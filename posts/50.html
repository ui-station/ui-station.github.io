<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/50" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/50" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="어려운 대화에서 효과적인 커뮤니케이션의 여섯 가지 규칙" href="/post/2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="어려운 대화에서 효과적인 커뮤니케이션의 여섯 가지 규칙" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="어려운 대화에서 효과적인 커뮤니케이션의 여섯 가지 규칙" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">어려운 대화에서 효과적인 커뮤니케이션의 여섯 가지 규칙</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Apache Airflow을 시작하는 방법 2024 최신 업데이트" href="/post/2024-05-27-HowtogetstartedwithApacheAirflow2024updated"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Apache Airflow을 시작하는 방법 2024 최신 업데이트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-HowtogetstartedwithApacheAirflow2024updated_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Apache Airflow을 시작하는 방법 2024 최신 업데이트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Apache Airflow을 시작하는 방법 2024 최신 업데이트</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="내일을 위한 솔루션을 만들어가는 과정 코딩대쉬 이야기" href="/post/2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="내일을 위한 솔루션을 만들어가는 과정 코딩대쉬 이야기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="내일을 위한 솔루션을 만들어가는 과정 코딩대쉬 이야기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">내일을 위한 솔루션을 만들어가는 과정 코딩대쉬 이야기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제트팩 컴포즈에서 스낵바를 어떻게 보여줄 수 있을까요" href="/post/2024-05-27-HowtoshowSnackbarinJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제트팩 컴포즈에서 스낵바를 어떻게 보여줄 수 있을까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제트팩 컴포즈에서 스낵바를 어떻게 보여줄 수 있을까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">제트팩 컴포즈에서 스낵바를 어떻게 보여줄 수 있을까요</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라라벨  플러터 플러터 앱을 라라벨 인증 API에 연결하기" href="/post/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라라벨  플러터 플러터 앱을 라라벨 인증 API에 연결하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라라벨  플러터 플러터 앱을 라라벨 인증 API에 연결하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">라라벨  플러터 플러터 앱을 라라벨 인증 API에 연결하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드 오토 튜토리얼 단계별 가이드" href="/post/2024-05-27-AndroidAutoTutorialStepbyStepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 오토 튜토리얼 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 오토 튜토리얼 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 오토 튜토리얼 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구" href="/post/2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 인터뷰 질문-제7파" href="/post/2024-05-27-iOSInterviewQuestions-Part7"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 인터뷰 질문-제7파" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-iOSInterviewQuestions-Part7_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 인터뷰 질문-제7파" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 인터뷰 질문-제7파</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고" href="/post/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI Photo Picker 앱을 PhotosUI로 만들기" href="/post/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI Photo Picker 앱을 PhotosUI로 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI Photo Picker 앱을 PhotosUI로 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI Photo Picker 앱을 PhotosUI로 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link posts_-active__YVJEi" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"어려운 대화에서 효과적인 커뮤니케이션의 여섯 가지 규칙","description":"","date":"2024-05-27 16:40","slug":"2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations","content":"\n![Six Rules of Effective Communication in Difficult Conversations](/assets/img/2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations_0.png)\n\n우리가 목표를 달성하기 위해서는 타인과 원할한 소통이 필요합니다. 그러나 중요한 순간에 건전한 대화를 나누는 대신에 우리는 종종 최악의 상태에 있습니다. 우리는 어리석고 비용이 드는 농담거리, 논쟁, 공격, 조종 또는 다른 자기패배적인 방식으로 행동합니다.\n\n어려운 대화는 본질적으로 까다로운 것입니다. 이야기하기를 원치 않는 민감한 주제들로 구성됩니다. 의견의 차이, 감정적 문제, 민감한 주제 또는 충돌의 잠재적인 원인들을 다뤄야 합니다 — 우리가 논하기 어려운 모든 것들을 포함합니다.\n\n어려운 대화는 불편함, 불확실성 및 복잡한 감정을 헤쳐나가야 하기 때문에 도전적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어려운 대화를 피하는 것이 감정적으로 지치고 정신적으로 지친 상황을 피하는 것보다 의식적으로 직면하는 것이 훨씬 더 쉽습니다.\n\n그러나 어려운 대화를 미루는 것은 좋지 않은 생각입니다. 왜냐하면:\n\n- 처리되지 않은 문제들은 시간이 지남에 따라 악화됩니다. 적절히 대처하지 않으면 처음에는 다룰만한 문제도 시간이 흐름에 따라 훨씬 큰 문제로 커질 수 있습니다.\n- 미해결된 문제에 대한 지속적인 걱정은 정신 건강에 해를 끼칠 수 있으며 스트레스, 불안, 심지어 무력감까지 증가시킬 수 있습니다.\n- 중요한 문제가 무시되거나 뒤로 밀리면 신뢰를 훼손하고 원한을 쌓고 관계를 손상시킬 수 있습니다.\n\n대화가 얼마나 어려워도 그것을 영원히 미루거나 지체할 수는 없습니다. 문제에 직접 대응하고 명료함을 제공하며 마무리를 찾는 것은 신뢰와 존중을 얻고 스트레스를 줄이는 데 도움이 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 어려운 대화를 잘 다루기 위해서는 좋은 커뮤니케이션 관행을 따라야 합니다. 어려운 대화에서 효과적인 커뮤니케이션의 여섯 가지 규칙은 다음과 같습니다:\n\n## 규칙 1: 개인적으로 대하지 마세요\n\n구체적인 행동에 대해 토론을 이어가세요. 그 사람에 대해 이야기하지 마세요. 대화 상대방은 여러분의 억지로 느껴질 정도의 판단과 몸짓을 통해 첫 몇 분 내에 여러분이 판단적이라는 것을 느낄 수 있습니다. 이로 인해 그들은 여러분이 마음을 바꿀 수 없다고 생각하고 말하는 것이 아무런 영향을 미칠 수 없다고 여겨 대화를 중단하거나 옳다고 주장하고 여러분이 틀렸다고 증명하기 위해 대화를 전환할 수 있습니다.\n\n여러분의 목적은 그들의 성격을 공격하거나 그들이 누구인지에 도전해 기분 나쁘게 만드는 것이 아닙니다. 이렇게 하면 그들의 자존심을 상처받아 여러분이 말하는 모든 것에 저항을 보이게 할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 규칙 2: 명확하고 간결한 커뮤니케이션 실천하기\n\n간결하게 유지하세요. 둘러대지 말고 바로 말해야 할 것을 말하세요. 불필요한 정보에 가라앉지 않도록 명확하게 해주어야 합니다. 몇 가지 예시를 들어주면, 상대방이 당신의 의견을 이해하고 그것을 설득력 있게 파악할 수 있도록 도울 수 있겠죠.\n\n상황: 당신의 매니저가 밤 늦게 전화해서 가족과 함께 보내는 저녁 시간을 방해합니다.\n\n예를 들어:\n그렇다고 떠들어대거나 분명히 그들의 걱정을 명확히 표현하지 않고 상대방이 줄줄알아야 한다고 기대하지 마세요.\n하지말라: 밤에 전화하는 것이 가족과 함께 시간을 보내기 어렵게 만들고, 왜 당신에게 그런 다운타임이 필요한지 설명해주세요.\n\n상황: 팀원이 타인의 아이디어와 의견을 무시하는 습관을 가지고 있습니다.\n\n예를 들어:\n다양한 시각을 추구하거나 토론에서 다른 사람들이 더 많이 참여하도록 장려하는 일반적인 조언을 공유하지 마세요. 그들은 그를 무시할 가능성이 높습니다.\n해주세요: 이전 토론이나 회의에서 그들이 다른 사람들의 의견을 무시한 사례를 공유하세요. 앞으로 어떻게 더 포용적일 수 있는지 물어보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상황: 자신이 받을 만한 좋은 기회를 놓치다.\n그 대신에: 자신이 원하는 것을 얻지 못한 데 대해 매니저에게 불평하거나 원망을 표현하는 대신에\n다음과 같이 해보세요: 실망을 표현하지만, 그들의 결정에 대해 존중을 보여주세요. 다음에 그런 기회를 얻을 수 있도록 어디가 부족한지 이해하려고 노력해보세요.\n\n## 규칙 3: 영향에 초점을 둬요, 감정이 아닌\n\n특정 행동, 행동, 또는 비활동의 영향을 설명하세요. 영향에 대해 이야기하면 다른 사람들이 해결책을 적극적으로 찾게 하는 뇌의 일부를 동원하게 됩니다. 이를 감정에 대한 것으록 만들면 다른 사람들이 명확하게 생각하지 못하도록 방해하고 상황을 이성적으로 판단하기 어렵게 만듭니다.\n\n- 직원이 일터에서 계속 모욕적 언어를 사용한다면, 혐오감을 표현하는 대신 협업에 어떻게 영향을 미치는지 설명해보세요.\n- 매니저가 1:1 미팅을 계속 취소한다면, 당황을 드러내는 대신 이러한 회의를 가지지 않는 것이 성장에 어떻게 제한이 되는지 설명해보세요.\n- 팀원이 당신의 아이디어에 대한 영괴를 독차지하려 한다면, 짜증내지 말고, 이런 행동을 계속하면 아이디어를 나누기를 중지할 것이라고 명확히 표현하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보편적으로 **잉크 테이블**은 데이터를 효율적으로 나타내기 위한 데 사용됩니다. 하지만 어떨 때는 이 테이블을 **마크다운** 형식으로 변경하고 싶을 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 그들의 우려나 오해에 대해 설명합니다 (하지 말아주세요: 당신이 의도하지 않은 내용).\n- 당신이 실제로 의도한 바를 명확히 합니다 (해주세요: 당신이 의도하는 내용).\n\n하지 말아주세요: 여러분이 제안한 아이디어가 논의할 가치가 있는 것이 아니라고 말하려는 게 아닙니다. 여러분이 제기한 많은 포인트가 극히 가치 있게 여겨집니다.\n해주세요: 하지만, 우리가 결정하기 전에 다른 대안도 고려하고 싶습니다.\n\n하지 말아주세요: 여러분의 작업이나 제안에 가치를 두지 않는 것이 아닙니다. 여러분의 연구가 방대하며 주요 분야를 모두 다루고 있다는 것을 알 수 있습니다.\n해주세요: 하지만, 최근 기업 전략의 변화를 고려하고 이 제안을 재평가하는 것이 유용할 것으로 생각합니다.\n\n하지 말아주세요: 저의 목표는 우리 지난 프로젝트에서 벌어진 실수에 대해 누군가를 탓하는 것이 아닙니다.\n해주세요: 저는 그 경험에서 배우고, 다시 일어나지 않도록 사전에 예방하는 방법을 살펴보려고 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 규칙 5: 먼저 이해하려고 하고 나중에 이해되려고 하세요\n\n당신의 의견을 듣기 원한다면, 상대방이 느끼고 이해되었다고 느끼게 하세요. 상대방의 의도를 가정하거나 강요하지 마세요. 상황을 보는 방식, 사고과정 또는 특정한 행동의 이유에 대해 공유할 수 있도록 허락하세요.\n\n전달하고자 하는 바를 반복하는 것은 반대 반응만 일으킬 뿐입니다. 상대방이 당신을 듣기 원한다면, 먼저 이해하려는 의도로 상대방을 들으며 상호 존중을 보여주세요.\n\n효과적인 청취를 연습하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 명확성을 강조하고 대화하도록하여 오픈 질문을 통해 이야기를 이끌어보세요.\n\n- “좀 더 자세히 말해봐요…”\n- “이해시켜 주세요…”\n- “그것을 나에게 설명해주세요…”\n- “어떻게 생각하세요…”\n- “당신이 어디서 오는 건지 이해하고 싶어요…”\n- “당신이 어떻게 보는지 조금 더 공유해 줄 수 있어요?”\n\n2. 말뿐만 아니라 비언어적 의사 소통에 초점을 맞춰보세요. 목소리 톤부터 제스처, 신체 언어까지 포함합니다.\n\n3. 메시지 전달을 위해 중단하거나 방어적인 태도를 취하지 마세요. 상대방이 말을 끝내면 당신이 전달하고 싶은 바를 솔직하게 말해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 눈에 띄려 하지 마세요. 대화는 당신에 대한 것이 아닙니다.\n\n5. 상대방의 감정과 견해를 인정해 주세요. 인정하는 것은 그들과 동의하는 것을 의미하지는 않으며, 단지 그들이 어떻게 느꼈는지 이해한다는 것을 의미합니다.\n\n- \"당신이 말한 것으로 보아, 당신이 압도되는 느낌인 것으로 이해해요.\"\n- \"당신이 이 문제로 스트레스를 받고 있는 것을 알겠어요.\"\n- \"제가 당신을 올바르게 이해했다면, 지금은 이유로 인해 화가 나신 것 같으세요.\"\n\n6. 현재 대화와 관련된 주제에 대해 논의하세요. 주제를 벗어나지 말고 진로를 유지하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 규칙 6: 평정 유지\n\n상대방이 방어적이거나 과잉 반응하는 경우에도 그에 반응하지 마세요. 차분함을 유지하고, 대조를 통해 대화를 복원하고, 질문을 하며 그들의 생각과 감정을 이해하려 노력하세요.\n\n대화를 유익하게 만들기 위해 다양한 전략을 시도하더라도 상황이 변하지 않거나 악화된다면 상대방에게 휴식을 취하고 다른 시간에 다시 모이도록 제안하세요.\n\n예를 들어, 다음과 같이 말할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 우리가 논의한 내용을 처리하는 데 더 많은 시간이 필요한 것 같아요. 생각해 본 후에 다시 만나는 것은 어떠세요?\n- 우리가 논의한 것에 대해 생각해 볼 시간을 가지면 도움이 될까요? 언제든 다시 만날 수 있습니다.\n\n다른 사람들이 과도하게 반응하거나 정보를 이해하는 방식이 예상과 다르다고 화를 내면 오히려 상황을 악화시킬 뿐입니다. 상대에게 공간과 시간을 주어 우려를 다루도록 해보세요.\n\n## 요약\n\n- 필수적이지만 어려운 대화는 깨기 어렵습니다. 나쁜 결과를 두려워하거나 무엇을 말할지 모르는 것이 바로 필요한 순간에 의미 있는 대화에 참여하지 못하게 만들 수 있습니다.\n- 다루지 않으면 갈등은 악화됩니다. 어려운 대화를 피하거나 미루는 만큼 나중에 해결하기가 더욱 어려워집니다.\n- 상대방의 성품을 비난하거나 강한 판단을 내리면 반드시 나쁘게 반응하고 방어적으로 나서게 됩니다. 개인적인 공격 대신 걱정되는 구체적인 행동이나 행동에 대해 대화하세요.\n- 너무 많은 정보는 상대방을 심심하게 만들고, 너무 적은 정보는 혼란스럽게 만듭니다. 좋은 커뮤니케이션은 명확하고 간결하며 핵심적입니다. 이해하고 행동하기 쉽도록 의견을 표현하세요.\n- 표현은 건강한 표현은 하지만 당신의 유일한 방어 수단이 되어서는 안 됩니다. 영향을 명확히 표현하는 것은 중요합니다. 문제를 해결하고 표준 솔루션에 동의하기 위해 필요한 뇌의 사고 부분을 활성화합니다.\n- 어려운 대화에서의 선의는 충분하지 않습니다. 명시적으로 표현해야 합니다. 다른 사람이 당신의 목적과 일치하면 건강한 이야기를 나누고 해결책을 찾기가 쉬워집니다.\n- 우리는 어려운 대화가 우리의 의견을 공유하고 기대를 밝히며 불만을 표현하는 것이라고 생각합니다. 그러나 모든 말을 할 때 중요한 것을 잊어버립니다-다른 사람의 견해를 듣고 높이 평가하는 것.\n- 마지막으로 일부 문제가 될 수 있는 대화는 폭력적이거나 공격적일 수 있습니다. 이런 순간에 침착함을 잃는다면 상황을 더욱 악화시킬 수 있습니다. 나중에 연결하라고 상대방에게 요청하여 긴장을 풀어보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기와 LinkedIn에서 더 많은 이야기를 읽어보세요. 이 이야기는 원래 https://www.techtello.com에서 발행되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations_0.png"},"coverImage":"/assets/img/2024-05-27-SixRulesofEffectiveCommunicationinDifficultConversations_0.png","tag":["Tech"],"readingTime":9},{"title":"Apache Airflow을 시작하는 방법 2024 최신 업데이트","description":"","date":"2024-05-27 16:38","slug":"2024-05-27-HowtogetstartedwithApacheAirflow2024updated","content":"\n\u003cimg src=\"/assets/img/2024-05-27-HowtogetstartedwithApacheAirflow2024updated_0.png\" /\u003e\n\n- 노트북을 열어주세요\n- 터미널을 열어주세요\n- 아래 코드를 실행해주세요\n\n```js\npip uninstall apache-airflow\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:534/0*iDdoQ91AdPvPcWGm.gif\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n죄송해요 — 이걸 쓸 때는 금요일이었어요!\n\nOrchestra를 시도해보세요 🚀\n\n(검색 엔진 최적화를 위해 추가한 내용입니다)\n\n# Apache Airflow은 쉽게 배울 수 있나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아파치 에어플로우는 특히 초보자에게는 어느 정도의 도전이 될 수 있지만, 일부 필수적인 개념과 도구에 익숙해지면 더 쉬워집니다. 에어플로우를 배우기 위해 알아야 할 내용과 학습이 쉬운 또는 어려운 이유를 살펴보겠습니다:\n\n# 전제 조건\n\n- 파이썬: 에어플로우는 파이썬으로 작성되었으므로, 파이썬에 대한 탄탄한 이해가 필수적입니다.\n- 명령줄 인터페이스 (CLI): 명령줄 사용에 대한 기본 지식은 에어플로우의 설치와 구성에 도움이 됩니다.\n- SQL: SQL을 알고 있는 것은 에어플로우가 데이터베이스와 상호 작용하는 경우가 많으므로 유용합니다.\n- 예약 개념: 작업 예약 및 워크플로 관리의 기본 개념을 이해하는 것이 중요합니다.\n\n# 학습 곡선\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 초기 설정: Airflow를 설정하는 것은 여러 구성 요소(Web 서버, 스케줄러, 메타데이터 데이터베이스 등) 때문에 약간 복잡할 수 있어요.\n- DAGs (Directed Acyclic Graphs): Airflow의 핵심 개념은 DAGs를 중심으로 돌아갑니다. DAGs를 정의하고 관리하는 방법을 익히는 데는 시간이 필요하죠.\n- Operators와 Hooks: Airflow는 작업을 정의하고 다양한 시스템에 연결하기 위해 operators와 hooks를 사용해요. 이들의 다양성과 사용 사례를 이해하는 것은 처음에는 압도될 수 있어요.\n- 설정 및 배포: Airflow를 다른 환경(로컬, 온프레미스, 클라우드)에서 실행하도록 설정하는 것은 복잡성을 더합니다.\n\n# 학습 자료\n\n- 문서: 공식 Airflow 문서는 포괄적이며 좋은 시작점입니다.\n- 온라인 튜토리얼과 강의: Udemy, Coursera 등에서 온라인 튜토리얼, 강의, YouTube 비디오들이 Airflow의 기본을 안내해줄 수 있어요.\n- 커뮤니티와 포럼: 포럼, GitHub 이슈, Stack Overflow를 통해 Airflow 커뮤니티와 소통하면 일반적인 문제에 대한 가치 있는 통찰과 해결책을 얻을 수 있어요.\n- 책: “Data Pipelines with Apache Airflow”와 같은 책들은 체계적인 학습을 제공할 수 있어요.\n\n# 실용적인 팁\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 간단히 시작하기: 간단한 DAG부터 시작하여 점차 복잡성을 높여가세요.\n- 실습 중심: 더 많이 연습할수록 더 편안해질 거에요. 작은 프로젝트를 만들어보거나 예제를 복제해보세요.\n- 예제 탐색: 예제 DAG 및 일반 패턴을 검토하면 많은 실용적인 통찰력을 얻을 수 있어요.\n- 관리 서비스 사용: Apache Airflow 설정이 어렵게 느껴진다면 Google Cloud Composer나 Amazon Managed Workflows for Apache Airflow와 같은 관리 서비스 사용을 고려해보세요.\n\n# 요약\n\n- 학습 용이성: 중간 정도의 난이도로 Python 및 관련 도구에 익숙해야 합니다.\n- 학습 경로: 문서로 시작하여 튜토리얼을 사용하고 커뮤니티와 정기적인 실습을 통해 참여하세요.\n- 복잡성: 사용 사례에 따라 다를 수 있으며, 간단한 DAG가 쉽지만 복잡한 워크플로 및 배포에 더 많은 노력이 필요합니다.\n\n전반적으로 Apache Airflow에는 학습 곡선이 있지만 자원과 커뮤니티 지원이 많아 프로세스가 보다 원활해질 수 있습니다. 일관된 연습과 탐색을 통해 Airflow를 숙달하는 것은 분명히 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Apache Airflow을 시작하는 방법은?\n\n오픈 소스라서 도커, 쿠버네티스를 배우고 다운로드하여 적극 활용해보세요:\n\nApache Airflow를 시작하려면 로컬 머신 또는 서버에 설치하고 설정하는 방법을 따르면 됩니다. 아래는 시작하는 데 도움이 되는 기본 가이드입니다:\n\n# 1. Apache Airflow 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 준비 사항:\n\n- Python: Python이 설치되어 있는지 확인해주세요 (버전 3.6 이상).\n- 가상 환경: 충돌을 피하기 위해 가상 환경을 만드는 것이 좋은 습관입니다.\n\n## 설치 단계:\n\n- 가상 환경 만들기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\npython -m venv airflow_env source airflow_env/bin/activate # Windows에서는 `airflow_env\\Scripts\\activate`를 사용하십시오\n\n- Apache Airflow 설치: Apache Airflow는 호환 가능한 종속성을 지정하기 위해 constraints 파일을 사용합니다. 아래 명령어를 사용하여 설치할 수 있습니다:\n\n```bash\nexport AIRFLOW_VERSION=2.5.0\nexport PYTHON_VERSION=\"$(python --version | cut -d \" \" -f 2 | cut -d \".\" -f 1-2)\"\nexport CONSTRAINT_URL=\"https://raw.githubusercontent.com/apache/airflow/constraints-${AIRFLOW_VERSION}/constraints-${PYTHON_VERSION}.txt\"\npip install \"apache-airflow==${AIRFLOW_VERSION}\" --constraint \"${CONSTRAINT_URL}\"\n```\n\n# 2. 데이터베이스 초기화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAirflow은 작업 인스턴스 및 다른 메타데이터를 추적하는 데 데이터베이스를 사용합니다. Airflow를 실행하기 전에 데이터베이스를 초기화해야 합니다.\n\n```js\nairflow db init\n```\n\n# 3. 관리자 사용자 만들기\n\nAirflow 웹 인터페이스에 액세스할 수 있는 관리자 사용자를 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n에어플로우 사용자 생성 \\\n   --username admin \\\n   --firstname 당신의_이름 \\\n   --lastname 당신의_성 \\\n   --role Admin \\\n   --email 당신의_이메일\n```\n\n당신의 성, 이름 및 admin@example.com을 여러분의 정보로 대체하세요.\n\n# 4. 에어플로우 웹 서버 및 스케쥴러 시작\n\n- 웹 서버 시작:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 첫 번째 터미널 창에서:\nairflow webserver --port 8080\n\n# 두 번째 터미널 창에서:\nairflow scheduler\n```\n\n# 5. Airflow UI에 액세스하기\n\n웹 브라우저를 열고 http://localhost:8080로 이동하세요. 이전에 생성한 관리자 자격 증명을 사용하여 로그인할 수 있습니다.\n\n# 6. 첫 번째 DAG(Directed Acyclic Graph) 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDAG은 실행하려는 작업을 관계와 종속성을 반영하는 방식으로 구성된 작업 모음입니다.\n\n- DAG 파일 생성: dags 디렉토리에 새 Python 파일을 생성합니다 (일반적으로 ~/airflow/dags에 위치).\n\n```python\n# ~/airflow/dags/example_dag.py\nfrom airflow import DAG\nfrom airflow.operators.dummy_operator import DummyOperator\nfrom datetime import datetime\n\ndefault_args = {\n    'owner': 'airflow',\n    'start_date': datetime(2023, 1, 1),\n    'retries': 1,\n}\n\ndag = DAG(\n    'example_dag',\n    default_args=default_args,\n    description='간단한 예제 DAG',\n    schedule_interval='@daily',\n)\n\nstart = DummyOperator(task_id='start', dag=dag)\nend = DummyOperator(task_id='end', dag=dag)\n\nstart \u003e\u003e end\n```\n\n- 파일 저장: 이 파일을 example_dag.py로 저장하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7. Airflow UI에서 DAG 확인하기\n\nDAG 파일을 저장한 후 Airflow UI로 이동하면 새로운 DAG가 목록에 표시됩니다. 수동으로 트리거하거나 정의된 일정에 따라 자동으로 트리거될 수 있습니다.\n\n# 추가 자료\n\n- 공식 문서: Apache Airflow 문서\n- 튜토리얼 및 가이드: 여러 온라인 튜토리얼이 특정 사용 사례 및 고급 구성에 도움이 될 수 있습니다.\n- 커뮤니티 지원: Airflow의 Slack 채널이나 다른 커뮤니티 포럼에 가입하여 지원 및 네트워킹을 할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 단계를 따라하면 Apache Airflow를 설정하고 실행하여 자체 워크플로를 만들고 관리할 수 있을 것입니다.\n\n## Airflow을 사용하려면 코딩이 필요한가요?\n\n당연히 그렇죠. Python 및 OOP 지식이 필요합니다. 또한 CI/CD, 약간의 terraform 및 Kubernetes도 필요합니다!\n\n## Apache Airflow를 배우는 데 얼마나 시간이 걸릴까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n너무 길어요. 궁금하다면, Orchestra를 사용해보세요. 누구나 사용할 수 있고 기업용 오케스트레이터 및 감시 도구의 모든 기능을 가지고 있지만 수고를 덜 수 있어요.\n","ogImage":{"url":"/assets/img/2024-05-27-HowtogetstartedwithApacheAirflow2024updated_0.png"},"coverImage":"/assets/img/2024-05-27-HowtogetstartedwithApacheAirflow2024updated_0.png","tag":["Tech"],"readingTime":9},{"title":"내일을 위한 솔루션을 만들어가는 과정 코딩대쉬 이야기","description":"","date":"2024-05-27 16:37","slug":"2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory","content":"\n디지털 랜드스케이프가 끊임없이 변화하는 시대에는 혁신, 민첩성, 그리고 신기술에 대한 심도 있는 이해가 필수적입니다. Codedash는 AI 기반의 사용자 중심 접근 방식을 활용하여 웹, 모바일 및 서버 개발 솔루션 분야에서 선두주자로서 비즈니스의 미래를 형성합니다.\n\n![Codedash 이미지](/assets/img/2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory_0.png)\n\n## 우리는 누구인가\n\nCodedash에서 우리는 단순히 기술 회사가 아닙니다. 오늘날 기업이 직면한 독특한 과제에 대처하는 맞춤형 솔루션을 만드는 데 헌신된 노련한 전문가들의 팀입니다. 우리의 미션은 조직이 장기적인 성공을 보장하는 확장 가능하고 적응 가능하며 미래지향적인 솔루션을 통합함으로써 기관을 더 강력하게 만드는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 우리의 철학: 협업과 민첩성\n\n협업은 우리의 접근법의 핵심에 있습니다. 우리는 최고의 해결책이 나오는 것은 우리가 우리의 고객들과 밀접하게 협력하여 그들의 요구를 이해하고 그들의 목표와 전략을 조화시킬 때라고 믿습니다. 이 협업적인 정신은 우리가 차별화된 솔루션을 제공할 수 있도록 해줍니다.\n\n민첩성은 우리 철학의 또 다른 기반입니다. 급변하는 기술적 풍경 속에서 적응하고 발전하는 능력은 중요합니다. Codedash에서는 우리의 솔루션이 효과적일 뿐만 아니라 비즈니스와 함께 성장할 수 있도록 충분히 유연하도록 확실한 방법론을 받아들입니다.\n\n## 우리의 솔루션: 미래를 위해 설계되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당사는 비즈니스 운영을 높이고 성장을 촉진하기 위해 설계된 혁신적인 제품 스위트를 제공합니다:\n\n- Dashpad: 휴가 및 출석 추적부터 내장된 채팅 기능을 통한 즉각적인 의사 소통을 용이하게 하는 탁월한 올인원 앱입니다. 작업 추적을 위한 사용자 정의 보드를 갖춘 Dashpad는 생산성과 조직을 향상시켜 실수 없이 모든 것이 원활하게 이루어집니다.\n- DrawDash: 창의력을 발휘할 수 있는 스케치, 그림, 그리기 앱인 DrawDash입니다. 직관적인 사용자 인터페이스, 실행 취소/다시 실행 기능 및 깊이를 위한 다중 레이어를 통해, DrawDash는 예술가와 디자이너가 자신의 비젼을 현실로 구현할 수 있도록 돕습니다.\n- Dashnotes: 당신의 생각을 손쉽게 정리하는 다목적 노트 앱인 Dashnotes입니다. 프로젝트를 관리하는 전문가, 시험 공부를 하는 학생 또는 창의적인 아이디어를 메모하는 사람이라도, Dashnotes는 풍부한 텍스트 편집, 개인 노트 및 미디어 통합을 통해 포괄적인 노트 작성 경험을 제공합니다.\n\n## 왜 Codedash를 선택해야 하는가?\n\n전문지식과 혁신성: 당사 팀은 기술과 혁신에 열정적인 전문가들로 구성되어 있습니다. 우리는 업계 동향을 선행하여 고객들에게 경쟁 우위를 제공하는 첨단 솔루션을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자 중심 디자인: 저희의 솔루션은 사용자를 염두에 두고 디자인되었습니다. 우리는 사용자 경험을 우선시하여 제품이 기능적일 뿐만 아니라 직관적이고 사용하기 즐겁도록 보장합니다.\n\n품질에 대한 약속: Codedash에서는 품질을 타협할 수 없습니다. 우리는 최고의 탁월성 기준을 준수하여 신뢰할 수 있는 견고하고 신뢰할 수 있는 솔루션을 제공합니다.\n\n## 우리의 미래를 위한 비전\n\n우리가 미래를 바라보며, 우리의 비전은 기술 분야에서 가능한 한 한계를 뛰어넘기를 계속하는 것입니다. 우리는 디지털 전환의 선두에 서 있어 기업이 디지털 시대의 복잡성을 자신 있게 해결하도록 지원합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 우리의 여정에 참여하세요\n\n혁신과 성장으로 가득한 이 흥미진진한 여정에 여러분을 초대합니다. 혁신적인 솔루션을 찾는 비즈니스이거나 최신 기술에 관심이 많은 팬이든, Codedash가 여러분을 이끌어 나갈 것입니다.\n\n저희와 연락을 유지하시고, 제품을 살펴보며 Codedash가 여러분의 비즈니스를 변화시킬 수 있는 방법을 알아보세요. 함께하여 우리는 내일의 솔루션을 오늘 만들어 갈 수 있습니다.\n\n더 많은 정보를 원하신다면, 저희 웹사이트인 Codedash를 방문해 주세요.\n","ogImage":{"url":"/assets/img/2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory_0.png"},"coverImage":"/assets/img/2024-05-27-CraftingTomorrowsSolutionsTodayTheCodedashStory_0.png","tag":["Tech"],"readingTime":4},{"title":"제트팩 컴포즈에서 스낵바를 어떻게 보여줄 수 있을까요","description":"","date":"2024-05-27 16:36","slug":"2024-05-27-HowtoshowSnackbarinJetpackCompose","content":"\n안녕하세요! 아래는 Markdown 형식으로 변경된 테이블 태그입니다.\n\n![Jetpack Compose Snackbar](/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_0.png)\n\n저는 Snackbars에 대해 쓸 예정이며, Jetpack Compose에서 가장 쉬운 방법을 소개해 드릴 예정입니다.\n\n따라서, 이어서 용어를 명확히 정리하면서 시작해 보겠습니다.\n\n# Snackbars란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스낵바는 앱 내부에서 어떤 것에 대한 경량화된 피드백을 제공하는 UI 구성 요소입니다. 기본적으로는 앱이 수행했거나 수행할 작업에 대해 사용자에게 간단히 알려주는 메시지입니다.\n\n![스낵바 이미지](/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_1.png)\n\n이들은 임시로 표시되며 시간이 지나거나 사용자 상호 작용 후에 자동으로 사라집니다. 스낵바에는 텍스트 버튼을 통해 액세스할 수 있는 단일 작업이 포함될 수 있습니다. 일반적으로 \"다시 시도\" 또는 \"실행 취소\"와 같은 내용입니다. 그리고 사용자 경험을 중단시키지 않아야 합니다.\n\n# 구현\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n젯팩 콤포즈에서 스낵바가 구현되는 방법을 살펴봅시다. 기본적으로, 주요 구성 요소는 3가지입니다.\n\n- 스낵바 코포저블은 보여주거나 숨기는 옵션이나 애니메이션 없이 머터리얼 디자인 가이드라인에 정의된 스낵바의 시각적 표현에 불과합니다.\n- 스낵바 호스트는 스낵바의 표시 및 숨김, 그리고 애니메이션을 담당하는 구성 요소입니다. 이는 이전에 언급한 스낵바를 감싸는 UI 래퍼입니다.\n- 스낵바 호스트 상태는 스낵바 호스트 내에 표시되는 현재 스낵바 및 나중에 표시할 스낵바 대기열을 제어합니다. 한 번에 최대 하나의 스낵바만 표시할 수 있도록 보장합니다.\n  showSnackbar()라는 중단 메서드가 있어 새로운 스낵바를 표시할 수 있습니다.\n\n자, 이제 스낵바가 무엇이며 어떻게 구현되는지 명확해졌습니다. 처음에 말한대로 최선의 방법으로 표시하는 방법을 보여드리도록 하겠습니다. 하지만 먼저, 스카폴드를 간단히 소개하겠습니다.\n\n# 스카폴드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nScaffold는 기본적인 머티리얼 디자인 레이아웃 구조를 구현하는 레이아웃입니다. TopBar, BottomBar, Floating Action Button (FAB) 또는 Drawer와 같은 요소를 추가할 수 있습니다.\n\n![image](/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_2.png)\n\nScaffold는 모든 것이 머티리얼 디자인 가이드에 따라 올바른 위치에 함께 표시되도록 합니다.\n\n위에서 보듯이, Scaffold composable에는 SnackbarHostState와 Snackbar Host와 같은 다양한 매개변수가 포함되어 있습니다. 이러한 지식을 바탕으로 코드를 작성할 준비가 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 코드\n\nScaffold와 버튼이 있는 Composable을 사용하여 시작해봅시다. 사용자가 버튼을 누르면 스낵바가 표시되어야 합니다.\n\n```js\n@Composable\nfun SnackbarDemo() {\n    Scaffold() {\n        Button(onClick = {})\n        {\n            Text(text = \"Click me!\")\n        }\n    }\n}\n```\n\n우리는 \"remember\" 메서드 내에 기본 ScaffoldState를 생성하여 재구성 후에도 동일한 상태를 사용할 수 있도록합니다. 앞서 언급했듯이, ScaffoldState에는 새로운 스낵바를 표시하는 데 사용할 수있는 SnackbarHostState가 포함되어 있습니다. 메시지 또는 작업 레이블과 같은 필요한 매개변수를 제공해야합니다. 그러나 snowSnackbar은 일시 중단된 함수이므로 직접 호출할 수는 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun SnackbarDemo() {\n    val scaffoldState: ScaffoldState = rememberScaffoldState()\n    val coroutineScope: CoroutineScope = rememberCoroutineScope()\n\n    Scaffold(scaffoldState = scaffoldState) {\n        Button(onClick = {\n            coroutineScope.launch {\n                scaffoldState.snackbarHostState.showSnackbar(\n                    message = \"This is your message\",\n                    actionLabel = \"Do something\"\n                )\n            }\n        }) {\n            Text(text = \"Click me!\")\n        }\n    }\n}\n```\n\n버튼을 누를 때마다 스낵바가 화면에 나타날 것입니다. 그러나 스낵바가 사라졌는지, 사용자가 스낵바의 액션을 클릭했는지 알 수 없습니다.\n\n이 문제를 해결하기 위해 현재 스레드를 차단하지 않고 새로운 코루틴을 시작하는 코루틴 범위를 사용합니다. 이제 버튼을 누르면 스낵바가 화면에 나타나야 합니다.\n\n표시된 스낵바가 해제되었는지, 사용자가 스낵바의 액션을 클릭했는지 확인하려면 중단된 함수에 의해 반환된 SnackbarResult를 확인하면 됩니다. SnackbarResult는 Dimissined 또는 ActionPerformed 값을 갖는 enum이며 업무 로직을 이에 따라 구현할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun SnackbarDemo() {\n    val scaffoldState: ScaffoldState = rememberScaffoldState()\n    val coroutineScope: CoroutineScope = rememberCoroutineScope()\n\n    Scaffold(scaffoldState = scaffoldState) {\n        Button(onClick = {\n            coroutineScope.launch {\n                val snackbarResult = scaffoldState.snackbarHostState.showSnackbar(\n                    message = \"This is your message\",\n                    actionLabel = \"Do something\"\n                )\n                when (snackbarResult) {\n                    SnackbarResult.Dismissed -\u003e TODO()\n                    SnackbarResult.ActionPerformed -\u003e TODO()\n                }\n            }\n        }) {\n            Text(text = \"Click me!\")\n        }\n    }\n}\n```\n\n구현 내용을 확인하려면 YouTube 비디오를 참조하십시오. 전체 튜토리얼과 최종 결과를 녹화한 영상이 있습니다.\n\n이 기사가 마음에 드시면 좋아요를 눌러 주시고 피드백을 남기시고 친구들과 공유해 주세요. 즐거운 코딩되세요!\n","ogImage":{"url":"/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-27-HowtoshowSnackbarinJetpackCompose_0.png","tag":["Tech"],"readingTime":6},{"title":"라라벨  플러터 플러터 앱을 라라벨 인증 API에 연결하기","description":"","date":"2024-05-27 16:35","slug":"2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI","content":"\n![Screenshot](/assets/img/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI_0.png)\n\n플러터(Flutter)는 네이티브 컴파일된 애플리케이션을 구축하기 위한 인기 있는 오픈 소스 프레임워크로, 라라벨(Laravel)은 안전하고 확장 가능한 백엔드 솔루션을 제공하는 강력한 PHP 기반 웹 프레임워크입니다.\n\n이 글에서는 플러터 애플리케이션과 라라벨 REST API를 통합하는 과정을 탐색하고, 안전한 사용자 인증 구현을 포함할 것입니다.\n\n# [0] 인증 API가 포함된 라라벨 프로젝트 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 글을 따라하거나 빠른 시작 프로젝트를 다운로드하세요.\n\n# [1] Flutter 프로젝트 생성하기\n\n## [1.1] 기본 Flutter 프로젝트 생성\n\n...다음 기본 설정으로.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(파일 → pubspec.yaml)\n\n```yaml\nversion: 1.0.0+1\nenvironment:\n  sdk: \"\u003e=2.18.2 \u003c3.0.0\"\ndependencies:\n  flutter:\n    sdk: flutter\n  cupertino_icons: ^1.0.2\n  dio: ^4.0.0\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_lints: ^2.0.0\nflutter:\n  uses-material-design: true\n```\n\n## [1.2] dio 패키지 추가\n\ndio.dart 패키지는 Dart용 인기있는 HTTP 클라이언트 라이브러리로, Flutter 애플리케이션에서 일반적으로 사용됩니다. 이는 HTTP 요청을 만들고 응답을 처리하며, 가로채기, 헤더 및 기타 고급 기능을 관리하기 위한 간단하고 직관적인 API를 제공하는 유연한 HTTP 클라이언트입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\npubspec.yaml 파일을 업데이트해주세요:\n\n```yaml\ndependencies:\n  dio: ^4.0.6\n```\n\n## [1.3] Auth 서비스 생성\n\n(파일 →lib/services/auth_service.dart)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport 'package:dio/dio.dart';\n\nclass AuthService {\n  final _dio = Dio(\n    BaseOptions(\n      baseUrl: 'https://demo.razzi.my/lara11breeze/public/api',\n      headers: {\n        'Accept': 'application/json',\n      },\n    ),\n  );\n\n  Future\u003cMap\u003cString, dynamic\u003e\u003e login(String email, String password) async {\n    final response = await _dio.post('/login', data: {\n      'email': email,\n      'password': password,\n    });\n    return response.data;\n  }\n\n  Future\u003cMap\u003cString, dynamic\u003e\u003e register(\n    String name,\n    String email,\n    String password,\n  ) async {\n    final response = await _dio.post('/register', data: {\n      'name': name,\n      'email': email,\n      'password': password,\n    });\n    return response.data;\n  }\n\n  Future\u003cMap\u003cString, dynamic\u003e\u003e logout() async {\n    final response = await _dio.post('/logout');\n    return response.data;\n  }\n}\n```\n\n코드 설명:\n\n1] dio/dio.dart 패키지 가져오기: 이 import 문은 dio.dart 패키지에서 HTTP 요청을 수행하는 데 사용되는 주요 클래스인 Dio 클래스를 가져옵니다.\n\n2] Dio 인스턴스 초기화: 클래스에는 Dio 인스턴스로 초기화된 private \\_dio 필드가 있습니다. BaseOptions 매개변수를 사용하여 HTTP 요청의 기본 URL 및 기본 헤더를 구성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- baseUrl: `https://demo.razzi.my/lara11breeze/public/api`: 이 설정은 API의 기본 URL을 설정합니다. 이 경우에는 지정된 URL에서 호스팅되는 데모 라라벨 API입니다.\n- headers: ' `Accept`: `application/json` ': 이 설정은 기본 `Accept` 헤더를 `application/json`으로 설정합니다. 이는 API가 JSON 응답을 반환해야 함을 나타냅니다.\n\n3] 로그인 메서드: 로그인 메서드는 이메일과 비밀번호를 인수로 취하며, `_dio.post` 메서드를 사용하여 /login 엔드포인트로 POST 요청을 보냅니다. 요청 데이터는 데이터 매개변수를 통해 맵으로 전달됩니다.\n\n4] 등록 메서드: 등록 메서드는 이름, 이메일 및 비밀번호를 인수로 취하며, `_dio.post` 메서드를 사용하여 /register 엔드포인트로 POST 요청을 보냅니다. 요청 데이터는 데이터 매개변수를 통해 맵으로 전달됩니다.\n\n5] 로그아웃 메서드: 로그아웃 메서드는 `_dio.post` 메서드를 사용하여 /logout 엔드포인트로 POST 요청을 보냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## [1.4] 로그인 화면 생성\n\n(파일 → lib/login_screen.dart)\n\n```js\nimport 'package:flutter/material.dart';\nimport 'services/auth_service.dart';\n\nclass LoginScreen extends StatefulWidget {\n  @override\n  _LoginScreenState createState() =\u003e _LoginScreenState();\n}\n\nclass _LoginScreenState extends State\u003cLoginScreen\u003e {\n  final _authService = AuthService();\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n\n  Future\u003cvoid\u003e _login() async {\n    final email = _emailController.text;\n    final password = _passwordController.text;\n\n    try {\n      final response = await _authService.login(email, password);\n      // 응답 처리, 예를 들어 액세스 토큰 및 사용자 데이터 저장\n      print(response);\n    } catch (e) {\n      // 오류 처리\n      print(e);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Login'),\n      ),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Column(\n          children: [\n            TextField(\n              controller: _emailController,\n              decoration: InputDecoration(\n                hintText: 'Email',\n              ),\n            ),\n            SizedBox(height: 16.0),\n            TextField(\n              controller: _passwordController,\n              obscureText: true,\n              decoration: InputDecoration(\n                hintText: 'Password',\n              ),\n            ),\n            SizedBox(height: 16.0),\n            ElevatedButton(\n              onPressed: _login,\n              child: Text('Login'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n코드 설명:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1] 의존성 가져오기: 이 코드는 핵심 Flutter UI 위젯을 제공하는 flutter/material.dart 패키지와 AuthService 클래스를 포함하는 auth_service.dart 파일을 가져옵니다.\n\n2] LoginScreen 위젯: LoginScreen은 StatefulWidget으로 정의되어 있어 변경 가능한 상태를 가질 수 있습니다.\n\n3] \\_LoginScreenState 클래스: \\_LoginScreenState 클래스는 LoginScreen 위젯의 내부 상태 클래스입니다. 다음을 포함합니다:\n\n- \\_authService: 로그인 작업을 수행하는 데 사용되는 AuthService 클래스의 인스턴스입니다.\n- \\_emailController 및 \\_passwordController: 이메일 및 비밀번호 필드의 입력 값을 관리하는 두 TextEditingController 인스턴스입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4] \\_login 메서드: \\_login 메서드는 사용자가 \"로그인\" 버튼을 탭했을 때 호출되는 비동기 함수입니다. 다음을 수행합니다:\n\n- 각각의 TextEditingController 인스턴스에서 이메일과 비밀번호 값을 가져옵니다.\n- \\_authService 인스턴스의 login 메서드를 호출하여 이메일과 비밀번호를 전달합니다.\n- login 메서드로부터 예상되는 데이터 맵(예: 사용자의 액세스 토큰 및 기타 데이터)를 처리합니다.\n- 오류가 발생하면 콘솔에 오류를 출력합니다.\n\n5] build 메서드: build 메서드는 LoginScreen 위젯의 UI를 정의합니다. 앱 바와 다음을 포함하는 본문이 있는 Scaffold 위젯을 생성합니다:\n\n- 이메일과 비밀번호 입력을 위한 두 개의 TextField 위젯이 있으며, 각각의 TextEditingController 인스턴스가 연결되어 있습니다.\n- 텍스트 필드와 로그인 버튼 사이에 간격을 추가하기 위한 SizedBox가 있습니다.\n- 눌렸을 때 \\_login 메서드를 호출하는 ElevatedButton 위젯이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## [1.5] 메인 업데이트\n\n(파일 → lib/main.dart)\n\n```js\nimport 'package:flutter/material.dart';\nimport 'login_screen.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({key}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: '플러터 앱!!',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSwatch(primarySwatch: Colors.indigo),\n        useMaterial3: true,\n        brightness: Brightness.light,\n      ),\n      darkTheme: ThemeData(\n        colorScheme: ColorScheme.fromSwatch(primarySwatch: Colors.blue),\n        useMaterial3: true,\n        brightness: Brightness.dark,\n      ),\n      home: LoginScreen(),\n      debugShowCheckedModeBanner: false,\n    );\n  }\n}\n```\n\n이제 플러터 앱을 실행하면 MyHomePage 위젯이 아닌 LoginScreen이 표시됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인증 기능을 더 강화하기 위해 더 많은 화면을 추가할 수 있습니다. 예를 들어, 등록 화면, 비밀번호 재설정 화면, 그리고 로그인에 성공한 후에 표시되는 홈 화면 등을 추가할 수 있습니다. 또한 사용자 인증 상태와 세션 관리를 다루는 로직을 추가할 수도 있습니다.\n\n# [2] 테스트\n\nFlutter 앱을 실행하세요.\n\n1] 로그인 화면에서 Laravel 사용자의 이메일과 비밀번호를 입력하세요. 로그인 버튼을 누르세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2] 로그를 확인하세요. 모든 것이 잘 작동되면 아래와 같이 응답이 출력됩니다. 응답에는 사용자 토큰이 포함되어 있는데, 이를 이후 요청에 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI_1.png)\n\n# 다운로드\n\n[링크](https://archive.org/download/laravelprojects/lara11breeze_userapi_flutter_20240409.zip)\n","ogImage":{"url":"/assets/img/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI_0.png"},"coverImage":"/assets/img/2024-05-27-LaravelFlutterConnectingFlutterApptoLaravelAuthAPI_0.png","tag":["Tech"],"readingTime":10},{"title":"안드로이드 오토 튜토리얼 단계별 가이드","description":"","date":"2024-05-27 16:33","slug":"2024-05-27-AndroidAutoTutorialStepbyStepGuide","content":"\n![Android Auto](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_0.png)\n\n# 안드로이드 오토란?\n\n안드로이드 오토는 안드로이드 폰과 안드로이드 오토 앱을 가진 사용자들을 위한 운전자 최적화 앱 경험을 제공합니다. 호환되는 자동차에 연결된 안드로이드 스마트폰의 확장판으로, 일부 앱, 엔터테인먼트, 그리고 자동차 대시보드에 메시지를 표시할 수 있습니다. USB 또는 블루투스를 사용하여 기기를 연결할 수 있습니다.\n\n![Android Auto Tutorial Step by Step Guide](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n차량에 핸드폰을 연결하면 모든 Android Auto 호환 앱을 사용할 수 있습니다.\n\n# Android Automotive OS는 무엇인가요?\n\nAndroid Automotive OS는 차량에 내장된 안드로이드 기반 인포테인먼트 시스템입니다. 차량 시스템은 운전용으로 최적화된 독립형 안드로이드 장치입니다. Android Automotive OS를 사용하면 사용자가 앱을 핸드폰이 아닌 차량에 직접 설치할 수 있습니다.\n\n![Android Auto Tutorial Step by Step Guide](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 안드로이드 오토 및/또는 안드로이드 오토모티브 OS는 다음 유형의 앱을 지원합니다:\n\n- 미디어 앱 — 오디오: 미디어 앱을 사용하면 사용자가 차 안에서 음악, 라디오, 오디오북 및 기타 오디오 콘텐츠를 찾아 재생할 수 있습니다.\n- 메시징 앱: 메시징 앱을 통해 사용자는 수신 알림을 받고 텍스트 음성 변환을 사용하여 메시지를 소리내어 읽거나 음성 입력을 통해 답장을 보낼 수 있습니다.\n- 내비게이션 앱: 운전 및 배송 서비스 제공 업체를 포함한 내비게이션 앱은 차원소를 제공하여 사용자가 목적지에 쉽게 도달할 수 있도록 도와줍니다.\n- 관심지역(POI) 앱: POI 앱을 사용하면 사용자가 관심 지역을 발견하고 찾아갈 수 있으며 주차, 충전 및 연료 앱과 같은 관련 작업을 수행할 수 있습니다.\n- 사물인터넷(IOT) 앱: IOT 앱을 사용하면 사용자가 차 안에서 연결된 기기에 관련 작업을 수행할 수 있습니다.\n- 비디오 앱(주차 시에만 사용): 비디오 앱을 사용하면 차가 주차된 상태에서 스트리밍 비디오를 시청할 수 있습니다.\n- 게임(주차 시에만 사용): 게임 앱을 사용하면 차가 주차된 상태에서 게임을 즐길 수 있습니다.\n\n# Android Auto 장치를 탐색하고 에뮬레이터를 설정하기 위한 환경 구성\n\n데스크톱 헤드 유닛(DHU)을 사용하면 개발 컴퓨터를 안드로이드 오토 헤드 유닛으로 에뮬레이션하여 안드로이드 오토 앱을 실행하고 테스트할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDHU는 Windows, Mac OS 및 Linux 시스템에서 작동합니다.\n\n아래 단계를 따라 Android Auto 에뮬레이터를 활성화하세요.\n\n- Android 6.0 이상( API 레벨 23)을 실행하는 모바일 기기에서 개발자 모드를 활성화하세요.\n- 앱을 컴파일하고 기기에 설치하세요.\n- 기기에 Android Auto를 설치하세요. 이미 Android Auto가 설치되어 있는 경우, 최신 버전을 사용하는지 확인하세요.\n- SDK Manager를 열고 SDK 도구 탭으로 이동한 다음 Android Auto 데스크톱 헤드유닛 에뮬레이터 패키지를 다운로드하세요.\n\n![AndroidAutoTutorialStepbyStepGuide_3](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n5. DHU는 SDK_LOCATION/extras/google/auto/ 디렉토리에 설치됩니다.\n\n6. 리눅스 또는 맥 OS 시스템에서는 해당 디렉토리에서 다음 명령을 실행하여 DHU 실행 파일이 실행 가능한지 확인하세요:\n\n```js\nchmod +x ./desktop-head-unit\n```\n\n```js\n./desktop-head-unit --usb\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. 에뮬레이터가 작동을 시작하고 Android 장치에서 업데이트 관련 팝업이 표시되면 업데이트 옵션을 클릭하고 에뮬레이터를 다시 시작하세요.\n\n![이미지](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_4.png)\n\n# Android Auto 디자인 템플릿\n\nAndroid Auto에서는 사용자 정의 UI를 만들 수 없고 Android Auto 앱에 허용된 템플릿 세트를 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나에 따르면, 구글에서 제공하는 미리 정의된 UI 템플릿을 사용하면 운전 중에 안드로이드 오토 장치와 조화롭게 작동할 수 있어요.\n\n## 사용 가능한 템플릿 목록:\n\n- 탭 컨테이너 템플릿\n\n![Tab Container Template](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 마크다운 형식으로 변환한 표입니다.\n\n- Tab bar with app icon and up to 4 tabs (no back button)\n- Embedded template, which can be any of the following types: List, Grid, Search, Pane, or Message\n- List or Grid Template\n\n![Image](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_7.png)\n\n- Message or Long Message Template\n\n![Image](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_8.png)\n\n- Search Template\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_9.png)\n\n- Place List (map) Template\n- Navigation Template\n\n# 자동차용 미디어 앱을 만들기 위한 단계\n\n- Manifest 파일에서 Android Auto 지원 선언하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Step 10](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_10.png)\n\n![Step 11](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_11.png)\n\n- 미디어 브라우저 서비스를 선언하세요\n\n![Step 12](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_12.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 안드로이드 오토가 미디어 브라우저 서비스와 상호 작용하는 방법:\n\n![AndroidAutoTutorialStepbyStepGuide_13](/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_13.png)\n\n- 사용자가 안드로이드 오토에서 앱을 실행하면, 안드로이드 오토가 onCreate() 메서드를 사용하여 앱의 미디어 브라우저 서비스에 연락합니다. onCreate() 메서드를 구현할 때는 MediaSessionCompat 객체와 콜백 객체를 생성하고 등록해야 합니다.\n- 안드로이드 오토가 서비스의 onGetRoot() 메서드를 호출하여 콘텐츠 계층 구조에서 루트 미디어 항목을 가져옵니다. 모든 것은 루트에서 시작하며, MediaBrowserServiceCompat에 연결을 허용하려면 null이 아닌 BrowserRoot를 반환해야 합니다.\n- 안드로이드 오토가 서비스의 onLoadChildren() 메서드를 호출하여 루트 미디어 항목의 자식 항목을 가져옵니다. 안드로이드 오토는 이러한 미디어 항목을 컨텐츠 항목의 최상위로 표시합니다. FLAG_PLAYABLE 및 FLAG_BROWSABLE 두 가지 사용 가능한 플래그가 있으며, 미디어 항목이 직접 재생될 수 있는지 또는 자체 자식 항목이 있는지를 나타냅니다.\n- 사용자가 브라우저 가능한 미디어 항목을 선택하면, 선택한 메뉴 항목의 자식 항목을 다시 검색하기 위해 서비스의 onLoadChildren() 메서드가 호출됩니다.\n- 사용자가 재생 가능한 미디어 항목을 선택하면, 안드로이드 오토는 해당 작업을 수행하기 위해 적절한 미디어 세션 콜백 메서드를 호출합니다.\n\n예시: 음악 항목을 재생하게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 안드로이드 오토에서 미디어 앱을 지원하는 필수 단계:\n\n## 표준 재생 작업 설정\n\n안드로이드 오토는 PlaybackStateCompat 객체에서 활성화된 작업에 따라 재생 컨트롤을 표시합니다.\n\n기본적으로 앱은 다음 작업을 지원해야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ACTION_PLAY\n- ACTION_PAUSE\n- ACTION_STOP\n- ACTION_PLAY_FROM_MEDIA\n- ACTION_PLAY_FROM_SEARCH\n\nIf applicable to your app's content, you can also consider supporting the following actions:\n\n- ACTION_SKIP_TO_PREVIOUS\n- ACTION_SKIP_TO_NEXT\n\nThe MCT includes tests for the following media actions:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Play\n- Play From Search\n- Play From Media ID\n- Play From URI\n- Pause\n- Stop\n- Skip To Next\n- Skip To Previous\n- Skip To Queue Item\n- Seek To\n\n## 음성 명령 지원\n\n당신의 미디어 앱은 안전하고 편리한 경험을 제공하기 위해 운전자에게 방해가 되지 않도록 도와주는 음성 명령을 지원해야 합니다. Android Auto가 음성 명령을 감지하고 해석하면 해당 음성 명령은 onPlayFromSearch()를 통해 앱으로 전달됩니다. 이 콜백을 받은 후 앱은 쿼리 문자열과 일치하는 내용을 찾아 재생을 시작합니다.\n\n## 사용자 정의 재생 조작\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미디어 앱이나 메시징 앱, 내비게이션 주차 앱 등이라면 Android Auto 플랫폼을 지원하는 것이 좋은 것 같아요. 사용자가 운전 중에 스크린을 보지 않고도 음성 명령으로 어플을 사용할 수 있도록 하는 것이 유용할 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지 그럼 이만 마치겠습니다. 향후 글에서는 안드로이드 오토(Android Auto) 및 안드로이드 오토모티브(Android Automotive) 구현 예제 앱을 공유할 예정입니다.\n\nUAMP 미디어 앱은 안드로이드 오토(Android Auto) 및 안드로이드 오토모티브(OS)를 모두 탐색할 수 있는 매우 유용한 저장소입니다.\n\n이 글을 읽어 주셔서 감사합니다. 만약 이 게시물이 유용하고 흥미로웠다면 👏 클릭하고 추천해 주세요.\n\n제 소셜 미디어 및 기타 플랫폼에서 저에게 연락하거나 최신 소식을 확인하세요: [https://linktr.ee/droiddikshit](https://linktr.ee/droiddikshit) 🤝\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고 자료:\n\n[Android Media app UAMP](https://github.com/android/uamp)\n","ogImage":{"url":"/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_0.png"},"coverImage":"/assets/img/2024-05-27-AndroidAutoTutorialStepbyStepGuide_0.png","tag":["Tech"],"readingTime":11},{"title":"다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구","description":"","date":"2024-05-27 16:30","slug":"2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter","content":"\n객체지향 프로그래밍(OOP)은 소프트웨어 디자인을 객체와 그 상호작용을 중심으로 구성하는 패러다임입니다. 플러터 뒤에 있는 언어인 Dart는 OOP 원칙을 완벽히 지원하여 견고하고 확장 가능한 애플리케이션을 구축하는 데 탁월한 선택지입니다. 이 포괄적인 가이드에서는 Dart와 Flutter의 맥락에서 캡슐화, 상속, 다형성, 추상화와 같은 OOP의 네 가지 기둥을 자세히 살펴보며 메서드 오버라이딩과 오버로딩과 같은 개념도 살펴볼 것입니다.\n\n# OOP의 네 가지 기둥 이해하기\n\n## 1. 캡슐화\n\n캡슐화는 데이터와 데이터를 조작하는 메서드를 하나의 클래스라는 단위 내에 묶는 것을 말합니다. 이는 객체의 내부 상태를 외부 세계로부터 숨기고 필요한 기능을 명확히 정의된 인터페이스를 통해 노출하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDart에서 캡슐화는 public, private 및 protected와 같은 접근 한정자를 통해 달성됩니다. 기본적으로 멤버는 public이지만 밑줄(\\_)을 사용하여 private로 표시할 수도 있습니다.\n\n예제:\n\n```js\nclass BankAccount {\n  double _balance = 0; // Private property\n\n  void deposit(double amount) {\n    _balance += amount;\n  }\n\n  void withdraw(double amount) {\n    if (_balance \u003e= amount) {\n      _balance -= amount;\n    } else {\n      print('Insufficient funds.');\n    }\n  }\n\n  double getBalance() {\n    return _balance;\n  }\n}\n\nvoid main() {\n  var account = BankAccount();\n  account.deposit(1000);\n  print('Current balance: ${account.getBalance()}'); // Output: Current balance: 1000\n  account.withdraw(500);\n  print('Remaining balance: ${account.getBalance()}'); // Output: Remaining balance: 500\n}\n```\n\n## 2. 상속\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상속은 하위 클래스(subclass)가 다른 클래스(슈퍼클래스)로부터 속성과 메소드를 상속받을 수 있는 메커니즘입니다. 이는 코드 재사용을 촉진하고 클래스 간에 계층적인 관계를 정립합니다.\n\n예시:\n\n```js\nclass Animal {\n  void speak() {\n    print('동물이 말합니다.');\n  }\n}\n\nclass Dog extends Animal {\n  @override\n  void speak() {\n    print('개가 짖습니다.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.speak(); // 출력: 개가 짖습니다.\n}\n```\n\n## 3. 다형성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다형성은 서로 다른 클래스의 객체를 공통 부모 클래스의 객체로 다룰 수 있게 합니다. 이는 코드의 유연성과 확장성을 가능하게 합니다.\n\n예시:\n\n```js\nclass Shape {\n  void draw() {\n    print('도형을 그립니다.');\n  }\n}\n\nclass Circle extends Shape {\n  @override\n  void draw() {\n    print('원을 그립니다.');\n  }\n}\n\nclass Rectangle extends Shape {\n  @override\n  void draw() {\n    print('사각형을 그립니다.');\n  }\n}\n\nvoid main() {\n  Shape circle = Circle();\n  Shape rectangle = Rectangle();\n\n  circle.draw(); // 결과: 원을 그립니다.\n  rectangle.draw(); // 결과: 사각형을 그립니다.\n}\n```\n\n## 4. 추상화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상화는 복잡한 구현 세부사항을 숨기고 객체의 필수적인 특성만을 보여주는 과정입니다. 이는 프로그래밍 복잡성을 줄이고 대규모 코드베이스를 효과적으로 관리하는 데 도움이 됩니다.\n\n예시:\n\n```js\nabstract class Animal {\n  void speak();\n}\n\nclass Dog extends Animal {\n  @override\n  void speak() {\n    print('Dog barks.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.speak(); // 출력: Dog barks.\n}\n```\n\n# 메서드 재정의와 오버로딩\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 메소드 오버라이딩\n\n메소드 오버라이딩은 서브클래스가 슈퍼클래스에서 이미 정의된 메소드의 특정 구현을 제공할 때 발생합니다. 이를 통해 서브클래스는 상속된 메소드의 동작을 자신의 필요에 맞게 수정할 수 있습니다.\n\n예시:\n\n```js\nclass Animal {\n  void speak() {\n    print('Animal speaks.');\n  }\n}\n\nclass Dog extends Animal {\n  @override\n  void speak() {\n    print('Dog barks.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.speak(); // 출력: Dog barks.\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 메소드 오버로딩\n\n메소드 오버로딩은 같은 이름을 가진 다른 매개변수를 갖는 여러 메소드를 정의할 수 있는 능력을 가리킵니다. Dart는 메소드 오버로딩을 직접 지원하지 않지만 선택적 매개변수 또는 이름이 지정된 매개변수를 사용하여 유사한 기능을 구현할 수 있습니다.\n\n예시:\n\n```js\nclass Calculator {\n  int add(int a, int b) {\n    return a + b;\n  }\n\n  double add(double a, double b) {\n    return a + b;\n  }\n}\n\nvoid main() {\n  var calc = Calculator();\n  print(calc.add(2, 3)); // 결과: 5\n  print(calc.add(2.5, 3.5)); // 결과: 6.0\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 상속 이해\n\n상속은 기존 클래스(슈퍼 클래스)에서 새 클래스(서브 클래스)를 생성하여 속성과 메소드를 상속받는 메커니즘입니다. 이는 코드 재사용을 촉진하고 클래스 간에 계층적인 관계를 설정합니다.\n\n# 상속의 종류\n\n## 1. 단일 상속\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 개의 수퍼클래스로부터 속성과 메소드를 상속받는 것을 단일 상속이라고 합니다. Dart에서 클래스는 하나의 수퍼클래스만 확장할 수 있습니다.\n\n예시:\n\n```js\nclass Animal {\n  void eat() {\n    print('동물이 먹고 있습니다.');\n  }\n}\n\nclass Dog extends Animal {\n  void bark() {\n    print('개가 짖고 있습니다.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.eat();  // 출력: 동물이 먹고 있습니다.\n  dog.bark(); // 출력: 개가 짖고 있습니다.\n}\n```\n\n이 예시에서 Dog 클래스는 Animal 클래스로부터 eat() 메소드를 상속받습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 다중 상속\n\n다중 상속은 하위 클래스가 다른 클래스의 슈퍼 클래스가 되는 상속 체인에 관련된 개념입니다. 이는 다수의 상속 레벨을 가진 계층적 관계를 설정합니다.\n\n예시:\n\n```js\nclass Animal {\n  void eat() {\n    print('Animal is eating.');\n  }\n}\n\nclass Dog extends Animal {\n  void bark() {\n    print('Dog is barking.');\n  }\n}\n\nclass Labrador extends Dog {\n  void swim() {\n    print('Labrador is swimming.');\n  }\n}\n\nvoid main() {\n  var labrador = Labrador();\n  labrador.eat();  // 출력: Animal is eating.\n  labrador.bark();  // 출력: Dog is barking.\n  labrador.swim();  // 출력: Labrador is swimming.\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n랩라도 클래스는 Dog 클래스를 상속하고, Dog 클래스는 Animal 클래스를 상속합니다.\n\n## 3. 계층 상속\n\n계층적 상속은 여러 하위 클래스가 단일 상위 클래스에서 상속받는 것을 의미합니다. 각 하위 클래스는 상위 클래스에서 공통 특성을 공유하지만 각자 고유한 특성을 가질 수 있습니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass Animal {\n  void eat() {\n    print('Animal is eating.');\n  }\n}\n\nclass Dog extends Animal {\n  void bark() {\n    print('Dog is barking.');\n  }\n}\n\nclass Cat extends Animal {\n  void meow() {\n    print('Cat is meowing.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.eat();  // 결과: Animal is eating.\n  dog.bark(); // 결과: Dog is barking.\n\n  var cat = Cat();\n  cat.eat();  // 결과: Animal is eating.\n  cat.meow(); // 결과: Cat is meowing.\n}\n```\n\n이 예제에서 Dog 및 Cat 클래스는 Animal 클래스를 상속받아 eat() 메서드를 공유합니다.\n\n# 캡슐화 이해하기\n\n캡슐화는 객체 지향 프로그래밍의 핵심 원칙 중 하나로, 데이터(변수) 및 해당 데이터를 조작하는 메서드(함수)를 하나로 묶은 클래스라는 단위로 묶는 것을 목표로 합니다. 이 접근 방식은 개체의 일부 구성 요소에 대한 직접적인 액세스를 제한하여 의도하지 않은 간섭 및 남용을 방지하는 데 필수적입니다. Dart 및 Flutter에서 캡슐화는 멤버 변수 캡슐화, 함수 캡슐화 및 클래스 캡슐화의 세 가지 주요 방법으로 달성됩니다. 각 유형을 구체적인 예를 통해 자세히 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1. 멤버 변수 캡슐화\n\n멤버 변수 캡슐화는 객체의 내부 상태를 보호하기 위해 변수를 private로 만들고 public 메서드를 통해 제어된 접근을 제공하는 것을 의미합니다. 이를 통해 객체의 데이터가 정의된 방법으로만 수정될 수 있도록 보장할 수 있습니다.\n\n예시:\n\n```js\nclass Person {\n  String _name; // Private 변수\n\n  Person(this._name);\n\n  // name의 Getter\n  String get name =\u003e _name;\n\n  // name의 Setter\n  set name(String name) {\n    if (name.isNotEmpty) {\n      _name = name;\n    }\n  }\n}\n\nvoid main() {\n  var person = Person('John');\n  print(person.name); // 결과: John\n  person.name = 'Doe';\n  print(person.name); // 결과: Doe\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제에서 \\_name 변수는 private이며 getter 및 setter 메서드를 통해서만 액세스하거나 수정할 수 있습니다. 이 캡슐화는 \\_name에 대한 모든 수정이 확인되도록 보장합니다.\n\n## 2. 함수 캡슐화\n\n함수 캡슐화는 일부 메서드를 private으로 만들어 객체의 데이터가 내부적으로 어떻게 조작되는지 제어하는 것을 의미합니다. 필요한 메서드만 공개되고 내부 구현은 숨겨집니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass Calculator {\n  // Public method\n  int add(int a, int b) {\n    return _performAddition(a, b);\n  }\n\n  // Private helper method\n  int _performAddition(int a, int b) {\n    return a + b;\n  }\n}\n\nvoid main() {\n  var calc = Calculator();\n  print(calc.add(2, 3)); // Output: 5\n}\n```\n\n여기서 \\_performAddition 메서드는 private이며 Calculator 클래스 내에서만 접근할 수 있습니다. public add 메서드는 기능을 노출하면서 내부 작업은 숨겨둡니다.\n\n## 3. Class Encapsulation\n\n클래스 캡슐화는 관련된 변수와 메서드를 하나의 클래스로 묶는 것을 의미합니다. 이는 모듈성과 재사용성을 촉진하여 코드를 보다 조직적이고 관리하기 쉽도록 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\nclass Car {\n  String _model;\n  int _year;\n\n  Car(this._model, this._year);\n\n  // 자동차 정보를 표시하는 공개 메서드\n  void displayInfo() {\n    print('Model: $_model, Year: $_year');\n  }\n}\n\nvoid main() {\n  var myCar = Car('Tesla', 2021);\n  myCar.displayInfo(); // 출력: Model: Tesla, Year: 2021\n}\n```\n\n이 예시에서 Car 클래스는 \\_model과 \\_year 변수 및 displayInfo 메서드를 캡슐화합니다. 이 구조는 자동차에 관련된 모든 정보와 동작이 함께 그룹화되도록 보장합니다.\n\n# 추상화 이해하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상화는 객체 지향 프로그래밍(OOP)에서 중요한 원칙으로, 문제에 적합한 클래스를 모델링하여 복잡한 시스템을 간단하게 만들어줍니다. 이는 구현 세부 정보를 숨기고 사용자에게 기능만 표시함으로써 도움이 됩니다. Dart와 Flutter에서 추상화는 깔끔하고 유지보수 가능하며 모듈식 코드를 작성하는 데 다양한 형태로 적용될 수 있습니다. 이 블로그에서는 OOP에서 다양한 종류의 추상화인 데이터 추상화, 프로세스 추상화, 공개 지정자를 사용한 추상화, 그리고 비공개 분류자를 사용한 추상화에 대해 다룰 것입니다. 함께 알아보겠습니다!\n\n## 1. 데이터 추상화\n\n데이터 추상화는 필수적인 기능만 노출하고 불필요한 세부 정보를 숨기는 데 초점을 맞춥니다. Dart에서는 데이터 추상화를 주로 추상 클래스와 인터페이스를 사용하여 달성합니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상 클래스인 Animal은 사운드()라는 추상 메서드를 정의합니다. 이 메서드는 Dog 클래스에서 구현됩니다. Animal 클래스의 사용자로부터 사운드()의 구현 세부사항을 숨기고 필요한 기능만 노출시킵니다.\n\n## 2. 프로세스 추상화\n\n프로세스 추상화는 복잡한 프로세스나 작업을 간단하고 관리하기 쉬운 메서드로 추상화하는 것을 의미합니다. 이를 통해 복잡한 기능을 작은 재사용 가능한 메서드로 분해하는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\nclass MathOperations {\n  double calculateArea(double radius) {\n    return _calculateCircleArea(radius);\n  }\n\n  // 자세한 계산을 위한 비공개 메서드\n  double _calculateCircleArea(double radius) {\n    return 3.14 * radius * radius;\n  }\n}\n\nvoid main() {\n  var math = MathOperations();\n  print(math.calculateArea(5)); // 출력: 78.5\n}\n```\n\n여기서 MathOperations 클래스는 원의 넓이를 계산하는 과정을 \\_calculateCircleArea 비공개 메서드로 추상화합니다. 사용자는 내부 계산을 알 필요 없이 calculateArea 메서드와 상호작용할 수 있습니다.\n\n## 3. 공개 지정자를 사용한 추상화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDart에서의 공개 지정자는 클래스의 특정 부분을 노출시키면서 다른 부분을 숨길 때 사용됩니다. 이는 클래스의 명확한 인터페이스를 정의하는 데 중요하며 내부 상태를 보호하는 데 도움이 됩니다.\n\n예시:\n\n```js\nclass BankAccount {\n  String _accountNumber;\n  double _balance;\n\n  BankAccount(this._accountNumber, this._balance);\n\n  // 계좌 잔액을 얻기 위한 공개 메서드\n  double get balance =\u003e _balance;\n\n  // 돈을 입금하는 공개 메서드\n  void deposit(double amount) {\n    if (amount \u003e 0) {\n      _balance += amount;\n    }\n  }\n}\n\nvoid main() {\n  var account = BankAccount('123456789', 1000.0);\n  account.deposit(500);\n  print(account.balance); // 출력: 1500.0\n}\n```\n\n이 예시에서는 \\_accountNumber 및 \\_balance 변수가 비공개이지만 balance getter 및 deposit 메서드는 공개되어 있습니다. 이를 통해 잔액에 제한된 액세스권을 부여하면서 계좌 번호를 숨길 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4. 비공개 분류자를 사용한 추상화\n\n다트에서의 비공개 분류자는 클래스 내의 세부 사항을 캡슐화하여 클래스 외부에서 특정 속성 및 메서드에 액세스를 제한합니다.\n\n예시:\n\n```js\nclass Employee {\n  String _name;\n  double _salary;\n\n  Employee(this._name, this._salary);\n\n  // 직원 세부 정보를 얻는 공용 메서드\n  String getDetails() {\n    return 'Name: $_name, Salary: $_salary';\n  }\n\n  // 보너스 계산을 위한 비공용 메서드\n  double _calculateBonus() {\n    return _salary * 0.1;\n  }\n\n  // 보너스를 얻기 위한 공용 메서드\n  double get bonus =\u003e _calculateBonus();\n}\n\nvoid main() {\n  var employee = Employee('Alice', 50000);\n  print(employee.getDetails()); // 출력: Name: Alice, Salary: 50000\n  print(employee.bonus); // 출력: 5000.0\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예에서 \\_calculateBonus 메서드는 private이며 Employee 클래스 내에서만 액세스할 수 있습니다. 보너스 getter는 실제 계산 프로세스를 숨기고 계산된 보너스를 노출합니다.\n\n# 결론\n\nDart 및 Flutter 애플리케이션에서 깨끗하고 유지보수가능하며 확장 가능한 코드를 작성하는 데 OOP의 네 가지 기둥인 캡슐화, 상속, 다형성 및 추상화를 이해하는 것이 중요합니다. 또한 메서드 재정의와 오버로딩과 같은 개념을 이해하면 더 강력한 소프트웨어 솔루션을 설계하고 구현하는 능력이 향상됩니다. 이러한 개념을 숙달하여 OOP의 전체 능력을 활용하여 복잡하고 확장 가능한 애플리케이션을 구축할 수 있습니다.\n\n또한 Dart와 Flutter에서 다양한 유형의 상속을 이해하는 것은 효율적이고 유지보수 가능한 코드베이스를 설계하는 데 중요합니다. 상속을 효과적으로 활용하면 코드 재사용을 촉진하고 계층적 관계를 수립하고 쉽게 확장 가능한 애플리케이션을 구축할 수 있습니다. 간단한 클래스 계층 구조를 작성하거나 복잡한 객체 구조를 설계하든 상속은 Dart 및 Flutter 프로젝트의 아키텍처를 형성하는 데 중요한 역할을 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 댓글에 Dart와 Flutter에서의 OOP에 대한 생각과 경험을 자유롭게 공유해주세요!\n","ogImage":{"url":"/assets/img/2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter_0.png"},"coverImage":"/assets/img/2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter_0.png","tag":["Tech"],"readingTime":16},{"title":"iOS 인터뷰 질문-제7파","description":"","date":"2024-05-27 16:28","slug":"2024-05-27-iOSInterviewQuestions-Part7","content":"\nSwift, iOS, Xcode에 관한 인터뷰 질문\n\n![iOS Interview Questions Part7](/assets/img/2024-05-27-iOSInterviewQuestions-Part7_0.png)\n\n1. 옵셔널을 어떻게 생성할 수 있나요?\n\nSwift에서 옵셔널은 타입 앞에 ?를 추가하여 만들 수 있습니다. 예를 들어\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nvar name: String?\n\n# 2. What is optional Binding?\n\nOptional Binding은 옵셔널이 값을 포함하고 있는지 여부를 확인하는 데 사용됩니다. 값이 있는 경우 if let을 사용하여 상수나 변수에 그 값을 저장합니다. if 문 내에서 생성된 상수와 변수는 if 블록 내에서만 사용할 수 있습니다.\n\n우리는 옵셔널 값을 가져와서 논 옵셔널 상수에 연결할 것입니다. 우리는 If let 구조 또는 Guard 문을 사용합니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 옵셔널 체이닝이란 무엇인가요?\n\n옵셔널 체이닝은 현재 nil일 수 있는 옵셔널에서 속성, 서브스크립트 및 메소드를 조회하고 호출하기 위한 과정입니다. 옵셔널이 속성, 메소드 또는 서브스크립트 호출이 성공하면 해당 값이 반환됩니다. 옵셔널이 nil이면 모든 속성, 메소드 또는 서브스크립트 호출이 nil을 반환합니다. 여러 쿼리가 연결되어 있을 때 체인 중 하나의 링크가 nil이면 전체 체인이 안전하게 실패합니다.\n\n스위프트 프로그래밍 언어에서 옵셔널 체이닝은 속성을 조회하고 호출하는 과정입니다. 여러 쿼리를 체이닝할 수 있지만 체인 중 하나의 링크가 nil이면 전체 체인이 실패합니다.\n\n# 4. iOS 애플리케이션 개발에서 사용되는 디자인 패턴을 설명해 주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n본질적으로, 디자인 패턴은 전형적인 소프트웨어 문제를 해결하기 위해 반복적으로 적용할 수 있는 코드 솔루션입니다. 프로젝트에서 디자인 패턴을 사용하면 더 모듈식이고 확장 가능하며 최적화된 소프트웨어를 얻을 수 있습니다. 다른 사람들의 코드를 더 잘 이해할 수 있게 되어, 디자인 패턴을 즉시 인식할 수 있게 될 것입니다.\n\n디자인 패턴은 더 나은 소프트웨어를 만들기 위한 지침으로 사용되지 않습니다. 디자인 패턴과 최선의 방법은 전혀 다르기 때문입니다. 또한, 도전에 접근하는 방법에 대한 지침을 제공하기 위한 것이 아닙니다. 대신, 전형적인 엔지니어링 및 아키텍처 컨셉에 대한 관찰된 일반적인 응답을 문서화하는 데 주로 사용됩니다. 일반적인 디자인 패턴으로는 Facade, Decorator, Factory Method, Singleton 등이 있습니다.\n\n다음 디자인 패턴은 iOS 개발에서 주로 사용됩니다.\n\n- 생성 디자인 패턴 — Builder, Factory, Singleton.\n- 구조 디자인 패턴 — Decorator, Facade, Adapter.\n- 행동 디자인 패턴 — Observer, Memento.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. Swift에서 옵셔널 값을 해제하는 여러 방법은 무엇입니까?\n\n- Guard 문 (안전한 방법)\n- 옵셔널 바인딩 — 안전\n- 옵셔널 패턴 — 안전\n- 강제 언래핑 — \"!\" 연산자를 사용하여, 안전하지 않음\n- 옵셔널 체이닝 — 안전\n- nil 병합 연산자 — 안전\n- 암시적으로 언래핑된 변수 선언: 많은 경우 안전하지 않음\n\n# 6. Nil 병합 연산자\n\n??을 사용하여, 연산자의 왼쪽에 nil 값이 있으면 ?? 오른쪽의 값이 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7. iOS의 코어 데이터란 무엇인가요?\n\n코어 데이터는 애플이 제공하는 프레임워크로, 데이터를 저장, 검색, 삭제 및 수정하는 데 사용됩니다. 애플리케이션의 모델 레이어 객체를 관리하는 데 사용됩니다. 코어 데이터는 데이터베이스가 아닙니다. 코어 데이터의 데이터 모델 편집기를 사용하면 데이터 유형과 관계를 쉽게 정의하고 해당 클래스 정의를 생성할 수 있습니다.\n\n코어 데이터는 ORM(객체 관계 매핑)이나 객체-관계 매퍼가 아닙니다. 또한 데이터베이스도 아닙니다. 대신 코어 데이터는 객체 그래프 관리자로, 객체 그래프를 디스크에 지속성 저장할 수 있는 기능을 갖추고 있습니다.\n\n애플은 이렇게 말합니다: \"코어 데이터를 사용하여 애플리케이션의 오프라인 사용을 위한 영구 데이터를 저장하고, 임시 데이터를 캐시하며, 앱에서 단일 장치에서 취소 기능을 추가하세요.\" 😮\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코어 데이터는 지속성, 개별 또는 일괄적으로 변경 내용을 실행 취소 및 다시 실행, 백그라운드 데이터 작업, 뷰 동기화, 버전 및 이전 버전 마이그레이션 등의 기능을 제공합니다.\n\n프로젝트를 만들 때 \"코어 데이터 사용\"란 체크 박스를 선택하여 코어 데이터 모델을 만들 수 있습니다.\n\n코어 데이터 스택\n\n데이터 모델 파일을 만든 후, 앱의 모델 레이어를 지원하는 협업 클래스를 설정하십시오. 이러한 클래스들은 총칭하여 코어 데이터 스택이라고 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Core Data 구성 요소 몇 가지가 있습니다:\n\n- NSManagedObjectModel 인스턴스는 앱의 모델 파일을 나타내며 앱의 유형, 속성 및 관계를 설명합니다.\n- NSManagedObjectContext 인스턴스는 앱의 유형의 인스턴스에 대한 변경 사항을 추적합니다.\n- NSPersistentStoreCoordinator 인스턴스는 앱의 유형의 인스턴스를 저장소에서 저장하고 가져옵니다.\n- NSPersistentContainer 인스턴스는 한 번에 모델, 컨텍스트 및 저장소 코디네이터를 설정합니다.\n\n# 8. Core Data의 다른 데이터 유형\n\n많은 앱이 다양한 유형의 정보를 영속적으로 저장하고 표시해야 합니다. Core Data는 일반적인 데이터베이스에서 사용되는 Date 나 Decimal 유형과 같은 속성뿐만 아니라 Transformable 유형으로 처리되는 비표준 속성을 포함하여 다양한 속성을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 9. 관리 대상 객체 컨텍스트란 무엇인가요?\n\n관리 대상 객체 컨텍스트는 Core Data 응용 프로그램에서 단일 객체 공간 또는 스크래치 패드를 나타냽니다.\n\n# 10. 정적 바인딩과 동적 바인딩의 차이는 무엇인가요?\n\n정적 바인딩: 이벤트는 컴파일 시간에 발생합니다. 정적 바인딩에서 실행이 빠릅니다. 초기 바인딩이 있습니다. \"컴파일 시간\"에 해결됩니다. 메소드 오버로딩은 정적 바인딩의 예시입니다.\n동적 바인딩: 이벤트는 실행 시간에 발생합니다. 동적 바인딩에서 실행이 느립니다. 지연 바인딩이 있습니다. \"실행 시간\"에 가상 바인딩으로 해결됩니다. 메소드 오버라이딩은 동적 바인딩의 예시입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 11. Entity 상속은 무엇인가요?\n\nentity 상속은 클래스 상속과 유사하게 작동합니다. 때로는 많은 수의 엔티티가 있고 그 중 일부가 유사할 수 있습니다. 이 경우 공통 속성을 슈퍼타입으로 고려할 수 있고 이것을 부모 엔티티라고 말할 수 있습니다. 이는 하위 엔티티가 부모 엔티티를 상속할 때의 작업을 줄이는 데 도움이 됩니다.\n예: 이름이라는 엔티티를 정의했고 그 속성으로 이름과 성을 가지고 있는데, 하위 엔티티인 직원과 고객은 이러한 속성을 상속할 수 있습니다.\n\n# 12. Core Data에서는 멀티스레딩이 가능할까요?\n\n네, Core Data에서 멀티스레딩이 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 13. Deinit이란 무엇인가요?\n\nDeInitializer는 클래스의 인스턴스가 확보 해제되기 직전에 호출됩니다. DeInitializer에서 사용하는 키워드는 초기화에 사용되는 Init 키워드와 유사한 deinit입니다. 중요한 점은 DeInitializer가 구조체 타입이 아닌 클래스 타입에만 사용 가능하다는 것입니다.\n\n# 14. reuseIdentifier의 목적은 무엇인가요?\n\n이미 할당된 객체의 재사용성입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`reuseIdentifier`은 UITableView에서 모든 비슷한 행을 그룹화하는 데 사용됩니다.\n\n### 15. UITableView를 처음으로로드할 때 몇 개의 UITableViewCells가 할당되나요? 테이블을 스크롤하면 몇 개가 더 할당되나요?\n\nUITableView는 일반적으로 테이블에서 보이는 내용을 표시할만큼의 UITableViewCell 객체만 할당합니다. reuseIdentifier 덕분에 UITableView는 뷰로 스크롤되는 각 새로운 항목마다 새로운 UITableViewCell 객체를 할당하지 않아 렉이 걸리는 애니메이션을 피할 수 있습니다.\n\n### 16. UITableViewCell 생성자에서 재사용 식별자를 왜 사용하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 재사용할 식별자를 설정하지 않으면 TableView는 새로운 UITableViewCell을 할당하도록 강제합니다.\n재사용 식별자의 사용 목적은 비슷한 행 내용을 UITableView에서 그룹화하는데 사용되지만 데이터 내용은 다를 수 있습니다.\n\n## 17. 제네릭이란 무엇이며 어떤 문제를 해결하나요?\n\n제네릭 코드는 재사용 가능하고 유연한 함수 및 어떤 유형이라도 작동할 수 있는 유형을 작성할 수 있도록 돕습니다. 제네릭은 Swift 언어의 가장 강력한 기능입니다.\n\n## 18. Objective-C에서 @synthesize란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`@synthesize`는 컴파일러에게 변수에 대한 setter와 getter 프로퍼티를 생성하도록 하는 것이에요.\n\n# 19. ARC란 무엇인가요? Swift에서 어떻게 메모리를 관리하는 데 도움이 되나요? 그 기능을 설명하기 위한 예시를 제시해 주세요.\n\nARC (Automatic Reference Count)는 iOS 애플리케이션에서 사용되며 애플리케이션 메모리를 추적하고 관리하는 데 도움을 줘요. Arc는 클래스 인스턴스가 더 이상 필요하지 않을 때 클래스 인스턴스가 보유한 메모리를 자동으로 해제해 줘요.\n\n```swift\nclass Person {\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n명함: 문자열\n\ninit(이름: 문자열) '\n\nself.name = name\n\nprint(“\\(이름)이(가) 초기화되고 있습니다.”)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n' deinit '\n\nprint(\"\\\"\\(name) is being deinitialized.\\\"\")\n\n'\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nvar person1: Person? = Person(name: “Alice”)\n\nvar person2: Person? = person1 // person1 and person2 now both reference the same Person instance\n\nperson1 = nil // The reference count of the Person instance decreases to 1\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nperson2 = nil // Person 인스턴스의 참조 카운트가 0으로 감소하고 인스턴스가 해제됩니다.\n\n이 예에서 person1과 person2가 동일한 Person 인스턴스에 할당될 때 참조 카운트가 2가 됩니다. person1과 person2가 모두 nil로 설정되면 참조 카운트가 0으로 떨어지고 Person 인스턴스가 해제되어 deinitializer가 트리거됩니다.\n\n# 20. 라이브 렌더링이란?\n\n인터페이스 빌더에서 사용되는 속성인 IBDesignable 및 IBInspectable은 특정 속성(색상/폭/그림자 및 테두리와 같은)이 스토리보드에서 라이브로 구성될 수 있도록 도와주며 인터페이스 빌더에서 해당 요소를 직접 렌더링하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 21. ‘assign’와 ‘retain’ 키워드의 차이점을 설명해주세요.\n\nRetain — 객체 할당 시 retain을 호출해야 함을 명시합니다. 객체의 소유권을 가져갑니다.\n\nAssign — 세터가 단순 할당을 사용한다는 것을 명시합니다. float, int와 같은 스칼라 유형의 속성에 사용됩니다.\n\n# 22. iBeacons이란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niBeacon.com에서는 iBeacon을 Apple의 기술 표준으로 정의하며, 이를 통해 Mobile Apps이 물리적 세계에서 비콘에서 신호를 수신하고 그에 맞게 반응할 수 있습니다. iBeacon 기술을 통해 Mobile Apps은 마이크로 로컬 스케일에서 위치를 이해하고 위치에 기반한 하이퍼 컨텍스트 콘텐츠를 사용자에게 제공할 수 있습니다. 기술은 Bluetooth Low Energy를 기반으로 합니다.\n\nApple의 Bluetooth Low Energy(BLE) 무선 기술인 iBeacon은 iPhones 및 기타 iOS 사용자가 위치 기반 정보와 서비스를 받는 새로운 방법입니다.\n\n# 23. Autorelease란 무엇인가요?\n\n객체에 autorelease 메시지를 보내면 해당 객체는 로컬 AutoReleasePool에 추가됩니다. 그렇기 때문에 더 이상 해당 객체를 신경 쓸 필요가 없습니다. AutoReleasePool이 소멸될 때 (주 실행 루프에서), 해당 객체는 릴리스 메시지(참조 횟수가 하나 감소)를 받으며, RetainCount가 0이되면 가비지 수집기가 해당 객체를 제거합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n릴리스: `release` 메시지를 객체에 보낼 때 보유 카운트가 하나 감소합니다.\n\n## 24. autorelease pool이란 무엇인가요?\n\n객체에 `autorelease`가 보내질 때마다, 해당 객체는 가장 내부에 있는 autorelease 풀에 추가됩니다. 풀이 비워질 때, 풀에 있는 모든 객체에 대해 간단히 `release` 메시지를 보냅니다. `@autoreleasepool` 블록을 활용합니다.\n\nautorelease 풀은 `release` 메시지를 \"나중에\"까지 보낼 수 있게 해주는 편의 기능입니다. 이 \"나중에\"는 여러 곳에서 발생할 수 있지만, Cocoa GUI 애플리케이션에서 가장 흔한 시점은 현재 런 루프 사이클의 끝입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 25. 블록에서 변수에 액세스하는 방법은?\n\n\\_\\_block 저장 유형을 사용하면 됩니다.\n\n만약 이 글을 즐겁게 읽으셨다면 공유하고 박수를 두드려주세요 👏🏻👏🏻👏🏻👏🏻👏🏻\n\n또한 저와 연락할 수도 있습니다 📲\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그를 변경해 주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아무 의견, 질문 또는 추천이 있으시면 아래 댓글 섹션에 자유롭게 남겨주세요💬\n\n💁🏻‍♀️ 즐거운 코딩하세요!\n\n감사합니다😊\n\nSwiftfy를 팔로우하여 더 많은 업데이트를 받아보세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 많은 기사를 보고 싶다면 참고하세요:\n","ogImage":{"url":"/assets/img/2024-05-27-iOSInterviewQuestions-Part7_0.png"},"coverImage":"/assets/img/2024-05-27-iOSInterviewQuestions-Part7_0.png","tag":["Tech"],"readingTime":14},{"title":"스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고","description":"","date":"2024-05-27 16:27","slug":"2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices","content":"\n\u003cimg src=\"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png\" /\u003e\n\n소개\n\n프로토콜 지향 프로그래밍(POP)은 스위프트 개발에서 핵심 패러다임 중 하나로 자리 잡았으며, 전통적인 객체지향 프로그래밍에 강력한 대안을 제공합니다. 프로토콜에 주목함으로써, 스위프트는 개발자들이 유연하고 재사용 가능하며 테스트 가능한 코드를 작성할 수 있게 해줍니다. 이 글에서는 프로토콜 지향 프로그래밍의 원칙을 탐구하고, 일반적인 디자인 패턴을 살펴보며, 스위프트에서 프로토콜을 통해 견고한 애플리케이션을 구축하는 데 가장 좋은 방법을 논의할 것입니다.\n\n왜 프로토콜 지향 프로그래밍을 해야 할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPOP은 작업이나 기능에 대한 청사진을 정의하는 데 프로토콜 사용을 장려합니다. 이 접근 방식은 여러 가지 이점을 제공합니다:\n\n- 유연성: 프로토콜을 사용하면 타입이 여러 프로토콜을 준수하도록 하여 보다 유연한 아키텍처를 구축할 수 있습니다.\n- 재사용성: 공통 기능은 프로토콜에 정의하고 다양한 타입 간에 재사용할 수 있습니다.\n- 테스트 용이성: 프로토콜은 의존성 주입을 용이하게 하여 단위 테스트에서 의존성을 가짜로 대체하기 쉽습니다.\n- 결합도 낮추기: 프로토콜은 인터페이스를 정의함으로써 코드를 결합도 낮추며 구체적인 구현 대신 인터페이스를 정의합니다. 역할 분리를 촉진합니다.\n\n프로토콜을 활용하기\n기본 프로토콜 정의\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n프로토콜 Drivable {\n    var speed: Double { get }\n    func drive()\n}\n\n구조체 Car: Drivable {\n    var speed: Double\n\n    func drive() {\n        print(\"속도: \\(speed) km/h로 주행 중\")\n    }\n}\n\nlet car = Car(speed: 120)\ncar.drive()  // 출력: 속도: 120.0 km/h로 주행 중\n```\n\n이 예제에서는 speed 속성과 drive 메서드가 있는 Drivable 프로토콜을 정의합니다. Car 구조체는 Drivable 프로토콜을 준수하며 필요한 속성과 메서드를 구현합니다.\n\n프로토콜 익스텐션\n\n프로토콜 익스텐션을 사용하여 프로토콜 메서드에 대한 기본 구현을 제공할 수 있으며 주어진 유형의 기능을 확장할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로토콜 확장 예제\n\n```swift\nprotocol Drivable {\n    var speed: Double { get }\n    func drive()\n}\n\nextension Drivable {\n    func drive() {\n        print(\"Driving at \\(speed) km/h\")\n    }\n\n    func stop() {\n        print(\"Stopped.\")\n    }\n}\n\nstruct Car: Drivable {\n    var speed: Double\n}\n\nlet car = Car(speed: 120)\ncar.drive()  // 출력: 120.0 km/h로 주행 중\ncar.stop()   // 출력: 정지됨\n```\n\n여기에는 프로토콜 확장 내에서 drive 메서드에 대한 기본 구현이 있습니다. 또한 모든 준수하는 타입이 추가 구현없이 사용할 수 있는 새로운 stop 메서드가 도입되었습니다.\n\n프로토콜 조합\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스위프트를 사용하면 여러 프로토콜을 조합하여 타입이 조합된 프로토콜을 준수할 수 있습니다.\n\n프로토콜 조합 예시\n\n```js\nprotocol Drivable {\n    var speed: Double { get }\n    func drive()\n}\n\nprotocol Flyable {\n    var altitude: Double { get }\n    func fly()\n}\n\nstruct FlyingCar: Drivable, Flyable {\n    var speed: Double\n    var altitude: Double\n\n    func drive() {\n        print(\"Driving at \\(speed) km/h\")\n    }\n\n    func fly() {\n        print(\"Flying at \\(altitude) meters\")\n    }\n}\n\nlet flyingCar = FlyingCar(speed: 120, altitude: 1000)\nflyingCar.drive()  // 출력: Driving at 120.0 km/h\nflyingCar.fly()    // 출력: Flying at 1000.0 meters\n```\n\n이 예시에서 FlyingCar 구조체는 Drivable 및 Flyable 프로토콜을 모두 준수하며, 프로토콜 조합이 복잡한 기능을 가능하게 함을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로토콜 중심의 디자인 패턴\n\n1. 전략 패턴\n\n전략 패턴은 알고리즘들의 집합을 정의하고 각각을 캡슐화하여 교환 가능하게 만듭니다. Swift에서 이 패턴을 구현하는 데는 프로토콜이 이상적입니다.\n\n전략 패턴 예시\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n프로토콜 PaymentStrategy {\n    func pay(amount: Double)\n}\n\n구조체 CreditCardPayment: PaymentStrategy {\n    func pay(amount: Double) {\n        print(\"\\(amount) 금액으로 신용카드를 사용해 결제했습니다\")\n    }\n}\n\n구조체 PayPalPayment: PaymentStrategy {\n    func pay(amount: Double) {\n        print(\"\\(amount) 금액으로 PayPal을 사용해 결제했습니다\")\n    }\n}\n\n구조체 ShoppingCart {\n    var paymentStrategy: PaymentStrategy\n\n    func checkout(amount: Double) {\n        paymentStrategy.pay(amount: amount)\n    }\n}\n\nlet creditCardPayment = CreditCardPayment()\nlet payPalPayment = PayPalPayment()\n\nvar cart = ShoppingCart(paymentStrategy: creditCardPayment)\ncart.checkout(amount: 100)  // 결과: 100.0 금액으로 신용카드를 사용해 결제했습니다\ncart.paymentStrategy = payPalPayment\ncart.checkout(amount: 200)  // 결과: 200.0 금액으로 PayPal을 사용해 결제했습니다\n```\n\n여기서 PaymentStrategy 프로토콜은 결제를 위한 메서드를 정의합니다. 다양한 결제 전략(CreditCardPayment과 PayPalPayment)이 이 프로토콜을 준수합니다. ShoppingCart은 전략을 사용하여 결제를 수행하며, 결제 방법을 동적으로 전환할 수 있습니다.\n\n2. 의존성 주입\n\n의존성 주입(Dependency Injection, DI)은 IoC(제어의 역전)를 구현하는 데 사용되는 디자인 패턴으로, 클래스가 내부적으로 생성하는 대신 외부 소스에서 의존성을 받을 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성 주입을 사용한 예제\n\n```js\nprotocol DataService {\n    func fetchData() -\u003e String\n}\n```\n\n```js\nstruct APIService: DataService {\n    func fetchData() -\u003e String {\n        return \"API에서 데이터를 가져왔습니다\"\n    }\n}\nstruct MockService: DataService {\n    func fetchData() -\u003e String {\n        return \"모의 데이터입니다\"\n    }\n}\nstruct DataManager {\n    var service: DataService\n    func getData() -\u003e String {\n        return service.fetchData()\n    }\n}\nlet apiService = APIService()\nlet mockService = MockService()\nlet dataManager = DataManager(service: apiService)\nprint(dataManager.getData())  // 출력: API에서 데이터를 가져왔습니다\nlet testManager = DataManager(service: mockService)\nprint(testManager.getData())  // 출력: 모의 데이터입니다\n```\n\n이 예제에서는 DataService 프로토콜이 데이터를 가져오는 메서드를 정의합니다. APIService와 MockService 구조체는 이 프로토콜을 준수하여 다른 구현을 제공합니다. DataManager는 데이터를 가져오기 위해 DataService에 의존하며, 실제 서비스와 테스트를 위한 모의 서비스를 쉽게 변경할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로토콜 지향 프로그래밍의 Best Practices\n\n- 상속 대신 구성 사용: 클래스 상속에 의존하는 대신 프로토콜을 사용하여 함께 조합할 수 있는 재사용 가능한 동작을 정의하세요.\n- 작고 집중된 프로토콜 정의: 프로토콜을 단일 책임 원칙(SRP)을 준수하며 집중시켜 작고 집중된 상태로 유지하세요. 이렇게 하면 이해하고 구현하기 쉬워집니다.\n- 프로토콜 익스텐션 올바르게 활용: 프로토콜 익스텐션에서 일반적인 동작에 대한 기본 구현을 제공하지만 오버라이드할 필요가 있는 로직을 너무 많이 포함하지 않도록 주의하세요.\n- 프로토콜 조합 활용: 여러 프로토콜을 결합하여 유연하고 모듈식 설계를 만드세요.\n- 프로토콜 및 익스텐션 문서화: 프로토콜과 그 익스텐션의 의도된 사용 및 요구 사항을 명확히 문서화하여 올바르게 사용되도록 하세요.\n\n결론\n\nSwift에서의 프로토콜 지향 프로그래밍은 유연하고 재사용 가능하며 테스트 가능한 코드를 작성하는 강력한 방법을 제공합니다. 프로토콜 및 그 조합에 집중함으로써 관심사 분리를 촉진하고 유지보수성을 향상시키는 견고한 아키텍처를 만들 수 있습니다. Strategy 및 Dependency Injection과 같은 디자인 패턴을 구현하거나 프로토콜 익스텐션을 사용하여 기본 동작을 활용하는 경우, 프로토콜 지향 프로그래밍을 도입하면 Swift 개발 기술을 크게 향상시킬 수 있습니다. 프로토콜의 힘을 받아 코드를 더 높은 수준으로 발전시키세요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png"},"coverImage":"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI Photo Picker 앱을 PhotosUI로 만들기","description":"","date":"2024-05-27 16:26","slug":"2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI","content":"\n![이미지](/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png)\n\nSwiftUI와 PhotosUI는 iOS 앱에서 풍부하고 인터랙티브한 사용자 인터페이스를 만드는 강력한 도구를 제공합니다. 이 튜토리얼에서는 사용자가 사진 라이브러리에서 사진을 선택하고 표시할 수 있는 앱을 만들겠습니다.\n\n# 프로젝트 설정\n\n- Xcode를 열고 새 SwiftUI 프로젝트를 생성합니다.\n- 프로젝트의 이름을 지정합니다 (예: \"PhotoPickerApp\").\n- 사용자 인터페이스로 SwiftUI를 선택하고 프로그래밍 언어로 Swift를 선택해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 코드 설명\n\n## 단계 1: 필요한 프레임워크 가져오기\n\n```js\nimport SwiftUI\nimport PhotosUI\n```\n\n- SwiftUI: 사용자 인터페이스를 구축하기 위한 프레임워크입니다.\n- PhotosUI: 사진 및 비디오 선택 및 관리를 위한 프레임워크입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2: 상태 변수 정의\n\n```js\nstruct ContentView: View {\n   @State private var selectedPhotos: [PhotosPickerItem] = []\n   @State private var images: [UIImage] = []\n   @State private var errorMessage: String?\n\n   // ... 나머지 코드\n}\n```\n\n- selectedPhotos: 선택된 사진 항목을 저장합니다.\n- images: 불러온 이미지를 저장합니다.\n- errorMessage: 발생한 오류 메시지를 저장합니다.\n\n## 단계 3: 메인 뷰 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nvar body: some View {\n    VStack {\n        Form {\n            photoPickerSection\n            imagesSection\n        }\n        if let errorMessage = errorMessage {\n            Text(errorMessage)\n                .foregroundColor(.red)\n                .padding()\n        }\n    }\n}\n```\n\n- VStack: 폼과 에러 메시지를 포함합니다.\n- Form: 사진 선택기와 이미지를 위한 섹션을 포함합니다.\n\n## 단계 4: 사진 선택기 섹션 정의\n\n```swift\nprivate var photoPickerSection: some View {\n    Section {\n        PhotosPicker(selection: $selectedPhotos, maxSelectionCount: 3, matching: .images) {\n            Label(\"사진 선택\", systemImage: \"photo\")\n        }\n        .onChange(of: selectedPhotos) { _ in\n            loadSelectedPhotos()\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- PhotosPicker: 사진을 선택하는 UI 구성 요소입니다.\n- selection: `selectedPhotos`에 바인딩됩니다.\n- maxSelectionCount: 선택을 3개의 사진으로 제한합니다.\n- matching: 이미지로 제한된 선택을 합니다.\n- .onChange: `selectedPhotos`이 변경될 때 `loadSelectedPhotos`를 호출합니다.\n\n## 단계 5: 이미지 섹션 정의하기\n\n```js\nprivate var imagesSection: some View {\n    Section {\n        ForEach(images, id: \\.self) { image in\n            Image(uiImage: image)\n                .resizable()\n                .scaledToFit()\n                .frame(maxWidth: .infinity)\n                .clipShape(RoundedRectangle(cornerRadius: 10.0))\n                .padding(.vertical, 10)\n        }\n    }\n}\n```\n\n- ForEach: `images` 배열을 반복합니다.\n- Image(uiImage:): 각 이미지를 표시합니다.\n- .resizable(), .scaledToFit(), .frame(maxWidth: .infinity), .clipShape(), .padding(): 이미지를 스타일링합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 6: 선택한 사진 불러오기\n\n```js\nprivate func loadSelectedPhotos() {\n    images.removeAll()\n    errorMessage = nil\n\n    Task {\n        await withTaskGroup(of: (UIImage?, Error?).self) { taskGroup in\n            for photoItem in selectedPhotos {\n                taskGroup.addTask {\n                    do {\n                        if let imageData = try await photoItem.loadTransferable(type: Data.self),\n                           let image = UIImage(data: imageData) {\n                            return (image, nil)\n                        }\n                        return (nil, nil)\n                    } catch {\n                        return (nil, error)\n                    }\n                }\n            }\n\n            for await result in taskGroup {\n                if let error = result.1 {\n                    errorMessage = \"한 개 이상의 이미지를 불러오지 못했습니다.\"\n                    break\n                } else if let image = result.0 {\n                    images.append(image)\n                }\n            }\n        }\n    }\n}\n```\n\n- images.removeAll(): 기존 이미지를 지웁니다.\n- errorMessage = nil: 오류 메시지를 초기화합니다.\n- Task: 비동기 작업을 시작합니다.\n- withTaskGroup: 사진을 로드하는 동시 작업을 관리합니다.\n- photoItem.loadTransferable(type: Data.self): 사진 데이터를 로드합니다.\n- UIImage(data: imageData): 데이터를 `UIImage`로 변환합니다.\n- errorMessage: 오류 발생 시 업데이트됩니다.\n- images.append(image): 로드된 이미지를 배열에 추가합니다.\n\n## 단계 7: 뷰 미리보기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Preview {\n    ContentView()\n}\n```\n\n- # Preview: Xcode 캔버스에서 `ContentView`를 미리 볼 수 있습니다.\n\n# 프로젝트 실행\n\n이제 프로젝트를 시뮬레이터나 실제 장치에 실행하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](https://miro.medium.com/v2/resize:fit:720/1*AtvjZ8d79WvKb85R-jBVVg.gif)\n\n# 요약\n\n이 튜토리얼은 사용자가 사진을 선택하고 표시할 수 있는 SwiftUI 앱을 만드는 방법을 안내했습니다. 상태 관리, 비동기 작업 및 이미지 처리를 다루었습니다. 이 앱은 사진 편집, 저장 또는 공유와 같은 추가 기능으로 확장할 수 있습니다. SwiftUI와 PhotosUI를 활용하여 앱의 기능과 사용자 경험을 향상시켜 보세요.\n\n즐거운 코딩되세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 완성된 코드\n\n이 저장소를 복제하거나 다운로드하여 완전한 코드를 확인하십시오.\n","ogImage":{"url":"/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png"},"coverImage":"/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png","tag":["Tech"],"readingTime":7}],"page":"50","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"50"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>