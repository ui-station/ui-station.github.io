<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/37" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/37" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="루비온레일즈에서 낮은 결합의 중요성" href="/post/2024-05-27-TheImportanceofLowCouplinginRubyonRails"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비온레일즈에서 낮은 결합의 중요성" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-TheImportanceofLowCouplinginRubyonRails_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비온레일즈에서 낮은 결합의 중요성" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비온레일즈에서 낮은 결합의 중요성</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="널 객체 패턴 - 루비 스타일" href="/post/2024-05-27-TheNullObjectPatternTheRubyway"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="널 객체 패턴 - 루비 스타일" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-TheNullObjectPatternTheRubyway_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="널 객체 패턴 - 루비 스타일" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">널 객체 패턴 - 루비 스타일</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비를 사용하여 LLM 애플리케이션을 Langchain과 Qdrant를 이용해 만드는 단계별 가이드" href="/post/2024-05-27-Step-by-StepGuidetoBuildingLLMApplicationswithRubyUsingLangchainandQdrant"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비를 사용하여 LLM 애플리케이션을 Langchain과 Qdrant를 이용해 만드는 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Step-by-StepGuidetoBuildingLLMApplicationswithRubyUsingLangchainandQdrant_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비를 사용하여 LLM 애플리케이션을 Langchain과 Qdrant를 이용해 만드는 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비를 사용하여 LLM 애플리케이션을 Langchain과 Qdrant를 이용해 만드는 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네, 제가 느낀 좌절을 제품으로 만들었어요" href="/post/2024-05-27-YesITurnedmyFrustrationintoaProduct"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네, 제가 느낀 좌절을 제품으로 만들었어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-YesITurnedmyFrustrationintoaProduct_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네, 제가 느낀 좌절을 제품으로 만들었어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">네, 제가 느낀 좌절을 제품으로 만들었어요</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바의 29번째 생일을 축하합니다" href="/post/2024-05-27-Happy29thBirthdayJava"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바의 29번째 생일을 축하합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Happy29thBirthdayJava_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바의 29번째 생일을 축하합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바의 29번째 생일을 축하합니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바에서의 락lock - 파트 63  스탬프락 메서드, 읽기 뷰 및 쓰기 뷰 " href="/post/2024-05-27-LocksInJavaPart63StampedLockMethodsReadViewandWriteView"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바에서의 락lock - 파트 63  스탬프락 메서드, 읽기 뷰 및 쓰기 뷰 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-LocksInJavaPart63StampedLockMethodsReadViewandWriteView_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바에서의 락lock - 파트 63  스탬프락 메서드, 읽기 뷰 및 쓰기 뷰 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바에서의 락lock - 파트 63  스탬프락 메서드, 읽기 뷰 및 쓰기 뷰 </strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년을 위한 자바 개발자를 위한 상위 60개의 스프링 프레임워크 인터뷰 질문책에 있는 모든 질문 포함" href="/post/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년을 위한 자바 개발자를 위한 상위 60개의 스프링 프레임워크 인터뷰 질문책에 있는 모든 질문 포함" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년을 위한 자바 개발자를 위한 상위 60개의 스프링 프레임워크 인터뷰 질문책에 있는 모든 질문 포함" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년을 위한 자바 개발자를 위한 상위 60개의 스프링 프레임워크 인터뷰 질문책에 있는 모든 질문 포함</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">45<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모듈화된 단일 모놀리스의 보안을 OAuth2와 Spring Security로 확보하기" href="/post/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모듈화된 단일 모놀리스의 보안을 OAuth2와 Spring Security로 확보하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모듈화된 단일 모놀리스의 보안을 OAuth2와 Spring Security로 확보하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">모듈화된 단일 모놀리스의 보안을 OAuth2와 Spring Security로 확보하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바에서의 가비지 컬렉션" href="/post/2024-05-27-GarbageCollectionInJava"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바에서의 가비지 컬렉션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-GarbageCollectionInJava_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바에서의 가비지 컬렉션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바에서의 가비지 컬렉션</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="WhatsApp의 감시 소프트웨어 거물에 대한 승리 페가수스의 격퇴" href="/post/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="WhatsApp의 감시 소프트웨어 거물에 대한 승리 페가수스의 격퇴" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="WhatsApp의 감시 소프트웨어 거물에 대한 승리 페가수스의 격퇴" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">WhatsApp의 감시 소프트웨어 거물에 대한 승리 페가수스의 격퇴</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link posts_-active__YVJEi" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"루비온레일즈에서 낮은 결합의 중요성","description":"","date":"2024-05-27 16:08","slug":"2024-05-27-TheImportanceofLowCouplinginRubyonRails","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-TheImportanceofLowCouplinginRubyonRails_0.png\" /\u003e\n\n소프트웨어 엔지니어링에서 낮은 결합의 원칙은 모듈화, 유지 보수 용이성 및 확장 가능한 애플리케이션을 만드는 데 근본적입니다. 낮은 결합은 시스템의 서로 다른 부분 간의 의존성을 줄이는 것을 의미하며 따라서 한 부분에서의 변경이 다른 부분에서 변경을 필요로하지 않도록합니다. Ruby on Rails라는 인기있는 웹 애플리케이션 프레임워크에서 낮은 결합의 원칙을 준수하면 코드베이스의 품질과 관리 용이성을 크게 향상시킬 수 있습니다. 이 기사에서는 낮은 결합의 중요성을 탐구하고 Ruby on Rails에서 어떻게 실현할 수 있는지를 실제 예제와 함께 보여줍니다.\n\n## 낮은 결합의 중요성\n\n보다 쉬운 유지 보수: 애플리케이션의 구성 요소가 느슨하게 결합되어있을 때 한 부분의 변경이 다른 부분에 영향을 미칠 가능성이 적어집니다. 이 격리는 유지 보수를 단순화하고 코드를 수정할 때 버그를 도입할 위험을 줄입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경했습니다.\n\n개선된 테스트 용이성: 느슨하게 결합된 구성 요소는 독립적으로 테스트할 수 있어 더 신뢰할 수 있고 효율적인 테스트 프로세스를 이끌어냅니다. 이를 통해 응용 프로그램의 개별 부분이 전체 시스템에 의존하지 않고 올바르게 작동하는지 확인할 수 있습니다.\n\n향상된 재사용성: 낮은 결합도의 구성 요소는 응용 프로그램의 다른 부분이나 다른 프로젝트에서 재사용할 수 있습니다. 이는 DRY (반복하지 마세요) 원칙을 촉진하고 개발을 가속화합니다.\n\n더 나은 확장성: 낮은 결합도를 가진 응용 프로그램은 독립적인 구성 요소를 개발하고 배포하며 확장하기 쉬워집니다.\n\n## 예시: Rails에서의 사용자 등록 및 알림\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 등록을 구현하고 등록에 성공했을 때 환영 이메일을 보내는 시나리오를 고려해 봅시다. 이 시나리오에서 낮은 결합도를 달성하는 것은 사용자 등록 로직을 이메일 전송 로직에서 분리하는 것을 의미합니다.\n\n낮은 결합도 없이\n\n결합도가 높은 디자인에서는 사용자 등록 로직과 이메일 전송 로직이 UsersControler에 함께 위치할 수 있습니다. 이러한 접근 방식은 유지보수와 테스트가 어려운 컨트롤러로 이어질 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-TheImportanceofLowCouplinginRubyonRails_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저렇게 테이블 태그를 마크다운 형식으로 변경해주시면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메일러:\n\n![Mailer Image](/assets/img/2024-05-27-TheImportanceofLowCouplinginRubyonRails_3.png)\n\n컨트롤러:\n\n![Controller Image](/assets/img/2024-05-27-TheImportanceofLowCouplinginRubyonRails_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 설명 \n\n**역할 분리**: UsersController는 HTTP 요청과 응답을 처리하는 데 전적으로 책임이 있습니다. UserRegistrationService는 사용자 등록의 비즈니스 로직을 처리하고, UserMailer는 이메일 전송을 관리합니다. 각 클래스는 단일 책임을 가지고 있어 코드를 이해하고 유지하기 쉽게 만듭니다.\n\n**테스트를 위한 격리**: 이 설계는 컨트롤러를 건드리지 않고 UserRegistrationService의 독립적인 테스트를 가능하게 합니다. 마찬가지로 메일러는 이메일이 올바르게 전송되는지 확인하기 위해 격리된 환경에서 테스트할 수 있습니다.\n\n**유연성**: 이메일 전송 메커니즘이 변경되더라도(예: 다른 이메일 서비스로 전환) UserMailer 클래스만 수정하면 되어 사용자 등록 로직에 영향을 주지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n낮은 결합도는 유지보수가 쉬우며 테스트 가능하고 유연한 애플리케이션을 만드는 중요한 설계 원칙입니다. 루비 온 레일즈(Ruby on Rails)에서는 서비스 객체, 메일러 및 다른 관심사 분리를 촉진하는 패턴을 활용하여 낮은 결합도를 달성할 수 있습니다. 이 원칙을 준수함으로써 개발자는 관리하기 쉽고 시간이 지나도 발전할 수 있는 견고한 레일즈 애플리케이션을 구축할 수 있습니다. 낮은 결합도를 수용함으로써 현재 코드베이스의 상태를 개선할 뿐만 아니라 향후 개발 및 확장 노력에 민첩하게 대처할 수 있는 견고한 기반을 마련할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-27-TheImportanceofLowCouplinginRubyonRails_0.png"},"coverImage":"/assets/img/2024-05-27-TheImportanceofLowCouplinginRubyonRails_0.png","tag":["Tech"],"readingTime":3},{"title":"널 객체 패턴 - 루비 스타일","description":"","date":"2024-05-27 16:07","slug":"2024-05-27-TheNullObjectPatternTheRubyway","content":"\n\n![image](/assets/img/2024-05-27-TheNullObjectPatternTheRubyway_0.png)\n\n# 소개\n\n당신은 아마도 위의 기사 이미지에서 보듯 유사한 오류를 만나본 적이 있을 것입니다. 뭔가 다음과 같은 내용이 포함되어 있죠: \"undefined method 'username' for nil:NilClass\".\n\n이 문구는 그저 'username' 메서드를 누락된 객체에 적용할 수 없다는 것을 의미합니다. 즉, 당신이 메서드 이름을 잘못 입력했거나 데이터베이스에서 제공된 ID로 찾는 객체가 삭제되었을 수 있습니다. 따라서, 이곳이 바로 Null 객체 패턴을 사용하여 이러한 공포스러운 화면을 피할 수 있는 정확한 장소입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n널 객체 패턴은 코드에서 널 체크를 제거하는 데 도움이 되는 행동 디자인 패턴입니다. 이는 Nil 예외의 피해를 최소화하고 코드를 더 선언적이고 DRY하게 만들어주는 매우 유용한 도구입니다.\n\n간단히 말해서, 이것은 ActiveRecord 객체에 대해 끝없이 'present?' 또는 'try?'를 호출하는 것을 막아주는 훌륭한 해킹입니다.\n\n널 객체는 실제 객체의 부재 상황에서 실제 객체를 대신하여 나타낼 수 있으므로, 소비 코드가 실제 객체의 부재를 명시적으로 처리하고 널 체크를 수행할 필요가 없습니다.\n\n그럼 시작해 볼까요...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 루비에서 널 객체 패턴 구현\n\n널 객체 패턴을 소개하는 간단하면서도 유익한 방법은 일반적인 시나리오를 고려해보는 것입니다. 사용자의 사용자 이름, 이메일 또는 이름을 출력하는 경우를 생각해보겠습니다. 제공된 ID를 가진 사용자가 이미 데이터베이스에서 삭제되었을 때의 상황을 가정해봅시다.\n\n```js\n# 케이스 1\n@user_1 = User.find_by(email: \"deleted.user@mymail.com\")\n@user_1.first_name\n\n# 케이스 2\n@user_2 = User.find(34)\n@user_2.username\n```\n\n그리고 이러한 상황에서 여러분이 받게 되는 것은 이 오류 메시지뿐입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Case 1\nnil:NilClass에 대한 nil을 위한 'first_name' 메소드가 정의되지 않았습니다.\n\n# Case 2\nnil:NilClass에 대한 nil을 위한 'username' 메소드가 정의되지 않았습니다.\n```\n\n물론, 세상이 끝나는 것은 아닙니다. 오류를 피하는 몇 가지 방법이 있습니다. 여기에 있습니다:\n\n```js\n# 해결책 1 / 'try' 메소드 사용.\n@user.try(:first_name)\n\n\n# 해결책 2 / 조건 연산자 사용.\nif @user.exists?\n @user.first_name\nend\n```\n\n이러한 종류의 확인 사항은 쉽게 여러분의 코드를 확인 사항과 조건 연산자의 혼란으로 바꿀 수 있습니다. 우리가 한 것과 대조적으로 한 번만 하고 모든 곳에서 사용할 수 있는 더 나은 방법이 있습니다. 이는 코드를 보기 좋게 만들어줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스에 없는 사용자 객체에 대체될 'DeletedUser' 클래스를 정의해 봅시다. 이 클래스는 실제 사용자 객체를 흉내 내도록 동일한 일반 속성/메서드를 갖게 될 것입니다.\n\n```js\nclass DeletedUser\n  def first_name\n   \"알 수 없는 이름\"\n  end\n\n  def last_name\n    \"알 수 없는 성\"\n  end\n\n  def username\n    \"알 수 없는 사용자 이름\"\n  end\n\n  def email\n    \"이미 삭제된 사용자입니다. 이메일: already.deleted.user@mail.com\"\n  end\nend\n```\n\n이전 코드에서 사용자로부터 기대한 것을 얻지 못했던 것을 기억하나요? 사용자가 우리의 요청을 따르지 않았고, 이제 그것을 다스리는 방법을 찾았습니다. 사용자를 찾지 못했다면, 'DeletedUser' 객체의 인스턴스로 ' @user_1` 및 '@user_2' 변수를 초기화합니다.\n\n```js\n# 케이스 1\n@user_1 = User.find_by(email: \"deleted@user.com\") || DeletedUser.new\n@user_1.first_name #=\u003e \"알 수 없는 이름\"\n@user_1.email #=\u003e \"이미 삭제된 사용자입니다. 이메일: already.deleted.user@mail.com\"\n\n# 케이스 2\n@user_2 = User.find(34) || DeletedUser.new\n@user_2.username #=\u003e \"알 수 없는 사용자 이름\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 객체가 항상 예상한 메서드에 응답할 것이라는 점을 확신할 수 있어요.\n\n# 장단점\n\nNull 객체 패턴은 다음 시나리오에서 특히 유용해요:\n\n- 기본 값: 누락된 객체에 대한 기본 값이나 동작을 제공하고 싶을 때.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조심하세요, 때로는 이 패턴이 다음과 같습니다:\n\n- 속일 수 있음: 오류/버그를 일반적인 프로그램 실행으로 나타낼 수 있음.\n\n# 결론\n\n널 객체 패턴은 누락된 객체를 깨끗하고 유지보수 가능한 방식으로 처리하기 위한 강력한 도구입니다. 실제 객체의 동작을 흉내 내는 널 객체를 생성함으로써 코드를 단순화하고 테스트를 쉽게 할 수 있습니다. 필요한 객체가 없을 때 우아하게 처리해야 할 필요가 있을 때 이 패턴을 고려할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n널 객체 패턴은 데이터베이스 쿼리에서 데이터를 반환하지 않는 경우 외에도 유용하게 활용할 수 있습니다.\n\n그럼, 널 객체 패턴에 대한 내용이었습니다. 여러분의 코드를 더 예쁘고 의미있게 만들기 위해 어디선가 활용해보세요.\n\n안전하고 건강하게 지내세요!\n\n![이미지](/assets/img/2024-05-27-TheNullObjectPatternTheRubyway_1.png)\n","ogImage":{"url":"/assets/img/2024-05-27-TheNullObjectPatternTheRubyway_0.png"},"coverImage":"/assets/img/2024-05-27-TheNullObjectPatternTheRubyway_0.png","tag":["Tech"],"readingTime":4},{"title":"루비를 사용하여 LLM 애플리케이션을 Langchain과 Qdrant를 이용해 만드는 단계별 가이드","description":"","date":"2024-05-27 16:04","slug":"2024-05-27-Step-by-StepGuidetoBuildingLLMApplicationswithRubyUsingLangchainandQdrant","content":"\n\u003cimg src=\"/assets/img/2024-05-27-Step-by-StepGuidetoBuildingLLMApplicationswithRubyUsingLangchainandQdrant_0.png\" /\u003e\n\n소프트웨어 개발의 세계에서 프로그래밍 언어와 도구의 선택은 단순히 선호도의 문제가 아니라 프로젝트 결과에 상당한 영향을 미칠 수 있는 전략적인 선택입니다. 파이썬이 인공 지능(AI) 및 기계 학습(ML) 애플리케이션에서 선두 주자였던 반면, 루비의 잠재력은 이러한 영역에서 여전히 충분히 발휘되지 않았습니다. 이 안내서는 특히 고급 AI 구현의 맥락에서 루비의 능력을 밝히고자 합니다.\n\n우아하고 간결함으로 유명한 루비는 작성하기 쉽기만한 문법과 읽기 즐거운 문법을 제공합니다. 주로 웹 개발에서 유능함으로 인정받았던 이 언어는 AI 및 ML 분야에서는 과소평가되고 있습니다. 그러나 견고한 프레임워크와 커뮤니티 주도의 접근 방식으로, 루비는 특히 이미 루비 생태계에 몸담은 팀 및 프로젝트에 대한 선택지로 자리잡고 있습니다.\n\n우리의 여정은 루비가 LangChain, Mistral 7B, 그리고 Qdrant Vector DB와 같은 최첨단 기술과 효과적으로 결합되어 얼마나 활용될 수 있는지를 탐색함으로 시작됩니다. 이러한 도구들이 결합되면 정교한 Retriever-Augmented Generation (RAG) 모델을 만들 수 있습니다. 이 모델은 루비가 더 전통적인 AI 언어와 어깨를 나란히 할 수 있는 능력을 보여줍니다. 이는 AI 및 ML 분야에서 새로운 지평을 열어주며 루비 애호가들을 위한 새로운 가능성을 제시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Ruby 설치 가이드\n\n루비의 이러한 측면을 이해하면 프로그래밍에 가져다주는 가치와 파워를 더욱 높이게 될 것입니다. 설치 과정은 보상을 받는 여정의 첫걸음입니다.\n\n## 원하는 루비 버전 매니저 선택\n\n버전 매니저를 선택하는 것은 집을 건설할 때 올바른 기초를 선택하는 것과 같습니다. 루비의 다양한 버전 및 의존성을 관리하는 데 필수적이기 때문입니다. 이는 루비의 자주 업데이트되는 언어와 서로 다른 프로젝트의 요구 사항 때문에 특히 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## RVM (루비 버전 관리자)\n\n장점: 루비 환경을 효율적으로 관리할 수 있는 방법을 제공합니다. 여러 루비 버전 및 젬 세트(젬셋)를 처리하는 데 좋습니다. 또한 동일한 컴퓨터에서 여러 루비 환경을 설치, 관리 및 사용할 수 있습니다. 이는 여러 프로젝트에 작업하는 개발자에게 이상적입니다.\n\n## 설치 안내\n\n## 시스템 패키지 업데이트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시스템을 최신 상태로 유지하려면 다음 명령을 실행하세요:\n\n```bash\nsudo apt update\nsudo apt upgrade\n```\n\n루비 설치에 필요한 종속성을 설치하세요:\n\n```bash\nsudo apt install git curl libssl-dev libreadline-dev zlib1g-dev autoconf bison build-essential libyaml-dev libreadline-dev libncurses5-dev libffi-dev libgdbm-dev\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo apt install rbenv\n```\n\nGitHub에서 가져온 설치 스크립트를 사용하여 rbenv를 설치하세요:\n\n```js\ncurl -fsSL https://github.com/rbenv/rbenv-installer/raw/HEAD/bin/rbenv-installer | bash\n```\n\nrbenv 명령어를 사용하기 위해 $PATH에 ~/.rbenv/bin을 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\necho 'export PATH=\"$HOME/.rbenv/bin:$PATH\"' \u003e\u003e ~/.bashrc\n```\n\nrbenv를 자동으로 로드하도록 초기화 명령어를 추가하세요:\n\n```js\necho 'eval \"$(rbenv init -)\"' \u003e\u003e ~/.bashrc\n```\n\n모든 변경 사항을 쉘 세션에 적용하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sh\n소스 ~/.bashrc\n```\n\nrbenv이 제대로 설정되었는지 확인하세요:\n\n```sh\ntype rbenv\n```\n\n## Ruby-Build\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루비 빌드는 유니스류 시스템에서 소스로부터 루비 버전을 설치하는 과정을 간소화하기 위해 설계된 명령줄 유틸리티입니다.\n\n## 루비 버전 설치\n\nrbenv install 명령은 rbenv에 기본적으로 포함되어 있지 않습니다. 대신에 ruby-build 플러그인에서 제공됩니다.\n\n루비를 설치하기 전에 필요한 도구와 라이브러리가 포함된 빌드 환경을 확인하세요. 확인이 완료되면 다음 단계를 따르세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 최신 안정 버전 목록:\nrbenv install -l\n# 모든 로컬 버전 목록:\nrbenv install -L\n# Ruby 버전 설치:\nrbenv install 3.1.2\n\n\n# 왜 Ruby를 선택해야 하는가?\n\nRuby는 프로그래밍 세계에서 실무자들 사이에 잘 보호된 비밀 같은 존재입니다. AI와 ML 분야에서 Python의 높은 인기에 가려져, Ruby의 이 분야에서의 능력은 종종 간과되곤 합니다.\n\nRuby의 진정한 강점은 그 간단함에 있으며 사용자들에게 제공하는 생산성입니다. 이 언어의 우아한 구문과 튼튼한 표준 라이브러리는 신속한 개발 주기에 이상적인 후보입니다. 코드 작성의 용이성뿐만 아니라, 그것을 유지하는 용이성에 있습니다. Ruby의 가독성이 뛰어나고 직관적인 코드베이스는 장기 프로젝트를 위한 큰 도움이 됩니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기존 응용 프로그램 스택에서는 이미 Ruby가 핵심 구성 요소로 사용되고 있습니다. 이러한 스택에 AI 기능을 전환하거나 통합하는 것은 새로운 언어인 Python으로 전환할 필요가 없다는 것을 의미합니다. 대신, AI 응용 프로그램에 대한 기존 Ruby 워크플로를 활용하는 것이 실용적이고 효율적인 접근 방법이 될 수 있습니다.\n\n또한 Ruby의 생태계는 AI 및 ML 작업에 적합한 라이브러리와 도구로 장착되어 있습니다. 딥 러닝을 위한 Ruby-DNN과 머신 러닝을 위한 Rumale과 같은 젬들은 Ruby가 이러한 분야에서 점차 늘어나는 능력을 입증하고 있습니다.\n\n따라서 이미 Ruby에 익숙한 응용 프로그램 및 팀에 대해, Ruby를 계속 사용하여 AI 및 ML 작업을 수행하는 것은 안락함뿐만 아니라 전략적 효율성의 문제입니다.\n\n## Ruby로 기본 데이터 처리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 간단한 데이터 처리\ndata = [2, 4, 6, 8, 10]\nprocessed_data = data.map { |number| number * 2 }\nputs processed_data\n```\n\n## 출력\n\n```js\n[4, 8, 12, 16, 20];\n```\n\n## 루비로 하는 기본 머신 러닝\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"rumale\"을 설치하려면 RubyGems 패키지 매니저를 사용하세요. 터미널에서 다음 명령을 실행해주세요:\n\n```js\ngem install rumale\n```\n\n\"rumale\"을 설치한 후에, gem 파일에 다음 줄을 추가해주세요:\n\n```js\ngem \"rumale\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```ruby\n# 단순 선형 회귀를 위해 Rumale 젬을 사용합니다\nrequire 'rumale'\nx = [[1, 2], [2, 3], [3, 4], [4, 5]]\ny = [1, 2, 3, 4]\nmodel = Rumale::LinearModel::LinearRegression.new\nmodel.fit(x, y)\npredictions = model.predict(x)\n# Numo::DFloat를 Ruby 배열로 변환합니다\npredictions_array = predictions.to_a\nputs \"예측 값: #{predictions_array}\"\n```\n\n이 코드 예제들은 Ruby의 간단한 작업 처리 방식을 보여줍니다. 이는 AI 및 ML을 포함한 다양한 응용 프로그램에 대한 접근성과 강력함을 제공합니다.\n\n### 아키텍처: LangChain, Mistral 7B, GPU 노드 위의 Qdrant\n\n저희 Ruby 기반 AI 시스템 아키텍처에서는 LangChain, Mistra 7B, 그리고 Qdrant 세 가지 주요 구성 요소를 통합하고 있습니다. 각 구성 요소는 시스템의 기능성에 중요한 역할을 하며 특히 GPU 노드에서 활용될 때 중요합니다. 각 구성 요소에 대해 자세히 살펴보고 전체 아키텍처에 어떻게 기여하는지 이해해 봅시다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## LangChain\n\nLangChain은 언어 모델의 구축과 활용을 용이하게 하는 오픈 소스 라이브러리입니다. 언어 처리 작업의 복잡성을 추상화하여 개발자가 정교한 NLP 기능을 구현하기 쉽도록 설계되었습니다. Ruby 환경에서 LangChain은 언어 모델과 데이터베이스 간 상호작용을 관리하는 오케스트레이터 역할을 합니다.\n\n## Mistral 7B\n\nMistral 7B는 Transformer 모델의 변형 버전으로, 자연어 처리 작업에서 효율적이고 효과적인 성능으로 알려져 있습니다. AI 및 기계 학습 분야의 선두주자인 Hugging Face에서 제공되며, Mistral 7B는 인간과 유사한 텍스트를 이해하고 생성하는 데 능숙합니다. 우리의 아키텍처에서 Mistral 7B는 핵심 언어 이해 및 생성 작업을 담당합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 큐드런트\n\n큐드런트는 주로 AI 및 ML 애플리케이션에서 찾을 수 있는 고차원 데이터를 처리하기에 최적화된 벡터 데이터베이스로 작용합니다. 이는 벡터의 효율적인 저장 및 검색을 위해 설계되었으며, Mistral 7B와 같은 AI 모델로부터 생성되고 사용되는 데이터를 관리하기에 이상적인 솔루션입니다. 저희 설정에서는 큐드런트가 언어 모델에서 생성된 벡터의 저장을 담당하며, 빠르고 정확한 검색을 용이하게 합니다.\n\n## GPU 노드 활용\n\n이 아키텍처에 GPU 노드를 포함하는 것은 중요합니다. GPU는 병렬 처리 능력을 통해 AI 및 ML에 관련된 계산 집약적 작업에 매우 적합합니다. GPU 노드에서 구성 요소를 실행함으로써 시스템의 성능을 크게 향상시킬 수 있습니다. GPU는 Mistral 7B 및 큐드런트의 작업을 가속화하여 언어 모델이 데이터를 신속하고 효율적으로 처리하도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 구성 요소 통합\n\n이러한 구성 요소의 루비 환경 통합은 핵심적입니다. 랭체인은 루비 인터페이스를 통해 미스트랄 7B 모델과 큐드란트 데이터베이스 간 상호 작용을 조율하는 중심 요소로 작용합니다. 미스트랄 7B 모델은 언어 데이터를 처리하고 텍스트를 의미 있는 벡터로 변환한 다음 큐드란트에 의해 저장되고 관리됩니다. 이 설정을 통해 데이터가 효율적으로 처리되고 저장되며 검색되어 GPU의 능력을 최대한 활용할 수 있는 워크플로우가 구축됩니다.\n\n## 루비에서 LangChain 초기화\n\n\"LangChain\"과 \"transformer\"를 설치하려면 RubyGems 패키지 관리자를 사용하십시오. 터미널에서 다음을 실행하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ngem install langchainrb\ngem install hugging-face\n```\n\n이 명령은 LangChain과 transformers 및 그 종속성을 설치합니다. \"langchain\" 및 \"transformers\"를 설치한 후, gem 파일에 다음 줄을 추가하세요:\n\n```js\ngem \"langchainrb\"\ngem \"hugging-face\"\n```\n\n## Hugging Face 및 LangChain과 상호 작용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```ruby\nrequire 'langchain'\nclient = HuggingFace::InferenceApi.new(api_token:\"hf_llpPsAVgQYqSmWhlC*****\") # add your inference endpoint api key.\nputs client\n```\n\n# 루비에서 Qdrant 클라이언트 설정하기\n\n루비에서 Qdrant와 상호 작용하려면 qdrant_client 젬을 설치해야 합니다. 이 젬은 Qdrant API에 편리한 루비 인터페이스를 제공합니다. 터미널을 통해 다음과 같이 설치할 수 있습니다:\n\n```sh\ngem install qdrant-ruby\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n“qdrant-ruby”을 설치한 후 젬 파일에 다음 줄을 추가해주세요:\n\n```js\ngem \"qdrant-ruby\"\n```\n\n```js\nrequire 'qdrant'\n# Qdrant 클라이언트를 초기화합니다.\nclient = Qdrant::Client.new(\n url: \"여러분의-qdrant-URL\",\n api_key: \"여러분의-qdrant-API-키\"\n)\n```\n\n이 아키텍처는 루비에서 인공 지능 및 기계 학습에 대한 혁신적인 접근 방식을 보여주며, 해당 언어의 유연성과 첨단 인공 지능 도구 및 기술과 통합할 수 있는 능력을 뽐내고 있습니다. 특히 LangChain, Mistral 7B 및 Qdrant 간의 시너지는 GPU 노드에서 활용될 때 강력하고 효율적인 인공 지능 시스템을 만들어냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# LangChain - 루비 설치 가이드\n\n![LangChain](/assets/img/2024-05-27-Step-by-StepGuidetoBuildingLLMApplicationswithRubyUsingLangchainandQdrant_1.png)\n\nLangChain은 언어 모델을 구축하기 위한 혁신적인 라이브러리로, 루비 기반의 AI 아키텍처에서 중심적인 역할을 합니다. 복잡한 언어 처리 작업을 통합하는 간소화된 방법을 제공합니다. 이제 루비 환경에서 LangChain을 설치하고 코드 스니펫을 통해 기본 사용법을 살펴보겠습니다.\n\n## LangChain 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLangChain을 설치하기 전에 시스템에 Ruby가 설치되어 있는지 확인하세요. LangChain은 Ruby 버전 2.5 이상이 필요합니다. Ruby 버전을 확인하려면 \"ruby -v\" 명령을 사용하실 수 있습니다. 올바른 Ruby 버전이 설치되어 있다면 다음과 같이 설치를 진행할 수 있습니다:\n\n## Ruby 스크립트에 LangChain을 요구하세요\n\n설치 후에는 Ruby 스크립트에 LangChain을 포함하여 사용을 시작할 수 있습니다:\n\n```rb\nrequire 'langchain'\nrequire \"hugging_face\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 시작하는 방법이 있습니다:\n\n### 언어 모델 초기화\n\nLangChain을 사용하면 다양한 종류의 언어 모델을 초기화할 수 있습니다. 기본 모델을 초기화하는 예제를 보여드리겠습니다:\n\n```js\nclient = HuggingFace::InferenceApi.new(api_token:\"hf_llpPsAVgQYqSmW*****\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Mistral 7B (Hugging Face 모델): 루비 설치 가이드\n\n루비 애플리케이션에 Hugging Face의 Mistral 7B 모델을 통합하는 것은 최첨단 자연어 처리 (NLP) 능력을 활용하는 강력한 방법을 제공합니다. 여기에는 Mistral 7B를 루비에서 설치하고 사용하는 방법에 대한 자세한 안내서 및 시작하는 데 도움이 되는 코드 조각이 포함되어 있습니다.\n\n## 루비에서 Mistral 7B 설치\n\nMistral 7B를 사용하려면 먼저 transformers-ruby 젬을 설치해야 합니다. 이 젬은 Hugging Face의 Transformers 라이브러리에 대한 루비 인터페이스를 제공합니다. 터미널을 통해 다음과 같이 설치할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ngem install hugging-face\n```\n\n## 루비 스크립트에서 HuggingFace 및 LangChain Gem을 요구하십시오\n\n설치한 후에는 HuggingFace 및 LangChain 젬을 루비 스크립트에 포함시키세요:\n\n```js\nrequire 'langchain'\nrequire \"hugging_face\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Mistral 7B 모델을 초기화합니다\n\nMistral 7B를 사용하려면 Hugging Face를 사용하여 초기화해야 합니다. 다음은 초기화하는 방법입니다:\n\n```js\n# 텍스트 생성을 위해 Mistral 7B 모델을 초기화합니다\nmodel = \"mistralai/Mistral-7B-v0.1\"\ncall_model = client.call(model:model,input:{ inputs: '더 많은 세부 정보에 대해 알려주시겠어요?'})\n```\n\n## Mistral 7B로 텍스트 생성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMistral 7B는 텍스트 생성과 같은 다양한 NLP 작업에 사용될 수 있습니다. 아래는 텍스트를 생성하는 예제입니다:\n\n```js\ntest = Langchain::LLM::HuggingFaceResponse.new(call_model, model: model)\nputs test.raw_response[0][\"generated_text\"]\n```\n\n# Qdrant: 루비 설치 안내서\n\n\u003cimg src=\"/assets/img/2024-05-27-Step-by-StepGuidetoBuildingLLMApplicationswithRubyUsingLangchainandQdrant_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nQdrant은 머신 러닝 작업에 최적화된 강력한 벡터 검색 엔진으로, Ruby에서 AI 애플리케이션에 이상적인 선택지입니다. 이 섹션에서는 Ruby 환경에서 Qdrant를 설치하고 사용하는 방법에 대해 자세히 안내하며, 코드 스니펫이 포함되어 있습니다.\n\n## Ruby에서 Qdrant 설치하기\n\nQdrant 클라이언트 젬 설치\n\nRuby에서 Qdrant와 상호 작용하려면 qdrant_client 젬을 설치해야 합니다. 이 젬은 Qdrant API에 편리한 Ruby 인터페이스를 제공합니다. 터미널을 통해 다음과 같이 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ngem install qdrant-ruby\n```\n\n“qdrant-ruby”를 설치한 후, 젬 파일에 다음 라인을 추가해주세요:\n\n```js\ngem \"qdrant-ruby\"\n```\n\n# 루비 스크립트에서 Qdrant 클라이언트를 요청하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이젠 gem을 설치한 후 Ruby 스크립트에 포함하세요:\n\n```js\nrequire 'qdrant'\n```\n\nQdrant 클라이언트를 설치하면 Ruby 어플리케이션에서 해당 기능을 활용할 수 있습니다.\n\n# Qdrant 클라이언트 초기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nQdrant 서버에 연결하려면 Qdrant 클라이언트를 초기화하십시오. 로컬 또는 원격으로 실행 중인 Qdrant 서버가 있어야 합니다.\n\n```js\n# Qdrant 클라이언트 초기화\nclient = Qdrant::Client.new(\n url: \"your-qdrant-url\",\n api_key: \"your-qdrant-api-key\"\n)\n```\n\n## Qdrant에서 컬렉션 만들기\n\nQdrant에서의 컬렉션은 전통적인 데이터베이스의 테이블과 유사합니다. 벡터와 해당 payload를 저장합니다. 다음은 컬렉션을 만드는 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Qdrant에 컬렉션 만들기\ncollection_name = 'my_collection'\nqdrant_client.create_collection(collection_name)\n```\n\n## 컬렉션에 벡터 삽입하기\n\n컬렉션에 벡터를 삽입합니다. 이러한 벡터는 NLP 모델로부터의 텍스트 임베딩과 같은 다양한 데이터 지점을 나타낼 수 있습니다.\n\n```js\n# 예시: 벡터를 컬렉션에 삽입하기\nvector_id = 1\nvector_data = [0.1, 0.2, 0.3] # 예시 벡터 데이터\nqdrant_client.upsert_points(collection_name, [{ id: vector_id, vector: vector_data }])\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 비슷한 벡터 검색하기\n\nQdrant는 비슷한 벡터를 검색하는 데 능숙합니다. 다음은 벡터 검색을 수행하는 방법입니다:\n\n```js\n# 벡터 검색 수행\nquery_vector = [0.1, 0.2, 0.3] # 예시 쿼리 벡터\nsearch_results = qdrant_client.search(collection_name, query_vector)\nputs search_results\n```\n\n## Mistral 7B 및 LangChain에 Qdrant 통합\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nQdrant를 Mistral 7B와 LangChain과 통합하는 것은 고급 AI 응용 프로그램을 가능하게 합니다. 예를 들어, AI 생성 콘텐츠로 구동되는 검색 엔진을 만들거나 벡터 기반 검색을 통해 언어 모델을 개선할 수 있습니다.\n\n```js\n# LangChain 및 HuggingFace 초기화\nrequire 'langchain'\nrequire 'hugging_face'\n\n# API 토큰으로 HuggingFace 클라이언트 초기화\nclient = HuggingFace::InferenceApi.new(api_token: \"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\")\n\n# 텍스트 생성 및 임베딩을 위한 모델 정의\nmistral_model = \"mistralai/Mistral-7B-v0.1\"\nembedding_model = 'sentence-transformers/all-MiniLM-L6-v2'\n\n# Mistral 모델을 사용하여 텍스트 생성\ntext_generation = client.call(model: mistral_model, input: { inputs: 'Can you please let us know more details about your '})\n\n# Mistral 모델을 위한 LangChain 클라이언트 초기화\nllm = Langchain::LLM::HuggingFaceResponse.new(text_generation, model: mistral_model)\n\n# LangChain 응답에서 생성된 텍스트 추출\ngenerated_text = llm.raw_response[0][\"generated_text\"]\n\n# 생성된 텍스트를 임베딩 모델을 사용하여 임베딩\nembedding_text = client.call(model: embedding_model, input: { inputs: generated_text })\n\n# 임베딩 모델을 위한 LangChain 클라이언트 초기화\nllm_embed = Langchain::LLM::HuggingFaceResponse.new(embedding_text, model: embedding_model)\n\n# LangChain 응답에서 임베딩된 텍스트 추출\ngenerated_embed = llm_embed.raw_response\n\n# 생성된 임베딩 텍스트를 출력\nputs generated_embed\n\n# Qdrant 클라이언트 초기화\nqdrant_client = Qdrant::Client.new(\n url: \"your-qdrant-url\",\n api_key: \"your-qdrant-api-key\"\n)\n\n# 생성된 텍스트를 벡터로 변환하여 Qdrant에 저장\nqdrant_client.upsert_points('my_collection', [{ id: 1, vector: generated_embed }])\n```\n\n위 예제는 Qdrant가 Ruby 응용 프로그램에 신속하게 통합될 수 있음을 보여줍니다. 이를 통해 현대 AI 및 ML 응용 프로그램에서 중요한 강력한 벡터 기반 작업을 가능하게 합니다. Qdrant의 효율적인 벡터 처리 기능과 Ruby의 간결함과 우아함이 결합되어 개발자들이 고급 데이터 처리 및 검색 시스템을 탐색할 수 있는 새로운 방법이 열립니다.\n\n# Qdrant, Mistral 7B, LangChain 및 Ruby 언어를 사용하여 RAG (LLM) 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![RAG Model](/assets/img/2024-05-27-Step-by-StepGuidetoBuildingLLMApplicationswithRubyUsingLangchainandQdrant_3.png)\n\n클린체인과 Qdrant를 사용하여 루비 언어로 작성된 LLM 애플리케이션을 구축하는 단계별 가이드에서 Retriever-Augmented Generation (RAG) 모델을 만드는 과정은 고급 AI 분야로의 정교한 진출입니다. 이 섹션에서는 이러한 구성 요소를 통합하여 효율적이고 강력한 RAG 모델을 구축하는 과정을 안내합니다.\n\n## 개념적 개요\n\nRetriever (Qdrant): Qdrant는 RAG 모델에서 우리의 검색기 역할을 합니다. 이는 고차원 벡터(텍스트 데이터의 표현)를 효율적으로 저장하고 검색합니다. 이러한 벡터는 Mistral 7B 모델을 사용하여 텍스트에서 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 생성기 (Mistral 7B):\n\nMistral 7B는 transformer 모델로, 생성기 역할을 합니다. 이 모델은 텍스트 임베딩을 생성하는 데 사용되며 (Qdrant에 저장하기 위해) 입력 프롬프트와 Qdrant에서 검색된 문맥 데이터를 기반으로 사람과 유사한 텍스트를 생성합니다.\n\n오케스트레이션 (LangChain):\nLangChain은 검색기와 생성기를 결합하여 함께 작동합니다. Qdrant와 Mistral 7B 간의 데이터 흐름을 관리하며, 검색기의 출력이 생성기에 의해 효과적으로 활용되어 관련성이 있는 일관된 텍스트가 생성되도록 보장합니다.\n\n## 코드 통합\n\n이것이 이러한 시스템을 구축하는 구조화된 접근 방식입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 텍스트 생성: Hugging Face API를 사용하여 사용자의 프롬프트를 기반으로 텍스트 생성하기\n- 텍스트 임베딩: 생성된 텍스트를 문장 변환 모델을 사용하여 벡터 표현으로 변환하기\n- Qdrant 검색: 임베드된 벡터를 사용하여 Qdrant 데이터베이스를 쿼리하고 가장 관련성 있는 데이터 검색하기\n- 응답 구성: 원본 생성된 텍스트와 검색된 정보를 결합하여 최종 응답 형성하기\n\n```js\nrequire 'langchain'\nrequire 'hugging_face'\nrequire 'qdrant_client'\n\n# API 토큰을 사용하여 HuggingFace 클라이언트 초기화\nhf_client = HuggingFace::InferenceApi.new(api_token: \"your-hf-api-token\")\n\n# 모델 정의\nmistral_model = \"mistralai/Mistral-7B-v0.1\"\nembedding_model = 'sentence-transformers/all-MiniLM-L6-v2'\n\n# 텍스트 생성하는 함수\ndef generate_text(hf_client, model, prompt)\n response = hf_client.call(model: model, input: { inputs: prompt })\n response[0][\"generated_text\"]\nend\n\n# 텍스트 임베딩하는 함수\ndef embed_text(hf_client, model, text)\n response = hf_client.call(model: model, input: { inputs: text })\n response[0][\"vector\"]\nend\n\n# Qdrant 클라이언트 초기화\nqdrant_client = Qdrant::Client.new(url: \"your-qdrant-url\", api_key: \"your-qdrant-api-key\")\n# Qdrant에서 데이터를 검색하는 함수\ndef retrieve_from_qdrant(client, collection, vector, top_k)\n client.search_points(collection, vector, top_k)\nend\n\n# 사용자 프롬프트\nuser_prompt = \"사용자의 프롬프트를 입력하세요\"\n\n# 텍스트 생성 및 임베딩\ngenerated_text = generate_text(hf_client, mistral_model, user_prompt)\nembedded_vector = embed_text(hf_client, embedding_model, generated_text)\n\n# Qdrant에서 관련 데이터 검색\nretrieved_data = retrieve_from_qdrant(qdrant_client, 'your-collection-name', embedded_vector, 5)\n\n# 응답 구성\nfinal_response = \"생성된 텍스트: #{generated_text}\\n\\n관련 정보:\\n#{retrieved_data}\"\nputs final_response\n```\n\n## RAG 모델 결과\n\nLangChain, Mistral 7B, Qdrant 및 Ruby를 통합하여 Retriever-Augmented Generation (RAG) 모델을 구축한 결과, 성능 평가를 통해 놀라운 결과를 확인할 수 있었습니다. 이 섹션은 핵심 성능 메트릭 및 질적 분석을 강조하며, 또한 RAG 모델의 실제 출력을 포함하여 해당 능력을 시연합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 성능 지표\n\n정확성: 모델은 맥락적으로 관련성이 높고 일관된 텍스트를 생성하는 데 높은 정확도를 보였습니다. Qdrant의 통합은 언어 모델의 맥락 인식을 효과적으로 증가시켜 더 정확하고 적합한 응답을 이끌어 냈습니다.\n\n속도: GPU 가속을 활용하여 모델은 신속하게 응답하여 실시간 응용 프로그램에 중요한 역할을 합니다. Qdrant로부터 벡터의 신속한 검색과 Mistral 7B에 의한 효율적인 텍스트 생성이 이 속도에 기여했습니다.\n\n확장성: 모델은 데이터 양이 증가함에 따라 성능 효율을 유지하며 원활하게 확장되었습니다. Qdrant의 고차원 벡터 데이터를 견고하게 처리하는 것이 여기서 중요한 역할을 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 질적 분석 및 모델 출력\n\n생성된 텍스트는 구문적으로 맞고 의미론적으로 풍부하여 맥락을 깊이 이해한다는 것을 시사합니다. 예를 들어:\n\n```js\n입력 프롬프트: \"인공지능의 최신 트렌드는 무엇인가요?\"\n\n생성된 텍스트: 인공지능의 최신 트렌드에는 자연어 처리의 발전, 윤리적 AI에 대한 관심 증가, 그리고 더 효율적인 기계 학습 알고리즘의 개발이 포함됩니다.\n관련 정보:\n현대 개발에서의 AI 윤리\n기계 학습의 효율성: 2024년의 전망\n자연어 처리: 언어 장벽 극복\n```\n\n이 출력물은 모델이 제공된 프롬프트와 잘 일치하면서도 정보를 제공하고 응집된 콘텐츠를 생성할 수 있는 능력을 잘 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용자 피드백\n\n사용자들은 이 모델이 미묘하고 문맥을 이해하는 응답을 생성하는 데 효과적이라고 언급했습니다. 또한 루비 환경 내에서의 원활한 통합이 잘 받아들여졌으며, 해당 모델의 실용성과 사용 편의성을 강조했습니다.\n\n## 비교 분석\n\n전통적인 루비 기반 NLP 모델과 비교할 때, 저희 RAG 모델은 문맥 이해와 응답 생성 측면에서 우수한 성능을 보여주었으며, Mistral 7B와 Qdrant와 같이 고급 AI 구성 요소를 통합하는 이점을 강조했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용 사례\n\n모델은 다양한 분야에서 실용적인 응용 프로그램을 찾아 챗봇 상호 작용, 자동화된 콘텐츠 생성 및 정교한 텍스트 분석과 같은 작업을 개선했습니다.\n\n# 결론\n\n우리가 마침내 도달한 결론은 루비의 영역을 탐험하는 과정은 LangChain, Mistral 7B 및 Qdrant와 같은 최첨단 기술로 보강된 것으로 나타났지만 그것은 과거에만 한하는 것이 아니라 또한 교육적이었습니다. 루비 환경에서 Retriever-Augmented Generation 모델의 성공적인 생성 및 배포는 언어의 응용 분야의 전통적인 경계에 도전했습니다. 이 프로젝트는 루비를 주로 웹 개발에 적합한 언어로 간주하던 것을 뒤엎으며 고급 인공 지능 및 기계 학습 분야에서 미개척된 잠재력을 품고 있다는 것을 명확하게 입증했습니다. 이 프로젝트의 성과인 루비의 복잡한 AI 작업과의 호환성을 강조하고, 세련된 도구들과 신속한 통합 능력, 그리고 RAG 모델의 놀라운 성능을 모두 루비의 능력의 범위를 확대하는 중요한 이정표로 인식하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전망을 바라볼 때, 이 성공적인 통합의 함의는 깊이 있습니다. 이는 루비 개발자들에게 새로운 가능성들을 열어주며, 그들이 자신감을 가지고 AI 분야로 진출하도록 격려합니다. RAG 모델은 루비의 다재다능함과 강력함을 보여주며 복잡하고 컨텍스트에 민감하며 계산적으로 요구되는 작업을 다룹니다. 이 노력은 다양한 영역에서 혁신적인 응용 프로그램을 위한 길을 열 뿐만 아니라 루비 기반의 AI 솔루션을 더 깊게 탐구하고 발전시키는 선례로 남깁니다. AI 및 기계 학습 분야가 계속 발전함에 따라, 루비의 역할은 약속만큼 중요하며 AI 및 기계 학습 기술의 발전된 능력과 함께 루비의 우아함과 효율성이 손에 잡힌다는 미래가 약속됩니다.\n","ogImage":{"url":"/assets/img/2024-05-27-Step-by-StepGuidetoBuildingLLMApplicationswithRubyUsingLangchainandQdrant_0.png"},"coverImage":"/assets/img/2024-05-27-Step-by-StepGuidetoBuildingLLMApplicationswithRubyUsingLangchainandQdrant_0.png","tag":["Tech"],"readingTime":18},{"title":"네, 제가 느낀 좌절을 제품으로 만들었어요","description":"","date":"2024-05-27 16:03","slug":"2024-05-27-YesITurnedmyFrustrationintoaProduct","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-YesITurnedmyFrustrationintoaProduct_0.png\" /\u003e\n\n10년 전, 주니어 개발자에서 중급 개발자로의 전환이 진행되던 중, Ruby와 Rails와의 여정은 전혀 순탄하지 않았어요.\n\n나는 자습서, 책, 문서의 바다에서 자주 길을 잃고, 이해하기 어려워 보이는 개념을 이해하려고 애썼었어요.\n\n특정 주제를 이해하려는 데 몇 시간을 보냈지만, 그것이 제일 필요한 때 몇 주 후에는 까먹게 되곤 했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 투쟁\n\n처음에는 앞으로 한 걸음씩 나아갈 때마다 엄청난 성취감을 느꼈습니다.\n\n루비 구문을 배우고, 레일스 관례를 이해하고, 액티브 레코드에 익숙해지는 모든 과정이 어려웠습니다.\n\n저는 코드를 디버깅하는 데 끝없는 시간을 보내며, 한 번 발목이 잡히면 저에게 점점 눈에 띄는 저항을 느꼈습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n온라인 포럼과 커뮤니티 도움은 귀중했지만, 내 학습 과정에서 아직 빠진 게 뭔지를 느꼈다.\n\n# 깨달음\n\n전환점은 이미 만났던 개념들을 다시 공부하는 데 너무 많은 시간을 낭비하고 있다는 것을 깨달았을 때 찾아왔다.\n\n문제에 부딪힐 때마다, 이미 정복했다고 생각했던 주제를 다시 보는 나 자신을 발견했다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 과정은 시간이 많이 걸리기만 하지 않고 매우 동기부여가 떨어지게 만들었어요.\n\n내가 이미 알고 있는 것에 집착하지 않고 약점을 식별하고 집중할 방법이 필요했어요.\n\n# 루비퀴즈의 탄생\n\n이러한 좌절에서 루비퀴즈.dev가 탄생되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n10년 만에 내 상황에 있는 다른 개발자들을 돕는 개념을 드디어 찾았어요.\n\nTwitter와 Linkedin에서 퀴즈 질문을 공유한 지 여러 년이 지난 후, 갑자기 깨달았어요! 💡\n\n내 지식을 테스트하는 도구를 상상했어요. 뿐만 아니라 내 실수를 이해하고 학습 중의 빈틈을 채우는 데 도움을 줄 수 있는 도구를요.\n\n상호작용적이고 매력적이며, 가장 중요한 것은 효율적인 것을 원했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루비퀴즈는 아래와 같은 목적으로 설계되었습니다:\n\n- 무작위 퀴즈 생성하기\n\n학습 프로세스를 동적이고 도전적으로 유지하여 매 퀴즈마다 새로운 내용을 제공합니다.\n\n- 퀴즈 결과 및 정답 상세 정보에 접근하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n귀하의 진행 상황을 명확하게 파악하고 개선이 필요한 부분을 강조하기 위해 제공됩니다.\n\n- 각 오답에 대한 자세한 설명\n\n그래서 당신은 실수의 이유를 배우고, 그것을 소중한 학습 기회로 바꿀 수 있습니다.\n\n# RubyQuiz.dev\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n30일 동안 도구를 설계한 후에 드디어 만족스러운 V1을 만들어 냈습니다.\n\n이 플랫폼은 학습 도구를 넘어서 제 여정의 산물로, 다른 사람들이 저와 마주한 같은 함정을 피하도록 만든 것입니다.\n\n특정한 공백에 집중하여 시간을 절약하고 항상 학습 여정에서 전진할 수 있도록 도와주는 디자인입니다.\n\n정말로 RubyQuiz.dev를 통해 Ruby 및 Rails 학습 커브에서 효율적으로 지식 공백을 채우고 시간을 아낄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운 형식으로 table 태그를 변경해 드릴게요.","ogImage":{"url":"/assets/img/2024-05-27-YesITurnedmyFrustrationintoaProduct_0.png"},"coverImage":"/assets/img/2024-05-27-YesITurnedmyFrustrationintoaProduct_0.png","tag":["Tech"],"readingTime":2},{"title":"자바의 29번째 생일을 축하합니다","description":"","date":"2024-05-27 16:01","slug":"2024-05-27-Happy29thBirthdayJava","content":"\n\n![Happy 29th Birthday Java](/assets/img/2024-05-27-Happy29thBirthdayJava_0.png)\n\n1991년, 제임스 고슬링, 마이크 셰리던, 패트릭 나이튼은 썬 마이크로시스템즈에서 그린 프로젝트를 시작했습니다. 디지털 장치용 언어를 개발하기 위해 세트톱 박스와 텔레비전을 대상으로했습니다. 팀은 처음에 고슬링 사무실 바깥의 참나무에 명칭이 붙은 'Oak'이라는 언어에 대해 작업했습니다. 그러나 이후 인도네시아의 커피 종류를 따라 이름이 Java로 변경되었습니다. 이는 팀이 커피를 사랑하기 때문입니다.\n\n# 타임라인\n\n![Timeline](/assets/img/2024-05-27-Happy29thBirthdayJava_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Happy 29th Birthday Java Image](/assets/img/2024-05-27-Happy29thBirthdayJava_2.png)\n\n# Java이란 무엇이며, 어디에 사용되나요?\n\n전 세계의 기업들은 고객에 제공하는 응용 프로그램과 웹사이트를 개발하기 위해 Java를 활용합니다.\n\n자주 사용되는 용도로는\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모바일 애플리케이션 개발 및 배포\n- 클라우드 기반 애플리케이션 확장 및 관리\n- 챗봇 및 추가 마케팅 유틸리티 제작\n- 기업을 위한 고성능 웹 애플리케이션 구축\n- 인공 지능 (AI) 및 사물 인터넷 (IoT) 장치 지원 활성화\n\n# 자바의 장점\n\n- 플랫폼 독립성: Java 프로그램은 Java 가상 머신 (JVM)이 있는 장치에서 실행될 수 있어 플랫폼에 독립적입니다.\n- 객체지향 (OOP): Java는 캡슐화, 상속 및 다형성을 포함한 객체지향 프로그래밍 원칙에 기반합니다.\n\n```java\nclass Car {\n    // 인스턴스 변수\n    String brand;\n    String model;\n    int year;\n\n    // 생성자\n    public Car(String brand, String model, int year) {\n        this.brand = brand;\n        this.model = model;\n        this.year = year;\n    }\n\n    // 데모 목적으로 차량 정보 표시하는 메서드\n    public void displayInfo() {\n        System.out.println(\"브랜드: \" + brand);\n        System.out.println(\"모델: \" + model);\n        System.out.println(\"연도: \" + year);\n    }\n}\n\n// Car 클래스를 보여주기 위한 주 클래스\npublic class Main {\n    public static void main(String[] args) {\n        // 'myCar'라는 Car 클래스의 인스턴스 생성\n        Car myCar = new Car(\"Toyota\", \"Camry\", 2020);\n\n        // 차량 정보를 출력하기 위해 displayInfo() 메서드 호출\n        myCar.displayInfo();\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 간단하고 익숙한 구문: 자바 구문은 C 및 C++과 유사하여 개발자가 배우고 사용하기 쉽습니다.\n- 자동 메모리 관리: 자바에는 내장된 가비지 수집기가 있어 메모리를 자동으로 할당 해제하여 메모리 누수의 위험을 줄입니다. 이전에 보았던 것처럼, 자바 12, 13, 및 14 버전은 가비지 수집기를 개선하는 데 초점을 맞췄습니다.\n- 보안: 자바의 강력한 보안 기능에는 바이트코드 확인기와 보안 관리자가 포함되어 있어 무단 접근과 악성 코드로부터 보호합니다.\n- 멀티스레딩: 자바는 내장된 멀티스레딩 지원으로 동시성 프로그래밍을 지원하며, 개발자가 빠르게 반응하고 확장 가능한 애플리케이션을 만들 수 있게 합니다.\n\n```java\npublic class MultithreadingExample extends Thread {\n\n    @Override\n    public void run() {\n        // 쓰레드가 실행할 작업\n        for (int i = 1; i \u003c= 5; i++) {\n            System.out.println(\"Thread: \" + Thread.currentThread().getId() + \" - Count: \" + i);\n            try {\n                // 처리를 시뮬레이션하기 위해 짧은 지연을 도입\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                System.out.println(e);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // 다중 쓰레드 생성\n        MultithreadingExample thread1 = new MultithreadingExample();\n        MultithreadingExample thread2 = new MultithreadingExample();\n\n        // 쓰레드 시작\n        thread1.start();\n        thread2.start();\n    }\n}\n```\n\n자바의 멀티스레딩은 작업을 동시에 실행하는 데 사용됩니다. 이를 통해 자바 프로그램은 여러 작업을 동시에 수행하여 사용 가능한 시스템 자원을 효율적으로 활용하여 성능을 향상시킵니다. 이는 또한 자바 애플리케이션에서 반응이 빠른 사용자 인터페이스(UI)를 개발하는 데 필수적입니다.\n\n- 풍부한 표준 라이브러리: 자바에는 네트워킹, I/O 및 데이터 조작과 같은 일상적인 작업을 위한 사전 구축된 클래스와 메서드를 제공하는 포괄적인 표준 라이브러리(Java API)가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 커뮤니티 지원: Java는 크고 활발한 개발자 커뮤니티를 갖고 있어 소프트웨어 개발을 지원하기 위한 자료, 라이브러리 및 프레임워크를 제공합니다.\n\n# Java로 개발된 프레임워크\n\n![이미지](/assets/img/2024-05-27-Happy29thBirthdayJava_3.png)\n\n## 스프링 프레임워크\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스프링 생태계는 제가 가장 좋아하는 생태계입니다. 기업용 자바 애플리케이션을 구축하기위한 다재다능하고 강력한 프레임워크입니다. 의존성 주입, 관점 지향 프로그래밍, 모듈식 개발에 대한 포괄적인 지원을 제공하여 복잡한 애플리케이션의 개발 및 유지보수를 더 쉽게 만듭니다. 다양한 모듈과 라이브러리로 이루어진 넓은 생태계로 인해 스프링은 데이터베이스 액세스, 트랜잭션 관리, 웹 개발과 같은 일상적인 작업을 단순화합니다. 게다가, 스프링의 가벼우면서도 비침투적인 아키텍처는 모범 사례를 촉진하고 개발자가 쉽게 확장 가능하고 견고한 애플리케이션을 만들 수 있도록 돕습니다.\n\n## Play Framework\n\nPlay Framework는 최신형 가벼운 웹 프레임워크로, 개발자가 Java와 Scala로 확장 가능하고 반응성 있는 웹 애플리케이션을 구축할 수 있도록 돕습니다. 개발자 생산성을 강조하여 깨끗하고 직관적인 API, 신속한 개발을 위한 핫 리로딩 및 비동기 프로그래밍을 위한 내장 지원을 제공합니다.\n\n## Vaadin Framework\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프레임워크는 Java를 사용하여 풍부하고 상호 작용적인 사용자 인터페이스의 개발을 간편화하기 위해 설계된 견고하고 기능이 풍부한 웹 응용 프로그램 프레임워크입니다. 개발자들이 최신 웹 응용 프로그램을 쉽게 만들 수 있도록 해주며, 서버 측 Java 코드를 활용하여 동적이고 반응적인 UI 구성 요소를 생성할 수 있습니다.\n\n## Dropwizard 프레임워크\n\nDropwizard는 Java에서 RESTful 웹 서비스를 구축하기 위한 강력하고 가볍고 프레임워크입니다. Jetty를 사용하여 HTTP 서비스, RESTful 웹 서비스를 위한 Jersey, JSON 직렬화를 위한 Jackson, 모니터링 및 메트릭 수집을 위한 Metrics를 포함한 다양한 라이브러리 및 구성 요소를 번들로 제공하여 고성능 및 확장 가능한 웹 응용 프로그램의 개발을 간편화합니다.\n\n# Java를 사용하는 회사들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스포티파이, 우버, 아마존, 넷플릭스, 핀터레스트, 구글, 마이크로소프트 등이 있습니다.\n\n# 2024년에 자바를 배워야 할까요?\n\n자바는 최신 언어와 기술이 등장하더라도 소프트웨어 개발 산업의 중요한 요충지로 남아있으며 여전히 요구되고 있습니다. 산업용 응용프로그램을 구축하는 데 선호되는 도구인 자바는 성숙한 툴링과 크로스 플랫폼 호환성을 통해 특히 금융, 의료 및 전자 상거래 분야에서 기업용 애플리케이션을 만드는 데 선택되고 있습니다.\n\n자바의 광범위한 채택은 대기업과 기업에서 임무 중심 시스템 및 기반구조를 구축하는 중요성을 강조합니다. 백엔드 서비스, 기업 애플리케이션부터 모바일 개발 및 클라우드 네이티브 솔루션까지 다양한 영역에서 자바가 사용되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지속적인 수요로 인해 숙련된 Java 개발자에 대한 수요가 계속되고 있으며, Java 기반 응용 프로그램을 효과적으로 디자인, 개발 및 유지할 수 있는 전문가들이 필요합니다.\n\n# Java 개발자 연봉\n\n미국의 평균 Java 개발자 연봉은 연간 $117,024 또는 시간당 $56.26입니다. — 출처\n\n헝가리의 중간 Java 개발자 연봉은 월 650,000 HUF (순수익) (연간 순수익 21,000 USD)입니다. — 출처\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가까운 미래에는 Java 개발자들이 굶주릴 일은 없겠지만, 헝가리에서는 중간 임금이 여전히 일반적인 수준 하회합니다. 결과적으로 개발자들은 이런 현실에서 벗어나기 위해 원치 않는 낮은 월급을 피하기 위해 원격으로 일할 수도 있습니다.\n\n# 요약하자면\n\nJava는 수십 년 동안 존재해왔으며, 가장 인기 있는 프로그래밍 언어 중 하나로 남을 것입니다. 그만큼 그의 탄탄함과 신뢰성에 대한 이야기가 많습니다. 그 역사는 놀랍고, 입문자가 지식을 습득하기에는 학습 곡선이 꽤 균형이 잡힌 것 같습니다. 저는 확실히 이 프로그래밍 언어가 영원히 제 최애 언어가 될 것이라고 확신합니다. :)\n\n오늘은 여기까지! 코드를 작성해 봅시다! ❤\n","ogImage":{"url":"/assets/img/2024-05-27-Happy29thBirthdayJava_0.png"},"coverImage":"/assets/img/2024-05-27-Happy29thBirthdayJava_0.png","tag":["Tech"],"readingTime":6},{"title":"자바에서의 락lock - 파트 63  스탬프락 메서드, 읽기 뷰 및 쓰기 뷰 ","description":"","date":"2024-05-27 16:00","slug":"2024-05-27-LocksInJavaPart63StampedLockMethodsReadViewandWriteView","content":"\n\n본 기사에서는 자바의 stamped lock 메서드에 대해 알아보고 이를 통해 제공되는 view 개념을 살펴볼 것입니다.\n\n출발해 봅시다!!\n\n![image](/assets/img/2024-05-27-LocksInJavaPart63StampedLockMethodsReadViewandWriteView_0.png)\n\n이 메서드들은 상태 값을 확인하여 true 또는 false를 결정하기 위해 일부 검사를 계속 수행하기 때로 이해하기가 상당히 간단합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽기 뷰:\n\n이것은 락 인터페이스를 구현하는 내부 클래스이며 Stamped 락에 있는 메서드들을 감싸는 래퍼 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메소드가 있습니다.\n\n- lock() - 내부적으로 readLock() 메소드를 호출합니다.\n- lockInterruptibly() - 내부적으로 readLockInterruptiblyMethod()을 호출합니다.\n- tryLock() - tryReadLock() 메소드 출력값이 0이 아닌지 확인합니다.\n- tryLock () - 시간 제한이 있는 잠금으로 내부적으로 tryReadLock 시간 제한이 있는 잠금이 0이 아닌지 확인합니다.\n- unlock() - unstampedUnlockRead() 메소드를 호출합니다. [stamped 메소드는 view 클래스용으로 만들어지며, view 클래스 잠금 메소드에서는 스탬프가 필요하지 않습니다.]\n- newCondition () - 예외를 throw합니다.\n\n[위의 6개 메소드에 대해 자세히 알아보려면 lock 인터페이스를 확인해 주세요.]\n\nasReadLock()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 stamped lock의 Read Lock 뷰를 생성합니다.\n\n비슷하게, 우리는 Lock 인터페이스를 다시 구현하고 내부적으로 해당 쓰기 잠금 메서드를 호출하는 writeLock 뷰를 가지고 있습니다.\n\n이 두 뷰는 우리에게 Lock 인터페이스 아래에서 stamped lock을 사용하는 데 도움이 됩니다.\n\nasReadLock () 및 asWriteLock () 메서드를 사용하고 ReadWriteLock 인터페이스를 구현하는 ReadWriteView도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 자바 락 시리즈를 완료했습니다. 자바의 대부분의 락을 다루려고 노력했습니다.\n\n여기 완전한 시리즈 목록입니다:\n\n- Lock Interface : [링크](https://medium.com/@avinashsoni9829/locks-in-java-part-1-lock-interface-38222d6048d3)\n- Read Write Lock : [링크](https://medium.com/@avinashsoni9829/locks-in-java-part-2-read-write-locks-0a2a7c803b44)\n- Lock Support : [링크](https://medium.com/@avinashsoni9829/locks-in-java-part-3-locksupport-607d8766ed1a)\n- Abstract Ownable Synchronizers : [링크](https://medium.com/@avinashsoni9829/locks-in-java-part-4-abstract-ownable-synchronizers-1e4033f66d17)\n- Reentrant Lock part — 1: [링크](https://medium.com/@avinashsoni9829/locks-in-java-part-5-1-reentrant-locks-in-java-sync-class-bf11e8765507)\n- Reentrant Lock part — 2 : [링크](https://medium.com/@avinashsoni9829/locks-in-java-part-5-2-reentrant-locks-051e31e19a48)\n- Stamped Lock Part 1 : [링크](https://medium.com/@avinashsoni9829/locks-in-java-part-6-1-stamped-lock-optimistic-reads-and-pessimistic-reads-8cb8f9858674)\n- Stamped Lock Part 2 : [링크](https://medium.com/@avinashsoni9829/locks-in-java-part-6-2-stamped-lock-conversions-b2ec88e78ad1)\n- Stamped Lock Part 3 and Series End : [링크](https://medium.com/@avinashsoni9829/locks-in-java-part-6-3-stamped-lock-methods-read-view-and-write-view-333579a644f4)\n\n코드 : [GitHub 링크](https://github.com/avinashsoni9829/Threading/tree/main/locks)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 읽어주셔서 감사합니다! 피드백을 공유해 주시면 감사하겠습니다.","ogImage":{"url":"/assets/img/2024-05-27-LocksInJavaPart63StampedLockMethodsReadViewandWriteView_0.png"},"coverImage":"/assets/img/2024-05-27-LocksInJavaPart63StampedLockMethodsReadViewandWriteView_0.png","tag":["Tech"],"readingTime":3},{"title":"2024년을 위한 자바 개발자를 위한 상위 60개의 스프링 프레임워크 인터뷰 질문책에 있는 모든 질문 포함","description":"","date":"2024-05-27 15:53","slug":"2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook","content":"\n## 안녕하세요! Java 개발자라면, 백엔드 개발에 필수적인 스프링 프레임워크를 정복하는 것이 중요합니다. 스프링 부트 프로젝트의 기초 역할을 하는데, 스프링 프레임워크는 깊게 파고들 필수 기술입니다. 이 기사에는 스프링 프레임워크 인터뷰 질문이 모두 포함되어 있습니다. 이를 통해 인터뷰에 성공할 수 있을 것입니다. 함께 더 알아보세요!\n\n![이미지](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_0.png)\n\n스프링 부트로의 진입 전에 스프링 프레임워크를 배우는 것은 집을 짓기 전에 견고한 기초를 쌓는 것과 같습니다. 스프링 프레임워크는 자바 개발에서 중요한 개념과 작동방식을 가르쳐주며 의존성 처리와 코드 구성 등을 다룹니다.\n\n이 지식을 통해 더 효율적이고 빠른 스프링의 버전인 스프링 부트가 왜 이런 방식으로 작업을 하는지 이해할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해 보겠습니다.\n\n\nIt’s like learning the basics before using a time-saving tool that’s built on those basics. So, by mastering Spring first, you’ll have a better grip on Spring Boot and make smarter choices when creating modern applications.\n\nLet’s dive into the Spring framework interview questions,\n\n# What is Spring Framework?\n\nThe Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications — on any kind of deployment platform.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring의 중요 요소 중 하나는 애플리케이션 수준에서의 인프라 지원입니다. Spring은 기업 애플리케이션의 \"배관 시스템\"에 집중하여 팀이 애플리케이션 수준의 비즈니스 로직에 집중할 수 있도록 하며, 특정 배포 환경에 불필요한 결합을 만들지 않습니다.\n\n# 제어 반전이란 무엇인가요?\n\n전통적인 프로그래밍에서는 애플리케이션이 필요로 하는 모든 객체를 수동으로 생성하고 관리해야 합니다. 이런 방식은 복잡하고 오류가 발생하기 쉬울 수 있습니다.\n\n다음은 IOC가 어떻게 보이는지 보여주는 다이어그램입니다,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_1.png\" /\u003e\n\n스프링 프레임워크의 IoC 컨테이너는 객체를 생성하고 관리하는 책임을 가져오면서 이 프로세스를 간소화합니다. 단순히 Spring에 필요한 객체를 알려주면 Spring이 해당 객체를 만들어주고 코드에 제공해줍니다. 이를 의존성 주입이라고 합니다.\n\n의존성 주입은 코드를 더 모듈식으로 만들어 유지보수를 더 쉽게 합니다. 또한 객체를 올바르게 생성하는 걱정을 덜어주어 오류의 위험을 줄입니다.\n\nIoC는 의존성 주입(DI)로도 알려져 있습니다. 객체가 생성자 인수, 팩토리 메소드에 대한 인수 또는 생성 또는 팩토리 메소드에서 반환된 후 객체 인스턴스에 설정된 속성을 통해 단지 그 종속성(즉, 작동하는 다른 객체)을 정의하는 프로세스입니다. 컨테이너는 빈을 생성할 때 이러한 종속성을 주입합니다. 이 프로세스는 기본적으로 빈 자체가 직접 클래스를 사용하여 종속성을 제어하거나 위치를 찾는 것의 역(따라서 제어의 역전)입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스프링 IOC 컨테이너란 무엇인가요?\n\norg. spring framework.context.ApplicationContext 인터페이스는 스프링 IoC 컨테이너를 나타내며 빈을 인스턴스화, 구성 및 조립하는 역할을 합니다.\n\n![image](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_2.png)\n\n컨테이너는 구성 메타데이터를 읽어서 인스턴스화, 구성 및 조립할 객체에 대한 지침을 얻습니다. 구성 메타데이터는 XML, Java 주석 또는 Java 코드로 표현됩니다. 이를 통해 응용 프로그램을 구성하는 객체와 해당 객체 간의 풍부한 상호 종속성을 표현할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스프링에서 구성을 정의하는 방법은 몇 가지가 있을까요?\n\n두 가지 방법이 있습니다:\n\n1. XML 기반 구성 : 빈 정의를 여러 XML 파일에 걸쳐 설정하는 것이 유용할 수 있습니다. 각 개별 XML 구성 파일은 종종 아키텍처에서 논리적인 레이어나 모듈을 나타냅니다.\n\n2. Java 기반 구성: XML 파일 대신 Java를 사용하여 애플리케이션 클래스 외부에 빈을 정의할 수 있습니다. 이러한 기능을 사용하려면 @Configuration, @Bean, @Import, @DependsOn 어노테이션을 참조하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 의존성 주입이란?\n\n의존성 주입(Dependency injection, DI)은 객체가 생성될 때 생성자 인수, 팩토리 메서드의 인수 또는 생성 또는 팩토리 메서드에서 반환된 후 객체 인스턴스에 설정된 속성을 통해 다른 객체인 의존성을 정의하는 프로세스입니다. 컨테이너는 그러한 의존성을 빈을 생성할 때 주입합니다. 이 프로세스는 빈이 자체적으로 직접 클래스의 생성 또는 의존성의 위치를 제어하지 않고, 클래스의 직접 생성 또는 Service Locator 패턴을 사용하여 의존성을 제어하는 것의 역전(즉, 제어의 역전)입니다.\n\n![이미지](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_3.png)\n\nDI 원칙에 따라 코드가 더 깔끔해지고, 객체가 의존성이 주어질 때 결합이 더 효과적해집니다. 객체는 자체 의존성을 찾지 않으며 의존성의 위치나 클래스를 알지 못합니다. 결과적으로 클래스는 인터페이스나 추상 기본 클래스에 대한 의존성이 있을 때 특히 의존성이 단위 테스트에서 사용될 수 있도록 스텁 또는 모의 구현을 허용하는 경우 테스트하기 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDI는 주로 생성자 기반 의존성 주입과 Setter 기반 의존성 주입 두 가지 주요 변형이 있습니다. 일반적으로 다이어그램은 다음과 같이 보입니다.\n\n## 제어의 역전과 의존성 주입의 차이는 무엇인가요?\n\n![다이어그램](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_4.png)\n\n## 의존성 주입의 유형과 그것을 사용함으로써 얻는 이점은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존성 주입(DI)은 객체가 자신의 종속성을 생성하는 대신 종속성을 제공받을 수 있는 디자인 패턴입니다. 여러 종류의 의존성 주입이 있으며, 각각의 장단점이 있습니다:\n\n생성자 주입: 이 종류의 주입에서는 종속성이 클래스의 생성자로 전달됩니다. 이렇게 하면 클래스가 항상 필요한 종속성을 보유하게 되며 클래스 불변성을 강제하는 데 유용할 수 있습니다.\n\n다음 예시는 생성자 주입으로만 의존성을 주입할 수 있는 클래스를 보여줍니다:\n\n```js\npublic class SimpleMovieLister {\n// SimpleMovieLister는 MovieFinder에 종속성이 있습니다.\nprivate final MovieFinder movieFinder;\n// Spring 컨테이너가 MovieFinder를 주입할 수 있도록하는 생성자\npublic SimpleMovieLister(MovieFinder movieFinder) {\nthis.movieFinder = movieFinder;\n}\n// 주입된 MovieFinder를 실제로 사용하는 비즈니스 로직은 생략되었습니다...\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSetter 주입: 이 유형의 주입에서는 종속성이 클래스가 인스턴스화된 후에 setter 메서드로 전달됩니다. 이를 통해 종속성을 실행 중에 변경할 수 있어서 클래스를 다른 문맥에서 재사용할 수 있습니다.\n\n```java\npublic class SimpleMovieLister {\n    // SimpleMovieLister는 MovieFinder에 종속성이 있습니다\n    private MovieFinder movieFinder;\n\n    // Spring 컨테이너가 MovieFinder를 주입할 수 있도록 setter 메서드\n    public void setMovieFinder(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n\n    // 주입 된 MovieFinder를 실제로 사용하는 비즈니스 로직은 생략되었습니다\n}\n```\n\n# 생성자 기반 또는 setter 기반 DI 중 어떤 것이 더 나은가요?\n\n생성자 기반 및 setter 기반 DI를 혼합하여 사용할 수 있기 때문에 필수적인 종속성에는 생성자를 사용하고 선택적 종속성에는 setter 메서드나 구성 메서드를 사용하는 것이 좋은 지침입니다. @Autowired 주석을 setter 메서드에 사용하여 속성을 필수 종속성으로 만들 수 있지만, 프로그래밍 방식으로 인수의 유효성을 검사하는 생성자 주입이 선호됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스프링 팀은 일반적으로 생성자 주입을 옹호합니다. 왜냐하면 이렇게 하면 애플리케이션 구성 요소를 변경 불가능한 객체로 구현할 수 있고 필수 종속성이 null이 되지 않도록 할 수 있기 때문입니다. 더불어 생성자 주입된 구성 요소는 항상 클라이언트(호출) 코드에 완전히 초기화된 상태로 반환됩니다.\n\n# 메서드 주입이란 무엇인가요?\n\n메서드 주입은 스프링 및 다른 프레임워크에서 일반적으로 사용되는 설계 패턴으로, 객체에 종속성을 주입하는 데 사용됩니다. 필드 주입이나 생성자 주입과 달리 메서드 주입은 특정 메서드 인수에 종속성을 주입합니다.\n\n# 컨테이너 내부에서 제어의 역전이 어떻게 작동하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제어의 역전(IoC)은 응용 프로그램 코드에서 외부 컨테이너로 제어가 전달되는 디자인 패턴입니다. Java 응용 프로그램의 경우, 해당 컨테이너는 보통 IoC 컨테이너 또는 의존성 주입(DI) 컨테이너로 불립니다.\n\nIoC 컨테이너는 객체의 생성과 관리를 담당하며, 이를 위해 객체가 어떻게 생성되고 서로 연결되는지를 정의하는 일련의 구성 규칙에 의존합니다.\n\n다음은 IoC가 IoC 컨테이너 내에서 동작하는 방법입니다:\n\n구성: IoC 컨테이너를 사용하려면, 객체가 어떻게 생성되고 연결되어야 하는지를 정의하는 일련의 규칙으로 구성해야 합니다. 이 구성은 일반적으로 XML 또는 Java 어노테이션을 사용하여 수행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n객체 생성: 애플리케이션이 컨테이너로부터 객체를 요청하면, 컨테이너는 구성 규칙을 사용하여 요청된 객체의 새 인스턴스를 만듭니다.\n\n의존성 주입: 컨테이너는 새로 생성된 객체에 필요한 모든 의존성을 주입합니다. 이러한 의존성은 일반적으로 구성 규칙에서 정의됩니다.\n\n객체 수명주기 관리: 컨테이너는 생성한 객체의 수명주기를 관리합니다. 이는 애플리케이션이 필요에 따라 객체를 생성, 초기화 및 소멸하는 책임을 가지는 것을 의미합니다.\n\n제어의 역전: 컨테이너를 통해 객체를 생성하고 관리하도록 의존하는 것으로, 애플리케이션 코드는 더 이상 객체 생성 프로세스를 직접 제어하지 않습니다. 대신, 컨테이너가 이 책임을 맡고, 애플리케이션 코드는 단순히 컨테이너로부터 필요한 객체를 요청합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 다양한 스프링 모듈은 무엇인가요?\n\n스프링 프레임워크는 여러 모듈로 구성된 포괄적인 자바 프레임워크로, 각각 특정한 기능과 기능을 제공합니다. 이러한 모듈은 주요 목적에 따라 카테고리로 구성되어 있습니다. 다음은 주요 스프링 모듈 및 각각의 역할에 대한 개요입니다:\n\n![Spring Modules](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_5.png)\n\n핵심 컨테이너(Core Container): 핵심 컨테이너 모듈은 스프링 프레임워크의 기초를 형성하며, 의존성 주입, 빈 라이프사이클 관리 및 리소스 관리와 같은 필수 서비스를 제공합니다. 애플리케이션 전체에서 객체를 생성, 구성 및 관리하는 역할을 수행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 접근/통합: 데이터 접근/통합 모듈은 관계형 데이터베이스, 객체-관계 매핑 (ORM) 프레임워크, 메시징 시스템 등 다양한 데이터 원본과의 데이터 접근 및 통합을 간소화하는 데 중점을 둡니다. JDBC 추상화, ORM 통합, 메시지 지향 미들웨어 (MOM) 지원과 같은 기능을 제공합니다.\n\n웹 (MVC/Remoting): 웹 모듈은 Model-View-Controller (MVC) 패턴을 사용하여 웹 애플리케이션을 구축하고 분산 애플리케이션을 위한 리모팅 기능을 제공합니다. Servlet, Portlet, Struts와 같은 다양한 웹 기술을 지원합니다.\n\nAOP (Aspect-Oriented Programming): AOP 모듈은 로깅, 보안, 트랜잭션 관리와 같은 관점이 교차되는 관심사를 모듈화하는 기술인 관점 지향 프로그래밍을 가능하게 합니다. 관점 선언, 관점(Aspect) 조합, 관점 실행과 같은 기능을 제공합니다.\n\n계측 (Instrumentation): 계측 모듈은 Spring 애플리케이션을 모니터링하고 성능을 관리하는 데 도움을 줍니다. 빈 생명주기 추적, 메모리 프로파일링, 성능 메트릭 수집과 같은 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테스트: 테스트 모듈은 Spring 애플리케이션의 테스트를 위한 도구와 프레임워크를 제공하며, 단위 테스트, 통합 테스트 및 웹 애플리케이션 테스트에서 의존성 주입을 지원합니다.\n\n# 스프링 MVC, 스프링 AOP 및 스프링 Core 모듈이 무엇인가요?\n\n이 질문을 하는 이유는 이 세 가지 모듈이 스프링 기반 애플리케이션을 개발하는 데 매우 중요하기 때문입니다.\n\n스프링 MVC, 스프링 AOP 및 스프링 Core는 강력하고 확장 가능한 자바 애플리케이션을 구축하는 데 중요한 역할을 하는 스프링 프레임워크의 세 가지 불가결한 모듈입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스프링 MVC (Model-View-Controller)\n\n스프링 MVC는 Model-View-Controller (MVC) 아키텍처를 구현하는 웹 프레임워크로, 애플리케이션 논리, 사용자 인터페이스 표현 및 데이터 관리를 분리하는 인기 있는 패턴입니다. 웹 요청 처리를 계층적으로 다루어 유지보수 가능하고 테스트 가능한 웹 애플리케이션 개발을 용이하게 합니다.\n\n스프링 MVC의 주요 기능:\n\nDispatcher Servlet: 요청 처리 및 적절한 컨트롤러로의 디스패치를 중앙에서 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨트롤러 클래스: 사용자 요청을 처리하고 데이터를 처리하며 모델과 상호 작용하여 적절한 뷰를 선택합니다.\n\n뷰 기술: JSP, FreeMarker, Thymeleaf, Velocity와 같은 다양한 템플릿 엔진을 지원하여 동적 콘텐츠를 렌더링합니다.\n\nSpring AOP (Aspect-Oriented Programming)\n\nSpring AOP는 관점 지향 프로그래밍 (AOP)의 구현을 제공합니다. 이는 로깅, 보안, 트랜잭션 관리와 같은 교차 관심사를 모듈화하는 기술입니다. 개발자들은 이러한 관심사를 측면으로 캡슐화하고 응용 프로그램 실행 흐름 내에서 특정 지점에 적용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring AOP의 주요 기능은 다음과 같습니다:\n\n- Aspect 선언: 관점(Aspect)을 정의하여, 적용해야 하는 교차 관점 문제 및 적용해야 하는 지점(pointcuts)을 지정합니다.\n\n- Aspect 결합(weaving): Aspect를 애플리케이션의 실행 흐름에 통합하여, 특정 조인 포인트(join points)에서 Aspect의 동작을 적용합니다.\n\n- Aspect 실행: Aspect 조언(advice)의 호출을 처리하여, 조인 포인트에서 취해야 할 행동을 정의합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Spring Core의 주요 기능입니다:\n\n- 의존성 주입: 객체에 필요한 의존성을 자동으로 제공하여 코드 복잡성을 줄이고 모듈성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빈 라이프사이클 관리: Spring 애플리케이션 컨텍스트 내의 객체 생성, 초기화, 파괴 및 범위를 처리합니다.\n\n자원 관리: 데이터베이스 연결, 파일 및 메시징 큐와 같은 자원을 관리하여 자원 획득 및 해제를 간편하게 합니다.\n\n# @ComponentScan을 통한 컴포넌트 스캔 작동 방식은?\n\n주석 발견: Spring 프레임워크는 주석 기반 구성을 사용하여 Spring 빈을 식별합니다. 지정된 패키지 및 하위 패키지에서 @Component, @Service, @Repository, @Controller 또는 다른 스테레오타입 주석이 지정된 클래스를 검사하여 응용 프로그램에서 빈의 역할을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빈 생성 및 등록: Spring Framework는 어노테이션으로 지정된 클래스를 발견하면 해당 클래스의 인스턴스를 생성하고 애플리케이션 컨텍스트에 Spring 빈으로 등록합니다. 애플리케이션 컨텍스트는 모든 관리되는 빈의 레지스트리를 유지하여 의존성 주입에 접근할 수 있게 합니다.\n\n빈 구성: Spring Framework는 등록된 빈에 기본 구성 규칙을 적용합니다. 이러한 규칙에는 의존성 주입, 빈 생명주기 관리 및 리소스 관리가 포함됩니다. 개발자는 어노테이션, XML 구성 파일 또는 프로그래밍 방식을 사용하여 빈 구성을 더 잠재적으로 사용자 정의할 수 있습니다.\n\n```java\n구성 클래스:\n@Configuration\n@ComponentScan(\"com.example.springapp\")\npublic class AppConfig {\n}\n```\n\n이 구성 클래스는 두 개의 어노테이션을 정의합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- `@Configuration`: 이 클래스를 Spring의 빈 정의 원천으로 표시합니다.\n\n- `@ComponentScan`: 구성 요소 스캔의 기본 패키지를 지정합니다. Spring은 이 패키지 및 하위 패키지를 스캔하여 `@Component`, `@Service`, `@Repository`, 또는 `@Controller`로 주석이 달린 클래스를 찾아 Spring 빈으로 등록합니다.\n\n# ApplicationContext은 무엇이며 Spring 내에서 어떻게 사용할까요?\n\nApplicationContext는 빈 관리 및 Spring 애플리케이션에 서비스를 제공하는 핵심 컨테이너입니다. 빈 구성, 의존성 주입 및 자원 관리를 간단화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 사용해야 합니다.\n\n```js\nClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\nMyService myService = context.getBean(\"myService\", MyService.class);\nmyService.doSomething();\ncontext.close();\n```\n\n이 코드는 XML 구성 파일에서 ApplicationContext를 생성하고, 이름으로 빈을 검색하여 빈의 메소드를 호출하고, ApplicationContext를 닫는 방법을 보여줍니다.\n\n# BeanFactory란 무엇이며 Spring에서 어떻게 사용하는가?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBeanFactory는 Spring 애플리케이션에서 빈을 관리하기 위한 기본 컨테이너를 나타내는 인터페이스입니다. 빈을 생성, 검색 및 구성하는 메서드를 제공합니다. ApplicationContext는 보다 고급이며 일반적으로 사용되는 컨테이너이지만, BeanFactory는 기본적인 빈 관리를 위한 더 간단한 인터페이스를 제공합니다.\n\n다음은 예시입니다.\n\n```java\nBeanFactory factory = new XmlBeanFactory(\"applicationContext.xml\");\nMyService myService = factory.getBean(\"myService\", MyService.class);\nmyService.doSomething();\n```\n\n# 빈이란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빈: Spring에서 빈은 Spring IoC 컨테이너 내에서 관리되는 관리 객체입니다. Spring 프레임워크에 의해 생성, 관리 및 연결되는 클래스의 인스턴스입니다. 빈은 Spring 애플리케이션의 기본 구성 요소이며, 주로 주석 또는 XML 구성을 사용하여 구성 및 정의됩니다.\n\n# 빈 스코프란 무엇인가요?\n\nSpring 프레임워크에서 빈 스코프는 Spring IoC 컨테이너 내에서 빈의 수명주기와 가시성을 정의합니다. Spring 프레임워크는 각기 다른 목적과 동작을 가진 여러 내장 빈 스코프를 제공합니다.\n\n다음은 Spring Framework에서 가장 일반적으로 사용되는 빈 스코프입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n싱글톤:\n\n(기본값) Spring IoC 컨테이너마다 개체 인스턴스에 대해 단일 빈 정의를 스코프 지정합니다.\n\n프로토타입:\n\n임의의 개체 인스턴스 수에 대해 단일 빈 정의를 스코프 지정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요청:\n\n하나의 빈 정의를 하나의 HTTP 요청 수명 주기에 한정합니다. 즉, 각 HTTP 요청은 하나의 빈 정의를 사용하여 생성된 별도의 인스턴스를 가지게 됩니다. 웹-aware Spring ApplicationContext의 맥락에서만 유효합니다.\n\n세션:\n\n하나의 빈 정의를 HTTP 세션의 수명 주기에 한정합니다. 웹-aware Spring ApplicationContext의 맥락에서만 유효합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션:\n\n하나의 빈 정의를 ServletContext의 라이프사이클에 범위를 지정합니다. 웹 기반 Spring ApplicationContext의 컨텍스트에서만 유효합니다.\n\n웹소켓:\n\n하나의 빈 정의를 웹소켓의 라이프사이클에 범위를 지정합니다. 웹 기반 Spring ApplicationContext의 컨텍스트에서만 유효합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스프링 빈 라이프사이클이란 무엇인가요?\n\n스프링 프레임워크에서 빈은 Spring IoC 컨테이너에 의해 관리되는 객체입니다. 빈의 라이프사이클은 빈이 생성되어 소멸될 때까지 발생하는 일련의 이벤트입니다.\n\n- 스프링 빈 라이프사이클은 인스턴스화, 구성, 소멸 세 단계로 나눌 수 있습니다.\n\n- 인스턴스화: 이 단계에서 Spring IoC 컨테이너는 빈의 인스턴스를 생성합니다. 스프링 프레임워크는 빈을 인스턴스화하는 여러 방법을 지원합니다. 생성자를 통해, 정적 팩토리 메서드를 통해, 또는 인스턴스 팩토리 메서드를 통해 등등.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 설정: 이 단계에서는 Spring IoC 컨테이너가 새로 생성된 빈을 구성합니다. 이는 의존성 주입을 수행하고 빈 후처리기를 적용하며 초기화 및 소멸 콜백을 등록하는 것을 포함합니다.\n\n- 소멸: 이 단계에서는 Spring IoC 컨테이너가 빈 인스턴스를 파괴합니다. 이는 Spring 빈 라이프사이클의 마지막 단계입니다.\n\n이 세 단계 외에도 Spring 프레임워크는 개발자가 빈에 대한 사용자 정의 초기화 및 소멸 로직을 지정할 수 있도록 여러 콜백을 제공합니다. 이러한 콜백에는 다음이 포함됩니다:\n\n- @PostConstruct: 빈이 구성된 후에 호출되며 모든 종속성이 주입된 후에 호출됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- init-method: 빈이 생성되고 모든 의존성이 주입된 후 호출할 메서드를 지정합니다.\n\n- destroy-method: 빈이 소멸되기 직전에 호출할 메서드를 지정합니다.\n\n- @PreDestroy: 빈이 소멸되기 전에 호출됩니다.\n\nSpring 빈 생명주기는 Spring IoC 컨테이너에 의해 제어되며, 빈의 생명주기를 생성, 구성 및 관리합니다. 개발자들은 빈 생명주기 콜백을 활용하여 빈에 사용자 정의 초기화 및 소멸 로직을 추가할 수 있으며, 객체의 생명주기를 쉽게 관리하고 리소스가 올바르게 처리되도록 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 애플리케이션 컨텍스트에서 빈 라이프사이클은 무엇인가요?\n\n애플리케이션 컨텍스트 내의 빈 라이프사이클은, 빈이 생성부터 소멸까지 거치는 다양한 단계를 가리킵니다. 애플리케이션 컨텍스트는 이 라이프사이클을 관리하며, 빈이 적절한 시간에 올바르게 초기화되고 사용되며 소멸되도록 보장합니다.\n\n빈 라이프사이클의 단계:\n\n- 빈 생성: 빈이 생성되고, 생성자 주입, 세터 주입 또는 다른 방법을 통해 초기화됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 빈 구성: 빈의 속성이 설정되고 필요한 초기화 콜백이 호출됩니다.\n\n- 빈 사용: 응용 프로그램에서 빈을 사용하여 지정된 기능을 제공합니다.\n\n- 빈 소멸: 빈이 더 이상 필요하지 않을 때 파괴되고, 리소스를 해제하고 필요한 정리 작업을 수행합니다.\n\n빈 라이프사이클에서 애플리케이션 컨텍스트의 역할:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 애플리케이션 컨텍스트는 빈 생명주기를 관리하는 데 중요한 역할을 합니다. 빈의 생성, 구성, 사용 및 소멸을 제어하기 위한 다양한 메커니즘을 제공합니다.\n\n- 빈 구성 메타데이터: 애플리케이션 컨텍스트는 빈에 대한 구성 메타데이터를 저장하며, 빈이 어떻게 생성, 구성 및 관리되어야 하는지를 정의합니다.\n\n- 빈 생명주기 후크: 애플리케이션 컨텍스트는 빈 생명주기의 다양한 단계에서 초기화 및 소멸 콜백과 같이 사용자 정의 동작을 정의하는 후크를 제공합니다.\n\n- 빈 범위 관리: 애플리케이션 컨텍스트는 빈의 범위를 관리하여 애플리케이션 내에서의 가시성과 수명을 결정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Bean Lifecycle Listeners: 애플리케이션 컨텍스트는 빈 생명주기 리스너를 지원하여 다른 빈의 생명주기 변경 사항을 알릴 수 있습니다.\n\n## BeanFactory와 ApplicationContext의 차이는?\n\n![이미지](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_6.png)\n\n## 스프링의 기본 빈 스코프는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring의 기본 빈 스코프는 싱글톤입니다. 이는 빈의 인스턴스가 한 번만 만들어지고 스프링 컨테이너에 의해 관리된다는 것을 의미합니다. 요청 횟수에 상관 없이 동일한 빈 인스턴스가 사용됩니다. 이 스코프는 상태가 없는 빈에 유용하며, 내부 상태를 유지하지 않고 응용 프로그램의 다양한 부분에서 안전하게 공유될 수 있는 빈에 적합합니다.\n\n다음 다이어그램은 하나의 인스턴스가 생성되는 방법을 보여줍니다.\n\n![diagram](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_7.png)\n\n빈이 어떻게 스프링 내에서 로드되는지 설명해 주시겠어요? 그리고 레이지 로딩과 이거 로딩의 차이점을 설명해 주실 수 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n봄에는 빈 로딩이 있어요:\n\n봄 프레임워크는 빈 인스턴스화라는 프로세스를 사용하여 빈을 만들고 애플리케이션에서 사용할 수 있게 해요. 이 프로세스에는 다음 단계가 포함돼요:\n\n빈 스캔: 봄 프레임워크는 애플리케이션 컨텍스트를 스캔하여 @Component, @Service, @Repository, @Controller와 같은 스프링 주석이 달린 클래스를 찾아요.\n\n빈 인스턴스 생성: 봄 프레임워크는 찾은 각 빈 클래스의 인스턴스를 생성해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빈 구성: 스프링 프레임워크는 각 빈을 구성하여 속성을 설정하고 의존성을 주입합니다.\n\n빈 초기화: 스프링 프레임워크는 초기화 콜백을 호출하여 각 빈을 초기화합니다.\n\n# 지연 로딩 vs 즉시 로딩? (중요한 면접 질문)\n\nSpring에서 빈은 지연로딩 또는 즉시로딩으로 설정할 수 있습니다. 지연로딩은 애플리케이션이 처음 요청할 때까지 빈이 생성되지 않는 것을 의미합니다. 즉시로딩은 애플리케이션이 시작될 때 빈이 생성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring의 기본 동작은 빈을 Eager로 로드하는 것입니다. 이는 실제로 필요한 빈만 만들기 때문에 애플리케이션의 성능을 향상시킬 수 있습니다. 그러나 lazy loading은 생성된 빈을 추적하기 어렵게 만들어 애플리케이션을 디버깅하기 어렵게 만들 수도 있습니다.\n\nEager loading은 애플리케이션이 시작하는 즉시 필요한 빈에 유용할 수 있습니다. 예를 들어, 애플리케이션이 시작되자마자 데이터베이스에 연결해야 할 수도 있습니다. 이 경우 데이터베이스에 연결하는 책임을 지는 빈을 Eager로 로드하는 것이 합리적일 것입니다.\n\n# Lazy 로딩 및 Eager 로딩 지정 방법\n\n@Lazy 주석을 사용하여 빈을 lazy 로드할지 또는 eager로 로드할지 지정할 수 있습니다. 예를 들어, 다음 코드는 lazy로 로드되는 빈을 생성합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n@Lazy\n@Service\npublic class MyService {\n}\n```\n\n아래 코드는 즉시 로딩되는 빈을 생성합니다:\n\n```java\n@Service\npublic class MyEagerService {\n}\n```\n\n레이지 로딩과 이거 로딩을 언제 사용해야 하는지:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 애플리케이션이 시작될 때 즉시 필요하지 않은 bean에는 lazy loading을 사용하세요.\n- 애플리케이션이 시작될 때 즉시 필요한 bean에는 eager loading을 사용하세요.\n- 시작 비용이 높은 bean에는 eager loading을 사용하세요.\n- 자주 사용되지 않는 bean에는 lazy loading을 사용하세요.\n\n**@Autowired 어노테이션이 작동하는 방식**\n\n@Autowired 어노테이션은 리플렉션(reflection)을 사용하여 적절한 의존성을 주입하도록 작동합니다. 먼저, 해당 종속성과 동일한 유형의 bean을 찾습니다. 동일한 유형의 bean을 찾을 수 없는 경우, 이름이 의존성과 일치하는 qualifier를 갖는 bean을 찾습니다. 그래도 주입할 bean을 찾을 수 없는 경우 예외가 발생합니다.\n\n**자동 주입의 종류**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@Autowired 어노테이션이 지원하는 네 가지 자동 연결 유형이 있습니다:\n\n- byType: 이것은 기본 자동 연결 유형입니다. Spring Framework는 종속성과 동일한 유형의 빈을 찾습니다.\n\n- byName: Spring Framework는 종속성과 동일한 이름을 가진 빈을 찾습니다.\n\n- byConstructor: Spring Framework는 종속성의 유형과 일치하는 단일 인수를 사용하는 생성자를 찾습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- byQualifier: 스프링 프레임워크는 지정된 값과 일치하는 한정자를 가진 빈을 찾습니다.\n\n## 어떻게 자동 와이어링에서 빈을 제외할 수 있을까요?\n\nSpring에서 빈을 자동 와이어링에서 제외하는 방법은 다음과 같습니다:\n\n1. XML 구성에서 autowire-candidate를 false로 설정하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXML 구성에서 제왈하고 싶은 'bean' 요소에 autowire-candidate=\"false\" 속성을 추가하세요:\n\n```js\n\u003cbean id=\"myBean\" class=\"com.example.MyBean\" autowire-candidate=\"false\"\u003e\u003c/bean\u003e\n```\n\n2. @Lazy 주석 사용하기 (지연 초기화를 위해):\n\n빈 구성을 주석으로 사용하는 경우, 빈 클래스나 해당 @Bean 메서드에 @Lazy를 주석으로 추가하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n@Lazy\n@Bean\npublic MyBean myBean() {\n    return new MyBean();\n}\n```\n\n3. Disabling auto-configuration for a specific bean:\n\nIn Spring Boot, use `@SpringBootApplication(exclude = 'MyBeanAutoConfiguration.class')` to exclude a specific auto-configuration class.\n\n# Difference between `@Autowire` and `@Inject` in Spring?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@Autowired 및 @Inject 어노테이션은 둘 다 Spring 애플리케이션에서 의존성 주입에 사용됩니다. 그러나 이 두 어노테이션 간에는 몇 가지 주요 차이점이 있습니다.\n\n@Autowired(스프링 애플리케이션 개발 시 사용)\n\n@Autowired 어노테이션은 스프링 전용 어노테이션입니다. 이 어노테이션은 Spring 컨테이너에서 관리되는 빈에 의존성을 주입하는 데 사용됩니다. @Autowired 어노테이션은 byType, byName, byConstructor, byQualifier라는 네 가지 자동 연결 유형과 함께 사용할 수 있습니다.\n\n@Inject(스프링이 아닌 애플리케이션 개발 시 사용)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`@Inject` 어노테이션은 표준 JSR-330 어노테이션입니다. 이 어노테이션은 JSR-330을 지원하는 의존성 주입 컨테이너에서 관리되는 빈에 의존성을 주입하는 데 사용됩니다. `@Inject` 어노테이션은 byType 및 byName 자동 연결과 함께만 사용할 수 있습니다.\n\n# 싱글톤 Bean은 스레드 안전한가요?\n\n아니요, 싱글톤 빈은 기본적으로 스레드 안전하지 않습니다. 이는 두 스레드가 동시에 싱글톤 빈에 액세스하려고 시도하는 경우 충돌하는 결과가 발생할 수 있다는 것을 의미합니다. 이는 싱글톤 빈이 모든 스레드에서 공유되며, 한 스레드가 싱글톤 빈에 대한 변경을 가하면 다른 모든 스레드에서도 해당 변경 사항이 보인다는 것을 의미합니다.\n\n# 싱글톤과 프로토타입 빈의 차이점은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_8.png](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_8.png)\n\n# 스프링에서 @Bean 어노테이션이란?\n\n@Bean 어노테이션은 Spring Framework 어노테이션으로, 메소드를 빈 정의로 표시하는 역할을 합니다. 빈 정의는 Spring 컨테이너에게 빈을 생성하고 관리하는 방법을 알려줍니다. 메소드에 @Bean 어노테이션을 붙이면 Spring 컨테이너는 메소드에서 반환된 빈 클래스의 인스턴스를 생성하고 라이프사이클을 관리합니다.\n\n```js\n@Configuration\npublic class MyConfiguration {\n@Bean\npublic MyService myService() {\nreturn new MyServiceImpl();\n}\n}\n```\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서 myService() 메소드는 @Bean으로 주석 처리되어 있습니다. 이는 Spring 컨테이너에 MyServiceImpl 클래스의 인스턴스를 생성하고 라이프사이클을 관리하도록 알려줍니다. 그런 다음 해당 빈은 @Autowired 주석을 사용하여 다른 빈에 주입될 수 있습니다.\n\n# @Configuration 주석이 무엇인가요?\n\n@Configuration 주석은 Spring Framework 주석으로, 클래스를 구성 클래스로 표시합니다. 구성 클래스는 Spring 애플리케이션에서 빈을 정의하는 데 사용됩니다. 클래스에 @Configuration이 주석으로 달려 있을 때, Spring 컨테이너는 @Bean으로 주석이 달린 메소드를 검색하여 그 메소드를 사용하여 빈을 정의합니다.\n\n```js\n@Configuration\npublic class MyConfiguration {\n@Bean\npublic MyService myService() {\nreturn new MyServiceImpl();\n}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Spring 프로필을 구성하는 방법은?\n\nSpring 프로필은 애플리케이션 구성의 일부를 분리하고 특정 환경에서만 사용할 수 있도록하는 방법을 제공합니다.\n\nSpring 프로필을 구성하는 두 가지 방법이 있습니다:\n\n1. Spring Boot 속성 파일을 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring Boot 속성 파일은 일반적으로 application.properties 또는 application.yml로 명명되며 Spring 프로필을 구성하는 편리한 방법입니다. 속성 파일을 사용하여 프로필을 구성하려면 다음 속성을 추가하면 됩니다:\n\n예:\nspring.profiles.active=profile1,profile2\n\nMarkdown 형식으로 변경해 드릴까요?\n\n# @component, @profile, @value 어노테이션은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_9.png)\n\n# @Value 어노테이션 내부의 $와 #은 무엇을 하는 것인가요?\n\n$ 기호는 속성 값을 다양한 소스(예: 속성 파일, 환경 변수 및 시스템 속성)에서 주입하는 데 사용됩니다. 예를 들어, 다음 코드는 application.properties 파일에서 app.name 속성의 값을 주입합니다:\n\n예:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n@Value(\"$'app.name'\")\n\nprivate String appName;\n\n```\n\n# 기호는 SpEL(Spandom Expression Language) 표현식에 액세스하는 데 사용됩니다. SpEL은 속성 값에 대한 복잡한 작업을 수행하는 데 사용할 수 있는 강력한 표현 언어입니다. 예를 들어, 다음 코드는 app.name 속성의 값을 주입하고 대문자로 변환합니다:\n\n예시.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n@Value(\"#'‘$'app.name'’.toUpperCase()'\")\n\nprivate String appNameUppercase;\n```\n\n# 스프링에서 stateless bean이란 무엇인가요? 그것의 이름을 말하고 설명해주세요.\n\nSpring Framework에서 stateless bean은 메소드 호출 사이에 상태를 유지하지 않는 bean입니다. 이는 bean이 이전 호출에 대한 정보를 저장하지 않고 각 메소드 호출이 독립적으로 처리된다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStateless beans are typically used for services that perform actions or calculations, but do not maintain any state between invocations. This can include services that perform mathematical calculations, access external resources, or perform other tasks that do not require the bean to maintain state.\n\nStateless beans can be implemented as singleton beans, and multiple clients can share the same instance of the bean. Since stateless beans do not maintain any state, they can be easily scaled horizontally by adding more instances of the bean to handle the increased load.\n\nStateless beans also have the advantage of being simpler and easier to reason about, since they do not have to worry about maintaining state between invocations. Additionally, since stateless beans do not maintain any state, they can be easily serialized and replicated for high availability and scalability.\n\n# Spring에서 빈을 주입하는 방법은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n봄(Spring)에서 빈(bean)은 의존성 주입(Dependency Injection, DI) 패턴을 사용하여 다른 빈에 주입(또는 연결)됩니다. DI는 클래스가 스스로 생성하는 대신 의존성을 제공받을 수 있는 설계 패턴입니다.\n\nSpring은 다른 빈에 빈을 주입하는 여러 가지 방법을 제공합니다.\n\n생성자 주입(Constructor injection): 빈을 생성자 인수로 전달하여 다른 빈에 주입할 수 있습니다. 스프링은 의존성이 있는 빈의 인스턴스를 자동으로 생성하고 생성자에 전달합니다.\n\n```java\npublic class BeanA {\nprivate final BeanB beanB;\npublic BeanA(BeanB beanB) {\nthis.beanB = beanB;\n}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSetter 주입: 한 빈(Bean)을 다른 빈에 세터 메소드 인자로 전달하여 주입할 수 있습니다. 스프링(Spring)은 자동으로 세터 메소드를 호출하고 의존성 있는 빈(Bean)을 전달합니다.\n\n```java\npublic class BeanA {\n    private BeanB beanB;\n    @Autowired\n    public void setBeanB(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n```\n\n필드 주입: 한 빈을 다른 빈에 @Autowired 어노테이션을 사용하여 필드에 주입할 수 있습니다. 스프링은 해당 필드에 의존성 있는 빈을 자동으로 설정합니다.\n\n```java\npublic class BeanA {\n    @Autowired\n    private BeanB beanB;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터페이스 주입: 빈은 인터페이스를 구현함으로써 다른 빈에 주입될 수 있습니다. Spring은 의존성 빈을 필드에 자동으로 설정해 줍니다.\n\n```java\npublic class BeanA implements BeanBUser {\n@Autowired\nprivate BeanB beanB;\n}\n```\n\n중요한 점은 위의 방법을 임의 조합하여 사용할 수 있지만, 사용 사례에 따라 적합한 방법을 선택해야 한다는 것입니다.\n\n또한, Spring은 자동으로 빈을 연결하기 위해 Autowiring이라는 기술을 사용합니다. Autowiring은 타입, 이름 또는 생성자를 통해 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 Spring은 빈을 유형별로 자동 연결하려고 시도하지만, 동일한 유형의 빈이 여러 개인 경우 구성 파일에서 정의된 빈의 이름을 사용하여 이름별로 자동 연결을 시도합니다.\n\n# 빈 간 순환 종속성 처리 방법?\n\n예를 들어, 빈 A가 빈 B에 종속되고 빈 B가 빈 A에 종속되는 경우를 생각해 봅시다. 스프링 컨테이너는 어떻게 즉시 로딩과 지연 로딩을 처리할까요?\n\n빈 간 순환 종속성은 두 개 이상의 빈이 서로 상호 종속성을 갖는 경우 발생하며, 이로 인해 이러한 빈들의 생성 및 초기화에 문제가 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring에서 빈 간의 순환 종속성을 처리하는 여러 가지 방법이 있습니다:\n\n- Lazy Initialization: 순환에 관여하는 빈 중 하나에 @Lazy 주석을 사용하여 필요할 때만 초기화할 수 있습니다.\n\n\n@Lazy\n@Autowired\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nprivate BeanA beanA;\n\n생성자 주입: setter나 필드 주입 대신 생성자 주입을 사용하면 의존성이 제대로 제공될 때까지 빈이 완전히 초기화되도록 할 수 있습니다.\n\n```java\npublic class BeanA {\n    private final BeanB beanB;\n\n    public BeanA(BeanB beanB) {\n        this.beanB = beanB;\n    }\n}\n```\n\n프록시 사용: 프록시를 사용하여 한 빈의 초기화를 실제로 필요할 때까지 지연시켜 순환을 중단할 수 있습니다. Spring AOP를 사용하여 순환이 발생하는 빈 중 하나에 대한 프록시를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBeanFactory를 사용하세요: 빈을 직접 주입하는 대신, 실제로 필요할 때 BeanFactory를 사용하여 빈을 검색할 수 있습니다.\n\n```java\npublic class BeanA {\n\n    private BeanB beanB;\n\n    @Autowired\n    public BeanA(BeanFactory beanFactory) {\n        this.beanB = beanFactory.getBean(BeanB.class);\n    }\n}\n```\n\nSpring 부트 애플리케이션을 시작/로드하기 전에 어떤 메서드를 호출할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring Boot에서는 Spring Boot 애플리케이션을 시작하거나 로드하기 전에 호출할 수 있는 여러 메서드가 있습니다. 가장 일반적으로 사용되는 메서드 중 일부는 다음과 같습니다:\n\nmain() 메서드: main() 메서드는 일반적으로 Spring Boot 애플리케이션의 진입점입니다. SpringApplication.run() 메서드를 호출하여 Spring Boot 애플리케이션을 시작하는 데 사용됩니다.\n\n@PostConstruct 메서드: @PostConstruct 주석은 빈이 구성된 후에 호출되어야 하는 메서드를 표시하는 데 사용할 수 있습니다. 이를 사용하여 애플리케이션이 시작하기 전에 필요한 초기화를 수행할 수 있습니다.\n\nCommandLineRunner 인터페이스: CommandLineRunner 인터페이스는 빈에 의해 구현될 수 있으며 Spring Application 컨텍스트가 로드된 후에 특정 코드를 실행하는 데 사용될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nApplicationRunner 인터페이스: ApplicationRunner 인터페이스는 빈에 의해 구현될 수 있어 Spring 응용 프로그램 컨텍스트가로드되고 응용 프로그램 인수가 처리 된 후에 특정 코드를 실행하는 데 사용할 수 있습니다.\n\n@EventListener: @EventListener 어노테이션은 ApplicationStartingEvent, ApplicationReadyEvent 등과 같은 특정 응용 프로그램 이벤트를 수신하도록 메서드를 등록하는 데 사용할 수 있습니다.\n\n# Spring 프레임워크에서 예외를 처리하는 방법\n\nSpring 프레임워크에서 예외를 처리하는 여러 가지 방법이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntry-catch 블록: 예외를 처리하고 처리할 수 있도록 try-catch 블록을 사용할 수 있습니다. 특정 예외를 처리하는 데 유용하며 특정 메소드 내에서 발생할 가능성이 있는 예외를 처리할 수 있습니다.\n\n@ExceptionHandler 어노테이션: @Controller 클래스의 메소드에 @ExceptionHandler 어노테이션을 사용하여 동일한 클래스 내의 다른 메소드에서 발생하는 예외를 처리할 수 있습니다. 여러 메소드에서 특정 예외를 중앙에서 처리하는 데 유용합니다.\n\n@ControllerAdvice 어노테이션: 글로벌 예외 처리기를 정의하기 위해 @ControllerAdvice 어노테이션을 클래스에 사용할 수 있습니다. 응용 프로그램의 여러 컨트롤러에서 특정 예외를 중앙에서 처리하는 데 유용합니다.\n\nHandlerExceptionResolver 인터페이스: HandlerExceptionResolver 인터페이스를 구현하여 전체 응용 프로그램에 대한 전역 예외 처리기를 만들 수 있습니다. 응용 프로그램 전체에서 특정 예외를 중앙에서 처리하는 데 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에러 페이지: 응용 프로그램에서 특정 예외가 발생할 때 특정 페이지로 리디렉션하는 ErrorPage를 정의할 수 있습니다. 이 접근 방식은 예외가 발생했을 때 사용자 친화적인 에러 페이지를 표시하는 데 유용합니다.\n\n@ResponseStatus 어노테이션: 예외 클래스에 @ResponseStatus 어노테이션을 사용하여 예외가 발생했을 때 반환되어야 하는 HTTP 상태 코드를 정의할 수 있습니다.\n\n# 스프링에서 필터는 어떻게 작동하나요?\n\n스프링에서 필터는 요청과 응답의 인터셉터 역할로, 실제 응용 프로그램 로직에 도달하기 전후에 처리합니다. 이들은 미리 정의된 규칙에 따라 요청을 수정, 거부 또는 허용할 수 있는 \"수문장\"과 같은 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 간략히 설명드리겠습니다:\n\n1. 설정:\n\n   - 필터를 Spring 구성에서 빈으로 정의합니다.\n\n   - 필터가 실행되는 순서를 지정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 요청 흐름:\n\n- 클라이언트가 요청을 보내면 지정된 순서대로 각 필터를 거칩니다.\n\n- 각 필터는:\n\n- 요청 헤더, 본문 및 기타 속성을 검사할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**변경 내용 또는 헤더를 수정합니다.**\n\n**요청을 계속 처리할지 종료할지 결정합니다.**\n\n**3. 응답 흐름:**\n\n**· 요청이 응용 프로그램 논리에 도달하고 응답을 받으면, 응답이 역순으로 다시 필터를 통해 흐릅니다.**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n필터는 다시 다음을 수행할 수 있습니다:\n\n- 응답 헤더 및 본문을 검사합니다.\n- 응답 내용이나 헤더를 수정합니다.\n\n4. 일반적인 사용 사례:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 보안 필터: 사용자 인증을 확인하고 액세스 권한을 부여하며 보안 취약점을 방지합니다.\n\n- 로깅 필터: 요청 및 응답에 대한 정보를 기록하여 디버깅 및 분석에 사용합니다.\n\n- 압축 필터: 대역폭 사용량을 줄이기 위해 응답을 압축합니다.\n\n- 캐싱 필터: 성능을 향상시키기 위해 자주 액세스되는 리소스를 캐싱합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n혜택:\n\n- 요청과 응답을 가로채고 수정: 애플리케이션 동작에 더 많은 제어를 제공합니다.\n\n- 공통 작업 중앙 집중화: 보안, 로깅 등의 코드 중복을 피합니다.\n\n- 여러 필터를 연결: 여러 필터를 결합하여 복잡한 처리 논리를 구현할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 디스패쳐 서블릿이란?\n\n디스패쳐 서블릿은 스프링 MVC 애플리케이션의 중심 \"프론트 컨트롤러\" 역할을 합니다. 이는 모든 들어오는 HTTP 요청을 받고 적절한 컨트롤러 클래스에 위임하는 서블릿입니다. 디스패쳐 서블릿은 각 요청에 대해 적절한 핸들러 메소드를 식별하고 호출하여 요청이 올바르게 처리되도록 하는 역할을 합니다.\n\n다음은 Java 구성의 예제로, 서블릿 컨테이너에서 자동으로 감지되는 디스패쳐 서블릿을 등록하고 초기화하는 방법을 보여줍니다.\n\n```js\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n@Override\npublic void onStartup(ServletContext servletContext) {\n// 스프링 웹 애플리케이션 구성 로드\nAnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\ncontext.register(AppConfig.class);\n// 디스패쳐 서블릿 생성 및 등록\nDispatcherServlet servlet = new DispatcherServlet(context);\nServletRegistration.Dynamic registration = servletContext.addServlet(\"app\", servlet);\nregistration.setLoadOnStartup(1);\nregistration.addMapping(\"/app/*\");\n}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스프링에서 @Controller 주석은 무엇인가요?\n\n@Controller 주석은 스프링의 스테레오타입 주석으로, 클래스가 웹 컨트롤러로 작동한다는 것을 나타냅니다. 주로 Spring MVC 애플리케이션에서 사용되며 클래스를 HTTP 요청의 핸들러로 표시하는 데 사용됩니다. 클래스가 @Controller로 주석 처리되면 Spring 컨테이너에 의해 스캔되어 특정 HTTP 요청을 처리하는 메서드로 식별될 수 있습니다.\n\nSpring MVC는 @Controller 및 @RestController 컴포넌트가 요청 매핑, 요청 입력, 예외 처리 등을 표현하기 위해 주석을 사용하는 주석 기반 프로그래밍 모델을 제공합니다. 주석이 지정된 컨트롤러는 유연한 메서드 시그니처를 가지고 있으며 기본 클래스를 확장하거나 특정 인터페이스를 구현할 필요가 없습니다. 다음 예시는 주석을 사용하여 정의된 컨트롤러를 보여줍니다:\n\n예시.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n@Controller\npublic class HelloController {\n@GetMapping(\"/hello\")\npublic String handle(Model model) {\nmodel.addAttribute(\"message\", \"Hello World!\");\nreturn \"index\";\n}\n}\n```\n\n# 컨트롤러가 들어오는 요청과 적절한 메소드를 매핑하는 방법은?\n\n@RequestMapping 주석을 사용하여 요청을 컨트롤러 메소드에 매핑할 수 있습니다. URL, HTTP 메소드, 요청 매개변수, 헤더 및 미디어 유형에 따라 일치시킬 수 있는 다양한 속성이 있습니다. 클래스 수준에서 사용하여 공유 매핑을 나타낼 수도 있고, 메소드 수준에서 사용하여 특정 엔드포인트 매핑으로 좁힐 수도 있습니다. 요청 매핑 프로세스:\n\n또한 @RequestMapping의 HTTP 메소드별 바로 가기 변형도 있습니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n- @GetMapping\n- @PostMapping\n- @PutMapping\n- @DeleteMapping\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n## @PatchMapping\n\n**Request Reception:** The DispatcherServlet receives an incoming HTTP request containing the request URI, HTTP method (GET, POST, PUT, DELETE, etc.), and request parameters.\n\n**Mapping Lookup:** The DispatcherServlet utilizes a HandlerMapping component to lookup the appropriate handler method for the received request. The HandlerMapping maintains a registry of mappings between request patterns and handler methods.\n\n**Pattern Matching:** The HandlerMapping compares the request URI and HTTP method against the registered request patterns. It uses pattern matching rules to identify the most specific matching pattern.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n핸들러 메서드 식별: 일치하는 패턴을 식별한 후 HandlerMapping은 해당 핸들러 메서드를 레지스트리에서 검색합니다. 이 핸들러 메서드는 들어오는 요청을 처리하는 책임이 있습니다.\n\n메서드 호출: DispatcherServlet은 식별된 핸들러 메서드를 호출하며, 요청 객체를 인수로 전달합니다. 핸들러 메서드는 요청의 로직을 처리하고 적절한 응답을 생성합니다.\n\n응답 처리: 핸들러 메서드가 실행을 완료하면, DispatcherServlet은 생성된 응답 객체를 수신합니다. 적절한 헤더와 콘텐츠를 설정하여 응답을 준비하고 클라이언트에게 응답을 전송합니다.\n\n이것은 샘플 프로그램입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n@RestController\n@RequestMapping(\"/persons\")\nclass PersonController {\n@GetMapping(\"/{id}\")\npublic Person getPerson(@PathVariable Long id) {\n// …\n}\n@PostMapping\n@ResponseStatus(HttpStatus.CREATED)\npublic void add(@RequestBody Person person) {\n// …\n}\n}\n```\n\n## Spring MVC에서 @Controller와 @RestController의 차이점은 무엇인가요?\n\n@Controller:\n\n전통적인 MVC 애플리케이션에 대한 컨트롤러로 클래스를 지정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 메서드는 뷰 이름(String)을 반환하며, 이는 뷰 리졸버에 의해 해결되어 뷰를 렌더링합니다 (예: HTML 페이지).\n\n요청 경로와 동일한 경우 뷰 이름을 반환하는 void를 반환할 수도 있습니다.\n\n개별 메서드에 @ResponseBody를 사용하여 데이터를 직접 반환할 수도 있지만, 이것은 기본 동작이 아닙니다.\n\n@RestController:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레스트풀 웹 서비스를 구축하는 데 특화된 컨트롤러입니다.\n\n모든 핸들러 메서드에 @ResponseBody가 암시적으로 적용되어 데이터를 일반적으로 JSON 또는 XML 형식으로 응답 본문에 직접 반환합니다.\n\n데이터를 반환할 때 뷰 해상도나 수동 설정이 필요하지 않습니다.\n\n레스트 API 개발을 간단하게 만들어 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각각을 사용하는 시점:\n\n- 뷰를 렌더링하고 HTML 콘텐츠를 반환하는 전통적인 웹 애플리케이션에는 @Controller를 사용합니다.\n\n- JSON이나 XML과 같은 형식으로 주로 데이터를 반환하는 RESTful API를 구축할 때는 @RestController를 사용합니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n@Controller\npublic class MyController {\n@GetMapping(\"/hello\")\npublic String hello() {\nreturn \"hello\"; // \"hello\" 뷰 이름을 반환합니다\n}\n}\n\n@RestController\npublic class MyRestController {\n@GetMapping(\"/greeting\")\npublic String greeting() {\nreturn \"Hello, World!\"; // JSON 또는 XML로 \"Hello, World!\"을 반환합니다\n}\n}\n```\n\n# @Requestparam과 @Pathparam 어노테이션의 차이점은?\n\n@Requestparam:\n\n@Requestparam 어노테이션을 사용하여 서블릿 요청 매개변수(쿼리 매개변수 또는 폼 데이터)를 컨트롤러의 메소드 인수에 바인딩할 수 있습니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 코드 예시입니다.\n\n```java\n@Controller\n@RequestMapping(\"/pets\")\npublic class EditPetForm {\n    @GetMapping\n    public String setupForm(@RequestParam(\"petId\") int petId, Model model) {\n        Pet pet = this.clinic.loadPet(petId);\n        model.addAttribute(\"pet\", pet);\n        return \"petForm\";\n    }\n}\n```\n\n`@RequestParam`을 사용하여 petId를 바인딩합니다.\n\n기본적으로 이 주석을 사용하는 메소드 파라미터는 필수입니다. 하지만 `@RequestParam` 주석의 `required` 플래그를 `false`로 설정하거나 `java.util.Optional` 래퍼로 인자를 선언함으로써 메소드 파라미터가 옵션임을 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@Pathparam\n\n기능:\n\n- 요청 URI 경로에서 변수를 Spring 컨트롤러의 메소드 매개변수로 매핑할 수 있습니다.\n- 이를 통해 API에서 동적 데이터를 처리하는 더 깔끔하고 유연한 방법을 제공합니다.\n\n사용 방법:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- @Pathparam 어노테이션을 메소드 매개변수에 적용합니다.\n- 어노테이션 내에서 URI 경로에서 변수의 이름을 지정하여 매개변수에 바인딩합니다.\n\n![이미지](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_10.png)\n\n# 세션 스코프는 무엇에 사용됩니까?\n\n세션 스코프는 특정 HTTP 세션에 바인드된 객체의 라이프사이클을 관리하는 방법입니다. 세션 스코프에서 객체가 생성되면 세션에 저장되어 동일 세션에 속하는 모든 요청에서 접근할 수 있습니다. 이는 사용자별 정보를 저장하거나 여러 요청 간에 상태를 유지하는 데 유용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Spring에서 @Component, @Service, @Controller, @Repository 어노테이션의 차이는 무엇입니까?\n\n![이미지](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_11.png)\n\n# Spring-MVC 흐름 상세히 설명\n\nSpring MVC는 Java 웹 애플리케이션을 구축하기 위한 인기있는 웹 프레임워크입니다. 이는 Model-View-Controller 아키텍처를 제공하여 응용 프로그램 로직을 모델, 뷰, 컨트롤러 세 가지 구성 요소로 분리합니다. Spring MVC 흐름은 다음 단계를 포함합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_12.png](/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_12.png)\n\n고객이 요청을 보냅니다: 사용자가 브라우저 또는 다른 클라이언트 응용 프로그램을 통해 Spring MVC 애플리케이션에 요청을 보냅니다.\n\nDispatcherServlet이 요청을 받습니다: DispatcherServlet은 Spring MVC 아키텍처의 중앙 컨트롤러입니다. 클라이언트로부터 요청을 받고 요청을 처리할 컨트롤러를 결정합니다.\n\nHandlerMapping이 적절한 컨트롤러를 선택합니다: HandlerMapping 구성 요소는 Spring 구성 파일에서 구성된 URL 패턴을 기반으로 요청 URL을 적절한 컨트롤러에 매핑합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨트롤러는 요청을 처리합니다: 컨트롤러는 요청을 처리하고 필요한 처리 로직을 수행합니다. 모델 구성 요소와 상호작용하여 데이터를 검색하거나 업데이트할 수 있습니다.\n\n모델은 데이터를 업데이트합니다: 모델 구성 요소는 데이터를 관리하고 컨트롤러가 데이터를 검색하거나 업데이트할 수 있는 인터페이스를 제공합니다.\n\n뷰 리졸버는 적절한 뷰를 선택합니다: 뷰 리졸버 구성 요소는 컨트롤러에서 반환된 논리적 뷰 이름을 실제 뷰 템플릿에 매핑합니다.\n\n뷰가 응답을 렌더링합니다: 뷰 템플릿이 렌더링되어 응답을 생성합니다. 모델 구성 요소에서 데이터를 포함할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDispatcherServlet은 응답을 보냅니다: DispatcherServlet은 JSP, HTML 또는 JSON과 같은 적절한 뷰 기술을 통해 응답을 클라이언트에 다시 보냅니다.\n\nSpring MVC 흐름은 순환적인 프로세스이며, 클라이언트가 애플리케이션으로 추가 요청을 보낼 수 있으며, 이 주기가 반복됩니다.\n\n# 가장 일반적인 Spring MVC 어노테이션은 무엇인가요?\n\n컨트롤러 어노테이션:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@Controller: 클래스를 컨트롤러로 지정하여 HTTP 요청을 처리하고 응답을 렌더링하는 역할을 담당합니다.\n\n@RestController: @Controller의 특수한 버전으로, 핸들러 메서드에 @ResponseBody를 암시적으로 추가하여 데이터를 직접 응답 본문에 쓰도록 지정합니다. 주로 JSON 또는 XML 형식으로 작성됩니다.\n\n요청 매핑 어노테이션:\n\n@RequestMapping: URL 패턴, HTTP 메서드(GET, POST, PUT, DELETE 등), 요청 매개변수 및 헤더에 기반하여 웹 요청을 특정 컨트롤러 메서드에 매핑합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping: 특정 HTTP 메서드에 매핑하는 편리한 바로 가기입니다.\n\n@PathVariable: URL의 경로 세그먼트 변수에 메서드 매개변수를 바인딩합니다.\n\n@RequestParam: 요청 URL의 쿼리 매개변수에 메서드 매개변수를 바인딩합니다.\n\n데이터 바인딩 어노테이션:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@ModelAttribute: 객체를 사용하여 모델 속성을 채워 뷰에서 사용할 수 있도록 합니다.\n\n@RequestParam: 요청 매개변수를 메서드 매개변수에 바인딩합니다.\n\n@RequestHeader: 요청 헤더를 메서드 매개변수에 바인딩합니다.\n\n@RequestBody: 요청 본문을 메서드 매개변수에 매핑하며 주로 JSON 또는 XML 데이터에 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n응답 처리 어노테이션:\n\n- **@ResponseBody**: 메서드의 반환 값이 뷰 해상도를 우회하고 직접 응답 본문에 작성되어야 함을 나타냅니다.\n\n- **@ResponseStatus**: 응답의 HTTP 상태 코드를 설정합니다.\n\n예외 처리 어노테이션:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@ExceptionHandler: 특정 유형의 예외를 처리하는 메서드를 정의하여 오류를 관리하는 중앙화된 방법을 제공합니다.\n\n다른 유용한 주석:\n\n- @SessionAttribute: 세션 속성에 액세스합니다.\n- @ModelAttribute: 컨트롤러의 모든 핸들러 메서드에 모델에 속성을 추가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n@InitBinder: 컨트롤러의 데이터 바인딩 및 유효성 검사를 사용자 정의합니다.\n\n@CrossOrigin: 컨트롤러나 특정 핸들러 메소드에 대해 교차 출처 요청을 활성화합니다.\n\n# 싱글톤 빈 범위가 여러 병렬 요청을 처리할 수 있을까요?\n\nSpring의 싱글톤 빈은 모든 요청 간에 공유되는 단일 인스턴스를 갖습니다. 즉, 두 요청이 동시에 처리되더라도 동일한 빈 인스턴스를 공유하며 빈의 상태에 대한 액세스가 요청 사이에서 공유됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 싱글톤 빈이 상태를 유지하고 있고 그 상태가 요청 사이에 공유된다면, 이는 경합 조건 및 기타 동시성 문제로 이어질 수 있다는 점을 유의해야 합니다. 예를 들어, 두 요청이 동시에 동일한 데이터를 수정하려고 할 때 데이터 불일치 문제가 발생할 수 있습니다.\n\n이러한 문제를 피하기 위해서는 상태를 유지하는 싱글톤 빈이 스레드 안전하게 설계되었는지 확인하는 것이 중요합니다. 이를 위해 동기화 또는 다른 동시성 제어 메커니즘을 활용할 수 있습니다. synchronized 키워드, Lock 또는 ReentrantLock 클래스, 또는 빈이 데이터베이스 작업을 수행하는 경우 @Transactional 어노테이션을 사용하는 것이 한 가지 방법입니다.\n\n반면에, 싱글톤 빈이 상태를 유지하지 않는 상태라면 여러 병렬 요청을 문제없이 처리할 수 있습니다. 빈의 상태에 의존하지 않는 공유 기능을 제공하는 데 사용될 수 있습니다.\n\n결론적으로, 싱글톤 빈은 여러 병렬 요청을 처리할 수 있지만, 빈의 상태를 인식하고, 공유 상태가 있는 경우 스레드 안전하게 설계되어 있는지 확인하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Spring Framework 내부에서 사용된 디자인 패턴에 대해 알려주세요.\n\nSpring Framework는 기능을 제공하기 위해 여러 디자인 패턴을 활용합니다. Spring에서 사용되는 주요 디자인 패턴 중 일부는 다음과 같습니다:\n\n- 제어의 역전 (IoC): 이 패턴은 Spring Framework 전반에서 사용되어 응용 프로그램 코드를 프레임워크와 그 구성 요소로부터 분리합니다. IoC 컨테이너는 빈의 라이프사이클을 관리하고 그들 사이의 의존성을 주입하는 역할을 합니다.\n\n- 싱글톤: Spring IoC 컨테이너 내에서 빈의 단일 인스턴스만 생성되도록 하기 위해 싱글톤 패턴이 사용됩니다. 싱글톤 패턴은 클래스의 단일 인스턴스를 생성하여 응용 프로그램 전체에서 공유하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Factory: 팩토리 패턴은 Spring에서 구성에 기반한 다른 클래스의 객체를 생성하는 데 사용됩니다. Spring은 빈을 생성하기 위한 팩토리 메소드 디자인 패턴을 기반으로 한 팩토리 패턴을 제공합니다.\n\n- Template Method: 템플릿 메소드 패턴은 Spring에서 다양한 유형의 작업에 대한 공통 구조를 제공하는 데 사용됩니다. Spring은 JdbcTemplate, Hibernate Template 등 공통 구조를 제공하는 여러 템플릿 클래스를 제공합니다.\n\n- Decorator: 데코레이터 패턴은 기존 빈에 추가 기능을 추가하는 데 Spring에서 사용됩니다. Spring AOP (Aspect-Oriented Programming) 모듈은 데코레이터 패턴을 사용하여 프록시를 통해 기존 빈에 추가 기능을 추가합니다.\n\n- Observer: 옵저버 패턴은 Spring에서 빈의 상태 변경을 다른 빈에 알리는 데 사용됩니다. Spring은 옵저버 패턴을 구현하는 데 사용할 수 있는 ApplicationEvent 및 ApplicationListener 인터페이스를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Command: 명령(Command) 패턴은 Spring에서 특정 코드 조각의 실행을 명령 객체(command object)에 캡슐화하는 데 사용됩니다. 이 패턴은 Spring에서 재사용 가능하고 테스트 가능한 코드를 생성하는 데 사용됩니다.\n\n- Facade: Facade(퍼사드) 패턴은 Spring에서 복잡한 시스템의 인터페이스를 간단하게 만드는 데 사용됩니다. Spring 프레임워크는 Facade 패턴을 사용하여 구성 요소와 상호 작용하는 간소화된 인터페이스를 제공합니다.\n\n이것들은 Spring에서 사용되는 디자인 패턴의 몇 가지 예일 뿐이며, 더 많이 있습니다. Spring 프레임워크는 이러한 패턴을 활용하여 일관된 간단한 방식으로 응용 프로그램을 구축할 수 있도록 하여, 복잡한 시스템을 관리하기 쉽게 합니다.\n\n# 스프링 프레임워크에서 공장(Factory) 디자인 패턴이 동작하는 방식은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n봄(Spring)에서는 구성에 따라 서로 다른 클래스의 객체를 생성하는 데 팩토리 디자인 패턴을 사용합니다. Spring IoC 컨테이너는 빈(beans)을 생성하기 위해 팩토리 패턴을 사용하는데, 이는 팩토리 메소드 디자인 패턴에 기반을 둡니다.\n\n팩토리 메소드는 팩토리 인터페이스를 기반으로 다른 클래스의 객체를 생성하는 방법을 제공하는 디자인 패턴입니다. Spring에서 IoC 컨테이너는 팩토리로 작용하며, 팩토리 인터페이스는 BeanFactory 또는 ApplicationContext 인터페이스로 표현됩니다.\n\nIoC 컨테이너는 빈을 생성하고 관리하는 역할을 담당합니다. 구성에서 빈을 정의할 때, IoC 컨테이너는 해당 빈의 인스턴스를 생성하기 위해 팩토리 패턴을 사용합니다. 그런 다음 IoC 컨테이너는 빈의 라이프사이클을 관리하며, 의존성 주입, 빈 초기화, 그리고 필요하지 않게 되면 빈을 소멸시킵니다.\n\n다음은 봄(Spring)에서 팩토리 디자인 패턴을 사용하여 빈을 정의하는 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@Configuration\npublic class MyConfig {\n@Bean\npublic MyService myService() {\nreturn new MyService();\n}\n}\n```\n\n이 예에서 myService() 메서드는 @Bean으로 주석이 달려 있습니다. 이는 Spring에게 IoC 컨테이너가 생성될 때 MyService 클래스의 인스턴스를 만들도록 지시합니다. IoC 컨테이너는 팩토리 패턴을 사용하여 인스턴스를 생성하고 수명주기를 관리합니다.\n\nSpring에서 프록시 디자인 패턴을 사용하는 또 다른 방법은 FactoryBean 인터페이스를 사용하는 것입니다. FactoryBean 인터페이스를 사용하면 팩토리 메서드에 의해 생성되는 bean을 생성할 수 있습니다. FactoryBean 인터페이스는 getObject()라는 하나의 메서드를 정의하며, 이 메서드는 Spring 애플리케이션 컨텍스트에서 빈으로 공개해야 하는 객체를 반환합니다.\n\nSpring에서 프록시 디자인 패턴을 사용하는 방법에 대해 궁금해 하셨군요! 해당 내용에 대해 설명 드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프록시 디자인 패턴은 기존 객체에 추가 기능을 제공하기 위해 Spring에서 사용됩니다. Spring 프레임워크는 AOP(관점 지향 프로그래밍) 기능을 제공하기 위해 프록시 패턴을 사용하여, 로깅, 보안, 트랜잭션 관리와 같은 교차 관심 사항을 응용 프로그램에 모듈식이고 재사용 가능한 방식으로 추가할 수 있습니다.\n\nSpring에서 AOP 프록시는 IoC 컨테이너에 의해 생성되며, 대상 빈에 대한 메서드 호출을 가로채도록 사용됩니다. 이를 통해 대상 빈으로의 메서드 호출 전 또는 후에 로깅이나 보안 검사와 같은 추가 동작을 추가할 수 있습니다.\n\nAOP 프록시는 JDK 동적 프록시, CGLIB 프록시 또는 AspectJ 프록시 중 하나의 프록시 유형을 사용하여 생성됩니다.\n\nJDK 동적 프록시: 이것은 Spring에서의 기본 프록시 유형이며, 인터페이스를 프록시화하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCGLIB 프록시: 이 프록시 유형은 클래스를 프록시함으로써 작동하며 대상 빈의 서브클래스를 생성함으로써 작동합니다.\n\nAspectJ 프록시: 이 프록시 유형은 AspectJ 라이브러리를 사용하여 프록시를 생성하며 애플리케이션에서 AspectJ 포인트컷 및 어드바이스를 사용할 수 있습니다.\n\nSpring은 AOP 기능을 제공하기 위해 프록시 패턴을 사용하여 대상 빈을 감싸는 프록시 객체를 생성합니다. 프록시 객체는 대상 빈으로 전달된 메서드 호출을 가로채고 대상 빈으로 메서드 호출이 이루어지기 전 또는 후에 추가 동작, 예를 들어 로깅이나 보안 확인을 호출합니다.\n\n다음은 Spring AOP를 사용하여 빈에 로깅을 추가하는 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n@Aspect\n@Component\npublic class LoggingAspect {\n@Before(\"execution(* com.example.service.*.*(..))\")\npublic void logBefore(JoinPoint joinPoint) {\nlog.info(\"Started method: \" + joinPoint.getSignature().getName());\n}\n}\n```\n\n이 예제에서 LoggingAspect 클래스는 @Aspect 및 @Component로 주석이 달려 있어 Spring 빈으로 만들어집니다. @Before 어노테이션이 사용되어 logBefore() 메서드가 대상 빈으로의 메서드 호출 전에 실행되어야 함을 지정합니다. logBefore() 메서드는 JoinPoint 인자를 사용하여 호출 중인 메서드의 이름을 기록합니다.\n\n# 싱글톤 빈을 프로토타입 빈에서 호출하거나 그 반대로 프로토타입 빈을 싱글톤 빈에서 호출하면 몇 개의 객체가 반환됩니까?\n\n싱글톤 빈이 프로토타입 빈 또는 그 반대로부터 호출될 때 동작은 의존성 주입 방식에 따라 다릅니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n싱글톤 빈이 프로토타입 빈에 주입되면, 프로토타입 빈이 생성될 때마다 싱글톤 빈의 동일한 인스턴스를 수신합니다. 이는 싱글톤 빈은 애플리케이션 컨텍스트 시작 시에 한 번만 생성되며, 이후에는 동일한 인스턴스가 프로토타입 빈에 주입되기 때문입니다.\n\n반면에, 프로토타입 빈이 싱글톤 빈에 주입되면, 싱글톤 빈이 호출될 때마다 새로운 프로토타입 빈 인스턴스가 생성됩니다. 이는 프로토타입 빈이 컨테이너에 의해 관리되지 않고, 의존성이 주입될 때마다 새 인스턴스가 생성되기 때문입니다.\n\n다음은 이를 설명하는 예시입니다:\n\n```java\n@Component\n@Scope(\"singleton\")\npublic class SingletonBean {\n// 싱글톤 빈 코드\n}\n@Component\n@Scope(\"prototype\")\npublic class PrototypeBean {\n@Autowired\nprivate SingletonBean singletonBean;\n// 프로토타입 빈 코드\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서 프로토타입 빈이 생성되고 싱글톤 빈과 주입되면 각 생성마다 같은 싱글톤 빈의 인스턴스를 받게 됩니다. 그러나 싱글톤 빈이 생성되고 프로토타입 빈과 주입되면 각 호출마다 새로운 프로토타입 빈의 인스턴스를 받게 됩니다.\n\n하나의 응용 프로그램 컨텍스트에서 싱글톤 및 프로토타입 스코프를 혼합하는 것은 예상치 못한 동작을 유발할 수 있으며 필요하지 않은 한 피하는 것이 좋습니다. 응용 프로그램 컨텍스트 전체에서 일관된 스코프를 사용하는 것이 가장 좋습니다.\n\n# 스프링 부트 대 스프링을 선택하는 이유는?\n\n다음은 스프링 프레임워크를 선택하는 몇 가지 이유입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 애플리케이션에 포괄적인 기능과 기능 세트가 필요합니다.\n- 필요한 컴포넌트만 선택하여 모듈식 애플리케이션을 구축하고 싶습니다.\n- 애플리케이션에서 높은 유연성과 사용자 정의가 필요합니다.\n\nSpring Boot를 선택해야 하는 몇 가지 이유가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 많은 구성을 하지 않고도 독립적인 Spring 애플리케이션을 빠르게 설정하고 싶을 때\n- 미리 구성된 종속성과 합리적인 기본값을 활용하고 싶을 때\n- 애플리케이션을 간편하게 자체 실행 가능한 실행 가능한 JAR 파일로 배포하고 싶을 때\n\n전체적으로 Spring과 Spring Boot은 기업 수준의 애플리케이션을 구축하는 데 사용할 수 있는 강력한 프레임워크입니다. 둘 사이의 선택은 애플리케이션의 특정 요구 사항과 필요한 유연성 및 사용자 정의 수준에 따라 다를 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Spring에서 RestTemplate이란 무엇인가요?\n\nRestTemplate은 Spring에서 외부 REST API로 HTTP 요청을 보내는 강력한 도구입니다. 이는 낮은 수준의 HTTP 세부 사항에 대한 고수준 추상화를 제공하여 클라이언트 측 통신을 간단화합니다. 외부 서비스와 상호 작용하기 위한 편리한 스위스 아미 나이프로 상상해보세요.\n\n주요 용도:\n\n- 외부 RESTful API에서 데이터 소비하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 내 애플리케이션 내부 마이크로서비스와 상호 작용하기\n- RESTful API 테스트하기\n- 외부 시스템과 사용자 정의 통합 구축하기\n\n간단히 말해서: RestTemplate은 Spring에서 HTTP 요청을 보내는 번거로움을 덜어주며, 애플리케이션을 외부 세계와 연결하는 편리하고 유연한 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 스프링과 스프링 부트에서 사용 가능한 모든 HTTP 클라이언트는 무엇인가요?\n\n다음은 사용 가능한 다양한 클라이언트들입니다:\n\n- RestTemplate\n- WebClient\n- HttpClient\n- RestClient\n- OkHttp\n\n# 스프링 REST에서 HttpMessageConverter란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTTP 요청과 응답을 Java 객체와 그에 해당하는 메시지 형식 (예: JSON, XML) 간의 변환을 처리하는 중요 인터페이스에요.\n\n이는 컨트롤러 계층과 메시지 페이로드 간의 다리 역할을 하며, 데이터 호환성을 보장해요.\n\n작동 방식:\n\n수신 요청 처리:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 요청이 도착하면 Spring은 요청의 Content-Type 헤더를 기반으로 적합한 HttpMessageConverter를 찾습니다.\n\n- 일치하는 항목을 찾으면 컨버터가 요청 본문을 읽고 컨트롤러가 처리할 수 있는 Java 객체로 변환합니다.\n\n응답 처리:\n\n- 컨트롤러가 객체를 반환할 때 Spring은 다시 요청의 Accept 헤더나 기본 변환기를 기반으로 적절한 HttpMessageConverter를 찾습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**테이블 태그를 Markdown 형식으로 변경해주세요.**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n- FormHttpMessageConverter (폼 데이터용)\n- ByteArrayHttpMessageConverter (바이너리 데이터용)\n- Jaxb2RootElementHttpMessageConverter (XML용, JAXB 사용)\n\n# Spring MVC를 사용하여 RESTful 웹 서비스를 소비하는 방법?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. RestTemplate 주입하기:\n\nRestTemplate 인스턴스를 가져와서 HTTP 요청을 하는 스프링의 중심 클래스입니다.\n\n의존성 주입을 사용하여 컨트롤러나 서비스 클래스에 주입하세요.\n\n2. HTTP 요청 만들기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 HTTP 작업에 RestTemplate 메서드를 사용해보세요:\n\ngetForObject(url, responseType): GET 요청에 대한 데이터를 가져옵니다.\n\npostForObject(url, requestBody, responseType): POST 요청에 데이터를 보냅니다.\n\nput(url, requestBody): PUT 요청을 사용하여 데이터를 업데이트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 응답 데이터 매핑:\n\nRestTemplate은 기대되는 응답 유형에 따라 응답 본문을 자동으로 Java 객체로 변환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@RestController\npublic class MyController {\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @GetMapping(\"/fetch-data\")\n    public User fetchUserData() {\n        String url = \"https://api.example.com/users/123\";\n        User user = restTemplate.getForObject(url, User.class);\n        return user;\n    }\n}\n```\n\n# Thanks for reading\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 👏 이야기에 박수를 보내주시고 저를 팔로우해주세요 👉\n- 📰 제 미디엄에서 더 많은 콘텐츠를 읽어보세요 (Java 개발자 인터뷰에 관한 50개의 이야기)\n\n여기서 제 책을 찾을 수 있어요:\n\n- Amazon에서 여기서 Guide To Clear Java Developer Interview(킨들북)와 Gumroad(PDF 형식)에서.\n- Gumroad(PDF 형식)에서와 Amazon(킨들 이북)에서 Guide To Clear Spring-Boot Microservice Interview.\n- 🔔 팔로우: LinkedIn | Twitter | Youtube\n","ogImage":{"url":"/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_0.png"},"coverImage":"/assets/img/2024-05-27-Top60Spring-FrameworkInterviewQuestionsforJavaDevelopers2024ContainAlltheQuestionsfromtheBook_0.png","tag":["Tech"],"readingTime":45},{"title":"모듈화된 단일 모놀리스의 보안을 OAuth2와 Spring Security로 확보하기","description":"","date":"2024-05-27 15:50","slug":"2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity","content":"\n\u003cimg src=\"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_0.png\" /\u003e\n\n제1부: Spring Boot 및 도메인 주도 설계를 사용하여 모듈식 단일체 응용 프로그램 구축\n\n제2부: Spring Modulith를 사용하여 모듈식 단일체 응용 프로그램 개선\n\n제3부: Hexagonal Architecture를 활용한 모듈식 단일체에서 도메인 중심 사고 채택\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모듈화된 모노리틱 코드베이스에서는 각 기능이 다른 모듈과 순환 종속성이 없는 모듈에 구현되어야 합니다. 그러나 보안과 같은 교차 관심사가 적용되어야 할 때, 보안 관련 코드는 어디에 배치해야 할까요? 각 모듈에 있어야 할까요? 아니면 별도의 모듈이어야 할까요? 함께 알아보겠습니다.\n\n이전 블로그에서 우리는 도서관 애플리케이션을 개발했습니다. 이 애플리케이션에서 사용자는 책을 대출할 수 있습니다. 그러나 보안이 없으면 어플리케이션을 사용하는 대여자를 식별할 방법이 없고 다른 사람이 대출한 책을 대출하는지 확신할 수 없습니다. 올바른 동작을 보장하기 위해 인증 및 권한 부여 규칙을 추가하려고 합니다. 우리는 애플리케이션을 보호하기 위해 OAuth2 프로토콜을 사용할 것입니다.\n\n## OAuth2 / OIDC 프로토콜\n\n코드 구조와 모듈 조직에 대한 토론에 앞서, OAuth2에 대한 간단한 개요부터 살펴보겠습니다. 이미 알고 계시다면 이 섹션을 건너뛰어도 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOAuth2를 이해할 수 있는 많은 훌륭한 리소스들이 있기 때문에 여기에서는 세부적인 내용을 다루지 않겠습니다. 대신 OAuth2를 활용한 솔루션을 설계하는 방법에 대해 이야기하려고 합니다.\n\nOAuth2로 해야 할 세 가지 중요한 사항은 \"인가 서버(Authorization Server)\", \"리소스 서버(Resource Server)\", 그리고 \"클라이언트(Client)\"입니다. 클라이언트는 일반적으로 웹 애플리케이션의 UI로 사용되지만 Terraform 제공자나 자동화를 위한 CI/CD 파이프라인, 그리고 테스트를 위한 Postman이나 Insomnia일 수도 있습니다. 리소스 서버는 리소스를 제공하는 백엔드 API를 나타냅니다. 우리의 경우에는 이를 \"도서관 어플리케이션\"으로 정의할 수 있습니다. 중요한 점은 리소스 서버가 사용자의 인증 및 관리 책임이 없다는 것입니다. 이 역할을 하는 것은 인가 서버입니다.\n\nOAuth2 솔루션을 구축할 때 가장 중요한 구성 요소는 인가 서버입니다. 사용자 관리 및 사용자 자격 증명을 보관하는 역할을 합니다. 인가 서버를 선택하는 것은 중요한 결정입니다. SaaS를 구축 중이라면 Auth0나 Okta와 같은 SaaS 솔루션을 선택할 수 있습니다. 자체 호스팅(또는 온프레미스)해야 하는 경우 Keycloak을 선택할 수 있습니다. 또는 Spring Authorization Server를 사용하여 직접 구축할 수도 있지만, 거의 항상 좋은 아이디어는 아닙니다. 우리의 구현에는 Keycloak을 선택할 것입니다.\n\nUI가 없는 경우, 이 흐름을 사용하여 API를 테스트할 수 있습니다: 클라이언트(Postman이나 Insomnia)는 사용자를 인증하고 액세스 토큰을 획득하기 위해 인가 서버(Keycloak)를 호출합니다. 이 액세스 토큰을 사용하면 클라이언트가 리소스 서버(도서관 어플리케이션)의 데이터에 액세스할 수 있습니다. 이는 Authorization Code Flow로도 알려져 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 스프링 시큐리티를 사용한 OAuth2\n\n이제 우리 애플리케이션이 OAuth2 플로우에서 리소스 서버로 작동한다는 것을 이해했으니, pom.xml에 관련 의존성을 포함해야 합니다.\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n  \u003cartifactId\u003espring-boot-starter-security\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.security\u003c/groupId\u003e\n  \u003cartifactId\u003espring-security-oauth2-resource-server\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\u003c!-- JWT를 다루기 위한 의존성 --\u003e\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.security\u003c/groupId\u003e\n  \u003cartifactId\u003espring-security-oauth2-jose\u003c/artifactId\u003e\n\u003c/dependency\u003e\n```\n\n그 다음으로, OAuth2 리소스 서버를 활성화 하기 위해 스프링 시큐리티를 구성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n@Configuration\n@EnableMethodSecurity\npublic class LibraryWebSecurityConfiguration {\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity security) throws Exception {\n\n        return security\n                .authorizeHttpRequests(http -\u003e http\n                        .requestMatchers(\"/swagger-ui/**\", \"/v3/api-docs/**\").permitAll()\n                        .anyRequest().authenticated())\n                .oauth2ResourceServer(oauth2 -\u003e\n                        oauth2.jwt(jwtConfigurer -\u003e\n                                jwtConfigurer.jwtAuthenticationConverter(new KeycloakJwtAuthenticationConverter())\n                        )\n                ).build();\n    }\n}\n```\n\n`oauth2.jwt()` 함수는 액세스 토큰에 대한 Json Web Tokens (JWT) 사용을 나타냅니다. 이를 통해 사용자의 역할을 액세스 토큰에서 Spring Security의 내부 Granted Authorities로 추출하는 사용자 정의 컨버터를 사용합니다.\n\n또한 우리는 리소스 서버가 JWT 토큰을 특정 인가 서버로 유효성 검사하도록 설정해야 합니다. 이는 application.yaml 파일에서 구성할 수 있습니다.\n\n```yaml\nspring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          issuer-uri: http://localhost:8083/realms/library\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 보안을 위한 새로운 모듈\n\n\u003cimg src=\"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_1.png\" /\u003e\n\n보안과 관련된 클래스를 관리하기 위해 User Account라는 새 모듈을 소개하려고 합니다. 이 모듈에는 UserAccount라는 인증된 사용자를 나타내는 도메인 모델이 포함될 것입니다. 다른 모듈들은 UserAccount를 참조하여 자신만의 내부 표현에 매핑할 수 있습니다. Borrow 모듈에는 Patron이, Catalog 모듈에는 Staff가 될 것입니다.\n\n```js\n.\n└── example/\n    ├── borrow\n    ├── catalog\n    ├── useraccount/\n    │   ├── web/\n    │   │   ├── Authenticated.java\n    │   │   └── AuthenticatedUserArgumentResolver.java\n    │   ├── KeycloakJwtAuthenticationConverter.java\n    │   └── UserAccount.java\n    └── LibraryWebSecurityConfiguration.java\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대출 및 카탈로그 모듈은 현재 인증된 사용자의 세부 정보를 가져와 관련 도메인 모델과 매핑하는 데 사용자 계정 모듈을 사용합니다. 새로운 기능을 위한 미래 모듈도 해당 모듈을 사용할 가능성이 높습니다. 이는 사용자 계정 모듈을 공유 모듈로 만들어줍니다. Spring Modulith는 모듈을 공유로 지정할 수 있는 방법을 제공합니다.\n\nMarkdown 형식의 테이블로 변환하면 다음과 같습니다.\n\n\n| 모듈 | 설명 |\n| ----- | -----|\n| 대출 | 사용자 계정 모듈을 사용하여 현재 승인된 사용자의 세부 정보를 가져옵니다. |\n| 카탈로그 | 사용자 계정 모듈을 사용하여 현재 승인된 사용자의 세부 정보를 가져옵니다. |\n\n\n@SpringBoot 애플리케이션 클래스에 @Modulithic 어노테이션을 설정하고 공유 모듈을 정의할 수 있습니다. 이렇게 하면 Spring Modulith가 항상 사용자 계정 모듈을 부트스트랩하도록 할 수 있습니다.\n\n## 모듈에서 인증된 사용자 식별하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인증된 사용자는 UserAccount 레코드로 모델링됩니다. 사용자 세부 정보를 영속화할 필요가 없기 때문에 이를 집계로 정의하지 않습니다. 사용자, 역할 및 자격 증명의 참 소스는 Keycloak입니다.\n\n```js\n/**\n * 사용자 계정을 나타내는 모델입니다.\n * 아직 필요가 없기 때문에 집계로 이동되지 않았습니다.\n */\npublic record UserAccount(String firstName,\n                          String lastName,\n                          String email,\n                          List\u003cString\u003e roles) {}\n```\n\n대출 모듈에서 홀드를 배치할 때, 인증된 사용자를 알아야 하며, 컨트롤러의 Patron 모델과 매핑해야 합니다. 이 작업은 사용자 정의 어노테이션 @Authenticated로 수행됩니다. 사용자 지정 HandlerMethodArgumentResolver를 사용하여 컨트롤러 메서드에 자동으로 UserAccount를 주입할 수 있습니다.\n\n```js\n@PostMapping(\"/borrow/holds\")\nResponseEntity\u003cHoldDto\u003e holdBook(@RequestBody HoldRequest request, @Authenticated UserAccount userAccount) {\n    var command = new Hold.PlaceHold(new Book.Barcode(request.barcode()), LocalDate.now(), new PatronId(userAccount.email()));\n    var holdDto = circulationDesk.placeHold(command);\n    return ResponseEntity.ok(holdDto);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자 계정은 새로운 PatronId(userAccount.email())와 매핑되어 있습니다. CirculationDesk 서비스는 인증 방식에 대한 지식 없이 특정 Patron만을 다룹니다.\n\n## 권한 부여 대 비즈니스 규칙\n\n새로운 두 가지 비즈니스 요구 사항이 있습니다:\n\n- 도서관 직원만이 카달로그에 새 책을 추가할 수 있습니다.\n- 다른 회원이 대출한 책을 대출할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 요구 사항을 도메인 모델에 매핑해 봅시다. 현재 Library Staff 구성원에 대한 모델이 없습니다. 이를 ROLE_STAFF 역할을 갖는 인증된 사용자로 정의할 수 있습니다. 두 번째 요구 사항은 이미 있는 도메인 모델인 Patron으로 모델에 변경이 필요하지 않습니다.\n\n첫 번째 요구 사항은 RBAC(Role-Based Access Control)의 간단한 경우입니다. Spring Security의 Method Security @PreAuthorize 주석을 사용하여 구현할 수 있습니다.\n\n```java\n@PreAuthorize(\"hasRole('STAFF')\")\n@PostMapping(\"/catalog/books\")\nResponseEntity\u003cBookDto\u003e addBookToInventory(@RequestBody AddBookRequest request) {\n    var bookDto = books.addToCatalog(request.title(), new Barcode(request.catalogNumber()), request.isbn(), request.author());\n    return ResponseEntity.ok(bookDto);\n}\n```\n\n사용자의 역할은 JWT 토큰에서 식별됩니다. 역할이 어느 클레임에서 사용 가능할지는 인가 서버가 결정합니다. 저희의 경우 Keycloak에서는 realm*access.roles[] 클레임에서 역할을 사용할 수 있습니다. Spring Security가 역할로 인식하려면 역할에는 기본적으로 ROLE* 접두사가 있어야 하지만, GrantedAuthorityDefaults를 사용하여 변경할 수도 있습니다. 토큰 처리 중에 각 역할을 GrantedAuthority로 변환합니다. Authorization 결정을 내릴 때 AccessDecisionManager에 의해 이러한 권한이 읽힙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 요구 사항이 더 흥미롭습니다. 권한 규칙인지 비즈니스 규칙인지 어떻게 판단해야 할까요? 리소스에 대한 액세스를 설명하고 있기 때문에 권한 규칙으로 보이지만, 반대로 도메인의 기능을 설명하고 있기 때문에 비즈니스 규칙으로도 볼 수 있습니다. 그렇다면 이를 어떻게 구현해야 할까요?\n\n권한 규칙으로써 요구 사항을 구현할 수 없는 이유는 해당 도메인 모델의 속성을 확인해야하기 때문입니다. 이 경우, Hold 객체가 올바른 Patron에 의해 보유되어 있는지 확인해야 합니다. 따라서 RBAC(Role-Based Access Control) 대신 ABAC(Attributed-Based Access Control)이 필요합니다. Spring Security에는 ABAC을 내장 지원하지 않으므로 직접 구현해야 합니다.\n\n반면, 이 요구 사항을 도메인의 비즈니스 제약 조건으로 처리한다면 도메인 모델이나 서비스에서 확인할 수 있습니다. ABAC보다 간단한 해결책을 택하는 경우, 비즈니스 규칙 확인을 선택하겠습니다.\n\n```js\npublic CheckoutDto checkout(Hold.Checkout command) {\n\n    var hold = holds.findById(command.holdId())\n            .orElseThrow(() -\u003e new IllegalArgumentException(\"Hold not found!\"));\n\n    if (!hold.isHeldBy(command.patronId())) {\n        throw new IllegalArgumentException(\"Hold belongs to a different patron\");\n    }\n\n    return CheckoutDto.from(\n            hold.checkout(command)\n                    .then(holds.save)\n                    .then(eventPublisher.bookCheckedOut)\n    );\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인증 규칙이 복잡해지면 비즈니스 규칙과 중첩될 수 있습니다. 일반적으로 인가 규칙은 \"누가 무엇에 액세스할 수 있는지\"에 관심이 있으며, 비즈니스 규칙은 \"시스템 및 도메인의 동작\"에 관심이 있습니다. 인가 주변에 복잡한 규칙이 많다면, 모든 정책을 한 곳에 모아 쉽게 관리할 수 있는 ABAC 솔루션을 구축하는 것이 좋은 아이디어일 수 있습니다.\n\n## 인증 플로우 트리거\n\nUI가 없으므로 Insomnia(REST 클라이언트)를 사용하여 라이브러리 애플리케이션 및 OAuth2로의 인증을 테스트할 것입니다. 그러나 먼저 애플리케이션을 시작해야 합니다. 이 작업은 docker compose를 사용하여 쉽게 할 수 있습니다.\n\n애플리케이션의 최신 코드는 여기에서 확인할 수 있습니다: https://github.com/xsreality/spring-modulith-with-ddd/tree/part-4-authentication. 로컬에서 코드를 확인하고 mvn spring-boot:build-image를 실행하여 애플리케이션의 로컬 도커 이미지를 빌드해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 컴포즈를 실행하여 Keycloak과 애플리케이션을 시작하세요. 이 Keycloak은 realm이라는 이름의 렘을 미리 구성했으며 ROLE_STAFF 역할 및 두 사용자인 john.wick@continental.com 및 winston@continental.com을 정의했습니다. Winston은 도서관 직원입니다. 두 계정의 암호는 \"password\"입니다.\n\n우리의 realm 라이브러리에 대한 인가 서버 메타데이터는 http://localhost:8083/realms/library/.well-known/openid-configuration에서 확인할 수 있습니다. authorization_endpoint 및 token_endpoint와 같은 두 엔드포인트가 필요한 Authorization Code 플로우가 있습니다.\n\n![이미지](/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_2.png)\n\n다음으로 Insomnia를 설정하여 OAuth2 플로우를 트리거합니다. 아래 스크린샷에 따라 설정을 선택하고 토큰을 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_3.png\" /\u003e\n\n인증 코드 플로우로 인해 Insomnia가 Keycloak의 로그인 페이지로 리디렉트됩니다. 자격 증명을 입력하고 코드를 엑세스 토큰으로 교환하려면 로그인하세요. 이 토큰은 그런 다음 자원 서버를 Bearer 토큰으로 호출하는 데 사용됩니다. Spring Security는 토큰을 디코딩하고 Keycloak에서 서명을 유효성 검사하고 iss 클레임을 유효성 검사하며 역할을 권한으로 매핑하는 데 신경 씁니다.\n\n## OAuth2의 통합 테스트\n\nSpring Security OAuth2 플로우를 JWT로 통합 테스트하는 아이디어는 전체 OAuth 플로우를 건너뛰고(결국 복잡하기 때문에 서명을 유효성 검사하는 것이 테스트의 중점이 아님) 대신 목킷 JWT를 사용하여 인증 후의 비즈니스 로직을 테스트하는 것입니다. 권한 관점에서는 유효한 인증된 사용자가 나타나므로 권한 규칙을 테스트하기가 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 요구 사항을 테스트해 보겠습니다. 카탈로그에 책을 추가하는 테스트를 하려면 역할 ROLE_STAFF가 포함된 JWT 토큰이 필요합니다.\n\n먼저 mockMvc 객체를 Spring Security를 사용하도록 구성해야 합니다.\n\n```js\n@BeforeEach\nvoid setUp() {\n    this.mockMvc = MockMvcBuilders.webAppContextSetup(context)\n            .apply(springSecurity())\n            .build();\n}\n```\n\n역할 ROLE_STAFF를 가진 인증된 사용자를 시뮬레이션하기 위해 권한을 포함한 가짜 JWT 토큰을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n@Test\nvoid addBookToCatalogSucceedsWithStaff() throws Exception {\n    mockMvc.perform(post(\"/catalog/books\")\n                    .with(jwt().authorities(new SimpleGrantedAuthority(\"ROLE_STAFF\")))\n                    .contentType(MediaType.APPLICATION_JSON)\n                    .content(\"\"\"\n                            {\n                              \"title\": \"Sapiens\",\n                              \"catalogNumber\": \"12345\",\n                              \"isbn\": \"9780062316097\",\n                              \"author\": \"Yuval Noah Harari\"\n                            }\n                            \"\"\"))\n            .andExpect(status().isOk())\n            .andExpect(jsonPath(\"$.id\").exists())\n            .andExpect(jsonPath(\"$.catalogNumber.barcode\", equalTo(\"12345\")))\n            .andExpect(jsonPath(\"$.isbn\", equalTo(\"9780062316097\"))\n            .andExpect(jsonPath(\"$.author.name\", equalTo(\"Yuval Noah Harari\"));\n\n\n만약 역할이 없는 경우 403 Access Denied 응답이 반환되며, 헤더에는 WWW-Authenticate:\"Bearer error=\"insufficient_scope\", error_description=\"The request requires higher privileges than provided by the access token.\", error_uri=\"https://tools.ietf.org/html/rfc6750#section-3.1\"\"가 포함됩니다.\n\n두 번째 요구 사항에서는 대출 모듈은 인증된 사용자의 이메일 주소에서 Patron을 식별합니다. 따라서 가짜 JWT 토큰에는 이메일 클레임이 필요합니다. 이 작업은 쉽게 할 수 있습니다.\n\n\n@Test\nvoid checkoutBookRestCall() throws Exception {\n    mockMvc.perform(post(\"/borrow/holds/018dc74a-4830-75cf-a194-5e9815727b02/checkout\")\n                    .with(jwt().jwt(jwt -\u003e jwt.claim(\"email\", \"john.wick@continental.com\"))))\n            .andExpect(jsonPath(\"$.holdId\", equalTo(\"018dc74a-4830-75cf-a194-5e9815727b02\"))\n            .andExpect(jsonPath(\"$.patronId\", equalTo(\"john.wick@continental.com\"))\n            .andExpect(jsonPath(\"$.dateOfCheckout\").exists());\n}\n\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 발급자 URI 대 JWK Set URI\n\nOAuth2 사양의 주요 요구 사항 중 하나는 권한 부여 서버의 발급자 URI(Authorization Server Metadata 응답의 발급자)와 토큰의 발급자 클레임(iss 클레임)이 일치해야 한다는 것입니다. application.yaml에 발급자 URI가 구성되어 있는 경우, Spring Security가 Authorization Server Metadata를 호출하고 JWK Set URI를 포함한 여러 URL을 찾습니다. 이 URI는 토큰의 서명을 확인하기 위한 공개 서명 키를 반환합니다.\n\n이 흐름의 문제는 리소스 서버가 외부 사용자용 URL에서 권한 부여 서버에 연락해야 한다는 것입니다. 이러한 서버가 API 게이트웨이 또는 역방향 프록시 뒤에 있으면 요청이 게이트웨이에 전송되고 다시 돌아와야 하므로 비효율적입니다.\n\n이 문제를 해결하는 한 가지 방법은 application.yaml 대신 JWK Set URI를 직접 구성하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nspring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          jwk-set-uri: http://keycloak:8080/realms/library/protocol/openid-connect/certs\n```\n\n이 설정은 Spring Security가 인증 서버 메타데이터를 호출하는 것을 건너뛰고 토큰의 서명을 확인하기 위해 JWK Set URI를 직접 호출하도록 만듭니다. API 게이트웨이 뒤에서 JWK Set URI는 통신용으로만 사용되기 때문에 내부 URL일 수 있습니다.\n\n## 결론\n\nSpring Security에 대해 더 말할 수 있는 부분이 많이 있습니다. 그러나 이 블로그에서는 Spring Security 관련 코드가 모듈식 모놀리스 코드베이스에 어떻게 들어 맞는지 살펴보았습니다. 또한 Spring Security를 사용하여 OAuth2 플로우를 구현하고 설정을 통합 테스트했습니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 코드를 확인하고 실행해보고 싶다면 아래를 확인해보세요.\n\n","ogImage":{"url":"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_0.png"},"coverImage":"/assets/img/2024-05-27-SecuringModularMonolithwithOAuth2andSpringSecurity_0.png","tag":["Tech"],"readingTime":14},{"title":"자바에서의 가비지 컬렉션","description":"","date":"2024-05-27 15:48","slug":"2024-05-27-GarbageCollectionInJava","content":"\n\n## 자바에서 쓰레기 수거가 이뤄지는 방식에 대한 기본적인 설명\n\n![이미지](/assets/img/2024-05-27-GarbageCollectionInJava_0.png)\n\n# 가비지 컬렉션이란?\n\n변수를 선언하는 것은 프로그래머로서 생활의 일부입니다. 변수를 사용하는 것은 코드의 재사용성을 향상시키는 것뿐만 아니라 코드의 가독성을 크게 향상시키고, 이는 결국 코드의 유지보수성을 높이는 데 큰 도움이 됩니다. 또한 선언된 변수가 일정 공간을 차지하고 특정 범위와 연결되어 있다는 것은 비밀이 아닙니다. 최적화된 메모리 관리를 위해 JVM이 이러한 객체들이 더 이상 필요하지 않을 때 제거하거나 파괴하는 것이 합리적입니다. 이렇게 \"원치 않는\" 변수들을 제거하는 프로세스를 가비지 컬렉션이라고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 자바에서의 가비지 컬렉션\n\nC, C++와 같은 언어에서는 가비지 컬렉션을 애플리케이션 개발자의 책임으로 간주됩니다. 이러한 언어에서는 쓰레기를 수동으로 처리하는 명시적 도구가 있습니다. 반면에 Java에서는 JVM이 가비지 컬렉션을 자동으로 처리합니다. JVM은 힙 메모리에서 언제 어디서 GC를 트리거할지 결정하는 일련의 프로세스를 거칩니다. 자바 개발자로서, 가비지 컬렉션의 기본 원리와 힙 메모리의 섹션을 이해하는 것이 매우 중요합니다. 이는 우리가 메모리를 효율적으로 사용하는 자바 애플리케이션을 개발하는 데 큰 도움이 될 것입니다.\n\n## 가비지 컬렉션에 포함된 단계\n\n자바 가비지 컬렉션은 일반적으로 2단계로 수행됩니다. 마크 단계와 스윕 단계입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크 단계: 마크 단계에서는 객체를 참조될 수 있는지 여부에 따라 두 가지 방식으로 분류합니다. 참조된 객체는 여전히 사용 중이며 범위에서 벗어나지 않은 객체입니다. 참조되지 않은 객체는 응용 프로그램에서 더 이상 필요하지 않은 객체입니다. 참조되지 않는 객체는 가비지 수집을 위해 \"표시\"됩니다.\n\n스윕 단계: 스윕 단계에서는 \"표시\"된 객체가 삭제되거나 지워집니다. 게다가 때로는 힙(heap)에서 메모리 압축(Mark-compact 알고리즘)이라고 하는 작업도 초기화됩니다. 이 과정을 통해 남아 있는 객체가 연속된 메모리에 남아 있도록 메모리가 다시 할당됩니다. 이 과정을 통해 JVM이 새로 생성된 객체에 순차적으로 메모리를 할당할 수 있습니다. 메모리 압축 프로세스의 세부 내용은 이 글의 범위를 벗어나므로 생략하겠습니다.\n\n효율적인 가비지 수집을 유지하기 위해 JVM이 따르는 일부 가비지 수집 전략이 있습니다. 가장 흔한 전략은 세대별 가비지 수집 전략입니다.\n\n## 세대별 가비지 수집 전략\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 일반적으로 사용되는 가장 흔한 가비지 컬렉션 형태인 세대별 가비지 컬렉션 전략을 탐구해 볼 거에요. 세대별 가비지 컬렉션은 주로 2가지 주된 이유로 선호됩니다.\n\n- 메모리에 할당된 객체가 더 많아질수록 표시, 정리, 그리고 압축 과정이 굉장히 비효율적해집니다. 이는 표시, 정리, 그리고 압축하는 데 소요되는 시간을 증가시키고 극도로 큰 GC 시간을 야기할 수 있습니다.\n- 분석 결과 자바 애플리케이션의 대부분 객체가 수명이 짧다는 것을 입증하였습니다.\n\n위에서 언급된 이유들 때문에, GC 프로세스를 더 효율적으로 만들기 위해 자바의 힙 메모리는 세그먼트 또는 세대로 분할됩니다.\n\n![가비지컬렉션](/assets/img/2024-05-27-GarbageCollectionInJava_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n젊은 세대:\n\n젊은 세대는 세 지역으로 나뉩니다. 에덴 공간, 생존자 공간 제로(S0) 및 생존자 공간 원(S1). 우리는 응용 프로그램 부팅 시 가비지 컬렉션 프로세스를 논의해 보겠습니다.\n\n처음에는 생성된 모든 객체가 에덴 공간에 채워집니다. 생존자 공간(S0 및 S1)은 모두 비어 있을 것입니다. 에덴 공간이 가득 차면 소규모 가비지 컬렉션 주기가 트리거됩니다. 에덴 공간의 모든 참조되지 않은 객체가 삭제되고 모든 참조된 객체가 S0로 이동됩니다. 이것이 gc(0)입니다. 이어지는 가비지 컬렉션 주기에서 에덴 공간 및 S0 공간의 모든 참조된 객체가 S1로 이동됩니다. 이후 모든 참조되지 않은 객체가 삭제됩니다. gc(1) 이후의 객체 할당은 다음과 같이 보일 것입니다.\n\n![image](/assets/img/2024-05-27-GarbageCollectionInJava_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 이미지에서 볼 수 있듯이 모든 GC 주기마다 객체의 나이가 1씩 증가합니다. 나이가 특정 임계값에 도달하면 객체들은 힙 메모리의 다음 섹션으로 이동됩니다. 또한 모든 마이너 GC는 Stop the world 이벤트입니다. 이는 응용 프로그램 스레드가 GC가 완료될 때까지 중지된다는 것을 의미합니다. 일반적으로 마이너 GC는 메이저 GC와 비교했을 때 소요 시간이 더 적습니다.\n\n늙은 세대\n\n결국 객체의 연령이 특정 임계값에 도달하면 젊은 세대에서늙은 세대로 이동됩니다. 언젠가는 오래된 세대도 채워집니다. 오래된 세대가 가득 차고 정리되어야 할 때 메이저 GC가 트리거됩니다.\n\n메이저 GC와 마이너 GC의 차이점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMinor GC와 Major GC의 주요 차이 중 하나는 Minor GC와 Major GC가 완료되는 데 걸리는 시간입니다. Major GC는 Minor GC와 마찬가지로 멈춤 현상(stop the world) 이벤트이지만 Major GC를 완료하는 데 걸리는 시간은 모든 활성 객체를 포함하기 때문에 Minor GC보다 훨씬 많이 소요됩니다. Major GC를 완료하는 데 필요한 시간은 주요 GC 공간이 증가할수록 선형적으로 증가하며 공간이 많을수록 메모리 압축에 더 많은 시간이 소요됩니다. 이는 응답 시간을 우선시하는 응용 프로그램에서 주요 GC의 빈도를 낮게 유지해야 한다는 것을 의미합니다. 또한 주요 GC의 멈춤 현상 이벤트의 길이는 사용 중인 GC 유형에 따라 달라집니다.\n\n**Full GC**\n\n자바 가비지 컬렉션에서 Full GC란 young generation과 old generation GC가 모두 트리거되는 경우입니다. full garbage collection은 Minor GC나 Major GC보다 훨씬 더 많은 시간이 소요됩니다. Full GC가 발생하는 이유는 여러 가지가 있을 수 있습니다. 그 중 몇 가지 이유는 다음과 같습니다:\n\n- Heap 공간이 가득 차는 경우: 모든 Java 힙 메모리가 고갈되기 전에 Full GC가 발생할 수 있습니다. 이는 일련의 영역을 연속으로 찾아야 하는 필요로 인해 발생할 수 있습니다.\n- 영역 크기 변경: 메모리 수요에 따라 영역 크기(영구 또는 올드)가 변경되면 일반적으로 Full GC에 의해 영역 변경 크기가 시작됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Metaspace\n\n힙 메모리의 일부였고 전체 가비지 수집에 포함되었던 추가 메모리 세그먼트가 있습니다. 이 메모리 세그먼트를 영구 세대(Permanent generation)라고 했습니다. Java 8에서 영구 세대는 Metaspace로 변경되었으며 힙 메모리에서 분리되었습니다. Metaspace의 주요 이유는 클래스 메타데이터를 저장하는 것입니다. 클래스가 더 많은 공간을로드하고 메타데이터를 저장해야 할 경우 Metaspace는 자동으로 증가하는 기능을 갖추고 있습니다.\n\nJava 가비지 컬렉션을 이해하는 것은 자바 애플리케이션을 보다 효율적으로 만들기 위해 매우 중요하며 시스템에서 잠재적인 메모리 누수를 해결하고 문제 해결하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-05-27-GarbageCollectionInJava_0.png"},"coverImage":"/assets/img/2024-05-27-GarbageCollectionInJava_0.png","tag":["Tech"],"readingTime":4},{"title":"WhatsApp의 감시 소프트웨어 거물에 대한 승리 페가수스의 격퇴","description":"","date":"2024-05-23 18:55","slug":"2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus","content":"\n\nWhatsApp은 Meta가 소유한 메신저 앱으로, 매우 강력한 감청 소프트웨어를 만드는 이스라엘 회사인 NSO 그룹에 대한 주요 법적 싸움에서 승리했습니다. 미국 판사는 NSO 그룹에게 Pegasus, 그들의 가장 유명한 감청 소프트웨어뿐만 아니라 다른 감시 도구들의 코드를 WhatsApp에 전달하도록 명령했습니다. WhatsApp은 2019년 NSO의 감청 소프트웨어가 사용되어 1,400명의 사용자를 감시했다는 사실을 발견한 이후 제기한 소송의 일환입니다.\n\nPegasus는 모든 전화로 침투하고 소유자의 동의 없이 통화, 이메일, 사진, 위치 및 개인 메시지에 접근할 수 있는 도구입니다. NSO 그룹은 이 소프트웨어를 주로 정부에 판매하고 있으며, 이는 여러 국가에서 활동가, 기자 및 기타 사람들을 대상으로 사용되었습니다. NSO는 제품이 범죄를 bek이하고 국가 안보를 보호하는 데 사용된다고 주장했지만, 그 사용은 심각한 개인정보와 인권 우려를 불러일으켰습니다.\n\n판사의 결정은 NSO 그룹이 WhatsApp과 감청 소프트웨어가 어떻게 작동하는지에 대한 세부 정보를 공유해야 하지만 고객을 공개하거나 서버에 대한 구체적인 정보를 공개할 필요는 없다는 것을 의미합니다. 이 판결은 WhatsApp이 불법 감시로부터 사용자들을 보호하는 데 큰 도약이 될 것으로 보입니다. 이스라엘 정부에 의해 엄격히 규제되고, 바이든 행정부에 의해 미국 국가안보에 위협으로 지목된 NSO 그룹은 이 법정 결정에 대해 의견을 제시하지 않았습니다. 이 사안은 아직 진행 중입니다.\n\n![WhatsApp의 스파이웨어 거인 NSO 그룹 격파 - 2024년 5월 23일](/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 배경 및 관련 당사자\n\n이 분쟁은 WhatsApp Inc.와 Facebook Inc. (원고)가 NSO Group Technologies Limited (피고)에 대한 소송으로, 불법 접근 및 스파이웨어 유포에 관한 주장에 초점을 맞추고 있습니다. Facebook 소유의 메시징 서비스 인 WhatsApp은 이스라엘 기술 기업인 NSO Group이 특정 WhatsApp 사용자를 감시하기 위해 악성 소프트웨어를 유포하는 것을 비난합니다.\n\n본 사건은 디지털 개인 정보 보호, 사이버 보안 및 권한 없이 개인에 대해 사용되는 정부 감시 기술의 함의에 대한 매우 중요한 우려 사안을 제기합니다. 이는 전세계적인 디지털 통신에서 이러한 기술의 사용을 어떻게 대처하고 잠재적으로 규제해야 하는 법적 구조에 대한 중요한 선례를 제공합니다.\n\n# 법적 주장 및 주장들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWhatsApp과 Facebook이 NSO 그룹에게 WhatsApp 플랫폼을 불법적으로 사용하여 스파이웨어를 배포했다는 주장을 중심으로 한 법적 주장 및 항의가 돌아가고 있습니다. 이 주장들은 다음과 같습니다:\n\n- Computer Fraud and Abuse Act (CFAA)의 위반. 연방 법률인 이 법은 컴퓨터 및 네트워크에 대한 무단 접근을 금지하며, NSO 그룹이 허가 없이 WhatsApp 서버에 접근하여 스파이웨어를 주입했다는 것을 시사합니다.\n- 캘리포니아의 Comprehensive Computer Access and Fraud Act. CFAA와 유사하지만 주의 수준에서, 이 법은 캘리포니아 내에서의 무단 컴퓨터 접근 및 데이터 도용을 대상으로 하며, WhatsApp은 NSO 그룹의 행동이 무단 접근 및 사용에 속한다고 주장합니다.\n- 계약 위반. WhatsApp은 NSO Group가 WhatsApp의 이용 약관을 위반했다고 주장하며, 해당 약관은 플랫폼의 오용을 엄격히 금지하고 악성 소프트웨어 사용을 포함합니다.\n- Chattels 침입. 이 공통 법적 책임은 타인의 개인 재산 소유를 방해하는 것을 포함합니다. WhatsApp은 NSO의 스파이웨어가 개인 정보를 침해하는 뿐만 아니라 자체 소프트웨어 및 사용자 장치에 영향을 미쳐 chattels 침입에 해당한다고 주장합니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_1.png\" /\u003e\n\n# Richmark 요인 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리치마크 팩터(Richmark Corp. v. Timber Falling Consultants (1991))에 대한 분석은 법원 판결에서 특히 외국 법률이나 당사자가 관련된 경우에 어떤 발견 요청이 강제적으로 이루어져야 하는지를 평가하는 방법론적 접근을 포함합니다. 다음은 이 접근 방식에 대한 요약입니다:\n\n- 정보의 중요성. 법원은 우선 요청된 문서 또는 정보가 조사 또는 소송에 얼마나 중요한지를 고려합니다. 이는 요청된 정보가 사건 결과를 결정하는 데 중요하거나 관련 문제를 이해하는 데 중요할 수 있는지를 평가하는 것을 의미합니다.\n- 요청의 구체성. 법원은 발견 요청이 얼마나 상세하고 명확한지를 살펴봅니다. 요청은 너무 포괄적이거나 모호해서는 안 되며, 필요한 정보를 명확히 지정하여 발견 과정이 효율적이고 사건과 관련이 있는지를 보장해야 합니다.\n- 정보의 출처. 법원은 요청된 정보나 문서가 미국에서 발생했는지를 고려합니다. 이 요소는 국제 분쟁 또는 외국 법이 발견 과정에 영향을 미칠 때 특히 관련이 있습니다.\n- 대안의 가용성. 필요한 정보를 얻는 다른 방법이 덜 부담스럽거나 논란적일 수 있는지 여부를 고려합니다. 다른 소스에서 정보를 찾거나 침입적이지 않은 방법을 통해 정보를 얻는 것을 의미할 수 있습니다.\n- 준수 또는 부적응의 영향. 법원은 발견 요청에 대해 준수하거나 그렇지 않을 때의 결과를 평가합니다. 이는 부적응이 미국의 중요한 이익을 약화시킬 수 있는지 또는 준수가 어떻게 해당 정보가 위치한 주의 이익에 영향을 미칠 수 있는지를 고려하는 것을 포함합니다.\n\n이러한 요인들을 해당 사례에 적용할 때, 법원은 정보 공개의 필요성과 국제 법적 규범을 존중하면서 관련 당사자에게 주는 부담을 균형있게 고려합니다. 특히, 소송에 대한 요청의 중요성과 요청의 구체성에 중점을 둡니다.\n\n![WhatsApp의 스파이어 타이탄 격파로 승리: 페가수스의 철퇴](/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 발견 준수 및 국제적 고려사항\n\n법원 판결의 발견 준수 및 국제적 고려사항 부분은 국제적인 법과 다양한 국가의 당사자들이 관련된 경우 발견 요청을 시행하는 도중의 어려움과 법률적 미묘함을 중심으로 하고 있습니다:\n\n- 법원은 미국 및 이스라엘 법에 따라 발견 요청을 준수해야 하는 피고들의 의무를 검토했습니다. 다양한 제약 조건에도 불구하고, 법원은 모든 발견에 대한 완전한 면제를 부여하지 않기로 결정했으나 특정 기준에 따라 일부 면제를 허용했으며, 외국 법에 대한 검토를 고려한 조합 기준을 강조했습니다.\n- 외국 법이 발견 명령의 불이행을 변명할 수 있는 범위를 결정할 때, 법원은 Richmark 판결의 두 가지 주요 요소에 초점을 맞췄습니다 (이전 섹션에서 다룬 내용): 소송에 대해 요구된 문서나 정보의 중요성과 발견 요청의 명확성입니다. 법원은 필요한 정보 및 구체적으로 명시된 정보만이 발견 대상이 되도록 하여, 피고들에 대한 부담을 줄이면서도 원고들이 중요한 증거에 접근할 수 있도록 하려고 했습니다.\n- 법원은 발견 범위에 대해 몇 가지 핵심적인 결정을 내렸습니다: (i) 스파이웨어 제작: 피고들에게 주장된 스파이웨어의 버전 및 기능을 제작하도록 요구했습니다. WhatsApp 서버를 대상으로 하는 또는 WhatsApp을 이용하는 관련 스파이웨어가 모두 포함되어야 한다는 내용을 명시했습니다; (ii) 클라이언트 신원: 법원은 피고들의 제3자 클라이언트 (즉, 스파이웨어를 사용한 사람들)의 신원을 공개할 필요가 없다고 결정했습니다. 이유는 이러한 제3자가 취한 행동을 이해하기 위해서는 그들의 구체적인 신분을 알 필요가 없다고 판단했기 때문입니다. 피고들이 스파이웨어 남용의 각 혐의에 대한 역할이 조사될 수 있다면 충분하다는 것이었습니다; (iii) 서버 아키텍처: 법원은 피고들의 서버 아키텍처에 대한 구체적인 정보가 현재 소송 단계에서 필요하지 않다고 결론 내렸습니다. 이 결정은 주장된 스파이웨어의 전체 기능을 이해하는 것이 (공개되어야 하는) 원고들의 목적을 위해 서버 설정의 기술적 세부사항에 심층적으로 파고들 필요는 없다는 판단에 기반하고 있습니다.\n\n# 법원의 동의에 관한 판결\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n법원은 발견 절차 및 사건 관리와 관련된 여러 동의 관련 움직임에 대한 주요 판결을 내렸습니다:\n\n- 원고의 발견 강요 동의서 (Dkt. 236). 이 동의서는 대부분 수락되었으나 일부는 거부되었습니다. 법원은 Richmark 요소에서 제공된 지침에 따라 원고들이 제출한 특정 정보 요청의 중요성과 구체성을 인정했습니다. 구체적으로, 법원은 사건과 관련이 있는 악성 소프트웨어의 버전 및 기능에 대한 정보를 제공하도록 피고인들에게 요구했습니다. 그러나 이 동의서는 완전히 수락되지 않았으며, 일부 요청은 너무 넓거나 충분히 구체적이지 않거나 강제 발견의 입김 임계값을 충족하지 않았을 가능성이 있습니다.\n- 피고인의 발견 강요 동의서 (Dkt. 240). 이 동의서는 거부되었습니다. 피고인들은 제3자 증인 (시민 연구소)와 관련된 원고들의 의사 소통 및 피고인 소프트웨어를 통해 타깃으로 지정된 사용자들의 식별과 관련된 내부 문서를 요청했습니다. 법원은 피고인들이 이러한 요청이 사건의 소송 또는 방어에 따라 Rule 26(b)(1)에 따라 관련성을 입증하지 않았다고 판단했습니다.\n- 피고인의 사건 관리 일정으로부터의 해방을 위한 동의서 (Dkt. 265). 이 동의서는 수락되었으며, 피고인들에게 발견 마감일과 요약 판결 및 재판의 연장 마감일을 약 6개월 동안 허용했습니다. 이 동의서를 수락한 법원의 결정은 사건에 수반된 복잡성을 인지하며, 검토될 정보의 양이나 관할 지역 간 조정의 어려움 등을 고려했을 가능성이 있습니다.\n- 봉인 동의서 (Dkt. 235, 239, 249, 257, 260, 264, 272, 276). 당사자들이 제출한 모든 봉인 동의서가 수락되었습니다. 이는 법원에 제출된 특정 문서나 정보가 비공개로 유지되어 공개되지 않을 것을 의미하며, 이는 일반적으로 개인 정보 보호 문제 또는 해당 문서에 포함된 정보의 민감성 때문일 가능성이 큽니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_3.png\" /\u003e\n\n# 디지털 감시와 사이버 보안에 대한 함의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제의 핵심은 근본적인 질문이 있습니다: 미국인들은 외국 기관, 특히 이스라엘 회사에서 동의 없이 감시를 받고 싶어 할까요? 이는 사람들의 개인 정보 보호권과 디지털 세계에서 넘어가는 보이지 않는 경계에 대한 심오한 우려에 관련이 있습니다.\n\n미국의 법률 체계와 정부는 갈림길에 서 있습니다. 사람들이 어떤 사회에서 살고 싶은지 심사숙고해야 합니다. 그들은 개인 정보 보호를 희생하려 할까요? 아니면 우리의 허락을 받기 전까지 보이지 않음을 포함한 자유를 믿나요?\n\n미국의 법적 구조는 발전해야 합니다. 사람들이 위협에 대비하면서, 동의 없이 (특히 외국에서의) 감시가 일반적인 행태가 되지 않도록 보장해야 합니다.\n\n#면책 조항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에 제공된 정보는 정보 및 교육 목적으로만 제공되는 것이며, 법률 자문이나 법률 자문 대체로 사용되어서는 안 됩니다. 본문의 정확성과 완전성을 보증하기 위해 노력했지만, 법률 원칙과 규정은 관할 지역과 구체적 상황에 따라 상당히 다를 수 있음을 감안해야 합니다. 따라서 이 기사는 결정적인 법적 자료나 법적 판단의 기초로 사용해서는 안 됩니다. 독자들은 각각의 사례가 상세하고 맞춤화된 법률 분석을 필요로 할 수 있으므로 법률 문제나 사안에 관해 자격 있는 변호사와 상담하기를 강력히 권고합니다.\n\n본문에서 제공된 정보를 전적으로 의존하고 변호사의 전문 자문을 구하지 않으면 의도하지 않은 법적 결과나 오해를 초래할 수 있습니다. 이 기사의 저자나 발행인은 잠재적인 오류나 생략에 대한 책임을 인정하지 않으며, 그 내용이나 사용으로 인해 발생한 손실, 부상, 또는 손해에 대해서도 책임을 지지 않습니다. 여기에 제공된 정보는 독자와 저자 또는 발행인 간의 변호사-의뢰인 관계를 설정하지 않습니다.","ogImage":{"url":"/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_0.png"},"coverImage":"/assets/img/2024-05-23-WhatsAppsVictoryOverSpywareTitantheTakedownofPegasus_0.png","tag":["Tech"],"readingTime":7}],"page":"37","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"37"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>