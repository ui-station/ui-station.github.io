<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/37" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/37" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Java 제네릭을 이용한 다형 함수" href="/post/2024-06-19-PolymorphicfunctionsusingJavagenerics"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Java 제네릭을 이용한 다형 함수" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Java 제네릭을 이용한 다형 함수" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Java 제네릭을 이용한 다형 함수</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 어려운 면접 질문" href="/post/2024-06-19-Javatrickyinterviewquestions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 어려운 면접 질문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Javatrickyinterviewquestions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 어려운 면접 질문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 어려운 면접 질문</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제" href="/post/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">46<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="가장 많이 묻는 질문 - SOLID 원칙 JAVA" href="/post/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가장 많이 묻는 질문 - SOLID 원칙 JAVA" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가장 많이 묻는 질문 - SOLID 원칙 JAVA" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">가장 많이 묻는 질문 - SOLID 원칙 JAVA</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요" href="/post/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기" href="/post/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법" href="/post/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 여러 개의 경고를 표시하는 방법" href="/post/2024-06-19-HowtoshowMultipleAlertsinSwiftUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 여러 개의 경고를 표시하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtoshowMultipleAlertsinSwiftUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 여러 개의 경고를 표시하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI에서 여러 개의 경고를 표시하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코틀린 멀티플랫폼 KMP" href="/post/2024-06-19-KotlinMultiPlatformKMP"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코틀린 멀티플랫폼 KMP" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-KotlinMultiPlatformKMP_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코틀린 멀티플랫폼 KMP" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코틀린 멀티플랫폼 KMP</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기" href="/post/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link posts_-active__YVJEi" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Java 제네릭을 이용한 다형 함수","description":"","date":"2024-06-19 22:03","slug":"2024-06-19-PolymorphicfunctionsusingJavagenerics","content":"\n자바 함수형 프로그래밍 구축 요소\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png)\n\n이 기사는 제네릭 유형과 함수형 인터페이스를 사용하여 자바에서 다형성 함수를 작성하는 주제를 탐구합니다. 이 기본 사항은 종종 주니어 엔지니어에 의해 고려되지 않는다. 대신 Java 8+ Stream API와 같은 더 심화된 주제로 즉시 진입하는 것을 선호합니다. 그러나 이것들은 자바에서 함수형 프로그래밍 개념을 배우고 적용하며 더 깨끗하고 재사용 가능하며 선언적인 코드를 작성하는 데 필수적인 구축 요소입니다.\n\n기사 말미에서, 저는 모든 것을 매우 유용하고 실용적인 예제로 하나로 조합할 것입니다. 이 기사가 당신에게 매우 유용하고 실질적인 예제가 될 것이라고 기대합니다. 이 기사가 당신에게 단단한 기초를 제공하고 댓글 섹션이나 스스로 더 탐구하도록 격려할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 계속 읽기 전에 주의할 점은, 이 문서가 제네릭 및 함수형 인터페이스 개념 및 구문을 배우는 초보자용 완전한 자습서로 제공되는 것이 아니라는 것입니다. 이미 Java 공식 문서 및 다양한 자습서 웹사이트에 많은 이러한 자습서가 존재합니다. 우리는 기본 사항을 빠르게 살펴볼 것이며, 이 글의 주요 목적은 왜 그리고 어떻게 실제로 유용한지 깊게 이해하려는 것입니다.\n\n## Java 제네릭의 목적\n\n그렇다면 Java 제네릭의 목적은 무엇이며, 언제 유용할까요?\n\n가장 유혹적인 말은 \"공통 부모를 공유하는 클래스가 있는 재사용 가능한 코드를 작성하기 위해서\"라고 말하는 것입니다. — 또는 이와 같은 말입니다. 경우에 따라, 그리고 어느 정도로 그렇습니다. 하지만 이것이 정확히 무엇을 의미하는지는 무엇일까요? 아래 코드 조각을 살펴봅시다. 제네릭 유형을 사용하는 좋은 이유가 될까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_1.png)\n\n답은: no입니다. 이 코드는 다음 코드 스니펫에서 강조하는 것처럼 Dog 추상화 자체로 쉽게 바꿀 수 있습니다. 이러한 경우에는 제네릭을 사용할 필요가 없습니다.\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_2.png)\n\n그렇다면, Java 제네릭이 언제 진정으로 유용한가요? 먼저, 클래스 제네릭 유형과 메서드 제네릭 유형 두 가지 유형의 일반 유형이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스 제네릭 타입은 특히 여러 클래스 API 메소드들 사이에서 타입 일관성을 유지하는 데 유용합니다. 첫 번째 예시로는 List 인터페이스가 add나 get과 같은 여러 메소드에서 동일한 클래스 제네릭 타입 E를 시그니처에 재사용하는 것이 있습니다.\n\n메소드 제네릭 타입은 Java 언어의 설계 제한을 극복하는 데 도움을 줍니다. 클래스 제네릭 타입을 사용하는 클래스는 무변(invariant)이기 때문에(공변(covariant)이 아님) 메소드 제네릭 타입은 여러 메소드 매개변수 및/또는 반환 타입에 걸쳐 특정 타입을 강제하는 데 매우 유용합니다.\n\n실무에서 무변이 무엇을 의미하는지 예를 들어 설명하자면, List`String`은 String이 Object의 하위 타입이지만 List`Object`의 하위 타입이 아니라는 것입니다. 리스트가 무변이라는 것에 주목할 만한 점은 Java에서 배열은 공변적(covariant)이기 때문에(String[]는 Object[]를 확장합니다) 이 특정 목적을 위해 제네릭 메소드 타입을 사용할 필요가 없다는 것입니다.\n\n다음 코드 스니펫에서 Java의 공변성/무변성 관련하여 어떤 것이 허용되고, 어떤 것이 안 되는지 살펴볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_3.png\" /\u003e\n\n그래서 요약하면, Java 제네릭의 주요 목적은 개발자가 여러 가지 유형에서 재사용 가능한 코드를 작성하고 일관된 계약(클래스 수준 또는 메소드 수준)을 제공하는 동안 유연하게 작동하도록 하는 것입니다.\n\n## 제한된 제네릭 유형\n\n제네릭 유형은 상한, 하한 또는 명시적 바운드가 없을 수 있습니다(Object가 상한인 경우).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한계가 없는 제네릭 유형을 탐색해 봅시다. 이 유형들은 어떤 객체 유형이든 가능하게 합니다. 주로 여러 매개변수 및/또는 반환 유형에 동일한 유형을 적용하는 데 사용됩니다. 아래 코드 예제에서 볼 수 있듯이 다른 간단한 동작도 정의할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_4.png)\n\n아마도 가장 흔한 제네릭 사용 사례 중 하나는 상위 경계 제네릭 유형을 사용하는 것입니다. 이것은 소개 섹션에서 언급한 \"일반 부모\" 상속 기반 예제입니다. 아래 예제에서 강조되어 있습니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번 멈춰서 일반적인 유형이 우리에게 무엇을 하는지 두 가지 관점에서 이해해 봅시다: 호출자의 관점과 구현의 관점에서.\n\n이 API를 사용하는 사용자로서, List`Dog`나 Dog 하위 유형(예: List`GermanSheppard`)을 사용하여 findDogByNameGeneric(...)을 호출할 수 있습니다.\n\n메서드 구현 관점에서는 경계가 있는 일반 유형 `T extends Dog` 가 우리에게 강력한 보증을 제공하는데, 이는 우리가 받는 모든 목록이 요소가 부모 유형 Dog를 공유할 것이라는 것입니다. 이는 목록이 개발자에게 메서드 내에서 사용할 수 있는 요소를 생성할 수 있게 해줍니다(즉, 여기서는 Dog 및 특히 부모 인터페이스에서 정의된 getName()을 호출하는 경우).\n\n상한이 있는 제네릭 유형 목록으로는 요소를 추가할 수 없습니다. 이것을 생각해 보면 이해할 수 있으며, 그 이유를 찾아보는 것은 시간을 들여서 한 번 곰곰히 생각할 가치가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[1초 후]\n\n상한이 정의된 제네릭 타입 목록에 요소를 추가할 수 없는 이유는 메서드 구현 내에서 호출된 목록의 실제 타입을 알 수 없기 때문입니다. 아래 예시를 살펴봅시다.\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_6.png)\n\n만약 상한이 정의된 타입에 추가할 수 있다면, List`Double` 입력 매개변수를 사용해 addSomething을 이론적으로 호출할 수 있고, 메서드 내에서 Double 목록에 Integer(또한 Number를 확장한)을 추가할 수 있습니다. 컴파일 시에 메서드가 어떤 타입으로 호출될지 알 수 없기 때문에, 언어가 목록의 타입 무결성을 잠재적으로 위반하지 못하도록 우리를 방해하는 것은 바로 이것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 우리가 일반 형식 소비자에 요소를 전달하려면(컬렉션이어야만 하는 것은 아님), 상위 바운드를 만들기 위해 super 키워드를 사용해야 합니다. 아래의 또 다른 예제를 살펴보고, 이전처럼 API 관점과 구현 관점에서 super가 우리에게 무엇을 보장해주는지 생각해봅시다.\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_7.png)\n\nAPI 관점에서는 populateGermanSheppards 메서드의 두 번째 매개변수는 List`GermanSheppard` 또는 그 상위 형식인 List`Dog`일 수 있습니다. 이게 구현 관점에서 왜 도움이 되는지 생각해 보세요.\n\n[또 다른 시간이 흘렀습니다]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\npopulateGermanSheppards의 구현 내에서 두 번째 입력 매개변수가 List`GermanSheppard` 또는 List`Dog` 중 하나인 것을 알 수 있습니다. 따라서 해당 목록에 GermanSheppard를 추가해도 목록의 유형 무결성을 위반하지 않습니다. 왜냐하면 입력 매개변수 목록이 List`GermanSheppard`인 경우 GermanSheppard를 추가하는 것이 단순히 유효하며, List`Dog`인 경우 GermanSheppard는 Dog이므로 유형이 여전히 유효합니다. 더불어 부모 클래스에 대해서도 동일한 원리가 적용됩니다.\n\n매번 바운드된 제네릭 유형을 생각할 필요가 없도록, 간단히 PECS라는 머릿글자를 기억하면 됩니다. PECS는 Producer-Extends Consumer-Super의 약자로, 제네릭 메소드를 사용하여 상위 바운드 유형을 가진 요소를 생성/생산하는 요소들을 생산자로 정의합니다.\n\n소비자는 요소를 받아들일 수 있는 능력과 관련이 있습니다. 예를 들어 List의 add 메소드는 요소를 받아들일 수 있기 때문에 소비자이며, 목록의 제네릭 유형을 소비자-슈퍼로 제한할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지 우리가 논의한 것은 단순한 기본 구성 요소로, Java에서 일반적인 타입이 어떻게 실제로 작동하는지의 기본 설명입니다. 더 많은 내용이 있으며, 와일드카드 및 타입 이레이저에 대해 약간 읽어보고, 컬렉션을 중심으로하지 않는 더 많은 예시(예: Optional)를 살펴보면 일반 타입에 대해 더 익숙해질 수 있습니다.\n\n그러나 순수 일반 타입을 강조하는 좋은 예제를 제공하기가 어려운데, 적어도 내게는 이러한 타입의 가장 크고 일반적으로 사용되는 장점은 함수형 인터페이스와 결합될 때입니다. 이에 대해 더 자세히 알아보겠습니다.\n\n# 함수형 인터페이스 기본 사항\n\n함수형 인터페이스는 재사용 가능한 코드를 작성할 때 우리가 가진 도구 중 하나입니다. 또한 좋은 개발자 경험을 제공하는 유연한 API를 구축하고 싶다면 바운드된 제네릭 타입을 사용하여 개선할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이론적으로 함수형 인터페이스는 오직 하나의 비디폴트 메소드만 가진 인터페이스를 말합니다(즉, 구현이 없는 메소드가 하나뿐인 경우). 이러한 인터페이스들은 Java 유형을 제공하고 람다 표현식이나 메소드 참조 같은 호출 가능한 코드 조각을 참조하는 데 사용됩니다. 이러한 참조를 다른 객체 유형처럼 사용할 수 있게 해줍니다. 함수를 참조할 수 있고, 호출하지 않고 다른 함수에 전달할 수 있습니다.\n\nJava 8부터 Java JDK 내에 여러 유형의 함수형 인터페이스가 있습니다. 가장 기본적인 것은 Function`T, R`입니다. 이는 입력 T 집합을 가져와 R 집합의 결과를 출력하는 수학 함수와 동등합니다. 다만 여기서는 유형 인스턴스를 다루고 있을 뿐입니다. 함수형 프로그래밍에서는 이를 펑터라고도 부릅니다.\n\n함수 외에도 다음과 같이 계속해서 사용되는 함수형 인터페이스 유형들이 있습니다(그들의 Bi[…]variant인 BiFunction`T, U, R`와 함께), 이미 알고 계신지 모르겠지만 익숙해지기를 권장드립니다:\n\n- Predicate`T`: Function`T, Boolean`와 같은 역할을 합니다.\n- Consumer`T`: T형 인자를 가지고 void(아무것도)를 반환하는 함수를 나타냅니다.\n- Supplier`T`: 어떠한 인자도 받지 않고 T 유형 원소를 반환하는 함수를 나타냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 많은 작업을 수행할 수 있는 메소드의 예시를 살펴봅니다. 원리적으로는 리스트의 요소를 반복하고 특정 조건에서 특정 작업을 수행합니다. 메소드 자체에서는 구체적인 내용은 정의되어 있지 않으며, 이는 꽤 추상적입니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_8.png)\n\n추가로, 제 개인적인 의견으로는 함수형 인터페이스를 사용하여 지나치게 추상화된 일반적인 함수를 작성하는 것도 코드 재사용성을 위해 코드 가독성을 너무 희생하는 경우 반대 패턴으로 간주해야 한다고 생각합니다. 둘 사이에는 균형이 필요하며, 재사용 가능한 일반적인 메소드에서 구체적이고 정당화할 수 있는 문제를 해결하도록 노력해야 합니다.\n\n조건부 요소 소비자(conditionalElementsConsumer) 메소드 시그니처가 어떻게 보일지 생각해 보세요. 일반적인 타입을 완화하고 한정적인(혹은 제한된) 일반적인 타입을 사용한다면 어떨까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[a second of thinking passes]\n\nPECS 약자에 대해 간단히 생각해 보면, 느슨한 서명은 다음 예시와 같은 형태여야 합니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_9.png)\n\n새 예시에서 이전의 제한된 제네릭 유형이 새로운 케이스를 지원하기에 충분히 유연하지 못했음을 알 수 있습니다. 이 간단한 기능 인터페이스를 사용해 개념을 설명하고 있지만, 실제 프로젝트에서는 타입이 일치하도록 바꿀 수 없는 서드파티 코드의 메서드 참조와 유사한 상황을 마주하게 될 수 있습니다. 경계를 통해 제네릭 유형을 느슨하게 처리하면 이를 해결하는 데 도움이 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 지점에서 또 다른 좋은 연습은 위의 예제를 생각하고 152번 라인에서 컴파일 되는 메소드 호출의 실제 T 유형을 파악해 보는 것입니다.\n\n함수형 인터페이스의 기본을 더 깊이 들어가지는 않겠습니다. 다양한 다른 유형에 대해 이야기하는 많은 기사들과 람다 표현식, 메소드 참조에 대해 참조할 수 있는 함수형 인터페이스 유형도 있습니다.\n\n그러나 이러한 기본 개념을 조합하여 실제 유용한 재사용 가능한 코드를 만들 수 있는 방법을 강조하는 데는 조금 더 나아갈 것입니다.\n\n# 고차 함수를 통한 데코레이터\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고차 함수는 다른 함수를 매개변수로 받거나 함수를 반환하는 함수형 프로그래밍 개념을 나타냅니다.\n\n이를 생각하면, 실제로 호출하지 않고 일반 함수를 래핑하는 데코레이터와 유사한 디자인 패턴을 이론적으로 정의할 수 있습니다.\n\n많이 접하게 되는 예시 중 하나는 확인된 예외를 throw하는 함수를 처리하는 것입니다. 이는 특히 Stream API 메소드 호출 내에서 문제가 될 수 있습니다. Stream API 메소드는 예외를 throw하지 않는 함수형 인터페이스를 입력 매개변수로 사용하기 때문입니다. 물론 Vavr과 같은 라이브러리를 사용할 수도 있지만, 사용 사례가 제한적이고 종속성 목록을 작게 유지하고 싶다면 직접 래퍼/핸들러를 구축하는 것이 더 나은 옵션이 될 수 있습니다. 아래 예시에서 (인기 있는) 상황을 확인해보세요.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_10.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 위의 코드에서 발생한 컴파일 오류는 map 메서드에서 예상되는 메서드 시그니처 (즉, Function`T, R`)와 제공된 함수가 String을 가져와 List`String`을 반환하거나 IO Exception을 던질 수 있는 함수임을 고려할 때 발생합니다 (이러한 의미로는 JDK에 기본적으로 해당 함수형 인터페이스가 없음).\n\n이러한 유형의 불일치를 다루는 비제네릭하고 간단한 방법은 발생한 예외를 별도의 메서드로 분리하여 거기서 예외를 처리하는 것입니다. 이렇게 하면 사실상 Stream::map 메서드에 대해 Function`String, List`String`` 입력 매개변수로 변환될 것이며 이는 컴파일이 될 것입니다. 그러나 제네릭 및 함수 인터페이스를 통해 코드 재사용할 수 있는 큰 기회가 있다는 것을 다음 예제에서 확인할 수 있습니다.\n\n![Example](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_11.png)\n\n위의 코드 예제를 조금 설명해보겠습니다. 먼저, 제시된 3가지 옵션 중 어느 것을 사용하더라도 더 이상 컴파일 오류가 발생하지 않음을 관찰할 수 있습니다. 이제 map 메서드는 호출 시 예상대로 Function`Path, List`String``를 받는다고 볼 수 있는 mapSafeFunction을 수신하며, 또한 ExceptionalFunction 인터페이스를 정의할 때 코드가 완벽하게 컴파일되고 Files::readAllLines 메서드 참조가 어떤 컴파일 오류도 없이 허용됩니다. 즉, 이 문제는 예외 처리가 되지 않았던 것이 아니라 함수형 인터페이스 타입이 일치하지 않았기 때문임을 결론짓습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수학 함수에 대해 생각해보면, 입력을 받아 출력을 제공하며 예외를 throw하지 않습니다. 마찬가지로 여기서는 예외를 throw하는 함수를 throw하지 않는 함수로 변환하려고 합니다. 그렇다면 예외가 발생했을 때 어떻게 해야 할까요?\n\n이것은 완전히 개인적인 선택이었지만, 예외가 발생한 경우 결과가 없을 수도 있다는 사실을 나타내기 위해 생성된 함수가 Optional을 반환하도록 만들기를 원했습니다. 이것이 ExceptionalFunction`T, R`의 입력에 대한 반환 타입이 Function`T, Optional`R``로 되어 있는 이유입니다. 이전 Optional::map 작업이 flatmap 작업으로 변경되어 코드 전체에 매우 잘 맞는 점에 주목하면 좋습니다(Javadoc 여기를 참조하세요). 예외가 발생하면 Optional 체인이 빈 결과를 제공하며 코드는 전반적으로 매우 깨끗하고 순조롭게 따라갈 수 있습니다.\n\n(부기적으로, 예외를 완전히 억제하거나 런타임 예외로 다시 던지거나 null을 반환하는 API 디자인 선택은 개발자 경험 관점에서 객관적으로 잘못된 접근법이라고 생각합니다. 주된 주장은 계약이 그냥 틀렸다는 것이며, 예기치 않은 동작이 API를 통해 추론될 수 없다는 점이며, 코드를 읽어야만 이해할 수 있다는 것입니다.)\n\nmapSafeFunction의 구현은 Files::readAllLines 또는 예외를 throw하는 기타 함수에 적용할 수 있습니다. 이 메서드는 전체 프로젝트 전반에 걸쳐 매우 재사용 가능하며 해결하는 문제가 매우 인기가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메소드 mapSafeFunction의 구현은 특별하거나 복잡한 것은 없습니다. 우리는 예외 처리 함수를 가져와 try/catch 예외 처리 논리를 처리하고 원래 함수를 호출하는 함수를 반환합니다. 추가적으로 Consumer`Exception`은 예외 로깅이나 처리 논리를 다루기 위한 유연한 API를 제공합니다. 호출자가 slf4j를 사용하여 예외를 로깅하거나, 콘솔에 로깅하거나, 소비자 내에서 런타임 예외를 다시 던지는 것을 막는 것은 없습니다. 이 방법은 덜 번거롭고 명시적이지 않은 API에 기본값을 제공하기위해 의도적으로 오버로드되었습니다.\n\n동일한 패턴에 대한 유사한 사용 사례는 트랜잭션 관리 일 수도 있습니다. 함수가 호출되기 전에 트랜잭션을 시작하고, 끝에서 커밋하거나 예외가 발생했을 경우 롤백하는 전반적인 개념은 동일합니다.\n\n# 결론\n\n함수형 프로그래밍(또는 단순히 Java Stream API)을 이해하려면 함수형 인터페이스를 이해해야 하며, 이는 다시 제네릭 유형에 의존합니다. 이러한 주제들은 서로 긴밀하게 연결되어 있으며, 개인적인 관찰에 따르면 후자는 종종 간과됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사의 개념들은 하나씩 쉽게 이해할 수 있지만 함께 사용하면 사용할 수 있는 코드가 매우 재사용 가능하다는 것을 알 수 있습니다, 특히 예외 기능 데코레이터의 예시에서 확인할 수 있습니다. 더 많은 응용 프로그램이 있으며, 이 중 한 가지가 제 개인적인 취향입니다.\n\n이 기사가 유익했고 이러한 개념을 실험하고 일상 프로젝트에 적용해 보는 호기심을 자극했기를 바랍니다. 이러한 기본적인 자바 개념은 자바에서 함수형 프로그래밍 패턴을 배우는 데 필요한 기본 블록으로 기능하지만, 이에 대해 더 알아보도록 하겠습니다.\n\n향후 자바 개념 설명, 프레임워크 및 기타 기술 관련 콘텐츠에 구독하고 좋아요를 눌러주시기 바랍니다!\n","ogImage":{"url":"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png"},"coverImage":"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png","tag":["Tech"],"readingTime":15},{"title":"자바 어려운 면접 질문","description":"","date":"2024-06-19 22:01","slug":"2024-06-19-Javatrickyinterviewquestions","content":"\n![이미지](/assets/img/2024-06-19-Javatrickyinterviewquestions_0.png)\n\n안녕하세요! 오늘은 핵심 Java에 관련된 어려운 인터뷰 질문을 살펴보겠습니다. 이 자료는 면접 준비 중인 개인들을 돕기 위해 특별히 설계되었습니다. 기술 면접을 해결하거나 이해력을 향상시키려는 경우, 이 시리즈는 성공으로 향하는 여정에서 귀하에게 가치 있는 자산이 되도록 목표하고 있습니다.\n\n- 다음 코드 스니펫의 출력은 무엇입니까?\n\n```java\npublic static void main(String[] args) {\n\n    int a = 5;\n    int b = 10;\n    System.out.println(a++ + ++b);\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n질문: 16\n\n2. 이 코드 실행의 결과는 무엇입니까?\n\n```java\npublic static void main(String[] args) {\n\n  String str = null;\n  if (str instanceof String) {\n   System.out.println(\"True\");\n  } else {\n   System.out.println(\"False\");\n  }\n\n }\n```\n\n답변: False\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 다음 코드의 출력은 무엇입니까?\n\n```java\npublic static void main(String[] args) {\n\n  int x = 10;\n  int y = (x \u003e 5) ? (x \u003c 10 ? 1 : 2) : 3;\n  System.out.println(y);\n\n}\n```\n\n답: 2\n\n4. 다음 코드의 출력은 무엇입니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nint a = 10;\nSystem.out.println(a += (a = 5) * (a / 5));\n```\n\n답: 15\n\n5. 이 코드의 결과는 무엇입니까?\n\n```js\npublic static void main(String[] args) {\n\n  String s1 = \"Java\";\n  String s2 = \"Ja\" + \"va\";\n  System.out.println(s1 == s2);\n\n }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n답변: True\n\n6. 출력 결과는 무엇입니까?\n\n```java\n public static void main(String[] args) {\n\n  int[] arr = new int[5];\n  System.out.println(arr[0]);\n\n }\n\n\n답변: 0\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. 아래 코드의 출력은 무엇입니까?\n\npublic static void main(String[] args) {\n\n  int i = 0;\n  int j = i++ + ++i;\n  System.out.println(j);\n\n}\n\n답: 2\n\n8. 다음 코드는 무엇을 출력합니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\npublic static void main(String[] args) {\n\n  System.out.println(\"Hello\" == new String(\"Hello\"));\n\n }\n\n답변: False\n\n9. 아래 코드의 결과는 무엇입니까?\n\nint a = 5;\nint b = 10;\na ^= b ^= a ^= b;\nSystem.out.println(a + \"-\" + b);\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n0-5 사이의 답변입니다.\n\n10. 이 코드는 무엇을 출력합니까?\n\npublic static void main(String[] args) {\n\n  System.out.println(10 + 20 + \"30\" + 40 + 50);\n\n }\n\n답변 : 30304050\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n11. 아웃풋은 무엇인가요?\n\n public static void main(String[] args) {\n\n  String s1 = \"abc\";\n  String s2 = new String(\"abc\");\n  System.out.println(s1.equals(s2) \u0026\u0026 s1 == s2);\n\n }\n\n답: False\n\n12. 이 코드는 무엇을 출력하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```\n\njava\npublic static void main(String[] args) {\n\nInteger a = 127;\nInteger b = 127;\nSystem.out.println(a == b);\n\n}\n\n답변: True\n\n13. 다음 코드는 무엇을 출력합니까?\n\n```java\npublic static void main(String[] args) {\n\n for (int i = 0; i \u003c 3; i++) {\n  switch (i) {\n  case 0:\n   System.out.print(\"A\");\n  case 1:\n   System.out.print(\"B\");\n   break;\n  case 2:\n   System.out.print(\"C\");\n  }\n }\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 답변이 있습니다:\n\n14. 이 코드의 결과는 무엇인가요?\n\n```java\npublic static void main(String[] args) {\n\n  String a = \"apple\";\n  String b = \"apple\";\n  a = a.replace(\"p\", \"b\");\n  System.out.println(a + b);\n\n}\n```\n\n답변: abbleapple\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n15. 출력은 무엇입니까?\n\n```java\npublic static void main(String[] args) {\n\n  boolean a = true;\n  boolean b = false;\n  boolean c = a || b \u0026\u0026 !a;\n  System.out.println(c);\n\n }\n```\n\n정답: true\n\n16. 결과는 무엇입니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic static void main(String[] args) {\n\n  int x = 2;\n  int y = 0;\n  for (; y \u003c 10; ++y) {\n    if (y % x == 0)\n      continue;\n    else if (y == 8)\n      break;\n    else\n      System.out.print(y + \" \");\n  }\n\n}\n```\n\nAnswer : 1 3 5 7 9\n\n17. What will this code output?\n\n```java\npublic static void main(String[] args) {\n\n  try {\n    int a = 10 / 0;\n    System.out.println(\"This will not be printed\");\n  } catch (Exception e) {\n    System.out.println(\"Exception caught\");\n  } finally {\n    System.out.println(\"Finally block executed\");\n  }\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n답변:\n\n예외가 발생했습니다\n\n마지막으로 블록이 실행되었습니다\n\n18. 결과는 무엇입니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic static void main(String[] args) {\n\n  int a = 5;\n  int b = 10;\n  if ((a = 3) == b) {\n   System.out.println(a);\n  } else {\n   System.out.println(a + b);\n  }\n\n }\n```\n\n답변: 13\n\n19. 이 코드는 무엇을 인쇄합니까?\n\n```java\npublic static void main(String[] args) {\n\n  System.out.println(Math.min(Double.MIN_VALUE, 0.0d));\n\n }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n답변: 0.0\n\n20. 이 코드의 출력은 무엇입니까?\n\n```js\npublic static void main(String[] args) {\n\n  int a = 0;\n  System.out.println(a++ == ++a);\n\n}\n```\n\n답변: false\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n21. 이 코드는 무엇을 출력합니까?\n\n```js\npublic static void main(String[] args) {\n\n   String s1 = new String(\"xyz\");\n   String s2 = \"xyz\";\n   System.out.println(s1.intern() == s2);\n\n}\n```\n\n답: True\n\n22. 다음의 출력물은 무엇입니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경하실래요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n질문 : 6\n\n24. 다음 코드의 출력은 무엇입니까?\n\n```java\n public static void main(String[] args) {\n\n  int x = 10;\n  int y = 20;\n  int z = x += y -= x += y;\n  System.out.println(z);\n\n }\n```\n\n답변 : 0\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n25. 이 코드의 출력은 무엇입니까?\n\n```js\n public static void main(String[] args) {\n\n  int[] nums = { 1, 2, 3, 4, 5 };\n  for (int num : nums) {\n   if (num % 2 == 0) {\n    continue;\n   }\n   System.out.print(num + \" \");\n  }\n }\n```\n\n답변: 1 3 5\n\n제 글을 끝까지 읽어주셔서 감사합니다. 글에서 유익한 통찰과 지식을 얻으셨기를 진심으로 바랍니다. 글이 즐겁고 유익했다면, 친구들과 동료들과 공유해 주시기를 부탁드립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 글을 즐겨 보셨다면 팔로우, 구독 또는 박수를 부탁드립니다.\n\n다른 글들도 한번 살펴보세요.\n","ogImage":{"url":"/assets/img/2024-06-19-Javatrickyinterviewquestions_0.png"},"coverImage":"/assets/img/2024-06-19-Javatrickyinterviewquestions_0.png","tag":["Tech"],"readingTime":11},{"title":"자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제","description":"","date":"2024-06-19 21:56","slug":"2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements","content":"\n## 안녕하세요 친구들, 이 기사에서는 다양한 Java 버전에 대해 이야기하고 싶습니다. 나는 Java 8부터 Java 21까지의 각 버전에서 소개된 모든 중요한 기능과 API를 다루고, 좀 더 심도있는 통찰력을 얻기 위해 코딩 예제를 제시하려고 합니다.\n\n이는 Java 초보자뿐만 아니라 Java 8이나 Java 11과 같은 오래된 버전의 Java에서 작업하고 있는 Java 개발자들에게 도움이 될 것입니다. 자바 세계에서 무슨 일이 일어나고 있는지업데이트하고 싶어 하는 사람들에게 유용할 것입니다.\n\n자 그럼 시작해봅시다,\n\n![이미지](/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 특징:\n\n람다 표현식:\n\n- 익명 함수 사용으로 함수형 프로그래밍 가능.\n- 함수형 인터페이스 작성을 위한 간결한 구문.\n\n함수형 인터페이스:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 람다 표현식을 사용하는 데 도움이되는 단일 추상 메소드를 가진 인터페이스입니다.\n- @FunctionalInterface 어노테이션을 사용하여 해당 인터페이스를 표시합니다.\n\n스트림 API:\n\n- 요소 시퀀스를 처리하기 위해 Stream이라는 새로운 추상화를 소개합니다.\n- filter, map, reduce 등의 함수형 스타일 작업을 지원합니다.\n\n메소드 참조:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 람다 표현식에 대한 간편한 표기법을 제공합니다.\n- 메서드나 생성자를 :: 연산자를 사용하여 참조할 수 있습니다.\n\nOptional 클래스:\n\n- 비어 있을 수도 있고 비어 있지 않은 값을 포함할 수 있는 컨테이너 객체입니다.\n- null 체크를 더 효과적으로 처리하고 NullPointerException을 방지하는 데 도움이 됩니다.\n\n새로운 날짜 및 시간 API:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- java.time 패키지는 날짜와 시간을 다루는 보다 포괄적이고 유연한 API를 소개했습니다.\n- 이전의 java.util.Date 및 java.util.Calendar 클래스에서 발생한 다양한 문제를 해결합니다.\n\n기본 메소드:\n\n- 인터페이스에 메소드 구현을 허용합니다.\n- 기존 구현을 망가뜨리지 않고 인터페이스를 발전시키는 데 도움이 됩니다.\n\nNashorn JavaScript 엔진:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이전 Rhino JavaScript 엔진을 대체합니다.\n- 더 나은 성능을 제공하며 최신 JavaScript 표준과 더 호환됩니다.\n\nParallel Streams:\n\n- parallel() 메서드를 사용하여 스트림을 병렬 처리할 수 있습니다.\n- 특정 유형의 작업에서 멀티코어 시스템에서 성능을 향상시킵니다.\n\nCollectors:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 일반적인 축소 작업을 위한 Collectors 클래스의 유틸리티 메서드 집합을 소개합니다. 예를들어 toList(), toSet(), joining() 등이 있습니다.\n\njava.util.function 패키지의 함수형 인터페이스:\n\n- 람다 표현식을 지원하기 위해 Predicate, Function, Consumer 및 Supplier와 같은 새로운 함수형 인터페이스가 추가되었습니다.\n\n## 개선된 Process API:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 자바 9은 원시 프로세스를 더 잘 제어할 수 있도록 Process API에 개선 사항을 도입했습니다. 새로운 ProcessHandle 클래스를 사용하면 개발자가 프로세스와 관련된 정보를 얻고 상호 작용할 수 있습니다.\n\n```js\n// ProcessHandle API를 사용하여 현재 프로세스에 대한 정보 가져오기\npublic class ProcessHandleExample {\n    public static void main(String[] args) {\n        ProcessHandle currentProcess = ProcessHandle.current();\n        System.out.println(\"프로세스 ID: \" + currentProcess.pid());\n        System.out.println(\"실행 중? \" + currentProcess.isAlive());\n    }\n}\n```\n\n## 컬렉션 팩토리 메서드:\n\n- 자바 9에서는 컬렉션 인터페이스(List, Set, Map 등)에 새로운 정적 팩토리 메서드를 추가하여 이러한 컬렉션의 불변 인스턴스를 더 편리하게 생성할 수 있게 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport java.util.List;\n\npublic class CollectionFactoryMethodsExample {\n    public static void main(String[] args) {\n        // List.of() 팩토리 메서드를 사용하여 변경할 수 없는 목록 생성\n        List\u003cString\u003e colors = List.of(\"Red\", \"Green\", \"Blue\");\n        System.out.println(colors);\n    }\n}\n```\n\n## 향상된 스트림 API:\n\n- takeWhile, dropWhile, ofNullable과 같은 여러 새로운 메서드로 스트림 API가 향상되어 스트림 작업의 유연성과 기능성을 향상시켰습니다.\n\n```js\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class StreamAPIImprovementsExample {\n    public static void main(String[] args) {\n        // 예시 1: takeWhile\n        List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n        List\u003cInteger\u003e lessThanFive = numbers.stream()\n                .takeWhile(n -\u003e n \u003c 5)\n                .collect(Collectors.toList());\n\n        System.out.println(\"5보다 작은 숫자: \" + lessThanFive);\n\n        // 예시 2: dropWhile\n        List\u003cInteger\u003e greaterThanThree = numbers.stream()\n                .dropWhile(n -\u003e n \u003c= 3)\n                .collect(Collectors.toList());\n\n        System.out.println(\"3보다 큰 숫자: \" + greaterThanThree);\n\n        // 예시 3: ofNullable\n\n        // 예시 3: ofNullable\n        String value1 = \"안녕\";\n        String value2 = null;\n\n        // null이 아닌 값이 있는 예시\n        Stream.ofNullable(value1)\n                .ifPresentOrElse(v -\u003e System.out.println(\"ofNullable 예제 - null이 아닌 값: \" + v),\n                        () -\u003e System.out.println(\"ofNullable 예제 - null 값\"));\n\n        // null 값이 있는 예시\n        Stream.ofNullable(value2)\n                .ifPresentOrElse(v -\u003e System.out.println(\"ofNullable 예제 - null이 아닌 값: \" + v),\n                        () -\u003e System.out.println(\"ofNullable 예제 - null 값\"));\n\n        // null 안전한 스트림 예시\n        List\u003cString\u003e names = Arrays.asList(\"Alice\", \"Bob\", null, \"Charlie\", null, \"David\");\n        List\u003cString\u003e nonNullNames = names.stream()\n                .flatMap(name -\u003e StreamAPIImprovementsExample.nullSafeStream(name))\n                .collect(Collectors.toList());\n\n        System.out.println(\"null이 아닌 이름: \" + nonNullNames);\n    }\n\n    // 잠재적으로 null인 값을 스트림으로 만드는 헬퍼 메서드\n    private static \u003cT\u003e java.util.stream.Stream\u003cT\u003e nullSafeStream(T value) {\n        return value == null ? java.util.stream.Stream.empty() : java.util.stream.Stream.of(value);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제에서:\n\n- takeWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 가져오는 데 사용됩니다 (이 경우에는 5보다 작은 숫자).\n- dropWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 삭제하는 데 사용됩니다 (이 경우에는 3 이하의 숫자).\n- ofNullable은 잠재적으로 null인 값을 사용하여 스트림을 생성하고 null 값을 필터링하여 null 이름을 제외합니다.\n\n## 인터페이스의 비공개 메서드:\n\n- Java 9의 인터페이스는 비공개 메서드를 가질 수 있습니다. 이를 통해 공통 기능을 인터페이스 내에 캡슐화하여 외부 클래스에 노출하지 않고 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 프라이빗 메서드를 가진 인터페이스\npublic interface PrivateMethodInterface {\n    default void publicMethod() {\n        // 퍼블릭 메서드에서 프라이빗 메서드 호출 가능\n        privateMethod();\n    }\n\n    private void privateMethod() {\n        System.out.println(\"인터페이스 안의 프라이빗 메서드\");\n    }\n}\n```\n\nHTTP/2 클라이언트:\n\n- Java 9에서는 HTTP/2 및 WebSocket을 지원하는 새로운 가벼운 HTTP 클라이언트가 도입되었습니다. 이 클라이언트는 예전 HttpURLConnection API보다 효율적이고 유연하게 설계되었습니다.\n\n```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class HttpClientExample {\n    public static void main(String[] args) throws Exception {\n        HttpClient httpClient = HttpClient.newHttpClient();\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(new URI(\"https://www.example.com\"))\n                .GET()\n                .build();\n\n        HttpResponse\u003cString\u003e response = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        System.out.println(\"응답 코드: \" + response.statusCode());\n        System.out.println(\"응답 본문: \" + response.body());\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로컬 변수 타입 추론 (var):\n\n- 자바 10에서는 var 키워드를 사용하여 로컬 변수 타입 추론 기능을 도입했습니다. 이를 통해 개발자는 타입을 명시적으로 지정하지 않고 로컬 변수를 선언할 수 있으며, 할당된 값에 기반하여 컴파일러가 추론하도록 합니다.\n\n```js\npublic class LocalVarInference {\n\n    /**\n     * 허용: 로컬 변수로만 사용\n     * 허용되지 않음: 클래스 필드, 메소드 매개변수 등 다른 곳 (멤버 변수, 여타곳)\n     * var 키워드 책임있게 사용하는 것이 좋습니다!\n     *\n     * 사용 사례:\n     *  - 타입이 명확한 경우 (문자열, 정수)\n     *  - 너무 긴, 복잡한 타입을 줄이기 위하여\n     *\n     * 사용하지 말아야 할 때:\n     *      - 반환 값이 명확하지 않은 경우 (var data = service.getData();)\n     */\n\n    public static void main(String[] args) {\n\n        // 허용되지만 장점이 별로 없음\n        var b = \"b\";\n        var c = 5; // int\n        var d = 5.0; // double\n        var httpClient = HttpClient.newHttpClient();\n\n        // 추론할때 쉬운 경우 :)\n        var list = List.of(1, 2.0, \"3\");\n\n        // 이름이 긴 타입일 때 장점이 더욱 분명해집니다\n        var reader = new BufferedReader(null);\n        // vs.\n        BufferedReader reader2 = new BufferedReader(null);\n    }\n}\n```\n\nOptional API - 새로운 메소드가 도입되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class OptionalApi {\n\n    /**\n     * 새로운 .orElseThrow() 메서드\n     */\n    public static void main(String[] args) {\n\n        Optional\u003cFlight\u003e earliestFlight = FlightSchedule.getFlights()\n                .stream()\n                .filter(f -\u003e \"Boston\".equals(f.from()))\n                .filter(f -\u003e \"San Francisco\".equals(f.to()))\n                .min(comparing(Flight::date));\n\n        earliestFlight.orElseThrow(FlightNotFoundException::new);\n    }\n}\n```\n\nHTTP client\n\n```java\npublic class HttpClientBasicExample {\n\n    /**\n     * 클라이언트 생성, GET 요청 보내기, 응답 정보 출력\n     */\n    public static void main(String... args) throws Exception {\n        HttpClient client = HttpClient.newHttpClient();\n\n        HttpRequest request =\n                HttpRequest.newBuilder(URI.create(\"https://github.com/\"))\n                        .GET()  // 기본값, 생략 가능\n                        .build();\n\n        HttpResponse\u003cString\u003e response =\n                client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        print(\"상태 코드: \" + response.statusCode());\n\n        print(response.headers().map());\n    }\n}\n```\n\n## 새로운 파일 메서드:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJava 11에서는 java.nio.file 패키지에 여러 가지 새로운 메서드가 추가되었는데, 파일 및 디렉토리 작업에 대한 추가 기능을 제공합니다. 주목할 만한 몇 가지 메서드는 다음과 같습니다:\n\n- Files.readString(Path path) 및 Files.writeString(Path path, CharSequence content, OpenOption... options):\n\n- 이러한 메서드를 사용하여 파일의 내용을 문자열로 읽고 쓰는 작업을 간단하게 처리할 수 있습니다. readString 메서드는 파일의 전체 내용을 문자열로 읽어오고, writeString 메서드는 문자열을 파일에 씁니다.\n\n2. Files.readAllLines(Path path) 및 Files.write(Path path, Iterable\u003c? extends CharSequence\u003e lines, OpenOption... options):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이러한 메서드는 파일 내용을 문자열 목록으로 읽고 쓰는 작업을 간단하게 해줍니다. readAllLines 메서드는 파일에서 모든 줄을 목록으로 읽고, write 메서드는 문자열 컬렉션을 파일에 쓰기 위한 메서드입니다.\n\n3. Files.newBufferedReader(Path path) 및 Files.newBufferedWriter(Path path, OpenOption... options):\n\n- 이러한 메서드는 파일을 효율적으로 읽고 쓰기 위한 버퍼드 리더와 라이터를 생성합니다. 이들은 문자 스트림을 다루는 프로세스를 간단하게 합니다.\n\n4. files.mismatch(Path path1, Path path2):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이 메서드는 두 파일의 내용을 비교하여 첫 번째 불일치하는 바이트의 위치를 반환합니다. 파일이 동일한 경우 -1을 반환합니다.\n\n```js\npublic class NewFilesMethods {\n\n    static String filePath = System.getProperty(\"user.dir\") + \"/src/main/resources/\";\n    static String file_1 = filePath + \"file_1.txt\";\n\n    /**\n     * Files.readString() and .writeString()\n     */\n    public static void main(String[] args) throws IOException {\n\n        // 파일 읽기가 이제 훨씬 쉬워졌습니다.\n        // 대용량 파일과 사용하면 안됨\n        Path path = Paths.get(file_1);\n        String content = Files.readString(path);\n        print(content);\n\n        Path newFile = Paths.get(filePath + \"newFile.txt\");\n        if(!Files.exists(newFile)) {\n            Files.writeString(newFile, \"some str\", StandardOpenOption.CREATE);\n        } else {\n            Files.writeString(newFile, \"some str\", StandardOpenOption.TRUNCATE_EXISTING);\n        }\n    }\n}\n```\n\n## 콤팩트 숫자 포맷팅:\n\nJava 12에서 JEP 357의 일환으로 \"콤팩트 숫자 포맷팅\"이라는 새로운 기능이 소개되었습니다. 이 개선은 지역별 방식으로 대형 숫자를 더 간결하게 포맷하는 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\njava.text 패키지의 NumberFormat 클래스가 새로운 Style enum을 지원할 수 있도록 업데이트되었습니다. 이 Style에는 Style.SHORT 및 Style.LONG 상수가 포함되어 있습니다. 이러한 스타일은 특정 로케일에 기반해 큰 숫자를 간결한 형태로 포맷하는 데 사용할 수 있습니다.\n\n```java\nimport java.text.NumberFormat;\nimport java.util.Locale;\n\npublic class CompactNumberFormattingExample {\n    public static void main(String[] args) {\n        // 컴팩트 스타일의 숫자 포매터 생성\n        NumberFormat compactFormatter = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n\n        // 큰 숫자 형식화\n        System.out.println(\"Short Format: \" + compactFormatter.format(1000));  // 결과: 1K\n        System.out.println(\"Short Format: \" + compactFormatter.format(1000000));  // 결과: 1M\n\n        // 긴 형식의 컴팩트 스타일 숫자 포매터 생성\n        NumberFormat compactLongFormatter = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.LONG);\n\n        // 긴 스타일로 큰 숫자 형식화\n        System.out.println(\"Long Format: \" + compactLongFormatter.format(10000000));  // 결과: 10 million\n        System.out.println(\"Long Format: \" + compactLongFormatter.format(1000000000));  // 결과: 1 billion\n    }\n}\n```\n\n## String::indent (JEP 326):\n\n- Java 12의 String 클래스에는 indent(int n)이라는 새로운 메서드가 도입되었습니다. 이 메서드는 문자열의 각 줄의 들여쓰기를 지정된 공백 수만큼 조정하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nString indentedString = \"Hello\\nWorld\".indent(3);\n// indentedString이 이제 \"   Hello\\n   World\"가 됩니다.\n```\n\njava.util.Arrays에 추가된 새로운 메서드 (JEP 326):\n\n- Java 12에서는 java.util.Arrays 클래스에 copyOfRange 및 Comparator를 사용하는 equals 변형 등을 포함한 여러 새로운 메서드가 추가되었습니다.\n\njava.util.stream.Collectors의 개선 사항 (JEP 325):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Java 12에서 도입된 Collectors 유틸리티 클래스에는 teeing과 같은 새로운 수집기가 추가되었는데, 이를 사용하면 두 개의 수집기를 결합하여 하나의 수집기로 만들 수 있습니다.\n\n## 새로운 파일 메소드:\n\n```js\npublic class NewFilesMethod {\n\n    static String filePath = System.getProperty(\"user.dir\") + \"/src/main/resources/\";\n    static String file_1 = filePath + \"file_1.txt\";\n    static String file_2 = filePath + \"file_2.txt\";\n\n    public static void main(String[] args) throws IOException {\n\n        // 두 파일의 내용에서 첫 번째 불일치하는 바이트의 위치를 찾아 반환합니다.\n        // 불일치가 없는 경우 -1L을 반환합니다.\n        long result = Files.mismatch(Paths.get(file_1), Paths.get(file_2));\n\n        print(result);      // -1\n    }\n}\n```\n\n특별히 흥미로운 일은 없었습니다:\n\n- ByteBuffer에 대한 API 업데이트\n- 지역화 업데이트 (새로운 문자 및 이모지 지원)\n- GC 업데이트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## “Switch Expressions” (SE) 대신 “Switch Statements” (SS):\n\n향상된 Switch 표현식:\n\n- Java 12에서 미리보기 기능으로 소개되었으며 Java 13에서 최종화된 스위치 표현식은 개발자들이 switch 문을 표현식으로 사용할 수 있도록 해주어 더 간결하고 표현력 있는 구문을 제공합니다.\n\n```java\nint dayOfWeek = 2;\nString dayType = switch (dayOfWeek) {\n    case 1, 2, 3, 4, 5 -\u003e \"평일\";\n    case 6, 7 -\u003e \"주말\";\n    default -\u003e throw new IllegalArgumentException(\"유효하지 않은 요일: \" + dayOfWeek);\n};\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"수확\" 문장:\n\n- \"수확\" 문장은 스위치 표현식을 보완하기 위해 Java 14에서 소개되었습니다. 이를 사용하여 스위치 암에서 반환할 값을 지정할 수 있어, 명령형과 함수형 스타일을 융합하는 데 더 많은 유연성을 제공합니다.\n\n```js\nString dayType = switch (dayOfWeek) {\n    case 1, 2, 3, 4, 5 -\u003e {\n        System.out.println(\"근무일\");\n        yield \"평일\";\n    }\n    case 6, 7 -\u003e {\n        System.out.println(\"주말\");\n        yield \"주말\";\n    }\n    default -\u003e throw new IllegalArgumentException(\"유효하지 않은 요일: \" + dayOfWeek);\n};\n```\n\n또 다른 예시,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n/**\n * \"스위치 표현식\" (SE) 대신 \"스위치 문\" (SS)\n * (둘 다 사용할 수 있지만 SE가 SS보다 낫습니다)\n */\npublic class SwitchExpressions {\n\n    public static void main(String[] args) {\n\n        oldStyleWithBreak(FruitType.APPLE);\n\n        withSwitchExpression(FruitType.PEAR);\n\n        switchExpressionWithReturn(FruitType.KIWI);\n\n        switchWithYield(FruitType.PINEAPPLE);\n    }\n\n    // 예전 방식은 더 복잡하고 오류 발생 가능성이 높음 (\"break;\"을 잊으면 switch가 지나가버릴 수 있음)\n    private static void oldStyleWithBreak(FruitType fruit) {\n        print(\"==== break를 사용한 예전 방식 ====\");\n        switch (fruit) {\n            case APPLE, PEAR:\n                print(\"보통 과일\");\n                break;\n            case PINEAPPLE, KIWI:\n                print(\"이국적인 과일\");\n                break;\n            default:\n                print(\"정의되지 않은 과일\");\n        }\n    }\n\n    private static void withSwitchExpression(FruitType fruit) {\n        print(\"==== 스위치 표현식을 사용한 방식 ====\");\n        switch (fruit) {\n            case APPLE, PEAR -\u003e print(\"보통 과일\");\n            case PINEAPPLE -\u003e print(\"이국적인 과일\");\n            default -\u003e print(\"정의되지 않은 과일\");\n        }\n    }\n\n    private static void switchExpressionWithReturn(FruitType fruit) {\n        print(\"==== 반환 값이 있는 경우 ====\");\n\n        // 직접 \"return switch\"을 사용할 수도 있음\n        String text = switch (fruit) {\n            case APPLE, PEAR -\u003e \"보통 과일\";\n            case PINEAPPLE -\u003e \"이국적인 과일\";\n            default -\u003e \"정의되지 않은 과일\";\n        };\n        print(text);\n    }\n\n    /**\n     * \"Yield\"는 \"return\"과 비슷하지만 중요한 차이가 있음:\n     * \"yield\"는 값을 반환하고 switch 문을 종료함. 실행은 특정 메서드 내에서 유지됨\n     * \"return\"은 switch문 및 특정 메서드를 종료함\n     */\n    // https://stackoverflow.com/questions/58049131/what-does-the-new-keyword-yield-mean-in-java-13\n    private static void switchWithYield(FruitType fruit) {\n        print(\"==== yield를 사용한 경우 ====\");\n        String text = switch (fruit) {\n            case APPLE, PEAR -\u003e {\n                print(\"주어진 과일은: \" + fruit);\n                yield \"보통 과일\";\n            }\n            case PINEAPPLE -\u003e \"이국적인 과일\";\n            default -\u003e \"정의되지 않은 과일\";\n        };\n        print(text);\n    }\n\n    public enum FruitType {APPLE, PEAR, PINEAPPLE, KIWI}\n}\n```\n\n## 텍스트 블록\n\n텍스트 블록은 여러 줄에 걸친 문자열 리터럴을 나타내는 새로운 유형의 리터럴입니다. 여러 줄에 걸친 소스 코드의 문자열을 작성하고 유지하는 작업을 간단하게 만들면서 이스케이프 시퀀스를 피하려고 합니다.\n\n텍스트 블록을 사용하지 않은 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nString html = \"\"\"\n\u003chtml\u003e\n    \u003cbody\u003e\n        \u003cp\u003eHello, world\u003c/p\u003e\n    \u003c/body\u003e\n\u003c/html\u003e\n\"\"\";\n```\n\n텍스트 블록의 주요 기능은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 여러 줄 문자열: 텍스트 블록을 사용하면 여러 줄 문자열을 더 자연스럽게 표현할 수 있어 코드 가독성을 향상시킵니다.\n- 공백 제어: 각 줄의 시작과 끝 공백이 제거되어 들여쓰기를 더 잘 제어할 수 있습니다.\n- 이스케이프 시퀀스: 텍스트 블록 내에서 이스케이프 시퀀스는 여전히 유효하며 특수 문자를 포함할 수 있습니다.\n\n텍스트 블록은 HTML, XML, JSON 또는 SQL 쿼리와 같은 여러 줄 콘텐츠를 포함하는 문자열을 더 쉽게 표현할 수 있도록 설계되었습니다. Java 15나 이후 버전에서 텍스트 블록과 관련된 업데이트나 새로운 기능이 있었을 경우 해당 버전의 공식 문서나 릴리스 노트를 확인하는 것이 좋습니다.\n\n```js\n/**\n * TextBlocks에 대한 사용 사례 (Java 15의 새로운 기능 \u003e Text Blocks in Practice)\n * - 마크다운을 사용한 텍스트 블록\n * - 테스트, 하드 코딩된 JSON 문자열 정의\n * - 간단한 템플릿\n */\npublic class TextBlocks {\n\n    public static void main(String[] args) {\n        oldStyle();\n        emptyBlock();\n        jsonBlock();\n        jsonMovedEndQuoteBlock();\n        jsonMovedBracketsBlock();\n    }\n\n    private static void oldStyle() {\n        print(\"******** 기존 스타일 ********\");\n\n        String text = \"{\\n\" +\n                \"  \\\"name\\\": \\\"John Doe\\\",\\n\" +\n                \"  \\\"age\\\": 45,\\n\" +\n                \"  \\\"address\\\": \\\"Doe Street, 23, Java Town\\\"\\n\" +\n                \"}\";\n        print(text);\n    }\n\n    private static void emptyBlock() {\n        print(\"******** 빈 블록 ********\");\n        String text = \"\"\"\n                \"\"\";\n        print(\"|\" + text + \"|\");\n    }\n\n    private static void jsonBlock() {\n        print(\"******** JSON 블록 ********\");\n\n        String text = \"\"\"\n                {\n                  \"name\": \"John Doe\",\n                  \"age\": 45,\n                  \"address\": \"Doe Street, 23, Java Town\"\n                }\n                \"\"\"; // \u003c-- 첫 번째 \" 문자와 정렬되어 있으면 들여쓰기 없음\n        print(text);\n    }\n\n    private static void jsonMovedEndQuoteBlock() {\n        print(\"******** JSON 이동된 끝 따옴표 블록 ********\");\n\n        String text = \"\"\"\n                  {\n                    \"name\": \"John Doe\",\n                    \"age\": 45,\n                    \"address\": \"Doe Street, 23, Java Town\"\n                  }\n                       \"\"\";\n        print(text);\n    }\n\n    private static void jsonMovedBracketsBlock() {\n        print(\"******** JSON 이동된 괄호 블록 ********\");\n\n        String text = \"\"\"\n                  {\n                    \"name\": \"John Doe\",\n                    \"age\": 45,\n                    \"address\": \"Doe Street, 23, Java Town\"\n                  }\n                \"\"\"; // \u003c-- 세 번째 \" 문자와 정렬되어 2칸 들여쓰기\n        print(text);\n    }\n}\n```\n\n## instanceof에 대한 패턴 매칭:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바 16의 instanceof에 대한 패턴 매칭은 유용한 기능으로 형식 검사와 추출을 개선합니다. 여기에 이 기능의 주요 측면을 요약해 두었어요:\n\n기능:\n\n- 단일 형식 대신 타입 패턴을 소개합니다.\n- instanceof 검사 내에서 추출된 객체를 보유할 변수를 선언할 수 있습니다.\n- 형식 검사 및 캐스팅을 더 간결하고 가독성 있게 결합한 표현입니다.\n\n혜택:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 번거로운 코드 줄이기: 별도의 instanceof 확인, 형 변환 및 변수 선언이 필요 없게 합니다.\n- 가독성 향상: 코드가 더 명확해지고 복잡한 유형 계층 구조에 대해 이해하기 쉬워집니다.\n- 오류 감소: 잘못된 유형으로 인한 캐스트 예외 발생 가능성이 줄어듭니다.\n\n구문\n\n```javascript\nif (obj instanceof String s) {\n  // 여기서 \"s\"를 String으로 직접 사용\n} else if (obj instanceof List\u003cInteger\u003e list) {\n  // 여기서 \"list\"를 List \u003cInteger\u003e로 직접 사용\n} else {\n  // 다른 경우 처리\n}\n```\n\n예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class PatternMatchingForInstanceof {\n\n    public static void main(String[] args) {\n\n        Object o = new Book(\"Harry Potter\", Set.of(\"Jon Doe\"));\n\n        // 옛날 방식\n        if (o instanceof Book) {\n            Book book = (Book) o;\n            print(\"The book's author(s) are \" + book.getAuthors());\n        }\n\n        // 새 방식\n        if (o instanceof Book book) {\n            print(\"The book's author(s) are \" + book.getAuthors());\n        }\n\n    }\n}\n```\n\n## 레코드:\n\n자바의 레코드는 변경할 수 없는 데이터를 보관하기 위해 특별히 설계된 특수한 유형의 클래스입니다. 이는 단순한 데이터 구조를 처리할 때 보일러플레이트 코드를 줄이고 가독성 및 유지보수성을 향상시킬 수 있도록 도와줍니다.\n\n- 이들의 주요 특성을 살펴봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 간결함:\n\n- 기존 클래스와는 달리 레코드는 정의하는 데 필요한 코드가 최소화됩니다. 레코드 선언에서 데이터 필드(구성 요소)만 지정하면 됩니다. 그러면 컴파일러가 다음과 같은 필수 메서드를 자동으로 생성합니다:\n- 각 구성 요소에 대한 매개변수가 있는 생성자.\n- 각 구성 요소에 대한 게터.\n- 구성 요소 값을 기반으로 한 equals 및 hashCode 메서드.\n- 레코드의 상태를 나타내는 toString 메서드.\n\n2. 변경 불가능성:\n\n- 레코드 필드는 final로 선언되어 있어, 레코드가 생성된 후에는 그 내부에 저장된 데이터를 변경할 수 없습니다. 이는 데이터 일관성을 보장하고 스레드 안전성에 대한 고려사항을 단순화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 가독성:\n\n- 레코드의 자동 생성 메서드와 예측 가능한 동작은 코드 가독성을 향상시키고 레코드가 어떤 것을 나타내며 프로그램의 다른 부분과 어떻게 상호 작용하는지 이해하기 쉽게 만듭니다.\n\n4. 오류 감소:\n\n- 보일러플레이트를 최소화함으로써 레코드는 getter를 잊거나 equals를 잘못 구현하는 것과 같은 일반적인 실수의 위험을 줄입니다. 이는 더 견고하고 신뢰할 수 있는 코드로 이어집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전반적으로 레코드는 Java 개발자가 간결하고 불변 그리고 가독성 좋은 데이터 구조를 만드는 데 유용한 도구입니다. 이는 보다 깔끔하고 유지보수 가능한 코드를 유도합니다.\n\n```js\n/**\n * 레코드는 데이터 전용 불변 클래스입니다 (따라서 특정한 사용 사례가 있음)\n * 클래스의 특정 형태(예: enum과 같은)로 제한된(전문화된) 형태입니다\n * 상태 변경 등을 의도한 객체에는 적합하지 않습니다.\n * \u003cp\u003e\n * 레코드는 다음과 관련이 없습니다:\n * - 보일러플레이트 감소 기법\n * \u003cp\u003e\n * 레코드는 생성자, 게터, 필드; equals, hashCode, toString을 생성합니다\n * \u003cp\u003e\n * 사용 사례:\n * - 불변 데이터 모델링\n * - 데이터를 읽기 전용으로 메모리에 보관\n * - DTOs - 데이터 전송 객체\n */\npublic class RecordsDemo {\n\n    public static void main(String[] args) {\n        Product p1 = new Product(\"우유\", 50);\n        Product p2 = new Product(\"우유\", 50);\n\n        print(p1.price()); // \"get\" 접두사 없이 사용\n        print(p1);         // 자동으로 생성된 toString() 출력- Product[name=우유, price=50]\n\n        print(p1 == p2);       // false    - 다른 객체\n        print(p1.equals(p2));  // true     - 값들(milk, 50)은 auto-generated equals()/hashCode()에 의해 비교됨\n    }\n}\n\n/**\n * 매개변수를 \"Components\"라고 함\n * 더 많은 필드 원할 시, 시그니처에 추가 필요\n * 확장은 허용되지 않지만 인터페이스 구현은 가능\n */\npublic record Product(String name, int price) {\n\n    // 정적 필드는 가능하지만 비정적은 허용하지 않음\n    static String country = \"US\";\n\n    // 모든 필드를 가진 생성자가 생성됨\n\n    // Validation 추가 가능\n    public Product {\n        if(price \u003c 0) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    // toString()과 같은 auto-generated 메소드들 오버라이딩 가능\n}\n```\n\n## 날짜 및 시간 형식 API:\n\n- Java 16의 DateTimeFormatter API의 일반적 사용법 및 기능: 형식 패턴 이해, 사용자 정의 형식 생성, 날짜 및 시간 구문 분석, 사용 가능한 형식 설정 포함\n- Java 16에서 소개된 날짜 형식팅을 위한 새로운 기능: 특히 \"B\" 심볼과 다양한 스타일을 사용한 일시 지원\n- SimpleDateFormat과 같은 이전 서식기와 DateTimeFormatter의 비교: 각 접근 방식의 장단점 탐색\n- 특정 형식 작업에 DateTimeFormatter 사용 예제: 다양한 로케일에서 날짜 형식화, 타임존 처리, 더 사람이 이해하기 쉬운 표현 생성하기 등을 포함하여.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class DateTimeFormatterApi {\n\n    static Map\u003cTextStyle, Locale\u003e map = Map.of(\n            TextStyle.FULL, Locale.US,\n            TextStyle.SHORT, Locale.FRENCH,\n            TextStyle.NARROW, Locale.GERMAN\n    );\n\n    public static void main(String[] args) {\n\n        for (var entry : map.entrySet()) {\n\n            LocalDateTime now = LocalDateTime.now();\n            DateTimeFormatter formatter = new DateTimeFormatterBuilder()\n                    .appendPattern(\"yyyy-MM-dd hh:mm \")\n                    .appendDayPeriodText(entry.getKey())    // at night, du soir, abends, etc.\n                    .toFormatter(entry.getValue());\n\n            String formattedDateTime = now.format(formatter);\n            print(formattedDateTime);\n        }\n    }\n}\n```\n\n## Stream API의 변경 사항:\n\nJava 16에서 Stream API에 흥미로운 변경 사항이 있었습니다. 더욱 강력하고 편리하게 사용할 수 있게 되었습니다. 주요 하이라이트는 다음과 같습니다:\n\n1. Stream.toList() 메서드: 이 새로운 메서드는 스트림의 요소를 목록으로 수집하는 간결한 방법을 제공합니다. 이전에는 collect(Collectors.toList())를 사용해야 했지만, 이제는 약간 중복된 방법입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Stream.mapMulti() 메소드: 이 메소드를 사용하면 스트림의 각 요소를 제로 또는 그 이상의 요소로 매핑하여 결과 요소의 새로운 스트림을 생성할 수 있습니다. 복잡한 데이터 구조를 분할하거나 펼치는 데 편리합니다.\n\n3. 향상된 줄 바꿈 처리: Java 16에서 java.io.LineNumberReader 클래스에서 줄 바꿈자를 정의하는 방법을 명확히하였습니다. 이는 모순을 제거하고 줄 기반 데이터를 읽을 때 일관된 동작을 보장합니다.\n\n4. 기타 작은 변경점:\n\n- 이제 문자열 스트림은 중간 작업이 필요하지 않고 limit 및 skip 메소드를 직접 지원합니다.\n- peek 메소드를 병렬 스트림과 함께 사용할 수 있으므로 병렬성에 영향을주지 않고 부작용을 발생시킬 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class StreamApi {\n\n    public static void main(String[] args) {\n\n        List\u003cInteger\u003e ints = Stream.of(1, 2, 3)\n                .filter(n -\u003e n \u003c 3)\n                .toList();  // new, instead of the verbose .collect(Collectors.toList())\n\n        ints.forEach(System.out::println);\n\n    }\n}\n```\n\n## Sealed classes(Subclassing):\n\nSealed 클래스는 Java 17 (JEP 409)에서 소개된 새로운 기능으로 상속 계층구조에 대해 더 많은 제어를 제공합니다. 본질적으로 클래스나 인터페이스를 확장하거나 구현하는 것을 제한할 수 있습니다. 이는 다양한 이유로 매우 유용할 수 있습니다:\n\n1. 향상된 타입 안전성: 허용된 하위 클래스를 명시함으로써 코드를 손상시키거나 보안 취약점을 도입할 수 있는 예기치 않은 확장을 방지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 개선된 라이브러리 디자인: 라이브러리 내에서 폐쇄된 생태계를 만들 수 있어서, 사용자가 승인된 확장 기능만 사용하고 호환되지 않는 구현을 만들지 않도록 보장할 수 있습니다.\n\n3. 쉬운 코드 유지 관리: 가능한 서브클래스 집합을 정확히 알면 코드에 대한 추론이 간단해지며 이해와 유지보수가 쉬워집니다.\n\nsealed 클래스는 어떻게 작동합니까?\n\nsealed 키워드를 사용하여 클래스 또는 인터페이스를 sealed로 선언합니다. 그런 다음 permits 절을 사용하여 확장하거나 구현할 수 있는 클래스 목록을 지정합니다. 이 허용된 클래스만 직접 상속할 수 있고, 다른 모든 클래스는 금지됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsealed class Shape {\n  permits Circle, Square, Triangle;\n  // ... 구현 세부사항\n}\n\nclass Circle extends Shape {\n  // ...\n}\n\n// 사각형이 허용되지 않아 컴파일 오류가 발생합니다\nclass Rectangle extends Shape {\n  // ...\n}\n```\n\n봉인된 클래스나 인터페이스는 지정된 클래스와 인터페이스만이 상속하거나 구현할 수 있습니다.\n\n이점:\n\n- 1. 의도를 전달하여 잘 정의되고 제한된 가능한 구현을 강제화할 수 있음\n- 2. 더 나은 보안 — 제 3자 코드로부터의 예기치 않은 또는 무단 서브클래싱과 행위 예방을 돕습니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n규칙:\n\n- 1. sealed 클래스는 \"permits\"를 사용하여 다른 클래스가 하위 클래스로 지정될 수 있게 합니다.\n- 2. 하위 클래스는 반드시 final, sealed 또는 non-sealed 이어야 합니다. (그렇지 않으면 코드가 컴파일되지 않습니다)\n- 3. 허용된 하위 클래스는 상위 sealed 클래스를 확장해야 합니다. permit을 사용하지 않고 허용하는 것은 허용되지 않습니다.\n- 4. permits로 지정된 클래스들은 상위 클래스와 근접하게 위치해야 합니다:\n  - 동일한 모듈에 있어야 합니다 (상위 클래스가 명명된 모듈에 있는 경우) (Java 9 모듈화 참조)\n  - 동일한 패키지에 있어야 합니다 (상위 클래스가 무명 모듈에 있는 경우).\n\n4번 항목에 대한 더 자세한 내용:\n\n- Sealed 클래스와 그 (직접적인) 하위 클래스는 함께 컴파일되고 유지되어야 하기 때문에 밀접하게 결합됩니다.\n- 모듈화된 환경에서는 \"동일한 모듈\"; 모듈화되지 않은 환경에서는 이를 가장 잘 나타내는 것이 \"동일한 패키지\"입니다.\n- 모듈을 사용한다면 모듈이 제공하는 안전한 경계 때문에 몇 가지 추가적인 유연성을 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 기본 UTF-8 설정:\n\nJava 18에서는 플랫폼의 기본 문자 인코딩이 UTF-8로 변경되었습니다. 이는 현대 표준에 맞추어 문자 처리를 간소화하고 있습니다.\n\n```js\npublic class Utf8ByDefault {\n\n    // https://openjdk.org/jeps/400 - Platform Default Encoding\n\n    public static void main(String[] args) throws IOException {\n\n        // 문제:\n        // 1) 윈도우에서는 아스키 테이블 외의 문자, 예를 들어 특이한 유니코드 문자,을 지정하지 않고 FileWriter을 사용하여 쓰기\n        // 2) 파일을 맥과 같은 UNIX 기반 OS로 복사하거나 전송한 다음 시스템의 기본 문자 인코딩을 사용하여 파일을 읽음\n        // 3) 예상되는 결과 - 엉망인 출력\n        // 따라서 문제는 예측불가능한 동작입니다.\n        FileWriter writer = new FileWriter(\"out.txt\");\n\n        // Java 18 이전의 해결책: 항상 문자 집합을 지정하십시오 (그리고 그것을 잊지 않도록 행운을 빕니다!)\n        FileWriter writer2 = new FileWriter(\"out.txt\", StandardCharsets.UTF_8);\n\n        // Java 18부터의 해결책: UTF-8은 이제 기본값이므로 문자 집합을 지정할 필요가 없습니다.\n\n    }\n}\n```\n\n## 간단한 웹 서버:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 새로운 API는 정적 파일을 제공하는 기본 웹 서버를 제공하여 빠른 프로토타이핑 및 임베디드 애플리케이션에 이상적입니다.\n\n- 시스템에 Java 18 이상이 설치되어 있는지 확인합니다.\n- 정적 파일(HTML, CSS, JavaScript, 이미지 등)을 특정 디렉토리에 준비해 두세요.\n\n```js\nimport com.sun.net.httpserver.HttpServer;\nimport com.sun.net.httpserver.SimpleFileServer;\n\nimport java.net.InetSocketAddress;\n\npublic class SimpleWebServer {\n    public static void main(String[] args) throws Exception {\n        String documentRoot = \"/path/to/your/static/files\";  // 실제 디렉토리로 교체합니다\n        int port = 8080;  // 필요에 따라 포트를 변경할 수 있습니다\n\n        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);\n        SimpleFileServer fileServer = new SimpleFileServer(documentRoot);\n        server.setExecutor(null);  // 단일 스레드 실행자 사용\n        server.createContext(\"/\", fileServer);\n\n        server.start();\n        System.out.println(\"포트 \" + port + \"에서 서버가 시작되었습니다.\");\n    }\n}\n```\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n    \u003ctitle\u003e문서 제목\u003c/title\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n이 페이지는 \"jwebserver\" 명령을 사용하여 Java의 Simple Web Server로 제공될 수 있습니다.\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같은 방법으로 실행해보세요:\n\n1. Java 파일 컴파일하기: javac SimpleWebServer.java\n2. 컴파일된 클래스 실행하기: java SimpleWebServer\n\n접속하기:\n\n- 웹 브라우저를 열고 http://localhost:8080 (또는 지정된 포트)로 이동합니다.\n- 정적 파일 디렉토리에서 기본 파일 (보통 index.html)이 제공되는 것을 확인할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n5. 서버를 중지하는 방법:\n\n- 서버를 중지하려면 실행 중인 터미널에서 Ctrl+C를 누릅니다.\n\n가장 간단한 방법으로 시작하기:\n\n1. 이 패키지(java18)에서 터미널을 엽니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. \"java -version\"을 실행하고 Java가 적어도 18 버전인지 확인해주세요.\n\n3. \"jwebserver\" 명령어를 실행해주세요.\n\n다음과 같은 메시지가 표시되어야 합니다:\n\n기본적으로 루프백에 바인딩됩니다. 모든 인터페이스에 대해 사용하려면 \"-b 0.0.0.0\" 또는 \"-b ::\"를 사용하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n127.0.0.1 포트 8000에서 경로/디렉토리 및 하위 디렉토리를 제공하고 있어요.\n\nURL http://127.0.0.1:8000/\n\nHTML 페이지는 이제 다음 주소에서 제공됩니다: http://127.0.0.1:8000/java18/doc.html\n\nIP 주소, 포트 및 기타 매개변수를 변경할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## HEAD() 편의 메서드 추가:\n\n```js\npublic class HttpHeadDemo {\n\n    /**\n     * HEAD() 편의 메서드 추가\n     */\n    public static void main(String[] args) throws IOException, InterruptedException {\n        HttpRequest head = HttpRequest.newBuilder(URI.create(\"https://api.github.com/\"))\n                .HEAD()\n                .build();\n\n        var response = HttpClient.newHttpClient().send(head, HttpResponse.BodyHandlers.ofString());\n\n        print(response);\n    }\n}\n```\n\nMethod Handles로 Core Reflection 재구현: 이 재구현은 리플렉션 기능의 성능과 안정성을 개선하기 위한 것입니다.\n\n제거를 위한 Finalization 과거화: 자원 정리를 위해 고안된 Finalization은 고유한 단점이 있습니다. 이를 과거화함으로써 더 안전하고 신뢰할 수 있는 대안들이 제공됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미리보기 또는 인큐베이터 기능:\n\n## 가상 스레드:\n\n이 기능은 운영 체제 스레드 위에서 실행되는 가벼운 스레드를 소개하여 이를 통해 동시 프로그래밍을 간단히하고 특정 작업 부하의 성능을 향상시키는 것을 목표로합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Java 21에서 가상 스레드를 소개하는 간단한 데모입니다:\n\n- 가상 스레드 생성:\n\n```js\nThread vThread1 = Thread.ofVirtual().start(() -\u003e {\n  for (int i = 0; i \u003c 10; i++) {\n    System.out.println(\"가상 스레드 1: \" + i);\n  }\n});\n\nThread vThread2 = Thread.ofVirtual().start(() -\u003e {\n  for (int i = 0; i \u003c 10; i++) {\n    System.out.println(\"가상 스레드 2: \" + i);\n  }\n});\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 완료 대기:\n\n```js\nvThread1.join();\nvThread2.join();\n```\n\n결과:\n\n이렇게 하면 두 가상 스레드의 출력이 교차되어 풀 OS 스레드의 오버헤드 없이 동시 실행이 나타납니다. 다음과 같은 내용을 볼 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n가상 스레드 1: 0\n가상 스레드 2: 0\n가상 스레드 1: 1\n가상 스레드 2: 1\n...\n가상 스레드 1: 9\n가상 스레드 2: 9\n```\n\n가상 스레드 설명:\n\n가상 스레드는 작은 기본 OS 스레드 풀 위에서 실행되는 가벼운 실행 단위입니다. 다음과 같은 여러 가지 장점을 제공합니다:\n\n- 가벼운 무게: OS 스레드와 비교하여, 가상 스레드는 생성 및 컨텍스트 전환 비용이 상당히 낮습니다.\n- 개선된 병행성: 제한된 수의 OS 스레드 내에 효율적으로 더 많은 가상 스레드를 관리할 수 있어서, 특정 작업 부하에 대한 자원을 더 잘 활용할 수 있습니다.\n- 단순화된 병행성 프로그래밍: 가상 스레드는 복잡한 스레드 관리와 동기화를 제거하여, 개발자들에게 병행 프로그래밍을 더 쉽게 만들어 줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 가상 스레드의 예제이며 OS/플랫폼 스레드와 대조적입니다. 이 프로그램은 ExecutorService를 사용하여 10,000개의 작업을 생성하고 모든 작업이 완료될 때까지 기다립니다. JDK는 배완 스레드와 OS 스레드의 제한된 수에서 이를 실행하여 쉽게 동시 코드를 작성할 수 있도록 지원합니다.\n\n```js\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    IntStream.range(0, 10_000).forEach(i -\u003e {\n        executor.submit(() -\u003e {\n            Thread.sleep(Duration.ofSeconds(1));\n            return i;\n        });\n    });\n}  // executor.close()는 암시적으로 호출되어 기다립니다\n```\n\n## 레코드 패턴 (프로젝트 앰버):\n\n레코드는 Java 14에서 미리보기로 도입되었으며, Java 열거형도 함께 제공되었습니다. record는 Java의 또 다른 특별한 종류이며, 클래스 개발 프로세스를 단순한 데이터 운반자로만 동작하는 클래스로 쉽게 만들 수 있도록 도와줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJDK 21에서 레코드 패턴과 타입 패턴을 중첩하여 사용하여 데이터 탐색 및 처리를 선언적이고 조합 가능한 형태로 가능하게 되었습니다.\n\n```java\n// 레코드 생성하기:\n\npublic record Todo(String title, boolean completed){}\n\n// 객체 생성하기:\n\nTodo t = new Todo(“Learn Java 21”, false);\n```\n\nJDK 21 이전에는 전체 레코드를 분해하여 액세서에 액세스해야 했습니다. 그러나 이제는 값들을 더 간단하게 얻을 수 있습니다. 예를 들어:\n\n```java\nstatic void printTodo(Object obj) {\n    if (obj instanceof Todo(String title, boolean completed)) {\n        System.out.print(title);\n        System.out.print(completed);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레코드 패턴의 다른 장점은 중첩된 레코드 및 해당 값에 액세스하는 기능입니다. JEP 정의 자체에서 제시된 예시는 ColoredPoint에 중첩된 Rectangle 내부의 Point 값을 얻는 능력을 보여줍니다. 이전보다 더 유용해졌습니다. 이전에는 레코드를 매번 분해해야 했는데, 이제 중첩된 레코드의 값을 쉽게 얻을 수 있습니다.\n\n```js\n// Java 21부터\nstatic void printColorOfUpperLeftPoint(Rectangle r) {\n    if (r instanceof Rectangle(ColoredPoint(Point p, Color c),\n                               ColoredPoint lr)) {\n        System.out.println(c);\n    }\n}\n```\n\n## 순차적 컬렉션:\n\nJDK 21에서는 새로운 컬렉션 인터페이스 세트가 소개되어 컬렉션 사용 경험을 향상시킵니다. 예를 들어, 컬렉션에서 요소의 역순을 얻고 싶다면, 사용 중인 컬렉션에 따라 번거로울 수 있습니다. 사용 중인 컬렉션에 따라 등장 순서를 가져오는 데 불일치가 있을 수 있습니다. 예를 들어, SortedSet은 하나를 구현하지만 HashSet는 그렇지 않기 때문에 서로 다른 데이터 세트에서 이 작업을 수행하는 것이 번거로울 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_2.png\" /\u003e\n\n이 문제를 해결하기 위해 SequencedCollection 인터페이스는 reverse 메서드를 추가하고 첫 번째 및 마지막 요소를 가져오는 기능을 제공하여 순서를 보장합니다. 또한 SequencedMap 및 SequencedSet 인터페이스도 있습니다.\n\n```js\ninterface SequencedCollection\u003cE\u003e extends Collection\u003cE\u003e {\n    // 새로운 메서드\n    SequencedCollection\u003cE\u003e reversed();\n    // Deque에서 승급된 메서드\n    void addFirst(E);\n    void addLast(E);\n    E getFirst();\n    E getLast();\n    E removeFirst();\n    E removeLast();\n}\n```\n\n## 문자열 템플릿:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문자열 템플릿은 JDK 21의 미리 보기 기능입니다. 그러나 이는 문자열 조작에 더 많은 신뢰성과 더 나은 경험을 제공하여 때로는 원하지 않는 결과로 이어질 수 있는 일반적인 함정을 피하기 위해 노력합니다. 이제 템플릿 표현식을 작성하고 문자열에서 렌더링할 수 있습니다.\n\n```java\n// Java 21부터\nString name = \"Ajay\";\nString greeting = \"Hello \\{name}\";\nSystem.out.println(greeting);\n```\n\n이 경우 두 번째 줄이 표현식이며 호출시 Hello Ajay를 렌더링해야 합니다. 또한 보안 문제를 일으킬 수 있는 SQL 문 또는 HTML과 같은 불법적인 문자열의 가능성이 있는 경우 템플릿 규칙은 이스케이프된 따옴표만 허용하고 HTML 문서에서는 불법 엔티티를 허용하지 않습니다.\n\n# 읽어 주셔서 감사합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 👏 위 이야기에 박수를 보내주시고 저를 팔로우해주세요 👉\n- 📰 미디엄에서 더 많은 콘텐츠를 읽어보세요 (자바 개발자 인터뷰에 관한 총 50개의 이야기)\n\n제 책들은 여기서 확인하실 수 있습니다:\n\n- 아마존에서 제공하는 [가이드: 명쾌한 자바 개발자 인터뷰 (킨들북)](Amazon) 및 Gumroad (PDF 형식).\n- Gumroad에서 제공하는 [가이드: 명쾌한 스프링 부트 마이크로서비스 인터뷰 (PDF 형식)] 및 아마존 (킨들 eBook).\n- 🔔 팔로우해보세요: LinkedIn | Twitter | YouTube\n","ogImage":{"url":"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png"},"coverImage":"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png","tag":["Tech"],"readingTime":46},{"title":"가장 많이 묻는 질문 - SOLID 원칙 JAVA","description":"","date":"2024-06-19 21:55","slug":"2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA","content":"\n![SOLID Principles in JAVA](/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png)\n\n- **S — Single Responsibility Principle (SRP)**\n  - Each unit of code should have only one responsibility.\n  - A unit can be a class, module, function, or component.\n  - Keeps code modular and reduces tight coupling.\n  - Example: A class that handles user authentication should not also manage database connections.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# O — Open/Closed Principle (OCP)\n\n- 코드 단위는 확장을 허용하고 수정을 제한해야 합니다.\n\n- 기존 코드를 수정하는 대신 새 코드를 추가하여 기능 확장.\n\n- React 프론트엔드와 같이 구성 요소 기반 시스템에서 유용합니다.\n  예: 로깅 시스템에 새 로그 핸들러를 생성하여 기능을 추가하는 것이 기존 핸들러를 변경하는 것보다 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# L — 리스코프 치환 원칙 (LSP)\n\n- 서브클래스는 기본 클래스로 대체 가능해야 합니다.\n- 기본 클래스의 기능은 모든 서브클래스에서 사용할 수 있어야 합니다.\n\n- 만약 서브클래스가 기본 클래스의 기능을 사용할 수 없다면, 그것은 기본 클래스에 있어서는 안 됩니다.\n  예: `새` 클래스에 `참새`와 `펭귄` 서브클래스가 있는 경우, 만약 `새`에 `날다` 메소드가 있다면, `펭귄`은 날지 못하기 때문에 상속받으면 안 됩니다.\n\n# I — 인터페이스 분리 원칙 (ISP)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 몇 개의 일반 목적이 아닌 구체적인 인터페이스를 제공해주세요.\n\n- 클라이언트는 사용하지 않는 메소드에 의존하면 안 됩니다.\n  예시: `Vehicle` 인터페이스를 `Drivable`과 `Flyable`로 분리하여 자동차 클래스가 `Flyable`을 구현할 필요가 없도록합니다.\n\n# D — 의존성 역전 원칙 (DIP)\n\n- 구체적인 클래스가 아닌 추상화에 의존해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 시스템의 부분 간 의존성을 분리시키기 위해 추상화를 사용하세요.\n\n- 인터페이스나 추상화를 사용하여 코드 유닠 사이에 직접 호출을 피하세요.\n  예: 특정 'FileLogger' 클래스 대신 로깅을 위해 'ILogger' 인터페이스를 사용하세요.\n","ogImage":{"url":"/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png"},"coverImage":"/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png","tag":["Tech"],"readingTime":3},{"title":"자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요","description":"","date":"2024-06-19 21:54","slug":"2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads","content":"\n혹시 팀 애플리케이션 서비스에 기능을 구현하려다가 예상대로 되지 않은 적이 있나요? 저도 정확히 그런 일이 발생했어요!\n\n# 제가 겪은 일을 설명하기 전에 가상 스레드를 살펴보죠\n\n\"가상 스레드는 대량 처리 동시 응용 프로그램의 작성, 유지 관리 및 관찰 노력을 크게 줄이는 가벼운 스레드입니다.\"\n— 참고: (https://openjdk.org/jeps/444)\n\n플랫폼 스레드의 문제는 I/O 작업 완료를 기다리는 시간입니다. 해당 스레드가 다른 작업을 수행할 수 없어 기본적으로 아이들 상태가 됩니다. 이는 많은 동시 요청을 처리하는 응용 프로그램에게 특히 비효율적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 사진에서 보여지는 시나리오에서 플랫폼 스레드가 두 번 블록되어 프로그램이 크게 느려질 수 있습니다. 이는 흔히 발생하는 일입니다. 그러나 이러한 상황을 해결하기 위해 리액티브 프레임워크라 불리는 비차단 솔루션이 등장했습니다.\n\nSpring Boot은 Project Reactor를 기반으로 한 Spring WebFlux 스택을 제공합니다. Spring WebFlux를 사용하는 개발자들은 전체 개발 프로세스를 수정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2017년, 자바 엔지니어들은 문제를 해결하기 위해 \"프로젝트 룸\"을 시작했습니다. 결국, 그들은 \"가상 스레드\"를 개발했습니다.\n\n![이미지](/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_2.png)\n\n가상 스레드의 주요 개념은 단일 가상 스레드가 여러 플랫폼 스레드에 장착될 수 있다는 것입니다. 가상 스레드는 블로킹 I/O 작업에서 오류가 발생할 때 현재 플랫폼 스레드에서 해제됩니다. 이 절차는 가상 스레드가 I/O 작업이 완료될 때까지 대기하는 동안 플랫폼 스레드가 다른 작업을 처리할 수 있도록 합니다. I/O 작업이 완료되면, 가상 스레드는 새로운 사용 가능한 플랫폼 스레드에 장착되어 실행을 계속할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 팀원이 점심 시간에 (블로킹 I/O)다른 플랫폼 스레드로 이동하여 소포 트럭이 중단되지 않고 여정을 계속할 수 있도록 하는 택배 회사의 전략을 상상해 보세요. 이 방식은 물류 운영 시간을 단축시키고 생산성을 높이며 회사를 경쟁력이 더 뛰어나게 만들었습니다.\n\n플랫폼 스레드 간으로 이동하여 마운트 및 언마운트함으로써 가상 스레드는 I/O 작업이 완료될 때까지 블록되지 않을 수 있습니다. 이는 플랫폼 스레드를 더 효율적으로 사용할 수 있게 하고 전반적인 대기 시간을 줄입니다.\n\n간단히 말하면, 단 한 줄의 코드 변경으로 서비스 성능을 향상시킬 수 있는 가장 간단한 방법입니다.\n\nSpring Boot에서 Java 가상 스레드를 활성화하려면 \"application.properties\"에 이 구성을 추가하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nspring.threads.virtual.enabled = true; // 클릭 한 번으로 쉽게 설정 !!\n```\n\n참고: 이 설정은 JDK 21 이상과 Spring Boot 3.2 이상을 필요로 합니다.\n\n# 성능 비교를 위한 테스트 API 빌드\n\n```js\n@RestController\npublic class PerformanceTestController {\n\n    @GetMapping(\"/test\")\n    public ResponseEntity\u003cString\u003e testPerformance() throws InterruptedException {\n\n        System.out.println(\"Sleeping ...\");\n        // CPU 바인드되지 않는 작업 시뮬레이션, 3초 동안 sleep\n        Thread.sleep(3000);\n\n        return ResponseEntity.ok(\"테스트 완료\");\n    }\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Apache HTTP 서버 벤치마킹 도구를 사용하여 서비스 성능을 측정할 수 있어요\n\n다양한 부하로 테스트하고 결과를 분석하여 개선할 수 있어요.\n\n여기 명령어에요.\n\n```js\nab -c 300 -n 1000 -r “http://localhost:8443/test\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- -c 300: 동시 요청 수입니다. 이 경우에는 서버를 동시에 폭격하기 위해 가상 사용자 [300]명이 시뮬레이션됩니다.\n- -n 1000: 최종적으로 실행될 총 요청 수입니다 [1000].\n- -r “http://localhost:8443/test”: 벤치마크 테스트 대상 URL입니다.\n\n테스트를 시작합니다. 첫 번째는 기존 방식을 사용하고, 두 번째는 가상 스레드가 활성화됩니다.\n\n가상 스레드 강력해요! 플랫폼 스레드보다 약 20% 빠른 속도로 동일한 작업을 완료합니다 (65.21 RPS 대 54.80 RPS). 그렇다면, 왜 제목에서 가상 스레드가 플랫폼 스레드보다 느리다고 말했을까요?\n\n# 실세계에서의 가상 스레드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 팀의 API 분석\n\n- GET 방식 사용 중\n- 요청 방식 검증\n- 데이터베이스에서 데이터 쿼리\n- RestClient를 통해 다른 서비스로 요청 보내기\n- 데이터베이스에 데이터 업데이트/저장\n\n성능 테스트 결과\n\n```js\n플랫폼 스레드: 587.24 TPS, 평균 응답 시간은 56.52ms\n가상 스레드: 502.80 TPS, 평균 응답 시간은 66.54ms\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가상 스레드가 플랫폼 스레드보다 느리다고 테스트 결과에서 나왔다니, 무슨 실수를 한 걸까요?\n\n# 핀닝, 발동한 숨겨진 함정\n\n![이미지](/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_4.png)\n\n캐리어 스레드는 가상 스레드가 현재 실행 중인 플랫폼 스레드를 정의하는 또 다른 용어입니다. 핀닝은 가상 스레드가 플랫폼 스레드에 매핑되어 있는 상태를 말하며, 캐리어 스레드에 붙어서 떨어질 수 없는 상태를 묘사합니다. 이는 가상 스레드의 상태를 힙 메모리에 저장할 수 없기 때문에 발생합니다. 핀닝된 스레드는 다른 스레드가 동일한 플랫폼 스레드를 사용하는 것을 막습니다. 몇 가지 가능한 원인을 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 동기화된 블록 또는 메서드: 한 번에 한 스레드만 들어갈 수 있습니다. 다른 스레드들은 현재(실행 중인) 스레드가 나갈 때까지 차단됩니다. 경합 조건을 방지하고 데이터의 정확한 상태를 유지하기 위해 공유 리소스에 중단되지 않은 액세스가 필요합니다.\n\n```js\nclass MyService {\n  public void calculateFee() {\n    synchronized (this) {\n      ...\n    }\n  }\n}\n```\n\n- 네이티브 메서드: 이 메서드를 사용하면 다른 언어의 코드(C 또는 C++ 등)를 Java 프로젝트에 통합할 수 있습니다. 네이티브 메서드는 Java 가상 머신 내에서 호출되지만 Java의 제어 범위 밖에서 실행됩니다.\n\nMyService.java\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class MyService {\n  public static void main(String[] args) {\n    System.out.println(calculateFee(5, 3));\n  }\n  public static native int calculateFee(int a, int b);\n  static {\n    // Loads the native library from file named \"nativemethod.c\".\n    System.loadLibrary(\"nativemethod\");\n  }\n}\n```\n\nnativemethod.c\n\n```c\n#include \u003cjni.h\u003e\n\nJNIEXPORT jint JNICALL Java_calculateFee (JNIEnv *env, jobject obj, jint a, jint b) {\n  return a * b;\n}\n```\n\n- 외부 함수: 다른 프로그래밍 언어로 작성된 함수로서, Foreign Function Interface (FFI)를 통해 가상 스레드에 노출된 함수입니다. FFIs는 다른 언어로 작성된 코드들이 함께 동작할 수 없는 상황에서 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic interface PythonFunctions extends Library {\n  /**\n   * 이 정적 final 필드는 `PythonFunctions` 인터페이스의 싱글톤 인스턴스를 생성합니다.\n   * 이는 `Library.getInstance` 메서드에서 인스턴스를 검색하고 이 인터페이스 유형으로 캐스팅합니다.\n   */\n  PythonFunctions INSTANCE = (PythonFunctions) Library.getInstance(\"python_functions\");\n  doubled calculateFee(doubled a, doubled b);\n}\n```\n\n# 다음 JVM 매개변수를 옵션으로 사용하여 고정된 스레드를 추적하세요\n\n- -Djdk.tracePinnedThreads=full: 고정된 상태에서 스레드가 고정되어 있을 때 완전한 스택 추적을 출력하며, 네이티브 프레임과 모니터를 보유한 프레임을 강조합니다.\n- -Djdk.tracePinnedThreads=short: 문제가 있는 프레임만을 포함하여 출력을 제한합니다.\n\n로그에는 가상 스레드 내에서의 메서드 호출의 스택 추적이 표시됩니다. 이 스레드는 JDBC(Java Database Connectivity) 및 특히 MySQL 연결과 상호 작용하는 메서드를 실행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주목할 점은 이러한 메서드 호출 중 몇 가지가 `= monitors:1` 표기를 포함하고 있어서 가상 스레드가 이 코드 실행 블록 내에서 계속 고정되어 있는 것을 나타낸다.\n\n# 버그 #110512 기여: synchronized를 ReentrantLock으로 교체\n\n마침내 깨달았어요. 저는 사용 중인 MySQL Connector/J 버전 8에서 가상 스레드를 지원하지 않는다는 것을.\n\n다음 단계로 나아가는 내 선택지입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- MySQL Connector/J 버전 9.0.0 이상으로 업그레이드하세요: 이 버전은 가상 스레드가 데이터베이스 상호 작용을 최적으로 수행하도록 합니다.\n- 새 라이브러리 탐험: 새 라이브러리를 찾아 새로운 코드를 작성하고 테스트해 보세요. 도전적이며 상당한 노력이 필요할 수 있습니다.\n\n# 한 발 물러서 두 발 앞으로!\n\n플랫폼 스레드에서 가상 스레드로의 전환을 통해 성능을 향상시키려는 시도는 \"피닝\"과 관련하여 예상치 못한 제약으로 인해 속도가 느려지는 문제가 발생했습니다. 결과적으로, 우리는 다시 플랫폼 스레드를 사용하도록 돌아갔습니다.\n\n지금은 성능을 개선하기 위한 대안 전략을 탐색하면서 버전 9.0.0의 릴리스를 기다리고 있습니다. 이는 새로운 기술을 도입하는 데 따르는 도전을 강조하며, 실행 전 철저한 테스트의 중요성을 강조합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png"},"coverImage":"/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png","tag":["Tech"],"readingTime":9},{"title":"자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기","description":"","date":"2024-06-19 21:50","slug":"2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures","content":"\n## 자바의 계속되는 중요성: 언어 진화에 대한 깊은 이해\n\n![image](/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_0.png)\n\n나는 예전에는 자바의 팬이 아니었지만, 최근 몇 년 동안 더 많이 귀하와 자바 언어와 생태계를 귀하했습니다. 특히 새 개인 프로젝트에 자바 21을 사용하기로 결정한 후 더욱 그랬습니다. JVM의 세계로 소개되는 것은 스칼라로 시작했는데, 이는 객체 지향과 함수형 프로그래밍 개념을 조화롭게 결합한 간결한 언어로서 타입 안전성에 중점을 둔 것이 특징입니다.\n\n그렇다면, 왜 스칼라를 사용하지 않았을까요? 자바를 선택한 이유 중 일부는 언어에 대한 새로운 흥미로운 개선 사항이 있었기 때문이며, 자바의 현재 상태인 생태계, 프레임워크 및 라이브러리를 좀 더 탐색하고 싶었기도 했습니다. JVM 플랫폼을 대상으로 한 다른 최신 언어들은 많지만, 그 중에서도 스칼라와 코틀린이 가장 많은 관심을 받은 것은 자바와 마찬가지로 강력하고 정적으로 타이핑된 프로그래밍 언어입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 자바 대 스칼라 대 코틀린 비교\n\n스칼라와 코틀린 중에서는 코틀린이 자바 경험이 있는 개발자들에게 더 익숙한 문법을 갖고 있으며, 자바와 완전히 상호 운용 가능하면서 자바의 일부 문제점을 해결하기 위해 고안된 더 현대적이고 간결한 언어로 주목받고 있습니다. 현재는 안드로이드 개발 공간에서 코틀린이 더 인기가 있습니다.\n\n한편, 스칼라는 데이터 엔지니어링 (아파치 스파크 등) 및 백엔드 응용 프로그램 개발에서 주로 인기를 누리고 있습니다. 스칼라는 덜 번잡한 문법을 갖고 있으며, 어떤 사람들은 특히 Scala3에 대해 파이썬의 스트레로이드 버전으로 비교할 수 있습니다. 더 견고한 타입 시스템을 갖추고 있어 컴파일 시간에 더 많은 오류를 제거하는 데 도움이 되는 특징이 있습니다.\n\n## 개발자들은 자바를 높게 평가합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스칼라, 코틀린 및 자바의 채택 및 인기에 대해 알아보겠습니다. 스택 오버플로 조사 및 TIOBE 그리고 Redmonk 언어 인기 지수를 살펴볼 예정입니다.\n\n다음은 스택 오버플로 결과를 기반으로 한 인기 언어 차트입니다. 여기서는 세 언어만을 선택하여 살펴보겠습니다.\n\n![이미지](/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_1.png)\n\n## Redmonk 언어 지수\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2023년 1월 현재 Redmonk 지수를 확인해보세요. 이 지수는 Github와 Stack Overflow 데이터를 기반으로 합니다. Java가 상위에 랭크되어 있고 Scala와 Kotlin도 비교적 높은 순위를 차지하고 있네요.\n\n![이미지](/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_2.png)\n\n## TIOBE 프로그래밍 지수\n\n이제 TIOBE 지수를 살펴보겠습니다. 이 지수는 25개 다른 검색 엔진에서의 검색어를 고려합니다. Java 또한 상위 언어 중 하나로 랭크되어 있습니다. Scala와 Kotlin은 상위 10위 안에 들지 못해서 차트에 표시되지 않았지만, 2023년 기준 Scala는 15위, Kotlin은 36위에 랭크되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Java Programming](/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_3.png)\n\nJava는 여전히 Kotlin 및 Scala와의 강력한 경쟁 속에서 매우 인기 있는 것을 볼 수 있습니다. 몇 년 동안 약간의 감소가 있었지만, 다른 프로그래밍 언어 및 생태계 (예: Python, Go, Rust)에 의해 조각이 빼앗겼습니다.\n\n# Java 탐험: 역호환성에 대한 헌신\n\nJava가 최근 몇 년간 무엇을 해 왔는지 및 강한 인기에 기여하는 다른 요소들을 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 인기는 Java의 DNA와 관련이 있습니다. Java의 DNA에는 강력한 하위 호환성을 유지하기로 한 의무가 포함되어 있습니다. 최근 몇 년간 투입적인 하위 호환성 파괴가 몇 차례 있었지만 이는 언어와 도구의 개선을 지원하기 위한 것입니다. 그러나 이러한 변경에 대해 평소보다 많은 고려와 타당한 이유가 있습니다. 이것이 Java가 기업 환경에서 인기를 얻는 큰 이유 중 하나입니다. JVM 플랫폼의 안정성이 더 많은 엔지니어가 생산적이며 비즈니스 문제 해결과 코드 출시에 집중할 수 있도록 해줍니다.\n\n## 고려할 Java 관련 요소\n\nJava 9부터 OpenJDK는 \"준비되었을 때 출시\"에서 6개월 주기로 변경되었습니다 - 3월과 9월에 각각 출시됩니다. 이 목표는 새로운 버전의 제공이 일부 향상이 준비되지 않아서 발생하는 지연을 완화하기 위한 것이었습니다. 이 작업을 수행하기 위해 미리보기 기능이라는 개념이 도입되었습니다. 특정 기능이 완전히 기능하나 여전히 파괴적인 변경의 영향을 받을 때, 해당 기능은 다음 버전에서 미리보기로 도입됩니다.\n\n이를 통해 개발자 커뮤니티가 피드백을 제공하고 다음 정기 릴리스에 최종화될 구현을 형성하는 데 도움을 줄 수 있습니다. 몇 년에 한 번씩 Oracle은 LTS (장기 지원 릴리스) 릴리스로 태깅된 다음 다른 JDK 공급 업체도 따를 것입니다. 예를 들어, Amazon Web Services는 Corretto JDK라는 자체 JDK 빌드를 유지하며 이에 대해 AWS가 장기적인 지원을 제공할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_4.png\" /\u003e\n\nJava의 또 다른 핵심인 마지막 이동자 장점에 대해 이야기해봅시다. 스칼라와 같은 다른 JVM 언어들은 상당히 빠른 속도로 진화합니다. 저는 여전히 스칼라를 사용하며 즐기고 있지만 그 역사적인 호환성 및 도구 이야기는 많이 부족한 것 같습니다 (하지만 계속 발전 중입니다!). 한편, 스칼라는 언어와 컴파일러 디자인을 새로운 수준으로 밀어올리는 최신 기술을 제공하고 있습니다.\n\n그러나 Java는 장기 게임을 펼치며, 산업이 어떻게 발전하는지 관찰하고, 다른 언어들이 무엇을 하고 있는지 평가하며, 잘 작동하는 부분을 골라내고 가장 유의미한 곳에서 언어를 개선합니다. Java 8 이후에 적용된 몇 가지 언어 개선 사항을 간략히 살펴보겠습니다.\n\n# Java 10의 'var' 키워드가 언어의 불필요한 길이에 미치는 영향\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 최신 언어에 이미 숙달된 개발자들이 Java를 배우고 있는 경우, 가장 싫어하는 점을 물어보면, 말이 많다는 것이 상위권에 오릅니다. Java 10이 출시되기 전까지는 할당의 왼쪽에 변수 유형을 명시적으로 선언해야 했습니다. Java 10에서는 실제 유형 대신 사용할 수 있는 새로운 특별한 \"var\" 키워드가 도입되었습니다. 컴파일 단계에서 Java 컴파일러가 할당의 오른쪽 표현식에서 추론된 실제 유형을 삽입할 것입니다.\n\n```js\n//Java 8\nHashMap map = new HashMap();\n\nDatabaseEngineColumnCacheImpl cache = new DatabaseEngineColumnCacheImpl();\n\nOptional accessRole = user.getUserAccessRole();\n\n//Java 10, 컴파일러에게 더 이상 실제 유형이 무엇인지 설득할 필요 없음\nvar map = new HashMap();\n\nvar cache = new DatabaseEngineColumnCacheImpl();\n\nvar accessRole = user.getUserAccessRole();\n```\n\n위는 몇 가지 중요치 않은 예제입니다. 그러나 이것은 코드를 읽을 때 말을 줄일 수 있습니다. 그러나 이것은 산업에서 새로운 것이 아닙니다. 다른 최신 정적 형식 프로그래밍 언어의 개발자들은 오랫동안 형식 추론을 즐겼습니다.\n\n예를 들어, Scala는 2004년에 처음 만들어진 이후부터 더 진보된 형식 추론을 가지고 있습니다. 그럼에도 불구하고, 이것은 Java에서 매우 환영받는 기능입니다. 형식 추론은 로컬 변수 선언에만 제한되는데, 즉 메소드 본문에서, 실제로 그것이 가장 중요한 곳입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## instanceof와 패턴 매칭으로 타입 체크 과제 극복하기\n\ninstanceof는 주어진 객체가 특정 타입인지 확인하기 위해 사용되는 언어 키워드입니다. 예를 들어, Object 타입의 객체가 주어졌을 때, 이 객체가 무엇인지 런타임에 실제 타입을 확인하여 해당 객체 타입에 특정한 작업을 실행해야 할 수 있습니다.\n\n다소 극단적으로 보일 수 있는 예제가 있습니다. Shape 인터페이스와 특정 모양을 나타내는 여러 클래스가 있다고 가정해 봅시다. 코드의 어딘가에서 모양의 둘레에 관한 정보를 얻고 싶을 때, 각 하위 클래스가 구현해야 하는 둘레 계산 메서드가 인터페이스에 명시되어 있지 않고 이 코드를 리팩토링할 수 없다고 가정해 봅시다.\n\n이 경우 해결책은 한 가지뿐입니다: 사각형 또는 원인지 확인하고 그에 따라 둘레를 계산하는 유틸리티 메서드를 구현하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n인터페이스 모양 {}\n\npublic class Rectangle implements Shape {\n    final double length;\n    final double width;\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n    }\n}\n\npublic class Circle implements Shape {\n    final double radius;\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n}\n\npublic static double getPerimeter(Shape shape) {\n    if (shape instanceof Rectangle) {\n        Rectangle r = (Rectangle) shape;\n        return 2 * r.length + 2 * r.width;\n    } else if (shape instanceof Circle) {\n        Circle c = (Circle) shape;\n        return 2 * c.radius * Math.PI;\n    } else {\n        throw new RuntimeException(\"Unknown shape\");\n    }\n}\n```\n\ngetPerimeter 메서드 구현을 살펴보면, 이미 타입을 확인했음에도 불구하고 여전히 다운캐스팅하고 연산을 수행하기 전에 새 변수를 선언해야 합니다. 이는 컴파일러가 여전히 shape를 Shape의 인스턴스로 보기 때문입니다.\n\ninstanceof의 패턴 매칭을 사용하면 if-else 블록의 범위 내에서 확인한 타입의 변수를 선언할 수 있습니다. Java 14에서 동일한 if-else 블록은 다음과 같이 보일 것입니다.\n\n```js\n  public static double getPerimeter(Shape shape) {\n    if (shape instanceof Rectangle r) {\n        return 2 * r.length + 2 * r.width;\n    } else if (shape instanceof Circle c) {\n        return 2 * c.radius * Math.PI;\n    } else {\n        throw new RuntimeException(\"Unknown shape\");\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 컴파일러의 좋은 개선이에요. 점점 똑똑해지고 더 나아졌어요. instanceof를 위한 패턴 매칭은 자바의 나중 버전에서 계속 확장되었던 큰 노력이었고, 레코드 클래스에 대한 패턴 매칭도 포함되었는데, 다음으로 다루고 싶은 큰 기능입니다.\n\n# 장황함에서 간결함으로, Java의 레코드가 데이터 클래스를 재정의해요\n\n이 부분은 꽤 중요해요, 적어도 제게는요. Scala가 데이터 클래스를 사용해서 모델링하는 것이 얼마나 쉬운지 정말 좋아해요. Java는 도메인 모델링에 능숙하다는 것으로 유명하지만, 레코드가 도입되기 전에 데이터 컨테이너나 POJO를 정의하는 과정이 매우 장황했었고, 이에 따라 반복적인 코드를 직접 작성하기보다는 코드 생성을 수행하는 다양한 라이브러리가 생겼죠 (예: 롬복).\n\n## 다음 예시를 살펴보죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class Person {\n    public final String id;\n    public final String name;\n    public final Integer age;\n\n    public Person(String id, String name, Integer age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n}\n\nvar p1 = new Person(\"a1b\", \"Frank\", 30)\nvar p2 = new Person(\"a1b\", \"Frank\", 30)\n\np1.equals(p2) // false, oops?\n```\n\n우선, 다른 고수준 프로그래밍 언어와 비교하면 이것은 이미 간단한 데이터 클래스를 정의한 매우 억양있는 문법이라고 볼 수 있습니다. 더구나, 이와 같은 방식으로 데이터를 모델링하고 싶을 때는 객체를 내용에 기반하여 비교할 수 있으면 좋겠지만, 이 예시에서는 (Java에 처음 접하는 경우) p1과 p2가 동일하다고 가정할 수 있겠지만 실제로는 그렇지 않습니다.\n\n이것은 Java에서 객체가 메모리의 참조이기 때문에 명시적으로 컴파일러에게 객체를 어떻게 동일한지 알려주지 않으면, equals()의 기본 전략은 메모리 주소를 비교하는 것입니다. 이것이 정확히 == 연산자가 하는 일입니다. 그렇다면, 우리의 Person 객체를 동일한 유형의 다른 인스턴스와 비교할 수 있게 하려면 어떻게 해야 할까요?\n\n```java\npublic class Person {\n    public final String id;\n    public final String name;\n    public final Integer age;\n\n    public Person(String id, String name, Integer age) {\n      this.id = id;\n      this.name = name;\n      this.age = age;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this) return true;\n      if (o == null || !(o instanceof Person)) return false;\n\n      Person p = (Person) o;\n      return Objects.equals(p.id, this.id) \u0026\u0026 Objects.equals(p.age, this.age) \u0026\u0026 Objects.equals(p.name, this.name);\n    }\n\n    @Override\n    public int hashCode() {\n      int hash = 7;\n      hash = 31 * hash + Objects.hashCode(id);\n      hash = 31 * hash + Objects.hashCode(name);\n      hash = 31 * hash + age;\n      return hash;\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n할 일이 상당히 많다는 것을 알게 되었네요. 객체를 비교하는 규칙을 정의하기 위해 equals 및 hashCode를 override해야 합니다. 롬복(Lombok)과 같은 라이브러리는 이러한 메서드를 생성해주므로 직접 작성하지 않아도 됩니다. 그러나 이제 Java에는 이를 고유하게 처리할 수 있는 방법이 있습니다.\n\nRecords가 등장합니다. Java 17부터(14부터 미리보기로 제공) record 키워드를 사용하여 클래스를 정의하는 새로운 방법이 있습니다. 이전 예제를 바탕으로 Records로 어떻게 개선할 수 있는지 살펴봅시다.\n\n```js\nrecord Person(String id, String name, Integer age) {};\n\nvar p1 = new Person(\"1ab\", \"Frank\", 30);\nvar p2 = new Person(\"1ab\", \"Frank\", 30);\n\np1.equals(p2); //true, 맞아요!\n\np1 == p2; //false, 여전히 두 개의 다른 인스턴스이기 때문에 예상대로입니다\n```\n\n## Java records의 'with' 탐색하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Java 컴파일러는 우리를 위해 bytecode를 즐겁게 생성해 줍니다. equals와 hashCode 메서드를 구현하기 위해 정의된 모든 매개변수를 고려합니다. 레코드 클래스는 toString 및 getter 메서드를 제공하지만 setter는 제공하지 않습니다. 레코드 클래스는 변경할 수 없도록 설계되어 있어 한 번 인스턴스가 생성되면 객체 멤버들을 읽기만 가능하고 값을 변경할 수 없습니다.\n\n변하지 않음으로써, 동시성 프로그램의 버그를 줄이고 코드를 이해하기 쉽게 만들어줍니다. 현재 업데이트된 인스턴스를 만드는 것은 약간 번거로운 일이며, 다른 레코드로부터 모든 인수를 복사해야 한다는 것이 필요하지만 Brian Goetz 자신이 프로젝트 Amber의 일부인 \"With for records\"라는 새로운 기능을 통해 나중에 이 부분이 바뀔 것이라고 희망합니다. — Java 언어 설계자인 Brian Goetz의 Amber 프로젝트의 일부인 초안 중에 설명되어 있습니다. 결국 기존 레코드 객체의 한 명 이상의 멤버를 수정하여 새로운 인스턴스를 생성할 수 있는 기능이 추가될 것입니다. 예를 들어:\n\n```js\n var p3 = p2 with { name = \"Joe\" };\n```\n\n이미 이를 해결하기 위해 도움이 되는 몇 가지 라이브러리가 있습니다. record-builder라는 이 github 프로젝트를 살펴볼 수 있습니다. 레코드 객체를 수정하는 제한사항을 해결하는 것 외에도 더 복잡한 데이터 클래스에 매우 유용한 빌더를 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바 레코드에는 이 예시가 보여주는 것 이상의 기능이 있습니다. 레코드의 다른 기능은 사용자 정의 생성자 정의 능력이 있고 기본 데이터에 작용할 수 있는 일반적인 메소드를 정의할 수 있는 것입니다. 또한 레코드의 직렬화는 변경 불가능성에 의해 일반 클래스의 인스턴스의 직렬화보다 간단하고 안전합니다. 레코드는 또한 값을 분해하여 사용할 수 있으며, 다음 기능, 레코드용 패턴 매칭에 활용되는 것입니다.\n\n# 레코드용 패턴 매칭\n\n레코드용 패턴 매칭은 자바 21에서 최종화되었습니다. 프로젝트 Amber의 일부로 제공되는 패턴 매칭과 레코드는 새로운 프로그래밍 패러다임인 데이터 지향 프로그래밍을 가능케 합니다. DOP(Data Oriented Programming)은 문제를 변경할 수 없는 데이터 구조로 모델링하고 변경되지 않는 일반적인 목적 함수를 사용하여 계산을 수행하는 것을 강조합니다. 이미 들어보신 것 같네요. 그렇습니다, 함수형 프로그래밍에서 잘 알려진 개념입니다! DOP 패러다임을 촉진하는 기능의 도입은 OOP를 대체하려는 것이 아니라, 특정 작업을 더 우아하게 해결하는 데 도움을 주기 위한 것입니다. OOP는 대규모 코드 경계를 정의하고 지배하는 데 훌륭하지만, DOP는 데이터를 모델링하고 작업하는 데 더 유용합니다.\n\n이게 전부가 아닌 걸로 갑시다. 패턴 매칭이란 무엇인가요? 클래스 생성자의 반대로 생각할 수 있습니다. 클래스 생성자는 데이터를 제공하여 객체를 생성할 수 있게 해주는 반면, 패턴 매칭은 객체 생성에 사용된 데이터를 분해하거나 추출할 수 있게 해줍니다. 실제로 이것이 어떻게 보이는지 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 패턴 매칭 예제\n\n이 예제에서는 레코드 클래스를 사용하여 서로 다른 트랜잭션 유형을 모델링하고, 목표는 트랜잭션 목록을 사용하여 계정 잔액을 계산하는 메서드를 작성하는 것입니다. 구매 유형인 경우 잔액을 증가시키고, 지불 유형인 경우 잔액을 감소시키며, 지불 취소된 경우에는 다시 잔액을 증가시키어야 합니다.\n\n```js\n public interface Transaction {\n    String id();\n}\n\nrecord Purchase(String id, Integer purchaseAmount) implements Transaction {}\n\nrecord Payment(String id, Integer paymentAmount) implements Transaction {}\n\nrecord PaymentReturned(String id, Integer paymentAmount, String reason) implements Transaction {}\n\nList transactions = List.of(\n    new Purchase(\"1\", 1000),\n    new Purchase(\"2\", 500),\n    new Purchase(\"3\", 700),\n    new Payment(\"1\", 1500),\n    new PaymentReturned(\"1\", 1500, \"NSF\")\n);\n```\n\n만약 우리가 트랜잭션을 정의하는 코드베이스에 액세스할 수 없거나, 이 코드 부분이 잔액을 계산하는 책임을 지지 않아야한다고 가정해 봅시다. 우리 코드에서 calculateAccountBalance를 구현하는 한 가지 방법은 다음과 같습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic static Integer calculateAccountBalance(List transactions) {\n  var accountBalance = 0;\n  for (Transaction t : transactions) {\n    if (t instanceof Purchase p) {\n      accountBalance += p.purchaseAmount();\n    } else if (t instanceof Payment p) {\n      accountBalance -= p.paymentAmount();\n    } else if (t instanceof PaymentReturned p) {\n      accountBalance += p.paymentAmount();\n    } else {\n      throw new RuntimeException(\"Unknown transaction type\");\n    }\n  }\n  return accountBalance;\n}\n```\n\n이 구현은 나쁘지 않습니다. 상당히 가독성이 높고, 처리해야 하는 거래 유형이 더 많아지면 다소 길어질 수 있습니다. 레코드용 패턴 매칭은 다음과 같은 구현을 향상시킵니다.\n\n```java\npublic static Integer calculateAccountBalance(List transactions) {\n  var accountBalance = 0;\n  for (Transaction t: transactions) {\n    switch(t) {\n      case Purchase p -\u003e accountBalance += p.purchaseAmount();\n      case Payment(var id, var amt) -\u003e accountBalance -= amt;\n      case PaymentReturned(var id, var amt, var reason) -\u003e accountBalance += amt;\n      default -\u003e throw new RuntimeException(\"Unknown transaction type\");\n    }\n  }\n  return accountBalance;\n}\n```\n\n이 코드는 조금 더 깔끔하고 장황하지 않게 보입니다. switch 키워드에 주목하세요. Java에는 오랫동안 사용 가능했습니다. Java 17에서 switch는 람다와 익숙한 문법을 지원하는 표현식을 지원하도록 했고, Java 19 및 21에서는 switch가 레코드에 대한 패턴 매칭을 지원하도록 더욱 향상되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPattern matching을 사용할 때에는 첫 번째 경우에 나타난 것처럼 타입의 인스턴스를 참조하거나 두 번째와 세 번째 경우처럼 타입을 그 구성 요소로 분해할 수 있습니다. switch에 대한 패턴 매칭은 또한 새로운 when 키워드를 사용하여 부울 표현식에 따라 패턴을 일치시키는 것을 가능하게 합니다. 예를 들어, 동일한 타입을 여러 번 다른 조건으로 일치시키고 각 경우마다 다른 로직을 실행할 수 있습니다.\n\n만약 여전히 패턴 매칭의 유용성에 확신이 없다면, 한 가지 더 있습니다. 어느 시점 후에 새로운 거래 유형을 도입했다고 가정해봅시다. Reversed purchase transactions을 모델링하기 위해 Credit이라고 부르는 새로운 거래 유형을 도입했다고 가정해봅시다. Transaction을 구현하는 새 레코드 타입을 추가함으로써 우리의 코드는 두 구현 모두에서 컴파일될 것입니다. 우리는 해당 타입을 처리할 수 없다는 문제를 런타임에서 만나게 되어 예외가 발생할 때까지 이를 발견하게 될 것입니다.\n\n레코드에 대한 패턴 매칭의 사용 편의성은 Java 17에 다시 도입된 다른 언어 기능, sealed classes and interfaces ( JEP409)에 의해 더욱 개선되었습니다. 인터페이스를 sealed로 표시하면 Compiler에게 Transaction에 대한 구현이 한정적이라는 정보를 제공하므로, Compiler가 패턴 매칭에서 모든 경우가 처리되었는지를 확인할 수 있습니다. 구현 클래스는 sealed 인터페이스와 동일한 파일에 위치시키거나 인터페이스에서 permit 키워드를 사용하여 닫힌 유형 계층 구조를 지정할 수 있습니다(자세한 내용은 JEP를 참조하십시오).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 우리의 코드는 모든 경우를 처리하지 못했을 때 컴파일되지 않을 것입니다. 그러나 이를 보장하려면 보통 빠뜨릴 수 있는 부분을 처리하는 기본 케이스를 제거해야 합니다.\n\n```js\n public sealed interface Transaction {\n    String id();\n\n    // define in here records extending interface\n}\n\n\npublic static Integer calculateAccountBalance(List transactions) {\n  var accountBalance = 0;\n\n  for (Transaction t: transactions) {\n    switch(t) {\n      case Purchase p -\u003e accountBalance += p.purchaseAmount();\n      case Payment(var id, var amt) -\u003e accountBalance -= amt;\n      case PaymentReturned(var id, var amt, var reason) -\u003e accountBalance += amt;\n    }\n  }\n\n  return accountBalance;\n}\n```\n\n이제 컴파일러는 다음과 같은 친절한 오류 메시지로 중단할 것입니다 — \"컴파일 실패: switch 문이 모든 가능한 값을 다 다루지 않았습니다\".\n\n인터페이스에 sealed 키워드를 사용하는 것은 초기 구현시 if-else 블록을 사용하는 것만큼 유용하지 않았습니다. 따라서 여기서는 패턴 매칭이 더 유리합니다. 이 글에서 다루지 않은 sealed 인터페이스/클래스에는 더 많은 내용이 있지만, 언어의 여러 기능이 잘 결합되어 코드의 견고성을 향상시키는 방법을 보여주는 예 중 하나입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금 설명한 문제를 해결하기 위해 방문자 디자인 패턴을 사용할 수 있다는 사실을 언급할 가치가 있습니다. 그러나 이 패턴은 상당히 더 많은 복잡성과 코드 양을 도입합니다. Java 21은 봉인된 인터페이스와 패턴 매칭이 도입된 Java 17 이후의 기능을 더해 출시된 기능이 많은 버전입니다. 대규모 기업에서는 일반적으로 LTS 버전만 사용을 허용하므로 Java 21이 다음 LTS 릴리스로 선정된 것은 훌륭한 소식입니다.\n\n이 게시물에서 언급하지 않은 많은 흥미로운 새로운 기능들이 있습니다. Virtual Threads인 프로젝트 룸은 아마도 Java 21에서 마무리된 가장 기대되는 기능일 것이지만, 이는 별도의 블로그 게시물이 필요한 큰 주제이기 때문에 다루기 어렵습니다. OpenJDK 웹사이트에서 최근 JDK 21 릴리스에 대해 더 많은 정보를 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바는 안정적이고 책임감 있는 방식으로 발전하는 경향이 있습니다. 소프트웨어 업계가 어떻게 변화하는지와 언어 기능을 유지하기 위해 필요한 기능을 주의 깊게 관찰하면서, 기능을 신중하게 구현하고 역호환성을 보장합니다.\n\n버전 21에서 자바는 사용하기 즐거운 언어이며, 이는 자바를 산업에 더 오랜 기간 동안 강하게 뿌리내릴 수 있는 또 다른 중요한 이정표입니다.\n\nCapital One의 소프트웨어 엔지니어링에 대해 더 알아보세요.\n\n원문은 https://www.capitalone.com에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작성자: 마신 코사코프스키, 선임 소프트웨어 엔지니어. 마신은 스몰 비즈니스 카드에서 새로운 카드 제품을 만드는 데 도움을 주는 선임 소프트웨어 엔지니어입니다. 데이터 엔지니어링, 분산 및 이벤트 기반 시스템에 열정을 갖고 있습니다. 여가 시간에는 하이킹과 마운틴 바이크를 즐깁니다.\n\n공개 성명: © 2024 Capital One. 의견은 해당 개인 작성자의 것입니다. 이 게시물에서 별도로 언급되지 않는 한, Capital One은 언급된 회사들과 제휴하거나 보증하고 있지 않습니다. 사용되거나 표시된 모든 상표 및 기타 지적 재산은 각 소유자의 재산입니다. Capital One은 링크된 제 3자 사이트의 콘텐츠나 개인 정보 취급 방침에 대해 책임지지 않습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_0.png"},"coverImage":"/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_0.png","tag":["Tech"],"readingTime":21},{"title":"포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법","description":"","date":"2024-06-19 21:49","slug":"2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer","content":"\n2009년에는 독일 철도 기업 직원 교대 관리를 위해 중요한 미션이었고, Java 1.5를 사용하기로 선택했습니다. 제네릭스가 도입되었고, 병행성 유틸리티들이 등장했습니다. 기본적으로 ReentrantLock을 사용하여 다중 스레드 시나리오를 관리하기 시작했습니다. 철도 회사는 여러 사용자가 동시에 데이터에 액세스해야 하는 필요가 있었는데, 예를 들어 여러 사무원이 기차 노선의 일부에 (기관사, 안내원, 요리사, 서빙원) 업무를 할당하려고 했습니다. 실제로 오래된 synchronized 키워드는 폐기되었다고 여겨졌습니다. 하지만 실제로는 그렇지 않았습니다. 그리고 결과적으로 대부분의 상황에서 synchronized가 새롭고 반짝거리는 ReentrantLock보다 우수하다는 것이 밝혀졌습니다.😊\n\n기술적인 세부 사항 대부분은 참고문헌에 남겨두었습니다. 솔직히 말해서 우리는 그 복잡한 것들을 알 필요가 없습니다. 누구도 면접에서 묻지 않을 것이기 때문입니다.\n\n본문의 목적은 대규모 분산 시스템의 하수구에서 작업하고 있는 Java 프로그래머에게 곧바로 `관련된` 정보를 전달하고 진지한 압박 속에서 기술을 자랑하는 기회를 갖겠다는 것입니다.\n\n## 대부분의 상황에서 synchronized가 ReentrantLock보다 우수합니다 😊\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCopyOnWriteArrayList에서 코드를 인용합니다. Java 1.6부터 대부분의 API 개발자들이 ReentrantLock을 사용하기 시작했는데, 이를 사용하는 것이 새롭고 멋진 것으로 여겨졌기 때문입니다. 그러나 Java 1.9에서는 synchronized로 다시 되돌아가기 시작했습니다 (ReentrantLock에서 synchronized로 다시 되돌아감 참조). 이는 synchronized 작동 방식에 대한 이해 부족 및 Doug Lee와 같은 Java Guru들이 자신을 적용하지 않았다는 점을 반영합니다. ReentrantLock 작동 방식에 대해 설명할 것입니다. 이 글에서 lock 객체 및 synchronized를 사용한 코드와 'lock'에 대한 간결한 설명이 있는 Java 21 버전을 살펴보십시오.\n\n이제 위대한 Doug Lee가 회개했고, synchronized와 ReentrantLock 사이의 장단점이 비슷하다면 synchronized를 기본값으로 사용한다고 말합니다.\n\n하지만 문제는, 왜 고대의 synchronized가 어떤 상황에서 새롭고 멋진 ReentrantLock보다 우수한 것인가입니다?!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n짧은 답변: synchronized는 JVM이 관리하는 객체로, JVM은 이를 통해 락 상승 및 감소와 같은 다양한 기능을 동적으로 처리할 수 있습니다. 반면 ReentrantLock은 비교 및 설정을 사용하는 일반적인 자바 코드에 갇혀 있습니다. synchronized 키워드를 사용할 때, JVM은 biased lock(더 이상 사용되지 않음), thin lock 또는 fat lock을 사용할지 여부를 결정합니다. 이 세 가지에 대해 알아봅시다.\n\n락 상승\n\nJVM은 얼마나 많은 경합이 있는지에 대한 정보를 수집합니다. 스레드가 biased lock(해당 스레드만 관심을 가짐)을 가지고 있고 두 번째 스레드가 오면, 락이 thin lock으로 상승됩니다. 그러나 더 많은 수의 스레드가 오는 경우, 바로 fat lock으로 상승될 수 있습니다. thin lock도 마찬가지입니다. thin lock은 루프에서 회전하면서 CPU를 소비합니다. 어느 시점에서 경합이 높아지면 락이 fat lock으로 상승됩니다. 마찬가지로, 락이 감소될 수도 있습니다.\n\n## Biased Lock\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'Synchronize' 메서드를 사용하여 여러 스레드가 공유 자원을 안전하게 사용할 수 있습니다. 이 메서드를 사용하면 잠금 객체의 머리글에 스레드 ID가 저장되어 공유 자원에 대한 액세스가 제어됩니다. 아래 이미지에서 여러 사용자(스레드)가 동일한 전화 부스를 사용하려고 하지만 한 번에 하나의 사용자만 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_0.png)\n\n이 접근법은 매우 빠릅니다. 같은 스레드가 동일한 잠금을 호출할 때마다 간단하게 다음과 같이 작동합니다:\n\n```js\nif (threadId == notedThreadId) {\n  // 계속 진행\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바15부터 Biased Locks는 사용되지 않으며 현재는 아마도 제거되었습니다. 자바 ≤ 1.3 시대에는 Java 컬렉션이 동기화되어 있었기 때문에 유용했습니다: Vector, Hashtable. 그러나 대부분 단일 스레드로 사용됩니다. 동기화되지 않은 java.util ArrayList, HashSet, HashMap 등을 사용하면 됩니다. 이러한 컬렉션은 엄격히 단일 스레드 안전하며 biased lock는 JVM에서 코딩하고 유지하는 비용이 아마도 그 가치가 없을 것입니다.\n\n## Thin Lock\n\n이미 biased lock로 보호된 lock을 얻으려는 두 번째 스레드가 있을 때, 두 스레드 모두에 대한 lock은 thin lock으로 승격되고, 첫 번째 스레드가 lock의 소유자가 됩니다. 반대로, 경합이 심한 경우 biased lock에서 fat lock으로 승격될 수 있습니다.\n\n현재 biased lock가 사용되지 않으므로 스레드가 lock을 획들하려고 하면 직접 thin lock을 먼저 사용하게 됩니다. Thin lock은 비교적 무거운 작업입니다. 비교 및 설정이 필요합니다. 그러나 CAS는 여전히 CPU 명령어이며 시스템 호출이 아닙니다. 시스템 호출은 비용이 많이 듭니다. 여기에 비교 및 설정을 사용하여 thin lock을 획들하는 의사 코드 예시가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class Person {\n\n    private AtomicBoolean locked = new AtomicBoolean(false);\n    private int id;\n    private String name;\n\n    public Person(int id, String name){\n        this.id = id;\n        this.name = name;\n    }\n\n    public String getDetailsAsString(){\n        while(!locked.compareAndSet(false, true)); // tricky tricky\n        try {\n          return this.id + \", \" + this.name;\n        } finally {\n          locked.set(false);\n        }\n    }\n}\n```\n\n얇은 락은 비교 및 설정을 사용합니다. 조금 까다로운 면이 있어 이해하기 어려울 수 있습니다. 그러나 이는 바쁜 락입니다. 락을 빨리 얻기를 희망하며 CPU를 일정 시간 동안 소비합니다. 상황에 따라 바쁜/스핀 락은 좋을 수도 있습니다. 왜냐하면 쓰레드를 코어에서 제거하고 다른 쓰레드를 코어에 올리는 데 시간이 소요되기 때문입니다.\n\n![이미지](/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_1.png)\n\n## 두꺼운 락\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFat Lock은 OS 뮤텍스를 사용합니다. 이것은 시스템 콜을 의미합니다. Thin Lock은 CAS만 사용합니다. 즉, 하드웨어 명령어입니다. 시스템 콜이 연관되지 않습니다. 이는 CPU 상태 변경이 필요하지 않음을 의미합니다. 프로그램 카운터, 베이스 포인터, 레지스터 등이 그것입니다. 하지만 Fat Lock은 시스템 콜이고, 시스템 콜은 비용이 많이 듭니다. 하지만 이해할 필요는 없습니다. 왜냐하면 우리는 애플리케이션 개발자이고 JVM C++ 프로그래머는 아니기 때문입니다.\n\nFat Lock은 스레드를 스레드의 대기 링크드 리스트에 넣습니다. OS는 이 목록에서 스케줄링합니다. 따라서 이는 바쁜 스핀이 없고 CPU 소모가 없음을 의미합니다. 스레드는 즉시 CPU를 해제합니다.\n\n![image](/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_2.png)\n\n## 그래서 Intrinsic (synchronized) Locking이 대부분에서 ReentrantLock을 능가할 수 있는 이유는 무엇일까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내재 락은런타임에서 계산된 경합에 따라 동적으로 thin lock 또는 fat lock을 수행하거나 스케일을 조절하거나 해제할 수 있습니다. 반면 재진입 락은 그렇지 못합니다. 이는 내재 락이 JVM 객체이기 때문입니다. 재진입 락은 그냥 일반적인 자바 코드에 불과합니다. 이것을 열어서 그 소스 코드를 읽을 수 있습니다.\n\n## 내재 및 재진입 락을 언제 사용해야 하는가\n\n재진입락 사용 시점:\n\n- tryLock, lockInterruptibly, 시간 제한이 있는 tryLock, 락의 공정성과 같은 고급 기능이 필요할 때\n\n내재 락 사용 시점:\n\n- (재)-세상에서 가장 위대한 자바 프로그래머 Doug Lee의 말을 인용하여\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npackage java.util.concurrent;\n\n//@author Doug Lea\npublic class CopyOnWriteArrayList\u003cE\u003e {\n\n    /**\n     * 모든 변경 작업을 보호하는 잠금입니다. (내장 모니터나 ReentrantLock 중 어느 것이든 사용 가능할 때는 builtin 모니터를 약간 선호합니다.)\n     */\n    final transient Object lock = new Object();\n\n    public E set(int index, E element) {\n        synchronized (lock) {\n```\n\n이후\n\n일부 사람들은 Java21 프로젝트 Loom을 통해 JVM이 내포된 잠금보다 ReentrantLock을 사용할 때 더 잘 작동할 수 있다고 의견을 제시합니다.\n\n## 참고문헌:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 유형의 JVM 락\nJVM에서 동기화 최적화에 대한 심층적인 탐구\nJava 동기화 메커니즘의 진화\n","ogImage":{"url":"/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_0.png"},"coverImage":"/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI에서 여러 개의 경고를 표시하는 방법","description":"","date":"2024-06-19 14:14","slug":"2024-06-19-HowtoshowMultipleAlertsinSwiftUI","content":"\n## SwiftUI에서 여러 경고를 표시하는 것은 조금 까다로울 수 있어요. 이 두 가지 방법을 소개해 드릴게요.\n\n![이미지](/assets/img/2024-06-19-HowtoshowMultipleAlertsinSwiftUI_0.png)\n\nSwiftUI에서 여러 경고를 표시하는 것은 귀찮을 수 있어요. 그러나, 하나의 경고를 표시하는 것은 꽤 간단해요. 먼저 하나의 경고를 표시하는 방법을 알아보죠.\n\n# 단일 경고\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어플리케이션이 있어요. 사용자가 10진수를 입력하면, 해당 입력이 짝수일 경우 경고 메시지가 표시됩니다.\n\n```js\nstruct ContentView: View {\n    @State private var showEvenAlert: Bool = false\n    @State private var num = 2\n\n    var body: some View {\n        VStack {\n             TextField(\"숫자를 입력하세요: \", value: $num, format: .number)\n                .textFieldStyle(.roundedBorder)\n                .frame(maxWidth: 150)\n            Button(\"숫자가 짝수일 때 경고 표시\") {\n                showEvenAlert = num % 2 == 0\n            }\n            .alert(isPresented: $showEvenAlert, content: {\n                Alert(title: Text(\"짝수\"), message: Text(\"\\(num)은(는) 짝수입니다\"), dismissButton: .cancel() )\n            })\n        }\n    }\n}\n```\n\n정상적으로 작동합니다. 사용자가 짝수를 입력하면 경고 메시지가 표시됩니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*uA2Shsj_0WoDUVHLylsHvw.gif\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다중 알림\n\n우리는 숫자가 홀수일 때도 알림을 표시하고 싶어요. 홀수는 외롭게 남겨두고 싶지 않아요. 그러니까 첫 번째 알림 아래에 추가 알림을 넣으면 작동할까요?\n\n```js\nstruct ContentView: View {\n    @State private var showEvenAlert:Bool = false\n    @State private var showOddAlert:Bool = false\n    @State private var num = 2\n\n    var body: some View {\n        VStack {\n            TextField(\"숫자를 입력하세요: \", value: $num, format:.number)\n                .textFieldStyle(.roundedBorder)\n                .frame(maxWidth: 150)\n            Button(\"숫자가 홀수인지 짝수인지 확인\") {\n                showEvenAlert = num % 2 == 0\n                showOddAlert = num % 2 == 1\n            }\n            .alert(isPresented: $showEvenAlert, content: {\n                Alert(title: Text(\"짝수\"), message: Text(\"\\(num)은(는) 짝수입니다\"), dismissButton: .cancel() )\n            })\n            .alert(isPresented: $showOddAlert, content: {\n                Alert(title: Text(\"홀수\"), message: Text(\"\\(num)은(는) 홀수입니다\"), dismissButton: .cancel() )\n            })\n\n        }\n    }\n}\n```\n\n안타깝게도 그 답은 아니에요. 위의 코드는 작동하지 않을 거예요. 홀수에 대한 알림은 표시되지만 짝수에 대한 알림은 나타나지 않을 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*JtKMxr1kTj-vWjPfBfa0bw.gif)\n\n이 무엇이 일어나고 있는지 이해해 봅시다. 뷰의 가장 바깥 쪽 알람만 작동합니다. 그래서 홀수 번째 알람은 작동하지만 짝수 번째는 작동하지 않습니다. 의왕, 컴파일러는 심지어 경고도 표시하지 않습니다. 그렇다면 해결책은 무엇일까요?\n\n# 해결책 1:\n\n한 알람을 여러 뷰에 할당할 수 있습니다. 그래서 단일 뷰에 한 개 이상의 알람이 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct ContentView: View {\n    @State private var showEvenAlert: Bool = false\n    @State private var showOddAlert: Bool = false\n    @State private var num = 2\n\n    var body: some View {\n        VStack {\n            TextField(\"Enter number: \", value: $num, format: .number)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .frame(maxWidth: 150)\n                .alert(isPresented: $showOddAlert) {\n                    Alert(title: Text(\"Odd\"), message: Text(\"\\(num) is odd\"), dismissButton: .cancel())\n                }\n\n            Button(\"Show Alert if number is odd or even\") {\n                showEvenAlert = num % 2 == 0\n                showOddAlert = num % 2 == 1\n            }\n            .alert(isPresented: $showEvenAlert) {\n                Alert(title: Text(\"Even\"), message: Text(\"\\(num) is even\"), dismissButton: .cancel())\n            }\n        }\n    }\n}\n```\n\n이렇게 수정하면 의도한 대로 작동할 것입니다. 하지만, 이 코드가 조금 어수선해 보입니다. 더 많은 알림이 있다면 어떻게 될까요? 코드가 더 어지러워질 것입니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1188/1*QoWoOOrtm-jHFuuIjTYEag.gif\" /\u003e\n\n# 해결책 2:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문제를 해결하는 한 가지 방법은 열거형(enum)을 사용하는 것이에요. 모든 종류의 알림에 대해 하나의 case를 만들고 열거형(enum)의 연관 값(associated value)을 사용하여 알림의 제목과 메시지를 나타낼 수 있어요.\n\n```js\nenum AlertContent {\n    case even(num:Int), odd(num:Int)\n\n    var title:String {\n        switch self {\n        case .even:\n            \"짝수\"\n        case .odd:\n            \"홀수\"\n        }\n    }\n\n    var message:String {\n        switch self {\n        case .even(let num):\n            \"\\(num)은(는) 짝수에요\"\n        case .odd(let num):\n            \"\\(num)은(는) 홀수에요\"\n        }\n    }\n}\n```\n\n이후에 뷰 코드도 훨씬 간단해질 거예요. 더 이상 여러 알림과 바인딩 변수가 필요하지 않아요. 하나의 알림, 하나의 바인딩 변수, 그리고 AlertContent 변수만 있으면 돼요. 알림 콘텐츠의 형식을 변경하고 알림을 표시할 수 있어요.\n\n```js\nstruct ContentView: View {\n    @State private var showAlert:Bool = false\n    @State private var num = 2\n    @State private var alertContent:AlertContent = .even(num: 2)\n\n    var body: some View {\n        VStack {\n            TextField(\"숫자를 입력하세요: \", value: $num, format:.number)\n                .textFieldStyle(.roundedBorder)\n                .frame(maxWidth: 150)\n            Button(\"숫자가 홀수이거나 짝수이면 알림 표시\") {\n                alertContent = (num % 2 == 0) ? .even(num: num) : .odd(num: num)\n                showAlert = true\n            }\n            .alert(isPresented: $showAlert, content: {\n                Alert(title: Text(alertContent.title), message: Text(alertContent.message), dismissButton: .cancel() )\n            })\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 화면에 필요한 경고를 여러 개 보여야 할 때도 하나의 경고창으로 처리할 수 있습니다. 더 많은 경고를 위해 enum 케이스를 더 추가해야 할 뿐입니다. 이상적으로는 버튼 누름 로직은 다른 곳으로 이동하여, 필요한 경고의 수에 관계없이 뷰가 변하지 않습니다. GitHub에서 해당 프로젝트를 확인할 수 있습니다.\n\n# 함께 소통해요!\n\n- LinkedIn\n- Twitter\n- GitHub\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoshowMultipleAlertsinSwiftUI_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoshowMultipleAlertsinSwiftUI_0.png","tag":["Tech"],"readingTime":7},{"title":"코틀린 멀티플랫폼 KMP","description":"","date":"2024-06-19 14:12","slug":"2024-06-19-KotlinMultiPlatformKMP","content":"\n이것은 안드로이드 및 iOS 플랫폼에서 작동하는 첫 번째 크로스 플랫폼 응용 프로그램을 만드는 단계별 안내서입니다.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_0.png)\n\nKotlin Multiplatform 기술은 크로스 플랫폼 프로젝트의 개발을 간소화하며, 그 중요한 사용 사례 중 하나는 플랫폼 간에 응용 프로그램 로직 코드를 공유하는 것입니다.\n\nhttps://github.com/ZahraHeydari/Kotlin-MultiPlatform-Mobile\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이 기사에서 배울 내용:\n\n- 환경 설정\n- 기본적인 KMM 프로젝트 생성\n- KMM 프로젝트 구조의 기초 이해\n- ViewModel\n- 네트워킹\n- iOS에서의 코루틴\n- 의존성 주입\n\n# 1. 환경 설정\n\n필요한 도구를 설치하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Android Studio\n- Xcode\n- JDK\n- Kotlin Multiplatform Mobile plugin\n- Kotlin plugin\n\n모든 것이 예상대로 작동되도록하려면 KDoctor 도구를 설치하고 실행하십시오.\n\n```js\nbrew install kdoctor\n```\n\n# 2. 기본 KMM 프로젝트 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 안드로이드 스튜디오를 열고 새 프로젝트 템플릿에서 Kotlin Multiplatform App을 선택하세요. 그리고 '다음' 버튼을 클릭하세요.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_1.png)\n\n다음 화면에서 애플리케이션의 이름과 프로젝트를 저장할 위치 등을 선택하세요. 그리고 다시 '다음' 버튼을 클릭하세요.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내 iOS 앱에 대한 종속성 관리자를 선택하십시오. 기본적으로 Regular framework이 선택되어 있고, 그런 다음 '완료'를 눌러주세요.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_3.png)\n\nGradle 동기화가 완료되면 툴바에서 실행 버튼을 사용하여 iOS 및 Android 앱을 모두 실행할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 안드로이드 에뮬레이터나 iOS 시뮬레이터에서 앱을 실행할 거예요.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_5.png)\n\n# 3. KMM 프로젝트 구조 기초 이해\n\n각 Kotlin Multiplatform 프로젝트는 shared, androidApp, iosApp 세 가지 모듈을 포함하고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-KotlinMultiPlatformKMP_6.png\" /\u003e\n\n- shared은 Android 및 iOS 애플리케이션 모두에 공통으로 포함된 로직을 포함하는 Kotlin 모듈입니다. 이것은 플랫폼 간에 공유하는 코드입니다. 빌드 프로세스를 자동화하기 위해 Gradle을 빌드 시스템으로 사용합니다.\n- androidApp은 Android 애플리케이션으로 빌드되는 Kotlin 모듈입니다. 빌드 시스템으로 Gradle을 사용합니다. androidApp 모듈은 공통 Android 라이브러리로 사용하기 위해 shared 모듈에 의존하고 사용합니다.\n- iosApp은 iOS 애플리케이션으로 빌드되는 Xcode 프로젝트입니다. 이는 shared 모듈에 의존하며 iOS 프레임워크로 사용합니다. 공유 모듈은 일반 프레임워크로 사용하거나 CocoaPods 종속성으로 사용할 수 있습니다.\n\n# 기대 및 실제 키워드\n\n기대 및 실제 선언을 통해 Kotlin Multiplatform 모듈에서 플랫폼별 API에 액세스할 수 있습니다. 공통 코드에서 플랫폼에 중립적인 API를 제공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-06-19-KotlinMultiPlatformKMP_7.png)\n\n다음 규칙을 따라 예상 및 실제 선언을 정의합니다:\n\n- 공통 소스 세트에서 표준 코틀린 구조를 선언합니다. 이는 함수, 속성, 클래스, 인터페이스, 열거형 또는 주석일 수 있습니다.\n\n2. 이 구조물에 expect 키워드를 표시합니다. 이것이 예상 선언입니다. 이러한 선언은 공통 코드에서 사용할 수 있지만 구현은 포함하면 안 됩니다. 대신, 플랫폼별 코드가이 구현을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 각 플랫폼별 소스 세트에서 동일한 구조물을 동일한 패키지에 선언하고 actual 키워드로 표시하세요. 이것이 여러분의 실제 선언입니다. 일반적으로 이 선언에는 플랫폼별 라이브러리를 사용하여 구현이 포함됩니다.\n\n![Kotlin Multiplatform](/assets/img/2024-06-19-KotlinMultiPlatformKMP_8.png)\n\n## 공통 코드\n\n공통 코드는 서로 다른 플랫폼 간에 공유되는 Kotlin 코드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 예제를 살펴보겠습니다:\n\n```kotlin\nclass Greeting {\n    private val platform: Platform = getPlatform()\n\n    fun greet(): String {\n        return \"안녕, ${platform.name}!\"\n    }\n}\n```\n\n```kotlin\ninterface Platform {\n    val name: String\n}\n\nexpect fun getPlatform(): Platform\n```\n\n## 모든 플랫폼에서 코드 공유하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 모든 플랫폼에 대해 공통인 비즈니스 로직이 있다면, 각 플랫폼에 동일한 코드를 작성할 필요가 없습니다. 그저 공통 소스 집합에서 공유하면 됩니다.\n\n![Image](/assets/img/2024-06-19-KotlinMultiPlatformKMP_9.png)\n\n보통 여러 네이티브 타겟을 생성해야 할 때가 많으며, 이러한 타겟들은 공통 로직과 써드파티 API를 재사용할 수 있습니다.\n\n이제 KMM 프로젝트에 viewModel을 추가할 시간입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4. KMP 프로젝트의 ViewModel\n\nViewModel은 Activity 또는 Fragment를 위한 데이터를 준비하고 관리하는 클래스입니다.\n\n이 샘플 프로젝트에서 EmojiHubViewModel은 이모지 데이터를 준비하고 관리하며 UI에 노출하기 위해 사용되며, SharedViewModel은 여러 뷰모델의 기본 클래스입니다.\n\nSharedViewModel과 EmojiHubViewModel은 commonMain 모듈에 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n// shared/commonMain/.../viewModel/SharedViewModel\nexpect open class SharedViewModel() {\n\n    val sharedViewModelScope: CoroutineScope\n\n    protected open fun onCleared()\n}\n```\n\nandroidMain 및 iosMain 소스 세트에서 actual 키워드를 사용하여 동일한 구조물을 표시하십시오. 일반적으로 이 actual 선언에는 플랫폼별 라이브러리를 사용한 구현이 포함됩니다.\n\nEmojiHubViewModel 선언이 공통 코드에 있고 iOS 및 Android 플랫폼 모두에서 사용할 수 있다는 점에 유의하십시오.\n\n```kotlin\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    ...\n\n    init {\n        sharedViewModelScope.launch {\n            ...\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 안드로이드 플랫폼의 ViewModel\n\n![image](/assets/img/2024-06-19-KotlinMultiPlatformKMP_10.png)\n\n```kotlin\n// shared/androidMain/.../viewModel/SharedViewModel\nactual open class SharedViewModel: ViewModel() {\n\n    actual val sharedViewModelScope: CoroutineScope = this.viewModelScope\n\n    actual override fun onCleared() {\n        super.onCleared()\n    }\n}\n```\n\n아래 코드 스니펫은 EmojiHubScreen에서 emojiHubViewModel을 사용하는 방법을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun EmojiHubScreen() {\n\n    val emojiHubViewModel: EmojiHubViewModel = koinViewModel()\n    val items by emojiHubViewModel.items.collectAsState()\n\n    Scaffold(topBar = {\n        TopAppBar(title = {\n            Text(text = \"EmojiHub\")\n        })\n    }, content = { paddingValues -\u003e\n        LazyColumn(modifier = Modifier.padding(paddingValues)) {\n            items(items.size) { index -\u003e\n                Item(items[index])\n            }\n        }\n    })\n}\n```\n\n저는 이 글에서 Ktor를 사용하여 데이터를 가져오고 Koin을 사용하여 종속성 주입하는 방법에 대해 설명하겠습니다! 그러니 지금은 건너뛰세요!\n\n## iOS 플랫폼의 ViewModel\n\n\u003cimg src=\"/assets/img/2024-06-19-KotlinMultiPlatformKMP_11.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n// shared/iosMain/.../viewModel/SharedViewModel\n실제 열린 클래스 SharedViewModel {\n\n    실제 val sharedViewModelScope = MainScope()\n\n    보호된 실제 기능 onCleared() {}\n\n    fun clear() {\n        onCleared()\n    }\n}\n```\n\n그리고 ContentView에서 emojiHubViewModel을 사용하는 방법입니다.\n\n```swift\nstruct ContentView: View {\n\n @StateObject\n var emojiHubViewModel: EmojiHubViewModel()\n\n var body: some View {\n     Text(String(\"EmojiHub\"))\n     List {\n          ForEach(iOSEmojiHubViewModel.items, id: \\.self) { item in\n              Item(emojiItem: item)\n          }\n     }\n  }\n}\n```\n\n# 5. 네트워킹\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKtor은 마이크로서비스부터 멀티플랫폼 HTTP 클라이언트 앱까지 다양한 용도로 사용됩니다. 이를 사용하려면 build.gradle.kts 파일에 아래와 같이 Ktor 종속성을 추가하면 됩니다.\n\n```kotlin\nval ktorVersion = \"3.4.3\"\n\n// shared/build.gradle.kts\nsourceSets {\n\n    val commonMain by getting {\n        dependencies {\n            implementation(\"io.ktor:ktor-client-core:$ktorVersion\")\n            implementation(\"io.ktor:ktor-client-logging:$ktorVersion\")\n            implementation(\"io.ktor:ktor-client-content-negotiation:$ktorVersion\")\n        }\n    }\n\n    val androidMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            // 다른 의존성 추가\n            implementation(\"io.ktor:ktor-client-okhttp:$ktorVersion\")\n        }\n    }\n\n    val iosMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            implementation(\"io.ktor:ktor-client-darwin:$ktorVersion\")\n        }\n    }\n}\n```\n\n공통 모듈인 commonMain에 HttpClient 파일을 아래와 같이 추가하세요:\n\n```kotlin\nexpect fun httpClient(config: HttpClientConfig\u003c*\u003e.() -\u003e Unit): HttpClient\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안드로이드 메인에서 실제 키워드를 사용하여 httpClient를 선언하세요:\n\n```kotlin\nactual fun httpClient(config: HttpClientConfig\u003c*\u003e.() -\u003e Unit): HttpClient = HttpClient(OkHttp) {\n    config()\n}\n```\n\n또한 iOS 메인에서도 실제 키워드를 사용하여 httpClient를 선언하세요:\n\n```kotlin\nactual fun httpClient(config: HttpClientConfig\u003c*\u003e.() -\u003e Unit): HttpClient = HttpClient(Darwin) {\n    config()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 EmojiHubRepository에서 httpClient를 사용하여 원격 서버에서 이모지를 가져오세요.\n\n```kotlin\nclass EmojiHubRepository(private val httpClient: HttpClient) {\n\n    suspend fun getEmojis(): List\u003cEmojiItem\u003e {\n        return try {\n            httpClient.get(urlString = \"/api/all\").body()\n        } catch (e: Exception) {\n            e.printStackTrace()\n            emptyList()\n        }\n    }\n}\n```\n\n그리고 EmojiHubViewModel에서 EmojiHubRepository를 사용하여 원격 또는 로컬 소스에서 데이터를 가져오세요.\n\n```kotlin\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    private val _items = MutableStateFlow\u003cList\u003cEmojiItem\u003e\u003e(listOf())\n\n    @NativeCoroutinesState\n    val items = _items.asStateFlow()\n\n    init {\n        sharedViewModelScope.launch {\n            _items.update {\n                repository.getEmojis() // 저장소를 통해 데이터 가져오기\n            }\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. 아이폰에서의 코루틴\n\n프로젝트에 Kotlinx.Serialization을 추가하세요.\n\nKotlinx.Serialization은 사용자 정의 타입의 객체를 직렬화하고 역직렬화하는 데 사용됩니다.\n\n```js\nval kotlinxSerializationVersion = \"1.5.1\"\n\n// shared/build.gradle.kts\nsourceSets {\n\n    val commonMain by getting {\n        dependencies {\n            implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:$kotlinxSerializationVersion\")\n            ...\n        }\n    }\n\n    val androidMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            ...\n        }\n    }\n\n    val iosMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            ...\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## httpClient 재구성하기\n\n```kotlin\n// shared/commonMain/.../EmojiHubRepository\n    class EmojiHubRepository {\n        private val httpClient = httpClient {\n            ...\n            install(ContentNegotiation) {\n                json(\n                    Json {\n                        ignoreUnknownKeys = true\n                    }\n                )\n            }\n        }\n    }\n```\n\n서버에서 데이터를 가져와 Android 앱을 실행합니다.\n\n```kotlin\nsuspend fun getEmojis(): List\u003cEmojiItem\u003e {\n        return try {\n            httpClient.get(urlString = \"/api/all\").body()\n        } catch (e: Exception) {\n            e.printStackTrace()\n            emptyList()\n        }\n    }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    private val _items = MutableStateFlow\u003cList\u003cEmojiItem\u003e\u003e(listOf())\n\n    @NativeCoroutinesState\n    val items = _items.asStateFlow()\n\n    init {\n        sharedViewModelScope.launch {\n            _items.update {\n                repository.getEmojis()\n            }\n        }\n    }\n}\n```\n\n![Image](/assets/img/2024-06-19-KotlinMultiPlatformKMP_12.png)\n\n## KMP-NativeCoroutines\n\n```kotlin\n// commonMain/viewModel/EmojiHubViewModel\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    private val _items = MutableStateFlow\u003cList\u003cEmojiItem\u003e\u003e(listOf())\n\n    @NativeCoroutinesState\n    val items = _items.asStateFlow()\n\n    ...\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIOSEmojiHubViewModel은 iosApp 모듈에 있어요.\n\n\u003cimg src=\"/assets/img/2024-06-19-KotlinMultiPlatformKMP_13.png\" /\u003e\n\nIOSEmojiHubViewModel에서 KMPNativeCoroutinesAsync을 사용하여 데이터를 가져옵니다.\n\n```swift\n@MainActor\nclass IOSEmojiHubViewModel: ObservableObject {\n\n    private let githubViewModel = GithubViewModel()\n\n    @Published\n    var items = Array\u003cEmojiItem\u003e()\n\n    var task: Task\u003c(), Never\u003e? = nil\n\n    init() {\n        task = Task {\n            do {\n                let asyncItems = asyncSequence(for: emojiHubViewModel.itemsFlow)\n                for try await asyncItem in asyncItems {\n                    items = asyncItem\n                }\n            } catch {\n                print(\"Failed with error: \\(error)\")\n            }\n        }\n    }\n\n    func clear() {\n        task?.cancel()\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct ContentView: View {\n\n    @StateObject\n    var iOSEmojiHubViewModel = IOSEmojiHubViewModel()\n\n    var body: some View {\n        Text(String(\"EmojiHub\"))\n        List {\n            ForEach(iOSEmojiHubViewModel.items, id: \\.self) { item in\n                Item(emojiItem: item)\n            }\n        }\n    }\n}\n```\n\n# 7. 의존성 주입\n\n의존성 주입 패턴을 구현하기 위해 프로젝트에 Koin을 추가하세요.\n\n```js\nval koinVersion = \"3.4.3\"\n\n// shared/build.gradle.kts\nsourceSets {\n\n    val commonMain by getting {\n        dependencies {\n            implementation(\"io.insert-koin:koin-core:$koinVersion\")\n            ...\n        }\n    }\n\n    val androidMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            implementation(\"io.insert-koin:koin-android:$koinVersion\")\n            ...\n        }\n    }\n\n    val iosMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            ...\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEmojiHubRepository에 HttpClient을 주입해주세요.\n\n```kotlin\nclass EmojiHubRepository(private val httpClient: HttpClient) {\n\n    ...\n}\n```\n\n그리고 EmojiHubViewModel에서 EmojiHubRepository를 주입해주세요.\n\n```kotlin\n// commonMain/viewModel/EmojiHubViewModel\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    ...\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 의존성을 정의하도록 모듈을 선언해보세요:\n\n```kotlin\nval appModule = module {\n    single {\n        httpClient {\n           ...\n        }\n    }\n\n    single {\n        EmojiHubRepository(get())\n    }\n\n    sharedViewModel {\n        EmojiHubViewModel(get())\n    }\n}\n```\n\n프로젝트 애플리케이션 클래스에 Koin을 시작하는 코드를 추가해보세요.\n\n```kotlin\n//androidApp/MainApplication\nclass MainApplication : Application() {\n\n    override fun onCreate() {\n        super.onCreate()\n\n        startKoin {\n            androidContext(this@MainApplication)\n            modules(appModule) // 앱 모듈\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOSMain 에서 Koin을 시작하려면 아래와 같이 시작하세요.\n\n```js\n// shared/iosMain/.../KoinStarter.kt\nfun startKoin() {\n    startKoin { modules(appModule) }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-KotlinMultiPlatformKMP_14.png\" /\u003e\n\niOSApp에서 startKoin을 호출하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n@ main\n구조체 iOSApp: 앱 {\n\ninit() {\nKoinStarterKt.startKoin()\n}\n\n    var body: some Scene {\n       WindowGroup {\n           ContentView()\n       }\n    }\n\n}\n\n그리고 GithubViewModelHelper은 iOS에서 GithubViewModel을 주입하는 데 사용됩니다.\n\nclass EmojiHubViewModelHelper: KoinComponent {\n\n    private val emojiHubViewModel: EmojiHubViewModel = get()\n\n    @NativeCoroutinesState\n    val items = emojiHubViewModel.items\n\n}\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_15.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Android 앱과 iOS 앱을 실행해보세요.\n\n![Kotlin Multiplatform](/assets/img/2024-06-19-KotlinMultiPlatformKMP_16.png)\n\n## 라이브러리 및 도구\n\n- KMP 플러그인\n- Kdoctor\n- Ktor\n- kotlinx.serialization\n- KMP-NativeCoroutines\n- Koin\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 KMP(Kotlin Multiplatform)를 사용한 예제 프로젝트입니다.\n\n[여기](https://github.com/ZahraHeydari/Kotlin-MultiPlatform-Mobile)를 클릭해주세요!\n\n이 이야기를 읽어 주셔서 감사합니다. 도움이 되셨으면 좋겠어요.\n\n의견이 있으시면 언제든지 남겨주세요. 감사합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코딩을 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-19-KotlinMultiPlatformKMP_0.png"},"coverImage":"/assets/img/2024-06-19-KotlinMultiPlatformKMP_0.png","tag":["Tech"],"readingTime":22},{"title":"마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기","description":"","date":"2024-06-19 14:10","slug":"2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms","content":"\n![이미지](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png)\n\nCompose Multiplatform은 개발자에게 뛰어난 가능성의 세계를 열어주어 안드로이드와 iOS용 네이티브 모습을 하나의 코드베이스로 구축할 수 있게 합니다. 이러한 앱에 인증을 통합하는 것은 어렵게 느껴질 수 있지만, 이 기사에서는 Firebase REST API 인증을 Compose Multiplatform과 통합하는 단계와 혜택을 탐색할 것입니다.\n\n# 왜 Firebase REST API를 사용하는가?\n\n우리는 Android, iOS 및 Web 플랫폼용 다양한 Firebase SDK가 있음을 알고 있지만 Compose Multiplatform용 안정적인 SDK는 없습니다. 또한, 다양한 Compose Multiplatform 예제에서 사용 사례를 보여주기 위해 REST API를 사용하는 것을 보았습니다. 따라서 하나의 코드베이스를 사용하고 여러 플랫폼을 대상으로 하기 위해 Firebase REST API를 인증에 사용하는 것을 선호했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 준비물:\n\n- Compose Multiplatform 플러그인이 설치된 Android Studio 또는 IntelliJ IDEA.\n- iOS 앱을 실행하기 위한 Xcode.\n- Firebase 프로젝트.\n- 프로젝트에서 Firebase Authentication이 활성화되어 있어야 합니다.\n\n# 단계 1: Compose Multiplatform 프로젝트 생성\n\nCompose Multiplatform 프로젝트를 생성하려면 Kotlin Multiplatform Wizard를 사용할 수 있습니다. 이는 우리가 타깃팅하는 플랫폼을 선택할 수 있게 해줍니다. 이 프로젝트에서는 Android, iOS 및 데스크톱 플랫폼을 선택할 것입니다. 플랫폼을 선택하고 나면 프로젝트를 다운로드하여 선호하는 IDE에서 열 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_1.png)\n\n# 단계 2: 인증을 위한 UI 생성\n\n이 프로젝트에서는 Email/Password 인증만 대상으로 하고 시작하므로 composeApp/src/commonMain/kotlin/authentication/AuthenticationView.kt 파일에서는 로그인 및 회원가입 뷰를 포함한 UI가 제공됩니다.\n\n![image](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 3: Firebase 프로젝트 구성하기.\n\nFirebase 프로젝트를 구성하면 프로젝트 설정을 방문하여 Firebase REST API와 함께 사용할 API Key를 얻을 수 있습니다. 이를 사용하여 사용자를 인증할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_3.png)\n\n# 단계 4: 프로젝트에서 Ktor 구성하기.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKotlin의 Ktor 프레임워크는 강력하고 유연한 HTTP 클라이언트를 제공하여 외부 API와의 상호 작용을 원활하게 만들어줍니다. 구현에 앞서 필요한 종속성이 포함된 Kotlin 프로젝트를 설정했는지 확인해보세요. Ktor의 클라이언트 라이브러리를 포함하여 프로젝트에 Ktor 클라이언트를 추가할 수 있습니다. 이를 위해 libs.versions.toml 파일 내 gradle 폴더에 다음 종속성을 포함하면 됩니다.\n\n[versions]\n...\nkotlin = \"1.9.21\"\nkotlinx-coroutines = \"1.7.3\"\nktor = \"2.3.6\"\n\n[libraries]\n....\nktor-serialization-kotlinx-json = { module = \"io.ktor:ktor-serialization-kotlinx-json\", version.ref = \"ktor\" }\nktor-client-core = { module = \"io.ktor:ktor-client-core\", version.ref = \"ktor\" }\nktor-client-darwin = { module = \"io.ktor:ktor-client-darwin\", version.ref = \"ktor\" }\nktor-client-okhttp = { module = \"io.ktor:ktor-client-okhttp\", version.ref = \"ktor\" }\nktor-client-content-negotiation = { module = \"io.ktor:ktor-client-content-negotiation\", version.ref = \"ktor\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nandroidLibrary = { id = \"com.android.library\", version.ref = \"agp\" }\njetbrainsCompose = { id = \"org.jetbrains.compose\", version.ref = \"compose-plugin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nkotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }\n\nlibs.versions.toml 파일 내의 라이브러리를 추가했으면, build.gradle.kts 파일의 composeApp 내부에 종속성을 추가하고 프로젝트를 동기화해주면 됩니다:\n\nandroidMain.dependencies {\n...\nimplementation(libs.ktor.client.okhttp)\n}\ncommonMain.dependencies {\n...\nimplementation(libs.ktor.client.core)\nimplementation(libs.ktor.client.content.negotiation)\nimplementation(libs.ktor.serialization.kotlinx.json)\n}\ndesktopMain.dependencies {\n..\nimplementation(libs.ktor.client.okhttp)\n}\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 5: Firebase REST API 호출하기\n\nKtor 라이브러리가 추가되고 프로젝트가 동기화된 후, Ktor 함수를 사용하여 Firebase REST API를 호출할 수 있습니다. 그 전에 HttpClient를 초기화하여 API 요청을 만들 수 있어야 합니다. 그래서, AuthenticationViewModel.kt 파일을 생성하여 모든 백엔드 작업을 처리하고 아래 코드를 추가합니다.\n\n```js\nprivate val httpClient = HttpClient() {\n    install(ContentNegotiation) {\n        json()\n    }\n}\n```\n\n## 사용자 생성 정복하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 새로운 사용자를 생성해 봅시다! https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=$'API_KEY' 엔드포인트로 Ktor 클라이언트 호출을 만들어 보겠습니다. 사용자 데이터(이메일 및 비밀번호)를 코틀린 직렬화를 사용하여 JSON 형식으로 직렬화해야 합니다. 데이터와 함께 POST 요청을 보내고 Firebase 응답을 기다리세요. 사용자가 성공적으로 생성되면 응답을 구문 분석하여 사용자 ID 및 기타 관련 정보를 추출하세요.\nAuthenticationViewModel.kt에 추가된 signUp() 메서드의 아래 코드 스니펫을 확인해보세요.\n\n```js\nfun signUp(\n        email: String,\n        password: String,\n        confirmPassword: String,\n        onCompletion: onCompletion\n    ) {\n        if (password == confirmPassword) {\n            viewModelScope.launch {\n                val responseBody = httpClient\n                    .post(\"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${API_KEY}\") {\n                        header(\"Content-Type\", \"application/json\")\n                        parameter(\"email\", email)\n                        parameter(\"password\", password)\n                        parameter(\"returnSecureToken\", true)\n                    }\n                if (responseBody.status.value in 200..299) {\n                    val response = Json { ignoreUnknownKeys = true }\n                        .decodeFromString\u003cAuthResponse\u003e(responseBody.bodyAsText())\n                    onCompletion.onSuccess(response.idToken)\n                } else {\n                    onCompletion.onError(Exception(responseBody.bodyAsText()))\n                }\n            }\n        } else {\n            onCompletion.onError(Exception(\"Password doesn't match\"))\n        }\n    }\n```\n\n## 로그인 퀘스트:\n\n이제 로그인에 도전해 봅시다! 사용자 생성과 유사하게, https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=$'API_KEY' 엔드포인트로의 Ktor 클라이언트 호출을 구성해보세요. 다시 한번 사용자 자격 증명(이메일 및 비밀번호)을 직렬화하고 POST 요청을 보내세요. 응답을 구문 분석하여 ID 토큰을 얻어 사용자 신원을 확인하고 보호된 리소스에 액세스하는 데 필수적인 요소를 확보하세요.\nAuthenticationViewModel.kt에 추가된 login() 메서드의 아래 코드 스니펫을 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nfun login(\n    email: String,\n    password: String,\n    onCompletion: onCompletion\n) {\n    viewModelScope.launch {\n        val responseBody = httpClient\n            .post(\"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${API_KEY}\") {\n                header(\"Content-Type\", \"application/json\")\n                parameter(\"email\", email)\n                parameter(\"password\", password)\n                parameter(\"returnSecureToken\", true)\n            }\n        if (responseBody.status.value in 200..299) {\n            val response = Json { ignoreUnknownKeys = true }\n                .decodeFromString(responseBody.bodyAsText())\n            storeUserDetails(response)\n            onCompletion.onSuccess(response.idToken)\n        } else {\n            onCompletion.onError(Exception(responseBody.bodyAsText()))\n        }\n    }\n}\n```\n\n# 단계 6: 캐시 지원을 위해 SQLDelight 추가.\n\nSQLDelight는 플랫폼에 중립적인 SQL 쿼리를 작성하기 위한 강력한 코틀린 라이브러리로, 캐싱과 결합하여 앱의 효율성을 높이는 동적 이중체를 형성합니다. 여기서는 login 및 signUp API 호출의 응답에서 얻은 refreshToken을 저장할 것입니다. 따라서 사용자가 앱을 다시 열 때 인증을 요청하지 않을 것입니다.\n\n## SQLDelight 종속성 설정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 gradle 폴더 내 libs.versions.toml 파일에 필요한 SQLDelight 종속성 및 플러그인을 추가해야 합니다.\n\n```js\n[versions]\n...\n...\nsqlDelight = \"2.0.1\"\n\n[libraries]\n...\n...\nsqldelight-androidDriver = { module = \"app.cash.sqldelight:android-driver\", version.ref = \"sqlDelight\" }\nsqldelight-jvmDriver = { module = \"app.cash.sqldelight:sqlite-driver\", version.ref = \"sqlDelight\" }\nsqldelight-nativeDriver = { module = \"app.cash.sqldelight:native-driver\", version.ref = \"sqlDelight\" }\nsqldelight-coroutines = { module = \"app.cash.sqldelight:coroutines-extensions\", version.ref = \"sqlDelight\" }\nsqldelight-primitiveAdapters = { module = \"app.cash.sqldelight:coroutines-extensions\", version.ref = \"sqlDelight\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nandroidLibrary = { id = \"com.android.library\", version.ref = \"agp\" }\njetbrainsCompose = { id = \"org.jetbrains.compose\", version.ref = \"compose-plugin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nkotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }\nsqlDelight = { id = \"app.cash.sqldelight\", version.ref = \"sqlDelight\" }\n```\n\n다음 단계는 프로젝트 수준의 build.gradle.kts 파일에 플러그인을 추가하는 것입니다.\n\n```js\nplugins {\n    // this is necessary to avoid the plugins to be loaded multiple times\n    // in each subproject's classloader\n    alias(libs.plugins.androidApplication) apply false\n    alias(libs.plugins.androidLibrary) apply false\n    alias(libs.plugins.jetbrainsCompose) apply false\n    alias(libs.plugins.kotlinMultiplatform) apply false\n    //SQLDelight Plugin\n    alias(libs.plugins.sqlDelight) apply false\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막 단계로는 composeApp build.gradle.kts 파일에서 SQLDelight를 구성해야 합니다. 여기서는 필요한 플랫폼에 따라 종속성을 추가하고 SQLDelight 데이터베이스의 이름을 추가할 것입니다. 매개변수가 포함된 데이터베이스 목록을 포함하는 sqlDelight 블록을 맨 끝에 볼 수 있을 것입니다.\n\n```js\nimport org.jetbrains.compose.ExperimentalComposeLibrary\nimport org.jetbrains.compose.desktop.application.dsl.TargetFormat\n\nplugins {\n    alias(libs.plugins.kotlinMultiplatform)\n    alias(libs.plugins.androidApplication)\n    alias(libs.plugins.jetbrainsCompose)\n    alias(libs.plugins.kotlinxSerialization)\n    alias(libs.plugins.sqlDelight)\n}\n\nkotlin {\n\n    androidTarget {\n        compilations.all {\n            kotlinOptions {\n                jvmTarget = \"1.8\"\n            }\n        }\n    }\n\n\n    jvm(\"desktop\")\n\n    listOf(\n        iosX64(),\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach { iosTarget -\u003e\n        iosTarget.binaries.framework {\n            baseName = \"ComposeApp\"\n            // This should be set to false to run on iOS\n            isStatic = false\n            // Add it to avoid sqllite3 issues in iOS\n            linkerOpts.add(\"-lsqlite3\")\n        }\n    }\n\n    sourceSets {\n        val desktopMain by getting\n\n        androidMain.dependencies {\n            implementation(libs.compose.ui.tooling.preview)\n            implementation(libs.androidx.activity.compose)\n            implementation(libs.ktor.client.okhttp)\n            //SqlDelight for Android\n            implementation(libs.sqldelight.androidDriver)\n        }\n        commonMain.dependencies {\n            implementation(compose.runtime)\n            implementation(compose.foundation)\n            implementation(compose.material)\n            implementation(compose.ui)\n            @OptIn(ExperimentalComposeLibrary::class)\n            implementation(compose.components.resources)\n            //Ktor\n            implementation(libs.ktor.client.core)\n            implementation(libs.ktor.client.content.negotiation)\n            implementation(libs.ktor.serialization.kotlinx.json)\n            //Moko MVVM\n            implementation(libs.moko.mvvm.core)\n            implementation(libs.moko.mvvm.compose)\n            //Kamel\n            implementation(libs.kamel)\n            // Navigator\n            implementation(libs.voyager.navigator)\n            //SqlDelight for common\n            implementation(libs.sqldelight.coroutines)\n            implementation(libs.sqldelight.primitiveAdapters)\n        }\n        desktopMain.dependencies {\n            implementation(compose.desktop.currentOs)\n            implementation(libs.kotlinx.coroutines.swing)\n            implementation(libs.ktor.client.okhttp)\n            //SqlDelight for jvm\n            implementation(libs.sqldelight.jvmDriver)\n        }\n        iosMain.dependencies {\n            //SqlDelight for iOS\n            implementation(libs.sqldelight.nativeDriver)\n        }\n    }\n}\n\nsqldelight {\n    databases {\n        //Note: Name of your Database and .sq file should be same\n        create(\"Database\") {\n            packageName.set(\"com.dwarshb.firebaseauthentication\")\n        }\n    }\n    // Add this line to avoid library linking issues\n    linkSqlite = true\n}\n\nandroid {\n    ...\n}\n\ncompose.desktop {\n    ...\n}\n```\n\n## 쿼리용 Database.sq 파일 만들기\n\n다음 단계는 모든 필요한 SQL 쿼리를 포함하는 .sq 파일을 작성하는 것입니다. 기본적으로 SQLDelight 플러그인은 sqldelight 폴더 내의 패키지 폴더에서 .sq를 읽습니다. 해당 폴더는 직접 commainMain 폴더 내에 있을 것입니다.\nDatabase.sq 파일이 위치하는 폴더 구조 스크린샷은 아래에서 확인하실 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_4.png\" /\u003e\n\n다음 코드를 Database.sq 파일에 추가하세요. 이 파일은 createTable, insertUser, removeAllUsers, getAllUsers 등의 쿼리를 포함합니다.\n\n프로젝트를 컴파일하면 생성된 Kotlin 코드가 composeApp/build/generated/sqldelight 디렉토리에 저장됩니다. 또는 터미널에서 ./gradlew generateSqlDelightInterface 명령어를 사용하여 sqldelight 코틀린 코드를 생성할 수도 있습니다.\n\n## 데이터베이스 드라이버 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSQLDelight은 SQLite 드라이버의 여러 플랫폼별 구현을 제공하므로 각 플랫폼에 대해 별도로 생성해야 합니다. 이를 기대 선언과 실제 선언을 사용하여 수행할 수 있습니다.\n\ncomposeApp/src/commonMain/kotlin에서 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 만드세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\n\nexpect class DriverFactory {\n    fun createDriver(): SqlDriver\n}\n```\n\n이제 각 대상 플랫폼에 대해 이를 구현해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안드로이드에서는 AndroidSqliteDriver 클래스가 SQLite 드라이버를 구현합니다.\n그래서 composeApp/src/androidMain/kotlin에서 패키지를 만들어 그 안에 DriverFactory.kt 클래스를 생성해주세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport android.content.Context\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.android.AndroidSqliteDriver\n\nactual class DriverFactory(var appContext: Context) {\n\n    actual fun createDriver(): SqlDriver {\n        return AndroidSqliteDriver(Database.Schema, appContext, \"firebase.db\")\n    }\n}\n```\n\n이제 Android에서 작동하도록 하기 위해 composeApp/src/androidMain/kotlin에 있는 MainActivity.kt 파일에서 해당 인스턴스를 생성해야 합니다.\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        //Android용 DriverFactory의 인스턴스 생성\n        val driverFactory = DriverFactory(this)\n        setContent {\n            App(driverFactory.createDriver())\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS에서 SQLite 드라이버 구현은 NativeSqliteDriver 클래스입니다.\n그래서 composeApp/src/iosMain/kotlin에 패키지를 만들고 내부에 DriverFactory.kt 클래스를 만들어 주세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.native.NativeSqliteDriver\n\nactual class DriverFactory {\n    actual fun createDriver(): SqlDriver {\n        return NativeSqliteDriver(Database.Schema, \"firebase.db\")\n    }\n}\n```\n\n이제 MainViewController.kt 파일을 만들어서 iOS에서 작업할 수 있도록 인스턴스를 만들어주세요. 이 파일은 composeApp/src/iosMain/kotlin에 있습니다.\n\n```kotlin\nimport androidx.compose.ui.window.ComposeUIViewController\nimport com.dwarshb.firebaseauthentication.DriverFactory\n\nfun MainViewController() = ComposeUIViewController {\n    val driverFactory = DriverFactory()\n    App(driverFactory.createDriver())\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데스크톱 환경에서는 SQLite 드라이버 구현이 JdbcSqliteDriver 클래스입니다.\n그래서 composeApp/src/desktopMain/kotlin에 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 생성해주세요.\n\n```js\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver\nimport java.io.File\n\nactual class DriverFactory {\n    actual fun createDriver(): SqlDriver {\n        val databasePath = File(System.getProperty(\"java.io.tmpdir\"), \"firebase.db\")\n        val driver: SqlDriver = JdbcSqliteDriver(url = \"jdbc:sqlite:${databasePath.absolutePath}\")\n        Database.Schema.create(driver)\n        return driver\n    }\n}\n```\n\n이제 데스크톱에서 작동하도록 composeApp/src/desktopMain/kotlin의 main.kt 파일에 인스턴스를 생성해야 합니다.\n\n```js\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\nimport com.dwarshb.firebaseauthentication.DriverFactory\n\nfun main() = application {\n    Window(onCloseRequest = ::exitApplication, title = \"FirebaseAuthentication\") {\n        val driverFactory = DriverFactory()\n        App(driverFactory.createDriver())\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_5.png\" /\u003e\n\n모든 플랫폼에서 DriverFactory를 구성하고 위 단계를 모두 따라왔다면, App() 함수를 수정하고 SqlDriver를 매개변수로 추가해야 합니다. 각 플랫폼에서 SqlDriver의 인스턴스를 가져올 수 있는 유일한 방법이기 때문입니다. 그래서 composeApp/src/commanMain/kotlin/App.kt 안에 다음과 같이 작성하세요.\n\n```js\n@Composable\nfun App(sqlDriver: SqlDriver) {\n    val authenticationViewModel = AuthenticationViewModel(sqlDriver)\n\n    MaterialTheme {\n      ...\n    }\n}\n```\n\n# 단계 7: SQLDelight 쿼리 구성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 단계에서는 Firebase Authentication API에서 받은 토큰을 저장하여 사용자 세션을 유지하기 위해 insertUser 쿼리를 사용할 예정입니다. 또한 로컬 데이터베이스에 저장된 토큰을 얻기 위해 selectAllUser 쿼리를 사용할 것입니다. AuthenticationViewModel.kt 내에서 먼저 데이터베이스를 초기화할 것입니다.\n\n```js\n    var databaseQuery : DatabaseQueries\n\n    val database = Database(sqlDriver)\n    databaseQuery = database.databaseQueries\n```\n\n이제 API에서 받은 응답을 저장할 storeUserDetails() 메서드를 만들 것입니다. 이 메서드는 로컬 데이터베이스에 정보를 저장하는 데 insertUser 쿼리를 사용합니다. AuthenticationViewModel.kt 파일의 login()이나 signUp() 메서드 내에 이 메서드를 추가할 수 있습니다.\n\n```js\ninternal fun storeUserDetails(response: AuthResponse) {\n        databaseQuery.insertUser(\n            response.idToken, response.email, response.refreshToken,\n            response.email\n        )\n    }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n세션 유지를 위해 시스템에 이미 토큰이 로컬 데이터베이스에 있는지 확인해야 합니다. 그래서 우리는 selectAllUsers 쿼리를 사용하여 로컬 데이터베이스에 저장된 토큰을 확인하는 checkSession()을 생성할 것입니다.\n\n```kotlin\ninternal fun checkSession(onCompletion: onCompletion) {\n    for(user in databaseQuery.selectAllUsers().executeAsList()) {\n        if (user != null) {\n            onCompletion.onSuccess(user.refreshToken.toString())\n        } else {\n            onCompletion.onError(Exception(\"세션을 찾을 수 없습니다\"))\n        }\n    }\n}\n```\n\n우리는 checkSession() 메서드를 사용하여 결과에 따라 UI를 업데이트할 수 있습니다. 예를 들어, 토큰이 있는 경우 onSuccess 내에서 앱을 MainScreen으로 이동시키고, 그렇지 않은 경우 AuthenticationView 화면이 표시됩니다.\n\n# 데모\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 Github 링크에서 전체 코드를 확인해보세요.\n\n# 참조 링크:\n\n- https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ktor-sqldelight.html#build-an-sdk\n- https://firebase.google.com/docs/reference/rest/auth#section-api-usage\n","ogImage":{"url":"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png"},"coverImage":"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png","tag":["Tech"],"readingTime":23}],"page":"37","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"37"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>