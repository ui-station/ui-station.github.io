<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/8" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/8" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="레스토랑 사업을 위한 혁신적인 음식 앱 아이디어 2024년 최신 트렌드" href="/post/2024-06-23-FoodAppIdeasforRestaurantBusinessesInnovatingDining"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="레스토랑 사업을 위한 혁신적인 음식 앱 아이디어 2024년 최신 트렌드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FoodAppIdeasforRestaurantBusinessesInnovatingDining_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="레스토랑 사업을 위한 혁신적인 음식 앱 아이디어 2024년 최신 트렌드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">레스토랑 사업을 위한 혁신적인 음식 앱 아이디어 2024년 최신 트렌드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Groovy와 Kotlin DSL 최신 비교 어떤 걸 선택해야 할까" href="/post/2024-06-23-GroovyvsKotlinDSL"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Groovy와 Kotlin DSL 최신 비교 어떤 걸 선택해야 할까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GroovyvsKotlinDSL_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Groovy와 Kotlin DSL 최신 비교 어떤 걸 선택해야 할까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Groovy와 Kotlin DSL 최신 비교 어떤 걸 선택해야 할까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Reactjs로 모바일 앱 개발하기 예측불가능한 경우들의 완벽한 궁합" href="/post/2024-06-23-ReactjsforMobileAppDevelopmentUnpredictableMatchforTheCases"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Reactjs로 모바일 앱 개발하기 예측불가능한 경우들의 완벽한 궁합" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ReactjsforMobileAppDevelopmentUnpredictableMatchforTheCases_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Reactjs로 모바일 앱 개발하기 예측불가능한 경우들의 완벽한 궁합" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Reactjs로 모바일 앱 개발하기 예측불가능한 경우들의 완벽한 궁합</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="간단한 커스텀 훅을 이용한 React Native 앱 상태 마스터하기" href="/post/2024-06-23-MasteringAppStateinReactNativewithasimplecustomhook"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="간단한 커스텀 훅을 이용한 React Native 앱 상태 마스터하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-MasteringAppStateinReactNativewithasimplecustomhook_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="간단한 커스텀 훅을 이용한 React Native 앱 상태 마스터하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">간단한 커스텀 훅을 이용한 React Native 앱 상태 마스터하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플레이 스토어에 첫 번째 앱을 출시하며 배운 7가지 소중한 교훈" href="/post/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플레이 스토어에 첫 번째 앱을 출시하며 배운 7가지 소중한 교훈" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플레이 스토어에 첫 번째 앱을 출시하며 배운 7가지 소중한 교훈" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">플레이 스토어에 첫 번째 앱을 출시하며 배운 7가지 소중한 교훈</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 모바일 개발에서 Feature Flags 사용 방법" href="/post/2024-06-23-FeatureFlagsiniOSMobileDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 모바일 개발에서 Feature Flags 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 모바일 개발에서 Feature Flags 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 모바일 개발에서 Feature Flags 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 No MediaQuery widget found 오류 해결하는 방법" href="/post/2024-06-23-ResolvingNoMediaQuerywidgetfoundErrorinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 No MediaQuery widget found 오류 해결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ResolvingNoMediaQuerywidgetfoundErrorinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 No MediaQuery widget found 오류 해결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Flutter에서 No MediaQuery widget found 오류 해결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter로 인물 및 가로 모드가 가능한 카메라 앱 만드는 방법" href="/post/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter로 인물 및 가로 모드가 가능한 카메라 앱 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter로 인물 및 가로 모드가 가능한 카메라 앱 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Flutter로 인물 및 가로 모드가 가능한 카메라 앱 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 간단하게 Pull to Refresh 구현하는 방법" href="/post/2024-06-23-SimpleFlutterpulltorefresh"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 간단하게 Pull to Refresh 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SimpleFlutterpulltorefresh_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 간단하게 Pull to Refresh 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Flutter에서 간단하게 Pull to Refresh 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법" href="/post/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">36<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link posts_-active__YVJEi" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"레스토랑 사업을 위한 혁신적인 음식 앱 아이디어 2024년 최신 트렌드","description":"","date":"2024-06-23 21:47","slug":"2024-06-23-FoodAppIdeasforRestaurantBusinessesInnovatingDining","content":"\n이미지 태그를 Markdown 형식으로 변경해주세요.\n\n기술은 오늘날 빠르게 발전하는 레스토랑 산업에서 번창의 비밀 재료로 자리 잡았어요. 특히 음식 앱은 레스토랑 사업에 혁명을 일으키는 중요한 역할을 하고 있어요. 이러한 앱들은 고객이 자신이 좋아하는 음식점을 발견하고 주문하며 소통하기에 편리하고 효율적인 방법을 제공해요. 이들은 고객 경험을 향상시키는데 그치지 않고 레스토랑에게 고객 선호도와 행동에 대한 가치 있는 통찰을 제공해요. 온라인 예약부터 디지털 메뉴, 접촉 없는 결제까지, 기술은 산업의 발전에 빼놓을 수 없는 부분이 되었어요.\n\n이 기사에서는 레스토랑 산업에서 음식 앱에 대한 성장하는 필요성을 살펴보고 최고의 음식 앱 아이디어를 탐구해볼 거예요. 또한 레스토랑 앱 아이디어의 사례 연구를 살펴보고 레스토랑 업체에 제공된 혜택을 살펴볼 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소스: unsplash.com\n\n# 레스토랑 앱 아이디어: 음식 앱 필요성에 대한 배경\n\n소비자 선호도와 식사 습관이 계속 변화함에 따라, 레스토랑 사업들은 관련성 유지를 위해 적응해야 합니다. 이 섹션에서는 레스토랑을 위한 모바일 앱을 개발해야 하는 중요한 이유에 대해 논의합니다.\n\n## 변화하는 소비자 행동과 기대들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소비자들은 식사 경험을 포함한 일상의 모든 측면에서 편의와 효율성을 요구합니다. 스마트폰과 디지털 시대의 확산은 고객들을 원활하고 사용자 친화적인 음식 앱 개발 아이디어를 찾도록 조건부로 만들었습니다.\n\n음식 앱의 채택은 이러한 변화하는 소비자 행동에 대한 자연스러운 반응입니다. 고객들은 이제 스마트폰에서 몇 번의 탭만으로 메뉴를 탐색하고 주문을 배치하며 예약을 진행할 수 있는 편리함을 기대합니다. 식사나 음식 주문하는 전통적인 방식이 변화되어, 음식 앱은 현대 레스토랑 운영의 필수적인 부분으로 자리 잡았습니다.\n\n## 코로나바이러스 팬데믹이 식습관에 미치는 영향\n\n최근 몇 년간 COVID-19 팬데믹의 발생은 전 세계적으로 식습관의 풍경을 크게 변화시켰습니다. 건강 문제와 사회적 거리두기 조치로 인해 음식점은 상황에 맞는 레스토랑 앱 아이디어를 찾고 신속하게 적응해야 했습니다. 결과적으로, 특히 배달 및 테이크아웃 서비스를 위한 음식 앱의 채택은 전례없는 수준에 도달했습니다. 음식 앱은 많은 레스토랑에게 생명줄이 되어 어려운 시기에도 고객 유치와 수익을 유지할 수 있게 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코로나19 대유행이 종식되었지만, 채택된 편의성은 여전히 힘을 잃지 않고 있어요.\n\n## 레스토랑 사업주가 푸드 앱에 투자해야 하는 이유\n\n푸드 앱의 도입은 발전하는 소비자 행동이나 국제 위기의 영향에 대한 반응뿐만이 아닙니다. 이는 레스토랑 사업체에 다양한 이점을 제공하는 전략적 투자입니다. 이러한 앱들은 접근성을 향상시키고 운영을 최적화하며 맞춤 경험을 통해 고객 충성도를 육성함으로써 경쟁 우위를 확보합니다.\n\n푸드 앱에 투자함으로써 레스토랑은 현대 다이너들의 요구와 기대를 충족시킬 수 있는 전략적인 사업체로 자리매김합니다. 이점은 편의성을 넘어 수익 증대, 고객 재유지, 정보 기반의 의사 결정을 위한 가치 있는 데이터 접근 그리고 다양한 부가적 혜택을 포함합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 레스토랑 사업을 위한 혁신적인 앱 아이디어\n\n음식 앱은 더 이상 편의성을 넘어서만 있지 않습니다; 식사 경험 전체를 향상시키는 동적 도구로 발전했습니다. 특이한 맛을 발견하고 주문하고 식사를 즐기는 방법을 변화시키는 데서부터 음식 앱은 레스토랑과의 상호작용 방식을 혁신적으로 바꾸었습니다.\n\n그리고 더 나아가, 혁신적인 식품 사업 앱 아이디어의 세계를 탐색해보겠습니다. 여러분이 먹고 협업하고 식품과 상호작용하는 방법을 재정의하는 발명적인 개념의 다양한 메뉴로 뛰어들어볼 것입니다.\n\n## 가상 주방 마켓플레이스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가상 주방 시장은 메뉴 옵션을 다변화시키는 파트너십을 용이하게 합니다. 이를 통해 고객들에게 흥미로운 요리 경험을 제공할 수 있습니다. 식당 입장에서는 물리적 장소를 빌리지 않고도 레퍼토리를 확장할 수 있는 기회가 있습니다. 그리고 이에 대해 고객들은 독특한 다양한 식사 옵션을 만날 수 있습니다.\n\n가상 주방 또는 유령 주방으로도 알려진 가상 주방은 음식 앱에 통합될 수 있습니다. 이러한 주방 기능은 음식점 앱 개발에서 물리적 장소를 빌리지 않고도 음식점의 영향력을 확장하고 특별한 요리를 제공할 수 있도록 합니다.\n\n## 증강 현실 (AR) 메뉴\n\nAR 기술은 정적 메뉴를 상호 작용적이고 시각적으로 매력적인 경험으로 변화시킬 수 있습니다. 고객들은 스마트폰을 사용하여 메뉴 항목을 스캔하고 자세한 설명, 이미지, 심지어 비디오를 받아볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAR 메뉴는 고객들에게 메뉴 항목의 3D 시각화를 제공할 수 있습니다. 이를 통해 주문 전 요리가 어떻게 보이는지 확인할 수 있어 음식이 도착했을 때 놀라움을 줄일 수 있습니다.\n\n## AI-기반 음식 추천 시스템\n\nAI 알고리즘은 고객의 선호도, 과거 주문 내역, 날씨 또는 시간과 같은 외부 요소까지 분석하여 맞춤형 추천을 제공합니다. 이 결과로 고객은 자신의 취향과 일치하는 새로운 요리를 발견하는 데 기쁨을 느낄 수 있는 향상된 다이닝 경험을 얻을 수 있습니다.\n\n또한 레스토랑은 AI를 활용하여 고객 데이터를 수집하고 분석함으로써 메뉴 변경, 가격 정책, 마케팅 전략과 관련된 데이터 기반 결정을 내리는 데 도움을 받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 요리 수업 및 레시피 공유\n\n전통적인 식당 경험을 넘어서, 푸드 앱은 요리 교육과 커뮤니티 참여를 촉진할 수 있습니다. 이는 레스토랑 앱 개발 아이디어를 통해 실현됩니다. 가상 요리 수업을 진행하거나 고객들이 즐겨 찾는 레시피를 공유할 수 있는 기능을 통해 이루어질 수 있습니다.\n\n푸드 앱은 유명 셰프들이 이끄는 가상 요리 수업을 제공하여 고객들이 집에서도 레스토랑 품질의 요리를 배우고 재현할 수 있도록 도와줍니다.\n\n고객들이 앱에서 자신의 레시피나 창작물을 공유하도록 장려함으로써, 커뮤니티와 참여감을 유도하면서 유용한 사용자 생성 콘텐츠를 제공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 지속가능한 다이닝 트래커\n\n지속가능성은 이제 더 이상 소수의 관심사가 아니라 식사객들에게 중요한 고려 사항이 되었습니다. 생태 친화적인 다이닝 선택을 촉진하는 음식 앱 개발 아이디어를 찾고 있다면, 여기 음식 앱이 작동하는 방식이 있습니다.\n\n음식 앱 내의 지속 가능한 식사 추적기는 고객에게 요리의 탄소 발자국이나 재료의 원산지와 같은 중요한 정보를 제공합니다. 이러한 정보를 투명하게 제시함으로써, 음식 앱은 고객들이 지속 가능한 가치에 부합하는 정보를 기반으로 선택을 할 수 있도록 돕습니다.\n\n또한, 음식 앱은 고객들이 지속 가능한 메뉴 항목을 선택할 경우 보너스나 할인 혜택을 제공하여 생태 친화적인 옵션을 선택하도록 고객을 자극할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-FoodAppIdeasforRestaurantBusinessesInnovatingDining_2.png)\n\n출처: unsplash.com\n\n# 혁신적인 식당 비즈니스를 위한 식음료 앱 아이디어에 대한 성공 사례\n\n이 섹션에서는 혁신적인 식음료 앱을 성공적으로 도입한 여러 식당 비즈니스의 사례 연구를 소개합니다. 이러한 사례 연구는 식당 비즈니스를 위한 다양한 앱 아이디어를 포함하며, 다양한 맥락에서의 효과를 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다기능 체인 레스토랑 관리 시스템\n\n배경:\n\n중동과 영국에 위치한 레스토랑 체인은 운영을 중앙 집중화하여 더 나은 관리 효율성과 편리성을 추구했습니다.\n\n해결책:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCeladonsoft은 사용자 행동 분석을 구현하고 POS 시스템을 통합하여 메뉴 데이터 동기화를 실현했으며, 중앙 주문 확인 지점을 설립하고 종단 간 충성 프로그램을 개발하고 실행했습니다.\n\n결과:\n\n- 충성 프로그램은 매출을 증가시키고 고객의 재방문을 유도하며 목표 시장에 대한 가치 있는 통찰력을 제공했습니다;\n- 앱은 비용을 줄이면서 비즈니스 운영을 개선했습니다;\n- 데이터 분석은 고객을 그들의 고객에게 더 가깝게 만들었습니다;\n- 자동화된 프로세스와 직원 업무를 효율적으로 진행했습니다;\n- 앱의 편의성으로 인해 매출이 증가하고 시장 확대를 이끌었습니다;\n- 관리를 최적화하는 관리자 패널의 도입이 있었습니다.\n\n![이미지](/assets/img/2024-06-23-FoodAppIdeasforRestaurantBusinessesInnovatingDining_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소스: celadonsoft.com\n\n## 레스토랑 네트워크를 위한 음식 주문 어플\n\n소도매상:\n\n레스토랑 사장은 레스토랑과 배달 서비스를 관리하기 위한 맞춤 솔루션을 개발하여 기업을 강화하고 효율성을 향상시키고자 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해결책:\n\nCeladonsoft는 목표를 달성하기 위해 모바일 앱 아이디어를 찾았고, 레스토랑 관리 및 배달 서비스에 대한 솔루션을 도출했습니다. 이 솔루션에는 다음이 포함되었습니다:\n\n- 지역 송장 및 결제와의 통합.\n- 필터가 있는 고급 쇼핑 카트.\n- 앱 내 기계 번역.\n- 배달원 및 관리자용 안전 맵.\n- 배송 추적을 위한 내장 GPS.\n- 앱 내 통화 기능.\n- 다중 관리자 역할.\n- 간소화된 주문 처리.\n- 메뉴 업데이트 자동화.\n\n결과:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고객사의 비즈니스는 소비자 트래픽과 고객 충성도의 향상으로 인해 매출이 증가하고 있으며, 솔루션 론칭으로는 퀵서비스 및 행정 직원에게 새로운 일자리 기회를 창출했습니다. 또한, 지역 송장 구독 및 결제 시스템과의 통합을 통해 결제 처리가 간소화되었습니다. 고급 관리자 패널을 구현하여 다단계 액세스를 제공하면서 레스토랑 운영이 자동화되고 현대화되었습니다.\n\n![음식점 비즈니스 혁신을 위한 레스토랑 앱 아이디어](/assets/img/2024-06-23-FoodAppIdeasforRestaurantBusinessesInnovatingDining_4.png)\n\n출처: celadonsoft.com\n\n## 레스토랑 기업을 위한 예측 앱 개발\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n배경:\n\n여러 개의 체인을 운영하는 레스토랑 기업이 고객 맞춤화와 충성도를 향상시키기 위해 2022 FIFA 월드컵과 관련된 레스토랑 앱 아이디어를 찾고 있었습니다. 예측 앱은 프로모션 캠페인의 일환으로 선보였습니다.\n\n솔루션:\n\n사용자들은 다른 사용자들과 예측 대결에 참여할 수 있었고, 경기 결과를 보여주는 리더보드가 개발되었습니다. 리더보드에서의 개인 순위에 따라 쿠폰과 포인트 형태의 상품이 수여되었고, 이러한 보상은 주 어플 내에서 사용할 수 있었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과:\n\n보너스 시스템은 새로운 고객을 유치하고 기존 고객들 사이의 충성을 높여 매출 급증을 이끌어냈습니다. 게다가, 보고 및 분석 기능의 통합을 통해 철저한 관객 분석이 가능해지면서 이해를 높이고 더 많은 맞춤 비즈니스 옵션을 제공할 수 있게 되었습니다.\n\n이러한 사례 연구는 레스토랑을 위한 앱을 개발하는 혁신적인 아이디어가 현실적인 성과를 도출할 수 있는 방법을 강조합니다. 음식물 낭비를 줄이고 고객 만족도를 높이며 배달 서비스 확대와 고객 충성도 육성까지, 이러한 앱을 도입함으로써 이러한 시설이 운영되는 방식을 변화시켰습니다.\n\n# 레스토랑용 모바일 앱 아이디어 포장\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n식품 앱은 소비자들의 기대 변화에 적응할 뿐만 아니라 산업 내 혁신을 이끌어내기도 합니다. 올바른 전략으로 레스토랑 앱을 만들면 레스토랑들이 디지털 시대에서 번창할 수 있습니다.\n\n레스토랑 산업에서 경쟁을 앞서가는 것은 중요하며, 음식 앱은 상당한 장점을 제공합니다. 지속적으로 혁신하고 최첨단 기술을 통합함으로써 레스토랑들은 그들의 중요성을 유지하고 더 넓은 고객층을 유치할 수 있습니다.\n\n기술이 계속 발전함에 따라 레스토랑 사업은 음식 앱이 제공하는 기회를 받아들여야 합니다. 수익성 있는 음식 앱 아이디어를 발굴함으로써, 사업은 현대 다이너들에 공감하는 독특하고 매력적인 경험을 만들 수 있습니다.\n\n레스토랑 산업의 미래는 적응하고 혁신하는 사람들의 손에 달려 있으며, 음식 앱은 그들의 전략의 선두에 있습니다. 이러한 기술을 받아들이는 것은 단순한 트렌드뿐만이 아닙니다. 영원히 변화하는 요리 환경에서 장기적인 성공을 위한 비결입니다. 약속된 레스토랑 앱 아이디어를 완전한 앱으로 만드는 것에 대해 언제든지 Celadonsoft에 문의해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원래 https://celadonsoft.com에 발행되었습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-FoodAppIdeasforRestaurantBusinessesInnovatingDining_0.png"},"coverImage":"/assets/img/2024-06-23-FoodAppIdeasforRestaurantBusinessesInnovatingDining_0.png","tag":["Tech"],"readingTime":11},{"title":"Groovy와 Kotlin DSL 최신 비교 어떤 걸 선택해야 할까","description":"","date":"2024-06-23 21:46","slug":"2024-06-23-GroovyvsKotlinDSL","content":"\n![Groovy vs Kotlin DSL](/assets/img/2024-06-23-GroovyvsKotlinDSL_0.png)\n\n## 소개\n\n안녕하세요 친구들, 이 기사에서는 코틀린과 그루비의 차이점, 코틀린 DSL과 그루비의 장단점을 살펴보겠습니다. 이 기사에서는 이주 단계에 대해 언급하지는 않았지만, 이주 전에 고려해야 할 기준을 제 경험을 바탕으로 표현하려고 노력했습니다. 그것이 유용하길 바랍니다. 시작해봅시다.\n\n## 그루비란 무엇인가\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGroovy는 자바 가상 머신을 위한 동적인 스크립팅 언어입니다. 바이트 코드로 컴파일되며 Java 코드 및 라이브러리와 원활하게 통합됩니다. Groovy는 간결하고 표현력이 뛰어나며 Java와 상호 운용성이 뛰어납니다.\n\n안녕하세요! 위의 표를 마크다운 형식으로 변경해드릴게요. 부가 내용이 있으면 언제든지 말해주세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Groovy는 동적 언어이기 때문에 빌드 과정 전까지는 잡히지 않는 런타임 오류가 발생할 수 있습니다.\n- 정적 타이핑의 부재로 인해 특정 상황에서 오류가 더 많이 발생할 수 있습니다.\n\n![Groovy vs Kotlin DSL](/assets/img/2024-06-23-GroovyvsKotlinDSL_1.png)\n\n## Kotlin DSL이 무엇인가요?\n\nKotlin 도메인 특화 언어(DSL)는 특정 문제 영역을 해결하기 위해 사용되는 Kotlin에 내장된 특수 목적 프로그래밍 언어입니다. Kotlin의 새로운 언어 구조로 자신을 확장할 수 있는 능력 덕분에 Kotlin DSL을 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점 Kotlin DSL in Android:\n\n- 정적 타이핑: Kotlin은 정적으로 타입이 지정된 언어로, 컴파일 시에 타입 안전성을 제공합니다. 이는 개발 프로세스 초기에 오류를 미리 확인하고 IDE에서 더 나은 도구 지원을 제공할 수 있습니다.\n- 현대적인 언어 기능: Kotlin은 간결하고 표현력이 풍부하며 기존 Java 코드와 상호 운용할 수 있는 현대적인 언어로 설계되었습니다. 널 안전성, 확장 함수, 스마트 캐스트와 같은 기능을 포함하고 있습니다.\n- Android에서 Gradle 빌드 스크립트: Kotlin DSL은 Android 프로젝트에서 Gradle 빌드 스크립트를 작성하는 데 점점 더 사용되고 있습니다. 기존 Groovy 기반 스크립트에 대한 더 간결하고 타입 안전한 대안을 제공합니다.\n- 도구 및 IDE 지원: Kotlin은 IntelliJ IDEA 및 Android Studio와 같은 인기 있는 IDE에서 탁월한 지원을 제공합니다. 이 지원에는 코드 완성, 리팩터링 도구, 빠른 탐색 등이 포함됩니다.\n- Java와의 호환성: Kotlin은 Java와 완전히 상호 운용할 수 있도록 설계되어 있어, Java에서 Kotlin으로 점진적으로 이전할 수 있습니다. 이 호환성은 Android 개발의 문맥에서 중요하며, 기존 코드베이스가 Java로 작성된 경우에 필수적입니다.\n\nKotlin DSL의 단점:\n\n빌드 시간을 제외한 다른 항목들은 실제로 단점이 아닌 것처럼 보입니다. 하지만 Android 개발의 미래를 염두에 두어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 빌드 시간: 빌드 스크립트의 복잡성과 수행하는 특정 작업에 따라 Kotlin DSL은 Groovy보다 약간 더 긴 빌드 시간을 소요할 수 있습니다. 그러나 개선 및 최적화가 계속 이루어지고 있으므로 시간이 지남에 따라 이 측면이 변할 수 있습니다.\n- 도구 지원: 안드로이드 스튜디오에서 Kotlin에 대한 도구 지원은 일반적으로 우수하지만, 더 성숙한 Groovy 기반 스크립트에 비해 가끔 문제나 업데이트 지연이 발생할 수 있습니다. Kotlin DSL이 보다 보편화되면 이 차이는 좁혀질 것으로 예상됩니다.\n- 플러그인 호환성: 일부 플러그인이나 제3자 도구는 원래 Groovy 기반 스크립트를 고려하여 설계되었을 수 있습니다. Kotlin DSL은 높은 호환성을 갖도록 설계되었지만, 플러그인 개발자들이 Kotlin DSL을 더 잘 지원하기 위해 도구를 업데이트해야 하는 경우도 있을 수 있습니다.\n- Kotlin에 대한 의존성: Gradle 빌드 스크립트에 Kotlin DSL을 채택하면 프로젝트가 Kotlin 생태계와 더 긴밀하게 연결됩니다. Kotlin은 안드로이드 개발을 공식적으로 지원하지만, 프로젝트에 언어 선택과 관련된 특정 요구사항이나 제약조건이 있는 경우 고려해야 합니다.\n- 커뮤니티 및 자원: Kotlin은 안드로이드 생태계에서 잘 지원되지만, Gradle을 위한 Kotlin DSL은 Groovy에 비해 비교적 최근에 나왔습니다. 이는 Groovy 기반 Gradle 스크립트에 대한 문제 해결 및 문제 해결을 위한 커뮤니티와 자원이 Groovy에 대한 커뮤니티 및 자원이 더 풍부할 수 있음을 의미합니다.\n\n## 이전\n\n마이그레이션은 어렵지 않지만 너무 쉽지도 않을 것입니다. 이 기사에서는 마이그레이션 단계에 대해 다루지 않지만, Groovy에서 Kotlin DSL로의 마이그레이션에 대한 숨겨진 단점에 대해 논의해야 합니다.\n\n오해하지 마세요, 저는 Groovy에서 Kotlin DSL로 마이그레이션을 강력히 추천합니다. Kotlin DSL에는 많은 장점이 있기 때문에 그것을 사용하지 않을 것을 권하는 것은 완전히 어처구니 없는 일이 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 개인 또는 팀으로 이주하기 전에, 이주 과정 중 가능한 결과를 고려해야 합니다. 제가 본 관점에서 가능한 결과를 나열해 봤습니다. 안드로이드 개발 전문가들이 이 목록을 보다 상세히 설명할 수 있을 것입니다.\n\n- 학습 곡선: 팀이 이미 전통적인 Groovy 기반 Gradle 스크립트에 익숙하다면, Kotlin DSL로 전환하는 것과 관련된 학습 곡선이 있을 수 있습니다. 개발자들이 Kotlin DSL에서 도입된 새로운 구문과 개념에 익숙해지는 데 시간이 걸릴 수 있습니다.\n- 기존 프로젝트 이주: 기존 프로젝트를 Groovy 기반 스크립트에서 Kotlin DSL로 이주하는 것은 노력이 필요할 수 있으며, 원활한 전환을 보장하기 위한 도전이 있을 수 있습니다. 이주 과정을 신중하게 계획하여 중단을 최소화하는 것이 중요합니다.\n- 팀 전문성: 팀이 Groovy에 더 익숙하거나 Gradle 스크립트에 Groovy를 사용한 강력한 역사가 있는 경우, Kotlin DSL로 전환하기 위해서 추가적인 교육과 조정이 필요할 수 있습니다.\n\n## 결론\n\n이것으로 이번 글을 마칩니다. Groovy와 Kotlin DSL에 대해 이야기했습니다. 즉시 이 작업을 시작하고 싶은 분들을 위해 Groovy에서 Kotlin DSL로 전환하기 위한 필요한 모든 단계를 담은 공식 문서를 공유하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 참고문헌\n","ogImage":{"url":"/assets/img/2024-06-23-GroovyvsKotlinDSL_0.png"},"coverImage":"/assets/img/2024-06-23-GroovyvsKotlinDSL_0.png","tag":["Tech"],"readingTime":5},{"title":"Reactjs로 모바일 앱 개발하기 예측불가능한 경우들의 완벽한 궁합","description":"","date":"2024-06-23 21:45","slug":"2024-06-23-ReactjsforMobileAppDevelopmentUnpredictableMatchforTheCases","content":"\n![image](/assets/img/2024-06-23-ReactjsforMobileAppDevelopmentUnpredictableMatchforTheCases_0.png)\n\n현재 발전 중인 IT 세계에서 프로젝트 빌딩을 위한 도구 선택은 매일 어려워지고 있습니다. 인기 있는 도구와 잘 알려지지 않은 도구가 많아서 어떻게 선택해야 할까요?\n\n선택은 항상 팀이 특정 스택에 익숙한지에 기반해야 합니다.\n\n하지만, 현재 우리의 노력에서 가장 많이 사용되는 도구들에 대해 이야기한다면, 모바일 애플리케이션 개발에 React.js를 살펴볼 가치가 있습니다. 명백하지 않을 수 있지만, 우리는 독자들의 생각을 바꾸려고 노력할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 모바일 개발에서 React를 사용하나요?\n\n이미 React.js를 웹 개발에 적용한 영향을 파악했습니다. 그렇다면 React.js는 모바일 앱 개발에 사용되는지요? 함께 살펴봅시다.\n\n우선, RJS는 웹 애플리케이션을 위한 UI 구성 도구이므로 휴대용 기기 제품을 구축하기 위해 명시적으로 설계되지는 않았습니다. 그러나 그 일부 측면에 여전히 활용될 수 있으며, 특히 PWA(Progressive Web App) 또는 하이브리드 모바일-데스크톱 케이스를 생성하는 데 특히 유용합니다.\n\nRJS의 모바일 앱 개발에 React.js를 사용하는 이유를 RJS의 모든 단계에 대해 번복하며 설명하지는 않겠습니다. 대신에, 다양하고 특히 하이브리드 개발에 대한 React.js 개발 유용성을 파악해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알림!\n\n다양한 접근 방식의 세부 사항을 이해하는 것이 중요합니다.\n\n- RJS 패키지를 사용하면 장치의 운영 체제와 독립적으로 모바일 브라우저에서 작동하는 웹페이지를 만들 수 있습니다.\n- RN을 사용하면 iOS 및 안드로이드 스마트폰 또는 네이티브 앱용으로 멀티 플랫폼 프로젝트를 구축할 수 있습니다.\n\n# REACT를 통한 모바일 개발의 기적\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact를 사용한 모바일 앱 개발의 혜택이 실제로 존재할까요? 아니면 그냥 트렌드 때문에 사용되는 것인가요?\n\n간단한 답변은 - 아니요. 하지만 주제를 더 깊게 살펴봅시다.\n\n- 다중 플랫폼: React는 웹, 모바일 및 데스크톱과 같이 둘 이상의 운영체제에서 실행되는 하이브리드 프로젝트를 조립할 수 있습니다. 이는 생산을 간소화하고 운영체제 간 일관된 동작을 보장합니다.\n- 기본 재사용: RJS를 사용하여 작성된 코드는 다양한 프로젝트와 운영체제에서 재사용될 수 있으므로 생산 시간을 크게 줄이고 통일된 스타일과 기능을 제공합니다.\n- 생태계와 도구: RJS는 애플리케이션의 형태를 관리하는 Redux, 탐색을 위한 React Router 및 기타 여러 도구와 카탈로그로 구성된 넓은 생태계를 보유하고 있어 생산주기를 촉진합니다.\n- 성능: RJS는 가상 DOM과 재그리기 메커니즘을 통해 높은 성능을 제공합니다. 하이브리드 케이스에서 특히 중요하며, 다양한 접근방식과 미디어로 인해 과제가 발생할 수 있습니다.\n- 커뮤니티 지원: RJS는 다양한 리소스, 문서, 교육 자료 및 경험이 많은 창조자로부터의 지원을 제공하는 광범위한 커뮤니티에 의해 지원됩니다.\n- 네이티브 기능: RN을 구현하면 네이티브 모듈을 추가하여 장치 API 및 기능에 액세스할 수 있어 광범위한 기능을 갖춘 강력한 하이브리드 케이스를 생성할 수 있습니다.\n\n모바일 제품에만 사용할 수 없더라도 RJS를 사용하여 하이브리드 모바일-데스크톱 개발에 많은 이점이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![ReactJS for Mobile App Development](/assets/img/2024-06-23-ReactjsforMobileAppDevelopmentUnpredictableMatchforTheCases_1.png)\n\n# 어려움을 극복하는 쉬운 방법\n\n여전히 자신에게 물어볼 수 있습니다: RJS와 RN을 모바일 앱 개발에 선택하는 이유가 무엇인가요?\n\nRJS는 RN과 달리 모바일 케이스를 직접 설계하는 데 일반적으로 사용되지 않습니다. 주로 웹 기반 UI를 만드는 데 사용됩니다. 그러나 React를 기반으로 하는 RN은 React 세부 정보를 사용하여 휴대용 OS 프로젝트를 쉽게 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRN을 사용하면 React 부품을 활용하여 JS 기반 UI를 구축한 다음 각 대상 플랫폼에 대해 네이티브 코드로 변환할 수 있습니다. RN은 휴대용 장치 프로젝트를 생성하는 데 최적의 선택지입니다. 따라서 개발자는 미디어용으로 JS 코딩을 한 번 작성하여 개발 프로세스를 상당히 간단하고 신속하게 만들 수 있습니다.\n\n따라서 핸드폰 앱 개발에 React.js를 적용할 계획이 있다면, RN과 결합하여 React 부품과 JS를 활용하여 하이브리드 모바일-데스크톱 케이스를 구축하는 데 초점을 맞추어야 합니다.\n\n이것은 명백한 결정이 아니므로, 이 아이디어를 실현하려면 해당 분야에서 우수한 경험을 가진 전문 외부 업체에 문의하는 것이 좋습니다.\n\n귀사의 아이디어에 대한 상담을 받고 더 나은 제품 케이스를 형성하기 위해 Celadonsoft에 연락해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원문: https://celadonsoft.com 에서 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-ReactjsforMobileAppDevelopmentUnpredictableMatchforTheCases_0.png"},"coverImage":"/assets/img/2024-06-23-ReactjsforMobileAppDevelopmentUnpredictableMatchforTheCases_0.png","tag":["Tech"],"readingTime":5},{"title":"간단한 커스텀 훅을 이용한 React Native 앱 상태 마스터하기","description":"","date":"2024-06-23 21:44","slug":"2024-06-23-MasteringAppStateinReactNativewithasimplecustomhook","content":"\n# 소개\n\n애플리케이션 상태를 관리하는 것은 견고한 React Native 애플리케이션을 구축하는 중요한 측면입니다. 이 글에서는 애플리케이션 상태 변경을 간소화하기 위해 설계된 useAppStateCheck라는 사용자 정의 React 훅을 탐구해 보겠습니다. 이 훅은 React Native의 AppState 모듈을 활용하여 애플리케이션의 라이프사이클 변경을 추적하고 대응하는 우아한 해결책을 제공합니다.\n\n# useAppStateCheck 훅\n\nuseAppStateCheck 훅은 React Native 컴포넌트에 애플리케이션 상태 모니터링을 간편하게 통합할 수 있는 다재다능한 도구입니다. 이를 사용해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// useAppStateCheck.tsx\n\nimport { useCallback, useEffect } from \"react\";\nimport {\n  NativeEventSubscription,\n  AppState,\n  AppStateStatus,\n} from \"react-native\";\n\ninterface useAppStateCheckProps {\n  setAppStateStatus: React.Dispatch\u003cReact.SetStateAction\u003cAppStateStatus\u003e\u003e;\n}\n\nexport default function useAppStateCheck(props: useAppStateCheckProps) {\n  const { setAppStateStatus } = props;\n\n  const handleAppStateChange = useCallback(\n    async (nextAppState: AppStateStatus) =\u003e {\n      setAppStateStatus(nextAppState);\n    },\n    [setAppStateStatus]\n  );\n\n  useEffect(() =\u003e {\n    let eventListener: NativeEventSubscription;\n    eventListener = AppState.addEventListener(\"change\", handleAppStateChange);\n\n    return () =\u003e {\n      eventListener \u0026\u0026 eventListener.remove();\n    };\n  }, [handleAppStateChange]);\n}\n```\n\n# 애플리케이션에 통합\n\nuseAppStateCheck 훅을 사용하는 것은 매우 간단합니다. React Native 컴포넌트에 신속하게 통합하는 방법을 보여드리겠습니다.\n\nApp.tsx에서 처음에 AppStateStatusContext에서 사용되는 상태를 선언한 곳에서, useEffect 종속성으로 appStateStatus를 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```jsx\n// App.tsx\n\nimport React, { useState, useEffect, useCallback, useContext } from \"react\";\nimport { AppStateStatusContext } from \"./AppStateStatusContext\"; // 앱 상태 관리를 위한 컨텍스트가 있다고 가정합니다\n\nconst App = () =\u003e {\n  const [appStateStatus, setAppStateStatus] = useState(undefined);\n  useAppStateCheck({ setAppStateStatus });\n\n  const onAppStateChange = useCallback(() =\u003e {\n    switch (appStateStatus) {\n      case \"active\":\n        // 앱이 활성 상태인 경우 수행해야 할 작업\n        break;\n      case \"background\":\n        // 앱이 백그라운드 상태인 경우 수행해야 할 작업\n        break;\n      case \"inactive\":\n        // 앱이 비활성 상태인 경우 수행해야 할 작업\n        break;\n      default:\n        // 다른 앱 상태 시나리오 처리\n        break;\n    }\n  }, [appStateStatus]);\n\n  useEffect(() =\u003e {\n    onAppStateChange();\n  }, [onAppStateChange]);\n\n  return (\n    \u003cAppStateStatusContext.Provider\n      value={{ appStateStatus, setAppStateStatus }}\n    \u003e\n      {/* 여러분의 앱 컴포넌트들 */}\n    \u003c/AppStateStatusContext.Provider\u003e\n  );\n};\n```\n\n다른 앱 부분에서 사용하기 위해서는 AppStateStatusContext로부터 값 가져오기만 하면 됩니다:\n\n```jsx\n// Example.page.tsx\n\nimport { useContext, useEffect, useCallback } from \"react\";\nimport AppStateStatusContext from \"../../contexts/AppStateStatusContext\";\n\nexport const ExamplePage: React.FC = () =\u003e {\n  const { appStateStatus } = useContext(AppStateStatusContext);\n\n  const onAppStateChange = useCallback(() =\u003e {\n    switch (appStateStatus) {\n      case \"active\":\n        // 앱이 활성 상태인 경우 수행해야 할 작업\n        break;\n      case \"background\":\n        // 앱이 백그라운드 상태인 경우 수행해야 할 작업\n        break;\n      case \"inactive\":\n        // 앱이 비활성 상태인 경우 수행해야 할 작업\n        break;\n      default:\n        // 다른 앱 상태 시나리오 처리\n        break;\n    }\n  }, [appStateStatus]);\n\n  useEffect(() =\u003e {\n    onAppStateChange();\n  }, [onAppStateChange]);\n\n  return \u003cView\u003e\u003c/View\u003e;\n};\n```\n\n# 앱 상태에 맞게 컨텍스트 설정하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱 상태에 대한 보다 포괄적인 컨텍스트를 제공하기 위해 컨텍스트 제공자를 사용하는 것을 고려해보세요. 위 예제에서는 AppStateStatusContext를 사용하여 앱 상태 및 setAppStateStatus를 중앙 집중식으로 캡슐화합니다.\n\n```js\n// AppStateStatusContext.tsx\nimport * as React from 'react';\nimport { AppStateStatus } from 'react-native';\n\nconst AppStateStatusContext = React.createContext\u003c{\n    appStateStatus: AppStateStatus;\n    setAppStateStatus: React.Dispatch\u003cReact.SetStateAction\u003cAppStateStatus\u003e\u003e;\n}\u003e({\n    appStateStatus: 'active',\n    setAppStateStatus: () =\u003e {},\n});\n\nexport default AppStateStatusContext;\n```\n\n# 결론\n\nReact Native에서 앱 상태를 숙달하는 것은 반응성 및 안정성 있는 애플리케이션을 구축하는 데 필수적입니다. useAppStateCheck 사용자 정의 React Hook을 사용하면 앱 상태 변경 처리 과정을 간소화하여 코드베이스가 보다 깔끔하고 유지 관리하기 쉬워집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 이 접근 방식을 적용한 사용 사례 중 하나로, 앱이 백그라운드로 전환되고 다시 활성 상태로 돌아올 때 기기 시간이 수동으로 변경되었는지 확인하는 것이 있습니다.\n\n전체 구현을 자유롭게 살펴보시고 프로젝트의 구체적인 요구 사항에 맞게 사용자 정의할 수 있습니다. 즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-06-23-MasteringAppStateinReactNativewithasimplecustomhook_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringAppStateinReactNativewithasimplecustomhook_0.png","tag":["Tech"],"readingTime":6},{"title":"플레이 스토어에 첫 번째 앱을 출시하며 배운 7가지 소중한 교훈","description":"","date":"2024-06-23 21:43","slug":"2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore","content":"\n앱 출판의 장애물을 극복하는 개발자의 솔직한 여정\n\n![image](/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_0.png)\n\n이 여정은 \"튜토리얼 지옥\"의 격전지에서 앱 출판의 흥미진진한 세계로 나를 이끌었습니다. 제가 겪었던 여러 어려움을 공유하여 여러분이 이 과정을 더 원할하게 탐험할 수 있도록 도와드리겠습니다.\n\n- 튜토리얼 지옥을 벗어나기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱 개발 여정 중 처음 6개월은 튜토리얼에 많이 의존했어요. 각각의 튜토리얼을 통해 새로운 것을 배우긴 했지만, 종종 근본적인 개념을 제대로 이해하지 못한 채 지시사항을 따라가는 상황에 갇혔어요. 이를 어떤 사람들은 \"튜토리얼 지옥\"이라고 부르죠.\n\n교훈: 튜토리얼은 귀중한 자원이지만 맹목적으로 따르지 마세요. \"어떻게\" 뒤에 숨은 \"왜\"를 이해하기 위해 노력해보세요.\n\n내 아이디어를 주도하는 경험은 궁극적인 힘이 되었어요! 앱을 개발한 후, Play Store에 출시하기 위한 \"20명 테스터 필요\" 규정을 마주하게 되었어요. 이는 앱을 14일 연속으로 적극적으로 테스트할 20명의 테스터를 찾아내는 것을 의미했어요. 사교적 상호작용을 최소화하는 제 성향을 고려하면, 이 테스터들을 모아내는 데 감히 2개월이 걸렸네요!\n\n교훈: 계획을 세워보세요! 앱의 출시 일정을 예상할 때 테스터를 찾는 것도 고려해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 내 내성적인 성격을 극복하다\n\n과거에는 꽤 내성적이었던 나로서는 테스터를 찾는 사회적 측면이 무서웠습니다. 그래서 이 작업이 이렇게 오래 걸렸구나라고 이것이 그 이유였습니다! 그러나 이 장벽을 극복한 것은 개인적인 승리였습니다.\n\n교훈: 편안한 지역을 벗어나는 것은 보람찬 경험이 될 수 있습니다. 내내성으로 인해 목표를 이루는 데 방해받지 마세요.\n\n![이미지](/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. Google Play 개발자 계정 만들기: 나의 경험\n\nPlay Store에 앱을 게시하는 여정이 내가 상상했던 것만큼 간단하지는 않았다. 초기 단계는 간단했다: 개인 또는 조직 계정 중 선택하고 이메일, 전화번호, 지불 방법을 제공하는 것이었다. 그러나 계정 인증이라는 진짜 장벽이 생겼다.\n\n내 신원을 인증하는 과정은 두 단계로 이루어졌다. 첫 번째는 쉬웠다 — 운전면허증, 여권, 선거증과 같은 정부 발급 신분증의 앞면과 뒷면 이미지를 제출하는 것이었다. 그러나 두 번째 단계는 좀 까다로웠다. Google은 제출한 문서에 있는 주소가 제공한 주소와 정확히 일치해야 한다고 요구했다. 이 보다는 간단해 보이는 작업이 나에게 두 번의 거부를 불러왔다!\n\n여기서 중요한 점은 등록할 때 입력하는 주소가 선택한 신분증 문서에 있는 주소와 완벽하게 일치하도록 하는 것이다. 이는 공과금, 은행 명세서 또는 임대 계약서의 사본일 수 있다. 반복적인 거부는 나중에 인증할 능력을 제한할 수 있으니 유의해야 한다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 자세한 내용을 원하시나요?\n\n전체 프로세스를 상세히 살펴보려면 제 미디엄 기사를 확인해보세요: \"2024년에 개발자 계정 만드는 방법: Google Play Store 잠금 해제하기\"\n\n4. 앱 생성 및 업로드\n\n계정이 확인된 후에 앱을 만들어 업로드할 수 있습니다. 이 과정에서 앱이나 게임인지, 가격 모델(무료 또는 유료), 필요한 동의를 받는 등의 세부 정보를 지정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이후에는 앱 대시보드에 착륙하게 될 거에요. 여기서 \"프로덕션 언락\" 장벽을 만날 수도 있는데, 20명의 테스터가 14일 연속으로 앱을 활발히 테스트하도록 참여해야 한다는 요구 조건입니다.\n\n5. 20명 테스터 요건: 주의해야 할 사례\n\n여기서 재미있는 일들이 벌어지죠! 테스터를 구하는 데 어려움을 겪었던 걸 기억하시나요? 앱을 론칭하려는 초기 흥분이 Google Play의 내부 테스팅이 아닌 폐쇄 테스팅이 필요하다는 요구 사항과 충돌했어요. 내부 테스팅(친구와 가족과 함께)으로 업로드하는 것은 잘못된 방법이었죠! 그 테스터들은 폐쇄 테스팅 트랙의 일원이 아니라 참여할 수 없었어요.\n\n교훈: 세부 사항을 꼼꼼히 읽어보세요! 앱을 업로드하기 전에 내부 테스팅과 폐쇄 테스팅의 차이를 이해하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_2.png)\n\n6. 테스터 찾기: 미션 임파서블은 아니에요 (하지만 느낌은 비슷할 수 있어요)\n\n테스터를 찾기 어려워 지불 서비스를 탐색했지만 다행히도 무료 대안을 찾을 수 있었어요 (나중에 더 자세히 알려줄게요). 테스터를 찾는 무료 방법이 있다는 것을 기억하세요. 그러나 예전에 연락을 취한 적이 없는 사람들에게 연락해야 할 수도 있어요. 은애어 앱의 테스터를 모으는 팁은 아래와 같아요:\n\n- 앱의 특정 분야와 관련된 온라인 커뮤니티 및 포럼.\n- 앱 개발이나 베타 테스트에 중점을 둔 소셜 미디어 그룹.\n- 대학 캠퍼스 (앱이 학생을 대상으로하는 경우)\n- 기술 애호가나 기업가를 위한 로컬 밋업.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. 결론: 앱 출판을 위한 더 스무디한 길\n\n이 정보 폭포는 앱 출판의 어두운 물길을 잘 건널 수 있도록 도와줬기를 희망합니다! 이 단계를 따르면 저가 겪은 함정을 피하고 과정을 더욱 원할하게 진행할 수 있습니다.\n\n더 자세히 알고 싶나요? 제 다른 글인 \"Play Store에 앱 출판 전 알아야 할 사항\"에서 종합적으로 설명하고 있습니다.\n\n읽어 주셔서 감사합니다. 행복한 개발되세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://saurabh7973.medium.com/subscribe\n","ogImage":{"url":"/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_0.png"},"coverImage":"/assets/img/2024-06-23-7Hard-EarnedLessonsfromPublishingMyFirstApponthePlayStore_0.png","tag":["Tech"],"readingTime":6},{"title":"iOS 모바일 개발에서 Feature Flags 사용 방법","description":"","date":"2024-06-23 21:41","slug":"2024-06-23-FeatureFlagsiniOSMobileDevelopment","content":"\n앱 개발의 동적인 환경에서는 새로운 기능을 도입하거나 기존 기능을 대체해야 하는 필요성이 항상 존재합니다. 전통적으로, 개발자들은 과거 코드를 제거하거나 주석 처리하고 새 코드를 통합한 후 업데이트를 앱 스토어에 제출한 다음 변경 사항을 공개하기 전에 검토 프로세스를 기다리는 경우가 많습니다. 그러나 이 방식은 앱 스토어의 검토 일정을 기다려야 하는 큰 문제점을 안고 있습니다.\n\n대안으로, 더 나은 방법이 있습니다. 바로 피처 플래그(Feature flags)를 사용하는 것입니다. 이러한 플래그를 사용하면 특정 기능의 가시성과 동작을 손쉽게 제어할 수 있으며 복잡한 코드 변경이나 앱 스토어 제출 없이 기능을 관리할 수 있습니다. 예를 들어, 특정 기능을 특정 시간 동안만 활성화하고 싶다면, 피처 플래그를 사용하여 기능이 나타나는 조건을 제어할 수 있습니다. 앱 스토어에 새로운 빌드를 제출할 필요가 없습니다. 매끄럽고 효율적인 프로세스가 됩니다.\n\n개인적인 개발 경험을 바탕으로 말하자면, 특정 시간대에만 특정 뷰를 제공하고 싶은 경우가 있었습니다. 피처 플래그는 이러한 시간에 민감한 기능 구현을 효율적으로 처리할 수 있는 강력한 도구로 작용했습니다.\n\n![이미지](/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 기능 플래그란 무엇인가요?\n\n본질적으로, 기능 플래그 또는 기능 토글이라고도 알려진 것은 일반적으로 서버에 저장된 값입니다. Firebase, SupaBase 또는 서버에 호스팅된 JSON과 같은 곳에 저장됩니다. 이 값은 특정 기능 이름과 부울 값과 연결됩니다. 모바일 애플리케이션이 이 객체를 가져오면 해당 기능이 활성화되었는지 비활성화되었는지 확인합니다. 활성화되어 있으면 앱은 일련의 기능을 실행하거나 특정 기능을 제공합니다. 이러한 동적 제어는 개발자가 기능을 선택적으로 관리하고 릴리스할 수 있도록 하여 애플리케이션의 동작을 유연하게 제어할 수 있게 합니다.\n\n# 서버 측\n\n프로세스를 가동하기 위해 앱에 가져올 기능을 저장하기 위한 리포지토리를 설정하는 것이 중요합니다. 제 경우에는 내 앱 내에서 이미 통합되어 있는 SupaBase를 선택하여 이를 활용했습니다. 이 선택은 추가적인 SDK를 통합하거나 새로운 구현을 도입할 필요성을 제거하고, 만들어 둔 테이블을 호출하는 방법으로 단순화된 과정을 제공합니다. 새로운 feature_flag라는 테이블을 만든 다음 다음 필드를 포함했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- created_at\n- is_enabled\n- feature_name\n- number_users_seen\n\n\u003cimg src=\"/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_1.png\" /\u003e\n\n'feature_name'을 이해하기 쉬운 내용으로 설정하는 것이 좋지만 원한다면 설명을 위한 다른 필드도 추가할 수 있습니다.\n\n'number_users_seen'은 내가 사용하는 사용 사례로 특정 기능을 본 사용자 수를 추적하는 것이지만 창의력과 요구 사항에 따라 추가 필드도 포함할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 클라이언트 측\n\n클라이언트 측 모델을 구축할 때는 데이터 구조와 완벽하게 일치하도록 설계하는 것이 중요합니다. 잘 구성된 모델은 응용 프로그램 전체에서 명확성과 일관성을 보장합니다.\n\n거기에 더해, 특히 기능 이름을 위한 enum을 포함하는 것을 고려해보세요. 열거형은 서로 다른 값 집합을 나타내는 구조화된 안전한 방법을 제공하며, 이 경우에는 각기 다른 기능 이름을 나타냅니다.\n\n여기서 enum의 장점에 대해 자세히 다루지는 않겠지만, docs.swift.org에서 더 많은 정보를 찾아볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Screenshot 1](/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_2.png)\n\n구체적인 상황으로 돌아와서, 특정 시간 프레임 내에서 뷰를 표시하고 한 번만 나타나도록하는 것을 목표로 한 내 상황에서는 아래에 설명된 방식과 유사한 접근 방식을 채택했습니다. 사용자가 프롬프트를 보았는지 여부를 추적하기 위해 UserDefaults (또는 SwiftUI에서의 @AppStorage)를 사용했습니다. 또한 featureFlags 데이터에 대한 Published 변수와 관련 시트를 표시해야 하는지를 결정하는 데 사용된 다른 Published 변수를 사용했습니다.\n\n- 기능 플래그 가져오기\n- shouldSowGiveAwaySheet 호출\n- updateHasSeenGiveAwayPrompt 호출\n\n![Screenshot 2](/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 수업 내에서는 FeatureFlagManager가 초기화될 때 getFeatureFlags를 호출하고 SupaBase에서 기능 플래그를 가져올 것입니다. 이 작업은 초기화 시에 수행하지 않을 수도 있으며 필요한 진입점에서 getFeatureFlags를 호출할 수도 있습니다.\n\n내가 기능 플래그가 있는 시트를 표시해야 하는지 결정해야 하는 경우 shouldShowGiveAwaySheet를 호출할 수 있습니다.\n\n```swift\nguard let featureIsEnabled = featureFlags.first(where:\n  { $0.featureName == .giveAwayPrompt })?.isEnabled else\n    { self.showGiveAwayFeature = false }\n```\n\n위의 guard 문은 giveAwayPrompt의 기능 플래그가 featureFlags 배열에 있는지 확인합니다. 해당 플래그를 찾지 못하면 showGiveAwayFeature를 false로 설정하고 함수를 일찍 종료합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nif featureIsEnabled \u0026\u0026 !hasSeenGiveAwayPrompt {\n  self.showGiveAwayFeature = true\n  self.updateHasSeenGiveAwayPrompt(featureName: .giveAwayPrompt)\n}\n```\n\n이 블록은 특징이 활성화되어 있고 사용자가 이전에 선물 증정 프롬프트를 보지 않은 경우에 실행됩니다.\n\ngiveaway 시트를 표시해야 한다는 것을 나타내기 위해 showGiveAwayFeature를 true로 설정합니다.\n\n또한, updateHasSeenGiveAwayPrompt 메소드를 호출하여 사용자가 선물 증정 프롬프트를 이제 보았다는 것을 나타내는 @AppStorage showGiveAwayFeature 표식을 업데이트합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nself.showGiveAwayFeature = false;\n```\n\n이 라인은 조건 블록 밖에 있으므로 해당 기능이 활성화되었는지와 사용자가 give-away 프롬프트를 보았는지 여부에 관계없이 실행됩니다. showGiveAwayFeature를 false로 설정하여 기본적으로 표시되지 않도록 합니다.\n\n# 열거형(enum)의 우아함\n\n열거형(enum)의 우아함은 updateHasSeenGiveAwayPrompt와 같은 함수에서 빛을 발합니다. 필수는 아니지만, 저는 switch 문을 사용하여 사용법을 설명하는 것이 중요하다고 생각합니다. 이 접근 방식은 새로운 기능이 도입되었을 때 개발자가 해당 경우를 명시적으로 처리하도록 요청하므로 코드 완성도를 높이고 놓치는 것을 방지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱 개발의 동적 영역에서 특징 플래그와 열거형의 신중한 사용은 개발자에게 유연하고 조직적인 도구 상자를 제공해줍니다. 우리는 특징 플래그가 동적 변경을 가능하게 하며, 지속적인 코드 수정이나 긴 앱 스토어 리뷰 없이 기능 릴리스를 원할하게 제어할 수 있도록 하는 방법을 살펴보았습니다. updateHasSeenGiveAwayPrompt와 같은 함수에서 열거형을 활용하면 코드의 가독성을 향상시킬 뿐만 아니라 새로운 기능 사례를 신중하게 처리하도록 개발자에게 강요하는 최선의 실천법을 갖추게 됩니다.\n\n우리가 계속 발전하는 응용 프로그램 개발 영역을 탐험하는 동안, 이러한 실천법은 귀중하다는 것을 입증했습니다. 이것은 효율적인 프로세스뿐만 아니라 탄력적이고 적응 가능한 코드 기반을 생성하는 데 기여합니다. 특징 플래그와 열거형을 활용하여, 개발자는 변화하는 요구 사항에 우아하게 대응하는 애플리케이션을 구축할 수 있으며, 이는 보다 효율적이고 유지보수가 쉽며 미래를 대비한 개발 경험을 제공합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_0.png"},"coverImage":"/assets/img/2024-06-23-FeatureFlagsiniOSMobileDevelopment_0.png","tag":["Tech"],"readingTime":7},{"title":"Flutter에서 No MediaQuery widget found 오류 해결하는 방법","description":"","date":"2024-06-23 21:40","slug":"2024-06-23-ResolvingNoMediaQuerywidgetfoundErrorinFlutter","content":"\n플러터를 사용해 오셨다면 언젠가 No MediaQuery 위젯을 찾을 수 없다는 오류와 마주쳐 보셨을 겁니다. 이 오류는 답답할 수 있지만, 다행히도 보통 쉽게 해결할 수 있어요. 이 글에서는 이 오류의 원인을 살펴보고 해결하는 방법을 알아볼 거에요.\n\n## 오류 이해하기\n\nNo MediaQuery 위젯을 찾을 수 없다는 오류는 주로 MediaQuery 클래스를 사용하여 화면 크기, 방향 또는 기타 미디어 관련 정보를 가져오려고 시도할 때 발생합니다. MediaQuery 클래스는 미디어 쿼리 데이터에 액세스해야 하는 위젯들보다 위젯 트리 계층구조에서 MediaQuery 위젯이 존재해야 합니다.\n\n## 일반적인 원인\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 에러의 일반적인 원인 중 하나는 MaterialApp, CupertinoApp 또는 WidgetsApp으로 래핑되지 않은 위젯에서 MediaQuery.of(context)를 사용하려고 시도하는 것입니다. 이러한 위젯들은 위젯 트리 상위에서 MediaQuery 위젯이 사용 가능하도록 보장합니다.\n\n## 예시 시나리오\n\n간단한 예시를 살펴보겠습니다. 다음과 같은 코드가 있다고 가정해봅시다:\n\n```js\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text(\n        '화면 너비: ${MediaQuery.of(context).size.width}',\n      ),\n    );\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 코드를 실행하면 No MediaQuery widget found 오류가 발생합니다. 이는 Text 위젯이 액세스를 시도하는 곳에 MediaQuery 위젯이 존재하지 않기 때문입니다.\n\n## 해결 방법\n\n이 오류를 해결하려면 MaterialApp, CupertinoApp 또는 WidgetsApp과 같은 MediaQuery 객체를 소개하는 위젯이 포함된 위젯 트리를 확인하십시오. 수정된 코드는 다음과 같습니다:\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('MediaQuery Example'),\n        ),\n        body: Center(\n          child: Text(\n            'Screen width: ${MediaQuery.of(context).size.width}',\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 수정된 버전에서는 MaterialApp 위젯이 MediaQuery 위젯이 위젯 트리 상위에 있는지 확인합니다. 이제 MediaQuery.of(context)를 사용하여 미디어 쿼리 정보에 성공적으로 액세스할 수 있습니다.\n\n## 대안 솔루션\n\n만약 MaterialApp을 사용하고 싶지 않다면 수동으로 위젯을 MediaQuery 위젯으로 래핑할 수 있습니다. 예를 들어:\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MediaQuery(\n      data: MediaQueryData.fromWindow(WidgetsBinding.instance.window),\n      child: Center(\n        child: Text(\n          '화면 너비: ${MediaQuery.of(context).size.width}',\n        ),\n      ),\n    );\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 버전에서는 MediaQuery 위젯을 수동으로 추가했습니다. 이 위젯에는 MediaQueryData.fromWindow으로 얻은 화면 데이터가 제공되었습니다.\n\n## 결론\n\n플러터(Flutter)에서 발생하는 No MediaQuery widget found 오류는 흔히 마주치는 장애물이지만, 위젯 트리에 MediaQuery 위젯이 포함되어 있는지 확인하여 쉽게 해결할 수 있습니다. MaterialApp, CupertinoApp 또는 WidgetsApp을 사용하거나 위젯을 수동으로 MediaQuery 위젯으로 래핑함으로써 이를 수행할 수 있습니다.\n\n이 오류를 이해하고 해결하는 것은 Flutter 개발 경험을 더욱 원만하고 효율적으로 만들어 줄 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-23-ResolvingNoMediaQuerywidgetfoundErrorinFlutter_0.png"},"coverImage":"/assets/img/2024-06-23-ResolvingNoMediaQuerywidgetfoundErrorinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"Flutter로 인물 및 가로 모드가 가능한 카메라 앱 만드는 방법","description":"","date":"2024-06-23 21:39","slug":"2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode","content":"\n![이미지](/assets/img/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode_0.png)\n\n현재 모바일 애플리케이션 개발에서 가장 흔한 단어 중 하나인 Flutter 입니다. Flutter는 요즘 가장 편리하고 강력한 크로스 플랫폼 프레임워크 중 하나입니다. 놀라운 커뮤니티, 도구 및 라이브러리를 갖추고 있어 여러분이 원하는 모바일 애플리케이션을 만들 수 있습니다.\n\n지금은 Flutter 애플리케이션에 카메라와 같은 기능이 있는 것이 매우 흔합니다. 여러분의 애플리케이션이 CRM이든 E-commerce이든 소셜 플랫폼이든, 카메라 기능은 매우 일반적이고 유용합니다. 모든 이런 미리 튜토리얼 단어들로 지루하게 만드는 것은 하지 않겠습니다. 바로 개발에 들어가 봅시다...\n\n사용할 패키지:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우린 flutter.dev의 Camera 패키지를 사용할 거야.\n\n패키지 설치 방법:\n\n이것을 당신의 패키지의 pubspec.yaml 파일에 다음과 같은 줄을 추가할 거야 (그리고 암시적으로 flutter pub get을 실행할 거야):\n\n```js\ndependencies:\n  camera: ^0.10.5+2\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 가져오기\n\n이제 당신의 Dart 코드에서 다음을 사용할 수 있습니다:\n\n```js\nimport \"package:camera/camera.dart\";\n```\n\n또한 이 링크를 클릭하여 패키지 설치를 확인할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 어떻게 구현하나요?\n\n나는 코드를 깔끔하게 작성하는 것을 선호해요. 모든 기능을 분리하고 모든 기능이나 기능이 재사용 가능하도록 만들려고 해요. 그래서 전체 카메라 기능을 분리하는 걸 좋아해요.\n아래에서 어떻게 할 수 있는지 알려드릴게요.\n단계 1: Stateful 위젯을 만드세요 (저는 CameraScreen이라고 이름 붙였어요).\n\n```js\nclass CameraScreen extends StatefulWidget\n```\n\n이제 List`CameraDescription` 유형의 변수를 취하세요. 메인 함수에서 초기화하려면 전역 변수로 만들 수도 있어요. 카메라 화면으로 이동하기 전에 사용 가능한 카메라 목록을 가져오는 것이 좋아요. 따라서 사용 가능한 카메라 목록을 가져오는 방법입니다. 메인 함수에서 사용 가능한 카메라 목록을 가져올 수도 있고, 카메라 화면으로 이동하기 전에 가져올 수도 있고, 카메라 컨트롤러를 초기화하기 전에 가져올 수도 있어요. 하지만 이렇게하여 사용 가능한 카메라를 가져올 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```dart\n// 여기에 코드를 넣어 주세요.\nList\u003cCameraDescription\u003e cameras = [];\nvoid getAvalaibleCamera() async {\n  try {\n    cameras = await availableCameras();\n  } catch (error, stackTrace) {\n    // 무언가를 처리합니다.\n  }\n}\n// 여기에 코드를 넣어 주세요.\n```\n\n단계 2: 이제 Init 함수를 정의합시다. Init 함수에서는 카메라에 필요한 모든 컨트롤러 및 기타 필요한 것들을 초기화할 것입니다. 다음과 같이 진행할 거에요.\n\n```dart\nlate CameraController _cameraController;\nlate CameraDescription backCamera, frontCamera;\n\n@override\nvoid initState() {\n  getAvailableCamera();\n\n  super.initState();\n}\n\n@override\nvoid dispose() {\n  _cameraController.dispose();\n  super.dispose();\n}\n\nvoid getAvailableCamera() async {\n  for (var i = 0; i \u003c cameras.length; i++) {\n    var camera = cameras[i];\n    if (camera.lensDirection == CameraLensDirection.back) {\n      backCamera = camera;\n    }\n    if (camera.lensDirection == CameraLensDirection.front) {\n      frontCamera = camera;\n    }\n  }\n  if (backCamera == null) {\n    backCamera = cameras.first;\n  }\n  if (frontCamera == null) {\n    frontCamera = cameras.last;\n  }\n  _cameraController = CameraController(backCamera, ResolutionPreset.medium);\n\n  _cameraController.initialize().then((_) {\n    if (!mounted) {\n      return;\n    }\n    setState(() {});\n  });\n}\n```\n\n단계 3: 예스, 초기화하는 것에 관해 충분히 알겠죠. 이제 UI로 넘어갑시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI를 만들 때는 화면을 최대한 간단하게 유지하려고 노력하고 있어요. CameraView와 두 개의 버튼(한 개는 사진 촬영을 위한 것이고, 다른 한 개는 카메라 설정 변경을 위한 것)만 있는 정적 UI를 만들 계획이에요.\n\n여기서 빌드 함수를 확인해 볼게요.\n\n```js\n @override\n  Widget build(BuildContext context) {\n    if (!_cameraController.value.isInitialized) {\n      return Container();\n    }\n    return Scaffold(\n      backgroundColor: Colors.transparent,\n      body: CameraPreview(_cameraController),\n      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,\n      floatingActionButton: Stack(\n        children: [\n          Align(\n            alignment: Alignment.bottomCenter,\n            child: FloatingActionButton(\n              backgroundColor: Colors.orange,\n              child: const Icon(Icons.camera_alt),\n              onPressed: () async {\n                XFile? image = await _cameraController.takePicture();\n                if(image != null){\n                  // todo: 여기에 코드를 추가해 주세요\n                }\n              },\n            ),\n          ),\n          Align(\n            alignment: Alignment.bottomRight,\n            child: Padding(\n              padding: EdgeInsets.only(right: 20),\n              child: FloatingActionButton(\n                backgroundColor: Colors.deepOrange,\n                child: const Icon(Icons.flip_camera_android),\n                onPressed: () {\n                  if (_cameraController.description.lensDirection == CameraLensDirection.back) {\n                    _cameraController = CameraController(frontCamera, ResolutionPreset.medium);\n                  } else {\n                    _cameraController = CameraController(backCamera, ResolutionPreset.medium);\n                  }\n\n                  _cameraController.initialize().then((_) {\n                    if (!mounted) {\n                      return;\n                    }\n                    setState(() {});\n                  });\n                },\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n```\n\n여기서 todo 섹션에서 작업할 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 UI가 될 것입니다. 하지만 UI에 대해서는 걱정하지 마세요. 마음대로 UI를 만들면 됩니다.\n\n![이미지](/assets/img/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode_1.png)\n\n단계 4: 여기까지는 모든 것이 카메라 패키지 설명서에 따라 괜찮아 보입니다. 하지만 이제 실제 문제가 발생합니다.\n\n\"자동 회전\" 모드를 끄고 이 사진처럼 가로 모드에서 사진을 찍고 싶을 때, 이미지가 90도 회전됩니다. 이 문제는 플러터 앱을 기본적으로 세로 모드로 설정하면서 발생합니다. 따라서 기기의 방향을 변경해도 앱이 방향에 따라 구성을 변경하지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n응, 알았어. 이 문제는 단순히 기기의 자동 회전 모드를 켜는 것으로 쉽게 해결할 수 있어. 그런데 이미지나 비디오 파일을 편평화하기 위해 자동 회전 모드가 필요한 카메라 앱을 본 적이 없어. 이제 그런 문제가 생기면 어떻게 해야 할까?\n\n첫 번째 할 일은, 기기가 어느 방향을 향하고 있는지 감지하는 것인데, 자동 회전 모드가 켜져 있던 말던 상관없이 이 작업을 수행해야 해.\n\n기기의 자동 회전을 끈 채로 OrientationBuilder를 사용하여 이를 감지할 수 없어.\n\n이를 확인하려면 자이로 센서를 사용해야 해. 인터넷에 센서에 대한 많은 정보가 있으니 찾아보길 추천해. 기기의 다양한 움직임 등을 감지하는 다른 센서들도 있어. 많은 게임이 이러한 센서들을 사용하여 사용자에게 깨끗한 게임 경험을 제공해.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자이로 센서를 앱에 설치하려면 sensor_plus라는 이 패키지를 추가해야 합니다.\n\npubspec.ymal 파일에 패키지를 설치하고 사용하려는 페이지에 가져와야 합니다.\n\n```js\ndependencies:\n  sensors_plus: ^3.0.3\n```\n\n제가 밝혔듯이 OrientationBuilder는 기기의 자동 회전 모드가 꺼져 있거나 강제로 앱을 특정 방향으로 설정한 경우에는 작동하지 않습니다. 그래서 기기의 방향을 알기 위해 직접 OrientationBuilder를 작성해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBuilder 위젯을 만들어 봅시다.\n\n```js\nimport 'dart:async';\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:sensors_plus/sensors_plus.dart';\n\nclass CustomOrientationBuilder extends StatefulWidget {\n  const CustomOrientationBuilder({required this.builder, required this.isVideosRecording, super.key});\n  /// 이 빌더 함수는 콘텍스트와 방향(열거형)을 제공합니다.\n  final Widget Function(BuildContext, CustomOrientation) builder;\n  /// 이것은 비디오 녹화 중인지 여부를 나타내는 플래그입니다.\n  /// 녹화 중인 경우 방향 변경이 인식되지 않습니다. 이 논리는 제가 만들었지만 여러분은 변경할 수 있습니다.\n  final bool isVideosRecording;\n  @override\n  State\u003cCustomOrientationBuilder\u003e createState() =\u003e _CustomOrientationBuilderState();\n}\n\nclass _CustomOrientationBuilderState extends State\u003cCustomOrientationBuilder\u003e {\n  late StreamSubscription\u003cAccelerometerEvent\u003e accelerometerSubscription;\n  CustomOrientation cameraOrientation = CustomOrientation.portrait;\n\n  @override\n  void initState() {\n    super.initState();\n    orientation();\n  }\n  @override\n  Widget build(BuildContext context) {\n    return widget.builder(context, cameraOrientation);\n  }\n\n  orientation(){\n    try {\n      accelerometerSubscription = accelerometerEvents.listen((AccelerometerEvent event) {\n        if(!widget.isVideosRecording){\n          setState(() {\n            if (event.z \u003c -8.0) {\n\n              cameraOrientation = CustomOrientation.portrait;\n            } else if (event.x \u003e 5.0) {\n\n              cameraOrientation = CustomOrientation.rightLandScape;\n            } else if (event.x \u003c -5.0) {\n\n              cameraOrientation = CustomOrientation.leftLandScape;\n            }\n            else{\n\n              cameraOrientation = CustomOrientation.portrait;\n            }\n\n          });\n\n        }\n\n\n\n      });\n    } on PlatformException catch (e) {\n      print(\"Error: $e\");\n    }\n  }\n  @override\n  void dispose() {\n    super.dispose();\n    /// 듣기자나 컨트롤러나 스트림 등의 청취자나 컨트롤러나 스트림을 해제하거나 취소하거나 제거하지 않도록 유의하세요.\n    accelerometerSubscription.cancel();\n  }\n}\n\n/// 방향 열거형\nenum CustomOrientation {portrait, leftLandScape, rightLandScape}\n```\n\n또는 사진을 찍기 전에 자이로 센서로 방향을 확인할 수 있습니다. 다음과 같이요.\n\n```js\nlate StreamSubscription\u003cAccelerometerEvent\u003e accelerometerSubscription;\n\nCustomOrientation getOrientation(){\n  CustomOrientation cameraOrientation = CustomOrientation.portrait;\n    try {\n      accelerometerSubscription = accelerometerEvents.listen((AccelerometerEvent event) {\n        if(!widget.isVideosRecording){\n          if (event.z \u003c -8.0) {\n\n              cameraOrientation = CustomOrientation.portrait;\n            } else if (event.x \u003e 5.0) {\n\n              cameraOrientation = CustomOrientation.rightLandScape;\n            } else if (event.x \u003c -5.0) {\n\n              cameraOrientation = CustomOrientation.leftLandScape;\n            }\n            else{\n\n              cameraOrientation = CustomOrientation.portrait;\n            }\n\n        }\n\n      });\n    } on PlatformException catch (e) {\n      print(\"Error: $e\");\n    }\n    return cameraOrientation;\n}\n\n/// 여러분의 코드\ntakePhoto()async{\n  CustomOrientation orientation = getOrientation();\n  XFile? image =  await _cameraController.takePicture();\n\n  /// 여러분의 코드\n\n}\n/// 여러분의 코드\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 당신의 선택입니다. 방향을 어떻게 설정할지 결정하세요.\n\n이제 이 빌더를 카메라 화면에 추가해 보겠습니다. 다음과 같이 보일 것입니다.\n\n```js\nimport 'package:camera/camera.dart';\nimport 'package:flutter/material.dart';\nimport 'package:prism_v2/global/global_variables.dart';\nimport 'package:sizer/sizer.dart';\n\nclass CameraScreen extends StatefulWidget {\n  static const routeName = '/camera';\n\n  const CameraScreen({Key? key}) : super(key: key);\n\n  @override\n  _CameraScreenState createState() =\u003e _CameraScreenState();\n}\n\nclass _CameraScreenState extends State\u003cCameraScreen\u003e {\n  late CameraController _cameraController;\n  late CameraDescription backCamera, frontCamera;\n\n  @override\n  void initState() {\n    getAvailableCamera();\n\n    super.initState();\n  }\n\n  @override\n  void dispose() {\n    _cameraController.dispose();\n    super.dispose();\n  }\n\n  void getAvailableCamera() async {\n    for (var i = 0; i \u003c cameras.length; i++) {\n      var camera = cameras[i];\n      if (camera.lensDirection == CameraLensDirection.back) {\n        backCamera = camera;\n      }\n      if (camera.lensDirection == CameraLensDirection.front) {\n        frontCamera = camera;\n      }\n    }\n    if (backCamera == null) {\n      backCamera = cameras.first;\n    }\n    if (frontCamera == null) {\n      frontCamera = cameras.last;\n    }\n    _cameraController = CameraController(backCamera, ResolutionPreset.medium);\n\n    _cameraController.initialize().then((_) {\n      if (!mounted) {\n        return;\n      }\n      setState(() {});\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (!_cameraController.value.isInitialized) {\n      return Container();\n    }\n    return Scaffold(\n      backgroundColor: Colors.transparent,\n      body: CameraPreview(_cameraController),\n      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,\n      floatingActionButton: Stack(\n        children: [\n          Align(\n            alignment: Alignment.bottomCenter,\n            /// here I have added this right on the take photo button\n            child: CustomOrientation(\n              builder: (context, orientation) {\n                return FloatingActionButton(\n                  backgroundColor: Colors.orange,\n                  child: const Icon(Icons.camera_alt),\n                  onPressed: () async {\n                    await _cameraController.takePicture().then((value) {\n                      Navigator.pop(context, value.path);\n                    });\n                  },\n                );\n              }\n            ),\n          ),\n          Align(\n            alignment: Alignment.bottomRight,\n            child: Padding(\n              padding: EdgeInsets.only(right: 5.0.w),\n              child: FloatingActionButton(\n                backgroundColor: Colors.deepOrange,\n                child: const Icon(Icons.flip_camera_android),\n                onPressed: () {\n                  if (_cameraController.description.lensDirection ==\n                      CameraLensDirection.back) {\n                    _cameraController =\n                        CameraController(frontCamera, ResolutionPreset.medium);\n                  } else {\n                    _cameraController =\n                        CameraController(backCamera, ResolutionPreset.medium);\n                  }\n\n                  _cameraController.initialize().then((_) {\n                    if (!mounted) {\n                      return;\n                    }\n                    setState(() {});\n                  });\n                },\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n이제 우리는 방향을 설정했습니다. 당신의 기기나 앱의 기본 방향에 대해 아무것도 할 필요가 없습니다. 문제는 기기의 방향을 변경할 때 발생할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해결하기 위해서는 디바이스의 현재 방향에 따라 이미지를 회전해야 합니다. 여기서는 takephoto 함수만 작성하고 있어요. 한번 봅시다...\n\n```dart\nimport 'package:image/image.dart' as img;\n\ntakePhoto(CustomOrientation orientation) async {\n\n  XFile? image = await _cameraController.takePicture();\n  List\u003cint\u003e rotatedBytes = [];\n  if (orientation != AppString.portrait) {\n    int angle = 90;\n    if (orientation == AppString.leftLandScape) {\n      angle = -90;\n    }\n    Uint8List byte = await File(rawImage!.path).readAsBytes();\n    img.Image? image = img.decodeImage(byte);\n    image = img.copyRotate(image!, angle.toInt());\n    rotatedBytes = img.encodeJpg(image);\n  }\n  File imageFile = rotatedBytes.isEmpty ? File(rawImage!.path) : await File(rawImage!.path).writeAsBytes(rotatedBytes);\n  /// 여기에 코드를 작성하세요\n\n}\n```\n\n요렇게요. 이제 원하는 대로 직립 사진을 찍을 수 있어요. 이제 카메라 방향이 OS 카메라 기능처럼 작동할 거에요.\n\n이제 비디오 파일을 회전시키고 싶다면! 가능해요. 그러나 해당 작업을 하려면 flutter_ffmpeg 패키지를 import해야 해요. 그걸 추천하진 않겠어요. 두 가지 이유가 있어서요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 비디오 녹화를 중지한 후, 비디오 처리에 너무 오랜 시간이 걸릴 수 있습니다. 녹화된 비디오의 방향에 따라 회전 처리를 하려면 많은 시간이 소요될 수 있습니다.\n- 특정 패키지를 가져오려면 minSdkVersion을 24로 증가해야 합니다. 그러면 앱 크기가 두 배가 됩니다. 그렇지 않길 바라겠네요.\n\n그러므로 가장 좋은 방법은 비디오를 서버로 전송하여 서버에서 비디오를 처리하도록 하는 것입니다.\n또는 사용자에게 비디오를 보여줄 때, RotatedBox를 사용하여 화면 방향에 따라 비디오 플레이어 위젯을 회전시킬 수 있습니다. 이렇게 하면 사용자가 비디오가 회전되었는지 여부를 이해하지 못할 것입니다.\nFlutter 여행에 도움이 되기를 바랍니다.\n\n즐거운 코딩하시고 ❤️\n","ogImage":{"url":"/assets/img/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode_0.png"},"coverImage":"/assets/img/2024-06-23-HowtocreateacameraappbyflutterwithPortraitandLandscapemode_0.png","tag":["Tech"],"readingTime":17},{"title":"Flutter에서 간단하게 Pull to Refresh 구현하는 방법","description":"","date":"2024-06-23 21:38","slug":"2024-06-23-SimpleFlutterpulltorefresh","content":"\n\u003cimg src=\"/assets/img/2024-06-23-SimpleFlutterpulltorefresh_0.png\" /\u003e\n\n모바일 애플리케이션에서 사용자가 콘텐츠를 새로 고칠 수 있는 방법을 제공하는 것은 일반적인 필요사항입니다. 가장 직관적인 방법 중 하나는 pull-to-refresh 제스처입니다. 이 기능을 통해 사용자는 추가 버튼이나 수동 입력이 필요하지 않고 새로운 데이터를 쉽게 가져올 수 있어 사용자 경험을 향상시킵니다.\n\n# Flutter에서 Pull-to-Refresh 구현하기\n\nFlutter를 사용하면 RefreshIndicator 위젯을 사용하여 pull-to-refresh 기능을 구현하기가 쉽습니다. 아래에는 이 기능을 Flutter 애플리케이션에 추가하는 방법을 보여주는 간단한 예제가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샘플 코드: main.dart\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Pull to Refresh Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  @override\n  _HomePageState createState() =\u003e _HomePageState();\n}\n\nclass _HomePageState extends State\u003cHomePage\u003e {\n  List\u003cString\u003e items = List.generate(20, (index) =\u003e \"Item ${index + 1}\");\n\n  Future\u003cvoid\u003e _refresh() async {\n    await Future.delayed(Duration(seconds: 2));\n    setState(() {\n      items = List.generate(20, (index) =\u003e \"New Item ${index + 1}\");\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Pull to Refresh Demo'),\n      ),\n      body: RefreshIndicator(\n        onRefresh: _refresh,\n        child: ListView.builder(\n          itemCount: items.length,\n          itemBuilder: (context, index) {\n            return ListTile(\n              title: Text(items[index]),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n# 설명\n\n- MyApp 위젯: 이것은 애플리케이션의 루트 위젯입니다.\n- HomePage 위젯: 이것은 풀-투-리프레시 기능이 구현된 메인 화면입니다.\n- RefreshIndicator 위젯: 이 위젯은 ListView를 감싸고 풀-투-리프레시 기능을 제공합니다. 사용자가 목록을 새로 고치기 위해 아래로 당기면 onRefresh 메서드가 호출됩니다.\n- \\_refresh 메서드: 이 메서드는 2초 동안 지연을 통해 네트워크 호출을 시뮬레이션합니다. 지연 후에 새로운 데이터를 보여주기 위해 항목 목록을 업데이트합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\nPull-to-refresh는 현대 모바일 애플리케이션에서 필수적인 기능으로, 사용자 상호작용을 향상시켜 콘텐츠 업데이트를 쉽게 제공합니다. Flutter를 사용하면 RefreshIndicator 위젯을 활용하여 이 기능을 간편하고 효율적으로 구현할 수 있습니다.\n\n이 튜토리얼이 도움이 되었다면 박수를 눌러주시고, 플러터 튜토리얼과 팁을 더 받아보려면 팔로우해주세요. 여러분의 지원은 우리가 여러분의 개발 여정을 돕기 위해 더 많은 콘텐츠를 만들도록 격려합니다!\n\n즐거운 코딩하세요! 🚀\n","ogImage":{"url":"/assets/img/2024-06-23-SimpleFlutterpulltorefresh_0.png"},"coverImage":"/assets/img/2024-06-23-SimpleFlutterpulltorefresh_0.png","tag":["Tech"],"readingTime":3},{"title":"SwiftUI TextField 심화  이벤트, 포커스, 키보드 제어 방법","description":"","date":"2024-06-23 21:35","slug":"2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard","content":"\n이 글은 SwiftUI TextField 이벤트, 포커스 전환, 키보드 설정 및 기타 관련 경험, 기술 및 고려 사항을 탐색할 것입니다.\n\n## 이벤트\n\n### onEditingChanged\n\nTextField가 포커스를 얻을 때(편집 가능한 상태로 전환될 때), onEditingChanged는 주어진 메서드를 호출하고 값으로 true를 전달합니다. TextField가 포커스를 잃을 때, 다시 메서드를 호출하고 값을 false로 전달합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct OnEditingChangedDemo: View {\n    @State var name = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name, onEditingChanged: getFocus)\n        }\n    }\n\n    func getFocus(focused: Bool) {\n        print(\"포커스 받음: \\(focused ? \"참\" : \"거짓\")\")\n    }\n}\n```\n\n이 매개변수의 이름은 사용자에게 모호함을 초래하기 쉽습니다. 사용자가 콘텐츠를 입력했는지 확인하는 데 onEditingChanged를 사용하지 마십시오.\n\niOS 15에서는 ParseableFormatStyle을 지원하는 새로 추가된 생성자에서 이 매개변수를 제공하지 않습니다. 따라서 새로운 Formatter를 사용하는 TextFields의 경우, 포커스를 얻었는지 또는 상실했는지를 확인하기 위해 다른 수단을 사용해야 합니다.\n\n# onCommit\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nonCommit은 사용자가 입력하는 중에 리턴 키를 누를 때 (또는 클릭할 때) 트리거됩니다 (코드 시뮬레이션으로는 트리거할 수 없음). 사용자가 리턴 키를 클릭하지 않으면(예: 직접 다른 TextField로 전환하는 경우) onCommit은 트리거되지 않습니다. onCommit이 트리거되는 동시에 TextField는 포커스를 잃게 됩니다.\n\n```js\nstruct OnCommitDemo: View {\n    @State var name = \"\"\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name, onCommit: { print(\"커밋\") })\n        }\n    }\n}\n```\n\n사용자가 입력한 내용을 확인해야 하는 경우, onCommit과 onEditingChanged를 함께 사용하는 것이 좋습니다. 사용자의 입력 데이터를 실시간으로 처리하려면 SwiftUI TextField 고급 — 형식 지정 및 유효성 검사를 참고해주세요.\n\nonCommit은 SecureField에도 적용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 15에서 추가된 ParseableFormatStyle을 지원하는 새 생성자는 해당 매개변수를 제공하지 않습니다. 동일한 효과를 얻으려면 새롭게 추가된 onSubmit을 사용할 수 있습니다.\n\n# onSubmit\n\nonSubmit은 SwiftUI 3.0에서 새로 추가된 기능입니다. onCommit 및 onEditingChanged는 각각의 TextField의 상태를 설명하지만 onSubmit은 한 뷰 내에서 여러 TextField의 통합 관리 및 일정 관리를 가능하게 합니다.\n\n```js\n// onSubmit의 정의\nextension View {\n    public func onSubmit(of triggers: SubmitTriggers = .text, _ action: @escaping (() -\u003e Void)) -\u003e some View\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 코드는 onCommit과 동일한 동작을 구현할 것입니다:\n\n```js\nstruct OnSubmitDemo:View{\n    @State var name = \"\"\n    var body: some View{\n        List{\n            TextField(\"name:\",text: $name)\n                .onSubmit {\n                    print(\"commit\")\n                }\n        }\n    }\n}\n```\n\nonSubmit의 트리거 조건은 onCommit과 동일하며, 사용자가 “return”을 활성화하도록 요구합니다.\n\nonSubmit은 SecureField에도 적용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 범위와 중첩\n\nonSubmit의 구현은 환경 값 TriggerSubmitAction을 설정하는 것에 기반하며 (아직 개발자에게 제공되지 않음) onSubmit은 범위를 가지고 있으며 (뷰 트리로 전달될 수 있음) 중첩될 수 있습니다.\n\n```js\nstruct OnSubmitDemo: View {\n    @State var text1 = \"\"\n    @State var text2 = \"\"\n    @State var text3 = \"\"\n    var body: some View {\n        Form {\n            Group {\n                TextField(\"text1\", text: $text1)\n                    .onSubmit { print(\"text1 commit\") }\n                TextField(\"text2\", text: $text2)\n                    .onSubmit { print(\"text2 commit\") }\n            }\n            .onSubmit { print(\"textfield in group commit\") }\n            TextField(\"text3\", text: $text3)\n                .onSubmit { print(\"text3 commit\") }\n        }\n        .onSubmit { print(\"textfield in form commit1\") }\n        .onSubmit { print(\"textfield in form commit2\") }\n    }\n}\n```\n\nTextField (text1)이 commit되면, 콘솔 출력은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n양식에서의 텍스트 필드 커밋2\n양식에서의 텍스트 필드 커밋1\n그룹에서의 텍스트 필드 커밋\n텍스트1 커밋\n```\n\n외부에서 내부로 호출 순서임을 참고하십시오.\n\n# 제한된 범위\n\nsubmitScope를 사용하여 범위를 차단하고 (뷰 트리 상에서의 추가 전파를 제한합니다). 예를 들어, 위 코드에서는 그룹 뒤에 submitScope를 추가하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n그룹 {\n    TextField(\"text1\", text: $text1)\n        .onSubmit { print(\"text1 commit\") }\n    TextField(\"text2\", text: $text2)\n        .onSubmit { print(\"text2 commit\") }\n}\n.submitScope()  // scope blocking\n.onSubmit { print(\"textfield in group commit\") }\n```\n\nTextField1이 커밋되면 콘솔에 다음이 표시됩니다:\n\n```js\ntext1 commit\n```\n\n이 시점에서 onSubmit의 범위는 그룹 내로 제한됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뷰에 여러 개의 TextFields가 있는 경우, onSubmit과 FocusState를 결합하여 훌륭한 사용자 경험을 얻을 수 있습니다.\n\n# searchable 지원\n\niOS 15에서는 새로운 검색 상자도 \"return\"을 클릭할 때 onSubmit을 트리거하지만, 트리거를 검색으로 설정해야 합니다:\n\n```js\nstruct OnSubmitForSearchableDemo:View{\n    @State var name = \"\"\n    @State var searchText = \"\"\n    var body: some View{\n        NavigationView{\n            Form{\n                TextField(\"이름:\",text:$name)\n                    .onSubmit {print(\"textField 커밋\")}\n            }\n            .searchable(text: $searchText)\n            .onSubmit(of: .search) { //\n                print(\"searchField 커밋\")\n            }\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSubmitTriggers의 타입은 OptionSet입니다. onSubmit 메서드는 환경 내에서 뷰 트리에서 SubmitTriggers에 포함된 값을 계속 전달합니다. onSubmit에서 받는 SubmitTriggers 값이 onSubmit에서 지정된 SubmitTriggers 세트에 포함되지 않으면 전달이 종료됩니다. 간단히 말해, onSubmit(of:.search)은 TextField에서 생성된 커밋 상태를 차단하고 그 반대도 마찬가지입니다.\n\n예를 들어, 위 코드에서 searchable 다음에 onSubmt(of:.text)를 추가하면 TextField의 커밋 이벤트에 응답할 수 없게 됩니다.\n\n```js\n.searchable(text: $searchText)\n            .onSubmit(of: .search) {\n                print(\"searchField commit1\")\n            }\n            .onSubmit {print(\"textField commit\")} //cannot be triggered, blocked by search\n```\n\n따라서 TextField와 검색 상자를 모두 처리할 때 호출 순서에 특별히 주의해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 코드는 하나의 onSubmit에서 TextField와 검색 상자를 모두 지원할 수 있습니다:\n\n```js\n.onSubmit(of: [.text, .search]) {\n  print(\"무언가가 제출되었습니다\")\n}\n```\n\n다음 코드는 searchable 보다 onSubmit(of:.search)가 먼저 배치되어 있기 때문에 어느 것도 트리거하지 않습니다.\n\n```js\nNavigationView{\n    Form{\n        TextField(\"이름:\", text: $name)\n            .onSubmit {print(\"textField 제출\")}\n    }\n    .onSubmit(of: .search) { // 트리거 안 됨\n        print(\"searchField 제출1\")\n    }\n    .searchable(text: $searchText)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 초점\n\niOS 15(몬테레이) 이전에는 SwiftUI에서 TextField(예 : becomeFirstResponder)에 초점을 맞추는 방법을 제공하지 않았습니다. 오랫동안 개발자들은 비슈위 방법에 의존하여 비슷한 기능을 구현해야 했습니다.\n\nSwiftUI 3.0에서 Apple은 개발자들에게 onSubmit과 유사한, 높은 수준의 뷰 계층 구조에서 텍스트 필드의 초점을 일관되게 결정하고 관리할 수 있는 예상보다 훨씬 더 나은 솔루션을 제공했습니다.\n\n# 기본 사용법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwiftUI에서는 새 FocusState 프로퍼티 래퍼를 제공하여이 뷰 내의 TextField에 포커스가 있는지 여부를 결정하는 데 도움을 줍니다. focused를 사용하여 FocusState를 특정 TextField와 연결할 수 있습니다.\n\n```swift\nstruct OnFocusDemo: View {\n    @FocusState var isNameFocused: Bool\n    @State var name = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($isNameFocused)\n        }\n        .onChange(of: isNameFocused) { value in\n            print(value)\n        }\n    }\n}\n```\n\n위 코드는 TextField가 포커스를 얻을 때 isNameFocused를 true로 설정하고 포커스를 잃을 때 false로 설정합니다.\n\n동일한 뷰 내에 여러 개의 TextField가있는 경우 각 해당 TextField와 연결할 여러 FocusStates를 생성할 수 있습니다. 예를 들어:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 방법은 뷰에 더 많은 TextField가 있는 경우 귀찮아지고 통일된 관리에 도움이 되지 않습니다. 다행히 FocusState는 Boolean 값뿐만 아니라 모든 해시 타입도 지원합니다. Hashable 프로토콜을 준수하는 enum을 사용하여 뷰 내 여러 TextField의 포커스를 관리할 수 있습니다. 다음 코드는 위의 코드와 동일한 기능을 수행합니다:\n\n```js\nstruct OnFocusDemo:View{\n    @FocusState var focus:FocusedField?\n    @State var name = \"\"\n    @State var password = \"\"\n    var body: some View{\n        List{\n            TextField(\"name:\",text:$name)\n                .focused($focus, equals: .name)\n            SecureField(\"password:\",text:$password)\n                .focused($focus,equals: .password)\n        }\n        .onChange(of: focus, perform: {print($0)})\n    }\n\n    enum FocusedField:Hashable{\n        case name,password\n    }\n}\n```\n\n# 특정 TextField가 뷰를 표시한 직후에 즉시 포커스를 받도록 만들기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFocusState를 사용하면 지정된 TextField가 포커스를 얻고 뷰를 표시한 후 즉시 키보드가 팝업되게 할 수 있어요:\n\n```js\nstruct OnFocusDemo: View {\n    @FocusState var focus: FocusedField?\n    @State var name = \"\"\n    @State var password = \"\"\n\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n            SecureField(\"비밀번호:\", text: $password)\n                .focused($focus, equals: .password)\n        }\n        .onAppear {\n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {\n                focus = .name\n            }\n        }\n    }\n\n    enum FocusedField: Hashable {\n        case name, password\n    }\n}\n```\n\n뷰 초기화 중에 값을 할당하는 것은 잘못된 방법이에요. onAppear에서도 TextField가 포커스를 얻을 시간을 지연시켜야 해요 (iOS 16에서는 지연이 필요하지 않아요).\n\n# 여러 개의 TextField 사이에서 포커스 전환하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주의력과 onSubmit을 결합하여 한 TextField에서 입력을 완료하고(리턴을 클릭할 때) 자동으로 다음 TextField로 포커스를 전환하는 효과를 얻을 수 있어요.\n\n```js\nstruct OnFocusDemo:View{\n    @FocusState var focus:FocusedField?\n    @State var name = \"\"\n    @State var email = \"\"\n    @State var phoneNumber = \"\"\n    var body: some View{\n        List{\n            TextField(\"이름:\",text:$name)\n                .focused($focus, equals: .name)\n                .onSubmit {\n                    focus = .email\n                }\n            TextField(\"이메일:\",text:$email)\n                .focused($focus,equals: .email)\n                .onSubmit {\n                    focus = .phone\n                }\n            TextField(\"전화번호:\",text:$phoneNumber)\n                .focused($focus, equals: .phone)\n                .onSubmit {\n                    if !name.isEmpty \u0026\u0026 !email.isEmpty \u0026\u0026 !phoneNumber.isEmpty {\n                        submit()\n                    }\n                }\n        }\n    }\n\n    private func submit(){\n        // 모든 정보 제출\n        print(\"제출\")\n    }\n    enum FocusedField:Hashable{\n        case name,email,phone\n    }\n}\n```\n\n위의 코드는 onSubmit 전달 기능을 활용하여 다음과 같이 변환될 수도 있어요:\n\n```js\nList {\n    TextField(\"이름:\", text: $name)\n        .focused($focus, equals: .name)\n    TextField(\"이메일:\", text: $email)\n        .focused($focus, equals: .email)\n    TextField(\"전화번호:\", text: $phoneNumber)\n        .focused($focus, equals: .phone)\n}\n.onSubmit {\n    switch focus {\n    case .name:\n        focus = .email\n    case .email:\n        focus = .phone\n    case .phone:\n        if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {\n            submit()\n        }\n    default:\n        break\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n화면 버튼(예: 보조 키보드 보기) 또는 키보드 단축키를 결합하여 포커스를 전환하거나 특정 TextField로 이동할 수도 있습니다.\n\n# 포커스를 얻기 위한 키보드 단축키 사용\n\n보안 필드를 포함한 여러 개의 TextField가 있는 뷰에서는 Tab 키를 사용하여 TextField에서 포커스를 직접 전환할 수 있습니다. 그러나 SwiftUI는 키보드 단축키를 사용하여 특정 TextField에 포커스를 설정하는 기능을 직접 제공하지 않습니다. FocusState와 keyboardShortcut을 결합하여 iPad 및 MacOS에서 이 기능을 얻을 수 있습니다.\n\n키보드 단축키 바인딩을 지원하는 focused를 생성하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\npublic extension View {\n    func focused(_ condition: FocusState\u003cBool\u003e.Binding, key: KeyEquivalent, modifiers: EventModifiers = .command) -\u003e some View {\n        focused(condition)\n            .background(Button(\"\") {\n                condition.wrappedValue = true\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n\n    func focused\u003cValue\u003e(_ binding: FocusState\u003cValue\u003e.Binding, equals value: Value, key: KeyEquivalent, modifiers: EventModifiers = .command) -\u003e some View where Value: Hashable {\n        focused(binding, equals: value)\n            .background(Button(\"\") {\n                binding.wrappedValue = value\n            }\n            .keyboardShortcut(key, modifiers: modifiers)\n            .hidden()\n            )\n    }\n}\n```\n\n코드 사용법:\n\n```swift\nstruct ShortcutFocusDemo: View {\n    @FocusState var focus: FouceField?\n    @State private var email = \"\"\n    @State private var address = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이메일\", text: $email)\n                .focused($focus, equals: .email, key: \"t\")\n            TextField(\"주소\", text: $address)\n                .focused($focus, equals: .address, key: \"a\", modifiers: [.command, .shift, .option])\n        }\n    }\n\n    enum FouceField: Hashable {\n        case email\n        case address\n    }\n}\n```\n\n사용자가 ⌘ + T를 입력하면 이메일을 처리하는 TextField에 초점이 맞춰집니다. 사용자가 ⌘ + ⌥ + ⇧ + A를 입력하면 주소를 처리하는 TextField에 초점이 맞춰집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 자체 onEditingChanged 만들기\n\n개별 TextField의 포커스 상태를 확인하는 가장 좋은 방법은 여전히 onEditingChanged를 사용하는 것입니다. 그러나 새 포매터와 같이 onEditingChanged를 사용할 수 없는 경우에는 FocusState를 사용하여 비슷한 효과를 얻을 수 있습니다.\n\n- 개별 TextField의 포커스 상태 확인\n\n```swift\npublic extension View {\n    func focused(_ condition: FocusState\u003cBool\u003e.Binding, onFocus: @escaping (Bool) -\u003e Void) -\u003e some View {\n        focused(condition)\n            .onChange(of: condition.wrappedValue) { value in\n                onFocus(value == true)\n            }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 방법:\n\n```js\nstruct onEditingChangedFocusVersion:View{\n    @FocusState var focus:Bool\n    @State var price = 0\n    var body: some View{\n        Form{\n            TextField(\"가격:\",value:$price,format: .number)\n                .focused($focus){ focused in\n                    print(focused)\n                }\n        }\n    }\n}\n```\n\n- 여러 TextFields 확인\n\nTextField가 포커스를 잃을 때 여러 번 호출을 피하기 위해 뷰 계층 구조에서 마지막 포커스된 TextField의 FocusState 값을 저장해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic extension View {\n    func storeLastFocus\u003cValue: Hashable\u003e(current: FocusState\u003cValue?\u003e.Binding, last: Binding\u003cValue?\u003e) -\u003e some View {\n        onChange(of: current.wrappedValue) { _ in\n            if current.wrappedValue != last.wrappedValue {\n                last.wrappedValue = current.wrappedValue\n            }\n        }\n    }\n\n    func focused\u003cValue\u003e(_ binding: FocusState\u003cValue\u003e.Binding, equals value: Value, last: Value?, onFocus: @escaping (Bool) -\u003e Void) -\u003e some View where Value: Hashable {\n        return focused(binding, equals: value)\n            .onChange(of: binding.wrappedValue) { focusValue in\n                if focusValue == value {\n                    onFocus(true)\n                } else if last == value { // only call once\n                    onFocus(false)\n                }\n            }\n    }\n}\n```\n\n호출:\n\n```js\nstruct OnFocusView: View {\n    @FocusState private var focused: Focus?\n    @State private var lastFocused: Focus?\n    @State private var name = \"\"\n    @State private var email = \"\"\n    @State private var address = \"\"\n    var body: some View {\n        List {\n            TextField(\"이름:\", text: $name)\n                .focused($focused, equals: .name, last: lastFocused) {\n                    print(\"이름:\", $0)\n                }\n            TextField(\"이메일:\", text: $email)\n                .focused($focused, equals: .email, last: lastFocused) {\n                    print(\"이메일:\", $0)\n                }\n            TextField(\"주소:\", text: $address)\n                .focused($focused, equals: .address, last: lastFocused) {\n                    print(\"주소:\", $0)\n                }\n        }\n        .storeLastFocus(current: $focused, last: $lastFocused) // 최신 포커스 값을 저장합니다.\n    }\n\n    enum Focus {\n        case name, email, address\n    }\n}\n```\n\n# 키보드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTextField를 사용하다보면 소프트웨어 키보드와 함께 작업해야 합니다. 이 섹션에서는 키보드와 관련된 몇 가지 예제를 소개할 것입니다.\n\n## 키보드 유형\n\niPhone에서 keyboardType를 통해 소프트웨어 키보드 유형을 설정하여 사용자 입력을 용이하게 하거나 입력 문자 범위를 제한할 수 있습니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct KeyboardTypeDemo: View {\n    @State var price: Double = 0\n    var body: some View {\n        Form {\n            TextField(\"Price:\", value: $price, format: .number.precision(.fractionLength(2)))\n                .keyboardType(.decimalPad) // 소수점 숫자 키보드 지원\n        }\n    }\n}\n```\n\n위 이미지는 \"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png\" 입니다.\n\n현재, 지원되는 키보드 유형은 총 11가지이며, 다음과 같습니다:\n\n- asciiCapable\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 번호 및 구두점 테이블입니다.\n\n| numbersAndPunctuation   |\n| ----------------------- |\n| Numbers and punctuation |\n\nURL 테이블로 아래 내용을 변환해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nURL 주소를 입력하는 데 유용하며, 문자 및 '.', '/', '.com'을 포함할 수 있습니다.\n\n- numberPad\n\n해당 지역의 숫자 세트를 사용합니다(0-9, ۰-۹, ०-९ 등). 양의 정수나 PIN에 적합합니다.\n\n- phonePad\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전화기에서 사용되는 숫자 및 다른 기호, 예를 들면 ‘\\*#+’\n\n- namePhonePad\n\n텍스트 및 전화번호 입력에 편리합니다. 문자 상태는 asciiCapable과 유사하며, 숫자 상태는 numberPad와 유사합니다.\n\n- emailAddress\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'@'를 입력하는 데 편리한 아스키 호환 키보드입니다.\n\n- decimalPad\n\n소수점이 포함된 숫자 키패드입니다. 자세한 내용은 위의 이미지를 참조해주세요.\n\n- 트위터\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아스키 지원 키보드에는 '@#'이 포함되어 있습니다.\n\n- 웹 검색\n\n'.'을 포함한 아스키 지원 키보드이며 'return' 키는 'go'로 표시됩니다.\n\n- 아스키 지원 번호 패드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAn asciiCapable 키보드에는 숫자가 포함되어 있습니다.\n\nApple은 다양한 키보드 모드를 제공하지만, 경우에 따라 사용자의 요구 사항을 충족시키지 못할 수도 있습니다.\n\n예를 들어, numberPad 및 decimalPad에는 \"-\" 및 \"return\"이 없습니다. SwiftUI 3.0 이전에는 주요 뷰에 별도로 그리거나 SwiftUI 이외의 방법을 사용하여 문제를 해결해야 했습니다. 그러나 SwiftUI 3.0에서는 네이티브 설정 키보드 보조 뷰(자세한 내용은 아래에 설명되어 있음) 추가로 위 문제를 해결하는 것이 이제 더 어렵지 않아졌습니다.\n\n# TextContentType를 통해 제안을 받아보세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 iOS 앱을 사용할 때 텍스트를 입력할 때 소프트웨어 키보드가 자동으로 입력해야 할 내용을 제안하는 경우가 있습니다. 이는 전화 번호, 이메일, 인증 코드 등을 텍스트ContentType를 통해 얻는 효과입니다.\n\nTextField의 UITextContentType을 설정함으로써 시스템은 입력 중에 입력하려는 콘텐츠를 지능적으로 추론하고 제안을 표시합니다.\n\n다음 코드는 비밀번호 입력 시 키체인을 사용할 수 있도록 합니다.\n\n```js\nstruct KeyboardTypeDemo: View {\n    @State var password = \"\"\n    var body: some View {\n        Form {\n            SecureField(\"\", text: $password)\n                .textContentType(.password)\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_1.png\" /\u003e\n\n이메일 주소를 입력할 때 연락처 및 이메일에서 비슷한 이메일 주소를 제안하는 코드입니다:\n\n```js\nstruct KeyboardTypeDemo: View {\n    @State var email = \"\"\n    var body: some View {\n        Form {\n            TextField(\"\", text: $email)\n                .textContentType(.emailAddress)\n        }\n    }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_2.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 설정할 수 있는 여러 종류의 UITextContentType이 있습니다. 흔히 사용되는 것들 중 일부는 다음과 같습니다:\n\n- password\n- 이름 옵션, 예를 들어 name, givenName, middleName 등이 있습니다.\n- 주소 옵션, 예를 듀 addressCity, fullStreetAddress, postalCode 등이 있습니다.\n- telephoneNumber\n- emailAddress\n- oneTimeCode (인증 코드)\n\n# 키보드 해제\n\n일부 경우에는 사용자가 텍스트 입력을 완료한 후 소프트웨어 키보드를 해제하여 더 많은 디스플레이 공간을 확보해야 할 수 있습니다. 일부 키보드 유형에는 \"return\" 버튼이 없기 때문에 프로그래밍을 사용하여 키보드를 사라지게 해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한 가끔은 사용자가 \"return\" 버튼을 클릭하지 않고도 화면의 다른 영역을 클릭하거나 목록을 스크롤하여 키보드를 숨길 수 있게 하려고 할 수도 있습니다. 상호 작용 경험을 향상시키기 위해 프로그래밍을 사용하여 키보드를 사라지게 할 필요가 있습니다.\n\n- FocusState를 사용하여 키보드 숨기기\n\n해당 FocusState가 TextField에 설정되면 값을 \"false\" 또는 \"nil\"로 설정하여 키보드를 숨길 수 있습니다.\n\n```js\nstruct HideKeyboardView: View {\n    @State private var name = \"\"\n    @FocusState private var nameIsFocused: Bool\n\n    var body: some View {\n        Form {\n            TextField(\"이름을 입력하세요\", text: $name)\n                .focused($nameIsFocused)\n            Button(\"키보드 숨기기\") {\n                nameIsFocused = false\n            }\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기타 상황\n\n대부분의 경우, 우리는 UIkit에서 제공하는 메서드를 직접 사용하여 키보드를 숨길 수 있습니다.\n\n```js\nUIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n```\n\n예를 들어, 사용자가 뷰를 드래그할 때 키보드를 숨기는 다음 코드가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n구조 ResignKeyboardOnDragGesture: ViewModifier {\n    var gesture = DragGesture().onChanged { _ in\n        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n    }\n\n    func body(content: Content) -\u003e some View {\n        content.gesture(gesture)\n    }\n}\nextension View {\n    func dismissKeyboard() -\u003e some View {\n        return modifier(ResignKeyboardOnDragGesture())\n    }\n}\n구조 HideKeyboardView: View {\n    @State private var name = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이름을 입력하세요\", text: $name)\n        }\n        .dismissKeyboard()\n    }\n}\n```\n\n# 키보드 어시스턴트 뷰\n\n# 툴바를 통해 생성됨\n\nSwiftUI 3.0에서는 ToolbarItem(placement: .keyboard, content: View)를 사용하여 키보드 어시스턴트 뷰(inputAccessoryView)를 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n입력 보조 뷰를 통해 이전에 처리하기 어려웠던 많은 문제들을 해결하고 상호 작용 수단을 더 많이 제공할 수 있습니다.\n\n다음 코드는 소수점 숫자를 입력할 때 양/음수 변환 및 확인 버튼을 추가합니다:\n\n```js\nimport Introspect\nstruct ToolbarKeyboardDemo: View {\n    @State var price = \"\"\n    var body: some View {\n        Form {\n            TextField(\"가격:\", text: $price)\n                .keyboardType(.decimalPad)\n                .toolbar {\n                    ToolbarItem(placement: .keyboard) {\n                        HStack {\n                            Button(\"-/+\") {\n                                if price.hasPrefix(\"-\") {\n                                    price.removeFirst()\n                                } else {\n                                    price = \"-\" + price\n                                }\n                            }\n                            .buttonStyle(.bordered)\n                            Spacer()\n                            Button(\"완료\") {\n                                UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)\n                                // 해야 할 일을 수행합니다\n                            }\n                            .buttonStyle(.bordered)\n                        }\n                        .padding(.horizontal, 30)\n                    }\n                }\n        }\n    }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_3.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안타깝지만, ToolbarItem을 통해 입력 보조 뷰를 설정하는 데는 아직 몇 가지 제한 사항이 있습니다:\n\n- 표시 콘텐츠 제한\n\n높이가 고정되어 있어 악세서리 뷰의 전체 디스플레이 영역을 활용할 수 없습니다. 다른 종류의 툴바와 마찬가지로 SwiftUI가 콘텐츠의 레이아웃에 개입합니다.\n\n- 같은 뷰 내에서 여러 텍스트 필드에 대해 별도의 액세서리 뷰를 설정할 수 없음\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보다 복잡한 조건부 구문은 ToolbarItem에서 사용할 수 없습니다. 다른 텍스트 필드에 대해 별도로 설정하더라도 SwiftUI는 모든 내용을 함께 표시하기 위해 병합합니다.\n\n# UIKit을 통해 생성하기\n\n현재 단계에서는 SwiftUI에 대한 키보드 액세서리 뷰를 UIKit을 통해 생성하는 것이 여전히 최적의 솔루션이 됩니다. 화면 표시에 대한 완벽한 제어를 얻을 수 있을 뿐만 아니라 동일한 뷰 내부의 여러 텍스트 필드를 별도로 설정할 수도 있습니다.\n\n```js\nextension UIView {\n    func constrainEdges(to other: UIView) {\n        translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            leadingAnchor.constraint(equalTo: other.leadingAnchor),\n            trailingAnchor.constraint(equalTo: other.trailingAnchor),\n            topAnchor.constraint(equalTo: other.topAnchor),\n            bottomAnchor.constraint(equalTo: other.bottomAnchor),\n        ])\n    }\n}\n\nextension View {\n    func inputAccessoryView\u003cContent: View\u003e(@ViewBuilder content: @escaping () -\u003e Content) -\u003e some View {\n        introspectTextField { td in\n            let viewController = UIHostingController(rootView: content())\n            viewController.view.constrainEdges(to: viewController.view)\n            td.inputAccessoryView = viewController.view\n        }\n    }\n    func inputAccessoryView\u003cContent: View\u003e(content: Content) -\u003e some View {\n        introspectTextField { td in\n            let viewController = UIHostingController(rootView: content)\n            viewController.view.constrainEdges(to: viewController.view)\n            td.inputAccessoryView = viewController.view\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용법:\n\n```js\nstruct OnFocusDemo: View {\n    @FocusState var focus: FocusedField?\n    @State var name = \"\"\n    @State var email = \"\"\n    @State var phoneNumber = \"\"\n    var body: some View {\n        Form {\n            TextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n                .inputAccessoryView(content: accessoryView(focus: .name))\n\n            TextField(\"이메일:\", text: $email)\n                .focused($focus, equals: .email)\n                .inputAccessoryView(content: accessoryView(focus: .email))\n\n            TextField(\"전화번호:\", text: $phoneNumber)\n                .focused($focus, equals: .phone)\n        }\n        .onSubmit {\n            switch focus {\n            case .name:\n                focus = .email\n            case .email:\n                focus = .phone\n            case .phone:\n                if !name.isEmpty, !email.isEmpty, !phoneNumber.isEmpty {}\n            default:\n                break\n            }\n        }\n    }\n}\n\nstruct accessoryView: View {\n    let focus: FocusedField?\n    var body: some View {\n        switch focus {\n        case .name:\n            Button(\"이름\") {}.padding(.vertical, 10)\n        case .email:\n            Button(\"이메일\") {}.padding(.vertical, 10)\n        default:\n            EmptyView()\n        }\n    }\n}\n```\n\n# 사용자 정의 제출 레이블\n\n기본적으로 TextField (SecureField)의 키보드에 대한 제출 동작 버튼은 \"return\"입니다. SwiftUI 3.0에서 소개된 \"submitLabel\" 수정자를 사용하면 \"return\" 버튼을 입력 콘텍스트와 관련된 텍스트로 수정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nTextField(\"사용자 이름\", text: $username)\n            .submitLabel(.next)\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_4.png\" /\u003e\n\n현재 지원되는 유형은 다음과 같습니다:\n\n- continue\n- done\n- go\n- join\n- next\n- return\n- route\n- search\n- send\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 이전 코드에서는 이름, 이메일 및 전화번호에 대한 서로 다른 표시를 설정할 수 있습니다:\n\n```js\nTextField(\"이름:\", text: $name)\n                .focused($focus, equals: .name)\n                .submitLabel(.next)\nTextField(\"이메일:\", text: $email)\n                .focused($focus, equals: .email)\n                .submitLabel(.next)\n\nTextField(\"전화번호:\", text: $phoneNumber)\n                .focused($focus, equals: .phone)\n                .submitLabel(.return)\n```\n\n# 결론\n\nSwiftUI 1.0부터 Apple은 TextField의 기능을 지속적으로 개선해 왔습니다. 버전 3.0에서 SwiftUI는 더 많은 네이티브 수정자를 제공하는데 그치지 않고 FocusState와 onSubmit과 같은 통합 관리 논리를 제공합니다. 믿음직스러운 2~3년 뒤에는 SwiftUI의 주요 컨트롤의 네이티브 기능이 해당하는 UIKit 컨트롤과 맞먹을 것이라고 믿습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 글이 도움이 되었거나 즐겁게 읽으셨다면, 제 글을 지원하기 위해 기부를 고려해 주세요. 여러분의 기부는 저가 계속해서 가치 있는 콘텐츠를 만드는데 도움이 될 것입니다.\nPatreon, Buy Me a Coffee 또는 PayPal을 통해 기부할 수 있습니다.\n\n```js\n연락하고 싶다면?\n\nTwitter에서 @fatbobman을 팔로우하세요.\n```\n","ogImage":{"url":"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png"},"coverImage":"/assets/img/2024-06-23-AdvancedSwiftUITextFieldEventsFocusKeyboard_0.png","tag":["Tech"],"readingTime":36}],"page":"8","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"8"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>