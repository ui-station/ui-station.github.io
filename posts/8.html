<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/8" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/8" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 No MediaQuery widget found 오류 해결 방법" href="/post/2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 No MediaQuery widget found 오류 해결 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 No MediaQuery widget found 오류 해결 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Flutter에서 No MediaQuery widget found 오류 해결 방법</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기" href="/post/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="RxSwift 심층 탐구 메커니즘 분석" href="/post/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="RxSwift 심층 탐구 메커니즘 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="RxSwift 심층 탐구 메커니즘 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">RxSwift 심층 탐구 메커니즘 분석</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오픈 소스의 힘 Flutter로 Maestro 성능 최적화 하는 방법" href="/post/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오픈 소스의 힘 Flutter로 Maestro 성능 최적화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오픈 소스의 힘 Flutter로 Maestro 성능 최적화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">오픈 소스의 힘 Flutter로 Maestro 성능 최적화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제가 처음으로 애플 스토어에 앱을 배포한 방법 1" href="/post/2024-06-22-HowIpublishedmyfirstapptoAppleStore1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제가 처음으로 애플 스토어에 앱을 배포한 방법 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제가 처음으로 애플 스토어에 앱을 배포한 방법 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">제가 처음으로 애플 스토어에 앱을 배포한 방법 1</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법" href="/post/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드" href="/post/2024-06-22-Flutter-Bloc"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Flutter-Bloc_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS에서 URLCache 사용하기 초보자를 위한 가이드" href="/post/2024-06-22-URLCacheiniOSABeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS에서 URLCache 사용하기 초보자를 위한 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-URLCacheiniOSABeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS에서 URLCache 사용하기 초보자를 위한 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS에서 URLCache 사용하기 초보자를 위한 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift에서 weak와 unowned의 차이점 예제 포함" href="/post/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서 weak와 unowned의 차이점 예제 포함" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서 weak와 unowned의 차이점 예제 포함" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift에서 weak와 unowned의 차이점 예제 포함</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="4단계로 iOS 앱에 실시간 활동 추가하는 방법" href="/post/2024-06-22-AddLiveActivitiestoyouriOSappin4steps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="4단계로 iOS 앱에 실시간 활동 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AddLiveActivitiestoyouriOSappin4steps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="4단계로 iOS 앱에 실시간 활동 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">4단계로 iOS 앱에 실시간 활동 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">13 hours ago</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link posts_-active__YVJEi" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Flutter에서 No MediaQuery widget found 오류 해결 방법","description":"","date":"2024-06-22 23:27","slug":"2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter","content":"\n\n플러터 개발자들은 개발 과정 중에 종종 'No MediaQuery widget found' 메시지를 마주하게 됩니다. 특히 초보자들에게는 이 오류가 혼란스러울 수 있습니다. 이 글에서는 이 오류의 원인을 살펴보고, 쉽게 이해할 수 있는 단계와 설명으로 해결하는 방법에 대해 알아보겠습니다.\n\n## MediaQuery 위젯 이해하기\n\n플러터의 MediaQuery 위젯은 화면의 크기, 디바이스의 픽셀 비율 및 기타 화면 관련 요소에 대한 정보를 제공합니다. 위젯은 이 정보를 활용하여 레이아웃 및 스타일링에 대한 결정을 내릴 수 있습니다. 그러나 MediaQuery.of(context)를 호출하여 크기 정보에 의존하는 위젯이 MediaQuery 내부에 배치되지 않았을 경우 'No MediaQuery widget found' 오류가 발생합니다.\n\n## 오류를 유발하는 전형적인 시나리오들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 다음과 같은 시나리오 중 하나에서 오류가 발생합니다:\n\n- MediaQuery에 의존하는 위젯을 사용하지만 MediaQuery가 제공되지 않는 컨텍스트에 배치하는 경우, 예를 들어 Padding, SafeArea 또는 AspectRatio와 같은 경우\n- MediaQuery.of(context)에 의존하는 사용자 정의 위젯을 만들지만 Material App이나 WidgetsApp으로 감싸놓지 않은 경우\n\n## 오류 수정 방법\n\n## 1. MaterialApp으로 감싸기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위젯 트리를 MaterialApp로 래핑하는 것이 가장 일반적인 해결책입니다. 예를 들어:\n\n```js\nvoid main() {\n  runApp(MaterialApp(\n    home: MyHomePage(),\n  ));\n}\n```\n\n이렇게 하면 모든 하위 위젯에서 MediaQuery를 사용할 수 있습니다.\n\n## 2. Using WidgetsApp\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Material 컴포넌트를 사용하지 않는다면 대신 WidgetsApp을 사용할 수도 있어요:\n\n```js\nvoid main() {\n  runApp(WidgetsApp(\n    home: MyHomePage(),\n    color: Colors.blue,\n  ));\n}\n```\n\nWidgetsApp은 후손에 MediaQuery를 동일하게 제공해줍니다.\n\n### 3. BuildContext 무결성 보장하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n항상 MediaQuery.of(context)에서 사용하는 BuildContext가 MaterialApp 또는 WidgetsApp 아래에 있는 위젯에서 왔는지 확인해주세요.\n\n```js\nclass MyHomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final mediaQueryData = MediaQuery.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"My Home Page\"),\n      ),\n      body: Center(\n        child: Text(\"Screen Width: ${mediaQueryData.size.width}\"),\n      ),\n    );\n  }\n}\n```\n\n## 결론\n\nFlutter에서 'No MediaQuery widget found' 오류는 위젯 트리가 적절하게 MaterialApp 또는 WidgetsApp으로 래핑되어 있는지 확인함으로써 쉽게 해결할 수 있습니다. MediaQuery를 사용하는 맥락을 이해하여 이 흔한 함정을 피하는 것이 중요합니다. 위에서 설명한 단계를 따르면 이 오류를 만남 없이 Flutter 애플리케이션에서 MediaQuery를 효과적으로 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter_0.png","tag":["Tech"],"readingTime":3},{"title":"RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기","description":"","date":"2024-06-22 23:25","slug":"2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide","content":"\n\n\n![RPC Image 1](/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_0.png)\n\n![RPC Image 2](/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_1.png)\n\n# 원격 프로시저 호출(RPC)이란?\n\nRPC는 프로그램이 로컬 프로시저 호출과 마찬가지로 원격 서버(다른 주소 공간에 있는 서버)에서 프로시저(코드 블록)를 실행할 수 있는 기술입니다. 이는 네트워크 통신의 복잡성을 추상화하여 개발자가 기본 네트워킹 세부사항에 대해 과도하게 걱정하지 않고 분산 애플리케이션을 작성할 수 있도록 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 원격 프로시저란 무엇인가요?\n\n원격 프로시저는 다른 주소 공간에 위치한 코드 블록 또는 함수로, 일반적으로 클라이언트라고 불리는 다른 곳에 위치한 프로그램이나 프로세스에 의해 호출되고 실행될 수 있는 기능입니다.\n\n# 원격 프로시저의 주요 특징:\n\n- 원격 시스템에 위치: 원격 프로시저는 실행을 초기화하는 클라이언트와 비교하여 다른 기계, 주소 공간 또는 서버에 위치합니다.\n- 원격 클라이언트 호출 가능: 클라이언트는 이 프로시저를 로컬 함수 또는 메소드 호출인 것처럼 원격 위치에서 호출하고 실행할 수 있습니다.\n- 추상화된 통신: 클라이언트와 원격 프로시저 간의 통신은 추상화되어 있어, 클라이언트가 저수준 네트워킹 세부사항을 처리해야 할 필요 없이 원격 프로시저와 상호작용할 수 있습니다.\n- 투명한 호출: 원격 프로시저를 호출하는 클라이언트는 일반적으로 로컬 프로시저 호출과 유사하게 보이도록 프로그래밍 언어 구조를 사용하며, 실제로는 원격으로 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# RPC의 주요 구성 요소\n\n- 클라이언트: 원격 서버에서 서비스를 요청하여 RPC를 시작하는 프로그램 또는 프로세스입니다.\n- 서버: 요청된 서비스를 제공하는 프로그램 또는 프로세스입니다. 클라이언트는 서버로부터 수신된 RPC 요청을 청취하고 해당 절차를 실행합니다.\n- Stub: 클라이언트 프록시라고도 불립니다. 이는 원격 서비스의 로컬 표현입니다. 클라이언트는 스텁과 마치 실제 서비스인 것처럼 상호작용하며, 스텁은 통신 세부 정보를 처리합니다.\n- Skeleton: 서버 프록시라고도 불립니다. 클라이언트에게 서버의 인터페이스를 나타냅니다. 들어오는 RPC 요청을 받아들이고 매개변수를 해제하며 서버에서 적절한 절차를 호출합니다.\n- 통신 프로토콜: 클라이언트와 서버 간의 메시지 교환 규칙 및 형식을 정의합니다. HTTP, TCP/IP, gRPC와 같은 프로토콜이 RPC에 널리 사용됩니다.\n\n# RPC 작동 방식\n\n클라이언트가 원격 절차를 호출하면 일반적으로 다음 단계가 발생합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클라이언트 Stub 호출: 클라이언트는 로컬로 보이지만 실제로 원격 프로시저를 대표하는 스텁을 호출합니다. 스텁은 실행할 프로시저 및 해당 매개변수에 대한 정보를 포함한 RPC 요청을 준비합니다.\n- 마샬링: 매개변수 및 메소드 정보는 직렬화되어 (전송을 위한 형식으로 변환되어) 네트워크를 통해 전송될 수 있도록 준비됩니다.\n- 통신: 클라이언트는 선택한 통신 프로토콜을 사용하여 RPC 요청을 서버로 보냅니다.\n- 서버 스켈레톤 처리: 서버의 스켈레톤은 요청을 받아 데이터를 해제하고 (디마샬링) 요청된 프로시저를 결정합니다.\n- 로컬 프로시저 실행: 서버는 제공된 매개변수를 사용하여 요청된 프로시저를 실행합니다.\n- 응답 준비: 서버는 응답 (있는 경우)을 전송을 위한 형식으로 마샬링합니다.\n- 응답 전송: 서버는 클라이언트에게 응답을 다시 보냅니다.\n- 언마샬링: 클라이언트 Stub은 응답을 수신하고, 이를 언마샬하고, 로컬 프로시저 호출처럼 결과를 클라이언트에게 반환합니다.\n\n# 시나리오 예시\n\n클라이언트 프로그램이 서버에서 호스팅되는 원격 프로시저를 사용하여 숫자의 제곱을 계산해야 하는 상황을 상상해보세요:\n\n- 클라이언트 요청: 클라이언트는 서버에게 특정 숫자, 예를 들어 5의 제곱을 계산해 달라는 요청을 보냅니다.\n- 원격 프로시저 실행: 서버는 요청을 받아 \"제곱_계산\" 프로시저를 찾아 계산을 수행하고 (이 경우 25), 응답을 준비합니다.\n- 응답 전송: 서버는 계산된 결과 25를 요청한 클라이언트에게 다시 보냅니다.\n- 클라이언트 수신: 클라이언트는 응답을 받아서 원격 프로시저 실행으로부터 얻은 결과를 사용하여 작업을 계속할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 소프트웨어 개발 및 분산 시스템에서의 RPC 역할\n\n## 1. 네트워크 통신의 추상화:\n- 간소화된 통신: RPC는 네트워크 통신의 복잡성을 추상화합니다. 이를 통해 개발자들은 분산 애플리케이션의 개발을 단순화하기 위해 로컬처럼 원격 시스템에서 절차를 호출할 수 있습니다.\n- 사용 편의성: RPC를 사용함으로써 개발자들은 로우 레벨 네트워킹 세부 사항 대신에 애플리케이션 논리에 집중할 수 있습니다.\n\n## 2. 상호 운용성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Cross-platform 통신: RPC는 다른 시스템 및 프로그래밍 언어간의 통신을 가능하게 합니다. 이 유연성은 서로 다른 환경 간 상호 작용이 필요한 애플리케이션을 개발할 때 중요합니다.\n\n## 3. 모듈식 및 확장 가능한 아키텍처:\n\n- 모듈성: RPC는 복잡한 시스템을 관리 가능한 구성 요소로 분해하여 모듈식 소프트웨어 설계를 용이하게 합니다. 개발자는 특정 작업을 수행하는 서비스를 만들고 이를 결합하여 더 크고 확장 가능한 시스템을 형성할 수 있습니다.\n- 확장성: RPC는 서비스를 여러 서버 또는 시스템에 분산하여 확장을 지원합니다. 이를 통해 리소스 활용과 성능 최적화가 가능해집니다.\n\n## 4. 원격 서비스 접근:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 원격 리소스 액세스: RPC를 통해 서로 다른 기계나 서버에 위치한 서비스 및 리소스에 액세스할 수 있습니다. 특히 특정 기능이나 데이터가 별도의 서버나 위치에 있을 때 유용합니다.\n\n## 5. 클라이언트-서버 상호작용:\n\n- 클라이언트-서버 모델: RPC는 클라이언트-서버 모델을 구현하는 데 중요한 역할을 합니다. 여기서 클라이언트는 서버로부터 서비스나 리소스를 요청하게 됩니다. 이는 다양한 클라이언트-서버 아키텍처의 기초를 형성합니다.\n\n## 6. 재사용성과 캡슐화:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 코드 재사용성: RPC는 개발자가 여러 클라이언트에서 호출할 수있는 서비스를 생성할 수 있도록 함으로써 코드 재사용성을 촉진합니다.\n- 캡슐화: 원격 프로시저 실행의 구현 세부 정보를 캡슐화하여 클라이언트와 서버 사이의 더 깨끗한 분리를 제공합니다.\n\n## 7. 분산 컴퓨팅:\n\n- 분산 응용 프로그램: RPC는 분산 컴퓨팅의 중요한 부분으로, 여러 기기나 위치에 걸친 응용 프로그램 개발을 용이하게 합니다.\n\n## 8. 서비스 지향 아키텍처(SOA) 및 마이크로서비스:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- SOA와 Microservices: 서비스 지향 아키텍처 및 마이크로서비스에서 RPC는 서비스 또는 마이크로서비스 간의 통신을 정의하고 구현하는 데 도움이 됩니다.\n\n## 9. 효율적인 자원 활용:\n\n- 자원 최적화: RPC는 다른 기계 또는 서버간 작업 분산을 통해 효율적인 자원 활용을 가능하게 합니다. 작업 부하를 균형 있게 분배하는 것이 가능합니다.\n\n## 10. 실시간 통신:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 실시간 상호 작용: RPC는 클라이언트와 서버 간에 실시간 통신을 지원하여 즉각적인 응답과 상호 작용이 가능합니다.\n\n## RPC의 종류\n\n다양한 종류의 RPC가 있습니다:\n\n- 동기식 대비 비동기식: 동기식 RPC는 응답을 받을 때까지 대기하며 비동기식 RPC는 클라이언트가 즉시 응답을 기다리지 않고 작업을 계속할 수 있게 합니다.\n- 블로킹 대비 논블로킹: 블로킹 RPC는 클라이언트가 응답을 받기 전까지 대기하도록 하지만, 논블로킹 RPC는 클라이언트가 응답을 기다리지 않고 계속할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일반적인 RPC 프레임워크\n\n- gRPC: Google이 개발한 gRPC는 HTTP/2를 전송에 사용하고 직렬화에 Protocol Buffers를 사용하는 오픈 소스 RPC 프레임워크입니다.\n- Apache Thrift: Facebook이 개발한 RPC 프레임워크로, 다양한 프로그래밍 언어와 전송 방법을 지원합니다.\n- Java RMI (원격 메서드 호출): Java 전용 RPC 메커니즘으로 Java 객체간 원격 통신을 지원합니다.\n\n# 왜 원격 프로시저가 존재하는가\n\n원격 프로시저는 네트워크 환경에서 서로 다른 시스템이나 프로세스 간의 통신과 코드 실행을 원활하게하기 위해 도입되었습니다. 원격 프로시저가 도입된 이유는 여러 가지가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 분산 컴퓨팅:\n\n- 자원 활용: 원격 프로시저를 통해 다른 기계 또는 시스템 간의 자원 활용이 가능해집니다. 이를 통해 계산 작업을 분산시켜 전체 시스템 성능과 효율성을 향상시킬 수 있습니다.\n\n# 2. 연결된 시스템:\n\n- 상호 운용성: 서로 다른 하드웨어 및 소프트웨어 플랫폼이 혼재된 환경에서 원격 프로시저가 상호 운용성과 통신을 가능케 합니다. 이를 통해 기술적인 차이에 상관없이 정보와 기능을 교환할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 모듈화와 재사용성:\n\n- 모듈화: 원격 프로시저는 시스템 설계에 모듈화 접근법을 장려합니다. 개발자들이 별도의 서비스를 만들어 여러 응용 프로그램이나 구성 요소에서 재사용할 수 있도록 해줍니다. 이는 코드 재사용성을 향상시킵니다.\n\n# 4. 중앙화된 서비스:\n\n- 기능의 중앙화: 원격 프로시저는 특정 기능이나 서비스의 중앙화를 가능하게 합니다. 예를 들어 데이터베이스 서버는 데이터 검색이나 조작을 위한 원격 프로시저를 제공하여 여러 클라이언트에 서비스를 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 구성 요소 분리:\n\n- 클라이언트와 서버 분리: 원격 프로시저가 네트워크 통신의 세부 사항을 추상화함으로써 클라이언트를 서버에서 분리합니다. 이 분리는 다른 구성 요소에 영향을 미치지 않고 한 구성 요소의 변경 또는 업데이트를 허용하여 시스템 유연성을 향상시킵니다.\n\n# 6. 클라이언트-서버 모델:\n\n- 클라이언트-서버 통신: 원격 프로시저는 클라이언트-서버 통신 모델의 필수 요소입니다. 이를 통해 클라이언트는 서버로부터 서비스 또는 기능을 요청하고 수신하여 많은 네트워크 응용 프로그램의 기초를 형성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. 확장성 및 부하 분산:\n\n- 확장성: 원격 절차는 작업을 여러 서버 또는 시스템에 분산하여 작업 부하를 균형있게 분배하여 시스템 확장성을 향상시킵니다.\n\n# 8. 기능 캡슐화:\n\n- 캡슐화: 원격 절차는 특정 기능의 구현 세부 사항을 캡슐화하여 클라이언트와 서버 사이의 깔끔한 분리를 제공합니다. 이 분리는 개발과 유지보수를 간단하게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 9. 실시간 상호작용:\n\n- 실시간 통신: 원격 프로시저를 통해 다양한 구성 요소나 시스템 간에 실시간 상호작용이 가능해지며, 분산 환경에서 즉각적인 응답과 매끄러운 통신이 가능합니다.\n\n# 도전과 고려 사항\n\n- 보안: 안전한 통신을 보장하고 원격 프로시저에 대한 무단 액세스를 방지합니다.\n- 신뢰성: 네트워크 장애, 시간 초과 처리, 원격 호출의 일관성을 보장합니다.\n- 성능: 네트워크 지연 시간과 데이터 전송을 고려하여 RPC 호출을 속도와 효율성을 위해 최적화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모바일 앱 개발에서 원격 프로시저 호출이 필요한 이유는 무엇일까요?\n\n모바일 앱 개발에서 원격 프로시저 호출(RPC)을 도입하는 것은 여러 가지 경우에 유리할 수 있습니다:\n\n# 1. 백엔드 서비스 통합\n\n- 서버 측 기능 액세스: 모바일 앱은 종종 사용자 인증, 데이터 검색, 거래 처리 또는 리소스 액세스와 같은 다양한 기능을 위해 백엔드 서버와 상호 작용해야 합니다. RPC를 통해 모바일 앱과 백엔드 서비스 간에 통신을 원활하게 할 수 있어 서버 측 기능을 신속하게 통합할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. Cross-Platform Communication\n\n- 상호 운용성: 모바일 앱은 다른 기술이나 언어로 구축된 서비스나 시스템과 통신해야 할 수 있습니다. RPC는 이러한 다양한 플랫폼 간의 간극을 메꾸어 상호 운용성을 가능하게 하며 모바일 앱이 다양한 시스템과 상호 작용할 수 있도록 합니다.\n\n# 3. 모듈식 개발과 마이크로서비스\n\n- 마이크로서비스 통합: 마이크로서비스 아키텍처에서 모바일 앱은 RPC를 사용하여 이러한 서비스와 상호 작용할 수 있으며 모듈식 개발을 가능하게 하고 이러한 서비스가 제공하는 특정 기능을 활용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 원격 처리 및 오프로딩:\n\n- 리소스 집약적 작업: 모바일 기기는 처리 능력이나 배터리 수명에 한계를 가질 수 있습니다. RPC를 사용하면 계산적으로 요구되는 작업을 원격 서버로 오프로딩하여 모바일 기기를 과부하 없이 원활한 앱 성능을 보장할 수 있습니다.\n\n# 원격 프로시저 호출의 대안\n\n원격 프로시저 호출(RPC)의 대안으로 Representational State Transfer(REST) API 및 해당하는 메커니즘인 HTTP 기반 통신이나 웹 서비스를 활용할 수 있습니다. 이러한 대안은 시스템 또는 구성 요소 간의 통신을 원활하게 하기 위한 다른 접근 방식을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. RESTful APIs:\n\n- 상태 정보 유지: RESTful API는 HTTP 메소드(GET, POST, PUT, DELETE)를 사용하여 URL(Uniform Resource Locator)로 식별된 리소스에 대한 CRUD(Create, Read, Update, Delete) 작업을 수행합니다.\n- 리소스 중심 설계: REST API는 리소스 지향 아키텍처를 따르며, 데이터 엔티티를 표준화된 URL을 통해 접근할 수 있는 리소스로 취급합니다.\n- JSON 또는 XML 사용: 일반적으로 클라이언트와 서버 간 데이터 교환에 JSON 또는 XML과 같은 텍스트 기반 형식을 사용합니다.\n\n# 2. 웹 서비스 (SOAP, WSDL 및 XML-RPC):\n\n- SOAP (Simple Object Access Protocol): 웹 서비스에서 구조화된 정보를 교환하기 위해 XML 메시지 형식 및 HTTP, SMTP 또는 기타 전송 프로토콜을 메시지 협상에 사용하는 프로토콜입니다.\n- WSDL (Web Services Description Language): 웹 서비스, 메소드, 매개변수 및 통신 프로토콜을 설명하는 데 사용되는 XML 기반 언어입니다.\n- XML-RPC: RPC와 유사하게, XML-RPC는 XML을 데이터 교환 형식으로 사용하여 네트워크를 통해 프로시저를 실행할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# RPC와의 주요 차이점\n\n- 통신 패러다임: RPC는 원격 메서드 호출에 중점을 두는 반면, REST 및 웹 서비스(SOAP, XML-RPC)는 통신을 위해 리소스 중심 접근 방식이나 표준화된 프로토콜을 따릅니다.\n- 프로토콜과 형식: RPC 프레임워크는 일반적으로 이진 직렬화 형식을 사용하고 자체 통신 프로토콜을 가질 수 있습니다. 반면에 REST API는 주로 HTTP 또는 HTTPS를 통해 JSON 또는 XML과 같은 텍스트 기반 형식을 사용합니다.\n- 상태 비저장 vs. 상태 유지: RESTful API는 설계상 상태 비저장이며, SOAP와 같은 일부 웹 서비스는 세션과 같은 기능을 통해 상태 유지를 유지할 수 있습니다.\n\n# RPC 대안 선택 시기\n\n- 표준화와 상호 운용성: 여러 시스템이나 플랫폼 간의 표준화와 상호 운용성이 중요할 때는 REST API가 적합합니다.\n- 웹 통합: 웹 중심 애플리케이션이나 간단하고 확장 가능한 통신이 필요한 경우, RESTful API가 널리 사용되고 있어 사용이 편리합니다.\n- 의미론적 인터페이스: 인터페이스가 인간이 읽기 쉽고 이해하기 쉬워야 할 때, RESTful API의 리소스 중심 설계와 자기 설명적 URL이 인기 있는 선택지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# RPC 또는 REST를 선택하는 시점\n\n- RPC: 더 직접적이고 메소드 중심의 통신 스타일이 선호되는 경우에 적합합니다. 특히 서로 강하게 연결된 시스템이나 프로그래밍 언어 중립성이 필요한 경우에 적합합니다.\n- REST: 상호 운용성, 간결함, 확장성 및 웹 표준을 활용하는 능력이 중요한 상황에서 선호됩니다. RESTful API는 웹 중심 애플리케이션과 상태가 없는 통신 및 리소스 중심 설계를 선호할 때 일반적으로 사용됩니다.\n\n# RPC 또는 웹소켓을 사용하는 시점\n\n- RPC: 시스템 간 직접적인 메소드 호출이 필요한 경우 적합하며 특히 동기화되고 메소드 중심의 통신 패턴이 필요한 시나리오에서 적합합니다.\n- 웹소켓: 실시간 애플리케이션이 필요한 경우, 낮은 지연 시간과 양방향, 이벤트 중심의 통신이 필요한 경우에 선호됩니다. 라이브 업데이트, 게임, 채팅 애플리케이션 또는 영구적인 완전 이중 방향 연결이 필요한 시나리오 등이 해당됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n원격 프로시저 호출은 분산 애플리케이션이 원활하게 통신할 수 있게 하는 강력한 개념입니다. 스텁(stubs), 스켈레톤(skeletons) 및 기반이 되는 통신 프로토콜을 이해하는 것은 분산 시스템에서 작업하는 개발자들에게 중요합니다. RPC가 제공하는 유연성과 사용 편의성은 현대적이고 확장 가능하며 서로 연결된 애플리케이션의 개발에 상당한 기여를 합니다. RPC를 사용하면 개발자들은 기본 네트워킹 복잡성을 걱정하지 않고 견고하고 서로 연결된 시스템을 구축하는 데 집중할 수 있습니다.\n\n즐거운 코딩!\n\n👏🏽 👏🏽 이 이야기에 CLAPS를 보내주세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n👉🏽 다가오는 기사를 구독해보세요\n\n💰 무료 모바일 개발 튜토리얼에 접속해보세요\n\n🔔 더 많은 소식을 확인하기 위해 팔로우해주세요\n\n다음 기사에서 만나요 👋","ogImage":{"url":"/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":10},{"title":"RxSwift 심층 탐구 메커니즘 분석","description":"","date":"2024-06-22 23:24","slug":"2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms","content":"\n\n# 목적\n\n이 튜토리얼의 주요 목적은 RxSwift의 핵심 구성 요소에 대한 심층적인 이해를 제공하는 것입니다. RxSwift 뒷면의 구현에 주로 초점을 맞춰 설명합니다.\n\n이 게시물을 읽은 후에는 관찰 가능한(observables)이 무엇인지, 구독(subscriptions)이 무엇인지, 관찰 가능한이 어떻게 작동하는지에 대한 명확한 이해가 있을 것으로 기대됩니다.\n\n이 튜토리얼은 RxSwift에 대한 일부 경험이 있다고 가정하고 있습니다. 이는 이해하기 쉽게 만들어줄 것입니다. 저희 zen8labs에서는 RxSwift를 주로 멤버들에게 교육하고 있으며, Serg Dort의 멋진 튜토리얼 \"Learn Rx by implementing Observable\"을 주의 깊게 참고하도록 강력히 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSerg Dort님께 이 유용한 튜토리얼을 작성해 주신 것에 대해 진심으로 감사드립니다. 이 튜토리얼은 RxSwift의 구현을 간단하게 설명하여 RxSwift의 주요 구성 요소와 그들이 어떻게 함께 작동하는지 이해하기 쉽게 만들었습니다.\n\n한 번 다시, 이 튜토리얼을 주의 깊게 읽고 코드를 단계별로 따라 하시기를 부탁드립니다. 믿어 주세요, 정말 값어치가 있을 겁니다.\n\n정말 솔직히 말씀드리자면, RxSwift의 내부 작동 방식을 알 필요는 없습니다. 단지 옵저버블이 요소를 발행할 때, 정지할 때, 오류가 발생할 때, 옵저버블이 발행할 수 있는 요소의 개수, 그리고 구독을 해제해야 하는 시점에 집중하면 됩니다. 이러한 것들을 잘 이해하면 어떤 문제도 없이 RxSwift를 사용할 수 있습니다.\n\n하지만 제 경우에는 항상 사용 중인 것들이 어떤 일이 벌어지는지 이해하고 싶습니다. 제가 무엇을 올바르게 수행하고 있는지 확인하는 가장 좋은 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 질문들\n\n간단한 예제를 살펴봅시다:\n\n![이미지](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_0.png)\n\n이것은 기본적인 예제입니다. 그러나 RxSwift의 중요한 개념들을 대부분 포함하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에는 많은 숨겨진 세부 사항이 있습니다.\n\n이에 대한 몇 가지 질문이 있습니다:\n\n- Observable은 추상 클래스이고 Disposable은 프로토콜입니다. 그래서 여기서 실제로 생성되는 유형은 무엇인가요?\n- 이러한 오퍼레이터들은 실제로 어떻게 작동합니까?\n- 데이터는 이러한 오퍼레이터들을 통해 어떻게 처리됩니까?\n- 오퍼레이터들은 어떻게 함께 구성되는가요?\n- 왜 우리는 로직을 실행하기 위해 구독해야 하죠?\n- 구독은 언제 끝나나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 질문에 대답하려면 이 연산자들의 구현을 살펴보겠습니다.\n\n## 구현\n\n연산자의 경우:\n\n![이미지](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n맵 연산자:\n\n![맵 연산자](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_2.png)\n\n필터 연산자:\n\n![필터 연산자](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해 주세요.\n\n\n| header1 | header2 |\n|---------|---------|\n| data1   | data2   |\n| data3   | data4   |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(1) Producer 클래스는 실제로 Observable 클래스의 하위 클래스이므로 RxSwift 연산자는 기본적으로 Producer의 다른 하위 유형을 반환하는 메서드입니다.\n\n(2) Producer에 구독할 때마다 SinkDisposer가 반환됩니다. 사실 Observable 클래스는 추상 유형이며 해당 인스턴스를 직접적으로 생성하지 않습니다. 대신, 우리는 연산자를 사용하여 observables을 만듭니다. 따라서 우리가 일상적으로 프로그래밍에서 사용하는 observables 대부분은 사실 Producer의 하위 클래스입니다. 따라서 observables에 구독할 때 대부분의 구독은 SinkDisposer입니다. 예시의 구독 또한 SinkDisposer입니다.\n\n(3) Producer 클래스에는 \"run\"이라는 내부 추상 메서드가 있습니다. 이는 Producer의 하위 클래스가 비즈니스 로직을 구현해야 하는 곳입니다. \"run\" 메서드는 항상 sink와 subscription 두 가지를 반환합니다.\n\n이제, 예시에서 네 가지 observables(ObservableSequence, Map, Filter, TakeCount)의 구현을 탐구하여 sink와 구독이 무엇인지에 대한 질문에 답해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nObservableSequence\n\n![Image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_6.png)\n\nMap\n\n![Image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nFilter\n\n![Filter Image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_8.png)\n\nTake\n\n![Take Image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_9.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이상한가요?\n\n이 네 가지 옵저버블의 run 메서드에 주목해 봅시다. 각 유형의 옵저버블에는 해당하는 Sink 클래스가 있다는 것을 알 수 있어요: ObservableSequence에는 ObservableSequenceSink, Map에는 MapSink, Filter에는 FilterSink, TakeCount에는 TakeCountSink가 있어요. 그리고 RxSwift의 다른 옵저버블에도 마찬가지예요.\n\n게다가, 옵저버블 자체는 어떤 로직도 실행하지 않음을 알 수 있어요; 그저 옵저버블 로직을 위한 디자인 또는 템플릿으로 동작할 뿐이에요. 정작 모든 일을 하는 사람은 Sink라는 거죠.\n\n이를 시각화해 보면, 옵저버블이 기계의 청사진이라고 상상해 보세요. 반면 Sink 인스턴스는 그 청사진을 기반으로 구축된 실제 기계에요. 사실 Sink는 RxSwift에서 일어나는 모든 마법 같은 일들이 일어나는 곳이에요. 그것은 우리 관찰자에 대한 참조를 유지하고, 옵저버블 로직을 실행하며, 결과 이벤트를 관찰자에게 전달해요. RxSwift에서 특정 유형의 옵저버블이 어떻게 작동하는지, 그것이 처리되는 데이터를 어떻게 살펴야 하는지를 정말로 이해하려면 해당 옵저버블의 Sink를 살펴보면 돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또 다른 중요한 점은 run 메서드에서 Observable을 구독할 때만 Sink 인스턴스가 생성된다는 것입니다. 이것이 Observable의 논리가 구독되어야만 실행되고, Observable을 구독할 때마다 논리가 다시 실행되는 이유를 설명합니다. 이는 새로운 Sink 인스턴스가 생성되기 때문에 발생하는 것입니다.\n\nProducer의 run 메서드가 항상 반환하는 하나 더의 구성 요소는 subscription입니다. 그렇다면 subscription이란 무엇일까요?\n\n이 질문에 답변하기 전에, RxSwift가 조합 가능하다는 점을 기억해 두세요. 즉, 여러 개의 각기 다른 유형의 Observable을 한 개의 Observable로 결합할 수 있다는 것이죠, 마치 다수의 객차로 구성된 기차와 유사합니다.\n\n![image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 종류의 observable이 있습니다: Generation observables과 Transformation observables.\n\n- Generation observables는 자체적으로 이벤트를 생성하는 observables입니다. 예를 들어, create, of, from... 연산자에서 반환된 observables입니다. Generation observable은 항상 모든 파워를 생성하는 기차 머리와 같은 역할을 합니다. 어떤 이벤트도 Generation observable에서 시작됩니다. 위의 ObservableSequence 구현을 살펴보면, 구독은 sink 인스턴스를 실행한 결과입니다. 구독은 Sink 실행을 관리하기 위해 할당된 리소스를 관리하는 Disposable 프로토콜을 구현한 형식입니다. Sink가 생성을 완료하면, 구독은 Sink가 할당한 모든 리소스를 해제하기 위해 삭제됩니다.\n- Transformation observables는 원본으로부터 받은 이벤트를 observable로 변환하는 observables입니다. 예를 들어, map, filter, take... 연산자에서 반환된 observables입니다. Map, Filter, TakeCount 구현을 살펴봅시다. 각 클래스는 항상 기본적으로 이전 체인 내의 observable에 대한 참조인 원본 observable을 갖습니다. 구독은 sink를 원본 observable에 구독하는 결과입니다. 그리고 원본 observable이 사실상 다른 Producer인 경우, 구독도 SinkDisposer입니다. 이것은 RxSwift가 여러 연산자를 연결하는 방법입니다.\n\n모든 것을 연결하면, 다음과 같이 예시를 시각화할 수 있습니다:\n\n![이미지](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 우리 예시에서 발생한 일입니다:\n\n1. 생성 단계:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제로 나오는 결과 observable은 TakeCount입니다. TakeCount는 Filter가 있는 observable 소스를 가지고 있습니다. Filter에는 observable 소스인 Map이 있습니다. Map은 observable 소스인 ObservableSequence를 가지고 있습니다. ObservableSequence는 자체적으로 이벤트를 생성할 수 있는 생성 observable입니다.\n\n2. 구독 단계:\n\n결과 observable에 구독하면 실제로 TakeCount observable에 구독하게 됩니다. TakeCountSink를 만들어 TakeCount의 로직을 실행하고 Filter observable을 해당 Sink에 구독하여 구독을 만듭니다. Sink 및 구독은 TakeCount에 구독을 할 때 반환된 SinkDisposer에 의해 관리됩니다. 예시에서 해당 구독은 바로 이 SinkDisposer입니다.\n\nFilter, Map 및 ObservableSequence에 대해서도 동일한 동작이 발생합니다. 각 단계는 자체 Sink 및 SinkDisposer를 만들며, 각 SinkDisposer의 구독은 이전 단계의 SinkDisposer입니다. ObservableSequence는 생성 observable이므로 ObservableSequenceSink 자체를 실행하기 위해 할당된 자원을 관리하는 인스턴스로 구독하는 것이며, 그 외의 단계에서 발생하는 것과는 다릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 3. Running phase:\nObservableSequenceSink가 이벤트를 방출하기 시작하고, 그 observer는 MapSink입니다. MapSink는 ObservableSequenceSink에서 이벤트를 가져와서 작업을 처리하고(2로 곱함), 그 결과를 그 observer인 FilterSink에게 방출하고, 이런 식으로 계속됩니다... 마지막 싱크는 TakeCountSink이며, 이는 예시에서 값이 프린트되는 클로저에 이벤트를 방출합니다.\n\n### 4. Dispose phase:\n작업을 마치면 구독을 해제합니다. 실제로 TakeCount의 SinkDisposer입니다. 그러면 이 SinkDisposer가 TakeCountSink와 그 구독을 해제하고, 이는 Filter의 SinkDisposer의 구독인 것입니다. ObservableSequence의 마지막 SinkDisposer에 이르기까지 해제 프로세스가 계속됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이것이 RxSwift의 전체 그림입니다. 이 게시물이 RxSwift 내부에서 무엇이 발생했는지에 대해 더 깊은 이해를 가지는 데 도움이 되기를 바랍니다. 다른 주제에 관심이 있다면, 여기에서 유용한 기술 정보를 확인해보세요!\n\n토안 누옌, 시니어 모바일 엔지니어","ogImage":{"url":"/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_0.png"},"coverImage":"/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_0.png","tag":["Tech"],"readingTime":7},{"title":"오픈 소스의 힘 Flutter로 Maestro 성능 최적화 하는 방법","description":"","date":"2024-06-22 23:21","slug":"2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter","content":"\n\n마에스트로는 기본 또는 크로스 플랫폼 기술로 구축된 앱에 대한 최종 UI 테스트를 생성하는 가장 빠르고 쉬운 방법입니다. 마에스트로는 \"안드로이드 테스팅 프레임워크\"나 \"플러터 테스팅 프레임워크\"가 아니라, 접근성 정보에만 의존하는 \"UI\" 테스팅 프레임워크입니다.\n\n이 기사에서는 Flutter 앱을 테스트할 때 사용자가 마주한 문제와 우리가 Flutter 오픈 소스 프로젝트에 기여함으로써 그 문제를 어떻게 해결했는지 알아볼 수 있을 거예요!\n\n# Flutter에 대한 간단한 소개\n\nFlutter에 익숙하지 않은 분들을 위해, Flutter는 Dart 언어를 사용하여 앱을 구축하기 위한 크로스 플랫폼 프레임워크입니다. Flutter에서 UI의 거의 모든 부분(버튼, 목록, 화면 전체)을 위젯이라고 부릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터의 독특한 특징 중 하나는 게임 엔진처럼 작동한다는 점입니다. 위젯은 캔버스 위에 직접 렌더링됩니다. 이에는 많은 장점이 있지만, 네이티브 구성 요소를 사용하지 않기 때문에 안드로이드와 iOS에서 제공하는 기본 UI 프레임워크에서처럼 UI를 설명하는 의미 정보를 자동으로 제공할 수 없습니다. 대신, 플러터 위젯은 전체 의미 정보 트리를 직접 구성합니다.\n\n## 플러터에서의 의미 정보\n\n여기서 플러터의 구성 요소인 접근성 브릿지라는 것이 필요합니다. 이는 플러터 앱 내부에 존재하는 가상 의미 트리를 TalkBack이나 VoiceOver와 같은 스크린 리더가 이해할 수 있는 네이티브 의미 트리로 번역합니다. 또는 Maestro와 같은 접근성 기반 테스트 프레임워크에서 이해할 수 있도록 합니다!\n\n![이미지](/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연히 이것은 단순화된 내용입니다 (Flutter는 시맨틱 트리라는 다른 트리에서 접근성 정보를 유지합니다), 하지만 핵심은 동일합니다.\n\nFlutter의 탁월한 접근성 지원 덕분에 Maestro는 항상 훌륭하게 작동했습니다.\n\n## Flutter에서의 키\n\n반응형 프레임워크(예: React 또는 Flutter)를 사용한 적이 있다면 키(Key) 개념에 익숙할 것입니다. Flutter의 모든 위젯은 선택적인 \"key\" 인수를 받습니다. 키는 프레임워크가 어떻게 하나의 위젯이 다른 위젯을 대체하는지 제어하는 데 사용됩니다. 예를 들어 편집 가능한 목록에서 자주 발생하는 경우입니다. 키는 위젯을 화면에서 고유하게 식별하는 데도 사용될 수 있지만 그것이 주요 목적은 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 문제 설명\n\n몇 달 전에 Maestro 사용자 중 한 명이 GitHub에 흥미로운 기능 요청을 제출했습니다. 그는 Maestro가 키를 기반으로 플러터 앱과 상호 작용할 수 있기를 원했습니다:\n\n![image](/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_1.png)\n\n다시 말해, 그는 Maestro 플로우에서 이 코드를 작성할 수 있기를 원했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n- tapOn:\n    flutterKey: add_comment\n- tapOn:\n    flutterKey: comment_text_field\n- inputText: Mobile UI Testing, Simplified.\n\n\n이 기능 요청은 Maestro 사용자들에게 중요한 것으로 나타났습니다 - 빠르게 30개의 좋아요를 받아 GitHub 저장소에서 두 번째로 많이 추천된 이슈가 되었습니다!\n\n\u003cimg src=\"/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_2.png\" /\u003e\n\n커뮤니티로부터 이러한 강력한 피드백을 받아 우리는 이 문제에 대해 심층적으로 알아보기로 결정했습니다. 다행히 이 이슈 작성자는 자체적으로 flutter_driver 패키지를 사용한 초기 구현을 공유하기도 했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 입력: flutter_driver\n\n플러터 드라이버는 플러터의 원본 솔루션으로 엔드 투 엔드 UI 테스트를 위한 것입니다. 사용하려면, 개발자는 flutter_driver 패키지에 종속성을 추가하고 앱 시작 중에 이를 초기화해야 합니다. 그런 다음 테스트 스크립트를 Dart로 작성하여 호스트 기계에서 실행합니다. 테스트 스크립트는 웹소켓을 통해 실행 중인 앱과 JSON-RPC 명령(탭 또는 enterText와 같은)을 주고받습니다.\n\n![이미지](/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_3.png)\n\n드라이버 스크립트는 플러터 앱을 실행하는 동일한 Dart VM과 통신하기 때문에 탭, 클릭, 텍스트 입력 등 다양한 작업을 수행할 수 있습니다. 이는 위젯 키로 위젯을 찾는 것도 가능합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nasync void main() {\n  final driver = await FlutterDriver.connect();\n  await driver.tap(find.byValueKey('add_comment'));\n  await driver.close();\n}\n```\n\nflutter_driver의 중요한 제한 사항은 Flutter에 의해 렌더링된 UI와만 상호 작용할 수 있다는 것입니다. 즉, 권한 대화상자와 같은 네이티브 UI 요소에 액세스할 수 없다는 것입니다. 다행히 Maestro는 이미 시맨틱 정보를 사용하여 네이티브 UI와 상호 작용하고 있기 때문에 이것은 문제가 되지 않습니다.\n\n지금까지 잘 진행되고 있습니다. 그럼 함정은 무엇일까요?\n\n# flutter_driver에서 문제점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지 몇 년 동안 플러터 팀에 의해 flutter_driver가 서서히 제거되고 있습니다. 제거될 예정이라는 신호는 없지만 구글 내부를 포함한 많은 기존 테스트가 이에 의존하므로 지원, 버그 수정 또는 개발을 거의 받지 않고 있습니다. 이는 처리되지 않은 이슈의 많은 숫자에서 확인할 수 있습니다.\n\n플러터 개발자들은 flutter_driver에서 integration_test 플러그인으로 이주하도록 권장받습니다. integration_test 플러그인은 flutter_driver의 몇 가지 문제점(예: 완전한 블랙박스인 것, JSON을 주고받기만 하는 것)을 해결하지만 새로운 문제점을 도입하고, 여전히 심각한 UI 테스트에 대한 실용적인 솔루션은 아닙니다. 또한 2021년 1분기에 Flutter 2.0에서 출시된 이후 큰 업데이트를 받지 않았습니다.\n\n이제 flutter_driver를 안정적인 기반으로 보지 않는 이유를 이해하셨습니다. 하지만 안정성과 유지 보수 측면을 제외하고도 다른 심각한 단점들이 있었습니다.\n\n## 릴리스 빌드에서 작동하지 않음\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 드라이버는 디버그 및 프로필 모드로 빌드된 앱에서만 작동합니다. 이 제한은 Dart VM 서비스 확장으로 구현되었기 때문에 릴리스 빌드에서는 비활성화된 서비스 확장으로 인해 발생합니다. 이 동작을 변경하려면 패키지를 포크하고 서비스 확장 대신 일반 HTTP 서버를 사용해야 합니다.\n\n## 앱 코드 수정 필요\n\n앱 개발자는 pubspec.yaml 파일에 flutter_driver를 포함하고 일부 초기화 코드를 추가해야 합니다. 이로 인해 Maestro의 가장 인기 있는 기능 중 하나인 놀랍도록 간단한 설정 또는 설정 없음이 사라지게 됩니다.\n\n## 컨텍스트 전환\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 선택한 flutterKey 인수를 selectors에 추가해도 테스트 중인 Flutter 앱에서만 작동할 것입니다. 따라서 Maestro 사용자들은 테스트의 현재 \"컨텍스트\"(내 Flutter 앱이 현재 실행 중인가요?)를 추적해야 합니다. 이는 분명히 직관적이지 않습니다.\n\n## Flutter 위젯 트리와 의미 트리 간의 복잡한 상호작용\n\n탭 또는 입력 텍스트와 같은 간단한 경우는 잘 작동할 것입니다. 그러나 보다 복잡한 상황은 어떨까요? Maestro의 훌륭한 기능 중 하나는 강력한 selector 시스템입니다. 다음과 같이 복잡한 명령을 작성할 수 있습니다:\n\n```js\n- tapOn:\n    below: \"View above that has this text\"\n    above:\n        id: \"view_below_id\"\n    leftOf: \"View to the right has this text\"\n    rightOf: \"View to the left has this text\"\n    containsChild: \"Text in a child view\"\n    childOf:\n        - id: \"buy-now\"\n    containsDescendants:\n        - id: \"title_id\"\n          text: \"A descendant view has id 'title_id' and this text\"\n        - \"Another descendant view has this text\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플러터 드라이버와 함께 작동할 수 있는 방법은 무엇일까요? 명확한 답이 없네요. 어떤 멋진 트리 병합을 사용해야 할까요? Maestro는 가장 간단하고 효과적인 테스트 프레임워크를 지향한다는 것을 기억하세요.\n\n## 불량 사례\n\n이 접근 방식은 전반적으로 Maestro에 플러터의 존재를 \"가르쳐 주어야 한다는\" 것을 필요로할 것입니다. 하지만 우리는 정말 그렇게 하고 싶지 않습니다. Maestro의 핵심 기능 중 하나는 당신이 앱을 작성하는 기술에 관계없이 항상 잘 작동한다는 것입니다. 이는 당신의 앱이 생성한 의미 정보만 사용함으로써 가능합니다. (내부 작동 방식에 대해 더 알아보려면 이 기사를 확인하세요).\n\n플러터를 위해 특별한 지원을 추가하면 잘못된 선례가 될 수 있습니다. 우리는 접근성만을 고려한 접근 방식에서 벗어나 Flutter를 지원하기 위해 존재하는 추가 코드를 유지해야 할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 다시 스케치하는 중\n\n플러터 드라이버 접근 방식이 마음에 들지 않았어요. \n\n에드워도(원래 이슈 작성자)가 제공한 초안 실행 방식만 사용하고 (화면 테스트 도구를 개발했던 제 경험을 많이 참고하여) 몇 가지 사고 실험을 진행했더니 이미 많은 문제점이 발견되었어요.\n\n한 발 물러나서 생각해 보았어요. 정말 옳은 문제를 해결하려고 노력 중인 걸까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 시맨틱 위젯 — 누락된 조각\n\n처음에 Flutter 앱의 의미론 정보가 어떻게 AccessibilityBridge에 의해 네이티브 의미론으로 변환되는지 보여드렸습니다. 이것은 복잡한 시스템이지만, 앱 개발자의 관점에서는 위젯을 시맨틱 정보와 함께 주석 처리하기 위해 Semantics 위젯을 사용하는 것으로 이해할 수 있습니다:\n\n```js\nSemantics(\n  label: '이상한 빨간 상자 위젯',\n  child: InkWell(\n    onTap: () =\u003e launchUrl('https://youtu.be/YlUKcNNmywk?t=148'),\n    child: Container(width: 100, height: 100, color: Colors.red),\n  ),\n)\n```\n\nSemantics.label 필드는 AccessibilityBridge에 의해 접근성 레이블로 변환되며, 이는 텍스트 마에스트로의 선택기라고 불립니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n- tapOn:\n    text: \"이상한 빨간 상자 위젯\"\n```\n\n접근성 레이블의 문제는 스크린 리더가 사용자에게 읽혀진다는 점입니다. 실제로 그것이 목적이죠. 도움이 되는 콘텐츠를 UI 테스트에 사용될 이상한 식별자로 대체하고 싶지 않으시겠죠. 악인이 되지 마세요!\n\n다행히도 안드로이드와 iOS의 기본 시맨틱 요소는 접근성 식별자도 지원합니다. 이는 접근성 레이블과 동일하지만 UI 테스트에만 사용됩니다. 스크린 리더는 이를 읽지 않습니다.\n\n마에스트로는 항상 시맨틱 식별자에 기반한 상호 작용을 지원해 왔습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\n- tapOn:\n    id: login_button\n```\n\nFlutter에서 작동하지 않는 이유는 무엇일까요? 답은 간단합니다: 'Semantics' 위젯에는 의미 식별자용 속성이 없습니다.\n\n빠른 구글 검색으로도 Flutter 문제인 \"테스트 목적을 위한 접근성 ID 누락\"이라는 적절한 이름의 문제가 확인되었습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_4.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테스트와 관련된 Flutter 이슈 중에서 가장 많이 투표를 받은 문제였어요. 2018년 5월 생성되어 129개의 투표를 받았죠. 접근성 식별자가 빠져 있어서 짜증났던 사람들이 우리뿐만이 아니었다는 사실을 알게 되었어요!\n\n만약 이 문제를 해결하면, Maestro 사용자뿐만 아니라 Flutter 앱을 진지하게 테스트하고자 하는 모든 사람들이 혜택을 받을 거예요.\n\n# Plan B — Flutter 수정하기\n\n이 문제를 해결하는 데 시간이 좀 걸렸어요. 5년 동안 120개의 댓글을 다 읽는 것은 꽤 어려운 작업이었죠! 하지만 해냈고, 이미 필요한 변경이 무엇인지 대충 감이 왔어요 — Semantics 위젯에 식별자 속성을 추가해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSemantics(\n  identifier: 'tap_me',\n  label: 'A weird red box widget',\n  child: InkWell(\n    onTap: () =\u003e launchUrl('https://youtu.be/YlUKcNNmywk?t=147'),\n    child: Container(width: 100, height: 100, color: Colors.red),\n  ),\n)\n```\n\n위젯을 시멘틱스 식별자로 탭하려면:\n\n```js\n- tapOn:\n    id: \"tap-me\"\n```\n\n## 장단점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 \"fix Flutter approach\"가 매력적으로 보였어요. 이점들은 분명하게 있었습니다:\n\n- 높은 보상 — 모든 것들이 갑자기 작동하기 시작할 거에요\n- Maestro의 철학에 충실 — 설정이 제로이고 사용하기 쉽고 간단함\n- flutter_driver의 문제점이 전혀 없어요\n\n불확실한 점들도 몇 가지 있었어요:\n\n- 외부 프로젝트에 (복잡한 지도) 기여가 필요해요\n- 프로젝트 소유자들이 받아들일 수도 없을 기여가 필요해요\n- 받아들여진다 해도, 주기적으로 큰 Flutter 릴리즈에만 사용 가능할 거에요, 이는 매 분기마다 일어나요\n- 앱 개발자들은 이를 활용하기 위해 Flutter 버전을 업그레이드해야만 할 거에요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다행히도이 기능 요청은 긴급하지 않았기 때문에 우리는 시간을 들여 제대로 처리하기로 결정했습니다. \"Flutter 방식 수정\"이 실패할 경우 언제든지 \"flutter_driver 접근 방식\"을 재고할 수 있을 것이기 때문입니다.\n\n# 구현\n\n가장 재미있는 부분!\n\n우리가 기여한 기능은 간단해 보이지만, Flutter의 모든 레이어 — 프레임워크, 엔진 및 Android 및 iOS 내장 프로그램 — 에 변경이 필요했고, 다양한 프로그래밍 언어 — Dart, Java, Objective-C++ 및 C++ — 을 사용하여 일부 코드를 작성해야 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_5.png\" /\u003e\n\n플러터 프로젝트는 Framework(flutter/flutter)와 Engine(flutter/engine)로 두 가지 주요 리포지토리로 나뉘어져 있어요.\n\nFramework에서의 변경사항은 빠르고 즐거웠지만, Engine은 완전히 다른 수준이었어요. 수십만 줄의 코드가 있었죠. 컴파일하는 데 한 시간을 기다리는 것은 재미 없었지만 다행히도 점진적 빌드는 단 몇 분밖에 걸리지 않았어요.\n\n또한, 플러터 프로젝트는 모든 PR이 master로 병합되기 전에 모두 초록색이어야 한다고 강요하고 있어요. 이로 인해 Framework ↔ Engine 경계에서 일부 내부 API를 변경해야 했고, 결과적으로 빨간색 CI가 발생했던 어려움이 있었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_6.png)\n\n의도적인 순환 종속성은 프레임워크와 호환되지 않는 엔진 변경 사항을 병합할 수 없도록 합니다.\n\n임시 API를 도입하고 식별자 속성을 주의 깊게 추가함으로써 이 문제를 해결했습니다. 결과적으로 5개의 풀 리퀘스트가 생성되었습니다:\n\n- [엔진] 임시 API 추가\n- [프레임워크] 임시 API에 종속\n- [엔진] 원본 API를 임시 API와 동일하게 업데이트\n- [프레임워크] 원본 API에 종속, 임시 API에 대한 종속 제거\n- [엔진] 임시 API 제거\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세스는 상당히 복잡했지만, Flutter와 같은 큰 프로젝트에서 완벽한 의미를 가집니다.\n\n# 결과\n\n성공! 🎉\n\n새 Semantics.identifier 속성은 Android 및 iOS의 원래 접근성 트리에 존재하며 Maestro 및 Maestro Studio 모두에서 매끄럽게 작동합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 깜박해서 Flutter에서 가장 많은 추천을 받은 테스팅 이슈 #1도 해결해 버렸어요! 그리고 이건 Maestro뿐만 아니라 모든 모바일 UI 테스팅 프레임워크를 사용하는 사용자들을 위해 한 거에요! 그래서 여전히 Appium을 사용해서 Flutter 앱을 테스트하고 Maestro로 전환하고 싶지 않은 경우에도, 여전히 당신의 기여에서 이익을 얻을 수 있어요.\n\n커뮤니티에서는 5년 된 이슈가 해결되어 기뻤답니다 🤠\n\n\u003cimg src=\"/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_7.png\" /\u003e\n\n# 지금 바로 시도해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최신 안정화된 Flutter 3.19 릴리스에서는 이미 Semantics.identifier을 사용할 수 있어요:\n\n```js\n$ flutter channel stable\n$ flutter upgrade\n```\n\n또한 Flutter 문서도 업데이트했습니다 — 이제 Semantics.identifier 사용법을 설명하는 것뿐만 아니라 더 포괄적이고 유용해졌어요 🙌\n\n지금은 이만 글을 마치겠습니다 — 다음에 또 뵙겠습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아직 Maestro를 사용하여 Flutter 앱을 테스트해보지 않았다면, 지금 해보세요! 확실히 머리가 터질 것입니다. 여기에서 시작하고 Slack에 참여해주세요!","ogImage":{"url":"/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-Thepowerofopen-sourceMakingMaestroworkbetterwithFlutter_0.png","tag":["Tech"],"readingTime":10},{"title":"제가 처음으로 애플 스토어에 앱을 배포한 방법 1","description":"","date":"2024-06-22 23:20","slug":"2024-06-22-HowIpublishedmyfirstapptoAppleStore1","content":"\n\n![이미지](/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_0.png)\n\n# 배경\n\n안녕하세요! 저는 울라즈입니다. 첫 번째 iOS 애플리케이션을 작성 중이에요. 지난 주에 물병에서 물을 쏟아 노트북이 고장 났어요. 그래서 다음 몇 주 동안 코딩을 못하니 대신 글을 쓸 거예요...\n\n지난 몇 년 동안 자신의 일을 시작하고자 끊임없이 생각했어요. 나 자신을 위해 일하는 것을 꿈꿨죠. 새로운 사업을 시작하기 위한 기준은 몇 가지가 있었어요. 여가 시간에 해야하고 필요한 기술이나 배우기를 원하는 욕망이 있어야 했어요. 그리고 초기 투자가 적고 6개월 이내에 초기 결과를 볼 수 있는 잠재력이 있어야 했어요. 드롭 배송이나 프린트 온 디맨드 티셔츠 스토어부터 내 카페나 어린이 장난감 가게까지 아이디어는 다양했어요. 많은 아이디어가 지루해서 폐기되었지만 무언가가 동작하지 않을까 두려워서 대부분이었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 해 전에 아빠가 되었고 성장하는 아기의 활동을 추적하기 위해 앱을 다운로드했어요. 이름은 기억이 안 나지만 목적을 잘 해결해 주었어요. 유료로 제공되어야 했던 몇 가지 기능이 구독 없이 사용할 수 없어서 아쉬웠지만, 급하게 제 자신의 앱을 만들어보려고 생각했어요.\n\n\u003cimg src=\"/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_1.png\" /\u003e\n\n이 아이디어가 마음에 들어서 모든 조건을 충족시킬 수 있다고 생각했어요: 매일 1~2시간을 코딩할 수 있었고, 휴대폰 개발을 배우고 싶었으며, 자금이 필요하지 않았어요 (전혀 사실이 아니라면, 다음 부분에서 설명할게요), 그리고 6개월 안에 완성할 수 있을 것 같았어요. 판매할 계획은 없었고, 주된 목적은 배우기와 개인적인 용도였어요. 릴리스 프로세스를 간소화하고 싶었기 때문에 변화를 가하기 위해 쉽게 새 버전을 릴리스할 수 있지 않을까 생각했어요. 만약 모든 것이 잘 풀린다면 미래에 수익창출을 시도하고 수동적인 소득을 얻을 수 있겠죠. 그래서 밤에 피트니스 볼 위에 앉아 딸을 흔들며 한 손으로 타이핑을 시작했어요.\n\n첫 번째 일은 무엇을 작성할지와 어느 플랫폼을 위해 작성할지를 결정하는 것이었어요. iOS에만 제한하지 않기로 결정해서 안드로이드 스마트폰 사용자들이 제 아름다운 작품을 사용할 기회를 놓치지 않게 하려고 했죠. 그래서 React Native과 Flutter 중에서 선택했어요. 회사에서 내부 서비스를 지원하기 위해 React를 배워야 했는데, React Native를 선호하는 이유였죠. 공식 문서를 보고 예상대로 시작해봤는데, 시뮬레이터에서 Hello World 예제를 실행하려고 해보니 예상보다 순조롭지 않았어요. 환경 설정 과정이 어색해서 제 동기부여가 금방 떨어졌어요. 종속성이 설치되지 않고, 시뮬레이터가 실행되지 않거나 이유를 알 수 없이 다운되기도 했어요. 게다가 앱 릴리스 프로세스가 불분명해서 2~3주간 투쟁한 끝에 아이디어를 포기했어요. 게다가 우리 아이의 일상이 안정되고 유료 앱을 사용하지 않게 되었거든요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![앱 이미지](/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_2.png)\n\n아홉 달이 지나자 우리는 다른 도시로 이사를 가게 되었고, 저는 체육관에 가입했어요. 이전에도 시도해 봤지만 오래 기억하지 못했어요. 이번에는 체육관이 걸어서 2분 거리에 있어서 규칙적으로 빠뜨릴 가능성이 거의 없었어요. 세트와 무게를 기록할 앱을 찾기 시작했고, 여러 개가 있었어요. 처음 발견한 앱이 나에게 적합했지만, 시간이 지남에 따라, 한 세트만 주석을 남길 수 없고, 세 개 이상의 루틴을 만들 수 없다는 것을 깨달았어요.\n\n그래서 나는 내 앱 아이디어로 돌아가고 무엇으로 쓸지 고민했어요. 이번에는 가장 쉬운 길인 작게 시작하고 빨리 배우는 길을 선택하기로 결정했어요. 주로 나 자신을 위해 쓰기 때문에, iOS만 지원하도록 제한하기로 했어요. 진입 장벽이 매우 낮았고, 애플의 공식 자습서로 시작했고, 처음 두 시간 안에 시험 앱을 핸드폰에 올렸어요. 그래서 매일 업무를 끝낸 후에 운동 기록 앱을 만들기 시작했어요 💪.\n\n지금까지입니다! 끝까지 읽어 주신 모든 분들께 감사드려요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 게시물에서는 다음과 같은 주제를 다룰 예정입니다:\n\n- 개발 프로세스 및 왜 스위프트를 배우지 않고 ChatGPT에게 물어보기로 결정했는지 \n- 첫 번째 릴리스 \n- 향후 계획\n\n여기서 스크린샷을 확인하거나 다운로드할 수 있습니다. 광고나 등록이 필요하지 않으며 무료로 제공됩니다.","ogImage":{"url":"/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_0.png"},"coverImage":"/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_0.png","tag":["Tech"],"readingTime":3},{"title":"안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법","description":"","date":"2024-06-22 23:17","slug":"2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention","content":"\n\n⚡주요 요점:\n\n- 프로모션 남용은 비즈니스의 가입 보너스, 추천, 쿠폰 또는 프로모션을 악용하는 사기 유형입니다.\n- 가능한 경우에는 MediaDRM을 디바이스 지문보다 선호해야 합니다.\n- 우리의 연구 결과, 블록리스트에 가장 적합한 최고의 디바이스 ID는 MediaDRM+디바이스 모델의 결합입니다.\n- 모바일 앱 백엔드 API를 보호하는 AppiCrypt(앱 보호), RASP(앱 쉴딩) 및 KYC 솔루션(고객 신원 확인)과 같은 여러 보안 계층을 항상 포함해야 합니다.\n- 특정 시나리오에 따라 다른 접근 방식이 필요할 수 있다는 것을 염두에 두세요. info@talsec.app으로 메시지를 남기면 Talsec 보안 전문가가 도와드릴 것입니다.\n\n# 사용자 파악 방법?\n\n최근에 모바일 디바이스 식별에서 어려움에 부딪혔습니다 - 사용자 개인정보를 침해하지 않으면서 사기적인 디바이스를 식별하고 블록리스트에 올리는 방법은 무엇일까요. 이 문제는 결제 회피 또는 다양한 보너스를 악용하는 사용자들과 빈번히 대면하는 모바일 애플리케이션 소유자에게 특히 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n초기 가입 시 사용자들을 유혹하는 매력적인 보너스로 사용자를 유치하는 것은 흔한 일이지만, 이 전략은 내재적인 위험을 안고 있으며 남용될 수 있다는 점을 인지하는 것이 중요합니다. 이 악의적인 사용자들은 앱을 여러 번 다시 설치하여 계속해서 가입 보너스를 얻으려는 행위를 하는데, 이를 \"멀티 인스턴싱\"이라고 부릅니다.\n\n안드로이드는 각 앱 인스턴스마다 일부 디바이스 ID를 변경하므로, 동일한 악의적 사용자의 디바이스를 차단하기가 어려워집니다. 이는 효과적인 해결책을 찾기 위한 우리의 노력이 복잡함을 강조합니다.\n\n![이미지](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png)\n\n# 좋은 ID는 고유하며 충돌 방지, 지속적이고 개인정보 친화적이어야 합니다. 그리고 위조할 수 없어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n과거에는 특별한 권한을 요청하지 않고 MAC 주소나 IMEI를 통해 기기를 식별할 수 있었어요. 오늘날 안드로이드 개인 정보 보호를 위한 다양한 변경 사항 이후, Android 기기에서 AndroidID, MediaDRM, GSF ID, FID 및 InstanceID와 같은 여러 반영구적 ID가 사용 가능해졌어요. 물론, 사용자에게 상승된 액세스 및 잠재적 보안 문제를 가진 권한을 요청하는 것은 현실적이지 않아요.\n\n각 ID에는 장단점이 있어 다양한 시나리오에서 유용하게 사용될 수 있어요. 아래 예시 테이블을 참고하세요. Android 문서에서 ID에 대한 추가 정보를 찾을 수 있어요.\n\n또 다른 방법으로는 다양한 디바이스 지문 라이브러리(예: fingerprintjs-android)를 사용하여 여러 기기 ID, 기기 상태, OS 지문 또는 설치된 앱을 기반으로 ID를 생성할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 ID들을 더 자세히 살펴보겠습니다.\n\n# AndroidID, GSF ID, FID, InstanceID, Google 광고 ID\n\n이러한 식별 방법은 다른 맥락에서는 잘 작동할 수 있지만, 우리의 시나리오에서는 부정한 다중 인스턴싱에 견딜 수 있는 견고함이 부족합니다. 이러한 ID들은 비교적 쉽게 변경할 수 있으므로 각각에 대한 단점에 대해 간단한 설명만 제공하겠습니다.\n\n- AndroidID는 다시 패키징되거나 기기의 다른 사용자로 설치되는 경우 변경됩니다.\n- GSF ID (Google Play 서비스 프레임워크 ID)는 Google 기기에만 제한되며 XPrivacyLua에 의해 상대적으로 쉽게 위조될 수 있습니다. 또한 다른 사용자에 대해 변경됩니다.\n- FID (Firebase 설치 ID)는 재설치를 견뎌내지 못합니다.\n- InstanceID (GUID, UUID.randomUUID().toString())는 사용자 정의 생성 및 내부 저장 ID입니다만, 재설치를 견딜 수 없습니다.\n- Google 광고 ID는 전혀 적합하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하면, 우리의 시나리오에서 나쁜 행위자를 식별하는 데 충분히 견고한 ID는 없습니다.\n\n# fingerprintjs-android 라이브러리 기반의 지문 ID\n\n참고: 전체 분석에서 우리는 상태 없는 오프라인 지문 ID를 위해 종합적인 신호 목록을 사용하는 fingerprintjs-android 라이브러리를 사용했습니다. 다른 지문 ID 라이브러리의 결과는 다를 수 있습니다. 이는 그들의 데이터 인사이트, 지리 위치, IP 위치, TEE 및 다른 요소에 기반한 더 많은 신호와 휴리스틱을 포함할 수 있습니다. Talsec는 fingerprintjs-android V3 및 StabilityLevel.OPTIMAL을 수집합니다. 안정성 수준 (STABLE — OPTIMAL — UNIQUE) 사이의 차이점은 여기에서 찾을 수 있습니다.\n\n위의 표를 다시 한 번 살펴보세요. 첫눈에는 하드웨어 지문 (위의 표 참조)가 최선의 선택일 수 있습니다. 이것은 인스턴트 앱 이벤트를 제외하고는 무엇이든 견딜 수 있습니다. 그러나 이 ID에는 한 가지 심각한 단점이 있습니다 — 충돌입니다. 이 충돌은 ID가 계산되는 방식에 의해 발생합니다. ID는 디바이스의 하드웨어에만 기반하기 때문에 발생합니다. 예를 들어, 조립 라인에서 직접 나오는 모든 삼성 갤럭시 Z 플립이 동일한 ID를 갖게 될 것입니다. 이 유형의 지문은 STABLE 지문이라고 불립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png)\n\n한편, 고유한 지문(fingerprint)이 있습니다. 이것은 기기의 ID를 계산하기 위해 상당량의 신호를 사용합니다. 이 방식으로 생성된 ID는 하나의 사용자에게만 매칭될 가능성이 높습니다(충돌이 적음), 그러나 신호가 많기 때문에 ID가 자주 변경될 수 있습니다(예: 설정 변경시). 따라서 하나의 사용자에게 많은 ID가 생길 수 있어 우리의 사용 사례에는 유용하지 않습니다. 예: 설치된 앱이 변경되거나 데이터 로밍이 활성화/비활성화될 때 ID가 변경될 수 있습니다.\n\n세 번째 유형의 지문은 STABLE과 UNIQUE 지문 사이의 절충안인 OPTIMAL 지문입니다. 이 지문은 STABLE 지문보다는 덜 안정적이지만 더 고유하며 Talsec SDK에 의해 수집됩니다. 그러나 이 유형의 지문조차 이 기사에서 나중에 보여줄 것처럼 최적적이지 않습니다. 예: 사용자가 12시 및 24시간 형식으로 전환하거나 개발자 설정 또는 ADB가 활성화/비활성화될 때 ID가 변경될 수 있습니다.\n\n지문 예시: `f37fc958dc6d566a8f4bf1e0fd25b510`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# MediaDRM\n\nMediaDrm은 프리미엄 콘텐츠 재생을 위해 암호화 키를 안전하게 제공하는 안드로이드 API입니다. Google의 Widevine 및 Microsoft의 PlayReady와 같은 DRM 공급자를 사용합니다. 초기 DRM 사용 중에는 장치 프로비저닝을 통해 장치의 DRM 서비스에 저장된 고유한 인증서를 획득합니다.\n\n이 API에서 제공되는 MediaDRM은 장치 상의 모든 사용자에게 동일하지만, 저희 상황에서는 위조하기 어렵고 많은 공격에도 견딜 수 있습니다. 이 ID를 얻으려면 권한이 필요하지 않습니다.\n\n하지만 여전히 제한 사항이 있습니다. MediaDrm을 지원하지 않는 장치에서는 사용할 수 없을 수 있습니다. 또한 동일한 제조업체의 장치 간에는 충돌이 많이 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMediaDRM 예시: `e3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6`\n\n# MediaDRM vs 지문 ID?\n\n우리는 다섯 대의 기기와 에뮬레이터를 여러 개의 다중 인스턴싱 시나리오에서 테스트하고 ID가 변경되었는지 여부를 확인했습니다. 가장 흥미로운 부분은 MediaDRM과 Fingerprint (V3 \u0026 V5 Optimal)입니다. 그래서 우리는 특히 이 부분에 주의를 기울였습니다.\n\n다중 인스턴싱 시나리오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 앱의 첫 설치\n- 앱 재설치\n- 작업 프로필에 설치\n- Island 앱을 사용하여 앱의 복제\n- Parallel Space를 사용하여 앱의 복제\n- 병렬 애플리케이션을 사용하여 앱의 복제\n- 두 번째 공간(Xiaomi)을 사용하여 앱의 복제\n- 손님 프로필에 설치\n- 공장 초기화\n- 안드로이드 에뮬레이터 대 실제 기기\n\n이 지루한 작업은 훌륭한 지문 OSS 데모 도구 덕분에 더 쉽게 진행되었습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_3.png\" /\u003e\n\n가장 중요한 관찰 결과를 여기에 나열하였습니다. 모든 테스트를 항상 수행할 수는 없었기 때문에 사소한 부분들은 모두 다시 시도했습니다 - 이는 공격자들이 시도할 것이기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유지한 것 (= 좋은):\n\n- 미디어 DRM은 처음 설치 시 OnePlus 8 Pro의 Island App에서 동일하게 유지되었습니다.\n- 미디어 DRM은 Redmi Note 10 Pro의 두 번째 공간에서 동일하게 유지되었습니다.\n- 미디어 DRM은 OnePlus 8 Pro에서 공장 초기화 후에도 동일하게 유지되었습니다.\n- 미디어 DRM은 OnePlus 8T에서 처음 설치, 작업 프로필 및 여러 사용자에 대해 동일하게 유지되었습니다.\n- 첫 설치 및 병렬 공간에서의 OnePlus 8T의 Fingerprint V5 Optimal이 동일하게 유지되었습니다.\n- Redmi Note 10 Pro에서 다시 설치 후에도 미디어 DRM 및 Fingerprint V3 및 V5 Optimal이 동일하게 유지되었습니다.\n- OnePlus 8T의 첫 설치, 작업 프로필 및 병렬 공간에서 Fingerprint V5 Optimal이 다시 설치 후에도 동일하게 유지되었습니다.\n\n변경된 것 (= 나쁜):\n\n- 처음 설치 및 Island App에서 Fingerprint V5 Optimal이 변경되었습니다.\n- OnePlus 8 Pro에서 공장 초기화 후 Fingerprint V5 Optimal이 변경되었습니다.\n- Redmi Note 10 Pro의 두 번째 공간에서 Fingerprint V5 Optimal이 변경되었습니다.\n- OnePlus 8T의 병렬 공간에서 미디어 DRM이 변경되었습니다.\n- OnePlus 8T의 작업 프로필 및 게스트 사용자에서 Fingerprint V5 Optimal이 변경되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른:\n\n- 에뮬레이터에서 FingerprintV3 Optimal이 Fingerprint V5 Optimal보다 성능이 더 좋았습니다.\n- Emulator 1과 Emulator 2에서 MediaDRM이 다르게 동작했는데 둘 다 동일한 Windows 기계에서 실행되었습니다.\n\n이러한 관찰을 바탕으로 Fingerprint V3과 V5 Optimal은 MediaDRM과 비교했을 때 많은 다중 인스턴스 사기 시나리오에서 실패했습니다. 이러한 테스트에서 우리는 MediaDRM이 더 나은 것으로 결론지었습니다.\n\n# 원시 데이터 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과를 양적으로 파악하기 위해 우리는 데이터를 살펴보고 해당 ID들의 행동을 평가하여 데이터를 기반으로 가장 적합한 ID를 찾아냈습니다. 사용자 기반의 기기와 비교하여 우리의 데이터가 왜곡되어 있고 대표적이지 않을 수 있다는 점을 기억해 주세요.\n\n## 2주간의 데이터 수집\n\n우리는 2주 동안 freeRASP 데이터를 수집하여 분석했습니다. 이 기간이 비교적 짧기 때문에 다시 설치하는 경우가 많지 않다고 가정합니다. 다시 한 번 강조하지만, 특정 응용프로그램의 카테고리/사용 사례에 따라 실제 재설치 비율이 달라질 수 있으므로 이 창을 선택하는 데 실제 재설치 비율에 대한 연구가 없다는 점을 유의해 주세요.\n\n아래에서 각 ID의 고유 값 수와 이 데이터에서 캡처된 고유 디바이스 모델 수를 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAndroidID: 13 402 601\n\nFingerprintV3: 22 525 265\n\nMediaDRM: 13 285 081\n\nInstanceId: 13 740 706\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 기기 모델: 14,175 (예: Pixel 4, SM-G973N, ONEPLUS A5000, LG-H930, ...)\n\n처음에 봤을 때 다른 ID들의 수보다 훨씬 높은 FingerprintV3의 수를 알아차렸어요. 이것은 사용자가 32가지 관측된 지문 신호 중 일부를 변경할 때마다 변하는 FingerprintV3의 행동에 의한 것일 수 있어요.\n\n## ID들은 어떻게 관련이 있을까요?\n\n그 후, 우리는 ID들 간의 동시 발생을 살펴보았습니다. 이를 통해 그들 간의 관련성을 파악해 보았어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 테이블을 읽는 방법입니다. 하나의 AndroidID에는 1.00557개의 고유한 MediaDRM이 있으며, 고유한 AndroidID 중 0.54%가 하나 이상의 MediaDRM을 가지고 있습니다.\n\n## ID 충돌: 같은 ID지만 다른 기기\n\n데이터에 따르면, 우리는 여전히 \"최적\" 식별자를 찾고 있기 때문에 \"다른 기기\"가 무엇인지 말할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아이디 당 평균 모델 수를 살펴봐요. ID마다 모델이 하나만 있는 것이 이상적입니다 — 서로 다른 디바이스에 동일한 ID가 있는 충돌이 최소화되기를 바랍니다. 아래 표를 빠르게 살펴보면 진정한 불일치가 있음을 알 수 있어요.\n\n![표](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_5.png)\n\n## 결과\n\n데이터 분석 결과, 다음과 같이 진술할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- FingerprintV3는 다른 ID들에 비해 값이 너무 많아서 우리 시나리오에서는 덜 유용합니다.\n- 하나의 AndroidID/MediaDRM/InstanceID에는 보통 여러 개의 FingerprintV3가 있습니다.\n- AndroidId와 MediaDRM은 대략 1:1 관계이며, 일부 MediaDRM 인스턴스에는 AndroidID보다 더 많은 AndroidID (AndroidId보다 더 많은 MediaDRM을 가지고 있는 경우도 있습니다).\n- 경우에 따라 하나의 AndroidID에는 여러 개의 InstanceID (MediaDRM보다 더 자주 발생), MediaDRM과 InstanceID 사이의 관계와 유사합니다.\n- InstanceID는 MediaDRM보다 AndroidID와 더 밀접한 관계에 있습니다.\n- AndroidID는 하나의 모델만 가지고 있습니다 (이상치의 양은 극히 적음).\n- MediaDRM은 일반적으로 하나의 모델을 가지나, 몇 가지 충돌이 있을 수 있습니다 (AndroidID의 경우보다 더 많음).\n- InstanceId는 이 두 모델 사이 어딘가에 위치합니다.\n\n총평으로, 이러한 식별자 중에서 AndroidID가 가장 우수해 보이며, MediaDRM이 그 뒤를 이어갑니다. InstanceId도 유용할 수 있지만 AndroidID만큼은 아닙니다. FingerprintV3은 우리 시나리오에서는 쓸모 없습니다. AndroidID는 다시 설치 후 변경되고 상대적으로 쉽게 위조될 수 있기 때문에 사기 탐지에는 MediaDRM이 가장 적합해 보입니다.\n\n다만, MediaDRM은 충돌이 꽤 많이 발생하는 것 같습니다 (모델 분석을 기반으로 확인한 결과). 같은 제조업체의 기기끼리(즉, 동일 제조업체의 기기일수록 다른 제조업체의 기기보다 더 같은 MediaDRM을 가질 가능성이 훨씬 높음) 충돌이 가장 자주 발생하는 것으로 밝혀졌습니다. 여기에 전반적인 개요를 제공해 드리겠습니다:\n\n- MediaDRM 중 0.005%가 여러 제조업체를 가지고 있음\n- MediaDRM 중 0.55%가 같은 제조업체의 여러 모델을 가지고 있음\n- 한 MediaDRM 당 평균 제조업체 수: 1.000085\n- 한 제조업체 당 MediaDRM의 평균 모델 수: 1.006362\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## MediaDRM를 개선할 수 있을까요?\n\n우리는 많은 시도(자세히 설명하지는 않겠습니다) 끝에 MediaDRM+모델의 조합을 잠재적 ID로 실험해 보았습니다.\n\n구글 Pixel 4의 MediaDRM+모델의 결합 예시: e3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6+Pixel 4\n\n아래는 위와 동일한 공현 테이블이며, 이제 MediaDRM+모델과의 관계를 포함하고 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_6.png)\n\n우리는 MediaDRM+ 모델이 원래의 MediaDRM보다 더 나은 성능을 보여준다는 것을 확인할 수 있습니다. 각 MediaDRM+ 모델에는 연관된 다른 ID의 수가 더 적습니다. 이는 몇 가지 충돌을 피했다는 것을 의미합니다 (정확한 숫자를 측정하기는 어렵지만, 최소한의 경계는 MediaDRM과 MediaDRM+ 모델의 숫자로 추정됩니다).\n\n두 가지 특성의 조합으로 ID를 만들 때, 한 기기가 더 많은 ID를 가지는 문제가 발생할 수 있습니다. 그러나 MediaDRM+ 모델에서는 이런 경우가 발생하지 않아야 합니다. 한 기기에는 하나의 모델만 연결되어야 하기 때문에 (즉, 구글 픽셀 4 전화기의 물리적 단위는 항상 \"Pixel 4\" 모델 이름만을 가져야 함).\n\n그러므로 데이터를 기반으로, 사기 탐지 사례를 검토할 때 MediaDRM과 기기 모델의 간단한 조합을 ID로 사용하는 것을 제안합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n저희는 모바일 기기 식별에 대한 도전에 직면하고 있습니다 — 사용자 개인 정보를 침해하지 않고 사기꾼 기기를 차단하는 방법에 대해 고민하고 있습니다. 모바일 앱 소유자들은 사용자들이 결제를 회피하거나 보너스를 악용하는 문제에 직면하고 있는데, 이는 여러 번 앱을 재설치함으로써 이루어지는 다중 인스턴스화로 인한 문제입니다. 신뢰할 수 없는 기기 ID로 인해 꾸준한 악의적인 사용자를 식별하는 것이 어려워지고 있습니다. 저희의 연구 결과는 효과적인 차단을 위해 미디어 DRM을 기기 지문보다 우선시하는 것을 권장하며 (또는 더 나아가 미디어 DRM과 기기 모델 조합을 권장합니다). 또한 AppiCrypt, RASP 및 KYC 솔루션과 같은 추가적인 보안층으로 보호 강화를 잊지 마세요. 모든 시나리오는 유니크합니다. 맞춤형 조언이 필요하시면 info@talsec.app 으로 Talsec 보안 전문가에게 문의하세요.\n\n저자: Dáša Pawlasová, Matúš Šikyňa, Tomáš Soukal","ogImage":{"url":"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png"},"coverImage":"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png","tag":["Tech"],"readingTime":10},{"title":"2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드","description":"","date":"2024-06-22 23:16","slug":"2024-06-22-Flutter-Bloc","content":"\n\n![Bloc](/assets/img/2024-06-22-Flutter-Bloc_0.png)\n\n## Bloc이란?\n\nBloc은 '비즈니스 로직 구성 요소'의 약자로, Google에서 권장하는 패턴 중 하나입니다. 이 패턴은 비즈니스 로직을 UI로부터 분리할 수 있도록 도와줍니다. 또한 응용 프로그램에서 책임을 분리하여 쉽게 테스트 가능한 코드를 작성할 수 있는 패턴입니다. Google에서 권장하는 다른 패턴은 여기에서 확인할 수 있습니다.\n\nBloc은 세 가지 구조로 구성됩니다. 이들은 이벤트 클래스, 상태 클래스 및 Bloc 클래스입니다. 이제 이들을 좀 더 자세히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![img](/assets/img/2024-06-22-Flutter-Bloc_1.png)\n\n1. 이벤트:\n이벤트는 응용 프로그램에서 수행하려는 작업을 나타냅니다. 연락처 응용 프로그램을 고려해보세요. 이 경우, 이벤트는 GetUsers, UpdateUser, DeleteUser 등이 될 것입니다. 이 이벤트에 대한 추상 클래스가 있으며, 다른 이벤트들은 이 추상 클래스를 상속받아 사용합니다.\n\n응용 프로그램에서 수행하려는 작업에 따라 직접 이벤트를 만들어야 합니다.\n\n2. 상태:\n상태는 응용 프로그램에서 발생할 수 있는 상황을 나타냅니다. 어떤 상황에서 무엇을 해야 할지를 결정하는 데 사용됩니다. 연락처 앱의 경우 UsersInitial, UsersLoading, UsersLoaded 및 UsersError 등이 있을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 블록:\nBloc 클래스를 중간 클래스로 생각할 수 있습니다. 이 클래스는 이벤트와 상태를 연결합니다. 이벤트가 트리거되면, 어떤 함수가 호출될지와 어떤 상태로 애플리케이션이 전환될지는 블록 클래스에서 결정됩니다.\n\n## 블록 사용\n\n저는 Bloc을 사용하여 프로젝트를 개발했습니다. 이 프로젝트에는 화면이 있습니다. 이 화면에서는 The Last Airbender에서 캐릭터를 무작위로 가져올 수 있습니다. 저는 Clean Architecture로 프로젝트를 개발했지만, 이 이야기에서는 블록의 사용법만 설명합니다. Clean Architecture에 대한 자세한 내용은 여기에서 읽을 수 있습니다. 프로젝트 개발 중에는 The Last Airbender API를 사용했습니다.\n\n## 예제 채우기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 코어, 구성 및 기능 폴더를 생성했습니다. 그런 다음 fetch characters의 기능을 위해 features 폴더 내에 characters 폴더를 만들었습니다. 마지막으로 characters 폴더 내에 데이터, 도메인 및 프리젠테이션 폴더를 생성했습니다.\n기능 폴더에 bloc 폴더를 만들었습니다. 이는 Bloc이 애플리케이션의 비즈니스 로직에 사용되기 때문입니다.\n\nBloc의 세 부분인 이벤트, 상태 및 bloc 파일을 추가했습니다.\n\n![2024-06-22-Flutter-Bloc_2.png](/assets/img/2024-06-22-Flutter-Bloc_2.png)\n\n## 코드 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 제가 CharactersInitial, CharactersLoading, CharactersError 및 CharactersLoaded 상태를 결정했고 CharactersState를 추상 클래스로 만들었습니다. 그런 다음 다른 상태에 CharactersState에서 상속을 제공했습니다.\n\n```js\npart of 'characters_bloc.dart';\n\nabstract class CharactersState {}\n\nclass CharactersInitial extends CharactersState {}\n\nclass CharactersLoading extends CharactersState {}\n\nclass CharactersLoaded extends CharactersState {\n  CharacterEntity character;\n  CharactersLoaded({required this.character});\n}\n\nclass CharactersError extends CharactersState {\n  String? errorMessage;\n  CharactersError(this.errorMessage);\n}\n```\n\n둘째로, 이벤트를 위한 추상 클래스를 만들었습니다. 이 어플리케이션에서는 캐릭터만 가져올 것이기 때문에 GetCharacter 이벤트만 생성했습니다. 그리고 CharactersEvent 클래스에서 GetCharacters 클래스로 상속을 제공했습니다.\n\n```js\npart of 'characters_bloc.dart';\n\nabstract class CharactersEvent {}\n\nclass GetCharacters extends CharactersEvent {}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBloc으로부터 CharactersBloc으로 상속을 받았고, 클래스의 생성자 메서드에 이벤트를 추가했습니다. 그런 다음 데이터를 가져오기 위해 getCharacters 함수를 만들었습니다. 이 함수에서 API 결과에 따라 상황을 트리거했습니다.\n\n```js\npart 'characters_event.dart';\npart 'characters_state.dart';\n\nclass CharactersBloc extends Bloc\u003cCharactersEvent,CharactersState\u003e {\n   final GetCharacterUseCase _getCharactersUseCase;\n   CharactersBloc(this._getCharactersUseCase) : super(CharactersInitial()){\n     on\u003cGetCharacters\u003e(getCharacters);\n   }\n\n\n   Future\u003cvoid\u003e getCharacters(GetCharacters event, Emitter\u003cCharactersState\u003e emit) async {\n     emit(CharactersLoading());\n     final dataState = await _getCharactersUseCase.call(null);\n     if(dataState is DataSuccess){\n       emit(CharactersLoaded(character: dataState.data!));\n     } else if(dataState is DataFailed){\n       emit(CharactersError(dataState.exception!.message));\n     }\n   }\n}\n```\n\n마지막으로 CharactersPage를 작성했습니다. 상태를 감시하기 위해 BlocBuilder를 사용했습니다. 이것은 상태가 변경되었을 때 관련 함수를 반환할 수 있기 때문입니다.\n\n```js\n_buildBloc() {\n    return BlocBuilder(\n      bloc: _bloc,\n      builder: (BuildContext context, state) {\n        if(state is CharactersLoading){\n          return _showLoadingAnimation();\n        } else if(state is CharactersLoaded){\n          return _buildCharactersList(state);\n        } else if(state is CharactersError){\n          return _buildErrorView(state);\n        } else {\n          return _buildInitialView();\n        }\n      },\n    );\n  }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n화면이 로드되면 GetCharacters 이벤트를 트리거합니다.\n\n```dart\n@override\nvoid initState() {\n  super.initState();\n  _bloc.add(GetCharacters());\n}\n```\n\n자세히 살펴보고 싶다면 GitHub 링크를 여기에서 찾을 수 있어요.\n\n😊 읽어 주셔서 감사합니다 😊","ogImage":{"url":"/assets/img/2024-06-22-Flutter-Bloc_0.png"},"coverImage":"/assets/img/2024-06-22-Flutter-Bloc_0.png","tag":["Tech"],"readingTime":5},{"title":"iOS에서 URLCache 사용하기 초보자를 위한 가이드","description":"","date":"2024-06-22 23:15","slug":"2024-06-22-URLCacheiniOSABeginnersGuide","content":"\n\n\n![이미지](/assets/img/2024-06-22-URLCacheiniOSABeginnersGuide_0.png)\n\niOS 개발자로서, 네트워크 요청을 효율적으로 관리하고 데이터를 캐시하는 방법을 이해하는 것은 앱의 성능과 사용자 경험을 크게 향상시킬 수 있습니다. URLCache는 애플이 제공하는 내장 프레임워크 중 하나로, 여러분이 이용할 강력한 도구 중 하나입니다. 이 가이드에서는 무엇인 URLCache인지, 핵심 개념, 실제 응용 사례, 그리고 iOS 프로젝트에서 효과적으로 사용하는 방법에 대해 알아보겠습니다.\n\n# URLCache란 무엇인가요?\n\nURLCache는 iOS의 Foundation 프레임워크에서 제공하는 메커니즘으로, URLSession과 같은 URL 로딩 시스템에서 응답을 캐시하여 네트워크 요청의 효율성을 향상시킬 수 있습니다. 이미지, JSON 또는 기타 리소스와 같은 다운로드된 데이터를 기기의 로컬에 저장하여 동일한 데이터를 반복적으로 네트워크에서 다시 가져오는 필요성을 줄입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 핵심 개념\n\n- 캐싱 정책: URLCache를 사용하여 다른 유형의 요청에 대한 캐싱 정책을 정의할 수 있습니다. 응답이 캐시에 얼마나 오랫동안 저장되어야 하는지 및 어떤 조건에서 서버를 통해 다시 유효성을 검사해야 하는지를 결정합니다.\n- 저장: 캐시된 응답은 디스크 기반 캐시에 저장되므로 앱이 닫혀도 다시 열릴 때까지 유지됩니다.\n- 유효성 검사: URLCache는 캐시된 응답을 서버와 유효성을 검사하기 위한 메커니즘을 제공하여 해당 응답이 여전히 유효하고 최신인지를 확인합니다.\n\n# 실용적인 응용\n\nURLCache는 다양한 시나리오에서 네트워크 요청을 최적화하고 사용자 경험을 향상시키는 데 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 성능 향상: 자주 액세스하는 데이터를 로컬로 캐싱하여 지연 시간을 줄이고 앱의 응답성을 향상시킬 수 있습니다.\n- 오프라인 지원: 캐시된 데이터는 기기가 오프라인 상태일 때도 액세스할 수 있어 사용자에게 원활한 경험을 제공합니다.\n- 대역폭 사용량 감소: 응답을 캐싱함으로써 네트워크를 통해 전송되는 데이터 양을 줄일 수 있습니다. 특히 데이터 요금제가 제한된 사용자에게 유용합니다.\n\n# URLCache 사용 방법\n\niOS 앱에서 URLCache를 사용하는 기본적인 단계를 살펴보겠습니다:\n\n## 초기화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지정된 메모리 용량 및 디스크 용량으로 URLCache 인스턴스를 초기화할 수 있어요:\n\n```js\nlet memoryCapacity = 4 * 1024 * 1024 // 4 MB\nlet diskCapacity = 100 * 1024 * 1024 // 100 MB\nlet urlCache = URLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: \"myCache\")\nURLCache.shared = urlCache // 공유 캐시로 설정\n```\n\n## 네트워크 요청 만들기\n\nURLSession을 사용하여 네트워크 요청을 만들 때 URLRequest에 지정된 캐싱 정책을 기반으로 URLCache가 자동으로 캐싱을 처리해 줘요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet url = URL(string: \"https://api.example.com/data\")!\nvar request = URLRequest(url: url)\nrequest.cachePolicy = .returnCacheDataElseLoad // 사용 가능한 캐시 데이터 사용\nlet task = URLSession.shared.dataTask(with: request) { data, response, error in\n    // 응답 처리\n}\ntask.resume()\n```\n\n## 캐싱 정책 이해하기\n\nURLCache는 응답을 저장하고 캐시에서 검색하는 방법을 지정하는 여러 가지 캐싱 정책을 제공합니다. 일반적인 캐싱 정책에 대해 알아보겠습니다:\n\n- .CachePolicy.useProtocolCachePolicy: 이 정책은 서버에서 보낸 캐싱 헤더를 기반으로 응답이 캐시되어야 하는지를 결정합니다. 서버가 Cache-Control 또는 Expires와 같은 캐싱 헤더를 지정하면 URLCache는 해당 지침을 따릅니다.\n- .CachePolicy.reloadIgnoringLocalCacheData: 이 정책을 사용하면 URLCache는 항상 로컬로 캐시된 응답을 무시하고 데이터를 직접 서버에서 가져옵니다.\n- .CachePolicy.returnCacheDataElseLoad: 이 정책은 사용 가능한 캐시된 응답을 반환하거나 네트워크에서 데이터를 가져옵니다. 앱 성능을 향상시키면서 데이터 신선도를 보장하는 데 흔히 사용되는 정책입니다.\n- .CachePolicy.returnCacheDataDontLoad: 이 정책은 캐시된 응답을 반환하되, 캐시된 데이터가 없으면 네트워크에서 데이터를 가져오지 않습니다. 오프라인으로 캐시된 데이터에 액세스할 수 있는 시나리오에 유용합니다.\n- .CachePolicy.reloadIgnoringCacheData: 이 정책을 사용하면 URLCache는 캐시된 응답을 무시하고 데이터를 항상 네트워크에서 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 응답 캐싱\n\n이제 URLCache를 사용하여 응답을 캐싱하는 방법을 살펴보겠습니다:\n\n```js\nlet url = URL(string: \"https://api.example.com/data\")!\nlet request = URLRequest(url: url)\n        \nURLSession.shared.dataTask(with: request) { data, response, error in\n    guard let data = data, let httpResponse = response as? HTTPURLResponse, error == nil else {\n        // 오류 처리\n        return\n    }\n    \n    if httpResponse.statusCode == 200 {\n        let cachedResponse = CachedURLResponse(response: httpResponse, data: data)\n        URLCache.shared.storeCachedResponse(cachedResponse, for: request)\n        \n        // 데이터가 이제 캐싱되었습니다\n    }\n}.resume()\n```\n\n이 코드 샘플에서는 지정된 URL에서 데이터를 가져오기 위해 데이터 작업을 시작합니다. 성공적인 응답(상태 코드 200)을 받은 경우, 응답과 데이터를 캡슐화하는 CachedURLResponse 객체를 생성합니다. 그런 다음 이 응답을 미래 사용을 위해 캐시에 저장하기 위해 URLCache.shared.storeCachedResponse(_:for:)를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캐싱 정책을 이해하고 URLCache를 사용하여 응답을 캐시하는 방법을 알면 iOS 개발자는 네트워크 요청을 최적화하고 앱 성능을 향상시키기 위해 캐싱 메커니즘을 효과적으로 활용할 수 있습니다.\n\n## 사용자 정의\n\ncachedResponse(for:) 및 storeCachedResponse(_:for:)와 같은 메서드를 서브클래싱하고 오버라이딩하여 URLCache 동작을 사용자 정의할 수 있습니다. 이를 통해 앱 요구 사항에 맞는 사용자 정의 캐싱 전략을 구현할 수 있습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nURLCache는 iOS 앱에서 네트워크 응답을 캐시하는 강력한 도구로, 다양한 캐싱 정책을 제공하여 다양한 요구 사항에 맞게 사용할 수 있습니다. 캐싱 정책을 숙지하고 캐싱 전략을 효과적으로 구현함으로써, 개발자들은 보다 부드럽고 반응성 있는 사용자 경험을 제공하는 앱을 만들 수 있습니다. iOS 프로젝트에서 캐싱을 실험해보고 URLCache를 최대한 활용해보세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-22-URLCacheiniOSABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-06-22-URLCacheiniOSABeginnersGuide_0.png","tag":["Tech"],"readingTime":5},{"title":"Swift에서 weak와 unowned의 차이점 예제 포함","description":"","date":"2024-06-22 23:14","slug":"2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png\" /\u003e\n\n# 소개\n\nSwift에서는 메모리 관리가 ARC(Automatic Reference Counting)를 통해 이루어집니다. weak 및 unowned 참조의 주요 개념을 이해하는 것은 메모리 누수와 강한 참조 순환을 방지하는 데 매우 중요합니다. 이러한 참조들이 어떻게 다르며 올바르게 사용하는 방법을 알아보겠습니다.\n\n# weak 참조\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n약한 참조는 한 객체가 다른 객체 없이 존재할 수 있을 때 사용됩니다. 이는 객체의 참조 카운트를 증가시키지 않아 강력한 참조 순환을 방지하는 데 도움이 됩니다.\n\n약한 참조의 특징:\n- 가리키는 객체가 해제될 수 있기 때문에 항상 옵셔널 변수(var)로 선언됩니다. 이 경우에 참조는 nil이 됩니다.\n- 델리게이트와 클로저를 사용할 때 메모리 누수를 방지하는 데 특히 유용합니다.\n\n약한 참조를 사용한 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nclass Department {\n    var manager: Employee?\n\n    deinit {\n        print(\"Department is being deinitialized\")\n    }\n}\n\nclass Employee {\n    weak var department: Department?\n\n    deinit {\n        print(\"Employee is being deinitialized\")\n    }\n}\n\nvar department: Department? = Department()\nvar manager: Employee? = Employee()\n\ndepartment?.manager = manager\nmanager?.department = department\n\ndepartment = nil\nmanager = nil\n// Prints: \"Employee is being deinitialized\" and then \"Department is being deinitialized\"\n\n```\n\n이 예시에서, Department와 Employee간의 연결을 끊음으로써 메모리 누수를 피할 수 있습니다.\n\n## 클로저에서 weak 사용\n\n클로저에서 weak를 사용하는 것은 강한 참조 순환을 방지하기 위해 종종 필요한데, 특히 클로저가 self, 즉 클래스 인스턴스를 캡처할 때입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nViewController 클래스는 비동기 작업을 수행하는 클래스입니다. 이 작업이 완료된 후에 코드가 실행되도록 하고, 동시에 강한 참조 순환에 의한 메모리 누수를 방지해야 합니다.\n\nweak 키워드를 사용한 예시:\n\n```js\nclass ViewController: UIViewController {\n    var dataLoader: DataLoader?\n\n    func fetchData() {\n        dataLoader?.loadData(completion: { [weak self] result in\n            guard let self = self else { return }\n\n            switch result {\n            case .success(let data):\n                self.updateUI(with: data)\n            case .failure(let error):\n                self.showErrorMessage(error)\n            }\n        })\n    }\n\n    private func updateUI(with data: Data) {\n        // 사용자 인터페이스 업데이트\n    }\n\n    private func showErrorMessage(_ error: Error) {\n        // 에러 메시지 표시\n    }\n}\n\nclass DataLoader {\n    func loadData(completion: @escaping (Result\u003cData, Error\u003e) -\u003e Void) {\n        // 데이터 로드 코드\n    }\n}\n```\n\n위 예시에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ViewController에는 DataLoader의 loadData 메서드를 호출하는 fetchData 메서드가 있습니다.\n- loadData에 전달된 클로저 내에서 [weak self]를 사용하여 ViewController의 인스턴스인 self에 강한 참조를 방지합니다. 이는 DataLoader가 클로저를 오랫동안 유지할 수 있기 때문에 중요합니다. 예를 들어 비동기 작업 중에 발생할 수 있습니다.\n- 클로저 내에서 self에 안전하게 액세스하기 위해 guard let self = self else 'return'을 사용합니다. 만약 ViewController가 클로저가 실행되기 전에 해제되면 self는 nil이 되어 클로저 내의 코드가 실행되지 않아 잠재적인 오류나 충돌을 방지합니다.\n\n# unowned 참조\n\nunowned 참조는 weak와 유사하지만 두 가지 주요 차이점이 있습니다: 옵셔널이 아니며, 가리키는 객체가 해제될 때 nil이 되지 않습니다.\n\n## unowned 참조의 특징:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다른 객체가 해제되기 전까지 한 객체를 해제하지 않을 때 사용됩니다.\n- 객체가 해제된 후 비소유 참조에 접근하면 충돌이 발생합니다.\n- 상수(let)와 함께만 작동합니다.\n\n비소유 참조를 사용한 예시:\n\n```js\nclass Customer {\n    let name: String\n    var card: CreditCard?\n    \n    init(name: String) {\n        self.name = name\n    }\n\n    deinit {\n        print(\"\\(name) 해제 중\")\n    }\n}\n\nclass CreditCard {\n    let number: UInt64\n    unowned let customer: Customer\n\n    init(number: UInt64, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n\n    deinit {\n        print(\"카드 #\\(number) 해제 중\")\n    }\n}\n\nvar john: Customer? = Customer(name: \"John\")\njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)\n\njohn = nil\n// 출력: \"John 해제 중\" 그리고 \"카드 #1234567890123456 해제 중\" \n```\n\n여기서 Customer가 해제된 후 관련된 CreditCard 객체도 해제되어 메모리 누수를 방지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 약한 참조와 미소유 참조 비교\n\n- 선언: 약한 참조는 항상 옵셔널이지만, 미소유 참조는 상수로 값이 옵셔널이 아닙니다.\n- 강한 참조 순환: 둘 다 강한 참조 순환을 방지하지만, 각각 다른 상황에서 사용됩니다.\n- 안전성: 약한 참조는 객체가 해제될 때 자동으로 nil이 되어 안전합니다. 미소유 참조는 객체가 파괴되면 크래시가 발생할 수 있습니다. 무엇을 하는지 잘 알아야 합니다.\n\n# 결론\n\nSwift에서 약한 참조와 미소유 참조의 차이를 이해하는 것은 안전하고 효율적인 메모리 관리를 위해 중요합니다. 두 참조 사이의 선택은 애플리케이션의 구조와 객체 간 관계에 따라 다릅니다. 항상 메모리 누수를 확인하여 신뢰성과 성능을 보증할 수 있도록 코드를 테스트하세요.","ogImage":{"url":"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png"},"coverImage":"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png","tag":["Tech"],"readingTime":4},{"title":"4단계로 iOS 앱에 실시간 활동 추가하는 방법","description":"","date":"2024-06-22 23:13","slug":"2024-06-22-AddLiveActivitiestoyouriOSappin4steps","content":"\n\n## iOS에서 라이브 액티비티로 사용자 경험과 실시간 상호작용 향상\n\n이미 라이브 액티비티를 앱에 통합하지 않았다면, 이제 강력한 잠재력을 고려해보는 것이 좋습니다.\n\n라이브 액티비티는 호환되는 아이폰의 잠금 화면과 다이나믹 아일랜드에 자연스럽게 나타나는 전용 UI로, 이 기능을 활용하면 사용자가 앱의 주요 부분을 벗어나도 사용자와 상호작용을 유지할 수 있습니다.\n\n푸시 알림을 보내지 않고 업데이트를 보내거나 실시간 정보를 표시할 수 있습니다. 그리고 가장 좋은 점은? 이를 추가하는 것이 놀랍도록 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 그것을 하는 방법이 있어요.\n\n![image1](/assets/img/2024-06-22-AddLiveActivitiestoyouriOSappin4steps_0.png)\n\n![image2](https://miro.medium.com/v2/resize:fit:460/1*RqsG45Gbo625UNKcIUElTQ.gif)\n\n## 단계1 — 라이브 활동 콘텐츠 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 처음으로 할 일은 라이브 활동에서 보여줄 정보를 정의하는 것입니다. 제한된 공간 때문에 사용자가 중요하게 생각할 데이터에 집중해야 합니다.\n\n그 생각을 기억하고 다음으로 할 일은 ActivityAttributes 프로토콜을 구현하는 것입니다.\n\n```js\npublic protocol ActivityAttributes : Decodable, Encodable {\n\n    /// 라이브 활동의 동적 콘텐츠를 설명하는 연관 타입.\n    ///\n    /// `ContentState`로 인코딩된 라이브 활동의 동적 데이터는 4KB를 초과할 수 없습니다.\n    associatedtype ContentState : Decodable, Encodable, Hashable\n}\n```\n\n알 수 있듯이, 우리는 정보를 두 가지 범주로 나눌 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 정적 → ActivityAttributes를 구현하는 모델의 속성입니다.\n- 동적 → ContentState 타입에 저장됩니다.\n\n우리 경우에는 다음과 같이 정보를 정리할 수 있습니다:\n\n- 정적 → 주문 번호입니다. 사용자가 주문을 하면 번호가 바뀌지 않습니다.\n- 동적 → 주문 상태로, 주문의 현재 단계를 나타냅니다.\n\n```js\nstruct OrderAttributes: ActivityAttributes {\n    \n    struct ContentState: Codable, Hashable {\n        enum OrderStatus: Float, Codable, Hashable {\n            case inQueue = 0\n            case aboutToTake\n            case making\n            case ready\n            \n            var description: String {\n                switch self {\n                case .inQueue:\n                    return \"주문이 대기 중입니다\"\n                case .aboutToTake:\n                    return \"주문을 받을 준비 중입니다\"\n                case .making:\n                    return \"주문을 준비 중입니다\"\n                case .ready:\n                    return \"주문이 수령 가능합니다!\"\n                }\n            }\n        }\n        \n        let status: OrderStatus\n    }\n    \n    let orderNumber: Int\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 2 — UI 생성하기\n\n라이브 활동 UI는 앱의 위젯 범위에 있습니다. 따라서 앱에 위젯 확장 기능이 없는 경우, 먼저 하나를 생성해야 합니다.\n\n새로운 위젯 뷰를 생성하고 위젯 구현에서 ActivityConfiguration의 인스턴스를 반환합니다. 이전 단계에서 만든 ActivityAttributes 모델을 사용해야 합니다.\n\n```js\nstruct CoffeeShopWidgetLiveActivity: Widget {\n    \n    var body: some WidgetConfiguration {\n        ActivityConfiguration(for: OrderAttributes.self) { context in\n            // 여기에 잠금 화면/배너 UI가 들어갑니다\n            LiveActivityView(state: context.state)\n        } dynamicIsland: { context in\n            // 동적 아일랜드 구현이 이곳에 들어갑니다\n            // 이 기사의 범위를 벗어난 내용입니다\n             ...\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLiveActivityView 내에서는 Live Activity UI를 구성합니다.\n\n```js\nstruct LiveActivityView: View { \n    let state: OrderAttributes.ContentState\n   \n    var body: some View {\n        VStack {\n            HStack {\n                Image(systemName: \"cup.and.saucer\")\n                ProgressView(value: state.status.rawValue, total: 3)\n                    .tint(.black)\n                    .background(Color.brown)\n                Image(systemName: \"cup.and.saucer.fill\")\n            }\n            .padding(16)\n            \n            Text(\"\\(state.status.description)\")\n                .font(.system(size: 18, weight: .semibold))\n                .padding(.bottom)\n            Spacer()\n        }\n        .background(Color.brown.opacity(0.6))\n    }\n}\n```\n\n마지막으로, Live Activity 위젯을 위한 위젯 번들에 추가해야 합니다. 이 경우, 위젯을 제공하지 않을 것이므로 Live Activity만 사용합니다.\n\n```js\n@main\nstruct CoffeeShopWidgetBundle: WidgetBundle {\n    var body: some Widget {\n        CoffeeShopWidgetLiveActivity()\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 3 — 라이브 활동 초기화\n\n라이브 활동과 상호 작용하는 데는 ActivityKit API를 사용해야 합니다.\n\n먼저, ActivityContent의 생성자인 init(state:staleDate:relevanceScore:)를 사용하여 라이브 활동의 초기 내용을 만들어야 합니다.\n\n- state: 라이브 활동에 대한 초기 ActivityAttributes.ContentState입니다.\n- staleDate: 라이브 활동이 오래되었음을 OS에 알리기 위한 날짜입니다. staleDate가 지정되지 않으면, 8시간 후 OS가 라이브 활동을 종료합니다.\n- relevanceScore: 여러 개의 라이브 활동이 있는 경우, relevanceScore는 다이나믹 아일랜드에 표시할 우선순위와 잠금 화면의 순서를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 Activity 메서드 request(attributes: content: pushType:)를 호출하여 새로운 라이브 액티비티를 요청할 수 있어요.\n\n- attributes: Step 1에서 생성한 ActivityAttributes의 인스턴스입니다.\n- content: 라이브 액티비티의 초기 콘텐츠입니다.\n- pushType: 라이브 액티비티의 업데이트가 ActivityKit 푸시 알림에서 올 것인지를 나타냅니다. 업데이트 기능만 사용할 경우에는 nil을 전달할 수 있어요.\n\n📣 중요한 알림: 새로운 Activity를 요청할 때 앱은 활성화 상태여야 해요.\n\n```js\nlet orderAttributes = OrderAttributes(orderNumber: 1)    \nlet initialState = OrderAttributes.ContentState(status: .inQueue)\nlet content = ActivityContent(state: initialState, staleDate: nil, relevanceScore: 1.0)\n\ndo {\n    let orderActivity = try Activity.request(\n        attributes: orderAttributes,\n        content: content,\n        pushType: nil\n    )\n} catch {\n    print(error.localizedDescription)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 4 — 라이브 활동 업데이트\n\n라이브 활동을 업데이트하려면 update(_:) 함수를 사용할 수 있습니다. 초기 상태를 생성한 것과 마찬가지로 업데이트로 ActivityContent를 작성할 수 있습니다.\n\n```js\nawait orderActivity?.update(\n    ActivityContent\u003cOrderAttributes.ContentState\u003e(\n        state: state,\n        staleDate: nil\n    )\n)\n```\n\n라이브 활동을 종료하려면 end(_:dismissalPolicy:) 함수를 사용합니다. 사용하는 종료 정책에 따라 라이브 활동은 사용자가 명시적으로 제거할 때까지 잠금 화면에 남게될 수 있습니다. 이것이 마지막 라이브 활동 상태를 전달하여 UI를 항상 최신 상태로 유지해야하는 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용 가능한 해제 정책 옵션은 세 가지입니다.\n\n- default: 라이브 액티비티는 최대 4시간 동안 잠금 화면에 유지됩니다. (사용자가 제거할 때까지)\n- immediate: 운영 체제가 즉시 라이브 액티비티를 제거합니다.\n- after(_ date:): 라이브 액티비티를 해제할 날짜를 지정할 수 있습니다. (라이브 액티비티 종료 시간으로부터 4시간 이내여야 함)\n\n# 다음 단계는 무엇인가요?\n\n앱의 사용 사례를 신중하게 고려해보세요. 라이브 액티비티는 배송 앱이나 스포츠 이벤트와 같은 실시간 애플리케이션에 특히 적합하지만, 푸시 알림에 대한 매력적인 대안으로도 사용될 수 있어 사용자에게 더 매력적인 경험을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 풍부한 사용자 경험을 위해 라이브 활동에 딥 링크를 통합하여 사용자가 라이브 활동을 탭할 때 연결이 원활하도록 할 수 있습니다.\n\n질문이 있으시면 언제든지 메시지 남겨주세요! 🙂\n\n- 🤓 iOS 개발 팁과 통찰을 정기적으로 제공하는 제 트위터에 참여해보세요.\n- 🚀 나의 예제 프로젝트를 모두 공유하는 GitHub를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-22-AddLiveActivitiestoyouriOSappin4steps_0.png"},"coverImage":"/assets/img/2024-06-22-AddLiveActivitiestoyouriOSappin4steps_0.png","tag":["Tech"],"readingTime":6}],"page":"8","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"8"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>