<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/13" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/13" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드" href="/post/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">28<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="쿠버네티스 명령어 명령형 vs 선언형 비교" href="/post/2024-06-23-ImperativevsDeclarativeKubernetesCommands"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="쿠버네티스 명령어 명령형 vs 선언형 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ImperativevsDeclarativeKubernetesCommands_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="쿠버네티스 명령어 명령형 vs 선언형 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">쿠버네티스 명령어 명령형 vs 선언형 비교</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법" href="/post/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유" href="/post/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기" href="/post/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법" href="/post/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법" href="/post/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ubuntu 2204에 Docker Desktop 설치하는 방법" href="/post/2024-06-23-HowToInstallDockerDesktoponUbuntu2204"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ubuntu 2204에 Docker Desktop 설치하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ubuntu 2204에 Docker Desktop 설치하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Ubuntu 2204에 Docker Desktop 설치하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Docker 볼륨 이해하기 완벽 가이드" href="/post/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker 볼륨 이해하기 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker 볼륨 이해하기 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Docker 볼륨 이해하기 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것" href="/post/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link posts_-active__YVJEi" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드","description":"","date":"2024-06-23 23:03","slug":"2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide","content":"\n최근 몇 년간 데이터 엔지니어링이 크게 발전하였는데, Kubernetes가 이 분야에서 중요한 기술로 부상하였습니다. Kubernetes는 확장 가능하고 효율적인 애플리케이션 배포를 포함한 데이터 파이프라인 및 워크플로우의 효율적인 구축과 관리를 지원하는 오픈 소스 컨테이너 오케스트레이션 플랫폼입니다. 이 글에서는 Docker에서 Kubernetes 설정, kubectl로 클러스터 관리, Kubernetes 대시보드 배포, 그리고 Helm 차트를 사용해 Apache Airflow를 실행하는 방법에 대해 알아보겠습니다.\n\n![KubernetesforDataEngineeringAnEnd-to-EndGuide_0](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_0.png)\n\n# Kubernetes란 무엇인가요?\n\nKubernetes는 K8s로 약칭되며, 애플리케이션 컨테이너를 자동으로 배포, 확장 및 운영하기 위해 설계된 오픈 소스 플랫폼입니다. 원래 구글에서 개발되었으며 현재는 Cloud Native Computing Foundation에서 유지보수하고 있습니다. Kubernetes는 견고한 기능과 광범위한 커뮤니티 지원으로 컨테이너 오케스트레이션의 표준으로 자리매깁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쿠버네티스의 핵심 개념\n\n쿠버네티스를 이해하기 위해 그 핵심 개념을 살펴보겠습니다:\n\n- 컨테이너: 쿠버네티스는 컨테이너화를 기반으로 구축되어 있습니다. 컨테이너는 응용 프로그램을 모든 종속성과 실행 환경과 함께 패키징합니다. 이는 다양한 개발, 테스트 및 프로덕션 환경에서 일관성을 유지합니다.\n- 파드: 쿠버네티스에서 가장 작은 배포 가능한 단위입니다. 파드는 하나 이상의 컨테이너를 포함할 수 있으며, 이 컨테이너들은 저장소, 네트워크 및 실행 방법에 대한 사양을 공유합니다. 파드는 순간적이고 임시적입니다.\n- 노드: 쿠버네티스에서의 워커 머신으로서, 물리적 또는 가상 머신이 될 수 있습니다. 각 노드는 파드를 실행하고, 마스터 노드에 의해 관리됩니다. 노드에는 파드를 실행하기 위한 필요한 서비스가 포함되어 있으며, 컨트롤 플레인에 의해 관리됩니다.\n- 컨트롤 플레인: 쿠버네티스 노드를 제어하는 프로세스들의 모음입니다. 모든 작업 할당은 여기에서 시작됩니다. 컨트롤 플레인의 구성 요소들은 클러스터에 대한 전역 결정(예: 스케줄링)을 내리고, 클러스터 이벤트(예: 배포의 레플리카 필드가 충족되지 않았을 때 새로운 파드 시작)를 감지하고 대응합니다.\n- 서비스: 쿠버네티스 서비스는 논리적인 일련의 파드와 그에 대한 액세스 정책을 정의하는 추상화 계층입니다. 이는 일부 파드에 네트워크 액세스를 제공하는 데 자주 사용됩니다.\n- 배포: 파드 및 레플리카셋에 대한 선언적 업데이트를 관리하는 고수준 개념입니다. 배포는 파드에 대한 템플릿을 사용하고 파드 수, 롤링 업데이트 전략 및 원하는 상태에 대한 제어 매개변수를 확장합니다.\n\n만일 전체 비디오에 관심이 있으시다면, [여기](#)를 클릭해서 보실 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데이터 엔지니어링에서 Kubernetes 이해하기\n\n실제 측면에 들어가기 전에, 데이터 엔지니어링에서 Kubernetes가 왜 게임 체인저인지 이해하는 것이 중요합니다:\n\n- 확장성: Kubernetes는 수요에 따라 데이터 처리 워크로드를 자동으로 확장할 수 있습니다.\n- 내구성: 실패를 효과적으로 관리하여 데이터 파이프라인의 높은 가용성을 보장합니다.\n- 자원 최적화: Kubernetes는 기본 리소스의 사용을 최적화하여 비용을 절감합니다.\n- 이식성과 일관성: 서로 다른 배포 플랫폼에서도 일관된 환경을 제공합니다.\n\n# 연결 기술은 어떨까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 Kubernetes 클러스터를 관리하고 제어하며 데이터 엔지니어링 프로세스를 용이하게 하기 위해 Kubernetes와 함께 사용될 다른 기술들에 대해 이야기해보려고 해요. 이 기술들은 Docker, Kubectl, Helm 등을 포함합니다.\n\n## Docker\n\nDocker는 컨테이너 내에서 애플리케이션을 개발, 배포 및 실행하는 플랫폼입니다. 컨테이너화는 애플리케이션을 해당 애플리케이션만을 위한 자체 운영 환경과 함께 컨테이너에 묶는 완전한 가상화의 가벼운 대안입니다.\n\n- 컨테이너: 애플리케이션의 코드, 구성 및 종속성을 하나의 객체로 패키징하는 표준 방법을 제공합니다.\n- 이미지: 코드, 런타임, 라이브러리, 환경 변수 및 구성 파일 등 애플리케이션을 실행하는 데 필요한 모든 것이 포함된 실행 가능한 패키지입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쿠버네티스 클러스터 관리\n\n쿠버네티스 클러스터를 관리하는 것은 각각이 클러스터의 라이프사이클 및 운영에 특정 목적을 제공하는 다양한 도구와 기술을 포함합니다. 저는 쿠버네티스 클러스터를 제어하고 관리하는 데 널리 사용되는 세 가지 주요 기술을 강조하기로 결정했습니다.\n\n## 1. kubectl\n\n- 목적: kubectl은 쿠버네티스 API와 상호 작용하는 명령줄 도구입니다. 이는 쿠버네티스 클러스터를 관리하는 주요 인터페이스입니다.\n- 기능: 애플리케이션을 배포하고 클러스터 리소스를 검사하고 관리하며 로그를 보고 팟에서 명령을 실행하는 등의 기능을 제공합니다.\n- 사용법: kubectl 명령은 간단합니다. 예를 들어, kubectl get pods는 현재 네임스페이스의 모든 팟을 나열하거나 kubectl apply -f deployment.yaml은 파일에서 구성을 적용하는 것과 같은 명령입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 미니큐브\n\n- 목적: 미니큐브는 쿠버네티스를 로컬에서 실행할 수 있게 해주는 도구입니다. 로컬 머신에서 단일 노드 쿠버네티스 클러스터를 생성합니다.\n- 사용 사례: 개발 및 테스트 목적으로 이상적입니다. 개발자들이 자신의 머신에서 쿠버네티스 환경에서 애플리케이션을 테스트할 수 있도록 합니다.\n- 특징: DNS, 노드 포트, 구성 맵 및 시크릿, 대시보드, 컨테이너 런타임 등 다양한 쿠버네티스 기능을 지원합니다.\n\n## 3. 쿠버엠톰\n\n- 목적: 쿠버엠톰은 쿠버네티스 클러스터를 생성하고 관리하기 위해 kubeadm init 및 kubeadm join을 제공하는 도구입니다.\n- 기능: 쿠버네티스 클러스터의 부트스트래핑, 제어 플레인 설정, 토큰 관리, kubeadm 설정 등을 처리합니다.\n- 사용법: 일반 클러스터 설정 과정을 간소화하여, 쿠버네티스에 처음 입문하는 사람들도 접근하기 쉽게 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 문서에서는 kubectl을 사용할 것입니다. 귀하의 운영 체제 및 버전을 선택하여 기기에 설치할 수 있습니다.\n\n만약 minikube 또는 kubeadm을 사용하여 Kubernetes 클러스터를 관리하고 싶다면, 각각 여기와 여기의 빠른 시작 가이드를 따를 수 있습니다.\n\n설치가 완료된 후에는 다음을 실행하여 설치를 확인할 수 있습니다.\n\n```js\nkubectl version\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 경우에는 kubectl 버전 1.29.1을 실행 중입니다. 당신이 프로세스를 실행하는 시기에 따라 더 높을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_1.png)\n\n# Docker에서 Kubernetes 설정하기\n\nDocker에서 Kubernetes를 설정하는 것은 Docker가 컨테이너화된 애플리케이션을 실행하는 로컬 Kubernetes 클러스터를 생성하는 과정을 포함합니다. 이 설정은 개발 및 테스트 목적으로 특히 유용합니다. Docker에서 Kubernetes를 설정하는 단계별 가이드는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 준비 사항\n\n- 도커: 시스템에 도커가 설치되어 있는지 확인해주세요. Windows 및 Mac용 도커 데스크톱은 쿠버네티스 지원이 기본 내장되어 있습니다.\n- 하드웨어 요구 사항: 여러 컨테이너를 실행하기 위한 충분한 CPU, 메모리 및 저장 공간이 필요합니다.\n\n# 설정 단계\n\n## 1. 도커 데스크톱 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다운로드 및 설치: 공식 Docker 웹사이트에서 Docker Desktop을 다운로드하세요. 제공된 지침을 따라 컴퓨터에 설치해주세요.\n- Kubernetes 활성화: Docker Desktop에는 로컬 컴퓨터에서 실행되는 독립형 Kubernetes 서버가 포함되어 있습니다. 이를 활성화하기 전에 초기 기본 구성에서 리소스를 약간 늘려주어야 합니다.\n\n![이미지](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_2.png)\n\nDocker Desktop에서 Kubernetes 활성화 방법:\n\n- Docker Desktop 설정을 엽니다.\n- Kubernetes 섹션을 찾습니다.\n- “Kubernetes 활성화”란에 체크합니다.\n- 변경사항을 저장하려면 “적용 및 다시 시작”을 클릭합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 변경하겠습니다.\n\n![이미지](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_3.png)\n\n## 2. 설치 확인\n\n- 도커 확인: 터미널이나 명령 프롬프트를 열고 docker --version을 실행하여 도커가 올바르게 설치되었는지 확인합니다.\n\n## 3. 쿠버네티스 컨텍스트 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 쿠버네티스는 서로 다른 클러스터에 액세스하기 위해 컨텍스트를 사용합니다. 도커 데스크탑은 docker-desktop이라는 컨텍스트를 설정합니다.\n- 이 컨텍스트로 전환하려면 kubectl config use-context docker-desktop을 사용하십시오.\n\n# PC에 헬름 차트 설치하는 방법\n\n## macOS용:\n\n- Homebrew: Homebrew를 설치한 경우, 간단히 다음을 실행할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nbrew install helm\n```\n\n## Windows 사용자분들을 위해:\n\n- Chocolatey를 사용하는 경우, 다음 명령어를 실행하여 Helm을 설치할 수 있습니다:\n\n```js\nchoco install kubernetes-helm\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 리눅스용:\n\n- 스크립트: Helm은 리눅스 사용자를 위한 자동화된 스크립트를 제공합니다. 다음을 실행하세요:\n\n```js\ncurl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n```\n\n만약 다른 버전의 운영 체제, 패키지 관리자를 원하시거나 소스에서 직접 빌드하고 싶다면 공식 가이드의 지침을 따를 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n헬름이 컴퓨터에 설치되면 다음을 실행하여 설치를 확인할 수 있습니다:\n\n```js\nhelm version\n```\n\n아래 스크린샷과 유사한 내용이 표시됩니다. 저의 경우에는 헬름 3.14.0을 실행하고 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Kubernetes 대시보드 배포하기\n\nKubernetes 대시보드는 Kubernetes 클러스터를 관리하는 사용자 친화적인 웹 기반 인터페이스를 제공합니다. 클러스터 리소스와 애플리케이션을 보고 관리할 수 있으며 기본적인 문제 해결 기능도 제공합니다. Kubernetes 대시보드를 배포하는 방법은 다음과 같습니다:\n\n## 단계 1: 대시보드 배포하기\n\n- 배포 명령 실행: Kubernetes 대시보드를 배포하려면 kubectl을 사용하여 yaml 구성을 배포하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl apply -f https://raw.githubusercontent.com/airscholar/Kubernetes-For-DataEngineering/main/k8s/recommended-dashboard.yaml\n```\n\n이 명령은 Kubernetes 대시보드의 GitHub 저장소에서 권장 배포 구성을 다운로드하고 적용합니다. 보게 될 내용은 다음과 같아야 합니다.\n\n# 단계 2: 대시보드에 액세스하기\n\n- 프록시 시작: Kubernetes 대시보드는 프록시 서버를 통해 액세스됩니다. 다음 몤령을 사용하여 프록시를 시작합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl proxy\n```\n\n이 명령어를 실행하면 대시보드를 로컬 머신에서 URL을 통해 접속할 수 있습니다.\n\n![image](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_5.png)\n\n2. URL에 접속하세요: 웹 브라우저를 열고 다음 URL로 이동하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhttp://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/\n```\n\n이 URL은 Kubernetes 대시보드 인터페이스로 이동합니다.\n\n# 단계 3: 대시보드 인증하기\n\n- Bearer 토큰 받기: 대시보드에 로그인하려면 Bearer 토큰을 생성해야 합니다. 다음 단계를 따라 서비스 계정을 생성하고 토큰을 받을 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다음 내용으로 dashboard-adminuser.yaml이라는 파일을 생성하세요:\n\n```yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: admin-user\n  namespace: kubernetes-dashboard\n```\n\n- 다음 내용으로 dashboard-clusterrole.yaml이라는 파일을 생성하세요:\n\n```yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: admin-user\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n  - kind: ServiceAccount\n    name: admin-user\n    namespace: kubernetes-dashboard\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 그리고 마지막으로 아래 내용을 가진 dashboard-secret.yaml 파일을 생성해주세요.\n\n```js\napiVersion: v1\nkind: Secret\nmetadata:\n  name: admin-user\n  namespace: kubernetes-dashboard\n  annotations:\n    kubernetes.io/service-account.name: \"admin-user\"\ntype: kubernetes.io/service-account-token\n```\n\n이 구성을 적용하려면 다음 명령을 실행해야합니다.\n\n```js\nkubectl apply -f dashboard-adminuser.yaml\nkubectl apply -f dashboard-clusterrole.yaml\nkubectl apply -f dashboard-secret.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 대시보드에 액세스할 때 사용할 토큰을 생성하는 방법입니다:\n\n```js\nkubectl get secret admin-user -n kubernetes-dashboard -o jsonpath={\".data.token\"} | base64 -d\n```\n\n만약 CLI를 사용하는 것을 선호한다면, 대신에 다음 명령어를 실행할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- kube-system 네임스페이스에 서비스 계정을 생성해 주세요:\n\n```js\nkubectl create serviceaccount admin-user -n kubernetes-dashboard\n```\n\n- 서비스 계정을 클러스터 관리자 역할에 바인딩해 주세요:\n\n```js\nkubectl create clusterrolebinding admin-user --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:admin-user\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다음 명령을 사용하여 비밀을 가져오세요:\n\n```js\nkubectl get secret $(kubectl get serviceaccount admin-user -n kubernetes-dashboard -o jsonpath=\"{.secrets[0].name}\") -n kubernetes-dashboard -o jsonpath=\"{.data.token}\" | base64 --decode\n```\n\n그런 다음 대시보드에 로그인하려면 토큰을 사용하세요:\n\n## 단계 4: 대시보드 사용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 대시보드 탐색하기: 로그인하면 배포, 서비스 및 팟과 같은 Kubernetes 자원을 보거나 관리할 수 있습니다.\n- 자원 생성 및 수정: 대시보드 UI를 통해 직접 새로운 자원을 생성하거나 기존 자원을 수정할 수 있습니다.\n- 클러스터 및 애플리케이션 성능 모니터링: 대시보드를 통해 클러스터 전체 및 CPU 및 메모리 사용량을 포함한 개요를 제공합니다.\n\n모든 소셜 미디어 플랫폼에서 팔로우를 눌러주시고 지지를 보여주기 위해 박수를 보내고 댓글을 달아주세요.\n\n- Github: airscholar\n- Twitter: @YusufOGaniyu\n- LinkedIn: Yusuf Ganiyu\n- Youtube: CodeWithYu\n\n이제 Kubernetes 대시보드를 성공적으로 배포했으므로, 차례로 Kubernetes 클러스터에 Apache Airflow를 배포할 준비를 해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쿠버네티스 클러스터에 Apache Airflow 배포하기\n\n쿠버네티스 클러스터에 Apache Airflow를 배포하는 것은 강력한 스케줄링 및 워크플로우 관리 기능을 확장 가능한 환경에서 활용하는 훌륭한 방법입니다. Apache Airflow를 쿠버네티스에 배포하는 가장 효율적인 방법은 Helm을 사용하는 것입니다. Helm은 쿠버네티스 응용 프로그램의 설치 및 관리를 간소화하는 패키지 매니저입니다. 이제 함께 Apache Airflow를 쿠버네티스에 배포하는 과정을 살펴보겠습니다.\n\n## 요구 사항\n\n다음 요구 사항은 문제 없이 진행하기 위해 필요합니다. 이전 부분을 건너 뛰었다면, 계속 진행하기 전에 모든 것이 잘 작동하는지 다시 확인하는 것이 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 실행 중인 Kubernetes 클러스터가 필요합니다.\n- 로컬 머신에 Helm이 설치되어 있어야 합니다 (필요한 경우 Helm 설치 방법은 이전 지침을 참조하십시오).\n- Kubernetes 클러스터와 통신할 수 있도록 kubectl이 구성되어 있어야 합니다.\n\n## 단계 1: Airflow Helm Chart 저장소 추가\n\n먼저, Apache Airflow 공식 Helm 차트 저장소를 Helm 설치에 추가해야 합니다:\n\n```sh\nhelm repo add apache-airflow https://airflow.apache.org\nhelm repo update\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령어는 Airflow 리포지토리를 추가하고 로컬 Helm 차트 리포지토리 인덱스를 업데이트합니다.\n\n# 단계 2: Apache Airflow 설치\n\n다음 명령어로 Apache Airflow를 Helm 차트를 사용하여 설치할 수 있습니다:\n\n```js\nhelm install airflow apache-airflow/airflow --namespace airflow --create-namespace --debug\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- airflow은 릴리스 이름으로, 원하는대로 변경할 수 있습니다.\n- --namespace airflow는 Airflow를 설치할 Kubernetes 네임스페이스를 지정합니다. 네임스페이스가 존재하지 않는 경우, --create-namespace를 사용하여 생성하고 --debug를 사용하면 배포 단계를 볼 수 있습니다.\n\n이 명령은 웹 서버, 스케줄러 등 필요한 모든 구성 요소와 함께 Airflow를 배포합니다. 디버그 플래그가 있으면 Apache Airflow 릴리스를 배포하는 데 사용된 세부 정보, 구성 및 해당 값들을 볼 수 있습니다.\n\n배포 중에는 대기 중인 작업 및 해당 상태를 쿠버네티스 클러스터에서 볼 수 있습니다. 프로세스가 완료되면 작업은 대기열에서 제거되어 더 이상 보이지 않게 됩니다.\n\n재미있게도 Apache Airflow 릴리스는 완료되었지만 보통 localhost:8080으로 접근해도 여전히 접속할 수 없습니다. 이를 가능하게 하고 Apache Airflow 파드에 대한 연결을 처리하려면 아래 명령을 실행한 다음 UI에서 Apache Airflow 배포에 액세스해야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl port-forward svc/airflow-webserver 8080:8080 --namespace airflow\n```\n\n또한, 쿠버네티스 클러스터에서 Airflow 배포의 건강 상태를 확인하고 모니터링하는 것이 중요합니다. 모든 것이 잘 되고 준비되어 있는지 확인하기 위해 위의 네임스페이스를 airflow로 변경해주시면 워크로드 세부 정보를 볼 수 있습니다.\n\n이제 관리자 사용자 이름과 관리자 비밀번호로 Airflow UI에 액세스할 수 있습니다.\n\n화면 상단에 동적 웹서버 비밀 키에 관한 경고가 있는 경우 정적 웹서버 비밀 키를 사용하는 것이 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 동적 키 대신 정적 키 사용하는 이유\n\n개발 환경에서는 동적 웹 서버 비밀 키를 사용해도 상관없지만, 제품 환경에서는 정적 웹 서버 비밀 키를 사용하는 것이 강력히 권장됩니다. 그 이유는 다음과 같습니다:\n\n- 응용 프로그램 인스턴스 간의 일관성: 특히 쿠버네티스로 관리되는 제품 환경에서는 응용 프로그램이 여러 인스턴스로 확장될 수 있습니다. 각 인스턴스가 자체 동적 비밀 키를 생성하는 경우 세션, 쿠키 또는 기타 암호화된 데이터 처리에 일관성이 무너질 수 있습니다. 정적 키는 응용 프로그램의 모든 인스턴스가 데이터를 일관적으로 읽고 쓸 수 있도록 보장합니다.\n- 다시 시작 시 지속성: 웹 서버가 다시 시작될 때 새로운 동적 비밀 키를 생성하면 이전 키로 암호화된 모든 세션 및 쿠키가 무효화됩니다. 이는 갑자기 로그아웃되거나 세션 데이터를 잃어버린 사용자에게 혼란을 줄 수 있습니다. 정적 키는 다시 시작할 때 동일하게 유지되어 세션의 연속성을 유지합니다.\n- 보안 최상의 사례: 역설적으로 보일 수 있지만, 안전하게 저장된 정적 비밀 키를 사용하는 것이 동적으로 생성하는 것보다 보안상 더 안전할 수 있습니다. 완전히 무작위이고 안전한 키를 생성하는 것은 쉽지 않습니다. 잘못 생성된 동적 키가 선정된 정적 키보다 덜 안전할 수 있습니다.\n- 구성 관리: 정적 키는 안전한 구성 관리 관행을 통해 관리할 수 있습니다. 이는 HashiCorp Vault, AWS Secrets Manager 또는 Kubernetes Secrets와 같은 비밀 관리 시스템에 키를 저장하는 것을 포함합니다. 이렇게 하면 키가 코드나 안전하지 않은 구성에서 노출되지 않고 액세스를 엄격하게 제어할 수 있습니다.\n- 감사 및 규정 준수: 많은 규정 준수 환경에서는 비밀 키에 대한 감사 및 액세스 제어가 필요합니다. 정적 키를 사용하면 이러한 제어를 구현하고 누가 액세스 권한을 가지고 있는지 추적하는 것이 더 쉬워집니다.\n\n이를 해결하기 위해, Apache Airflow 릴리스에 웹 서버 비밀 키를 포함하여 재구성하겠습니다. 이를 위해 원하는 구성을 덮어쓸 values.yaml 파일을 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n키를 생성하는 다양한 방법이 있지만 가장 인기 있는 두 가지 방법을 강조하겠습니다:\n\n- 파이썬 암호화 라이브러리를 사용하여 키를 생성하는 간단한 코드를 작성할 수 있습니다.\n\n- 먼저, cryptography 라이브러리가 설치되어 있는지 확인하십시오:\n\n```js\npip install cryptography\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 그럼 당신의 Python 환경에서 다음 한 줄을 사용할 수 있어요:\n\n```js\npython -c \"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\"\n```\n\n2. airflow 페르네 키 사용:\n\n```js\n echo Fernet Key: $(kubectl get secret --namespace airflow\n airflow-fernet-key -o jsonpath=\"{.data.fernet-key}\" | base64 --decode)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한번 생성되면 다음과 같이 보일 것입니다. 이 값들로 values.yaml 파일을 업데이트할 수 있어요.\n\n```js\nfernetKey: aERBZE5MN3E0TjRjU2xzQWxCdTNIUks0WGFTZThoWXc=\nwebserverSecretKey: aERBZE5MN3E0TjRjU2xzQWxCdTNIUks0WGFTZThoWXc=\n```\n\n그런 다음 helm 차트 배포를 다시 업데이트하세요:\n\n```js\nhelm upgrade --install airflow apache-airflow/airflow --namespace airflow --create-namespace -f values.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI에서 변경 사항을 미리보기하면 경고 메시지가 사라진 것을 확인할 수 있습니다.\n\n# 쿠버네티스에서 Airflow의 DAG 연결\n\n쿠버네티스에 Apache Airflow를 성공적으로 배포한 후에 해야 할 다음 단계는 DAG를 해당 Airflow에 연결하는 것입니다.\n\n우리의 경우, GitHub 저장소에서 DAG를 Airflow에 연결하게 됩니다. 거기에 Airflow DAG 코드를 작성하고 커밋한 후에 해당 커밋으로부터 URL을 얻어 Kubernetes와 동기화할 것입니다. 아래에 제시된 대로 진행됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHere is the translation into Korean:\n\n```python\nfrom airflow import DAG\nfrom airflow.operators.bash_operator import BashOperator\nfrom datetime import datetime, timedelta\n\ndefault_args = {\n    'owner': 'datamasterylab.com',\n    'start_date': datetime(2024, 1, 25),\n    'catchup': False\n}\n\ndag = DAG(\n    'hello_world',\n    default_args=default_args,\n    schedule_interval=timedelta(days=1)\n)\n\nt1 = BashOperator(\n    task_id='hello_world',\n    bash_command='echo \"Hello World\"',\n    dag=dag\n)\n\nt2 = BashOperator(\n    task_id='hello_dml',\n    bash_command='echo \"Hello Data Mastery Lab\"',\n    dag=dag\n)\n\nt1 \u003e\u003e t2\n\n```\n\n```python\nfrom datetime import datetime, timedelta\n\nfrom airflow import DAG\nfrom airflow.operators.python_operator import PythonOperator\n\n\ndef get_data(**kwargs):\n    import requests\n    import pandas as pd\n\n    url = 'https://raw.githubusercontent.com/airscholar/ApacheFlink-SalesAnalytics/main/output/new-output.csv'\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        df = pd.read_csv(url, header=None, names=['Category', 'Price', 'Quantity'])\n\n        # 데이터프레임을 JSON 문자열로 변환하여 xcom으로 전달\n        json_data = df.to_json(orient='records')\n\n        kwargs['ti'].xcom_push(key='data', value=json_data)\n    else:\n        raise Exception(f'데이터를 가져오는 데 실패했습니다. HTTP 상태 코드: {response.status_code}')\n\n\ndef preview_data(**kwargs):\n    import pandas as pd\n    import json\n\n    output_data = kwargs['ti'].xcom_pull(key='data', task_ids='get_data')\n    print(output_data)\n    if output_data:\n        output_data = json.loads(output_data)\n    else:\n        raise ValueError('XCom으로부터 데이터를 받지 못했습니다.')\n\n    # JSON 데이터에서 데이터프레임 생성\n    df = pd.DataFrame(output_data)\n\n    # 총 판매량 계산\n    df['Total'] = df['Price'] * df['Quantity']\n\n    df = df.groupby('Category', as_index=False).agg({'Quantity': 'sum', 'Total': 'sum'})\n\n    # 총 판매량을 기준으로 정렬\n    df = df.sort_values(by='Total', ascending=False)\n\n    print(df[['Category', 'Total']].head(20))\n\n\ndefault_args = {\n    'owner': 'datamasterylab.com',\n    'start_date': datetime(2024, 1, 25),\n    'catchup': False\n}\n\ndag = DAG(\n    'fetch_and_preview',\n    default_args=default_args,\n    schedule_interval=timedelta(days=1)\n)\n\nget_data_from_url = PythonOperator(\n    task_id='get_data',\n    python_callable=get_data,\n    dag=dag\n)\n\npreview_data_from_url = PythonOperator(\n    task_id='preview_data',\n    python_callable=preview_data,\n    dag=dag\n)\n\nget_data_from_url \u003e\u003e preview_data_from_url\n\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 commited된 저장소는 다음과 같습니다:\n\n```js\nhttps://github.com/airscholar/Kubernetes-For-DataEngineering.git\n```\n\n이제 우리의 values.yaml 파일로 돌아가서 저장소와 동기화할 값을 업데이트해봅시다.\n\n```js\nfernetKey: aERBZE5MN3E0TjRjU2xzQWxCdTNIUks0WGFTZThoWXc=\nwebserverSecretKey: aERBZE5MN3E0TjRjU2xzQWxCdTNIUks0WGFTZThoWXc=\n\ndags:\n  gitSync:\n    enabled: true\n    repo: https://github.com/airscholar/Kubernetes-For-DataEngineering.git\n    branch: main\n    rev: HEAD\n    depth: 1\n    maxFailures: 0\n    subPath: \"dags\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하루 마무리로 우리는 구성을 다시 적용하고 helm 차트로 릴리스를 업데이트할 거에요!\n\n```js\nhelm upgrade --install airflow apache-airflow/airflow --namespace airflow --create-namespace -f values.yaml\n```\n\nUI에서 그 모습을 확인해보죠.\n\n마지막으로, 이 DAG들을 트리거하고 해당 로그에서 출력을 확인해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이제 마무리입니다!\n\n아래 주제 중에 관심이 있는 분은:\n\n- Python\n- 데이터 엔지니어링\n- 데이터 분석\n- 데이터 과학\n- SQL\n- 클라우드 플랫폼 (AWS/GCP/Azure)\n- 머신러닝\n- 인공지능\n\n제 모든 플랫폼을 좋아요와 팔로우 해주세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Github: airscholar\n- Twitter: @YusufOGaniyu\n- LinkedIn: Yusuf Ganiyu\n- Youtube: CodeWithYu\n- Medium: Yusuf Ganiyu\n\n나는 LinkedIn, X, Medium 및 YouTube에서 매일 콘텐츠를 공유합니다.\n\ndatamasterylab.com에서 더 많은 코스를 확인하실 수 있습니다.\n\n# 자료들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n깃허브 풀 코드\n\n유튜브 비디오\n\n엔드 투 엔드 데이터 엔지니어링 재생 목록\n\n# 스택데믹\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 축소 버튼을 클릭해 주시고 작가를 팔로우해 주세요! 👏\n- X사의 팔로우 | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해 보세요: In Plain English | CoFeed | Venture\n","ogImage":{"url":"/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_0.png"},"coverImage":"/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_0.png","tag":["Tech"],"readingTime":28},{"title":"쿠버네티스 명령어 명령형 vs 선언형 비교","description":"","date":"2024-06-23 23:01","slug":"2024-06-23-ImperativevsDeclarativeKubernetesCommands","content":"\n쿠버네티스 명령줄 도구 인 kubectl을 사용하면 쿠버네티스 클러스터에 대해 명령을 실행할 수 있습니다. kubectl을 사용하여 응용 프로그램을 배포하고 클러스터 리소스를 검사하고 관리하며 로그를 볼 수 있습니다.\n\nkubectl 도구는 세 가지 유형의 객체 관리를 지원합니다.\n\n- 명령형 명령\n- 명령형 객체 구성\n- 선언적 객체 구성\n\n![이미지](/assets/img/2024-06-23-ImperativevsDeclarativeKubernetesCommands_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 명령문\n\n명령문은 클러스터의 객체에 직접적으로 작용하며, 이러한 명령문은 객체의 상태를 즉시 변경합니다.\n\n이러한 명령문의 예시:\n\n- **kubectl create** — 이 명령어는 객체(e.g. 배포(Deployment), 레플리카셋(ReplicaSet) 등)를 생성하는 데 사용됩니다.\n- **kubectl run** — 이 명령어는 포드(Pod)를 생성하는 데 사용됩니다.\n- **kubectl expose** — 이 명령어는 배포(Deployment) 또는 레플리카셋(ReplicaSet)에 대한 서비스를 생성하는 데 사용됩니다.\n- **kubectl scale** — 이 몤령어는 배포(Deployment) 또는 레플리카셋(ReplicaSet)에서 레플리카의 수를 확장하거나 축소하는 데 사용됩니다.\n- **kubectl delete** — 이 명령어는 객체(e.g. 배포(Deployment), 포드(Pod) 등)를 삭제하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시\n\n첫 번째 명령은 nginx 컨테이너를 실행하는 Pod 객체를 생성합니다. 두 번째 명령\n\nnginx 컨테이너를 실행하는 Pod 객체를 생성합니다:\n\n```js\nkubectl run nginx --image=nginx\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnginx 컨테이너를 실행하는 ReplicaSets가 있는 Deployment 객체를 만들어보세요:\n\n```js\nkubectl create deployment nginx --image nginx\n```\n\nImperative 명령어들은 보통 사용하기 쉽습니다. 학습이나 테스트 프로젝트에는 훌륭한데, Git과 같은 버전 관리 시스템에서 시스템 변경사항을 추적할 수 없기 때문에 프로덕션 시스템에서는 일반적으로 피해야합니다.\n\n## 명령어를 사용한 객체 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n명령형 객체 구성에서는 kubectl 명령어를 사용하여 작업(생성, 대체 등), 선택적 플래그 및 하나 이상의 파일 이름을 지정합니다.\n\n예시\n\n구성 파일에 정의된 객체를 생성합니다:\n\n```js\nkubectl create -f config.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 구성 파일에서 정의된 객체를 삭제합니다:\n\n```js\nkubectl delete -f config1.yaml -f config2.yaml\n```\n\n## 선언적 객체 구성\n\n명령형 명령어와는 달리 객체에 대한 작업을 수행하기 위해 정확한 단계를 올바른 순서대로 수행해야 하는 절차적 방법과 달리, 선언적 접근 방식은 선언적 매니페스트 파일에서 객체의 원하는 상태를 선언하고 Kubernetes가 kubectl applycommand를 사용하여 객체의 원하는 상태를 달성하도록 관리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시\n\nconfigs 디렉토리에 있는 모든 객체 구성 파일을 처리하고 라이브 객체를 생성하거나 패치합니다. 무엇이 변경될 것인지 먼저 확인하고 적용할 수 있습니다:\n\n```js\nkubectl diff -f configs/\nkubectl apply -f configs/\n```\n\n디렉토리를 재귀적으로 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl diff -R -f configs/\nkubectl apply -R -f configs/\n```\n\n딱지 복제 파일은 YAML 또는 JSON으로 작성되며 Kubernetes 객체의 원하는 상태를 정의합니다. 선언적 매니페스트가 클러스터에 적용되면 Kubernetes는 객체의 현재 상태와 원하는 상태를 비교하여 원하는 상태를 달성하기 위해 필요한 변경을 수행합니다.\n\n다음은 선언적 매니페스트 예시입니다 — configs/nginx-deployment.yaml\n\n```js\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n        - name: nginx-container\n          image: nginx:latest\n          ports:\n            - containerPort: 8080\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 manifest는 nginx:latest Docker 이미지를 기반으로 하는 컨테이너의 복제본을 두 개 실행해야 한다는 배포를 설명합니다.\n\n이렇게 하면, 우리는 많은 선언적 manifest 파일들을 직접적으로 구성에 추가하고, 모두를 하나의 kubectl apply -f configs/ 명령어로 적용할 수 있습니다.\n\n일반적으로 선언적 접근 방식은 변경 사항을 버전 관리 시스템에서 추적할 수 있게 하며, 코드 리뷰를 가능하게 하고 변경 사항을 CI/CD 파이프라인에서 자동으로 적용하는 것을 가능하게 합니다.\n\n이 글이 마음에 드셨다면 팔로우 버튼을 눌러 주세요. 더 이상의 이와 유사한 글을 읽고 싶으시다면요\n","ogImage":{"url":"/assets/img/2024-06-23-ImperativevsDeclarativeKubernetesCommands_0.png"},"coverImage":"/assets/img/2024-06-23-ImperativevsDeclarativeKubernetesCommands_0.png","tag":["Tech"],"readingTime":5},{"title":"K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법","description":"","date":"2024-06-23 23:00","slug":"2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution","content":"\n![Kubernetes Automated Diagnosis Tool: k8sgpt-operator](/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_0.png)\n\n주말에 블로그 초고를 확인했더니 이 글이 있었어요. 한 해 전 'Kubernetes Automated Diagnosis Tool: k8sgpt-operator'를 쓸 때의 기억이 떠오르네요. 처음에는 K8sGPT + LocalAI를 써보려 했지만, Ollama로 시도해보니 더 사용하기 편리했어요. 게다가 Ollama는 OpenAI API를 지원하기도 해서 Ollama로 바꾸기로 결정했죠.\n\nk8sgpt-operator를 소개하는 글을 게시한 후 몇몇 독자들이 OpenAI를 사용하기 위한 높은 진입 장벽을 언급했어요. 이 문제는 정말 어려운 문제이지만 극복할 수 있는 문제에요. 하지만 이 글은 그 문제를 해결하는 게 아니라 OpenAI 대안인 Ollama를 소개하기 위한 글이에요. 작년 말에 k8sgpt는 CNCF Sandbox에 들어갔어요.\n\n# 1. Ollama 설치하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Ollama](/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_1.png)\n\nOllama은 로컬이나 클라우드에서 쉽게 설치하고 실행할 수 있는 여러 대형 모델을 지원하는 오픈 소스 대형 모델 도구입니다. 매우 사용하기 편리하며 간단한 명령어로 실행할 수 있습니다. macOS에서는 homebrew를 사용하여 다음 명령어로 쉽게 설치할 수 있습니다:\n\n```js\nbrew install ollama\n```\n\n최신 버전은 0.1.44입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nollama -v\n경고: 실행 중인 Ollama 인스턴스에 연결할 수 없습니다\n경고: 클라이언트 버전은 0.1.44입니다\n```\n\n리눅스에서는 공식 스크립트로도 설치할 수 있습니다.\n\n```js\ncurl -sSL https://ollama.com/install.sh | sh\n```\n\nOllama를 시작하고 컨테이너나 K8s 클러스터에서 접근할 수 있도록 환경 변수를 통해 수신 주소를 0.0.0.0으로 설정하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nOLLAMA_HOST=0.0.0.0 ollama start\n```\n\n```js\n...\ntime=2024-06-16T07:54:57.329+08:00 level=INFO source=routes.go:1057 msg=\"127.0.0.1:11434에서 수신 대기 중 (버전 0.1.44)\"\ntime=2024-06-16T07:54:57.329+08:00 level=INFO source=payload.go:30 msg=\"임베디드 파일 추출 중\" dir=/var/folders/9p/2tp6g0896715zst_bfkynff00000gn/T/ollama1722873865/runners\ntime=2024-06-16T07:54:57.346+08:00 level=INFO source=payload.go:44 msg=\"동적 LLM 라이브러리 [metal]\"\ntime=2024-06-16T07:54:57.385+08:00 level=INFO source=types.go:71 msg=\"추론 계산 중\" id=0 library=metal compute=\"\" driver=0.0 name=\"\" total=\"21.3 GiB\" available=\"21.3 GiB\"\n```\n\n# 2. 큰 모델 다운로드 및 실행하기\n\n4월에 Meta에서 오픈 소스로 공개된 인기 있는 큰 모델 중 하나인 Llama3가 있습니다. Llama3에는 8B와 70B 두 가지 버전이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n맥OS에서 실행 중이고, 8B 버전을 선택했어요. 8B 버전은 4.7GB이며, 빠른 인터넷 연결로 다운로드하면 3-4분이 소요돼요.\n\n```js\nollama run llama3\n```\n\n제 M1 Pro에서 32GB 메모리를 사용하고 있는데, 실행하는 데 약 12초 정도 걸려요.\n\n```js\ntime=2024-06-17T09:30:25.070+08:00 level=INFO source=server.go:572 msg=\"llama runner started in 12.58 seconds\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 쿼리마다 약 14초가 소요됩니다.\n\n```js\ncurl http://localhost:11434/api/generate -d '{\n  \"model\": \"llama3\",\n  \"prompt\": \"Why is the sky blue?\",\n  \"stream\": false\n}'\n```\n\n```js\n....\n\"total_duration\":14064009500,\"load_duration\":1605750,\"prompt_eval_duration\":166998000,\"eval_count\":419,\"eval_duration\":13894579000}\n```\n\n# 3. K8sGPT CLI 백엔드 구성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 k8sgpt-operator를 테스트하려면 이 단계를 건너뛸 수 있어요.\n\nk8sgpt의 백엔드로 Ollama REST API를 사용할 거에요. 이 API는 추론 제공자로 기능하며, backend 유형은 localai로 선택했어요. LocalAI는 OpenAI API와 호환되며, 실제 제공자는 여전히 Llama를 실행하는 Ollama일 거예요.\n\n```js\nk8sgpt auth add --backend localai --model llama3 --baseurl http://localhost:11434/v1\n```\n\n이를 기본 제공자로 설정하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nk8sgpt auth default --provider localai\nlocalai로 기본 제공자가 설정되었습니다.\n\n테스트 중:\n\nimage-not-exist 이미지를 사용하여 k8s 내에서 Pod를 생성합니다.\n\nkubectl get po k8sgpt-test\n이름          준비     상태         다시 시작     나이\nk8sgpt-test   0/1     ErrImagePull   0          6초\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n에러를 분석하려면 k8sgpt를 사용해보세요.\n\nk8sgpt analyze --explain --filter=Pod --namespace=default --output=json\n\n{\n  \"provider\": \"localai\",\n  \"errors\": null,\n  \"status\": \"ProblemDetected\",\n  \"problems\": 1,\n  \"results\": [\n    {\n      \"kind\": \"Pod\",\n      \"name\": \"default/k8sgpt-test\",\n      \"error\": [\n        {\n          \"Text\": \"Back-off pulling image \\\"image-not-exist\\\"\",\n          \"KubernetesDoc\": \"\",\n          \"Sensitive\": []\n        }\n      ],\n      \"details\": \"Error: Back-off pulling image \\\"image-not-exist\\\"\\n\\nSolution: \\n1. Check if the image exists on Docker Hub or your local registry.\\n2. If not, create the image using a Dockerfile and build it.\\n3. If the image exists, check the spelling and try again.\\n4. Verify the image repository URL in your Kubernetes configuration file (e.g., deployment.yaml).\",\n      \"parentObject\": \"\"\n    }\n  ]\n}\n\n# 4. k8sgpt-operator 배포 및 설정하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nk8sgpt-operator은 클러스터 내에서 k8sgpt를 자동화할 수 있습니다. Helm을 사용하여 쉽게 설치할 수 있어요.\n\n```\n\nhelm repo add k8sgpt https://charts.k8sgpt.ai/\nhelm repo update\nhelm install release k8sgpt/k8sgpt-operator -n k8sgpt --create-namespace\n\nk8sgpt-operator는 K8sGPT를 구성하고 분석 결과를 출력하는 Result를 위한 두 가지 CRD를 제공합니다.\n\nkubectl api-resources | grep -i gpt\nk8sgpts core.k8sgpt.ai/v1alpha1 true K8sGPT\nresults core.k8sgpt.ai/v1alpha1 true Result\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOllama의 IP 주소를 baseUrl로 사용하여 K8sGPT를 구성하세요.\n\n```js\nkubectl apply -n k8sgpt -f - \u003c\u003c EOF\napiVersion: core.k8sgpt.ai/v1alpha1\nkind: K8sGPT\nmetadata:\n  name: k8sgpt-ollama\nspec:\n  ai:\n    enabled: true\n    model: llama3\n    backend: localai\n    baseUrl: http://198.19.249.3:11434/v1\n  noCache: false\n  filters: [\"Pod\"]\n  repository: ghcr.io/k8sgpt-ai/k8sgpt\n  version: v0.3.8\nEOF\n```\n\nK8sGPT CR을 생성한 후, 연산자(operator)가 이를 위한 파드를 자동으로 만듭니다. result CR을 확인하면 동일한 결과가 표시됩니다.\n\n```js\nkubectl get result -n k8sgpt -o jsonpath='{.items[].spec}' | jq .\n{\n  \"backend\": \"localai\",\n  \"details\": \"Error: Kubernetes is unable to pull the image \\\"image-not-exist\\\" due to it not existing.\\n\\nSolution: \\n1. Check if the image actually exists.\\n2. If not, create the image or use an alternative one.\\n3. If the image does exist, ensure that the Docker daemon and registry are properly configured.\",\n  \"error\": [\n    {\n      \"text\": \"Back-off pulling image \\\"image-not-exist\\\"\"\n    }\n  ],\n  \"kind\": \"Pod\",\n  \"name\": \"default/k8sgpt-test\",\n  \"parentObject\": \"\"\n}\n```\n","ogImage":{"url":"/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_0.png"},"coverImage":"/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_0.png","tag":["Tech"],"readingTime":9},{"title":"GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유","description":"","date":"2024-06-23 22:58","slug":"2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst","content":"\nMulti-Cluster Services (MCS)은 한 GKE 클러스터에서 워크로드 간 통신을 허용하는 일반적인 문제에 대한 해결책을 제공합니다. 이 서비스는 이 글에서 MCS가 어떻게 구성되는지, 어떻게 구축되는지, 그리고 클러스터와 주변 인프라 수준에서 어떤 구성 요소가 관련되어 있는지 살펴볼 것입니다. 이를 통해 서비스에 대한 심층적인 이해를 얻고 문제 해결에 대한 신뢰를 높일 수 있을 것입니다.\n\n만약 플릿 및 MCS에 대한 일반 소개를 원한다면 Kishore Jagannath의 훌륭한 두 부분 블로그 포스트를 추천합니다.\n\n이 블로그 포스트에서는 조금 다른 방식으로 MCS의 구성 요소를 분석할 것입니다. 운이 좋다면 이런 과정이 기술이 마법처럼 느껴질 때의 어린 시절 추억을 떠올리게 할지도 모릅니다. 그러나 다행히 이번에는 가족용 계산기를 조금 복잡하게 살펴보고 고쳤다가 다시 조립했을 때 처럼 부모님께서 화를 내지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 우선 순위를 정하자 — MCS를 사용해야 할 때\n\nMCS의 내부 작동 방식을 더 깊이 들어가기 전에, 교차 클러스터 통신 영역을 탐색하기 전에 먼저 한 걸음 물러나보겠습니다. 아래 다이어그램에서 볼 수 있듯이, MCS는 쿠버네티스 또는 구체적으로 GKE 클러스터에서 실행되는 서비스를 사용하는 것을 허용하기 위한 여러 가능한 솔루션 중 하나에 불과합니다.\n\nMCS는 같은 플리트 내의 다른 클러스터에서 실행되는 팟에 백업된 서비스와 통신할 수 있도록 하는 작업에 집중하는 비교적 간단한 해결책입니다. 동일한 교차 클러스터 통신은 GKE의 Service Mesh나 Istio와 같은 서비스 메시의 다중 클러스터 기능이나 Cilium과 같은 네트워크 수준의 도구를 사용하여 구현할 수도 있습니다. 이미 이러한 방식 중 하나를 사용하고 있거나 교차 클러스터 통신 상단에 트래픽 관리, 투명 인증 또는 텔레미트리와 같은 기능을 사용할 계획이라면, 아마도 MCS는 너무 단순해서 당신의 사용 사례에 적합하지 않을 것이며, 대신 서비스 메시를 사용하는 것이 좋을 것입니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# MCS 데모 준비 중\n\n이 블로그 포스트에서 실제 탐구를 따라하고 싶다면, MCS와 놀 수 있도록 필요한 API를 활성화하고 GKE autopilot 클러스터 두 개를 생성하는 단계를 수행할 수 있습니다. 대신 표준 GKE 클러스터를 사용하고 싶다면, 여기 제공된 예시도 잘 작동할 것입니다.\n\n```js\nexport PROJECT_ID=\u003c여기에 프로젝트 ID 입력\u003e\n\ngcloud services enable \\\n    compute.googleapis.com \\\n    container.googleapis.com \\\n    multiclusterservicediscovery.googleapis.com \\\n    gkehub.googleapis.com \\\n    cloudresourcemanager.googleapis.com \\\n    trafficdirector.googleapis.com \\\n    dns.googleapis.com \\\n    --project=$PROJECT_ID\n\ngcloud container clusters create-auto \"test-us-cluster\" \\\n  --region \"us-central1\" --enable-master-authorized-networks \\\n  --network \"default\" --subnetwork \"default\" \\\n  --services-ipv4-cidr 10.99.0.0/20 \\\n  --async --project \"$PROJECT_ID\"\n\ngcloud container clusters create-auto \"test-eu-cluster\" \\\n  --region \"europe-west1\" --enable-master-authorized-networks \\\n  --network \"default\" --subnetwork \"default\" \\\n  --services-ipv4-cidr 10.99.16.0/20 \\\n  --async --project \"$PROJECT_ID\"\n```\n\n클러스터가 준비되면, 피트에서 다중 클러스터 기능을 활성화하고 새로 생성된 클러스터를 피트에 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngcloud container fleet multi-cluster-services enable --project $PROJECT_ID\n\ngcloud container fleet memberships register test-us-cluster \\\n   --gke-cluster us-central1/test-us-cluster \\\n   --enable-workload-identity \\\n   --project $PROJECT_ID\n\ngcloud container fleet memberships register test-eu-cluster \\\n   --gke-cluster europe-west1/test-eu-cluster \\\n   --enable-workload-identity \\\n   --project $PROJECT_ID\n```\n\n우리 클러스터 상황을 확인해보죠. 이를 위해 europe-west1 지역의 클러스터에 연결해봅시다:\n\n```js\ngcloud container clusters get-credentials test-eu-cluster --region europe-west1 --project $PROJECT_ID\n```\n\nMCS의 흔적이 이미 존재하는지 확인하기 위해 우리의 네임스페이스 리소스를 나열해보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl get ns\n```\n\n네임스페이스 목록에는 \"gke-mcs\"라는 새로 생성된 네임스페이스가 포함되어 있어야 합니다. 해당 네임스페이스 이름은 이미 플릿에서 활성화된 MCS 기능과 관련이 있을 가능성이 높으며, 또한 해당 네임스페이스가 만들어진 시간은 클러스터를 플릿에 등록했을 때와 일치합니다.\n\n\"gke-mcs\" 네임스페이스를 좀 더 자세히 알아보고 이미 실행 중인 것이 있는지 확인해 봅시다:\n\n```js\nkubectl get all -n gke-mcs # 이 명령은 gke-mcs-importer에 대한 배포를 보여줍니다.\n\nkubectl logs -n gke-mcs -l k8s-app=gke-mcs-importer --tail -1 # Importer의 로그를 얻기 위해\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로그에서는 수입 업체가 트래픽 디렉터 API에 액세스할 권한이 아직 부여되지 않았기 때문에 권한 오류가 발생할 수 있습니다:\n\n```js\n핸들러 오류: 스트림을 통해 ADS 응답 수신 중: 권한이 거부되었습니다:\nrpc 오류: 코드 = PermissionDenied desc = 권한\n'trafficdirector.networks.getConfigs'이 자원에 대해 거부되었습니다\n'//trafficdirector.googleapis.com/projects/...' (또는 존재하지 않을 수 있음).\n```\n\n수입 업체의 워크로드 ID를 사용하여 Cloud DNS에서 정보를 가져오는 데 사용되는 네트워크 뷰어 역할을 할당함으로써 이 문제를 해결할 수 있습니다:\n\n```js\ngcloud projects add-iam-policy-binding $PROJECT_ID \\\n    --member \"serviceAccount:$PROJECT_ID.svc.id.goog[gke-mcs/gke-mcs-importer]\" \\\n    --role \"roles/compute.networkViewer\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 로그 문을 다시 실행하면 예상대로 폴링이 작동하지만 우리를 위해 생성된 존이 없다는 것을 확인할 것입니다. 이제 클러스터는 다중 클러스터 서비스를 배포할 준비가 되었습니다.\n\n# 데모 응용 프로그램 배포\n\n두 GKE 클러스터 간의 컨텍스트 전환을 쉽게하기 위해 먼저 클러스터 컨텍스트의 이름을 변경합니다. 또는 클라우드 셸에 미리 설치된 kubectx 단축키를 사용할 수도 있습니다.\n\n```js\ngcloud container clusters get-credentials test-us-cluster --region us-central1 --project $PROJECT_ID\nkubectl config rename-context \"$(kubectl config current-context)\" mcs-us\n\ngcloud container clusters get-credentials test-eu-cluster --region europe-west1 --project $PROJECT_ID\nkubectl config rename-context \"$(kubectl config current-context)\" mcs-eu\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 지나치게 화려한 애플리케이션이 필요하지 않습니다. 결국, 다른 GKE 클러스터에서 실행 중인 특정 서비스에 도달할 수 있는지 여부를 보여주기만 원합니다. 데모 목적으로, 우리의 EU 클러스터에서 기존의 hello-web 예제를 배포하고 클러스터 내에서 전통적인 ClusterIP 서비스로 노출합니다.\n\n```js\nkubectl create ns shared-services --context mcs-eu\n\nkubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/kubernetes-engine-samples/main/quickstarts/hello-app/manifests/helloweb-deployment.yaml -n shared-services  --context mcs-eu\n\nkubectl expose deployment/helloweb --port 8080 -n shared-services --context mcs-eu\n```\n\n서비스가 생성되면 클러스터 내에서 기대대로 자동으로 생성된 k8s cluster.local DNS 이름을 사용하여 성공적으로 호출할 수 있습니다:\n\n```js\nkubectl run test-curl --image=curlimages/curl -it --rm --pod-running-timeout=4m --context mcs-eu -- curl -v http://helloweb.shared-services.svc.cluster.local:8080\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n흥미로운 사이드 노트와 나중에 중요한 세부 정보는, 우리의 GKE 클러스터가 클라우드 DNS를 사용한다는 것입니다. 따라서 Google Cloud 콘솔의 Cloud DNS UI에서 우리 서비스를 위해 자동으로 생성된 A 레코드도 볼 수 있습니다. DNS 존에는 명시적으로 이 Cloud DNS 존이 특정 GKE 클러스터에서만 사용 가능하다고 나와 있습니다. 이 DNS 존은 어떤 VPC에도 첨부되어 있지 않기 때문에 전형적인 사설 존은 아닙니다.\n\n![그림](/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_2.png)\n\nMCS의 목표는 미국 클러스터에서 이 서비스를 사용할 수 있도록 하는 것입니다. 서비스를 노출하기 전에 기본 서비스에서 어떤 일이 발생하는지 살펴봅시다. 아마도 예상하시겠지만, EU 클러스터에서 사용한 DNS 레코드는 미국 클러스터에서 사용할 수 없으며, 심지어 서비스 IP도 미국 클러스터에서 도달할 수 없습니다. 클러스터를 생성할 때 RFC 1918 범위를 사용했지만, 미국 클러스터에서는 이러한 클러스터를 호출할 수 없기 때문입니다.\n\n```js\n# 호스트 이름을 해결할 수 없다는 오류로 실패합니다\nkubectl run test-curl --image=curlimages/curl -it --rm --pod-running-timeout=4m --context mcs-us -- curl -v http://helloweb.shared-services.svc.cluster.local:8080\n\n# 타임아웃으로 실패합니다\nEU_SERVICE_IP=\"$(kubectl get svc -l app=hello -n shared-services --context mcs-eu -ojsonpath='{.items[*].spec.clusterIP}')\"\nkubectl run test-curl --image=curlimages/curl -it --rm --pod-running-timeout=4m --context mcs-us -- curl -v \"http://$EU_SERVICE_IP:8080\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희가 겪고 있는 문제는 미국 클러스터의 작업량이 EU 클러스터의 작업량에 도달하지 못하는 것이 아니라, 아래에서 직접 Pod IP를 호출하여 증명할 수 있는 것입니다. 네트워크 수준에서는 VPC 네이티브 클러스터 네트워킹을 사용하여 VPC 내에서 Pod IP가 경로 지정될 수 있기 때문에 이 작업이 가능합니다. 아래 예시에서는 양 쪽 클러스터의 API 서버에 연결하여 이를 활용하여 서로간의 교차 클러스터 통신을 증명하는 데 사용합니다.\n\n```js\nEU_POD_IP=\"$(kubectl get po -l app=hello -n shared-services --context mcs-eu -ojsonpath='{.items[*].status.podIP}')\"\n\nkubectl run test-curl --image=curlimages/curl -it --rm --pod-running-timeout=4m --context mcs-us -- curl -v http://$EU_POD_IP:8080\n```\n\n물론 포드 IP를 명시적으로 Kubernetes API에 쿼리하는 것은 확장 가능한 해결책이 아닙니다. 이것이 클러스터 간에 서비스 발견을 자동화하기 위해 MCS로 전환해야 하는 이유입니다.\n\n# MCS로 서비스 내보내기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMCS에서 실행 중인 서비스를 EU 클러스터에서 내보내려면 EU 클러스터에 ServiceExport 리소스를 만듭니다. 동시에 해당 서비스를 가져올 US 클러스터의 이름 공간을 만듭니다:\n\n```js\nkubectl create ns shared-services --context mcs-us\n\nkubectl apply --context mcs-eu -f - \u003c\u003cEOF\napiVersion: net.gke.io/v1\nkind: ServiceExport\nmetadata:\n namespace: shared-services\n name: helloweb\nEOF\n```\n\n이제 방금 내보낸 서비스와 관련된 로그 항목이 포함된 MCS 가져오기자 로그를 US 클러스터에서 살펴볼 수 있습니다:\n\n```js\nkubectl logs -n gke-mcs -l k8s-app=gke-mcs-importer --tail=25 --context mcs-us\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미국 클러스터가 EU에서 실행 중인 작업에 대한 정보를 수신했음을 나타내고 해당 정보를 자동으로 사용하는 엔드포인트가 만들어 졌음을 나타내고 있습니다:\n\n```js\nADS 응답을 받음 (europe-west1-d), 유형: type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\neurope-west1-d에서 1개의 negs로부터 업데이트\n엔드포인트 \"gke-mcs-...\" 생성 중\n```\n\nMCS importer를 통해 미국 클러스터에서 자동으로 생성된 리소스를 살펴봅시다.\n\n```js\nkubectl get ServiceImport -n shared-services --context mcs-us\n\nkubectl get Service -n shared-services --context mcs-us\n\nkubectl get Endpoints -n shared-services --context mcs-us\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 명령어에서 나열된 엔드포인트들은 EU 클러스터에서 실행 중인 워크로드의 pod ip를 포함하고 있습니다. 이는 ServiceExport 리소스가 이전 섹션에서 수동으로 제공한 교차 클러스터 리소스 식별을 자동화했다는 것을 의미합니다. 이제 위에서 찾은 서비스와 엔드포인트를 테스트하고 미국 클러스터 내에서부터 호출해 봅시다:\n\n```js\nSVC_NAME=$(kubectl get service -o=jsonpath='{.items[?(@.metadata.annotations.net\\.gke\\.io/service-import==\"helloweb\")].metadata.name}' -n shared-services --context mcs-us)\n\n\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-us -- \\\n  curl -v http://$SVC_NAME.shared-services.svc.cluster.local:8080\n```\n\n작동이 잘 되었네요. 이번에는 EU 클러스터의 API 서버와 통신하여 워크로드를 실행 중인 pod의 IP를 찾아낼 필요가 없었습니다. 왜냐하면 Service Import가 이미 해당 정보를 동기화했기 때문입니다. 유일하게 해결해야 할 문제는 \"gke-mcs-`해시`\" 형식으로 자동 생성된 MCS importer의 서비스 이름이 사전에 쉽게 알려지지 않는다는 것입니다. 위 예에서도 다시 API 서버를 사용하여 올바른 서비스 이름을 검색했습니다. 실제 사용 사례에서는 워크로드가 원격 서비스를 호출하기 전에 쿠버네티스 API 서버에 문의하는 것을 원치 않는 것은 당연합니다. 이는 추상화를 깨뜨리고 파드의 서비스 계정에 불필요한 권한이 필요하게 됩니다.\n\n클러스터셋 로컬 호스트 이름의 호기심스러운 사례#\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자동 생성되는 기억하기 어려운 서비스 이름 문제를 해결하기 위해 MCS가 제공하는 편리한 DNS 기반 솔루션을 사용할 수 있습니다. 각 가져온 서비스에 대해 \"SERVICE_EXPORT_NAME.NAMESPACE.svc.clusterset.local\" 형식의 DNS 항목을 만듭니다. 이 호스트 이름을 사용하여 생성된 서비스 이름을 식별하는 추가 단계 없이 서비스를 호출할 수 있는 결정론적인 방법이 생겼습니다. 가져온 서비스의 호스트 이름을 작성하고 클러스터 중 하나에서 팟 내부에서 호출할 수 있습니다:\n\n```js\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-eu -- \\\n  curl http://helloweb.shared-services.svc.clusterset.local:8080\n\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-us -- \\\n  curl http://helloweb.shared-services.svc.clusterset.local:8080\n```\n\n참고: 위 요청 중 하나에 대해 오류가 발생하면 DNS 캐싱 때문일 수 있습니다. 관리 DNS 존이 클러스터셋 로컬 DNS A 레코드를 나열하면 결국 팟에서 인식할 수 있습니다.\n\n처음에 예상하지 못한 흥미로운 점 중 하나는 clusterset.local DNS 존이 Cloud DNS UI에 노출되지 않는다는 것입니다. 하지만 우리 호스트 이름을 위해 레코드 세트가 있는 하부 관리 DNS 존이 있음을 다음 명령어를 실행하여 확인할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngcloud dns managed-zones list --location=us-central1-b\n\ngcloud dns managed-zones describe \u003cname of the zone from above\u003e --location=us-central1-b\n\ngcloud dns record-sets list --location=us-central1-b --zone \u003cname of the zone from above\n```\n\n만약 클라우드 콘솔에서 clusterset.local 호스트명을 보고 싶다면 Traffic Director로 이동할 수 있어요. GCP 콘솔에서 Traffic Director UI를 열면 라우팅 규칙 맵 탭에서 우리의 플릿과 연결된 정방향 규칙 및 helloweb 서비스가 연결된 서비스로 나열된 라우팅 규칙을 볼 수 있어요. 또한 이에 연결된 정방향 규칙도 표시돼요.\n\n\u003cimg src=\"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_3.png\" /\u003e\n\n라우팅 규칙의 이름을 클릭하면 정방향 규칙과 라우팅 규칙에서 사용된 호스트명 목록을 볼 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_4.png\" /\u003e\n\n# [옵션 부분] 계산기를 해체하고 다시 조립하는\n\n만약 그게 맞다면, 우리의 호스트 이름이 실제로 전달 규칙에서 처리되고 내부 로드 밸런서의 경우처럼 연결된 NEG로 보내진다고 가정하는 유혹을 느낄 수 있습니다. 이것이 맞다면, 우리는 미국 클러스터의 쿠버네티스 리소스가 EU 서비스와 통신하기 위해서는 서비스와 엔드포인트에 대한 Kubernetes 리소스가 필요하지 않을 것입니다. 여기서 우리는 다시 시작점으로 돌아와 계산기를 해체해 우리의 이해를 확인하는 유사성을 다시 살펴보는 지점에 도달합니다.\n\n이 가정을 확인하기 위해 미국 클러스터의 shared-services 네임스페이스를 삭제해볼 수 있습니다. 이렇게 하면 우리가 이전에 살펴본 서비스와 엔드포인트를 포함한 모든 네임스페이스 리소스를 삭제합니다. 마지막으로 미국 클러스터의 파드에서 curl을 다시 실행하고 싶을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl delete ns shared-services --context mcs-us\n\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-us -- \\\n  curl http://helloweb.shared-services.svc.clusterset.local:8080\n```\n\n위의 curl 명령은 실패할 것이며, MCS Importer가 shared-services 네임스페이스에 생성한 리소스가 실제로 필요했음을 확인합니다. 이것은 클러스터 외부의 라우트 규칙에서 호스트 이름이 구성되어 있더라도 해당된다는 것을 의미합니다. 계산기를 되돌려 놓고 MCS Importer가 리소스를 다시 생성할 수 있도록 shared-services 네임스페이스를 재생성합시다.\n\n```js\nkubectl create ns shared-services --context mcs-us\n```\n\nImporter가 서비스 및 엔드포인트 리소스를 다시 생성한 후, 우리는 버보즈 출력으로 curl 명령을 다시 실행합니다. 이렇게 하면 서비스를 삭제했을 때 위와 같은 이유로 실패했던 것을 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-us -- \\\n  curl http://helloweb.shared-services.svc.clusterset.local:8080\n```\n\n여기서 볼 수 있듯이 호스트 이름이 우리 서비스의 클러스터 IP로 해석되어 MCS에 접근하기 위해 서비스 리소스가 여전히 필요합니다.\n\n# 결론\n\n이 모든 실험과 탐구를 통해 MCS에 대한 우리의 이해를 완성할 수 있습니다. 우리는 지금 관련된 구성 요소를 이해하고, 처음에는 다소 마술적으로 보였던 기능을 가능하게 하는 것에 대해 더 나은 그림을 그릴 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![GKE Multi-Cluster Services](/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_5.png)\n\n이 게시물에서는 MCS를 실제로 경험하면서 뿐만 아니라 여러 가지를 부수고 다시 조립하는 과정으로 탐구했습니다. 우리는 한 클러스터에 서비스를 생성하고, 그런 다음 MCS를 단계별로 구축하고 워크로드에서 서비스를 소비하는 방식으로 다른 클러스터에서 실행되는 워크로드 사이의 통신을 가능하게 하는 리소스를 살펴봄으로써 MCS를 살펴보았습니다.\n\n자신만의 멀티 클러스터 서비스 여정을 계속해 보고 싶다면 문서에서의 MCS 예제를 살펴보고, 멀티 클러스터 통신 위에 추가 기능을 제공하는 서비스 메시와 같은 대체 구현도 고려해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_0.png"},"coverImage":"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_0.png","tag":["Tech"],"readingTime":18},{"title":"M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기","description":"","date":"2024-06-23 22:57","slug":"2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips","content":"\n\u003cimg src=\"/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_0.png\" /\u003e\n\n이 기사는 여러분의 기계에 k3s Kubernetes 환경을 설정하여 여러분의 POC를 테스트하고 CNCF 랜드스케이프의 더 많은 도구들을 탐색하는 방법을 보여줍니다.\n\n여러분의 Mac에서 K3S/K8S를 직접 실행할 수 없기 때문에 여러분은 Mac 위에 Linux 레이어를 설정해야 합니다. Mac M1에서 Linux VM을 설정하는 쉬운 방법은 Multipass를 사용하는 것입니다.\n\n왜 Multipass를 사용해야 하는지요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번의 명령어로 즉시 Ubuntu VM을 얻을 수 있어요.\n\n먼저, Multipass를 설치해야 해요.\n\n```js\nbrew install --cask multipass\n```\n\n설치되면 메모리 및 디스크 공간을 지정하여 새 VM을 생성해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmultipass launch --name k3s --memory 4G --disk 40G\n```\n\n우리는 심지어 VM에서 Mac 디렉터리를 마운트할 수도 있어요.\n\n```js\nmkdir ~/test/k8s\nmultipass mount ~/test/k8s k3s:~/k8s\n```\n\n호스트 디렉토리에서 변경 사항을 만들고 VM 내부의 클러스터에 변경 사항을 적용하려고 할 때 유용할 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nVM 내부에서 설치 스크립트를 실행하여 k3s를 설치할 수 있어요.\n\n```js\nmultipass shell k3s\n\nubuntu@k3s:~$ curl -sfL https://get.k3s.io | K3S_KUBECONFIG_MODE=\"644\" sh -\n```\n\nVM이 시작되면 VM 세부 정보를 확인할 수 있어요.\n\n```js\nmultipass info k3s\n\nName:           k3s\nState:          Running\nSnapshots:      0\nIPv4:           192.168.64.7\n                10.42.0.0\n                10.42.0.1\nRelease:        Ubuntu 24.04 LTS\nImage hash:     8263b4713896 (Ubuntu 24.04 LTS)\nCPU(s):         1\nLoad:           0.29 0.22 0.13\nDisk usage:     2.8GiB out of 38.7GiB\nMemory usage:   814.2MiB out of 3.8GiB\nMounts:         /Users/ibrahimmohamed/test/k8s =\u003e ~/k8s\n                    UID map: 501:default\n                    GID map: 20:default\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```shell\nK3S_IP=$(multipass info k3s | grep IPv4 | awk '{print $2}')\n\necho $K3S_IP\n\n192.168.64.7# kubeconfig 다운로드\n\nmultipass exec k3s cp /etc/rancher/k3s/k3s.yaml /home/ubuntu/k8s/\n\ncd ~/test/k8s\n\nsed -i '' \"s/127.0.0.1/${K3S_IP}/\" k3s.yaml\n\nexport KUBECONFIG=${PWD}/k3s.yaml\n```\n\n이제 kubeconfig이 있습니다:\n\n머신에 kubectl을 설치하세요:\n\n```shell\nbrew install kubectl\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```sh\nkubectl get nodes -o wide\n\nNAME   STATUS   ROLES                  AGE   VERSION        INTERNAL-IP    EXTERNAL-IP   OS-IMAGE           KERNEL-VERSION     CONTAINER-RUNTIME\nk3s    Ready    control-plane,master   12m   v1.29.5+k3s1   192.168.64.7   \u003cnone\u003e        Ubuntu 24.04 LTS   6.8.0-35-generic   containerd://1.7.15-k3s1\n\n\nkubectl get pods -A\n\nNAMESPACE     NAME                                      READY   STATUS      RESTARTS   AGE\nkube-system   coredns-6799fbcd5-dc8nd                   1/1     Running     0          41m\nkube-system   local-path-provisioner-6c86858495-9q524   1/1     Running     0          41m\nkube-system   helm-install-traefik-crd-p4xhh            0/1     Completed   0          41m\nkube-system   metrics-server-54fd9b65b-vmhvc            1/1     Running     0          41m\nkube-system   helm-install-traefik-5snzg                0/1     Completed   1          41m\nkube-system   svclb-traefik-ae8c3cf6-hntgn              2/2     Running     0          40m\nkube-system   traefik-7d5f6474df-48vsc                  1/1     Running     0          40m\n```\n\nNow let's view it through Lens\n\n![Lens](/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_1.png)\n\nNow you are ready to run any POC on your local machine.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nk3s 실험이 끝나면 VM을 삭제할 수 있습니다.\n\n```js\nmultipass delete k3s\nmultipass purge\n```\n\n화이팅!\n","ogImage":{"url":"/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_0.png"},"coverImage":"/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_0.png","tag":["Tech"],"readingTime":5},{"title":"Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법","description":"","date":"2024-06-23 22:55","slug":"2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed","content":"\n![이미지](/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_0.png)\n\n이 블로그 포스트에서는 MongoDB 레플리카 세트를 로컬에서 실행할 수 있는 다양한 Docker Compose 설정을 탐색해보려고 합니다. 레플리카 세트는 MongoDB의 강력한 기능인 트랜잭션, 변경 스트림 또는 oplog에 액세스하는 것과 같은 것들을 활용하려는 사람들에게 필수적입니다. 로컬에서 MongoDB 레플리카 세트를 실행하면 이러한 기능에 액세스할 뿐만 아니라 복제 메커니즘 및 일반적인 오류 허용성을 실험할 수 있는 일회용 샌드박스로도 작용합니다. 더 이상 기다리지 말고 시작해 봅시다!\n\n# 단일 노드 레플리카 세트 설정\n\n첫 번째 설정은 몇 초만에 MongoDB 단일 노드 레플리카 세트를 실행할 수 있는 준비된 Docker Compose 파일입니다. 클라우드 환경에서는 고가용성과 오류 허용성을 보장하기 위해 복수 노드가 필요할 것입니다. 그러나 로컬 개발에는 단일 노드 레플리카 세트가 충분하며 트랜잭션 및 변경 스트림에 액세스할 수 있습니다. 이는 로컬에서 MongoDB 인스턴스를 실행하는 데 필요한 CPU 및 메모리 리소스를 줄여 Google Chrome을 더 행복하게 만들어줍니다. rs0라는 이름의 단일 노드 레플리카 세트를 실행하는 docker-compose.yml 파일은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nversion: \"3.8\"\n\nservices:\n  mongo1:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27017\"]\n    ports:\n      - 27017:27017\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n    healthcheck:\n      test: echo \"try { rs.status() } catch (err) { rs.initiate({_id:'rs0',members:[{_id:0,host:'host.docker.internal:27017'}]}) }\" | mongosh --port 27017 --quiet\n      interval: 5s\n      timeout: 30s\n      start_period: 0s\n      start_interval: 1s\n      retries: 30\n    volumes:\n      - \"mongo1_data:/data/db\"\n      - \"mongo1_config:/data/configdb\"\n\nvolumes:\n  mongo1_data:\n  mongo1_config:\n```\n\n여기에서 무슨 일이 벌어지고 있는지 이해해보도록 합시다. 먼저, 우리는 이 글 작성 시 최신 MongoDB Community Edition 이미지인 mongo:7.0을 사용하고 있습니다. rs0라는 레플리카 셋 이름을 지정하기 위해 --replSet 플래그를 사용하고 있습니다. --bind_ip_all 플래그는 MongoDB 인스턴스를 모든 IPv4 주소에 바인딩하기 위해 사용되었으며, --port 플래그는 MongoDB 인스턴스가 수신 대기할 포트를 지정하기 위해 사용되었습니다. 27017은 MongoDB의 기본 포트입니다. 컨테이너 포트 27017을 호스트 포트 27017로 매핑하여 호스트 머신에서 MongoDB 인스턴스에 연결할 수 있도록 하고 있습니다. extra_hosts 섹션은 host.docker.internal 호스트 이름을 호스트 머신의 IP 주소에 매핑하는 데 사용되고 있습니다.\n\nhealthcheck 기능은 우리의 설정에서 레플리카 셋을 초기화하기 위해 재사용되었습니다. 레플리카 셋은 rs.initiate() 명령을 사용하여 초기화되어야 하며(이것은 replSetInitiate 데이터베이스 명령의 동일한 것입니다), 이 작업은 MongoDB 인스턴스가 시작되는 동안 실패할 수 있으므로 healthcheck 기능을 사용하여 작업이 성공할 때까지 재시도하고 있습니다. Docker의 healthcheck은 시작 단계에서 조금 더 공격적일 수 있도록 허용해줍니다. 이것이 start_interval이 1초로만 설정되어 있는 이유입니다. 유감스럽게도 Docker Compose에서 start_interval이 아직 지원되지 않고 있지만, 이것은 사양의 일부입니다. 이 기능에 대한 진행 상황은 해당 GitHub 이슈에서 확인할 수 있습니다. 그 동안 우리는 5초로 일반 interval 값을 설정할 수 있으며, 과도하게 공격적이거나 너무 오랫동안 기다리는 중간 지점입니다. 그러나 start_interval이 구현되면 interval 값을 몇 분 동안 올릴 수 있을 것입니다.\n\n여기서 rs.status()를 사용한 이유는 레플리카 셋이 초기화되지 않았을 때 예외를 throw하기 때문에, 레플리카 셋이 초기화될 때까지 rs.initiate()를 호출하기에 편리합니다. 그 후에는 rs.status()를 주기적으로 호출하는 것은 부담이 되지 않습니다. 또한 여기서 healthcheck가 의도한 대로 작동하고 있다는 점에 유의하십시오. 왜냐하면 우리는 bash 명령이 처음으로 레플리카 셋을 초기화하거나 레플리카 셋이 이미 초기화되어 있는 경우에만 성공적인 종료 코드를 리턴할 것으로 기대하고 있기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 우리는 mongo1_data라는 Docker 볼륨에 데이터를 영속화합니다. 이것은 컨테이너가 중지될 때 데이터가 손실되지 않도록 하는 최선의 방법입니다. 또 다른 볼륨인 mongo1_config은 복제 세트 구성을 영속화하는 데 사용됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*4FJZGrr5m7VuvOk-SmYxcg.gif)\n\n이 단일 노드 MongoDB 복제 세트에 액세스하기 위한 연결 문자열은 다음과 같습니다:\n\n```js\nmongodb://127.0.0.1:27017/?replicaSet=rs0\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쓰림 노드 복제본 설정\n\n이전에 말했듯이, 단일 노드 복제본은 로컬 개발에 충분합니다. 그러나 장애 허용성 및 고 가용성을 실험하려면 여러 노드가 필요합니다. 프로덕션 용도로 사용할 경우, MongoDB 문서에서는 적어도 세 개의 노드를 갖는 것을 권장합니다. 첫 번째 컨테이너는 기본 노드가 되고, 나머지 두 개의 컨테이너는 보조 노드가 됩니다. 다음은 rs0라는 세 개의 노드로 구성된 쓰림 복제본을 실행하기 위한 docker-compose.yml 파일입니다:\n\n```js\nversion: \"3.8\"\n\nservices:\n  mongo1:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27017\"]\n    ports:\n      - 27017:27017\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n    healthcheck:\n      test: echo \"try { rs.status() } catch (err) { rs.initiate({_id:'rs0',members:[{_id:0,host:'host.docker.internal:27017',priority:1},{_id:1,host:'host.docker.internal:27018',priority:0.5},{_id:2,host:'host.docker.internal:27019',priority:0.5}]}) }\" | mongosh --port 27017 --quiet\n      interval: 5s\n      timeout: 30s\n      start_period: 0s\n      start_interval: 1s\n      retries: 30\n    volumes:\n      - \"mongo1_data:/data/db\"\n      - \"mongo1_config:/data/configdb\"\n\n  mongo2:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27018\"]\n    ports:\n      - 27018:27018\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n    volumes:\n      - \"mongo2_data:/data/db\"\n      - \"mongo2_config:/data/configdb\"\n\n  mongo3:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27019\"]\n    ports:\n      - 27019:27019\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n    volumes:\n      - \"mongo3_data:/data/db\"\n      - \"mongo3_config:/data/configdb\"\n\nvolumes:\n  mongo1_data:\n  mongo2_data:\n  mongo3_data:\n  mongo1_config:\n  mongo2_config:\n  mongo3_config:\n```\n\n이 구성에서 기본 노드를 중지하고 보조 노드가 새로운 기본 노드를 선택하는 방식을 확인할 수 있습니다. 이 설정에서 mongo1 컨테이너에는 다른 두 컨테이너보다 약간 더 높은 우선순위가 부여됩니다. 이는 복제본 세트가 완전히 기능할 때 mongo1 컨테이너가 기본 노드로 선출되도록 하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보조 노드 중 하나를 중지하고 레플리카 세트가 계속 작동하는지 확인해 볼 수도 있어요. 모든 노드를 중지해 보고 레플리카 세트가 작동을 멈추는지도 확인할 수 있어요. 이는 내결함 허용성과 고가용성을 실험하는 좋은 방법이에요. 레플리카 세트 상태를 쿼리하고 어느 노드가 주 노드인지 확인하려면 rs.status() 몽고 쉘 명령어를 사용하세요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*w9Oxx6FtrIJ4SMj2ySOApA.gif)\n\n3개 노드 레플리카 세트 연결 문자열은:\n\n```js\nmongodb://127.0.0.1:27017,127.0.0.1:27018,127.0.0.1:27019/?replicaSet=rs0\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 연결 문제 해결하기\n\n![이미지](/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_1.png)\n\n만약 MongoDB 복제본 세트에 연결하는 데 문제가 있다면 Docker가 실행 중인지 확인해주세요. 또한 host.docker.internal 호스트명이 호스트 머신의 IP 주소로 해석될 수 있도록도 확인해주세요.\n\nWindows에서는 호스트 파일에 \\*.docker.internal 호스트명을 자동으로 추가하는 설정이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinux에서 host.docker.internal을 해결할 수 없는 경우, host.docker.internal을 IP 주소 127.17.0.1로 매핑하기 위해 /etc/hosts 파일에 한 줄을 추가해야 합니다.\n\n# healthcheck에 대한 추가 사항\n\n여기에서 healthcheck을 사용하여 복제 세트를 초기화하는 장점은 docker-compose.yml 파일이 자체 포함되어 있습니다. 수동으로 복제 세트를 초기화하는 것을 선호하는 경우, healthcheck 섹션을 제거하고 rs.initiate() mongosh 명령을 사용하여 복제 세트를 초기화할 수 있습니다.\n\n```js\ndocker compose exec mongo1 mongosh --port 27017 --quiet --eval \"rs.initiate({...})\" --json relaxed\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 docker-compose.yml 파일을 사용할 모든 개발자 여러분께서는 적어도 한 번은 이 작업을 기억해야 합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_0.png"},"coverImage":"/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_0.png","tag":["Tech"],"readingTime":8},{"title":"코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법","description":"","date":"2024-06-23 22:54","slug":"2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven","content":"\n![이미지](/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_0.png)\n\n컨테이너화는 애플리케이션을 배포하는 방식을 혁신적으로 변화시켰습니다. 환경별 일관성을 제공하고 배포 프로세스를 간소화합니다. 이 가이드에서는 Maven을 사용하여 스프링 부트 애플리케이션을 원활하게 도커화하는 방법을 살펴보겠습니다. 개발부터 프로덕션까지 스무스하고 효율적인 워크플로우를 보장합니다.\n\n필수 사항\n\n1. Spring Boot 및 Maven의 기본 지식\n2. 시스템에 Docker가 설치되어 있어야 함\n\n단계 1: 스프링 부트 애플리케이션 설정하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 Spring Boot 애플리케이션을 만들려면 spring initializer (https://start.spring.io/)를 사용하세요. Spring web, Spring Boot dev tools와 같은 기본 종속성을 포함하세요.\n\n![spring initializer](/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_1.png)\n\n단계 2: Maven의 pom.xml에 도커 Maven 플러그인을 추가하세요.\n\nio.fabric8 플러그인은 Maven을 위한 도커 관련 활동의 공식 플러그인입니다.\n이제 새로운 \"containerize\"라는 Maven 프로필을 만들고 해당 프로필에서 도커-Maven 플러그인을 사용할 것입니다. 코드 스니펫을 추가했고, 코드를 설명하기 위해 주석을 사용했습니다.\n이 플러그인의 문서는 여기서 확인할 수 있습니다: https://dmp.fabric8.io/\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003cprofile\u003e\n  \u003cid\u003econtainerize\u003c/id\u003e\n  \u003cbuild\u003e\n   \u003cplugins\u003e\n    \u003cplugin\u003e\n     \u003cgroupId\u003eio.fabric8\u003c/groupId\u003e\n     \u003cartifactId\u003edocker-maven-plugin\u003c/artifactId\u003e\n     \u003cversion\u003e0.44\u003c/version\u003e\n     \u003cconfiguration\u003e\n      \u003cimages\u003e\n       \u003cimage\u003e\n        \u003c!--플레이스홀더의 명명법입니다.\n          %g=매이븐 그룹 이름의 마지막 부분은 여기에서 중요합니다.\n          %v=프로젝트 버전. ${project.version}과 동의어입니다.\n           ....................................... --\u003e\n        \u003cname\u003e%g/docker-containerize:%v\u003c/name\u003e\n        \u003c!-- ....................................... --\u003e\n         \u003c!-- 이미지 생성을위한 빌드 구성 --\u003e\n        \u003c!-- ....................................... --\u003e\n        \u003cbuild\u003e\n         \u003cdockerFile\u003eDockerfile\u003c/dockerFile\u003e\n         \u003cassembly\u003e\n          \u003c!--매븐 어셈블리 플러그인에 대한 자세한 내용은 다음에서 찾을 수 있습니다:\n          https://maven.apache.org/plugins/maven-assembly-plugin/assembly.html--\u003e\n          \u003cbasedir\u003e/\u003c/basedir\u003e\n          \u003cinline xmlns=\"http://maven.apache.org/ASSEMBLY/2.2.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n              xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\"\u003e\n           \u003cfileSets\u003e\n            \u003cfileSet\u003e\n             \u003cdirectory\u003e${project.basedir}/src/main/docker\u003c/directory\u003e\n             \u003coutputDirectory\u003e/\u003c/outputDirectory\u003e\n             \u003cincludes\u003e\n              \u003cinclude\u003edocker-entrypoint.sh\u003c/include\u003e\n             \u003c/includes\u003e\n             \u003cfileMode\u003e755\u003c/fileMode\u003e\n            \u003c/fileSet\u003e\n            \u003cfileSet\u003e\n             \u003cdirectory\u003e${project.basedir}/target\u003c/directory\u003e\n             \u003coutputDirectory\u003e/\u003c/outputDirectory\u003e\n             \u003cincludes\u003e\n              \u003cinclude\u003econtainerize-*.jar\u003c/include\u003e\n             \u003c/includes\u003e\n             \u003cfileMode\u003e755\u003c/fileMode\u003e\n            \u003c/fileSet\u003e\n           \u003c/fileSets\u003e\n          \u003c/inline\u003e\n         \u003c/assembly\u003e\n         \u003ctags\u003e\n          \u003ctag\u003e${project.version}\u003c/tag\u003e\n          \u003ctag\u003elatest\u003c/tag\u003e\n         \u003c/tags\u003e\n        \u003c/build\u003e\n       \u003c/image\u003e\n      \u003c/images\u003e\n     \u003c/configuration\u003e\n     \u003c!-- 라이프사이클에 훅 달기 --\u003e\n     \u003cexecutions\u003e\n      \u003cexecution\u003e\n       \u003cid\u003ebuild\u003c/id\u003e\n       \u003cgoals\u003e\n        \u003cgoal\u003ebuild\u003c/goal\u003e\n       \u003c/goals\u003e\n      \u003c/execution\u003e\n     \u003c/executions\u003e\n    \u003c/plugin\u003e\n   \u003c/plugins\u003e\n  \u003c/build\u003e\n \u003c/profile\u003e\n```\n\n```js\n위 구성에 대한 중요 사항:\n\nDockerFile -\u003e 이 플러그인은 src/main/docker 디렉토리에 배치된 도커 파일을 자동으로 가져올 것입니다.\n도커 파일의 이름만 전달해주면 됩니다. 여기서는 \u003cdockerFile\u003eDockerfile\u003c/dockerFile\u003e을 전달했습니다.\n\nAssembly plugin -\u003e \u003cbuild\u003e 내부의 \u003cassembly\u003e 요소는 XML 구조를 가지며, 빌드 아티팩트 및 기타 파일이\n도커 이미지로 진입하는 방식을 정의합니다. 여러 \u003cassembly\u003e 요소를 추가하여 명시할 수 있습니다.\n어셈블리 플러그인에 대한 자세한 내용은 여기에서 확인할 수 있습니다.\n\noutputDirectory -\u003e 이 플러그인에서 사용할 기본 출력 디렉터리입니다. 기본 값은 target/docker의\n매이븐 디렉터리입니다. 사용자는 이 디렉터리를 변경할 수 있는 옵션을 가지고 있습니다.\n\nFileSets -\u003e List\u003cFileSet\u003e 유형의 파일 설정으로, 포함된 각 모듈에서 어떤 그룹의 파일을 어셈블리에 포함할지 지정합니다.\n한 개 이상의 \u003cfileSet\u003e 하위 요소를 제공하여 fileSet을 지정합니다.\n여기서는 도커 파일에 필요한 어플리케이션 jar 및 docker-entrypoint.sh를 포함했습니다.\n\ntags -\u003e 빌드 후 이미지를 태깅할 추가 태그 요소 목록입니다. 여기서는 tag를 'latest'로 추가했으므로,\n이 플러그인은 이미지를 생성하고 해당 이미지에 'latest' 태그를 지정합니다.\nI이로 인해, 이 구성으로 2개의 이미지가 생성될 것입니다.\n```\n\nStep 3: Docker 파일 추가\n\n자바 17을 기본 이미지로 사용하는 Docker 파일을 작성합시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n###########################################################################\n# Dockerfile - Spring Boot Application Runner\n###########################################################################\n\n# 기본 이미지를 java17로 설정합니다.\n\nFROM openjdk:17-oracle\n\n# 파일 작성자 / 유지 관리자\nLABEL org.medium.image.authors=\"tauseef\"\n\n# 기본 환경 변수 정의\nENV APP_HOME=/opt/medium/containerize\n# 실행 가능한 artifact의 이름\nENV ARTIFACT_NAME=containerize-*.jar\n# Java 디버그 포트\nENV DEBUG_PORT=8000\n\n# 모든 artifact를 홈 디렉토리로 복사합니다\n# maven/에서 \u003cassembly\u003e 섹션에 지정된 파일은 수동으로 추가해야 합니다\nCOPY /maven/docker-entrypoint.sh /\nCOPY /maven/$ARTIFACT_NAME ${APP_HOME}/\n\n# 권한 부여\nUSER root\nRUN chmod 755 /docker-entrypoint.sh\n\n# 디렉토리에 쓰기 액세스를 위해 777 권한을 설정합니다\nRUN chmod -R 777 /opt/medium\n\n# 작업 디렉토리 설정\nWORKDIR /opt/medium\n\n# 주요 명령어\nUSER 185\nENTRYPOINT [\"/docker-entrypoint.sh\"]\n```\n\n이 도커 파일에서 ENTRYPOINT를 사용하고 있으며 이는 docker-entrypoint.sh를 가리킵니다. 파일은 다음과 같습니다.\n\n```js\n#!/bin/sh\nset -e\n\necho 'Starting containerize Spring Boot App'\n\nif [ \"$DEBUG\" = true ]; then\n  printf \"Running the application in debug mode\\n\"\n  JAVA_OPTS=\"$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:$DEBUG_PORT\"\nfi\n\n# 애플리케이션이 PID 1을 취하고 Docker stop 명령에 의해 보내진 SIGTERM을 수신할 수 있도록 합니다.\n# 여기를 참조하세요: https://docs.docker.com/engine/reference/builder/#/entrypoint\nexec java $JAVA_OPTS \\\n       -Djava.security.egd=file:/dev/./urandom -jar \\\n       ${APP_HOME}/$ARTIFACT_NAME\n\n# 인터럽트가 발생할 때까지 컨테이너를 계속 실행합니다\nsleep infinity\n```\n\nStep 4: 메이븐 프로필을 사용하여 이미지를 빌드합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 설정이 완료되었고, 이제 우리 애플리케이션의 이미지를 생성할 준비가 되었어요. 다음 명령어를 실행해봐요.\n\n```js\nmvn clean install -Pcontainerize\n```\n\n이 명령어는 docker-maven 플러그인을 실행시키고 이미지를 생성할 거에요. 빌드에 성공하면 터미널에 다음 로그 라인을 볼 수 있을 거에요.\n\n```js\n[INFO] DOCKER\u003e [medium/docker-containerize:0.0.1-SNAPSHOT]: Created docker-build.tar in 318 milliseconds\n[INFO] DOCKER\u003e [medium/docker-containerize:0.0.1-SNAPSHOT]: Built image sha256:e091d\n[INFO] DOCKER\u003e medium/docker-containerize:0.0.1-SNAPSHOT: Removed dangling image sha256:ea18f\n[INFO] DOCKER\u003e [medium/docker-containerize:0.0.1-SNAPSHOT]: Tag with 0.0.1-SNAPSHOT,latest\n[INFO] DOCKER\u003e Tagging image medium/docker-containerize:0.0.1-SNAPSHOT successful!\n[INFO] DOCKER\u003e Tagging image medium/docker-containerize:latest successful!\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 명령어를 실행하여 확인해주세요\n\n![image1](/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_2.png)\n\n이제 다음 이미지를 실행해주세요\n\n![image2](/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n따라서 컨테이너가 성공적으로 시작되었습니다.\n\n단계 5: 도커 메이븐 플러그인을 사용한 준비된 조립품\n\n도커 메이븐 플러그인은 사용자가 자세한 내용에 들어가서 조립품을 작성할 필요가 없도록 준비된 조립품을 지원합니다. 이는 descriptor-ref를 통해 수행할 수 있습니다. 조립품에서 지원되는 아티팩트 목록은 여기에서 찾을 수 있습니다.\n이 설명서를 따라, 우리는 pom 파일의 구성을 다음과 같이 수정하기만 하면 됩니다.\n\n```xml\n\u003cprofile\u003e\n   \u003cid\u003econtainerize2\u003c/id\u003e\n   \u003cbuild\u003e\n    \u003cplugins\u003e\n     \u003cplugin\u003e\n      \u003cgroupId\u003eio.fabric8\u003c/groupId\u003e\n      \u003cartifactId\u003edocker-maven-plugin\u003c/artifactId\u003e\n      \u003cconfiguration\u003e\n       \u003cimages\u003e\n        \u003cimage\u003e\n         \u003c!-- 플레이스홀더의 명명법\n          %g= Maven 그룹 이름의 마지막 부분은 여기서 미디엄에 해당합니다\n          %v= 프로젝트 버전. ${project.version}의 동의어\n          ....................................... --\u003e\n         \u003cname\u003e%g/docker-containerize2:%v\u003c/name\u003e\n         \u003c!-- ....................................... --\u003e\n         \u003c!-- 이미지 생성을 위한 빌드 구성 --\u003e\n         \u003c!-- ....................................... --\u003e\n         \u003cbuild\u003e\n          \u003cdockerFile\u003eDockerfile2\u003c/dockerFile\u003e\n          \u003cassemblies\u003e\n           \u003cassembly\u003e\n            \u003cdescriptorRef\u003eartifact\u003c/descriptorRef\u003e\n           \u003c/assembly\u003e\n          \u003c/assemblies\u003e\n          \u003ctags\u003e\n           \u003ctag\u003e${project.version}\u003c/tag\u003e\n           \u003ctag\u003elatest\u003c/tag\u003e\n          \u003c/tags\u003e\n         \u003c/build\u003e\n        \u003c/image\u003e\n       \u003c/images\u003e\n      \u003c/configuration\u003e\n      \u003c!-- 라이프사이클에 훅하기 --\u003e\n      \u003cexecutions\u003e\n       \u003cexecution\u003e\n        \u003cid\u003edocker-build\u003c/id\u003e\n        \u003cgoals\u003e\n         \u003cgoal\u003ebuild\u003c/goal\u003e\n        \u003c/goals\u003e\n       \u003c/execution\u003e\n      \u003c/executions\u003e\n     \u003c/plugin\u003e\n    \u003c/plugins\u003e\n   \u003c/build\u003e\n  \u003c/profile\u003e\n```\n\n```xml\n만약 주목했다면 다음과 같이 전달하기만 하면 됩니다.\n            \u003cassembly\u003e\n            \u003cdescriptorRef\u003eartifact\u003c/descriptorRef\u003e\n           \u003c/assembly\u003e\n그리고 이것은 jar 파일을 target/docker의 maven 디렉토리로 복사하고\n거기서 Docker 파일이 jar 파일을 선택할 것입니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결론\nSpring Boot 애플리케이션을 컨테이너화하는 것은 배포 프로세스를 효율적으로 만들 뿐만 아니라 다양한 환경에서의 확장성과 일관성을 향상시킵니다. 오늘부터 Spring Boot 프로젝트를 컨테이너화하여 현대적인 애플리케이션 배포의 혜택을 직접 경험해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_0.png"},"coverImage":"/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_0.png","tag":["Tech"],"readingTime":11},{"title":"Ubuntu 2204에 Docker Desktop 설치하는 방법","description":"","date":"2024-06-23 22:53","slug":"2024-06-23-HowToInstallDockerDesktoponUbuntu2204","content":"\n\u003cimg src=\"/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_0.png\" /\u003e\n\n이 블로그에서는 Ubuntu 22.04에 Docker Desktop을 설정하는 방법을 살펴보겠습니다.\n\nDocker Desktop:\n\nDocker Desktop은 macOS, Linux 및 Windows 컴퓨터용 응용 프로그램으로, 컨테이너화된 응용 프로그램 및 마이크로서비스를 빠르고 안전하게 구축하고 공유할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDocker Desktop에는 응용 프로그램 개발을 위한 내장 Kubernetes 설정이 포함되어 있으며, 인증된 이미지, 템플릿, 그리고 원하는 언어와 도구를 사용할 수 있습니다. 개발 워크플로우는 Docker Hub를 활용하여 개발 환경을 안전한 저장소로 확장하여 빠른 자동 빌드, 지속적 통합 및 안전한 협업을 지원합니다.\n\n## 준비 사항\n\nPC가 다음 기본 요구 사항을 충족하는지 확인해주세요.\n\n- 가상화 지원이 활성화된 64비트 CPU\n- 적어도 4GB RAM\n- GUI 데스크톱 환경 (가능하면 GNOME, MATE 또는 KDE)\n- 관리자 권한이 있는 Sudo 사용자\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# KVM 가상화 지원\n\n호스트가 가상화 지원을 하는 경우 kvm 모듈은 자동으로 로드됩니다. 모듈을 수동으로 로드하려면 다음을 실행하세요:\n\n```js\nmodprobe kvm\n```\n\n호스트 머신의 프로세서에 따라 해당 모듈을 로드해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmodprobe kvm_intel  # 인텔 프로세서\nmodprobe kvm_amd    # AMD 프로세서\n```\n\n단계 1: Gnome 데스크톱이 없는 상황에서는 Gnome 터미널을 설치해야 합니다:\n\n```js\nsudo apt install gnome-terminal\n```\n\n단계 2: Linux용 Docker Desktop의 기술 미리보기 또는 베타 버전을 제거하세요. 실행하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsudo apt remove docker-desktop\n```\n\n# 우분투 22.04에 Docker 설치하기:\n\n이제 Docker를 설치해봅시다. 하지만 그 전에 패키지 목록을 업데이트하고 필수 종속성을 설치해야 합니다. 다음과 같이 입력해주세요.\n\n```js\n$ sudo apt update\n$ sudo apt install software-properties-common curl apt-transport-https ca-certificates -y\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설치가 완료되면 Docker의 GPG 서명 키를 추가해주세요.\n\n```js\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/docker-archive-keyring.gpg\n```\n\n다음으로, 아래와 같이 시스템에 공식 Docker 저장소를 추가해주세요.\n\n```js\n$ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레포지토리가 준비되었으면 다음과 같이 Docker 및 기타 도커 도구를 설치합니다.\n\n```js\n$ sudo apt install docker-ce docker-ce-cli containerd.io uidmap -y\n```\n\n도커가 실행 중인지 확인하려면 다음 명령어를 실행하세요:\n\n```js\nsudo systemctl status docker\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Docker 버전을 확인하는 방법입니다.\n\n```js\ndocker version\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우분투 22.04에 Docker Desktop 설치 방법:\n\n아래 wget 명령어를 사용하여 Docker Desktop을 설치하세요. Docker Desktop의 최신 버전은 Docker Desktop 버전 4.19.0입니다.\n\n```js\n$ wget https://desktop.docker.com/linux/main/amd64/docker-desktop-4.19.0-amd64.deb\n```\n\n또한 이 링크에서 DEB 패키지를 다운로드할 수 있고 아래 명령어를 사용하여 설치할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n$ sudo apt install ./docker-desktop-*-amd64.deb\n```\n\n![Docker Desktop Installation](/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_3.png)\n\n도커 데스크톱을 실행하세요:\n\n이제 애플리케이션 메뉴에서 도커 데스크톱을 실행하고 라이센스 약관을 수락하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_4.png\" /\u003e\n\n이제 CLI에서 명령어 대신 도커 데스크톱에서 컨테이너를 만들 수 있어요.\n\n즐거운 학습 되세요!\n","ogImage":{"url":"/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_0.png"},"coverImage":"/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_0.png","tag":["Tech"],"readingTime":6},{"title":"Docker 볼륨 이해하기 완벽 가이드","description":"","date":"2024-06-23 22:52","slug":"2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide","content":"\n도커(Docker)의 컨테이너는 상태를 유지하지 않고 쉽게 폐기할 수 있는 방식으로 설계되었습니다. 볼륨(Volumes)은 컨테이너가 생성하고 사용하는 데이터를 단일 컨테이너의 수명 주기를 넘어서 계속 유지하는 방법을 제공합니다. 이는 데이터베이스, 파일 저장소 및 지속적인 저장 공간이 필요한 다른 응용 프로그램에 필수적입니다.\n\n본 문서는 도커 볼륨을 생성하고 사용하는 다양한 방법을 탐구하며, 실제 응용 사례를 설명하기 위한 예제가 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Docker Volume 소개\n\nDocker 볼륨은 Docker 컨테이너에서 생성된 데이터를 저장하고 사용하기 위해 설계된 지속적인 저장 메커니즘입니다. 이들은 데이터 수명주기를 컨테이너 수명주기와 분리하여 데이터가 컨테이너가 삭제되거나 다시 생성되더라도 손상되지 않도록 보장합니다.\n\n# Docker Volume의 종류\n\n## Named Volumes\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이름이 지정된 볼륨은 사용자가 정의한 볼륨으로, 이름으로 쉽게 참조하고 여러 컨테이너 간에 재사용할 수 있습니다. 이러한 볼륨은 Docker의 내부 볼륨 저장소에 저장됩니다.\n\n```js\ndocker volume create myVolume\ndocker run -d --name my_container -v myVolume:/data node_container\n```\n\n## 익명 볼륨\n\n이름이 지정되지 않은 볼륨은 생성된 이름이 없을 때 생성됩니다. 이러한 볼륨들은 일반적으로 컨테이너의 수명주기를 넘어서 지속되지 않아야 하는 일시적인 데이터에 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 실행 -d --name my_container -v /data node_container\n```\n\n## 바인드 마운트\n\n바인드 마운트는 호스트 파일 시스템의 디렉터리나 파일을 컨테이너에 매핑합니다. 이를 통해 호스트 파일 시스템에 직접 액세스하여 데이터를 호스트와 컨테이너 간에 공유해야하는 시나리오에 이상적입니다.\n\n```js\n도커 실행 -d --name my_container -v /호스트/경로:/data node_container\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## tmpfs 볼륨\n\ntmpfs 볼륨은 컨테이너의 메모리에 임시 파일 시스템을 마운트합니다. 민감한 정보나 임시 파일과 같이 디스크에 쓰여서는 안 되는 비영구 데이터를 저장하는 데 유용합니다.\n\n```js\ndocker run -d --name my_container --tmpfs /data node_container\n```\n\n# Docker 볼륨 생성 및 관리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 볼륨 만들기\n\n이름이 지정된 볼륨을 만들려면 다음 명령을 사용하세요:\n\n```js\ndocker volume create myVolume\n```\n\n## 볼륨 검사\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n볼륨을 검사하고 세부 정보를 확인하려면\n\n```js\ndocker volume inspect myVolume\n```\n\n## 볼륨 제거\n\n더 이상 필요하지 않은 볼륨을 제거하려면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 볼륨 삭제 myVolume\n```\n\n![이미지](/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_2.png)\n\n# 도커 볼륨 사용하기\n\n## 명명된 볼륨 마운트하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 이름의 볼륨을 컨테이너에 마운트하려면:\n\n```js\ndocker run -d -v myVolume:/app/data myImage\n```\n\n## 익명 볼륨 마운트\n\n익명 볼륨을 마운트하려면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 실행 -d -v /app/data myImage\n```\n\n## 바인드 마운트 사용하기\n\n바인드 마운트를 사용하려면 호스트 경로와 컨테이너 경로를 지정하십시오:\n\n```js\n도커 실행 -d -v /host/data:/app/data myImage\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 예시\n\n## 1. 이름있는 볼륨을 사용하여 데이터 유지하기\n\n이름이 지정된 볼륨을 생성하고 컨테이너에서 사용하기\n\n```js\ndocker volume create mydata\ndocker run -d -v mydata:/app/data myImage\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컨테이너 내부의 /app/data 경로에 작성된 모든 데이터는 컨테이너가 삭제되더라도 유지됩니다.\n\n## 2. 컨테이너 간 데이터 공유\n\n여러 컨테이너 간 데이터를 공유하려면 명명된 볼륨을 사용할 수 있습니다:\n\n```js\ndocker volume create shared_data\ndocker run -d -v shared_data:/app/data container1\ndocker run -d -v shared_data:/app/data container2\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Understanding Docker Volumes](/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_3.png)\n\n두 컨테이너 모두 /app/data에 읽고 쓸 수 있어 데이터 공유가 가능합니다.\n\n## 개발을 위한 Bind Mount 사용\n\n호스트 디렉토리를 컨테이너에 매핑하는 Bind Mount를 사용하여 실시간 코드 변경을 가능하게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 실행 -d -v $(pwd):/app myImage\n```\n\n호스트 디렉토리의 파일에 대한 변경 사항은 즉시 컨테이너에 반영됩니다.\n\n# 간단한 Node.js 애플리케이션 예제\n\n## 단계 1: Node.js 애플리케이션 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 파일에 데이터를 작성하는 간단한 Node.js 애플리케이션을 만들어봅시다:\n\n![이미지](/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_4.png)\n\n## 단계 2: Dockerfile 생성\n\n다음으로 Node.js 애플리케이션을 위한 Dockerfile을 만들어봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nFROM node:14\n\nWORKDIR /app\n\nCOPY . .\n\nCMD [\"node\", \"app.js\"]\n```\n\n## Step 3: 이제 도커 이미지를 빌드하세요\n\n![Step 3](/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_5.png)\n\n## Step 4: 컨테이너를 실행하세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_6.png\" /\u003e\n\n- myVolume: 호스트 머신에있는 볼륨의 이름입니다.\n- :/app/data: 이는 컨테이너 내부의 마운트 포인트를 지정합니다. 이 경우 호스트의 myVolume 볼륨을 컨테이너 내부의 /app/data 디렉토리로 마운트합니다.\n\n## 단계 5: data.txt 파일의 내용을 확인합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_7.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_8.png\" /\u003e\n\n# 도커 볼륨 사용에 대한 최상의 방법\n\n- 컨테이너 수명 주기를 초과하는 데이터에 사용할 때는 명명된 볼륨을 사용합니다.\n- 개발 목적이거나 호스트 파일에 직접 액세스해야 할 때는 바인드 마운트를 사용합니다.\n- 사용되지 않는 볼륨을 정기적으로 검사하고 정리하여 공간을 확보합니다.\n- 보안 위험을 피하기 위해 바인드 마운트를 사용할 때 올바른 액세스 권한을 보장합니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 볼륨은 컨테이너화된 응용 프로그램의 유연성과 효율성을 향상시키는 강력한 기능입니다. 다양한 유형의 볼륨을 이해하고 관리하는 방법을 알면 도커를 사용하여 컨테이너 내에서 데이터를 지속적으로 유지, 공유 및 관리할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것","description":"","date":"2024-06-23 22:50","slug":"2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide","content":"\n\u003cimg src=\"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png\" /\u003e\n\n# 소개\n\nKubernetes는 컨테이너 오케스트레이션을 혁신하여 기업이 규모에 맞게 응용 프로그램을 배포하고 관리할 수 있게 하였습니다. Kubernetes의 주요 구성요소 중 하나인 pod는 하나 이상의 강하게 결합된 컨테이너들의 논리적 그룹입니다. pod가 서로 통신하는 방식을 이해하는 것은 Kubernetes 클러스터에서 탄력적이고 확장 가능한 응용 프로그램을 구축하는 데 중요합니다. 이 블로그 게시물에서는 Kubernetes pod 간 통신에 대해 깊이 알아보고 다양한 통신 패턴과 기술을 탐구할 것입니다.\n\n# Pod 네트워킹 이해하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠버네티스에서 Pods는 클러스터 내에서 고유한 IP 주소가 할당되어 직접 통신할 수 있습니다. 기본적으로 각 Pod는 격리되어 고유한 IP 주소를 가지며, 안전한 통신을 가능하게 하고 포트 충돌을 피할 수 있습니다. 이러한 IP 주소는 외부 액세스를 위해 특정 구성이 없는 한 쿠버네티스 클러스터 네트워크 내에서만 접근 가능합니다.\n\n# 쿠버네티스 네트워킹 모델\n\n- 동일 노드 내 Pod 간 통신: 동일한 노드에 여러 개의 Pod가 예약되면 localhost 또는 루프백 인터페이스를 사용하여 직접 통신할 수 있습니다. 이 통신은 주로 가상 이더넷(veth) 쌍 형태로 클러스터 내에 할당된 Pod의 IP 주소를 통해 이루어집니다. 이 통신은 네트워크 계층에서 발생하여 동일 노드의 Pod 간 높은 성능과 낮은 지연 시간 상호작용을 가능하게 합니다.\n- 노드 간 Pod 간 통신: 클러스터 내 서로 다른 노드 간에 통신이 필요한 경우, 쿠버네티스는 다양한 네트워킹 솔루션인 Container Network Interfaces (CNIs) 및 소프트웨어 정의 네트워킹(SDN) 기술을 활용합니다. 이러한 솔루션은 전체 클러스터를 가로지르는 가상 네트워크 오버레이를 생성하여 노드 간 Pod 간 통신을 가능하게 합니다. Calico, Flannel, Weave, Cilium 등이 인기 있는 CNIs 중 일부이며, 이러한 네트워킹 솔루션은 Pod의 IP 주소가 Reachable하도록 보장하며, 클러스터 내에서 Pod의 위치에 관계없이 투명한 네트워크 연결성을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 쿠버네티스 클러스터 내의 파드는 내부 IP 주소를 사용하여 서로 통신할 수 있습니다. 이 통신은 백그라운드의 컨테이너 런타임이나 네트워크 플러그인에서 제공하는 가상 네트워크 오버레이를 통해 이루어집니다. 내부 IP 주소는 쿠버네티스 클러스터 네트워킹 솔루션에 의해 할당되며 클러스터 내에서만 라우터링됩니다.\n\n# DNS 기반 서비스 검색\n\n쿠버네티스는 클러스터 내에서 서비스 검색을 위한 내장 DNS 서비스를 제공합니다. 서비스들은 기본 파드를 추상화한 안정적인 엔드포인트 역할을 합니다. 각 서비스는 DNS 이름이 할당되며, 해당 서비스를 지원하는 파드의 IP 주소로 해석됩니다. 이 DNS 기반 접근 방식을 통해 파드는 개별 파드 IP 주소를 직접 참조하는 대신 서비스 이름을 사용하여 서로 통신할 수 있습니다.\n\n# 서비스 로드 밸런싱\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 개의 팟이 동일한 애플리케이션을 제공할 때, Kubernetes는 이러한 팟들 간의 트래픽을 분산하는 데 사용하는 내장된 로드 밸런싱 기능을 제공합니다. 서비스 객체를 생성하고 이를 일련의 팟과 연결함으로써, Kubernetes는 사용 가능한 팟들 사이에 들어오는 요청을 자동으로 로드 밸런싱합니다. 이 로드 밸런싱 메커니즘은 애플리케이션의 고가용성과 확장성을 보장합니다.\n\n# 네트워크 정책\n\nKubernetes는 팟 간의 트래픽 흐름을 제어하기 위한 수단으로 네트워크 정책을 제공합니다. 네트워크 정책은 IP 주소, 포트 및 프로토콜과 같은 다양한 매개변수를 기반으로 어떤 팟이 서로 통신할 수 있는지를 지정하는 규칙을 정의합니다. 네트워크 정책을 시행함으로써, 애플리케이션의 네트워크 트래픽을 세분화하고 추가적인 보안 층을 추가할 수 있습니다.\n\n# 외부 통신\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKubernetes 클러스터 바깥의 리소스와 통신해야 하는 팟이 자주 있습니다. 외부 서비스나 데이터베이스와 통신하는 방법을 용이하게 해주는 여러 메커니즘이 Kubernetes에서 제공됩니다. 한 가지 접근법은 서비스 유형이 \"LoadBalancer\" 또는 \"NodePort\"인 서비스를 사용하여 팟 또는 팟 세트를 노출하는 것으로, 외부 클라이언트가 팟에 액세스할 수 있게 합니다. 또 다른 옵션은 Ingress 컨트롤러를 사용하는 것인데, 이를 통해 외부 클러스터로부터 들어오는 트래픽을 정의된 규칙에 따라 적절한 팟으로 라우팅할 수 있습니다.\n\n# 서비스 메쉬\n\n고급 네트워킹 시나리오를 위해, 서비스 메쉬를 사용하여 팟 간 통신을 강화할 수 있습니다. Istio나 Linkerd와 같은 서비스 메쉬는 Kubernetes 클러스터 상단에 있는 레이어로써 트래픽 관리, 관찰가능성, 보안과 같은 기능을 제공합니다. 서비스 메쉬를 사용하면 고급 라우팅 규칙, 회로 차단, 분산 추적을 통해 팟 간 통신을 제어하고 모니터링할 수 있습니다.\n\n# 예시\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKubernetes에서 pod 간 통신을 구성하는 방법을 보여드리기 위해 예제 사양을 살펴보겠습니다. 이 예제에서는 서비스를 사용하여 두 개의 파드를 생성하고 그들 간의 통신을 수립할 것입니다.\n\n- Pod A 생성: 먼저 간단한 웹 애플리케이션을 실행하는 Pod A를 생성해 보겠습니다. pod-a.yaml이라는 파일을 만들고 아래 내용을 추가하세요:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-a\nspec:\n  containers:\n    - name: web-app\n      image: your-web-app-image\n      ports:\n        - containerPort: 8080\n```\n\n\"your-web-app-image\"를 사용 중인 웹 애플리케이션의 적절한 이미지로 교체해 주세요. 이 사양은 지정된 포트 8080이 노출된 상태로 \"pod-a\"라는 이름의 파드를 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Pod B를 생성하세요: 이제 Pod A와 통신하는 클라이언트 Pod인 Pod B를 생성해 봅시다. pod-b.yaml이라는 파일을 만들고 다음 내용을 추가해 주세요:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-b\nspec:\n  containers:\n    - name: client-app\n      image: your-client-app-image\n      command: [\"sleep\", \"infinity\"]\n```\n\nyour-client-app-image를 사용하고 있는 클라이언트 어플리케이션에 해당하는 이미지로 변경해 주세요. 이 명세는 \"pod-b\"라는 이름의 pod를 생성하고, 해당 컨테이너를 실행하여 pod를 계속 실행 상태로 유지할 수 있는 무한 sleep 명령을 실행합니다.\n\n3. 서비스 생성하기: Pod A와 Pod B 간의 통신을 가능하게 하기 위해 안전한 엔드포인트로 작동하는 서비스를 생성할 것입니다. service.yaml이라는 파일을 만들고 다음 내용을 추가하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: pod-service\nspec:\n  selector:\n    app: web-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n```\n\n이 구성은 \"pod-service\"라는 서비스를 생성하며, 이 서비스는 app: web-app 라벨을 가진 파드를 대상으로합니다 (우리가 Pod A에 추가 할 것입니다). 이 서비스는 포트 80을 노출하고 선택한 파드의 포트 8080으로 트래픽을 전달합니다.\n\n4. 설정 적용: 다음 명령을 사용하여 생성된 구성을 적용하십시오:\n\n```yaml\nkubectl apply -f pod-a.yaml\nkubectl apply -f pod-b.yaml\nkubectl apply -f service.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 쿠버네티스 클러스터에 Pod A, Pod B 및 서비스가 생성됩니다.\n\n5. 통신 테스트: 통신을 테스트하려면 Pod B에 접속하여 서비스의 DNS 이름을 사용하여 Pod A에 요청을 보낼 수 있습니다. 다음 명령어를 실행하세요:\n\n```sh\nkubectl exec -it pod-b -- sh\n```\n\nPod B 쉘에 들어간 후에 curl과 같은 도구를 사용하여 Pod A에 요청을 보낼 수 있습니다. 서비스 명세서에서 다른 이름을 사용했다면 실제 서비스 이름으로 pod-service를 대체하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ncurl pod-service\n```\n\n이 명령은 서비스로 요청을 보내어 트래픽을 로드 밸런싱하고 Pod A로 전달합니다.\n\n여기까지입니다! 이제 쿠버네티스에서 서비스를 사용하여 pod 간 통신을 설정했습니다. 다양한 통신 패턴을 탐색하거나 네트워크 정책을 적용하거나 특정 요구 사항을 충족시키기 위해 추가적인 쿠버네티스 기능을 활용하여 이 예시를 확장할 수 있습니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그를 변경하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":8}],"page":"13","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"13"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>