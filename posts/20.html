<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/20" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/20" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="2024년 최신 AWS API Gateway 사용 방법 및 기능 완벽 가이드" href="/post/2024-06-23-AWSAPIGateway"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 최신 AWS API Gateway 사용 방법 및 기능 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AWSAPIGateway_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 최신 AWS API Gateway 사용 방법 및 기능 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년 최신 AWS API Gateway 사용 방법 및 기능 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법" href="/post/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS Glue CI CD 간소화하는 방법" href="/post/2024-06-23-StreamliningAWSGlueCICD"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS Glue CI CD 간소화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-StreamliningAWSGlueCICD_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS Glue CI CD 간소화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS Glue CI CD 간소화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법" href="/post/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법" href="/post/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS Powertools를 사용해 Serverless API 문서화 하는 방법" href="/post/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS Powertools를 사용해 Serverless API 문서화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS Powertools를 사용해 Serverless API 문서화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS Powertools를 사용해 Serverless API 문서화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시" href="/post/2024-06-23-ReflectionsandBasicWebApplicationArchitecture"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="몇 번의 클릭으로 IAM 정책 시각화 하는 방법" href="/post/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="몇 번의 클릭으로 IAM 정책 시각화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="몇 번의 클릭으로 IAM 정책 시각화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">몇 번의 클릭으로 IAM 정책 시각화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라우드 보안 전략을 만드는 궁극적인 가이드" href="/post/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라우드 보안 전략을 만드는 궁극적인 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라우드 보안 전략을 만드는 궁극적인 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">클라우드 보안 전략을 만드는 궁극적인 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기" href="/post/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link posts_-active__YVJEi" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"2024년 최신 AWS API Gateway 사용 방법 및 기능 완벽 가이드","description":"","date":"2024-06-23 00:28","slug":"2024-06-23-AWSAPIGateway","content":"\n## AWS API Gateway를 효과적으로 사용하는 필수 팁\n\n![AWS API Gateway](/assets/img/2024-06-23-AWSAPIGateway_0.png)\n\n# 소개\n\n모놀리식 또는 마이크로서비스 아키텍처를 사용하더라도 API에 접근하기 위한 중앙 진입점은 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기업에서는 비즈니스의 다른 부분에 작업을 수행하는 여러 팀이 있고, 각 팀은 다른 애플리케이션에 서비스를 노출하기 위해 API를 구현합니다.\n\n시간이 지나면서 조직의 아키텍처에 대한 포괄적인 시각 없이, API 진입점, 트래픽 관리, 보안, 그리고 이러한 제어를 구현하기 위한 규칙이 없다는 문제에 직면할 수 있습니다. 이러한 도전은 특히 인터넷을 통해 상호 작용이 발생할 때 특히 어렵습니다.\n\n본 문서는 HTTP 기반 애플리케이션 상호 작용에서의 일반적인 도전 과제를 강조하고, API 게이트웨이가 이러한 문제에 대해 어떻게 대응할 수 있는지에 대해 살펴봅니다. 구체적으로 AWS API 게이트웨이 사용에 중점을 두고 구현하기 전에 알아야 할 사항에 대해 설명하겠습니다.\n\n# API 게이트웨이가 왜 필요한가\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현대 소프트웨어 아키텍처는 클라이언트가 데이터를 사용하고 생성하는 방법을 제어하고 동시에 보호 기술을 구현하는 인프라 요소가 필요합니다.\n\n이 토론에서 자주 물들어 있는 질문은 API 게이트웨이가 이 보호와 분할을 구현하는 유일한 해결책인가요? 확실한 대답은 아니에요.\n\n역 프록시나 로드 밸런서를 사용할 수 있지만 네트워킹과 관련한 여러 이유로 API 게이트웨이가 선호됩니다.\n\nAPI 게이트웨이는 OSI 모델의 응용 계층(레이어 7)에서 작동하여 기본 SSL 종료나 백엔드 인스턴스 간 요청 분배 이상의 고급 기능을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI Gateway 솔루션은 인증 및 권한 부여, 속도 제한/쓰로틀링, 액세스 로깅, HTTP 프로토콜에 대한 자세한 내용, 회로 차단기 구현 등과 같은 책임을 통합합니다.\n\nAPI Gateway를 네트워킹 아키텍처에서 DMZ와 비교할 수 있습니다.\n\n클라우드 컴퓨팅이 급부상함에 따라 소프트웨어 아키텍처 프로토타입은 레고 블록을 사용하여 구축하는 것과 같습니다. 핵심은 요구 사항과 기술을 기존 자원과 도구로 결합하는 것입니다.\n\n인터넷을 통해 API를 노출시키기 위해 여러 솔루션을 유지하고 싶지 않다면, API Gateway가 최선의 방법입니다. AWS를 사용하고 하드 제한이 문제가 되지 않는다면, AWS API Gateway가 강력한 선택입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음에는 귀하의 요구 사항에 가장 가까운 옵션을 선택하는 방법에 대해 더 자세히 설명하겠습니다.\n\n# 어떤 종류의 API 게이트웨이가 필요할까요?\n\n좋은 시작점은 AWS API Gateway 문서를 읽는 것입니다. 여기에서 REST API와 HTTP API 간의 선택 사항에 대한 자세한 내용을 찾을 수 있습니다.\n\n본 문서에서 읽을 수 있는 것과 똑같은 내용을 설명할 의도는 없지만, 리전별, 엣지, 또는 프라이빗 API 게이트웨이와 같은 엔드포인트 유형에 대한 개념을 깊이 이해하는 것의 중요성을 강조하고 싶습니다. REST API 또는 HTTP API 인스턴스에서 사용할 수 있는 각 유형에 대해 알아보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인스턴스 유형에 대한 간단한 설명은 다음과 같습니다:\n\n- 보안, 관리 및 인증 기능이 더 필요하고 수요가 지리적으로 분산되어 있다면 (인터넷을 통해) REST API 인스턴스를 사용하세요(엣지 최적화, REST API의 기본 값).\n- 동일 지리적 지역 내에서 API Gateway를 내부적으로 사용하고 수요가 낮다면 HTTP API 인스턴스(지역)를 사용하세요.\n- VPC 내에서 사용하는 경우 VPC 엔드포인트를 통해 REST API 인스턴스를 사용하세요.\n\n실제 예제를 통해 엣지 최적화 또는 지역 AWS API Gateway 인스턴스를 선택하는 차이를 보여주는 것이 중요합니다.\n\n저는 PetStore 예제를 사용하여 미국 동부 버지니아 (us-east-1) 지역에 두 개의 AWS API Gateway 인스턴스를 생성했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-AWSAPIGateway_1.png)\n\n첫 번째 인스턴스(ID w43fgx5wk6)는 엣지 최적화되었고, 두 번째 인스턴스(ID 16hx5blsm5)는 리전 최적화되었습니다.\n\nAWS API 게이트웨이 설명서에 따르면 엣지 최적화는\n\n또한, 이 정보를 HTTP 헤더 응답을 검사하여 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![AWS API Gateway](/assets/img/2024-06-23-AWSAPIGateway_2.png)\n\nx-amz-cf-pop 헤더는 예약된 HTTP 헤더이며, 이를 검사하여 엣지 최적화된 AWS API Gateway를 확인할 수 있습니다.\n\n이 ID들과 관련이 있는 POP (Points of Presence) 목록에 대해 더 많은 정보가 필요합니다. 하지만 구체적으로 링크에서 ID G1G51-P2를 발견했습니다.\n\n![AWS API Gateway](/assets/img/2024-06-23-AWSAPIGateway_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지역 인스턴스를 분석하면이 유형의 인스턴스가 POP을 통과하지 않는 것을 확인할 수 있습니다.\n\n![AWS API Gateway](/assets/img/2024-06-23-AWSAPIGateway_4.png)\n\n## 각각의 지연 시간은 무엇인가요?\n\n먼저, 각 AWS 지역과 관련된 지연 시간을 이해해야합니다. 이 측정을 위해 https://clients.amazonworkspaces.com/Health.html을 사용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AWSAPIGateway_5.png\" /\u003e\n\n위의 이미지를 보면 가장 가까운 지역은 남아메리카(상파울루)입니다. 이 정보를 기반으로 지리적으로 분산된 지연 시간을 확인하여 엣지 최적화된 AWS API 게이트웨이 인스턴스와 지역별 인스턴스의 장점을 비교할 수 있습니다.\n\n측정을 위해 저는 인터넷을 통해 전 세계의 다른 지역에서 클라이언트 경험 액세스를 시뮬레이션하는 데 사용되는 Pingdown을 사용합니다.\n\n지연 시간을 비교하기 위해 북아메리카, 남아메리카 및 아시아에서 엣지 최적화된 인스턴스 및 지역별 인스턴스에 액세스를 시뮬레이션했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 이미지는 엣지 최적화 인스턴스 (w43fgx5wk6)에 대한 결과를 보여줍니다.\n\n![AWS API Gateway](/assets/img/2024-06-23-AWSAPIGateway_6.png)\n\n북미와 라틴 아메리카 사이의 응답 시간에 주목해 주시기 바랍니다. 두 지역 간의 거리를 고려할 때, 약 20ms 차이는 미미합니다.\n\n아시아의 경우 응답 시간이 상당히 높으며, 숫자를 더 자세히 조사해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 이미지는 이전에 제시된 것과 유사하며, AWS 지역 간의 내 지연 시간을 보여줍니다. 특히, 도쿄까지의 지연 시간은 732밀리초입니다.\n\n![이미지](/assets/img/2024-06-23-AWSAPIGateway_7.png)\n\n도쿄에서 시작된 요청으로 PetStore API를 호출하는 PingDown과 비교했을 때, 도쿄에서 미국 동부 버지니아 북부까지의 지연 시간이 760밀리초임을 확인할 수 있습니다. 흥미롭게도, 도쿄에서 버지니아까지의 지연 시간은 남아메리카에서 도쿄까지의 지연 시간과 유사합니다.\n\n![이미지](/assets/img/2024-06-23-AWSAPIGateway_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n28ms의 델타에서 주요 포인트는 대부분의 시간이 네트워크 왕복 시간에 소비된다는 것입니다. 이러한 숫자들은 다양한 위치에서 아시아로의 요청 지연 시간에 대한 소중한 통찰을 제공합니다.\n\n싱가포르, 홍콩, 시드니 등 아시아의 다른 위치들은 더 나은 지연 시간 값을 보여줍니다. 여기서 중요한 점은 아메리카에서 아시아로의 요청은 적어도 이 간단한 예에서 더 높은 지연 시간 패널티가 부과된다는 것입니다. 기반 시설과 API 배포를 계획할 때 이 정보를 염두에 두세요.\n\n지역별 인스턴스에 관한 이미지는 다음과 같습니다.\n\n![이미지](/assets/img/2024-06-23-AWSAPIGateway_9.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n북미(로컬 API Gateway 인스턴스가 실행 중인 곳)에서 멀어질수록 미리측된 밀리초 증가가 더 두드러집니다. 지연 시간은 북미에서 라틴 아메리카, 그리고 아시아로 이동함에 따라 거의 두 배로 증가하는 것 같습니다.\n\n이 분석 결과, 지역 또는 엣지 최적화된 AWS API Gateway 인스턴스 중에서 선택하는 것이 솔루션의 성능에 상당한 영향을 미친다는 것을 보여줍니다.\n\n중요한 주의 사항은 테스트 기간의 시간 창이 아주 짧다는 것입니다. 이러한 숫자를 제시하는 목적은 시간이 흐름에 따라 다양한 이유로 상당히 달라질 수 있는 파트너의 경험에 대한 지연 시간 영향을 설명하기 위한 구체적인 데이터를 제공하는 것입니다.\n\n이 관점은 중요하지만 AWS API Gateway를 효과적으로 사용하기 위해서는 다른 특성들을 이해해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 어떤 요구 사항이 있나요?\n\nAWS 문서에서 속한 제한에 관한 부분을 읽을 때 중요합니다. 특히, 제한을 증가 요청할 수 없는 제한에 대한 부분이요. AWS API Gateway의 경우, 여기에서 이러한 제한을 확인할 수 있어요.\n\n귀하의 경우에 관련된 특정 제한 사항은 다를 수 있기 때문에, 사용 가능한 제한 사항과 귀하의 요구 사항을 신중히 맞추어 정보를 얻을 수 있도록 하는 것이 중요해요.\n\n고려해야 할 주요 제한 사항은 다음과 같아요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 할당량은 문서에 따라 증가될 수 있지만, 귀하의 계정과 지역에 있는 모든 AWS API Gateway 인스턴스를 고려하여 10K RPS의 양에 주의를 기울이고 싶습니다.\n\n고려해야 할 또 다른 점은 문서에서 할당량이 증가될 수 있다고 명시되어 있지만, 이를 쉽거나 싸게 처리하기 어려울 수 있습니다. 어떤 경우에는 AWS 지원팀이 요청을 정당화하고 해당 지역에서 서비스에 영향을 미치지 않도록 보장하기 위해 상세 증거를 요청할 수 있습니다.\n\nAWS API Gateway REST API 인스턴스의 최대 타임아웃은 대략 29초입니다. 대부분의 API 통신에는 충분합니다. 그러나 장기 실행이 포함된 경우 해당 제한을 염두에 두시기 바랍니다.\n\n최근 AWS는 타임아웃을 증가시킬 수 있는 가능성을 발표했지만, 이는 계정 수준의 쓰로틀 할당량 제한을 감소시키는 데에 처벌이 따릅니다. 문서에서는 쓰로틀링 할당량이 얼마나 감소할 지 명시되어 있지 않지만, 이는 중요한 고려 사항입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRPS는 동일한 계정 및 지역의 모든 API 게이트웨이 인스턴스의 요청 합계를 계산하는 것과 같이 API 키도 동일한 규칙을 따릅니다. 그러나 중요한 차이점은 API 키의 수를 늘릴 수 없으며, 모든 인스턴스 사이에서 공유되는 API 키의 하드 제한이 10K개이다.\n\n이 할당량에 대한 주요 포인트는 쓰로틀링과의 직접적인 관련성입니다. 쓰로틀링은 다양한 특성이 있으며, 제가 요약해 보겠습니다.\n\n쓰로틀링은 계정 수준에 적용될 수 있습니다.\n\n이전에 언급한대로, 계정 수준의 쓰로틀링은 모든 AWS API 게이트웨이 인스턴스의 초당 요청을 제한하기 위해 초당 모든 요청을 합계하여 적용됩니다. 이 쓰로틀링에 대해 우리는 제어할 수 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클라이언트별로 쓰로틀링을 적용하는 유일한 방법은 클라이언트를 API 키와 연관시키는 것입니다. 프로덕션 환경에서 1만 개의 API 키를 활성화하는 것은 불가능하지 않은 것으로 보입니다. 서로 다른 기준에 맞게 API 키를 관리할 수 있으므로 한 클라이언트나 클라이언트와 엔드포인트에 API 키를 사용할 수 있습니다.\n\n이러한 API 키를 쓰로틀링 제한과 연관시키는 중요한 점은 사용 계획 내에서 사용해야 한다는 것입니다.\n\n사용 계획의 할당량은 계정과 지역당 300개로 제한됩니다. 이 할당량은 증가시킬 수 있지만, 이러한 과정은 어려울 수 있고 AWS 지원팀에 상세 정보를 제공해야 할 수도 있습니다.\n\nAWS API Gateway 인스턴스를 프로토타입으로 만들어 클라이언트, 클라이언트-엔드포인트 또는 다른 전략별 API 키를 사용하려면 할당량을 초과하지 않도록 사용 계획과 API 키를 구현하고 연관시키는 것이 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 의견으로는 API 게이트웨이의 관련 기능으로 인해 클라이언트 당 쓰로틀링을 구현해야한다는 이 제한이 가장 어려운 것으로 생각됩니다. 따라서 이 제한이 솔루션에 영향을 미치지 않도록 주의하시기 바랍니다.\n\nAWS API 게이트웨이 인터페이스에서 API 키를 조회하거나 검색하려면 1만 개의 API 키에 도달하면 속도가 매우 느려질 것입니다. 반드시 관리용 API를 사용하여 이를 조회해야 할 것입니다.\n\n마지막으로, 관리용 API의 할당량이 매우 제한적이므로 이 제한도 주의 깊게 확인하셔야 합니다.\n\n# 제약사항은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 제약 사항은 다음과 같은 유형의 제한 사항을 만날 경우 파트너들과의 갈등을 야기할 수 있습니다:\n\n- 감사를 위해 요청과 응답을 저장해야 할 경우, CloudWatch에 저장할 수 있는 페이로드 크기 제한이 문제를 일으킬 수 있습니다. 이 경우 AWS API Gateway 외부에서 이 감사를 구현해야 할 수도 있습니다.\n\n- RFC 3986 (통합 자원 식별자-URI)에 따르면 세미콜론은 특정 목적을 위해 예약된 문자입니다. URI에 세미콜론이나 파이프(|)가 포함되면 요청 처리가 복잡해질 수 있습니다.\n\n- REST API의 AWS API Gateway의 기본 설정은 \"백엔드 통합에 전달하기 전에 URL 인코딩된 요청 매개 변수를 디코딩(decoding)\"하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 특별한 문제는 여러분의 파트너가 URL 인코딩을 구현해야 한다는 것입니다. 이를 역방향 프록시를 사용하여 해결하려고 하면 어려움을 겪을 수 있습니다. 이 상황을 피하기 위해 AWS Lambda@Edge와 CloudFront를 사용할 수 있지만, 과도한 엔지니어링에 주의해야 합니다.\n\n역방향 프록시 시나리오를 모의하기 위해 edge-optimized API Gateway와 URL https://w43fgx5wk6.execute-api.us-east-1.amazonaws.com/test를 사용했습니다. beeceptor.com을 사용하여 외부 역방향 프록시를 정의했는데, 다음과 같이 구성했습니다:\n\n![이미지](/assets/img/2024-06-23-AWSAPIGateway_10.png)\n\nhttps://apigateway.free.beeceptor.com/pets를 호출하면 결과가 이렇게 나옵니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-AWSAPIGateway_11.png)\n\n특정 상황에서 확인해야 할 다른 제약 사항이 있습니다. 결정을 내리기 전에 api-gateway-known-issues에서 더 많은 정보를 읽어보세요.\n\n# 결론\n\n여기서는 AWS API Gateway를 사용하기 전에 공부하고 이해해야 할 중요한 요점을 설명했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS API Gateway은 제품 환경에서 사용할 수 있는 견고한 솔루션이에요. 어떤 솔루션을 채택하기 전에 요구 사항을 이해하는 것이 중요해요. AWS API Gateway를 사용하기로 결정하는 것도 마찬가지죠.\n\n계정 당 및 리전 당 10K RPS와 관련된 할당량은 많은 경우에 적합하지만, 언제 아키텍처의 수명이 끝날지 예상하고 항상 준비해두는 것이 중요해요.\n\n이러한 통찰력이 AWS API Gateway를 효과적으로 사용하는 데 도움이 되기를 바라요.\n","ogImage":{"url":"/assets/img/2024-06-23-AWSAPIGateway_0.png"},"coverImage":"/assets/img/2024-06-23-AWSAPIGateway_0.png","tag":["Tech"],"readingTime":14},{"title":"AWS에서 이벤트 기반 아키텍처에 분산 회로 차단기 적용 방법","description":"","date":"2024-06-23 00:26","slug":"2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS","content":"\n![image](\"https://miro.medium.com/v2/resize:fit:1280/1*gGh7HhACzjtw6wplLPUyQQ.gif\")\n\n# 소개\n\n저는 이벤트 기반 아키텍처에서 이벤트 실패를 처리하는 방법에 대해 발표 자료를 준비하고 있었습니다. 어느 순간에 이를 설명할 때 회로 차단기가 필요한 이유에 대해 깊이 들어가게 되었습니다. 제 프로젝트에서 Elasticache를 기반으로 한 사용자 정의 구현을 사용했다는 것을 깨달았습니다. 그들을 설정하는 더 \"가벼운\" 방법에 대해 고민하기 시작했을 때, 서버리스 아키텍처에서 회로 차단기를 설정하는 메커니즘이 없다는 것을 깨달았습니다. 좀 더 연구해보고 이 주제에 대한 제 생각을 공유하려고 합니다.\n\n## 왜 서버리스가 특별한가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서킷 브레이커는 상태를 가지고 있습니다. 호출하기 전에 해당 상태를 확인하고 모든 요청을 추적해야 합니다. 왜냐하면 서킷 브레이커를 단일 호출 기반이 아니라 실패율(RATE) 기준으로 열기 때문입니다.\n\n우리는 람다 인스턴스 전체에 분산된 상태 대신 단일 위치에 상태를 추적해야 합니다. 다시 처음으로 돌아가 봅시다.\n\n# 왜 서킷 브레이커가 필요한가요?\n\n## 시나리오\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이벤트 처리를 상상해보세요. 여기서는 대기열에서 작업을 가져와서 제3자로부터 데이터를 로드한 다음 데이터에 대해 \"무언가\"를 수행합니다. 이제 이 데이터를 DynamoDB 테이블에 지속시키기로 했다고 가정해 봅시다.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png)\n\n## 모든 것이 실패할 때\n\n어느 날, 우리의 3rd 파티가 좋지 않은 날을 보내서 실패하기 시작할 수도 있습니다. 그 순간, 그것은 완벽할 것이고 모두가 우리가 예의 바르게 3rd 파티 시스템을 사용하는 데 존경을 기울이면 좋을 것입니다. 우리는 그들이 많은 압박을 받고 있다는 것을 알았으므로 그들에게 계속해서 요청을 보내지 않는 것이 좋을 것입니다. 돈과 자원, 그리고 SRE 팀 멤버들의 신경을 아끼게 되겠죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1280/1*d6R2_OewGnnrbMdLNLht8A.gif)\n\n## 그럼 우리가 할 수 있는 것은 무엇일까요? 백오프 아이디어\n\n첫 번째 떠오르는 아이디어는 소비자들에게 백오프 전략을 적용하는 것입니다. 받은 메시지와 실패한 메시지의 가시성 제한 시간을 변경할 수 있습니다. 여기 명심해야 할 몇 가지 중요한 점이 있습니다:\n\n- 최대 지연 시간 값을 설정하는 것,\n- 그리고 지터를 적용하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같은 메시지를 받았다고 가정하고 있다면, ChangeMessageVisibility API를 사용하여 간단히 처리할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_1.png)\n\n우리는 메시지의 처리 시도 횟수에 대한 정보를 포함하고 있는 ApproximateReceiveCount 값을 추출하고, 이를 기반으로 백오프와 지터를 계산할 수 있습니다. 아래 스니펫과 같이요.\n\n다음으로, 각 레코드의 receiptHandle을 사용하여 AWS SQS SDK를 이용해 시각성 제한 시간을 변경해야 합니다. 아래 코드 스니펫처럼요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결과\n\n백오프는 메시지를 확장된 간격으로 다시 시도합니다. 이를 통해 루프에서 항상 같은 메시지를 처리하지 않고, 제3자 시스템에 호흡 공간을 줄 수 있어서 그 사이에 좋아질 것을 희망할 수 있습니다. 또한, 최대 재시도가 제한된 경우 죽은 편지 대기열을 저장할 수 있습니다.\n\n자랑스럽게 여겨질 수 있고, 자신을 칭찬할 수 있지만, 우리는 크게 변하지 않았습니다. 심각한 중단이 있을 경우 AWS는 SQS 소비자 호출을 제한할 수 있지만, 고 처리량 시스템의 경우 3rd party 시스템 관점에서는 여전히 같은 상황에 있습니다.\n\n더 심각한 문제는 이 모든 람다 호출에 돈을 쓰고 있으며, 우리의 제3자 시스템이 다운된 경우 호출은 우리의 타임아웃만큼 느려져 많은 비용이 발생할 수 있습니다. 이를 어떻게 방지할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 회로 차단기 이용하기\n\n회로 차단기는 전기 회로의 회로 차단기처럼 작동합니다. 문제를 감지하면 차단이 되어 더 이상 요청이 전달되지 않습니다. 서드 파티 시스템이 다시 온라인 상태가 되면 회로를 닫고 싶습니다.\n\n그 현지 조사는 \"정찰\" 요청을 보내면서 반 열린 상태로 수행됩니다. 이 요청은 회로 차단기 뒤에 있는 시스템이 여전히 다운된 상태인지 확인하는 작은 그룹으로, 시스템이 다운된 경우 회로는 열린 상태를 유지하고 다시 작동하면 회로를 닫고 평상시로 돌아갑니다.\n\n아래 애니메이션을 살펴보시면 더 이해하기 쉬울 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 다이어그램을 확인하면 프로세스에 대해 여전히 헷갈리는 부분이 있을 수 있습니다.\n\n![다이어그램](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_2.png)\n\n# 게임의 서버리스 상태\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버에서는 크게 문제가 되지 않습니다. 회로 차단 장치 구현 중 하나를 사용할 수 있으니 걱정 마세요. 서버에 상태를 로컬로 저장합니다. 물론 모든 인스턴스가 동기화되지는 않겠지만, 보통 큰 문제가 되지는 않습니다. 서버리스의 경우 상황은 매우 다릅니다. 많은 인스턴스가 있고, 각 작은 인스턴스 간에 상태를 전달할 수 없습니다.\n\n이곳에서 주요 고려 사항은 무엇인가요?\n\n- 솔루션의 복잡성\n- 읽기 작업 전에 상태를 검사해야 하므로 솔루션 비용\n- 작업 후 호출 결과를 지속\n\n서버리스 공간에서 대다수 사용자에게 쉽게 작동할 수 있는 솔루션을 고민 중입니다. 일반적으로 저는 Circuit Breaker 상태를 Elasticache에 저장합니다. 왜냐하면 존재하고, 속도가 매우 빠르며 – 사용자 정의 구현 외에 – 사용하기 쉽기 때문입니다. 반면에 모든 서버리스 시스템이 VPC에서 실행되고 심한 부하를 겪지는 않는다는 것을 이해하고 있습니다. 그렇지만 여기서 가장 흥미로운 부분이 \"고부하\"입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인터넷에서 발견된 구현 방법들과 제가 생각해낸 것에 대해 살펴보겠습니다.\n\n# 일반적인 옵션: Jeremy Daly의 클래식\n\n서킷 브레이커에 관한 거의 모든 기사가 Jeremy Daly의 기사를 언급합니다... 그러니 시작해보죠.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 사용 중이고 방금 말한 패턴입니다. 중앙 집중식 저장소에 상태를 가진 클래식 회로 차단기일 뿐입니다. 훌륭하게 작동하며 실전 검증을 받았습니다. 분산 시스템에서 회로 차단기를 설정하는 가장 좋은 방법이라고 믿습니다. 다음을 제공합니다:\n\n- 여러 CB를 지원하는 매우 세분화된 솔루션\n- 로직이 코드에 있기 때문에 대체값을 반환할 수 있습니다.\n- 어떤 이벤트 소스 매핑 및 호출 유형과도 사용할 수 있습니다.\n\n이 패턴은 Elasticache를 필요로 하므로 일반적으로 VPC도 필요합니다. VPC에서 솔루션을 구축하고 싶지 않다면 어떻게 할까요?\n\n## 비-VPC 변형\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDynamoDB 고려 사항\n저자는 비-VPC 람다와 함께 DynamoDB를 사용할 수도 있다고 언급합니다. 고수준 시스템에서 이 옵션을 고려할 가치가 있을까요? 물론, 이것은 귀하의 규모에 달려 있습니다. 왜냐하면:\n\n- 파티션당 1000 WCU 제한 - 따라서 1000 RPS 이상의 회로 차단기 상태를 유지하는 데 꼼수를 사용해야 합니다 (Tycko Franklin에게 그것을 지적해 준 것을 칭찬합니다)\n- 회로 차단기 유지의 비용은 고처럼 높을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_4.png)\n\n대안적 접근 방식? Momento!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMomento를 사용하면 람다 함수를 VPC에 넣을 필요가 없고 동시에 비용을 절약할 수 있습니다. 또한 매우 확장 가능하고 저지연 솔루션이기도 합니다.\n\n![2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_5.png](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_5.png)\n\n## 주의할 점\n\n잘못된 구현\n인터넷을 뒤져본 결과 잘못된 구현이 많은 것 같습니다. 제가 잘못된 부분이 있다면 지적해주세요. 가장 인기 있는 구현조차도 분산 시스템에서 단일 인스턴스의 상태를 덮어씌우기 때문에 많은 문제를 야기할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구현: https://github.com/gunnargrosch/circuitbreaker-lambda\n\n잘못된 정보 소스입니다\nSSM 및 헬스 체크 상태를 사용하라는 제안을 봤는데, 해당 구현에 들어가기 전 꼭 모든 호출 전에 SSM을 확인하지 말아주세요. 비용이 많이 발생할 수 있어요. 그러나 어떤 해결책은 있습니다. 아래 링크된 스레드를 살펴보세요.\n\n# ESM Circuit Breaker Patterns\n\n일부 회로 차단 방식은 이전 패턴만큼 범용적이지 않으며 ESM (이벤트 소스 매핑)으로 실행되는 이벤트 컨슈머에 특화되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Christoph Gerkens의 전문화된 ESM 회로 차단기\n\n이 문서는 흥미로운 아이디어를 다루고 있습니다. 계획은 SQS Consumer ESM을 회로 차단기로 사용하는 것입니다. 우리는 ESM 상태를 활성화/비활성화하여 회로를 열고 닫을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_6.png)\n\n\"Half Open\" 상태와 \"스카웃 요청\"을 보낼 때, 작성자는 \"Trial Message Poller\"라는 추가 람다를 사용하는 것을 제안합니다. 이 람다는 큐에서 메시지 중 하나를 읽어 SQS Consumer 람다로 보냅니다. 결과에 따라 회로를 닫을지 열어둘지 결정하게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법은 우리의 람다에서 아무것도 할 필요가 없으며, 그것은 완전히 그 로직에서 분리되어 있다는 점에서 훌륭합니다.\n\n비용\n상점이 없으므로 저렴해야 할 텐데요, 맞죠? 저자는 고해상도 메트릭 사용을 권장합니다. 미처리 드리프트가 몇 분 동안 지속되는 차단기 문제를 피하려면 꼭 필요합니다. 동의합니다만, 여기서는 고처리량 처리 렌즈를 통해 보는 것이기도 합니다.\n\n이 경우 많은 메트릭을 수집하면 비용이 많이 들 수 있고, 이러한 메트릭을 저장하는 것은 신중하게 처리해야 합니다. PutMetricData API는 1000번의 호출당 0.01달러로 상당히 비싸니, EMF로 전환하는 것을 고려해볼 수 있습니다. 그 가격표와 매 호출 후 이벤트 추적을 고려하면 상태 저장과 함께 적절한 차단기를 사용하는 것이 더 저렴할 수 있다. 미리 계산해보세요.\n\n복잡성\n\"시험 메시지 폴러\"은 추가 복잡성을 도입하며 저는 유지하고 싶어하는 것이 아닙니다. 이것은 전체 솔루션과 결합돼 있어야 하며 다른 유형의 트리거와 재사용할 수 없습니다. SQS에서도 시각 제한 또는 부분 실패로 인한 잠재적인 문제가 있다고 상상할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n잠재적인 메시지 손실\n메시지가 대기열에서로드되지 않고 장기적이고 심각한 서드파티 오류의 경우, 우리는 메시지를 잃을 수 있습니다. 네, 메시지가 maxReceiveCount에 도달하지 않고 rententionPeriod가 경과하면 메시지가 데드 레터 대기열로 이동되지 않습니다.\n\n## 간소화된 ESM 회로 차단기\n\nChristoph Gerken의 논문에서 영감을 받아, 저는 그 구조적 패턴을 간소화하는 것을 고려했습니다.\n\n이 원리는 전체 회로 차단기 상태를 CloudWatch 경보 상태에 반영하고 이를 회로의 상태로 사용하는 것에 기반합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Screenshot](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_7.png)\n\n원본 글에 정의된 메트릭(호출 및 오류를 사용하여 실패율을 계산)은 기본적으로 무료로 고해상도로 제공되므로 우리는 이를 사용하여 실패율을 추적하고 10초 간격으로 경보를 정의할 수 있습니다. (이 솔루션은 여러분의 요구에 따라 어떤 경보라도 기반으로 작동할 수 있으며, ESM 관리자는 다양한 경보의 변경 사항을 듣고 있어야 합니다.)\n\nHalf-open 상태는 Step Functions를 통해 관리할 필요가 없습니다. CloudWatch 경보의 INSUFFICIENT_DATA 상태를 사용할 수 있습니다. 여기에는 한 가지 단점이 있습니다 — half-open 기간은 큐에서 가져온 단일 메시지 대신 SQS 소비자가 사용한 메시지의 제한된 샘플을 기반으로 합니다. 또한, TreatMissingData: missing을 사용하는 것이 중요합니다.\n\n```js\nFailureRateAlarm:\n  Type: AWS::CloudWatch::Alarm\n  Properties:\n    Metrics:\n      - Expression: \"100 * errors / MAX([errors, invocations])\"\n        Id: \"failureRate\"\n        Label: \"failureRate\"\n        ReturnData: true\n      - Id: \"errors\"\n        MetricStat:\n          Metric:\n            MetricName: Errors\n            Namespace: AWS/Lambda\n            Dimensions:\n              - Name: FunctionName\n                Value: !Ref YourFunction\n          Period: 10\n          Stat: Sum\n        ReturnData: false\n      - Id: \"invocations\"\n        MetricStat:\n          Metric:\n            MetricName: Invocations\n            Namespace: AWS/Lambda\n            Dimensions:\n              - Name: FunctionName\n                Value: !Ref YourFunction\n          Period: 10\n          Stat: Sum\n        ReturnData: false\n    EvaluationPeriods: 5\n    DatapointsToAlarm: 3\n    TreatMissingData: missing\n    Threshold: 80\n    ComparisonOperator: GreaterThanOrEqualToThreshold\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상태 관리\n알람이 트리거되면 회로가 열리며 람다 호출이 발생하지 않습니다. 그럼 알람은 INSUFFICIENT_DATA 상태로 전환됩니다. 그 후에는 큐의 제한된 동시성 처리를 통해 \"스카웃 요청\"을 보낼 수 있으며, 실패한 후에는 처리가 성공적으로 이루어진 후에 서킷을 열거나 닫을 수 있습니다.\n\n![image](/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_8.png)\n\n기본 AWS 람다 메트릭을 사용할 경우, 새로운 접근 방식을 절약할 수 있지만, 이전 옵션에서의 \"메시지 손실 가능성\" 문제에 여전히 취약합니다.\n\n구현\nESM을 활성화하고 비활성화하는 것은 쉽습니다. 유일하게 누락된 것은 ESM에 메타데이터를 추가할 수 있는 옵션이었습니다. 해당 기능이 누락되었으므로 스택에 매개변수로 추가해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 구현은 go로 작성되었고 일부 사용자 지정 instrumentation 및 OTEL 통합이 되어 있어요. 하지만 여기 스니펫에서처럼 간단한 것을 사용할 수도 있어요.\n\n내 구현은 SQS를 기반으로 하고 있지만 모든 다양한 이벤트 주도형 ESMs 구성에 적응시킬 수 있어요. 작은 사용자 정의 후처리 후 반-열린 상태로 커스터마이즈된 구성을 이용해요.\n\n테스트\n해당 솔루션은 여러 다른 알람 구성을 이용해 FIS로 테스트했어요. 아래에서는 예제 알람 상태 전이의 동작을 확인할 수 있어요.\n\n이 접근 방식은 반-열린 상태로 이동하는 빈도를 제어하는 유연성이 부족하지만, 코드에 액세스할 수 없거나 람다 핸들러에 복잡성을 추가하고 싶지 않은 경우에는 좋아요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n분산 시스템에서 서킷 브레이커를 올바르게 구현하는 것은 매우 어려울 수 있으며 고려해야 할 다양한 트레이드오프와 접근 방식이 많이 있습니다. 경우에 따라 분산된 서킷 브레이커가 전혀 필요하지 않을 수도 있습니다. 예를 들어, 작은 람다 소비자 풀의 경우에는 서킷 상태 메모리가 충분할 수도 있습니다.\n\n만약 당신의 케이스에 해당하지 않는다면, 이 글이 당신에게 결정을 도와주거나 구현 중 고려해야 할 사항에 대한 아이디어를 제공해 줄 수 있기를 바랍니다. 아래에서는 당신을 위한 결정 트리를 만들어 보았습니다. 전통적인 접근 방식이 여전히 최선이라고 믿지만 ESM 기반 서킷 브레이커의 사용 사례도 볼 수 있습니다.\n\n해당 주제에 대해 토의하고 싶다면, #believeinserverless 커뮤니티에 가입하여 이곳에서 커뮤니티와 논의할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시간 내어 주셔서 감사합니다! 이 주제에 대한 여러분의 생각을 듣고 싶습니다! 연락을 주세요:\n\n## 부가 설명\n\n또 다른 접근법\n이곳에서 읽을 수 있는 Sheen Brisals가 시도한 Circuit Breakers with retries 및 archiving events에 대한 접근법: [https://sbrisals.medium.com/amazon-eventbridge-archive-replay-events-in-tandem-with-a-circuit-breaker-c049a4c6857f](https://sbrisals.medium.com/amazon-eventbridge-archive-replay-events-in-tandem-with-a-circuit-breaker-c049a4c6857f) 또는 여기서 저자가 아이디어를 제시하는 동영상을 시청하세요(멋진 이야기입니다):\n","ogImage":{"url":"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png"},"coverImage":"/assets/img/2024-06-23-DistributedCircuitBreakersinEvent-DrivenArchitecturesonAWS_0.png","tag":["Tech"],"readingTime":15},{"title":"AWS Glue CI CD 간소화하는 방법","description":"","date":"2024-06-23 00:23","slug":"2024-06-23-StreamliningAWSGlueCICD","content":"\n## 포괄적인 청사진\n\n끊임없이 변화하는 데이터 관리 환경에서, 생 데이터를 실행 가능한 통찰로 변환하는 것은 전 세계 비즈니스에게 중요합니다. AWS Glue는 바로 이를 위한 AWS 내의 서비스로, 추출(Extract), 변환(Transform), 로드(Load) 작업에 특화된 서비스입니다.\n\nGlue는 본질적으로 전통적으로 복잡하고 시간이 많이 소요되는 ETL 작업을 간편화하여 핵심 작업을 자동화하고 중요 인프라를 추상화하며 직관적인 인터페이스를 제공합니다.\n\n그러나 대부분의 클라우드 서비스와 마찬가지로 Glue ETL 작업의 테스트, 배포, 조정에는 코드 버전 관리, 의존성 관리, 인프라 설정 및 액세스 제어 등의 복잡성이 포함되어 여러 도전 과제가 발생합니다. 이러한 도전 과제를 해결하기 위해서는 AWS Glue에 특화된 잘 구조화된 CI/CD 전략이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 블로그 포스트는 이러한 전략을 탐구합니다. 구체적으로, 우리는 AWS Glue CI/CD 워크플로우를 최적화하고 자동화하기 위해 설계된 포괄적인 청사진을 살펴봅니다. 이는 동반 GitHub 저장소를 통해 이용할 수 있습니다.\n\n# GitHub 저장소 개요\n\n이 청사진의 GitHub 저장소는 집단 학습 과정을 통해 생산되었으며, 주요 컨셉의 예시를 제공합니다. Glue 기반 데이터 레이크 구현의 출발점으로 활용하고 있으며, 데이터 엔지니어들의 교육을 가속화하고 팀원들과 함께 다양한 배포 접근 방식을 검증하는 데 도움이 됩니다. 이는 다음과 같이 구성되어 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\naws-glue-ci-cd-blueprint\n├──.github/\n   └──workflows/ (CI/CD configurations)\n├──infrastructure/\n   └──environments/ (deployment environment configurations)\n      └──dev/\n      └──prod/\n      └──qa/\n      └──staging/\n   └──modules/ (reusable infrastructure components)\n      └──athena/\n      └──core/\n      └──glue/\n├──src/ (ETL code written in Python)\n├──tests/ (unit tests for the Python code)\n├──...\n```\n\n주요 구성 요소와 프레임워크는 다음과 같습니다:\n\n- 지속적 통합/지속적 전달: GitHub Actions\n- 인프라스트럭처 코드: Terraform\n- 코드 품질 보증 (Python): Unittest + Pytest, Black 및 Flake8\n\n이 설계도를 활용하기 위해 도구를 숙달하는 것보다 개념을 잘 이해하는 것이 중요하다는 점을 강조할 가치가 있습니다. 예를 들어, GitHub Actions 코드는 쉽게 GitLab CI로 변환할 수 있습니다. Terraform과 AWS Cloud Formation에도 동일하게 적용되며, 선택한 프로그래밍 언어와 QA 도구에도 물론 그와 같이 적용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 청사진 시작하기\n\n아래 이미지를 살펴보세요. 인프라 및 Python 코드를 위한 두 개의 수영선이 있음을 알 수 있습니다. 이러한 코드 조각들은 데이터 파이프라인 개발 수명주기 동안 서로 다른 사람이 다루거나 적어도 구분된 시기에 처리되는 경험을 보여주고 있기 때문에 우리는 이들을 별도로 다루기로 결정했습니다. 일반적인 경험에 따르면 인프라는 어떤 ETL 작업을 배포하기 전에 프로비저닝되어야 합니다.\n\n![image](/assets/img/2024-06-23-StreamliningAWSGlueCICD_1.png)\n\n## 자동화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현대 데이터 팀은 데이터 파이프라인을 개발, 유효성 검사 및 전달하는 데 다른 환경을 사용합니다. 이 환경은 클라우드에서 실행되며 많은 연결된 리소스에 의존합니다. 자동화 없이 이러한 환경 간에 리소스 구성을 복제하는 것은 거의 불가능합니다. 그렇지만 청사진은 인프라 및 코드 품질 보증을 위한 자동화 안내를 제공합니다.\n\nIaC 측면에서 Terraform은 데이터 파이프라인과 관련된 모든 AWS 리소스를 설정하는 역할을 맡습니다. 예를 들어, S3 버킷, 최소 권한 IAM 역할, Glue 작업, 워크플로, 데이터 카탈로그를 공급하는 크롤러 및 Athena를 위한 잘 정의된 IAM 정책 등이 있습니다.\n\nETL 코드에 대해 단위 테스트, 형식, 및 린트 체크는 새로운 커밋이 Pull Requests에 푸시되거나 dev 및 main 브랜치로 병합될 때마다 실행되어 파이프라인을 깨뜨릴 수 있는 변경을 방지합니다. 그리고 모든 것이 잘 진행된다면 코드는 적절한 위치로 배포됩니다.\n\nGitHub에서 실행되는 단계는 GitHub Actions를 통해 구성됩니다. 자세한 내용은 aws-glue-ci-cd-blueprint/.github/workflows를 참조해 주세요; on-iac-로 시작하는 파일은 IaC의 CI/CD에 속하며 on-으로 시작하는 파일은 Python 코드의 CI/CD에 속합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여전히 개발자들은 특히 개발 환경(“배포 전략” 섹션에 설명된)을 사용할 때 Terraform, AWS CLI 및 품질 보증 명령을 로컬에서 실행할 수 있습니다.\n\n## 테스트\n\nTerraform 구성에는 세 가지 유형의 확인이 적용되며, 그 중 하나라도 실패하는 경우 인프라 배포 파이프라인이 즉시 중지됩니다 (참조용으로 iac-pr-against-dev.yaml 참조):\n\n- 스타일 확인: terraform fmt -check\n- 코드 정확성: terraform validate\n- 실행 계획 실현 가능성: terraform plan\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 코드에는 세 가지 유형의 체크가 적용되며, 실패 시 배포 파이프라인을 중단합니다 (참고용: on-pr-against-dev.yaml):\n\n- 단위 테스트: pytest\n- 스타일 체크: black --check ./src ./tests\n- 린터: flake8 ./src ./tests\n\n## 배포 전략\n\n아래에 설명된 네 가지 환경을 다루는 청사진입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-StreamliningAWSGlueCICD_2.png)\n\n프로젝트 요구 사항에 따라 모든 환경을 사용하는 것은 과도할 수 있지만, 적어도 개발 및 프로덕션 환경을 갖는 것이 좋습니다. 이렇게 하면 개발자와 사용자 경험을 더 향상시킬 수 있습니다.\n\n## 사용 지침\n\n주의: 이 부분에서 설명된 실습 가이드를 처음 사용하는 경우, 도구에 대한 전문 지식에 따라 몇 시간이 걸릴 수 있습니다. 그러나 블루프린트에 익숙해지는 것은 가치가 있습니다. 더 짧은 전달 주기 및 더 높은 품질 기준의 혜택은 몇 차례 상호 작용 후에 옵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개념적 개요를 이해한 후에 블루프린트로 놀아보려 합니다. 저희는 Glue 작업을 설정할 것입니다. 해당 작업은 `awsglue-datasets` 공개 S3 버킷에서 `examples/us-legislators/all/persons.json` 파일을 지정하신 개인 버킷으로 복사할 것입니다. 그 다음 단계에서 Crawler가 테이블을 검사하고 데이터 카탈로그 항목을 생성할 것입니다. 이 작업 흐름은 간단하지만 시연 목적으로 충분합니다. 이미지 3는 Terraform 모듈, AWS 리소스 및 그들 간의 관계를 설명합니다.\n\n![image](/assets/img/2024-06-23-StreamliningAWSGlueCICD_3.png)\n\n다음을 전제로 합니다:\n\n- `aws-glue-ci-cd-blueprint` 리포지토리의 `main` 및 `dev` 브랜치를 복사하셨습니다.\n- 로컬 환경에 Terraform 및 AWS CLI가 설치되어 있습니다.\n- Glue, IAM 및 S3에 대한 관리 권한이 있는 것으로 가정합니다. 그렇지 않으면 다음 단계를 따를 때 도움이 필요할 수 있습니다. Athena 접근 권한이 있다면 더 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테라폼은 생성하는 모든 AWS 리소스에 dev|qa|staging|prod 접미사를 추가합니다. 이렇게 함으로써 네 개의 배포 환경을 하나의 계정에서 구성할 수 있습니다. 이는 교육 목적에 적합하지만 적어도 운영 환경은 별도로 존중받고 적절히 관리되는 계정에서 사용되어야 합니다.\n\n이제 몇 가지 수동 단계가 필요합니다... 다음 권한 정책을 가진 IAM 사용자가 필요합니다:\n\n- AmazonS3FullAccess\n- AWSKeyManagementServicePowerUser\n- AWSGlueConsoleFullAccess\n- IAMFullAccess\n- kms:EnableKeyRotation 및 kms:EnableKeyDeletion을 실행할 수 있는 사용자 정의 정책\n\n이 사용자는 로컬 개발 환경에서 테라폼과 AWS CLI에서만 사용될 예정이므로 콘솔 액세스가 필요하지 않습니다. 이 사용자를 위해 액세스 키를 생성하고 해당 ID 및 비밀을 안전하게 보관하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTerraform 상태 파일을 저장하기 위한 S3 Bucket도 필요합니다. infrastructure/environments/\\*/provider.tf 파일을 확인하면 glue-ci-cd-terraform 버킷이 블루프린트를 위해 구성되어 있다는 것을 알 수 있으니, 이 파일들을 업데이트해주세요.\n\n또한, infrastructure/environments/\\*/variables.tf 파일에서 다음 버킷들을 위한 다른 이름을 설정해주세요: data_bucket_name, glue_assets_bucket_name, glue_scripts_bucket_name, athena_query_results_bucket_name. 이름만 제공하면, Terraform이 버킷을 생성할 것입니다.\n\n이제 보여주는 시간입니다! 리포지토리 루트 폴더에서 터미널에서 다음 명령어를 실행하세요:\n\n```js\nexport AWS_ACCESS_KEY_ID=\u003c당신의-액세스-키-ID\u003e\nexport AWS_SECRET_ACCESS_KEY=\u003c당신의-비밀-액세스-키\u003e\n\nexport TF_VAR_aws_access_key=$AWS_ACCESS_KEY_ID\nexport TF_VAR_aws_secret_key=$AWS_SECRET_ACCESS_KEY\n\ncd infrastructure/environments/dev/\nterraform init\nterraform plan\nterraform apply\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샘플 ETL 파이프라인 인프라를 구성하는 약 20개의 AWS 리소스가 개발 환경(dev 접미사)에서 생성됩니다. 이에는 S3 버킷, IAM 정책 및 역할, Glue 작업, 데이터베이스, 크롤러 및 워크플로우가 포함됩니다.\n\n개발자 설정을 마무리하기 위해 ETL 코드를 스크립트 버킷에 복사해주세요:\n\n```js\ncd ../../..\naws s3 sync --delete ./src s3://\u003cYOUR-GLUE-SCRIPTS-BUCKET\u003e\n```\n\n그런 다음 AWS 콘솔에서 Glue 워크플로우 페이지로 이동하여 glue-ci-cd-us-legislators-dev를 선택합니다. 워크플로를 실행하고 완료될 때까지 약 10분 정도 기다려주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 Markdown 형식의 표를 참조하세요.\n\n![이미지](/assets/img/2024-06-23-StreamliningAWSGlueCICD_4.png)\n\n데이터 버킷을 확인하고 원본 데이터가 JSON 형식으로 저장된 bronze 폴더를 찾으세요. 또한 Parquet 형식으로 데이터가 저장된 silver 폴더도 있습니다. JSON에서 Parquet으로 변환하는 것이 샘플 파이프라인의 한 단계입니다. Glue Workflow에는 silver 테이블을 검토하는 크롤러가 있으며 관련된 데이터 카탈로그 항목을 생성합니다.\n\n![이미지](/assets/img/2024-06-23-StreamliningAWSGlueCICD_5.png)\n\n마지막 단계는 CI/CD를 위해 GitHub 저장소를 구성하는 것입니다. 저장소 설정 페이지로 이동하여 환경을 선택하세요. quality-assurance, staging, production 세 개의 환경을 만드세요. 각각에 대해 AWS_ACCOUNT_ID 비밀 및 AWS_REGION 및 GLUE_SCRIPTS_S3_BUCKET 변수를 설정하세요. 여기에서는 GitHub Action 실행기가 특정 IAM 역할을 가정하기 때문에 액세스 키나 시크릿을 제공해야 할 필요가 없다는 점을 주목하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCI/CD YAML 파일 중 하나를 다시 확인하고 GitHub Action 러너가 GlueCICDGitHubActionsServiceRole을 가정하는지 확인해주세요. 이 IAM 역할은 아직 AWS 계정에 생성되지 않았으므로 이를 생성하고 Amazon Web Services에서 OpenID Connect 구성 지침을 따라 설정을 완료하세요. 이전에 생성된 IAM 사용자에 부여된 동일한 권한을 부여해주세요.\n\n작업을 완료하면 “배포 전략” 섹션에 설명된 규칙에 따라 나머지 세 개 환경에서 자동화 및 품질 체크를 활용할 수 있습니다. 스크립트를 변경하고 파이프라인에 새 단계를 추가하며, 저장소에 풀 리퀘스트를 생성하고 이를 dev 브랜치로 병합한 뒤 dev를 main에 병합하여 결과를 확인해주세요. 또한 CI/CD 실행 예제를 참조하기 위해 블루프린트 저장소를 참고할 수도 있습니다.\n\n![AWS GlueCICD](/assets/img/2024-06-23-StreamliningAWSGlueCICD_6.png)\n\n# 도전과 고려 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제공된 청사진은 AWS Glue CI/CD 파이프라인을 간소화하기 위한 유용한 자원을 제공하지만, 항상 개선할 부분이 있습니다. 앞으로 진행할 때 극복하고자 하는 주요 장벽은 다음과 같습니다:\n\n- 다중 개발 및 QA 환경 지원. 현재는 개발 및 품질 보증 환경이 각각 하나씩만 있어 대규모 팀에 대해 동시성 문제를 발생시킬 수 있습니다. 더 나은 해결책은 각 엔지니어마다 하나의 개발 환경 및 각 Pull Request에 대해 하나의 QA 환경을 지원하는 것입니다.\n- 데이터 품질 기능. DataOps는 데이터에 대해 적용된 단순한 DevOps 이상을 의미합니다. 현재 청사진은 처음 릴리스된 Glue 데이터 파이프라인용 DevOps일 뿐입니다. 자동으로 데이터 품질 점검을 설정하는 것이 DataOps 범주로 승격하는 데 도움이 될 것입니다.\n- 통합 테스트. 유닛 테스트는 Python 코드에 대해 잘 작동하지만, ETL 파이프라인은 일반적으로 단위 테스트에 적합하지 않은 SQL 문에 의존합니다. 통합 또는 시스템 테스트 지원을 추가하는 것이 적절할 것입니다.\n\n# 결론\n\n데이터 관리의 동적 영역에서 AWS Glue의 ETL 프로세스를 용이하게 하는 역할은 조직이 데이터의 잠재력을 효과적으로 활용할 수 있도록 하는 중요한 힘으로 남아 있습니다. 이 탐험을 통해 AWS Glue 작업에 대한 CI/CD 관리의 내재적인 도전 과제를 극복하기 위한 포괄적인 청사진을 소개하면서 이러한 복잡성에 직면하는 것을 목표로 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n변화를 받아들이는 것은 때로는 시간과 노력을 투자하는 것이 필요합니다. 사용 설명서에 상세히 설명된 실습 단계들은 특히 이 도구에 익숙하지 않은 사람들에게는 시간이 좀 걸릴 수 있습니다. 그러나 걱정하지 마세요, 이 노력의 결실은 처음 투자한 가치가 충분히 있을 것입니다.\n\n글을 마무리하며, 데이터 민첩성 여정에 참여하실 것을 초대합니다. GitHub 저장소를 살펴보고, 구현 세부사항에 익숙해지고, 이 원칙을 프로젝트 요구에 맞게 적용해 보세요. 도움이 필요하시면 언제든지 연락 주세요.\n\n귀하의 데이터 프로젝트가 효율성과 성공으로 가득하길 기원합니다!\n","ogImage":{"url":"/assets/img/2024-06-23-StreamliningAWSGlueCICD_0.png"},"coverImage":"/assets/img/2024-06-23-StreamliningAWSGlueCICD_0.png","tag":["Tech"],"readingTime":12},{"title":"Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법","description":"","date":"2024-06-23 00:22","slug":"2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey","content":"\n이 안내서는 PEM 키를 사용하여 SSH 액세스가 설정된 Terraform을 사용하여 EC2 인스턴스를 생성하는 데 도움이 될 것입니다.\n\n## 아키텍처 개요\n\n설치에는 다음이 포함됩니다:\n\n- 서브넷과 인터넷 게이트웨이가 있는 VPC.\n- EC2 인스턴스.\n- SSH 액세스용 보안 그룹.\n- 라우팅 테이블.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# AWS 자격 증명 구성\n\nAWS CLI 설치: AWS CLI를 아직 설치하지 않았다면 여기에서 다운로드하여 설치할 수 있습니다.\n\nAWS CLI 구성: 아래 명령을 실행하여 AWS 자격 증명을 구성하세요. 이를 통해 Terraform이 사용할 필요한 구성 파일을 설정합니다.\n\n```js\naws configure\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 자격 증명을 입력해주세요:\n\n```js\nAWS Access Key ID [None]: \u003c당신의 AWS 액세스 키 ID\u003e\nAWS Secret Access Key [None]: \u003c당신의 AWS Secret 액세스 키\u003e\nDefault region name [None]: us-west-2\nDefault output format [None]: json\n```\n\n설정 확인: 설정을 완료한 후에는 다음 명령어를 실행하여 설정을 확인하세요:\n\n```js\naws sts get-caller-identity\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령은 IAM 사용자에 대한 세부 정보가 포함된 JSON 응답을 반환해야 합니다.\n\n# 디렉토리 구조 설정하기\n\n터미널을 열고 다음과 같이 메인 디렉토리를 생성하세요:\n\n```shell\nmkdir terraform_project\ncd terraform_project\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모듈을 위한 하위 디렉토리를 생성해주세요:\n\n```bash\nmkdir ec2_setup\ncd ec2_setup\n```\n\n필요한 Terraform 파일을 생성해주세요:\n\n```bash\ntouch main.tf variables.tf vpc.tf subnet.tf security_group.tf ec2.tf internet_gateway.tf route_table.tf key_pair.tf\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파일이 생성되었는지 확인하기 위해 파일 목록을 나열해보세요:\n\n```js\nls;\n```\n\n## 구성 시작\n\n## 1. 제공자 정의\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmain.tf 파일에서 공급업체를 설정하십시오:\n\n```js\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~\u003e 5.18\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = \"us-west-2\"\n}\n```\n\n## 2. 입력 변수 정의\n\nvariables.tf 파일에서 변수를 정의하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nvariable \"ssh_key_name\" {\n  description = \"SSH 키 쌍의 이름\"\n  type        = string\n}\n\nvariable \"ec2_instance_type\" {\n  description = \"EC2 인스턴스의 유형\"\n  type        = string\n}\n\nvariable \"ec2_instance_tag\" {\n  description = \"EC2 인스턴스를 위한 태그\"\n  type        = string\n}\n\nvariable \"instance_count\" {\n  description = \"생성할 인스턴스 수\"\n  type        = number\n}\n\nvariable \"private_key_file\" {\n  description = \"개인 키 파일의 이름\"\n  type        = string\n}\n\nvariable \"vpc_cidr_block\" {\n  description = \"VPC의 CIDR 블록\"\n  type        = string\n}\n\nvariable \"subnet_az\" {\n  description = \"서브넷의 가용 영역\"\n  type        = string\n}\n```\n\n# 3. VPC 생성\n\nvpc.tf 파일에 VPC 리소스를 정의하세요:\n\n```js\nresource \"aws_vpc\" \"my_vpc\" {\n  cidr_block           = var.vpc_cidr_block\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n  tags = {\n    Name = \"my_vpc\"\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4. 서브넷 정의하기\n\nsubnet.tf 파일에서 다음과 같이 서브넷을 정의하세요:\n\n```js\nresource \"aws_subnet\" \"my_subnet\" {\n  cidr_block        = cidrsubnet(aws_vpc.my_vpc.cidr_block, 3, 1)\n  vpc_id            = aws_vpc.my_vpc.id\n  availability_zone = var.subnet_az\n}\n```\n\n# 5. 인터넷 게이트웨이 설정하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ninternet_gateway.tf 파일에서 인터넷 게이트웨이를 정의하세요:\n\n```js\nresource \"aws_internet_gateway\" \"my_igw\" {\n  vpc_id = aws_vpc.my_vpc.id\n}\n```\n\n# 6. 보안 그룹 생성하기\n\nsecurity_group.tf 파일에서 보안 그룹을 정의하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nresource \"aws_security_group\" \"ssh_access\" {\n  name   = \"ssh_access\"\n  vpc_id = aws_vpc.my_vpc.id\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = -1\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n```\n\n# 7. EC2 인스턴스 시작하기\n\nec2.tf에서 다음과 같이 EC2 인스턴스를 정의하세요:\n\n```js\ndata \"aws_ami\" \"latest_ubuntu\" {\n  most_recent = true\n\n  filter {\n    name   = \"name\"\n    values = [\"ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*\"]\n  }\n\n  filter {\n    name   = \"virtualization-type\"\n    values = [\"hvm\"]\n  }\n\n  owners = [\"\u003cYour AWS Account ID\u003e\"]\n}\n\nresource \"aws_instance\" \"my_ec2_instance\" {\n  count                       = var.instance_count\n  ami                         = data.aws_ami.latest_ubuntu.id\n  instance_type               = var.ec2_instance_type\n  key_name                    = var.ssh_key_name\n  security_groups             = [aws_security_group.ssh_access.id]\n  associate_public_ip_address = true\n  subnet_id                   = aws_subnet.my_subnet.id\n\n  tags = {\n    Name = var.ec2_instance_tag\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 8. 라우트 테이블 생성\n\nroute_table.tf 파일에서 라우트 테이블 및 연관을 정의하세요:\n\n```js\nresource \"aws_route_table\" \"my_route_table\" {\n  vpc_id = aws_vpc.my_vpc.id\n\n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.my_igw.id\n  }\n}\nresource \"aws_route_table_association\" \"my_route_table_assoc\" {\n  subnet_id      = aws_subnet.my_subnet.id\n  route_table_id = aws_route_table.my_route_table.id\n}\n```\n\n# 9. 키페어 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nkey_pair.tf 파일에서 키페어를 정의하고 개인 키를 저장하세요:\n\n```js\nresource \"tls_private_key\" \"my_rsa_key\" {\n  algorithm = \"RSA\"\n  rsa_bits  = 4096\n}\n\nresource \"aws_key_pair\" \"my_key_pair\" {\n  key_name   = var.ssh_key_name\n  public_key = tls_private_key.my_rsa_key.public_key_openssh\n}\n\nresource \"local_file\" \"my_private_key\" {\n  content  = tls_private_key.my_rsa_key.private_key_pem\n  filename = var.private_key_file\n}\n```\n\n# 구성 배포\n\nTerraform 구성을 초기화하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```bash\n테이블 태그를 Markdown 형식으로 변경하세요.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nterraform apply -var 'ssh_key_name=my_ssh_key' -var 'ec2_instance_type=t2.micro' -var 'ec2_instance_tag=[\"TestInstance\"]' -var 'instance_count=1' -var 'private_key_file=my_private_key.pem' -var 'vpc_cidr_block=10.0.0.0/16' -var 'subnet_az=us-west-2a'\n```\n\nAWS에서 리소스를 확인해보세요:\n\n![이미지1](/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_0.png)\n\n![이미지2](/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 변경한 것입니다.\n\n![이미지1](/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_2.png)\n\n![이미지2](/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_3.png)\n\nPEM 키를 사용하여 인스턴스로 SSH 연결:\n\n```js\nssh -i my_private_key.pem ubuntu@\u003cpublic-ip\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_4.png\" /\u003e\n\n# 결론\n\n테라폼을 사용하여 SSH 액세스가 가능한 EC2 인스턴스를 성공적으로 생성했습니다. 이 구성은 모듈식이므로 향후 프로젝트에 맞게 쉽게 적응시킬 수 있습니다. 완전한 모듈은 GitHub에서 찾을 수 있습니다.\n\n행복한 Terraforming!\n","ogImage":{"url":"/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_0.png"},"coverImage":"/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_0.png","tag":["Tech"],"readingTime":11},{"title":"기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법","description":"","date":"2024-06-23 00:20","slug":"2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse","content":"\n# 소개\n\n클라우드 또는 데브옵스 엔지니어로 일해본 적이 있다면, 아마도 이전에 AWS Lambda 함수를 한 번 이상 만들어 본 적이 있을 것입니다. 아마도 주로 Python이나 NodeJS와 같은 네이티브 지원 런타임에서 이 함수를 개발했으며, 그 목적은 간단한 프로세스를 실행하거나 AWS Cognito나 API Gateway와 같은 다른 AWS 서비스와 통합하여 신원 확인을 수행하는 것이었을 것입니다. 이 구현 과정에서 런타임 선택, 코드 업로드, 환경 변수 설정 및 사용, 그리고 기본 실행 권한이 있는 역할을 첨부하는 등의 기본 AWS Lambda 작업에 익숙해졌을 것입니다.\n\n하지만 쉘 또는 Go 스크립트와 같은 네이티브 지원되지 않는 런타임으로 작성된 코드가 있다면 어떨까요? 첫 번째 충동은 그 코드를 Python으로 번역하려고 하는 것일 것입니다. 또는 더 좋은 방법으로는 GenAI에게 번역을 요청하는 것일 것입니다. 이 방법은 코드가 간단하고 짧은 함수일 경우에는 잘 작동할 수 있습니다. 또는 회사의 보안 및 기밀 정책이 제3자인 GenAI에게 코드를 전송하는 것을 허용한다면 더욱 좋을 것입니다. 그러나 대부분의 경우, 엄격한 규정과 요구사항을 가진 대기업에서 일하는 경우에는 이를 할 수 없을 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:480/1*HLkvF3q4nyCWnwjiUiH5qA.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 게시물에서는 Docker 및 AWS Lambda 개념에 대한 기본적인 이해만 있으면 함수 실행에 필요한 사용자 정의 런타임을 제공하는 Docker 이미지를 쉽고 간단히 만드는 방법을 설명하겠습니다.\n\n# AWS Lambda의 내부 구조\n\n사용자 지정 런타임을 구성하는 방법에 대해 자세히 알아보기 전에 AWS Lambda가 서버리스 모드에서 함수를 실행하는 마법같은 방법을 이해해 보겠습니다.\n\n![AWS Lambda 내부 구조](/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS Lambda 서버리스 실행은 세 가지 구성 요소 덕분에 가능해집니다:\n\n- Lambda Service: 프로비저닝, 스케일링, 모니터링 및 로깅을 처리합니다. 코드를 배포하고 함수를 호출하는 것을 포함한 함수 실행의 수명주기를 관리합니다.\n- Execution Runtime: 코드가 실행되는 환경입니다. AWS Lambda는 Node.js, Python, Java 등 다양한 런타임을 지원하며, 다른 프로그래밍 언어나 특정 런타임 버전을 위한 사용자 정의 런타임 사용도 허용합니다.\n- Runtime API: 이 인터페이스는 Lambda 서비스와 실행 런타임 사이에 위치합니다. AWS Lambda 인프라와 함수 실행 환경 간의 통신에 사용됩니다.\n\n![Advanced AWS Lambda](/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_1.png)\n\n주로 런타임과 함수 코드로 구성된 파란색 사각형에 초점을 맞출 것입니다. 우리 Lambda 함수가 작동하도록 수정해야 하는 부분입니다. 일반적으로 지원되는 AWS Lambda 런타임은 런타임 API를 지속적으로 폴링하여 새 이벤트를 수신하고, 함수 핸들러를 로드하고, 이벤트를 수신하면 실행하여 결과를 런타임 API로 다시 보내며, 이를 통해 클라이언트(이 경우 Lambda 서비스)에 결과를 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS는 우리에게 OS전용 런타임이라고 불리는 것을 제공합니다. 이는 언어 지원을 제공하며, 실행 스크립트를 실행하는 데 필요한 환경 변수 및 인증서와 같은 추가 설정을 제공하고, Lambda 서비스와 상호 작용하기 위한 모든 필요한 API를 구성합니다 [1]. 모든 것을 할 일은 작은 스크립트를 추가하고, 코드와 번들로 만든 후, AWS OS 전용 런타임을 기반으로 새로운 도커 이미지를 빌드하고, 이 이미지를 ECR에 업로드한 후, 마지막으로 AWS Lambda의 이미지로 사용하는 것뿐입니다. 쉽고 간단해요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:500/1*Fs-d5kxj5Aa3LL0Jm0MF-Q.gif)\n\n# 사용자 정의 런타임 구현\n\n이 섹션에서는 AWS Lambda 사용자 정의 런타임을 위한 도커 이미지를 빌드하는 데 필요한 스크립트와 코드를 제공하겠습니다. 준비가 되셨나요? 코드 정글로의 여행에 깊이 파고 들어가기 전에 커피를 가져오세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:600/1*-AMtT2H3qw0N26uRiqTVwQ.gif)\n\n```js\n#!/bin/sh\n\nset -euo pipefail\n\n# export\n# Initialization - load function handler\nsource $LAMBDA_TASK_ROOT/\"$(echo $HANDLER | cut -d. -f1).sh\"\n\n# Processing\nwhile true\ndo\n  HEADERS=\"$(mktemp)\"\n  # Get an event. The HTTP request will block until one is received\n  EVENT_DATA=$(curl -sS -LD \"$HEADERS\" \"http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/next\")\n\n  # Extract request ID by scraping response headers received above\n  REQUEST_ID=$(grep -Fi Lambda-Runtime-Aws-Request-Id \"$HEADERS\" | tr -d '[:space:]' | cut -d: -f2)\n\n  # Run the handler function from the script\n  RESPONSE=$($(echo \"$HANDLER\" | cut -d. -f2) \"$EVENT_DATA\")\n\n  # Send the response\n  curl \"http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/response\"  -d \"$RESPONSE\"\ndone\n```\n\nThe first line \"set -euo pipefail\" is to configure the shell to handle errors robustly and to exit immediately if any command within the script fails.\n\nThis script starts by loading the function handler through the source command.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음, invocation/next API를 호출하여 Runtime API에서 새 이벤트를 조사하기 위한 루프가 시작됩니다.\n\n그런 다음 Lambda 호출을 식별하는 데 도움이 되는 요청 ID를 추출합니다.\n\n그런 다음 Lambda 서비스로부터 수신한 페이로드 데이터로 주요 셸 스크립트를 실행합니다.\n\n마지막으로, invocation/$Request_ID/response를 호출하여 Runtime API로 응답을 보냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nFROM public.ecr.aws/lambda/provided:al2023\n\nENV HANDLER=\"function.handler\"\n\nCOPY ./bootstrap  ${LAMBDA_TASK_ROOT}/bootstrap\nCOPY ./function.sh  ${LAMBDA_TASK_ROOT}/function.sh\n\nRUN chmod +x ${LAMBDA_TASK_ROOT}/bootstrap\nRUN chmod +x ${LAMBDA_TASK_ROOT}/function.sh\n\nENTRYPOINT [\"/var/task/bootstrap\"]\n```\n\n이 Dockerfile은 AWS public Lambda 이미지 `lambda/provided:al2023`를 기반으로 하는 Docker 이미지를 생성합니다 [3]. 이 이미지는 언어 지원과 스크립트 실행에 필요한 환경 변수 및 인증서와 같은 추가 설정을 제공합니다.\n\n우리는 환경 변수를 우리 셸 스크립트의 핸들러로 설정했습니다. 이는 `스크립트 이름`.`함수 이름` 형식으로 되어야 합니다.\n\n이후 이전 부트스트랩 스크립트와 우리의 셸 스크립트를 $LAMBDA_TASK_ROOT로 복사합니다 (Lambda 런타임 환경 변수로 정의된, 함수 코드 디렉토리 `/var/task`를 참조하는 Lambda 환경 변수) [4]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 스크립트를 실행할 수 있도록 만들고, 마지막으로 실행 시점을 기다리는 새 이벤트를 기다리는 부트스트랩 스크립트로 설정합니다.\n\n```js\nfunction handler () {\n  EVENT_DATA=$1\n  echo \"$EVENT_DATA\" 1\u003e\u00262;\n  RESPONSE=\"Echoing request: '$EVENT_DATA'\"\n\n  echo $RESPONSE\n}\n```\n\n이것은 이벤트 데이터를 인수로 받아 출력하는 샘플 셸 스크립트입니다.\n\n```js\nruntime-tutorial\n├ bootstrap\n├ Dockerfile\n└ function.sh\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 직접 테스트해보세요\n\n지금까지 따라오셨다면, 축하드립니다. 여러분은 이제 AWS 람다 함수에 대한 가장 복잡한 컨셉 중 하나를 이해하셨습니다. 우리 모두가 알다시피, 지식을 확고히 하는 가장 좋은 방법은 실습하는 것이죠!\n\n![image](https://miro.medium.com/v2/resize:fit:480/1*3JqMenMdO5NIFvKGb0Tylg.gif)\n\n그래서 저는 이전 스크립트를 포함하고 사용자 정의 런타임 람다를 생성하고 자체적으로 그 인보케이션을 테스트할 필요한 AWS 리소스를 생성하는 Terraform 모듈을 만들었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Lambda 함수와 해당 사용자 지정 런타임을 배포하고 탐색하려면 작성하고 실행해야 하는 Terraform 스크립트입니다:\n\n```js\ndata \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n\nlocals {\n  current_account_number = data.aws_caller_identity.current.account_id\n  region = data.aws_region.current.name\n}\n\nmodule \"custom-lambda\" {\n  source = \"github.com/Ilyassxx99/lambda-custom-runtime.git\"\n  custom_bash_function_name = \"custom-bash-function\"\n  custom_bash_ecr_repository_name = \"custom-lambda\"\n  current_account_number = local.current_account_number\n  docker_image_custom_bash_uri = \"custom-lambda:latest\"\n  lambda_image_custom_bash_version    = \"3.12.2\"\n  lambda_image_arch              = \"amd64\"\n  region = local.region\n  tags = {\n    Terraform-module = \"custom-bash-runtime\"\n  }\n}\n```\n\n# 결론\n\n제 블로그 시리즈 '고급 AWS Lambda'의 첫 번째 글에서는 Lambda 런타임을 사용자 지정하여 작성한 스크립트에 사용한 어떤 프로그래밍 언어든 지원할 수 있는 방법을 살펴보았습니다. 이것은 Go나 Rust와 같은 AOT 컴파일된 언어로 작업할 때 스크립트의 실행 성능이 중요할 때 매우 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 블로그가 유용했기를 바라요. 피드백이나 이 블로그 주제에 대한 질문 또는 앞으로 논의하고 싶은 다른 기술 주제에 대해 궁금한 점이 있으면 제 LinkedIn(https://www.linkedin.com/in/ifezouaniilyass/)에서 연락해 주세요.\n\n소중한 시간 내어 주셔서 감사합니다. 다음 블로그에서 만나요. 건배!\n\n![Image](https://miro.medium.com/v2/resize:fit:720/1*WIjcsTL49wdYazQX2VS95Q.gif)\n\n## 노트:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- AWS는 Docker 이미지 대신 직접 zip을 가져올 수 있는 OS-only provided.al2023 런타임을 지원합니다. 이 문서에서는 코드에 다른 종속성을 포함해야 하는 경우를 다루기 위해 Docker 이미지를 사용하기로 선택했습니다. Docker 이미지 내에서 패키지/모듈을 직접 더 쉽게 설치하고 패키징할 수 있습니다.\n- Go 또는 Rust와 같이 AOT 컴파일된 언어의 경우, AWS는 런타임을 구현하는 라이브러리를 제공하며 해당 기능을 사용하여 메인 프로세스를 랩핑할 수 있습니다. 이 문서에서는 셸 스크립트를 배포하려고 한다고 가정할 때, 런타임 API 호출과 프로세스 실행을 수행하는 스크립트를 작성해야 합니다.\n\n## 참고:\n\n[1] https://docs.aws.amazon.com/lambda/latest/dg/runtimes-provided.html\n\n[2] https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[3] [Amazon Linux 2023 Runtime for AWS Lambda 소개](https://aws.amazon.com/fr/blogs/compute/introducing-the-amazon-linux-2023-runtime-for-aws-lambda/)\n\n[4] [AWS Lambda 환경 변수 구성](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime)\n\n[5] [Lambda 런타임 API](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html)\n","ogImage":{"url":"/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_0.png"},"coverImage":"/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_0.png","tag":["Tech"],"readingTime":11},{"title":"AWS Powertools를 사용해 Serverless API 문서화 하는 방법","description":"","date":"2024-06-23 00:18","slug":"2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS","content":"\n![서버리스 API 문서화](/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_0.png)\n\n높은 품질의 API 문서는 특히 람다 함수가 API를 제공하는 서버리스 아키텍처에서 고객 만족도를 향상시킵니다. 이러한 API를 문서화하는 것은 언제나 깃털로 소설을 쓰는 것 같았습니다. 그러나 이제는 AWS용 Powertools가 OpenAPI 문서화 유틸리티를 출시하면서 그렇지 않게 됐습니다.\n\n이 게시물에서는 Python 람다 함수 기반 API에 대한 OpenAPI 문서를 생성하는 방법을 소개합니다. AWS 람다 및 Pydantic용 Powertools를 활용합니다.\n\n다음 게시물에서는 이 프로세스를 자동화하고 서비스 CI/CD 파이프라인에 추가하여 제작 게이트 및 문서 게시를 생산물에 추가하는 방법을 논의할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_1.png\" /\u003e\n\n이 블로그 글은 원래 \"Ran The Builder\" 웹사이트에 게시되었습니다.\n\n# API 문서 작성의 필요성\n\nAPI 변경이 필요한 기능을 설계할 때, 나는 그것들을 문서화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 API 우선 접근 방식을 채택하는 것이 중요하다고 강하게 믿습니다. AWS 서버리스 영웅인 Allen Helton은 API 우선 접근 방식의 가치에 대해 훌륭한 글을 썼습니다. 이 방식은 내부 또는 외부 API 사용자가 새로운 API를 발행할 때까지 차단되지 않고 자사의 API와 통합을 개발하고 계획할 수 있도록 합니다. API 문서를 보내고 그들이 작업할 수 있게 해 주는 것입니다.\n\nAPI 문서는 시스템의 제공되는 것을 언제나 상세히 이해하는 데도 도움이 됩니다. 미래의 통합, 새로운 기능 개발, 그리고 신규 팀원을 온보딩하는 데 훌륭합니다.\n\n## OpenAPI — 표준의 왕\n\nOpenAPI가 API를 설명하는 표준 형식으로 자리잡고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nREST API와 관련된 내용을 설명하는 간단한 JSON 또는 YML 형식의 파일이에요!\n\n- 이용 가능한 엔드포인트\n- 각 엔드포인트에 대한 작업\n- 각 작업의 입력 및 출력 매개변수\n- 인증 방법\n- 태그 또는 그룹별로 엔드포인트를 구성하고 샘플 요청을 생성할 수 있어요.\n\nSwagger.io는 이 문서 파일을 시각화할 수 있는 도구에요.\n\n더미 서비스를 위한 포맷의 라이브 데모를 확인할 수 있어요! 이런식으로 보여요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![](/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_2.png)\n\n이제 API를 문서화하는 방법을 이해했으니 람다 함수를 백엔드로 사용하는 서버리스 API에이 프로세스를 적용하는 방법에 대해 이야기해 보겠습니다.\n\n# API 문서 생성\n\n여러 가지 API 문서 생성 방법을 살펴보겠습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 의견으로는 Python 기반 API 문서를 생성하는 가장 좋은 방법은 서비스 코드에서 생성하는 것입니다. Pydantic을 사용하여 입력 및 응답 스키마를 정의하고, 이 스키마를 OpenAPI 형식으로 내보내는 옵션이 내재되어 있어서 제 입장에서는 큰 장점입니다. 따라서 우리가 선택하는 모든 솔루션에 이 도구와 통합해야 합니다.\n\n첫 번째 옵션은 API Gateway에서 기본으로 제공됩니다.\n\nAPI Gateway에는 멋진 기능이 있습니다. 배포한 후 콘솔이나 여기에 설명된대로 API를 통해 OpenAPI 문서를 내보낼 수 있습니다. 그러나 Pydantic을 지원하지 않고, 세부 사항 스키마 (입력 또는 출력) 중 많은 것들이 쉽게 구성되지 않습니다. JSON 스키마를 직접 정의하고 요청 검증을 활성화해야 합니다. 마지막으로, 핸들러 코드가 아닌 인프라 코드로부터 생성되므로 좋지만 완벽하지는 않습니다.\n\n좋은 기능이지만, 더 많은 것이 필요합니다. 다른 방법을 검토해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 번째 옵션은 FastAPI와 같은 프레임워크에서 나옵니다.\n\n대부분의 이러한 Python 프레임워크 및 도구들은 FastAPI, Flask-RESTPlus/Flask-RESTx, Django REST Framework, Connexion과 같이 설계되어 있어 웹 응용 프로그램 및 API를 구축하고 소켓을 통해 수신되는 HTTP 요청을 수신할 수 있습니다.\n\nFastAPI에 초점을 맞춰 봅시다.\n\nFastAPI는 Pydantic 스키마를 지원하여 페이로드를 설명하고 코드에서 직접 OpenAPI 문서를 생성할 수 있습니다. 이 접근 방식은 문서 작성 프로세스를 간소화하고 코드와 동기화를 유지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 Lambda에서 웹 서버를 실행하기 때문에 이미 Lambda 서비스가 대신 수신되는 HTTP 요청을 수신하기 위해 소켓을 여는 방식으로 작동합니다. 이것은 서버 기반 프레임워크이며, 콜드 스타트, Lambda ZIP 파일 크기 및 지연 시간에 부정적인 영향을 미칩니다. 가능은 하지만, 필요한가 싶진 않습니다.\n\n내 의견으로는, 핸들러 코드로부터 생성된 OpenAPI 문서를 제공하는 네이티브 서버리스 프레임워크가 필요합니다. 빠르고 Lambda의 호출 모델과 일치하며, 이에 따라 자체적으로 소켓을 열어서는 안 됩니다.\n\n어떻게 그것을 실현할 수 있는지 살펴봅시다.\n\n# 서버리스 OpenAPI 문서\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 목표는 API Gateway와 Lambda 함수로 구성된 서버리스 API에 대한 OpenAPI 문서를 생성하는 것입니다. HTTP 입력 페이로드 스키마와 모든 가능한 HTTP 응답(상태 코드 및 JSON 페이로드)를 정의할 것입니다. 우리는 Pydantic을 사용하여 모든 스키마를 정의할 것입니다.\n\nOpenAPI 문서는 새로운 API 엔드포인트인 '/swagger' 아래에서 제공될 것입니다.\n\n다음 블로그 포스트에서는 문서 내보내기 및 이 전체 프로세스를 자동화하는 방법에 대해 논의할 것입니다.\n\n이제 목표를 이해했으니 코드를 작성해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Powertools EventHandler 소개\n\n우리는 AWS Lambda용 Powertools 라이브러리를 사용합니다. Powertools for Lambda는 서버리스 운영을 위한 관측 가능성, 로깅, 아이덤포턴시, 입력 유효성 검사 및 기타 여러 가지 기능을 제공하는 라이브러리입니다.\n\nPowertools의 이벤트 핸들러 유틸리티를 사용할 것입니다.\n\n이벤트 핸들러 유틸리티는 API Gateway REST/HTTP API, ALB 및 Lambda Function URL에 대한 보일러플레이트를 줄이기 위한 가벼운 루팅을 제공합니다. 이 유틸리티는 마이크로 함수(한 개 또는 몇 개의 라우트) 및 모놀리식 함수(모든 라우트)와 함께 작동합니다. 가장 흥미로운 점은 OpenAPI와 Pydantic 스키마를 사용한 요청/응답의 데이터 유효성 검사 기능을 제공한다는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오픈API 문서는 비교적 새로운 기능입니다. 이는 API Gateway에서 '/swagger' 엔드포인트를 제공하여 OpenAPI 문서를 출력합니다.\n\n실제 서비스에서 이벤트 핸들러 및 데이터 유효성 검사를 구현해 봅시다.\n\nAWS 람다 쿡북 템플릿 프로젝트를 사용하여 OpenAPI 문서를 지원하도록 추가할 것입니다. 쿡북은 서버리스를 시작하는 데 세 번의 클릭만으로 모든 최상의 실전 서버리스 서비스가 요구하는 모든 최상의 실전 서버리스 서비스가 요구하는 모범 사례와 유틸리티를 포함한 템플릿 프로젝트입니다.\n\n인프라 구성부터 시작해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## OpenAPI 엔드포인트 인프라\n\n공식 문서에 SAM 코드 샘플이 있지만, 저는 AWS CDK를 사용합니다.\n\n아래는 CDK REST API 구성에 추가할 함수입니다.\n\n이 함수를 사용하여 GET ‘/swagger’ HTTP 호출에 응답하고 OpenAPI 문서를 생성하는 람다 핸들러를 선택해야 합니다. 우리는 이벤트 핸들러 유틸리티를 사용하는 람다 함수를 연결해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n/swagger, /swagger.css, /swagger.js 세 개의 'GET' 엔드포인트를 해당 기능과 매핑해야 합니다.\n\n5번 라인에서는 새로운 엔드포인트를 추가할 REST API 게이트웨이 개체를 이 함수에 전달하며, 이 엔드포인트를 처리할 람다 함수 클래스를 받습니다.\n\n7번부터 14번 라인까지, 세 개의 엔드포인트를 추가하고 HTTP GET 명령을 사용하여 람다 함수를 연결합니다.\n\n전체 코드는 여기에서 찾을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 이벤트 핸들러 코드\n\n이제 모든 인프라가 구성되었으니 이벤트 핸들러 코드를 추가하고 API 문서화를 시작해 봅시다.\n\n3번 줄에서는 이벤트 핸들러 API 게이트웨이 리졸버를 생성하고 입력 이벤트와 출력 응답 유효성 검사(Pydantic 사용)를 얻기 위해 유효성을 활성화합니다.\n\n4번 줄에서는 '/swagger' 엔드포인트를 통해 OpenApi 생성을 활성화하고 생성된 문서에 제목을 전달합니다. 문서에 따르면 완전한 OpenAPI 정의를 얻으려면 검증을 활성화해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 전체 코드를 찾을 수 있어요.\n\n## 람다 핸들러 코드\n\n람다 핸들러 코드를 작성하고 문서화해봅시다.\n\n새로운 고객 주문을 생성하는 HTTP POST '/api/orders' 엔드포인트에 대해 문서화하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에는 많은 내용이 있지만, 꽤 간단해요. 우리는 가능한 한 많은 OpenAPI 정보를 추가할 거예요. 특정 API, 설명, JSON HTTP 본문의 입력 스키마, 그리고 모든 가능한 HTTP 응답 스키마를 Pydantic으로 설명할 거예요.\n\n8번째 줄에서, 우리는 이전 파일에서 초기화한 이벤트 핸들러를 가져와요.\n\n13번째 줄에서, 우리는 앱 정의를 시작해요. 먼저, 이 API를 HTTP POST로 표시해요.\n\n14번째 줄에서, 우리는 API를 '/API/orders/' 경로에 응답할 수 있도록 설정해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n15번 라인에서는 OpenAPI 문서에 표시될 API 설명을 설정합니다.\n\n18~31번 라인에서는 모든 API 응답을 정의합니다.\n\n19~22번 라인에서는 HTTP 200 OK 응답을 정의합니다. 이렇게하면 모든 HTTP 응답 정의를 제어할 수 있습니다. 이 응답을 정의하지 않으면 이벤트 핸들러가 자동으로 422 및 200 응답을 생성하고 501 응답을 자동으로 생성하지는 않음을 유의하세요. 422는 입력 유효성 검사 기능에서 내장된 응답이며, 200 응답은 35번 라인에서 정의한 'CreateOrderOutput' Pydantic 스키마를 사용하여 구축됩니다.\n\n23~26번 라인에서는 HTTP 코드 422를 사용하여 HTTP 입력 유효성 검사 응답을 정의합니다. 'InvalidApiRequest' Pydantic 스키마를 사용하여 설명했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n27–30 줄에서 우리는 HTTP 501에 대해 동일한 작업을 수행합니다.\n\n32 줄에서는 이 API를 'CRUD'라는 그룹의 일부로 태그합니다. 여러 개의 API가 있는 경우 태그를 사용하면 하나의 긴 목록이 아닌 여러 하위 목록에서 API를 제시하는 것이 더 쉬워집니다.\n\n39 줄에서는 핸들러의 엔트리 함수를 정의합니다. 리졸버는 HTTP 경로와 명령에 따라 올바른 이벤트 핸들러 하위 함수를 호출합니다. 여기서 더 자세히 알아볼 수 있습니다. 우리 경우에는 모든 호출이 13–36 줄에서 정의한 함수로 라우팅됩니다.\n\n34–35 줄에서 핸들러가 예상하는 입력을 정의하기 위해 타입 힌트를 사용합니다. 데이터 유효성 검사를 활성화했기 때문에 36 줄에 도달하면 파이다닉 오브젝트가 파싱되고 직렬화되어 일반 이벤트가 아닌 딕셔너리 형식으로 손에 넣게 됩니다. 제가 Annotated와 body typing 클래스를 사용하여 이벤트 핸들러가 본문 페이로드에 'CreateOrderInput' 클래스가 필요하며 JSON 딕셔너리이며 문자열이 아님을 알려주었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI 요청과 응답은 모두 그들을 정의하는 Pydantic 스키마를 가지고 있습니다. Pydantic 스키마 정의는 여기와 여기에서 찾을 수 있습니다.\n\n전체 핸들러 코드는 여기에서 찾아볼 수 있습니다.\n\n저는 아키텍처 레이어 컨셉에 따라 이 핸들러와 로직을 작성했는데, 이 내용은 AWS re:Invent 2023 세션에서도 다뤘어요. 자세한 내용은 여기를 클릭해 더 알아보세요.\n\n# OpenAPI Endpoint in Action\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 남은 일은 코드를 배포하고 스웨거 엔드포인트에 액세스하는 것뿐입니다.\n\n다음과 같은 모습일 것입니다:\n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n스키마를 클릭하면 Pydantic 정의 출력이 제대로 된 OpenAPI 스키마로 표시되는 것을 확인할 수 있습니다. 설명, 제한 사항 및 유형이 포함됩니다.\n\n여기에서 실시간 버전의 스웨거를 확인할 수도 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://tzmt8vspl4.execute-api.us-east-1.amazonaws.com/prod/swagger\n\n# 제한 사항\n\n이 새로운 유틸리티에 꽤 감명받았어요. 그러나 몇 가지 제한 사항이 있습니다.\n\n이는 해결 가능하지만 Powertools 팀이나 커뮤니티로부터의 개발이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, OpenAPI 명세의 전체가 생성되지는 않습니다. 그럼에도 불구하고 저장소에 여전히 열려 있는 문제들이 있으며, 커뮤니티의 도움을 요청하고 있기 때문에 시도해보고 싶다면 의미 있는 첫 번째 기여가 될 수 있습니다!\n\n이제 더 중요한 문제로 넘어가겠습니다.\n\n작성 시점에서 여러 마이크로 함수를 사용하면 OpenAPI 생성이 지원되지 않습니다. 단일 람다만 지원됩니다. 제가 제안한 해결책으로 GitHub 이슈를 만들었으며, 이 문제에 대한 긍정적인 피드백을 주시면 사물을 움직이는 데 도움이 될 것입니다.\n\n# 요약\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 게시물에서는 AWS용 Powertools가 핸들러 코드에서 OpenAPI 문서를 생성하는 데 어떻게 도움을 줄 수 있는지 알아보았습니다. 이는 개발자가 코드와 해당 설명 문서를 소유하고, 무엇보다도 두 가지를 항상 동기화하는 방법에 대한 지원을 제공합니다.\n\n다음 글에서 제가 이 접근 방식을 어떻게 더 발전시킬 수 있는지, 상당히 중요한 것을 추가하여 코드와 API 설명 문서 사이의 소중한 동기화를 보호할 수 있는 방법에 대해 논의할 예정입니다. 함께 해주세요!\n","ogImage":{"url":"/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_0.png"},"coverImage":"/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_0.png","tag":["Tech"],"readingTime":14},{"title":"기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시","description":"","date":"2024-06-23 00:17","slug":"2024-06-23-ReflectionsandBasicWebApplicationArchitecture","content":"\n\u003cimg src=\"/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_0.png\" /\u003e\n\n둘째 주가 끝나고, GitHub와 버전 관리에 대해 많이 배웠어요!\n\n이번 주에 저는 GitHub에서 저장소를 만들고, 커맨드 라인 인터페이스(CLI)를 사용하여 컴퓨터에 복제했어요. 또한 CLI로 커밋하고 README 파일을 GitHub에 푸시하고, 새로운 브랜치를 만들고, 파일을 업데이트하고, 풀 리퀘스트를 메인 브랜치에 병합하는 등 많은 작업을 할 수 있다는 것을 발견했어요. 게다가, 컴퓨터에 아마존 웹 서비스(AWS) CLI를 설치하고 연습했어요.\n\n이번 주에 웹 애플리케이션 아키텍처의 기본을 배우고, 배운 내용을 강화하기 위해 간단한 설정을 디자인하는 데 많은 시간을 보냈어요. AWS와 어떻게 관련이 있는지 알아볼까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 웹 애플리케이션 아키텍처\n\n그렇다면, 먼저 웹 애플리케이션 아키텍처는 무엇일까요?\n\n웹 애플리케이션 아키텍처는 웹 사이트가 어떻게 구성되어 작동하는지를 나타냅니다. 세 가지 주요 구성 요소가 있습니다: 프론트엔드, 백엔드 및 데이터베이스 (아래에 만든 다이어그램 참조). 프론트엔드는 당신이 보고 클릭하는 것들인데, HTML, CSS 및 JavaScript로 만들어진 버튼이나 사진과 같은 것들입니다. 백엔드는 웹 사이트의 뇌와 같습니다. 모든 로직과 처리를 처리하며 Python이나 JavaScript와 같은 언어를 사용합니다. 데이터베이스는 모든 정보가 저장되는 곳으로, 큰 디지털 파일 캐비닛처럼 작동합니다. 이러한 부분들은 웹을 통해 서로 대화하여 웹 사이트를 사용할 때 모든 것이 원활히 작동하도록 합니다. 아래는 모든 게 어떻게 작동하는지에 대한 이미지입니다.\n\n![웹 애플리케이션 아키텍처 다이어그램](/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 용어 설명\n\n위 다이어그램에 포함된 내용을 더 잘 설명하기 위한 어휘 목록입니다.\n\n최종 사용자: 제품이나 서비스를 사용하는 사람입니다. 이 경우에는 웹 애플리케이션과 상호 작용하는 사람으로, 휴대폰이나 태블릿과 같은 모바일 기기를 통해 웹 애플리케이션과 상호 작용하는 사람을 의미합니다.\n\n프론트엔드: 웹사이트나 앱의 일부로, 사용자가 보고 상호 작용하는 부분을 말합니다. 화면에 나타나는 모든 것인 버튼, 그림, 텍스트, 메뉴 등을 포함합니다. HTML, CSS, JavaScript와 같은 도구를 사용하여 멋지게 보이고 매끈하게 작동하도록 만들어집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도메인 이름 시스템(Domain Name System)은 전화번호부와 비슷해요. www.amazon.com 같은 웹사이트를 방문하려고 할 때 브라우저에 입력하면 DNS가 빠르게 웹사이트가 저장된 위치(IP 주소)를 찾아내고 컴퓨터에게 어떻게 찾아갈 지 알려줘요. 이렇게 하면 복잡한 주소를 알 필요 없이 원하는 웹사이트에 방문할 수 있어요. AWS Route 53은 AWS가 제공하는 DNS 서비스에요.\n\n백엔드는 모든 데이터와 정보가 저장되고 처리되는 곳이에요. 웹사이트에서 버튼을 클릭하여 메시지를 보내거나 물건을 구매하는 등의 작업을 할 때 백엔드가 그 요청을 처리해줘요.\n\n로드 밸런서는 웹사이트와 앱의 교통 관리자와 같아요. 많은 사람들이 동시에 웹사이트를 방문하려고 할 때, 로드 밸런서는 모든 요청을 처리하는 데 도움을 줘요. 각 서버에 일을 고르게 분배하여 한 대의 서버가 과부하되지 않게 해요. 그래서 웹사이트는 모든 사용자에게 빠르고 반응성 있는 상태를 유지할 수 있어요. AWS에서 로드 밸런서를 \"Elastic Load Balancer\"(ELB)라고 부르고 있어요.\n\n서버는 인터넷을 통해 다른 컴퓨터와 정보를 저장하고 공유하는 강력한 컴퓨터에요. 폰에서 웹사이트나 앱을 사용할 때 실제로 세계 어딘가의 서버에 연결하게 될 거예요. 이 서버는 온라인에서 보거나 상호작용하는 모든 사진, 비디오, 텍스트 등을 저장해요. 인터넷 상의 모든 것이 원할하고 빠르게 작동할 수 있도록 노력하며, 좋아하는 웹사이트와 앱에 언제든지 접속할 수 있도록 해줘요. AWS는 클라이언트가 활용할 수 있도록 전 세계의 큰 데이터 센터에 EC2 서버를 구축해 두고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터베이스: 웹 애플리케이션 데이터베이스는 사용자 이름, 비밀번호, 사진 등 웹 사이트가 기억해야 하는 모든 중요한 정보를 보관하는 디지털 컨테이너와 같습니다. 웹 사이트에 가입하거나 댓글을 게시할 때 이 정보는 데이터베이스에 저장되어, 웹 사이트가 다음 방문 때에도 해당 정보를 기억할 수 있습니다. 데이터베이스는 웹 사이트의 모든 것이 원할하게 작동하고 정보가 안전하고 조직적으로 유지되도록 보장합니다. AWS RDS(관계형 데이터베이스 서비스)가 이러한 예시 중 하나입니다.\n\n# 반성\n\n2주차에는 일부 어려움이 있었지만 그때마다 능력이 더 향상된 것 같아요. 이 어려움들은 웹 개발 도구와 관행의 기본 원리에 대한 탐구의 여정으로 이끌어주었어요. GitHub를 이용해 저장소 생성, 복제, 명령 줄 인터페이스를 통한 버전 관리를 익혔고, AWS CLI를 탐험하며 앞으로의 프로젝트에서 귀중한 경험을 쌓을 수 있었어요.\n\n이번 주 중요한 부분 중 하나는 웹 애플리케이션 아키텍처를 이해하는 데 헌신했습니다. 웹 사이트가 원활하게 작동하도록 보장하는 설계도와 같다는 것을 배웠어요. 이는 세 가지 핵심 부분으로 구성되어 있어요: 사용자가 버튼과 시각적 요소와 상호작용하는 프론트엔드, 로직 처리와 배경에서의 처리를 담당하는 백엔드, 모든 웹 사이트 정보를 안전하게 저장하는 데이터베이스가 있어요. 이러한 구성 요소는 협력하여 통일된 사용자 경험을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미래를 기대하며, 웹 애플리케이션 아키텍처의 복잡성에 더 깊이 파고들기를 기대하고 있어요. 다음 주에는 이러한 기본 개념이 AWS 서비스와 어떻게 통합되어 내 이해력과 기술 세트를 더욱 향상시키는지 살펴볼 거에요. 클라우드 엔지니어링의 매혹적인 세계에 대한 더 많은 통찰력을 기대해 주세요!\n\n지금은 여기까지입니다!\n\nBlaize\n","ogImage":{"url":"/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_0.png"},"coverImage":"/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_0.png","tag":["Tech"],"readingTime":5},{"title":"몇 번의 클릭으로 IAM 정책 시각화 하는 방법","description":"","date":"2024-06-23 00:16","slug":"2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks","content":"\n우리 모두가 IAM 정책이 AWS 리소스를 보호하는 데 매우 중요하다는 것을 알고 있습니다. 그러나 IAM 정책을 시각화해 본 적이 있나요? 아니라면, 이 게시물이 도움이 될 것입니다. 이 게시물에서는 IAM 정책을 몇 번의 클릭만으로 시각화하는 방법을 살펴보겠습니다.\n\n# IAM 정책을 시각화하는 이유\n\n간단한 IAM 정책이 다중 명령문을 가진 시나리오를 고려해 봅시다. 각 명령문에는 여러 작업, 리소스 및 조건이 있습니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n{\n      \"Version\": \"2012-10-17\",\n      \"Statement\": [\n          {\n              \"Effect\": \"Allow\",\n              \"Action\": [\n                  \"s3:GetObject\",\n                  \"s3:PutObject\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          },\n          {\n              \"Effect\": \"Deny\",\n              \"Action\": [\n                  \"s3:*\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringNotEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          }\n      ]\n  }\n```\n\n이제 정책을 이해하려면 정책을 읽고 이해해야 합니다. 하지만, 여러 문과 조건이 포함된 복잡한 정책이 있는 경우는 어떨까요?\n\n예시:\n\n```js\n{\n      \"Version\": \"2012-10-17\",\n      \"Statement\": [\n          {\n              \"Effect\": \"Allow\",\n              \"Action\": [\n                  \"s3:GetObject\",\n                  \"s3:PutObject\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          },\n          {\n              \"Effect\": \"Deny\",\n              \"Action\": [\n                  \"s3:*\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringNotEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          },\n          {\n              \"Effect\": \"Allow\",\n              \"Action\": [\n                  \"s3:GetObject\",\n                  \"s3:PutObject\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          },\n          {\n              \"Effect\": \"Deny\",\n              \"Action\": [\n                  \"s3:*\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringNotEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          }\n      ]\n  }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정책을 읽는 것만으로는 정책을 이해하기가 매우 어려울 것입니다. 여기에 IAM 정책 시각화가 등장합니다. IAM 정책을 시각화하여 쉽게 이해하고 필요한 경우 변경할 수 있습니다.\n\n# IAM 정책 시각화 방법\n\n- 이 사이트로 이동하십시오. 이 사이트는 Amazon의 보안 엔지니어인 BOUR Abdelhadi가 만들었습니다.\n\n![IAM Policies Visualization](/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. IAM 정책을 텍스트 영역에 붙여넣으세요. 이제 IAM 정책의 시각적 표현을 \"정책 시각화\" 섹션에서 볼 수 있습니다. 정책을 쉽게 이해하고 필요한 경우 변경할 수 있습니다.\n\n![IAM Policy Visualization 1](/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_1.png)\n\n![IAM Policy Visualization 2](/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_2.png)\n\n3. 조금 아래로 스크롤하면 \"이 정책이 하는 일은?\"을 평문으로 볼 수 있습니다. 이를 통해 정책을 간단하게 이해할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_3.png\" /\u003e\n\n여기까지입니다. 몇 번의 클릭으로 IAM 정책을 성공적으로 시각화했습니다.\n\nIAM 정책을 시각화해야 하는 이유에 대해 더 알아보세요: [여기를 클릭하세요](링크)\n\n사이트 제작자: BOUR Abdelhadi\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinkedIn에서 연결해요: LinkedIn 프로필\n\n실전 프로젝트 살펴보기 (제 저장소가 도움이 된다면 GitHub에서 저를 팔로우하시는 것을 잊지 마세요): 내 GitHub 계정\n","ogImage":{"url":"/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_0.png"},"coverImage":"/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_0.png","tag":["Tech"],"readingTime":5},{"title":"클라우드 보안 전략을 만드는 궁극적인 가이드","description":"","date":"2024-06-23 00:14","slug":"2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy","content":"\n![Cloud Security](/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_0.png)\n\n클라우드 보안은 처음에는 쉽지 않습니다.\n\n저는 지난 20년간 이 산업에서 일한 경험이 있으며, 그 중 마지막 5년은 클라우드에 전념했습니다.\n\n클라우드 보안 여정에서 가장 어려운 단계 중 하나는 클라우드 환경을 보호하기 위한 로드맵을 만드는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지난 몇 년 동안 클라우드 및 디지털 채택이 급증했으며, 적절한 로드맵이 없는 사이버 보안 팀은 후속 문제에 직면할 수 있습니다.\n\nCIO들과 CISO들이 앉아서 자신들의 클라우드 워크로드를 안전하게 보호하기 위한 최상의 접근 방식을 논의할 때, 상당한 양의 자료에 물들게 될 것입니다. 그것은 상당히 짜증날 수 있습니다!\n\n다양한 클라우드 구현 경험을 바탕으로, 나는 성공적인 클라우드 보안 구현을 위한 주요 성공 요소가 무엇인지 요약해 보기로 했습니다.\n\n로드맵을 세 가지 기본 단계로 나누었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기초\n- 실행\n- 최적화\n\n참고: 제 경험을 바탕으로 가능한 한 상세하게 작성하려고 노력했지만, 대부분의 회사에 적용하기에 너무 상세해서 실용적이지 않게 만드는 것은 피했습니다.\n\n# 단계 1: 기초 다지기\n\n클라우드 보안 프로젝트가 실패하는 가장 일반적인 이유 중 하나는 CISO가 단순히 온프레미스 모델을 클라우드에 그대로 복사하려는 것 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구름의 이해 부족은 매우 강력한 원천 기능이 무시되는 결과를 초래할 수 있습니다. 그러므로 여정을 시작하기 전에 적절한 기초를 마련하는 것이 매우 중요합니다.\n\n다음은 몇 가지 중요한 기본 요소들입니다.\n\n## A. 규정 환경 이해\n\n클라우드 보안 여정을 시작하기 전에, 특정 지리에 대한 규정을 알아야 하는 것이 결정적인 첫 번째 단계입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n올바르게 처리하지 않으면 권한이 없는 데이터를 이동할 수 있으며 엄격한 규정 위반으로 엄격한 벌금을 부과 받을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_1.png)\n\n특정 국가는 자국 데이터를 자국 이외로 이동할 수 없도록하며 규정 미준수에 대해 엄중한 벌금을 부과합니다.\n\n유익한 점은 대부분의 규정이 보안에 대한 최상의 실천 방법과 겹치기 때문에 적절한 프레임워크를 먼저 마련하면 나중에 작업량이 현저히 줄어듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHIPAA, PCI DSS 또는 SOC 2와 관련하여, 귀하의 법률 부서와 적절한 부문의 dos 및 don`ts를 완전히 숙지하기 위해 상호 협력하는 것이 중요합니다.\n\n매년 종일 감사를 하는 데 지치는 사이버 보안 팀에게 한 가지 놀라운 소식은 대부분의 클라우드 제공업체가 그들을 위해 많은 일을 처리한다는 것입니다.\n\nAWS, Azure 및 Google은 모두 매년 수백 개의 로컬 및 글로벌 인증을 실행하는 여러 제3자 프로그램을 보유하고 있으며, 이러한 인증은 수수료 없이 요청할 수 있습니다.\n\nAWS artifact는 AWS에 대한 수백 개의 보고서에 액세스할 수 있는 예시 중 하나입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_2.png\" /\u003e\n\n## B. 공유 책임 모델 이해\n\n공유 책임 모델은 클라우드에서 무언가를 구현하기 전에 미리 알아둬야 할 가장 중요한 것 중 하나입니다.\n\n클라우드에서 보안은 고객과 클라우드 제공업체가 함께 작업하여 환경을 안전하게 유지해야 하는 공유 책임이 되므로 이를 미리 알아두는 것이 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기반이 거의 다 마무리되었지만, 데이터와 애플리케이션에 대한 통제를 시행하여 귀하의 영역이 규정 준수를 하고 있는지 확인해야 합니다.\n\nAWS는 구름의 보안을 책임지고, 귀하는 구름 안에서의 보안을 담당합니다.\n\n![이미지](/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_3.png)\n\n이것은 사용하는 모델에 따라 달라질 수 있습니다 (완전히 관리되는 모델, IaaS 또는 플랫폼 등). 클라우드 제공업체는 귀하가 선택한 모델에 따라 일을 더 맡기거나 적게 맡을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_4.png\" /\u003e\n\n## C. 팀을 병렬적으로 강화하세요\n\nCISO이고 클라우드 보안 여정을 시작하는 경우, 팀 내에서 클라우드 기술을 구축하는 것이 중요한 기본 단계입니다.\n\n외부 컨설턴트에만 의존하지 마세요. 그들은 프로젝트가 끝나면 대개 떠나가고 내부 팀은 매일 운영을 맡게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n팀원들은 투자가 이루어지고 있기 때문에 이를 신뢰의 표시로 인식할 것입니다.\n\n# 단계 2: 클라우드 보안\n\n이제 클라우드에 대한 견고한 기본 지식과 규제 승인(희망적으로!)이 확보되었으니, 클라우드 환경을 안전하게 유지하는 방법을 살펴볼 차례입니다.\n\n말씀드린대로, 온프렘에서 사용 중인 도구 세트를 그대로 복사하려고 하지 마세요. 항상 네이티브 클라우드 서비스를 먼저 사용하려고 노력해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 단계는 팀에서 가장 많은 노력과 스트레스를 유발할 수 있는 단계 중 하나입니다.\n\n이 단계에서 가장 중요한 두 가지는 벤치마킹과 클라우드 보안 모델을 만드는 것입니다.\n\n## A. 벤치마킹\n\n클라우드에서 보안 상태를 즉시 파악하는 가장 좋고 빠른 방법은 보안 모베스트 프랙티스에 대한 벤치마킹을 활성화하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋은 소식은, 구글, Azure 및 AWS와 같은 공급 업체가 이미 사전 구성된 벤치마크를 제공하여 환경을 측정할 수 있습니다.\n\n첫 날부터 CIS 벤치마크를 활성화하여 클라우드 내에서 쉽고 빠른 보안 성과를 얻는다면, CISO를 기쁘게 만들 수 있는 좋은 방법일 것입니다.\n\n아래는 각 메이저 프로바이더에 대한 도구입니다:\n\n- AWS Security Hub\n- Azure Security Center (Microsoft Defender로 변경됨)\n- Google 규정 준수 센터\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 외에도, 예산이 있는 경우에는 가시성을 얻을 수 있는 제3자 도구가 있습니다.\n\n참고: 1일차의 높음 / 중간 수의 갯수에 대해 걱정하지 마세요. 모든 환경에 정상입니다. 하지만 아무것도 놓치지 않도록 위험 추적이 프로세스로 구현되어 있는지 확인해 주세요.\n\n## B. 클라우드 보안 모델 구축하기\n\n벤치마크가 활성화되었다면, 이제는 환경을 위한 고수준 보안 프레임워크를 구현하는 시기입니다. 아래는 중점을 두어야 하는 주요 영역입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 신원 제어: 클라우드에서의 신원은 방화벽입니다. 그래서 이를 우선으로 생각해야 합니다. 그냥 MFA를 활성화하고 끝내지 마세요. 대신 신원을 위한 적절한 보안 생태계를 구축해야 합니다. 단일 사인온 시스템과 연결하여 클라우드에서 별도의 신원 집합을 관리할 필요가 없도록 하는 것이 가장 좋은 방법입니다.\n\n- 암호화: 암호화 제어는 클라우드로 들어가는 PCI, PII와 같은 민감한 데이터를 어떤 규정에 맞춰야 하는지에 따라 다를 것입니다. 데이터가 정지 상태에 있을 때와 전송 중에 대한 암호화 제어를 알아두세요. AWS 및 다른 클라우드 제공업체는 암호화 키를 다루는 뛰어난 관리 서비스를 제공하며, 이를 통해 내부에서 HSM을 관리하는 번거로움을 줄일 수 있습니다.\n\n- 로깅 및 경보: 클라우드에서 로깅 및 경보를 지나치게 하는 것은 매우 쉽습니다. 경보를 너무 적게 만들면 중요한 데이터를 놓치게 될 수 있고, 너무 많이 만들면 대응팀을 분주하게 만들어 경보 피로를 야기할 수 있습니다. 좋은 점은 이미 벤치마킹을 활성화했다면, 이러한 항목 중 많은 것을 경보로 변환하고 해당 사항을 추가하기만 하면 됩니다.\n\n- 작업 부하 보호: 클라우드 워크로드를 실행할 때 VM, 컨테이너 및 클러스터를 보호하고 안전하게 유지해야 합니다. VM은 안전한 이미지에서 시작해야 합니다. 컨테이너 이미지는 시작하기 전에 검사돼야 하며, 실행 시 보호는 전반적으로 제공되어야 합니다. 클라우드를 위한 최소 요구 사항으로 만드세요.\n\n- 위협 인텔리전스: 클라우드에서 가장 멋진 점 중 하나는 클라우드 제공업체 덕분에 얼마나 많은 위협 인텔리전스에 접근할 수 있는지입니다. Azure, Google 및 AWS는 고객이 혜택을 받는 위협 인텔리전스 기술에 수십억을 투자하고 있습니다. 이 데이터는 클라우드 서비스에 공급되어 공격의 조기 탐지를 가능케 합니다. 서비스는 초기에 활성화하여 첫날부터 학습을 시작하고 사전에 조치를 취할 수 있는 기준 값을 생성할 수 있도록 하세요.\n\n# 단계 3: 클라우드 최적화\n\n이 단계는 클라우드 제어에 대한 자신감을 키워나갈 때이며, 더 전략적인 작업에 집중할 수 있는 시기입니다. 이 단계에서 살펴볼 몇 가지 주요 영역은 아래와 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 알림을 자동으로 해결하도록 설정하여 보안 팀이 더 생산적으로 작업에 집중할 수 있도록 합니다.\n- 기존 알림 논리를 세부 조정하면 무엇이 작동하고 무엇이 그렇지 않은지 알 수 있습니다.\n- 이전 단계에서 부여된 클라우드 권한을 정리합니다. 지금쯤 누가 어떤 권한이 필요한지 알 수 있고 그에 맞게 조정할 수 있습니다.\n- Slack과 같은 협업 도구를 통해 도구 세트를 확장하면 보안 프로세스의 효율성을 크게 높일 수 있으며, 이메일 문화에서 벗어날 수 있습니다.\n\n## A. 리스크 검토\n\n첫 날부터 리스크 추적기를 유지해야했지만, 이제는 리스크 데이터베이스를 신중히 살펴보고 무엇을 유지할지와 관리부서가 수용해야 하는 것을 결정해야 합니다. 실용적으로 생각하고 완벽한 100% 완료된 리스크 추적기를 얻을 수 없음을 깨닫는 것이 중요합니다.\n\n수정할 수 있는 것은 추적하고, 수정할 수 있는 것은 닫아야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것은 주요 단계를 마무리하고 성공적인 클라우드 보안 여정으로 나아가게 도와줍니다.\n\n더 많은 세부 정보를 원하시면, 아래에서 만든 비디오를 확인해보세요.\n\n![이미지](/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_5.png)\n\n타이머 이즈랄은 핀테크 산업에서 사이버 보안 및 IT 리스크 관리 분야에서 20년 이상의 국제적 경험을 보유한 다중 수상 경력을 지닌 정보 보안 리더입니다. 타이머에게는 링크드인이나 그의 유튜브 채널 \"클라우드 보안 가이\"에서 연락할 수 있으며, 거기에서는 클라우드 보안, 인공지능 및 일반적인 사이버 보안 진로에 관한 조언을 정기적으로 게시하고 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_0.png"},"coverImage":"/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_0.png","tag":["Tech"],"readingTime":10},{"title":"클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기","description":"","date":"2024-06-23 00:13","slug":"2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments","content":"\n![2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments](/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_0.png)\n\n# 소개\n\n클라우드로 애플리케이션을 배포하는 것은 현대 소프트웨어 개발의 중요한 부분이 되었습니다. AWS는 클라우드 배포를 용이하게 하는 서비스로 CloudFormation을 제공하며 AWS Cloud Development Kit(CDK) 같은 도구를 제공합니다. 동시에 Terraform은 다중 클라우드 제공 업체로 더 빠른 배포를 가능케 하는 인프라스트럭처의 코드(IaC)에 강력한 솔루션이 되었습니다. 이 글에서는 AWS CDK와 Terraform을 함께 사용하는 이점을 살펴보고 TypeScript에서 CDK를 사용하여 REST API를 생성하는 실용적인 예제를 살펴보겠습니다.\n\n# Terraform과 CDK란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테라폼과 CDK는 인프라를 코드로 정의하는 데 도움을 주는 주요 도구들입니다. 각 솔루션에는 각각의 장단점이 있습니다. 좀 더 자세히 알아보도록 하죠.\n\n## 테라폼\n\n테라폼은 HashiCorp에서 만든 도구로, HCL (HashiCorp Configuration Language)이라는 고수준 구성 언어를 사용하여 인프라를 정의할 수 있게 해줍니다. 테라폼은 클라우드에 독립적이며 AWS, Azure, Google Cloud Platform을 포함한 다양한 클라우드 제공 업체 간의 인프라를 관리할 수 있습니다. 또한 AWS의 경우 CloudFormation과 비교했을 때 빠른 배포를 가능하게 합니다.\n\n## AWS CDK\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS Cloud Development Kit (CDK)은 클라우드 인프라를 코드로 정의하고 AWS CloudFormation을 통해 프로비저닝하는 오픈 소스 소프트웨어 개발 프레임워크입니다. CDK는 TypeScript를 포함한 익숙한 프로그래밍 언어를 사용하여 애플리케이션을 모델링합니다. CDK는 코드를 사용하여 인프라를 생성하기 위해 일반적인 CloudFormation 템플릿을 생성합니다. 이 추상화로 인해 CDK를 사용하여 몇 줄의 코드로 매우 긴 CloudFormation 템플릿을 생성할 수 있습니다. 이는 개발자가 즐겨 사용하는 프로그래밍 언어로 편리하게 인프라 코드를 구현하고 유지할 수 있도록 도와줍니다.\n\n# Terraform과 CDK를 함께 사용하는 이점\n\n두 도구를 함께 사용하면 양쪽의 이점을 누릴 수 있습니다. Terraform은 HCL을 사용하지만 개발자에게는 불편할 수 있습니다. CDK는 몇 줄의 코드로 인프라를 구현하기 위한 고수준 재사용 가능한 CDK 구조를 제공함으로써 이를 해결합니다. 또한 매우 익숙한 프로그래밍 언어를 사용하기 때문에 개발자에게 친숙합니다.\n\n반면, CDK는 CloudFormation을 내부적으로 사용하며 이는 일반적으로 Terraform보다 느릴 수 있습니다. 그러나 CDK와 Terraform을 함께 사용할 때 Terraform을 사용하여 클라우드 배포를 수행하기 때문에 훨씬 빠른 클라우드 배포를 할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 프로젝트 설정\n\nCDK를 사용하여 Typescript를 언어로 사용하여 Terraform 프로젝트를 설정해 봅시다. CDK를 Terraform에 사용하기 위한 몇 가지 선행 조건을 설정해야 합니다.\n\n- Terraform CLI\n- NodeJS\n- TypeScript\n- CDKTF CLI\n\n설정이 완료되면 프로젝트를 시작할 수 있습니다. 먼저, 초기 코드를 설정할 폴더를 만들어 보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 CLI 명령어를 사용하여 프로젝트를 초기화할 수 있어요. 이 프로젝트에서는 TypeScript를 사용할 거에요.\n\n프로젝트를 초기화하고 나면, main.ts 파일을 업데이트하여 필요한 인프라를 정의할 수 있어요. main.ts 파일 안에 CDK 앱과 스택이 생성되어 있어요. 스택 내의 리소스를 필요에 맞게 업데이트하여 배포할 수 있어요. API Gateway 및 Lambda 함수를 사용하여 간단한 hello world REST API를 구축해보죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# REST API 구축\n\n어떤 AWS 리소스도 추가하기 전에, AWS를 클라우드 제공업체로 사용할 것이므로 Terraform에서 AWS 프로바이더를 구성해야 합니다. 또한,\n\nTerraform 백엔드를 저장하고 배포 상태를 추적하기 위해 S3 버킷을 사용할 수 있습니다.\n\n아래와 같이 필요한 CDK 생성물 (AwsProvider, S3Backend)과 같은 매개변수를 추가하여 간단히 구성할 수 있습니다.\n\n여기서 우리는 배포에 필요한 AWS 계정 ID와 지역을 제공함으로써 AWS 프로바이더를 구성했습니다. 마찬가지로, S3 백엔드를 구성하려면 버킷 이름과 다른 구성을 제공했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 람다 함수를 실행할 IAM 역할을 생성하고, 기본 람다 실행 역할의 권한을 포함시킵니다.\n\n이제 람다 함수를 생성할 시간입니다. src 폴더 내 index.ts 파일에 람다 함수 코드를 추가해 보겠습니다. 우리는 간단한 hello-world 애플리케이션을 구축하고 있으므로, 람다 함수는 간단한 hello-world 응답을 반환합니다.\n\n람다 함수 핸들러 구현을 추가한 후, 해당 핸들러를 참조하고 람다 함수 리소스를 생성하기 위해 CDK 구현을 추가할 수 있습니다.\n\n위 정의에 따라 함수 코드를 보관할 S3 버킷을 생성하고, 람다 함수를 만듭니다. 앞서 정의한 역할은 함수의 실행 역할로 제공됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n람다 함수가 준비되면 이제 API Gateway REST API를 생성하고 람다 함수와 통합할 수 있습니다.\n\n여기서는 API Gateway를 위한 구성을 정의하고, /hello 경로를 위한 리소스 및 해당 /hello GET 엔드포인트에 대한 GET 메서드를 정의하고 있습니다. 마지막으로, 우리는 앞에서 만든 람다 함수와 프록시 통합으로 통합했습니다.\n\n모든 것이 올바르게 통합되었으므로 API Gateway에 스테이지를 생성하고 아래와 같이 배포를 생성할 수 있습니다.\n\n우리는 설정에서 만들고자 하는 스테이지 이름과 API를 제공했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 필요한 모든 리소스를 생성했습니다. 하지만 해야 할 일이 아직 하나 더 있어요. API Gateway 서비스가 제공된 람다 함수를 호출할 수 있도록 보장해야 합니다. 이를 위해 람다 함수 내에서 해당 작업을 허용하는 리소스 기반 정책을 생성하고 첨부해야 해요. LambdaPermission 구성을 사용하여 아래와 같이 쉽게 할 수 있어요.\n\n이 구성 요소는 람다 함수에 필요한 권한을 추가하여 앞서 생성한 API에 의해 호출될 수 있도록 해줘요. 이렇게 하면 구현이 완료됩니다.\n\n이제 모든 것이 배포할 준비가 됐어요. 인프라를 프로비저닝하기 위해 Terraform이 AWS에 액세스할 수 있도록 AWS 자격 증명을 올바르게 구성했는지 확인하세요. 먼저 코드를 빌드하고 아래 명령을 사용하여 배포할 수 있어요.\n\n![image](/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 명령을 실행하면 CDK for Terraform이 누락된 패키지가 있는 경우 설치되고 배포가 시작됩니다. 배포가 완료되면 생성된 리소스를 확인하고 API를 사용해 볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_4.png)\n\n게다가, 우리는 Terraform이 CloudFormation보다 배포를 훨씬 빠르게 실행한다는 것을 알 수 있습니다. 이는 무척 유리한 점입니다.\n\n만들어 둔 리소스를 삭제하려면 cdktf destroy 명령을 실행할 수 있습니다. 이렇게 하면 프로젝트에서 생성된 모든 리소스가 적절히 정리됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\nAWS CDK를 Terraform과 함께 사용하면 클라우드 인프라를 효과적으로 관리하는 여러 가지 이점이 있습니다. CDK는 AWS와 깊게 통합되어 있으며 TypeScript와 같은 익숙한 프로그래밍 언어를 지원하여 AWS 리소스를 정의하는 것을 직관적이고 유지보수하기 쉽게 만듭니다. Terraform의 클라우드에 중립적인 기능은 여러 클라우드 제공업체에 걸쳐 원활한 관리를 가능하게 하여 CDK를 보완합니다. 이 조합은 유연성, 사용 편의성 및 모듈성을 제공하여 전체 인프라 관리 워크플로우를 향상시킵니다. 이 두 도구를 활용하면 배포 프로세스를 최적화하고 효율성을 향상시키며 더 견고하고 다양한 인프라 관리 솔루션을 구축할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_0.png"},"coverImage":"/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_0.png","tag":["Tech"],"readingTime":8}],"page":"20","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"20"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>