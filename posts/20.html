<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/20" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/20" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="모든 안드로이드 개발자가 알아야 할 ObjectAnimator로 애니메이션 구현하는 방법" href="/post/2024-06-23-EveryAndroiddevelopershouldknowaboutObjectAnimatortouseanimationsinyourApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모든 안드로이드 개발자가 알아야 할 ObjectAnimator로 애니메이션 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-EveryAndroiddevelopershouldknowaboutObjectAnimatortouseanimationsinyourApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모든 안드로이드 개발자가 알아야 할 ObjectAnimator로 애니메이션 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">모든 안드로이드 개발자가 알아야 할 ObjectAnimator로 애니메이션 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코틀린 채널 완벽 정복 초보부터 프로까지 - 1부" href="/post/2024-06-23-MasteringKotlinChannelsFromBeginnertoPro-Part1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코틀린 채널 완벽 정복 초보부터 프로까지 - 1부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-MasteringKotlinChannelsFromBeginnertoPro-Part1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코틀린 채널 완벽 정복 초보부터 프로까지 - 1부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코틀린 채널 완벽 정복 초보부터 프로까지 - 1부</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose의 공식 Pager 컴포저블 탐구하기" href="/post/2024-06-23-ExploringtheOfficialPagerComposableinJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose의 공식 Pager 컴포저블 탐구하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ExploringtheOfficialPagerComposableinJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose의 공식 Pager 컴포저블 탐구하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Compose의 공식 Pager 컴포저블 탐구하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GSoC 2024 두 번째 주  FHIR 안드로이드 애플리케이션에 위치 통합하기" href="/post/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GSoC 2024 두 번째 주  FHIR 안드로이드 애플리케이션에 위치 통합하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GSoC 2024 두 번째 주  FHIR 안드로이드 애플리케이션에 위치 통합하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">GSoC 2024 두 번째 주  FHIR 안드로이드 애플리케이션에 위치 통합하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드 유닛 테스트 101 초보자를 위한 가이드" href="/post/2024-06-23-UnitTestingforAndroidABeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 유닛 테스트 101 초보자를 위한 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 유닛 테스트 101 초보자를 위한 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 유닛 테스트 101 초보자를 위한 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드 앱에서 URL로 썸네일 또는 로고 가져오는 방법" href="/post/2024-06-23-FetchThumbnailorLogofromAnyURLinYourAndroidApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 앱에서 URL로 썸네일 또는 로고 가져오는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FetchThumbnailorLogofromAnyURLinYourAndroidApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 앱에서 URL로 썸네일 또는 로고 가져오는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 앱에서 URL로 썸네일 또는 로고 가져오는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비와 OpenSSL의 미스터리한 이야기" href="/post/2024-06-23-ThecuriouscaseofRubyandOpenSSL"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비와 OpenSSL의 미스터리한 이야기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ThecuriouscaseofRubyandOpenSSL_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비와 OpenSSL의 미스터리한 이야기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비와 OpenSSL의 미스터리한 이야기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리트코드 두 수 더하기 문제 해결 - 루비 솔루션 완벽 가이드" href="/post/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리트코드 두 수 더하기 문제 해결 - 루비 솔루션 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리트코드 두 수 더하기 문제 해결 - 루비 솔루션 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">리트코드 두 수 더하기 문제 해결 - 루비 솔루션 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Rails 7에서 Sidekiq Gem을 사용한 백그라운드 작업 처리 Part-I" href="/post/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Rails 7에서 Sidekiq Gem을 사용한 백그라운드 작업 처리 Part-I" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Rails 7에서 Sidekiq Gem을 사용한 백그라운드 작업 처리 Part-I" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Rails 7에서 Sidekiq Gem을 사용한 백그라운드 작업 처리 Part-I</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="튜토리얼 Windows Ruby on Rails  SQLite 시작하는 방법" href="/post/2024-06-23-TUTORIALWindowsGetstartedwithRubyonRailsSQLite"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="튜토리얼 Windows Ruby on Rails  SQLite 시작하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TUTORIALWindowsGetstartedwithRubyonRailsSQLite_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="튜토리얼 Windows Ruby on Rails  SQLite 시작하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">튜토리얼 Windows Ruby on Rails  SQLite 시작하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link posts_-active__YVJEi" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"모든 안드로이드 개발자가 알아야 할 ObjectAnimator로 애니메이션 구현하는 방법","description":"","date":"2024-06-23 21:04","slug":"2024-06-23-EveryAndroiddevelopershouldknowaboutObjectAnimatortouseanimationsinyourApps","content":"\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 목적: 객체의 속성을 시간에 따라 애니메이션화합니다.\n- 상속: ValueAnimator로부터 상속받으며 그 기능을 확장하여 속성을 직접 애니메이션화합니다.\n\n2. 속성 애니메이션 vs. 뷰 애니메이션:\n\n- 속성 애니메이션: 뷰 속성뿐만 아니라 모든 객체의 속성을 애니메이션화합니다.\n- 뷰 애니메이션: 위치, 크기, 회전 등과 같은 특정 뷰 속성에 대해 제한됩니다.\n\n# 기본 사용법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ObjectAnimator를 만드는 방법:\n- 방법: 정적 메서드를 사용하여 인스턴스를 생성합니다.\n- 예시:\n\n```js\nObjectAnimator animator = ObjectAnimator.ofFloat(targetView, \"translationX\", 0f, 100f);\nanimator.setDuration(1000);  // 1초\nanimator.start();\n```\n\n2. 애니메이트할 공통 속성:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- alpha: 화면을 서서히 사라지게 합니다.\n- translationX, translationY: 화면을 X 또는 Y 축을 따라 이동시킵니다.\n- rotation, rotationX, rotationY: 피벗 지점을 중심으로 화면을 회전시킵니다.\n- scaleX, scaleY: X 또는 Y 방향으로 화면의 크기를 조절합니다.\n\n# 고급 사용법\n\n- AnimatorSet:\n\n- 목적: 여러 애니메이션을 함께 또는 순차적으로 실행합니다.\n- 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nObjectAnimator scaleX = ObjectAnimator.ofFloat(targetView, \"scaleX\", 1f, 1.5f);\nObjectAnimator scaleY = ObjectAnimator.ofFloat(targetView, \"scaleY\", 1f, 1.5f);\nAnimatorSet animatorSet = new AnimatorSet();\nanimatorSet.playTogether(scaleX, scaleY);\nanimatorSet.setDuration(1000);\nanimatorSet.start();\n```\n\n2. PropertyValuesHolder:\n\n- 목적: 하나의 애니메이터로 개체의 여러 속성을 동시에 애니메이션화합니다.\n- 예시:\n\n```js\nPropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"scaleX\", 1f, 1.5f);\nPropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"scaleY\", 1f, 1.5f);\nObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(targetView, pvhX, pvhY);\nanimator.setDuration(1000);\nanimator.start();\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. AnimatorListener:\n\n- 목적: 애니메이션 이벤트에 대응합니다.\n- 구현:\n\n```js\nPropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"scaleX\", 1f, 1.5f);\nPropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"scaleY\", 1f, 1.5f);\nObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(targetView, pvhX, pvhY);\nanimator.setDuration(1000);\nanimator.start();\n```\n\n4. Interpolator:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 목적: 애니메이션의 변화율을 제어합니다.\n- 일반적으로 사용되는 보간기: LinearInterpolator, AccelerateInterpolator, DecelerateInterpolator, BounceInterpolator.\n- 예시:\n\n```js\nanimator.setInterpolator(new BounceInterpolator());\n```\n\n5. 키프레임:\n\n- 목적: 애니메이션 타임라인에서 특정 지점을 정의합니다.\n- 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nKeyframe kf0 = Keyframe.ofFloat(0f, 0f);\nKeyframe kf1 = Keyframe.ofFloat(0.5f, 200f);\nKeyframe kf2 = Keyframe.ofFloat(1f, 0f);\nPropertyValuesHolder pvh = PropertyValuesHolder.ofKeyframe(\"translationX\", kf0, kf1, kf2);\nObjectAnimator animator = ObjectAnimator.ofPropertyValuesHolder(targetView, pvh);\nanimator.setDuration(2000);\nanimator.start();\n```\n\n## Pratical Examples\n\n- Fading a View:\n\n```js\nObjectAnimator fadeOut = ObjectAnimator.ofFloat(targetView, \"alpha\", 1f, 0f);\nfadeOut.setDuration(2000);\nfadeOut.start();\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 바운스 애니메이션:\n\n```js\nObjectAnimator bounceAnim = ObjectAnimator.ofFloat(targetView, \"translationY\", 0f, 300f);\nbounceAnim.setInterpolator(new BounceInterpolator());\nbounceAnim.setDuration(2000);\nbounceAnim.start();\n```\n\n3. 연속 애니메이션:\n\n```js\nObjectAnimator moveRight = ObjectAnimator.ofFloat(targetView, \"translationX\", 0f, 300f);\nObjectAnimator moveDown = ObjectAnimator.ofFloat(targetView, \"translationY\", 0f, 300f);\nAnimatorSet set = new AnimatorSet();\nset.playSequentially(moveRight, moveDown);\nset.setDuration(2000);\nset.start();\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 최선의 실첀법\n\n- 레이아웃 패스 최소화하기:\n\n- onDraw와 같이 자주 호출되는 메서드에서 애니메이션을 생성하거나 시작하는 것을 피하세요.\n\n2. 애니메이터를 재사용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가능한 경우 ObjectAnimator 인스턴스를 재사용하여 성능을 향상시킵니다.\n\n3. 하드웨어 가속화:\n\n- 애니메이션을 부드럽게 실행하기 위해 하드웨어 가속화를 활용하세요.\n\n4. 테스트:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 서로 다른 기기와 화면 크기에서 애니메이션을 테스트하여 일관된 동작을 보장하세요.\n\n5. 사용자 정의 속성:\n\n- PropertyValuesHolder 및 사용자 정의 속성 세터/게터를 사용하여 일반적이지 않은 속성을 애니메이션화하세요.\n\nObjectAnimator를 이해하고 효과적으로 활용함으로써 Android 애플리케이션의 사용자 경험을 향상시키는 매혹적이고 순조로운 애니메이션을 만들 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-EveryAndroiddevelopershouldknowaboutObjectAnimatortouseanimationsinyourApps_0.png"},"coverImage":"/assets/img/2024-06-23-EveryAndroiddevelopershouldknowaboutObjectAnimatortouseanimationsinyourApps_0.png","tag":["Tech"],"readingTime":7},{"title":"코틀린 채널 완벽 정복 초보부터 프로까지 - 1부","description":"","date":"2024-06-23 21:02","slug":"2024-06-23-MasteringKotlinChannelsFromBeginnertoPro-Part1","content":"\n![그림](/assets/img/2024-06-23-MasteringKotlinChannelsFromBeginnertoPro-Part1_0.png)\n\n코틀린 채널은 두 개 이상의 코루틴 간 통신을 가능하게 하는 강력한 동시성 구조입니다. 애플리케이션의 다른 부분 간에 협력하는 방법을 제공하여 서로 간섭하지 않고 데이터를 공유하고 함께 작업할 수 있습니다. 이 시리즈의 게시물에서는 코틀린 채널을 더 깊이 파고들어 이 강력한 도구를 습득하는 방법과 팁, 트릭, 그리고 최고의 실천 방법에 대해 살펴보겠습니다.\n\n# Kotlin 채널이란?\n\n코틀린 채널은 한 코루틴에서 다른 코루틴으로 데이터가 흐를 수 있는 파이프 라인으로 생각할 수 있습니다. 채널은 사실 코루틴이 메시지를 보내고 받을 수 있는 버퍼나 큐입니다. 한 코루틴은 채널에 데이터를 넣을 수 있고(send) 다른 코루틴은 그 데이터를 채널에서 가져올 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n채널은 코루틴을 위해 특히 구축된 Producer-Consumer 패턴의 구현입니다. 정보를 보내는 코루틴을 생산자(producer)라고 하고, 정보를 받는 코루틴을 소비자(consumer)라고 합니다. 하나 이상의 코루틴이 동일한 채널로 정보를 보낼 수 있고, 하나 이상의 코루틴이 데이터를 수신할 수 있습니다.\n\n여러 코루틴이 동일한 채널에서 정보를 받을 때, 각 엘리먼트는 소비자 중 하나에 의해 한 번만 처리됩니다. 한 번 처리된 요소는 즉시 채널에서 제거됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코틀린 채널 사용 예제입니다:\n\n```js\nfun channel(\n    coroutineScope: CoroutineScope,\n) {\n    val channel = Channel\u003cString\u003e() // 채널은 String 형식의 데이터를 교환합니다\n\n    // 프로듀서가 코루틴 내에서 데이터를 전송하기 시작합니다\n    coroutineScope.launch {\n        Log.d(\"Channel\", \"채널에 데이터 1 전송\")\n        channel.send(\"데이터 1\")\n        Log.d(\"Channel\",\"채널에 데이터 2 전송\")\n        channel.send(\"데이터 2\")\n        channel.close() // 데이터 전송이 완료되었으므로 채널을 닫습니다\n    }\n\n    // 컨슈머가 다른 코루틴 내에서 데이터를 수신하기 시작합니다\n    coroutineScope.launch {\n        channel.consumeEach {\n            Log.d(\"Channel\",\"받은 데이터: $it\")\n        }\n        Log.d(\"Channel\",\"완료!\") // 채널이 닫힌 후에 호출됩니다\n    }\n}\n```\n\n이 예제에서는 두 개의 코루틴을 시작합니다. 첫 번째 코루틴은 channel.send() 함수를 사용하여 채널에 데이터 문자열을 전송합니다. 두 번째 코루틴은 channel.consumeEach() 함수를 사용하여 채널에서 데이터를 소비하는데, 이 함수는 채널에 전송된 모든 값들을 반복하는 편리한 방법입니다. 데이터를 전송한 후, 코루틴은 channel.close() 함수를 사용하여 채널을 닫습니다.\n\n코틀린 채널의 close() 함수는 데이터 전송의 끝을 신호하는 데 사용됩니다. 개념적으로, 이는 채널을 닫는 것을 나타내는 특별한 토큰을 전송하는 것과 같습니다. 코루틴이 이 토큰을 수신하면 더 이상 데이터가 채널로 전송되지 않을 것임을 알 수 있습니다. 코루틴은 이 시점에서 반복을 중지하여 채널이 닫히기 전에 이전에 전송된 모든 요소를 수신하도록 보장합니다. 이를 통해 통신 세션의 종료를 처리하기가 더 쉬워지며, 코루틴이 종료되기 전에 모든 데이터가 처리되도록 보장됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드의 출력은 다음과 같습니다:\n\n```js\n채널로 데이터 1을 보냈습니다\n수신: 데이터 1\n채널로 데이터 2을 보냈습니다\n수신: 데이터 2\n완료!\n```\n\n# ReceiveChannel\n\nKotlin 코루틴에서 ReceiveChannel은 코루틴에서 데이터를 수신하는 방법을 제공하는 채널 유형입니다. 데이터를 송신자에게 다시 보낼 수 없이 채널에서 데이터를 소비하고 싶을 때 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소비자 코루틴에 ReceiveChannel을 사용함으로써 데이터를 받기만 하고 실수로 데이터를 전송하지 않도록 보장합니다. 이러한 관심사의 분리는 코드를 보다 유지 보수하기 쉽고 오류가 적은 상태로 유지하는 데 도움이 됩니다.\n\n아래는 ReceiveChannel을 사용하는 예시입니다.\n\n```js\n@OptIn(ExperimentalCoroutinesApi::class)\nfun receiveChannel(\n    coroutineScope: CoroutineScope\n) {\n    var channel: ReceiveChannel\u003cString\u003e = Channel()\n\n    // Producer Coroutine\n    coroutineScope.launch {\n        channel = produce {\n            send(\"A\")\n            send(\"B\")\n            send(\"C\")\n            send(\"D\")\n            // 채널을 명시적으로 닫아줄 필요가 없습니다\n        }\n    }\n\n    // Consumer Coroutine\n    coroutineScope.launch {\n        channel.consumeEach {\n            Log.d(TAG, \"Received $it\")\n        }\n        // 소비자 코루틴 내에서 데이터를 다시 채널로 보내는 것은 불가능합니다\n        // 왜냐하면 이것은 ReceiveChannel이기 때문입니다\n        // channel.send(\"E\")\n\n        // 채널은 자동으로 닫힙니다\n        Log.d(TAG, \"Is producer closed: ${channel.isClosedForReceive}\")\n    }\n}\n```\n\n위 코드에서 우리는 코루틴을 위한 ProducerScope를 만드는 편리한 방법인 produce 함수를 사용했습니다. produce 함수는 코루틴 내에서 데이터를 보낼 수 있게 해주며 새로운 코루틴에서 사용할 수 있는 ReceiveChannel을 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nchannel.send(\"E\") 라인은 주석 처리되어 있습니다. 이는 컴파일 오류를 발생시킬 것이기 때문입니다. channel은 ReceiveChannel이므로 send() 메서드가 없습니다. 이는 소비자 코루틴이 ReceiveChannel을 사용할 때 생산자로 데이터를 다시 보낼 수 없음을 보여줍니다.\n\nconsumeEach 블록이 완료되면 produce 함수에 의해 채널이 자동으로 닫힙니다. 마지막으로 channel.isClosedForReceive 속성을 확인하여 결과가 true이므로 채널이 닫혔음을 알 수 있습니다.\n\n위 코드의 출력은 다음과 같습니다:\n\nReceived A\nReceived B\nReceived C\nReceived D\nIs producer closed: true\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`Channel`과 `ReceiveChannel`의 차이\n\nKotlin 코루틴에서 `ReceiveChannel`과 일반 `Channel`의 주요 차이점은 `ReceiveChannel`은 채널에서 데이터를 소비하는 데만 사용될 수 있다는 것이며, 일반 `Channel`은 데이터를 보내고 받는 데 모두 사용될 수 있다는 것입니다.\n\n`Channel`을 생성하면 코루틴 간에 데이터를 보내고 받을 수 있는 채널에 대한 참조가 생성됩니다. `Channel` 클래스는 `send()`와 `receive()`와 같은 함수를 제공하여 채널에서 데이터를 보내고 받을 수 있습니다.\n\n반면에 `ReceiveChannel`을 생성하면 채널에서 데이터를 소비하는 데만 사용될 수 있는 채널에 대한 참조가 생성됩니다. `ReceiveChannel` 클래스는 `receive()` 및 `tryReceive()`와 같은 함수를 제공하여 채널에서 데이터를 받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다시 말해서, Regular Channel은 상호 작용 채널로 coroutine 간에 데이터를 송수신하는 데 사용할 수 있고, ReceiveChannel은 단방향 채널로 채널에서 데이터를 받는 데만 사용할 수 있습니다.\n\n# 파이프라인\n\n수신 채널을 사용하여 파이프라인을 구현할 수 있습니다. 파이프라인은 채널에 의해 연결된 여러 단계로 구성되며 입력 데이터를 출력 데이터로 변환하는 데 함께 작동합니다.\n\n파이프라인의 각 단계는 입력 채널에서 데이터를 소비하는 coroutine이며, 데이터에 대한 일부 계산을 수행한 후, 다음 단계에서 소비되는 출력 채널로 변환된 데이터를 전송합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이프라인 내 각 단계 사이의 입력 및 출력 채널은 각 단계가 데이터를 비동기적이고 독립적으로 처리할 수 있도록 하는 버퍼 역할을 합니다. 이를 통해 파이프라인은 대량의 데이터를 효율적으로 처리하고, 병렬로 계산을 다수의 코어나 스레드에 분산시킬 수 있습니다.\n\n파이프라인은 각 단계가 데이터에 대해 특정 연산을 수행하는 상황에서 유용합니다. 예를 들어, 센서로부터의 데이터 스트림을 처리해야 하는 경우, 각 단계가 데이터에 대해 필터링, 평활화, 또는 평균 등의 특정 변환을 수행하는 파이프라인을 활용할 수 있습니다.\n\n파이프라인 예시 1:\n\n다음은 정수 스트림을 처리하는 파이프라인 예시입니다. 이 파이프라인은 짝수를 걸러내고 남은 홀수를 제곱하여 총합을 구합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfun streamingNumbers(scope: CoroutineScope) {\n    scope.launch {\n        val numbers = produceNumbers(10)\n        val result = pipeline(numbers)\n\n        Log.d(TAG, result.receive().toString())\n    }\n}\n\n// 숫자를 생성하여 파이프라인으로 보내는 함수\nfun CoroutineScope.produceNumbers(count: Int): ReceiveChannel\u003cInt\u003e = produce {\n    for (i in 1..count) send(i)\n}\n\n// 숫자를 처리하는 파이프라인\nfun CoroutineScope.pipeline(\n    numbers: ReceiveChannel\u003cInt\u003e\n): ReceiveChannel\u003cInt\u003e = produce {\n    // 짝수를 걸러냄\n    val filtered = filter(numbers) { it % 2 != 0 }\n\n    // 남은 홀수를 제곱함\n    val squared = map(filtered) { it * it }\n\n    // 제곱한 홀수들을 합침\n    val sum = reduce(squared) { acc, x -\u003e acc + x }\n\n    send(sum)\n}\n\nfun CoroutineScope.filter(\n    numbers: ReceiveChannel\u003cInt\u003e,\n    predicate: (Int) -\u003e Boolean\n): ReceiveChannel\u003cInt\u003e = produce {\n    numbers.consumeEach { number -\u003e\n        if (predicate(number)) send(number)\n    }\n}\n\nfun CoroutineScope.map(\n    numbers: ReceiveChannel\u003cInt\u003e,\n    mapper: (Int) -\u003e Int\n): ReceiveChannel\u003cInt\u003e = produce {\n    numbers.consumeEach { number -\u003e\n        send(mapper(number))\n    }\n}\n\nfun reduce(\n    numbers: ReceiveChannel\u003cInt\u003e,\n    accumulator: (Int, Int) -\u003e Int\n): Int = runBlocking {\n    var result = 0\n    for (number in numbers) {\n        result = accumulator(result, number)\n    }\n    result\n}\n```\n\n이 예제에서 pipeline 함수는 filter, map 및 reduce 세 단계를 연결하여 새로운 파이프라인을 생성합니다. filter 단계는 짝수를 걸러내고, map 단계는 남은 홀수를 제곱하며, reduce 단계는 제곱된 홀수 값을 합산합니다.\n\n각 단계는 입력 채널에서 데이터를 소비하고 filter, map 및 reduce 함수를 사용하여 출력 채널로 데이터를 생성하는 별개의 코루틴으로 구현됩니다. 파이프라인 함수는 파이프라인의 출력 채널을 나타내는 새로운 ReceiveChannel을 반환합니다.\n\n파이프라인 예제 2 — 이미지 처리:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 스트림을 처리하는 파이프라인 예제를 보여드리겠습니다. 이미지를 리사이징, 압축하고 저장하는 과정을 거칩니다:\n\n```js\nfun processImages(\n    coroutineScope: CoroutineScope\n) {\n    coroutineScope.launch {\n        val images = produceImages(listOf(\n            \"https://via.placeholder.com/300x300.png\",\n            \"https://via.placeholder.com/500x500.png\",\n            \"https://via.placeholder.com/800x800.png\"\n        ))\n        val resized = resizeImages(images, 400)\n        val compressed = compressImages(resized, 80)\n        storeImages(compressed, Paths.get(\"output/\"))\n    }\n}\n\nfun CoroutineScope.produceImages(urls: List\u003cString\u003e): ReceiveChannel\u003cByteArray\u003e = produce {\n    for (url in urls) {\n        val bytes = URL(url).readBytes()\n        send(bytes)\n    }\n}\n\nfun CoroutineScope.resizeImages(\n    images: ReceiveChannel\u003cByteArray\u003e, size: Int\n): ReceiveChannel\u003cByteArray\u003e = produce {\n    images.consumeEach { image -\u003e\n        // ImageResizer can a util class to resize the image\n        val resizedImage = ImageResizer.resize(image, size)\n        send(resizedImage)\n    }\n}\n\nfun CoroutineScope.compressImages(\n    images: ReceiveChannel\u003cByteArray\u003e, quality: Int\n): ReceiveChannel\u003cByteArray\u003e = produce {\n    images.consumeEach { image -\u003e\n        // ImageCompressor can a util class to compress the image\n        val compressedImage = ImageCompressor.compress(image, quality)\n        send(compressedImage)\n    }\n}\n\nsuspend fun storeImages(images: ReceiveChannel\u003cByteArray\u003e, directory: Path) {\n    Files.createDirectories(directory)\n    var index = 1\n    for (image in images) {\n        val file = directory.resolve(\"image${index++}.jpg\")\n        FileOutputStream(file.toFile()).use { output -\u003e\n            output.write(image)\n        }\n    }\n}\n```\n\n이 예제에서 processImages 함수는 produceImages 함수를 사용하여 URL 목록에서 이미지 데이터의 스트림을 생성하는 ReceiveChannel을 생성합니다. 그런 다음 이 채널을 resizeImages 함수에 전달하여 이미지를 지정된 크기로 조정한 후 compressImages 함수에 출력 채널을 전달하여 이미지를 지정된 품질로 압축합니다. 마지막으로 compressImages 함수의 출력 채널을 디스크에 압축된 이미지를 저장하는 storeImages 함수에 전달합니다.\n\n파이프라인의 각 단계는 입력 채널에서 데이터를 소비하고 resizeImages, compressImages 및 storeImages 함수를 사용하여 출력 채널에 데이터를 생성하는 별도의 코루틴으로 구현되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nresizeImages 및 compressImages 함수에서 사용되는 ImageResizer 및 ImageCompressor 클래스는 이미지 데이터에 대해 이러한 작업을 수행할 수있는 가상 클래스 예시입니다.\n\n이 파이프라인은 이미지를 크기 조정, 압축 및 저장하는 편리하고 효율적인 방법을 제공합니다. 이 파이프라인은 추가 단계를 포함하거나 다양한 종류의 이미지 처리 작업을 처리하는 데 쉽게 확장할 수 있습니다.\n\n# 다음은 무엇인가요?\n\n이 시리즈의 다음 부분에서는 Kotlin 채널의 세계에 더욱 심층적으로 파고들어 다양한 유형의 채널과 실제 응용 프로그램을 탐구할 것입니다. 제2편을 마치면 Kotlin 채널을 사용하여 효율적이고 확장 가능한 동시성 응용 프로그램을 구축하는 방법을 포괄적으로 이해하게 될 것입니다. 기대해 주세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 부분은 여기서 찾을 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-MasteringKotlinChannelsFromBeginnertoPro-Part1_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringKotlinChannelsFromBeginnertoPro-Part1_0.png","tag":["Tech"],"readingTime":13},{"title":"Jetpack Compose의 공식 Pager 컴포저블 탐구하기","description":"","date":"2024-06-23 21:00","slug":"2024-06-23-ExploringtheOfficialPagerComposableinJetpackCompose","content":"\n1.4 버전이 출시되면서 Jetpack Compose가 공식적으로 페이징 레이아웃을 지원하게 되었습니다. 뷰 기반 시스템에서는 ViewPager 위젯 형태로 오랫동안 사용되어 왔지만, 개발자들은 Compose에서 유사한 효과를 얻기 위해 Accompanist 라이브러리 구현을 사용해야 했습니다.\n\n새로운 컴포저블 두 개가 추가되었습니다. HorizontalPager와 VerticalPager. 사용법과 동작을 좀 더 자세히 살펴봅시다.\n\n## HorizontalPager\n\nHorizontalPager는 사용자 또는 프로그래밍 방식으로 좌우로 수평 스크롤할 수 있는 컴포저블입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:800/1*AP2jKexaHqpaCoDt9zPh3Q.gif)\n\n## VerticalPager\n\nVerticalPager는 사용자 또는 프로그래밍적으로 수직으로 위아래로 스크롤할 수 있게 하는 조합성이다.\n\n![image](https://miro.medium.com/v2/resize:fit:800/1*CMRnteybuokM-9AkJUqxRA.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 더 자세히 살펴보기\n\n페이지/아이템은 필요할 때만 게으르게 구성되어 배치됩니다. 이는 LazyColumn 및 LazyRow 컴포저블과 유사합니다. 위 모든 컴포저블은 내부적으로 LazyList 컴포저블을 사용합니다.\n\n페이저 컴포저블 모두 내부 Pager 컴포저블을 다른 값으로 orientation 인자에 전달하는 래퍼입니다.\n\npageCount를 제외한 모든 인자는 선택적입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- pageCount: 페이저에서 표시할 총 페이지/아이템 수입니다.\n- pageSize: 페이저 내의 페이지 크기를 정의합니다.\n- pageSpacing: 페이저 내 두 페이지 사이의 간격을 정의합니다.\n- contentPadding: 페이저 내에서 페이지가 정렬되는 방식을 지정합니다.\n- beyondBoundsPageCount: 현재 보이는 페이지 이상으로 로드할 페이지 수를 지정합니다.\n- state: 페이저를 제어하고 현재 선택된 페이지와 같은 다양한 속성을 관찰하는 PagerState 객체입니다.\n- flingBehavior: 스크롤 제스처의 동작 방식을 정의합니다.\n- reverseLayout: 레이아웃과 스크롤 방향을 반전시킵니다. 첫 번째 페이지가 마지막 페이지로 표시되고 페이저의 끝이 아닌 시작 쪽으로 스크롤해야 합니다.\n- key: 항목을 나타내는 안정적이고 유일한 키입니다. 이를 사용하여 항목을 추가하거나 제거할 때에도 스크롤 위치를 유지할 수 있습니다.\n\n이러한 인수에 다른 값을 전달하는 방법이 페이저의 동작에 어떻게 영향을 주는지 자세히 알아보겠습니다.\n\n## 페이지 크기\n\npageSize: PageSize 인수를 사용하여 페이지 크기를 제어할 수 있습니다. 기본적으로 이 값은 PageSize.Fill로 설정되어 있어 HorizontalPager의 경우 전체 너비 또는 VerticalPager의 경우 전체 높이를 차지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:800/1*XeEa09R4_NnVH-yk0RA9AA.gif)\n\n페이지 크기를 고정 크기로 정의하려면 PageSize.Fixed(dp)를 사용할 수 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:800/1*dpCJNBPMMZLEzQ2zD6267g.gif)\n\n가끔은 사용자 정의 계산에 따라 크기를 정의해야 할 때가 있습니다. 이를 위해 PageSize 인터페이스를 확장하고 calculateMainAxisPageSize(availableSpace: Int, pageSpacing: Int) 함수를 구현할 수 있습니다. 아래 예제에서는 사용 가능한 너비의 80%를 차지하는 HorizontalPager가 있고, 페이지 크기를 사용 가능한 너비의 50%로 설정합니다. 이렇게 하면 한 번에 두 페이지를 볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](https://miro.medium.com/v2/resize:fit:800/1*BS5XgH4dP9-4Il5SFaxqVA.gif)\n\n## 페이지 간격\n\npageSpacing: Dp 인수를 사용하여 페이지 사이에 사용할 공간의 양을 정의할 수 있습니다. 이전에 pageSize를 PageSize.Fixed(dp)로 정의하고 간격으로 8.dp를 사용하는 예제를 사용하면 다음과 같은 결과를 얻을 수 있습니다:\n\n![Image](https://miro.medium.com/v2/resize:fit:800/1*3aTc7YErEY0MKqgnbY0ijg.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](https://miro.medium.com/v2/resize:fit:800/1*hwZ22hqTVXFfILxsNzDM_w.gif)\n\n## 내용 패딩\n\ncontentPadding: PaddingValues 인수를 사용하면 페이저 안의 페이지 위치를 제어할 수 있습니다.\n\n여기서 start 및 end 속성에 동일한 패딩을 설정하여 페이지를 페이저 중앙에 배치합니다. 또한 HorizontalPager의 경우 상단 및 하단에 동일한 수직 패딩을 적용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:800/1*MMgcNXPLncPODVgMQjgfpg.gif)\n\nWhen you apply the start padding alone, the pages are shifted towards the end, causing a portion of the previous page to be visible.\n\n![image](https://miro.medium.com/v2/resize:fit:800/1*nhxpvTwxRxvaItT9kFvMWw.gif)\n\nWhen you apply the end padding alone, the pages are shifted towards the start, causing a portion of the next page to be visible.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:800/1*LiD4FxaDr2XQLp8nvItQRA.gif)\n\n수직 페이저에도 동일한 원칙이 적용되지만, top, bottom 및 vertical padding 속성은 페이지의 정렬을 제어합니다. top padding을 적용하면 페이지가 아래쪽으로 이동됩니다. 그리고 bottom padding을 적용하면 페이지가 위쪽으로 이동됩니다.\n\n한편 start, end 및 horizontal은 일반적인 padding만 적용됩니다.\n\n![image](/assets/img/2024-06-23-ExploringtheOfficialPagerComposableinJetpackCompose_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## BeyondBoundsPageCount\n\n이 인수는 현재 표시된 페이지 주변에 심지어 보이지 않을 때도로드해야 하는 페이지/항목 수를 지정합니다. 기본값은 0으로 설정됩니다.\n\n항목의 높이를 감싸고 각 항목에 맞게 크기를 조정하는 페이저를 원한다면, HorizontalPager에 beyondBoundsPageCount = 0으로 Modifier.wrapContentHeight()를 사용할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*NDlSiw0m8Ts87Rgxu_yFNA.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 페이저가 가장 높은 항목의 높이에 맞춰져야 하는 경우 beyondBoundsPageCount = pageCount로 지정할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*a-4Jh2cpNCzfzKxg6J4RMw.gif)\n\n큰 값을 설정하는 경우 성능이 저하될 수 있다는 문서를 참고하세요:\n\n## 페이지 상태 변경 관찰\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔 페이지 변경에 반응하고 싶을 때가 있습니다. 분석 이벤트를 보내거나 어떤 로직을 발동하거나 다른 화면으로 이동하고 싶은 경우가 있습니다. 이를 위해 LaunchedEffect 내에서 PagerState 객체의 네 가지 속성을 snapshotFlowOf를 사용하여 관찰할 수 있습니다:\n\n- currentPage: 현재 선택된 페이지 또는 스냅 위치에 가장 인접한 페이지입니다.\n- targetPage: 스크롤 이동 결과로 선택해야 하는 페이지입니다.\n- settledPage: currentPage와 유사하지만 애니메이션이 완료될 때까지 변경되지 않습니다.\n- currentPageOffsetFraction: 현재 페이지가 스냅 위치에서 얼마나 벗어났는지를 나타내는 범위입니다. -0.5에서 0.5까지의 값으로, 페이저의 시작 쪽으로 스크롤하는 경우에는 음수가 사용되고, 끝 쪽으로 스크롤하는 경우에는 양수가 사용됩니다. 0.0은 현재 페이지가 완전히 스냅된 상태를 나타냅니다.\n\n## 페이지 인디케이터 만들기\n\n페이저와 함께 보통 페이지 인디케이터를 표시하여 현재 어떤 페이지를 보고 있는지와 전체 페이지 수를 표시하고 싶어합니다. 공식 페이지 인디케이터 컴포저블은 없지만, 상당히 간단히 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*VCFpbnnn1juWCifnTFF3Pg.gif)\n\n가로 표시기를 적용하는 데 필요한 것은 개별 페이지 표시기를 배치하려면 행(수평 표시기) 또는 열(수직 표시기)을 사용하고, 디자인 요구사항에 따라 표시기를 렌더링하기 위해 상자 또는 아이콘 또는 이미지를 사용할 수 있습니다.\n\n현재 페이지(pagerState.currentPage: Int), 선택될 페이지(pagerState.targetPage: Int)를 나타내는 타깃 페이지 및 스크롤 오프셋(pagerState.currentPageOffsetFraction: Float)을 얻기 위해 PagerState 객체를 사용할 수 있습니다. 이를 통해 선택을 계산하고 애니메이션을 적용할 수 있습니다.\n\n현재 스크롤 오프셋에 따라 현재 선택된 페이지 표시기의 크기와 색상을 애니메이션하는 수평 페이저 표시기 예시를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 특정 페이지로 스크롤하기\n\nPager에서 특정 페이지로 프로그래밍적으로 스크롤할 수 있습니다. PagerState 객체를 작성하여 pager에 전달한 다음에 pagerState.scrollToPage(page: Int) 또는 pagerState.animateScrollToPage(page: Int)을 CoroutineScope 내에서 호출하면 됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*va9VoqeZ146bUcx_j4-Q5A.gif)\n\n## 탭과 함께 Pager 사용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자주 탭을 사용하는데 페이저와 함께 사용해야 할 때가 있습니다. 선택된 탭을 표시하고 스크롤하거나 특정 탭을 클릭하여 선택할 수 있도록 합니다. 이를 위해 TabRow 컴포저블과 HorizontalPager를 함께 사용하여 이를 구현할 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*PR4b0VlQgMfMYuEN08lOyQ.gif)\n\nTabRow 컴포저블을 생성하고 pagerState.currentPage를 selectedTabIndex 인수로 전달해야 합니다. 이렇게 하면 페이저를 스크롤할 때 선택된 탭이 업데이트됩니다. 이 예제에서는 기본 탭 표시기 TabRowDefaults.Indicator를 사용하고 Modifier.tabIndicatorOffset 수정자를 적용하여 기본 선택된 탭 표시기를 그리고 애니메이션화합니다.\n\n이렇게 설정하면 페이저를 스크롤하면 탭이 선택됩니다. 탭을 클릭하여 페이지를 선택하는 기능도 지원하려면 coroutine 스코프 내에서 pagerState.animateScrollToPage(selectedTabIndex) 함수를 호출해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 스크롤 동작 사용자 정의\n\n우리는 페이저의 기본 스크롤 동작을 변경할 수 있습니다. 이를 위해 페이저에 사용자 정의 fling 동작인 SnapFlingBehavior를 제공해야 합니다. 또한 PagerState 객체를 생성해야 합니다.\n\npagerSnapDistance를 사용하여 플링 제스처가 얼마나 많은 페이지를 스크롤할 수 있는지 정의할 수 있습니다. 기본적으로 이 값은 한 페이지로 설정되어 있지만, PagerSnapDistance.atMost(pages: Int)를 사용하여 이를 무시하고 다른 값을 설정할 수 있습니다. 다음은 스냅을 2페이지로 설정하는 예시입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*J3ipnv3bHlSPmzUNZsbDfA.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nlowVelocityAnimationSpec은 스크롤이나 천천히 움직일 때 사용되는 애니메이션을 정의합니다. 예제에서는 이를 5초로 설정하여, 천천히 움직인 후 다음 페이지를 선택하는 애니메이션이 5초 동안 진행됩니다.\n\nhighVelocityAnimationSpec은 스크롤이나 아주 빨리 움직일 때 사용되는 애니메이션을 정의합니다.\n\nsnapAnimationSpec은 최종적으로 포지션에 스냅되는데 사용되는 애니메이션을 정의합니다. 다음 페이지가 선택될만큼 충분히 스크롤하거나 현재 페이지를 선택한 채로 약간만 스크롤하는 경우를 말합니다. 예제에서는 이를 1초로 설정했습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:800/1*UzWgACMOPRWIqSihQhrm5Q.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 반주자 페이저 이전\n\n파트너 버전의 페이저가 이제는 사용이 중단되었습니다. Google은 기존의 com.google.accompanist.pager.HorizontalPager에서 androidx.compose.foundation.pager.HorizontalPager로 및 com.google.accompanist.pager.VerticalPager에서 androidx.compose.foundation.pager.VerticalPager로 코드베이스를 이전하는 가이드를 제공했습니다.\n\n마이그레이션을 수행하는 방법에 대한 자세한 정보는 https://google.github.io/accompanist/pager/에서 확인하세요.\n\n## 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJetpack Compose의 최신 버전이 릴리스되었습니다. 이 버전에는 사용하기 쉽고 사용자 정의할 수 있는 새로운 공식 Pager composable이 포함되어 있습니다.\n\n우리는 이 새로운 composable의 다양한 속성을 살펴보고 pager의 동작에 어떤 영향을 미치는지 배웠습니다. 그런 다음, 자체 페이지 표시자를 만드는 방법과 탭과 함께 pager를 사용하는 방법을 배웠습니다.\n\n이를 통해, 추가 라이브러리가 필요 없으며, 개발자가 빠르게 pager를 필요로 하는 디자인을 구현할 수 있도록 해야 합니다.\n\n## 참고:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 공식 문서: https://developer.android.com/jetpack/compose/layouts/pager\n- Accompanist pager 라이브러리: https://google.github.io/accompanist/pager/\n","ogImage":{"url":"/assets/img/2024-06-23-ExploringtheOfficialPagerComposableinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-23-ExploringtheOfficialPagerComposableinJetpackCompose_0.png","tag":["Tech"],"readingTime":13},{"title":"GSoC 2024 두 번째 주  FHIR 안드로이드 애플리케이션에 위치 통합하기","description":"","date":"2024-06-23 20:58","slug":"2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication","content":"\n안녕하세요 여러분! 👋\n\n모두가 행복한 한 주를 보내고 계시기를 바랍니다! 🌈 이번주는 저희 어플리케이션에 위치 기능을 통합하는 작업을 진행하면서 모험 가득한 한 주였어요. 이제 사용자들은 지정된 위치를 동기화하고 특정 위치를 선택하며 선택한 위치에 환자를 등록할 수 있어요. 자세한 내용을 알아보도록 하겠습니다! 🚀\n\n\u003cimg src=\"/assets/img/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication_0.png\" /\u003e\n\n# 🌍 안드로이드 FHIR 어플리케이션에 위치 동기화하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 안드로이드 FHIR SDK의 엔진 라이브러리를 사용하여 FHIR 리소스를 로컬에 저장하고 서버와 동기화하고 있어요. OpenMRS는 위치 데이터를 FHIR 리소스로 저장하며, Download Work Manager의 구현에 URL 경로를 추가하기만 하면 됐어요.\n\n🔗 OpenMRS 위치 URL: Location?\\_summary=data\u0026\\_tag=Login+Location\n\n나중에 한 번의 커밋에서 위치 URL을 첫 번째 인덱스로 이동했어요. 이 변경으로 위치가 먼저 로드되어 사용자가 환자 및 만남 데이터가 동기화되는 동안 선택할 수 있도록 되었어요. 효율성이 승리했네요! 🏆 이 변경 사항은 여기 커밋에서 확인할 수 있어요.\n\n# 📱 위치 선택 화면 만들기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 홈 화면에서 선택 위치 화면으로 이동할 수 있는 옵션을 추가했어요. 🏠\n\n![이미지](/assets/img/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication_1.png)\n\n선택 위치 화면은 현재 위치 세부 정보를 CardView에 보여주며, 드롭다운 메뉴를 통해 위치를 선택할 수 있도록 멋진 디자인으로 구성되어 있어요. 위치를 선택하면 현재 위치 세부 정보가 업데이트됩니다.\n\n이 세부 사항들은 앱 전체에서 쉽게 액세스하기 위해 데이터 저장소 환경 설정에 저장돼요. Location.id와 Location.name 두 가지가 모두 필요에 맞게 저장돼요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n처음에는 간단한 드롭다운을 계획했었지만, 멋진 멘토들의 통찰력 덕분에 사용자들이 수백 개의 위치를 가질 수 있다는 것을 깨달았어요. 그래서 최대한 편리하도록 드롭다운을 필터링 가능하게 만들었어요! 🛠️\n\n📝 이 변경 사항을 위한 커밋:\n\n- LocationViewModel 생성\n- 위치 POC의 초기 통합.\n\n# 🧭 앱 전반에 걸쳐 현재 위치 정보 통합하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 멘토들의 소중한 안내 덕분에, 환자 등록 화면의 사이드 패널과 맨 위에 위치 정보를 추가했어요. 이 정보를 여러 곳에서 확인할 수 있으니 사용자들에게 정말 편리하고 저장된 데이터를 재확인할 수 있게 도와줘요. 🔍\n\n이제 사용자가 위치를 선택하기 전까지는 환자를 추가하는 네비게이션이 차단되어요. 또한 등록된 환자의 FHIR 환자 자원에는 사용자가 선택한 위치 자원이 포함될 거예요. 🎯\n\n📝 이 변경 사항에 대한 커밋 내역:\n\n- 등록된 새 환자를 차단하는 로직을 통합함\n- 위치 화면에 현재 위치를 추가함\n- (기능) 환자 추가 화면에 현재 위치 추가함\n- (기능) 첫 설정: 환자 자원 저장 시 현재 위치를 추가함\n- (기능) 첫 설정: 사이드 패널에 현재 위치 추가함.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 🔮 다음 주 계획\n\n다음 주 일정은 다음과 같습니다:\n\n- 🧪 서버와 동기화하여 위치 데이터 저장 로직을 구현하고 유효성을 검사합니다.\n- ✨ MVP 1의 구현을 정리하고 MVP 2의 구현을 시작합니다.\n\n함께 해 주셔서 정말 감사합니다! 여러분의 지원은 저에게 큰 힘이 됩니다. 더 많은 업데이트를 기대해 주세요. 코딩을 즐기세요! 🎉👩‍💻👨‍💻 Frederic Deniger, Jose Francisco, Pedro Sousa, ICRC 팀 및 OpenMRS 팀께 소중한 지도를 해 준 데에 박수를 보냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n읽어 주셔서 감사합니다! 언제든지 건강 관련, 풀 스택 개발, FHIR, OpenMRS 안드로이드, Open Health Stack, 노래 추천 등과 관련된 모든 것에 대해 저에게 연락하실 수 있습니다! 🎵\n\nLinkedIn이나 OpenMRS Talk에서 저를 찾아보고 GitHub에서 제 프로젝트를 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication_0.png"},"coverImage":"/assets/img/2024-06-23-GSoC2024Week2IntegratingLocationstoFHIRAndroidApplication_0.png","tag":["Tech"],"readingTime":4},{"title":"안드로이드 유닛 테스트 101 초보자를 위한 가이드","description":"","date":"2024-06-23 20:57","slug":"2024-06-23-UnitTestingforAndroidABeginnersGuide","content":"\n유닛 테스트는 소프트웨어 개발의 중요한 단계입니다. 이것은 Test Driven Development (TDD)라고 불리는 개발 패러다임을 가져옵니다. 이러한 테스트는 일반적으로 애플리케이션의 비즈니스 로직을 테스트합니다.\n\n# 왜 우리는 유닛 테스트를 작성할까요?\n\n- 우리는 실수를 할 수 있습니다.\n- 우리의 코드가 작동되기를 원합니다.\n- 더 빠르게 개발하고 더 많은 확신과 더 적은 회귀를 가지기를 원합니다.\n\n안드로이드 및 일반적으로 다양한 모바일 플랫폼에서 앱 테스트는 어려울 수 있습니다. 유닛 테스트를 구현하고 테스트 주도 개발(TDD)의 원칙을 따르는 것은 종종 직관에 어긋날 수 있습니다. 그럼에도 불구하고 테스트는 중요하며 당연하게 여기거나 무시해서는 안 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번 유닛 테스트의 기본 사항으로 이동해 보죠. 안드로이드에서 유당 테스트라고 하면 떠오르는 몇 가지 기본 사항부터 시작해보겠습니다.\n\n# 패키지 구조\n\n새로운 안드로이드 프로젝트를 생성하면 기본적으로 다음 세 가지 소스 세트를 얻게 됩니다. 이들은 다음과 같습니다:\n\n![Unit Testing for Android - A Beginner's Guide](/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- main: 앱 코드가 포함되어 있습니다.\n- androidTest: 인스트루먼티드 테스트로 알려진 테스트가 포함되어 있습니다.\n- test: 로컬 테스트로 알려진 테스트가 포함되어 있습니다.\n\n로컬 테스트와 인스트루먼티드 테스트의 차이점은 실행되는 방식에 있습니다.\n\n# 로컬 테스트 (test 소스 세트)\n\n이러한 테스트는 개발 컴퓨터의 JVM에서 로컬로 실행되며 에뮬레이터나 물리적 장치가 필요하지 않습니다. 이로 인해 실행 속도가 빠르지만, 신뢰성은 낮아 실제와 다르게 동작할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Instrumented tests (androidTest source set)\n\n이러한 테스트는 실제 또는 에뮬레이션된 Android 장치에서 실행되므로 실제 세계에서 발생할 사항을 반영하지만 훨씬 느립니다.\n\n# Test runner\n\n테스트 실행기는 테스트를 실행하는 JUnit 구성 요소입니다. 테스트 실행기가 없으면 테스트가 실행되지 않습니다. JUnit에서는 자동으로 제공되는 기본 테스트 실행기가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nAndroid Studio를 사용하면 클래스를 테스트하는 테스트를 생성할 수 있는 도구를 제공합니다. 테스트할 클래스를 마우스 오른쪽 버튼으로 클릭하고 Generate ` Test를 선택하세요.\n\n\u003cimg src=\"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_1.png\" /\u003e\n\nTest를 클릭한 후에는 Test 클래스를 생성할 수 있습니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_2.png)\n\n테스트 클래스에서 사용하는 몇 가지 주석을 살펴봅시다.\n\n- @Test: 이 주석은 메서드를 테스트 케이스로 표시하는 데 사용됩니다. @Test 주석은 Java 컴파일러에게 클래스를 컴파일할 때 메서드를 테스트 케이스로 실행하도록 알려줍니다.\n- @Before: 이 주석은 메서드를 설정 메서드로 표시하는 데 사용됩니다. @Before 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 전에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행되기 전에 테스트 환경을 설정하는 데 유용합니다.\n- @After: 이 주석은 메서드를 소멸 메서드로 표시하는 데 사용됩니다. @After 주석은 Java 컴파일러에게 클래스의 각 테스트 케이스 후에 메서드를 실행하도록 알려줍니다. 각 테스트 케이스가 실행된 후 테스트 환경을 정리하는 데 유용합니다.\n- @Ignore: 이 주석은 메서드를 무시된 테스트 케이스로 표시하는 데 사용됩니다. @Ignore 주석은 Java 컴파일러에게 메서드를 테스트 케이스로 실행하지 말도록 알려줍니다. 아직 실행할 준비가 안 된 테스트 케이스를 일시적으로 무시하는 데 유용합니다.\n\n단언문은 테스트의 핵심입니다. 코드 문장으로, 코드나 앱이 예상대로 작동했는지 확인합니다. 이 경우, 단언문은 assertEquals(4, 2 + 2)로 4가 2 + 2와 같은지를 확인합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 테스트 전략\n\n가독성이 좋은 테스트를 작성하는 몇 가지 다른 전략이 있습니다. 방금 작성한 테스트에서 이 두 가지 전략이 모두 보여집니다.\n\n## 주어진 상황, When, Then\n\n테스트의 구조를 생각하는 한 가지 방법은 주어진 상황, When, Then 테스트 니모닉을 따르는 것입니다. 이를 통해 테스트를 세 부분으로 나눌 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 주어진: 테스트에 필요한 객체 및 앱 상태를 설정하십시오. 이 테스트에서 \"주어진\" 부분이 무엇인가요.\n- 실행: 테스트 중인 객체에 대해 실제로 작업을 수행하십시오.\n- 결과: 이 부분은 실제로 작업을 수행할 때 일어나는 일을 확인하는 곳으로, 테스트가 통과했는지 실패했는지 확인합니다. 보통 여러 assert 함수 호출이 포함됩니다.\n\n주의해 주실 점은 \"준비, 실행, 확인\" (AAA) 테스트 니모닉이 유사한 개념이라는 것입니다.\n\n```js\n@Test\nfun getUserProfile_givenUserId_returnUser() {\n    // 주어진\n    val userId = 1\n    val user = User(userId,\"\",\"TestUser\")\n    // 실행\n    doReturn(Observable.just(user)).`when`(webservice).getMyProfile(userId)\n    presenter.getUserProfile(anyString())\n    // 결과\n    verify(profileView).render(ProfileState.DataState(user))\n}\n```\n\n# 종속성 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 종속성을 추가할 때 구현을 사용합니다. 앱을 세계와 공유할 준비가 되면, 테스트 코드나 앱의 종속성을 APK의 크기를 부풀리지 않는 것이 가장 좋습니다. Gradle 구성을 사용하여 라이브러리가 주 코드 또는 테스트 코드에 포함되어야 하는지 지정할 수 있습니다.\n\n가장 일반적인 구성은 다음과 같습니다:\n\n- implementation—이 종속성은 테스트 소스 세트를 포함한 모든 소스 세트에서 사용할 수 있습니다.\n- testImplementation—이 종속성은 테스트 소스 세트에서만 사용할 수 있습니다.\n- androidTestImplementation—이 종속성은 androidTest 소스 세트에서만 사용할 수 있습니다.\n\n# 테스트 더블들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 문제의 해결책은 리포지토리를 테스트할 때 실제 네트워킹 또는 데이터베이스 코드를 사용하지 말고 대신 테스트 더블을 사용해야 합니다. 테스트 더블은 테스트를 위해 특별히 작성된 클래스의 버전을 말합니다. 이것은 테스트에서 사용되는 클래스의 실제 버전을 대체하는 것을 목적으로 합니다. 이는 스턴트 배우가 위험한 액션을 대신하는 것처럼 테스트 더블이 스턴트에 특화된 배우인 것과 유사합니다.\n\n다음은 일부 테스트 더블의 유형입니다:\n\n## 가짜(Fake)\n\n클래스의 \"작동\" 구현을 갖는 테스트 더블이지만 테스트에는 적합하지만 프로덕션에는 적합하지 않은 방식으로 구현되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 목\n\n호출된 메소드를 추적하는 테스트 더블(Mock)입니다. 그런 다음 메소드가 올바르게 호출되었는지에 따라 테스트를 통과하거나 실패합니다. 객체를 모의(Mock)하면 해당 클래스의 빈 구현이 생성됩니다.\n\n# 네이밍 규칙\n\n테스트의 이름은 해당 테스트가 무엇을 하는지 이해하는 데 도움이 되어야 합니다. 네이밍 규칙은 다음과 같이 보여야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**subjectUnderTest_actionOrInput_resultState**\n\n- Subject under test is the method or class that is being tested (getUserProfile).\n- Next is the action or input (givenUserId).\n- Finally you have the expected result (returnUser).\n\n**Pro Tip**\n\nWhen you have repeated setup code for multiple tests, you can use the @Before annotation to create a setup method and remove repeated code.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사를 읽어 주셔서 감사합니다. 도움이 되었다면 아래 👏을 클릭해서 기사를 칭찬해주세요. 제게 매우 큰 의미가 됩니다. 댓글이나 트위터, 링크드인을 통해 연락 주시면 감사하겠습니다. 코딩 즐기시고 즐거운 시간 보내세요!\n\n커피 사주세요 ☕\n","ogImage":{"url":"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-06-23-UnitTestingforAndroidABeginnersGuide_0.png","tag":["Tech"],"readingTime":8},{"title":"안드로이드 앱에서 URL로 썸네일 또는 로고 가져오는 방법","description":"","date":"2024-06-23 20:56","slug":"2024-06-23-FetchThumbnailorLogofromAnyURLinYourAndroidApp","content":"\n이 기사에서는 안드로이드 애플리케이션에서 주어진 URL에서 섬네일이나 로고를 가져와서 표시하는 방법을 안내하겠습니다. 네트워크 요청에는 Retrofit, HTML 파싱에는 Jsoup, 이미지 로딩에는 Glide를 사용할 예정입니다.\n\n# 특징\n\n- 주어진 URL에서 HTML 콘텐츠를 가져옵니다.\n- HTML을 파싱하여 섬네일이나 로고 URL을 추출합니다.\n- Glide를 사용하여 가져온 이미지를 표시합니다.\n- 섬네일이나 로고를 찾을 수 없는 경우 기본 로고로 대체합니다.\n\n# 사용 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 앱은 다음과 같은 여러 시나리오에 유용할 수 있어요:\n\n- 메시지나 소셜 미디어 앱에서 공유된 URL에 미리보기 이미지 표시하기.\n- 콘텐츠 집계 앱에서 블로그 글이나 기사의 썸네일 표시하기.\n- 북마크 관리자에서 링크와 관련된 로고나 이미지를 가져와 표시하기.\n\n# 시작하기\n\n# 요구 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 안드로이드 스튜디오\n- 코틀린\n- 인터넷 연결\n\n# 종속성\n\n다음 종속성을 build.gradle.kts 파일에 추가해주세요:\n\n```js\nimplementation(\"com.squareup.retrofit2:retrofit:2.9.0\");\nimplementation(\"com.squareup.retrofit2:converter-scalars:2.9.0\");\nimplementation(\"org.jsoup:jsoup:1.13.1\");\nimplementation(\"com.github.bumptech.glide:glide:4.11.0\");\nkapt(\"com.github.bumptech.glide:compiler:4.11.0\");\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 사용 방법\n\n- 저장소를 복제합니다:\n\n  bash\n  git clone https://github.com/WalidAhmed90/Fetch-Thumbnail-or-Logo-in-Android-App.git\n  cd Fetch-Thumbnail-or-Logo-in-Android-App\n\n2. Android Studio에서 프로젝트를 엽니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 안드로이드 기기 또는 에뮬레이터에서 프로젝트를 빌드하고 실행하세요.\n\n4. URL을 입력하고 \"썸네일 생성\" 버튼을 클릭하여 썸네일이나 로고를 가져와 표시하세요.\n\n# 코드 개요\n\n## API 서비스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nApiService 인터페이스는 URL에서 HTML 콘텐츠를 가져오는 메서드를 정의합니다:\n\n```js\ninterface ApiService {\n    @GET\n    suspend fun fetchHtml(@Url url: String): String\n}\n```\n\n## 썸네일 가져오기\n\nfetchThumbnail 함수는 HTML 콘텐츠를 가져와 썸네일이나 로고를 찾아 Glide를 사용하여 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nfun fetchThumbnail(url: String) {\n        mBinding.progress.visibility = View.VISIBLE\n        val retrofit = Retrofit.Builder()\n            .baseUrl(\"https://example.com/\")  // 가짜 기본 URL, 덮어쓰기될 예정\n            .client(OkHttpClient())\n            .addConverterFactory(ScalarsConverterFactory.create())\n            .build()\n\n        val apiService = retrofit.create(ApiService::class.java)\n\n        CoroutineScope(Dispatchers.IO).launch {\n            try {\n                val html = apiService.fetchHtml(url)\n                Log.d(\"HTML_CONTENT\", html) // 가져온 HTML 내용 로깅\n\n                val document = Jsoup.parse(html)\n                val metaTags = document.select(\"meta[property=og:image], meta[name=twitter:image]\")\n\n                var thumbnailUrl: String? = null\n                for (metaTag in metaTags) {\n                    val content = metaTag.attr(\"content\")\n                    if (content.isNotEmpty()) {\n                        thumbnailUrl = content\n                        break\n                    }\n                }\n\n                if (thumbnailUrl == null) {\n                    val mainImage: Element? = document.select(\"table.infobox img\").first()\n                    mainImage?.let {\n                        thumbnailUrl = \"https:${it.attr(\"src\")}\"\n                    }\n                }\n\n                // 썸네일 이미지를 찾을 수 없는 경우 도메인 로고로 대체\n                if (thumbnailUrl == null) {\n                    val domain = Uri.parse(url).host ?: \"\"\n                    thumbnailUrl = \"https://logo.clearbit.com/$domain\"\n                }\n\n                if (thumbnailUrl != null) {\n                    launch(Dispatchers.Main) {\n                        mBinding.progress.visibility = View.GONE\n                        Glide.with(this@MainActivity)\n                            .load(thumbnailUrl)\n                            .into(mBinding.thumbnailImage)\n                    }\n                } else {\n                    mBinding.progress.visibility = View.GONE\n                    Log.d(\"THUMBNAIL\", \"이미지를 찾을 수 없습니다.\")\n                }\n            } catch (e: Exception) {\n                e.printStackTrace()\n                mBinding.progress.visibility = View.GONE\n            }\n        }\n    }\n```\n\n## Layout\n\nactivity_main.xml 레이아웃 파일은 다음과 같이 UI 구성요소를 정의합니다:\n\n```xml\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003clayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\u003e\n\n    \u003cdata\u003e\n\n    \u003c/data\u003e\n\n    \u003candroidx.constraintlayout.widget.ConstraintLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n  \u003e\n\n        \u003cLinearLayout\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"match_parent\"\n            android:orientation=\"vertical\"\n            android:padding=\"16dp\"\n            app:layout_constraintBottom_toBottomOf=\"parent\"\n            app:layout_constraintEnd_toEndOf=\"parent\"\n            app:layout_constraintStart_toStartOf=\"parent\"\n            app:layout_constraintTop_toTopOf=\"parent\"\n            tools:context=\".MainActivity\"\u003e\n\n            \u003cEditText\n                android:id=\"@+id/urlInput\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:textColor=\"@color/grey\"\n                android:layout_marginTop=\"20dp\"\n                android:hint=\"URL 입력\" /\u003e\n\n            \u003cButton\n                android:id=\"@+id/generateButton\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_marginTop=\"10dp\"\n                android:text=\"썸네일 생성\" /\u003e\n\n            \u003cImageView\n                android:id=\"@+id/thumbnailImage\"\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"wrap_content\"\n                android:adjustViewBounds=\"true\"\n                android:contentDescription=\"썸네일\"\n                android:layout_marginTop=\"10dp\"\n                android:scaleType=\"fitCenter\"\n                android:visibility=\"visible\" /\u003e\n\n            \u003ccom.google.android.material.progressindicator.CircularProgressIndicator\n                android:id=\"@+id/progress\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                app:indicatorColor=\"@color/green\"\n                android:indeterminate=\"true\"\n                android:layout_gravity=\"center_horizontal\"\n                android:visibility=\"gone\"\n                /\u003e\n\n        \u003c/LinearLayout\u003e\n\n\n    \u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\n\u003c/layout\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 기여하기\n\n문제를 발견하거나 개선 제안이 있는 경우 문제를 열거나 풀 요청을 제출해주세요.\n\n# 결과:\n\n![Output](https://miro.medium.com/v2/resize:fit:1200/1*606E5BSXDVXR6xuwV6sFSg.gif)\n","ogImage":{"url":"/assets/img/2024-06-23-FetchThumbnailorLogofromAnyURLinYourAndroidApp_0.png"},"coverImage":"/assets/img/2024-06-23-FetchThumbnailorLogofromAnyURLinYourAndroidApp_0.png","tag":["Tech"],"readingTime":9},{"title":"루비와 OpenSSL의 미스터리한 이야기","description":"","date":"2024-06-23 20:55","slug":"2024-06-23-ThecuriouscaseofRubyandOpenSSL","content":"\n![image](/assets/img/2024-06-23-ThecuriouscaseofRubyandOpenSSL_0.png)\n\n만약 당신이 컴퓨터에 익숙한 사용자라면, 토런트를 통해 게임을 다운로드하고 크랙을 사용하거나 라이브러리를 설치하는 경우와 같이 일부 상황에서는 오류를 만날 수밖에 없습니다. 그럴 때 여러 웹사이트를 찾아다니거나 여러 YouTube 동영상을 보며 해결책을 찾는 긴 여정을 겪게 될 수 있습니다. 그런 상황에서는 당신의 노력이 가치 있는지 의심하게 될 수도 있지만, 결국 그 문제를 해결했을 때의 기분은 정말로 훌륭합니다. 제 경험을 들어보면 PC용 콜 오브 듀티 블랙 옵스 II를 수정하거나 Wii의 임의의 CD를 허용하기 위해 크랙을 적용하거나 Arch Linux를 설치하는 등 여러 번 이런 상황을 겪었습니다. 그리고 지금은 Ruby용 webauthn 젬을 설치하는 과정에서 OpenSSL 오류를 해결하고 있습니다. StackOverflow의 답변을 여러 개 찾아보고 관련 블로그 글을 여러 개 읽은 결과, 처음에는 문제 해결에 실패했지만 약 한 시간을 투자한 끝에 성공했습니다. 비슷한 문제가 다시 발생할 경우를 대비해 나의 해결책을 문서로 남겨두기로 했습니다.\n\nwebauthn을 설치하려고 하는 과정에서 에러 메시지가 나왔습니다. sudo gem install webauthn 명령을 입력하자 다음과 같은 응답이 왔습니다: ERROR: While executing gem ... (Gem::Exception) Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources..\n\n두 가지 잠재적인 해결책을 살펴보았습니다. 먼저, 몇몇 온라인 소스에서 제안한 대로 기본 Ruby를 제거하고 다시 설치해보기로 결정했습니다. rvm remove ruby-2.6.10 명령을 사용하여 버전을 성공적으로 제거했지만 rvm install ruby-2.6.10 --with-openssl-dir=`/usr/local/opt/openssl` 명령을 사용하여 재설치하려고 시도했을 때 추가 문제가 발생했습니다. Ruby를 설치했지만 webauthn을 설치하려고 할 때 문제가 지속되었습니다. 나중에 Ruby gem을 업데이트해야 문제를 해결할 수 있다는 것을 발견했습니다. sudo gem update --system 명령을 사용하여 시도했지만 또 다른 오류가 발생했습니다: ruby: No such file or directory -- setup.rb (LoadError). 여러 해결책을 조사한 끝에 gem install rubygems-update --source http://production.s3.rubygems.org/ update_rubygems와 같은 방법으로 시도해도 문제를 해결할 수 없었습니다. 결국 다시 Ruby를 제거하고 brew install을 통해 설치하니 gem을 성공적으로 업데이트할 수 있었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpenSSL 오류를 해결하면서 루비와 비슷한 방법을 시도하기로 결정했습니다. homebrew를 사용하여 OpenSSL 1.0을 설치하기로 결정해서 brew install rbenv/tap/openssl@1.0을 실행했고, 이전 버전의 OpenSSL을 참조하여 루비를 다시 설치했습니다: rvm reinstall 2.6.10 --with-openssl-dir=`/usr/local/opt/openssl@1.0`. 놀랍게도 작동했습니다! 이것이 제 첫 번째 해결책이었고, 이 아이디어를 제공해준 데 대해 감사를 표합니다.\n\n그러나 OpenSSL 오류를 해결한 뒤 webauthn을 설치하려고 시도할 때 추가 오류가 발생했습니다: ERROR: While executing gem ... (Gem::FilePermissionError) You don`t have write permissions for the /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/gems/2.6.0 directory.. 조사를 한 결과, 이는 Mac의 미리 설치된 Ruby 버전에 직접 gem을 설치하는 것에 대한 Apple의 제한 때문이었음을 알게 되었습니다. 좀 더 깊이 파고들어 알아보니 Apple이 macOS의 10.15 버전인 Catalina에서 macOS에 내장된 각종 스크립트 언어 런타임을 공식으로 사용 중단했다는 것을 알게 되었습니다. macOS Catalina 10.15 릴리스 노트에서 관련 정보를 찾아볼 수 있습니다. 더 깊이 조사한 결과 두 번째 해결책을 찾게 되었습니다.\n\n루비 2.6.10을 사용하는 것이 내가 겪은 문제들의 근본 원인이었음을 알게 되었습니다. 이 문제를 해결하기 위해 최신 버전의 루비를 설치하여, rvm install ruby-3.2.1을 실행하고, sudo gem install webauthn으로 webauthn을 설치했습니다. 어려움 없이 작동했고, 다음 메시지가 표시되었습니다: Done installing documentation for openssl-signature_algorithm, bindata, tpm-key_attestation, jwt, safety_net_attestation, cbor, cose, awrence, android_key_attestation, webauthn after 1 seconds. 10 gems installed.\n\n전반적으로 상당히 흥미로운 오류였으며 해결하는 것이 즐거웠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 부가 정보:\n\n- 때때로, RVM이 이상하게 행동할 수 있습니다. 그냥 삭제하고 다시 설치하세요. rm -rf ~/.rvm를 입력한 후, curl -L https://get.rvm.io | bash -s stable을 실행하세요.\n- 젬을 설치할 때 경로를 제공해야 합니다. 이렇게: sudo gem install -n /usr/local/bin GEM_NAME. 이걸 매번 하기 귀찮다면, 먼저 이렇게 하세요: echo \"gem: -n/usr/local/bin\" `` ~/.gemrc. 다음에는 그냥 sudo gem install GEM_NAME을 실행하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-ThecuriouscaseofRubyandOpenSSL_0.png"},"coverImage":"/assets/img/2024-06-23-ThecuriouscaseofRubyandOpenSSL_0.png","tag":["Tech"],"readingTime":4},{"title":"리트코드 두 수 더하기 문제 해결 - 루비 솔루션 완벽 가이드","description":"","date":"2024-06-23 20:53","slug":"2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough","content":"\n\u003cimg src=\"/assets/img/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough_0.png\" /\u003e\n\n# 소개\n\nLeetCode의 'Add Two Numbers' 문제는 두 개의 음이 아닌 정수를 나타내는 비어 있지 않은 두 연결 리스트를 더하는 것을 포함합니다. 각 목록의 숫자는 역순으로 저장되어 있으며, 각 노드에는 한 자리 숫자가 포함되어 있습니다. 이 작업은 두 숫자를 더하고 합계를 연결 리스트로 반환하는 것입니다.\n\nRuby는 간결한 구문과 동적 기능으로 이 문제를 효율적으로 해결하는 여러 가지 방법을 제공합니다. 이 안내서에서는 'Add Two Numbers' 문제를 해결하기 위한 4가지 Ruby 솔루션을 살펴보겠습니다. 이 가이드의 끝에서 각 방법의 메커니즘과 효율성, 효과에 대한 이해를 얻게 될 것입니다. 코드 주석 및 각 방법에 대한 자세한 단계별 설명은 결론 이후에 제공됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 문제 설명\n\n```js\n# 단일 연결 리스트에 대한 정의\n# class ListNode\n#     attr_accessor :val, :next\n#     def initialize(val = 0, _next = nil)\n#         @val = val\n#         @next = _next\n#     end\n# end\n```\n\n## 루비에서의 함수 시그니처:\n\n```js\n# @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef add_two_numbers(l1, l2)\n\nend\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시 1:\n\n\u003cimg src=\"/assets/img/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough_1.png\" /\u003e\n\n- 입력: l1 = [2,4,3], l2 = [5,6,4]\n- 출력: [7,0,8]\n- 설명: 342 + 465 = 807.\n\n## 예시 2:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 입력: l1 = [0], l2 = [0]\n- 출력: [0]\n\n## 예제 3:\n\n- 입력: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n- 출력: [8,9,9,9,0,0,0,1]\n\n## 제약 조건\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 각 연결 목록의 노드 수는 [1, 100] 범위 내에 있습니다.\n- 0 ≤ Node.val ≤ 9\n- 목록이 선행 0이 없는 숫자를 나타낸다는 것이 보장됩니다.\n\n# 해법 1: 전달하는 접근 방법 및 캐리 처리\n\n이 간단한 접근 방법은 두 연결 목록을 반복하며 해당하는 숫자를 더하고, 9보다 큰 합계에 대해 캐리를 처리하는 것을 포함합니다.\n\n## 루비 코드:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new(0)\n    current = dummy\n    carry = 0\n\n    while l1 || l2\n        x = l1 ? l1.val : 0\n        y = l2 ? l2.val : 0\n        sum = carry + x + y\n        carry = sum / 10\n        current.next = ListNode.new(sum % 10)\n        current = current.next\n        l1 = l1.next if l1\n        l2 = l2.next if l2\n    end\n\n    current.next = ListNode.new(carry) if carry \u003e 0\n    dummy.next\nend\n```\n\n## 시간 및 공간 복잡도\n\n- 시간 복잡도: O(n). 이 알고리즘은 연결 리스트 l1과 l2를 정확히 한 번씩 훑습니다. 각 반복에서 각 목록에서 하나의 노드를 처리하고 고정량의 작업(덧셈, carry 처리 및 노드 생성)을 수행합니다. 따라서 시간 복잡도는 긴 목록의 길이에 대해 선형입니다.\n- 공간 복잡도: O(n). 공간 복잡도는 결과 연결 리스트를 저장하는 데 필요한 공간에 의해 결정됩니다. 합의 각 자릿수에 대해 새로운 노드가 생성되므로 공간 복잡도는 결과 목록의 길이에 비례하며 O(n)입니다. carry, dummy 및 current와 같은 변수에 사용하는 보조 공간은 상수(O(1))입니다. 그러나 새로운 연결 리스트가 전체 O(n) 공간 복잡도에 기여합니다.\n\n# Solution 2: 재귀적 접근\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 접근 방식은 재귀를 사용하여 숫자와 올림을 처리하며, 더 작은 재귀 호출로 반복 논리를 단순화합니다.\n\n## 루비 코드:\n\n```js\ndef add_two_numbers(l1, l2, carry = 0)\n    return ListNode.new(carry) if l1.nil? \u0026\u0026 l2.nil? \u0026\u0026 carry \u003e 0\n    return nil if l1.nil? \u0026\u0026 l2.nil?\n\n    sum = carry\n    sum += l1.val if l1\n    sum += l2.val if l2\n\n    result = ListNode.new(sum % 10)\n    result.next = add_two_numbers(l1 ? l1.next : nil, l2 ? l2.next : nil, sum / 10)\n    result\nend\n```\n\n## 시간 및 공간 복잡도\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 시간 복잡도: O(n). 반복적인 방법과 유사하게, 재귀적인 해결책은 입력 리스트의 각 노드를 한 번씩 처리합니다. 각 재귀 호출은 하나의 숫자 더하기를 처리하고 l1 및 l2의 다음 노드로 진행하며, 시간 복잡도는 더 긴 리스트의 길이에 비례하여 선형적입니다.\n- 공간 복잡도: O(n). 공간 복잡도에는 새 연결 리스트와 재귀 호출 스택에 필요한 공간이 모두 포함됩니다. 각 재귀 호출은 스택 공간을 소비하므로 재귀 깊이가 더 긴 리스트의 길이와 동일하기 때문에 재귀 깊이가 O(n)이 되어 O(n) 공간 복잡도가 발생합니다. 또한 결과를 저장하기 위해 생성된 새 연결 리스트가 O(n) 공간 복잡도에 기여합니다. 따라서, 호출 스택과 새 연결 리스트에 대한 총 공간 복잡도는 O(n)입니다.\n\n# Solution 3: Using Enumerators for Clean Iteration\n\n이 접근 방식은 루비의 enumerators를 활용하여 연결된 리스트를 반복하는 코드를 더 깔끔하고 관용적으로 만듭니다.\n\n## 루비 코드:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new(0)\n    current = dummy\n    carry = 0\n\n    e1 = to_enum(l1)\n    e2 = to_enum(l2)\n\n    loop do\n        begin\n            x = e1.next\n        rescue StopIteration\n            x = ListNode.new(0)\n        end\n\n        begin\n            y = e2.next\n        rescue StopIteration\n            y = ListNode.new(0)\n        end\n\n        sum = carry + x.val + y.val\n        carry = sum / 10\n        current.next = ListNode.new(sum % 10)\n        current = current.next\n\n        break if x.next.nil? \u0026\u0026 y.next.nil? \u0026\u0026 carry.zero?\n    end\n\n    current.next = ListNode.new(carry) if carry \u003e 0\n    dummy.next\nend\n\ndef to_enum(node)\n    Enumerator.new do |yielder|\n        while node\n            yielder \u003c\u003c node\n            node = node.next\n        end\n    end\nend\n```\n\n## 시간 복잡도와 공간 복잡도\n\n- 시간 복잡도: O(n). 이 알고리즘은 입력 연결 리스트의 각 노드를 정확히 한 번씩 처리합니다. 각 노드마다 상수 시간의 작업(덧셈, carry 처리 및 노드 생성)을 수행합니다. Enumerators의 사용은 각 노드가 더 긴 목록의 길이에 비례하는 선형 시간 내에 처리된다는 사실을 변경하지 않습니다.\n- 공간 복잡도: O(n). 공간 복잡도는 결과 연결 리스트를 저장하는 데 필요한 공간에 의해 결정됩니다. 합의 각 자릿수마다 새로운 노드가 생성되므로 공간 복잡도는 결과 목록의 길이에 비례하며 O(n)입니다. carry, dummy 및 current와 같은 변수에 사용된 보조 공간은 상수(O(1))이지만 새로운 연결 리스트가 전체적인 O(n) 공간 복잡도를 차지합니다. Enumerators의 사용은 최소한의 오버헤드를 추가하며 공간 복잡도에 중대한 영향을 미치지 않습니다.\n\n# 솔루션 4: 입력 리스트의 위치 수정을 통한 해결 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n긴 입력 목록의 노드를 변경하여 결과 목록을 만드는 추가 노드를 생성하지 않고 재사용하는 방식으로 처리합니다.\n\n## 루비 코드:\n\n```js\ndef add_two_numbers(l1, l2)\n    carry = 0\n    head = l1\n    prev = nil\n\n    while l1 \u0026\u0026 l2\n        sum = l1.val + l2.val + carry\n        carry = sum / 10\n        l1.val = sum % 10\n        prev = l1\n        l1 = l1.next\n        l2 = l2.next\n    end\n\n    if l2\n        prev.next = l2\n        l1 = l2\n    end\n\n    while l1\n        sum = l1.val + carry\n        carry = sum / 10\n        l1.val = sum % 10\n        prev = l1\n        l1 = l1.next\n    end\n\n    if carry \u003e 0\n        prev.next = ListNode.new(carry)\n    end\n\n    head\nend\n```\n\n## 시간 및 공간 복잡도\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 시간 복잡도: O(n). 이 알고리즘은 입력 연결 리스트의 각 노드를 정확히 한 번 처리하므로, 긴 리스트의 길이에 비례하여 선형 시간 복잡도를 갖습니다.\n- 공간 복잡도: O(1). 알고리즘은 결과를 위해 추가 공간을 할당하지 않고 기존 노드를 그대로 수정하므로, 공간 복잡도는 상수입니다. 사용되는 추가 공간은 몇 가지 보조 변수(carry, prev, head) 뿐이며 입력 크기에 따라 달라지지 않습니다.\n\n# 결론 및 비교\n\n분석 결과, 네 가지 루비 메서드의 시간 복잡도는 모두 유사하며, 각각 입력 연결 리스트를 한 번만 순회하는 작업이 포함되어 있습니다. 결과 연결 리스트 및 carry를 처리하는 전략에 따라 솔루션 간 공간 복잡도가 달라집니다.\n\n## 솔루션 1: Carry 처리를 포함한 반복적 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 장점: 직관적이고 이해하기 쉽습니다. 두 숫자의 덧셈을 처리하는 데 효율적으로 작동하며 리스트를 반복하고 루프 내에서 캐리를 처리합니다. 논리가 명확하고 간단하여 구현 및 디버깅이 쉽습니다.\n- 단점: 결과를 저장하기 위해 새 연결 리스트를 생성해야 하므로 O(n) 공간 복잡성을 가집니다. 이 방법은 인플레이스 수정 솔루션보다 공간을 덜 효율적으로 사용합니다.\n\n## 솔루션 2: 재귀적 접근\n\n- 장점: 명확하고 간결한 해결책을 제공합니다. 반복 논리를 더 작은 조각으로 나누어 처리하는 재귀 호출을 통해 단순화합니다. 코드가 깨끗하고 이해하기 쉬워 재귀를 선호하는 사람들에게 좋은 선택입니다.\n- 단점: 재귀 스택으로 인해 공간 복잡성이 높아져 O(n)의 공간을 사용할 수 있습니다. 이는 매우 큰 입력 크기에 대한 제약으로, 스택 오버플로우 문제를 일으킬 수 있습니다.\n\n## 솔루션 3: 깔끔한 반복을 위한 열거자 사용\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 장점: Ruby의 enumerators를 활용하여 더 깔끔하고 관용적인 접근을 제공합니다. 명시적인 확인이 줄어들고 반복을 우아하게 처리합니다. 이 해결책은 Ruby의 고수준 구조를 이해하는 사람들에게 적합합니다.\n- 단점: 첫 번째 해결책에 비해 약간 더 복잡한 논리를 요구하며 Ruby의 enumerators에 대한 숙련도가 필요합니다. 공간 복잡도는 새로운 연결 리스트를 만들어야 하기 때문에 O(n)으로 유지됩니다.\n\n## 솔루션 4: 입력 리스트의 자리수 수정\n\n- 장점: 이 해결책은 입력 리스트의 노드를 그 자리에서 수정하여 공간을 가장 효율적으로 활용합니다. 기존 노드를 재사용하고 추가적인 노드를 만들지 않음으로써 O(1)의 고정된 공간 복잡도를 달성합니다. 메모리 소비를 과도하게 막으면서 대량의 입력 크기를 처리하기에 이상적입니다.\n- 단점: 자리수 수정을 위한 논리는 더 복잡하며 노드 포인터와 값에 대한 주의 깊은 처리가 필요합니다. 다른 해결책들에 비해 오류 발생 가능성이 높고 디버깅하기 어려울 수 있습니다.\n\n## 요약\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 해결책 1: 캐리 처리를 포함한 반복적 접근은 간단함과 효율성 사이의 균형을 제공하여 문제를 이해하는 데 좋은 시작점이 될 수 있습니다.\n- 해결책 2: 재귀적 접근은 명확하고 간결한 해결책을 제공하지만 큰 입력에 대해 더 높은 공간 복잡성을 가집니다.\n- 해결책 3: 깨끗한 반복을 위한 Enumerators 사용은 Ruby의 고수준 구조를 활용하여 더 깔끔한 접근을 제공하지만 반복적인 접근과 동일한 공간 복잡성을 가집니다.\n- 해결책 4: 입력 리스트의 내부 수정은 가장 공간을 효율적으로 활용할 수 있으며 큰 입력 크기에 적합하지만 더 신중한 구현이 필요합니다.\n\n네 개의 해결책 모두 장단점이 있지만, 공간 효율성 면에서 해결책 4가 최적의 선택으로 돋보입니다. 입력 리스트를 그대로 수정함으로써 메모리 사용량을 최소화하고, 대규모 데이터셋을 다룰 때 특히 유리합니다. 그러나 더 세심한 구현 방식이 필요합니다. 포인터 관리와 내부 수정에 익숙한 사람들에게는 자원을 가장 효율적으로 사용할 수 있는 해결책 4를 추천합니다.\n\n- LeetCode — 두 수 더하기\n- Ruby 문서\n\n읽어 주셔서 감사합니다! 이 안내서가 도움이 되었다면, 하이라이트를 주거나 박수를 치거나 답글을 달거나 Twitter/X를 통해 연결해 주시면 정말 감사하겠습니다. 이는 매우 감사히 받아들이며, 이와 같은 콘텐츠를 계속 무료로 제공하는 데 도움이 됩니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 다른 Leetcode Walkthrough 목록도 확인해보세요:\n\n- Two Sum 문제\n- Palindrome Number 문제\n\n# 주석이 달린 코드 및 단계별 설명\n\n## 솔루션 1: 캐리 처리를 포함한 반복적 접근\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법은 두 연결 리스트를 반복하면서 해당하는 숫자를 합쳐서 9보다 큰 경우를 위해 캐리를 관리합니다. 결과를 저장하기 위해 새로운 연결 리스트를 만듭니다. 이 방법은 구현하고 이해하기 쉽기 때문에 직관적입니다. 두 리스트를 동시에 탐색하면 모든 숫자가 정확하게 처리되며 존재하는 경우 최종 캐리도 처리합니다.\n\n```js\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new(0)  # 결과 리스트의 헤드 역할을 할 더미 노드 생성\n    current = dummy  # 결과 리스트를 구축하기 위한 포인터 초기화\n    carry = 0  # 캐리 초기화\n\n    while l1 || l2  # 두 리스트가 모두 완전히 처리될 때까지 순회\n        x = l1 ? l1.val : 0  # l1의 현재 노드 값 또는 l1이 nil인 경우 0 반환\n        y = l2 ? l2.val : 0  # l2의 현재 노드 값 또는 l2가 nil인 경우 0 반환\n        sum = carry + x + y  # 현재 값과 캐리의 합 계산\n        carry = sum / 10  # 캐리 업데이트\n        current.next = ListNode.new(sum % 10)  # 숫자 값으로 새 노드 생성하고 결과 리스트에 연결\n        current = current.next  # 결과 리스트의 다음 노드로 이동\n        l1 = l1.next if l1  # l1이 있으면 l1의 다음 노드로 이동\n        l2 = l2.next if l2  # l2가 있으면 l2의 다음 노드로 이동\n    end\n\n    current.next = ListNode.new(carry) if carry \u003e 0  # 나머지 캐리가 있는 경우, 해당 값을 갖는 새 노드 생성\n    dummy.next  # 결과 리스트의 헤드 반환\nend\n```\n\n단계별 설명\n\n- 단계 1: 결과 리스트의 헤드로 사용할 더미 노드와 결과 리스트를 구축하기 위한 현재 포인터를 초기화합니다. 캐리를 0으로 초기화합니다.\n- 단계 2: l1 및 l2를 동시에 탐색합니다.\n- 단계 3: 현재 노드의 값(x 및 y)을 추출합니다. 리스트가 완전히 순회된 경우, 값으로 0을 사용합니다.\n- 단계 4: x, y 및 캐리의 합을 계산합니다.\n- 단계 5: 합을 10으로 나누어 캐리를 업데이트합니다.\n- 단계 6: 값이 sum % 10인 새 노드를 만들고 결과 리스트에 연결합니다.\n- 단계 7: 현재 포인터를 새 노드로 이동합니다.\n- 단계 8: l1 및 l2 포인터를 다음 노드로 이동합니다(존재하는 경우).\n- 단계 9: 반복문을 종료한 후, 남은 캐리가 있는지 확인합니다. 있다면 해당 값을 갖는 새 노드를 만들고 결과 리스트에 연결합니다.\n- 단계 10: 결과 리스트의 헤드로 더미 노드의 다음을 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 해결 방법 2: 재귀 접근 방식\n\n이 방법은 숫자 및 캐리의 덧셈을 처리하기 위해 재귀를 사용하여 반복 논리를 작은 재귀 호출로 분해하여 단순화합니다. 재귀를 사용하면 덧셈 과정을 효율적으로 처리하므로 코드가 간결하고 명확해집니다. 이 함수는 각 재귀 호출에서 각 입력 목록의 하나의 숫자를 처리하고 이들을 캐리와 함께 더한 다음 다음 노드로 진행합니다. 이 방법은 상태를 관리하기 위해 호출 스택을 효과적으로 활용하여 재귀를 선호하는 사람들에게 좋은 선택입니다.\n\n```js\ndef add_two_numbers(l1, l2, carry = 0)\n    return ListNode.new(carry) if l1.nil? \u0026\u0026 l2.nil? \u0026\u0026 carry \u003e 0  # 기본 사례: 모두 nil이면서 캐리 값이 있는 경우 빈 노드를 반환\n    return nil if l1.nil? \u0026\u0026 l2.nil?  # 기본 사례: 모두 nil이면서 캐리 값이 없는 경우 빈 노드를 반환\n\n    sum = carry  # 캐리 값으로 시작\n    sum += l1.val if l1  # l1의 현재 노드 값 추가(현재 노드가 있는 경우)\n    sum += l2.val if l2  # l2의 현재 노드 값 추가(현재 노드가 있는 경우)\n\n    result = ListNode.new(sum % 10)  # 숫자 값으로 새 노드 생성\n    result.next = add_two_numbers(l1 ? l1.next : nil, l2 ? l2.next : nil, sum / 10)  # 다음 노드 및 캐리로 재귀 호출\n    result  # 결과 노드 반환\nend\n```\n\n단계별 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 단계 1: 기본 경우: l1과 l2가 모두 nil이고 캐리가 없는 경우 nil을 반환합니다.\n- 단계 2: 현재 노드(l1 및 l2)와 캐리의 값들을 더합니다.\n- 단계 3: 합과 새로운 캐리를 계산합니다.\n- 단계 4: 합 % 10 값을 갖는 새로운 노드를 생성합니다.\n- 단계 5: 새로운 캐리를 전달하여 l1과 l2의 다음 노드로 재귀적으로 함수를 호출합니다.\n- 단계 6: 재귀 호출 결과를 새로운 노드의 다음에 연결합니다.\n- 단계 7: 새롭게 생성된 노드를 반환합니다.\n\n## 솔루션 3: 깨끗한 반복을 위한 Enumerators 사용\n\n이 접근 방식은 Ruby의 Enumerators를 활용하여 링크드 리스트를 반복하면서 코드를 더 깔끔하고 Ruby다운 방식으로 만듭니다. Enumerators는 명시적인 루프를 피하고 코드를 더 읽기 쉽게 만들어주는 Ruby스러운 반복 처리 방식을 제공합니다. Enumerators를 사용함으로써이 솔루션은 각 숫자가 올바르게 합산되고 처리되도록 하고 불필요하게 새 노드를 생성하지 않고 리스트를 탐색하고 캐리를 관리하는 과정을 간소화합니다.\n\n```js\ndef add_two_numbers(l1, l2)\n    dummy = ListNode.new(0)  # 결과 리스트의 헤드로 사용할 더미 노드를 만듭니다\n    current = dummy  # 결과 리스트를 구성하는 포인터를 초기화합니다\n    carry = 0  # 캐리를 초기화합니다\n\n    e1 = to_enum(l1)  # l1에 대한 이너레이터를 생성합니다\n    e2 = to_enum(l2)  # l2에 대한 이너레이터를 생성합니다\n\n    loop do\n        begin\n            x = e1.next  # e1에서 다음 값 가져오기\n        rescue StopIteration\n            x = ListNode.new(0)  # e1이 소진된 경우 0 사용\n        end\n\n        begin\n            y = e2.next  # e2에서 다음 값 가져오기\n        rescue StopIteration\n            y = ListNode.new(0)  # e2가 소진된 경우 0 사용\n        end\n\n        sum = carry + x.val + y.val  # 현재 값 및 캐리의 합 구하기\n        carry = sum / 10  # 캐리 업데이트\n        current.next = ListNode.new(sum % 10)  # 숫자 값으로 새 노드 생성하고 결과 리스트에 연결\n        current = current.next  # 결과 리스트의 다음 노드로 이동\n\n        break if x.next.nil? \u0026\u0026 y.next.nil? \u0026\u0026 carry.zero?  # 두 리스트가 모두 소진되고 캐리가 남아있지 않은 경우 반복문 종료\n\n    end\n\n    current.next = ListNode.new(carry) if carry \u003e 0  # 남아 있는 캐리가 있으면 이를 위한 새 노드 생성\n    dummy.next  # 결과 리스트의 헤드 반환\nend\n\ndef to_enum(node)\n    Enumerator.new do |yielder|\n        while node\n            yielder \u003c\u003c node  # 각 노드를 반환합니다\n            node = node.next  # 다음 노드로 이동합니다\n        end\n    end\nend\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단계별 설명\n\n- 단계 1: 연결 리스트를 열거자(enumerator)로 변환하는 helper method인 to_enum을 생성합니다.\n- 단계 2: 결과 리스트의 머리 역할을 하는 더미(dummy) 노드와 결과 리스트를 구성할 현재 포인터를 초기화합니다. 그리고 carry를 0으로 초기화합니다.\n- 단계 3: 열거자 e1과 e2를 사용하여 l1과 l2를 반복(iterate)합니다.\n- 단계 4: e1과 e2에서 다음 값을 가져오려 시도합니다. 열거자가 소진된 경우 해당 값을 0으로 취급합니다.\n- 단계 5: 현재 값과 carry의 합을 계산합니다.\n- 단계 6: 합을 10으로 나누어 carry를 업데이트합니다.\n- 단계 7: sum % 10의 값으로 새 노드를 생성하고 이를 결과 리스트에 연결합니다.\n- 단계 8: 현재 포인터를 새 노드로 이동합니다.\n- 단계 9: 두 열거자가 모두 소진되고 carry가 남아있지 않은 경우 루프를 탈출합니다.\n- 단계 10: 루프를 탈출한 후 남은 carry가 있는지 확인합니다. 있다면 carry 값을 가진 새 노드를 만들고 결과 리스트에 연결합니다.\n- 단계 11: 결과 리스트의 머리를 나타내는 더미 노드의 다음을 반환합니다.\n\n## 솔루션 4: 입력 리스트의 장소를 변경하여 수정\n\n이 솔루션은 입력 리스트 중 긴 쪽의 노드를 그대로 수정하여 노드를 재사용하고 결과 리스트의 추가 노드를 생성하는 것을 피합니다. 기존 노드를 직접 업데이트함으로써 공간 사용을 최소화하고 O(1)의 상수 공간 복잡도를 달성합니다. 이 방법은 노드 포인터와 값들을 정확하게 처리하여 올바른 결과를 보장하기 위해 주의 깊은 처리가 필요합니다. 메모리 소비를 줄이면서 효율성을 유지하므로 대량의 입력 크기를 다루는 데 특히 유리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef add_two_numbers(l1, l2)\n    carry = 0  # 캐리를 0으로 초기화합니다.\n    head = l1   # l1의 헤드부터 시작합니다.\n    prev = nil  # 이전 포인터를 초기화합니다.\n\n    while l1 \u0026\u0026 l2  # 두 리스트를 모두 탐색합니다.\n        sum = l1.val + l2.val + carry  # 현재 값과 캐리의 합을 계산합니다.\n        carry = sum / 10  # 캐리를 업데이트합니다.\n        l1.val = sum % 10  # l1의 현재 노드 값을 업데이트합니다.\n        prev = l1  # 이전 포인터를 이동합니다.\n        l1 = l1.next  # l1의 다음 노드로 이동합니다.\n        l2 = l2.next  # l2의 다음 노드로 이동합니다.\n    end\n\n    if l2  # l2가 더 긴 경우, 나머지 l2를 l1에 추가합니다.\n        prev.next = l2\n        l1 = l2\n    end\n\n    while l1  # 더 긴 리스트의 나머지 부분을 처리합니다.\n        sum = l1.val + carry  # 현재 값과 캐리의 합을 계산합니다.\n        carry = sum / 10  # 캐리를 업데이트합니다.\n        l1.val = sum % 10  # 현재 노드 값을 업데이트합니다.\n        prev = l1  # 이전 포인터를 이동합니다.\n        l1 = l1.next  # 다음 노드로 이동합니다.\n    end\n\n    if carry \u003e 0  # 남은 캐리가 있는 경우, 끝에 새 노드를 추가합니다.\n        prev.next = ListNode.new(carry)\n    end\n\n    head  # 수정된 리스트의 헤드를 반환합니다.\nend\n```\n\n단계별 설명\n\n- 단계 1: 캐리를 0으로 초기화하고 l1의 시작 부분을 head로 설정합니다. 이전 노드를 추적하기 위해 prev를 사용합니다.\n- 단계 2: l1과 l2를 반복하여 각 노드 쌍에 대해:\n  - 노드 값 및 캐리의 합을 계산합니다.\n  - l1의 노드 값을 sum % 10으로 업데이트합니다.\n  - carry를 sum / 10으로 업데이트합니다.\n  - prev를 l1으로 이동한 다음 l1과 l2를 다음 노드로 이동합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 단계 3: l2가 더 긴 경우, l2의 나머지 부분을 l1에 추가하고 l1을 계속 처리합니다.\n- 단계 4: 더 긴 목록에 남아있는 노드를 계속 처리하고, 노드 값을 및 캐리를 업데이트합니다.\n- 단계 5: 모든 노드를 처리한 후에도 캐리가 남아있는 경우, 캐리 값으로 새 노드를 끝에 추가합니다.\n- 단계 6: 수정된 목록의 헤드를 반환합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough_0.png"},"coverImage":"/assets/img/2024-06-23-SolvingtheAddTwoNumbersProblemonLeetCodeRubySolutionsWalkthrough_0.png","tag":["Tech"],"readingTime":20},{"title":"Rails 7에서 Sidekiq Gem을 사용한 백그라운드 작업 처리 Part-I","description":"","date":"2024-06-23 20:52","slug":"2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I","content":"\n\u003cimg src=\"/assets/img/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I_0.png\" /\u003e\n\n레일즈 개발자로서, 백엔드 개발자들이 거의 모든 시간에 수행하는 일로 비동기적으로 백그라운드에서 실행되는 코드를 작성하는 것은 매우 흔한 작업입니다.\n\n예를 들어, 새로운 고객에게 환영 이메일을 보내거나 수천 건의 레코드를 통해 복잡한 계산을 위해 백그라운드 처리를 사용합니다.\n\n다행히도, 모든 무거운 작업을 처리하고 간단한 인터페이스를 제공하여 우리의 시간을 아낄 수 있는 도구들이 있습니다. 그 중 하나인 Sidekiq를 살펴보겠습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Sidekiq이란 무엇인가요?\n\nSidekiq은 루비 온 레일즈(Ruby on Rails) 애플리케이션을 위한 인기 있는 백그라운드 작업 처리 라이브러리입니다. Sidekiq은 주요 요청-응답 주기(main request-response cycle)에서 시간이 많이 소요되는 작업들을 간편하고 효율적으로 처리할 수 있는 방법을 제공합니다.\n\nSidekiq이 의존하는 세 가지 주요 구성 요소가 있습니다:\n\n- Redis\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSidekiq은 작업자에 의해 처리되는 작업을 저장하는 데 메모리 데이터 저장소인 Redis를 사용합니다.\n\n클라이언트\n\n백그라운드에서 처리되는 작업을 생성하는 Ruby 또는 Rails 프로세스입니다.\n\n서버\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 작업은 Redis 대기열에서 작업을 가져와 실행하는 데 책임이 있어요.\n\n너무 많은 텍스트인가요? 지금 무언가를 만들어보죠!\n\n## 전제 조건\n\n언급했듯이 Sidekiq는 백그라운드 작업을 대기열에 넣기 위해 Redis에 의존합니다. 따라서 로컬에 Redis 서버가 실행 중인지 확인해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 1\n\n새 프로젝트를 만들거나 이미 설정된 프로젝트가 있다면이 단계를 건너 뛰세요.\n\n```js\n$ rails new sidekiq_tutorial\n```\n\n# 단계 2\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트 안으로 들어오신 것을 환영합니다:\n\n```js\n$ bundle add sidekiq\n```\n\n# 단계 3\n\n이제, 새 작업을 생성하고 Sidekiq 워커로 푸시할 준비가 되었습니다. 새 작업을 생성해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n$ rails generate sidekiq:job my_first_job\n```\n\n여기에 원하는 내용을 입력하고 app/sidekiq/my_first_job.rb과 테스트 파일이 생성됩니다. 작업 파일의 내용을 다음과 같이 편집해 봅시다:\n\n```js\nclass MyFirstJob\n  include Sidekiq::Job\n\n  def perform(name,age)\n    puts \"나는 #{name}이고, 나이가 #{age}살인 첫 작업을 실행 중입니다.\"\n    #여기에는 다른 유효한 루비/레일스 코드를 넣을 수 있어요!\n  end\nend\n```\n\n여기서는 콘솔에 텍스트를 로깅하긴 하지만, 여기에서는 거의 모든 유효한 코드를 실행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 작업을 실행하기 전에 Redis가 올바르게 구성되어 있는지 확인해야 합니다.\n\n## Redis 구성\n\n이 작업을 실행하기 전에 Redis가 올바르게 구성되어 있는지 확인해야 합니다.\n\n두 가지 방법이 있습니다. 하나는 REDIS_URL 환경 변수(`dotenv-rails gem`을 사용하여)를 사용하는 방법이며, 더 복잡한 설정이 필요한 경우에는 config/initializers에 있는 sidekiq.rb 파일을 만들 수 있습니다.\n\n### .env 파일 사용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nREDIS_URL=redis://redis.example.com:7372/0\n```\n\n## config/initializers/sidekiq.rb 파일을 사용하기\n\n```js\nSidekiq.configure_server do |config|\n  config.redis = { url: 'redis://redis.example.com:7372/0' }\nend\n\nSidekiq.configure_client do |config|\n  config.redis = { url: 'redis://redis.example.com:7372/0' }\nend\n```\n\n참고: Redis와 연결하려면 위의 설정 중 하나를 사용해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 당신이 Docker에 능숙하다면, 간단한 Redis 컨테이너를 사용하여 Redis를 실행하고 Rails 앱과 연결할 수 있습니다.\n\n# 작업을 대기열에 넣기\n\nRails 콘솔에서 작업을 실행해 봅시다:\n\n```js\n$ rails c\n\n3.0.0 :001 \u003e MyFirstJob.perform_async \"Affan\", 31\n=\u003e \"5a4c435ddd2295a6104c8fcb\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업이 성공적으로 생성되었습니다.\n\n# 작업 실행하기\n\n이제 작업이 대기열에 들어 있으므로 Sidekiq 워커를 실행하여 작업을 실행해야 합니다. 다른 터미널 창을 열고 다음을 실행하세요:\n\n```js\n$ bundle exec sidekiq\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 것이 잘 작동되면 다음과 같은 내용을 볼 수 있을 거예요.\n\n![image](/assets/img/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I_1.png)\n\n작업을 마치면 ctrl+c를 사용하여 워커를 종료할 수 있어요.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 튜토리얼의 첫 번째 부분에서는 Sidekiq에 대해 어떻게 백그라운드 작업을 처리하는지, 새로운 Rails 프로젝트에서 간단한 작업을 만드는 방법에 대해 설명했습니다. 또한 Sidekiq를 Rails 앱에 연결하는 구성 옵션에 대해 알아보았습니다. 다음 이야기의 2부에서는 이 주제와 관련된 고급 내용에 대해 논의할 예정입니다 :)\n","ogImage":{"url":"/assets/img/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I_0.png"},"coverImage":"/assets/img/2024-06-23-ProcessingBackgroundJobsUsingSidekiqGeminRails7Part-I_0.png","tag":["Tech"],"readingTime":7},{"title":"튜토리얼 Windows Ruby on Rails  SQLite 시작하는 방법","description":"","date":"2024-06-23 20:51","slug":"2024-06-23-TUTORIALWindowsGetstartedwithRubyonRailsSQLite","content":"\n안녕하세요! 🙂 이 직선적인 튜토리얼에서는 루비 온 레일즈 + sqlite3 설치 방법을 안내해 드릴 거에요.\n\n## 루비 설치하기\n\n- 이 URL에서 루비 + Devkit 설치 프로그램을 다운로드하세요. 여기서는 선호하는 버전을 선택할 수 있어요. 이 튜토리얼을 작성한 날짜를 기준으로 최신 안정화 버전은 이 URL에서 사용 가능해요.\n- 설치 프로그램을 실행하세요. 모든 옵션을 선택하고 계속 다음을 눌러 설치를 진행하세요.\n- 설치가 완료되면 터미널이 열리고 MSYS2 설치에 대해 묻습니다. 그냥 Enter 키를 누르면 기본 설정으로 설치됩니다.\n- MSYS2 설치가 완료되면 다시 Enter 키를 눌러 터미널을 닫으세요.\n\n## 루비젬 설치하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- RubyGems(루비의 패키지 관리 프레임워크)를 이 URL에서 다운로드하세요(ZIP 형식 파일 받기). 이 튜토리얼 작성 시점을 기준으로, 최신 안정 버전이 이 URL에서 제공됩니다.\n- 방금 다운로드한 파일을 압축 해제하고 해당 폴더에서 터미널을 열어주세요.\n- 다음 명령어를 입력하세요: ruby setup.rb.\n- 작업이 완료되면 터미널을 닫고 다른 터미널을 열어주세요.\n\n## RAILS 설치하기\n\n- 다음 명령어를 입력하세요: gem install -V rails. 이 명령은 호환되는 최신 버전의 Rails를 설치합니다.\n- 작업이 완료되면, Rails가 설치되어 있어야 합니다. Rails 버전을 확인하려면 rails -v 명령을 실행하세요. 오류가 발생하면 설치가 올바르게 이루어지지 않았다는 것을 의미합니다.\n\n## BUNDLER 설치하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이제 'gem install -V bundler' 명령을 실행해주세요. Bundler는 필요한 정확한 젬 및 버전을 추적하고 설치하여 Ruby 프로젝트에 일관된 환경을 제공합니다.\n\n## SQLITE3 설치\n\n- 마지막 단계는 'gem install -V sqlite3'을 실행하는 것입니다.\n\n## PSYCH 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- gem install psych 명령어를 실행해주세요. --platform=ruby를 꼭 붙여주셔야 합니다.\n- 다음 단계로 넘어가시기 전에 설치가 완료될 때까지 기다려주세요.\n\n## 첫 번째 프로젝트 만들기\n\n- 첫 번째 레일즈 프로젝트를 만들려면 프로젝트를 저장할 위치로 이동하세요. 예: cd desktop.\n- NameOfProject로 레일즈 프로젝트를 생성하기 위해 rails new NameOfProject를 입력하세요. 이 명령어는 많은 파일을 생성하고 프로젝트의 종속성을 설치합니다.\n\n잘 동작하기를 바래요 :)\n","ogImage":{"url":"/assets/img/2024-06-23-TUTORIALWindowsGetstartedwithRubyonRailsSQLite_0.png"},"coverImage":"/assets/img/2024-06-23-TUTORIALWindowsGetstartedwithRubyonRailsSQLite_0.png","tag":["Tech"],"readingTime":3}],"page":"20","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"20"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>