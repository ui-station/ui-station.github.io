<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/26" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/26" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유" href="/post/2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까" href="/post/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로그래밍 언어를 만드는 단계별 가이드" href="/post/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로그래밍 언어를 만드는 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로그래밍 언어를 만드는 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">프로그래밍 언어를 만드는 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">32<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="성공적인 관리자들이 실천하는 6가지 미세 습관" href="/post/2024-06-22-6MicroHabitsofHighlyEffectiveManagers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="성공적인 관리자들이 실천하는 6가지 미세 습관" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-6MicroHabitsofHighlyEffectiveManagers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="성공적인 관리자들이 실천하는 6가지 미세 습관" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">성공적인 관리자들이 실천하는 6가지 미세 습관</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" Mac OS에서 React Native를 사용한 Android 개발 환경 설정 방법" href="/post/2024-06-22-HowToSetUpYourAndroidDevelopmentEnvironmentReactNativeMacOS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" Mac OS에서 React Native를 사용한 Android 개발 환경 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowToSetUpYourAndroidDevelopmentEnvironmentReactNativeMacOS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" Mac OS에서 React Native를 사용한 Android 개발 환경 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl"> Mac OS에서 React Native를 사용한 Android 개발 환경 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter DropdownButtonFormField에서 텍스트 넘침 방지하는 방법" href="/post/2024-06-22-PreventingTextOverflowinFluttersDropdownButtonFormField"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter DropdownButtonFormField에서 텍스트 넘침 방지하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-PreventingTextOverflowinFluttersDropdownButtonFormField_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter DropdownButtonFormField에서 텍스트 넘침 방지하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Flutter DropdownButtonFormField에서 텍스트 넘침 방지하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React Query  React Native 완벽한 협업 이야기" href="/post/2024-06-22-ReactQueryReactNativeALoveStoryatFound"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React Query  React Native 완벽한 협업 이야기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ReactQueryReactNativeALoveStoryatFound_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React Query  React Native 완벽한 협업 이야기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">React Query  React Native 완벽한 협업 이야기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter에서 No MediaQuery widget found 오류 해결 방법" href="/post/2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter에서 No MediaQuery widget found 오류 해결 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter에서 No MediaQuery widget found 오류 해결 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Flutter에서 No MediaQuery widget found 오류 해결 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기" href="/post/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="RxSwift 심층 탐구 메커니즘 분석" href="/post/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="RxSwift 심층 탐구 메커니즘 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="RxSwift 심층 탐구 메커니즘 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">RxSwift 심층 탐구 메커니즘 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link posts_-active__YVJEi" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유","description":"","date":"2024-06-22 23:39","slug":"2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware","content":"\n대규모 팀 개발에 대해 이야기할 때, 또는 더 정확히 말하면 여러 팀이 공통 목표를 향해 협력해야 하는 프로젝트에서는 무엇이 잘 되고 무엇이 잘 안 되는지의 역학이 빠르게 변합니다. 10명 또는 심지어 20명의 팀에 효과적인 것이 100명 이상의 팀에는 효과적이지 않을 가능성이 있음을 분명히 알 수 있습니다. 더 작은 팀으로 나누어져 있더라도 의존성과 과정이 강력하다면, 그들은 사실상 훨씬 큰 가상 팀이 되어버립니다 (이에 대해 이전에 기사에서 논의했습니다).\n\n본 기사에서는 많은 주제를 다룰 수 있지만, 확장이 큰 문제이기에 한 가지 개념에 초점을 맞출 것입니다. 그리고 이 개념은 도시 계획 단체인 '강한 도시'의 배움을 통해 더 잘 이해될 수 있습니다. 내 직관과 소프트웨어 공학 매뉴얼에 설명되어 있음에도 불구하고, 강한 도시가 등장하기 전까지는 완전히 이해하고 모델링하지 못했습니다. 그리고 이제 여러분과 이 배움을 공유하고 싶습니다, 여러분도 그 혜택을 받을 수 있도록요.\n\n놀라우신가요? 도시와 도시 계획을 개선하기 위해 전념하는 단체의 연구가 소프트웨어 개발로 전달할 수 있는 의미 있는 통찰과 모델을 제공할 수 있는가요? 그러나 이것을 생각해 보면, 그리 놀랄 일은 아닙니다, 맞죠? 더 구체적이고 일상적인 것들에서 비유를 사용하여 더 추상적이고 개념적인 측면을 이해하고(모델링)하는 데 도움이 되기 때문입니다. 예를 들어 전기를 물로 생각하는 것은 많은 속성을 이해하는 데 도움이 됩니다(물론 모든 것을 이해하는 데 도움이 되는 것은 아닙니다).\n\n그래서, 강한 도시에서 어떤 개념이 내가 대개 큰 팀들이 잘못 관리되는 것을 다시 생각하게 했을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘, 나는 Charles Marohn(강력한 도시의 대통령이자 설립자)이 계획된 도시 발전의 문제에 대해 이야기하는 것을 많은 시간동안 듣고 있었어. 그리고 이번에는 한 가지 개념이 나에게 더 깊게 와닿았고, 소프트웨어 엔지니어링 세계와도 직접적인 관련성을 느꼈어.\n\n그의 말씀은 다음과 같았어:\n\n내가 무엇을 깨달았는지 생각해볼 수 있겠니?\n\n큰 팀을 위한 아키텍트의 역할을 생각해볼 때, 많은 사람들을 모아 팀을 조직하는 역할에 대해 고려해봤을 때, 보통의 접근 방식은 종종 동질화하는 것이야. '모두가 같은 도구를 사용한다면, 우리는 지식과 해결책을 널리 활용할 수 있겠지'라는 생각이야. 나도 오랫동안 이것을 믿었어. 나는 이것을 정말 놀랍게 여기기도 했고, 솔직히 말해서 그 당시에는 미니프론트엔드나 미니프레임워크 같은 방법론이 각 팀이 자신에 맞는 프레임워크나 라이브러리, 데이터베이스 등을 선택할 수 있다고 가정한 것을 비웃기도 했어. 나에게는 이것이 순수한 혼돈과 재앙의 레시피로 느껴졌지.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음 경험이 찾아왔어요. 종이 위에서 잘 작동해야 했던 모든 것이 예상대로 되지 않았음을 관찰했습니다. 간단해 보이는 작은 변화도 대규모이며, 느리고 모든 팀 또는 모든 팀이 참여해야 하는 프로젝트로 변모했으며, 수개월 또는 몇 년이 걸렸습니다. 모든 것이 바람을 맞서 있었어요.\n\n이를 보며, 마이크로프론트엔드 또는 마이크로프레임워크(기본적으로 DDD, 도메인 주도 설계)로부터의 모든 가르침들을 감사히 여기기 시작했습니다. 그러나 뭔가가 부족했어요 — 일어나고 있는 일의 모델을 내면화하는 능력이죠. 물의 비유를 이해함으로써 전기를 이해하는 데 도움이 되었던 것과 마찬가지로, 이 한 부분은 'Strong Towns'의 단편이 프로젝트를 이해하는 데 어떻게 재앙이 될 수 있는지 명확히 보여줬어요.\n\n제가 이전에 언급한 인용구를 고려해 보면 이해하기 쉬워요. '모든 집이 같은 방식으로 지어진다'라고 이야기 합니다. 이제 이를 소프트웨어 개발에 확장해 보아요. 프로젝트의 프론트엔드 프레임워크로 Angular 18(당시의 최신 버전)이어야 한다고 결정한 경우를 상상해 보세요. 그러면 모든 팀이 이것과 함께 작업하게 됩니다. 그러나 인용문이 어떻게 이어지는가요? '모든 지붕이 동시에 고장날 것이다.' 소프트웨어에서도 동일한 일이 벌어질 것입니다. 언젠가 '와, Angular 18은 이제 너무 오래됐네요. Angular 26로 업데이트해야 할 필요가 있어요.' 라는 말을 할 수가 있잖아요. 이게 무슨 의미인가요? 개발을 중단하고 모든 팀을 이전시키고, 모두에게 동일한 업그레이드라고 생각해도 사실은 그렇지 않을 것입니다. 각 팀은 다양한 문제를 마주하며 다른 단계가 필요할 것이고, 누군가는 쉽게 해결하겠지만, 누군가는 매우 어려워할 것입니다. 이는 거대한 결정이 됩니다. 모든 팀에 통일된 것을 변경하는 비용은 행한 어떤 결정에도 적용되며, 표준 라이브러리, 패턴, 아키텍처, 데이터베이스, 환경 등을 포함합니다. 모든 변경에는 엄청난 비용이 발생할 것입니다. 우리는 엄청난 가격을 지불하거나 낡은 기술로 고정된 취약한 해결책에 얽매이는 선택을 해야할 것입니다 — 마치 팟캐스트가 설명한 것처럼, 모든 집이 동시에 악화되기 시작하고 동네가 저하되며 가치를 잃는 20년 이상이 지난 후에 어떻게 될 것인지 생각해 보세요. 궁극적으로, 우리는 갇히게 될 것입니다.\n\n해결책은 무엇일까요? 팟캐스트에서 설명한 것은?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'해결책'은 끝 부분에 나옵니다. 이는 스트롱 타운즈(Strong Towns)의 철학을 반영하고 있습니다: 점진적 적응. 큰 변화를 만들지 말고, 대신 작은 개선에 집중해보세요. 한꺼번에 100채의 집을 짓지 말고 2채를 개조하고, 또 다른 것을 개조하고, 이런 식으로 진행하세요. 고대부터 도시가 가지고 있던 유기적 발전을 이어갔으면 좋겠고, 현재 멋을 준 계획을 피하면서 떨어진 모양을 피해야 합니다.\n\n소프트웨어 개발로 번역하면 DDD 방법론, 마이크로서비스 및 마이크로프론트엔드의 권고 사항과 일치합니다. 각 팀이 자신의 필요에 따라 선택하고 발전할 수 있게 놔두세요. 그렇다고 모든 팀을 이리저리 옮기기 어렵고, 더 많은 스택을 모니터링해야 할 것입니다. 하지만 더 민첩해질 것입니다. 팀이 라이브러리를 적응해야 할 때, 다른 팀들을 중단시키지 않고 그 작업을 수행할 수 있습니다. 점진적으로 전체 응용프로그램 및 모든 팀을 업데이트할 수 있습니다. 모두 한꺼번에 하는 것이 아니라 스트롱 타운즈가 제안하는 대로 유기적으로 진행될 것입니다. 라이브러리에 심각한 문제가 발생하여 모든 개발을 급작스럽게 중단할 수 있는 대규모 실패는 발생하지 않을 것이며, 대신 모든 것이 더 적응 가능해질 것입니다. 그리고 민첩해질 것입니다.\n\n사실 이와 연결하여 한때 막혀있거나 실패한 소프트웨어를 구하는데 관한 안내서를 작성해보았습니다. 이것도 동일한 아이디어를 기반으로 하고 있습니다. 모든 것을 새롭게 다시 하는 것은 필요하지 않습니다. 그냥 매일 최상의 조건에서 작업하도록 노력하고, 가장 생산적인 환경에서 작업하며, 손대지 않아도 되고 잘 작동하는 코드를 그대로 두세요.\n\n재미있지 않나요? 스트롱 타운즈의 철학과 애자일(Agile)이 얼마나 유사한지? 그러나 생각해보면 그리 놀랍지는 않을 것입니다. 스트롱 타운즈는 사람들이 함께(도시적으로) 진보하고 발전하는 방법에 중점을 둡니다. 이를 효율적으로 수행하는 방법은 반복적이고, 작은 단계로 진행하면서 배우는 것입니다. 사물을 유기적으로 발전하게 해서 이미 작동 중인 구조를 활용하고, 더 나은 결과를 위해 그 위에 쌓는 것입니다. 본질적으로 이것이 과학적 방법의 기초이며, 이것이 리안 제조 및 애자일 정신을 지지하는 바탕이기도 합니다. 그럼, 어째서 오리브 캔의 물류에 대한 이야기를 들을 때, 팀의 효율성을 10배로 향상시킬 방법을 찾게 될지 모르겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n읽어 주셔서 감사합니다. 일반적으로 소프트웨어 엔지니어링을 어떻게 이해하고 적용하는지 고민하며 이를 통해 우리가 어떻게 개선할 수 있는지에 대해 이야기하는 것을 좋아합니다. 이 글이 마음에 드셨다면 박수를 치거나 댓글을 남겨주세요. 더 많은 통찰력과 토론을 위해 제가 Medium에 올린 가장 성공적인 이야기들을 살펴보세요.\n","ogImage":{"url":"/assets/img/2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware_0.png"},"coverImage":"/assets/img/2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware_0.png","tag":["Tech"],"readingTime":5},{"title":"Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까","description":"","date":"2024-06-22 23:37","slug":"2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday","content":"\n## 원격 외부 서비스 (RSS)\n\n# 목차\n\n- Uber의 Apache Spark\n- 원래의 셔플\n- MapReduce에 대한 새로운 생각\n- RSS 아키텍처\n\n# TL;DR\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스파크 셔플 데이터의 대규모 규모는 Uber에 약간의 문제를 일으킵니다. 이에 대응하여 Uber는 원격 셔플 서비스(RSS)를 사용하여 셔플 데이터를 원격으로 관리하기로 결정했습니다. RSS의 주요 아이디어는 스파크 실행자가 맵 작업에서 셔플 데이터를 원격 서버로 보내도록 한 다음 리듀서가 거기서 데이터를 가져오도록하는 것입니다. 게다가, Uber는 솔루션을 더 효율적으로 만들기 위해 원본 MapReduce 패러다임을 역전시켰습니다.\n\n# 소개\n\n내 글 쓰기 역사를 돌이켜보면, 내 첫 블로그는 BigQuery가 셔플 작업을 처리하는 방법에 대한 기사입니다. 그 블로그에서는 Google이 Dremel의 셔플 도전 과제를 해결하기 위해 전용 인메모리 셔플 서버를 구축할 때 사용한 흥미로운 접근 방식에 대한 메모를 공유했습니다. Dremel 맵 워커가 로컬 디스크에 셔플 레코드를 쓰는 대신 결과를 원격 서버에 쓰고 리듀스 워커가 데이터를 가져오도록 했습니다. Google은 이 방법이 셔플 스케일링 도전 과제에 대응하는 데 도움이 되었다고 말했지만, 원격 셔플 솔루션의 세부 사항에 대해서는 자세히 설명하지 않았습니다.\n\nDremel의 셔플 작업이 Google에 문제를 일으키는 요소 중 하나는 처리해야 하는 데이터의 거대한 양입니다. 이로 인해 나는 궁금해졌습니다: \"셔플 작업에서 문제를 일으키는 거대한 규모의 데이터를 처리해야하는 다른 기업이 있는가?\". 조사한 결과, Uber가 Dremel과 같은 문제를 겪고 있는 Spark에 문제가 있다는 것을 발견했습니다. Uber의 글에는 Spark 셔플 작업을 처리하기 위해 전용 서버를 개발했다는 내용이 있습니다. 다행이도 글은 솔루션이 어떻게 동작하는지에 대한 내용을 자세히 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 주의 글은 우버(UBER)에서 공개한 훌륭한 블로그 게시물을 읽은 후에 작성한 제 노트입니다: 높은 확장성과 분산 셔플 서비스.\n\n## 우버(Uber)에서의 아파치 스파크\n\n스파크는 우버(Uber)의 주요 컴퓨팅 엔진으로, 라이드, 우버 이츠(Uber Eats) 또는 지도와 같은 운영을 지원합니다. 데이터 웨어하우징, 데이터 과학, 그리고 AI/ML에 있어서 필수적입니다. 우버의 스파크 사용량은 기하급수적으로 증가했으며, 하루에 수 백 페타바이트의 데이터를 처리하는 10,000대 이상의 프로덕션 노드에서 실행됩니다. 현재 스파크 작업은 분석 클러스터 계산 자원의 95% 이상을 사용하고 있습니다. 우버의 규모에 맞게 스파크를 운영하는 것은 데이터 이동과 관련된 도전에 직면하며, 특히 잘 알려진 셔플이라고 불리는 작업 단계 간 데이터 전송에 있어서 중요한 문제가 있습니다. 다음 섹션에서는 우버에게 중요한 원래의 스파크 셔플과 그것이 가지는 중요한 도전에 대해 알아보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_0.png)\n\n과거의 Spark 셔플러에는 두 가지 종류의 작업이 있었습니다: 맵과 리듀스. 첫 번째는 셔플 데이터를 생성하고, 후자는 이를 사용합니다. Spark에서 작업 교환은 풀 모델을 사용하여 데이터를 섞습니다. 맵 작업은 셔플 데이터를 로컬 디스크에 작성합니다. 그런 다음 리듀스 작업은 여러 맵 작업에게 해당 데이터를 가져오기 위해 연결합니다.\n\n## 셔플 쓰기\n\n![이미지](/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우버의 초기 Spark 셔플 구현은 맵 작업이 셔플 데이터를 실행자의 로컬 디스크에 쓸 수 있게 했습니다. 먼저 데이터를 메모리 버퍼에 씁니다. 버퍼가 가득 차면 데이터를 임시 파일로 디스크에 흘립니다. 나중에 모든 흘림 파일을 최종 셔플 파일로 병합합니다. 우버는 이 프로세스가 최적화되지 않았음을 깨달았습니다. 많은 경우에, 장애 파일에서 여러 디스크 작업(읽기 및 쓰기)을 수행해야 하여 지연을 초래합니다.\n\n## 셔플 읽기\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*f9fRJZZBKeHhtBtZsVFTyw.gif)\n\n맵 호스트에서는 여러 파티션에서 많은 데이터 파일이 오는데, 호스트는 또한 각 파일이 어느 파티션에 속하는지 추적하기 위해 파티션 오프셋을 유지하는 인덱스 파일을 유지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nreduce 작업은 각 맵퍼 호스트에서 실행 중인 셔플 서비스와 통신하여 해당 호스트에서 셔플 파티션 출력을 가져옵니다. 셔플 서비스가 요청을 받으면 인덱스 파일에서 오프셋을 읽고 reduce 작업에 필요한 데이터를 찾아 반환합니다. 그 후에 reduce 작업은 데이터를 메모리 버퍼로 가져와서 리듀서 프로세스에서 사용할 이터레이터를 생성합니다. 이 과정은 비효율적입니다. 왜냐하면 리듀서가 파티션 데이터를 가져오기 위해 많은 맵퍼 호스트에 요청해야 하며, 이로 인해 네트워크 오버헤드가 발생하고 맵퍼 호스트가 많은 디스크 작업을 수행해야 합니다.\n\n## 도전과제\n\nUber가 대규모로 Spark 셔플을 운영할 때 여러 도전 과제가 있었습니다:\n\n- 하드웨어 신뢰성: 매일 SSD에 쓰이는 대량의 셔플 데이터로 인해 초기 설계에서 예상한 것보다 더 빨리 Uber 디스크가 소모됩니다. 3년간 유지될 것으로 예상되었던 디스크는 대신 6개월 만에 소모됩니다.\n- 셔플 실패: 리듀서가 동일한 기계에서 모든 맵퍼 작업의 데이터를 가져올 때, 서비스가 사용 불가능해지며, 이로 인해 많은 셔플 실패가 발생합니다.\n- 노이즈 이슈: 더 많은 셔플 데이터를 작성하는 응용 프로그램은 해당 기계의 디스크 공간을 모두 차지하여 다른 응용 프로그램이 디스크가 가득 찼다는 예외로 실패할 수 있습니다.\n- 셔플 서비스 신뢰성 문제: Uber는 Spark에서 YARN 및 Mesos를 사용하여 외부 셔플 서비스를 사용합니다. 그들은 종종 일련의 노드에서 셔플 서비스를 사용할 수 없다는 경험을 가졌습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Uber가 문제를 해결하기 위한 노력\n\nUber는 지역 데이터 저장이 위에서 언급한 문제의 근본 원인 중 하나라는 것을 깨달은 후, 원격 기기에 셔플 데이터를 저장하는 여러 가지 접근 방식을 시도해 보았습니다:\n\n- 다른 저장소 플러그인 사용: Uber는 Spark를 위한 셔플 관리자를 작성하여 다양한 저장소 플러그인을 지원하도록 하고, 셔플 파일을 HDFS 또는 NFS에 쓸 수 있는 플러그인을 개발했습니다. 그러나 테스트 결과, Spark 작업의 실행 시간이 2배에서 5배 증가했습니다.\n- 스트리밍 쓰기: Uber는 Spark 실행기로부터 스트림을 수락할 수 있는 스트리밍 서버를 구축했습니다. 이들은 이러한 스트림의 싱크 대상으로 HDFS 및 로컬 저장소를 사용했지만, 작업 지연이 1.5배에서 3배 증가했습니다.\n\n# MapReduce에 대한 새로운 접근 방식\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 번의 실험 끝에 Uber는 매퍼에서 원격 서버로 스트리밍 쓰기를 통해 문제를 해결할 수 있다는 것을 발견했습니다. 그러나 이 방식의 성능은 현재 지역 머신 성능(맵 태스크가 데이터를 로컬 디스크에 쓰는 곳)과 비교할 수 없다고 합니다. 따라서 Uber는 원격 쓰기를 위해 맵-리듀스 패러다임을 역전시켰습니다.\n\n처음에 맵 태스크는 데이터를 로컬 머신에 기록하고, 그 후 리듀스 태스크가 단일 파티션의 데이터를 얻기 위해 여러 매퍼 머신에 도달하였습니다. 이렇게 함으로써 리듀서는 각 맵 머신으로 이동하여 데이터를 가져오고 이를 최종적으로 병합하여 리듀스 프로세스를 수행하는 데 많은 시간이 소요되었습니다.\n\nApache Spark를 위해 Remote Shuffle Service(RSS)를 구현하기 위해, 매퍼는 셔플 데이터를 원격 서버로 써야 합니다. Uber는 매퍼가 동일 파티션의 데이터를 고유한 RSS 서버로 쓰도록 지정하여, 리듀서가 하나의 RSS 서버에서만 데이터를 가져오도록 했습니다. 이를 통해 Uber는 이제 리듀서가 여러 매퍼에 통신할 필요가 없어져서 원격 셔플 서버에서의 Spark 작업 지연을 완화할 수 있었습니다.\n\n# RSS 아키텍처\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![RSS architecture](https://miro.medium.com/v2/resize:fit:1400/1*SthOAIxcxzMl_pM5yqVdlw.gif)\n\n다음은 RSS의 전반적인 아키텍처입니다:\n\n- RSS에서 모든 Spark executor들은 서비스 레지스트리와 RSS 서버와 통신하기 위해 클라이언트를 사용합니다.\n- 초기에 Spark 드라이버는 Zookeeper를 활용하여 동일한 파티션에 대한 고유한 RSS 서버 인스턴스를 식별합니다.\n- 드라이버는 이 정보를 모든 매퍼와 리듀서에게 전달합니다.\n- 매퍼와 리듀서는 이 정보를 사용하여 셔플 데이터 프로세스를 처리합니다.\n\n## RSS 클라이언트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRSS는 클라이언트 측 jar 파일을 가지고 있으며 Apache Spark가 제공하는 Shuffle Manager 인터페이스를 구현합니다. 드라이버는 서비스 레지스트리를 쿼리하여 Shuffle을 처리할 RSS 서버 목록을 선택합니다. 그런 다음 드라이버는 이 메타데이터를 Shuffle 핸들 내에 인코딩합니다. Spark 머신은 Shuffle 핸들(다른 인터페이스)을 맵-리듀스 작업에 전달할 것입니다.\n\n위에서 언급한대로, 모든 매퍼는 특정 파티션의 Shuffle 데이터를 단일 RSS 서버로 보냅니다. 따라서 리듀서는 특정 파티션의 Shuffle 데이터를 읽기 위해 단일 RSS 서버에 연결하기만 하면 됩니다.\n\nRSS 클라이언트는 Shuffle 데이터의 복제 팩터를 여러 RSS 서버에 지정할 수도 있습니다. 매퍼는 단일 서버에 기록하는 대신, 서버 다운에 대한 내고장성을 추가하기 위해 두 개 이상의 서버로 데이터를 기록할 것입니다.\n\n전체 클라이언트는 Shuffle Manager 인터페이스에서 구현되므로 Spark 코드베이스에는 코드 변경이 없습니다. Spark 작업 관점에서는 모든 것이 같지만, 매퍼가 이제 로컬 디스크에 쓰기 대신 Shuffle 데이터를 RSS 서버로 보내야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 서비스 레지스트리\n\nRSS에서 서비스 레지스트리는 사용 가능한 RSS 서버 목록을 유지합니다. Uber는 서비스 레지스트리로 Zookeeper를 사용합니다. 각 RSS 서버는 주기적으로 상태를 업데이트하기 위해 ZooKeeper와 장시간 연결을 유지합니다. 셔플 등록 중에 Spark 드라이버는 Zookeeper에서 모든 사용 가능한 RSS 서버 목록을 검색합니다. 그런 다음 드라이버는 지연 시간, 셔플 파티션, 활성 연결 등 여러 요소를 기반으로 서버를 선택합니다. 이 프로세스를 마치면 드라이버는 사용 가능한 서버 목록을 셔플 핸들 내의 매퍼 및 리듀서에 전달합니다.\n\n이 접근 방식은 각 RSS 인스턴스가 자체를 서비스 레지스트리에 등록해야 한다는 것을 필요로 합니다. 인스턴스는 실패하고 서비스 레지스트리에 연결을 잃으면 자동으로 등록 해제됩니다. 익스큐터는 사용 가능한 인스턴스 및 데이터 셔플 위치에 대한 정보를 얻기 위해 서비스 레지스트리와 통신합니다.\n\n## 셔플 매니저\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**Shuffle Manager** in RSS는 Spark의 셔플 관리자 인터페이스를 구현하는 구성 요소입니다. 이는 원격 셔플 서비스 인스턴스를 선택하고 추적하여 (매퍼) 데이터를 업로드하고 (리듀서) 다운로드하기 위한 책임을 가지고 있습니다.\n\n## RSS 서버\n\n![RSS Server](/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_2.png)\n\n각 매퍼는 셔플 데이터를 고유한 RSS 서버에 작성합니다. 클라이언트로부터 복제된 설정이 있는 경우 데이터는 내결함성을 위해 하나 이상의 서버에 작성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n셔플 데이터 스트림은 각 레코드가 파티션 ID와 실제 데이터를 가지고 있는 셔플 레코드의 시퀀스입니다. RSS 서버가 매퍼로부터 셔플 레코드를 받으면, 해당 파티션 ID를 기반으로 로컬 파일을 선택하고 레코드를 파일 끝에 추가합니다.\n\nRSS 서버에서는 미접근된 셔플 데이터를 주기적으로 확인하고 36시간 이내에 접근되지 않은 데이터를 삭제하는 정리 스레드가 실행됩니다. Uber는 RSS 서버 당 동시 연결 수를 제한하여 RSS 서버가 과중되지 않도록 합니다.\n\n# 고장 허용\n\n- RSS 서버가 바쁠 때: 클라이언트가 RSS 서버에 도달하지 못할 경우, 서버에 부담을 주지 않도록 지수 함수적 백오프 재시도를 수행합니다.\n- RSS 서버 다시 시작: 서버는 로컬 디스크로 셔플 데이터 파일을 읽어 다시 시작한 후 이전 상태를 복구합니다. 이러한 상황에서 맵 태스크가 실패하면 Spark 애플리케이션이 새로운 태스크 시도 ID로 이러한 실패한 태스크를 재시도합니다. RSS 서버는 파일에 저장된 각 셔플 레코드의 시도된 태스크를 유지합니다. 서버는 최종으로 성공한 태스크 시도 ID만 저장합니다. 리듀서는 마지막으로 성공한 시도가 있는 셔플 레코드만 수락합니다.\n- 서버 다운: RSS 서버를 사용할 수 없는 경우 복제는 유용합니다. 셔플 데이터는 하나 이상의 RSS 서버에서 제공될 수 있습니다. 이러한 상황에서 필요하면 Spark 드라이버가 영향을 받는 매퍼/리듀서 스테이지를 다시 예약합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 하드웨어 신뢰성\n\n거의 10 PB의 디스크 쓰기를 원격 서버로 오프로딩하여 최적화된 I/O-하드웨어로, RSS를 사용하여 SSD의 내구 시간을 3개월에서 36개월로 연장된다. 원래의 셔플 구현에 있어 3개월의 수명주기를 갖고 있던 SSD 디스크는 이제 RSS 서버를 도입한 이후 거의 3년 동안 사용할 수 있다.\n\n# 애플리케이션 신뢰성\n\n운영 환경에 RSS를 배포한 후, Spark 작업의 실패율이 크게 감소했다; 셔플 실패로 인한 실패율은 거의 95%로 줄었다. 또한, RSS 서버가 다운되는 경우를 대비해 장애 허용 기능을 추가함으로써 Uber는 99.99% 이상의 신뢰성을 달성했다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 확장성\n\n현재 우버의 RSS는 하루에 약 220k 개의 애플리케이션을 처리하며, 약 80k 번의 셔플 및 일일 10 PB의 데이터를 처리합니다. 하나의 셔플마다 약 40 TB의 데이터를 처리하는 프로덕션 작업을 갖고 있습니다. RSS는 셔플 프로세스에 더 많은 RSS 서버를 참여시킴으로써 이러한 대규모 셔플을 쉽게 처리할 수 있습니다. 이는 스파크의 기본 외부 셔플에서는 불가능했으며, 각 기계의 디스크 크기에 의해 제한되었으며, 일반적으로 1 TB SSD를 사용했습니다.\n\n# 마무리\n\n이 기사를 통해 우버 블로그 게시물에서 얻은 주요 통찰을 문서화했습니다. 스파크의 원래 셔플 작업의 도전과제를 논의한 뒤 우버가 원격 셔플 서비스를 도입함으로써 이를 극복한 방법을 살펴보았습니다. 셔플 데이터의 원격 쓰기 및 읽기로의 전환은 네트워크를 통해 이제 이러한 작업을 수행해야 하므로 추가된 대기 시간의 가능성을 도입합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만, 이 변경 역시 상당한 혜택을 가져다줍니다. 예를 들어, 줄어든 worker는 이제 입력 데이터를 읽기 위해 여러 map worker와의 통신이 필요 없어졌으며, 하나의 서버에서만 데이터를 읽으면 됩니다. 셔플된 데이터를 로컬 디스크로 이동하는 것은 Uber에게 다양한 엔지니어링 기회를 제공합니다. 예를 들어, map worker에 장애가 발생하더라도, 데이터가 RSS 서버에 원격으로 저장되어 있기 때문에 처리된 데이터에는 영향을 주지 않습니다.\n\n이번 주는 여기까지 입니다. 읽어 주셔서 감사합니다.\n\n다음 주에 뵙겠습니다.\n\n# 참고문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해 드릴게요.\n","ogImage":{"url":"/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_0.png"},"coverImage":"/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_0.png","tag":["Tech"],"readingTime":13},{"title":"프로그래밍 언어를 만드는 단계별 가이드","description":"","date":"2024-06-22 23:34","slug":"2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage","content":"\n## 몇 시간 안에 처음부터 프로그래밍 언어 구축하기\n\n![이미지](/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_0.png)\n\n세상에는 다양한 용도로 만들어진 프로그래밍 언어가 가득합니다. 이러한 언어 중 대다수는 매우 일반적인 목적을 위해 만들어졌지만 때로는 매우 특정한 용도에 맞는 언어를 설계하기를 원할 수 있습니다(예: Facebook은 React를 개발하여 웹 응용 프로그램을 보다 쉽게 개발하기 위해 설계했고, Apple은 최근 Pkl이라는 언어를 개발하여 구성을 보다 쉽게 만들었습니다. 다양한 분야에서 이와 같은 예가 많이 있습니다). 따라서 프로그래밍 언어를 구축하는 방법을 알고 있는 것은 가지고 있는 것이 유용한 기술입니다.\n\n이 문서에서는 처음부터 해석형 프로그래밍 언어를 만들고 람다 대수와 프로그래밍 언어 전반에 대해 알아가는 과정을 조금 배웁니다. 여기서 만들어볼 언어는 꽤 독특할 수 있지만, 이 과정을 통해 당신이 자신만의 특정 용도 언어를 설계하는 방법과 프로그래밍 언어가 어떻게 작동하는지에 대해 유용한 정보를 가르칠 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 게임 계획\n\n저희는 해석형 언어¹을 개발 중이니, 우리의 전반적인 흐름은 다음과 같을 것입니다:\n\n![프로젝트 이미지](/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_1.png)\n\n기본적으로, 우리는 우리가 작성하려는 대상 언어로 된 몇 가지 구체적인 구문(코드)으로 시작하고, 이를 추상 구문 트리로 변환하는 구문 분석기에 전달합니다(이것은 작업하기 쉬운 코드의 트리 표현입니다). 그 후에 실행된 추상 구문 트리를 우리에게 최종 결과를 제공하는 해석기에 전달합니다. 구문 분석기와 해석기는 이미 존재하는 호스트 언어로 작성됩니다 — 예를 들어 C 언어의 초기 구문 분석기와 컴파일러는 어셈블리어로 작성되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\\*\\*참고: 여기서 사용하는 \"파서\"는 파싱 프로세스 전체를 포괄합니다. 일반적으로 렉싱은 \"파싱\" 이전에 수행됩니다. 그러나 이 경우 파싱은 구체적인 구문을 추상 구문으로 변환하는 프로세스입니다. 이 프로세스에는 다양한 형태가 있을 수 있습니다.\n\n예를 들어, 기본 산술 연산을 위한 간단한 언어에 대한 다음 명세를 고려해보십시오:\n\n```js\nEXPR =\n  number | (EXPR + EXPR) | (EXPR - EXPR) | (EXPR * EXPR) | (EXPR / EXPR) | EXPR;\n```\n\n위의 내용은 컨텍스트-프리 문법에 대한 EBNF입니다. 여기서 깊이 들어가진 않겠지만, 이 형태의 프로그래밍 언어는 모두 CYK 알고리즘을 통해 다항 시간 내에 파싱할 수 있습니다. 이 EBNF에서 (4 + 4) \\* 3과 같은 것은 유효한 프로그램이지만, def f(x): return 5; f(5)와 같은 것은 유효하지 않습니다.\\*\\*\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 우리가 구체적인 구문 (4 + 4) \\* 3을 주어졌다고 가정해 봅시다. 파싱 후에는 다음과 같은 추상 구문 트리(AST)를 얻어야 합니다:\n\n![AST](/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_2.png)\n\n그런 다음 우리의 해석기는 루트에서 시작하여 트리를 재귀적으로 타고 내려가면서 답인 24를 얻습니다.\n\n이 문법이 모호한 점에 대한 간단한 언급을 해보면 — 예를 들어, 표현식 4 + 4 _ 3은 어떻게 파싱되어야 할까요? 이것은 위에 언급된 ((4 + 4) _ 3)로 파싱되거나, 4 + (4 \\* 3)로 파싱될 수 있습니다 — 이 둘 다 유효한 파싱 트리이기 때문에 더 이상 “정확한” 파싱이라고 말할 수 없습니다. 이와 같은 경우에는 파서가 언어를 파싱하는 방법에 대해 임의로 결정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 저희 구문 설계하기\n\n플로 차트에 따르면, 첫 번째 단계로 저희는 구체적인 구문을 설계해야 합니다. 구문을 만드는 방법은 완전히 당신에게 달려 있어요. 저는 EmojiLang이라는 (형편없는) 언어를 만들기로 결정했어요. 이 언어는 당신이 타이핑할 때 매우 다채로운 화면을 보장합니다. 문법은 아래와 같아요:\n\n```js\ngrammar EmojiLang;\n\nprogram: '🏃‍♂️🏃‍♂️🏃‍♂️' expr '🛑🛑🛑' EOF;\n\nexpr: '(' (ID\n         | atom\n         | ifCond\n         | anonFunctionDefn\n         | funApplication\n         | varAssignment\n         | READ_FLOAT\n         | READ_STRING\n         | printExpr\n         | sequentialOp\n         | baseComputation) ')';\n\natom: NUMBER | BOOLEAN | STRING;\nifCond: '🤔' cond=expr '❓' ontrue=expr ':' onfalse=expr;\nanonFunctionDefn: '🧑‍🏭' arg=ID '⚒️' body=expr;\nfunApplication: '🏭' fun=expr arg=expr;\nvarAssignment: '📦' var=ID '🔜' val=expr;\nprintExpr: '🖨️' expr;\nsequentialOp: '📋' first=expr second=expr;\nbaseComputation: left=expr op=('➕' | '➖' | '✖️' | '➗' | '🟰' | '≤') right=expr;\n\n\nID: [a-zA-Z_][a-zA-Z0-9_]*;\nNUMBER: [0-9]+ ('.' [0-9]+)?;\nBOOLEAN: '👍' | '👎';\nSTRING: '\"' ~[\\r\\n\"]* '\"';\nREAD_FLOAT: '🔢';\nREAD_STRING: '🔤';\n\n\nWHITESPACE: [ \\t\\r\\n]+ -\u003e skip;\nCOMMENT: '😴' .*? '⏰' -\u003e skip;\nLINE_COMMENT: '🥱' ~[\\r\\n]* -\u003e skip;\n```\n\n\\*\\* 참고: 위 명세서는 ANTLR이라는 도구에서 사용되도록 작성되었으며, 곧 다시 이에 대해 다룰 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론 언어 자체가 우스꽝스러워 보이지만 몇 가지 이유로 흥미로운 점들이 있어요. 우선, 모든 표현은 괄호로 둘러싸야 하는 것이 필수적이에요. 이렇게 하니 코드 작성이 매우 귀찮지만, 문법이 모호하지 않다는 장점이 있어요. 둘째로, 익명 함수만 정의할 수 있다는 점을 주목해봐요 — 파이썬의 def와 같은 구문이 없어요. 마지막으로, 이 언어의 모든 함수 (기본 계산 외)는 정확히 하나의 인수를 가져야 해요. 조금 후에 이 두 가지 설계 결정의 영향을 살펴볼게요.\n\n# 파싱\n\n물론, 우리 스스로 파서를 작성할 수 있어요. 그러나 다행히도 임의의 문맥-자유 문법을 구문 분석할 수 있는 도구들이 있어요. 이 튜토리얼에서는 ANTLR을 사용할 거에요 (여기서 다운로드할 수 있어요). ANTLR은 위와 같은 문법 명세를 받아들여 이를 다양한 대상 언어의 파서로 생성해주는 매우 좋고 쉬운 도구에요 (이 튜토리얼에서는 Python을 사용할 거예요).\n\n사용법은 꽤 간단해요. 아래 단계를 따라해보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 여기에서 ANTLR Java 이진 파일을 다운로드하세요.\n- 문법에 맞는 .g4 파일(위와 같은)을 만드세요. ANTLR는 이모지를 잘 처리하지 못하기 때문에, 언어에 이모지를 사용할 계획이라면 다음 파이썬 스크립트를 실행하여 문법에서 이모지를 제거해주십시오:\n\n```js\nimport emoji\nimport sys\n\ndef demojify_file(input_file, output_file):\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        input_text = f.read()\n\n    input_text = emoji.demojize(input_text)\n\n    with open(output_file, \"w\", encoding=\"utf-8\") as f:\n        f.write(input_text)\n\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    output_file = sys.argv[2]\n    demojify_file(input_file, output_file)\n```\n\n3. java -Xmx500M -cp `path_to_antlr.jar` org.antlr.v4.Tool -Dlanguage=Python3 `your_grammar.g4` 명령을 실행하여 파서를 생성하세요.\n\n그런 다음 생성된 구문 분석 파일을 가져와 다음과 같이 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom antlr4 import *\nfrom EmojiLangLexer import EmojiLangLexer\nfrom EmojiLangParser import EmojiLangParser\nfrom EmojiLangListener import EmojiLangListener\nimport emoji\n\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        input_text = f.read()\n\n    input_text = emoji.demojize(input_text)\n    input_stream = InputStream(input_text)\n    lexer = EmojiLangLexer(input_stream)\n    token_stream = CommonTokenStream(lexer)\n    parser = EmojiLangParser(token_stream)\n    tree = parser.program()\n\n    if parser.getNumberOfSyntaxErrors() \u003e 0:\n        exit(1)\n```\n\n아마도 이 경우에는 데모지징 단계가 필요하지 않을 것입니다. 그런 경우에는 InputStream 대신 antlr4의 FileStream를 사용할 수 있지만, 실제로 큰 차이가 없습니다. 이제 우리는 쉽게 처리할 수 있는 매우 좋은 추상 구문 트리를 갖게 되었고, 이제 어려운 부분인 해석으로 넘어갈 차례입니다³\n\n# 해석기 구축\n\n트리를 다루고 있기 때문에 우리의 해석기는 자연스럽게 재귀적인 개념이 될 것입니다. 그러나 일부 기능을 정확히 어떻게 구현할지에 대한 선택지가 있습니다. 이 튜토리얼에서는 변수를 주소에 바인딩하는 환경을 사용한 뒤, 주소를 값에 매핑하는 가변 스토어를 사용하는 해석기를 구축할 것입니다. 이 아이디어는 꽤 흔한데, 모든 곳에서 사용되는 것은 아니지만 적절한 범위를 유지하고 변수 변이를 지원할 수 있게 합니다. 구현의 편의를 위해 우리의 해석기는 공통 값 구조체를 반환하도록 할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 값, 저장소 및 환경\n\n먼저, 우리의 인터프리터가 출력할 수 있는 것을 정의해 봅시다. 우리의 EBNF에는 세 가지 명백한 기본 사례가 있습니다(즉, 부울 값, 문자열 및 숫자), 따라서 해당 값을 가지고 있는 객체를 만들어 봅시다:\n\n```js\nclass Value:\n    def __init__(self, value):\n        self.value = value\n\n    def __str__(self) -\u003e str:\n        return str(self.value)\n\nclass NumValue(Value):\n    def __init__(self, value: float):\n        super().__init__(value)\n\nclass StringValue(Value):\n    def __init__(self, value: str):\n        super().__init__(value)\n\nclass BoolValue(Value):\n    def __init__(self, value: bool):\n        super().__init__(value)\n```\n\n변수를 값들로 매핑하기 위해, 우리는 환경과 저장소도 만들어 볼 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nclass EnvLookupException(Exception):\n    pass\n\nclass Environment:\n    def __init__(self):\n        self.vars = {}\n\n    def set_var(self, name, addr: int):\n        self.vars[name] = addr\n\n    def get_var(self, name):\n        if name not in self.vars:\n            raise EnvLookupException(f\"Variable {name} not found in environment\")\n        return self.vars[name]\n\n    def copy(self):\n        new_env = Environment()\n        new_env.vars = self.vars.copy()\n        return new_env\n\nclass Store:\n    def __init__(self):\n        self.store = []\n\n    def alloc(self, value: Value):\n        self.store.append(value)\n        return len(self.store) - 1\n\n    def get(self, addr: int):\n        if addr \u003e= len(self.store):\n            raise EnvLookupException(f\"Address {addr} not found in store\")\n        return self.store[addr]\n\n    def set(self, addr: int, value: Value):\n        if addr \u003e= len(self.store):\n            raise EnvLookupException(f\"Address {addr} not found in store\")\n        self.store[addr] = value\n```\n\n우리의 환경은 변수 → 주소 바인딩을 저장하고, store는 주소 → 값 바인딩을 유지합니다. 현재 기능 세트에서 store는 필요하지 않을 수 있지만, 참조에 의한 변수 변경을 허용한다면 유용할 것입니다.\n\n이상적으로, 함수를 변수로 전달할 수도 있기를 원하므로, 더 많은 값을 나타낼 수 있는 하나의 값이 필요합니다. 이를 위해 우리는 클로저를 생성합니다. 클로저에는 함수의 매개변수, 본문, 및 생성된 환경이 포함됩니다:\n\n```python\nclass ClosureValue(Value):\n    # Body should be an antlr4 tree\n    def __init__(self, param: str, body: object, env: 'Environment'):\n        super().__init__(None)\n        self.param = param\n        self.body = body\n        self.env = env\n\n    def __str__(self) -\u003e str:\n        return f\"\u003cfunction\u003e\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n너가 환경을 함수에 저장해야 하는 이유에 대해 물을 수도 있겠지만, 만약에 우리가 다음과 같은 함수 값을 가지고 있는 경우를 상상해보자:\n\n```js\nclass FunctionValue(Value):\n    # Body should be an antlr4 tree\n    def __init__(self, param: str, body: object):\n        super().__init__(None)\n        self.param = param\n        self.body = body\n\n    def __str__(self) -\u003e str:\n        return f\"\u003cfunction\u003e\"\n```\n\n이제, 우리 언어에서 다음과 같은 코드와 동등한 코드를 가졌다고 가정해보자:\n\n```js\n# ----------------\n# ENV MUST PERSIST\n# ----------------\ndef f(x):\n  def g(y):\n    return x + y\n  return g(x)\n\nprint((f(4))(5))  # 9\n\n# ----------------\n# ENV MUST CLEAR\n# ----------------\ndef f2(x):\n  return x + y\n\ndef g2(y):\n  return f(5)\n\nprint(f(4))  # Should crash\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 케이스에서 g에 대한 여전히 y 범위를 보장하려면 동적 스코핑을 구현해야 합니다 (프로그램이 실행되는 동안 변수가 지워지지 않고 환경에 추가되는 범위). 서퍼 코드가 실제로 실행되고 9를 인쇄할 수 있도록 클로저 없이 동적 스코핑을 적용해야 합니다. 그러나 하단 코드가 제대로 충돌하려면 동적 스코프를 구현할 수 없습니다. 따라서 함수가 생성된 환경을 효과적으로 기억하도록 하려면 환경을 클로저 클래스에 추가해야 합니다⁵.\n\n## 인터프리터\n\n이제 실제 인터프리터를 작성할 준비가 되었습니다. ANTLR에서 인터프리터는 EmojiLangListener 클래스를 확장할 것입니다. 또한 최상위 환경을 만들고 인터프리터에 저장소를 제공해야 합니다:\n\n```js\nclass EmojiLangException(Exception):\n    pass\n\nTOP_ENV = Environment()\n\nclass Interpreter(EmojiLangListener):\n    def __init__(self):\n        self.store = Store()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 모든 표현 사례를 처리하는 interp 메서드를 생성해야 합니다. 아래와 같이 보일 것입니다:\n\n```js\ndef interp(self, prog, env: Environment) -\u003e Value:\n    if prog.ID():\n        return self.interp_id(prog.ID())\n    elif prog.atom():\n        return self.interp_atom(prog.atom())\n    elif prog.anonFunctionDefn():\n        return self.interp_function_defn(prog.anonFunctionDefn())\n    elif prog.READ_FLOAT():\n        return self.interp_read_float()\n    elif prog.READ_STRING():\n        return self.interp_read_string()\n    elif prog.printExpr():\n        return self.interp_print_expr()\n    elif prog.ifCond():\n        return self.interp_if(prog.ifCond(), env)\n    elif prog.sequentialOp():\n        return self.interp_sequential_op(prog.sequentialOp(), env)\n    elif prog.baseComputation():\n        return self.interp_base_computation(prog.baseComputation(), env)\n    elif prog.varAssignment():\n        return self.interp_var_assignment(prog.varAssignment(), env)\n    elif prog.funApplication():\n        return self.interp_fun_application(prog.funApplication(), env)\n```\n\n우리의 기본 사례(ID, atom, 함수 정의, 읽기, 출력)는 꽤 단순하기 때문에, 우리는 이렇게 적을 수 있습니다:\n\n```js\ndef interp(self, prog, env: Environment) -\u003e Value:\n    if prog.ID():\n        return self.store.get(env.get_var(prog.ID().getText()))\n    elif prog.atom():\n        return self.interp_atom(prog.atom())\n    elif prog.anonFunctionDefn():\n        return ClosureValue(prog.anonFunctionDefn().arg.text, prog.anonFunctionDefn().body, env)\n    elif prog.READ_FLOAT():\n        try:\n            return NumValue(float(input(\"\u003e \")))\n        except ValueError:\n            raise EmojiLangException(\"Expected float input\")\n    elif prog.READ_STRING():\n        return StringValue(input(\"\u003e \"))\n    elif prog.printExpr():\n        value = self.interp(prog.printExpr().expr(), env)\n        if isinstance(value, StringValue):\n            # print without quotes\n            print(str(value)[1:-1])\n        else:\n            print(value)\n        return value\n    # ...\n\ndef interp_atom(self, atm):\n    if atm.NUMBER():\n        return NumValue(float(atm.NUMBER().getText()))\n    elif atm.BOOLEAN():\n        return BoolValue(atm.BOOLEAN().getText() == \":thumbs_up:\")\n    elif atm.STRING():\n        return StringValue(atm.STRING().getText())\n    # 이런 경우는 절대 발생해서는 안 됩니다.\n    raise EmojiLangException(f\"Unknown atom {atm.getText()}\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 if 조건은 꽤 간단합니다. 조건을 해석한 다음, 조건이 참이면 참인 경우를 해석한 결과를 반환하고 거짓인 경우는 거짓인 경우를 해석한 결과를 반환하면 됩니다. 코드는 다음과 같습니다.\n\n```js\ndef interp_if(self, if_cond, env: Environment):\n    cond = self.interp(if_cond.cond, env)\n    if not isinstance(cond, BoolValue):\n        raise EmojiLangException(f\"Expected boolean when evaluating if condition, got {cond}\")\n    return self.interp(if_cond.ontrue if cond.value else if_cond.onfalse, env)\n```\n\n연속적인 동작도 마찬가지로 간단합니다. 첫 번째 표현식을 해석한 다음 두 번째 표현식을 해석하면 됩니다. 따라서 해당 블록의 코드를 다음과 같이 바꿀 수 있습니다.\n\n```js\ndef interp(self, prog, env: Environment) -\u003e Value:\n  # ...\n  elif prog.sequentialOp():\n    self.interp(prog.sequentialOp().first, env)\n    return self.interp(prog.sequentialOp().second, env)\n  # ...\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 기본 계산이 있습니다. 많은 작업을 처리해야하기 때문에 코드 양이 상당한 편이지만, 복잡하지는 않아요:\n\n```js\ndef interp_base_computation(self, base_computation, env: Environment):\n    left, right = self.interp(base_computation.left, env), self.interp(base_computation.right, env)\n    if base_computation.op.text == \":plus:\":\n        if isinstance(left, NumValue) and isinstance(right, NumValue):\n            return NumValue(left.value + right.value)\n        elif isinstance(left, StringValue) and isinstance(right, StringValue):\n            return StringValue(left.value + right.value)\n        raise EmojiLangException(f\"{left}과 {right}을(를) 더할 수 없습니다\")\n    if base_computation.op.text == \":heavy_equals_sign:\":\n        if type(left) != type(right):\n            return BoolValue(False)\n        if isinstance(left, ClosureValue):\n            raise EmojiLangException(\"함수를 비교할 수 없습니다\")\n        return BoolValue(left.value == right.value)\n\n    # 숫자만 계산\n    if not isinstance(left, NumValue) or not isinstance(right, NumValue):\n        raise EmojiLangException(f\"기본 계산 평가 시 숫자가 예상됩니다. {left}과 {right}을(를) 받았습니다\")\n    if base_computation.op.text == \":minus:\":\n        return NumValue(left.value - right.value)\n    elif base_computation.op.text == \":multiply:\":\n        return NumValue(left.value * right.value)\n    elif base_computation.op.text == \":divide:\":\n        if right.value == 0:\n            raise EmojiLangException(\"0으로 나눌 수 없습니다\")\n        return NumValue(left.value / right.value)\n    elif base_computation.op.text == \"≤\":\n        return BoolValue(left.value \u003c= right.value)\n```\n\n아마도 사전(dictionary)을 사용하여 조금 정리할 수도 있지만, 그것은 크게 중요하지 않아요. 그 다음에는 변수 할당이 있습니다. 이것도 별로 복잡하지 않죠. 여기서 우리가 정확히 무엇을 원하는지에 대한 몇 가지 선택 사항이 있습니다. 구체적으로, 새 변수가 새롭게 생성되는 것을 허용할지 기존 변수만 수정할지 결정해야 합니다. 저는 후자를 선택하겠습니다. 그 결과 코드는 다음과 같습니다:\n\n```js\ndef interp_var_assignment(self, var_assign, env: Environment):\n    value = self.interp(var_assign.val, env)\n    addr = env.get_var(var_assign.var.text)\n    self.store.store[addr] = value\n    return value\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 함수 적용이 있습니다. 여기서는 네 가지 단계를 따라야 합니다. 먼저 호출하는 함수를 해석하여 클로저를 가져옵니다. 그런 다음 인수를 해석합니다. 그런 다음 인수를 클로저의 환경 복사본에 바인딩합니다. 마지막으로 새로운 환경에서 클로저의 본문을 해석합니다. 코드는 다음과 같이 보이게 됩니다:\n\n```js\ndef interp_fun_application(self, fun_app, env: Environment):\n    closure = self.interp(fun_app.fun, env)\n    if not isinstance(closure, ClosureValue):\n        raise EmojiLangException(f\"함수 적용을 평가할 때 함수가 예상되었습니다. 해당 함수: {closure}\")\n    arg = self.interp(fun_app.arg, env)\n    new_env = closure.env.copy()\n    new_env.set_var(closure.param, self.store.alloc(arg))\n    return self.interp(closure.body, new_env)\n```\n\n이제 우리의 해석기가 완벽히 동작합니다! 이제 우리가 실행할 프로그램에 대해 메인 프로그램을 수정하는 것만 남았습니다:\n\n```js\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        input_text = f.read()\n\n    # 입력에서 이모지를 데모지로 변환하기 위해 전처리\n    input_text = emoji.demojize(input_text)\n\n    input_stream = InputStream(input_text)\n    lexer = EmojiLangLexer(input_stream)\n    token_stream = CommonTokenStream(lexer)\n    parser = EmojiLangParser(token_stream)\n    tree = parser.program()\n\n    if parser.getNumberOfSyntaxErrors() \u003e 0:\n        exit(1)\n\n    interpreter = Interpreter()\n    interpreter.interp(tree.expr(), TOP_ENV)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 우리 언어로 놀아보기\n\n이제 우리 언어로 프로그램 작성을 시작할 준비가 끝났어요. 이모지 언어 (EML)로 작성한 간단한 'Hello World!' 프로그램을 확인해보세요:\n\n```js\n🏃‍♂️🏃‍♂️🏃‍♂️\n    (🖨️ (\"Hello World!\"))\n🛑🛑🛑\n```\n\n그리고 이를 실행하려면 단순히 이렇게 하시면 돼요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e python emoji_lang.py helloworld.eml\n\u003e Hello World!\n\n(위 코드는 물론, 해당 프로그램이 helloworld.eml이라는 파일에 존재한다고 가정합니다.)\n\n## 커링\n\n첫 번째 섹션에서 언급했듯이, 우리의 프로그래밍 언어는 함수가 하나의 인수만을 가져야 한다는 점에서 흥미로운 특징을 가지고 있습니다. 그렇다면 다변수 함수와 유사한 효과를 어떻게 만들 수 있을까요? 예를 들어, 다음의 파이썬 코드를 살펴보십시오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef f(x, y):\n  return x + y\n\nprint(f(3, 4))\n```\n\n여기서 f 는 arity 2 — 즉, 두 개의 argument 를 가집니다. 그러나, addition 을 제외한 함수의 arity 가 1 인 함수들만 사용하는 동등한 코드를 아래와 같이 작성할 수 있습니다:\n\n```python\ndef f(x):\n  def g(y):\n    return x + y\n  return g\n\nprint((f(3))(4))\n```\n\n위와 같은 고차 arity 함수를 일변량 함수로 변환하는 개념을 currying 이라고 합니다. 이는 어떤 arity 의 함수에 대해서도 동작하며, arity 가 n 인 함수 f 에 대해 n-1 번의 currying 만을 수행하면 됩니다. 이를 이모지 언어에서 표현하면 다음과 같이 프로그램을 작성할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🏃‍♂️🏃‍♂️🏃‍♂️\n(📋\n(🖨️ (\"두 숫자를 입력하여 합계를 계산합니다.\"))\n(🖨️\n(🏭\n(🏭\n(🧑‍🏭 x ⚒️\n(🧑‍🏭 y ⚒️\n((x) ➕ (y))\n)\n)\n(🔢))\n(🔢))\n)\n)\n🛑🛑🛑\n\n이것의 Python 번역은:\n\nprint(\"두 숫자를 입력하여 합계를 계산합니다.\")\nprint(((lambda x: (lambda y: x + y)))(float(input()))(float(input())))\n\n또는 더 읽기 쉽게,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprint(\"두 숫자를 입력하여 합산합니다.\")\n\ndef f(x):\n  def g(y):\n    return x + y\n  return g\n\nx = float(input())\ny = float(input())\n\nprint(f(x)(y))\n```\n\n또한 처음의 Python 반복이 이름이 지정된 함수를 사용하지 않았다는 것에 유의하십시오. 하지만 우리가 실제로 필요하지는 않지만, 물론 가독성을 위해 유용합니다. 그런 다음,\n\n```js\n\u003e python emoji_lang.py currying.eml\n두 숫자를 입력하여 합산하시오\n\u003e 4\n\u003e 5\n9.0\n```\n\n## 재귀\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 똑똑한 작은 요령을 쓸 수 있어요. 함수들이 값이기 때문에, 함수를 호출할 때 자기 자신에 대한 함수를 전달할 수 있어요. 그렇게 하면 재귀 호출이 가능해져요.\n\n예를 들어 다음 파이썬 코드를 봐봅시다:\n\n```js\nn = int(input())\nwhile n \u003e 0:\n  print(n)\n  n -= 1\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 이를 재귀 버전으로 변환할 수 있습니다. 다음과 같은 방법을 사용할 수 있어요:\n\n```js\ndef while_loop(condition, body):\n  \"\"\"\n  while 루프의 재귀적 구현.\n\n  Arguments\n  -------------\n  - condition: 부울값을 반환하는 매개변수가 없는 함수\n  - body: condition이 true를 반환하는 동안 실행할 매개변수가 없는 함수\n  \"\"\"\n  if condition():\n    body()\n    while_loop(condition, body)\n  else:\n    return False\n\nclass Box:\n    def __init__(self, n):\n        self.n = n\n\n    def set_n(self, n):\n        self.n = n\n\n    def get_n(self):\n        return self.n\n\nn = Box(int(input()))\n\ndef body():\n    print(n.get_n())\n    n.set_n(n.get_n() - 1)\n\nwhile_loop(lambda: n.get_n() \u003e 0, body)\n```\n\n하지만 여기서 문제가 있습니다. while_loop 함수가 자기 자신을 호출하는 것을 주목해주세요. 익명 함수만으로는 언어에서 그렇게는 할 수 없기 때문에 어떻게 해결할까요? 답은 다음과 같이 할 수 있습니다:\n\n```js\ndef while_loop(self, condition, body):\n  if condition():\n    body()\n    self(self, condition, body)\n  else:\n    return False\n\n# ...\n# (상자로 n을 정의)\n# ...\n\ndef body():\n    print(n.get_n())\n    n.set_n(n.get_n() - 1)\n\ndef call_while(loop_func, condition, body):\n    loop_func(loop_func, condition, body)\n\ncall_while(while_loop, lambda: n.get_n() \u003e 0, body)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제로, while_loop 함수가 자신을 매개변수로 취하도록 만듭니다. 그럼에도 불구하고 while_loop 함수 내에서 자신을 호출할 수 있게 되어 while_loop 함수가 재귀적으로 자신을 호출할 수 있게 됩니다.\n\n물론, 우리의 언어에 lambda화하고 커링해야 하므로, 다음과 동등한 코드를 만들어야 합니다:\n\n```js\n(((lambda while_loop:\n    lambda n:\n        while_loop(while_loop)\n                  (lambda bogus: n.get_n() \u003e 0)\n                  (lambda bogus: print(n.get_n()) or n.set_n(n.get_n() - 1)))\n(lambda self:\n    lambda cond:\n        lambda body:\n            (body(\"BOGUS\") or self(self)(cond)(body)) if cond(\"BOGUS\") else False))\n(Box(int(input()))))\n```\n\n이것은 약간 복잡할 수 있지만 작동합니다. 이를 이모지 언어로 표현하면\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n🏃‍♂️🏃‍♂️🏃‍♂️\n    (🏭\n        (🏭\n            (🧑‍🏭 while ⚒️\n                (🧑‍🏭 n ⚒️\n                    (🏭 (🏭 (🏭 (while) (while))\n                        (🧑‍🏭 bogus ⚒️ (🤔 ((n) ≤ (0)) ❓ (👎) : (👍))))\n                        (🧑‍🏭 bogus ⚒️ (📋\n                            (🖨️ (n))\n                            (📦 n 🔜 ((n) ➖ (1)))\n                        )))\n                ))\n            😴\n                아래는 while 함수입니다. 재귀 호출을 위해 자신을 인자로 받습니다\n                (이 외에도 이를 수행하는 다른 방법이 있지만, 재귀 호출을 통한 자기 전달은 상당히 간단합니다)\n\n                ARGS:\n                1. self(자기 자신)\n                2. condition_func (참 또는 거짓을 반환하는 0인자 함수)\n                3. body (참일 때 실행할 아무것도 반환하지 않는 0인자 함수)\n\n                RETURNS:\n                끝날 때 거짓 반환\n            ⏰\n            (🧑‍🏭 self ⚒️\n                (🧑‍🏭 condition_func ⚒️\n                    (🧑‍🏭 body ⚒️\n                        (\n                            🤔 (🏭 (condition_func) (\"BOGUS\")) ❓\n                                (📋\n                                    (🏭 (body) (\"BOGUS\"))\n                                    (🏭 (🏭 (🏭 (self) (self))\n                                            (condition_func))\n                                            (body))) :\n                                (👎)\n                        ))))\n        )\n    (🔢))\n🛑🛑🛑\n```\n\n그런 다음\n\n```js\n\u003e python emoji_lang.py while_loop.eml\n\u003e 4\n4.0\n3.0\n2.0\n1.0\n```\n\n## 추가 보너스: Y 컴비네이터\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 호출할 때마다 while에 자체를 전달하는 것은 다소 귀찮은 작업일 수 있습니다. 그래서 이미 커리된 상태로 자체가 있는 while 함수를 만들 수 있다면 어떨까요? 이를 달성할 수 있는 것이 Y Combinator입니다. Y 컴비네이터는 다음과 같이 보입니다:\n\n```js\nY = lambda g: (lambda f: g(lambda arg: f(f)(arg))) (lambda f: g(lambda arg: f(f)(arg)))\n```\n\n이것은 완전히 터무니없는 것이지만, 함수를 효과적으로 \"저장\"할 수 있게 해줍니다. 이에 대해 자세히 설명은 생략하겠지만, 더 알고 싶다면 이 훌륭한 기사를 참고하는 것이 좋습니다.\n\n이 컴비네이터를 사용하면 우리의 코드를 다음과 같이 변경할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🏃‍♂️🏃‍♂️🏃‍♂️\n(🏭\n(🏭\n(🏭\n(🧑‍🏭 y_combinator ⚒️\n(🧑‍🏭 while ⚒️\n(🧑‍🏭 n ⚒️\n(📋\n🥱 y-combinate our while\n(📦 while 🔜 (🏭 (y_combinator) (while)))\n(🏭 (🏭 (while)\n(🧑‍🏭 bogus ⚒️ (🤔 ((n) ≤ (0)) ❓ (👎) : (👍))))\n(🧑‍🏭 bogus ⚒️ (📋\n(🖨️ (n))\n(📦 n 🔜 ((n) ➖ (1)))\n))\n)\n)\n)\n)\n)\n😴\nOur y combinator function - this allows for recursion without e.g. self passing\nby effectively currying the function and passing it to itself.\n⏰\n(🧑‍🏭 fn_nr ⚒️\n(🏭\n(🧑‍🏭 cc ⚒️\n(🏭 (fn_nr)\n(🧑‍🏭 x ⚒️ (🏭 (🏭 (cc) (cc)) (x)))\n)\n)\n(🧑‍🏭 cc ⚒️\n(🏭 (fn_nr)\n(🧑‍🏭 x ⚒️ (🏭 (🏭 (cc) (cc)) (x)))\n)\n)\n)\n)\n)\n(🧑‍🏭 while ⚒️\n(🧑‍🏭 condition_func ⚒️\n(🧑‍🏭 body ⚒️\n(\n🤔 (🏭 (condition_func) (\"BOGUS\")) ❓\n(📋\n(🏭 (body) (\"BOGUS\"))\n(🏭 (🏭 (while)\n(condition_func))\n(body))) :\n(👎)\n))))\n)  \n (🔢))  \n🛑🛑🛑\n\n이제, y-컴비네이트 된 후 while에 대한 호출이 그 자신을 전달할 필요가 없이 조건과 본문을 전달하는 것만 포함되어 있다는 점에 주목하세요. 그리고 여전히 다음 결과를 얻을 수 있습니다.\n\n```js\n\u003e python emoji_lang.py y_comb_while.eml\n\u003e 4\n4.0\n3.0\n2.0\n1.0\n```\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n축하드려요! 이제 아마도 여러분만의 프로그래밍 언어를 만들었고 그 안에서 재미있는 일들을 코딩했을 거예요. EmojiLang 같은 것은 실제로 많은 유용성이 없지만, 여러분만의 언어를 만들어 다양한 용도로 활용해볼 수 있다는 것을 상상할 수 있어요. 예를 들어 자주 하는 작업을 빠르게 수행할 수 있는 초 특정한 스크립팅 언어를 만들어보는 것 등이 있겠죠.\n\n도전을 좋아하신다면, 아래 연습 문제들을 시도해보세요:\n\n**연습 1:** ANTLR를 사용하지 않고 아래 언어에 대한 간단한 파서와 인터프리터를 만드세요. 괄호가 우선순위를 갖고, 그 외 연산은 동등한 우선순위를 갖도록 해보세요. (예: 4 + 4 \\* 3은 24로 계산되어야 하며, 16이 아니어야 합니다)\n\n```js\nEXPR =\n  숫자 | (EXPR + EXPR) | (EXPR - EXPR) | (EXPR * EXPR) | (EXPR / EXPR) | EXPR;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nExercise 2: 위의 코드를 수정하여 연산자 우선순위를 추가해보세요.\n\nExercise 3 (Tricky): 모든 함수를 익명으로 만들 필요는 없습니다. 다음 언어를 위한 인터프리터를 구현해보세요 (ANTLR을 사용해도 되지만, 직접 .g4 파일을 작성해야 합니다):\n\n```js\nprogram = (FUNDEF | EXPR)* // 하나 이상의 함수 정의 또는 표현식\n\n// 참고: \u003csomething\u003e은 해당 것이 문자열임을 의미합니다\n// 또한, 공백을 무시하거나 세미콜론을 추가하거나 괄호를 추가하여\n// 표현식 또는 함수 정의를 원하는 대로 작성하세요\n\nEXPR = 숫자\n     | 함수적용\n     | 계산\n\nFUNDEF = 'def' \u003cname\u003e '(' \u003cargs\u003e* '):' EXPR\n\n함수적용 = \u003cname\u003e '(' EXPR* ')' // 예: f(1, 2+2, g(3))\n계산 = EXPR + EXPR\n       | EXPR - EXPR\n       | EXPR * EXPR\n       | EXPR / EXPR\n       | (EXPR)\n```\n\nExercise 4 (Easy → Very Very Hard): 다양한 실제 언어에 대한 .g4 파일은 여기서 찾을 수 있습니다. 그 중 하나에 대한 인터프리터를 구현해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 문의 사항이 있으시면 mchak@calpoly.edu 로 연락해주세요.\n\n부. CS 430 교수님 브라이언 존스에게 많은 것을 가르쳐 주셔서 감사합니다.\n\n모든 이미지는 작성자 소유이나 그렇지 않은 경우를 제외하고 있습니다.\n\n- 컴파일된 언어들은 약간 다릅니다. 생성된 추상 구문 트리는 대신 컴파일러로 전달되어 다른 기존 언어(대부분 어셈블리)로 코드로 변환됩니다. 그런 다음 결과 코드를 실행할 수 있습니다.\n- 기술적으로 이것은 실제 EBNF에 있는 것은 아니지만, 충분히 가깝습니다. 궁금하시다면 EBNF에 대해 더 읽어보세요.\n- 참고: 일부 언어들은 해석기로 전달하기 전에 AST에 최적화를 수행할 수 있습니다. 여기서는 그렇게 하지는 않겠습니다.\n- 여전히 환경에서 상자 값을 사용하여 변이를 허용할 수는 있지만, 스토어는 대부분의 언어가 하는 것과 더 유사하며, 적어도 나에게는 더 직관적입니다.\n- 자세한 정보는 7 Functions Anywhere (brown.edu) 참조하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6. 여기서 상자를 사용해야 하는 이유는 Python 환경이 우리와 같은 방식으로 작동하지 않기 때문입니다. 예를 들어, 다음을 실행할 수 없습니다:\n\n```js\n# ...\ndef get_body_and_cond(inp):\n    n = inp\n    condition = lambda: n \u003e 0\n\n    def body():\n        print(n)\n        n -= 1\n    return condition, body\n\nc, b = get_body_and_cond(float(input()))\n\nwhile_loop(c, b)\n```\n\n7. 실제로 우리의 언어는 즉시 무엇을 평가하기 때문에 Z-콤비네이션이 되었습니다만, 효과는 같습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_0.png"},"coverImage":"/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_0.png","tag":["Tech"],"readingTime":32},{"title":"성공적인 관리자들이 실천하는 6가지 미세 습관","description":"","date":"2024-06-22 23:32","slug":"2024-06-22-6MicroHabitsofHighlyEffectiveManagers","content":"\n아래는 이미지 태그를 Markdown 형식으로 변경한 것입니다.\n\n![Manager](/assets/img/2024-06-22-6MicroHabitsofHighlyEffectiveManagers_0.png)\n\n매니저를 뛰어나게 만드는 것은 무엇일까요?\n\n하루 종일 많은 부적절한 결정을 내리는 것이 좋을까요, 아니면 소수의 결정을 잘 내리는 것이 좋을까요?\n\n문제에 반응하여 바쁘게 해결하거나 기회를 결과로 전환하는 적극적인 접근을 하는 것이 좋을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n거대한 발걸음을 내딛으려 하다가 진전을 이루기 어려울 때 포기하느냐, 아니면 쉬운 속도로 매일 꾸준히 나아가느냐?\n\n과거의 낡은 신념을 고수하느냐, 아니면 지식을 넓히려는 호기심을 보이느냐?\n\n답은 명백하지만, 대부분의 매니저들은 효과적이기 어려워합니다. 그들은 적절한 습관을 개발하기 전에도 복잡한 프레임워크와 실천방법을 도입하려고 노력합니다. 그러나 기본이 갖춰지지 않은 채로 그들의 모든 노력이 쓸데없이 낭비되는 것입니다.\n\n매니저에게 효과적으로 일하는 것은 선택사항이 아닌, 그들 직무의 중요한 부분입니다. 효과적이지 않다면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 하찮은 일에 더 많은 시간을 들이고 전진하는 활동에 소요되는 시간은 줄어듭니다.\n- 들인 노력이 결과와 맞지 않습니다.\n- 시간을 통제할 수 없는 느낌이 들어요.\n- 우선순위가 설정되지 않거나 존중받지 않습니다.\n- 기회를 놓치고 문제가 계속되어 있습니다.\n\n효과적인 것은 습관일 뿐이에요; 다른 모든 습관들처럼 삶 속의 여타 습관들처럼 배울 수 있어요. 효과적인 매니저가 되고 싶다면, 이 여섯 가지 미시 습관들을 마스터하세요:\n\n## 두려움에 지지 않기\n\n매니저가 안전한 선택을 하는 이유는 무엇일까요 — 좋은 기회를 놓치고, 위험을 감수하지 않기, 이전에 했던 일을 계속해야 하는 이유는 무엇일까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두려움.\n\n실패에 대한 두려움.\n\n남들의 기대에 부응하지 못할까 두려움.\n\n신용을 잃을까 두려움.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두려움이 심심하고 능력 있는 매니저도 효과적이지 못하게 만드는 경우가 많습니다. 건강한 감정과 도움이 되지 않는 감정을 구분하지 못해서 그들은 안락 지대에 갇힌 채 유지됩니다. 안락 지대는 안전해 보이지만 성장을 제한하기도 합니다.\n\n매우 효율적인 매니저들은 자신을 자신감 넘치게 드러내지 않습니다. 그들도 다른 이들만큼 두려워합니다. 그러나 그들은 두려움이 직무를 수행하거나 매니저로서의 책임을 이행하는 데 방해가 되지 않도록 합니다. 이를 이루기 위해 다음과 같은 방법을 사용합니다:\n\n- 두려움이 인간이라는 것을 인정합니다.\n- 자신의 기술을 의심하는 것에서 그들이 가치 있는 작업을 수행하고 있다는 신호로 변화시킵니다.\n- 두려움을 활용하여 결정을 재평가하고 선택 사항을 의심하며 가정을 다시 고려합니다.\n\n## 비판만을 하는 사람들을 피하세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n매니저가 항상 비판을 받고 아이디어를 맹비난받고 새로운 방법에 반대하는 사람들에게 둘러싸여 있으면 어떻게 될까요?\n\n그들의 냉소주의로 인해 무언가를 이루기가 어려워집니다.\n\n결정이 더 오래 걸리게 됩니다.\n\n토론이 영원히 계속됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 상황을 유지하는 중입니다.\n\n새로운 아이디어는 거절됩니다.\n\n그들의 영향으로 인해 매니저들도 다른 사람에게 비판적이고 명백히 거부하는 경향이 생깁니다. 부정적인 태도는 전염성을 가질 수 있습니다. 이러한 사람들 주변에서 조심하지 않으면 매우 낙관적인 사람마저 낙천주의자로, 응원자는 빌어 먹을 사람으로 변할 수 있습니다.\n\n효율적인 매니저는 주변 사람들의 에너지를 확인합니다 — 그들이 올바른 의도로 우려를 표현하고 있는지, 아니면 단순히 부정적인 태도를 퍼뜨리고 있는지?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n부정적인 사고를 가진 사람들이나 비판적인 사람들과 거리를 두거나 그들의 영향을 최소화하는 것은 더 나은 결정을 내리도록 돕습니다. 선택을 내리기 전에 다양한 옵션을 고려할 수 있습니다.\n\n## 인지적 편향에 적극적으로 대응하기\n\n매니저들이 인지적 편향에 주의를 기울이지 않을 때 어떻게 행동합니까?\n\n그들은 자신의 사고가 합리적이라고 가정하고 자신이 어떻게 속고 있는지 깨닫지 못하고 남을 판단합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 인지 편향이 있습니다. 예를 들어, 근본적인 속성 소인 오류, 확인 편향, 투명성의 환상, 프레임 효과, 그리고 모든 것이 아닌 사고가 습관적인 사고 오류로 이어지며, 현실에 대한 부정확한 견해를 형성합니다.\n\n이러한 편향에 빠지는 관리자들은 업무에서 건강하지 않고 유해한 실천을 따릅니다. 그들은 빨리 탓하고, 다른 사람의 성격 결점을 지적하고, 훌륭한 아이디어를 거부하며, 직원을 불공평하게 대합니다.\n\n매우 효과적인 관리자들도 편향에서 자유롭지 않습니다. 그들은 다른 사람들과 마찬가지로 마음의 제한에 직면하고 있습니다. 그러나 그들은 또한 매우 자기 인식이 높습니다. 그들은 통신, 협업 및 다른 사람과 함께 일할 때 자신들의 편향이 방해요소가 되지 않도록 하는 좋은 실천과 마음의 습관을 준수합니다. 예를 들면:\n\n- 실수로부터 배우기 위해 피드백 루프를 실행합니다.\n- 상반된 의견을 장려합니다.\n- 답변 대신 질문으로 리드합니다.\n- 선택적으로 간단함을 더하기 위해 Occam의 면도날을 사용하고, 자신의 개인적 서술을 넘어서 다른 사람의 관점에서 상황을 상상하기 위해 Hanlon의 면도날을 적용하며, 그 밖의 유용한 정신적 모델을 활용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일상 습관으로서 이러한 간단한 실천 방법을 채택하면 인지 편향이 결정에 미치는 부정적인 영향을 줄일 수 있고 어떻게 리딩하는지에 도움이 되겠죠.\n\n## 타인을 격려하기\n\n매니저들이 팀의 재능을 활용하고 잠재력을 최대화하며 그들이 최고의 일을 할 수 있는 환경을 조성하는 데 막는 요소는 무엇인가요?\n\n다른 사람들보다 항상 우월함을 느끼는 것과 늘 다른 사람보다 더 나은 존재여야 한다는 욕망입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n탁월한 관리자는 자신의 팀의 사고력과 능력을 향상시키는 배푸리로서 활동합니다. 그들은 사람들이 스스로 발전할 수 있도록 도와주며 각 개인의 독특한 지성을 활용하고 적절한 기회들과 연결시킵니다.\n\n약자는 팀을 억누르고 위로 밀어내지만, 배푸리는 그들에게 빛나고 성공할 기회를 주어서 사람들을 격려합니다.\n\n## 영향권 내에서 활동하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n왜 일부 관리자는 장애물을 만나거나 도전에 직면했을 때 즉시 포기하는 것일까?\n\n낮은 대리력.\n\n대리력이 낮은 관리자는 관심 영역에 노력을 집중합니다. 제어할 수 없는 일에 시간과 에너지를 쏟다 보면 개선할 여지가 있는 영역을 소홀히 합니다. 다른 사람을 비난하거나 자신의 상황, 환경을 원망하는 것은 부정적인 악순환을 초래하여 영향력을 줄입니다.\n\n매우 효과적인 관리자들은 대리력이 높습니다. 그들은 영향력 영역에 노력을 집중합니다. 제어할 수 있는 것에 주의를 기울이면 실험을 하고 다양한 전략을 시도하며 실제 문제를 해결할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기대한 대로 되지 않을 때 타인을 비난하거나 비판하는 대신, 자신의 결정과 행동을 내적으로 돌아보는 사람들이 있습니다. 이는 다른 사람의 약점에 초점을 맞추는 것에서 자신의 강점으로 이동시킵니다. 자신의 통제력을 발휘함으로써 얻는 긍정적 에너지는 그들의 영향력을 증대시킵니다.\n\n어려운 문제나 어려운 결정에 직면했을 때, 그들은 다음과 같은 질문을 던집니다:\n\n- 내 영향력의 범위 내에 있는가?\n- 나 자신이나 내가 하는 방식을 어떻게 바꿔 이 문제를 해결할 수 있는가?\n- 다른 사람에게 영향을 미치고 변화를 이끌어내도록 할 수 있는가?\n- 내가 원하는 결과를 얻을 수 있는 다른 대안은 무엇인가?\n\n높은 효율을 발휘하는 매니저는 희생자식 마인드에 빠지거나 자신의 통제 범위 밖에 있는 사람들, 상황 또는 조건에 대해 시간을 낭비하지 않기 때문에 행동할 수 있는 힘을 느낍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 일의 신체적, 정신적 요구에 에너지를 맞추세요\n\n매니저들이 경솔해지거나 분석 마비에 빠지거나 현 상태를 선택하는 원인은 무엇인가요?\n\n낮은 정신적 에너지로 운영 중이거나 중요한 결정이나 작업을 위해 인지적 자원을 절약하지 못한 경우입니다.\n\n매우 효과적인 매니저들은 일의 신체적, 정신적 요구와 에너지를 맞춤으로써 일정을 최적으로 활용합니다. 그들은 최고 생산성 시기를 활용하여 가장 중요한 일 중 일부를 처리합니다. 중요한 일을 우선시하는 것은 정신적 에너지가 최상 상태일 때 명확하게 사고하고 의식적인 결정을 내릴 수 있도록 돕습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 요약\n\n- 탁월한 매니저들은 높은 효율성을 유지하기 위해 간단한 습관과 실천 방법을 따릅니다.\n- 공포를 살펴보는 신호로 이해하고 다수의 옵션을 평가하거나 질문을 하거나 가정을 재고하여, 결정을 내릴 때나 행동을 취할 때 공포에 방해받지 않습니다.\n- 미적흡인자에게 영향을 받지 않도록 하기 위해, 탁월한 매니저들은 그들의 사고나 의사결정에 영향을 미치게 허용하지 않습니다.\n- 탁월한 매니저들은 제어할 수 있는 일에 집중함으로써 제어할 수 없는 일에 시간을 낭비하지 않고, 영향력의 원을 확대합니다.\n- 그들의 팀의 잠재력을 극대화하는 것이 그들의 주요 관심사입니다. 각 개인의 장점을 강조하고, 적절한 기회와 결합시켜 높은 성과를 거둘 수 있는 탁월한 매니저들은 고성능 팀을 구축합니다.\n- 효과적인 매니저들은 자신의 정신적 한계를 뚜렷이 인식합니다. 인지적 편향이 그들의 사고나 의사결정에 방해가 되지 않도록 합니다.\n- 그들은 자신의 최고 생산성 시간을 활용하여 최상의 업무를 수행합니다. 에너지를 작업의 인지적 수요와 일치시킴으로써 그들을 높은 효율성을 낼 수 있습니다.\n\n더 많은 이야기를 위해 여기와 LinkedIn에서 제 팔로우를 눌러주세요. 이 이야기는 원래 https://www.techtello.com 에서 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-6MicroHabitsofHighlyEffectiveManagers_0.png"},"coverImage":"/assets/img/2024-06-22-6MicroHabitsofHighlyEffectiveManagers_0.png","tag":["Tech"],"readingTime":9},{"title":" Mac OS에서 React Native를 사용한 Android 개발 환경 설정 방법","description":"","date":"2024-06-22 23:31","slug":"2024-06-22-HowToSetUpYourAndroidDevelopmentEnvironmentReactNativeMacOS","content":"\n![Image](/assets/img/2024-06-22-HowToSetUpYourAndroidDevelopmentEnvironmentReactNativeMacOS_0.png)\n\n새로운 기계를 설정하는 것에는 특별한 즐거움이 있다고 생각해요... 그러나 개발 환경을 다시 구성해야 한다는 것을 깨닫게 되면 조금 번거로울 수도 있죠! 제가 직접 단계를 거치면서 Android 개발 환경을 설정하는 방법에 대한 안내서를 작성해 보았어요 (특히 macOS에서 React Native 애플리케이션을 위해). 새로운 기계를 설정하려는 것이거나 간단히 상기시키고 싶을 때, 이 안내서가 도움이 되리라고 생각돼요. 더 이상 미루지 말고 지금 시작해볼까요?\n\n# 단계 1: Homebrew 설치하기\n\nHomebrew는 macOS용 패키지 매니저로 소프트웨어 설치를 간편하게 해줘요. 아직 설치하지 않았다면, 터미널을 열고 다음을 실행하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```sh\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n# 단계 2: Node, Watchman 및 Java 설치\n\n다음으로 Node 및 Watchman이 필요합니다. 또한 Java도 필요합니다. Node의 경우 NVM (Node Version Manager)을 사용하여 설치하는 것을 극력 드립니다. 이를 통해 다른 프로젝트에 필요한 다양한 노드 버전을 쉽게 관리할 수 있습니다.\n\n- 이러한 모든 것을 설치하려면 Homebrew를 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nbrew install nvm\n// 또는 nvm을 사용하지 않을 경우:\nbrew install node\nbrew install watchman\n```\n\n- NVM을 선택했다면, 이제 NVM을 통해 원하는 버전의 node를 설치하거나 최신 버전을 설치하세요.\n\n```js\nnvm install node\n```\n\n- 그런 다음 Java를 다운로드하고 설치하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 3: 안드로이드 스튜디오 설치\n\nhttps://developer.android.com/studio 에서 안드로이드 스튜디오를 다운로드하고 설치하세요. 설정 중에 다음을 선택하세요:\n\n- Android SDK\n- Android SDK 플랫폼\n- Android 가상 장치\n\n체크 박스가 보이지 않는 경우 나중에 안드로이드 스튜디오의 SDK 관리자를 통해 이러한 구성 요소를 설치할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 4: JAVA_HOME 변수 설정하기\n\n- 터미널을 엽니다\n- bash를 사용 중이라면:\n\n```js\necho export \"JAVA_HOME=\\$(/usr/libexec/java_home)\" \u003e\u003e ~/.bash_profile\n```\n\n- macOS Catalina 이상을 실행 중이라면 zsh를 사용 중이라고 가정하는 경우 대신 다음과 같이해야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\necho export \"JAVA_HOME=\\$(/usr/libexec/java_home)\" \u003e\u003e ~/.zshrc\n```\n\n- 그런 다음 source ~/.bash_profile 또는 source ~/.zshrc를 사용하여 셸을 다시 시작합니다.\n\n# 단계 5: ANDROID_HOME 환경 변수 구성\n\nReact Native는 Android SDK의 위치를 알아야합니다. 이는 ANDROID_HOME 환경 변수를 설정하여 달성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 터미널을 엽니다.\n- 파일을 만들거나 이미 있는 경우 파일을 엽니다:\n- 만약 bash를 사용하는 경우: touch ~/.bash_profile\n- 혹은 zsh를 사용하는 경우: touch ~/.zshrc\n- 그런 다음, open -e ~/.bash_profile을 실행하여 TextEdit에서 파일을 엽니다.\n- 다음 줄을 파일에 추가하고 저장하세요:\n\n```js\nexport ANDROID_HOME=$HOME/Library/Android/sdk\nexport PATH=$PATH:$ANDROID_HOME/emulator\nexport PATH=$PATH:$ANDROID_HOME/tools\nexport PATH=$PATH:$ANDROID_HOME/tools/bin\nexport PATH=$PATH:$ANDROID_HOME/platform-tools\n```\n\n# 단계 6: 가상 장치 생성 및 구성\n\n앱을 실행할 Android Virtual Device(AVD)가 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 안드로이드 스튜디오를 열어주세요.\n- 상단 메뉴에서 Device Manager를 클릭해주세요.\n- \"장치 생성\"을 클릭해주세요 (Play Store 구매를 테스트하려면 Play Store를 지원하는 장치를 선택해야 합니다).\n- 장치 정의를 선택하고 \"다음\"을 클릭해주세요.\n- 시스템 이미지를 선택하고 \"다음\"을 클릭해주세요.\n- 구성을 확인하고 \"완료\"를 클릭해주세요.\n\n# 7단계: React Native 설치\n\n[React Native 문서](https://reactnative.dev/docs/environment-setup?guide=native)의 지침을 따라주세요 (저는 Bare React Native을 사용하고 있지만 Expo에 대한 지침도 있습니다).\n\n# 8단계: 새 애플리케이션 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모두 준비되었습니다! 다음 명령을 실행하여 새로운 React Native 애플리케이션을 만들 수 있어요:\n\n```js\nreact-native init MyNewApp\n\n// 애플리케이션 이름으로 \"MyNewApp\"을(를) 교체하세요.\n```\n\nAndroid 가상 장치에서 React Native 애플리케이션을 실행하려면:\n\n- AVD가 실행 중인지 확인하세요. Android Studio의 AVD 관리자에서 확인할 수 있어요.\n- 터미널이나 코드 편집기에서 npm start 명령을 실행하세요.\n- 그런 다음 Android에서 실행하려면 \"a\"를 입력하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기요! 지금 모두 잘 되고 있기를 바라요. 앱 만드는 즐거움이 가득하길!\n\n언스플래시(Unsplash)에서 로브 햄프슨(Rob Hampsono) 사진으로 제공된 사진을 표지로 사용\n\n원문 게시 위치: https://www.tiaeastwood.com.\n","ogImage":{"url":"/assets/img/2024-06-22-HowToSetUpYourAndroidDevelopmentEnvironmentReactNativeMacOS_0.png"},"coverImage":"/assets/img/2024-06-22-HowToSetUpYourAndroidDevelopmentEnvironmentReactNativeMacOS_0.png","tag":["Tech"],"readingTime":6},{"title":"Flutter DropdownButtonFormField에서 텍스트 넘침 방지하는 방법","description":"","date":"2024-06-22 23:30","slug":"2024-06-22-PreventingTextOverflowinFluttersDropdownButtonFormField","content":"\n# 문제: RenderFlex 오버플로우\n\n플러터에서 DropdownButtonFormField를 사용할 때 긴 텍스트 항목은 레이아웃 문제를 일으킬 수 있습니다. 텍스트가 너무 길면 다음 오류를 만날 수 있습니다:\n\n```js\n======== Exception caught by rendering library =====================================================\nThe following assertion was thrown during layout:\nA RenderFlex overflowed by 14 pixels on the right.\n```\n\n이 문제는 드롭다운 항목의 텍스트가 사용 가능한 너비를 초과하여 오버플로우가 발생하기 때문에 발생합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 해결책: isExpanded 사용하기\n\n이 문제의 간단한 해결책은 DropdownButtonFormField의 isExpanded 속성을 true로 설정하는 것입니다. 이렇게 하면 드롭다운 버튼과 해당 아이템이 부모 컨테이너의 전체 너비를 차지하도록해 오버플로우를 방지합니다.\n\n# 코드 예시\n\n다음은 이 해결책을 구현하는 방법을 보여주는 간결한 예시 코드입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nWidget _buildDropdownButtonFormField() {\n  return DropdownButtonFormField\u003cString\u003e(\n    isDense: true,\n    isExpanded: true, // Key property to handle text overflow\n    value: _selectedValue,\n    style: const TextStyle(fontWeight: FontWeight.bold),\n    dropdownColor: const Color(0xFF55565A),\n    decoration: InputDecoration(\n      labelText: 'Select Item',\n      hintText: 'Please select an item',\n      labelStyle: Theme.of(context).textTheme.labelMedium,\n    ),\n    items: ['Item 1', 'A very long item text that overflows', 'Item 3'].map((String item) {\n      return DropdownMenuItem\u003cString\u003e(\n        value: item,\n        child: Text(\n          item,\n          softWrap: true,\n          overflow: TextOverflow.ellipsis,\n          style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),\n        ),\n      );\n    }).toList(),\n    onChanged: (newValue) {\n      setState(() {\n        _selectedValue = newValue;\n      });\n    },\n    validator: (value) =\u003e value == null ? 'Please select an item' : null,\n  );\n}\n```\n\n## 작동 방식\n\nisExpanded: true로 설정하면 드롭다운 버튼과 항목이 사용 가능한 너비에 맞게 확장됩니다. TextOverflow.ellipsis 속성은 여전히 너무 긴 텍스트를 자르고, 더 많은 텍스트가 있다는 것을 나타내기 위해 생략 부호를 추가합니다.\n\n## 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDropdownButtonFormField에서 isExpanded 속성을 사용하면 텍스트 오버플로 문제를 쉽고 효과적으로 처리할 수 있어요. 이 작은 변경은 드롭다운 메뉴 레이아웃을 개선하여 깔끔하고 사용자 친화적인 인터페이스를 보장해 줘요.\n","ogImage":{"url":"/assets/img/2024-06-22-PreventingTextOverflowinFluttersDropdownButtonFormField_0.png"},"coverImage":"/assets/img/2024-06-22-PreventingTextOverflowinFluttersDropdownButtonFormField_0.png","tag":["Tech"],"readingTime":3},{"title":"React Query  React Native 완벽한 협업 이야기","description":"","date":"2024-06-22 23:28","slug":"2024-06-22-ReactQueryReactNativeALoveStoryatFound","content":"\n\u003cimg src=\"/assets/img/2024-06-22-ReactQueryReactNativeALoveStoryatFound_0.png\" /\u003e\n\n모든 좋은 사랑 이야기처럼, 기쁨, 절망, 고통, 고난이 있습니다. 유명한 속담처럼 \"사랑하고 잃는 것이 전혀 사랑하지 않는 것보다 나은지\" 생각해 볼 때도 있죠.\n\n그러나 이 사랑 이야기의 스포일러 경고는 저와 공유하고 싶어요. 위아래로 변동이 있었지만 사랑은 잃어버린 적이 없습니다. 저희는 React Query (준말 Tanstack Query)와 함께 Found 모바일 애플리케이션에서 서버 상태를 처리하는 방식에 완전히 사랑에 빠져 있습니다.\n\n# 첫눈에 반한, React Query 선택하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리액트 쿼리가 리액트 애플리케이션에서 서버 상태를 관리하는 산업 표준 라이브러리 중 하나로 자리를 잡은 것은 의심할 여지가 없습니다. 리액트 네이티브로 구축된 Found의 모바일 앱은 자바스크립트 스레드에서 리액트가 렌더링되는 곳에서 리액트 쿼리를 사용할 수 있습니다.\n\n그렇기에 선언적인 성격, 후크 지향 아키텍처, 강력한 캐시 메커니즘이 조화를 이루어 완벽한 패키지가 되었습니다. 저에게(그리고 Found에게) 첫눈에 반한 것이 정말입니다 😍.\n\n리액트 쿼리는 그 존재 이유를 설명하는 \"매니페스토\"로 매력을 발산했습니다:\n\n제 무릎이 약해지기 시작했습니다. 더 이상 리덕스? 사용자 정의 API 클라이언트 없이도 가능한가요? 로컬 상태와 서버 상태 간 분명한 관심사 분리? 사랑에 빠졌습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(정말 공정하게 말하자면, 내가 합류하기 전에 Found 팀도 아예 같은 생각을 했다. 실제로 Found의 모바일 팀에 합류하는 데 중요한 이유 중 하나였어. React Native와 React Query를 사용하나요? 어디에 등록하면 되나요?)\n\n# 신혼 여행 단계: React Query로 상태 관리 스택\n\n로컬 및 서버 상태 간에 분명하게 구분되어 스케일을 빠르게 확장할 수 있었습니다. React Query는 서버 상태를 다루는 것에 대한 선언문에 충실했고, 우리는 더 행복할 수 없었습니다.\n\n![이미지](/assets/img/2024-06-22-ReactQueryReactNativeALoveStoryatFound_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nZustand과 Context는 애플리케이션의 로컬 상태에 관한 문제를 다루며, stores를 유지하여 단일 책임 원칙(SRP)을 준수하는 것을 목표로 합니다.\n\n최종적으로 Zustand와 Context stores는 React Query의 쿼리 양에 비해 애플리케이션의 총 상태(로컬 상태 + 서버 상태)의 약 20%만 차지했습니다. 우리는 Redux 또는 다른 복잡한 상태 관리 라이브러리로 스택을 과도하게 설계할 필요가 없었습니다. 우리의 스택은 비즈니스와 사용자 요구에 맞추어 잘 확장되고 있었습니다.\n\n하지만, 좋은 로맨스 코미디와 마찬가지로, 좋은 것 없이는 나쁜 것도 없습니다.\n\n# 문제점: 완벽한 사람은 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 관계는 문제가 있을 수 있고, 우리의 React Query와의 관계도 그 예외는 아니었습니다. 처음에는 잘 시작했지만, 기능 세트가 성장함에 따라 데이터가 더 복잡해지고 문제가 발생하기 시작했습니다:\n\n- 캐싱. 제품과 사용자가 기대하는대로 데이터가 업데이트되지 않아 UX가 나빠지고 캐싱 버그의 대규모 backlog이 생겼습니다.\n- 대량의 로컬 상태, 쿼리 훅 및 캐시 쿼리들이 한 화면에 밀어넣어져 작업하기 번거로워졌습니다. 이는 관리하기 힘들어졌습니다.\n- 캐시를 직접 업데이트하는 것은 즐겁지 않았습니다. 이게 왜 이렇게 어려워야 하는 걸까요?\n\n긴 이야기를 짧게 말하자면, 대부분의 로맨스 영화 스토리처럼 우리는 화가 나서 그 후 자체성장 몽타주를 겪었습니다 (이는 React Query에서 작동하지 않는 이유를 이해하고 그에 대해 어떻게 해야 하는지 확인하는 작업을 맡은 것이었습니다).\n\n## 1. 문제가 너에게 있는 게 아니야, 나에게 있다: 캐시가 모든 것을 통제한다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact Query를 우리에게 매료시킨 것은 낮은 보일러플레이트, 설정 가능하고 자동 백그라운드 다시 불러오기와 같은 강력한 캐싱 메커니즘이었습니다. 이 기능을 통해 서버의 데이터를 클라이언트로 동기화할 수 있었습니다. 그러나 캐싱 관련 버그와 사용자 불만이 증가함에 따라, 우리의 애플리케이션과 React Query의 캐시에 문제가 있는 것으로 분명해졌습니다.\n\n많은 사람들이 손가락을 가리고 안경이 깨지는 등 여러 문제가 있었지만, 이 문제의 해결책은 \"React Query 때문이 아니라 우리 때문이다\"라는 것으로 밝혀졌습니다.\n\n## 서버 상태와 캐시를 적절하게 동기화하기\n\n서버와 애플리케이션의 상태를 동기화하기 위해서는 다음과 같이 간단한 패러다임 전환이 필요합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 대부분의 경우에는 cacheTime과 staleTime만으로 신뢰할 수 없을 것입니다. 언제나 캐시를 직접 업데이트하거나 응용 프로그램의 어느 시점에서는 해당 쿼리를 무효화해야 한다고 가정하십시오.\n- 서버가 올바른 데이터 구조로 응답하는 경우 캐시를 직접 업데이트합니다.\n- 서버가 올바른 데이터 구조로 응답하지 않거나 캐시를 쉽게 업데이트할 수 없는 경우, 단순히 쿼리를 무효화하십시오.\n\n## 캐시 무효화\n\n캐시를 직접 무효화하는 방법은 React Query의 유지 관리자가 \"스마트 재요청\"이라고 부르는 방법으로, 캐시를 직접 업데이트할 수 없을 때 클라이언트와 서버 상태를 동기화하는 많은 문제를 해결했습니다.\n\n```js\n// 특정 포커스에 대한 사용자 작업 로그를 업데이트합니다. ex) Getting More Sleep\nconst {\n  mutate: taskLogMutate,\n  isSuccess: isTaskLogMutationSuccess,\n  isLoading: isTaskLogMutationLoading,\n  data: taskLogResponse,\n} = useTaskLogMutation({\n  onSuccess: ({ taskLog }) =\u003e {\n    invalidateQueries([\n      queryStore.focuses.fetch._def,\n      queryStore.focuses.fetchDetails._def,\n      queryStore.logs.fetch._def,\n    ]);\n  },\n});\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서 사용자는 특정 관심사를 가진 작업 로그를 변경하고, 그 변경이 성공한 경우 해당 작업 로그를 가져오는 쿼리들과 새로운 작업 로그를 반영하기 위한 포커스/포커스 세부 정보는 모두 무효화됩니다.\n\n이를 통해 클라이언트의 서버 상태를 업데이트하도록 다시 가져올 것이 보장됩니다. 이는 해당 쿼리에 활성 옵저버가 있는 경우 즉시 또는 사용자에게 해당 쿼리를 보유하고 있는 화면이 표시될 때 백그라운드에서 업데이트됩니다.\n\n## React Navigation (Mobile) 레슨\n\n모바일 앱에서의 네비게이션은 일반적인 브라우저 URL 라우팅 네비게이션보다 더 복잡성을 추가합니다. 여러 개의 중첩된 네비게이션 패턴(스택, 탭, 모달, 드로어)에 의존하기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 Found 팀이 쿼리의 라이프사이클을 이해하고 캐시 구성 값인 staleTime과 cacheTime에 기반하여 언제 다시 가져올지에 대해 배우는 과정이 분명히 있었습니다. 여기서 그 값에 대해 자세히 다루지는 않겠지만, 궁금하다면 React Query의 블로그 포스트를 확인해보세요.\n\n우리가 배운 가장 큰 두 가지 교훈은 다음과 같습니다:\n\n1. staleTime: 0, cacheTime: 0로 설정된 쿼리가 있는 화면에 네비게이션 스택 위로 화면을 푸시하고, 현재 화면을 팝할 때 이전 쿼리를 다시 가져오고 싶다면, 쿼리를 수동으로 무효화해서 가져와야 한다는 것입니다.\n2. #1에서 이어서, 탭 네이게이터는 루트 화면이 항상 마운트되어 있어서, 백그라운드 다시 가져오기가 발생하길 원한다면, 해당하는 쿼리들은 수동으로 무효화되어야 합니다.\n\n요약하자면, 화면이 마운트되어 있고 해당 화면으로 이동하면 백그라운드에서 자동으로 다시 가져오지 않습니다. 설정한 staleTime과 cacheTime과 상관없이 그 화면의 쿼리는 데이터를 백그라운드에서 다시 가져오고자 할 때 queryClient.invalidateQueries()를 통해 수동으로 무효화해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Query Store\n\n우리는 75개 이상의 쿼리를 가지고 있었고 쿼리 키 스토어가 없었기 때문에 절대적인 혼란이었습니다. 쿼리 스토어를 도입하는 것은 쿼리를 실행하고 캐시를 무효화하고 업데이트해야 할 때 큰 성과였습니다. 우리는 루크 모랄레스의 쿼리 키 팩토리를 선택했지만 여러분도 직접 만들 수 있습니다.\n\n```js\nimport type { inferQueryKeys } from \"@lukemorales/query-key-factory\";\n\nimport { createQueryKeys } from \"@lukemorales/query-key-factory\";\n\nexport const focusesQueryStore = createQueryKeys(\"focuses\", {\n  fetch: (category: string) =\u003e [\"fetch\", category],\n  fetchDetails: (focusId?: string) =\u003e [\"details\", focusId],\n});\n\nexport type FocusesQueryStoreType = inferQueryKeys\u003ctypeof focusesQueryStore\u003e;\nqueryClient.invalidateQeries({\n  queryKey: queryStore.focuses.fetchDetails(focusId).queryKey,\n});\n```\n\n기본 제공되는 타이핑이 우리를 홀렸고, React Query에서 서버 데이터 타이핑을 중앙 집중화하는 데 도움을 주기 위해 스토어에 요청 함수를 추가하는 실험을 계획 중입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. Talking in Circles: Repository 훅을 사용하여 관심사를 더 분리하기\n\n우리의 화면 구성 요소는 여러 사용자 정의 쿼리 훅, Zustand 스토어 훅, 컨텍스트 및 로컬 및 클라이언트 상태를 병합하는 로직으로 인해 매우 부풀어 있고 길어졌다는 것에 의심의 여지가 없었습니다.\n\nDomain-Driven Design에서 고수준으로 Repository 패턴을 재사용하여 응용 프로그램 전체에서 특정 도메인의 관심을 자체 사용자 정의 훅으로 상위 수준으로 분리했습니다.\n\n![이미지](/assets/img/2024-06-22-ReactQueryReactNativeALoveStoryatFound_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 훅의 책임은 로컬 상태와 서버 상태를 병합하고 여러 쿼리를 하나로 병합하는 것을 포함하지만 이에 국한되지 않습니다. 이 패턴의 채택은 DDD 레포지토리를 일대일로 따르기보다는 UI를 쿼리 및 응용 프로그램 상태 레이어의 업데이트 및 쿼리 클라이언트로 분리하는 개념을 구현하는 것을 의미합니다.\n\nReact Query에서 기본으로 지원하지 않는 훌륭한 사용 사례는 종속 변이(dependent mutation)일 것입니다.\n\n```js\nexport const useTaskLogMutationRepository = ({\n  image,\n  taskId,\n  isEditing,\n}: TaskLogRepositoryParams) =\u003e {\n  const { invalidateQueries } = useInvalidateQueries();\n\n  // useTaskLogMutation에 종속된 변이\n  const {\n    isSuccess: isTaskImageMutationSuccess,\n    isLoading: isTaskImageMutationLoading,\n    mutate: taskImageMutate,\n  } = useTaskImageMutation({\n    onSuccess: () =\u003e {\n      invalidateQueries(queryStore.challenges.detail._def);\n    },\n  });\n\n  const {\n    mutate: taskLogMutate,\n    isSuccess: isTaskLogMutationSuccess,\n    isLoading: isTaskLogMutationLoading,\n    data: taskLogResponse,\n  } = useTaskLogMutation({\n    onSuccess: ({ taskLog }) =\u003e {\n      invalidateQueries([\n        queryStore.focuses.fetch._def,\n        queryStore.focuses.fetchDetails._def,\n        queryStore.logs.fetch._def,\n      ]);\n\n      // 이미지가 있는 경우 taskLog.id를 사용하여 이미지를 변경합니다.\n      if (image) {\n        taskImageMutate({ taskLogId: taskLog?.id, image });\n      } else {\n        invalidateQueries(queryStore.challenges.detail._def);\n      }\n    },\n  });\n\n  // 비동기 상태 병합\n  const isLoading = isTaskImageMutationLoading || isTaskLogMutationLoading;\n  const isSuccess =\n    isTaskLogMutationSuccess \u0026\u0026 (isTaskImageMutationSuccess || !image);\n\n  const mutate = useCallback(\n    (data: ITaskLogMutationParams) =\u003e {\n      taskLogMutate(data);\n    },\n    [taskLogMutate]\n  );\n\n  return useMemo(\n    () =\u003e ({ mutate, isSuccess, isLoading, taskLogResponse }),\n    [mutate, isSuccess, isLoading, taskLogResponse]\n  );\n};\n```\n\n이 저장소의 책임은 작업을 완료할 때 종속 변이 처리, 이미지 업로드에 대한 후속 변이 처리 및 비동기 상태 병합을 다루는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비동기 상태의 병합을 함으로써 UI가 종속된 작업 로그 이미지 변이 로딩인지 또는 단순히 작업 로그 변이인지에 대한 올바른 로딩 피드백을 표시할 수 있습니다. 비동기 논리의 병합을 해제하면 비동기 상태 관련 문제를 저장소에 집중시켜 응용 프로그램 전체에서 재사용할 수 있습니다.\n\n## 3. 더 이상 싸우지 말고: Immer가 도와줍니다\n\n서버 데이터는 중첩 구조 때문에 특히 페이지네이션과 함께 중첩된 객체 값 업데이트가 어려웠습니다. 이는 setQueryData를 사용하여 캐시 데이터를 업데이트할 때 불변한 방식으로 수행해야 하는 경우 우리의 관계에서 지속적인 문제였습니다.\n\n```js\nqueryClient.setQueryData\u003cInfiniteData\u003cITagsInfiniteQueryResponse\u003e\u003e(\n  queryStore.tags.fetch.queryKey,\n  tags =\u003e {\n    if (tags?.pages) {\n      return {\n        ...tags,\n        pages: tags.pages.map(page =\u003e ({\n          ...page,\n          bookmarks: page.bookmarks.map(bookmark =\u003e\n            bookmark.bookmarkable.text === favoriteTag.bookmarkable.text\n              ? favoriteTag\n              : bookmark,\n          ),\n        })),\n      };\n    }\n    return tags;\n  },\n);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nImmer가 나타났습니다. React Query와는 상호배타적인 문제는 아니지만(툴킷(RTK)은 잠재적으로 내부적으로 immer를 사용합니다), 많은 공개적인 논쟁을 막아줬어요.\n\n```js\nqueryClient.setQueryData\u003cInfiniteData\u003cITagsInfiniteQueryResponse\u003e\u003e(\n  queryStore.tags.fetch.queryKey,\n  tags =\u003e {\n    // ✅ Immer의 produce 함수로\n    const newData = produce(tags, draft =\u003e {\n      const tag = draft?.pages\n        .flatMap(page =\u003e page.bookmarks)\n        .find(\n          bookmark =\u003e\n            bookmark.bookmarkable.text === favoriteTag.bookmarkable.text,\n        );\n      if (tag) {\n        tag.isBookmarked = favoriteTag.isBookmarked;\n      }\n    });\n    return newData;\n  },\n);\n```\n\n전체 중첩 구조를 다시 만들 필요가 없고, Immer는 중첩된 객체의 값을 업데이트하기 위한 produce 함수를 제공하여 중첩된 객체를 다시 만들지 않고도 성능적이고 가독성 좋게 업데이트할 수 있어요.\n\n# 화해 후의 키스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대부분의 커플들과는 다르겠지만, 우리가 우리의 관계 문제를 해결하는 데 도움이 된 것은 문제를 이해하고 이야기하며 실제로 (특히 이것) 실행하는 것이었습니다.\n\n리포지토리를 사용하여 애플리케이션 상태에 추가적인 추상화 계층을 덧붙이고, 지속적으로 캐시를 무효화하고 업데이트하며, 캐시를 쉽게 업데이트하면서 코드베이스, 기술 스택, 그리고 가장 중요한 것인 Found 모바일 앱의 사용자 경험을 향상시켰습니다.\n\n# 해지로 가는 길\n\nFound에서 우리의 지도원칙 중 하나는 완벽보다 반복인데, 이것이 React Query와의 관계를 가장 잘 대변한 것 같습니다. React Query로 일부 초기 문제를 해결했지만, 아직 개선할 부분이 몇 가지 남아 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n┌──────────────┬──────────────────────────────────────────────────────────────────────────────────────────────────────┐\n│ 본문 │\n├──────────────┼──────────────────────────────────────────────────────────────────────────────────────────────────────┤\n│ Refetch가 실패하면 어떻게 될까요? 간단한 오류 메시지는 충분한 경험인가요? 사용자의 건강과 관련된 상황에서 실패는 심각한 결과로 이어질 수 있습니다. │\n│ 이와 같은 이유로 모바일 앱을 개선하는 과정에서 현재 사용 중인 React Query를 통해 서버 상태를 신뢰할 수 있고 반응적으로 만드는 것이 목표입니다. │\n│ │\n│ (주의: 실제로 인간 파트너가 있긴 하지만, 아마도 React Query와 더 많은 시간을 보낼 것입니다) │\n└──────────────┴──────────────────────────────────────────────────────────────────────────────────────────────────────┘\n","ogImage":{"url":"/assets/img/2024-06-22-ReactQueryReactNativeALoveStoryatFound_0.png"},"coverImage":"/assets/img/2024-06-22-ReactQueryReactNativeALoveStoryatFound_0.png","tag":["Tech"],"readingTime":14},{"title":"Flutter에서 No MediaQuery widget found 오류 해결 방법","description":"","date":"2024-06-22 23:27","slug":"2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter","content":"\n플러터 개발자들은 개발 과정 중에 종종 'No MediaQuery widget found' 메시지를 마주하게 됩니다. 특히 초보자들에게는 이 오류가 혼란스러울 수 있습니다. 이 글에서는 이 오류의 원인을 살펴보고, 쉽게 이해할 수 있는 단계와 설명으로 해결하는 방법에 대해 알아보겠습니다.\n\n## MediaQuery 위젯 이해하기\n\n플러터의 MediaQuery 위젯은 화면의 크기, 디바이스의 픽셀 비율 및 기타 화면 관련 요소에 대한 정보를 제공합니다. 위젯은 이 정보를 활용하여 레이아웃 및 스타일링에 대한 결정을 내릴 수 있습니다. 그러나 MediaQuery.of(context)를 호출하여 크기 정보에 의존하는 위젯이 MediaQuery 내부에 배치되지 않았을 경우 'No MediaQuery widget found' 오류가 발생합니다.\n\n## 오류를 유발하는 전형적인 시나리오들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 다음과 같은 시나리오 중 하나에서 오류가 발생합니다:\n\n- MediaQuery에 의존하는 위젯을 사용하지만 MediaQuery가 제공되지 않는 컨텍스트에 배치하는 경우, 예를 들어 Padding, SafeArea 또는 AspectRatio와 같은 경우\n- MediaQuery.of(context)에 의존하는 사용자 정의 위젯을 만들지만 Material App이나 WidgetsApp으로 감싸놓지 않은 경우\n\n## 오류 수정 방법\n\n## 1. MaterialApp으로 감싸기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위젯 트리를 MaterialApp로 래핑하는 것이 가장 일반적인 해결책입니다. 예를 들어:\n\n```js\nvoid main() {\n  runApp(MaterialApp(\n    home: MyHomePage(),\n  ));\n}\n```\n\n이렇게 하면 모든 하위 위젯에서 MediaQuery를 사용할 수 있습니다.\n\n## 2. Using WidgetsApp\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 Material 컴포넌트를 사용하지 않는다면 대신 WidgetsApp을 사용할 수도 있어요:\n\n```js\nvoid main() {\n  runApp(WidgetsApp(\n    home: MyHomePage(),\n    color: Colors.blue,\n  ));\n}\n```\n\nWidgetsApp은 후손에 MediaQuery를 동일하게 제공해줍니다.\n\n### 3. BuildContext 무결성 보장하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n항상 MediaQuery.of(context)에서 사용하는 BuildContext가 MaterialApp 또는 WidgetsApp 아래에 있는 위젯에서 왔는지 확인해주세요.\n\n```js\nclass MyHomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    final mediaQueryData = MediaQuery.of(context);\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"My Home Page\"),\n      ),\n      body: Center(\n        child: Text(\"Screen Width: ${mediaQueryData.size.width}\"),\n      ),\n    );\n  }\n}\n```\n\n## 결론\n\nFlutter에서 'No MediaQuery widget found' 오류는 위젯 트리가 적절하게 MaterialApp 또는 WidgetsApp으로 래핑되어 있는지 확인함으로써 쉽게 해결할 수 있습니다. MediaQuery를 사용하는 맥락을 이해하여 이 흔한 함정을 피하는 것이 중요합니다. 위에서 설명한 단계를 따르면 이 오류를 만남 없이 Flutter 애플리케이션에서 MediaQuery를 효과적으로 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoFixtheNoMediaQuerywidgetfoundErrorinFlutter_0.png","tag":["Tech"],"readingTime":4},{"title":"RPC 초보자를 위한 완벽 가이드 원격 프로시져 호출 쉽게 이해하기","description":"","date":"2024-06-22 23:25","slug":"2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide","content":"\n![RPC Image 1](/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_0.png)\n\n![RPC Image 2](/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_1.png)\n\n# 원격 프로시저 호출(RPC)이란?\n\nRPC는 프로그램이 로컬 프로시저 호출과 마찬가지로 원격 서버(다른 주소 공간에 있는 서버)에서 프로시저(코드 블록)를 실행할 수 있는 기술입니다. 이는 네트워크 통신의 복잡성을 추상화하여 개발자가 기본 네트워킹 세부사항에 대해 과도하게 걱정하지 않고 분산 애플리케이션을 작성할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 원격 프로시저란 무엇인가요?\n\n원격 프로시저는 다른 주소 공간에 위치한 코드 블록 또는 함수로, 일반적으로 클라이언트라고 불리는 다른 곳에 위치한 프로그램이나 프로세스에 의해 호출되고 실행될 수 있는 기능입니다.\n\n# 원격 프로시저의 주요 특징:\n\n- 원격 시스템에 위치: 원격 프로시저는 실행을 초기화하는 클라이언트와 비교하여 다른 기계, 주소 공간 또는 서버에 위치합니다.\n- 원격 클라이언트 호출 가능: 클라이언트는 이 프로시저를 로컬 함수 또는 메소드 호출인 것처럼 원격 위치에서 호출하고 실행할 수 있습니다.\n- 추상화된 통신: 클라이언트와 원격 프로시저 간의 통신은 추상화되어 있어, 클라이언트가 저수준 네트워킹 세부사항을 처리해야 할 필요 없이 원격 프로시저와 상호작용할 수 있습니다.\n- 투명한 호출: 원격 프로시저를 호출하는 클라이언트는 일반적으로 로컬 프로시저 호출과 유사하게 보이도록 프로그래밍 언어 구조를 사용하며, 실제로는 원격으로 실행됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# RPC의 주요 구성 요소\n\n- 클라이언트: 원격 서버에서 서비스를 요청하여 RPC를 시작하는 프로그램 또는 프로세스입니다.\n- 서버: 요청된 서비스를 제공하는 프로그램 또는 프로세스입니다. 클라이언트는 서버로부터 수신된 RPC 요청을 청취하고 해당 절차를 실행합니다.\n- Stub: 클라이언트 프록시라고도 불립니다. 이는 원격 서비스의 로컬 표현입니다. 클라이언트는 스텁과 마치 실제 서비스인 것처럼 상호작용하며, 스텁은 통신 세부 정보를 처리합니다.\n- Skeleton: 서버 프록시라고도 불립니다. 클라이언트에게 서버의 인터페이스를 나타냅니다. 들어오는 RPC 요청을 받아들이고 매개변수를 해제하며 서버에서 적절한 절차를 호출합니다.\n- 통신 프로토콜: 클라이언트와 서버 간의 메시지 교환 규칙 및 형식을 정의합니다. HTTP, TCP/IP, gRPC와 같은 프로토콜이 RPC에 널리 사용됩니다.\n\n# RPC 작동 방식\n\n클라이언트가 원격 절차를 호출하면 일반적으로 다음 단계가 발생합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 클라이언트 Stub 호출: 클라이언트는 로컬로 보이지만 실제로 원격 프로시저를 대표하는 스텁을 호출합니다. 스텁은 실행할 프로시저 및 해당 매개변수에 대한 정보를 포함한 RPC 요청을 준비합니다.\n- 마샬링: 매개변수 및 메소드 정보는 직렬화되어 (전송을 위한 형식으로 변환되어) 네트워크를 통해 전송될 수 있도록 준비됩니다.\n- 통신: 클라이언트는 선택한 통신 프로토콜을 사용하여 RPC 요청을 서버로 보냅니다.\n- 서버 스켈레톤 처리: 서버의 스켈레톤은 요청을 받아 데이터를 해제하고 (디마샬링) 요청된 프로시저를 결정합니다.\n- 로컬 프로시저 실행: 서버는 제공된 매개변수를 사용하여 요청된 프로시저를 실행합니다.\n- 응답 준비: 서버는 응답 (있는 경우)을 전송을 위한 형식으로 마샬링합니다.\n- 응답 전송: 서버는 클라이언트에게 응답을 다시 보냅니다.\n- 언마샬링: 클라이언트 Stub은 응답을 수신하고, 이를 언마샬하고, 로컬 프로시저 호출처럼 결과를 클라이언트에게 반환합니다.\n\n# 시나리오 예시\n\n클라이언트 프로그램이 서버에서 호스팅되는 원격 프로시저를 사용하여 숫자의 제곱을 계산해야 하는 상황을 상상해보세요:\n\n- 클라이언트 요청: 클라이언트는 서버에게 특정 숫자, 예를 들어 5의 제곱을 계산해 달라는 요청을 보냅니다.\n- 원격 프로시저 실행: 서버는 요청을 받아 \"제곱\\_계산\" 프로시저를 찾아 계산을 수행하고 (이 경우 25), 응답을 준비합니다.\n- 응답 전송: 서버는 계산된 결과 25를 요청한 클라이언트에게 다시 보냅니다.\n- 클라이언트 수신: 클라이언트는 응답을 받아서 원격 프로시저 실행으로부터 얻은 결과를 사용하여 작업을 계속할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 소프트웨어 개발 및 분산 시스템에서의 RPC 역할\n\n## 1. 네트워크 통신의 추상화:\n\n- 간소화된 통신: RPC는 네트워크 통신의 복잡성을 추상화합니다. 이를 통해 개발자들은 분산 애플리케이션의 개발을 단순화하기 위해 로컬처럼 원격 시스템에서 절차를 호출할 수 있습니다.\n- 사용 편의성: RPC를 사용함으로써 개발자들은 로우 레벨 네트워킹 세부 사항 대신에 애플리케이션 논리에 집중할 수 있습니다.\n\n## 2. 상호 운용성:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Cross-platform 통신: RPC는 다른 시스템 및 프로그래밍 언어간의 통신을 가능하게 합니다. 이 유연성은 서로 다른 환경 간 상호 작용이 필요한 애플리케이션을 개발할 때 중요합니다.\n\n## 3. 모듈식 및 확장 가능한 아키텍처:\n\n- 모듈성: RPC는 복잡한 시스템을 관리 가능한 구성 요소로 분해하여 모듈식 소프트웨어 설계를 용이하게 합니다. 개발자는 특정 작업을 수행하는 서비스를 만들고 이를 결합하여 더 크고 확장 가능한 시스템을 형성할 수 있습니다.\n- 확장성: RPC는 서비스를 여러 서버 또는 시스템에 분산하여 확장을 지원합니다. 이를 통해 리소스 활용과 성능 최적화가 가능해집니다.\n\n## 4. 원격 서비스 접근:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 원격 리소스 액세스: RPC를 통해 서로 다른 기계나 서버에 위치한 서비스 및 리소스에 액세스할 수 있습니다. 특히 특정 기능이나 데이터가 별도의 서버나 위치에 있을 때 유용합니다.\n\n## 5. 클라이언트-서버 상호작용:\n\n- 클라이언트-서버 모델: RPC는 클라이언트-서버 모델을 구현하는 데 중요한 역할을 합니다. 여기서 클라이언트는 서버로부터 서비스나 리소스를 요청하게 됩니다. 이는 다양한 클라이언트-서버 아키텍처의 기초를 형성합니다.\n\n## 6. 재사용성과 캡슐화:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 코드 재사용성: RPC는 개발자가 여러 클라이언트에서 호출할 수있는 서비스를 생성할 수 있도록 함으로써 코드 재사용성을 촉진합니다.\n- 캡슐화: 원격 프로시저 실행의 구현 세부 정보를 캡슐화하여 클라이언트와 서버 사이의 더 깨끗한 분리를 제공합니다.\n\n## 7. 분산 컴퓨팅:\n\n- 분산 응용 프로그램: RPC는 분산 컴퓨팅의 중요한 부분으로, 여러 기기나 위치에 걸친 응용 프로그램 개발을 용이하게 합니다.\n\n## 8. 서비스 지향 아키텍처(SOA) 및 마이크로서비스:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- SOA와 Microservices: 서비스 지향 아키텍처 및 마이크로서비스에서 RPC는 서비스 또는 마이크로서비스 간의 통신을 정의하고 구현하는 데 도움이 됩니다.\n\n## 9. 효율적인 자원 활용:\n\n- 자원 최적화: RPC는 다른 기계 또는 서버간 작업 분산을 통해 효율적인 자원 활용을 가능하게 합니다. 작업 부하를 균형 있게 분배하는 것이 가능합니다.\n\n## 10. 실시간 통신:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 실시간 상호 작용: RPC는 클라이언트와 서버 간에 실시간 통신을 지원하여 즉각적인 응답과 상호 작용이 가능합니다.\n\n## RPC의 종류\n\n다양한 종류의 RPC가 있습니다:\n\n- 동기식 대비 비동기식: 동기식 RPC는 응답을 받을 때까지 대기하며 비동기식 RPC는 클라이언트가 즉시 응답을 기다리지 않고 작업을 계속할 수 있게 합니다.\n- 블로킹 대비 논블로킹: 블로킹 RPC는 클라이언트가 응답을 받기 전까지 대기하도록 하지만, 논블로킹 RPC는 클라이언트가 응답을 기다리지 않고 계속할 수 있게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 일반적인 RPC 프레임워크\n\n- gRPC: Google이 개발한 gRPC는 HTTP/2를 전송에 사용하고 직렬화에 Protocol Buffers를 사용하는 오픈 소스 RPC 프레임워크입니다.\n- Apache Thrift: Facebook이 개발한 RPC 프레임워크로, 다양한 프로그래밍 언어와 전송 방법을 지원합니다.\n- Java RMI (원격 메서드 호출): Java 전용 RPC 메커니즘으로 Java 객체간 원격 통신을 지원합니다.\n\n# 왜 원격 프로시저가 존재하는가\n\n원격 프로시저는 네트워크 환경에서 서로 다른 시스템이나 프로세스 간의 통신과 코드 실행을 원활하게하기 위해 도입되었습니다. 원격 프로시저가 도입된 이유는 여러 가지가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 분산 컴퓨팅:\n\n- 자원 활용: 원격 프로시저를 통해 다른 기계 또는 시스템 간의 자원 활용이 가능해집니다. 이를 통해 계산 작업을 분산시켜 전체 시스템 성능과 효율성을 향상시킬 수 있습니다.\n\n# 2. 연결된 시스템:\n\n- 상호 운용성: 서로 다른 하드웨어 및 소프트웨어 플랫폼이 혼재된 환경에서 원격 프로시저가 상호 운용성과 통신을 가능케 합니다. 이를 통해 기술적인 차이에 상관없이 정보와 기능을 교환할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 모듈화와 재사용성:\n\n- 모듈화: 원격 프로시저는 시스템 설계에 모듈화 접근법을 장려합니다. 개발자들이 별도의 서비스를 만들어 여러 응용 프로그램이나 구성 요소에서 재사용할 수 있도록 해줍니다. 이는 코드 재사용성을 향상시킵니다.\n\n# 4. 중앙화된 서비스:\n\n- 기능의 중앙화: 원격 프로시저는 특정 기능이나 서비스의 중앙화를 가능하게 합니다. 예를 들어 데이터베이스 서버는 데이터 검색이나 조작을 위한 원격 프로시저를 제공하여 여러 클라이언트에 서비스를 제공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 구성 요소 분리:\n\n- 클라이언트와 서버 분리: 원격 프로시저가 네트워크 통신의 세부 사항을 추상화함으로써 클라이언트를 서버에서 분리합니다. 이 분리는 다른 구성 요소에 영향을 미치지 않고 한 구성 요소의 변경 또는 업데이트를 허용하여 시스템 유연성을 향상시킵니다.\n\n# 6. 클라이언트-서버 모델:\n\n- 클라이언트-서버 통신: 원격 프로시저는 클라이언트-서버 통신 모델의 필수 요소입니다. 이를 통해 클라이언트는 서버로부터 서비스 또는 기능을 요청하고 수신하여 많은 네트워크 응용 프로그램의 기초를 형성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7. 확장성 및 부하 분산:\n\n- 확장성: 원격 절차는 작업을 여러 서버 또는 시스템에 분산하여 작업 부하를 균형있게 분배하여 시스템 확장성을 향상시킵니다.\n\n# 8. 기능 캡슐화:\n\n- 캡슐화: 원격 절차는 특정 기능의 구현 세부 사항을 캡슐화하여 클라이언트와 서버 사이의 깔끔한 분리를 제공합니다. 이 분리는 개발과 유지보수를 간단하게 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 9. 실시간 상호작용:\n\n- 실시간 통신: 원격 프로시저를 통해 다양한 구성 요소나 시스템 간에 실시간 상호작용이 가능해지며, 분산 환경에서 즉각적인 응답과 매끄러운 통신이 가능합니다.\n\n# 도전과 고려 사항\n\n- 보안: 안전한 통신을 보장하고 원격 프로시저에 대한 무단 액세스를 방지합니다.\n- 신뢰성: 네트워크 장애, 시간 초과 처리, 원격 호출의 일관성을 보장합니다.\n- 성능: 네트워크 지연 시간과 데이터 전송을 고려하여 RPC 호출을 속도와 효율성을 위해 최적화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 모바일 앱 개발에서 원격 프로시저 호출이 필요한 이유는 무엇일까요?\n\n모바일 앱 개발에서 원격 프로시저 호출(RPC)을 도입하는 것은 여러 가지 경우에 유리할 수 있습니다:\n\n# 1. 백엔드 서비스 통합\n\n- 서버 측 기능 액세스: 모바일 앱은 종종 사용자 인증, 데이터 검색, 거래 처리 또는 리소스 액세스와 같은 다양한 기능을 위해 백엔드 서버와 상호 작용해야 합니다. RPC를 통해 모바일 앱과 백엔드 서비스 간에 통신을 원활하게 할 수 있어 서버 측 기능을 신속하게 통합할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. Cross-Platform Communication\n\n- 상호 운용성: 모바일 앱은 다른 기술이나 언어로 구축된 서비스나 시스템과 통신해야 할 수 있습니다. RPC는 이러한 다양한 플랫폼 간의 간극을 메꾸어 상호 운용성을 가능하게 하며 모바일 앱이 다양한 시스템과 상호 작용할 수 있도록 합니다.\n\n# 3. 모듈식 개발과 마이크로서비스\n\n- 마이크로서비스 통합: 마이크로서비스 아키텍처에서 모바일 앱은 RPC를 사용하여 이러한 서비스와 상호 작용할 수 있으며 모듈식 개발을 가능하게 하고 이러한 서비스가 제공하는 특정 기능을 활용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4. 원격 처리 및 오프로딩:\n\n- 리소스 집약적 작업: 모바일 기기는 처리 능력이나 배터리 수명에 한계를 가질 수 있습니다. RPC를 사용하면 계산적으로 요구되는 작업을 원격 서버로 오프로딩하여 모바일 기기를 과부하 없이 원활한 앱 성능을 보장할 수 있습니다.\n\n# 원격 프로시저 호출의 대안\n\n원격 프로시저 호출(RPC)의 대안으로 Representational State Transfer(REST) API 및 해당하는 메커니즘인 HTTP 기반 통신이나 웹 서비스를 활용할 수 있습니다. 이러한 대안은 시스템 또는 구성 요소 간의 통신을 원활하게 하기 위한 다른 접근 방식을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. RESTful APIs:\n\n- 상태 정보 유지: RESTful API는 HTTP 메소드(GET, POST, PUT, DELETE)를 사용하여 URL(Uniform Resource Locator)로 식별된 리소스에 대한 CRUD(Create, Read, Update, Delete) 작업을 수행합니다.\n- 리소스 중심 설계: REST API는 리소스 지향 아키텍처를 따르며, 데이터 엔티티를 표준화된 URL을 통해 접근할 수 있는 리소스로 취급합니다.\n- JSON 또는 XML 사용: 일반적으로 클라이언트와 서버 간 데이터 교환에 JSON 또는 XML과 같은 텍스트 기반 형식을 사용합니다.\n\n# 2. 웹 서비스 (SOAP, WSDL 및 XML-RPC):\n\n- SOAP (Simple Object Access Protocol): 웹 서비스에서 구조화된 정보를 교환하기 위해 XML 메시지 형식 및 HTTP, SMTP 또는 기타 전송 프로토콜을 메시지 협상에 사용하는 프로토콜입니다.\n- WSDL (Web Services Description Language): 웹 서비스, 메소드, 매개변수 및 통신 프로토콜을 설명하는 데 사용되는 XML 기반 언어입니다.\n- XML-RPC: RPC와 유사하게, XML-RPC는 XML을 데이터 교환 형식으로 사용하여 네트워크를 통해 프로시저를 실행할 수 있게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# RPC와의 주요 차이점\n\n- 통신 패러다임: RPC는 원격 메서드 호출에 중점을 두는 반면, REST 및 웹 서비스(SOAP, XML-RPC)는 통신을 위해 리소스 중심 접근 방식이나 표준화된 프로토콜을 따릅니다.\n- 프로토콜과 형식: RPC 프레임워크는 일반적으로 이진 직렬화 형식을 사용하고 자체 통신 프로토콜을 가질 수 있습니다. 반면에 REST API는 주로 HTTP 또는 HTTPS를 통해 JSON 또는 XML과 같은 텍스트 기반 형식을 사용합니다.\n- 상태 비저장 vs. 상태 유지: RESTful API는 설계상 상태 비저장이며, SOAP와 같은 일부 웹 서비스는 세션과 같은 기능을 통해 상태 유지를 유지할 수 있습니다.\n\n# RPC 대안 선택 시기\n\n- 표준화와 상호 운용성: 여러 시스템이나 플랫폼 간의 표준화와 상호 운용성이 중요할 때는 REST API가 적합합니다.\n- 웹 통합: 웹 중심 애플리케이션이나 간단하고 확장 가능한 통신이 필요한 경우, RESTful API가 널리 사용되고 있어 사용이 편리합니다.\n- 의미론적 인터페이스: 인터페이스가 인간이 읽기 쉽고 이해하기 쉬워야 할 때, RESTful API의 리소스 중심 설계와 자기 설명적 URL이 인기 있는 선택지입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# RPC 또는 REST를 선택하는 시점\n\n- RPC: 더 직접적이고 메소드 중심의 통신 스타일이 선호되는 경우에 적합합니다. 특히 서로 강하게 연결된 시스템이나 프로그래밍 언어 중립성이 필요한 경우에 적합합니다.\n- REST: 상호 운용성, 간결함, 확장성 및 웹 표준을 활용하는 능력이 중요한 상황에서 선호됩니다. RESTful API는 웹 중심 애플리케이션과 상태가 없는 통신 및 리소스 중심 설계를 선호할 때 일반적으로 사용됩니다.\n\n# RPC 또는 웹소켓을 사용하는 시점\n\n- RPC: 시스템 간 직접적인 메소드 호출이 필요한 경우 적합하며 특히 동기화되고 메소드 중심의 통신 패턴이 필요한 시나리오에서 적합합니다.\n- 웹소켓: 실시간 애플리케이션이 필요한 경우, 낮은 지연 시간과 양방향, 이벤트 중심의 통신이 필요한 경우에 선호됩니다. 라이브 업데이트, 게임, 채팅 애플리케이션 또는 영구적인 완전 이중 방향 연결이 필요한 시나리오 등이 해당됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n원격 프로시저 호출은 분산 애플리케이션이 원활하게 통신할 수 있게 하는 강력한 개념입니다. 스텁(stubs), 스켈레톤(skeletons) 및 기반이 되는 통신 프로토콜을 이해하는 것은 분산 시스템에서 작업하는 개발자들에게 중요합니다. RPC가 제공하는 유연성과 사용 편의성은 현대적이고 확장 가능하며 서로 연결된 애플리케이션의 개발에 상당한 기여를 합니다. RPC를 사용하면 개발자들은 기본 네트워킹 복잡성을 걱정하지 않고 견고하고 서로 연결된 시스템을 구축하는 데 집중할 수 있습니다.\n\n즐거운 코딩!\n\n👏🏽 👏🏽 이 이야기에 CLAPS를 보내주세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉🏽 다가오는 기사를 구독해보세요\n\n💰 무료 모바일 개발 튜토리얼에 접속해보세요\n\n🔔 더 많은 소식을 확인하기 위해 팔로우해주세요\n\n다음 기사에서 만나요 👋\n","ogImage":{"url":"/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-22-DemystifyingRemoteProcedureCallsRPCforBeginnersAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":15},{"title":"RxSwift 심층 탐구 메커니즘 분석","description":"","date":"2024-06-22 23:24","slug":"2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms","content":"\n# 목적\n\n이 튜토리얼의 주요 목적은 RxSwift의 핵심 구성 요소에 대한 심층적인 이해를 제공하는 것입니다. RxSwift 뒷면의 구현에 주로 초점을 맞춰 설명합니다.\n\n이 게시물을 읽은 후에는 관찰 가능한(observables)이 무엇인지, 구독(subscriptions)이 무엇인지, 관찰 가능한이 어떻게 작동하는지에 대한 명확한 이해가 있을 것으로 기대됩니다.\n\n이 튜토리얼은 RxSwift에 대한 일부 경험이 있다고 가정하고 있습니다. 이는 이해하기 쉽게 만들어줄 것입니다. 저희 zen8labs에서는 RxSwift를 주로 멤버들에게 교육하고 있으며, Serg Dort의 멋진 튜토리얼 \"Learn Rx by implementing Observable\"을 주의 깊게 참고하도록 강력히 권장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSerg Dort님께 이 유용한 튜토리얼을 작성해 주신 것에 대해 진심으로 감사드립니다. 이 튜토리얼은 RxSwift의 구현을 간단하게 설명하여 RxSwift의 주요 구성 요소와 그들이 어떻게 함께 작동하는지 이해하기 쉽게 만들었습니다.\n\n한 번 다시, 이 튜토리얼을 주의 깊게 읽고 코드를 단계별로 따라 하시기를 부탁드립니다. 믿어 주세요, 정말 값어치가 있을 겁니다.\n\n정말 솔직히 말씀드리자면, RxSwift의 내부 작동 방식을 알 필요는 없습니다. 단지 옵저버블이 요소를 발행할 때, 정지할 때, 오류가 발생할 때, 옵저버블이 발행할 수 있는 요소의 개수, 그리고 구독을 해제해야 하는 시점에 집중하면 됩니다. 이러한 것들을 잘 이해하면 어떤 문제도 없이 RxSwift를 사용할 수 있습니다.\n\n하지만 제 경우에는 항상 사용 중인 것들이 어떤 일이 벌어지는지 이해하고 싶습니다. 제가 무엇을 올바르게 수행하고 있는지 확인하는 가장 좋은 방법입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 질문들\n\n간단한 예제를 살펴봅시다:\n\n![이미지](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_0.png)\n\n이것은 기본적인 예제입니다. 그러나 RxSwift의 중요한 개념들을 대부분 포함하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에는 많은 숨겨진 세부 사항이 있습니다.\n\n이에 대한 몇 가지 질문이 있습니다:\n\n- Observable은 추상 클래스이고 Disposable은 프로토콜입니다. 그래서 여기서 실제로 생성되는 유형은 무엇인가요?\n- 이러한 오퍼레이터들은 실제로 어떻게 작동합니까?\n- 데이터는 이러한 오퍼레이터들을 통해 어떻게 처리됩니까?\n- 오퍼레이터들은 어떻게 함께 구성되는가요?\n- 왜 우리는 로직을 실행하기 위해 구독해야 하죠?\n- 구독은 언제 끝나나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 질문에 대답하려면 이 연산자들의 구현을 살펴보겠습니다.\n\n## 구현\n\n연산자의 경우:\n\n![이미지](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n맵 연산자:\n\n![맵 연산자](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_2.png)\n\n필터 연산자:\n\n![필터 연산자](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해 주세요.\n\n| header1 | header2 |\n| ------- | ------- |\n| data1   | data2   |\n| data3   | data4   |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(1) Producer 클래스는 실제로 Observable 클래스의 하위 클래스이므로 RxSwift 연산자는 기본적으로 Producer의 다른 하위 유형을 반환하는 메서드입니다.\n\n(2) Producer에 구독할 때마다 SinkDisposer가 반환됩니다. 사실 Observable 클래스는 추상 유형이며 해당 인스턴스를 직접적으로 생성하지 않습니다. 대신, 우리는 연산자를 사용하여 observables을 만듭니다. 따라서 우리가 일상적으로 프로그래밍에서 사용하는 observables 대부분은 사실 Producer의 하위 클래스입니다. 따라서 observables에 구독할 때 대부분의 구독은 SinkDisposer입니다. 예시의 구독 또한 SinkDisposer입니다.\n\n(3) Producer 클래스에는 \"run\"이라는 내부 추상 메서드가 있습니다. 이는 Producer의 하위 클래스가 비즈니스 로직을 구현해야 하는 곳입니다. \"run\" 메서드는 항상 sink와 subscription 두 가지를 반환합니다.\n\n이제, 예시에서 네 가지 observables(ObservableSequence, Map, Filter, TakeCount)의 구현을 탐구하여 sink와 구독이 무엇인지에 대한 질문에 답해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nObservableSequence\n\n![Image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_6.png)\n\nMap\n\n![Image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFilter\n\n![Filter Image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_8.png)\n\nTake\n\n![Take Image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_9.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이상한가요?\n\n이 네 가지 옵저버블의 run 메서드에 주목해 봅시다. 각 유형의 옵저버블에는 해당하는 Sink 클래스가 있다는 것을 알 수 있어요: ObservableSequence에는 ObservableSequenceSink, Map에는 MapSink, Filter에는 FilterSink, TakeCount에는 TakeCountSink가 있어요. 그리고 RxSwift의 다른 옵저버블에도 마찬가지예요.\n\n게다가, 옵저버블 자체는 어떤 로직도 실행하지 않음을 알 수 있어요; 그저 옵저버블 로직을 위한 디자인 또는 템플릿으로 동작할 뿐이에요. 정작 모든 일을 하는 사람은 Sink라는 거죠.\n\n이를 시각화해 보면, 옵저버블이 기계의 청사진이라고 상상해 보세요. 반면 Sink 인스턴스는 그 청사진을 기반으로 구축된 실제 기계에요. 사실 Sink는 RxSwift에서 일어나는 모든 마법 같은 일들이 일어나는 곳이에요. 그것은 우리 관찰자에 대한 참조를 유지하고, 옵저버블 로직을 실행하며, 결과 이벤트를 관찰자에게 전달해요. RxSwift에서 특정 유형의 옵저버블이 어떻게 작동하는지, 그것이 처리되는 데이터를 어떻게 살펴야 하는지를 정말로 이해하려면 해당 옵저버블의 Sink를 살펴보면 돼요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또 다른 중요한 점은 run 메서드에서 Observable을 구독할 때만 Sink 인스턴스가 생성된다는 것입니다. 이것이 Observable의 논리가 구독되어야만 실행되고, Observable을 구독할 때마다 논리가 다시 실행되는 이유를 설명합니다. 이는 새로운 Sink 인스턴스가 생성되기 때문에 발생하는 것입니다.\n\nProducer의 run 메서드가 항상 반환하는 하나 더의 구성 요소는 subscription입니다. 그렇다면 subscription이란 무엇일까요?\n\n이 질문에 답변하기 전에, RxSwift가 조합 가능하다는 점을 기억해 두세요. 즉, 여러 개의 각기 다른 유형의 Observable을 한 개의 Observable로 결합할 수 있다는 것이죠, 마치 다수의 객차로 구성된 기차와 유사합니다.\n\n![image](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_10.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 종류의 observable이 있습니다: Generation observables과 Transformation observables.\n\n- Generation observables는 자체적으로 이벤트를 생성하는 observables입니다. 예를 들어, create, of, from... 연산자에서 반환된 observables입니다. Generation observable은 항상 모든 파워를 생성하는 기차 머리와 같은 역할을 합니다. 어떤 이벤트도 Generation observable에서 시작됩니다. 위의 ObservableSequence 구현을 살펴보면, 구독은 sink 인스턴스를 실행한 결과입니다. 구독은 Sink 실행을 관리하기 위해 할당된 리소스를 관리하는 Disposable 프로토콜을 구현한 형식입니다. Sink가 생성을 완료하면, 구독은 Sink가 할당한 모든 리소스를 해제하기 위해 삭제됩니다.\n- Transformation observables는 원본으로부터 받은 이벤트를 observable로 변환하는 observables입니다. 예를 들어, map, filter, take... 연산자에서 반환된 observables입니다. Map, Filter, TakeCount 구현을 살펴봅시다. 각 클래스는 항상 기본적으로 이전 체인 내의 observable에 대한 참조인 원본 observable을 갖습니다. 구독은 sink를 원본 observable에 구독하는 결과입니다. 그리고 원본 observable이 사실상 다른 Producer인 경우, 구독도 SinkDisposer입니다. 이것은 RxSwift가 여러 연산자를 연결하는 방법입니다.\n\n모든 것을 연결하면, 다음과 같이 예시를 시각화할 수 있습니다:\n\n![이미지](/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 우리 예시에서 발생한 일입니다:\n\n1. 생성 단계:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제로 나오는 결과 observable은 TakeCount입니다. TakeCount는 Filter가 있는 observable 소스를 가지고 있습니다. Filter에는 observable 소스인 Map이 있습니다. Map은 observable 소스인 ObservableSequence를 가지고 있습니다. ObservableSequence는 자체적으로 이벤트를 생성할 수 있는 생성 observable입니다.\n\n2. 구독 단계:\n\n결과 observable에 구독하면 실제로 TakeCount observable에 구독하게 됩니다. TakeCountSink를 만들어 TakeCount의 로직을 실행하고 Filter observable을 해당 Sink에 구독하여 구독을 만듭니다. Sink 및 구독은 TakeCount에 구독을 할 때 반환된 SinkDisposer에 의해 관리됩니다. 예시에서 해당 구독은 바로 이 SinkDisposer입니다.\n\nFilter, Map 및 ObservableSequence에 대해서도 동일한 동작이 발생합니다. 각 단계는 자체 Sink 및 SinkDisposer를 만들며, 각 SinkDisposer의 구독은 이전 단계의 SinkDisposer입니다. ObservableSequence는 생성 observable이므로 ObservableSequenceSink 자체를 실행하기 위해 할당된 자원을 관리하는 인스턴스로 구독하는 것이며, 그 외의 단계에서 발생하는 것과는 다릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### 3. Running phase:\n\nObservableSequenceSink가 이벤트를 방출하기 시작하고, 그 observer는 MapSink입니다. MapSink는 ObservableSequenceSink에서 이벤트를 가져와서 작업을 처리하고(2로 곱함), 그 결과를 그 observer인 FilterSink에게 방출하고, 이런 식으로 계속됩니다... 마지막 싱크는 TakeCountSink이며, 이는 예시에서 값이 프린트되는 클로저에 이벤트를 방출합니다.\n\n### 4. Dispose phase:\n\n작업을 마치면 구독을 해제합니다. 실제로 TakeCount의 SinkDisposer입니다. 그러면 이 SinkDisposer가 TakeCountSink와 그 구독을 해제하고, 이는 Filter의 SinkDisposer의 구독인 것입니다. ObservableSequence의 마지막 SinkDisposer에 이르기까지 해제 프로세스가 계속됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이것이 RxSwift의 전체 그림입니다. 이 게시물이 RxSwift 내부에서 무엇이 발생했는지에 대해 더 깊은 이해를 가지는 데 도움이 되기를 바랍니다. 다른 주제에 관심이 있다면, 여기에서 유용한 기술 정보를 확인해보세요!\n\n토안 누옌, 시니어 모바일 엔지니어\n","ogImage":{"url":"/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_0.png"},"coverImage":"/assets/img/2024-06-22-AdeepcutintoRxSwiftExploreitsmechanisms_0.png","tag":["Tech"],"readingTime":11}],"page":"26","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"26"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>