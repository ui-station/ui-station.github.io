<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/3" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법" href="/post/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024 최신 PyTorch 치트 시트 " href="/post/2024-07-01-PyTorchCheatSheet"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024 최신 PyTorch 치트 시트 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-PyTorchCheatSheet_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024 최신 PyTorch 치트 시트 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024 최신 PyTorch 치트 시트 </strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python weakref 모듈을 사용한 약한 참조 가이드" href="/post/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python weakref 모듈을 사용한 약한 참조 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python weakref 모듈을 사용한 약한 참조 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Python weakref 모듈을 사용한 약한 참조 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 시각화로 스토리텔링 하는 방법" href="/post/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 시각화로 스토리텔링 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 시각화로 스토리텔링 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">데이터 시각화로 스토리텔링 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">55<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="API를 활용한 증분 데이터 로딩 스크립트를 작성할 때 반드시 해결해야 할 3가지 필수 질문" href="/post/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="API를 활용한 증분 데이터 로딩 스크립트를 작성할 때 반드시 해결해야 할 3가지 필수 질문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="API를 활용한 증분 데이터 로딩 스크립트를 작성할 때 반드시 해결해야 할 3가지 필수 질문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">API를 활용한 증분 데이터 로딩 스크립트를 작성할 때 반드시 해결해야 할 3가지 필수 질문</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Microsoft DSA 면접 질문 모음" href="/post/2024-07-01-MicrosoftDSAInterviewQuestions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Microsoft DSA 면접 질문 모음" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Microsoft DSA 면접 질문 모음" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Microsoft DSA 면접 질문 모음</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="돈 버는 것 말고도 코딩이 삶을 업그레이드하는 5가지 뜻밖의 방법" href="/post/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="돈 버는 것 말고도 코딩이 삶을 업그레이드하는 5가지 뜻밖의 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="돈 버는 것 말고도 코딩이 삶을 업그레이드하는 5가지 뜻밖의 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">돈 버는 것 말고도 코딩이 삶을 업그레이드하는 5가지 뜻밖의 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="저장된 XSS를 통해 사용자 쿠키를 탈취한 방법" href="/post/2024-07-01-HowIwasabletostealusercookiesviastoredXSS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="저장된 XSS를 통해 사용자 쿠키를 탈취한 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="저장된 XSS를 통해 사용자 쿠키를 탈취한 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">저장된 XSS를 통해 사용자 쿠키를 탈취한 방법</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="독학으로 최고의 프로그래머가 되는 방법 5가지" href="/post/2024-07-01-Howtobecomethebestself-taughtprogrammer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="독학으로 최고의 프로그래머가 되는 방법 5가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-Howtobecomethebestself-taughtprogrammer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="독학으로 최고의 프로그래머가 되는 방법 5가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">독학으로 최고의 프로그래머가 되는 방법 5가지</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프론트엔드 주간 소식 369 2024년 6월 24일  6월 30일" href="/post/2024-07-01-FrontendWeeklyDigest3692430Jun2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프론트엔드 주간 소식 369 2024년 6월 24일  6월 30일" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-FrontendWeeklyDigest3692430Jun2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프론트엔드 주간 소식 369 2024년 6월 24일  6월 30일" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">프론트엔드 주간 소식 369 2024년 6월 24일  6월 30일</strong><div class="PostList_meta__VCFLX"><span class="date">4 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link posts_-active__YVJEi" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법","description":"","date":"2024-07-01 16:09","slug":"2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython","content":"\n\n리즌+액트(ReAct) 에이전트들은 사고의 연쇄를 결합하고 외부 도구에 접근하며 해결책으로 나아가는 능력을 활용하여 복잡한 추론 작업을 수행할 수 있습니다.\n\n에이전트의 중요한 구성 요소는 시스템 프롬프트로, 에이전트의 전반적인 행동을 정의합니다(곧 예시를 볼 것입니다).\n\n처리 과정은 문제의 해결책을 요청하는 사용자 프롬프트로 시작됩니다. 시스템 프롬프트에 따라 에이전트는 문제에 대해 사고하고 해결에 도움이 되는 외부 도구를 적절하게 선택합니다.\n\n에이전트가 도구를 호출하고 응답을 받은 후, 더 많은 처리가 필요한지 판단합니다. 필요하다면 다시 도움을 요청할 수 있습니다. 에이전트는 문제를 해결하고 사용자에게 결과를 반환할 때까지 추론과 조치(도구 호출)를 반복합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 다이어그램에서 과정이 설명되어 있습니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png\" /\u003e\n\nReAct 에이전트의 작동 방식을 설명하는 가장 쉬운 방법은 간단한 사례 연구로 설명하는 것입니다. 아래는 간단한 산술 문제를 해결하는 에이전트의 예시 응답입니다.\n\n우리는 \"20 * 15은 무엇인가요?\" 라는 질문으로 시작해서, 그에 대한 응답으로 에이전트가 '소리내어 생각'하기 시작합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n에이전트의 응답 앞에는 '사고' 레이블이 있는데, 이는 에이전트가 어떻게 해야 하는지 고민합니다. 이 경우, 문제를 해결하기 위해 'calculate' 동작을 사용하기로 결정했습니다('calculate'는 에이전트에 제공된 도구입니다).\n\n다음 응답은 '동작' 레이블로 시작되며, 에이전트가 'calculate' 도구를 사용하여 답변을 검색하는 것을 볼 수 있습니다. 이 후에는 '관찰'이 나오는데, 이는 도구에서의 응답입니다.\n\n마지막 '답변'은 에이전트가 초기 질문과 'calculate' 도구의 출력으로부터 응답을 작성한 결과입니다.\n\n보통 이곳에서 특별하게 벌어지는 일은 없어 보이지만, 에이전트가 우리가 제공한 도구를 사용하고 있다는 점에서 조금은 특별한 점이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것이 ReAct 에이전트의 기본입니다: 에이전트는 이성을 사용하여 행동합니다.\n\n## 반복\n\n더 흥미로워지는 부분은 에이전트가 결론에 도달하지 못했다고 판단하고 다른 이성/행동 시퀀스를 거쳐야 한다는 경우입니다. 에이전트는 유효한 결론에 도달할 때까지 추론/행동 시퀀스를 반복할 수 있습니다.\n\n위의 예시는 사소하지만 기본적인 이벤트 시퀀스를 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좀 더 복잡한 쿼리를 시도해보면 실제 반복을 볼 수 있어요.\n\n저는 다음과 같은 질문을 에이전트에게 했어요: \"농구 팀의 선수 수를 라크로스 팀의 선수 수로 곱하면 얼마가 되나요?\".\n\n이 질문에 대한 답변을 하기 위해 에이전트는 각 스포츠의 선수 수를 찾아 곱해야 해요. 곱셈을 위해 calculate 도구를 사용할 수 있지만, 농구와 라크로스에 대해 알아내기 위해서는 다른 도구가 필요해요 — 위키피디아죠. 위키피디아 도구를 사용하면 에이전트가 어떤 것이든 검색하고 결과를 얻을 수 있어요.\n\n아래에서 에이전트가 만족스러운 답변을 도출하기 전에 생각-행동-관찰 순서를 세 번 거치는 방법을 볼 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 결과를 자세히 읽으시면 에이전트가 결과를 생성하기 전에 이유를 생각하고 도구를 상담하는 방법을 볼 수 있고, 그러면서 지식을 쌓아 가게 됩니다.\n\n# 매우 적은 양의 코드\n\nReAct 에이전트를 구현하는 데 필요한 코드는 놀랍게도 매우 적습니다. 이는 대부분의 작업이 프롬프트에서 수행되기 때문입니다.\n\n그러니까 먼저 그것을 살펴보죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n프롬프트는 문제에 어떻게 접근해야 하는지에 대해 설명하며, 이전에 본 과정의 레이블이 지정된 부분을 반복합니다.\n\n그런 다음 계산 및 위키피디아라는 작업이 설명되고, 예제 세션이 이어집니다.\n\n이 프롬프트는 간단한 예제이며 명확히 시연용으로만 사용됩니다. 프롬프트 설명은 도구의 사용이 하드코딩되어 있으며, 실제 제품 시스템에서는 프로그래밍 방식으로 이를 확장할 수 있어야 합니다. (곧 확인할 것이지만, calculate는 Python 함수 eval()을 사용하여 구현됩니다. 이는 코드 삽입 공격에 매우 취약한 부분이므로 매우 위험한 방법입니다.)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 시점에서 Simon Willison의 작업을 인정해야 할 필요가 있습니다. 이 코드의 많은 부분은 Simon Willison의 작품에 기반합니다 — LLMs를 위한 ReAct 패턴의 간단한 Python 구현 참조 | Simon Willison의 TILs — 해당 코드는 Apache 2 라이선스가 있습니다.\n\n이 코드와 프롬프트의 기본 구조는 Simon의 것이지만, 저는 Anthropic의 Claude 3.5 Sonnet LLM을 사용하도록 수정하고 코드와 프롬프트를 간소화했습니다.\n\n## Claude 3.5\n\nClaude Sonnet 3.5은 Anthropic의 최근 릴리스로, 릴리스 발표에서 \"Claude 3.5 Sonnet은 인텔리전스에 대한 산업 기준을 높여 다양한 평가에서 경쟁 모델과 Claude 3 Opus보다 우월하며, 중급 모델인 Claude 3 Sonnet의 속도와 비용을 가지고 있습니다.\" 라고 설명합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것을 맥락에 맞춰 설명하자면, Anthrop have는 저렴하고 빠른 하이쿠 모델부터 똑똑하지만 더 비싼 오퍼스까지 세 가지 버전의 Claude LLM을 보유하고 있습니다. 소넷은 그 중간 모델로서 이 글을 작성하는 시점에 버전 3.5 릴리스가 있습니다.\n\n나는 어느 때부터 Claude를 살펴보고 싶어했었는데, 이런 좋은 기회였습니다.\n\n코드는 필요한 라이브러리를 불러오는 부분으로 시작됩니다:\n\n```js\nimport anthropic\nimport re\nimport httpx\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 답변은 많지 않네요. LLM을 위한 추론, 정규 표현식 및 Wikipedia에 액세스할 수 있는 HTTP 라이브러리가 필요하겠네요.\n\n이 코드를 실행하려면 물론 Anthropic 계정이 필요하고 사용 요금이 부과될 거에요. 하지만 가격은 꽤 저렴하답니다: 클로드 3.5 소네는 이전 버전보다 더 강력해지면서 더 저렴해진 것 같아요 — 제가 여기서 코드를 여러 번 실행해 봤는데 수십 센트 정도만 청구받았어요.\n\n이 코드는 먼저 클라이언트를 만든 후 챗봇을 구현할 파이썬 클래스를 정의하는 방식으로 시작합니다. 오픈AI와는 달리, Claude는 시스템 프롬프트를 사용자나 어시스턴트의 것과 분리하여 ChatBot을 인스턴스화할 때 초기화합니다. `__call__` 함수는 사용자 메시지를 저장하고 챗봇의 응답을 처리하고 에이전트를 실행하는 `execute`를 호출하는 역할을 합니다.\n\n```python\nclient = anthropic.Anthropic(api_key=\"여기에 API 키를 입력하세요\")\n\nclass ChatBot:\n    def __init__(self, system=\"\"):\n        self.system = system\n        self.messages = []\n\n    def __call__(self, message):\n        self.messages.append({\"role\": \"user\", \"content\": message})\n        result = self.execute()\n        self.messages.append({\"role\": \"assistant\", \"content\": result})\n        return message\n\n    def execute(self):\n        message = client.messages.create(\n            model=\"claude-3-5-sonnet-20240620\",\n            max_tokens=1000,\n            temperature=0,\n            system=self.system,\n            messages=self.messages\n        )\n        return message.content\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 단계는 챗봇의 인스턴스를 사용하는 query() 함수를 정의하는 것입니다. query 함수는 작업이 더 이상 없을 때까지 루프를 실행합니다(또는 최대 반복 횟수에 도달할 때까지). 이 함수는 작업을 감지하고 작업의 이름을 정규식을 사용하여 추출합니다. 작업이 호출된 후 더 이상 작업이 없는 경우, 챗봇 메시지가 반환됩니다.\n\n```js\naction_re = re.compile('^Action: (\\w+): (.*)$')\n\ndef query(question, max_turns=5):\n    i = 0\n    bot = ChatBot(prompt)\n    next_prompt = question\n    while i \u003c max_turns:\n        i += 1\n        result = bot(next_prompt)\n        print(result)\n        actions = [action_re.match(a) for a in result.split('\\n') if action_re.match(a)]\n        if actions:\n            # 실행할 작업이 있습니다\n            action, action_input = actions[0].groups()\n            if action not in known_actions:\n                raise Exception(\"Unknown action: {}: {}\".format(action, action_input))\n            print(\" -- running {} {}\".format(action, action_input))\n            observation = known_actions[action](action_input)\n            print(\"Observation:\", observation)\n            next_prompt = \"Observation: {}\".format(observation)\n        else:\n            return bot.messages\n```\n\n이제 wikipedia 및 eval과 같은 작업 함수(도구)를 정의하고 해당 함수에 대한 참조를 사전에 저장해야 합니다.\n\n```js\ndef wikipedia(q):\n    return httpx.get(\"https://en.wikipedia.org/w/api.php\", params={\n        \"action\": \"query\",\n        \"list\": \"search\",\n        \"srsearch\": q,\n        \"format\": \"json\"\n    }).json()[\"query\"][\"search\"][0][\"snippet\"]\n\ndef calculate(what):\n    return eval(what)\n\nknown_actions = {\n    \"wikipedia\": wikipedia,\n    \"calculate\": calculate\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 봇이 생성한 마지막 메시지를 출력하는 유틸리티 함수입니다.\n\n```js\ndef get_last_message():\n    for m in bot.messages[-1]['content'][0].text.split('\\n'):\n        print(m)\n```\n\n그리고 그 모든 것이 끝나면 에이전트를 사용할 수 있습니다.\n\n```js\nquery(\"What is 20 * 15\")\nget_last_message()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드는 기사 맨 위에 본 매우 첫 번째 예제에 결과를 초래하며 아래의 코드는 ReAct 에이전트가 다양한 조치를 순환하여 유효한 결론에 도달하는 방식의 또 다른 예제를 보여줍니다.\n\n에이전트가 도구에 대한 호출을 순환해야 하는 또 다른 예제가 여기 있습니다. 이 경우, 에이전트는 위키피디아만 사용하지만 답변을 도출하기 위해 응담을 지능적으로 분석해야 합니다.\n\n```js\nquery(\"스페인에서 사용되는 언어 중 프랑스에서도 사용되는 언어는 무엇인가\")\nget_last_message()\n```\n\n위의 응답은 에이전트가 적절한 답변을 도출하기 위해 거치는 합리적인 과정을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 또한 에이전트가 잘 다루는 것으로 보이는 좀 더 복잡한 질문도 시도해 보았습니다 (다운로드 가능한 코드에 더 많은 예제를 볼 수 있습니다).\n\n## 결론\n\n여기 제시된 코드는 ReAct 에이전트가 작동하는 방식을 보여줍니다. 이 코드는 견고하지 않으며 제품용으로 적합하지 않습니다. 하지만 이제 ReAct 에이전트의 원리에 대해 어느 정도 이해하고 구현할 수 있다는 것을 바라겠습니다.\n\n더 복잡한 예제로 코드를 시도해보고, 아마도 더 많은 도구를 추가해 보세요. 여러분의 실험에 대해 알고 싶어합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론, Langchain과 Llamaindex를 사용한 더 간단한 해결책도 있습니다(예:). 나는 아마도 미래에 이를 다룰 것 같습니다. 그러나 이들의 추상화된 구현은 에이전트의 내부 작업을 숨기는데, 저는 이 글과 Simon의 코드가 이를 명확히 만들었다고 기대합니다.\n\n모든 코드와 예제는 내 [Github 레포지토리](GitHub — alanjones2/claudeapps)에서 확인할 수 있습니다 — 자유롭게 다운로드하십시오.\n\n더 많은 기사를 보려면, 여기 Medium에서 나를 팔로우하시거나, 가끔씩 소식지를 구독해 주세요. 이전 기사들은 내 웹페이지에 나와 있습니다.\n\n# 노트와 참고 문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Shunyu Yao 등, ReAct: 언어 모델에서 추론과 행동을 시너지적으로 결합하기, The Eleventh International Conference on Learning Representations (ICLR), 2023. (https://arxiv.org/pdf/2210.03629에서 검색, 2024년 6월 27일에 접속)\n- Simon Willison의 블로그는 여기에 있습니다.\n- 모든 이미지와 삽화는 별도로 표시되지 않는 한 저자 본인이 만들었습니다.\n\n본 기사의 버전이 여기에 게시되어 있습니다.","ogImage":{"url":"/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png"},"coverImage":"/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png","tag":["Tech"],"readingTime":12},{"title":"2024 최신 PyTorch 치트 시트 ","description":"","date":"2024-07-01 16:07","slug":"2024-07-01-PyTorchCheatSheet","content":"\n\nPyTorch에 대해 알아야 할 모든 것을 배워보세요.\n\n![PyTorch Cheat Sheet](/assets/img/2024-07-01-PyTorchCheatSheet_0.png)\n\n야심차고 데이터 고수! 챗봇, 이미지 인식 소프트웨어, 심지어 자율 주행 자동차 같은 멋진 AI 작품을 만들고 싶나요? PyTorch를 찾아보세요!\n\nPyTorch는 Facebook의 AI 전문가들이 만든 슈퍼 멋진 오픈소스 라이브러리로, 기계 학습(ML)과 심층 학습(DL)에 손쉽게 뛰어들 수 있게 해줍니다. 이 치트 시트는 PyTorch의 기본을 모두 배울 수 있는 한 곳의 쇼핑처가 될 것이며, 금세 기계 학습 마에스트로가 될 수 있도록 도와줄 거에요! ✨\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# PyTorch 불러오기\n\n필요한 주요 라이브러리를 알려드리겠습니다:\n\n```js\n# 핵심 기능을 위한 최상위 패키지 불러오기\nimport torch\n\n# 신경망 기능 불러오기\nfrom torch import nn\n\n# 함수형 프로그래밍 도구 불러오기\nimport torch.nn.functional as F\n\n# 최적화 기능 불러오기\nimport torch.optim as optim\n\n# 데이터셋 함수 불러오기\nfrom torch.utils.data import TensorDataset, DataLoader\n\n# 평가 지표 불러오기\nimport torchmetrics\n```\n\n- import torch: 이게 본 프로그램이에요! PyTorch의 모든 중심 기능을 불러오는데요, 텐서(다차원 배열)를 구축하고 조작할 수 있습니다.\n- from torch import nn: 신경망 팬들 주목! 이 라이브러리를 사용하여 강력한 신경망을 만들 수 있는 기본 블록을 제공합니다.\n- import torch.nn.functional as F: 멋있게 만들고 싶나요? 이 라이브러리는 새로운 신경망 레이어를 만들기 위한 함수형 프로그래밍 도구를 제공하여 코드에 유연성을 더해줍니다.\n- import torch.optim as optim: 신경망을 훈련하는 것은 강아지를 훈련하는 것과 비슷해요 - 어떤 최적화가 필요해요! 이 라이브러리는 다양한 옵티마이저를 제공하여 신경망이 효율적으로 학습할 수 있도록 도와줍니다.\n- import torch.utils.data as data: 머신러닝에서 데이터는 중요해요! 이 라이브러리는 데이터셋을 효율적으로 관리하는 도구를 제공하여 훈련을 쉽게 만들어줍니다.\n- import torchmetrics: 모델이 얼마나 잘 수행되는지 잘 모르겠다구요? 이 라이브러리는 네트워크의 정확성과 효율성을 평가하는 메트릭 도구상자를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Tensor 사용하기\n\n텐서는 PyTorch에서 기본적인 구성 요소로, AI 프로젝트용 레고 블록과 비슷한 역할을 합니다! 여기에서는 텐서를 만들고 조작하는 방법을 알아보겠습니다:\n\n```js\n# 리스트에서 tensor를 사용하여 텐서 생성\ntnsr = torch.tensor([1, 3, 6, 10])\n\n# 텐서 요소의 데이터 유형 가져오기: .dtype\ntnsr.dtype # torch.int64가 반환됩니다.\n\n# 텐서의 차원 가져오기: .size()\ntnsr.shape # torch.Size([4])가 반환됩니다.\n\n# 텐서의 메모리 위치 가져오기: .device\ntnsr.device # cpu 또는 gpu가 반환됩니다.\n\n# 모든 요소가 0인 텐서 만들기: zeros()\ntnsr_zrs = torch.zeros(2, 3)\n\n# 무작위 텐서 만들기: rand()\ntnsr_rndm = torch.rand(size=(3, 4)) # 텐서는 3행 4열입니다.\n```\n\n# 데이터셋과 데이터로더\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기계 학습에서 데이터는 왕이에요! 그런데 데이터를 모델에 효율적으로 전달하는 것은 다루기 어려운 일일 수 있어요. 그럴 때 데이터셋과 데이터로더가 등장합니다. 믿을 수 있는 드래곤처럼 당신을 지켜줄 거예요.\n\n- 데이터셋 구축: 데이터셋은 깔끔하게 구성된 귀하의 훈련 데이터 모음으로 상상해보세요. 데이터가 판다스 DataFrame에 저장된 경우, TensorDataset()을 사용하여 데이터셋을 만들 수 있어요. 이 함수는 두 개의 인수를 취합니다:\n\n  - torch.tensor()를 사용하여 부동 소수점 숫자의 텐서로 변환된 특성(독립 변수).\n  - 부동 소수점 텐서로 변환된 목표(종속 변수).\n\n```js\n# TensorDataset()을 사용하여 판다스 DataFrame에서 데이터셋 만들기\nX = df[feature_columns].values\ny = df[target_column].values\ndataset = TensorDataset(torch.tensor(X).float(), torch.tensor(y).float())\n\n# DataLoader()를 사용하여 데이터를 배치로 로드하기\ndataloader = DataLoader(dataset, batch_size=n, shuffle=True)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 전처리\n\n신경망에 데이터를 입력하기 전에 몇 가지 준비작업이 필요합니다! 이를 전처리라고 합니다. PyTorch의 카테고리 변수(텍스트 레이블과 같은)를 다루기 위한 멋진 기능이 있습니다:\n\nF.one_hot()을 사용한 원-핫 인코딩\n\n“빨강,” “초록,” “파랑”과 같은 카테고리를 가진 데이터가 있다고 상상해보세요. 컴퓨터는 이러한 단어들을 처리하기 어려울 수 있습니다. 원-핫 인코딩은 이러한 카테고리를 특별한 종류의 텐서로 변환하는 트릭입니다. 이 텐서에는 각 가능한 카테고리에 대해 한 열이 있을 것입니다(이 경우 \"빨강,\" \"초록,\" \"파랑\"). 각 데이터 포인트에 대해, 해당 카테고리에 해당하는 열에 1이 있고, 나머지는 모두 0입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 PyTorch에서 F.one_hot()을 사용하는 방법입니다:\n\n```js\n# One-hot encode categorical variables with one_hot()\nF.one_hot(torch.tensor([0, 1, 2]), num_classes=3) # 0과 1로 구성된 텐서 반환\n```\n\n# Sequential Model Architecture\n\n이제 신경망 아키텍처를 구성해 봅시다! PyTorch의 nn.Sequential 클래스를 사용하면 레이어를 스택하는 것이 매우 쉬워집니다. 아래에서 설명하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n선형 레이어: 네트워크의 주역! nn.Linear(m, n)을 사용하여 m개의 입력을 받고 n개의 출력을 생성하는 선형 레이어를 만들 수 있어요. 입력값을 가중치와 곱하고 편향을 더한 것으로 생각하면 돼요.\n\n가중치와 편향 엿보기: 선형 레이어의 내부 동작에 궁금해하는가요? .weight를 사용하여 가중치 행렬에 접근하고 .bias로 편향 벡터를 확인할 수 있어요. 이들은 훈련 중에 업데이트되는 내용이에요!\n\n활성화 함수: 네트워크에 복잡성을 더하는 비선형 히어로들이에요. 여기 인기 있는 몇 가지 선택사항이 있어요:\n\n- nn.Sigmoid(): 0과 1 사이의 값을 압축하는 함수로 이진 분류(일대다)에 자주 사용돼요.\n- nn.Softmax(dim=-1): 출력값을 합이 1이 되도록 확률로 변환시켜주는 함수로 다중 클래스 분류(다대다)에 이상적이에요.\n- nn.ReLU(): 음수 값을 0으로 설정하는 ReLU(Rectified Linear Unit). 소멸 그래디언트를 방지하는 데 도움이 돼요.\n- nn.LeakyReLU(negative_slope=0.05): ReLU와 유사하지만 0이 아닌 그래디언트를 위한 작은 양수 기울기를 허용하는 함수에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDropout 레이어: 모델이 훈련 데이터를 너무 잘 기억할 때 발생하는 오버피팅을 nn.Dropout(p=0.5)로 극복하세요. 이는 훈련 중에 일정 비율의 활성화를 무작위로 제거하여 네트워크가 특정 기능에 너무 의존하지 않도록 유도합니다.\n\n모델 구축: 원하는 순서대로 레이어를 nn.Sequential로 연결해보세요. 각 레이어의 입력 크기는 이전 레이어의 출력 크기와 일치해야 합니다! 예를 들면 다음과 같습니다.\n\n```js\n# Linear()을 사용하여 입력이 m이고 출력이 n인 선형 레이어를 만듭니다.\nlnr = nn.Linear(m, n)\n\n# .weight로 레이어의 가중치를 가져옵니다\nlnr.weight\n\n# .bias로 레이어의 편향을 가져옵니다\nlnr.bias\n\n# Sigmoid()를 사용하여 이진 분류를 위한 시그모이드 활성화 레이어 생성\nnn.Sigmoid()\n\n# Softmax()를 사용하여 다중 클래스 분류를 위한 소프트맥스 활성화 레이어 생성\nnn.Softmax(dim=-1)\n\n# ReLU()를 사용하여 포화를 피하기 위한 계단식 활성화 레이어 생성\nnn.ReLU()\n\n# LeakyReLU()를 사용하여 포화를 피하기 위한 릭리 레키 크기를 설정\nnn.LeakyReLU(negative_slope=0.05)\n\n# Dropout()을 사용하여 규제하고 오버피팅을 방지하는 드롭아웃 레이어 생성\nnn.Dropout(p=0.5)\n\n# 레이어를 순차적으로 연결하여 모델 생성\nmodel = nn.Sequential(\n    nn.Linear(n_features, i),\n    nn.Linear(i, j),   # 입력 크기는 이전 레이어의 출력과 일치해야 합니다\n    nn.Linear(j, n_classes),\n    nn.Softmax(dim=-1) # 활성화 레이어가 마지막에 옵니다\n)\n```\n\n# 모델 훈련 및 손실 계산\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 데이터를 준비했고 모델을 구축했으니, 모델 훈련을 시작해봅시다!\n\n```js\n# 입력 데이터에 모델을 피팅하고 모델은 Sequential()을 통해 생성된 변수입니다.\nprediction = model(input_data).double()\n\n# 타겟 값들을 얻습니다.\nactual = torch.tensor(target_values).double()\n\n# 평균 제곱 오차 손실을 계산합니다. 회귀에는 MSELoss()를 사용합니다.\nmse_loss = nn.MSELoss()(prediction, actual) # 텐서(x)를 반환합니다.\n\n# 강건한 회귀를 위한 L1 손실을 계산합니다. SmoothL1Loss()를 사용합니다.\nl1_loss = nn.SmoothL1Loss()(prediction, actual) # 텐서(x)를 반환합니다.\n\n# 이진 분류를 위한 바이너리 크로스 엔트로피 손실을 계산합니다. BCELoss()를 사용합니다.\nbce_loss = nn.BCELoss()(prediction, actual) # 텐서(x)를 반환합니다.\n\n# 다중 클래스 분류를 위한 크로스 엔트로피 손실을 계산합니다. CrossEntropyLoss()를 사용합니다.\nce_loss = nn.CrossEntropyLoss()(prediction, actual) # 텐서(x)를 반환합니다.\n\n# .backward()를 사용하여 역전파로 기울기를 계산합니다.\nloss.backward()\n```\n\n# 옵티마이저 사용하기\n\n신경망을 훈련하는 것은 운동 선수를 훈련하는 것과 비슷합니다. 올바른 도구와 기술이 필요합니다! 이때 옵티마이저가 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# SGD() 함수를 사용하여 확률적 경사 하강 옵티마이저를 생성하고 학습률 및 모멘텀 설정\noptimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.95)\n\n# .step()을 사용하여 뉴런 매개변수 업데이트\noptimizer.step()\n```\n\n파이토치에서는 optim 모듈을 사용하여 서로 다른 옵티마이저를 생성하여 신경망의 가중치와 편향을 조정하는 방법을 각각 지정할 수 있습니다. 이번에는 확률적 경사 하강 (SGD)라는 일반적인 옵티마이저를 사용하는 방법을 알아보겠습니다:\n\n- 옵티마이저 생성: optim.SGD()를 사용하여 SGD 옵티마이저를 생성합니다. 다음 두 가지 중요한 인수를 전달합니다:\n\n    - model.parameters(): 이를 통해 옵티마이저에게 모델에서 업데이트해야 할 매개변수(가중치와 편향)를 알려줍니다.\n    - lr=0.01: 이는 학습률로, 옵티마이저가 각 단계에서 매개변수를 얼마나 조정할지를 제어합니다. 작은 학습률은 조심스러운 업데이트를 유도하고, 큰 학습률은 학습 속도를 빠르게 할 수 있지만 (또한 잠재적으로 불안정성을 유발할 수 있음) 빠른 학습을 할 수 있습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 훈련 루프\n\n```js\n# 모델을 훈련 모드로 설정합니다.\nmodel.train()\n# 손실 기준 및 옵티마이저 설정\nloss_criterion = nn.MSELoss()\noptimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.95)\n# 훈련 세트의 데이터 청크를 반복합니다.\nfor data in dataloader:\n    # 그라디언트를 0으로 설정합니다.\n    optimizer.zero_grad()\n    # 현재 데이터 청크의 특징과 타깃을 가져옵니다.\n    features, targets = data\n    # \"순방향 패스\"를 실행하여 모델을 데이터에 맞춥니다.\n    predictions = model(data)\n    # 손실 계산\n    loss = loss_criterion(predictions, targets)\n    # 역전파를 사용하여 그래디언트 계산\n    loss.backward()\n    # 모델 매개변수 업데이트\n    optimizer.step()\n```\n\n# 평가 루프\n\n굉장한 PyTorch 모델을 훈련한 후, 이제 얼마나 잘 수행되는지 확인해보세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 모델을 평가 모드로 설정\nmodel.eval()\n\n# 정확도 메트릭 생성\nmetric = torchmetrics.Accuracy(task=\"multiclass\", num_classes=3)\n# 검증 세트에서 데이터 청크 루프\nfor i, data in enumerate(dataloader, 0):\n    # 현재 데이터 청크의 특징과 타겟 가져오기\n    features, targets = data\n    # 모델을 데이터에 맞추기 위해 \"포워드 패스\" 실행\n    predictions = model(data)\n    # 배치의 정확도 계산\n    accuracy = metric(output, predictions.argmax(dim=-1))\n# 전체 검증 데이터에 대한 정확도 계산\naccuracy = metric.compute()\nprint(f\"All 데이터에 대한 정확도: {accuracy}\")\n# 다음 데이터셋(학습 또는 검증)을 위해 메트릭 재설정\nmetric.reset()\r\n```\n\n# 전이 학습과 파인튜닝\n\n머신 러닝에서 사전 훈련된 모델을 활용하여 우리 자신의 프로젝트를 빠르게 시작할 수 있습니다. 이를 전이 학습이라고하며, 그 내에서 파인튜닝은 강력한 기술입니다. PyTorch가 여러분을 돕는 방법을 살펴보겠습니다:\n\n나중을 위한 레이어 저장: 모델의 특정 레이어를 훈련시키고 나중에 다시 사용하고 싶다면, torch.save()를 사용하여 레이어의 가중치와 편향을 파일로 직렬화할 수 있습니다. 이는 미래 AI 프로젝트를 위한 청사진을 저장하는 것으로 생각할 수 있습니다!\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ntorch.save(layer, 'layer.pth')  # 'layer.pth' 파일에 레이어를 저장합니다.\n```\n\n저장된 레이어 불러오기: 이전에 저장한 레이어를 가져와야 하는 경우가 있습니다. torch.load()를 사용하여 다시 불러올 수 있습니다! 새 모델에 사전 훈련된 레이어를 통합하는 데 유용합니다.\n\n```js\nnew_layer = torch.load('layer.pth')  # 'layer.pth' 파일에서 레이어를 불러옵니다.\n```\n\n동결된 파워로 파인튜닝! 예를 들어, 사전 훈련된 모델이 있고 특정 작업을 위해 최종 레이어만 파인튜닝하려는 경우가 있습니다. PyTorch를 사용하면 .requires_grad = False를 사용하여 이전 레이어의 가중치를 동결시킬 수 있습니다. 이렇게 하면 훈련 중에 업데이트되지 않고 마지막 레이어에 중점을 두고 학습 프로세스를 진행할 수 있습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfor name, param in model.named_parameters():\n    if name == \"0.weight\":\n        param.requires_grad = False  # 필요에 따라 레이어 번호를 조정하여 레이어 0의 가중치를 고정시킵니다.\n\n# 이제 최종 레이어만 업데이트되도록 모델을 학습할 수 있습니다!\n```\n\n전이 학습과 파인 튜닝을 마스터하면, 사전 학습된 지식을 활용하여 학습 시간을 단축시키고, 여러분을 머신러닝 효율성 챔피언으로 만들 수 있습니다!\n\n읽어 주셔서 감사합니다. 내 컨텐츠가 마음에 드시고 저를 지원하고 싶다면, Patreon에서 저를 지원하는 것이 가장 좋은 방법입니다 —\n\n\u003cimg src=\"/assets/img/2024-07-01-PyTorchCheatSheet_1.png\" /\u003e\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 내 YouTube 채널 구독하기.\r\n- 내 웹사이트 방문하기.\r\n- LinkedIn과 Github에서 나와 연락하기! 나는 거기에서 무료로 놀라운 콘텐츠를 공유하고, 기술과 AI를 활용하여 더 생산적이고 효과적으로 일할 수 있도록 돕습니다.\r\n- 머신러닝 및 딥러닝 도움이 필요하신가요? 내 Fiverr 및 Upwork 서비스를 확인해보세요!","ogImage":{"url":"/assets/img/2024-07-01-PyTorchCheatSheet_0.png"},"coverImage":"/assets/img/2024-07-01-PyTorchCheatSheet_0.png","tag":["Tech"],"readingTime":13},{"title":"Python weakref 모듈을 사용한 약한 참조 가이드","description":"","date":"2024-07-01 16:06","slug":"2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule","content":"\n\n\n\u003cimg src=\"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png\" /\u003e\n\n아마 당신은 파이썬의 weakref 모듈에 대해 들어본 적이 없을 것입니다. 여러분의 코드에서 자주 사용되지는 않지만, 많은 라이브러리, 프레임워크 및 심지어 파이썬 자체의 내부 작업에 기본적입니다. 그래서, 이 글에서는 weakref 모듈이 무엇인지, 어떻게 유용한지, 그리고 여러분의 코드에 어떻게 통합할 수 있는지 살펴보겠습니다.\n\n# 기본 사항\n\nweakref 모듈과 약한 참조를 이해하기 위해 먼저 파이썬에서 가비지 컬렉션에 대해 간단히 소개해야 합니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬은 쓰레기 수집을 위한 메커니즘으로 참조 카운팅을 사용합니다. 간단히 말해, 파이썬은 우리가 생성한 각 객체에 대한 참조 카운트를 유지하며, 코드에서 객체가 참조될 때마다 참조 카운트가 증가하고, 객체가 해제될 때(e.g. 변수가 None으로 설정될 때) 감소합니다. 참조 카운트가 0이 되면, 해당 객체의 메모리가 할당 해제(가비지 수집)됩니다.\n\n조금 더 이해하기 쉽도록 코드를 살펴봅시다:\n\n```js\nimport sys\n\nclass SomeObject:\n    def __del__(self):\n        print(f\"(Deleting {self=})\")\n\nobj = SomeObject()\n\nprint(sys.getrefcount(obj))  # 2\n\nobj2 = obj\nprint(sys.getrefcount(obj))  # 3\n\nobj = None\nobj2 = None\n\n# (Deleting self=\u003c__main__.SomeObject object at 0x7d303fee7e80\u003e)\n```\n\n여기서는 __del__ 메서드만 구현한 클래스를 정의하는데, 이 메서드는 객체가 가비지 수집될 때 호출되며, 가비지 수집이 발생했을 때를 확인할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 클래스의 인스턴스를 만든 후에는 sys.getrefcount를 사용하여이 객체에 대한 현재 참조 수를 가져옵니다. 여기에서는 1을 기대하지만 getrefcount가 반환하는 카운트는 일반적으로 예상보다 한 단계 높습니다. getrefcount를 호출하면 참조가 함수의 인수로 값에 의해 복사되어 객체의 참조 수가 일시적으로 증가하기 때문입니다.\n\n다음으로, obj2 = obj를 선언하고 다시 getrefcount를 호출하면 이제 obj와 obj2 둘 다에 의해 참조되기 때문에 3을 얻습니다. 반대로, 이러한 변수에 None을 할당하면 참조 수가 0으로 감소하고, 마침내 객체가 가비지 수집되었다는 __del__ 메서드에서 메시지를 받게 됩니다.\n\n자, 그럼 약한 참조는 어떻게 여기에 맞는 것인가요? 객체에 대한 유일한 남은 참조가 약한 참조인 경우, Python 인터프리터는 이 객체를 가비지 수집할 수 있습니다. 다른 말로하면 — 객체에 대한 약한 참조만으로는 객체를 살리는 데 충분하지 않습니다:\n\n```js\nimport weakref\n\nobj = SomeObject()\n\nreference = weakref.ref(obj)\n\nprint(reference)  # \u003cweakref at 0x734b0a514590; to 'SomeObject' at 0x734b0a4e7700\u003e\nprint(reference())  # \u003c__main__.SomeObject object at 0x707038c0b700\u003e\nprint(obj.__weakref__)  # \u003cweakref at 0x734b0a514590; to 'SomeObject' at 0x734b0a4e7700\u003e\n\nprint(sys.getrefcount(obj))  # 2\n\nobj = None\n\n# (Deleting self=\u003c__main__.SomeObject object at 0x70744d42b700\u003e)\n\nprint(reference)  # \u003cweakref at 0x7988e2d70590; dead\u003e\nprint(reference())  # None\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 다시 클래스의 obj 변수를 선언합니다. 이번에는 이 객체에 대한 두 번째 강력한 참조 대신에 참조 변수에 약한 참조를 만듭니다.\n\n그런 다음 참조 카운트를 확인하면 증가하지 않음을 알 수 있고, obj 변수를 None으로 설정하면 약한 참조가 여전히 남아 있음에도 즉시 쓰레기 수집됨을 확인할 수 있습니다.\n\n마지막으로 이미 쓰레기로 처리된 객체에 대한 약한 참조에 액세스하려고 하면 “무효한” 참조 및 None이 반환됩니다.\n\n또한 객체에 액세스하기 위해 약한 참조를 사용할 때 함수로 호출해야 했음을 주목하십시오(reference()). 따라서 객체 속성에 액세스해야 하는 경우 특히 프록시를 사용하는 것이 훨씬 편리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nobj = SomeObject()\n\nreference = weakref.proxy(obj)\n\nprint(reference)  # \u003c__main__.SomeObject object at 0x78a420e6b700\u003e\n\nobj.attr = 1\nprint(reference.attr)  # 1\n```\n\n# 사용 시기\n\n이제 약한 참조가 어떻게 작동하는지 알았으니, 어떻게 유용할 수 있는지 몇 가지 예시를 살펴보겠습니다.\n\n약한 참조의 일반적인 사용 사례 중 하나는 트리와 같은 데이터 구조입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\nclass Node:\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self._parent = None\r\n        self.children = []\r\n\r\n    def __repr__(self):\r\n        return \"Node({!r:})\".format(self.value)\r\n\r\n    @property\r\n    def parent(self):\r\n        return self._parent if self._parent is None else self._parent()\r\n\r\n    @parent.setter\r\n    def parent(self, node):\r\n        self._parent = weakref.ref(node)\r\n\r\n    def add_child(self, child):\r\n        self.children.append(child)\r\n        child.parent = self\r\n\r\nroot = Node(\"parent\")\r\nn = Node(\"child\")\r\nroot.add_child(n)\r\nprint(n.parent)  # Node('parent')\r\n\r\ndel root\r\nprint(n.parent)  # None\r\n\n\r\n여기서는 약한 참조를 사용하여 자식 노드들이 부모 노드를 가리키는 Node 클래스를 통해 트리를 구현했습니다. 이 관계에서 자식 Node는 부모 Node 없이 살 수 있어 부모가 소리 없이 제거되거나 가비지 수집될 수 있게 합니다.\r\n\r\n또 다른 방법으로 이를 구현해보겠습니다:\r\n\r\n\nclass Node:\r\n    def __init__(self, value):\r\n        self.value = value\r\n        self._children = weakref.WeakValueDictionary()\r\n\r\n    @property\r\n    def children(self):\r\n        return list(self._children.items())\r\n\r\n    def add_child(self, key, child):\r\n        self._children[key] = child\r\n\r\nroot = Node(\"parent\")\r\nn1 = Node(\"child one\")\r\nn2 = Node(\"child two\")\r\nroot.add_child(\"n1\", n1)\r\nroot.add_child(\"n2\", n2)\r\nprint(root.children)  # [('n1', Node('child one')), ('n2', Node('child two'))]\r\n\r\ndel n1\r\nprint(root.children)  # [('n2', Node('child two'))]\r\n\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 부모는 자식들을 약한 참조를 갖고 있습니다. 이는 WeakValueDictionary를 사용합니다. 사전에서 참조된 요소(약한 참조)가 프로그램의 다른 곳에서 참조를 제거하면, 자동으로 사전에서도 제거됩니다. 따라서 사전 항목의 수명주기를 관리할 필요가 없습니다.\n\nweakref의 또 다른 사용 예는 Observer 디자인 패턴에 있습니다:\n\n```js\nclass Observable:\n    def __init__(self):\n        self._observers = weakref.WeakSet()\n\n    def register_observer(self, obs):\n        self._observers.add(obs)\n\n    def notify_observers(self, *args, **kwargs):\n        for obs in self._observers:\n            obs.notify(self, *args, **kwargs)\n\n\nclass Observer:\n    def __init__(self, observable):\n        observable.register_observer(self)\n\n    def notify(self, observable, *args, **kwargs):\n        print(\"Got\", args, kwargs, \"From\", observable)\n\nsubject = Observable()\nobserver = Observer(subject)\nsubject.notify_observers(\"test\", kw=\"python\")\n# Got ('test',) {'kw': 'python'} From \u003c__main__.Observable object at 0x757957b892d0\u003e\n```\n\nObservable 클래스는 옵저버에 대한 약한 참조를 유지합니다. 이는 그들이 제거되었는지 여부를 신경쓰지 않기 때문입니다. 이전 예제와 마찬가지로, 이를 통해 종속 객체의 수명주기를 관리할 필요가 없습니다. 아마도 주목했을 것이지만, 이 예제에서는 WeakSet을 사용했습니다. 이는 WeakValueDictionary와 비슷하지만 Set을 사용하여 구현되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션의 최종 예제는 weakref 문서에서 빌려왔습니다:\n\n```js\nimport tempfile, shutil\nfrom pathlib import Path\n\nclass TempDir:\n    def __init__(self):\n        self.name = tempfile.mkdtemp()\n        self._finalizer = weakref.finalize(self, shutil.rmtree, self.name)\n\n    def __repr__(self):\n        return \"TempDir({!r:})\".format(self.name)\n\n    def remove(self):\n        self._finalizer()\n\n    @property\n    def removed(self):\n        return not self._finalizer.alive\n\ntmp = TempDir()\nprint(tmp)  # TempDir('/tmp/tmp8o0aecl3')\nprint(tmp.removed)  # False\nprint(Path(tmp.name).is_dir()) # True\n```\n\n이를 통해 weakref 모듈의 또 다른 기능을 확인할 수 있습니다. 바로 weakref.finalize입니다. 이름에서 암시하는 바대로 종속 객체가 가비지 수집될 때 최종화 함수/콜백을 실행할 수 있습니다. 이 예제에서는 가비지 수집될 때 TempDir 객체에 대해 rmtree를 자동으로 실행할 최종화가 실행됩니다. 프로그램이 완전히 종료될 때를 포함하여 TempDir이 가비지 수집될 때 실행되는 finalizer를 통해 TempDir를 정리하기를 항상 기억해야하지만 잊어버릴 경우에 대비할 수 있습니다.\n\n# 실제 예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앞서 섹션에서 weakref의 실용적인 사용 예를 보여드렸지만, 실세계 예제도 함께 살펴보겠습니다. 그 중 하나는 캐시된 인스턴스를 생성하는 것입니다:\n\n```js\nimport logging\na = logging.getLogger(\"first\")\nb = logging.getLogger(\"second\")\nprint(a is b)  # False\n\nc = logging.getLogger(\"first\")\nprint(a is c)  # True\n```\n\n위의 코드는 Python의 내장 logging 모듈의 기본적인 사용법입니다. 우리는 특정 이름에 하나의 로거 인스턴스만 관련시킬 수 있음을 알 수 있습니다. 즉, 동일한 로거를 여러 번 검색해도 항상 동일한 캐시된 로거 인스턴스가 반환됩니다.\n\n만약 이를 구현하고 싶다면, 다음과 같이 할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nclass Logger:\n    def __init__(self, name):\n        self.name = name\n\n_logger_cache = weakref.WeakValueDictionary()\n\ndef get_logger(name):\n    if name not in _logger_cache:\n        l = Logger(name)\n        _logger_cache[name] = l\n    else:\n        l = _logger_cache[name]\n    return l\n\na = get_logger(\"first\")\nb = get_logger(\"second\")\nprint(a is b)  # False\n\nc = get_logger(\"first\")\nprint(a is c)  # True\n```\n\n마지막으로, Python 자체도 약한 참조를 사용합니다. OrderedDict의 구현 예시를 보겠습니다:\n\n```python\nfrom _weakref import proxy as _proxy\n\nclass OrderedDict(dict):\n\n    def __new__(cls, /, *args, **kwds):\n        self = dict.__new__(cls)\n        self.__hardroot = _Link()\n        self.__root = root = _proxy(self.__hardroot)\n        root.prev = root.next = root\n        self.__map = {}\n        return self\n```\n\n위는 CPython의 collections 모듈에서의 일부 코드입니다. 여기서 weakref.proxy가 순환 참조를 막는 데 사용된다는 점을 유의하십시오 (더 많은 세부 정보는 doc-strings를 참조하세요).\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\nweakref는 꽤 낯설지만 때때로 매우 유용한 도구로 여러분의 도구상자에 넣어두어야 할 가치가 있습니다. 이는 캐시를 구현하거나 이중 연결 리스트와 같이 서로 참조하는 데이터 구조를 다룰 때 매우 도움이 될 수 있습니다.\n\n그렇지만 여기서 말한 모든 것과 문서에서 언급된 사항은 CPython에 특화되어 있으며 다른 Python 구현체에서는 weakref 동작이 다를 수 있음을 인식해야 합니다. 또한 리스트, 튜플 또는 정수와 같은 많은 내장 타입이 약한 참조를 지원하지 않는다는 사실을 알아두어야 합니다.\n\n본 문서는 원문이 [martinheinz.dev](https://martinheinz.dev)에 게시되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 항목을 추천해 드려요...","ogImage":{"url":"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png"},"coverImage":"/assets/img/2024-07-01-AGuidetoPythonsWeakReferencesUsingtheweakrefModule_0.png","tag":["Tech"],"readingTime":11},{"title":"데이터 시각화로 스토리텔링 하는 방법","description":"","date":"2024-07-01 16:00","slug":"2024-07-01-HowtoMakeYourDataVisualizationsTellaStory","content":"\n\n- 소개\n- 규칙 0: 데이터의 유형을 고려하세요\n- 규칙 1: 면적 당 정보를 최대화하세요\n- 규칙 2: 중요한 축 레이블을 무시하지 마세요\n- 규칙 3: 가능한 경우 오차 막대 추가\n- 규칙 4: 모든 것의 글꼴 크기를 키우세요\n- 규칙 5: 축 척도를 적절히 설정하세요\n- 규칙 6: 소표시선과 그리드를 사용하세요\n- 규칙 7: 범례를 잊지 마세요\n- 규칙 8: 명확성이 중요합니다\n- 규칙 9: 일관성이 중요합니다\n- 규칙 10: 지나치게 혼잡해지지 않도록 주의하세요\n- 규칙 11: 적합 매개변수를 요약하는 텍스트 상자 추가\n- 규칙 12: 그림을 나란히 표시할 때 동일한 축 척을 사용하세요\n- 규칙 13: 텍스트 상자를 절약해서 사용하세요\n- 규칙 14: 그림은 .pdf 파일로 저장하세요\n- 요약 및 결론\n\n# 소개\n\n한 명의 현명한 사람이 말했습니다: \"그림은 어떤 설명 없이도 스스로 설명이 가능해야 합니다.\" 즉, 제목이나 저자의 설명 없이 독자에게 제공된 그림은 그 안에 담긴 정보를 해독하고 의미 있는 결론을 추출할 수 있어야 합니다. 저는 다수의 그림을 제작했으며, 이 중 많은 그림이 '원자력 계측 방법', '계측 학지', '원자력 과학 심포지엄 및 IEEE 의료 영상 학술 대회' 등의 학술지에 게재되어 전국 및 국제 학회에 발표되었습니다. 학업 생활을 시작할 때 나는 어떻게 그림을 만드는지 (좋은 그림은 더욱) 몰랐습니다. 과학적 공동 작업 그룹에 가입하고 논문을 투고하면서야 그렇게 배울 수 있었습니다. 논문 본문과 모든 도표/표는 공동 작업 그룹 내부 검토를 여러 번 거쳤을 뿐만 아니라 투고 과정에서도 학술지에서 승인을 받아야 했습니다. 데이터 시각화에 대한 접근 방식이 완전히 틀렸다는 사실을 빨리 깨달았습니다. 그것은 꽤 충격적인 깨달음이었는데, 그림 (및 글쓰기)의 품질은 외부 세계에 대한 귀하의 커뮤니케이션 기술의 즉각적인 반영입니다.\n\n저는 지난 7년 동안 배운 지식을 공유하고자 이 기사를 쓰려고 합니다. 제가 겪은 고통을 당신에게 납득시킬 수 있기를 바래봅니다. 데이터를 시각화하는 것은 과학적 노력뿐만 아니라 예술입니다; 심미적 선택은 이러한 과학적 노력에서 더욱 큰 역할을 합니다. 이러한 객관적 및 주관적 영향의 혼재를 풀어내기 위해, 나는 그림 작성 철학을 14가지 간단한 규칙으로 요약했습니다. 여러분이 유용하게 사용하길 바랍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 다양한 데이터를 다룰 예정이에요; 예제에 더 잘 맞게 하기 위해 수동으로 생성하는 데이터도 있고 캐글에서 가져오는 데이터셋도 있을 거예요. 하지만 모든 데이터셋에 대해 csv 파일을 다운로드할 수 있는 링크를 포함하거나 데이터를 어떻게 생성했는지 보여드릴 거에요. 시작하기 전에 이 글에서 데이터를 생성/플로팅하는 데 사용된 모든 import 문을 나열할 거에요:\n\n```js\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom matplotlib.lines import Line2D\nimport matplotlib.patches as mpatches\nfrom matplotlib.ticker \nimport numpy as np\nimport pandas as pd\nfrom scipy.optimize import curve_fit\nfrom sklearn.neighbors import KernelDensity\n```\n\n참고로, 저는 Python 버전 3.12.2를 사용하고 있고, 아래에서 모든 패키지 버전을 나열할 거에요:\n\n```js\nmatplotlib==3.8.2\nnumpy==1.26.3\npandas==2.2.0\nscikit-learn==1.4.0\nscipy==1.12.0\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, Matplotlib의 전역 매개변수 몇 가지도 변경하고 싶습니다. 예를 들어, 주요 및 보조 눈금 표시 마커의 크기를 키우고 싶습니다. 그래서 실행 시 구성(RC) 매개변수(Parameter)의 재정의를 아래에 나열해 두겠습니다:\n\n```js\nmpl.rcParams['xtick.major.size']  = 5\nmpl.rcParams['xtick.major.width'] = 2\nmpl.rcParams['xtick.minor.size']  = 4\nmpl.rcParams['xtick.minor.width'] = 1\n\nmpl.rcParams['ytick.major.size']  = 5\nmpl.rcParams['ytick.major.width'] = 2\nmpl.rcParams['ytick.minor.size']  = 4\nmpl.rcParams['ytick.minor.width'] = 1\n```\n\n# Rule 0: 데이터의 유형을 고려하세요\n\n이 규칙은 데이터 시각화에 가장 중요한 규칙으로, 별도의 기사로도 충분히 다루어질 만큼 중요합니다. 하지만 여기서 간결하게 요약하겠습니다. 플롯의 특별한 내용을 고려하기 전에, 먼저 데이터를 가장 잘 표시할 수 있는 플롯 유형을 고려해야 합니다. 이를 정확하게 파악하는 것은 어려울 수 있지만, 데이터를 플로팅할 때 따를 수 있는 몇 가지 기본적인 지침을 설명하겠습니다. 이 토론을 간결하게 유지하기 위해, 데이터 탐색 및 변수 관계에 적합한 데이터 시각화 방법만 고려하겠으며, 플로우, 아크 또는 트리 형태의 플롯으로 해결하는 것이 가장 적합한 문제에 대해서는 고려하지 않겠습니다. 두 가지 더 중요한 점은 다음과 같습니다: 이 목록은 모든 플롯 유형을 갖춘 것이 아니며, 이러한 지침은 절대적인 것이 아니지만 시작점을 찾는 데 도움이 되는 공리입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 히스토그램 및 상자, 바이올린, 및 확률 밀도 그림\n\n히스토그램: 데이터 탐색을 위한 가장 쉬운 옵션이자 처음 익히면 좋은 것은 겸손한 히스토그램입니다. 이것은 분포를 빠르게 표시하는 데 사용되는 지금까지 믿음직한 방법이죠. 우리가 다루는 모든 새로운 데이터셋에 대해 우리는 데이터가 어떻게 분포되어 있는지 보고 싶어합니다. 예를 들어, 극값이 어디에 위치하는지, 분포의 모양(단일 모양, 이분 모양 등), 시각적으로 추정할 수 있는 몇 가지 기초 통계 (평균, 중앙값, 분산 등) 등을 알고 싶어합니다. 그러나 히스토그램은 1차원 플롯입니다. x축에 하나의 피처를 표시하며, y축은 각 bin에서 발생하는 횟수를 인코딩하여 우리에게 기초 분포의 좋은 감각을 제공합니다. 따라서 많은 피처를 가진 데이터셋의 경우 일반적으로 최적의 옵션이 아닙니다 (물론 여러 피처를 동일한 축에 플롯할 수 있을 때는 제외하고요. 그렇지 않으면 데이터셋의 각 피처에 대해 히스토그램이 필요합니다). 이 플롯 유형 설명의 마지막에 히스토그램을 상단 왼쪽 패널에 표시한 플롯을 참조하세요.\n\n히스토그램은 신뢰할 만한 도구이지만 완벽하지는 않습니다. bin 크기는 분포 형태에 상당한 영향을 미칠 수 있습니다. 나중에는 히스토그램에 전적으로 헌신된 기사를 작성할 것입니다 (데이터를 가장 잘 표시하는 방법, bin 크기 선택 방법 등에 관한 것 등), 하지만 지금은 bin 크기를 조정하여 분포 모양이 어떻게 영향을 받는지 확인해보세요.\n\n상자 수염 그림: 히스토그램 대신에 사용할 수 있는 대안은 상자 수염 그림입니다. 이것은 데이터가 플로팅되는 방식을 표준화함으로써 bin-의존 상태를 약간 향상시킵니다. 상자는 제 1사분위부터 제 3사분위까지 (1Q 및 3Q 각각)를 나타내며 이를 사분위범위 (IQR)라고도 합니다. IQR 내에서 중앙값을 나타내는 선이 그어지고, 종종 마커가 평균값을 나타냅니다. 수염은 위에서 제3사분위부터 상단 3Q + (1.5 • IQR)까지, 및 하단에서 1사분위부터 하단 1Q - (1.5 • IQR)까지 연장됩니다. 이 범위의 이상치는 수염 밖에 그려진 마커로 나타납니다. 처음에는 약간 이상하게 보일 수 있지만, 상자 수염 그림이 키 특징이 표시된 히스토그램의 요약일 뿐이라는 것을 깨달을 때 이해하기가 완전히 가능해지며 유틸리티가 급격하게 증가합니다. 아래 상자수염 그림과 정규 분포의 대조를 살펴보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_0.png)\n\n바이올린 플롯: 상자그림의 확장인 바이올린 플롯은 데이터 집합의 최솟값과 최댓값을 가리키는 수직선 왼쪽과 오른쪽에 확률 밀도 함수(probability density function, PDF)를 겹쳐 놓습니다. 아래 예시에서는 기본 바이올린 플롯의 유용성을 확대하기 위해 중앙값(주황색 선)과 평균값(빨간 다이아몬드)을 표시했습니다.\n\n확률 밀도 함수 그래플: 바이올린 플롯의 구성 요소 중 하나로 논의된 PDF 그래프는 대상 데이터만으로 생성되는 KDE(커널 밀도 추정) 과정에 따라 단순히 PDF만 보여줍니다. 이러한 종류의 그래플은 통계에 익숙하지 않은 사람들에게는 해석하기 어려울 수 있지만, 통계를 아는 사람들에게는 히스토그램보다 유용한 경우도 있습니다. 왜냐하면 데이터에 존재하는 미묘한 변동을 완화시키기 때문입니다. KDE 과정은 다음과 같이 요약될 수 있습니다: 분포 내 각 데이터 포인트에 대해 커널(대부분의 경우 가우스 함수)이 적합되고, 이러한 개별 가우시안 분포가 합산되고 평활화되어 확률 밀도 분포가 생성됩니다. (실제 KDE 과정은 이보다 복잡하지만, 일단 이 설명으로 충분합니다.) 이 그래플의 독특한 이점은 적분(곡선 아래 영역)이 확률을 나타낸다는 것입니다. 아래 예시를 사용해 이것의 물리적 해석은 \"샘플링된 개인이 일부 혈중 콜레스테롤 범위를 가질 확률은 얼마인가\" 입니다. (중요성 때문에, KDE 방법에 대해 보다 철저한 설명이 필요하므로 전체 논문을 쓸 예정입니다.)\n\n아래 예시에 표시된 예제에 사용된 데이터 집합은 Kaggle의 심장 데이터셋(데이터셋 링크)에서 가져온 것입니다. 아래 그래프에서는 전체 데이터 집합(남성과 여성 모두 포함)의 콜레스테롤이 표시되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n## 데이터 전처리\ndf_heart = pd.read_csv('heart.csv')\nchol = df_heart.chol.to_numpy()\n\n## KDE 방법을 사용하여 PDF 계산\nkde = KernelDensity(kernel='gaussian', bandwidth=10).fit(chol.reshape(-1, 1))\nlog_dens = kde.score_samples(np.arange(0, 600).reshape(-1, 1))\n\n## 서브플롯 간격 매개변수\nleft = 0.125   # 그림의 서브플롯의 왼쪽\nright = 0.9    # 그림의 서브플롯 오른쪽\nbottom = 0.1   # 그림의 서브플롯의 아래쪽\ntop = 0.9      # 그림의 서브플롯의 위쪽\nwspace = 0.5   # 서브플롯 사이의 공백 너비\nhspace = 0.4   # 서브플롯 사이의 공백 높이\n\nmatplotlib.rcParams.update({'font.size': 24})  # 전역 글꼴 크기 설정\nmeanprops = dict(marker='D', markeredgecolor='black',\n                 markerfacecolor='crimson') # 평균 마커를 위한 상자그림 속성\n\nfig, ax = plt.subplots(2, 2, figsize=(14, 13))\n\n## 히스토그램\nax[0, 0].grid('both', zorder=0)\nax[0, 0].hist(chol, bins=40, alpha=0.8, color='forestgreen', edgecolor='black', zorder=2)\n\nax[0, 0].set_xlim(0, 600)\nax[0, 0].set_ylim(0, 40)\nax[0, 0].set_xlabel('콜레스테롤 수준 (mg/dl)', loc='right')\nax[0, 0].set_ylabel('빈도', loc='top')\nax[0, 0].set_title('히스토그램')\nax[0, 0].xaxis.set_minor_locator(AutoMinorLocator())\nax[0, 0].yaxis.set_minor_locator(AutoMinorLocator())\nax[0, 0].tick_params(which='major', length=6, width=2)\nax[0, 0].tick_params(which='minor', length=3.5, width=1)\n\n...\n\nfig.subplots_adjust(left=left, bottom=bottom, right=right, top=top,\n                    wspace=wspace, hspace=hspace) # 서브플롯 간 공백 조정\nfig.savefig('distribution_plots.pdf')\n```\n\n각 플롯 유형은 거의 동일한 것을 디스플레이하며, 각각의 장단점이 있습니다. 이러한 플롯 유형의 데이터는 연속적이지만 필요에 따라 한 축을 이산화하거나 몇 가지 값을 구간으로 나눌 수 있으며, 결과적으로 히스토그램과 유사한 것을 생성할 수 있습니다. 모든 경우에, 이러한 플롯 유형은 계층화된 데이터 간 분포를 비교하는 데 매우 유용하며, 특히 상자 그림과 바이올린 플롯이 있습니다. 연구 대상 남성과 여성 참가자의 콜레스테롤 수준을 비교해보세요:\n\n\u003cimg src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_2.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n## 데이터 전처리\nm_chol = df[df['sex'] == 1].chol.to_numpy() # 남성 콜레스테롤 값 가져오기\nf_chol = df[df['sex'] == 0].chol.to_numpy() # 여성 콜레스테롤 값 가져오기\n\nmpl.rcParams.update({'font.size': 24}) # 전역 글꼴 크기 설정\nfig, ax = plt.subplots(2, 2, figsize=(14, 13)) # 2x2 서브 플롯 생성\n\n## 히스토그램 그리기\nax[0, 0].grid('both', zorder=0)\nax[0, 0].hist(m_chol, bins=40, alpha=0.6, color='forestgreen', edgecolor='black', zorder=2)\nax[0, 0].hist(f_chol, bins=40, alpha=0.6, color='xkcd:cerulean', edgecolor='black', zorder=2)\n\nax[0, 0].set_xlim(0, 600)\nax[0, 0].set_ylim(0, 22)\nax[0, 0].set_xlabel('콜레스테롤 수치 (mg/dl)', loc='right')\nax[0, 0].set_ylabel('빈도', loc='top')\nax[0, 0].set_title('히스토그램')\n\n...\n\n## 일부 요소 생략\n```\n\n히스토그램이나 확률 밀도 함수(PDF)가 겹칠 때 그래프가 지저분해질 수 있습니다. 이럴 경우, 맷플롯립이 제공하는 다른 그리기 방법 중 하나인 barstacked나 step 옵션을 사용하는 게 좋습니다. (아래 그림 참조)\n\n\u003cimg src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_3.png\" /\u003e\n\n```js\nmpl.rcParams.update({'font.size': 24})\n## 사용자 정의 범례 항목\nlegend = [mpatches.Patch(color='forestgreen', label='남성', alpha=0.6),\n          mpatches.Patch(color='xkcd:cerulean', label='여성', alpha=0.6)\n         ]\n\nlegend_line = [Line2D([0], [0], color='forestgreen', lw=2.5, label='남성'),\n               Line2D([0], [0], color='xkcd:cerulean', lw=2.5, label='여성')\n              ]\n\nfig, ax = plt.subplots(1, 2, figsize=(12, 8))\nax[0].grid('both', zorder=0)\nax[0].hist([m_chol,f_chol], bins=25, alpha=0.6, linewidth=2.3, edgecolor='k', color=['forestgreen', 'xkcd:cerulean'], histtype='barstacked',zorder=2)\nax[1].hist([m_chol,f_chol], bins=25, linewidth=2.5, color=['forestgreen', 'xkcd:cerulean'], histtype='step',zorder=2)\n\n...\n\n## 일부 요소 생략\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플롯이 지저분하고 해석하기 어렵다면, 아래 두 개의 PDF처럼 서로 다른 데이터를 별도의 서브플롯에 그릴 수 있어요:\n\n![PDFs](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_4.png)\n\n```js\n## 데이터 처리\nlog_dens   = [log_dens_m, log_dens_f]\npdf_colors = ['forestgreen', 'xkcd:cerulean']\npdf_labels = ['남성', '여성']\n\nmpl.rcParams.update({'font.size': 30})\nfig, ax = plt.subplots(1, 2, figsize=(15, 8))\n\n#ax[1, 1].fill(x_data, kde_y)\nfor subplot in np.arange(2):\n    ax[subplot].plot(np.arange(0, 600), np.exp(log_dens[subplot]), color=pdf_colors[subplot], linewidth=2)\n    ax[subplot].set_xlabel('콜레스테롤 농도 (mg/dl)', loc='right')\n    ax[subplot].set_ylabel('확률 밀도', loc='top')\n    ax[subplot].grid('both', zorder=0)\n    ax[subplot].fill(np.arange(0, 600), np.exp(log_dens[subplot]), color=pdf_colors[subplot], alpha=0.4)\n    ax[subplot].set_xlim(-25, 625)\n    ax[subplot].set_ylim(-0.0005, 0.012)\n    legend = [mpatches.Patch(color=pdf_colors[subplot], label=pdf_labels[subplot], alpha=0.6)]\n    ax[subplot].legend(handles=legend)\n\nfig.tight_layout()\nfig.savefig('pdf_comparison_plots.pdf')\n```\n\n## 산점도\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n산포도(Scatter plot)는 데이터를 군집화하거나 데이터 집합 내에서 다양한 특성 간의 관계를 찾는 데 매우 유용한 옵션입니다. 아래의 산포도를 살펴보십시오. 이 그래프는 뉴욕의 주택 가격을 면적의 함수로 보여줍니다. (데이터셋은 Kaggle에서 확인 가능합니다):\n\n![scatter plot](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_5.png)\n\n\n## 데이터 로딩 및 전처리\ndf_housing = pd.read_csv('NY-House-Dataset.csv')\n\nprice = df_housing['PRICE'].to_numpy()\nsqft  = df_housing['PROPERTYSQFT'].to_numpy()\n\nmpl.rcParams.update({'font.size': 32})\nfig, ax = plt.subplots(figsize=(9,9))\nax.scatter(sqft, price, c='xkcd:cherry', s=12)\nax.set_xscale('log')\nax.set_yscale('log')\nax.set_xlabel('면적 (ft$^{2}$)', loc='right')\nax.set_ylabel('가격 (USD)', loc='top')\nfig.tight_layout()\nfig.savefig('scatter_plot_example.pdf')\n\n\n위 예시를 선형-로그 척도로 확인하면 아웃라이어의 존재를 더 쉽게 식별할 수 있지만, 데이터 분포의 퍼짐도를 고려하면 로그-로그 척도가 더 적합합니다. 주택 가격과 총 면적이 지수 함수 관계임을 확인할 수 있어, 산포도가 왜 유용한지 잘 드러나는 사례입니다. 추가로, 2000 평방피트 근처에서 여러 주택 가격이 동일한 것을 볼 수 있습니다. 이는 데이터의 오류일 수도 있고, 더 큰 기저 패턴이 있을 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nScatter plot을 사용하면 더 많은 데이터나 다른 데이터 세트를 포함시킬 수 있습니다. 예를 들어, 다른 지리적 위치를 다른 포인트 집합으로 추가하거나, 데이터 세트에서 다른 기능을 표시하기 위해 두 번째 x-축이나 y-축을 추가할 수도 있습니다. 아래와 같이 설명되어 있습니다:\n\n![Scatter Plot Image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_6.png)\n\n```python\nmpl.rcParams.update({'font.size': 32})\n\n## 데이터 전처리\nbedrooms = df_housing['BEDS'].to_numpy()\n\nfig, ax = plt.subplots(figsize=(9,9))\nax.scatter(sqft, price, c='xkcd:cherry', s=12)\nax.set_yscale('log')\nax.set_xscale('log')\nax.set_xlabel('Area (ft$^{2}$)', loc='right')\nax.set_ylabel('Price (USD)', loc='top')\nax.tick_params(axis='x',  which='both', colors='xkcd:cherry') \nax.xaxis.label.set_color('xkcd:cherry')\nax.set_title('NY House Prices')\n\nax2 = ax.twiny() # 두 번째 x-축 추가\nax2.scatter(bedrooms, price, c='xkcd:cerulean', s=12, label='Bedrooms')\nax2.set_xticks(np.arange(0, 60, 10))\nax2.set_xlabel('Bedrooms', loc='right')\nax2.xaxis.label.set_color('xkcd:cerulean')\nax2.minorticks_on()\nax2.tick_params(axis='x', which='both', colors='xkcd:cerulean') \nfig.tight_layout()\nfig.savefig('scatter_plot_example_double_x_axes.pdf')\n```\n\n두 번째 x-축이 이산적이기 때문에 가장 명확한 예시는 아니지만, 침실 수가 주택 가격의 가장 좋은 예측자가 아님을 추론할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 막대 그래프 및 파이 차트\n\n범주형 데이터의 경우, 막대 그래프나 심지어 파이 차트와 같은 플롯 유형이 적합합니다. 그러나 저는 다양한 종류의 데이터를 표시하는 더 많은 유연성을 제공하기 때문에 막대 차트를 선호합니다. 파이 차트는 각 데이터 범주가 전체에 기여하는 비율을 쉽게 시각화하여 해석하기 쉽고 빠르게 만들어주는 독특한 장점을 가지고 있지만, 이해하기 쉽고 빠르게 만들어주는 독특한 장점을 가지고 있습니다. 그러나 막대 차트가 제공하는 다방면의 유연성이 파이 차트의 명료함을 상쇄시킵니다. 아래는 2019 회계연도의 넷플릭스 서비스의 네 개 주요 지역에서 넷플릭스 스트리밍 수익을 보여주는 막대 차트(왼쪽)와 파이 차트(오른쪽)를 고려해 보세요. 해당 데이터셋은 이곳에서 찾을 수 있습니다(Kaggle):\n\n![그림](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원 그래프는 전체의 백분율을 두 가지 서로 다른 시각적 표현으로 표시하여 해석이 쉽게 됩니다(백분율로 표시된 것과 전체 원의 기하학적 비율로 표시된 것 두 가지입니다). 이는 빠르게 핵심 데이터 시각화를 제시해야 하는 프리젠테이션에서 더 나은 선택일 수 있습니다. 이에 비해 막대 차트는 각 막대 위에 (10억 달러 단위로) 순수한 수치를 제공하면서 각 막대에서 읽을 수 있는 공통 스케일을 제공하여 양을 기하학적으로 나타냅니다. 이렇게 함으로서 이러한 데이터를 시각화하는 비슷한 방법을 제공합니다. 그러나 플롯의 차원을 늘리고, 예를 들어 여러 해를 표시한다면 막대 차트는 훨씬 더 유용합니다. 다음에 나오는 플롯을 고려해 보십시오. 이 플롯은 여러 해 동안의 스트리밍 수익을 보여줍니다:\n\n![Netflix 스트리밍 수익 (2019-2023)](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_8.png)\n\n번역된 코드:\n```js\n## 여러 막대 그래프를 위한 데이터 처리\nyear_separated = {}\nfor region in total_separated[year].keys():\n    temp = []\n    for year in total_separated.keys():\n        if year == 2024: # 2024년은 1분기만 사용 가능하므로 건너뜁니다\n            pass\n        else:\n            temp.append(total_separated[year][region])\n    year_separated[region] = temp\n\nmpl.rcParams.update({'font.size': 32})\n\n막대의 너비     = 0.2\n막대의 오프셋    = -0.4\n레이블들        = list(region_labels.values())\n색상들          = list(region_colors.values())\nx_ticks       = np.arange(len(total_separated.keys()) - 1) \nx_tick_labels = [str(year) for year in total_separated.keys()]\nx_tick_labels = x_tick_labels[:-1]\n\nfig, ax = plt.subplots(figsize=(10,9))\n\nfor region, cnt in zip(year_separated.keys(), np.arange(len(year_separated.keys()))):\n    data_scaled = np.array(year_separated[region]) / 1e9\n    ax.bar(x_ticks + bar_offset, data_scaled, width=0.2, label=region_labels[region], color=region_colors[region]) \n    ax.set_ylim(0, 20)\n    ax.set_xlabel('Region', loc='right') \n    ax.set_ylabel('Revenue (BUSD)', loc='top') \n    ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())\n    \n    if np.average(data_scaled) \u003e= 8: # 막대의 숫자에 대한 올바른 y-오프셋 설정\n        text_yoffset = 1.4\n    else:\n        text_yoffset = 1.2\n        \n    for bar in np.arange(x_ticks.shape[0]):\n        ax.text(x_ticks[bar] + bar_offset, data_scaled[bar] + text_yoffset, '%.1f' % data_scaled[bar],\n                rotation=90, verticalalignment='center',horizontalalignment='center', fontsize=24)\n\n    bar_offset += bar_width\n\nax.set_xticks(x_ticks, x_tick_labels)\nax.set_title('Netflix 스트리밍 수익 (2019-2023)', fontsize=32, pad=15)\nax.legend(fontsize=24, ncols=2, loc='upper left', columnspacing=0.6)\nfig.tight_layout()\nfig.savefig('netflix_streaming_revenue_2019_2023.pdf')\n```\n\n이것은 원 그래프로는 불가능합니다; 같은 플롯에 여러 원 그래프가 필요할 것이며 —공간의 비효율적 사용입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 라인 플롯\n\n또는 이 데이터 세트를 라인 플롯으로 표시할 수도 있습니다. 라인 플롯을 사용하면 데이터를 보다 세밀하게 살펴볼 수 있습니다:\n\n![line plot](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_9.png)\n\n```js\n## 2019년부터 2024년까지 모든 날짜에 대한 지역 데이터 추출\ndates = netflix_data['Date']\nline_plot_data = {}\nfor region in region_labels.keys():\n    line_plot_data[region] = netflix_data[region].to_numpy()\n\nmarkers = ['o', 's', 'D', 'v']\nregion_markers = {region: marker for region, marker in zip(region_labels.keys(), markers)}\n\nmpl.rcParams.update({'font.size': 32})\n\nfig, ax = plt.subplots(figsize=(11,9))\n\nlabels        = list(region_labels.values())\ncolors        = list(region_colors.values())\nx_ticks       = np.arange(len(total_separated.keys()) - 1) \nx_tick_labels = [str(year) for year in total_separated.keys()]\nx_tick_labels = x_tick_labels[:-1]\n\nfor region in line_plot_data.keys():\n    ax.plot(dates, line_plot_data[region], color=region_colors[region],\n            marker=region_markers[region], label=region_labels[region],\n            linewidth=2.2, markersize=7)\n\nax.set_ylim(0, 4.6e9)\nax.set_xlabel('Region', loc='right') \nax.set_ylabel('Revenue (USD)', loc='top') \nax.minorticks_on()\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nax.set_title('넷플릭스 스트리밍 수익', fontsize=32, pad=15)\nax.legend(fontsize=27, ncols=2, loc='upper left', columnspacing=0.6)\nfig.tight_layout()\nfig.savefig('netflix_streaming_revenue_2019_2023.pdf')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2D 히스토그램 / 히트맵\n\n이전에 논의한 히스토그램 패밀리의 주의점 중 하나는 2D 히스토그램입니다. 이 플롯 유형은 범주형 데이터의 두 차원을 표시하거나 이미지 데이터를 시각화하는 데 사용할 수 있습니다 [예 : 컴퓨터 비전이나 합성곱 신경망과 작업하고 원시 데이터가 어떻게 보이는지 보고 싶을 때; 편리한 플로팅 라이브러리로 Python Image Library (Pillow) 패키지가 여기에 있습니다]. 아래는 클래식 iris 데이터 집합을 사용한 2D 히스토그램의 예입니다 (Kaggle에서 여기에서 제공).\n\n![2D Histogram Example](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_10.png)\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndf_iris = pd.read_csv('Iris.csv')\nsepal_length = df_iris['SepalLengthCm']\nsepal_width  = df_iris['SepalWidthCm']\n\nfig, ax = plt.subplots(figsize=(9,9))\n\nhist = ax.hist2d(sepal_length, sepal_width, vmin=0, vmax=10, bins=10)\nax.set_xlabel('Sepal length', loc='right')\nax.set_ylabel('Sepal width', loc='top')\n\ncbar = fig.colorbar(hist[3])\ncbar.set_label('Counts', loc='top')\nfig.tight_layout()\nfig.savefig('hist2d_example.pdf')\n```\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 붓꽃의 측정된 꽃받침 길이와 너비의 가장 일반적인 값들을 식별하기 위해 이 2D 히스토그램을 사용할 수 있습니다. 2D 히스토그램/히트맵은 데이터의 밀도 분포를 나타내는 지표가 될 수 있습니다. 이는 3D 히스토그램으로 확장되어 적용될 수 있으며, 3D 히스토그램에서 z-축(2D 바이닝의 높이)은 색상 막대의 기능을 대체합니다.\n\n## 플롯 유형의 테이블\n\n편의상, 위에서 논의된 각 플롯 유형에 대한 데이터 유형, 사용 용도, 장단점을 표로 정리했습니다:\n\n최종적으로는 경험을 쌓고 상황이 발생했을 때 기술적이고 미적인 판단을 내릴 수 있는 능력에 달려 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 규칙 1: 면적 당 정보를 극대화하세요\n\n어떤 플롯이든 축(맷플롯립 용어로 \"spines\"라 불림)의 범위 내에서 제시되는 정보를 최대화하는 것이 목표입니다. 너무 많은 여백은 낭비된 영역을 의미하며, 플롯 생성은 사용 가능한 공간을 효율적으로 사용하는 예술입니다. 아래의 플롯은 이 규칙을 지키지 않은 사례를 보여줍니다 (Kaggle에서 데이터셋 확인 가능):\n\n![Plot Image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_11.png)\n\n```python\n## 데이터 전처리\ndf_power = pd.read_csv('Power_data.csv')\npressure = df_power['Ambient pressure'].to_numpy()\ntemp = df_power['Avg temperature'].to_numpy()\nhumidity = df_power['Relative humidity'].to_numpy()\npower = df_power['Net hourly electrical energy output'].to_numpy()\n\nmpl.rcParams.update({'font.size': 32})\nfig, ax = plt.subplots(figsize=(11,9))\n\nax.minorticks_on()\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7, zorder=0)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5, zorder=0)\nax.scatter(temp, power, s=5, label='Temperature ($^{\\circ}$C)', c='xkcd:hot pink', zorder=3)\nax.scatter(humidity, power, s=5, label='Relative humidty (%)', c='xkcd:blue purple', zorder=3)\nax.scatter(pressure, power, s=5, label='Pressure (mbar)', c='xkcd:deep sky blue', zorder=3)\nax.set_xlabel('Variable', loc='right')\nax.set_ylabel('Power output (MW)', loc='top')\n\nax.legend(fontsize=25, markerscale=4, handletextpad=0.3, loc='upper center')\nfig.tight_layout()\nfig.savefig('power_output_scatter.pdf')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서로 다른 변수들 간의 큰 간격은 서로 다른 스케일을 가진 여러 변수를 동일한 플롯/축에 플롯하려고 시도했기 때문에 발생했습니다. 이 경우 x축에 로그 스케일을 적용해도 변화가 없습니다. 왜냐하면 모든 변수의 분포 폭이 충분히 넓지 않기 때문입니다. 세 가지 옵션이 있습니다: (1) 서로 다른 데이터를 세 개의 패널로 분할하고 각 변수를 별도로 표시하거나 (2) 온도와 상대습도를 동일한 플롯에 유지하고 압력 데이터를 자체 축으로 할당하거나 (3) 플롯에 두 번째 x축을 추가합니다. 옵션(1)이 가장 좋습니다. 이는 각 피쳐를 개별 x축에 배치하여 출력과 해당 피쳐 간의 관계를 더 잘 시각화하게 하며 전반적으로 플롯을 이해하기 쉽고 조직적으로 만듭니다.\n\n![Visualization](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_12.png)\n\n```js\nmpl.rcParams.update({'font.size': 38})\n\nfig, ax = plt.subplots(1, 3, figsize=(26,12))\nfor axis in np.arange(3):\n    ax[axis].minorticks_on()\n    ax[axis].grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7, zorder=0)\n    ax[axis].grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5, zorder=0)\n    ax[axis].set_ylabel('Power output (MW)', loc='top')\n    ax[axis].set_ylim(418, 500)\n\nax[0].scatter(temp, power, s=5, label='Temperature ($^{\\circ}$C)', c='xkcd:hot pink', zorder=3)\nax[1].scatter(humidity, power, s=5, label='Relative humidty (%)', c='xkcd:blue purple', zorder=3)\nax[2].scatter(pressure, power, s=5, label='Pressure (mbar)', c='xkcd:deep sky blue', zorder=3)\n\nax[0].set_xlabel('Temperature ($^{\\circ}$C)', loc='right')\nax[1].set_xlabel('Relative humidty (%)', loc='right')\nax[2].set_xlabel('Pressure (mbar)', loc='right')\n\nax[0].set_xlim(0, 40)\nax[1].set_xlim(0, 110)\n\nfig.tight_layout()\nfig.savefig('power_output_scatter_improved.pdf')\n```\n\n# Rule 2: 중요한 축 라벨을 절대 무시하지 마세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 간과되는 경우가 있어 축 레이블을 추가하는 것을 잊을 때가 종종 있습니다. 종종 이는 협업자들이 각 축에 무엇이 플로팅되고 있는지 알고 있거나 추론할 수 있기 때문일 수 있습니다. 그러나 우리의 작업을 비롯한 외부의 관찰자나 우리와 같은 분야의 누군가에게는 축 레이블이 없으면 시각화된 내용을 이해하는 데 필수적인 맥락이 제거될 수 있습니다. 예를 들어, 아래 플롯을 살펴보세요:\n\n![히스토그램](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_13.png)\n\n플롯을 훑어본 빠르게 확인만으로 이것이 확실히 히스토그램이라는 것을 알 수 있으므로 y축에 무엇이 플로팅되고 있는지를 추론할 수 있습니다(회수/빈도). 그러나 x축에는 무엇이 플로팅되고 있는지요? 이것은 다양한 양에 대한 것이 될 수 있으며, 데이터 집합을 사전에 알 경우에만 추론을 시작할 수 있습니다. 협업자들과 같은 내부 사용을 위한 플롯을 보낼 때에도, 즉, 내용을 추측하는 것을 독자에게 맡기면 안 됩니다.\n\n![플롯](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 반복 작업은 상당히 향상되었습니다. 하지만 독자는 콜레스테롤 수치가 어떤 단위인지 여전히 알지 못합니다. 이 수치는 무게/부피의 어떤 조합일 수 있습니다(예: 마이크로그램/리터, 나노그램/리터 등). 이 중요한 세부 내용을 추가하면 플롯의 최종 버전이 됩니다:\n\n![image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_15.png)\n\n```js\n## 데이터 포맷팅\nchol = df.chol.to_numpy()\n\n## 플로팅\nmatplotlib.rcParams.update({'font.size': 31})\nfig, ax = plt.subplots(figsize=(10, 8))\n\nax.grid('both', zorder=0)\nax.hist(chol, bins=30, edgecolor='k', facecolor='forestgreen', zorder=2)\nax.set_xlim(0, 600)\nax.set_ylim(0, 40)\nax.set_xticks(np.arange(0, 700, 100))\nax.set_xlabel('콜레스테롤 농도 (mg/dl)', loc='right', fontsize=36)\nax.set_ylabel('빈도', loc='top', fontsize=36)\n#ax.set_title('히스토그램')\n#ax.tick_params(axis='x', which='minor', bottom=True)#, bottom=False)\nplt.minorticks_on()\n#ax.tick_params(axis='both', which='major', labelsize=4)\n#ax.tick_params(axis='both', which='minor', labelsize=2)\n\n\nfig.tight_layout()\nfig.savefig('labeled_hist_1.pdf')\n```\n\n물론, 플로팅되는 변수에 단위가 없는 경우 특성 이름을 추가하는 것이 적절합니다. 일부 경우에서 축 레이블의 단위 부분으로 \"임의 단위\"를 사용하는 것도 허용되지만, 이는 대부분 중복된 추가입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 규칙 3: 가능한 경우 오차 막대 추가하기\n\n일반적으로 오차 막대가 없는 선 그래프를 볼 때 가장 먼저 떠오르는 의문점은 \"어디에 오차 막대가 있는 거죠?\" 입니다. 가능한 경우 작성자는 반드시 오차 막대를 포함해야 합니다. 물론, 오차 막대가 너무 작아서 마커로 가려지는 경우는 캡션이나 설명과 함께 명시되어야 합니다. 예를 들어, 첫 눈에 왼쪽 그래프에서 독립 변수가 증가함에 따라 두 곡선이 분명히 서로 다르게 변화하는 것을 볼 수 있습니다:\n\n![Error Bars Example](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_16.png)\n\n```js\n## 데이터 생성\nx_vals   = np.arange(0, 20, 1)\nnum_vals = x_vals.shape[0] \n\ny0     = 1.4 * x_vals + (np.random.rand(num_vals) + 3.3)\ny1     = 1.6 * x_vals + (np.random.rand(num_vals) + 3.5)\ny_data = [y0, y1]\n\nerror0     = x_vals * 0.1\nerror1     = x_vals * 0.28\nerror_data = [error0, error1]\n\ncolors = ['xkcd:azure', 'xkcd:carmine']\n\nmpl.rcParams.update({'font.size': 34})\n\nfig, ax = plt.subplots(1, 2, figsize=(16,9))\nfor plot in np.arange(2):\n    for dataset in np.arange(2):\n        if plot == 0:\n            ax[plot].plot(x_vals, y_data[dataset], marker='o', color=colors[dataset], label='Dataset %d' % dataset)\n        else:\n            ax[plot].errorbar(x_vals, y_data[dataset], error_data[dataset], marker='o', color=colors[dataset], label='Dataset %d' % dataset)\n    \n    ax[plot].set_xlim(-2, 22)\n    ax[plot].set_ylim(0, 42)\n    ax[plot].set_xlabel('독립 변수', loc='right')\n    ax[plot].set_ylabel('종속 변수', loc='top')\n    ax[plot].legend(fontsize=30)\n    ax[plot].minorticks_on()\n    ax[plot].set_xticks(np.arange(0, 25, 5))\n    ax[plot].set_yticks(np.arange(0, 45, 5))\n    \nfig.tight_layout()\nfig.savefig('error_bars_example.pdf')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 오른쪽 그림에 오차 막대가 있는 그래프를 확인해보면, 이러한 이질성이 꼭 그렇지 않을 수 있음을 알 수 있습니다: x 값이 증가할수록 데이터 집합 1의 오차가 단조롭게 증가합니다. 이로써 두 데이터 집합이 모두 이질적이라는 주장이 의심스러운 것입니다. 이를 덧없이 언급할 때, 오직 조금 더 정교한 통계적 검정 없이 이 관측 결과만으로 (즉, 더 나은 통계 검정 없이) 우리는 이전과 같이 두 선이 모두 이질적임을 결론 지을 수 없습니다.\n\n# 규칙 4: 모든 것의 글꼴 크기를 키우세요\n\n작고 괴롭히는 글꼴 크기의 큰 그림은 성가신 일입니다. 특히 인쇄용이거나 발표용으로 서식이 지정된 그래프를 볼 때는 더욱 그렇습니다. 회의나 회의가 진행될 때 발표를 들으면 눈에 꺼내어 x 및 y축 레이블을 읽기 위해 눈을 잔뜩 까놓아야 할 때 즐거움이 있을 리가 없습니다. 그림의 \"전체적인 그림\"은 확대하거나 눈을 찌푸리지 않아도 파악할 수 있어야 합니다. 현대 기술과 (규칙 14를 참조하십시오)에서 그림이 적절한 형식으로 저장된 경우에는 크게 문제가 되지 않을 것입니다. 그러나 규칙 14를 깨야 하는 경우에는, 그림이 합리적으로 수용할 수 있는 한 큰 글꼴 크기를 늘리는 것이 가장 좋습니다. 또한, 제 시각적인 의견으로는, 더 큰 글꼴 크기가 더 잘 보인다고 생각합니다. 아래 그림을 고려해보십시오 (Kaggle 데이터 세트는 여기에서 사용 가능합니다):\n\n\u003cimg src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_17.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nhousing_prices_2 = pd.read_csv('Housing_Price_Data.csv')\n\nprice_no_ac_df = housing_prices_2[housing_prices_2['airconditioning'] == 'no']\nprice_with_ac_df = housing_prices_2[housing_prices_2['airconditioning'] == 'yes']\n\nmpl.rcParams.update({'font.size': 10})  # Matplotlib의 기본 글꼴 크기를 10으로 설정\n\nfig, ax = plt.subplots(figsize=(9, 9))\n\nax.scatter(price_no_ac_df['area'], price_no_ac_df['price'], c='xkcd:vibrant green', s=12, marker='o', label='에어컨 없음')\nax.scatter(price_with_ac_df['area'], price_with_ac_df['price'], c='xkcd:orangered', s=12, marker='D', label='에어컨 있음')\n\nax.set_xlabel('면적 (ft$^{2}$)', loc='right')\nax.set_ylabel('가격 (USD)', loc='top')\nax.set_xlim(1000, 20000)\nax.set_ylim(1e6, 2.1e7)\nax.set_yscale('log')\nax.set_xscale('log')\nax.legend(loc='upper left', markerscale=2.4)\nfig.tight_layout()\nfig.savefig('small_font_example.pdf')\n```\n\n이 그래프는 Matplotlib의 글꼴 크기를 기본값 10으로 사용하여 만들었습니다. 눈금과 축 레이블을 읽기 어렵게 만들어 전체적으로 해석하기 어렵게 합니다. 동일한 그래프를 글꼴 크기를 26으로 크게 한 것으로 생각해보세요:\n\n![Large Font Example](https://cdn.url/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_18.png)\n\n```python\nmpl.rcParams.update({'font.size': 26})\n\nfig, ax = plt.subplots(figsize=(8, 8))\n\nax.scatter(price_no_ac_df['area'], price_no_ac_df['price'], c='xkcd:vibrant green', s=12, marker='o', label='에어컨 없음')\nax.scatter(price_with_ac_df['area'], price_with_ac_df['price'], c='xkcd:orangered', s=12, marker='D', label='에어컨 있음')\n\nax.set_xlabel('면적 (ft$^{2}$)', loc='right')\nax.set_ylabel('가격 (USD)', loc='top')\nax.set_xlim(1000, 20000)\nax.set_ylim(1e6, 2.1e7)\nax.set_yscale('log')\nax.set_xscale('log')\nax.legend(loc='upper left', markerscale=2.4)\nfig.tight_layout()\nfig.savefig('large_font_example.pdf')\n```  \n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n독자들이 폰트 크기를 늘려줘서 감사할 거예요.\n\n# Rule 5: 축의 스케일을 적절하게 설정하세요\n\n여러 개 주문에 걸친 데이터는 거의 항상 로그 축을 사용하여 플로팅해야 합니다. 어느 시점에서는, 두 개 이상의 수주에 걸쳐 변환해야 하는 경우도 있을 것입니다. 이는 그래프의 하나, 또는 모든 축에 적용될 수 있습니다. 이 예제에서는 계수 a에 의해 스케일링된 자연 로그 곡선을 그릴 것입니다:\n\n![그림](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_19.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n## 데이터 생성\na_coeff = 1.5\n\nx_data = np.arange(10, 48000, 0.1)\ny_data = a_coeff * np.log(x_data)\n\nmpl.rcParams.update({'font.size': 34})\n\nfig, ax = plt.subplots(figsize=(9,8))\nax.plot(x_data, y_data, linewidth=2.4, c='xkcd:indigo')\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7, zorder=0)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5, zorder=0)\nax.set_xlabel('$x$', loc='right')\nax.set_ylabel('$f(x)$', loc='top')\nax.minorticks_on()\nax.set_ylim(0, 20)\n\nprops = dict(boxstyle='round', facecolor='xkcd:indigo', alpha=0.3)\n\nax.text(0.062, 0.81, '$f(x) = a\\cdot\\mathrm{ln}(x)$\\na = 1.5', fontsize=26, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('no_log_example.pdf')\n```\n\nx-축이 여러 개의 자릿수에 걸쳐 있어 공간이 효율적으로 사용되지 않는 것을 알 수 있습니다. 그래프의 우측 하단 부분에는 많은 빈 공간이 있습니다. 독립 데이터에 로그 변환을 적용할 수 있는 완벽한 상황입니다. 우리는 이 변환을 직접 계산할 필요가 없습니다. Matplotlib가 내부적으로 처리해 줄 것입니다.\n\n![image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_20.png)\n\n```js\nmpl.rcParams.update({'font.size': 34})\n\nfig, ax = plt.subplots(figsize=(9,8))\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7, zorder=0)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5, zorder=0)\nax.plot(x_data, y_data, linewidth=2.4, c='xkcd:indigo')\nax.set_xlabel('$x$', loc='right')\nax.set_ylabel('$f(x)$', loc='top')\nax.minorticks_on()\nax.set_xscale('log')\nax.set_ylim(0, 20)\nax.set_xlim(5, 9e4)\n\nprops = dict(boxstyle='round', facecolor='xkcd:indigo', alpha=0.3) # 텍스트 상자 속성\nax.text(0.062, 0.81, '$f(x) = a\\cdot\\mathrm{ln}(x)$\\na = 1.5', fontsize=26, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('semi_log_example.pdf')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nx-축에 로그 스케일을 적용하여 사용 가능한 공간을 훨씬 더 효율적으로 활용할 수 있습니다. 최상의 예시는 아니지만, 많은 단위 범위를 다루는 데이터에 대해 로그 축이 더 적합한 이유를 보여줍니다.\n\n# 규칙 6: 보조 눈금 및 그리드 사용\n\n보조 눈금을 사용하면 독자에게 귀중한 도움이 됩니다. 로그-노멀 또는 로그-로그 축을 다룰 때는 그리드가 심사숙고하여 구현될 때 더 유용한 기능이 될 수 있습니다. 아래 예시를 고려해보세요:\n\n![이미지](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_21.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n## 데이터 생성\nx_data   = np.arange(0.1, 20.1, 0.1)\nexp_data = (1/200) * np.power(x_data, 3)\n\nmpl.rcParams.update({'font.size': 34})\nfig, ax=plt.subplots(figsize=(10,8))\nax.plot(x_data, exp_data, linewidth=2, color='xkcd:deep sky blue')\nax.set_xlabel('x',    loc='right', fontsize=40)\nax.set_ylabel('f(x)', loc='top',   fontsize=40)\nax.set_xlim(0, 22)\nax.set_ylim(0, 42)\nprops = dict(boxstyle='round', facecolor='white', alpha=0.7)\nax.text(0.08, 0.83, \"$f(x) = \\dfrac{x^{3}{200}$\", fontsize=32, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('four_x_cubed_no_minor_ticks.pdf')\n```\n\n위의 그림은 x축과 y축이 모두 선형 스케일로 나타난 곡선을 보여줍니다. 그러나 플롯의 왼쪽에 많은 여백이 있어 곡선에서 x 및 y 값을 정확히 파악하기 어렵습니다. 이 그림을 보다 쉽게 읽을 수 있도록 몇 가지 마이너 틱을 추가할 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_22.png\" /\u003e\n\n```python\nmpl.rcParams.update({'font.size': 34})\n\nfig, ax=plt.subplots(figsize=(10,8))\nax.plot(x_data, exp_data, linewidth=2, color='xkcd:deep sky blue')\nax.set_xlabel('x',    loc='right', fontsize=40)\nax.set_ylabel('f(x)', loc='top',   fontsize=40)\nax.set_xlim(0, 22)\nax.set_ylim(0, 42)\nax.minorticks_on()\nprops = dict(boxstyle='round', facecolor='white', alpha=0.7)\nax.text(0.08, 0.83, \"$f(x) = \\dfrac{x^{3}{200}$\", fontsize=32, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('four_x_cubed_with_minor_ticks.pdf')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 하면 더 쉬워지지만, 그리드 사용은 시각적 안내에 더 효과적일 수 있습니다. 아래의 두 그래프를 비교해보세요: 왼쪽에는 주 그리드 라인만 표시되고, 오른쪽에는 소 그리드와 주 그리드 라인이 모두 표시됩니다:\n\n![Grid Comparison](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_23.png)\n\n```python\nmpl.rcParams.update({'font.size': 42})\nprops = dict(boxstyle='round', facecolor='white', alpha=0.7)\n\nfig, ax=plt.subplots(1, 2, figsize=(20,10))\nax = ax.ravel()\n\nfor plot in np.arange(2):\n    ax[plot].plot(x_data, exp_data, linewidth=2, color='xkcd:deep sky blue')\n    ax[plot].set_xlabel('x',    loc='right', fontsize=40)\n    ax[plot].set_ylabel('f(x)', loc='top',   fontsize=40)\n    ax[plot].set_xlim(0, 22)\n    ax[plot].set_ylim(0, 42)\n    ax[plot].minorticks_on()\n    ax[plot].set_xticks(np.arange(0, 25, 5))\n    if plot == 0:\n        ax[plot].grid()\n    else:\n        plt.grid(True, which=\"both\")\n\n    ax[plot].text(0.08, 0.83, \"$f(x) = \\dfrac{x^{3}{200}$\", fontsize=38, bbox=props, transform=ax[plot].transAxes)\nfig.tight_layout()\nfig.savefig('four_x_cubed_with_minor_ticks_major_minor_grid.pdf')\n```\n\n오른쪽에 있는 그래프가 우리에게 가장 유용한 정보를 제공합니다: 소 그리드 라인이 시각을 안내하여 곡선 상의 점을 식별하기가 훨씬 쉬워집니다. 그러나 주 그리드 라인과 소 그리드 라인의 선 종류 및 색상을 사용자 정의하는 것으로 한 발짝 더 나아갈 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmpl.rcParams.update({'font.size': 34})\n\n\nfig, ax=plt.subplots(figsize=(10,8))\nax.plot(x_data, exp_data, linewidth=2, color='xkcd:deep sky blue')\n#ax.set_xscale('log')\n#ax.set_yscale('log')\n\n\nax.set_xlabel('x', loc='right', fontsize=40)\nax.set_ylabel('f(x)', loc='top', fontsize=40)\nax.set_xlim(0, 22)\nax.set_ylim(0, 42)\nax.minorticks_on()\nprops = dict(boxstyle='round', facecolor='white', alpha=0.7)\nax.text(0.08, 0.83, \"$f(x) = \\dfrac{x^{3}{200}$\", fontsize=32, bbox=props, transform=ax.transAxes)\n\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nfig.tight_layout()\nfig.savefig('four_x_cubed_with_minor_ticks_major_minor_grid_custom.pdf')\n```\n\n사용자 정의 그리드를 추가하여 주요 그리드 선을 미세 그리드 선보다 강조하는 것은 꽤 차이를 만들 수 있어요!\n\n# Rule 7: Don’t forget the legend\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뻔한 말이지만, 제가 본 플롯 중에는 이 중요한 요소가 생략된 경우가 많았습니다. 특이한 피처를 가진 플롯의 경우에는 보통 이것이 문제가 되지 않습니다 — 보통 x-축과 y-축 레이블에서 데이터의 신원을 추론할 수 있습니다; 그러나 어쨌든 범례를 추가하는 것이 가장 좋습니다. 이 선택적인 피처는 단일 플롯에 여러 곡선, 산포도 등을 그릴 때 필수적인 요소가 됩니다. 아래의 막대 플롯을 고려해보세요:\n\n![그림](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_25.png)\n\n```js\n## 데이터 생성\ncategories = np.array(['A','B','C','D', 'E']) \ngroup_a    = np.array([5, 22, 34, 10, 7]) \ngroup_b    = np.array([15, 4, 22, 8, 12])\ngroup_c    = np.array([30, 10, 9, 17, 23])\n\nmpl.rcParams.update({'font.size': 32})\n\nfig, ax = plt.subplots(figsize=(10,8))\nx_ticks   = np.arange(categories.shape[0]) \nbar_width = 0.2\n\nax.bar(x_ticks - 0.2, group_a, width=0.2, label='Group A', color='xkcd:pumpkin orange') \nax.bar(x_ticks + 0.0, group_b, width=0.2, label='Group B', color='xkcd:goldenrod') \nax.bar(x_ticks + 0.2, group_c, width=0.2, label='Group C', color='xkcd:carmine') \n\nax.set_xticks(x_ticks, categories) \nax.set_xlabel('Category', loc='right') \nax.set_ylabel('Number of ocurrences', loc='top') \n\nax.yaxis.set_minor_locator(ticker.AutoMinorLocator())\nfig.tight_layout()\nfig.savefig('bar_chart_with_legend.pdf')\n```\n\n분명하게, 여기에서 다섯 가지 다른 카테고리에 대해 세 개의 개별 데이터셋이 플롯되어 있습니다. 범례가 없으면 이 플롯은 해독할 수 없습니다; 우리는 세 가지 다른 막대 색상이 무슨 의미인지 이해해야 합니다. 범례를 추가하면 마침내 제시된 정보를 해석할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n## 데이터 생성\ncategories = np.array(['A','B','C','D', 'E']) \ngroup_a    = np.array([5, 22, 34, 10, 7]) \ngroup_b    = np.array([15, 4, 22, 8, 12])\ngroup_c    = np.array([30, 10, 9, 17, 23])\n\nmpl.rcParams.update({'font.size': 32})\n\nfig, ax = plt.subplots(figsize=(10,8))\nx_ticks   = np.arange(categories.shape[0]) \nbar_width = 0.2\n\nax.bar(x_ticks - 0.2, group_a, width=0.2, label='Group A', color='xkcd:pumpkin orange') \nax.bar(x_ticks + 0.0, group_b, width=0.2, label='Group B', color='xkcd:goldenrod') \nax.bar(x_ticks + 0.2, group_c, width=0.2, label='Group C', color='xkcd:carmine') \n\nax.set_xticks(x_ticks, categories) \nax.set_xlabel('Category', loc='right') \nax.set_ylabel('Number of ocurrences', loc='top') \nax.legend(fontsize=24) # 범례 추가\nax.yaxis.set_minor_locator(ticker.AutoMinorLocator())\nfig.tight_layout()\nfig.savefig('bar_chart_with_legend.pdf')\n```\n\n초보용 예제이지만 의도적으로 선택한 것은 명확한 필요성을 보여주는 범례입니다.\n\n마지막으로, 범례가 표시 중인 데이터와 겹치지 않도록 주의하십시오! 이렇게 되면 혼란스러울 수 있습니다(데이터를 얼마나 많이 차지하는지에 따라 다를 수 있음) 그리고 전달하려는 내용을 방해할 수도 있습니다. 플롯 내에 범례를 맞게 배치하도록 축 스케일을 조정하거나 범례 글꼴 크기를 약간 줄이세요(즉, Rule 4을 어기지 마세요!).\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 규칙 8: 명확함이 중요합니다\n\n현재 시대에는 그래픽 출판물을 위해 구별 가능한 색상(또는 회색의 음영)을 선택해야 했던 시절은 더 이상 흔하지 않지만 각 데이터가 서로 다른 색상, 표식 및 선 유형(실선, 대시 등)으로 구별되어야 하는 것이 여전히 중요합니다. 서로 겹치지 않거나 쉽게 구별되는 곡선이 있는 그래프의 경우 다른 색상만으로 충분합니다. 내 의견으로는 곡선에 표식이 없을 때 이 전략이 더 잘 작동합니다:\n\n```js\n## 데이터 생성\nx_data       = np.arange(1, 20, 1)\nx_data_gauss = np.arange(1, 20, 0.5)\n\nslope0 = 1.5 \nslope1 = 3\nslope2 = 6\nint0   = 1\nint1   = 2\nint2   = 3\nint3   = 5\nint4   = 4\nsigma  = 2\nscale4 = 1.5\npower4 = 1.5\ny_data0 = slope0 * x_data + int0\ny_data1 = slope1 * x_data + int1\ny_data2 = slope2 * x_data + int2\ny_data3 = (1000 / (2 * np.pi * np.sqrt(np.power(sigma, 2)))) * np.exp(-1 * (np.power((x_data_gauss - 10), 2) / (2 * np.power(sigma, 2))))\ny_data4 = scale4 * np.power(x_data, power4) + int4\n\nmpl.rcParams.update({'font.size': 30})\nfig, ax = plt.subplots(figsize=(8,8))\n\nax.plot(x_data, y_data0,       markersize=7, linewidth=2, color='xkcd:azure',       label='$f(x)=%.1fx + %d$' % (slope0, int0))\nax.plot(x_data, y_data1,       markersize=7, linewidth=2, color='xkcd:carmine',     label='$f(x)=%.1fx + %d$' % (slope1, int1))\nax.plot(x_data, y_data2,       markersize=8, linewidth=2, color='xkcd:blue violet', label='$f(x)=%.1fx + %d$' % (slope2, int2))\nax.plot(x_data_gauss, y_data3, markersize=7, linewidth=2, color='xkcd:true green',  label='$f(x)=80e^{-(x-10)^{2}/8}$')\nax.plot(x_data, y_data4,       markersize=8, linewidth=2, color='xkcd:cyan',        label='$f(x)=%.1fx^{.1f} + %d$' % (scale4, power4, int4))\nax.set_xlabel('x', loc='right')\nax.set_ylabel('f(x)', loc='top')\nax.legend(loc='upper left', fontsize=20)\nax.set_xlim(0, 22)\nax.set_ylim(0, 160)\nax.set_xticks(np.arange(0, 25, 5))\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.5)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nax.minorticks_on()\nfig.tight_layout()\nfig.savefig('legend_example_colors_only_no_markers.pdf')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 색깔은 충분히 다르기 때문에 쉽게 구별할 수 있지만, 이 경우 선 스타일을 변경하는 것도 나쁘지 않습니다. 특히 곡선의 수가 색상과 마커/마커 채움 스타일을 쉽게 구별할 수 있는 한계점에 접근할 때 추가가 가치가 있습니다.\n\n내 의견으로는 각 곡선에 동일한 마커를 추가하면 플롯이 혼란스러워집니다. 색상은 다르지만 그렇습니다.\n\n```js\nmpl.rcParams.update({'font.size': 30})\nfig, ax = plt.subplots(figsize=(8,8))\n\nax.plot(x_data, y_data0,       marker='o', markersize=7, linewidth=2, color='xkcd:azure',       label='$f(x)=%.1fx + %d$' % (slope0, int0))\nax.plot(x_data, y_data1,       marker='o', markersize=7, linewidth=2, color='xkcd:carmine',     label='$f(x)=%.1fx + %d$' % (slope1, int1))\nax.plot(x_data, y_data2,       marker='o', markersize=8, linewidth=2, color='xkcd:blue violet', label='$f(x)=%.1fx + %d$' % (slope2, int2))\nax.plot(x_data_gauss, y_data3, marker='o', markersize=7, linewidth=2, color='xkcd:true green',  label='$f(x)=80e^{-(x-10)^{2}/8}$')\nax.plot(x_data, y_data4,       marker='o', markersize=8, linewidth=2, color='xkcd:cyan',        label='$f(x)=%.1fx^{.1f} + %d$' % (scale4, power4, int4))\n#ax.plot(x_data, y_data1, marker='s', color='xkcd:carmine')\nax.set_xlabel('x', loc='right')\nax.set_ylabel('f(x)', loc='top')\nax.legend(loc='upper left', fontsize=20)\nax.set_xlim(0, 22)\nax.set_ylim(0, 160)\nax.set_xticks(np.arange(0, 25, 5))\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.5)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nax.minorticks_on()\nfig.tight_layout()\nfig.savefig('legend_example_colors_only.pdf')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마커와 채우기 스타일(또는 선 스타일)을 다르게 설정하면 도표를 더 쉽게 읽을 수 있습니다:\n\n![Plot Image](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_29.png)\n\n```js\nmpl.rcParams.update({'font.size': 30})\nfig, ax = plt.subplots(figsize=(8,8))\n\nax.plot(x_data, y_data0, marker='o', markersize=7, linewidth=2, color='xkcd:azure', label='$f(x)=%.1fx + %d$' % (slope0, int0))\nax.plot(x_data, y_data1, marker='s', markersize=7, linewidth=2, color='xkcd:carmine', label='$f(x)=%.1fx + %d$' % (slope1, int1))\nax.plot(x_data, y_data2, marker='^', markersize=8, linewidth=2, color='xkcd:blue violet', label='$f(x)=%.1fx + %d$' % (slope2, int2))\nax.plot(x_data_gauss, y_data3, marker='D', markersize=7, linewidth=2, color='xkcd:true green', label='$f(x)=80e^{-(x-10)^{2}/8}$', fillstyle='none',)\nax.plot(x_data, y_data4, marker='P', markersize=8, linewidth=2, color='xkcd:cyan', label='$f(x)=%.1fx^{.1f} + %d$' % (scale4, power4, int4), fillstyle='none',)\nax.set_xlabel('x', loc='right')\nax.set_ylabel('f(x)', loc='top')\nax.legend(loc='upper left', fontsize=20)\nax.set_xlim(0, 22)\nax.set_ylim(0, 160)\nax.set_xticks(np.arange(0, 25, 5))\nax.grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.5)\nax.grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\nax.minorticks_on()\nfig.tight_layout()\nfig.savefig('legend_example_colors_markers.pdf')\n```\n\n# Rule 9: 일관성은 중요합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n슬라이드 세트, 학회 포스터 또는 저널 논문에 서로 다른 스타일의 플롯이 포함되어 있는 것은 이상하게 보일 수 있습니다. 이겈 엄밀하게 보일 수 있지만, 일관된 스타일을 유지하는 것은 플롯 간의 연속성을 유지하고 작업을 보다 통일되게 보이게 도와줍니다. 이 스타일은 상황에 따라 달라질 수 있습니다. 예를 들어 일부 저널은 플롯(그리고 테이블 등)을 특정 형식으로 선호할 수 있습니다. 또는 많은 과학적 협업에서는 특정한 플롯 스타일이 논문을 저널에 제출하기 위해 요구될 수 있습니다. 더불어, 여러분의 작업이 더 유요하게 보이게 하고 발표 자료들 사이의 일관된 스타일을 유지하기 위해 도움이 됩니다. 그러므로, 여러분만의 플롯 스타일을 개발하거나 요구된 스타일을 채택한다면 작업의 일관성을 높일 수 있습니다.\n\n# Rule 10: 과적합에 주의하세요\n\n이것은 Rule 1과 모순된 것처럼 보일 수도 있지만, 모든 것은 균형을 이루어야 합니다. 하나의 플롯 용량은 무한하지 않습니다. 너무 많은 데이터나 텍스트 상자와 같은 부착물을 추가하면 메시지가 혼란스러워질 수 있습니다. 이러한 데이터를 서브플롯으로 분리하는 것은 그림의 가독성을 높이는 데 도움이 될 뿐입니다. 아래의 플롯은 이 효과를 완벽히 보여줍니다:\n\n\u003cimg src=\"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_30.png\" /\u003e \n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플롯의 혼란이 x ≥ 30에서 해소되지만 이 범위 아래의 값들은 데이터 포인트와 교차하는 선들이 꼬리를 치는 메시가 됩니다. 그 결과 플롯의 메시지가 흐려지게 되죠. 다음 규칙(규칙 11)에서 말했듯이, 데이터에 맞는 함수는 적합한 매개변수, 그 오차, 적합도 측정값을 나열한 텍스트 상자와 함께 사용되어야 합니다. 위의 플롯에서는 이러한 텍스트 상자를 넣을 공간이 없어서 플롯의 x 또는 y 한계를 불필요하게 연장시키게 되며, 결과적으로 규칙 13(“텍스트 상자를 절약하여 사용”)를 위반합니다. 이 문제를 해결하기 위해, 데이터셋과 해당 적합선을 개별 부분 그림으로 나누면 됩니다.\n\n여기에서 각 데이터셋이 명확하게 분리되어 있으며, 범례도 덜 복잡하며, 선형 최적 적합선과 일치하는 텍스트 상자가 추가되어 그림을 더 잘 정리하고 결과적으로 플롯을 훨씬 더 읽기 쉽게 만들 수 있습니다.\n\n# 규칙 11: 적합 매개변수를 요약하는 텍스트 상자 추가하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n텍스트 상자는 플롯에 완벽한 보충물이 될 수 있어요. 예를 들어, 적합이 적용된 데이터는 항상 적합 매개변수를 설명하는 텍스트 상자를 가져야 합니다. 또한 적합의 품질에 관한 어떤 측정 항목(예: 결정 계수, R², 또는 카이 제곱 통계의 자유도 수에 대한 비율, χ²/dof)이 표시돼야 해요.\n\n아래에 표시된 것처럼:\n\n![이미지](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_32.png)\n\n```python\n## 적합 함수 정의\ndef func(x_data, m_val, b_val):\n    return (m_val * x_data) + b_val\n    \npopt, pcov = curve_fit(func, x_data, y_data) # 함수 적합\n\n## 결정 계수 계산\nres          = y_data - func(x_data, *popt) # 잔차 계산\nsum_res_sq   = np.sum(np.power(res, 2)) # 잔차 제곱의 합\nsum_sq_total = np.sum(y_data - np.power(np.mean(y_data), 2))\nr_squared    = 1 - (sum_res_sq / sum_sq_total) # 결정 계수 계산\n\nmpl.rcParams.update({'font.size': 32})\nprops = dict(boxstyle='round', facecolor='xkcd:scarlet', alpha=0.3)\n\nfig, ax = plt.subplots(figsize=(9, 8))\nax.minorticks_on()\nax.grid('both', zorder=0)\n...\n(fig 설정 및 플롯)\n\nax.text(0.085, 0.75, \"$f(x) = mx + b$\\n$m = %.3f\\pm%.3f$\\n$b = %.3f\\pm%.3f$\\n$R^{2} = %.2f$\" % (popt[0], pcov[0, 0], popt[1], pcov[1,1], r_squared), fontsize=22, bbox=props, transform=ax.transAxes)\nfig.tight_layout()\nfig.savefig('linear_fit_example.pdf')\n```\n\n이 규칙은 히스토그램에서도 유용할 수 있어요. 종종 관련 통계 정보(평균, 표준 편차, 중앙값, 총 항목 수 등)를 요약하는 텍스트 상자를 추가하는 것이 매우 도움이 될 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Rule 12: 동시에 플롯을 비교할 때는 동일한 축 척도를 사용하세요\n\n데이터 시각화의 목표가 서로 다른 데이터 세트를 비교하는 것이라면, 이러한 데이터들을 동일한 축 척도를 사용하여 플로팅하는 것이 매우 중요합니다. 아래의 플롯을 살펴보세요. 이 플롯은 남성과 여성 콜레스테롤 분포의 확률 밀도 함수(PDFs)를 비교합니다 (Rule 0에서 사용된 'heart' 데이터셋):\n\n![PDF Comparison Plots](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_33.png)\n\n```js\n## 데이터 전처리\nlog_dens   = [log_dens_m, log_dens_f]\npdf_colors = ['forestgreen', 'xkcd:cerulean']\npdf_labels = ['남성', '여성']\n\nmpl.rcParams.update({'font.size': 28})\nfig, ax = plt.subplots(1, 2, figsize=(15, 8))\n\nfor subplot in np.arange(2):\n    ax[subplot].minorticks_on()\n    ax[subplot].grid(which='major', color='xkcd:cool grey', linestyle='-', alpha=0.7)\n    ax[subplot].grid(which='minor', color='xkcd:light grey', linestyle='--', alpha=0.5)\n    ax[subplot].plot(np.arange(0, 600), np.exp(log_dens[subplot]), color=pdf_colors[subplot], linewidth=2)\n    ax[subplot].set_xlabel('콜레스테롤 농도 (mg/dl)', loc='right')\n    ax[subplot].set_ylabel('확률 밀도', loc='top')\n    ax[subplot].grid('both', zorder=0)\n    ax[subplot].fill(np.arange(0, 600), np.exp(log_dens[subplot]), color=pdf_colors[subplot], alpha=0.4)\n    ax[subplot].set_xlim(-25, 625)\n    \n    legend = [mpatches.Patch(color=pdf_colors[subplot], label=pdf_labels[subplot], alpha=0.6)]\n    ax[subplot].legend(handles=legend)\n\nfig.tight_layout()\nfig.savefig('pdf_comparison_plots_different_scales.pdf')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 서브플롯의 y-축이 공통 범위를 공유하지 않기 때문에 두 PDF를 직접적으로 일대일로 비교하기 어렵습니다. 이 문제를 수정함으로써 이제 두 서브플롯을 더 쉽게 비교할 수 있습니다.\n\n![이미지](/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_34.png)\n\n# 규칙 13: 텍스트 상자를 절약해서 사용하세요\n\n이 규칙은 텍스트 상자를 과하게 사용하지 않도록 미세한 알림입니다. 이 규칙은 실제로 규칙 10(\"플롯을 너무 가득 채우지 마세요\")의 확장성에 불과합니다. 일부 데이터셋과 플롯에서는 나란히 플로팅된 데이터셋의 매개변수/서술자를 포함하는 여러 텍스트 상자를 추가하는 것이 유용할 수 있지만, 공간이 제한되어 있거나 플롯이 이미 균형을 이루고 있는 경우, 추가 텍스트 상자를 맞추기 위해 축을 늘리지 마세요. 해당 정보는 그림 설명에 추가할 수 있습니다. 예를 들어, 규칙 10의 첫 번째 예제에 모든 세 맞춤 매개변수에 대한 텍스트 상자를 추가하는 것은 부적절합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 규칙 14: 플롯을 .pdf 파일로 저장하세요\n\n이것은 제 개인적인 짜증 나는 점 중 하나 입니다. .png, .jpg, .gif 또는 .tiff와 같은 형식은 래스터(비트맵) 이미지 형식의 가족에 속하며 일반적으로 인치당 도트 (dpi) 또는 픽셀당 인치 (ppi)로 지정된 해상도를 사용하여 이미지를 구성합니다. 이는 확대할 때 픽셀의 난리를 볼 수 있다는 불행한 상황으로 이어집니다. 반면에 .pdf, .svg 또는 .eps와 같은 벡터 그래픽 형식은 정보를 객체로 저장합니다 (예: 객체와 공간 상의 위치에 대한 설명). 결과적으로 복잡한 플롯에서 정보를 추출하는 것이 훨씬 쉬워지기 때문에 무한대로 확대할 수 있습니다. 대부분의 플롯이 어차피 컴퓨터에서 볼텐데, 사용자가 무한대로 확대할 수 있는 자유를 허용하는 것이 좋지 않을까요?\n\n# 요약 및 결론\n\n이 기사를 쓰기 시작했을 때는 훨씬 짧을 것이라고 생각했지만, 이러한 규칙과 그와 관련된 예제에 대해 더 많이 쓰고 생각한 후에는 이 글이 완전한 변론으로 번지게 되었습니다. 이렇게까지 오신 여러분께 진심으로 감사드리며, 이 금구가이나 그 예제들에서 의미 있는 정보를 추출할 수 있었으면 좋겠습니다. 제가 준수하는 데이터 시각화 규칙이나 일반 원칙을 빠뜨렸다면, 댓글을 남겨 알려주세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요약하면, 아래 규칙을 나열합니다:\n\n규칙 0: 데이터 유형을 고려해야 합니다.\n규칙 1: 면적 당 정보를 극대화해야 합니다.\n규칙 2: 중요한 축 레이블을 무시해서는 안 됩니다.\n규칙 3: 가능한 경우 오차 막대를 추가해야 합니다.\n규칙 4: 모든 것의 글꼴 크기를 키워야 합니다.\n규칙 5: 축 스케일을 적절히 설정해야 합니다.\n규칙 6: 작은 눈금선과 격자를 사용해야 합니다.\n규칙 7: 범례를 잊어서는 안 됩니다.\n규칙 8: 명확성이 매우 중요합니다.\n규칙 9: 일관성이 필수입니다.\n규칙 10: 지나치게 혼잡해지지 않도록 주의해야 합니다.\n규칙 11: 적합 매개변수를 요약하는 텍스트 상자를 추가해야 합니다.\n규칙 12: 그림을 제품 측면에 표시할 때 동일한 축 스케일을 사용해야 합니다.\n규칙 13: 텍스트 상자를 절약해서 사용해야 합니다.\n규칙 14: 그림을 .pdf 파일로 저장해야 합니다.\n\n이 기사를 좋아하셨다면 더 많이 보시고 싶다면, 저를 팔로우하시고 이메일 알림을 받아보시는 것을 고려해 주세요!","ogImage":{"url":"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_0.png"},"coverImage":"/assets/img/2024-07-01-HowtoMakeYourDataVisualizationsTellaStory_0.png","tag":["Tech"],"readingTime":55},{"title":"API를 활용한 증분 데이터 로딩 스크립트를 작성할 때 반드시 해결해야 할 3가지 필수 질문","description":"","date":"2024-07-01 15:56","slug":"2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript","content":"\n\n# 개요\n\n- 애플리케이션(예: 광고 성과, 판매 수치 등)에서 데이터를 데이터베이스로 동기화하려고 합니다.\n- 애플리케이션은 데이터를 검색하기 위한 API 엔드포인트를 제공합니다.\n- 데이터는 매일 데이터베이스로 동기화되어야 합니다.\n- 데이터베이스에는 ❗\"새로운\" 데이터(또는 변경 사항)❗ 만로드하려고 합니다. 동기화할 때 매번 전체 데이터 집합을 다시로드하고 싶지 않습니다.\n\n여러분은 Python에서 어떻게 처리할 것인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 💥 질문 1: 데이터를 점진적으로 동기화하기 위해 API로부터 어떤 것이 필요한가요?\n\n점진적으로 로딩하는 스크립트를 개발하기 전에, 작업 중인 API 엔드포인트의 동작을 이해해야합니다.\n\n❗모든 API가 점진적으로 로딩을 지원할 수 있는 것은 아닙니다.\n\n## 👉 답변: 점진적 로딩을 지원하는 쿼리 매개변수\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n판매 실적을 추적하는 응용 프로그램(또는 \"소스\" 응용 프로그램)의 예제를 살펴보겠습니다. 이 응용 프로그램에서 각 레코드는 제품과 해당 판매량을 나타냅니다. 생성된 필드(created_at)와 업데이트된 필드(updated_at)는 레코드가 생성 및 업데이트된 시기를 나타냅니다.\n\n판매 데이터의 변경 사항은 일반적으로 두 가지 주요 방식으로 발생합니다:\n\n- 새 제품이 목록에 추가됩니다.\n- 기존 레코드의 판매 데이터가 업데이트되어, updated_at에 새 값이 생성됩니다. 이를 통해 새 변경 사항을 추적할 수 있습니다. 이 정보가 없으면 어떤 레코드가 수정되었는지 알 수 없습니다.\n\n👁️👁️ 아래는 소스 응용 프로그램의 데이터베이스에서의 예제 판매 테이블입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n↪️ 어제의 데이터: 2개의 레코드\n\n![어제의 데이터](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_0.png)\n\n↪️ 오늘의 데이터: 새 레코드 추가 및 기존 레코드 수정\n\n![오늘의 데이터](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🟢 핵심 내용: 만약 API 엔드포인트가 updated_at 매개변수를 기반으로 쿼리를 허용한다면, 이전 동기화에서 저장된 가장 최근 updated_at 값보다 나중에 갱신된 updated_at 값을 가진 레코드만 검색하기 위해 요청을 보내는 방식으로 점진적으로 데이터를 로드할 수 있습니다. 이 문맥에서 updated_at은 점진적 커서로 참조되며, 그 값은 다음 동기화까지 유지되는 상태로 알려져 있습니다.\n\nupdated_at 필드는 점진적 커서로 일반적으로 선택됩니다. id나 sales와 같은 다른 쿼리 매개변수는 마지막 동기화 이후 추가되거나 업데이트된 레코드를 알려주지 못하기 때문에 데이터를 점진적으로 요청하는 데 도움을 줄 수 없습니다.\n\n어떤 쿼리 매개변수가 데이터를 점진적으로 로드하는 데 필요한가요?\n\n![이미지](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 🤷 페이지네이션 메커니즘\n\nAPI는 성능을 향상하기 위해 결과를 작은 단위로 반환하는 경우가 많습니다. 예를 들어, 한 번에 10,000 개의 레코드를 반환하는 대신 API는 각 요청당 최대 100 개의 레코드로 응답을 제한할 수 있으며, 여러 일괄처리를 거쳐 순환해야 합니다.\n\n이를 관리하기 위해 전형적으로 (항상 그렇지는 않음) 두 개의 쿼리 매개변수인 limit과 skip(또는 offset)을 사용해야 합니다.\n\n간단한 예제를 통해 설명해드리겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 요청사항:\n\n- limit=100\n- skip=0\n\n두 번째 요청사항, 이미 동기화한 처음 100개의 레코드를 건너뛰기 위해:\n\n- limit=100\n- skip=100\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 패턴은 각 배치마다 제한을 따라 건너뛰기 값을 증가시키면서 모든 레코드가 검색될 때까지 계속됩니다.\n\n🟢 인사이트: API가 응답을 반환하는 방식을 이해해야 누락된 레코드가 발생하지 않습니다. API가 페이지네이션을 관리하는 데 사용할 수 있는 방법은 skip 및 offset이외에도 다양합니다. 하지만 이는 다음에 이야기할 주제입니다.\n\n## 🤷 경로 매개변수\n\n경로 매개변수는 API의 URL에 직접 포함되며 일반적으로 데이터의 다른 세그먼트(파티션)를 구별하는 데 사용됩니다. 예를 들어, 마케팅 계정 내의 다양한 캠페인을 지정하거나 소스 애플리케이션에서 관리되는 다른 하위 계정을 지정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예시에서는 경로 파라미터로 applicationId와 campaignId가 사용됩니다.\n\nhttps://yourbaseurl.myapp/v1/applications/'applicationId'/campaigns/'campaignId'/sales\n\n🟢 요점: 동일한 API에서 다른 경로 파라미터를 사용해 데이터를 동기화할 때, 하나의 테이블에 동기화할지 아니면 별도의 테이블에 동기화할지를 결정해야 합니다 (sales_campaign_1, sales_campaign_2 등).\n\n# 💥 질문 2: 추출된 레코드를 목적지 테이블에 어떻게 쓰고 싶습니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 위에서 언급한 매개변수를 사용하여 API 요청을 통해 여러 레코드를 이미 추출했다고 가정해 봅시다. 이제 목적지 테이블에 어떻게 쓸지를 결정할 때입니다.\n\n## 👉 답변: 병합/중복 제거 모드 (권장)\n\n이 질문은 Write disposition 또는 Sync 모드의 선택과 관련이 있습니다. 즉시 대답하면, 데이터를 점진적으로 로드하려고 한다면 추출한 데이터를 추가 모드 또는 병합 모드(중복 제거 모드로도 알려짐) 중 하나로 쓰는 것이 좋을 것입니다.\n\n그러나 우리는 옵션을 더 신중히 살펴보고 점진적으로 로드하기에 가장 적합한 방법이 무엇인지 결정해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인기있는 라이트 배치 방법은 다음과 같아요.\n\n- 🟪 덮어쓰기/대체: 대상 테이블의 모든 기존 레코드를 삭제한 후 추출된 레코드를 삽입해요.\n- 🟪 추가: 추출된 레코드를 단순히 대상 테이블에 추가해요.\n- 🟪 병합/중복제거: 새로운(*) 레코드를 삽입하고 기존 레코드를 업데이트해요.\n\n(*) 어떻게 새 레코드를 알 수 있을까요?: 보통, 주요 키를 사용하여 그것을 결정해요. dlt를 사용한다면, 병합 키와 주요 키를 구분하는 병합 전용키와 중복 제거 전 병합을 위한 중복 제거 정렬 등을 포함한 더 정교한 병합 전략을 사용할 수 있어요. 이 부분은 다른 튜토리얼에서 다루기로 해요.\n\n(**) 이것은 간단한 설명이에요. 더 많은 정보를 원하시면 dlt가 이 병합 전략을 어떻게 처리하는지 자세히 알고 싶다면 여기를 더 읽어보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👁️👁️ 안녕하세요! 다양한 쓰기 방식 결과를 이해하는 데 도움이 되는 예제를 준비해봤어요.\n\n↪️ 2024.06.19: 첫 번째 동기화를 수행했어요.\n\n🅰️ 소스 애플리케이션의 데이터\n\n![이미지](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🅱️ 데이터가 목적지 데이터베이스로로드되었습니다.\n\n어떤 동기화 전략을 선택하더라도 목적지의 테이블은 원본 테이블의 복사본입니다.\n\n![이미지](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_4.png)\n\n2개의 레코드를 동기화한 결과, 최신 업데이트 날짜인 2024-06-03의 상태가 저장되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n↪️ 2024.06.2일: 두 번째 동기화를 진행합니다.\n\n🅰️ 소스 응용 프로그램의 데이터\n\n![이미지](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_5.png)\n\n✍️ 소스 테이블의 변경 사항:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 레코드 id=1이 업데이트되었습니다 (매출액).\n- 레코드 id=2가 삭제되었습니다.\n- 레코드 id=3이 삽입되었습니다.\n\n이번 동기화에서는 **updated_at**이 2024년 6월 3일인 레코드만 추출합니다 (마지막 동기화 상태로 저장됨). 따라서 레코드 id=1 및 id=3만 추출됩니다. 소스 데이터에서 레코드 id=2가 제거되었기 때문에 이 변경사항을 인식할 방법이 없습니다.\n\n두 번째 동기화 시, 이제 쓰기 전략 간 차이를 확인할 수 있습니다.\n\n🅱️ 목적지 데이터베이스에 데이터가 로드되었습니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n❗ 시나리오 1: 덮어쓰기\n\n![image](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_6.png)\n\n이번에 추출된 2개의 레코드로 대상 테이블이 덮어쓰여질 것입니다.\n\n❗ 시나리오 2: 추가하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![img1](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_7.png)\n\n추출된 2개의 레코드가 대상 테이블에 추가됩니다. 기존 레코드는 영향을 받지 않습니다.\n\n❗ 시나리오 3: 병합 또는 중복 제거\n\n![img2](/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nid가 1 및 3인 레코드 2개가 추출되어 대상에 있는 기존 레코드를 대체합니다. 이 과정을 병합 또는 중복 제거라고 합니다. 대상 테이블의 id가 2인 레코드는 그대로 유지됩니다.\n\n🟢 포인트: 병합(중복 제거) 전략은 증분 데이터 로드 파이프라인에서 효과적일 수 있지만, 테이블이 매우 크면 이러한 중복 제거 과정에 상당한 시간이 소요될 수 있습니다.\n\n# 💥 질문 3: 코드에서 어떻게 구현할까요?\n\n## 👉 답변: dlt — 경량이며, 문서화가 잘 되어 있으며, 지원을 위해 활성화된 커뮤니티가 있는 것을 이용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다이어그램을 참조하여 상위 수준을 확인한 후 아래에 자세한 설명과 함께 코드로 들어가보세요.\n\n빠른 참고: dlt는 구조화를 위해 용어 source와 resources를 사용합니다. 리소스는 일반적으로 API 엔드포인트에 해당하며 데이터를 대상 데이터베이스의 테이블에 작성합니다. 소스는 리소스의 집합입니다.\n\n아래 그림에서 우리가 논의한 두 가지 질문에 대한 답을 볼 수 있습니다:\n\n- 질문 1에 대한 답변: 날짜 커서를 사용하여 API 엔드포인트에 요청을 보내 데이터를 점진적으로 가져옵니다 (그리고 점진적인 실행을 위해 커서 값을 지속적으로 유지하는 상태로도 알려져 있습니다).\n- 질문 2에 대한 답변: 병합 전략을 사용하여 대상 테이블에 데이터를 작성하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n💥 여기에는 제 주석이 달린 DLT 구현 스니펫이 있어요 💥\n\n🟣️ 전체 코드는 여기 저장소에서 확인할 수 있어요 🟣\n\n✅ 이로서 튜토리얼을 마치겠습니다. 점진적 로딩 스크립트를 구성하는 다양한 구성 요소 및 코드 구현에 대해 배우셨길 바라며,\n\nDLT로 점진적 로딩 스크립트를 작성하는 방법에 대해 더 알고 싶다면 여기서 문서를 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 나에 대해\n\n안녕하세요, 베를린에 거주 중인 Daniel Le입니다. 현재, 저는 기계 학습에 대한 큰 열정을 가지고 데이터 엔지니어로 일하고 있습니다.\n\n저는 독일 베를린에 거주하고 있으며 새로운 기술에 관심이 많으며 이를 실제 문제 해결에 어떻게 적용할 수 있는지 고민합니다.\n\n궁금한 점이 있거나 이러한 관심사를 더 자세히 논의하고 싶다면 망설이지 말고 LinkedIn에서 저와 연락해 주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고\n\n- https://dlthub.com/docs/general-usage/incremental-loading","ogImage":{"url":"/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_0.png"},"coverImage":"/assets/img/2024-07-01-3EssentialQuestionstoAddressWhenBuildinganAPI-InvolvedIncrementalDataLoadingScript_0.png","tag":["Tech"],"readingTime":12},{"title":"Microsoft DSA 면접 질문 모음","description":"","date":"2024-07-01 15:54","slug":"2024-07-01-MicrosoftDSAInterviewQuestions","content":"\n\n# 질문 1\n\n![이미지](/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png)\n\n두 개의 동일한 길이를 가진 정수 배열 A와 B가 주어졌을 때, 시작점 j까지 A의 요소들의 누적 합이 B의 요소들의 누적 합과 같은 경우의 수를 반환하는 solution(A, B) 함수를 작성하십시오. 이때 다음 조건들을 만족해야 합니다:\n\n- A의 요소들의 누적 합이 시작부터 j까지 B의 요소들의 누적 합과 동일합니다.\n- A의 요소들의 누적 합이 배열 A의 총 합의 절반과 동일합니다.\n- B의 요소들의 누적 합이 배열 B의 총 합의 절반과 동일합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 방법,\n\n- 총합 초기화: 주석은 sumA 및 sumB의 초기화 및 목적을 명확히 합니다.\n- 총합 계산: 총합을 계산하는 루프에 대한 주석이 있습니다.\n- 유효한 분할 지점 계산: count의 목적 및 유효한 분할 지점을 확인하는 논리에 대한 설명이 있습니다.\n- 누적 합: tempA 및 tempB의 초기화 및 누적 합을 추적하는 역할을 명확히 하는 주석이 있습니다.\n- 반복 및 조건 확인: 두 번째 요소부터 시작하는 루프, 유효한 분할 지점을 찾기 위해 확인된 조건 및 누적 합의 업데이트를 설명하는 주석이 있습니다.\n\n## 실제 실행,\n\n```js\n단계별 결과\n\n총합 계산:\nsumA 진행: 0, 4, 3, 3, 6\nsumB 진행: 0, -2, 3, 3, 6\n최종 sumA = 6\n최종 sumB = 6\n\n누적 합 및 조건 확인:\n\n초기화:\ntempA = 0\ntempB = 0\n\n반복:\n\nj = 1:\ntempA = 4\ntempB = -2\n조건 미충족\n\nj = 2:\ntempA = 3\ntempB = 3\n조건: tempA === tempB \u0026\u0026 2 * tempA === sumA \u0026\u0026 2 * tempB == sumB\n3 === 3 \u0026\u0026 2 * 3 === 6 \u0026\u0026 2 * 3 == 6 (참)\n하지만, j !== 1이어야 조건이 검사됨\n\nj = 3:\ntempA = 3\ntempB = 3\n조건: tempA === tempB \u0026\u0026 2 * tempA === sumA \u0026\u0026 2 * tempB == sumB\n3 === 3 \u0026\u0026 2 * 3 === 6 \u0026\u0026 2 * 3 == 6 (참)\n조건 충족, 그러나 j !== 1이므로 조건이 이 단계에서는 확인되지 않음\n\nj = 4:\ntempA = 6\ntempB = 6\n필요한 길이를 초과하여 조건 확인이 안 됨\n\n최종 결과:\n조건 j !== 1 \u0026\u0026 tempA === tempB \u0026\u0026 2 * tempA === sumA \u0026\u0026 2 * tempB == sumB이 전혀 충족되지 않아 count는 0으로 남습니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 구현,\n\n```js\nA: [0,4,-1,0,3]\nB: [0,-2,5,0,3]\n\nfunction solution(A, B) {\n  // 배열 A와 B의 총합을 저장할 sumA와 sumB를 초기화합니다.\n  let sumA = 0;\n  let sumB = 0;\n\n  // 배열 A와 B의 요소 총합을 계산합니다.\n  for (let i = 0; i \u003c A.length; i++) {\n    sumA += A[i]; // 각 반복 후 sumA = [0, 4, 3, 3, 6]\n    sumB += B[i]; // 각 반복 후 sumB = [0, -2, 3, 3, 6]\n  }\n\n  // sumA는 이제 6입니다.\n  // sumB는 이제 6입니다.\n\n  // 유효한 분할 지점의 수를 추적하는 count를 초기화합니다.\n  let count = 0;\n\n  // 현재 인덱스까지 누적 합을 저장할 tempA와 tempB를 초기화합니다.\n  let tempA = A[0]; // tempA = 0\n  let tempB = B[0]; // tempB = 0\n\n  // 두 번째 요소부터 배열을 반복합니다.\n  for (let j = 1; j \u003c A.length; j++) {\n    // 현재 누적 합(첫 번째 인덱스 제외)이 같고,\n    // 서로의 배열 합의 절반인지 확인합니다.\n    if (j !== 1 \u0026\u0026 tempA === tempB \u0026\u0026 2 * tempA === sumA \u0026\u0026 2 * tempB == sumB) {\n      count++; // 이 경우 조건이 충족되지 않아 count는 여전히 0입니다.\n    }\n\n    // 현재 요소로 누적 합을 업데이트합니다.\n    tempA += A[j]; // 각 반복 후 tempA 값: [0, 4, 3, 3, 6]\n    tempB += B[j]; // 각 반복 후 tempB 값: [0, -2, 3, 3, 6]\n  }\n\n  // 유효한 분할 지점의 수를 반환합니다.\n  return count; // 유효한 분할 지점을 찾지 못해 count는 0입니다.\n}\n\n// 사용 예시\nconst A = [0, 4, -1, 0, 3];\nconst B = [0, -2, 5, 0, 3];\nconsole.log(solution(A, B)); // 출력: 0\n```\n\n# 두 번째 질문\n\n\u003cimg src=\"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계별 접근 방법:\n\n초기화:\n\n- 각 요소가 이전 요소와 다음 요소보다 큰지를 추적하는 배열 isGreaterThanPrev 및 isGreaterThanNext를 초기화합니다.\n- 이전 요소나 다음 요소와 비교할 요소가 없는 첫 번째 요소의 isGreaterThanPrev와 마지막 요소의 isGreaterThanNext를 -1로 초기화합니다.\n\n비교 배열 채우기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 배열 Y를 순회하여 각 요소가 다음 요소보다 큰지 나타내는 isGreaterThanNext를 채웁니다.\n- 배열 Y를 순회하여 각 요소가 이전 요소보다 큰지 나타내는 isGreaterThanPrev를 채웁니다.\n\n쌍(Pairs) 생성 및 정렬:\n\n- 각 Y의 요소에 대해 [값, 인덱스] 쌍을 포함하는 배열 v를 생성합니다.\n- 배열 v를 요소의 값에 기반하여 내림차순으로 정렬합니다.\n\n변수 초기화:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- cur와 maxLines라는 변수를 초기화하여 현재 라인 수와 관찰된 최대 라인 수를 추적합니다.\n\n정렬된 요소 처리:\n\n- 동일한 값으로 처리할 요소를 처리하기 위해 정렬된 배열 v를 반복합니다.\n- 각 요소에 대해 다음을 계산합니다:\n  - down: 시작 부분에서 이전 요소보다 큰 요소 수 또는 끝 부분에서 다음 요소보다 큰 요소 수.\n  - up: 시작 부분에서 다음 요소보다 크지 않은 요소 수 또는 끝 부분에서 이전 요소보다 크지 않은 요소 수.\n  - peaks: 다음과 이전 요소보다 큰 요소 수.\n  - valleys: 다음과 이전 요소보다 작은 요소 수.\n  - peaks를 추가하고 valleys를 빼고 down/up 값을 통해 현재 라인 수 cur를 조정합니다.\n  - 현재 라인 수가 이전 최대값을 초과하면 최대 라인 수 maxLines를 업데이트합니다.\n\n결과 반환:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 배열에서 각각의 peak(봉우리)와 valley(골짜기) 전환을 나타내는 비중복 라인(줄)의 최대 수인 maxLines를 반환합니다.\n\n## 실행 과정,\n\n```js\n중간 결과와 함께 설명:\n초기화:\n\n이전 요소보다 큰지, 이후 요소보다 큰지를 추적할 isGreaterThanPrev 및 isGreaterThanNext 배열이 생성됩니다.\nisGreaterThanNext = [false, true, true, false, false, true, -1]\nisGreaterThanPrev = [-1, true, false, false, true, true, false]\n쌍 생성 및 정렬:\n\nY의 각 요소에 대해 [값, 인덱스] 쌍 생성합니다.\n정렬 전 v: [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]\n값을 기준으로 v를 내림차순으로 정렬합니다.\n정렬 후 v: [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]\n정렬된 요소 처리:\n\n요소 6 (인덱스 5):\ndown = 1, 이전 요소보다 크고, 끝에 위치하므로\nup = 0, 조건 충족 없음.\ncur = 1, maxLines = 1\n요소 5 (인덱스 4와 6):\n인덱스 4:\ndown = 0, up = 0\n인덱스 6:\ndown = 0, up = 1, 이전 요소보다 크지 않고, 끝에 위치하므로\n봉우리 = 0, 골짜기 = 0\ncur = 1 - 1 = 0, maxLines = 1\n요소 3 (인덱스 1):\ndown = 0, up = 0\n봉우리 = 1, 이전과 이후 요소보다 크기 때문.\ncur = 0 + 1 - 0 = 1, maxLines = 1\n요소 2 (인덱스 0와 2):\n인덱스 0:\ndown = 0, up = 1, 이후 요소보다 크지 않고, 시작에 위치하므로\n인덱스 2:\ndown = 0, up = 0\n봉우리 = 0, 골짜기 = 1, 이전과 이후 요소보다 작기 때문.\ncur = 1 - 1 - 0 = 0, maxLines = 1\n요소 1 (인덱스 3):\ndown = 0, up = 0\n봉우리 = 0, 골짜기 = 0\ncur = 0 + 0 - 0 = 0, maxLines = 1\n최종 결과:\n\n관측된 최대 라인 수는 1이고, 따라서 maxLines = 1입니다.\r\n```\n\n## 구현,\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunction solution(Y) {\n  let n = Y.length;\n\n  // 다음 요소보다 크다는지 이전 요소보다 크다는지 추적하는 배열\n  let isGreaterThanPrev = new Array(n);\n  let isGreaterThanNext = new Array(n);\n  isGreaterThanNext[n - 1] = -1; // 마지막 요소는 다음 요소가 없음\n  isGreaterThanPrev[0] = -1; // 첫 요소는 이전 요소가 없음\n\n  // isGreaterThanNext 배열 작성\n  for (let i = 0; i \u003c n - 1; i++) {\n    isGreaterThanNext[i] = Y[i] \u003e Y[i + 1];\n  }\n\n  // isGreaterThanNext = [false, true, true, false, false, true, -1]\n\n  // isGreaterThanPrev 배열 작성\n  for (let i = 1; i \u003c n; i++) {\n    isGreaterThanPrev[i] = Y[i] \u003e Y[i - 1];\n  }\n\n  // isGreaterThanPrev = [-1, true, false, false, true, true, false]\n\n  // [값, 인덱스] 쌍의 배열 생성\n  let v = [];\n  for (let i = 0; i \u003c n; i++) {\n    v.push([Y[i], i]);\n  }\n\n  // v = [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]\n\n  // 값 기준으로 내림차순 정렬\n  v.sort((a, b) =\u003e b[0] - a[0]);\n\n  // v = [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]\n\n  let cur = 0,\n    maxLines = 0;\n  for (let i = 0; i \u003c v.length; i++) {\n    let y = v[i][0];\n\n    let peaks = 0,\n      valleys = 0,\n      down = 0,\n      up = 0;\n\n    // 동일한 값 요소 처리\n    while (i \u003c v.length \u0026\u0026 v[i][0] === y) {\n      let idx = v[i][1];\n\n      // 아래로 향하는 지점인지 확인\n      if (\n        (idx === 0 \u0026\u0026 isGreaterThanNext[idx]) ||\n        (idx === n - 1 \u0026\u0026 isGreaterThanPrev[idx])\n      ) {\n        down++;\n      }\n\n      // 올라가는 골짜기인지 확인\n      if (\n        (idx === 0 \u0026\u0026 !isGreaterThanNext[idx]) ||\n        (idx === n - 1 \u0026\u0026 !isGreaterThanPrev[idx])\n      ) {\n        up++;\n      }\n\n      let isNotEnd = idx \u003e 0 \u0026\u0026 idx \u003c n - 1;\n\n      // 산인지 확인\n      if (isNotEnd \u0026\u0026 isGreaterThanNext[idx] \u0026\u0026 isGreaterThanPrev[idx]) {\n        peaks++;\n      } \n      // 계곡인지 확인\n      else if (isNotEnd \u0026\u0026 !isGreaterThanNext[idx] \u0026\u0026 !isGreaterThanPrev[idx]) {\n        valleys++;\n      }\n      i++;\n    }\n\n    i--;\n\n    // 현재 라인 수 계산\n    cur = cur + peaks - valleys + down;\n    maxLines = Math.max(maxLines, cur);\n\n    cur = cur + peaks - valleys - up;\n    maxLines = Math.max(maxLines, cur);\n  }\n\n  return maxLines;\n}\n\n// 사용 예시\nconsole.log(solution([2, 3, 2, 1, 5, 6, 5])); // 출력: 2\r\n```\n\n# 읽어 주셔서 감사합니다\n\n- 👏 이야기에 박수를 보내주시고 팔로우 부탁드립니다 👉\n- 📰 자바스크립트, 자료 구조 및 알고리즘, 리액트, 인터뷰 준비 등 다양한 콘텐츠 확인해보세요\n- 🔔 팔로우 링크: LinkedIn!\n\n늘 개선할 점이 있을텐데요. 의견을 자유롭게 공유해주세요. 😊\n","ogImage":{"url":"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png","tag":["Tech"],"readingTime":9},{"title":"돈 버는 것 말고도 코딩이 삶을 업그레이드하는 5가지 뜻밖의 방법","description":"","date":"2024-07-01 15:53","slug":"2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney","content":"\n\n\n![image](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_0.png)\n\n항상 궁금해했어요.\n\n왜 코딩을 몇 시간씩 연달아 쉽게 할 수 있을까, 그러나 쓰기에 대해서는 그렇지 못한 걸까요?\n\n코딩할 때 느끼는 특정한 감정과 가치 때문이라고 알았지만 쓰기에는 그런 느낌이 덜했어요.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결국 코딩에 대해 즐겁고 의미 있는 5가지 정도를 발견했어요.\n\n어떤 활동이든 더 즐겁고 만족스럽게 만들 수 있는 것들이 있어요.\n\n코딩은 우리에게 목적, 성장, 그리고 다른 3가지 소중한 가치를 제공해요.\n\n# 1. 목적\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코딩에는 계속된 동기와 열정이 주어져요.\n\n아침에 일어나는 이유가 생겨요.\n\n매번 대규모 코딩 프로젝트는 많은 흥미로운 목표와 성취까지의 새로운 미션이에요.\n\n끝없는 모험이죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n엔드리스 러너 게임인 Subway Surfers와 같은 게임을 처음부터 만든다고 상상해보세요:\n\n![game screenshot](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_1.png)\n\n할 일이 정말 많을 거예요:\n\n- 게임 엔진 다운로드 및 설치: Unity와 같은 것\n- 스프라이트 만들기: 캐릭터, 호버보드, 의상 등\n- 엔드리스 러닝을 위한 알고리즘 만들기…\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n매 단계마다 성취감과 방향을 뚜렷이 만들어 줍니다.\n\n## 2. 성장: 사람과 코드의 성장\n\n![이미지](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_2.png)\n\n## 당신\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사람으로서成長한다는 것은 새롭고 흥미로운 삶을 느끼게 합니다.\n\n가치 있는 것을 더 많이 얻을 때 성장합니다:\n\n- 힘: 체육관에서 레벨 업\n- 자유: 중독에서 벗어나기 - 알코올, 포르노 등\n- 지식: 언어에 능숙해지기\n\n코딩 지식과 기술을 향상시킬수록 개인으로서 집중된 진전을 이루는 느낌을 받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신은 다음을 통해 능숙해집니다:\n\n- 문제 해결과 알고리즘 설계\n- 깔끔하고 가독성있는 코드 작성\n- 결합이 최소화된 모듈화된 일관성 있는 코드 작성\n\n# 당신의 코드\n\n누군가가 성장하는 것을 돕는 것으로 키우세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 아이를 키우기\n- 몸 변화 코칭\n- 가드닝\n\n코딩할 때, 프로그램을 기르는 것과 같아요.\n\n새로운 줄과 커밋마다 시스템이 새로운 기능으로 업그레이드돼요.\n\n높은 수준에서는:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 태그를 마크다운 형식으로 변경하였습니다.\n\n- You give it more features\n- You make it faster\n- You improve the UI\n\nLow-level:\n\n- You refactor: greater readability\n- You fix bugs\n- You create tests: greater stability\n\n# 3. Cognitive challenge: and mental stimulation\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코딩을 하면 뇌가 활발해져요!\n\n마치:\n\n- 체스\n- 철학\n- 논쟁 \u0026 수학 증명 문제 해결\n\n문제 해결 알고리즘을 만들려면 많은 논리적 처리와 기억 검색이 필요해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특히 복잡한 게임과 백엔드 중심 어플리케이션에 대해요.\n\n당신의 인지 능력을 발휘하고 즐거움에 젖어들며, 의자에 몇 시간을 묶여 있게 될 거에요.\n\n작업을 마치면 깊은 성취감을 느낄 거에요.\n\n그것이 우리가 코딩 뷰티 플레이를 만든 이유 중 하나에요 - 당신의 기억력을 시험하고 사고하게 만드는 정기 퍼즐을 제공하기 위해서죠!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 서식이 지정된 문자열에서 숫자로 변환하는 데 필요한 모든 처리를 살펴보세요:\n\n![image](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_3.png)\n\n## 4. 창조와 자동화의 힘\n\n코딩은 당신을 모든 것을 다룰 수 있는 디지턼 신으로 만들어 줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신은 단순히 생각만으로 완전히 새로운 세계를 창조할 수 있어요.\n\n이것이 게임 프로그래밍과 프런트엔드 UI 디자인이 왜 그토록 흥미로울 수 있는 주요 이유입니다.\n\n매일 사용하는 수백만 개의 게임과 앱은 어디서 왔을까요?\n\n![image](/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것들은 투자자의 자금이나 코드 편집기에서 오지 않았어요; 이것들은 그저 도구일 뿐이었어요.\n\n그것들은 창조자와 개발자들의 마음에서 시작되었어요.\n\n모든 것은 아이디어에서 시작되었어요 - 세상을 혁신하고 수십억을 창출하는 아이디어들이에요.\n\n가상 세계와 물리적 세계 둘 다에 영향을 주는 것이죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 자동화\n\n코딩을 통해 단 몇 초 안에 엄청난 양의 작업을 완료할 수 있어요.\n\n매일 Google 검색이 하는 모든 작업을 생각해보세요:\n\n- 초당 99,000개의 쿼리\n- 하루에 85억 건의 검색\n- 하루에 2조 건의 전 세계 검색\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요청하신 테이블 태그를 Markdown 형식으로 변경해드릴게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 유니티: 코드와 사람들의 \n\n# 코드\n\n코딩을 하면 협업의 아름다움을 직접 체험할 수 있어요.\n\n여러 복잡한 시스템 구성 요소가 하나로 통합되어 서로 협력하여 공통의 목표를 향해 일하는 멋진 경험을 할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n체스판의 조각들처럼 조화롭게 작동하는 것처럼 조심히 연결되어 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:960/0*cmpJHu03JhvTAqrN.gif)\n\n파일을 모듈과 객체로 분리하면 이를 볼 수 있습니다.\n\n각 모듈은 더 큰 시스템의 전반적인 목표를 달성하는 데 역할을 수행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그들은 자신보다 더 큰 무언가인 커뮤니티의 일원이 될 수 있는 기회를 가지고 있어요.\n\n# 인간으로서\n\n우리가 팀으로서 함께 일할 때도 마찬가지에요.\n\n우리는 공동의 목표를 향해 노력하면서 함께 속할 수 있는 느낌을 느껴요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 연결을 통해 에너지를 얻고, 그룹과 미션이 이루어짐에 따라 보람을 느낍니다.\n\n이와 같은 열정적인 주제에 대한 논의와 개방적인 대화를 더 많이 즐기고 싶다면 Discord에 참여해 주세요. 개발자로서의 실력 향상과 더 많은 수익을 올리는 팁을 비롯해 즐거운 대화를 나누실 수 있습니다.  ","ogImage":{"url":"/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_0.png"},"coverImage":"/assets/img/2024-07-01-5unexpectedwayscodingcanupgradeyourlifebeyondmakingmoney_0.png","tag":["Tech"],"readingTime":9},{"title":"저장된 XSS를 통해 사용자 쿠키를 탈취한 방법","description":"","date":"2024-07-01 15:51","slug":"2024-07-01-HowIwasabletostealusercookiesviastoredXSS","content":"\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 사용자 계정과 상점 계정 두 개를 만들었어요.\n\n상점 계정에서 \"Ahmeee\"라는 랜덤 카테고리 아래에 \"ahmed\"라는 상점을 만들었어요.\n\n새 제품을 추가하러 가서 새 제품을 추가했는데, 제품에 일반적인 이름 대신 XSS payload를 시도해 봤어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 사용했어요:\n\n\n`img src=\"invalid-image\" onerror=\"alert(document.cookie)\"`\n\n\n![image](/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_2.png)\n\n그러고 나서 \"제품 추가\"를 클릭하고 내 사용자 계정으로 이동했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자 계정에서 내 가게를 방문하여 \"Ahmeee\" 카테고리를 클릭했어요.\n\n![image1](/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_3.png)\n\n그런 다음 XSS 페이로드로 주입한 제품을 발견했어요!\n\n![image2](/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제가 제품을 클릭한 후 \"장바구니에 추가\"를 클릭했더니, XSS 페이로드가 실행되어 사용자 세션 쿠키가 표시되었어요!\n\n![이미지](/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_5.png)\n\n영향: 이 취약점으로 인해 공격자가 사용자 쿠키를 획득하여 사용자 계정에 무단 액세스할 수 있습니다.\n\n권장 사항: 이러한 공격을 방지하기 위해 적절한 입력 방지 및 출력 인코딩을 구현해야 합니다. 또한 콘텐츠 보안 정책(CSP)을 배포하여 이 취약점을 줄일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 배운 교훈!\n\n보이는 모든 입력란에 XSS 페이로드를 주입하세요; 아마도 작동할지도 몰라요!\n\n**편집**\n\n그 프로그램은 사기였고 신고에도 답변이 없어요. 발견하면 피하세요, \"dukaan.com\"이에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**수정**\n\n\u003cimg src=\"/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_6.png\" /\u003e\n\n더 많은 Write-Ups을 보려면 소셜 미디어에서 팔로우해주세요\n\n# 연락처:","ogImage":{"url":"/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_0.png"},"coverImage":"/assets/img/2024-07-01-HowIwasabletostealusercookiesviastoredXSS_0.png","tag":["Tech"],"readingTime":3},{"title":"독학으로 최고의 프로그래머가 되는 방법 5가지","description":"","date":"2024-07-01 15:51","slug":"2024-07-01-Howtobecomethebestself-taughtprogrammer","content":"\n\n안녕하세요! 13살 때, 친구들과 프로그래밍 언어에 대해 이야기를 나누다가 모든 것이 시작된 Adrian이에요. 그 전 11살 때는 Godot에서 게임을 만들었지만, 정확히 무엇을 하는지 이해하지 못한 채 비디오 강의를 따라 하기만 했어요.\n\n우리 친구들은 서로 어떤 프로그래밍 언어를 알고 있는지 자랑을 하곤 했어요. 그때, 나는 \"프로그래밍 언어를 알아도 어떻게 사용해야 하는지는 모르는데, 사용법을 모르는데 자랑하는 건 왜 해야 할까?\" 라고 스스로 말했어요.\n\n9학년 때부터는 점심시간에 개인 재정 및 Python 프로그래밍의 자습 과정을 따르기 시작했어요. 무언갈 연습할 수 없는 것보다 더 집중하고 싶다는 생각에, 모든 것을 공책에 썼어요. 중요한 건 학교 도서관에서 시간을 보냈는데, 거기에는 학교에서 관리하는 컴퓨터가 있었습니다.\n\n도서관에 가면 매번 개인 재정과 Python 강의에 대한 유튜브 영상을 보고 공책에 메모했어요. 어린 시절부터 자기 규율을 가지고 겸손하게 행동하며 내가 아는 것에 대해 현실적으로 인식하는 법을 배웠어요. 그 당시에는 REST API가 전혀 낯설게 느껴졌어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그동안 집에서 공부하면서 시간을 잃지 않고 프로그래밍 언어를 배우게 되었어요. 쉬는 시간에는 밥을 먹으며 수업에 참석했고, 그만큼 시간이 충분했어요.\n\n점차적으로 HTML, CSS, JS를 배우면서 웹 개발에 더 관심을 두게 되었어요. 당시에는 Scapy와 같은 라이브러리가 매우 복잡해 보였어요. 지금은 이 글을 쓰면서 Scapy를 이해하려면 Python과 네트워크만 알면 충분하다는 것을 깨달았어요.\n\nExpress.js를 통해 API가 무엇인지를 배우게 되었어요. 그 여름, 밴 안에서 노트북을 들고 간달 때, JS로 작동하는 간단한 API를 이해하는 데 고생했어요. 미들웨어, HTTP 메소드, CORS, JWT 등이 무엇인지 이해하기까지 미치도록 날 미치게 했죠. 쉽지 않았지만, 이 스트레스를 우수한 챔피언처럼 다루어 지금의 모습이 되었어요.\n\n14살 때의 여름 수업 이후, 내 인생 중 가장 좋았던 해 중의 하나를 기억해요. Geometry Dash 레벨에 대한 영상을 만들고, 그것을 업로드하러 도서관에 갔어요. 그 후에는 C# 과정을 이어나가거나 그 때 미뤄뒀던 것을 하곤 했어요. 오후 1-2시쯤 밥을 먹고, 3시에는 자전거를 타며 창업 팟캐스트를 들으면서 들판에 나갔어요. 집에 돌아와 차가운 샤워를 하고 오후를 통째로 읽었어요. 당연히 인터넷이 없었기 때문에 할 게 별로 없었죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나의 나이에 많이 발전했어요. 인터넷을 사용하지 않았지만 제 것을 스스로 찾는 법을 잘 알았어요. 아무것도 하지 않고 앉아있는 것은 해결책이 아니에요.\n\n초등학교 때, 엄마가 체육 수업에 관한 학부모 회의에 참석했는데, 하나의 아이(저)가 카페테리아로 숙제를 하러 간다고 언급했어요. 물론, 엄마는 부끄러워 했고, 나쁜 엄마처럼 보일까 봐 걱정했지만, 이런 방식으로 나를 키워준 엄마를 정말 사랑해요.\n\n10학년 때 수학과 물리에 흥미를 가지기 시작했던 걸 기억해요. 성적은 좋지 않았지만, 학술적인 수학과 물리를 배우고 있었어요. 성적은 좋지 않았기 때문에 연습을 했지만, 기초를 이해하지 못했기 때문에 제가 이해하기 어려웠어요. 실생활에서 실용적이지 않은 것을 배울 때 특히 개념을 깨우치기 어려웠던 거죠. 마이너스(-)는 부호가 바뀌는 것이 아닌 연산이 아니라는 것을 깨달을 때까지요.\n\n당시에는 JS, CSS, HTML을 사용하여 정적이고 반응형이 아닌 웹페이지를 만들었어요. 웹 개발에 더 많이 몰입함으로써, JSON, YML/YAML, XML 등의 지속적인 정보 파일 표준 사이의 명확한 차이를 이해하게 됐어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 유리한 점은 나의 규율, 호기심, 그리고 연습했던 것이었습니다. 지성은 나에게 성공하는 데 중요한 요소가 아니었습니다. 10학년 때 나는 궁극적으로 영어를 이해하지 못하는 이유에 대해 궁금해했습니다. 왜 나는 영어 수업을 듣는 내 친구들과 동급인데 내가 못할까요? 영어 선생님인 토니에게 \"어떻게 하면 영어를 배울 수 있을까요? 이해는 되지만 말을 할 수가 없어요\"라고 물었습니다. 그때 유튜브의 영어 자막 동영상을 보며 영어를 배우기 시작했어요. 이것이 나에게 이후 영어를 이해하고 말하는 데 큰 도움이 되었습니다.\n\n고등학교를 졸업한 후에 대학에 진학하는 대신 동일한 학교의 무역 분야의 직업 프로그램을 선택했습니다. 이 선택은 좋은 선택이었습니다. 왜냐하면 제 반에는 여성 23명 정도가 있었거든요. 여성들의 행동에 대해 많은 것을 배우고 무역에 대해 큰 이해를 얻을 수 있었습니다.\n\n이제까지 이어져온 나의 변화가 있었고 이 지난 두 해는 놀라울 정도로 훌륭했으며, 많은 것을 배웠습니다. 이 기간 동안 더 많은 스트레스를 다루는 법을 배우고, 육체적 운동과 같은 자신에게 가하는 스트레스는 규율과 회복력을 향상시킨다는 것을 깨달았습니다.\n\n직업 프로그램 2학년 때 무역을 싫어한다는 것을 깨달았습니다. 경제를 공부하고 싶었지만 프로그램을 통해 SOIB 과정을 수강하게 된 것은 좋은 결정이었습니다 (비록 완료는 하지 못했지만) 새로운 사람들을 만나는 등 많은 것을 배울 기회가 되었습니다. 자신이 무언가를 싫어하고 그것을 그만두는 것이 놀라울 정도로 유익하다는 것을 알아서 기쁘게 생각했어요. 불확실함이 있더라도 시간이 지나면 변할 수 있게 하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 태그를 Markdown 형식으로 변경하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내가 가장 좋아하는 언어는 Golang과 Rust이며, 이 두 언어는 함수형 언어입니다. 반면에 클래스 기반 프로그래밍 언어를 사용하는 것을 싫어해요.\n\n이전에 언급하지 않았지만, 지금은 17살이에요. 내 모든 성취들에 대해 정말 자랑스러워해요. to_literal이라는 PyPi 라이브러리를 만들었고, 현재는 CUDA를 활용한 GPU 가속화에 중점을 둔 또 다른 라이브러리를 개발 중이에요. 또한 Python을 사용하여 암호화 및 복호화를 가능한 간단하고 효율적으로 만드는 작업도 하고 있어요.\n\n모든 것이 쉽지만은 않았어요. 친구들로부터 중도 탈락을 했다는 이유로 받은 거부감은 좋지 않았고, 그리고 고등학교 공부와 미용실 일을 균형있게 해야 했던 높은 압력은 가장 어려웠던 시기 중 일부였어요. 직업 교육 프로그램을 완수하지 못한 것으로 부모님을 실망시킨 것도 좋은 일이 아니었어요. 그때 나는 근력 운동과 달리기를 했어요. 그만큼의 압박에 견디는 것은 정신 건강에 좋지 않지만, 포기는 결코 내 선택지가 되지 않았어요.","ogImage":{"url":"/assets/img/2024-07-01-Howtobecomethebestself-taughtprogrammer_0.png"},"coverImage":"/assets/img/2024-07-01-Howtobecomethebestself-taughtprogrammer_0.png","tag":["Tech"],"readingTime":5},{"title":"프론트엔드 주간 소식 369 2024년 6월 24일  6월 30일","description":"","date":"2024-07-01 15:50","slug":"2024-07-01-FrontendWeeklyDigest3692430Jun2024","content":"\n\n![이미지](/assets/img/2024-07-01-FrontendWeeklyDigest3692430Jun2024_0.png)\n\n# 웹 개발\n\n- 팝오버는 슬라이드 아웃 서랍으로 아주 잘 작동합니다.\n- 떠오르기\n- 등간격 이상: 완벽한 코딩 폰트를 찾다\n- 프런트엔드 개발에 대한 불평\n- 웹사이트 성능 최적화를 위한 13가지 실용적인 업데이트\n- 리액트에서 네이티브 DOM API로의 전환: 실제 사례\n\n## 도구\n- Vercel v0 및 AI 기반 UI 생성의 미래\n- window.ai - 개발자 도구에서 로컬로 AI 실행!\n\n## 접근성\n- 키보드만으로 웹 브라우징하는 방법\n- 접근성을 위한 강력한 사례 구성 방법\n\n## 효과\n- Digital meets Physical: WebGL로 Risograph 인쇄하기\n- 반짝이는 텍스트 마키 아니메이션 만들기\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# CSS\n\n• CSS에서 conic-gradient()를 사용한 텍스트 노출 효과\n• 2024 CSS Day - 제 10회\n• 유동적인 타이포그래피 크기 계산하기\n• 자동 높이 전환\n• daisyUI 채택 가이드: 개요, 예제 및 대안\n• MUI의 런타임 제로 CSS-in-JS 라이브러리인 Pigment CSS 탐색\n\n# JavaScript\n\n• Ecma International이 ECMAScript 2024를 승인: 무엇이 새로울까?\n• JavaScript Proxy를 위한 7가지 사용 사례\n• 새로운 JavaScript Set 메서드\n• 최신 웹 기능에 대한 JavaScript 브라우저 지원 테스트\n• Million.js 채택 가이드: 개요, 예제 및 대안\n• Unicode 문자열 올바르고 더 나은 처리\n• EmberConf 2024: 12개 비디오\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 리액트\n  - Yup과 Formik을 사용하여 리액트 및 리액트 네이티브에서 양식 유효성 검사하는 방법\n  - Next.js로 정적 사이트 생성 (SSG)\n  - CSS-in-JS 및 리액트 서버 컴포넌트: 개발자 가이드\n  - 리액트 18로 뉴욕 타임스 웹 성능 향상하기\n  - 개발자를 위한 포괄적인 리액트.js 치트시트\n  - 리액트에서 Chrome의 Document Picture-in-Picture API 사용하기\n\n- 뷰\n  - Vue.js Live 2024\n  - Vue 3 이전과 함께 마이크로 프론트엔드 아키텍처 구축\n  - Vue에서 퀸스 게임 재현하기\n\n- 앵귤러\n  - 현대적인 앵귤러 기능 강제하는 5가지 ESLint 규칙\n  - 웹 서버 및 프론트엔드 애플리케이션에서 ClickJacking 방지하는 방법\n  - 라우트 전환을 위한 앵귤러 애니메이션 튜토리얼","ogImage":{"url":"/assets/img/2024-07-01-FrontendWeeklyDigest3692430Jun2024_0.png"},"coverImage":"/assets/img/2024-07-01-FrontendWeeklyDigest3692430Jun2024_0.png","tag":["Tech"],"readingTime":2}],"page":"3","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"3"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>