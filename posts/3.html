<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/3" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리" href="/post/2024-06-30-BestPythonLibrariesforCybersecurityin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-BestPythonLibrariesforCybersecurityin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬에서 멀티프로세싱 사용하는 방법" href="/post/2024-06-30-MultiprocessinginPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬에서 멀티프로세싱 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-MultiprocessinginPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬에서 멀티프로세싱 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">파이썬에서 멀티프로세싱 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">37<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ntscraper를 사용한 실시간 트윗 데이터 분석 방법" href="/post/2024-06-30-ScrapingTweetsforReal-TimeDataAnalysisUsingntscraper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ntscraper를 사용한 실시간 트윗 데이터 분석 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-ScrapingTweetsforReal-TimeDataAnalysisUsingntscraper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ntscraper를 사용한 실시간 트윗 데이터 분석 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">ntscraper를 사용한 실시간 트윗 데이터 분석 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Part 3 React  폴더 구조 쉽게 정리하는 방법" href="/post/2024-06-30-Part3ReactFolderStructure"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Part 3 React  폴더 구조 쉽게 정리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-Part3ReactFolderStructure_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Part 3 React  폴더 구조 쉽게 정리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Part 3 React  폴더 구조 쉽게 정리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="최신 프론트엔드 기술 비교 React vs Vuejs" href="/post/2024-06-30-Front-EndTechnologiesReactvsVuejs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="최신 프론트엔드 기술 비교 React vs Vuejs" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-Front-EndTechnologiesReactvsVuejs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="최신 프론트엔드 기술 비교 React vs Vuejs" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">최신 프론트엔드 기술 비교 React vs Vuejs</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Tornado Cash 소스 코드를 통해 알아보는 영지식 증명 이해하기" href="/post/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Tornado Cash 소스 코드를 통해 알아보는 영지식 증명 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Tornado Cash 소스 코드를 통해 알아보는 영지식 증명 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Tornado Cash 소스 코드를 통해 알아보는 영지식 증명 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React와 Nextjs 프론트엔드 기술 비교 2024년 최신 분석" href="/post/2024-06-30-ComparingReactandNextjsFrontendTechnology"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React와 Nextjs 프론트엔드 기술 비교 2024년 최신 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-ComparingReactandNextjsFrontendTechnology_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React와 Nextjs 프론트엔드 기술 비교 2024년 최신 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">React와 Nextjs 프론트엔드 기술 비교 2024년 최신 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Python을 사용하여 GitHub 개발 활동 분석하는 방법" href="/post/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Python을 사용하여 GitHub 개발 활동 분석하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Python을 사용하여 GitHub 개발 활동 분석하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Python을 사용하여 GitHub 개발 활동 분석하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">39<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="일찍 알았더라면 좋았을 6가지 Python 문자열 팁" href="/post/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="일찍 알았더라면 좋았을 6가지 Python 문자열 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="일찍 알았더라면 좋았을 6가지 Python 문자열 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">일찍 알았더라면 좋았을 6가지 Python 문자열 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="내가 가장 좋아하는 자바스크립트 코드 한 줄" href="/post/2024-06-30-MySingleFavoriteLineOfJavascript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="내가 가장 좋아하는 자바스크립트 코드 한 줄" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="내가 가장 좋아하는 자바스크립트 코드 한 줄" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">내가 가장 좋아하는 자바스크립트 코드 한 줄</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 30, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link posts_-active__YVJEi" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리","description":"","date":"2024-06-30 22:17","slug":"2024-06-30-BestPythonLibrariesforCybersecurityin2024","content":"\n\n![이미지](/assets/img/2024-06-30-BestPythonLibrariesforCybersecurityin2024_0.png)\n\n안녕하세요! 사이버 보안 분야에서 올바른 도구를 선택하는 것은 침입과 방어 사이의 차이를 만드는 중요한 요소입니다. 사이버 위협이 계속 증가함에 따라 더 많은 보안 전문가들이 파이썬을 선택하는 이유로 압도적으로 많은 87%가 매일 파이썬을 사용한다고 보고하고 있습니다.\n\n파이썬이 사이버 보안 분야에서 인기를 끌게 된 이유는 간결성, 가독성 및 강력한 라이브러리의 거대한 생태계 때문입니다. 최신 스택 오버플로 개발자 설문조사에 따르면, 파이썬은 개발자들이 가장 사랑하는 프로그래밍 언어 중 세 번째로 랭크되며, 개발을 계속하고 싶어하는 개발자들이 59.4%에 달합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 범용적인 채택은 최신 기술과 자원이 지속적으로 유입되는 활기찬 기여자 커뮤니티를 의미합니다.\n\n하지만 파이썬을 차별화하는 진정한 요소는 유연성과 크로스 플랫폼 호환성입니다. 침투 테스트를 수행하거나 네트워크 트래픽을 분석하거나 견고한 암호화 프로토콜을 구현하든, 파이썬은 사이버 보안 요구 사항에 맞춤형 라이브러리를 제공합니다. 2024년에는 위협 환경이 점점 더 복잡해지면서 이러한 라이브러리가 더욱 필수적으로 사용될 것으로 예상됩니다.\n\n본 문서에서는 사이버 보안을 위한 가장 흥미로운 파이썬 라이브러리 중 일부를 살펴보고, 그 기능과 현실 세계 응용 사례를 살펴볼 것입니다.\n\n# Scapy: 최고의 패킷 제작 도구\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네트워크 트래픽을 관찰하고 제어하는 것은 네트워크 보안에서 매우 중요합니다. 여기서 Scapy는 네트워크 보안 전문가에게 꼭 필요한 도구로 빛을 발합니다. Scapy는 독보적인 패킷 조작 능력을 통해 네트워크 패킷을 정교하게 제작, 송수신, 스니핑 및 해체할 수 있도록 제공합니다.\n\nScapy의 중요성은 그 다재다능성과 유연성에 있습니다. 침투 테스트, 침입 탐지 시스템 (IDS) 구축, 네트워크 프로토콜 분석 등 다양한 보안 도전 과제에 대처할 수 있는 도구를 제공하여 여러분에게 강력한 지원을 해줍니다. 스크립트 기능을 활용하여 복잡한 작업을 자동화할 수 있어 소중한 시간과 자원을 절약할 수 있습니다.\n\n활용 사례:\n\n- 침투 테스트: Scapy를 사용하여 취약점을 이용할 수 있는 맞춤형 패킷을 제작하여 네트워크 인프라의 잠재적인 취약점을 식별하고 포괄적인 침투 테스트를 수행할 수 있습니다.\n- 네트워크 분석: 강력한 패킷 해체 기능을 통해 Scapy는 네트워크 트래픽을 심층적으로 분석하여 숨겨진 패턴, 이상 현상 및 잠재적 위협을 발견하는 데 도움을 줍니다.\n- 침입 탐지 시스템: Scapy의 패킷 제작 능력을 활용하여 조직의 특정 요구 사항에 맞춘 맞춤형 침입 탐지 시스템을 생성하여 악의적 활동을 강인하게 탐지할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nScapy를 시작하는 방법: Scapy를 숙달하는 가장 좋은 방법은 실전 실습과 포괄적인 학습 자료를 결합하는 것입니다. 먼저 시스템에 Scapy를 설치하고 공식 문서 및 튜토리얼을 통해 기본 기능에 익숙해지세요. 자신감을 쌓으면 패킷 제작, 해석 및 스니핑과 같은 더 고급 기능을 탐험해보세요.\n\n또한, 경험있는 전문가들과 소통하고 지도를 받으며 프로젝트의 발전에 기여할 수 있는 활발한 Scapy 커뮤니티에 가입하는 것도 고려해보세요.\n\n온라인 포럼에 참여하거나 사이버 보안 컨퍼런스에 참석하며 동료들과 협력하는 것은 학습 곡선을 가속화하고 최신 Scapy 기술과 모범 사례를 파악하는 데 도움이 됩니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport scapy.all as scapy\n# ICMP 패킷 생성\n    packet = scapy.IP(dst=\"대상 IP\")/scapy.ICMP()\n    # 패킷 전송하고 응답 캡처\n    response = scapy.sr1(packet)\n    # 응답 분석\n    if response:\n        print(f\"대상 {response.src}이(가) 동작 중이며 응답 중입니다!\")\n    else:\n        print(\"대상이 다운되었거나 응답하지 않습니다.\")\n```\n\n이 예제에서는 Scapy의 패킷 제작 기능을 활용하여 대상 IP 주소로 이동하는 ICMP 패킷을 생성합니다. 그런 다음 패킷을 전송하고 응답을 캡처하여 대상이 동작 중이고 응답하는지 확인할 수 있습니다.\n\nScapy를 숙달하면 강력한 네트워크 보안 도구 세트를 활용할 수 있어 신생 위협에 앞서 나아가 조직의 방어력을 강화할 수 있습니다.\n\nScapy에 대해 더 자세히 알아보려면 Python을 사용한 첫 번째 포트 스캐너 작성에 대한 실용적인 가이드를 따르세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 암호화: 안전한 디자인\n\n디지털 시대에 있어서 데이터는 새로운 통화이며, 간첨자들로부터 보호하는 것이 중요합니다.\n\n파이썬을 위한 Cryptography 라이브러리는 여기에서 빛을 발하며, 암호화 알고리즘의 견고하고 안전한 구현을 제공합니다. 산업의 최고의 규칙을 준수하며 \"기본적으로 암호화\"의 원칙을 따르는 이 라이브러리는 안전한 기본 설정을 사용하여 조직의 민감한 데이터를 잠재적으로 위협할 수 있는 일반적인 함정을 완화합니다.\n\nCryptography 라이브러리의 중요성은 다양한 암호화 및 복호화 메커니즘을 제공하여 사이버 보안 방어 태세를 강화하는 데 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n통신 보안, 데이터 보호 및 인증 프로토콜 구현 등 여러 분야에서 이 라이브러리는 디지털 자산을 보호하는 도구를 제공합니다.\n활용 사례:\n\n- 데이터 암호화: 암호화 라이브러리를 활용하여 비밀번호, 금융 정보, 기밀 문서 등 민감한 데이터를 암호화하여 비인가된 당사자에게는 알아볼 수 없게 만듭니다. 가로채여도 데이터가 안전하고 해독할 수 없도록 보장합니다.\n- 안전한 통신: 강력한 암호화 프로토콜을 구현하여 안전한 통신을 위한 보호를 제공하며, 네트워크를 통해 전송되는 데이터가 도청이나 중간자 공격으로부터 안전하고 비밀스럽게 유지됩니다.\n- 인증 및 키 관리: 안전한 키 생성, 저장 및 관리를 위한 라이브러리 기능을 활용하여 견고한 인증 메커니즘을 구현하고 암호화 작업의 무결성을 보장합니다.\n\n암호학 시작하기: 이 라이브러리를 숙달하기 위해서는 암호학 원리와 모범 사례에 대한 확고한 이해가 필요합니다. 먼저 공식 문서와 자습서를 탐험하여 라이브러리의 기능과 사용법에 대한 종합적인 개요를 제공받으세요. 능숙해지면 키 관리, 안전한 키 교환 프로토콜, 암호화 알고리즘 구현과 같은 고급 주제에 대해 탐구해 보세요.\n\n활기찬 Python 커뮤니티와 사이버 보안 컨퍼런스에 참여하면 현실 세계의 사용 사례와 최신 기술을 경험할 수 있습니다. 또한 암호학과 관련된 오픈 소스 프로젝트에 기여하는 것도 고려해 보세요. 이런 실무 경험은 지식을 확고히 하고 분야에서 선도적인 위치에 자리할 수 있도록 도와줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom cryptography.fernet import Fernet\n# 안전한 키를 생성합니다\nkey = Fernet.generate_key()\n# Fernet 인스턴스를 생성합니다\ncipher = Fernet(key)\n# 메시지를 암호화합니다\nmessage = b\"This is a secret message!\"\nencrypted = cipher.encrypt(message)\n# 메시지를 복호화합니다\ndecrypted = cipher.decrypt(encrypted)\nprint(decrypted.decode())  # 출력: This is a secret message!\n```\n\n이 예시에서는 Cryptography 라이브러리의 Fernet 모듈을 활용하여 메시지를 안전하게 암호화하고 복호화합니다. 안전한 키를 생성하고 Fernet 인스턴스를 만들어 민감한 데이터를 쉽게 암호화하고 복호화하여 기밀성과 무결성을 보장할 수 있습니다.\n\nCryptography 라이브러리를 채택함으로써, 귀하는 조직의 디지털 자산을 보호하고 사이버 보안 방어 체계를 강화하여 신흥 위협에 앞서 나갈 수 있는 강력한 도구를 갖추게 될 것입니다.\n\n암호화에 대해 더 알아보고 싶다면, 저는 \"암호화: 비트코인 거래의 중추 및 프로젝트에 구현하는 방법\"에 관한 기사를 작성했습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# PyNmap: 네트워크 매핑 및 취약점 스캔\n\nPyNmap: 네트워크 취약성을 발견하고 변화무쌍한 사이버 보안 환경에서 적극적인 자세를 유지하는 것은 중요합니다. PyNmap는 유명한 Nmap 보안 스캐너의 능력을 활용하는 강력한 Python 라이브러리로 보안 전문가들에게 힘을 실어줍니다.\n\nPyNmap를 사용하면 Python 스크립트에 포괄적인 네트워크 매핑, 포트 스캔, 그리고 취약성 평가를 직접 통합할 수 있어서 보안 작업을 간소화하고 네트워크 보안 상태에 대한 소중한 통찰력을 제공합니다.\n\nPyNmap의 진정한 힘은 보안 평가를 자동화하고 확장하여 소중한 시간과 자원을 절약하면서 철저하고 일관된 분석을 보장하는 능력에 있습니다. 규칙적인 감사를 수행하거나 잠재적인 위협을 조사하거나 방어를 강화하는 경우, PyNmap는 떠오르는 취약성에 선행하기 위한 도구를 갖추고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 사례:\n\n- 네트워크 탐사: PyNmap을 활용하여 네트워크 토폴로지에 대한 포괄적인 이해를 얻어 라이브 호스트, 열린 포트, 그리고 악의적인 사용자의 가능한 진입점을 식별할 수 있습니다.\n- 취약점 스캔: Python 스크립트에 쉽게 취약점 스캔을 통합하여 네트워크 인프라, 응용 프로그램 및 서비스 전반에 걸친 취약점을 식별하고 우선순위를 정할 수 있습니다.\n- 침투 테스트: PyNmap의 강력한 기능을 활용하여 실제 공격을 모의하고 방어 수단을 검증하며 상대방이 악용하기 전에 잠재적인 약점을 찾아낼 수 있습니다.\n\nPyNmap 시작하기: PyNmap 여행을 시작하려면 네트워크 보안 원칙과 Nmap 스캐너 자체에 대한 확고한 이해부터 시작해야 합니다. 먼저 공식 Nmap 문서에 익숙해지고 다양한 스캔 기술과 옵션을 탐험해보세요.\n\nNmap의 기능을 완전히 이해한 후에는 PyNmap 라이브러리의 문서와 자습서를 찾아들어 Nmap 기능을 Python 스크립트에 통합하는 방법을 안내받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사이버 보안 커뮤니티와 소통하고 온라인 포럼에 참여하며 학회에 참석하고 네트워크 보안과 관련된 오픈 소스 프로젝트에 기여함으로써 활기찬 사이버 보안 커뮤니티와 소통하세요. 이런 실무 경험을 통해 지식을 공고히하고 실제 사용 사례와 최상의 사례에 노출될 수 있습니다.\n\n예시:\n\n```python\nimport nmap\n# Nmap 스캐너 인스턴스 생성\nscanner = nmap.PortScanner()\n# 대상 호스트에 대한 TCP 커넥트 스캔 수행\ntarget = \"192.168.1.100\"\nscanner.scan(target, arguments=\"-sT\")\n# 열린 포트와 연결된 서비스 출력\nfor host in scanner.all_hosts():\n    print(f\"Host : {host} ({scanner[host].hostname()})\")\n    for proto in scanner[host].all_protocols():\n        print(f\"Protocol : {proto}\")\n        lport = scanner[host][proto].keys()\n        for port in lport:\n            print(f\"{port}: {scanner[host][proto][port]['name']}\")\n```\n\n이 예시에서는 PyNmap을 사용하여 대상 호스트에 대한 TCP 커넥트 스캔을 수행하여 열린 포트와 연결된 서비스를 확인합니다. Nmap의 능력을 우리의 Python 스크립트에 원활하게 통합함으로써 네트워크 정찰 작업을 자동화하고 확장할 수 있어 잠재적인 취약점을 식별하고 방어를 사전에 강화할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPyNmap을 활용하면 강력한 네트워크 보안 도구를 활용하여 최신 보안 위협에 앞서 나가고 조직의 디지털 자산을 자신 있게 보호할 수 있습니다.\n\n# Python-Nmap: 네트워크 탐사 및 호스트 발견\n\n사이버 보안에서는 지식이 힘이 되며 네트워크 환경에 대한 포괄적인 가시성을 확보하는 것이 중요합니다. Python-Nmap은 유명한 Nmap 보안 스캐너의 기능을 활용하는 강력한 라이브러리를 제공하여 이 분야에서 빛을 발합니다.\n\n사용자 친화적 인터페이스와 포괄적인 설명서를 통해 Python-Nmap은 네트워크 탐사 및 호스트 발견을 간편하게 만들어줍니다. 보안 운영을 위한 가치 있는 정보를 수집하여 보안 작업을 강화하는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬-Nmap의 가치는 네트워크 정찰 작업을 간소화하고 자동화하여 소중한 시간과 자원을 절약하며 철저하고 일관된 분석을 보장하는 데 있습니다. 일반적인 네트워크 감사를 수행하거나 침투 테스트를 위한 정보를 수집하거나 방어력을 강화하는 경우, 파이썬-Nmap은 대상 네트워크에 대한 가치 있는 정보를 발견할 수 있는 강력한 도구를 제공합니다.\n\n활용 사례:\n\n- 네트워크 매핑: 파이썬-Nmap을 활용하여 네트워크 토폴로지를 복잡하게 이해하여 살아 있는 호스트, 열린 포트, 악의적인 사용자들에 대한 가능한 입구점을 식별할 수 있습니다.\n- 호스트 발견: 네트워크에서 활성 호스트를 신속하게 발견하여 중요한 시스템 및 서비스에 대한 보안 노력에 중점을 두고 집중할 수 있도록 합니다.\n- 정보 수집: 파이썬-Nmap의 강력한 기능을 활용하여 운영 체제, 소프트웨어 버전 및 잠재적인 취약성을 포함한 대상 호스트에 대한 상세한 정보를 수집하여, 효율적인 의사 결정을 내리고 잠재적인 위험을 선제적으로 줄일 수 있습니다.\n\n파이썬-Nmap 시작하기: 파이썬-Nmap 여행을 시작하려면 네트워크 보안 원칙과 Nmap 스캐너 자체에 대한 견고한 이해를 가져야 합니다. 공식 Nmap 설명서에 친숙해지고 사용 가능한 다양한 스캔 기술과 옵션을 탐색해 보세요. Nmap의 기능을 완전히 이해한 후에는 Python-Nmap 라이브러리의 설명서 및 튜토리얼을 살펴보고, Nmap 기능을 파이썬 스크립트에 통합하는 방법을 안내받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친구 같은 톤으로 말하자면, 온라인 포럼에 참여하거나 컨퍼런스에 참석하며 네트워크 보안과 관련된 오픈소스 프로젝트에 기여함으로써 활기찬 사이버 보안 커뮤니티와 소통할 수 있어요. 이 실전 경험은 여러분의 지식을 강화시켜주며 실제 사용 사례와 최선의 실천 방법에 노출시켜 줄 거예요.\n\n실제 설정:\n\n```python\nimport nmap3\n# Nmap 스캐너 인스턴스 생성\nscanner = nmap3.NmapHostDiscovery()\n# 특정 네트워크에 호스트 검색 스캔 수행\nresults = scanner.nmap_no_portscan(\"192.168.1.0/24\")\n# 발견된 호스트 출력\nfor host in results.keys():\n    print(f\"Host: {host} ({results[host]['hostnames'][0]['name']})\")\n```\n\n이 예시에서는 Python-Nmap을 활용하여 특정 네트워크 범위(192.168.1.0/24)에서 호스트 검색 스캔을 수행합니다. nmap3.NmapHostDiscovery 클래스를 활용하여 네트워크에서 활성 호스트를 쉽게 발견할 수 있으며, 전체 포트 스캔을 수행하지 않고 시간과 자원을 절약할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스크립트는 NmapHostDiscovery 클래스의 인스턴스를 생성하고, nmap_no_portscan 메서드를 사용하여 호스트 탐지 스캔을 초기화합니다. 그런 다음 결과가 구문 분석되고 발견된 호스트들은 호스트 이름과 함께 인쇄됩니다.\n\nPython-Nmap을 채택함으로써 네트워크 인텔리전스 도구의 강력한 아카이브를 활용하여 새로운 위협에 한 발 앞서나가며 조직의 디지턈 자산을 자신있게 보호할 수 있습니다.\n\nNmap에 대해 시작하고 학습하려면 이 가이드를 확인해주세요, 시스템에 대한 원격 코드 실행 공격을 수행하는 방법\n\n# Impacket: 네트워크 프로토콜 구현\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네트워크 프로토콜의 이해와 조작은 계속 발전하는 사이버 보안 분야에서 중요합니다. 여기서 Impacket이 빛을 발합니다. Impacket은 네트워크 프로토콜 구현과 이용을 위한 스위스 아미 나이프로서 빛을 발하고 있습니다.\n\nImpacket은 SMB, MSRPC 등 다양한 네트워크 프로토콜에 대한 저수준 프로그래밍 액세스를 통해 보안 전문가들이 침투 테스트, 악용 개발, 심지어 자신들의 요구에 맞게 맞춤형 네트워크 도구를 생성할 수 있도록 지원합니다.\n\nImpacket의 진정한 힘은 다양성과 프로토콜 지원의 심도에 있습니다. 취약점 조사, 개념 증명 악용 개발, 네트워크 트래픽 분석을 하든, Impacket은 당신이 네트워크 프로토콜의 복잡성에 심취할 수 있는 도구를 제공하여 떠오르는 위협에 선제적으로 대응하고 조직의 방어력을 강화할 수 있도록 도와줍니다.\n\n사용 사례:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Penetration Testing: Impacket의 광범위한 프로토콜 지원을 활용하여 포괄적인 침투 테스트를 수행하고 취약점을 발견하여 네트워크 인프라의 보안 상태를 평가해 보세요.\n- Exploit Development: Impacket의 네트워크 프로토콜에 대한 저수준 액세스를 활용하여 공격을 개발하고 테스트하여 잠재적인 취약점을 사전에 식별하고 완화할 수 있습니다.\n- Custom Tool Development: Impacket의 유연성을 활용하여 조직의 특정 필요에 맞는 사용자 정의 네트워크 도구를 개발하고 보안 운영을 간소화하며 전반적인 사이버 보안 역량을 향상시킬 수 있습니다.\n\nImpacket으로 시작하기: Impacket 여행을 시작하려면 네트워크 프로토콜과 그 기본 메커니즘에 대한 탄탄한 이해부터 시작하세요.\n\n먼저 공식 Impacket 문서를 숙지하고 사용 가능한 프로토콜과 모듈을 탐색해보세요. 라이브러리의 능력을 완전히 이해한 후에는 실습과 실제 시나리오로 직접 뛰어들어 이해를 공고히 해보세요.\n\n온라인 포럼에 참여하고 학회에 참석하며 네트워크 보안과 관련된 오픈 소스 프로젝트에 기여함으로써 다이내믹한 사이버 보안 커뮤니티와 교류하세요. 이 실전 경험은 실제 사용 사례, 최선의 실천법 및 네트워크 프로토콜 개발의 첨단 기술을 경험하게 해줄 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 세팅:\n\n```js\nimport impacket.smb3\nfrom impacket.ntlm import compute_lm_hashed, compute_nthash\n# SMB 연결 설정\nsmb = impacket.smb3.SMB3(remote_host=\"대상_호스트\", remote_port=445)\nsmb.login(\"사용자_이름\", \"암호\")\n# 공유 리소스 목록\nshares = smb.listShares()\nfor share in shares:\n    print(share.name)\n# 공유 폴더에 접근\ntid = smb.tree_connect_andx(\"\\\\\\\\대상_호스트\\\\공유_이름\")\nsmb.listPath(\"공유_이름\", \"*\")\n```\n\n이 예시에서는 Impacket을 활용하여 서버 메시지 블록 (SMB) 프로토콜과 상호 작용합니다. SMB는 파일 공유 및 원격 액세스를 위해 널리 사용되는 네트워크 프로토콜입니다. 스크립트는 대상 호스트에 SMB 연결을 설정하고 제공된 자격 증명으로 인증하며 사용 가능한 공유 리소스를 나열하고 특정 공유 폴더에 액세스합니다.\n\nImpacket을 숙달하면 강력한 네트워크 프로토콜 악용 도구 모음을 활용할 수 있어 신뢰성 있는 조직 방어 강화와 신규 위협에 앞장서는 데 도움을 줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nImpacket에 대해 자세히 알아보려면 Beginner’s Guide)에서 Python으로 백신을 빌드하는 방법을 탐색한 이 안내서를 확인해보세요.\n\n# Brypt: 비밀번호 안전성 강화\n\n비밀번호 보호는 사이버 보안에서 무단 액세스에 대한 중요한 방어 라인입니다. Brypt는 안전하게 해싱하고 비밀번호를 확인하는 Python 라이브러리를 제공하여 이 분야에서 빛을 발합니다.\n\nbcrypt, scrypt, 그리고 Argon2와 같은 업계 표준 해싱 알고리즘에 대한 고수준 인터페이스를 제공함으로써 Brypt는 최고의 비밀번호 저장 및 확인 관행을 따르도록 보장하여 데이터 누출 및 무단 액세스의 위험을 줄입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBrypt의 참 가치는 업계 표준 보안 프로토콜을 준수하면서 암호 해시 및 확인을 간소화하고 간결하게하는 능력에 있습니다. 웹 애플리케이션을 개발하든, 내부 시스템을 보호하든, 조직의 인증 메커니즘을 강화하든, Brypt는 민감한 자격 증명을 보호하기 위한 강력하고 사용하기 쉬운 툴킷을 제공하여 여러분을 돕습니다.\n\n활용 사례:\n\n- 웹 애플리케이션 보안: Brypt를 웹 애플리케이션에 통합하여 사용자 암호를 안전하게 해싱하고 저장하여 일반 텍스트 암호 노출의 위험을 최소화하고 전반적인 애플리케이션 보안을 강화합니다.\n- 내부 시스템 보안: Brypt를 활용하여 고강도의 암호 해시 및 확인 메커니즘을 구현하여 내부 시스템 및 서비스를 안전하게 보호하여 무단 접근과 잠재적인 데이터 침해로부터 보호합니다.\n- 인증 메커니즘: Brypt의 능력을 활용하여 조직의 인증 프로토콜을 강화하여 민감한 자격 증명이 안전하게 저장되고 확인되도록하며, 어카운트 침해 위험을 줄입니다.\n\nBrypt로 시작하기:\nBrypt 여행을 시작하는 것은 안전한 비밀번호 보안 모범 사례와 해싱 알고리즘에 대한 탄탄한 이해로부터 시작합니다. 첫걸음은 공식 Brypt 문서를 익히고 다양한 해싱 알고리즘과 옵션을 탐색하는 것입니다. 라이브러리의 능력을 완전히 이해하면 실전 연습과 현실 시나리오에 뛰어들어 이해를 고착시키세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사이버보안 커뮤니티와 소통하기 위해 온라인 포럼에 참여하고 컨퍼런스에 참석하며 비밀번호 보안과 관련된 오픈 소스 프로젝트에 기여하세요. 이 경험을 통해 현실 세계의 사용 사례, 최고의 실천 사례 및 최신 비밀번호 해싱 및 확인 기술에 노출될 것입니다.\n\n실제 설정:\n\n```js\nimport brypt\n# bcrypt를 사용하여 비밀번호를 해싱합니다\n    hashed_password = brypt.hashpw(\"mypassword\", brypt.gensalt())\n    # 해시값과 비밀번호를 비교하여 확인합니다\n    if brypt.checkpw(\"mypassword\", hashed_password):\n        print(\"비밀번호가 유효합니다!\")\n    else:\n        print(\"유효하지 않은 비밀번호!\")\n```\n\n이 예제에서는 bcrypt 알고리즘을 사용하여 안전하게 비밀번호를 해싱하고 제공된 비밀번호를 해시 값과 비교하여 확인하는 Brypt를 활용합니다. 이 스크립트는 Brypt의 간단한 인터페이스를 보여줌으로써 비밀번호 저장 및 확인이 업계의 최고 기준을 준수하도록 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Scapy-HTTPS: 암호화된 네트워크 트래픽 해독하기\n\nScapy는 강력한 패킷 조작 도구이지만 HTTPS 트래픽을 처리하는 기본 지원이 부족합니다. 여기에 Scapy-HTTPS가 등장합니다. Scapy의 기능을 확장하여 암호화된 HTTPS 트래픽을 분석하고 분해할 수 있는 보조 라이브러리입니다. Scapy-HTTPS를 사용하면 HTTPS 패킷을 검사하고 해독할 수 있어 잠재적인 취약점을 발견하고 안전한 네트워크 통신을 모니터링할 수 있습니다.\n\nScapy-HTTPS의 중요성은 암호화된 네트워크 트래픽을 볼 수 있는 능력에 있습니다. 오늘날의 사이버 보안 환경에서 안전한 통신 프로토콜이 흔하기 때문에 이 능력은 매우 중요합니다. Scapy-HTTPS를 활용함으로써 보안 전문가는 잠재적인 위협과 취약점에 대한 소중한 통찰력을 얻을 수 있어 조직의 네트워크 인프라의 무결성과 기밀성을 보장할 수 있습니다.\n\n사용 사례:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 네트워크 트래픽 분석: Scapy-HTTPS를 활용하여 암호화된 HTTPS 트래픽을 분석하고 해독하여 잠재적인 취약점, 이상 현상 및 침해 사례 지표를 발견합니다.\n- 침투 테스트: Scapy-HTTPS를 활용하여 실제 공격을 시뮬레이션하고 조직의 HTTPS 구현의 보안을 테스트하여 취약점을 식별하고 방어 체계를 강화합니다.\n- 사고 대응 및 포렌식: 사고 대응 및 포렌식 조사에서 Scapy-HTTPS를 활용하여 캡처한 HTTPS 트래픽을 해독하여 값진 증거를 수집하고 보안 사고의 근본 원인을 발견합니다.\n\n바이크립트에 대해 더 알아보려면 다음 기사를 확인하세요. '내일을 위한 소프트웨어 보안 강화'\n\nScapy-HTTPS 시작하기:\nScapy-HTTPS 여행을 시작하려면 네트워크 프로토콜, 패킷 분석 및 암호화 메커니즘에 대한 확고한 이해가 필요합니다. 먼저 Scapy 문서를 읽고 패킷 조작 기능을 탐색하여 Scapy에 대한 확고한 이해를 갖춥니다. 그 후 Scapy-HTTPS 문서와 자습서를 탐험하여 HTTPS 트래픽 분석을 Python 스크립트에 통합하는 과정을 안내 받습니다.\n\n온라인 포럼에 참여하거나 컨퍼런스에 참석하고 오픈 소스 네트워크 보안 및 암호화 프로젝트에 기여함으로써 사이버 보안 커뮤니티와 소통하세요. 이러한 실무 경험을 통해 HTTPS 트래픽 분석의 실제 사용 사례, 최선의 방법 및 최신 기술에 노출될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 환경 설정:\n\n```python\nfrom scapy_https import SSLStreamReader\n\n# 패킷 캡처 파일을 불러옵니다\npackets = rdpcap(\"capture.pcap\")\n# SSLStreamReader 객체를 인스턴스화합니다\nreader = SSLStreamReader()\n# HTTPS 패킷을 처리합니다\nfor packet in packets:\n    reader.insert(packet)\n    if reader.isDone():\n        print(f\"복호화된 데이터: {reader.get_decrypted_data()}\")\n        reader.reset()\n```\n\n이 예시에서는 Scapy-HTTPS를 사용하여 패킷 캡쳐 파일에서 HTTPS 트래픽을 분석하고 복호화합니다. 이 스크립트는 SSLStreamReader 객체를 인스턴스화하고 각 패킷을 처리하여 HTTPS 데이터를 복호화하고 복호화된 내용을 출력합니다. 이 접근법을 통해 보안 전문가들은 암호화된 네트워크 트래픽을 보고 잠재적인 취약점을 발견하거나 안전한 통신을 모니터링할 수 있습니다.\n\n이 강력한 Python 라이브러리들을 활용하여 조직의 사이버 보안 방어 체계를 강화하고 신규 위협에 대비하며 디지털 자산을 안전하게 보호할 수 있는 포괄적인 도구 상자를 구축하게 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n파이썬은 라이브러리의 풍부한 생태계를 통해 강력한 사이버 보안 동맹으로 나타납니다. Scapy의 패킷 조작 능력부터 Cryptography의 견고한 암호화 구현까지, 이러한 최고의 파이썬 도구들은 방어 체계를 강화하고 떠오르는 위협에 앞장서도록 도와줍니다. 파이썬의 사이버 보안 능력을 받아들이고 커뮤니티와 소통하여 귀하의 조직의 디지털 미래를 안전하게 지키세요.","ogImage":{"url":"/assets/img/2024-06-30-BestPythonLibrariesforCybersecurityin2024_0.png"},"coverImage":"/assets/img/2024-06-30-BestPythonLibrariesforCybersecurityin2024_0.png","tag":["Tech"],"readingTime":20},{"title":"파이썬에서 멀티프로세싱 사용하는 방법","description":"","date":"2024-06-30 22:13","slug":"2024-06-30-MultiprocessinginPython","content":"\n\n\u003cimg src=\"/assets/img/2024-06-30-MultiprocessinginPython_0.png\" /\u003e\n\n# 소개\n\n이 게시물은 multiprocessing 모듈을 사용하여 Python에서 다중 프로세싱을 소개하며 내용을 더 잘 이해하기 위한 몇 가지 예제와 시각화가 포함되어 있습니다.\n\n마지막 부분의 자료 섹션에는 해당 주제를 더 깊게 이해할 수 있는 멋진 자료 링크가 몇 개 있습니다 🤓\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n관련 게시물들\n\n- 동시성과 병렬 처리 소개\n- Python에서의 Threading\n- Python에서의 ProcessPoolExecutor\n\n## 프로세스란 무엇인가요?\n\n프로세스는 실행 중인 프로그램으로, 실행 중인 컴퓨터 프로그램의 인스턴스입니다. Python에서는 프로세스가 Python 코드를 실행하는 Python 인터프리터의 인스턴스입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로그램은 처리 명령을 포함한 실행 가능한 파일입니다. 응용 프로그램 또는 시스템 프로그램으로 나뉩니다:\n\n- 응용 프로그램: 워드 프로세서, 게임, Google Chrome 등\n- 시스템 프로그램: 컴파일러, 파일 관리 프로그램 등\n\n이 파일들은 디스크에 저장되며 컴파일되어 메모리(RAM)로 로드되어 프로세서(CPU)에서 실행됩니다.\n\n동시에 여러 프로세스가 실행될 수 있고, 하나의 프로그램은 여러 프로세스와 관련이 있을 수 있습니다(예: Chrome). 기계에서 실행 중인 각 프로세스는 자체 메모리 공간이 할당됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 프로세스에는 적어도 하나의 스레드, 즉 주 스레드가 있습니다. 스레드는 프로세스 내에서 실행의 기본 단위입니다. 다른 독립적인 실행 흐름과 동일한 주소 공간을 공유하는 독립적인 실행 흐름입니다. 하나 이상의 스레드를 가질 수 있습니다.\n\n![Multiprocessing in Python - Image 1](/assets/img/2024-06-30-MultiprocessinginPython_1.png)\n\n아래에서 내 컴퓨터에서 실행 중인 일부 프로세스와 그 안에 있는 스레드 수를 확인할 수 있습니다. 크롬 프로그램에 속하는 여러 프로세스가 보이며, 각각의 프로세스 ID(PID)와 함께 표시됩니다.\n\n![Multiprocessing in Python - Image 2](/assets/img/2024-06-30-MultiprocessinginPython_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬 스크립트를 실행하면 운영 체제가 파이썬 인터프리터를 실행하는 프로세스를 생성하고, 이 프로세스가 다시 파이썬 코드를 실행합니다.\n\n- 운영 체제는 새 프로세스를 시작합니다.\n- 이 프로세스가 파이썬 인터프리터를 실행합니다.\n- 파이썬 인터프리터가 사용자의 파이썬 스크립트를 읽고 실행합니다.\n\n# Multiprocessing 사용 사례\n\nMultiprocessing이 가장 적합한 작업 유형은 CPU 바운드 작업입니다. CPU 바운드 작업은 처리기 속도에 주로 좌우되는 작업으로, 수학 계산, 데이터 압축, 코드 컴파일, 머신 러닝 등과 같은 작업이 포함됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬에서 multiprocessing을 사용할 때는 실제로 병렬성을 구현하는 것이며, 파이썬의 Global Interpreter Lock (GIL) 때문에 병렬 실행이 불가능한 멀티스레딩과는 달라요.\n\n최소한 두 개의 CPU 코어를 갖춘 컴퓨터를 사용하여 multiprocessing을 통해 병렬로 여러 작업을 실행할 수 있어요. 하지만 오늘날에는 Simultaneous Multithreading SMT 또는 Hyper-Threading과 같은 기술 덕분에 하나의 코어 만으로도 여러 작업을 병렬로 실행할 수 있게 되었어요. 이 기술을 사용하면 컴퓨터가 하나의 물리 CPU 코어 안에 두 개 이상의 논리 코어를 가지게 됩니다.\n\nCPU 바운드 작업을 수행하는 두 가지 작업을 고려해보세요. 이러한 작업은 완료하는 데 더 많은 시간이 소요돼요. 아래에는 이를 나타내기 위해 유연한 구석이 차 있는 원형으로 표현되어 있습니다. 이러한 작업을 병렬로 실행하면 많은 시간을 절약할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대신, 동기적으로 실행하면 두 작업을 완료하는 데 필요한 시간이 더 오래 걸립니다.\n\n![](/assets/img/2024-06-30-MultiprocessinginPython_4.png)\n\n진정한 병렬성 없이 동시에 실행해도 이득이 없습니다.\n\n![](/assets/img/2024-06-30-MultiprocessinginPython_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 자식과 부모 프로세스\n\n부모 프로세스는 하나 이상의 자식 프로세스를 생성한 프로세스입니다. 시스템 호출을 통해 자식 프로세스의 생성을 시작합니다.\n\n플랫폼에 따라, multiprocessing은 프로세스를 시작하는 세 가지 방식을 지원합니다:\n\n- spawn\n  - 부모 프로세스는 새로운 Python 인터프리터 프로세스를 시작합니다. 자식 프로세스는 프로세스 객체의 Process.run() 메서드를 실행하는 데 필요한 리소스만 상속받습니다.\n  - Windows 및 macOS에서 기본값입니다.\n- fork\n  - 부모 프로세스는 os.fork()를 사용하여 Python 인터프리터를 복제합니다. 자식 프로세스는 시작할 때 부모와 동일합니다.\n  - macOS를 제외한 POSIX(Linux)에서 기본값입니다.\n- forkserver\n  - 서버 프로세스가 생성되며 새 프로세스가 필요할 때마다 부모 프로세스는 서버에 연결하여 새 프로세스를 생성하도록 요청합니다.\n  - Linux와 같은 Unix 파이프를 통해 파일 디스크립터를 전달하는 POSIX 플랫폼에서 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로그램이 실행될 때 시작하는 기본 프로세스를 주 프로세스라고 합니다. \n\n자식 프로세스는 부모 프로세스에 의해 생성된 프로세스입니다. 부모 프로세스의 사본이지만 고유한 프로세스 ID(PID)를 가지고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n부모로부터 환경 변수, 열린 파일, 특정 리소스 제한 등 속성을 상속받을 수 있습니다.\n\n프로세스를 다룰 때 운영체제는 프로세스에 필요한 자원(CPU 시간, 메모리 등)을 할당하고, 어떤 프로세스가 실행되는지 결정하여 CPU 시간을 공정하게 분배하고 효율적인 멀티태스킹을 보장합니다.\n\n# 프로세스 상태\n\n실행 중인 프로세스는 다음 상태들 사이를 변경할 수 있습니다. 프로세스가 실행 중일 때 높은 우선 순위의 프로세스에 의해 중단될 수 있어 다시 준비 상태로 돌아가게 됩니다. 또한 프로세스가 실행 중일 때 입력/출력 작업이나 이벤트 대기가 필요할 수 있습니다. 그런 경우 프로세스는 대기 상태로 변경되며, 대기 상태가 완료되면 준비 상태로 돌아갑니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-30-MultiprocessinginPython_6.png\" /\u003e\n\n만약 자식 프로세스가 실행을 완료했지만 부모가 아직 종료 상태를 읽지 않아 프로세스 테이블에 남아 있는 경우, 이를 좀비 프로세스 또는 망자 프로세스라고 합니다.\n\n부모 프로세스가 이미 종료되어 자식 프로세스가 아직 남아 있는 경우, 해당 자식 프로세스는 고아 프로세스가 됩니다.\n\n# 파이썬 multiprocessing 첫 걸음\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n멀티프로세싱 모듈은 스레딩 모듈과 유사한 API를 사용하여 프로세스를 생성하는 것을 지원합니다. multiprocessing 패키지는 로컬 및 원격 동시성을 모두 제공하여 스레드 대신 서브프로세스를 사용함으로써 전역 인터프리터 락을 우회합니다.\n\n우리는 multiprocessing.Process 객체를 생성하여 메인 프로세스에서 새로운 프로세스를 생성할 수 있습니다. 메인 프로세스는 새로운 자식 프로세스의 부모입니다.\n\n하지만 먼저, 파이썬의 Threading에서 사용한 것과 같은 CPU 바운드 작업을 정의해 봅시다.\n\n```js\ndef cpu_bound_operation(n: int) -\u003e tuple[float]:\n    \"\"\"CPU-bound task.\"\"\"\n    start = perf_counter()\n    count = 0\n    for i in range(n):\n        count += i\n    finish = perf_counter()\n\n    return start, finish\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 코드는 n개의 숫자 범위를 반복하고 이를 모두 더합니다. 그런 다음 나중에 차트를 그릴 수 있도록 시작 및 종료 시간이 포함된 튜플을 반환합니다.\n\n그런 다음 단순히 다른 함수에서 CPU 집약 작업을 실행하는 함수를 호출하고 반환 값을 기록합니다.\n\n마지막으로 multiprocessing 모듈에서 Process 클래스를 사용하여 자식 프로세스를 생성합니다.\n\n```python\ndef cpu_bound_task(counts: int) -\u003e None:\n    \"\"\"Run a CPU-bound task and append the results to shared_list.\"\"\"\n    time = cpu_bound_operation(counts)\n    logging.info(f\"time - {time}\")\n\ndef multiprocessing() -\u003e None:\n\n    # Run in a child process ; 150000000 is 3.25 secs aprox in my laptop\n    p = Process(target=cpu_bound_task, args=(150000000,))\n    p.start()  # Starts the process and calls the target function\n    p.join()  # Blocks the thread\n\n\nif __name__ == \"__main__\":\n    logging.info(\"Init program\")\n    multiprocessing()\n    logging.info(\"Finish program\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 multiprocessing() 함수에서:\n\n- multiprocessing.Process 객체를 생성할 때 args 매개변수에 일부 인수를 전달하여 생성한 함수를 대상 함수로 전달할 수 있습니다.\n- 대상 함수 cpu_bound_task는 multiprocessing.Process의 내부 run() 메서드에서 호출됩니다(부모 클래스 process.BaseProcess에서 상속되었지만 아직 호출되지 않았습니다).\n- start() 메서드가 호출될 때까지 프로세스는 준비 상태로 대기합니다.\n- start() 메서드를 호출하면 프로세스가 실행 중인 상태로 전환되어 새로운 자식 프로세스가 고유한 주 메인 스레드를 가지고 생성됩니다.\n- 새로운 프로세스는 전달한 인수와 함께 대상 함수를 실행하는 run() 메서드를 실행합니다.\n- 프로세스는 차단되지 않는 한 실행 중인 상태입니다.\n- join() 메서드는 프로세스가 실행을 완료할 때까지 대기합니다. 호출하는 스레드(주 프로세스의 주 스레드)는 프로세스가 종료될 때까지 블록됩니다.\n\n아래는 예제를 실행한 결과로, 자식 프로세스가 완료하는 데 걸린 시간을 보여줍니다.\n\n```js\n20:45:31: 프로그램 시작\n20:45:35: 시간 - (45723.689522083, 45727.402436291)\n20:45:35: 프로그램 완료\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 각 프로세스에는 별도의 메모리 주소 공간이 있습니다.\n\n파이썬의 스레딩에 대한 포스트를 읽으셨다면, 같은 메모리 공간을 공유하는 쓰레드들이 완료하는 데 걸린 시간을 shared_data 변수에 저장했다는 것을 알 수 있을 것입니다. 같은 프로세스 내의 스레드는 동일한 메모리 공간을 공유하기 때문에 모두 데이터를 공유할 수 있습니다. 하지만 프로세스들은 다른 프로세스의 공유 데이터에 직접적으로 액세스할 수 없습니다.\n\n다음 예시에서 간단한 변수를 통해 두 프로세스가 데이터를 직접적으로 공유할 수 없음을 확인할 수 있습니다. 왜냐하면 각 프로세스는 별도의 메모리 공간을 갖기 때문입니다.\n\n우리는 주 프로세스에서 shared_list라는 변수를 생성하여 그 안에 시간 결과를 저장합니다. 그런 다음 두 가지 작업을 정의하는데, 각각은 자신의 결과를 shared_list 변수에 추가할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport logging\nfrom concurrency.operations.cpu_bound import cpu_bound_operation\nfrom multiprocessing import Process\n\n\nformat = \"%(asctime)s: %(message)s\"\nlogging.basicConfig(format=format, level=logging.INFO, datefmt=\"%H:%M:%S\")\n\n\n# 동일한 프로세스의 스레드는 메모리 공간을 공유합니다\n# 프로세스는 다른 메모리 공간을 가집니다\nshared_list = []\n\n\ndef cpu_bound_task_1(counts: int) -\u003e None:\n    \"\"\"CPU 바운드 작업을 실행하고 결과를 shared_list에 추가합니다.\"\"\"\n    time = cpu_bound_operation(counts)\n    logging.info(\"시간 1 - \", time)\n    logging.info(f\"공유 리스트 1 {shared_list}\")\n    shared_list.append([time])\n    logging.info(f\"공유 리스트 1 {shared_list}\")\n\n\ndef cpu_bound_task_2(counts: int) -\u003e None:\n    \"\"\"CPU 바운드 작업을 실행하고 결과를 shared_list에 추가합니다.\"\"\"\n    time = cpu_bound_operation(counts)\n    logging.info(\"시간 2 - \", time)\n    logging.info(f\"공유 리스트 2 {shared_list}\")\n    shared_list.append([time])\n    logging.info(f\"공유 리스트 2 {shared_list}\")\n```\n\n이제 multiprocessing() 함수에서 CPU 바운드 작업을 호출합니다.\n\ncpu_bound_task_1()은 부모 프로세스인 메인 프로세스의 주 스레드에서 실행됩니다.\n\n그런 다음 작업 1이 완료되면 자식 프로세스에서 작업 2를 실행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef multiprocessing() -\u003e None:\n\n    start = perf_counter()\n    # Main process에서 실행 - 1\n    cpu_bound_task_1(150000000)\n\n    # 자식 프로세스에서 실행 - 2\n    p = Process(target=cpu_bound_task_2, args=(150000000,))\n    p.start()  # 프로세스 시작 및 대상 함수 호출\n    p.join()  # 스레드 차단\n\n    logging.info(f\"최종 shared_list {shared_list}\")\n    end = perf_counter()\n\n    logging.info(f\"총 소요 시간 :: {round(end - start, 4)} 초\")\n\n\nif __name__ == \"__main__\":\n    logging.info(\"프로그램 시작\")\n    multiprocessing()\n    logging.info(\"프로그램 종료\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 두 작업의 순서를 변경한다면 (아래 예시 참조) join() 메서드가 주 스레드를 차일드 프로세스가 완료될 때까지 차단하기 때문에 병렬로 실행되지 않게 됩니다.\n\n```js\ndef multiprocessing() -\u003e None:\n\n    start = perf_counter()\n    # 자식 프로세스에서 실행 - 2\n    p = Process(target=cpu_bound_task_2, args=(150000000,))\n    p.start()  # 프로세스를 시작하고 타겟 함수를 호출합니다\n    p.join()  # 스레드를 차단합니다\n\n    # 메인 프로세스에서 실행 - 1\n    cpu_bound_task_1(150000000)\n\n    logging.info(f\"최종 공유 리스트 {shared_list}\")\n    end = perf_counter()\n\n    logging.info(f\"총 시간 :: {round(end - start, 4)} 초\")\n```\n\n완료하는 데 걸리는 시간은 거의 동일합니다.\n\n```js\n17:55:18: 프로그램 시작\n...\n17:55:25: 총 시간 :: 6.6648 초\n17:55:25: 프로그램 완료\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제로 두 작업을 병렬로 실행하려면 작업 1이 실행되기 전에 부모 프로세스의 주 스레드를 차단하지 않아야 합니다. 따라서 작업 1이 시작된 후 join() 메서드를 호출해야 합니다.\n\n```js\ndef multiprocessing() -\u003e None:\n\n    start = perf_counter()\n    # Run in a child process - 2\n    p = Process(target=cpu_bound_task_2, args=(150000000,))\n    p.start()  # 프로세스를 시작하고 대상 함수를 호출합니다.\n\n    # Run in the main process - 1\n    cpu_bound_task_1(150000000)\n    \n    p.join()  # 스레드를 차단합니다.\n\n    logging.info(f\"final shared_list {shared_list}\")\n    end = perf_counter()\n\n    logging.info(f\"Total time :: {round(end - start, 4)} secs\")\n```\n\n아래에서 볼 수 있듯이, 두 작업을 완료하는 데 소요된 시간이 대략 절반으로 감소했습니다:\n\n```js\n18:08:48: 병렬 프로그램 초기화\n...\n18:08:51: 총 시간 :: 3.3857 초\n18:08:51: 병렬 프로그램 완료\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어이, 잠시만요! 방금 다른 프로세스가 같은 메모리 공간을 공유하지 않는지 확인했던 거 아니었나요? 🧐\n\n병렬로 실행할 수 있는 우리 프로그램의 전체 출력을 조사해보면 몇 가지 흥미로운 점을 발견할 수 있어요.\n\n```js\n18:08:48: 병렬 프로그램 초기화\n\n18:08:51: 시간 1 - (14708.567523791, 14711.932722375)\n18:08:51: 공유 목록 1 []\n18:08:51: 공유 목록 1 [[(14708.567523791, 14711.932722375)]]\n\n18:08:51: 시간 2 -  (14708.587407041, 14711.944044333)\n18:08:51: 공유 목록 2 []\n18:08:51: 공유 목록 2 [[(14708.587407041, 14711.944044333)]]\n\n18:08:51: 최종 공유 목록 [[(14708.567523791, 14711.932722375)]]\n\n18:08:51: 총 실행 시간 :: 3.3857 초\n\n18:08:51: 병렬 프로그램 완료\n```\n\n- 우리는 부모 프로세스에서 작업 1을 실행하기 전에 작업 2의 목표로 자식 프로세스를 생성하고 시작합니다. 그러나 작업 1이 작업 2보다 먼저 실행되기 시작합니다. 이는 자식 프로세스를 생성하는 과정이 충분한 시간이 소요되어 작업 1이 시작된 후에야 그 이후로 늦춰진다고 생각해요.\n- 두 작업은 부모 프로세스에서 생성된 share_list 변수에 결과 시간을 추가합니다. 그러나 우리가 로그를 찍을 때 변수에 저장된 결과는 부모 프로세스에서 실행되었던 작업인 작업 1의 결과만 보관하는 것을 확인할 수 있어요. 이것은 자식 프로세스가 부모 프로세스와 데이터를 공유하지 못하도록 되어 있다는 것을 확인해줘요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 결과를 주의 깊게 살펴보면, 두 작업 모두 메모리 공간을 공유하지 않는 상황에서도 데이터를 shared_list라는 변수에 저장한다는 점을 알 수 있어요. 🤯 여기서 무슨 일이 벌어지고 있는 걸까요? 😱\n\nspawn 방법을 사용하여 multiprocessing 모듈에 의해 생성된 각 프로세스(새로운 Python 인터프리터 프로세스를 시작함)는 독립된 메모리 공간을 갖습니다. 즉, shared_list와 같은 전역 변수를 포함한 모든 변수는 각 프로세스에서 복제되며, 한 프로세스에서 이러한 변수를 변경해도 다른 프로세스에 영향을 주지 않아요.\n\n이를 더 잘 이해하기 위해 프로세스 ID와 shared_list의 메모리 주소를 확인하는 코드를 추가해볼까요?\n\n```js\n...\nshared_list = []\nlogging.info(\n    f\"--\u003e id - main thread in {os.getpid()} process shared_list: {id(shared_list)}\"\n)\n\n\ndef cpu_bound_task_1(counts: int) -\u003e None:\n    ...\n    shared_list.append([time])\n    logging.info(\n        f\"--\u003e id - main thread in {os.getpid()} process in task 1 shared_list: {id(shared_list)}\"\n    )\n    logging.info(f\"shared_list 1 {shared_list}\")\n\n\ndef cpu_bound_task_2(counts: int) -\u003e None:\n    ...\n    shared_list.append([time])\n    logging.info(\n        f\"--\u003e id - main thread in {os.getpid()} process in task 2 shared_list: {id(shared_list)}\"\n    )\n    logging.info(f\"shared_list 2 {shared_list}\")\n\n\ndef multiprocessing() -\u003e None:\n\n    start = perf_counter()\n    # Run in a child process - 2\n    p = Process(target=cpu_bound_task_2, args=(150000000,))\n    p.start()  # Starts the process and calls the target function\n\n    # Run in the main process - 1\n    cpu_bound_task_1(150000000)\n\n    p.join()  # Blocks the thread\n\n    logging.info(f\"final shared_list {shared_list}\")\n    logging.info(\n        f\"--\u003e id - main thread in {os.getpid()} process final shared_list: {id(shared_list)}\"\n    )\n    end = perf_counter()\n\n    logging.info(f\"Total time :: {round(end - start, 4)} secs\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드 결과는 다음을 보여줍니다:\n\n```js\n19:58:05: --\u003e FIRST id - 메인 스레드인 17723 프로세스에서 shared_list: 4340073984\n\n19:58:05: 병렬 프로그램 초기화\n\n19:58:05: --\u003e FIRST id - 메인 스레드인 17725 프로세스에서 shared_list: 4313028032\n\n19:58:08: 시간 2 - (21265.75012825, 21269.074238291)\n19:58:08: 공유된 목록 2 []\n19:58:08: --\u003e 17725 프로세스의 작업 2에서 메인 스레드 ID가 shared_list: 4313028032인 것\n19:58:08: 공유된 목록 2 [[(21265.75012825, 21269.074238291)]]\n\n19:58:09: 시간 1 - (21265.729837416, 21269.162869458)\n19:58:09: 공유된 목록 1 []\n19:58:09: --\u003e 17723 프로세스의 작업 1에서 메인 스레드 ID가 shared_list: 4340073984인 것\n19:58:09: 공유된 목록 1 [[(21265.729837416, 21269.162869458)]]\n\n19:58:09: 최종 공유된 목록 [[(21265.729837416, 21269.162869458)]]\n\n19:58:09: --\u003e 17723 프로세스의 최종 공유된 목록: 4340073984\n\n19:58:09: 총 소요 시간: 3.4389초\n\n19:58:09: 병렬 프로그램 완료\n``` \n\n각 프로세스가 자체 메모리 주소를 갖는 shared_list 글로벌 변수의 고유한 버전을 가지고 있음을 알 수 있습니다. 이들은 완전히 다릅니다.\n\n- 줄 1\n  - 프로세스 PID 17723 - 부모 프로세스\n  - shared_list 메모리 주소 4340073984\n- 줄 5\n  - 프로세스 PID 17725 - 자식 프로세스\n  - shared_list 메모리 주소 4313028032\n- 줄 9\n  - 프로세스 PID 17725 - 자식 프로세스\n  - shared_list 메모리 주소 4313028032\n- 줄 14\n  - 프로세스 PID 17723 - 부모 프로세스\n  - shared_list 메모리 주소 4340073984\n- 줄 19\n  - 프로세스 PID 17723 - 부모 프로세스\n  - shared_list 메모리 주소 4340073984\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 macOS를 사용 중이기 때문에 multiprocessing 모듈은 spawn 방법을 사용하여 새로운 자식 프로세스를 생성합니다. spawn 방법은 spawn()과 같이 내부적으로 호출되는 방법이 아닙니다. 이 방법을 사용할 때 multiprocessing 모듈이 새로운 프로세스를 생성하기 위해 신선한 Python 인터프리터를 실행하는 방식으로 내부적으로 처리합니다. 그래서 우리의 shared_list 전역 변수는 다른 메모리 주소를 갖게 됩니다.\n\n이제 시간 결과에 집중해보면 두 프로세스가 모두 해당 결과를 shared_list 변수에 추가하고 있음을 알 수 있습니다. 그러나 각각이 변수의 자체 버전에 추가하고 있습니다.\n\n최종적으로 부모 프로세스에서 shared_list 변수의 값을 확인하면 부모 프로세스의 task 1이 그것에 추가한 값만 표시됩니다. 자식 프로세스의 task 2가 자신의 변수 버전에 값을 추가했기 때문에 데이터를 공유하지 않습니다.\n\n```js\n19:58:05: --\u003e FIRST id - main thread in 17723 process shared_list: 4340073984\n\n19:58:05: 병렬 프로그램 시작\n\n19:58:05: --\u003e FIRST id - main thread in 17725 process shared_list: 4313028032\n\n19:58:08: 시간 2 - (21265.75012825, 21269.074238291)\n19:58:08: shared_list 2 []\n19:58:08: --\u003e id - main thread in 17725 process in task 2 shared_list: 4313028032\n19:58:08: shared_list 2 [[(21265.75012825, 21269.074238291)]]\n\n19:58:09: 시간 1 - (21265.729837416, 21269.162869458)\n19:58:09: shared_list 1 []\n19:58:09: --\u003e id - main thread in 17723 process in task 1 shared_list: 4340073984\n19:58:09: shared_list 1 [[(21265.729837416, 21269.162869458)]]\n\n19:58:09: 최종 shared_list [[(21265.729837416, 21269.162869458)]]\n\n19:58:09: --\u003e id - main thread in 17723 process final shared_list: 4340073984\n\n19:58:09: 총 소요 시간: 3.4389 초\n\n19:58:09: 병렬 프로그램 종료\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 아마 궁금해하고 있을 거예요. 리눅스를 사용한다면 맥북 프로처럼 비싼 돈을 들여서 사용하는 경우에는 어떻게 될까요? 그렇죠? 그래서 os.fork() 메서드를 사용하여 자식 프로세스를 생성하는 경우에는 어떻게 될까요?\n\n자, 이제 알아보겠습니다! ✨\n\n우리는 multiprocessing 모듈의 시작 방법을 set_start_method()를 통해 명시적으로 지정할 수 있어요:\n\n```js\n...\nimport multiprocessing as mp \n\n...\n\ndef multiprocessing() -\u003e None:\n\n    mp.set_start_method(\"fork\")\n\n    start = perf_counter()\n    # 자식 프로세스에서 실행 - 2\n    p = mp.Process(target=cpu_bound_task_2, args=(150000000,))\n    p.start()  # 프로세스를 시작하고 대상 함수를 호출함\n\n    # 주 프로세스에서 실행 - 1\n    cpu_bound_task_1(150000000)\n\n    p.join()  # 스레드를 블록함\n\n    logging.info(f\"최종 공유 리스트 {shared_list}\")\n    logging.info(\n        f\"--\u003e id - {os.getpid()} 프로세스 내의 메인 스레드가 가진 최종 공유 리스트: {id(shared_list)}\"\n    )\n    end = perf_counter()\n\n    logging.info(f\"전체 시간 :: {round(end - start, 4)} 초\")\r\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로세스 및 메모리 주소 로그에 집중하면 이제 shared_list 변수가 서로 다른 프로세스에 있더라도 동일한 메모리 주소를 가지고 있다는 사실을 알 수 있어요! 🤯\n\n```js\n20:54:27: --\u003e id - 19098 프로세스 메인 스레드에서 shared_list: 4375988096\n\n20:54:27: 병렬 프로그램 시작\n\n20:54:31: 시간 1 - (24648.12229775, 24651.257626791)\n20:54:31: shared_list 1 []\n20:54:31: --\u003e id - 19098 프로세스 메인 스레드에서 작업 1의 shared_list: 4375988096\n20:54:31: shared_list 1 [[(24648.12229775, 24651.257626791)]]\n\n20:54:31: 시간 2 - (24648.122759958, 24651.44781075)\n20:54:31: shared_list 2 []\n20:54:31: --\u003e id - 19099 프로세스에서 작업 2의 shared_list: 4375988096\n20:54:31: shared_list 2 [[(24648.122759958, 24651.44781075)]]\n\n20:54:31: 최종 shared_list [[(24648.12229775, 24651.257626791)]]\n\n20:54:31: --\u003e id - 19098 프로세스 메인 스레드에서 최종 shared_list: 4375988096\n\n20:54:31: 총 소요 시간 :: 3.3296 초\n\n20:54:31: 병렬 프로그램 종료\n```\n\n부모 프로세스가 os.fork() 메서드를 사용하여 Python 인터프리터를 복제하는 경우, 자식 프로세스는 시작할 때 부모 프로세스와 완전히 동일합니다. 자식 프로세스는 부모의 모든 리소스를 상속받습니다.\n\n따라서 os.fork()를 사용할 때 자식 프로세스는 부모 프로세스의 복사본으로 생성됩니다. 이는 부모 프로세스의 메모리 공간을 복사하며, 이로 인해 자식 프로세스가 초기에는 부모 프로세스와 동일한 메모리 레이아웃을 가지며 모든 객체의 주소를 포함합니다. 따라서 fork 직후에는 두 프로세스(부모 및 자식)가 변수인 shared_list와 같은 메모리 내용 및 주소를 공유합니다. 하지만 이는 두 프로세스가 동일한 메모리 공간을 공유한다는 의미는 아닙니다. 그들은 단지 fork 직후에 동일한 우연히 동일한 메모리 공간을 가지고 있을 뿐입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 작업은 메모리 사용량을 최적화하기 위해 \"copy-on-write\" 기술을 사용하여 수행됩니다. 이는 자식 프로세스가 초기에는 부모 프로세스와 동일한 메모리 페이지를 공유하지만 부모 또는 자식 프로세스 중 하나가 페이지를 수정하면 해당 페이지의 복사본이 수정 프로세스를 위해 생성됩니다. 따라서 메모리가 처음에는 공유되지만 어떤 변경이 발생하면 별도의 복사본이 생기면서 독립적인 메모리 공간으로 이어집니다.\n\n# 프로세스 간 객체 교환\n\nmultiprocessing 모듈은 프로세스 간 통신 채널로 두 가지 유형을 지원합니다:\n\n- Queue()\n- Pipe()\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmultiprocessing.Queue은 내부적으로 multiprocessing.Pipe를 사용하며 일반적으로 선호됩니다. Queue는 Pipe에 비해 더 간단하고 직관적인 API를 가진 더 높은 수준의 추상화를 제공합니다.\n\nQueue는 다음과 같은 Pipe에 비해 몇 가지 이점을 제공합니다:\n\n- Queue는 여러 생성자 및 소비자를 기본적으로 지원하므로 여러 프로세스가 동시에 큐에 항목을 넣고 큐에서 항목을 동시에 가져올 수 있습니다. 반면에 Pipe는 두 지점 간의 일대일 통신에 가장 적합하며 여러 생성자 또는 소비자를 관리하는 것은 복잡하고 오류가 발생할 수 있습니다.\n- Queue는 스레드 및 프로세스 안전합니다. Queue는 잠금 및 세마포어를 내부적으로 관리하여 작업이 안전하게 수행되고 데이터 손상이나 경합 조건이 발생하지 않도록 보장합니다.\n- Queue에는 내부 버퍼링이 포함되어 있어 프로세스 간의 컨텍스트 전환 빈도를 줄이는 방식으로 성능을 향상시킬 수 있습니다. 버퍼는 데이터가 한 곳에서 다른 곳으로 전송되는 동안 사용되는 컴퓨터 메모리의 임시 저장 영역입니다.\n\n일반적으로 큐는 프로세스 간에 단방향 또는 양방향 채널을 설정하기 위해 Pipe를 사용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만, Pipe()를 사용하여 예제를 시작해 봅시다!\n\n## Pipe 함수\n\nPipe() 함수는 기본적으로 이중(duplex)인 파이프로 연결된 두 개의 연결 객체를 반환합니다. Pipe()에 의해 반환된 두 연결 객체는 파이프의 두 끝을 나타냅니다. 각각의 연결 객체는 send() 및 recv() 메서드(그 외에도 다른 메서드들이 있음)를 갖고 있습니다.\n\n여기서는 send()를 사용하여 자식 프로세스에서 데이터를 보내고 recv()를 사용하여 부모 프로세스에서 데이터를 받습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\n...\nfrom multiprocessing.connection import Connection \n...\nfrom multiprocessing import Pipe, Process \n\n\nshared_list = []\n\n...\n\ndef cpu_bound_task_2(counts: int, conn: Connection) -\u003e None:\n    \"\"\"CPU 바운드 작업을 실행하고 결과를 부모에게 보냅니다.\"\"\"\n    time = cpu_bound_operation(counts)\n    logging.info(f\"시간 2 -  {time}\")\n    conn.send([time])\n    conn.close()\n\n\ndef multiprocessing() -\u003e None:\n\n    parent_conn, child_conn = Pipe()\n\n    start = perf_counter()\n    # 자식 프로세스에서 실행 - 2\n    p = Process(target=cpu_bound_task_2, args=(150000000, child_conn))\n    p.start()  # 프로세스를 시작하고 대상 함수를 호출합니다.\n\n    # 주 프로세스에서 실행 - 1\n    cpu_bound_task_1(150000000)\n\n    child_time = parent_conn.recv()\n    logging.info(f\"자식 프로세스 시간: {child_time}\")\n    shared_list.append(child_time)\n\n    p.join()  # 스레드를 차단합니다.\n    ...\r\n```\n\nparent_conn.recv() 메서드는 cpu_bound_task_1 이후에 위치해야 합니다. 그렇지 않으면 부모 프로세스의 주 스레드가 데이터를 받을 때까지 블록됩니다.\n\n```js\r\n18:10:59: 병렬 프로그램 초기화\n\n18:11:02: 시간 1 - (44691.260117416, 44694.601532625)\n18:11:02: 공유 리스트 1 []\n18:11:02: 공유 리스트 1 [[(44691.260117416, 44694.601532625)]]\n\n18:11:02: 시간 2 -  (44691.283312583, 44694.670279125)\n\n18:11:02: 자식 프로세스 시간: [(44691.283312583, 44694.670279125)]\n\n18:11:02: 최종 공유 리스트 [[(44691.260117416, 44694.601532625)], [(44691.283312583, 44694.670279125)]]\n\n18:11:02: 총 경과 시간 :: 3.4163 초\n\n18:11:02: 병렬 프로그램 완료\r\n```\n\n이제 다시 shared_list 변수에 시간이 포함되어 있기 때문에 막대 차트를 생성하는 플로팅 함수를 사용할 수 있습니다! 💃🏻\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-30-MultiprocessinginPython_7.png\" /\u003e\n\n## Queue 클래스\n\nmultiprocessing.Queue 클래스는 프로세스간에 객체를 교환하는 우선적인 방법입니다.\n\n앞의 프로그램을 구현하기 위해 약간의 변경만 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n...\nfrom multiprocessing import Process, Queue \n\n...\n\nshared_list = []\n\n...\n\ndef cpu_bound_task_2(counts: int, q: Queue) -\u003e None:\n    \"\"\"Runs a CPU-bound task and sends the results to parent.\"\"\"\n    time = cpu_bound_operation(counts)\n    logging.info(f\"time 2 -  {time}\")\n    q.put([time]) # Add items to the queue\n\n\ndef multiprocessing() -\u003e None:\n\n    q = Queue()\n\n    start = perf_counter()\n    # Run in a child process - 2\n    p = Process(target=cpu_bound_task_2, args=(150000000, q))\n    p.start()  # Starts the process and calls the target function\n\n    # Run in the main process - 1\n    cpu_bound_task_1(150000000)\n\n    child_time = q.get() # Remove and return an item from the queue\n    logging.info(f\"child process time: {child_time}\")\n    shared_list.append(child_time)\n\n    p.join()  # Blocks the thread\n    ...\n```\n\nput() 메서드는 항목을 큐에 추가하는 데 사용됩니다. 이 메서드는 객체를 직렬화하고 내부 버퍼로 이를 전송합니다.\n\nget() 메서드는 큐에서 항목을 제거하고 반환하는 데 사용됩니다. 이 메서드는 파이프로부터 직렬화된 객체를 읽고 역직렬화합니다.\n\n그리고 결과는 꽤 유사합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Multiprocessing in Python](/assets/img/2024-06-30-MultiprocessinginPython_8.png)\n\n# Pool of worker processes with Pool class\n\nThe Pool class provides a convenient way to parallelize the execution of a function across multiple input values, distributing the input data across available processes.\n\nWhen a Pool object is created, it initializes several worker processes. The number of worker processes can be specified with the processes parameter, or it defaults to the number of logical CPU cores returned by os.cpu_count() (or by os.process_cpu_count() since Python 3.13).\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmap, map_async, apply, apply_async, imap, imap_unordered, starmap 및 starmap_async과 같은 메소드들을 사용하여 작업을 풀(pool)에 제출합니다.\n\n풀(pool) 객체는 내부적으로 큐를 사용하여 작업을 메인 프로세스에서 작업 프로세스로 보내고, 작업 프로세스에서 결과를 다시 메인 프로세스로 전송합니다.\n\n일부 예제를 살펴보겠습니다!\n\n## map\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmap() 메소드에는 함수, 반복 가능한 객체 및 청크 크기를 지정하는 정수를 제공할 수 있습니다.\n\n이 메소드는 반복 가능한 객체를 여러 청크로 나누고 이를 워커 프로세스 풀에서 분배합니다.\n\n모든 항목이 처리될 때까지 map은 블록킹됩니다.\n\n첫 번째 예시에서는 4개의 프로세스와 4개의 정수로 된 반복 가능한 객체가 있습니다. 우리의 함수는 각 프로세스에서 실행되며, 반복 가능한 객체의 값들이 프로세스 사이에 분배되고 함수에 인수로 전달됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n...\n\ndef cpu_bound_task(counts: int) -\u003e None:\n    \"\"\"CPU 바운드 작업을 실행합니다.\"\"\"\n    time = cpu_bound_operation(counts)\n    logging.info(f\"-------- 프로세스: {os.getpid()} --------\")\n    logging.info(f\"time - {time}\\n\")\n    return [time]\n\n\ndef multiprocessing() -\u003e None:\n\n    args = [50000000, 50000000, 50000000, 50000000]\n\n    # Worker 프로세스에서 실행\n    with Pool(processes=4) as pool:\n        res = pool.map(cpu_bound_task, args)  # 결과가 준비될 때까지 블록됩니다\n\n        logging.info(res)\n    ...\n```\n\n각 프로세스는 주어진 함수를 반복 가능한 값 중 하나로 실행합니다.\n\n```python\n22:17:24: 병렬 프로그램 시작\n\n22:17:25: -------- 프로세스: 44665 --------\n22:17:25: time - (56633.60939425, 56634.651306916)\n\n22:17:25: -------- 프로세스: 44663 --------\n22:17:25: time - (56633.612802333, 56634.656112583)\n\n22:17:25: -------- 프로세스: 44666 --------\n22:17:25: time - (56633.64181075, 56634.682685541)\n\n22:17:25: -------- 프로세스: 44664 --------\n22:17:25: time - (56633.641066125, 56634.707866125)\n\n22:17:25: [[(56633.60939425, 56634.651306916)], [(56633.612802333, 56634.656112583)], [(56633.641066125, 56634.707866125)], [(56633.64181075, 56634.682685541)]]\n\n22:17:26: 병렬 프로그램 종료\n```\n\n네 가지 작업이 효과적으로 병렬로 실행됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/assets/img/2024-06-30-MultiprocessinginPython_9.png)\n\n이제 iterable에 두 가지 값을 더 추가하고 네 개의 워커를 유지하면 두 개의 새 값이 워커 프로세스가 사용 가능해지면 처리되는 것을 볼 수 있습니다.\n\n```python\n...\n\ndef multiprocessing() -\u003e None:\n\n    args = [50000000, 50000000, 50000000, 50000000, 50000000, 50000000]\n\n    # Worker 프로세스에서 실행\n    with Pool(processes=4) as pool:\n        res = pool.map(cpu_bound_task, args)  # 결과가 준비될 때까지 블록됨\n\n        logging.info(res)\n\n    ...\n```\n\n![Image](/assets/img/2024-06-30-MultiprocessinginPython_10.png)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 chunksize 매개변수로 놀아봅시다.\n\n24개의 값을 처리할 이터러블을 제출하고 chunksize를 1로 전달하면 위의 것과 동일한 동작을 볼 수 있습니다.\n\n```js\n...\n\ndef multiprocessing() -\u003e None:\n\n    n_tasks = 24\n    args = [50000000] * n_tasks\n    chunksize = 1\n\n    # Worker 프로세스에서 실행\n    with Pool(processes=4) as pool:\n        res = pool.map(\n            cpu_bound_task, args, chunksize\n        )  # 결과가 준비될 때까지 블록됨\n\n        logging.info(res)\n\n    ...\n```\n\n\u003cimg src=\"/assets/img/2024-06-30-MultiprocessinginPython_11.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대신에, chunksize 매개변수를 설정하여 처리해야 할 작업의 수를 줄일 수 있습니다. map() 메서드는 이터러블을 여러 청크로 나누어 풀에 별도의 작업으로 제출합니다. 이러한 청크의 (대략적인) 크기는 chunksize를 양수 정수로 설정하여 지정할 수 있습니다.\n\n아래 예시에서는 24개의 요소가 있는 args 이터러블과 chunksize가 2로 설정되어 있습니다. 이는 24개의 작업이 24개가 아닌 12개처럼 전송되며, 각 작업은 이터러블에서 2개의 요소를 가지게 됩니다.\n\n```python\n...\n\ndef multiprocessing() -\u003e None:\n\n    n_tasks = 24\n    args = [50000000] * n_tasks\n    chunksize = 1\n    chunksize = 2\n\n    # 워커 프로세스에서 실행\n    ...\n```\n\n![그림](/assets/img/2024-06-30-MultiprocessinginPython_12.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 chunksize가 3으로 설정하면 다음과 같습니다:\n\n```js\n...\n\ndef multiprocessing() -\u003e None:\n\n    n_tasks = 24\n    args = [50000000] * n_tasks\n    chunksize = 2\n    chunksize = 3\n\n    # 작업 프로세스에서 실행\n    ...\n```\n\n![이미지](/assets/img/2024-06-30-MultiprocessinginPython_13.png)\n\n## map_async\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmap_async()은 AsyncResult 객체를 반환하며 스레드를 차단하지 않습니다. 결과를 기다리거나 준비되었는지 확인하려면 get(), wait() 또는 ready()와 같은 AsyncResult 메소드를 사용할 수 있습니다. get() 및 wait()는 시간 초과 인자를 받습니다.\n\n```python\n...\n\ndef multiprocessing() -\u003e None:\n\n    n_tasks = 24\n    args = [50000000] * n_tasks\n\n    # worker 프로세스에서 실행\n    with Pool(processes=4) as pool:\n        res = pool.map_async(cpu_bound_task, args, 1)  # 차단되지 않음\n\n        logging.info(f\"res.ready(): {res.ready()}\")\n        logging.info(\"waiting...\")\n        res.wait()  # 결과가 준비될 때까지 차단\n        logging.info(f\"res.ready(): {res.ready()}\")\n        res = res.get()\n\n    ...\n```\n\n```python\n20:05:53: 병렬 프로그램 시작\n\n20:05:53: res.ready(): False\n20:05:53: 대기 중...\n\n20:05:54: -------- 프로세스: 35723 --------\n20:05:54: 시간 - (151823.566433833, 151824.614282083)\n\n...\n\n20:06:00: res.ready(): True\n\n20:06:00: 병렬 프로그램 완료\n```\n\n![이미지](/assets/img/2024-06-30-MultiprocessinginPython_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmultiprocessing.Pool 및 multiprocessing.AsyncResult 문서에서 apply_async와 기타 유용한 메서드를 찾을 수 있어요.\n\napply() 메서드는 제공한 인수로 함수를 호출하고 해당 함수가 완료될 때까지 블록되어 결과를 반환해요. 직접 함수 호출과 유사하지만 풀 내 작업자 프로세스에서 실행됩니다. apply_async()는 AsyncResult 객체를 반환하며 스레드를 블록하지 않아요.\n\n아래에는 이 주제를 더 잘 이해하는 데 도움이 된 몇 가지 리소스가 있어요.\n\n어떤 소셜 네트워크에서든 연락해도 괜찮아요. 피드백을 주시면 감사하겠어요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n읽어 주셔서 감사합니다 💛\n\njavideveloper.com\n\n# 기타 참고 자료\n\n- multiprocessing — 프로세스 기반 병렬 처리\n- multiprocessing 모듈 소스 코드\n- concurrency repo | javiicc\n- 좀비 프로세스\n- 고아 프로세스\n- Python Multiprocessing: 완전 가이드 | SuperFastPython\n- Copy on Write | GeeksforGeeks\n- 병행성과 병렬성 소개\n- Python에서의 스레딩","ogImage":{"url":"/assets/img/2024-06-30-MultiprocessinginPython_0.png"},"coverImage":"/assets/img/2024-06-30-MultiprocessinginPython_0.png","tag":["Tech"],"readingTime":37},{"title":"ntscraper를 사용한 실시간 트윗 데이터 분석 방법","description":"","date":"2024-06-30 22:12","slug":"2024-06-30-ScrapingTweetsforReal-TimeDataAnalysisUsingntscraper","content":"\n\n![이미지](/assets/img/2024-06-30-ScrapingTweetsforReal-TimeDataAnalysisUsingntscraper_0.png)\n\n데이터 분석 분야는 계속 발전 중이에요. 실시간 데이터는 매우 중요하죠. 실시간 데이터의 가장 풍부한 출처 중 하나는 소셜 미디어인데, 특히 트위터(X.com)가 그 중요한 출처이죠. 트위터 데이터에 접근하려면 기존에는 복잡한 트위터 API를 통해 접근해야 했는데, 이는 종종 유료 구독과 복잡한 인증 키가 필요했어요. 그러나 새로운 Python 라이브러리인 ntscraper를 사용하면 유료 API나 키 없이도 트윗을 스크래핑할 수 있는데요. 이 블로그에서는 ntscraper를 사용하여 실시간 데이터셋을 만들어본 경험을 공유할게요.\n\n# ntscraper 소개\n\nntscraper는 공식 API가 필요 없이 트위터에서 트윗을 바로 스크래핑할 수 있도록 설계된 Python 라이브러리에요. 이를 통해 데이터 과학을 시작한 사람들에게도 매우 접근하기 쉽고 사용하기 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# ntscraper의 주요 기능:\n\n- API 키 불필요: API 요청 제한과 인증 처리로 인한 번거로움을 피하세요.\n- 실시간 데이터: 게시된 최신 트윗을 검색합니다.\n- CSV 변환: 수집된 데이터를 쉽게 CSV 형식으로 변환하여 분석할 수 있습니다.\n\n# ntscraper로 시작하기\n\n# 단계 1: 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 ntscraper 라이브러리를 설치하세요. 이 작업은 pip를 사용하여 수행할 수 있습니다:\n\n```js\npip install ntscraper\n```\n\n# 단계 2: 트윗 스크레이핑\n\n다음은 인도 대통령(@rashtrapatibhvn)의 공식 트위터 계정에서 트윗을 스크레이핑하고 CSV 파일로 저장한 구체적인 코드입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom ntscraper import Nitter\n\n# 스크레이퍼 초기화\nscraper = Nitter()\n\n# 특정 사용자의 트윗 스크랩\ntweets_data = scraper.get_tweets(\"rashtrapatibhvn\", mode='user', number=10)\nprint(tweets_data)\n\n# 데이터 구조 검사\nprint(tweets_data.keys())\nprint(tweets_data['tweets'][0])\n\n# 프로필 정보 가져오기\nprofile_info = scraper.get_profile_info(username='elonmusk')\nprint(profile_info)\n\n# 트윗 데이터를 저장할 딕셔너리 생성\ndata = {\n    '링크': [],\n    '내용': [],\n    '사용자': [],\n    '좋아요': [],\n    '리트윗': [],\n    '댓글': []\n}\n\n# 트윗에서 데이터 추출\nfor tweet in tweets_data['tweets']:\n    data['링크'].append(tweet['link'])\n    data['내용'].append(tweet['text'])\n    data['사용자'].append(tweet['user']['name'])\n    data['좋아요'].append(tweet['stats']['likes'])\n    data['리트윗'].append(tweet['stats']['retweets'])\n    data['댓글'].append(tweet['stats']['comments'])\n\n# 데이터프레임 생성 후 CSV로 저장\nimport pandas as pd\ndf = pd.DataFrame(data)\ndf.to_csv('prez.csv', index=False)\nprint(\"프리즈.csv 파일에 트윗이 저장되었습니다.\")\n```\n\n# 단계 3: 데이터 분석\n\n데이터셋을 사용하여 선호하는 데이터 분석 도구인 판다스, 맷플롯립 또는 다른 도구를 활용하여 데이터를 분석할 수 있습니다.\n\n## 예시 분석: 감성 분석\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 TextBlob 라이브러리를 사용하여 수집된 트윗에 대한 감성 분석을 수행하는 간단한 예제입니다:\n\n```python\nimport pandas as pd\nfrom textblob import TextBlob\n\n# CSV 파일을 DataFrame으로 불러오기\ndf = pd.read_csv('prez.csv')\n\n# 감성 분석 수행\ndf['Sentiment'] = df['text'].apply(lambda tweet: TextBlob(tweet).sentiment.polarity)\n\n# 처음 몇 행 표시\nprint(df.head())\n\n# 감성 분석 결과 플롯하기\ndf['Sentiment'].plot(kind='hist', title='트윗 감성 분석 결과')\n```\n\n# 결론\n\nntscraper를 사용하면 실시간 데이터 분석을 위해 트윗을 수집하는 것이 이전보다 더 쉬워졌습니다. 이 도구는 Twitter 데이터에 대한 접근을 민주화시키며, 데이터 분석가와 데이터 과학자들이 API 복잡성을 다루는 대신 인사이트를 추출하는 데 집중할 수 있게 합니다. 트렌드 추적, 감성 분석 수행, 시장 조사 등을 하든지, ntscraper는 데이터 분석 도구상의 중요한 자산이 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n행복한 스크래핑하세요!","ogImage":{"url":"/assets/img/2024-06-30-ScrapingTweetsforReal-TimeDataAnalysisUsingntscraper_0.png"},"coverImage":"/assets/img/2024-06-30-ScrapingTweetsforReal-TimeDataAnalysisUsingntscraper_0.png","tag":["Tech"],"readingTime":4},{"title":"Part 3 React  폴더 구조 쉽게 정리하는 방법","description":"","date":"2024-06-30 22:10","slug":"2024-06-30-Part3ReactFolderStructure","content":"\n\n# 📖 이전 파트\n\n이 시리즈의 2부는 여기에서 찾을 수 있습니다:\n\nhttps://javascript.plainenglish.io/part-2-react-naming-convention-return-signatures-for-hooks-b9e31f5e7f58\n\n가끔, 새 프로젝트를 시작하거나 애플리케이션이 성장함에 따라 파일을 어디에 둬야 할지에 대한 지침이 필요할 때가 있습니다. 이 컴포넌트를 어디에 두어야 할까요? 여기에 추가해야 할까요? 아이디어를 얻으셨죠? 만약 이미 그에 대해 헤매고 있다면, 필요한 파일을 찾는 것은 더 어려울 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 답은 더 나은 폴더 구조에 있습니다.\n\n폴더 구조는 프로젝트에서 가장 중요한 요소 중 하나입니다. 파일을 어디에 두고 어떻게 조직화할지 알아야 하며, 애플리케이션이 성장함에 따라 유용합니다. 이는 당신과 팀이 필요한 파일을 쉽게 찾을 수 있도록 합니다.\n\n각 팀의 목표는 누구나 즉시 파일을 찾을 수 있고 새 파일을 추가하거나 기존 파일을 업데이트하는 방법을 아는 것입니다.\n\n이 파트에서는 내 프로젝트에서 사용하는 폴더 구조를 탐색하고, 당신에게 더 나을 수도 있는 다른 가능한 해결책을 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# ⚙️ 폴더 구조\n\n제가 일반적으로 프로젝트를 시작할 때 사용하는 업데이트된 폴더 구조입니다:\n\n![Folder Structure](/assets/img/2024-06-30-Part3ReactFolderStructure_0.png)\n\n각 폴더를 설명해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- api\n\n이 폴더에는 애플리케이션이 수행할 모든 API 호출이 포함되어 있습니다. 백엔드에서 데이터를 가져오는 기능을 모두 넣을 곳입니다.\n\n최신 버전의 Next.js에서는 서버 액션이라는 새로운 개념이 있습니다. 이는 서버에서 데이터를 가져오거나 데이터 변경을 수행하는 함수입니다. 이를 api 폴더에 넣을 수도 있습니다.\n\n예시 구조:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![image](/assets/img/2024-06-30-Part3ReactFolderStructure_1.png)\n\nReact-Query 쿼리 및 뮤테이션을 혼합하여 Next.js 서버 동작도 구현했습니다.\n\n- assets\n\n이 폴더에는 애플리케이션이 사용할 모든 이미지, 글꼴 및 기타 에셋이 포함되어 있습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 앱에서 로컬 이미지, 폰트 및 기타 에셋이 필요한 경우가 있습니다. 여기서는 앱에서 사용할 모든 에셋을 넣을 곳입니다.\n\n예시 구조:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_2.png)\n\n- components\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 폴더에는 앱에서 사용할 모든 재사용 가능한 구성 요소가 포함되어 있습니다. 여기에는 여러 화면에서 사용할 구성 요소를 모두 넣게 됩니다.\n\n가능한 한 각 구성 요소가 \"독립적\"이 되도록 해야 합니다. 이것은 각 구성 요소가 독립적으로 존재할 수 있고 다른 구성 요소에 의존하지 않는다는 것을 의미합니다.\n\n그러나 항상 그런 것은 아닙니다. 때로는 구성 요소가 다른 구성 요소를 사용해야 하는 경우도 있습니다. 이는 일반적으로 구성 요소의 조합을 의미합니다. Button + Input과 같이 구성 요소 조합이 필요할 때는 새로운 구성 요소로 취급하고 새 폴더에 넣어야 합니다.\n\n그리고 그것을 ButtonInput 또는 다른 원하는 이름으로 지을 수 있습니다. 단지 의미가 통하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지의 구조를 가장 단순하게 만들어봤어. 이렇게 하면 필요한 컴포넌트를 더 쉽게 찾을 수 있을 거야.\n\n예시 구조:\n\n- constants\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 폴더에는 앱에서 사용할 모든 상수가 포함되어 있습니다. 상수는 앱 전체에서 변하지 않는 값입니다.\n\n예를 들어 환경 변수를 담고 있는 Environment.ts 파일을 여기에 넣을 수 있습니다.\n\n예시 구조:\n\n![Folder Structure](/assets/img/2024-06-30-Part3ReactFolderStructure_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- hooks\n\n이 폴더에는 애플리케이션이 사용할 모든 사용자 지정 React 훅이 포함되어 있습니다.\n\n예시 구조:\n\n![Hooks](/assets/img/2024-06-30-Part3ReactFolderStructure_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 제공자\n\n이 폴더에는 애플리케이션이 사용할 모든 리액트 컨텍스트 제공자가 포함되어 있습니다.\n\n컨텍스트 제공자의 구현을 하나의 파일에 모두 넣고 싶다면 hooks 폴더에 넣을 수 있습니다.\n\n예시 코드:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-30-Part3ReactFolderStructure_6.png\" /\u003e\n\n예제 구조:\n\n\u003cimg src=\"/assets/img/2024-06-30-Part3ReactFolderStructure_7.png\" /\u003e\n\n- screens\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 폴더에는 애플리케이션이 사용할 모든 화면이 포함되어 있어요.\n\n저희 애플리케이션에서는 Next.js이든 React Native이든, 보통 일종의 \"라우터\"를 가지고 있어요. 여기서 우리가 사용할 애플리케이션의 경로를 정의해요.\n\n이는 폴더 기반 라우팅으로 이뤄진 Next.js와 같은 형식일 수도 있고, 단일 파일에서 경로를 정의하는 react-router-dom과 같은 라우터 라이브러리 형식일 수도 있어요.\n\nReact는 웹, 모바일 및 데스크톱과 같은 여러 플랫폼에서 사용될 수 있기 때문에 경로를 정의하는 방식이 다를 수 있어요. 이 폴더 구조를 갖고 있으면 여전히 화면을 정의하고 사용 중인 플랫폼에 맞게 쉽게 적응시킬 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시 구조:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_8.png)\n\n- 화면 '컴포넌트\n\n이 폴더에는 화면에 특화된 모든 컴포넌트가 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 특별한 디렉토리는 \"프랙탈\" 패턴에서 영감을 받아 폴더의 무한 중첩을 만들 수 있도록 합니다.\n\n그러나 우리의 경우에는 중첩이 하나뿐이며 간단한 수준을 유지할 것입니다. `components` 디렉토리는 화면에 특정한 섹션 구성 컴포넌트를 모두 넣을 수 있는 곳입니다. \"섹션\"이라는 단어에 주목해주세요.\n\n화면 컴포넌트 폴더가 없으면:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_9.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n화면 구성 요소 폴더에 저장될 모든 구성 요소는 해당 화면에서만 사용해야 합니다. 이는 각 화면이 방대할 수 있기 때문에 코드베이스의 유지 관리성을 향상시키기 위한 것입니다.\n\n구성 요소 폴더의 구성 요소를 사용할 수 있다면 해당 구성 요소 폴더에 있어야 합니다. 그러나 해당 화면에 대해 특정한 사용자 정의가 필요하다면 화면 구성 요소 폴더에 있어야 합니다.\n\n예시 구조:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_10.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- utils\n\n이 폴더에는 애플리케이션이 사용할 유틸리티 함수들이 포함되어 있습니다.\n\n여기에는 컴포넌트 또는 화면과 관련되지 않은 모든 함수를 넣을 것입니다. 이는 애플리케이션 여러 곳에서 사용되는 함수일 수 있습니다.\n\n포매터, 발리데이터 및 다른 컴포넌트 또는 화면과 관련되지 않은 함수는 여기에 넣어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컴포넌트 폴더와 유사하게, 최대한 평면화하십시오. 이는 깊은 폴더 구조를 갖지 않아야 함을 의미합니다. 이렇게 하면 필요한 함수를 쉽게 찾을 수 있습니다.\n\n사용할 각 유틸리티 함수에 대한 폴더를 만들어서 해당 함수에 대한 테스트를 작성할 수 있도록 그룹화하십시오.\n\n예시 구조:\n\n![Folder Structure](/assets/img/2024-06-30-Part3ReactFolderStructure_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 💡 다른 폴더 구조 아이디어\n\n우리는 문제를 해결하는 여러 가지 방법이 있다는 것을 알 수 있습니다. 폴더 구조도 마찬가지입니다. 그래서 여러분에게 더 나은 해결책일 수도 있는 다른 가능한 솔루션을 탐색할 수 있는 이 섹션을 마련했습니다.\n\n- 원자 디자인\n\n원자 디자인은 디자인 시스템을 만드는 데 도움이 되는 방법론입니다. UI를 더 작은 구성 요소로 나누는 방법입니다. 컴포넌트는 원자, 분자, 유기체, 템플릿 및 페이지로 나누어집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 예시 구조입니다:\n\n![이미지](/assets/img/2024-06-30-Part3ReactFolderStructure_12.png)\n\n[링크](https://bradfrost.com/blog/post/atomic-web-design/)\n\n- 기능 기반\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n피처 기반은 애플리케이션의 기능에 따라 파일을 구성하는 방법입니다. 많은 기능을 갖춘 대형 애플리케이션의 경우 파일을 잘 구성하는 방법 중 하나입니다.\n\n예시 구조:\n\n![폴더 구조](/assets/img/2024-06-30-Part3ReactFolderStructure_13.png)\n\n각 폴더는 해당 기능과 관련된 모든 컴포넌트, 훅, 그리고 다른 파일들을 포함하게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 좋은 커뮤니티 토론이 있어요:\n\n[커뮤니티 링크](https://community.redwoodjs.com/t/how-to-use-feature-based-folders-structure-instead-type-based/2980/7)\n\n- 도메인 기반\n\nFeature-based와 유사하게, 도메인 기반은 당신의 응용프로그램의 도메인을 특징이 아닌 파일들을 구성하는 방법입니다. 이 방법은 여러 도메인이 있는 대규모 응용프로그램의 파일을 구성하는 좋은 방법입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 예시 구조입니다. \n\n\n![folder structure](/assets/img/2024-06-30-Part3ReactFolderStructure_14.png)\n\n\n각 폴더는 해당 도메인과 관련된 모든 컴포넌트, 훅, 그리고 다른 파일을 포함하고 있습니다.\n\n## 🚀 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로젝트에서 파일을 구성하는 다양한 방법이 있음을 볼 수 있어요. 프로젝트에서 사용할 폴더 구조에 대해 생각을 많이 하면 좋은 일이에요. 이렇게 하면 당신과 팀원들이 필요한 파일을 쉽게 찾을 수 있게 도와줄 거예요.\n\n저는 주로 제 프로젝트에서 React를 사용하는데, 그래서 이 글에서는 주로 React 예시를 보여드리고 있어요. 하지만 다른 프레임워크로도 이를 적용할 수 있을 것이라 확신해요.\n\n언제든지 궁금한 점이나 제안이 있으면 아래 댓글을 남겨주세요. 당신의 이야기를 듣는 걸 무척이나 기대하고 있어요.\n\n읽어주셔서 감사해요. 이 글이 여러분의 여정에 도움이 되길 바래요! ❤️\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쉽게 설명한 것에 오신 것을 환영합니다! 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 필자를 박수로 격려하고 팔로우해 주세요 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-30-Part3ReactFolderStructure_0.png"},"coverImage":"/assets/img/2024-06-30-Part3ReactFolderStructure_0.png","tag":["Tech"],"readingTime":12},{"title":"최신 프론트엔드 기술 비교 React vs Vuejs","description":"","date":"2024-06-30 22:09","slug":"2024-06-30-Front-EndTechnologiesReactvsVuejs","content":"\n\n알맞은 프론트엔드 기술을 선택하는 것은 효율적이고 확장 가능한 웹 애플리케이션을 개발하는 데 중요합니다. 현대 웹 개발 환경에서 인기 있는 두 프레임워크는 React와 Vue.js입니다. 이 글은 ReactJS와 Vue.js 사이의 주요 차이점을 밝히고 있습니다.\n\n## React: 사용자 인터페이스를 구축하기 위한 라이브러리\n\nReact는 Facebook에서 개발한 JavaScript 라이브러리로 사용자 인터페이스를 구축하는 데 중점을 둡니다. 재사용 가능한 UI 구성 요소를 만드는 데 초점을 두고 있습니다.\n\n## React의 주요 기능\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Component-Based Architecture: 자체 상태를 관리하는 캡슐화된 구성 요소를 구축하여 개발을 더 모듈화하고 유지 관리할 수 있습니다.\n- Virtual DOM: 변경된 부분만 업데이트하여 성능을 향상시킵니다.\n- JSX Syntax: JavaScript 내에서 HTML과 유사한 구문을 작성할 수 있어 코드를 읽고 이해하기 쉽게 만들고 디버깅하기 용이하게 합니다.\n\n## Vue.js: 점진적인 JavaScript 프레임워크\n\nVue.js는 사용자 인터페이스를 구축하기 위한 점진적인 프레임워크로 Evan You가 만들었습니다. 점진적인 채택이 가능하도록 설계된 이 프레임워크는 간단함과 쉬운 통합에 중점을 두고 있습니다.\n\n## Vue.js의 주요 기능:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 반응형 데이터 바인딩: 기본 데이터가 변경될 때 DOM을 자동으로 업데이트합니다.\n- 컴포넌트 기반 아키텍처: React와 유사하게 재사용 가능한 컴포넌트를 구축할 수 있습니다.\n- 단일 파일 컴포넌트: HTML, CSS 및 JavaScript를 한 파일에 캡슐화하여 코드베이스를 관리하기 쉽게 합니다.\n\n## 비교 요약\n\n- 학습 곡선: Vue.js는 일반적으로 학습하기 쉽고 시작하기 쉬우므로 초보자에게 이상적입니다. JSX 구문과 더 복잡한 설정으로 React는 더 가파른 학습 곡선을 가지고 있습니다.\n- 유연성: React는 응용 프로그램을 구조화하고 다른 라이브러리와 통합하는 방법에 대해 더 많은 유연성을 제공하지만, Vue.js는 더 직관적이고 통합된 접근 방식을 제공합니다.\n- 성능: 두 프레임워크 모두 성능이 우수하지만, React의 가상 DOM은 효율적인 업데이트와 렌더링을 제공합니다. Vue.js도 반응형 데이터 바인딩으로 좋은 성능을 제공합니다.\n\n## 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결론적으로, React와 Vue.js는 각각의 장점을 가지고 있는 강력한 프론트엔드 기술입니다. React는 유연성, 성능, 그리고 다양한 생태계로 인해 크고 복잡한 프로젝트에 적합하다는 점에서 선호됩니다. Vue.js는 간결함, 통합의 용이성, 그리고 접근하기 쉬운 학습 커브로 인해 빠른 개발과 작은 프로젝트에 이상적이라는 점이 인정받고 있습니다. 두 기술 중 어느 것을 선택할지는 특정 프로젝트 요구사항과 개인적인 취향에 따라 다를 것입니다.\n\n웹 개발을 배우거나 JavaScript 프레임워크 중 하나에 대한 지식을 향상시키고 싶다면 https://hng.tech/internship 또는 https://hng.tech/premium을 방문해보세요.","ogImage":{"url":"/assets/img/2024-06-30-Front-EndTechnologiesReactvsVuejs_0.png"},"coverImage":"/assets/img/2024-06-30-Front-EndTechnologiesReactvsVuejs_0.png","tag":["Tech"],"readingTime":3},{"title":"Tornado Cash 소스 코드를 통해 알아보는 영지식 증명 이해하기","description":"","date":"2024-06-30 22:07","slug":"2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash","content":"\n\n## 제로지식증명으로 스마트 컨트랙트 세계로 뛰어들어 보세요\n\n![image](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_0.png)\n\n위키피디아에 따르면, 제로지식증명(ZKP)의 정의는 다음과 같습니다:\n\n제로지식증명(ZKP) 기술은 블록체인과 같은 공개적인 데이터베이스에서 해결하기 어려운 익명 투표 또는 익명 금전 송금과 같은 여러 다양한 분야에 널리 사용될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n토네이도 캐시는 이더리움 트랜잭션을 익명화할 수 있는 코인 믹서입니다. 블록체인의 논리로 인해 모든 트랜잭션은 공개적이기 때문에 자신의 계정에 이더리움이 있다면 누구나 블록체인에서 트랜잭션 기록을 따라갈 수 있습니다. 토네이도 캐시와 같은 코인 믹서는 ZKP를 사용하여 출처와 목적지 주소 사이의 체인 상의 연결을 끊어 개인 정보 보호 문제를 해결할 수 있습니다.\n\n트랜잭션 중 하나를 익명화하려면 토네이도 캐시 계약에 소량의 이더리움(또는 ERC20 토큰)을 예치해야 합니다(예: 1 ETH). 잠시 후 다른 계정으로 이 1 ETH를 인출할 수 있습니다. 핵심은 누구도 예치 계정과 인출 계정 사이에 연결을 만들 수 없다는 점입니다. 수백 개의 계정이 한 쪽에 1 ETH를 예치하고 다른 수백 개의 계정이 다른 쪽에서 1 ETH를 인출하면 자금 이동 경로를 추적할 수 없습니다. 기술적인 과제는 스마트 계약 트랜잭션도 이더리움 네트워크의 다른 모든 트랜잭션과 마찬가지로 공개적이라는 것입니다. 여기서 ZKP가 관련될 때가 됩니다.\n\n계약에 1 ETH를 예치할 때 \"커밋먼트\"를 제공해야 합니다. 이 커밋먼트는 스마트 계약에 저장됩니다. 다른 쪽에서 1 ETH를 인출할 때는 \"널리파이어\"와 제로 지식 증명을 제공해야 합니다. 널리파이어는 커밋먼트와 관련이 있는 고유한 ID이며, ZKP는 이 연결을 증명하지만 어떤 널리파이어가 어떤 커밋먼트에 할당되어 있는지는 아무도 모릅니다(예외는 예금자/인출 계정의 소유주).\n\n한번 더 말씀드리면: 우리는 커밋먼트가 우리의 널리파이어에 할당되어 있다는 것을 증명할 수 있습니다. 본인의 커밋먼트를 공개하지 않고요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스마트 계약으로 널리파이어를 추적하므로 한 번에 예금한 ETH를 하나의 널리파이어로만 인출할 수 있습니다.\n\n쉬워보이죠? 그렇지 않아요! :) 이제 기술의 심연으로 들어가 봅시다. 하지만 무엇보다도 또 다른 tricky한 요소, Merkle tree를 이해해야 합니다.\n\n![Merkle tree](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_1.png)\n\nMerkle tree는 잎이 요소인 해시 트리로, 모든 노드가 자식 노드의 해시인 구조입니다. 트리의 루트는 Merkle root로, 전체 요소 집합을 나타냅니다. 트리에서 어떤 요소(잎)를 추가, 제거 또는 변경하면 Merkle root가 변경됩니다. Merkle root는 요소 집합의 고유 식별자입니다. 그럼 어떻게 사용할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Understanding Zero Knowledge Proofs through the Source Code of Tornado Cash](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_2.png)\n\n다른 것으로 Merkle proof라는 것이 있어요. 만약 내게 Merkle root가 있다면, 당신은 루트로 표현된 집합에 요소가 있는 것을 증명해주는 Merkle proof를 보낼 수 있어요. 아래 그림은 어떻게 작동하는지 보여줍니다. 만약 HK가 그 집합 안에 있다는 것을 나에게 증명하고 싶다면, HL, HIJ, HMNOP, HABCDEFGH 해시를 보내주어야 해요. 이 해시들을 사용하여 나는 Merkle root를 계산할 수 있어요. 만약 루트가 내 루트와 같다면, HK가 집합 안에 있는 것이에요. 어디에 사용할 수 있을까요?\n\n간단한 예시로 화이트리스트를 상상해봅시다. 오직 화이트리스트된 사용자만이 호출할 수 있는 메소드를 갖는 스마트 컨트랙트가 있다고 가정해봅시다. 문제는 화이트리스트에 있는 계정이 1000개나 되는 것이에요. 이를 스마트 컨트랙트에 저장하는 방법은 무엇일까요? 각 계정을 매핑에 저장하는 간단한 방법이 있지만, 매우 비싸요. 더 싼 해결책은 Merkle tree를 만들고 Merkle root만 저장하는 것이에요 (1개의 해시 대신 1000개의 해시는 아주 좋아요). 누군가가 그 메소드를 호출하고 싶으면, 그 지능적인 스마트 컨트랙트가 쉽게 유효성 검사할 수 있는 Merkle proof(이 경우에 10개 해시의 목록)를 제공해야 해요.\n\n한번 더 말씀드리면: Merkle tree는 하나의 해시(=Merkle root)로 원소 집합을 나타내는 데 사용됩니다. Merkle proof를 통해 원소의 존재를 증명할 수 있어요.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로 이해해야 할 것은 제로-지식 증명(ZKP) 자체입니다. ZKP를 사용하면 무언가를 알고 있다는 사실을 증명할 수 있습니다. 그러나 알고 있는 내용을 공개하지 않으면서 증명할 수 있습니다. ZKP를 생성하기 위해서는 회로가 필요합니다. 회로란 공개 입력과 출력, 그리고 비공개 입력을 가진 작은 프로그램과 같은 것입니다. 이러한 비공개 입력은 검증을 위해 공개하지 않는 정보이며, 이것이 제로-지식 증명이라 불리는 이유입니다. ZKP를 사용하면 주어진 회로와 입력에서 출력이 생성될 수 있는 것을 증명할 수 있습니다.\n\n간단한 회로는 다음과 같습니다:\n\n```js\npragma circom 2.0.0;\n\ninclude \"node_modules/circomlib/circuits/bitify.circom\";\ninclude \"node_modules/circomlib/circuits/pedersen.circom\";\n\ntemplate Main() {\n    signal input nullifier;\n    signal output nullifierHash;\n\n    component nullifierHasher = Pedersen(248);\n    component nullifierBits = Num2Bits(248);\n\n    nullifierBits.in \u003c== nullifier;\n    for (var i = 0; i \u003c 248; i++) {\n        nullifierHasher.in[i] \u003c== nullifierBits.out[i];\n    }\n\n    nullifierHash \u003c== nullifierHasher.out[0];\n}\n\ncomponent main = Main();\n```\n\n이 회로를 사용하면 주어진 해시의 원본을 알고 있다는 것을 증명할 수 있습니다. 이 회로에는 하나의 입력(널리파이어)과 하나의 출력(널리파이어 해시)가 있습니다. 입력의 기본 접근성은 비공개이며, 출력은 항상 공개입니다. 이 회로는 Circomlib에서 2개의 라이브러리를 사용합니다. Circomlib은 유용한 회로들의 집합입니다. 첫 번째 라이브러리는 비트 조작 방법을 포함하는 bitlify이며, 두 번째는 페더슨 해시를 포함하는 pedersen입니다. 페더슨 해싱은 제로-지식 증명 회로에서 효율적으로 실행할 수 있는 해싱 방법입니다. Main 템플릿의 내용에서 해시를 채우고 계산합니다. (circom 언어에 대한 자세한 정보는 circom 문서를 참조해주세요)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n영접하십시오. 제로지식 증명을 생성하려면 증명 키가 필요합니다. 이는 ZKP의 가장 민감한 부분인데, 증명 키를 생성하는 데 사용된 소스 데이터를 사용하면 누구든지 가짜 증명을 생성할 수 있습니다. 이 소스 데이터를 \"유독 폐기물\"이라고 하며, 이를 폐기해야 합니다. 이러한 이유로 증명 키 생성을 위해 \"의식\"이 있습니다. 의식에는 많은 구성원이 참여하며 각 구성원이 증명 키에 기여합니다. 악의가 없는 하나의 구성원만 있으면 유효한 증명 키를 생성할 수 있습니다. 개인 입력, 공개 입력 및 증명 키를 사용하여 ZKP 시스템은 회로를 실행하고 증명 및 출력을 생성할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_3.png)\n\n증명 키에 대한 유효성 검사용 검증 키가 있습니다. 검증 시스템은 공개 입력, 출력 및 검증 키를 사용하여 증명을 검증할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스낵제이에스는 세레모니를 통해 증명 키 및 검증 키를 생성하고 증명을 생성하며 해당 증명을 확인하는 기능을 제공하는 풀 피처드 도구입니다. 또한 검증을 위한 스마트 계약을 생성할 수 있어 다른 계약에서 제로 지식 증명을 확인하는 데 사용할 수 있습니다. 더 자세한 정보는 스낵제이에스 문서를 확인해 주세요.\n\n지금, 토네이도 캐시(TC)가 어떻게 작동하는지 이해할 수 있는 모든 것이 준비되었습니다. TC 계약에 1이더를 예금할 때 커밋먼트 해시를 제공해야 합니다. 이 커밋먼트 해시는 Merkle 트리에 저장됩니다. 다른 계정으로 이 1이더를 인출할 때는 2개의 제로 지식 증명을 제공해야 합니다. 첫 번째는 Merkle 트리에 당신의 커밋먼트가 포함됨을 증명하는 것입니다. 이 증명은 Merkle 증명의 제로 지식 증명입니다. 하지만 이것만으로 충분하지 않습니다. 당신은 이 1이더를 한 번만 인출할 수 있어야 합니다. 그래서 당신은 커밋먼트에 대한 유일한 널리파를 제공해야 합니다. 계약은 이 널리파를 저장함으로써 당신이 예금한 돈을 두 번 이상 인출하지 못하도록 보장합니다.\n\n널리파의 고유성은 커밋먼트 생성 방법에 의해 보장됩니다. 커밋먼트는 널리파와 비밀을 해싱하여 생성됩니다. 널리파를 변경하면 커밋먼트도 변경되기 때문에 하나의 널리파는 하나의 커밋먼트에만 사용할 수 있습니다. 해싱의 단방향성으로 인해 커밋먼트와 널리파를 연결할 수는 없지만 이에 대한 제로 지식 증명을 생성할 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이론을 이해한 후에는 TC의 인출 회로가 어떻게 생겼는지 살펴보겠습니다:\n\n```js\ninclude \"../node_modules/circomlib/circuits/bitify.circom\";\ninclude \"../node_modules/circomlib/circuits/pedersen.circom\";\ninclude \"merkleTree.circom\";\n// Pedersen(nullifier + secret)를 계산합니다.\ntemplate CommitmentHasher() {\n    signal input nullifier;\n    signal input secret;\n    signal output commitment;\n    signal output nullifierHash;\n    component commitmentHasher = Pedersen(496);\n    component nullifierHasher = Pedersen(248);\n    component nullifierBits = Num2Bits(248);\n    component secretBits = Num2Bits(248);\n    nullifierBits.in \u003c== nullifier;\n    secretBits.in \u003c== secret;\n    for (var i = 0; i \u003c 248; i++) {\n        nullifierHasher.in[i] \u003c== nullifierBits.out[i];\n        commitmentHasher.in[i] \u003c== nullifierBits.out[i];\n        commitmentHasher.in[i + 248] \u003c== secretBits.out[i];\n    }\n    commitment \u003c== commitmentHasher.out[0];\n    nullifierHash \u003c== nullifierHasher.out[0];\n}\n// 주어진 비밀과 널리파에 해당하는 묵사가 예금의 Merkle tree에 포함되어 있는지 확인합니다.\ntemplate Withdraw(levels) {\n    signal input root;\n    signal input nullifierHash;\n    signal private input nullifier;\n    signal private input secret;\n    signal private input pathElements[levels];\n    signal private input pathIndices[levels];\n    component hasher = CommitmentHasher();\n    hasher.nullifier \u003c== nullifier;\n    hasher.secret \u003c== secret;\n    hasher.nullifierHash === nullifierHash;\n    component tree = MerkleTreeChecker(levels);\n    tree.leaf \u003c== hasher.commitment;\n    tree.root \u003c== root;\n    for (var i = 0; i \u003c levels; i++) {\n        tree.pathElements[i] \u003c== pathElements[i];\n        tree.pathIndices[i] \u003c== pathIndices[i];\n    }\n}\ncomponent main = Withdraw(20);\r\n```\n\n첫 번째 템플릿은 CommitmentHasher입니다. 널리파 와 시크릿이라고하는 두 개의 랜덤한 248비트 숫자를 입력으로 사용합니다. 템플릿은 널리 파해시 및 커밋먼트 해시를 계산합니다. 이는 널리파와 시크릿의 해시입니다.\n\n두 번째 템플릿은 Withdraw 자체입니다. 해당 템플릿에는 Merkle 루트와 널리 파 해시와 같은 2개의 공개 입력이 있습니다. Merkle root는 Merkle proof를 확인하기 위해 필요하며, 널리파 해시는 스마트 계약에서 저장해야 합니다. 개인 입력 매개 변수는 널리파, 시크릿 및 Merkle proof의 pathElements 및 pathIndices입니다. 회로는 널리파를 검사하여 해당 스마트 계약에서 커밋먼트를 생성하고 지정된 Merkle proof를 검사합니다. 모든 것이 정상이면 TC 스마트 계약에서 확인할 수 있는 제로 지식 증명이 생성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저장소의 contracts 폴더에서 스마트 계약을 찾을 수 있어요. Verifier는 회로에서 생성돼요. Tornado 계약에서는 주어진 널리파 해시 및 Merkle 루트의 ZKP를 확인하는 데 사용돼요.\n\n계약을 사용하는 가장 쉬운 방법은 명령줄 인터페이스를 사용하는 거예요. 이 인터페이스는 JavaScript로 작성되었으며 소스 코드가 비교적 간단해요. 여기에서 매개변수와 ZKP가 생성되고 스마트 계약을 호출하는 데 사용되는 곳을 쉽게 찾을 수 있어요.\n\n제로지식증명은 암호화 세상에서 비교적 새로운 기술이에요. 그 뒤에 숨어있는 수학은 정말 복잡하고 이해하기 어려운데, snarkjs와 circom과 같은 도구를 사용하면 쉽게 사용할 수 있어요. 이 기술에 대해 이 기사가 도움이 되었으면 좋겠어요. 다음 프로젝트에서 ZKP를 사용할 수 있게 되길 바라요.\n\n즐거운 코딩 하세요...\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n업데이트: 해당 주제에 대한 새로운 기사가 있어요:\n\n그리고 Tornado Cash의 소스 코드를 기반으로 한 익명 투표를 위한 JavaScript 라이브러리를 만드는 방법에 대한 또 다른 기사가 있습니다. circom, Solidity 및 JavaScript 코드를 사용한 단계별 자습서입니다:\n\n그리고 이를 기반으로한 투표 시스템을 어떻게 만들었는지 설명하고 있어요:","ogImage":{"url":"/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_0.png"},"coverImage":"/assets/img/2024-06-30-UnderstandingZero-KnowledgeProofsThroughtheSourceCodeofTornadoCash_0.png","tag":["Tech"],"readingTime":11},{"title":"React와 Nextjs 프론트엔드 기술 비교 2024년 최신 분석","description":"","date":"2024-06-30 22:06","slug":"2024-06-30-ComparingReactandNextjsFrontendTechnology","content":"\n\n프론트엔드 개발은 지속적으로 발전 중이며, 이 공간에서 두 가지 중요 기술은 React와 Next.js입니다. 이 기사에서는 React와 Next.js를 비교하여 각각의 차이점, 강점, 그리고 약점을 강조해보겠습니다. 추가로, HNG 인턴십에 대한 기대와 React와 함께 일할 때의 생각을 공유할 것입니다.\n\n# React란?\n\n# React의 장점\n\n1. 컴포넌트 기반 아키텍처:\n- 코드 재사용성: React의 컴포넌트 기반 아키텍처는 재사용성을 촉진하여 코드를 더 쉽게 유지하고 확장할 수 있도록 합니다.\n- 모듈화: 컴포넌트는 독립적으로 개발, 테스트, 및 배포될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 가상 DOM:\n- 성능: 가상 DOM은 실제 DOM을 직접 조작하는 것을 최소화하여 UI를 업데이트할 때 더 나은 성능을 제공합니다.\n- 효율성: React는 애플리케이션 상태 변경 시 필요한 구성 요소만 효율적으로 업데이트하고 렌더링합니다.\n\n3. 생태계 및 커뮤니티:\n- 거대한 커뮤니티: React에는 방대하고 활발한 커뮤니티가 있어 다양한 리소스, 라이브러리 및 도구를 제공합니다.\n- 다양한 생태계: 라우팅을 위한 React Router와 상태 관리를 위한 Redux와 같은 도구들로 React는 복잡한 애플리케이션을 구축하기 위한 포괄적인 생태계를 제공합니다.\n\n# React의 단점\n\n- JSX 구문: React의 JSX 구문은 새로운 개발자들에게 익숙하지 않을 수 있어 익히는 기간이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- **상태 관리**: 대규모 애플리케이션에서 상태를 관리하는 것은 복잡해질 수 있으며 때로는 Redux나 Context API와 같은 추가 라이브러리를 사용해야 하는 경우도 있습니다.\n\n- **설정 및 구성**: React 프로젝트는 종종 Webpack이나 Babel과 같은 빌드 도구를 포함한 상당한 설정 및 구성이 필요합니다.\n\nNext.js는 Vercel에서 개발한 React 프레임워크입니다. 서버 측 렌더링(SSR), 정적 사이트 생성(SSG) 및 기타 강력한 기능을 제공하여 생산 준비가 된 애플리케이션을 구축하는 강력한 솔루션을 제공합니다.\n\n# Next.js의 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `서버 측 렌더링: SSR은 서버에서 페이지를 렌더링하여 초기 로드 시간을 단축하고 SEO를 향상시킴으로써 성능을 향상시킵니다.\n- `정적 사이트 생성: SSG는 빌드 시간에 정적 HTML을 생성하여 최적의 성능과 확장성을 제공합니다.\n\n- `내장 라우팅: Next.js는 파일 기반 라우팅 시스템을 제공하여 동적 경로를 쉽게 만들 수 있는 기능을 제공합니다.\n\n- `API Routes: Next.js를 통해 동일한 프로젝트 내에서 API 경로를 생성할 수 있어 전체 스택 개발이 용이해집니다.\n\n# Next.js의 단점\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `SSR`과 `SSG`: `SSR`과 `SSG`를 이해하고 효과적으로 활용하기 위해서는 특히 이 개념에 새로운 개발자들에게는 추가적인 학습이 필요할 수 있습니다.\n\n간단한 애플리케이션의 경우, Next.js는 일반적인 React 설정에 비해 불필요한 복잡성과 오버헤드를 도입할 수 있습니다.\n\n# HNG 인턴십에 대한 기대\n\nHNG 인턴십에 참여하며, 협력적이고 빠른 학습 환경에 몰입하는 것을 고대합니다. 이 프로그램을 통해 실제 프로젝트에 참여하고, 기술을 향상시키며 실무 경험을 쌓을 수 있는 환상적인 기회가 될 것으로 믿습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# HNG에서 React 작업하기\n\nReact는 사용자 인터페이스를 구축하는 강력하고 널리 사용되는 라이브러리입니다. 인턴십 기간 동안 React의 이해를 더 깊이 파고들게 되어 정말 기쁩니다.\n\nReact의 기능을 숙달하고, 최고의 실천 방법을 탐구하며, 영향력 있는 프로젝트에 기여하는 것을 기대하고 있습니다.\n\nHNG 인턴십에 대해 더 알아보려면,\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n방문해보세요: https://hng.tech/internship\n\n만약 재능있는 개발자를 채용하려고 한다면,\n\nHNG Hire를 확인해보세요: https://hng.tech/hire\n\nOR\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://hng.tech/premium\n\n# 결론\n\nReact와 Next.js는 각각 독특한 장점을 가지고 있습니다. React의 유연성과 광범위한 생태계는 동적 사용자 인터페이스를 구축하는 인기 있는 선택지이며, Next.js의 서버 측 렌더링과 정적 사이트 생성과 같은 제품 준비 기능은 향상된 성능과 개발자 경험을 제공합니다. \n\nHNG 인턴십 여정을 시작하면서 이러한 기술을 활용하고, 기술을 향상시키며 혁신적인 해결책에 기여하고자 합니다. 프론트엔드 개발의 미래는 밝으며, 그 중 일부가 되고 싶습니다.","ogImage":{"url":"/assets/img/2024-06-30-ComparingReactandNextjsFrontendTechnology_0.png"},"coverImage":"/assets/img/2024-06-30-ComparingReactandNextjsFrontendTechnology_0.png","tag":["Tech"],"readingTime":5},{"title":"Python을 사용하여 GitHub 개발 활동 분석하는 방법","description":"","date":"2024-06-30 22:01","slug":"2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython","content":"\n\n\u003cimg src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png\" /\u003e\n\nGitHub 개발 데이터는 특정 프로젝트나 회사의 전체 활동을 평가하려는 기관, 투자자, 경쟁업체에게 소중한 통찰을 제공합니다. 이 데이터를 분석함으로써 이해관계자들은 특정 시간대의 최고 기여자를 식별하고 가장 활발한 저장소를 파악하며 프로젝트의 단계별 목표와 활동 수준 사이의 관계를 발견할 수 있습니다.\n\n다음 글에서는 web3 생태계의 여섯 개의 오픈 소스 AI 프로젝트의 GitHub 개발 데이터를 살펴보겠습니다. 이들은 다음과 같습니다:\n\n- Ocean Protocol: 이 프로젝트는 암호화폐 가격 예측 알고리즘부터 데이터 과학 도전과 시장을 위한 다양한 솔루션을 보유하고 있습니다.\n- Bittensor: 이 프로젝트는 탈중앙화된 컴퓨팅으로 AI 민주화를 목표로 하는 모듈식 아키텍처를 가지고 있습니다.\n- Fetch.ai: 이 프로젝트는 SDK를 사용하여 AI 기반 프로젝트를 통해 개발자들이 수익을 창출할 수 있도록 합니다.\n- Numerai: 이 프로젝트는 주식 시장 예측 토너먼트를 주최하며 우승자에게 토큰을 보상합니다.\n- Oraichain: AI의 다차원 신뢰도를 검증하고 독특한 AI 오라클을 활용하여 Web3 애플리케이션을 구축하기 위한 IBC 활성화된 Layer 1입니다.\n- SingularityNET: 이 프로젝트의 임무는 탈중앙화 방식으로 인공 일반 지능(AGI)을 개발하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPython을 사용하여 분석을 진행하기 위해 위에서 언급한 각 프로젝트에 대한 GitHub의 공개 데이터를 활용할 것입니다. 데이터 조작 및 정리에는 Pandas를 사용하고, 시각화에는 Matplotlib 및 Seaborn을 활용하여 가치 있는 통찰을 제공하는 정보적인 차트를 생성할 것입니다. 커밋 빈도, 저장소 생성, 개발자 참여 등과 같은 주요 메트릭을 조사함으로써 개발 참여 수준이 프로젝트 성공의 신뢰할 수 있는 지표인지를 평가할 수 있습니다.\n\n저희의 분석은 GitHub에서의 개발 활동의 중요성과 해당 활동이 이해관계자, 투자자, 경쟁 업체에게 가치 있는 통찰을 제공할 수 있다는 점을 탐색하는 데서 시작할 것입니다. 그 다음으로, 개발 활동에 대한 시간적 분석을 탐구한 다음, 커밋 빈도를 기준으로 프로젝트를 순위 매기겠습니다. 또한 가장 활발하게 활동하는 개발자를 식별하고 순위를 매기며, 주목받는 저장소도 확인하여 각 프로젝트의 역학을 포괄적으로 이해할 수 있도록 할 것입니다.\n\n# GitHub의 개발 활동 데이터의 중요성\n\n개발 활동을 연구하는 것이 왜 중요한지 궁금하다면, 이 섹션에서 이해관계자, 투자자 및 경쟁사에게 특히 중요할 수 있는 몇 가지 핵심 요소를 강조하겠습니다. 함께 살펴보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 이해관계자들\n\n- 프로젝트 건강 및 진행 상황에 대한 통찰력을 얻을 수 있습니다: 이해관계자들은 프로젝트가 활발히 개발되고 있는지, 어떤 기능이 우선 순위에 있는지 이해할 수 있습니다.\n- 프로젝트 역학 이해하기: 시간적 분석을 통해 이해관계자들은 프로젝트 수명주기를 이해하고 중요한 진전 또는 정체 기간을 식별할 수 있습니다. 또한 프로젝트의 주요 이정표들과의 상관 관계를 파악하는 데 도움이 됩니다.\n- 개발자 성과 평가: 많은 커밋 수는 언제나 생산성이 높다는 것을 의미하는 것은 아니지만, 이는 이해관계자들이 개발자의 참여 정도를 이해하고, 그가 회사의 건강한 성장에 기여하는지를 이해하는 데 좋은 지표입니다.\n\n## 투자자들\n\n- 안내된 투자 결정: 커밋 빈도 및 활동 트렌드를 분석함으로써, 투자자들은 활발히 개발되고 유지되는 유망한 프로젝트를 식별할 수 있습니다. 높은 개발 활동은 투자 수익 가능성에 대한 긍정적인 신호가 될 수 있습니다.\n- 프로젝트 장기성 이해하기: 시간적 분석을 통해 투자자들은 프로젝트의 지속 가능성과 장기적 잠재력을 평가할 수 있습니다.\n- 개발자 품질: 개발자들의 활동 및 GitHub 프로필을 알게 되면 투자자들은 프로젝트 뒤에 있는 재능을 볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 경쟁사\n\n- 경쟁 전략 수립: 경쟁사는 경쟁 프로젝트의 개발 활동을 분석하여 그들의 장단점을 이해할 수 있습니다. 이 정보를 활용하여 경쟁사를 앞서가는 전략을 개발할 수 있습니다.\n- 트렌드 파악: 개발 활동의 시계열 분석을 통해 경쟁사는 시장 트렌드를 식별하고 그에 맞게 전략을 조정할 수 있습니다. 어떤 저장소가 가장 많은 관심을 받고 있는지 파악함으로써 경쟁사는 주목받고 있는 분야에 초점을 맞출 수 있습니다.\n\n전반적으로, GitHub 개발 활동을 연구함으로써 이해당사자, 투자자, 경쟁사 및 다른 이야기에서 언급되지 않은 당사자들에게 맞춤형 통찰력을 제공하여 각 그룹이 정보에 근거한 결정을 내리고 소프트웨어 개발 생태계에서 경쟁력을 유지할 수 있도록 도와줍니다.\n\n# 시간별 개발자 활동 분석\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 각 프로젝트의 시간 경과에 따른 커밋 수와 참여자 수를 조사할 것입니다. 데이터 포인트가 매일 표시하기에 너무 많기 때문에 대신 주간 보기를 사용할 것입니다. 차트에서 범례의 각 색깔은 서로 다른 연도에 해당합니다. 우리는 활동의 증가와 주요 프로젝트 이정표간의 연결을 살펴볼 것이며, 시간이 흐름에 따라 개발 강도가 어떻게 변하는지 확인할 것입니다.\n\n## Bittensor\n\n\u003cimg src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_1.png\" /\u003e\n\n위의 Bittensor 차트에서 시간이 흐름에 따라 개발 활동이 점차 증가하는 것을 볼 수 있습니다. 2023년이 가장 많은 커밋과 다른 참여자 수가 있었던 해로, 거의 50명의 개발자가 Bittsensor의 저장소에서 업그레이드를 진행했습니다. 2024년에 관한 데이터가 충분치 않지만, 이미 개발이 크게 감소하고 참여자 수도 줄어든 것을 볼 수 있으며, 이는 2019년과 거의 동일합니다. 그렇지만 우리는 몇몇 중요한 커밋 피크를 볼 수 있습니다. 주로 연도의 처음 4주와 11, 12주쯤에 발생합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 1월 17일쯤에 Bittsensor의 토큰 $TAO가 상승한 상위 그룹에 속했다는 기사를 찾을 수 있습니다. 이때가 2024년의 첫 번째 정점이 있는 시기와 비슷합니다. 그러나 토큰의 가격은 개발 활동과 항상 상관관계가 있는 것은 아니므로, 차트에서 가장 큰 정점은 2023년 말에 발생했으며, 이 기간 동안 큰 상승 추세가 없었습니다.\n\n## Fetch.ai\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_2.png)\n\nFetch.ai 차트는 Bittensor의 차트와 매우 다릅니다. 개발 활동은 주로 2017년부터 2021년 사이에 발생한 것을 볼 수 있습니다. 회사는 2017년에 설립되었고 2019년에 출시되었지만, 개발은 2014년에 더 빨리 시작된 것으로 보입니다. 커밋의 주요 정점은 출시의 거의 1년 전인 2018년 중반에 있습니다. GitHub 기여자 수는 2019년에 증가하며, 해당 해에 가장 큰 정점을 나타냅니다. 그 후 바로 2020년 1월 1일에 회사는 메인넷에서 출시되었습니다. 이 이벤트는 2019년 후반에 보다 많은 기여자와 커밋과 관련이 있을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지 개발은 지난 세 년 동안 감소하는 것으로 보이지만, 2024년에는 참여자 수와 커밋 수가 약간 상승하는 추세를 보입니다.\n\n## Numerai\n\n![Numerai](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_3.png)\n\nNumerai의 전반적인 개발 활동은 크지 않습니다. 2017년과 2021년에는 몇 가지 의미있는 정점이 있습니다. 또한 참여자/기여자 수가 다른 프로젝트와 달리 커밋 수와 관련이 없어 보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2021년의 고점이 Numerai 네트워크 발표와 관련이 있을 수 있습니다. 이 기사에서는 CLI의 업데이트와 예측 노드 구현이 언급되었습니다.\n\n## Ocean Protocol\n\n![Ocean Protocol](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_4.png)\n\nOcean Protocol 팀은 몇 년 동안 꾸준히 높은 커밋 수를 보여주었으며, 300개 이상의 커밋을 넘는 고점이 있었습니다. 이러한 커밋 고점과 참여자 또는 기여자 수 사이에 상관 관계가 있는 것으로 보이지만, 모든 경우에 일관되게 관찰되는 것은 아닙니다. 그러나 2022년에는 분명한 상관 관계가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPredictoor는 2023년 9월 12일 경부 출시되었습니다 (37주차), 이 날짜 이전에는 개발에서 상당한 피크가 있었는데, 이는 해당 이벤트와 관련이 있을 수 있습니다.\n\n가장 큰 피크는 2020년 41주에서 43주에 발생했는데, 바로 Ocean Protocol V3가 출시된 후였습니다. 이에 관한 기사를 확인할 수 있습니다:\n\n2024년에는 2023년과 비교했을 때 개발 활동이 현저히 감소했으며, 저장소에서 활발히 작업하는 기여자 수도 감소했습니다. 그러나 이는 반드시 전체 연도에 대한 지속적인 추세를 나타내지는 않을 수 있습니다. 2020년과 마찬가지로, 개발 면에서는 천천히 시작되었지만 연말에는 급증세를 지켜볼 수 있을 것입니다.\n\n## Oraichain\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_5.png)\n\nOraichain Labs 차트를 보면 커밋 수와 참여자/기여자 수 사이에 명확한 상관 관계가 있는 것을 볼 수 있습니다. 2020년 말에 개발이 속도를 내며, 이는 2021년 2월의 공식 발표와 관련이 있을 수 있습니다.\n\n2023년은 개발에서 가장 활발한 해로, 이 추세가 2024년으로 이어지고 있습니다. 이 급증은 해커톤, 지갑 업데이트 및 통합과 같은 중요한 프로젝트 이정표를 반영하고 있습니다. 상대적으로 새로운 프로젝트이기 때문에, 특히 최근 몇 주간 다른 AI 프로젝트들보다 더 높은 개발 강도를 보여주고 있습니다.\n\n## 싱귤러리티넷\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_6.png)\n\n이 차트는 SingularityNET의 개발이 2018년부터 2020년 사이에 정점에 이른 것을 보여줍니다. 이후 커밋 활동 및 기여자 수가 감소하는 추세를 보였습니다. 이 기사에 따르면, 백엔드 소프트웨어는 2019년에 성숙기에 이르렀으며 이는 또한 가장 많은 개발이 이루어진 해입니다.\n\n2024년에는 2023년과 비교했을 때 개발이 증가하는 것을 볼 수 있습니다. 이는 2018년부터 2020년 사이와 유사한 고개발의 새로운 이후를 나타낼 수 있습니다.\n\n# 시간에 따른 개발자 활동 분석 (코드)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제공된 데이터셋은 즉시 분석에 사용할 수 있는 상태가 아니라 데이터 조작 기술을 적용하여 작업해야 합니다. 먼저 각 행별로 데이터셋에서 의미 있는 정보를 추출하고, 분석을 위해 다른 정리된 데이터프레임을 생성하기 위해 두 가지 함수를 만듭니다.\n\n```js\nimport pandas as pd\n\ndef process_commits_row(row):\n    \"\"\" 이 함수는 데이터셋의 각 행에서 의미 있는 정보를 추출하여 딕셔너리로 반환합니다. 'repo' 변수가\n    나중에 저장소 데이터셋과 병합하는 데 사용됨에 유의하세요. \"\"\"\n    repo = \\\n        row['url'].split('repos')[1].split('commits')[0].split(\"/\")[-2]\n    return {\n        'sha': row['sha'],\n        'repo': repo,\n        'node_id': row['node_id'],\n        'author': row['commit']['author']['name'],\n        'date': row['commit']['author']['date'],\n        'message': row['commit']['message']}\n\ndef gen_df_commits_filt(df):\n    \"\"\" 이 함수는 데이터셋을 반복하면서 'process_commits_row' 함수를 각 행에 적용합니다. 결과는\n    딕셔너리의 목록으로 반환되어 최종적으로 DataFrame으로 반환됩니다. \"\"\"\n    all_features = []\n    for row in df.iterrows():\n        for i in range(1, len(row[1]) - 1):\n            try:\n                all_features.append(process_commits_row(row[1][i]))\n            except Exception:\n                pass\n    return pd.DataFrame(all_features)\n```\n\n위의 함수들은 각 프로젝트의 커밋 데이터셋을 대상으로 합니다. 이 두 함수를 함께 사용하여 sha, repo, node_id, author, date 및 message의 특징을 가진 필터링된 데이터프레임을 생성합니다. 그런 다음 데이터셋을 호출하고 각각의 데이터셋에 gen_df_commits_filt() 함수를 적용할 수 있습니다.\n\n```js\n# 데이터셋 호출\ndf_commits_bittensor = pd.read_json('datasets/bittensor_commits.json')\ndf_commits_fetchai = pd.read_json('datasets/fetchai_commits.json')\ndf_commits_numerai = pd.read_json('datasets/numerai_commits.json')\ndf_commits_ocean = pd.read_json('datasets/oceanprotocol_commits.json')\ndf_commits_oraichain = pd.read_json('datasets/oraichain_commits.json')\ndf_commits_singular = pd.read_json('datasets/singularitynet_commits.json')\n\n# 데이터셋 필터링\ndf_commits_bittensor_filt = gen_df_commits_filt(df_commits_bittensor)\ndf_commits_fetchai_filt = gen_df_commits_filt(df_commits_fetchai)\ndf_commits_numerai_filt = gen_df_commits_filt(df_commits_numerai)\ndf_commits_ocean_filt = gen_df_commits_filt(df_commits_ocean)\ndf_commits_oraichain_filt = gen_df_commits_filt(df_commits_oraichain)\ndf_commits_singular_filt = gen_df_commits_filt(df_commits_singular)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n날짜별로 그룹화된 데이터셋을 사용하여 시간별 사용자 활동을 관찰할 수 있습니다. 이전에 언급했듯이 날짜 데이터가 너무 많아서 차트에 표시하기에는 많았기 때문에 주차별, 연도별로 그룹화했습니다. 아래 함수를 사용하여 그룹화했습니다:\n\n```js\ndef gen_group_week(filt_dataframe):\n    \"\"\" 이 함수는 필터링된 데이터셋을 주별로 그룹화합니다 \"\"\"\n    df_commits_temp = filt_dataframe.sort_values(\n        by='date')[['date', 'sha', 'repo', 'author', 'message']]\n    df_commits_temp.date = df_commits_temp.date.apply(\n        lambda x: datetime.strptime(x, '%Y-%m-%dT%H:%M:%SZ'))\n    df_commits_temp['week'] = df_commits_temp['date'].dt.strftime('%W-%Y')\n    df_commits_temp = df_commits_temp.groupby('week').agg(\n        {\n            'sha': 'count',\n            'repo': 'nunique',\n            'author': 'nunique'}).reset_index().rename(\n            columns={\n                'sha': 'n_commits',\n                'author': 'n_participants',\n                'repo': 'n_repos'})\n    df_commits_temp['week_num'] = \\\n        df_commits_temp['week'].str.split('-').str[0].astype(int)\n    df_commits_temp['year'] = \\\n        df_commits_temp['week'].str.split('-').str[1].astype(int)\n    df_commits_temp = df_commits_temp.sort_values(by=['year', 'week_num'])\n    return df_commits_temp\n```\n\n마지막으로, 필터링된 각 데이터셋에 이 함수를 적용했습니다.\n\n```js\ndf_commits_bittensor_week = gen_group_week(df_commits_bittensor_filt)\ndf_commits_fetchai_week = gen_group_week(df_commits_fetchai_filt)\ndf_commits_numerai_week = gen_group_week(df_commits_numerai_filt)\ndf_commits_ocean_week = gen_group_week(df_commits_ocean_filt)\ndf_commits_oraichain_week = gen_group_week(df_commits_oraichain_filt)\ndf_commits_singular_week = gen_group_week(df_commits_singular_filt)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 이전에 표시된 막대 차트를 구동한 코드를 살펴보겠습니다.\n\n```js\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom datetime import datetime\n\ndef chart_user_activity(df, protocol):\n    \"\"\" 사용자 활동에 대한 시간별 막대 차트 작성 \"\"\"\n    fig, ax1 = plt.subplots(figsize=(20, 8))\n    # 필요에 따라 색상 수를 조정할 수 있습니다\n    colors = sns.color_palette('tab10', len(df['year'].unique()))\n    # 각 고유 연도를 색상에 매핑하는 딕셔너리 생성\n    year_colors = dict(zip(df['year'].unique(), colors))\n    sns.barplot(\n        df,\n        x='week',\n        y='n_commits',\n        hue='year',\n        ax=ax1,\n        dodge=False,\n        palette=year_colors)\n    ax1.set_xlabel('주', fontsize=18)\n    ax1.set_ylabel('커밋 수', fontsize=18)\n    ax1.tick_params('y', labelsize=12)\n    ax1.set_title(f\"{protocol} 개발자 활동 시간별\", fontsize=30)\n    ax1.grid(axis='y', which='major', linestyle='--', linewidth=0.5)\n    ax2 = ax1.twinx()\n    sns.lineplot(\n        df,\n        x='week',\n        y='n_participants',\n        ax=ax2,\n        linestyle='--',\n        marker='o',\n        color='r',\n        alpha=0.5)\n    ax2.set_ylabel('참가자 수', fontsize=18, color='r')\n    ax2.tick_params('y', colors='r', labelsize=12)\n    ax2.xaxis.set_ticks(df['week'][::10])\n    ax1.spines['top'].set_visible(False)\n    ax2.spines['top'].set_visible(False)\n    # x축 눈금 라벨에서 연도 부분 제거\n    labels = [item.get_text().split('-')[0] for item in ax1.get_xticklabels()]\n    ax1.set_xticklabels(labels)\n    ax1.tick_params('x', labelsize=12)\n    ax2.set_ylim(bottom=0)\n    plt.show()\n```\n\n차트를 표시하려면 다음과 같이 간단히 수행할 수 있습니다:\n\n```js\nchart_user_activity(df_commits_bittensor_week, 'Bittensor')\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 프로젝트 활동 기준으로 순위 매기기\n\n이 섹션에서는 서로 다른 프로젝트에서 시간이 지남에 따라 사용된 커밋 수와 리포지토리 수를 비교해 보겠습니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_7.png)\n\n위 막대 차트는 시간이 지남에 따른 커밋의 진화와 연도별 사용된 다른 리포지토리의 수를 확인할 수 있습니다. 이 차트들을 검토하면 몇 가지 초기 관찰을 할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 가장 많은 커밋(41465)을 가진 프로젝트는 Fetch.ai이며, 그 다음으로 Ocean Protocol이 33626개의 커밋을 가지고 있습니다. Fetch.ai가 가장 많은 커밋을 가졌다는 사실은 GitHub에서의 장기간 활동으로 인해 놀랍지 않습니다. Ocean Protocol은 4년 뒤에 시작했지만 이미 다른 최근 프로젝트와 비교하여 인상적인 개발 활동을 보여주고 있습니다.\n- Bittensor, Ocean Protocol, Oraichain, 그리고 Numerai는 해마다 저장소 수를 늘리고 있으며, 2023년에는 가장 많은 저장소 사용량을 가지고 있습니다. 2024년에는 이 수가 늘어날 수 있습니다. 그러나 이 명제를 확인하기 위해 모든 데이터를 아직 갖고 있지는 않습니다.\n- Oraichain은 커밋 수와 저장소 수 사이에 높은 상관 관계를 보여줍니다. Bittensor도 어느 정도 상관 관계를 보여주지만, 다른 프로젝트에는 해당되지 않습니다.\n- 저장소 수에 대해서는, Oraichain과 Ocean Protocol이 가장 많으며, 명확히 연도별로 늘어나고 있습니다.\n- Bittensor, Ocean Protocol, 그리고 Oraichain은 연도별로 커밋 수를 늘리고 있으며, SingularityNET은 Numerai와 함께 줄어들고 있습니다. Fetch.ai는 벨 모양 곡선을 보여주는데, 개발이 2018년, 2019년, 2020년에 매우 많았지만, 최초와 최근 연도에는 낮았습니다.\n\n간단히 말하면, 각 프로젝트의 연도별 커밋을 합산하여 순위를 매기려면 다음과 같은 결과를 얻을 수 있습니다:\n\n- Fetch.ai — 41465 개의 커밋.\n- Ocean Protocol — 3362 개의 커밋.\n- SingularityNET — 26245 개의 커밋.\n- Bittensor — 23336 개의 커밋.\n- Oraichain — 21136 개의 커밋.\n- Numerai — 2543 개의 커밋.\n\n# 활동에 따른 프로젝트 순위 (코드)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 연도별로 필터된 데이터셋을 그룹화하는 함수입니다.\n\n```js\ndef gen_group_year(filt_dataframe):\n    \"\"\" 필터된 데이터셋을 연도별로 그룹화하는 함수입니다 \"\"\"\n    df_commits_temp = filt_dataframe.sort_values(\n        by='date')[['date', 'sha', 'repo', 'author', 'message']]\n    df_commits_temp['date'] = pd.to_datetime(df_commits_temp['date'])\n    df_commits_temp['year'] = df_commits_temp['date'].dt.year\n    df_commits_temp = df_commits_temp.groupby('year').agg(\n            {\n                'sha': 'count',\n                'repo': 'nunique',\n                'author': 'nunique'}).reset_index().rename(\n                columns={\n                    'sha': 'n_commits',\n                    'author': 'n_participants',\n                    'repo': 'n_repos'})\n    return df_commits_temp\n```\n\n이제 각 프로젝트에 함수를 적용해봅시다:\n\n```js\ndf_commits_bittensor_year = gen_group_year(df_commits_bittensor_filt)\ndf_commits_fetchai_year = gen_group_year(df_commits_fetchai_filt)\ndf_commits_numerai_year = gen_group_year(df_commits_numerai_filt)\ndf_commits_ocean_year = gen_group_year(df_commits_ocean_filt)\ndf_commits_oraichain_year = gen_group_year(df_commits_oraichain_filt)\ndf_commits_singular_year = gen_group_year(df_commits_singular_filt)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 차트의 코드입니다:\n\n```js\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom datetime import datetime\n\ndef bar_activity_n_repos(datasets, main_title, subplot_titles):\n    \"\"\" Make bar char for activity and repos over time \"\"\"\n    num_datasets = len(datasets)\n    num_rows = (num_datasets + 1) // 2\n    fig, axes = plt.subplots(num_rows, 2, figsize=(14, 7*num_rows))\n    fig.suptitle(main_title, fontsize=30)\n    for i, (df, title) in enumerate(zip(datasets, subplot_titles)):\n        row = i // 2\n        col = i % 2\n        ax = axes[row, col]\n        sns.barplot(\n            x=\"year\",\n            y=\"n_commits\",\n            hue='n_repos',\n            data=df,\n            dodge=False,\n            palette='Blues',\n            ax=ax)\n        ax.spines['top'].set_visible(False)\n        ax.set_ylabel('Commits', fontsize=14)\n        ax.set_xlabel('Years', fontsize=14)\n        ax.set_title(title, fontsize=20)\n        ax.grid(axis='y', which='major', linestyle='--', linewidth=0.5)\n        legend = ax.legend()\n        legend.set_title(\"Repositories\")  # Setting legend title\n        # Add a red horizontal line for the mean of commits\n        mean_commits = df['n_commits'].mean()\n        ax.axhline(y=mean_commits, color='red', linestyle='--', label='mean')\n        # Annotate mean value above the line\n        ax.text(\n            0.05,\n            mean_commits * 1.05,\n            f'Mean: {mean_commits:.2f}',\n            color='red',\n            fontsize=12,\n            va='bottom')\n    plt.tight_layout(rect=[0, 0.03, 1, 0.95])  # Adjust subplot title position\n    plt.subplots_adjust(hspace=0.2, wspace=0.2)  # Add gap between charts\n    plt.show()\r\n```\n\n# 가장 활발한 개발자 순위\n\n이 섹션에서는 각 프로젝트에서 가장 활발한 개발자를 살펴보고, 그들의 상호작용을 시간에 따라 살펴볼 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다가오는 차트는 막대 그래프입니다. 첫 번째 차트는 연도별로 커밋 수가 가장 많은 상위 10명의 저자를 보여주며, 두 번째 차트는 매년 가장 활발한 개발자를 순위로 나타냅니다. 각 프로젝트에 대해 두 차트를 살펴봐요.\n\n## Bittensor\n\n![Bittensor Chart](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_8.png)\n\n위의 막대 차트를 보면, 각 개발자가 매년 비슷한 수의 커밋을 하지 않는다는 것을 알 수 있습니다. 즉, 저자들은 매년 비슷한 수의 커밋을 하지 않는다는 것입니다. 이는 각 개발자가 자신의 전문 분야가 있고, 가장 익숙한 기술에 대해 작업하기 때문일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발 초기 몇 년(2017년, 2018년 및 2029년)에는 Pierre Krieger, Robert Habermeier 및 Bastian Kocher가 프로젝트 개발에 참여했습니다. 그 중 일부는 Polkadot에서 알려져 있습니다. 이야기해야 할 것은 2019년에 Gavin Wood도 프로젝트 개발에 합류했다는 것입니다.\n\n가장 많은 커밋이 이루어진 고점은 Carro가 2022년에 기여했습니다. 동일한 개발자가 2023년에도 일부 기여를 했으며, 전반적으로 이 분은 이러한 연도에 발생한 특정 작업에 중요한 역할을 한 것으로 보입니다.\n\n마지막 몇 년 동안 p-ferreira가 2023년과 2024년에 가장 많은 커밋을 한 것으로 보입니다. Cameron Fairchild는 최근 몇 년간 높은 헌신을 보여주었지만 2024년에는 그렇게 많이 하지는 않은 것 같습니다.\n\n이제 연도별 총 커밋 수를 기준으로 개발자들을 순위 매겨 보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 차트를 기준으로:\n\n- 2017년에는 Robert Habermeier가 가장 많은 커밋을 하였으며, 2018년에는 Gavin Wood가 활약했습니다.\n- 2019년에는 Bastian Kocher가 가장 활발하였습니다.\n- unconst는 2020년, 2021년, 2023년에 1위를 기록했습니다.\n- 2022년에는 Carro가 가장 높은 피크에 기여한 바 있습니다.\n- 현재까지는 p-ferreira가 2024년 가장 활발하게 활동 중입니다.\n\n전체 기간을 살펴보면, Bastian Kocher가 프로젝트에서 가장 많은 커밋을 하였으며, unconst가 그 뒤를 이었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 페치.에이\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_10.png)\n\n위 차트에서 우리는 상위 10명의 개발자 중 아무도 2024년에 기여를 하지 않고 있다는 것을 결론 지을 수 있습니다. 가장 최근의 커밋은 2022년과 2023년이며, 이는 ali와 Yuri Turchenkov에 의해 이루어졌습니다. David Minarsch는 2021년에 매우 활발히 활동했으며 커밋의 최고 피크(2500건 이상)는 2020년에 그에 의해 이루어졌습니다. Ethan Buchman 역시 2016년부터 2018년 사이에 많은 커밋을 하였지만, 2019년 이후로 활동이 없습니다. 또한 이 프로젝트에서 일한 최초의 사람 중 한 명이기도 하지만, 최초의 커밋은 Jae Kwon에 의해 이루어졌습니다.\n\n이제 각 연도별로 가장 활발하게 활동한 개발자들을 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_11.png]을(를) 참고하면 다음과 같습니다:\n\n- Jae Kwon은 프로젝트 시작 시점인 2014년과 2015년에 가장 활발하게 개발을 진행했습니다.\n- Ethan Buchman은 2016년, 2017년 및 2018년에 리더였습니다.\n- David Minarsch는 2019년, 2020년 및 2021년에 가장 많은 커밋을 했습니다.\n- Yuri Turchenkov은 2022년에 119개의 커밋을 했습니다.\n- James Riehl은 2023년과 2024년에 가장 많은 커밋을 했습니다.\n\n전체적으로 Ethan Buchman(5911개의 커밋)이 가장 활발한 개발자였고, David Minarsch(5002개의 커밋)와 Jae Kwon(2604개의 커밋)이 이어졌습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Numerai\n\n![image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_12.png)\n\n위 차트에서 전체 커밋 수가 가장 많은 상위 10명의 개발자를 볼 수 있습니다. Keith Goodman과 Xander Dunn은 2017년과 2018년에 가장 많은 커밋을 보였습니다. 그러나 현재는 더이상 기여를 하지 않는 것으로 보입니다. 몇 년 동안 가장 꾸준하게 활동한 개발자는 Anson Chu로 보입니다.\n\n지난 몇 년간 Noah Harasz는 꽤 활발히 활동했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 목록의 대부분의 개발자는 1년에서 2년 사이에 기여하였으며, 참여할 때 상당히 활발하지만 오랫동안 머무르지 않았습니다.\n\n이제 각 연도별 주요 기여자를 분석해보겠습니다.\n\n![chart](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_13.png)\n\n차트를 살펴보면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 첫 번째 실제 개발은 2017년에 키스 굿맨(Kieth Goodman)과 함께 시작되었고, 2018년까지 계속되었습니다.\n- 2019년에는 제이슨 파리아니(Jason Paryani)가 주도하며, 2020년에는 나타샤-제이드 챈들러(Natasha-Jade Chandler)의 시기였습니다.\n- 2021년에는 titbtcqash의 시기였습니다.\n- 2023년과 2024년에는 노아 하라즈(Noah Harasz)가 가장 많은 커밋을 했습니다.\n\n총적으로, 키스 굿맨이 822개의 커밋으로 현저히 가장 활발한 개발자였습니다. 그 다음으로는 노아 하라즈가 207개의 커밋, 그리고 제이슨 파리아니가 196개의 커밋을 했습니다.\n\n## Ocean Protocol\n\n![Ocean Protocol Image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 막대 차트에서 우리는 Ocean Protocol에서 활발히 활동하는 상위 10명의 개발자를 볼 수 있습니다. Matthias Kretschmann은 처음부터 개발을 해오고 있으며, 지난 두 해 동안 커밋을 하지 않았더라도, 여전히 이전에 가장 활발한 개발자입니다. Trent McConaghy는 (trentmc) 이름으로 차트에 두 번 나타나며, 최고의 협력자 중 하나이기도 하며, 지난 몇 년간 상당히 활발하게 활동했습니다. Matthias Kretschmann은 가장 많은 커밋 피크를 보여주지만, Jamie Hewitt와 Norbert도 최근 몇 년간 두 가지 중요한 피크를 보여줍니다.\n\n이제 연도별 최고 기여자를 살펴봅시다.\n\n![chart](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_15.png)\n\n위의 차트를 관찰함으로써 다음을 결론짓을 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Matthias Kretschmann은 2018년부터 2021년까지 가장 활발하게 활동한 개발자였습니다. 또한 프로젝트 전체에서 가장 많은 커밋을 보유한 저자입니다(4666개의 커밋).\n- Jamie Hewitt은 2022년에 우세하며, 또한 두 번째로 활발한 개발자입니다(2133개의 커밋).\n- Norbert은 2023년에 우세합니다.\n- 2024년에는 Trent McConaghy가 지금까지 가장 많은 커밋을 가지고 있습니다.\n\n## Oraichain\n\n![image](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_16.png)\n\nOraichain의 가장 활발한 10명의 개발자가 위의 막대 차트로 나타나 있습니다. 해당 그림은 몇 개의 봉우리로 특징 지어집니다. 개발자들이 1년에서 2년 사이에 노력을 집중했음을 나타냅니다. Thunnini은 2019년부터 2021년까지 매우 활발하게 활동했으며, Le Duc Pham과 함께였습니다. 가장 높은 커밋 피크는 Pham Tu에 의해 2023년에 기록되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근 가장 많은 커밋을 한 개발자는 Hau Nguyen Van, Toan Dang, sonlha 그리고 ducphamle2라는 이름의 Le Duc Pham입니다.\n\n이제 각 연도별로 가장 활발한 개발자들을 살펴보겠습니다.\n\n![2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_17.png](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_17.png)\n\n상단의 막대 차트는 다음 정보를 제공합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Yury Delendik은 2018년에 가장 활발히 활동했습니다.\n- 2019년부터 2021년까지 Thunnini가 커밋 수에서 우세했습니다.\n- 2022년에는 Le Duc Pham이 선두를 차지했습니다.\n- 2023년에는 Pham Tu가 모든 기간에 가장 많은 커밋을 했습니다.\n- 2024년에는 Hau Nguyen Van이 가장 활발한 개발자입니다.\n\n예상대로, Thunnini가 총 커밋 수로 가장 많은(2458건)를 기록했습니다. 이어서 Pham Tu(2427건)와 Le Duc Pham(2273건) 순으로 나타났습니다.\n\n## SingularityNET\n\n\u003cimg src=\"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_18.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 표에서 볼 수 있듯이, 상위 10명의 가장 활발한 개발자는 대부분 2018년부터 2021년 사이에 활동했으며 몇 가지 예외가 있습니다. 일부 개발자는 몇 년 동안 일관성을 보였는데, 이들은 Prashant Gupta, anandrgitnirman, dasari-ananya 및 Sridhar Babu Kolapalli입니다. 초기 개발은 특히 Vitaly Bogdanov에 의해 표시되었으며, 커밋의 최고점은 2019년 Vivek에 의해 이루어졌습니다.\n\nRajeev는 최근 몇 년간 가장 활발한 개발자 중 한 명이었으며, anandrgitnirman과 함께 활동하고 있었습니다.\n\n이제 매년 최고의 개발자들을 살펴보는 시간입니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_19.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 차트에서 다음을 결론지을 수 있습니다:\n\n- Marco Argentieri는 프로젝트 초창기(2017년)에 가장 활발했습니다.\n- 2018년에는 Vitaly Bogdanov가 선두를 담당했습니다.\n- 가장 높은 커밋 피크는 2019년에 Vivek이 올렸습니다.\n- 2020년은 Pratik의 시기였고, 2021년은 Rajeev의 시간이었으며, 2022년은 anandrgitnirman의 시기였습니다.\n- Marco Capozzoli는 최근 몇 년간 가장 활발한 개발자였습니다.\n\n다른 프로젝트와 달리, 대부분의 경우 연도별로 한 명의 개발자가 있으며, 한 명의 개발자가 여러 해 동안 지배하는 경우는 드뭅니다. 그래도 Marco Capozzoli는 2023년과 2024년에 1위를 차지했습니다. 전체적으로 Vivek이 1927개의 커밋으로 가장 활발했고, 그 뒤를 이어 anandrgitnirman의 1340개 커밋, 마지막으로 Vitaly Bogdanov의 1106개 커밋이 이어졌습니다.\n\n# 활동에 따라 저장소 순위 매기기\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 각 프로젝트에서 활동이 가장 많은 상위 10개 저장소를 살펴보겠습니다. 이는 프로젝트 저장소에 제출된 커밋 수로 측정됩니다.\n\n## Bittensor\n\n현재 Bittensor는 총 31개의 저장소를 보유하고 있지만, 시간상의 이유로 상위 10개 저장소만 고려하여 시각화를 더 잘하고 가장 활발한 저장소에 대해 심층적인 연구를 할 것입니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_20.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 커밋 수에 따라 정렬된 상위 10개 리포지토리 목록과 각각의 GitHub 저장소가 있습니다:\n\n- polkadot-sdk: https://github.com/opentensor/polkadot-sdk\n- bittensor: https://github.com/opentensor/bittensor\n- subtensor: https://github.com/opentensor/subtensor\n- prompting: https://github.com/opentensor/prompting\n- developer-docs: https://github.com/opentensor/developer-docs\n- old-docs: https://github.com/opentensor/old-docs\n- validators: https://github.com/opentensor/validators\n- text-prompting: https://github.com/opentensor/text-prompting\n- mem-pytorch: https://github.com/opentensor/mem-pytorch\n- squid: https://github.com/opentensor/squid\n\npolkadot-sdk는 가장 많은 커밋 수(13789개)를 가진 저장소로, Polkadot 네트워크에서 개발을 시작하는 데 필요한 모든 리소스를 제공합니다. 이것은 또한 Polkadot의 개발자들이이 프로젝트에 참여하는 이유입니다. 목록에서 두 번째로 많은 커밋을 가진 저장소인 bittensor가 뒤를 이어 나옵니다.\n\n세 번째로는 subtensor가 차지하는데, 이는 Bittensor의 substrate-chain입니다. 이 저장소는 다음을 수행합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Bittensor의 합의 메커니즘 실행\n- 신경 정보, IP 등을 광고합니다.\n- TAO를 통해 가치 이체를 용이하게 함.\n\n## Fetch.ai\n\n현재 Fetch.ai는 57개의 저장소를 가지고 있습니다. 하지만 우리는 상위 10개 저장소만 살펴보고 더 나은 시각화를 위해 최고 활동적인 저장소에 대해 심층적인 연구를 진행할 것입니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_21.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 커밋 수를 기준으로 정렬된 상위 10개 리포지토리와 해당 GitHub 저장소 목록입니다:\n\n- agents-aea: [링크](https://github.com/fetchai/agents-aea)\n- tendermint: [링크](https://github.com/fetchai/tendermint)\n- cosmos-consensus: [링크](https://github.com/fetchai/cosmos-consensus)\n- cosmos-sdk: [링크](https://github.com/fetchai/cosmos-sdk)\n- ledger: [링크](https://github.com/fetchai/ledger)\n- ledger-archive: [링크](https://github.com/fetchai/ledger-archive)\n- agents-tac: [링크](https://github.com/fetchai/agents-tac)\n- cosmos-explorer: [링크](https://github.com/fetchai/cosmos-explorer)\n- docs: [링크](https://github.com/fetchai/docs)\n- colearn: [링크](https://github.com/fetchai/colearn)\n\n1위는 1천 개 이상의 커밋을 기록한 agents-aea입니다. 이 저장소는 자율 경제 에이전트를 만들 수 있도록 합니다. 두 번째는 tendermint이며, Cosmos 블록체인 환경에서 매우 흔한 비잔틴 장애 허용 (BFT) 미들웨어입니다. cosmos-consensus가 세 번째로 순위되어 있습니다. 일반적으로 Fetch.ai는 여러 Cosmos 블록체인 리포지토리를 사용합니다.\n\n## Numerai\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNumerai은 현재 21개의 저장소가 있지만 시각화를 더 잘 하기 위해 상위 10개 저장소만 살펴보고 가장 활발한 저장소에 대해 심층 연구를 할 것입니다.\n\n아래는 커밋 수로 정렬된 상위 10개 저장소 목록과 해당 GitHub 저장소입니다:\n\n- numerox: https://github.com/numerai/numer\n- doc: https://github.com/numerai/docs\n- example-scripts: https://github.com/numerai/example-scripts\n- submission-criteria: https://github.com/numerai/submission-criteria\n- numerai-cli: https://github.com/numerai/numerai-cli\n- doc-jp: https://github.com/numerai/docs-jp\n- heroku-buildpack-polymer: https://github.com/numerai/heroku-buildpack-polymer\n- numerai-predict: https://github.com/numerai/numerai-predict\n- tournament-data-integrity: https://github.com/numerai/tournament-data-integrity\n- tournament-contracts: https://github.com/numerai/tournament-contracts\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnumerox가 가장 많은 커밋을 가진 저장소입니다. Numerai 토너먼트 도구 상자입니다. 두 번째로 활발한 것은 Numerai에 관한 자습서와 문서가 있는 docs입니다. 세 번째로는 이름 그대로 Numerai 토너먼트를 위한 코드 예제를 보여주기 위해 할애된 example-scripts입니다.\n\n## Ocean Protocol\n\n현재 쓰고 있는 시점에서 Ocean Protocol은 79개의 저장소를 보유하고 있지만, 가장 활동적인 저장소를 파악하고 깊은 연구를 하기 쉽도록 상위 10개 저장소만 분석하겠습니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_23.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 커밋 수로 정렬된 상위 10개 저장소 목록과 해당 GitHub 저장소가 있습니다:\n\n- pdr-docs: https://github.com/oceanprotocol/pdr-docs\n- docs: https://github.com/oceanprotocol/docs\n- ocean.js: https://github.com/oceanprotocol/ocean.js\n- marketplace-launchpad: https://github.com/oceanprotocol/marketplace-launchpad\n- market: https://github.com/oceanprotocol/market\n- waves: https://github.com/oceanprotocol/waves\n- df-web: https://github.com/oceanprotocol/df-web\n- contracts: https://github.com/oceanprotocol/contracts\n- ocean.py: https://github.com/oceanprotocol/ocean.py\n- aquarius: https://github.com/oceanprotocol/aquarius\n\nOcean Protocol 프로젝트에서 문서 작성이 중요합니다. 가장 활발한 두 저장소는 문서와 관련이 있으며, 첫 번째는 Predictoor를 위한 것이고 두 번째는 일반 스택을 위한 것입니다. 차트는 Predictoor가 팀이 우선순위를 두고 있는 도구라는 것을 시사하며, 이는 높은 커밋 수와 매우 상세한 문서화로 확인할 수 있습니다. 세 번째로는 Ocean의 프로토콜 기술을 사용할 수 있게 해주는 ocean.js가 있습니다. 커밋 수를 보면, JavaScript가 Python보다 더 많이 요청된다고 가정할 수 있습니다. 왜냐하면 ocean.py 패키지도 있지만 활동이 훨씬 적습니다.\n\n네 번째로, 개발자들이 자신만의 마켓플레이스를 만드는 방법을 가르치는 marketplace-launchpad이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Oraichain\n\nOraichain은 109개의 저장소가 있습니다. 그러나 시각화를 용이하게 하고 가장 활발한 것을 더 깊이 연구하기 위해 상위 10개 저장소만 보겠습니다.\n\n![이미지](/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_24.png)\n\n아래는 커밋 수에 따라 정렬된 상위 10개 저장소 목록이며, 각 저장소의 GitHub 저장소입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- owallet: https://github.com/oraichain/owallet\n- oraiswap-frontend: https://github.com/oraichain/oraiswap-frontend\n- oraiscan-frontend: https://github.com/oraichain/oraiscan-frontend\n- keplr-extension-orai: https://github.com/oraichain/keplr-extension-orai\n- oraidex-sdk: https://github.com/oraichain/oraidex-sdk\n- smart-studio: https://github.com/oraichain/smart-studio\n- orai: https://github.com/oraichain/orai\n- oraiswap: https://github.com/oraichain/oraiswap\n- oraiwasm: https://github.com/oraichain/oraiwasm\n- cosmosjs: https://github.com/oraichain/cosmosjs\n\n위 차트를 보면 owallet이 가장 활동적인 프로젝트임을 알 수 있습니다. 이 지갑은 Cosmos 및 EVM 통합을 지원합니다. 두 번째로 활발한 저장소는 Oraichain DEX의 일부인 oraiswap-frontend입니다. 가장 활발한 3번째 저장소는 Oraichain을 위한 블록 익스플로러인 oraiscan-frontend입니다.\n\n## 싱귤래리티넷\n\n싱귤래리티넷은 목록에서 가장 많은 저장소(116개)를 보유한 프로젝트입니다. 그러나 더 나은 시각화를 위해 상위 10개 저장소만 살펴보고 각각에 대해 약간 깊이 파고들어보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 커밋 수에 따라 순서가 매겨진 상위 10개 저장소 목록과 해당 GitHub 저장소가 있습니다:\n\n- snet-marketplace-service: https://github.com/singnet/snet-marketplace-service\n- snet-dapp: https://github.com/singnet/snet-dapp\n- snet-daemon: https://github.com/singnet/snet-daemon\n- dev-portal: https://github.com/singnet/dev-portal\n- snet-cli: https://github.com/singnet/snet-cli\n- airdrop-services: https://github.com/singnet/airdrop-services\n- snet-betav1-dapp: https://github.com/singnet/snet-betav1-dapp\n- offernet: https://github.com/singnet/offernet\n- ai-dsl: https://github.com/singnet/ai-dsl\n- airdrop-dapp: https://github.com/singnet/airdrop-dapp\n\n가장 많은 커밋을 가진 저장소는 snet-marketplace-service입니다. 이 저장소는 SingularityNET의 시장을 사용하는 방법을 가르쳐 줍니다. 프로젝트의 탈중앙화 애플리케이션(snet-dapp)을 구축하는 데 사용된 저장소가 두 번째로 활동적입니다. 세 번째로 커밋 수가 많은 저장소는 SingularityNET 데몬이고, 그 다음은 플랫폼 및 시장에 대한 많은 문서를 제공하는 dev-portal입니다. 또한 두 개의 에어드랍에 전념한 저장소도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 문서는 여러 프로젝트 내 개발자 활동에 대한 포괄적인 견해를 제공합니다. 프로젝트 성장과 개발자 참여의 지표로서 커밋 및 저장소 사용의 중요성을 강조하며, 주요 사건이 개발 활동에 미치는 영향을 보여주고, 연도별 활동을 기반으로 저장소를 순위로 나열합니다.\n\n우리는 좋은 데이터 처리 방법론과 몇 개의 바 차트를 통해 각 프로젝트의 활동에 대해 풍부한 정보를 얻을 수 있었습니다. 요약하자면, Python과 데이터 분석에 대한 충분한 지식을 가지고 있으면 스테이크홀더, 투자자 및 경쟁업체가 GitHub 개발 활동에 기반한 정보에 근거하여 판단을 내릴 수 있습니다.\n\n전체 보고서는 [이 링크](링크)에서 찾아볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png"},"coverImage":"/assets/img/2024-06-30-HowtoAnalyseGitHubDevelopmentActivitywithPython_0.png","tag":["Tech"],"readingTime":39},{"title":"일찍 알았더라면 좋았을 6가지 Python 문자열 팁","description":"","date":"2024-06-30 21:58","slug":"2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier","content":"\n\n\u003cimg src=\"/assets/img/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier_0.png\" /\u003e\n\n개발자로서, 우리는 우연히 문자열을 다루게 됩니다. 여기 개발자로서의 삶을 편리하게 만들어준 멋진 파이썬 문자열 사실 6가지가 있어요.\n\n# 1) 'string' 모듈\n\n모든 알파벳이 필요할 때 실제로 모두 타이핑할 필요가 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\n알파벳 = 'abcdefghijklmnopqrstuvwxyz'\r\n```\r\n\r\n대신에, 내장된 문자열 모듈을 가져와서 사용할 수 있어요:\r\n\r\n```js\r\nfrom string import ascii_lowercase\r\n\r\nprint(ascii_lowercase)\r\n# abcdefghijklmnopqrstuvwxyz\r\n```\r\n\r\n문자열 모듈에는 대문자와 구두점과 같은 다른 유용한 문자열 상수들이 포함되어 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n첫 번째 표\n\n```\n| 모듈 | import 구문 |\n| --- | --- |\n| string | (\n| | ascii_uppercase,\n| | ascii_letters,\n| | punctuation\n) |\n\n\nprint(ascii_uppercase)\n# abcdefghijklmnopqrstuvwxyz\n\nprint(ascii_letters)\n# abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\n\nprint(punctuation)\n# !\"#$%\u0026'()*+,-./:;\u003c=\u003e?@[\\]^_`{|}~\n\n\n두 번째 표\n\n유니 코드 문자\n\nUnicode를 통해 특수 문자를 출력할 수 있습니다. 중국어, 일본어, 한국어, 이모티콘, 상자 문자 등을 문자열에서 출력할 수 있습니다.\n\n```js\nprint('옴 심볼: \\u03A9')\n\n# 옴 심볼: Ω\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n유니코드 문자를 인쇄하려면:\n\n- 유니코드 코드를 찾아야 합니다. 예: 오메가(옴) 기호의 경우 30A9를 구글/위키 등에서 찾습니다.\n- 유니코드 코드 앞에 \\u를 추가합니다. 예: \\u30A9\n- 문자열에 추가합니다. 예: `오메가 기호: \\u30A9`\n- 인쇄합니다! 그게 다입니다.\n\n참고 — \\u03A9와 같이 유니코드 문자는 한 개의 문자로 처리됩니다.\n\n이 방법을 사용하여 많은 특수 문자를 출력할 수 있습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprint('alpha: \\u03B1')\n# alpha: α\n\nprint('beta: \\u03B2')\n# beta: β\n\nprint('inverted ?: \\u00BF')\n# inverted ?: ¿\n\nprint('arrow:', '\\u2192')\n# arrow: →\n\nprint('summation:', '\\u2211')\n# summation: ∑\n```\n\n# 3) f-strings (formatted strings)\n\n처음에 문자열을 더하는 방법을 배웠을 때:\n\n```js\nname = 'tom'\nage = 30\n\nx = 'my name is ' + name + ' and I am ' + str(age)\n\nprint(x) # my name is tome and I am 30\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 문제점:\n\n- 변수를 처리해야 할 때 더 많은 변수가 추가될수록 계속 타이핑하는 것이 점점 귀찮아집니다.\n- 우리는 non-string 변수에 대해 str(var)를 사용해야 합니다. 이는 string에 string만 추가할 수 있기 때문에(이것이 귀찮음) 필요합니다.\n\nF-strings(형식화된 문자열)를 사용하면 우리의 삶이 더 쉬워집니다:\n\n```js\nname = 'tom'\nage = 30\n\nx = f'my name is {name} and I am {age}'\n\nprint(x) # my name is tom and I am 30\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 우리는 문자열을 형식화된 문자열로 만들기 위해 따옴표 앞에 f를 추가합니다.\n- f-문자열 안에 변수를 포함시키기 위해 'var'를 사용합니다.\n\nF-문자열은 강력한 형식 지정 구문을 제공합니다:\n\n```js\n# 변수 이름을 출력하려면 var 뒤에 = 을 추가합니다\n\nname = 'tom'\nage = 30\n\nprint(f'{name=} {age=}') \n# name='tom' age=30\n```\n\n```js\n# 소수점 n 자리까지 반올림을 수행하려면 :.nf를 추가합니다\n\npi = 3.14159265\n\nprint(f'{pi:.2f} {pi:.4f}')\n# 3.14 3.1416\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 날짜 및 시간을 쉽게 포맷팅하기\n# 참고: 날짜 및 시간 포맷에 대한 기호들은 Python 문서에서 찾을 수 있습니다\n\nfrom datetime import datetime\ndate = datetime(2024, 3, 7)\n\nprint(f\"{date:%y-%m-%d}\")  # 24-03-07\nprint(f\"{date:%d %B %Y}\")  # 07 March 2024\n```\n\n# 4) 원시 문자열\n\n문자열 내부에 \\n (개행 문자)을 추가하면 새 줄에 출력됩니다:\n\n```js\nx = 'hello\\nworld'\n\nprint(x)\n# hello\n# world\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 이유로 만약 실제로 \"hello\\nworld\"를 출력하고 싶다면, \\ 문자를 또 다른 \\ 문자를 사용하여 이스케이프해야 합니다:\n\n```js\nx = 'hello\\\\nworld'\n\nprint(x)\n# hello\\nworld\n```\n\n우리는 원시 문자열(raw strings)을 사용하여 이를 피할 수 있습니다 - 따옴표 앞에 r을 추가함으로써\n\n```js\nx = r'hello\\nworld'\n\nprint(x)\n# hello\\nworld\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 생 문자열에서 \\ 문자는 실제 문자로 처리됩니다\n- \\n은 2개의 문자로 처리됩니다 — \\와 n\n- 많은 \\ 문자로 이루어진 문자열을 구성해야 할 때 유용합니다\n\n저는 특히 정규 표현식 (regex)에 대해 생 문자열을 유용하게 사용합니다.\n\n```js\n# 'apple'을 포함하는 모든 단어를 찾기 위해 regex 사용\n\nstring = 'apple orange pear pineapple snapple durian'\n\nimport re\n\nregex = r'\\b\\w*apple\\b'\nprint(re.findall(regex, string))\n\n# ['apple', 'pineapple', 'snapple']\n```\n\n정규 표현식에 익숙하지 않은 분들을 위해 추가적인 설명:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- \\b 는 단어들 사이의 경계를 나타내는 문자이며, 단어, 숫자 또는 밑줄과 매칭됩니다.\n- \\w 는 단어 문자로, 숫자, 알파벳, 또는 밑줄과 매칭됩니다.\n\n만약 여기서 정규표현식에 원시 문자열을 사용하지 않았다면, 아마도 다음과 같을 것입니다:\n\n```js\n# 'apple'을 포함하는 모든 단어를 찾기 위해 정규표현식 사용\n\nstring = 'apple orange pear pineapple snapple durian'\n\nimport re\n\nregex = '\\\\b\\\\w*apple\\\\b'\nprint(re.findall(regex, string))\n\n# ['apple', 'pineapple', 'snapple']\n```\n\n^ 여전히 작동하지만, 다른 \\ 문자를 이스케이프하기 위해 \\를 사용해야 한다는 것에 주목해 주세요. 많은 이러한 작업을 다뤄야 한다면 괴롭다는 것을 알 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5) 대괄호를 사용하여 문자열 결합\n\n대괄호 안에 연속된 문자열은 자동으로 함께 결합됩니다:\n\n```js\nx = (\n    'apple '\n    'orange '\n    'pear'\n)\n\nprint(x)\n# apple orange pear\n```\n\n^ 이것은 여러 줄로 나뉘어진 매우 긴 문자열을 처리해야 할 때 유용하며 + 연산자를 사용하고 싶지 않을 때 유용합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# + 연산자 사용하기\nx = 'apple ' + \\\n    'orange ' + \\\n    'pear'\n\nprint(x)\n# apple orange pear\n```\n\n^ + 연산자를 여러 줄에 걸쳐 사용할 때는 \\을 사용하여 한 줄이 여러 줄에 걸친다고 Python에 알려주어야 합니다. 이것은 간단한 괄호를 사용하는 것만큼 우아하지 않다고 제 생각에는 느껴집니다.\n\n# 6) ANSI 이스케이프 시퀀스\n\nANSI 이스케이프 시퀀스는 특수한 문자로, 문자열에서 멋진 작업을 할 수 있게 해줍니다. 예를 들어:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 텍스트를 색으로 출력하기\n- 텍스트 강조 표시하기\n- 커서를 위로 이동하기\n\n예를 들어, 몇 가지 텍스트를 색상으로 출력해봅시다\n\n```js\nprint('\\x1b[31mhello')\nprint('\\x1b[32mhello')\nprint('\\x1b[34mhello')\n```\n\n\u003cimg src=\"/assets/img/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- \\x1b[31m은 빨강의 ANSI 시퀀스입니다.\n- \\x1b[32m은 초록의 ANSI 시퀀스입니다.\n- \\x1b[34m은 파랑의 ANSI 시퀀스입니다.\n\n이미 출력된 내용을 지우는 멋진 작업도 할 수 있어요:\n\n```js\nCURSOR_UP = \"\\033[1A\"\nCLEAR = \"\\x1b[2K\"\nCLEAR_LINE = CURSOR_UP + CLEAR\n\nprint('apple')\nprint('orange')\nprint('pear')\nprint('pineapple')\n\nprint(CLEAR_LINE * 2, end='')\n\nprint('durian')\nprint('grapes')\nprint('dragonfruit')\n\n# apple\n# orange\n# durian\n# grapes\n# dragonfruit\n```\n\n- \\033[1A는 커서를 한 줄 위로 이동시킵니다.\n- \\x1b[2K는 커서가 있는 줄을 삭제합니다.\n- 두 개를 함께 출력하면 터미널에서 한 줄을 삭제합니다.\n- print(CLEAR_LINE * 2, end='')는 이미 출력된 2 줄(pear와 pineapple)을 삭제합니다.\n- 그래서 durian이 바로 orange 다음에 나타나는 이유입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고 - 이슈 문자열을 매번 찾아보지 않아도 되도록 Python 패키지를 만들었습니다. pip install unprint을 사용해서 다운로드해보세요.\n\n```js\nfrom unprint import unprint\n\nprint('apple')\nprint('orange')\nprint('pear')\nprint('pineapple')\n\nunprint(2)\n\nprint('durian')\nprint('grapes')\nprint('dragonfruit')\n\n# apple\n# orange\n# durian\n# grapes\n# dragonfruit\n```\n\n# 부가적인 Python 농담\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알기 쉽고 명확했기를 바랍니다\n\n# 만약 개발자로서 저를 지원하고 싶다면\n\n- 내 서적을 구매해 주세요! — 파이썬에 대해 알지 못했던 101가지\r\n- 찾을 수 있는 곳: https://payhip.com/b/vywcf\r\n- 이 이야기에 대해 50번 박수를 치세요\r\n- 당신의 생각을 남겨줘요\r\n- 이야기에서 가장 좋아하는 부분을 강조해 주세요\n\n감사합니다! 이 작은 행동들이 큰 도움이 되고, 정말 감사합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nYouTube: [https://www.youtube.com/@zlliu246](https://www.youtube.com/@zlliu246)\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/assets/img/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier_0.png"},"coverImage":"/assets/img/2024-06-30-6PythonStringThingsIRegretNotKnowingEarlier_0.png","tag":["Tech"],"readingTime":11},{"title":"내가 가장 좋아하는 자바스크립트 코드 한 줄","description":"","date":"2024-06-30 21:57","slug":"2024-06-30-MySingleFavoriteLineOfJavascript","content":"\n\n![MySingleFavoriteLineOfJavascript_0](/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_0.png)\n\n몇 년 전, Quora에서 누군가가 \"지금까지 쓰여진 가장 강력한 코드 라인은 무엇인가?\"라고 물었습니다.\n\n대답들은 정말 재미있었고, 대부분은 예상한 것들이었습니다 (개발자라면요). 어떤 사람들은 while과 for 루프를 칭찬했는데, 컴퓨터가 반복 작업을 수행하도록 하는 중요한 구성 요소이며 \"우리 생활 중 가장 지루한 부분을 처리해 주기 때문에 감사한 역할\"이라고 말했습니다. 다른 개발자들은 컴퓨터가 말을 하게 만드는 print 문의 힘(컴퓨터 발화라고도 함), if-else 문(자동화된 의사 결정!), 또는 다른 사람의 오픈 소스 코드를 자동으로 흡수하고 나의 앱에서 사용할 수 있게 하는 import 명령에 대해 이야기했습니다.\n\n확실히 멋진 선택들입니다. 그러나 저에게는 기쁨을 주는 한 줄의 명령어가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의사 난수 생성기! 대부분의 프로그래밍 언어에는 그런 것이 있습니다. 자주 사용하는 Javascript 나 Node에서 작성 중이라면, 이 함수는 ...\n\n나는 이것을 존경스럽게 생각하며, 우연하게도 유용한 존재 중에서 가장 이상하고 마법 같은 코드라고 후보로 지명합니다.\n\n![MySingleFavoriteLineOfJavascript_1](/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_1.png)\n\nMath.random()은 마법 같은데, 왜냐하면 우리가 똑같이 형편없이 하는 게 내재하는 랜덤 숫자를 생성하기 때문이죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n누구나 정확히 이것을 왜 이렇게 못하는지는 알지 못합니다. 아마도 너무 많이 과도하게 생각하기 때문이죠. 예를 들어, 사람들에게 1에서 20까지의 임의의 숫자를 고르라고 부탁하면, 그들은 대부분 17을 선택할 것입니다. 그 이유는 뭘까요? 아마도 홀수이자 소수이기 때문에 무작위로 느껴지기 때문이겠지만, 우리가 그 결론에 이르기까지 논리적/직관적으로 사고하기 때문에, 그 외에 어떠한 것도 아닙니다.\n\n이것이 바로 왜 우리가 운명의 게임이 흔히 주사위와 같은 의사난수 생성 도구에 의존했는지, 컴퓨터가 현대의 주사위 던지기인 이유입니다. 한 줄의 코드로 필요한 만큼의 의사난수를 얻을 수 있죠.\n\n그리고 'random' 명령어는 제게 매우 유용한 것으로 나타났습니다.\n\n저는 특히 이 트위터 봇이 하루에 세 번 시를 생성하거나, \"Weird Old Book Finder\" 같은 이상한 오래된 책을 찾는 프로젝트와 같이 독특한 문화 프로젝트를 만드는 취미 코더입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문화 앱을 만들 때, 무작위성은 창의적인 힘이 될 수 있어요. \n\n예를 들어, 제 트위터봇을 위해 하이쿠 모양의 시를 900줄 이상 직접 썼어요. 매일 세 번, 봇이 무작위로 세 줄을 골라서 합쳐요.\n\n봇을 만드는 어려운 점은 그 모든 줄을 쓰는 것이었어요. 각 줄을 만들 때는 그것이 독립적으로 성립할 수 있을 뿐만 아니라 다른 줄과 쉽게 결합될 수 있도록 공들여야 했거든. 그것이 대부분의 작업이었습니다. \n\n![내가 가장 좋아하는 자바스크립트 한 줄](/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 소프트웨어 측면에서는 얼마나 재미있고 복잡하지 않은 일인가요? 코드가 네 줄 밖에 안 되었어요. 단 한 줄의 Math.random() 명령어가 모든 일을 처리해 주는 거죠.\n\n그런데 정말 대단한 건, 잘 작동한다는 거예요! 이 봇은 거의 다섯 년 동안 계속 트윗을 올리고 있고, Math.random()이 만들어내는 조합에 여전히 놀랍습니다. 제가 직접 모든 줄을 작성했음에도 왠지 모르게 이 조합들은 제 스스로 생각하지 못했을 거예요.\n\n시와 예술에서 무작위성을 사용하는 것은 당연히 제 창작물이 아니에요. 이전 디지털 시대로 거슬러 올라가면 (예를 들면 OULIPO 시에서 명사를 대체하는 \"N+7\" 기법처럼), 계휴한 우렁찬 전통이 있었고, 컴퓨터 시대에 들어서면서 더욱 놀라운 발전을 이루었어요. 많은 비디오 게임에서 봐도, 종종 간단한 무작위성을 이용해서 게임을 끝없이 즐길 수 있게 만들어요. 수많은 창작자들이 계산되는 무작위성을 즐거워해요.\n\nMatthew Siu의 말을 빌리자면...\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 Math.random()을 유용하게 활용하는 또 다른, 아마도 미묘한 방법이 있습니다: 결정을 내릴 때 사용하기.\n\n구체적으로, '선택의 역설'을 극복하는 데 사용합니다.\n\n이 이론은 우리가 매우 다양한 옵션을 제공 받을 때 결정하기가 더 어려워지며, 최종적으로 내린 결정에 덜 만족하게 됩니다. 이것은 흔치 않은 이론이며 최근 몇 년 동안 논쟁이 있었습니다. 그러나 제 개인적인 경험에는 맞다는 것 같습니다. 책방에 들어가면 \"최근 출간된\" 제목들의 거대한 배열을 보게 되면, 제 주의가 흐려지고 멀어지는 것을 느낍니다. 저는 책방 직원이 고른 10권의 작은 표를 선택하는 것이 훨씬 쉽다고 생각합니다.\n\n그래서 \"Weird Old Book Finder\"를 만들 때, 선택의 역설을 우회하는 방법으로 무작위성을 사용했습니다. 사용자의 검색 질의를 받아 구글 도서 API에 전달하고, 결과가 반환되면 1920년대 중반 이전에 출판된 제목을 필터링하여 공공 도메인에 속하고 즉시 전문을 읽을 수 있는 책들을 찾습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문제는 Google Books API가 최대 40개의 제목을 보내다는 것입니다. 너무 많아요. 선택 목록을 제공하고 싶지 않았어요 — 선택 광선을 유발할 수도 있으니까요!\n\n그래서 그냥 사용자에게 돌려보낼 책을 랜덤하게 하나 선택해요.\n\n또 다시, 이건 정말 간단한 기술이에요. 한 줄의 코드 뿐이에요. 하지만 이로 인해 검색 엔진이 재미있는 퀄리티를 얻게 해줘요. 동일한 검색어를 여러 번 실행해도 서로 다른 책을 얻어요. 이는 문화의 슬롯 머신이 되는거에요.\n\n![MySingleFavoriteLineOfJavascript_3.png](/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMath.random()은 일반적으로 사람들이 되지 못하는 방식으로도 재미있는 요소를 제공합니다.\n\n책 판매자나 사서에게 특정 주제의 책을 요청한다면 \"음, 해당 주제의 섹션으로 가서 아무거나 가져와\"라고 말하지 않을 텐데요. 이를 하기엔 너무 어색할 것입니다. 사람들은 의미 있는 행동과 의미창출을 선호합니다. 그들은 당신이 선택을 할 수 있도록 안내하는 것이 더 편할 것입니다.\n\n하지만 Math.random()은 이런 어색함이 없죠. 그냥 아무거나 줄 수 있습니다.\n\n그래서 제가 가장 강력한 코드 줄에 투표한 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMath.random().\n\n클라이브 톰슨은 주간 세 번의 게시물을 미디엄에 게시하며, 여러분께 이메일로 각 게시물을 받아보실 수 있습니다 - 그리고 미디엄 회원이 아닌 경우, 여기에서 가입할 수 있습니다.\n\n클라이브는 뉴욕 타임스 매거진의 기고자이자, 와이어드와 스미스소니언 매거진의 칼럼니스트로 활동하며, Mother Jones에 정기 기고자로 활동하고 있습니다. 그는 Coders: The Making of a New Tribe and the Remaking of the World과 Smarter Than You Think: How Technology is Changing our Minds for the Better의 저자이기도 합니다. 트위터와 인스타그램에서는 @pomeranian99를 팔로우할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_0.png"},"coverImage":"/assets/img/2024-06-30-MySingleFavoriteLineOfJavascript_0.png","tag":["Tech"],"readingTime":6}],"page":"3","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"3"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>