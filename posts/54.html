<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/54" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/54" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구" href="/post/2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 인터뷰 질문-제7파" href="/post/2024-05-27-iOSInterviewQuestions-Part7"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 인터뷰 질문-제7파" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-iOSInterviewQuestions-Part7_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 인터뷰 질문-제7파" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 인터뷰 질문-제7파</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고" href="/post/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI Photo Picker 앱을 PhotosUI로 만들기" href="/post/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI Photo Picker 앱을 PhotosUI로 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI Photo Picker 앱을 PhotosUI로 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI Photo Picker 앱을 PhotosUI로 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI 얼럿alerts 사용 방법" href="/post/2024-05-27-SwiftUIHowtousealerts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI 얼럿alerts 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SwiftUIHowtousealerts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI 얼럿alerts 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI 얼럿alerts 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift 동시성 뒤엉킨 것들 풀어내기" href="/post/2024-05-27-SwiftConcurrencyUn-tangledup"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift 동시성 뒤엉킨 것들 풀어내기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift 동시성 뒤엉킨 것들 풀어내기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift 동시성 뒤엉킨 것들 풀어내기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기" href="/post/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="맵핑 대 이터러블 맵핑 간단히 해석하기" href="/post/2024-05-27-MappingsvsIterableMappingsSimplified"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="맵핑 대 이터러블 맵핑 간단히 해석하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="맵핑 대 이터러블 맵핑 간단히 해석하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">맵핑 대 이터러블 맵핑 간단히 해석하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요" href="/post/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기" href="/post/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link posts_-active__YVJEi" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"다트와 플러터에서 객체지향 프로그래밍OOP 심층 탐구","description":"","date":"2024-05-27 16:30","slug":"2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter","content":"\n객체지향 프로그래밍(OOP)은 소프트웨어 디자인을 객체와 그 상호작용을 중심으로 구성하는 패러다임입니다. 플러터 뒤에 있는 언어인 Dart는 OOP 원칙을 완벽히 지원하여 견고하고 확장 가능한 애플리케이션을 구축하는 데 탁월한 선택지입니다. 이 포괄적인 가이드에서는 Dart와 Flutter의 맥락에서 캡슐화, 상속, 다형성, 추상화와 같은 OOP의 네 가지 기둥을 자세히 살펴보며 메서드 오버라이딩과 오버로딩과 같은 개념도 살펴볼 것입니다.\n\n# OOP의 네 가지 기둥 이해하기\n\n## 1. 캡슐화\n\n캡슐화는 데이터와 데이터를 조작하는 메서드를 하나의 클래스라는 단위 내에 묶는 것을 말합니다. 이는 객체의 내부 상태를 외부 세계로부터 숨기고 필요한 기능을 명확히 정의된 인터페이스를 통해 노출하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDart에서 캡슐화는 public, private 및 protected와 같은 접근 한정자를 통해 달성됩니다. 기본적으로 멤버는 public이지만 밑줄(\\_)을 사용하여 private로 표시할 수도 있습니다.\n\n예제:\n\n```js\nclass BankAccount {\n  double _balance = 0; // Private property\n\n  void deposit(double amount) {\n    _balance += amount;\n  }\n\n  void withdraw(double amount) {\n    if (_balance \u003e= amount) {\n      _balance -= amount;\n    } else {\n      print('Insufficient funds.');\n    }\n  }\n\n  double getBalance() {\n    return _balance;\n  }\n}\n\nvoid main() {\n  var account = BankAccount();\n  account.deposit(1000);\n  print('Current balance: ${account.getBalance()}'); // Output: Current balance: 1000\n  account.withdraw(500);\n  print('Remaining balance: ${account.getBalance()}'); // Output: Remaining balance: 500\n}\n```\n\n## 2. 상속\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상속은 하위 클래스(subclass)가 다른 클래스(슈퍼클래스)로부터 속성과 메소드를 상속받을 수 있는 메커니즘입니다. 이는 코드 재사용을 촉진하고 클래스 간에 계층적인 관계를 정립합니다.\n\n예시:\n\n```js\nclass Animal {\n  void speak() {\n    print('동물이 말합니다.');\n  }\n}\n\nclass Dog extends Animal {\n  @override\n  void speak() {\n    print('개가 짖습니다.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.speak(); // 출력: 개가 짖습니다.\n}\n```\n\n## 3. 다형성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다형성은 서로 다른 클래스의 객체를 공통 부모 클래스의 객체로 다룰 수 있게 합니다. 이는 코드의 유연성과 확장성을 가능하게 합니다.\n\n예시:\n\n```js\nclass Shape {\n  void draw() {\n    print('도형을 그립니다.');\n  }\n}\n\nclass Circle extends Shape {\n  @override\n  void draw() {\n    print('원을 그립니다.');\n  }\n}\n\nclass Rectangle extends Shape {\n  @override\n  void draw() {\n    print('사각형을 그립니다.');\n  }\n}\n\nvoid main() {\n  Shape circle = Circle();\n  Shape rectangle = Rectangle();\n\n  circle.draw(); // 결과: 원을 그립니다.\n  rectangle.draw(); // 결과: 사각형을 그립니다.\n}\n```\n\n## 4. 추상화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상화는 복잡한 구현 세부사항을 숨기고 객체의 필수적인 특성만을 보여주는 과정입니다. 이는 프로그래밍 복잡성을 줄이고 대규모 코드베이스를 효과적으로 관리하는 데 도움이 됩니다.\n\n예시:\n\n```js\nabstract class Animal {\n  void speak();\n}\n\nclass Dog extends Animal {\n  @override\n  void speak() {\n    print('Dog barks.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.speak(); // 출력: Dog barks.\n}\n```\n\n# 메서드 재정의와 오버로딩\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 메소드 오버라이딩\n\n메소드 오버라이딩은 서브클래스가 슈퍼클래스에서 이미 정의된 메소드의 특정 구현을 제공할 때 발생합니다. 이를 통해 서브클래스는 상속된 메소드의 동작을 자신의 필요에 맞게 수정할 수 있습니다.\n\n예시:\n\n```js\nclass Animal {\n  void speak() {\n    print('Animal speaks.');\n  }\n}\n\nclass Dog extends Animal {\n  @override\n  void speak() {\n    print('Dog barks.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.speak(); // 출력: Dog barks.\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 메소드 오버로딩\n\n메소드 오버로딩은 같은 이름을 가진 다른 매개변수를 갖는 여러 메소드를 정의할 수 있는 능력을 가리킵니다. Dart는 메소드 오버로딩을 직접 지원하지 않지만 선택적 매개변수 또는 이름이 지정된 매개변수를 사용하여 유사한 기능을 구현할 수 있습니다.\n\n예시:\n\n```js\nclass Calculator {\n  int add(int a, int b) {\n    return a + b;\n  }\n\n  double add(double a, double b) {\n    return a + b;\n  }\n}\n\nvoid main() {\n  var calc = Calculator();\n  print(calc.add(2, 3)); // 결과: 5\n  print(calc.add(2.5, 3.5)); // 결과: 6.0\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 상속 이해\n\n상속은 기존 클래스(슈퍼 클래스)에서 새 클래스(서브 클래스)를 생성하여 속성과 메소드를 상속받는 메커니즘입니다. 이는 코드 재사용을 촉진하고 클래스 간에 계층적인 관계를 설정합니다.\n\n# 상속의 종류\n\n## 1. 단일 상속\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 개의 수퍼클래스로부터 속성과 메소드를 상속받는 것을 단일 상속이라고 합니다. Dart에서 클래스는 하나의 수퍼클래스만 확장할 수 있습니다.\n\n예시:\n\n```js\nclass Animal {\n  void eat() {\n    print('동물이 먹고 있습니다.');\n  }\n}\n\nclass Dog extends Animal {\n  void bark() {\n    print('개가 짖고 있습니다.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.eat();  // 출력: 동물이 먹고 있습니다.\n  dog.bark(); // 출력: 개가 짖고 있습니다.\n}\n```\n\n이 예시에서 Dog 클래스는 Animal 클래스로부터 eat() 메소드를 상속받습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 다중 상속\n\n다중 상속은 하위 클래스가 다른 클래스의 슈퍼 클래스가 되는 상속 체인에 관련된 개념입니다. 이는 다수의 상속 레벨을 가진 계층적 관계를 설정합니다.\n\n예시:\n\n```js\nclass Animal {\n  void eat() {\n    print('Animal is eating.');\n  }\n}\n\nclass Dog extends Animal {\n  void bark() {\n    print('Dog is barking.');\n  }\n}\n\nclass Labrador extends Dog {\n  void swim() {\n    print('Labrador is swimming.');\n  }\n}\n\nvoid main() {\n  var labrador = Labrador();\n  labrador.eat();  // 출력: Animal is eating.\n  labrador.bark();  // 출력: Dog is barking.\n  labrador.swim();  // 출력: Labrador is swimming.\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n랩라도 클래스는 Dog 클래스를 상속하고, Dog 클래스는 Animal 클래스를 상속합니다.\n\n## 3. 계층 상속\n\n계층적 상속은 여러 하위 클래스가 단일 상위 클래스에서 상속받는 것을 의미합니다. 각 하위 클래스는 상위 클래스에서 공통 특성을 공유하지만 각자 고유한 특성을 가질 수 있습니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass Animal {\n  void eat() {\n    print('Animal is eating.');\n  }\n}\n\nclass Dog extends Animal {\n  void bark() {\n    print('Dog is barking.');\n  }\n}\n\nclass Cat extends Animal {\n  void meow() {\n    print('Cat is meowing.');\n  }\n}\n\nvoid main() {\n  var dog = Dog();\n  dog.eat();  // 결과: Animal is eating.\n  dog.bark(); // 결과: Dog is barking.\n\n  var cat = Cat();\n  cat.eat();  // 결과: Animal is eating.\n  cat.meow(); // 결과: Cat is meowing.\n}\n```\n\n이 예제에서 Dog 및 Cat 클래스는 Animal 클래스를 상속받아 eat() 메서드를 공유합니다.\n\n# 캡슐화 이해하기\n\n캡슐화는 객체 지향 프로그래밍의 핵심 원칙 중 하나로, 데이터(변수) 및 해당 데이터를 조작하는 메서드(함수)를 하나로 묶은 클래스라는 단위로 묶는 것을 목표로 합니다. 이 접근 방식은 개체의 일부 구성 요소에 대한 직접적인 액세스를 제한하여 의도하지 않은 간섭 및 남용을 방지하는 데 필수적입니다. Dart 및 Flutter에서 캡슐화는 멤버 변수 캡슐화, 함수 캡슐화 및 클래스 캡슐화의 세 가지 주요 방법으로 달성됩니다. 각 유형을 구체적인 예를 통해 자세히 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1. 멤버 변수 캡슐화\n\n멤버 변수 캡슐화는 객체의 내부 상태를 보호하기 위해 변수를 private로 만들고 public 메서드를 통해 제어된 접근을 제공하는 것을 의미합니다. 이를 통해 객체의 데이터가 정의된 방법으로만 수정될 수 있도록 보장할 수 있습니다.\n\n예시:\n\n```js\nclass Person {\n  String _name; // Private 변수\n\n  Person(this._name);\n\n  // name의 Getter\n  String get name =\u003e _name;\n\n  // name의 Setter\n  set name(String name) {\n    if (name.isNotEmpty) {\n      _name = name;\n    }\n  }\n}\n\nvoid main() {\n  var person = Person('John');\n  print(person.name); // 결과: John\n  person.name = 'Doe';\n  print(person.name); // 결과: Doe\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제에서 \\_name 변수는 private이며 getter 및 setter 메서드를 통해서만 액세스하거나 수정할 수 있습니다. 이 캡슐화는 \\_name에 대한 모든 수정이 확인되도록 보장합니다.\n\n## 2. 함수 캡슐화\n\n함수 캡슐화는 일부 메서드를 private으로 만들어 객체의 데이터가 내부적으로 어떻게 조작되는지 제어하는 것을 의미합니다. 필요한 메서드만 공개되고 내부 구현은 숨겨집니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass Calculator {\n  // Public method\n  int add(int a, int b) {\n    return _performAddition(a, b);\n  }\n\n  // Private helper method\n  int _performAddition(int a, int b) {\n    return a + b;\n  }\n}\n\nvoid main() {\n  var calc = Calculator();\n  print(calc.add(2, 3)); // Output: 5\n}\n```\n\n여기서 \\_performAddition 메서드는 private이며 Calculator 클래스 내에서만 접근할 수 있습니다. public add 메서드는 기능을 노출하면서 내부 작업은 숨겨둡니다.\n\n## 3. Class Encapsulation\n\n클래스 캡슐화는 관련된 변수와 메서드를 하나의 클래스로 묶는 것을 의미합니다. 이는 모듈성과 재사용성을 촉진하여 코드를 보다 조직적이고 관리하기 쉽도록 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\nclass Car {\n  String _model;\n  int _year;\n\n  Car(this._model, this._year);\n\n  // 자동차 정보를 표시하는 공개 메서드\n  void displayInfo() {\n    print('Model: $_model, Year: $_year');\n  }\n}\n\nvoid main() {\n  var myCar = Car('Tesla', 2021);\n  myCar.displayInfo(); // 출력: Model: Tesla, Year: 2021\n}\n```\n\n이 예시에서 Car 클래스는 \\_model과 \\_year 변수 및 displayInfo 메서드를 캡슐화합니다. 이 구조는 자동차에 관련된 모든 정보와 동작이 함께 그룹화되도록 보장합니다.\n\n# 추상화 이해하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상화는 객체 지향 프로그래밍(OOP)에서 중요한 원칙으로, 문제에 적합한 클래스를 모델링하여 복잡한 시스템을 간단하게 만들어줍니다. 이는 구현 세부 정보를 숨기고 사용자에게 기능만 표시함으로써 도움이 됩니다. Dart와 Flutter에서 추상화는 깔끔하고 유지보수 가능하며 모듈식 코드를 작성하는 데 다양한 형태로 적용될 수 있습니다. 이 블로그에서는 OOP에서 다양한 종류의 추상화인 데이터 추상화, 프로세스 추상화, 공개 지정자를 사용한 추상화, 그리고 비공개 분류자를 사용한 추상화에 대해 다룰 것입니다. 함께 알아보겠습니다!\n\n## 1. 데이터 추상화\n\n데이터 추상화는 필수적인 기능만 노출하고 불필요한 세부 정보를 숨기는 데 초점을 맞춥니다. Dart에서는 데이터 추상화를 주로 추상 클래스와 인터페이스를 사용하여 달성합니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상 클래스인 Animal은 사운드()라는 추상 메서드를 정의합니다. 이 메서드는 Dog 클래스에서 구현됩니다. Animal 클래스의 사용자로부터 사운드()의 구현 세부사항을 숨기고 필요한 기능만 노출시킵니다.\n\n## 2. 프로세스 추상화\n\n프로세스 추상화는 복잡한 프로세스나 작업을 간단하고 관리하기 쉬운 메서드로 추상화하는 것을 의미합니다. 이를 통해 복잡한 기능을 작은 재사용 가능한 메서드로 분해하는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```js\nclass MathOperations {\n  double calculateArea(double radius) {\n    return _calculateCircleArea(radius);\n  }\n\n  // 자세한 계산을 위한 비공개 메서드\n  double _calculateCircleArea(double radius) {\n    return 3.14 * radius * radius;\n  }\n}\n\nvoid main() {\n  var math = MathOperations();\n  print(math.calculateArea(5)); // 출력: 78.5\n}\n```\n\n여기서 MathOperations 클래스는 원의 넓이를 계산하는 과정을 \\_calculateCircleArea 비공개 메서드로 추상화합니다. 사용자는 내부 계산을 알 필요 없이 calculateArea 메서드와 상호작용할 수 있습니다.\n\n## 3. 공개 지정자를 사용한 추상화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDart에서의 공개 지정자는 클래스의 특정 부분을 노출시키면서 다른 부분을 숨길 때 사용됩니다. 이는 클래스의 명확한 인터페이스를 정의하는 데 중요하며 내부 상태를 보호하는 데 도움이 됩니다.\n\n예시:\n\n```js\nclass BankAccount {\n  String _accountNumber;\n  double _balance;\n\n  BankAccount(this._accountNumber, this._balance);\n\n  // 계좌 잔액을 얻기 위한 공개 메서드\n  double get balance =\u003e _balance;\n\n  // 돈을 입금하는 공개 메서드\n  void deposit(double amount) {\n    if (amount \u003e 0) {\n      _balance += amount;\n    }\n  }\n}\n\nvoid main() {\n  var account = BankAccount('123456789', 1000.0);\n  account.deposit(500);\n  print(account.balance); // 출력: 1500.0\n}\n```\n\n이 예시에서는 \\_accountNumber 및 \\_balance 변수가 비공개이지만 balance getter 및 deposit 메서드는 공개되어 있습니다. 이를 통해 잔액에 제한된 액세스권을 부여하면서 계좌 번호를 숨길 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4. 비공개 분류자를 사용한 추상화\n\n다트에서의 비공개 분류자는 클래스 내의 세부 사항을 캡슐화하여 클래스 외부에서 특정 속성 및 메서드에 액세스를 제한합니다.\n\n예시:\n\n```js\nclass Employee {\n  String _name;\n  double _salary;\n\n  Employee(this._name, this._salary);\n\n  // 직원 세부 정보를 얻는 공용 메서드\n  String getDetails() {\n    return 'Name: $_name, Salary: $_salary';\n  }\n\n  // 보너스 계산을 위한 비공용 메서드\n  double _calculateBonus() {\n    return _salary * 0.1;\n  }\n\n  // 보너스를 얻기 위한 공용 메서드\n  double get bonus =\u003e _calculateBonus();\n}\n\nvoid main() {\n  var employee = Employee('Alice', 50000);\n  print(employee.getDetails()); // 출력: Name: Alice, Salary: 50000\n  print(employee.bonus); // 출력: 5000.0\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예에서 \\_calculateBonus 메서드는 private이며 Employee 클래스 내에서만 액세스할 수 있습니다. 보너스 getter는 실제 계산 프로세스를 숨기고 계산된 보너스를 노출합니다.\n\n# 결론\n\nDart 및 Flutter 애플리케이션에서 깨끗하고 유지보수가능하며 확장 가능한 코드를 작성하는 데 OOP의 네 가지 기둥인 캡슐화, 상속, 다형성 및 추상화를 이해하는 것이 중요합니다. 또한 메서드 재정의와 오버로딩과 같은 개념을 이해하면 더 강력한 소프트웨어 솔루션을 설계하고 구현하는 능력이 향상됩니다. 이러한 개념을 숙달하여 OOP의 전체 능력을 활용하여 복잡하고 확장 가능한 애플리케이션을 구축할 수 있습니다.\n\n또한 Dart와 Flutter에서 다양한 유형의 상속을 이해하는 것은 효율적이고 유지보수 가능한 코드베이스를 설계하는 데 중요합니다. 상속을 효과적으로 활용하면 코드 재사용을 촉진하고 계층적 관계를 수립하고 쉽게 확장 가능한 애플리케이션을 구축할 수 있습니다. 간단한 클래스 계층 구조를 작성하거나 복잡한 객체 구조를 설계하든 상속은 Dart 및 Flutter 프로젝트의 아키텍처를 형성하는 데 중요한 역할을 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 댓글에 Dart와 Flutter에서의 OOP에 대한 생각과 경험을 자유롭게 공유해주세요!\n","ogImage":{"url":"/assets/img/2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter_0.png"},"coverImage":"/assets/img/2024-05-27-ADeepDiveObject-OrientedProgrammingOOPinDartandFlutter_0.png","tag":["Tech"],"readingTime":16},{"title":"iOS 인터뷰 질문-제7파","description":"","date":"2024-05-27 16:28","slug":"2024-05-27-iOSInterviewQuestions-Part7","content":"\nSwift, iOS, Xcode에 관한 인터뷰 질문\n\n![iOS Interview Questions Part7](/assets/img/2024-05-27-iOSInterviewQuestions-Part7_0.png)\n\n1. 옵셔널을 어떻게 생성할 수 있나요?\n\nSwift에서 옵셔널은 타입 앞에 ?를 추가하여 만들 수 있습니다. 예를 들어\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nvar name: String?\n\n# 2. What is optional Binding?\n\nOptional Binding은 옵셔널이 값을 포함하고 있는지 여부를 확인하는 데 사용됩니다. 값이 있는 경우 if let을 사용하여 상수나 변수에 그 값을 저장합니다. if 문 내에서 생성된 상수와 변수는 if 블록 내에서만 사용할 수 있습니다.\n\n우리는 옵셔널 값을 가져와서 논 옵셔널 상수에 연결할 것입니다. 우리는 If let 구조 또는 Guard 문을 사용합니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 옵셔널 체이닝이란 무엇인가요?\n\n옵셔널 체이닝은 현재 nil일 수 있는 옵셔널에서 속성, 서브스크립트 및 메소드를 조회하고 호출하기 위한 과정입니다. 옵셔널이 속성, 메소드 또는 서브스크립트 호출이 성공하면 해당 값이 반환됩니다. 옵셔널이 nil이면 모든 속성, 메소드 또는 서브스크립트 호출이 nil을 반환합니다. 여러 쿼리가 연결되어 있을 때 체인 중 하나의 링크가 nil이면 전체 체인이 안전하게 실패합니다.\n\n스위프트 프로그래밍 언어에서 옵셔널 체이닝은 속성을 조회하고 호출하는 과정입니다. 여러 쿼리를 체이닝할 수 있지만 체인 중 하나의 링크가 nil이면 전체 체인이 실패합니다.\n\n# 4. iOS 애플리케이션 개발에서 사용되는 디자인 패턴을 설명해 주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n본질적으로, 디자인 패턴은 전형적인 소프트웨어 문제를 해결하기 위해 반복적으로 적용할 수 있는 코드 솔루션입니다. 프로젝트에서 디자인 패턴을 사용하면 더 모듈식이고 확장 가능하며 최적화된 소프트웨어를 얻을 수 있습니다. 다른 사람들의 코드를 더 잘 이해할 수 있게 되어, 디자인 패턴을 즉시 인식할 수 있게 될 것입니다.\n\n디자인 패턴은 더 나은 소프트웨어를 만들기 위한 지침으로 사용되지 않습니다. 디자인 패턴과 최선의 방법은 전혀 다르기 때문입니다. 또한, 도전에 접근하는 방법에 대한 지침을 제공하기 위한 것이 아닙니다. 대신, 전형적인 엔지니어링 및 아키텍처 컨셉에 대한 관찰된 일반적인 응답을 문서화하는 데 주로 사용됩니다. 일반적인 디자인 패턴으로는 Facade, Decorator, Factory Method, Singleton 등이 있습니다.\n\n다음 디자인 패턴은 iOS 개발에서 주로 사용됩니다.\n\n- 생성 디자인 패턴 — Builder, Factory, Singleton.\n- 구조 디자인 패턴 — Decorator, Facade, Adapter.\n- 행동 디자인 패턴 — Observer, Memento.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. Swift에서 옵셔널 값을 해제하는 여러 방법은 무엇입니까?\n\n- Guard 문 (안전한 방법)\n- 옵셔널 바인딩 — 안전\n- 옵셔널 패턴 — 안전\n- 강제 언래핑 — \"!\" 연산자를 사용하여, 안전하지 않음\n- 옵셔널 체이닝 — 안전\n- nil 병합 연산자 — 안전\n- 암시적으로 언래핑된 변수 선언: 많은 경우 안전하지 않음\n\n# 6. Nil 병합 연산자\n\n??을 사용하여, 연산자의 왼쪽에 nil 값이 있으면 ?? 오른쪽의 값이 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7. iOS의 코어 데이터란 무엇인가요?\n\n코어 데이터는 애플이 제공하는 프레임워크로, 데이터를 저장, 검색, 삭제 및 수정하는 데 사용됩니다. 애플리케이션의 모델 레이어 객체를 관리하는 데 사용됩니다. 코어 데이터는 데이터베이스가 아닙니다. 코어 데이터의 데이터 모델 편집기를 사용하면 데이터 유형과 관계를 쉽게 정의하고 해당 클래스 정의를 생성할 수 있습니다.\n\n코어 데이터는 ORM(객체 관계 매핑)이나 객체-관계 매퍼가 아닙니다. 또한 데이터베이스도 아닙니다. 대신 코어 데이터는 객체 그래프 관리자로, 객체 그래프를 디스크에 지속성 저장할 수 있는 기능을 갖추고 있습니다.\n\n애플은 이렇게 말합니다: \"코어 데이터를 사용하여 애플리케이션의 오프라인 사용을 위한 영구 데이터를 저장하고, 임시 데이터를 캐시하며, 앱에서 단일 장치에서 취소 기능을 추가하세요.\" 😮\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코어 데이터는 지속성, 개별 또는 일괄적으로 변경 내용을 실행 취소 및 다시 실행, 백그라운드 데이터 작업, 뷰 동기화, 버전 및 이전 버전 마이그레이션 등의 기능을 제공합니다.\n\n프로젝트를 만들 때 \"코어 데이터 사용\"란 체크 박스를 선택하여 코어 데이터 모델을 만들 수 있습니다.\n\n코어 데이터 스택\n\n데이터 모델 파일을 만든 후, 앱의 모델 레이어를 지원하는 협업 클래스를 설정하십시오. 이러한 클래스들은 총칭하여 코어 데이터 스택이라고 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Core Data 구성 요소 몇 가지가 있습니다:\n\n- NSManagedObjectModel 인스턴스는 앱의 모델 파일을 나타내며 앱의 유형, 속성 및 관계를 설명합니다.\n- NSManagedObjectContext 인스턴스는 앱의 유형의 인스턴스에 대한 변경 사항을 추적합니다.\n- NSPersistentStoreCoordinator 인스턴스는 앱의 유형의 인스턴스를 저장소에서 저장하고 가져옵니다.\n- NSPersistentContainer 인스턴스는 한 번에 모델, 컨텍스트 및 저장소 코디네이터를 설정합니다.\n\n# 8. Core Data의 다른 데이터 유형\n\n많은 앱이 다양한 유형의 정보를 영속적으로 저장하고 표시해야 합니다. Core Data는 일반적인 데이터베이스에서 사용되는 Date 나 Decimal 유형과 같은 속성뿐만 아니라 Transformable 유형으로 처리되는 비표준 속성을 포함하여 다양한 속성을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 9. 관리 대상 객체 컨텍스트란 무엇인가요?\n\n관리 대상 객체 컨텍스트는 Core Data 응용 프로그램에서 단일 객체 공간 또는 스크래치 패드를 나타냽니다.\n\n# 10. 정적 바인딩과 동적 바인딩의 차이는 무엇인가요?\n\n정적 바인딩: 이벤트는 컴파일 시간에 발생합니다. 정적 바인딩에서 실행이 빠릅니다. 초기 바인딩이 있습니다. \"컴파일 시간\"에 해결됩니다. 메소드 오버로딩은 정적 바인딩의 예시입니다.\n동적 바인딩: 이벤트는 실행 시간에 발생합니다. 동적 바인딩에서 실행이 느립니다. 지연 바인딩이 있습니다. \"실행 시간\"에 가상 바인딩으로 해결됩니다. 메소드 오버라이딩은 동적 바인딩의 예시입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 11. Entity 상속은 무엇인가요?\n\nentity 상속은 클래스 상속과 유사하게 작동합니다. 때로는 많은 수의 엔티티가 있고 그 중 일부가 유사할 수 있습니다. 이 경우 공통 속성을 슈퍼타입으로 고려할 수 있고 이것을 부모 엔티티라고 말할 수 있습니다. 이는 하위 엔티티가 부모 엔티티를 상속할 때의 작업을 줄이는 데 도움이 됩니다.\n예: 이름이라는 엔티티를 정의했고 그 속성으로 이름과 성을 가지고 있는데, 하위 엔티티인 직원과 고객은 이러한 속성을 상속할 수 있습니다.\n\n# 12. Core Data에서는 멀티스레딩이 가능할까요?\n\n네, Core Data에서 멀티스레딩이 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 13. Deinit이란 무엇인가요?\n\nDeInitializer는 클래스의 인스턴스가 확보 해제되기 직전에 호출됩니다. DeInitializer에서 사용하는 키워드는 초기화에 사용되는 Init 키워드와 유사한 deinit입니다. 중요한 점은 DeInitializer가 구조체 타입이 아닌 클래스 타입에만 사용 가능하다는 것입니다.\n\n# 14. reuseIdentifier의 목적은 무엇인가요?\n\n이미 할당된 객체의 재사용성입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`reuseIdentifier`은 UITableView에서 모든 비슷한 행을 그룹화하는 데 사용됩니다.\n\n### 15. UITableView를 처음으로로드할 때 몇 개의 UITableViewCells가 할당되나요? 테이블을 스크롤하면 몇 개가 더 할당되나요?\n\nUITableView는 일반적으로 테이블에서 보이는 내용을 표시할만큼의 UITableViewCell 객체만 할당합니다. reuseIdentifier 덕분에 UITableView는 뷰로 스크롤되는 각 새로운 항목마다 새로운 UITableViewCell 객체를 할당하지 않아 렉이 걸리는 애니메이션을 피할 수 있습니다.\n\n### 16. UITableViewCell 생성자에서 재사용 식별자를 왜 사용하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 재사용할 식별자를 설정하지 않으면 TableView는 새로운 UITableViewCell을 할당하도록 강제합니다.\n재사용 식별자의 사용 목적은 비슷한 행 내용을 UITableView에서 그룹화하는데 사용되지만 데이터 내용은 다를 수 있습니다.\n\n## 17. 제네릭이란 무엇이며 어떤 문제를 해결하나요?\n\n제네릭 코드는 재사용 가능하고 유연한 함수 및 어떤 유형이라도 작동할 수 있는 유형을 작성할 수 있도록 돕습니다. 제네릭은 Swift 언어의 가장 강력한 기능입니다.\n\n## 18. Objective-C에서 @synthesize란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`@synthesize`는 컴파일러에게 변수에 대한 setter와 getter 프로퍼티를 생성하도록 하는 것이에요.\n\n# 19. ARC란 무엇인가요? Swift에서 어떻게 메모리를 관리하는 데 도움이 되나요? 그 기능을 설명하기 위한 예시를 제시해 주세요.\n\nARC (Automatic Reference Count)는 iOS 애플리케이션에서 사용되며 애플리케이션 메모리를 추적하고 관리하는 데 도움을 줘요. Arc는 클래스 인스턴스가 더 이상 필요하지 않을 때 클래스 인스턴스가 보유한 메모리를 자동으로 해제해 줘요.\n\n```swift\nclass Person {\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n명함: 문자열\n\ninit(이름: 문자열) '\n\nself.name = name\n\nprint(“\\(이름)이(가) 초기화되고 있습니다.”)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n' deinit '\n\nprint(\"\\\"\\(name) is being deinitialized.\\\"\")\n\n'\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nvar person1: Person? = Person(name: “Alice”)\n\nvar person2: Person? = person1 // person1 and person2 now both reference the same Person instance\n\nperson1 = nil // The reference count of the Person instance decreases to 1\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nperson2 = nil // Person 인스턴스의 참조 카운트가 0으로 감소하고 인스턴스가 해제됩니다.\n\n이 예에서 person1과 person2가 동일한 Person 인스턴스에 할당될 때 참조 카운트가 2가 됩니다. person1과 person2가 모두 nil로 설정되면 참조 카운트가 0으로 떨어지고 Person 인스턴스가 해제되어 deinitializer가 트리거됩니다.\n\n# 20. 라이브 렌더링이란?\n\n인터페이스 빌더에서 사용되는 속성인 IBDesignable 및 IBInspectable은 특정 속성(색상/폭/그림자 및 테두리와 같은)이 스토리보드에서 라이브로 구성될 수 있도록 도와주며 인터페이스 빌더에서 해당 요소를 직접 렌더링하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 21. ‘assign’와 ‘retain’ 키워드의 차이점을 설명해주세요.\n\nRetain — 객체 할당 시 retain을 호출해야 함을 명시합니다. 객체의 소유권을 가져갑니다.\n\nAssign — 세터가 단순 할당을 사용한다는 것을 명시합니다. float, int와 같은 스칼라 유형의 속성에 사용됩니다.\n\n# 22. iBeacons이란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niBeacon.com에서는 iBeacon을 Apple의 기술 표준으로 정의하며, 이를 통해 Mobile Apps이 물리적 세계에서 비콘에서 신호를 수신하고 그에 맞게 반응할 수 있습니다. iBeacon 기술을 통해 Mobile Apps은 마이크로 로컬 스케일에서 위치를 이해하고 위치에 기반한 하이퍼 컨텍스트 콘텐츠를 사용자에게 제공할 수 있습니다. 기술은 Bluetooth Low Energy를 기반으로 합니다.\n\nApple의 Bluetooth Low Energy(BLE) 무선 기술인 iBeacon은 iPhones 및 기타 iOS 사용자가 위치 기반 정보와 서비스를 받는 새로운 방법입니다.\n\n# 23. Autorelease란 무엇인가요?\n\n객체에 autorelease 메시지를 보내면 해당 객체는 로컬 AutoReleasePool에 추가됩니다. 그렇기 때문에 더 이상 해당 객체를 신경 쓸 필요가 없습니다. AutoReleasePool이 소멸될 때 (주 실행 루프에서), 해당 객체는 릴리스 메시지(참조 횟수가 하나 감소)를 받으며, RetainCount가 0이되면 가비지 수집기가 해당 객체를 제거합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n릴리스: `release` 메시지를 객체에 보낼 때 보유 카운트가 하나 감소합니다.\n\n## 24. autorelease pool이란 무엇인가요?\n\n객체에 `autorelease`가 보내질 때마다, 해당 객체는 가장 내부에 있는 autorelease 풀에 추가됩니다. 풀이 비워질 때, 풀에 있는 모든 객체에 대해 간단히 `release` 메시지를 보냅니다. `@autoreleasepool` 블록을 활용합니다.\n\nautorelease 풀은 `release` 메시지를 \"나중에\"까지 보낼 수 있게 해주는 편의 기능입니다. 이 \"나중에\"는 여러 곳에서 발생할 수 있지만, Cocoa GUI 애플리케이션에서 가장 흔한 시점은 현재 런 루프 사이클의 끝입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 25. 블록에서 변수에 액세스하는 방법은?\n\n\\_\\_block 저장 유형을 사용하면 됩니다.\n\n만약 이 글을 즐겁게 읽으셨다면 공유하고 박수를 두드려주세요 👏🏻👏🏻👏🏻👏🏻👏🏻\n\n또한 저와 연락할 수도 있습니다 📲\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그를 변경해 주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아무 의견, 질문 또는 추천이 있으시면 아래 댓글 섹션에 자유롭게 남겨주세요💬\n\n💁🏻‍♀️ 즐거운 코딩하세요!\n\n감사합니다😊\n\nSwiftfy를 팔로우하여 더 많은 업데이트를 받아보세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 많은 기사를 보고 싶다면 참고하세요:\n","ogImage":{"url":"/assets/img/2024-05-27-iOSInterviewQuestions-Part7_0.png"},"coverImage":"/assets/img/2024-05-27-iOSInterviewQuestions-Part7_0.png","tag":["Tech"],"readingTime":14},{"title":"스위프트에서의 프로토콜 지향 프로그래밍 디자인 패턴과 최선의 광고","description":"","date":"2024-05-27 16:27","slug":"2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices","content":"\n\u003cimg src=\"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png\" /\u003e\n\n소개\n\n프로토콜 지향 프로그래밍(POP)은 스위프트 개발에서 핵심 패러다임 중 하나로 자리 잡았으며, 전통적인 객체지향 프로그래밍에 강력한 대안을 제공합니다. 프로토콜에 주목함으로써, 스위프트는 개발자들이 유연하고 재사용 가능하며 테스트 가능한 코드를 작성할 수 있게 해줍니다. 이 글에서는 프로토콜 지향 프로그래밍의 원칙을 탐구하고, 일반적인 디자인 패턴을 살펴보며, 스위프트에서 프로토콜을 통해 견고한 애플리케이션을 구축하는 데 가장 좋은 방법을 논의할 것입니다.\n\n왜 프로토콜 지향 프로그래밍을 해야 할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPOP은 작업이나 기능에 대한 청사진을 정의하는 데 프로토콜 사용을 장려합니다. 이 접근 방식은 여러 가지 이점을 제공합니다:\n\n- 유연성: 프로토콜을 사용하면 타입이 여러 프로토콜을 준수하도록 하여 보다 유연한 아키텍처를 구축할 수 있습니다.\n- 재사용성: 공통 기능은 프로토콜에 정의하고 다양한 타입 간에 재사용할 수 있습니다.\n- 테스트 용이성: 프로토콜은 의존성 주입을 용이하게 하여 단위 테스트에서 의존성을 가짜로 대체하기 쉽습니다.\n- 결합도 낮추기: 프로토콜은 인터페이스를 정의함으로써 코드를 결합도 낮추며 구체적인 구현 대신 인터페이스를 정의합니다. 역할 분리를 촉진합니다.\n\n프로토콜을 활용하기\n기본 프로토콜 정의\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n프로토콜 Drivable {\n    var speed: Double { get }\n    func drive()\n}\n\n구조체 Car: Drivable {\n    var speed: Double\n\n    func drive() {\n        print(\"속도: \\(speed) km/h로 주행 중\")\n    }\n}\n\nlet car = Car(speed: 120)\ncar.drive()  // 출력: 속도: 120.0 km/h로 주행 중\n```\n\n이 예제에서는 speed 속성과 drive 메서드가 있는 Drivable 프로토콜을 정의합니다. Car 구조체는 Drivable 프로토콜을 준수하며 필요한 속성과 메서드를 구현합니다.\n\n프로토콜 익스텐션\n\n프로토콜 익스텐션을 사용하여 프로토콜 메서드에 대한 기본 구현을 제공할 수 있으며 주어진 유형의 기능을 확장할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로토콜 확장 예제\n\n```swift\nprotocol Drivable {\n    var speed: Double { get }\n    func drive()\n}\n\nextension Drivable {\n    func drive() {\n        print(\"Driving at \\(speed) km/h\")\n    }\n\n    func stop() {\n        print(\"Stopped.\")\n    }\n}\n\nstruct Car: Drivable {\n    var speed: Double\n}\n\nlet car = Car(speed: 120)\ncar.drive()  // 출력: 120.0 km/h로 주행 중\ncar.stop()   // 출력: 정지됨\n```\n\n여기에는 프로토콜 확장 내에서 drive 메서드에 대한 기본 구현이 있습니다. 또한 모든 준수하는 타입이 추가 구현없이 사용할 수 있는 새로운 stop 메서드가 도입되었습니다.\n\n프로토콜 조합\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스위프트를 사용하면 여러 프로토콜을 조합하여 타입이 조합된 프로토콜을 준수할 수 있습니다.\n\n프로토콜 조합 예시\n\n```js\nprotocol Drivable {\n    var speed: Double { get }\n    func drive()\n}\n\nprotocol Flyable {\n    var altitude: Double { get }\n    func fly()\n}\n\nstruct FlyingCar: Drivable, Flyable {\n    var speed: Double\n    var altitude: Double\n\n    func drive() {\n        print(\"Driving at \\(speed) km/h\")\n    }\n\n    func fly() {\n        print(\"Flying at \\(altitude) meters\")\n    }\n}\n\nlet flyingCar = FlyingCar(speed: 120, altitude: 1000)\nflyingCar.drive()  // 출력: Driving at 120.0 km/h\nflyingCar.fly()    // 출력: Flying at 1000.0 meters\n```\n\n이 예시에서 FlyingCar 구조체는 Drivable 및 Flyable 프로토콜을 모두 준수하며, 프로토콜 조합이 복잡한 기능을 가능하게 함을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로토콜 중심의 디자인 패턴\n\n1. 전략 패턴\n\n전략 패턴은 알고리즘들의 집합을 정의하고 각각을 캡슐화하여 교환 가능하게 만듭니다. Swift에서 이 패턴을 구현하는 데는 프로토콜이 이상적입니다.\n\n전략 패턴 예시\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n프로토콜 PaymentStrategy {\n    func pay(amount: Double)\n}\n\n구조체 CreditCardPayment: PaymentStrategy {\n    func pay(amount: Double) {\n        print(\"\\(amount) 금액으로 신용카드를 사용해 결제했습니다\")\n    }\n}\n\n구조체 PayPalPayment: PaymentStrategy {\n    func pay(amount: Double) {\n        print(\"\\(amount) 금액으로 PayPal을 사용해 결제했습니다\")\n    }\n}\n\n구조체 ShoppingCart {\n    var paymentStrategy: PaymentStrategy\n\n    func checkout(amount: Double) {\n        paymentStrategy.pay(amount: amount)\n    }\n}\n\nlet creditCardPayment = CreditCardPayment()\nlet payPalPayment = PayPalPayment()\n\nvar cart = ShoppingCart(paymentStrategy: creditCardPayment)\ncart.checkout(amount: 100)  // 결과: 100.0 금액으로 신용카드를 사용해 결제했습니다\ncart.paymentStrategy = payPalPayment\ncart.checkout(amount: 200)  // 결과: 200.0 금액으로 PayPal을 사용해 결제했습니다\n```\n\n여기서 PaymentStrategy 프로토콜은 결제를 위한 메서드를 정의합니다. 다양한 결제 전략(CreditCardPayment과 PayPalPayment)이 이 프로토콜을 준수합니다. ShoppingCart은 전략을 사용하여 결제를 수행하며, 결제 방법을 동적으로 전환할 수 있습니다.\n\n2. 의존성 주입\n\n의존성 주입(Dependency Injection, DI)은 IoC(제어의 역전)를 구현하는 데 사용되는 디자인 패턴으로, 클래스가 내부적으로 생성하는 대신 외부 소스에서 의존성을 받을 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성 주입을 사용한 예제\n\n```js\nprotocol DataService {\n    func fetchData() -\u003e String\n}\n```\n\n```js\nstruct APIService: DataService {\n    func fetchData() -\u003e String {\n        return \"API에서 데이터를 가져왔습니다\"\n    }\n}\nstruct MockService: DataService {\n    func fetchData() -\u003e String {\n        return \"모의 데이터입니다\"\n    }\n}\nstruct DataManager {\n    var service: DataService\n    func getData() -\u003e String {\n        return service.fetchData()\n    }\n}\nlet apiService = APIService()\nlet mockService = MockService()\nlet dataManager = DataManager(service: apiService)\nprint(dataManager.getData())  // 출력: API에서 데이터를 가져왔습니다\nlet testManager = DataManager(service: mockService)\nprint(testManager.getData())  // 출력: 모의 데이터입니다\n```\n\n이 예제에서는 DataService 프로토콜이 데이터를 가져오는 메서드를 정의합니다. APIService와 MockService 구조체는 이 프로토콜을 준수하여 다른 구현을 제공합니다. DataManager는 데이터를 가져오기 위해 DataService에 의존하며, 실제 서비스와 테스트를 위한 모의 서비스를 쉽게 변경할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로토콜 지향 프로그래밍의 Best Practices\n\n- 상속 대신 구성 사용: 클래스 상속에 의존하는 대신 프로토콜을 사용하여 함께 조합할 수 있는 재사용 가능한 동작을 정의하세요.\n- 작고 집중된 프로토콜 정의: 프로토콜을 단일 책임 원칙(SRP)을 준수하며 집중시켜 작고 집중된 상태로 유지하세요. 이렇게 하면 이해하고 구현하기 쉬워집니다.\n- 프로토콜 익스텐션 올바르게 활용: 프로토콜 익스텐션에서 일반적인 동작에 대한 기본 구현을 제공하지만 오버라이드할 필요가 있는 로직을 너무 많이 포함하지 않도록 주의하세요.\n- 프로토콜 조합 활용: 여러 프로토콜을 결합하여 유연하고 모듈식 설계를 만드세요.\n- 프로토콜 및 익스텐션 문서화: 프로토콜과 그 익스텐션의 의도된 사용 및 요구 사항을 명확히 문서화하여 올바르게 사용되도록 하세요.\n\n결론\n\nSwift에서의 프로토콜 지향 프로그래밍은 유연하고 재사용 가능하며 테스트 가능한 코드를 작성하는 강력한 방법을 제공합니다. 프로토콜 및 그 조합에 집중함으로써 관심사 분리를 촉진하고 유지보수성을 향상시키는 견고한 아키텍처를 만들 수 있습니다. Strategy 및 Dependency Injection과 같은 디자인 패턴을 구현하거나 프로토콜 익스텐션을 사용하여 기본 동작을 활용하는 경우, 프로토콜 지향 프로그래밍을 도입하면 Swift 개발 기술을 크게 향상시킬 수 있습니다. 프로토콜의 힘을 받아 코드를 더 높은 수준으로 발전시키세요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png"},"coverImage":"/assets/img/2024-05-27-Protocol-OrientedProgramminginSwiftDesignPatternsandBestPractices_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI Photo Picker 앱을 PhotosUI로 만들기","description":"","date":"2024-05-27 16:26","slug":"2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI","content":"\n![이미지](/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png)\n\nSwiftUI와 PhotosUI는 iOS 앱에서 풍부하고 인터랙티브한 사용자 인터페이스를 만드는 강력한 도구를 제공합니다. 이 튜토리얼에서는 사용자가 사진 라이브러리에서 사진을 선택하고 표시할 수 있는 앱을 만들겠습니다.\n\n# 프로젝트 설정\n\n- Xcode를 열고 새 SwiftUI 프로젝트를 생성합니다.\n- 프로젝트의 이름을 지정합니다 (예: \"PhotoPickerApp\").\n- 사용자 인터페이스로 SwiftUI를 선택하고 프로그래밍 언어로 Swift를 선택해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 코드 설명\n\n## 단계 1: 필요한 프레임워크 가져오기\n\n```js\nimport SwiftUI\nimport PhotosUI\n```\n\n- SwiftUI: 사용자 인터페이스를 구축하기 위한 프레임워크입니다.\n- PhotosUI: 사진 및 비디오 선택 및 관리를 위한 프레임워크입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2: 상태 변수 정의\n\n```js\nstruct ContentView: View {\n   @State private var selectedPhotos: [PhotosPickerItem] = []\n   @State private var images: [UIImage] = []\n   @State private var errorMessage: String?\n\n   // ... 나머지 코드\n}\n```\n\n- selectedPhotos: 선택된 사진 항목을 저장합니다.\n- images: 불러온 이미지를 저장합니다.\n- errorMessage: 발생한 오류 메시지를 저장합니다.\n\n## 단계 3: 메인 뷰 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nvar body: some View {\n    VStack {\n        Form {\n            photoPickerSection\n            imagesSection\n        }\n        if let errorMessage = errorMessage {\n            Text(errorMessage)\n                .foregroundColor(.red)\n                .padding()\n        }\n    }\n}\n```\n\n- VStack: 폼과 에러 메시지를 포함합니다.\n- Form: 사진 선택기와 이미지를 위한 섹션을 포함합니다.\n\n## 단계 4: 사진 선택기 섹션 정의\n\n```swift\nprivate var photoPickerSection: some View {\n    Section {\n        PhotosPicker(selection: $selectedPhotos, maxSelectionCount: 3, matching: .images) {\n            Label(\"사진 선택\", systemImage: \"photo\")\n        }\n        .onChange(of: selectedPhotos) { _ in\n            loadSelectedPhotos()\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- PhotosPicker: 사진을 선택하는 UI 구성 요소입니다.\n- selection: `selectedPhotos`에 바인딩됩니다.\n- maxSelectionCount: 선택을 3개의 사진으로 제한합니다.\n- matching: 이미지로 제한된 선택을 합니다.\n- .onChange: `selectedPhotos`이 변경될 때 `loadSelectedPhotos`를 호출합니다.\n\n## 단계 5: 이미지 섹션 정의하기\n\n```js\nprivate var imagesSection: some View {\n    Section {\n        ForEach(images, id: \\.self) { image in\n            Image(uiImage: image)\n                .resizable()\n                .scaledToFit()\n                .frame(maxWidth: .infinity)\n                .clipShape(RoundedRectangle(cornerRadius: 10.0))\n                .padding(.vertical, 10)\n        }\n    }\n}\n```\n\n- ForEach: `images` 배열을 반복합니다.\n- Image(uiImage:): 각 이미지를 표시합니다.\n- .resizable(), .scaledToFit(), .frame(maxWidth: .infinity), .clipShape(), .padding(): 이미지를 스타일링합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 6: 선택한 사진 불러오기\n\n```js\nprivate func loadSelectedPhotos() {\n    images.removeAll()\n    errorMessage = nil\n\n    Task {\n        await withTaskGroup(of: (UIImage?, Error?).self) { taskGroup in\n            for photoItem in selectedPhotos {\n                taskGroup.addTask {\n                    do {\n                        if let imageData = try await photoItem.loadTransferable(type: Data.self),\n                           let image = UIImage(data: imageData) {\n                            return (image, nil)\n                        }\n                        return (nil, nil)\n                    } catch {\n                        return (nil, error)\n                    }\n                }\n            }\n\n            for await result in taskGroup {\n                if let error = result.1 {\n                    errorMessage = \"한 개 이상의 이미지를 불러오지 못했습니다.\"\n                    break\n                } else if let image = result.0 {\n                    images.append(image)\n                }\n            }\n        }\n    }\n}\n```\n\n- images.removeAll(): 기존 이미지를 지웁니다.\n- errorMessage = nil: 오류 메시지를 초기화합니다.\n- Task: 비동기 작업을 시작합니다.\n- withTaskGroup: 사진을 로드하는 동시 작업을 관리합니다.\n- photoItem.loadTransferable(type: Data.self): 사진 데이터를 로드합니다.\n- UIImage(data: imageData): 데이터를 `UIImage`로 변환합니다.\n- errorMessage: 오류 발생 시 업데이트됩니다.\n- images.append(image): 로드된 이미지를 배열에 추가합니다.\n\n## 단계 7: 뷰 미리보기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Preview {\n    ContentView()\n}\n```\n\n- # Preview: Xcode 캔버스에서 `ContentView`를 미리 볼 수 있습니다.\n\n# 프로젝트 실행\n\n이제 프로젝트를 시뮬레이터나 실제 장치에 실행하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](https://miro.medium.com/v2/resize:fit:720/1*AtvjZ8d79WvKb85R-jBVVg.gif)\n\n# 요약\n\n이 튜토리얼은 사용자가 사진을 선택하고 표시할 수 있는 SwiftUI 앱을 만드는 방법을 안내했습니다. 상태 관리, 비동기 작업 및 이미지 처리를 다루었습니다. 이 앱은 사진 편집, 저장 또는 공유와 같은 추가 기능으로 확장할 수 있습니다. SwiftUI와 PhotosUI를 활용하여 앱의 기능과 사용자 경험을 향상시켜 보세요.\n\n즐거운 코딩되세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 완성된 코드\n\n이 저장소를 복제하거나 다운로드하여 완전한 코드를 확인하십시오.\n","ogImage":{"url":"/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png"},"coverImage":"/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png","tag":["Tech"],"readingTime":7},{"title":"SwiftUI 얼럿alerts 사용 방법","description":"","date":"2024-05-27 16:25","slug":"2024-05-27-SwiftUIHowtousealerts","content":"\n\u003cimg src=\"/assets/img/2024-05-27-SwiftUIHowtousealerts_0.png\" /\u003e\n\n이 기사는 .alert()를 사용하여 사용자에게 뭔가를 확인하라는 팝업을 표시하는 방법을 보여줍니다.\n이것을 사용하는 방법은 iOS 15 이후 많이 변경되었습니다.\niOS 14 및 이전 버전의 알림을 사용하는 방법에 대한 자세한 정보는 아래를 참조하세요.\n\n- Environment\n- Basic Usage\n- Example of Use\n- Install Multiple Buttons\n- Specifying Button Display Style\n- Example of Use\n- Use Multiple Alerts\n\n# 환경\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사는 다음 버전을 사용합니다:\n\n- **Xcode** 13.0\n- **Swift** 5.5\n- **iOS** 15.0\n- **macOS** Big Sur 버전 11.6\n\n## 기초 사용법\n\nSwiftUI에서 코딩은 선언적이며 절차적이 아닙니다. 경고(alerts)도 이 규칙을 따릅니다. \"알림을 표시\"하는 단계별 프로세스를 코딩하는 대신, 경고를 정의하고 언제 나타날지를 정의합니다. 경고를 정의하려면 .alert() 수정자(modifier)를 사용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n.alert(\"제목\", isPresented: Binding\u003cbool\u003e, actions: { 액션 버튼 목록 }, message: { 메시지 })\n```\n\n또는\n\n```js\n.alert(\"제목\", isPresented: Binding\u003cbool\u003e) {\n     // 액션 버튼 목록\n} message: {\n     // 메시지\n}\n```\n\n“제목”\n제목에 표시할 텍스트를 지정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nisPresented\n알림이 표시될지를 결정하는 표시 플래그 변수입니다. 사용자가 알림 액션을 탭하면 표시 플래그가 자동으로 거짓으로 변경됩니다.\n\nActions\nButton() 목록을 사용하여 알림에 표시할 작업 버튼을 나열합니다. 특정 작업이 없는 경우 \"OK\" 버튼이 기본으로 표시됩니다. 알림의 모든 버튼은 닫히며, 표시 플래그를 거짓으로 설정합니다.\n\nmessages (선택 사항)\nText를 사용하여 제목 아래에 자세한 메시지를 설정할 수 있습니다. 그러나 스타일을 적용하거나 여러 Text를 표시할 수는 없습니다.\n\n# 사용 예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 Button에 대해 alert 수정자가 설정되어 있지만, 직접적으로 해당 Button에 연결되어 있지는 않습니다. 경고는 Button 자체가 아닌 표시 플래그에 의해 제어됩니다.\n\n```js\nimport SwiftUI\n\nstruct AlertsBootCamp: View {\n\n    // MARK: - 속성\n    @State private var isShowAlert: Bool = false\n\n    // MARK: - 본문\n    var body: some View {\n        Button(action: {\n           isShowAlert = true\n        }, label: {\n            Text(\"알림 표시\")\n                .font(.headline)\n                .fontWeight(.bold)\n                .foregroundStyle(.white)\n                .padding()\n                .background(content: {\n                    RoundedRectangle(cornerRadius: 25.0, style: .continuous)\n                        .foregroundStyle(Color.black)\n                })\n        })\n        .alert(\"제목\", isPresented: $isShowAlert) {\n            Button(\"눌러주세요\") {\n                // 버튼이 눌릴 때 수행되는 작업\n            }\n        } message: {\n            Text(\"메시지\")\n        }\n    }\n}\n```\n\n![이미지](/assets/img/2024-05-27-SwiftUIHowtousealerts_1.png)\n\n# 여러 버튼 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport SwiftUI\n\nstruct AlertsBootCamp: View {\n\n    // MARK: - Properties\n    @State private var isShowAlert: Bool = false\n\n    // MARK: - Body\n    var body: some View {\n        Button(action: {\n           isShowAlert = true\n        }, label: {\n            Text(\"Display Alert\")\n                .font(.headline)\n                .fontWeight(.bold)\n                .foregroundStyle(.white)\n                .padding()\n                .background(content: {\n                    RoundedRectangle(cornerRadius: 25.0, style: .continuous)\n                        .foregroundStyle(Color.black)\n                })\n        })\n        .alert(\"Title\", isPresented: $isShowAlert) {\n            Button(\"Button 1\") {\n                // button 1 action will come here\n            }\n            Button(\"Button 2\") {\n                // button 2 action will come here\n            }\n        } message: {\n            Text(\"Message\")\n        }\n    }\n}\n```\n\n두 개의 버튼이 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-27-SwiftUIHowtousealerts_2.png\" /\u003e\n\n세 개 이상 설치하시면 아래와 같이 수직으로 배열됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3개의 버튼이 있는 테이블을 만들려면\n다음 Markdown 형식을 사용하실 수 있습니다.\n\n| Header1 | Header2 | Header3 |\n| ------- | ------- | ------- |\n| Data1   | Data2   | Data3   |\n| Data4   | Data5   | Data6   |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nButton(\"Title\", role: ButtonRole?, action: { action button })\n```\n\n3가지 유형을 지정할 수 있습니다:\n\n1. 취소\n\n2. 파괴성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 아무 값도 지정하지 않으면 버튼은 기본 스타일인 파란색으로 나타납니다.\n\n.cancel\n취소 버튼은 진한 파란색으로 스타일이 지정됩니다. 버튼이 두 개인 경우 항상 왼쪽에 위치하며, 세 개 이상인 경우에는 맨 아래에 위치합니다.\n\n.destructive\n이 스타일은 삭제와 같은 파괴적인 작업을 나타내며 빨간색으로 표시됩니다. 적어도 하나의 이 유형 버튼이 있는 경우 취소 버튼이 자동으로 추가됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 사용 예시\n\n버튼에 .destructive 역할을 부여하면 자동으로 취소 버튼이 추가됩니다.\n\n```js\nimport SwiftUI\n\nstruct AlertsBootCamp: View {\n\n    // MARK: - Properties\n    @State private var isShowAlert: Bool = false\n\n    // MARK: - Body\n    var body: some View {\n        Button(action: {\n            isShowAlert = true\n        }, label: {\n            Text(\"알림 표시\")\n                .font(.headline)\n                .fontWeight(.bold)\n                .foregroundStyle(.white)\n                .padding()\n                .background(content: {\n                    RoundedRectangle(cornerRadius: 25.0, style: .continuous)\n                        .foregroundStyle(Color.black)\n                })\n        })\n        .alert(\"제목\", isPresented: $isShowAlert) {\n\n            Button(\"삭제\", role: .destructive) {\n                // 동작이 여기에 들어갑니다.\n            }\n        } message: {\n            Text(\"메시지\")\n        }\n    }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-SwiftUIHowtousealerts_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 여러 경고 사용하기\n\n한 화면에 여러 경고를 사용하려면 여러 디스플레이 플래그 변수를 사용하세요.\niOS14 이전에는 특별한 조치가 필요했습니다.\n\n```js\nstruct ContentView: View {\n\n    // MARK: - Properties\n    @State private var isShowAlert1: Bool = false\n    @State private var isShowAlert2: Bool = false\n\n    // MARK: - Body\n    var body: some View {\n        VStack {\n            Button(\"경고 1 표시\") { isShowAlert1 = true }\n            Button(\"경고 2 표시\") { isShowAlert2 = true }\n        }\n        .alert(\"경고 1\", isPresented: $isShowAlert1) { }\n        .alert(\"경고 2\", isPresented: $isShowAlert2) { }\n    }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:590/1*y3FoT4bWzWZcph2TnxqMzg.gif\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-27-SwiftUIHowtousealerts_0.png"},"coverImage":"/assets/img/2024-05-27-SwiftUIHowtousealerts_0.png","tag":["Tech"],"readingTime":9},{"title":"Swift 동시성 뒤엉킨 것들 풀어내기","description":"","date":"2024-05-27 16:24","slug":"2024-05-27-SwiftConcurrencyUn-tangledup","content":"\n\u003cimg src=\"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png\" /\u003e\n\nSwift 5.5부터는 concurrent programming을 위해 async/await 접근 방식이 도입되어 비동기 작업 관리가 변경되었습니다. 이 방식은 올바르게 구현할 때 많은 이점을 제공하며 고려해야 할 사항도 몇 가지 있습니다.\n\n# 이것은 무엇인가요?\n\nConcurrency는 concurrent code를 처리하는 도구를 제공하는 라이브러리로, 이러한 도구는 쓰레드를 다룰 때 안전성을 제공하기 위한 것입니다. 이는 쓰레드를 관리할 때 발생하는 모든 종류의 문제를 포함하며, 흔한 문제 몇 가지를 들자면 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터 레이스(Data races). 여러 스레드가 동시에 동일한 데이터 조각에 액세스하여 조작하려고 할 때 발생합니다.\n- 데드락(Deadlocks). 여러 스레드가 서로가 완료되기를 기다리고 계속 지장을 일으킬 때 발생합니다.\n- 우선순위 역전(Priority inversion). 낮은 우선순위 작업이 높은 우선순위 작업의 실행을 차단할 때 발생합니다.\n\n## 병렬성 vs 순차성\n\n예제를 시작하기 전에, 이 주제 아래에서 두 가지 개념, 병렬성과 순차성을 이해해야 합니다.\n\n- 병렬 코드는 다른 작업이 끝나기를 기다릴 필요 없이 동시에 실행될 수 있는 코드입니다.\n- 순차 코드는 이전 결과가 완료되어야 다음 작업을 계속할 수 있는 코드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 구현 방법\n\n## 비동기 및 대기\n\n이 프레임워크는 두 가지 주요 키워드 async와 await를 사용합니다. 각각은 다른 목적으로 사용됩니다.\n\n- Async는 비동기 작업을 표시하는 데 주로 사용되며, 작업 내에서 가능한 비동기 기능을 노출하는 데도 사용됩니다. 다시 말해, async 메서드 안에는 비동기 작업이 포함될 수 있습니다.\n- Await은 현재 컨텍스트의 실행이 중지될 수 있는 가능성이 있는 중단 지점을 표시하는 데 사용되며, 그 시간 동안 리소스를 사용하여 다른 작업을 수행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 일반적인 데이터 가져오기 방법은 완료될 때까지 시간이 걸릴 수 있습니다. 왜냐하면 로컬이거나 클라우드인 데이터베이스에 도달해야 하기 때문이죠.\n\n```js\nfunc fetchData(completion: @escaping (Result\u003cData, Error\u003e) -\u003e Void) {\n    let url = URL(string: \"https://itunes.apple.com/search/media=music\u0026entity=song\u0026term=avicii\")!\n\n    URLSession.shared.dataTask(with: url) { data, response, error in\n        if let error {\n            return completion(.failure(error))\n        }\n        guard let data else {\n            return completion(.failure(URLError(.unknown)))\n        }\n        return completion(.success(data))\n    }.resume() // 항상 세션 작업을 재개하는 것을 기억하세요 :)\n}\n\nfetchData { result in\n    switch result {\n    case let .success(data):\n        print(\"Itunes 정보를 가져왔습니다: \\(data.description)\")\n    case let .failure(error):\n        print(\"문제가 발생했습니다: \\(error.localizedDescription)\")\n    }\n}\n\n// 출력: \"Itunes 정보를 가져왔습니다: 80075 bytes\"\n```\n\n이는 원격 서버에서 정보를 가져오는 비동기 작업을 완료하기 위해 기다리는 일반적인 패턴입니다. 완료 핸들러는 한 번 작업이 완료되면 호출되는 익명 함수(클로저)입니다. 그러나 이러한 패턴은 중첩된 클로저로 코드베이스를 쉽게 더럽힐 수 있습니다(콜백 지옥).\n\n비동기/대기 접근 방식을 사용하면 다음과 같이 개선될 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모든 시간이 걸릴 수 있는 작업 또는 다른 시간이 많이 소요되는 작업을 async로 표시하여 컴파일러가 가능한 비동기 작업을 알 수 있게 합니다.\n- await로 가능한 중단 지점을 찾아보세요. 이 경우 URLSession은 이미 async/await 버전의 dataTask(with:)를 제공합니다. async context 내에서 사용할 수 있으며 완료까지 시간이 소요됩니다.\n- 처리될 함수를 async context 내에서 호출하세요.\n\n```js\nfunc fetchData() async throws -\u003e Data { // 1\n    let url = URL(string: \"https://itunes.apple.com/search/media=music\u0026entity=song\u0026term=avicii\")!\n    let (data, _) = try await URLSession.shared.data(from: url) // 2\n    return data\n}\n\nTask { // 3\n    do {\n        let data = try await fetchData()\n        print(\"Itunes info has been retreived: \\(data.description)\")\n    } catch {\n        print(\"Something went wrong: \\(error.localizedDescription)\")\n    }\n}\n```\n\n여기 몇 가지 향상된 점이 있습니다:\n\n- 오류가 발생할 수 있는 가능성을 나타내기 위해 throws를 사용하세요.\n- 이러한 오류를 처리하세요(예: do-catch 블록 사용)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 혜택 및 고려 사항은 무엇인가요?\n\n이 기능은 많은 혜택을 제공하며, 구현할 때 고려해야 할 몇 가지 사항이 있습니다. async/await 방식을 사용하면\n\n- 가독성 개선. 주요 키워드를 쉽게 식별하고 특정 작업에서 무슨 일이 일어나고 있는지 이해할 수 있어 중첩 코드를 줄이고 유지보수성을 향상시킵니다.\n- 스레드 관리 오류 감소. 단순화된 접근 방식은 동기화 작업을 조작할 때 로직 오류를 줄이는 데 도움이 되어 신뢰성을 향상시킵니다.\n- 성능 향상. 동시성 코드 작성시의 정확성이 향상되어 컴파일러가 실행 시간이 아닌 컴파일 시간에 문제를 감지할 수 있습니다.\n\n## 고려 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 호환성. Async/Await을 사용하는 데 일부 우려 사항이 있는데, 이는 Swift 5.5부터 지원되며, 더 최신 버전은 사용법과 기능을 개선합니다.\n- Actors. 여러 동시 작업에서 액세스해서는 안 되는 기능을 격리하기 위해 액터의 사용을 고려해보세요.\n- 구조화된 및 구조화되지 않은 동시성. 그룹 및 오류 처리는 동시 작업의 사용 및 상호 작용을 조직화하는 데 도움이 되며, 반면 구조화되지 않은 작업은 자유롭지만 가능한 문제를 처리하기 위해 수동 지원이 필요합니다.\n\n# 결론\n\nSwift는 매년 업데이트로 발전하는 쓰레드 안전한 언어가 되고 있습니다. 더욱 명확한 문법을 제공하여 이해하고 유지하기 쉽게되었습니다. 이러한 라이브러리와 같은 특정 도구를 통해 개발을 개선할 수 있습니다. 이 모든 것은 모든 지원 플랫폼에서 사용할 수 있으며 특히 iOS, macOS 및 watchOS와 같은 플랫폼에서 운영 가능합니다.\n","ogImage":{"url":"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png"},"coverImage":"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png","tag":["Tech"],"readingTime":6},{"title":"100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기","description":"","date":"2024-05-27 16:21","slug":"2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings","content":"\n가장 큰 문제 중 하나는 RAG 어플리케이션의 연산 검색 시간입니다. 1조 개의 임베딩 벡터 기록이 있는 벡터 데이터베이스가 있다고 상상해보세요. 사용자 쿼리를 1조 개의 벡터와 일치시키려고 하면 올바른 정보를 검색하는 데 1분 이상이 걸릴 것입니다.\n\n시간을 단축하기 위해서는 사용자 쿼리 임베딩 벡터와 벡터 데이터베이스에 저장된 백만, 십억 또는 심지어 1조 개의 다른 임베딩 벡터 사이의 코사인 유사도를 계산하는 효율적인 방법을 찾아야 합니다.\n\nMIT 라이선스 하에 Chunkdot은 밀집(dense) 및 희소(sparse) 행렬에 대한 멀티 스레드 행렬 곱셈을 제공하기 위해 특별히 설계되었습니다. Numba를 사용하여 계산을 가속화하며 항목 행렬 표현(임베딩)을 세분화하여 대규모 항목에 대한 K개의 가장 유사한 항목을 계산하는 데 적합합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChunkdot GitHub 저장소\n\nHuggingFace에는 Qdrant의 이 데이터셋과 같이 백만 개 이상의 엔트리의 임베딩 벡터를 제공하는 다양한 데이터셋이 많이 있습니다. Chunkdot 성능을 테스트하는 데 사용할 수 있습니다. 그러나 세부 성능 측정을 위해 우리는 NumPy 라이브러리를 사용하여 여러 차원의 임의의 임베딩 벡터를 생성할 것입니다.\n\nChunkdot의 접근 방식과 코사인 유사도의 의사 코드를 비교할 것이며, 크기와 차원을 증가시킴으로써 성능이 어떻게 영향을 받는지 관찰할 것입니다. 이 작업에는 일관성을 보장하기 위해 Kaggle (GPU 없음) 노트북을 사용할 것입니다.\n\n본 블로그의 모든 코드는 제 GitHub 저장소에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 목차\n\n- 준비 단계 설정\n- 의사 코드 알고리즘 코딩\n- Chunkdot 알고리즘 코딩\n- 계산 시간 함수 코딩\n- 10k 벡터 임베딩에 대한 테스트\n- 100k 벡터 임베딩에 대한 테스트\n- 1 백만 벡터 임베딩에 대한 테스트\n- 확장성 영향 시각화\n- Chunkdot의 특징\n- 다음에 할 일\n\n# 준비 단계 설정\n\nChunkdot을 설치하려면 다른 라이브러리와 마찬가지인 유사한 설치 과정이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# chunkdot 설치하기\n\n```bash\npip install chunkdot\n```\n\n무엇이든 실행하기 전에 먼저 Kaggle 환경에서 사용 가능한 메모리를 확인해야 합니다.\n\n# 사용 가능한 메모리 확인하기\n\n```bash\n!free -h\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChunkdot 에게 사용 가능한 메모리를 확인하는 것은 매우 중요합니다. 벡터 데이터베이스 크기가 증가할수록 계산 메모리도 증가합니다. 사용 가능한 메모리를 초과하지 않도록 하려면 하드웨어의 남은 메모리를 모니터링하는 것이 중요합니다. 제 경우에는 버퍼/캐시를 제외하고 25GB의 여유 공간이 있습니다.\n\n필요한 라이브러리를 가져오겠습니다.\n\n```js\n# 행렬을 생성하기 위한 라이브러리\nimport numpy as np\n\n# chunkdot에서 코사인 유사도 모듈을 가져옵니다.\nfrom chunkdot import cosine_similarity_top_k\n\n# 계산 시간을 측정하기 위한 라이브러리\nimport timeit\n```\n\n# 코딩 의사 코드 알고리즘\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 데이터베이스나 로컬에 저장된 수백만 벡터들과 사용자 쿼리 벡터 간의 코사인 유사도를 계산하는 의사 코드 알고리즘을 만들어 볼게요.\n\n```js\ndef cosine_pseudocode(query_v, doc_v, num_indices):\n    \"\"\"\n    Embedding 벡터와 쿼리 벡터 간의 가장 높은 코사인 유사도 값을 가진 인덱스를 반환합니다.\n\n    매개변수:\n        query_v (numpy.ndarray): 쿼리 벡터.\n        doc_v (list of numpy.ndarray): Embedding 벡터의 목록.\n        num_indices (int): 반환할 상위 인덱스 개수.\n\n    반환값:\n        list of int: 가장 높은 코사인 유사도 값을 가진 인덱스들.\n    \"\"\"\n    cosine_similarities = []  # 코사인 유사도를 저장할 빈 리스트를 초기화합니다.\n\n    query_norm = np.linalg.norm(query_v)  # 쿼리 벡터의 노름을 계산합니다.\n\n    # 리스트에 있는 각 문서의 임베딩 벡터에 대해 반복합니다.\n    for vec in doc_v:\n        dot_product = np.dot(vec, query_v.T)  # 임베딩 벡터와 쿼리 벡터 간의 내적을 계산합니다.\n        embedding_norm = np.linalg.norm(vec)  # 임베딩 벡터의 노름을 계산합니다.\n        cosine_similarity = dot_product / (embedding_norm * query_norm)  # 코사인 유사도 계산\n        cosine_similarities.append(cosine_similarity)  # 코사인 유사도를 리스트에 추가합니다.\n\n    cosine_similarities = np.array(cosine_similarities)  # 리스트를 넘파이 배열로 변환합니다.\n\n    # 배열을 내림차순으로 정렬합니다.\n    sorted_array = sorted(range(len(cosine_similarities)), key=lambda i: cosine_similarities[i], reverse=True)\n\n    # 상위 num_indices 값을 가져옵니다.\n    top_indices = sorted_array[:num_indices]\n\n    # 가장 높은 코사인 유사도 값을 가진 인덱스를 반환합니다.\n    return top_indices\n```\n\n이 코사인 유사도 함수는 NumPy를 제외한 모든 라이브러리와 독립적으로 작동하며 세 가지 입력을 받습니다:\n\n- query_v는 사용자 쿼리의 임베딩 벡터입니다.\n- doc_v는 어딘가에 저장된 문서들의 임베딩 벡터들입니다.\n- num_indices는 유사한 상위 k결과로부터 문서의 인덱스 번호입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 코딩 Chunkdot 알고리즘\n\n의사코드 알고리즘을 코딩했으니, 다음 단계는 Chunkdot 코사인 유사도 함수를 코딩하는 것입니다.\n\n```js\ndef cosine_chunkdot(query_v, doc_v, num_indices, max_memory):\n    \"\"\"\n    청크닷 라이브러리를 사용하여 코사인 유사도를 계산합니다.\n\n    매개변수:\n        query_v (numpy.ndarray): 쿼리 벡터.\n        doc_v (numpy.ndarray): 임베딩 벡터 목록.\n        num_indices (int): 검색할 상위 인덱스 수.\n        max_memory (float): 사용할 최대 메모리.\n\n    반환값:\n        numpy.ndarray: 상위 k 인덱스.\n    \"\"\"\n\n    # 코사인 유사도 계산\n    cosine_array = cosine_similarity_top_k(embeddings=query_v, embeddings_right=doc_v,\n                                         top_k=num_indices, max_memory=max_memory)  # 청크닷을 사용하여 코사인 유사도 계산\n\n    # 상위 값의 인덱스 가져오기\n    top_indices = cosine_array.nonzero()[1]\n\n    # 상위 유사 결과 반환\n    return top_indices\n```\n\n이 Chunkdot 함수는 네 개의 입력을 받습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- query_v은 사용자 쿼리의 임베딩 벡터를 나타냅니다.\n- doc_v는 어딘가에 저장된 문서의 임베딩 벡터들을 나타냅니다.\n- num_indices는 유사한 상위 k개 결과에 대한 문서의 인덱스 번호를 나타냅니다.\n- max_memory는 계산에 사용할 수 있는 사용 가능한 메모리를 바이트 단위로 나타냅니다. 예를 들어, 1E9는 1GB를 의미하며, 10E9는 10GB를 의미합니다.\n\n두 함수를 샘플 데이터셋에서 테스트하여 출력을 관찰해보겠습니다.\n\n```js\ndoc_embeddings = np.random.randn(10, 100) # 10개의 문서 임베딩 (100차원)\n\nuser_query = np.random.rand(1, 100) # 1개의 사용자 쿼리 (100차원)\n\ntop_indices = 1 # 검색할 상위 인덱스 수\n\nmax_memory = 5E9 # 사용할 최대 메모리 (5GB)\n\n# 의사코드를 사용하여 가장 높은 코사인 유사도 값을 갖는 인덱스를 검색\nprint(\"의사코드를 사용한 상위 인덱스:\", cosine_pseudocode(user_query, doc_embeddings, top_indices))\n\n# chunkdot을 사용하여 가장 높은 코사인 유사도 값을 갖는 인덱스를 검색\nprint(\"chunkdot을 사용한 상위 인덱스:\", cosine_chunkdot(user_query, doc_embeddings, top_indices, max_memory))\n```\n\n```js\n### 출력 ###\n의사코드를 사용한 상위 인덱스: [4]\nchunkdot을 사용한 상위 인덱스: [4]\n### 출력 ###\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문서 임베딩에 대한 유사한 항목의 인덱스를 최고의 코사인 유사도를 기반으로 한 항목만 반환한다는 것을 의미하는 top_indices 매개변수를 1로 설정했습니다. 메모리 사용량을 5E9로 설정했는데, 이는 5GB와 동일합니다. 두 함수 모두 동일한 인덱스 4를 반환하여 두 함수를 정확하게 코딩했음을 나타냅니다.\n\n# 코딩 계산 시간 함수\n\n또한 이러한 두 함수에 의해 소요된 계산 시간을 측정할 수 있는 타이밍 함수를 만들어야 합니다.\n\n```js\n# 소요 시간 계산\ndef calculate_execution_time(query_v, doc_v, num_indices, max_memory, times):\n\n    # 의사코드 함수 실행에 걸리는 시간 계산\n    pseudocode_time = round(timeit.timeit(lambda: cosine_pseudocode(query_v, doc_v, num_indices), number=times), 5)\n\n    # chunkdot 함수 실행에 걸리는 시간 계산\n    chunkdot_time = round(timeit.timeit(lambda: cosine_chunkdot(query_v, doc_v, num_indices, max_memory), number=times), 5)\n\n    # 소요 시간 출력\n    print(\"의사코드 함수에 걸리는 시간:\", pseudocode_time, \"초\")\n    print(\"chunkdot 함수에 걸리는 시간:\", chunkdot_time, \"초\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 이미 이 함수로 전달되는 매개변수를 검토했습니다. 여기서 새로운 매개변수는 times입니다. 이 매개변수는 코드를 몇 번 실행할지를 함수에 알려줍니다. 더 큰 규모에서 Chunkdot 성능을 테스트해 봅시다.\n\n# 10,000 벡터 임베딩 테스트\n\n우리는 합리적인 수의 문서 임베딩인 10000개로 시작할 것입니다. 이는 소규모 도메인별 RAG 애플리케이션과 비교 가능합니다. 각 임베딩 벡터의 차원을 1536으로 설정했습니다. 이는 OpenAI 임베딩 모델 텍스트 임베딩-3-small과 동등합니다.\n\n각 접근 방식의 계산 시간을 계산하기 위해 각각 100번 실행하여 효율성을 테스트해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndoc_embeddings = np.random.randn(10000, 1536)  # 10K 문서 임베딩 (1536 차원)\n\nuser_query = np.random.rand(1, 1536)  # 사용자 쿼리 (1536 차원)\n\ntop_indices = 1  # 검색할 상위 인덱스 수\n\nmax_memory = 5E9  # 최대 메모리를 5GB로 설정\n\n# 함수 실행에 소요된 시간을 계산합니다.\ncalculate_execution_time(user_query, doc_embeddings, top_indices, max_memory, 100)\n```\n\n10,000개의 문서 임베딩, 1536 차원을 가진 두 알고리즘을 100번 실행한 결과는 다음과 같습니다:\n\n![그래프](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_2.png)\n\nChunkdot은 유사도 비교 코드와 비교해 더 많은 시간이 소요됩니다. 이는 Chunkdot이 먼저 청크를 생성하고 각 청크에서 계산을 수행한 후 병합하기 때문입니다. 따라서 이 소규모 예제에 대해서는 적합한 해결책이 아닐 수 있습니다. 그러나 나중에 더 큰 예제를 다룰 때 Chunkdot의 이점을 확인하게 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 100k 벡터 임베딩 테스트\n\n10천 개의 가상 코드 방식으로는 우리가 이긴다고 하지만, 이제는 문서 임베딩 벡터를 중형 규모의 RAG 응용 프로그램과 유사한 100K 벡터까지 늘려보겠습니다.\n\n각 방법에 대한 계산 시간을 계산해 봅시다. 이번에는 벡터의 수가 매우 많기 때문에 계산을 여러 번 수행할 필요가 없으므로 times 매개변수를 1로 설정하여 코드를 한 번 실행합니다.\n\n```js\ndoc_embeddings = np.random.randn(100000, 1536) # 100K 문서 임베딩 (1536 차원)\n\nuser_query = np.random.rand(1,1536) # 사용자 쿼리 (1536 차원)\n\ntop_indices = 1 # 반환할 상위 인덱스 수\n\nmax_memory = 5E9 # 최대 메모리를 5GB로 설정\n\ntimes = 1 # 함수를 실행할 횟수\n\n# 함수 실행 시간 계산\ncalculate_execution_time(user_query, doc_embeddings, top_indices, max_memory, times)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n100,000개의 문서 임베딩, 차원이 1536인 경우, 두 알고리즘을 한 번씩 실행하여 비교한 결과는 다음과 같습니다:\n\n![Comparison Chart](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_3.png)\n\nChunkdot은 의사코드에 비해 거의 절반의 시간이 소요됩니다. 이제 Chunkdot의 유망한 영향을 확인하고 있습니다.\n\n1백만 벡터 임베딩을 위한 테스트 중입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n백만 개의 임베딩을 다루는 작업 중에, 첫 번째로 확인해야 할 사항은 문서 임베딩 벡터가 얼마나 많은 메모리를 차지하는지입니다.\n\n```js\n# 1 백만 개의 문서 임베딩 (1536 차원)\ndoc_embeddings = np.random.randn(1000000, 1536)\n\n# 사용자 쿼리 (1536 차원)\nuser_query = np.random.rand(1, 1536)\n\n# doc_embeddings와 user_query 임베딩의 메모리 크기 확인\nprint(doc_embeddings.nbytes / (1024 * 1024 * 1024),\n      user_query.nbytes / (1024 * 1024))\n```\n\n![이미지](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_4.png)\n\n저희 문서 임베딩은 대략 12GB를 차지합니다. 남은 공간을 확인해 보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_5.png)\n\n17GB의 사용 가능한 메모리가 있습니다. 어떠한 메모리 오류도 피하기 위해 max_memory 매개변수의 안전한 값을 12GB로 설정할 것입니다. 결과를 확인해 봅시다.\n\n```js\n# 100만 개의 문서 임베딩 (1536 차원)\ndoc_embeddings = np.random.randn(1000000, 1536)\n\n# 사용자 쿼리 (1536 차원)\nuser_query = np.random.rand(1, 1536)\n\ntop_indices = 1 # 가져올 상위 인덱스 수\n\nmax_memory = 12E9 # 최대 메모리 설정 --- 12GB ---\n\ntimes = 1 # 함수를 실행할 횟수\n\n# 함수 실행 시간 계산하기\ncalculate_execution_time(user_query, doc_embeddings, top_indices, max_memory, times)\n```\n\n![image](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChunkDot은 실제로 계산을 효과적으로 줄입니다. 진지한 RAG 앱을 만들려면 적어도 백만 개의 쿼리부터 시작하는 것이 좋습니다. 높은 차원의 임베딩 모델로 작업을하는 경우 4000까지 증가합니다. 이 접근 방식은 훨씬 더 효율적이어질 것입니다.\n\n# 확장성 영향 시각화\n\n문서 임베딩 벡터 수를 증가시키는 영향을 시각화해 보겠습니다. 시작은 10,000부터 매우 큰 수까지입니다.\n\n![이미지](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 세 가지 방법을 그래프로 나타내었고, 문서 임베딩의 수를 늘릴 때 Chunkdot이 모든 방법 중에서 가장 우수하다는 것을 확인했습니다. 이제 임베딩 벡터의 차원이 계산 시간에 어떤 영향을 미치는지 살펴보겠습니다.\n\n![Embedding Vectors Computation Time](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_8.png)\n\n벡터의 차원을 늘리면서 10만 개의 문서를 사용했고, 문서 수를 늘릴 때 관찰한 현상과 동일한 결과를 얻었습니다.\n\n# Chunkdot의 특징\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChunkdot에는 진행 표시 막대를 표시할 수 있는 기능이 있어서 얼마만큼의 계산이 남았는지 추적할 수 있습니다.\n\n```js\ndoc_embeddings = np.random.randn(100000, 1536) # 100K document embeddings (1536 dim)\n\nuser_query = np.random.rand(1,1536) # user query (1536 dim)\n\ntop_indices = 100 # 검색할 상위 인덱스 수\n\nmax_memory = 5E9 # 최대 메모리를 5GB로 설정\n\n# 진행 표시 막대와 함께\noutput_array = cosine_similarity_top_k(user_query, doc_embeddings,\n                        top_k=top_indices,\n                        show_progress=True)\n```\n\n![진행 표시 막대](https://miro.medium.com/v2/resize:fit:1400/1*3A2KQ9fDvAA-VfQNKjphJw.gif)\n\nChunkdot의 출력은 희소 행렬이며, 다음을 사용하여 배열로 변환할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 출력 변환\n\noutput_array.toarray()\n\nChunkdot은 문서 임베딩에 대해서만 사용할 수 있습니다. 이는 각 문서 임베딩 요소에 대해 가장 유사한 상위 k개 요소를 반환할 것입니다.\n\n# 총 5개의 문서 임베딩\n\nembeddings = np.random.randn(5, 256)\n\n# 각각의 상위 2개 가장 유사한 항목 인덱스 반환\n\ncosine_similarity_top_k(embeddings, top_k=2).toarray()\n\n### 출력\n\narray([[1.        , 0.        , 0.        , 0.        , 0.09924064],\n       [0.        , 1.        , 0.        , 0.09935381, 0.        ],\n       [0.02358785, 0.        , 1.        , 0.        , 0.        ],\n       [0.        , 0.09935381, 0.        , 1.        , 0.        ],\n       [0.09924064, 0.        , 0.        , 0.        , 1.]]\n\n### 출력\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비슷한 방법으로 top_k 매개변수에 음수 값을 제공하여 가장 다른 항목을 반환할 수도 있습니다.\n\n```js\n# 총 5개의 문서 임베딩\nembeddings = np.random.randn(5, 256)\n\n# 각 항목의 가장 다른 상위 2개 항목 인덱스 반환\n# Top_K = -2\ncosine_similarity_top_k(embeddings, top_k=-2).toarray()\n```\n\n```js\n### 출력 ###\narray([[ 0.        ,  0.        , -0.04357524,  0.        , -0.05118288],\n       [ 0.        ,  0.        ,  0.        ,  0.01619543, -0.01836534],\n       [-0.04357524,  0.        ,  0.        , -0.02466613,  0.        ],\n       [ 0.        ,  0.01619543, -0.02466613,  0.        ,  0.        ],\n       [-0.05118288, -0.01836534,  0.        ,  0.        ,  0.        ]])\n### 출력 ###\n```\n\n당신의 상황이 아닐 수도 있지만, 1만 차원까지의 희소한 임베딩을 처리하는 경우 density 매개변수를 사용하여 계산을 더 효율적으로 줄일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 희소 임베딩 생성을 위해\nfrom scipy import sparse\n\n# 각각 10,000 차원을 가진 100,000개의 문서로 이루어진 희소 매트릭스 생성\n# 밀도를 0.005로 정의\n임베딩 = sparse.rand(100000, 10000, density=0.005)\n\n# 시스템의 모든 메모리 사용\n코사인 유사도 상위 k(embeddings, top_k=50)\n```\n\n# 다음 단계\n\nChunkdot 알고리즘이 어떻게 작동하는지 알고 싶다면, 저자의 멋진 블로그를 확인해보세요. Chunkdot의 가장 큰 장점 중 하나는 CPU 코어에서 작동한다는 것입니다. 앞으로, GPU 지원을 통합할 계획이 있으며, 이는 연산에 소요되는 시간을 크게 줄일 것입니다. 로컬 환경에 충분한 RAM이 없는 경우에는 Kaggle이나 GitHub Codespaces 같은 플랫폼을 활용할 수 있습니다. 이러한 클라우드 CPU 코어와 RAM은 GPU 비용에 비해 매우 저렴합니다. Chunkdot가 어떻게 작동하는지를 잘 설명한 공식 GitHub 저장소와 블로그도 꼭 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_0.png"},"coverImage":"/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_0.png","tag":["Tech"],"readingTime":17},{"title":"맵핑 대 이터러블 맵핑 간단히 해석하기","description":"","date":"2024-05-27 16:20","slug":"2024-05-27-MappingsvsIterableMappingsSimplified","content":"\n안녕하세요! 모두들! 저는 모든 것을 간단하게 만들어 설명해드릴게요. 데이터 구조가 어떻게 작동하는지 설명하는 글이 정말 많죠. 하지만 여기서는 조금 더 쉽게 설명할 거에요. 이 글을 끝까지 읽어보시면 제대로 이해하실 거에요. 확실해요💯.\n\n![이미지](/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png)\n\n# 표준 Mapping\n\nMappings이 뭔가요? 하하, 제가 어이가 없네요! Solidity에서의 Mappings은 간단한 전화번호부와 같아요. 사람의 이름을 통해 전화번호를 찾을 수 있지만, 전화번호를 통해 이름을 찾을 수는 없어요. (Mapping이라고 말할 때는 표준 Mapping을 의미합니다 😉) 지금쯤 완전 쉽다고 생각하셨을 거예요. 그래요, 이렇게 말해볼게요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n매핑은 Solidity에서 키-값 데이터 구조입니다. 고유한 키를 기반으로 값을 저장하고 검색할 수 있습니다. 주로 고유한 이더리움 주소와 다양한 값 유형을 연결하는 데 사용되어, 스마트 계약에서 데이터를 관리하는 데 필수적인 도구입니다.\n\n# 매핑의 종류\n\n간단한 매핑:\n\n간단한 매핑의 예제를 살펴봅시다. 이곳에서는 이더리움 주소와 해당 잔액 간의 연결을 만들고 있습니다. 이를 \"잔액(balances)\"이라는 매핑으로 부르겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n매핑 :address =\u003e uint) public balances;\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_1.png\" /\u003e\n\n컨트랙트인 SimpleMapping을 살펴보겠습니다.\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ncontract SimpleMapping {\n    mapping(address =\u003e uint) public balances;\n\n    function setBalance(address _user, uint _balance) public {\n        balances[_user] = _balance;\n    }\n\n    function getBalance(address _user) public view returns (uint) {\n        return balances[_user];\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 배포된 계약의 스크린샷입니다. 'setBalance' 함수를 호출할 때 이더리움 주소와 해당 잔고를 제공했습니다. 'getBalance'에서는 그 이더리움 주소의 잔고를 검색했습니다.\n\n![contract-screenshot](/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_2.png)\n\nSolidity에서 매핑을 선언할 때 주의할 점:\n\n- 사실상 두 값 사이의 연결을 만드는 것입니다.\n- 매핑에서 키를 사용하여 해당 값을 찾을 수 있지만, 역은 찾을 수 없습니다. 즉, 값을 사용하여 키를 찾을 수는 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n중첩 매핑:\n\n이제 중첩 매핑에 대해 알아보겠습니다. 두 개의 이더리움 주소와 불리언 값 사이의 링크를 생성 중입니다. 불리언 값이 true이면, 두 주소는 관련이 있습니다.\n\n```js\nmapping(address =\u003e mapping(address =\u003e bool)) public isRelated;\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_3.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 아래는 'NestedMapping' 계약에 대한 정보입니다.\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ncontract NestedMapping {\n    mapping(address =\u003e mapping(address =\u003e bool)) public isRelated;\n\n    function setRelationship(address _user1, address _user2, bool _isRelated) public {\n        isRelated[_user1][_user2] = _isRelated;\n    }\n\n    function checkRelationship(address _user1, address _user2) public view returns (bool) {\n        return isRelated[_user1][_user2];\n    }\n}\n```\n\n배포된 계약의 스크린샷을 아래에서 확인할 수 있습니다. 'setRelationship' 함수를 사용하여 두 이더리움 주소 및 false 값을 제공하였습니다. 'checkRelationship' 함수에서 해당 중첩 매핑의 부울 값을 검색하였습니다.\n\n![매핑 이미지](/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한 중첩된 매핑의 경우:\n\n- 순서가 중요합니다.\n- \\_user1에 값 설정 후 \\_user2에 값 설정하는 것은 자동으로 \\_user2에 값 설정 후 \\_user1에 값 설정하는 것을 의미하지 않습니다.\n\n# 반복 가능한 매핑\n\n반복 가능한 매핑이란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n반복 가능한 매핑은 모든 이름과 전화번호를 나열할 수 있는 향상된 전화번호부와 같습니다. 이름으로 전화번호를 찾을 수는 있지만 모든 항목을 하나씩 차례대로 확인할 수도 있습니다.\n\n주요 포인트:\n\n- 양방향 상호작용: 키로 값을 찾거나 모든 키를 나열할 수 있습니다.\n- 더 많은 제어: 보다 복잡한 작업을 수행할 수 있습니다. 예를 들어 보고서 생성이나 모든 항목에 대한 작업 수행 등이 가능합니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ncontract IterableMapping {\n\n    mapping(address =\u003e uint) private balances;\n\n    address[] private keys;\n\n    mapping(address =\u003e bool) private isKey;\n\n    function setBalance(address _user, uint _balance) public {\n        if (!isKey[_user]) {\n            keys.push(_user);\n            isKey[_user] = true;\n        }\n        balances[_user] = _balance;\n    }\n\n    function getBalance(address _user) public view returns (uint) {\n        return balances[_user];\n    }\n\n    function getAllKeys() public view returns (address[] memory) {\n        return keys;\n    }\n}\n```\n\n배포된 스마트 계약의 스크린샷이 아래에 있습니다. ‘getAllKeys’ 함수를 호출했습니다. 현재 ‘keys’ 배열에 저장된 모든 키를 반환해야 합니다. 이는 Iterable Mapping을 사용하여 가능한 내용 중 하나에 불과합니다… 모두 나열했습니다.\n\n\u003cimg src=\"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_5.png\" /\u003e\n\n# 왜 Iterable Mappings를 사용해야 하는가?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모든 것 나열하기: 모든 항목을 보고 싶을 때 반복 가능한 매핑을 사용할 수 있어요. 예를 들어, 모든 토큰 소지자를 나열하는 경우입니다.\n- 복잡한 작업: 모든 항목에 작업을 수행할 수 있도록해주어, 모든 사용자에게 보상을 분배하는 것과 같은 작업을 수행할 수 있어요.\n\n각각을 사용하는 시점:\n\n- 표준 매핑: 간단하고 빠른 조회가 필요하며 모든 항목을 나열할 필요가 없는 경우에 사용하세요. 예를 들어, 사용자의 잔고를 확인하는 경우입니다.\n- 반복 가능한 매핑: 모든 항목을 나열하거나 관리해야 할 때 사용하세요. 예를 들어, 모든 사용자의 잔액을 처리하는 경우입니다.\n\n# 비교 요약\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003ctable\u003e 태그를 Markdown 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해 주세요!\n","ogImage":{"url":"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png"},"coverImage":"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png","tag":["Tech"],"readingTime":8},{"title":"한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요","description":"","date":"2024-05-27 16:18","slug":"2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode","content":"\n![이미지](/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png)\n\n데코레이터를 작성하고 싶지만 구문을 기억하지 못하시나요? 데코레이터는 많은 보일러플레이트 코드가 포함된 꽤 어려운 구문을 갖고 있습니다. 이 기사에서는 데코레이터를 작성하는 더 간단한 방법을 소개합니다. 이 새로운 방법은 훨씬 더 짧고 명확하며 가독성이 뛰어날 것입니다. 함께 코딩해봅시다!\n\n# 데코레이터 작성의 기본 방법\n\n아래 코드는 데코레이터를 생성하는 기본 방법입니다. 데코레이터로 래핑된 함수가 실행되는 시간을 측정합니다. 깊이 파고든 이 기사를 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndef timer(name:str) -\u003e Callable:\ndef decorator(func:Callable) -\u003e Callable:\n@wraps(func)\ndef decorator_implementation(*args, \\*\\*kwargs):\ntry:\nprint(f\"TIMER: {name} start\")\nstrt = time.perf_counter()\nreturn func(*args, \\*\\*kwargs)\nfinally:\nprint(f\"TIMER: {name} finished in {time.perf_counter() - strt}\")\nreturn decorator_implementation\nreturn decorator\n\n이렇게 하면 코드를 다음과 같이 사용할 수 있습니다:\n\n```js\n@timer(name=\"test\")\ndef my_func(name:str, age:int) -\u003e str:\n    return f\"{name} is {age} years old\"\n\nmy_func(name=\"mike\", age=34)\n# TIMER:   test start\n# mike is 34 years old\n# TIMER:   test finished in 5.299999999998532e-06\n```\n\n## 이 접근 방식의 문제점은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 개발자이며 개인적으로 데코레이터를 작성하는 방법을 항상 기억하지 못하고 이전 프로젝트에서 코드를 복사하여 붙여넣어야 합니다. 이는 3개의 중첩된 함수가 포함된 약간 읽기 어려운 구문 때문에 데코레이터를 이해하기 어렵게 만들기 때문이라고 생각합니다. 우리는 이를 어떻게 단순화할 수 있는지 알아보겠습니다.\n\n# 데코레이터를 작성하는 더 쉬운 방법\n\n아래 구현은 이전 섹션의 데코레이터와 정확히 동일한 작업을 하지만 한 가지 함수만 사용합니다. 이는 훨씬 더 읽기 쉽고 @contextmanager 데코레이터를 추가하고 함수를 생성기로 변환하는 것으로 처리됩니다.\n\n```python\n@contextmanager\ndef timer(name:str) -\u003e Generator:\n    try:\n        print(f\"TIMER:   {name} start\")\n        strt = time.perf_counter()\n        yield\n    finally:\n        print(f\"TIMER:   {name} finished in {time.perf_counter() - strt}\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모두 같은 방식으로 함수를 사용할 수 있어요:\n\n```js\n@timer(name=\"AS DEC\")\ndef my_func(name:str, age:int) -\u003e str:\n    return f\"{name}은(는) {age}살이야\"\n\n\nmy_func(name=\"마이크\", age=34)\n# TIMER:   AS DEC 시작\n# 마이크은(는) 34살이야\n# TIMER:   AS DEC 5.399999999995686e-06초 내에 완료됨\n```\n\n## 컨텍스트 매니저로서의 기능\n\n개인적으로 새로운 함수가 더 읽기 쉽고 이해하기 쉽다고 생각해요. 몇 가지 간단한 변경이 필요하지만 그만큼 다양한 기능을 제공해요. 함수에 데코레이터를 적용하는 것이 훨씬 쉬워지고 데코레이터 함수(예: 위의 timer)를 데코레이터 및 컨텍스트 매니저로 모두 사용할 수도 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n타이머와 함께(context manager와 함께)\n\n우리는 동일한 데코레이터 함수를 데코레이터 및 context-manager로도 사용할 수 있습니다.\n\n```js\nas ctx라는 이름의 타이머와 함께:\n    fn_with_ctx_decorator(name=\"john\", age=42)\n    print(\"컨텍스트 매니저 내부\")\n\n# 타이머:  as ctx 시작\n# 타이머:  AS DEC 시작\n# john은 42살입니다\n# 타이머:  AS DEC가 3.7000000000023126e-06초에 완료되었습니다\n# 컨텍스트 매니저 내부\n# 타이머:  as ctx가 3.0000000000002247e-05초에 완료되었습니다\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 어떻게 작동합니까?\n\n내부적으로 contextlib은 @contextmanager를 사용하여 우리의 데커레이터 함수를 감싸서 데커레이터와 컨텍스트 매니저 역할을 하는 객체로 만들어줍니다. 이 작업 방식은 꽤 기술적이고 매우 흥미로우며 독립된 기사가 필요합니다. 계속 따라와주세요!\n\n이 기사의 범위에서는 contextlib이 @contextmanager 데코레이터를 사용하여 데커레이터 함수를 데커레이터와 컨텍스트 매니저로 모두 사용할 수 있는 객체로 변환한다는 것만 알면 됩니다.\n\n## 단점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새 데코레이터는 많은 기능을 제공하지만 몇 가지 단점이 있습니다. 그 중 가장 중요한 것은 데코레이터 함수 내에서 실제로 데코레이션하는 함수에 액세스할 수 없다는 점입니다. 또한 해당 함수의 args와 kwargs에 액세스할 수도 없습니다. 이로 인해 이러한 변수를 수정할 수 없지만 제 생각에는 이를 드물게 해야 하는 것입니다.\n\n두 번째 단점은 데코레이터 함수가 제너레이터 함수여야 한다는 점입니다. 이는 해당 함수가 본문에서 어딘가에 yield해야 한다는 의미입니다. 이로 인해 코드를 다시 작성해야 할 수도 있습니다.\n\n# 결론\n\n@contextmanager를 사용하면 데코레이터를 쉽고 가독성있게 작성할 수 있습니다. 많은 쓰기 장치를 처리해주며 심지어 콘텍스트 매니저 역할도 수행합니다. 그러나 이 자동화와 \"하드코딩된 마법\"으로 인해 함수와 인수에 액세스할 수 있는 제어를 일부 상실하게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ncontextlib은 내부에서 작동하는 방식이 상당히 복잡하며 별도의 기사가 필요하므로 관심이 있다면 저를 따라오세요!\n\n이 기사가 제가 희망하는 대로 명확하게 전달되었기를 바라지만, 그렇지 않은 경우 추가 설명이 필요하다면 알려주세요. 그동안 다른 주제들에 대한 제 다른 기사들도 확인해보세요:\n\n- 절대 초보자를 위한 Git: 비디오 게임의 도움으로 Git 이해하기\n- 나만의 Python 패키지 작성 및 게시\n- FastAPI를 사용해 5줄의 코드로 빠르고 자동 문서화되고 유지보수 가능한 쉽게 사용할 수 있는 Python API 만들기\n\n즐거운 코딩 되세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Mike\n\nP.S: 제 하는 일 좋아하시나요? 제 팔로우 해주세요!\n","ogImage":{"url":"/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png"},"coverImage":"/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png","tag":["Tech"],"readingTime":6},{"title":"단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기","description":"","date":"2024-05-27 16:17","slug":"2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness","content":"\n![unit test image](/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png)\n\n저는 전문적인 코딩을 시작한 이후로 단위 테스트를 작성해 왔어요. 그 속에는 특별한 \"영감\"이 있죠. 다른 개발자가 여러분의 코드를 사용해야 한다는 점을 생각하게 만들어요.\n\n그 \"다른 개발자\"가 바로 여러분의 미래 자신이기도 해요.\n\n단위 테스트를 작성할 때마다, 정확성을 검증할 뿐만 아니라 클래스의 작업 편의성도 평가하려고 해요. 좋은 코드를 작성하는 중요한 측면 중 하나는 함께 작업하기 즐거운 코드를 작성하는 것이라고 생각해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 전반적인 시스템의 정확성을 검증하는 것은 단위 테스트가 갖고 있지 않은 특징입니다.\n\n단위 테스트를 작성하는 데 드는 비용은 매우 적습니다. 기대되는 결과를 빠르게 작성, 실행 및 확인할 수 있습니다. 그러나 다른 측면에서도 저렴하다고 할 수 있습니다. 단위 테스트는 실제로 발생할 수 있는 프로덕션에서 발생할 수 있는 버그를 잡는 데는 거의 충분하지 않습니다.\n\n🔔 이와 유사한 기사를 더 보고 싶으시면 여기에서 가입하세요.\n\n매우 제어된 상황에서 고립된 상태로 작동하는 것을 본다는 것은 여러 협업 객체, 다양한 사용 사례 등이 포함된 더 큰 환경에서 작동하는 것을 보는 것과는 전혀 다릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성을 경멸하는 것은 재앙의 길이 될 수 있습니다. 그리고 내 경험상, 데이터베이스와의 상호 작용을 모의하는 경우에는 특히 그렇습니다.\n\n이 유닛 테스트를 분석해 보세요. 우리는 \"UserManager\"를 통해 사용자를 저장하는 것을 확인하려고 합니다.\n\n```js\n[Fact]\npublic void SaveNewUser()\n{\n   // Arrange\n   var repository = Substitute.For\u003cIUserRepository\u003e();\n\n\n   var user = new User();\n   var sut = new UserManager(repository);\n\n   // Act\n   sut.SaveUser(user);\n\n   // Assert\n   repository.Received(1).SaveUser(Arg.Any\u003cUser\u003e());\n}\n```\n\n이것은 투명하고 화이트박스 테스트입니다. UserManager는 실제 저장을 협력자 \"IUserRepository\"에 위임하고 있으며, \"UserManager\"가 \"SaveUser\" 메서드를 호출하는지 확인합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 아무 것도 테스트하지 않는 종류의 단위 테스트입니다. 아무 것도 확인하지 않으며 확신을 줄 수도 없습니다.\n\n우리는 모든 것이 잘되도록 하려는 중입니다.\n\n이러한 테스트는 무언가를 확실히 해서 빌드 서버에서 코드 품질 단계를 통과시키는 임의의 코드 커버리지 목표를 충족하는 데로 인해 우리를 기분 좋게 만들어 줍니다. 하지만 실제로는 일이 잘 되고 있다는 빈 약속일 뿐입니다.\n\n만약 당신의 코드베이스에 제가 방금 보여준 것과 유사한 테스트가 있다면, 그것은 당신에게 큰 문제가 있을 수 있다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 \"사용자\" 테이블이 이렇게 생겼다고 가정해 봅시다.\n\n```js\n-- PostgreSQL\nCREATE TABLE \"Users\" (\n   \"Id\" uuid NOT NULL,\n   \"Name\" text NOT NULL,\n\n   -- 그리고 다른 많은 열들\n\n   CONSTRAINT \"PK_Users\" PRIMARY KEY (\"Id\")\n);\n```\n\n그럼 \"Id\"나 \"Name\"이 없이 만들어진 사용자를 저장하려고 하면 예외가 발생하게 되어, 모든 것이 정상적으로 작동되고 있다고 생각하는 것을 방지할 수 있습니다.\n\n```js\nvar user = new User(); // 저장되지 않아야 함\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 분명히 클래스와 협력자 간의 상호 작용이 매우 적은 간단한 예제입니다. 그러나 단위 테스트에 무작정 의존하는 함정을 보여줍니다.\n\n🔔 이와 유사한 기사를 더 보시려면 여기에서 가입하세요.\n\n프로페셔널 소프트웨어 개발의 여러 해를 거친 후, 무언가를 모킹할 때 항상 그 테스트를 단위 테스트로 유지해야 하는지 아니면 통합 테스트로 승격해야 하는지 신중하게 생각하는 시간을 가집니다.\n\n이제 이 전환된 테스트와 이 통합 테스트를 대조해 보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```csharp\npublic class UserManagerShould(DatabaseFixture fixture) : IClassFixture\u003cDatabaseFixture\u003e\n{\n  [Fact]\n  public async Task SaveNewUser()\n  {\n     // Arrange\n     UserDbContext context = new TestDbContextFactory(fixture.ConnectionString)\n         .CreateDbContext(null!);\n\n     await context.Database.EnsureCreatedAsync();\n     await context.Users.ExecuteDeleteAsync();\n\n     var repository = new EfUserRepository(context);\n\n     var user = new User();\n     var sut = new UserManager(repository);\n\n\n     // Act\n     sut.SaveUser(user);\n\n     // Assert\n     List\u003cUser\u003e result = context.Users\n         .AsNoTracking()\n         .ToList();\n\n     result.Should()\n           .HaveCount(1);\n  }\n}\n```\n\n이 테스트는 우리 시스템이 프로덕션에서 수행할 작업을 정확히 모방합니다. 이 테스트는 픽스처와 PostgreSQL 도커 컨테이너가 하나의 테스트를 위해 실행됩니다.\n\n이제 \"SaveUser(user)\" 메서드를 호출하면 실제 데이터베이스에 삽입이 수행되며, 사용자에게 이름이 없기 때문에 오류가 발생합니다: Npgsql.PostgresException 23502: null value in column \"Name\" of relation \"Users\" violates not-null constraint.\n\n실제로 잘못된 상황에서 오류가 발생하는 이러한 테스트는 사용자를 저장하기 전에 추가적인 확인 절차를 수행해야 함을 알려줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테스트 실패는 우리에게 대응을 촉발시킵니다. 이 경우 UserManager의 SaveUser(user) 메서드에 가드 절을 추가하여 사용자가 유효한 상태에 있는지 확인하십시오.\n\n# 요약하자면...\n\n테스트는 시스템이 작동한다는 확신을 주어야 하며, 단순히 통제된 실험실 조건에서 각 부분이 작동하는 것만으로는 충분하지 않습니다.\n\n🔔 이와 같은 기사를 더 읽고 싶으신가요? 여기에서 등록하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시스템 내 중요한 클래스 상호작용을 모의하는 것은 클래스 간 통신 및 데이터 교환에서 발생하는 통합 문제를 알리지 못하게 할 수 있습니다. 실제 데이터베이스를 사용하는 데 조금 노력을 기울이면 장기적으로 이득을 볼 수 있습니다.\n\n빌드 시간에 통합 문제를 발견하는 것은 운영시간(프로덕션)에 발생하는 쉽게 피할 수 있는 문제를 발견하는 것보다 훨씬 저렴합니다.\n\n# 계속 연락을 유지합시다!\n\n뉴스레터에 등록하여 유사한 기사에 대한 알림을 받고 YouTube 채널인 @Nicklas Millard를 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n린크드인에 연결하지 않는 것을 잊지 마세요.\n","ogImage":{"url":"/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png"},"coverImage":"/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png","tag":["Tech"],"readingTime":7}],"page":"54","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"54"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>