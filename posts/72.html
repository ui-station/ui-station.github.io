<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/72" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/72" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="안드로이드 프로젝트에 Kotlin Multiplatform Mobile KMM을 원활하게 통합하기" href="/post/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 프로젝트에 Kotlin Multiplatform Mobile KMM을 원활하게 통합하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 프로젝트에 Kotlin Multiplatform Mobile KMM을 원활하게 통합하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 프로젝트에 Kotlin Multiplatform Mobile KMM을 원활하게 통합하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드에서 Room 데이터베이스 시작하기" href="/post/2024-05-20-GettingStartedwithRoomDatabaseinAndroid"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드에서 Room 데이터베이스 시작하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드에서 Room 데이터베이스 시작하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드에서 Room 데이터베이스 시작하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코틀린 코루틴에서 에러 다루기 예외 처리와 에러 전파" href="/post/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코틀린 코루틴에서 에러 다루기 예외 처리와 에러 전파" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코틀린 코루틴에서 에러 다루기 예외 처리와 에러 전파" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코틀린 코루틴에서 에러 다루기 예외 처리와 에러 전파</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비 온 레일즈에서의 유효성 검사를 위한 모범 사례들" href="/post/2024-05-20-BestPracticesforValidationsinRubyonRails"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비 온 레일즈에서의 유효성 검사를 위한 모범 사례들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비 온 레일즈에서의 유효성 검사를 위한 모범 사례들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비 온 레일즈에서의 유효성 검사를 위한 모범 사례들</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="성능 비교 Ruby 대 Python 대 Go  문자 발생 횟수 세기" href="/post/2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="성능 비교 Ruby 대 Python 대 Go  문자 발생 횟수 세기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="성능 비교 Ruby 대 Python 대 Go  문자 발생 횟수 세기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">성능 비교 Ruby 대 Python 대 Go  문자 발생 횟수 세기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="테스트 속도를 높이는 parallel_tests의 힘을 활용해보세요 로컬 설정 및 실행법" href="/post/2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="테스트 속도를 높이는 parallel_tests의 힘을 활용해보세요 로컬 설정 및 실행법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="테스트 속도를 높이는 parallel_tests의 힘을 활용해보세요 로컬 설정 및 실행법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">테스트 속도를 높이는 parallel_tests의 힘을 활용해보세요 로컬 설정 및 실행법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비 온 레일즈로 CORS 구성하기 - 2부" href="/post/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비 온 레일즈로 CORS 구성하기 - 2부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비 온 레일즈로 CORS 구성하기 - 2부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비 온 레일즈로 CORS 구성하기 - 2부</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴" href="/post/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지" href="/post/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능" href="/post/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link posts_-active__YVJEi" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"안드로이드 프로젝트에 Kotlin Multiplatform Mobile KMM을 원활하게 통합하기","description":"","date":"2024-05-20 15:55","slug":"2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png\" /\u003e\n\nKotlin Multiplatform Mobile (KMM)은 Android 및 iOS 애플리케이션 간에 코드를 공유할 수 있게 해주어 개발을 더 신속하고 효율적으로 만듭니다.\n\n본 안내서는 KMM을 기존의 Android 프로젝트에 통합하는 단계를 안내합니다. Android 앱의 고유한 기능을 희생하지 않고 공유 코드를 활용할 수 있도록 보장합니다.\n\n필수 준비물:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기존 Android 앱.\n\n## 단계 1: KMM 모듈 생성하기:\n\n- Android Studio에서 File -` New -` New Module로 이동합니다.\n- KMM Shared Module을 선택합니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 Android Studio에서 KMM 공유 모듈을 찾을 수 없다면 걱정하지 마세요. 설정에 숨겨져 있습니다.\n\n## 단계 2: 앱 모듈에 공유 모듈 포함하기:\n\n- settings.gradle 파일을 열고 KMM 모듈 종속성이 추가되었는지 확인하세요 (이 작업은 자동으로 수행됩니다).\n- app/build.gradle 파일에서 다음 종속성을 추가하세요:\n\n```js\nimplementation project(\":shared\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 3: Kotlin DSL용 빌드 스크립트 업데이트(필요한 경우):\n\n만약 Android 프로젝트가 빌드에 실패한다면, KMM 모듈이 Kotlin DSL을 사용하고 있을 가능성이 높습니다. 다음과 같이 shared/build.gradle.kts에 의존성 설정을 변경하세요:\n\n```js\nplugins {\n    id(\"com.android.library\")\n    id(\"org.jetbrains.kotlin.multiplatform\")\n}\n\nkotlin {\n    android()\n    sourceSets {\n        val androidMain by getting {\n            dependencies {\n                implementation(\"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\")\n            }\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n의존성 {\n    구현(\"org.jetbrains.kotlin:kotlin-test:$kotlin_version\")\n}\n```\n\n## 단계3: 빌드 및 확인:\n\n- 프로젝트를 Gradle 파일과 동기화하고 빌드가 성공적으로 완료되는지 확인합니다.\n- 빌드 과정 중 발생하는 어떤 문제든 해결합니다.\n\n## 단계4: 앱에서 공유 코드 사용:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이제 KMM 모듈의 공유 코드를 Android 프로젝트에서 사용할 수 있습니다. 예를 들어 Android 액티비티나 프래그먼트에서 필요한 대로 공유 클래스 및 함수를 가져올 수 있습니다.\n\n## 단계5: 빌드 및 확인\n\n- Android 프로젝트를 실행하여 모든 것이 올바르게 통합되었고 공유 코드가 기대대로 작동하는지 확인하십시오.\n\n이러한 단계를 따라서 기존 Android 프로젝트에 KMM을 성공적으로 통합할 수 있으며, Android와 기타 플랫폼 간에 코드를 원할하게 공유하여 개발 프로세스를 강화하고 노력의 중복을 줄일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 시리즈의 내용을 기대해주세요. KMM을 기존 iOS 프로젝트에 통합하는 방법을 살펴볼 예정입니다.","ogImage":{"url":"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png"},"coverImage":"/assets/img/2024-05-20-SeamlesslyIntegrateKotlinMultiplatformMobileKMMintoYourAndroidProject_0.png","tag":["Tech"],"readingTime":3},{"title":"안드로이드에서 Room 데이터베이스 시작하기","description":"","date":"2024-05-20 15:54","slug":"2024-05-20-GettingStartedwithRoomDatabaseinAndroid","content":"\n\n## Room 데이터베이스 구현에 대한 포괄적인 안내\n\n![Android Room Database](/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png)\n\n## 소개:\n\n로컬 데이터 저장은 많은 안드로이드 애플리케이션에게 중요하며, 데이터를 효율적으로 저장하고 검색할 수 있게 합니다. 이 안내서에서는 안드로이드 앱에서 데이터베이스 관리를 간편하게 하는 강력한 라이브러리인 Room을 살펴보겠습니다. Room 설정부터 데이터베이스 작업 수행 및 마이그레이션 처리까지 모두 다룰 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_1.png\" /\u003e\n\n## 섹션 1: Room 데이터베이스 설정하기\n\n단계 1: 종속성 추가\n앱의 `build.gradle` 모듈 레벨 파일을 열어 Room 및 Kotlin Coroutines (비동기 작업을 위한)에 필요한 종속성을 추가해주세요:\n\n```js\ngradle\ndependencies {\n def roomVersion = \"2.4.0\" // 최신 버전을 확인하세요\n implementation \"androidx.room:room-runtime:$roomVersion\"\n kapt \"androidx.room:room-compiler:$roomVersion\"\n implementation \"androidx.room:room-ktx:$roomVersion\"\n implementation \"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2\" // 코루틴 종속성 추가\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOR\n\n최신 안드로이드 및 Jetpack Compose에서 특정 오류로 실패하는 경우 'Kotlin 심볼 처리' ksp()을 추가해야 할 수도 있습니다.\n\n아래 종속성 및 플러그인을 build.gradle(모듈 레벨)에 추가해보세요.\n\n```js\nplugins {\n .\n .\n id \"com.google.devtools.ksp\"\n}\n\n.\n.\n.\n\ndependencies{\n  // Room 종속성\n    val room_version = \"2.5.2\"\n\n    implementation(\"androidx.room:room-ktx:$room_version\")\n    // Kotlin 주석 처리 도구 (kapt) 사용을 위해\n    ksp(\"androidx.room:room-compiler:$room_version\")\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 클래스 경로를 build.gradle(앱 레벨)에 KSP에 추가해주세요.\n\n```js\nplugins {\n    id \"com.google.devtools.ksp\" version \"1.8.10-1.0.9\" apply false\n}\n```\n\n단계 2: 엔티티 클래스 생성\n데이터베이스에서 테이블을 나타내기 위해 어노테이션을 사용하여 엔티티 클래스를 정의하세요. 예를 들어, `User` 엔티티를 생성해보겠습니다(각 데이터 멤버가 열 이름인 테이블로 간주합니다):\n\n```js\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n @PrimaryKey(autoGenerate = true) val id: Long = 0,\n val username: String,\n val email: String\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### Step 3: DAO (Data Access Object) Interface 생성\n데이터베이스 작업을 정의하기 위한 DAO 인터페이스를 생성하세요. 예를 들어, `UserDao`를 만들어보겠습니다:\n\n```kotlin\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.OnConflictStrategy\nimport androidx.room.Query\n\n@Dao\ninterface UserDao {\n\n @Insert(onConflict = OnConflictStrategy.REPLACE)\n suspend fun insertUser(user: User)\n\n @Query(\"SELECT * FROM users\")\n suspend fun getAllUsers(): List\u003cUser\u003e\n}\n```\n\n### Step 4: 데이터베이스 클래스 정의\n`RoomDatabase`를 확장하는 추상 클래스를 생성하여 데이터베이스 인스턴스를 정의하고 엔티티 및 DAO를 포함시키세요:\n\n```kotlin\nimport androidx.room.Database\nimport androidx.room.RoomDatabase\n\n@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStep 5: 데이터베이스 인스턴스 초기화하기\n`Application` 클래스나 관련 진입점에서 Room 데이터베이스 인스턴스를 초기화하세요:\n\n```kotlin\nimport android.app.Application\nimport androidx.room.Room\n\nclass MyApp: Application() {\n\n    companion object {\n        lateinit var database: AppDatabase\n    }\n\n    override fun onCreate() {\n        super.onCreate()\n        database = Room.databaseBuilder(\n            applicationContext,\n            AppDatabase::class.java,\n            \"my_database\"\n        ).build()\n    }\n}\n```\n\n## 섹션 2: 데이터베이스 작업 수행하기\n\nStep 1: 데이터 삽입\n사용자를 데이터베이스에 삽입하려면 `UserDao`에 정의된 `insertUser` 메서드를 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nval newUser = User(username = \"JohnDoe\", email = \"john@example.com\")\nMyApp.database.userDao().insertUser(newUser)\n```\n\n단계 2: 데이터 검색\n데이터베이스에서 모든 사용자를 검색하려면 `UserDao`의 `getAllUsers` 메서드를 사용하십시오:\n\n```js\nval userList: List\u003cUser\u003e = MyApp.database.userDao().getAllUsers()\n```\n\n인젝션 가능한 Room 데이터베이스 객체를 설정하는 데모 프로젝트를 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데모 프로젝트 링크: https://github.com/raikwaramit/RoomDatabaseModule/\n\n## 결론:\n\nAndroid 앱에서 Room 데이터베이스를 구현하면 데이터 저장을 간편하게 처리할 수 있습니다. 직관적인 설정과 강력한 기능으로 앱의 로컬 데이터를 효율적으로 관리할 수 있습니다. 이 가이드를 따라가면 Room 설정, 엔티티 및 DAO 정의, 데이터베이스 작업 수행, 마이그레이션 처리 방법을 배울 수 있습니다.\n\n이 가이드에서는 Room의 기본 사항을 다루었습니다. 라이브러리에 익숙해지면 데이터베이스 관계, LiveData 통합, 복잡한 쿼리와 같은 고급 기능을 탐색할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n룸을 사용하면 Android 앱에서 로컬 데이터를 관리하는 것이 더 쉬워집니다. 코딩을 즐기세요!","ogImage":{"url":"/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png"},"coverImage":"/assets/img/2024-05-20-GettingStartedwithRoomDatabaseinAndroid_0.png","tag":["Tech"],"readingTime":5},{"title":"코틀린 코루틴에서 에러 다루기 예외 처리와 에러 전파","description":"","date":"2024-05-20 15:53","slug":"2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation","content":"\n\n\n![image](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png)\n\n현대 비동기 프로그래밍 패러다임에서는 Kotlin 코루틴이 중심적인 역할을 합니다. 비동기 프로그래밍 프로세스 중 발생하는 오류를 효과적으로 처리하는 것은 애플리케이션의 견고성과 신뢰성에 중요합니다. 본 문서에서는 Kotlin 코루틴을 사용할 때 오류 관리의 중요한 측면을 탐구하고 오류 전파의 복잡성을 다루고자 합니다.\n\n비동기 프로그래밍은 현대 소프트웨어 개발에서 널리 사용됩니다. 그러나 이러한 프로그래밍 프로세스에서 오류를 만나는 것은 불가피합니다. 네트워크 호출, 파일 작업, 데이터베이스 상호작용 및 기타 외부 소스에서 발생하는 오류를 효과적으로 해결하여 애플리케이션의 신뢰성과 사용자 경험을 보장해야 합니다. Kotlin 코루틴은 비동기 프로그래밍 시 이러한 오류를 처리하는 다양한 도구와 전략을 제공합니다.\n\n# 코루틴 스코프 내에서 오류 처리\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKotlin 코루틴을 사용할 때, 코루틴 스코프 내에서 오류 처리를 확실히 하는 것은 비동기 작업을 효과적으로 관리하는 데 중요합니다. 코루틴 스코프는 특정 작업의 라이프사이클을 제어하며, 내부에서 발생할 수 있는 모든 오류를 적절히 처리해야 합니다.\n\n![image](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_1.png)\n\n위 예시에서는, 코루틴 내에서 발생하는 오류가 외부 스코프에서 캐치되어 적절히 처리될 수 있습니다.\n\n# Supervisor Jobs\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSupervisor 작업은 특히 병렬 coroutine이 관련된 시나리오에서 오류 관리에 필수적인 도구입니다. Supervisor 작업은 한 coroutine에서 발생한 오류가 다른 coroutine에 영향을 미치지 않도록 보장하여 응용 프로그램의 전체 강건성을 향상시킵니다.\n\n![이미지](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_2.png)\n\nSupervisor 작업을 사용하면 coroutine의 오류가 다른 coroutines에 영향을 주지 않도록하여 프로세스가 계속될 수 있습니다.\n\n# 오류 전파\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 오류가 전파되는 방법에 대해 이야기해 보겠습니다. 코루틴에서 결과를 기다리다가 문제가 발생하면 어떻게 처리할 수 있는지 알아봅시다:\n\n![이미지](/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_3.png)\n\n위의 예제에서 우리는 async 코루틴 내에서 예외를 던지고 적절히 예외를 처리하여 처리하는 방법을 확인할 수 있습니다.\n\n그럼 이제 여기까지입니다! 코틀린 코루틴을 사용하면 오류 처리가 쉬워집니다. 코루틴 스코프 내에서, 슈퍼바이저 작업을 사용하여, 또는 오류 전파를 다룰 때, 코드를 견고하고 신뢰할 수 있게 유지할 수 있는 도구를 갖고 있습니다. 그러니 맘 놓고 코루틴에 더 깊이 파고들어보고 오류를 두려워하지 마세요!","ogImage":{"url":"/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png"},"coverImage":"/assets/img/2024-05-20-DealingwithErrorsinKotlinCoroutinesExceptionHandlingandErrorPropagation_0.png","tag":["Tech"],"readingTime":2},{"title":"루비 온 레일즈에서의 유효성 검사를 위한 모범 사례들","description":"","date":"2024-05-20 15:52","slug":"2024-05-20-BestPracticesforValidationsinRubyonRails","content":"\n\n\n![Validation](/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png)\n\n유효성 검사는 웹 응용 프로그램 개발의 중요한 측면으로, 사용자가 입력한 데이터가 처리되거나 저장되기 전에 특정 기준을 충족시키도록 하는 것을 보장합니다. 루비 온 레일즈(Ruby on Rails)에서는 ActiveRecord의 강력한 내장 유효성 검사 메서드 덕분에 유효성 검사를 구현하기가 간단합니다. 이 기사에서는 레일즈 애플리케이션에서 유효성 검사를 구현하는 최선의 방법에 대해 안내해 드리겠습니다.\n\n# 유효성 검사의 중요성\n\n유효성 검사는 응용 프로그램의 데이터 무결성과 일관성을 보장합니다. 데이터베이스에 잘못된 데이터가 저장되는 것을 방지하여 응용 프로그램 오류, 보안 취약점 및 기타 문제가 발생하는 것을 방지합니다. 모델 수준에서 데이터를 유효성 검사함으로써 데이터 무결성 논리를 집중시킴으로써, 응용 프로그램을 유지 보수 가능하고 안전하게 만듭니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일반적인 유효성 검증\n\n루비 온 레일즈는 모델을 유효성 검증하는 데 사용할 수 있는 다양한 내장 유효성 검증 도우미를 제공합니다. 여기에는 일반적으로 사용되는 몇 가지가 있습니다:\n\n1. **Presence(존재)**: 필드가 비어있지 않은지 확인합니다.\n\n```js\nvalidates :name, presence: true\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n독특성: 값이 테이블 전체에서 고유한지 확인합니다.\n\n```js\nvalidates :email, uniqueness: true\n```\n\n형식: 정규 표현식을 사용하여 필드가 특정 형식에 일치하는지 확인합니다.\n\n```js\nvalidates :email, format: { with: URI::MailTo::EMAIL_REGEXP }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n숫자 정합성: 필드가 숫자임을 보장하고 숫자 제약 조건을 유효성 검사할 수도 있습니다.\n\n```js\nvalidates :age, numericality: { only_integer: true, greater_than: 0 }\n```\n\n# 유효성 검사 구현을 위한 모범 사례\n\n## 내장된 유효성 검사기 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가능한 한 Rails의 내장 유효성 검사기를 활용하세요. 이들은 테스트를 거친 상태이며 다양한 일반적인 유효성 검사 요구사항을 다룹니다. 내장 유효성 검사기를 사용하면 코드가 더 읽기 쉽고 유지보수하기 쉬워집니다.\n\n```js\nclass User \u003c ApplicationRecord\n  validates :email, presence: true, uniqueness: true, format: { with: URI::MailTo::EMAIL_REGEXP }\nend\n```\n\n## 사용자 정의 유효성 검사\n\n내장 도우미로 다루기 어려운 복잡한 유효성 검사 로직이 필요한 경우, 사용자 정의 유효성 검사 메서드를 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```ruby\nclass User \u003c ApplicationRecord\n  validate :password_complexity\n\n  def password_complexity\n    return if password.blank? || password =~ /(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])/\n\n    errors.add :password, 'must include at least one lowercase letter, one uppercase letter, and one digit'\n  end\nend\n```\n\n## 조건부 유효성 검사\n\n가끔 필드를 특정 조건에서만 유효성을 검사해야 할 때가 있습니다. Rails에서는 :if와 :unless 옵션을 통해 이를 쉽게 할 수 있습니다.\n\n```ruby\nclass User \u003c ApplicationRecord\n  validates :ssn, presence: true, if: :adult?\n\n  def adult?\n    age \u003e= 18\n  end\nend\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 유효성 검사 및 데이터베이스 제약조건\n\nActiveRecord 유효성 검사는 강력하지만 애플리케이션 수준에서만 실행됩니다. 중요한 유효성 검사의 경우, 데이터베이스 수준에서도 제약조건을 강제하세요. 이렇게 하면 두 겹의 보호막이 제공됩니다.\n\n```js\n# 마이그레이션\nadd_index :users, :email, unique: true\n```\n\n## 지나치게 유효성 검사 피하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n너무 많은 유효성 검사를 하지 않도록 주의해주세요. 지나치게 엄격한 유효성 검사는 사용자에게 답답한 경험을 줄 수 있습니다. 필요한 유효성 검사를 실행하고 사용자에게 의미 있는 피드백을 제공해 주세요.\n\n## 오류 메시지\n\n사용자 친화적인 오류 메시지를 표시해 주세요. 기본 오류 메시지는 최종 사용자에게는 너무 기술적일 수 있습니다.\n\n```js\nclass User \u003c ApplicationRecord\n  validates :username, presence: { message: \"빈 칸일 수 없습니다\" }\nend\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 유효성 검사 테스트\n\n언제나 유효성 검사에 대한 테스트를 작성하세요. 이렇게 함으로써 해당 기능이 예상대로 작동하는지 확인할 수 있으며, 미래의 회귀 사항을 방지할 수 있습니다.\n\n```ruby\n# spec/models/user_spec.rb\nrequire 'rails_helper'\n\nRSpec.describe User, type: :model do\n  it '유효한 이메일로 유효성이 유효해야 합니다' do\n    user = User.new(email: 'user@example.com')\n    expect(user).to be_valid\n  end\n\n  it '이메일이 없으면 유효하지 않아야 합니다' do\n    user = User.new(email: nil)\n    user.valid?\n    expect(user.errors[:email]).to include(\"can't be blank\")\n  end\n\n  it '중복된 이메일로는 유효하지 않아야 합니다' do\n    User.create!(email: 'user@example.com')\n    user = User.new(email: 'user@example.com')\n    user.valid?\n    expect(user.errors[:email]).to include('has already been taken')\n  end\nend\n```\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.","ogImage":{"url":"/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png"},"coverImage":"/assets/img/2024-05-20-BestPracticesforValidationsinRubyonRails_0.png","tag":["Tech"],"readingTime":4},{"title":"성능 비교 Ruby 대 Python 대 Go  문자 발생 횟수 세기","description":"","date":"2024-05-20 15:51","slug":"2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences_0.png\" /\u003e\n\n# 소개\n\n저는 얼마 동안 Ruby로 작업해오다 최근 Python과 Go를 배우기 시작했습니다. 오늘은 릿코드 문제 1347번, '두 문자열을 애너그램으로 만들기 위한 최소 단계 수'를 해결했습니다. Ruby 언어로 쉽게 해결했는데 궁금해서 Python과 Go에서도 시도해 보았더니, 놀랄 정도로 Go가 다른 두 언어와 비교했을 때 얼마나 빠르고 효율적인지에 깜짝 놀랐습니다. 이 차이를 보는 것이 흥미로운데, 더 많은 코딩 모험에 대해 더 많이 공유하고 싶습니다!\n\n이 성능 탐구에서는 간단한 알고리즘을 세 가지 인기 프로그래밍 언어인 Ruby, Python 및 Go에서 실행 시간과 메모리 사용량에 대해 탐구합니다. 작업은 문자열에서 문자 발생 횟수를 계산하고 한 문자열을 다른 문자열로 변환하는 데 필요한 최소 단계를 계산하는 것을 포함합니다. 각 언어로 프로그램을 작성하는 것을 넘어, 이 분석은 Ruby, Python 및 Go가 도전 과제를 어떻게 처리하는지에 대해 밝혀내어, 실행 시 동작 및 메모리 효율성에 대한 통찰을 제공합니다. 이 언어들의 동작을 보다 깊게 이해하기 위해 계속 주목해 주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루비 구현:\n\n```js\ndef min_steps(s, t)\n  min_steps = 0\n  h = Hash.new(0)\n  s.each_char do |c|\n    h[c] += 1\n  end\n\n  t.each_char do |c|\n    h[c].positive? ? h[c] -= 1 : min_steps += 1\n  end\n  min_steps\nend\n```\n\n파이썬 구현:\n\n```js\nclass Solution:\n    def minSteps(self, s: str, t: str) -\u003e int:\n        d = {}\n        count = 0\n        for c in s:\n            d[c] = 1 if not d.get(c) else d[c] + 1\n        \n        for c in t:\n            if d.get(c):\n                d[c] -= 1\n            else:\n                count += 1\n        \n        return count\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGo 구현:\n\n```js\nfunc minSteps(s string, t string) int {\n    minSteps := 0\n    h := make(map[rune]int)\n\n    for _, c := range s {\n        h[c]++\n    }\n\n    for _, c := range t {\n        if h[c] \u003e 0 {\n            h[c]--\n        } else {\n            minSteps++\n        }\n    }\n\n    return minSteps\n}\n```\n\n결과:\n\n\n| 언어     | 실행 시간 (밀리초) | 메모리 사용량 (메가바이트) |\n|----------|------------------|--------------------------|\n| Ruby     | 504              | 218.2                    |\n| Python   | 164              | 17.9                     |\n| Go       | 58               | 6.6                      |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 관찰 및 설명:\n\n루비, 파이썬 및 Go로 구현된 제공된 알고리즘의 성능 비교에서 런타임 및 메모리 사용량에 상당한 차이가 관찰되었습니다. 이러한 차이는 각 프로그래밍 언어의 독특한 설계 철학과 실행 모델에서 비롯됩니다.\n\n- 런타임 차이:\n\n- 루비: 루비는 해석형 언어로, 컴파일된 언어와 비교해 일반적으로 더 높은 런타임을 갖습니다.\n- 파이썬: 파이썬은 루비보다 더 좋은 런타임 성능을 갖지만 Go에는 미치지 못합니다.\n- Go: Go는 정적 형식의 컴파일 언어로, 강력한 성능 특성을 갖추어 가장 빠른 런타임을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 메모리 사용량:\n\n- Ruby와 Python: 이러한 언어들은 특히 동적 상황에서 더 높은 메모리 사용량으로 알려져 있습니다.\n- Go: 효율성을 위해 설계된 Go는 낮은 메모리 소비로 이어집니다.\n\n## 3. 언어 디자인:\n\n- Ruby와 Python: 동적 타입 및 고수준 추상화는 유연성에 기여하지만 성능에 영향을 줄 수 있습니다.\n- Go: 정적 타입 및 컴파일된 Go는 간결함과 성능을 강조합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. Garbage Collection:\n\n- 루비와 파이썬: 자동 메모리 관리(가비지 컬렉션)는 오버헤드를 발생시킬 수 있습니다.\n- Go: 효율적인 가비지 컬렉션 전략을 갖추어 낮은 메모리 사용량을 제공합니다.\n\n5. 실행 환경:\n\n- 루비와 파이썬: 인터프리터 언어는 런타임 환경에 의존하여 오버헤드가 발생할 수 있습니다.\n- Go: 네이티브 이진 파일이 컴파일되어 인터프리터를 필요로 하지 않고 빠른 실행이 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론:\n\n이 비교에서 관찰된 성능 차이는 언어 특징, 런타임 환경 및 메모리 관리 전략 사이의 트레이드오프를 강조합니다. 정적으로 타입 지정되고 컴파일된 Go 언어는 런타임 및 메모리 사용량 측면에서 우수한 성능을 보여줍니다. 개발자 친화적인 문법과 동적 기능을 제공하는 Python과 Ruby는 사용 편의성을 위해 성능을 어느 정도 포기할 수 있습니다. 이러한 차이를 이해하면 개발자들이 개발 속도, 사용 편의성 및 성능 요구사항과 같은 요소를 균형있게 고려해 특정 사용 사례에 적합한 언어를 선택할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences_0.png"},"coverImage":"/assets/img/2024-05-20-PerformanceComparisonRubyvsPythonvsGoCountingCharacterOccurrences_0.png","tag":["Tech"],"readingTime":4},{"title":"테스트 속도를 높이는 parallel_tests의 힘을 활용해보세요 로컬 설정 및 실행법","description":"","date":"2024-05-20 15:50","slug":"2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution","content":"\n\n# parallel_tests란 무엇인가요?\n\n이는 RSpec, Cucumber 및 기타 테스트 도구 그룹의 실행 속도를 높이기 위해 사용되는 Ruby gem입니다.\n\nParallelTests는 테스트를 균형 잡힌 그룹(라인 수 또는 실행 시간으로)으로 분할하고 각 그룹을 해당 데이터베이스와 함께 프로세스에서 실행합니다.\n\n# 설정 및 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- .zshrc 파일에 export PARALLEL_TEST_PROCESSORS=n을 추가하여 세그먼트 수를 지정하세요.\n- `test` 섹션 내에서 database.yml 파일에 병렬 테스트 구성을 추가하세요.\n\n```js\ntest:\n database: yourproject_test\u003c%= ENV['TEST_ENV_NUMBER'] %\u003e\n```\n\n- .rspec 파일에 형식 구성을 추가하세요.\n\n```js\n--format progress\n--format ParallelTests::RSpec::RuntimeLogger --out tmp/parallel_runtime_rspec.log\n--format ParallelTests::RSpec::SummaryLogger --out tmp/spec_summary.log\n--format ParallelTests::RSpec::FailuresLogger --out tmp/failing_specs.log\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다음 명령을 실행하여 병렬 테스트 데이터베이스를 생성하세요: rake parallel:create.\n- 마이그레이션에 업데이트가 있는 경우 rake parallel:migrate를 실행하세요.\n- rake parallel:prepare 명령을 사용하여 개발 스키마를 복사하세요.\n- 병렬로 스펙을 실행하려면 rake parallel:spec 명령을 사용하세요.\n- 모든 병렬 테스트 데이터베이스를 삭제하려면 rake parallel:drop 명령을 실행하세요.\n\n참고사항:\n\n- 기본적으로 PARALLEL_TEST_PROCESSORS의 수는 기기의 프로세서 수로 설정됩니다.\n- 모든 작업을 한 번에 처리하려면 🤩 다음 명령어를 사용하세요 \n\n```js\nRAILS_ENV=test PARALLEL_TEST_PROCESSORS=6\nrails db:drop db:create db:migrate parallel:prepare parallel:spec\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 장점\n\n- 빠른 테스트 실행 달성\n일반적으로 병렬 테스트를 사용하지 않을 때 테스트 실행에 약 1.5시간이 소요된다고 가정해 보겠습니다. 그러나 6개 코어를 이용하여 병렬 테스트를 수행하면 이 시간을 15분에서 20분으로 줄일 수 있어 대략 85~90%의 속도 향상이 가능합니다.\n- 최적화된 자원 활용\n6개 코어를 보유한 상황을 가정해 봅시다. 병렬 테스트를 사용하지 않는다면 모든 사양은 단일 코어에서만 실행됩니다. 그러나 병렬 테스트를 활용하면 여러 코어를 이용하여 사양을 실행할 수 있습니다.\n- Rails와의 원활한 통합\n한 번만 병렬 테스트를 구성하면 여러 테스트 도구에서 사용할 수 있습니다. 예를 들어, RSpec을 사용하는 경우 rake parallel:spec을 실행할 수 있습니다. Minitest로 전환한다면 실행 명령을 rake parallel:test로 변경하기만 하면 됩니다.\n\n# 결점\n\n- 자원 부담\n병렬로 테스트를 실행하는 것은 CPU 및 메모리와 같은 추가 시스템 자원을 소비합니다.\n- 불안정성 가능성\n캐싱이나 Redis와 같은 공유 자원을 활용하는 일부 사양은 설정되어 있지만 다른 세그먼트의 사양에서는 해당 자원을 읽을 수 있습니다. 이로 인해 오류나 일관성에 문제가 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자원\n\n- 문서\n\n# 결론\n\n요약하자면, 더 빠른 테스트를 위해 병렬 테스트를 활용하는 것은 상당한 이점을 제공합니다. 자원 활용을 최적화하고 Rails와 완벽하게 통합되어 테스트 실행 시간을 크게 줄입니다. 그러나 자원 과부하 및 안정성과 같은 잠재적인 단점에 대해 주의해야 합니다. 적절한 구성과 모니터링으로 병렬 테스트가 개발 프로세스에서 유용한 자산임을 입증했습니다. 더 많은 지침을 위해서 문서를 참조하세요.","ogImage":{"url":"/assets/img/2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution_0.png"},"coverImage":"/assets/img/2024-05-20-HarnessingthePowerofparallel_testsforFasterTestingLocalSetupandExecution_0.png","tag":["Tech"],"readingTime":3},{"title":"루비 온 레일즈로 CORS 구성하기 - 2부","description":"","date":"2024-05-20 15:49","slug":"2024-05-20-ConfiguringforCORSwithRubyonRailsPartII","content":"\n\n여러 달 전에, 프록시를 사용하여 CORS 오류를 해결하는 방법에 대해 게시물을 게시했었어요. 배포할 때까지는 잘 되지만, 프록시를 설정하는 것이 최선의 방법이 아니라는 것을 빨리 깨달았어요. 이전 포스트에서 놓친 요소 중 하나는 Ruby on Rails API를 빌드할 때 사용자 인증을 통합하는 경우에 Rack-CORS를 구성하는 것이었어요. 이 포스트는 개인 프로젝트에서 개발 및 프로덕션에서 CORS 오류를 디버깅하면서 배운 내용을 요약한 것이에요.\n\n처음에 제가 채택한 접근 방식은 순수한 Ruby를 사용하는 것이었어요. 이 방법은 분명 더 복잡했지만, 사전 플라이트 HTTP 요청 주변의 세부 사항을 이해하고 요청/응답 헤더가 동작하는 실제 내용을 이해하는 데 도움이 되었어요. 그래서 이 방법을 간소화하기 전에 CORS 오류를 해결하는 첫 번째 방법으로 제시하고 있어요.\n\n## CORS 사전 체크 — HTTP OPTIONS 요청\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_1.png)\n\n가장 먼저 이해해야 할 것은 프런트엔드가 백엔드에 보내는 HTTP 요청의 유형에 따라 해당 요청이 처리되기 전에 완료되는 CORS 사전검사입니다. 이는 보내려는 HTTP 요청이 안전한지 여부를 결정합니다. 사전검사는 HTTP OPTIONS 메서드를 통해 수행됩니다. 개발 도구의 네트워크 탭에서 사전검사 및 fetch 요청을 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_2.png)\n\nOPTIONS 요청에는 다음과 같은 요청 헤더가 포함될 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Origin: 요청이 온 곳을 나타냅니다. 예를 들어, 개발 중이라면 \"http://localhost:3000\"이거나 배포된 앱이라면 \"http://127.0.0.1:5173\" 또는 \"http://yourwebsite.production.app\"입니다.\n- Access-Control-Request-Method: 사용 가능한 HTTP 메소드를 나타냅니다. 예를 들어, GET, POST, PUT, PATCH, DELETE, OPTIONS가 있습니다.\n- Access-Control-Request-Headers: 실제 요청을 보낼 때 프론트엔드 애플리케이션이 보낼 수 있는 HTTP 헤더를 지정합니다.\n- Access-Control-Request-Credentials: 요청이 인증을 요구하는지를 결정합니다. 요구되면 true로 설정하고, 그렇지 않으면 생략됩니다. 이 헤더의 유효한 값은 true뿐입니다.\n- Access-Control-Max-Age: 프리플라이트 요청의 결과를 캐싱할 수 있는 시간(초)을 결정하는 선택적인 헤더입니다. MDN 문서에 따르면, 기본값은 5초이며 최대 24시간(86400초)입니다.\n\n만약 서버가 프리플라이트 확인에 적절한 응답 헤더를 제공한다면, 그때에만 프론트엔드가 실제 HTTP 요청을 계속할 수 있습니다. 프리플라이트 확인이 실패하면 적절한 헤더가 제공되지 않았기 때문에 아래와 같이 콘솔에서 볼 수 있는 오류의 예시가 있습니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_3.png\" /\u003e\n\n## 루비 온 레일즈를 이용한 CORS 구성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법을 사용하면 추가적인 젬이나 종속성을 설치할 필요가 없습니다. 첫 번째 단계는 요청을 CORS 컨트롤러로 라우팅할 config/routes.rb에 OPTIONS 라우트를 추가하는 것입니다. 아래 예시에서는 ' /login', ' /signup', ' /logout', '그리고 ' /users' 네 개의 라우트를 추가했습니다.\n\n```js\n# config/routes.rb에 추가\n\nRails.application.routes.draw do\n\n  match '/login', controller: 'cors', action: 'cors_preflight_check', via: [:options]\n  match '/signup', controller: 'cors', action: 'cors_preflight_check', via: [:options]\n  match '/logout', controller: 'cors', action: 'cors_preflight_check', via: [:options]\n  match '/users', controller: 'cors', action: 'cors_preflight_check', via: [:options]\n  # ... 다른 라우트들은 여기에 추가\n\nend\n```\n\n구성하려는 특정 엔드포인트들이 있으면 아래와 같이 개별적으로 추가하여 `path`와 `컨트롤러의 이름`을 대체할 수 있습니다:\n\n```js\nmatch '\u003cpath\u003e', controller: \"\u003c컨트롤러의 이름\u003e\", action: 'cors_preflight_check', via: [:options]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 애플리케이션은 약 20개의 엔드포인트로 끝났어요. OPTIONS 요청을 경로하는 DRY한 방법은 아래와 같습니다. 모든 OPTIONS 요청을 와일드카드 \"*\" 경로를 사용하여 한 컨트롤러와 메소드에 경로하려면 이 방법이 작동합니다.\n\n```js\n# config/routes.rb에 추가\n\nRails.application.routes.draw do\n\n  options '*path', to: 'application#cors_preflight_check'\n  # ... 다른 루트\n\nend\n```\n\n그 다음으로 app/controllers에 cors_controller.rb 파일을 생성하고 다음 메소드를 추가하세요. HTTP 메소드가 OPTIONS인 경우 cors_preflight_check 메소드가 cors_set_access_control_headers 메소드를 실행합니다.\n\n```js\n# app/controllers/cors_controller.rb에 추가:\n\nclass CorsController \u003c ApplicationController\n\n    def cors_preflight_check\n        if request.method == 'OPTIONS'\n          cors_set_access_control_headers\n          render text: '', content_type: 'text/plain'\n        end\n      end\n\n    protected\n\n    def cors_set_access_control_headers\n        response.headers['Access-Control-Allow-Origin'] = \"http://localhost:4000\"\n        response.headers['Access-Control-Allow-Credentials'] = \"true\"\n        response.headers['Access-Control-Allow-Methods'] = 'POST, GET, PUT, PATCH, DELETE, OPTIONS'\n        response.headers['Access-Control-Allow-Headers'] = 'Origin, Content-Type, Accept, Authorization, Token, Auth-Token, Email, X-User-Token, X-User-Email'\n        response.headers['Access-Control-Max-Age'] = '86400'\n    end\n\nend\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncors_set_access_control_headers 메서드는 적절한 응답 헤더를 설정합니다. Access-Control-Allow-Methods, Access-Control-Allow-Headers 및 Access-Control-Max-Age에 대해 각각 모든 HTTP 메소드, 허용되는 모든 헤더 및 최대 캐시 기간을 나열했습니다.\n\nOrigin 및 Credentials에 초점을 맞추고 싶습니다. 인증된 요청이 필요하지 않다면 Origin 헤더에 와일드카드 \"*\"를 사용하여 서버가 모든 원본에서 요청을 수락하도록 할 수 있습니다. 그러나 로그인, 가입 등과 같은 인증이 필요한 HTTP 요청의 경우, 원본으로 와일드카드 \"*\"를 사용할 수 없습니다. 시도하면 다음과 같은 오류가 발생합니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_4.png\" /\u003e\n\n따라서 인증이 필요한 경우 프론트엔드 애플리케이션의 원본을 명시해야 합니다. API에 액세스를 허용하고 싶은 여러 원본이 있는 경우, response.headers['Access-Control-Allow-Origin']을 다음과 같이 업데이트할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# in app/controllers/cors_controller.rb:\ndef cors_set_access_control_headers\n        response.headers['Access-Control-Allow-Origin'] = check_origin\n        response.headers['Access-Control-Allow-Credentials'] = \"true\"\n        response.headers['Access-Control-Allow-Methods'] = 'POST, GET, PUT, PATCH, DELETE, OPTIONS'\n        response.headers['Access-Control-Allow-Headers'] = 'Origin, Content-Type, Accept, Authorization, Token, Auth-Token, Email, X-User-Token, X-User-Email'\n        response.headers['Access-Control-Max-Age'] = '86400'\nend\n\ndef check_origin\n        permitted_origins = Set[\n            \"http://localhost:4000\", \n            \"http://127.0.0.1:4000\",\n            \"http://yourwebsite.production.app\",\n            /\\Ahttps:\\/\\/deploy-preview-\\d{1,4}--yourwebsite\\.domain\\.app\\z/\n        ]\n\n        origin = request.origin\n\n        if permitted_origins.include?(origin)\n            origin\n        else\n            render json: { error: \"Origin not permitted\" }\n        end\nend\n```\n\ncheck_origin 메소드 내에서, 허용된 origin을 Set으로 정의합니다. 여기에 Rail API가 허용할 origin을 추가합니다: 포트 번호가 포함된 localhost 및 프론트엔드 응용 프로그램이 배포된 경우의 프로덕션 URL 등이 포함됩니다.\n\n[선택사항] 내 응용 프로그램에서 프론트엔드를 배포하기 위해 Netlify를 사용하고 있었으며, Netlify의 CI/CD의 일부로 \"https://deploy-preview-123--yourwebsite.netlify.app\"와 같은 형식의 배포 미리보기가 생성됩니다. 여기서 \"123\"은 길이가 3 이상인 정수 문자열일 수 있습니다. 이것을 해결하기 위해 유연성을 제공하고 Netlify의 미리보기 모드로 배포된 앱을 계속 테스트할 수 있도록 하기 위해 정규식을 추가했습니다.\n\n[주의] Origin을 정의할 때 슬래시(/)가 앞뒤로 제대로 있는지에 주의하십시오. 이를 제대로 맞추기 위해 백엔드를 5번 재배포해야 할 것 같았습니다..\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 다입니다! Rails 서버를 다시 시작하면 CORS 오류가 더 이상 표시되지 않아야 합니다.\n\n## Postman에 대한 참고 사항\n\nAPI를 테스트할 때 Postman을 사용할 때, Postman에 대한 origin이 설정되어 있지 않아도 CORS가 발생하지 않는 것을 알았습니다. 이는 Postman의 기본 origin이 “nil”로 설정되어 있기 때문입니다. 따라서 Postman은 API를 테스트하는 데 훌륭하지만, 프론트엔드와 백엔드 응용 프로그램을 연결하고 HTTP 요청이 다른 도메인에서 전송되는 경우에만이 문제가 발생한다는 점을 기억해 주세요. 저는 개발 중에, 배포 중에, 그리고 CI/CD에서 여러 번 이 문제를 겪었습니다 (즐겁게요...)!\n\n## Rack-CORS Gem 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Vanilla Ruby를 사용하여 상세 구현을 살펴 보았습니다. Rack-CORS gem을 사용하여 이를 간단하게 만들어 봅시다.\n\n먼저 Gemfile에 rack-cors gem을 추가하세요. 이미 추가되어 있을 수 있으므로 주석 처리만 해제해야 할 수도 있습니다.\n\n```js\n# Gemfile에 추가\ngem 'rack-cors'\n```\n\n그런 다음 다음 명령어로 설치하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n번들 설치\n\ncors.rb를 구성하세요. 일반적인 Ruby 케이스에서 위와 같은 구성을 달성하려면 config/initializers/cors.rb로 이동하여 미들웨어 구성 코드 블록 주석 처리를 해제하고 다음과 같이 수정하세요:\n\n```js\n# in config/initializers/cors.rb\n\nRails.application.config.middleware.insert_before 0, Rack::Cors do\n  allow do\n    origins \"http://localhost:4000\"\n            \"http://127.0.0.1:4000\",\n            \"http://yourwebsite.production.app\",\n            /\\Ahttps:\\/\\/deploy-preview-\\d{1,4}--yourwebsite\\.domain\\.app\\z/\n\n    resource \"*\",\n      headers: :any,\n      methods: [:get, :post, :put, :patch, :delete, :options, :head],\n      credentials: true,\n      max_age: 86400\n  end\nend\n```\n\n그런 다음 서버를 재시작하면 문제 없이 작동해야 합니다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRack-CORS를 사용하면 훨씬 쉬워지고 초반에 이를 어떻게 구성해야 할지 이해했더라면 훨씬 많은 시간을 절약할 수 있었을 텐데요. 하지만 HTTP 요청과 CORS 사전 확인에 대해 깊이 파헤친 것은 가치 있는 학습 경험이었습니다. 이를 통해 이러한 원칙을 다른 언어와 프레임워크로 번역할 수 있었죠. 예를 들어, CORS와 사전 확인 요청/응답 헤더를 이해하고 구성하는 것이 파이썬/Django로 CORS를 이해하고 구성하는 데 도움이 되었습니다.\n\n읽어 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_0.png"},"coverImage":"/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_0.png","tag":["Tech"],"readingTime":8},{"title":"루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴","description":"","date":"2024-05-20 15:48","slug":"2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_0.png\" /\u003e\n\n소프트웨어 개발에서 디자인 패턴은 흔한 문제에 대한 검증된 해결책을 제공하기 때문에 중요합니다. Ruby on Rails 개발자에게는 이러한 패턴을 이해하고 구현하는 것이 유지보수 가능하고 확장 가능하며 효율적인 응용 프로그램을 만들 수 있게 도와줍니다. Ruby on Rails 개발자가 꼭 알아야 할 다섯 가지 중요한 디자인 패턴을 소개합니다:\n\n# MVC (Model-View-Controller)\n\n## 개요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMVC 패턴은 루비 온 레일 애플리케이션의 아키텍처에 근간을 두고 있어요. 애플리케이션을 세 가지 연결된 구성 요소로 구분합니다:\n\n- Model: 데이터와 비즈니스 로직을 관리합니다.\n  \n- View: 정보의 표시를 관리합니다.\n  \n- Controller: 사용자 입력을 처리하고 Model과 상호 작용하여 View를 렌더링합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_1.png)\n\n## 장점\n\n역할의 분리: 각 구성 요소가 명확한 책임을 갖고 있어 코드베이스가 더 정리되고 관리하기 쉬워집니다.\n\n테스트 용이성: 각 구성 요소를 격리시켜 개별적으로 테스트하기가 더 쉽습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예시\n\n\u003cimg src=\"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_2.png\" /\u003e\n\n# 서비스 객체\n\n## 개요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스 객체는 모델이나 컨트롤러에 자연스럽게 맞지 않는 비즈니스 로직을 캡슐화합니다. 이 패턴을 사용하면 모델과 컨트롤러를 가볍게 유지하고 주요 책임에 집중할 수 있습니다.\n\n![이미지](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_3.png)\n\n## 장점\n\n단일 책임 원칙: 각 서비스 객체는 특정 작업을 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n재사용성: 비즈니스 로직은 애플리케이션의 다른 부분에서 재사용할 수 있습니다.\n\n## 예시\n\n![이미지](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_4.png)\n\n# 데코레이터 패턴\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개요\n\n데코레이터 패턴은 동일한 클래스의 다른 객체들의 동작에 영향을 미치지 않으면서 개별 객체에 동작이나 책임을 추가하는데 사용됩니다. Rails에서는 Draper 젬이 데코레이터를 구현하는 데 자주 사용됩니다.\n\n## 이점\n\n확장성: 기존 코드를 변경하지 않고 쉽게 새로운 기능을 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프레젠테이션 로직 분리: 모델에서 프레젠테이션 로직을 유지합니다.\n\n## 예시\n\n![Example](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_5.png)\n\n# FORM OBJECT PATTERN\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개요\n\n폼 객체 패턴은 여러 모델을 관련시키는 양식 관련 로직을 캡슐화합니다. 이 패턴은 여러 모델과 상호 작용하거나 사용자 정의 유효성 검사가 필요한 복잡한 양식에 특히 유용합니다.\n\n![이미지](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_6.png)\n\n## 장점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n관심사 분리: 모델과 컨트롤러에서 양식 로직을 분리합니다.\n\n재사용성: 양식 객체는 응용 프로그램 전체에서 비슷한 양식에 재사용할 수 있습니다.\n\n## 예시\n\n![image](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 쿼리 오브젝트 패턴\n\n## 개요\n\n쿼리 오브젝트 패턴은 데이터베이스 쿼리 로직을 캡슐화하여 복잡한 쿼리를 더 깔끔하고 재사용 가능한 방식으로 관리하는 것을 제공합니다. 이는 모델을 가볍고 데이터를 표현하는 데 집중할 수 있도록 도와줍니다.\n\n## 장점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 관심사의 분리: 쿼리 논리를 모델 외부로 유지합니다.\n\n재사용성: 쿼리 객체는 응용 프로그램의 다양한 부분에서 재사용할 수 있습니다.\n\n![image](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_8.png)\n\n## 예제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_9.png\" /\u003e\n\n# 결론\n\n이 디자인 패턴을 이해하고 구현하는 것은 Ruby on Rails 애플리케이션의 품질을 크게 향상시킬 수 있습니다. 이러한 패턴은 깔끔하고 조직적이며 확장 가능한 코드를 유지하는 데 도움이 되어 개발을 더 효율적이고 관리하기 쉽게 만듭니다. Rails 개발자로서成해 나감에 따라, 이러한 패턴들은 개발 툴킷에서 가치 있는 도구가 될 것입니다.","ogImage":{"url":"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_0.png"},"coverImage":"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_0.png","tag":["Tech"],"readingTime":3},{"title":"25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지","description":"","date":"2024-05-20 15:42","slug":"2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024","content":"\n\n\n![Java Image](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_0.png)\n\n“프로그래밍 언어는 두 종류밖에 없어: 사람들이 불평하며 사용하는 것과 아무도 사용하지 않는 것.” — 바르네 스트롭스트룹.\n\n제가 Java를 배웠을 때, 객체지향 프로그래밍 열풍이 불었고 (90년대 후반), Java는 그 개념을 실제로 구현한 유일한 언어였던 것 같아요 (이전에 C++도 공부했지만, 정말로 한계라고 생각했죠).\n\n제가 Java가 어떻게 발전해 왔는지 정말 좋아했어요. Python을 살펴봤었는데, 사람들에게 열정을 일으키는 것 같지만, 저는 딱히 그 열풍에 휩싸이지 않았어요; 다시 말해서, 제가 충분히 깊은 수준으로 들어가지 못했을 수도 있어요. 제가 정말 큰 Java 프로젝트에서 일한 적이 있는데, 그들은 (합리적으로) 꽤 잘 다뤘어요; Python은 그 규모에서 상상도 못 해요. 하지만, 최근의 프로젝트들은 미니 서비스 방향으로 향하고 있는 것 같아요 — 아마 Python은 그것에 적합할지도 모르겠지만, 제게는 잘 모르는 분야예요. Java는 그 부분에 대해서는 알고 있어요.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바를 배울 때는 90년대 후반에 OOP 열풍이 한창이었고, 자바는 실제로 그 개념들을 구현한 언어로 빛이 났죠 (전에 C++을 배웠었지만, 정말). 저는 자바의 플랫폼 독립성을 감사히 여겼어요.\n\n제 생각에는 간결함보다는 구조와 일관성을 선호하는 편이기 때문에 자바를 계속 사용하고 있네요. \n\n제 경력 동안에는 이상적이지 않은 자바 코드베이스와 여러 번 마주치게 되었는데, 때로는 자바에 조금 심심해하기도 했어요. 하지만 다른 많은 훌륭한 프로젝트들에 참여하면서 자바를 다시 사랑하게 되었죠.\n\n자바에 대해 비판하고 불평하는 사람들은 종종 자바스크립트에 더 노출된 젊은 세대인 것 같아요. JS와 비교하면 자바는 조금 무겁고 제한적으로 느껴질 수 있어요 — 보일러플레이트가 많고, 컴파일러에 의해 엄격하게 시행되는 타입 시스템 등이 그 예시죠. 하지만 선택이 주어진다면, 저는 분명 자바 코드베이스가 서브옵티멀하더라도 JS보다는 자바를 선택할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현실 세계에서 일정 경험을 쌓은 후 수백 개의 파일에 흩어진 코드를 처리하면서, 자바의 이른바 \"한계\"는 실제로 발목을 다치지 않도록 방지하는 안전장치라는 것을 깨닫게 됩니다.\n\n\"C++의 창시자인 바네 스트롭스트룹이 할 말을 인용하면, '프로그래밍 언어는 두 가지 종류뿐이다: 사람들이 불평하는 것과 아무도 사용하지 않는 것'\"입니다.\n\n자바에 대한 불평이 많다고 생각하십니까? C++를 보세요. 사람들은 그 언어를 사랑하거나 미워하며 마치 피할 수 없는 학대적인 관계인 것처럼 대합니다.\n\n파이썬도 불평을 많이 받았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사람들은 계속해서 GIL(글로벌 인터프리터 락)이 진정한 효율적인 멀티스레딩을 방해한다고 말합니다. Python 코어의 많은 부분이 GIL에 의존하기 때문에 아마도 결코 제거되지 않을 것입니다. 그 결과로 사람들은 여러 프로세스를 사용하고 프로세스 간에 통신하기 위해 메시지 전달 체계를 만들어 이를 해결해야 했습니다. Python의 성능 또한 C/C++로 hotpaths를 다시 작성하지 않으면 굉장히 느립니다. 물론 Python 2에서 3으로의 전환도 그렇죠.\n\n한 번 Django 프로젝트를 작업했을 때(그때는 뜨거운 주제였던 시절) Python이 유형화된 언어보다 더 나은 것으로 생각했습니다(사용 용도에 따라 다르겠지만 1000개 이상의 클래스가 있는 복잡한 시스템에서는 아닙니다).\n\n이 프로젝트가 저 혼자 개발자인 상태에서 여러 사람이 참여하고 코드가 10,000줄 이상이 된 순간, 유지보수가 복잡해졌습니다.\n\nJava로 전환하고 다시 발견했을 때 놀랍다는 생각이 들었습니다. Java와 그 생태계를 사랑하는 것을 깨달았죠. 그래서 Java 생태계에 대해 좋아하는 몇 가지를 메모해 보기로 했습니다. 그래서 Java를 욕하는 누군가가 있다면, 그들이 틀렸다는 이유를 25가지로 설명해 줄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 생태계가 성숙합니다\n\n자바는 25년 이상 되었습니다. 이 생태계에서 개발자로 일해온 경험을 토대로, 이 생태계가 몇 년 동안 얼마나 성숙해졌는지 되돌아보는 것이 흥미롭습니다.\n\n자바의 넓은 생태계 중 가장 좋은 점은 다양한 라이브러리, 빌드 도구 및 프레임워크를 선택할 수 있다는 것입니다.\n\nJVM 생태계는 완벽하게 다양하며, 최상의 라이브러리로 거의 모든 문제에 대한 해법이 있으며 모두 고성능이며 잘 유지됩니다. 빌드 도구를 선택할 때 다양한 선택지가 있습니다. 예를 들어 빠르고 재현 가능한 빌드를 위해 Gradle, Maven 및 Bazel을 사용할 수 있습니다. 아직 이 생태계에 익숙하지 않은 경우, 자바는 기본 구현체로 로깅, 데이터베이스 연결, 메시징 및 응용 프로그램 서버와 같은 다양한 기능을 제공하여 좋은 출발점이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 애플리케이션에 로깅이 필요한 경우를 생각해보겠습니다. 걱정하지 마세요. Java는 JDK에 기본 로깅 옵션이 내장되어 있어 여러분을 지원해줍니다. 기본 옵션을 좋아하지 않거나 충분하지 않다면 어떻게 할까요? 기본 로깅은 로깅 API에 대한 참조 구현에 불과합니다. 선택할 수 있는 다른 훌륭한 로깅 라이브러리들이 있습니다.\n\n그리고 로깅 뿐만 아니라, Java 생태계는 데이터베이스 연결, 메시징, 애플리케이션 서버, 서블릿 등 다양한 옵션을 제공해줍니다.\n\n## 2. 한 번 작성하면 어디서나 실행하기 (WORA)\n\n이것은 Java 언어의 크로스 플랫폼 이점을 가리키는 우리가 자주 사용하는 슬로건입니다. 여기서 원한 말고 말하자면, 요즘 Java를 배우는 대부분의 개발자들은 이 기능이 소프트웨어 개발에 어떤 혁신적 영향을 미쳤는지 모를 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJava가 탄생하기 10년 전, C++가 주를 이루던 프로그래밍 언어였습니다. 그러나 개발자들이 직면한 문제 중 하나는 C++의 플랫폼 의존적인 성격이었습니다. C++로 작성된 코드는 다른 운영 체제나 하드웨어 아키텍처에서 실행되려면 재컴파일 및 종종 수정이 필요했습니다.\n\n![image](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_1.png)\n\n### 3. 하위 호환성\n\n만약 새로운 Java 버전이 나올 때마다 프로그램을 위한 코드를 다시 작성해야 한다면 어떨까요? 특히 대규모 기관들에게는 매우 비용이 많이 들고 시간이 많이 소요될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바는 오랜 시간동안 사용되어 왔기 때문에 예전 버전의 자바를 기반으로 한 소프트웨어 제품이 많이 존재하며, 다양한 분야에서 중요한 기능을 제공하며 기업의 주요 기반을 형성하고 있습니다.\n\n대규모이고 복잡한 프로젝트가 진행되는 기업 개발에서는 이러한 시스템을 최신 자바 버전으로 이관하는 작업은 신중한 계획과 실행이 필요합니다.\n\n자바의 하위 호환성은 개발자나 조직이 시스템 개발에 많은 투자를 한 상태라도 시스템이 계속 운영되며 완전한 재작성을 필요로하지 않고 유지 관리할 수 있음을 보장해줍니다. 자바(JVM)의 하위 호환성은 또한 마이그레이션 프로세스를 간소화시키며, 기존 시스템의 안정성을 저해하지 않으면서 새로운 기능과 개선 사항을 도입하는 것을 용이하게 합니다.\n\n# 4. 자바 강한 타입 시스템\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바는 파이썬과 같이 느슨하게 유형이 지정된 언어와는 달리 강력하게 유형이 지정된 언어입니다. 파이썬과 함께 일해본 적이 있다면, 서로 다른 유형의 값을 동일한 변수에 할당할 수 있는 유연성을 즉시 느낄 수 있으며, 언어가 동적으로 적응된다는 것을 느끼게 될 것입니다.\n\nint age = 25;\n\nString name = “John”;\n\n하지만 이러한 유연성은 대가가 따릅니다. 제가 기억하는 한, 다양한 숫자 데이터 유형을 사용하는 복잡한 계산을 다루는 금융 응용 프로그램에서 작업했었습니다. 자바의 강력한 유형 지정으로 인해, 컴파일러는 호환되지 않는 데이터 유형을 혼합하거나 데이터 손실이나 예기치 않은 결과로 이어질 수 있는 작업을 수행하려는 모든 시도에 경고를 표시했습니다. 이러한 명백한 버그 중 일부는 파이썬과 같은 언어로 작업할 때 런타임까지 눈에 띄지 않았을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 왜 Java가 기업 애플리케이션을 개발하는 데 흥미로운 이유 중 하나인데요, 특히 은행 및 금융과 같은 산업에서 신뢰성과 보안이 중요한 분야입니다. Java의 강력한 타입 시스템은 런타임 오류를 줄이는 데 도움이 될 뿐만 아니라 변수, 매개변수 및 반환 값의 의도된 데이터 유형을 이해하기 쉽게 해서 코드의 가독성을 향상시킵니다.\n\n## 5. RELEASE CYCLE — 지속적인 개선\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_2.png)\n\n일반적으로 Java 개발자로서, 몇 년마다 주요 릴리스에 이어 새로운 Java 기능을 얻는 데 익숙했습니다. 그러나 현대 프로그래밍 요구 사항에 따라 Java의 릴리스 주기가 Java 9 릴리스 후 6개월로 바뀌었습니다. 그러나 새 버전으로 넘어가지 않아도 되는 기업 기관을 위해, Oracle은 3년마다 LTS(Long-Term Support) 버전을 릴리스할 것을 제안했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 자주 발생하는 작은 릴리스는 새로운 자바 버전으로 업그레이드할 때 발생하는 복잡성과 위험을 줄입니다. 점진적인 변경 사항은 역호환성을 더 고려하여 설계되어 있기 때문에 개발자들이 주요 호환성 문제에 직면할 가능성이 적어집니다.\n\n# 6. 최고의 IDE\n\nJava는 다양한 변경과 기능으로 현대적인 개발에 탁월하게 맞는 언어로 발전해 왔습니다. 그러나 IntelliJ IDEA, Eclipse, NetBeans와 같은 강력한 통합 개발 환경(IDE)의 지원을 받지 않는다면 이는 유용하지 않을 수도 있습니다.\n\n지능적인 코드 완성, 자동 리팩터링, 원활한 버전 관리 통합 등과 같은 기능이 없는 환경에서 코드를 작성하는 것은 상상하기 어렵습니다. 그러나 특히 초기의 자바 시대에는 항상 그랬다고 당당히 주장하는 것도 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최신 IDE인 IntelliJ와 Eclipse로 빠르게 이동하면, 이들은 Java 개발을 간편하게 만들어 주었습니다. 이 IDE들은 Maven 및 Gradle과 완벽하게 통합되어 컴파일, 의존성 해결 및 프로젝트 관리를 처리합니다. 지능적인 코드 완성 기능과 내장 정적 코드 분석 도구를 통해 Java가 덜 장황하게 느껴지며, 플러그인을 통한 액세스로 환경을 원하는 대로 사용자 정의할 수 있습니다.\n\n# 7. GRAALVM 네이티브 이미지 지원\n\n이미 JVM이 Java를 영광으로 이끌어 주었던 원츄r 개론 자 애플리케이션에서 실행 시간이 지연되므로 애플리케이션이 JVM 상에서 실행되는 것보다 빠르게 시작하는 것입니다. 젠하는 것입니다. 이 이있는데, 나와 같은 개 개발자는 대부분 마이크로서비스, 서버리스 컴퓨팅 및 빠른 시작 및 최적화된 리소스 사용이 중요한 환경으로 이동하고 있으므로, 특히 이제는 프로그램 정보와 시작 시간을 빠르게 시작하기 위해 노력을 기울이고 있습니다. 사용하기 위한 해법 중 하나로 Oracle GraalVM의 고성능 JDK이며, Graal 컴파일러라는 대체 JIT(Just-in-Time) 컴파일러를 사용하여 Java 및 JVM 기반 애플리케이션의 성능을 농도로vey합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGraalVM에는 Java 바이트코드를 미리 컴파일하는 네이티브 이미지 유틸리티가 포함되어 있어서 애플리케이션이 거의 즉시 시작될 수 있습니다. Graal 컴파일러는 AOT 컴파일러로도 작동하여 네이티브 실행 파일을 생성합니다. 입력은 Java 바이트코드이고 출력은 네이티브 실행 파일입니다.\n\n여기 재귀를 사용하여 문자열을 뒤집는 작은 Java 프로그램 예제가 있습니다.\n\n```js\npublic class Example {\n    public static void main(String[] args) {\n        String str = \"Native Image is awesome\";\n        String reversed = reverseString(str);\n        System.out.println(\"The reversed string is: \" + reversed);\n    }\n    public static String reverseString(String str) {\n        if (str.isEmpty())\n            return str;\n        return reverseString(str.substring(1)) + str.charAt(0);\n    }\n}\n```\n\n이 Java 클래스에서 컴파일하고 네이티브 이미지를 빌드할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\njavac Example.java\nnative-image Example\n```\n\n네이티브 이미지 빌더는 Example 클래스를 사전 컴파일하여 현재 작업 디렉토리에 독립 실행 파일인 \"example\"로 생성합니다. 그런 다음 해당 실행 파일을 실행할 수 있습니다.\n\n```js\n./example\n```\n\n# 8. 오픈 소스 라이브러리 및 프레임워크.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오픈 소스 라이브러리와 프레임워크는 Java가 내 도구상에서 특별한 자리를 차지하는 주요 이유 중 하나입니다.\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_3.png)\n\n이러한 라이브러리와 프레임워크는 내 프로젝트에 원활하게 통합할 수 있는 구성 요소와 같습니다. 개발자로서 일반적인 기능을 새롭게 만들 필요 없이 바퀴를 다시 발명할 필요가 없습니다. 마치 잘 작성되고 테스트된 코드 저장소를 편하게 사용할 수 있는 것과 같습니다.\n\n이러한 라이브러리의 양이 많아서 한 가지 솔루션에 갇히지 않습니다. 내 요구에 가장 적합한 것을 항상 선택할 수 있습니다. 이러한 라이브러리의 오픈 속성은 투명성과 책임성을 장려합니다. 또한 소스 코드를 살펴볼 수 있고 내부 작동 방식을 이해할 수 있으며 개선 작업에 기여할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJava에서는 Jackson 및 Gson과 같은 JSON 파싱 라이브러리, Log4j, SLF4j 및 LogBack와 같은 로깅 라이브러리, JUnit, Mockito 및 PowerMock를 포함한 유닛 테스트 라이브러리, 데이터베이스 연결 라이브러리, 메시징 라이브러리 등이 포함된 오픈 소스 라이브러리 목록이 있습니다.\n\n또한 Java는 다양한 프레임워크의 확장성이 있어서 널리 알려진 프로그래밍 언어입니다. Spring과 Springboot는 제가 좋아하는 조합 중 하나입니다. 또 다른 제가 작업한 프레임워크로는 Jakarta Faces, Struts, Hibernate 및 Quarkus 등이 있습니다.\n\n# 9. 멀티스레딩\n\nJava는 멀티스레딩을 지원하여 데이터 처리, 사용자 상호작용 처리, 백그라운드 계산 관리 등을 동시에 처리할 수 있는 애플리케이션을 설계할 수 있습니다. Java는 Runnable 인터페이스를 구현하거나 Thread Class를 확장함으로써 멀티스레딩을 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바의 java.util.concurrent 패키지는 ExecutorService, ScheduledExecutorService, Future, CyclicBarrier 등을 포함한 고수준 동시성 유틸리티를 제공하여 동시성 응용 프로그램을 개발하는 데 도움을 줍니다.\n\n```java\npublic class MyRunnable implements Runnable {\n   public void run() {\n       // 새로운 스레드에서 실행될 코드\n   }\n}\nMyRunnable myRunnable = new MyRunnable();\nThread myThread = new Thread(myRunnable);\nmyThread.start();\n```\n\n# 10. 자바의 객체지향적 특성\n\n여러분이 생각하는 것을 알고 있어요: 자바는 유일한 객체지향 언어가 아니기 때문에, Python이나 C와 같은 언어와 무엇이 다른 점을 만드는 걸까요? 실제로 어떤 프로그래밍 언어들은 객체지향의 요소를 채택하거나 객체지향 개념을 지원하는 기능을 도입한 반면, 자바는 객체지향 원칙을 처음부터 고려하여 설계되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바는 추상화, 상속, 다형성, 캡슐화와 같은 객체 지향 원칙을 준수하여 복잡하고 확장 가능하며 유지보수가 용이한 소프트웨어 시스템을 구축하는 데 좋은 선택지입니다. 자바가 OOP 패러다임을 지원하는 데서 얻을 수 있는 많은 혜택이 있습니다. 이러한 혜택으로는 모듈화, 유연성, 가독성, 유지보수 용이성 및 확장 가능성이 포함됩니다.\n\n# 11. 메모리 관리와 가비지 컬렉션\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_4.png)\n\n출처: Digital Ocean\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n솔직히 말해서, 쓰레기를 버리는 걸 싫어해요. 그 일은 항상 귀찮게 느껴지는 가사일 중 하나에요. 많은 분들이 공감하실 거예요. 수동 메모리 관리에서는 개발자가 메모리를 할당하고 해제해야 하는 책임이 있어요. 마치 쓰레기를 버릴 때와 같이 언제 어떻게 각 조각을 처분할지를 결정하는 것과 비슷해요. 쓰레기를 버리는 것을 잊어버리면 혼란스러운 상황이 생기듯, 메모리를 해제하는 것을 잊어버리면 메모리 누수와 성능 문제가 발생할 수 있어요.\n\n자바의 자동 메모리 관리를 생각해보세요. 신뢰할 수 있는 쓰레기 수거 서비스가 있는 것과 같아요. 자바에서는 쓰레기 수거자가 성실하게 메모리를 식별하고 폐기하는 역할을 합니다.\n\n저는 자바로 전향하기 전 C++을 사용한 경험이 있어요. C++는 메모리 관리에 대한 막연한 통제를 제공하지만 메모리 누수가 없는지 확인하기 위한 개발자로서의 책임도 크지요.\n\n반면 자바에서는 저수준 시스템 기술적인 세부사항이나 수동 쓰레기 수거, 기본 OS 또는 메모리 할당 및 해제 추적에 대해 걱정할 필요가 없어요. 쓰레기 수거자가 더 이상 필요하지 않은 메모리를 자동으로 식별하고 회수합니다. 이로 인해 메모리 누출의 위험을 줄일 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n표준 프로파일러.\n\nVisualVM.\n\nVisualVM은 Java 애플리케이션의 내부 작동을 이해하는 데 필수적인 도구입니다. JConsole 및 VisualGC를 통합하여 쓰레드, 힙 사용량 및 CPU 프로파일링을 모니터링할 수 있는 시각적인 플레이그라운드를 제공합니다. 또한 다양한 JDK 유틸리티와 원활하게 작동하여 신뢰할 수 있는 도구로 유용합니다.\n\nYourKit.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로파일러는 내 도구 상자에 비밀 요원이 있는 것 같아요. 이것은 메소드 수준의 세부 정보를 깊이 파고들어 실행 시간과 메모리 할당을 드러냅니다. 이것은 클라우드, 컨테이너 및 클러스터 환경에서 프로파일링하는 간단하고 쉽고 안전한 방법을 제공합니다.\n\nAPM 도구.\n\n뉴 렐릭.\n\n뉴 렐릭은 어플리케이션 성능 모니터링 (APM)에 가장 좋은 선택지예요. 내 애플리케이션을 24시간 내내 감시하는 개인적인 비서가 있는 느낌입니다. 실시간 통찰력부터 자세한 트랜잭션 추적까지. 경고 기능은 예기치 않은 동작에 대해 알림을 받도록 하는 안전망이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 표로 변경해주세요.\n\nAppDynamics.\n\nAppDynamics, 나의 성능 아티스트! 데이터베이스 및 서버부터 클라우드 네이티브 및 하이브리드 환경까지 전체 기술 스택을 모니터링, 관찰 및 시각화하는 전체적인 방법을 취합니다. 성능이 최종 사용자에 미치는 영향을 이해하는 데 도움을 주어 감사합니다. 이로써 이는 모니터링 도구뿐만 아니라 사용자 만족 도구가 됩니다.\n\nLogging Solutions.\n\nLog4j.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 로깅 프레임워크의 노인 같은 존재입니다. 믿고 의존할 수 있게 이벤트와 오류를 충실하게 기록해 왔습니다. 애펜더와 필터를 구성하는 유연성 덕분에 로깅 필요에 신뢰할 수 있는 일말의 일력으로 떠드는 중입니다.\n\nSLF4J.\n\nSLF4J는 바로 내 로깅 스위스 아미 나이프 같은 존재입니다. 직접 로그를 남기지 않고 퍼사드 역할을 하며, 서로 다른 로깅 구현체들을 편리하게 연결할 수 있게 해줍니다. 이 유연성 덕분에 라이브러리의 로깅 기본 사양을 준수하는 다양한 작업 시 슬기로운 선택지가 됩니다.\n\nJava에서의 관측 가능성.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다이그마: Continuous Feedback (FC).\n\n코드가 실제 세계에서 어떻게 실행되는지 보지 못하면, 설계 결정을 내릴 수 없고 변경 사항의 영향을 평가할 수 없습니다. 관측 가능성과 코드 사이의 루프를 닫음으로써, 다이그마는 새로운 개발 방법을 열어줍니다.\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_5.png)\n\n다이그마는 Continuous Feedback(CF) 도구로, OTEL 관측 가능성 소스에서 코드에 대한 데이터를 수집하고 처리하는 작업을 간소화하도록 설계되었습니다. 다이그마는 IDE 플러그인으로 로컬에서 실행되며, 코딩하는 동안 추적부터 로그 및 지표까지 코드에 대한 데이터를 수집합니다. 이는 실시간으로 문제를 발견하고 통찰력을 얻을 수 있음을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로메테우스와 그라파나.\n\n프로메테우스와 그라파나, 나의 다이내믹 듀오! 프로메테우스는 나의 애플리케이션에서 메트릭을 수집하고, 그라파나는 이러한 메트릭을 아름답고 사용자 정의 가능한 대시보드로 변환해줍니다. 이 도구들 주변의 활발한 커뮤니티와 오픈 소스 성격 때문에 이 둘은 나의 다이내믹한 관측성 듀오입니다.\n\nElastic Stack (ELK).\n\n인공 지능과 검색 기술을 기반으로 한 오픈형, 확장 가능한 풀 스택 관측성입니다. 일라스틱서치, 로그스태시, 키바나는 함께 로그를 검색, 분석 및 시각화하기 위한 강력한 도구를 구성합니다. 로그, 메트릭 및 추적을 상호 연관시킬 수 있는 능력은 나에게 완전한 조사 툴킷을 제공해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 13. 함수형 프로그래밍 지원\n\n자바는 자바 8부터 지원하는 또 다른 프로그래밍 패러다임인 함수형 프로그래밍을 제공합니다. 함수형 프로그래밍에서는 함수를 일급 시민으로 취급하여 변수에 할당하거나 인수로 전달하고 반환할 수 있습니다.\n\n이 패러다임의 일부 기능으로 자바는 매력적인 프로그래밍 언어가 되었습니다. 자바의 함수형 프로그래밍 기능을 받아들이면서 개발자로서 제 삶에 큰 영향을 주었습니다. 람다 표현식과 함수형 인터페이스의 도입으로 코드를 더 간결하고 표현력 있게 작성할 수 있었습니다. 멀티코어 프로세서에서 병렬 처리를 활용할 수 있는 Stream API 덕분에 제 애플리케이션의 성능을 향상시킬 수 있었습니다.\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\npublic class Main {\n    public static void main(String[] args) {\n        List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(1, 2, 3, 4, 5));\n        \n        int sum = list.stream().reduce(0, (a, b) -\u003e a + b);\n        System.out.println(sum);\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n델리클러티브 스타일을 채택하면 함수형 프로그래밍에서 권장하는 대로 코드가 더 읽기 쉽고 이해하기 쉬워집니다. 불변성을 강조하고 부작용을 피하는 것이 실제로 영향을 미쳤으며, 코드를 더 예측 가능하고 유지보수 가능하게 만들었습니다. 그리고 테스트에 있어서 순수 함수의 보편성은 테스트하기 쉬워졌다는 것을 알았어요.\n\n## 14. 자바의 풍부한 문서화\n\n팀 프로젝트에 참여할 기회가 있다면 문서화의 중요성을 분명히 이해하게 될 것입니다. 저는 개인적으로 문서화를 코드가 무엇을 하는지, 어떻게 하는지, 그리고 왜 그렇게 하는지 설명해주는 사용자 매뉴얼로 간주합니다. 그리고 자바를 배우는 초보자라면, 그것은 마치 옆에서 멘토가 함께하는 것과 같습니다.\n\n문서에는 다양한 코드 샘플, 튜토리얼, 개발자 가이드, API 문서 등이 포함되어 있어서 프로토타입을 빠르게 개발하고 실제 응용 프로그램으로 스케일을 확장할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문서는 최신 상태가 아니면 별로 도움이 되지 않습니다. Java의 문서는 생태계의 새로운 개발 내용을 개발자와 전문가들이 반영하기 위해 정기적으로 최신 상태로 유지되며 개정됩니다. 또한 문서는 특정 클래스, 메소드 또는 개념에 대한 정보를 쉽게 찾을 수 있도록 구조화되어 있습니다.\n\n# 15. 빌드 도구 및 의존성 관리\n\n평균적인 Java/Spring 부트 프로젝트는 직접 및 간접 의존성이 수십 개에서 수백 개가 될 수 있습니다. 특히 대규모 기업 프로젝트를 처리할 때 버전 호환성과 같은 문제로 인해 이러한 의존성을 수동으로 관리하는 것은 머리아플 수 있습니다. 빌드 도구를 활용하면 여러 개발자가 로컬에서 빌드를 실행하는 상황에서 이산된 빌드를 통합할 수 있습니다.\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 Maven 및 Gradle과 같은 빌드 도구는 빌드, 테스트 및 종속성 관리를 간소화하여 개발자로서 일을 더 쉽게 만듭니다. 이러한 도구들은 시작부터 여러분이 다양한 종속성에 대한 업데이트와 보안 패치에 대해 알아야 하는 불편함을 덜어줍니다. 저장소에서 종속성을 가져와 자동으로 업데이트를 확인하므로 직접 업데이트 정보를 찾아가지 않아도 됩니다.\n\n빌드 도구는 또한 프로젝트 구조 및 구성에 대한 관례와 표준을 강제하므로 다른 Java 개발자 팀과 함께 작업하기 쉽고 이해하기 쉽습니다.\n\n# 16. 견고한 테스트 기능\n\n우리 개발자들이 버그를 해결하고 QA 엔지니어와 협업하는 것을 꺼리지만, 포괄적인 테스트는 응용 프로그램이 가능한 한 버그가 없도록 보장하는 가장 효과적인 방법 중 하나라고 인정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n견고한 테스트 기능을 갖춘 언어를 선택하면 부담이 줄어들고 더 신뢰할 수 있고 유지보수가 쉬운 코드베이스를 구축하는 데 도움이 됩니다. 그것이 왜 나는 Java를 버그가 없는 소프트웨어를 만들기 위한 기본 프로그래밍 언어로 지지하는 이유 중 하나입니다.\n\n단위 테스트, 통합 테스트, 또는 종단간 테스팅이든 Java는 포괄적인 테스트를 작성하기 위한 도구 세트를 제공합니다. JUnit은 Java의 단위 테스트의 표준입니다. 테스트를 작성하고 실행하기 위한 간단하고 우아한 방법을 제공합니다. JUnit은 @Test, @Before, @After, @BeforeClass, @AfterClass와 같은 어노테이션을 사용하여 테스트 메서드의 라이프사이클을 정의합니다. 이를 통해 테스트를 실행하기 전에 사전 조건을 설정할 수 있습니다.\n\n개발자들이 버그를 해결하고 QA 엔지니어들과 협업하는 것을 꺼리지만, 아플리케이션이 가능한 한 버그가 없는 것을 보장하는 가장 효과적인 방법 중 하나가 포괄적인 테스트임을 인정합니다.\n\n견고한 테스트 기능을 갖춘 언어를 선택하면 부담이 줄어들고 더 신뢰할 수 있고 유지보수가 쉬운 코드베이스를 구축하는 데 도움이 됩니다. 그것이 왜 나는 Java를 버그가 없는 소프트웨어를 만들기 위한 기본 프로그래밍 언어로 지지하는 이유 중 하나입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단위 테스트, 통합 테스트 또는 엔드투엔드 테스트든, Java는 포괄적인 테스트를 작성할 수 있는 풍부한 도구 세트를 제공해요. JUnit은 Java에서 단위 테스트의 표준이며 간단하고 우아한 방식으로 테스트를 작성하고 실행할 수 있어요. JUnit은 @Test, @Before, @After, @BeforeClass, @AfterClass와 같은 주석을 사용하여 테스트 메서드의 라이프사이클을 정의합니다. 이를 통해 테스트 실행 전 사전 조건을 설정할 수 있어요.\n\n```java\n// EmployeeServiceTest.java\nimport org.junit.jupiter.api.Test;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n@SpringBootTest\npublic class EmployeeServiceTest {\n    @Mock\n    private EmployeeRepository employeeRepository;\n    @InjectMocks\n    private EmployeeService employeeService;\n    @Test\n    public void testGetAllEmployees() {\n        // Mocking repository response\n        when(employeeRepository.findAll()).thenReturn(new ArrayList\u003c\u003e());\n        // Test case for getAllEmployees method\n        List\u003cEmployee\u003e result = employeeService.getAllEmployees();\n        // Assertion\n        assertEquals(0, result.size());\n        // Verify that the repository method was called\n        verify(employeeRepository, times(1)).findAll();\n    }\n}\n```\n\nJUnit을 사용하여 테스트를 작성하는 것은 간단하고, Eclipse, IntelliJ IDEA, NetBeans와 같은 인기있는 Java IDE(통합 개발 환경)와 원활하게 통합됩니다.\n\nJava 생태계에서 테스트하는 데 유용한 다른 도구로는 통합 테스트용 TestNG, 행동 주도 개발에 대한 Cucumber, 기능 및 회귀 테스트 케이스를 자동화하는 Selenium이 있습니다. Mockito는 JUnit 및 TestNG와 함께 사용할 수 있는 강력한 mocking 프레임워크입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 17. 대규모 커뮤니티\n\n자바 커뮤니티는 나의 자바 개발자로서의 여정에서 중요한 역할을 해왔습니다. 자바 커뮤니티로부터 도움과 지침을 여러 차례 구했는데 그 횟수를 셀 수 없을 정도입니다. 버그에 막혔을 때, 새로운 라이브러리를 탐구할 때, 새로운 솔루션을 구현할 때 최고의 실천 방법을 찾을 때, 커뮤니티는 매우 가치 있는 정보의 근원임이 증명되었습니다.\n\n자바 커뮤니티는 가장 응답이 빠른 커뮤니티 중 하나이며 거의 즉각적으로 도움을 받을 수 있습니다. 예를 들어, 저는 수천 명의 자바 개발자로 이루어진 레딧의 r/java 커뮤니티의 일원입니다. Stack Overflow와 GitHub와 같은 다른 플랫폼의 커뮤니티 또한 초보자부터 베테랑 전문가까지 다양한 개발자들이 포함되어 있습니다. 이 다양성은 각종 도메인과 경험 수준을 다루는 다양한 전문성이 있음을 의미하여 강점으로 작용합니다.\n\n온라인 커뮤니티 외에도 여러 자바 이벤트, 컨퍼런스, 그리고 밋업을 통해 개발자들이 직접 만나 경험을 공유하고 서로 배우는 기회를 제공합니다. 이러한 모임들은 네트워킹과 협업을 촉진하여 자바 개발자 커뮤니티 감각에 기여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 18. 자바 어노테이션 지원\n\n자바 어노테이션은 매우 인기 있는 주제이지만 논란이 많습니다. 어노테이션은 자바 5에서 소개되었고, 우리 모두 흥분했습니다. 개인적으로도 이 열정을 나눴습니다. 어노테이션의 도입은 확장된 Hibernate 또는 Spring XML 구성 파일 시대에서 떠났음을 나타냈습니다. 대신, 어노테이션을 사용하여 우리는 필요한 곳에 정확하게 정보, 지시 또는 구성을 직접 내장할 수 있게 되었습니다.\n\n\nPredefined annotations\n@Deprecated\n@Override\n@SuppressWarnings\n@SafeVarargs\n@FunctionalInterface\n2. Meta-annotations\n@Retention\n@Documented\n@Target\n@Inherited\n@Repeatable\n3. Custom annotations\n우리만의 사용자 정의 어노테이션을 만들 수도 있습니다.\n\n\n자바 어노테이션은 확실히 외부 문서를 참조할 필요성을 줄이는 것으로 코드의 명확성과 표현력을 향상시켰습니다. 어노테이션은 반복적인 작업이나 구성을 캡슐화하여 일부 보일러플레이트 코드를 줄이는 데 도움이 될 수도 있습니다. 예를 들어, 어노테이션을 사용하여 의존성 주입, ORM 매핑, 트랜잭션 범위와 같은 측면을 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 개발자들은 주석이 편리하고 여러 이점이 있지만, 일부 주석에 대해 의심을 품고 있는 것 같아요.\n\n# 보안 기능\n\n우리가 작성하는 프로그램은 코드 라인뿐만 아니라, 개인 사용자 데이터, 금융 세부 정보 및 독점 비즈니스 정보와 같은 민감한 정보도 처리합니다. 사용자는 우리에게 그들의 정보를 보호하고 안전한 환경을 제공하기를 기대합니다. 소프트웨어 개발이나 혁신에 관여하는 비즈니스에 대해, 의지재산 침탈을 예방하기 위해 애플리케이션을 보호하는 것이 중요합니다. 소스 코드, 알고리즘 및 독점 정보를 보호하는 것은 경쟁 우위를 유지하는 데 중요합니다.\n\nJava는 안전한 애플리케이션을 개발하기 쉽게 하는 많은 기능을 가지고 있어요. 이러한 기능 중 일부에는 암호화, 공개 키 인프라, 안전한 통신, 인증 및 접근 제어가 포함됩니다. 암호화에서부터 스마트 카드 I/O 및 안전한 통신을 보장하는 인증 프로토콜에 이르기까지, Java 애플리케이션에 보안 조치를 원활하게 통합할 수 있는 다양한 API 및 도구에 접근할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 목록은 완전하지 않아요. 공식 Java 보안 가이드에서 더 많은 기능을 배울 수 있어요.\n\n# 20. RICH API SET\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_7.png)\n\nJava는 풍부한 응용 프로그램 프로그래밍 인터페이스(APIs) 세트로도 알려져 있어요. 이들은 여러 소프트웨어 구성요소, 라이브러리 및 서비스와 상호 작용하는 표준화된 방법을 제공해요. 이 API에는 준비된 기능을 제공하는 미리 컴파일된 클래스, 인터페이스 및 메소드들의 풍부한 컬렉션이 포함되어 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차를 처음부터 만들고 있다고 가정해보겠습니다. Java API를 사용하면 이미 제조업체로부터 입수한 부품들을 조립하는 것과 같은 느낌을 받게 됩니다. 즉, 부품을 직접 제조하는 대신 필요한 부품들을 조립하는 방식입니다. 이 경우, 필요에 딱 맞는 API를 선택할 수 있는 유연성이 있습니다. 이 API들은 표준화되어 있고 잘 문서화되어 있어 사용하기 쉽습니다.\n\nJava의 API가 가지고 있는 장점은 구성 요소 빌드의 복잡한 세부 사항들을 추상화하여 완전히 기능적인 자동차를 조립하는 데 집중할 수 있게 해준다는 점입니다. 이 API들을 사용하여 네트워킹, IO, 파일 처리, 데이터베이스 연결, 멀티스레딩 등 다양한 도메인에서 다양한 작업을 수행할 수 있습니다.\n\nJava API는 여러 패키지로 구성되어 있습니다. 가장 일반적인 것들 중 일부는 java.lang, java.util, java.io, java.net 등이 있습니다.\n\n# 21. JAVA의 성능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 이유는 Java를 오랜 기간 동안 사용하게 한 것은 Java의 성능이 지속적으로 향상되는 것을 목도하면서, 이것이 주 프로그래밍 언어로서의 선택을 유효하게 만들었습니다.\n\n성능 면에서의 이러한 개선은 문제를 해결하는 데 큰 도움을 주었으며, 현대 고객을 대상으로 하는 성능 우수한 응용 프로그램을 개발할 수 있는 기회를 제공했습니다. 몇 가지 주목할 만한 것도 있습니다.\n\n예를 들어, Java 가상 머신(JVM)은 각 새로운 릴리스마다 상당한 최적화가 이루어졌습니다. Just-in-time(JIT) 컴파일러의 개선, 가비지 수집 기능의 향상, 그리고 더 나은 런타임 프로파일링이 함께 빠른 실행과 낮은 메모리 소요를 기여했습니다.\n\nProject Valhalla는 값 타입을 도입하여 더 효율적이고 간결한 데이터 구조를 정의할 수 있게 했습니다. 이는 메모리 소모를 줄이고 캐시 지역성을 향상시키며, 특히 대량의 데이터가 있는 시나리오에서 상당한 성능 향상을 가져왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최근에 JDK 21에서 키 캡슐화 메커니즘 API, 가상 스레드, 및 문자열 템플릿 및 구조화된 동시성 미리보기와 같은 15개의 기능이 도입되었습니다. 이러한 변경 사항은 자바를 크게 향상시킵니다.\n\n# JDK 21에서 가상 스레드와 기타 기능으로 한 발  LEAP FORWARD\n\n# 22. 구조화된 동시성\n\n제안된 구조화된 동시성을 위한 API는 JDK 21의 주요 기능으로 유지되며 관련 작업 그룹을 다른 스레드에서 단일 작업 단위로 다루어 동시 프로그래밍을 간단하게 하는 것을 목표로 합니다. 이 접근 방식은 오류 처리, 취소, 신뢰성 및 관측성을 향상시킵니다. 이 기능은 java.util.concurrent의 기존 동시성 구조를 대체할 목적이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능을 통해 ExecutorService 및 Future와 같은 기존 구조를 활용하여 병행 프로그래밍에서 작업 및 하위 작업을 관리하는 복잡성을 제거할 수 있습니다. 작업과 하위 작업 간의 내재적인 관계 부재로 오류 처리, 취소 및 관찰에 어려움이 있습니다. 제안된 구조화된 동시성 접근 방식은 코드의 구문 구조를 작업의 실행 계층 구조와 일치시켜 주어 병행 프로그래밍을 더 가독성 있고 유지보수가능하며 신뢰할 수 있도록 합니다.\n\n# 23. 가상 스레드\n\n처음에는 JDK 19 및 JDK 20에서 미리보기 기능으로 소개되었지만 이제 JDK 21에서 공식적으로 도입된 가상 스레드입니다. java.lang.Thread의 각 인스턴스는 일반적으로 여타 플랫폼 스레드에 연결되어 수명 주기 동안 기본 OS 스레드에 바인딩됩니다.\n\n그러나 가상 스레드는 패러다임 변화를 가져왔습니다. 여전히 java.lang.Thread의 인스턴스가 존재하지만 이제 Java 코드를 백그라운드 OS 스레드에서 실행하여 해당 스레드를 독점하지 않는 방식으로 작동합니다. 이 혁신은 여러 가상 스레드가 효율적으로 단일 OS 스레드를 공유할 수 있도록 합니다. 플랫폼 스레드와는 달리 가상 스레드는 소중한 OS 스레드를 제한하지 않으며, 그 숫자는 OS 스레드의 제약을 크게 초월할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가상 스레드는 JDK 21의 매력적인 새로운 기능입니다. 이는 특히 동시 작업이 매우 많은 시나리오에서 애플리케이션 성능에 상당한 긍정적인 영향을 미칠 수 있습니다. 이러한 시나리오에서는 종종 수천 개 이상의 동시 작업이 발생합니다.\n\n이제 애플리케이션의 특정 요구 사항에 따라 가상 스레드와 전통적인 플랫폼 스레드 중에서 선택할 수 있는 유연성이 생겼습니다.\n\n# 24. SWITCH 문을 위한 패턴 매칭\n\n이 흥미로운 기능은 JDK 17 제안에서 시작되어 JDK 18, JDK 19 및 JDK 20에서 일련의 개선 작업을 거친 후, 이제 Java 커뮤니티의 피드백과 경험을 바탕으로 JDK 21의 일부로 정식으로 도입되어 추가로 발전했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기능의 주요 목적은 switch 표현식과 문장의 기능과 다양성을 확장하는 것입니다. 또한 경우 레이블에서 패턴이 더 중요한 역할을 하도록하여, null 값 처리에 대해 더 유연성을 제공하고, 패턴 switch 문을 사용하여 가능한 모든 입력 값에 대한 포괄적인 커버리지를 요구함으로써 switch 문을 더 안전하게 만드는 데 관한 것입니다.\n\n이미 switch 표현식과 문장을 사용하고 있다면 걱정하지 마세요. 목표는 어떠한 변경도 필요하지 않게 현재처럼 작동하도록 보장하는 것입니다.\n\n# 25. 문자열 템플릿\n\n문자열 템플릿이 Java에 도입되어, 개발자가 오래 전부터 바라왔던 문자열 보간을 지원하게 되었습니다. 지금까지 여러 문자열을 결합하거나 string.format을 사용해야 했는데, 솔직히 말해서 귀찮았습니다. 그러나 Java 21에서 우리는 즐거움을 느낄 것입니다. 이 새로운 기능은 개발자들에게 Java의 문자열 리터럴과 텍스트 블록을 문자열 템플릿으로 채울 수 있는 기능을 부여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nint x = 10;\nint y = 20;\nString s = STR.\"\\{x} + \\{y} = \\{x + y}\";\n\n\n\n주요 목표는 런타임에서 컴파일될 수 있는 값들을 표현하는 데 있어서 동적 문자열 생성을 간소화하는 것입니다. 또 다른 목표는 StringBuilder 및 StringBuffer 클래스와 관련된 장황함을 해결하여 가독성을 향상시키는 것입니다. 마지막으로, 문자열 템플릿은 다른 프로그래밍 언어의 존재하는 문자열 보간 기술과 관련된 보안 문제를 극복하는 데 도움이 될 것입니다.\n\n# 요약\n\n자바는 더 쉽지는 않지만 더 나은 것이죠! 또한, 현대적인 자바는 매우 빠릅니다. 읽기 쉽고 - 유지 보수가 쉬워요. 자바에서 똑똑해지려고 애쓰는 것은 어렵습니다 - 록스타 동료들과 싸우지 않아도 됩니다. 그리고 모두 솔직해지자면, 우리는 급여에 관심이 있죠. 자바 개발자들은 높은 급여를 받습니다. 대부분의 기업과 대규모 조직에서 주 언어로 자바를 사용하기 때문에 많은 일자리가 있습니다. 아직 자바 8을 사용하고 행복해하는 사람들도 알고 있어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n무료로 Digma를 설치하세요!\n\n# 자주 묻는 질문 (FAQ)\n\nJava가 인기 있는 프로그래밍 언어로 손꼽히는 이유는 무엇인가요?\n\nJava는 플랫폼 독립성, 견고함, 그리고 방대한 커뮤니티 지원으로 인해 인기를 얻었습니다. 웹 개발부터 기업 애플리케이션에 이르기까지 다양한 분야에서 널리 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대용량 엔터프라이즈 애플리케이션에 Java를 사용하는 이점은 무엇인가요?\n\nJava는 안정적이고 확장 가능한 환경을 제공하며, 멀티스레딩을 지원하며, Spring Boot와 같은 많은 라이브러리와 프레임워크로 엔터프라이즈 애플리케이션 개발을 단순화합니다.\n\nJava는 어떻게 크로스 플랫폼 개발을 지원하나요?\n\nJava는 \"한 번 작성하고, 모두에서 실행\" 원칙을 통해 크로스 플랫폼 호환성을 달성하며, Java 코드를 Java Virtual Machine (JVM)을 사용하는 모든 장치에서 실행할 수 있도록 합니다.","ogImage":{"url":"/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_0.png"},"coverImage":"/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_0.png","tag":["Tech"],"readingTime":23},{"title":"스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능","description":"","date":"2024-05-20 15:41","slug":"2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_0.png\" /\u003e\n\n안녕하세요! 이 글은 요청받은 기사입니다. 독자들이 Spring Boot와 가상 스레드를 비교하고 Gin, Fiber, Echo와 같은 인기 있는 Go 프레임워크를 최신 버전으로 비교해 달라고 요청했습니다. Spring Boot는 매우 포괄적이고 다양한 기능 세트를 갖춘 프레임워크인 반면에 언급된 Go 프레임워크들은 비교적 간단하며(Express와 유사한) 기능이 간단한 것에 유의해 주세요.\n\n이전 기사에서 우리는 가장 간단한 \"hello world\" 케이스에서 Spring Boot가 Go 프레임워크와 어떻게 맞붙는지 살펴보았습니다.\n\n이번 기사에서는 좀 더 실제적인 케이스에 초점을 맞출 것입니다: 데이터베이스 조회입니다. 간단한 사용 예는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- HTTP 요청 받기\n- 요청 본문(JSON)에서 userEmail 매개변수 추출하기\n- 추출된 이메일로 데이터베이스 조회 수행\n- HTTP 응답에서 사용자 레코드 반환\n\n# 테스트 설정\n\n모든 테스트는 MacBook Pro M2에서 16GB RAM 및 8+4 CPU 코어를 사용하여 실행되었습니다. 소프트웨어 버전은 다음과 같습니다:\n\n- SpringBoot 3.2.5 (Java 21.0.3)\n- Go 1.22.3\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n테스트는 Bombardier 로드 테스터를 사용하여 진행됩니다.\n\n모바일 앱에서는 Bun ORM을 사용하고 있습니다 (Bun JS 런타임과 혼동하지 마세요).\n\n애플리케이션 코드는 다음과 같습니다:\n\nSpringBoot\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기록을 표시해왔던 다음과 같은 과정을 반복하셨습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 차트 형식으로 결과가 제공됩니다:\n\n- ![이미지1](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_1.png)\n- ![이미지2](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_2.png)\n- ![이미지3](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_4.png)\n\n![Image 2](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_5.png)\n\n![Image 3](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_6.png)\n\n![Image 4](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_7.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_8.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_9.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_10.png\" /\u003e\n\n# 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, Spring Boot와 Go 프레임워크는 매우 다릅니다. Spring의 기능 세트는 간단한 Go 프레임워크에 비해 너무 방대합니다.\n\n데이터베이스 읽기와 같이 I/O 집중적인 경우에는 Go 프레임워크가 Spring Boot에 비해 2배 빠릅니다. Go 측에서 가장 빠른 것은 38K RPS를 제공하는 Fiber입니다.\n\nSpring Boot의 CPU 사용량은 모든 Go 프레임워크와 비교할 만큼 유사합니다. 그러나 Spring Boot의 메모리 사용량은 Go 프레임워크와 비교했을 때 너무 높습니다.\n\n승자: Fiber\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 비슷한 \"hello world\" 비교가 있습니다:","ogImage":{"url":"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_0.png"},"coverImage":"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_0.png","tag":["Tech"],"readingTime":3}],"page":"72","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"72"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>