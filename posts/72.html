<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/72" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/72" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover" href="/post/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="마스터링 디스패치 큐Dispatch Queues in Swift 이해, 구현, 그리고 제한들" href="/post/2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="마스터링 디스패치 큐Dispatch Queues in Swift 이해, 구현, 그리고 제한들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="마스터링 디스패치 큐Dispatch Queues in Swift 이해, 구현, 그리고 제한들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">마스터링 디스패치 큐Dispatch Queues in Swift 이해, 구현, 그리고 제한들</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="사용자 정의 Segmented Control  SwiftUI" href="/post/2024-05-23-CustomSegmentedControlSwiftUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="사용자 정의 Segmented Control  SwiftUI" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-CustomSegmentedControlSwiftUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="사용자 정의 Segmented Control  SwiftUI" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">사용자 정의 Segmented Control  SwiftUI</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기술 및 미디어 부문의 침체로 비윤리적인 기업들이 어떻게 이용하고 있는지 알아보기" href="/post/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기술 및 미디어 부문의 침체로 비윤리적인 기업들이 어떻게 이용하고 있는지 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기술 및 미디어 부문의 침체로 비윤리적인 기업들이 어떻게 이용하고 있는지 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">기술 및 미디어 부문의 침체로 비윤리적인 기업들이 어떻게 이용하고 있는지 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Salesforce 마케팅 클라우드에 WhatsApp 통합하기 단계별 가이드" href="/post/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Salesforce 마케팅 클라우드에 WhatsApp 통합하기 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Salesforce 마케팅 클라우드에 WhatsApp 통합하기 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Salesforce 마케팅 클라우드에 WhatsApp 통합하기 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로그래머를 위한 11가지 어첈없이 간단한 수동 소득 아이디어" href="/post/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로그래머를 위한 11가지 어첈없이 간단한 수동 소득 아이디어" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로그래머를 위한 11가지 어첈없이 간단한 수동 소득 아이디어" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">프로그래머를 위한 11가지 어첈없이 간단한 수동 소득 아이디어</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 개발자로 성장하기 위한 자료와 로드맵" href="/post/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 개발자로 성장하기 위한 자료와 로드맵" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 개발자로 성장하기 위한 자료와 로드맵" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 개발자로 성장하기 위한 자료와 로드맵</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년에 경력있는 Java 개발자를 위한 카프카 인터뷰 질문" href="/post/2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년에 경력있는 Java 개발자를 위한 카프카 인터뷰 질문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년에 경력있는 Java 개발자를 위한 카프카 인터뷰 질문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년에 경력있는 Java 개발자를 위한 카프카 인터뷰 질문</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">32<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드 개발 입문자를 위한 가이드 첫 앱 만들기 시작하기" href="/post/2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 개발 입문자를 위한 가이드 첫 앱 만들기 시작하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 개발 입문자를 위한 가이드 첫 앱 만들기 시작하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 개발 입문자를 위한 가이드 첫 앱 만들기 시작하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안녕하세요 오늘은 안드로이드에서 ExoPlayer를 사용하여 Jetpack Compose로 비디오를 표시하는 방법에 대해 알아보겠습니다" href="/post/2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안녕하세요 오늘은 안드로이드에서 ExoPlayer를 사용하여 Jetpack Compose로 비디오를 표시하는 방법에 대해 알아보겠습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안녕하세요 오늘은 안드로이드에서 ExoPlayer를 사용하여 Jetpack Compose로 비디오를 표시하는 방법에 대해 알아보겠습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안녕하세요 오늘은 안드로이드에서 ExoPlayer를 사용하여 Jetpack Compose로 비디오를 표시하는 방법에 대해 알아보겠습니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link posts_-active__YVJEi" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover","description":"","date":"2024-05-23 13:10","slug":"2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover","content":"\n![이미지](/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png)\n\n이 글은 이전 글들을 이어서 작성되었으며, 그 위에 쌓아 올릴 것입니다.\nSwiftUI 네비게이션 파트 1 — 푸시 네비게이션\nSwiftUI 네비게이션 파트 2 — 알림\n\n이 글에서는 Sheets 및 FullscreenCovers을 동시에 다룰 것이며, 이들은 동일한 방식으로 구현됩니다.\n\n시작해 봅시다! 이전 글들에서는 결정적 목적지로 조정하기 위해 Routes를 사용했습니다. 그러나 SwiftUI는 어떻게 이루어지는 걸까요?\n뷰 계층 구조의 루트에 있는 NavigationStack에 대한 네비게이션 경로에 대한 바인딩이 있습니다. Apple의 문서 예제를 살펴보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nNavigationStack(path: $presentedParks) {\n    List(parks) { park in\n        NavigationLink(park.name, value: park)\n    }\n    .navigationDestination(for: Park.self) { park in\n        ParkDetails(park: park)\n    }\n}\n```\n\n우리는 NavigationStack 라는 뷰가 있습니다. 이 뷰를 통해 일부 데이터 유형의 바인딩을 통해 .navigationDestination이라는 뷰 수정자에서 제공된 뷰로 이동할 수 있습니다 🤔 어떻게 보면 흥미로운 것 같네요.\n\n그럼 이 뷰 수정자가 무엇인지 궁금하죠? 프레임워크 문서에서 더 자세히 살펴봐 봅시다.\n\n```js\n/// 스택에 한 개 이상의 네비게이션 대상 수정자를 추가할 수 있습니다.\n/// 여러 데이터 유형을 표시해야 하는 경우 스택에 네비게이션 대상 수정자를 여러 개 추가할 수 있습니다.\n///\n/// \"List\" 또는 \"LazyVStack\"과 같은 \"lazy\" 컨테이너 내부에 네비게이션 대상 수정자를 넣지 마세요.\n/// 이러한 컨테이너는 화면에 렌더링할 때 필요한 경우에만 자식 뷰를 생성합니다.\n/// 항상 네비게이션 대상 수정자를 이러한 컨테이너 외부에 추가하여 네비게이션 스택이 대상을 항상 볼 수 있도록 하세요.\n///\n/// - Parameters:\n///   - data: 이 대상이 일치하는 데이터의 유형입니다.\n///   - destination: 스택의 네비게이션 상태에 유형 'data'의 값을 포함하고 있을 때 표시할 뷰를 정의하는 뷰 빌더입니다.\n///     클로저는 데이터 값을 나타내는 하나의 인수를 사용합니다.\npublic func navigationDestination\u003cD, C\u003e(for data: D.Type, @ViewBuilder destination: @escaping (D) -\u003e C) -\u003e some View where D : Hashable, C : View\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뭐 이건 Data.Type을 받아들이는 ViewModifier인데, 그런 다음에 destination이라고 불리는 클로저가 주입되는데, 이 클로저는 hashable해야 할 that Data.Type의 인스턴스를 주입하고 구체적인 View를 반환해야 해요...... 그렇죠. 😵\n\n또 다른 것은 .navigationDestination(\\_:)이 NavigationStack 내부의 View에 적용되어야 하며, NavigationStack의 범위 외부에 적용할 수 없다는 것을 주의해야 해요. 🤔\n\n뷰 계층 구조를 통해 데이터를 상위 뷰로 전파하는 유사한 시그니처를 가진 다른 것이 있어요. 이것이 바로 데이터를 뷰의 부모에게 전달하는 데 사용되는 PreferenceKeys입니다!\n\nPreferenceKeys를 사용하여 .navigationDestination(\\_:)이 NavigationStack에 하는 것처럼 내비게이션 목적지를 전달할 수 있을까요?\n우리는 곧 알게 될 거예요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시트 및 풀스크린 커버의 ViewModifier를 검사해 봅시다.\n\n```js\n    public func sheet\u003cItem, Content\u003e(item: Binding\u003cItem?\u003e, onDismiss: (() -\u003e Void)? = nil, @ViewBuilder content: @escaping (Item) -\u003e Content) -\u003e some View where Item : Identifiable, Content : View\n\n    public func fullScreenCover\u003cItem, Content\u003e(item: Binding\u003cItem?\u003e, onDismiss: (() -\u003e Void)? = nil, @ViewBuilder content: @escaping (Item) -\u003e Content) -\u003e some View where Item : Identifiable, Content : View\n```\n\n이들은 서로 거의 동일하며 navigationDestination(\\_:)과도 매우 유사합니다. 주요 차이점은 나타낼 아이템에 대한 바인딩이 Hashable 대신 Identifiable을 준수해야 하며 전달할 수 있는 선택적인 onDismiss 클로저가 있는 것입니다.\n\nRoutes도 Identifiable을 준수하도록 만들어 보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable { // \u003c-- Identifiable\n    var id: String { String(describing: self) }\n\n    case detailView\n    case secondDetailView(String)\n}\n```\n\n이제 루트를 처리하는 ViewModifier를 만들어야 합니다. navigationDestination(_:)가 어떻게 작동하는지 더 잘 이해하려고 했고, navigationDestination(_:)와 동일하게 목적지를 뷰 계층 구조로 전달할 수 있는 방법을 재현해 볼 수 있을지 생각했습니다.\n\n내가 알기로는 뷰 계층 구조로 데이터를 전송하는 유일한 방법은 PreferenceKeys이니까 그것부터 시작하겠습니다.\n그러나 몇 가지 기준이 있습니다. 어떤 경로에 대해서도 작동하고 다른 경로에 대한 모든 목적지를 해결할 수 있어야합니다. 이 기준으로 인해 타입 지워를 사용해야 합니다. 다음과 같이 PreferenceKeys를 생성해 봅시다.\n\n```js\nstruct SheetFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -\u003e [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } } // reduce all into one value (dictionary)\n}\n\nstruct CoverFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -\u003e [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } }\n}\n\nextension View {\n    public func sheetDestination\u003cD,C\u003e(for data: D.Type, @ViewBuilder sheet: @escaping (D) -\u003e C) -\u003e some View where D: Identifiable \u0026 Hashable, C : View  {\n        preference(key: SheetFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, sheet)]) // \u003c- Here we set the key to the data type's description! and pass our view factory\n    }\n\n    public func coverDestination\u003cD,C\u003e(for data: D.Type, @ViewBuilder cover: @escaping (D) -\u003e C) -\u003e some View where D: Identifiable \u0026 Hashable, C : View  {\n        preference(key: CoverFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, cover)])\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네비게이션 목적지()가 sheetDestination()와 coverDestination() 선호 키 모두 호출자의 모든 값을 하나의 [String: NavigationViewFactory] 사전으로 줄입니다.\n\n기본적으로 여러 Coordinator가 있는 경우 각각이 자체 경로 유형을 위해 sheetDestination() 선호 키를 사용합니다. 이것은 PreferenceKeys에서 보내진 모든 값들을 하나의 사전으로 병합/줄이고, 문자열 키를 사용하여 작업하는 데이터 유형에 대한 식별자로 사용할 수 있습니다. 따라서 뷰 계층 구조를 통해 전달된 대응하는 예상 값에 접근할 수 있습니다. 이 값은 해당 목적지를 반환하는 데 도움이 됩니다.\n\n여기에는 데이터 유형을 설명하는 ID와 AnyView를 반환하는 타입 지워진 NavigationViewFactory가 있습니다.\nAnyView는 SwiftUI에서 제공되는 타입 지워진 뷰 래퍼로 성능에 부담이 있으므로 절약해서 사용해야 합니다. 그러나 한 번에 하나의 시트나 커버만 표시할 수 있기 때문에 수용할만한 것으로 보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNavigationController로 다시 가서 코드를 추가해 봅시다.\n\n```js\n@Observable final class NavigationController {\n    var navigationPath = NavigationPath()\n    var alertPath = AlertPath()\n    var sheetPath: SheetPath = .init() // \u003c- SheetPath를 생성해 봅시다\n    var coverPath: CoverPath = .init() // \u003c- CoverPath를 생성해 봅시다\n\n    func presentSheet\u003cT\u003e(_ route: T, onDismiss: (() -\u003e Void)? = nil)  where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        sheetPath.setSheet(route, onDismiss: onDismiss)\n    }\n\n    func presentCover\u003cT\u003e(_ route: T, onDismiss: (() -\u003e Void)? = nil)  where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        coverPath.setCover(route, onDismiss: onDismiss)\n    }\n}\n\n// Sheet\nstruct SheetPath: Identifiable {\n    var id: String { sheet?.id ?? UUID().uuidString } // \u003c- 현재 sheet의 id를 사용합니다.\n    var sheet: SheetContainer?\n\n    mutating func setSheet\u003cT\u003e(_ sheet: T, onDismiss: (() -\u003e Void)? = nil) where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        self.sheet = SheetContainer(sheet, onDismiss: onDismiss)\n    }\n}\n\nstruct SheetContainer: Identifiable {\n    let id: String\n    let sheet: Any\n    let onDismiss: (() -\u003e Void)?\n\n    init\u003cT\u003e(_ sheet: T, onDismiss: (() -\u003e Void)? = nil) where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        self.id = String(describing: T.self)\n        self.sheet = sheet\n        self.onDismiss = onDismiss\n    }\n}\n\n// Fullscreen Cover\nstruct CoverPath: Identifiable {\n    var id: String { cover?.id ?? UUID().uuidString }\n    var cover: CoverContainer?\n\n    mutating func setCover\u003cT\u003e(_ cover: T, onDismiss: (() -\u003e Void)? = nil) where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        self.cover = CoverContainer(cover, onDismiss: onDismiss)\n    }\n}\n\nstruct CoverContainer: Identifiable {\n    let id: String\n    let cover: Any\n    let onDismiss: (() -\u003e Void)?\n\n    init\u003cT\u003e(_ cover: T, onDismiss: (() -\u003e Void)? = nil) where T: Codable \u0026 Identifiable \u0026 Hashable  {\n        self.id = String(describing: T.self)\n        self.cover = cover\n        self.onDismiss = onDismiss\n    }\n}\n```\n\n이 두 가지 구현 사항은 기본적으로 동일하며 같은 컨테이너, 경로, 함수 뷰 수정자 등을 사용하고 열거형 PresentationMode를 추가하여 sheet와 cover를 구분할 수 있는 case를 추가할 수 있습니다. 그러나 일관성을 유지하기 위해 이 예제에서는 이들을 분리해 두었습니다. 또한 SwiftUI가 이후에 여러 개의 sheet/cover를 지원한다면 별도로 처리하고자 할 수도 있습니다. 선택은 당신에게 맡깁니다. 지금까지 어떤 것들을 얻었나요?\n\n- NavigationController에는 이제 sheet 및 fullScreenCover에 대한 경로가 있습니다.\n- 우리는 데이터 작업의 구체적인 유형을 지우기 위해 타입 이레이저를 사용하지만, 우리가 수용할 수 있는 유형으로만 컨테이너를 초기화할 수 있도록 하여, 지워진 타입 값은 일종의 Identifiable, Hashable 및 Codable 유형이 되도록 보장합니다.\n- 또한, 해당 데이터 유형의 설명을 Identifiable 준수를위한 식별자로 저장하여 우리의 뷰 팩토리 콜백 딕셔너리에서 구분할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여전히 함께 계신다니 너무 기쁘네요! 이제 모든 것을 함께 연결해보려 합니다.\n\n이제 시트를 표시하는 ViewModifier를 만들어야 합니다.\n\n```js\nextension View {\n    func sheet(for sheetPath: Binding\u003cSheetPath\u003e) -\u003e some View {\n        modifier(SheetModifier(sheetPath: sheetPath))\n    }\n\n    func cover(for data: Binding\u003cCoverPath\u003e, onDismiss: (() -\u003e Void)? = nil) -\u003e some View {\n        modifier(CoverModifier(data: data))\n    }\n}\n\nstruct SheetModifier: ViewModifier {\n    @Binding var sheetPath: SheetPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -\u003e Void)?\n\n    init(sheetPath: Binding\u003cSheetPath\u003e) {\n        self._sheetPath = sheetPath\n        self.onDismiss = sheetPath.wrappedValue.sheet?.onDismiss\n    }\n\n    func body(content: Content) -\u003e some View {\n        content\n            .onPreferenceChange(SheetFactoryKey.self) { factories = $0 }\n            .sheet(item: _sheetPath.sheet, onDismiss: sheetPath.sheet?.onDismiss, content: { factories[sheetPath.id]?.factory($0.sheet) })\n    }\n}\n\nstruct CoverModifier: ViewModifier {\n    @Binding var data: CoverPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -\u003e Void)?\n\n    init(data: Binding\u003cCoverPath\u003e) {\n        self._data = data\n        self.onDismiss = data.wrappedValue.cover?.onDismiss\n    }\n\n    func body(content: Content) -\u003e some View {\n        content\n            .onPreferenceChange(CoverFactoryKey.self) { factories = $0 }\n            .fullScreenCover(item: _data.cover, onDismiss: data.cover?.onDismiss, content: { factories[data.id]?.factory($0.cover) })\n    }\n}\n```\n\n이게 뭐하는 거야? 모든 .sheetDestination()를 사용하는 코디네이터는 경로에 해당하는 코디네이션 함수를 뷰 계층 구조에 전달합니다. 그리고 sheetPath에 값을 설정하면 동일한 데이터 유형에 대한 viewFactory를 추출하고 데이터 인스턴스를 주입하여 메서드를 호출하여 대상을 반환할 것입니다. 모두 어떻게 함께 작동하는지 예제를 살펴봅시다.\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable {\n    var id: String { String(describing: self) }\n    ... 이전 경로들\n\n    case sheet // 선택 사항으로 연결된 값 전달 가능\n    case cover\n}\n\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor var rootView: some View {\n        let viewModel = FirstViewModel(self)\n        FirstView(viewModel)\n            .navigationDestination(for: Route.self, destination: coordinate(_:))\n            .sheetDestination(for: Route.self, sheet: coordinate(_:))\n            .coverDestination(for: Route.self, cover: coordinate(_:))\n    }\n\n    func presentSheet(onDismiss: (() -\u003e Void)? = nil) {\n        navigationController.presentSheet(Route.sheet, onDismiss: onDismiss)\n    }\n\n    func presentCover(onDismiss: (() -\u003e Void)? = nil) {\n        navigationController.presentCover(Route.cover, onDismiss: onDismiss)\n    }\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -\u003e some View {\n        switch route {\n            ... 이전 경로들\n\n            case .sheet: SomeBranchedView()\n            case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와, 정말 깔끔하네요!\nrootView 계산 속성 내에서 PreferenceKeys를 설정하여 모든 정보가 코디네이터의 Route.Types를 해결하는 데 필요한 정보를 코디네이트(coordinates) 함수로 보냅니다. 이 함수는 특정 코디네이터가 좌표를 맡은 모든 뷰를 생성합니다. 🤔 꽤 괜찮죠.\n\n```js\nstruct CoordinatedView\u003cC: Coordinator\u003e: View {\n    private let coordinator: C\n\n    init(_ coordinator: C) {\n        self.coordinator = coordinator\n    }\n\n    var body: some View {\n        @Bindable var navigationController = coordinator.navigationController\n        NavigationStack(path: $navigationController.navigationPath) {\n            coordinator.rootView\n        }\n        .sheet(for: $navigationController.sheetPath)\n        .cover(for: $navigationController.coverPath)\n        .alert(for: $navigationController.alertPath)\n    }\n}\n```\n\n마지막으로 루트 CoordinatedView에 sheet 또는 cover를 적용하는 방법에 대해 다음과 같이 살펴보겠습니다. 이것도 꽤 깔끔하네요 😉\n\n그러니까 이 경우를 위해 우리의 view와 viewModel을 검사해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct FirstView: View {\n    let viewModel: FirstViewModel\n\n    var body: some View {\n        VStack {\n            Text(\"First View\")\n            Button(\"상세 화면으로 이동\") {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n@Observable class FirstViewModel {\n\n    private let coordinator: FirstTabCoordinator\n\n    init(coordinator: FirstTabCoordinator) {\n        self.coordinator = coordinator\n    }\n\n    func didTapButton() {\n        coordinator.presentSheet {\n          // closure called onDismiss\n        }\n    }\n}\n```\n\n우리의 뷰는 didTapButton 이외에 무슨 일이 벌어지고 있는지 알 수 없습니다.\n\nℹ️ 또한 다른 필요한 수식어(modifier)들이 coordinate() 함수에서 반환되기 전에 뷰에 적용될 수 있습니다.\n\n예를 들어, 시트에 presentationDetents를 적용하려면. 그리고 뷰 내부에서 심지어 그것에 대해 알 필요조차 없을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -\u003e some View {\n        switch route {\n         ... 이전 루트\n\n        case .sheet: SomeBranchedView().presentationDetents([.medium, .large]) // 시트를 반으로 크기 조정하고 드래그 액션 등을 허용합니다.\n        case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n지금은 여기까지입니다.\n\n이 글에서 어떤 통찰을 얻으셨다면 좋겠네요. 피드백이나 개선 제안이 있다면 알려주세요. 이 글이 가치 있다고 느끼신다면 공유해주세요!\n\n즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png"},"coverImage":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png","tag":["Tech"],"readingTime":16},{"title":"마스터링 디스패치 큐Dispatch Queues in Swift 이해, 구현, 그리고 제한들","description":"","date":"2024-05-23 13:09","slug":"2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations","content":"\n![Image](/assets/img/2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations_0.png)\n\n디스패치 큐는 Apple의 Grand Central Dispatch (GCD)의 일부로 2009년 소개되었으며, 스레드의 대안으로 작업을 비동기적으로 수행할 수 있게 합니다. 우리는 그들의 기능과 작업 큐, 스레드와 비교한 차이를 탐색해보겠습니다.\n\n## 기본 사용법\n\n디스패치 큐를 하나의 작업 라인으로 생각해보세요. 이렇게 생성할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nlet queue = DispatchQueue(label: \"my.queue\")\n```\n\n이제, 해당 큐에서 어떤 작업을 실행하고 싶다면 다음과 같이 작업을 추가하면 됩니다:\n\n```swift\nqueue.async {\n    print(\"여기서 일부 작업을 수행 중입니다!\")\n}\n```\n\n# 디스패치 큐 유형\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 시리얼 큐\n\n기본적으로 디스패치 큐를 생성할 때 특성을 지정하지 않으면 시리얼 큐를 얻게 됩니다. 시리얼 큐에 대기열에 있는 작업들은 한 번에 하나씩 순차적으로 실행되며, 마치 한 줄로 움직이는 자동차와 같습니다. 예를 들어:\n\n```js\nlet serialQueue = DispatchQueue(label: \"my.serial.queue\")\nserialQueue.async {\n print(\"작업 1\")\n}\nserialQueue.async {\n print(\"작업 2\")\n}\n```\n\n## 병렬 큐\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한편, 동시 큐는 작업들이 동시에 실행되도록 허용합니다. 이는 여러 차로로 이어진 고속도로와 같이 작동하여 차(작업)들이 나란히 이동할 수 있도록 합니다. 이와 같이 동시 큐를 만들 수 있습니다:\n\n```js\nlet concurrentQueue = DispatchQueue(label: \"my.concurrent.queue\", attributes: .concurrent)\nconcurrentQueue.async {\n print(\"동시 작업 1\")\n}\nconcurrentQueue.async {\n print(\"동시 작업 2\")\n}\n```\n\n## 지연된 실행\n\nDispatch 큐는 작업의 지연된 실행을 가능하게 합니다. 특정 시간 이후에 작업을 시작할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nlet delayedQueue = DispatchQueue(label: \"delayed.queue\")\ndelayedQueue.asyncAfter(deadline: .now() + 1) {\n    print(\"1초 후에 시작하는 작업입니다!\")\n}\n```\n\n## 작업 우선순위\n\nGCD(Grand Central Dispatch) 큐는 작업 우선순위를 설정할 수 있도록 해줍니다. 이는 다른 작업들과 얼마나 빨리 실행되어야 하는지를 결정합니다:\n\n```swift\nlet highPriorityQueue = DispatchQueue(\n    label: \"high.priority.queue\",\n    qos: .userInitiated\n)\nlet highPriorityTask = DispatchWorkItem {\n    print(\"이것은 높은 우선순위 작업입니다!\")\n}\nhighPriorityQueue.async(execute: highPriorityTask)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 작업 취소\n\n필요할 경우 작업을 취소할 수 있지만, 반드시 스레드와 작업 큐와 같이 작업 내에서 취소 여부를 확인하는 것이 중요합니다.\n\n```js\nvar task: DispatchWorkItem!\ntask = DispatchWorkItem {\n guard !task.isCancelled else {\n print(\"작업이 취소되었습니다.\")\n return\n }\n // 일부 작업 수행\n}\nqueue.async(execute: task)\n// 일정 시간 후 취소하려면\nDispatchQueue.global().asyncAfter(deadline: .now() + 3) {\n task.cancel()\n}\n```\n\n## 데이터 공유\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n디스패치 큐는 큐에 사용자 정의 데이터를 연결하는 DispatchSpecificKey를 제공하여 동일한 컨텍스트에서 실행되는 작업들 간에 데이터 공유를 허용합니다.\n\n```swift\nlet id = UUID()\nlet specificKey = DispatchSpecificKey\u003cUUID\u003e()\nqueue.setSpecific(key: specificKey, value: id)\nif let retrievedId = DispatchQueue.getSpecific(key: specificKey) {\n print(\"Found the ID: \\(retrievedId)\")\n}\n```\n\n물론! 이제 우리는 디스패치 큐에서 타겟팅 개념을 코드 예제와 함께 살펴보면서 큐 간에 어떻게 데이터가 흐르는지 이해해보겠습니다.\n\n# 큐 타겟팅과 디테일 이해하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 특정 사항 설정 및 액세스\n\n동일한 대기열에서 실행되는 작업 내에서 대기열을 만들고 특정 사항(사용자 지정 데이터)을 설정하고 해당 특정 사항에 액세스하는 방법을 고려해보세요:\n\n```js\nlet queue1 = DispatchQueue(label: \"queue1\")\nlet idKey = DispatchSpecificKey\u003cInt\u003e()\nlet dateKey = DispatchSpecificKey\u003cDate\u003e()\nqueue1.setSpecific(key: idKey, value: 42)\nqueue1.setSpecific(key: dateKey, value: Date())\nqueue1.async {\n print(\"queue1\", \"id\", DispatchQueue.getSpecific(key: idKey))\n print(\"queue1\", \"date\", DispatchQueue.getSpecific(key: dateKey))\n}\n```\n\n## 새로운 대기열에서 특정 사항을 잃는 경우\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기존 큐 내에서 새 큐를 생성하더라도 자동으로 세부사항을 상속받지 않습니다:\n\n```js\nqueue1.async {\n let queue2 = DispatchQueue(label: \"queue2\")\n queue2.setSpecific(key: idKey, value: 1729)\n queue2.async {\n print(\"queue2\", \"id\", DispatchQueue.getSpecific(key: idKey))\n print(\"queue2\", \"date\", DispatchQueue.getSpecific(key: dateKey))\n }\n}\n```\n\n## 특정 사항 상속을 위한 큐 지정\n\n지정은 새 큐에서 특정 정보 손실 문제를 해결합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nlet queue2 = DispatchQueue(label: \"queue2\", target: queue1)\nqueue2.setSpecific(key: idKey, value: 1729)\nqueue2.async {\n print(\"queue2\", \"id\", DispatchQueue.getSpecific(key: idKey))\n print(\"queue2\", \"date\", DispatchQueue.getSpecific(key: dateKey))\n}\n```\n\n## 지정된 대상 대기열을 사용하여 병렬 작업 실행하기\n\n두 개의 독립적인 작업, 데이터베이스 쿼리와 네트워크 요청이 있다고 가정하고 이를 병렬로 실행하려고 합니다:\n\n```js\nfunc response(for request: URLRequest, queue: DispatchQueue) -\u003e HTTPURLResponse {\n let group = DispatchGroup()\n let databaseQueue = DispatchQueue(label: \"database-request\", target: queue)\n databaseQueue.async(group: group) {\n makeDatabaseQuery()\n }\n let networkQueue = DispatchQueue(label: \"network-request\", target: queue)\n networkQueue.async(group: group) {\n makeNetworkRequest()\n }\n group.wait()\n return .init()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 특정 사항 상속 유지\n\n새 대기열이 특정 사항을 상속받도록하려면 부모 대기열을 인수로 전달하십시오:\n\n```js\nresponse(for: .init(url: .init(string: \"https://www.testurl.com\")!), queue: queue)\n```\n\n## 대기열 생성 최적화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한개의 동시 서버 대기열을 만들고 새 대기열을 이 속성을 상속하도록 타깃팅하여 최적화하세요:\n\n```js\nlet serverQueue = DispatchQueue(label: \"server\", attributes: .concurrent)\n// 각 요청에 대해\nlet queue = DispatchQueue(label: \"request-\\(requestId)\", attributes: .concurrent, target: serverQueue)\nqueue.setSpecific(key: requestIdKey, value: requestId)\nqueue.async {\n    response(for: .init(url: .init(string: \"https://www.testurl.com\")!)\n}\n```\n\n# 제약 사항:\n\nSwift의 디스패치 대기열은 스레드와 작업 대기열의 강점을 결합하여 비동기 작업, 우선순위 관리, 취소 및 특정 데이터 저장을 제공합니다. 그러나 아직도 주의를 요하는 일부 도전이 존재합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 특정 상속을 위한 큐 전달\n\n현재 새 큐 내에서 특정 사항을 상속하려면 부모 큐를 명시적으로 전달해야 하며, 암시적 데이터 흐름의 목적이 무력화됩니다:\n\n```js\nresponse(for: .init(url: .init(string: \"https://www.testurl.com\")!), queue: requestQueue)\n```\n\n이 접근 방식은 계층별로 데이터를 전달하지 않고 실행 컨텍스트 전체에서 매끄럽게 데이터를 공유하는 목표에 모순됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 취소 및 스레드 관리 상속\n   디스패치 큐 사이에 구체적인 사항을 상속할 수는 있지만, 하나의 작업 항목의 취소는 자식 작업 항목으로 전파되지 않습니다. 제대로 처리되지 않을 경우에는 여전히 스레드가 증가할 수 있으며, 이는 잠재적으로 리소스 문제로 이어질 수 있습니다.\n\n3. 큐 굶주림과 강렬한 작업\n   단일 작업 단위를 위해 많은 큐를 생성하거나 CPU 집약적 작업을 단일 큐에서 실행하는 것은 스레드 굶주림으로 이어질 수 있습니다. 디스패치 큐는 작업 항목간 협력을 위한 도구가 부족하여 CPU 이용률을 공정하게 제어하는 데 어려움을 겪습니다.\n\n4. 협력적인 동시 코드 부재\n   GCD는 강력하지만, 협력적인 동시 코드를 작성하기 위한 기능이 부족합니다. 작업 항목은 휴식 시간에 다른 리소스를 활용할 수 있게 허용하지 않으면 CPU 시간을 경쟁하게 됩니다.\n\n5. 데이터 레이스 완화\n   GCD는 데이터 레이스를 방지하기 위한 바리어 같은 동기화 도구를 제공하나, 명시적 처리가 필요하며 전통적인 NSLock 같은 잠금과 비교해 속도가 느릴 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Summary\n\n요약하자면, GCD는 강력한 병렬 처리 도구를 제공하지만, 암시적 데이터 흐름, 취소 상속, CPU 자원 관리, 협력적 병렬 코드 및 효과적인 데이터 경쟁 처리와 같은 문제를 해결하는 것은 여전히 개선이 필요한 부분입니다. GCD 도구는 도움이 되지만 병렬 처리 모델에 깊게 통합되지는 않아, 이러한 세밀한 문제들을 효과적으로 처리하는 책임은 개발자에게 있습니다.\n\n다음 단계: Swift에서 병렬 처리를 마스터하고 싶나요? 다음 챕터인 '병렬 처리 마스터링: Task'을 살펴보세요.\n\n# Series Navigation\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 제1부: 스위프트에서 쓰레드 탐구\n- 제2부: 스위프트의 Operation Queues 탐구: 한계와 함께 쓰레딩 향상\n- 제3부: 스위프트에서 Dispatch Queues 숙달하기: 이해, 구현 및 한계\n- 제4부: 병행성 마스터링: Task\n- 제5부: 스위프트 병행성: @Sendable 및 Actors로 데이터 보호하기\n","ogImage":{"url":"/assets/img/2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations_0.png"},"coverImage":"/assets/img/2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations_0.png","tag":["Tech"],"readingTime":11},{"title":"사용자 정의 Segmented Control  SwiftUI","description":"","date":"2024-05-23 13:08","slug":"2024-05-23-CustomSegmentedControlSwiftUI","content":"\n이 기사에서는 SwiftUI 프레임워크 내에서 사용자 정의 디자인을 적용한 Segmented Control 예제를 찾을 수 있습니다. 이 방법은 애플리케이션에 특별히 디자인된 Segmented Control을 사용자화합니다.\n\n![Custom Segmented Control Example](/assets/img/2024-05-23-CustomSegmentedControlSwiftUI_0.png)\n\n# Segmented Controls\n\n애플 사전적 정의에 따르면 Segmented Control은 두 개 이상의 세그먼트로 구성된 일련의 요소로, 각각 버튼의 역할을 합니다. Segmented Control 내에서 모든 세그먼트는 일반적으로 동일한 너비를 갖고 있습니다. 버튼과 같이 세그먼트에는 텍스트나 이미지가 포함될 수 있습니다. 세그먼트 아래에 텍스트 레이블을 가질 수도 있습니다(또는 제어 전체 아래에). Segmented Control은 단일 선택 또는 다중 선택을 제공할 수 있습니다. (1).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwiftUI 라이브러리에서는 Segmented, UIKit 프레임워크에서는 UISegmentedControl라고 해요.\n\n# 사용자 정의 세그먼트 컨트롤\n\n앱의 테마에 맞게 디자인하려면 아래 방법을 따라주세요.\n\n이번에는 두 개의 요소로 구성된 세그먼트 컨트롤을 디자인하겠습니다. 이를 위해 0과 1로 구성된 enum 타입으로 관리할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 0 : 카메라\n// 1 : 사진 라이브러리\n```\n\n아래는 디자인 출력입니다. 그에 따라 개발되었습니다. ⬇️\n\n\u003cimg src=\"/assets/img/2024-05-23-CustomSegmentedControlSwiftUI_1.png\" /\u003e\n\n```js\nimport Foundation\nimport SwiftUI\n\nstruct CustomSegmentedControl: View {\n    @Binding var preselectedIndex: Int\n    var options: [String]\n    // 이 색상은 테마 라이브러리에서 가져온 것입니다\n    let color = ThemeManager.shared.currentTheme.currentPallet.secondary\n\n    var body: some View {\n        HStack(spacing: 0) {\n            ForEach(options.indices, id:\\.self) { index in\n                ZStack {\n                    Rectangle()\n                        .fill(color.opacity(0.2))\n\n                    Rectangle()\n                        .fill(color)\n                        .cornerRadius(20)\n                        .padding(2)\n                        .opacity(preselectedIndex == index ? 1 : 0.01)\n                        .onTapGesture {\n                            withAnimation(.interactiveSpring()) {\n                                preselectedIndex = index\n                            }\n                        }\n                }\n                .overlay(\n                    Text(options[index])\n                )\n            }\n        }\n        .frame(height: 50)\n        .cornerRadius(20)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCustom Segmented Control 클래스는 두 개의 매개변수를 사용합니다. 첫 번째 매개변수는 현재 선택된 아이템을 나타내고, 두 번째 매개변수는 아이템 배열 문자열로 사용됩니다. 이 배열은 상수로 정의할 수 있습니다.\n\n중요한 점은 첫 번째 매개변수가 @Binding으로 표시되어야 한다는 것입니다.\n\n이 매개변수는 @state로 유지하고 sourcetype과 함께 뷰로 전송됩니다.\n\n제스처와 함께 작동하는 작은 애니메이션이 있는 코드가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```bash\nVStack{\n     CustomSegmentedControl(preselectedIndex: $selectedSegmentSourceType,\n        options: [Localization.value(\"photos.title\"), Localization.value(\"camera.title\")])\n}\n```\n\n또한, 컨트롤에서 변경한 값은 뷰에서 sourcetype 변수와 함께 만들어집니다.\n\n이 변수를 통해 선택 상태를 읽을 수 있습니다.\n\n다음 글에서 이 세그먼트 컨트롤과 피커를 함께 사용할 예정이에요. ❤️‍🔥\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 자료들\n","ogImage":{"url":"/assets/img/2024-05-23-CustomSegmentedControlSwiftUI_0.png"},"coverImage":"/assets/img/2024-05-23-CustomSegmentedControlSwiftUI_0.png","tag":["Tech"],"readingTime":4},{"title":"기술 및 미디어 부문의 침체로 비윤리적인 기업들이 어떻게 이용하고 있는지 알아보기","description":"","date":"2024-05-23 13:07","slug":"2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors","content":"\n\u003cimg src=\"/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png\" /\u003e\n\n와이어드 기사인 \"테크 취업 면접이 어미잡아\"는 내 학생들이 얼마나 오랫동안 말해왔던 불쾌한 추세를 확인했어요. 몇몇 부도덕한 회사들이 취업 면접을 무료로 가치 있는 작업을 제공하도록 변형시키고 있어요.\n\n일주일 전, 한 MBA 학생이 사회 네트워크를 위한 콘텐츠를 몇 일 동안 생성하는 것을 포함한 선발 프로세스에 대한 경험을 나누었어요. 많은 전문 경험을 가진 사람들이 이런 작업을 하는 것을 요구하는 것은 \"그동안과 고생이 되었어요\"의 수준까지 이를 강요하는 것과 다를 바 없어요.\n\n기술과 미디어 기업이 대규모 인력 감축을 하고 있는 시기에, 일부 부도덕한 회사들이 개발자들에게, 예를 들어, \"데스크톱 어플리케이션을 처음부터 만들고, 백엔드 시스템 모형에 연결하고, 모든 단계를 철저히 문서화하라\" 또는 \"현재 어플리케이션에 대한 새로운 기능을 개발하고 문서화하라\"를 요구하고 있어요. 이 프로젝트들은 때로는 몇 일이 걸릴 수 있고, 후보자들은 보상받지 않은 채로 작업을 하게 되며, 제출 후 회사는 단순히 개발자에게 \"선발 프로세스에 실패했다\"고 말한 후 그 작업을 계속 사용할 수도 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 채용 관행은 단순히 후보자들로 하여금 회사를 위해 무료로 일하도록 유도하는 방법에 불과합니다. 어떤 사람이 얼마나 그 일에 관심이 있더라도 받아들일 필요가 없으며, 이러한 관행은 거부되고 공개되어야 합니다. 윤리적이고 부도덕한 회사들에 대해 매우 주의해야 합니다. 시장 상황을 악용하여 자격있는 노동력을 착취하고 무료 노동을 얻을 수 있는 회사들입니다. 이러한 방식으로 일 하는 회사와의 전문적인 관계에서는 아무런 긍정적인 결과를 기대할 수 없습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png"},"coverImage":"/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png","tag":["Tech"],"readingTime":2},{"title":"Salesforce 마케팅 클라우드에 WhatsApp 통합하기 단계별 가이드","description":"","date":"2024-05-23 13:06","slug":"2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide","content":"\n\u003cimg src=\"/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png\" /\u003e\n\n즉각적인 메시징 시대에 있어 WhatsApp와 Salesforce Marketing Cloud (SFMC)를 통합하면 고객과의 참여를 크게 향상시키고 커뮤니케이션을 간소화할 수 있습니다. 이 통합을 통해 기업은 WhatsApp의 대규모 사용자 기반과 실시간 커뮤니케이션 기능을 마케팅 자동화 워크플로 내에서 직접 활용할 수 있습니다. Salesforce Marketing Cloud에 WhatsApp를 통합하는 방법에 대한 포괄적인 안내서입니다.\n\n# 단계 1: 사전 요구 사항 이해\n\n• Salesforce Marketing Cloud 계정: 필요한 설정을 구성할 관리자 액세스 권한이 있는지 확인하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n• WhatsApp 비즈니스 계정: 공식 WhatsApp 비즈니스 솔루션 제공업체(BSP)를 통해 승인된 WhatsApp 비즈니스 계정이 필요합니다.\n\n• Twilio 계정: Twilio는 WhatsApp를 SFMC와 통합할 수 있게 해주는 인기있는 BSP입니다. 활성화된 Twilio 계정과 API 자격 증명을 보유하고 있는지 확인해주세요.\n\n# 단계 2: WhatsApp용 Twilio 설정하기\n\n1. Twilio 가입: Twilio에서 계정을 생성하고 Twilio Console로 이동하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. WhatsApp Business 신청: Twilio를 통해 WhatsApp 비즈니스 프로필을 제출하고 승인을 받으세요. 이 과정에는 비즈니스 정보 제공과 전화번호 인증이 포함됩니다.\n\n3. API 자격 증명 획득: 승인된 후 Twilio 계정 SID, Auth Token 및 WhatsApp 활성화된 전화번호를 받으세요.\n\n# 단계 3: Salesforce Marketing Cloud 구성\n\n1. Salesforce Marketing Cloud에 로그인: 관리자 자격 증명을 사용하여 SFMC 대시보드에 액세스하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Mobile Studio로 이동하려면: SFMC 인터페이스에서 Mobile Studio로 이동합니다.\n\n3. WhatsApp 채널 만들기:\n\n- '관리'로 이동하고 '계정 설정'을 선택합니다.\n\n- '채널'을 클릭하고 'WhatsApp'을 선택합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n• 필요한 정보를 입력하세요. Twilio 계정 SID, 인증 토큰 및 WhatsApp 번호를 포함해야 합니다.\n\n4. 연락처 데이터 설정: SFMC의 연락처 데이터에는 전화번호가 WhatsApp 통신용으로 형식화되어 있어야 합니다. 이는 일반적으로 전화번호 앞에 0이나 특수 문자가 없는 국제 형식을 사용하는 것을 의미합니다.\n\n# 단계 4: WhatsApp 메시지 작성\n\n1. 메시지 템플릿 생성: WhatsApp은 비즈니스에서 시작된 대화에 대해 사전 승인된 메시지 템플릿이 필요합니다. Twilio에서 이러한 템플릿을 생성하고 승인을 요청하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. SFMC로 템플릿 가져오기: 승인되면 Salesforce Marketing Cloud에 이러한 템플릿을 가져옵니다.\n\n# 단계 5: SFMC에서 WhatsApp 캠페인 만들기\n\n1. Journey Builder: SFMC의 Journey Builder를 사용하여 WhatsApp을 커뮤니케이션 채널로 포함한 고객 여정을 만듭니다.\n\n- 고객 여정 워크플로에 'WhatsApp 전송' 활동을 끌어다 놓습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n• 미리 승인된 템플릿을 선택하고 연락처 데이터를 매핑하여 메시지를 개인화하세요.\n\n2. 자동화 스튜디오: 고객이 취한 특정 이벤트 또는 조치에 따라 WhatsApp 메시지를 트리거하는 자동화를 설정하세요.\n\n# 단계 6: 테스트 및 배포\n\n1. 통합 테스트: 라이브로 이동하기 전에 메시지가 올바르게 보내지고 수신되는지 확인하기 위해 철저한 테스트를 수행하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 모니터링 및 최적화: 배포 후에는 SFMC의 분석 도구를 통해 WhatsApp 캠페인의 성능을 모니터링하고 최적화하세요. 참여 지표와 피드백에 기반하여 최적화하세요.\n\n시나리오: 소매 회사가 Salesforce Marketing Cloud 내에서 마케팅 및 서비스 업무에 WhatsApp을 통합하여 고객 지원 및 참여를 개선하고자 합니다.\n\n# 목표:\n\n1. WhatsApp을 통해 실시간 고객 지원 제공하기.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**솔루션:**\n\n- 실시간 지원: 고객은 지원 문제를 위해 WhatsApp을 통해 채팅을 시작할 수 있습니다. SFMC와의 통합을 통해 고객 서비스 담당자가 고객 데이터 및 상호 작용 기록에 액세스하여 신속하고 맞춤형 지원을 제공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n• 프로모션 및 업데이트: 주문 확인, 배송 알림 및 개인 맞춤 프로모션 제공을 위해 자동화된 WhatsApp 메시지를 보낼 수 있어 고객들이 항상 정보를 받고 참여할 수 있도록 합니다.\n\n# 구현 단계별 순서:\n\n## 1. WhatsApp을 위한 Twilio 설정:\n\n## 2. SFMC 구성:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3. 메시지 템플릿 만들기:\n\n## 4. 고객 여정 구축:\n\n## • 환영 메시지:\n\n## • 주문 확인:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## • 배송 알림:\n\n## • 프로모션 제안:\n\n• SFMC의 분석 도구를 사용하여 WhatsApp 캠페인의 성능을 추적하세요.\n\n• 오픈률, 응답률 및 고객 피드백을 모니터링하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n• 데이터 통찰을 기반으로 메시지와 워크플로우를 지속적으로 최적화하세요.\n\n## • 맞춤화:\n\n고객 데이터를 활용하여 WhatsApp 메시지를 맞춤화하여 참여도와 응답률을 향상시킵니다.\n\n## • 준수:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWhatsApp의 비즈니스 정책과 GDPR와 같은 데이터 보호 규정을 준수해주세요.\n\n## • 세분화:\n\n대상을 분할하여 타겟팅된 및 관련성 있는 메시지를 보내어 캠페인의 효과를 향상시켜주세요.\n\nFollow Me:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루치카 산돌카 (함께成長합시다) 🫱🏻‍🫲🏽\n\n또는\n\n매일 Salesforce 업데이트를 받기 위해 WhatsApp 커뮤니티에 참여해주세요.\n\n참여하기 위해 스캔: 📲\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_1.png`를 사용하려면 이미지 태그를 Markdown 형식으로 변경하면 됩니다.\n","ogImage":{"url":"/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":8},{"title":"프로그래머를 위한 11가지 어첈없이 간단한 수동 소득 아이디어","description":"","date":"2024-05-23 13:05","slug":"2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers","content":"\n\u003cimg src=\"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png\" /\u003e\n\n프로그래머들은 창의적인 인간들이에요; 우리는 생각하고 혁신하고 만들어 냅니다.\n\n프로그래머가 되는 것도 중요하지만, 기업가적 사고를 갖춘 프로그래머가 되는 것은 또 다른 문제죠...\n\n그리고 지금 이 시점에서 이 기사를 읽고 계시다면, 여러분이 자신의 재정을 늘리기 위한 능력을 갖췄다고 믿어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글에서는 프로그래머를 위한 11가지 수동 소득 아이디어를 공유하겠습니다.\n\n별 거짓말 없이, 이것은 인터넷의 무작위 쓰레기가 아닌 다음과 같은 내용에 대한 심층적인 탐구입니다:\n\n- 프로그래머로써 시도해본 것 중 실제로 성공한 사례,\n- 현재 탐색 중인 새로운 긍정적인 통찰,\n- 동료들의 성공적인 사업 모험과 내부 기술 커뮤니티에서의 경험,\n- 제대로 하고 있는 프로그래머들과의 몇 가지 개인 인터뷰.\n\n바로 알아봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 수동 소득 뒤의 진실\n\n수동 소득은 추가적인 노력이 없거나 최소한의 노력으로 주기적으로 돈을 발생시킬 때 이를 지칭합니다.\n\n가장 중요한 노력은 설정할 때 들이는 노력일 것입니다.\n\n사실은;\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n본질적으로 수동 소득은 당신이 직접 시간을 돈으로 교환할 필요가 없는 소득원입니다.\n\n수동 소득 사업의 3가지 핵심 특징이 있습니다:\n\n- 막대한 시간 또는 자본의 초기 투자.\n- 적극적인 작업 없이 완전히 설정된 후 소득 생성\n- 운영 유지에 필요한 최소의 노력.\n\n보통 알려진 수동 소득 아이디어와 아직 탐험되지 않은 수동 소득 아이디어에 대해 이야기해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로그래머들을 위한 수익 창출 아이디어\n\n## 1. 블로깅\n\n프로그래머들이 수 pass 된소득을 발생시키는 가장 접근하기 쉬운 방법 중 하나는 블로깅이나 기술 콘텐츠 작성을 통해 이루어집니다.\n\n숙련된 프로그래머로서, 당신이 알려줄 수 있는 것들이 많습니다. 특히 새로운 개발자들에게 더 많은 것을 가르쳐줄 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신의 사고 패턴이나 프로세스/워크플로, 혹은 언어 전문 지식일 수 있습니다.\n\n개인 블로그를 시작하거나 Medium에 글을 쓰실 수도 있습니다.\n\n## 어떤 게 더 좋아요?\n\n저는 기술 블로그를 운영하고 있으며 Medium에도 글을 쓰고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n완전히 새로운 글쓰기에 입문하신 분이라면 Medium을 선택해보세요. 초보자에게 가장 적합한 글쓰기 플랫폼이에요.\n\n하지만 글을 쓰면서 돈을 벌 수 있는 방법은 무엇일까요? 처음 시작할 때 나도 궁금했던 문제였어요.\n\n여기서 간단히 알아보도록 할게요:\n\n- Medium 파트너 프로그램: Medium은 글을 쓰고 유료로 공개된 글에 게시하는 작가들에게 돈을 지급해요. Medium이 유료 사용자들로부터 수익을 올릴 때(프리미엄 글을 읽을 수 있는 사람들) 이익을 작가들과 분할해요.\n- 자체 호스팅된 블로그: 개인 블로그가 있다면 Ezoic, Mediavine 또는 Adthrive와 같은 품질 있는 광고 네트워크에 가입하여 수익을 창출할 수 있어요.\n- 제휴 마케팅과 후원: Medium/자체 호스팅 중 어느 플랫폼을 선택하든, 제휴 마케팅이나 후원을 통해 수익을 창출할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 달 전에, 블로그에서 한 제품으로 제휴 마케팅으로 120달러 이상을 벌었어요.\n\n![이미지](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_1.png)\n\n## 2. 온라인 강의\n\n자신이 잘하는 분야에 대한 강좌를 만들어보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 사람들이 서면 자료 대신 비디오 강의를 선호합니다.\n\n최근 보고서에 따르면 2021년에만 Coursera에 2000만 명 이상의 신규 학습자가 등록했다고 합니다.\n\n일부 인기 있는 강의 플랫폼은 다음과 같습니다:\n\n- Udemy\n- Skillshare\n- Teachable\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 유튜브 채널을 시작해보세요\n\n유튜브는 정보의 보고일 뿐만 아니라 Google 뒤를 이으며 두 번째로 큰 검색 엔진입니다.\n\n그러나 많은 사람들은 유튜브 채널을 시작하는 것을 힘든 작업으로만 생각하며, 특별한 사람들이나 대기업만이 할 수 있는 것으로 여기곤 합니다.\n\n하지만 이는 사실이 아닙니다. 저렴한 비디오 녹화 장비도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 텍스트를 참고해주세요.\n\n![이미지](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_2.png)\n\n다음으로 생각해볼 문제는:\n\n## 채널을 만들면 어떤 주제로 이야기할까요?\n\n이 모두는 당신의 전문 분야에 따라 다릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발 스택이나 기술 면접에서 성공하기 위한 도움이 되는 비디오 가이드, 소프트웨어 엔지니어링, 웹/앱 개발 등과 관련된 것들이 있을 수 있어요.\n\n채널을 시작하기 전에 FreeCodeCamp와 같은 큰 브랜드일 필요는 없어요.\n\n## 4. 디지털 제품 판매\n\n대부분 이북, 치트 시트 및 일반 정보 제품을 가리킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작년에는 29달러에 데브옵스 전자책을 판매하는 개발자와 인터뷰를 했어요. 그 책은 초보자를 위한 가이드처럼 보이는데, 그의 판매 대부분은 트위터 청중에서 나옵니다. 한 달에 약 1300달러를 벌어요.\n\nGumroad와 같은 플랫폼은 디지털 제품을 판매하고 수동 소득을 얻기 위한 마켓플레이스를 제공해요.\n\n# 5. 웹사이트 테마 및 템플릿 판매:\n\n프로그래머들에게 이는 매우 수익성 높은 수동 소득 사업임이 입증되었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 웹 사이트 테마, 템플릿 및 플러그인을 판매할 수 있어요:\n\n- 테마 포레스트\n- 사이트 포인트\n- 템플릿 몬스터\n- 모조 마켓플레이스\n- 크리에이티브 마켓\n- 테마스냅\n- 코데스터\n\n![이미지](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_3.png)\n\n일반 판매 플랫폼 외에도 특정 CMS 마켓플레이스로도 직접 판매할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 다음과 같은 것들을 판매할 수 있어요:\n\n- Shopify 마켓플레이스에서 전자 상거래 테마\n- Ghost 마켓플레이스에서 Ghost 웹사이트 테마\n- WordPress.org에서 WordPress 웹사이트 테마\n\n# 6. 코드, 스크립트 및 플러그인 판매\n\nCMS 테마 이외에도, Code Canyon과 같은 웹사이트에서 직접 프로그래밍 코드, 스크립트 및 플러그인을 판매할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n부트스트랩, 자바스크립트, PHP, HTML5, 모바일/안드로이드 앱 템플릿 및 기타 코드 및 스크립트를 판매할 수 있습니다.\n\n여기에 Ladela가 디자인한 예약 및 일정 관리 소프트웨어 시스템 플러그인이 있어요.\n\nCode Canyon에서 $89에 판매 중이에요.\n\n이 기사를 작성하는 시점에서 52,525번의 판매로 총 $4,000,000 이상의 매출을 기록했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_4.png)\n\n# 7. API 개발\n\n소프트웨어 응용 프로그램이 증가함에 따라 API 서비스에 대한 수요가 증가하고 있습니다.\n\n실제 문제를 해결하거나 개발자에게 가치 있는 서비스를 제공하는 API (Application Programming Interfaces)를 개발하고 활용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n접근을 유료로 제공하거나 계층별 요금제를 제공함으로써, 개발자가 API 서비스를 구독하는 동안 수동 소득을 얻을 수 있습니다.\n\n# 8. 크롬 확장 프로그램 만들기\n\n네, 맞아요. 크롬 확장 프로그램을 만들어 돈을 벌 수 있습니다.\n\n기술 기업가인 김 댕은 그녀의 크롬 확장 프로그램인 Group Convert로 100만 달러 이상을 벌었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4,000 회 이상의 설치를 보유하고 있으며 매월 $10에서 $17까지의 가격대를 가지고 있어요.\n\n김의 기능 확장은 Facebook 그룹 소유자가 그룹에 들어올 때 Facebook 사용자로부터 이메일을 수집하는 데 도움을 줘요.\n\n이 수동 소득 아이디어는 들리는 대로 쉽지 않지만 할만해요.\n\n# 9. 봇 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_5.png\" /\u003e\n\n봇은 고객 서비스부터 소셜 미디어 관리까지 다양한 플랫폼에서 작업을 자동화하는 데 중요한 역할을 합니다.\n\n특정 사용 사례나 산업을 대상으로 하는 봇을 개발할 수 있습니다. 예를 들어 고객 지원용 챗봇이나 금융 시장용 거래 봇 등이 있습니다.\n\n한 번 배포되고 운영 중이면 구독 요금제나 사용량 기반 가격 책정을 통해 패시브 수입을 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 10. iOS 및 Android 애플리케이션 출시\n\n안드로이드 앱 개발자를 위해 특별히 디자인된 이 수동 수입 사업은 모바일 앱 개발자들을 대상으로 합니다.\n\n많은 앱들이 매일 Play 스토어와 App Store에서 출시되지만, 높은 경쟁으로 인해 소수만이 성공을 거두고 있습니다.\n\nSteven Benson은 혁신적인 경로 계획 앱인 Badger Maps를 설립했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_6.png)\n\nWorking with a small team, he was able to quickly scale revenue to $6M ARR within a couple of years. I shared insights from an interview with him in a separate Medium article.\n\n# 11. Creating a SaaS or Micro SaaS\n\nThe last on the list and also what I'll consider the holy grail of passive income generation for programmers as it can lead to very high returns when done right.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인기 있는 SaaS 제품의 예시는 다음과 같습니다:\n\n- 프로젝트 관리를 위한 ClickUp.\n- 실시간 채팅을 위한 Zendesk.\n- 랜딩 페이지 제작을 위한 Leadpages.\n- 마케팅 보고서를 위한 Whatagraph.\n- 자동 PDF 생성을 위한 JotForm PDF 편집기.\n- 파일 및 문서 관리를 위한 Bit.ai.\n- 링크 관리를 위한 Bitly.\n- 일페이지 웹사이트 구축을 위한 Carrd.\n\n일주일 전에 여기에서 두 친구가 SaaS 비즈니스를 55,000 달러의 월 평균 반복 수익으로 확장한 방법에 대한 기사를 게시했어. 한번 확인해봐.\n\nSaaS 비즈니스를 구독 기반 가격으로 제공함으로써, 지속적인 반복 수익을 창출하고 지속 가능한 수 pass받는 소득원을 구축할 수 있어.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 주의:\n\n무엇을 도와드릴까요?\n\n- 제 뉴스레터 가입하기 (글 작가 창업가를 위한 프리미어 뉴스레터).\n- 제 미디엄 계정 팔로우하기 (가치 있는 정보를 얻을 수 있습니다).\n","ogImage":{"url":"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png"},"coverImage":"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png","tag":["Tech"],"readingTime":12},{"title":"자바 개발자로 성장하기 위한 자료와 로드맵","description":"","date":"2024-05-23 13:03","slug":"2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper","content":"\n## DSA, 데이터베이스, 시스템 설계, 객체지향 프로그래밍, 자바, 테스팅, 그리고 더 많은 것들…\n\n![2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0](/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png)\n\n안녕하세요, 독자 여러분! 저는 인도 마이크로소프트에서 5년의 산업 경험을 가진 소프트웨어 엔지니어 II입니다.\n\nLinkedIn, Medium, 그리고 친구들로부터 제가 발전하기 위해 사용한 자원에 관한 메시지를 많이 받았어요. 기다리셨던 대로요! 이제 내가 항상 활용하는 자원들을 여러분과 공유하려고 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 현재 마이크로소프트에서 근무하기 전 주로 Java에 대한 배경을 가지고 있었습니다. 이 영역에서 자원과 고급 기술을 공유하는 데 초점을 맞출 것입니다. 하지만 다른 분야에서도 일반적인 자원 및 IT 산업에서 업그레이드하는 로드맵을 참고할 수 있습니다.\n\n## 참고 — 블로그 안내\n\n- 이 블로그에는 제가 배운 것과 경험한 것이 담겨 있습니다. 모든 것에 동의하지 않을 수도 있습니다. 각 개발자에게는 다른 여정이 있습니다.\n- 이 분야에서 전진하기 위한 순차적 기술과 이정표, 필수 기술 및 전문가 팁을 강조하는 로드맵을 공유할 것입니다. 또한 인터뷰에서 가장 많이 물어보는 주제들을 언급할 것입니다.\n- 또한 내 프로젝트에서 거의 학습하고 공식 튜토리얼을 참조하지 않은 많은 도구들을 실제로 사용한 리소스를 공유할 것입니다.\n- 섹션 사이에 관련된 Medium 블로그를 공유할 것입니다.\n- 자세히 읽어보시고 빠뜨리지 않도록 마지막까지 읽어주시기 바랍니다.\n\n질문이 있으면 언제든지 물어보시거나 LinkedIn에서 DM을 보내주시기 바랍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 로드맵과 자원\n\n## 1. 기초 지식\n\n## Java 핵심:\n\nJava와 여러분이 주력으로 하는 언어에서 전문가가 되도록 노력하세요. 여러분이 뛰어난 분야를 가지는 것은 유익합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발자님 안녕하세요!\n\n다양한 회사에서 일반적인 인터뷰를 실시하기 때문에 언어는 영구적으로 변경될 수 있어요. 특히 제품 중심 회사들이 그렇죠.\n\n저는 자바 개발자로 시작했지만 스칼라, 파이썬으로도 일해봤고 이제는 C++과 C#으로 작업 중이에요.\n\n제 자료: Java Tutorial | Learn Java Programming — javatpoint\n\n## 객체 지향 프로그래밍 (OOPs):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 개념의 중요성을 이해하고 문제를 실질적으로 해결하는 방법을 배웁시다.\n\n내 자료: 자바 OOPs 개념 — Javatpoint\n\n## 데이터 구조와 알고리즘 (DSA):\n\n문제 해결을 위한 필수 데이터 구조와 알고리즘을 마스터하는 것이 중요합니다. 제품 중심 기업에서의 면접을 성공적으로 통과하는 데 필수적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘에는 서비스 기반 조직들도 클라이언트의 요구에 따라 DSA 질문을 하기도 합니다.\n\nDSA는 논리 개발과 알고리즘 구축에도 유용합니다. 예를 들어, 저는 은행 분야 프로젝트에서 슬라이딩 윈도우 기법을 활용한 적이 있습니다.\n\n나의 자료:\n\n- Scott Barrett의 \"Java 자료 구조 및 알고리즘 + LEETCODE 연습\" (Udemy)\n- Tim Buchalka, Goran Lochert의 \"자바를 사용한 자료 구조 및 알고리즘 심층 탐구\" (Udemy)\n- LeetCode (매일 연습)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 중급 스킬\n\n## 멀티스레딩, 동시성, 병렬성:\n\n많은 영역에서 중요하고 널리 사용되며, 회사들은 인터뷰 중 이러한 영역에 대한 능숙함을 기대하기도 합니다.\n\n저는 내 인터뷰 중 대략 60% 정도에서 이러한 주제에 관한 질문을 받았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 자료:\n\n- Java 멀티스레딩, 병행성 및 성능 최적화 — Michael Pogrebinsky (Udemy)\n- Peter Lee의 글: 자바에서의 병행성과 병렬성 | Peter Lee | Medium\n- Multiprogramming vs Multiprocessing vs Multitasking vs Multithreading — Javatpoint\n- G. Abhisek의 글: 병행성, 병렬성, 스레드, 프로세스, 비동기 및 동기 — 관련되어 있나요? 🤔 | G. Abhisek | Swift India | Medium\n\n## 기본 원리, 프레임워크 및 데이터베이스:\n\nSpring Framework: 자바 개발자로서 계속 발전하려면, 의존성 주입, 제어의 역전, 그리고 관점 지향 프로그래밍과 같은 중요한 Spring Framework 개념을 탐구하고 Spring Core, Spring Data, Spring MVC 및 기타 관련 Spring 개념을 다루는 것이 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나의 자원: Spring 튜토리얼 | Baeldung\n\nMySQL: 이것은 중요하며 프로젝트와 인터뷰에서 관계형 데이터베이스, SQL 쿼리 및 데이터베이스 설계 작업에 능숙해지기 위해 항상 필요할 것입니다.\n\nHibernate: 처음에는 ORM(Object-Relational Mapping)에 대해 알아야 하고 Hibernate를 사용하여 데이터베이스와 상호 작용하는 방법을 알아야 했습니다.\n\n소프트웨어 디자인 원칙: 경험 많은 개발자로서 반드시 갖춰야 할 기술은 최적화된 시스템을 설계하는 것이므로 면접이나 지식 습득 시 빠뜨리지 마세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소프트웨어 디자인 원리:\n\n- 디자인 원칙 - 상속보다는 조합을 선호합니다 | LinkedIn\n- 소프트웨어 디자인 원리 | 추상화, 확장성, 응집도 (workat.tech)\n- 예제로 배우는 자바에서의 상속보다는 조합 선호하기 - GeeksforGeeks\n- 의존성 주입에 대한 빠른 소개: 무엇인지 및 언제 사용해야 하는지 (freecodecamp.org)\n- 소프트웨어 디자인 원리 (기본) | DRY, YAGNI, KISS 등 (workat.tech)\n\n## 3. 고급 기술\n\n## 스프링 부트:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스프링 부트는 스프링 플랫폼에 추가된 기능으로, 설정보다는 규약에 중점을 둔다.\n\n스프링 부트를 사용하여 서비스 및 웹 애플리케이션을 구축하는 방법에 대해 알아보세요.\n\n내 자료: Spring Boot 배우기 | Baeldung\n\n## 마이크로서비스 아키텍처:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 3부에서 언급했지만, 요즘 개발자 인터뷰에서 가장 많이 묻는 주제 중 하나에요.\n\n마이크로서비스의 원리를 이해하고, 설계하고, 구현하고, 배포하는 방법을 알아보세요.\n\n## Apache Kafka/RabbitMQ:\n\n이것들은 개발자에게 추가로 좋은 기술들이에요. 널리 사용되며 개발자의 실용적인 지식을 향상시킬 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스케일러블하고 분산 시스템을 구축하기 위한 메시지 브로커에 대해 알아보세요.\n\n가장 중요한 것은 모든 것을 왜 필요로 하는지 알아야 합니다 (왜 처음부터 그들이 필요한지).\n\n내 자료: Apache Kafka 튜토리얼 시리즈 힌디어 버전 - YouTube\n\n## AWS:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS 및 AWS, Azure, GCP 등과 같은 모든 클라우드 서비스는 중요합니다. 매일 다른 취직 공고에서 이에 관한 언급을 찾을 수 있을 거에요.\n\n회사들은 시니어 개발자들이 클라우드 플랫폼 서비스에 대해 실무 경험이 있어야 한다고 기대하며, 최소한 입문자 수준에서도 공통적인 서비스에 대한 경험이 필요합니다.\n\n이미 이러한 프로젝트 경험이 있나요? 와! 없다면, 오늘부터 시작해 볼까요? 직접 POC(Concept of Proof)를 해보세요.\n\n호스팅, 저장 및 컴퓨팅을 위한 클라우드 서비스를 탐색해보세요. 여기서 배운 것의 \"무엇\"과 \"왜\"도 알아야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 자료: [NEW] Ultimate AWS Certified Cloud Practitioner CLF-C02 — by Stephane Maarek (Udemy)\n\n## 4. 전문분야\n\n## REST API:\n\nRESTful API를 설계하고 구현하는 방법을 배워보세요. 마이크로서비스에서 RESTful API가 널리 사용되고 개발자들로부터 기대되므로 이를 숙지하는 것이 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 통합 테스팅 및 유닛 테스팅:\n\n분산 시스템에서 컴포넌트 간의 통합 테스팅 및 독립적인 컴포넌트의 유닛 테스팅하는 중요성과 방법에 대해 이해합니다.\n\nJUnit, Mockito, Cucumber, 그리고 Chai(node.js)와 같은 도구들이 유명합니다.\n\n유닛 테스트는 온라인 평가 및 머신 코딩 인터뷰 라운드의 일부가 되기도 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 외에도, 이러한 것들은 개발자가 코드에서 채택해야 하는 매우 유익한 관행들입니다.\n\n## 시스템 설계:\n\n여기서 고수준 설계 (HLDs)와 저수준 설계 (LLDs) 같은 용어가 나옵니다.\n\nSSEs에서는 HLDs가 깊게 다뤄지며, LLDs는 상위 수준에서 기대됩니다. 기본 LLDs도 SSEs로부터 요청될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서, 확장 가능하고 신뢰할 수 있는 시스템을 설계하는 기술을 숙달해보세요. 어떤 구성 요소를 사용할지, 왜 사용하는지, 그리고 어떻게 사용할지를 알아야 합니다.\n\n시스템 설계는 가장 많은 반문이 있는 면접 라운드입니다. 따라서 시스템 설계 질문에 대한 각 구성 요소의 요구 사항을 매우 잘 이해해야 합니다.\n\n나의 자료:\n\n- 시스템 설계 튜토리얼 — GeekforGeeks\n- 초보자를 위한 시스템 설계 — YouTube\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 5. 도구 및 기술\n\nGit, Maven, Gradle: 개발자들이 알아야 하는 기본적인 도구로 버전 관리, 의존성 관리 및 빌드 자동화 도구가 포함됩니다.\n\nDocker, Kubernetes: 애플리케이션을 배포하고 관리하기 위한 컨테이너화 및 오케스트레이션을 탐색해보세요.\n\nJenkins, JIRA: Agile 개발을 위한 CI/CD 파이프라인과 프로젝트 관리 도구에 대해 이해해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6. 전문 기술\n\n- 커뮤니케이션: 팀원 및 이해관계자들과 효율적인 협업을 위해 커뮤니케이션 기술 향상하기.\n\n- 리더십과 팀 관리: 프로젝트를 성공적으로 완료하기 위해 팀을 리드하고 관리하는 방법 익히기. 시니어 개발자로서 중요한 기술이에요.\n\n- 애자일 방법론: 요즘은 거의 80% 이상의 회사가 인터뷰 후보자가 스크럼이나 칸반 등 애자일 원칙 및 방법론, 그리고 JIRA, Confluence, SDLC와 같은 도구에 대해 이해하거나 경험이 있기를 기대해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 요약\n\n저는 수준별로 모든 것을 나열했습니다.\n\nDSA와 함께 '||'가 있으면 DSA가 다른 모든 수준과 병렬로 처리될 수 있음을 나타내며 (이상적으로는 절대 중지하면 안 됨).\n\n2024년 현재 Java 개발자에게 필요한 최고의 기술은 DSA, 시스템 디자인, Java, 마이크로서비스, Spring Boot, AWS/Azure와 같은 클라우드 플랫폼, Apache Kafka/RabbitMQ와 같은 메시지 브로커, MySQL과 같은 데이터베이스, 그리고 Redis와 같은 캐싱 메커니즘이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경험 많은 직원들에게 기대되는 기본적인 기술은 Git, CI/CD 파이프라인에 대한 이해, 그리고 자동화 도구 구축입니다.\n\n오늘날 인터뷰에서는 'Docker'와 'Kubernetes'와 같은 용어가 특히 강조됩니다.\n\nGitHub Actions, Telemetry, Spinnaker, Datadog, New Relic 등의 APM 도구는 추가 요건으로 고려됩니다.\n\n지금까지 만난 가장 중요한 기술들이며 이러한 분야에서 뛰어나거나 이를 뛰어넘는다면 다수의 개발자들 사이에서 돋보이게 되어 어려운 인터뷰에 성공하거나 MAANGs와 같은 주요 기술 회사에서 취업할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 학습하거나 복습하고 있는 개념이 있나요? 저는 레벨 5에 있어서 Docker와 Kubernetes를 배우고 있어요.\n\n또한, 아래 블로그들도 확인해보세요:\n\n질문이 있으면 답글로 물어보시거나 LinkedIn에서 메시지를 보내주세요. 또한, 다음에 다루고 싶은 다른 주제가 있다면 제안해주세요.\n","ogImage":{"url":"/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png"},"coverImage":"/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png","tag":["Tech"],"readingTime":13},{"title":"2024년에 경력있는 Java 개발자를 위한 카프카 인터뷰 질문","description":"","date":"2024-05-23 12:57","slug":"2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024","content":"\n## 안녕하세요 여러분, 카프카와 관련된 또 다른 기사에 오신 것을 환영합니다. 요즘 대부분의 기술 인터뷰에서 자바, 프런트엔드, 백엔드 및 풀스택 개발자 인터뷰에서 카프카 관련 질문이 나온다고 하죠. 하지만 왜 그럴까요? 분산 환경에서 여러 애플리케이션을 연결하기 위해 미들웨어가 필요하고 카프카는 인기 있는 미들웨어이면서 매우 강력합니다. 업계는 이를 신속하게 채택했기 때문에 카프카는 인터뷰에서 중요하다고 할 수 있습니다. 이제 물어볼 수 있는 질문 유형으로 들어가보겠습니다. 초보자나 신입 개발자는 이 부분을 건너 뛰어도 됩니다.\n\n![이미지](/assets/img/2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024_0.png)\n\n## 왜 카프카가 기술 산업에서 사용되며 왜 인기가 많을까요?\n\n아파치 카프카는 기술 산업에서 인기가 많은데, 그 이유는 몇 가지 주요한 이유로 인해입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 높은 처리량과 낮은 지연 시간: Kafka는 대량의 메시지를 신속하게 처리하여 실시간 데이터 처리에 적합합니다.\n- 확장성: Kafka의 분산 아키텍처로 수평적 확장이 가능하며, 더 많은 노드를 추가함으로써 데이터 요구량을 수용할 수 있습니다.\n- 고장 허용성 및 신뢰성: Kafka는 복제와 파티셔닝을 통해 데이터의 내구성과 신뢰성을 보장하여 일부 노드가 실패해도 작업을 유지합니다.\n- 스트림 처리: Kafka Streams를 사용하면 복잡한 실시간 데이터 처리 응용프로그램을 구축할 수 있습니다.\n- 데이터 통합: Kafka는 다양한 소스에서 데이터를 통합하고 여러 시스템에 분산하는 중앙 허브 역할을 합니다.\n- 오픈 소스 및 커뮤니티 지원: Kafka는 계속해서 기능을 개선하고 확장하는 거대하고 활발한 커뮤니티의 혜택을 받습니다.\n- 다양한 사용 사례: Kafka는 로그 집계, 실시간 분석, 이벤트 소싱, 메시징 및 메트릭 수집에 사용됩니다.\n- 대형 데이터 생태계와의 호환성: Kafka는 하둡, 스파크, 엘라스틱서치와 같은 기술과 잘 통합되어 종합적인 데이터 파이프라인을 용이하게 합니다.\n- 간소화된 데이터 처리: Kafka는 비동기 처리를 통해 시스템 성능과 신뢰성을 향상시킵니다.\n\nLinkedIn, Netflix, Uber, Airbnb와 같은 주요 기술 기업은 Kafka를 강력하고 확장 가능하며 효율적인 실시간 데이터 처리 능력으로 사용하며, 생산 환경에서의 효과를 입증하고 있습니다.\n\n경험이 풍부한 개발자로서, 면접에서 Kafka 지식에 대한 강한 수요를 알아챘습니다. 다른 분들이 준비하는 데 도움이 되도록, Kafka에 관한 질문 및 답변 세션을 게시할 예정입니다. 만나서 질문과 의견을 자유롭게 남겨주세요!\n\n## Kafka의 주요 구성 요소는 무엇인가요? (프로듀서, 컨슈머, 브로커, 토픽, 주키퍼)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로듀서: 이들은 데이터 스트림을 Kafka에 발행하는 애플리케이션이나 서비스입니다. 특정 카테고리나 피드인 토픽에 메시지를 작성합니다 (아래에서 설명됨). 프로듀서들은 소비자와 직접 상호작용하지 않고 Kafka로 데이터를 발행합니다.\n\n컨슈머: 이들은 토픽을 구독하고 프로듀서가 발행한 데이터 스트림을 읽는 애플리케이션이나 서비스입니다. 컨슈머들은 메시지 처리 방법을 조정하기 위해 컨슈머 그룹에 속할 수 있습니다 (아래 설명됨).\n\n토픽: 토픽을 데이터 스트림을 위한 명명된 카테고리나 피드로 생각해보세요. 프로듀서들은 특정 토픽에 데이터를 발행하고, 컨슈머들은 해당 토픽을 구독하여 데이터를 받습니다.\n\n브로커: 이들은 Kafka 클러스터를 형성하는 서버들입니다. 단일 Kafka 클러스터는 함께 작동하는 하나 이상의 브로커를 가질 수 있습니다. 브로커들은 프로듀서가 발행한 메시지를 저장하고 이를 컨슈머에 제공합니다. 메시지 복제, 파티션 관리 (아래에서 설명됨) 및 전체 Kafka 클러스터 조정을 담당합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nZookeeper: 카프카 클러스터의 상태를 관리하는 외부 서비스인 Zookeeper. 토픽, 브로커, 소비자 그룹을 추적하여 클러스터 내에서 모든 것이 원활하게 작동하도록 합니다. 조정에 중요하지만, Zookeeper 자체는 실제 데이터 메시지를 저장하지는 않습니다.\n\n이러한 구성 요소는 실시간 데이터 파이프라인을 처리하는 강력하고 확장 가능한 플랫폼으로 함께 작동합니다.\n\n## Kafka는 내구성과 오류 허용을 어떻게 보장하나요? (복제)\n\nKafka는 주로 복제라는 기술을 통해 데이터 내구성과 오류 허용을 보장합니다. 작동 방식은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 토픽 및 파티션: Kafka 토픽은 데이터 스트림의 범주입니다. 내부적으로 각 토픽은 파티션이라고 하는 작은 순서대로 정렬된 세그먼트로 나뉩니다. 이 파티션은 병렬 처리와 확장성을 가능하게 합니다.\n- 복제 팩터: 각 파티션은 Kafka 클러스터 내의 여러 브로커에 걸쳐 복제됩니다. 파티션의 복사본 수는 복제 팩터라는 구성 매개변수에 의해 결정됩니다. 더 높은 복제 팩터는 더 큰 장애 허용성을 보장합니다.\n- 리더와 팔로워: 파티션의 복사본 중 하나의 브로커가 리더로 지정됩니다. 리더는 프로듀서로부터 쓰기를 받아들이고, 이를 다른 복제본인 팔로워에게 복제합니다.\n- 데이터 지속성: 모든 브로커는 데이터(메시지)를 디스크에 지속합니다. 이를 통해 브로커가 실패하더라도 데이터가 손실되지 않습니다. 팔로워는 리더와 파티션 데이터의 동기화를 유지합니다.\n- 리더 장애 및 복구: 리더 브로커가 실패하면 Kafka는 자동으로 리더 선출 프로세스를 트리거합니다. 동기화된 팔로워 중 하나가 새 리더가 되며, 데이터 복제가 계속됩니다. 소비자는 새로운 리더에서 데이터를 최소한의 중단으로 계속 읽을 수 있습니다.\n\n프로듀서 확인: 추가로, Kafka는 내구성 보증에 영향을 주는 프로듀서 확인 설정을 제공합니다:\n\n- acks=all: 이 설정은 최대 내구성을 보장합니다. 프로듀서는 모든 복제본으로부터 확인을 받기 전에 쓰기를 성공으로 간주합니다.\n- acks=1 (기본값): 프로듀서는 리더 복제본만 확인을 받기를 기다립니다. 이는 내구성과 성능 사이의 균형을 제공합니다.\n\n복제 및 확인 전략을 통해 Kafka는 브로커 장애로 인한 데이터 손실을 방지합니다. 브로커가 다운되어도 해당 데이터는 복제본에 유지되어 시스템이 복구하고 운영을 계속할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n카프카의 내결함 허용성에 기여하는 다른 요소들이 있지만, 복제가 핵심 메커니즘입니다.\n\n## 카프카에서 리더 및 팔로워 복제본의 차이점을 설명해주세요.\n\n데이터가 토픽으로 구성되고 확장성을 위해 파티션으로 더 나눠지는 카프카 클러스터에서, 리더 및 팔로워 복제본은 데이터 가용성과 내결함성을 보장하기 위해 중요한 역할을 합니다. 이들 간 주요 차이점은 다음과 같습니다:\n\n리더 복제본:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 책임:\n  - 배정된 파티션에 대한 생산자로부터 쓰기(새 메시지)를 수락합니다.\n  - 받은 메시지를 같은 파티션에 대한 모든 팔로워 레플리카에 복제합니다.\n  - 안전하게 저장되고 소비할 수 있는 메시지의 지점을 나타내는 확정 오프셋을 결정합니다.\n  - 소비자로부터의 읽기 요청을 처리합니다 (일반적으로 소비자는 아래에서 설명하는 동기화된 레플리카 세트와 주로 상호 작용합니다).\n- 선출: 리더는 파티션 내의 레플리카 중에서 선출됩니다. 이 선출은 브로커 시작 시 자동으로, 리더의 실패 시 또는 리더가 심각하게 뒤처지는 경우에 발생합니다.\n\nFollower 레플리카:\n\n- 책임:\n  - 리더로부터 복제된 메시지를 수동으로 소비합니다.\n  - 받은 메시지를 자체 로그에 적용하여 해당 파티션 데이터의 사본을 리더와 동기화 상태로 유지합니다.\n  - 복제가 성공한 경우 리더를 승인합니다.\n- 중요성: 팔로워는 리더의 실패 시 데이터 가용성을 보장하고 중복성을 제공합니다. 리더 선출이 발생할 때 팔로워는 파티션 기능을 유지하기 위해 새 리더가 될 수 있습니다.\n\n## 소비자 그룹이란 무엇이며 어떻게 작동합니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소비자 그룹은 Kafka에서 데이터 스트림의 병렬 처리를 가능하게 하고 각 메시지가 그룹 내 정확히 하나의 소비자에 전달되도록 하는 기본적인 개념입니다. 다음은 그들이 작동하는 방식입니다:\n\n소비자 그룹 지정하기:\n\n- 소비자들은 group.id라는 고유 식별자를 사용하여 그룹화될 수 있습니다. 동일 그룹에 속한 소비자들은 소비자 그룹으로 식별됩니다.\n- 소비자 인스턴스는 구성 중에 그룹 소속을 지정합니다.\n\n부하 분산 및 병렬 처리:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 소비자 그룹이 주제를 구독하면 해당 주제의 파티션은 그룹 내의 소비자들 사이에 자동으로 나눠집니다. 이 분배는 소비자와 파티션의 수에 기반하여 균형을 유지하도록 지능적으로 이루어집니다.\n- 그룹 내 각 소비자는 할당된 파티션에서 메시지를 처리하는 책임이 있습니다. 이 병렬 처리를 통해 소비자 그룹이 대량의 데이터를 효율적으로 처리할 수 있습니다.\n\n소비자 독점성:\n\n- 소비자 그룹의 중요한 측면은 그룹 내 하나의 소비자에게만 메시지가 전달된다는 것입니다. 이를 통해 중복 처리가 방지되고 데이터 일관성이 보장됩니다. Kafka는 각 소비자 그룹에 대한 상태를 유지하고 현재 파티션 할당을 추적함으로써 이를 달성합니다.\n\n소비자 리밸런싱:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 파티션의 분배는 소비자들 사이에서 동적으로 변경될 수 있습니다. 이는 다음과 같은 시나리오에서 발생합니다:\n  - 소비자가 그룹에 가입하거나 나가는 경우.\n  - 브로커의 장애로 인해 파티션 재할당이 필요한 경우.\n  - 카프카가 이러한 상황에서 소비자 리밸런싱이라는 프로세스를 트리거합니다. 리밸런싱은 나머지 소비자들 사이에서 파티션 할당을 재조정하여 균형있는 처리를 유지하는 과정을 말합니다.\n\n소비자 그룹의 장점:\n\n- 병렬 처리: 대용량 데이터 스트림을 효율적으로 처리할 수 있습니다.\n- 확장성: 그룹에서 소비자를 추가하거나 제거함으로써 쉽게 소비자 처리를 확장할 수 있습니다.\n- 내고장성: 소비자가 실패하면 해당 소비자의 파티션이 그룹 내 다른 소비자로 재할당되어 데이터 처리가 계속됩니다.\n- 정확히 한 번 전달 (구성에 따라): 올바르게 구성된 경우, 소비자 그룹은 그룹 내의 각 메시지가 정확히 한 번만 정확히 한 소비자에게 전달되도록 보장할 수 있습니다.\n\n소비자 그룹 사용 사례:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소비자 그룹은 여러 소비자 간에 데이터 처리를 병렬화해야 하는 다양한 시나리오에서 가치가 있습니다. 예를 들어 다음과 같은 경우에 사용됩니다:\n\n- 로그 집계: 여러 소비자가 중앙 주제에서 로그 데이터를 병렬로 처리할 수 있습니다.\n- 스트림 처리: 소비자 그룹은 데이터 스트림을 실시간 분석 작업에 배포하는 데 사용될 수 있습니다.\n- 마이크로서비스 통신: 소비자 그룹은 관련 주제를 구독하고 메시지를 동시에 처리할 수 있도록 허용하여 마이크로서비스 간의 통신을 용이하게 합니다.\n\n## Kafka에서 오프셋이란 무엇이며 어떻게 커밋되는가?\n\nKafka에서 오프셋은 소비자 그룹 또는 각각의 소비자가 토픽 파티션 내에서 진행 상황을 추적하는 포인터 역할을 합니다. 이것들은 본질적으로 각 파티션 내에서 0부터 시작하는 순차적으로 할당된 정수로, 각 메시지에 대한 진행 상황을 나타냅니다. 여기에 오프셋에 대한 더 깊은 내용과 커밋 방법이 나와 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**Offset 이해:**\n\n- 파티션별 추적: 오프셋은 특정한 컨슈머 그룹이나 컨슈머, 그리고 토픽 내 특정 파티션에 대한 것입니다. 이를 통해 각 컨슈머는 읽은 각 파티션에 대해 독립적으로 진행 상황을 추적할 수 있습니다.\n- 소비 재개: 오프셋은 중단 후에 소비를 재개하는 데 중요한 역할을 합니다. 컨슈머가 재시작하거나 그룹에 합류할 때, 지정된 파티션에서 메시지를 읽기 시작할 위치를 결정하기 위해 커밋된 오프셋을 사용합니다. 이를 통해 컨슈머는 이미 처리한 메시지를 다시 처리하지 않게 됩니다.\n\n**오프셋 커밋:**\n\n- 컨슈머 책임: 컨슈머는 주기적으로 오프셋을 커밋하는 책임이 있습니다. 이는 컨슈머가 성공적으로 처리한 마지막 메시지에 대해 Kafka에 알립니다. 오프셋을 커밋하는 다양한 전략이 있으며, 각각의 전략은 메시지 전달 의미론(메시지가 전달되는 방식에 대한 보장)을 가지고 있습니다:\n  - 적어도 한 번: 이것은 기본 설정입니다. 컨슈머는 메시지 처리 후 오프셋을 커밋합니다. 그러나 컨슈머가 오프셋을 커밋하기 전에 충돌하면 메시지가 다시 전달될 수 있어 재시작 시 중복 처리 가능성이 있습니다.\n  - 최대 한 번: 컨슈머는 메시지를 받자마자 오프셋을 커밋합니다. 처리가 실패하면 메시지가 다시 시도되지 않을 수 있어 데이터 손실 가능성이 있습니다.\n  - 정확히 한 번 (트랜잭션): 이것은 가장 복잡하지만 각 메시지가 정확히 한 번 전달 및 처리됨을 보장합니다. Kafka 트랜잭션과 Kafka Streams API를 사용해야 합니다.\n- 오프셋 커밋 과정: 일반적으로 컨슈머는 Kafka가 유지하는 \"\\_\\_consumer_offsets\"라는 특별한 내부 토픽에 오프셋을 커밋합니다. 이 토픽은 모든 컨슈머 그룹과 파티션에 대한 커밋된 오프셋을 저장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오프셋을 커밋하는 중요성:\n\n- 진행 상황 추적: 커밋된 오프셋을 통해 소비자는 장애 또는 재시작 후 올바른 지점에서 처리를 계속할 수 있습니다.\n- 중복 방지 (at-least-once와 함께): at-least-once 전략을 사용하여 정기적으로 커밋하면 이미 소비자가 처리한 메시지의 재처리를 방지할 수 있습니다.\n\n오프셋 커밋 전략 선택:\n\n오프셋 커밋 전략의 선택은 응용 프로그램의 요구 사항에 따라 달라집니다. 데이터 손실이 절대 허용되지 않는 경우, 정확히 한 번의 전달이 필요하며 (더 복잡하지만) 구현해야 합니다. 어느 정도의 메시지 중복은 허용되는 경우, at-least-once 전략이 더 간단한 접근 방식입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Kafka가 높은 처리량과 낮은 지연 시간을 어떻게 달성하는가?\n\nKafka는 설계 선택과 기술의 조합을 통해 높은 처리량과 낮은 지연 시간을 달성합니다. 여기에 중요한 요소 몇 가지가 있습니다:\n\n확장성과 병렬성:\n\n- 분산 아키텍처: Kafka의 분산 아키텍처는 클러스터 내 여러 브로커에 부하를 분산시켜 대규모 데이터 양을 처리할 수 있도록 합니다. 이를 통해 필요에 따라 더 많은 머신을 추가함으로써 수평 확장이 가능합니다.\n- 분할: Kafka의 주제는 파티션이라는 더 작은 단위로 나누어집니다. 프로듀서는 이러한 파티션에 병렬로 메시지를 발행할 수 있으며, 이는 전체 처리량을 향상시킵니다. 소비자는 할당된 파티션에서 메시지를 동시에 소비함으로써 처리를 병렬화할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n효율적인 데이터 저장 및 액세스:\n\n- Append-only Logs(추가 전용 로그): 데이터는 각 브로커의 추가 전용 로그에 저장됩니다. 이렇게 하면 쓰기 작업이 간소화되고 무작위 디스크 액세스의 부하를 피할 수 있습니다. 새로운 데이터가 로그의 끝에 씌여지기 때문에 효율적으로 액세스할 수 있습니다.\n- 배칭: 프로듀서는 여러 메시지를 브로커로 보내기 전에 함께 배칭할 수 있습니다. 이렇게 하면 네트워크 왕복 횟수가 줄어들고 데이터 전송의 효율성이 향상됩니다.\n- Zero-Copy 처리: 가능한 경우에는 Kafka가 불필요한 데이터 복사를 피하기 위한 zero-copy 기술을 활용합니다. 이렇게 하면 CPU 부하가 줄어들고 처리 속도가 향상됩니다.\n- OS 기능 활용: Kafka는 Linux 페이지 캐시를 활용하여 자주 액세스되는 데이터를 메모리에 저장함으로써 디스크 I/O를 줄이고 소비자가 더 빠르게 메시지를 검색할 수 있도록 합니다.\n\n분리된 통신:\n\n- 프로듀서 및 소비자: 프로듀서와 소비자는 독립적으로 작동합니다. 프로듀서는 소비자가 구독한 것을 알 필요 없이 주제에 메시지를 발행합니다. 이 분리는 프로듀서가 소비자 확인을 기다리지 않기 때문에 전체 대기 시간이 줄어듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비동기 통신:\n\n- 생산자, 중개업자 및 소비자간의 통신은 비동기적으로 이루어집니다. 이는 생산자가 중개업자가 수신 확인을 기다리는 동안 블록되지 않고, 소비자가 새 메시지를 기다리는 동안 블록되지 않음을 의미합니다. 이는 전반적으로 응답성을 향상시킵니다.\n\n소비자 중심 최적화:\n\n- 미리 가져오기: 소비자는 로컬 버퍼로 구성된 메시지를 사전에 가져올 수 있습니다. 이는 후속 메시지 가져오기의 지연 시간을 줄이며 데이터가 메모리에 이미 사용 가능하게 함.\n- 효율적인 소비자 그룹 관리: 소비자 그룹은 다시 조정 알고리즘을 활용하여 파티션을 효율적으로 소비자들 사이에 분배합니다. 이로써 균형 잡힌 부하 및 전반적인 처리 시간을 줄입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Kafka의 실제 사용 사례는 무엇인가요? (로그 집계, 마이크로서비스 통신)\n\n아파치 카프카의 실제 사용 사례 중 일부를 살펴보면, 실시간 데이터 파이프라인을 처리하는 능력을 강조할 수 있습니다:\n\n로그 집계 및 모니터링:\n\n- Kafka는 다양한 분산 애플리케이션, 서비스 및 마이크로서비스에서 로그를 수집하는 데 뛰어납니다. 이러한 로그는 Kafka의 특정 토픽으로 스트림으로 발행됩니다.\n- 중앙 집계된 로그를 사용하면 애플리케이션의 실시간 분석, 문제 해결 및 성능 모니터링이 가능해집니다. ELK 스택(Elasticsearch, Logstash, Kibana)과 같은 도구를 Kafka와 통합하여 로그 데이터를 소비하고 시각화하여 더 깊은 인사이트를 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마이크로서비스 통신:\n\n- 카프카는 마이크로서비스 아키텍처의 중추신경계 역할을 합니다. 마이크로서비스는 이벤트나 데이터 업데이트를 카프카의 관련 토픽에 발행할 수 있습니다.\n- 다른 마이크로서비스는 이러한 토픽을 구독하고 발행된 이벤트에 반응하여 서비스 간에 비동기적이고 느슨하게 결합된 통신을 가능케 합니다. 이는 마이크로서비스 배포에서 확장성과 유연성을 증진시킵니다.\n\n스트림 처리와 분석:\n\n- 카프카는 대량 데이터 스트림을 처리할 수 있는 능력으로 실시간 분석 애플리케이션에 이상적입니다.\n- 아파치 플링크나 아파치 스파크 스트리밍과 같은 스트림 처리 프레임워크를 카프카와 통합하여 토픽에서 데이터 스트림을 소비하고 실시간 연산, 필터링 또는 변환을 수행할 수 있습니다.\n- 이를 통해 애플리케이션은 사기 탐지, 이상 분석 또는 추천 엔진을 위한 실시간 데이터 통찰에 반응할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIoT 데이터 수집 및 처리:\n\n- 사물 인터넷(IoT) 영역에서 Kafka는 센서와 장치가 생성하는 대량 및 고속의 데이터를 효율적으로 처리할 수 있습니다.\n- 센서 데이터는 메시지로 Kafka 토픽에 발행될 수 있어 이 데이터의 실시간 처리, 집계 및 분석이 가능합니다.\n- 이는 예측 현상 유지, 원격 모니터링 또는 IoT 센서 데이터의 실시간 시각화에 활용될 수 있습니다.\n\n이벤트 소싱:\n\n- Kafka는 마이크로서비스 및 응용 프로그램을 위한 중앙 이벤트 저장소로 사용될 수 있습니다. 상태 변경 또는 작업을 나타내는 이벤트는 Kafka 토픽에 메시지로 발행됩니다.\n- 이 이벤트 로그는 분산 시스템에서 언제든지 응용 프로그램 상태를 재구성하거나 최종 일관성 패턴을 구현하는 데 사용될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**실시간 사기 탐지:**\n\n- 카프카의 고 처리량과 낮은 지연 시간은 실시간 사기 탐지 시스템을 구축하기에 적합합니다.\n- 거래 데이터는 카프카 토픽으로 스트리밍될 수 있으며, 스트림 처리 응용 프로그램은이 데이터를 실시간으로 분석하여 의심스러운 패턴이나 잠재적인 사기 활동을 식별할 수 있습니다.\n\n이것들은 몇 가지 예시일 뿐이며, 카프카의 사용 사례는 기업이 실시간 데이터 파이프라인 및 응용 프로그램을 위한 능력을 활용함에 따라 계속 발전하고 있습니다.\n\n## 카프카 소비자가 뒤처지는 상황을 어떻게 처리하시겠어요? (소비자 리밸런싱, 구성 조정)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n카프카 소비자가 생산자를 따라잡지 못하고 메시지 처리에서 뒤처지기 시작하는 상황을 해결하는 방법을 다음과 같이 제시해 드립니다.\n\n원인 파악하기:\n\n- 소비자 랙 관찰: 먼저, 카프카 소비자 모니터링 도구나 내장된 소비자 그룹 랙 정보를 활용하여 어떤 소비자 그룹과 파티션이 랙을 겪고 있는지 식별해 보세요.\n- 소비자 성능 분석: 문제가 되는 소비자의 성능 메트릭스인 CPU, 메모리 사용량 및 처리 시간을 조사하여 소비자 애플리케이션 자체에서 발생하는 잠재적인 병목 현상을 파악해 보세요.\n\n소비자 측 해결책:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 소비자 코드 최적화: 소비자 코드를 검토하고 개선할 부분을 식별합니다. 이 작업에는 다음이 포함될 수 있습니다:\n  - 메시지 처리 논리를 최적화하여 메시지당 처리 시간을 줄입니다.\n  - 여러 메시지를 한꺼번에 처리하기 위해 메시지 처리를 일괄 처리합니다.\n- 소비자 병렬화 증가: 소비자 응용 프로그램이 처리할 수 있다면, 소비자 그룹 내의 소비자 인스턴스 수를 증가시키는 것을 고려해보세요. 이렇게 하면 작업이 분산되어 뒤처진 작업을 처리할 수 있습니다.\n- 소비자 페치 크기 조정: 소비자 페치 크기는 각 요청에서 브로커로부터 검색되는 데이터 양을 제어합니다. 페치 크기를 늘림으로써(합리적인 한계 내에서) 처리량을 향상시키고 지연을 줄일 수 있습니다.\n\n카프카 구성 조정:\n\n- 소비자 리밸런스: 소비자 그룹 내에서 부분적으로 파티션이 분산되어 지연이 발생하는 경우, Kafka 소비자 그룹 관리 도구를 사용하여 소비자 리밸런스를 수동으로 트리거할 수 있습니다. 이렇게 하면 파티션이 소비자 사이에서 재분배되어 과도하게 작업이 부담스럽게 된 소비자의 지연이 완화될 수 있습니다.\n- 오토 오프셋 리셋: 극단적인 경우, 지연되는 파티션용으로 소비자 오프셋을 재설정해야 할 수도 있습니다. 그러나 이 접근 방식은 메시지 중복 (at-least-once 의미론)이나 데이터 손실 (at-most-once 의미론)로 이어질 수 있으므로 신중하게 사용해야 합니다.\n\n## 카프카에서 한 소비자로 중복 메시지 소비 방지하기를 선택하는 방법?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정확히 한 번만 메시지가 전달되고 소비자에 의해 한 번만 처리되는 정확히 한 번의 의미를 달성하려면 Apache Kafka에서는 적어도 한 번 또는 최대 한 번 전달보다 더 많은 노력이 필요합니다. Kafka에서 단일 소비자에 의한 중복 처리를 피하기 위한 두 가지 주요 방법은 다음과 같습니다:\n\n- Kafka Streams API를 사용한 트랜잭션 소비자:\n\n- 이것은 정확히 한 번의 처리 보장을 위한 추천 접근 방식입니다. Kafka Streams는 Kafka Consumer를 기반으로 구축된 고수준 API로 스트림 처리 작업을 간단화합니다.\n- 이는 Kafka 트랜잭션을 활용하여 프로듀서에 의한 메시지 쓰기와 소비자의 오프셋 커밋을 원자적 단위로 처리합니다. 쓰기 또는 커밋 중 하나가 실패하면 전체 트랜잭션이 롤백되어 부분 처리와 잠재적인 중복을 방지합니다.\n\n프로세스의 분해는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 소비자는 메시지를 소비하기 전에 Kafka 트랜잭션을 시작합니다.\n- 소비자는 메시지를 처리하고 필요한 작업을 수행합니다.\n- 처리가 성공하면, 소비자는 트랜잭션 내에서 오프셋을 커밋합니다.\n- Kafka는 트랜잭션 내의 모든 작업이 성공하거나 모두 실패하도록 보장하여 중복을 방지합니다.\n- 기억해둘 중요한 점들:\n- 이 접근 방식은 메시지 소비를 위해 Kafka Streams API를 사용해야 합니다.\n- 한 번만 적용되는 의미론은 생산자 측의 트랜잭션 기능이 필요합니다.\n\n2. 수동 오프셋 관리를 통한 멱등성:\n\n- 이 방법은 소비자 응용 프로그램 내에서 멱등성을 구현하고 오프셋을 수동으로 관리하는 것을 포함합니다. 멱등성은 의도하지 않은 부작용 없이 작업을 여러 번 반복할 수 있음을 보장합니다.\n\n여기에 일반적인 아이디어가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 사용자는 받은 각 메시지에 고유 식별자(동질성 키)를 할당합니다.\n- 메시지를 처리하기 전에 사용자는 동일한 동질성 키를 가진 메시지를 이미 처리했는지 확인합니다. 이를 위해 처리된 키를 데이터베이스나 분산 캐시에 저장하여 확인할 수 있습니다.\n- 메시지가 새로운 경우(고유 키), 사용자는 처리하고 나중을 위해 키를 저장합니다.\n- 메시지가 중복인 경우(키가 이미 존재), 사용자는 더 이상 처리하지 않고 삭제합니다.\n- 성공적인 처리 후에 사용자는 오프셋을 커밋합니다.\n\n고려해야 할 주요 사항:\n\n- 동질성 논리를 구현하는 것은 사용자 애플리케이션에 복잡성을 추가합니다.\n- 동질성 키를 저장하고 관리하기 위한 적합한 메커니즘을 선택해야 합니다.\n- 수동으로 오프셋을 커밋하면 데이터 손실이나 중복을 피하기 위해 신중히 처리해야 합니다.\n\n적절한 방법 선택하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 트랜잭션 소비자(카프카 스트림 API)는 간단하고 정확히 한 번 배송이 보장되는 접근 방식으로 일반적으로 권장됩니다.\n- 수동 오프셋 관리와 이덤포턴스는 대안일 수 있지만, 이의 효율을 위해서 더 많은 개발 노력이 필요하며, 이덤포턴시 키 및 오프셋을 관리하는 데 잠재적인 복잡성을 도입할 수 있습니다.\n\n## 동일한 메시지를 다른 컨슘어에서 듣지 않도록 어떻게 보장할까요?\n\n기본적으로, 컨슈머 그룹 내의 카프카 컨슈머는 동일한 메시지를 듣지 않습니다. 카프카는 이를 컨슈머 그룹과 오프셋 관리라는 개념을 통해 실현합니다. 작동 방식은 다음과 같습니다:\n\n컨슈머 그룹:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 소비자는 \"group.id\"라는 고유 식별자를 사용하여 그룹화될 수 있습니다. 동일한 그룹에 속하는 모든 소비자는 소비자 그룹을 형성합니다.\n- 각 소비자 인스턴스는 구성 중에 해당하는 그룹 소속을 지정합니다.\n\n파티션 및 오프셋 추적:\n\n- Kafka의 토픽은 파티션이라는 작은 단위로 분할됩니다.\n- 각 소비자 그룹은 가입한 각 파티션에 대한 오프셋 기록을 유지합니다. 오프셋은 파티션 내 메시지의 고유 식별자로, 본질적으로 0부터 시작하는 카운터입니다.\n- 소비자 그룹이 토픽을 구독하면 Kafka는 파티션을 그룹의 소비자들 사이에 분산시키기 위해 소비자 리밸런싱을 수행합니다. 이를 통해 고률한 부하 분산이 보장됩니다.\n\n독점 청취:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 각 주제 내의 각 파티션은 한 번에 그룹 내의 하나의 소비자에게 할당됩니다. 이는 그룹 내에서 중복 처리를 방지합니다.\n- 소비자가 메시지를 처리하는 동안 주기적으로 오프셋을 커밋합니다. 이를 통해 Kafka에게 각 파티션의 마지막으로 성공적으로 처리한 메시지를 알립니다.\n\n장점:\n\n- 중복 방지: 파티션을 배정하고 오프셋을 추적함으로써 Kafka는 각 메시지가 그룹 내의 하나의 소비자에게만 전달되도록 보장하여 중복 처리를 방지합니다.\n- 확장성: 그룹에서 소비자를 추가하거나 제거하여 소비자 처리를 쉽게 확장할 수 있습니다. Kafka는 파티션을 자동으로 리밸런싱하여 균형 잡힌 부하를 유지합니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 명의 소비자(소비자 A 및 소비자 B)가 3개 파티션을 가진 주제에 가입한 소비자 그룹을 상상해보세요. Kafka는 파티션을 다음과 같이 분배할 수 있습니다:\n\n- 소비자 A: 파티션 0 및 1 수신\n- 소비자 B: 파티션 2 수신\n\n이렇게 함으로써 각 메시지가 그룹 내 하나의 소비자에게만 전달됩니다.\n\n중요 참고사항:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n카프카는 소비자 그룹 내에서 중복 처리를 방지하지만, 동일한 주제에 두 개의 소비자 그룹이 모두 구독되어 있다면 메시지가 여러 소비자 그룹으로 전달될 수 있습니다. 소비자 그룹에 관계없이 메시지가 한 번만 처리되도록 보장해야 한다면, 이벤트 중복성과 같은 기술을 활용하여 소비자 내에서 추가 로직을 구현해야 합니다 (이전 질문에 다루어졌습니다).\n\n## 소비자 측의 장애 복구 방법\n\n카프카에서 소비자 측의 장애를 복구하는 것은 데이터 손실 없이 메시지 처리가 원활하게 계속되도록 보장하기 위해 몇 가지 주요 전략을 활용해야 합니다. 다음은 취할 수 있는 접근 방법에 대한 설명입니다:\n\n1. 카프카 오프셋 커밋과 소비자 리발란싱 활용하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 오프셋 커밋: 카프카는 소비자 측 오프셋 커밋을 활용하여 진행 상황을 추적합니다. 소비자들은 주기적으로 오프셋을 커밋하여 구독 중인 각 파티션에서 마지막으로 성공적으로 처리한 메시지를 나타냅니다.\n- 소비자 리밸런싱: 소비자가 실패하거나 새로운 소비자가 그룹에 가입하면, 카프카는 소비자 리밸런싱을 트리거합니다. 이 과정은 나머지 소비자들 사이에서 파티션을 재분배합니다.\n\n복구 프로세스:\n\n- 다시 시작할 때, 실패한 소비자는 이전에 책임지고 있던 파티션에 대한 커밋된 오프셋을 검색합니다.\n- 카프카는 해당 파티션을 다시 소비자에게 할당하여 리밸런싱 동안 (같은 소비자 그룹에 다시 가입할 경우) 이어서 처리합니다.\n- 소비자는 커밋된 오프셋에서 메시지 처리를 계속하며, 장애로 인한 데이터 손실이 발생하지 않도록 합니다.\n\n2. 소비자에서 오류 처리 및 재시도 구현:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 에러 처리: 소비자 애플리케이션에서 예외나 처리 실패를 감지하기 위한 견고한 에러 처리 메커니즘을 갖추는 것이 중요합니다.\n- 재시도 논리: 에러가 발생할 때 소비자는 메시지 처리를 다시 시도하는 재시도 논리를 구현해야 합니다. 이는 일시적 에러의 경우 브로커를 과도하게 사용하지 않도록 백오프 전략을 사용하여 재시도하는 것을 포함할 수 있습니다.\n- 데드 레터 큐 (선택 사항): 중요한 메시지나 지속적인 오류의 경우 데드 레터 큐 (DLQ)를 구현해야 합니다. 실패한 메시지는 DLQ로 전송되어 수동 개입이나 후속 처리 시도가 가능합니다.\n\n3. 카프카 컨슈머 오프셋 관리 도구 활용:\n\n- 카프카는 컨슈머 오프셋을 수동으로 관리하기 위한 도구와 API를 제공합니다. 이는 특정 시나리오에서 유용할 수 있습니다:\n- 오프셋 재설정: 극도의 경우에는 컨슈머 그룹이나 특정 파티션의 오프셋을 수동으로 재설정해야 할 수 있습니다. 그러나 이를 신중하게 사용해야 하며, 이로 인해 메시지 중복(at-least-once 의미론)이나 데이터 손실(at-most-once 의미론)이 발생할 수 있습니다.\n- 컨슈머 일시 중지/재개: 유지보수나 디버깅 목적으로 일시적으로 컨슈머나 컨슈머 그룹을 일시 중지할 수 있는 도구를 사용할 수 있습니다. 이를 통해 메시지 전달과 오프셋 관리를 제어할 수 있습니다.\n\n4. 올바른 오프셋 커밋 전략 선택:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Kafka의 기본 옵셋 커밋 전략은 적어도 한 번은 입니다. 이는 메시지가 최소한 한 번은 전달되도록 보장하지만, 소비자가 오프셋을 커밋하기 전에 실패할 경우 중복이 발생할 수 있습니다.\n- 더 엄격한 전달 보증을 위해 Kafka Transactions 및 Kafka Streams API를 사용하여 정확히 한 번만 전달되는 의미론을 고려하십시오. 이 방식은 각 메시지가 한 번만 전달되고 처리되도록 보장하지만, 더 복잡한 구성 및 개발 노력이 필요합니다.\n\n## 스프링 부트 앱에서 Kafka 구성하는 방법은?\n\n- Kafka 종속성 추가:\n\n필요한 Kafka 종속성을 pom.xml(Maven용)이나 build.gradle(Gradle용) 파일에 추가하십시오. Spring Boot은 핵심 Kafka 종속성이 포함된 편리한 spring-kafka 스타터를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n  \u003cartifactId\u003espring-boot-starter-kafka\u003c/artifactId\u003e\n\u003c/dependency\u003e\n```\n\n2. Kafka 속성 구성하기:\n\nSpring Boot는 application.yml 또는 application.properties와 같은 애플리케이션 프로퍼티 파일을 사용하여 Kafka 속성을 편리하게 구성할 수 있는 방법을 제공합니다. 여기에 몇 가지 중요한 속성이 있습니다:\n\n- spring.kafka.bootstrap-servers: 이 속성은 Kafka 브로커 주소의 쉼표로 구분된 목록을 지정합니다.\n- spring.kafka.consumer.group-id: 이 속성은 응용 프로그램의 소비자 그룹 ID를 정의합니다. 동일한 그룹 ID로 동일한 주제에 구독된 소비자는 소비자 그룹을 형성하고 메시지를 효율적으로 병렬 처리합니다.\n- spring.kafka.producer.key-serializer: 이 속성은 응용 프로그램에서 생성한 메시지 키의 직렬화에 사용되는 직렬화기를 지정합니다. 기본적으로 StringSerializer가 사용됩니다. JSON 키의 경우와 같이 메시지 키 데이터 유형에 따라 다른 직렬화기를 선택할 수 있습니다 (예: JSON 키의 경우의 경우 JsonSerializer).\n- spring.kafka.producer.value-serializer: 이 속성은 응용 프로그램에서 생성한 메시지 값의 직렬화에 사용되는 직렬화기를 정의합니다. 키 직렬화기와 유사하게, 메시지 값 데이터 유형에 따라 적절한 직렬화기를 선택하세요.\n- (선택 사항) spring.kafka.consumer.auto-offset-reset: 이 속성은 소비자 그룹이 리밸런스되거나 장애 발생 후 다시 시작할 때 소비자 오프셋이 어떻게 처리되는지를 제어합니다. 기본값은 earliest로, 이는 소비자가 파티션의 처음부터 읽기를 시작함을 의미합니다. 최신 메시지부터 읽기를 시작하려면 latest로 설정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. Kafka 프로듀서와 컨슈머 생성하기:\n\n- 스프링 부트는 Kafka 프로듀서와 컨슈머를 위한 추상화를 제공합니다. @Autowired를 사용하여 주입하고 Kafka 토픽과 상호 작용하는 데 사용할 수 있습니다:\n\n```java\n@SpringBootApplication\npublic class MyKafkaApp {\n\n    @Autowired\n    private KafkaTemplate\u003cString, String\u003e kafkaTemplate;\n\n    public void sendMessage(String topic, String message) {\n        kafkaTemplate.send(topic, message);\n    }\n\n    @KafkaListener(topics = \"myTopic\")\n    public void receiveMessage(String message) {\n        // 받은 메시지 처리\n    }\n\n    // ... (다른 애플리케이션 로직)\n}\n```\n\n## Kafka 작업 시 개발자들이 자주 하는 일반적인 실수는 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정 및 사용에 대한 오류:\n\n- 소비자 그룹 이해 부족: 소비자 그룹의 개념과 그들이 작업 부하를 어떻게 분산시키는지를 이해하지 못하면 비효율적인 처리나 중복된 메시지가 발생할 수 있습니다.\n- 올바르지 않은 오프셋 커밋 전략: 적절하지 않은 오프셋 커밋 전략(적어도 한 번, 최대 한 번 또는 정확히 한 번)을 선택하면 데이터 손실이나 메시지 중복이 발생할 수 있습니다.\n- 적절하지 않은 직렬화기 선택: 메시지 키와 값의 데이터 유형에 맞는 적합한 직렬화기/역직렬화기를 선택하지 않으면 직렬화 오류나 예기치 않은 동작이 발생할 수 있습니다.\n- 불필요한 수동 오프셋 관리: 수동으로 오프셋을 관리하는 것은 오류가 발생하기 쉽고 복잡할 수 있습니다. 가능한 경우 카프카의 자동 오프셋 관리를 활용하십시오.\n\n성능 및 확장성 문제:\n\n- 파티셔닝 무시: 주제 파티셔닝을 효과적으로 활용하지 않으면 모든 그룹의 소비자가 단일 파티션에서 읽기 때문에 성능 병목이 발생할 수 있습니다.\n- 충분하지 않은 소비자 병렬성: 그룹 내 소비자가 너무 적으면 처리 지연이 발생할 수 있으며, 특히 대용량 데이터 스트림의 경우에는 더욱 그렇습니다.\n- 비효율적인 소비자 코드: 최적화되지 않은 소비자 코드는 메시지 처리 속도를 늦추고 전반적인 처리량을 저해할 수 있습니다.\n- 소비자 랙 모니터링 미흡: 소비자 랙을 모니터링하지 않으면 잠재적인 병목 현상이나 부하 분배의 불균형에 대해 알지 못할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발 및 오류 처리:\n\n- 정확히 한 번만 Guarantee 무시: 귀하의 애플리케이션이 엄격한 데이터 일관성을 필요로 하는 경우, Kafka Streams 및 트랜잭션을 사용하여 정확히 한 번 전달 보장을 무시하면 데이터 불일치가 발생할 수 있습니다.\n- 부족한 오류 처리: 생산자와 소비자의 견고한 오류 처리 메커니즘을 구현하지 않으면 응용 프로그램이 예외와 데이터 손실에 취약해질 수 있습니다.\n- 테스트 부족: 특히 오류 시나리오에서 적절한 테스트를 누락하면 Kafka 응용 프로그램의 오류 처리 및 복구 프로세스의 약점이 드러날 수 있습니다.\n\nKafka 대체 제품 및 비교:\n\n메시지 스트리밍 세계에서 Kafka가 우세한 플레이어이지만 귀하의 특정 요구 사항에 따라 고려할 수 있는 다른 옵션도 있습니다. 여기에는 Kafka와 두 가지 인기 있는 대체 제품인 RabbitMQ 및 Apache Pulsar의 비교가 포함됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRabbitMQ:\n\n- 초점: RabbitMQ는 사용하기 쉽고 유연성으로 유명한 가벼운 메시지 브로커입니다. 메시지 라우팅 및 발행/구독, RPC(원격 프로시저 호출), 팬아웃과 같은 메시지 교환 패턴에서 우수한 성과를 내며, 애플리케이션 간 유연한 통신을 지원합니다.\n\n장점:\n\n- 간단함: 간단하게 설정하고 관리하고 사용할 수 있어 복잡하지 않은 메시지 전달 요구에 적합합니다.\n- 가벼움: Kafka와 비교했을 때 더 작은 풋프린트로 리소스가 제한된 환경에 이상적입니다.\n- 유연성: 다양한 메시지 교환 패턴을 지원하여 다양한 통신 시나리오에 적합합니다.\n- 성숙하고 안정적인: 큰 커뮤니티와 포괄적인 실전 테스트로 지탱되어 안정성이 뛰어납니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n약점:\n\n- 확장성: Kafka보다 수평적으로 확장하는 데 있어서 극도로 높은 메시지 양을 다루는 데 비교적 부족할 수 있습니다.\n- 처리량: 아키텍처로 인해 매우 높은 처리량 데이터 스트림에서 고난을 겪을 수 있습니다.\n- 제한된 스트림 처리: Kafka Streams나 Pulsar Functions과 비교하여 내장된 스트림 처리 기능이 부족합니다.\n- 사용 사례:\n- 작업 대기열: RabbitMQ는 작업 대기열을 관리하고 애플리케이션에서 백그라운드 작업을 트리거하는 데 적합합니다.\n- 마이크로서비스 통신: RabbitMQ는 마이크로서비스 간 가벼운 통신 및 데이터 교환에 사용될 수 있습니다.\n- 통합: RabbitMQ는 서로 다른 응용 프로그램 및 시스템 간 통합을 구현하는 데 좋은 선택입니다.\n\nApache Pulsar:\n\n- 초점: Pulsar는 상대적으로 새로운 오픈 소스 메시지 스트리밍 플랫폼으로 고성능, 확장성 및 낮은 지연 시간을 위해 설계되었습니다. Kafka와 유사한 기능을 제공하지만 멀티테넌시와 지리적 복제에 중점을 둡니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 고성능: 높은 처리량 및 낮은 지연 시간을 지원하여 요구되는 실시간 데이터 파이프라인에 적합합니다.\n- 확장성: 대용량 데이터 처리를 위해 수평적으로 높은 확장성을 제공합니다.\n- 다중 테넌시(Multi-tenancy): 단일 Pulsar 클러스터를 다중 테넌트 또는 조직간에 안전하게 공유할 수 있습니다.\n- 지역 복제(Geo-replication): 지리적으로 분산된 지역 간 데이터 복제를 지원하여 재해 복구 및 글로벌 배포를 가능하게 합니다.\n- 스트림 처리(Stream Processing): Kafka Streams와 유사한 내장형 스트림 처리 기능을 제공하여 플랫폼 내에서 데이터 변환 및 분석이 가능합니다.\n\n단점:\n\n- 성숙도: Kafka의 확립된 생태계와 비교할 때, Pulsar는 비교적 신생 프로젝트로 생태계 및 툴 통합이 덜 성숙할 수 있습니다.\n- 복잡성: 고급 기능으로 인해 Kafka보다 설정 및 관리가 다소 복잡할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 사례:\n\n- 실시간 분석: 고 처리량과 낮은 지연 시간으로, Pulsar는 실시간 분석 파이프라인을 구축하는 데 좋은 선택지입니다.\n- IoT 데이터 스트리밍: Pulsar는 IoT 장치에서 생성된 대량 및 고속 데이터를 효율적으로 처리할 수 있습니다.\n- 클라우드 네이티브 배포: 다중 테넌시와 지오-레플리케이션 기능을 갖춘 Pulsar는 클라우드 네이티브 배포에 적합합니다.\n\n적절한 도구 선택:\n\nKafka, RabbitMQ 및 Pulsar 중에서 최상의 선택을 하려면 특정 요구 사항을 고려해야 합니다. 다음은 간략한 가이드라인입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 간단한 메시지 라우팅 및 가벼운 통신에는 RabbitMQ를 사용하세요.\n- 고 처리량과 낮은 지연 시간, 확장성을 갖춘 스트리밍에는 Kafka 또는 Pulsar를 사용하세요.\n- 멀티 테넌시, 지오 레플리케이션, 그리고 클라우드 네이티브 배포에는 Pulsar를 사용하세요.\n- 기존의 Kafka 생태계와 성숙한 도구를 활용하기 위해서는 Kafka를 사용하세요.\n\n더 많은 구성 옵션, 고급 기능, 그리고 Spring Boot를 활용한 Kafka 애플리케이션 구축을 위한 모범 사례에 대해 알아보려면 Spring Kafka 문서(https://spring.io/projects/spring-kafka)를 참고하세요.\n\n여기까지 읽어 주셔서 감사합니다. 여기에서 모두를 도울 수 있는 실제 Kafka 질문들을 공유할 수 있는 코멘트 섹션에서 스레드를 만들어 볼까요?\n\n# 읽어 주셔서 감사합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 👏 이야기에 박수를 보내 주시고 저를 팔로우하세요 👉\n- 📰 제 Medium 페이지에서 더 많은 콘텐츠를 읽어보세요 (Java 개발자 면접을 위한 60개의 이야기)\n\n제 책은 여기서 찾아볼 수 있어요:\n\n- 아마존에서 Guide To Clear Java Developer Interview (킨들 북) 또는 Gumroad( PDF 형식)을 확인하세요.\n- Gumroad( PDF 형식) 또는 아마존(킨들 전자책)에서 Guide To Clear Spring-Boot Microservice Interview를 확인하세요.\n- 🔔 팔로우해 주세요: LinkedIn | Twitter | Youtube\n","ogImage":{"url":"/assets/img/2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024_0.png"},"coverImage":"/assets/img/2024-05-23-KafkaInterviewQuestionforexperiencedJavadeveloperin2024_0.png","tag":["Tech"],"readingTime":32},{"title":"안드로이드 개발 입문자를 위한 가이드 첫 앱 만들기 시작하기","description":"","date":"2024-05-23 12:56","slug":"2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp","content":"\n\u003cimg src=\"/assets/img/2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp_0.png\" /\u003e\n\n안드로이드 앱을 만들고 싶지만 시작할 방법을 모르시나요? 모바일 애플리케이션에 대한 수요가 증가함에 따라 안드로이드 개발은 가치 있는 기술이 되었습니다. 특정 문제를 해결하기 위한 도구를 만들거나 앱 개발 분야로 뛰어들기를 원한다면, 이 초심자를 위한 가이드는 안드로이드 개발을 시작하는 데 필수적인 단계를 안내해줍니다.\n\n# 설정하기\n\n코딩을 시작하기 전에 개발 환경을 설정해야 합니다. 다음은 필요한 기본 도구입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Android Studio: 안드로이드 앱 개발을 위한 공식 통합 개발 환경(IDE)입니다. 안드로이드 앱 빌드 및 디버깅을 위한 포괄적인 도구 세트를 제공합니다.\n- Java 또는 Kotlin: 안드로이드 앱은 주로 Java 또는 Kotlin 프로그래밍 언어를 사용하여 개발됩니다. Java는 전통적으로 안드로이드 개발에 사용되었지만, Kotlin은 간결한 구문과 향상된 기능으로 인해 인기를 얻고 있습니다.\n- SDK 관리자: 안드로이드 스튜디오에는 내장된 SDK 관리자가 있어서 필요한 안드로이드 SDK 구성 요소와 시스템 이미지를 다운로드하여 다양한 장치 및 안드로이드 버전에서 앱을 테스트할 수 있습니다.\n\n# 기본 개념 이해하기\n\n## 1. 활동(Activity):\n\n안드로이드에서 활동(Activity)은 사용자 인터페이스를 가진 단일 화면을 나타냅니다. 활동은 안드로이드 앱의 구성 요소이며, 각 활동은 Activity 클래스의 하위 클래스로 구현됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 레이아웃:\n\n레이아웃은 앱의 사용자 인터페이스 구조를 정의합니다. Android는 LinearLayout, RelativeLayout 및 ConstraintLayout과 같은 다양한 레이아웃 유형을 제공하여 화면에 UI 구성 요소를 배열하는 데 도움을 줍니다.\n\n## 3. 뷰:\n\n뷰는 화면에 표시되는 UI 구성 요소로, 버튼, 텍스트 필드 및 이미지와 같은 요소입니다. 각 뷰는 View 클래스의 서브클래스의 인스턴스이며 XML 속성 또는 프로그래밍적으로 외관과 동작을 사용자 정의할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 첫 번째 앱 만들기\n\n안드로이드 개발의 주요 개념에 대한 기본적인 이해를 얻었으니, 시작하기 위해 간단한 \"Hello World\" 앱을 만들어 보겠습니다.\n\n## 단계 1: 새 프로젝트 생성\n\nAndroid Studio를 열고 환영 화면에서 \"새 Android Studio 프로젝트 시작\"을 선택합니다. 프로젝트 템플릿 선택, 앱의 이름과 패키지 이름 설정, 최소 SDK 버전 선택 등의 프로젝트 설정을 구성하는 안내에 따릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2: 사용자 인터페이스 디자인\n\n프로젝트를 설정하면 Android Studio의 레이아웃 편집기를 사용하여 앱의 사용자 인터페이스를 디자인할 수 있습니다. 팔레트에서 UI 구성요소를 끌어다가 디자인 캔버스에 놓고, 속성 패널을 사용하여 속성을 사용자 정의할 수 있습니다.\n\n\"Hello World\" 앱의 경우, 환영 메시지를 표시하기 위해 TextView 구성요소를 추가할 수 있습니다.\n\n## 단계 3: 코드 작성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 앱의 기능을 구현하는 코드를 작성해야 합니다. 주요 활동 파일 (MainActivity.java 또는 MainActivity.kt)을 열고 다음 코드를 추가하여 앱이 시작될 때 \"Hello World\" 메시지를 표시하십시오:\n\n## 단계 4: 앱 실행\n\n코드를 작성한 후 Android 에뮬레이터 또는 실제 장치에서 앱을 실행하여 작동을 확인할 수 있습니다. Android Studio에서 \"실행\" 버튼을 클릭하고 대상 장치를 선택한 다음 앱을 빌드 및 설치할 때까지 기다리십시오.\n\n축하합니다! 첫 번째 Android 앱을 만들고 실행했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다음 단계\n\n첫 번째 안드로이드 앱을 완료했으니, 안드로이드 개발의 더 고급 주제와 기능을 탐색할 수 있습니다. 예를 들면:\n\n- 다양한 UI 구성 요소와 레이아웃 작업\n- 사용자 입력 및 상호 작용 처리\n- SharedPreferences나 SQLite 데이터베이스를 사용한 데이터 저장 및 검색\n- Retrofit이나 Volley를 사용한 네트워크 요청\n- 활동 또는 프래그먼트를 이용한 내비게이션 구현\n\n안드로이드 개발의 이해를 깊이 있게 하는 데 도움이 되는 다양한 온라인 자료, 튜토리얼 및 문서가 많이 있습니다. 안드로이드 앱 개발 세계로의 여정을 계속하면서 새로운 것을 시도하고 실험해 보는 데 겁내지 마세요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp_0.png"},"coverImage":"/assets/img/2024-05-23-ABeginnersGuidetoAndroidDevelopmentGettingStartedwithBuildingYourFirstApp_0.png","tag":["Tech"],"readingTime":4},{"title":"안녕하세요 오늘은 안드로이드에서 ExoPlayer를 사용하여 Jetpack Compose로 비디오를 표시하는 방법에 대해 알아보겠습니다","description":"","date":"2024-05-23 12:55","slug":"2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose","content":"\n이 튜토리얼에서는 Jetpack Compose와 함께 ExoPlayer를 사용하는 간단한 방법을 보여드리기로 했어요.\n\n먼저 아래 종속성을 build.gradle(Module: app) 파일에 추가해주세요.\n\n```js\n// in .kts\nimplementation(\"androidx.media3:media3-exoplayer:1.2.0\");\nimplementation(\"androidx.media3:media3-ui:1.2.0\");\n```\n\n현재 컨텍스트를 LocalContext.current로 가져오세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n    // 현재 컨텍스트 가져오기\n    val context = LocalContext.current\n```\n\nComposable이나 ViewModel에서 ExoPlayer의 인스턴스를 만듭니다.\n\n```kotlin\nval exoPlayer = ExoPLayer.Builder(context).build()\n```\n\nExoPlayer의 라이프사이클을 관리하여 필요하지 않을 때 리소스를 해제해야 합니다. DisposableEffect와 LaunchedEffect를 사용하여 라이프사이클 이벤트를 처리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// MediaSource를 ExoPlayer에 설정합니다.\nLaunchedEffect(mediaSource) {\n    exoPlayer.setMediaItem(mediaSource)\n    exoPlayer.prepare()\n}\n\n// 라이프사이클 이벤트 관리\nDisposableEffect(Unit) {\n    onDispose {\n        exoPlayer.release()\n    }\n}\n```\n\nExoPlayer 및 해당 컨트롤을 표시하는 Android view입니다.\n\n```js\nAndroidView(\n    factory = { ctx -\u003e\n        PlayerView(ctx).apply {\n            player = exoPlayer\n        }\n    },\n    modifier = Modifier\n        .fillMaxWidth()\n        .height(200.dp) // 원하는 높이로 설정하세요\n)\n```\n\n상수 EXAMPLE_VIDEO_URI를 만들어 샘플 비디오의 URL을 정의합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst val EXAMPLE_VIDEO_URI = \"https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"\n```\n\nmanifest.file에 인터넷 권한을 추가해주세요.\n\n```js\n\u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e\n```\n\n이전에 만든 완성된 코드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n/**\n * Composable 함수로 ExoPlayer를 사용하여 비디오를 재생하는 기능을 표시합니다.\n *\n * @OptIn 어노테이션인 UnstableApi는 해당 API가 여전히 실험적이며 향후 변경될 수 있다는 것을 나타냅니다.\n *\n * @see EXAMPLE_VIDEO_URI 실제 재생할 비디오의 URI로 대체하세요.\n */\n@OptIn(UnstableApi::class)\n@Composable\nfun ExoPlayerView() {\n    // 현재 컨텍스트 가져오기\n    val context = LocalContext.current\n\n    // ExoPlayer 초기화\n    val exoPlayer = ExoPlayer.Builder(context).build()\n\n    // MediaSource 생성\n    val mediaSource = remember(EXAMPLE_VIDEO_URI) {\n        MediaItem.fromUri(EXAMPLE_VIDEO_URI)\n    }\n\n    // MediaSource를 ExoPlayer에 설정\n    LaunchedEffect(mediaSource) {\n        exoPlayer.setMediaItem(mediaSource)\n        exoPlayer.prepare()\n    }\n\n    // 라이프사이클 이벤트 관리\n    DisposableEffect(Unit) {\n        onDispose {\n            exoPlayer.release()\n        }\n    }\n\n    // AndroidView를 사용하여 Android View(PlayerView)를 Compose에 임베드\n    AndroidView(\n        factory = { ctx -\u003e\n            PlayerView(ctx).apply {\n                player = exoPlayer\n            }\n        },\n        modifier = Modifier\n            .fillMaxWidth()\n            .height(200.dp) // 원하는 높이로 설정\n    )\n}\n```\n\n사용자 지정 UI 컨트롤이 필요하면 play, pause, seek 등을 위한 버튼으로 Composables를 생성하고 exoPlayer를 업데이트하면 됩니다.\n\n이 기능을 테스트하려면 Compose UI에서 ExoPlayeView()를 포함하면 됩니다:\n\n```kotlin\nExoPlayerView()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드를 실행하고 결과를 확인해보세요.\n\n![이미지](/assets/img/2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose_0.png)\n\n아래에는 해당 예제의 저장소 URL이 있습니다.\n\n## 그러나, 더 복잡한 설정과 동영상 컨트롤을 숨기는 기능이 포함된 다음 두 가지 화면으로 구성된 샘플 프로젝트가 있습니다. 첫 번째는 동영상 목록이고 두 번째는 선택된 동영상의 상세 정보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n/**\n * Jetpack Compose를 사용하여 ExoPlayer를 이용한 비디오 플레이어를 표시하는 조합 가능한 함수입니다.\n *\n * @param video 비디오 재생 대상인 [VideoResultEntity]를 나타내는 매개변수입니다.\n * @param playingIndex 현재 재생 중인 인덱스를 나타내는 State입니다.\n * @param onVideoChange 비디오가 변경될 때 호출되는 콜백 함수입니다.\n * @param isVideoEnded 비디오가 종료되었는지를 결정하는 콜백 함수입니다.\n * @param modifier 스타일링 및 위치 지정을 위한 Modifier입니다.\n *\n * UnstableApi에 대한 OptIn 주석은 API가 여전히 실험적이며 미래에 변경될 수 있음을 나타냅니다.\n *\n * OpaqueUnitKey 사용에 대한 경고를 억제하기 위해 이용되는 SuppressLint 주석입니다.\n *\n * 실험적인 Animation API 사용을 위해 ExperimentalAnimationApi 주석이 적용되었습니다.\n */\n@OptIn(UnstableApi::class)\n@SuppressLint(\"OpaqueUnitKey\")\n@ExperimentalAnimationApi\n@Composable\nfun VideoPlayer(\n    video: VideoResultEntity,\n    playingIndex: State\u003cInt\u003e,\n    onVideoChange: (Int) -\u003e Unit,\n    isVideoEnded: (Boolean) -\u003e Unit,\n    modifier: Modifier = Modifier\n) {\n    // 현재 context 가져오기\n    val context = LocalContext.current\n\n    // 비디오 제목의 가시성을 제어하는 Mutable state\n    val visible = remember { mutableStateOf(true) }\n\n    // 비디오 제목을 보유하는 Mutable state\n    val videoTitle = remember { mutableStateOf(video.name) }\n\n    // ExoPlayer를 위한 MediaItems 목록 생성\n    val mediaItems = arrayListOf\u003cMediaItem\u003e()\n    mediaItems.add(\n        MediaItem.Builder()\n            .setUri(video.video)\n            .setMediaId(video.id.toString())\n            .setTag(video)\n            .setMediaMetadata(MediaMetadata.Builder().setDisplayTitle(video.name).build())\n            .build()\n    )\n\n    // ExoPlayer 초기화\n    val exoPlayer = remember {\n        ExoPlayer.Builder(context).build().apply {\n            this.setMediaItems(mediaItems)\n            this.prepare()\n            this.addListener(object : Player.Listener {\n                override fun onEvents(player: Player, events: Player.Events) {\n                    super.onEvents(player, events)\n                    // 200밀리초 후에 비디오 제목 숨김\n                    if (player.contentPosition \u003e= 200) visible.value = false\n                }\n\n                override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {\n                    super.onMediaItemTransition(mediaItem, reason)\n                    // 비디오 변경 시 콜백\n                    onVideoChange(this@apply.currentPeriodIndex)\n                    visible.value = true\n                    videoTitle.value = mediaItem?.mediaMetadata?.displayTitle.toString()\n                }\n\n                override fun onPlaybackStateChanged(playbackState: Int) {\n                    super.onPlaybackStateChanged(playbackState)\n                    // 비디오 재생 상태가 STATE_ENDED로 변경될 때 콜백\n                    if (playbackState == ExoPlayer.STATE_ENDED) {\n                        isVideoEnded.invoke(true)\n                    }\n                }\n            })\n        }\n    }\n\n    // 지정된 인덱스로 이동하고 재생 시작\n    exoPlayer.seekTo(playingIndex.value, C.TIME_UNSET)\n    exoPlayer.playWhenReady = true\n\n    // 생명주기 이벤트에 기반한 플레이어 상태 관리를 위한 생명주기 관찰자 추가\n    LocalLifecycleOwner.current.lifecycle.addObserver(object : LifecycleEventObserver {\n        override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {\n            when (event) {\n                Lifecycle.Event.ON_START -\u003e {\n                    // Composable이 화면에 있을 때 재생 시작\n                    if (exoPlayer.isPlaying.not()) {\n                        exoPlayer.play()\n                    }\n                }\n\n                Lifecycle.Event.ON_STOP -\u003e {\n                    // Composable이 화면에서 벗어날 때 플레이어 일시정지\n                    exoPlayer.pause()\n                }\n\n                else -\u003e {\n                    // Nothing\n                }\n            }\n        }\n    })\n\n    // 비디오 플레이어를 포함하는 Column Composable\n    Column(modifier = modifier.background(Color.Black)) {\n        // Composable이 소멸될 때 ExoPlayer 해제를 위한 DisposableEffect\n        DisposableEffect(\n            AndroidView(\n                modifier = modifier\n                    .testTag(VIDEO_PLAYER_TAG),\n                factory = {\n                    // Compose에 PlayerView를 포함시키는 AndroidView\n                    PlayerView(context).apply {\n                        player = exoPlayer\n                        layoutParams = FrameLayout.LayoutParams(\n                            ViewGroup.LayoutParams.MATCH_PARENT,\n                            ViewGroup.LayoutParams.MATCH_PARENT\n                        )\n                        // 사용 가능한 공간을 채우는 리사이즈 모드 설정\n                        resizeMode = AspectRatioFrameLayout.RESIZE_MODE_FILL\n                        // 불필요한 플레이어 컨트롤 숨김\n                        setShowNextButton(false)\n                        setShowPreviousButton(false)\n                        setShowFastForwardButton(false)\n                        setShowRewindButton(false)\n                    }\n                })\n        ) {\n            // Composable이 소멸될 때 ExoPlayer 해제\n            onDispose {\n                exoPlayer.release()\n            }\n        }\n    }\n}\n```\n\n## VideoPlayer() 조합 가능한 함수 내용:\n\nMediaItems 및 ExoPlayer 설정:\n\n- 비디오 정보를 담을 MediaItems 목록 생성.\n- ExoPlayer를 해당 MediaItems로 구성하고 준비하며, 비디오 변경 및 재생 상태 변경과 같은 이벤트를 처리할 수 있도록 리스너가 추가됨.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n라이프사이클 관리:\n\n- 리사이클러브 옵서버가 추가되어 Composable 라이프사이클 이벤트를 기반으로 플레이어 상태를 관리합니다. 화면이 포그라운드에 있을 때 플레이어가 재생되고, 백그라운드에 있을 때는 일시정지됩니다.\n\nAndroidView 및 PlayerView 통합:\n\n- AndroidView Composable은 안드로이드 PlayerView를 Jetpack Compose에 삽입하는 데 사용됩니다.\n- PlayerView는 ExoPlayer 인스턴스, 레이아웃 매개변수 및 리사이즈 모드와 플레이어 컨트롤의 가시성과 같은 속성과 함께 구성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n휴지통 효과를 위한 정리:\n\n- DisposableEffect는 Composable이 dispose될 때 ExoPlayer 자원을 해제하기 위해 사용됩니다.\n\n총적으로, VideoPlayer Composable은 Jetpack Compose UI 내에서 비디오 재생을 위해 ExoPlayer를 초기화하고 관리하는 로직을 캡슐화합니다.\n\n## 아래 저장소에서 코드를 더 주의 깊게 테스트하고 검토해 주셨으면 좋겠습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-23-HowtodisplayvideosusingExoPlayeronandroidwithJetpackCompose_0.png","tag":["Tech"],"readingTime":11}],"page":"72","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"72"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>