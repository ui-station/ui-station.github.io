<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/30" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/30" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="레일즈 앱에 클래스 레벨 콜백을 추가해보세요" href="/post/2024-06-19-EnhanceYourRailsAppwithClass-LevelCallbacks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="레일즈 앱에 클래스 레벨 콜백을 추가해보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-EnhanceYourRailsAppwithClass-LevelCallbacks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="레일즈 앱에 클래스 레벨 콜백을 추가해보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">레일즈 앱에 클래스 레벨 콜백을 추가해보세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ruby on Rails 응용 프로그램을 PostgreSQL을 사용하여 VPS에 Kamal을 이용하여 배포하는 단계별 안내" href="/post/2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ruby on Rails 응용 프로그램을 PostgreSQL을 사용하여 VPS에 Kamal을 이용하여 배포하는 단계별 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ruby on Rails 응용 프로그램을 PostgreSQL을 사용하여 VPS에 Kamal을 이용하여 배포하는 단계별 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Ruby on Rails 응용 프로그램을 PostgreSQL을 사용하여 VPS에 Kamal을 이용하여 배포하는 단계별 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Rails 7 폼 제출과 Turbo Stream  폼 제출 실패시 에러 표시" href="/post/2024-06-19-Rails7FormsubmissionwithTurboStreamShowingerroronfailureofformsubmission"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Rails 7 폼 제출과 Turbo Stream  폼 제출 실패시 에러 표시" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Rails7FormsubmissionwithTurboStreamShowingerroronfailureofformsubmission_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Rails 7 폼 제출과 Turbo Stream  폼 제출 실패시 에러 표시" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Rails 7 폼 제출과 Turbo Stream  폼 제출 실패시 에러 표시</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Spring Boot에서 사용자 정의 micrometer 메트릭 및 스크레이핑, Prometheus 및 Grafana를 사용하여 시각화하기" href="/post/2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Spring Boot에서 사용자 정의 micrometer 메트릭 및 스크레이핑, Prometheus 및 Grafana를 사용하여 시각화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Spring Boot에서 사용자 정의 micrometer 메트릭 및 스크레이핑, Prometheus 및 Grafana를 사용하여 시각화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Spring Boot에서 사용자 정의 micrometer 메트릭 및 스크레이핑, Prometheus 및 Grafana를 사용하여 시각화하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바로 간단한 규칙 엔진 구축하기" href="/post/2024-06-19-BuildingaSimpleRuleEngineinJava"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바로 간단한 규칙 엔진 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-BuildingaSimpleRuleEngineinJava_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바로 간단한 규칙 엔진 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바로 간단한 규칙 엔진 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 Optional을 더 유창하게 활용하기" href="/post/2024-06-19-UseJavaOptionalFluently"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 Optional을 더 유창하게 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-UseJavaOptionalFluently_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 Optional을 더 유창하게 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 Optional을 더 유창하게 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Java 제네릭을 이용한 다형 함수" href="/post/2024-06-19-PolymorphicfunctionsusingJavagenerics"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Java 제네릭을 이용한 다형 함수" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Java 제네릭을 이용한 다형 함수" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Java 제네릭을 이용한 다형 함수</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 어려운 면접 질문" href="/post/2024-06-19-Javatrickyinterviewquestions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 어려운 면접 질문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Javatrickyinterviewquestions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 어려운 면접 질문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 어려운 면접 질문</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제" href="/post/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">46<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="가장 많이 묻는 질문 - SOLID 원칙 JAVA" href="/post/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가장 많이 묻는 질문 - SOLID 원칙 JAVA" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가장 많이 묻는 질문 - SOLID 원칙 JAVA" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">가장 많이 묻는 질문 - SOLID 원칙 JAVA</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link posts_-active__YVJEi" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"레일즈 앱에 클래스 레벨 콜백을 추가해보세요","description":"","date":"2024-06-19 22:14","slug":"2024-06-19-EnhanceYourRailsAppwithClass-LevelCallbacks","content":"\n\u003cimg src=\"/assets/img/2024-06-19-EnhanceYourRailsAppwithClass-LevelCallbacks_0.png\" /\u003e\n\n# 소개\n\n지난 주에는 ActiveJob의 결과를 처리해야 하는 기능을 작업했습니다. 해당 작업은 젬 내에 존재했고, 호스트 애플리케이션의 클래스에서 메소드를 호출하기 위해 젬을 수정해야 했습니다. 이 상황은 클래스 인스턴스와는 독립적으로 처리되어야 했기 때문에 클래스 수준의 콜백이 필요했습니다.\n\n# Rails에서 콜백 이해하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n콜백은 객체의 라이프사이클 중 특정 시점에 호출되는 메서드입니다. Rails에서는 콜백이 널리 사용되어 객체의 생성, 업데이트 및 삭제 중에 코드를 자동으로 실행합니다. 콜백에 대해 더 알고 싶다면 Rails 가이드의 콜백 섹션을 참조해보세요.\n\n# 예시 코드\n\n## ActiveJob의 젬\n\n여기에는 호스트 애플리케이션의 클래스에서 메서드를 호출해야 하는 젬 내의 작업이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# ActiveJob in the gem\n\nclass MyJob \u003c ActiveJob::Base\ndef perform\nresult = # perform the job and get the result\nif ModelName.respond_to?(:after_result, true)\nModelName.after_result { result }\nend\nend\nend\n\n이 스니펫에서는 호스트 애플리케이션의 ModelName 클래스가 after_result 클래스 메소드를 갖고 있는지 확인합니다. 해당 메소드가 있다면 블록을 사용하여 작업 결과를 이 메소드로 전달합니다.\n\n## Host Application Class Method\n\n호스트 애플리케이션에서는 클래스 내에 after_result 메소드를 정의합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 호스트 응용프로그램의 클래스\n\nClass ModelName\ndef self.after_result\nresult = yield if block_given?\nprocess(result) if result.present?\nend\n\ndef self.process(result) # 결과를 처리합니다\nend\nend\n\n여기서 yield는 작업 결과를 after_result 메서드로 전달하며, 결과가 있는 경우 처리합니다.\n\n## 인스턴스 메서드 콜백\n\n인스턴스 메서드와 Rails 콜백을 사용한다면 조금 다르게 보일 것입니다. define_callbacks와 set_callback을 사용하여 클래스 인스턴스에서 콜백을 정의할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```ruby\n# 호스트 응용 프로그램의 클래스\nclass ModelName\n  define_callbacks :result\n  set_callback :result, :after, :after_result, if: -\u003e { respond_to?(:after_result, true) }\n\n  def after_result\n    result = yield if block_given?\n    process(result) if result.present?\n  end\n\n  def process(result)\n    # 결과 처리\n  end\nend\n```\n\n이 예에서 after_result는 인스턴스 메서드입니다. :result 콜백을 정의하고, :result 콜백이 트리거된 후에 after_result 메서드가 실행되어야 함을 지정합니다.\n\n## 젬 내 수정된 ActiveJob\n\n인스턴스 메서드 콜백을 사용하려면 작업을 다음과 같이 수정하십시오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# ActiveJob in the gem\nclass MyJob \u003c ActiveJob::Base\n  def perform(instance)\n    result = # perform the job and get the result\n    if instance.respond_to?(:after_result, true)\n      instance.run_callbacks(:result) { result }\n    end\n  end\nend\n```\n\n여기서 instance는 호스트 애플리케이션의 ModelName의 인스턴스입니다. after_result에 응답하는지 확인하고 :result 콜백을 실행합니다.\n\n# 결론\n\n클래스 메서드를 콜백으로 사용하는 방법과 인스턴스 메서드에 대해 Rails의 set_callback을 활용하는 방법을 다루었습니다. 사용 사례에 따라 클래스 수준 또는 인스턴스 수준 메서드가 필요한 경우 적절한 콜백 메커니즘을 구현할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-EnhanceYourRailsAppwithClass-LevelCallbacks_0.png"},"coverImage":"/assets/img/2024-06-19-EnhanceYourRailsAppwithClass-LevelCallbacks_0.png","tag":["Tech"],"readingTime":4},{"title":"Ruby on Rails 응용 프로그램을 PostgreSQL을 사용하여 VPS에 Kamal을 이용하여 배포하는 단계별 안내","description":"","date":"2024-06-19 22:12","slug":"2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal","content":"\n![image](/assets/img/2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal_0.png)\n\n이 튜토리얼에서는 DigitalOcean에서 제공하는 Virtual Private Server (VPS)에 Ruby on Rails 애플리케이션을 PostgreSQL 데이터베이스와 함께 배포하는 과정을 안내하겠습니다. Docker 기반 애플리케이션을 자동화하는 배포 도구 인 Kamal을 활용하여 배포 프로세스를 자동화할 것입니다.\n\n# 전제 조건\n\n시작하기 전에 다음 사항을 갖추었는지 확인하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- PostgreSQL이 구성된 Ruby on Rails 애플리케이션.\n- VPS (droplet)가 프로비저닝되어 SSH 액세스가 설정된 DigitalOcean 계정. 원하는 제공업체를 사용해도 됩니다.\n\n# 단계 1: Kamal 설치\n\n로컬 머신에 Kamal이 설치되어 있는지 확인하세요. RubyGems를 통해 설치할 수 있습니다:\n\n```js\ngem install kamal\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 2: 배포 설정 구성\n\n프로젝트 디렉토리로 이동한 다음 다음을 실행하세요:\n\n```js\nkamal init\n```\n\n이 명령은 deploy.yml 설정 파일을 생성하고 다른 몇 가지 파일을 함께 생성합니다. deploy.yml 구성 파일의 여러 섹션을 이해해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 애플리케이션의 이름. 고유하게 컨테이너를 구성하는 데 사용됩니다.\nservice: mynewapp\n```\n\n애플리케이션의 이름을 지정합니다. 이는 애플리케이션과 관련된 컨테이너를 고유하게 구성하는 데 사용됩니다.\n\n```js\n# 컨테이너 이미지의 이름.\nimage: talha/mynewapp\n```\n\n애플리케이션에 대한 Docker 컨테이너 이미지의 이름을 지정합니다. talha/mynewapp를 Docker Hub 저장소의 이름으로 교체하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 이러한 서버에 배포할 수 있습니다.\n서버:\n  웹:\n    호스트:\n      - 123.123.45.678\n    라벨:\n      traefik.http.routers.mynewapp.rule: Host(`mynewapp.com`)\n      traefik.http.routers.mynewapp.entrypoints: websecure\n      traefik.http.routers.mynewapp_secure.rule: Host(`mynewapp.com`)\n      traefik.http.routers.mynewapp_secure.tls: true\n      traefik.http.routers.mynewapp_secure.tls.certresolver: letsencrypt\n    옵션:\n      네트워크: \"private\"\n```\n\n어플리케이션이 배포될 서버를 정의하고, HTTP 요청을 앱에 라우팅하고 TLS/SSL 암호화를 활성화하기 위한 Traefik 설정을 구성합니다.\n\n```js\n# 이미지 호스트에 대한 자격 증명.\n레지스트리:\n  사용자 이름:\n    - KAMAL_REGISTRY_USERNAME\n  비밀번호:\n    - KAMAL_REGISTRY_PASSWORD\n```\n\n어플리케이션 이미지가 호스팅된 Docker 이미지 레지스트리에 액세스하는 자격 증명을 지정합니다. KAMAL_REGISTRY_USERNAME 및 KAMAL_REGISTRY_PASSWORD를 Docker 허브 자격 증명으로 교체하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\n# 컨테이너에 환경 변수 주입 (시크릿은 .env에서 온다).\n# 변경 후 `kamal env push`를 실행하는 것을 잊지 마세요!\nenv:\n  clear:\n    RAILS_ENV: production\n    RACK_ENV: production\n    RAILS_LOG_TO_STDOUT: true\n    RAILS_SERVE_STATIC_FILES: true\n  secret:\n    - RAILS_MASTER_KEY\n    - SMTP_PASSWORD\n    - SMTP_SERVER\n    - SMTP_LOGIN\n    - DB_HOST\n    - POSTGRES_USER\n    - POSTGRES_PASSWORD\n```\n\n컨테이너의 환경 변수를 지정합니다. clear 변수는 공개적으로 접근 가능하며, 시크릿 변수는 비공개로 유지됩니다. 이러한 변수는 .env 파일에서 가져옵니다.\n\n```yaml\n# root가 아닌 다른 ssh 사용자 사용\nssh:\n  user: deploy\n```\n\n- 서버에 액세스하는 데 사용할 SSH 사용자를 지정합니다. 이 경우 사용자는 deploy입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\n# 빌더 설정 구성.\n빌더:\n  원격:\n    아키텍처: amd64\n```\n\n빌더 설정을 구성하여 응용 프로그램을 빌드할 원격 서버의 아키텍처를 지정합니다. 위의 구성은 Apple Silicon에서 개발하고 있지만 amd64 도커 이미지만 빌드하려는 경우 유용합니다.\n\n```yaml\n# 부가 서비스 사용 (비밀은 .env에서 제공됨).\n부가서비스:\n  db:\n    이미지: postgres:16.0\n    호스트: 123.123.45.678\n    환경:\n      클리어:\n        POSTGRES_USER: \"mynewapp\"\n        POSTGRES_DB: \"mynewapp_production\"\n      시크릿:\n        - POSTGRES_PASSWORD\n        - POSTGRES_USER\n    파일:\n      - config/init.sql:/docker-entrypoint-initdb.d/setup.sql\n    디렉토리:\n      - data:/var/lib/postgresql/data\n    옵션:\n      네트워크: \"private\"\n```\n\n응용 프로그램에서 필요한 추가 서비스를 정의합니다. 이 경우 지정된 버전과 환경 변수를 갖는 PostgreSQL 데이터베이스 서비스를 구성합니다. 파일 지시문을 사용하여 자체 엔트리포인트를 제공할 수 있습니다. config/init.sql은 config/database.yml 구성에서 예상한대로 데이터베이스를 생성해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nCREATE DATABASE mynewapp_production;\n```\n\n위 명령어를 사용하여 새로운 파일 config/init.sql을 만들어주세요.\n\n```js\nproduction:\n  \u003c\u003c: *default\n  database: mynewapp_production\n  username: \u003c%= ENV[\"POSTGRES_USER\"] %\u003e\n  password: \u003c%= ENV[\"POSTGRES_PASSWORD\"] %\u003e\n  host: \u003c%= ENV[\"DB_HOST\"] %\u003e\n```\n\n또한, 위와 같이 database.yml 파일을 업데이트하여 프로덕션 DB 구성을 업데이트해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\ntraefik:\n  options:\n    publish:\n      - \"443:443\"\n    volume:\n      - \"/letsencrypt/acme.json:/letsencrypt/acme.json\"\n    network: \"private\"\n  args:\n    entryPoints.web.address: \":80\"\n    entryPoints.websecure.address: \":443\"\n    entryPoints.web.http.redirections.entryPoint.to: websecure\n    entryPoints.web.http.redirections.entryPoint.scheme: https\n    entryPoints.web.http.redirections.entrypoint.permanent: true\n    certificatesResolvers.letsencrypt.acme.email: \"info@mynewapp.com\"\n    certificatesResolvers.letsencrypt.acme.storage: \"/letsencrypt/acme.json\"\n    certificatesResolvers.letsencrypt.acme.httpchallenge: true\n    certificatesResolvers.letsencrypt.acme.httpchallenge.entrypoint: web\n```\n\nTraefik을 설정하여 HTTPS 요청을 처리하고 Let's Encrypt를 사용하여 SSL 인증서를 자동으로 관리하도록 구성합니다.\n\n아래에 완전한 deploy.yml 파일을 찾을 수 있어요:\n\n```yaml\n# 애플리케이션의 이름. 컨테이너를 고유하게 설정하는 데 사용됩니다.\nservice: mynewapp\n\n# 컨테이너 이미지의 이름입니다.\nimage: talha/mynewapp\n\n# 이 서버로 배포합니다.\nservers:\n  web:\n    hosts:\n      - 123.123.45.678\n    labels:\n      traefik.http.routers.mynewapp.rule: Host(`mynewapp.com`)\n      traefik.http.routers.mynewapp.entrypoints: websecure\n      traefik.http.routers.mynewapp_secure.rule: Host(`mynewapp.com`)\n      traefik.http.routers.mynewapp_secure.tls: true\n      traefik.http.routers.mynewapp_secure.tls.certresolver: letsencrypt\n    options:\n      network: \"private\"\n\n# 이미지 호스트의 자격 증명입니다.\nregistry:\n  username:\n    - KAMAL_REGISTRY_USERNAME\n  password:\n    - KAMAL_REGISTRY_PASSWORD\n\n# 컨테이너로 ENV 변수를 주입합니다(비밀은 .env에서 가져옵니다).\n# 변경 후 `kamal env push`를 실행하는 것을 잊지 마세요!\nenv:\n  clear:\n    RAILS_ENV: production\n    RACK_ENV: production\n    RAILS_LOG_TO_STDOUT: true\n    RAILS_SERVE_STATIC_FILES: true\n  secret:\n    - RAILS_MASTER_KEY\n    - SMTP_PASSWORD\n    - SMTP_SERVER\n    - SMTP_LOGIN\n    - DB_HOST\n    - POSTGRES_USER\n    - POSTGRES_PASSWORD\n\n# root가 아닌 다른 ssh 사용자를 사용합니다.\nssh:\n  user: deploy\n\n# 빌더 설정을 구성합니다.\nbuilder:\n  remote:\n    arch: amd64\n\n# 보조 서비스를 사용합니다(비밀은 .env에서 가져옵니다).\naccessories:\n  db:\n    image: postgres:16.0\n    host: 123.123.45.678\n    env:\n      clear:\n        POSTGRES_USER: \"mynewapp\"\n        POSTGRES_DB: \"mynewapp_production\"\n      secret:\n        - POSTGRES_PASSWORD\n        - POSTGRES_USER\n    files:\n      - config/init.sql:/docker-entrypoint-initdb.d/setup.sql\n    directories:\n      - data:/var/lib/postgresql/data\n    options:\n      network: \"private\"\n\ntraefik:\n  options:\n    publish:\n      - \"443:443\"\n    volume:\n      - \"/letsencrypt/acme.json:/letsencrypt/acme.json\"\n    network: \"private\"\n  args:\n    entryPoints.web.address: \":80\"\n    entryPoints.websecure.address: \":443\"\n    entryPoints.web.http.redirections.entryPoint.to: websecure\n    entryPoints.web.http.redirections.entryPoint.scheme: https\n    entryPoints.web.http.redirections.entrypoint.permanent: true\n    certificatesResolvers.letsencrypt.acme.email: \"info@mynewapp.com\"\n    certificatesResolvers.letsencrypt.acme.storage: \"/letsencrypt/acme.json\"\n    certificatesResolvers.letsencrypt.acme.httpchallenge: true\n    certificatesResolvers.letsencrypt.acme.httpchallenge.entrypoint: web\n\nasset_path: /rails/public/assets\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 예시를 참고하여 실제 애플리케이션 이름, 도메인 및 서버 IP 주소로 mynewapp, mynewapp.com 및 123.123.45.678와 같은 자리 표시자를 교체해주세요.\n\n# 단계 3: 배포 사용자 생성\n\nVPS에 SSH로 접속하고 새로운 사용자 deploy를 만들어보세요. 아래 명령어를 실행하세요.\n\n로컬 머신에서 터미널을 열고 SSH를 사용하여 VPS에 연결합니다. 실제 VPS의 IP 주소로 your_server_ip를 교체해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```sh\nssh root@your_server_ip\n```\n\n다음 명령어를 실행하여 새로운 사용자 deploy를 생성하세요:\n\n```sh\nadduser deploy\n```\n\n새 사용자에 대한 암호를 설정하고 추가 정보를 입력하라는 프롬프트가 표시됩니다. 선택 사항을 건너뛰려면 Enter 키를 누르세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(선택사항) 배포 사용자에게 sudo 권한을 부여하고 싶다면 다음 명령을 실행하여 sudo 그룹에 추가할 수 있습니다:\n\n```js\nusermod -aG sudo deploy\n```\n\n# 단계 4: VPS에 Docker 설치하기:\n\nDocker를 설치하기 전에 패키지 인덱스를 업데이트하는 것이 좋은 실천법입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\napt update\n```\n\nHTTPS를 통해 저장소를 사용할 수 있도록 패키지를 설치하고 Docker에 필요한 몇 가지 패키지를 설치하세요:\n\n```js\napt install -y apt-transport-https ca-certificates curl software-properties-common\n```\n\n시스템에 Docker의 공식 GPG 키를 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n```\n\nDocker 리포지토리를 APT 원본에 추가하세요:\n\n```js\nadd-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n한번 더 패키지 인덱스를 업데이트하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```bash\napt update\n```\n\n최신 버전의 Docker CE (Community Edition)와 containerd를 함께 설치하려면:\n\n```bash\napt install -y docker-ce docker-ce-cli containerd.io\n```\n\nDocker 서비스를 시작하고 부팅 시 자동으로 시작되도록 설정하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsystemctl start docker\nsystemctl enable docker\n```\n\n다음 명령어를 실행하여 Docker가 올바르게 설치되었는지 확인하세요. 이 명령은 Docker 버전 정보를 출력해야 합니다:\n\n```js\ndocker --version\n```\n\n마지막으로, 프라이빗 Docker 네트워크를 생성하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 네트워크 생성 -d bridge private\n```\n\n# 단계 5: LetsEncrypt 설치하기:\n\n로컬 머신에서 터미널을 열고 SSH를 사용하여 VPS에 연결합니다. 실제 VPS의 IP 주소로 your_server_ip를 대체하십시오.\n\n```js\nssh root@your_server_ip\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 명령을 사용하여 Let's Encrypt 디렉토리를 설정하세요:\n\n```js\nmkdir -p /letsencrypt \u0026\u0026 touch /letsencrypt/acme.json \u0026\u0026 chmod 600 /letsencrypt/acme.json\n```\n\n# 단계 6: 애플리케이션 배포\n\n처음부터 모든 단계를 거쳐 config/deploy.yml 파일을 작성했고 배포할 준비가 되었다면, 다음을 실행하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkamal setup\n```\n\n# Step 7: 일일 업무 흐름\n\n카말의 명령어를 사용하여 매일 배포 작업을 수행하세요:\n\n앱의 새 버전을 배포하려면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkamal deploy\n```\n\n환경 변수를 업데이트하려면:\n\n```js\nkamal env push\n```\n\n새 컨테이너에서 bash 세션을 시작하려면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkamal app exec -i bash\n```\n\n새로운 컨테이너에서 Rails 콘솔을 시작하려면:\n\n```js\nkamal app exec -i ‘bin/rails console’\n```\n\n로그 보기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkamal 앱 로그\n```\n\n# 결론\n\n축하합니다! 카말(Kamal)을 사용하여 디지턈오션(DigitalOcean) VPS에서 PostgreSQL과 함께 루비 온 레일즈(Ruby on Rails) 애플리케이션을 성공적으로 배포했습니다. 이제 구성된 도메인 이름으로 애플리케이션에 액세스할 수 있습니다. 🚀\n\n이 포스트가 마음에 들었다면 좋아요를 눌러 주시고 미디엄(Medium)과 트위터(Twitter)에서도 저를 팔로우해주세요(https://twitter.com/royalty568).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시간을 절약하고 앱을 즉시 구축하고자 한다면 Rails 보일러플레이트를 찾고 계신 것 같네요. https://talha345.gumroad.com/l/rails7-bootstrap5-devise-fa-psql-boldo-boilerplate 를 확인해보세요!\n","ogImage":{"url":"/assets/img/2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal_0.png"},"coverImage":"/assets/img/2024-06-19-Step-by-StepGuidetoDeployingaRubyonRailsApplicationwithPostgreSQLonVPSusingKamal_0.png","tag":["Tech"],"readingTime":16},{"title":"Rails 7 폼 제출과 Turbo Stream  폼 제출 실패시 에러 표시","description":"","date":"2024-06-19 22:11","slug":"2024-06-19-Rails7FormsubmissionwithTurboStreamShowingerroronfailureofformsubmission","content":"\n# 소개\n\nHotwire 스위트의 일부인 Turbo Stream은 Rails 애플리케이션에서 실시간 업데이트를 처리하는 우아한 방법을 제공합니다. Rails 7에서 Turbo Stream을 사용하여 양식 제출을 관리하는 것은 더욱 강력하고 간소화되었습니다. 이 블로그 포스트에서는 양식 제출이 실패할 때 오류를 우아하게 처리하여 유연한 사용자 경험을 제공하는 방법에 대해 살펴보겠습니다.\n\n# 전제 조건\n\n시작하기 전에 다음 사항을 확인하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Rails 7 애플리케이션을 설정했어요.\n- Turbo와 Stimulus 라이브러리가 프로젝트에 포함되어 있어요. (이들은 Rails 7 앱에서 기본으로 제공돼요)\n\n# 단계 1: 모델 및 컨트롤러 설정하기\n\n간단한 모델과 컨트롤러를 설정해볼게요. 데모를 위해 간단한 제목과 본문을 가진 Post 모델을 만들고, PostsController에서 폼 제출을 처리할 거예요.\n\n## 모델 및 컨트롤러 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 유효성 정의\n\nPost 모델 (app/models/post.rb) 에 몇 가지 유효성을 추가해보세요:\n\n```rb\nclass Post \u003c ApplicationRecord\n validates :title, presence: true\n validates :body, presence: true\nend\n```\n\n# 단계 2: 폼 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, 새로운 게시물을 제출하기 위한 양식을 만들어보겠습니다. PostsController에서 new 및 create 액션을 정의하세요:\n\n```js\nclass PostsController \u003c ApplicationController\n  def new\n    @post = Post.new\n  end\n\n  def create\n    @post = Post.new(post_params)\n    if @post.save\n      redirect_to @post, notice: '게시물이 성공적으로 생성되었습니다.'\n    else\n      render :new, status: :unprocessable_entity\n    end\n  end\n\n  private\n\n  def post_params\n    params.require(:post).permit(:title, :body)\n  end\nend\n```\n\n# 단계 3: 뷰 작성\n\n## 양식 부분\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n폼 부분을 생성하려면 다음 파일을 만드세요 (app/views/posts/\\_form.html.erb):\n\n```ruby\n\u003c%= form_for post, html: { class: 'row' } do |f| %\u003e\n  \u003cdiv class=\"col-auto\"\u003e\n    \u003c%= f.label :title, class: 'form-label' %\u003e\n    \u003c%= f.text_field :title, class: 'form-control' %\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"col-auto\"\u003e\n    \u003c%= f.label :body, class: 'form-label' %\u003e\n    \u003c%= f.text_area :body, class: 'form-control' %\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"col-auto mt-4\"\u003e\n    \u003c%= f.submit class: 'btn btn-primary' %\u003e\n  \u003c/div\u003e\n\u003c% end %\u003e\n```\n\n폼 부분을 생성하려면 다음 파일을 만드세요 (app/views/posts/new.html.erb):\n\n```ruby\n\u003ch2\u003e새 글 작성하기\u003c/h2\u003e\n\u003c%= render 'form', post: @post %\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이제 레일즈 7에서 오류가 발생합니다.\n\n새로운 포스트를 생성하기 위해 폼을 제출할 때.\n\n```js\nturbo.es2017-esm.js:2115 Error: Form responses must redirect to another location\n    at FormSubmission.requestSucceededWithResponse (turbo.es2017-esm.js:679:27)\n    at FetchRequest.receive (turbo.es2017-esm.js:450:27)\n    at FetchRequest.perform (turbo.es2017-esm.js:431:31)\n```\n\n이것은 모든 링크 클릭과 폼 제출이 이제 레일즈 7에서 TURBO_STREAM 요청이 되었기 때문에 발생합니다.\n더 빠른 응답을 얻기 위해서이며, TURBO_STREAM 요청을 만들기 위한 명시적 코드를 작성할 필요가 없습니다.\n\nTURBO_STREAM 요청이 하는 일은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 전체 페이지를 다시로드하지 않고 페이지에 터보 프레임을 업데이트합니다.\n\n해결하는 방법은\n\n이 문제를 해결하려면\n\n이렇게 컨트롤러에서 TURBO_STREAM 요청을 처리해야 합니다.\n\n```js\n  def create\n    @post = Post.new(post_params)\n    if @post.save\n      redirect_to @post, notice: '게시물이 성공적으로 생성되었습니다.'\n    else\n      respond_to do |format|\n        format.turbo_stream { render turbo_stream: turbo_stream.replace(@post, partial: 'posts/form', locals: { post: @post }) }\n        format.html { render :new }\n      end\n    end\n  end\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n터보 스트림.replace 메소드는 레일즈의 Turbo Streams 라이브러리의 일부입니다. 이 메소드는 전체 페이지 새로고침 없이 페이지의 일부를 교체하는 Turbo Stream 액션을 생성합니다.\n\n다음은 이 메소드와 해당 속성에 대한 설명입니다:\n\n- format.turbo_stream: 이는 다음 블록이 Turbo Stream 요청에 응답하는 데 사용되어야 함을 지정합니다. Turbo Stream은 Hotwire 프레임워크의 일부로서 WebSocket을 통해 페이지의 특정 부분에 업데이트를 보낼 수 있게 합니다.\n- `render turbo_stream: turbo_stream.replace(@post, partial: 'posts/form', locals: { post: @post })`: 이는 Turbo Stream 요청에 대해 실행되는 블록입니다. 응답을 보내기 위해 render 메소드를 사용합니다.\n- turbo_stream.replace(@post, partial: `posts/form`, locals: { post: @post }): 이는 페이지의 일부를 교체하는 Turbo Stream 액션입니다. 새로운 콘텐츠로 Turbo Frame이나 Turbo Stream 요소를 교체하는 replace 메소드를 사용합니다.\n- @post: 이는 교체 액션의 대상입니다. 페이지에서 Turbo Frame이나 Turbo Stream 요소의 ID와 일치해야 합니다.\n- 지금은 대상이 form ID인 new_post인 경우가 있습니다. 첫 번째 인자에 @post를 전달했기 때문에 replace 메소드가 자동으로 form ID를 대상으로 설정합니다.\n- partial: 'posts/form': 이는 대상을 렌더링하고 교체할 부분을 지정합니다.\n- locals: { post: @post }: 이는 부분에 로컬 변수를 전달합니다. 이 경우 @post 인스턴스 변수를 post라는 로컬 변수로 전달합니다.\n\n또한, 폼 제출 실패를 처리하기 위해 뷰에 오류를 추가할 예정입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 게시물 생성하기\n\n```ruby\n\u003c%= form_for post, html: { class: 'row' } do |f| %\u003e\n  \u003c% if post.errors.any? %\u003e\n    \u003cdiv class=\"col-12\"\u003e\n      \u003cdiv class=\"alert alert-danger\"\u003e\n        \u003cul\u003e\n          \u003c% post.errors.full_messages.each do |message| %\u003e\n            \u003cli\u003e\u003c%= message %\u003e\u003c/li\u003e\n          \u003c% end %\u003e\n        \u003c/ul\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c% end %\u003e\n\n  \u003cdiv class=\"col-auto\"\u003e\n    \u003c%= f.label :title, class: 'form-label' %\u003e\n    \u003c%= f.text_field :title, class: 'form-control' %\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"col-auto\"\u003e\n    \u003c%= f.label :body, class: 'form-label' %\u003e\n    \u003c%= f.text_area :body, class: 'form-control' %\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"col-auto mt-4\"\u003e\n    \u003c%= f.submit class: 'btn btn-primary' %\u003e\n  \u003c/div\u003e\n\u003c% end %\u003e\n```\n\n이렇게 수정하면 우리는 Rails 7에서 양식 제출 실패를 처리하는 문제를 해결할 수 있습니다.\n\n# 결론:\n\nTurbo는 Basecamp에 의해 소개된 Hotwire 프레임워크의 일부입니다. 최소한의 JavaScript를 사용하여 HTML을 통해 전송함으로써 현대적인 웹 애플리케이션을 구축하는 방법을 제공하도록 설계되었습니다. Turbo에는 세 가지 주요 부분이 있습니다: Turbo Drive, Turbo Frames 및 Turbo Streams.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 단계를 따라 하셨다면 Rails 7 애플리케이션에서 Turbo Stream을 성공적으로 구현하셨습니다. 이 방법을 통해 사용자 경험을 향상시켜 전체 페이지 새로고침 없이 즉각적인 피드백을 제공하고 Hotwire의 Turbo 라이브러리의 능력을 활용할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-Rails7FormsubmissionwithTurboStreamShowingerroronfailureofformsubmission_0.png"},"coverImage":"/assets/img/2024-06-19-Rails7FormsubmissionwithTurboStreamShowingerroronfailureofformsubmission_0.png","tag":["Tech"],"readingTime":8},{"title":"Spring Boot에서 사용자 정의 micrometer 메트릭 및 스크레이핑, Prometheus 및 Grafana를 사용하여 시각화하기","description":"","date":"2024-06-19 22:09","slug":"2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana","content":"\n# 개요\n\n비즈니스에 중요한 응용 프로그램에서 관측 가능성은 중요합니다. 이는 응용 프로그램의 내부 상태를 외부에서 관측하는 능력입니다. 자주 언급되는 것처럼 로그, 지표 및 추적은 관측 가능성의 세 축입니다.\n\n- 로그는 이벤트의 연대 기록입니다. 로그는 주로 일반 텍스트로 기록되지만(이진 및 구조화된 형식도 가능함) 디버깅 및 시스템 이벤트 및 실패 이해에 중요합니다.\n- 지표는 집계된 데이터 또는 이벤트 또는 응용 프로그램 성능의 현재 상태입니다. 지표는 CPU 사용률, 평균 HTTP 응답 시간 또는 총 HTTP 요청과 같은 실시간 통찰력을 제공할 수 있습니다.\n- 추적은 시작부터 끝까지의 엔드 투 엔드 흐름에 대한 상세한 정보를 제공합니다. 요청이 응용 프로그램의 각 구성 요소 또는 서비스를 통과하는 것을 추적합니다. 추적은 로그 및 지표보다 복잡합니다.\n\n이 블로그에서는 지표에 초점을 맞출 것입니다. Spring Boot는 Micrometer와 통합하기 위한 자동 구성을 제공합니다. 이는 SLF4J와 유사하지만 관측 가능성을 위한 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계\n\n우리는 사용자 정의 지표와 헬스 인디케이터를 생성하고 아래 단계를 따를 것입니다:\n\n- 액추에이터와 마이크로미터 레지스트리를 사용하여 프로메테우스 엔드포인트를 활성화합니다.\n- JaMon을 사용하여 REST API 응답 시간을 모니터링하는 Aspect를 생성합니다.\n- HTTP 응답 시간과 요청 횟수에 대한 사용자 정의 지표를 생성합니다.\n- 사용자 정의 헬스 인디케이터를 생성합니다.\n- 프로메테우스를 설정하여 정기적으로 지표를 수집합니다.\n- 그라파나 대시보드를 설정하여 거의 실시간으로 지표를 시각화합니다.\n\n# 구현\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 액추에이터와 micrometer 레지스트리를 사용하여 프로메테우스 엔드포인트를 활성화합니다.\n\n다음 의존성을 pom.xml에 추가하세요.\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n  \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\u003cdependency\u003e\n  \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\n  \u003cartifactId\u003emicrometer-registry-prometheus\u003c/artifactId\u003e\n\u003c/dependency\u003e\n```\n\n엔드포인트는 HTTP 또는 JMX를 통해 활성화 또는 노출시킬 수 있습니다. 우리는 HTTP에만 초점을 맞출 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 모든 엔드포인트가 활성화되어 있습니다. 그러나 종료 점은 활성화되지 않습니다.\n\n기본적으로 헬스 엔드포인트만 노출됩니다.\n\n다른 엔드포인트도 노출해 봅시다. 아래 라인을 애플리케이션 속성에 추가해 주세요:\n\n```js\nmanagement.endpoints.web.exposure.include=*\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(\\*) 모든 끝점을 노출시킬 것이다 (권장되지 않음). 선택된 끝점을 지정하는 데 쉼표로 구분된 값들을 사용할 수 있습니다. 이제 /actuator/metrics로 이동하면 모든 메트릭 목록을 볼 수 있습니다. 이제 /actuator/prometheus로 이동하면 특정 형식의 유사한 메트릭 및 그 값들을 볼 수 있습니다. 이것이 프로메테우스를 구성할 때 사용할 내용입니다.\n\n2 JaMon을 사용하여 REST API 응답 시간을 모니터링하는 Aspect를 생성하세요.\n\nAround 어드바이스를 생성하세요. 이를 위해 어노테이션을 만들었습니다. AOP에 대한 전체 기사를 작성했습니다. 한 번 시도해보세요. JaMon은 개발자가 애플리케이션을 쉽게 모니터링할 수 있게 하는 Java 애플리케이션 모니터링 API입니다. JaMon 의존성을 주입하세요:\n\n\u003cdependency\u003e\n   \u003cgroupId\u003ecom.jamonapi\u003c/groupId\u003e\n   \u003cartifactId\u003ejamon\u003c/artifactId\u003e\n   \u003cversion\u003e2.82\u003c/version\u003e\n\u003c/dependency\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 JaMon을 위해 빈을 생성하고 구성할 것입니다:\n\n```js\n@Configuration\n@ComponentScan(basePackages = \"com.yogendra.aspect\")\n@EnableAspectJAutoProxy\npublic class MonitorConfig {\n    @Bean\n    MonitorFactoryInterface monitorFactory() {\n        return MonitorFactory.getFactory();\n    }\n}\n\n@Component\n@Aspect\npublic class MonitorAspect {\n\n    private final MonitorFactoryInterface monitorFactoryInterface;\n\n    public MonitorAspect(MonitorFactoryInterface monitorFactoryInterface) {\n        this.monitorFactoryInterface = monitorFactoryInterface;\n    }\n\n\n    @Around(\"@annotation(com.yogendra.annotation.MethodMonitor)\")\n    public Object monitorMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable {\n        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n        Method method = methodSignature.getMethod();\n        MethodMonitor methodMonitor = method.getAnnotation(MethodMonitor.class);\n        Monitor monitor = monitorFactoryInterface.start(methodMonitor.name());\n        try {\n            return joinPoint.proceed();\n        } finally {\n            monitor.stop();\n        }\n    }\n}\n\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MethodMonitor {\n    String name() default \"\";\n\n    String uri() default \"\";\n\n    String method() default \"GET\";\n}\n```\n\n이제 MethodMonitor로 우리의 메서드 중 어떤 것이든 연결하면 JaMon이 모니터링을 시작합니다. AOP가 얼마나 강력한지 보여주는 것이죠.\n\n3. HTTP 응답 시간 및 요청 횟수에 대한 사용자 정의 메트릭 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 Micrometer에 대해 조금 이야기해보자. Micrometer는 JVM 기반 애플리케이션을 위한 메트릭 인스트루먼테이션 라이브러리야. Micrometer에서 가장 중요한 인터페이스는 Meter야. 미터는 MeterRegistry에 생성되고 보관돼. Step 1에서 추가한 종속성은 PrometheusMeterRegistry를 자동으로 구성할 거야. Micrometer는 Counter, Gauge, Timer, DistributionSummary 등 다양한 타입의 미터를 제공해. 이 예제에서는 Counter와 Gauge를 구현할 거야. http.requests.count와 http.response.time 두 가지 지표를 생성할 거야.\n\n```js\nCounter.builder(\"http.requests.count\")\n  .tag(\"uri\", methodMonitor.uri())\n  .tag(\"method\", methodMonitor.method())\n  .register(meterRegistry)\n  .increment();\n\nGauge.builder(\"http.response.time\", monitor::getLastValue)\n  .tag(\"uri\", methodMonitor.uri())\n  .tag(\"method\", methodMonitor.method())\n  .register(meterRegistry);\n```\n\n첫 번째 코드는 URI별로 HTTP 메소드(GET, PUT 등) 당 수행된 HTTP 요청 수를 셈. 두 번째 코드는 URI별로 HTTP 메소드(GET, PUT 등)의 API 실행 시간을 측정해. 이전 단계에서 생성한 MonitorAspect에 위 지표들을 추가할 거야. 우리 업데이트된 어드바이스는 이렇게 생겼어:\n\n```js\n@Component\n@Aspect\npublic class MonitorAspect {\n\n    private final MonitorFactoryInterface monitorFactoryInterface;\n    private final MeterRegistry meterRegistry;\n\n    public MonitorAspect(MonitorFactoryInterface monitorFactoryInterface, MeterRegistry meterRegistry) {\n        this.monitorFactoryInterface = monitorFactoryInterface;\n        this.meterRegistry = meterRegistry;\n    }\n\n\n    @Around(\"@annotation(com.yogendra.annotation.MethodMonitor)\")\n    public Object monitorMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable {\n        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n        Method method = methodSignature.getMethod();\n        MethodMonitor methodMonitor = method.getAnnotation(MethodMonitor.class);\n        Monitor monitor = monitorFactoryInterface.start(methodMonitor.name());\n        try {\n            return joinPoint.proceed();\n        } finally {\n            monitor.stop();\n            Counter.builder(\"http.requests.count\")\n                    .tag(\"uri\", methodMonitor.uri())\n                    .tag(\"method\", methodMonitor.method())\n                    .register(meterRegistry).increment();\n            Gauge\n                    .builder(\"http.response.time\", monitor::getLastValue)\n                    .tag(\"uri\", methodMonitor.uri())\n                    .tag(\"method\", methodMonitor.method())\n                    .register(meterRegistry);\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n필요한 지표를 구성했습니다. 이제 서버를 재시작하고, API 엔드포인트를 호출한 후 브라우저에서 /actuator/prometheus를 열어보세요. 여기서 http_requests_count와 http_response_time이라는 이름의 두 가지 지표를 찾을 수 있습니다. Spring Boot는 자동 구성된 HTTP 지표를 제공하며, 이를 비활성화하려면 application.properties에 다음을 추가해주세요.\n\n```js\nmanagement.metrics.enable.http.server.requests = false;\n```\n\n4. 사용자 정의 헬스 지표를 만드세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSpring Boot은 DOWN, OUT_OF_SERVICE, UP, UNKNOWN과 같은 네 가지 다른 상태 코드를 제공합니다. 이 상태 코드는 중요도 순으로 정렬되어 있어요. 클래스 패스에서 발견된 종속성에 따라 Spring Boot는 JmsHealthIndicator, DataSourceHealthIndicator, RedisHealthIndicator 등과 같은 여러 건강 지시자를 자동으로 구성할 수 있습니다. 이를 비활성화할 수도 있어요. 비즈니스 요구에 따라 특정 데이터베이스 테이블의 행 수나 대기열에 있는 메시지 수와 같은 것을 기반으로 사용자 정의 상태를 추가하고 싶을 수 있어요.\n\n건강 지시자를 생성하기 위해 HealthIndicator를 구현하거나 AbstractHealthIndicator를 확장할 수 있습니다:\n\n```java\npublic class AccountHealthIndicator implements HealthIndicator {\n\n    public final JdbcTemplate jdbcTemplate;\n\n    public AccountHealthIndicator(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Override\n    public Health health() {\n        Long count = jdbcTemplate.queryForObject(\"select count(*) from account\", Long.class);\n\n        if (count \u003e= 1) {\n            return Health.up().withDetail(\"accounts\", count).build();\n        } else {\n            return Health.status(\"NO_ACCOUNT\").withDetail(\"accounts\", count).build();\n        }\n    }\n}\n```\n\n여기서는 사용자 정의 상태인 NO_ACCOUNT를 생성합니다. 이를 적용하려면 해당 심각도 수준을 정의해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n(management.endpoint.health.status.order = NO_ACCOUNT),\n  DOWN,\n  OUT_OF_SERVICE,\n  UP,\n  UNKNOWN;\n```\n\n이제 새로 만든 Health Indicator를 위해 HealthMetrics를 생성해 보겠습니다. 이를 위해 Gauge 미터를 사용할 것입니다:\n\n```js\npublic class HealthMetrics {\n\n    private final AccountHealthIndicator accountHealthIndicator;\n    private final MeterRegistry meterRegistry;\n\n    public HealthMetrics(AccountHealthIndicator accountHealthIndicator, MeterRegistry meterRegistry) {\n        this.accountHealthIndicator = accountHealthIndicator;\n        this.meterRegistry = meterRegistry;\n    }\n\n\n    @Scheduled(fixedRate = 15000, initialDelay = 0)\n    public void reportHealth() {\n        Gauge\n                .builder(\"application.health\",\n                        () -\u003e getStatus(accountHealthIndicator.getHealth(true).getStatus())\n                )\n                .register(meterRegistry);\n    }\n\n    private int getStatus(Status status) {\n       return switch (status.getCode()) {\n            case \"NO_ACCOUNT\" -\u003e 0;\n            case \"DOWN\" -\u003e 1;\n            case \"OUT_OF_SERVICE\" -\u003e 2;\n            case \"UP\" -\u003e 3;\n            default -\u003e -1;\n        };\n    }\n}\n```\n\n이제 애플리케이션을 다시 시작하면 새로 생성된 메트릭인 application_health를 볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로메테우스를 자주 간격으로 메트릭을 스크래핑하도록 설정하기\n\n프로메테우스는 모니터링 및 경보 기술로 오픈 소스입니다. 프로메테우스를 설치하기 위해 다음 단계를 따를 수 있습니다. 기본적으로 프로메테우스는 prometheus.yml을 기본 구성 파일로 사용합니다. 아래와 같이 파일을 편집하세요:\n\n![이미지](/assets/img/2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana_0.png)\n\n여기에서 대부분의 것을 기본값으로 유지했습니다. 스크래핑 구성 아래에서 작업 이름과 대상을 업데이트했습니다. 대상은 우리의 스프링 부트 어플리케이션입니다. 프로메테우스 서버를 시작하려면 아래 명령을 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n./prometheus --web.listen-address=호스트:포트\n```\n\n상태로 이동 - `targets`. 활성화된 모든 엔드포인트를 확인할 수 있습니다:\n\n![2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana_1.png](/assets/img/2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana_1.png)\n\n실시간으로 메트릭을 시각화하는 Grafana 대시보드를 설정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로컬 시스템에 Grafana를 설치하려면 이 링크를 사용하십시오. Grafana가 작동 중이면 데이터 소스를 구성합니다. 홈 `연결` `데이터 소스` `새 데이터 소스 추가로 이동합니다. Prometheus를 선택하고 이전 단계에서 설정한 Prometheus 서버 URL을 입력하십시오. 이제 홈 `대시보드` `새 대시보드`로 이동하여 시각화를 추가해보세요. 대시보드에 추가할 시각화를 위해 다음 PromQL 쿼리를 공유할게요:\n\n(1) 상태 (Stat) - `application_health'application=\"YOGENDRA\"`을 추가하고 아래 값 매핑을 추가합니다.\n\n![이미지](/assets/img/2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana_2.png)\n\n(2) 시작 시간 (Stat) - `process_start_time_seconds'application=\"YOGENDRA\"'\\*1000\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(3) Uptime (Stat) - `process_uptime_seconds' application=\"YOGENDRA\"\n\n(4) Heap utilization (Gauge) - `sum(jvm_memory_used_bytes' application=\"YOGENDRA\", area=\"heap\")\\*100 / sum(jvm_memory_max_bytes' application=\"YOGENDRA\", area=\"heap\")'\n\n(5) CPU utilization (Time series)\n\n- A - `system_cpu_usage' application=\"YOGENDRA\"\n- B - `process_cpu_usage' application=\"YOGENDRA\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(6) HTTP 응답 시간 (시계열) - `http_response_time 'application=”YOGENDRA”, uri!=”_/actuator/_”' 여기서는 HTTP 호출이 발생한 지점만 보여줄 수 있도록 데이터를 변환합니다. 따라서 데이터 변환으로 이동하고 Group by를 선택합니다. 시간에서 Calculate를 선택하고 Stat First을 선택합니다\\*:\n\n![이미지](/assets/img/2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana_3.png)\n\n(7) HTTP 요청 횟수 (시계열) - `http_requests_count_total'application=”YOGENDRA”, uri!=”_/actuator/_”' 여기서도 reduce 함수를 사용하여 데이터를 변환합니다. 변환은 다음과 같이 보입니다:\n\n![이미지](/assets/img/2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플리케이션 코드 링크를 [여기](https://github.com/your-repository)에서 찾을 수 있어요.\n","ogImage":{"url":"/assets/img/2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana_0.png"},"coverImage":"/assets/img/2024-06-19-CustommicrometermetricsinSpringBootandscrapeandvisualiseusingPrometheusandGrafana_0.png","tag":["Tech"],"readingTime":15},{"title":"자바로 간단한 규칙 엔진 구축하기","description":"","date":"2024-06-19 22:08","slug":"2024-06-19-BuildingaSimpleRuleEngineinJava","content":"\n![Building a Simple Rule Engine in Java](/assets/img/2024-06-19-BuildingaSimpleRuleEngineinJava_0.png)\n\n소프트웨어 개발에서는 종종 데이터를 필터링하거나 처리하기 위해 일련의 규칙이나 조건을 적용해야 하는 상황이 있습니다. 전통적인 if 및 else 문을 사용하여 이러한 규칙을 관리하면 유지 관리하기 어렵고 번거로울 수 있습니다. 규칙 엔진은 이러한 규칙을 정의하고 실행하는 더 유연하고 조직화된 방법을 제공합니다. 이 기사에서는 함수형 프로그래밍 원칙을 사용하여 Java에서 간단한 규칙 엔진을 구축하는 방법을 탐색하겠습니다.\n\n준비 사항\n\n규칙 엔진을 구축하기에 앞서 필요한 구성 요소를 정의해 보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 규칙:\n\n규칙은 우리가 평가하고 싶은 조건 또는 기준을 나타냅니다. 규칙은 주어진 객체가 규칙의 기준을 충족하는지 여부를 결정하는 술어로 구성됩니다. Enum 또는 Map`key, value`를 사용하세요 (이 부분에서 Enum을 사용합니다).\n\n# 규칙 엔진:\n\n규칙 엔진은 규칙 컬렉션을 관리하고 이를 객체 집합에 적용하는 것을 담당합니다. 정의된 규칙에 기반하여 객체를 필터링하고 필터된 결과를 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 대상-객체:\n\n규칙을 사용하여 필터링하고자 하는 간단한 Person 클래스를 예시 객체로 사용하겠습니다. 이름과 나이와 같은 속성이 있습니다.\n\n# 규칙 엔진 구축하기\n\n규칙 엔진을 단계별로 구축해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n규칙 정의:\n먼저 Rule이라는 enum을 사용하여 규칙을 정의합니다. enum의 각 규칙은 우리가 평가하고 싶은 특정 조건이나 기준을 나타냅니다. 예를 들어, 코드에서 우리는 AGE_GREATER_THAN_30과 NAME_STARTS_WITH_B 두 가지 규칙을 정의했습니다. 각 규칙에는 해당 규칙의 조건을 정의하는 프레디케이트가 있습니다.\n\n```js\nimport java.util.function.Predicate;\n\n// 여러 enum을 가질 수 있어요. 이를 통해 규칙이나 조건을 관리할 수 있어요.\npublic enum Rule implements TestRule {\n    AGE_GREATER_THAN_30(person -\u003e person.getAge() \u003e 30),\n    NAME_STARTS_WITH_B(person -\u003e person.getName().startsWith(\"B\"));\n\n    private final Predicate\u003cPerson\u003e predicate;\n\n    Rule(Predicate\u003cPerson\u003e predicate) {\n        this.predicate = predicate;\n    }\n\n    public Predicate\u003cPerson\u003e getPredicate() {\n        return predicate;\n    }\n}\n```\n\nRule Engine 생성:\n다음으로 RuleEngine 클래스를 생성합니다. 이 클래스는 규칙의 관리와 실행을 처리할 것입니다. 규칙 목록을 유지하고 이러한 규칙에 기반한 새로운 규칙을 추가하고 개체를 필터링하기 위한 메서드를 제공합니다.\n\n필터링 로직 구현:\nRuleEngine 클래스의 filter 메서드에서는 개체 목록을 반복하고 Java 8 Stream API의 allMatch 메서드를 사용하여 각 규칙을 적용합니다. 이 메서드는 주어진 개체에 대해 모든 규칙이 통과되었는지 확인합니다. 모든 규칙이 통과되면 해당 개체를 필터링된 목록에 추가합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic interface TestRule {\n    \u003cT\u003e Predicate\u003cT\u003e getPredicate();\n}\n```\n\n```js\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class RuleEngine\u003cT\u003e {\n    private List\u003cTestRule\u003e rules;\n\n    public RuleEngine() {\n        this.rules = new ArrayList\u003c\u003e();\n    }\n\n    public void addRule(TestRule rule) {\n        rules.add(rule);\n    }\n\n    public List\u003cT\u003e filter(List\u003cT\u003e items) {\n        List\u003cT\u003e filteredItems = new ArrayList\u003c\u003e();\n        for (T item : items) {\n            if (rules.stream().allMatch(rule -\u003e rule.getPredicate().test(item))) {\n                filteredItems.add(item);\n            }\n        }\n        return filteredItems;\n    }\n}\n```\n\n샘플 대상 객체 만들기:\n\n```js\npublic class Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모두 함께 해보기\n\nMain 클래스에서는 우리의 규칙 엔진 사용법을 보여줍니다. Person 객체의 리스트를 생성하고 RuleEngine을 AGE_GREATER_THAN_30과 NAME_STARTS_WITH_B 두 가지 규칙으로 초기화합니다. 그런 다음 규칙 엔진의 filter 메소드를 호출하여 Person 객체의 리스트를 전달합니다. 규칙 엔진은 각 사람에게 규칙을 적용하고 필터링된 리스트를 반환합니다.\n\n마지막으로 필터링된 리스트를 반복하고 지정된 규칙을 충족하는 사람들의 이름을 출력합니다.\n\n```java\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        List\u003cPerson\u003e people = List.of(\n                new Person(\"Alice\", 25),\n                new Person(\"Bob\", 31),\n                new Person(\"Charlie\", 35)\n        );\n\n        RuleEngine\u003cPerson\u003e ruleEngine = new RuleEngine\u003c\u003e();\n        ruleEngine.addRule(Rule.AGE_GREATER_THAN_30);\n        ruleEngine.addRule(Rule.NAME_STARTS_WITH_B);\n\n        List\u003cPerson\u003e filteredPeople = ruleEngine.filter(people);\n\n        // 이 부분은 결과만 출력합니다.\n        for (Person person : filteredPeople) {\n            System.out.println(person.getName());\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 글에서는 Java로 간단한 규칙 엔진을 구축하는 방법을 살펴보았습니다. 이 규칙 엔진을 사용하면 프레디케이트를 사용하여 규칙을 정의하고 객체 컬렉션에 적용할 수 있습니다. 함수형 프로그래밍 원칙을 활용하여 유연하고 확장 가능한 규칙 엔진을 만들어 다양한 시나리오에서 사용할 수 있습니다.\n\n여기서 제시된 개념과 코드를 이해하면 이 기반을 확장하여 특정 필요에 맞는 보다 복잡한 규칙 엔진을 구축할 수 있습니다.\n\nhttps://github.com/KiaShamaei/ruleEngine\n","ogImage":{"url":"/assets/img/2024-06-19-BuildingaSimpleRuleEngineinJava_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaSimpleRuleEngineinJava_0.png","tag":["Tech"],"readingTime":6},{"title":"자바 Optional을 더 유창하게 활용하기","description":"","date":"2024-06-19 22:06","slug":"2024-06-19-UseJavaOptionalFluently","content":"\nOptional 클래스에는 filter(), map() 및 flatMap()과 같은 다양한 공개 메서드가 포함되어 있습니다. 함수형 및 유창한 프로그래밍에 유용합니다. 이 글에서는 Java Optional을 사용하여 함수형 및 유창한 프로그래밍 스타일을 탐구할 것입니다.\n\n![Java Optional](/assets/img/2024-06-19-UseJavaOptionalFluently_0.png)\n\n# Java Optional 기본 사항\n\nJava Optional의 기본 사항을 다시 확인해 봅시다. 아래는 사용자 레코드의 간단한 예시로, 사용자 ID, 이름, 주소 및 사용자가 CEO인지 여부와 같은 데이터 속성이 포함되어 있습니다. 아래는 코드에서 Optional 클래스를 사용하는 예시입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n// 사용자 레코드\nrecord User(String uid, String name,\nAddress address, boolean ceo){\n\npublic static final User DEFAULT_USER\n= new User(\"0\", \"더미\", null, false);\n\n}\n\n// 주소 레코드\nrecord Address(String line, String zip) {\n}\n\n// User 객체를 생성하는 User 팩토리 클래스\npublic class Users {\n\npublic static Optional\u003cUser\u003e getUser(String uid) {\n\n      User user = null;\n\n      // user 변수를 설정하는 로직\n\n      return Optional.ofNullable(user);\n\n}\n}\n\n// Optional 값을 반환하는 getUser 메서드를 호출하는 예시\nOptional\u003cUser\u003e oUser = Users.getUser(uid);\nif (oUser.isPresent()) {\n\n// User를 처리합니다. 비어있지 않습니다\nString name = oUser.get().name();\n}\n\n위 예시에서 Users 클래스에는 getUser(...)라는 메서드가 있는데 이 메서드는 User 타입의 Optional을 반환합니다. 이는 호출자에게 반환된 User 값이 null일 수 있다는 것을 나타냅니다. Optional 값 자체가 null이 되어선 안 됩니다.\n\nUsers.getUser(...)의 호출자는 Optional의 isPresent() 메서드를 사용하여 유효한 값이 있는지 확인하고 있다면 사용자를 처리할 것입니다. Optional 클래스를 사용하는 이점은 호출자가 null 반환 값을 처리하는 방법을 고려하게끔 만든다는 점입니다. 이로써 Null Pointer Exception을 방지하고 코드를 견고하게 만듭니다. 본질적으로 이 아이디어는 호출자가 Exception을 처리할 수 있도록 강제하는 것과 유사합니다.\n\n다수의 개발자가 사용할 라이브러리를 작성할 때 Java Optional을 반환하는 것이 권장됩니다. 모든 메서드 호출이 null을 반환할 수 있는 경우에 Optional을 반환하도록 설계하는 것은 목적이 아닙니다. 예를 들어 Java Streams API와 Spring Boot 라이브러리는 많은 곳에서 Java Optional을 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대부분의 개발자들은 Java Optional 클래스의 이러한 최소한의 기능만 사용하는 경향이 있습니다(유용한 기능입니다). 그러나 Optional 클래스의 여러 메서드 중에는 Java Optional을 사용하는 데 매우 유용한 다양한 기능적 스타일의 메서드가 숨겨져 있습니다. 이러한 메서드를 사용하면 코드를 간결하고 가독성있게 만드는 데 매우 유용합니다.\n\nOptional 객체를 함수형 스타일로 소비하는 방법을 살펴보겠습니다.\n\n# Optional을 활용한 함수형 스타일\n\nOptional 클래스는 ifPresent(..)라는 메서드를 제공하는데, 여기에 프로그래머가 포함된 객체를 처리하는 Lambda 함수(Consumer)를 제공할 수 있습니다. 아래는 예제입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 사용자를 처리하기 위해 Lamba 객체를 전달합니다\nOptional\u003cUser\u003e oUser = Users.getUser(uid);\noUser.ifPresent(user -\u003e {\n\n    // 사용자 처리\n    String name = user.name();\n    System.out.println(name);\n});\n\n// \"Optional.ifPresent\" 메서드 서명\nvoid ifPresent(Consumer\u003c? super T\u003e action)\n```\n\n여기서 코드는 ifPresent(..)를 호출하고 포함된 사용자 객체를 처리하기 위해 Consumer를 전달하고 있음을 볼 수 있습니다. 그러나 변수 oUser가 빈 Optional인 경우 - Consumer가 호출되지 않습니다. 다시 말하면, 전통적인 Java \"if\"문을 사용하는 함수 스타일입니다. ifPresent의 메서드 서명도 표시되어 있으며 Consumer 인터페이스를 사용합니다.\n\n전형적인 람다 프로그래밍의 일환으로, 람다 대신 메소드 참조를 전달할 수 있습니다. 이렇게 하면 코드가 더 읽기 쉬워집니다.\n\n```js\n// 메소드 참조를 사용한 함수형 스타일\nOptional\u003cUser\u003e oUser = Users.getUser(uid);\noUser.ifPresent(Main::handleUser);\n\n\n// Main.java의 handleUser 정적 메소드\npublic static void handleUser(User u) {\n\n    // 사용자 처리\n    String name = u.name();\n    System.out.println(name);\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 Main :: handleUser 메서드 참조가 매개변수로 전달되어 핸들러가 별도의 메서드로 격리되었습니다.\n\n만약 호출자가 전통적인 if-then-else 문을 사용하려면 어떻게 할까요?\n\n\"ifPresentOrElse(..)\" 메서드를 사용하여 가능합니다. 다음은 예시입니다\n\n```js\n// 함수형 스타일의 if-then-else.\n// 값이 존재하면 handleUser 호출\n// 그렇지 않으면 AppException이 throw됨\noUser.ifPresentOrElse(Main::handleUser, () -\u003e {\n    throw new AppException(\"Some Error\");\n});\n\n// \"Optional.ifPresentOrElse\"의 시그니처\nvoid ifPresentOrElse(\n  Consumer\u003c? super T\u003e action, Runnable emptyAction)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자가 사용 가능하면 Method Reference로 표시된 첫 번째 매개변수가 호출됩니다. 그렇지 않은 경우 두 번째 매개변수로 표시된 Runnable을 나타내는 람다 함수가 호출됩니다. 이 방법은 Optional 객체에 적용된 전통적인 Java if-then-else의 기능적 동등물입니다.\n\nOptional 클래스에는 비어있을 때 수행해야 하는 작업을 표현하는 데 유용한 여러 orXXX(..) 메서드가 있습니다.\n\n## orXXX(..) 메서드\n\norElse() 메서드를 사용한 예제입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// Optional이 비어있을 때 기본 사용자 반환\nUser user = oUser.orElse(User.DEFAULT_USER);\n```\n\n여기서 orElse(..) 메소드를 사용합니다. 해당 값이 있는 경우 user 변수에 할당되고, 그렇지 않으면 DEFAULT_USER가 할당됩니다. 이 방법은 Groovy와 같은 다른 언어의 Elvis 연산자에 해당하는 함수적 동등체입니다.\n\n그러나 기본 사용자가 상수보다 조금 복잡하고 어떤 로직에 의해 검색되어야 하는 경우는 어떨까요?\n\nOptional 클래스가 해결책을 제공합니다. orElseGet(..) 메소드를 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// Supplier를 호출하여 기본 사용자를 반환합니다.\nUser user = oUser.orElseGet(() -\u003e {\n    // 사용자를 가져오기 위한 기본 로직\n    return defUser;\n});\n```\n\n이는 Optional oUser가 비어 있을 때, Supplier Lambda 함수가 호출되어 내부 로직을 이용하여 기본 사용자를 검색합니다. Optional에는 사용자 대신 \"Optional of User\"를 공급하는 Supplier를 사용하는 or(..) 메소드도 있습니다.\n\nOptional이 비어 있을 때 예외를 throw하고 싶다면 어떻게 해야 할까요?\n\n```js\n// 가능한 경우 사용자 추출\n// 그렇지 않으면 NoSuchElementException을 throw합니다.\nUser user = oUser.orElseThrow();\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\norElseThrow() 메서드를 사용하여 사용자를 반환하거나, 가능한 경우 기본 NoSuchElementException 예외를 throw합니다.\n\n만약 Optional이 비어있는 경우 사용자 정의 예외를 throw하려면 어떻게 해야 할까요?\n\n```java\n// 사용자 추출 가능한 경우\n// 그렇지 않으면 AppException throw\nUser user = oUser.orElseThrow(\n        () -\u003e new AppException(\"에러\"));\n```\n\n우리는 매개변수로 람다(Supplier of Exception) 표현식을 전달하는 오버로드된 orElseThrow(...) 메서드를 사용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 더 좋아집니다. Optional에는 메서드 체인을 구축하는 데 유용한 메서드가 많이 있습니다.\n\n# Optional을 활용한 Fluent Style\n\n플루언트 스타일 프로그래밍은 특정 사용 사례를 표현하고 구현하는 데 메서드 체이닝을 사용합니다. 이러한 종류의 프로그래밍은 자바 스트림을 사용할 때 볼 수 있습니다. 이 스타일을 쉽게 인식할 수 있도록 다음과 비슷한 가짜 코드가 있습니다.\n\n```js\nReturnType output = object\n                       .method1(..)\n                       .method2(..)\n                       ...\n                       .methodN(..);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOptional에는 filter(..), map(..), flatMap(..)과 같은 몇 가지 메서드가 있습니다. 이러한 메서드는 유창한 스타일 개발에 사용할 수 있습니다. 이러한 메서드는 동등한 스트림 메서드와 유사하지만 하나의 값에 작용합니다. 각각 살펴보겠습니다.\n\n# map() 메서드\n\nmap() 메서드는 한 유형의 Optional을 다른 유형의 Optional로 변환합니다. 다음 코드를 고려해보세요. 이 코드는 명령형 스타일(일반적인 if문)로 사용자의 이름을 추출합니다.\n\n```js\n// 사용자의 이름 가져오기\nString name = null;\nOptional\u003cUser\u003e oUser = Users.getUser(uid);\nif (oUser.isPresent()) {\n    name = oUser.get().name();\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드에서는 사용자 ID(uid)에 해당하는 사용자 객체를 가져와서 해당 사용자의 이름을 추출하고 있습니다. 변수 name은 null이거나 유효한 문자열일 수 있습니다. Optional 세계에서는 이를 Optional`String`으로 표현하는 것이 가장 완벽한 방법입니다. 따라서 실제 요구사항은 Optional`User`를 Optional`String`(이름)으로 변환하는 것입니다. Optional.map()은 이 작업을 우리를 위해 수행해 주며, 아래와 같이 유창한 스타일을 사용하여 보여줍니다.\n\n```js\n// Optional\u003cUser\u003e -\u003e Optional\u003cString\u003e\nOptional\u003cString\u003e name\n        = Users.getUser(uid)\n               .map(User::name);\n```\n\n보시다시피, 우리는 optional에서 map() 메서드를 호출합니다. map() 메서드는 \"User 개체를 가져와 사용자 이름을 반환하는 함수\"를 인수로 취합니다. Method reference 'User::name'은 해당 함수를 표현하기 위해 전달됩니다. 따라서 여기서는 이름을 추출하기 위해 더 유창한 API를 사용하였고, 최종 결과물은 눈에 즐거운 것입니다.\n\n# filter() 메서드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 사용자가 회사의 CEO인 경우에만 유효한 이름을 가져와야 한다고 요구 사항을 약간 변경합시다. 기억하세요, 사용자 객체에 사용자가 CEO인지 여부를 나타내는 플래그가 있습니다. 명령문 스타일을 사용하여 메소드 코드는 다음과 같이 보일 것입니다.\n\n```js\n// User -\u003e name of CEO\nString name = null;\nOptional\u003cUser\u003e oUser = Users.getUser(uid);\nname = oUser.filter(User::ceo)\n              .map(User::name)\n              .orElse(null);\n```\n\n여기서는 사용자가 CEO인 경우에만 이름 필드를 설정합니다. 따라서 사용자가 CEO인지 여부를 확인하기 위해 user.ceo() 메소드를 사용한 추가적인 확인이 필요합니다. 이 명령문 스타일 프로그래밍의 문제는 원하지 않는 코드로 이어지는 여러 개의 \"if\" 문이 있어서 코드가 복잡해집니다.\n\n우리는 위의 코드를 filter()와 map()의 멋진 조합으로 대체할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// CEO만 허용하려면 filter를 사용하세요\nOptional\u003cString\u003e name\n        = Users.getUser(uid)\n               .filter(User::ceo)\n               .map(User::name);\n```\n\n여기서 Optional 사용자 객체를 얻은 후, filter(..) 메서드가 사용자가 CEO인지 확인합니다. filter() 메서드는 Predicate를 취하며, 런타임에서 이 Predicate가 true를 반환하면 filter는 다시 Optional 사용자 객체를 반환합니다. 그렇지 않으면 빈 Optional을 반환합니다. 다음 단계는 map() 메서드를 호출하는 것인데, 이는 사용자 이름을 나타내는 Optional 문자열을 반환할 것입니다.\n\nFluent 스타일 개발을 사용하면 코드의 가독성이 뚜렷하게 향상된 것을 볼 수 있습니다. Fluent 스타일의 프로그래밍은 사용에 익숙해지려면 약간의 연습이 필요합니다.\n\n# flatMap() 메서드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 flatMap() 메서드에 대해 이야기해 보겠습니다 - 이는 map() 메서드의 변형입니다. 이 메서드를 이해하기 위해 우리의 사용 사례를 약간 수정해 보겠습니다. 사용자의 이름 대신 사용자의 우편번호를 추출하고 싶다고 가정해 봅시다. 이 경우 명령형 프로그래밍에서의 첫 번째 시도는 다음과 같을 것입니다.\n\n```js\n// User -\u003e zip\nString zip = null;\nOptional\u003cUser\u003e oUser = Users.getUser(uid);\nif (oUser.isPresent()) {\n    User user = oUser.get();\n    Address address = user.address();\n    if (address != null) {\n        zip = address.zip();\n    }\n}\n```\n\n이 코드는 작동하지만 명백한 이유로 이상적이지 않습니다. 이러한 계단식 if 문을 map() 메서드를 사용하여 우아하게 제거할 수 있습니다 - 아래에서 확인할 수 있습니다.\n\n```js\nOptional\u003cString\u003e zip\n        = Users.getUser(uid)\n               .map(User::address)\n               .map(Address::zip);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러면 두 개의 메소드 — getAddress()와 getZip()를 추가하여 User와 Address의 디자인을 아래와 같이 변경한다면 어떨까요?\n\n```js\n// Record User\nrecord User(String uid, String name,\n            Address address, boolean ceo) {\n\n    public static final User DEFAULT_USER\n       = new User(\"0\", \"Dummy\", null, false);\n\n    public Optional\u003cAddress\u003e getAddress() {\n        return Optional.ofNullable(address);\n    }\n}\n\n// Record Address\nrecord Address(String line, String zip) {\n\n    public Optional\u003cString\u003e getZip() {\n        return Optional.ofNullable(zip);\n    }\n}\n```\n\n만약 map 메소드에 \"Optional 타입을 반환하는 함수\"를 전달하면, 반환된 결과는 \"Optional`Optional`타입\"이 됩니다. flatMap(..)의 사용은 연속적인 옵셔널을 플래트하게 만들어 주어 Optional`타입`으로 만들면 간편하게 작업할 수 있습니다.\n\n따라서 우리의 fluent pipeline에서 address()와 zip() 메소드 대신 getAddress()와 getZip() 메소드를 사용하는 경우, 우리는 다음과 같은 결과를 얻게 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nOptional\u003cString\u003e zip = Users.getUser(uid)\n                         .flatMap(User::getAddress)\n                         .flatMap(Address::getZip);\n```\n\n`flatMap(..)` 메소드의 사용에 주목하세요. Method Reference `User::getAddress`는 `Optional\u003cAddress\u003e`를 반환하기 때문에 `flatMap(..)`은 단순히 `Optional\u003cAddress\u003e`를 반환할 것이며, `map(..)`은 `Optional\u003cOptional\u003cAddress\u003e\u003e`를 반환했을 것입니다.\n\n# `stream()` 메소드\n\n마지막으로, `Optional`은 `stream()` 메소드도 가지고 있는데, 이 메소드는 0 또는 1개의 값을 가지는 스트림을 생성합니다. 만약 `Optional`이 비어있다면 0개의 요소를 가진 스트림을 반환하고, 유효한 값이 있는 경우 1개의 요소를 가진 스트림을 반환할 것입니다. 그런 다음 사용 가능한 스트림 메소드 중 하나를 사용하여 스트림을 함수형 스타일로 조작할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 Optional.stream() 메소드를 언제 사용해야 하는지에 대해 더 알고 싶다면, 제 Medium 기사를 읽어보세요.\n\nJava Optional을 사용할 때 따를 몇 가지 기본 규칙을 알고 싶다면, 아래의 Medium 기사를 읽어보세요.\n\n또한 Optional 클래스에 대한 Javadoc을 살펴보기 위해 아래의 링크를 이용해 주세요.\n\n이 글이 도움이 되었다면, 아래의 👏 버튼을 여러 번 클릭하여 지원을 보여주세요. 읽어주셔서 감사합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Summary\n\nOptional은 가장 간단한 형태로 사용될 수 있지만, 개발자가 유창한 스타일의 코드를 작성하는 데 도움이 되는 여러 메서드가 있습니다. 많은 경우 더 간결하고 가독성이 높으며 견고한 코드를 작성할 수 있습니다.\n\n사용을 고려해 보세요!\n","ogImage":{"url":"/assets/img/2024-06-19-UseJavaOptionalFluently_0.png"},"coverImage":"/assets/img/2024-06-19-UseJavaOptionalFluently_0.png","tag":["Tech"],"readingTime":15},{"title":"Java 제네릭을 이용한 다형 함수","description":"","date":"2024-06-19 22:03","slug":"2024-06-19-PolymorphicfunctionsusingJavagenerics","content":"\n자바 함수형 프로그래밍 구축 요소\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png)\n\n이 기사는 제네릭 유형과 함수형 인터페이스를 사용하여 자바에서 다형성 함수를 작성하는 주제를 탐구합니다. 이 기본 사항은 종종 주니어 엔지니어에 의해 고려되지 않는다. 대신 Java 8+ Stream API와 같은 더 심화된 주제로 즉시 진입하는 것을 선호합니다. 그러나 이것들은 자바에서 함수형 프로그래밍 개념을 배우고 적용하며 더 깨끗하고 재사용 가능하며 선언적인 코드를 작성하는 데 필수적인 구축 요소입니다.\n\n기사 말미에서, 저는 모든 것을 매우 유용하고 실용적인 예제로 하나로 조합할 것입니다. 이 기사가 당신에게 매우 유용하고 실질적인 예제가 될 것이라고 기대합니다. 이 기사가 당신에게 단단한 기초를 제공하고 댓글 섹션이나 스스로 더 탐구하도록 격려할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 계속 읽기 전에 주의할 점은, 이 문서가 제네릭 및 함수형 인터페이스 개념 및 구문을 배우는 초보자용 완전한 자습서로 제공되는 것이 아니라는 것입니다. 이미 Java 공식 문서 및 다양한 자습서 웹사이트에 많은 이러한 자습서가 존재합니다. 우리는 기본 사항을 빠르게 살펴볼 것이며, 이 글의 주요 목적은 왜 그리고 어떻게 실제로 유용한지 깊게 이해하려는 것입니다.\n\n## Java 제네릭의 목적\n\n그렇다면 Java 제네릭의 목적은 무엇이며, 언제 유용할까요?\n\n가장 유혹적인 말은 \"공통 부모를 공유하는 클래스가 있는 재사용 가능한 코드를 작성하기 위해서\"라고 말하는 것입니다. — 또는 이와 같은 말입니다. 경우에 따라, 그리고 어느 정도로 그렇습니다. 하지만 이것이 정확히 무엇을 의미하는지는 무엇일까요? 아래 코드 조각을 살펴봅시다. 제네릭 유형을 사용하는 좋은 이유가 될까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_1.png)\n\n답은: no입니다. 이 코드는 다음 코드 스니펫에서 강조하는 것처럼 Dog 추상화 자체로 쉽게 바꿀 수 있습니다. 이러한 경우에는 제네릭을 사용할 필요가 없습니다.\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_2.png)\n\n그렇다면, Java 제네릭이 언제 진정으로 유용한가요? 먼저, 클래스 제네릭 유형과 메서드 제네릭 유형 두 가지 유형의 일반 유형이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스 제네릭 타입은 특히 여러 클래스 API 메소드들 사이에서 타입 일관성을 유지하는 데 유용합니다. 첫 번째 예시로는 List 인터페이스가 add나 get과 같은 여러 메소드에서 동일한 클래스 제네릭 타입 E를 시그니처에 재사용하는 것이 있습니다.\n\n메소드 제네릭 타입은 Java 언어의 설계 제한을 극복하는 데 도움을 줍니다. 클래스 제네릭 타입을 사용하는 클래스는 무변(invariant)이기 때문에(공변(covariant)이 아님) 메소드 제네릭 타입은 여러 메소드 매개변수 및/또는 반환 타입에 걸쳐 특정 타입을 강제하는 데 매우 유용합니다.\n\n실무에서 무변이 무엇을 의미하는지 예를 들어 설명하자면, List`String`은 String이 Object의 하위 타입이지만 List`Object`의 하위 타입이 아니라는 것입니다. 리스트가 무변이라는 것에 주목할 만한 점은 Java에서 배열은 공변적(covariant)이기 때문에(String[]는 Object[]를 확장합니다) 이 특정 목적을 위해 제네릭 메소드 타입을 사용할 필요가 없다는 것입니다.\n\n다음 코드 스니펫에서 Java의 공변성/무변성 관련하여 어떤 것이 허용되고, 어떤 것이 안 되는지 살펴볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_3.png\" /\u003e\n\n그래서 요약하면, Java 제네릭의 주요 목적은 개발자가 여러 가지 유형에서 재사용 가능한 코드를 작성하고 일관된 계약(클래스 수준 또는 메소드 수준)을 제공하는 동안 유연하게 작동하도록 하는 것입니다.\n\n## 제한된 제네릭 유형\n\n제네릭 유형은 상한, 하한 또는 명시적 바운드가 없을 수 있습니다(Object가 상한인 경우).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한계가 없는 제네릭 유형을 탐색해 봅시다. 이 유형들은 어떤 객체 유형이든 가능하게 합니다. 주로 여러 매개변수 및/또는 반환 유형에 동일한 유형을 적용하는 데 사용됩니다. 아래 코드 예제에서 볼 수 있듯이 다른 간단한 동작도 정의할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_4.png)\n\n아마도 가장 흔한 제네릭 사용 사례 중 하나는 상위 경계 제네릭 유형을 사용하는 것입니다. 이것은 소개 섹션에서 언급한 \"일반 부모\" 상속 기반 예제입니다. 아래 예제에서 강조되어 있습니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번 멈춰서 일반적인 유형이 우리에게 무엇을 하는지 두 가지 관점에서 이해해 봅시다: 호출자의 관점과 구현의 관점에서.\n\n이 API를 사용하는 사용자로서, List`Dog`나 Dog 하위 유형(예: List`GermanSheppard`)을 사용하여 findDogByNameGeneric(...)을 호출할 수 있습니다.\n\n메서드 구현 관점에서는 경계가 있는 일반 유형 `T extends Dog` 가 우리에게 강력한 보증을 제공하는데, 이는 우리가 받는 모든 목록이 요소가 부모 유형 Dog를 공유할 것이라는 것입니다. 이는 목록이 개발자에게 메서드 내에서 사용할 수 있는 요소를 생성할 수 있게 해줍니다(즉, 여기서는 Dog 및 특히 부모 인터페이스에서 정의된 getName()을 호출하는 경우).\n\n상한이 있는 제네릭 유형 목록으로는 요소를 추가할 수 없습니다. 이것을 생각해 보면 이해할 수 있으며, 그 이유를 찾아보는 것은 시간을 들여서 한 번 곰곰히 생각할 가치가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[1초 후]\n\n상한이 정의된 제네릭 타입 목록에 요소를 추가할 수 없는 이유는 메서드 구현 내에서 호출된 목록의 실제 타입을 알 수 없기 때문입니다. 아래 예시를 살펴봅시다.\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_6.png)\n\n만약 상한이 정의된 타입에 추가할 수 있다면, List`Double` 입력 매개변수를 사용해 addSomething을 이론적으로 호출할 수 있고, 메서드 내에서 Double 목록에 Integer(또한 Number를 확장한)을 추가할 수 있습니다. 컴파일 시에 메서드가 어떤 타입으로 호출될지 알 수 없기 때문에, 언어가 목록의 타입 무결성을 잠재적으로 위반하지 못하도록 우리를 방해하는 것은 바로 이것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 우리가 일반 형식 소비자에 요소를 전달하려면(컬렉션이어야만 하는 것은 아님), 상위 바운드를 만들기 위해 super 키워드를 사용해야 합니다. 아래의 또 다른 예제를 살펴보고, 이전처럼 API 관점과 구현 관점에서 super가 우리에게 무엇을 보장해주는지 생각해봅시다.\n\n![image](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_7.png)\n\nAPI 관점에서는 populateGermanSheppards 메서드의 두 번째 매개변수는 List`GermanSheppard` 또는 그 상위 형식인 List`Dog`일 수 있습니다. 이게 구현 관점에서 왜 도움이 되는지 생각해 보세요.\n\n[또 다른 시간이 흘렀습니다]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\npopulateGermanSheppards의 구현 내에서 두 번째 입력 매개변수가 List`GermanSheppard` 또는 List`Dog` 중 하나인 것을 알 수 있습니다. 따라서 해당 목록에 GermanSheppard를 추가해도 목록의 유형 무결성을 위반하지 않습니다. 왜냐하면 입력 매개변수 목록이 List`GermanSheppard`인 경우 GermanSheppard를 추가하는 것이 단순히 유효하며, List`Dog`인 경우 GermanSheppard는 Dog이므로 유형이 여전히 유효합니다. 더불어 부모 클래스에 대해서도 동일한 원리가 적용됩니다.\n\n매번 바운드된 제네릭 유형을 생각할 필요가 없도록, 간단히 PECS라는 머릿글자를 기억하면 됩니다. PECS는 Producer-Extends Consumer-Super의 약자로, 제네릭 메소드를 사용하여 상위 바운드 유형을 가진 요소를 생성/생산하는 요소들을 생산자로 정의합니다.\n\n소비자는 요소를 받아들일 수 있는 능력과 관련이 있습니다. 예를 들어 List의 add 메소드는 요소를 받아들일 수 있기 때문에 소비자이며, 목록의 제네릭 유형을 소비자-슈퍼로 제한할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지 우리가 논의한 것은 단순한 기본 구성 요소로, Java에서 일반적인 타입이 어떻게 실제로 작동하는지의 기본 설명입니다. 더 많은 내용이 있으며, 와일드카드 및 타입 이레이저에 대해 약간 읽어보고, 컬렉션을 중심으로하지 않는 더 많은 예시(예: Optional)를 살펴보면 일반 타입에 대해 더 익숙해질 수 있습니다.\n\n그러나 순수 일반 타입을 강조하는 좋은 예제를 제공하기가 어려운데, 적어도 내게는 이러한 타입의 가장 크고 일반적으로 사용되는 장점은 함수형 인터페이스와 결합될 때입니다. 이에 대해 더 자세히 알아보겠습니다.\n\n# 함수형 인터페이스 기본 사항\n\n함수형 인터페이스는 재사용 가능한 코드를 작성할 때 우리가 가진 도구 중 하나입니다. 또한 좋은 개발자 경험을 제공하는 유연한 API를 구축하고 싶다면 바운드된 제네릭 타입을 사용하여 개선할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이론적으로 함수형 인터페이스는 오직 하나의 비디폴트 메소드만 가진 인터페이스를 말합니다(즉, 구현이 없는 메소드가 하나뿐인 경우). 이러한 인터페이스들은 Java 유형을 제공하고 람다 표현식이나 메소드 참조 같은 호출 가능한 코드 조각을 참조하는 데 사용됩니다. 이러한 참조를 다른 객체 유형처럼 사용할 수 있게 해줍니다. 함수를 참조할 수 있고, 호출하지 않고 다른 함수에 전달할 수 있습니다.\n\nJava 8부터 Java JDK 내에 여러 유형의 함수형 인터페이스가 있습니다. 가장 기본적인 것은 Function`T, R`입니다. 이는 입력 T 집합을 가져와 R 집합의 결과를 출력하는 수학 함수와 동등합니다. 다만 여기서는 유형 인스턴스를 다루고 있을 뿐입니다. 함수형 프로그래밍에서는 이를 펑터라고도 부릅니다.\n\n함수 외에도 다음과 같이 계속해서 사용되는 함수형 인터페이스 유형들이 있습니다(그들의 Bi[…]variant인 BiFunction`T, U, R`와 함께), 이미 알고 계신지 모르겠지만 익숙해지기를 권장드립니다:\n\n- Predicate`T`: Function`T, Boolean`와 같은 역할을 합니다.\n- Consumer`T`: T형 인자를 가지고 void(아무것도)를 반환하는 함수를 나타냅니다.\n- Supplier`T`: 어떠한 인자도 받지 않고 T 유형 원소를 반환하는 함수를 나타냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 많은 작업을 수행할 수 있는 메소드의 예시를 살펴봅니다. 원리적으로는 리스트의 요소를 반복하고 특정 조건에서 특정 작업을 수행합니다. 메소드 자체에서는 구체적인 내용은 정의되어 있지 않으며, 이는 꽤 추상적입니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_8.png)\n\n추가로, 제 개인적인 의견으로는 함수형 인터페이스를 사용하여 지나치게 추상화된 일반적인 함수를 작성하는 것도 코드 재사용성을 위해 코드 가독성을 너무 희생하는 경우 반대 패턴으로 간주해야 한다고 생각합니다. 둘 사이에는 균형이 필요하며, 재사용 가능한 일반적인 메소드에서 구체적이고 정당화할 수 있는 문제를 해결하도록 노력해야 합니다.\n\n조건부 요소 소비자(conditionalElementsConsumer) 메소드 시그니처가 어떻게 보일지 생각해 보세요. 일반적인 타입을 완화하고 한정적인(혹은 제한된) 일반적인 타입을 사용한다면 어떨까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n[a second of thinking passes]\n\nPECS 약자에 대해 간단히 생각해 보면, 느슨한 서명은 다음 예시와 같은 형태여야 합니다.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_9.png)\n\n새 예시에서 이전의 제한된 제네릭 유형이 새로운 케이스를 지원하기에 충분히 유연하지 못했음을 알 수 있습니다. 이 간단한 기능 인터페이스를 사용해 개념을 설명하고 있지만, 실제 프로젝트에서는 타입이 일치하도록 바꿀 수 없는 서드파티 코드의 메서드 참조와 유사한 상황을 마주하게 될 수 있습니다. 경계를 통해 제네릭 유형을 느슨하게 처리하면 이를 해결하는 데 도움이 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 지점에서 또 다른 좋은 연습은 위의 예제를 생각하고 152번 라인에서 컴파일 되는 메소드 호출의 실제 T 유형을 파악해 보는 것입니다.\n\n함수형 인터페이스의 기본을 더 깊이 들어가지는 않겠습니다. 다양한 다른 유형에 대해 이야기하는 많은 기사들과 람다 표현식, 메소드 참조에 대해 참조할 수 있는 함수형 인터페이스 유형도 있습니다.\n\n그러나 이러한 기본 개념을 조합하여 실제 유용한 재사용 가능한 코드를 만들 수 있는 방법을 강조하는 데는 조금 더 나아갈 것입니다.\n\n# 고차 함수를 통한 데코레이터\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고차 함수는 다른 함수를 매개변수로 받거나 함수를 반환하는 함수형 프로그래밍 개념을 나타냅니다.\n\n이를 생각하면, 실제로 호출하지 않고 일반 함수를 래핑하는 데코레이터와 유사한 디자인 패턴을 이론적으로 정의할 수 있습니다.\n\n많이 접하게 되는 예시 중 하나는 확인된 예외를 throw하는 함수를 처리하는 것입니다. 이는 특히 Stream API 메소드 호출 내에서 문제가 될 수 있습니다. Stream API 메소드는 예외를 throw하지 않는 함수형 인터페이스를 입력 매개변수로 사용하기 때문입니다. 물론 Vavr과 같은 라이브러리를 사용할 수도 있지만, 사용 사례가 제한적이고 종속성 목록을 작게 유지하고 싶다면 직접 래퍼/핸들러를 구축하는 것이 더 나은 옵션이 될 수 있습니다. 아래 예시에서 (인기 있는) 상황을 확인해보세요.\n\n![이미지](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_10.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 위의 코드에서 발생한 컴파일 오류는 map 메서드에서 예상되는 메서드 시그니처 (즉, Function`T, R`)와 제공된 함수가 String을 가져와 List`String`을 반환하거나 IO Exception을 던질 수 있는 함수임을 고려할 때 발생합니다 (이러한 의미로는 JDK에 기본적으로 해당 함수형 인터페이스가 없음).\n\n이러한 유형의 불일치를 다루는 비제네릭하고 간단한 방법은 발생한 예외를 별도의 메서드로 분리하여 거기서 예외를 처리하는 것입니다. 이렇게 하면 사실상 Stream::map 메서드에 대해 Function`String, List`String`` 입력 매개변수로 변환될 것이며 이는 컴파일이 될 것입니다. 그러나 제네릭 및 함수 인터페이스를 통해 코드 재사용할 수 있는 큰 기회가 있다는 것을 다음 예제에서 확인할 수 있습니다.\n\n![Example](/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_11.png)\n\n위의 코드 예제를 조금 설명해보겠습니다. 먼저, 제시된 3가지 옵션 중 어느 것을 사용하더라도 더 이상 컴파일 오류가 발생하지 않음을 관찰할 수 있습니다. 이제 map 메서드는 호출 시 예상대로 Function`Path, List`String``를 받는다고 볼 수 있는 mapSafeFunction을 수신하며, 또한 ExceptionalFunction 인터페이스를 정의할 때 코드가 완벽하게 컴파일되고 Files::readAllLines 메서드 참조가 어떤 컴파일 오류도 없이 허용됩니다. 즉, 이 문제는 예외 처리가 되지 않았던 것이 아니라 함수형 인터페이스 타입이 일치하지 않았기 때문임을 결론짓습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수학 함수에 대해 생각해보면, 입력을 받아 출력을 제공하며 예외를 throw하지 않습니다. 마찬가지로 여기서는 예외를 throw하는 함수를 throw하지 않는 함수로 변환하려고 합니다. 그렇다면 예외가 발생했을 때 어떻게 해야 할까요?\n\n이것은 완전히 개인적인 선택이었지만, 예외가 발생한 경우 결과가 없을 수도 있다는 사실을 나타내기 위해 생성된 함수가 Optional을 반환하도록 만들기를 원했습니다. 이것이 ExceptionalFunction`T, R`의 입력에 대한 반환 타입이 Function`T, Optional`R``로 되어 있는 이유입니다. 이전 Optional::map 작업이 flatmap 작업으로 변경되어 코드 전체에 매우 잘 맞는 점에 주목하면 좋습니다(Javadoc 여기를 참조하세요). 예외가 발생하면 Optional 체인이 빈 결과를 제공하며 코드는 전반적으로 매우 깨끗하고 순조롭게 따라갈 수 있습니다.\n\n(부기적으로, 예외를 완전히 억제하거나 런타임 예외로 다시 던지거나 null을 반환하는 API 디자인 선택은 개발자 경험 관점에서 객관적으로 잘못된 접근법이라고 생각합니다. 주된 주장은 계약이 그냥 틀렸다는 것이며, 예기치 않은 동작이 API를 통해 추론될 수 없다는 점이며, 코드를 읽어야만 이해할 수 있다는 것입니다.)\n\nmapSafeFunction의 구현은 Files::readAllLines 또는 예외를 throw하는 기타 함수에 적용할 수 있습니다. 이 메서드는 전체 프로젝트 전반에 걸쳐 매우 재사용 가능하며 해결하는 문제가 매우 인기가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메소드 mapSafeFunction의 구현은 특별하거나 복잡한 것은 없습니다. 우리는 예외 처리 함수를 가져와 try/catch 예외 처리 논리를 처리하고 원래 함수를 호출하는 함수를 반환합니다. 추가적으로 Consumer`Exception`은 예외 로깅이나 처리 논리를 다루기 위한 유연한 API를 제공합니다. 호출자가 slf4j를 사용하여 예외를 로깅하거나, 콘솔에 로깅하거나, 소비자 내에서 런타임 예외를 다시 던지는 것을 막는 것은 없습니다. 이 방법은 덜 번거롭고 명시적이지 않은 API에 기본값을 제공하기위해 의도적으로 오버로드되었습니다.\n\n동일한 패턴에 대한 유사한 사용 사례는 트랜잭션 관리 일 수도 있습니다. 함수가 호출되기 전에 트랜잭션을 시작하고, 끝에서 커밋하거나 예외가 발생했을 경우 롤백하는 전반적인 개념은 동일합니다.\n\n# 결론\n\n함수형 프로그래밍(또는 단순히 Java Stream API)을 이해하려면 함수형 인터페이스를 이해해야 하며, 이는 다시 제네릭 유형에 의존합니다. 이러한 주제들은 서로 긴밀하게 연결되어 있으며, 개인적인 관찰에 따르면 후자는 종종 간과됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사의 개념들은 하나씩 쉽게 이해할 수 있지만 함께 사용하면 사용할 수 있는 코드가 매우 재사용 가능하다는 것을 알 수 있습니다, 특히 예외 기능 데코레이터의 예시에서 확인할 수 있습니다. 더 많은 응용 프로그램이 있으며, 이 중 한 가지가 제 개인적인 취향입니다.\n\n이 기사가 유익했고 이러한 개념을 실험하고 일상 프로젝트에 적용해 보는 호기심을 자극했기를 바랍니다. 이러한 기본적인 자바 개념은 자바에서 함수형 프로그래밍 패턴을 배우는 데 필요한 기본 블록으로 기능하지만, 이에 대해 더 알아보도록 하겠습니다.\n\n향후 자바 개념 설명, 프레임워크 및 기타 기술 관련 콘텐츠에 구독하고 좋아요를 눌러주시기 바랍니다!\n","ogImage":{"url":"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png"},"coverImage":"/assets/img/2024-06-19-PolymorphicfunctionsusingJavagenerics_0.png","tag":["Tech"],"readingTime":15},{"title":"자바 어려운 면접 질문","description":"","date":"2024-06-19 22:01","slug":"2024-06-19-Javatrickyinterviewquestions","content":"\n![이미지](/assets/img/2024-06-19-Javatrickyinterviewquestions_0.png)\n\n안녕하세요! 오늘은 핵심 Java에 관련된 어려운 인터뷰 질문을 살펴보겠습니다. 이 자료는 면접 준비 중인 개인들을 돕기 위해 특별히 설계되었습니다. 기술 면접을 해결하거나 이해력을 향상시키려는 경우, 이 시리즈는 성공으로 향하는 여정에서 귀하에게 가치 있는 자산이 되도록 목표하고 있습니다.\n\n- 다음 코드 스니펫의 출력은 무엇입니까?\n\n```java\npublic static void main(String[] args) {\n\n    int a = 5;\n    int b = 10;\n    System.out.println(a++ + ++b);\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n질문: 16\n\n2. 이 코드 실행의 결과는 무엇입니까?\n\n```java\npublic static void main(String[] args) {\n\n  String str = null;\n  if (str instanceof String) {\n   System.out.println(\"True\");\n  } else {\n   System.out.println(\"False\");\n  }\n\n }\n```\n\n답변: False\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 다음 코드의 출력은 무엇입니까?\n\n```java\npublic static void main(String[] args) {\n\n  int x = 10;\n  int y = (x \u003e 5) ? (x \u003c 10 ? 1 : 2) : 3;\n  System.out.println(y);\n\n}\n```\n\n답: 2\n\n4. 다음 코드의 출력은 무엇입니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nint a = 10;\nSystem.out.println(a += (a = 5) * (a / 5));\n```\n\n답: 15\n\n5. 이 코드의 결과는 무엇입니까?\n\n```js\npublic static void main(String[] args) {\n\n  String s1 = \"Java\";\n  String s2 = \"Ja\" + \"va\";\n  System.out.println(s1 == s2);\n\n }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n답변: True\n\n6. 출력 결과는 무엇입니까?\n\n```java\n public static void main(String[] args) {\n\n  int[] arr = new int[5];\n  System.out.println(arr[0]);\n\n }\n\n\n답변: 0\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. 아래 코드의 출력은 무엇입니까?\n\npublic static void main(String[] args) {\n\n  int i = 0;\n  int j = i++ + ++i;\n  System.out.println(j);\n\n}\n\n답: 2\n\n8. 다음 코드는 무엇을 출력합니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\npublic static void main(String[] args) {\n\n  System.out.println(\"Hello\" == new String(\"Hello\"));\n\n }\n\n답변: False\n\n9. 아래 코드의 결과는 무엇입니까?\n\nint a = 5;\nint b = 10;\na ^= b ^= a ^= b;\nSystem.out.println(a + \"-\" + b);\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n0-5 사이의 답변입니다.\n\n10. 이 코드는 무엇을 출력합니까?\n\npublic static void main(String[] args) {\n\n  System.out.println(10 + 20 + \"30\" + 40 + 50);\n\n }\n\n답변 : 30304050\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n11. 아웃풋은 무엇인가요?\n\n public static void main(String[] args) {\n\n  String s1 = \"abc\";\n  String s2 = new String(\"abc\");\n  System.out.println(s1.equals(s2) \u0026\u0026 s1 == s2);\n\n }\n\n답: False\n\n12. 이 코드는 무엇을 출력하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```\n\njava\npublic static void main(String[] args) {\n\nInteger a = 127;\nInteger b = 127;\nSystem.out.println(a == b);\n\n}\n\n답변: True\n\n13. 다음 코드는 무엇을 출력합니까?\n\n```java\npublic static void main(String[] args) {\n\n for (int i = 0; i \u003c 3; i++) {\n  switch (i) {\n  case 0:\n   System.out.print(\"A\");\n  case 1:\n   System.out.print(\"B\");\n   break;\n  case 2:\n   System.out.print(\"C\");\n  }\n }\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 답변이 있습니다:\n\n14. 이 코드의 결과는 무엇인가요?\n\n```java\npublic static void main(String[] args) {\n\n  String a = \"apple\";\n  String b = \"apple\";\n  a = a.replace(\"p\", \"b\");\n  System.out.println(a + b);\n\n}\n```\n\n답변: abbleapple\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n15. 출력은 무엇입니까?\n\n```java\npublic static void main(String[] args) {\n\n  boolean a = true;\n  boolean b = false;\n  boolean c = a || b \u0026\u0026 !a;\n  System.out.println(c);\n\n }\n```\n\n정답: true\n\n16. 결과는 무엇입니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic static void main(String[] args) {\n\n  int x = 2;\n  int y = 0;\n  for (; y \u003c 10; ++y) {\n    if (y % x == 0)\n      continue;\n    else if (y == 8)\n      break;\n    else\n      System.out.print(y + \" \");\n  }\n\n}\n```\n\nAnswer : 1 3 5 7 9\n\n17. What will this code output?\n\n```java\npublic static void main(String[] args) {\n\n  try {\n    int a = 10 / 0;\n    System.out.println(\"This will not be printed\");\n  } catch (Exception e) {\n    System.out.println(\"Exception caught\");\n  } finally {\n    System.out.println(\"Finally block executed\");\n  }\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n답변:\n\n예외가 발생했습니다\n\n마지막으로 블록이 실행되었습니다\n\n18. 결과는 무엇입니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic static void main(String[] args) {\n\n  int a = 5;\n  int b = 10;\n  if ((a = 3) == b) {\n   System.out.println(a);\n  } else {\n   System.out.println(a + b);\n  }\n\n }\n```\n\n답변: 13\n\n19. 이 코드는 무엇을 인쇄합니까?\n\n```java\npublic static void main(String[] args) {\n\n  System.out.println(Math.min(Double.MIN_VALUE, 0.0d));\n\n }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n답변: 0.0\n\n20. 이 코드의 출력은 무엇입니까?\n\n```js\npublic static void main(String[] args) {\n\n  int a = 0;\n  System.out.println(a++ == ++a);\n\n}\n```\n\n답변: false\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n21. 이 코드는 무엇을 출력합니까?\n\n```js\npublic static void main(String[] args) {\n\n   String s1 = new String(\"xyz\");\n   String s2 = \"xyz\";\n   System.out.println(s1.intern() == s2);\n\n}\n```\n\n답: True\n\n22. 다음의 출력물은 무엇입니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경하실래요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n질문 : 6\n\n24. 다음 코드의 출력은 무엇입니까?\n\n```java\n public static void main(String[] args) {\n\n  int x = 10;\n  int y = 20;\n  int z = x += y -= x += y;\n  System.out.println(z);\n\n }\n```\n\n답변 : 0\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n25. 이 코드의 출력은 무엇입니까?\n\n```js\n public static void main(String[] args) {\n\n  int[] nums = { 1, 2, 3, 4, 5 };\n  for (int num : nums) {\n   if (num % 2 == 0) {\n    continue;\n   }\n   System.out.print(num + \" \");\n  }\n }\n```\n\n답변: 1 3 5\n\n제 글을 끝까지 읽어주셔서 감사합니다. 글에서 유익한 통찰과 지식을 얻으셨기를 진심으로 바랍니다. 글이 즐겁고 유익했다면, 친구들과 동료들과 공유해 주시기를 부탁드립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 글을 즐겨 보셨다면 팔로우, 구독 또는 박수를 부탁드립니다.\n\n다른 글들도 한번 살펴보세요.\n","ogImage":{"url":"/assets/img/2024-06-19-Javatrickyinterviewquestions_0.png"},"coverImage":"/assets/img/2024-06-19-Javatrickyinterviewquestions_0.png","tag":["Tech"],"readingTime":11},{"title":"자바 8부터 자바 21까지의 포괄적인 여정 중요 API 개선 사항의 코드 예제","description":"","date":"2024-06-19 21:56","slug":"2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements","content":"\n## 안녕하세요 친구들, 이 기사에서는 다양한 Java 버전에 대해 이야기하고 싶습니다. 나는 Java 8부터 Java 21까지의 각 버전에서 소개된 모든 중요한 기능과 API를 다루고, 좀 더 심도있는 통찰력을 얻기 위해 코딩 예제를 제시하려고 합니다.\n\n이는 Java 초보자뿐만 아니라 Java 8이나 Java 11과 같은 오래된 버전의 Java에서 작업하고 있는 Java 개발자들에게 도움이 될 것입니다. 자바 세계에서 무슨 일이 일어나고 있는지업데이트하고 싶어 하는 사람들에게 유용할 것입니다.\n\n자 그럼 시작해봅시다,\n\n![이미지](/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 특징:\n\n람다 표현식:\n\n- 익명 함수 사용으로 함수형 프로그래밍 가능.\n- 함수형 인터페이스 작성을 위한 간결한 구문.\n\n함수형 인터페이스:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 람다 표현식을 사용하는 데 도움이되는 단일 추상 메소드를 가진 인터페이스입니다.\n- @FunctionalInterface 어노테이션을 사용하여 해당 인터페이스를 표시합니다.\n\n스트림 API:\n\n- 요소 시퀀스를 처리하기 위해 Stream이라는 새로운 추상화를 소개합니다.\n- filter, map, reduce 등의 함수형 스타일 작업을 지원합니다.\n\n메소드 참조:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 람다 표현식에 대한 간편한 표기법을 제공합니다.\n- 메서드나 생성자를 :: 연산자를 사용하여 참조할 수 있습니다.\n\nOptional 클래스:\n\n- 비어 있을 수도 있고 비어 있지 않은 값을 포함할 수 있는 컨테이너 객체입니다.\n- null 체크를 더 효과적으로 처리하고 NullPointerException을 방지하는 데 도움이 됩니다.\n\n새로운 날짜 및 시간 API:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- java.time 패키지는 날짜와 시간을 다루는 보다 포괄적이고 유연한 API를 소개했습니다.\n- 이전의 java.util.Date 및 java.util.Calendar 클래스에서 발생한 다양한 문제를 해결합니다.\n\n기본 메소드:\n\n- 인터페이스에 메소드 구현을 허용합니다.\n- 기존 구현을 망가뜨리지 않고 인터페이스를 발전시키는 데 도움이 됩니다.\n\nNashorn JavaScript 엔진:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이전 Rhino JavaScript 엔진을 대체합니다.\n- 더 나은 성능을 제공하며 최신 JavaScript 표준과 더 호환됩니다.\n\nParallel Streams:\n\n- parallel() 메서드를 사용하여 스트림을 병렬 처리할 수 있습니다.\n- 특정 유형의 작업에서 멀티코어 시스템에서 성능을 향상시킵니다.\n\nCollectors:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 일반적인 축소 작업을 위한 Collectors 클래스의 유틸리티 메서드 집합을 소개합니다. 예를들어 toList(), toSet(), joining() 등이 있습니다.\n\njava.util.function 패키지의 함수형 인터페이스:\n\n- 람다 표현식을 지원하기 위해 Predicate, Function, Consumer 및 Supplier와 같은 새로운 함수형 인터페이스가 추가되었습니다.\n\n## 개선된 Process API:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 자바 9은 원시 프로세스를 더 잘 제어할 수 있도록 Process API에 개선 사항을 도입했습니다. 새로운 ProcessHandle 클래스를 사용하면 개발자가 프로세스와 관련된 정보를 얻고 상호 작용할 수 있습니다.\n\n```js\n// ProcessHandle API를 사용하여 현재 프로세스에 대한 정보 가져오기\npublic class ProcessHandleExample {\n    public static void main(String[] args) {\n        ProcessHandle currentProcess = ProcessHandle.current();\n        System.out.println(\"프로세스 ID: \" + currentProcess.pid());\n        System.out.println(\"실행 중? \" + currentProcess.isAlive());\n    }\n}\n```\n\n## 컬렉션 팩토리 메서드:\n\n- 자바 9에서는 컬렉션 인터페이스(List, Set, Map 등)에 새로운 정적 팩토리 메서드를 추가하여 이러한 컬렉션의 불변 인스턴스를 더 편리하게 생성할 수 있게 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport java.util.List;\n\npublic class CollectionFactoryMethodsExample {\n    public static void main(String[] args) {\n        // List.of() 팩토리 메서드를 사용하여 변경할 수 없는 목록 생성\n        List\u003cString\u003e colors = List.of(\"Red\", \"Green\", \"Blue\");\n        System.out.println(colors);\n    }\n}\n```\n\n## 향상된 스트림 API:\n\n- takeWhile, dropWhile, ofNullable과 같은 여러 새로운 메서드로 스트림 API가 향상되어 스트림 작업의 유연성과 기능성을 향상시켰습니다.\n\n```js\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class StreamAPIImprovementsExample {\n    public static void main(String[] args) {\n        // 예시 1: takeWhile\n        List\u003cInteger\u003e numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n        List\u003cInteger\u003e lessThanFive = numbers.stream()\n                .takeWhile(n -\u003e n \u003c 5)\n                .collect(Collectors.toList());\n\n        System.out.println(\"5보다 작은 숫자: \" + lessThanFive);\n\n        // 예시 2: dropWhile\n        List\u003cInteger\u003e greaterThanThree = numbers.stream()\n                .dropWhile(n -\u003e n \u003c= 3)\n                .collect(Collectors.toList());\n\n        System.out.println(\"3보다 큰 숫자: \" + greaterThanThree);\n\n        // 예시 3: ofNullable\n\n        // 예시 3: ofNullable\n        String value1 = \"안녕\";\n        String value2 = null;\n\n        // null이 아닌 값이 있는 예시\n        Stream.ofNullable(value1)\n                .ifPresentOrElse(v -\u003e System.out.println(\"ofNullable 예제 - null이 아닌 값: \" + v),\n                        () -\u003e System.out.println(\"ofNullable 예제 - null 값\"));\n\n        // null 값이 있는 예시\n        Stream.ofNullable(value2)\n                .ifPresentOrElse(v -\u003e System.out.println(\"ofNullable 예제 - null이 아닌 값: \" + v),\n                        () -\u003e System.out.println(\"ofNullable 예제 - null 값\"));\n\n        // null 안전한 스트림 예시\n        List\u003cString\u003e names = Arrays.asList(\"Alice\", \"Bob\", null, \"Charlie\", null, \"David\");\n        List\u003cString\u003e nonNullNames = names.stream()\n                .flatMap(name -\u003e StreamAPIImprovementsExample.nullSafeStream(name))\n                .collect(Collectors.toList());\n\n        System.out.println(\"null이 아닌 이름: \" + nonNullNames);\n    }\n\n    // 잠재적으로 null인 값을 스트림으로 만드는 헬퍼 메서드\n    private static \u003cT\u003e java.util.stream.Stream\u003cT\u003e nullSafeStream(T value) {\n        return value == null ? java.util.stream.Stream.empty() : java.util.stream.Stream.of(value);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제에서:\n\n- takeWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 가져오는 데 사용됩니다 (이 경우에는 5보다 작은 숫자).\n- dropWhile은 특정 조건이 충족될 때까지 스트림에서 요소를 삭제하는 데 사용됩니다 (이 경우에는 3 이하의 숫자).\n- ofNullable은 잠재적으로 null인 값을 사용하여 스트림을 생성하고 null 값을 필터링하여 null 이름을 제외합니다.\n\n## 인터페이스의 비공개 메서드:\n\n- Java 9의 인터페이스는 비공개 메서드를 가질 수 있습니다. 이를 통해 공통 기능을 인터페이스 내에 캡슐화하여 외부 클래스에 노출하지 않고 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 프라이빗 메서드를 가진 인터페이스\npublic interface PrivateMethodInterface {\n    default void publicMethod() {\n        // 퍼블릭 메서드에서 프라이빗 메서드 호출 가능\n        privateMethod();\n    }\n\n    private void privateMethod() {\n        System.out.println(\"인터페이스 안의 프라이빗 메서드\");\n    }\n}\n```\n\nHTTP/2 클라이언트:\n\n- Java 9에서는 HTTP/2 및 WebSocket을 지원하는 새로운 가벼운 HTTP 클라이언트가 도입되었습니다. 이 클라이언트는 예전 HttpURLConnection API보다 효율적이고 유연하게 설계되었습니다.\n\n```java\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\n\npublic class HttpClientExample {\n    public static void main(String[] args) throws Exception {\n        HttpClient httpClient = HttpClient.newHttpClient();\n        HttpRequest httpRequest = HttpRequest.newBuilder()\n                .uri(new URI(\"https://www.example.com\"))\n                .GET()\n                .build();\n\n        HttpResponse\u003cString\u003e response = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());\n        System.out.println(\"응답 코드: \" + response.statusCode());\n        System.out.println(\"응답 본문: \" + response.body());\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로컬 변수 타입 추론 (var):\n\n- 자바 10에서는 var 키워드를 사용하여 로컬 변수 타입 추론 기능을 도입했습니다. 이를 통해 개발자는 타입을 명시적으로 지정하지 않고 로컬 변수를 선언할 수 있으며, 할당된 값에 기반하여 컴파일러가 추론하도록 합니다.\n\n```js\npublic class LocalVarInference {\n\n    /**\n     * 허용: 로컬 변수로만 사용\n     * 허용되지 않음: 클래스 필드, 메소드 매개변수 등 다른 곳 (멤버 변수, 여타곳)\n     * var 키워드 책임있게 사용하는 것이 좋습니다!\n     *\n     * 사용 사례:\n     *  - 타입이 명확한 경우 (문자열, 정수)\n     *  - 너무 긴, 복잡한 타입을 줄이기 위하여\n     *\n     * 사용하지 말아야 할 때:\n     *      - 반환 값이 명확하지 않은 경우 (var data = service.getData();)\n     */\n\n    public static void main(String[] args) {\n\n        // 허용되지만 장점이 별로 없음\n        var b = \"b\";\n        var c = 5; // int\n        var d = 5.0; // double\n        var httpClient = HttpClient.newHttpClient();\n\n        // 추론할때 쉬운 경우 :)\n        var list = List.of(1, 2.0, \"3\");\n\n        // 이름이 긴 타입일 때 장점이 더욱 분명해집니다\n        var reader = new BufferedReader(null);\n        // vs.\n        BufferedReader reader2 = new BufferedReader(null);\n    }\n}\n```\n\nOptional API - 새로운 메소드가 도입되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class OptionalApi {\n\n    /**\n     * 새로운 .orElseThrow() 메서드\n     */\n    public static void main(String[] args) {\n\n        Optional\u003cFlight\u003e earliestFlight = FlightSchedule.getFlights()\n                .stream()\n                .filter(f -\u003e \"Boston\".equals(f.from()))\n                .filter(f -\u003e \"San Francisco\".equals(f.to()))\n                .min(comparing(Flight::date));\n\n        earliestFlight.orElseThrow(FlightNotFoundException::new);\n    }\n}\n```\n\nHTTP client\n\n```java\npublic class HttpClientBasicExample {\n\n    /**\n     * 클라이언트 생성, GET 요청 보내기, 응답 정보 출력\n     */\n    public static void main(String... args) throws Exception {\n        HttpClient client = HttpClient.newHttpClient();\n\n        HttpRequest request =\n                HttpRequest.newBuilder(URI.create(\"https://github.com/\"))\n                        .GET()  // 기본값, 생략 가능\n                        .build();\n\n        HttpResponse\u003cString\u003e response =\n                client.send(request, HttpResponse.BodyHandlers.ofString());\n\n        print(\"상태 코드: \" + response.statusCode());\n\n        print(response.headers().map());\n    }\n}\n```\n\n## 새로운 파일 메서드:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJava 11에서는 java.nio.file 패키지에 여러 가지 새로운 메서드가 추가되었는데, 파일 및 디렉토리 작업에 대한 추가 기능을 제공합니다. 주목할 만한 몇 가지 메서드는 다음과 같습니다:\n\n- Files.readString(Path path) 및 Files.writeString(Path path, CharSequence content, OpenOption... options):\n\n- 이러한 메서드를 사용하여 파일의 내용을 문자열로 읽고 쓰는 작업을 간단하게 처리할 수 있습니다. readString 메서드는 파일의 전체 내용을 문자열로 읽어오고, writeString 메서드는 문자열을 파일에 씁니다.\n\n2. Files.readAllLines(Path path) 및 Files.write(Path path, Iterable\u003c? extends CharSequence\u003e lines, OpenOption... options):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이러한 메서드는 파일 내용을 문자열 목록으로 읽고 쓰는 작업을 간단하게 해줍니다. readAllLines 메서드는 파일에서 모든 줄을 목록으로 읽고, write 메서드는 문자열 컬렉션을 파일에 쓰기 위한 메서드입니다.\n\n3. Files.newBufferedReader(Path path) 및 Files.newBufferedWriter(Path path, OpenOption... options):\n\n- 이러한 메서드는 파일을 효율적으로 읽고 쓰기 위한 버퍼드 리더와 라이터를 생성합니다. 이들은 문자 스트림을 다루는 프로세스를 간단하게 합니다.\n\n4. files.mismatch(Path path1, Path path2):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이 메서드는 두 파일의 내용을 비교하여 첫 번째 불일치하는 바이트의 위치를 반환합니다. 파일이 동일한 경우 -1을 반환합니다.\n\n```js\npublic class NewFilesMethods {\n\n    static String filePath = System.getProperty(\"user.dir\") + \"/src/main/resources/\";\n    static String file_1 = filePath + \"file_1.txt\";\n\n    /**\n     * Files.readString() and .writeString()\n     */\n    public static void main(String[] args) throws IOException {\n\n        // 파일 읽기가 이제 훨씬 쉬워졌습니다.\n        // 대용량 파일과 사용하면 안됨\n        Path path = Paths.get(file_1);\n        String content = Files.readString(path);\n        print(content);\n\n        Path newFile = Paths.get(filePath + \"newFile.txt\");\n        if(!Files.exists(newFile)) {\n            Files.writeString(newFile, \"some str\", StandardOpenOption.CREATE);\n        } else {\n            Files.writeString(newFile, \"some str\", StandardOpenOption.TRUNCATE_EXISTING);\n        }\n    }\n}\n```\n\n## 콤팩트 숫자 포맷팅:\n\nJava 12에서 JEP 357의 일환으로 \"콤팩트 숫자 포맷팅\"이라는 새로운 기능이 소개되었습니다. 이 개선은 지역별 방식으로 대형 숫자를 더 간결하게 포맷하는 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\njava.text 패키지의 NumberFormat 클래스가 새로운 Style enum을 지원할 수 있도록 업데이트되었습니다. 이 Style에는 Style.SHORT 및 Style.LONG 상수가 포함되어 있습니다. 이러한 스타일은 특정 로케일에 기반해 큰 숫자를 간결한 형태로 포맷하는 데 사용할 수 있습니다.\n\n```java\nimport java.text.NumberFormat;\nimport java.util.Locale;\n\npublic class CompactNumberFormattingExample {\n    public static void main(String[] args) {\n        // 컴팩트 스타일의 숫자 포매터 생성\n        NumberFormat compactFormatter = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT);\n\n        // 큰 숫자 형식화\n        System.out.println(\"Short Format: \" + compactFormatter.format(1000));  // 결과: 1K\n        System.out.println(\"Short Format: \" + compactFormatter.format(1000000));  // 결과: 1M\n\n        // 긴 형식의 컴팩트 스타일 숫자 포매터 생성\n        NumberFormat compactLongFormatter = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.LONG);\n\n        // 긴 스타일로 큰 숫자 형식화\n        System.out.println(\"Long Format: \" + compactLongFormatter.format(10000000));  // 결과: 10 million\n        System.out.println(\"Long Format: \" + compactLongFormatter.format(1000000000));  // 결과: 1 billion\n    }\n}\n```\n\n## String::indent (JEP 326):\n\n- Java 12의 String 클래스에는 indent(int n)이라는 새로운 메서드가 도입되었습니다. 이 메서드는 문자열의 각 줄의 들여쓰기를 지정된 공백 수만큼 조정하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nString indentedString = \"Hello\\nWorld\".indent(3);\n// indentedString이 이제 \"   Hello\\n   World\"가 됩니다.\n```\n\njava.util.Arrays에 추가된 새로운 메서드 (JEP 326):\n\n- Java 12에서는 java.util.Arrays 클래스에 copyOfRange 및 Comparator를 사용하는 equals 변형 등을 포함한 여러 새로운 메서드가 추가되었습니다.\n\njava.util.stream.Collectors의 개선 사항 (JEP 325):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Java 12에서 도입된 Collectors 유틸리티 클래스에는 teeing과 같은 새로운 수집기가 추가되었는데, 이를 사용하면 두 개의 수집기를 결합하여 하나의 수집기로 만들 수 있습니다.\n\n## 새로운 파일 메소드:\n\n```js\npublic class NewFilesMethod {\n\n    static String filePath = System.getProperty(\"user.dir\") + \"/src/main/resources/\";\n    static String file_1 = filePath + \"file_1.txt\";\n    static String file_2 = filePath + \"file_2.txt\";\n\n    public static void main(String[] args) throws IOException {\n\n        // 두 파일의 내용에서 첫 번째 불일치하는 바이트의 위치를 찾아 반환합니다.\n        // 불일치가 없는 경우 -1L을 반환합니다.\n        long result = Files.mismatch(Paths.get(file_1), Paths.get(file_2));\n\n        print(result);      // -1\n    }\n}\n```\n\n특별히 흥미로운 일은 없었습니다:\n\n- ByteBuffer에 대한 API 업데이트\n- 지역화 업데이트 (새로운 문자 및 이모지 지원)\n- GC 업데이트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## “Switch Expressions” (SE) 대신 “Switch Statements” (SS):\n\n향상된 Switch 표현식:\n\n- Java 12에서 미리보기 기능으로 소개되었으며 Java 13에서 최종화된 스위치 표현식은 개발자들이 switch 문을 표현식으로 사용할 수 있도록 해주어 더 간결하고 표현력 있는 구문을 제공합니다.\n\n```java\nint dayOfWeek = 2;\nString dayType = switch (dayOfWeek) {\n    case 1, 2, 3, 4, 5 -\u003e \"평일\";\n    case 6, 7 -\u003e \"주말\";\n    default -\u003e throw new IllegalArgumentException(\"유효하지 않은 요일: \" + dayOfWeek);\n};\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"수확\" 문장:\n\n- \"수확\" 문장은 스위치 표현식을 보완하기 위해 Java 14에서 소개되었습니다. 이를 사용하여 스위치 암에서 반환할 값을 지정할 수 있어, 명령형과 함수형 스타일을 융합하는 데 더 많은 유연성을 제공합니다.\n\n```js\nString dayType = switch (dayOfWeek) {\n    case 1, 2, 3, 4, 5 -\u003e {\n        System.out.println(\"근무일\");\n        yield \"평일\";\n    }\n    case 6, 7 -\u003e {\n        System.out.println(\"주말\");\n        yield \"주말\";\n    }\n    default -\u003e throw new IllegalArgumentException(\"유효하지 않은 요일: \" + dayOfWeek);\n};\n```\n\n또 다른 예시,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n/**\n * \"스위치 표현식\" (SE) 대신 \"스위치 문\" (SS)\n * (둘 다 사용할 수 있지만 SE가 SS보다 낫습니다)\n */\npublic class SwitchExpressions {\n\n    public static void main(String[] args) {\n\n        oldStyleWithBreak(FruitType.APPLE);\n\n        withSwitchExpression(FruitType.PEAR);\n\n        switchExpressionWithReturn(FruitType.KIWI);\n\n        switchWithYield(FruitType.PINEAPPLE);\n    }\n\n    // 예전 방식은 더 복잡하고 오류 발생 가능성이 높음 (\"break;\"을 잊으면 switch가 지나가버릴 수 있음)\n    private static void oldStyleWithBreak(FruitType fruit) {\n        print(\"==== break를 사용한 예전 방식 ====\");\n        switch (fruit) {\n            case APPLE, PEAR:\n                print(\"보통 과일\");\n                break;\n            case PINEAPPLE, KIWI:\n                print(\"이국적인 과일\");\n                break;\n            default:\n                print(\"정의되지 않은 과일\");\n        }\n    }\n\n    private static void withSwitchExpression(FruitType fruit) {\n        print(\"==== 스위치 표현식을 사용한 방식 ====\");\n        switch (fruit) {\n            case APPLE, PEAR -\u003e print(\"보통 과일\");\n            case PINEAPPLE -\u003e print(\"이국적인 과일\");\n            default -\u003e print(\"정의되지 않은 과일\");\n        }\n    }\n\n    private static void switchExpressionWithReturn(FruitType fruit) {\n        print(\"==== 반환 값이 있는 경우 ====\");\n\n        // 직접 \"return switch\"을 사용할 수도 있음\n        String text = switch (fruit) {\n            case APPLE, PEAR -\u003e \"보통 과일\";\n            case PINEAPPLE -\u003e \"이국적인 과일\";\n            default -\u003e \"정의되지 않은 과일\";\n        };\n        print(text);\n    }\n\n    /**\n     * \"Yield\"는 \"return\"과 비슷하지만 중요한 차이가 있음:\n     * \"yield\"는 값을 반환하고 switch 문을 종료함. 실행은 특정 메서드 내에서 유지됨\n     * \"return\"은 switch문 및 특정 메서드를 종료함\n     */\n    // https://stackoverflow.com/questions/58049131/what-does-the-new-keyword-yield-mean-in-java-13\n    private static void switchWithYield(FruitType fruit) {\n        print(\"==== yield를 사용한 경우 ====\");\n        String text = switch (fruit) {\n            case APPLE, PEAR -\u003e {\n                print(\"주어진 과일은: \" + fruit);\n                yield \"보통 과일\";\n            }\n            case PINEAPPLE -\u003e \"이국적인 과일\";\n            default -\u003e \"정의되지 않은 과일\";\n        };\n        print(text);\n    }\n\n    public enum FruitType {APPLE, PEAR, PINEAPPLE, KIWI}\n}\n```\n\n## 텍스트 블록\n\n텍스트 블록은 여러 줄에 걸친 문자열 리터럴을 나타내는 새로운 유형의 리터럴입니다. 여러 줄에 걸친 소스 코드의 문자열을 작성하고 유지하는 작업을 간단하게 만들면서 이스케이프 시퀀스를 피하려고 합니다.\n\n텍스트 블록을 사용하지 않은 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nString html = \"\"\"\n\u003chtml\u003e\n    \u003cbody\u003e\n        \u003cp\u003eHello, world\u003c/p\u003e\n    \u003c/body\u003e\n\u003c/html\u003e\n\"\"\";\n```\n\n텍스트 블록의 주요 기능은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 여러 줄 문자열: 텍스트 블록을 사용하면 여러 줄 문자열을 더 자연스럽게 표현할 수 있어 코드 가독성을 향상시킵니다.\n- 공백 제어: 각 줄의 시작과 끝 공백이 제거되어 들여쓰기를 더 잘 제어할 수 있습니다.\n- 이스케이프 시퀀스: 텍스트 블록 내에서 이스케이프 시퀀스는 여전히 유효하며 특수 문자를 포함할 수 있습니다.\n\n텍스트 블록은 HTML, XML, JSON 또는 SQL 쿼리와 같은 여러 줄 콘텐츠를 포함하는 문자열을 더 쉽게 표현할 수 있도록 설계되었습니다. Java 15나 이후 버전에서 텍스트 블록과 관련된 업데이트나 새로운 기능이 있었을 경우 해당 버전의 공식 문서나 릴리스 노트를 확인하는 것이 좋습니다.\n\n```js\n/**\n * TextBlocks에 대한 사용 사례 (Java 15의 새로운 기능 \u003e Text Blocks in Practice)\n * - 마크다운을 사용한 텍스트 블록\n * - 테스트, 하드 코딩된 JSON 문자열 정의\n * - 간단한 템플릿\n */\npublic class TextBlocks {\n\n    public static void main(String[] args) {\n        oldStyle();\n        emptyBlock();\n        jsonBlock();\n        jsonMovedEndQuoteBlock();\n        jsonMovedBracketsBlock();\n    }\n\n    private static void oldStyle() {\n        print(\"******** 기존 스타일 ********\");\n\n        String text = \"{\\n\" +\n                \"  \\\"name\\\": \\\"John Doe\\\",\\n\" +\n                \"  \\\"age\\\": 45,\\n\" +\n                \"  \\\"address\\\": \\\"Doe Street, 23, Java Town\\\"\\n\" +\n                \"}\";\n        print(text);\n    }\n\n    private static void emptyBlock() {\n        print(\"******** 빈 블록 ********\");\n        String text = \"\"\"\n                \"\"\";\n        print(\"|\" + text + \"|\");\n    }\n\n    private static void jsonBlock() {\n        print(\"******** JSON 블록 ********\");\n\n        String text = \"\"\"\n                {\n                  \"name\": \"John Doe\",\n                  \"age\": 45,\n                  \"address\": \"Doe Street, 23, Java Town\"\n                }\n                \"\"\"; // \u003c-- 첫 번째 \" 문자와 정렬되어 있으면 들여쓰기 없음\n        print(text);\n    }\n\n    private static void jsonMovedEndQuoteBlock() {\n        print(\"******** JSON 이동된 끝 따옴표 블록 ********\");\n\n        String text = \"\"\"\n                  {\n                    \"name\": \"John Doe\",\n                    \"age\": 45,\n                    \"address\": \"Doe Street, 23, Java Town\"\n                  }\n                       \"\"\";\n        print(text);\n    }\n\n    private static void jsonMovedBracketsBlock() {\n        print(\"******** JSON 이동된 괄호 블록 ********\");\n\n        String text = \"\"\"\n                  {\n                    \"name\": \"John Doe\",\n                    \"age\": 45,\n                    \"address\": \"Doe Street, 23, Java Town\"\n                  }\n                \"\"\"; // \u003c-- 세 번째 \" 문자와 정렬되어 2칸 들여쓰기\n        print(text);\n    }\n}\n```\n\n## instanceof에 대한 패턴 매칭:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바 16의 instanceof에 대한 패턴 매칭은 유용한 기능으로 형식 검사와 추출을 개선합니다. 여기에 이 기능의 주요 측면을 요약해 두었어요:\n\n기능:\n\n- 단일 형식 대신 타입 패턴을 소개합니다.\n- instanceof 검사 내에서 추출된 객체를 보유할 변수를 선언할 수 있습니다.\n- 형식 검사 및 캐스팅을 더 간결하고 가독성 있게 결합한 표현입니다.\n\n혜택:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 번거로운 코드 줄이기: 별도의 instanceof 확인, 형 변환 및 변수 선언이 필요 없게 합니다.\n- 가독성 향상: 코드가 더 명확해지고 복잡한 유형 계층 구조에 대해 이해하기 쉬워집니다.\n- 오류 감소: 잘못된 유형으로 인한 캐스트 예외 발생 가능성이 줄어듭니다.\n\n구문\n\n```javascript\nif (obj instanceof String s) {\n  // 여기서 \"s\"를 String으로 직접 사용\n} else if (obj instanceof List\u003cInteger\u003e list) {\n  // 여기서 \"list\"를 List \u003cInteger\u003e로 직접 사용\n} else {\n  // 다른 경우 처리\n}\n```\n\n예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class PatternMatchingForInstanceof {\n\n    public static void main(String[] args) {\n\n        Object o = new Book(\"Harry Potter\", Set.of(\"Jon Doe\"));\n\n        // 옛날 방식\n        if (o instanceof Book) {\n            Book book = (Book) o;\n            print(\"The book's author(s) are \" + book.getAuthors());\n        }\n\n        // 새 방식\n        if (o instanceof Book book) {\n            print(\"The book's author(s) are \" + book.getAuthors());\n        }\n\n    }\n}\n```\n\n## 레코드:\n\n자바의 레코드는 변경할 수 없는 데이터를 보관하기 위해 특별히 설계된 특수한 유형의 클래스입니다. 이는 단순한 데이터 구조를 처리할 때 보일러플레이트 코드를 줄이고 가독성 및 유지보수성을 향상시킬 수 있도록 도와줍니다.\n\n- 이들의 주요 특성을 살펴봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 간결함:\n\n- 기존 클래스와는 달리 레코드는 정의하는 데 필요한 코드가 최소화됩니다. 레코드 선언에서 데이터 필드(구성 요소)만 지정하면 됩니다. 그러면 컴파일러가 다음과 같은 필수 메서드를 자동으로 생성합니다:\n- 각 구성 요소에 대한 매개변수가 있는 생성자.\n- 각 구성 요소에 대한 게터.\n- 구성 요소 값을 기반으로 한 equals 및 hashCode 메서드.\n- 레코드의 상태를 나타내는 toString 메서드.\n\n2. 변경 불가능성:\n\n- 레코드 필드는 final로 선언되어 있어, 레코드가 생성된 후에는 그 내부에 저장된 데이터를 변경할 수 없습니다. 이는 데이터 일관성을 보장하고 스레드 안전성에 대한 고려사항을 단순화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 가독성:\n\n- 레코드의 자동 생성 메서드와 예측 가능한 동작은 코드 가독성을 향상시키고 레코드가 어떤 것을 나타내며 프로그램의 다른 부분과 어떻게 상호 작용하는지 이해하기 쉽게 만듭니다.\n\n4. 오류 감소:\n\n- 보일러플레이트를 최소화함으로써 레코드는 getter를 잊거나 equals를 잘못 구현하는 것과 같은 일반적인 실수의 위험을 줄입니다. 이는 더 견고하고 신뢰할 수 있는 코드로 이어집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전반적으로 레코드는 Java 개발자가 간결하고 불변 그리고 가독성 좋은 데이터 구조를 만드는 데 유용한 도구입니다. 이는 보다 깔끔하고 유지보수 가능한 코드를 유도합니다.\n\n```js\n/**\n * 레코드는 데이터 전용 불변 클래스입니다 (따라서 특정한 사용 사례가 있음)\n * 클래스의 특정 형태(예: enum과 같은)로 제한된(전문화된) 형태입니다\n * 상태 변경 등을 의도한 객체에는 적합하지 않습니다.\n * \u003cp\u003e\n * 레코드는 다음과 관련이 없습니다:\n * - 보일러플레이트 감소 기법\n * \u003cp\u003e\n * 레코드는 생성자, 게터, 필드; equals, hashCode, toString을 생성합니다\n * \u003cp\u003e\n * 사용 사례:\n * - 불변 데이터 모델링\n * - 데이터를 읽기 전용으로 메모리에 보관\n * - DTOs - 데이터 전송 객체\n */\npublic class RecordsDemo {\n\n    public static void main(String[] args) {\n        Product p1 = new Product(\"우유\", 50);\n        Product p2 = new Product(\"우유\", 50);\n\n        print(p1.price()); // \"get\" 접두사 없이 사용\n        print(p1);         // 자동으로 생성된 toString() 출력- Product[name=우유, price=50]\n\n        print(p1 == p2);       // false    - 다른 객체\n        print(p1.equals(p2));  // true     - 값들(milk, 50)은 auto-generated equals()/hashCode()에 의해 비교됨\n    }\n}\n\n/**\n * 매개변수를 \"Components\"라고 함\n * 더 많은 필드 원할 시, 시그니처에 추가 필요\n * 확장은 허용되지 않지만 인터페이스 구현은 가능\n */\npublic record Product(String name, int price) {\n\n    // 정적 필드는 가능하지만 비정적은 허용하지 않음\n    static String country = \"US\";\n\n    // 모든 필드를 가진 생성자가 생성됨\n\n    // Validation 추가 가능\n    public Product {\n        if(price \u003c 0) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    // toString()과 같은 auto-generated 메소드들 오버라이딩 가능\n}\n```\n\n## 날짜 및 시간 형식 API:\n\n- Java 16의 DateTimeFormatter API의 일반적 사용법 및 기능: 형식 패턴 이해, 사용자 정의 형식 생성, 날짜 및 시간 구문 분석, 사용 가능한 형식 설정 포함\n- Java 16에서 소개된 날짜 형식팅을 위한 새로운 기능: 특히 \"B\" 심볼과 다양한 스타일을 사용한 일시 지원\n- SimpleDateFormat과 같은 이전 서식기와 DateTimeFormatter의 비교: 각 접근 방식의 장단점 탐색\n- 특정 형식 작업에 DateTimeFormatter 사용 예제: 다양한 로케일에서 날짜 형식화, 타임존 처리, 더 사람이 이해하기 쉬운 표현 생성하기 등을 포함하여.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class DateTimeFormatterApi {\n\n    static Map\u003cTextStyle, Locale\u003e map = Map.of(\n            TextStyle.FULL, Locale.US,\n            TextStyle.SHORT, Locale.FRENCH,\n            TextStyle.NARROW, Locale.GERMAN\n    );\n\n    public static void main(String[] args) {\n\n        for (var entry : map.entrySet()) {\n\n            LocalDateTime now = LocalDateTime.now();\n            DateTimeFormatter formatter = new DateTimeFormatterBuilder()\n                    .appendPattern(\"yyyy-MM-dd hh:mm \")\n                    .appendDayPeriodText(entry.getKey())    // at night, du soir, abends, etc.\n                    .toFormatter(entry.getValue());\n\n            String formattedDateTime = now.format(formatter);\n            print(formattedDateTime);\n        }\n    }\n}\n```\n\n## Stream API의 변경 사항:\n\nJava 16에서 Stream API에 흥미로운 변경 사항이 있었습니다. 더욱 강력하고 편리하게 사용할 수 있게 되었습니다. 주요 하이라이트는 다음과 같습니다:\n\n1. Stream.toList() 메서드: 이 새로운 메서드는 스트림의 요소를 목록으로 수집하는 간결한 방법을 제공합니다. 이전에는 collect(Collectors.toList())를 사용해야 했지만, 이제는 약간 중복된 방법입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Stream.mapMulti() 메소드: 이 메소드를 사용하면 스트림의 각 요소를 제로 또는 그 이상의 요소로 매핑하여 결과 요소의 새로운 스트림을 생성할 수 있습니다. 복잡한 데이터 구조를 분할하거나 펼치는 데 편리합니다.\n\n3. 향상된 줄 바꿈 처리: Java 16에서 java.io.LineNumberReader 클래스에서 줄 바꿈자를 정의하는 방법을 명확히하였습니다. 이는 모순을 제거하고 줄 기반 데이터를 읽을 때 일관된 동작을 보장합니다.\n\n4. 기타 작은 변경점:\n\n- 이제 문자열 스트림은 중간 작업이 필요하지 않고 limit 및 skip 메소드를 직접 지원합니다.\n- peek 메소드를 병렬 스트림과 함께 사용할 수 있으므로 병렬성에 영향을주지 않고 부작용을 발생시킬 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class StreamApi {\n\n    public static void main(String[] args) {\n\n        List\u003cInteger\u003e ints = Stream.of(1, 2, 3)\n                .filter(n -\u003e n \u003c 3)\n                .toList();  // new, instead of the verbose .collect(Collectors.toList())\n\n        ints.forEach(System.out::println);\n\n    }\n}\n```\n\n## Sealed classes(Subclassing):\n\nSealed 클래스는 Java 17 (JEP 409)에서 소개된 새로운 기능으로 상속 계층구조에 대해 더 많은 제어를 제공합니다. 본질적으로 클래스나 인터페이스를 확장하거나 구현하는 것을 제한할 수 있습니다. 이는 다양한 이유로 매우 유용할 수 있습니다:\n\n1. 향상된 타입 안전성: 허용된 하위 클래스를 명시함으로써 코드를 손상시키거나 보안 취약점을 도입할 수 있는 예기치 않은 확장을 방지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 개선된 라이브러리 디자인: 라이브러리 내에서 폐쇄된 생태계를 만들 수 있어서, 사용자가 승인된 확장 기능만 사용하고 호환되지 않는 구현을 만들지 않도록 보장할 수 있습니다.\n\n3. 쉬운 코드 유지 관리: 가능한 서브클래스 집합을 정확히 알면 코드에 대한 추론이 간단해지며 이해와 유지보수가 쉬워집니다.\n\nsealed 클래스는 어떻게 작동합니까?\n\nsealed 키워드를 사용하여 클래스 또는 인터페이스를 sealed로 선언합니다. 그런 다음 permits 절을 사용하여 확장하거나 구현할 수 있는 클래스 목록을 지정합니다. 이 허용된 클래스만 직접 상속할 수 있고, 다른 모든 클래스는 금지됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsealed class Shape {\n  permits Circle, Square, Triangle;\n  // ... 구현 세부사항\n}\n\nclass Circle extends Shape {\n  // ...\n}\n\n// 사각형이 허용되지 않아 컴파일 오류가 발생합니다\nclass Rectangle extends Shape {\n  // ...\n}\n```\n\n봉인된 클래스나 인터페이스는 지정된 클래스와 인터페이스만이 상속하거나 구현할 수 있습니다.\n\n이점:\n\n- 1. 의도를 전달하여 잘 정의되고 제한된 가능한 구현을 강제화할 수 있음\n- 2. 더 나은 보안 — 제 3자 코드로부터의 예기치 않은 또는 무단 서브클래싱과 행위 예방을 돕습니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n규칙:\n\n- 1. sealed 클래스는 \"permits\"를 사용하여 다른 클래스가 하위 클래스로 지정될 수 있게 합니다.\n- 2. 하위 클래스는 반드시 final, sealed 또는 non-sealed 이어야 합니다. (그렇지 않으면 코드가 컴파일되지 않습니다)\n- 3. 허용된 하위 클래스는 상위 sealed 클래스를 확장해야 합니다. permit을 사용하지 않고 허용하는 것은 허용되지 않습니다.\n- 4. permits로 지정된 클래스들은 상위 클래스와 근접하게 위치해야 합니다:\n  - 동일한 모듈에 있어야 합니다 (상위 클래스가 명명된 모듈에 있는 경우) (Java 9 모듈화 참조)\n  - 동일한 패키지에 있어야 합니다 (상위 클래스가 무명 모듈에 있는 경우).\n\n4번 항목에 대한 더 자세한 내용:\n\n- Sealed 클래스와 그 (직접적인) 하위 클래스는 함께 컴파일되고 유지되어야 하기 때문에 밀접하게 결합됩니다.\n- 모듈화된 환경에서는 \"동일한 모듈\"; 모듈화되지 않은 환경에서는 이를 가장 잘 나타내는 것이 \"동일한 패키지\"입니다.\n- 모듈을 사용한다면 모듈이 제공하는 안전한 경계 때문에 몇 가지 추가적인 유연성을 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 기본 UTF-8 설정:\n\nJava 18에서는 플랫폼의 기본 문자 인코딩이 UTF-8로 변경되었습니다. 이는 현대 표준에 맞추어 문자 처리를 간소화하고 있습니다.\n\n```js\npublic class Utf8ByDefault {\n\n    // https://openjdk.org/jeps/400 - Platform Default Encoding\n\n    public static void main(String[] args) throws IOException {\n\n        // 문제:\n        // 1) 윈도우에서는 아스키 테이블 외의 문자, 예를 들어 특이한 유니코드 문자,을 지정하지 않고 FileWriter을 사용하여 쓰기\n        // 2) 파일을 맥과 같은 UNIX 기반 OS로 복사하거나 전송한 다음 시스템의 기본 문자 인코딩을 사용하여 파일을 읽음\n        // 3) 예상되는 결과 - 엉망인 출력\n        // 따라서 문제는 예측불가능한 동작입니다.\n        FileWriter writer = new FileWriter(\"out.txt\");\n\n        // Java 18 이전의 해결책: 항상 문자 집합을 지정하십시오 (그리고 그것을 잊지 않도록 행운을 빕니다!)\n        FileWriter writer2 = new FileWriter(\"out.txt\", StandardCharsets.UTF_8);\n\n        // Java 18부터의 해결책: UTF-8은 이제 기본값이므로 문자 집합을 지정할 필요가 없습니다.\n\n    }\n}\n```\n\n## 간단한 웹 서버:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 새로운 API는 정적 파일을 제공하는 기본 웹 서버를 제공하여 빠른 프로토타이핑 및 임베디드 애플리케이션에 이상적입니다.\n\n- 시스템에 Java 18 이상이 설치되어 있는지 확인합니다.\n- 정적 파일(HTML, CSS, JavaScript, 이미지 등)을 특정 디렉토리에 준비해 두세요.\n\n```js\nimport com.sun.net.httpserver.HttpServer;\nimport com.sun.net.httpserver.SimpleFileServer;\n\nimport java.net.InetSocketAddress;\n\npublic class SimpleWebServer {\n    public static void main(String[] args) throws Exception {\n        String documentRoot = \"/path/to/your/static/files\";  // 실제 디렉토리로 교체합니다\n        int port = 8080;  // 필요에 따라 포트를 변경할 수 있습니다\n\n        HttpServer server = HttpServer.create(new InetSocketAddress(port), 0);\n        SimpleFileServer fileServer = new SimpleFileServer(documentRoot);\n        server.setExecutor(null);  // 단일 스레드 실행자 사용\n        server.createContext(\"/\", fileServer);\n\n        server.start();\n        System.out.println(\"포트 \" + port + \"에서 서버가 시작되었습니다.\");\n    }\n}\n```\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003chead\u003e\n    \u003ctitle\u003e문서 제목\u003c/title\u003e\n\u003c/head\u003e\n\n\u003cbody\u003e\n이 페이지는 \"jwebserver\" 명령을 사용하여 Java의 Simple Web Server로 제공될 수 있습니다.\n\u003c/body\u003e\n\n\u003c/html\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같은 방법으로 실행해보세요:\n\n1. Java 파일 컴파일하기: javac SimpleWebServer.java\n2. 컴파일된 클래스 실행하기: java SimpleWebServer\n\n접속하기:\n\n- 웹 브라우저를 열고 http://localhost:8080 (또는 지정된 포트)로 이동합니다.\n- 정적 파일 디렉토리에서 기본 파일 (보통 index.html)이 제공되는 것을 확인할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n5. 서버를 중지하는 방법:\n\n- 서버를 중지하려면 실행 중인 터미널에서 Ctrl+C를 누릅니다.\n\n가장 간단한 방법으로 시작하기:\n\n1. 이 패키지(java18)에서 터미널을 엽니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. \"java -version\"을 실행하고 Java가 적어도 18 버전인지 확인해주세요.\n\n3. \"jwebserver\" 명령어를 실행해주세요.\n\n다음과 같은 메시지가 표시되어야 합니다:\n\n기본적으로 루프백에 바인딩됩니다. 모든 인터페이스에 대해 사용하려면 \"-b 0.0.0.0\" 또는 \"-b ::\"를 사용하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n127.0.0.1 포트 8000에서 경로/디렉토리 및 하위 디렉토리를 제공하고 있어요.\n\nURL http://127.0.0.1:8000/\n\nHTML 페이지는 이제 다음 주소에서 제공됩니다: http://127.0.0.1:8000/java18/doc.html\n\nIP 주소, 포트 및 기타 매개변수를 변경할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## HEAD() 편의 메서드 추가:\n\n```js\npublic class HttpHeadDemo {\n\n    /**\n     * HEAD() 편의 메서드 추가\n     */\n    public static void main(String[] args) throws IOException, InterruptedException {\n        HttpRequest head = HttpRequest.newBuilder(URI.create(\"https://api.github.com/\"))\n                .HEAD()\n                .build();\n\n        var response = HttpClient.newHttpClient().send(head, HttpResponse.BodyHandlers.ofString());\n\n        print(response);\n    }\n}\n```\n\nMethod Handles로 Core Reflection 재구현: 이 재구현은 리플렉션 기능의 성능과 안정성을 개선하기 위한 것입니다.\n\n제거를 위한 Finalization 과거화: 자원 정리를 위해 고안된 Finalization은 고유한 단점이 있습니다. 이를 과거화함으로써 더 안전하고 신뢰할 수 있는 대안들이 제공됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미리보기 또는 인큐베이터 기능:\n\n## 가상 스레드:\n\n이 기능은 운영 체제 스레드 위에서 실행되는 가벼운 스레드를 소개하여 이를 통해 동시 프로그래밍을 간단히하고 특정 작업 부하의 성능을 향상시키는 것을 목표로합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Java 21에서 가상 스레드를 소개하는 간단한 데모입니다:\n\n- 가상 스레드 생성:\n\n```js\nThread vThread1 = Thread.ofVirtual().start(() -\u003e {\n  for (int i = 0; i \u003c 10; i++) {\n    System.out.println(\"가상 스레드 1: \" + i);\n  }\n});\n\nThread vThread2 = Thread.ofVirtual().start(() -\u003e {\n  for (int i = 0; i \u003c 10; i++) {\n    System.out.println(\"가상 스레드 2: \" + i);\n  }\n});\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 완료 대기:\n\n```js\nvThread1.join();\nvThread2.join();\n```\n\n결과:\n\n이렇게 하면 두 가상 스레드의 출력이 교차되어 풀 OS 스레드의 오버헤드 없이 동시 실행이 나타납니다. 다음과 같은 내용을 볼 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n가상 스레드 1: 0\n가상 스레드 2: 0\n가상 스레드 1: 1\n가상 스레드 2: 1\n...\n가상 스레드 1: 9\n가상 스레드 2: 9\n```\n\n가상 스레드 설명:\n\n가상 스레드는 작은 기본 OS 스레드 풀 위에서 실행되는 가벼운 실행 단위입니다. 다음과 같은 여러 가지 장점을 제공합니다:\n\n- 가벼운 무게: OS 스레드와 비교하여, 가상 스레드는 생성 및 컨텍스트 전환 비용이 상당히 낮습니다.\n- 개선된 병행성: 제한된 수의 OS 스레드 내에 효율적으로 더 많은 가상 스레드를 관리할 수 있어서, 특정 작업 부하에 대한 자원을 더 잘 활용할 수 있습니다.\n- 단순화된 병행성 프로그래밍: 가상 스레드는 복잡한 스레드 관리와 동기화를 제거하여, 개발자들에게 병행 프로그래밍을 더 쉽게 만들어 줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 가상 스레드의 예제이며 OS/플랫폼 스레드와 대조적입니다. 이 프로그램은 ExecutorService를 사용하여 10,000개의 작업을 생성하고 모든 작업이 완료될 때까지 기다립니다. JDK는 배완 스레드와 OS 스레드의 제한된 수에서 이를 실행하여 쉽게 동시 코드를 작성할 수 있도록 지원합니다.\n\n```js\ntry (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n    IntStream.range(0, 10_000).forEach(i -\u003e {\n        executor.submit(() -\u003e {\n            Thread.sleep(Duration.ofSeconds(1));\n            return i;\n        });\n    });\n}  // executor.close()는 암시적으로 호출되어 기다립니다\n```\n\n## 레코드 패턴 (프로젝트 앰버):\n\n레코드는 Java 14에서 미리보기로 도입되었으며, Java 열거형도 함께 제공되었습니다. record는 Java의 또 다른 특별한 종류이며, 클래스 개발 프로세스를 단순한 데이터 운반자로만 동작하는 클래스로 쉽게 만들 수 있도록 도와줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJDK 21에서 레코드 패턴과 타입 패턴을 중첩하여 사용하여 데이터 탐색 및 처리를 선언적이고 조합 가능한 형태로 가능하게 되었습니다.\n\n```java\n// 레코드 생성하기:\n\npublic record Todo(String title, boolean completed){}\n\n// 객체 생성하기:\n\nTodo t = new Todo(“Learn Java 21”, false);\n```\n\nJDK 21 이전에는 전체 레코드를 분해하여 액세서에 액세스해야 했습니다. 그러나 이제는 값들을 더 간단하게 얻을 수 있습니다. 예를 들어:\n\n```java\nstatic void printTodo(Object obj) {\n    if (obj instanceof Todo(String title, boolean completed)) {\n        System.out.print(title);\n        System.out.print(completed);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레코드 패턴의 다른 장점은 중첩된 레코드 및 해당 값에 액세스하는 기능입니다. JEP 정의 자체에서 제시된 예시는 ColoredPoint에 중첩된 Rectangle 내부의 Point 값을 얻는 능력을 보여줍니다. 이전보다 더 유용해졌습니다. 이전에는 레코드를 매번 분해해야 했는데, 이제 중첩된 레코드의 값을 쉽게 얻을 수 있습니다.\n\n```js\n// Java 21부터\nstatic void printColorOfUpperLeftPoint(Rectangle r) {\n    if (r instanceof Rectangle(ColoredPoint(Point p, Color c),\n                               ColoredPoint lr)) {\n        System.out.println(c);\n    }\n}\n```\n\n## 순차적 컬렉션:\n\nJDK 21에서는 새로운 컬렉션 인터페이스 세트가 소개되어 컬렉션 사용 경험을 향상시킵니다. 예를 들어, 컬렉션에서 요소의 역순을 얻고 싶다면, 사용 중인 컬렉션에 따라 번거로울 수 있습니다. 사용 중인 컬렉션에 따라 등장 순서를 가져오는 데 불일치가 있을 수 있습니다. 예를 들어, SortedSet은 하나를 구현하지만 HashSet는 그렇지 않기 때문에 서로 다른 데이터 세트에서 이 작업을 수행하는 것이 번거로울 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_2.png\" /\u003e\n\n이 문제를 해결하기 위해 SequencedCollection 인터페이스는 reverse 메서드를 추가하고 첫 번째 및 마지막 요소를 가져오는 기능을 제공하여 순서를 보장합니다. 또한 SequencedMap 및 SequencedSet 인터페이스도 있습니다.\n\n```js\ninterface SequencedCollection\u003cE\u003e extends Collection\u003cE\u003e {\n    // 새로운 메서드\n    SequencedCollection\u003cE\u003e reversed();\n    // Deque에서 승급된 메서드\n    void addFirst(E);\n    void addLast(E);\n    E getFirst();\n    E getLast();\n    E removeFirst();\n    E removeLast();\n}\n```\n\n## 문자열 템플릿:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문자열 템플릿은 JDK 21의 미리 보기 기능입니다. 그러나 이는 문자열 조작에 더 많은 신뢰성과 더 나은 경험을 제공하여 때로는 원하지 않는 결과로 이어질 수 있는 일반적인 함정을 피하기 위해 노력합니다. 이제 템플릿 표현식을 작성하고 문자열에서 렌더링할 수 있습니다.\n\n```java\n// Java 21부터\nString name = \"Ajay\";\nString greeting = \"Hello \\{name}\";\nSystem.out.println(greeting);\n```\n\n이 경우 두 번째 줄이 표현식이며 호출시 Hello Ajay를 렌더링해야 합니다. 또한 보안 문제를 일으킬 수 있는 SQL 문 또는 HTML과 같은 불법적인 문자열의 가능성이 있는 경우 템플릿 규칙은 이스케이프된 따옴표만 허용하고 HTML 문서에서는 불법 엔티티를 허용하지 않습니다.\n\n# 읽어 주셔서 감사합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 👏 위 이야기에 박수를 보내주시고 저를 팔로우해주세요 👉\n- 📰 미디엄에서 더 많은 콘텐츠를 읽어보세요 (자바 개발자 인터뷰에 관한 총 50개의 이야기)\n\n제 책들은 여기서 확인하실 수 있습니다:\n\n- 아마존에서 제공하는 [가이드: 명쾌한 자바 개발자 인터뷰 (킨들북)](Amazon) 및 Gumroad (PDF 형식).\n- Gumroad에서 제공하는 [가이드: 명쾌한 스프링 부트 마이크로서비스 인터뷰 (PDF 형식)] 및 아마존 (킨들 eBook).\n- 🔔 팔로우해보세요: LinkedIn | Twitter | YouTube\n","ogImage":{"url":"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png"},"coverImage":"/assets/img/2024-06-19-AComprehensiveJourneyfromJava8toJava21withCodeExamplesofEssentialAPIEnhancements_0.png","tag":["Tech"],"readingTime":46},{"title":"가장 많이 묻는 질문 - SOLID 원칙 JAVA","description":"","date":"2024-06-19 21:55","slug":"2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA","content":"\n![SOLID Principles in JAVA](/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png)\n\n- **S — Single Responsibility Principle (SRP)**\n  - Each unit of code should have only one responsibility.\n  - A unit can be a class, module, function, or component.\n  - Keeps code modular and reduces tight coupling.\n  - Example: A class that handles user authentication should not also manage database connections.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# O — Open/Closed Principle (OCP)\n\n- 코드 단위는 확장을 허용하고 수정을 제한해야 합니다.\n\n- 기존 코드를 수정하는 대신 새 코드를 추가하여 기능 확장.\n\n- React 프론트엔드와 같이 구성 요소 기반 시스템에서 유용합니다.\n  예: 로깅 시스템에 새 로그 핸들러를 생성하여 기능을 추가하는 것이 기존 핸들러를 변경하는 것보다 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# L — 리스코프 치환 원칙 (LSP)\n\n- 서브클래스는 기본 클래스로 대체 가능해야 합니다.\n- 기본 클래스의 기능은 모든 서브클래스에서 사용할 수 있어야 합니다.\n\n- 만약 서브클래스가 기본 클래스의 기능을 사용할 수 없다면, 그것은 기본 클래스에 있어서는 안 됩니다.\n  예: `새` 클래스에 `참새`와 `펭귄` 서브클래스가 있는 경우, 만약 `새`에 `날다` 메소드가 있다면, `펭귄`은 날지 못하기 때문에 상속받으면 안 됩니다.\n\n# I — 인터페이스 분리 원칙 (ISP)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 몇 개의 일반 목적이 아닌 구체적인 인터페이스를 제공해주세요.\n\n- 클라이언트는 사용하지 않는 메소드에 의존하면 안 됩니다.\n  예시: `Vehicle` 인터페이스를 `Drivable`과 `Flyable`로 분리하여 자동차 클래스가 `Flyable`을 구현할 필요가 없도록합니다.\n\n# D — 의존성 역전 원칙 (DIP)\n\n- 구체적인 클래스가 아닌 추상화에 의존해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 시스템의 부분 간 의존성을 분리시키기 위해 추상화를 사용하세요.\n\n- 인터페이스나 추상화를 사용하여 코드 유닠 사이에 직접 호출을 피하세요.\n  예: 특정 'FileLogger' 클래스 대신 로깅을 위해 'ILogger' 인터페이스를 사용하세요.\n","ogImage":{"url":"/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png"},"coverImage":"/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png","tag":["Tech"],"readingTime":3}],"page":"30","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"30"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>