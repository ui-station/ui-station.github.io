<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/30" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/30" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="제가 처음으로 애플 스토어에 앱을 배포한 방법 1" href="/post/2024-06-22-HowIpublishedmyfirstapptoAppleStore1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제가 처음으로 애플 스토어에 앱을 배포한 방법 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제가 처음으로 애플 스토어에 앱을 배포한 방법 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">제가 처음으로 애플 스토어에 앱을 배포한 방법 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법" href="/post/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드" href="/post/2024-06-22-Flutter-Bloc"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Flutter-Bloc_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS에서 URLCache 사용하기 초보자를 위한 가이드" href="/post/2024-06-22-URLCacheiniOSABeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS에서 URLCache 사용하기 초보자를 위한 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-URLCacheiniOSABeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS에서 URLCache 사용하기 초보자를 위한 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS에서 URLCache 사용하기 초보자를 위한 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift에서 weak와 unowned의 차이점 예제 포함" href="/post/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서 weak와 unowned의 차이점 예제 포함" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서 weak와 unowned의 차이점 예제 포함" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift에서 weak와 unowned의 차이점 예제 포함</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="4단계로 iOS 앱에 실시간 활동 추가하는 방법" href="/post/2024-06-22-AddLiveActivitiestoyouriOSappin4steps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="4단계로 iOS 앱에 실시간 활동 추가하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AddLiveActivitiestoyouriOSappin4steps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="4단계로 iOS 앱에 실시간 활동 추가하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">4단계로 iOS 앱에 실시간 활동 추가하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift 비동기 처리에서 경합 상태 버그 해결 방법 " href="/post/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift 비동기 처리에서 경합 상태 버그 해결 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift 비동기 처리에서 경합 상태 버그 해결 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift 비동기 처리에서 경합 상태 버그 해결 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftData로 원격 API에서 데이터 저장하는 방법" href="/post/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftData로 원격 API에서 데이터 저장하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftData로 원격 API에서 데이터 저장하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftData로 원격 API에서 데이터 저장하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 제스처 완벽하게 활용하는 방법 종합 가이드" href="/post/2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 제스처 완벽하게 활용하는 방법 종합 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 제스처 완벽하게 활용하는 방법 종합 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI에서 제스처 완벽하게 활용하는 방법 종합 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI 앱을 위한 디자인 패턴 선택하기" href="/post/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI 앱을 위한 디자인 패턴 선택하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI 앱을 위한 디자인 패턴 선택하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI 앱을 위한 디자인 패턴 선택하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link posts_-active__YVJEi" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"제가 처음으로 애플 스토어에 앱을 배포한 방법 1","description":"","date":"2024-06-22 23:20","slug":"2024-06-22-HowIpublishedmyfirstapptoAppleStore1","content":"\n![이미지](/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_0.png)\n\n# 배경\n\n안녕하세요! 저는 울라즈입니다. 첫 번째 iOS 애플리케이션을 작성 중이에요. 지난 주에 물병에서 물을 쏟아 노트북이 고장 났어요. 그래서 다음 몇 주 동안 코딩을 못하니 대신 글을 쓸 거예요...\n\n지난 몇 년 동안 자신의 일을 시작하고자 끊임없이 생각했어요. 나 자신을 위해 일하는 것을 꿈꿨죠. 새로운 사업을 시작하기 위한 기준은 몇 가지가 있었어요. 여가 시간에 해야하고 필요한 기술이나 배우기를 원하는 욕망이 있어야 했어요. 그리고 초기 투자가 적고 6개월 이내에 초기 결과를 볼 수 있는 잠재력이 있어야 했어요. 드롭 배송이나 프린트 온 디맨드 티셔츠 스토어부터 내 카페나 어린이 장난감 가게까지 아이디어는 다양했어요. 많은 아이디어가 지루해서 폐기되었지만 무언가가 동작하지 않을까 두려워서 대부분이었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 해 전에 아빠가 되었고 성장하는 아기의 활동을 추적하기 위해 앱을 다운로드했어요. 이름은 기억이 안 나지만 목적을 잘 해결해 주었어요. 유료로 제공되어야 했던 몇 가지 기능이 구독 없이 사용할 수 없어서 아쉬웠지만, 급하게 제 자신의 앱을 만들어보려고 생각했어요.\n\n\u003cimg src=\"/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_1.png\" /\u003e\n\n이 아이디어가 마음에 들어서 모든 조건을 충족시킬 수 있다고 생각했어요: 매일 1~2시간을 코딩할 수 있었고, 휴대폰 개발을 배우고 싶었으며, 자금이 필요하지 않았어요 (전혀 사실이 아니라면, 다음 부분에서 설명할게요), 그리고 6개월 안에 완성할 수 있을 것 같았어요. 판매할 계획은 없었고, 주된 목적은 배우기와 개인적인 용도였어요. 릴리스 프로세스를 간소화하고 싶었기 때문에 변화를 가하기 위해 쉽게 새 버전을 릴리스할 수 있지 않을까 생각했어요. 만약 모든 것이 잘 풀린다면 미래에 수익창출을 시도하고 수동적인 소득을 얻을 수 있겠죠. 그래서 밤에 피트니스 볼 위에 앉아 딸을 흔들며 한 손으로 타이핑을 시작했어요.\n\n첫 번째 일은 무엇을 작성할지와 어느 플랫폼을 위해 작성할지를 결정하는 것이었어요. iOS에만 제한하지 않기로 결정해서 안드로이드 스마트폰 사용자들이 제 아름다운 작품을 사용할 기회를 놓치지 않게 하려고 했죠. 그래서 React Native과 Flutter 중에서 선택했어요. 회사에서 내부 서비스를 지원하기 위해 React를 배워야 했는데, React Native를 선호하는 이유였죠. 공식 문서를 보고 예상대로 시작해봤는데, 시뮬레이터에서 Hello World 예제를 실행하려고 해보니 예상보다 순조롭지 않았어요. 환경 설정 과정이 어색해서 제 동기부여가 금방 떨어졌어요. 종속성이 설치되지 않고, 시뮬레이터가 실행되지 않거나 이유를 알 수 없이 다운되기도 했어요. 게다가 앱 릴리스 프로세스가 불분명해서 2~3주간 투쟁한 끝에 아이디어를 포기했어요. 게다가 우리 아이의 일상이 안정되고 유료 앱을 사용하지 않게 되었거든요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![앱 이미지](/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_2.png)\n\n아홉 달이 지나자 우리는 다른 도시로 이사를 가게 되었고, 저는 체육관에 가입했어요. 이전에도 시도해 봤지만 오래 기억하지 못했어요. 이번에는 체육관이 걸어서 2분 거리에 있어서 규칙적으로 빠뜨릴 가능성이 거의 없었어요. 세트와 무게를 기록할 앱을 찾기 시작했고, 여러 개가 있었어요. 처음 발견한 앱이 나에게 적합했지만, 시간이 지남에 따라, 한 세트만 주석을 남길 수 없고, 세 개 이상의 루틴을 만들 수 없다는 것을 깨달았어요.\n\n그래서 나는 내 앱 아이디어로 돌아가고 무엇으로 쓸지 고민했어요. 이번에는 가장 쉬운 길인 작게 시작하고 빨리 배우는 길을 선택하기로 결정했어요. 주로 나 자신을 위해 쓰기 때문에, iOS만 지원하도록 제한하기로 했어요. 진입 장벽이 매우 낮았고, 애플의 공식 자습서로 시작했고, 처음 두 시간 안에 시험 앱을 핸드폰에 올렸어요. 그래서 매일 업무를 끝낸 후에 운동 기록 앱을 만들기 시작했어요 💪.\n\n지금까지입니다! 끝까지 읽어 주신 모든 분들께 감사드려요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 게시물에서는 다음과 같은 주제를 다룰 예정입니다:\n\n- 개발 프로세스 및 왜 스위프트를 배우지 않고 ChatGPT에게 물어보기로 결정했는지\n- 첫 번째 릴리스\n- 향후 계획\n\n여기서 스크린샷을 확인하거나 다운로드할 수 있습니다. 광고나 등록이 필요하지 않으며 무료로 제공됩니다.\n","ogImage":{"url":"/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_0.png"},"coverImage":"/assets/img/2024-06-22-HowIpublishedmyfirstapptoAppleStore1_0.png","tag":["Tech"],"readingTime":4},{"title":"안드로이드 앱 부정 방지 프로모션 남용을 막기 위한 최적의 디바이스 ID 선택 방법","description":"","date":"2024-06-22 23:17","slug":"2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention","content":"\n⚡주요 요점:\n\n- 프로모션 남용은 비즈니스의 가입 보너스, 추천, 쿠폰 또는 프로모션을 악용하는 사기 유형입니다.\n- 가능한 경우에는 MediaDRM을 디바이스 지문보다 선호해야 합니다.\n- 우리의 연구 결과, 블록리스트에 가장 적합한 최고의 디바이스 ID는 MediaDRM+디바이스 모델의 결합입니다.\n- 모바일 앱 백엔드 API를 보호하는 AppiCrypt(앱 보호), RASP(앱 쉴딩) 및 KYC 솔루션(고객 신원 확인)과 같은 여러 보안 계층을 항상 포함해야 합니다.\n- 특정 시나리오에 따라 다른 접근 방식이 필요할 수 있다는 것을 염두에 두세요. info@talsec.app으로 메시지를 남기면 Talsec 보안 전문가가 도와드릴 것입니다.\n\n# 사용자 파악 방법?\n\n최근에 모바일 디바이스 식별에서 어려움에 부딪혔습니다 - 사용자 개인정보를 침해하지 않으면서 사기적인 디바이스를 식별하고 블록리스트에 올리는 방법은 무엇일까요. 이 문제는 결제 회피 또는 다양한 보너스를 악용하는 사용자들과 빈번히 대면하는 모바일 애플리케이션 소유자에게 특히 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n초기 가입 시 사용자들을 유혹하는 매력적인 보너스로 사용자를 유치하는 것은 흔한 일이지만, 이 전략은 내재적인 위험을 안고 있으며 남용될 수 있다는 점을 인지하는 것이 중요합니다. 이 악의적인 사용자들은 앱을 여러 번 다시 설치하여 계속해서 가입 보너스를 얻으려는 행위를 하는데, 이를 \"멀티 인스턴싱\"이라고 부릅니다.\n\n안드로이드는 각 앱 인스턴스마다 일부 디바이스 ID를 변경하므로, 동일한 악의적 사용자의 디바이스를 차단하기가 어려워집니다. 이는 효과적인 해결책을 찾기 위한 우리의 노력이 복잡함을 강조합니다.\n\n![이미지](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png)\n\n# 좋은 ID는 고유하며 충돌 방지, 지속적이고 개인정보 친화적이어야 합니다. 그리고 위조할 수 없어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n과거에는 특별한 권한을 요청하지 않고 MAC 주소나 IMEI를 통해 기기를 식별할 수 있었어요. 오늘날 안드로이드 개인 정보 보호를 위한 다양한 변경 사항 이후, Android 기기에서 AndroidID, MediaDRM, GSF ID, FID 및 InstanceID와 같은 여러 반영구적 ID가 사용 가능해졌어요. 물론, 사용자에게 상승된 액세스 및 잠재적 보안 문제를 가진 권한을 요청하는 것은 현실적이지 않아요.\n\n각 ID에는 장단점이 있어 다양한 시나리오에서 유용하게 사용될 수 있어요. 아래 예시 테이블을 참고하세요. Android 문서에서 ID에 대한 추가 정보를 찾을 수 있어요.\n\n또 다른 방법으로는 다양한 디바이스 지문 라이브러리(예: fingerprintjs-android)를 사용하여 여러 기기 ID, 기기 상태, OS 지문 또는 설치된 앱을 기반으로 ID를 생성할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 ID들을 더 자세히 살펴보겠습니다.\n\n# AndroidID, GSF ID, FID, InstanceID, Google 광고 ID\n\n이러한 식별 방법은 다른 맥락에서는 잘 작동할 수 있지만, 우리의 시나리오에서는 부정한 다중 인스턴싱에 견딜 수 있는 견고함이 부족합니다. 이러한 ID들은 비교적 쉽게 변경할 수 있으므로 각각에 대한 단점에 대해 간단한 설명만 제공하겠습니다.\n\n- AndroidID는 다시 패키징되거나 기기의 다른 사용자로 설치되는 경우 변경됩니다.\n- GSF ID (Google Play 서비스 프레임워크 ID)는 Google 기기에만 제한되며 XPrivacyLua에 의해 상대적으로 쉽게 위조될 수 있습니다. 또한 다른 사용자에 대해 변경됩니다.\n- FID (Firebase 설치 ID)는 재설치를 견뎌내지 못합니다.\n- InstanceID (GUID, UUID.randomUUID().toString())는 사용자 정의 생성 및 내부 저장 ID입니다만, 재설치를 견딜 수 없습니다.\n- Google 광고 ID는 전혀 적합하지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요약하면, 우리의 시나리오에서 나쁜 행위자를 식별하는 데 충분히 견고한 ID는 없습니다.\n\n# fingerprintjs-android 라이브러리 기반의 지문 ID\n\n참고: 전체 분석에서 우리는 상태 없는 오프라인 지문 ID를 위해 종합적인 신호 목록을 사용하는 fingerprintjs-android 라이브러리를 사용했습니다. 다른 지문 ID 라이브러리의 결과는 다를 수 있습니다. 이는 그들의 데이터 인사이트, 지리 위치, IP 위치, TEE 및 다른 요소에 기반한 더 많은 신호와 휴리스틱을 포함할 수 있습니다. Talsec는 fingerprintjs-android V3 및 StabilityLevel.OPTIMAL을 수집합니다. 안정성 수준 (STABLE — OPTIMAL — UNIQUE) 사이의 차이점은 여기에서 찾을 수 있습니다.\n\n위의 표를 다시 한 번 살펴보세요. 첫눈에는 하드웨어 지문 (위의 표 참조)가 최선의 선택일 수 있습니다. 이것은 인스턴트 앱 이벤트를 제외하고는 무엇이든 견딜 수 있습니다. 그러나 이 ID에는 한 가지 심각한 단점이 있습니다 — 충돌입니다. 이 충돌은 ID가 계산되는 방식에 의해 발생합니다. ID는 디바이스의 하드웨어에만 기반하기 때문에 발생합니다. 예를 들어, 조립 라인에서 직접 나오는 모든 삼성 갤럭시 Z 플립이 동일한 ID를 갖게 될 것입니다. 이 유형의 지문은 STABLE 지문이라고 불립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_2.png)\n\n한편, 고유한 지문(fingerprint)이 있습니다. 이것은 기기의 ID를 계산하기 위해 상당량의 신호를 사용합니다. 이 방식으로 생성된 ID는 하나의 사용자에게만 매칭될 가능성이 높습니다(충돌이 적음), 그러나 신호가 많기 때문에 ID가 자주 변경될 수 있습니다(예: 설정 변경시). 따라서 하나의 사용자에게 많은 ID가 생길 수 있어 우리의 사용 사례에는 유용하지 않습니다. 예: 설치된 앱이 변경되거나 데이터 로밍이 활성화/비활성화될 때 ID가 변경될 수 있습니다.\n\n세 번째 유형의 지문은 STABLE과 UNIQUE 지문 사이의 절충안인 OPTIMAL 지문입니다. 이 지문은 STABLE 지문보다는 덜 안정적이지만 더 고유하며 Talsec SDK에 의해 수집됩니다. 그러나 이 유형의 지문조차 이 기사에서 나중에 보여줄 것처럼 최적적이지 않습니다. 예: 사용자가 12시 및 24시간 형식으로 전환하거나 개발자 설정 또는 ADB가 활성화/비활성화될 때 ID가 변경될 수 있습니다.\n\n지문 예시: `f37fc958dc6d566a8f4bf1e0fd25b510`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# MediaDRM\n\nMediaDrm은 프리미엄 콘텐츠 재생을 위해 암호화 키를 안전하게 제공하는 안드로이드 API입니다. Google의 Widevine 및 Microsoft의 PlayReady와 같은 DRM 공급자를 사용합니다. 초기 DRM 사용 중에는 장치 프로비저닝을 통해 장치의 DRM 서비스에 저장된 고유한 인증서를 획득합니다.\n\n이 API에서 제공되는 MediaDRM은 장치 상의 모든 사용자에게 동일하지만, 저희 상황에서는 위조하기 어렵고 많은 공격에도 견딜 수 있습니다. 이 ID를 얻으려면 권한이 필요하지 않습니다.\n\n하지만 여전히 제한 사항이 있습니다. MediaDrm을 지원하지 않는 장치에서는 사용할 수 없을 수 있습니다. 또한 동일한 제조업체의 장치 간에는 충돌이 많이 발생할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMediaDRM 예시: `e3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6`\n\n# MediaDRM vs 지문 ID?\n\n우리는 다섯 대의 기기와 에뮬레이터를 여러 개의 다중 인스턴싱 시나리오에서 테스트하고 ID가 변경되었는지 여부를 확인했습니다. 가장 흥미로운 부분은 MediaDRM과 Fingerprint (V3 \u0026 V5 Optimal)입니다. 그래서 우리는 특히 이 부분에 주의를 기울였습니다.\n\n다중 인스턴싱 시나리오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 앱의 첫 설치\n- 앱 재설치\n- 작업 프로필에 설치\n- Island 앱을 사용하여 앱의 복제\n- Parallel Space를 사용하여 앱의 복제\n- 병렬 애플리케이션을 사용하여 앱의 복제\n- 두 번째 공간(Xiaomi)을 사용하여 앱의 복제\n- 손님 프로필에 설치\n- 공장 초기화\n- 안드로이드 에뮬레이터 대 실제 기기\n\n이 지루한 작업은 훌륭한 지문 OSS 데모 도구 덕분에 더 쉽게 진행되었습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_3.png\" /\u003e\n\n가장 중요한 관찰 결과를 여기에 나열하였습니다. 모든 테스트를 항상 수행할 수는 없었기 때문에 사소한 부분들은 모두 다시 시도했습니다 - 이는 공격자들이 시도할 것이기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n유지한 것 (= 좋은):\n\n- 미디어 DRM은 처음 설치 시 OnePlus 8 Pro의 Island App에서 동일하게 유지되었습니다.\n- 미디어 DRM은 Redmi Note 10 Pro의 두 번째 공간에서 동일하게 유지되었습니다.\n- 미디어 DRM은 OnePlus 8 Pro에서 공장 초기화 후에도 동일하게 유지되었습니다.\n- 미디어 DRM은 OnePlus 8T에서 처음 설치, 작업 프로필 및 여러 사용자에 대해 동일하게 유지되었습니다.\n- 첫 설치 및 병렬 공간에서의 OnePlus 8T의 Fingerprint V5 Optimal이 동일하게 유지되었습니다.\n- Redmi Note 10 Pro에서 다시 설치 후에도 미디어 DRM 및 Fingerprint V3 및 V5 Optimal이 동일하게 유지되었습니다.\n- OnePlus 8T의 첫 설치, 작업 프로필 및 병렬 공간에서 Fingerprint V5 Optimal이 다시 설치 후에도 동일하게 유지되었습니다.\n\n변경된 것 (= 나쁜):\n\n- 처음 설치 및 Island App에서 Fingerprint V5 Optimal이 변경되었습니다.\n- OnePlus 8 Pro에서 공장 초기화 후 Fingerprint V5 Optimal이 변경되었습니다.\n- Redmi Note 10 Pro의 두 번째 공간에서 Fingerprint V5 Optimal이 변경되었습니다.\n- OnePlus 8T의 병렬 공간에서 미디어 DRM이 변경되었습니다.\n- OnePlus 8T의 작업 프로필 및 게스트 사용자에서 Fingerprint V5 Optimal이 변경되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른:\n\n- 에뮬레이터에서 FingerprintV3 Optimal이 Fingerprint V5 Optimal보다 성능이 더 좋았습니다.\n- Emulator 1과 Emulator 2에서 MediaDRM이 다르게 동작했는데 둘 다 동일한 Windows 기계에서 실행되었습니다.\n\n이러한 관찰을 바탕으로 Fingerprint V3과 V5 Optimal은 MediaDRM과 비교했을 때 많은 다중 인스턴스 사기 시나리오에서 실패했습니다. 이러한 테스트에서 우리는 MediaDRM이 더 나은 것으로 결론지었습니다.\n\n# 원시 데이터 분석\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과를 양적으로 파악하기 위해 우리는 데이터를 살펴보고 해당 ID들의 행동을 평가하여 데이터를 기반으로 가장 적합한 ID를 찾아냈습니다. 사용자 기반의 기기와 비교하여 우리의 데이터가 왜곡되어 있고 대표적이지 않을 수 있다는 점을 기억해 주세요.\n\n## 2주간의 데이터 수집\n\n우리는 2주 동안 freeRASP 데이터를 수집하여 분석했습니다. 이 기간이 비교적 짧기 때문에 다시 설치하는 경우가 많지 않다고 가정합니다. 다시 한 번 강조하지만, 특정 응용프로그램의 카테고리/사용 사례에 따라 실제 재설치 비율이 달라질 수 있으므로 이 창을 선택하는 데 실제 재설치 비율에 대한 연구가 없다는 점을 유의해 주세요.\n\n아래에서 각 ID의 고유 값 수와 이 데이터에서 캡처된 고유 디바이스 모델 수를 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAndroidID: 13 402 601\n\nFingerprintV3: 22 525 265\n\nMediaDRM: 13 285 081\n\nInstanceId: 13 740 706\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다양한 기기 모델: 14,175 (예: Pixel 4, SM-G973N, ONEPLUS A5000, LG-H930, ...)\n\n처음에 봤을 때 다른 ID들의 수보다 훨씬 높은 FingerprintV3의 수를 알아차렸어요. 이것은 사용자가 32가지 관측된 지문 신호 중 일부를 변경할 때마다 변하는 FingerprintV3의 행동에 의한 것일 수 있어요.\n\n## ID들은 어떻게 관련이 있을까요?\n\n그 후, 우리는 ID들 간의 동시 발생을 살펴보았습니다. 이를 통해 그들 간의 관련성을 파악해 보았어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 테이블을 읽는 방법입니다. 하나의 AndroidID에는 1.00557개의 고유한 MediaDRM이 있으며, 고유한 AndroidID 중 0.54%가 하나 이상의 MediaDRM을 가지고 있습니다.\n\n## ID 충돌: 같은 ID지만 다른 기기\n\n데이터에 따르면, 우리는 여전히 \"최적\" 식별자를 찾고 있기 때문에 \"다른 기기\"가 무엇인지 말할 수 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이디 당 평균 모델 수를 살펴봐요. ID마다 모델이 하나만 있는 것이 이상적입니다 — 서로 다른 디바이스에 동일한 ID가 있는 충돌이 최소화되기를 바랍니다. 아래 표를 빠르게 살펴보면 진정한 불일치가 있음을 알 수 있어요.\n\n![표](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_5.png)\n\n## 결과\n\n데이터 분석 결과, 다음과 같이 진술할 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- FingerprintV3는 다른 ID들에 비해 값이 너무 많아서 우리 시나리오에서는 덜 유용합니다.\n- 하나의 AndroidID/MediaDRM/InstanceID에는 보통 여러 개의 FingerprintV3가 있습니다.\n- AndroidId와 MediaDRM은 대략 1:1 관계이며, 일부 MediaDRM 인스턴스에는 AndroidID보다 더 많은 AndroidID (AndroidId보다 더 많은 MediaDRM을 가지고 있는 경우도 있습니다).\n- 경우에 따라 하나의 AndroidID에는 여러 개의 InstanceID (MediaDRM보다 더 자주 발생), MediaDRM과 InstanceID 사이의 관계와 유사합니다.\n- InstanceID는 MediaDRM보다 AndroidID와 더 밀접한 관계에 있습니다.\n- AndroidID는 하나의 모델만 가지고 있습니다 (이상치의 양은 극히 적음).\n- MediaDRM은 일반적으로 하나의 모델을 가지나, 몇 가지 충돌이 있을 수 있습니다 (AndroidID의 경우보다 더 많음).\n- InstanceId는 이 두 모델 사이 어딘가에 위치합니다.\n\n총평으로, 이러한 식별자 중에서 AndroidID가 가장 우수해 보이며, MediaDRM이 그 뒤를 이어갑니다. InstanceId도 유용할 수 있지만 AndroidID만큼은 아닙니다. FingerprintV3은 우리 시나리오에서는 쓸모 없습니다. AndroidID는 다시 설치 후 변경되고 상대적으로 쉽게 위조될 수 있기 때문에 사기 탐지에는 MediaDRM이 가장 적합해 보입니다.\n\n다만, MediaDRM은 충돌이 꽤 많이 발생하는 것 같습니다 (모델 분석을 기반으로 확인한 결과). 같은 제조업체의 기기끼리(즉, 동일 제조업체의 기기일수록 다른 제조업체의 기기보다 더 같은 MediaDRM을 가질 가능성이 훨씬 높음) 충돌이 가장 자주 발생하는 것으로 밝혀졌습니다. 여기에 전반적인 개요를 제공해 드리겠습니다:\n\n- MediaDRM 중 0.005%가 여러 제조업체를 가지고 있음\n- MediaDRM 중 0.55%가 같은 제조업체의 여러 모델을 가지고 있음\n- 한 MediaDRM 당 평균 제조업체 수: 1.000085\n- 한 제조업체 당 MediaDRM의 평균 모델 수: 1.006362\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## MediaDRM를 개선할 수 있을까요?\n\n우리는 많은 시도(자세히 설명하지는 않겠습니다) 끝에 MediaDRM+모델의 조합을 잠재적 ID로 실험해 보았습니다.\n\n구글 Pixel 4의 MediaDRM+모델의 결합 예시: e3af1aa4dacb6b6637846488b511e7643c6ac20b65c95baad164b122ecb036b6+Pixel 4\n\n아래는 위와 동일한 공현 테이블이며, 이제 MediaDRM+모델과의 관계를 포함하고 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_6.png)\n\n우리는 MediaDRM+ 모델이 원래의 MediaDRM보다 더 나은 성능을 보여준다는 것을 확인할 수 있습니다. 각 MediaDRM+ 모델에는 연관된 다른 ID의 수가 더 적습니다. 이는 몇 가지 충돌을 피했다는 것을 의미합니다 (정확한 숫자를 측정하기는 어렵지만, 최소한의 경계는 MediaDRM과 MediaDRM+ 모델의 숫자로 추정됩니다).\n\n두 가지 특성의 조합으로 ID를 만들 때, 한 기기가 더 많은 ID를 가지는 문제가 발생할 수 있습니다. 그러나 MediaDRM+ 모델에서는 이런 경우가 발생하지 않아야 합니다. 한 기기에는 하나의 모델만 연결되어야 하기 때문에 (즉, 구글 픽셀 4 전화기의 물리적 단위는 항상 \"Pixel 4\" 모델 이름만을 가져야 함).\n\n그러므로 데이터를 기반으로, 사기 탐지 사례를 검토할 때 MediaDRM과 기기 모델의 간단한 조합을 ID로 사용하는 것을 제안합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n저희는 모바일 기기 식별에 대한 도전에 직면하고 있습니다 — 사용자 개인 정보를 침해하지 않고 사기꾼 기기를 차단하는 방법에 대해 고민하고 있습니다. 모바일 앱 소유자들은 사용자들이 결제를 회피하거나 보너스를 악용하는 문제에 직면하고 있는데, 이는 여러 번 앱을 재설치함으로써 이루어지는 다중 인스턴스화로 인한 문제입니다. 신뢰할 수 없는 기기 ID로 인해 꾸준한 악의적인 사용자를 식별하는 것이 어려워지고 있습니다. 저희의 연구 결과는 효과적인 차단을 위해 미디어 DRM을 기기 지문보다 우선시하는 것을 권장하며 (또는 더 나아가 미디어 DRM과 기기 모델 조합을 권장합니다). 또한 AppiCrypt, RASP 및 KYC 솔루션과 같은 추가적인 보안층으로 보호 강화를 잊지 마세요. 모든 시나리오는 유니크합니다. 맞춤형 조언이 필요하시면 info@talsec.app 으로 Talsec 보안 전문가에게 문의하세요.\n\n저자: Dáša Pawlasová, Matúš Šikyňa, Tomáš Soukal\n","ogImage":{"url":"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png"},"coverImage":"/assets/img/2024-06-22-Fraud-ProofinganAndroidAppChoosingtheBestDeviceIDforPromoAbusePrevention_0.png","tag":["Tech"],"readingTime":15},{"title":"2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드","description":"","date":"2024-06-22 23:16","slug":"2024-06-22-Flutter-Bloc","content":"\n![Bloc](/assets/img/2024-06-22-Flutter-Bloc_0.png)\n\n## Bloc이란?\n\nBloc은 '비즈니스 로직 구성 요소'의 약자로, Google에서 권장하는 패턴 중 하나입니다. 이 패턴은 비즈니스 로직을 UI로부터 분리할 수 있도록 도와줍니다. 또한 응용 프로그램에서 책임을 분리하여 쉽게 테스트 가능한 코드를 작성할 수 있는 패턴입니다. Google에서 권장하는 다른 패턴은 여기에서 확인할 수 있습니다.\n\nBloc은 세 가지 구조로 구성됩니다. 이들은 이벤트 클래스, 상태 클래스 및 Bloc 클래스입니다. 이제 이들을 좀 더 자세히 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![img](/assets/img/2024-06-22-Flutter-Bloc_1.png)\n\n1. 이벤트:\n   이벤트는 응용 프로그램에서 수행하려는 작업을 나타냅니다. 연락처 응용 프로그램을 고려해보세요. 이 경우, 이벤트는 GetUsers, UpdateUser, DeleteUser 등이 될 것입니다. 이 이벤트에 대한 추상 클래스가 있으며, 다른 이벤트들은 이 추상 클래스를 상속받아 사용합니다.\n\n응용 프로그램에서 수행하려는 작업에 따라 직접 이벤트를 만들어야 합니다.\n\n2. 상태:\n   상태는 응용 프로그램에서 발생할 수 있는 상황을 나타냅니다. 어떤 상황에서 무엇을 해야 할지를 결정하는 데 사용됩니다. 연락처 앱의 경우 UsersInitial, UsersLoading, UsersLoaded 및 UsersError 등이 있을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 블록:\n   Bloc 클래스를 중간 클래스로 생각할 수 있습니다. 이 클래스는 이벤트와 상태를 연결합니다. 이벤트가 트리거되면, 어떤 함수가 호출될지와 어떤 상태로 애플리케이션이 전환될지는 블록 클래스에서 결정됩니다.\n\n## 블록 사용\n\n저는 Bloc을 사용하여 프로젝트를 개발했습니다. 이 프로젝트에는 화면이 있습니다. 이 화면에서는 The Last Airbender에서 캐릭터를 무작위로 가져올 수 있습니다. 저는 Clean Architecture로 프로젝트를 개발했지만, 이 이야기에서는 블록의 사용법만 설명합니다. Clean Architecture에 대한 자세한 내용은 여기에서 읽을 수 있습니다. 프로젝트 개발 중에는 The Last Airbender API를 사용했습니다.\n\n## 예제 채우기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 코어, 구성 및 기능 폴더를 생성했습니다. 그런 다음 fetch characters의 기능을 위해 features 폴더 내에 characters 폴더를 만들었습니다. 마지막으로 characters 폴더 내에 데이터, 도메인 및 프리젠테이션 폴더를 생성했습니다.\n기능 폴더에 bloc 폴더를 만들었습니다. 이는 Bloc이 애플리케이션의 비즈니스 로직에 사용되기 때문입니다.\n\nBloc의 세 부분인 이벤트, 상태 및 bloc 파일을 추가했습니다.\n\n![2024-06-22-Flutter-Bloc_2.png](/assets/img/2024-06-22-Flutter-Bloc_2.png)\n\n## 코드 예시\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 제가 CharactersInitial, CharactersLoading, CharactersError 및 CharactersLoaded 상태를 결정했고 CharactersState를 추상 클래스로 만들었습니다. 그런 다음 다른 상태에 CharactersState에서 상속을 제공했습니다.\n\n```js\npart of 'characters_bloc.dart';\n\nabstract class CharactersState {}\n\nclass CharactersInitial extends CharactersState {}\n\nclass CharactersLoading extends CharactersState {}\n\nclass CharactersLoaded extends CharactersState {\n  CharacterEntity character;\n  CharactersLoaded({required this.character});\n}\n\nclass CharactersError extends CharactersState {\n  String? errorMessage;\n  CharactersError(this.errorMessage);\n}\n```\n\n둘째로, 이벤트를 위한 추상 클래스를 만들었습니다. 이 어플리케이션에서는 캐릭터만 가져올 것이기 때문에 GetCharacter 이벤트만 생성했습니다. 그리고 CharactersEvent 클래스에서 GetCharacters 클래스로 상속을 제공했습니다.\n\n```js\npart of 'characters_bloc.dart';\n\nabstract class CharactersEvent {}\n\nclass GetCharacters extends CharactersEvent {}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBloc으로부터 CharactersBloc으로 상속을 받았고, 클래스의 생성자 메서드에 이벤트를 추가했습니다. 그런 다음 데이터를 가져오기 위해 getCharacters 함수를 만들었습니다. 이 함수에서 API 결과에 따라 상황을 트리거했습니다.\n\n```js\npart 'characters_event.dart';\npart 'characters_state.dart';\n\nclass CharactersBloc extends Bloc\u003cCharactersEvent,CharactersState\u003e {\n   final GetCharacterUseCase _getCharactersUseCase;\n   CharactersBloc(this._getCharactersUseCase) : super(CharactersInitial()){\n     on\u003cGetCharacters\u003e(getCharacters);\n   }\n\n\n   Future\u003cvoid\u003e getCharacters(GetCharacters event, Emitter\u003cCharactersState\u003e emit) async {\n     emit(CharactersLoading());\n     final dataState = await _getCharactersUseCase.call(null);\n     if(dataState is DataSuccess){\n       emit(CharactersLoaded(character: dataState.data!));\n     } else if(dataState is DataFailed){\n       emit(CharactersError(dataState.exception!.message));\n     }\n   }\n}\n```\n\n마지막으로 CharactersPage를 작성했습니다. 상태를 감시하기 위해 BlocBuilder를 사용했습니다. 이것은 상태가 변경되었을 때 관련 함수를 반환할 수 있기 때문입니다.\n\n```js\n_buildBloc() {\n    return BlocBuilder(\n      bloc: _bloc,\n      builder: (BuildContext context, state) {\n        if(state is CharactersLoading){\n          return _showLoadingAnimation();\n        } else if(state is CharactersLoaded){\n          return _buildCharactersList(state);\n        } else if(state is CharactersError){\n          return _buildErrorView(state);\n        } else {\n          return _buildInitialView();\n        }\n      },\n    );\n  }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n화면이 로드되면 GetCharacters 이벤트를 트리거합니다.\n\n```js\n@override\nvoid initState() {\n  super.initState();\n  _bloc.add(GetCharacters());\n}\n```\n\n자세히 살펴보고 싶다면 GitHub 링크를 여기에서 찾을 수 있어요.\n\n😊 읽어 주셔서 감사합니다 😊\n","ogImage":{"url":"/assets/img/2024-06-22-Flutter-Bloc_0.png"},"coverImage":"/assets/img/2024-06-22-Flutter-Bloc_0.png","tag":["Tech"],"readingTime":6},{"title":"iOS에서 URLCache 사용하기 초보자를 위한 가이드","description":"","date":"2024-06-22 23:15","slug":"2024-06-22-URLCacheiniOSABeginnersGuide","content":"\n![이미지](/assets/img/2024-06-22-URLCacheiniOSABeginnersGuide_0.png)\n\niOS 개발자로서, 네트워크 요청을 효율적으로 관리하고 데이터를 캐시하는 방법을 이해하는 것은 앱의 성능과 사용자 경험을 크게 향상시킬 수 있습니다. URLCache는 애플이 제공하는 내장 프레임워크 중 하나로, 여러분이 이용할 강력한 도구 중 하나입니다. 이 가이드에서는 무엇인 URLCache인지, 핵심 개념, 실제 응용 사례, 그리고 iOS 프로젝트에서 효과적으로 사용하는 방법에 대해 알아보겠습니다.\n\n# URLCache란 무엇인가요?\n\nURLCache는 iOS의 Foundation 프레임워크에서 제공하는 메커니즘으로, URLSession과 같은 URL 로딩 시스템에서 응답을 캐시하여 네트워크 요청의 효율성을 향상시킬 수 있습니다. 이미지, JSON 또는 기타 리소스와 같은 다운로드된 데이터를 기기의 로컬에 저장하여 동일한 데이터를 반복적으로 네트워크에서 다시 가져오는 필요성을 줄입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 핵심 개념\n\n- 캐싱 정책: URLCache를 사용하여 다른 유형의 요청에 대한 캐싱 정책을 정의할 수 있습니다. 응답이 캐시에 얼마나 오랫동안 저장되어야 하는지 및 어떤 조건에서 서버를 통해 다시 유효성을 검사해야 하는지를 결정합니다.\n- 저장: 캐시된 응답은 디스크 기반 캐시에 저장되므로 앱이 닫혀도 다시 열릴 때까지 유지됩니다.\n- 유효성 검사: URLCache는 캐시된 응답을 서버와 유효성을 검사하기 위한 메커니즘을 제공하여 해당 응답이 여전히 유효하고 최신인지를 확인합니다.\n\n# 실용적인 응용\n\nURLCache는 다양한 시나리오에서 네트워크 요청을 최적화하고 사용자 경험을 향상시키는 데 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 성능 향상: 자주 액세스하는 데이터를 로컬로 캐싱하여 지연 시간을 줄이고 앱의 응답성을 향상시킬 수 있습니다.\n- 오프라인 지원: 캐시된 데이터는 기기가 오프라인 상태일 때도 액세스할 수 있어 사용자에게 원활한 경험을 제공합니다.\n- 대역폭 사용량 감소: 응답을 캐싱함으로써 네트워크를 통해 전송되는 데이터 양을 줄일 수 있습니다. 특히 데이터 요금제가 제한된 사용자에게 유용합니다.\n\n# URLCache 사용 방법\n\niOS 앱에서 URLCache를 사용하는 기본적인 단계를 살펴보겠습니다:\n\n## 초기화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지정된 메모리 용량 및 디스크 용량으로 URLCache 인스턴스를 초기화할 수 있어요:\n\n```js\nlet memoryCapacity = 4 * 1024 * 1024 // 4 MB\nlet diskCapacity = 100 * 1024 * 1024 // 100 MB\nlet urlCache = URLCache(memoryCapacity: memoryCapacity, diskCapacity: diskCapacity, diskPath: \"myCache\")\nURLCache.shared = urlCache // 공유 캐시로 설정\n```\n\n## 네트워크 요청 만들기\n\nURLSession을 사용하여 네트워크 요청을 만들 때 URLRequest에 지정된 캐싱 정책을 기반으로 URLCache가 자동으로 캐싱을 처리해 줘요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet url = URL(string: \"https://api.example.com/data\")!\nvar request = URLRequest(url: url)\nrequest.cachePolicy = .returnCacheDataElseLoad // 사용 가능한 캐시 데이터 사용\nlet task = URLSession.shared.dataTask(with: request) { data, response, error in\n    // 응답 처리\n}\ntask.resume()\n```\n\n## 캐싱 정책 이해하기\n\nURLCache는 응답을 저장하고 캐시에서 검색하는 방법을 지정하는 여러 가지 캐싱 정책을 제공합니다. 일반적인 캐싱 정책에 대해 알아보겠습니다:\n\n- .CachePolicy.useProtocolCachePolicy: 이 정책은 서버에서 보낸 캐싱 헤더를 기반으로 응답이 캐시되어야 하는지를 결정합니다. 서버가 Cache-Control 또는 Expires와 같은 캐싱 헤더를 지정하면 URLCache는 해당 지침을 따릅니다.\n- .CachePolicy.reloadIgnoringLocalCacheData: 이 정책을 사용하면 URLCache는 항상 로컬로 캐시된 응답을 무시하고 데이터를 직접 서버에서 가져옵니다.\n- .CachePolicy.returnCacheDataElseLoad: 이 정책은 사용 가능한 캐시된 응답을 반환하거나 네트워크에서 데이터를 가져옵니다. 앱 성능을 향상시키면서 데이터 신선도를 보장하는 데 흔히 사용되는 정책입니다.\n- .CachePolicy.returnCacheDataDontLoad: 이 정책은 캐시된 응답을 반환하되, 캐시된 데이터가 없으면 네트워크에서 데이터를 가져오지 않습니다. 오프라인으로 캐시된 데이터에 액세스할 수 있는 시나리오에 유용합니다.\n- .CachePolicy.reloadIgnoringCacheData: 이 정책을 사용하면 URLCache는 캐시된 응답을 무시하고 데이터를 항상 네트워크에서 가져옵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 응답 캐싱\n\n이제 URLCache를 사용하여 응답을 캐싱하는 방법을 살펴보겠습니다:\n\n```js\nlet url = URL(string: \"https://api.example.com/data\")!\nlet request = URLRequest(url: url)\n\nURLSession.shared.dataTask(with: request) { data, response, error in\n    guard let data = data, let httpResponse = response as? HTTPURLResponse, error == nil else {\n        // 오류 처리\n        return\n    }\n\n    if httpResponse.statusCode == 200 {\n        let cachedResponse = CachedURLResponse(response: httpResponse, data: data)\n        URLCache.shared.storeCachedResponse(cachedResponse, for: request)\n\n        // 데이터가 이제 캐싱되었습니다\n    }\n}.resume()\n```\n\n이 코드 샘플에서는 지정된 URL에서 데이터를 가져오기 위해 데이터 작업을 시작합니다. 성공적인 응답(상태 코드 200)을 받은 경우, 응답과 데이터를 캡슐화하는 CachedURLResponse 객체를 생성합니다. 그런 다음 이 응답을 미래 사용을 위해 캐시에 저장하기 위해 URLCache.shared.storeCachedResponse(\\_:for:)를 사용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐싱 정책을 이해하고 URLCache를 사용하여 응답을 캐시하는 방법을 알면 iOS 개발자는 네트워크 요청을 최적화하고 앱 성능을 향상시키기 위해 캐싱 메커니즘을 효과적으로 활용할 수 있습니다.\n\n## 사용자 정의\n\ncachedResponse(for:) 및 storeCachedResponse(\\_:for:)와 같은 메서드를 서브클래싱하고 오버라이딩하여 URLCache 동작을 사용자 정의할 수 있습니다. 이를 통해 앱 요구 사항에 맞는 사용자 정의 캐싱 전략을 구현할 수 있습니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nURLCache는 iOS 앱에서 네트워크 응답을 캐시하는 강력한 도구로, 다양한 캐싱 정책을 제공하여 다양한 요구 사항에 맞게 사용할 수 있습니다. 캐싱 정책을 숙지하고 캐싱 전략을 효과적으로 구현함으로써, 개발자들은 보다 부드럽고 반응성 있는 사용자 경험을 제공하는 앱을 만들 수 있습니다. iOS 프로젝트에서 캐싱을 실험해보고 URLCache를 최대한 활용해보세요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-06-22-URLCacheiniOSABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-06-22-URLCacheiniOSABeginnersGuide_0.png","tag":["Tech"],"readingTime":6},{"title":"Swift에서 weak와 unowned의 차이점 예제 포함","description":"","date":"2024-06-22 23:14","slug":"2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples","content":"\n\u003cimg src=\"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png\" /\u003e\n\n# 소개\n\nSwift에서는 메모리 관리가 ARC(Automatic Reference Counting)를 통해 이루어집니다. weak 및 unowned 참조의 주요 개념을 이해하는 것은 메모리 누수와 강한 참조 순환을 방지하는 데 매우 중요합니다. 이러한 참조들이 어떻게 다르며 올바르게 사용하는 방법을 알아보겠습니다.\n\n# weak 참조\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n약한 참조는 한 객체가 다른 객체 없이 존재할 수 있을 때 사용됩니다. 이는 객체의 참조 카운트를 증가시키지 않아 강력한 참조 순환을 방지하는 데 도움이 됩니다.\n\n약한 참조의 특징:\n\n- 가리키는 객체가 해제될 수 있기 때문에 항상 옵셔널 변수(var)로 선언됩니다. 이 경우에 참조는 nil이 됩니다.\n- 델리게이트와 클로저를 사용할 때 메모리 누수를 방지하는 데 특히 유용합니다.\n\n약한 참조를 사용한 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nclass Department {\n    var manager: Employee?\n\n    deinit {\n        print(\"Department is being deinitialized\")\n    }\n}\n\nclass Employee {\n    weak var department: Department?\n\n    deinit {\n        print(\"Employee is being deinitialized\")\n    }\n}\n\nvar department: Department? = Department()\nvar manager: Employee? = Employee()\n\ndepartment?.manager = manager\nmanager?.department = department\n\ndepartment = nil\nmanager = nil\n// Prints: \"Employee is being deinitialized\" and then \"Department is being deinitialized\"\n\n```\n\n이 예시에서, Department와 Employee간의 연결을 끊음으로써 메모리 누수를 피할 수 있습니다.\n\n## 클로저에서 weak 사용\n\n클로저에서 weak를 사용하는 것은 강한 참조 순환을 방지하기 위해 종종 필요한데, 특히 클로저가 self, 즉 클래스 인스턴스를 캡처할 때입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nViewController 클래스는 비동기 작업을 수행하는 클래스입니다. 이 작업이 완료된 후에 코드가 실행되도록 하고, 동시에 강한 참조 순환에 의한 메모리 누수를 방지해야 합니다.\n\nweak 키워드를 사용한 예시:\n\n```js\nclass ViewController: UIViewController {\n    var dataLoader: DataLoader?\n\n    func fetchData() {\n        dataLoader?.loadData(completion: { [weak self] result in\n            guard let self = self else { return }\n\n            switch result {\n            case .success(let data):\n                self.updateUI(with: data)\n            case .failure(let error):\n                self.showErrorMessage(error)\n            }\n        })\n    }\n\n    private func updateUI(with data: Data) {\n        // 사용자 인터페이스 업데이트\n    }\n\n    private func showErrorMessage(_ error: Error) {\n        // 에러 메시지 표시\n    }\n}\n\nclass DataLoader {\n    func loadData(completion: @escaping (Result\u003cData, Error\u003e) -\u003e Void) {\n        // 데이터 로드 코드\n    }\n}\n```\n\n위 예시에서:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ViewController에는 DataLoader의 loadData 메서드를 호출하는 fetchData 메서드가 있습니다.\n- loadData에 전달된 클로저 내에서 [weak self]를 사용하여 ViewController의 인스턴스인 self에 강한 참조를 방지합니다. 이는 DataLoader가 클로저를 오랫동안 유지할 수 있기 때문에 중요합니다. 예를 들어 비동기 작업 중에 발생할 수 있습니다.\n- 클로저 내에서 self에 안전하게 액세스하기 위해 guard let self = self else 'return'을 사용합니다. 만약 ViewController가 클로저가 실행되기 전에 해제되면 self는 nil이 되어 클로저 내의 코드가 실행되지 않아 잠재적인 오류나 충돌을 방지합니다.\n\n# unowned 참조\n\nunowned 참조는 weak와 유사하지만 두 가지 주요 차이점이 있습니다: 옵셔널이 아니며, 가리키는 객체가 해제될 때 nil이 되지 않습니다.\n\n## unowned 참조의 특징:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다른 객체가 해제되기 전까지 한 객체를 해제하지 않을 때 사용됩니다.\n- 객체가 해제된 후 비소유 참조에 접근하면 충돌이 발생합니다.\n- 상수(let)와 함께만 작동합니다.\n\n비소유 참조를 사용한 예시:\n\n```js\nclass Customer {\n    let name: String\n    var card: CreditCard?\n\n    init(name: String) {\n        self.name = name\n    }\n\n    deinit {\n        print(\"\\(name) 해제 중\")\n    }\n}\n\nclass CreditCard {\n    let number: UInt64\n    unowned let customer: Customer\n\n    init(number: UInt64, customer: Customer) {\n        self.number = number\n        self.customer = customer\n    }\n\n    deinit {\n        print(\"카드 #\\(number) 해제 중\")\n    }\n}\n\nvar john: Customer? = Customer(name: \"John\")\njohn!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)\n\njohn = nil\n// 출력: \"John 해제 중\" 그리고 \"카드 #1234567890123456 해제 중\"\n```\n\n여기서 Customer가 해제된 후 관련된 CreditCard 객체도 해제되어 메모리 누수를 방지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 약한 참조와 미소유 참조 비교\n\n- 선언: 약한 참조는 항상 옵셔널이지만, 미소유 참조는 상수로 값이 옵셔널이 아닙니다.\n- 강한 참조 순환: 둘 다 강한 참조 순환을 방지하지만, 각각 다른 상황에서 사용됩니다.\n- 안전성: 약한 참조는 객체가 해제될 때 자동으로 nil이 되어 안전합니다. 미소유 참조는 객체가 파괴되면 크래시가 발생할 수 있습니다. 무엇을 하는지 잘 알아야 합니다.\n\n# 결론\n\nSwift에서 약한 참조와 미소유 참조의 차이를 이해하는 것은 안전하고 효율적인 메모리 관리를 위해 중요합니다. 두 참조 사이의 선택은 애플리케이션의 구조와 객체 간 관계에 따라 다릅니다. 항상 메모리 누수를 확인하여 신뢰성과 성능을 보증할 수 있도록 코드를 테스트하세요.\n","ogImage":{"url":"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png"},"coverImage":"/assets/img/2024-06-22-DifferencesbetweenweakandunownedinSwiftwithexamples_0.png","tag":["Tech"],"readingTime":6},{"title":"4단계로 iOS 앱에 실시간 활동 추가하는 방법","description":"","date":"2024-06-22 23:13","slug":"2024-06-22-AddLiveActivitiestoyouriOSappin4steps","content":"\n## iOS에서 라이브 액티비티로 사용자 경험과 실시간 상호작용 향상\n\n이미 라이브 액티비티를 앱에 통합하지 않았다면, 이제 강력한 잠재력을 고려해보는 것이 좋습니다.\n\n라이브 액티비티는 호환되는 아이폰의 잠금 화면과 다이나믹 아일랜드에 자연스럽게 나타나는 전용 UI로, 이 기능을 활용하면 사용자가 앱의 주요 부분을 벗어나도 사용자와 상호작용을 유지할 수 있습니다.\n\n푸시 알림을 보내지 않고 업데이트를 보내거나 실시간 정보를 표시할 수 있습니다. 그리고 가장 좋은 점은? 이를 추가하는 것이 놀랍도록 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에 그것을 하는 방법이 있어요.\n\n![image1](/assets/img/2024-06-22-AddLiveActivitiestoyouriOSappin4steps_0.png)\n\n![image2](https://miro.medium.com/v2/resize:fit:460/1*RqsG45Gbo625UNKcIUElTQ.gif)\n\n## 단계1 — 라이브 활동 콘텐츠 정의\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가장 처음으로 할 일은 라이브 활동에서 보여줄 정보를 정의하는 것입니다. 제한된 공간 때문에 사용자가 중요하게 생각할 데이터에 집중해야 합니다.\n\n그 생각을 기억하고 다음으로 할 일은 ActivityAttributes 프로토콜을 구현하는 것입니다.\n\n```js\npublic protocol ActivityAttributes : Decodable, Encodable {\n\n    /// 라이브 활동의 동적 콘텐츠를 설명하는 연관 타입.\n    ///\n    /// `ContentState`로 인코딩된 라이브 활동의 동적 데이터는 4KB를 초과할 수 없습니다.\n    associatedtype ContentState : Decodable, Encodable, Hashable\n}\n```\n\n알 수 있듯이, 우리는 정보를 두 가지 범주로 나눌 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 정적 → ActivityAttributes를 구현하는 모델의 속성입니다.\n- 동적 → ContentState 타입에 저장됩니다.\n\n우리 경우에는 다음과 같이 정보를 정리할 수 있습니다:\n\n- 정적 → 주문 번호입니다. 사용자가 주문을 하면 번호가 바뀌지 않습니다.\n- 동적 → 주문 상태로, 주문의 현재 단계를 나타냅니다.\n\n```js\nstruct OrderAttributes: ActivityAttributes {\n\n    struct ContentState: Codable, Hashable {\n        enum OrderStatus: Float, Codable, Hashable {\n            case inQueue = 0\n            case aboutToTake\n            case making\n            case ready\n\n            var description: String {\n                switch self {\n                case .inQueue:\n                    return \"주문이 대기 중입니다\"\n                case .aboutToTake:\n                    return \"주문을 받을 준비 중입니다\"\n                case .making:\n                    return \"주문을 준비 중입니다\"\n                case .ready:\n                    return \"주문이 수령 가능합니다!\"\n                }\n            }\n        }\n\n        let status: OrderStatus\n    }\n\n    let orderNumber: Int\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2 — UI 생성하기\n\n라이브 활동 UI는 앱의 위젯 범위에 있습니다. 따라서 앱에 위젯 확장 기능이 없는 경우, 먼저 하나를 생성해야 합니다.\n\n새로운 위젯 뷰를 생성하고 위젯 구현에서 ActivityConfiguration의 인스턴스를 반환합니다. 이전 단계에서 만든 ActivityAttributes 모델을 사용해야 합니다.\n\n```js\nstruct CoffeeShopWidgetLiveActivity: Widget {\n\n    var body: some WidgetConfiguration {\n        ActivityConfiguration(for: OrderAttributes.self) { context in\n            // 여기에 잠금 화면/배너 UI가 들어갑니다\n            LiveActivityView(state: context.state)\n        } dynamicIsland: { context in\n            // 동적 아일랜드 구현이 이곳에 들어갑니다\n            // 이 기사의 범위를 벗어난 내용입니다\n             ...\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLiveActivityView 내에서는 Live Activity UI를 구성합니다.\n\n```js\nstruct LiveActivityView: View {\n    let state: OrderAttributes.ContentState\n\n    var body: some View {\n        VStack {\n            HStack {\n                Image(systemName: \"cup.and.saucer\")\n                ProgressView(value: state.status.rawValue, total: 3)\n                    .tint(.black)\n                    .background(Color.brown)\n                Image(systemName: \"cup.and.saucer.fill\")\n            }\n            .padding(16)\n\n            Text(\"\\(state.status.description)\")\n                .font(.system(size: 18, weight: .semibold))\n                .padding(.bottom)\n            Spacer()\n        }\n        .background(Color.brown.opacity(0.6))\n    }\n}\n```\n\n마지막으로, Live Activity 위젯을 위한 위젯 번들에 추가해야 합니다. 이 경우, 위젯을 제공하지 않을 것이므로 Live Activity만 사용합니다.\n\n```js\n@main\nstruct CoffeeShopWidgetBundle: WidgetBundle {\n    var body: some Widget {\n        CoffeeShopWidgetLiveActivity()\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 3 — 라이브 활동 초기화\n\n라이브 활동과 상호 작용하는 데는 ActivityKit API를 사용해야 합니다.\n\n먼저, ActivityContent의 생성자인 init(state:staleDate:relevanceScore:)를 사용하여 라이브 활동의 초기 내용을 만들어야 합니다.\n\n- state: 라이브 활동에 대한 초기 ActivityAttributes.ContentState입니다.\n- staleDate: 라이브 활동이 오래되었음을 OS에 알리기 위한 날짜입니다. staleDate가 지정되지 않으면, 8시간 후 OS가 라이브 활동을 종료합니다.\n- relevanceScore: 여러 개의 라이브 활동이 있는 경우, relevanceScore는 다이나믹 아일랜드에 표시할 우선순위와 잠금 화면의 순서를 나타냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 Activity 메서드 request(attributes: content: pushType:)를 호출하여 새로운 라이브 액티비티를 요청할 수 있어요.\n\n- attributes: Step 1에서 생성한 ActivityAttributes의 인스턴스입니다.\n- content: 라이브 액티비티의 초기 콘텐츠입니다.\n- pushType: 라이브 액티비티의 업데이트가 ActivityKit 푸시 알림에서 올 것인지를 나타냅니다. 업데이트 기능만 사용할 경우에는 nil을 전달할 수 있어요.\n\n📣 중요한 알림: 새로운 Activity를 요청할 때 앱은 활성화 상태여야 해요.\n\n```js\nlet orderAttributes = OrderAttributes(orderNumber: 1)\nlet initialState = OrderAttributes.ContentState(status: .inQueue)\nlet content = ActivityContent(state: initialState, staleDate: nil, relevanceScore: 1.0)\n\ndo {\n    let orderActivity = try Activity.request(\n        attributes: orderAttributes,\n        content: content,\n        pushType: nil\n    )\n} catch {\n    print(error.localizedDescription)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 4 — 라이브 활동 업데이트\n\n라이브 활동을 업데이트하려면 update(\\_:) 함수를 사용할 수 있습니다. 초기 상태를 생성한 것과 마찬가지로 업데이트로 ActivityContent를 작성할 수 있습니다.\n\n```js\nawait orderActivity?.update(\n    ActivityContent\u003cOrderAttributes.ContentState\u003e(\n        state: state,\n        staleDate: nil\n    )\n)\n```\n\n라이브 활동을 종료하려면 end(\\_:dismissalPolicy:) 함수를 사용합니다. 사용하는 종료 정책에 따라 라이브 활동은 사용자가 명시적으로 제거할 때까지 잠금 화면에 남게될 수 있습니다. 이것이 마지막 라이브 활동 상태를 전달하여 UI를 항상 최신 상태로 유지해야하는 이유입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 가능한 해제 정책 옵션은 세 가지입니다.\n\n- default: 라이브 액티비티는 최대 4시간 동안 잠금 화면에 유지됩니다. (사용자가 제거할 때까지)\n- immediate: 운영 체제가 즉시 라이브 액티비티를 제거합니다.\n- after(\\_ date:): 라이브 액티비티를 해제할 날짜를 지정할 수 있습니다. (라이브 액티비티 종료 시간으로부터 4시간 이내여야 함)\n\n# 다음 단계는 무엇인가요?\n\n앱의 사용 사례를 신중하게 고려해보세요. 라이브 액티비티는 배송 앱이나 스포츠 이벤트와 같은 실시간 애플리케이션에 특히 적합하지만, 푸시 알림에 대한 매력적인 대안으로도 사용될 수 있어 사용자에게 더 매력적인 경험을 제공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 풍부한 사용자 경험을 위해 라이브 활동에 딥 링크를 통합하여 사용자가 라이브 활동을 탭할 때 연결이 원활하도록 할 수 있습니다.\n\n질문이 있으시면 언제든지 메시지 남겨주세요! 🙂\n\n- 🤓 iOS 개발 팁과 통찰을 정기적으로 제공하는 제 트위터에 참여해보세요.\n- 🚀 나의 예제 프로젝트를 모두 공유하는 GitHub를 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-06-22-AddLiveActivitiestoyouriOSappin4steps_0.png"},"coverImage":"/assets/img/2024-06-22-AddLiveActivitiestoyouriOSappin4steps_0.png","tag":["Tech"],"readingTime":9},{"title":"Swift 비동기 처리에서 경합 상태 버그 해결 방법 ","description":"","date":"2024-06-22 23:11","slug":"2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency","content":"\n\u003cimg src=\"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png\" /\u003e\n\niOS 캘린더 스케줄러에는 '기본 캘린더' 기능이 있어요. Apple 캘린더와 같은 외부 캘린더와 통합한 후에, 이 설정은 이벤트를 추가할 때 가장 자주 사용하는 캘린더가 기본적으로 선택되도록 합니다. 이 기능은 사용자가 정의한 '기본 캘린더'를 연결된 캘린더에서 이벤트 스케줄링 시에 에디터의 '캘린더 선택' 섹션에서 자동으로 선택되도록 설정합니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_1.png\" /\u003e\n\n# 💡 경합 조건으로 인한 문제 해결하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 때로는 다른 닠린더가 선택된 경우도 있었습니다. 항상 그런 것은 아니었고, 대부분의 경우 정상적으로 작동했습니다. 제가 이 문제를 디버그하는 방법을 잘 모르겠었는데, 가끔 발생하는 문제라서 더욱 더 어려웠습니다. 가끔씩 발생하더라도, 이 기능이 제대로 작동하지 않으면 사용자가 잘못된 링크된 달력에 이벤트를 알지 못하게 추가할 수 있어 나중에 불필요한 수정을 유발할 수 있습니다.\n\n최근에 이 문제를 해결할 실마리를 찾았습니다. Xcode 16 베타 버전의 새 기능에 대한 호기심으로 설치한 후 보게 된 경고 메시지 덕분이었습니다. 이 경고는 이전 버전의 Xcode에서는 나타나지 않았고, 스위프트 6의 보다 엄격한 Actor Isolation 규칙으로 인해 발생했습니다. 이 규칙은 동시성 모델을 더 안전하게 만들기 위한 것입니다.\n\n![Image](/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_2.png)\n\n스위프트에서 Actor는 동시성 모델로, 내부 함수와 속성을 동시 액세스로부터 보호합니다. Actors는 수행하는 작업을 직렬화하여 각 작업이 순차적으로 실행되도록 합니다. 이를 통해 경합 조건 및 데이터 경주와 같은 동시성 문제를 방지할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경주 조건은 시스템의 동작이 실행 순서에 따라 달라질 수 있는 다중 스레드 프로그래밍에서 중요한 개념입니다. 다시 말해, 경주 조건은 두 개 이상의 작업이 병렬로 실행되고 결과가 실행 순서나 시간에 따라 변경될 수 있는 경우 발생합니다. 경주 조건이 발생하면 프로그램이 예측할 수 없이 동작하거나 예상치 못한 결과를 내놓을 수 있습니다.\n\n데이터 경주는 두 개 이상의 스레드가 동시에 동일한 메모리 위치에 액세스하고, 그 중 적어도 하나가 쓰기 작업을 수행하는 경우 발생합니다. 이는 메모리 일관성을 파괴하고 예측할 수 없는 프로그램 동작으로 이어질 수 있습니다. Swift의 Actor는 이러한 문제를 방지하기 위해 상태를 안전하게 격리합니다.\n\n제 코드에서는 메인 Actor 콘텍스트에서 Actor로 격리된 ekRepository의 eventStore 속성에 액세스하려고 시도했으며, 이로 인해 Swift 6에서 컴파일 오류가 발생했습니다. 코드의 문제가 요약된 부분은 다음과 같습니다:\n\n```swift\nimport EventKit\n\nactor EKRepository {\n    let eventStore: EKEventStore\n\n    init() {\n        self.eventStore = EKEventStore()\n    }\n}\n\n@MainActor\nfinal class EKInteractor: ObservableObject {\n    private let ekRepository: EKRepository\n\n    var eventStore: EKEventStore {\n        /// 🔥 Actor-isolated property 'eventStore' can not be referenced from the main actor;\n        /// 🔥 this is an error in the Swift 6 language mode.\n        ekRepository.eventStore\n    }\n\n    init(ekRepository: EKRepository) {\n        self.ekRepository = ekRepository\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 이 코드를 처음 작성할 때 'eventStore'가 'EKRepository' 내에서만 액세스되도록 보장하는 것이 목표였습니다. 처음에는 EKInteractor가 속성으로 eventStore를 정의하지 않았습니다. 그러나 EKEventEditViewController와 같은 Apple에서 제공하는 UI에 EKEventStore를 매개변수로 전달해야 하는 상황이 많았습니다. 그 결과, EKInteractor는 eventStore을 노출하기 시작했습니다.\n\n하지만, EKInteractor가 Actor Isolation을 무시하고 ekRepository의 eventStore에 액세스하고 있다면, 이는 경합 조건과 예기치 않은 문제를 초래할 수 있습니다.\n\n이를 해결하기 위해 코드를 리팩토링하여 Actor Isolation을 준수하도록 만들어 경합 조건을 피했습니다. 리팩토링된 코드는 다음과 같습니다:\n\n```swift\nactor EKRepository {\n    /// 💡 'getEventStore()' 메서드를 사용하여 eventStore에 대한 액세스 캡슐화\n    private let eventStore: EKEventStore\n\n    init() {\n        self.eventStore = EKEventStore()\n    }\n}\n\nextension EKRepository {\n    func getEventStore() -\u003e EKEventStore {\n        return eventStore\n    }\n}\n\n@MainActor\nfinal class EKInteractor: ObservableObject {\n    private let ekRepository: EKRepository\n\n    private var cachedEventStore: EKEventStore? = nil\n\n    /// 💡 Actor Isolation을 준수하면서 eventStore에 비동기적으로 액세스하고 캐시합니다.\n    /// 우선 캐시된 eventStore이 있는지 확인하고,\n    /// 그렇지 않으면 EKRepository의 getEventStore 메서드를 비동기적으로 호출하여 eventStore을 가져와 캐시합니다.\n    var eventStore: EKEventStore {\n        get async {\n            if let eventStore = cachedEventStore {\n                return eventStore\n            }\n\n            let store = await ekRepository.getEventStore()\n            cachedEventStore = store\n            return store\n        }\n    }\n\n    init(ekRepository: EKRepository) {\n        self.ekRepository = ekRepository\n\n        /// 💡 시작할 때 eventStore을 비동기적으로 가져와 캐싱하여 이후 액세스 성능을 향상시킵니다.\n        initEventStore(ekRepository: ekRepository)\n    }\n}\n\nextension EKInteractor {\n    private func initEventStore(ekRepository: EKRepository) {\n        /// 💡 [Task] 이 메서드는 eventStore을 비동기적으로 가져와 캐시하지만,\n        /// 이 프로세스가 완료되기 전에 후속 작업이 진행될 수 있습니다.\n        Task {\n            self.cachedEventStore = await ekRepository.getEventStore()\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, 'Default Calendar'를 설정하는 부분에서 레이스 컨디션에 민감한 코드를 발견했어요. 아래 코드에서는 newEKEvent의 캘린더(타입은 EKCalendar)가 Task 블록 내에서 비동기로 설정되어 있습니다. 이 비동기 작업은 getNewEKEvent 함수가 newEKEvent 객체를 반환한 뒤에 실행될 수 있습니다. 이는 반환된 newEKEvent 객체를 다른 곳에서 사용하려고 할 때 캘린더 속성이 아직 설정되지 않을 수 있다는 의미입니다. 이러한 상황은 '실행 순서(execution order)'에 따라 예측할 수 없는 동작을 유발할 수 있으며, 이는 해결하고자 했던 간헐적 버그와 일치합니다.\n\n```js\nprivate func getNewEKEvent(ekInteractor: EKInteractor, selectedDate: Date) -\u003e EKEvent {\n    let newEKEvent = EKEvent(eventStore: ekInteractor.eventStore)\n\n    // 🔥 문제: 이 Task 블록은 비동기로 실행되므로, 함수가 newEKEvent를 반환한 후에 실행될 수 있습니다.\n    Task {\n        // 🔥 문제: 비동기 작업이 newEKEvent 반환 후에 완료된 경우, 캘린더 속성이 아직 설정되지 않을 수 있습니다.\n        if let defaultEKCalendarToAdd = await ekInteractor.getDefaultEKCalendarToAdd() {\n            newEKEvent.calendar = defaultEKCalendarToAdd\n        }\n    }\n\n    // 🔥 문제: 함수가 비동기 작업이 완료되기 전에 newEKEvent를 반환하므로, 데이터 레이스와 레이스 컨디션이 발생할 수 있습니다.\n    return newEKEvent\n}\n```\n\n요약하면, 위의 코드는 '레이스 컨디션'의 대상이 될 수 있으며, 비동기 작업이 완료되기 전에 객체가 반환됩니다. 이 문제는 아래에 표시된 대로 코드를 재구성하여 해결할 수 있습니다.\n\n```js\n/// 💡 비동기 작업을 수행할 수 있도록 getNewEKEvent 함수를 async로 선언하여,\n/// 모든 비동기 작업이 완료된 후에만 newEKEvent가 반환되도록 함.\n/// ---\u003e 레이스 컨디션과 데이터 레이스 방지\nprivate func getNewEKEvent(ekInteractor: EKInteractor, selectedDate: Date) async -\u003e EKEvent {\n    /// 💡 eventStore를 비동기로 가져오기 위해 await 사용\n    let newEKEvent = EKEvent(eventStore: await ekInteractor.eventStore)\n\n    /// 💡 defaultEKCalendarToAdd를 비동기로 가져와 newEKEvent의 캘린더 속성에 설정\n    if let defaultEKCalendarToAdd = await ekInteractor.getDefaultEKCalendarToAdd() {\n        newEKEvent.calendar = defaultEKCalendarToAdd\n    }\n\n    /// 💡 모든 비동기 작업이 완료된 후에 newEKEvent 반환\n    return newEKEvent\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 문제를 해결하면서 Swift 동시성에 대한 이해가 깊어졌습니다. 안전한 동시 코드 작성의 기초를 확립할 수 있어 기쁩니다. 무엇보다도, Scheduler 앱의 다음 업데이트에서 사용자에게 흠잡을 데 없는 '기본 캘린더' 기능을 제공할 수 있어 기쁩니다.\n\n'Reminders'부터 '기본 캘린더'까지 모든 것을 신속하게 통합하세요.\n다양한 위젯.\nScheduler: iPhone, iPad 및 Mac용 캘린더 앱.\n\n# 참고문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Swift 프로그래밍 언어 — 동시성:\n  https://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/\n- Apple 개발자 문서 — Swift 동시성:\n  https://developer.apple.com/documentation/swift/concurrency\n- Apple 개발자 문서 — EKEventStore:\n  https://developer.apple.com/documentation/eventkit/ekeventstore\n- 경합 조건 이해와 해결:\n  https://en.wikipedia.org/wiki/Race_condition\n- Apple 개발자 문서 — Task:\n  https://developer.apple.com/documentation/swift/task\n\n이러한 자료들은 Swift 동시성, 액터 및 관련 주제에 대해 자세한 정보를 제공하여 경합 조건과 같은 문제를 이해하고 해결하는 데 도움이 됩니다.\n","ogImage":{"url":"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png"},"coverImage":"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png","tag":["Tech"],"readingTime":9},{"title":"SwiftData로 원격 API에서 데이터 저장하는 방법","description":"","date":"2024-06-22 23:10","slug":"2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI","content":"\n앱 사용자에게 오프라인 기능을 제공하고 앱 운영 비용을 줄이는 데 중요한 로컬 데이터 저장은 매우 중요합니다.\n\n[![Image](/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png)](//)\n\n시작하기 전에 몇 초 동안 제 게시물을 팔로우하고 👏 클랩(clap)하여 더 많은 사람들이 이 유용한 내용을 배울 수 있도록 도와주세요.\n\n# API 호출로부터 SwiftData를 사용하여 로컬로 데이터 저장하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드로 넘어가기로 하겠습니다. SwiftData에 익숙하지 않으신 경우, 새로운 내용을 익히시려면 이 기사를 확인해보세요.\n\n우리는 구조체의 이름 뒤에 약어 DTO(Data Transfer Object)를 추가하기로 결정했습니다. DTO는 한 시스템에서 다른 시스템으로 데이터를 전송하는 데 사용됩니다. 우리의 예제에서는 API 응답의 데이터를 JSON에서 SwiftData entity로 전송하려고 합니다. DTO는 JSON 응답을 일시적으로 보유하여 해당 데이터를 파싱하고 Swift 객체로 변환할 수 있게 합니다. 앞으로 몇 개의 코드 블록에서는 해당 Swift 객체를 SwiftData entity로 변환할 것입니다.\n\n```swift\n// PhotoDTO.swift\nimport Foundation\n\nstruct PhotoDTO: Identifiable, Codable {\n    let albumId: Int\n    let id: Int\n    let title: String\n    let url: String\n    let thumbnailUrl: String\n}\n```\n\nSwiftData로 시작하는 기사를 읽으신 경우, 이 내용은 익숙하게 느껴질 것입니다. 클래스에 새로운 코드 조각을 추가했는데, 그것은 편의 이니셜라이저입니다. 이를 통해 DTO를 직접 전달하여 SwiftData entity를 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n//  PhotoObject.swift\nimport Foundation\nimport SwiftData\n\n@Model\nclass PhotoObject {\n    var albumId: Int\n    @Attribute(.unique) var id: Int\n    var title: String\n    var url: String\n    var thumbnailUrl: String\n\n    init(albumId: Int, id: Int, title: String, url: String, thumbnailUrl: String) {\n        self.albumId = albumId\n        self.id = id\n        self.title = title\n        self.url = url\n        self.thumbnailUrl = thumbnailUrl\n    }\n\n    convenience init(item: PhotoDTO) {\n        self.init(\n            albumId: item.albumId,\n            id: item.id,\n            title: item.title,\n            url: item.url,\n            thumbnailUrl: item.thumbnailUrl\n        )\n    }\n}\n```\n\n웹 서비스도 만약 SwiftUI에서 API 호출을 만들고 파싱한 적이 있다면 익숙할 것입니다. 웹 서비스를 살펴보면, 그 기사에서 살짝 수정하여 새로운 기능을 보유한 웹 서비스를 가지고 있다는 것을 알 수 있습니다. updateDataInDatabase를 이용해 API 호출에서 데이터를 파싱할 때마다 데이터를 데이터베이스에 저장할 수 있도록 새 기능을 추가했습니다. updateDataInDatabase 함수는 PhotoDTO를 SwiftData 엔티티로 변환하고 각 레코드를 데이터베이스에 저장하는 메서드입니다. 또한, ID로 찾을 수 없는 경우 새 레코드를 생성할지 또는 기존 레코드를 업데이트할지 결정하기 위해 insert 메서드를 사용하고 있음을 알 수 있습니다.\n\n```swift\n//  WebService.swift\nimport Foundation\nimport SwiftData\n\nenum NetworkError: Error {\n    case badUrl\n    case invalidRequest\n    case badResponse\n    case badStatus\n    case failedToDecodeResponse\n}\n\nclass WebService {\n    @MainActor\n    func updateDataInDatabase(modelContext: ModelContext) async {\n        do {\n            let itemData: [PhotoDTO] = try await fetchData(fromUrl: \"https://jsonplaceholder.typicode.com/albums/1/photos\")\n            for eachItem in itemData {\n                let itemToStore = PhotoObject(item: eachItem)\n                modelContext.insert(itemToStore)\n            }\n        } catch {\n            print(\"Error fetching data\")\n            print(error.localizedDescription)\n        }\n    }\n\n    private func fetchData\u003cT: Codable\u003e(fromUrl: String) async throws -\u003e [T] {\n        guard let downloadedData: [T] = await WebService().downloadData(fromURL: fromUrl) else { return [] }\n\n        return downloadedData\n    }\n\n    private func downloadData\u003cT: Codable\u003e(fromURL: String) async -\u003e T? {\n        do {\n            guard let url = URL(string: fromURL) else { throw NetworkError.badUrl }\n            let (data, response) = try await URLSession.shared.data(from: url)\n            guard let response = response as? HTTPURLResponse else { throw NetworkError.badResponse }\n            guard response.statusCode \u003e= 200 \u0026\u0026 response.statusCode \u003c 300 else { throw NetworkError.badStatus }\n            guard let decodedResponse = try? JSONDecoder().decode(T.self, from: data) else { throw NetworkError.failedToDecodeResponse }\n\n            return decodedResponse\n        } catch NetworkError.badUrl {\n            print(\"There was an error creating the URL\")\n        } catch NetworkError.badResponse {\n            print(\"Did not get a valid response\")\n        } catch NetworkError.badStatus {\n            print(\"Did not get a 2xx status code from the response\")\n        } catch NetworkError.failedToDecodeResponse {\n            print(\"Failed to decode response into the given type\")\n        } catch {\n            print(\"An error occured downloading the data\")\n        }\n\n        return nil\n    }\n}\n```\n\n뷰 레이어에서는 데이터베이스에서 PhotoObjects를 읽어와 목록으로 표시합니다. 목록 내에서는 AsyncImage 구성 요소를 사용해 API에서 이미지를 표시하고 해당 항목의 ID를 이미지 옆에 표시합니다. 목록의 하단에는 몇 가지 다른 변형을 추가했습니다. overlay 변형은 목록이 비어 있을 때 진행 스피너를 표시합니다. task 변형은 목록이 비어 있으면 API에서 데이터를 자동으로 가져오도록 합니다. 또한, refreshable 변형을 사용해 목록 구성 요소에 pull to refresh를 추가했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"task\" 및 \"refreshable\" 수정자를 사용하면 사용자가 업데이트된 데이터를 확인하려고 할 때만 API가 호출되도록 보장합니다(API를 실행하는 비용을 줄임). 이는 앱을 런칭할 때마다 API에서 데이터를 가져오는 대신 두 번째로 데이터가 데이터베이스에서 가져와지게 함을 의미합니다.\n\n또한 미리보기가 일반적인 경우보다 코드가 더 많이 보일 수 있습니다. SwiftData에서 데이터를 미리보는 것은 일반적인 뷰에서 데이터를 표시하는 것보다 조금 더 복잡하기 때문입니다. 미리보기에서는 데이터가 임시로 저장되는 새 컨테이너를 만들고(미리보기 장치에 데이터를 영구적으로 저장하지 않기 위함), 그런 다음 객체를 만들어 그 컨테이너에 저장합니다. 미리보기 데이터를 저장하는 별도의 파일을 생성하는 다른 자습서도 볼 수 있지만 이는 작동하며 전혀 문제가 없습니다. 저는 미리보기에 대한 코드를 미리보기 자체에 가까이 유지하고 싶어하여 별도의 파일을 생성하지 않았습니다.\n\n```js\n//  ContentView.swift\nimport SwiftData\nimport SwiftUI\n\nstruct ContentView: View {\n    @Environment(\\.modelContext) var modelContext\n    @Query(sort: \\PhotoObject.id) var photos: [PhotoObject]\n\n    var body: some View {\n        List(photos) { item in\n            HStack {\n                Text(item.id, format: .number)\n                Spacer()\n\n                AsyncImage(url: URL(string: item.url)!) { imagePhase in\n                    switch imagePhase {\n                    case .empty:\n                        Image(systemName: \"ellipsis\")\n                    case .success(let returnedImage):\n                        returnedImage\n                            .resizable()\n                            .scaledToFit()\n                    case .failure:\n                        Image(systemName: \"xmark.circle\")\n                            .font(.headline)\n                            .foregroundColor(.red)\n                    @unknown default:\n                        Image(systemName: \"ellipsis\")\n                    }\n                }\n            }\n        }\n        .overlay {\n            if photos.isEmpty {\n                ProgressView()\n            }\n        }\n        .task {\n            if photos.isEmpty {\n                await WebService().updateDataInDatabase(modelContext: modelContext)\n            }\n        }\n        .refreshable {\n            await WebService().updateDataInDatabase(modelContext: modelContext)\n        }\n    }\n}\n\n#Preview {\n    do {\n        let config = ModelConfiguration(isStoredInMemoryOnly: true)\n        let container = try ModelContainer(for: PhotoObject.self, configurations: config)\n        let sampleObject = PhotoObject(\n            albumId: 1,\n            id: 1,\n            title: \"accusamus beatae ad facilis cum similique qui sunt\",\n            url: \"https://via.placeholder.com/600/92c952\",\n            thumbnailUrl: \"https://via.placeholder.com/150/92c952\"\n        )\n        container.mainContext.insert(sampleObject)\n\n        return ContentView().modelContainer(container)\n    } catch {\n        fatalError(\"Failed to create model container\")\n    }\n}\n```\n\n이 글이 유익하다고 느끼신다면, 제를 팔로우하는 것, 이 글에 👏 반응을 보내는 것, 또는 공유하여 다른 사람이 더 쉽게 찾을 수 있도록 돕는 것도 고려해주세요.\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 주제에 대해 궁금한 점이 있거나 동일한 작업을 수행하는 다른 방법을 알고 계신다면, 이 게시물에 답글을 달거나 친구에게 공유하여 의견을 얻을 수 있습니다. Native 모바일 개발에 대해 더 배우고 싶다면, 여기에서 작성한 다른 기사들을 확인해보세요: [https://medium.com/@jpmtech](https://medium.com/@jpmtech). Native 모바일 개발로 제작된 앱들을 보고 싶다면, 여기에서 제가 만든 앱들을 확인해보세요: [https://jpmtech.io/apps](https://jpmtech.io/apps). 제 작품을 확인해주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png"},"coverImage":"/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png","tag":["Tech"],"readingTime":9},{"title":"SwiftUI에서 제스처 완벽하게 활용하는 방법 종합 가이드","description":"","date":"2024-06-22 23:09","slug":"2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide","content":"\n앱이라는 힘을 상상해보세요. 각 탭, 스와이프 및 핀치로 UI를 생동감 있게 만들어보세요.\n\n![이미지](/assets/img/2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide_0.png)\n\n직관적인 제스처의 마법은 정적인 인터페이스를 동적이고 매력적인 경험으로 변화시킬 수 있습니다. 사용자들이 사랑하는 경험으로 만들어 주죠. 사용자가 쉽게 줌 인/아웃 및 패닝을 할 수 있는 사진 편집기, 창의성이 모든 드래그로부터 흘러나오는 그림 앱, 반응형 스와이프 제어가 있는 게임을 만드는 중이라면 SwiftUI에서 제스처를 마스터하는 것이 이런 가능성을 해제하는 열쇠입니다.\n\n이 포괄적인 가이드에서 기초부터 고급 기술까지 안내해 드릴 것이며, SwiftUI의 제스처 인식기를 활용하여 매끄럽고 상호작용적인 사용자 경험을 만드는 방법을 공개할 것입니다. 실용적인 예제에 대해 깊이 파헤치고, 현실 세계의 사용 사례를 소개하며, 제스처 충돌을 처리하고 접근성을 보장하는 전문 팁을 제공할 것입니다. 이 여정을 마치면 SwiftUI 프로젝트에서 제스처의 모든 잠재력을 활용할 수 있는 준비가 되어 있을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwiftUI의 제스처에 대한 소개\n\nSwiftUI에서 제스처는 탭, 스와이프 및 드래그와 같은 사용자 상호 작용을 감지하고 응답하는 데 사용됩니다. SwiftUI에는 기본 제스처 인식기가 제공되어 앱에 이러한 상호 작용을 손쉽게 통합할 수 있습니다.\n\n기본 제스처 인식기\n\nSwiftUI에는 여러 내장 제스처가 포함되어 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 탭 제스처: 탭 상호작용을 감지합니다.\n- 롱 프레스 제스처: 롱 프레스 상호작용을 감지합니다.\n- 드래그 제스처: 드래깅 상호작용을 감지합니다.\n\n탭 제스처 예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nimport SwiftUI\n\nstruct TapGestureView: View {\n    @State private var message = \"어디서나 탭하세요\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.yellow)\n            .onTapGesture {\n                message = \"탭되었습니다!\"\n            }\n    }\n}\n```\n\n이 예제에서 텍스트를 탭하면 메시지가 \"탭되었습니다!\"로 변경됩니다.\n\nLongPressGesture 예제\n\n```swift\nimport SwiftUI\n\nstruct LongPressGestureView: View {\n    @State private var message = \"길게 눌러 변경하세요\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.green)\n            .onLongPressGesture {\n                message = \"길게 눌렀습니다!\"\n            }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 메시지를 \"길게 눌렀습니다!\"로 변경합니다.\n\n드래그 제스처 예제\n\n```swift\nimport SwiftUI\n\nstruct DragGestureView: View {\n    @State private var offset = CGSize.zero\n\n    var body: some View {\n        Text(\"드래그해 보세요\")\n            .padding()\n            .background(Color.blue)\n            .offset(offset)\n            .gesture(\n                DragGesture()\n                    .onChanged { gesture in\n                        offset = gesture.translation\n                    }\n                    .onEnded { _ in\n                        offset = .zero\n                    }\n            )\n    }\n}\n```\n\n텍스트를 드래그하여 화면 상에서 이동하고 놓을 때 위치가 재설정됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 고급 제스처 기술\n\n동시 제스처 인식\n\n동시에 여러 제스처를 처리하면 더 다이내믹한 상호작용을 만들 수 있어요.\n\n확대/축소(Pinch-to-Zoom) 및 이동(Pan) 예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nimport SwiftUI\n\nstruct PinchAndPanView: View {\n    @State private var scale: CGFloat = 1.0\n    @State private var offset = CGSize.zero\n\n    var body: some View {\n        Image(systemName: \"photo\")\n            .resizable()\n            .scaledToFit()\n            .scaleEffect(scale)\n            .offset(offset)\n            .gesture(\n                SimultaneousGesture(\n                    MagnificationGesture()\n                        .onChanged { value in\n                            scale = value\n                        },\n                    DragGesture()\n                        .onChanged { value in\n                            offset = value.translation\n                        }\n                )\n            )\n    }\n}\n```\n\n이 예제는 사용자가 이미지를 확대 및 축소하고 동시에 이동할 수 있도록 합니다.\n\n사용자 정의 제스처 인식기\n\n사용자 지정 제스처를 만들면 앱에 특정한 독특한 상호작용을 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nimport SwiftUI\n\nstruct CustomGestureView: View {\n    @State private var message = \"오른쪽으로 스와이프하여 나타납니다\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.orange)\n            .gesture(\n                DragGesture(minimumDistance: 50)\n                    .onEnded { value in\n                        if value.translation.width \u003e 50 {\n                            message = \"나타났습니다!\"\n                        }\n                    }\n            )\n    }\n}\n```\n\n이 사용자 정의 제스처에서 오른쪽으로 스와이핑하면 메시지가 나타납니다.\n\n제스처 수정자\n\n여러 제스처 인식기를 연결하면 복잡한 상호 작용을 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n길게 누른 후 스와이프\n\n```js\nimport SwiftUI\n\nstruct LongPressAndSwipeView: View {\n    @State private var message = \"길게 누르고 스와이프하세요\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.purple)\n            .gesture(\n                LongPressGesture(minimumDuration: 1)\n                    .onEnded { _ in\n                        message = \"이제 스와이프하세요\"\n                    }\n                    .simultaneously(\n                        with: DragGesture(minimumDistance: 50)\n                            .onEnded { value in\n                                if value.translation.width \u003e 50 {\n                                    message = \"스와이프했어요!\"\n                                }\n                            }\n                    )\n            )\n    }\n}\n```\n\n이 예제는 메시지를 변경하려면 길게 누른 후에 스와이프해야 합니다.\n\n3. 실용적인 예제 및 사용 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사진 편집 앱: 드래그 제스처로 조정하기\n\n```js\nimport SwiftUI\n\nstruct PhotoEditingView: View {\n    @State private var brightness: Double = 0.0\n\n    var body: some View {\n        VStack {\n            Image(systemName: \"photo\")\n                .resizable()\n                .scaledToFit()\n                .brightness(brightness)\n                .gesture(\n                    DragGesture()\n                        .onChanged { value in\n                            brightness = Double(value.translation.height / 100)\n                        }\n                )\n            Text(\"드래그하여 밝기 조정\")\n        }\n    }\n}\n```\n\n위아래로 드래그하여 이미지의 밝기를 조정할 수 있어요.\n\n그림 그리기 앱: 드래그 제스처로 선 그리기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport SwiftUI\n\nstruct DrawingView: View {\n    @State private var points: [CGPoint] = []\n\n    var body: some View {\n        Canvas { context, size in\n            for point in points {\n                context.fill(Path(ellipseIn: CGRect(origin: point, size: CGSize(width: 5, height: 5))), with: .color(.black))\n            }\n        }\n        .gesture(\n            DragGesture()\n                .onChanged { value in\n                    points.append(value.location)\n                }\n                .onEnded { _ in\n                    // 선택적으로 제스처 종료 처리\n                }\n        )\n    }\n}\n```\n\n이 예제는 사용자가 화면을 드래그하여 선을 그릴 수 있도록 합니다.\n\n게임 앱: 스와이프로 이동\n\n```js\nimport SwiftUI\n\nstruct GamingView: View {\n    @State private var position = CGSize.zero\n\n    var body: some View {\n        Circle()\n            .frame(width: 50, height: 50)\n            .offset(position)\n            .gesture(\n                DragGesture(minimumDistance: 50)\n                    .onEnded { value in\n                        if abs(value.translation.width) \u003e abs(value.translation.height) {\n                            if value.translation.width \u003e 0 {\n                                position.width += 50\n                            } else {\n                                position.width -= 50\n                            }\n                        } else {\n                            if value.translation.height \u003e 0 {\n                                position.height += 50\n                            } else {\n                                position.height -= 50\n                            }\n                        }\n                    }\n            )\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스와이핑은 스와이프 방향으로 원을 이동시킵니다.\n\n4. 프로 팁 및 고려 사항\n\n제스처 충돌 처리\n\n여러 제스처가 동시에 인식될 수 있는 경우, 제스처를 우선순위를 정하거나 배타적 제스처 인식을 사용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nimport SwiftUI\n\nstruct GestureConflictView: View {\n    @State private var message = \"탭 또는 길게 누르기\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.gray)\n            .gesture(\n                TapGesture()\n                    .onEnded {\n                        message = \"탭!\"\n                    }\n                    .exclusively(\n                        before: LongPressGesture()\n                            .onEnded { _ in\n                                message = \"길게 눌렀어요!\"\n                            }\n                    )\n            )\n    }\n}\n```\n\n이 예제에서는 탭 제스처가 길게 누르기 제스처보다 우선합니다.\n\n접근성 고려사항\n\n보이스오버와 같은 보조 기술을 사용하는 데 제스처를 사용할 수 있도록 보장하세요. 예를 들어, 버튼이나 다른 UI 요소를 통해 작업을 수행할 수 있는 대안 방법을 제공하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwiftUI에서 제스처를 마스터하는 것은 상호작용적이고 매력적인 앱을 만들기 위해 꼭 필요합니다. 다양한 제스처 인식기를 이해하고 구현함으로써 사용자 경험을 향상시키고 동적 상호작용을 만들 수 있습니다. 이러한 예제들을 실험해보고 추가 제스처 인식기와 서드파티 라이브러리를 탐구하여 SwiftUI 프로젝트를 더욱 발전시켜 보세요.\n","ogImage":{"url":"/assets/img/2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":12},{"title":"SwiftUI 앱을 위한 디자인 패턴 선택하기","description":"","date":"2024-06-22 23:06","slug":"2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp","content":"\n디자인 패턴은 문제를 해결해야 합니다\n\n![이미지](/assets/img/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp_0.png)\n\n2022년 초, 저는 라커우드에 소재한 소프트웨어 컨설팅 회사인 우드리지 소프트웨어에서 근무하고 있었습니다. 그때 한 고객이 저희에게 수년간 지속될 대규모 기업용 앱을 개발해 달라는 요청을 했습니다. 프로젝트의 범위가 크기 때문에, 저희는 SwiftUI로 완전히 앱을 구축하는 도전을 수용하기로 결정했습니다.\n\n우드리지의 iOS 팀 아키텍트로서, 저는 앱의 아키텍처를 기획하는 업무를 맡았습니다. 이런 방대한 프로젝트에 SwiftUI를 도입하는 것은 잘 정립된 아키텍처적인 모베스트 프랙티스의 부재로 독특한 도전이었습니다. 제가 디자인 패턴을 선택하고 나중에 발명하게 된 여정은 세 단계로 나뉘었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 첫 번째 단계: UIKit 친화적인 디자인 패턴 선택하기\n\nUIKit 개발자로서, 저는 처음에는 UIKit 세계에서 잘 작동하는 아키텍처 패턴을 선택하는 것이 최선일 것이라고 생각했습니다. 그러나 이는 문제가 있었고, 그 이유는 간단한 역사 수업 이후에 가장 잘 설명됩니다.\n\n## iOS 아키텍처 간단 역사\n\n애플이 2008년에 iPhone SDK를 출시했을 때, UIKit 애플리케이션을 구축하기 위한 권장 디자인 패턴은 MVC(Model-View-Controller)였습니다. 이 패턴은 데이터 모델, 뷰 및 이들을 연결하는 컨트롤러(UIKit에서는 뷰와 컨트롤러가 단일 \"뷰 컨트롤러\"로 결합됩니다)를 포함합니다. 기본적인 것을 넘어서 애플리케이션의 복잡도가 증가할수록, 이 패턴은 종종 익숙한 문제인 거대한 뷰 컨트롤러로 이어집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대형 뷰 컨트롤러가 생긴 이유는 여러 가지가 있습니다. 예를 들어 UIKit 내에서 뷰 구성(큰 뷰를 작은 하위 뷰로 분해하는 것)을 사용하기가 매우 어렵기 때문에 대부분의 개발자들이 포기하고 앱의 전체 화면 당 하나의 뷰 컨트롤러를 만들어 각 뷰 컨트롤러를 불합리하게 늘리고 있습니다. 게다가 대부분의 뷰 컨트롤러가 네트워킹과 같은 공통 기능을 추가하여 부풀게되어 있습니다. 또한 모바일 애플리케이션에서 가장 중요한 측면 중 하나인 상태 관리도 쉽지 않았습니다. 애플리케이션 상태의 저장 및 관리는 대부분 개발자에게 맡겨져 있어 결과적으로 모든 것이 기본적으로 뷰 컨트롤러에 저장되었습니다.\n\n총론적으로 문제는 뷰 컨트롤러가 맡은 책임이 너무 많았던 것입니다. 이 문제를 해결하기 위해 개발자들은 일반적으로 뷰 컨트롤러가 보유하던 관심사를 분리하여 해결하려는 의도로 많은 추가 디자인 패턴을 사용했습니다:\n\n- MVP (Model-View-Presenter): 각 뷰 컨트롤러와 데이터 모델 간의 통신을 처리하는 \"프레젠터\" 구성 요소를 소개합니다.\n- MVVM (Model-View-ViewModel): MVP와 유사하게, 각 뷰 컨트롤러에 데이터 모델과 통신을 원활하게 하는 \"뷰 모델\"이라고 불리는 구성 요소가 포함됩니다. 뷰 모델은 프레젠터와 차이점이 있으며 뷰 상태를 저장하고 그 상태를 직접 관련된 뷰에 바인딩합니다.\n- Coordinator: 코디네이터 구성 요소는 네비게이션 관심사를 뷰 컨트롤러로부터 분리합니다.\n- VIPER (View-Interactor-Presenter-Entity-Router): 아마도 그중에서 가장 복잡한 VIPER는 뷰 컨트롤러가 일반적으로 맡은 각 관심사를 개별 구성 요소로 분리하려고 합니다. 뷰(뷰 컨트롤러)는 UI 표시만 다루며, 프레젠터는 뷰용 데이터를 조작하며, 인터랙터는 비즈니스 로직을 처리하며, 엔티티는 기본 데이터 모델을 표현하며, 라우터는 네비게이션을 다룹니다.\n\n## SwiftUI 도입\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2019년에 Apple은 새로운 UI 프레임워크인 SwiftUI를 소개했습니다. SwiftUI는 UIKit과 매우 다릅니다. UIKit은 명령형인 반면, SwiftUI는 선언적입니다. 개발자가 뷰를 직접 처리하는 대신, UI가 어떻게 보여야 하는지를 지정하고 프레임워크가 나머지를 처리합니다. 개발자가 상태 관리를 직접 처리하는 대신 SwiftUI에는 내장된 상태 관리가 있으며 상태 변경 시 뷰 업데이트를 자동으로 처리합니다. UIKit에서 뷰 구성이 어려운 반면, SwiftUI에서는 기본적인 것입니다.\n\n보시다시피, SwiftUI는 단순히 새로운 UI 프레임워크가 아닙니다. UIKit과 너무 다르기 때문에 우리가 하는 게임을 완전히 바꿉니다. UIKit에서 발생했던 대규모 뷰 컨트롤러 문제가 SwiftUI 세계에 존재하지 않으므로 이 문제를 해결하기 위해 특별히 고안된 디자인 패턴을 사용할 필요가 없음을 의미합니다.\n\n따라서 UIKit 친화적인 디자인 패턴을 선택하는 것이 처음에는 합리적으로 보일지라도, 이러한 패턴이 SwiftUI 세계에서는 존재하지 않는 문제를 해결하려는 것임을 빨리 깨닫게 됩니다. 더구나 VIPER와 같은 몇 가지 패턴은 개발자가 좋은 SwiftUI 코드를 작성하는 것을 방해할 수도 있습니다. VIPER와 같은 패턴은 뷰당 중요한 보일러플레이트를 생성하여 각 뷰가 많은 코드와 복잡성을 추가하기 때문에, 개발자들이 뷰를 더 작은 단위로 나누는 것을 열심히 하지 않게 됩니다. Michael Long이 이에 대해 상세히 쓴 바 있습니다.\n\n결국, 디자인 패턴은 문제를 해결하기 위해 존재해야 하며, 가능한 문제를 만들어서는 안 됩니다. UIKit 친화적 아키텍처는 대규모 뷰 컨트롤러 문제를 해결하기 위해 고안된 것인 반면, 이 문제가 SwiftUI에서는 더 이상 존재하지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 두 번째 단계: 가장 추천되는 SwiftUI 디자인 패턴 선택: MVVM\n\n알겠어요, 지금 UIKit 지식을 적용해도 이 문제를 해결할 수 없을 거에요. 그래서 웹을 철저히 조사해본 결과, 대부분의 사람들이 MVVM을 표준 SwiftUI 디자인 패턴으로 추천하고 있어요.\n\n이전에 언급한 바와 같이, MVVM은 각 뷰가 자체 ViewModel 구성 요소를 갖고, 해당 상태와 비즈니스 로직을 포함하며, ViewModel은 상태를 직접 뷰에 바인딩할 것을 규정하고 있어요. 이는 SwiftUI의 상태 중심 및 바인딩 기반 구조에 매우 적합한 후보로 보이며, ObservableObject(그리고 새 @Observed 매크로)를 사용하여 쉽게 구현할 수 있어요.\n\n이 접근 방식에는 장단점이 있어요. 장점은 MVVM이 비즈니스 로직을 뷰에서 분리하여 이식 가능하고 테스트하기 쉽게 만든다는 것입니다. 그러나 SwiftUI에서 MVVM을 사용하는 단점은 많으며, 내 의견으로는 장점을 상회한다고 생각해요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 개발자들은 ViewModels 내에서 withAnimation, @FocusState, @FetchRequest 등과 같은 SwiftUI 기능을 사용할 수 없습니다. 이겈 view models는 그냥 보통의 클래스이기 때문에 그들은 뷰가 아니며, 따라서 뷰의 기능 세트를 활용할 수 없습니다. 이러한 제한을 피하기 위해 우회 방법을 사용하는 것은 번거로울 수 있습니다.\n- SwiftUI 뷰 간의 데이터 전달은 도전적인 과제가 됩니다. 왜냐하면 이제는 바인딩을 쉽게 사용하거나 뷰 모델 내에서 환경에서 정보에 액세스할 수 없기 때문입니다(@Environment 또는 @EnvironmentObject를 통해).\n- ViewModel에서 하나의 속성을 변경하면 해당 속성이 연관된 전체 뷰가 아닌 이 뷰를 무효화시키는 문제가 발생합니다(이는 iOS 17의 새로운 관찰 시스템으로 해결되었지만, iOS 17 이전의 SwiftUI 버전에는 여전히 언급할 가치가 있습니다).\n- MVVM은 비즈니스 로직과 뷰를 강하게 결합하기 때문에 뷰 구성을 억제할 수 있습니다. 단일 뷰를 여러 개의 뷰로 분해하면 여러 개의 새로운 뷰 모델을 생성하고 그들 사이의 복잡한 데이터 흐름을 조율해야 합니다.\n\n이러한 단점을 고려하면 SwiftUI에 적용할 때 MVVM은 적합한 도구가 아닌 것으로 판단됩니다. 이 패턴은 효과적으로 뷰와 비즈니스 로직을 분리하지만 이 과정에서 개발자와 핵심 SwiftUI 기능 사이에 수많은 장애물이 놓여 있습니다. SwiftUI의 세계에 더 적합한 것을 찾아야 한다고 생각합니다. 이것이 저만의 의견이 아닌 것 같습니다.\n\n# 세 번째 단계: 새로운 시도\n\n그렇다면 이제 어떻게 해야 할까요? SwiftUI와 같이 상대적으로 새로운 프레임워크를 사용하는 것은 최상의 방법이 아직 확립되지 않았다는 것이 멋진 점이자 무서운 점입니다. 다른 사람들이 당신을 위해 길을 밟은 사례를 더 찾아보면, 당신이 하나의 길을 밟는이라는 것을 더 많이 깨닫게 됩니다. 이를 염두에 두고, 우리가 나름대로의 방법을 제시해야 하고, 우리만의 아키텍처 패턴을 처음부터 개발해야 할 것이라는 것을 깨달았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 발 물러서서 생각을 해보면, 결국 소프트웨어 아키텍처의 목적은 무엇인가요? 아무튼 그냥 해야 하는 건가요? 아키텍처 신에게 기쁘기 위해서요?\n\n전 반대의 의견을 가지고 있어요. 제가 생각하는 아키텍처 철학은 그것이 목적을 가져야 한다는 것이에요: 문제를 해결해야 해요. SwiftUI의 본질은 방대한 뷰 컨트롤러를 만들어낸 문제들을 해결했고, 이는 더 일반적인 아키텍처 문제를 해결하는 데 노력을 집중할 수 있다는 것을 의미합니다. 그 결과로 나타나는 아키텍처는 UIKit 중심의 아키텍처보다 더 간단하고 우아할 수 있습니다.\n\n그렇다면, 더 일반적인 아키텍처로 어떤 문제들을 해결하려고 하는 것인가요? 주로 우리는 스파게티 코드를 방지하려고 하며, 코드 구조가 이해하기 쉽고 확장하기 쉬운 구조로 끝나길 원합니다. 일반적으로 유지보수 가능한 코드를 지향합니다. 이 새로운 아키텍처 패턴을 위해 선택한 일반적인 원칙들은 다음과 같아요:\n\n- 관심사 분리 (예: 뷰와 비즈니스 로직 분리)\n- DRY 원칙 준수 — 일반적인 작업들은 자체 유틸리티로 정리되어야 합니다\n- 이 패턴은 SwiftUI를 보완하고 프레임워크와 대립하지 않아야 합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## MVSU (Model-View-Service-Utility)\n\n위 요구 사항을 고려하여, 저는 MVSU라는 디자인 패턴을 고안했습니다. 이 패턴은 MVC, 도메인 주도 디자인, 그리고 Clean architecture에 깊은 뿌리를 두고 있지만, SwiftUI에 특히 잘 어울릴 것으로 생각되는 고유한 특성을 갖고 있습니다. 이 패턴은 4개 그룹의 구성 요소로 이루어져 있습니다:\n\n- **유틸리티**는 특정 작업 하나를 수행하거나 몇 가지 밀접하게 관련된 작업을 수행하는 좁게 중점을 둔 재사용 가능한 도구들입니다. 서비스는 하위 수준의 세부 사항을 걱정하지 않고 기능 수행을 가능케 합니다.\n- **서비스**는 비즈니스 로직 계층입니다. 서비스는 애플리케이션의 특정 도메인에 관련된 기능의 상태를 가지지 않은 그룹입니다. 이를 보면 뷰가 사용하는 API로 생각할 수 있습니다.\n- **모델**은 가장 일반적인 부분이며, 앱 데이터를 캡슐화하는 역할을 합니다. 서비스는 모델과 통신하여 기능을 수행합니다.\n- **뷰**는 대체로 자명하지만 알아둬야 할 몇 가지 규칙이 있습니다. 뷰는 주로 자신의 상태를 처리하며, 주로 유틸리티가 아닌 서비스를 사용하여 기능을 수행합니다. 뷰 구성을 적극적으로 활용하여 각 뷰를 쉽게 이해할 수 있는 구성 요소로 분해하여 유지하고, 그로 인해 각 뷰가 작고 중점적으로 유지됩니다.\n\n![이미지](/assets/img/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 구성 요소 유형에 대해 자세히 설명하겠습니다:\n\n## 유틸리티\n\n일부 앱에서 네트워킹, 알림 표시, 오류 처리 등과 같은 일반 작업은 코드베이스 전체에 흩어지거나 반복될 수 있습니다 (또는 뷰모델과 같은 중재 레이어에 위치할 수도 있습니다). MVSU는 특히 이러한 유형의 반복 작업을 “유틸리티” 접미사를 가진 클래스로 이동해야 한다고 규정합니다 (예: NetworkUtility, SessionUtility, LoggingUtility 등).\n\n단일 책임 원칙을 준수하는 한, 이러한 유틸리티는 매우 집중되어 있어야 합니다. 한 가지 유형의 작업이나 몇 가지 밀접한 관련 작업만 수행해야 합니다. 서비스는 그들의 상위 수준 기능을 수행하기 위해 유틸리티를 활용합니다. 이러한 작업을 유틸리티로 이동함으로써 코드베이스를 DRY(반복하지 마세요) 상태로 유지하고 서비스가 독자적 도메인에만 집중하도록 합니다. 여기서의 규칙은 여러 서비스가 동일한 논리를 수행한다면, 아마도 유틸리티로 이동해야 한다는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nclass NetworkUtility {\n    func perform\u003cResultType: Decodable\u003e(request: Request\u003cResultType\u003e) async throws -\u003e ResultType {\n        // ...\n    }\n}\n\nclass LogUtility {\n    func log(type: LogType, description: String) {\n        // ...\n    }\n}\nclass FileUtility {\n    func save(data: Data, toFileUrl fileUrl: URL) throws {\n        // ...\n    }\n    func retrieveData(fromFileUrl fileUrl: URL) throws -\u003e Data {\n        // ...\n    }\n}\n```\n\n## 서비스\n\nMVC, MVP, MVVM, VIPER과 같은 많은 패턴은 뷰별로 비즈니스 로직을 분리합니다 (즉, 각 뷰는 별도의 컨트롤러, 뷰모델 등을 갖습니다). MVSU에서는 비즈니스 로직을 도메인별로 분리합니다. 이는 앱이 사용하는 각 데이터 유형마다 해당하는 서비스를 갖는 것을 의미합니다 (예: 도넛 가게의 경우 도넛 서비스, 주문 서비스, 사용자 서비스 등).\n\n도메인별로 비즈니스 로직을 분리하는 것에는 몇 가지 장점이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 관심사 분리가 더 잘 이루어집니다: 뷰 모델과 같은 중재자는 특정 뷰에 연결되도록 설계되어 있기 때문에 해당 뷰에 대해 많은 정보를 알게 됩니다. 도메인별로 분리하면 서비스가 자신의 도메인에 대해 많은 지식을 갖지만, 뷰에 대해서는 거의 또는 전혀 알지 못합니다. 이것은 다른 뷰 모델과 달리 특정 뷰를 고려하여 설계되지 않았기 때문에 더 이동성이 있습니다.\n- 논리적으로 관련된 코드는 논리적으로 그룹화됩니다. Donut을 생성하고 삭제하는 뷰 각각을 가지는 MVVM 앱의 경우, 관련성이 높은 이 코드도 2개의 다른 뷰모델에 들어가게 되지만, MVSU에서는 해당 코드가 단일 DonutService에 모두 들어가 관련된 코드를 유지하기 쉽게 만듭니다.\n- 기능은 뷰 간에 쉽게 공유할 수 있습니다. 서비스 기능은 한 뷰 이상에서 사용될 수 있기 때문입니다. 이는 MVVM과는 달리 뷰 당 하나의 뷰모델을 가지고 있는 것과 대립적입니다.\n- 도메인별로 분리하면 SwiftUI의 뷰 구성 세계에서 boilerplate가 줄어듭니다. MVVM이나 VIPER와 같은 패턴에서 개발자들은 boilerplate로 인해 하위 뷰를 만들기가 꺼려진다. MVSU에서는 뷰 당 boilerplate가 아닌 도메인 당 boilerplate가 생기기 때문에 하위 뷰로 세분화하는 단점이 없어집니다. 이것은 SwiftUI가 거대한 뷰 컨트롤러 문제를 해결한 주요 이유이므로 아키텍처에서 하위 뷰를 권장해야 합니다.\n\n또한 서비스에 대해 더 알아야 할 점은 상태가 없다는 것입니다 - 상태는 서비스가 아닌 뷰에 저장되어야 합니다. 이에 대한 더 자세한 내용은 Views 섹션에서 설명하겠습니다.\n\n```js\n// 주입 전략은 본인에게 달려 있지만, Factory (https://github.com/hmlongco/Factory)와 같은 라이브러리를 사용할 것을 권장합니다.\n\nimport Factory\n\nclass OrderService {\n    @Injected(\\.networkUtility) private var networkUtility\n    @Injected(\\.logUtility) private var logUtility\n\n    func createOrder(items: [ItemModel]) async throws -\u003e OrderModel {\n        do {\n            let response = try networkUtility.perform(request: .createOrder(items: items))\n            return OrderModel(record: response.order)\n        } catch {\n            logUtility.log(type: .error, description: \"Order error occurred: \\(error.localizedDescription)\")\n            throw RuntimeError(\"주문 생성이 불가능합니다.\")\n        }\n    }\n}\n```\n\n## Views\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n언급한 대로, MVSU는 뷰 구성을 권장하여 큰 뷰를 작은 뷰로 나누고, 각 뷰를 가늠있고 좁게 중점을 두어 과거의 방대한 뷰 컨트롤러 문제를 피합니다.\n\nMVSU에서 서비스는 상태를 유지하지 않습니다. 대신 뷰가 모든 필요한 상태를 유지합니다. 이는 몇 가지 이유로 인해 이루어집니다:\n\n- 관심사의 분리: 어떤 면에서는 응용 프로그램 상태는 도메인 문제가 아니라 뷰 문제입니다. 뷰의 관심사를 뷰 내부에 유지함으로써 더 유지보수 용이한 코드를 얻을 수 있습니다.\n- 향상된 가용성과 단순성: 데이터를 뷰 계층 구조를 위아래로 전달하는 것은 뷰 모델과 같은 중간 계층을 처리할 때 혼란스러운 도전이 될 수 있습니다. 대조적으로 @Binding 및 @Environment를 사용하면 매우 간단하고, 이에 따라 가용성을 촉진합니다.\n- SwiftUI 기능의 쉬운 활용: 뷰 내부에 상태를 유지하는 것은 애니메이션과 같은 기능을 쉽게 활용할 수 있게 해줍니다.\n\n```swift\nstruct OrderView: View {\n    @Injected(\\.orderService) private var orderService\n    @Injected(\\.paymentService) private var paymentService\n\n    let availableItems: [ItemModel]\n    @State private var itemsInCart: [ItemModel]\n    @State private var orderAwaitingPayment: OrderModel?\n    @State private var error: Error?\n\n    var body: some View {\n        VStack {\n            ForEach(availableItems) { availableItem in\n                AddItemToCartButton(availableItem) { item in\n                    itemsInCart.append(item)\n                }\n            }\n\n            Divider()\n\n            // \"AsyncButton\" 뷰를 만드는 것을 강력히 권장합니다: https://www.swiftbysundell.com/articles/building-an-async-swiftui-button/\n            AsyncButton(\"Create Order\") {\n                do {\n                    orderAwaitingPayment = await orderService.createOrder(items: itemsInCart)\n                } catch let orderError {\n                    error = orderError\n                }\n            }\n        }\n        .sheet(item: $orderAwaitingPayment) { order in\n            PaymentInfoView(order: order)\n            PaymentButton() {\n                await paymentService.createPayment(forOrder: order)\n                orderAwaitingPayment = nil\n            }\n        }\n        .errorAlert(error)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 모델\n\n이 부분은 패턴 중 가장 독특하지 않은 부분입니다. 모델은 데이터 유형과 필요한 모든 지속성 레이어(예: Core Data, SwiftData, Realm 등)를 포함합니다. MVSU에서 SwiftUI의 기능 세트를 유지하는 것이 중요하므로 뷰는 SwiftUI의 프로퍼티 래퍼(예: @FetchRequest 또는 @Query)를 통해 모델과 직접 통신할 수 있어야 합니다.\n\n# 결론\n\n내 의견으로는 SwiftUI의 도입은 iOS 개발 영역에서 가장 중요한 변화 중 하나입니다. SwiftUI는 그냥 새로운 UI 프레임워크가 아닙니다. UIKit과는 매우 다르기 때문에 앱을 구축하는 전체 방식에 대해 다시 생각하도록 요구한다고 생각합니다. 아마도 iOS 커뮤니티가 처음부터 아키텍처적 결정을 왜 내리는지에 대해 다시 한번 고민할 때가 되었을지도 모릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n디자인 패턴을 선택하고 결국 만드는 과정을 거치며 왜 처음부터 일반적인 UIKit 디자인 패턴을 사용했는지 깨달았어요. 제 의견으로는 대부분의 앱에서 달성한 복잡성 수준에 UIKit이 잘 맞지 않아서, 이로 인해 우리는 특별히 설계된 아키텍처 패턴으로 문제를 해결해야 했어요. SwiftUI는 같은 문제가 없어서 그런 해결책이 필요하지 않아요.\n\n이 새로운 환경은 두렵고 흥미로운 만큼 새로운 도전이에요. 이는 불가피하게 UIKit 세계에서 연마해온 지식과 기술 일부가 적용되지 않을 수 있다는 의미예요. 또한, 우리가 나만의 방향을 개척하고, 아마도 더 이상 UIKit 개발의 최악 부분들과 다시는 싸울 필요가 없을지도 모른다는 것을 의미해요. 저는 이 길을 계속 나아가며 알려지지 않은 세계를 탐험하는 것에 흥미를 느끼고 있어요.\n","ogImage":{"url":"/assets/img/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp_0.png"},"coverImage":"/assets/img/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp_0.png","tag":["Tech"],"readingTime":15}],"page":"30","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"30"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>