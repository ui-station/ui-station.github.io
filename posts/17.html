<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/17" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/17" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="안녕하세요 오늘은 안드로이드용 5가지 최고의 무료 음악 플레이어 앱에 대해 이야기해 보려고 해요 함께 즐겁게 앱을 살펴보시죠" href="/post/2024-06-19-5BestFreeMusicPlayerAppsforAndroid"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안녕하세요 오늘은 안드로이드용 5가지 최고의 무료 음악 플레이어 앱에 대해 이야기해 보려고 해요 함께 즐겁게 앱을 살펴보시죠" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안녕하세요 오늘은 안드로이드용 5가지 최고의 무료 음악 플레이어 앱에 대해 이야기해 보려고 해요 함께 즐겁게 앱을 살펴보시죠" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안녕하세요 오늘은 안드로이드용 5가지 최고의 무료 음악 플레이어 앱에 대해 이야기해 보려고 해요 함께 즐겁게 앱을 살펴보시죠</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="접근성 강화 포용적 안드로이드 앱으로의 여정" href="/post/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="접근성 강화 포용적 안드로이드 앱으로의 여정" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="접근성 강화 포용적 안드로이드 앱으로의 여정" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">접근성 강화 포용적 안드로이드 앱으로의 여정</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose와 함께 ViewModel 사용하기" href="/post/2024-06-19-HowtoUseViewModelwithJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose와 함께 ViewModel 사용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtoUseViewModelwithJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose와 함께 ViewModel 사용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Compose와 함께 ViewModel 사용하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코틀린 고급 주제 필수" href="/post/2024-06-19-KotlinAdvancedTopicsEssential"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코틀린 고급 주제 필수" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코틀린 고급 주제 필수" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코틀린 고급 주제 필수</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="픽셀 완벽 모든 화면, 모든 폴드를 위한 디자인" href="/post/2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="픽셀 완벽 모든 화면, 모든 폴드를 위한 디자인" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="픽셀 완벽 모든 화면, 모든 폴드를 위한 디자인" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">픽셀 완벽 모든 화면, 모든 폴드를 위한 디자인</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성" href="/post/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기" href="/post/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="접근성 테스트에서 코틀린 Compose - 이름, 역할, 값" href="/post/2024-06-19-AccessibilityTestsinComposeNameRoleValue"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="접근성 테스트에서 코틀린 Compose - 이름, 역할, 값" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="접근성 테스트에서 코틀린 Compose - 이름, 역할, 값" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">접근성 테스트에서 코틀린 Compose - 이름, 역할, 값</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다" href="/post/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법" href="/post/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link posts_-active__YVJEi" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"안녕하세요 오늘은 안드로이드용 5가지 최고의 무료 음악 플레이어 앱에 대해 이야기해 보려고 해요 함께 즐겁게 앱을 살펴보시죠","description":"","date":"2024-06-19 13:54","slug":"2024-06-19-5BestFreeMusicPlayerAppsforAndroid","content":"\n\n이 기사는 완전히 무료로 사용할 수 있고 광고가 없으며 유용한 기능이 제공되는 최고의 5가지 오프라인 음악 플레이어 앱을 소개합니다.\n\n![이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png)\n\n본 기사에서는 Google Play Store에서 사용할 수 있는 안드로이드 기기용 최고의 5가지 무료 오프라인 음악 플레이어 앱을 살펴볼 예정입니다. 각 음악 플레이어를 비교하려면 우리는 최고의 음악 플레이어를 찾는 데 도움이 되는 몇 가지 주요 요소를 고려해야 합니다. 이러한 요소는 다음과 같습니다:\n\n- 좋은 디자인\n- 유용한 기능\n- 기기 호환성\n- 보안\n- 추가 기능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다가오는 섹션에서는 각 음악 플레이어를 이 주요 요소로 평가할 것입니다.\n\n## #1: Groovy — 음악 플레이어\n\nPlay Store 링크: [여기를 클릭하세요](https://play.google.com/store/apps/details?id=com.bitmavrick.groovy)\n\nGroovy는 현재 최고의 음악 플레이어 앱 중 하나입니다. 단순하고 독특한 UI 디자인 시스템을 갖추고 있어 누구나 쉽게 이해하고 작동할 수 있으며 프로 사용자를 위한 많은 사용자 정의 옵션을 제공합니다. 이 앱은 Material-You를 따르는 디자인으로 동적 테마를 지원하고 아이콘 테마를 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_1.png\" /\u003e\n\n유용한 기능들을 요청하면, 이 앱은 음악, 앨범, 아티스트 등을 쉽게 찾을 수 있는 트랙 조직 시스템으로 제공됩니다. 강력한 음악 검색 시스템뿐만 아니라 셔플 모드, 음악 재생 리스트 조직 시스템, 음악 정렬, 기기에서 포함하고 싶지 않은 폴더 차단 등 다양한 유용한 기능들도 제공하고 있습니다.\n\n이 앱은 거의 모든 종류의 안드로이드 기기와 호환됩니다. 예를 들어, 스마트폰, 태블릿, 폴더블 기기, 크롬북, 안드로이드 TV 등을 지원합니다. 플레이어는 세로 및 가로 디스플레이 모드를 모두 지원합니다.\n\n보안에 대해 생각해보신다면, 이 앱은 완전히 오픈 소스이며 보안에 대해 매우 투명하게 공개되어 있습니다. 사용자로부터 개인 정보를 수집하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 추가 기능을 이야기하자면 슬립 타이머, 이퀄라이저, 'Amoled 테마'라고 불리는 한 가지 추가 어두운 테마, 음악 슬라이더 사용자 정의 등 많은 기능이 있습니다.\n\n## #2: 바닐라 음악 플레이어\n\nPlay 스토어 링크: [https://play.google.com/store/search?q=vanilla%20music%20player\u0026c=apps\u0026hl=en\u0026gl=US](https://play.google.com/store/search?q=vanilla%20music%20player\u0026c=apps\u0026hl=en\u0026gl=US)\n\n바닐라 음악 플레이어는 인상적인 아름다운 디자인 미학을 가지고 있습니다. 그러나 지금은 초기 릴리스 상태입니다. 그래서 스크롤할 때 UI가 조금 느려 보일 수 있습니다. 그 외에는 매우 멋진 음악 플레이어 앱입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_2.png)\n\n이 플레이어의 주요 기능은 매우 멋진 UI 애니메이션이 있고 사용자 지정 재생 목록을 만들거나 음악 파일을 삭제하거나 숨길 수 있으며 음악 파일을 다양한 방식으로 정렬할 수 있다는 것입니다. 이 플레이어는 가사 지원도 하고 있습니다. 음악 파일과 함께 가사가 있는 경우 플레이어 내에서 가사를 볼 수 있습니다.\n\n호환성 부서에서는 아직 알 수 없습니다. 초기 릴리스로 인해 모든 종류의 기기를 지원해야 합니다.\n\nGroovy와는 달리이 앱은 오픈 소스가 아닙니다. 그러나 앱은 사용자의 개인 정보를 수집하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n추가 기능에 관해 이 응용 프로그램은 사용자가 원하는 UI 색상을 사용자 정의할 수 있는 색상 팔레트를 지원합니다. 정말 멋지죠!\n\n# #3: Poweramp Music Player (체험판)\n\nPlay Store 링크: https://play.google.com/store/apps/details?id=com.maxmpz.audioplayer\n\n절대적인 제어와 사용자 정의를 원한다면, 이 음악 플레이어가 바로 당신을 위한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_3.png)\n\nPoweramp Music Player은 음악 플레이어에 모든 것이 필요한 사람들을 위한 최고의 선택입니다. 이 앱의 주요 포커스 포인트는 견고한 이퀄라이저입니다. 10 밴드 음악 이퀄라이저 지원과 수동 베이스, 트레블 컨트롤러도 제공합니다.\n\n이 앱의 위치에 대한 주요 이유는 UI/UX입니다. 앱의 디자인은 다소 구식이며 사용하기 복잡합니다. 주요 제공 요소는 음악 사용자 정의입니다.\n\n보안 면에서는 오픈 소스 애플리케이션이 아닙니다. 그러나 사용자의 개인 정보를 수집하지는 않습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# #4: 간단한 음악 플레이어\n\nPlay Store 링크: [여기를 클릭하여 Play Store에서 확인해보세요](https://play.google.com/store/apps/details?id=com.github.anrimian.musicplayer)\n\n이름에서 알 수 있듯이, 이 음악 플레이어는 정말로 간단합니다. 설치하기만 하고 사용하면 됩니다.\n\n![이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 음악 플레이어는 추가 기능이 없지만, 단순함을 원하는 사용자에게는 정말 좋습니다. 전문가로서 이 플레이어에 누락된 몇 가지 중요한 기능을 느껴요. 예를 들어, 오디오 파일을 필터링할 수 있는 시스템이 없고, My Call 및 음성 녹음 파일이 음악 파일과 혼합되어 나타나서 저에게는 큰 문제입니다. 전체적인 디자인은 꽤 간단하며 특별한 점도 없지만 불평할 만한 점도 없어요. 일이 잘 되어요.\n\n보안 관련 부분에서 이 앱은 오픈 소스이며 보안에 대해 투명해요. 또한이 앱은 사용자의 개인 정보를 수집하지 않아요.\n\n# #5: Musicmax — 음악 플레이어\n\nPlay Store 링크: https://play.google.com/store/apps/details?id=com.maximillianleonov.musicmax\u0026pcampaignid=web_share\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMusicmax은 저희가 가장 추천하지 않는 음악 플레이어 앱입니다. 이 플레이어는 전반적으로 꽤 좋은 음악 재생 경험을 제공합니다.\n\n![음악 플레이어 이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_5.png)\n\n이 음악 플레이어는 꽤 양호한 UI 경험을 제공하지만, 가로 모드로 변경할 때 상황이 그리 좋지 않습니다. UI 부서에서 더 많은 작업이 필요합니다. 이 플레이어는 무료 앱으로 가지고 있기 좋은 즐겨찾기 섹션이 있습니다. 또한 다크 모드와 기본적인 기능을 지원합니다.\n\n이 앱은 스마트폰만을 지원합니다. 보안을 위해 오픈 소스로 투명하게 제공됩니다. 이 앱은 사용자의 개인 정보를 수집하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 있습니다. 이것이 제 의견으로는 최고의 5가지 음악 플레이어 앱입니다. 남은 하루도 좋은 하루 되세요!","ogImage":{"url":"/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png","tag":["Tech"],"readingTime":5},{"title":"접근성 강화 포용적 안드로이드 앱으로의 여정","description":"","date":"2024-06-19 13:51","slug":"2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps","content":"\n\n![이미지](/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png)\n\n혁신을 추구하는 것은 종종 포용성 요구를 무시하는 경향이 있습니다. 우리의 삶이 디지털 인터페이스와 더불어 점점 더 얽히게 되면, 능력에 관계없이 모든 사람이 디지털 세계에 완전히 접근할 수 있도록 하는 것이 더 중요해지고 있습니다. 특히, 수십억 명의 소비자를 연결하는 전 세계 플랫폼인 안드로이드 생태계에 대해서는 특히 그렇습니다. 이 글에서는 안드로이드의 접근성에 대해 살펴보고, 보다 포용적이고 공정한 기술 환경을 구축하는 데 어떻게 도움이 될 수 있는지 알아보겠습니다.\n\n유럽 접근성법(EAA)은 디지털 접근성의 긴급성을 증대시키는 중요한 요소입니다. 장애를 가진 사람들에게 장애를 제거하도록 제정된 EAA는 유럽 연합 내에서 운영되는 많은 기업들이 2025년까지 자사의 디지털 서비스와 제품을 접근 가능하게 만들도록 요구합니다. 이 규정은 접근성이 단순한 도덕적 필요성뿐만 아니라 법적 요구사항이라는 것을 강조하는 패러다임 변화를 대표합니다. 마감일이 다가오면 기업들은 다양한 고객 요구를 충족시키는 중요성을 인식하면서 자사의 디지털 서비스를 재평가해야 합니다.\n\n이 글은 개발자들이 자신들의 안드로이드 애플리케이션의 접근성을 향상시킬 수 있는 다양한 방법에 대해 자세히 안내합니다. 사용자 친화적인 기능을 포함하고 포용적 설계 원칙을 준수하는 등 어플리케이션을 더 접근 가능하게 만드는 실용적 기술들을 살펴봅니다. 또한, 우리는 테스트의 중요한 요소를 살펴보며 제공된 솔루션이 참으로 포괄적인지 보장하는 방법과 도구에 대해 알아봅니다. 안드로이드 접근성의 복잡한 세계를 탐험하는 과정에서, 개발자들에게 국경을 초월하고 보편적 설계의 정신을 수용하는 디지털 경험을 구축하도록 영감을 줄 수 있기를 희망합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 포용\n\n디지털 접근성 분야에서의 포용은 기술적 요구사항 이상의 의미를 갖습니다. 이는 기술이 배제의 이유가 아닌 평등을 위한 수단으로 작용하기 위한 심도 있는 약속입니다. 접근성 있는 디자인은 사람들의 삶에 광범위한 영향을 미치며, 긍정적이든 부정적이든 모든 능력을 갖춘 사람들에게 영향을 줍니다.\n\n긍정적인 면에서 접근성 있는 기술은 장애로 인해 제약을 받는 사람들을 자유롭게 해 줄 수 있는 변형력을 갖습니다. 시각 장애인이 액세스 가능한 안드로이드 앱을 사용할 때 화면 판독기를 사용한다면 어떨까요. 올바른 접근성 기능이 제대로 설계되어 있다면, 이 사용자는 프로그램을 독립적으로 탐색하고 정보에 접근하며 이전에는 이용할 수 없었던 활동에 참여할 수 있습니다. 이러한 증가된 자유는 그들의 일상을 개선하는 것뿐만 아니라 자아감과 포용감을 육성하는 데에도 도움이 됩니다.\n\n반면에 디지털 접근성 부족은 편견과 문화적 장애를 악화시킬 수 있습니다. 화면 판독기와 호환되지 않거나 그림에 대한 대체 텍스트를 제공하지 않는 웹사이트나 앱은 시각 장애를 가진 사람들을 효과적으로 배제시킬 수 있습니다. 이러한 배제는 단순히 불편을 초래하는 것 이상으로 교육, 취업 및 사회 참여에 대한 장애물을 만들어냅니다. 예를 들어 접근성 기능이 충분하지 않은 취업 지원 포털은 장애를 가진 유능한 개인이 채용 공고에 지원하는 것을 방해할 수 있어 전문적 발전 가능성을 제한할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 액세스할 수없는 기술은 디지털 격차를 악화시킬 수 있습니다. 디지털 풍경을 쉽게 탐색할 수 있는 사람과 앞을 굳이 막는 장애물을 마주치는 사람 간의 격차를 만들어 낼 수 있습니다. 학습 장애를 가진 학생이 교육 자료에 엑세스하기 어렵다면 애플리케이션이 접근성 기능을 제공하지 않는 경우 어떻게 될까요? 이는 그들의 학업 진행을 방해할 뿐만 아니라 향후 취업 및 사회적 상호작용으로 이어지는 배제의 피라미드를 유발할 수 있습니다.\n\n간략히 말하자면, 디지털 접근성의 포용의 중요성은 모든 능력을 가진 개인들의 삶의 질을 형성하는 능력에 있습니다. 규제 요건을 충족시키는 것뿐만 아니라 기술이 장벽을 만들지 않고 사람들을 연결하는 다리 역할을 하는 세상을 육성하는 데 의미가 있습니다. 안드로이드 개발에서 포용적 디자인 원칙을 수용함으로써 사용자 경험을 향상시킬 뿐 아니라 보다 공정하고 조화로운 디지털 사회에 기여할 수 있습니다.\n\n# 유럽 접근성 법안 (EAA)\n\n유럽 접근성 법안(EAA)은 유럽 연합 내에서 보다 포용적이고 접근성 있는 디지털 풍경을 창출하기 위한 전환이라고 말할 수 있습니다. 장애를 가진 사람들이 직면한 장애물을 철폐하기 위해 제정된 EAA는 디지털 서비스 및 제품 스펙트럼에 걸쳐 접근성 표준을 강제하는 포괄적인 프레임워크를 제시합니다. 그 중요성은 법률적 틀 내뿐만 아니라 수십만 명의 디지털 배제를 오래 겪어온 개인들의 삶에 미치는 영향에서도 드러납니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n핵심적으로 EAA는 기술이 방해요소가 아닌 오히려 촉진요소로 작용하는 사회 조성을 위한 의지를 반영합니다. 그 중요 조항 중 하나는 유럽 연합 내에서 운영되는 많은 기업들이 2025년까지 자사의 디지털 서비스와 제품들이 접근성을 보장해야 한다는 것을 명시하고 있습니다. 이는 웹사이트부터 모바일 애플리케이션, ATM, 그리고 e북까지 다양한 디지털 인터페이스를 포함하고 있습니다. 이 기한을 부과함으로써, EAA는 기업들이 디지털 제품을 제공하는 데 있어 접근성을 우선시하는 것을 강요하여 기술 산업에서 패러다임 변화를 촉발시킵니다.\n\nEAA의 중요성은 장애를 가진 개인들의 삶에 미칠 전환적인 영향을 고려할 때 특히 명확해집니다. 기술이 일상적인 활동에서 점점 더 중요한 역할을 하게 되는 가운데, 디지털 콘텐츠와 서비스에 접근할 수 있는 능력은 사회 전체적인 참여와 동일시되어집니다. EAA는 접근성을 강제함으로써, 장애를 가진 사람들을 위한 교육, 일자리, 그리고 사회 참여의 문을 열어주어 모두가 기여하고 번영할 수 있는 포용적 환경을 조성합니다.\n\n더불어, EAA는 유럽 연합을 넘어 국제적으로 디지털 접근성에 대한 시각을 영향을 미치는 선례를 제공합니다. 기업들이 EAA의 요구 사항에 대응하며 직면하는 도전에 대처할 때, 그들은 법적 의무뿐만 아니라 모든 사용자의 요구를 충족시키기 위한 기술을 만들어내는 도덕적 필요성을 받아들이고 있습니다. 이러한 노력을 통해 EAA는 모든 사람이 접근 가능한 디지털 시대의 혜택을 얻을 수 있도록 하는 데 있어 길잡이 역할을 하며, 디지털 포용이 규정적인 체크박스뿐만 아니라 기술 혁신의 필수 요소로 자리 잡는 미래의 길을 밝혀주고 있습니다.\n\n요약하자면, 유럽 접근성법은 디지털 접근성이 법으로 강제되는 것뿐만 아니라 사회적 필요성으로 받아들여지는 새로운 시대를 예고합니다. 비즈니스들이 포용성을 우선시하도록 강요함으로써, EAA는 장벽을 허물고 디지털 시대의 혜택이 모든 이에게 접근 가능하도록 보장하고, 보다 공정하고 조화로운 디지털 미래를 위한 기초를 마련하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 접근성 높은 안드로이드 앱 만들기\n\n접근성 높은 안드로이드 앱을 만드는 것은 다양한 디자인 고려 사항과 기능을 아우르는 복합적인 접근 방식이 필요합니다. 이러한 조치들은 다양한 능력을 가진 사용자들이 응용 프로그램을 원활하게 탐색하고 상호 작용할 수 있도록 보장하는 데 중요합니다. 안드로이드 앱 개발에서 접근성을 향상시키는 여러 가지 핵심 전략을 소개합니다:\n\n## 텍스트 가시성과 대비\n\n명확하고 가독성 있는 글꼴을 사용하여 가독성을 보장하세요. 글꼴 크기와 대비 비율을 조정하여 시각 장애가 있는 사용자나 작은 텍스트를 읽는 데 어려움이 있는 사용자들의 가시성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코틀린:\n\n```kotlin\n// 가독성을 높이기 위해 텍스트 크기와 색상 설정\ntextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 18f)\ntextView.setTextColor(ContextCompat.getColor(context, R.color.textColor))\n```\n\nXML:\n\n```xml\n\u003cTextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"18sp\"\n    android:textColor=\"@color/textColor\"/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n젯팩 컴포즈:\n\n```kotlin\nText(\n    text = \"Hello, World!\",\n    fontSize = 18.sp,\n    color = Color.Black // 적절한 색상 사용\n)\n```\n\n# 크고 간단한 컨트롤\n\n모터 장애가 있는 사용자나 터치 인터페이스를 사용하는 사용자들을 위해 클릭 실수의 위험을 줄이기 위해 더 큰 터치 대상과 버튼을 구현하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKotlin:\n\n```kotlin\n// 버튼 크기 키우기\nbutton.layoutParams.width = 150\nbutton.layoutParams.height = 150\n```\n\nXML:\n\n```xml\n\u003cButton\n    android:id=\"@+id/button\"\n    android:layout_width=\"150dp\"\n    android:layout_height=\"150dp\"/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n젯팩 컴포즈:\n\n```js\nButton(\n    onClick = { /* 버튼 클릭 로직 */ },\n    modifier = Modifier.size(150.dp)\n) {\n    Text(\"눌러주세요!\")\n}\n```\n\n# 콘텐츠 설명 및 대체 텍스트\n\n컨텐츠 설명 또는 대체 텍스트를 사용하여 이미지와 기타 텍스트가 아닌 요소에 대한 설명을 제공하세요. 이렇게 하면 스크린 리더를 사용하는 사용자들이 콘텐츠와 문맥을 이해할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKotlin (이미지용):\n\n```js\nimageView.contentDescription = \"이미지에 대한 설명 텍스트\"\n```\n\nXML (ImageView용):\n\n```js\n\u003cImageView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:contentDescription=\"이미지에 대한 설명 텍스트\"\n    app:srcCompat=\"@drawable/your_image\"/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n젯팩 컴포즈 (이미지용):\n\n```kotlin\nImage(\n    painter = painterResource(id = R.drawable.your_image),\n    contentDescription = \"이미지에 대한 설명적 텍스트\",\n    modifier = Modifier.size(100.dp)\n)\n```\n\n# 색상 및 테마\n\n정보를 전달하기 위해 오로지 색상에 의존하지 말고, 색맹이나 시각 장애가 있는 사용자도 고려하여 중요 정보가 다른 시각적 신호를 통해서도 확인할 수 있도록 해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKotlin:\n\n```js\n// 색상만으로 정보 전달에 의존하지 말고,\n// 아이콘이나 레이블과 같은 다른 시각적 단서를 사용하세요\ntextView.setBackgroundResource(R.drawable.rounded_corner_background)\n```\n\nXML:\n\n```js\n\u003cTextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:background=\"@drawable/rounded_corner_background\"\n    android:text=\"중요 정보\"/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n젯팩 콤포즈:\n\n## 적응형 레이아웃과 반응형 디자인\n\n다양한 화면 크기와 방향에 적응하는 레이아웃을 디자인하세요. 반응형 디자인은 앱이 다양한 기기에서 사용자 친화적으로 유지되도록 하여 다양한 접근성 요구를 가진 사용자들에게 혜택을 줍니다.\n\n코틀린:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n//적응형 레이아웃을 위해 ConstraintLayout을 사용하세요\nval constraintLayout = findViewById\u003cConstraintLayout\u003e(R.id.constraintLayout)\nval layoutParams = ConstraintLayout.LayoutParams(\n    ConstraintLayout.LayoutParams.MATCH_PARENT,\n    ConstraintLayout.LayoutParams.MATCH_PARENT\n)\nconstraintLayout.layoutParams = layoutParams\n```\n\nXML:\n\n```js\n\u003candroidx.constraintlayout.widget.ConstraintLayout\n    android:id=\"@+id/constraintLayout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\u003e\n    \u003c!-- 여기에 UI 구성 요소를 추가하세요 --\u003e\n\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\n```\n\nJetpack Compose:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# TalkBack 및 화면 판독기\n\n시각 장애를 가진 사용자들을 위해 음성 피드백을 제공하는 TalkBack과 같은 화면 판독기를 통합하세요. 화면 판독기 사용자가 사용하는 제스처에 대한 앱의 호환성과 응답성을 테스트하세요.\n\n```js\n// 특정 뷰에 TalkBack 활성화\nViewCompat.setAccessibilityDelegate(view, object : AccessibilityDelegateCompat() {\n    override fun onInitializeAccessibilityNodeInfo(host: View?, info: AccessibilityNodeInfoCompat?) {\n        super.onInitializeAccessibilityNodeInfo(host, info)\n        info?.roleDescription = \"TalkBack용 사용자 정의 설명\"\n    }\n})\n```\n\nXML:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n\u003cView\n    android:id=\"@+id/view\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:contentDescription=\"TalkBack를 위한 사용자 정의 설명\"/\u003e \n```\n\n젯팩 Compose:\n\n# 키보드 탐색\n\n터치 인터페이스 사용에 어려움을 겪을 수 있는 사용자들을 위해 키보드를 사용한 부드러운 탐색을 활성화하세요. 앱 내에서 논리적이고 직관적인 키보드 탐색 경로를 구현해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코틀린:\n\n```kotlin\n// 뷰에 키보드 탐색 기능 활성화\nview.isFocusable = true\nview.isFocusableInTouchMode = true\nview.requestFocus()\n```\n\nXML:\n\n```xml\n\u003cView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:focusable=\"true\"\n    android:focusableInTouchMode=\"true\"/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n젯팩 콤포즈:\n\n```js\n// 콤포즈에서는 포커스가 일반적으로 자동으로 관리되지만 영향을 줄 수 있습니다\nTextField(\n    value = text,\n    onValueChange = { newText -\u003e text = newText },\n    label = { Text(\"라벨\") },\n    modifier = Modifier.focusRequester(focusRequester)\n)\n```\n\n# 음성 명령 및 음성 입력\n\n음성 명령 기능을 통합하여 사용자가 음성을 사용하여 앱과 상호 작용할 수 있도록합니다. 이는 접근성이 떨어지는 개인이나 무료 경험을 선호하는 사람들에게 큰 혜택이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMarkdown:\n\n```xml\n\u003cEditText\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:inputType=\"textMultiLine\"\n    android:imeOptions=\"actionDone\"/\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자막 및 대본\n\n오디오 및 비디오 콘텐츠에 자막을 포함시켜 보조기기를 사용하는 사용자들이 이용하기 쉽도록 하고, 대본을 제공하여 멀티미디어 콘텐츠를 보다 넓은 대중이 이용할 수 있도록 합니다.\n\nKotlin:\n\n```js\n// 비디오에 대한 자막 설정\nvideoView.contentDescription = \"비디오에 대한 자막\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXML:\n\n```js\n\u003cVideoView\n    android:id=\"@+id/videoView\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:contentDescription=\"동영상을 위한 캡션\"/\u003e\n```\n\nJetpack Compose:\n\n# 고대비 테마\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저시안을 가진 사용자 또는 특정 시각적 선호도를 갖는 사용자를 위해 시각성을 향상시키는 고대비 테마나 모드를 제공해보세요.\n\nKotlin:\n\n```js\n// 고대비 테마로 동적으로 전환하기\nAppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)\n```\n\nMarkdown:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- styles.xml에 고대비 테마를 정의하세요 --\u003e\n\u003cstyle name=\"HighContrastTheme\" parent=\"Theme.AppCompat.DayNight\"\u003e\n    \u003citem name=\"android:windowBackground\"\u003e@color/highContrastBackground\u003c/item\u003e\n    \u003c!-- 필요한 다른 속성을 추가하세요 --\u003e\n\u003c/style\u003e\n```\n\nJetpack Compose:\n\n```js\n// Compose 테마는 코드로 정의되며 프로그래밍 방식으로 전환할 수 있습니다\nval highContrastTheme = myTheme.copy(\n    colors = highContrastColors\n)\n```\n\n# 접근성이 좋은 폼\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친절한 톤으로 번역해보겠습니다:\n\n친밀한 레이블, 명확한 지시사항 및 적절한 입력 유효성 검사를 갖춘 양식을 디자인하세요. 이를 통해 인지 장애가 있는 사용자나 복잡한 양식 구조에 어려움을 겪는 사용자들에게 도움이 됩니다.\n\nKotlin:\n\n```kotlin\n// 양식 필드에 적절한 레이블링과 입력 유효성 검사를 보장\neditText.hint = \"당신의 이름\"\neditText.inputType = InputType.TYPE_CLASS_TEXT\n```\n\nXML:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n// Compose에서는 TextField 또는 기타 관련 컴포넌트를 사용하여 Form을 구축할 수 있습니다\nTextField(\n    value = text,\n    onValueChange = { newText -\u003e text = newText },\n    label = { Text(\"Your Name\") },\n    singleLine = true\n)\n```\n\n# 동적 텍스트 및 폰트 크기 조정하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱 설정에서 텍스트 크기를 사용자 정의할 수 있도록 허용하여 사용자가 인터페이스를 개인적인 필요에 맞게 조정할 수 있게 합니다.\n\n이러한 접근성 기능과 디자인 원칙을 통합함으로써 안드로이드 앱 개발자는 모든 사용자에게 접근 가능한 더 포괄적인 디지털 환경에 기여할 수 있습니다. 실제 사용자와 피드백을 수렴하여 정기적인 테스트를 통해 앱의 접근성과 사용자 경험을 더욱 세련되게 할 수 있습니다.\n\n코틀린:\n\n```kotlin\n// Allow users to customize text size in the app settings\nval sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)\nval textSize = sharedPreferences.getFloat(\"text_size\", 16f)\ntextView.textSize = textSize\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nXML:\n\n```xml\n\u003cTextView\n    android:id=\"@+id/textView\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"?attr/textSizePreference\"/\u003e\n```\n\nJetpack Compose:\n\n이 예시들은 각 접근성 요소가 Kotlin, XML 및 Jetpack Compose에서 어떻게 처리될 수 있는지에 대한 간략한 통찰력을 제공합니다. 앱의 아키텍처 및 디자인에 따라 이러한 개념을 적절하게 조정 및 통합해야 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 안드로이드 앱의 접근성 테스트\n\n모든 능력을 가진 사용자에게 안드로이드 앱이 접근 가능하도록 보장하려면 수동 및 자동화된 접근성 테스트 방법을 종합적으로 활용해야 합니다. 아래에서는 TalkBack 및 Switch Access를 활용한 수동 테스트부터 접근성 스캐너, APK 사전 시작 보고서, UIAutomatorViewer, Lint, Espresso, 사용자 테스트와 같은 분석 도구 및 프레임워크를 활용하는 다양한 테스트 방법을 개요로 설명합니다.\n\n# TalkBack\n\nTalkBack은 안드로이드 기기용 화면 리더기로, 시각 장애를 가진 사용자들을 위해 음성으로 피드백을 제공합니다. TalkBack로 수동 테스트하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기기 설정에서 TalkBack을 활성화하세요.\n- 터치 제스처를 사용하여 앱을 탐색하고 TalkBack이 UI 요소를 읽는 방법을 확인해보세요.\n\n# 스위치 액세스\n\n스위치 액세스를 사용하면 기동 장애가 있는 사용자가 스위치를 사용하여 Android 기기와 상호 작용할 수 있습니다. 스위치 액세스를 수동으로 테스트하려면:\n\n- 기기 설정에서 스위치 액세스를 활성화하세요.\n- 스위치 장치를 연결하고 앱을 탐색하면서 모든 상호 작용 요소에 접근하고 사용할 수 있는지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 음성 액세스\n\n음성 액세스를 통해 사용자는 음성 명령을 사용하여 기기를 제어할 수 있습니다. 음성 액세스를 수동으로 테스트하려면:\n\n- 기기 설정에서 음성 액세스를 활성화합니다.\n- 음성 명령을 사용하여 앱을 탐색하고 모든 기능이 접근 가능한지 확인합니다.\n\n# 접근성 스캐너\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n접근성 스캐너는 잠재적인 접근성 문제를 검사하는 자동화 도구입니다. Accessibility Scanner를 사용하려면:\n\n- 테스트 기기에 Accessibility Scanner 앱을 설치하세요.\n- 앱을 열고 스캐너를 실행하여 접근성을 향상시키는 권고 사항을 받아보세요.\n\n# APK 사전 발매 보고서\n\nGoogle Play 콘솔의 APK 사전 발매 보고서는 앱의 접근성 성능에 대한 통찰을 제공합니다. 보고서를 생성하려면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Play Console에 앱을 업로드하세요.\n- \"릴리스 관리\"로 이동하여 \"사전 론칭 보고서\"를 확인하고 접근성 섹션을 검토하세요.\n\n## UIAutomatorViewer\n\nUIAutomatorViewer는 앱의 UI 구성 요소를 검사하는 도구입니다. UIAutomatorViewer를 사용하려면:\n\n- Android SDK 도구에서 뷰어를 실행하세요.\n- 기기를 연결하고 앱을 열어 UI 요소를 적절한 레이블과 계층 구조로 검사하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 린트\n\n안드로이드 린트에는 코드에서 잠재적인 문제를 식별하는 접근성 체크가 포함되어 있습니다. 린트를 실행하려면:\n\n- 터미널에서 다음 명령을 사용하십시오: `./gradlew lint`\n- 생성된 보고서에서 접근성 경고를 검토하십시오.\n\n# 에스프레소\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에스프레소는 안드로이드용 강력한 테스팅 프레임워크로, UI 테스팅 및 접근성 측면에서 사용할 수 있습니다. 에스프레소를 사용하여 가시성을 테스트하는 간단한 예제를 확인해보세요:\n\n```js\nAccessibilityChecks.enable().setRunChecksFromRootView(true)\n```\n\n```js\nAccessibilityChecks.enable().apply {\n    setSuppressingResultMatcher(allOf(\n        matchesCheckNames(`is`(\"TextContrastViewCheck\")),\n        matchesViews(withId(R.id.countTV))\n    ))\n}\n```\n\n# 사용자 테스팅\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**마지막으로, 다양한 능력을 가진 사람들을 대상으로 한 사용자 테스트는 앱의 접근성에 대한 귀중한 통찰을 제공합니다. 다음을 고려해 보세요:**\n\n- **장애를 가진 사용자를 모집하여 앱을 테스트합니다.**\n- **그들의 경험에 대한 피드백을 수집하고 반복적으로 개선합니다.**\n\n**이러한 테스트 방법을 결합하여 안드로이드 앱이 접근 가능하다는 것을 체계적으로 보장할 수 있습니다. 모든 사용자에게 긍정적이고 포괄적인 경험을 제공해 보세요.**\n\n# **결론**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n드디어 안드로이드 앱 개발에서 접근성을 채택하는 것은 준수를 넘어서 모든 능력을 가진 사용자를 환영하는 포용적인 디지털 세계를 만들기 위한 약속입니다. 접근성 있는 앱을 개발하는 길은 다양한데, 가시성과 간결함을 우선시하는 디자인 원칙을 구현하는 것부터 첨단 테스트 방법을 활용하는 등 모든 것을 포함합니다.\n\n유럽 접근성법(EAA)은 2025년까지 회사들이 디지털 제품을 접근성 있게 하는 것을 보장하는 법적, 윤리적 필수성을 강조하는 선례를 제공했습니다. 이 지침은 디지털 포용성의 중요성을 인식하는 글로벌 이동을 강조합니다. 개발자로서, 우리는 이 변화에서 중추적인 역할을 하며, 장애요소를 제거하고 사용자가 디지털 세계를 원활하게 탐색할 수 있는 솔루션을 개발하는 역할을 맡았습니다.\n\nTalkBack, Switch Access, Voice Access와 같은 수동 테스트부터 Accessibility Scanner, APK Pre-Launch Report, UIAutomatorViewer, Lint와 같은 첨단 분석 도구를 활용하는 것까지, 개발 과정의 모든 단계가 접근성의 최종 목표에 기여합니다. Espresso와 같은 강력한 테스트 프레임워크를 통해 개발자들은 접근성 구현의 효과를 프로그래밍적으로 확인할 수 있습니다.\n\n하지만 가장 통찰력 있는 피드백은 종종 실제 사용자로부터 옵니다. 특히 다양한 능력을 가진 사용자들을 참여시키는 사용자 테스트는 접근성 평가에 질적인 차원을 제공합니다. 그들의 경험과 시각은 개발자들을 자신들의 앱을 개선하도록 이끄는 데 도움이 되며, 앱을 보다 직관적이고 탐색 가능하며 보편적으로 환영받는 것으로 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n접근성에 대한 약속은 고정적인 것이 아닙니다. 계속된 학습과 적응이 필요하며, 만능 디자인 원칙을 준수하는 디지턈 환경을 만들기 위한 변함없는 헌신이 필요합니다. 앞으로 나아가면서, 우리는 규제적인 기준을 준수하는 것뿐만 아니라, 제약을 넘어진 디지턈 경험을 개발하고 진정한 포용의 정신을 대변하는 것을 목표로 할 것입니다. 이렇게 함으로써, 법적 요구사항을 충족할 뿐만 아니라, 기술이 다양한 삶의 방식을 가진 사람들을 통합하는 다리 역할을 하며 미래에 기여할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png"},"coverImage":"/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png","tag":["Tech"],"readingTime":15},{"title":"Jetpack Compose와 함께 ViewModel 사용하기","description":"","date":"2024-06-19 13:50","slug":"2024-06-19-HowtoUseViewModelwithJetpackCompose","content":"\n\n이 기사는 ViewModel을 Jetpack Compose와 통합하여 데이터를 효율적으로 관리하고 표시하는 방법을 안내합니다.\n\n## ViewModel 이해하기\n\nViewModel은 Android 아키텍처 컴포넌트의 일부로서 UI 관련 데이터를 라이프사이클에 맞게 관리하는 데 도움이 됩니다. 환경 변경을 살아남고 활동 또는 프래그먼트와 같은 전통적인 Android 컴포넌트보다 긴 수명 주기 동안 UI 관련 데이터를 보관하고 관리하는 데 이상적입니다.\n\n## ViewModel 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 프로젝트에 Jetpack Compose가 설정되어 있는지 확인하세요. 이곳에는 Kotlin을 사용하여 Jetpack Compose를 이용한 ViewModel의 기본 설정이 있습니다:\n\nFoodCategoriesUiState: 이 sealed 인터페이스는 UI가 취할 수 있는 다양한 상태를 정의합니다: 로딩, 성공 (사진 목록 포함), 오류. 이를 통해 UI 상태를 구조적으로 관리하고 표현할 수 있습니다.\n\nFoodCategoriesViewModel: 이 클래스는 ViewModel을 확장하며 Food Categories 사진을 표시하기 위한 UI 관련 데이터를 관리합니다.\n\nfoodCategoriesUiState: 이 속성은 mutableStateOf를 사용하여 초기화된 로딩 상태인 UI의 현재 상태를 나타냅니다. Jetpack Compose가 이를 관찰하고 UI를 업데이트할 수 있는 반응적 상태입니다. 외부 클래스가 직접 수정할 수 없도록 private로 설정되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n초기화 블록: FoodCategoriesViewModel을 초기화하면 getFoodCategories()가 호출되어 즉시 Food Categories 사진을 가져오는 프로세스가 시작됩니다.\n\ngetFoodCategories(): 이 함수는 viewModelScope에서 코루틴을 시작합니다. Food Categories 사진을 비동기적으로 가져오기 전에 foodCategoriesUiState를 로딩으로 업데이트합니다.\n코루틴 내부:\n- getFoodCategories() 메서드를 사용하여 foodCategoriesRepository에서 사진을 가져오려고 시도합니다.\n- 성공하면(try 블록), 가져온 사진과 함께 foodCategoriesUiState를 성공으로 업데이트합니다.\n- IOException 또는 HttpException이 발생하면(catch 블록), foodCategoriesUiState를 에러로 업데이트합니다.\n\n팩토리 동반 객체: 이 객체는 FoodCategoriesViewModel 인스턴스를 인스턴스화하는 데 사용할 수 있는 ViewModelProvider.Factory를 제공합니다. ViewModel 인스턴스에 리포지토리와 같은 의존성이 필요한 경우에는 팩토리 패턴을 사용하는 것이 일반적입니다.\n\nviewModelFactory: 이는 androidx.lifecycle.viewmodel 라이브러리에서 제공되는 함수입니다. ViewModelProvider.Factory를 만들어 ViewModel 인스턴스를 람다(초기화자)를 사용하여 초기화할 수 있게 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n초기화 Lambda: 람다 내부에서는 FoodCategoriesApplication에서 FoodCategoriesRepository 종속성을 검색합니다. 이는 APPLICATION_KEY를 사용하여 수행되는데, 이는 맵 형태 구조(바로 이 구조)에서 애플리케이션 인스턴스를 검색하는 데 사용되는 키입니다.\n\n의존성 주입: 이 팩토리 패턴을 사용함으로써 FoodCategoriesViewModel은 종속성(foofCategoriesRepository)이 주입된 상태로 인스턴스화될 수 있습니다. 이는 관심사의 분리를 촉진하고 종속성의 목 표현을 주입함으로써 단위 테스트를 용이하게 합니다.\n\n📖 FoodCategoriesViewModel 클래스는 Jetpack Compose와 통합하여 Food Categories 사진 검색이 repository(foofCategoriesRepository)로부터 어떻게 상태를 관리하는지에 관여합니다. 이는 UI (foofCategoriesUiState)가 데이터를로드하는 중인지, 성공적으로 가져 왔는지 또는 가져오는 동안 오류가 발생했는지를 반영하도록 보장합니다. 이 설정은 Kotlin 코루틴(viewModelScope.launch)을 사용하여 비동기 작업과 Jetpack Compose의 반응형 상태 관리(mutableStateOf)를 통해 상태 변경에 따라 UI 업데이트를 제공합니다.\n\n## HomeScreen\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n👉 홈 화면 Composable 기능:\n\n- foodCategoriesUiState: FoodCategoriesViewModel에서 관리되는 UI의 현재 상태를 나타냅니다.\n- retryAction: FoodCategoriesViewModel에서 전달되는 람다 함수로, 오류가 발생한 경우 사진을 다시 가져오는 처리를 담당합니다.\n- modifier: 레이아웃과 모양 속성을 지정할 수 있게 해주는 Compose Modifier입니다.\n\n👉 When 표현식:\n\nfoodCategoriesUiState에 따라 다음이 실행됩니다:\n- Loading: 로딩 인디케이터를 표시하는 LoadingScreen을 호출합니다.\n- Success: 사진 목록(foodCategoriesUiState.photos)을 전달하여 그리드 형태의 사진을 보여주는 PhotosGridScreen을 호출합니다.\n- Error: 에러 메시지와 다시 시도하는 버튼이 함께 표시되는 ErrorScreen을 호출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ViewModel을 Jetpack Compose와 통합하기\n\n👉 FoodCategoriesApp 콤포저블 함수:\n@Composable: 이 함수가 Jetpack Compose를 사용하여 콤포저블 UI 요소를 정의한다는 것을 나타냄.\nScaffold: 상단 바, 컨텐츠 영역 및 선택적인 플로팅 액션 버튼을 포함하는 앱을 위한 기본 레이아웃 구조를 제공.\nSurface: 내용을 그리기 위한 컨테이너로, 지금의 경우 사용 가능한 공간 전체를 차지함(fillMaxSize() 수정자).\nviewModel: androidx.lifecycle.viewmodel.compose에서 ViewModel 인스턴스(FoodCategoriesViewModel)를 제공하는 공장(FoodCategoriesViewModel.Factory)을 사용하여 가져오는 콤포저블 함수.\nHomeScreen: FoodCategoriesViewModel에서 foodCategoriesUiState 및 retryAction을 전달 받는 HomeScreen.kt에 정의된 다른 콤포저블 함수.\n\n👉 ViewModel 통합:\nviewModel(factory = FoodCategoriesViewModel.Factory): 이 줄은 앞에서 정의된 Factory를 사용하여 FoodCategoriesViewModel의 인스턴스를 가져옴. 이는 음식 카테고리 사진을 가져와 표시하는 관련 상태를 관리함.\nFoodCategoriesViewModel 인스턴스(foodCategoriesViewModel)는 UI 상태(foodCategoriesUiState)를 관리하며 리포지토리에서 음식 카테고리 사진을 가져오는 메서드(getFoodCategories)를 제공함.\n\n요약하면, FoodCategoriesApp은 Jetpack Compose의 Scaffold와 Surface를 사용하여 앱의 기본 구조를 설정하고, UI 상태 및 데이터 가져오기를 관리하기 위해 FoodCategoriesViewModel을 통합함. 반면에 HomeScreen은 FoodCategoriesViewModel에서 관리되는 다양한 상태(로딩, 성공, 오류)에 기반한 UI 구성 요소를 정의함. 함께 사용하여 Jetpack Compose와 ViewModel 아키텍처를 사용하여 안드로이드 앱에서 동적이고 반응적인 UI를 구축하는 방법을 보여줌.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![How to Use ViewModel with Jetpack Compose](/assets/img/2024-06-19-HowtoUseViewModelwithJetpackCompose_0.png)\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoUseViewModelwithJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoUseViewModelwithJetpackCompose_0.png","tag":["Tech"],"readingTime":5},{"title":"코틀린 고급 주제 필수","description":"","date":"2024-06-19 13:48","slug":"2024-06-19-KotlinAdvancedTopicsEssential","content":"\n\nKotlin Multiplatform (KMP)의 공식 릴리스와 안드로이드와의 통합으로 Kotlin은 엄청난 인기를 얻고 있습니다. Kotlin의 매력은 다양성에 있습니다. 개발자들이 단일 언어를 습득하고 백엔드, 프론트엔드(Android, iOS 및 웹)를 포함한 여러 플랫폼에서 활용할 수 있습니다. Kotlin이 계속 성장함에 따라 개발자들은 필수적이고 고급 주제를 탐색하여 기술을 향상시킬 수 있어야 합니다. 이를 통해 예외적인 코딩 표준을 유지하고 산업에서 앞서 나갈 수 있습니다.\n\n![img](/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png)\n\n### 위임\n\nKotlin에서의 위임은 객체가 일부 책임을 다른 객체에 위임할 수 있도록 하는 디자인 패턴입니다. Kotlin은 by 키워드를 사용하여 위임에 대한 내장 지원을 제공합니다. Kotlin에서는 클래스 위임과 속성 위임 두 가지 주요 위임 유형이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 속성 위임\n\nlazy 위임은 속성이 처음 액세스 될 때만 초기화됩니다. 이는 비용이 많이 드는 객체 초기화나 프로그램 실행 중에만 필요한 속성에 유용합니다. 이를 통해 리소스 사용을 최적화하고 응용 프로그램 성능을 향상시킬 수 있습니다. 기본적으로 lazy 초기화는 스레드 안전합니다.\n\n```js\nval myName: String by lazy {\n    println(\"계산됨\")\n    \"내 이름\"\n}\n```\n\n## 클래스 위임\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스 위임은 한 클래스가 다른 클래스로 메서드 구현을 위임할 수 있게 합니다. 이는 합성을 위해 유용하며 상속 없이 다른 클래스의 동작을 통합할 수 있도록 합니다. 인터페이스 구현 또는 기능을 다른 클래스로 위임함으로써 코드 중복을 피할 수 있습니다.\n\n```kotlin\n    interface Weather {\n        fun currentWeather()\n    }\n\n    class Summer : Weather {\n        override fun currentWeather() {\n            println(\"Current weather is ${javaClass.simpleName}\")\n        }\n    }\n\n    class HolidayPlans(weather: Weather) : Weather by weather {\n    }\n```\n\n# 확장 함수\n\nKotlin의 확장 함수를 사용하면 코드의 재사용성을 높이기 위해 우리만의 유틸리티 함수를 작성할 수 있습니다. 내부적으로 확장 함수는 컴파일 시점에 클래스에 대해 정적으로 해결되며 해당 클래스의 공개 멤버에 액세스할 수 있도록 합니다(소스 코드를 수정하지 않고).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nval EMAIL_ADDRESS_PATTERN = Pattern.compile(\n        \"[a-zA-Z0-9\\\\+\\\\.\\\\_\\\\%\\\\-\\\\+]{1,256}\\\\@[a-zA-Z0-9][a-zA-Z0-9\\\\-]{0,64}(\\\\.[a-zA-Z0-9][a-zA-Z0-9\\\\-]{0,25})+\"\n    )\n\n    private fun String.isEmail() =\n        EMAIL_ADDRESS_PATTERN.matcher(this).matches()\n\n    fun verifyCredential(emailId: String) {\n        println(emailId.isEmail())\n    }\n```\n\n# 고차 함수\n\n고차 함수를 사용하면 함수를 인수로 사용하거나 함수를 반환하거나 둘 다를 할 수 있습니다. 이를 통해 추상 코드를 생성하고 특정 상황에서 함수 구현을 선언하고 다른 상황에서 실행할 수 있습니다. 이를 통해 강력한 추상화와 더 깨끗하고 모듈화된 코드를 작성할 수 있습니다.\n\n## 기본 고차 함수\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nfun calculate(a: Int, b: Int, operator: (Int, Int) -\u003e Int) {\n  operator(a, b)\n}\n\nfun main() {\n    val sum = calculate(5, 3) { a, b -\u003e a + b }\n    println(\"합계: $sum\") // 합계: 8\n    val product = calculate(5, 3) { a, b -\u003e a * b }\n    println(\"곱셈: $product\") // 곱셈: 15\n}\n```\n\n## 함수 반환\n\n```kotlin\nfun operation(op: String): (Int, Int) -\u003e Int {\n    return when (op) {\n        \"add\" -\u003e { a, b -\u003e a + b }\n        \"multiply\" -\u003e { a, b -\u003e a * b }\n        else -\u003e { _, _ -\u003e 0 }\n    }\n}\n\nfun main() {\n    val addOperation = operation(\"add\")\n    println(\"덧셈: ${addOperation(2, 3)}\") // 덧셈: 5\n    val multiplyOperation = operation(\"multiply\")\n    println(\"곱셈: ${multiplyOperation(2, 3)}\") // 곱셈: 6\n}\n```\n\n- inline: 컴파일러에게 함수의 바이트코드를 호출 지점에 직접 넣도록 요청합니다. 함수 호출 및 람다 생성의 오버헤드를 줄여 성능을 향상시킬 수 있습니다.\n- noinline: 인라인 함수 내 람다 매개변수를 인라인화하지 못하게 합니다. 람다를 저장하거나 전달해야 할 때 유용합니다.\n- crossinline: 인라인 함수 내 람다의 비지역 반환을 방지합니다. 람다가 둘러싸는 함수로부터 반환하지 못하도록하여 람다의 예측 가능한 동작을 보장합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Sealed Class / Interface\n\nSealed 클래스는 자바 세계의 enum의 고급 버전으로 볼 수 있습니다. 코틀린에서 sealed class와 sealed interface를 모두 선언할 수 있습니다. Sealed 클래스와 sealed interface는 Kotlin에서 제한된 계층 구조를 모델링하는 유용한 도구입니다. 두 가지 중에서 선택하는 것은 상태와 동작을 공유해야 하는지(Sealed class 사용) 또는 동작에 대한 계약을 정의해야 하는지에 따라 다릅니다(Sealed interface 사용).\n\n```js\nsealed interface Polygon {\n    data class Circle(val radius: Double) : Polygon\n    data class Square(val side: Double) : Polygon\n    data object NotAShape : Polygon\n}\n```\n\n```js\nsealed class Shape(area: Double) {\n    data class Circle(val radius: Double) : Shape(3.14* radius* radius)\n    data class Square(val side: Double) : Shape(side * side)\n    data object NotAShape : Shape(0.0)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 제네릭\n\n제네릭은 Kotlin에서 선언된 클래스, 인터페이스 및 함수에 타입 매개변수를 사용할 수 있는 강력한 도구입니다. 이를 통해 다양한 데이터 유형을 허용하고 타입 안전성을 유지하면서 유연하고 재사용 가능한 코드를 작성할 수 있습니다.\n\n## 제네릭 클래스\n\n```js\nclass Machine\u003cT\u003e(val type: T)\n\nfun main() {\n    val machine1 = Machine(12)\n    val machine2 = Machine(\"optimus\")\n    println(machine1.type) // 12\n    println(machine2.type) // optimus\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 일반 함수들\n\n일반 함수들은 타입 매개변수를 가진 함수들입니다. 이를 통해 우리는 타입 안전성을 희생하지 않고 다른 타입들에 대해 동작하는 함수를 작성할 수 있습니다.\n\n```kotlin\nfun \u003cT\u003e singletonList(item: T): List\u003cT\u003e {\n    return listOf(item)\n}\n\nfun main() {\n    val intList = singletonList(5)\n    println(intList) // [5]\n}\n```\n\n## Variance\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n분산이란 일반적인 유형 간의 서브타이핑 관계를 정의합니다.\n\n- 불변성은 요소를 소비하고 생성할 수 있습니다. `T` 타입의 `Invariant` 클래스입니다.\n\n```kotlin\nclass Invariant\u003cT\u003e(var value: T)\nval intInvariant = Invariant\u003cInt\u003e(12)\n// var anyInvariant : Invariant\u003cAny\u003e = intInvariant // 컴파일 오류\n```\n\n- 공산성은 요소를 생성만 할 수 있습니다. `T`의 슈퍼 클래스는 `T`를 대체할 수 있지만 서브타입은 아닙니다. `out T`입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nclass Contravariant\u003cout T\u003e(private val value: T) {\n    fun get(): T {\n        return value\n    }\n}\n\nfun main() {\n    val intContravariant = Contravariant\u003cInt\u003e(12)\n    val anyContravariant: Contravariant\u003cAny\u003e = intContravariant\n    // val doubleContravariant : Contravariant\u003cDouble\u003e = intContravariant // Compilation error\n}\n```\n\n- Contravariance can only consume elements. The subclasses of T can replace it but not the superclass. `in T`\n\n```kotlin\nclass Contravariant\u003cin T\u003e {\n    fun put(item: T) { println(item) }\n}\n\nfun main() {\n    val numberContravariant = Contravariant\u003cNumber\u003e()\n    val doubleContravariant: Contravariant\u003cDouble\u003e = numberContravariant\n    // val anyContravariant: Contravariant\u003cAny\u003e = numberContravariant  // Compilation error\n}\n```\n\n# 코루틴\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코루틴은 가볍고(쓰레드보다 훨씬 가볍습니다). 블로킹하지 않고, 어느 스레드도 차단하지 않지만 코드 실행을 일시 중단하고 다시 시작합니다. 디스패처(dispatchers)와 스코프(scopes)에 따라 코루틴이 널리 분류됩니다.\n\n## 코루틴 스코프\n\n- GlobalScope 어떤 특정 라이프사이클에 바인딩되지 않은 최상위 코루틴을 시작하는 글로벌 스코프\n- lifecycleScope 액티비티나 프래그먼트의 수명주기에 바인딩된 스코프\n- viewModelScope ViewModel 수명주기에 바인딩된 스코프\n\n```js\nGlobalScope.launch {\n    // 오래 실행되는 작업\n}\nlifecycleScope.launch {\n    // 코루틴 코드\n}\nviewModelScope.launch {\n    // 코루틴 코드    \n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Coroutine Dispatchers\n\n- `dispatchers.Main`은 주 (UI) 스레드에서 실행됩니다.\n- `dispatchers.IO`는 네트워크 또는 데이터베이스 작업에 사용됩니다.\n- `dispatchers.Default`는 CPU 집약적인 작업에 사용됩니다 (비트맵 작업).\n- `dispatchers.Unconfined`는 호출자 스레드에서 실행되지만 처음 일시 중지 지점까지만 실행됩니다.\n\n## Builders\n\n- `launch`는 새로운 코루틴을 시작하고 결과를 반환하지 않습니다. Fire-and-forget 방식입니다.\n- `async`는 새로운 코루틴을 시작하고 향후 결과를 나타내는 Deferred를 반환합니다. 결과를 얻으려면 `await`를 사용하세요.\n- `runBlocking`은 해당 블록이 완료될 때까지 현재 스레드를 차단합니다. 주로 메인 함수 및 테스트에서 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nCoroutineScope(Dispatchers.Main).launch {\n    // 코루틴 코드\n}\n\nval deferred = CoroutineScope(Dispatchers.Default).async {\n    // 비동기 작업\n    \"결과\"\n}\nrunBlocking {\n    val result = deferred.await()\n    println(result)\n}\n\nrunBlocking {\n    // 코루틴이 완료될 때까지 블록됨\n}\n```","ogImage":{"url":"/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png"},"coverImage":"/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png","tag":["Tech"],"readingTime":7},{"title":"픽셀 완벽 모든 화면, 모든 폴드를 위한 디자인","description":"","date":"2024-06-19 13:46","slug":"2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold","content":"\n\n모바일 기기 다양성이 이전에 없던 수준으로 증가했습니다. 앱 개발자들은 스마트폰, 태블릿, 접이식 기기와 같은 다양한 기기들이 각각 다른 화면 크기, 해상도 및 방향을 가지고 있기 때문에 많은 도전을 겪습니다. 이 넓은 범위에서 부드러운 사용자 경험을 만들기 위해서는 창의력 뿐만 아니라 다양한 화면 크기에 관련된 미묘한 부분을 깊이 이해해야 합니다.\n\n본 문서는 다양한 화면을 위해 응용프로그램을 생성하고 테스트하는 과학과 예술을 탐구하며, 다양한 형태 요소를 가진 기기에 대한 디자인 세부 사항에 대한 통찰력 있는 정보를 제공합니다. 태블릿에서 접이식 폰으로의 환경은 항상 변화하기 때문에, 개발자들은 모든 기기에서 앱이 멋지게 보이고 완벽하게 작동하도록 보장하기 위해 항상 최신 정보를 유지해야 합니다.\n\n다양한 화면 크기에 대한 디자인 시 고려해야 할 중요한 요소와 Jetpack Compose 및 XML 레이아웃을 사용하여 레이아웃을 관리하는 실용적인 조언에 대해 논의할 것입니다. 또한 사용자가 기능성 또는 스타일에 어긋나지 않고 세로 및 가로 모드 사이를 쉽게 전환할 수 있도록 하는 다양한 화면 방향을 지원하는 것이 얼마나 중요한지에 대해 이야기하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테스트는 개발 과정 중요한 부분이에요. 다양한 기기에서 앱의 기능을 확인하는 실용적인 방법을 안내해 드릴게요. 에뮬레이터를 사용하여 빠른 반복부터 디바이스 팜을 활용해 철저한 테스트까지, 테스트 환경에서의 복잡성을 성공적으로 해결하기 위해 필요한 기술과 정보를 제공할 거예요.\n\n함께 다중 화면 개발과 테스트의 복잡성을 탐험해 볼까요? 오늘날 접근 가능한 다양한 화면에 적응할 수 있는 애플리케이션을 디자인하는 수수께끼를 풀며, 미래 기술 발전에 부응할 수 있도록 하겠어요.\n\n# 폼 팩터 스펙트럼\n\n폼 팩터는 이제 전통적인 것 이상을 포함하고 있어요. 접이식 기기의 등장과 스마트폰, 태블릿의 전통적인 제약으로 개발자들은 이제 다양한 화면 크기와 모양을 대상으로 하고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 형태 요소의 진화\n\n스마트폰 및 태블릿: 전통적인 스마트폰 및 태블릿은 오랫동안 모바일 애플리케이션의 표준 형태 요소였습니다. 컴팩트한 화면부터 확장된 태블릿까지 다양한 디바이스가 있었기 때문에, 개발자들은 다양한 화면 크기와 해상도를 수용할 수 있도록 레이아웃을 조정하는 데 익숙해져 왔습니다.\n\n접이식 디바이스: 접이식 디바이스의 등장으로 새로운 시대가 열렸습니다. 이로 인해 개발자들은 정적 화면의 제약을 벗어나 생각하도록 도전받게 되었습니다. 접이식 디바이스는 유연성과 혁신을 동시에 제공하여 사용자가 컴팩트한 형태와 확장된 디스플레이 사이를 매끄럽게 전환할 수 있게 합니다. 접이식 디바이스 시장이 계속 성장함에 따라 적응형 앱 디자인의 필요성이 더욱 뚜렷해지고 있습니다.\n\n## 서로 다른 형태 요소에 맞추는 이유?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n향상된 사용자 경험: 다양한 형태 요소에 맞게 애플리케이션을 디자인하면 사용자가 선택한 기기에 관계없이 최적의 경험을 제공할 수 있습니다. 특정 화면에 맞게 레이아웃을 맞추면 더 몰입감 있고 사용자 친화적인 상호작용이 가능해져 사용자 만족도가 높아집니다.\n\n시장 접근성: 다양한 형태 요소 수용을 통해 앱의 잠재적 사용자 기반을 확대할 수 있습니다. 시장에 있는 다양한 기기들을 수용함으로써 애플리케이션의 접근성을 더 넓은 관객에게 제공하여 새로운 시장과 인구통계를 개방할 수 있습니다.\n\n미래 준비: 기술이 발전함에 따라 형태 요소도 변합니다. 유연성을 고려하여 디자인하면 새로운 모양과 크기의 기기가 등장해도 앱이 여전히 관련성 있고 기능적이게 유지될 수 있습니다.\n\n## 레이아웃 조정 대 기존 지원 중단\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 형태 요인을 수용해야 할 때, 개발자는 적응성과 실용성 사이의 균형을 유지해야 합니다. 다음은 고려해야 할 주요 사항입니다:\n\n레이아웃 조정:\n\n- 반응형 디자인 원칙을 활용하여 다양한 화면 크기에 동적으로 적응하는 레이아웃을 만듭니다.\n- XML 레이아웃에서 ConstraintLayout 또는 Jetpack Compose에있는 반응형 수정자와 같은 기술을 활용하여 다양한 기기에서 일관된 사용자 경험을 보장합니다.\n\n지원 중단:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 귀하의 앱 대상 사용자를 기준으로 특정 형태 요소를 지원하는 실용성을 평가합니다.\n- 특정 기기를 지원하지 않을지 결정할 때 필요한 개발 노력과 잠재적 사용자 영향을 고려합니다.\n\n형태 요소의 다양성을 수용하는 것은 단순히 디자인 고려사항이 아니라 전략적 필수불가결입니다. 다양한 형태 요소 개발의 복잡성을 탐구하는 동안 목표는 명확합니다: 정적 화면의 제약을 초월하며 다양한 장치 스펙트럼의 사용자에게 원활하고 즐거운 경험을 제공하는 애플리케이션을 만드는 것입니다.\n\n# 적응형 레이아웃 만들기\n\n## 다중 레이아웃 지원을 위한 XML 데이터 바인딩\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반응형 XML 레이아웃:\n\n- XML에서 `layout` 및 `data` 요소를 사용하여 레이아웃 구성 요소에 데이터를 바인딩하세요.\n- 리소스 지정자(예: 태블릿용 res/layout-large)를 활용하여 서로 다른 화면 크기에 대한 특정 레이아웃을 생성하세요.\n\n```js\nres/layout/activity_main.xml            // 기본 레이아웃\nres/layout-sw600dp/activity_main.xml    // 7인치 태블릿용 레이아웃\nres/layout-land/activity_main.xml       // 가로 방향용 레이아웃\n```\n\n가로 방향에 최적화된 레이아웃:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기기가 회전될 때 사용성이 향상되는 랜드스케이프 전용 레이아웃을 만들어보세요.\n\n```xml\n\u003c!-- res/layout-land/activity_main.xml --\u003e\n\u003cLinearLayout\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\u003e\n    \u003c!-- 랜드스케이프 전용 UI 구성 요소 --\u003e\n\u003c/LinearLayout\u003e\n```\n\n접이식 기기:\n\n- 맞춤형 레이아웃을 제공하기 위해 접이식 기기용 리소스 한정자를 활용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003c!-- res/layout-large/activity_main.xml --\u003e\n\u003cLinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\u003e\n    \u003c!-- Foldable device UI components --\u003e\n\u003c/LinearLayout\u003e\r\n```\n\n반응형 ConstraintLayout:\n\n- ConstraintLayout을 활용하여 다양한 화면 크기와 방향에 자동으로 조절되는 반응형 디자인을 만듭니다.\n\n## 동적 UI를 위한 Jetpack Compose\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n화면 크기 처리:\n\n젯팩 컴포즈에서 Modifier.fillMaxSize()는 레이아웃이 사용 가능한 공간을 차지하도록 보장하며, 다양한 화면 크기에 적응합니다. 또한 padding 수정자를 사용하여 일관된 여백을 제공하면 다양한 크기에 걸쳐 깔끔하고 조직적인 모양을 유지할 수 있습니다.\n\n방향 관리:\n\nLocalConfiguration.current.orientation을 사용하여 현재 방향을 확인하면 Composable 함수 내에서 조건부로 다른 레이아웃을 정의할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Foldable 기기용 SlidingPaneLayout\n\n- SlidingPaneLayout을 활용하여 Foldable 기기를 위한 슬라이딩 패널 UI를 만들어보세요.\n\nDataBinding과 Jetpack Compose에서 이러한 기술들을 활용함으로써, 다양한 화면 크기, 방향 및 심지어 Foldable 기기의 독특한 형태 요소까지 우아하게 수용하는 적응형 레이아웃을 만들 수 있습니다. 크기를 조정하거나 동적 레이아웃을 사용하더라도, 사용자들에게 다양한 기기 스펙트럼에서 일관되고 즐거운 경험을 제공하는 것이 목표입니다.\n\n# 함정 피하기 \u0026 최선의 실행 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 흔한 함정 및 그것을 피하는 방법\n\n고정된 크기:\n\n- 함정: 크기를 하드코딩하는 것은 다른 화면 크기에서 레이아웃이 왜곡될 수 있습니다.\n- 해결책: 상대적인 크기인 wrap_content 및 match_parent를 사용하거나 일관된 크기를 위해 밀도 독립적인 픽셀(dp)을 활용하십시오.\n- XML 데이터 바인딩 예시:\n\n- Jetpack Compose 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n밀도 독립성을 무시하고: \n\n- 함정: 고정된 픽셀 값에만 의존하는 것은 다른 픽셀 밀도를 가진 장치에서 일관성 없는 UI를 초래할 수 있습니다.\n- 해결책: 밀도 독립 단위(dp XML에서, Compose에서는 dp 또는 sp)를 사용하여 UI 요소가 다른 화면에서 적절하게 확장되도록 보장합니다.\n- XML 데이터 바인딩:\n\n```js\n\u003c!-- res/layout/activity_main.xml --\u003e\n\u003cTextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"16sp\"\n    android:padding=\"8dp\"\n    android:text=\"밀도 독립적 텍스트\" /\u003e\n```\n\n- Jetpack Compose:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n// src/main/kotlin/com/example/myapp/ui/MainScreen.kt\nText(\n    text = \"밀도 독립적 텍스트\",\n    fontSize = 16.sp,\n    modifier = Modifier.padding(8.dp)\n)\r\n```\n\n방향 변경 무시:\n\n- 함정: 가로 또는 세로 방향을 무시하면 사용자 경험이 최적화되지 않을 수 있습니다.\n- 해결책: 장치가 회전될 때 개선된 사용성을 위해 랜드스케이프 전용 레이아웃을 설계합니다.\n- XML 데이터 바인딩 예시:\n\n```js\r\n\u003c!-- res/layout-land/activity_main.xml --\u003e\n\u003cLinearLayout\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\u003e\n    \u003c!-- 랜드스케이프 전용 UI 구성 요소 --\u003e\n\u003c/LinearLayout\u003e\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Jetpack Compose 예시:\n\n접힐 수 있는 장치 고려를 무시할 때:\n\n- 함정: 접힐 수 있는 장치의 독특한 형태 요소를 간과하면 최적의 사용자 경험을 보장받기 어려울 수 있습니다.\n- 해결책: 접힐 수 있는 장치에 대한 리소스 크기 조정자를 통합하고 레이아웃을 맞춤화하여 그들의 기능을 최대한 활용하십시오.\n- XML 데이터 바인딩 예시:\n\n```js\n\u003c!-- res/layout-large/activity_main.xml --\u003e\n\u003cLinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\u003e\n    \u003c!-- 접힐 수 있는 장치 UI 구성 요소 --\u003e\n\u003c/LinearLayout\u003e\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- **Jetpack Compose 예시:**\n\n## 원활한 경험을 위한 추가 팁\n\n동적 간격:\n\n- 화면 크기에 따라 차원 리소스를 사용하여 간격을 동적으로 조절합니다.\n- XML 데이터 바인딩 예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nText(\n    text = \"동적 간격\",\n    modifier = Modifier\n        .padding(dimensionResource(id = R.dimen.margin_standard))\n)\n```\n\n반응형 글꼴 크기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Responsive 폰트 크기를 조절하는 데 디멘션 리소스를 사용하세요.\n- XML 데이터바인딩 예시:\n\n```js\n\u003cTextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"Responsive Font\"\n    android:textSize=\"@dimen/text_size_medium\" /\u003e\n```\n\n- Jetpack Compose 예시:\n\n```js\nText(\n    text = \"Responsive Font\",\n    fontSize = dimensionResource(id = R.dimen.text_size_medium).value\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n화면 크기, 방향 및 접이식 장치의 다양한 환경을 다루기 위해서는 세부 사항에 주의해야 합니다. 흔한 실수를 피하고 이러한 추가적인 기교를 구현하여 다양한 장치에서 원활하고 즐거운 사용자 경험을 제공하는 적응형 레이아웃을 만들 수 있습니다.\n\n# 스펙트럼 테스팅: 에스프레소, 파이어베이스 디바이스 팜, 그리고 에뮬레이터\n\n다양한 화면 크기와 방향에서 앱이 원활하게 작동하도록 보장하기 위해서는 견고한 테스트 전략이 필요합니다. 이 섹션에서는 에스프레소를 사용하여 애플리케이션을 효율적으로 테스트하는 방법, 포괄적인 디바이스 커버리지를 위해 파이어베이스 디바이스 팜을 활용하는 방법, 그리고 테스트 필요에 맞게 맞춤형 에뮬레이터를 설정하는 방법을 살펴보겠습니다. 게다가 이러한 테스트를 로컬 및 지속적 통합(Continuous Integration, CI) 파이프라인 내에서 실행하는 스크립트도 제공할 것입니다.\n\n## 로컬 테스트를 위한 에스프레소\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에스프레소는 안드로이드용 강력한 테스팅 프레임워크로서 간결하고 신뢰할 수 있는 UI 테스트를 작성할 수 있습니다. 로컬에서 다양한 화면 크기와 방향을 테스트하려면 에스프레소의 ViewMatchers 및 ViewActions를 사용하여 UI 요소를 확인하는 ViewAssertions와 결합할 수 있습니다.\n\n에스프레소 코드 예시:\n\n## Firebase Device Farm를 활용한 철저한 테스트\n\nFirebase Device Farm는 다양한 실제 기기에서 앱을 테스트할 수 있는 클라우드 기반 솔루션을 제공합니다. 다양한 화면 크기, 방향 및 기기를 커버하는 테스트 매트릭스를 생성하여 다양한 구성에 대해 철저한 테스트를 보장할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFirebase Test Lab 예제 코드:\n\n## 사용자 정의 테스트 환경을 위한 에뮬레이터 설정\n\nAndroid 에뮬레이터는 테스트를 위한 사용자 정의 가상 장치를 생성하는 유연한 방법을 제공합니다. 에뮬레이터를 구성하여 실제 시나리오를 모방하기 위해 특정 화면 크기, 해상도 및 방향을 일치시킬 수 있습니다.\n\n## 사용자 정의 에뮬레이터 설정:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAVD Manager를 사용하여 새로운 에뮬레이터를 생성하세요. 화면 크기, 해상도 및 방향과 같은 장치 세부 정보를 지정해주세요.\n\n```js\nemulator -avd Pixel_6_API_32 -orientation portrait\n```\n\n에뮬레이터 시작: 원하는 구성으로 에뮬레이터를 시작하세요.\n\n## 로컬에서 테스트를 실행하는 스크립트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n#!/bin/bash\n# Espresso 테스트가 'androidTest' 디렉토리에 있다고 가정합니다\n./gradlew connectedAndroidTest\n```\n\n## CI 파이프라인용 스크립트 (Firebase Device Farm 통합):\n\n이러한 테스트 전략을 개발 워크플로에 통합함으로써, 앱이 다양한 화면 크기, 해상도, 방향에서 매끄럽게 작동함을 보장할 수 있습니다. Espresso로 로컬에서 테스트하거나 Firebase Device Farm에서 다양한 설정을 탐색하거나 사용자 정의 에뮬레이터를 만들 때, 포괄적인 테스트 접근 방식은 높은 품질의 사용자 경험을 제공하는 데 중요합니다.\n\n# 결론\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금보다 더 중요한 것은 다양한 화면 크기, 방향 및 접힐 수 있는 장치에서 매끄럽게 작동하는 경험을 디자인하는 것입니다. 다양한 형태 요소 테스트와 개발을 통한 탐구는 디지털 세계의 도전에 대처하려는 개발자들에게 더 나은 방법을 제시하고 있습니다.\n\nJetpack Compose와 XML 데이터 바인딩의 적응형 디자인 개념을 활용하면, 개발자들은 점점 다양해지는 기기 범위에 맞춰 레이아웃을 유동적으로 조정할 수 있습니다. 이러한 방법으로 제공되는 적응성은 스마트폰, 태블릿 및 접힐 수 있는 장치에서 동일하고 즐거운 경험을 제공하여 모든 고객이 일관된 사용자 경험을 누릴 수 있도록 보장합니다.\n\n앱 개발의 중요한 요소인 테스팅은 Espresso, Firebase Device Farm 및 에뮬레이터 설정을 통해 다양한 시각에서 다뤄졌습니다. 로컬 테스트부터 클라우드 기반 솔루션까지, 개발자들은 다양한 도구를 활용하여 앱이 다양한 환경에서 완벽하게 작동하도록 보장할 수 있습니다. 특정 구성을 위해 Espresso 테스트를 실행하거나 Firebase를 활용하여 포괄적인 장치 커버리지를 제공하거나 로컬 및 CI/CD 파이프라인 테스트를 위해 에뮬레이터 설정을 스크립팅하는 것과 같이, 선택 가능한 옵션이 풍부합니다.\n\n이 조사를 마치면 다양성 수용이 성공에 중요하다는 것이 명확해집니다. 다양한 형태 요소의 미묘한 점을 이해하고 전형적인 실수를 피하며 여분의 전술을 추가함으로써, 개발자들은 제약을 뛰어넘는 응용프로그램을 만들 수 있습니다. 창의성에 경계가 없는 세계에서, 점진적인 개발자들은 포괄적이고 유연한 디지털 경험을 만들기 위한 헌신으로 구별됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사가 개발자들에게 나침반 역할을 하여 다중 화면 애플리케이션의 개발과 테스트의 복잡성을 탐험하고, 현재의 요구 사항을 충족시키는 데만 그치지 않고 미래 기술의 돌파구에도 견고한 프로그램을 만드는 데 영감을 주길 바랍니다. 우리는 어느 날 고객들이 어디서나 그들만의 세계를 탭하고 스와이프하며 펼쳐질 수 있는 시대를 기대하고 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold_0.png"},"coverImage":"/assets/img/2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold_0.png","tag":["Tech"],"readingTime":10},{"title":"피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성","description":"","date":"2024-06-19 13:44","slug":"2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose","content":"\n\n![image](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png)\n\n자동화에 대해 이야기해보겠습니다. 루틴적이고 시간이 많이 소요되는 프로세스를 자동화해야 할 때가 많습니다. 이전 프로젝트에서는 클라이언트를 위한 다양한 UI 사용자 정의가 포함된 단일 코드베이스 기반의 화이트 레이블 솔루션을 갖고 있었습니다. 이 게시물에서는 디자이너의 변경 사항을 찾는 데 추가 시간을 낭비하지 않고 즉시 코드 작성을 시작하는 데 도움이 된 다양한 접근 방식과 도구에 대해 이야기하겠습니다.\n\n# FIGMA/WHATEVER DSM\n\n기초부터 시작해보겠습니다. 디자이너들도 DRY 원칙을 따르기 위해 노력하며 Design System Manager와 같은 훌륭한 도구를 개발합니다. 먼저, 프로젝트에서 반복될 수 있는 구성요소를 식별하고 색상 및 스타일의 구조화된 세트를 개발합니다. 따라서 한 곳에서 색상이나 스타일이 변경되면 전체 프로젝트에서 자동으로 변경됩니다. 편리하죠? Figma나 다른 도구를 사용하여 이러한 구성을 특별한 파일로 내보낼 수 있으며, 그 파일을 분석하여 이를 기반으로 코드를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJetpack Compose을 사용하면 ColorScheme과 TextStyle과 같은 클래스를 알 수 있을 것입니다. Material 철학에 따라, 우리는 ColorScheme을 사용하여 색상을 설명하고 TextStyle을 사용하여 텍스트의 모양을 설명합니다. 이는 컴포넌트가 렌더링하는 데 사용되는 것입니다.\n\n# 코드 생성\n\nRoom, Dagger2와 같은 라이브러리를 사용해 본 적이 있다면, 이미 익숙한 개념일 수 있습니다.\n\nJava에서는 이 개념을 주석 처리(annotation processing)이라고 하며, Kotlin에서는 kapt 또는 ksp로 참조됩니다. 본질적으로 코드를 분석하고 추가 파일을 생성하는 컴파일러 기능입니다. 그러나 JSON 파일에 주석을 첨부할 수 없고 Kotlin 파일이 아니기 때문에, 여기에는 다른 해결책이 필요합니다. 따라서, 입력 데이터를 가져와 필요한 파일을 찾아 필요한 클래스를 생성하는 플러그인을 개발하는 방법을 배울 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Gradle 플러그인\n\nGradle 플러그인을 만드는 방법은 main 그레이들 파일에 작업을 작성하는 것에서 buildSrc에 코드를 배치하는 것까지 다양합니다. 그러나 저희는 권장 사항을 따라 composite 빌드를 사용할 것입니다. 이 아이디어는 간단합니다: 플러그인은 애플리케이션 코드와 분리되어 유지되고, 그런 다음 모든 것이 결합됩니다. 여기에서 AGP와 함께 이 메커니즘을 사용하는 방법에 대한 많은 예를 찾을 수 있으며, 오랫동안 가지고 있던 질문에 대한 답변을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_1.png)\n\n여기에 특별한 것은 없습니다. 차이는 플러그인이 가장 높은 수준에서 어떻게 연결되는지에 있습니다. includeBuild()를 사용하여 연결합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 플러그인 프로젝트의 build.gradle.kts 파일에서, 플러그인이 제대로 작동하기 위해 필요한 종속성 및 기본 구성을 명시해야 합니다. 다음은 플러그인을 위한 예시 설정입니다:\n\n# Gradle 플러그인 구현\n\n젯팩 콤포즈에 대한 Figma 파일 생성을 자동화하기 위한 목표를 달성하기 위해, Gradle 플러그인을 사용하여 다음 단계를 따라야 합니다:\n\n- DSM 토큰의 구조를 분석하고 해당 모델을 준비합니다.\n- 프로젝트에 각 클라이언트 디자인을 설명하는 토큰을 포함하는 모든 가능한 플레이버를 찾습니다.\n- 이 데이터를 분석하여 필요한 파일을 생성하는 방법을 학습합니다.\n- 이를 편리하게 만들고 Gradle 작업에 포장합니다.\n- ...\n- 코드를 작성하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일에는 색상 설명이 포함되어 있습니다. 이 설명은 여러 논리적 수준으로 구성될 수 있으며, 마지막 수준에는 우리가 관심을 가지는 정보가 포함되어 있습니다. 일반적으로 리소스는 유사한 구조를 가지며, 타입과 값이 명시됩니다.\n\n```js\n{\n  \"color\": {\n    \"m3\": {\n      \"white\": {\n        \"description\": \"\",\n        \"type\": \"color\",\n        \"value\": \"#ffffffff\",\n        \"blendMode\": \"normal\"\n      },\n      \"black\": {...},\n      \"sys\": {\n        \"light\": {...},\n        \"dark\": {...}\n      },\n      \"ref\": {...},\n      \"key-colors\": {...},\n      \"source\": {...},\n      \"surfaces\": {...},\n      \"state-layers\": {...}\n    }\n  },\n  \"font\": {...},\n  \"typography\": {...}\n}\n```\n\n색상에 대해서는 해당 값을 관심 있게 살펴보고 있으며, 해당 클래스에는 해당 색상의 16진수 표현이 포함됩니다.\n\n# Gradle 작업\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n작업 등록 중에는 주석으로 표시된 모든 필드를 설정해야 합니다. 즉, JSON 파일의 경로, 플레이버 폴더의 경로 및 생성된 파일의 최종 패키지입니다.\n\n우리의 삶을 편하게 하기 위해 몇 가지를 하드코딩할 것이지만, 더 많은 유연성이 필요한 경우 gradle 확장 기능을 살펴볼 가치가 있습니다.\n\n이 작업은 추상적이므로 일부 구성은 구현에 맡겨둡니다. 따라서 색상 파일을 생성할 작업의 구조는 다음과 같이 보일 것입니다.\n우리의 작업을 실행할 수 있게 하려면 프로젝트에 등록해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 플러그인을 사용하여 프로젝트에 존재하는 빌드 변형을 결정하고 각 유형에 대한 작업을 등록해야 합니다.\n\n이제 가장 흥미로운 부분으로 넘어가 봅시다. 파일 생성이 실제로 어떻게 일어나는지요.\n\n이를 위해 KotlinPoet라는 도구를 사용해야 합니다. 이 도구를 사용하면 필요한 파일을 쉽게 생성할 수 있습니다. 이 전체 매커니즘은 다양한 빌더로 구성되어 있으며, 여기에 파일 유형, 속성, 값 등을 추가합니다.\n\n우리의 작업 핵심은 JSON 구문 분석, 필요한 데이터 획득 및 해당 파일에 쓰는 데 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJSON 파일의 구조를 알고 있기 때문에 데이터를 수집하는 함수를 작성할 수 있어요. 결과적으로 필드 이름을 키로, 모델을 값으로 하는 맵이 만들어질 거예요.\n\n모든 필드의 목록을 갖게 되면, KotlinPoet을 사용하여 파일에 생성하고 싶은 내용을 설명할 수 있어요. 그 결과, 다음과 같은 모습의 파일을 얻게 될 거예요:\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_2.png)\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성된 파일을 사용하여 테마를 설명할 수 있습니다.\n\n![Image 4](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_4.png)\n\n![Image 5](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_5.png)\n\n![Image 6](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 다야! 우리의 초기 작업은 완료되었습니다. 이제 파일을 프로젝트에 업로드하고 작업을 실행하여 개발에 사용할 수 있는 파일을 얻을 수 있습니다. 이전에는 수동으로 수행되어 인간 요인으로 인한 오류가 포함될 수 있었지만, 이제는 원활하게 작동하며 추가 종속성이 필요하지 않습니다(Android와 iOS 솔루션은 기존의 Node.js 모듈을 설치하여 작업을 수행하지 못했으며 여전히 개발자 개입이 필요했습니다).\n\n# 명백하지 않은 도전 과제\n\n플러그인 개발은 문제 해결의 절반입니다. 언제나 문제가 발생할 수 있습니다:\n\n- 프로젝트 복잡성으로 인해 디자이너들은 Material Design을 제대로 사용하지 않고 수십, 아니 수백 개의 사용자 정의된 이름을 가진 색상과 스타일을 만들었습니다. 이로 인해 표준 MaterialTheme을 사용할 수 없었고, 결과적으로 우리 플러그인은 사용자 정의 ColorScheme과 Typography 클래스를 생성했습니다.\n- 초기 개발 및 이전 이관에 상당한 시간이 소요되었지만, Material 설정이 깨끗하고 디자이너와의 토큰 이름 문제를 해결하는 데 몇 시간을 보낼 필요가 없다면 이것은 문제가 되지 않습니다.\n- @Preview 주석은 모두 우리 사용자 정의 테마로 래핑되어야 합니다.\n- 디자인 자체가 문제일 수 있습니다. 고객 중 한 명은 그라데이션을 가진 버튼을 가졌는데, 이 토큰에는 색상을 사용해야 했습니다. 이 문제는 임시 해결 방법으로 우아하게 해결되었지만, 미래에 이러한 충돌이 발생하지 않도록 디자이너에게 강력히 당부했습니다.\n- 구성 복잡성 - 과정 자체는 간단하지만, 이전 문제와 같은 문제는 플러그인의 논리나 모델 구조를 크게 변경해야 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그거면 끝이에요. 비슷한 솔루션을 만들어 본 경험이 있거나 미리보기를 위해 매번 사용자 정의 테마를 작성하는 것을 피하는 방법을 아시는 분들은 댓글에서 공유해 주세요. 코드가 필요한 경우 전체 프로젝트는 여기에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png"},"coverImage":"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png","tag":["Tech"],"readingTime":6},{"title":"Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기","description":"","date":"2024-06-19 13:43","slug":"2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid","content":"\n\n\n![PDFViewer](/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png)\n\nPDF는 우리가 매일 사용하는 가장 일반적인 파일 형식 중 하나입니다. 그러나 Jetpack Compose에서 공식 PDF 뷰어가 아직 없습니다. 그렇다면 왜 만들지 않을까요?\n\n## 어떻게 가능한가요?\n\n우리의 계획 개요를 살펴봅시다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- PDF 파일이 있는 원격 URL 또는 전화 저장소가 있습니다.\n- 하나씩 페이지를 보여줄 수 있습니다.\n- 페이지는 확대 및 이동할 수 있어야 합니다.\n- 서버 PDF를 로컬 캐시/저장소에 다운로드하고 저장해야 합니다.\n- PDF를 '페이지'를 나타내는 '비트맵' 목록으로 변환할 수 있습니다. \n- 그런 다음 간단히, 비트맵을 지원하는 이미지 컴포저블을 사용하여 세로로 페이지를 하나씩 모두 표시할 것입니다.\n\n## 단계 1: PDF 다운로드 및 저장\n\n이 시점에서 PDF의 URL만 있습니다. 이를 다운로드하는 기능을 만들어 보겠습니다.\n\n먼저 AndroidManifest.xml에 다음 권한을 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\n\u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e\n\u003cuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /\u003e\n```\n\n우리는 HttpURLConnection 객체를 사용하여 연결을 설정하고 InputStream을 가져올 것입니다.\n\n```java\nval connection = URL(url).openConnection() as HttpURLConnection\nconnection.connect()\n```\n\n위의 코드들이 작동하여 PDF 파일을 가져올 것입니다. 작업이 완료되었고 필요한 Input stream을 얻었는지 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nif (connection.responseCode != HttpURLConnection.HTTP_OK) {\n    connection.disconnect()\n    return@withContext null\n}\n\nval inputStream = connection.inputStream\n```\n\n작업이 끝나면 꼭 연결을 끊어 주세요.\n\n```kotlin\nconnection.disconnect()\n```\n\n이제 다운로드 부분이 완료되었으니 사용자의 로컬 스토리지에 저장해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nfile = File.createTempFile(fileName, \".pdf\")\nval outputStream = FileOutputStream(file)\ninputStream.copyTo(outputStream)\noutputStream.close()\n```\n\n변경 후 전체 함수는 다음과 같습니다: \n\n```kotlin\nsuspend fun downloadAndGetFile(url: String, fileName: String): File? {\n    if (isFileExist(fileName)) return File(fileName) // 이 줄은 중복 파일 생성을 피하기 위해 중요합니다.\n    var connection: HttpURLConnection? = null\n    var file: File? = null\n    try {\n        withContext(Dispatchers.IO) {\n            connection = URL(url).openConnection() as HttpURLConnection\n            connection!!.connect()\n\n            if (connection!!.responseCode != HttpURLConnection.HTTP_OK) {\n                return@withContext null\n            }\n\n            val inputStream = connection!!.inputStream\n            file = File.createTempFile(fileName, \".pdf\")\n            val outputStream = FileOutputStream(file)\n            inputStream.copyTo(outputStream)\n            outputStream.close()\n        }\n    } catch (e: IOException) {\n        // UI에 응답을 전송합니다.\n    } finally {\n        connection?.disconnect()\n    }\n    return file\n}\n```\n\n```kotlin\nfun isFileExist(path: String): Boolean {\n    val file = File(path)\n    return file.exists()\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 2: 파일 객체를 List`Bitmap`으로 변환합니다.\n\n이 변환에는 PdfRenderer 클래스를 사용할 것입니다:\n\n```js\nPdfRenderer renderer = new PdfRenderer(ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY));\n```\n\n하지만 이것을 직접 사용하는 것은 Jetpack Compose에서 좋지 않고 많은 RAM을 소비할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 다음과 같이 사용할 것입니다:\n\n```js\nval rendererScope = rememberCoroutineScope()\nval mutex = remember { Mutex() }\nval renderer by produceState\u003cPdfRenderer?\u003e(null, file) {\n    rendererScope.launch(Dispatchers.IO) {\n        val input = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)\n        value = PdfRenderer(input)\n    }\n    awaitDispose {\n        val currentRenderer = value\n        rendererScope.launch(Dispatchers.IO) {\n            mutex.withLock {\n                currentRenderer?.close()\n            }\n        }\n    }\n}\n```\n\n이제 우리가 만든 \"PDFRenderer\" 객체인 \"renderer\"를 사용하여 모든 페이지를 가져와 비트맵 객체에 렌더링할 것입니다.\n\n```js\nrenderer?.let {\n    it.openPage(index).use { page -\u003e\n        page.render(destinationBitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 모든 페이지에 대한 비트맵을 가져올 수 있습니다. UI에서 모든 페이지에 표시할 시간입니다.\n\n## 단계 3: UI에 목록`비트맵` 표시 + 줌 및 이동 기능 추가:\n\nPDFViewer Composable의 전체 코드가 필요하면 이를 참조하십시오:\n\n여기서 설명이 시작됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- BoxWithConstraints를 사용하는 이유는 페이지의 높이와 너비를 정의하고 줌 및 이동을 위해 화면의 높이와 너비가 필요하기 때문입니다.\n\n```js\n            val width = with(LocalDensity.current) { maxWidth.toPx() }.toInt()\n            val height = (width * sqrt(2f)).toInt()\n            val pageCount by remember(renderer) { derivedStateOf { renderer?.pageCount ?: 0 } }//Used ahead\n\n            var scale by rememberSaveable {\n                mutableFloatStateOf(1f)\n            }\n            var offset by remember {\n                mutableStateOf(Offset.Zero)\n            }\n            val state = //Used for Zoom and Move\n                rememberTransformableState { zoomChange, panChange, rotationChange -\u003e\n                    scale = (scale * zoomChange).coerceIn(1f, 5f)\n\n                    val extraWidth = (scale - 1) * constraints.maxWidth\n                    val extraHeight = (scale - 1) * constraints.maxHeight\n\n                    val maxX = extraWidth / 2\n                    val maxY = extraHeight / 2\n\n                    offset = Offset(\n                        x = (offset.x + scale * panChange.x).coerceIn(-maxX, maxX),\n                        y = (offset.y + scale * panChange.y).coerceIn(-maxY, maxY),\n                    )\n                }\r\n```\n\nZoom 구현을 자세히 이해하려면 이 비디오를 시청하세요.\n\n2. 이 상태를 LazyColumn과 함께 간단히 사용하고 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n            LazyColumn(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .graphicsLayer {\n                        scaleX = scale\n                        scaleY = scale\n                        translationX = offset.x\n                        translationX = offset.y\n                    }\n                    .transformable(state)\n```\n\n3. 호출할 때 이미 PDF 파일을 다운로드하고 저장했습니다.\n\n```kotlin\nLaunchedEffect(key1 = Unit) {\n        file = async { downloadAndGetFile(url, fileName) }.await()\n    }\n```\n\n4. \"cacheKey\"로부터 Bitmap 객체를 만들어야 합니다. 이미지도 캐시에 저장될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nval cacheKey = MemoryCache.Key(\"${file!!.name}-$index\")\nval cacheValue: Bitmap? = imageLoader.memoryCache?.get(cacheKey)?.bitmap\nvar bitmap: Bitmap? by remember { mutableStateOf(cacheValue) }\n```\n\n5. 이후에는 각 페이지의 비트맵을 가져와 Coil ImageRequest 객체로 표시합니다.\n\n```kotlin\nval request = ImageRequest.Builder(context)\n    .size(width, height)\n    .memoryCacheKey(cacheKey)\n    .data(bitmap)\n    .build()\n\nImage(\n    modifier = Modifier\n        .background(Color.Transparent)\n        .border(1.dp, MaterialTheme.colors.background)\n//        .aspectRatio(1f / sqrt(2f))\n        .fillMaxSize(),\n    contentScale = ContentScale.Fit,\n    painter = rememberAsyncImagePainter(request),\n    contentDescription = \"Page ${index + 1} of $pageCount\"\n)\n```\n\n나머지 부분은 상당히 직관적이고 이해하기 쉽습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 새로운 것을 배웠다면, 좋다면 팔로우 버튼을 눌러 주세요.","ogImage":{"url":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png","tag":["Tech"],"readingTime":7},{"title":"접근성 테스트에서 코틀린 Compose - 이름, 역할, 값","description":"","date":"2024-06-19 13:42","slug":"2024-06-19-AccessibilityTestsinComposeNameRoleValue","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png\" /\u003e\n\n앱을 위한 테스트를 작성할 때는 접근성 관련 사항을 테스트하는 것도 고려해야 합니다. 이해합니다. 어디서부터 시작해야 할지 알기 어려울 수 있죠. 그래서 저는 어떻게 일부 접근성 측면을 테스트할지에 대해 이 블로그 글을 쓰기로 결정했습니다.\n\n이 글에서는 클릭 가능, 선택 가능, 토글 가능한 수정자를 사용하여 구성된 세 가지 사용자 정의 구성 요소에 대한 일부 접근성 관련 테스트를 추가할 것입니다. 이러한 구성 요소는 제가 썼던 블로그 글에서 만들어진 것입니다: Jetpack Compose에서 수정자를 활용한 Android 접근성 향상.\n\n# 무엇을 테스트하는 중인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 작성하는 테스트는 컴포넌트에 이름, 역할 및 값이 있는지 확인합니다. 하지만 이 그룹은 어디에서 왔을까요? 배경은 웹 콘텐츠 접근성 가이드라인(WCAG)이 \"이름, 역할, 값\"이라는 성공 기준을 가지고 있어요. 이는 모든 요소가 프로그래밍 방식으로 결정 가능한 이름과 역할을 가지고 있음을 보장합니다. 또한 사용자가 변경할 수 있는 상태, 속성 및 값은 프로그래밍 방식으로 변경 가능해야 합니다.\n\n그리고 지금, \"웹\"이라는 것을 언급하는 이유가 궁금하다면, WCAG은 이름과는 상관없이 모바일 앱의 최소 접근성 수준을 결정하는 데도 사용됩니다.\n\n\n\n여기서 '이름'은 이용자에게접근성을 제공하는 이름을 의미합니다. 요소의 텍스트 표현이 될 수 있습니다. 예를들어 버튼의 텍스트, 아이콘 버튼의 내용 설명, 스위치의 레이블 등이 있습니다. 스크린 리더를 사용하는 사람이 듣는 내용입니다. 음성 액세스 사용자는 대화형 요소를 활성화할 때 사용합니다.\n\n그리고 '역할'은 요소의 역할을 말합니다. 예를들어 버튼일 수 있습니다 - 이것은 사용자에게 '여기 버튼이 있어요, 그리고 이 버튼은 버튼처럼 행동해야 해'라고 알려줍니다. 역할은 작동해야 하는 방식에 대한 약속입니다. 따라서 역할을 추가한다면 올바른 상호작용도 추가해야 합니다. 그러나 역할은 웹보다는 Android에서 덜 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n값은 요소의 상태, 속성 또는 값에 대한 참조를 할 수 있습니다. 각 요소마다 정확한 의미가 다릅니다. 예를 들어, 체크박스의 경우 값은 체크 여부를 알려주고, 아코디언의 경우 상태가 열렸는지 닫혔는지를 나타냅니다.\n\n다음 섹션에서는 소개 부분에서 언급된 몇 가지 사용자 지정 컴포넌트에 대한 \"이름, 역할, 값\" 성공 기준을 테스트하는 구체적인 예제를 살펴보겠습니다.\n\n# 테스트 작성, 예시\n\n처음에 언급한 대로, 이러한 테스트는 이전에 작성한 블로그 게시물을 위한 컴포넌트에 대해 작성된 것입니다. 세 가지 컴포넌트를 어떻게 테스트할지 살펴보겠습니다: 스위치, 라디오 버튼 그룹 및 클릭 가능한 행.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n블로그 게시물의 구성 요소가 예제를 위해 단순화되었기 때문에 이 테스트들도 간소화되었습니다. 실제 프로덕션 코드에서는 일반적으로 테스트되는 구성 요소를 찾는 더 정교한 전략이 있습니다.\n\n## Toggleable\n\n테스트하는 첫 번째 구성 요소는 아래 사진에 나와있는 스위치와 같습니다:\n\n![Toggleable Component](/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 세 가지를 테스트하고 싶어합니다: 먼저, 컴포넌트에 접근 가능한 이름(따라서, 스위치의 레이블)이 있는지 확인하고 싶습니다. 둘째, 역할이 올바른지-토글 가능한 컴포넌트여야 합니다. 셋째, 스위치를 토글한 후에도 값이 올바른지 확인하고 싶습니다, 따라서 스위치가 켜져 있는지 꺼져 있는지에 상관없이.\n\n테스트를 작성해봅시다:\n\n첫째, 테스트에는 설정이 필요하므로, composeTestRule 및 콘텐츠 설정과 같은 것들이 필요합니다. 그런 다음 테스트 가능한 컴포넌트를 test 태그인 accessible-toggle로 가져옵니다. 마지막으로, 이름, 역할, 값에 대한 테스트가 있습니다.\n\n이름을 확인하는 테스트는 간단합니다: 요소의 텍스트 내용이 레이블의 단어와 같은지 확인하고 싶습니다. assertTextEquals를 사용하여 이를 확인할 수 있습니다. 역할을 테스트하기 위해 유용한 assert 함수인 assertIsToggleable을 사용할 수 있습니다. 마지막으로 값(즉, 확인된 상태)이 올바른지 확인하기 위해, assertIsOff 및 assertIsOn과 같은 유틸리티 함수를 사용할 수 있으며, 상태를 토글하기 위해 performClick을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 선택 가능한 요소\n\n다음으로 테스트하는 컴포넌트는 라디오 버튼 그룹입니다. 사진에서 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_2.png)\n\n이 컴포넌트에서 우리는 두 옵션이 모두 이름(즉, \"옵션 A\"와 \"옵션 B\" 레이블), 선택 가능한 역할 및 선택된 항목의 값을 가지고 있는지 확인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구성 요소의 테스트는 다음과 같습니다:\n\n구조는 이전 테스트와 매우 유사합니다. 먼저 설정하고, 그런 다음 요소를 가져 와서 이름, 역할 및 값에 대해 단언합니다. 요소의 레이블(즉, 이름)을 확인하기 위해 동일한 assertTextEquals를 사용합니다. toggleable과 마찬가지로, 선택 가능한 요소의 역할과 값을 확인하는 함수가 있습니다: isSelectable(), assertIsSelected(), 그리고 .assertIsNotSelected().\n\n## 클릭 가능\n\n이 블로그 글의 마지막 맞춤형 구성 요소는 아이템을 즐겨찾기하는 데 사용할 수 있는 맞춤형 버튼입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Accessibility test](/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_3.png)\n\n우리는 아이템에 이름(즉, \"이 항목 즐겨찾기\")과 버튼 역할, 그리고 해당 항목이 즐겨찾기되었는지 여부를 알리는 상태가 있는지 확인하고 싶습니다.\n\n다음 테스트는 다음을 보장합니다:\n\n다시 말하지만, 이름의 설정과 확인은 다른 두 구성 요소와 유사합니다. 그러나 구성 요소가 버튼 역할을 갖고 있는지 확인하려면 SemanticsMatcher를 사용해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`SemanticsMatcher`은 시맨틱 노드를 매칭하기 위한 래퍼입니다. 요소의 시맨틱 속성 Role이 Role.Button과 일치하는지 확인하고 싶습니다. 이를 위해서 SemanticMatcher로 우리의 체크를 래핑하고, element에서 element.config.getOrNull(SemanticsProperties.Role)을 사용해 element의 SemanticProperties.Role을 가져와 해당 값이 일치하는지 확인할 수 있습니다.\n\n이와 같은 패턴은 element의 state description을 테스트하는 데에도 동일하게 적용됩니다. 코드 중복을 피하기 위해 element의 state description을 확인하는 데 사용되는 extension function인 `assertStateDescription`을 만들었습니다.\n\n# 마무리\n\n이 블로그 포스트에서는 WCAG 성공 기준 4.1.2: Name, Role, Value에 대한 접근성 테스트 작성에 대해 논의했습니다. 이러한 테스트는 모바일 접근성에 항상 적용되는 것은 아니지만, 본 블로그 포스트에서는 접근성 테스트 작성 방법에 대한 예시를 제공하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안드로이드에서 접근성에 대한 테스트를 작성해 보았나요? 공유해 주시면 감사하겠어요!\n\n# 블로그 글 링크\n\n- Jetpack Compose에서 Modifier를 사용하여 안드로이드 접근성 향상하기\n- 이름, 역할, 값\n- SemanticsMatcher","ogImage":{"url":"/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png"},"coverImage":"/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png","tag":["Tech"],"readingTime":5},{"title":"제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다","description":"","date":"2024-06-19 13:40","slug":"2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem","content":"\n\n(고지: 저는 독립 개발자/개인이며 Zomato 엔지니어 팀에서 일하고 있지 않습니다)\n\n최종 제품이 어떻게 작동하는지 확인하려면 여기를 클릭하세요: [https://youtu.be/E89Etnvq6rY](https://youtu.be/E89Etnvq6rY)\n\n코드를 확인하려면 여기를 클릭하세요: [https://github.com/oddlyspaced/zomato-notification/tree/main](https://github.com/oddlyspaced/zomato-notification/tree/main)\n\n---\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZomato Android 앱을 매일 사용하는 사용자이자 앱 엔지니어로서, 나는 이 앱의 디자인과 어디에서나 음식 주문이 가능하다는 편의성을 사랑하게 되었습니다. 그러나 항상 음식 배달 상태를 확인하기 위해 앱을 열어야 한다는 점이 불편하다고 느꼈습니다. 앱은 훌륭한 주문 추적 화면을 제공하지만, iOS 버전의 Zomato 앱이 iOS 활동 인디케이터를 활용하여 제공하는 지속성과 쉬운 액세스를 제공하지 못한다는 점이 마음에 듭니다. 이에 영감을 받아 Zomato Android 앱을 역공학하여 주문 추적 경험을 향상시킬 수 있는 사용자 정의 솔루션을 구축하기로 결심했습니다. 이 글에서는 필요한 API 엔드포인트를 발견하고, 앱의 시스템 아키텍처를 설계하며, 반복적으로 Zomato 앱을 열 필요 없이 실시간 주문 추적 정보를 제공하는 지속적인 알림을 구현하는 과정을 공유하겠습니다.\n\n# 파트 1: 앱 트래픽 이해\n\n정보를 표시하는 방법을 이해하려면, 앱이 필요한 정보를 가져오는 방법을 파악해야 합니다. 앱과 서버 간의 네트워크 트래픽을 검사하는 것이 시작점으로 좋습니다. 이를 통해 앱으로 전송되는 정보에 대한 정확한 지식을 얻을 수 있습니다. 나중에 독립적으로 호출해야 하는 API 엔드포인트에 대한 정보를 제공해 줄 것입니다.\n\n이를 위해 다음 도구를 활용했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- apktool\n- Charles Proxy\n- Android Emulator\n\n앱을 디버깅하기 위한 설정 과정은 간단합니다. 이 글에서는 다루지 않겠습니다. \n\n다음 글을 참고해주세요 :\n\n# Part 2: 앱 트래픽 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n환경 설정이 완료되었으므로 이제 트래픽을 분석하고 요청 내용을 확인할 수 있습니다. 주문 내역을 가져오는 요청을 찾으려면 앱의 주문 내역 페이지로 이동하여 동시에 Charles의 활동을 확인합니다. 이 페이지에 접속할 때마다 호출되는 특정 엔드포인트가 있는 것으로 보입니다. 바로 이것입니다:\n\n```js\nhttps://api.zomato.com/gw/order/history/online_order\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png\" /\u003e\n\n이것에 대한 응답을 확인해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 샘플의 요약된 응답입니다. 전체 샘플 응답은 여기 있습니다.\n\nJSON 구조를 연구하면 결과 목록이 있고 레이아웃 구성 및 order_history_snippet_type_2 키가 있는 객체가 있음을 알 수 있습니다. order_history_snippet_type_2 객체에는 사용할 수 있는 정보가 포함되어 있습니다. click_action 객체에는 딥링크 문자열이 포함되어 있어 주문 ID를 추출하는 데 사용할 수 있습니다. 주문 ID는 다른 위치에도 있지만, 이것이 제 기준으로는 굉장히 간단한 장소로 보였습니다. 우리가 필요로 하는 다른 모든 정보가 포함된 top_container 및 bottom_container도 있습니다. 레스토랑 이름은 top_container의 title 객체 안에 있는 텍스트 항목에서 추출할 수 있습니다. 주문 ID는 딥링크에서 시작 태그를 대체하고 숫자를 유지하여 간단히 추출할 수 있습니다. 주문 상태는 top_container의 title 객체 안에 있는 텍스트 항목에서 추출할 수 있습니다. 주문 배달 시간은 bottom_container의 title 객체 안에 있는 텍스트 항목에서 추출할 수 있습니다.\n\n마찬가지로 주문을 배치하고 앱의 주문 상세 페이지에서 트래픽 활동을 분석하면 다음 API Endpoint가 반복적으로 호출됩니다:\n\n```js\nhttps://api.zomato.com/v2/order/crystal_v2\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 엔드포인트의 응답에는 많은 개인 정보가 포함되어 있기 때문에 샘플 응답을 공유할 수 없습니다. 그러나 참고로 응답에서 다음 태그들은 다음 정보를 제공합니다 :\n\n```js\nresponse -\u003e order_details -\u003e res_name = 음식점 이름\nresponse -\u003e order_details -\u003e tab_id = 주문 ID\nresponse -\u003e header_data -\u003e pill_data -\u003e left_data -\u003e title -\u003e text  = 예상 시간 (문자열) [예: 5분 후 도착 예정] \nresponse -\u003e header_data -\u003e subtitle2 -\u003e text = 텍스트 형식의 주문 상태 [예: 길을 가는 중, 곧 픽업될 예정 등]\nresponse -\u003e header_data -\u003e pill_data -\u003e right_data -\u003e title -\u003e text = 주문 예상 상태 [예: 제 시간, 지연됨]\n```\n\n# Part 3: 알림 디자인\n\n데이터 가져오기 부분이 해결되었으므로, iOS의 활동 표시기에서 영감을 받은 알림 시스템을 구축하고 싶습니다. 이는 Zomato가 iOS 앱에서 활동 표시 서비스를 활용하는 방식입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Figma 디자인으로 만든 Android 알림의 유사한 레이아웃입니다:\n\n![Android 알림 디자인](/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_2.png)\n\niOS 활동 지시기와 마찬가지로 앱에서 생성된 알림은 레스토랑 이름, 현재 주문 상태의 텍스트 표현, 배송 시간 예상 상태 및 실제 배송 전달 시간 예상을 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파트 3: 정보 흐름 처리 및 알림 관리\n\n![이미지](/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_3.png)\n\n정기적으로 업데이트할 수 있는 알림을 갖기 위해 Foreground Service를 활용하고 주문 세부 정보를 계속 가져오도록 하는 기능이 필요합니다. 이 서비스를 \"OrderTrackService\"라고 부르겠습니다. 이 서비스의 주요 목적은 주문 ID를 수락하고 crystal_v2 API를 호출하여 주문 상태 정보를 가져온 다음 해당 정보를 알림에 표시하는 것입니다. 이 작업은 30초 간격으로 반복되며 주문 상태가 \"배달 완료\"가 될 때까지 실행됩니다.\n\n알림을 처리하기 위해 주문 정보를 표시하는 사용자 정의 레이아웃을 만들 것입니다. 알림은 특정 ID로 표시됩니다. Android에서 동일한 ID로 알림을 다시 보내면 알림 패널에 이미 표시된 기존 알림이 자동으로 업데이트됩니다. 따라서 우리는 주문 정보를 가져와 기존 ID를 사용하여 알림을 다시 만들고 표시하는 이 논리를 활용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스를 제어하고 시작하기 위해서는 Activity도 필요합니다. 이 Activity의 주요 목적은 주문 내역을 가져와 목록으로 표시하는 것입니다. 이 목록을 통해 어떤 주문 ID를 OrderTrackService에 전달하여 알림을 처리할지 선택할 수 있습니다.\n\n# 파트 4: 모두 함께 사용하기\n\n디자인과 시스템이 명확하게 정해지면 이제 아이디어를 현실로 구현할 때입니다. 먼저 Jetpack Compose를 사용하여 MainActivity를 구현하여 시작했습니다. 메인 액티비티에는 세 개의 버튼이 있습니다. 첫 번째 버튼은 앱에 POST_NOTIFICATION 권한을 요청하는 기능을 합니다. 두 번째 버튼은 Foreground 서비스를 시작하는 기능을 하며, 마지막 버튼은 주문 내역을 가져오는 데 사용됩니다. \"주문 가져오기\" 버튼을 탭하면 앱은 online_order API를 호출하고 주문 상태가 \"배달완료\"가 아닌 결과를 필터링합니다. 필터링된 주문은 현재 활성화된 주문입니다.\n\nAPI 엔드포인트를 호출하기 위해 retrofit 라이브러리를 구현하고 필요한 헤더와 함께 적절한 인터페이스를 만들었습니다. 코드 품질을 보장하기 위해 모든 것을 MVVM 패턴을 사용하여 구현했고 Retrofit 인스턴스를 처리하기 쉽도록 의존성 주입을 위해 Hilt를 사용했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOrderTrackService 클래스는 Service 클래스의 확장입니다. 우리는 여기서 알림 로직을 처리할 것입니다. MainActivity와 OrderTrackService 간의 통신은 Broadcast Intents를 통해 설정됩니다. MainActivity에 표시된 목록의 각 주문에 대응하는 버튼은 주문 ID가 Intent의 데이터 번들 일부로 포함된 Broadcast Intent를 보냅니다. 이 Broadcast Intent를 받으면 Foreground Service가 작동하여 crystal_v2 API를 호출하여 지정된 주문 ID에 대한 주문 세부 정보를 가져옵니다. 그런 다음 정보를 표시하는 알림을 생성합니다. 가져오기 및 게시 로직은 Kotlin Flow 내에서 작동하도록 제작되어 여러 알림을 독립적으로 처리할 수 있도록 지원하며 필요한 경우 반복적인 Flow를 시작합니다. Flow를 사용하면 원하는대로 작업을 일시 중지/반복할 수 있으므로 동일한 작업을 원하는 지연 시간(우리의 경우 여기서는 30초)으로 반복할 수도 있습니다.\n\n```Markdown\n\u003cimg src=\"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_4.png\" /\u003e\n```\n\n# 최종:\n\n이 사용자 지정 앱은 내 시간을 절약할 뿐만 아니라 주문 상태를 효율적으로 파악하는 더 나은 방법을 제공합니다. 개발 이후로 앱을 여러 번 들여다보지 않고도 주문 상태를 손쉽게 추적할 수 있어서 매우 편리합니다. 본문이 역공학 및 네트워크 호출의 구현 과정에 대한 통찰을 제공했기를 바랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트의 완전한 소스 코드를 GitHub 리포지토리에서 확인할 수 있어요:\n\n[https://github.com/oddlyspaced/zomato-notification/tree/main](https://github.com/oddlyspaced/zomato-notification/tree/main)\n\n자유롭게 탐색하고 실험하며, 더 많은 향상을 위한 아이디어가 있으면 프로젝트에 기여해주세요.","ogImage":{"url":"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png"},"coverImage":"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png","tag":["Tech"],"readingTime":6},{"title":"다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법","description":"","date":"2024-06-19 13:38","slug":"2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform","content":"\n\n## 여러 환경에 걸쳐 AWS Lambda 함수를 배포하는 방법 배우기 — Hashicorp Terraform을 통해 가능하게 하기\n\n![이미지](/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png)\n\nAWS Lambda는 서버를 프로비저닝하거나 관리하지 않고 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스로, 배포 프로세스를 간소화하고 비즈니스가 자동으로 확장할 수 있게 합니다. 그러나 특히 여러 환경에 걸쳐 Lambda 함수를 배포하는 것은 개발 라이프사이클을 복잡하게 만들 수 있는 특정한 도전을 야기합니다.\n\n# Lambda 배포 도전\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS 람다 함수를 배포하는 가장 기본적인 방법은 주로 AWS 관리 콘솔을 통해 zip 파일을 수동으로 업로드하거나 AWS CLI 명령을 사용하는 것입니다. 그러나 이 방법은 몇 가지 어려움을 야기할 수 있습니다:\n\n- 일관성 문제: 수동 프로세스는 실수하기 쉽습니다. 개발, 테스트 및 프로덕션 환경을 거치는 반복 배포가 신중하게 관리되지 않으면 일관성 문제를 야기할 수 있습니다.\n- 확장성 제한: 애플리케이션이 성장함에 따라 여러 함수를 수동으로 관리하는 것은 다루기 어렵고 실수를 유발할 수 있습니다.\n- 구성 관리: 다른 환경(예: 개발, 스테이징, 프로덕션)에 대한 다른 구성을 수동으로 처리하는 것은 복잡하며 구성 드리프트를 야기할 수 있습니다.\n- 버전 관리: 수동 배포는 기본적으로 버전 관리를 지원하지 않으며, 변경 사항을 추적하거나 이전 버전의 함수로 롤백하는 것이 어려울 수 있습니다.\n\n# Terraform을 활용하여 다중 환경 도전을 해결하기\n\n개발, 스테이징, 프로덕션과 같은 여러 환경에 걸쳐 람다 함수를 배포하려면 구성 및 인프라를 일관되게 처리하는 전략이 필요합니다. 이것이 Terraform이 이러한 문제들에 대처하는 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 인프라스트럭처를 코드로 정의함으로써 Terraform은 배포가 다양한 환경에서 반복 가능하고 일관성 있게 이루어지도록 합니다. 이는 \"내 컴퓨터에서는 작동한다\" 문제를 제거합니다.\n- 환경 분리: Terraform은 워크스페이스나 변수 파일을 활용하여 동일한 코드로 여러 환경을 관리할 수 있습니다. 각 환경은 Terraform의 상태 파일을 통해 구성을 관리함으로써 격리를 보장하고 교차 환경 오염의 위험을 최소화합니다.\n- 자동화된 배포: Terraform은 자원 생성, 수정 및 삭제 과정을 자동화하여 인간 에러 가능성을 줄이고 효율성을 높입니다.\n- 변경 관리와 버전 관리: Terraform을 사용하면 모든 변경 사항이 버전 관리되고 적용되기 전에 검토되어 수정 사항에 대한 감사 트레일을 제공하고 쉬운 롤백 매커니즘을 제공합니다.\n\n# Terraform을 활용한 실용적인 구현\n\n제공된 Terraform 코드는 Lambda 함수용 필요한 인프라를 설정하는 방법을 보여줍니다. IAM 역할, 정책, 그리고 Lambda 함수 자체를 구성하고 Terraform 변수를 사용하여 환경별 구성을 설정합니다.\nAWS Terraform 프로바이더에 익숙하지 않은 경우, Terraform을 AWS에 연결하는 방법을 이해하기 위해 해당 문서를 읽어보세요.\n\n1. IAM 역할 및 정책 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n람다 함수는 다른 AWS 리소스와 상호작용할 것입니다. 이를 위해 IAM 역할을 가정해야 합니다. 먼저 해당 역할을 만들어 봅시다.\n\n```js\n# 람다 함수가 가정할 IAM 역할을 정의합니다.\nresource \"aws_iam_role\" \"lambda_role\" {\n  name               = \"lambda_function_role\"\n  assume_role_policy = \u003c\u003cEOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n```\n\n## 설명\n\n이 IAM 역할을 생성하고 해당 가정 역할 정책을 첨부함으로써, 람다 함수가 이 역할을 가정할 수 있게 합니다. 즉, 람다 함수는 이 역할과 관련된 권한을 사용하여 다른 AWS 리소스와 상호작용할 수 있습니다. 예를 들어, 이 역할에 S3 버킷에 액세스를 허용하는 정책을 첨부하면, 람다 함수는 이 역할을 사용하여 해당 버킷에서 읽거나 쓰는 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_1.png\" /\u003e\n\n참고: 본 튜토리얼에서는 환경 변수가 어떻게 사용되는지 간단하게 알 수 있도록 실제 버킷과 AWS 정책은 사용하지 않습니다. 하지만 다음 기사에서 사용할 예정입니다.\n\n# 람다 함수 배포\n\n환경에 따라 다른 변수를 출력하는 기본 \"Hello World!\" 파이썬 함수를 배포할 것입니다. 람다 패키지는 두 개의 파일로 구성됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# index.py, 핸들러가 있는 곳입니다\nfrom config import BUCKET_NAME\n\ndef lambda_handler(event, context):\n   message = f\"버킷 사용 중: {BUCKET_NAME}\"\n   return {\n       'message' : message\n   }\n```\n\n```js\n# config.py, 환경 변수를 가져와 다른 구성을 할 수 있습니다\nimport os\n\n# 지정되지 않은 경우 'mybucket'으로 기본 설정\nBUCKET_NAME = os.getenv('BUCKET_NAME', 'mybucket')\n```\n\n먼저, Lambda 함수 코드가 있는 \"code\" 폴더를 압축하여 배포에 사용할 ZIP 파일로 만들기 위해 Terraform 아카이브 파일 데이터 원본을 정의할 것입니다.\n\n```js\n# Lambda 배포를 위해 Python 코드를 zip 파일로 묶습니다.\ndata \"archive_file\" \"zip_the_code\" {\n  type        = \"zip\"\n  source_dir  = \"./code/\"\n  output_path = \"./code/test-terraform.zip\"\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 화면 구조를 명확하게하기 위해 스크린샷을 여기에 넣었습니다.\n\n![폴더 구조 이미지](/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_2.png)\n\n이제 우리는 람다 자원을 생성하기 위해 출력을 사용할 수 있습니다. 여기서 source_code_hash 속성이 매우 중요합니다. 소스 코드 해시 덕분에 Terraform이 코드의 변경을 감지할 수 있습니다.\n\n```js\n# 환경별 변수로 Lambda 함수를 배포합니다.\nresource \"aws_lambda_function\" \"terraform_lambda_func\" {\n  filename         = data.archive_file.zip_the_code.output_path\n  function_name    = \"MyLambdaFunction\"\n  role             = aws_iam_role.lambda_role.arn\n  handler          = \"index.lambda_handler\"\n  source_code_hash = data.archive_file.zip_the_code.output_base64sha256\n  runtime          = \"python3.8\"\n  environment {\n    variables = {\n      BUCKET_NAME = var.BUCKET_NAME\n    }\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 주요 요소는 환경 블록입니다. 이 블록을 정의함으로써 AWS Lambda가 실행 중에 읽을 수 있는 환경 변수인 BUCKET_NAME의 값을 지정할 수 있습니다.\n\n# 여러 환경 관리\n\n여러 환경을 관리하는 방법으로는 Terraform 워크스페이스를 사용하거나 서로 다른 변수 파일로 Terraform을 실행하여 각 환경별로 리소스를 분리하고 상태를 별도로 관리하는 데 도움이 됩니다:\n\n```js\n# 새 워크스페이스를 생성하고 개발 환경을 위한 리소스를 배포합니다.\nterraform workspace new development\nterraform apply -var=\"BUCKET_NAME=dev-bucket\"\n\n# 프로덕션 워크스페이스로 전환하고 리소스를 배포합니다.\nterraform workspace new production\nterraform apply -var=\"BUCKET_NAME=prod-bucket\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가끔은 많은 환경 변수를 정의해야 할 때가 있습니다. 그럴 땐 환경에 따라 다른 테라폼 변수 파일을 가리킬 수 있습니다.\n\n## 예시\n\n```js\nterraform apply -var-file=\"dev-variables.tfvars\"\nterraform apply -var-file=\"prod-variables.tfvars\"\n```\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS Lambda 함수를 여러 환경에 배포하기 위해 Terraform을 사용하면 배포를 표준화하고 서버리스 애플리케이션을 간단하게 관리할 수 있어요.\n\n다음에는 GitHub 액션, CSV 파일 및 적절한 폴더 구조를 사용하여 오늘 본 개념과 기술을 어떻게 제품화하는지 보여 드릴게요.\n\n읽어 주셔서 감사합니다. 저는 Infostrux의 데이터 아키텍트인 Mehdi Sidi Boumedine입니다. LinkedIn에서 저와 연락하거나 팔로우하고 Infostrux 블로그의 최신 기고를 확인해 주세요. 다음 글도 기대해 주세요.","ogImage":{"url":"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png"},"coverImage":"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png","tag":["Tech"],"readingTime":6}],"page":"17","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"17"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>