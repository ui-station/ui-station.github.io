<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/38" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/38" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="가장 많이 묻는 질문 - SOLID 원칙 JAVA" href="/post/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가장 많이 묻는 질문 - SOLID 원칙 JAVA" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가장 많이 묻는 질문 - SOLID 원칙 JAVA" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">가장 많이 묻는 질문 - SOLID 원칙 JAVA</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요" href="/post/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기" href="/post/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법" href="/post/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 여러 개의 경고를 표시하는 방법" href="/post/2024-06-19-HowtoshowMultipleAlertsinSwiftUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 여러 개의 경고를 표시하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtoshowMultipleAlertsinSwiftUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 여러 개의 경고를 표시하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI에서 여러 개의 경고를 표시하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코틀린 멀티플랫폼 KMP" href="/post/2024-06-19-KotlinMultiPlatformKMP"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코틀린 멀티플랫폼 KMP" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-KotlinMultiPlatformKMP_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코틀린 멀티플랫폼 KMP" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코틀린 멀티플랫폼 KMP</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기" href="/post/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="원활한 사용을 위해 ExecuTorch와 함께 모바일 앱에 원시 AI를 적용하기 - 파트 1 - iOS" href="/post/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="원활한 사용을 위해 ExecuTorch와 함께 모바일 앱에 원시 AI를 적용하기 - 파트 1 - iOS" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="원활한 사용을 위해 ExecuTorch와 함께 모바일 앱에 원시 AI를 적용하기 - 파트 1 - iOS" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">원활한 사용을 위해 ExecuTorch와 함께 모바일 앱에 원시 AI를 적용하기 - 파트 1 - iOS</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 모바일 앱 보안 iOS 모바일 개발자를 위한 최선의 모범 사례" href="/post/2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 모바일 앱 보안 iOS 모바일 개발자를 위한 최선의 모범 사례" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 모바일 앱 보안 iOS 모바일 개발자를 위한 최선의 모범 사례" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 모바일 앱 보안 iOS 모바일 개발자를 위한 최선의 모범 사례</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 빌드 시스템을 Buck에서 Bazel로 전환하기" href="/post/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 빌드 시스템을 Buck에서 Bazel로 전환하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 빌드 시스템을 Buck에서 Bazel로 전환하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 빌드 시스템을 Buck에서 Bazel로 전환하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link posts_-active__YVJEi" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"가장 많이 묻는 질문 - SOLID 원칙 JAVA","description":"","date":"2024-06-19 21:55","slug":"2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA","content":"\n![SOLID Principles in JAVA](/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png)\n\n- **S — Single Responsibility Principle (SRP)**\n  - Each unit of code should have only one responsibility.\n  - A unit can be a class, module, function, or component.\n  - Keeps code modular and reduces tight coupling.\n  - Example: A class that handles user authentication should not also manage database connections.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# O — Open/Closed Principle (OCP)\n\n- 코드 단위는 확장을 허용하고 수정을 제한해야 합니다.\n\n- 기존 코드를 수정하는 대신 새 코드를 추가하여 기능 확장.\n\n- React 프론트엔드와 같이 구성 요소 기반 시스템에서 유용합니다.\n  예: 로깅 시스템에 새 로그 핸들러를 생성하여 기능을 추가하는 것이 기존 핸들러를 변경하는 것보다 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# L — 리스코프 치환 원칙 (LSP)\n\n- 서브클래스는 기본 클래스로 대체 가능해야 합니다.\n- 기본 클래스의 기능은 모든 서브클래스에서 사용할 수 있어야 합니다.\n\n- 만약 서브클래스가 기본 클래스의 기능을 사용할 수 없다면, 그것은 기본 클래스에 있어서는 안 됩니다.\n  예: `새` 클래스에 `참새`와 `펭귄` 서브클래스가 있는 경우, 만약 `새`에 `날다` 메소드가 있다면, `펭귄`은 날지 못하기 때문에 상속받으면 안 됩니다.\n\n# I — 인터페이스 분리 원칙 (ISP)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 몇 개의 일반 목적이 아닌 구체적인 인터페이스를 제공해주세요.\n\n- 클라이언트는 사용하지 않는 메소드에 의존하면 안 됩니다.\n  예시: `Vehicle` 인터페이스를 `Drivable`과 `Flyable`로 분리하여 자동차 클래스가 `Flyable`을 구현할 필요가 없도록합니다.\n\n# D — 의존성 역전 원칙 (DIP)\n\n- 구체적인 클래스가 아닌 추상화에 의존해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 시스템의 부분 간 의존성을 분리시키기 위해 추상화를 사용하세요.\n\n- 인터페이스나 추상화를 사용하여 코드 유닠 사이에 직접 호출을 피하세요.\n  예: 특정 'FileLogger' 클래스 대신 로깅을 위해 'ILogger' 인터페이스를 사용하세요.\n","ogImage":{"url":"/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png"},"coverImage":"/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png","tag":["Tech"],"readingTime":3},{"title":"자바 가상 스레드가 플랫폼 스레드보다 느린 이유는 무엇인가요","description":"","date":"2024-06-19 21:54","slug":"2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads","content":"\n혹시 팀 애플리케이션 서비스에 기능을 구현하려다가 예상대로 되지 않은 적이 있나요? 저도 정확히 그런 일이 발생했어요!\n\n# 제가 겪은 일을 설명하기 전에 가상 스레드를 살펴보죠\n\n\"가상 스레드는 대량 처리 동시 응용 프로그램의 작성, 유지 관리 및 관찰 노력을 크게 줄이는 가벼운 스레드입니다.\"\n— 참고: (https://openjdk.org/jeps/444)\n\n플랫폼 스레드의 문제는 I/O 작업 완료를 기다리는 시간입니다. 해당 스레드가 다른 작업을 수행할 수 없어 기본적으로 아이들 상태가 됩니다. 이는 많은 동시 요청을 처리하는 응용 프로그램에게 특히 비효율적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 사진에서 보여지는 시나리오에서 플랫폼 스레드가 두 번 블록되어 프로그램이 크게 느려질 수 있습니다. 이는 흔히 발생하는 일입니다. 그러나 이러한 상황을 해결하기 위해 리액티브 프레임워크라 불리는 비차단 솔루션이 등장했습니다.\n\nSpring Boot은 Project Reactor를 기반으로 한 Spring WebFlux 스택을 제공합니다. Spring WebFlux를 사용하는 개발자들은 전체 개발 프로세스를 수정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2017년, 자바 엔지니어들은 문제를 해결하기 위해 \"프로젝트 룸\"을 시작했습니다. 결국, 그들은 \"가상 스레드\"를 개발했습니다.\n\n![이미지](/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_2.png)\n\n가상 스레드의 주요 개념은 단일 가상 스레드가 여러 플랫폼 스레드에 장착될 수 있다는 것입니다. 가상 스레드는 블로킹 I/O 작업에서 오류가 발생할 때 현재 플랫폼 스레드에서 해제됩니다. 이 절차는 가상 스레드가 I/O 작업이 완료될 때까지 대기하는 동안 플랫폼 스레드가 다른 작업을 처리할 수 있도록 합니다. I/O 작업이 완료되면, 가상 스레드는 새로운 사용 가능한 플랫폼 스레드에 장착되어 실행을 계속할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 팀원이 점심 시간에 (블로킹 I/O)다른 플랫폼 스레드로 이동하여 소포 트럭이 중단되지 않고 여정을 계속할 수 있도록 하는 택배 회사의 전략을 상상해 보세요. 이 방식은 물류 운영 시간을 단축시키고 생산성을 높이며 회사를 경쟁력이 더 뛰어나게 만들었습니다.\n\n플랫폼 스레드 간으로 이동하여 마운트 및 언마운트함으로써 가상 스레드는 I/O 작업이 완료될 때까지 블록되지 않을 수 있습니다. 이는 플랫폼 스레드를 더 효율적으로 사용할 수 있게 하고 전반적인 대기 시간을 줄입니다.\n\n간단히 말하면, 단 한 줄의 코드 변경으로 서비스 성능을 향상시킬 수 있는 가장 간단한 방법입니다.\n\nSpring Boot에서 Java 가상 스레드를 활성화하려면 \"application.properties\"에 이 구성을 추가하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nspring.threads.virtual.enabled = true; // 클릭 한 번으로 쉽게 설정 !!\n```\n\n참고: 이 설정은 JDK 21 이상과 Spring Boot 3.2 이상을 필요로 합니다.\n\n# 성능 비교를 위한 테스트 API 빌드\n\n```js\n@RestController\npublic class PerformanceTestController {\n\n    @GetMapping(\"/test\")\n    public ResponseEntity\u003cString\u003e testPerformance() throws InterruptedException {\n\n        System.out.println(\"Sleeping ...\");\n        // CPU 바인드되지 않는 작업 시뮬레이션, 3초 동안 sleep\n        Thread.sleep(3000);\n\n        return ResponseEntity.ok(\"테스트 완료\");\n    }\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Apache HTTP 서버 벤치마킹 도구를 사용하여 서비스 성능을 측정할 수 있어요\n\n다양한 부하로 테스트하고 결과를 분석하여 개선할 수 있어요.\n\n여기 명령어에요.\n\n```js\nab -c 300 -n 1000 -r “http://localhost:8443/test\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- -c 300: 동시 요청 수입니다. 이 경우에는 서버를 동시에 폭격하기 위해 가상 사용자 [300]명이 시뮬레이션됩니다.\n- -n 1000: 최종적으로 실행될 총 요청 수입니다 [1000].\n- -r “http://localhost:8443/test”: 벤치마크 테스트 대상 URL입니다.\n\n테스트를 시작합니다. 첫 번째는 기존 방식을 사용하고, 두 번째는 가상 스레드가 활성화됩니다.\n\n가상 스레드 강력해요! 플랫폼 스레드보다 약 20% 빠른 속도로 동일한 작업을 완료합니다 (65.21 RPS 대 54.80 RPS). 그렇다면, 왜 제목에서 가상 스레드가 플랫폼 스레드보다 느리다고 말했을까요?\n\n# 실세계에서의 가상 스레드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 팀의 API 분석\n\n- GET 방식 사용 중\n- 요청 방식 검증\n- 데이터베이스에서 데이터 쿼리\n- RestClient를 통해 다른 서비스로 요청 보내기\n- 데이터베이스에 데이터 업데이트/저장\n\n성능 테스트 결과\n\n```js\n플랫폼 스레드: 587.24 TPS, 평균 응답 시간은 56.52ms\n가상 스레드: 502.80 TPS, 평균 응답 시간은 66.54ms\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가상 스레드가 플랫폼 스레드보다 느리다고 테스트 결과에서 나왔다니, 무슨 실수를 한 걸까요?\n\n# 핀닝, 발동한 숨겨진 함정\n\n![이미지](/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_4.png)\n\n캐리어 스레드는 가상 스레드가 현재 실행 중인 플랫폼 스레드를 정의하는 또 다른 용어입니다. 핀닝은 가상 스레드가 플랫폼 스레드에 매핑되어 있는 상태를 말하며, 캐리어 스레드에 붙어서 떨어질 수 없는 상태를 묘사합니다. 이는 가상 스레드의 상태를 힙 메모리에 저장할 수 없기 때문에 발생합니다. 핀닝된 스레드는 다른 스레드가 동일한 플랫폼 스레드를 사용하는 것을 막습니다. 몇 가지 가능한 원인을 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 동기화된 블록 또는 메서드: 한 번에 한 스레드만 들어갈 수 있습니다. 다른 스레드들은 현재(실행 중인) 스레드가 나갈 때까지 차단됩니다. 경합 조건을 방지하고 데이터의 정확한 상태를 유지하기 위해 공유 리소스에 중단되지 않은 액세스가 필요합니다.\n\n```js\nclass MyService {\n  public void calculateFee() {\n    synchronized (this) {\n      ...\n    }\n  }\n}\n```\n\n- 네이티브 메서드: 이 메서드를 사용하면 다른 언어의 코드(C 또는 C++ 등)를 Java 프로젝트에 통합할 수 있습니다. 네이티브 메서드는 Java 가상 머신 내에서 호출되지만 Java의 제어 범위 밖에서 실행됩니다.\n\nMyService.java\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class MyService {\n  public static void main(String[] args) {\n    System.out.println(calculateFee(5, 3));\n  }\n  public static native int calculateFee(int a, int b);\n  static {\n    // Loads the native library from file named \"nativemethod.c\".\n    System.loadLibrary(\"nativemethod\");\n  }\n}\n```\n\nnativemethod.c\n\n```c\n#include \u003cjni.h\u003e\n\nJNIEXPORT jint JNICALL Java_calculateFee (JNIEnv *env, jobject obj, jint a, jint b) {\n  return a * b;\n}\n```\n\n- 외부 함수: 다른 프로그래밍 언어로 작성된 함수로서, Foreign Function Interface (FFI)를 통해 가상 스레드에 노출된 함수입니다. FFIs는 다른 언어로 작성된 코드들이 함께 동작할 수 없는 상황에서 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic interface PythonFunctions extends Library {\n  /**\n   * 이 정적 final 필드는 `PythonFunctions` 인터페이스의 싱글톤 인스턴스를 생성합니다.\n   * 이는 `Library.getInstance` 메서드에서 인스턴스를 검색하고 이 인터페이스 유형으로 캐스팅합니다.\n   */\n  PythonFunctions INSTANCE = (PythonFunctions) Library.getInstance(\"python_functions\");\n  doubled calculateFee(doubled a, doubled b);\n}\n```\n\n# 다음 JVM 매개변수를 옵션으로 사용하여 고정된 스레드를 추적하세요\n\n- -Djdk.tracePinnedThreads=full: 고정된 상태에서 스레드가 고정되어 있을 때 완전한 스택 추적을 출력하며, 네이티브 프레임과 모니터를 보유한 프레임을 강조합니다.\n- -Djdk.tracePinnedThreads=short: 문제가 있는 프레임만을 포함하여 출력을 제한합니다.\n\n로그에는 가상 스레드 내에서의 메서드 호출의 스택 추적이 표시됩니다. 이 스레드는 JDBC(Java Database Connectivity) 및 특히 MySQL 연결과 상호 작용하는 메서드를 실행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주목할 점은 이러한 메서드 호출 중 몇 가지가 `= monitors:1` 표기를 포함하고 있어서 가상 스레드가 이 코드 실행 블록 내에서 계속 고정되어 있는 것을 나타낸다.\n\n# 버그 #110512 기여: synchronized를 ReentrantLock으로 교체\n\n마침내 깨달았어요. 저는 사용 중인 MySQL Connector/J 버전 8에서 가상 스레드를 지원하지 않는다는 것을.\n\n다음 단계로 나아가는 내 선택지입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- MySQL Connector/J 버전 9.0.0 이상으로 업그레이드하세요: 이 버전은 가상 스레드가 데이터베이스 상호 작용을 최적으로 수행하도록 합니다.\n- 새 라이브러리 탐험: 새 라이브러리를 찾아 새로운 코드를 작성하고 테스트해 보세요. 도전적이며 상당한 노력이 필요할 수 있습니다.\n\n# 한 발 물러서 두 발 앞으로!\n\n플랫폼 스레드에서 가상 스레드로의 전환을 통해 성능을 향상시키려는 시도는 \"피닝\"과 관련하여 예상치 못한 제약으로 인해 속도가 느려지는 문제가 발생했습니다. 결과적으로, 우리는 다시 플랫폼 스레드를 사용하도록 돌아갔습니다.\n\n지금은 성능을 개선하기 위한 대안 전략을 탐색하면서 버전 9.0.0의 릴리스를 기다리고 있습니다. 이는 새로운 기술을 도입하는 데 따르는 도전을 강조하며, 실행 전 철저한 테스트의 중요성을 강조합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png"},"coverImage":"/assets/img/2024-06-19-WhyaremyJavavirtualthreadsslowerthantheplatformthreads_0.png","tag":["Tech"],"readingTime":9},{"title":"자바 프로그래밍 Java 21의 주요 기능을 깊이 탐구해 보기","description":"","date":"2024-06-19 21:50","slug":"2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures","content":"\n## 자바의 계속되는 중요성: 언어 진화에 대한 깊은 이해\n\n![image](/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_0.png)\n\n나는 예전에는 자바의 팬이 아니었지만, 최근 몇 년 동안 더 많이 귀하와 자바 언어와 생태계를 귀하했습니다. 특히 새 개인 프로젝트에 자바 21을 사용하기로 결정한 후 더욱 그랬습니다. JVM의 세계로 소개되는 것은 스칼라로 시작했는데, 이는 객체 지향과 함수형 프로그래밍 개념을 조화롭게 결합한 간결한 언어로서 타입 안전성에 중점을 둔 것이 특징입니다.\n\n그렇다면, 왜 스칼라를 사용하지 않았을까요? 자바를 선택한 이유 중 일부는 언어에 대한 새로운 흥미로운 개선 사항이 있었기 때문이며, 자바의 현재 상태인 생태계, 프레임워크 및 라이브러리를 좀 더 탐색하고 싶었기도 했습니다. JVM 플랫폼을 대상으로 한 다른 최신 언어들은 많지만, 그 중에서도 스칼라와 코틀린이 가장 많은 관심을 받은 것은 자바와 마찬가지로 강력하고 정적으로 타이핑된 프로그래밍 언어입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 자바 대 스칼라 대 코틀린 비교\n\n스칼라와 코틀린 중에서는 코틀린이 자바 경험이 있는 개발자들에게 더 익숙한 문법을 갖고 있으며, 자바와 완전히 상호 운용 가능하면서 자바의 일부 문제점을 해결하기 위해 고안된 더 현대적이고 간결한 언어로 주목받고 있습니다. 현재는 안드로이드 개발 공간에서 코틀린이 더 인기가 있습니다.\n\n한편, 스칼라는 데이터 엔지니어링 (아파치 스파크 등) 및 백엔드 응용 프로그램 개발에서 주로 인기를 누리고 있습니다. 스칼라는 덜 번잡한 문법을 갖고 있으며, 어떤 사람들은 특히 Scala3에 대해 파이썬의 스트레로이드 버전으로 비교할 수 있습니다. 더 견고한 타입 시스템을 갖추고 있어 컴파일 시간에 더 많은 오류를 제거하는 데 도움이 되는 특징이 있습니다.\n\n## 개발자들은 자바를 높게 평가합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스칼라, 코틀린 및 자바의 채택 및 인기에 대해 알아보겠습니다. 스택 오버플로 조사 및 TIOBE 그리고 Redmonk 언어 인기 지수를 살펴볼 예정입니다.\n\n다음은 스택 오버플로 결과를 기반으로 한 인기 언어 차트입니다. 여기서는 세 언어만을 선택하여 살펴보겠습니다.\n\n![이미지](/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_1.png)\n\n## Redmonk 언어 지수\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2023년 1월 현재 Redmonk 지수를 확인해보세요. 이 지수는 Github와 Stack Overflow 데이터를 기반으로 합니다. Java가 상위에 랭크되어 있고 Scala와 Kotlin도 비교적 높은 순위를 차지하고 있네요.\n\n![이미지](/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_2.png)\n\n## TIOBE 프로그래밍 지수\n\n이제 TIOBE 지수를 살펴보겠습니다. 이 지수는 25개 다른 검색 엔진에서의 검색어를 고려합니다. Java 또한 상위 언어 중 하나로 랭크되어 있습니다. Scala와 Kotlin은 상위 10위 안에 들지 못해서 차트에 표시되지 않았지만, 2023년 기준 Scala는 15위, Kotlin은 36위에 랭크되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Java Programming](/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_3.png)\n\nJava는 여전히 Kotlin 및 Scala와의 강력한 경쟁 속에서 매우 인기 있는 것을 볼 수 있습니다. 몇 년 동안 약간의 감소가 있었지만, 다른 프로그래밍 언어 및 생태계 (예: Python, Go, Rust)에 의해 조각이 빼앗겼습니다.\n\n# Java 탐험: 역호환성에 대한 헌신\n\nJava가 최근 몇 년간 무엇을 해 왔는지 및 강한 인기에 기여하는 다른 요소들을 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 인기는 Java의 DNA와 관련이 있습니다. Java의 DNA에는 강력한 하위 호환성을 유지하기로 한 의무가 포함되어 있습니다. 최근 몇 년간 투입적인 하위 호환성 파괴가 몇 차례 있었지만 이는 언어와 도구의 개선을 지원하기 위한 것입니다. 그러나 이러한 변경에 대해 평소보다 많은 고려와 타당한 이유가 있습니다. 이것이 Java가 기업 환경에서 인기를 얻는 큰 이유 중 하나입니다. JVM 플랫폼의 안정성이 더 많은 엔지니어가 생산적이며 비즈니스 문제 해결과 코드 출시에 집중할 수 있도록 해줍니다.\n\n## 고려할 Java 관련 요소\n\nJava 9부터 OpenJDK는 \"준비되었을 때 출시\"에서 6개월 주기로 변경되었습니다 - 3월과 9월에 각각 출시됩니다. 이 목표는 새로운 버전의 제공이 일부 향상이 준비되지 않아서 발생하는 지연을 완화하기 위한 것이었습니다. 이 작업을 수행하기 위해 미리보기 기능이라는 개념이 도입되었습니다. 특정 기능이 완전히 기능하나 여전히 파괴적인 변경의 영향을 받을 때, 해당 기능은 다음 버전에서 미리보기로 도입됩니다.\n\n이를 통해 개발자 커뮤니티가 피드백을 제공하고 다음 정기 릴리스에 최종화될 구현을 형성하는 데 도움을 줄 수 있습니다. 몇 년에 한 번씩 Oracle은 LTS (장기 지원 릴리스) 릴리스로 태깅된 다음 다른 JDK 공급 업체도 따를 것입니다. 예를 들어, Amazon Web Services는 Corretto JDK라는 자체 JDK 빌드를 유지하며 이에 대해 AWS가 장기적인 지원을 제공할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_4.png\" /\u003e\n\nJava의 또 다른 핵심인 마지막 이동자 장점에 대해 이야기해봅시다. 스칼라와 같은 다른 JVM 언어들은 상당히 빠른 속도로 진화합니다. 저는 여전히 스칼라를 사용하며 즐기고 있지만 그 역사적인 호환성 및 도구 이야기는 많이 부족한 것 같습니다 (하지만 계속 발전 중입니다!). 한편, 스칼라는 언어와 컴파일러 디자인을 새로운 수준으로 밀어올리는 최신 기술을 제공하고 있습니다.\n\n그러나 Java는 장기 게임을 펼치며, 산업이 어떻게 발전하는지 관찰하고, 다른 언어들이 무엇을 하고 있는지 평가하며, 잘 작동하는 부분을 골라내고 가장 유의미한 곳에서 언어를 개선합니다. Java 8 이후에 적용된 몇 가지 언어 개선 사항을 간략히 살펴보겠습니다.\n\n# Java 10의 'var' 키워드가 언어의 불필요한 길이에 미치는 영향\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 최신 언어에 이미 숙달된 개발자들이 Java를 배우고 있는 경우, 가장 싫어하는 점을 물어보면, 말이 많다는 것이 상위권에 오릅니다. Java 10이 출시되기 전까지는 할당의 왼쪽에 변수 유형을 명시적으로 선언해야 했습니다. Java 10에서는 실제 유형 대신 사용할 수 있는 새로운 특별한 \"var\" 키워드가 도입되었습니다. 컴파일 단계에서 Java 컴파일러가 할당의 오른쪽 표현식에서 추론된 실제 유형을 삽입할 것입니다.\n\n```js\n//Java 8\nHashMap map = new HashMap();\n\nDatabaseEngineColumnCacheImpl cache = new DatabaseEngineColumnCacheImpl();\n\nOptional accessRole = user.getUserAccessRole();\n\n//Java 10, 컴파일러에게 더 이상 실제 유형이 무엇인지 설득할 필요 없음\nvar map = new HashMap();\n\nvar cache = new DatabaseEngineColumnCacheImpl();\n\nvar accessRole = user.getUserAccessRole();\n```\n\n위는 몇 가지 중요치 않은 예제입니다. 그러나 이것은 코드를 읽을 때 말을 줄일 수 있습니다. 그러나 이것은 산업에서 새로운 것이 아닙니다. 다른 최신 정적 형식 프로그래밍 언어의 개발자들은 오랫동안 형식 추론을 즐겼습니다.\n\n예를 들어, Scala는 2004년에 처음 만들어진 이후부터 더 진보된 형식 추론을 가지고 있습니다. 그럼에도 불구하고, 이것은 Java에서 매우 환영받는 기능입니다. 형식 추론은 로컬 변수 선언에만 제한되는데, 즉 메소드 본문에서, 실제로 그것이 가장 중요한 곳입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## instanceof와 패턴 매칭으로 타입 체크 과제 극복하기\n\ninstanceof는 주어진 객체가 특정 타입인지 확인하기 위해 사용되는 언어 키워드입니다. 예를 들어, Object 타입의 객체가 주어졌을 때, 이 객체가 무엇인지 런타임에 실제 타입을 확인하여 해당 객체 타입에 특정한 작업을 실행해야 할 수 있습니다.\n\n다소 극단적으로 보일 수 있는 예제가 있습니다. Shape 인터페이스와 특정 모양을 나타내는 여러 클래스가 있다고 가정해 봅시다. 코드의 어딘가에서 모양의 둘레에 관한 정보를 얻고 싶을 때, 각 하위 클래스가 구현해야 하는 둘레 계산 메서드가 인터페이스에 명시되어 있지 않고 이 코드를 리팩토링할 수 없다고 가정해 봅시다.\n\n이 경우 해결책은 한 가지뿐입니다: 사각형 또는 원인지 확인하고 그에 따라 둘레를 계산하는 유틸리티 메서드를 구현하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n인터페이스 모양 {}\n\npublic class Rectangle implements Shape {\n    final double length;\n    final double width;\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n    }\n}\n\npublic class Circle implements Shape {\n    final double radius;\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n}\n\npublic static double getPerimeter(Shape shape) {\n    if (shape instanceof Rectangle) {\n        Rectangle r = (Rectangle) shape;\n        return 2 * r.length + 2 * r.width;\n    } else if (shape instanceof Circle) {\n        Circle c = (Circle) shape;\n        return 2 * c.radius * Math.PI;\n    } else {\n        throw new RuntimeException(\"Unknown shape\");\n    }\n}\n```\n\ngetPerimeter 메서드 구현을 살펴보면, 이미 타입을 확인했음에도 불구하고 여전히 다운캐스팅하고 연산을 수행하기 전에 새 변수를 선언해야 합니다. 이는 컴파일러가 여전히 shape를 Shape의 인스턴스로 보기 때문입니다.\n\ninstanceof의 패턴 매칭을 사용하면 if-else 블록의 범위 내에서 확인한 타입의 변수를 선언할 수 있습니다. Java 14에서 동일한 if-else 블록은 다음과 같이 보일 것입니다.\n\n```js\n  public static double getPerimeter(Shape shape) {\n    if (shape instanceof Rectangle r) {\n        return 2 * r.length + 2 * r.width;\n    } else if (shape instanceof Circle c) {\n        return 2 * c.radius * Math.PI;\n    } else {\n        throw new RuntimeException(\"Unknown shape\");\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 컴파일러의 좋은 개선이에요. 점점 똑똑해지고 더 나아졌어요. instanceof를 위한 패턴 매칭은 자바의 나중 버전에서 계속 확장되었던 큰 노력이었고, 레코드 클래스에 대한 패턴 매칭도 포함되었는데, 다음으로 다루고 싶은 큰 기능입니다.\n\n# 장황함에서 간결함으로, Java의 레코드가 데이터 클래스를 재정의해요\n\n이 부분은 꽤 중요해요, 적어도 제게는요. Scala가 데이터 클래스를 사용해서 모델링하는 것이 얼마나 쉬운지 정말 좋아해요. Java는 도메인 모델링에 능숙하다는 것으로 유명하지만, 레코드가 도입되기 전에 데이터 컨테이너나 POJO를 정의하는 과정이 매우 장황했었고, 이에 따라 반복적인 코드를 직접 작성하기보다는 코드 생성을 수행하는 다양한 라이브러리가 생겼죠 (예: 롬복).\n\n## 다음 예시를 살펴보죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class Person {\n    public final String id;\n    public final String name;\n    public final Integer age;\n\n    public Person(String id, String name, Integer age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n}\n\nvar p1 = new Person(\"a1b\", \"Frank\", 30)\nvar p2 = new Person(\"a1b\", \"Frank\", 30)\n\np1.equals(p2) // false, oops?\n```\n\n우선, 다른 고수준 프로그래밍 언어와 비교하면 이것은 이미 간단한 데이터 클래스를 정의한 매우 억양있는 문법이라고 볼 수 있습니다. 더구나, 이와 같은 방식으로 데이터를 모델링하고 싶을 때는 객체를 내용에 기반하여 비교할 수 있으면 좋겠지만, 이 예시에서는 (Java에 처음 접하는 경우) p1과 p2가 동일하다고 가정할 수 있겠지만 실제로는 그렇지 않습니다.\n\n이것은 Java에서 객체가 메모리의 참조이기 때문에 명시적으로 컴파일러에게 객체를 어떻게 동일한지 알려주지 않으면, equals()의 기본 전략은 메모리 주소를 비교하는 것입니다. 이것이 정확히 == 연산자가 하는 일입니다. 그렇다면, 우리의 Person 객체를 동일한 유형의 다른 인스턴스와 비교할 수 있게 하려면 어떻게 해야 할까요?\n\n```java\npublic class Person {\n    public final String id;\n    public final String name;\n    public final Integer age;\n\n    public Person(String id, String name, Integer age) {\n      this.id = id;\n      this.name = name;\n      this.age = age;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (o == this) return true;\n      if (o == null || !(o instanceof Person)) return false;\n\n      Person p = (Person) o;\n      return Objects.equals(p.id, this.id) \u0026\u0026 Objects.equals(p.age, this.age) \u0026\u0026 Objects.equals(p.name, this.name);\n    }\n\n    @Override\n    public int hashCode() {\n      int hash = 7;\n      hash = 31 * hash + Objects.hashCode(id);\n      hash = 31 * hash + Objects.hashCode(name);\n      hash = 31 * hash + age;\n      return hash;\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n할 일이 상당히 많다는 것을 알게 되었네요. 객체를 비교하는 규칙을 정의하기 위해 equals 및 hashCode를 override해야 합니다. 롬복(Lombok)과 같은 라이브러리는 이러한 메서드를 생성해주므로 직접 작성하지 않아도 됩니다. 그러나 이제 Java에는 이를 고유하게 처리할 수 있는 방법이 있습니다.\n\nRecords가 등장합니다. Java 17부터(14부터 미리보기로 제공) record 키워드를 사용하여 클래스를 정의하는 새로운 방법이 있습니다. 이전 예제를 바탕으로 Records로 어떻게 개선할 수 있는지 살펴봅시다.\n\n```js\nrecord Person(String id, String name, Integer age) {};\n\nvar p1 = new Person(\"1ab\", \"Frank\", 30);\nvar p2 = new Person(\"1ab\", \"Frank\", 30);\n\np1.equals(p2); //true, 맞아요!\n\np1 == p2; //false, 여전히 두 개의 다른 인스턴스이기 때문에 예상대로입니다\n```\n\n## Java records의 'with' 탐색하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Java 컴파일러는 우리를 위해 bytecode를 즐겁게 생성해 줍니다. equals와 hashCode 메서드를 구현하기 위해 정의된 모든 매개변수를 고려합니다. 레코드 클래스는 toString 및 getter 메서드를 제공하지만 setter는 제공하지 않습니다. 레코드 클래스는 변경할 수 없도록 설계되어 있어 한 번 인스턴스가 생성되면 객체 멤버들을 읽기만 가능하고 값을 변경할 수 없습니다.\n\n변하지 않음으로써, 동시성 프로그램의 버그를 줄이고 코드를 이해하기 쉽게 만들어줍니다. 현재 업데이트된 인스턴스를 만드는 것은 약간 번거로운 일이며, 다른 레코드로부터 모든 인수를 복사해야 한다는 것이 필요하지만 Brian Goetz 자신이 프로젝트 Amber의 일부인 \"With for records\"라는 새로운 기능을 통해 나중에 이 부분이 바뀔 것이라고 희망합니다. — Java 언어 설계자인 Brian Goetz의 Amber 프로젝트의 일부인 초안 중에 설명되어 있습니다. 결국 기존 레코드 객체의 한 명 이상의 멤버를 수정하여 새로운 인스턴스를 생성할 수 있는 기능이 추가될 것입니다. 예를 들어:\n\n```js\n var p3 = p2 with { name = \"Joe\" };\n```\n\n이미 이를 해결하기 위해 도움이 되는 몇 가지 라이브러리가 있습니다. record-builder라는 이 github 프로젝트를 살펴볼 수 있습니다. 레코드 객체를 수정하는 제한사항을 해결하는 것 외에도 더 복잡한 데이터 클래스에 매우 유용한 빌더를 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바 레코드에는 이 예시가 보여주는 것 이상의 기능이 있습니다. 레코드의 다른 기능은 사용자 정의 생성자 정의 능력이 있고 기본 데이터에 작용할 수 있는 일반적인 메소드를 정의할 수 있는 것입니다. 또한 레코드의 직렬화는 변경 불가능성에 의해 일반 클래스의 인스턴스의 직렬화보다 간단하고 안전합니다. 레코드는 또한 값을 분해하여 사용할 수 있으며, 다음 기능, 레코드용 패턴 매칭에 활용되는 것입니다.\n\n# 레코드용 패턴 매칭\n\n레코드용 패턴 매칭은 자바 21에서 최종화되었습니다. 프로젝트 Amber의 일부로 제공되는 패턴 매칭과 레코드는 새로운 프로그래밍 패러다임인 데이터 지향 프로그래밍을 가능케 합니다. DOP(Data Oriented Programming)은 문제를 변경할 수 없는 데이터 구조로 모델링하고 변경되지 않는 일반적인 목적 함수를 사용하여 계산을 수행하는 것을 강조합니다. 이미 들어보신 것 같네요. 그렇습니다, 함수형 프로그래밍에서 잘 알려진 개념입니다! DOP 패러다임을 촉진하는 기능의 도입은 OOP를 대체하려는 것이 아니라, 특정 작업을 더 우아하게 해결하는 데 도움을 주기 위한 것입니다. OOP는 대규모 코드 경계를 정의하고 지배하는 데 훌륭하지만, DOP는 데이터를 모델링하고 작업하는 데 더 유용합니다.\n\n이게 전부가 아닌 걸로 갑시다. 패턴 매칭이란 무엇인가요? 클래스 생성자의 반대로 생각할 수 있습니다. 클래스 생성자는 데이터를 제공하여 객체를 생성할 수 있게 해주는 반면, 패턴 매칭은 객체 생성에 사용된 데이터를 분해하거나 추출할 수 있게 해줍니다. 실제로 이것이 어떻게 보이는지 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 패턴 매칭 예제\n\n이 예제에서는 레코드 클래스를 사용하여 서로 다른 트랜잭션 유형을 모델링하고, 목표는 트랜잭션 목록을 사용하여 계정 잔액을 계산하는 메서드를 작성하는 것입니다. 구매 유형인 경우 잔액을 증가시키고, 지불 유형인 경우 잔액을 감소시키며, 지불 취소된 경우에는 다시 잔액을 증가시키어야 합니다.\n\n```js\n public interface Transaction {\n    String id();\n}\n\nrecord Purchase(String id, Integer purchaseAmount) implements Transaction {}\n\nrecord Payment(String id, Integer paymentAmount) implements Transaction {}\n\nrecord PaymentReturned(String id, Integer paymentAmount, String reason) implements Transaction {}\n\nList transactions = List.of(\n    new Purchase(\"1\", 1000),\n    new Purchase(\"2\", 500),\n    new Purchase(\"3\", 700),\n    new Payment(\"1\", 1500),\n    new PaymentReturned(\"1\", 1500, \"NSF\")\n);\n```\n\n만약 우리가 트랜잭션을 정의하는 코드베이스에 액세스할 수 없거나, 이 코드 부분이 잔액을 계산하는 책임을 지지 않아야한다고 가정해 봅시다. 우리 코드에서 calculateAccountBalance를 구현하는 한 가지 방법은 다음과 같습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic static Integer calculateAccountBalance(List transactions) {\n  var accountBalance = 0;\n  for (Transaction t : transactions) {\n    if (t instanceof Purchase p) {\n      accountBalance += p.purchaseAmount();\n    } else if (t instanceof Payment p) {\n      accountBalance -= p.paymentAmount();\n    } else if (t instanceof PaymentReturned p) {\n      accountBalance += p.paymentAmount();\n    } else {\n      throw new RuntimeException(\"Unknown transaction type\");\n    }\n  }\n  return accountBalance;\n}\n```\n\n이 구현은 나쁘지 않습니다. 상당히 가독성이 높고, 처리해야 하는 거래 유형이 더 많아지면 다소 길어질 수 있습니다. 레코드용 패턴 매칭은 다음과 같은 구현을 향상시킵니다.\n\n```java\npublic static Integer calculateAccountBalance(List transactions) {\n  var accountBalance = 0;\n  for (Transaction t: transactions) {\n    switch(t) {\n      case Purchase p -\u003e accountBalance += p.purchaseAmount();\n      case Payment(var id, var amt) -\u003e accountBalance -= amt;\n      case PaymentReturned(var id, var amt, var reason) -\u003e accountBalance += amt;\n      default -\u003e throw new RuntimeException(\"Unknown transaction type\");\n    }\n  }\n  return accountBalance;\n}\n```\n\n이 코드는 조금 더 깔끔하고 장황하지 않게 보입니다. switch 키워드에 주목하세요. Java에는 오랫동안 사용 가능했습니다. Java 17에서 switch는 람다와 익숙한 문법을 지원하는 표현식을 지원하도록 했고, Java 19 및 21에서는 switch가 레코드에 대한 패턴 매칭을 지원하도록 더욱 향상되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPattern matching을 사용할 때에는 첫 번째 경우에 나타난 것처럼 타입의 인스턴스를 참조하거나 두 번째와 세 번째 경우처럼 타입을 그 구성 요소로 분해할 수 있습니다. switch에 대한 패턴 매칭은 또한 새로운 when 키워드를 사용하여 부울 표현식에 따라 패턴을 일치시키는 것을 가능하게 합니다. 예를 들어, 동일한 타입을 여러 번 다른 조건으로 일치시키고 각 경우마다 다른 로직을 실행할 수 있습니다.\n\n만약 여전히 패턴 매칭의 유용성에 확신이 없다면, 한 가지 더 있습니다. 어느 시점 후에 새로운 거래 유형을 도입했다고 가정해봅시다. Reversed purchase transactions을 모델링하기 위해 Credit이라고 부르는 새로운 거래 유형을 도입했다고 가정해봅시다. Transaction을 구현하는 새 레코드 타입을 추가함으로써 우리의 코드는 두 구현 모두에서 컴파일될 것입니다. 우리는 해당 타입을 처리할 수 없다는 문제를 런타임에서 만나게 되어 예외가 발생할 때까지 이를 발견하게 될 것입니다.\n\n레코드에 대한 패턴 매칭의 사용 편의성은 Java 17에 다시 도입된 다른 언어 기능, sealed classes and interfaces ( JEP409)에 의해 더욱 개선되었습니다. 인터페이스를 sealed로 표시하면 Compiler에게 Transaction에 대한 구현이 한정적이라는 정보를 제공하므로, Compiler가 패턴 매칭에서 모든 경우가 처리되었는지를 확인할 수 있습니다. 구현 클래스는 sealed 인터페이스와 동일한 파일에 위치시키거나 인터페이스에서 permit 키워드를 사용하여 닫힌 유형 계층 구조를 지정할 수 있습니다(자세한 내용은 JEP를 참조하십시오).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 우리의 코드는 모든 경우를 처리하지 못했을 때 컴파일되지 않을 것입니다. 그러나 이를 보장하려면 보통 빠뜨릴 수 있는 부분을 처리하는 기본 케이스를 제거해야 합니다.\n\n```js\n public sealed interface Transaction {\n    String id();\n\n    // define in here records extending interface\n}\n\n\npublic static Integer calculateAccountBalance(List transactions) {\n  var accountBalance = 0;\n\n  for (Transaction t: transactions) {\n    switch(t) {\n      case Purchase p -\u003e accountBalance += p.purchaseAmount();\n      case Payment(var id, var amt) -\u003e accountBalance -= amt;\n      case PaymentReturned(var id, var amt, var reason) -\u003e accountBalance += amt;\n    }\n  }\n\n  return accountBalance;\n}\n```\n\n이제 컴파일러는 다음과 같은 친절한 오류 메시지로 중단할 것입니다 — \"컴파일 실패: switch 문이 모든 가능한 값을 다 다루지 않았습니다\".\n\n인터페이스에 sealed 키워드를 사용하는 것은 초기 구현시 if-else 블록을 사용하는 것만큼 유용하지 않았습니다. 따라서 여기서는 패턴 매칭이 더 유리합니다. 이 글에서 다루지 않은 sealed 인터페이스/클래스에는 더 많은 내용이 있지만, 언어의 여러 기능이 잘 결합되어 코드의 견고성을 향상시키는 방법을 보여주는 예 중 하나입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금 설명한 문제를 해결하기 위해 방문자 디자인 패턴을 사용할 수 있다는 사실을 언급할 가치가 있습니다. 그러나 이 패턴은 상당히 더 많은 복잡성과 코드 양을 도입합니다. Java 21은 봉인된 인터페이스와 패턴 매칭이 도입된 Java 17 이후의 기능을 더해 출시된 기능이 많은 버전입니다. 대규모 기업에서는 일반적으로 LTS 버전만 사용을 허용하므로 Java 21이 다음 LTS 릴리스로 선정된 것은 훌륭한 소식입니다.\n\n이 게시물에서 언급하지 않은 많은 흥미로운 새로운 기능들이 있습니다. Virtual Threads인 프로젝트 룸은 아마도 Java 21에서 마무리된 가장 기대되는 기능일 것이지만, 이는 별도의 블로그 게시물이 필요한 큰 주제이기 때문에 다루기 어렵습니다. OpenJDK 웹사이트에서 최근 JDK 21 릴리스에 대해 더 많은 정보를 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바는 안정적이고 책임감 있는 방식으로 발전하는 경향이 있습니다. 소프트웨어 업계가 어떻게 변화하는지와 언어 기능을 유지하기 위해 필요한 기능을 주의 깊게 관찰하면서, 기능을 신중하게 구현하고 역호환성을 보장합니다.\n\n버전 21에서 자바는 사용하기 즐거운 언어이며, 이는 자바를 산업에 더 오랜 기간 동안 강하게 뿌리내릴 수 있는 또 다른 중요한 이정표입니다.\n\nCapital One의 소프트웨어 엔지니어링에 대해 더 알아보세요.\n\n원문은 https://www.capitalone.com에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작성자: 마신 코사코프스키, 선임 소프트웨어 엔지니어. 마신은 스몰 비즈니스 카드에서 새로운 카드 제품을 만드는 데 도움을 주는 선임 소프트웨어 엔지니어입니다. 데이터 엔지니어링, 분산 및 이벤트 기반 시스템에 열정을 갖고 있습니다. 여가 시간에는 하이킹과 마운틴 바이크를 즐깁니다.\n\n공개 성명: © 2024 Capital One. 의견은 해당 개인 작성자의 것입니다. 이 게시물에서 별도로 언급되지 않는 한, Capital One은 언급된 회사들과 제휴하거나 보증하고 있지 않습니다. 사용되거나 표시된 모든 상표 및 기타 지적 재산은 각 소유자의 재산입니다. Capital One은 링크된 제 3자 사이트의 콘텐츠나 개인 정보 취급 방침에 대해 책임지지 않습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_0.png"},"coverImage":"/assets/img/2024-06-19-JavaprogrammingAdeepdiveintoJava21skeyfeatures_0.png","tag":["Tech"],"readingTime":21},{"title":"포기하지 않고 노력하시는 자바 프로그래머를 위해 단순하게 설명하는 방식으로, 겸손한 동기화가 ReentrantLock을 이기는 방법","description":"","date":"2024-06-19 21:49","slug":"2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer","content":"\n2009년에는 독일 철도 기업 직원 교대 관리를 위해 중요한 미션이었고, Java 1.5를 사용하기로 선택했습니다. 제네릭스가 도입되었고, 병행성 유틸리티들이 등장했습니다. 기본적으로 ReentrantLock을 사용하여 다중 스레드 시나리오를 관리하기 시작했습니다. 철도 회사는 여러 사용자가 동시에 데이터에 액세스해야 하는 필요가 있었는데, 예를 들어 여러 사무원이 기차 노선의 일부에 (기관사, 안내원, 요리사, 서빙원) 업무를 할당하려고 했습니다. 실제로 오래된 synchronized 키워드는 폐기되었다고 여겨졌습니다. 하지만 실제로는 그렇지 않았습니다. 그리고 결과적으로 대부분의 상황에서 synchronized가 새롭고 반짝거리는 ReentrantLock보다 우수하다는 것이 밝혀졌습니다.😊\n\n기술적인 세부 사항 대부분은 참고문헌에 남겨두었습니다. 솔직히 말해서 우리는 그 복잡한 것들을 알 필요가 없습니다. 누구도 면접에서 묻지 않을 것이기 때문입니다.\n\n본문의 목적은 대규모 분산 시스템의 하수구에서 작업하고 있는 Java 프로그래머에게 곧바로 `관련된` 정보를 전달하고 진지한 압박 속에서 기술을 자랑하는 기회를 갖겠다는 것입니다.\n\n## 대부분의 상황에서 synchronized가 ReentrantLock보다 우수합니다 😊\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCopyOnWriteArrayList에서 코드를 인용합니다. Java 1.6부터 대부분의 API 개발자들이 ReentrantLock을 사용하기 시작했는데, 이를 사용하는 것이 새롭고 멋진 것으로 여겨졌기 때문입니다. 그러나 Java 1.9에서는 synchronized로 다시 되돌아가기 시작했습니다 (ReentrantLock에서 synchronized로 다시 되돌아감 참조). 이는 synchronized 작동 방식에 대한 이해 부족 및 Doug Lee와 같은 Java Guru들이 자신을 적용하지 않았다는 점을 반영합니다. ReentrantLock 작동 방식에 대해 설명할 것입니다. 이 글에서 lock 객체 및 synchronized를 사용한 코드와 'lock'에 대한 간결한 설명이 있는 Java 21 버전을 살펴보십시오.\n\n이제 위대한 Doug Lee가 회개했고, synchronized와 ReentrantLock 사이의 장단점이 비슷하다면 synchronized를 기본값으로 사용한다고 말합니다.\n\n하지만 문제는, 왜 고대의 synchronized가 어떤 상황에서 새롭고 멋진 ReentrantLock보다 우수한 것인가입니다?!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n짧은 답변: synchronized는 JVM이 관리하는 객체로, JVM은 이를 통해 락 상승 및 감소와 같은 다양한 기능을 동적으로 처리할 수 있습니다. 반면 ReentrantLock은 비교 및 설정을 사용하는 일반적인 자바 코드에 갇혀 있습니다. synchronized 키워드를 사용할 때, JVM은 biased lock(더 이상 사용되지 않음), thin lock 또는 fat lock을 사용할지 여부를 결정합니다. 이 세 가지에 대해 알아봅시다.\n\n락 상승\n\nJVM은 얼마나 많은 경합이 있는지에 대한 정보를 수집합니다. 스레드가 biased lock(해당 스레드만 관심을 가짐)을 가지고 있고 두 번째 스레드가 오면, 락이 thin lock으로 상승됩니다. 그러나 더 많은 수의 스레드가 오는 경우, 바로 fat lock으로 상승될 수 있습니다. thin lock도 마찬가지입니다. thin lock은 루프에서 회전하면서 CPU를 소비합니다. 어느 시점에서 경합이 높아지면 락이 fat lock으로 상승됩니다. 마찬가지로, 락이 감소될 수도 있습니다.\n\n## Biased Lock\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'Synchronize' 메서드를 사용하여 여러 스레드가 공유 자원을 안전하게 사용할 수 있습니다. 이 메서드를 사용하면 잠금 객체의 머리글에 스레드 ID가 저장되어 공유 자원에 대한 액세스가 제어됩니다. 아래 이미지에서 여러 사용자(스레드)가 동일한 전화 부스를 사용하려고 하지만 한 번에 하나의 사용자만 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_0.png)\n\n이 접근법은 매우 빠릅니다. 같은 스레드가 동일한 잠금을 호출할 때마다 간단하게 다음과 같이 작동합니다:\n\n```js\nif (threadId == notedThreadId) {\n  // 계속 진행\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바15부터 Biased Locks는 사용되지 않으며 현재는 아마도 제거되었습니다. 자바 ≤ 1.3 시대에는 Java 컬렉션이 동기화되어 있었기 때문에 유용했습니다: Vector, Hashtable. 그러나 대부분 단일 스레드로 사용됩니다. 동기화되지 않은 java.util ArrayList, HashSet, HashMap 등을 사용하면 됩니다. 이러한 컬렉션은 엄격히 단일 스레드 안전하며 biased lock는 JVM에서 코딩하고 유지하는 비용이 아마도 그 가치가 없을 것입니다.\n\n## Thin Lock\n\n이미 biased lock로 보호된 lock을 얻으려는 두 번째 스레드가 있을 때, 두 스레드 모두에 대한 lock은 thin lock으로 승격되고, 첫 번째 스레드가 lock의 소유자가 됩니다. 반대로, 경합이 심한 경우 biased lock에서 fat lock으로 승격될 수 있습니다.\n\n현재 biased lock가 사용되지 않으므로 스레드가 lock을 획들하려고 하면 직접 thin lock을 먼저 사용하게 됩니다. Thin lock은 비교적 무거운 작업입니다. 비교 및 설정이 필요합니다. 그러나 CAS는 여전히 CPU 명령어이며 시스템 호출이 아닙니다. 시스템 호출은 비용이 많이 듭니다. 여기에 비교 및 설정을 사용하여 thin lock을 획들하는 의사 코드 예시가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class Person {\n\n    private AtomicBoolean locked = new AtomicBoolean(false);\n    private int id;\n    private String name;\n\n    public Person(int id, String name){\n        this.id = id;\n        this.name = name;\n    }\n\n    public String getDetailsAsString(){\n        while(!locked.compareAndSet(false, true)); // tricky tricky\n        try {\n          return this.id + \", \" + this.name;\n        } finally {\n          locked.set(false);\n        }\n    }\n}\n```\n\n얇은 락은 비교 및 설정을 사용합니다. 조금 까다로운 면이 있어 이해하기 어려울 수 있습니다. 그러나 이는 바쁜 락입니다. 락을 빨리 얻기를 희망하며 CPU를 일정 시간 동안 소비합니다. 상황에 따라 바쁜/스핀 락은 좋을 수도 있습니다. 왜냐하면 쓰레드를 코어에서 제거하고 다른 쓰레드를 코어에 올리는 데 시간이 소요되기 때문입니다.\n\n![이미지](/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_1.png)\n\n## 두꺼운 락\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFat Lock은 OS 뮤텍스를 사용합니다. 이것은 시스템 콜을 의미합니다. Thin Lock은 CAS만 사용합니다. 즉, 하드웨어 명령어입니다. 시스템 콜이 연관되지 않습니다. 이는 CPU 상태 변경이 필요하지 않음을 의미합니다. 프로그램 카운터, 베이스 포인터, 레지스터 등이 그것입니다. 하지만 Fat Lock은 시스템 콜이고, 시스템 콜은 비용이 많이 듭니다. 하지만 이해할 필요는 없습니다. 왜냐하면 우리는 애플리케이션 개발자이고 JVM C++ 프로그래머는 아니기 때문입니다.\n\nFat Lock은 스레드를 스레드의 대기 링크드 리스트에 넣습니다. OS는 이 목록에서 스케줄링합니다. 따라서 이는 바쁜 스핀이 없고 CPU 소모가 없음을 의미합니다. 스레드는 즉시 CPU를 해제합니다.\n\n![image](/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_2.png)\n\n## 그래서 Intrinsic (synchronized) Locking이 대부분에서 ReentrantLock을 능가할 수 있는 이유는 무엇일까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내재 락은런타임에서 계산된 경합에 따라 동적으로 thin lock 또는 fat lock을 수행하거나 스케일을 조절하거나 해제할 수 있습니다. 반면 재진입 락은 그렇지 못합니다. 이는 내재 락이 JVM 객체이기 때문입니다. 재진입 락은 그냥 일반적인 자바 코드에 불과합니다. 이것을 열어서 그 소스 코드를 읽을 수 있습니다.\n\n## 내재 및 재진입 락을 언제 사용해야 하는가\n\n재진입락 사용 시점:\n\n- tryLock, lockInterruptibly, 시간 제한이 있는 tryLock, 락의 공정성과 같은 고급 기능이 필요할 때\n\n내재 락 사용 시점:\n\n- (재)-세상에서 가장 위대한 자바 프로그래머 Doug Lee의 말을 인용하여\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npackage java.util.concurrent;\n\n//@author Doug Lea\npublic class CopyOnWriteArrayList\u003cE\u003e {\n\n    /**\n     * 모든 변경 작업을 보호하는 잠금입니다. (내장 모니터나 ReentrantLock 중 어느 것이든 사용 가능할 때는 builtin 모니터를 약간 선호합니다.)\n     */\n    final transient Object lock = new Object();\n\n    public E set(int index, E element) {\n        synchronized (lock) {\n```\n\n이후\n\n일부 사람들은 Java21 프로젝트 Loom을 통해 JVM이 내포된 잠금보다 ReentrantLock을 사용할 때 더 잘 작동할 수 있다고 의견을 제시합니다.\n\n## 참고문헌:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 유형의 JVM 락\nJVM에서 동기화 최적화에 대한 심층적인 탐구\nJava 동기화 메커니즘의 진화\n","ogImage":{"url":"/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_0.png"},"coverImage":"/assets/img/2024-06-19-HowtheHumbleSynchronizedbeatsReentrantLockSimplifiedforalongsufferingJavaProgrammer_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI에서 여러 개의 경고를 표시하는 방법","description":"","date":"2024-06-19 14:14","slug":"2024-06-19-HowtoshowMultipleAlertsinSwiftUI","content":"\n## SwiftUI에서 여러 경고를 표시하는 것은 조금 까다로울 수 있어요. 이 두 가지 방법을 소개해 드릴게요.\n\n![이미지](/assets/img/2024-06-19-HowtoshowMultipleAlertsinSwiftUI_0.png)\n\nSwiftUI에서 여러 경고를 표시하는 것은 귀찮을 수 있어요. 그러나, 하나의 경고를 표시하는 것은 꽤 간단해요. 먼저 하나의 경고를 표시하는 방법을 알아보죠.\n\n# 단일 경고\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어플리케이션이 있어요. 사용자가 10진수를 입력하면, 해당 입력이 짝수일 경우 경고 메시지가 표시됩니다.\n\n```js\nstruct ContentView: View {\n    @State private var showEvenAlert: Bool = false\n    @State private var num = 2\n\n    var body: some View {\n        VStack {\n             TextField(\"숫자를 입력하세요: \", value: $num, format: .number)\n                .textFieldStyle(.roundedBorder)\n                .frame(maxWidth: 150)\n            Button(\"숫자가 짝수일 때 경고 표시\") {\n                showEvenAlert = num % 2 == 0\n            }\n            .alert(isPresented: $showEvenAlert, content: {\n                Alert(title: Text(\"짝수\"), message: Text(\"\\(num)은(는) 짝수입니다\"), dismissButton: .cancel() )\n            })\n        }\n    }\n}\n```\n\n정상적으로 작동합니다. 사용자가 짝수를 입력하면 경고 메시지가 표시됩니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*uA2Shsj_0WoDUVHLylsHvw.gif\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다중 알림\n\n우리는 숫자가 홀수일 때도 알림을 표시하고 싶어요. 홀수는 외롭게 남겨두고 싶지 않아요. 그러니까 첫 번째 알림 아래에 추가 알림을 넣으면 작동할까요?\n\n```js\nstruct ContentView: View {\n    @State private var showEvenAlert:Bool = false\n    @State private var showOddAlert:Bool = false\n    @State private var num = 2\n\n    var body: some View {\n        VStack {\n            TextField(\"숫자를 입력하세요: \", value: $num, format:.number)\n                .textFieldStyle(.roundedBorder)\n                .frame(maxWidth: 150)\n            Button(\"숫자가 홀수인지 짝수인지 확인\") {\n                showEvenAlert = num % 2 == 0\n                showOddAlert = num % 2 == 1\n            }\n            .alert(isPresented: $showEvenAlert, content: {\n                Alert(title: Text(\"짝수\"), message: Text(\"\\(num)은(는) 짝수입니다\"), dismissButton: .cancel() )\n            })\n            .alert(isPresented: $showOddAlert, content: {\n                Alert(title: Text(\"홀수\"), message: Text(\"\\(num)은(는) 홀수입니다\"), dismissButton: .cancel() )\n            })\n\n        }\n    }\n}\n```\n\n안타깝게도 그 답은 아니에요. 위의 코드는 작동하지 않을 거예요. 홀수에 대한 알림은 표시되지만 짝수에 대한 알림은 나타나지 않을 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*JtKMxr1kTj-vWjPfBfa0bw.gif)\n\n이 무엇이 일어나고 있는지 이해해 봅시다. 뷰의 가장 바깥 쪽 알람만 작동합니다. 그래서 홀수 번째 알람은 작동하지만 짝수 번째는 작동하지 않습니다. 의왕, 컴파일러는 심지어 경고도 표시하지 않습니다. 그렇다면 해결책은 무엇일까요?\n\n# 해결책 1:\n\n한 알람을 여러 뷰에 할당할 수 있습니다. 그래서 단일 뷰에 한 개 이상의 알람이 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct ContentView: View {\n    @State private var showEvenAlert: Bool = false\n    @State private var showOddAlert: Bool = false\n    @State private var num = 2\n\n    var body: some View {\n        VStack {\n            TextField(\"Enter number: \", value: $num, format: .number)\n                .textFieldStyle(RoundedBorderTextFieldStyle())\n                .frame(maxWidth: 150)\n                .alert(isPresented: $showOddAlert) {\n                    Alert(title: Text(\"Odd\"), message: Text(\"\\(num) is odd\"), dismissButton: .cancel())\n                }\n\n            Button(\"Show Alert if number is odd or even\") {\n                showEvenAlert = num % 2 == 0\n                showOddAlert = num % 2 == 1\n            }\n            .alert(isPresented: $showEvenAlert) {\n                Alert(title: Text(\"Even\"), message: Text(\"\\(num) is even\"), dismissButton: .cancel())\n            }\n        }\n    }\n}\n```\n\n이렇게 수정하면 의도한 대로 작동할 것입니다. 하지만, 이 코드가 조금 어수선해 보입니다. 더 많은 알림이 있다면 어떻게 될까요? 코드가 더 어지러워질 것입니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1188/1*QoWoOOrtm-jHFuuIjTYEag.gif\" /\u003e\n\n# 해결책 2:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문제를 해결하는 한 가지 방법은 열거형(enum)을 사용하는 것이에요. 모든 종류의 알림에 대해 하나의 case를 만들고 열거형(enum)의 연관 값(associated value)을 사용하여 알림의 제목과 메시지를 나타낼 수 있어요.\n\n```js\nenum AlertContent {\n    case even(num:Int), odd(num:Int)\n\n    var title:String {\n        switch self {\n        case .even:\n            \"짝수\"\n        case .odd:\n            \"홀수\"\n        }\n    }\n\n    var message:String {\n        switch self {\n        case .even(let num):\n            \"\\(num)은(는) 짝수에요\"\n        case .odd(let num):\n            \"\\(num)은(는) 홀수에요\"\n        }\n    }\n}\n```\n\n이후에 뷰 코드도 훨씬 간단해질 거예요. 더 이상 여러 알림과 바인딩 변수가 필요하지 않아요. 하나의 알림, 하나의 바인딩 변수, 그리고 AlertContent 변수만 있으면 돼요. 알림 콘텐츠의 형식을 변경하고 알림을 표시할 수 있어요.\n\n```js\nstruct ContentView: View {\n    @State private var showAlert:Bool = false\n    @State private var num = 2\n    @State private var alertContent:AlertContent = .even(num: 2)\n\n    var body: some View {\n        VStack {\n            TextField(\"숫자를 입력하세요: \", value: $num, format:.number)\n                .textFieldStyle(.roundedBorder)\n                .frame(maxWidth: 150)\n            Button(\"숫자가 홀수이거나 짝수이면 알림 표시\") {\n                alertContent = (num % 2 == 0) ? .even(num: num) : .odd(num: num)\n                showAlert = true\n            }\n            .alert(isPresented: $showAlert, content: {\n                Alert(title: Text(alertContent.title), message: Text(alertContent.message), dismissButton: .cancel() )\n            })\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 화면에 필요한 경고를 여러 개 보여야 할 때도 하나의 경고창으로 처리할 수 있습니다. 더 많은 경고를 위해 enum 케이스를 더 추가해야 할 뿐입니다. 이상적으로는 버튼 누름 로직은 다른 곳으로 이동하여, 필요한 경고의 수에 관계없이 뷰가 변하지 않습니다. GitHub에서 해당 프로젝트를 확인할 수 있습니다.\n\n# 함께 소통해요!\n\n- LinkedIn\n- Twitter\n- GitHub\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoshowMultipleAlertsinSwiftUI_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoshowMultipleAlertsinSwiftUI_0.png","tag":["Tech"],"readingTime":7},{"title":"코틀린 멀티플랫폼 KMP","description":"","date":"2024-06-19 14:12","slug":"2024-06-19-KotlinMultiPlatformKMP","content":"\n이것은 안드로이드 및 iOS 플랫폼에서 작동하는 첫 번째 크로스 플랫폼 응용 프로그램을 만드는 단계별 안내서입니다.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_0.png)\n\nKotlin Multiplatform 기술은 크로스 플랫폼 프로젝트의 개발을 간소화하며, 그 중요한 사용 사례 중 하나는 플랫폼 간에 응용 프로그램 로직 코드를 공유하는 것입니다.\n\nhttps://github.com/ZahraHeydari/Kotlin-MultiPlatform-Mobile\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이 기사에서 배울 내용:\n\n- 환경 설정\n- 기본적인 KMM 프로젝트 생성\n- KMM 프로젝트 구조의 기초 이해\n- ViewModel\n- 네트워킹\n- iOS에서의 코루틴\n- 의존성 주입\n\n# 1. 환경 설정\n\n필요한 도구를 설치하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Android Studio\n- Xcode\n- JDK\n- Kotlin Multiplatform Mobile plugin\n- Kotlin plugin\n\n모든 것이 예상대로 작동되도록하려면 KDoctor 도구를 설치하고 실행하십시오.\n\n```js\nbrew install kdoctor\n```\n\n# 2. 기본 KMM 프로젝트 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 안드로이드 스튜디오를 열고 새 프로젝트 템플릿에서 Kotlin Multiplatform App을 선택하세요. 그리고 '다음' 버튼을 클릭하세요.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_1.png)\n\n다음 화면에서 애플리케이션의 이름과 프로젝트를 저장할 위치 등을 선택하세요. 그리고 다시 '다음' 버튼을 클릭하세요.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내 iOS 앱에 대한 종속성 관리자를 선택하십시오. 기본적으로 Regular framework이 선택되어 있고, 그런 다음 '완료'를 눌러주세요.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_3.png)\n\nGradle 동기화가 완료되면 툴바에서 실행 버튼을 사용하여 iOS 및 Android 앱을 모두 실행할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 안드로이드 에뮬레이터나 iOS 시뮬레이터에서 앱을 실행할 거예요.\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_5.png)\n\n# 3. KMM 프로젝트 구조 기초 이해\n\n각 Kotlin Multiplatform 프로젝트는 shared, androidApp, iosApp 세 가지 모듈을 포함하고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-KotlinMultiPlatformKMP_6.png\" /\u003e\n\n- shared은 Android 및 iOS 애플리케이션 모두에 공통으로 포함된 로직을 포함하는 Kotlin 모듈입니다. 이것은 플랫폼 간에 공유하는 코드입니다. 빌드 프로세스를 자동화하기 위해 Gradle을 빌드 시스템으로 사용합니다.\n- androidApp은 Android 애플리케이션으로 빌드되는 Kotlin 모듈입니다. 빌드 시스템으로 Gradle을 사용합니다. androidApp 모듈은 공통 Android 라이브러리로 사용하기 위해 shared 모듈에 의존하고 사용합니다.\n- iosApp은 iOS 애플리케이션으로 빌드되는 Xcode 프로젝트입니다. 이는 shared 모듈에 의존하며 iOS 프레임워크로 사용합니다. 공유 모듈은 일반 프레임워크로 사용하거나 CocoaPods 종속성으로 사용할 수 있습니다.\n\n# 기대 및 실제 키워드\n\n기대 및 실제 선언을 통해 Kotlin Multiplatform 모듈에서 플랫폼별 API에 액세스할 수 있습니다. 공통 코드에서 플랫폼에 중립적인 API를 제공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-06-19-KotlinMultiPlatformKMP_7.png)\n\n다음 규칙을 따라 예상 및 실제 선언을 정의합니다:\n\n- 공통 소스 세트에서 표준 코틀린 구조를 선언합니다. 이는 함수, 속성, 클래스, 인터페이스, 열거형 또는 주석일 수 있습니다.\n\n2. 이 구조물에 expect 키워드를 표시합니다. 이것이 예상 선언입니다. 이러한 선언은 공통 코드에서 사용할 수 있지만 구현은 포함하면 안 됩니다. 대신, 플랫폼별 코드가이 구현을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 각 플랫폼별 소스 세트에서 동일한 구조물을 동일한 패키지에 선언하고 actual 키워드로 표시하세요. 이것이 여러분의 실제 선언입니다. 일반적으로 이 선언에는 플랫폼별 라이브러리를 사용하여 구현이 포함됩니다.\n\n![Kotlin Multiplatform](/assets/img/2024-06-19-KotlinMultiPlatformKMP_8.png)\n\n## 공통 코드\n\n공통 코드는 서로 다른 플랫폼 간에 공유되는 Kotlin 코드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 예제를 살펴보겠습니다:\n\n```kotlin\nclass Greeting {\n    private val platform: Platform = getPlatform()\n\n    fun greet(): String {\n        return \"안녕, ${platform.name}!\"\n    }\n}\n```\n\n```kotlin\ninterface Platform {\n    val name: String\n}\n\nexpect fun getPlatform(): Platform\n```\n\n## 모든 플랫폼에서 코드 공유하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 모든 플랫폼에 대해 공통인 비즈니스 로직이 있다면, 각 플랫폼에 동일한 코드를 작성할 필요가 없습니다. 그저 공통 소스 집합에서 공유하면 됩니다.\n\n![Image](/assets/img/2024-06-19-KotlinMultiPlatformKMP_9.png)\n\n보통 여러 네이티브 타겟을 생성해야 할 때가 많으며, 이러한 타겟들은 공통 로직과 써드파티 API를 재사용할 수 있습니다.\n\n이제 KMM 프로젝트에 viewModel을 추가할 시간입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4. KMP 프로젝트의 ViewModel\n\nViewModel은 Activity 또는 Fragment를 위한 데이터를 준비하고 관리하는 클래스입니다.\n\n이 샘플 프로젝트에서 EmojiHubViewModel은 이모지 데이터를 준비하고 관리하며 UI에 노출하기 위해 사용되며, SharedViewModel은 여러 뷰모델의 기본 클래스입니다.\n\nSharedViewModel과 EmojiHubViewModel은 commonMain 모듈에 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n// shared/commonMain/.../viewModel/SharedViewModel\nexpect open class SharedViewModel() {\n\n    val sharedViewModelScope: CoroutineScope\n\n    protected open fun onCleared()\n}\n```\n\nandroidMain 및 iosMain 소스 세트에서 actual 키워드를 사용하여 동일한 구조물을 표시하십시오. 일반적으로 이 actual 선언에는 플랫폼별 라이브러리를 사용한 구현이 포함됩니다.\n\nEmojiHubViewModel 선언이 공통 코드에 있고 iOS 및 Android 플랫폼 모두에서 사용할 수 있다는 점에 유의하십시오.\n\n```kotlin\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    ...\n\n    init {\n        sharedViewModelScope.launch {\n            ...\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 안드로이드 플랫폼의 ViewModel\n\n![image](/assets/img/2024-06-19-KotlinMultiPlatformKMP_10.png)\n\n```kotlin\n// shared/androidMain/.../viewModel/SharedViewModel\nactual open class SharedViewModel: ViewModel() {\n\n    actual val sharedViewModelScope: CoroutineScope = this.viewModelScope\n\n    actual override fun onCleared() {\n        super.onCleared()\n    }\n}\n```\n\n아래 코드 스니펫은 EmojiHubScreen에서 emojiHubViewModel을 사용하는 방법을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun EmojiHubScreen() {\n\n    val emojiHubViewModel: EmojiHubViewModel = koinViewModel()\n    val items by emojiHubViewModel.items.collectAsState()\n\n    Scaffold(topBar = {\n        TopAppBar(title = {\n            Text(text = \"EmojiHub\")\n        })\n    }, content = { paddingValues -\u003e\n        LazyColumn(modifier = Modifier.padding(paddingValues)) {\n            items(items.size) { index -\u003e\n                Item(items[index])\n            }\n        }\n    })\n}\n```\n\n저는 이 글에서 Ktor를 사용하여 데이터를 가져오고 Koin을 사용하여 종속성 주입하는 방법에 대해 설명하겠습니다! 그러니 지금은 건너뛰세요!\n\n## iOS 플랫폼의 ViewModel\n\n\u003cimg src=\"/assets/img/2024-06-19-KotlinMultiPlatformKMP_11.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n// shared/iosMain/.../viewModel/SharedViewModel\n실제 열린 클래스 SharedViewModel {\n\n    실제 val sharedViewModelScope = MainScope()\n\n    보호된 실제 기능 onCleared() {}\n\n    fun clear() {\n        onCleared()\n    }\n}\n```\n\n그리고 ContentView에서 emojiHubViewModel을 사용하는 방법입니다.\n\n```swift\nstruct ContentView: View {\n\n @StateObject\n var emojiHubViewModel: EmojiHubViewModel()\n\n var body: some View {\n     Text(String(\"EmojiHub\"))\n     List {\n          ForEach(iOSEmojiHubViewModel.items, id: \\.self) { item in\n              Item(emojiItem: item)\n          }\n     }\n  }\n}\n```\n\n# 5. 네트워킹\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKtor은 마이크로서비스부터 멀티플랫폼 HTTP 클라이언트 앱까지 다양한 용도로 사용됩니다. 이를 사용하려면 build.gradle.kts 파일에 아래와 같이 Ktor 종속성을 추가하면 됩니다.\n\n```kotlin\nval ktorVersion = \"3.4.3\"\n\n// shared/build.gradle.kts\nsourceSets {\n\n    val commonMain by getting {\n        dependencies {\n            implementation(\"io.ktor:ktor-client-core:$ktorVersion\")\n            implementation(\"io.ktor:ktor-client-logging:$ktorVersion\")\n            implementation(\"io.ktor:ktor-client-content-negotiation:$ktorVersion\")\n        }\n    }\n\n    val androidMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            // 다른 의존성 추가\n            implementation(\"io.ktor:ktor-client-okhttp:$ktorVersion\")\n        }\n    }\n\n    val iosMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            implementation(\"io.ktor:ktor-client-darwin:$ktorVersion\")\n        }\n    }\n}\n```\n\n공통 모듈인 commonMain에 HttpClient 파일을 아래와 같이 추가하세요:\n\n```kotlin\nexpect fun httpClient(config: HttpClientConfig\u003c*\u003e.() -\u003e Unit): HttpClient\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안드로이드 메인에서 실제 키워드를 사용하여 httpClient를 선언하세요:\n\n```kotlin\nactual fun httpClient(config: HttpClientConfig\u003c*\u003e.() -\u003e Unit): HttpClient = HttpClient(OkHttp) {\n    config()\n}\n```\n\n또한 iOS 메인에서도 실제 키워드를 사용하여 httpClient를 선언하세요:\n\n```kotlin\nactual fun httpClient(config: HttpClientConfig\u003c*\u003e.() -\u003e Unit): HttpClient = HttpClient(Darwin) {\n    config()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 EmojiHubRepository에서 httpClient를 사용하여 원격 서버에서 이모지를 가져오세요.\n\n```kotlin\nclass EmojiHubRepository(private val httpClient: HttpClient) {\n\n    suspend fun getEmojis(): List\u003cEmojiItem\u003e {\n        return try {\n            httpClient.get(urlString = \"/api/all\").body()\n        } catch (e: Exception) {\n            e.printStackTrace()\n            emptyList()\n        }\n    }\n}\n```\n\n그리고 EmojiHubViewModel에서 EmojiHubRepository를 사용하여 원격 또는 로컬 소스에서 데이터를 가져오세요.\n\n```kotlin\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    private val _items = MutableStateFlow\u003cList\u003cEmojiItem\u003e\u003e(listOf())\n\n    @NativeCoroutinesState\n    val items = _items.asStateFlow()\n\n    init {\n        sharedViewModelScope.launch {\n            _items.update {\n                repository.getEmojis() // 저장소를 통해 데이터 가져오기\n            }\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. 아이폰에서의 코루틴\n\n프로젝트에 Kotlinx.Serialization을 추가하세요.\n\nKotlinx.Serialization은 사용자 정의 타입의 객체를 직렬화하고 역직렬화하는 데 사용됩니다.\n\n```js\nval kotlinxSerializationVersion = \"1.5.1\"\n\n// shared/build.gradle.kts\nsourceSets {\n\n    val commonMain by getting {\n        dependencies {\n            implementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:$kotlinxSerializationVersion\")\n            ...\n        }\n    }\n\n    val androidMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            ...\n        }\n    }\n\n    val iosMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            ...\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## httpClient 재구성하기\n\n```kotlin\n// shared/commonMain/.../EmojiHubRepository\n    class EmojiHubRepository {\n        private val httpClient = httpClient {\n            ...\n            install(ContentNegotiation) {\n                json(\n                    Json {\n                        ignoreUnknownKeys = true\n                    }\n                )\n            }\n        }\n    }\n```\n\n서버에서 데이터를 가져와 Android 앱을 실행합니다.\n\n```kotlin\nsuspend fun getEmojis(): List\u003cEmojiItem\u003e {\n        return try {\n            httpClient.get(urlString = \"/api/all\").body()\n        } catch (e: Exception) {\n            e.printStackTrace()\n            emptyList()\n        }\n    }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    private val _items = MutableStateFlow\u003cList\u003cEmojiItem\u003e\u003e(listOf())\n\n    @NativeCoroutinesState\n    val items = _items.asStateFlow()\n\n    init {\n        sharedViewModelScope.launch {\n            _items.update {\n                repository.getEmojis()\n            }\n        }\n    }\n}\n```\n\n![Image](/assets/img/2024-06-19-KotlinMultiPlatformKMP_12.png)\n\n## KMP-NativeCoroutines\n\n```kotlin\n// commonMain/viewModel/EmojiHubViewModel\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    private val _items = MutableStateFlow\u003cList\u003cEmojiItem\u003e\u003e(listOf())\n\n    @NativeCoroutinesState\n    val items = _items.asStateFlow()\n\n    ...\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIOSEmojiHubViewModel은 iosApp 모듈에 있어요.\n\n\u003cimg src=\"/assets/img/2024-06-19-KotlinMultiPlatformKMP_13.png\" /\u003e\n\nIOSEmojiHubViewModel에서 KMPNativeCoroutinesAsync을 사용하여 데이터를 가져옵니다.\n\n```swift\n@MainActor\nclass IOSEmojiHubViewModel: ObservableObject {\n\n    private let githubViewModel = GithubViewModel()\n\n    @Published\n    var items = Array\u003cEmojiItem\u003e()\n\n    var task: Task\u003c(), Never\u003e? = nil\n\n    init() {\n        task = Task {\n            do {\n                let asyncItems = asyncSequence(for: emojiHubViewModel.itemsFlow)\n                for try await asyncItem in asyncItems {\n                    items = asyncItem\n                }\n            } catch {\n                print(\"Failed with error: \\(error)\")\n            }\n        }\n    }\n\n    func clear() {\n        task?.cancel()\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct ContentView: View {\n\n    @StateObject\n    var iOSEmojiHubViewModel = IOSEmojiHubViewModel()\n\n    var body: some View {\n        Text(String(\"EmojiHub\"))\n        List {\n            ForEach(iOSEmojiHubViewModel.items, id: \\.self) { item in\n                Item(emojiItem: item)\n            }\n        }\n    }\n}\n```\n\n# 7. 의존성 주입\n\n의존성 주입 패턴을 구현하기 위해 프로젝트에 Koin을 추가하세요.\n\n```js\nval koinVersion = \"3.4.3\"\n\n// shared/build.gradle.kts\nsourceSets {\n\n    val commonMain by getting {\n        dependencies {\n            implementation(\"io.insert-koin:koin-core:$koinVersion\")\n            ...\n        }\n    }\n\n    val androidMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            implementation(\"io.insert-koin:koin-android:$koinVersion\")\n            ...\n        }\n    }\n\n    val iosMain by getting {\n        dependsOn(commonMain)\n        dependencies {\n            ...\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEmojiHubRepository에 HttpClient을 주입해주세요.\n\n```kotlin\nclass EmojiHubRepository(private val httpClient: HttpClient) {\n\n    ...\n}\n```\n\n그리고 EmojiHubViewModel에서 EmojiHubRepository를 주입해주세요.\n\n```kotlin\n// commonMain/viewModel/EmojiHubViewModel\nclass EmojiHubViewModel(private val repository: EmojiHubRepository) : SharedViewModel() {\n\n    ...\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 의존성을 정의하도록 모듈을 선언해보세요:\n\n```kotlin\nval appModule = module {\n    single {\n        httpClient {\n           ...\n        }\n    }\n\n    single {\n        EmojiHubRepository(get())\n    }\n\n    sharedViewModel {\n        EmojiHubViewModel(get())\n    }\n}\n```\n\n프로젝트 애플리케이션 클래스에 Koin을 시작하는 코드를 추가해보세요.\n\n```kotlin\n//androidApp/MainApplication\nclass MainApplication : Application() {\n\n    override fun onCreate() {\n        super.onCreate()\n\n        startKoin {\n            androidContext(this@MainApplication)\n            modules(appModule) // 앱 모듈\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOSMain 에서 Koin을 시작하려면 아래와 같이 시작하세요.\n\n```js\n// shared/iosMain/.../KoinStarter.kt\nfun startKoin() {\n    startKoin { modules(appModule) }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-KotlinMultiPlatformKMP_14.png\" /\u003e\n\niOSApp에서 startKoin을 호출하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n@ main\n구조체 iOSApp: 앱 {\n\ninit() {\nKoinStarterKt.startKoin()\n}\n\n    var body: some Scene {\n       WindowGroup {\n           ContentView()\n       }\n    }\n\n}\n\n그리고 GithubViewModelHelper은 iOS에서 GithubViewModel을 주입하는 데 사용됩니다.\n\nclass EmojiHubViewModelHelper: KoinComponent {\n\n    private val emojiHubViewModel: EmojiHubViewModel = get()\n\n    @NativeCoroutinesState\n    val items = emojiHubViewModel.items\n\n}\n\n![이미지](/assets/img/2024-06-19-KotlinMultiPlatformKMP_15.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Android 앱과 iOS 앱을 실행해보세요.\n\n![Kotlin Multiplatform](/assets/img/2024-06-19-KotlinMultiPlatformKMP_16.png)\n\n## 라이브러리 및 도구\n\n- KMP 플러그인\n- Kdoctor\n- Ktor\n- kotlinx.serialization\n- KMP-NativeCoroutines\n- Koin\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 KMP(Kotlin Multiplatform)를 사용한 예제 프로젝트입니다.\n\n[여기](https://github.com/ZahraHeydari/Kotlin-MultiPlatform-Mobile)를 클릭해주세요!\n\n이 이야기를 읽어 주셔서 감사합니다. 도움이 되셨으면 좋겠어요.\n\n의견이 있으시면 언제든지 남겨주세요. 감사합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코딩을 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-19-KotlinMultiPlatformKMP_0.png"},"coverImage":"/assets/img/2024-06-19-KotlinMultiPlatformKMP_0.png","tag":["Tech"],"readingTime":22},{"title":"마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기","description":"","date":"2024-06-19 14:10","slug":"2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms","content":"\n![이미지](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png)\n\nCompose Multiplatform은 개발자에게 뛰어난 가능성의 세계를 열어주어 안드로이드와 iOS용 네이티브 모습을 하나의 코드베이스로 구축할 수 있게 합니다. 이러한 앱에 인증을 통합하는 것은 어렵게 느껴질 수 있지만, 이 기사에서는 Firebase REST API 인증을 Compose Multiplatform과 통합하는 단계와 혜택을 탐색할 것입니다.\n\n# 왜 Firebase REST API를 사용하는가?\n\n우리는 Android, iOS 및 Web 플랫폼용 다양한 Firebase SDK가 있음을 알고 있지만 Compose Multiplatform용 안정적인 SDK는 없습니다. 또한, 다양한 Compose Multiplatform 예제에서 사용 사례를 보여주기 위해 REST API를 사용하는 것을 보았습니다. 따라서 하나의 코드베이스를 사용하고 여러 플랫폼을 대상으로 하기 위해 Firebase REST API를 인증에 사용하는 것을 선호했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 준비물:\n\n- Compose Multiplatform 플러그인이 설치된 Android Studio 또는 IntelliJ IDEA.\n- iOS 앱을 실행하기 위한 Xcode.\n- Firebase 프로젝트.\n- 프로젝트에서 Firebase Authentication이 활성화되어 있어야 합니다.\n\n# 단계 1: Compose Multiplatform 프로젝트 생성\n\nCompose Multiplatform 프로젝트를 생성하려면 Kotlin Multiplatform Wizard를 사용할 수 있습니다. 이는 우리가 타깃팅하는 플랫폼을 선택할 수 있게 해줍니다. 이 프로젝트에서는 Android, iOS 및 데스크톱 플랫폼을 선택할 것입니다. 플랫폼을 선택하고 나면 프로젝트를 다운로드하여 선호하는 IDE에서 열 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_1.png)\n\n# 단계 2: 인증을 위한 UI 생성\n\n이 프로젝트에서는 Email/Password 인증만 대상으로 하고 시작하므로 composeApp/src/commonMain/kotlin/authentication/AuthenticationView.kt 파일에서는 로그인 및 회원가입 뷰를 포함한 UI가 제공됩니다.\n\n![image](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 3: Firebase 프로젝트 구성하기.\n\nFirebase 프로젝트를 구성하면 프로젝트 설정을 방문하여 Firebase REST API와 함께 사용할 API Key를 얻을 수 있습니다. 이를 사용하여 사용자를 인증할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_3.png)\n\n# 단계 4: 프로젝트에서 Ktor 구성하기.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKotlin의 Ktor 프레임워크는 강력하고 유연한 HTTP 클라이언트를 제공하여 외부 API와의 상호 작용을 원활하게 만들어줍니다. 구현에 앞서 필요한 종속성이 포함된 Kotlin 프로젝트를 설정했는지 확인해보세요. Ktor의 클라이언트 라이브러리를 포함하여 프로젝트에 Ktor 클라이언트를 추가할 수 있습니다. 이를 위해 libs.versions.toml 파일 내 gradle 폴더에 다음 종속성을 포함하면 됩니다.\n\n[versions]\n...\nkotlin = \"1.9.21\"\nkotlinx-coroutines = \"1.7.3\"\nktor = \"2.3.6\"\n\n[libraries]\n....\nktor-serialization-kotlinx-json = { module = \"io.ktor:ktor-serialization-kotlinx-json\", version.ref = \"ktor\" }\nktor-client-core = { module = \"io.ktor:ktor-client-core\", version.ref = \"ktor\" }\nktor-client-darwin = { module = \"io.ktor:ktor-client-darwin\", version.ref = \"ktor\" }\nktor-client-okhttp = { module = \"io.ktor:ktor-client-okhttp\", version.ref = \"ktor\" }\nktor-client-content-negotiation = { module = \"io.ktor:ktor-client-content-negotiation\", version.ref = \"ktor\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nandroidLibrary = { id = \"com.android.library\", version.ref = \"agp\" }\njetbrainsCompose = { id = \"org.jetbrains.compose\", version.ref = \"compose-plugin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nkotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }\n\nlibs.versions.toml 파일 내의 라이브러리를 추가했으면, build.gradle.kts 파일의 composeApp 내부에 종속성을 추가하고 프로젝트를 동기화해주면 됩니다:\n\nandroidMain.dependencies {\n...\nimplementation(libs.ktor.client.okhttp)\n}\ncommonMain.dependencies {\n...\nimplementation(libs.ktor.client.core)\nimplementation(libs.ktor.client.content.negotiation)\nimplementation(libs.ktor.serialization.kotlinx.json)\n}\ndesktopMain.dependencies {\n..\nimplementation(libs.ktor.client.okhttp)\n}\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 5: Firebase REST API 호출하기\n\nKtor 라이브러리가 추가되고 프로젝트가 동기화된 후, Ktor 함수를 사용하여 Firebase REST API를 호출할 수 있습니다. 그 전에 HttpClient를 초기화하여 API 요청을 만들 수 있어야 합니다. 그래서, AuthenticationViewModel.kt 파일을 생성하여 모든 백엔드 작업을 처리하고 아래 코드를 추가합니다.\n\n```js\nprivate val httpClient = HttpClient() {\n    install(ContentNegotiation) {\n        json()\n    }\n}\n```\n\n## 사용자 생성 정복하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 새로운 사용자를 생성해 봅시다! https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=$'API_KEY' 엔드포인트로 Ktor 클라이언트 호출을 만들어 보겠습니다. 사용자 데이터(이메일 및 비밀번호)를 코틀린 직렬화를 사용하여 JSON 형식으로 직렬화해야 합니다. 데이터와 함께 POST 요청을 보내고 Firebase 응답을 기다리세요. 사용자가 성공적으로 생성되면 응답을 구문 분석하여 사용자 ID 및 기타 관련 정보를 추출하세요.\nAuthenticationViewModel.kt에 추가된 signUp() 메서드의 아래 코드 스니펫을 확인해보세요.\n\n```js\nfun signUp(\n        email: String,\n        password: String,\n        confirmPassword: String,\n        onCompletion: onCompletion\n    ) {\n        if (password == confirmPassword) {\n            viewModelScope.launch {\n                val responseBody = httpClient\n                    .post(\"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${API_KEY}\") {\n                        header(\"Content-Type\", \"application/json\")\n                        parameter(\"email\", email)\n                        parameter(\"password\", password)\n                        parameter(\"returnSecureToken\", true)\n                    }\n                if (responseBody.status.value in 200..299) {\n                    val response = Json { ignoreUnknownKeys = true }\n                        .decodeFromString\u003cAuthResponse\u003e(responseBody.bodyAsText())\n                    onCompletion.onSuccess(response.idToken)\n                } else {\n                    onCompletion.onError(Exception(responseBody.bodyAsText()))\n                }\n            }\n        } else {\n            onCompletion.onError(Exception(\"Password doesn't match\"))\n        }\n    }\n```\n\n## 로그인 퀘스트:\n\n이제 로그인에 도전해 봅시다! 사용자 생성과 유사하게, https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=$'API_KEY' 엔드포인트로의 Ktor 클라이언트 호출을 구성해보세요. 다시 한번 사용자 자격 증명(이메일 및 비밀번호)을 직렬화하고 POST 요청을 보내세요. 응답을 구문 분석하여 ID 토큰을 얻어 사용자 신원을 확인하고 보호된 리소스에 액세스하는 데 필수적인 요소를 확보하세요.\nAuthenticationViewModel.kt에 추가된 login() 메서드의 아래 코드 스니펫을 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nfun login(\n    email: String,\n    password: String,\n    onCompletion: onCompletion\n) {\n    viewModelScope.launch {\n        val responseBody = httpClient\n            .post(\"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${API_KEY}\") {\n                header(\"Content-Type\", \"application/json\")\n                parameter(\"email\", email)\n                parameter(\"password\", password)\n                parameter(\"returnSecureToken\", true)\n            }\n        if (responseBody.status.value in 200..299) {\n            val response = Json { ignoreUnknownKeys = true }\n                .decodeFromString(responseBody.bodyAsText())\n            storeUserDetails(response)\n            onCompletion.onSuccess(response.idToken)\n        } else {\n            onCompletion.onError(Exception(responseBody.bodyAsText()))\n        }\n    }\n}\n```\n\n# 단계 6: 캐시 지원을 위해 SQLDelight 추가.\n\nSQLDelight는 플랫폼에 중립적인 SQL 쿼리를 작성하기 위한 강력한 코틀린 라이브러리로, 캐싱과 결합하여 앱의 효율성을 높이는 동적 이중체를 형성합니다. 여기서는 login 및 signUp API 호출의 응답에서 얻은 refreshToken을 저장할 것입니다. 따라서 사용자가 앱을 다시 열 때 인증을 요청하지 않을 것입니다.\n\n## SQLDelight 종속성 설정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 gradle 폴더 내 libs.versions.toml 파일에 필요한 SQLDelight 종속성 및 플러그인을 추가해야 합니다.\n\n```js\n[versions]\n...\n...\nsqlDelight = \"2.0.1\"\n\n[libraries]\n...\n...\nsqldelight-androidDriver = { module = \"app.cash.sqldelight:android-driver\", version.ref = \"sqlDelight\" }\nsqldelight-jvmDriver = { module = \"app.cash.sqldelight:sqlite-driver\", version.ref = \"sqlDelight\" }\nsqldelight-nativeDriver = { module = \"app.cash.sqldelight:native-driver\", version.ref = \"sqlDelight\" }\nsqldelight-coroutines = { module = \"app.cash.sqldelight:coroutines-extensions\", version.ref = \"sqlDelight\" }\nsqldelight-primitiveAdapters = { module = \"app.cash.sqldelight:coroutines-extensions\", version.ref = \"sqlDelight\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nandroidLibrary = { id = \"com.android.library\", version.ref = \"agp\" }\njetbrainsCompose = { id = \"org.jetbrains.compose\", version.ref = \"compose-plugin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nkotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }\nsqlDelight = { id = \"app.cash.sqldelight\", version.ref = \"sqlDelight\" }\n```\n\n다음 단계는 프로젝트 수준의 build.gradle.kts 파일에 플러그인을 추가하는 것입니다.\n\n```js\nplugins {\n    // this is necessary to avoid the plugins to be loaded multiple times\n    // in each subproject's classloader\n    alias(libs.plugins.androidApplication) apply false\n    alias(libs.plugins.androidLibrary) apply false\n    alias(libs.plugins.jetbrainsCompose) apply false\n    alias(libs.plugins.kotlinMultiplatform) apply false\n    //SQLDelight Plugin\n    alias(libs.plugins.sqlDelight) apply false\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막 단계로는 composeApp build.gradle.kts 파일에서 SQLDelight를 구성해야 합니다. 여기서는 필요한 플랫폼에 따라 종속성을 추가하고 SQLDelight 데이터베이스의 이름을 추가할 것입니다. 매개변수가 포함된 데이터베이스 목록을 포함하는 sqlDelight 블록을 맨 끝에 볼 수 있을 것입니다.\n\n```js\nimport org.jetbrains.compose.ExperimentalComposeLibrary\nimport org.jetbrains.compose.desktop.application.dsl.TargetFormat\n\nplugins {\n    alias(libs.plugins.kotlinMultiplatform)\n    alias(libs.plugins.androidApplication)\n    alias(libs.plugins.jetbrainsCompose)\n    alias(libs.plugins.kotlinxSerialization)\n    alias(libs.plugins.sqlDelight)\n}\n\nkotlin {\n\n    androidTarget {\n        compilations.all {\n            kotlinOptions {\n                jvmTarget = \"1.8\"\n            }\n        }\n    }\n\n\n    jvm(\"desktop\")\n\n    listOf(\n        iosX64(),\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach { iosTarget -\u003e\n        iosTarget.binaries.framework {\n            baseName = \"ComposeApp\"\n            // This should be set to false to run on iOS\n            isStatic = false\n            // Add it to avoid sqllite3 issues in iOS\n            linkerOpts.add(\"-lsqlite3\")\n        }\n    }\n\n    sourceSets {\n        val desktopMain by getting\n\n        androidMain.dependencies {\n            implementation(libs.compose.ui.tooling.preview)\n            implementation(libs.androidx.activity.compose)\n            implementation(libs.ktor.client.okhttp)\n            //SqlDelight for Android\n            implementation(libs.sqldelight.androidDriver)\n        }\n        commonMain.dependencies {\n            implementation(compose.runtime)\n            implementation(compose.foundation)\n            implementation(compose.material)\n            implementation(compose.ui)\n            @OptIn(ExperimentalComposeLibrary::class)\n            implementation(compose.components.resources)\n            //Ktor\n            implementation(libs.ktor.client.core)\n            implementation(libs.ktor.client.content.negotiation)\n            implementation(libs.ktor.serialization.kotlinx.json)\n            //Moko MVVM\n            implementation(libs.moko.mvvm.core)\n            implementation(libs.moko.mvvm.compose)\n            //Kamel\n            implementation(libs.kamel)\n            // Navigator\n            implementation(libs.voyager.navigator)\n            //SqlDelight for common\n            implementation(libs.sqldelight.coroutines)\n            implementation(libs.sqldelight.primitiveAdapters)\n        }\n        desktopMain.dependencies {\n            implementation(compose.desktop.currentOs)\n            implementation(libs.kotlinx.coroutines.swing)\n            implementation(libs.ktor.client.okhttp)\n            //SqlDelight for jvm\n            implementation(libs.sqldelight.jvmDriver)\n        }\n        iosMain.dependencies {\n            //SqlDelight for iOS\n            implementation(libs.sqldelight.nativeDriver)\n        }\n    }\n}\n\nsqldelight {\n    databases {\n        //Note: Name of your Database and .sq file should be same\n        create(\"Database\") {\n            packageName.set(\"com.dwarshb.firebaseauthentication\")\n        }\n    }\n    // Add this line to avoid library linking issues\n    linkSqlite = true\n}\n\nandroid {\n    ...\n}\n\ncompose.desktop {\n    ...\n}\n```\n\n## 쿼리용 Database.sq 파일 만들기\n\n다음 단계는 모든 필요한 SQL 쿼리를 포함하는 .sq 파일을 작성하는 것입니다. 기본적으로 SQLDelight 플러그인은 sqldelight 폴더 내의 패키지 폴더에서 .sq를 읽습니다. 해당 폴더는 직접 commainMain 폴더 내에 있을 것입니다.\nDatabase.sq 파일이 위치하는 폴더 구조 스크린샷은 아래에서 확인하실 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_4.png\" /\u003e\n\n다음 코드를 Database.sq 파일에 추가하세요. 이 파일은 createTable, insertUser, removeAllUsers, getAllUsers 등의 쿼리를 포함합니다.\n\n프로젝트를 컴파일하면 생성된 Kotlin 코드가 composeApp/build/generated/sqldelight 디렉토리에 저장됩니다. 또는 터미널에서 ./gradlew generateSqlDelightInterface 명령어를 사용하여 sqldelight 코틀린 코드를 생성할 수도 있습니다.\n\n## 데이터베이스 드라이버 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSQLDelight은 SQLite 드라이버의 여러 플랫폼별 구현을 제공하므로 각 플랫폼에 대해 별도로 생성해야 합니다. 이를 기대 선언과 실제 선언을 사용하여 수행할 수 있습니다.\n\ncomposeApp/src/commonMain/kotlin에서 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 만드세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\n\nexpect class DriverFactory {\n    fun createDriver(): SqlDriver\n}\n```\n\n이제 각 대상 플랫폼에 대해 이를 구현해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안드로이드에서는 AndroidSqliteDriver 클래스가 SQLite 드라이버를 구현합니다.\n그래서 composeApp/src/androidMain/kotlin에서 패키지를 만들어 그 안에 DriverFactory.kt 클래스를 생성해주세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport android.content.Context\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.android.AndroidSqliteDriver\n\nactual class DriverFactory(var appContext: Context) {\n\n    actual fun createDriver(): SqlDriver {\n        return AndroidSqliteDriver(Database.Schema, appContext, \"firebase.db\")\n    }\n}\n```\n\n이제 Android에서 작동하도록 하기 위해 composeApp/src/androidMain/kotlin에 있는 MainActivity.kt 파일에서 해당 인스턴스를 생성해야 합니다.\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        //Android용 DriverFactory의 인스턴스 생성\n        val driverFactory = DriverFactory(this)\n        setContent {\n            App(driverFactory.createDriver())\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS에서 SQLite 드라이버 구현은 NativeSqliteDriver 클래스입니다.\n그래서 composeApp/src/iosMain/kotlin에 패키지를 만들고 내부에 DriverFactory.kt 클래스를 만들어 주세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.native.NativeSqliteDriver\n\nactual class DriverFactory {\n    actual fun createDriver(): SqlDriver {\n        return NativeSqliteDriver(Database.Schema, \"firebase.db\")\n    }\n}\n```\n\n이제 MainViewController.kt 파일을 만들어서 iOS에서 작업할 수 있도록 인스턴스를 만들어주세요. 이 파일은 composeApp/src/iosMain/kotlin에 있습니다.\n\n```kotlin\nimport androidx.compose.ui.window.ComposeUIViewController\nimport com.dwarshb.firebaseauthentication.DriverFactory\n\nfun MainViewController() = ComposeUIViewController {\n    val driverFactory = DriverFactory()\n    App(driverFactory.createDriver())\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데스크톱 환경에서는 SQLite 드라이버 구현이 JdbcSqliteDriver 클래스입니다.\n그래서 composeApp/src/desktopMain/kotlin에 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 생성해주세요.\n\n```js\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver\nimport java.io.File\n\nactual class DriverFactory {\n    actual fun createDriver(): SqlDriver {\n        val databasePath = File(System.getProperty(\"java.io.tmpdir\"), \"firebase.db\")\n        val driver: SqlDriver = JdbcSqliteDriver(url = \"jdbc:sqlite:${databasePath.absolutePath}\")\n        Database.Schema.create(driver)\n        return driver\n    }\n}\n```\n\n이제 데스크톱에서 작동하도록 composeApp/src/desktopMain/kotlin의 main.kt 파일에 인스턴스를 생성해야 합니다.\n\n```js\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\nimport com.dwarshb.firebaseauthentication.DriverFactory\n\nfun main() = application {\n    Window(onCloseRequest = ::exitApplication, title = \"FirebaseAuthentication\") {\n        val driverFactory = DriverFactory()\n        App(driverFactory.createDriver())\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_5.png\" /\u003e\n\n모든 플랫폼에서 DriverFactory를 구성하고 위 단계를 모두 따라왔다면, App() 함수를 수정하고 SqlDriver를 매개변수로 추가해야 합니다. 각 플랫폼에서 SqlDriver의 인스턴스를 가져올 수 있는 유일한 방법이기 때문입니다. 그래서 composeApp/src/commanMain/kotlin/App.kt 안에 다음과 같이 작성하세요.\n\n```js\n@Composable\nfun App(sqlDriver: SqlDriver) {\n    val authenticationViewModel = AuthenticationViewModel(sqlDriver)\n\n    MaterialTheme {\n      ...\n    }\n}\n```\n\n# 단계 7: SQLDelight 쿼리 구성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 단계에서는 Firebase Authentication API에서 받은 토큰을 저장하여 사용자 세션을 유지하기 위해 insertUser 쿼리를 사용할 예정입니다. 또한 로컬 데이터베이스에 저장된 토큰을 얻기 위해 selectAllUser 쿼리를 사용할 것입니다. AuthenticationViewModel.kt 내에서 먼저 데이터베이스를 초기화할 것입니다.\n\n```js\n    var databaseQuery : DatabaseQueries\n\n    val database = Database(sqlDriver)\n    databaseQuery = database.databaseQueries\n```\n\n이제 API에서 받은 응답을 저장할 storeUserDetails() 메서드를 만들 것입니다. 이 메서드는 로컬 데이터베이스에 정보를 저장하는 데 insertUser 쿼리를 사용합니다. AuthenticationViewModel.kt 파일의 login()이나 signUp() 메서드 내에 이 메서드를 추가할 수 있습니다.\n\n```js\ninternal fun storeUserDetails(response: AuthResponse) {\n        databaseQuery.insertUser(\n            response.idToken, response.email, response.refreshToken,\n            response.email\n        )\n    }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n세션 유지를 위해 시스템에 이미 토큰이 로컬 데이터베이스에 있는지 확인해야 합니다. 그래서 우리는 selectAllUsers 쿼리를 사용하여 로컬 데이터베이스에 저장된 토큰을 확인하는 checkSession()을 생성할 것입니다.\n\n```kotlin\ninternal fun checkSession(onCompletion: onCompletion) {\n    for(user in databaseQuery.selectAllUsers().executeAsList()) {\n        if (user != null) {\n            onCompletion.onSuccess(user.refreshToken.toString())\n        } else {\n            onCompletion.onError(Exception(\"세션을 찾을 수 없습니다\"))\n        }\n    }\n}\n```\n\n우리는 checkSession() 메서드를 사용하여 결과에 따라 UI를 업데이트할 수 있습니다. 예를 들어, 토큰이 있는 경우 onSuccess 내에서 앱을 MainScreen으로 이동시키고, 그렇지 않은 경우 AuthenticationView 화면이 표시됩니다.\n\n# 데모\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 Github 링크에서 전체 코드를 확인해보세요.\n\n# 참조 링크:\n\n- https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ktor-sqldelight.html#build-an-sdk\n- https://firebase.google.com/docs/reference/rest/auth#section-api-usage\n","ogImage":{"url":"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png"},"coverImage":"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png","tag":["Tech"],"readingTime":23},{"title":"원활한 사용을 위해 ExecuTorch와 함께 모바일 앱에 원시 AI를 적용하기 - 파트 1 - iOS","description":"","date":"2024-06-19 14:08","slug":"2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS","content":"\n\u003cimg src=\"/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_0.png\" /\u003e\n\nExecuTorch는 PyTorch를 기반으로 한 새로운 프레임워크로, PyTorch AI 모델을 로컬 배포에 적합한 형식으로 내보낼 수 있게 해줍니다. 이는 약간의 네이티브 코드와 함께 React Native 앱에 AI 기능을 쉽게 통합할 수 있음을 의미합니다. iOS의 경우, Apple의 Neural Engines 덕분에 고성능을 제공하는 CoreML 백엔드를 활용할 수 있습니다.\n\n이 튜토리얼 시리즈에서는 API 호출이 필요 없이 자신이 선택한 AI 모델을 앱에서 직접 사용하는 방법을 안내해 드릴 것입니다.\n\n## 1. 모델 내보내기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가장 먼저 해야 할 일은 PyTorch 모델을 .pte 파일로 내보내는 것인데, 이는 본질적으로 PyTorch 실행 가능 파일입니다. 이 부분은 이미 처리해 드렸지만, 만약 여러분의 모델을 사용하고 싶으시다면 ExecuTorch의 Python API를 사용하여 가능합니다. 만약 재현하고 싶다면, 저희 레포지토리에서 모델을 다운로드할 수 있습니다. 여기에서 내보낸 모델들은 PyTorch 예제 레포지토리에서 가져왔습니다. 이를 하기 전에, 환경 설정이 필수적입니다. 기본 내보내기 튜토리얼은 다음을 참조하세요:\n\n전체 프로세스는 여러 단계로 이뤄져 있으며, 사용 사례에 따라 다를 수 있습니다. 모델은 먼저 그래프 표현으로 변환되며, 이후 여러분의 필요에 맞게 최적화될 수 있습니다. 이것은 컴파일, 옵셔널 양자화, 메모리 계획 등을 포함한 다단계 프로세스로, 최종적으로 실행 가능 파일로 내보냅니다. 실행 시, 특정 하드웨어 대상용으로 빌드된 ExecuTorch를 사용하여 장치에서 효율적으로 추론을 수행합니다.\n\n![이미지](/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_1.png)\n\n이 튜토리얼에서는 이미지를 멋진 아트스타일로 변환하는 스타일 전송 모델을 사용할 것입니다. 만약 웹 및 비디오에 대해 비슷한 일을 하는 방법에 궁금하다면 이전 기사를 확인해보세요. 원하는 모델을 사용하고 싶다면 아래 스크립트를 사용할 수 있습니다. 이를 통해 CoreML 백엔드에 적합한 .pte 파일이 생성될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 라이브러리 빌드 및 설정하기\n\n실제 코딩 부분에 들어가기 전에, 라이브러리를 빌드하고 Xcode 프로젝트에 연결해야 합니다. 빌드 프로세스는 문서에서 자세히 설명되어 있으므로, 익숙해지는 것을 강력히 권장합니다. 그러나 우리는 이미 빌드했으며 편의를 위해 GitHub 저장소에서 빌드를 다운로드할 수 있습니다.\n\n라이브러리를 다운로드한 후 (coreml_backend.xcframework와 executorch.xcframework), Xcode 프로젝트로 이동하여 -` 빌드 패스 -` 라이브러리와 함께 링크하기 -` +를 클릭하여 프로젝트에 추가해야 합니다. 또한 Xcode에서 기본 제공되는 CoreML.framework와 Accelerate.framework도 추가해야 합니다.\n\n코딩에 들어가기 전에 빌드 설정 -` 다른 링커 플래그로 이동하여 -all_load 플래그를 추가해야 합니다. 이를 통해 라이브러리가 제대로 연결되도록 할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3. 코딩 파트 — Xcode\n\n구현으로 넘어가면 이제 Objective-C++ 파일을 만들어야 합니다. 이를 StyleTransferModule.mm으로 부르겠습니다. 우리 코드에서는 React Native 앱에서 네이티브 모듈을 사용하여 이 메서드를 호출합니다. 그러나 이것은 선택 사항이며 사용 사례에 맞게 조정할 수 있습니다.\n\n```js\n// StyleTransferModule.mm\n\n#import \"StyleTransferModule.h\"\n#import \"ImageProcessor.h\"\n#import \u003cexecutorch/extension/module/module.h\u003e\n\nusing namespace ::torch::executor;\n\nconst int32_t imageSize = 640;\nconst int32_t numChannels = 3;\n\n@implementation StyleTransferModule {\n  std::unique_ptr\u003cModule\u003e styleTransferModel;\n}\n\n\nRCT_EXPORT_METHOD(initModule:(NSString *)modelFileName resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {\n    NSString *styleTransferPath = [[NSBundle mainBundle] pathForResource:modelFileName ofType:@\"pte\"];\n    styleTransferModel= std::make_unique\u003cModule\u003e(styleTransferPath.UTF8String);\n\n    if (styleTransferModel) {\n        resolve(@\"Module created successfully\");\n    } else {\n        NSError *error = [NSError errorWithDomain:@\"com.example.module\" code:1 userInfo:nil];\n        reject(@\"module_error\", @\"Failed to create module\", error);\n    }\n}\n```\n\n먼저 Module 클래스의 인스턴스를 만들어야 합니다. 이는 ExecuTorch 프레임워크의 일부입니다. 이를 통해 모델의 forward()와 같은 내보낸 메서드를 호출할 수 있습니다. 클래스를 인스턴스화하려면 이전에 언급한 .pte 파일의 경로를 전달해야 합니다. 또한 RCT_EXPORT_METHOD 매크로를 사용하여 메서드를 JS로 내보냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델을 실행하기 전에 다음 단계는 입력 텐서를 준비하는 것입니다. 머신 러닝 프레임워크와 작업을 해본 적이 있다면 텐서에 익숙할 것입니다. 고수준에서 말하면, 이것은 GPU에서 실행할 수 있는 배열입니다.\n\n텐서를 만들려면 이미지의 원시 RGB 데이터를 가져와야 합니다. 저희 저장소에서는 여러 모델을 로드하기 때문에 코드가 약간 다릅니다. 하지만 간단하게 유지하기 위해 이 튜토리얼에서는 한 모델에 집중하겠습니다.\n\n```js\n// StyleTransferModule.mm\nRCT_EXPORT_METHOD(applyStyleTransfer:(NSString *)imageUri resolver:(RCTPromiseResolveBlock)resolve rejecter:(RCTPromiseRejectBlock)reject) {\n{\n    if (!styleTransferModel) {\n        reject(@\"module_error\", @\"Module not initialized\", [NSError errorWithDomain:@\"com.example.module\" code:1 userInfo:nil]);\n        return;\n    }\n\n    NSURL *url = [NSURL URLWithString:imageUri];\n    NSData *data = [NSData dataWithContentsOfURL:url];\n    if (!data) {\n      reject(@\"img_loading_error\", @\"Unable to load image data\", nil);\n      return;\n    }\n    UIImage *inputImage = [UIImage imageWithData:data];\n```\n\n다시 한번 해당 메서드를 JS에 내보냅니다. applyStyleTransfer라고 부르며, NSString 포인터를 받도록 만들었습니다. 이는 표준 JS 문자열과 해당됩니다. 이 문자열은 우리 입력 이미지의 URI가 될 것입니다. 이제 모델이 예상하는 데이터 형식인 원시 RGB 데이터 배열을 만들어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// StyleTransferModule.mm\n// ...\n\n// StyleTransferModule.mm\n// ...\n\n  CGSize targetSize = CGSizeMake(imageSize, imageSize);\n  UIImage *resizedImage = [ImageProcessor resizeImage:inputImage toSize:targetSize];\n\n  // to float array - the input\n  float *imageData = [ImageProcessor imageToFloatArray:resizedImage size:\u0026targetSize];\n\n  // make it a tensor\n  int32_t sizes[] = {1, numChannels, imageSize, imageSize};\n  TensorImpl inputTensorImpl(ScalarType::Float, std::size(sizes), sizes, imageData);\n  Tensor inputTensor = Tensor(\u0026inputTensorImpl);\n\n이제 UIImage를 가져와서 사용자 정의 ImageProcessor에 전달합니다. 이것은 사용 사례와 모델에 따라 다양한 전처리 부분입니다. 여기서는 640x640 크기의 이미지 및 float 값 배열이 필요합니다. 크기 조정이 항상 필요한 것은 아니며 동적 입력 형태로 모델을 내보낼 수 있습니다. ImageProcessor가 정확히 무엇을 하는지 보려면 여기를 클릭하세요. 이후에는 해당 데이터로부터 텐서를 생성해야 하므로 데이터 및 텐서 크기를 TensorImpl 생성자에 전달해야 합니다. 마지막으로 TensorImpl을 Tensor 자체로 전달해야 합니다.\n\n다음 단계는 텐서를 모델에 전달하는 것입니다. 이 부분은 매우 간단합니다. 이전에 생성된 Tensor를 EValue로 래핑하고 벡터에 넣은 다음 forward() 메서드(또는 내보낸 다른 메서드)를 실행하기만 하면 됩니다. 벡터에 넣는 이유는 여러 입력을 예상하는 모델이 있기 때문입니다.\n\n// StyleTransferModule.mm\n// ...\n\nconst auto result = styleTransferModel-\u003eforward({EValue(inputTensor)});\nif (!result.ok()) {\nNSError *error = [NSError\n        errorWithDomain:@\"ModelForwardFailure\"\n        code:NSInteger(result.error())\n        userInfo:@{NSLocalizedDescriptionKey: [NSString stringWithFormat:@\"Failed to run forward on the torch module, error code: %i\", result.error()]}];\n  reject(@\"model_failure\", error.localizedDescription, error);\n}\nconst float *outputData = result-\u003eat(0).toTensor().const_data_ptr\u003cfloat\u003e();\nfree(imageData);\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추론 중에 오류가 발생했는지 확인하려면 .ok() 메서드를 호출하면 됩니다. outputData 변수는 모델 호출 결과에 대한 포인터입니다. 이는 분류 작업의 확률부터 LLM 출력까지 어떤 것이든 될 수 있습니다. 마지막으로 후속 처리 단계를 수행하고 출력 이미지 URI를 JS 쪽에 반환해야 합니다.\n\n// StyleTransferModule.mm\n// ...\n\nCGSize outputSize = CGSizeMake(imageSize, imageSize);\nUIImage *outputImage = [ImageProcessor imageFromFloatArray:outputData size:outputSize];\n\n// save img to tmp dir, return URI\nNSString *outputPath = [NSTemporaryDirectory() stringByAppendingPathComponent:@\"processed_image.png\"];\nif ([UIImagePNGRepresentation(outputImage) writeToFile:outputPath atomically:YES]) {\n  NSURL *fileURL = [NSURL fileURLWithPath:outputPath];\n  resolve([fileURL absoluteString]);\n} else {\n  reject(@\"img_write_error\", @\"Failed to write processed image to file\", nil);\n}\n\n그것이 거의 다입니다. 이 접근 방식을 React Native 앱에서 어떻게 사용할 수 있는지 보여주는 데모 앱을 준비했습니다. 왼쪽에 원본 이미지, 오른쪽에 모델 출력이 표시됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_2.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 마지막으로\n\n축하해요! 모델을 성공적으로 실행했어요. ExecuTorch는 LLaMa만큼 큰 모델도 완전히 기기에서 실행할 수 있게 해 주는 거대한 프레임워크야.\n\n이 시리즈의 다음 부분에서는 Android에서도 똑같이 할 수 있는 방법을 보여줄 거에요. 또한 곧 우리의 객체 제거 데모와 관련된 꽤 인상적인 기능을 구현하는 튜토리얼을 공개할 예정이에요 👀. 우리의 AI 및 멀티미디어 작업에 대해 계속해서 소식을 받고 싶다면 RTC.ON 소식지에 가입해주세요. 계속 연락을 유지해 주세요!\n\n우리는 소프트웨어 마스터즈(Software Mansion)입니다: 소프트웨어 개발 컨설턴트, AI 탐험가, 멀티미디어 전문가, React Native 코어 기여자 및 커뮤니티 빌더들이에요. 우리를 고용하고 싶다면 projects@swmansion.com 으로 연락해 주세요.\n```\n","ogImage":{"url":"/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_0.png"},"coverImage":"/assets/img/2024-06-19-BringingnativeAItoyourmobileappswithExecuTorchpartIiOS_0.png","tag":["Tech"],"readingTime":9},{"title":"iOS 모바일 앱 보안 iOS 모바일 개발자를 위한 최선의 모범 사례","description":"","date":"2024-06-19 14:06","slug":"2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers","content":"\n![image](/assets/img/2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers_0.png)\n\niOS 개발자들은 OWASP Top 10을 기반으로 코드 보안, 데이터 저장 및 통신 보안에 중점을 두어야 합니다. iOS는 안드로이드보다 취약성이 적지만 여전히 보안 문제에 직면합니다. 코드와 데이터 통신을 안전하게 보호하여 변조 및 무단 코드 접근을 방지하는 것은 개발자/조직의 책임입니다.\n\n개발자가 주의를 기울여야 할 초보 수준의 위협을 다루기 위해 모든 iOS 개발자는 다음을 주의깊게 살펴봐야 합니다:\n\n# 1. 화면 녹화 및 화면 캡처:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n공격자가 로그인 페이지와 입력된 사용자 이름 및 비밀번호를 캡처할 수 있는 민감한 화면을 녹화할 수 있습니다. 비디오 스트리밍 애플리케이션에서는 사용자가 유료 비디오 콘텐츠를 스트리밍하고 녹화할 수 있습니다.\n은행 애플리케이션에서 스크린샷이나 화면 녹화가 진행되면 민감한 거래 세부 정보가 노출될 수 있는 높은 위험이 있습니다.\n\n우리는 UIScreen.capturedDidChangeNotification을 관찰하고 UIScreen.main.isCaptured를 확인할 수 있습니다.\n\nNotificationCenter를 사용하여 isCaptured의 변경 사항을 관찰합니다:\n\n```js\nNotificationCenter.default.addObserver(self, selector: #selector(screenCaptureDidChange),\n                                       name: UIScreen.capturedDidChangeNotification,\n                                       object: nil)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알림 처리를 담당하는 함수입니다.\n\n```js\n@objc func screenCaptureDidChange() {\n    print(\"screenCaptureDidChange.. isCapturing: \\(UIScreen.main.isCaptured)\")\n\n    if UIScreen.main.isCaptured {\n        //TODO: They started capturing..\n        print(\"screenCaptureDidChange - 녹화 중입니다.\")\n    } else {\n        //TODO: They stopped capturing..\n        print(\"screenCaptureDidChange - 녹화가 중지되었습니다.\")\n    }\n}\n```\n\n# 2. 약한 탈옥 탐지:\n\n중요한 점은 탈옥된 기기에서 응용 프로그램 로직 및 동작이 손상될 수 있고, 이는 응용 프로그램을 공격에 노출시킬 수 있습니다. 그러나 어떤 해커라도 이러한 기본 보안 확인을 우회할 수 있음을 인식하는 것이 중요합니다. 따라서 탈옥 탐지 방법에만 의존하여 응용 프로그램의 안전을 보장하는 것이 충분하지 않을 수 있다는 것을 명심하는 것이 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 텍스트는 기기가 탈옥되었는지 여부를 식별하는 데 관련된 지침 또는 지침으로 보입니다. 이 식별에 도움이 되는 세 가지 테스트가 포함되어 있습니다:\n\n- 기기가 탈옥되었는지 여부를 식별하는 한 가지 방법은 탈옥된 기기에 설치된 고유한 파일 및 응용 프로그램을 확인하는 것입니다. 개발자는 이 테스트를 사용하여 파일 시스템에서 이러한 파일을 찾을 수 있습니다.\n\n```js\nprivate var filesPathToCheck: [String] {\n\n    return [\"/private/var/lib/apt\",\n            \"/Applications/Cydia.app\",\n            \"/private/var/lib/cydia\",\n            \"/private/var/tmp/cydia.log\",\n            \"/Applications/RockApp.app\",\n            \"/Applications/Icy.app\",\n            \"/Applications/WinterBoard.app\",\n            \"/Applications/SBSetttings.app\",\n            \"/Applications/blackra1n.app\",\n            \"/Applications/IntelliScreen.app\",\n            \"/Applications/Snoop-itConfig.app\",\n            \"/usr/libexec/cydia/\",\n            \"/usr/sbin/frida-server\",\n            \"/usr/bin/cycript\",\n            \"/usr/local/bin/cycript\",\n            \"/usr/lib/libcycript.dylib\",\n            \"/bin/sh\",\n            \"/usr/libexec/sftp-server\",\n            \"/usr/libexec/ssh-keysign\",\n            \"/Library/MobileSubstrate/MobileSubstrate.dylib\",\n            \"/bin/bash\",\n            \"/usr/sbin/sshd\",\n            \"/etc/apt\",\n            \"/usr/bin/ssh\",\n            \"/bin.sh\",\n            \"/var/checkra1n.dmg\",\n            \"/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist\",\n            \"/System/Library/LaunchDaemons/com.ikey.bbot.plist\",\n            \"/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist\",\n            \"/Library/MobileSubstrate/DynamicLibraries/Veency.plist\"]\n}\n\nfunc isJailBrokenFilesPresentInTheDirectory() -\u003e Bool{\n        var checkFileIfExist: Bool = false\n        filesPathToCheck.forEach {\n            checkFileIfExist =  fm.fileExists(atPath: $0) ? true : false\n            if checkFileIfExist{\n                return\n            }\n        }\n\n        return checkFileIfExist\n    }\n```\n\n2. 응용 프로그램이 탈옥되었는지 여부를 확인하는 또 다른 방법은 샌드박싱 규칙을 준수하는지 여부를 확인하는 것입니다. 파일이 응용 프로그램 번들 외부에서 수정될 수 있는지 확인함으로써 이를 식별할 수 있습니다. 개발자는 응용 프로그램이 샌드박싱 규칙을 준수하는지 확인하려면 이 테스트를 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nfunc canEditSandboxFilesForJailBreakDetection() -\u003e Bool {\n    let jailBreakTestText = \"JailBreak 테스트\"\n    do {\n        try jailBreakTestText.write(toFile: \"/private/jailBreakTestText.txt\", atomically: true, encoding: String.Encoding.utf8)\n        return true\n    } catch {\n        let resultJailBroken = isJailBrokenFilesPresentInTheDirectory()\n        return resultJailBroken\n    }\n}\n```\n\n3. 어플리케이션이 Cydia URL scheme (Cydia://)을 호출했을 때 성공하면, 기기가 탈옥되었다는 것을 의미합니다. 이 테스트는 개발자가 이 확인을 수행했는지를 확인합니다.\n\n```swift\n// JailBreak 감지를 위해 확장된 프로토콜 함수\nfunc assignJailBreakCheckType() -\u003e Bool {\n    // 시뮬레이터에서 실행 중이라면 앱의 일반 흐름을 따릅니다\n    if !isSimulator {\n        // 기기에 Cydia 앱이 설치되어 있는지 확인\n        guard UIApplication.shared.canOpenURL(URL(string: \"cydia://\")!) else {\n            return false\n        }\n        return true\n    }\n    return true\n}\n```\n\n# 3. 키체인 데이터 보호:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJailBroken 기기에서 취약한 접근성 옵션을 가진 키 체인 항목이 다른 애플리케이션이나 물리적으로 접근하는 공격자에게 쉽게 노출될 수 있습니다. 그러나 개발자는 이 보안 위험을 완화하기 위해 여러 작업을 선택할 수 있습니다.\n\n- kSecAttrAccessibleWhenUnlocked\n- kSecAttrAccessibleAfterFirstUnlock\n- kSecAttrAccessibleAlways\n- kSecAttrAccessibleWhenUnlockedThisDeviceOnly\n- kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly\n- kSecAttrAccessibleAlwaysThisDeviceOnly\n\n'kSecAttrAccessibleWhenUnlocked'와 같이 가장 쉬운 또는 취약할 가능성이 있는 옵션을 선택하는 것은 잠재적인 보안 위험을 유발할 수 있습니다.\n\n`kSecAttrAccessibleAfterFirstUnlock` 또는 `kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly` 모드는 애플리케이션이 백그라운드 처리를 위해 키체인 항목이 필요한 경우에만 사용해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4. 파일 데이터 보호:\n\n새 파일을 저장할 때, 개발자는 다음 옵션 중 하나를 선택하여 데이터 보호에 더 나은 이용 방법을 선택할 수 있습니다:\n\n- atomic:\n  데이터를 먼저 보조 파일로 작성한 다음 쓰기가 완료되면 원본 파일을 보조 파일로 교체하는 옵션입니다.\n- withoutOverwriting:\n  파일에 데이터를 작성하려고 하지만 대상 파일이 이미 존재하는 경우 실패하고 에러가 발생하는 옵션입니다.\n- noFileProtection:\n  파일을 쓸 때 암호화하지 않는 옵션입니다.\n- completeFileProtection:\n  장치의 잠금이 해제된 상태에서만 파일에 접근할 수 있는 옵션입니다.\n- completeFileProtectionUnlessOpen:\n  장치가 잠금 해제된 상태이거나 파일이 이미 열려 있는 경우에만 파일에 접근할 수 있는 옵션입니다.\n- completeFileProtectionUntilFirstUserAuthentication:\n  사용자가 장치를 처음 잠금 해제한 후에만 파일에 접근할 수 있는 옵션입니다.\n- fileProtectionMask:\n  시스템이 데이터에 할당하는 파일 보호 옵션을 결정할 때 사용되는 옵션입니다.\n\n'NSFileProtectionNone'과 같이 가장 쉬운 또는 취약성이 높은 옵션을 선택하는 것은 잠재적인 보안 위험을 초래할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 파일에 데이터 보호를 제공하려면 'completeFileProtectionUnlessOpen' 및 'completeFileProtectionUntilFirstUserAuthentication'을 사용하는 것이 좋습니다.\n\n첫 번째 쓰기 시 파일 암호화\n\n```js\ndo {\n    try data.write(to: fileURL, options: .completeFileProtection)\n}\ncatch {\n   // 오류 처리.\n}\n```\n\n기존 파일의 경우 NSFileManager/FileManager 또는 NSURL을 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nFileManager.default.setAttributes([.protectionKey: .completeFileProtection], ofItemAtPath: fileURL.path)\n// 또는\n// `fileProtection` 속성은 읽기 전용이므로 `NSURL`로 캐스트합니다.\n(fileURL as NSURL).setResourceValue(URLFileProtection.complete, forKey: .fileProtectionKey)\n```\n\nCore Data를 사용하면 영구 저장소를 추가할 때 보호 유형을 전달할 수 있습니다:\n\n```js\npersistentStoreCoordinator.addPersistentStore(ofType: NSSQLiteStoreType, configurationName: nil, at: storeURL, options: [NSPersistentStoreFileProtectionKey: .completeFileProtection])\n```\n\n# 5. 암호 필드 표시/숨기기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어플리케이션 비밀번호가 로그인 화면 및 기타 민감한 정보 화면을 녹화하는 동안 노출될 수 있습니다.\n\n녹화된 화면을 식별하면, 패스워드 텍스트 필드 또는 다른 민감한 텍스트 필드에 '마스크'를 사용하여 데이터 보안을 보호해주세요.\n어플이 녹화 중일 때는 키보드를 숨기거나 없애주세요.\n\n```js\nif(isRecording){\n    let maskView = UIView(frame: CGRect(x: 64, y: 0, width: 128, height: 128))\n    maskView.backgroundColor = .blue\n    maskView.layer.cornerRadius = 64\n    yourView.mask = maskView\n}\n```\n\n# 6. SSL 인증서 만료일:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 인증서는 1년 동안 유효하며 작업을 계속하려면 갱신이 필요합니다. 갱신이 제때 완료되지 않으면 앱이 작동을 멈출 수 있습니다.\n\n만료 날짜 이전에 인증서를 갱신하고 IPA를 업데이트하여 원활한 앱 기능을 보장하는 것이 좋습니다. 또한, 매번 실행할 때 인증서 만료를 확인하고 만료 날짜 몇 일 전에 새로운 인증서를 요청하는 것이 중요합니다.\n\n# 7. 인증서 핀 없음:\n\n공격자가 해당 도메인에 대한 유효한 인증서를 만들 수 있다면 사용자를 속여 안전한 웹사이트를 방문하고 있는 것으로 오해시킬 수 있습니다. 실제로는 사용자가 사칭된 웹사이트로 연결되는 상황이 됩니다. 이 공격은 `중간자 공격(Man-in-the-Middle attack)`으로 알려져 있으며 공격자가 사용자와 웹사이트 사이의 트래픽을 가로채고 해독하여 민감한 정보를 노출시키고 다른 취약점을 악용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 delegate가 구현해야 하는 내용입니다:\n\nURLSession:task:didReceiveChallenge:completionHandler:\n모든 연결을 인증서 인증을 통해 처리해야 합니다.\n\n```js\nfunc urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -\u003e Void) {\n  if let trust = challenge.protectionSpace.serverTrust, SecTrustGetCertificateCount(trust) \u003e 0 {\n    if let certificate = SecTrustGetCertificateAtIndex(trust, 0) {\n      let data = SecCertificateCopyData(certificate) as Data\n        if certificates.contains(data) {\n          completionHandler(.useCredential, URLCredential(trust: trust))\n          return\n         } else {\n           //TODO: Throw SSL Certificate Mismatch\n         }\n      }\n  }\n  completionHandler(.cancelAuthenticationChallenge, nil)\n}\n```\n\n# 8. HTTP 요청의 사용법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플리케이션은 안전하지 않은 통신 채널(HTTP)을 사용합니다. 이는 피해자와 동일한 네트워크에 있는 공격자가 공격자가 제어하는 서버로의 301 HTTP 리디렉션 응답을 주입하여 중간자 공격을 수행할 수 있다는 것을 의미합니다.\n\n## 9. 개인 정보 자원 액세스:\n\n애플리케이션은 연락처, 위치, 블루투스 장치 ID, 카메라 및 마이크와 같은 개인 장치 및/또는 사용자 자원에 액세스할 수 있습니다. 그러나 이는 데이터가 인터넷을 통해 평문으로 전송될 경우 데이터 유출로 이어질 수 있습니다. 이를 방지하기 위해 개발자는 이러한 자원에 대한 액세스가 안전한 정책을 따르도록 보장해야 합니다. 즉, 데이터를 서버로 전송하기 전에 암호화한다는 것입니다. 또한, 자원에 안전하지 않은 액세스 방식을 사용하는 써드파티 라이브러리가 사용 중이 아닌지 확인하는 것이 중요합니다. 개인 자원에 대한 모든 액세스를 검증하고 보안 정책을 준수하도록 강제해야 합니다. 광고 식별자나 ABAddressBookRef 등을 사용하는 경우와 같이요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 10. 디버그 로그 활성화:\n\n릴리스 빌드에서는 메소드 완료 세부 정보와 민감한 정보를 출력하는 디버그 로그를 피해야 합니다.\n\n#ifDef DEBUG 또는 디버그 빌드에서만 debug=1을 활성화하십시오. NSLog는 엄격히 피해야 합니다.\n\n```js\n#ifdef DEBUG\nprint(\"로그 문구\")\n#endif\n```\n","ogImage":{"url":"/assets/img/2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers_0.png"},"coverImage":"/assets/img/2024-06-19-IOSMobileAppSecurityBestPracticesforiOSMobileDevelopers_0.png","tag":["Tech"],"readingTime":13},{"title":"iOS 빌드 시스템을 Buck에서 Bazel로 전환하기","description":"","date":"2024-06-19 14:05","slug":"2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel","content":"\n\u003cimg src=\"/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_0.png\" /\u003e\n\n## Airbnb은 Buck에서 Bazel로의 iOS 움직임을 효율적이고 투명하게 성공적으로 달성했습니다. 개발자의 작업에 최소한의 방해를 주면서요.\n\n작성자: Qing Yang, Andy Bartholomew\n\nAirbnb에서는 엔지니어들에게 최고의 경험을 제공하기 위해 노력하고 있습니다. 모든 플랫폼에서 일관되고 효율적인 빌드 경험을 제공하기 위해 저희는 빌드 시스템으로 Bazel을 도입하기로 결정했습니다. Bazel은 산업에서 널리 사용되는 견고한 빌드 시스템입니다. Airbnb의 기술 계획에 부합하여, 백엔드 및 프론트엔드 팀은 모두 Bazel로의 이관 프로세스를 시작했습니다. 첫 번째 Bazel 포스트에서는 iOS 개발에서 Buck에서 Bazel로의 이관 작업에 대해 시작합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희는 두 가지 주요 작업으로 구성된 이주 접근 방식을 설명하겠습니다: 빌드 구성 이주 및 IDE 통합 이주. 이러한 전환은 엔지니어들의 작업 흐름을 방해하거나 새로운 기능 개발을 저해할 수 있지만, 우리는 개발자들의 일상 경험을 방해하지 않고 성공적으로 이주할 수 있었습니다. 저희 목표는 현재 유사한 이주를 진행하고 있는 분들이나 이와 유사한 이주를 계획 중인 분들을 도와드릴 수 있도록 하는 것입니다.\n\n# 빌드 구성 이주\n\n빌드 구성에 관련하여, Buck와 Bazel은 상당한 유사성을 보여줍니다. 두 빌드 시스템은 유사한 디렉토리 구조를 사용하고 유도 명령어 호출도 비슷하며 중요한 것은 둘 다 Starlark 언어를 사용한다는 점입니다. 이러한 유사성은 두 빌드 시스템 간의 구성 공유 기회를 제공합니다. 이를 통해 우리는 Buck 구성을 Bazel에서 재사용할 수 있게 되었고, 두 빌드 시스템을 모두 사용하면서 이주를 진행하고 있는 \"중첩\" 단계에서 지연을 피할 수 있었습니다.\n\n하지만, Buck와 Bazel은 서로 다른 매개변수를 가진 구별된 규칙을 사용합니다. 예를 들어, Buck은 apple_library 및 apple_binary와 같은 규칙을 제공하는 반면, Bazel은 외부 규칙 세트에 따라 swift_library와 apple_framework와 같은 규칙을 갖습니다. 두 시스템 모두 genrule과 같은 이름의 규칙이 있는 경우라도, 해당 규칙을 구성하는 구문은 종종 다릅니다. 이 두 시스템의 다른 디자인 철학은 다양한 호환성 문제로 이어집니다. 예를 들어, Bazel은 macro에서 명령줄 옵션을 읽는 read_config 함수를 갖고 있지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## rules_shim으로 차이점 숨기기\n\nBuck와 Bazel의 심층 분석을 수행한 후, 두 시스템 간의 차이점을 해결하고 유사성을 활용하기 위해 빌드 구성에 대한 포괄적인 아키텍처를 개발했습니다.\n\n![이미지](/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_1.png)\n\n이 아키텍처의 핵심에는 rules_shim 레이어가 있으며, Buck와 Bazel을 위한 두 세트의 규칙을 도입합니다. 이 규칙 세트는 네이티브 및 외부 규칙 주변에 래퍼 역할을 하여 상위 레이어에 대한 통합된 인터페이스를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nrules_shim이 정확히 어떻게 작동하는지 궁금하신가요? 로컬 저장소를 활용하여 rules_shim 저장소를 빌드 시스템에 따라 다른 구현으로 지정할 수 있습니다.\n\nBuck의 .buckconfig에서 결과물이 어떻게 나타나는지 살펴보겠습니다:\n\n```js\n[repositories];\nrules_shim = rules_shim / buck[buildfile];\nname = BUILD;\n```\n\n또한, 이미 존재하는 BUCK 파일들을 BUILD로 이름을 변경하고 Buck에서도 config 파일로 사용하도록 설정했으므로, Buck와 Bazel에서 동일한 구성을 인식할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBazel의 WORKSPACE에서는 다음을 수행합니다:\n\n```js\nlocal_repository((name = \"rules_shim\"), (path = \"rules_shim/bazel\"));\n```\n\n일반적인 BUILD 파일에서는 my_library를 사용하여 네이티브 규칙을 감싸고 각 애플리케이션에 동일한 인터페이스를 제공합니다:\n\n```js\nload(\"@rules_shim//:defs.bzl\", \"my_library\", …)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱별 규칙 레이어는 구현이 아닌 인터페이스만을 알아야 합니다. 그 결과로 Buck 또는 Bazel 명령을 실행할 때, 빌드 시스템은 rules_shim 레이어에서 해당 구현을 검색할 수 있습니다. 이 설계의 주목할만한 장점은 마이그레이션 이후에 rules_shim/buck를 쉽게 제거할 수 있다는 것입니다.\n\n## genrule 인터페이스 통합\n\n우리 iOS 코드베이스 내에서, 우리는 생성된 코드에 많이 의존하여 엔지니어들에 대한 유지관리 부담을 줄이는 데 사용합니다. 두 빌드 시스템 간 genrule 스크립트의 다른 구문 때문에, 우리는 genrule을 위한 통합된 인터페이스를 설계했습니다. 이로 인해 동일한 genrule 스크립트가 두 빌드 시스템 모두에서 작동할 수 있습니다. 아마도 이미 추측했겠지만, 변환 과정은 rules_shim 레이어에서 구현되었습니다.\n\n![링크 텍스트](/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## read_config을 select로 교체하기\n\n조건부 구성은 피할 수 없습니다. 왜냐하면 디버그 빌드와 릴리스 빌드와 같은 빌드 제품의 다양한 변형이 항상 있기 때문입니다. Buck은 매크로에서 명령줄 옵션을 읽는 read_config라는 함수를 제공하지만, Bazel은 로딩 단계의 엄격한 분리로 인해 이 기능을 제공하지 않습니다. Buck은 select 함수를 지원하지만 문서화되어 있지 않습니다. 따라서 우리는 모든 read_config 인스턴스를 select 기반 조건으로 마이그레이션했습니다.\n\n```js\ndeps = select({\n  \"//:DebugBuild\": non_production_deps,\n  \"//:ReleaseBuild\": [],\n  # SELECT_DEFAULT는 Buck과 Bazel에서 사용하는 서로 다른 기본 문자열을 고려하기 위해 rules_shim에서 정의됩니다\n  SELECT_DEFAULT: non_production_deps,\n}),\n```\n\n전체적으로, 이 설계를 통해 빌드 시스템의 빌드 구성을 단일로 활용하며, BUILD 파일 자체에는 최소한의 변경이 있습니다. 실제로 Airbnb의 iOS 엔지니어들은 주로 BUILD 파일을 수동으로 수정할 일이 거의 없습니다. 이 파일들은 주로 기본 소스 코드 분석을 통해 자동으로 업데이트됩니다. 그러나 파일을 직접 수정해야 하는 경우에는 특정 빌드 시스템에 대한 지식이 필요하지 않고 통합된 인터페이스에 의존할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# IDE 통합 마이그레이션\n\n에어비앤비의 iOS 엔지니어들은 주로 Xcode를 통해 빌드 시스템과 상호 작용합니다. 처음 Buck를 도입한 이후로, 우리는 로컬 개발을 위해 Buck에서 생성한 Xcode 워크스페이스를 활용해 왔습니다. 몇 년 동안 이러한 설정 위에 다양한 생산성 향상 기능을 개발했습니다. 이에는 단일 모듈에 초점을 맞춘 작은 개발 애플리케이션인 Dev App, 빌드 및 원격 캐시를 활용하는 Buck Local 및 IDE 성능을 크게 향상시키는 Focus Xcode 워크스페이스도 포함됩니다. 이는 작업 중인 모듈만로드하여 IDE 성능을 크게 향상시킵니다.\n\nBazel 생태계에서는 Xcode 워크스페이스를 생성하기 위한 다양한 솔루션이 존재합니다. 그러나 우리가 평가할 당시, 이 중 어떤 것도 우리의 요구 사항을 완벽하게 충족하지 못했습니다. 또한 IDE 통합은 빌드뿐만 아니라 편집, 색인, 테스트 및 디버깅도 지원해야 합니다. 현재의 워크스페이스 설정이 검증된 track record와 안정성을 가지고 있기 때문에 완전히 새로운 것으로 전환하는 위험이 너무 높다고 판단했습니다. 그래서 우리는 현재의 설정과 유사한 워크스페이스를 생성하기 위해 우리만의 생성자를 개발하기로 결정했습니다. 빌드 시스템 구현 세부 사항을 분리하기 위한 추상화 계층으로 작동하는 YAML 구성에서 Xcode 프로젝트를 생성하는 인기 있는 도구 인 XcodeGen을 선택했습니다.\n\n![이미지](/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 세 단계로 구성된 마이그레이션 프로세스를 구현했어요.\n\n첫째로, 우리는 코드베이스에서 필요한 모든 정보를 수집하고 Xcode 워크스페이스를 생성하기 위해 buck query를 활용했어요. 이 과정에서 buck project 명령을 대체했어요. 이 새로운 워크스페이스는 빌드 프로세스 중에 buck build를 호출했어요. 빌드 시스템을 변경하지 않고 유지함으로써, 새로운 생성기의 성능을 평가하고 호환성을 보장했어요.\n\n둘째로, 우리는 Bazel을 사용하여 bazel query와 bazel build에서 병렬 구현을 수행했어요. 생성 스크립트에 간단한 --bazel 옵션을 통합하여 Xcode 내에서 두 빌드 시스템 간에 전환할 수 있는 기능을 추가했어요. 빌드 시스템 외에는 사용자 인터페이스가 동일하게 유지되어, IDE 작업이 이전과 동일하게 작동하도록 보장했어요.\n\n마지막으로, 충분한 수의 사용자가 Bazel을 선택하고 모든 Bazel 기능이 철저히 테스트를 거친 후, --bazel 옵션을 기본값으로 설정하여 Bazel로의 원활한 전환을 완료했어요. 문제가 발생했다면 손쉽게 롤백할 수 있는 선택권이 있었어요. 수주 후에는 생성된 프로젝트에서 Buck 지원을 제거했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 마이그레이션의 최종 결과는 인상적입니다. Buck로 생성된 프로젝트와 비교하여 XcodeGen을 사용한 생성 시간이 60% 줄어들었고, Xcode의 오픈 시간도 70% 이상 감소했습니다. 이로 인해 이 새로운 워크스페이스 설정은 내부 개발자 경험 조사에서 최상위 순위를 차지하며, 이 프로세스를 통해 달성된 중요한 개선 사항을 보여주었습니다.\n\n# 마이그레이션 완료 및 전망\n\nBuck를 사용한 부분에 대해 공통 인터페이스 추상화를 도입하고 Buck와 Bazel 간의 차이를 처리하기 위해 별도의 구현을 삽입했습니다. \"간접\" 원칙 덕분에 코드를 크게 재작성하지 않고 각 구현을 테스트하고 업데이트할 수 있었으며, 로컬 개발, CI 테스트 및 릴리스를 포함한 모든 사용 사례에서 부드럽게 Buck에서 Bazel로 이전하는 데 성공했습니다. 이 마이그레이션 프로세스는 엔지니어들의 작업 흐름을 방해하지 않고 실행되었으며, 실제로 SwiftUI 미리보기 지원을 포함한 여러 새로운 기능을 제공할 수 있었습니다.\n\nBazel이 iOS 빌드 시스템이 된 후, 증분 빌드에 특히 빌드 시간이 크게 개선되었음을 관찰했습니다. 이러한 전환으로 인해 Airbnb 내에서 원격 캐시와 같은 공유 인프라를 활용할 수 있게 되었으며, 결과적으로 여러 플랫폼 간의 협업이 촉진되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 iOS 빌드 시스템을 이전하는 것은 에어비앤비에서 진행 중이거나 완료된 여러 Bazel 마이그레이션 중 첫 번째입니다. 저희는 Java/Kotlin/Scala로 된 JVM 기반 언어, JavaScript, Go용 리포지토리를 보유하고 있는데, 이미 Bazel을 사용 중인 것이나 미래에 사용할 것입니다. 전체 코드베이스에 걸쳐 함께 사용되는 단일 빌드 도구를 믿고 있어서 빌드 도구 및 교육에 대한 투자를 효과적으로 활용할 수 있을 것으로 기대합니다. 미래에는 다른 Bazel 마이그레이션에서 얻은 교훈을 공유할 예정입니다.\n\niOS Bazel 마이그레이션의 기술 리드인 Qing Yang은 구성 아키텍처와 새 프로젝트 생성기를 설계하고 구현했습니다. Andy Bartholomew는 모든 테스트의 마이그레이션을 이끌었고 스크립트 추상화 레이어를 구현했습니다. Xianwen Chen은 Bazel의 릴리스 빌드를 마이그레이션하고 관리했습니다.\n\n에어비앤비 내의 다수의 Bazel 전문가로부터 받은 귀중한 지원에 무한한 감사를 표합니다. 특히 Janusz Kudelka에게는 주제에 대한 소중한 조언과 지도를 제공해 준 것에 대해 특별히 감사드립니다.\n\n또한 Bazel iOS 커뮤니티에 우리의 마이그레이션 여정 동안 제공해준 다양한 오픈 소스 프로젝트와 지원에 대해 감사의 마음을 전합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희가 App Store에서 최고의 iOS 앱을 만들기 위한 여정에 참여하고 싶으시다면, 열려 있는 iOS 및 개발자 플랫폼 직무를 확인해주세요.\n\n모든 제품 이름, 로고 및 브랜드는 각 소유자들의 소유입니다. 이 웹사이트에서 사용된 모든 회사, 제품 및 서비스 이름은 식별 목적으로만 사용되었습니다. 이러한 이름, 로고 및 브랜드의 사용은 승인을 시사하지 않습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_0.png"},"coverImage":"/assets/img/2024-06-19-MigratingOuriOSBuildSystemfromBucktoBazel_0.png","tag":["Tech"],"readingTime":10}],"page":"38","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"38"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>