<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/38" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/38" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="AWS 프로젝트 시간 예측 그건 그냥 제안일 뿐이에요" href="/post/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS 프로젝트 시간 예측 그건 그냥 제안일 뿐이에요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS 프로젝트 시간 예측 그건 그냥 제안일 뿐이에요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS 프로젝트 시간 예측 그건 그냥 제안일 뿐이에요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법" href="/post/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="퀘스트 3용으로 제작된 18가지 혼합 현실 게임을 소개합니다" href="/post/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="퀘스트 3용으로 제작된 18가지 혼합 현실 게임을 소개합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="퀘스트 3용으로 제작된 18가지 혼합 현실 게임을 소개합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">퀘스트 3용으로 제작된 18가지 혼합 현실 게임을 소개합니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="게임 엔진을 위한 저지연 스크립팅 소개, 파트 2" href="/post/2024-06-19-AnIntroductiontoLow-LatencyScriptingforGameEnginesPart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="게임 엔진을 위한 저지연 스크립팅 소개, 파트 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AnIntroductiontoLow-LatencyScriptingforGameEnginesPart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="게임 엔진을 위한 저지연 스크립팅 소개, 파트 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">게임 엔진을 위한 저지연 스크립팅 소개, 파트 2</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="게임 개발자를 위한 생성적 AI의 활용 방안 2024년 6월판" href="/post/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="게임 개발자를 위한 생성적 AI의 활용 방안 2024년 6월판" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="게임 개발자를 위한 생성적 AI의 활용 방안 2024년 6월판" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">게임 개발자를 위한 생성적 AI의 활용 방안 2024년 6월판</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="유니티 실시간 멀티플레이어, 파트 8 사용 가능한 네트워킹 솔루션 탐색" href="/post/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="유니티 실시간 멀티플레이어, 파트 8 사용 가능한 네트워킹 솔루션 탐색" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="유니티 실시간 멀티플레이어, 파트 8 사용 가능한 네트워킹 솔루션 탐색" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">유니티 실시간 멀티플레이어, 파트 8 사용 가능한 네트워킹 솔루션 탐색</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아무도 사지 않은 큰 마법 모험 게임" href="/post/2024-06-19-TheBigMagicalAdventureGameNoOneBought"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아무도 사지 않은 큰 마법 모험 게임" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-TheBigMagicalAdventureGameNoOneBought_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아무도 사지 않은 큰 마법 모험 게임" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">아무도 사지 않은 큰 마법 모험 게임</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="개발 일지 3 피곤해요" href="/post/2024-06-19-Devlog3Imtired"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="개발 일지 3 피곤해요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Devlog3Imtired_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="개발 일지 3 피곤해요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">개발 일지 3 피곤해요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="비트크래프트 속 제국" href="/post/2024-06-19-EmpiresinBitCraft"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="비트크래프트 속 제국" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-EmpiresinBitCraft_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="비트크래프트 속 제국" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">비트크래프트 속 제국</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파 크라이 5의 매끄러운 오픈 월드 디자인이 대박이야" href="/post/2024-06-19-FarCry5sSeamlessOpenWorldDesignisAwesome"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파 크라이 5의 매끄러운 오픈 월드 디자인이 대박이야" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FarCry5sSeamlessOpenWorldDesignisAwesome_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파 크라이 5의 매끄러운 오픈 월드 디자인이 대박이야" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">파 크라이 5의 매끄러운 오픈 월드 디자인이 대박이야</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link posts_-active__YVJEi" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"AWS 프로젝트 시간 예측 그건 그냥 제안일 뿐이에요","description":"","date":"2024-06-19 12:00","slug":"2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion","content":"\nAWS 프로젝트 지침을 따르는 것은 할머니의 전설적인 초콜릿 칩 쿠키 레시피를 따르는 것과 같아. 낡은 인덱스 카드에는 \"12분 동안 굽다\"고 적혀 있을지도 모르지만, 우리는 다들 할머니가 영혼으로 측정한 게 분량 컵이 아니란 걸 알아. 클라우드에서 무언가를 구축할 때는 항상 제안된 시간보다 오래 코드 속에 팔 다쳐 있을 수밖에 없어.\n\n이런 이유로 나, 당신의 클라우드 전문가이자 친구인 쉐이가 여기 있어서 조언하려고 해: 그 프로젝트 시간 추정치는 실은 지침일 뿐이지, 신약의 진리는 아니라는 거야.\n\n특히 머신 러닝에 관한 이야기일 때 말이야!\n\n![/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_0.png]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 목표는 머신러닝에 초점을 맞춘 클라우드 어드보케이트가 되는 것입니다. 그래서 매일 한 프로젝트를 다루고 그 달콤한 (가끔은 조금 탄) 여정을 문서화하고 있어요.\n\n오늘의 프로젝트? 머신러닝 모델을 실시간 추론 엔드포인트에 배포하는 것이죠.\n\n![image](/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_1.png)\n\n쉽죠? 이게요, 상상해보세요: 재료 구비는 끝났지만, 그런데 여러분이 하나 중요한 재료를 놓치고 있는 걸 깨달았다는 거죠 — 이해력!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 제 빵 만들기 경험에서 배운 것들이 있어요:\n\n- 콘솔 변화: 할머니가 가끔 가장 좋아하는 주걱을 숨기는 것처럼, AWS 도구들은 종종 콘솔에서 자리를 옮기곤 해요. 한 분 동안 \"엔드포인트 생성\"이 여기 있었던 걸 분명 보았다고 생각하더니도 이젠 사라진 것 같아요! 걱정 마세요, 여기서 아마존 Q(AWS 내장 AI 챗봇)가 당신의 가장 친한 친구가 됩니다. 결국 그 빠진 도구는 전혀 다른 페이지에 숨어 있었던 거예요! 와, 여기 있네요! 이 예상치 못한 우회로로 +15분을 더하면 됩니다.\n- 문서 작성은 장식하기와 같아요: 제는 메모를 작성하고 어리버리한 비유를 만들며 다이어그램을 그리는 것을 좋아해요. 이것은 마치 과자에 장식을 하는 것 같아요 – 이런 방식으로 제가 더 잘 기억하고 전체 과정을 더 재미있게 만들어요! 하지만 장식하는 것처럼, 문서 작성은 프로젝트에 추가로 +30분이 걸려요. . . 어쨌든\n- 혼란스러운 개념? 심층 탐구 시간! 가끔 기술 용어가 전혀 이해가 되지 않을 때가 있어요. 그럴 땐 제 비밀 무기인 ChatGPT를 꺼내볼게요. 이 도구는 복잡한 개념을 예시 사용 사례와 함께 작은 조각으로 나눠줘요. 추가로 +45분을 더하게 되죠! (진짜로, 때로는 가장 좋은 학습이 호기심의 토끼 굴 속에서 일어나요).\n\n\u003cimg src=\"/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_2.png\" /\u003e\n\n최종 판정: 성공, 그리고 여분의 시간 한 잔 같이요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로젝트가 마침내 성공을 거두었어요! 내 모델을 배포했고, 많은 것을 배웠으며, 애매한 클라우드 개념을 이해하는 새로운 방법을 발견하기도 했어요. 하지만 여기서 중요한 점은 이겁니다: 프로젝트가 예상 시간보다 오래 걸린다고 좌절하지 마세요. 뜻밖의 학습 모험을 포용하고, 기억하세요, 가장 맛있는 쿠키(그리고 가장 멋진 머신 러닝 프로젝트)은 종종 좀 더 구워야 할 때 더 맛있어져요.\n\n그래서 다음에 AWS 프로젝트 예상을 보게 된다면, 한 줌의 소금과 미소와 함께 받아들이세요. 예상치 못한(그리고 교육적인) 경험이 기다리고 있을지도 몰라요!\n\nInstagram/TikTok에서 더 많은 콘텐츠를 만나보세요:\n\n@ShaeInTheCloud\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinkedIn:\n\n[데샤이 리다 프로필](https://www.linkedin.com/in/deshae-lyda/)\n\n#MachineLearning #AWS #CloudDeveloperAdvocate #CloudEngineer\n","ogImage":{"url":"/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_0.png"},"coverImage":"/assets/img/2024-06-19-ThoseAWSProjectTimeEstimatesHoneyThatsJustaSuggestion_0.png","tag":["Tech"],"readingTime":4},{"title":"구글 드라이브를 무료 클라우드 저장 공간 솔루션으로 활용하여 머신 러닝 데이터 동기화를 자동화하는 방법","description":"","date":"2024-06-19 11:59","slug":"2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata","content":"\nGoogle Drive은 문서와 미디어를 저장하는 데 탁월한 도구이지만, 상상해보세요: 어떻게 하면 앱의 데이터를 저장하는 데 사용할 수 있을까요? 네, 저도 구름에 멀티플레이어 게임 데이터를 안전하고 무료로 저장하는 방법을 고민하고 있었습니다. 이 기사에서는 기계 학습을 위해 게임 데이터를 Google Drive에 저장한 방법에 대해 설명하겠습니다.\n\n![이미지가 여기에 표시됩니다.](/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png)\n\n📢 안녕하세요, 이 기사에서 언급된 서비스 중 어느 것도 스폰서로서 제작되지 않았습니다. 제가 애플리케이션에서 직접 사용해보며 개발자로서의 경험을 공유하고자 합니다.\n\n📢 이 기사는 구글 서비스와의 인증을 위해 서비스 계정을 사용하는 데 어느 정도 익숙한 것으로 가정합니다. 서비스 계정 및 해당 링크를 통해 어떻게 생성하는지에 대해 더 알아볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 🤔 왜 구글 드라이브를 사용하게 된 걸까요?\n\n\"The Strategists\"의 승자를 예측하기 위한 머신 러닝 모델을 개발하는 도중, 모든 게임 데이터를 로컬 머신에 저장했습니다. 그 당시에는 그 방식이 합리적으로 느껴졌지만, 도커를 사용하여 게임을 컨테이너화하고 클라우드에 배포하기 시작하면서 몇 가지 의문이 생겼습니다.\n\n훈련된 모델을 도커 이미지에 포함해야 할까요? 게임을 한 번씩 진행할 때마다 모델을 다시 훈련하기 때문에 게임 데이터를 도커 이미지에 포함해야 할까요? 게임 데이터를 도커 이미지에 저장하는 것이 안전한 일일까요? 이러한 질문들을 고민하면서, 보안 위험이 있기 때문에 모델과 게임 데이터를 함께 도커 이미지에 포함시키지 말아야겠다는 결론에 도달했습니다.\n\n그래도 \"The Strategists\"를 배포할 때, 모든 게임 데이터와 예측 모델을 백엔드 도커 이미지에 포장해서 배포했습니다. 배포된 컨테이너에서 주기적으로 새로운 게임 데이터를 추출하는 아이디어도 고안했었죠. 이미 알 수 있겠지만, 이는 확장 가능한 해결책이 아니었습니다. 배포 단계에서 모델을 포장하지 않고 프로그래밍적으로 게임 데이터를 다운로드하고 업로드하며 훈련된 모델을 내보내야 한다는 것을 알았습니다. 그렇다면 어떻게 해야 할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 사용 사례에서는 Amazon S3 및 Google Cloud Storage와 같은 서비스를 탐색해 보았어요. 이전 글을 읽은 분들은 저의 의도를 알 거예요. 요금을 청구하지 않는 서비스를 찾았고, 호기심 많은 개발자로서 Google Drive를 사용하기로 결정했어요. Google Drive API를 사용해보고 싶었는데, 이는 Google Drive를 애플리케이션의 데이터 저장소로 사용하기 위한 기능을 프로토타입화하는 완벽한 기회였어요.\n\nGoogle Drive를 사용하여 프로덕션에 준비된 애플리케이션을 개발하는 것은 표준 산업 관행이 아니라는 점을 강조해야 해요. Amazon S3와 같은 서비스는 오브젝트 잠금 및 ID 및 액세스 관리를 포함한 더 넓은 범위의 기능을 제공해요. 게다가, Google Drive의 무료 계층은 15GB의 저장 공간으로 제한되어 있어요.\n\n# 🛠️ 게임 데이터 동기화 구현은 어떻게 이루어졌을까요?\n\n우선, 제가 어떻게 게임 데이터를 동기화하는지에 대해 이야기해볼게요. 제 로컬 설정에서는 The Strategists의 머신 러닝 워크플로를 설명해서 서버 시작 시 모델을 훈련시킨 다음, SpringBoot 기반의 백엔드 서비스는 각 게임 세션 후에 다시 훈련시켰어요. 이 훈련은 플레이어 투자 패턴을 CSV 파일로 내보낸 다음, 예측 모델 디렉토리에 게임 상태를 내보낸 후에 발생했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 내보내기 디렉토리에는 내보낸 CSV 파일이 모두 저장되어 있었기 때문에 훈련 스크립트는 이 데이터를 모두 로드하고 해당 데이터를 사용하여 모델을 훈련했습니다. 첫 번째 과제는 서버가 시작될 때 이 디렉토리를 채우는 것이었습니다. 훈련 스크립트가 예측 모델을 내보내기 위한 작업이 가능하도록 하려면 구글 드라이브 폴더에 있는 기존 CSV 파일을 업로드했습니다. 이 \"Downloads\" 폴더는 이제 게임 서버에서 사용 가능한 게임 데이터를 찾기 위해 참조되는 진실의 원천으로 제공됩니다.\n\n이 과제에 대처하기 위해 \"Downloads\" 폴더에서 이 CSV 파일들을 다운로드하는 Python 유틸리티를 아래 스니펫처럼 작성했습니다. 실제 코드는 여기에서 확인할 수 있습니다.\n\n```js\n# Google 서비스에 연결하기 위한 서버 자격 증명 생성\ncredentials = Credentials.from_service_account_file(filename=\"\u003cSERVICE_ACCOUNT_FILE의_경로\u003e\")\n\n# Google 드라이브 서비스 초기화\nservice = discovery.build(\"drive\", \"v3\", credentials=credentials)\n\n# \"Downloads\" 폴더에 있는 모든 CSV 파일 나열\nall_csv_files, page_token = [], None\nwhile True:\n\n  # 현재 페이지 토큰에 대해 csv 파일 나열\n  response = (\n    service.files().list(\n      q=f\"(mimeType='text/csv') and ('\u003cDOWNLOADS_폴더_ID\u003e' in parents)\",\n      spaces=\"drive\",\n      fields=\"nextPageToken, files(id, name)\",\n      pageToken=page_token\n    ).execute()\n  )\n\n  # 리스트에 csv 파일 추가\n  csv_files, page_token = response.get(\"files\", []), response.get(\"nextPageToken\", None)\n  all_csv_files.extend(csv_files)\n\n  # 더 많은 csv 파일이 있는지 확인\n  if page_token is None:\n    break\n\n# 나열된 모든 csv 파일 다운로드\nfor i, csv_file in enumerate(all_csv_files):\n\n  # csv 파일 메타데이터 가져오기\n  csv_file_id, csv_file_name = csv_file.get(\"id\"), csv_file.get(\"name\")\n\n  # csv 파일 바이트 가져오기\n  csv_bytes = io.BytesIO()\n  downloader = MediaIoBaseDownload(file, request)\n  downloaded = False\n  while downloaded is False:\n    status, downloaded = downloader.next_chunk()\n\n  # 파일 내용 저장\n  export_file_path = os.path.join(\"\u003c데이터_디렉토리\u003e\", csv_file_name)\n  with open(export_file_path, \"wb\") as csv:\n    csv.write(csv_bytes.getvalue())\n```\n\n구글 서비스 계정의 이메일 주소가 최소한 \"뷰어\" 권한으로 이 CSV 파일에 액세스할 수 있도록 이 \"Downloads\" 폴더를 공유하도록 반드시 확인해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 다운로드 문제를 해결했으니, 이제 새 CSV 파일을 Google 드라이브에 업로드하는 방법을 구현하기 시작했습니다. 이를 위해 \"Uploads\"라는 폴더를 만들었고, CSV 파일의 다운로드와 업로드를 위해 별도의 폴더를 유지했습니다. 새 CSV 파일이 다운로드 폴더로 이동하기 전에 먼저 제가 확인할 수 있도록 했습니다.\n\n다음 코드 조각은 이 \"Upload\" 폴더로 CSV 파일을 업로드한 방법입니다. 실제 코드는 여기에서 확인하실 수 있습니다.\n\n```js\n# 모든 로컬 csv 파일 나열\nlocal_csv_files = []\nfor file_name in os.listdir(\"\u003cDATA_DIRECTORY\u003e\"):\n  if file_name.endswith(\".csv\"):\n    local_csv_files.append(file_name)\n\n# 나열된 모든 로컬 csv 파일 다운로드\nfor i, local_csv_file in enumerate(local_csv_files):\n\n  # 업로드할 CSV 파일을 업로드 폴더에 업로드\n  local_csv_file_path = os.path.join(\"\u003cDATA_DIRECTORY\u003e\", local_csv_file)\n  mimeType = \"text/csv\"\n\n  body = {\n    \"name\": local_csv_file,\n    \"mimeType\": mimeType,\n    \"parents\": [\"\u003cUPLOADS_FOLDER_ID\u003e\"]\n  }\n  media = MediaFileUpload(local_csv_file_path, mimetype=mimeType)\n  file = service.files().create(body=body, media_body=media, fields=\"id\")\n```\n\n스크립트가 새 CSV 파일을 업로드할 수 있도록 Google 서비스 계정 이메일 주소에 적어도 \"편집자\" 권한으로 이 \"Uploads\" 폴더를 공유해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 코드 구현에서는 서버 데이터 디렉토리에 있는 CSV 파일만 다운로드했습니다. 업로드에 대해선 \"다운로드\" 또는 \"업로드\" 구글 드라이브 폴더에 이미 존재하지 않은 CSV 파일만 업로드했습니다.\n\n이 기사가 여러분이 응용 프로그램의 무료 클라우드 저장소로 Google 드라이브를 어떻게 사용하는지 이해하는 데 도움이 되었으면 좋겠습니다. The Strategists의 개발을 계속 따르고 싶다면 제 블로그를 구독해보세요. 프로젝트에 기여하는 것을 고려해주시고, 다음 링크를 통해 GitHub의 프로젝트 저장소에 액세스할 수 있습니다.\n\n제 포트폴리오를 확인해보세요. 시간 내어 이 기사를 읽어주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png"},"coverImage":"/assets/img/2024-06-19-HowdidIuseGoogleDriveasafreecloudstoragesolutiontoautomatesyncingmyMachineLearningdata_0.png","tag":["Tech"],"readingTime":7},{"title":"퀘스트 3용으로 제작된 18가지 혼합 현실 게임을 소개합니다","description":"","date":"2024-06-19 11:57","slug":"2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay","content":"\n## 사이드퀘스트가 추천하는 당신을 위한 최고의 혼합 현실 게임: MR-ready Quest 3에서 즐기세요!\n\n![2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_0.png](/assets/img/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_0.png)\n\n메타 퀘스트 3이 퀘스트 2보다 한층 더 놀라운 점 중 하나는 완전한 컬러 패스스루(full-color passthrough) 및 이로 인해 제공할 수 있는 혼합/증강 현실 경험입니다. 실제로, 이는 일반적으로 보다 강력하며, 이 강력함을 확인하고 싶다면 이 목록의 20개 무료 VR 게임을 확인해보세요!\n\n하지만, 퀘스트 3의 크게 향상된 혼합 현실을 활용하기 위해 당신이 지금 당장 SideQuest에서 시도할 수 있는 최고의 18개 MR 경험 목록을 만들었습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. Track Craft\n\nTrack Craft는 RC 레이싱과 스팅팅이 혼합된 독특한 Mixed Reality 경험을 즐기세요! 새로운 트랙과 차량을 잠금 해제하여 차고에 추가하고, 내장된 도전 과제와 타임 트라이얼에 도전하고, 직관적인 트랙 편집기를 사용하여 자신의 실제 게임 공간을 RC 천국으로 변신시킬 수도 있습니다!\n\nTrack Craft는 매우 세련된 MR 즐거움이며 실제로 2023 인디 스포트라이트에서 다루었는데, 이를 이 기사의 끝에서 시청할 수 있습니다!\n\n## [Track Craft 다운로드하기!]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. CoasterMania\n\n**CoasterMania**로 당신의 거실을 극한의 테마파크로 변신하세요!\n\n**Track Craft**와 마찬가지로 **CoasterMania**는 집 안 공간에서 꿈꾸던 롤러 코스터를 디자인하고 형태를 만들 수 있는 전례없는 창의적인 옵션을 제공합니다. 그리고 나서 그 차에 올라타서 당신이 만든 코스터를 체험할 수 있습니다. 이 게임은 현재 초기 액세스 단계에 있지만, 업데이트는 계속해서 빠르게 제공될 예정이니, 개발자들에게 귀중한 피드백을 SideQuest에서 꼭 남겨주세요.\n\n## [CoasterMania 다운로드하기!]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. Cubism\n\nCubism의 점점 어려워지는 퍼즐들로 두뇌를 도전하고 즐거움을 느껴보세요. 완전한 핸드 트래킹 지원, 라이트와 다크 모드, 두 개의 캠페인, 지역 퍼즐 편집기를 통해, 이 공간 퍼즐 보석과 함께 아담 새비지와 함께 하루의 '첫 커피를 마시게 될 때' 두뇌를 활성화하세요. Cubism는 SideQuest에서 시작된 최초의 게임 중 하나이며, 공식 메타 스토어로 진출하여 엄청난 인기를 끌고 있으니 계속해서 소개해 주는 것에 열정적입니다!\n\n## [Cubism 다운로드]\n\n# 4. Puzzling Places\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nVR로 즐기는 신선한 3D 직소퍼즐링이 'Puzzling Places'로 등장했습니다. 이것은 외부 세계를 잊고 마음을 단련시키는 뛰어난 방법으로, 자세한 사진촬영 스캔을 통해 정성스럽게 재현된 21개의 멋진 실제 세계 퍼즐 중 하나로 도망가 보세요. 각 퍼즐은 여러 난이도로 제공되어 직소퍼즐 실력을 테스트할 수 있습니다. 이것은 SideQuest에서 공식 스토어로 이동한 또 하나의 공을 드리는 제목이며, 여러분의 시간을 100% 충분히 가치 있는 시간으로 만들어 줄 것입니다.\n\n## [Puzzling Places 다운로드하기]\n\n# 5. Dungeon Maker\n\n'Dungeon Maker'로 '바닥이 용암이다'를 더 진보된 수준으로 가져오세요. 이 앱은 투과 모드에서 자신만의 맞춤 던전을 만들고 함정, 함정, 적들, 용암 통행 및 기타 도전 과제를 설정할 수 있습니다. 그리고 가장 중요한 것은: 완전히 무료로 즐길 수 있습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## [던전 메이커 무료로 받으세요!]\n\n# 6. 미라클 풀\n\n미라클 풀은 혼합 현실의 가장 훌륭한 예 중 하나로, 집 안 공간에 실제와 같은 크기의 가상 풀 테이블을 가져왔습니다. 그 위엔 마치 진짜처럼 보이는 텍스처가 있어, 진짜 것인 줄 알았을 정도입니다. 뿐만 아니라 만족스러운 물리학과 현실적인 게임 플레이로, 미라클 풀은 VR에서 풀을 즐기는 최고의 방법입니다!\n\n## [미라클 풀 다운로드하기!]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 7. 히트스트림\n\n히트스트림은 여가 시간에 단독 개발자가 만든 것이며, 즐겁고 빠르며 치열한 운동뿐만 아니라 MR이 체험을 더 높이는 데 사용될 수 있는 훌륭한 예시입니다. 땀을 흘리면서 운동을 즐길 때 어떤 것에 부딪힐 걱정도 없습니다!\n\n## [무료 데모 플레이!]\n\n## [히트스트림 다운로드!]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 8. 피아노 비전\n\n우리는 2023 인디 스포트라이트에 피아노 비전도 포함했는데, 이 앱은 SideQuest에서 가장 우수한 음악 앱 중 하나로 한 번 더 인정받아야 합니다! 최고 수준의 MR 기능과 핸드 트래킹 기능을 갖추고 있어, 새로운 피아노 스킬을 배우거나 초보자로서 건반을 연주해 보고 싶다면, 피아노 비전이 당신을 훌륭하게 만졌습니다.\n\n## [피아노 비전 다운로드하기!]\n\n# 9. 공간 작전\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n재미있고 열정적이며 완전 무료로 즐길 수 있어요—단지 Quest 3 부대를 가져와서 강렵한 FPS 액션에 대비하세요. Spatial Ops는 혼합 현실로 완전히 이루어진 멀티플레이 도시 전투터로 어떠한 실제 공간을도 온전히 바꿀 수 있어요. 인상적인 MR 기술을 최대한 활용할 수 있는 충분히 넓은 지역을 선택해보세요!\n\n## [Spatial Ops를 무료로 받아보세요!]\n\n# 10. Smash Drums\n\n다른 인기있는 SideQuest의 탈출 ‘smash’ 히트곡인 Smash Drums은 무대에서 드럼 연주의 즐거움을 당신의 거실에서 느낄 수 있게 해줘요. 현재 46곡의 클래식 트랙과 곧 추가될 더 많은 곡을 함께 드럼 연주할 수 있는 Smash Drums은 Quest 3의 MR 능력을 완전히 활용한 훌륭한 리듬 게임입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## [스매시 드럼 받기!]\n\n# 11. 장난감 몬스터\n\n장난감 몬스터는 손 추적과 혼합 현실을 염두에 두고 처음부터 만들어진 독창적인 타워 방어 게임입니다. MR에서 식물 대 좀비를 생각해보세요. 이런 비교를 할 때 기대되는 매력, 디테일, 다채로운 게임플레이가 모두 있습니다!\n\n## [장난감 몬스터 받기!]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 12. Spacefolk City\n\nSpacefolk City은 마치 전통적인 우주 도시 건설 시뮬레이션의 재치있는 그래픽으로 вas킨릴를 끌어들입니다 - 이제 MR에서도 즐길 수 있습니다! 자유롭게 떠다니는 도시의 위치를 조절하여 당신의 방에서 그를 즐길 수 있어요. 자유와 도전의 균형을 즐길 수 있어 계속해서 더 돌아오게 될 겁니다!\n\n## [Spacefolk City 다운로드하기!]\n\n# 13. Eleven Table Tennis\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 현실 세계의 탁구를 좋아한다면 Eleven Table Tennis가 딱 맞는 게임입니다. 물리 엔진이 훌륭하고 만족스럽습니다. MR 업데이트로 액션을 집 안으로 가져왔습니다! 다른 플레이어와 온라인 대결이 가능하거나 실력 있는 AI와 연습 모드에서 대결할 수 있어 여기에서 많은 즐길 거리가 있습니다.\n\n## [이븐 탁구 게임 다운로드]\n\n# 14. 더 우즐스\n\n만약 레밍스를 좋아한다면 우즐스도 즐길 수 있고, 퀘스트 3에서 혼합 현실을 시도하고 싶은 사람에겐 보석 같은 게임입니다. 기즐모이드를 신비한 지형과 나의 집 안으로 안내하여 승리로 이끌어 주세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금으로서는 위즐즈는 무료로 플레이할 수 있어요!\n\n## [위즐즈 무료로 받기!]\n\n# 15. FPS 향상현실\n\nFPS 향상현실은 퀘스트 2에서 훌륭했지만 퀘스트 3의 훨씬 우수한 MR 기능으로 인해 정말 자신을 찾아냈습니다. 당신의 집이 전쟁터로 변하면 다양한 무기와 몰입형 커버 시스템을 이용해 AI 적들과의 전투를 벌일 수 있어요. 미래에는 온라인 PvP도 예정되어 있어요...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## [FPS 향상된 현실을 경험하세요!]\n\n# 16. 고릴라질라: 맥시멈 램페이지\n\n고릴라질라는 당신의 거실을 번화한 대도시로 변신시켜주는 대성공 MR 게임입니다!\n\n퀘스트 3용으로 최적화되어 있어 특정 거대 고릴라로 변신하여 가상 도시를 파괴하고 싶다면 이 게임은 확실한 히트작입니다...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## [고릴라질라 게임을 만나보세요!]\n\n# 17. Deisim\n\nDeisim은 SideQuest에서 공식 스토어로 진출한 대히트 중 하나이며 지금, 혼합 현실에서 Deisim을 플레이할 수 있습니다!\n\n당신의 창조물을 살려내고, 사람들을 이끄는 것, 그리고 자신만의 공간에서 건물을 세우는 등 당신이 우상화되길 원하는 욕망을 충족하세요. 혹시 당신의 거실에서요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDeisim은 이전에도 좋았지만, 이 MR 업데이트로 더욱 멋지게 변했어요!\n\n## [Deisim 다운로드하기!]\n\n# 18. MR Chess\n\n![이미지](/assets/img/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컴퓨터와 대결하거나 친구들과 함께 MR Chess에서 체스 실력을 겨루세요!\n\n가장 뚜렷한 특징은 혼합 현실에서 실체 체스판 또는 가상 체스판을 사용할 수 있는 능력입니다. 진정으로 자신만의 방식으로 플레이할 수 있도록 합니다. 가상으로 선택하면 만족스러운 햅틱 피드백이 디지털적인 느낌을 물리학적으로 느낄 수 있게 해주고, 실체 체스판을 선택하면 상대방의 말들이 디지털적으로 실체 체스말과 함께 나타납니다. 정말 똑똑한 기능이에요!\n\n## [Get MR Chess!]\n\n# 2023 SideQuest Indie Spotlight\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 목록에 소개된 몇 가지 게임은 2023년 말에 우리의 인디 스폿라이트에 포함되었습니다. 이는 독립적인 타이틀들의 성취나 미래 가능성을 인정하고자 하는 쇼케이스였어요.\n\n지금 바로 플레이할 수 있는 놀라운 인디 타이틀로 가득한 전체 스폿라이트를 확인해보세요:\n\n# SideQuest 소개\n\nSideQuest는 독립적인 VR 커뮤니티를 대표합니다. 전 세계의 개발자와 플레이어들이 함께 창작하고 공유하며 사랑하는 가상현실 앱들에 대해 흥분할 수 있는 곳이에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발자들(우리와 같은)은 공식 상점에 도달하는 과정에서 메커니즘과 모드를 자유롭게 실험할 수 있고, 플레이어들은 실제로 모든 것이 한곳에 모인 멋진 VR 세계에서 수천 개의 앱을 안전하게 탐험할 수 있어요.\n\n제한이 필요할까요?\n\n[SIDEQUEST 여기서 가져오기]\n\n[BANTER 다운로드: 우리의 무료 소셜 VR 게임]\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서민수님의 SideQuest🚀 계속 진행하도록 해요...\n\n웹사이트 | 페이스북 | 트위터 | 인스타그램 | 틱톡 | 레딧 | 미디엄 | 디스코드 | 링크드인 | 연구 클럽 | 수다방\n","ogImage":{"url":"/assets/img/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_0.png"},"coverImage":"/assets/img/2024-06-19-18MixedRealityGamesForQuest3YouNeedToPlay_0.png","tag":["Tech"],"readingTime":11},{"title":"게임 엔진을 위한 저지연 스크립팅 소개, 파트 2","description":"","date":"2024-06-19 11:54","slug":"2024-06-19-AnIntroductiontoLow-LatencyScriptingforGameEnginesPart2","content":"\n고급 예제, 게스트 할당, RPC\n\n이전 파트에서는 모든 것을 설정하고 샌드박스 안팎에서 기본 호출을 만드는 방법을 보여 주었습니다. 라이브리스브 레포지터리의 예제 폴더에서 게임 개발 예제를 사용함으로써 RISC-V 컴파일러를 찾았다면 제시된 코드 예제를 즉시 실행할 수 있었습니다.\n\n이 파트 2에서는 고급 예제를 살펴보겠습니다.\n\n## 1. 고급 API 설계와 호스트 제어 힙\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게스트 힙은 샌드박스 바깥에서 완전히 제어됩니다. 게스트는 알려진 시스템 호출을 실행하여 메모리를 할당하고 해제하며 각각 할당과 해제를 처리합니다. 또한 calloc 및 realloc도 지원됩니다.\n\n우리는 이것을 어떻게 활용할 수 있는지 보여주기 위해 가벼운 추상화를 만들 것입니다. 예를 들어, 위치에 연결된 데이터 개념을 만들어볼 것입니다. 다음과 같은 것입니다:\n\n```js\nstruct LocationData {\n   int x, y, z;\n   std::unique_ptr\u003cuint8_t[]\u003e data = nullptr;\n   std::size_t size = 0;\n};\n```\n\n위치의 의미는 여기서 중요하지 않습니다. 중요한 것은 어딘가에 해당하는 구조체라는 것뿐입니다. 계속 진행하기 전에 몇 가지 알아야 할 사항이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모든 힙 할당은 64비트로 정렬됩니다. 그것은 우리가 제어합니다.\n- 데이터를 수정하고 모든 작업이 완전히 완료된 후에만 커밋할 수 있는 능력을 원합니다.\n- ... 따라서 우리는 데이터의 사본을 스크립트 프로그램으로 가져 오고 싶습니다.\n\n최소 API에 대해 2가지 기능이 필요합니다:\n\n```js\n// 위치 (x, y, z)의 내용을 검색하는 함수,\n// 또는 위치가 발견되지 않으면 (nullptr, 0)를 반환합니다.\nstruct LocationGet {\n  uint8_t* data;\n  size_t size = 0;\n};\nDEFINE_DYNCALL(10, location_get, LocationGet(int, int, int));\n// 위치의 내용을 커밋하는 함수\n// 오류를 반환 할 수 없으며 대신 예외가 발생합니다.\nDEFINE_DYNCALL(11, location_commit, void(int, int, int, const void*, size_t));\n```\n\nABI는 레지스터에 직접 2개의 원소 구조체를 반환할 수 있다고 합니다. 이는 효율적입니다. 따라서 x, y 및 z를 레지스터에 유지하려고 시도할 것입니다.모두 인수로 전달합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 간단하고 직관적인 클래스를 만드는 것이 좋습니다:\n\n```js\n#include \u003cspan\u003e\nstruct LocationData {\n  LocationData(int x, int y, int z)\n    : x(x), y(y), z(z)\n  {\n    auto res = location_get(x, y, z);\n    if (res.data) {\n       m_data.reset(res.data);\n       m_size = res.size;\n    }\n  }\n  void commit() {\n    location_commit(x, y, z, m_data.get(), m_size);\n  }\n\n  bool empty() const noexcept {\n    return m_data == nullptr || m_size == 0;\n  }\n  std::span\u003cuint8_t\u003e data() {\n    return { m_data.get(), m_size };\n  }\n  void assign(const uint8_t* data, size_t size) {\n    m_data = std::make_unique\u003cuint8_t[]\u003e(size);\n    std::copy(data, data + size, m_data.get());\n    m_size = size;\n  }\n\n  const int x, y, z;\nprivate:\n  std::unique_ptr\u003cuint8_t[]\u003e m_data = nullptr;\n  std::size_t m_size = 0;\n};\n```\n\n이 간단하고 직관적인 클래스는 특정 위치의 데이터를 관리합니다. 객체를 생성하면 공백을 채우려고 시도하며 비어 있으면 원하는 대로 데이터를 할당할 수 있습니다. 데이터를 커밋하면 크기에 관계없이 엔진 데이터를 덮어씁니다.\n\n게임 엔진 쪽에서 이를 아주 빠르게 구현할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nstruct Location {\n  int x = 0, y = 0, z = 0;\n\n  bool operator==(const Location\u0026 other) const {\n    return x == other.x \u0026\u0026 y == other.y \u0026\u0026 z == other.z;\n  }\n};\nnamespace std {\n  template\u003c\u003e struct hash\u003cLocation\u003e {\n    std::size_t operator()(const Location\u0026 loc) const {\n      return std::hash\u003cint\u003e()(loc.x) ^ std::hash\u003cint\u003e()(loc.y) ^ std::hash\u003cint\u003e()(loc.z);\n    }\n  };\n}\nstruct LocationData\n{\n  std::vector\u003cuint8_t\u003e data;\n};\nstatic std::unordered_map\u003cLocation, LocationData\u003e locations;\n```\n\n그리고 게임 엔진의 location_get 및 location_commit 콜백 함수들:\n\n```js\n// sys_location_get 콜백 함수입니다\nregister_script_function(10, [](Script\u0026 script) {\n  auto [x, y, z] = script.machine().sysargs\u003cint, int, int\u003e();\n  auto it = locations.find(Location(x, y, z));\n  if (it != locations.end()) {\n    auto alloc = script.guest_alloc(it-\u003esecond.data.size());\n    script.machine().copy_to_guest(alloc, it-\u003esecond.data.data(), it-\u003esecond.data.size());\n    script.machine().set_result(alloc, it-\u003esecond.data.size());\n  } else {\n    script.machine().set_result(0, 0);\n  }\n});\n// sys_location_commit 콜백 함수입니다\nregister_script_function(11, [](Script\u0026 script) {\n  auto [x, y, z, data] = script.machine().sysargs\u003cint, int, int, std::span\u003cuint8_t\u003e\u003e();\n  // 새로운 위치를 생성하거나 기존 위치를 업데이트합니다\n  auto\u0026 loc = locations[Location(x, y, z)];\n  loc.data = std::vector\u003cuint8_t\u003e(data.begin(), data.end());\n});\n```\n\n이제 조금 설명이 필요합니다. 게임 엔진의 콜백 함수는 프로그램에서 발생하는 호출로부터 인수를 검색한 다음 호출된 함수에 따라 유용한 작업을 수행합니다. 프로그램이 이렇게 수행한다고 가정해보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```cpp\nLocationData loc(1, 2, 3);\nif (!loc.empty()) {\n  printf(\"위치 (1, 2, 3)에 %zu바이트가 있습니다\\n\", loc.data().size());\n  location_commit(1, 2, 3, loc.data().data(), loc.data().size());\n} else {\n  printf(\"LocationGet(1, 2, 3) 비어 있었어요!\\n\");\n}\n\nstd::vector\u003cuint8_t\u003e data = { 0x01, 0x02, 0x03, 0x04 };\nloc.assign(data.data(), data.size());\nloc.commit();\n\nLocationData loc2(1, 2, 3);\nif (!loc2.empty()) {\n  printf(\"위치 (1, 2, 3)에 %zu바이트가 있습니다\\n\", loc2.data().size());\n  location_commit(1, 2, 3, loc2.data().data(), loc2.data().size());\n} else {\n  printf(\"LocationGet(1, 2, 3) 비어 있었어요!\\n\");\n}\n```\n\n그리고 예상대로 출력 결과가 나왔어요:\n\n```cpp\nLocationGet(1, 2, 3) 비어 있었어요!\n위치 (1, 2, 3)에 4 바이트가 있습니다\n```\n\n그래서 이 프로그램은 먼저 (1, 2, 3) 위치에 있는 LocationData를 생성하고 비어 있는지 확인합니다. 비어 있었습니다. 그런 다음 4바이트 벡터에서 할당하고, 커밋하며, 새로운 (1, 2, 3) 위치에 있는 LocationData를 만들고 이제 4바이트를 포함하였다는 것을 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLocationData의 생성자는 다음과 같습니다:\n\n```js\nauto res = location_get(x, y, z);\nif (res.data) {\n  m_data.reset(res.data);\n  m_size = res.size;\n}\n```\n\n이 코드는 게임 엔진에 location_get을 실행하도록 요청하며, 이를 콜백 10으로 번호를 매깁니다. 콜백 10이 실행되고, 즉시 첫 번째로 받은 3개의 인자를 정수형으로 가져와 x, y, z를 만듭니다. 그런 다음 이를 위치들 지도에 찾아보고, 찾지 못하면 (0, 0)를 반환합니다. 이것은 다른 한 쪽에 포인터가 있고, 다른 하나는 정수인 두 레지스터를 0으로 설정하는 것으로 상상할 수 있습니다.\n\n이후, LocationData가 비어있게 되고, 그것이 출력됩니다. 그런 다음에 데이터를 할당하고 commit()를 호출합니다. Commit은 location_commit인 콜백 11을 호출할 것입니다. 콜백을 확인하면 4개의 인자를 읽어옵니다: x, y, z 및 `span\u003cuint8_t\u003e`입니다. 이것은 동적인 스팬이므로 2개의 레지스터를 소비해서 총 5개로 만들어집니다. 이는 프로그램의 정의와 일치하는데, void(int, int, int, const void\\*, size_t)입니다. 즉, 포인터를 위한 하나의 레지스터, 그리고 데이터의 크기를 위한 두 번째 레지스터가 필요합니다. 그리고 이 데이터는 해당 위치의 지도로 복사됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내, LocationData를 다시 (1, 2, 3)로 만들었고, 이번에는 데이터를 찾았어요. 4바이트가 저장되고 프로그램으로 검색되었으며, 데이터와 크기는 2개의 레지스터로 전달되었어요. 호스트 측의 콜백 함수에서는 다음과 같은 절차가 진행됩니다:\n\n- 스크립트 프로그램에 대한 힙 할당이 script.guest_alloc(bytes)를 사용하여 이루어집니다.\n- 그 다음, 데이터를 힙 할당 주소로 복사하기 위해 script.machine().copy_to_guest(…)를 사용합니다.\n- 마지막으로, 주소와 크기를 반환합니다.\n\n이로써 첫 번째 고급 스크립팅 예제가 마무리되었습니다.\n\n이 예제 API에 대한 마지막 참고 사항은 상당히 남용 방지 메커니즘이 있다는 것입니다. 우리가 적대적인 행동을 기대하는 경우, 생성될 수 있는 위치의 수에 제한을 두었어야 했지만, 이를 제외하고는 libriscv API가 극단적인 값들을 예방하는 데 탁월한 역할을 합니다. 예를 들어, 방대한 범위는 즉시 실패합니다. 잘못된 메모리 읽기 또는 쓰기는 실행이 실패합니다. 너무 오랫동안 지연하는 시도도 실패합니다. 간단히 말해, 정말 딱글딱글하게 만드는 경우가 있어 무한 루프에 빠진 적도 있지만, 이로 인해 게임에 영향을 준 적은 없었습니다. 잠시 실행되다가 결국 스스로 실패하고 멈춘 지점도 알려줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 원격 프로시저 호출\n\n동일한 코드를 두 곳에서 실행하고 두 개의 별도 시스템에서 동일한 동작을 경험하는 것은 간단히 올바른 에뮬레이션입니다. 더 나아가, 동일한 프로그램이라고 가정한다면 함수 호출을 설명하고 그것이 동일하게 작동하도록 할 수도 있습니다. 그래서 두 개의 샌드박스에 동일한 프로그램을 실행하여 원격 프로시저 호출이 발생하도록 해 보겠습니다, 테스트 목적으로.\n\n우선, 다른 위치에서 함수를 실행하려면 어떻게 실행할지 정의해야 합니다. 예를 들어, 하나의 가상 머신에서 모든 레지스터를 다른 가상 머신으로 복사한 다음 레지스터에 맞는 모든 인수를 원격 함수에 전달한다고 가정할 수 있습니다. 그런 다음 모든 프로그램이 동일하기 때문에 기능도 동일하게 동작할 것입니다.\n\n우리가 하려는 다른 방법은 고정 크기 lambda 캡쳐를 사용하는 것입니다. 우리가 신경 쓰는 것들을 (값으로!) 람다 함수에 복사하여 원격 위치로 전송하고 그것을 인자로서 트램폴린에 전달할 수 있습니다. 그런 다음 트램폴린은 캡쳐와 함께 람다를 호출하고 와! 원격 프로시저 호출이 이뤄집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 API를 다음과 같이 만들어 봅시다:\n\n```js\nint x = 42;\nrpc([x] {\n  printf(\"원격 가상 머신에서 안녕하세요!\\n\");\n  printf(\"x = %d\\n\", x);\n  fflush(stdout);\n});\n```\n\n실제 환경에서 RPC 함수는 주변 또는 지역 플레이어에게 브로드캐스트할 수 있는 기능을 포함한 여러 가지 모드를 가질 것입니다. 하지만 이 예제에는 충분합니다. 이를 구현하기 위해서는 고정 크기 캡처 함수 구현이 필요합니다 (링크가 됨). 이를 사용하여 다음과 같이 callable을 트램폴린으로 사용하는 도우미 함수를 만들 수 있습니다:\n\n```js\nDEFINE_DYNCALL(12, remote_lambda, void(void(*)(void*), const void *, size_t));\n\nstatic void rpc(riscv::Function\u003cvoid()\u003e func)\n{\n  remote_lambda(\n  [](void* data) {\n    auto func = reinterpret_cast\u003criscv::Function\u003cvoid()\u003e*\u003e(data);\n    (*func)();\n  },\n  \u0026func, sizeof(func));\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 하는 일은 inline 함수를 사용하여 전달 된 `remote_lambda`를 호출하는 것입니다. 이 함수는 포인터로 변환 할 수있는 내부 함수를 취하며 해당 포인터를 고정 크기 캡처 함수로 변환할 수 있습니다. 그런 다음 호출합니다. 그리고 두 번째 및 세 번째 인수는 함수와 해당 크기입니다. 즉, 3 개의 인수가 있습니다. : 함수 포인터, Function`void()` 포인터 및 해당 크기.\n\n호스트에서는 캡처 스토리지를 읽어서 주소를 정수 값으로 검색합니다.\n\n```js\nstatic Script::gaddr_t remote_addr;\nstatic std::array\u003cuint8_t, 32\u003e remote_capture;\n...\nregister_script_function(12, [](Script\u0026 script) {\n  auto [addr, capture] = script.machine().sysargs\u003cScript::gaddr_t, std::array\u003cuint8_t, 32\u003e*\u003e();\n\n  remote_addr = addr;\n  remote_capture = *capture;\n});\n```\n\n여기서는 함수 포인터 주소를 검색한 다음 32 바이트 std::array에 대한 제로 복사 포인터를 얻습니다. 내부적으로 메모리가 올바르며 범위 내에 있는지 확인하려고 고정 크기 1 요소 span이 생성됩니다. 그런 다음 배열로 변환되며 정렬 확인 후에 처리됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금 우리는 프로그램에서 캡처 스토리지를 사용하여 함수를 호출할 수 있는 능력을 가졌습니다. 따라서 함수를 호출하기 위해 다른 Script 인스턴스를 만들겠습니다:\n\n```js\nauto script2 = script.clone(\"myscript2\");\n\n// 캡처를 스택에 푸시한 채로 원격 함수 호출\nscript2.call(remote_addr, remote_capture);\n```\n\n캡처 스토리지가 스택에 푸시된 상태로 remote_addr를 호출하면 성공적인 원격 프로시저 호출이 발생합니다:\n\n```js\nHello from a remote virtual machine!\nx = 42\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 두 프로그램이 동일할 때 안전하고 신뢰할 수 있는 RPC를 구현하는 데 함수 주소와 캡처 저장소만 필요하다는 것을 보여줍니다. 이것은 제가 게임 개발에서 많이 활용하는 기능입니다.\n\n## 3. 콜백 구현하기\n\n나중에 호출할 스크립트 내에서 콜백을 만드는 두 가지 방법이 있습니다.\n\n첫째, 단순히 이름으로 함수를 찾아 미리 합의된 매개변수를 사용하여 호출하는 것이 가장 쉽지만 약간 오류가 발생할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmyscript.call(\"my_function\", 1, 2, 3, \"four\");\n```\n\n요 메소드의 경우에는 스크립트에 \"my_function\" 함수를 extern \"C\"로 구현하는 것 외에는 아무것도 할 필요가 없습니다. 해당 함수가 visible 하다면 (심볼 테이블 항목이 있으면) 호출할 수 있습니다. 우리가 알 수 없는 것은 함수가 실제로 그러한 인수를 받는지 여부이지만 이 메소드는 JSON과 같은 곳에서 매우 쉽게 사용할 수 있습니다.\n\n두 번째 방법은 스크립트 자체에서 함수 포인터를 가져오는 방법이지만, 이를 위해 콜백 등록 함수를 만들어야 합니다. 다음과 같이:\n\n```js\nDEFINE_DYNCALL(13, my_callback, void(const char*, void(*)(int)));\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 게임 안의 엔티티를 식별하는 첫 번째 문자열을 가져와서 함수 포인터를 사용합니다. 이벤트가 발생할 때 함수 포인터가 호출되며, 엔티티의 ID인 정수를 전달할 것입니다. 호스트에서 핸들러를 구현하는 예시입니다:\n\n```js\nregister_script_function(13, [](Script\u0026 script) {\n  auto [name, func] = script.machine().sysargs\u003cstd::string, Script::gaddr_t\u003e();\n\n  // 이름으로 엔티티 찾기\n  auto\u0026 ent = entities.at(name);\n  // 엔티티를 위한 이벤트 핸들러 등록\n  ent.on_event(\n  [func, \u0026script] (auto\u0026 ent) {\n    // 엔티티 ID를 인수로하여 함수 호출\n    script.call(func, ent.getID());\n  });\n});\n```\n\n여기서 Script::gaddr_t은 샌드박스 내부의 포인터와 같은 크기의 부호 없는 정수입니다. 물론, 구조체를 전달할 때 문제를 피하기 위해 일치하는 포인터 크기를 사용하는 것이 좋습니다 (예: size_t의 차이).\n\n그래서 이러한 호스트에서의 콜백을 사용하면, 호출되면 엔티티를 찾아서, 해당 엔티티의 on_event 콜백을 설정하여 이전에 제공된 함수 포인터로 스크립트 함수를 호출하고 엔티티 ID를 인수로 전달하게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스크립트 안에는 이제 이렇게 이벤트 핸들러를 만들 수 있습니다:\n\n```js\nmy_callback(\"entity1\", [] (int id) {\n  printf(\"Callback from entity %s\\n\", Entity{id}.getName().c_str());\n});\n```\n\n이 예제에서는 Entity를 감싸는 래퍼가 있다고 가정합니다. 그럼 그 래퍼를 통해 예를 들어 Entity 이름을 가져올 수 있습니다.\n\n콜백에 대한 세 번째이자 마지막 방법은 위와 동일하지만, 스크립트에서 Function`void()`를 사용합니다. 호스트에서 캡처 스토리지를 람다로 복사하여 이벤트 핸들러에 전달한 후, 이벤트가 트리거될 때 함수 호출 중에 캡처 스토리지를 스택에 푸시합니다. RPC의 예와 비슷합니다. 이렇게 함으로써 캡처 스토리지를 가진 이벤트를 만들 수 있습니다. 매우 편리하죠!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 단계별로 구현을 마무리해 봅시다. 먼저, 스크립트에서 정의를 수정하여 추가적인 const void*, size_t 매개변수를 받도록 하고, 그 다음으로 함수 포인터를 수정하여 나중에 캡처 저장소를 가져올 수 있도록 void* 인수를 추가하세요:\n\n```js\nDEFINE_DYNCALL(13, my_callback, void(const char*, void(*)(int, void*), const void*, size_t));\n```\n\n조금 복잡해 보이지만 두 단계로 진행하면 됩니다. 두 번째 단계는 항상 같은 단계입니다. callable에 const void*, size_t를 추가하고 callback 함수 포인터에 void*를 추가하세요. 이 callable을 사용하려면 도우미 함수를 만들어야 합니다:\n\n```js\nstatic void entity_on_event(const char* name, riscv::Function\u003cvoid(int)\u003e callback)\n{\n  my_callback(name,\n  [] (int id, void* data) {\n    auto callback = reinterpret_cast\u003criscv::Function\u003cvoid(int)\u003e*\u003e(data);\n    (*callback)(id);\n  },\n  \u0026callback, sizeof(callback));\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도움 함수는 복잡한 호출을 간단하게 만들어줍니다. 함수를 다시 자체로 캐스팅하는 중간 함수가 추가되며, 일반적인 인수로 호출됩니다. 또한 반환 값을 전달할 수도 있습니다.\n\n```js\nint x = 42;\nentity_on_event(\"entity1\",\n[x] (int id) {\n  printf(\"Entity %s에서 콜백\\n\", Entity{id}.getName().c_str());\n  printf(\"x = %d\\n\", x);\n});\n```\n\nRPC 예제처럼 x = 42를 출력합니다. 이를 위해 호스트 측을 확장해야 합니다:\n\n```js\nregister_script_function(13, [](Script\u0026 script) {\n  auto [name, func, capture] = script.machine().sysargs\u003cstd::string, Script::gaddr_t, std::array\u003cuint8_t, 32\u003e*\u003e();\n\n  // 이름으로 Entity 찾기\n  auto\u0026 ent = entities.at(name);\n  // Entity의 이벤트 핸들러 등록\n  ent.on_event(\n  [func, \u0026script, capture = *capture] (auto\u0026 ent) {\n    // Entity ID를 인수로하여 함수 호출\n    script.call(func, ent.getID(), capture);\n  });\n});\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금 변경된 부분은 capture storage를 값으로 복사하여 on_event lambda에 넣은 다음, void* 인수로서 마지막 인수로 넣어 스택에 푸시하는 것입니다. 이것은 void* 인수입니다. 이 예제에서는 실제로 배열을 포인터로 반환했습니다: `std::array\u003cuint8_t, 32\u003e*`, 그리고 이것은 그 데이터에 대한 제로-코피 포인터를 제공합니다. 하지만, 그것을 값으로 capture해야 합니다.\n\n읽어 주셔서 감사합니다. 나중에 더 많은 예제를 살펴보겠습니다.\n\n-곤조\n","ogImage":{"url":"/assets/img/2024-06-19-AnIntroductiontoLow-LatencyScriptingforGameEnginesPart2_0.png"},"coverImage":"/assets/img/2024-06-19-AnIntroductiontoLow-LatencyScriptingforGameEnginesPart2_0.png","tag":["Tech"],"readingTime":17},{"title":"게임 개발자를 위한 생성적 AI의 활용 방안 2024년 6월판","description":"","date":"2024-06-19 11:53","slug":"2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition","content":"\n![image](/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_0.png)\n\n제너레이티브 AI는 빠르게 발전하고 있고 끊임없이 헤드라인을 내지만, 게임 개발자가 generative AI를 사용하는 것이 정말로 유익한가요? 저희는 2022년부터 이 분야에서의 경험을 기반으로 이 질문에 대한 저희의 견해를 요약했습니다.\n\n\\*2024년 6월을 기준으로 한 저희의 관점임을 유의해 주세요. 상황은 계속 변화 중입니다.\n\n# 주요 포인트 요약\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n바쁜 독자들을 위해 먼저 결론을 알려드립니다:\n\n- 생성적 AI의 가장 효과적인 사용은 게임 기획 단계에 있습니다.\n- 다음으로 효과적인 영역은 마케팅을 위한 콘텐츠 생성입니다.\n\n![이미지](/assets/img/2024-06-19-GenerativeAI를이용한게임개발자용도2024년6월판_1.png)\n\n반면, 게임에 직접 구현할 수 있는 자산을 생성하는 것은 가장 큰 기대치를 가졌을 수 있지만, 현재 일관성 없는 품질 및 다른 편집 과정과 같은 어려움에 직면하고 있습니다. 이로 인해 이분야 전문가들은 종종 불편함을 느끼며, 현재는 특정 목적으로만 한정적으로 사용되고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론 창의력을 발휘하여 제너레이티브 AI를 제품 개발에 활용할 수 있습니다. 예산 제약, 프로젝트 규모, 혹은 전문분야 외의 영역을 보충하는 데 있어 가치를 제공할 수 있습니다.\n\n위치팟 주식회사에서는 우리가 상담하는 게임 스튜디오와 개발자들에게 기술을 따라잡는 동안 기획 및 마케팅 단계에서 제너레이티브 AI를 활용할 것을 권장합니다. 게임 개발에 대한 AI 도구의 맞춤화부터 상담 서비스까지 다양한 서비스를 제공하고 있으니 언제든지 연락 주세요. (https://www.witchpot.com/contact)\n\n# 전제\n\n게임에서 제너레이티브 AI의 적용을 고려할 때에는 두 가지 주요 접근 방식이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기존 게임 콘텐츠의 효율성 향상을 위해 AI 활용 주로\n- 전통적인 방법과는 다른 새로운 게임 경험 창출을 위해 AI 활용\n\n이 글에서는 전자 방법에 초점을 맞출 것입니다. 후자인 새로운 게임 경험 창출 방법은 다루지 않겠지만, 수요가 있을 경우 별도로 논의할 수 있습니다.\n\n# 생성 AI의 현재 상태 및 과제\n\n게임 분야는 방대하기 때문에 이 글에서는 모든 것을 다 다루지는 않을 것입니다. 그러나 우리는 공개적으로 사용 가능한 시장 맵이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서는 이미지 및 텍스트 생성의 현재 상태와 도전 과제에 대해 이야기하겠습니다.\n\n이미지 생성의 현재 상태 및 도전 과제\n\n현재 이미지 생성은 특정 캐릭터의 다양한 상황에서 이미지를 생성할 수 있으며, 해당 캐릭터가 동일하다고 인식될 수 있는 수준까지 만들어낼 수 있습니다. 또한 적절한 조정을 통해 이미 존재하는 콘텐츠의 캐릭터에 대해서도 이 작업을 수행할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 도전 과제들이 있습니다. 예를 들어, 문자의 비율이나 몸의 형태에 약간의 차이가 발생할 수 있습니다. 유명한 사례로는 캐릭터들이 여섯 손가락으로 나오는 경우 등이 있습니다. 이러한 문제들은 사람들이 그릴 때는 발생하지 않지만 수정이 필요합니다.\n\nAI로 생성된 이미지는 층으로 분리되지 않고 하나의 이미지로 생성됩니다. 따라서 이미 그림을 잘 그리는 사람들에게는 세부적인 수정이 번거로울 수 있습니다.\n\n텍스트 생성의 현재 상황과 도전 과제\n\n이 비디오에서는 캐릭터의 대화가 생성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, 텍스트 생성은 이야기, 캐릭터 설정, 플레이버 텍스트 및 태그 라인을 작성하는 데 사용될 수 있어 그 적용 범위가 매우 광범위합니다.\n\n여기서 우리는 텍스트 생성을 위해 Glimnote를 사용하지만, ChatGPT와 같은 도구도 올바른 사용법으로 캐릭터의 어조와 성격에 맞는 대화를 생성할 수 있습니다.\n\n그러나, 여전히 일부 어려움이 남아 있습니다. 예를 들어 생성된 텍스트는 종종 지나치게 과장되거나 과도한 찬사를 포함할 수 있습니다. 우리는 개선을 위해 노력하고 있지만, 피드백에 따르면 이러한 텍스트를 그대로 사용하는 것이 여전히 어렵다는 것을 보여줍니다.\n\n이러한 상황에서 많은 기존 게임 개발 팀은 특정 영역마다 전문가를 보유한 특히 AI 도구의 출력이 미흡하고 진화를 기다리는 것으로 발견되었을 때 많은 어려움을 겪고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 기획 단계에서 AI 활용하기\n\nAI 도구의 장점은 그것들의 압도적인 속도와 양이에 있습니다. 새로운 콘텐츠를 기획하는 아이디어 생성 단계에서, 이러한 장점은 상기한 도전적인 부분들보다 상당한 혜택을 제공할 수 있습니다.\n\n![image](/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_3.png)\n\n실제로 AI는 팀 내에서 빠르게 프로토타입과 초안을 생성함으로써 \"우리가 만들고 싶은 것\"에 대한 의사 소통을 가속화하는 데 점점 더 활용되고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 팀이 새 캐릭터를 만들고 싶다면, 텍스트만 사용하여 세계 설정에 맞는 20개의 새 캐릭터를 몇 분 만에 생성할 수 있습니다. 도구에 익숙해지면, 이 20개 캐릭터에 대한 의도한 예술 스타일의 시각적 이미지도 몇 분에서 몇 시간만에 생성할 수 있습니다.\n\n필요한 시간은 원하는 품질 및 프롬프트 제작 전문성에 따라 다릅니다.\n\n개발팀 내에서 이 20개 캐릭터 프로토타입을 공유하면 종종 어떤 캐릭터를 추가로 발전시킬지에 대한 열정적인 토론이 이루어지며, 더 좋은 프로젝트와 원활한 커뮤니케이션으로 이어집니다.\n\n캐릭터 설정에만 국한되지 않습니다. 예를 들어, 효과음을 명시할 때, 텍스트 설명은 중요하지만, 효과음 AI가 생성한 프로토타입을 공유함으로써 정보 전달이 현저하게 향상됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마케팅 콘텐츠 작성\n\n이미지 생성 환경을 구축하고 능숙하게 사용할 수 있는 환경을 구축 한 후에는 게임 내에서 직접 사용하기 어려운 자산이더라도 여전히 소셜 미디어에 자주 게시할 만한 충분한 마케팅 콘텐츠를 만들 수 있습니다.\n\n여기에는 저희 Witchpot이 협력한 SQUADBLAST 게임을 위해 AI를 사용하여 작성된 팬 아트 콘텐츠의 예가 있습니다.\n\n![팬 아트](/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAI 도구를 활용하여 PR 콘텐츠를 제작하면 높은 빈도의 게시물을 유지하여 청중을 계속해서 참여시키고 게임에 대해 정보를 제공할 수 있습니다.\n\n실제 캐릭터 이미지를 생성할 수 있는 환경을 만들 수 있으며, 이를 제한함으로써 팬 아트를 만들 수 있는 환경을 제공할 수 있습니다. 또한 이를 활용하여 커뮤니티를 형성할 수도 있습니다.\n\n# 결론\n\n게임 개발자들이 현재 AI 도구를 기획 및 마케팅 콘텐츠 제작 분야에서 어떻게 활용하고 있는지에 대해 설명했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 분야에서 의도한 결과물을 생성하는 기술을 개발함으로써, 우리는 AI의 혜택을 누리고 가치 있는 통찰을 축적할 수 있습니다. 이를 통해 게임 자산 생성에 AI를 활용하는 것을 권장하며, 수많고 매혹적인 게임을 출시할 수 있게 됩니다.\n\n저희는 계속해서 이 분야의 정보를 공유할 것이므로, 부디 팔로우해 주세요!\n\n무엇이든 자유롭게 저희에게 질문해 주세요!\n","ogImage":{"url":"/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_0.png"},"coverImage":"/assets/img/2024-06-19-UsesofGenerativeAIforGameDevelopersJune2024Edition_0.png","tag":["Tech"],"readingTime":7},{"title":"유니티 실시간 멀티플레이어, 파트 8 사용 가능한 네트워킹 솔루션 탐색","description":"","date":"2024-06-19 11:50","slug":"2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions","content":"\n멀티플레이어 게임에서는 클라이언트들이 동기화되어야 합니다. 데이터 패킷을 직접 교환하는 것이 가능하지만, 이는 경험이 적은 개발자들에겐 복잡할 수 있습니다. 그러므로 우리는 다양한 케이스에 대한 준비된 네트워킹 솔루션을 살펴보겠습니다.\n\n![image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_0.png)\n\n안녕하세요! MY.GAMES의 리드 소프트웨어 엔지니어 Dmitrii Ivashchenko입니다. Unity 실시간 멀티플레이어 랜드스케이프에 관한 시리즈 기사가 계속됩니다! 오늘은 실시간 멀티플레이어용 준비된 솔루션에 대해 다뤄볼 예정입니다. 시작해봅시다.\n\n# 전송에 대한 간단한 메모\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n멀티플레이어 게임에서 서버와 클라이언트는 네트워크를 통해 패킷을 보내는 방식으로 데이터를 교환합니다. 서로 다른 위치에서 접속한 플레이어들을 위해 공유된 가상 공간을 만들기 위해, 게임 프로세스에서 발생하는 이벤트(캐릭터 이동 또는 오브젝트 생성과 같은)는 다른 클라이언트와 동기화되어 데이터 패킷을 보내는 것으로 처리됩니다. 네트워크를 통해 패킷을 송수신하는 책임을 맡고 있는 부분을 전송 계층이라고 부릅니다.\n\n이 패킷들을 직접 전송하는 것은 가능하지만, 이러한 방식은 멀티플레이어 게임을 다루는 데 경험이 적은 개발자들에겐 불편할 수 있습니다. 그래서 처음부터 직접 구현하기보다는 아래 나열된 것 중 하나를 사용하는 것이 더 나은 아이디어입니다. 이제 그 솔루션들을 살펴보겠습니다.\n\n# Unity Relay \u0026 Netcode\n\n유니티는 Netcode 패키지 두 가지를 제공합니다: GameObjects용 Netcode(미리보기 릴리스 단계), Entities용 Netcode(실험 모드) 그리고 폐기된 UNET. 또한 Unity Relay 서비스를 제공하여 게임 클라이언트를 연결합니다 - 이에 대해 간단히 언급하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 유니티 릴레이\n\n유니티 릴레이는 게임 개발자가 플레이어 간에 향상된 연결을 제공하는 방법으로, 세 번째 자로 솔루션에 투자하지 않고 전용 게임 서버(DGS)를 유지하거나 멀티플레이어 게임에서 네트워크 복잡성에 대해 걱정할 필요 없이 조인 코드 메커니즘을 통해 제공합니다. DGS 대신 릴레이 서비스는 프록시 역할을 하는 유니버설 릴레이 서버를 통해 연결성을 제공합니다.\n\n![image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_1.png)\n\n릴레이 서비스를 통해 플레이어들은 UDP, DTLS 및 안전한 WebSocket (WSS)를 포함한 여러 다양한 프로토콜을 통해 통신할 수 있습니다. 릴레이 서버를 선택한 후에 클라이언트는 앞에서 언급한 프로토콜 중 하나를 사용하여 직접 릴레이 서버와 통신합니다. WebSocket 연결을 통해 WebGL을 사용하는 브라우저에서 멀티플레이어 연결이 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRelay는 모든 게임 엔진과 함께 작동합니다. Unity에서 Relay를 사용하는 경우 Unity Transport Package (UTP)와 통합된 Relay SDK를 사용하는 것이 좋습니다.\n\n# Unity Transport Package\n\nUnity Transport은 멀티플레이어 게임을 개발하기 위한 저수준 네트워킹 라이브러리입니다. 이것은 Netcode for GameObjects 및 Netcode for Entities를 기반으로 하지만 솔루션과 함께 사용할 수도 있습니다.\n\nUnity Transport는 UDP 및 WebSockets 위에 제공된 연결 기반 추상화 계층(내장된 네트워크 드라이버) 덕분에 Unity Engine에서 지원하는 모든 플랫폼을 손쉽게 지원합니다. UDP 및 WebSockets를 암호화 여부에 관계없이 구성할 수 있습니다. 신뢰성, 패킷 순서, 패킷 분할과 같은 추가 기능을 제공하기 위해 파이프라인도 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTransport 2.0의 주요 기능은 WebGL 지원이 추가되었습니다. 이를 통해 Unity Transport 패키지를 Unity Engine의 모든 지원 플랫폼에서 사용할 수 있게 되었습니다. Transport 사용자들은 이제 Websocket 전송의 구현에 접근할 수 있습니다. TLS를 사용하든 사용하지 않든 움직이는 플레이어는 일반적으로 셀룰러 타워 사이에서 네트워크 이동을 투명하게 활용할 수 있습니다. 이 기능은 현재 클라이언트 측과 UDP 전송에만 제한되어 있습니다.\n\nUnity Transport를 사용하려면 Unity Editor 버전 2022.2 이상을 설치하고 com.unity.transport 패키지도 설치해야 합니다.\n\n![이미지](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_2.png)\n\nRelay는 Unity Transport (UTP)와 함께 작동합니다. 이를 통해 엄격한 방화벽과 같은 라우팅 제한으로 인해 통신할 수 없는 클라이언트들이 연결할 수 있게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Unity Relay 제한 사항\n\nRelay는 다음과 같은 제한 사항이 있습니다:\n\n- 현재 지역 잠금 기능이 없습니다. 요청을 처리할 수 있는 용량이 있는 경우 누구나 어느 지역에서든 할당 요청을 할 수 있습니다.\n- Relay 서비스는 모든 트래픽을 선택한 호스트 지역을 통해 라우팅합니다. 따라서 지역 간 통신은 최적의 지연 시간을 제공하지 않을 수 있습니다.\n- 한 게임 세션 내에서 최대 100명의 플레이어가 호스트에 참여할 수 있습니다.\n- Relay 서비스는 네트워크 트래픽을 제어하기 위해 속도 제한을 사용합니다. \"할당 생성\", \"참여 코드 생성\", \"Relay 참여\" 및 \"지역 리스트\" 요청에 대해 분당 60개의 요청 제한이 설정됩니다. 이 제한은 각 인증된 플레이어에 적용됩니다.\n\n제한 사항이 있지만, Relay 서비스는 플레이어 연결을 간편화하고 원활한 멀티플레이어 게임 경험을 제공하는 강력한 도구입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# GameObjects를 위한 Netcode\n\nRelay의 메인 게임 네트워크 코드를 위한 가장 인기 있는 두 가지 솔루션은 Netcode for GameObjects (NGO)와 API Mirror Networking이 있습니다.\n\n대부분의 경우 NGO를 사용하는 것이 권장되는 최상의 방법이며, 네트워크 변수, 씬 관리, 원격 프로시저 호출 (RPC), 그리고 메시징과 같은 안정적인 핵심 기능을 제공합니다. 그러나, API Mirror Networking은 NGO가 제공하는 전체 기능 세트를 요구하지 않는 게임에도 간편하고 사용하기 쉬운 기능을 제공하기 때문에 훌륭합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_3.png)\n\nPhoton Realtime은 멀티플레이어 게임용 핵심 레이어이자(그리고 Photon의 더 복잡한 네트워크 솔루션에서도) 플레이어 매칭 및 확장 가능한 방식으로 빠른 통신과 같은 문제를 다룹니다. Photon Realtime은 게임에서뿐만 아니라 더 구체적인 멀티플레이어 솔루션에서도 사용됩니다.\n\nPhoton Realtime은 퓨전이나 퀀텀 솔루션에서 찾을 수 있는 게임 상태 및 시뮬레이션 동기화 메커니즘을 포함하지 않고 대신 네트워크 상의 메시지 전송에 초점을 맞춥니다.\n\nPhoton Realtime이라는 용어는 또한 클라이언트와 서버 간 상호 작용을 정의하는 API, 도구 및 서비스의 포괄적인 프레임워크를 포함합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 Photon Realtime 클라이언트는 세 가지 명확한 작업으로 나뉜 전용 서버 시퀀스에 연결합니다: 인증 및 지역 배포 (Name Server), 플레이어 매칭 (Master Server) 및 게임 플레이 (Game Server). 이러한 서버들은 Realtime API를 통해 관리되므로 걱정할 필요가 없습니다. 하지만 이러한 서버에 대한 이해는 확실히 도움이 될 수 있습니다.\n\nPhoton Cloud는 Photon Realtime 클라이언트를 위한 글로벌 호스팅을 제공하는 완전한 관리형 서비스입니다. 게임 코드는 Photon Cloud와 통신하여 클라우드에 연결하고 해당 API를 사용하여 연결, 무작위 방 참가 또는 이벤트를 발생시키는 등의 작업을 수행합니다.\n\nPhoton Realtime에서는 방 데이터를 쉽게 저장하고 로드할 수 있으며, 웹훅을 설정하여 Photon Cloud를 외부 웹 서버에 연결할 수도 있습니다.\n\n# Photon Fusion\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_4.png)\n\n포톤 퓨전은 Unity를 위한 네트워크 상태 동기화를 위한 새로운 고성능 라이브러리입니다. 두 가지 주요하게 다른 네트워크 토폴로지를 지원하며, API 하나를 사용하여 네트워크 연결이 없는 경우에도 플레이어 한 명을 위한 모드를 지원합니다.\n\nFusion은 Unity 워크플로에 통합하기 쉽도록 설계되었으며, 데이터 압축, 클라이언트 측 예측, 지연 보상 등의 고급 기능을 해당 제품에 기본으로 제공합니다.\n\n예를 들어 Fusion에서 RPC 및 네트워크 상태는 MonoBehaviour 메서드 및 속성에 속성을 사용하여 정의되므로 명시적 직렬화 코드가 필요하지 않으며, 네트워크 오브젝트는 Unity 프리팹의 최신 기능을 모두 사용하여 정의할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n퓨전은 최신 압축 알고리즘을 사용하여 대역폭 요구량을 줄이고 프로세서에 미미한 오버헤드를 발생시킵니다. 데이터는 완전 압축된 스냅샷으로 전송되거나 후속 일관성을 보장하는 부분 블록으로 전송됩니다. 후자의 경우, 매우 큰 플레이어 수를 지원하는 맞춤형 관심 영역 시스템이 제공됩니다.\n\n퓨전은 틱 기반 시뮬레이션을 구현하며 공유 모드 또는 호스트 모드에서 운영됩니다. 주요 차이점은 네트워크 개체에 대한 권한이 누구에게 있는지이지만 이로 인해 사용 가능한 다른 SDK 기능이 결정됩니다.\n\n퓨전은 유니티 (볼트 및 PUN)용 기존 포톤 제품 두 개를 대체하기 위해 개발되었습니다. 퓨전의 중요한 핵심 구성 요소는 NetworkRunner와 NetworkObject입니다. NetworkRunner는 퓨전의 핵심으로 간주될 수 있습니다 - 장면에 있는 하나의 러너가 네트워크 작업과 시뮬레이션을 관리합니다.\n\n퓨전은 빠른 게임 또는 프로토타입 생성을 위해 다양한 사전 구축된 NetworkBehaviours를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFusion은 입력 처리를 두 단계로 구분합니다: 로컬 하드웨어에서 입력을 수집하고 구조체에 넣은 다음 해당 입력을 읽어 게임 상태를 변경합니다(시뮬레이션을 진행).\n\nFusion은 일반 Fusion 입력 또는 [Networked] 속성 사용이 가장 실용적인 해결책이 아닌 경우에 RPC(Remote Procedure Calls)를 지원합니다. Fusion을 시작하는 방법은 Fusion 시작 가이드를 공부하는 것을 권장합니다.\n\n# Photon Quantum\n\n![이미지](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n포톤 퀀텀은 멀티플레이어 게임용으로 완전한 결정론적 엔진입니다. 예측/롤백 방식에 기반한 이 엔진은 딜레이에 민감한 온라인 게임에 완벽하게 적합합니다. 액션 RPG, 스포츠 게임, 대전 게임, FPS 등과 같은 게임들에 특히 유용합니다.\n\n이 엔진을 사용하면 넷코드가 필요하지 않습니다. 모든 게임 요소가 기본적으로 네트워크로 연결되고 100% 동기화됩니다. 여러 연결된 플레이어가 있는 한 시뮬레이션을 만들어야 하며, 이는 로컬 멀티플레이어 경험을 개발할 때와 같습니다. 퀀텀의 결정론적 서브시스템은 각 클라이언트에서의 시뮬레이션이 물리학, 봇, 경로탐색, 애니메이션을 포함하여 항상 동기화되고 딜레이 없이 동작함을 보장합니다.\n\n![이미지](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_6.png)\n\n결정론적인 게임은 치팅에 저항력이 내재되어 있습니다. 치트에 대항하기 위한 가장 효과적인 방법은 재생 또는 서버-판정 시뮬레이션을 확인하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플레이어 입력은 Photon Cloud 서버로 전송되어 다른 플레이어들 사이에 분산됩니다. 웹훅(Webhooks)을 사용하면 자체 백엔드와 플러그인을 연결하여 서버 측에서 사용자 정의 코드를 실행할 수 있습니다.\n\nPhoton Quantum은 ECS 아키텍처(ECS architecture)로 구축되었으며, PC, 콘솔, VR 및 모바일 기기에서 심도 있는 멀티플레이어 게임조차 뛰어난 성능을 보장합니다.\n\nQuantum에서 인코딩된 시뮬레이션은 Unity에 종속성이 없어 어디에서든 실행할 수 있습니다. 모든 로컬 동작은 지연 없이 수행되며, 원격 입력은 예측되고 롤백됩니다. Quantum은 리플레이(replays)를 볼 수 있는 기능을 갖고 있습니다. 리플레이는 백엔드에 저장되거나 게임 내에서 사용할 수 있습니다. 시작하려면 Quantum 100 시리즈를 확인해보세요.\n\n# 노름코어(Normcore)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_7.png\" /\u003e\n\nNormcore는 Unity 기반 프로젝트에 멀티플레이어 모드를 추가하는 데 사용할 수 있는 고성능 도구입니다. Normcore에는 네트워크 물리학, 지속적인 공간, 음성 채팅 및 XR 지원이 포함되어 있습니다.\n\nRealtimeTransform 컴포넌트를 추가하면 Normcore는 모든 객체 변환을 자동으로 동기화합니다. 이를 위해 코딩이 필요하지 않습니다. 추가로 Normcore는 상태에 따른 보간 및 안정적인 네트워크 물리학을 제공하여 모든 연결에서 완벽한 움직임을 보장합니다.\n\nNormcore의 주요 장점 중 하나는 WebRTC를 기반으로 한 빠른 데이터 전송입니다. 전송 중 단편화를 발생시키지 않는 최대 패킷 크기를 사용하여 데이터 전송 프로세스를 가속화합니다. Normcore의 모든 데이터 패킷은 기본적으로 암호화되어 있어 사용자 데이터의 보안과 기밀성을 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n노름코어는 델타 업데이트 시스템을 사용합니다. 이는 마지막 데이터 패킷이 전송된 이후의 모든 변경 사항을 추적하고, 새로운 패킷을 전송할 때 어떤 것을 포함해야 하는지 이미 알고 있는 것을 의미합니다. 이를 통해 자원을 절약하고 성능을 향상시킵니다. 노름코어의 데이터 직렬화 기능은 CPU 사용량 최적화를 가능하게 합니다. 모든 직렬화 코드는 프로젝트 컴파일 전에 자동으로 생성되어 빠르고 효율적인 자원 사용을 보장합니다.\n\n노름코어 서버는 전 세계 지역에서 운영되며 사설 광섬유 네트워크를 통해 연결되어 지연시간이 낮습니다. 노름코어를 자체 서버에 호스팅하거나 노름코어가 클라우드 인프라의 사본을 호스팅하도록 허용할 수 있습니다.\n\n# 이미지\n\n![이미지](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMirror Networking은 Unity용 고수준 네트워크 라이브러리로, 사용 편의성과 신뢰성을 최적화했습니다. 이 라이브러리는 네트워크 연결을 다루는 과정을 간단하게 만들어 개발자가 프로젝트 작성에 집중할 수 있도록 설계되었습니다.\n\nMirror Networking은 12가지 이상의 저수준 프로토콜과 호환되며 지속적으로 발전하고 개선됩니다. 네트워크를 통한 원격 프로시저 호출 및 컨텍스트 관리를 위한 기능을 포함하며 네트워크 애플리케이션에서 물리 작업을 지원합니다.\n\n이 라이브러리는 12가지가 넘는 기본 제공 네트워크 어댑터와 다섯 가지의 네트워크 관리 시스템 옵션을 제공하여 개발자가 사용자 정의 버전을 만들 수 있습니다. 학습 및 코딩 프로세스를 용이하게 하기 위해 여러 완전한 사용 예제도 포함되어 있습니다.\n\n# Nakama\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![FishNet image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_9.png)\n\n히로익 랩스의 나카마(Nakama)는 사용자가 전체 인프라를 하나의 오픈 패키지로 소유할 수 있는 인기 있는 오픈 소스 게임 서버입니다. 나카마에는 필요한 모든 실시간 게임 API 및 소셜 및 경쟁 기능이 포함되어 있습니다.\n\n게임에 필요한 모든 기능을 갖춘 나카마는 실시간 멀티플레이어 및 소셜 및 경쟁 기능과 같은 모든 필수 기능을 제공하므로 Go, TypeScript 및 Lua를 사용하여 클라이언트 및 서버 측의 모든 측면을 사용자 정의할 수 있습니다. 나카마를 사용하면 실시간 멀티플레이어 경쟁 게임을 생성하고 매칭 알고리즘을 사용자 정의하며 매일 보상을 추가하고 리더보드를 생성하며 게임 내 통화를 구현하고 실시간 채팅을 제공할 수 있습니다.\n\n# FishNet\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_10.png)\n\nFish-Networking은 무료 오픈 소스 라이브러리로, Unity에서 개발된 네트워킹 솔루션을 제공하는 것입니다. 이는 경험 많은 게임 디자이너가 개발했으며, 일반적으로 유료 솔루션에서만 사용할 수 있는 많은 기능을 제공합니다.\n\nFish-Networking의 주요 장점은 대역폭 및 리소스 최적화(서버 비용 절감), 수십 명에서 수백 명까지의 많은 플레이어를 지원하며, 클라이언트 예측, 지연 보상, 서버 부하 분산, 중첩 네트워크 객체 지원 등의 내장 기능이 있습니다.\n\n# 솔루션 개요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 표는 유니티에서 게임 개발을 위한 다양한 네트워크 솔루션을 프로토콜 사용, 지원되는 위상들, 세션 당 최대 플레이어 수, 최소 지원 유니티 버전 및 현재 상태로 비교하여 제공합니다.\n\n![테이블](/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_11.png)\n\n다양한 솔루션을 통해 개발자들은 자신의 특정 요구 사항에 맞는 도구를 선택할 수 있습니다. 많은 솔루션이 서로 다른 유형의 위상을 지원하므로 게임의 특정 요구 사항에 적응할 수 있습니다. Photon PUN, Photon BOLT, UNET과 같은 일부 오래된 네트워크 솔루션은 새 프로젝트에 사용하지 않는 것이 좋으며, Netcode for Entities 및 Netcode for GameObjects는 아직 실험적이거나 프리 릴리스 단계에 있어서 제작용으로 사용할 수는 없습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_0.png"},"coverImage":"/assets/img/2024-06-19-UnityRealtimeMultiplayerPart8ExploringReady-MadeNetworkingSolutions_0.png","tag":["Tech"],"readingTime":15},{"title":"아무도 사지 않은 큰 마법 모험 게임","description":"","date":"2024-06-19 11:48","slug":"2024-06-19-TheBigMagicalAdventureGameNoOneBought","content":"\n![이미지](/assets/img/2024-06-19-TheBigMagicalAdventureGameNoOneBought_0.png)\n\n저는 PC에서 고전적인 1인칭 액션 게임을 하는 것으로 자랐어요. 친구들과 함께 Wolfenstein 3D 같은 게임을 위한 쉐어웨어 디스크를 거래하고, 게임 기술이 진정으로 몰입적이고 풍성한 플레이 공간을 그리기 시작한 첫 걸음을 밟는 것을 감탄했어요.\n\n그 시대의 게임 중에는 'Heretic'과 'Hexen'이 있었어요. 이를 간단하게 설명하자면 \"마법 주문이 있는 Doom 같은 게임!\"이라고 할 수 있겠죠. 특히 Hexen은 아직도 경험할 가치가 있는데, 상호 연결된 광활한 레벨 디자인으로 이제는 오픈 월드 모험의 초기 모습을 엿볼 수 있기 때문이에요.\n\n작년에 이전의 고전적인 마법이 가미된 액션 어드벤처 게임들에 대한 환상적인 현대식 재해석과 똑같이 플레이되는 게임이 출시되었는데, 아무도 구입하지 않았어요. 이는 일반적인 온라인 게임 기사의 과장이 아니에요. 'Immortals of Aveum'이라는 제목인데, 이 게임은 게시자 EA의 기대치를 크게 못 가르쳤기 때문에 이를 개발한 스튜디오는 완전히 사라졌어요. 게이머들 중 오랫동안 게임을 따라오고 있다면 EA라는 이름을 보고 고양이처럼 쥐를 쳐다볼 수도 있겠지만, 이는 그들의 스튜디오에서 내부 제작한 것이 아니었어요. 오히려 그들이 출판 및 마케팅에 참여한 중소 규모의 팀이 만든 게임이었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEA는 이 게임이 잘 될 것이라고 믿었어야 했다고 볼 수 있어요. 일단 빠르게 한 눈에 살펴보면 같은 생각이 들 수 있어요. 이 게임은 소니가 PlayStation에서 다양한 인기 프랜차이즈를 만들기 위해 끈질긴 노력을 기울인 “이야기 중심의 싱글 플레이 액션” 공식을 따라갑니다. 멋진 비쥬얼을 가지고 있고, Unreal Engine 5에서 운영되는 최초의 출시 게임 중 하나에요. 이 게임의 판타지 설정은 전통적인 군사 설정보다 넓은 관객층에게 더 쉽고 매력적일 수 있도록 만들어졌어요.\n\n그런데, 《Immortals of Aveum》은 1분부터 완전히 실패로 떨어졌습니다. 이 게임의 문제는 제목부터 시작된다고 생각해요. 최악의 경우, 그것은 아무런 의미가 없는 혼란스러운 용어의 무리가 되고, 최선의 경우에도 유비소프트의 《Immortals: Fenyx Rising》의 속편처럼 보여요. 이 게임의 제목은 게임 자체가 어둡고 불분명한 이야기 내용으로 넘쳐나는 것을 나타내는 단서라고 볼 수 있어요. 게임을 로딩할 때 처음 보는 화면은 이 게임 세계에만 해당되는 새로운 말들로 가득 찬 거대한 텍스트 벽이에요. 그리고 그 이후로도 상황은 나아지지 않아요. 모든 것을 완전히 이해하는 데 약 1시간이 걸리지만, 이 게임의 귀여운 문구의 절반도 의미가 담긴 채 기억에 남는다면 당신은 운이 좋은 편이에요.\n\n이제까지 쌓인 용어와 세계 설정의 악몽 속에 있는 이야기는 특별히 흥미로운 것도 새로운 것도 아니에요. Aveum은 악한 제국에 의해 파괴된 청년을 따르는데, 그러나 그는 사실 특별한 존재이며, 다른 특수 마법사들에 의해 영입되어 일행 중 한 명이 되어 세상을 구하기 위해 노력하는 이야기를 따라갑니다. 그러나 어떤 상황들은 반드시 그러한 것이 아닌 것이 팩트인 것이 연계됩니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네, 지금까지 지난 40년 동안 나온 모든 저급한 과학 소설이나 판타지 이야기를 거의 다 설명한 것 같네요. Immortals는 캐릭터 집합으로 일부 포인트를 되찾으려고 노력하고 있습니다. 칭찬할 만한 점은 많은 캐릭터들이 잘 연기되었다는 것입니다. 그러나 현대 판타지 제목에서 고정 캐릭터를 선택하고, 성별 맞춤화나 의미 있는 코스튬 옵션 없이 가는 것은 좀 이상한 선택이었다고 생각해요. 판타지 게이머들은 이야기의 세계에 몰입하고 싶어하는 경향이 있거나 최소한 그 역할을 개인적으로 수행하는 듯한 느낌을 받고 싶어합니다.\n\n![이미지](/assets/img/2024-06-19-TheBigMagicalAdventureGameNoOneBought_2.png)\n\nAveum의 주인공 \"Jak\" (진짜로)은 다른 게임의 영웅들만큼 매력이 없어요. 만나자마자 이미 세계에 몰입한 것 같아서 연결하기 어려운 점이 있습니다. 그가 이미 머리속에 가득 담고 있는 것들이 당신을 약간 혼란스럽게 만들 수 있어요.\n\n시작이 절망적인 악몽이라도 지나면, 게임이 정말 멋진 것이 됩니다. 현재 플레이할 수 있는 가장 날카로우면서 재미있는 1인칭 게임 중 하나에요. Doom Eternal을 좋아하고 마법사로서 그것이 어떻게 될지 보고 싶다면, 이 게임은 그 아이디어를 훌륭히 구현한 것 같습니다. 여러 공격 주문을 결합할 수 있을 때 놀랄 만한 공격 주문 다양성에 금세 압도되고, 세계를 탐험할 충분한 공간이 있어서 그것이 사실 상적인 적의 복도 순서로 느껴지지 않는 것 같아요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현대 게임 산업의 가장 나쁜 관행 중 하나를 촉진하는 것을 싫어하지만, 이것을 이야기해 보겠습니다: 이미 있는 IP와 연결되어야 했다고 생각합니다. 필 스펜서는 한 번 무대에서 Hexen 티셔츠를 입고 간 회의에서 유명해지기도 했습니다. 약간만 조정하면 새로운 Hexen 게임이었을 수도 있었습니다. 그런 게임 세계는 더 쉽게 이해할 수 있지만, 동시에 레트로한 신뢰성이 있어서 게임을 선호하는 플레이어들을 끌어들일 수 있었을 것입니다.\n\nAAA 게임 공간의 계속되는 쇠퇴에 기여하려는 것이 아닙니다; 스튜디오들이 자신들의 새로운 아이디어를 시도할 수 있을 때 그것을 좋아합니다. 그러나 Immortals of Aveum은 매우 기본적이고 만족스러운 게임 아이콘 위에 과도하게 복잡한 새로운 스킨을 제시합니다. 게임의 플레이에 대해 눈에 띄는 점은 없으며, 세계 구축이 그렇다고 생각하는 것만큼 빛나지 않습니다. 이것은 90년대 게임들이 했던 것을 하고 있지만, 그것을 현대 콘텍스트에서 아주 잘 수행하고 있습니다. 이것만으로는 성공적인 작품이 되기에는 충분하지 않습니다.\n\n게임은 게임 산업이 즐거움을 주는 가장 훌륭한 연도 중 하나에서 비참한 시기에 출시되었습니다. 8월 말에 출시되어 발르더스 게이트 3가 이미 PC에서 몇 주 전에 최종 발매되고 콘솔에서 그 후 몇 주 후에 발매되었을 때 그야말로 미제한 대어로 흡수되었습니다. 영역에 대한 좋은 이야기를 좋아하는 사람들은 이미 충분히 만족했기 때문에 Aveum을 사려고 하지 않았습니다. 그리고 더 캐주얼한 마법 모험 팬들은 이미 올해 앞쪽에 허그워츠 레거시의 사본을 트럭으로 구입한 상태였으며, 이것은 발드르의 게이트와 마찬가지로 기존 IP에 의해 지지받는 더 관련된, 확장된 게임입니다.\n\nAveum에 대한 최종적인 큰 문제는 60FPS 게임이 되기 위한 이상한 결정이라고 생각합니다. 행동 게임에 있어서는 고귀한 목표지만, Unreal Engine 5는 여전히 상대적으로 새로운 기술입니다. 게임은 엔진의 최첨단 시각적 기능과 그 수준의 성능을 조합하기에는 충분한 역동력을 갖춘 콘솔을 대상으로 했습니다. Aveum의 모든 콘솔 버전은 매우 부드럽게 보이며, 특히 Xbox Series S는 완전히 고대 \"표준 해상도\" 해상도로 감소했습니다. 튼튼한 PC를 가지고 있는 경우 더 나은 성과를 거둘 수 있지만, 튼튼한 PC가 있다면 이미 더 인지도 높은 게임을 플레이하고 있을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![게임 이미지](/assets/img/2024-06-19-TheBigMagicalAdventureGameNoOneBought_3.png)\n\n게임이 스튜디오 폐쇄에도 불구하고 며칠 전에 마지막으로 숨을 쉬었습니다. 새로운 패치가 출시되어 AMD의 FSR 3 기술을 추가했는데, 프레임 생성을 지원합니다. 이로써 콘솔에서 프레임율이 더욱 높아졌습니다. 하지만 저는 시도해본 결과, 더 많은 프레임보다는 고해상도 30FPS 옵션이 있다면 좋겠다고 생각했습니다. 이 새로운 패치는 현재 홈 콘솔의 그래픽 상태가 아직 완벽하지 않다는 문제에는 아무런 대책을 내놓지 않았습니다.\n\nAveum의 불멸자들은 왜 대규모 게임 회사들이 결코 기회를 잡지 않는지에 대한 훌륭한 사례 연구입니다. $1.2억을 들여서 일한 모든 사람들에게 일자리를 상실했으며, 10년 후에는 아무도 기억하지 못할 게임을 만들었습니다. 이 게임은 Unreal Engine 5의 상징적인 모습이 될 수 있는 순간이 있었지만, 너무 과도한 프레임율 야망으로 인해 왕관을 놓쳤고, Hellblade II는 그 왕관을 자신의 머릿결에 더 맺었습니다.\n\nAveum과 같은 새로운 세계를 바탕으로 한 게임들이 더 많이 존재할 수 있는 세상에 살고 싶지만, 그들은 흥미로워야 하고, 소니 게임을 좋아한 사람들 이외의 대상을 실제로 겨냥해야 합니다. 불멸자들은 그들의 게임 메카닉을 매우 잘 구현했지만, 수백만 가지를 추구하고 다음 대형 미디어 프랜차이즈가 되려고 하다가 갇혔습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임을 할 가치가 있는 편이에요. 비용을 과도하게 지불할 필요가 없고, 첫 시간을 견디는 데 문제가 없다면요. 제가 권하고 싶다는 건 아니지만 말이죠. 내부 창의 회의에서 심지어 \"Jak\"이라는 이름이 통과될 수 있다는 게 믿기지가 않아요. 게다가 어째서 Jak and Daxter를 발견하지 못한 법률 부서를 통과할 수 있었는지요.\n","ogImage":{"url":"/assets/img/2024-06-19-TheBigMagicalAdventureGameNoOneBought_0.png"},"coverImage":"/assets/img/2024-06-19-TheBigMagicalAdventureGameNoOneBought_0.png","tag":["Tech"],"readingTime":6},{"title":"개발 일지 3 피곤해요","description":"","date":"2024-06-19 11:47","slug":"2024-06-19-Devlog3Imtired","content":"\n게임 개발은 어렵습니다. 만약 이 경로를 선택한다면, 프로젝트가 당신을 밤낮으로 괴롭힐 준비가 되어야 합니다. 계획을 잘 세우지 않는 편이에요. 보통 그냥 뛰어들어서 어디로 나아갈지 보는 편이에요. 저의 게임인 '아마도 아트(PROBABLY ART)'를 만들 때에, 이 접근 방식이 제 약점으로 드러났어요.\n\n신비로운 분위기와 대화 없이 전개되는 이야기가 있는 특별한 게임을 만들고 싶다는 비전을 갖고 있었어요. 플레이 시간은 약 두 시간 정도 되고, 디지털 페인팅이 서사를 방해하지 않고 풀 화면에 표시될 예정이었어요. 큰 야망이 있었죠.\n\n시각적 요소는 비교적 빨리 조합되었어요. 제 디지털 페인팅에서 사용하는 스타일을 게임에 반영하려는 목표를 가졌어요. 어둡고 복잡한 스토리와 대조적으로 귀여운 의도적인 시각 효과가 있었어요.\n\n![이미지](/assets/img/2024-06-19-Devlog3Imtired_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이야기: 우울한 토끼\n\n하루 내내 가장 많이 생각나는 이야기였어요. 그래서 눈을 감기가 어려웠어요. 게임에서 저는 토끼 옷을 입은 우울한 캐릭터의 이야기를 전하고 싶었어요. \"토끼\"에 이름을 지어주지 않았는데, 그 이유는 플레이어들이 주인공에 스스로를 더 쉽게 떠올릴 수 있게 하기 위해서예요. 이 토끼의 과거는 추상적으로 탐구되며, 어린 시절과 현재를 왔다 갔다하며 다루어져요. 집에 대한 이야기인데, 그곳은 안식처가 될 수도 있고 떠날 것을 두려워하여 새로운 경험을 막는 감옥이 될 수 있어요. 이것은 이야기의 작은 조각이고 이야기가 시작되는 방식이에요. 자아 사랑과 자학이라는 주제는 이야기에서 중요한 역할을 해야 했어요. 모든 것이 애매하게 전달되어 플레이어들이 해석할 공간을 남겼어요.\n\n![이미지](/assets/img/2024-06-19-Devlog3Imtired_1.png)\n\n# 90-90 규칙\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임의 시각 측면을 만드는 것은 나머지 부분과 비교해 상대적으로 쉬웠어요. 난인티 난인티 법칙이 계속 머리 속에 떠오르더군요: \"프로젝트의 처음 90%는 전체 시간의 90%를 차지하고, 나머지 10%는 남은 90%를 차지한다.\" 첫 90%는 재미있는 부분이었어요 — 게임은 거의 플레이 가능했고, 음악도 마무리되었지만 보이지 않는 모든 것들 — 마지막 10%인 버그 수정, 게임 로직 등 — 첫 90%만큼 시간이 걸렸어요. 게임이 필요로 하는 모든 백그라운드 작업이 저를 압도했고 솔직히 가끔 지루할 때도 있었어요. 작은 버그를 고치기 전에 몇 일이 지나기도 했죠. 하지만 많은 것을 배웠고, 네 달 후에 처음 프로토타입이 완성되었어요. 이전 블로그 게시물에서 언급했듯이, 그 당시 프로젝트는 여전히 “엄마가 날 특별하다고 말했다”라고 불렸어요.\n\n옛 윈도우 데스크톱 모양의 전반적인 스타일은 향수와 어릴 적 추억을 떠올리게 하기 위해 만들어졌어요. 언급했듯이, 게임은 과거와 현재 사이를 자주 왔다갔다 합니다. 토끼의 색깔로 어느 시대에 있는지 알 수도 있어요. 게임이 진행될수록 더 많은 회상이 나오면서 시간이 점프하는 것이 더 이해하기 쉬울 거에요. 저는 Ableton에서 음악을 만들었지만, 그것은 다른 블로그 포스트에 남기겠어요.\n\n저에게 프로젝트를 조기에 포기하는 게 얼마나 어려웠는지 상상할 수 있을 거예요. 5분의 게임 플레이를 위해 네 달 동안의 작업. 게임을 완성하는 데 2년이 더 걸렸을 거예요. 솔직히 말하자면, 그 때에는 이미 한계에 도달했지만 완전히 포기하고 싶지 않았어요. 그래서 좀 더 작게 생각하기로 결정했고, 그렇게 새 프로젝트인 PROBABLY ART 아이디어가 탄생했어요.\n\n다음 블로그 포스트로 무슨 일이 일어나는지 계속 지켜봐 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-Devlog3Imtired_0.png"},"coverImage":"/assets/img/2024-06-19-Devlog3Imtired_0.png","tag":["Tech"],"readingTime":3},{"title":"비트크래프트 속 제국","description":"","date":"2024-06-19 11:45","slug":"2024-06-19-EmpiresinBitCraft","content":"\n# 게임 디자인 블로그 — 2024년 6월 10일\n\n![이미지](/assets/img/2024-06-19-EmpiresinBitCraft_0.png)\n\nBitCraft에서 제국에 대해 이야기할 시간입니다. 제국은 비즈니스적인 측면과 세계의 역사를 플레이어들이 쓰는 동적인 세계에서 BitCraft의 성공에 중요합니다. 공동체와 제국에 대해 이야기하는 것은 오랜 시간동안 기대해온 시스템입니다. 어느 면에서는 게임 수익화에 대한 이전 블로그 글과 연장선에 있으므로, 아마도 아직 보지 않으셨다면 먼저 우리의 철학을 이해하기 위해 읽어보시기를 권장합니다.\n\n모든 플레이어가 같은 물리적 세계에서 공유하고 협업하는 BitCraft는 본질적으로 사회적인 게임입니다. 따라서 플레이어들이 세계와 경쟁하거나 협력할 수 있는 다양한 방법이 필요합니다. BitCraft에서는 무역 길드, 정착지, 그리고 제국을 포함한 여러 가지 방법을 계획 중에 있습니다. 현재 게임에 구현된 그룹 시스템은 정착지뿐이며, 이는 기본적으로 신뢰할 수 있는 그룹의 플레이어들 사이에 자원과 건물을 공유하는 방식으로 작동합니다. 정착지의 목적은 서로 다른 기술을 가진 그룹이 함께 세계의 특정 장소에서 진전할 수 있도록 하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알파 2 플레이테스트에서 소개할 엠파이어 시스템은 다소 기능적이지 않고 좀 더 허영심을 충족시키는 목적을 가지고 있습니다. BitCraft에서 엠파이어의 목적은 플레이어가 큰 이념, 인물, 또는 군주에 힘을 모아 세계에 그 엠파이어의 충성을 퍼뜨리며 세계에 자신의 흔적을 남기도록 동기부여하는 것입니다.\n\n만약 우리가 일을 잘 한다면, BitCraft의 황제가 되는 느낌은 실제 세계의 황제가 되는 느낌과 유사해야 합니다. BitCraft에서의 이념을 위한 싸움이 흥미로울 뿐만 아니라, BitCraft 국가의 물류를 동원하는 일도 복잡할 것이며, BitCraft의 역사를 읽는 것이 현실 세계와 같이 매혹적일 것입니다.\n\n![엠파이어 이미지](/assets/img/2024-06-19-EmpiresinBitCraft_1.png)\n\n엠파이어의 작동 방식은 어떤가요?\n본질적으로, 엠파이어 시스템은 BitCraft의 세계지도 상에서 영토를 점령하기 위한 경쟁입니다. 엠파이어와 그 영토들은 게임 내에서 기능적인 목적보다는 BitCraft 세계의 맛과 역동성에 엄청난 영향을 미치지만, 플레이어와 그들의 엠파이어가 소유 및 통제하기 위해 경합하는 글로벌한 스킨으로 세계지도를 생각할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지난번에 게임 디자인 비전에 대해 이야기했던 것을 기억하시나요? 제국은 캐릭터나 정착지와는 근본적으로 다른 규모에서 운영됩니다. 제국은 모든 캐릭터나 정착지의 진행에 영향을 미치지 않지만, 모든 캐릭터가 제국 시스템에 각자의 방식으로 참여할 수 있습니다.\n\n제국 규모의 게임 플레이는 전략과 외교, 물류 및 사회 조직의 혼합으로 설계되었습니다. 적절한 전제조건이 갖춰지면 플레이어는 소유한 클레임을 사용하여 해당 클레임을 수도로 하는 제국을 설립할 수 있습니다. 그런 다음 이 새로운 수도를 사용하여 제국 규모의 주요 자원인 헥사이트 캡슐을 생산할 수 있습니다.\n\n플레이어는 이 헥사이트 캡슐을 사용하여 자신의 제국을 유지하거나 노드를 건설하거나 다른 클레임들을 설득하여 제국에 합류하도록 확장할 수 있으며, 최종적으로 경제적 전쟁을 펼쳐 다른 제국으로부터 영토를 차지할 수 있습니다. 이러한 캡슐은 수도 클레임에서만 생산할 수 있기 때문에 제국이 커질수록 모든 노드와 물류를 관리하는 것은 단일 플레이어에게 불가능해지므로 모집과 협력이 필수적이 됩니다. 모든 플레이어는 단일 제국에 충성을 맹세할 수 있으며 황제로서 이들 플레이어 중 일부를 권한 순위로 승진시켜 제국의 의무를 수행하는 데 도움을 받을 수 있습니다. 심지어 제국의 시민들도 제국 규모의 게임 플레이에 참여할 권한이 부여됩니다.\n\n![EmpiresinBitCraft_2](/assets/img/2024-06-19-EmpiresinBitCraft_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제국과 수익화\n이전 수익화 블로그의 철학과 관련하여 BitCraft에서 게임의 어떤 부분이 \"명예 메달\"로 의도되었는지와 어떤 부분이 \"람보\"로 의도되었는지 명확히 해주려고 합니다. BitCraft의 제국 시스템을 거대한 영전용 화장수, 일명 람보르기니로 디자인하고 상상한 적이 있습니다. 대규모로 성공한 제국을 갖고있는 유일한 이득은 상태입니다: 게임 세계에서의 명성, 제국 이름이 세계지도에 표시되고 황제의 왕관 등이 됩니다. 따라서 제국 운영을 위해서 누군가 돈을 지출해야 한다는 사실을 감안하여 만들어졌습니다.\n\n특히, 헥사이트 캡슐을 만드는 데에는 헥사이트 파편이 필요하며, 이는 우리 스토어에서 실제 화폐로 구매할 수 있습니다. 다가오는 테스트에서는 헥사이트 파편을 직접 판매하지는 않겠지만, 어떻게 작동할지 미리 명확히 하고 싶습니다.\n\n이 돈은 제국을 소유한 황제나 참여를 희망하는 모든 플레이어가 지출해야 하는 것은 아닙니다. 저희는 의도적으로 다양한 방식으로 제국이 조직화될 수 있도록 디자인했습니다. 많은 사람들이 존경하거나 지지하는 단일 지도자에게 원조하고 싶어할 수도 있고, 소수의 사람들이 자신의 방대한 자원을 동원하고 이름을 역사에 남기기 위해 연합하고 싶어할 수도 있습니다. 예를 들어, 헥사이트 파편은 제국에 소속된 플레이어들이 제국의 금고에 기부할 수 있으며, 그 금고에서는 단독으로 제국이 사용할 수 있습니다.\n\n제국 시스템은 누군가 실제 돈을 지출해야 하는데, 그 돈은 캐릭터나 정착단위에서 빠르게 진행할 수 있도록 도와주지 않습니다. 게다가, 제국의 실제 비용은 꽤 적습니다. 다른 제국이 자신의 땅과 칭호를 놓고 경쟁하는 전쟁을 벌이거나 자신의 열정을 보여주기 위해 제국 전역에 기를 달거나 동상을 세우는 것이 시간, 돈, 자원을 많이 소모하게 될 것입니다. 이러한 방식으로 거의 누구나 경쟁이 적은 원격 지역에서 제국을 시작할 수 있지만, 세계적인 히게모니를 유지하기는 훨씬 어렵고 비싸게 들어갈 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임을 개발하는 데 많은 노력과 에너지를 투입했어요. 모든 플레이어에게 공평하고 장기적인 게임 개발팀을 유지할 수 있는 게임을 만들기 위해 노력했답니다. 우리는 BitCraft 세계를 수십 년간 구축할 수 있도록 혁신하고자 하는 목표 중에 이 시스템이 한 부분이에요. 게임에서 무료로 즐겁고 공평한 경험을 많은 사람들에게 제공하고, 게임에 돈을 지불함으로써 새로운 종류의 다이내믹하고 재미있는 코스메틱을 만드는 방식으로 수익을 창출하고자 합니다.\n\n저는 이것이 시도해볼 가치가 있다고 생각해요. 잘못되면 항상 수정할 수 있고, 우리가 공평함을 놓치지 않는 한 상황을 개선할 수 있을 거예요.\n\n새로운 시스템을 즐기시길 바랍니다.\n\n- 3Blave (Tyler)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시계 장인 랩스의 창립자입니다.\n","ogImage":{"url":"/assets/img/2024-06-19-EmpiresinBitCraft_0.png"},"coverImage":"/assets/img/2024-06-19-EmpiresinBitCraft_0.png","tag":["Tech"],"readingTime":5},{"title":"파 크라이 5의 매끄러운 오픈 월드 디자인이 대박이야","description":"","date":"2024-06-19 11:44","slug":"2024-06-19-FarCry5sSeamlessOpenWorldDesignisAwesome","content":"\n유비소프트에 대한 온라인에서 비난하는 것이 인기가 있다는 것을 알고 있어요 — 그리고 그들에 대해 답답해하는 사람들이 잘못했다고 생각하지 않아요.\n\n그들은 여러 명의 끔찍한 사람들에게 지도자의 자리를 줌으로써 적었다고 생각되는 부당한 보도를 받았고, 그로 인해 성희롱, 매우 열악한 개발 압박, 그리고 권력 남용에 대한 여러 혐의가 제기되었습니다. 비디오 게임 제작에 대한 그들의 \"공장\" 사고 방식은 여러 해 동안 유사한 디자인을 연달아 선보이고, 그들의 일부 프랜차이즈에 대한 팬들의 피로를 가져왔습니다.\n\n그리고 그들의 세 번째 활 암시부터 시작해서, 어쌔신 크리드 IV: 블랙 플래그의 저주받은 속편인 Skull and Bones는 출시까지 10년 이상이 걸려 출시된 것 같지만, 이는 싱가포르 정부로부터 세금 감면을 받기 위해 비밀리에 체결한 계약 덕분인 것 같아요.\n\n그 어느 것도 좋은 상황은 아니죠. 그렇지만 유비소프트는 여전히 다양한 장르를 대상으로 저희 수준의 게임을 출시하는 거대한 게임 회사입니다. 그리고 모든 행정적인 문제에도 불구하고 산업 내에서 최고의 디자인 재능을 소속으로 두고 있으니까요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2018년의 훌륭한 Far Cry 5를 살펴보면 게임 제작 경험의 많은 멋진 예가 어떻게 작용하는지에 대해 알 수 있어요. 몬태나의 허구 버전에서 설정된 이 게임은 이전 몇 개 설치의 거대한 캠프 청소 모험을 좁히고 동적 서술과 세계를 중심으로 한 새로운 디자인 패러다임을 세우는 상태에 있어요. 이전 제목보다 훨씬 자연스러운 방식으로 플레이어에게 퀘스트를 제공하며, 다른 오픈 월드 게임에 좋은 템플릿이라고 생각해요.\n\n물론, 첫 시간을 넘기지 못하면 그 멋진 새로운 것들 중 어느 것도 보지 못할 거예요. 그 첫 시간 동안 여러분을 게임의 세계로 곧바로 빠져들게 하며, 적대 세력으로 작용하는 종교 집단을 설정하죠. 그 후에는 이전 아쿠아 금증 게임들을 풍자하는 섬으로 여러분을 떨어뜨립니다. 거점을 소탕할 수 있는 맵의 아이콘들을 제공하고, 게임의 이동 및 전투 메커니즘을 소개합니다. 여러분을 라디오탑을 등반하도록 하기도 하며, 그 후로 복수의 라디오탑을 등반하는 것 자체를 조롱하기도 해요.\n\n유비소프트는 문을 열기 전에 예전의 방식을 확립한 뒤 해체해요. 옛날 스타일의 튜토리얼 섬의 끝에서, 게임 세계의 나머지에 떠다니던 짙은 안개가 걷혀져 아름다운 큰 숲이 드러납니다. 그렇게 말해요, \"안마 읽고 원하는 대로 이 일을 실제로 할 수 있다\"며 메인 캠페인을 시작하도록 여러분을 자유롭게 놓아줍니다.\n\n그 첫 지역 이후, 이 게임은 일반적인 예전 유비소프트 맵 아이콘 축제보다 훨씬 동적이고 생각 깊으며 플레이어의 시간을 존중해요. Far Cry 5는 세계가 더 활기차 보이도록 만드는 무작위 동적 이벤트들로 가득 차 있어요. NPC를 구하면 숨겨진 무기 보관장소나 적 성채에 대해 여러분에게 알려줄 수도 있어요. 그들은 심지어 여러분과 함께 가기를 제안할 수도 있어요. 이벤트는 플레이어가 그들에게 발견되기를 기다리기보다는 세계 전역에서 항상 일어나죠. 측면 콘텐츠에는 충분히 활기차고 에너지가 있어요. 그것들이 연결되어 큰 통일된 게임의 다음 부분처럼 느껴지며, 단순히 메뉴 상자에서 확인하려고 하는 것이 아니라고요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 플레이어는 Far Cry 5 컨텐츠의 세계를 통해 약간 다른 경로를 따릅니다. 어디서 기반을 둔 \"Radiant Quest\" 시스템과 비슷한데, 유비소프트의 세계는 더 혼돈스럽고 우스꽝스럽습니다. 한 번 공격당한 좋은 친구들을 구해줬는데, 그리고 그런 후에 어떤 여성이 와서 \"고마워!\"라고 외치고 근처 버려진 헬기에 올라타고 어딘가로 날아가는 재미있는 순간이 있었어요. 이런 순간들이 웃기기는 한데, 세상 속의 지속적인 활동과 생명력은 이곳이 실제 장소처럼 느껴지게 만들어줘서 게임 콘텐츠의 대형 메뉴 같지 않게 만들어줍니다.\n\n주요 임무들은 다른 게임에서와 같이 더 선형적이고 구조화되어 있는데요 — 그러나 어떤 순서로든 접근할 수 있는 점 때문에 선택한 진행 방식을 주변에 신중하게 작성해야 했습니다. 게임의 이야기는 그 잠재적인 장벽에도 불구하고 성공을 거두었는데, 정말로 오싹하고 사악한 악당들과 내가 지금까지 본 대형 예산 비디오 게임 중 가장 위험하면서도 멋진 엔딩 덕분입니다.\n\n엔딩이 여기서 이야기 가속에 중요한 부분이어서 \"이미\" 오래됐다는 이유로 말씀드리기를 원하지 않아요. 그냥 Far Cry: New Dawn이라는 미니지작에 완벽하게 연결되어 있다는 것만 언급하고 싶네요. New Dawn도 좋아하고 Far Cry 5에서의 잡다한 부분을 잘 끝맺음 해주어서 즐거운데요 — 맵을 지우면서 \"숫자가 올라가는\" 전형적인 게임 형식이라서 전신의 동적인 퀘스트 진행 경로가 적은 거죠.\n\n의사동적 구조를 사용하는 다른 유비소프트 게임을 찾고 계신다면 Far Cry 6나 Frontiers of Pandora로 가야 할 것입니다. 그렇지만, 저는 Far Cry 5가 더 잘 했다고 생각해요. Far Cry 6나 아바타 게임은 약간 더 \"게임적\"이고, 무슨 일이 일어나고 있는지를 상기시키는 것과 진행 상황을 확인하기 위해 메뉴로 자주 들어가는 것들이 있어요. Far Cry 5는 실행에서 좀 더 확실합니다. 단지 당신이 혼돈의 세계 속에서 존재하고, 조금 더 유도 없이 여기저기 순찰하고 임무를 수행하는 것을 두렵지 않아해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파 크라이 5의 아름다운 세계는 이 디자인을 아름답게 묶어줍니다. 자연을 감상하는 것을 좋아한다면 초대하는 곳이며, 모든 지평선에는 흥미로운 랜드마크가 충분히 있어 지도를 계속 열기보다는 자연스럽게 주변을 둘러보게 됩니다. 게임에서 플레이어의 손을 프레임 아래로 낮게 배치함으로써 화면의 상당 부분이 아름다운 세계를 보는 데 전념할 수 있도록 해줍니다. 저는 완전한 3D 지도 화면을 좋아합니다. 이것은 다른 Ubisoft 게임에서도 등장합니다. 그리고 단순히 마법적인 지도 지점을 활성화하는 대신에 실제 탐험을 통해 지도를 채우는 것은 저를 아름다운 풍경에 더 빠지게 만듭니다.\n\n파 크라이 5가 처음 출시될 때, 이전 타이틀의 경험치 바 시스템이 사라지고 새로운 게임에서 다양한 도전을 수행함으로써 얻는 퍼크 포인트로 대체된 것을 보고 제 내부에서 디아블로에 집착하는 부분이 실망했습니다. 하지만 이제 이러한 도전이 게임 시스템과 더 깊이 관여하도록 부드럽게 조언하는 것을 알게 되었습니다. 당신이 원하는대로 어떤 순서로든 여기에서 할 수 있는 것은 정말 무엇이든 가능하며, 도전을 통해 당신이 원하는 플레이 스타일을 찾도록 도와줍니다. 이 도전들은 당신이 새로운 것을 시도해보는 동안 중요한 부가능력을 잠궈두기 때문에 도움이 됩니다.\n\n파 크라이 5를 파워업하는 CryEngine 기반의 둘니아 기술은 여전히 놀랍게도 훌륭하게 유지되고 있습니다. 게임은 원래 PS4 세대에서 출시되었지만 최근에 향상된 설정을 갖추고 현대 콘솔에서 실행할 수 있는 패치를 받았습니다. PC 버전은 여전히 놀라운 모습을 자랑합니다. 하지만 파 크라이 6는 광선 추적 및 현대 업스케일링 기술과 같은 기능으로 이를 능가합니다.\n\n유비소프트가 다른 파 크라이에 대한 작업을 진행하고 있다면 좋겠으며, 이 동적 디자인에 계속적으로 손질해 나갔으면 하는 바람도 있습니다. NPC가 근처 가게에 대해 나에게 이야기하고 난 후 트럭에 올라 앞으로 날아가는 것이 조금 어색할 수 있습니다. 그렇지만 이것은 대부분의 다른 비디오 게임의 NPC의 제공할 수 있는 것보다 훨씬 많은 생명과 즐거움을 제공하며, 특정한 장소나 미리 정의된 경로를 벗어나 움직일 기회가 거의 없는 NPC에 비해 훨씬 더 매력적인 부분입니다. 파 크라이 5의 디자인은 플레이어를 압도하지 않으면서도 거대하고 동적인 오픈 월드 게임이 어떻게 느껴질 수 있는지를 훌륭하게 보여주는 좋은 예입니다. 지금 다시 방문해볼 가치가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 이 게임을 만드는 데 관여된 어떤 사람으로부터 글을 쓰라고 요청받지도, 보상을 받지도 않았어요. 스크린샷을 위해 사용된 복사본은 제가 직접 현금을 사용해 구입했습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-FarCry5sSeamlessOpenWorldDesignisAwesome_0.png"},"coverImage":"/assets/img/2024-06-19-FarCry5sSeamlessOpenWorldDesignisAwesome_0.png","tag":["Tech"],"readingTime":6}],"page":"38","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"38"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>