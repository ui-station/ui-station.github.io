<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/65" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/65" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="꿈같은 원격 인턴십을 얻은 방법" href="/post/2024-05-23-HowILandedaDreamRemoteInternship"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="꿈같은 원격 인턴십을 얻은 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="꿈같은 원격 인턴십을 얻은 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">꿈같은 원격 인턴십을 얻은 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요" href="/post/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">40<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="분산 애플리케이션에서 캐싱 마스터하기" href="/post/2024-05-23-MasteringCachinginDistributedApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="분산 애플리케이션에서 캐싱 마스터하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="분산 애플리케이션에서 캐싱 마스터하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">분산 애플리케이션에서 캐싱 마스터하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">28<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AI-강화 주제 탐구로 예술 창작을 재정의하기" href="/post/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AI-강화 주제 탐구로 예술 창작을 재정의하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AI-강화 주제 탐구로 예술 창작을 재정의하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AI-강화 주제 탐구로 예술 창작을 재정의하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 " href="/post/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl"> 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 </strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법" href="/post/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="크로스 플랫폼 앱 개발 로드맵" href="/post/2024-05-23-Cross-PlatformAppDevelopmentRoadmap"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="크로스 플랫폼 앱 개발 로드맵" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-Cross-PlatformAppDevelopmentRoadmap_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="크로스 플랫폼 앱 개발 로드맵" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">크로스 플랫폼 앱 개발 로드맵</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2023년 혁신적인 수익화 전략으로 2억 6천만 달러를 벌어낸 화이트아웃 서바이벌의 성공 비결을 알아보세요" href="/post/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2023년 혁신적인 수익화 전략으로 2억 6천만 달러를 벌어낸 화이트아웃 서바이벌의 성공 비결을 알아보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2023년 혁신적인 수익화 전략으로 2억 6천만 달러를 벌어낸 화이트아웃 서바이벌의 성공 비결을 알아보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2023년 혁신적인 수익화 전략으로 2억 6천만 달러를 벌어낸 화이트아웃 서바이벌의 성공 비결을 알아보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제이미니 API 사용 전에 읽어보세요" href="/post/2024-05-23-ReadthisBeforeUsingGeminiAPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제이미니 API 사용 전에 읽어보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제이미니 API 사용 전에 읽어보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">제이미니 API 사용 전에 읽어보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift에서의 고급 오류 처리 Try-Catch를 넘어서" href="/post/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서의 고급 오류 처리 Try-Catch를 넘어서" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서의 고급 오류 처리 Try-Catch를 넘어서" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift에서의 고급 오류 처리 Try-Catch를 넘어서</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link posts_-active__YVJEi" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"꿈같은 원격 인턴십을 얻은 방법","description":"","date":"2024-05-23 13:32","slug":"2024-05-23-HowILandedaDreamRemoteInternship","content":"\n여러 인턴십과 소프트웨어 개발 분야의 다양한 경험을 쌓은 뒤, 원격 인턴십을 위한 엄격한 채용 프로세스를 거친 내 최근 여정을 기쁘게 공유하려고 합니다. 이 모든 과정이 어떻게 진행되었는지 살펴보겠습니다.\n\n# 제 소개\n\n# 경험\n\n- SDE 인턴, NewGen Software\n- 풀스택 개발자 @Infiniti Solutions\n- 프론트엔드 엔지니어 @Spotline, USA (원격 근무)\n- UI/UX 디자이너, Fiverr\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 기술 스택\n\n- 언어: C++, JavaScript, Java\n- 백엔드 개발: Express.js, Node.js, Backend TypeScript\n- 프론트엔드 개발: HTML, CSS, React.js, TypeScript, Next.js, Tailwind\n- 데이터베이스: Firebase, MySQL, MongoDB, Prisma, Postgres\n- 버전 관리: Git, GitHub, Docker\n\n# 기회의 출처\n\n나는 직접 연락을 받아온 맴버로부터 Twitter DM을 통해 이 기회를 발견했어.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 면접 프로세스\n\n## 1차 심층 면접\n\n첫 번째 라운드는 역할과 관련 기술 스택에 대해 논의하는 간단한 30 ~ 40분간의 심층 면접이었습니다. 이 역할은 Next.js, TypeScript 및 Postgres와 AWS에 중점을 둔 풀-스택 SWE 인턴십을 위한 것이었습니다. 저는 이전 경험 및 인턴십을 자세히 설명하며 특히 Next.js 프로젝트에서의 업무를 강조했습니다.\n\n## 코딩 라운드 1\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 단계는 빠른 속도의 라이브 코딩 라운드였어요. 프론트엔드에 전자 메일 콘텐츠와 여러 이메일 주소를 입력할 수 있는 두 개의 입력 상자를 만드는 것이 제 몫이었어요. 시스템은 이메일 목록을 표시하고 이메일을 삭제하고 메일링 익스텐션을 통합해야 했어요. 저는 더미 이메일을 보내기 위해 Node-mailer와 Mailtrap을 선택했어요. 압박 속에서도 이러한 기능들을 성공적으로 구현했어요.\n\n![이미지](/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png)\n\n# 코딩 라운드 2/시스템 디자인\n\n이 라운드는 시스템 디자인과 코딩을 결합하여 거의 2시간 동안 진행되었어요. 저에게는 Excalidraw를 사용하여 레스토랑을 위한 팁 시스템을 디자인하라는 임무가 주어졌어요. 이 작업에는 화면 계획, 업로드 서비스 또는 AWS를 사용한 이미지 저장, 그리고 빠른 로딩 시간을 보장하는 것이 포함되었어요. 시스템 디자인을 완료한 후에는 빠르게 이 시스템의 초기 프론트엔드 화면을 코딩했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, 이전 라운드에서 소개했던 메일링 시스템을 새롭게 업데이트하여 Prisma DB 통합을 추가하여 사용자를 추가하고 삭제하는 기능과 이메일에 구독 해지 버튼이 추가되었습니다. 이 시연은 내 작업 능력을 강력하게 증명하는 계기가 되었습니다.\n\n# 문화적 적합성\n\n최종 라운드는 인사팀 및 팀 문화 적합성 인터뷰로, 내 사고 방식과 팀에 얼마나 잘 적응할 수 있는지에 중점을 두었습니다.\n\n# 결과\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일주일 후에, 인턴십에 선발되었다는 이메일을 받게 되었어요! 이 경험 전체가 믿을 수 없을 정도로 보람찼고, 이 새로운 여정을 시작할 수 있어 너무 흥분되고 있어요.\n\n![이미지](/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_1.png)\n\n# 회고와 조언\n\n과거의 기술 능력, 준비, 그리고 강력한 이전 작업의 시연이 성공에 중요한 역할을 했던 것으로 돌아봤을 때, 비슷한 기회에 대비하는 분들에게 다음을 추천해요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기술 스킬: 자신의 기술 스킬을 끊임없이 향상시키세요. 특히 해당 역할과 관련된 기술에 집중해보세요.\n- 준비: 정기적으로 코딩 및 시스템 설계 문제를 연습해보세요.\n- 프레젠테이션: 이전 작업물을 선보일 준비를 하고, 여러분의 사고 과정을 명확하게 설명할 수 있도록 준비하세요.\n- 문화적합성: 회사의 문화를 이해하고, 면접 중에 어떻게 그것과 일치하는지를 보여주세요.\n\n입사 시즌은 스트레스를 유발할 수 있지만, 끈기와 지속적인 개선이 중요합니다. 때로는 기회가 예상치 못한 때에 찾아올 수 있고, 모든 경험은 여러분의 여정에 가치를 더할 것입니다. 앞으로 나아가며, 성공은 따를 것입니다.\n\n이 상세한 설명이 비슷한 채용 과정을 거치는 분들에게 유용한 통찰을 제공했으면 좋겠습니다. 궁금한 점이 있거나 추가적인 조언이 필요하시면 얼마든지 연락해주세요. 여러분의 여정에 행운을 빕니다!\n","ogImage":{"url":"/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png"},"coverImage":"/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png","tag":["Tech"],"readingTime":4},{"title":"50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요","description":"","date":"2024-05-23 13:27","slug":"2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer","content":"\n## 이 법칙을 따르지 않으면 해고당할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png)\n\n수백 또는 아마 수천 가지의 파이썬 최고의 관행들이 있습니다. 누구에게 물어도 다소 다른 실천 방법을 얻을 수 있습니다.\n\n인터넷은 모든 사람에게 의견 표명의 권리를 부여했습니다. 심지어 저도 말이죠. 하지만 이 기사에서는 암호화된 50가지 파이썬 최고의 관행을 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n신이라도 조작할 수 없는 기술들이 있어요. 이러한 기술들은 전문가와 아마추어를 구분하며 다양한 프로그래밍 언어에도 적용할 수 있어요.\n\n대부분의 파이썬 개발자들은 코드를 빠르게 테스트하거나 오류를 디버그할 곳이 필요해요. 제가 만든 python-fiddle.com 이라는 웹사이트를 이용하면 코드를 빠르게 테스트하고 AI/LLMs를 사용하여 가능한 오류의 해결책을 찾아줄 수 있어요.\n\n만약 웹 스크래퍼를 만들거나 데이터를 분석하거나 암호화폐 관련 프로젝트를 개발하거나 기계 학습 모델을 만들거나 Django 또는 Flask 웹사이트를 만들거나 작업을 자동화하거나 SQL 관련 프로젝트 등이 필요하다면, 이 사람에게 메시지를 보내보세요.\n\n## 법칙 1: 가능한 한 주석을 피하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코멘트는 종종 사실과는 다른 내용을 전달할 수 있는 방식을 갖고 있어요. 코드가 실제로 무엇을 하는지가 아닌 다른 사람이 말하는대로 어떤 일을 하고 있는지를 읽는 사람의 마음을 벗어낼 수 있어요.\n\n시간이 흐르고 코드가 업데이트되거나 변경될 때 이 문제가 매우 심각해질 수 있어요. 어느 순간, 코멘트가 거짓이 되고 이제 모든 사람들은 거짓을 통해 진실을 관찰해야 할 수도 있어요.\n\n모든 비용을 피해야 하는 것이 코멘트에 대한 태도예요. 코멘트는 독자가 당신의 과거적인 생각을 상속받도록 강요해요. 함수나 클래스가 변경되면 대부분 코멘트는 함께 변경되지 않을 가능성이 높아요. 대부분, 코멘트는 독자가 앞으로 생각하도록 막을 수 있어요.\n\n코멘트는 작성자가 명확한 클래스, 함수 또는 변수 이름을 제시하지 못했다는 것을 나타냅니다. 이는 프로그래머의 태도의 부족을 드러내고 팀에 그러한 태도를 상속받도록 강요해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주석을 가능한 한 피해야 합니다.\n\n로우 14와 15에서는 언제 주석을 사용해야 하고 언제 사용하면 안 되는지 알 수 있습니다.\n\n## 로우 2: 변수에 타입 속성을 이름으로 사용하지 마세요\n\n가끔 특정 변수가 문자열인지 정수형인지를 명시하고 싶을 때가 있습니다. 따라서 일부 개발자는 변수를 다음과 같이 지정할 수 있습니다: name_of_variable_str 또는 name_of_variable_int.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n변수가 문자열인 것이 직관적으로 이해되는 경우와 같이, 변수가 결코 int(정수) 타입이 될 수 없는 경우에는 이것이 상당히 중복될 수 있습니다.\n\n그러나 변수 타입이 직관적이지 않은 경우에는 변수명을 지정할 때 타입을 명시하는 대신 타입 어노테이션을 사용하는 것이 가장 좋은 방법입니다.\n\nname_of_variable:str = value 대신 name_of_variable_str = value를 사용하는 대신 이 방법을 사용하면 모두가 변수가 문자열인 것을 알 수 있으며 코드를 깔끔하고 간결하게 유지할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법률 3: 클래스 이름은 명사여야 합니다.\n\n클래스 이름을 명사로 유지하는 것이 항상 최선의 실천 방법입니다.\n\n이는 대부분 클래스 객체가 특징과 동작을 식별하거나 표현하는 데 사용되기 때문입니다. 어떻게 양이 어떤 특징(뿔)과 행동(주변 사람에게 고개를 끄덕이다)을 나타내듯이요.\n\n이는 코드를 매우 가독성 있고 중복되지 않게 만듭니다. 예를 들어, Goat.get_horn_length() 대신 GetGoat.get_horn_length()을 사용하는 대신 Goat.get_horn_length()을 사용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법칙 4: 함수 이름은 동사여야 합니다\n\n함수는 인접한 개발자가 수행하는 작업을 명확하게 이해할 수 있도록 동사로 가장 잘 명명되어야 합니다.\n\n이는 주석이 필요 없어지게 하고 어떤 개발자든 원시 코드를 확인하지 않고도 정신적으로 개념화할 수 있도록 해줍니다.\n\n## 법칙 5: 함수는 매개변수와 반환 형식을 명시해야 합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수를 정의할 때는 항상 인수의 유형 및 함수의 결과가 반환하는 데이터 유형을 명시해야 합니다.\n\n이렇게 하면 당신과 팀의 개발자들 모두 print 문을 계속 사용하지 않고도 예상되는 결과를 알 수 있게 됩니다.\n\n![이미지1](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_1.png)\n\n![이미지2](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법칙 6: 함수는 한 가지 기능만 수행해야 합니다\n\n주니어 개발자들은 종종 이 규칙을 어기기 좋아합니다. 함수가 한 가지 기능만을 수행하는 것은 버그가 어디에 있는지 노출시키고 재사용성을 높이며, 함수 이름이 하는 일을 정확히 수행하도록 해줍니다.\n\n다음과 같은 일을 하고 싶지 않을 것입니다...\n\n![Img](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주소가 유효한지 확인하고 확인 후 위도와 경도를 반환합니다. 이 함수는 두 가지 작업을 수행합니다. 주소가 유효한지 확인하고 해당 주소의 지리적 위치를 반환합니다.\n\n다음은 더 나은 방법입니다.\n\n![Better Way](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_4.png)\n\n위의 함수들은 하나의 일만을 하고 그 이상의 일을 하지 않습니다. 덜 간결해 보일 수 있지만 훨씬 간결하고 가독성이 높습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수의 \"하나\" 기능을 정확히 알아내는 것은 새로운 개발자들에게는 약간 어려울 수 있어요. 함수가 무엇을 수행해야 하는지를 매우 구체적으로 명시해야 해요.\n\n보통은 함수 내에서 일부 작업을 추출하거나 그룹화하여 다른 하나의 함수로 만들 수 있다면, 아마도 함수가 한 가지 이상의 일을 수행하고 있는 것일지도 모르겠어요.\n\n또 다른 방법은 함수가 여러 수준의 추상화를 갖는지 여부를 확인하는 것이에요...\n\n## LAW 7: 함수는 동일한 추상화 수준에 있어야 해요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수가 동일한 추상화 수준에 있을 때 언급하는 것은 함수가 단일하고 명확한 작업을 수행해야 한다는 아이디어를 가리킵니다. 해당 작업은 함수 전체에서 일관된 추상화 수준에 있어야 합니다.\n\n다시 말해, 함수는 특정한 세부 사항이나 복잡성에 집중해야 하며, 모든 함수의 작업은 동일한 수준에서 작동해야 합니다.\n\n![image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_5.png)\n\n이 함수는 낮은 추상화 수준의 명령문을 가지고 있습니다. sum, len 등과 같은 것들이 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_6.png\" /\u003e\n\n예를 들어, 이 함수에는 여러 수준의 추상화가 있습니다. get_numbers()는 높은 수준의 추상화, 리스트 내포(list comprehension)는 중간 수준의 추상화이며 sum은 낮은 수준의 추상화입니다.\n\n## 제8의 법칙: 함수와 인수는 형제 자매처럼\n\n함수 이름은 매우 밀접하게 그 인수와 관련되어야 합니다. 함수 이름과 관련성이 없는 인수를 전달하는 것은 좋은 방법이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 코드를 Markdown 형식으로 변경해보세요.\n\nwrite(True)\n\nwrite(name)\n\n두 번째 예시가 함수가 정확히 무엇을 하는지 더 잘 설명하고 있어요. 이것을 읽는 사람에게 이름을 작성하고 있다는 사실이 명확해요.\n\n첫 번째 예시는 두 번째 예시만큼 명시적이지 않아요. 추측을 하거나 함수 전체를 살펴봐야 할 수도 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법칙 9: 함수는 작아야 합니다\n\n함수는 재사용 가능하도록 설계되었습니다. 그리고 함수가 커질수록 재사용 가능성이 낮아집니다. 이는 함수가 한 가지 일만 해야 하는 이유와 관련이 있습니다. 한 가지 일만 하면 함수가 작을 가능성이 높습니다.\n\n## 법칙 10: 불필요한 단어 및 중복 단어 피하기\n\n개발자가 변수나 함수의 의미를 더 명확하게 해주는 단어가 아닌 단어를 사용하는 시간도 있습니다. 이런 목록화:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_7.png)\n\n함수의 구현에 대한 사전 지식이 없으면 이를 본 개발자는 어떤 함수를 사용해야 하는지 알 수 없습니다.\n\n## LAW 11: 더러운 프로그래머가 되지 말라\n\n시니어 개발자라면 그가 코드가 깨끗할 때에만 정신적으로 맑다고 말할 것입니다. 이것은 더러운 코드를 작성하는 것이 더러운 프로그래머를 만들기 때문입니다. 깨끗한 코드는 팀의 모든 이들에게 깨끗한 코드를 계속 작성하도록 장려합니다. 항상 깨끗한 코드를 작성하도록 노력해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 깨끗한 코드란 무엇일까요? 깨끗한 코드는 잘 구조화되어 정리되어 있습니다.\n\n깨끗한 코드는 버그를 숨기지 않습니다. 프로그래머가 버그가 숨을 수 있는 어떤 곳이든 드러내며, 완전한 리팩토링 없이 쉽게 수정할 수 있는 공간을 마련해줍니다.\n\n## LAW 12: 개방폐쇄 원칙\n\n개방폐쇄 원칙(Open Closed Principles, OCP)은 클래스, 메서드 또는 함수가 확장을 위해 열려 있지만 수정에는 닫혀 있어야 한다고 말합니다. 이는 정의된 모든 클래스, 메서드 또는 함수가 코드를 변경하지 않고 여러 인스턴스에 재사용하거나 확장할 수 있도록 만든다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 예제를 들어보겠습니다. address라는 클래스가 있다고 가정해 봅시다.\n\n![address class](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_8.png)\n\n이것은 OCP를 준수하지 못한 것입니다. 새로운 국가가 추가될 때마다, 해당 국가를 보충하기 위해 새로운 if 문을 작성해야 합니다. 지금은 간단해 보일 수 있지만, 상상해 보세요. 100개 이상의 국가를 고려해야 한다면 어떻게 될까요?\n\n여기서 OCP가 중요한 역할을 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_9.png)\n\n이제 클래스나 함수를 수정할 필요가 없어서 보다 견고한 해결책입니다. 어떤 나라와 그 나라의 수도를考え하고 싶을 때 capital 사전만 조정하면 됩니다.\n\n또 다른 흔한 예는 클래스 상속을 사용하는 것입니다.\n\n예를들어:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 다른 지불 방법을 추가할 때마다 항상 PaymentProcessor 클래스를 수정해야한다는 것이 잘못된 방법입니다.\n\n더 나은 방법은 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 하면 새로운 결제 옵션을 추가해야 할 때마다, 예를 들어 암호화폐나 페이팔 같은 것, 이를 달성하기 위해 어떤 클래스도 수정할 필요가 없습니다. 단순히 다음과 같이 하면 됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_12.png\" /\u003e\n\n## 법칙 13: 리스코프 치환 원칙\n\n이 전 원칙을 살펴보면, 암호화폐를 사용하여 결제할 때 우리는 정확히 어떤 암호화폐를 보내는지 명시적으로 지정하지 않습니다. 금액만 명시합니다. 그래서 만약 우리가 암호화폐를 명시하고 싶어한다면, 일반적으로 다음과 같이 할 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom abc import abstractmethod\n\nclass PaymentProcessor:\n\n   @abstractmethod\n   def pay_tax(amount, crypto):\n      pass\n```\n\n그런 다음 각 결제 프로세서를 호출할 때 crypto 인수를 None 타입으로 선언하거나 필요하지 않은 경우 인수를 전달하지 않도록 기본값을 지정합니다. 이 두 경우 모두 Liskov Substitution Principle을 준수하지 못합니다.\n\n이는 부모 클래스 또는 추상 클래스가 대부분의 하위 클래스에게 관련이 없는 인수를 포함하고 있기 때문입니다.\n\n리스코프 치환 원칙(LSP)은 \"슈퍼클래스의 객체는 하위 클래스의 객체로 교체해도 프로그램의 정확성에 영향을 미치지 않아야 한다\"는 것을 명시합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLSP를 준수하기 위해 CryptoPaymentProcessor 클래스 내에서 암호화폐를 정의해야합니다. 이렇게 하면 다른 하위 클래스와의 불필요한 충돌을 방지할 수 있습니다.\n\n```js\nclass CryptoPaymentProcessor(PaymentProcessor):\n   def __init__(self, crypto):\n      self.crypto = crypto\n\n   def pay_tax(amount):\n      print(f'당신의 {self.crypto} 지갑으로 세금 지불이 진행됩니다')\n      print(f'{amount}을(를) 청구할 예정입니다.')\n```\n\n## LAW 14: 언제 코멘트를 사용해야 할지 알기\n\n코멘트를 사용해야 할 때마다 코드로 표현하지 못한 것에 대해 부끄러워해야 합니다. 그러나 댓글을 사용하면 실제로 코드 자체보다 코드의 기본 작업을 잘 설명하는 데 도움이 되는 경우도 있습니다. 여기 \"좋음\" 코멘트의 5가지 좋은 예제가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친절한 메모\n코드를 읽는 사람에게 코드를 더 잘 전달하는 데 도움이 되는 정보가 있는 메모를 작성하는 것은 언제나 좋습니다. 예를 들어 함수의 반환 값을 강조하는 메모는 더 많은 명확성을 제공할 수 있습니다. 그러나 이러한 메모는 명확한 함수 또는 변수 이름을 사용하여 불필요하게 만들 수 있습니다.\n\n할 일 메모\n이러한 메모는 다른 프로그래머들이 이 함수/작업이 아직 미완성이거나 수정이 필요하다는 것을 알 수 있도록 도와줍니다. 특정 함수를 구현하는 더 나은 방법이 있을 수도 있습니다. 때로는 코드가 주기적으로 실패할 수 있습니다.\n\n당신의 이유에 상관없이, 이러한 메모는 가져가는 것보다 더 많은 가치를 제공합니다. 할 일 메모는 일반적으로 과업이 완료되었거나 제대로 수정된 후에 제거되어야 한다는 것을 기억하기 때문에 코드가 변경되거나 개선될 때 거의 손대지 않는 경향이 있습니다.\n\n후행 작용 경고\n가끔은 다른 개발자들에게 잠재적인 위험을 알리고 싶을 때가 있습니다. 이 위험에 발을 딛게 되면 예기치 못한 결과가 생길 수 있습니다. 우리는 모두 하루를 생존하고 싶어합니다. 이 상황에서 메모가 문제를 해결하는 데 도움이 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 코드가 시간이 걸리거나 특정 시스템을 과부하시킬 가능성이 있는 경우, 독자나 다른 프로그래머에게 \"#COMPUTING RESOURCES를 많이 소비함\"과 같은 경고가 도움이 될 수 있습니다.\n\n## 법칙 15: 언제 주석이 나쁜가요?\n\n소음 주석\n이러한 주석들은 당연한 것을 다시 강조하는 주석입니다. 추가 정보를 제공하지 않고 코드의 더 많은 길이만 늘립니다. 많은 시간, 우리는 이러한 주석을 건너뛰곤 합니다. 소음 주석의 예시는 다음과 같습니다:\n\n```js\n# 동물 리스트에 추가합니다\nanimal.append(dog)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비 로컬 정보\n프로그래머들이 주석을 사용할 때 범하는 실수 중 하나는 전역 정보를 로컬에서 제공하는 것입니다. 주석을 작성할 때는 해당 함수나 문을 참조하는 것에만 관련되도록 유지하십시오. 그 외의 부분은 제거해야 합니다.\n\n명확하지 않은 주석\n우리가 알기에는 분명한 주석을 작성하기 쉽습니다만 다른 사람에게는 명확하지 않을 수 있습니다. 주석과 함수 간의 연결은 명확해야 합니다. 둘 다 동일한 단계나 절차를 따라야 합니다. 주석이 또 다른 주석을 필요로 하지 않도록 해야 합니다.\n\n짧은 함수\n짧은 함수에 대해 주석이 필요하지 않을 가능성이 높습니다. 함수가 짧을수록 좋은 이름으로 설명할 수 있는 가능성이 높습니다. 따라서 이러한 함수는 보통 자기 설명적입니다.\n\n## 법칙 16: 소스 파일을 짧게 유지하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소스 파일은 최대 500줄이지만 100–200줄 사이로 유지하는 것이 좋습니다. 매우 좋은 이유가 없는 한 다른 방법을 선택하는 것을 권장하지 않습니다. 소스 파일을 짧게 유지하면 재사용성과 가독성과 같은 다양한 명백한 이점이 있습니다. 또한 연결할 내용을 찾느라 스크롤하고 시간을 낭비하는 일이 줄어들기 때문에 유지 및 업데이트하기가 더 쉽습니다.\n\n## 법칙 17: 빈 줄 사용 시점을 알아두세요\n\n빈 줄은 새로운 개념과 분리된 부분으로 진행하고 있다는 것을 독자에게 알려주는 방법입니다. 각 줄 그룹은 완전한 생각을 나타냅니다. 이는 독자가 생각이 끝났는지를 이해하는 데 도움이 됩니다.\n\n## 법칙 18: 관련된 코드/함수/클래스를 가까이 유지하세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 가지가 강하게 관련이 없음을 나타내기 위해 공백을 사용하고, 강하게 연관된 것들은 공백을 사용하지 않습니다. 예를 들어 함수를 정의할 때...\n\n```js\ndef create(name):\n    print(name)\n```\n\n함수와 이름 변수 사이에 공백이 없습니다. 만약 공백이 있다면, 매우 조화롭지 않고 조직되지 않은 모습이 될 것입니다...\n\n```js\ndef create (name):\n    print (name)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수에 전달되는 인수는 구별되어야 합니다.\n\n## 법칙 20: 팀 규칙 준수\n\n거의 모든 개발자는 자신만의 스타일을 갖고 있습니다. 파일 이름 짓는 방식부터 print 문 작성 방식까지.\n\n하지만 다른 개발자들과 협업할 때는 개인적인 취향을 내려놓고 팀의 선호도를 받아들이는 것이 좋습니다. 다른 사람들이 당신의 코드에서 아름다움을 느끼지 못할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## LAW 21: 마법 숫자 피하기\n\n마법 숫자란 나중에 변경될 수 있는 하드 코딩된 값으로, 그래서 업데이트하기 어려울 수 있습니다.\n\n예를 들어, \"나의 주문\" 개요 페이지에서 마지막 50개 주문을 보여주는 페이지가 있다고 가정해봅시다. 여기서 50은 마법 숫자입니다. 왜냐하면 표준이나 규약으로 설정되지 않았으며, 명세서에 기술된 이유로 임의로 정한 숫자입니다.\n\n이제 50을 서로 다른 곳에 넣으시는 것입니다 — SQL 스크립트 (SELECT TOP 50 \\* FROM orders), 웹사이트 (마지막 50개 주문), 주문 로그인 (for (i = 0; i ` 50; i++)) 그리고 가능한 다른 많은 장소에.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 나쁨\n\nSELECT TOP 50 \\* FROM orders\n\n# 좋음\n\nNUM_OF_ORDERS = 50\nSELECT TOP NUM_OF_ORDERS \\* FROM orders\n\n## LAW 22: 깊은 중첩 피하기\n\n루프, 조건문 또는 함수 내의 중첩 수준을 제한하여 가독성을 향상시킵니다.\n\n# 나쁨\n\nif x:\nif y:\ndo_something()\n\n# 좋음\n\nif x and y:\ndo_something()\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## LAW 23: 임시 변수 피하기\n\n```js\n# 나쁜 예\ntemp_result = calculate(x, y)\nfinal_result = temp_result * 2\n\n# 좋은 예\nfinal_result = calculate(x, y) * 2\n```\n\n## LAW 24: 암호적 줄임말 피하기\n\n가독성을 높이기 위해 암호적 줄임말 대신 설명적인 이름을 사용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 나쁜 예시\n\ndef calc(x, y):\npass\n\n# 좋은 예시\n\ndef calculate_total_price(quantity, unit_price):\npass\n\n## 법칙 25: 경로 하드코딩 피하기\n\n파일 경로나 URL을 하드코딩하지 말고, 대신 구성 파일 또는 환경 변수를 사용해주세요.\n\n# 나쁜 예시\n\nfile_path = \"/path/to/file.txt\"\n\n# 좋은 예시\n\nimport os\nfile_path = os.getenv(\"FILE_PATH\")\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## LAW 26: 항상 Try-Catch-Finally 문 사용하기\n\n코드를 작성할 때, 오류 처리를 반드시 포함하는 것이 가장 좋습니다. 이렇게 하면 디버깅 프로세스를 가속화하고 코드의 정교성을 높일 수 있을 뿐만 아니라 코드를 깔끔하고 관리하기 쉽게 유지할 수도 있습니다.\n\n특정 코드에서 오류가 발생할 가능성이 높은 경우 try-catch 문을 사용하고 싶어할 것입니다.\n\nAPI 요청, 파일 처리 등의 작업은 어떤 이유로든 실패하거나 오류를 일으킬 가능성이 높습니다. 반면에 곱셈이나 나눗셈과 같은 작업에 대해 try-catch 문을 사용하는 것은 오히려 문제를 더 만들어내기 때문에 지양해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법칙 27: 예외와 함께 컨텍스트 제공하기\n\n예외가 발생했을 때는 해당 예외가 발생한 위치와 디버깅할 수 있도록 충분한 컨텍스트를 제공해야 합니다.\n\n예외와 함께 유용한 오류 메시지를 생성해야 합니다. 오류를 출력할 때 해당 작업이 실패한 컨텍스트와 실패 유형을 명시해야 합니다.\n\n## 법칙 28: 여러 예외 클래스 사용 피하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같은 코드를 본 적이 있나요?\n\n```js\ntry:\n    pass\nexcept ValueError:\n    pass\nexcept TypeError:\n    pass\nexcept IndexError:\n    pass\nexcept KeyError:\n    pass\nexcept FileNotFoundError:\n    pass\n```\n\n이 코드는 매우 부적절하며, 오류 처리에 추가 도움을 제공하는 대신 가독성, 복잡성 및 유지보수 측면에서 문제를 일으킵니다.\n\n우리가 마주칠 수 있는 모든 종류의 오류를 처리하기 위해 보다 일반적인 예외를 사용하는 것이 종종 더 나은 방법입니다. 기본적으로 이 유형의 예외는 우리가 받은 오류의 유형을 포함합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ntry:\n pass\nexcept Exception:\n pass\n```\n\n특정 유형의 오류를 잡고 싶을 때 다른 모든 오류가 통과될 수 있도록 해주세요.\n\n## 법칙 29: 함수는 변이하거나 값을 반환해야 하나 둘 다 하면 안 된다.\n\n함수를 작성할 때 해당 함수가 정확히 무엇을 해야 하는지 유의해야 합니다. 인수를 변이시킬까요? 아니면 반환해야 하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 함수가 전달된 인수를 변형시키면, 그 함수 안에서만 그 작업을 하면 됩니다. 그 이외의 곳에서는 건드릴 필요가 없어요.\n\n하지만 여기서 변형이 무엇을 의미하는 걸까요? 함수가 인수의 내용을 변경하거나 인수의 데이터 유형을 변경하는 경우 변형됩니다.\n\n```js\ndef changed(array):\n    array.append('hello')\n```\n\n만약 인수가 다른 변수를 만들기 위해 사용된다면 그것은 변형이 아닙니다. 예를 들어, 시간이라는 인수가 거리를 계산하는 데 사용된다면, 그것은 변형이 아니기 때문에 거리는 그 함수에서 반환될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef calculate_distance(time, speed):\n    distance = speed * time\n    return distance\n```\n\n하지만 두 마리 토끼를 모두 잡는 방법이 있어요. 함수의 인수를 복사하고 그에 대한 변이(mutation)를 수행할 수 있어요. 이렇게 하면 부작용을 피할 수 있어요.\n\n```js\ndef changed(array):\n    array_copy = array[:]\n    array_copy.append(4)\n    return array_copy\n```\n\n## 법칙 30: 모든 함수 이름이 동사일 필요는 없어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네, 알겠어요. 이전에 제가 언급했던 것처럼 모든 함수명은 일반적으로 동사여야 한다고 했었는데, 때로는 함수명이 명사 형태여야 하는 경우가 있습니다. 이것이 언제 그런지 아는 것은 이전 법칙/법칙 29에 근거합니다.\n\n인수를 변형하지 않고 무언가를 반환하는 함수라면, 함수명은 명사여야 합니다. 반면에 인수를 변형하고 반환하지 않는 함수는 동사여야 합니다.\n\n이것은 파이썬 자체에 내장된 일반적인 관례입니다. sort나 append와 같은 메서드는 데이터 유형을 변형하고 None을 반환하기 때문에 동사입니다. 반면에 sorted, sum, product와 같은 메서드들은 전달된 인수를 변형하지 않고 데이터의 새 복사본을 반환하기 때문에 모두 명사입니다.\n\n물론 이에는 예외가 있고, 한 번 예외 상황을 마주했을 때는 언제든지 동사를 사용하도록 되돌아가도 괜찮습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법칙 31: 클래스는 작아야 합니다\n\n그렇습니다! 클래스는 가능한 작아야 합니다. 함수와 마찬가지로요.\n\n함수에서는 크기가 함수 내의 줄 수에 의해 결정되지만 클래스에서는 책임의 수에 따라 결정됩니다.\n\n일반적으로 클래스 이름은 해당 클래스가 가질 수 있는 책임의 종류를 나타냅니다. 그러나 이름이 모호하거나 너무 일반적인 경우, 대부분 너무 많은 책임을 부여하고 있는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 클래스가 하나의 이유, 즉 변경할 책임이 하나만 있어야 한다는 SRP(단일 책임 원칙)로 되돌아가게 됩니다.\n\n## LAW 32: 클래스는 인스턴스 변수의 개수를 적게 가져야 합니다.\n\n인스턴스 변수는 클래스가 정의되거나 인스턴스화될 때 정의된 변수입니다.\n\n```js\nclass Animal:\n    def __init__(self, name):\n        self.name = name #인스턴스 변수\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 모든 우리의 함수가 클래스 책임과 관련이 있다면, 많은 인스턴스 변수를 가질 이유가 없어요.\n\n수많은 인스턴스 변수가 생기기 시작하는 건, 클래스의 핵심 역할에서 벗어난 함수 때문입니다.\n\n이러한 함수들은 다른 함수가 필요하지 않은 자체 변수를 가지게 됩니다.\n\n## 법칙 33: 당신의 클래스는 응집력이 있어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스 내의 모든 함수는 하나 이상의 인스턴스 변수를 포함해야 합니다. 함수가 클래스 내의 인스턴스 변수와 관련이 많거나 해당 변수를 포함하면 클래스의 응집력이 더 높아집니다.\n\n## 법칙 34: 자원 관리를 위해 with 문 사용하기\n\n파일이나 데이터베이스 연결과 같은 자원을 자동으로 관리하려면 with 문을 사용하여 해당 자원이 제대로 닫히거나 해제되도록 합니다.\n\n```js\n# 나쁜 예\nfile = open(\"example.txt\", \"r\")\ndata = file.read()\nfile.close()\n\n# 좋은 예\nwith open(\"example.txt\", \"r\") as file:\n    data = file.read()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법칙 35: 복잡한 삼항 표현식 피하기\n\n과도하게 복잡한 삼항 표현식 사용을 삼가하고, 코드를 더 잘 이해할 수 있도록 간결함보다 가독성을 선호하세요.\n\n```js\n# 나쁨\nresult = \"even\" if number % 2 == 0 else \"odd\" if number % 3 == 0 else \"neither\"\n\n# 좋음\nif number % 2 == 0:\n    result = \"even\"\nelif number % 3 == 0:\n    result = \"odd\"\nelse:\n    result = \"neither\"\n```\n\n## 법칙 36: 정체성 비교에 ‘is’와 ‘is not’ 사용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대부분의 경우, 우리는 두 변수 사이의 비교를 확인하기 위해 ==를 사용합니다. 불변 데이터 유형인 문자열이나 정수와 같은 경우에는 보통 두 변수가 동일한 메모리 위치에 저장되기 때문에 메모리 위치 확인은 필요하지 않습니다.\n\n그러나 list, dict 및 사용자 정의 객체와 같은 가변 데이터 유형과 작업할 때는 종종 변수의 서브 유형과 메모리 위치를 확인하는 is 비교 연산자를 사용하는 것이 더 좋습니다.\n\n가변 객체의 메모리 위치는 Python의 작동 방식 때문에 보통 같지 않습니다. Python은 가변 객체를 서로 다른 메모리 위치에 저장합니다. 이것은 언제든지 변경될 수 있으며 각 객체가 다른 객체와 독립적이어야 하기 때문입니다.\n\n문자열, 튜플 및 정수는 생성된 후에 변경할 수 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n아래 링크를 사용하여 이 코드를 실행해보세요:\nhttps://python-fiddle.com/saved/nV6iEIyBuHm2mevD9Bhg\n\n# 예시 2: 두 리스트가 동일한 객체를 참조하는지 확인\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]\n\n# 선호되지 않는 방법: == 사용\nif list1 == list2:\n    print(\"리스트는 동일한 값을 가집니다\")\n\n# 선호되는 방법: is 사용\nif list1 is list2:\n    print(\"리스트는 동일한 객체를 참조합니다\")\n\n# 참고: 이 경우에, list1과 list2는 동일한 값을 가진 다른 객체이므로,\n# `is`를 사용하면 `==`와 다른 결과가 나옵니다.\n```\n\n## LAW 37: 의존 역전 원칙\n\n의존 역전 원칙(Dependency Inversion Principle, DIP)은 객체 지향 설계의 중요한 원칙으로, 컴포넌트 간의 느슨한 결합을 촉진하고 소프트웨어 시스템의 보다 쉬운 유지보수와 확장을 돕습니다.\n\n고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다시 말해서, 클래스는 구체적인 구현이 아닌 인터페이스 또는 추상 클래스에 의존해야 합니다.\n\n```js\n# 나쁜 예\nclass Logger:\n    def log(self, message):\n        with open('log.txt', 'a') as f:\n            f.write(message + '\\n')\n\nclass Calculator:\n    def __init__(self):\n        self.logger = Logger()\n\n    def add(self, x, y):\n        result = x + y\n        self.logger.log(f\"{x}와 {y}를 더했습니다. 결과 = {result}\")\n        return result\n```\n\n위 예시에서 Logger 클래스를 정의하고 Calculator 클래스에서 직접 인스턴스를 생성합니다. 이로 인해 Calculator는 이제 Logger 클래스에 의존하며, Logger 클래스를 변경하면 Calculator 클래스도 수정해야 합니다.\n\n또한 이는 개방-폐쇄 원칙(확장에는 열려 있고 수정에는 닫혀 있음)을 지키지 못하는 것을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 좋은 코드\nfrom abc import ABC, abstractmethod\n\nclass LoggerInterface(ABC):\n    @abstractmethod\n    def log(self, message):\n        pass\n\nclass Logger(LoggerInterface):\n    def log(self, message):\n      with open('log.txt', 'a') as f:\n          f.write(message + '\\n')\n\nclass Calculator:\n    def __init__(self, logger: LoggerInterface):\n        self.logger = logger\n\n    def add(self, x, y):\n        result = x + y\n        self.logger.log(f\"Added {x} and {y}, result = {result}\")\n        return result\n```\n\n이 기능은 테스트하기가 더 어려울 수 있지만, 가짜 로거 클래스를 사용하여 테스트할 수 없게 만든다는 문제가 있습니다.\n\n이렇게 하면 인터페이스가 일관성을 유지하는 한 한 요소의 변경이 다른 요소에 변경을 요구하지 않기 때문에 모듈화를 촉진합니다.\n\n이 모듈성은 코드베이스를 더 쉽게 이해, 수정 및 확장할 수 있도록 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법칙 38: 데이터 유효성 검사에 'assert' 사용을 피하십시오\n\n'assert' 문은 디버깅 및 개발 목적으로만 사용하고, 제품 코드에서 데이터 유효성 검사에는 사용을 피하십시오.\n\n```js\n# 안 좋은 예\nassert x \u003e 0, \"x는 양수여야 합니다.\"\n\n# 좋은 예\nif x \u003c= 0:\n    raise ValueError(\"x는 양수여야 합니다.\")\n```\n\n## 법칙 39: 하드 코딩된 숫자를 피하십시오\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n명확성을 높이고 코드 수정을 쉽게 만들기 위해 의미 있는 이름으로 상수를 작성하십시오.\n\n```js\nDISCOUNT_RATE = 0.1\n\ndef calculate_discount(price):\n    discount = price * DISCOUNT_RATE\n    return price - discount\n```\n\n위 예제는 10% 할인을 나타내는 하드 코딩된 숫자 0.1을 사용합니다.\n\n이로 인해 숫자의 의미를 이해하기 어렵고 다른 부분에서 필요시 할인율을 조정하는 것이 어려워집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef calculate_discount(price):\n    TEN_PERCENT_DISCOUNT = 0.1\n    discount = price * TEN_PERCENT_DISCOUNT\n    return price - discount\n```\n\n개선된 코드는 숫자를 하드코딩하는 대신 TEN_PERCENT_DISCOUNT라는 이름이 지정된 상수로 대체합니다. 이 이름은 값의 의미를 즉시 전달하여 코드를 자체 문서화하는 데 도움이 됩니다.\n\n## LAW 40: DRY (Don’t Repeat Yourself) 원칙을 따르세요\n\n같은 코드를 한 번 이상 작성하지 않도록 합니다. 대신 함수, 클래스, 모듈, 라이브러리 또는 기타 추상화를 사용하여 코드를 재사용하세요. 이렇게 하면 코드가 더 효율적이고 일관되며 유지 보수가 용이해집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 표를 변경하여 마크다운 형식으로 변환해보세요.\n\n```js\n# 나쁜 예\n\ndef calculate_book_price(quantity, price):\n    return quantity * price\ndef calculate_laptop_price(quantity, price):\n    return quantity * price\n\n# 좋은 예\n\ndef calculate_product_price(product_quantity, product_price):\n    return product_quantity * product_price\n```\n\n## LAW 41: 존중할 만한 코딩 기준을 따르세요.\n\n공백, 주석, 그리고 명명에 대한 일반적으로 인정받은 컨벤션을 따르는 것이 중요합니다. 대부분의 프로그래밍 언어에는 커뮤니티에서 인정하는 코딩 표준과 스타일 가이드가 있습니다. 예를 들어, Python의 경우 PEP 8가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적으로 사용되는 관례들은 다음과 같습니다:\n\n- 변수, 함수 및 클래스 이름에는 snake_case를 사용합니다.\n- 들여쓰기에는 탭 대신 공백을 사용합니다.\n- 들여쓰기 단계마다 4개의 공백을 사용합니다.\n- 모든 줄을 최대 79자로 제한합니다.\n- 2진 연산자 앞에 줄바꿈을 넣습니다.\n\n## 법칙 42: 데메테르의 법칙\n\n데메테르의 법칙은 간단히 말하면 모듈/함수/클래스는 주변 모듈/함수/클래스에 대한 지식이나 참조를 가질 수 있지만 그 이상의 지식은 가져서는 안 된다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인접한 이웃이라 함은 직접 액세스할 수 있는 메소드, 함수 또는 변수를 의미합니다.\n\n예제를 통해 설명해드리겠습니다...\n\n```js\nclass Order:\n    def __init__(self, customer):\n        self.customer = customer\n\n    def get_customer_name(self):\n        # 위반 사항: 주문이 고객의 구조에 대해 너무 많이 알고 있습니다\n        return self.customer.get_profile().get_name()\n```\n\n이 예제에서 Order 클래스는 고객의 프로필에 직접 접근하여 고객의 이름을 검색합니다. Order는 고객 객체의 내부 구조에 액세스하여 프로필 및 이름에 접근하고 있으므로 이는 데메테르 법칙을 위반합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주변 이웃을 넘어서고 이제 고객 개체에 대해 너무 많이 알게 되었습니다.\n\n```js\nclass Order:\n    def __init__(self, customer):\n        self.customer = customer\n\n    def get_customer_name(self):\n        # 준수 사항: 주문은 직접적인 협력자와만 상호 작용합니다\n        return self.customer.get_name()\n```\n\n이 준수 사례에서 Order 클래스는 해당 고객 개체와만 상호 작용하고 고객의 이름을 검색하기 위해 직접적으로 메서드를 호출합니다.\n\n고객 개체의 내부 구조에 접근하지 않으므로 Demeter의 법칙을 따릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법칙 43: 간결함보다 가독성이 중요합니다\n\n코드는 기계가 해석할 수 있어야 합니다. 그러나 다른 개발자들도 코드를 이해할 수 있어야 합니다. 특히 여러 명이 참여하는 프로젝트에서 작업할 때는 더욱 중요합니다.\n\n소프트웨어 개발에서 가독성은 항상 코드의 간결성보다 중요합니다.\n\n만약 다른 개발자들이 이해할 수 없는 간결한 코드를 작성한다면, 그것은 별 의미가 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법칙 44: Import를 깨끗하게 유지하세요\n\n필요한 모듈과 심볼만을 가져와서 import 섹션을 깔끔하게 유지하고 가독성을 향상시키세요. 모듈에서 모든 (\\*) 것을 가져올 때, 모든 변수, 함수 및 클래스도 가져오게 되어 특정 함수/클래스가 어디서 온 것인지 알기 어려워지며, 최신 IDE를 사용할 때 번거로울 수 있습니다.\n\n예를 들어, get_file이라는 함수를 작성하고 싶다고 상상해보세요. g를 클릭하면 IDE가 g로 시작하는 함수/클래스/변수 목록을 추천해줍니다. 이렇게 되면 꽤 혼란스러워질 수 있습니다.\n\n이것이 더 큰 문제로 변하는 경우가 있습니다. 함수를 호출하려고 할 때 더욱 문제가 될 수 있습니다. 함수 이름이 추천 목록 사이에 잃어버릴 수 있고, 이제 IDE가 효율적인 해결책보다는 문제로 변할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 나쁜 예\n\nfrom module import \\*\n\n# 좋은 예\n\nfrom module import symbol1, symbol2\n\n## LAW 45: Null/None을 반환하지 마세요\n\n보통 함수를 정의할 때, 기본적으로 반환 값이 지정되지 않은 경우 None이 반환됩니다. 그렇지만 우리가 명시적으로 None을 반환할 때는, 해당 함수가 None 이외의 다른 값을 반환할 수 있다는 것을 간접적으로 읽는 사람에게 알리는 것입니다.\n\n만약 이게 사실이 아니라면, 많은 오해를 불러올 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 법률 46: 건설과 사용 분리하기\n\n관심사의 분리는 소프트웨어 공학에서 매우 기본적인 원칙이 되어왔습니다. 우리는 소프트웨어의 건설 방식을 사용 방식으로부터 분리하는 방법을 알아야 합니다.\n\n이는 종종 시작 과정, 즉 의존성 및 객체들이 결합되는 때와 실행 시간 로직, 즉 응용 프로그램 로직이 사용자 입력이나 다른 트리거로부터 실행되는 경우와 같은 것들을 분리하는 것을 의미합니다.\n\n건설과 사용을 분리하는 일반적인 방법은 main이라는 파일/함수/모듈에서 응용 프로그램 로직을 구성하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주요 기능은 응용 프로그램이 원활하게 실행되도록 필요한 객체를 구축합니다. 이렇게 함으로써 다른 모듈이 응용 프로그램에 강하게 결합되지 않도록하고 재사용성과 모듈성을 증진시킵니다.\n\n## LAW 47: 간단한 디자인에는 모든 이러한 규칙이 포함됩니다\n\n모든 테스트 실행: 시스템은 문서상으로 완벽한 디자인을 가질 수 있지만, 시스템이 의도한 대로 작동하는지 확인할 수 있는 방법이 없다면, 문서상의 디자인은 의문스러워집니다.\n\n중복이 포함되지 않음: 중복은 잘 설계된 시스템의 주요 적인 적수입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로그래머의 의도를 표현합니다\n\n클래스와 메소드의 수를 최소화합니다\n\n## LAW 48: 중첩된 Try-Except 블록 피하기\n\n너무 복잡한 오류 처리 논리를 방지하기 위해 try-except 블록을 과도하게 중첩하는 것을 삼가세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 나쁜 예시\ntry:\n    try:\n        # 오류가 발생할 수 있는 코드\n        pass\n    except ValueError:\n        # ValueError 처리\n        pass\nexcept Exception as e:\n    # 다른 예기치 않은 오류 처리\n    pass\n\n# 좋은 예시\ntry:\n    # 오류가 발생할 수 있는 코드\n    pass\nexcept ValueError:\n    # ValueError 처리\n    pass\nexcept Exception as e:\n    # 다른 예기치 않은 오류 처리\n    pass\n```\n\n## 법칙 49: 필요할 때만 동시성 사용하기\n\n동시성 기능을 구현할 때 나쁜 코드를 작성하기가 매우 쉽습니다.\n\n또한, 매우 결함이 많은 동시성 기능을 구현할 때 깔끔한 코드를 작성하는 것도 매우 쉽습니다. 보통 시스템에 많은 스트레스가 가해질 때까지 잘못되었다는 것을 인식하지 못할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n너는 매우 현명하게 전투를 선택하길 원해.\n\n너의 동시성 코드가 실패할 수 있는 여러 이유들이 있다. 여기 몇 가지 예시가 있다:\n\n굶주림(Starvation): 굶주림은 스레드나 프로세스가 공유 자원에 접근할 수 없어 계속해서 시도해도 영원히 실패하는 경우 발생한다. 이는 다른 스레드나 프로세스가 계속해서 자원을 확보하고 보유하여 굶주는 스레드가 진행하지 못하게 하는 경우에 발생할 수 있다.\n\n교착상태(Deadlocks): 교착상태는 두 개 이상의 스레드나 프로세스가 상호적으로 서로 자원을 해제하기를 무한정 대기하고 있는 경우 발생한다. 이는 각 프로세스가 한 자원을 보유하고 다른 프로세스가 보유한 다른 자원을 기다리며 순환 의존성을 만들어 서로 대기하는 경우에 발생할 수 있다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## LAW 50: 49가지 법칙을 따르세요\n\n이 법칙들은 당신을 소프트웨어 엔지니어로서의 여정에서 안내하기 위해 존재합니다. 필요할 때마다 이를 준수해야 합니다.\n\n그러나 경험과 기술이 쌓일수록, 특정 규칙을 따를 때와 그렇지 않을 때를 판단할 수 있는 능력을 가지고 싶을 것입니다.\n\n이 직관은 자신의 기술을 숙달한 사람들에게만 주어지며, 만약 초보자이거나 2년 전에 경력을 시작한 경우라면, 이 법칙을 하늘로 가는 유일한 티켓으로 여기는 것이 가장 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대부분의 파이썬 개발자들은 코드를 빠르게 테스트하거나 오류를 디버깅하는 곳이 필요합니다. 저는 python-fiddle.com이라는 웹사이트를 개발했습니다. 여기에서 빠르게 코드를 테스트하고 AI/LLMs를 활용하여 가능한 오류의 해결책을 찾을 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png"},"coverImage":"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png","tag":["Tech"],"readingTime":40},{"title":"분산 애플리케이션에서 캐싱 마스터하기","description":"","date":"2024-05-23 13:23","slug":"2024-05-23-MasteringCachinginDistributedApplications","content":"\n![마스터링 분산 애플리케이션의 캐싱](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png)\n\n소프트웨어 시스템의 캐싱 구현에서 버그를 만날 때마다 1달러가 있다면... 아마도 Redis Enterprise의 연간 기업 구독 비용을 지불할만큼의 돈이 쌓였을 것입니다.\n\n캐싱은 거의 올바르게 할 수 있지만, 결코 완벽하게 할 수 없는 것처럼 보입니다. 그것에는 좋은 이유가 있습니다. 결국 - 캐싱(또는 캐시 무효화)은 컴퓨터 과학에서 가장 어려운 두 가지 기본 문제 중 하나로 간주됩니다. 다른 하나는 변수의 명명이겠지요.\n\n농담인지 아니든 - 캐싱을 제대로 이해하는 것은 정말 어렵습니다 - 특히 대규모 분산 애플리케이션에서. 결과적으로 팀은 종종 캐싱 전략과 구현을 조정하기 위한 반복과 실험 과정을 거치며 - 마침내, 어느 정도 합리적이고 반최적적인 상태로 이르기를 희망하며.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글에서는 종종 간과되거나 오해되는 캐싱에 대한 몇 가지 측면을 명확하게 하고자 합니다.\n\n이 글을 읽은 후에는 캐싱이 무엇인지, 캐싱의 주요 접근 방식, 주의해야 할 사항 및 다양한 캐싱 기술을 실제 사용 사례에 어떻게 적용하는지에 대해 더 명확한 이해를 가지게 될 것입니다.\n\n그러니 더 이상 미루지 말고....\n\n# 캐싱이란?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐싱은 간략히 말해서 데이터를 임시 저장하는 동작으로, 데이터를 원본 저장소(기록 시스템)에서 검색하는 것보다 더 저렴하거나 빠르거나 최적화된 방법으로 검색할 수 있는 임시 매체에 데이터를 저장하는 것을 말합니다.\n\n다른 말로 하면, 다음과 같은 사용 사례를 상상해보세요.\n\n주문 관리 시스템이 재고 시스템에서 제품 정보를 검색해야 하는 상황입니다. 재고 시스템이 그다지 효율적이지 않다고 가정해보겠습니다. 요청이 들어올 때마다 제품 정보를 가져오기 위해 중앙 데이터베이스로 이동해야 합니다. 이 데이터베이스는 느리며 너무 많은 병렬 요청을 처리할 수 없습니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n성능을 향상시키고 재고 데이터베이스에 가해지는 부담을 완화하기 위해 캐싱 레이어를 도입했습니다. 이제 동일한 제품 정보를 저장하는 캐시가 추가되었습니다. 이제 버거운 데이터베이스를 거치지 않고 먼저 캐시에 접근하며, 캐시에 데이터가 있다면 그곳에서 가져옵니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_2.png)\n\n여기서 한 일은 성능을 향상시키고 원본 재고 데이터베이스의 자원 사용을 최적화하기 위해 임시 저장 매체(캐시)를 도입한 것입니다.\n\n# “캐시”란 무엇을 의미할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사람들이 혼동하기 시작하는 지점 중 하나는 캐시의 기술적 성격에 대해입니다.\n\n소프트웨어 개발 분야에 종사하는 대다수의 사람들은 \"캐시\"라는 용어를 들었을 때 매우 구체적인 연상을 갖게 됩니다. 종종 이 용어를 Redis, Memcached 또는 EHCache와 같은 분산 캐시 제품과 연관시킵니다. 때로는 브라우저 캐시, 데이터베이스 캐싱, OS 캐싱 또는 하드웨어 캐싱을 떠올리기도 합니다.\n\n이것이 바로 핵심입니다. 캐시의 개념은 컴퓨터 과학 분야 내의 특정 제품이나 영역으로 제한되지 않습니다. \"캐싱\"은 널리 생각되는 바에 따르면, 우리가 어떤 레코드 시스템으로부터 데이터를 복제하는 임시 매체의 어떤 형태라도 될 수 있습니다. 그렇게 하는 이유는 그 데이터를 임시 매체에 저장하는 것이 한 방이나 다른 방식으로 유리하기 때문입니다.\n\n이는 일반적으로 비용 절감, 성능 향상 또는 원본 저장소보다 더 나은 확장성 때문에 그렇습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 주문 관리 및 재고 시스템의 예제를 살펴보면 캐싱 레이어는 이론상 여러 가지로 구성될 수 있습니다:\n\n- 분산 캐싱 제품(예: Redis)\n- 자체 데이터베이스를 갖춘 다른 마이크로서비스\n- 실제 재고 관리 시스템 내부의 인메모리 저장소\n\n위의 모든 것은 서로 다른 구현이지만 각각 캐시의 조건을 충족할 것입니다.\n\n간단히 말하면 위에 언급된 모든 것들이 캐시가 될 수 있습니다. 컴퓨터 시스템 스택의 모든 수준과 다양한 디지털 도메인에서 캐싱이 구현될 수 있다는 개념으로, 직접 적용될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 용어정의\n\n계속하기 전에 캐싱 주제 주변의 다양한 용어를 이해하는 것이 중요합니다.\n\n- **시스템 레코드(System of Record):** 데이터가 저장되는 영구 저장소입니다. 대부분 데이터베이스일 가능성이 높습니다. 참 값 시스템(source-of-truth system)이라고도 합니다.\n\n- **캐시 미스(Cache Miss):** 응용프로그램이 캐시를 쿼리하지만 해당 레코드가 캐시에 존재하지 않을 때 발생합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로 고침된 데이터: 캐시에 있는 레코드가 기본 시스템과 얼마나 동기화되어 있는지를 나타냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐시 만료: 캐시 레코드를 에백션 프로세스의 일부로 또는 캐시 무효화의 일부로 시간 기반으로 제거하는 것을 의미합니다.\n\n이제 우리 모두가 캐싱 용어에 완전히 익숙해졌으니, 캐시가 구현될 수 있는 몇 가지 장소와 계층에 대해 살펴보겠습니다.\n\n# 캐싱은 어디에 구현되나요?\n\n이미 언급했듯이, 캐싱은 기술 영역 전반에 걸쳐 사용되며, 모든 수준 및 다양한 기술 스택 내에서 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하드웨어 수준에서 캐싱은 CPU 아키텍처의 일부로 사용되며, 예를 들어 레벨 1-3 (L1/L2/L3) 캐시 형식으로 사용됩니다.\n\n운영 체제 커널 수준에서는 페이지 캐시라고 알려진 디스크 캐시 형식이 있습니다. 다른 형태도 있습니다.\n\n웹 기반 시스템에서는 물론 브라우저 캐시와 CDN(Content Delivery Networks)가 있습니다. 이 캐시는 일반적으로 정적 리소스(이미지, 스타일시트 등)를 사용자에게 빠르고 효율적으로 제공하고 대역폭을 줄이는 데 사용됩니다.\n\n다양한 종류의 응용 프로그램 및 미들웨어에도 자체 캐시가 있습니다. 예를 들어, 데이터베이스는 자주 사용되는 쿼리 및 자주 반환되는 결과 집합을 저장하기 위해 캐싱을 사용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, Redis, EHCache, Memcached, Hazelcast, Infinispan 등과 같은 많은 견고한 소프트웨어 캐싱 제품이 존재합니다. 이 제품들은 분산 애플리케이션 내에서 확장 가능한 분산 캐싱을 가능하게 합니다.\n\n이제 강조할 한 가지는 \"분산\" 캐시 개념이 \"로컬\" 또는 \"지역화된\" 캐시와 대조될 수 있다는 점입니다. 분산 캐시는 네트워크 상에서 여러 기기에 분산된 캐시 형태입니다. 로컬 캐시는 한 기기에만 존재합니다.\n\n이 두 개념 간의 차이를 이해하는 가장 좋은 방법은 클러스터 서버에 배포된 애플리케이션을 상상해보는 것입니다. 다시 말해, 동시에 여러 애플리케이션 인스턴스가 실행되는 것이 큰 규모 애플리케이션 개발자에게 익숙한 상황일 것입니다.\n\n이러한 시스템에 분산 캐시를 도입한다면, 어떤 애플리케이션 인스턴스에서든 해당 캐시에 접근하고 레코드를 수정할 수 있게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 한편으로, 로컬 캐시가 있다면 각 인스턴스마다 자체 캐시가 있을 것입니다. 그 캐시는 대부분 해당 인스턴스의 메모리 내에 위치할 것입니다. 서로 다른 인스턴스들은 다른 인스턴스의 캐시에 접근할 수 없을 것입니다. 그들은 자신들의 캐시에만 접근할 수 있을 것입니다.\n\n이러한 두 가지 접근 방식에는 장단점이 있습니다.\n\n한편으로, 여러 인스턴스가 캐시에 접근하는 경우 - 동기화 문제, 경쟁 조건, 데이터 손상 및 분산 애플리케이션에서 발생하는 기타 도전 과제를 해결해야 할 수도 있습니다. 다른 한편으로, 공유 캐시는 강력한 개념입니다. 왜냐하면 그것으로 가능했던 사용 사례를 처리할 수 있게 해줍니다. 로컬, 더 단순한 캐시로는 불가능했던 것들도 처리할 수 있게 해주기 때문입니다.\n\n예를 들어, 여러 가용 영역 내에서 클라우드 환경에 애플리케이션을 배포할 수 있습니다. 각 가용 영역은 애플리케이션을 실행하는 VM 인스턴스 클러스터를 가질 것입니다. 이러한 클러스터는 아마도 각각 자체 분산 캐시를 가질 것입니다. 분산 캐시의 전제조건 중 하나는 그것에 빠르고 효과적으로 액세스할 수 있어야 한다는 것입니다. 이는 캐시의 인스턴스에 서비스하는 네트워크 근접성(물리적일 필요는 없지만 가상적일 수도 있음)을 가지는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동시에 분산 및 로컬 캐싱에 공통적으로 발생하는 몇 가지 도전 과제가 있습니다.\n\n주요 도전 과제는 데이터 신선도 유지, 최적의 캐시 무효화 및 제거, 그리고 캐시 관리 방식을 특정 사용 사례에 잘 맞추는 것 사이의 꾸준한 균형입니다.\n\n캐시 관리 — 캐싱 패턴은 다음에 다룰 중요한 개념입니다.\n\n소프트웨어 엔지니어링에서의 대부분의 결정과 마찬가지로, 각 접근 방식에는 각자의 절충안(또는 다른 말로 장단점)이 있습니다. 아래에서 각 접근 방식의 장단점을 다룰 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐싱은 소프트웨어 엔지니어와 소프트웨어 아키텍트 모두가 이해해야 하는 중요한 개념입니다. 그러나 이것이 유일한 개념이라고는 할 수 없습니다.\n\n내 안내서 — 소프트웨어 아키텍트의 경력을 여는 법, 에서는 시니어 이상의 소프트웨어 엔지니어 및 소프트웨어/솔루션 아키텍트가 숙달해야 할 다른 개념, 기술 및 기술을 설명합니다.\n\n여기에서 확인하세요\n\n![마스터링 분산 애플리케이션에서의 캐싱 이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 로컬 및 분산 캐싱 시스템의 패턴\n\n캐싱 시스템에는 다섯 가지 주요 캐싱 패턴이 있으며, 이들은 캐시가 데이터를 읽고 쓰는 방식 및 기본 시스템과 동기화하는 방식과 관련이 있습니다.\n\n# 캐시 옆에\n\n캐시 옆에 캐싱 전략은 아마도 가장 인기 있는 전략이며 대부분의 소프트웨어 엔지니어가 익숙한 전략입니다. 이 캐싱 접근 방식은 애플리케이션에 캐시 쓰기 및 읽기 제어를 완전히 맡깁니다. 여기서 애플리케이션은 데이터베이스 또는 캐시에서 읽을 때와 쓸 때를 모두 제어합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 그것이 작동하는 방법에 대한 예시입니다.\n\n당신의 애플리케이션이 사용자의 로그인 요청을 받고, 결과적으로 사용자의 우편 주소를 가져오게 된다고 상상해보세요.\n\n- 애플리케이션은 먼저 사용자의 주소가 캐시 내에 존재하는지 확인합니다.\n- 만약 해당 사용자의 주소 항목이 없다면, 애플리케이션은 데이터를 데이터베이스에서 가져옵니다.\n- 그러나 캐시 내에서 정보가 존재한다면, 해당 데이터는 즉시 검색되어 데이터베이스로의 여행을 절약합니다.\n- 새로운 정보를 가져온 후, 애플리케이션은 해당 데이터를 캐시에 기록합니다.\n\n2단계에서, 특정 아이템을 위한 캐시에 항목이 없다면 — 이것은 \"캐시 미스\"로 자주 언급됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_4.png)\n\n## 장점\n\n- 구현이 간단합니다.\n- 제어권은 애플리케이션에 완전히 남습니다.\n- 필요할 때만 캐시된 항목을 가져오므로 (게으른 로딩), 최소한의 메모리를 사용합니다. (이론적으로는)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Write-Through Caching\n\n- 캐시 미스 발생 시 더 느린 저장소에서 데이터를 가져와야 하므로 지연 시간이 높아집니다. 캐시 미스가 많아지면 성능에 영향을 줄 수 있습니다.\n- 애플리케이션 로직이 더 복잡해집니다 (전반적인 아이디어는 구현하기 쉽지만요).\n\n### 사용 시기\n\n- 캐시가 어떻게 채워지는지에 대한 완전한 제어를 원할 때.\n- 데이터베이스 읽기/쓰기를 관리할 수 있는 캐싱 제품이 없을 때.\n- 캐시에 대한 액세스 패턴이 불규칙할 때.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWrite-Through 캐싱은 캐시와 기본 영속 데이터 저장소 사이의 일관성을 보장합니다. 다시 말해, 쓰기가 발생할 때 캐시와 데이터베이스 양쪽으로 동시에 전파됩니다.\n\n다음은 예시입니다:\n\n- 재무 애플리케이션이 사용자 계정을 새로운 잔액으로 업데이트하는 요청을 받습니다.\n- 사용자 계정 잔액은 데이터베이스와 캐시 둘 다에 존재합니다.\n- 데이터베이스와 캐시가 동일한 트랜잭션 내에서 새 값으로 업데이트됩니다.\n- 다른 요청이 발생하면, 이번에는 사용자의 잔액을 읽는 요청이 옵니다. 먼저 캐시에서 값을 찾아 사용합니다. 캐시가 가장 최신 값을 가지고 있기 때문에 기본 데이터베이스와 동기화되지 않을까 걱정할 필요가 없습니다.\n\n참고로 3단계는 애플리케이션 로직을 통해 수행할 수 있습니다. 그러나 실제 캐싱 제품에서는 해당 역할을 하게 됩니다. 예를 들어 EHCache나 Infinispan을 사용하는 경우 애플리케이션은 Redis 캐시를 업데이트하고, 다시 데이터베이스를 업데이트할 수 있도록 구성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 코드가 Markdown 형식으로 변경된 것입니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_5.png)\n\n# 장점\n\n- 캐시와 기본 데이터 저장소 사이의 일관성을 보장합니다.\n\n# 단점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 트랜잭션 복잡성은 이제 캐시와 데이터베이스 업데이트 모두를 보장하기 위해 어떤 종류의 2단계 커밋 로직이 필요합니다 (캐시에 의해 제어되지 않는 한)\n- 운영상의 복잡성, 위의 어느 하나가 실패하면 사용자 경험을 세련되게 처리해야 합니다.\n- 쓰기가 더 느려집니다. 왜냐하면 이제 두 군데 (캐시 및 데이터 저장소)를 업데이트해야 하기 때문에 데이터 저장소에 하나만 업데이트할 때보다 더 많은 시간이 걸리게 됩니다.\n\n# 사용 시기\n\nStrong data consistency를 필요로 하고 퇴보된 데이터를 제공할 여유가 없는 애플리케이션에 적합합니다. 데이터가 작성된 직후 즉시 정확하고 최신 상태여야 하는 환경에서 흔히 사용됩니다.\n\n# Write-Around Caching\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 전략은 기본 저장소를 채우지만 캐시 자체는 채우지 않습니다. 다시 말해, 이 쓰기는 캐시를 우회하고 기본 저장소에만 쓰입니다. 이 기술과 Cache-Aside 기술 간에는 일부 중첩이 있습니다.\n\n차이점은 Cache-Aside에서 읽기와 지연로딩에 초점을 맞추는 반면, Write-Around 캐싱에서는 쓰기 성능에 초점을 맞추는 것입니다. 이 기술은 자주 데이터를 쓰지만 드물게 읽을 때 캐시 오염을 피하기 위해 종종 사용됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_6.png\" /\u003e\n\n# 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 캐시 오염이 줄어듭니다. 이는 모든 쓰기 작업에서 캐시가 채워지지 않기 때문입니다.\n\n## 단점\n\n- 일부 레코드가 자주 읽히고 캐시에 사전으로 로드되어 첫 번째 히트 시 데이터베이스로의 전송을 방지해야 하는 경우 성능이 저하됩니다.\n\n## 언제 사용해야 할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 양의 쓰기 작업이 이루어지지만 읽기 작업은 상대적으로 적을 때 자주 사용됩니다.\n\n# Write-Back (Write-Behind) 캐싱\n\n쓰기 작업이 먼저 캐시를 채우고 데이터 저장소에 기록됩니다. 이곳의 핵심은 데이터 저장소에 쓰기가 비동기적으로 발생한다는 점입니다. 그러므로 이러한 경우 두 단계 트랜잭션 커밋이 필요 없어집니다.\n\n쓰기 지연 캐싱 전략은 보통 캐싱 제품에서 처리됩니다. 캐싱 제품이 이러한 메커니즘을 갖고 있다면, 응용 프로그램은 캐시에 쓰기를 하고, 캐싱 제품은 변경 사항을 데이터베이스로 전송하는 책임이 있습니다. 만약 캐시 제품에서 이를 지원하지 않는다면, 응용 프로그램 자체가 데이터베이스로 비동기적인 업데이트를 트리거할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_7.png)\n\n## 장점\n\n- 초기 트랜잭션 내에서 캐시에만 쓰기 작업이 발생하므로 쓰기 속도가 빨라집니다. 데이터베이스는 나중에 업데이트됩니다.\n- 흐름을 캐싱 제품이 처리하면 애플리케이션 로직이 덜 복잡해집니다.\n\n## 단점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터베이스와 캐시가 새로운 변경 사항을 수신하게 될 때까지 둘 사이에 불일치 가능성이 있습니다.\n- 캐시가 최종적으로 데이터베이스를 업데이트하려고 할 때 오류가 발생할 위험이 있습니다. 이 경우 데이터베이스가 가장 최신 데이터를 수신하도록 보장하기 위해 더 복잡한 메커니즘이 필요할 수 있습니다.\n\n# 사용 시기\n\n쓰기 퍼포먼스가 중요하고 데이터베이스의 데이터가 캐시와 잠시 동안 약간 동기화되어 있어도 괜찮을 때 쓰기 지연 캐싱을 사용할 수 있습니다. 높은 쓰기 부하를 처리해야 하지만 일관성 요구사항이 덜 엄격한 애플리케이션에서 적합합니다. 이 방법이 사용될 수 있는 한 예는 캐시된 콘텐츠를 빠르게 업데이트한 다음 레코드 시스템에 동기화하는 CDNs(콘텐츠 전송 네트워크)입니다.\n\n# 읽기 - 스루\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐시 생성 방식은 일반적으로 캐시 옆에 두어 캐시 미스 발생 시 데이터베이스로부터 데이터를 가져온후 캐시에 저장하는 것에 유사합니다. 그러나 캐시 생성 방식은 애플리케이션에게 캐시와 데이터베이스를 모두 질의하는 책임을 맡기는 반면, 읽기-스루는 해당 메카니즘을 가지고 있을 경우 해당 제품에게 질의하는 방식입니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_8.png)\n\n# 장점\n\n- 간편함 — 모든 로직이 캐싱 애플리케이션에 캡슐화되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단점\n\n- 캐시 미스 발생 시 데이터베이스에서 데이터를 읽을 때 잠재적인 지연이 발생할 수 있습니다. 데이터 업데이트를 위한 복잡한 무효화 메커니즘이 필요합니다.\n\n# 사용 시기\n\n리드-스루 캐싱은 데이터에 접근하는 코드를 간소화하고자 할 때 사용됩니다. 또한, 캐시가 항상 데이터 저장소의 가장 최근 데이터를 포함하도록 보장하고 싶을 때 사용됩니다. 쓰기보다 읽기가 더 자주 발생하는 애플리케이션에 유용합니다. 그러나 여기서 중요한 점은 캐싱 제품이 구성 또는 기본 시스템에서 이러한 읽기를 수행할 수 있는 능력을 가져야 한다는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 캐싱 전략 요약\n\n다섯 가지 캐싱 패턴에 대해 이야기한 내용을 아래에서 요약했습니다.\n\n## 캐시 옆에 캐싱\n\n애플리케이션이 캐시에서 데이터를 찾지 못하고 요청할 때만 요청에 따라 데이터가 캐시로 로드됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 예시: 온디맨드로 제품 세부 정보를 캐싱하는 전자 상거래 웹사이트.\n\n데이터베이스 작업 책임: 응용 프로그램\n\n## 쓰기-스루\n\n일괄 쓰기 작업은 일괄 캐시 및 기본 데이터 저장소에 동시에 작성되어 일관성을 유지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 예시: 거래마다 일관된 계좌 잔액을 유지하기 위한 은행 시스템\n\nDB 작업 책임: 캐싱 제품 또는 애플리케이션\n\n## Write-Behind (Write-Back)\n\n쓰기 작업은 먼저 캐시에 기록되고 나중에 데이터 저장소에 비동기적으로 기록됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 예시: CDN이 먼저 캐시에 콘텐츠를 업데이트하고 나중에 스토리지 시스템에 동기화하는 방식입니다.\n\nDB 작업 책임: 제품 또는 애플리케이션 캐싱\n\n## 라이트-어라운드\n\n쓰기 작업은 캐시를 우회하고 데이터 저장소를 직접 업데이트하여 즉시 필요하지 않은 데이터를 캐싱하는 것을 피합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 예시: 로그 작업에 대한 어디에서 캐싱없이 직접 스토리지로 기록합니다.\n\n데이터베이스 작업 책임: 애플리케이션\n\n## Read-Through\n\n캐시는 읽기를 위한 주요 인터페이스 역할을 합니다. 캐시에 데이터가 없으면 시스템에서 해당 데이터를 가져와 캐시에 저장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 예시: 사용자 프로필 서비스가 캐시 미스 상황에서 사용자 데이터를 가져오고 캐싱하는 경우.\n\nDB 작업 책임: 제품 또는 응용 프로그램 캐싱\n\n## 캐시 무효화\n\n이제 우리는 캐시를 채우는 다양한 방법을 이해했으니, 기록 시스템과 동기화하여 유지하는 방법도 이해해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐시 무효화에 관한 두 가지 주요 접근 방식은 시간 기반 방식과 이벤트 기반 방식입니다. 무효화를 위한 시간 기반 접근 방식은 대부분의 캐싱 제품에서 제공되는 TTL(Time-To-Live) 설정으로 제어할 수 있습니다. 이벤트 기반 접근 방식은 응용 프로그램이나 다른 요소가 새 레코드를 캐시로 전송해야 합니다.\n\n데이터 캐시에 대한 중요한 점은 거의 항상 기본 데이터 저장소(시스템 기록)와 어느 정도 동기화되어 있지만 매우 빨리 구식이 된다는 것입니다. 다시 말해 — 구식 상태가 됩니다. 캐시를 가능한 한 시스템 기록과 동기화된 상태로 유지하기 위해 캐시 무효화 전략을 구현해야 합니다.\n\n다시 말해, 캐시 내에서 데이터 \"신선도\"를 보장해야 합니다.\n\n캐시 무효화는 새 레코드가 시스템 기록으로부터 검색되어 캐시로 입력되는 현상을 유발합니다. 따라서 캐시 무효화와 위에서 논의한 캐싱 전략 사이의 관계를 이해하는 것이 매우 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n캐싱 전략은 데이터가 캐시에서 로드되고 검색되는 방식과 관련이 있습니다. 반면에 캐시 무효화는 시스템 레코드와 캐시 간 데이터 일관성과 신선도와 더 관련이 있습니다.\n\n따라서 이 두 가지 개념 사이에는 약간의 중첩이 있으며 일부 캐싱 전략에서는 무효화가 다른 것보다 간단할 수 있습니다. 예를 들어 캐시-쓰기 쓰기 방식의 경우 캐시가 모든 쓰기마다 업데이트되므로 추가 구현이 필요하지 않습니다. 하지만 삭제는 반영되지 않을 수 있기 때문에 명시적으로 이를 다루는 응용 프로그램 논리가 필요할 수 있습니다.\n\n캐싱 엔트리를 무효화하는 두 가지 방법이 있습니다:\n\n## 이벤트-드리븐\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이벤트 기반 접근 방식을 사용하면 응용 프로그램이 기록의 기반 저장소에서 변경이 발생할 때마다 캐시를 알립니다. 레코드가 변경될 때마다 동기적 또는 비동기적으로 캐시에 알림을 트리거합니다.\n\n이 작업은 응용 프로그램을 통해 수행할 수 있으며, 코드가 캐시를 최신 상태로 유지하는 것에 책임이 있습니다. 또는 일부 캐싱 제품에서는 퍼브/섭 기능이 제공될 수 있으며, 캐싱 제품이 이러한 유형의 알림에 가입할 수 있습니다. 그 경우 응용 프로그램에서 할 작업이 덜 할 수 있지만, 여전히 이러한 알림 이벤트를 생성해야 합니다.\n\n## 시간 기반\n\n시간 기반 접근 방식을 사용하면 모든 캐시 레코드에 TTL(임시 소멸 시간)이 지정됩니다. 레코드의 TTL이 만료되면 해당 캐시 레코드가 삭제됩니다. 이것은 일반적으로 캐싱 제품에 의해 제어됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 캐시 축출 전략\n\n캐시 축출은 기존 캐시 레코드를 제거하는 캐시 무효화와 유사합니다. 그러나 캐시 축출은 캐시가 가득 차서 더 이상 레코드를 수용할 수 없는 경우에 필요합니다.\n\n기억하세요, 캐시의 목적은 가장 자주 액세스되는 레코드의 부분 집합을 저장하는 것입니다. 전체 진실의 원본 시스템을 복제하는 것이 아닙니다. 따라서 캐시의 크기는 일반적으로 데이터베이스 / 진실의 원본 / 기록 시스템에 저장된 데이터의 크기보다 훨씬 작을 것입니다.\n\n따라서 레코드를 \"축출\" 또는 다른 말로 삭제할 수 있는 메커니즘이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동시에 캐시의 존재 이유를 완전히 무의미하게 만들지 않기 위해 애플리케이션이 제일 필요하지 않을 것으로 생각되는 레코드부터 시작해야 합니다.\n\n최적으로 레코드를 제거하는 방법을 보장하기 위해 사용할 수 있는 몇 가지 퇴직 전략이 있습니다:\n\n## Least Recently Used (LRU)\n\n이 접근 방식을 통해, 얼마 동안 사용되지 않은 레코드를 제거합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 시기: 데이터가 마지막으로 액세스된 후 시간이 경과함에 따라 데이터가 곧 액세스될 가능성이 줄어드는 시나리오에서 효과적입니다. 미래 액세스의 강력한 지표인 액세스 최근성을 고려하는 일반적인 캐싱에 적합합니다.\n\n사용하지 말아야 할 때: 데이터 액세스 패턴이 최근성과 관련이 없는 워크로드에는 이상적이지 않습니다.\n\n## 먼저 들어온 것이 먼저 나간다 (FIFO)\n\n다른 레코드보다 이전에 캐시에 저장된 레코드를 제거합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용할 때: 데이터의 나이가 액세스 빈도나 최근성보다 중요한 캐시에 유용합니다. 예측 가능한 수명을 가진 데이터를 캐싱하는 데 적합합니다.\n\n사용하지 않을 때: 이전 데이터가 여전히 빈번하게 액세스되는 워크로드에는 최적이 아닙니다.\n\n## 최소 사용 빈도 순서 (LFU)\n\n빈번하게 사용되지 않거나 액세스되지 않는 레코드를 삭제합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 시기: 오랜 기간 동안 자주 액세스되는 데이터를 보관해야 하는 상황에 가장 적합합니다. 안정된 액세스 패턴을 갖는 애플리케이션에 적합합니다.\n\n사용하지 말아야 하는 경우: 액세스 패턴이 크게 변할 수 있는 환경에서는 효과가 떨어집니다. 자주 액세스되지 않는 항목들이 캐시를 오염시킬 수 있습니다.\n\n## Time To Live (TTL)\n\n미리 결정된 Time-To-Leave 기간에 따라 퇴거합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 시기: 특정 기간 이후에 만료되거나 변하지 않는 데이터에 이상적입니다.\n\n사용하지 말아야 할 때: 유효성이 시간이 지나면 자연스럽게 종료되지 않고 다른 요인에 따라 캐시에 영원히 남아있어야 하는 데이터에 적합하지 않습니다.\n\n## 무작위 치환\n\n기록을 무작위로 대체합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 시점: 고급 추적 메커니즘의 비용이 혜택을 상쇄하는 상황이거나 액세스 패턴이 예측할 수 없어 다른 제거 전략이 적합하지 않은 경우에 사용할 수 있습니다.\n\n사용하지 않는 시점: 대체로 다른 전략에 비해 대부분 예측 가능한 액세스 패턴이 있는 실제 시나리오에서는 효율이 떨어질 수 있습니다.\n\n# 요약\n\n분산 응용 프로그램에서 캐싱의 중요성과 올바른 캐싱 전략을 선택하는 중요성에 대해 이야기했습니다. 일반적으로 사용되는 여러 전략이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 캐시 오프 (Cache-aside)\n- 쓰기-스루 캐시 (Write-through cache)\n- 읽기-스루 캐시 (Read-through cache)\n- 쓰기 배후 캐시 (Write-behind cache)\n- 쓰기 주변 캐시 (Write Around)\n\n우리는 또한 시간 기반 또는 이벤트 기반 접근 방식을 사용하여 캐시 무효화에 대해 이야기했습니다.\n\n캐시 제거의 중요성과 어떤 전략이 그 일을 수행하는지에 대해 주목했습니다. 이것들은 다음과 같습니다:\n\n- LRU\n- FIFO\n- LFU\n- TTL\n- 임의(Random)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 캐시는 로컬 또는 분산 형태일 수 있습니다. 전자는 단일 기계/응용프로그램 인스턴스에 한정되어 있습니다. 후자는 여러 기계에 걸쳐 확장되며 일반적으로 (필수는 아니지만) 인스턴스 클러스터에 한정되어 있습니다.\n\n많은 혁신이 시장에서 발생하고 있는 캐시 제품과 관련된 기술들과 유행에 대해 몇 가지 명확한 정보를 제공했기를 바랍니다. 왜 캐싱이 중요한지, 그리고 캐싱 기술을 다룰 때 이해해야 하는 모든 다른 용어와 미묘한 점에 대한 직관력을 향상시켜주길 바랍니다.\n\n# 캐싱: 미래\n\n다른 기술들과 마찬가지로 캐싱 제품이 시장에서 엄청난 혁신이 일어나고 있습니다. 일부 주목할만한 하이라이트는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 에지 컴퓨팅과 통합\n\n에지 컴퓨팅이 계속해서 성장함에 따라, 캐싱 전략은 더 분산화되어 데이터를 네트워크 가장자리에 필요한 위치에 더 가까이 이동시킵니다. 이 근접성은 레이턴시, 대역폭 및 데이터 제공 비용을 줄입니다. 이는 IoT 및 모바일 앱과 같은 실시간 응용 프로그램에 매우 중요합니다.\n\n예시: 자율 주행 차량은 에지 컴퓨팅을 사용하여 실시간 데이터를 로컬에서 처리합니다. 지도 및 교통 상황과 같은 핵심 데이터를 에지 노드에서 캐싱하면 중앙 서버를 쿼리하는 레이턴시 없이 신속한 의사결정을 할 수 있습니다.\n\n# AI와 머신 러닝 기반 캐싱\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAI와 머신 러닝은 데이터 사용 패턴을 예측하고 예상된 필요에 따라 미리 데이터를 캐싱함으로써 캐싱 메커니즘을 향상시킬 수 있습니다. 이러한 예방적인 접근 방식은 효율성을 크게 향상시킬 수 있습니다. 특히 데이터 액세스 패턴이 자주 변경되는 동적 환경에서는 더욱 그렇습니다.\n\n예시: 아마존은 머신 러닝을 사용하여 사용자 행동을 예측하고 블랙 프라이데이와 같은 피크 타임에 사용자가 구매할 가능성이 높은 제품을 미리 캐싱합니다. 이는 로드 시간을 줄이면서 사용자 경험을 향상시킵니다.\n\n# 인메모리 데이터 그리드 (IMDG)\n\nIMDG는 분산 시스템 전반에 걸쳐 저지연 복잡한 데이터 액세스를 제공하는 캐싱의 강력한 솔루션이자 빠르게 발전하고 있습니다. IMDG는 데이터를 캐싱뿐만 아니라 캐시 레이어 내에서 다양한 데이터 처리 기능, 실시간 분석 및 의사 결정 기능을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시: 고주파 트레이딩 플랫폼은 IMDG를 활용하여 시장 데이터와 거래 주문을 메모리에 캐시합니다. 이를 통해 서브초 단위 거래 결정을 내리는 데 필수적인 빠른 액세스와 처리가 가능해집니다.\n\n안녕하세요, 저는 야코프입니다. CloudWay Digital Inc을 운영하고 있는 소프트웨어 아키텍처 컨설팅 기관인 Developer.Coach에서 소프트웨어 엔지니어와 아키텍트들이 경력을 향상시키는 데 도와드리고 있습니다.\n\n제 Medium 무료 기사 외에도, 소프트웨어 엔지니어링 전문가들의 경력 향상에 도움이 되는 가이드 몇 편을 작성했습니다. 아래 링크를 통해 확인해보세요:\n\n👉 소프트웨어 아키텍트의 경력 잠금 해제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 소프트웨어 아키텍트 인터뷰 마스터하기\n\n👉 소프트웨어 엔지니어링 경력 잠금 해제: 중급에서 시니어로\n\n원본 게시물: 2024년 5월 17일, https://www.cloudwaydigital.com 에서 게시됨.\n","ogImage":{"url":"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png"},"coverImage":"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png","tag":["Tech"],"readingTime":28},{"title":"AI-강화 주제 탐구로 예술 창작을 재정의하기","description":"","date":"2024-05-23 13:21","slug":"2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration","content":"\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png)\n\n기술의 끊임없는 발전 속에서 AI는 계속해서 한계를 넓히고 가능성을 재정의합니다.\n\nAsycd에서는 스스로에게 이렇게 물었습니다: AI를 활용하여 예술적인 과정을 혁신할 수 있는 방법은 무엇일까요? 이 질문은 TEV1 – 테마틱 익스플로러 V1의 탄생으로 이어졌습니다. 그러나 TEV1의 변화의 힘에 대해 들어가기 전에, 그 탄생 배경과 갖추고 있는 탁월한 기능들을 탐험해보겠습니다.\n\n# 왜 우리가 TEV1을 만들었는가\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![TEV1 Image 1](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_1.png)\n\nTEV1의 시작은 예술적 창작 프로세스를 단순화하고 향상시키는 욕망에서 비롯되었습니다. 우리는 작가, 작가 및 크리에이터들이 종종 자신의 비전과 일치하는 주제를 개념화하고 시각물을 생성하는 데 상당한 시간을 소비한다는 것을 인지했습니다. 우리의 목표는 이러한 시간과 노력을 줄이고, 창작자들이 핵심 창작 작업에 더 집중할 수 있는 도구를 디자인하는 것이었습니다.\n\n게다가, 특히 DALL-E 3 및 GPT-4o와 같은 도구를 통한 인공 지능의 발전으로 고품질의 특정 주제 이미지를 생성하는 잠재력이 실행 가능하고 매력적해졌습니다. TEV1은 이러한 잠재력을 활용하기 위한 우리의 대응책으로, 창작자들에게 강력하고 직관적인 도구를 제공하여 세계 어디서나 사용할 수 있도록 합니다.\n\n![TEV1 Image 2](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한 이미지 생성 능력의 발전에 큰 투자 관심을 가지고 있습니다. 이미지 생성 도구를 사용하여 아이디어를 반영적 이미지로 변환하는 능력은 이미 훌륭하지만, 우리가 생각하는 것과 볼 수 있는 것 사이의 간격을 좁히는 것이 중요합니다.\n\n마음에 떠오르는 무작위 아이디어를 화면이나 캔버스, 심지어 의류 디자인으로 구현하는 것이 TEV1의 목적입니다.\n\n# TEV1 작동 원리\n\nTEV1은 최첨단 AI 기술인 DALL-E 3과 이미지 생성 및 콘텍스트 이해, 이미지 프롬프트 향상을 위해 GPT-4o를 사용하여 구축되었습니다. 사용자가 주제를 입력하면 TEV1은 이러한 고급 모델을 사용하여 주제를 분석하고 해당 주제의 본질을 담은 시각적 표현물을 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_3.png)\n\n저희 도구에는 컨텍스트 로딩, 자동 데이터 처리 및 RAG와 같은 복잡한 기능이 포함되어 있어 생성된 이미지가 관련성을 가지고 미학적으로 매력적인 것을 보장합니다. 현재는 관심도 및 성능을 측정하기 위한 샘플 생성에 제한되어 있지만, TEV1은 지속적인 사용자 피드백과 모델 훈련을 통해 발전하도록 설계되었습니다.\n\n## 데이터에서 아트로 — 우리가 새로운 아트워크를 위해 역사적 데이터를 활용하는 방법\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAsycd의 설립 이후로 우리는 예술을 생성하고 텍스트 설명을 만드는 작업을 진행해 왔습니다. 이러한 텍스트 설명은 대부분 내부에서 저장되어 사용되어 왔지만, 앞으로 출시될 웹 애플리케이션을 위한 TEV1 모델 훈련에 사용될 예정입니다.\n\n오늘을 기준으로 이러한 설명 중 일부는 저희 웹사이트에서 접근 가능한 곳에 공개되어 있습니다. 이 데이터를 사용하여 이전과 동일한 프롬프트 기술과 스타일을 활용하여 새로운 작품을 만들고 있습니다. 이 과정에 대해 자세히 다룰 예정이며, 이는 매우 상세한 과정이기 때문입니다.\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_5.png)\n\n우리는 이 데이터를 활용하여 이전 작품에 성공적인 프롬프트 기술과 스타일을 사용하여 새로운 작품을 생성합니다. 이를 통해 과거 작업에서 영감을 빨아들이면서도 지속적이고 고품질의 예술을 만들어낼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# TEV1: 예시 및 사용 사례 소개\n\nTEV1은 다양한 시각 디자인 분야에서 사용되며 다양한 매체에 대한 매우 상세한 그래픽을 생성할 수 있습니다.\n\n## 예술적 영감\n\nTEV1의 주요 사용 사례 중 하나는 예술적 영감을 제공하는 것입니다. 예술가들은 '어두운 심리학'부터 '로맨티시즘'까지 다양한 주제를 입력할 수 있으며, TEV1은 이러한 주제와 일치하는 이미지를 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_6.png)\n\nTEV1은 짧은 아이디어나 개념을 이야기를 담은 예술작품으로 변화시킬 수 있어요. 빠르게 떠오르는 영감을 활용하기에 안성맞춤이에요. 첨단 프롬프트 공학과 다양한 대형 언어 모델의 다층구조 덕분에, 테마 익스플로러 V1은 이미지뿐만 아니라 주제에 맞는 시각적 일치 작품을 생성해요.\n\n이 종합적인 방법론은 덧없는 생각을 다채롭고 표현력 풍부한 작품으로 변모시켜요. 이 작품들은 소셜 미디어 게시물부터 마케팅 자료 등 다양한 용도로 사용할 수 있어요.\n\n## 그래픽 디자인과 웹 디자인\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n취미로 즐기는 분들과 열정적인 창작가들을 위해 TEV1은 개인 프로젝트를 현실로 만들어 주는 견고한 플랫폼을 제공합니다. 개인 블로그를 위한 독특한 시각적 콘텐츠 작성, 소설을 위한 스토리보드 디자인, DIY 프로젝트를 위한 주제별 아트워크 초안 작성 등, TEV1은 창작하는 여러분의 작품에 전문적인 손길을 더해줍니다.\n\n우리는 이 도구를 사용하여 웹사이트의 장식을 완전히 맞춤화했고, 지속적인 개선 노력 덕분에 우리 웹사이트가 이전보다 더 멋지게 변했습니다!\n\n![TEV1 이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_7.png)\n\n웹 디자이너들은 TEV1 이미지 생성기를 활용하여 자신들의 웹사이트에 완벽한 배경 씬을 설정할 수 있는 매료되는 이미지를 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래픽 디자이너들에게 TEV1 세대는 가능성의 보물창고입니다. 그들은 끝없는 패턴, 생동감 넘치는 디자인, 그리고 고유한 구성에 접근하여 창의적인 과정을 시작하거나 프로젝트에 마지막 손짓을 더할 수 있습니다. 이는 올해 초부터 \"VALENHEARTS\" 컬렉션에서 작업한 예술가들에 의해 그렇게 사용되었고, 이 도구의 창의적인 힘을 조금 오박사 단계에서 목격했습니다.\n\n![TEV1](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_8.png)\n\n## 모든 것을\n\n우리는 이것을 창의적이거나 디자인 중심의 모든 것에 사용할 수 있다고 생각합니다. 우리는 캔버스로 시작했지만, 희망적으로 다른 모든 가능한 사용 사례를 탐색할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 마케팅 및 광고: 캠페인, 소셜 미디어 게시물 및 광고를 위한 독특하고 화려한 시각물을 제작합니다.\n- 게임 개발: 컨셉 아트, 캐릭터 디자인 및 환경 텍스처를 생성합니다.\n- 패션 디자인: 원단을 위한 패턴과 프린트를 개발합니다.\n- 인테리어 디자인: 커스텀 이미지로 방 구성과 장식을 시각화합니다.\n- 교육: 설명적인 다이어그램과 창의적인 이미지로 학습 자료를 향상합니다.\n- 엔터테인먼트: 음악 앨범, 책 표지 및 프로모션 포스터를 위한 아트워크를 제작합니다.\n\n# 곧 만나요!\n\nTEV1을 계속 개발하고 개선하는 동안, 여러분은 여기에서 시도해보시고 피드백을 제공해 주시기 바랍니다. 웹 앱의 예상 출시일은 6월 말이니 조금만 기다려 주시고, 계속 영감을 얻어 주세요!\n\n“항상 할 수 있는 것이 있다” - \"Asycd\"\n","ogImage":{"url":"/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png"},"coverImage":"/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png","tag":["Tech"],"readingTime":7},{"title":" 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 ","description":"","date":"2024-05-23 13:20","slug":"2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign","content":"\n요즘에는 인공 신경망에 대해 많은 사람들이 이야기하지만 자신의 신경 체계에 대해 알고있는 사람은 매우 드물어요.\n\n![이미지](/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png)\n\n제품 개발에 관여하는 모든 사람들에게 중요한 것은 사용자가 제품을 인지하는 데 필요한 것을 이해하는 것입니다:\n\n1. 제품에 주목하게 만드는 것 (외생적 주의),\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Keep a sustained interest (internal attention),\n\n3. Purchase the product with the belief that it will meet your needs.\n\nTherefore, we have three main neural networks:\n\n✅ 1. Default Mode Network - which controls our social reasoning. You might remember how you naturally start thinking about your family, coworkers, or someone who was rude to you in line.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 조상들이 작은 그룹에서 함께 생활하며 형성된 가능성이 높아요. 이것은 그들이 부족한 것들 사이에서 모든 사회적 상호작용을 이해하고 지켜주는 데 도움을 주었고, 한 마디로 말해 전체 네트워크를 형성했어요 — 이것이 뇌의 기본 시스템이에요. 이 기본 시스템은 다른 이들의 반응을 예측할 수 있어요. 수천 년 동안 우리 뇌는 신체적으로 크게 변하지 않았지만, 해야 할 일들의 목록은 크게 증가했어요. 우리는 다양한 문제를 해결하기 위해 같은 DMN을 사용하며, 사람들을 일시적으로 그것에서 떼어내어 해방된 공간에 사실, 추상적인 개념, 숫자, 그래프를 채워 넣어 일을 할 수 있어요.\n\n✅ 2. Salience Network — 이 시스템은 특정 지적 작업에 집중할 수 있는 능력을 제공해요. 들어오는 정보를 처리하고 외부 자극을 평가해요.\n\n✅ 3. Central Executive Network — 또한 들어오는 정보를 처리하고 외부 자극을 평가하고 분석해요.\n\n중요한 점은 이 세 시스템이 서로 경쟁한다는 것이에요🤓.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 작업에 집중할 때 (주의 네트워크) 주변에 덜 주의를 기울이게 되고, 그러면 어쩌다가 누군가와의 불쾌한 대화에 대해 생각하게 되는 경우가 생길 수 있어요 (기본 모드 네트워크가 우세해집니다).\n\n💡 광고에 있어서 외부 주의 (광고 배너와 같은 외부 신호로 인한 주의)가 어떻게 작용하는지 이해하는 것이 중요합니다.\n\n💡 온보딩에 있어서 중요한 것은 관심이 인위적으로 유발될 수 있다는 것을 깨달아야 합니다. 뇌는 어떤 것에 대한 이해의 모형을 형성하기 전에 사실들의 집합을 축적할 수 있는 능력을 갖고 있어요. 처음에는 흥미로워 보이지 않더라도, 사실이 축적되고 성공적인 작업 완료로 강화되는 경우, 흥미가 발전할 수 있어요. 이것이 온보딩의 주요 기능 중 하나에요.\n\nP.S. 다음에는 우리 뇌가 구매 결정을 내리는 방식에 대해 이야기할 거에요 😇.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n","ogImage":{"url":"/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png"},"coverImage":"/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png","tag":["Tech"],"readingTime":3},{"title":"SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법","description":"","date":"2024-05-23 13:19","slug":"2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro","content":"\n\u003cimg src=\"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png\" /\u003e\n\n안녕하세요! 오늘은 여러분께, 널리 확장된 로직을 사용하지 않고 모든 텍스트 필드를 한꺼번에 유효성을 검사하는 방법을 보여드리려고 합니다. 이번에는 텍스트 필드의 유효성을 검사하는 나쁜 방법과 좋은 방법을 구분하는 것을 목표로 하고 있어요.\n\n먼저, 예제를 아주 간단하게 유지할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n세 개의 텍스트 필드와 사용자 입력을 저장하는 비밀번호를 위한 한 개의 보안 필드가 있는 화면이 있다고 가정해봅시다. 이 숫자는 간단히 유지하기 위한 것이며, 실제 상황에서는 10개가 될 수도 있습니다.\n\n```js\nstruct ContentView: View {\n   @State var email : String = \"\"\n   @State var password : String = \"\"\n   @State var name : String = \"\"\n   @State var surname : String = \"\"\n    var body: some View {\n          VStack {\n             TextField(\"이메일\", text: $email)\n             TextField(\"이름\", text: $name)\n             TextField(\"성\", text: $surname)\n             SecureField(\"비밀번호\", text: $password)\n             Spacer().frame(height: 300)\n             Button {\n\n\n             } label: {\n                Text(\"여기를 눌러보세요!\")\n                   .padding(.all)\n                   .background(.red)\n                   .cornerRadius(16)\n             }\n          }\n          .padding()\n       }\n}\n```\n\n이제 나쁜 방식과 좋은 방식을 구분하여 느껴보겠습니다.\n\n#나쁜 방식\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nButton {\n    // 먼저 원하는 방식으로 유효성을 확인합니다.\n    if email.count \u003e 6 \u0026\u0026 password.count \u003e 12\n            \u0026\u0026 !name.isEmpty \u0026\u0026 !surname.isEmpty {\n        // 네트워킹 호출 수행!\n        // 이것은 영원히 계속됩니다.\n        // 읽기가 어렵고 확장 가능하지 않으며 재사용 가능하지 않습니다.\n    } else {\n        // 얼럿 팝업 등을 표시합니다.\n    }\n\n} label: {\n    Text(\"여기를 탭하여 시도해보세요!\")\n        .padding(.all)\n        .background(.red)\n        .cornerRadius(16)\n}\n```\n\n# 좋은 방법\n\n이제 진짜 작업이 시작되었지만, 먼저 이 솔루션을 사용하기 위해 SwiftUI의 일부 주요 기능을 알아야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**PreferenceKey**\n\nPreferenceKey 유형은 자식 뷰에서 부모 뷰로 뷰 트리를 업데이트하는 데이터 흐름을 처리하는 솔루션인데, 어떤 종류의 위임이나 생성자 핸들러를 사용하지 않고도 작업할 수 있습니다. 제가 본 바로는 널리 사용되지 않지만, 정말 복잡하지는 않습니다. 어느 정도로 보면, @EnvironmentObject의 역이라고 할 수 있습니다.\n\nPreferenceKey는 이미 NavigationView의 타이틀이나 TabViews 선택 및 자식의 id 등에 사용되고 있습니다.\n\n우리가 어떻게 사용자 정의 preference key를 정의할 수 있는지 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n구조체 ValidationPreferenceKey : PreferenceKey {\n   static var defaultValue: [Bool] = []\n\n   static func reduce(value: inout [Bool], nextValue: () -\u003e [Bool]) {\n      value += nextValue()\n   }\n}\n```\n\n이것은 사용자 지정 PreferenceKey를 정의하는 구문입니다. 이 특정 프로토콜을 준수하기 위해 두 가지를 구현해야 합니다.\n\n```js\nstatic var defaultValue: [Bool] = []\n```\n\n이 기본 값은 Equatable을 준수하는 한 어떤 것이든 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nstatic func reduce(value: inout [Bool], nextValue: () -\u003e [Bool]) {\n      value += nextValue()\n   }\n```\n\n우리는 이 줄이 키가 등록된 키의 여러 반복에서 무엇을 해야 하는지를 정의하는 리덕션 함수를 구현해야 합니다.\n\n예를 들어, TabView가 있고 그 안에 여러 개의 하위 뷰가 있고 모두 .id() 수정자를 가지고 있다고 하면, 이 reduce 함수는 모든 id 수정자 값에 사용됩니다.\n\nTextField에서 이를 사용하려면 두 단계가 필요합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1- 뷰 수정자\n\n2- 익스텐션\n\n이제 이를 위해 ViewModifier를 어떻게 구현하는지 보여드릴게요\n\n```js\nstruct ValidationModifier : ViewModifier  {\n   let validation : () -\u003e Bool\n   func body(content: Content) -\u003e some View {\n         content\n            .preference(\n               key: ValidationPreferenceKey.self,\n               value: [validation()]\n            )\n      }\n   }\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 수정자는 그 특정 뷰에 해당하는 키를 등록합니다.\n\n```js\nlet validation: () -\u003e Bool\n```\n\n이 변수는 우리가 유효성 검사에 사용할 로직을 보유할 것입니다.\n\n그리고 이 확장은 이를 일부 특정 유형의 뷰에 대해서만 적용합니다. TextFields 및 SecureFields와 같은 뷰입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nextension TextField {\n   func validate(_ flag: @escaping () -\u003e Bool) -\u003e some View {\n      self\n         .modifier(ValidationModifier(validation: flag))\n   }\n}\n\nextension SecureField {\n   func validate(_ flag: @escaping () -\u003e Bool) -\u003e some View {\n      self\n         .modifier(ValidationModifier(validation: flag))\n   }\n}\n```\n\n여기서 중요한 두 가지 아쉬움이 있습니다. 첫째로, 우리는 TextFields 텍스트를 노출할 수 없습니다. 이것은 이니셜라이저에서만 사용 가능하며 Apple에 의해 노출되지 않습니다.\n\n둘째로, TextField와 SecureField는 View가 아닌 동일한 형식에서 상속되지 않기 때문에 이것을 단일 확장으로 줄일 수 없습니다. 해결 방법이 있다면 알려주세요!\n\n이 modifier를 다른 뷰에서 사용할 수 없도록 유지하려면 동일한 파일에서 modifier와 확장을 정의하고 modifier를 private으로 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막 부분 빼고는 설정이 완료되었어요.\n\n마지막으로, 이 키의 업무를 처리할 뷰를 정의해야 해요.\n\n```js\nstruct TextFormView\u003cContent : View\u003e : View {\n   @State var validationSeeds : [Bool] = []\n   @ViewBuilder var content : (( @escaping () -\u003e Bool)) -\u003e Content\n   var body: some View {\n         content(validate)\n         .onPreferenceChange(ValidationPreferenceKey.self) { value in\n            validationSeeds = value\n         }\n   }\n\n   private func validate() -\u003e Bool {\n      for seed in validationSeeds {\n         if !seed { return false}\n      }\n      return true\n   }\n}\n```\n\n이 컨테이너 뷰는 이 키 타입에서 로직을 실행하고, Vstack 또는 TabView와 같은 뷰를 내부에 가져옵니다. .onPreferenChange 수정자를 본 적 있나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 수정자는 이 키에서 자식 뷰 업데이트를 잡습니다.\n\n그래서\n\n```js\n.preference(\n               key: ValidationPreferenceKey.self,\n               value: [validation()]\n            )\n```\n\n이렇게 업데이트됩니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n.onPreferenceChange(ValidationPreferenceKey.self) { value in\n  validationSeeds = value\n}\n```\n\n각 자식 뷰의 키 값을 캐치해요. [Bool]가 아니라 Bool로 반환했던 것 기억하시죠? 이건 단지 validationSeeds 변수에 할당하기 위한 것이에요. 이 validationSeeds 변수는 .validate() 확장 ValidationPreferenceKey로 수정된 각 자식 뷰를 보유하고 있어요.\n\n이제 모든 필드의 Key 값이 TextFormView에 있으니 이 데이터를 처리하고 무언가를 구축할 수 있어요.\n\n```js\nprivate func validate() -\u003e Bool {\n  for seed in validationSeeds {\n    if !seed { return false }\n  }\n  return true\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 함수는 그냥 제가 생각해 낸 것일 뿐이에요. 필수적이지는 않지만 저는 좋아해요.\n\n```js\n@ViewBuilder var content : ((@escaping () -\u003e Bool)) -\u003e Content\n                        // (validate) -\u003e Content 이게 무슨 뜻인지에요.\n```\n\n우리는 그냥 이 TextFormView 바깥으로 이 validate 함수를 노출시키는 것 뿐이에요.\n\n이제 이것을 우리 뷰에서 사용할 수 있고, 다음과 같이 될 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 유효성 검사를 만들었지만, 실제 상황에서는 정규식과 다른 로직을 사용하여 유효성을 검사해야 합니다. 어쩌다 그렇게 했어요.\n\n```swift\nstruct ContentView: View {\n   @State var email : String = \"\"\n   @State var password : String = \"\"\n   @State var name : String = \"\"\n   @State var surname : String = \"\"\n   var body: some View {\n\n       TextFormView  { validate  in // -\u003e 이 부분이 바로 validate 함수에요\n          VStack {\n             TextField(\"Email\", text: $email)\n                .validate {\n                   email.count \u003e 6\n                }\n             TextField(\"Name\", text: $name)\n                .validate {\n                   !name.isEmpty\n                }\n             TextField(\"Surname\", text: $surname)\n                .validate {\n                   !surname.isEmpty\n                }\n             SecureField(\"Password\", text: $password)\n                .validate {\n                   password.count \u003e 10\n                }\n             Spacer().frame(height: 300)\n             Button {\n                if !validate() {\n                   return\n                }\n                // 네트워크 호출을 해주세요\n             } label: {\n                Text(\"Tap here to try!\")\n                   .padding(.all)\n                   .background(.red)\n                   .cornerRadius(16)\n             }\n          }\n       }\n          .padding()\n    }\n\n}\n```\n\n미리 말씀드린 대로 이미지 삽입과 함께, 어떻게 동작하는지 보여주기 위해 validate()을 출력했어요. 모든 필드가 함께 유효성을 검사하는 모습이에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기까지 읽어 주셔서 감사합니다.\n\n이것은 시작에 불과하다는 것을 잊지 마세요. 이것을 사용하여 오류 메시지를 반환하거나 어떤 필드가 유효하지 않은지 선택할 수 있습니다. 나중에 이를 사용자 정의할 수도 있을 것 같네요.\n\n어쨌든 나중에 뵙겠습니다! 즐거운 시간 보내세요!\n","ogImage":{"url":"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png"},"coverImage":"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png","tag":["Tech"],"readingTime":11},{"title":"크로스 플랫폼 앱 개발 로드맵","description":"","date":"2024-05-23 13:17","slug":"2024-05-23-Cross-PlatformAppDevelopmentRoadmap","content":"\n오늘날의 디지털 시대에서 모바일 앱 개발은 고객과 소통하고 영향을 확대하려는 기업들에게 중요한 요소가 되었습니다.\n\n그러나 모바일 장치와 운영 체제의 다양성이 개발자들에게 어려움을 제공합니다. 이것이 크로스 플랫폼 앱 개발이 필요한 이유입니다.\n\n여기에는 크로스 플랫폼 앱 개발을 잘하기 위한 로드맵이 제시되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 크로스 플랫폼 앱 개발에서의 도전\n\n크로스 플랫폼 개발은 많은 이점을 제공하지만, 고유한 도전 과제들도 함께 따라옵니다.\n\n## 성능 문제\n\n가장 흔한 고민은 크로스 플랫폼 앱의 성능 문제입니다. 개발자들은 코드를 최적화하고 플랫폼별 최적화를 활용하여 원할한 성능을 보장해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 네이티브 기능 제한\n\n크로스 플랫폼 프레임워크는 특정 네이티브 기능 및 기능에 액세스하는 데 제한이 있을 수 있으며, 이로 인해 개발자는 해결책이나 대안적인 솔루션을 찾아야 할 수 있습니다.\n\n## 호환성 문제\n\n다양한 기기, 화면 크기 및 운영 체제 간의 호환성을 보장하는 것은 어려운 작업일 수 있습니다. 철저한 테스트와 최적화가 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 적절한 크로스 플랫폼 프레임워크 선택\n\n크로스 플랫폼 앱 개발 프로젝트의 성공을 위해 적절한 프레임워크 선택이 중요합니다.\n\n## 인기 프레임워크 개요\n\nReact Native, Xamarin, Flutter와 같은 프레임워크는 각각 독특한 기능과 능력을 제공하여 다양한 프로젝트 요구사항 및 개발자 선호도에 부합합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 크로스 플랫폼 모바일 앱 개발을 위해 고려해야 할 사항\n\n성능, 커뮤니티 지원, 학습 곡선 및 기존 기술과의 통합과 같은 고려 사항이 프레임워크 선택 프로세스에 영향을 미쳐야 합니다.\n\n## 준비 및 계획\n\n개발에 들어가기 전에 철저한 준비와 계획이 필요하며, 이는 프로젝트의 성공을 위해 필수적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 앱 요구 사항 정의\n\n앱의 기능, 기능 및 타겟 대상을 명확히 정의하여 개발 노력이 비즈니스 목표와 일치하도록합니다.\n\n## 타겟 대상 및 시장 조사\n\n사용자 선호도, 시장 동향 및 경쟁사를 이해하면 디자인 및 개발 결정에 영향을 미쳐 사용자 기대치를 충족시킬 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 프로젝트 일정 및 중요한 이벤트 설정\n\n명확한 일정과 이벤트 설정은 개발 프로세스를 추적하고 효율적인 프로젝트 관리를 가능하게 합니다.\n\n## 사용자 인터페이스 디자인\n\n잘 디자인된 사용자 인터페이스는 플랫폼 간에 원활한 사용자 경험을 제공하는 데 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 크로스 플랫폼 앱 개발에서 반응형 디자인의 중요성\n\n앱의 레이아웃과 기능을 다양한 화면 크기와 해상도에 맞게 조정하기 위해 반응형 디자인 원칙을 활용하세요.\n\n## 일관된 사용자 경험 생성\n\n모든 플랫폼에서 디자인 요소, 내비게이션 패턴, 브랜딩을 일관되게 유지하여 사용성과 브랜드 인지도를 향상시키세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 개발 단계\n\n기본 작업이 완료되었으므로, 개발자들은 이제 코드를 작성하고 앱을 구현할 수 있습니다.\n\n## 선택한 프레임워크를 사용하여 코드 작성\n\n선택한 프레임워크의 기능과 기능성을 활용하여 앱 로직, 사용자 인터페이스 요소 및 백엔드 통합을 구현하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 테스트 및 디버깅\n\n철저한 테스트는 버그를 식별하고 수정하여 앱이 다양한 기기와 플랫폼에서 의도한 대로 작동하도록 하는 데 중요합니다.\n\n## 반복적인 개발 프로세스\n\n반복적인 접근 방식을 채택하여 사용자 피드백을 통합하고 앱의 기능과 디자인을 점진적으로 개선하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 성능 최적화\n\n성능 최적화는 반응성 있고 효율적인 앱 경험을 제공하는 데 중요합니다.\n\n## 앱 성능 향상을 위한 기술\n\n코드 최적화, 캐싱 및 지연 로딩과 같은 전략을 구현하여 앱 반응성을 향상시키고 로딩 시간을 줄일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 일반적인 병목 현상 대응\n\n메모리 누수, 비효율적 알고리즘 및 과도한 리소스 사용과 같은 성능 병목 현상을 식별하고 대응하세요.\n\n## 네이티브 기능 통합\n\n원활한 사용자 경험을 제공하기 위해 개발자는 플랫폼별 기능과 기능을 앱에 통합해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 기기별 기능에 액세스하기\n\nGPS, 카메라 및 푸시 알림과 같은 기기 기능에 액세스하려면 플랫폼별 API 및 라이브러리를 활용하세요.\n\n## 플랫폼별 API 구현\n\n네이티브 능력을 활용하기 위해 필요한 곳에서 플랫폼별 코드를 구현하는 모듈식 접근 방식을 채택하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 크로스 플랫폼 앱 개발에서의 테스트 및 품질 보증\n\n품질 보증은 앱이 사용자의 기대를 충족하고 각 플랫폼에서 안정적으로 작동하는 것을 보장하는 데 매우 중요합니다.\n\n## 엄격한 테스트의 중요성\n\n자동화된 테스트 도구와 수동 테스트 기술을 활용하여 버그, 사용성 문제 및 성능 병목 현상을 식별하고 해결하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 사용자 인수 테스트\n\n베타 테스트와 포커스 그룹을 통해 실제 사용자로부터 피드백을 수집하여 개선할 부분을 식별하고 앱의 기능 및 디자인을 개선하세요.\n\n# 배포 전략\n\n개발이 완료되면 앱을 출시 및 배포할 준비가 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 앱 스토어 제출 프로세스\n\n애플 앱 스토어 및 구글 플레이 스토어와 같은 앱 스토어의 지침과 요구 사항을 따라 앱을 검토 및 승인을 위해 제출하세요.\n\n## 베타 테스트 및 피드백 수집\n\n공식 런칭 전에 초기 사용자로부터 피드백을 수집하고 남은 문제를 해결하기 위해 앱의 베타 버전을 출시하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 지속적 통합 및 배포\n\n빌드, 테스트 및 배포 프로세스를 자동화하는 지속적 통합 및 배포 파이프라인을 구현하여 업데이트 및 패치를 효율적으로 제공합니다.\n\n# 개발 후 지원 및 유지보수\n\n앱 출시로 끝나는 것이 아닙니다. 지속적인 지원 및 유지보수는 장기적인 성공에 필수적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 업데이트 및 패치 관리\n\n새로운 기능, 버그 수정 및 보안 패치를 포함하여 앱을 정기적으로 업데이트하여 사용자들을 즐겁게 유지하고 보호하세요.\n\n## 앱 성능 모니터링\n\n애널리틱스 도구 및 모니터링 플랫폼을 활용하여 앱 성능, 사용자 참여 및 피드백을 추적하여 데이터 기반의 의사 결정을 할 수 있도록하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 사용자 피드백 대응\n\n사용자 피드백을 듣고 사용자의 요구사항과 선호도에 따라 기능 요청과 버그 수정을 우선순위에 따라 설정하여 충성스러운 사용자 커뮤니티를 육성합니다.\n\n# 성공적인 크로스 플랫폼 앱 예시\n\n실제 사례를 통해 크로스 플랫폼 앱 개발이 비즈니스 목표를 달성하고 탁월한 사용자 경험을 제공하는 데 얼마나 효과적인지를 강조합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인기 있는 크로스 플랫폼 앱인 Airbnb, Instagram 및 Uber의 사례 연구를 살펴보면, 그들의 독특한 기능과 개발 과제를 보여줍니다.\n\n# 실제 프로젝트에서 얻은 교훈\n\n크로스 플랫폼 앱 개발을 채택한 개발자 및 기업의 경험에서 통찰을 얻어, 그들의 성공과 실패로부터 배우세요.\n\n# 크로스 플랫폼 앱 개발의 혜택\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 비용 효율성\n\n여러 플랫폼을 위한 단일 코드베이스를 활용하면 개발 비용을 크게 줄일 수 있고 시장 진입 시간을 단축할 수 있습니다.\n\n## 빠른 개발 시간\n\n크로스 플랫폼 프레임워크는 개발 프로세스를 간소화하는 도구와 라이브러리를 제공하여 개발자가 앱을 효율적으로 구축하고 배포할 수 있도록 도와줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 더 넓은 관객층 도달\n\n크로스 플랫폼 접근 방식을 통해 앱은 다양한 기기와 운영 체제에서 보다 넓은 관객층에게 도달할 수 있으며, 잠재적 사용자 베이스를 극대화할 수 있습니다.\n\n# 크로스 플랫폼 앱 개발의 미래 트렌드\n\n기술이 발전함에 따라, 새로운 트렌드와 혁신이 크로스 플랫폼 앱 개발의 미래를 선도하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 부상 중인 기술 및 프레임워크\n\n증강 현실, 머신 러닝, 블록체인과 같은 부상 중인 기술들에 대해 알아두세요. 교차 플랫폼 개발에 대한 그들의 영향도를 고려해보세요.\n\n## 교차 플랫폼 개발의 미래에 대한 예측\n\n전문가들은 도구, 프레임워크, 개발자 생태계의 발전을 주도로 하여 교차 플랫폼 개발 분야에서 지속적인 성장과 혁신이 예측됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱 경험을 다양한 플랫폼에서 향상시키기 준비가 되셨나요? Ropstam Solutions에 연락하여 전문적인 크로스 플랫폼 개발을 경험해보세요. Ropstam의 크로스 플랫폼 개발자들은 iOS, Android 및 기타 플랫폼에서 여러분의 비전을 원활하게 통합합니다. 함께 협력하여 차세대 앱을 만들어보세요! 지금 Ropstam에 연락해보세요.\n\n# 결론\n\n크로스 플랫폼 앱 개발은 여러 플랫폼에서 일관된 사용자 경험을 제공하며 넓은 관중에 접근할 수 있는 비용 효율적이고 효과적인 솔루션을 제공합니다.\n\n계획 수립, 디자인, 개발, 테스트 및 유지보수를 포함한 전략적인 로드맵을 따르면, 개발자들은 사용자와 기업 모두의 요구를 충족시키는 성공적인 크로스 플랫폼 앱을 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 자주 묻는 질문들\n\n## 크로스 플랫폼과 네이티브 앱 개발의 차이점은 무엇인가요?\n\n크로스 플랫폼 개발은 코드를 한 번 작성한 후 여러 플랫폼에 배포하는 것을 의미하며, 네이티브 개발은 각 플랫폼별로 별도의 코드베이스를 생성하는 것을 의미합니다.\n\n## 제 프로젝트에 가장 적합한 크로스 플랫폼 프레임워크는 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제일 좋은 프레임워크는 프로젝트 요구사항, 개발자 전문 지식 및 성능 목표 등과 같은 요소에 따라 다릅니다. 결정을 내리기 전에는 각 프레임워크의 기능과 제한 사항을 평가하는 것이 중요합니다.\n\n## 모든 기기에서 교차 플랫폼 앱이 잘 작동되도록 어떻게 할 수 있을까요?\n\n코드 최적화, 캐싱 및 기기별 테스트와 같은 성능 최적화 기술을 활용하면 다양한 기기와 플랫폼에서 앱이 잘 작동하는 것을 보장할 수 있습니다.\n\n## 교차 플랫폼 앱 개발에서 피해야 할 일반적인 함정은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적인 함정으로는 플랫폼별 기능을 무시하거나 성능 고려를 과소평가하는 것, 그리고 사용자 경험과 디자인 일관성을 우선시하지 않는 것이 있습니다.\n\n## 모든 종류의 앱에 크로스 플랫폼 앱 개발이 적합한가요?\n\n크로스 플랫폼 개발은 많은 종류의 앱에 적합하지만, 특정 플랫폼 기능과 깊은 통합이 필요한 고도로 특화되거나 자원 집약적인 애플리케이션에는 최선의 선택이 아닐 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-Cross-PlatformAppDevelopmentRoadmap_0.png"},"coverImage":"/assets/img/2024-05-23-Cross-PlatformAppDevelopmentRoadmap_0.png","tag":["Tech"],"readingTime":13},{"title":"2023년 혁신적인 수익화 전략으로 2억 6천만 달러를 벌어낸 화이트아웃 서바이벌의 성공 비결을 알아보세요","description":"","date":"2024-05-23 13:16","slug":"2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics","content":"\n![LearnHowWhiteoutSurvivalEarned260Millionin2023](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_0.png)\n\n저희 게임 모네타이제이션 리뷰 시리즈 두 번째 에티션이에 오신걸 환영합니다. 만약 ‘Idle Civilization’에 대한 첫 번째 기사를 놓치셨다면 여기서 확인해보세요 - 멋지고 독특한 통찰이 기다리고 있답니다.\n\n새로운 게임을 탐험하는 걸 좋아하는데, ‘Century Games’의 ‘Whiteout Survival’을 발견해서 정말 흥미로웠어요. 이 게임은 얼어붙은 세계에서 생존하는 것뿐만 아니라 지역사회를 구축하고 어려운 선택을 하는 것까지 관련돼 있거든요. 2022년 12월 2일에 출시된 ‘Whiteout Survival’은 엄청난 얼어붙음으로 모든 것이 변화한 세계에 당신을 던져넣어요. 플레이어들은 지구상의 마지막 도시를 이끌며 심한 추위, 위험한 동물, 그리고 다른 위협으로부터 싸워야 해요. 전략과 생존의 조합으로, 이 게임은 거대한 히트를 치며 2023년 현재까지 2억 6천만 달러의 수익을 올렸어요.\n\n‘Whiteout Survival’이 강조하는 점 중 하나는 게임 내 구매 방식이에요. 무료로 플레이할 수 있지만, 게임은 실제 돈을 쓰는 똑똑한 방법을 제공하며 그 비용을 지불한 만큼 더해진 재미를 느낄 수 있어요. 이 기사에서는 ‘Whiteout Survival’이 이 영역에서 뛰어난 네 가지 방법에 대해 살펴보겠어요. 이 전략들은 게임을 위해 돈을 벌이는 것뿐만 아니라 플레이어들의 즐거움을 크게 높여주고 있답니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 빌더를 강화하세요: 추가 빌더 제안\n\n많은 전략 게임과 마찬가지로 'Whiteout Survival'은 건물을 업그레이드할 수 있는 빌더 한 명으로 시작합니다. 즉, 다음 업그레이드를 시작하기 전에 하나의 업그레이드가 끝날 때까지 기다려야 합니다. 여기에 재미있는 점이 있습니다. 게임은 무료 15분 평가판으로 두 번째 빌더를 선물해줍니다. 바로 시작부터 추가적인 도움의 가치를 보여주는 것입니다. 평가판이 끝나면 두 가지 선택이 있습니다. 다이아몬드로 2일 동안 빌더를 고용하거나 현금으로 그들의 서비스를 영구적으로 확보할 수 있습니다. Century Games는 빠른 진행의 가치를 시연하기 위한 똑똑한 전략을 고안했습니다. 플레이어들에게 그 속도를 유지하기 위한 유연한 구매 옵션을 제공합니다.\n\n![이미지](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_1.png)\n\n# 다중 배틀 패스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'화이트아웃 서바이벌'은 다양한 배틀 패스를 제공하여 승부의 건을 높이고 있습니다. 이러한 패스들은 영웅을 모으거나 얼음 요새를 강화하는 등 다양한 게임 측면에 맞춰 제작되었습니다. 플레이어들은 현재 상황에 가장 적합한 배틀 패스를 선택할 수 있습니다. 센추리 게임즈는 다양한 배틀 패스를 제공함으로써 플레이어의 다양한 관심사를 고려하여 참여를 촉진하고 선호 콘텐츠를 통해 구매 가능성을 높이고 있습니다. 이 방법은 게임플레이에 층을 더하며 플레이어가 게임 내 진행상황과 보상을 맞춤 설정할 수 있는 자유를 부여합니다.\n\n![이미지](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_2.png)\n\n## 맞춤형 상자 제공\n\n'화이트아웃 서바이벌'은 \"맞춤형 상자 제공\"이라는 독특한 기능을 통해 게임 내 상점에 새로운 변화를 더했습니다. 이 기능을 통해 상자를 채우는 보상을 직접 선택할 수 있습니다. 각각의 다양한 가격대의 상자에서는 미리 정해진 항목들과 해당 세트를 완성하기 위해 추가 보상을 선택할 수 있는 옵션이 포함되어 있습니다. 이 맞춤형 기능을 통해 바로 필요한 속도 향상 또는 경험치 상승과 같은 게임 요구에 맞게 구매를 맞춤 설정할 수 있습니다. 이러한 맞춤형을 가능케 함으로써 게임은 플레이어들이 제어를 선호하는 경향을 파악하여 직접 구성한 번들에 투자할 가능성을 높이고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_3.png)\n\n# VIP 진행: 구매로 쉬운 레벨 업\n\n'Whiteout Survival'에서 VIP 랭크를 올라가면 새로운 기능과 보너스가 해제됩니다. 레벨 1부터 시작하여 다음 레벨로 진행하기 위해 포인트를 모으면 더 좋은 보상을 받을 수 있습니다. 게임은 VIP 사다리를 빠르게 오르는 경로를 제공합니다: 다이아몬드를 사용하거나 VIP 포인트가 포함된 팩을 구입하세요. 랭크를 빨리 오르고 싶은 사람들에게는 이러한 옵션이 더 많은 게임 내 혜택으로 가는 지름길을 제공합니다.\n\n![이미지](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n'Whiteout Survival'은 얼어붙은 아포칼립스에서 생존 기술뿐만 아니라 모험에 매끄럽게 통합되는 다양한 전략적 화폐화 옵션을 제공하여 여러분의 능력을 시험합니다. 새로운 VIP 레벨 도달, 맞춤형 상자 생성 및 배틀 패스 잠금 해제는 만족스러운 경험을 안겨줍니다. 이러한 통찰을 감상하고 게임 화폐화 전술의 보다 심층적인 탐구를 기대한다면 뉴스레터 구독을 잊지 말아주세요. 정보를 입수하고 앞서가는 자세를 유지하며 함께 가상 세계의 가치를 발견해 나가요.\n","ogImage":{"url":"/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_0.png"},"coverImage":"/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_0.png","tag":["Tech"],"readingTime":4},{"title":"제이미니 API 사용 전에 읽어보세요","description":"","date":"2024-05-23 13:15","slug":"2024-05-23-ReadthisBeforeUsingGeminiAPI","content":"\n## Gemini API를 최대한 활용할 수 있도록 도와주는 개발자 안내서\n\n안녕하세요 👋🏻\n\n앱에 Gemini API를 사용하고 싶으신가요? Gemini AI 매개변수를 효과적으로 활용하는 방법은 무엇인가요? Gemini AI를 사용할 때 주의해야 할 점은 무엇일까요?\n\n![이미지](/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGemini AI를 처음 사용하시는 분이라면, 이는 텍스트, 이미지 및 오디오 등 다양한 유형의 데이터 입력에서 콘텐츠를 생성할 수 있는 모델로 정의되는 생성적 AI입니다.\n\n## Gemini API를 사용해야 하는 이유\n\n아마도 몇몇 분들은 \"Gemini 앱이 있는데, 왜 Gemini API를 사용해야 하죠?\" 라고 물을지도 모릅니다.\n\nGemini API는 AI 기반 응용 프로그램을 만들고 싶은 분들을 대상으로 하고 있습니다. 게다가 유료 버전에서는 귀하의 프롬프트 및 응답을 제품 개선에 사용하지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 토큰\n\n생성적 AI 모델은 텍스트 데이터를 처리하기 위해 토큰이라는 단위로 분해합니다. 토큰은 문자, 단어 또는 구(phrase)가 될 수 있습니다. 이는 Gemini가 어떻게 단어를 분해하는지에 따라 다릅니다.\n\n# Top-K, Top-P 및 Temperature\n\n## topK\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ntopK 매개변수는 모델이 출력 토큰을 선택하는 방식을 변경합니다. 간단히 말해, 가능한 출력 토큰을 K개로 제한합니다.\n\n예시:\n다음 단어를 완성해야 합니다:\nThe quick brown fox jumps over the …\n\n다음 단어의 확률:\n\n1. squirrel: 0.08\n2. sleeping rabbit: 0.3\n3. lazy dog: 0.9\n4. dog: 0.7\n\n예시에서...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 topK를 1로 설정하면 (탐욕 디코딩), 출력 결과는 가장 높은 확률을 가진 단어만 표시됩니다. 즉, \"게으른 개\"가 됩니다.\n\n만약 topK를 N(N ≥ 1)으로 설정하면, 출력 결과는 가장 높은 확률을 가진 N개의 단어 중 하나가 나오게 됩니다. 예를 들어, \"게으른 개\", \"개\", \"자는 토끼\"가 있을 때, 이 중에서도 topP에 따라 단어가 더 필터링되고, 최종 출력은 온도를 이용하여 선택됩니다.\n\n## topP\n\ntopP 매개변수, 또한 넉클리어 샘플링이라고 불리는 것은 모델이 출력 토큰을 선택하는 방식을 변경합니다. 간단히 말해, 출력 토큰의 확률 합이 topP 값과 동일하거나 그 이상인 경우까지만 토큰을 생성하는 방식입니다. topP 값은 0.0에서 1.0 사이의 범위로 설정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n다음 단어를 완성해야 합니다:\n수영은 매우…\n\n다음 단어의 확률:\n\n1. 인기 있는: 0.3\n2. 치유적인: 0.1\n3. 건강한: 0.4\n4. 어려운: 0.2\n\n이때 topP는 0.5로 설정합니다.\n\n가장 높은 확률을 가진 단어는 \"건강한\" (0.4)이지만, 임계 값을 충족하지 못하므로 두 번째로 높은 \"인기 있는\" (0.3)으로 이동합니다. 따라서 출력은 \"건강한\" (0.4)과 \"인기 있는\" (0.3)입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 온도\n\n온도는 topP 및 topK가 적용된 이후의 토큰 선택의 무작위성을 제어합니다. 또한 0.0에서 1.0 범위 내에서 온도 값을 설정할 수 있습니다. 우리는 여기서 식을 포함하지 않을 것입니다.\n\n알아두어야 할 것은 높은 온도와 낮은 온도를 언제 사용해야 하는지입니다.\n\n- 낮은 온도 (≤ 0.5)는 더 구체적이거나 덜 창의적인 출력이 필요할 때 적합합니다. 사용 사례 예시로는 요약, 질문 응답, 팩트-체킹, 번역 등이 있습니다.\n- 높은 온도 (≥ 0.5)는 더 창의적인 출력이 필요할 때 적합합니다. 사용 사례 예시로는 이야기 작성, 퀴즈 생성 등이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 가격 책정\n\n가격은 입력 및 출력 토큰에 따라 다르므로 비용을 최적화하기 위해 콘텐츠 생성 전에 입력 및 출력 토큰을 제한할 수 있습니다.\n\n다트(Dart)에서의 예시는 다음과 같습니다:\n\n```js\nFuture\u003cvoid\u003e main() async {\n  final GenerativeModel model = GenerativeModel(\n    model: 'gemini-1.5-pro-latest',\n    apiKey: 'YOUR_API_KEY',\n    generationConfig: GenerationConfig(\n      responseMimeType: 'application/json',\n      maxOutputTokens: 150,\n    ),\n  );\n\n  final token = await model.countTokens(\n    [Content.text('Hello World')],\n  );\n  print(token.totalTokens);\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# JSON 생성하기\n\n가끔 앱에서 JSON을 생성해야 할 때가 있습니다. 최신 Gemini 1.5 Pro에서는 이미 JSON 출력을 지원합니다.\n\nDart에서 GenerationConfig 내부에 responseMimeType: 'application/json' 속성을 추가할 수 있습니다.\n\nGemini 1.0 Pro를 사용하지 않는 경우에는 프롬프트할 때 출력을 지정할 수 있습니다. ' '예제': '문자열' ' 이런 JSON 구조로 ...를 생성해줘 라고 간단히 요청하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 다트(Dart)에서의 예시가 있어요:\n\n```dart\nvoid main() {\n  final jsonString = jsonEncode({'story': 'string'});\n  final content = await model.generateContent([\n    Content.text(\n      'Generate me a story with this JSON structure: $jsonString',\n    ),\n  ]);\n  print(content.text);\n}\n```\n\n# 시스템 지침\n\n시스템 지침은 사용자가 특정 요구 사항과 사용 사례에 따라 모델의 동작을 조정할 수 있도록 합니다. AI 역할, 언어 스타일 또는 출력을 지정할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다트 코드 예시를 보여드립니다:\n\n```dart\nvoid main() {\n  final GenerativeModel model = GenerativeModel(\n    model: 'gemini-1.5-pro-latest',\n    apiKey: 'YOUR_API_KEY',\n    systemInstruction: Content.system(\n      '''You are a horror story teller.\n      You will receive a title, then turn it into a short horror story\n      and respond it to the JSON object contains title and story''',\n    ),\n  );\n}\n```\n\n# 보안\n\n클라이언트 측에서 직접 Gemini API를 호출하는 것은 API 키 유출, 서비스 거부(DoS) 공격 등과 같은 위협에 노출될 수 있습니다. 클라이언트 측은 프로토타입에만 사용해야 합니다. 가장 안전한 방법은 서버 측에서 구현하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모두 끝났어요!\n\n아래에 댓글을 남기시고 망고가 Linkedin에서 우릴 이어도록 합시다!\n\n독해주셔서 감사합니다! 🐈\n","ogImage":{"url":"/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png"},"coverImage":"/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png","tag":["Tech"],"readingTime":7},{"title":"Swift에서의 고급 오류 처리 Try-Catch를 넘어서","description":"","date":"2024-05-23 13:13","slug":"2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch","content":"\n\u003cimg src=\"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png\" /\u003e\n\n소개\n\n오류 처리는 견고한 응용 프로그램 구축의 중요한 측면입니다. Swift의 try, catch, throw 및 do로 소개된 오류 처리 모델은 오류를 우아하게 처리하는 강력하고 유연한 메커니즘을 제공합니다. 그러나 응용 프로그램이 복잡해지면 오류를 효과적으로 관리하기 위해 더 고급 기술이 필요할 수 있습니다. 이 글에서는 Swift에서 고급 오류 처리 전략인 Result 타입, async/await 오류 전파, 사용자 정의 오류 타입, 견고한 오류 처리 시스템을 만드는 데 가장 좋은 방법 등을 탐색해 보겠습니다.\n\n왜 고급 오류 처리가 중요한가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본 try-catch를 사용한 기본적인 오류 처리는 많은 시나리오에 효과적이지만, 고급 기술은 다음과 같은 여러 가지 이점을 제공합니다:\n\n- 가독성 향상: 더 명확한 오류 처리 경로는 코드의 가독성과 유지보수성을 향상시킵니다.\n- 더 좋은 제어: 오류 전파 및 복구에 대한 더 많은 제어.\n- 디버깅 향상: 더 구체적인 오류 유형으로 문제를 진단하고 수정하기가 더 쉬워집니다.\n- 비동기 컨텍스트: 비동기 코드에서의 오류를 효과적으로 관리합니다.\n\n결과 유형 사용하기\n\n결과 유형은 성공 또는 실패를 나타내며, 값이나 오류를 캡슐화합니다. 오류 처리에 대해 더 함수형 접근 방식을 제공하며 비동기 작업에서 특히 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본 예제 및 결과\n\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed\n}\n\nfunc fetchData(from urlString: String) -\u003e Result\u003cData, NetworkError\u003e {\n    guard let url = URL(string: urlString) else {\n        return .failure(.invalidURL)\n    }\n\n    do {\n        let data = try Data(contentsOf: url)\n        return .success(data)\n    } catch {\n        return .failure(.requestFailed)\n    }\n}\n\nlet result = fetchData(from: \"https://example.com/data\")\n\nswitch result {\ncase .success(let data):\n    print(\"데이터 수신 성공: \\(data)\")\ncase .failure(let error):\n    print(\"데이터 가져오기 실패: \\(error)\")\n}\n```\n\n이 예제에서 fetchData 함수는 가져온 데이터 또는 오류를 캡슐화하는 Result 타입을 반환합니다.\n\nAsync/Await으로 에러 처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwift의 새로운 동시성 모델은 async/await를 도입하여 비동기 코드를 처리하기 쉬워졌어요. 이 문맥에서 오류를 처리하는 방법을 살펴봅시다.\n\nAsync/Await 예제\n\n```js\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed\n}\n\nfunc fetchData(from urlString: String) async throws -\u003e Data {\n    guard let url = URL(string: urlString) else {\n        throw NetworkError.invalidURL\n    }\n\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n\nfunc processData() async {\n    do {\n        let data = try await fetchData(from: \"https://example.com/data\")\n        print(\"Data fetched: \\(data)\")\n    } catch {\n        print(\"Failed to fetch data: \\(error)\")\n    }\n}\n\nTask {\n    await processData()\n}\n```\n\n이 예제에서 fetchData 함수는 비동기이며 오류를 던질 수 있습니다. 이 오류는 processData 함수 내에서 try-catch를 사용하여 처리됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자 정의 오류 유형 만들기\n\n사용자 정의 오류 유형은 오류 처리를 더 정확하고 의미 있게 만들어줍니다.\n\n사용자 정의 오류 유형을 이용한 예제\n\n```js\nenum FileError: Error {\n    case fileNotFound\n    case unreadable\n    case encodingFailed\n}\n\nfunc readFile(named fileName: String) throws -\u003e String {\n    guard let filePath = Bundle.main.path(forResource: fileName, ofType: nil) else {\n        throw FileError.fileNotFound\n    }\n\n    guard let data = FileManager.default.contents(atPath: filePath) else {\n        throw FileError.unreadable\n    }\n\n    guard let content = String(data: data, encoding: .utf8) else {\n        throw FileError.encodingFailed\n    }\n\n    return content\n}\n\ndo {\n    let content = try readFile(named: \"example.txt\")\n    print(\"파일 내용: \\(content)\")\n} catch {\n    print(\"파일 읽기 실패: \\(error)\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에서 FileError는 파일 작업과 관련된 특정 오류를 정의합니다. readFile 함수는 이러한 오류 유형을 사용하여 상세한 오류 정보를 제공합니다.\n\n에러 처리를 위한 최상의 모법\n\n- 기술적인 오류 유형 사용: 오류에 대한 의미 있는 컨텍스트를 제공하는 사용자 정의 오류 유형을 정의하세요.\n\n```swift\nenum ValidationError: Error {\n    case invalidEmail\n    case passwordTooShort\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 적절한 수준으로 오류 전파하기: 오류를 효과적으로 처리할 수 있는 적절한 수준으로 전파하십시오.\n\n```js\nfunc performOperation() throws {\n    try validateInput()\n    try processData()\n}\n```\n\n3. 우아한 복구: 가능한 경우에는 오류로부터 복구할 수 있는 전략을 구현하여 실패하는 것이 아닌 대처하십시오.\n\n```js\nfunc fetchData() async {\n    do {\n        let data = try await fetchData(from: \"https://example.com\")\n        process(data)\n    } catch {\n        recoverFromError(error)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 중앙 집중식 오류 로깅: 디버깅을 간소화하기 위해 오류를 기록하는 데 중앙 집중식 방법을 사용하세요.\n\n```js\nfunc logError(_ error: Error) {\n    // 모니터링 서비스나 콘솔에 오류 기록\n    print(\"오류: \\(error)\")\n}\n```\n\n5. 사용자 친화적인 오류 메시지: 사용자에게 명확하고 실행 가능한 오류 메시지를 제공하세요.\n\n```js\nfunc displayError(_ error: Error) {\n    let message: String\n    switch error {\n    case is NetworkError:\n        message = \"네트워크 오류가 발생했습니다. 나중에 다시 시도해 주세요.\"\n    default:\n        message = \"예기치 못한 오류가 발생했습니다.\"\n    }\n    showAlert(with: message)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결론\n\nSwift에서의 고급 오류 처리는 기본적인 try-catch 블록을 넘어서 Result 타입, async/await, 그리고 사용자 정의 오류 타입과 같은 강력한 기능을 활용합니다. 이러한 고급 기술을 채택함으로써 더 견고하고 가독성이 높고 유지보수가 용이한 코드를 작성할 수 있습니다. 효과적인 오류 처리는 응용 프로그램이 오류를 우아하게 처리하여 개발자와 사용자 모두에게 더 나은 경험을 제공할 수 있도록 합니다. 이러한 전략을 받아들여 Swift 개발 기술을 향상시키고 더 견고한 응용 프로그램을 구축하세요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png"},"coverImage":"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png","tag":["Tech"],"readingTime":7}],"page":"65","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"65"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>