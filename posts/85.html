<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/85" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/85" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Git-활성화된 패브릭 워크스페이스 사용을 위한 최상의 실천법" href="/post/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Git-활성화된 패브릭 워크스페이스 사용을 위한 최상의 실천법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Git-활성화된 패브릭 워크스페이스 사용을 위한 최상의 실천법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Git-활성화된 패브릭 워크스페이스 사용을 위한 최상의 실천법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="실시간 데이터 파이프라인 구축하기" href="/post/2024-05-20-BuildingaReal-TimeDataPipeline"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="실시간 데이터 파이프라인 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="실시간 데이터 파이프라인 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">실시간 데이터 파이프라인 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제목 Python, Jinja2 및 NiceGUI를 사용하여 독특한 Gemini AI-챗봇 만들기" href="/post/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제목 Python, Jinja2 및 NiceGUI를 사용하여 독특한 Gemini AI-챗봇 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제목 Python, Jinja2 및 NiceGUI를 사용하여 독특한 Gemini AI-챗봇 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">제목 Python, Jinja2 및 NiceGUI를 사용하여 독특한 Gemini AI-챗봇 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">29<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년에 데이터 엔지니어링 전문가가 되는 방법" href="/post/2024-05-20-HowIwouldbecomeaproindataengineeringin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년에 데이터 엔지니어링 전문가가 되는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-HowIwouldbecomeaproindataengineeringin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년에 데이터 엔지니어링 전문가가 되는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년에 데이터 엔지니어링 전문가가 되는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="탐색적 데이터 분석 런던 교통 수속에 잃어버린 물품" href="/post/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="탐색적 데이터 분석 런던 교통 수속에 잃어버린 물품" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="탐색적 데이터 분석 런던 교통 수속에 잃어버린 물품" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">탐색적 데이터 분석 런던 교통 수속에 잃어버린 물품</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬에서 데이터 시각화 기술과 코드 예제" href="/post/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬에서 데이터 시각화 기술과 코드 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬에서 데이터 시각화 기술과 코드 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">파이썬에서 데이터 시각화 기술과 코드 예제</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아름다운 지도를 만들기 위한 6가지 파이썬 라이브러리" href="/post/2024-05-20-6pythonlibrariestomakebeautifulmaps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아름다운 지도를 만들기 위한 6가지 파이썬 라이브러리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아름다운 지도를 만들기 위한 6가지 파이썬 라이브러리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">아름다운 지도를 만들기 위한 6가지 파이썬 라이브러리</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 패키지 Yellowbrick와 PiML으로 소중한 데이터와 모델 통찰력 발견하기 코드 포함" href="/post/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 패키지 Yellowbrick와 PiML으로 소중한 데이터와 모델 통찰력 발견하기 코드 포함" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 패키지 Yellowbrick와 PiML으로 소중한 데이터와 모델 통찰력 발견하기 코드 포함" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">파이썬 패키지 Yellowbrick와 PiML으로 소중한 데이터와 모델 통찰력 발견하기 코드 포함</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Streamlit Plotly 대시보드 데이터 시각화를 위한 확실한 방법" href="/post/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Streamlit Plotly 대시보드 데이터 시각화를 위한 확실한 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Streamlit Plotly 대시보드 데이터 시각화를 위한 확실한 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Streamlit Plotly 대시보드 데이터 시각화를 위한 확실한 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="참작자 시선으로 바라본 Vista의 진실" href="/post/2024-05-20-WhatReallyHappenedwithVistaAnInsidersRetrospective"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="참작자 시선으로 바라본 Vista의 진실" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-WhatReallyHappenedwithVistaAnInsidersRetrospective_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="참작자 시선으로 바라본 Vista의 진실" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">참작자 시선으로 바라본 Vista의 진실</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link posts_-active__YVJEi" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Git-활성화된 패브릭 워크스페이스 사용을 위한 최상의 실천법","description":"","date":"2024-05-20 18:48","slug":"2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces","content":"\n효율적으로 데이터 파이프라인을 관리하는 것은 원활한 개발, 테스트 및 배포 프로세스를 보장하기 위한 중요한 요소입니다. Microsoft Fabric 작업 공간과 Git을 통합하면 이러한 파이프라인을 효과적으로 관리할 수 있습니다. 데이터 아키텍트 및 엔지니어로 전환하기 전에 다양한 소프트웨어 프로젝트에서 CI/CD를 활용하는 데 중점을 둔 소프트웨어 엔지니어였습니다. 이 게시물은 Git을 활용한 Fabric 작업 공간의 최선의 실천 방법을 이해하기 위해 그림을 활용한 나의 해석에 대해 다룹니다.\n\n![Diagram](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_0.png)\n\n이 그림은 Azure DevOps와 Microsoft Fabric 간의 통합을 개발 환경에서 제품 환경까지의 흐름을 보여줍니다.\n\n## Azure DevOps (Git)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n• Main Branch: 안정적인 릴리스를 위한 메인 브랜치입니다.\n\n• Develop Branch: 지속적인 개발을 위한 주요 브랜치입니다.\n\n• Feature Branches: 특정 기능 개발을 위한 브랜치입니다.\n\n## Microsoft Fabric (Workspaces)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 릴리스 파이프라인: 다양한 환경(개발, 스테이징, 프로덕션)으로의 릴리스를 관리합니다.\n- 개발 작업 공간: 개별 개발자 환경.\n\n# 최상의 실천 방법\n\n이것들은 대규모 또는 복잡한 Microsoft Fabric 프로젝트를 유지하는 데 도움이 되는 주요 배운 점입니다.\n\n## 브랜칭 전략\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이프라인, 노트북, 리포트, 데이터 웨어하우스, 레이크하우스 등을 작업할 수 있는 Fabric \"개발자\"들이 git을 배워야 합니다. 나는 많은 데이터 엔지니어가 분석가나 DBA 경로에서 왔다는 것을 경험상 알기에, git을 배우는 것이 어려울 수 있다는 걸 알고 있어요. 이들의 경력 초창기에 git을 배우지 않은 경우가 많았습니다. 그러나 특히 Microsoft Fabric에서 큰 프로젝트를 수행하는 경우에는 협업을 위해 git이 필수적입니다.\n\n기능 브랜치: 각 개발자는 자신의 기능이나 버그 수정을 위해 개발 브랜치의 브랜치를 만듭니다. Fabric을 네이티브로 사용하는 경우, \"MJ의 프로젝트 A 작업 공간\"과 같이 개인 작업 공간에 이를 연결할 수 있습니다. 작성 시점 기준으로 \"내 작업 공간\"을 Git으로 활성화할 수는 없으므로, 이를 위해 새로운 작업 공간을 할당해야 합니다. Power BI 리포트와 같은 경우 개발자가 Power BI 데스크톱을 사용하는 경우, 이 접근법 또한 작동하며 Fabric 작업 공간에 독립적입니다.\n\n개발 브랜치: 새로운 기능을 통합하고 본 브랜치로 병합하기 전에 테스트하는 데에 이 브랜치를 사용하세요. 개발자가 실수로 이 브랜치에 푸시하거나 풀 리퀘스트 없이 수정하지 못하도록 브랜치 정책을 구현해야 합니다. 이 프로세스는 다른 개발자의 작업을 배포하기 전에 누군가가 검토해야 한다는 것을 강제합니다.\n\n본 브랜치: 이 브랜치를 제품용 코드의 진리의 원천으로 유지하세요. 여기에는 안정적이고 테스트된 코드만 병합해야 합니다. 나중에 변경 내용을 롤백해야 하는 경우를 대비해 나중을 위해 충분한 태깅 전략을 사용하세요. 보너스로, 메인 브랜치에 유지된 히스토리가 두 가지다 하더라도 릴리스#1과 릴리스#75를 분리하는 릴리스 태그를 구현하는 것도 좋은 연습입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메인 브랜치가 패브릭 워크스페이스에서 git을 사용할 수 없는 것에 유의해주세요. 워크스페이스에 연결된 브랜치는 개발 브랜치 뿐입니다. 다음 섹션에서 이에 대해 더 설명하겠습니다.\n\n## 패브릭 Git 통합\n\nMicrosoft 패브릭 워크스페이스(파워 BI 워크스페이스 포함)는 git 통합을 지원합니다. 현재는 Azure DevOps만 지원하고 있으며, GitHub 통합을 기다리고 있습니다.\n\n이를 위해 워크스페이스 설정을 클릭하고 \"Git 통합\" 탭으로 이동하세요. 이를 Azure DevOps에 연결하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image1](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_1.png)\n\n통합을 위해 git 폴더를 추가하는 것을 추천하지 않습니다. Fabric는 분석을 위해 통합된 프로젝트로 표현되어야 합니다. 이는 응용 프로그램 소스 코드, 데이터베이스 스크립트 등을 저장소에 추가할 계획인 경우 복잡해지기 때문입니다. 이는 지원되지만, 개발자들이 Azure DevOps와 Fabric git 간에 컨텍스트 전환이 필요할 때 혼란스러울 수 있습니다.\n\n즉, 모든 이러한 파일들:\n\n![image2](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 Azure DevOps 저장소에서 테이블 태그가 표시됩니다:\n\n![2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_3.png](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_3.png)\n\n## 작업 공간 관리\n\n![2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_4.png](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미 이전에 언급한대로, 개발자들은 기능 브랜치를 워크스페이스에 연결합니다. 이 방식의 단점 또는 \"불편함\"은 개발자들이 새로운 기능을 개발할 때 이 프로세스를 반복해야 한다는 점입니다. 미래에는 \"원 클릭 워크스페이스 생성\" 기능이 있으면 더 원할텐데, 이 기능은 일시적인 워크스페이스를 의도한 것입니다. 그러나 반대로, 보통 기능 개발에는 몇 일이 걸리기 때문에 매주 한두 번 이 프로세스를 수행해야 한다는 것은 익숙해지면 나쁘지 않습니다.\n\n![이미지](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_5.png)\n\n기능 브랜치에서의 풀 리퀘스트가 개발 브랜치로 병합되면, Fabric에서 개발 워크스페이스로 동기화됩니다. 이 워크스페이스는 여러 개발자들 사이에서 \"놀이터\"로 공유됩니다. 여기서 개발자들은 여기서 실험하고 실수를 할 수 있으며, 엔드 투 엔드 파이프라인과 보고서가 어떻게 나타나는지 확인할 수 있습니다. 대부분의 경우, 이 워크스페이스는 개발자가 액세스 권한을 갖고 있는 데이터 소스에도 연결됩니다.\n\n여기서 Git과 릴리스 관리 간의 분리선이 깨지게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 릴리스 관리\n\n![이미지](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_6.png)\n\n가장 먼저 눈에 띄는 것은 스테이징과 프로덕션 워크스페이스가 Git에 연결되어 있지 않다는 점입니다. 이 접근 방식을 선택한 이유에는 여러 가지 이유가 있습니다.\n\n- 개발과 배포의 역할과 책임을 분리하기 위함입니다. 2~3명의 개발자로 구성된 팀에서는 큰 문제가 아니지만 대규모 팀에서는 더 나은 접근 방식일 수 있습니다. 모든 사람이 누가 어떤 플랫폼 및 기능에 액세스 권한이 있는지 잘 알 수 있기 때문에 관리자들이 특정 정책 및 액세스를 관리하는 데 도움이 됩니다.\n- \"비개발자\"는 Git을 사용할 필요가 없습니다. 대규모 조직에서는 이해관계자 및 임원과 같은 다른 역할이 Git을 사용할 필요가 없을 수 있습니다. 그러나 반대로 보고서를 보고 권한을 행사하고 싶어할 것입니다. 이 접근 방식은 이러한 시나리오에서 잘 작동합니다.\n- 승인 시나리오. 스테이징 및 프로덕션으로의 릴리스 승인을 위해 누군가가 Git을 통해 확인할 필요가 없습니다. 대규모 조직에서는 적절한 릴리스 프로세스가 있지만 이 방식의 장점은 사실 \"매니저\"나 승인자가 개발자가 브랜치를 병합하는 대신 버튼을 클릭할 수 있다는 것입니다. 감사 추적은 관리자 X가 배포를 승인했음을 말할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_7.png\" /\u003e\n\n## 요약 및 도전 과제\n\n어떤 방식이든 의견이 갈리는 점이 있고, 이는 제가 다룬 대규모 Fabric 구현에 적합한 방식입니다. 이 방법이 가장 적합하지 않은 시나리오도 있습니다:\n\n- 소규모 팀 (모든 작업을 하는 2명의 개발자)\n- 멀티테넌시, 즉 스테이징과 프로덕션에 서로 다른 도메인이 있는 경우 (Entra ID). 이는 더 복잡한 기업 내 관계에도 적용됩니다.\n- Azure DevOps에 액세스할 수 없는 경우 (당연히)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요약하면, 이 방법은 팀으로 작업하고 협업하는 데 도움이 되기 위해 Microsoft fabric 작업 공간에 Git를 활용하는 접근 방식입니다. 주요 강조점은 다음과 같습니다:\n\n- 각 개발자는 자체 기능 브랜치와 Fabric 작업 공간에서 작업해야 합니다.\n- 개발 브랜치를 사용하여 기능 브랜치를 병합하고 동료 검토를 촉진합니다. 그런 다음 개발 브랜치를 Fabric의 개발 작업 공간에 동기화합니다.\n- Fabric 배포 파이프라인에서 배포를 수행하며 Git의 범위를 벗어납니다. 그러나 어떤 프로덕션 릴리스든 버전 관리 목적을 위해 메인 브랜치에도 태깅 및 표시되도록 해야 합니다.\n\n이 다이어그램의 더 간단한 버전도 있습니다. 여기에는 메인 브랜치만 사용합니다. 이는 좋은 시작점이 될 수도 있습니다.\n\n![다이어그램](/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법에 대해 어떻게 생각하시나요? 놓친 부분이 있나요? 더 좋은 대안이 있다고 생각하시나요? 댓글로 알려주세요.\n","ogImage":{"url":"/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_0.png"},"coverImage":"/assets/img/2024-05-20-BestPracticesforUsingGit-EnabledFabricWorkspaces_0.png","tag":["Tech"],"readingTime":8},{"title":"실시간 데이터 파이프라인 구축하기","description":"","date":"2024-05-20 18:45","slug":"2024-05-20-BuildingaReal-TimeDataPipeline","content":"\n## 카프카(Kafka), 폴라스(Polars), 델타 레이크(Delta Lake)를 활용한 실시간 분석\n\n데이터 엔지니어라면 언젠가는 실시간 데이터에 대한 비즈니스 요구사항을 직면해야 할 것입니다. 이는 빨리 오겠다는 것이 확실합니다. 실시간 데이터 처리는 기업이 신속하게 정보 기반 결정을 내릴 수 있도록 필수적으로 중요해지고 있으며, 아파치 카프카는 확장 가능하고 오류 허용성 있는 실시간 데이터 파이프라인을 구축하기 위한 인기 있는 플랫폼으로 부상했습니다.\n\n이 기사에서는 카프카, 폴라스, 델타 레이크를 사용하여 실시간 데이터 파이프라인을 만드는 방법을 실제로 보여드리겠습니다. 그리 어렵지 않습니다! 자신도 이를 시도할 수 있는 코드는 여기에서 확인하실 수 있습니다. 유용하다고 느끼신다면 ⭐️을 주세요.\n\n기술적인 기사가 될 예정이니, 코드 스니펫이 많이 포함될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 따라오기 시작하기 위해 설정해야 할 사항\n\n시작하기 위해 몇 가지 구성 요소를 설정해 두었습니다:\n\nKafka 브로커: Docker Compose를 사용하여 Kafka와 Zookeeper 컨테이너를 실행했습니다. docker-compose.yml 파일에는 필요한 서비스와 구성이 정의되어 있습니다. 이에 대해 자세히 다루지는 않겠습니다. 이 파일은 어디에서든 다운로드할 수 있는 기본적인 docker-compose.yml입니다. 데이터 엔지니어링 팀이 Kafka 환경을 관리하는 것으로 간주하지 않겠습니다. 당신이 담당하고 있는 플랫폼 또는 데브옵스 팀이 그 역할을 맡고 있을 것이라고 가정하겠습니다.\n\n발행자: Python 스크립트인 publisher.py를 만들었습니다. 이 스크립트는 일련의 csv 파일에 저장된 샘플 데이터를 Kafka 주제에 발행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구독자님: 새로운 Python 스크립트인 subscriber.py를 만들었어요. 이 스크립트는 Kafka 토픽에서 메시지를 가져와 Polars를 사용하여 Delta 테이블에 쓰는 역할을 해요.\n\n질문: 추가적으로 한 가지 더, query.py라는 마지막 Python 스크립트를 만들었어요. 이 스크립트는 Delta 테이블에 포함된 데이터를 가져와 조인하고, 조인된 데이터를 포함한 데이터프레임을 화면에 출력합니다.\n\n매개변수: Python 스크립트 내에 설정 매개변수를 저장하는 대신 toml 파일을 사용했어요. 이렇게 하면 매개변수를 변경하고 싶어도 코드를 손대지 않아도 돼요.\n\n# 단순히 실행만 하려면\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원하는 부분으로 건너뛰고 싶으세요? 알겠어요! 여기 실행하는 순서입니다:\n\n먼저 Kafka 브로커를 실행하려면 Docker가 설치되어 있어야 합니다. 메인 폴더 내에서 docker-compose up을 실행할 수 있어요. 먼저 몇 가지 파일을 다운로드해야 하며, 그 후에 프로세스들이 시작되면 화면에 많은 텍스트가 표시될 거예요:\n\n![이미지](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png)\n\n그 다음으로, publisher용 새 터미널 세션을 열고, subscriber용 또 다른 터미널 세션을 열어 보세요. Docker 컨테이너를 설정하지는 않았지만, 이들을 독립적인 Docker 컨테이너로 설정할 방법에 대해 알아보고 싶다면 이 기사를 확인해 보세요. 대신, 새로운 가상 Python 환경을 만들어서 그 안에 설치할 걸 권장드려요. python3 -m venv venv로 가상 환경을 생성한 다음 venv/bin/activate를 입력하여 새로운 가상 환경으로 전환하고, requirements.txt에 정의된 필수 패키지를 pip install -r로 설치하시면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 준비가 완료되었습니다. 먼저 터미널 창에서 subscriber.py를 실행한 후, 준비가 되면 publisher.py를 실행하세요. publisher에서 전송된 마이크로 배치를 볼 수 있으며, 동시에 subscriber가 실시간으로 수신하는 것을 볼 수 있을 겁니다. 그러나 subscriber와 publisher를 올바른 순서로 로드해야 합니다. subscriber가 준비되기 전에 publisher가 모두 보내버리는 일이 없도록 주의하세요. 이 경량 데모에서는 보관 기간을 설정하지 않았으니 주의해주세요.\n\n아래 스크린샷을 보면, 왼쪽에 publisher가 있고 오른쪽에 subscriber가 있는 분할 된 터미널이 있습니다. 왼쪽에서 전송되는 일괄처리된 데이터를 보고, 오른쪽에서는 개별 레코드가 처리되는 것을 볼 수 있습니다.\n\n![Publisher 및 Subscriber 스크린샷](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_1.png)\n\n모든 레코드가 전송된 후에는 publisher가 연결을 종료할 것입니다. subscriber는 프로세스가 종료될 때까지 계속 수신 대기 상태에 머무를 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막 단계는 query.py 파일을 실행하여 다른 화면을 로드하고 쿼리 결과를 확인하는 것입니다. 화면에 DataFrame이 출력되는데, 이겇이 우리의 작업 결과입니다. 이러한 csv 파일 각각이 Kafka를 통해 Delta 테이블로 이동되었으며, 이제 올바른 데이터 유형과 필드 이름을 가진 단일 DataFrame으로 변환되었습니다. 필요하다면, 발행물을 시작하는 동시에 실행할 수 있으며, 여러 번 실행하면 데이터가 흐르는 것을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_2.png)\n\n여기까지입니다! 몇 개의 csv 파일을 Kafka를 통해 마이크로 배치로 로드한 다음 이를 Delta 테이블로 다운스트림으로 스트리밍했습니다. 그 후 데이터를 쿼리하고 변환하여 직원, 부서, 고객, 판매 일자, 판매 지역 및 판매 금액을 모두 포함한 단일 DataFrame으로 통합했습니다.\n\n만약 궁금하시다면, 각 테이블의 기본 키를 기반으로 파일을 로드하기 위해 병합 프로세스를 사용했습니다. 그래서 데이터를 변경하고 다시로드하면 Delta 테이블에서 데이터를 우아하게 업데이트할 수 있습니다. 아래에서 csv에서 Finance 부서 레코드를 FinTech로 변경하고 두 번째로 실행했더니 어떻게 변경되는지 확인해보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_3.png)\n\n계속 읽어 보면 어떻게 작동하는지 알 수 있어요...\n\n# 발행자\n\n발행자 스크립트는 데이터를 Kafka로 보내는 데 사용됩니다. 전체 파일은 여기에서 찾을 수 있어요. 일부 구성을 설정한 후, 파일을 시작하는 지점인 아래쪽에서 여정을 시작해요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nif __name__ == \"__main()\":\n    producer = create_producer(bootstrap_servers)\n\n    try:\n        process_files_and_send(producer, topics, batch_size)\n    finally:\n        producer.close()\n```\n\n카프카 프로듀서를 producer로 인스턴스화하고 서버 세부 정보를 전달했습니다. 그런 다음 파일을 처리하려고 시도하고 완료되면 연결을 닫습니다. 간단하죠! 이제 파일의 맨 위로 돌아가서 각 함수를 하나씩 작업할 수 있습니다.\n\n## create_producer\n\n```js\ndef create_producer(bootstrap_servers):\n    return KafkaProducer(\n        bootstrap_servers=bootstrap_servers,\n        value_serializer=lambda v: json.dumps(v).encode(\"utf-8\")\n    )\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에는 그다지 많은 내용이 없어요. 저는 단순히 KafkaProducer를 함수로 래핑하여 제 개인적인 것으로 만들었어요. 서버 세부 정보를 전달하고, 매개변수인 v를 취하고 해당 매개변수로 전달된 내용을 JSON으로 변환하는 람다 함수를 사용했어요. 그 JSON은 UTF-8로 인코딩되어요. 많은 데이터 처리 함수가 문자열 대신 바이트 형식의 데이터를 예상하기 때문에 이것은 필수적입니다.\n\n## send_messages\n\n```js\ndef send_messages(producer, topic, messages):\n    try:\n        for message in messages:\n            producer.send(topic, value=message)\n        producer.flush()\n        logging.info(f\"Batch of messages sent to topic '{topic}'.\")\n    except Exception as e:\n        logging.error(f\"Failed to send messages to topic '{topic}'. Error: {e}\")\n```\n\n저는 아직 클래스를 사용하지 않았기 때문에 다음에 이것을 설정하고 있어요. 실제로 사용될 때 미리 로드되고 준비되어 있어야 해요. 여기서는 Kafka로 데이터를 전송하려고 노력해요. 각 메시지마다 Kafka Producer를 사용하고 메시지를 주제로 보내요. 그런 다음 보낸 것을 기록하거나 필요한 경우 발생한 오류를 기록해 내용이 잘못됐는지 조사할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## process_files_and_send\n\n```js\ndef process_files_and_send(producer, topics, batch_size):\n    for topic in topics:\n        try:\n            with open(f\"{raw_path}/{topic}.csv\", encoding=\"utf-8-sig\") as csvfile:\n                csvreader = csv.DictReader(csvfile)\n                batch = []\n\n                for rows in csvreader:\n                    batch.append(rows)\n                    if len(batch) \u003e= batch_size:\n                        send_messages(producer, topic, batch)\n                        batch = []\n\n                # Send any remaining messages in the last batch\n                if batch:\n                    send_messages(producer, topic, batch)\n\n        except FileNotFoundError:\n            logging.error(f\"File not found: {raw_path}/{topic}.csv\")\n        except Exception as e:\n            logging.error(f\"Error processing file for topic '{topic}': {e}\")\n```\n\n여기가 번잡한 부분이고, 데이터를 보내는 작업을 마치게 될 거야.\n\n제가 프로듀서를 맨 처음에 인스턴스화할 때 전달하고, 토픽들도 함께 전달해주는 함수를 만들었어요. 그런 다음 각 토픽을 순회하면서 처리해요. 각 토픽은 csv 파일과 관련이 있기 때문에, 먼저 파일을 열려고 시도하는 거죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n배치 크기를 입력 매개변수로 정의했다는 것을 알 수 있을 겁니다. 이건 정말 필수적인 것은 아니지만, csv 파일에서 데이터를 가져오는 대신에 웹페이지나 다른 스트리밍 서비스에서 가져오는 것이 아니기 때문에, 메시지를 배치로 묶어서 그룹으로 보내고 싶었습니다. 이렇게 하면 작업이 빨라집니다. 저는 toml 파일 내에서 배치 크기를 10으로 설정했는데, 이는 사실상 한 번에 csv 파일의 10줄에 해당합니다.\n\n그런 다음 각 행을 배치에 추가하면서 배치 한도에 도달할 때까지 작업을 수행한 후 데이터를 전송하고 배치를 비웁니다. 작업을 마치면 마지막 메시지로 배치를 정리합니다 (남은 레코드가 5개만 남았을 수 있지만, 그래도 모두 보내고 싶습니다).\n\n마지막으로, raw 파일을 찾을 수 없는 경우나 발생할 수 있는 기타 일반적인 오류에 대한 오류 처리가 있습니다.\n\n이것이 publisher.py 파일의 내용입니다. 이해가 되시겠나요? 이제 subscriber.py 파일로 넘어가 봅시다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 구독자\n\n구독자는 Kafka 주제를 청취하고, 새 레코드를 발견했을 때 특정 작업을 수행하는 데 사용됩니다. 이 경우, 해당 레코드의 내용을 가져와 Delta 테이블에 저장합니다. 여기서 전체 코드를 찾을 수 있는 코드를 통해 코드를 하나씩 살펴보겠습니다.\n\n```js\nif __name__ == \"__main__\":\n    consumer = create_consumer(topics, bootstrap_servers)\n    for message in consumer:\n        process_message(message.topic, message.value)\n```\n\n발행자와 비슷하게, 첫 번째로 하는 일은 주제 및 서버 세부 정보를 구성 변수로 제공하고, 이를 전달하여 소비자를 인스턴스화하는 것입니다. 그런 다음 소비한 각 메시지를 처리합니다. 간단하지요. 하지만 함수별로 좀 더 자세히 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 소비자 생성\n\n```js\ndef create_consumer(topics, bootstrap_servers):\n    return KafkaConsumer(\n        *topics,\n        bootstrap_servers = bootstrap_servers,\n        value_deserializer = lambda v: json.loads(v.decode(\"utf-8\"))\n```\n\n우리 Python의 진입점에서 첫 번째 줄은 소비자를 인스턴스화하는 것이었습니다. 이것은 기본적으로 KafkaConsumer의 래퍼일 뿐입니다. 퍼블리셔와 다른 것은 아무 것도 하지 않습니다.\n\n## 메시지 처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef process_message(topic, data):\n    df = pl.from_records([data])\n    delta_table_path = f\"{delta_path}/{topic}\"\n    if not os.path.exists(delta_table_path):\n        write_delta_table(df, delta_table_path, \"insert\")\n    else:\n        merge_into_delta_table(df, delta_table_path)\n```\n\n메시지를 받을 때마다 그것을 처리하는 방법을 알아야 합니다. 저는 여기서 두 가지 방법을 선택했습니다. 먼저 Delta 테이블이 저장된 경로를 가져와 해당 경로가 존재하는지 확인합니다. 경로가 존재하지 않으면 새 레코드를 삽입하기 위해 insert 매개변수를 사용하여 write_delta_table 함수를 호출합니다. 그러나 경로가 이미 존재한다면, merge_into_delta_table 함수를 호출합니다. 이를 통해 데이터를 여러 번로드할 수 있게 하면서 단순히 테이블을 점점 더 크게 만들지 않습니다. 이미 변경된 기존 항목을 업데이트하고 새 레코드만 추가합니다.\n\n이러한 함수들을 좀 더 자세히 살펴봅시다.\n\n## write_delta_table\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef write_delta_table(df, path, mode):\n    try:\n        df.write_delta(target=path, mode=mode)\n        logging.info(f\"{mode.capitalize()}ed message to Delta table: {df}\")\n    except Exception as e:\n        logging.error(f\"Failed to {mode} message to Delta table: {df}\")\n        logging.error(f\"Error: {e}\")\n```\n\n테이블 태그를 마크다운 형식으로 변경해주시기 바랍니다.\n\n여기서는 DataFrame, 주제 경로, 그리고 모드(삽입)를 간단히 전달하고 네이티브 Polars 기능을 사용하여 Delta 테이블에 작성합니다. 작업이 성공했음을 로그에 남기거나 실패했을 때 오류를 캡처하여 조사할 수 있도록 합니다.\n\n## merge_into_delta_table\n\n여기에는 조금 더 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef merge_into_delta_table(df, path):\n    try:\n        df.write_delta(\n            target=path, mode=\"merge\",\n            delta_merge_options={\n                \"predicate\": \"s.id = t.id\",\n                \"source_alias\": \"s\",\n                \"target_alias\": \"t\",\n            }\n        ).when_matched_update_all().when_not_matched_insert_all().execute()\n        logging.info(f\"Merged message to Delta table: {df}\")\n    except Exception as e:\n        logging.error(f\"Failed to merge message to Delta table: {df}\")\n        logging.error(f\"Error: {e}\")\n```\n\n여기에서 모드를 전달하지 않아도 됩니다. 왜냐하면 모드가 \"merge\"로 설정될 것이라는 것을 알기 때문입니다. 제 모든 테이블에는 id라는 동일한 이름을 가진 기본 키가 있으므로 한 번 정의하고 이 함수를 완전히 재사용하기 쉽습니다. 일치하는 경우 데이터가 업데이트되고, 일치하지 않는 경우 데이터가 삽입됩니다. 이것이 기본적으로 upsert입니다. 성공과 실패를 여전히 기록했습니다.\n\n여기가 파이프라인의 전부입니다. 정말 간단합니다. 데이터를 게시하고 데이터를 구독하여 디스크에 저장합니다. 다음에는 해당 데이터를 쿼리하고 모든 것을 함께 가져오는 DataFrame을 가져오는 방법을 살펴볼 것입니다.\n\n# 쿼리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 시점에서 Kafka는 더 이상 사용되지 않습니다. 모든 것이 Delta 테이블에 있으며 쿼리만 필요합니다. 전체 코드는 여기에 있습니다. Delta 테이블을 각각 데이터프레임 집합으로 불러오기 시작했습니다:\n\n```js\nclient = pl.read_delta(f\"{delta_path}/client\")\ndepartment = pl.read_delta(f\"{delta_path}/department\")\nemployee = pl.read_delta(f\"{delta_path}/employee\")\nsale = pl.read_delta(f\"{delta_path}/sale\")\n```\n\nclient와 employee 데이터프레임에는 first_name과 last_name 속성이 같습니다. 데이터프레임 이름 외에는 구별할 요소가 없습니다. 각각에 first_name과 last_name을 붙여 공백을 구분자로 사용한 새로운 속성을 추가하고 적절히 이름을 지었습니다. 이렇게 하면 두 데이터프레임을 하나의 데이터프레임으로 결합할 때 무엇이 무엇인지 알 수 있습니다:\n\n```js\nclient = client.with_columns(\n  pl\n    .concat_str([\"first_name\", \"last_name\"], (separator = \" \"))\n    .alias(\"client_name\")\n);\n\nemployee = employee.with_columns(\n  pl\n    .concat_str([\"first_name\", \"last_name\"], (separator = \" \"))\n    .alias(\"employee_name\")\n);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n직원 DataFrame에는 department_id라는 추가 속성이 포함되어 있습니다. 이를 사용하여 직원과 부서를 함께 결합한 새 DataFrame을 생성할 수 있어요:\n\n```js\nemployee_dept = employee\n  .join(\n    department,\n    (left_on = \"department_id\"),\n    (right_on = \"id\"),\n    (how = \"inner\")\n  )\n  .select([\"id\", \"employee_name\", \"department_id\", \"department\"]);\n```\n\n직원 DataFrame을 기반으로, 부서 DataFrame과 조인을 생성했는데, 직원 DataFrame의 department_id와 부서 DataFrame의 id를 일치하는 조인 조건으로 지정했어요. 모든 직원이 부서를 가져야 하기 때문에 INNER JOIN을 조인 유형으로 선택했고, 이후 유지할 속성을 선택했어요.\n\n마지막으로, 한 마지막 문장으로 모두 함께 결합할 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ncomplete = sale\n  .join(employee_dept, (left_on = \"employee_id\"), (right_on = \"id\"))\n  .join(client, (left_on = \"client_id\"), (right_on = \"id\"), (how = \"inner\"))\n  .select(\n    pl.col(\"id\").str.to_integer(),\n    pl.col(\"employee_name\"),\n    pl.col(\"department\"),\n    pl.col(\"client_name\"),\n    pl.col(\"date\").str.to_date(\"%d/%m/%Y\"),\n    pl.col(\"region\"),\n    pl.col(\"sale\").str.to_decimal(2)\n  );\n```\n\n저는 sale DataFrame에서 시작하여 방금 생성한 employee_dept DataFrame에 조인을 수행합니다. 이제 이는 sale, employee 및 department를 결합하는 것입니다. 그런 다음 client DataFrame을 다시 조인한 다음 원하는 속성을 선택합니다. 그러나 이 경우 데이터 유형을 변경했습니다. 데이터는 csv를 통해 가져온 것이기 때문에 원래 데이터 유형이 없었습니다. 따라서 id는 정수이어야 한다고 지정했습니다. 날짜는 날짜 유형이어야 하며, 형식을 지정했으며, sale 속성이 두 자리 소수점(달러 및 센트)인 것을 지정했습니다.\n\n마지막 단계는 결과를 출력하는 것입니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n본 글에서는 Kafka, Polars, 그리고 Delta Lake를 활용하여 실시간 데이터 파이프라인을 구축하는 방법을 살펴보았습니다. 메시지 스트리밍을 위해 Kafka를 활용하고, 데이터 처리를 위해 Polars를 사용하며, 안정적인 저장소로 Delta Lake를 활용하여 확장 가능하고 오류 허용성 있는 데이터 파이프라인을 만들 수 있습니다.\n\n저장소의 코드 샘플은 파이프라인의 기본 설정과 기능을 보여줍니다. 데이터 보존 정책 구성, S3 객체 저장소에 데이터 보관, 다른 시스템과 통합하는 등 특정 요구 사항에 맞게 코드를 확장하고 사용자화할 수 있습니다.\n\n이 아키텍처를 채택함으로써 기업은 실시간 데이터를 효율적으로 처리하고 분석하여 데이터 기반 결정을 내리고 신속하게 변화에 대응할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글이 유용했길 바랍니다. 만약 그렇다면 👏 한 번 눌러주시겠어요? 그리고 더 보고 싶으면 구독해주세요. 매주 한 두 편의 글을 업로드하고 있어요.\n","ogImage":{"url":"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png"},"coverImage":"/assets/img/2024-05-20-BuildingaReal-TimeDataPipeline_0.png","tag":["Tech"],"readingTime":18},{"title":"제목 Python, Jinja2 및 NiceGUI를 사용하여 독특한 Gemini AI-챗봇 만들기","description":"","date":"2024-05-20 18:41","slug":"2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI","content":"\n## 파이썬을 사용하여 베르텍스AI를 통해 Gemini의 기본 사항을 알아보고 NiceGUI를 사용하여 웹 UI를 만들며 모듈식 프롬프트를 구성하는 Jinja2를 사용하는 방법\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png)\n\n본문에서는 Python, NiceGUI, Jinja2 및 VertexAI를 사용하여 LLM 기반 웹 애플리케이션을 만들어보겠습니다. 이 프로젝트를 처음부터 만드는 방법과 기본 개념의 개요를 얻을 수 있습니다.\n\n먼저 🚀 기술 스택에 대한 간단한 개요로 시작해 보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Python 3.12\n- NiceGUI를 사용하여 파이썬으로 프론트엔드를 코딩합니다.\n- 의존성 관리를 위해 Poetry 사용\n- 모듈식 프롬프트 생성을 위해 Jinja2 템플릿 사용\n\n# Poetry를 사용한 프로젝트 설정\n\n우리는 Python에서 의존성 관리와 패키징을 위한 도구인 Poetry를 사용하여 프로젝트를 생성하고 의존성을 어떻게 관리하는지 살펴볼 것입니다.\n\nPoetry가 도와줄 수 있는 세 가지 주요 작업은 빌드, 게시 및 추적입니다. 의존성을 관리하고 프로젝트를 공유하며 의존성 상태를 추적할 수 있는 결정론적인 방법이 되는 것이 아이디어입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시, Poetry는 가상 환경을 생성하는 작업도 담당합니다. 기본적으로 시스템 내의 중앙 폴더에 위치하는데요. 하지만 저와 같이 프로젝트 관련 가상 환경을 프로젝트 폴더 내에 가지고 싶다면, 간단한 설정 변경이 필요합니다:\n\n```js\npoetry config virtualenvs.in-project true\n```\n\nPoetry new를 사용하여 새로운 Python 프로젝트를 만들 수 있습니다. 이 작업은 시스템의 기본 Python과 링크되는 가상 환경이 생성됩니다. 이것을 pyenv와 결합하면 특정 버전을 사용하는 프로젝트를 유연하게 만들 수 있습니다. 또한, Poetry에 직접 사용할 Python 버전을 알려줄 수도 있습니다: poetry env use /full/path/to/python.\n\n새 프로젝트를 생성하면, poetry add로 종속성을 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새 프로젝트를 만들어 시작해봐요:\n\n```js\npoetry config virtualenvs.in-project true\npoetry new my-gemini-chatbot\ncd my-gemini-chatbot\n```\n\n프로젝트에 대한 메타데이터 및 해당 버전과 종속성은 .toml 및 .lock 파일에 저장됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 시작하기 위해 필요한 종속성을 추가해 봅시다:\n\n```js\npoetry add 'google-cloud-aiplatform\u003e=1.38'\npoetry add 'nicegui'\n```\n\n# NiceGUI를 사용한 기본 웹 UI\n\nNiceGUI는 웹 브라우저용 그래픽 사용자 인터페이스(GUI)를 만들 수 있게 해주는 Python 라이브러리입니다. 초보자들도 빠르게 시작할 수 있지만, 고급 사용자들을 위한 맞춤 설정 옵션도 풍부하게 제공합니다. 웹 뷰는 Quasar Framework를 기반으로 하며, 다양한 구성 요소를 제공합니다. 그리고 이는 TailwindCSS를 사용하기 때문에 NiceGUI 페이지에서도 직접 TailwindCSS 클래스를 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특히 나에게는 백엔드 소프트웨어 개발에서 온 데이터 엔지니어로써, Python을 사용하여 작은 웹 UI를 만드는 것은 좋은 방법입니다. 물론 더 복잡한 프론트엔드에 대해서는 충분한 해결책이 되지 않을 수도 있지만, 범위가 상대적으로 작다면 빠르게 결과를 확인할 수 있습니다. NiceGUI를 사용하면 Python 코드에 집중할 수 있습니다. 왜냐하면 NiceGUI가 모든 웹 개발 작업을 처리하기 때문입니다.\n\nNiceGUI는 버튼, 슬라이더, 텍스트 상자와 같은 일반적인 UI 구성 요소를 사용하고 유연한 레이아웃을 사용하여 페이지에 배열합니다. 이러한 구성 요소는 Python 코드의 데이터와 연결될 수 있어 데이터가 변경될 때 인터페이스가 자동으로 업데이트됩니다. 또한 응용 프로그램의 외관을 필요에 맞게 스타일링할 수도 있습니다.\n\n이 작업 방식을 설명하는 가장 쉬운 방법은 직접 보여주는 것입니다. 그래서 최소 예제를 만들기 시작해 봅시다.\n\n내 경우에는 내 모듈의 main.py (내 경우 my_gemini_chatbot)를 생성합니다. 이 파일은 모든 어플리케이션과 프론트엔드 로직에 사용될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 코드로 간단한 레이블이 포함된 페이지를 얻을 수 있습니다:\n\n```js\nfrom nicegui import ui\n\nui.label('Hello NiceGUI!')\nui.run()\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_2.png\" /\u003e\n\n애플리케이션을 실행하면 포트 8080에서 사용할 수 있습니다. 또한 스크립트를 실행할 때 페이지가 자동으로 열립니다. 이것이 페이지가 보이는 방법입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_3.png\" /\u003e\n\n축하합니다: 순수 Python으로 만든 첫 프론트엔드 😉.\n\n# 챗봇 웹 UI 준비\n\n다음 단계는 우리 챗봇을 위한 웹 UI를 준비하는 것입니다. 물론, 위의 예제보다는 조금 더 복잡할 것이지만 NiceGUI를 사용하여 컴포넌트를 배치하는 기본 아이디어를 알면 더 쉬워질 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 몇 가지 레이아웃 기본 사항을 이해해야 합니다. 컴포넌트가 페이지 상에 배치되는 방식을 제어하는 여러 가지 방법이 있습니다. 일반적인 방법 중 하나는 그리드 레이아웃인데, 우리는 이를 사용할 것입니다.\n\nNiceGUI에서 우리는 다음과 같이 그리드를 생성할 수 있습니다:\n\n```js\nfrom nicegui import ui\n\nwith ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n    ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n\nui.run()\n```\n\n이를 하나씩 분해하여 더 잘 이해해 봅시다. ui.grid(columns=16)은 16개의 열로 분할된 그리드 레이아웃을 초기화합니다. 이들은 모두 동일한 너비를 갖습니다. 이것은 그리드의 실제 너비에 대해 아무 말도 하지 않으며 그리드가 몇 개의 열로 나눠질지만을 지정합니다. 16개의 열로, 우리는 충분한 유연성을 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 .classes를 통해 사용자 정의 TailwindCSS 클래스를 추가할 수 있습니다. 여기서 우리는 그리드에 3가지 클래스를 추가했습니다:\n\n- w-3/4: 그리드는 항상 브라우저 전체 너비의 3/4을 차지해야 합니다.\n- place-self-center: 그리드 자체가 브라우저 창 가운데에 위치해야 합니다.\n- gap-4: 그리드 내 요소 사이에는 4개의 픽셀 간격이 있어야 합니다.\n\n위 예시에서는 그리드 안에 요소 하나를 배치했습니다:\n\n```js\nwith ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n    ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 확인할 수 있듯이, 우리는 다시 col-span-full이라는 사용자 정의 클래스를 할당했습니다. 이는 NiceGUI에게 이 요소가 첫 번째 행의 모든 사용 가능한 열을 사용해야 함을 알려줍니다. 우리의 경우: 모든 16열을 사용합니다.\n\n모든 열의 양에 대한 클래스가 있으므로 첫 번째 요소에 col-span-10을 할당하고 두 번째 요소에 col-span-6을 할당하여 한 행에 2개의 요소를 채울 수도 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_4.png\" /\u003e\n\n이 지식을 바탕으로 우리의 챗봇에 필요한 모든 요소를 추가할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom nicegui import ui\n\nwith ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n    ui.markdown(\"# 🚀 우리의 Gemini 챗봇\").classes(\"col-span-full\")\n    ui.input(label=\"프롬프트\").classes(\"col-span-10\")\n    ui.select(\n        options=[\"기본\", \"산타 클로스\"],\n        value=\"기본\",\n        label=\"성격 선택\"\n    ).classes(\"col-span-6\")\n    ui.button(\"Gemini로 전송\").classes(\"col-span-full\")\n\n    with ui.card().classes(\"col-span-full\"):\n        ui.markdown(\"## Gemini 응답\")\n        ui.separator()\n        ui.label(\"Gemini에 프롬프트를 보내고 응답을 여기서 확인하세요.\")\n\nui.run()\n```\n\n위의 코드는 다음과 같은 웹 UI를 만들어냅니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_5.png\" /\u003e\n\nPython으로 완전히 작성된 UI로는 꽤 괜찮은 결과가 나온 것 같네요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 기본 기능 추가하기\n\n우리의 다음 작업은 기본 기능을 추가하는 것입니다. 아직 VertexAI나 Gemini와 상호 작용하지는 않겠지만, Gemini로 전송 버튼을 클릭하면 사용자 입력을 반영하는 알림이 표시되도록 기능을 추가하려고 합니다.\n\n중요한 개념 하나를 설명해 드리겠습니다: 우리의 프론트엔드는 우리 Python 스크립트의 한 인스턴스에 의해 제공됩니다. 이제 사용자 입력을 전역 변수에 저장하고 있는데, 동시에 챗봇을 사용하고 있는 다른 사용자가 다른 값을 제출한다고 상상해 보십시오. 그러면 첫 번째 사용자의 값이 덮어쓰여지기 때문에 재밌지만 예상치 못한 동작이 발생할 것입니다.\n\n최근 NiceGUI에서는 이러한 상황을 다루기 위해 '저장소' 기능을 소개했습니다. 이는 데이터 지속성을 위한 간단한 메커니즘으로, 클라이언트 측에 데이터를 저장하는 것과 서버 측에 데이터를 저장하는 것을 포함한 다섯 가지 내장 저장 유형을 기반으로 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 저장소 기능은 페이지 빌더의 컨텍스트에서만 사용할 수 있습니다. 기본적으로 이것은 다음을 의미합니다: 메인 스크립트에서 웹 페이지를 간단히 코딩하는 대신, 각 페이지마다 함수로 래핑합니다. 우리는 한 페이지만 가지고 있으므로 하나의 함수만 필요합니다: index(). 그런 다음 해당 함수가 메인 인덱스 페이지인 /로 정의된 페이지를 나타낸다고 NiceGUI에 알리기 위해 데코레이터를 사용합니다.\n\n이제 페이지 데코레이터를 사용하면 저장소 기능도 사용할 수 있습니다. 간단한 클라이언트 측 저장소를 사용할 것입니다. 이를 위해 nicegui에서 app을 가져와야하며, 다음과 같이 사전 기반 저장소인 app.storage.client에 액세스할 수 있습니다.\n\nNiceGUI의 또 다른 기능으로 데이터 작업을 쉽게 만들어주는 기능이 있습니다. 그 방법은 입력 요소를 변수에 바인딩하는 것입니다. 이렇게 함으로써 사용자 프롬프트를위한 입력 요소를 앞서 언급한 클라이언트 저장소에 저장된 변수에 바인딩할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nui.input((label = \"Prompt\"))\n  .bind_value(app.storage.client, \"prompt\")\n  .classes(\"col-span-10\");\n```\n\n이제 입력 요소의 값은 항상 다음과 같이 액세스할 수 있습니다: app.storage.client.get(\"personality\").\n\n그리고 NiceGUI는 버튼 및 기타 요소에 on_click 매개변수를 정의할 수 있도록 합니다. 이 매개변수는 일반 Python 함수에 대한 참조를 취합니다. 이렇게 하면 웹 애플리케이션을 상호 작용 가능하게 할 수 있습니다.\n\n먼저 send() 함수를 소개하겠습니다. 나중에 Gemini LLM과 상호 작용하기 위해 사용할 것입니다. 현재 입력 양식의 현재 입력 값을 사용자에게 간단히 보여줄 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom nicegui import ui, app\n\ndef send():\n    prompt = app.storage.client.get(\"prompt\")\n    personality = app.storage.client.get(\"personality\")\n    ui.notify(\n        f\"Prompt: {prompt}, Personality: {personality}\",\n        type=\"info\"\n    )\n\n@ui.page('/')\ndef index():\n    with ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n        ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n        ui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n        ui.select(\n            options=[\"Default\", \"Santa Claus\"],\n            value=\"Default\",\n            label=\"Personality\"\n        ).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n        ui.button(\"Send to Gemini\", on_click=send).classes(\"col-span-full\")\n\n        with ui.card().classes(\"col-span-full\"):\n            ui.markdown(\"## Gemini Response\")\n            ui.separator()\n            ui.label(\"Send your prompt to Gemini and see the response here.\")\n\nui.run()\n```\n\n이제 사용자가 \"Send to Gemini\" 버튼을 클릭할 때마다, 입력 요소의 값이 표시되는 send() 함수를 통해 알림이 표시됩니다.\n\n![image](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_6.png)\n\n# Jinja2를 활용한 모듈화된 프롬프트들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시간이 되었어요! 🌪️ 사용자 프롬프트를 Gemini에 단순히 전송하는 대신, 사용자 입력을 기반으로 모듈식 프롬프트를 구성할 거에요. 그러면 프롬프트에 개성 부분을 프로그래밍적으로 추가해서 AI가 선택한 사용자에 따라 다른 성격으로 응답할 수 있어요.\n\nJinja2는 파이썬을 위한 템플릿 엔진이에요. Jinja2는 다양한 영역에서 동적 콘텐츠를 생성하는 데 도움이 되죠. 이는 로직과 표현을 분리하여 깨끗하고 유지보수 가능한 코드베이스를 유지할 수 있게 해줘요.\n\nJinja2는 다음과 같은 핵심 개념을 사용해요:\n\n- 템플릿: 사용 사례에 따라 내용이 포함된 텍스트 파일 (예: HTML, 설정 파일, SQL 쿼리).\n- 환경: 템플릿 구성을 관리해요 (예: 구분자, 자동 이스케이핑).\n- 변수: 이중 중괄호 ('' 변수 '')를 사용하여 템플릿에 삽입돼요.\n- 블록: '% ... %' 태그로 정의돼요 (예: 반복, 조건문을 위한) 제어 흐름.\n- 주석: 코드 가독성을 위해 '# ... #'로 묶여 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJinja2은 웹 개발에서 많이 사용되지만, 동적 콘텐츠를 생성하는 데 유용하기 때문에 Airflow와 같은 다른 경우에도 사용됩니다.\n\n이 프로젝트에서는 특정 인격과 사용자 프롬프트로 대체되는 변수를 포함하는 일반 템플릿을 정의하는 데 사용할 것입니다. 이렇게 하면 Python 코드가 깔끔하게 유지되고 쉽게 확장할 수 있는 모듈식 솔루션을 갖게 됩니다. 스포일러: 나중에 매우 재미있는 인격을 소개할 예정입니다.\n\nJinja2를 사용하기 전에 프로젝트 의존성에 추가해야 합니다. Poetry를 사용하고 있으므로 다음을 통해 수행할 수 있습니다:\n\n```js\npoetry add jinja2\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 템플릿을 저장할 폴더도 필요합니다. 좋은 기본 사례는 모듈 폴더에 templates라는 폴더를 추가하는 것입니다. 그러니 이 경우에는:\n\n```js\nmkdir my_gemini_chatbot/templates\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_7.png\" /\u003e\n\nJinja2를 사용하려면 환경을 설정해야 합니다. 위에서 설명한 대로, 환경은 일반 템플릿 구성을 관리합니다. 우리는 간단하게 유지하고 Jinja2가 우리의 폴더에서 템플릿을 찾도록 만들겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nenv = Environment(\nloader=PackageLoader(\"my_gemini_chatbot\"),\nautoescape=select_autoescape()\n)\n\n이제 템플릿을 준비할 시간입니다. templates/ 폴더 내에 prompt.jinja, default.jinja 및 santaclaus.jinja 세 개의 파일을 생성하십시오. default.jinja 파일은 비워두세요. 기본 펄스널리티는 Gemini의 정상 동작일 것이므로요.\n\n![image](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_8.png)\n\n다음 내용을 prompt.jinja 템플릿에 추가해 봅시다. 이것은 기본 템플릿입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n{ 성격 }\n\n{ 프롬프트 }\n\n이제, santaclaus.jinja에 다음 내용을 추가하여 산타클로스 성격을 정의해 봅시다:\n\n```js\n당신은 산타클로스이며 크리스마스를 사랑합니다. 당신의 답변에는 크리스마스와 관련된 사실과 퀴즈를 최대한 추가해 보세요. 또한 답변을 항상 엄격하게 \"Ho ho ho\"로 시작하고 \"메리 크리스마스\"로 끝내세요. 당신은 진정한 크리스마스 애호가입니다.\n```\n\n빠른 알림: 웹 UI에는 성격을 선택하는 select 요소가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nui.select(\n  (options = [\"Default\", \"Santa Claus\"]),\n  (value = \"Default\"),\n  (label = \"성격\")\n)\n  .bind_value(app.storage.client, \"personality\")\n  .classes(\"col-span-6\");\n```\n\n작은 도우미 함수를 사용하겠습니다. 이 함수는 선택한 값을 템플릿 파일로 매핑합니다:\n\n```js\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case _:\n            return \"default.jinja\"\n```\n\n이제 이 도우미 함수와 Jinja2 환경의 get_template 기능을 사용하여 템플릿을 사용한 프롬프트를 만들 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom jinja2 import Environment, PackageLoader, select_autoescape\nfrom nicegui import ui, app\n\n\nenv = Environment(\n    loader=PackageLoader(\"my_gemini_chatbot\"),\n    autoescape=select_autoescape()\n)\n\n\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case _:\n            return \"default.jinja\"\n\n\ndef send():\n    user_prompt = app.storage.client.get(\"prompt\")\n    personality = app.storage.client.get(\"personality\")\n\n    personality_template = env.get_template(get_personality_file(personality))\n    prompt_template = env.get_template(\"prompt.jinja\")\n\n    prompt = prompt_template.render(\n        prompt=user_prompt,\n        personality=personality_template.render()\n    )\n\n    ui.notify(\n        f\"Prompt: {prompt}\",\n        type=\"info\"\n    )\n\n\n@ui.page('/')\ndef index():\n    with ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n        ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n        ui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n        ui.select(\n            options=[\"Default\", \"Santa Claus\"],\n            value=\"Default\",\n            label=\"Personality\"\n        ).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n        ui.button(\"Send to Gemini\", on_click=send).classes(\"col-span-full\")\n\n        with ui.card().classes(\"col-span-full\"):\n            ui.markdown(\"## Gemini Response\")\n            ui.separator()\n            ui.label(\"Send your prompt to Gemini and see the response here.\")\n\n\nui.run()\n```\n\n지금 \"Send to Gemini\"을 클릭하면 Jinja2 템플릿을 기반으로 만든 모듈화된 프롬프트를 볼 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_9.png\" /\u003e\n\n# VertexAI를 통해 Gemini LLM 통합하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n젬니아이(GeminiAI)를 사용하기 위해서는 VertexAI를 통해 Gemini에 연결하려면, VertexAI가 활성화된 Google Cloud 프로젝트와 충분한 액세스 권한을 가진 서비스 계정 및 해당 계정의 JSON 키 파일이 필요합니다.\n\n![](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_10.png)\n\n새 프로젝트를 생성한 후, APIs 및 서비스 - `API 및 서비스 활성화 -` VertexAI API 검색 - ` 활성화로 이동합니다.\n\n![](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스 계정을 생성하려면 IAM 및 관리 - 서비스 계정 - 서비스 계정 만들기로 이동하십시오. 적절한 이름을 선택하고 다음 단계로 이동하십시오.\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_12.png)\n\n이제 계정에 미리 정의된 역할 Vertex AI 사용자를 할당하는지 확인하십시오.\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_13.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내 새로운 사용자 → 키 → 키 추가 → 새 키 생성 → JSON을 클릭하여 JSON 키 파일을 생성하고 다운로드할 수 있습니다. 이 파일이 있으면 사용할 준비가 된 것입니다.\n\n![이미지](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_14.png)\n\nJSON 자격 증명 키 파일을 준비하고 프로젝트 내에 저장한 후에는 VertexAI를 초기화할 수 있습니다.\n\n```js\ncredentials = service_account.Credentials.from_service_account_file(\n  \"gcp-vojay-gemini.json\"\n);\nvertexai.init(\n  (project = \"vojay-329716\"),\n  (location = \"us-central1\"),\n  (credentials = credentials)\n);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 VertexAI를 통해 모델을 로드할 수 있어요. 저희는 Gemini Pro 모델을 사용할 거예요.\n\n```js\nmodel = GenerativeModel(\"gemini-pro\");\n```\n\n이 모델은 대화를 시작하는 start_chat 함수를 제공해요. 이 함수는 Gemini에 데이터를 보내는 send_message 함수를 가진 Chat 객체를 반환해요. 여기서 generation config 매개변수를 조정할 수도 있어요. 여기서는 기본값을 사용할 거예요. Gemini로부터의 응답을 스트리밍하기 때문에, 전체 채팅 응답을 받기 위해 도우미 함수를 사용할 거에요:\n\n```js\ndef get_chat_response(chat, prompt):\n    text_response = []\n    responses = chat.send_message(prompt, stream=True)\n    for chunk in responses:\n        text_response.append(chunk.text)\n    return ''.join(text_response)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 이 정도면 괜찮네요. 우리는 준비된 프롬프트와 VertexAI가 초기화된 상태이며, 채팅 응답을 가져오는 도우미 함수를 사용하여 마침내 Gemini를 통합할 수 있게 되었어요.\n\n클라이언트 스토리지에서 변수에 바인딩된 레이블을 추가할 것이고, 이 레이블은 Gemini 응답을 저장하고 렌더링하는 데 사용될 거에요:\n\n```js\nui.label().bind_text(app.storage.client, \"response\");\n```\n\n이제 첫 번째 버전이 준비되었습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport vertexai\nfrom google.oauth2 import service_account\nfrom jinja2 import Environment, PackageLoader, select_autoescape\nfrom nicegui import ui, app\nfrom vertexai.generative_models import GenerativeModel\n\ncredentials = service_account.Credentials.from_service_account_file(\n    \"../gcp-vojay-gemini.json\"\n)\nvertexai.init(project=\"vojay-329716\", location=\"us-central1\", credentials=credentials)\n\nenv = Environment(\n    loader=PackageLoader(\"my_gemini_chatbot\"),\n    autoescape=select_autoescape()\n)\n\nmodel = GenerativeModel(\"gemini-pro\")\n\n\ndef get_chat_response(chat, prompt):\n    text_response = []\n    responses = chat.send_message(prompt, stream=True)\n    for chunk in responses:\n        text_response.append(chunk.text)\n    return ''.join(text_response)\n\n\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case _:\n            return \"default.jinja\"\n\n\ndef send():\n    user_prompt = app.storage.client.get(\"prompt\")\n    personality = app.storage.client.get(\"personality\")\n\n    personality_template = env.get_template(get_personality_file(personality))\n    prompt_template = env.get_template(\"prompt.jinja\")\n\n    prompt = prompt_template.render(\n        prompt=user_prompt,\n        personality=personality_template.render()\n    )\n\n    ui.notify(\"Sending to Gemini...\", type=\"info\")\n    chat = model.start_chat()\n    response = get_chat_response(chat, prompt)\n    ui.notify(\"Received response...\", type=\"info\")\n\n    app.storage.client[\"response\"] = response\n\n\n@ui.page('/')\ndef index():\n    with ui.grid(columns=16).classes(\"w-3/4 place-self-center gap-4\"):\n        ui.markdown(\"# 🚀 My Gemini Chatbot\").classes(\"col-span-full\")\n        ui.input(label=\"Prompt\").bind_value(app.storage.client, \"prompt\").classes(\"col-span-10\")\n        ui.select(\n            options=[\"Default\", \"Santa Claus\"],\n            value=\"Default\",\n            label=\"Personality\"\n        ).bind_value(app.storage.client, \"personality\").classes(\"col-span-6\")\n        ui.button(\"Send to Gemini\", on_click=send).classes(\"col-span-full\")\n\n        with ui.card().classes(\"col-span-full\"):\n            ui.markdown(\"## Gemini Response\")\n            ui.separator()\n            ui.label().bind_text(app.storage.client, \"response\")\n\n\nui.run()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![GeminiAI Chatbot](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_16.png)\n\n# AI가 바에 들어가다\n\n저는 아빠가 된 이후로, 가능한 경우에 아빠 농담을 해주는 기회를 즐기고 있어요. 이 장에서는 Jinja2를 사용한 모듈식 접근 방법과 NiceGUI를 사용한 간단한 웹 UI의 이점을 설명하고 싶어 합니다.\n\n새로운 개성을 소개해보죠. dadjokes.jinja와 같이 다른 파일 옆에 새로운 템플릿 파일을 만들어 다음 내용을 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n넌 자랍니다. 하지만, 거의 모든 문장에 아빠 농담을 추가해야 합니다. 답변에 가능한 한 많은 아빠 농담을 넣고, 입력과 관련된 농담을 만드려고 노력해주세요. 또한, 답변에 많은 이모지를 추가하고 싶어 금을 참지 못할 겁니다. 😉👨‍👧‍👦\n\n이를 실행하기 위해 우리는 우리의 도우미 함수인 get_personality_file을 확장해야 합니다. 👨‍💻\n\n```js\ndef get_personality_file(value):\n    match value:\n        case \"Default\":\n            return \"default.jinja\"\n        case \"Santa Claus\":\n            return \"santaclaus.jinja\"\n        case \"Dad Jokes\":\n            return \"dadjokes.jinja\"\n        case _:\n            return \"default.jinja\" 😄\n```\n\n그리고 우리의 입력 요소에 새 옵션을 추가하여 사용자가 새로운 옵션을 선택할 수 있도록 합시다. 🎁🧔\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nui.select(\n  (options = [\"기본\", \"산타 클로스\", \"아빠 Jokes\"]),\n  (value = \"기본\"),\n  (label = \"성격\")\n)\n  .bind_value(app.storage.client, \"personality\")\n  .classes(\"col-span-6\");\n```\n\n이제 해보기 전에 한 가지 더 구현해 봅시다. 다크 모드를 도입해 보겠습니다! NiceGUI를 사용하면 이 작업이 매우 간단합니다. ui.dark_mode()를 통해 UI 모드를 전환하기 위한 disable 및 enable 두 가지 함수를 제공하는 dark 객체를 얻을 수 있습니다. 그리드 접근 방식과 함께 사용하여 \"젬니니로 전송\" 버튼 옆에 UI 모드를 전환하는 두 개의 버튼을 쉽게 배치할 수 있습니다. 다음과 같이 코드 작성하세요:\n\n```js\nui.button(\"젬니니로 전송\", (on_click = send)).classes(\"col-span-8\");\n\ndark = ui.dark_mode();\nui.button(\"라이트 UI\", (on_click = dark.disable)).classes(\"col-span-4\");\nui.button(\"다크 UI\", (on_click = dark.enable)).classes(\"col-span-4\");\n```\n\n\"젬니니로 전송\" 버튼이 col-span-full 클래스 대신 col-span-8 클래스를 사용하고 있음을 알 수 있습니다. 또한 16개 열의 그리드를 사용하므로 바로 옆에 각각 col-span-4를 사용하여 두 개의 새로운 버튼을 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표를 Markdown 형식으로 바꾸는 방법은 다음과 같아요:\n\n| Function    | Description       |\n| ----------- | ----------------- |\n| ui.run()    | 애플리케이션 실행 |\n| ui.page()   | 페이지 만들기     |\n| ui.button() | 버튼 생성         |\n\n위와 같이 수정하시면 Markdown 형식으로 표를 작성할 수 있어요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아빠로서 이걸 승인합니다 😂.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*9xgCK0hrAI4XznUwk44o-w.gif)\n\n# 결론\n\n농담은 농담이고, 이 글을 통해 Gemini LLM을 기반으로 자체 AI 챗봇을 만들고 VertexAI와 함께 파이썬을 사용하여 NiceGUI로 간단한 웹 UI를 만드는 방법을 배웠습니다. Jinja2 템플릿을 사용하여, 이 비교적 짧은 예제조차도 확장하기 쉬운 모듈식 AI 애플리케이션을 제공했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![GeminiAI Chatbot](/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_18.png)\n\n파이썬, Jinja2 및 NiceGUI를 사용하면 VertexAI의 Gemini LLM과 상호 작용하는 사용자 친화적 인터페이스를 구축할 수 있습니다. 이를 통해 교육용 챗봇부터 재미있는 개성 기반 챗 체험까지 다양한 창의적인 응용 프로그램이 가능해집니다.\n\n이 블로그 글이 여러분들에게 VertexAI의 잠재력을 탐험하고 자체 AI 애플리케이션을 구축해보는데 영감을 줬기를 희망합니다.\n\n즐기고, 지시를 따르는 데 서툰 AI를 무엇이라고 부를까요? — 절망적 절자 없는 반란자.\n","ogImage":{"url":"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png"},"coverImage":"/assets/img/2024-05-20-CreateyourownGeminiAI-chatbotwithatwistusingPythonJinja2andNiceGUI_0.png","tag":["Tech"],"readingTime":29},{"title":"2024년에 데이터 엔지니어링 전문가가 되는 방법","description":"","date":"2024-05-20 18:39","slug":"2024-05-20-HowIwouldbecomeaproindataengineeringin2024","content":"\n당신의 데이터 엔지니어링 경력에서 이 사람처럼 날아다니고 싶나요?\n\n![이미지](/assets/img/2024-05-20-HowIwouldbecomeaproindataengineeringin2024_0.png)\n\n그럼 탑승하세요! 믿어 믿어, 시간을 할애하는 가치가 있을 거에요. 🤗\n\n지난 블로그에서 (여기를 참조하십시오), 데이터 엔지니어링에 어떻게 시작하고 입문 수준의 데이터 엔지니어링 직업을 얻을 수 있는지 설명했어요. (읽어보셨나요? 아니요? 꼭 읽어보세요. 아니면 두 부작 영화의 후편을 보는 느낌이겠죠. 😒)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 이전 블로그에서 전제 조건을 마무리하면, 당신이 경력을 향상시키고 프로 수준의 데이터 엔지니어가 되기 위해 무엇을 배워야 하는지 정확히 알려줄게요.\n\n우선 다음 수준의 데이터 엔지니어링 경력을 키우는 데 어떤 경로를 선택할 수 있는지에 대해 이야기해 봅시다.\n\n요즘에는 데이터 엔지니어링 직무들이 데이터 엔지니어링 이상을 요구하기 시작했는데, 일본 기업들의 열정적인 데이터를 분석하면 3가지 패턴을 식별할 수 있어요. (이걸 좋아하시나요? 데이터에서 패턴을 찾는 걸 좋아하신다면, 다음에 뭘 배워야할지 정확히 알려드릴게요. 😎)\n\n하지만 지금은 계속 읽어보세요. 어떤 경로를 선택할 수 있는지 도와줄 수 있는 몇 가지 시나리오를 알려드릴 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIPL 2024가 진행 중이며, 이미 많은 사람들이 이에 대해 알고 있을 것입니다 (인도에서는 두 가지 종교가 있습니다. 1. 당신의 실제 종교가 무엇이든지, 2. 크리켓 😜).\n\n지금까지 RCB는 어떤 IPL도 우승하지 못했지만 RR보다 총 승리 횟수가 더 많다는 것을 알고 계셨나요? 아니면 당신이 좋아하는 팀의 순위 계산을 통해 플레이오프에 진출할 수 있는지 확인하는 사람일까요?\n\n만약 크리켓 팬이 아니라면 어떻게든지, 그렇다면 아마도 여러분은 가장 아름다운 스포츠인 축구 (Hala Madrid 🤩)의 열렬한 팬이 되셨고, 챔피언스 리그에서 응원하는 팀이 있으며 선수의 xG를 계산하는 것을 좋아하시거나 최애 수비수가 완료한 태클 수를 확인하시거나 다양한 골키퍼의 히트맵을 분석하는 것을 좋아하시는 분일 수도 있습니다. 그리고 Manuel Neuer가 쉽게 수비수로 뛰어들 수 있다는 것을 알게 되셨을지도 모릅니다.\n\n그리고 혹시 이러한 게임 중 어느 하나도 좋아하지 않는다면 (진지하게??? 😣), 주식의 재무제표를 분석하여 잠재적인 매입 기회를 찾아내는 것을 좋아하시는지요 🤯, 혹은 다가올 여행을 위해 친구들과 예산을 만들기 위해 엑셀 시트를 만드는 분일 수도 있습니다.\n\n만약 여러분이 이러한 것들에 공감한다면, 다음 단계는 Power BI나 Tableau와 같은 데이터 시각화 도구에 대해 배우는 것입니다. (솔직히 말해서 어느 쪽을 선택하더라도 잘못될 일은 없지만 Power BI가 좀 더 쉬울 수 있습니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 질문이 생깁니다. Power BI를 어떻게 배워야 할까요? (응, 나는 좀 편향되어 있어요 😎)\n\n- 만약 강좌를 따를 필요가 꼭 있다면, Udemy에 접근할 수 있다면(내 말은, 회사에서 무료로 제공하는 경우), 다음 강좌가 좋을 거에요\n  [Udemy 강좌 링크](https://www.udemy.com/course/70-778-analyzing-and-visualizing-data-with-power-bi/?couponCode=LEADERSALE24A)\n  내가 이 강좌를 추가한 이유는 Azure PL-300 자격증을 취득할 수도 있다는 점이에요. 반드시 그렇게 해야 하는 건 아니지만 회사가 비용을 지불해주는 경우라면 왜 하지 않을까요?\n  내가 제안하는 방법은 한 달 후의 시험 일자를 예약하고 배우기 시작하는 것이에요. 그렇게 하면 '아 나중에 하면 되지'라고 생각하는 것보다 더욱 효율적으로 공부할 수 있어요.\n  나는 너에 대해 잘 모르겠지만, 내가 마음속에 마감일을 두면 보다 집중을 잘 한다.\n\n- Udemy 비즈니스 접근 권한이 없는 분들을 위해서 걱정하지 마세요, 무료로 배울 수 있는 방법도 있어요. 다만 여기에서는 스스로에게 구조를 정비해야 할 수도 있어요. 그렇지만! Microsoft에서는 PL-300을 위한 학습 경로를 제공하고 있고 구조를 이미 갖추고 있어요. 이제 할 일은 다음 재생 목록을 따라가서 기초를 습득하고, 앞서 설명한대로 시험 일자를 예약하고(약 45일 후에), 공부를 시작하는 것이에요.\n  [YouTube 재생 목록 링크](https://youtube.com/playlist?list=PLUaB-1hjhk8HqnmK0gQhfmIdCbxwoAoys\u0026si=sR5WzXwQxfbojLrJ)\n\n기초를 익힌 후에는 원하는 주제로 몇 개의 완성형 대시보드를 작업해보세요. 더 자세한 설명은 필요하지 않을 거에요. 단지, 다른 사람의 프로젝트를 맹목적으로 따르지 말고 Kaggle에서 데이터셋을 활용해 직접 무언가를 해보세요(응, 언젠가는 거기에 가서 탐험해야죠, 금덩어리 같아요 😍).\n\n조금은 익숙해지고 스스로 작업할 수 있게 되면 데이터 과학을 배울 차례에요. 하지만 데이터 과학을 어떻게 배울지 설명하면 이 블로그가 너무 길어지기 때문에 나준 날짜에 대해 예약해 두겠어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 위 이야기에 확신이 서지 않는 분이신다면, 즉, 이것이 평생의 직업으로 선택한 일이 아니라고 느낀다면, 백엔드 쪽에서 무언가 하는 건 어때요? 만약 API를 만들어본 적이 없고 백엔드가 데이터 엔지니어링과 어떤 연관이 있는지 궁금하다면, 친구야, 그것이 당신이 배우고 싶어하는 것이 아니라는 거죠. 멋진 일을 하고 싶지만 1년 혹은 2년 동안 엄청난 학습을 요구하는 것도 너무 좋아하시면 다음 단계로 넘어가셔도 좋습니다.\n\n![이미지](/assets/img/2024-05-20-HowIwouldbecomeaproindataengineeringin2024_2.png)\n\n만약 이 두 가지 옵션이 마음에 들지 않는다면, 이전 옵션으로 돌아가서 Power BI를 배우고, 커뮤니케이션 스킬을 향상시키고 특히 이야기하는 능력을 갖추세요(블로그 전체를 읽은 분들에게 보너스 포인트 😜). 그리고 다음 동영상부터 시작해보세요. 이 글을 읽고 있다면, 당신은 두 가지 중 어느 하나를 선택해야 하는 어려운 결정을 하고 있는 중이에요.\n\n![이미지](/assets/img/2024-05-20-HowIwouldbecomeaproindataengineeringin2024_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 약을 복용할지는 다음 문장을 읽었을 때 떠오르는 대답에 따라 달라질 것입니다: \"나는 확률, 다변수 미적분을 좋아하고 아래 식은 전혀 복잡하지 않다고 느껴져.\"\n\n![이미지](/assets/img/2024-05-20-HowIwouldbecomeaproindataengineeringin2024_4.png)\n\n만약 당신의 대답이 \"절대 아니야!!! 다시 시작할 수 없어!!!\" 라면, 친구여, 당신은 백엔드를 배우기 위해 알약을 삼켜야 할지도 모릅니다 (이미 배운 적이 없다고 가정합니다).\n\n백엔드를 배우는 방법을 탐색하기 시작하면, 여러 도구들이 당신을 다양한 옵션으로 속일 수 있습니다.\n파이썬 커뮤니티는 Django와 Flask를 추천하고 빠르게 가라고 제안할 수도 있습니다 (API 😂).\n어떤 사람들은 Node JS를 제안할 수도 있고, 어떤 사람들은 Spring Boot를 제안할 수도 있으며, Go를 배우라는 제안을 받을 수도 있습니다. 하지만 당신이 선택하는 데 도움이 될 수 있는 몇 가지를 알려드리겠습니다.\n현재 가장 많이 사용되는 프레임워크를 배우고 싶으신가요? 만약 그렇다면, 나머지는 건너뛰고 바로 Spring Boot를 배우는 것을 시작하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런데, 그러나, 이러한 경우가 있습니다.\n\nCore Java, Hibernate, JDBC, Struts, Lambda 표현식 등을 아십니까?\n\n그렇다면 진행하세요. 그렇지 않다면 다음 비디오를 따라가는 것을 제안합니다. 자바를 배우는 다양한 경로에 대해 알 수 있는 좋은 안내서입니다. 조금 오래되었지만 완전히 새로운 사람들을 위한 최고의 안내서입니다(자바 학습 경로).\n\n자바를 배우는 것은 어려운 작업일 수 있으며 Kaushik이 설명한 모든 것을 배우는 데 1년이 걸릴 수 있습니다. 아마도 어떻게 배웠는지에 대한 별도의 게시물을 만들 것입니다(네, 이 경로를 선택했습니다 😎). 그러나 결심을 세우고 매일 출석하는 것으로 진행하면 쉬워질 것입니다.\n그리고 자바를 선택하는 또 다른 이유는 마이크로서비스와 카프카일 수 있습니다. 이 두 가지 도구는 자바 에코시스템과 잘 통합되어 있으므로 그 모든 고충이 두 배의 보상을 줄 것입니다.\n작업이 너무 큰 일로 보인다면 Node 대신 Django나 Fast API를 선택할 수도 있습니다. 데이터 엔지니어로서 이미 Python 경험이 있기 때문에 새로운 언어를 배워야 할 이유가 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 것을 배워야 하는 것이 마지막 길이에요 😅, 즉 다음과 같은 길을 말해 봅니다:\n\n![이미지](/assets/img/2024-05-20-HowIwouldbecomeaproindataengineeringin2024_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전문 분야는 기계 학습 엔지니어 또는 AI 엔지니어가 될 것입니다. 이를 위해 앞서 말씀드린 대로 수학 및 통계에 대해 폭넓은 지식이 필요하고, 오늘날의 AI 모델을 구동하는 알고리즘에 대해 모든 것을 배워야 할 것입니다. 이 경로는 대부분 석사 또는 박사학위가 필요합니다 (예외는 있지만 대부분 그렇습니다). 그리고 이러한 직책을 위해 최소 몇 년 간 전념해야 할 시간이 필요할 것입니다. 가끔 사람들은 AI를 데이터 과학과 혼동하기도 하지만, 그것들은 완전히 다른 것들입니다. 그리고 여러분이 이 전체 블로그를 읽었기 때문에 더 말씀드릴게요: 훌륭한 AI/ML 엔지니어가 되기 위해 어떤 소프트웨어 엔지니어링 기술도 몇 가지는 배워야 합니다.\n\n따라서 다음 부분은 여러분이 선택한 경로와 상관없이 모두에게 중요합니다.\n\n시스템 설계 방법을 배우는 것 (System Design).\n\n이것은 본질적으로 별도의 주제이므로 이것을 스킵하겠지만, 가장 중요한 필수 사항으로 여러분에게 남기고 지금까지 말하지 않았다는 사실에 놀랄지도 모릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클라우드에 대해 알아보세요(AWS, Azure 중에서 선택). 여러 서비스가 있을 텐데, 모두에게 적합하지 않은 서비스도 많을 거에요.\n그러니 위에서 설명한 경로 중 하나를 선택했다면, 경로에 적합한 서비스를 찾아보세요.\n\n오케이, 이것이 긴 글이었네요. 마음에 들었으면 좋겠고, 좋았던 점이나 아쉬운 점이 있다면 자유롭게 의견을 남겨주세요 🙂.\n\n다음에 또 만나요! 건강하세요!!!\n","ogImage":{"url":"/assets/img/2024-05-20-HowIwouldbecomeaproindataengineeringin2024_0.png"},"coverImage":"/assets/img/2024-05-20-HowIwouldbecomeaproindataengineeringin2024_0.png","tag":["Tech"],"readingTime":8},{"title":"탐색적 데이터 분석 런던 교통 수속에 잃어버린 물품","description":"","date":"2024-05-20 18:36","slug":"2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon","content":"\n\u003cimg src=\"/assets/img/2024-05-20-런던 교통수단에서 분실물 품목의 탐색 데이터 분석_0.png\" /\u003e\n\n여러분께서도 짐을 버스에 두고 내려온 적이 있을 것 같아요. 다섯 분 뒤에 짐이 없어진 것을 깨닫지만 이미 버스가 떠났어요. 집에 돌아온 후 버스 회사 웹사이트를 확인해보니 분실한 짐을 청구할 수 있는 가능성이 있었고, 며칠 후 운종사에게 운종사에게 연락을 해서 짐을 다시 받을 수 있었어요. 저는 암스테르담에 살고 있는데, 여기의 대중교통은 iLost사와 협력 관계에 있어요. 누군가 분실한 물품을 청구할 수 있는 곳이랍니다. 이 사이트는 꽤 명확한 구조를 갖고 있으며 다른 사람들이 잊어버린 물품들을 볼 때에는 심지어 등록할 필요가 없어요 (개인 정보는 물론 숨겨져 있겠죠). 이런 데이터 지향적 사고방식이 있는 저는 ‘유레카’라는 순간을 겪었죠 — 이런 종류의 데이터는 문화 인류학적 관점에서 훌륭하다고 생각해서 대중교통 및 다른 장소에서 분실될 수 있는 물품에 대해 많은 것을 배울 수 있다고 생각했어요. 그러나 iLost의 라이선스 계약은 서면 동의 없이 데이터를 사용하는 것을 허가하지 않았기 때문에 제 질문에 아무도 답변하지 않았어요. 그럼에도 불구하고 이 아이디어를 마음에 품고 있던 저는 온라인에서 대안 소스를 찾기 시작했고 다음과 같은 것을 알게 되었어요:\n\n- 런던 교통 (TfL)도 분실물 품목을 청구하기 위한 좋은 서비스를 갖고 있어요.\n- 영국에는 공공 당국이 보유한 정보에 대한 공공 \"접근 권리\"를 만드는 정보의 자유법이 있어요. 모든 사람은 무료로 요청을 제기할 권리가 있으며 20일 이내에 응답을 받을 수 있어요. 그래서 가능하다면 TfL에게 \"분실 물품의 원시 데이터\"가 담긴 CSV 파일을 보내달라고 요청했고 2~3주 후에 (약속된 것처럼 빠르지 않았지만:) 파일을 받을 수 있었어요. 또한 TfL에게 이 데이터를 제 TDS 출판물에 사용할 수 있는지 물어봤고 긍정적인 답변을 받았죠.\n\n이것은 좋은 서비스인 것 같아요 (그런데 미국은 1967년 이후로 비슷한 법을 가지고 있어요) 그리고 과학자와 데이터 애호가들에게 연구에 공개 데이터를 활용할 수 있는 좋은 기회인 것 같아요. 그러니 말이 많지 않게, 우리가 어떤 정보를 얻을 수 있는지 한번 살펴봅시다. 원본 파일을 얻어 결과를 재현하고 싶은 분들은 아래에 댓글을 남겨주시면 링크를 공유해드릴게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 데이터 로딩\n\n우선 데이터를 로드하고 차원 및 유형을 확인해봅시다:\n\n```python\nimport pandas as pd\n\ndf = pd.read_csv(\"tfl.csv\")\ndisplay(df.head())\ndisplay(df.info(verbose=True)\n```\n\n출력 결과는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 변경하면 다음과 같습니다:\n\n![Exploratory Data Analysis Lost Property Items on the Transport of London](/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_1.png)\n\n아래에서 볼 수 있듯이 총 5245개의 항목이 있고 데이터프레임에는 NULL 항목이 없습니다. 날짜 형식이 표준이 아닌 것으로 보이므로 변환해보겠습니다:\n\n```python\ndf[\"Date Found\"] = pd.to_datetime(df[\"Date Found\"], format=\"%d/%m/%Y\")\n```\n\n다음 단계로 어떤 종류의 카테고리가 있는지 알아보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndisplay(df[\"Category\"].unique());\n```\n\n위 결과에서 숫자가 그리 크지 않다는 것을 보여줍니다:\n\n```js\narray(\n  [\n    \"Bags\",\n    \"Electronics \u0026 Technology\",\n    \"Wallets \u0026 Purses\",\n    \"Baby \u0026 Nursery\",\n    \"ID \u0026 Personal Documents\",\n    \"Health \u0026 Beauty\",\n    \"Tools / Garden / DIY\",\n    \"Jewellery\",\n    \"Travel Cards \u0026 Ticket\",\n    \"Household \u0026 General Items\",\n    \"Keys\",\n    \"Sports \u0026 Leisure\",\n    \"Eyewear\",\n    \"Currency (cash)\",\n    \"Stationery \u0026 Books\",\n    \"Clothing\",\n    \"Financial Documents\",\n  ],\n  (dtype = object)\n);\n```\n\n시각화를 더 잘 보이게 하기 위해 \"Electronics \u0026 Technology\" 카테고리를 \"Electronics\"로 변경하고 모든 \"Document\" 카테고리를 한 가지로 결합하기로 결정했습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndef update_category(name: str) -\u003e str:\n    \"\"\"카테고리 이름 업데이트\"\"\"\n    if \"문서\" in name:\n        return \"문서\"\n    if \"전자제품\" in name:\n        return \"전자제품\"\n    return name\n\ndf[\"Category\"] = df[\"Category\"].map(update_category)\n```\n\n날짜와 카테고리 변환을 마친 후, 최종 데이터프레임은 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_2.png\" /\u003e\n\n## 하루 평균 아이템\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 재미를 봐봅시다. 모든 항목을 날짜별로 그룹화하고 막대 차트를 그려봅시다:\n\n```js\nimport plotly.express as px\n\ngr_day = df[[\"Date Found\"]].groupby([\"Date Found\"], as_index=False).size()\n\nfig = px.bar(gr_day, x=\"Date Found\", y=\"size\",\n             title=\"\u003cspan style='font-size:18px;'\u003e\u003cb\u003eTfL, Lost Items Per Day\u003c/b\u003e\u003c/span\u003e\u003cb\u003e\u003c/b\u003e\",\n             width=1280, height=500)\nfig.update_xaxes(tickformat=\"%a, %d-%m-%Y\", showline=True, linecolor=\"black\")\nfig.update_layout(xaxis_title=None, yaxis_title=None, plot_bgcolor=\"#F5F5F5\",\n                  margin=dict(l=50, r=50, t=30, b=50))\nfig.show()\n```\n\n여기서는 오픈 소스 라이브러리 Plotly를 사용하여 차트를 작성했습니다. 이 라이브러리는 plotly.js를 기반으로 하므로 HTML 형식을 사용하여 스타일을 변경할 수 있습니다. 또한 출력물은 대화형이기 때문에 노트북에서 이미지를 바로 확대 또는 이동할 수 있습니다.\n\n출력물은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_3.png)\n\n이 결과를 보면 대중교통에서 물건을 분실할 확률을 계산하는 것이 흥미로울 것 같아요. 이 특정 날짜의 승객 수는 정확히 모르지만, 일반적으로 런던의 대중교통은 하루에 약 600만 명의 승객을 처리한다는 것을 알고 있습니다. 그래프에서 볼 수 있듯이, 분실 물품의 수는 꽤 일정합니다. 간단한 계산을 통해 대중교통에서 물건을 분실할 확률이 약 0.01% 정도라는 것을 알 수 있습니다. 이 값 자체는 크지 않지만, 매일 적어도 10,000 명의 사람 중 한 명은 이러한 사건을 겪을 수 있습니다.\n\n또 다른 흥미로운 발견은 목요일에 뾰족한 부분이 있습니다. 왜 이렇게 발생하는지는 모르겠지만, 다른 TfL 보도자료에서도 목요일을 가장 많은 승객이 있는 날로 언급했어요. 이에 대한 사회적 설명이 있는지 알지 못하지만, 흥미롭게 보입니다.\n\n## 카테고리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 단계로 카테고리와 하위 카테고리별로 모든 상품을 그룹화해 보겠습니다:\n\n```js\ngr_cat = df[[\"Category\", \"Sub-Category\"]]\n  .groupby([\"Category\", \"Sub-Category\"], (as_index = False))\n  .size();\n```\n\n다양한 종류의 시각화를 시도해 보았고, 그 중에서도 가장 유익하다고 생각되는 두 가지를 소개하겠습니다. 먼저, 2차원 원형 차트와 같은 선버스트 차트를 그려보겠습니다:\n\n```js\nfig = px.sunburst(\n  gr_cat,\n  (width = 1280),\n  (height = 800),\n  (path = [\"Category\", \"Sub-Category\"]),\n  (values = \"size\"),\n  (color = \"Category\"),\n  (title =\n    \"\u003cspan style='font-size:18px;'\u003e\u003cb\u003eTfL, Lost Items Chart\u003c/b\u003e\u003c/span\u003e\u003cb\u003e\u003c/b\u003e\")\n);\nfig.update_layout(\n  (font_size = 10),\n  (margin = dict((l = 10), (r = 10), (t = 30), (b = 50)))\n);\nfig.update_traces((textinfo = \"label+percent parent\"));\nfig.show();\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음처럼 출력됩니다:\n\n![이미지](/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_4.png)\n\n다양한 세그먼트를 쉽게 비교할 수 있습니다. 예를 들어, “가방”과 “전자제품”이 “유실 차트”의 상단에 있음을 확인할 수 있습니다(각각 19%와 15%). “가방” 카테고리에서는 승객들이 가장 자주(36%) 배낭을 잃어버립니다. 이는 배낭을 가지고 서거나 앉는 것이 불편하고, 사람들이 벗어 두기 때문에 이해할 수 있습니다. “전자제품” 카테고리에서는 모바일 폰이 가장 많습니다(58%). 다른 카테고리에서는 10%의 불운한 승객이 문서를 분실했고, 4%가 열쇠를 분실했습니다.\n\n선셋 차트가 흥미로워 보이지만, 좁은 세그먼트를 읽기 어려울 수 있습니다. 다른 대안은 트리맵 차트입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfig = px.treemap(gr_cat, width=1280, height=800,\n                 path=['Category', 'Sub-Category'], values='size',\n                 color='Category')\nfig.update_traces(textinfo=\"label+percent parent\")\nfig.show()\n```\n\n위의 코드를 실행하면 이와 같은 출력물이 나옵니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_5.png\" /\u003e\n\n이 경우, 마우스를 호버하여 작은 하위 카테고리의 데이터를 쉽게 읽을 수 있습니다. 반면, 파이 차트를 사용하면 다른 카테고리 간의 상대적인 크기를 더 쉽게 이해할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 하위 카테고리\n\n\"전자제품\" 카테고리를 자세히 살펴보겠습니다. 이를 위해 데이터프레임을 필터링하고, 모든 항목을 하위 카테고리별로 그룹화하여 막대 그래프를 그릴 수 있습니다:\n\n```js\ndf_ = df[df[\"Category\"] == \"전자제품\"];\ngr_electronics = df_[[\"하위 카테고리\"]]\n  .groupby([\"하위 카테고리\"], (as_index = False))\n  .size()\n  .sort_values((by = \"size\"), (ascending = True));\n\nfig = px.bar(\n  gr_electronics,\n  (width = 1280),\n  (height = 600),\n  (title =\n    \"\u003cspan style='font-size:18px;'\u003e\u003cb\u003eTfL, 분실물 주간별 전자제품\u003c/b\u003e\u003c/span\u003e\u003cb\u003e\u003c/b\u003e\"),\n  (x = \"size\"),\n  (y = \"하위 카테고리\"),\n  (orientation = \"h\")\n);\nfig.update_layout(\n  (xaxis_title = \"수량\"),\n  (yaxis_title = None),\n  (plot_bgcolor = \"#F5F5F5\"),\n  (margin = dict((l = 50), (r = 50), (t = 30), (b = 50)))\n);\nfig.show();\n```\n\n여기에서는 라벨을 읽기 쉽게하기 위해 가로 막대 차트를 사용했습니다. 결과는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_6.png)\n\n우리가 볼 수 있듯이, 대부분의 승객이 핸드폰이나 핸드폰 액세서리를 분실한 것이 분명합니다. 어떤 사람들은 노트북, 태블릿 또는 e-리더를 분실했으며, 한 명의 승객이 MP3 플레이어를 분실했습니다(요즘에는 조금 특이한 장치입니다). 놀랍게도 숫자가 상당히 많습니다. 데이터 집합은 일주일 동안의 데이터를 나타내며, 우리가 보기로는 이 기간 동안 총 467명의 승객이 핸드폰을 분실했습니다.\n\n## 위치\n\n간단한 연습으로 데이터를 위치별로 그룹화하고 어떤 물품이 발견된 상위 10곳을 확인해 봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngr_location = df[[\"Location\"]].groupby(['Location'], as_index=False).size().sort_values(by=\"size\", ascending=False)\ndisplay(gr_location[:10])\n```\n\nThe output looks like this:\n\n![Map Image](/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_7.png)\n\nI have been to London several times, but my knowledge of London stations is not that good. Let’s draw all locations on the map, so it will be easier to see the places. I will use a Python geopy library to get the coordinates:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom geopy.geocoders import Nominatim\n\ngeolocator = Nominatim(user_agent=\"Python3.9\")\n\n@lru_cache(maxsize=None)\ndef get_coord_lat_lon(full_addr: str) -\u003e Tuple[float, float]:\n    \"\"\" Get coordinates for address \"\"\"\n    pt = geolocator.geocode(full_addr + \", London, UK\")\n    return (pt.latitude, pt.longitude) if pt else (None, None)\n```\n\n여기서는 여러 번 코드를 실행하고 싶을 때 도움이 될 수 있는 lru_cache 데코레이터를 사용했어요. 데이터는 새로운 API 호출 대신 캐시에서 가져옵니다. 또한 처리 중에 진행률 표시줄을 볼 수 있게 해주는 tqdm Python 라이브러리를 사용했어요. 이는 처리가 몇 분 정도 걸리기 때문에 유용해요.\n\n처리가 완료된 후에 데이터프레임은 다음과 같이 보입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![map](/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_9.png)\n\nNow, we're ready to draw a map. I will use the folium Python library for that:\n\n```python\nimport folium\nfrom branca.element import Figure\n\nfig = Figure(width=1024, height=600)\nfmap = folium.Map(location=(51.5, -0.104), tiles=\"openstreetmap\", zoom_start=12)\n\nfor _, row in gr_location.iterrows():\n    point = row[\"Coordinates\"]\n    name, amount = row[\"Location\"], row[\"size\"]\n    if point[0] is not None or point[1] is not None:\n        add_to_map(fmap, name, point, amount)\n\nfig.add_child(fmap)\ndisplay(fig)\n```\n\nI also created `add_to_map` and `value_to_color` methods, which help to add a station to the map:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef value_to_color(value: int) -\u003e str:\n    \"\"\" 값을 HTML 색상으로 변환합니다 \"\"\"\n    norm = matplotlib.colors.Normalize(vmin=0, vmax=255, clip=True)\n    mapper = colormap.ScalarMappable(norm=norm, cmap=colormap.inferno)\n    r, g, b, _ = mapper.to_rgba(value, alpha=None, bytes=True)\n    return \"#\" + f\"{(r \u003c\u003c 16) + (g \u003c\u003c 8) + b:#08x}\"[2:]\n\n\ndef add_to_map(fmap: folium.Map, name: str,\n               location: Tuple[float, float],\n               value: int):\n    \"\"\" 지도에 점을 추가합니다 \"\"\"\n    color_str = value_to_color(value)\n    folium.Circle(\n        location=location,\n        radius=10*value//2,\n        popup = name + \": \" + str(value),\n        color=color_str,\n        fill=True,\n        fill_color=color_str\n    ).add_to(fmap)\n```\n\n결과는 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_10.png\" /\u003e\n\n이 지도는 물건이 발견된 장소를 보여줍니다. 물건을 분실한 장소에 대해서는 알 수 없습니다 (특히 빠르게 이동하는 기차에서), 하지만 결과를 보는 것은 여전히 흥미로울 것입니다. 지도의 가장 큰 원들은 마지막 기차나 버스 정류장인 것으로 보입니다. 그러나 다른 역에서도 많은 물건들이 발견되었습니다. 독자들은 색상 맵 (제가 \"Inferno\" 팔레트를 사용했습니다) 및 원 크기와 같은 매개변수를 변경하여 더 나은 시각화를 얻을 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n본 글에서는 공식 기관에게 공공 데이터를 요청하는 가능성과 이를 분석하여 런던 교통 수단에서 잃어버린 물품에 대한 흥미로운 결과를 얻을 수 있었습니다. 일반적으로 대중에게 공공 정보에 액세스할 수 있는 기회를 제공하는 것은 연구원과 데이터 애호가들이 흥미로운 데이터 조각을 찾는 데 도움이 되는 좋은 아이디어입니다. 어쨌든 통계는 우리에 관한 과학이죠. 결과적으로, 대중 교통에서 무언가를 분실할 확률은 0.01%에 해당한다는 것을 알 수 있었고, 앞으로 이 통계의 일부로 포함되지 않기를 바라며 모든 독자분들께 간청합니다 ;)\n\n사회 데이터 분석에 관심 있는 분들은 다음 기사들도 읽어보세요:\n\n- 데이터 탐색적 분석: 유튜브 채널에 대해 우리가 아는 것은 무엇인가\n- 독일 주택 임대 시장: Python으로 수행하는 데이터 탐색적 분석\n- 기후에 관해 사람들이 무엇을 쓰는지: Python에서 트위터 데이터 클러스터링\n- 트위터 글에서 시간적인 패턴 찾기: Python을 사용한 데이터 탐색적 분석\n- Python 데이터 분석: 팝송에 대해 우리가 아는 것은 무엇인가?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 이야기를 즐겼다면 Medium을 구독해보세요. 그러면 새 글이 올라올 때 알림을 받을 수 있을 뿐만 아니라 다른 작가들의 수천 개 이야기에도 완전한 액세스 권한을 얻을 수 있어요. LinkedIn을 통해 연락하셔도 좋고요. 이와 다른 포스트들의 전체 소스 코드를 얻고 싶으시다면 제 Patreon 페이지를 방문해주세요.\n\n읽어주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_0.png"},"coverImage":"/assets/img/2024-05-20-ExploratoryDataAnalysisLostPropertyItemsontheTransportofLondon_0.png","tag":["Tech"],"readingTime":16},{"title":"파이썬에서 데이터 시각화 기술과 코드 예제","description":"","date":"2024-05-20 18:34","slug":"2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples","content":"\n데이터 시각화는 데이터에서 통찰을 얻고 전달하는 데 강력한 도구입니다. 이 기사에서는 Python을 사용하여 타이타닉 데이터셋을 중심으로 다양한 데이터 시각화 기법을 탐색하겠습니다. Matplotlib 및 Seaborn과 같은 인기있는 라이브러리를 사용하여 유의미한 시각화를 만들 것입니다. 추가적으로, 모든 플롯에는 시각적 명확성과 일관성을 높이기 위해 빨간색을 사용할 것입니다.\n\n![image](/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_0.png)\n\n## 데이터셋 소개\n\n타이타닉 데이터셋은 다양한 데이터 분석 및 기계 학습 작업에 사용되는 고전적인 데이터셋입니다. 타이타닉호 승객에 대한 정보를 포함하며 그들의 인구 통계, 티켓 등급, 요금 및 생존 상태에 대한 정보가 포함되어 있습니다. 타이타닉 데이터셋을 로드하고 구조를 간단히 살펴보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# 타이타닉 데이터셋 불러오기\ntitanic = sns.load_dataset('titanic')\n```\n\n# 1. 숫자 변수에 대한 히스토그램\n\n히스토그램은 숫자 변수의 분포를 시각화하는 데 유용합니다. 나이와 요금에 대한 히스토그램을 그려보겠습니다:\n\n```python\n# 나이에 대한 히스토그램 그리기\nplt.figure(figsize=(8, 6))\nsns.histplot(titanic['age'].dropna(), bins=30, kde=True, color='red')\nplt.title('나이 분포')\nplt.xlabel('나이')\nplt.ylabel('빈도')\nplt.show()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_1.png\" /\u003e\n\n```js\n# 요금에 대한 히스토그램 작성\nplt.figure(figsize=(8, 6))\nsns.histplot(titanic['fare'], bins=30, kde=True, color='blue')\nplt.title('요금 분포')\nplt.xlabel('요금')\nplt.ylabel('빈도')\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_2.png\" /\u003e\n\n히스토그램을 통해 승객들의 나이와 요금 분포에 대한 통찰을 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. 범주형 변수에 대한 막대 플롯\n\n막대 플롯은 범주형 변수의 분포를 시각화하는 데 효과적입니다. 탑승객 클래스와 생존 상태에 대한 막대 플롯을 그려보겠습니다:\n\n```js\n# 승객 클래스에 대한 막대 플롯 그리기\nplt.figure(figsize=(6, 4))\nsns.countplot(x='class', data=titanic, color='red')\nplt.title('승객 클래스 분포')\nplt.xlabel('클래스')\nplt.ylabel('수')\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_3.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 생존 상태에 대한 막대 그래프 플롯하기\n\nplt.figure(figsize=(8, 6))\nsns.countplot(x='survived', data=titanic, color='red')\nplt.title('생존 상태 분포')\nplt.xlabel('생존 상태')\nplt.ylabel('카운트')\nplt.show()\n\n![이미지](/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_4.png)\n\n막대 그래프는 승객들이 다른 클래스 및 생존 상태에 분포된 정보를 제공합니다.\n\n# 3. 아웃라이어 감지를 위한 상자 그림(Box Plot)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상자 수염 도표는 이상치를 감지하고 숫자 변수의 분포를 시각화하는 데 유용합니다. 나이와 요금에 대한 상자 수염 도표를 그려보겠습니다:\n\n```js\n# 나이에 대한 상자 수염 도표 그리기\nplt.figure(figsize=(8, 6))\nsns.boxplot(x='age', data=titanic, color='red')\nplt.title('나이 분포 (상자 수염 도표)')\nplt.xlabel('나이')\nplt.show()\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_5.png\" /\u003e\n\n```js\n# 요금에 대한 상자 수염 도표 그리기\nplt.figure(figsize=(8, 6))\nsns.boxplot(x='fare', data=titanic, color='green')\nplt.title('요금 분포 (상자 수염 도표)')\nplt.xlabel('요금')\nplt.show()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Box plots](/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_6.png)\n\nBox plots는 이상값을 식별하고 연령 및 요금의 분포를 이해하는 데 도움이 됩니다.\n\n# 결론\n\n데이터 시각화는 데이터로부터 통찰력을 얻고 발견한 결과를 효과적으로 전달하는 데 중요합니다. 이 기사에서는 Matplotlib 및 Seaborn과 같은 Python 라이브러리를 사용하여 다양한 데이터 시각화 기술을 살펴보았습니다. 숫자형 및 범주형 변수의 분포를 시각화하고 이상값을 감지하며 Titanic 데이터셋에 대한 통찰력을 얻었습니다. 모든 플롯에 대해 빨간색을 사용함으로써 시각적 명확성과 시각화의 일관성을 보장했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n복잡한 데이터셋을 이해하고 정보를 얻기 위해서는 효과적인 데이터 시각화가 필수적입니다. 데이터에서 숨겨진 패턴과 관계를 발견하기 위해 다양한 시각화 기술을 실험해보세요.\n\n향후 기사에서는 고급 시각화 기술에 대해 더 깊이 파고들고 더 복잡한 데이터셋을 탐색할 것입니다. 더 많은 통찰력 있는 콘텐츠를 기대해 주세요!\n\n# Python Fundamentals\n\n소중한 시간과 관심에 감사드립니다! 🚀\nPython Fundamentals에서 더 많은 콘텐츠를 찾아보실 수 있습니다. 💫\n","ogImage":{"url":"/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_0.png"},"coverImage":"/assets/img/2024-05-20-DataVisualizationTechniquesinPythonwithCodeExamples_0.png","tag":["Tech"],"readingTime":6},{"title":"아름다운 지도를 만들기 위한 6가지 파이썬 라이브러리","description":"","date":"2024-05-20 18:32","slug":"2024-05-20-6pythonlibrariestomakebeautifulmaps","content":"\n![image](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_0.png)\n\n어느 순간 모든 데이터 과학자는 지리 공간 데이터를 분석하거나 모델링할 필요에 직면하게 되며, 결정적인 시각적 부분 없이는 수행할 수 없습니다. 저는 지도를 좋아하는 사람이라서, 여기에서 정보를 제공하게 된 이 6가지 멋진 라이브러리를 공유해 주어 기쁩니다. 여기에서 공유하는 라이브러리들 중 일부는 정적 시각화에 더 적합하고, 다른 것들은 대화식 시각화에 더 적합하기 때문에 해결할 수 있는 문제 범위가 넓습니다.\n\n# 1. Cartopy\n\n![image](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCartopy는 스칼라 또는 폴리곤 데이터를 사용하여 정적 지도를 그리는 데 완벽한 강력한 잘 알려진 라이브러리입니다. 땅, 물 및 행정 국경에 많은 내장된 레이어를 제공합니다. 매우 쉽게 사용할 수 있으며 직관적인 명령어 세트가 있습니다.\n\n예를 들어, MODIS 데이터를 시각화해 보겠습니다. 함께 따라오고 싶다면 코드를 여기에서 찾을 수 있습니다.\n\n패키지를 설치하려면 다음과 같이 pip로 정규 표현식을 사용할 수 있습니다:\n\n```js\n!pip install cartopy\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 데이터를 로드해 봅시다:\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlats = np.load('lats.npy')\nlons = np.load('lons.npy')\ndata = np.load('data.npy')\n```\n\n그 후에 데이터를 바로 플롯할 수 있어요:\n\n```js\nproj = ccrs.PlateCarree() #지도 투영을 설정해 봅시다\n\nfig, ax = plt.subplots(subplot_kw=dict(projection=proj), figsize=(10, 20))#미리 설정한 투영과 크기를 가진 figure를 생성해야 해요\n\nax.set_extent([-160, -105, 40 ,70], crs=ccrs.PlateCarree())#MODIS 제품 지역만 포함하도록 좌표를 제한합시다\n\nplt.contourf(lons, lats, data,\n             transform=ccrs.PlateCarree(), cmap = 'summer') #matplotlib을 사용하여 데이터의 등고선을 추가합시다\n'''좋은 cartopy 기능 추가하기'''\nax.add_feature(cfeature.BORDERS, edgecolor='black', linewidth=1)\nax.add_feature(cfeature.LAKES,  alpha=0.5)\nax.add_feature(cfeature.LAND)\nax.add_feature(cfeature.COASTLINE, edgecolor='black', linewidth=1)\nax.add_feature(cartopy.feature.RIVERS, edgecolor='blue', linewidth=0.5)\nstates_provinces = cfeature.NaturalEarthFeature(\n            category='cultural',  name='admin_1_states_provinces',\n            scale='10m', facecolor='none')\nax.add_feature(states_provinces, edgecolor='black', zorder=10, linestyle = '-', linewidth=0.5)\n\n\nax.gridlines(draw_labels=True)#그리드 형식 지정\n\nlon, lat = -122.8414, 55.1119\nax.plot(lon,lat,  'bo', markersize=6, color = 'red', transform=ccrs.Geodetic())#지도에 임의의 마커 추가하기\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_2.png)\n\n위 결과에서 알 수 있듯이, cartopy는 맵을 사용자 정의하는 다양한 방법을 제공합니다. 색상, 선 두께, 밀도 및 레이어의 다른 매개변수를 수동으로 설정할 수 있습니다. 게다가 코드 자체가 정말 직관적이고 이해하기 쉽습니다.\n\n이 라이브러리의 또 다른 큰 장점은 사용할 수 있는 다양한 투영법들인데, cartopy를 사용하여 시각화할 수 있는 데이터 범위가 매우 넓습니다!\n\n![Image 2](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Python libraries to make beautiful maps](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_4.png)\n\nCartopy is one of the tools I regularly use in my work, and I hope that you’ll find it extremely helpful as well!\n\n## 2. Folium\n\nThis library is probably the most popular in the industry, since it’s interactive (it has JS under the hood) and highly customizable. And to start plotting (after installation) you can simply call:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nimport folium\nmap = folium.Map(location=(50, 0), zoom_start=8) # 위치 - 맵의 중앙, 확대 수준 - 해상도\nmap\n\n![이미지](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_5.png)\n\n다른 기본 타일 또는 사용자 정의 타일을 사용할 수 있습니다:\n\nmap = folium.Map(location=(50, 0), zoom_start=8, tiles=\"Cartodb Positron\")\nmap\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_6.png)\n\n이제 세계 국가들을 추가해보겠습니다. 그러려면 기본 geopandas 데이터프레임을 사용할 거에요:\n\n```python\nimport geopandas as gpd\ndf = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))\n\nmap = folium.Map(zoom_start=4, tiles=\"Cartodb Positron\")\ngdf_json = df.to_json()\n\nfolium.GeoJson(gdf_json).add_to(map)\nmap\n```\n\n![image](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. Plotly\n\nPlotly는 아름다운 대화형 차트로 유명한 또 다른 라이브러리입니다. 다양한 기능 중에는 px.choropleth, px.choropleth_mapbox, px.scatter_mapbox, px.scatter_geo 등의 지도를 그리는 여러 함수가 있습니다. 더 자세한 내용은 [여기](https://plotly.com/python/)에서 확인할 수 있습니다.\n\n실제로 같은 지리 데이터셋을 사용하여 gdp_md_est 변수를 시각화해 보겠습니다. 다음 코드 몇 줄로 쉽게 수행할 수 있습니다:\n\n```python\nimport plotly.express as px\n\nfig = px.choropleth(df, locations='iso_a3', hover_name='name',\n                    color='gdp_md_est',\n                    projection='natural earth')\nfig.show()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*XGb8bY8LL26sKv2Wmkb-AQ.gif)\n\n# 4. ipyleaflet\n\n네 소개할 라이브러리는 'ipyleaflet'입니다. 이것은 상호작용형 지도를 만들기 위한 또 다른 훌륭한 JS 기반 라이브러리입니다. 이 패키지가 좋은 이유 중 하나는 타일의 종류가 많다는 것이에요. 그러니 기본적인 것부터 시작해봅시다:\n\n```js\nfrom ipyleaflet import Map\n\nm = Map(center=(45, 2), zoom=5)\nm\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_8.png)\n\n별 거 없죠? 그럼 이제 MODIS Terra 제품을 배경지도로 사용해 봅시다!\n\n```js\nm = Map(\n  (basemap = basemap_to_tiles(\n    basemaps.NASAGIBS.ModisTerraTrueColorCR,\n    \"2023-08-08\"\n  )),\n  (center = (45, 2)),\n  (zoom = 5)\n);\nm;\n```\n\n![image](/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_9.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nVIIRS 데이터를 사용하여 밤에 지구를 시각화할 수도 있어요:\n\n```js\nm = Map(\n  (basemap = basemaps.NASAGIBS.ViirsEarthAtNight2012),\n  (center = (45, 2)),\n  (zoom = 5)\n);\nm;\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_10.png\" /\u003e\n\n다른 옵션들도 함께 살펴보세요! 옵션이 많이 있답니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 실제 데이터를 시각화해 봅시다. 발견한 라이브러리 중 가장 인상적인 기능 중 하나는 속도 시각화입니다. 이를 위해 1° 해상도를 가진 NCEP(WMC) 예측 데이터를 사용할 수 있습니다. 해당 데이터셋은 2016년 4월 30일 06:00에 가져와졌고, ipyleaflet 라이브러리의 문서에서 제공되었습니다. 이를 읽기 위해 netCDF4 파일을 읽는 데 적합한 xarray를 사용할 것입니다.\n\n```js\nfrom ipyleaflet.velocity import Velocity\nimport xarray as xr\nimport os\nimport requests\n\nif not os.path.exists('wind-global.nc'):\n  url = 'https://github.com/benbovy/xvelmap/raw/master/notebooks/wind-global.nc'\n  r = requests.get(url)\n  wind_data = r.content\n  with open('wind-global.nc', 'wb') as f:\n      f.write(wind_data)\n\nm = Map(center=(45, 2), zoom=4, interpolation='nearest', basemap=basemaps.CartoDB.DarkMatter)\n\nds = xr.open_dataset('wind-global.nc')\n\nwind = Velocity(data=ds,\n                zonal_speed='u_wind',\n                meridional_speed='v_wind',\n                latitude_dimension='lat',\n                longitude_dimension='lon',\n                velocity_scale=0.01,\n                max_velocity=20)\nm.add(wind)\n\nm\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*ImNN4p5UxlISf-p22XbGGQ.gif\" /\u003e\n\n보시다시피 결과물은 단순히 상호작용형 지도가 아니라 애니메이션 지도입니다. 그렇기 때문에 데이터의 표현력을 향상시키고 데이터가 말하도록 만들어 줍니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. geemap\n\nGeemap은 Google Earth Engine과 통합된 대화식 맵핑을 위한 패키지입니다. 따라서 Python GEE 패키지인 ee 라이브러리와 함께 사용할 때 매우 편리합니다.\n\n데모로 북유럽 한 섬에서 Dynamic World 제품의 토지 피복 데이터를 수집해 보겠습니다:\n\n```js\nimport ee\n\n반지름 = 1250\n지점 = ee.Geometry.Point([19.9, 60.2])\nroi = 지점.buffer(반지름) # 관심 지점 주변에 원 만들기\n\nDW = ee.ImageCollection(\"GOOGLE/DYNAMICWORLD/V1\")\\\n                  .filterDate(start = '2022-07-08', end='2022-08-30')\\\n                  .filterBounds(roi) # 데이터 가져오기\nDW_list = DW.toList(DW.size()) # 데이터를 GEE 리스트로 변환\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 그래픽 플로팅을 할 수 있어요:\n\n```js\nm = geemap.Map(center=[60.2, 19.9], zoom=14)\n\nm.add_basemap('HYBRID') # Sentinel-2 이미지 레이어를 추가하고 있어요\nviz_params = {'bands':'label', 'min':0, 'max':8,\n'palette':['419bdf',\n    '397d49',\n    '88b053',\n    '7a87c6',\n    'e49635',\n    'dfc35a',\n    'c4281b',\n    'a59b8f',\n    'b39fe1']}\nm.add_ee_layer(ee.Image(DW_list.get(9)), viz_params) # 구름 커버리지가 낮은 이미지 №9를 추가하였어요\nm.add_legend(title=\"Dynamic World Land Cover\", builtin_legend='Dynamic_World')\ndisplay(m)\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*Rj0DI3lXmhlSdmRK7IiRKg.gif\" /\u003e\n\ngeemap은 GEE와 함께 사용하기 훌륭한 도구라고 생각해요. 다양한 기능을 제공하여 다양한 작업을 해결할 수 있어요. 주요하고 유일한 단점은 사용자 친화적이지 않다는 점이에요. geemap을 사용하기 전에 ee 라이브러리 문법을 알아야 하고, GEE가 어떻게 작동하는지 일반적으로 이해해야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. ridgemap\n\n이 라이브러리는 마지막이자 정말로 제가 가장 좋아하는 라이브러리입니다. 왜냐하면 이 라이브러리를 사용하면 예술작품 같은 독특한 플롯을 만들 수 있기 때문이죠.\n\n그래프를 그리기 전에 두 라이브러리를 설치해보겠습니다:\n\n```js\n!pip install ridge_map mplcyberpunk\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 맵을 만들어 봅시다:\n\n```js\nimport matplotlib.pyplot as plt\nfrom ridge_map import FontManager, RidgeMap\nimport ridge_map as rm\nimport mplcyberpunk\nimport matplotlib.font_manager as fm\n\nplt.style.use(\"cyberpunk\")\nplt.rcParams[\"figure.figsize\"] = (16,9)\n\nfm = FontManager('https://github.com/google/fonts/blob/main/ofl/arbutusslab/ArbutusSlab-Regular.ttf?raw=true')\n\nr = RidgeMap(bbox=(-15, 32, 45,90), font=fm.prop) # 맵 생성\n\nvalues = r.get_elevation_data(num_lines=200) # 고도 데이터 가져오기\nvalues = r.preprocess(values=values, # 하이퍼파라미터 설정\n   water_ntile=70,\n   vertical_ratio=40,\n   lake_flatness=3)\n\nr.plot_map(values, label=\"Europe\", label_x=0.4,label_y=-0.05, label_size=60, line_color=plt.get_cmap('inferno'), background_color=\"#212946\")\nmplcyberpunk.add_glow_effects() # 빛나는 효과 추가\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_11.png\" /\u003e\n\n내 의견으로는 이것이 정말 멋지네요! 이 라이브러리를 확인하고 다른 시각화를 찾아보고 자신만의 시각화를 올려보세요 :)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나중에 이 라이브러리들이 유용하고 당신의 도구상자에 포함할 가치가 있다고 느끼길 바랍니다.\n\n지도를 만드는 데 사용하는 라이브러리는 무엇인가요? 댓글로 공유해주세요👇\n\n===========================================\n\n부. (지리)데이터 과학, 머신러닝/인공지능, 기후 변화에 열정적입니다. 그래서 어떤 프로젝트에서 함께 일하고 싶다면 여기나 LinkedIn에서 연락주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 많은 내용을 보려면 팔로우해주세요! 🚀🌌\n","ogImage":{"url":"/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_0.png"},"coverImage":"/assets/img/2024-05-20-6pythonlibrariestomakebeautifulmaps_0.png","tag":["Tech"],"readingTime":14},{"title":"파이썬 패키지 Yellowbrick와 PiML으로 소중한 데이터와 모델 통찰력 발견하기 코드 포함","description":"","date":"2024-05-20 18:29","slug":"2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode","content":"\n\u003cimg src=\"/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_0.png\" /\u003e\n\n안녕하세요! 이 기사에서는 Yellowbrick와 PiML의 Python 패키지가 데이터 전문가가 데이터와 모델을 더 잘 이해할 수 있도록 도와주는 방법을 탐구할 것입니다. 다양한 데이터 및 모델 품질 문제에 대처하고 있습니다. LLM들의 시대에 여전히 중요한 이유들은 다음과 같습니다: (a) 데이터와 모델에 대한 강력한 시각적 통찰을 제공한다, (b) 모델 성능 분석 영역에서 교육 도구로 사용될 수 있다, (c) 비용과 자원 측면에서 효율적이며, (d) 데이터 프라이버시를 제공한다. 모든 교육 및 시각화는 데이터를 클라우드 기반 서버로 이전하지 않고도 내부에서 이뤄질 수 있습니다.\n\n다음은 토론할 주제들입니다:\n\n- 분류 작업에 충분한 훈련 데이터 크기인지\n- 특정 매개변수 튜닝이 분류 성능에 어떻게 영향을 주는지 시각화\n- 군집 알고리즘 성능을 클러스터 중첩 및 클러스터 거리 측면에서 시각화. 클래스 간 특징 분포 시각화.\n- 다섯 가지 다른 측정 방법을 사용한 모델 성능 비교\n- 전역 및 지역 해석가능성\n- 모델의 약한 조각 식별\n- 모델 신뢰성 분석\n- 모델 견고성 분석\n- 모델 분할 진단 분석\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# A. 옐로브릭\n\n## A.1 분류\n\n옐로브릭의 기능을 탐색하기 위해 잘 알려진 공개 데이터 세트 와인을 사용할 것입니다. 이 데이터 세트는 178개의 행과 13개의 열로 구성되어 있습니다. 특징은 '색상 강도', '알콜', '말산 산' 등의 다양한 와인 특성입니다. 목표 변수는 0, 1, 2로 표시된 3가지 와인 클래스로 구성되어 있습니다. 먼저 와인 데이터 세트를 사용하여 분류를 수행할 것입니다. RandomForestClassifier를 사용하여 다음과 같은 결과를 얻을 것입니다.\n\n분류 정확도가 0.97인 것을 볼 수 있습니다. 이는 높은 수준의 정확도를 나타냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nA.1.1 학습 데이터 양 충분성\n\nYellowbrick를 사용하여 모델의 학습 곡선을 플로팅하여 학습 데이터 양 충분성 문제를 해결할 것입니다. 이 곡선은 그림 1에 나타나 있습니다. 학습 곡선은 모델이 학습 데이터 양을 증가시킬 때 모델의 성능이 어떻게 변하는지 시각화합니다. 학습 곡선을 통해 우리는 다음을 이해할 수 있습니다:\n\n- 더 많은 데이터를 추가하면 모델의 일반화 능력이 향상될 수 있는지 여부.\n- 과적합/과소적합이 있는지 여부. 이는 학습 및 검증 점수가 수렴하는 방식에 따라 달라집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n학습曲선은 다음을 보여줍니다:\n\n- 훈련 점수는 모든 훈련 인스턴스에 대해 1.0에 가까운 높은 값을 유지합니다. 이는 RandomForest 모델이 훈련 데이터로부터 효과적으로 학습하는 것을 시사합니다.\n- Figure 1의 교차 검증 점수 라인을 살펴보면, 교차 검증 점수가 일정하지 않고 훈련 점수보다 낮게 시작하는 것을 볼 수 있습니다. 훈련 인스턴스 수가 증가함에 따라 일부 변동성을 보이다가 결국 훈련 점수보다 아래 수준에 안정화됩니다. 훈련과 교차 검증 사이에 뚜렷한 차이가 있으며, 이는 과적합의 지표입니다. 일반화를 향상시키기 위해 과적합을 줄이는 정규화와 같은 개선이 필요합니다.\n- 더 많은 데이터가 필요한가요? 아마도 그렇지 않습니다. 교차 검증 점수는 안정화되어 특정 훈련 인스턴스 수 이상(약 70~80)으로 진전이 없어 보입니다. 이는 더 많은 데이터를 추가해도 새로운, 보이지 않는 데이터에 대한 모델 성능이 크게 향상되지 않을 수도 있다는 것을 시사합니다.\n\nA.1.2. 특정 매개변수 조정이 분류 성능에 미치는 영향\n\n아래 코드 스니펫에서 RandomForest 분류기의 최대 트리 깊이는 값 1부터 11까지 변화합니다. 그런 다음 'max_depth' (최대 트리 깊이)가 변하는 것을 추적할 수 있도록 모델 성능 변화를 보여주는 검증 곡선 시각화기가 생성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Unlocking Valuable Data and Model Insights with Python Packages Yellowbrick and PiML with Code](/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_2.png)\n\n그림 2는 검증 곡선을 보여줍니다. 일반적으로 검증 곡선은 기계 학습에서 모델이 어떻게 수많은 하이퍼파라미터 값 범위에서 수행되는지를 평가하는 데 사용됩니다. 이 곡선은 하이퍼파라미터의 최적값을 찾는 데 도움을 주며, 그 곳은 검증 점수가 최대화되고, 훈련 및 검증 점수의 갭이 합리적인 곳입니다. 이는 우리 모델이 잘 일반화될 수 있다는 것을 의미합니다.\n\n교차 검증 점수가 'max_depth'=7에서 최대치를 보입니다. 그림 2의 이 관찰은 'max_depth'가 7로 설정할 때, 모델이 데이터에서 충분한 복잡성을 캡처하고 새로운 데이터로 일반화하기 위한 최상의 균형을 제공한다는 것을 시사합니다. 다시 말해, 이는 모델이 의미 있는 패턴을 학습하면서 너무 많은 잡음에 과적합 되지 않는 깊이입니다. 이러한 매개변수 설정으로 인해 우리는 과적합을 피하면서도 정확한 예측을 수행할만큼 충분한 세부 정보를 캡처할 수 있습니다. 매개변수 값을 7 이상으로 증가시키면 과적합으로 이어질 수 있으며, 이는 검증 점수의 플래토 또는 약간의 감소로 나타납니다.\n\n## A.2 클러스터링\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로 와인 데이터에 K-Means 클러스터링 방법을 적용하고 알고리즘 성능을 시각적으로 확인하기 위해 Yellowbrick을 활용할 것입니다. 그러나 그 전에, 볼 수 있는 게 드물지만 유용한 Yellowbrick 그래프를 사용할 것입니다. 이는 와인의 특성 분포에 관한 것입니다(도표 3). 세 가지 클래스에 대한 대부분의 특성이 서로 겹치는 것을 볼 수 있지만, '알콜'과 '프로린' 등 일부 주목할 만한 차이점이 있습니다. Shapley 분석에서도 이 두 가지 특성이 중요한지 확인하는 것이 흥미로울 것입니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_3.png\" /\u003e\n\n실제로, 아래의 도표 4에서 '알콜'과 '프로린'이 가장 중요한 세 가지 특성 중에 속합니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 클러스터링 알고리즘의 결과입니다. 아래의 내용을 보면, 클래스 1과 2에서 4개의 샘플이 잘못 분류되었지만, 전반적으로 결과는 좋습니다.\n\nYellowbrick의 도움을 받아 PCA 도메인에서 클러스터를 시각화할 것입니다. PCA 도메인에서 왜 하는지 궁금할 수 있습니다. PCA의 맥락에서 클러스터는 첫 번째 몇 개의 주요 구성 요소에 의해 정의된 공간에서 데이터 지점으로 표시됩니다. PCA는 데이터를 직교 방향으로 프로젝션하므로 원래 공간에서 겹치는 특징을 종종 분리할 수 있습니다. 와인 데이터에 대한 우리의 클러스터는 그림 5에 표시되어 있으며, 잘 분리되어 보입니다.\n\n마지막으로, Yellowbrick의 다차원 스케일링(MDS)을 사용하여 클러스터 간 거리를 시각화할 것입니다. MDS는 데이터 세트의 개별 데이터 지점의 유사성을 시각화하는 데 중점을 둡니다. 유사성 또는 상이성을 보존하므로 클러스터 간 거리를 시각화하는 데 적합한 도구입니다. 그림 6에서 세 클러스터 간에 큰 거리가 있음을 볼 수 있으며, PCA 도메인에서 명확한 클래스 분리와 일치합니다. 왼쪽 하단의 파선 원은 각 클래스에 속한 샘플 수를 나타냅니다(34: 클래스 0, 44: 클래스 1, 41: 클래스 2).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_6.png\" /\u003e\n\n# B. PiML\n\n## B.1 데이터 및 준비 단계\n\nYellowbrick가 아름다운 시각화로 사용자를 기쁘게 하듯이, PiML은 EDA부터 모델 강건성 및 신뢰성 분석, 그리고 약한 조각 식별까지 다양한 기능으로 인상을 주는 것입니다. 그러나 PiML의 기능을 논의하기 전에, 분석에 사용할 데이터 세트에 대해 알아보겠습니다. UCI Machine Learning Laboratory의 Adult 데이터 세트 또는 Census Income 데이터 세트로 알려진 이 데이터는 수입을 분류하고 50K를 초과하는지 예측하는 데 사용될 수 있습니다. 이 데이터 세트에는 48842개의 인스턴스와 14가지 피처 및 대상 수입 변수가 포함되어 있습니다. 그 피처들의 일부를 아래에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_7.png)\n\n많은 변수가 다양한 값을 갖는 범주형이기 때문에 일부 의미론적으로 유사한 값들을 병합하기 위해 feature engineering이 수행되었습니다. 우리는 [1]에서 설명된 feature engineering 예제를 따랐습니다. 'education' feature의 예시는 아래에 표시되어 있습니다.\n\nPiML은 사용자로부터 매우 적은 프로그래밍을 필요로 합니다. 모든 기능은 'Experiment' 객체를 통해 사용할 수 있습니다.\n\n한 줄로 된 코드 아래에서 PiML에서 EDA (탐색적 데이터 분석)를 하는 방법을 보여줍니다. 그리고 이것이 모든 PiML 기능에 접근하는 방법입니다: 한 줄로 된 명령어로.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 그림 7에서 나타나는 것처럼, PiML은 일변량 및 이변량 특성 분석을 수행하고 히트맵을 표시할 수 있습니다.\n\n![Figure 7](/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_8.png)\n\n- 어떤 분석을 수행하기 전에 대상 변수와 수행할 분석 유형(회귀 또는 분류)을 지정해야 합니다. 이 작업은 data_prepare() 모듈을 통해 수행됩니다.\n\n그림 8은 데이터 준비 모듈 화면을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_9.png\" /\u003e\n\n- 중요한 모델 훈련 단계입니다. 다양한 모델 중에서 선택할 수 있습니다. 아래 그림 9에서 볼 수 있듯이, 우리는 XGB1, XGB2, EBM(설명 가능한 부스팅 머신), 그리고 ReLU-DNN을 선택했습니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_10.png\" /\u003e\n\n## B.2 모델 분석\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nB.2.1 다섯 가지 숫자 측정치를 사용한 예측 성능 평가\n\nFigure 10은 선정된 모델에 대한 리더보드를 보여주며, 테스트 및 훈련 데이터셋에 대한 다섯 가지 모델 성능 지표를 보여줍니다. 이러한 지표는 (a) 정확도, (b) AUC-ROC: ROC 곡선 아래 영역, (c ) F1 점수: 정밀도와 재현율의 결합, (d) 로그 손실: 잘못된 예측에 대해 벌점을 부과하고 예측의 불확실성을 고려합니다, (e) Brier 점수: 확률 예보의 정확성을 측정하는 데 사용됩니다. 예측 신뢰도를 평가해야 할 때 특히 유용합니다. 값 범위에 대한 내용: 정확도, AUC-ROC 및 F1 점수의 경우 높은 값이 더 나은 모델 성능을 나타내고, 로그 손실 및 Brier 점수의 경우 낮은 값이 더 나은 모델 성능을 나타냅니다.\n\n따라서 리더보드는 EBM 알고리즘이 모든 다른 모델보다 모든 지표에서 테스트 및 훈련 세트에서 뛰어남을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nB.2.2 전역 및 지역 설명\n\n전역 설명에 관해, PiML은 다양한 측정치를 제공합니다: (a) 순열 피쳐 중요도, (b) 단변량 및 이변량 부분 의존도 플롯, 그리고 (c ) 누적 지역 효과. 피규어 11은 순열 피쳐 중요도 결과를 보여줍니다. '자본이익'이 가장 중요한 측정치라는 것을 알 수 있습니다. 직관적으로 이해하기 쉬운데, 과제가 50K 이상을 벌어들이는지 예측하고 싶기 때문입니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_12.png\" /\u003e\n\n지역 설명에 대해, PiML은 LIME과 SHAP을 제공합니다. 피규어 12는 LIME 결과를 보여줍니다. 여기서 '자본이익'이 상당히 긍정적인 가중치를 가지고 해당 긍정적인 효과를 갖는 것을 관찰합니다. 이는 자본이익 증가가 모델의 출력값을 긍정적으로 이동시키는 것과 강하게 관련이 있다는 것을 의미합니다. '나이' 또한 긍정적인 가중치와 효과를 가지고 있어, 나이가 높아질수록 모델 결과에 긍정적으로 기여한다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_13.png)\n\n### B.2.3 Underperforming Slices Identification\n\nIn PiML, this analysis is referred to as 'weakspot' analysis. Underperformance can result from various factors, such as data issues (bias or inadequacy) or model problems (lack of complexity, overfitting, etc.). To conduct this analysis, we utilize the model_diagnose function, which will also be used for other types of analyses in the following sections, like robustness or reliability. The code snippet below demonstrates its application for 'weakspot' analysis.\n\nLet's delve into the different parameters. When calling the model_diagnose function, the following parameters are passed:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 'model': 우리가 평가하고 싶은 모델입니다.\n- 'show': 우리가 하고 싶은 작업을 나타냅니다.\n- 'metric': 성능 메트릭입니다. 이는 위에서 논의한 다섯 가지 숫자 메트릭 중 하나일 수 있습니다.\n- 'slice_method': 데이터를 슬라이스하는 방법입니다. 히스토그램 또는 트리 중 하나일 수 있습니다.\n- 'slice_features': 슬라이스하는 데 사용할 1개 또는 2개의 특징입니다. 'marital_status' 특징을 사용할 것입니다.\n- 'threshold': 우리가 약한 지역과 좋은 지역을 구분하기 위해 사용할 성능 메트릭 '임계 비율'입니다. 우리는 기본 값 1.1을 사용할 것이며, 이는 모델 정확도 메트릭에서 10% 성능 하락에 해당합니다.\n- 'min_samples': 약한 지역으로 간주되기 위한 최소 샘플 크기를 지정합니다. 우리는 기본 값 20을 사용할 것입니다.\n- 'use_test': 이 매개변수는 훈련 데이터 또는 테스트 데이터를 사용할지를 지정합니다. 우리는 기본 값 False를 사용할 것이며, 이는 훈련 데이터를 사용할 것을 나타냅니다.\n\n약점 분석은 아래 그림 13에 나와 있으며, 두 개의 플롯으로 구성되어 있습니다.\n\n![그림 13](/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_14.png)\n\n상단 플롯은 'marital-status'의 함수로서 모델의 정확도를 나타내며, 버킷으로 분할됩니다. 단계별 함수는 'marital-status' 기능의 서로 다른 범위에서 모델의 정확도가 크게 변한다는 것을 나타냅니다. 빨간 점선은 원하는 임계 정확도를 나타냅니다. 빨간 '0' 마커는 모델의 정확도가 원하는 임계 미만인 특정 간격을 강조합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하단 플롯은 데이터셋의 특징 값 히스토그램을 보여줍니다. 색상(“임계값 이상”은 파란색, “임계값 미만”은 연한 파란색)은 각 ‘marital-status’ 범주에서의 샘플이 성적 임계값을 초과하거나 미만한 횟수를 나타냅니다.\n\n이러한 진단용 플롯은 데이터의 특정 하위 그룹에서 모델 동작을 이해하는 데 중요합니다. 마찬가지로, 오버피팅 영역을 분석하기 위해 show 매개변수를 overfit으로 설정할 수 있습니다.\n\n히스토그램 X축에 표시된 정수 값과 데이터 레이블 간의 매핑 방법에 대해 여기에 노트를 추가하고 싶습니다. 여기에 코드가 있습니다:\n\n그리고 결과는 다음과 같습니다: '0: ‘Married’, 1: ‘NotMarried’, 2: ‘Separated’, 3: ‘Widowed’'\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nB.2.4 모델 신뢰성 분석\n\n이 유형의 분석은 불확실성을 계량화하기 위해 사용되는 일치 예측 프레임워크에 기반을 두고 있습니다 [2]. 여기서 모델 신뢰성이 모델 견고성과 어떻게 다른지에 주목하는 것이 중요합니다. 이것은 다음 섹션에서 논의될 것입니다. 신뢰성은 모델이 다른 일반 운영 모드에서 전반적으로 일관성 있는지에 중점을 두며, 견고성은 모델이 입력의 변화에 대처하는 능력에 중점을 둡니다. 특히 금융 부문과 같은 동적 환경에서 신뢰성 분석은 중요합니다.\n\n아래 코드 스니펫에서 'show' 매개변수의 값이 이제 'reliability_distance'이고, 'distance_metric'이라는 새 매개변수를 PSI 값으로 정의합니다. 이 코드는 Figure 14를 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 그래프는 모델의 특성이 'Unreliable vs. Remaining Regions'간에 어떻게 분포가 변화하는지 보여주기 위해 인구 안정성 지수(PSI)를 사용하고 있습니다. PSI는 변수의 분포가 시간적으로나 다른 데이터셋 간에 얼마나 많이 변했는지를 측정하는 데 사용되는 지표입니다. 더 높은 PSI 값은 더 큰 변화를 나타내며, 이는 모델의 안정성에 문제가 될 수 있습니다.\n\n우리의 경우, 하나의 데이터셋을 다루고 있으며 높은 PSI 값은 해당 특성의 분포에 중요한 차이가 있다는 것을 나타냅니다. 이러한 세분화된 세그먼트는 지리적 지역, 연령 그룹 또는 다른 인구통계 요인에 의해 범주화될 수 있습니다. Figure 14에서 'relationship', 'marital-status', 'occupation' 특성은 상대적으로 높은 PSI 값이 나타납니다. 이는 데이터 하위 세그먼트에서 중요한 분포 변화가 있음을 나타냅니다. 반면에 'race', 'education', 'capital-loss'는 PSI 값이 낮아 해당 특성의 분포가 다른 데이터 세그먼트 간에 더 안정적임을 시사합니다.\n\n### 모델 견고성 분석\n\n모델의 견고성은 ML 모델이 다양한 시나리오에서 특히 새로운 데이터를 처리할 때 성능을 유지하는 능력을 말합니다. 모델 견고성의 측면에는 (a) 새로운 데이터에서 잘 동작하는 일반화 능력, (b) 입력값의 작은 변화에 크게 영향을 받지 않는 안정성, (c) 입력 데이터의 오류에 영향을 받지 않는 노이즈 허용성이 포함됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도형 15에 나타난 그래프는 EBM 모델의 모든 피처에 대한 교란(즉, 의도적인 변화)이 어떤 영향을 미치는지를 보여줍니다. 아래는 해당 그래프를 생성한 코드입니다. 'perturb_size'는 교란의 단계 크기를 나타내며, 'perturb_method'는 'quantile'로 설정되어 있습니다. 이 매개변수에는 'raw'와 'quantile' 두 가지 선택지가 있습니다. 'raw' 값은 피처에 가우시안 노이즈가 추가됨을 의미하며, 많은 피처가 이산형임을 감안할 때 'quantile' 값이 더 나은 선택입니다. 이 값은 사분위 범위 내의 교란을 의미합니다.\n\n![그래프](/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_16.png)\n\n그래프의 X축에는 교란 크기가, Y축에는 정확도 메트릭이 표시됩니다. 플롯 요소는 모델 정확도의 분포를 나타내는 상자 그림입니다. 특이치는 모델의 정확도가 대부분의 데이터와 현저하게 다른 지점을 보여줍니다.\n\n제로 교란은 데이터에 대한 수정 없이 모델의 기본 성능을 나타냅니다. 모델은 최고의 성능을 발휘하며, 높은 중앙값 정확도와 견고한 IQR로 나타납니다. 교란 크기가 커질수록 정확도가 저하하는 경향이 뚜렷하게 나타납니다. 이는 입력 데이터가 점점 교란을 받을수록 모델의 정확도가 낮아진다는 것을 나타냅니다. 예상대로, 성능 저하는 교란이 커질수록 더욱 뚜렷해집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 유형의 분석은 모델이 입력 데이터의 변화에 얼마나 민감한지 이해하는 데 중요하며, 입력 데이터가 훈련 중에 본 조건과 다를 수 있는 실제 시나리오에서 모델이 얼마나 잘 수행될 수 있는지를 평가하는 데 도움이 될 수 있습니다.\n\nB.2.6 세분화된 진단 분석\n\n우리가 논의할 마지막 유형의 분석은 특히 유용한데, 이는 개별 기능에 대한 심층적인 살피기를 통해 가장 취약한 영역을 찾는 데 도움이 됩니다. 아래 코드 스니펫을 사용하여 예제를 생성합니다. 모델 XGB1의 경우, 코드는 '교육'의 다른 세그먼트가 정확도와 같은 기본 성능 측정에 대해 어떻게 수행되고 있는지 보여줍니다. '교육'은 범주형 기능이며 균일하게 세분화될 것입니다.\n\n결과는 아래와 같습니다. 세그먼트 ID는 정확도를 오름차순으로 정렬하여 할당됩니다. 따라서 세그먼트 ID=0은 가장 낮은 정확도를 가진 세그먼트 2에 할당됩니다. 크기 매개변수는 세그먼트에 포함된 샘플 수를 보여줍니다. 가장 낮은 정확도를 가진 세그먼트에는 가장 적은 수의 샘플이 포함되어 있는 것은 좋은 소식입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 결과를 더 자세히 조사할 수 있습니다. 특히 가장 낮은 정확도를 보여주는 세그먼트 0을 살펴볼 필요가 있습니다. 아래 코드 조각은 'show' 매개변수에 'accuracy_table' 값을 할당하여 이를 수행합니다.\n\n결과는 아래 테이블 3에서 표시됩니다. 해당 테이블은 다섯 가지 숫자 성능 측정 항목과 세그먼트 0의 훈련 데이터와 테스트 데이터 간의 성능 차이에 대한 중요한 정보를 보여줍니다. 또한, 위의 정확도 테이블에 표시된 수치가 테스트 데이터의 가장 낮은 정확도였음을 알 수 있습니다.\n\n결론\n\nYellowbrick와 PiML은 데이터 과학자와 분석가들에게 모델 동작에 대한 이해를 심화하고자 하는 사람들에게 가치 있는 자원을 제공합니다. 이 도구들이 제공하는 시각화와 통찰력을 통해 사용자들은 데이터 품질 및 모델 성능과 관련된 여러 문제를 해결하고 이를 개선할 수 있습니다. 이를 통해 다양한 시나리오와 데이터 세그먼트에 대해 정확하고 견고하며 신뢰할 수 있는 모델을 보유할 수 있습니다. 이 글에서는 이러한 패키지의 일부 기능만 다루었습니다. 특히 PiML은 데이터 품질 평가, 모델 내구성 등과 같은 다양한 기능을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, 오늘날 증가하는 개인정보 보호에 대한 우려를 고려할 때, 로컬에서 작업하는 것이 사이버 보안 계획의 중요한 측면이 될 수 있습니다. 또 다른 문제는 오늘날 데이터의 증가하는 복잡성입니다. 이미지, 오디오 및 텍스트가로 결합되는 로봇학 및 다중 모달 LLM을 사용한 상황 객체 감지와 같은 다중 모달 응용 프로그램이 있습니다. 이러한 모든 모달리티의 관심 대상은 가능한 정확하게 모델링되어야 하므로, 다양한 모델의 다른 측면을 어떻게 평가하는지에 대해 알고하는 것이 중요합니다.\n\n모든 논의된 예제의 코드는 제 Github 저장소에서 찾을 수 있습니다: [https://github.com/theomitsa/Yellowbrik-PIML](https://github.com/theomitsa/Yellowbrik-PIML)\n\n독자 여러분, 읽어 주셔서 감사합니다!\n\n# 참고문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Kaggle 노트북, 소득 분류 모델, https://www.kaggle.com/code/jieyima/income-classification-model\n\n2. Manokhin, V., Practical Guide to Applied Conformal Prediction in Python: Learn and Apply The Best Uncertainty Frameworks to Your Industry Applications, Packt Publishing, December 2023.\n\n# 사용된 데이터셋\n\n- 와인 데이터셋: UCI Machine Learning Repository, https://archive.ics.uci.edu/dataset/109/wine, 라이센스: 본 데이터셋은 크리에이티브 커먼즈 저작자표시 4.0 국제 라이센스에 따라 라이센스가 부여됩니다.\n- 성인 (인구조사 소득) 데이터셋: UCI Machine Learning Repository, https://archive.ics.uci.edu/dataset/2/adult 라이센스: 본 데이터셋은 크리에이티브 커먼즈 저작자표시 4.0 국제 라이센스에 따라 라이센스가 부여됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**참고: \"저자가 아닌 경우, 모든 이미지는 저자에게 속합니다.\"**\n","ogImage":{"url":"/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_0.png"},"coverImage":"/assets/img/2024-05-20-UnlockingValuableDataandModelInsightswithPythonPackagesYellowbrickandPiMLwithCode_0.png","tag":["Tech"],"readingTime":20},{"title":"Streamlit Plotly 대시보드 데이터 시각화를 위한 확실한 방법","description":"","date":"2024-05-20 18:25","slug":"2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair","content":"\n![StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair](/assets/img/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair_0.png)\n\nPython Streamlit은 인터랙티브 웹 인터페이스를 만드는 놀라운 프레임워크입니다.\n\nPython Plotly는 지도 및 차트와 같은 데이터 시각화를 효율적으로 만드는 훌륭한 라이브러리입니다. 데이터 시각화를 아름답게 표시합니다.\n\nStreamlit과 Plotly는 함께하면 천생연분입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 CSV 데이터 세트에서 여러 데이터 시각화를 웹 인터페이스에서 생성할 수 있고 다중 상호 작용 레이어(예: 슬라이더 및 드롭다운 메뉴)를 추가할 수 있습니다.\n\n모두 100 줄 미만의 코드로 가능합니다! 어떻게 할 수 있는지 보고 싶으세요?\n\n종합적이고 무료로 이용할 수 있는 데이터 세트를 사용하여 모든 것을 함께 해보겠습니다.\n\n# 데이터 세트 — UNHCR 난민 데이터\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUNHCR(UN High Commission for Refugees)은 전 세계의 난민 이동에 대한 통계를 추적합니다.\n\n그들의 데이터는 여기에서 무료로 이용할 수 있습니다.\n\n다운로드 페이지에 도착한 후에는 선택한 데이터에 대해 자세히 볼 수 있습니다:\n\n![이미지](/assets/img/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트에서는 각 난민의 출신 국가와 피난국을 검색해 보겠습니다.\n\n이 데이터를 사용하여 다음을 보여주는 전 세계 맵과 차트를 만들 수 있습니다:\n\n- 출신 국가로부터 — 피난민이 어디로 가고 있는지\n- 피난국으로부터 — 피난민이 어디에서 왔는지\n\n데이터셋을 다운로드한 후, 스프레드시트 형식으로 열어서 다루고 있는 내용을 확인할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair_2.png\" /\u003e\n\n이 프로젝트에서 관심 있는 데이터 필드는 다음과 같습니다:\n\n- 출신 국가(3자리 ISO 코드 포함) — 망명을 찾는 사람이 어디에서 왔는지\n- 망명 국가(3자리 ISO 코드 포함) — 실제로 망명을 찾는 사람이 있는 곳\n- 인정된 결정 — 망명을 찾는 사람이 수락되었는지 여부(국가별 숫자 합계)\n\n출신 국가와 망명 국가 모두 3자리 ISO 코드를 가지고 있어서 등치지도를 만드는 데 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것 정말 유용해요! 지도 만드는 과정을 크게 간소화해줘요. 이제 코딩에 돌입해봅시다!\n\n## 단계 1: 라이브러리 가져오기 및 환경 설정\n\n우선, 필요한 라이브러리를 가져와 Streamlit 애플리케이션의 페이지 레이아웃을 설정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nimport streamlit as st\nimport pandas as pd\nimport plotly.express as px\n\n# 페이지 레이아웃을 넓게 설정합니다\nst.set_page_config(layout=\"wide\")\n```\n\n- streamlit: 대화형 웹 애플리케이션을 만드는 데 사용됩니다.\n- pandas: 데이터 조작 및 분석에 사용됩니다.\n- plotly.express: 시각화를 생성하는 데 사용됩니다.\n\n또한 Streamlit을 지도와 차트의 시각화를 위해 넓은 레이아웃으로 구성합니다.\n\n## 단계 2: 데이터셋 로드하기 — UNHCR 데이터베이스에서 글로벌 통계\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 우리는 피난 심사 결정을 포함한 데이터셋을 로드합니다.\n\n```js\n# 데이터셋 로드\nfile_path = 'asylum-decisions.csv'\ndf = pd.read_csv(file_path)\n```\n\n우리는 pandas를 사용하여 CSV 파일을 DataFrame으로 읽어옵니다.\n\n데이터 프레임을 만든 후에는 맵과 차트에 필요한 데이터를 설정하기 위해 가공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 3: 고유 년도 및 국가 추출\n\n우선적으로 데이터셋에서 고유한 년도와 국가를 추출합니다. 이 단계의 목적은 Streamlit 인터페이스의 슬라이더 및 드롭다운 메뉴를 채우는 것입니다:\n\n```python\n# 고유한 연도 추출 및 두 열의 고유 국가를 결합하여 드롭다운 메뉴 생성\nyears = sorted(df['Year'].unique())\ncountries = sorted(set(df['Country of origin']).union(set(df['Country of asylum'])))\n```\n\nunique() 함수는 슬라이더에 중복된 연도가 없고 원천/유학국에 중복된 국가가 없도록합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\norigin/asylum에 대한 연합을 수행함으로써 데이터셋에서 어떤 국가도 빠뜨리지 않도록 보장합니다.\n\n## 단계 4: Streamlit 인터페이스 생성\n\n데이터를 준비한 후에는 Streamlit 사용자 인터페이스 구성 요소를 선택하는 데 사용할 수 있습니다.\n\n```js\n# Streamlit 인터페이스\nst.subheader(\"Asylum Decisions Visualization\")\n\n# 연도 및 국가 선택 슬라이더 및 드롭다운\nselected_year = st.slider(\"연도 선택\", min_value=int(years[0]), max_value=int(years[-1]), step=1, key=\"year_slider\")\nselected_country = st.selectbox(\"국가 선택\", countries, key=\"country_select\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 줄은 작은 헤더를 만드는 것입니다. 그런 다음 다음을 만들어야 합니다:\n\n- 슬라이더: 사용자가 이전에 작성한 연도 데이터 프레임에서 연도를 선택할 수 있게 합니다.\n- 드롭다운(선택 상자): 사용자가 이전에 생성한 국가 데이터 프레임에서 국가를 선택할 수 있게 합니다.\n\n## 단계 5: 데이터 필터링\n\n선택한 연도와 피난국을 기반으로 데이터셋을 필터링하여 시각화를 위해 준비합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 선택한 연도와 국가를 기준으로 데이터 세트 필터링하기\nfiltered_df_origin = df[(df['연도'] == 선택한_연도) \u0026 (df['출신 국가'] == 선택한_국가)]\nfiltered_df_asylum = df[(df['연도'] == 선택한_연도) \u0026 (df['안보 국가'] == 선택한_국가)]\n\n# 0 값을 포함한 출신 국가 데이터\norigin_data = filtered_df_asylum.groupby('출신 국가')['인정된 결정'].sum().reset_index()\nall_countries_origin = pd.DataFrame(countries, columns=['출신 국가'])\norigin_data = all_countries_origin.merge(origin_data, on='출신 국가', how='left').fillna(0)\n\n# 0 값을 포함한 안보 국가 데이터\nasylum_data = filtered_df_origin.groupby('안보 국가')['인정된 결정'].sum().reset_index()\nall_countries_asylum = pd.DataFrame(countries, columns=['안보 국가'])\nasylum_data = all_countries_asylum.merge(asylum_data, on='안보 국가', how='left').fillna(0)\n```\n\n여기서 첫 번째 단계는 데이터를 연도별로 분리하는 것입니다. 이는 슬라이더로 선택한 연도에 따라 각 국가로 분리된 데이터를 만드는 과정입니다. 그 다음으로 모든 국가에 값이 있는지 확인하기 위해 fillna() 함수를 사용하여 모든 빈 열에 0을 추가합니다.\n\n## 단계 6: 코로플레스 맵 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 원산지 및 피난처 국가별 데이터 프레임을 가지고 나면, 각 데이터 프레임을 시각화하기 위해 두 개의 코로플레스 맵을 생성합니다:\n\n```js\n# 맵 생성\nfig_origin = px.choropleth(origin_data, locations=\"Country of origin\", locationmode=\"country names\",\n                           color=\"Recognized decisions\", hover_name=\"Country of origin\",\n                           projection=\"natural earth\", color_continuous_scale=\"YlOrRd\",\n                           title=\"원산지 국가\", template=\"plotly_dark\")\n\nfig_asylum = px.choropleth(asylum_data, locations=\"Country of asylum\", locationmode=\"country names\",\n                           color=\"Recognized decisions\", hover_name=\"Country of asylum\",\n                           projection=\"natural earth\", color_continuous_scale=\"YlOrRd\",\n                           title=\"피난처 국가\", template=\"plotly_dark\")\n```\n\n우리가 사용하는 메서드 및 속성에 대한 몇 가지 세부 정보:\n\n- px.choropleth(): 코로플레스 맵을 만드는 주요 plotly 메서드. 이 메서드를 사용하여 원산지 및 피난처 2개의 맵을 그립니다.\n- locations: 위치 이름이 있는 열을 지정합니다 (첫 번째 맵의 경우 원산지 국가이고, 두 번째 맵의 경우 피난처 국가입니다).\n- locationmode: 위치 이름을 해석하는 방법을 지정합니다.\n- color: 맵을 색칠하는 데 사용할 열을 지정합니다 (Recognized decisions 열의 값에 기초합니다).\n- hover_name: 위치를 가리킬 때 표시할 열을 지정합니다.\n- projection: 맵 투영 유형을 지정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 또한 제목, 색상 궁합(YlOrRd) 및 템플릿을 설정했습니다.\n\n![이미지](/assets/img/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair_3.png)\n\n각 지도는 위 예제와 유사하게 보일 것입니다(데이터에 따라 다름). 이 예제는 2017년 캐나다로의 망명 신청자를 위한 것입니다.\n\n## 7단계: 막대 차트 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음으로, 인정된 결정에 따른 상위 10개 국가에 대한 수평 막대 차트를 생성합니다:\n\n```js\n# 상위 10개 국가에 대한 막대 차트 생성\ntop_origin_data = origin_data.nlargest(10, 'Recognized decisions')  # 출신 국가 상위 10개\ntop_asylum_data = asylum_data.nlargest(10, 'Recognized decisions')  # 피난 국가 상위 10개\n\nfig_bar_origin = px.bar(top_origin_data, x='Recognized decisions', y='Country of origin',\n                        orientation='h', color='Recognized decisions', color_continuous_scale='YlOrRd',\n                        title='출신 국가 상위 10개')\n\nfig_bar_asylum = px.bar(top_asylum_data, x='Recognized decisions', y='Country of asylum',\n                        orientation='h', color='Recognized decisions', color_continuous_scale='YlOrRd',\n                        title='피난 국가 상위 10개')\n# 막대 순서 변경\nfig_bar_origin.update_layout(yaxis=dict(categoryorder='total ascending'))\nfig_bar_asylum.update_layout(yaxis=dict(categoryorder='total ascending'))\n```\n\n여기서는 나라 이름의 길이가 다양하기 때문에 수평 막대 차트가 가장 적합합니다. 이 코드 조각에 대해:\n\n- px.bar: 막대 차트 생성 (출신 데이터와 피난 데이터 각각 하나씩)\n- orientation='h': 막대 차트가 수평임을 지정합니다.\n- categoryorder='total ascending': 막대 순서를 반전시킵니다. 각 차트를 미학적으로 강조하기 위한 비필수적인 단계입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair_4.png\" /\u003e\n\n위 예제와 비슷한 차트가 생성될 것입니다.\n\n멋지네요. 이제 2개의 지도와 2개의 차트를 생성했으니, Streamlit 대시보드에 이 모든 것을 함께 표시할 수 있습니다.\n\n## 단계 8: 지도 및 막대 차트 표시하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n끝으로, Streamlit 인터페이스에서 지도와 막대 차트를 옆에 나란히 표시합니다.\n\n```js\n# 지도와 막대 차트를 옆에 표시하기\ncol1, col2 = st.columns(2)\n\nwith col1:\n    st.plotly_chart(fig_origin, use_container_width=True)\n    st.plotly_chart(fig_bar_origin, use_container_width=True)\n\nwith col2:\n    st.plotly_chart(fig_asylum, use_container_width=True)\n    st.plotly_chart(fig_bar_asylum, use_container_width=True)\n```\n\n이 코드 스니펫에 대한 설명:\n\n- st.columns: 시각화 요소를 옆에 배치할 수 있는 열을 생성합니다.\n- st.plotly_chart: Streamlit 앱에서 Plotly 차트를 표시합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와 놀라운 결과가 있습니다:\n\n![이미지](/assets/img/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair_5.png)\n\n이 정말 멋집니다.\n\n우리는 이 모두를 코드가 100줄 미만으로(내 예제 Python 파일에는 82줄) 구현했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n잘 진행되었으면 좋겠네요. 함께 와 주셔서 감사합니다.\n\n# 요약하면...\n\n이 Python 코딩 단계를 따라가며, Streamlit과 Plotly를 사용하여 망명 결정을 시각화하는 대화형 웹 애플리케이션을 만들어 보았습니다.\n\n사용자들은 슬라이더를 사용하여 국가를 선택하고, 해당 국가로 이동하는 난민의 움직임에 대한 다중 시각적 집중을 제공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPython의 Streamlit과 Plotly를 함께 사용하는 큰 장점 중 하나는 놀라울만큼 효율적인 코드를 만들 수 있다는 것입니다.\n\nPlotly는 지도 및 차트 시각화를 생성하는 데 최적화되어 있고 Streamlit은 웹 인터페이스를 생성하는 데 최적화되어 있습니다.\n\n완벽한 조합이라고 말할 수 있겠죠.\n\n읽어 주셔서 감사합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 유형의 이야기가 당신의 취향이고, 저를 작가로 지원하고 싶다면, 제 Substack를 구독해주세요.\n\nSubstack에서는 매주 뉴스레터와 다른 플랫폼에는 없는 기사들을 발행합니다.\n","ogImage":{"url":"/assets/img/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair_0.png"},"coverImage":"/assets/img/2024-05-20-StreamlitPlotlyDashboardsASureFireDataVisualizationLoveAffair_0.png","tag":["Tech"],"readingTime":14},{"title":"참작자 시선으로 바라본 Vista의 진실","description":"","date":"2024-05-20 18:21","slug":"2024-05-20-WhatReallyHappenedwithVistaAnInsidersRetrospective","content":"\n![이미지](/assets/img/2024-05-20-WhatReallyHappenedwithVistaAnInsidersRetrospective_0.png)\n\n테리 크로울리의 신중한 블로그 글 \"윈도우 비스타의 실제 상황\"를 읽는 것을 즐겼어요. 테리는 오피스 조직에서 일했고, 윈도우 비스타와 관련이 있는 하지만 실패한 롱혼 프로젝트에 대한 복잡한 작업들을 파트너 엔지니어링팀의 중요한 관점에서 아주 잘 다루었습니다.\n\n그는 프로젝트에 영향을 미친 많은 문제들을 올바르게 식별했고, 그 중 어느 것도 여기에서 다시 논의하려는 것은 아니에요. 같은 사건에 대한 내부자의 시각을 제공하려고 노력하는 것이 공평하다고 생각했어요. 테리만큼 훌륭하고 철저하게 설명할 수는 없겠지만, 이 프로젝트에서 무엇이 잘못되었는지에 대해 조금이나마 밝혀 보고 싶어요. 윈도우 비스타의 원래 출시일로부터 10년이 지났지만, 그 교훈들은 이제 전에보다 더 중요한 것 같아요.\n\n윈도우는 거대한 시스템이에요. 수천 명의 개발자, 테스터, 프로그램 매니저, 보안 전문가, UI 디자이너, 아키텍트, 등등이 있어요. 그리고 그것은 지원 캐스트인 인사담당자, 채용담당자, 마케팅 담당자, 영업인, 변호사, 물론 많은 관리자들, 이사들, 각 분야의 부사장들까지 말이에요. 전체 앙상블 캐스트는 Microsoft 내외부의 파트너 팀에서 지원받는 많은 수많은 사람들에 의해 지원되어요. 그들은 플랫폼 아래쪽의 하드웨어부터 제공하고 있는 장치 드라이버와 응용 프로그램까지 모든 것을 제공해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-WhatReallyHappenedwithVistaAnInsidersRetrospective_1.png\" /\u003e\n\n조직적으로 당시 Windows는 실제로 코어(Core), 서버(Server), 그리고 클라이언트(Client) 세 개의 팀이었습니다. 코어 팀은 운영 체계의 모든 필수 구성 요소인 \"배관 시설\"을 제공했으며(커널 자체, 스토리지, 보안, 네트워킹, 장치 드라이버, 설치 및 업그레이드 모델, Win32 등) 이는 모든 Windows 버전에서 공유되었습니다. 서버 팀은 다시 말해 서버 시장에서 필요한 기술(터미널 서비스, 클러스터링 및 고가용성, 기업 관리 도구 등)에 집중했고, 클라이언트 팀은 브라우저, 미디어 플레이어, 그래픽, 쉘 등 데스크톱 및 소비자 출시와 관련된 기술을 담당했습니다. 이 플랫폼은 많은 고객을 위해 서비스하는 데 논리적인 조직 구조로 보였습니다.\n\n물론 많은 조직 재편이 있었지만, Windows가 인기를 얻고 팀이 커지는 가운데서도 해당 기본 구조는 유지되었습니다.\n\n문화적으로나 조직적으로 말하자면, 코어 팀은 클라이언트 팀보다 서버 팀에 더 가까웠다고 말할 수 있습니다. 적어도 Vista 출시 이후까지는 그랬습니다. 이는 서버 플랫폼 요구 사항을 고려한 \"코어\" 팀 프로젝트에 더 많은 중점이 두어졌음을 의미했습니다: 더 많은 확장성 노력, 더 많은 중복 기능, OS 출시에서 기업 요구 사항을 더 많이 다루는 등, Windows가 이미 주도하는 소비자 데스크톱 시장뿐만 아니라 수익성이 높은 서버 시장에 대응하기 위해 성장하는 동안 기울이는 노력입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 1998년 초에 마이크로소프트에 도착했을 때, Windows라고 하면 Windows NT를 가리켰습니다. 아키텍처적으로, 조직적으로, 그리고 제품 적으로 모두 Windows 95 코드 베이스는 대부분 버려졌고 Windows NT가 노트북부터 클러스터 데이터베이스 서버까지 모든 유형의 Windows에 채택되었습니다. 그후 2년 뒤, Windows 95/98 코드 베이스가 한 번 더 부활하여 매우 비판을 받은 Windows ME를 출시했지만 그 프로젝트는 소규모 팀이 실행한 반면, 대부분은 NT 코드 베이스에 매진했습니다.\n\n제가 운이 좋았던 것은 Windows 2000 개발 시기의 절정기에 참여하여, \"카이로\"의 취소 이후부터 Windows 7 완성까지 머문 12년을 마이크로소프트의 속에서 보낼 수 있었습니다.\n\n저는 임기 7년간 스토리지, 파일 시스템, 고가용성/클러스터링, 파일 레벨 네트워크 프로토콜, 분산 파일 시스템, 복제 프로토콜 등을 책임지는 팀을 관리했습니다. 이는 대략 Windows 2000, XP, Server 2003, 그리고 Longhorn 시기와 일치했습니다.\n\n이후로는 Microsoft의 보안을 관리하는 데 1~2년을 보냈습니다. 이는 \"Longhorn 재설정\" 시점부터 Vista 출시까지 대략입니다. 제 책임은 Windows의 보안 기술부터 보안 소프트웨어 애드온 솔루션, 보안 마케팅, 그리고 보안 패치의 생성, 테스트, 전달 등 비상 대응에 이르기까지 모든 것을 다뤄야 했습니다. 이는 Windows의 바이러스와 웜이 시스템을 망가뜨리는 시기로, 마이크로소프트의 안전한 소프트웨어 개발 명성이 시장에서 심각한 타격을 입고 있던 시기였습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비스타 출시 후 윈도우 7 기간 동안, 윈도우즈 코어 개발팀을 관리했어요. 이 말은 실제로 “하드웨어 아래에서” 실행되는 모든 기술과 클라이언트 및 서버 팀에서 사용되는 기술을 개발팀이 소유한다는 것을 의미했어요. 비스타가 출시된 후, 윈도우 팀은 직군별로 구성되었고 각 조직의 모든 수준에서 “세 요소”(개발, 테스트, 프로젝트 관리)가 책임을 맡았기 때문에 함께 범죄 동료 두 명이 있었어요. 저는 개발팀을 총괄했고, 그들은 각각 테스트팀과 프로그램 관리팀을 총괄했어요.\n\n윈도우 팀은 대규모이자 야 Ambit이이었던 프로젝트를 시도한 역사가 있었는데, 이 프로젝트들은 종종 몇 년 후에는 포기되거나 다시 활용되었어요. 예를 들어 야 Cairo 프로젝트를 포함, 완벽한 Seoul 프로젝트는 결국 삭제되어 일부 구성 요소 만 윈도우 2000의 일부로 제공되었어요.\n\n내 감동적인 견해로 보면, 윈도우 릴리스의 가장 큰 문제는 각 릴리스의 기간이 오래 걸렸다는 것이었어요. 평균적으로 출시에는 총 세 년이 소요되지만 그 중 “새로운” 코드를 개발하는 데는 약 여섯에서 아홉 개월. 그 시간의 나머지는 통합, 테스트, 알파 및 베타 기간에 소요되었어요 — 각각 수개월 동안 지속되는 시간.\n\n일부 프로젝트는 6개월 이상의 코어 개발이 필요하여 병행으로 계속되어 완료되었을 때 주요 코드 베이스에 통합되었어요. 이는 주요 트리가 거의 항상 대규모의 기능이 통합되거나 교체되는 동안 거의 항상 반쪽 상태에 있음을 의미했어요. 윈도우 7 릴리스 중에는 항상 건강하고 기능하는 코드 베이스를 유지하기 위해 훨씬 더 엄격한 제어가 도입되었지만, 초기 릴리스는 수개월 동안 일상적인 불안전으로 시달렸어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발의 혼돈한 성격으로 인해 팀들은 종종 일정을 맞추는 데 서로 경쟁을 벌이며, 다른 프로젝트들보다 자신들의 코드가 더 잘되어 있다고 자신들과 다른 사람들을 설득했습니다. 마지막 순간에 몇 가지 남은 작업을 \"정리\"할 수 있다면, 나중에 조금 수정하고 자체 구현한 컴포넌트를 확인할 수 있게 되겠다는 것이죠.\n\n당시에는 Windows 개발 환경이 많은 해를 거쳐 하나로 이어진 도구들의 혼재체였기 때문에 이 문제가 악화되었습니다. 팀들은 자신들만의 컴포넌트를 빌드하고 테스트하는 데 많은 시간을 들여야만 했습니다. 왜냐하면 전체 소스 코드를 처음부터 컴파일하여 감지되지 않은 헤더 파일 종속성을 놓치지 않았는지 확인해야 했기 때문이었죠.\n\n3년의 릴리스 주기는 또한 우리가 릴리스를 시작할 때 경쟁 상황과 외부 생태계가 어떻게 변할지를 거의 알 수 없다는 점을 의미했습니다. 릴리스를 놓치는 것은 기능이 드물게 두 릴리스나 6년 후에는 더 이상 의미가 없게 되어 취소되거나, 더 나쁜 경우에는 시베리아로 추방될 수 있었습니다. 이는 대부분의 수천 명을 포함하는 조직에서 무시받는 컴포넌트의 개발을 계속하게 될 뿐만 아니라 결국 실패하거나 관련성을 잃는 운명에 처할 것이며, 그러나 팀이나 임원들이 단종하기에는 마음이 너무 아픈 프로젝트들도 있었습니다. 나는 그러한 몇 가지 프로젝트를 책임져 왔었습니다. 사후 판단은 쉬워요.\n\n각 팀이 릴리스에 자신들의 계획과 기능들을 밀어넣느라, 다른 컴포넌트와의 통합, 사용자 인터페이스, 끝까지 테스팅과 업그레이드와 같은 지루하고 골치 아픈 문제를 미흡하게 처리하는 경우가 많았습니다. 이로 인해 일부 팀들이 마지막 순간에 자신들의 UI나 업그레이드 테스트를 마무리하는 데 도움을 요청하여 병목 현상이 발생했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금 시점에서, 진행 중인 주요 릴리스가 여러 개 있었고 여러 사이드 프로젝트도 진행 중이었습니다. 다양한 상태의 코드베이스를 관리하던 다른 팀들은 시간이 흘러 “부자는 더 부자가 되고 가난한 사람은 더 가난해지는” 모델로 이어졌습니다. 따라서 어떤 이유로든 뒤쳐진 팀들은 대부분 뒤처졌습니다.\n\n프로젝트가 완료에 가까워질수록 프로그램 매니저들은 다음 릴리스를 위한 요구 사항을 살펴보기 시작했으며 “건강한”(부자) 팀의 개발자들은 다음 릴리스를 위해 새로 “forked”된 소스 트리에서 새 코드를 구현하기 시작했습니다. 하지만 조직의 상당 부분(가난한 팀)은 여전히 현재 릴리스에 갇혀 있었습니다. 특히, 테스트 팀은 릴리스가 출시될 때까지 거의 해방되지 않았기 때문에 새 코드는 프로젝트 초반에 충분히 테스트되지 않았고 “건강하지 않은” 팀은 항상 뒤처졌습니다. 이들 팀은 종종 도덕적이지 않은 코드를 상속받아 이해하지 못하는 엔지니어들이 되었습니다. 몇 년 동안 그러한 팀이 코드 베이스에 도입한 몇 가지 “버그 수정”과 “기능 향상”에 관한 압도적인 공포 이야기를 적을 수 있었습니다.\n\nVista/Longhorn의 대부분 기간 동안, 저는 Windows 파일 시스템 기술에 대한 책임이 있었습니다. 즉, 주로 SQL 데이터베이스 팀이 주도하는 WinFS 노력에 참여했지만 그 팀은 Windows 팀의 자매 조직이었습니다.\n\n빌 게이츠는 매우 상세한 수준에서 개인적으로 참여하여 “WinFS PM”로 농담처럼 불렸습니다: 프로젝트를 담당하는 프로그램 매니저입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수백, 아니면 수천 명의 엔지니어들이 참여한 엔지니어링 작업이 시간이 흐름에 따라 단순히 지나쳐가면서 발생했습니다: 데이터베이스의 쿼리 기능과 파일 시스템의 스트리밍 기능 및 비정형 데이터 기능을 결합하여 새로운 \"풍요로운\" 응용 프로그램을 만들기 위한 프로그래밍 패러다임으로 노출시키는 아이디어에 대한 일입니다.\n\n이제는 구글이 이 문제를 손쉽게 해결했음이 분명해졌습니다. 비정형 및 구조화된 데이터에 대한 심미적이고 빠른 인덱싱 경험을 제공했으니까요. 그들은 로컬 디스크뿐만 아니라 전체 인터넷에 대해 이 작업을 수행했고, 이를 활용하기 위해 응용 프로그램을 다시 작성할 필요가 없었습니다. 심지어 WinFS가 성공했다 해도, 그 기능을 활용하기 위해 응용 프로그램을 다시 작성하는 데 몇 년이 걸렸을 것입니다.\n\nLonghorn이 취소되고 비스타가 그 재난적인 잔해에서 급히 조합되는 동안, WinFS는 OS 출시에서 제외되었습니다. SQL 팀에 의해 몇 년 동안 스탠드얼론 프로젝트로 추구되었으나, 그때쯤에는 Windows에 기본 인덱싱 엔진과 통합 검색 환경이 내장되어 있었습니다. 이것은 애플리케이션 변경이 필요하지 않은 채로 순수하게 구현되었습니다. 따라서 WinFS의 관련성은 더욱 모호해졌지만 프로젝트는 계속되었습니다.\n\n우리는 선택의 여지가 없었습니다. Windows XP가 우리의 성공의 희생자였음을 밝혀냈습니다. 사용성을 위해 설계된 시스템이 인터넷 시대의 현실과 마주할 때 보안 면에서 큰 결함이 있었습니다. 이러한 보안 문제에 대처하기 위해 병렬 프로젝트인 Windows XP 서비스 팩 2가 생성되었는데, (이름과는 상관 없이) Longhorn으로부터 수천 개의 리소스를 빼앗아가는 거대한 작업이었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n윈도우 NT 커널은 항상 다중 사용자 ID를 지원하고 관리 권한 경계를 올바르게 구현했지만, 사용자 모드에서는 Windows 95 호환성을 향상시키기 위해 이를 무시했습니다. 이는 시스템의 기본 사용자가 관리 권한을 가진 채로 \"새로 판매 상태\"로 설정되어 있음을 의미했습니다.\n\n응용 프로그램은 보통(그리고 종종 알지 못하고) 이 권한을 남용하여 공통 파일 및 레지스트리 설정을 덮어쓰며 서로 간섭하곤 했습니다. 또한, 시스템을 쉽게 복제할 수 있었던 악성 소프트웨어도 사용자가 관리자(“루트”) 권한으로 실행되어 있었기 때문에 이러한 문제가 발생했습니다.\n\nVista에서 엄격한 관리적 경계를 강제로 적용하면 윈도우 전체의 거의 모든 응용 프로그램이 동작하지 않게 되었습니다. 해결책 중 하나는 UAC (사용자 계정 컨트롤)인데, 이는 아마도 가장 혐오받는 Vista의 기능 중 하나일 것입니다. 시스템이 사용자에게 명령을 실행하거나 레벨을 높이려는 스크립트를 클릭할 때 실제로 권환 레벨을 올릴 의도가 있는지 물어보게 했습니다. 레거시 응용 프로그램을 설치하려면 거의 항상 권한을 높여야 했기 때문에 사용자의 첫 상호작용은 혼란스러운 UAC 팝업창으로 가득했고 이는 경험을 망칠 수 있었습니다.\n\n만약 로그인한 사용자로부터 관리적 액세스가 제거된다면 모든 Windows 앱 중 99%가 제대로 설치조차 되지 않았다고 해도 과언이 아닐 것입니다. Windows 95와의 수십 년간의 하위 호환성은 우리의 손이 묶였다는 것을 의미했고, 안전성을 향상하려면 앱 호환성을 파괴하는 선택을 내려야만 했던 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 측면에서 볼 때, Vista는 마이크로소프트에서 출시한 이전 OS들보다 훨씬 더 안전했지만, 이 과정에서 우리는 \"알려진 나쁜\" API를 더 이상 지원하지 않거나 UAC와 같은 메커니즘을 통해 이를 해결하려는 방식으로 애플리케이션 및 장치 드라이버 호환성을 이전과는 다른 방식으로 파괴해 버렸어요.\n\n고객들은 자신들의 앱이 작동하지 않게 되어서 싫어했고, 생태계 파트너들은 드라이버와 애플리케이션을 업데이트하고 인증하는 데 충분한 시간이 없다고 느끼며 Vista가 다시 떠오르는 애플과의 경쟁에서 급히 출시되었다고 불평했어요.\n\n많은 경우, 이러한 보안 변경 사항으로 인해 제삼자 장치 드라이버 및 솔루션에 대한 심층적인 아키텍처 변경이 필요했어요. 대부분의 생태계 업체들은 그들의 레거시 앱에 많은 투자를 할 동기가 없었죠. 이러한 해결책 중 일부는 기능을 구현하기 위해 API 및 다중 프로세서 잠금을 우회하여 데이터 구조 및 심지를 수정하는 비평적인 접근 방식을 취했으며, 종종 혼란을 일으키기도 했어요. 어느 한 시점에, 윈도우 시스템의 약 70%가 이러한 제삼자 드라이버들과 그들의 기능 구현을 위해 지원되는 API를 사용하지 않는 점 때문에 발생하는 시스템 충돌(\"블루 스크린\") 때문에 발생한 것이었어요. 백신 소프트웨어 공급업체들이 이 방식을 사용하는 데 악명 높았어요.\n\n마이크로소프트 보안 책임자로서, 저는 개인적으로 백신 소프트웨어 업체들에게 왜 메모리에 있는 커널 명령과 데이터 구조를 \"패치\"할 수 없게 되었는지, 이것이 보안 위험이 되는 이유, 그리고 앞으로 승인된 API를 사용해야 하는 이유에 대해 몇 년 동안 설명했어요. 더 이상 우리는 윈도우 커널에서 레거시 앱을 지원하지 않고 이러한 접근법을 사용하여 소비자 시스템을 공격하는 해커들이 사용하던 것과 마찬가지로 시스템을 공격하는 제삼자의 필요성이 없다는 걸 알려주었죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"우리 \"친구\"인 백신 업체들이 우리에게 소송을 제기할 것이라고 협박했어요. 그들은 우리가 그들의 생계를 막고 독점 권력을 남용하고 있다고 주장했습니다! 이런 친구가 있으면 적이 뭐 필요해요? 그들은 단지 이전 솔루션들이 계속 작동되기를 원했던 것뿐이지만, 그것이 우리 고객들의 보안을 감소시킨다 해도요—우리가 개선해야 할 것이었던 것을요.\n\n그 몇 년 동안 컴퓨팅 산업에서 팽팽한 변화가 있었어요—인터넷의 등장, 휴대전화의 급부상, 클라우드 컴퓨팅의 등장, 새로운 광고 기반 비즈니스 모델의 창출, 소셜 미디어의 바이럴한 성장, 모어의 법칙의 무차별적인 행진, 64비트 컴퓨팅의 성숙, 저렴하고 신뢰할 수 있는 저장 공간, 풍부한 네트워킹 대역폭, 진화하는 보안 및 개인 정보 보호 환경, 그리고 오픈 소스의 인기 등이 윈도우에게 모든 방향에서 공격을 가했죠.\n\n놀랄만큼 성공적인 플랫폼이었기 때문에 우리의 대답은 그 자리에 있어서 기존 시스템을 점진적으로 개선하는 것이었어요—혁신자의 딜레마를 간단히 말하자면요. 우리가 코드를 계속 추가할수록, 우리는 더 복잡함을 만들었고, 팀도 커졌고, 생태계도 커졌고, 경쟁 상대를 앞지르는 것이 더 어려워졌어요.\n\n경쟁적인 힘만으로도 부족하지 않은 것처럼, 엔지니어들과 프로그램 매니저들의 군단이 소비자의 편의를 위해 이전 릴리스의 API를 문서화하기 위해 DOJ 및 기업 변호사들과 무수히 많은 시간, 하루, 주, 달을 보냈던 시기기도 했어요.\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현실적으로 말하자면, 현재의 수명주기에서 윈도우의 주요 릴리스를 완성하는 데는 대략 3년이 걸렸고, 그 속도는 빠르게 움직이는 시장에는 너무 느린 것으로 판명되었습니다. 롱혼(Longhorn)에서는 WinFS, 보안, 그리고 관리 코드 등 여러 거대한 프로젝트들이 계획되었습니다. 수백 개의 더 작은 베팅 프로젝트들도 있었습니다.\n\n수백 명의 직원으로 이뤄진 조직과 수십억 명이 넘는 고객이 있다면 누구나 의견을 내기 마련입니다. 곧 출시될 태블릿과 스마트폰에서 작동할 예정인 동일한 OS 릴리스는 노트북, 데이터 센터 서버, NAS 상자와 같은 임베디드 장치, 그리고 클라우드 내 하이퍼바이저(HyperV) 위에서도 작동해야 했습니다. 이러한 요구사항은 시장의 모든 세그먼트에 동시에 전진하려는 시도로 인해 팀을 상반되는 방향으로 이끌었습니다.\n\n롱혼과 비스타(Vista)를 고립시켜 보는 것은 불가능합니다. 이들은 그들 앞뒤로 즉시 출시된 윈도우 2000과 XP, 윈도우 서버 2008과 윈도우 7과 함께 포괄 산업 지식 속에서 봤을 때에만 의미를 가집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n윈도우는 자신의 성공에 휩쓸렸습니다. 다양한 시장에 성공적으로 파고들었고 각 사업이 이제 운영 체제의 디자인에 어떤 영향을 끼치며 서로 다른 방향으로 끌어당겼습니다. 이러한 이질적인 요구 사항을 충족시키려고 한다는 것은 그 중 어느 하나를 완전히 만족시키지 못하는 것을 의미했습니다.\n\n90년대에 대단히 성공했던 아키텍처가 주변 환경이 더욱 신속하게 변화할 때 더디게 느려졌으며 조직은 변화에 발 맞추기 어려워했습니다.\n\n분명히 이러한 추세들을 보았고 그에 대응하기 위해 노력했지만, 유사육아가 프리 출시로 3년 후 출시될 때 2년 동안 비행기를 개량하는 것은 매우 어려웠습니다.\n\n간단히 말하자면, 3-4년 전에 특정 운영 체제 출시를 계획했을 때 우리가 알았다고 생각했던 것들은 그 제품이 마침내 배송되었을 때 웃기게 구식이었고 때로는 완전히 잘못된 것들도 있었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가장 좋았던 일은 우리가 점차적이고 마찬가지로 안정적인 방식으로 새로운 클라우드 기반 서비스를 간소화된 기기에 제공할 수 있도록 한 것이었습니다. 대신, 우리는 필요할 때 속도를 내야 할 때마다 우리를 늦춘 각 릴리스 전에 몇 달 동안 테스트가 필요한 기존의 클라이언트 기반의 단일 시스템에 기능을 계속 추가했습니다. 물론, 이전 Windows 릴리스에서 이미 실행 중인 애플리케이션들에 의해 호환성을 위해 필요했던 이전 기능들을 제거할 용기가 없었죠.\n\n이제 수십억 명의 고객, 수백만 기업, 수천 개 파트너, 수백 가지 시나리오 및 수십 가지 형태 요소를 위한 일 년 이상의 동일한 OS를 지원해야 한다고 상상해보면, 지원 및 호환성 악모지란을 조금이라도 알 수 있을 겁니다.\n\n후에야, Linux는 이 측면에서 더욱 성공적이었습니다. 오픈 소스 커뮤니티와 소프트웨어 개발 접근 방식은 분명한 해결책의 한 부분입니다. Unix/Linux의 모듈식 및 플러그 가능한 아키텍처도 이 측면에서 큰 구조적 개선입니다.\n\n전혀 다른 접근 방식을 취한 Apple은 문제 공간을 축소하여 전체 품질과 최종 사용자 경험을 향상시킬 수 있는 방법을 보여 주었습니다. 기존 서버 및 저장 노력을 중단하고 이전 호환되지 않는 PowerPC 아키텍처를 지원 중단하며 새로운 형태 요소에 직면했을 때 macOS와 구분된 iOS라는 새로운 운영 체제를 탄생시켰습니다. 비교적으로 Windows는 모든 사람에게 모든 것이 되려고 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n조직은 결국 자신의 제품으로 조직도를 출시합니다(콘웨이의 법칙); Windows 조직도 예외는 아니었습니다.\n\n![이미지](/assets/img/2024-05-20-WhatReallyHappenedwithVistaAnInsidersRetrospective_3.png)\n\n그에 더해 내부 조직적 역학과 개성을 더하면 어떻습니까? 우리는 각자의 취향 있는 기능을 가졌고, 우리 생태계 파트너들이 새로운 표준을 채택하도록 우리를 격려하고, 솔루션을 플랫폼에서 인증하는 데 도움을 요청하고, 특정 시나리오에 대한 API를 추가하도록 요청했습니다. 우리는 모두 우리의 기술, 우리의 아이디어가 이길 것이라고 믿었습니다... 만약 우리가 다음 Windows 릴리스에 그것을 간신히 넣고 순식간에 수백만 명의 고객을 확보할 수 있다면요.\n\n우리는 이를 위해 기획 회의와 매일의 전쟁 회의에서 싸우기도 충분히 믿었습니다. 다른 모든 조직과 마찬가지로, 승진을 원하고 영향력을 더하거나, 대리팀 크기를 증가시키고 싶어 하는 매니저도 있었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n흑자인가요, 어떤가요? 지난 해 산업 수준의 문제가 종종 발생하곤 했습니다. 발생이 불가피할 때입니다. 그러나 이는 죄송하다는 말이 아닌 이해해 주셨으면 하는 바람입니다.그나저나, 실수를 했을까요? 네, 많았습니다.의도적으로 잘못된 결정을 내렸을까요? 아니요, 그렇게 기억나지 않아요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상당히 복잡한 제품이었나요? 놀랍도록 거대한 생태계를 가지고 있나요 (당시 세계 최고의 생태계)? 네, 그랬습니다.\n\n더 잘 할 수 있었나요? 네, 그렇습니다. 빠르게 변화하는 시장에서 단계적인 접근은 적대적입니다.\n\n오늘 다른 결정을 내릴까요? 네, 그렇습니다. 지식은 나중에야 20/20으로 드러납니다. 당시에는 지금 알고 있는 것을 몰랐습니다.\n\n그 실수로 배우고 다음 번엔 더 잘할 수 있었나요? 네. 윈도우 사용자라면 누구나 동의할 것 같아요. 비스타의 후속인 윈도우 7은 상품으로서 훨씬 성공적이었습니다. 사실, 대부분의 분석가와 사용자가 윈도우 XP와 함께 역사상 가장 우수한 릴리즈 중 하나로 여기고 있습니다. 사용자들이 \"마이크로소프트가 '차가운 주검 손에서 떼어낼' 필요가 있다\"라고 말한 것을 들었어요. 윈도우 7의 핵심 개발팀 책임자로서 그 노력에 참여한 것을 자랑스럽게 생각해요. 윈도우 팀은 비스타의 많은 실수로부터 배워서 훨씬 더 나은 제품을 제공했습니다. 비스타만큼 구조적으로 야심찼나요? 아니요. 그럼에도 세 배나 걸렸나요? 네.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n윈도우 8에 일어난 일은 전혀 다른 이야기입니다. 그 당시에는 회사를 떠난 상태였기 때문에 그에 대해 논평할 자격이 없습니다.\n\n비스타를 회고하며 안타깝게 생각할까요? 아니요, 저는 그것을 배운 교훈으로 바라보는 것을 선호합니다. 저희 중 아무도 나중 프로젝트에서 같은 실수를 반복하지 않았을 거라 확신합니다. 우리는 그 경험으로부터 배웠기 때문에 다음 번에는 전혀 다른 실수를 했을 거라고 생각합니다. 실수는 인간적이죠.\n\n이 게시물을 즐겼다면, 운영 체제 플랫폼의 진화에 관한 후속 포스트도 즐길 수 있을 것입니다.\n\n흥미로운 다른 블로그 포스트 목록입니다:\n","ogImage":{"url":"/assets/img/2024-05-20-WhatReallyHappenedwithVistaAnInsidersRetrospective_0.png"},"coverImage":"/assets/img/2024-05-20-WhatReallyHappenedwithVistaAnInsidersRetrospective_0.png","tag":["Tech"],"readingTime":16}],"page":"85","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"85"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>