<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/6" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/6" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="쿠버네티스 명령어 명령형 vs 선언형 비교" href="/post/2024-06-23-ImperativevsDeclarativeKubernetesCommands"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="쿠버네티스 명령어 명령형 vs 선언형 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ImperativevsDeclarativeKubernetesCommands_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="쿠버네티스 명령어 명령형 vs 선언형 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">쿠버네티스 명령어 명령형 vs 선언형 비교</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법" href="/post/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유" href="/post/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기" href="/post/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법" href="/post/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법" href="/post/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ubuntu 2204에 Docker Desktop 설치하는 방법" href="/post/2024-06-23-HowToInstallDockerDesktoponUbuntu2204"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ubuntu 2204에 Docker Desktop 설치하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ubuntu 2204에 Docker Desktop 설치하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Ubuntu 2204에 Docker Desktop 설치하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Docker 볼륨 이해하기 완벽 가이드" href="/post/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker 볼륨 이해하기 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker 볼륨 이해하기 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Docker 볼륨 이해하기 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것" href="/post/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="마이크로서비스 아키텍처 모두가 알아야 할 필수 개념과 방법" href="/post/2024-06-23-MicroservicesArchitectureAllYouNeedtoknow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="마이크로서비스 아키텍처 모두가 알아야 할 필수 개념과 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-MicroservicesArchitectureAllYouNeedtoknow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="마이크로서비스 아키텍처 모두가 알아야 할 필수 개념과 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">마이크로서비스 아키텍처 모두가 알아야 할 필수 개념과 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link posts_-active__YVJEi" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"쿠버네티스 명령어 명령형 vs 선언형 비교","description":"","date":"2024-06-23 23:01","slug":"2024-06-23-ImperativevsDeclarativeKubernetesCommands","content":"\n쿠버네티스 명령줄 도구 인 kubectl을 사용하면 쿠버네티스 클러스터에 대해 명령을 실행할 수 있습니다. kubectl을 사용하여 응용 프로그램을 배포하고 클러스터 리소스를 검사하고 관리하며 로그를 볼 수 있습니다.\n\nkubectl 도구는 세 가지 유형의 객체 관리를 지원합니다.\n\n- 명령형 명령\n- 명령형 객체 구성\n- 선언적 객체 구성\n\n![이미지](/assets/img/2024-06-23-ImperativevsDeclarativeKubernetesCommands_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 명령문\n\n명령문은 클러스터의 객체에 직접적으로 작용하며, 이러한 명령문은 객체의 상태를 즉시 변경합니다.\n\n이러한 명령문의 예시:\n\n- **kubectl create** — 이 명령어는 객체(e.g. 배포(Deployment), 레플리카셋(ReplicaSet) 등)를 생성하는 데 사용됩니다.\n- **kubectl run** — 이 명령어는 포드(Pod)를 생성하는 데 사용됩니다.\n- **kubectl expose** — 이 명령어는 배포(Deployment) 또는 레플리카셋(ReplicaSet)에 대한 서비스를 생성하는 데 사용됩니다.\n- **kubectl scale** — 이 몤령어는 배포(Deployment) 또는 레플리카셋(ReplicaSet)에서 레플리카의 수를 확장하거나 축소하는 데 사용됩니다.\n- **kubectl delete** — 이 명령어는 객체(e.g. 배포(Deployment), 포드(Pod) 등)를 삭제하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시\n\n첫 번째 명령은 nginx 컨테이너를 실행하는 Pod 객체를 생성합니다. 두 번째 명령\n\nnginx 컨테이너를 실행하는 Pod 객체를 생성합니다:\n\n```js\nkubectl run nginx --image=nginx\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nnginx 컨테이너를 실행하는 ReplicaSets가 있는 Deployment 객체를 만들어보세요:\n\n```js\nkubectl create deployment nginx --image nginx\n```\n\nImperative 명령어들은 보통 사용하기 쉽습니다. 학습이나 테스트 프로젝트에는 훌륭한데, Git과 같은 버전 관리 시스템에서 시스템 변경사항을 추적할 수 없기 때문에 프로덕션 시스템에서는 일반적으로 피해야합니다.\n\n## 명령어를 사용한 객체 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n명령형 객체 구성에서는 kubectl 명령어를 사용하여 작업(생성, 대체 등), 선택적 플래그 및 하나 이상의 파일 이름을 지정합니다.\n\n예시\n\n구성 파일에 정의된 객체를 생성합니다:\n\n```js\nkubectl create -f config.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 구성 파일에서 정의된 객체를 삭제합니다:\n\n```js\nkubectl delete -f config1.yaml -f config2.yaml\n```\n\n## 선언적 객체 구성\n\n명령형 명령어와는 달리 객체에 대한 작업을 수행하기 위해 정확한 단계를 올바른 순서대로 수행해야 하는 절차적 방법과 달리, 선언적 접근 방식은 선언적 매니페스트 파일에서 객체의 원하는 상태를 선언하고 Kubernetes가 kubectl applycommand를 사용하여 객체의 원하는 상태를 달성하도록 관리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시\n\nconfigs 디렉토리에 있는 모든 객체 구성 파일을 처리하고 라이브 객체를 생성하거나 패치합니다. 무엇이 변경될 것인지 먼저 확인하고 적용할 수 있습니다:\n\n```js\nkubectl diff -f configs/\nkubectl apply -f configs/\n```\n\n디렉토리를 재귀적으로 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl diff -R -f configs/\nkubectl apply -R -f configs/\n```\n\n딱지 복제 파일은 YAML 또는 JSON으로 작성되며 Kubernetes 객체의 원하는 상태를 정의합니다. 선언적 매니페스트가 클러스터에 적용되면 Kubernetes는 객체의 현재 상태와 원하는 상태를 비교하여 원하는 상태를 달성하기 위해 필요한 변경을 수행합니다.\n\n다음은 선언적 매니페스트 예시입니다 — configs/nginx-deployment.yaml\n\n```js\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n        - name: nginx-container\n          image: nginx:latest\n          ports:\n            - containerPort: 8080\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 manifest는 nginx:latest Docker 이미지를 기반으로 하는 컨테이너의 복제본을 두 개 실행해야 한다는 배포를 설명합니다.\n\n이렇게 하면, 우리는 많은 선언적 manifest 파일들을 직접적으로 구성에 추가하고, 모두를 하나의 kubectl apply -f configs/ 명령어로 적용할 수 있습니다.\n\n일반적으로 선언적 접근 방식은 변경 사항을 버전 관리 시스템에서 추적할 수 있게 하며, 코드 리뷰를 가능하게 하고 변경 사항을 CI/CD 파이프라인에서 자동으로 적용하는 것을 가능하게 합니다.\n\n이 글이 마음에 드셨다면 팔로우 버튼을 눌러 주세요. 더 이상의 이와 유사한 글을 읽고 싶으시다면요\n","ogImage":{"url":"/assets/img/2024-06-23-ImperativevsDeclarativeKubernetesCommands_0.png"},"coverImage":"/assets/img/2024-06-23-ImperativevsDeclarativeKubernetesCommands_0.png","tag":["Tech"],"readingTime":5},{"title":"K8sGPT  Ollama 무료 Kubernetes 자동 진단 솔루션 사용법","description":"","date":"2024-06-23 23:00","slug":"2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution","content":"\n![Kubernetes Automated Diagnosis Tool: k8sgpt-operator](/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_0.png)\n\n주말에 블로그 초고를 확인했더니 이 글이 있었어요. 한 해 전 'Kubernetes Automated Diagnosis Tool: k8sgpt-operator'를 쓸 때의 기억이 떠오르네요. 처음에는 K8sGPT + LocalAI를 써보려 했지만, Ollama로 시도해보니 더 사용하기 편리했어요. 게다가 Ollama는 OpenAI API를 지원하기도 해서 Ollama로 바꾸기로 결정했죠.\n\nk8sgpt-operator를 소개하는 글을 게시한 후 몇몇 독자들이 OpenAI를 사용하기 위한 높은 진입 장벽을 언급했어요. 이 문제는 정말 어려운 문제이지만 극복할 수 있는 문제에요. 하지만 이 글은 그 문제를 해결하는 게 아니라 OpenAI 대안인 Ollama를 소개하기 위한 글이에요. 작년 말에 k8sgpt는 CNCF Sandbox에 들어갔어요.\n\n# 1. Ollama 설치하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Ollama](/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_1.png)\n\nOllama은 로컬이나 클라우드에서 쉽게 설치하고 실행할 수 있는 여러 대형 모델을 지원하는 오픈 소스 대형 모델 도구입니다. 매우 사용하기 편리하며 간단한 명령어로 실행할 수 있습니다. macOS에서는 homebrew를 사용하여 다음 명령어로 쉽게 설치할 수 있습니다:\n\n```js\nbrew install ollama\n```\n\n최신 버전은 0.1.44입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nollama -v\n경고: 실행 중인 Ollama 인스턴스에 연결할 수 없습니다\n경고: 클라이언트 버전은 0.1.44입니다\n```\n\n리눅스에서는 공식 스크립트로도 설치할 수 있습니다.\n\n```js\ncurl -sSL https://ollama.com/install.sh | sh\n```\n\nOllama를 시작하고 컨테이너나 K8s 클러스터에서 접근할 수 있도록 환경 변수를 통해 수신 주소를 0.0.0.0으로 설정하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nOLLAMA_HOST=0.0.0.0 ollama start\n```\n\n```js\n...\ntime=2024-06-16T07:54:57.329+08:00 level=INFO source=routes.go:1057 msg=\"127.0.0.1:11434에서 수신 대기 중 (버전 0.1.44)\"\ntime=2024-06-16T07:54:57.329+08:00 level=INFO source=payload.go:30 msg=\"임베디드 파일 추출 중\" dir=/var/folders/9p/2tp6g0896715zst_bfkynff00000gn/T/ollama1722873865/runners\ntime=2024-06-16T07:54:57.346+08:00 level=INFO source=payload.go:44 msg=\"동적 LLM 라이브러리 [metal]\"\ntime=2024-06-16T07:54:57.385+08:00 level=INFO source=types.go:71 msg=\"추론 계산 중\" id=0 library=metal compute=\"\" driver=0.0 name=\"\" total=\"21.3 GiB\" available=\"21.3 GiB\"\n```\n\n# 2. 큰 모델 다운로드 및 실행하기\n\n4월에 Meta에서 오픈 소스로 공개된 인기 있는 큰 모델 중 하나인 Llama3가 있습니다. Llama3에는 8B와 70B 두 가지 버전이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n맥OS에서 실행 중이고, 8B 버전을 선택했어요. 8B 버전은 4.7GB이며, 빠른 인터넷 연결로 다운로드하면 3-4분이 소요돼요.\n\n```js\nollama run llama3\n```\n\n제 M1 Pro에서 32GB 메모리를 사용하고 있는데, 실행하는 데 약 12초 정도 걸려요.\n\n```js\ntime=2024-06-17T09:30:25.070+08:00 level=INFO source=server.go:572 msg=\"llama runner started in 12.58 seconds\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 쿼리마다 약 14초가 소요됩니다.\n\n```js\ncurl http://localhost:11434/api/generate -d '{\n  \"model\": \"llama3\",\n  \"prompt\": \"Why is the sky blue?\",\n  \"stream\": false\n}'\n```\n\n```js\n....\n\"total_duration\":14064009500,\"load_duration\":1605750,\"prompt_eval_duration\":166998000,\"eval_count\":419,\"eval_duration\":13894579000}\n```\n\n# 3. K8sGPT CLI 백엔드 구성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 k8sgpt-operator를 테스트하려면 이 단계를 건너뛸 수 있어요.\n\nk8sgpt의 백엔드로 Ollama REST API를 사용할 거에요. 이 API는 추론 제공자로 기능하며, backend 유형은 localai로 선택했어요. LocalAI는 OpenAI API와 호환되며, 실제 제공자는 여전히 Llama를 실행하는 Ollama일 거예요.\n\n```js\nk8sgpt auth add --backend localai --model llama3 --baseurl http://localhost:11434/v1\n```\n\n이를 기본 제공자로 설정하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nk8sgpt auth default --provider localai\nlocalai로 기본 제공자가 설정되었습니다.\n\n테스트 중:\n\nimage-not-exist 이미지를 사용하여 k8s 내에서 Pod를 생성합니다.\n\nkubectl get po k8sgpt-test\n이름          준비     상태         다시 시작     나이\nk8sgpt-test   0/1     ErrImagePull   0          6초\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n에러를 분석하려면 k8sgpt를 사용해보세요.\n\nk8sgpt analyze --explain --filter=Pod --namespace=default --output=json\n\n{\n  \"provider\": \"localai\",\n  \"errors\": null,\n  \"status\": \"ProblemDetected\",\n  \"problems\": 1,\n  \"results\": [\n    {\n      \"kind\": \"Pod\",\n      \"name\": \"default/k8sgpt-test\",\n      \"error\": [\n        {\n          \"Text\": \"Back-off pulling image \\\"image-not-exist\\\"\",\n          \"KubernetesDoc\": \"\",\n          \"Sensitive\": []\n        }\n      ],\n      \"details\": \"Error: Back-off pulling image \\\"image-not-exist\\\"\\n\\nSolution: \\n1. Check if the image exists on Docker Hub or your local registry.\\n2. If not, create the image using a Dockerfile and build it.\\n3. If the image exists, check the spelling and try again.\\n4. Verify the image repository URL in your Kubernetes configuration file (e.g., deployment.yaml).\",\n      \"parentObject\": \"\"\n    }\n  ]\n}\n\n# 4. k8sgpt-operator 배포 및 설정하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nk8sgpt-operator은 클러스터 내에서 k8sgpt를 자동화할 수 있습니다. Helm을 사용하여 쉽게 설치할 수 있어요.\n\n```\n\nhelm repo add k8sgpt https://charts.k8sgpt.ai/\nhelm repo update\nhelm install release k8sgpt/k8sgpt-operator -n k8sgpt --create-namespace\n\nk8sgpt-operator는 K8sGPT를 구성하고 분석 결과를 출력하는 Result를 위한 두 가지 CRD를 제공합니다.\n\nkubectl api-resources | grep -i gpt\nk8sgpts core.k8sgpt.ai/v1alpha1 true K8sGPT\nresults core.k8sgpt.ai/v1alpha1 true Result\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOllama의 IP 주소를 baseUrl로 사용하여 K8sGPT를 구성하세요.\n\n```js\nkubectl apply -n k8sgpt -f - \u003c\u003c EOF\napiVersion: core.k8sgpt.ai/v1alpha1\nkind: K8sGPT\nmetadata:\n  name: k8sgpt-ollama\nspec:\n  ai:\n    enabled: true\n    model: llama3\n    backend: localai\n    baseUrl: http://198.19.249.3:11434/v1\n  noCache: false\n  filters: [\"Pod\"]\n  repository: ghcr.io/k8sgpt-ai/k8sgpt\n  version: v0.3.8\nEOF\n```\n\nK8sGPT CR을 생성한 후, 연산자(operator)가 이를 위한 파드를 자동으로 만듭니다. result CR을 확인하면 동일한 결과가 표시됩니다.\n\n```js\nkubectl get result -n k8sgpt -o jsonpath='{.items[].spec}' | jq .\n{\n  \"backend\": \"localai\",\n  \"details\": \"Error: Kubernetes is unable to pull the image \\\"image-not-exist\\\" due to it not existing.\\n\\nSolution: \\n1. Check if the image actually exists.\\n2. If not, create the image or use an alternative one.\\n3. If the image does exist, ensure that the Docker daemon and registry are properly configured.\",\n  \"error\": [\n    {\n      \"text\": \"Back-off pulling image \\\"image-not-exist\\\"\"\n    }\n  ],\n  \"kind\": \"Pod\",\n  \"name\": \"default/k8sgpt-test\",\n  \"parentObject\": \"\"\n}\n```\n","ogImage":{"url":"/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_0.png"},"coverImage":"/assets/img/2024-06-23-K8sGPTOllamaAFreeKubernetesAutomatedDiagnosticSolution_0.png","tag":["Tech"],"readingTime":9},{"title":"GKE 멀티 클러스터 서비스MCS 처음에는 마법 같은 느낌이 드는 이유","description":"","date":"2024-06-23 22:58","slug":"2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst","content":"\nMulti-Cluster Services (MCS)은 한 GKE 클러스터에서 워크로드 간 통신을 허용하는 일반적인 문제에 대한 해결책을 제공합니다. 이 서비스는 이 글에서 MCS가 어떻게 구성되는지, 어떻게 구축되는지, 그리고 클러스터와 주변 인프라 수준에서 어떤 구성 요소가 관련되어 있는지 살펴볼 것입니다. 이를 통해 서비스에 대한 심층적인 이해를 얻고 문제 해결에 대한 신뢰를 높일 수 있을 것입니다.\n\n만약 플릿 및 MCS에 대한 일반 소개를 원한다면 Kishore Jagannath의 훌륭한 두 부분 블로그 포스트를 추천합니다.\n\n이 블로그 포스트에서는 조금 다른 방식으로 MCS의 구성 요소를 분석할 것입니다. 운이 좋다면 이런 과정이 기술이 마법처럼 느껴질 때의 어린 시절 추억을 떠올리게 할지도 모릅니다. 그러나 다행히 이번에는 가족용 계산기를 조금 복잡하게 살펴보고 고쳤다가 다시 조립했을 때 처럼 부모님께서 화를 내지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 우선 순위를 정하자 — MCS를 사용해야 할 때\n\nMCS의 내부 작동 방식을 더 깊이 들어가기 전에, 교차 클러스터 통신 영역을 탐색하기 전에 먼저 한 걸음 물러나보겠습니다. 아래 다이어그램에서 볼 수 있듯이, MCS는 쿠버네티스 또는 구체적으로 GKE 클러스터에서 실행되는 서비스를 사용하는 것을 허용하기 위한 여러 가능한 솔루션 중 하나에 불과합니다.\n\nMCS는 같은 플리트 내의 다른 클러스터에서 실행되는 팟에 백업된 서비스와 통신할 수 있도록 하는 작업에 집중하는 비교적 간단한 해결책입니다. 동일한 교차 클러스터 통신은 GKE의 Service Mesh나 Istio와 같은 서비스 메시의 다중 클러스터 기능이나 Cilium과 같은 네트워크 수준의 도구를 사용하여 구현할 수도 있습니다. 이미 이러한 방식 중 하나를 사용하고 있거나 교차 클러스터 통신 상단에 트래픽 관리, 투명 인증 또는 텔레미트리와 같은 기능을 사용할 계획이라면, 아마도 MCS는 너무 단순해서 당신의 사용 사례에 적합하지 않을 것이며, 대신 서비스 메시를 사용하는 것이 좋을 것입니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# MCS 데모 준비 중\n\n이 블로그 포스트에서 실제 탐구를 따라하고 싶다면, MCS와 놀 수 있도록 필요한 API를 활성화하고 GKE autopilot 클러스터 두 개를 생성하는 단계를 수행할 수 있습니다. 대신 표준 GKE 클러스터를 사용하고 싶다면, 여기 제공된 예시도 잘 작동할 것입니다.\n\n```js\nexport PROJECT_ID=\u003c여기에 프로젝트 ID 입력\u003e\n\ngcloud services enable \\\n    compute.googleapis.com \\\n    container.googleapis.com \\\n    multiclusterservicediscovery.googleapis.com \\\n    gkehub.googleapis.com \\\n    cloudresourcemanager.googleapis.com \\\n    trafficdirector.googleapis.com \\\n    dns.googleapis.com \\\n    --project=$PROJECT_ID\n\ngcloud container clusters create-auto \"test-us-cluster\" \\\n  --region \"us-central1\" --enable-master-authorized-networks \\\n  --network \"default\" --subnetwork \"default\" \\\n  --services-ipv4-cidr 10.99.0.0/20 \\\n  --async --project \"$PROJECT_ID\"\n\ngcloud container clusters create-auto \"test-eu-cluster\" \\\n  --region \"europe-west1\" --enable-master-authorized-networks \\\n  --network \"default\" --subnetwork \"default\" \\\n  --services-ipv4-cidr 10.99.16.0/20 \\\n  --async --project \"$PROJECT_ID\"\n```\n\n클러스터가 준비되면, 피트에서 다중 클러스터 기능을 활성화하고 새로 생성된 클러스터를 피트에 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngcloud container fleet multi-cluster-services enable --project $PROJECT_ID\n\ngcloud container fleet memberships register test-us-cluster \\\n   --gke-cluster us-central1/test-us-cluster \\\n   --enable-workload-identity \\\n   --project $PROJECT_ID\n\ngcloud container fleet memberships register test-eu-cluster \\\n   --gke-cluster europe-west1/test-eu-cluster \\\n   --enable-workload-identity \\\n   --project $PROJECT_ID\n```\n\n우리 클러스터 상황을 확인해보죠. 이를 위해 europe-west1 지역의 클러스터에 연결해봅시다:\n\n```js\ngcloud container clusters get-credentials test-eu-cluster --region europe-west1 --project $PROJECT_ID\n```\n\nMCS의 흔적이 이미 존재하는지 확인하기 위해 우리의 네임스페이스 리소스를 나열해보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl get ns\n```\n\n네임스페이스 목록에는 \"gke-mcs\"라는 새로 생성된 네임스페이스가 포함되어 있어야 합니다. 해당 네임스페이스 이름은 이미 플릿에서 활성화된 MCS 기능과 관련이 있을 가능성이 높으며, 또한 해당 네임스페이스가 만들어진 시간은 클러스터를 플릿에 등록했을 때와 일치합니다.\n\n\"gke-mcs\" 네임스페이스를 좀 더 자세히 알아보고 이미 실행 중인 것이 있는지 확인해 봅시다:\n\n```js\nkubectl get all -n gke-mcs # 이 명령은 gke-mcs-importer에 대한 배포를 보여줍니다.\n\nkubectl logs -n gke-mcs -l k8s-app=gke-mcs-importer --tail -1 # Importer의 로그를 얻기 위해\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로그에서는 수입 업체가 트래픽 디렉터 API에 액세스할 권한이 아직 부여되지 않았기 때문에 권한 오류가 발생할 수 있습니다:\n\n```js\n핸들러 오류: 스트림을 통해 ADS 응답 수신 중: 권한이 거부되었습니다:\nrpc 오류: 코드 = PermissionDenied desc = 권한\n'trafficdirector.networks.getConfigs'이 자원에 대해 거부되었습니다\n'//trafficdirector.googleapis.com/projects/...' (또는 존재하지 않을 수 있음).\n```\n\n수입 업체의 워크로드 ID를 사용하여 Cloud DNS에서 정보를 가져오는 데 사용되는 네트워크 뷰어 역할을 할당함으로써 이 문제를 해결할 수 있습니다:\n\n```js\ngcloud projects add-iam-policy-binding $PROJECT_ID \\\n    --member \"serviceAccount:$PROJECT_ID.svc.id.goog[gke-mcs/gke-mcs-importer]\" \\\n    --role \"roles/compute.networkViewer\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 로그 문을 다시 실행하면 예상대로 폴링이 작동하지만 우리를 위해 생성된 존이 없다는 것을 확인할 것입니다. 이제 클러스터는 다중 클러스터 서비스를 배포할 준비가 되었습니다.\n\n# 데모 응용 프로그램 배포\n\n두 GKE 클러스터 간의 컨텍스트 전환을 쉽게하기 위해 먼저 클러스터 컨텍스트의 이름을 변경합니다. 또는 클라우드 셸에 미리 설치된 kubectx 단축키를 사용할 수도 있습니다.\n\n```js\ngcloud container clusters get-credentials test-us-cluster --region us-central1 --project $PROJECT_ID\nkubectl config rename-context \"$(kubectl config current-context)\" mcs-us\n\ngcloud container clusters get-credentials test-eu-cluster --region europe-west1 --project $PROJECT_ID\nkubectl config rename-context \"$(kubectl config current-context)\" mcs-eu\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 지나치게 화려한 애플리케이션이 필요하지 않습니다. 결국, 다른 GKE 클러스터에서 실행 중인 특정 서비스에 도달할 수 있는지 여부를 보여주기만 원합니다. 데모 목적으로, 우리의 EU 클러스터에서 기존의 hello-web 예제를 배포하고 클러스터 내에서 전통적인 ClusterIP 서비스로 노출합니다.\n\n```js\nkubectl create ns shared-services --context mcs-eu\n\nkubectl apply -f https://raw.githubusercontent.com/GoogleCloudPlatform/kubernetes-engine-samples/main/quickstarts/hello-app/manifests/helloweb-deployment.yaml -n shared-services  --context mcs-eu\n\nkubectl expose deployment/helloweb --port 8080 -n shared-services --context mcs-eu\n```\n\n서비스가 생성되면 클러스터 내에서 기대대로 자동으로 생성된 k8s cluster.local DNS 이름을 사용하여 성공적으로 호출할 수 있습니다:\n\n```js\nkubectl run test-curl --image=curlimages/curl -it --rm --pod-running-timeout=4m --context mcs-eu -- curl -v http://helloweb.shared-services.svc.cluster.local:8080\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n흥미로운 사이드 노트와 나중에 중요한 세부 정보는, 우리의 GKE 클러스터가 클라우드 DNS를 사용한다는 것입니다. 따라서 Google Cloud 콘솔의 Cloud DNS UI에서 우리 서비스를 위해 자동으로 생성된 A 레코드도 볼 수 있습니다. DNS 존에는 명시적으로 이 Cloud DNS 존이 특정 GKE 클러스터에서만 사용 가능하다고 나와 있습니다. 이 DNS 존은 어떤 VPC에도 첨부되어 있지 않기 때문에 전형적인 사설 존은 아닙니다.\n\n![그림](/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_2.png)\n\nMCS의 목표는 미국 클러스터에서 이 서비스를 사용할 수 있도록 하는 것입니다. 서비스를 노출하기 전에 기본 서비스에서 어떤 일이 발생하는지 살펴봅시다. 아마도 예상하시겠지만, EU 클러스터에서 사용한 DNS 레코드는 미국 클러스터에서 사용할 수 없으며, 심지어 서비스 IP도 미국 클러스터에서 도달할 수 없습니다. 클러스터를 생성할 때 RFC 1918 범위를 사용했지만, 미국 클러스터에서는 이러한 클러스터를 호출할 수 없기 때문입니다.\n\n```js\n# 호스트 이름을 해결할 수 없다는 오류로 실패합니다\nkubectl run test-curl --image=curlimages/curl -it --rm --pod-running-timeout=4m --context mcs-us -- curl -v http://helloweb.shared-services.svc.cluster.local:8080\n\n# 타임아웃으로 실패합니다\nEU_SERVICE_IP=\"$(kubectl get svc -l app=hello -n shared-services --context mcs-eu -ojsonpath='{.items[*].spec.clusterIP}')\"\nkubectl run test-curl --image=curlimages/curl -it --rm --pod-running-timeout=4m --context mcs-us -- curl -v \"http://$EU_SERVICE_IP:8080\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희가 겪고 있는 문제는 미국 클러스터의 작업량이 EU 클러스터의 작업량에 도달하지 못하는 것이 아니라, 아래에서 직접 Pod IP를 호출하여 증명할 수 있는 것입니다. 네트워크 수준에서는 VPC 네이티브 클러스터 네트워킹을 사용하여 VPC 내에서 Pod IP가 경로 지정될 수 있기 때문에 이 작업이 가능합니다. 아래 예시에서는 양 쪽 클러스터의 API 서버에 연결하여 이를 활용하여 서로간의 교차 클러스터 통신을 증명하는 데 사용합니다.\n\n```js\nEU_POD_IP=\"$(kubectl get po -l app=hello -n shared-services --context mcs-eu -ojsonpath='{.items[*].status.podIP}')\"\n\nkubectl run test-curl --image=curlimages/curl -it --rm --pod-running-timeout=4m --context mcs-us -- curl -v http://$EU_POD_IP:8080\n```\n\n물론 포드 IP를 명시적으로 Kubernetes API에 쿼리하는 것은 확장 가능한 해결책이 아닙니다. 이것이 클러스터 간에 서비스 발견을 자동화하기 위해 MCS로 전환해야 하는 이유입니다.\n\n# MCS로 서비스 내보내기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMCS에서 실행 중인 서비스를 EU 클러스터에서 내보내려면 EU 클러스터에 ServiceExport 리소스를 만듭니다. 동시에 해당 서비스를 가져올 US 클러스터의 이름 공간을 만듭니다:\n\n```js\nkubectl create ns shared-services --context mcs-us\n\nkubectl apply --context mcs-eu -f - \u003c\u003cEOF\napiVersion: net.gke.io/v1\nkind: ServiceExport\nmetadata:\n namespace: shared-services\n name: helloweb\nEOF\n```\n\n이제 방금 내보낸 서비스와 관련된 로그 항목이 포함된 MCS 가져오기자 로그를 US 클러스터에서 살펴볼 수 있습니다:\n\n```js\nkubectl logs -n gke-mcs -l k8s-app=gke-mcs-importer --tail=25 --context mcs-us\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n미국 클러스터가 EU에서 실행 중인 작업에 대한 정보를 수신했음을 나타내고 해당 정보를 자동으로 사용하는 엔드포인트가 만들어 졌음을 나타내고 있습니다:\n\n```js\nADS 응답을 받음 (europe-west1-d), 유형: type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment\neurope-west1-d에서 1개의 negs로부터 업데이트\n엔드포인트 \"gke-mcs-...\" 생성 중\n```\n\nMCS importer를 통해 미국 클러스터에서 자동으로 생성된 리소스를 살펴봅시다.\n\n```js\nkubectl get ServiceImport -n shared-services --context mcs-us\n\nkubectl get Service -n shared-services --context mcs-us\n\nkubectl get Endpoints -n shared-services --context mcs-us\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 명령어에서 나열된 엔드포인트들은 EU 클러스터에서 실행 중인 워크로드의 pod ip를 포함하고 있습니다. 이는 ServiceExport 리소스가 이전 섹션에서 수동으로 제공한 교차 클러스터 리소스 식별을 자동화했다는 것을 의미합니다. 이제 위에서 찾은 서비스와 엔드포인트를 테스트하고 미국 클러스터 내에서부터 호출해 봅시다:\n\n```js\nSVC_NAME=$(kubectl get service -o=jsonpath='{.items[?(@.metadata.annotations.net\\.gke\\.io/service-import==\"helloweb\")].metadata.name}' -n shared-services --context mcs-us)\n\n\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-us -- \\\n  curl -v http://$SVC_NAME.shared-services.svc.cluster.local:8080\n```\n\n작동이 잘 되었네요. 이번에는 EU 클러스터의 API 서버와 통신하여 워크로드를 실행 중인 pod의 IP를 찾아낼 필요가 없었습니다. 왜냐하면 Service Import가 이미 해당 정보를 동기화했기 때문입니다. 유일하게 해결해야 할 문제는 \"gke-mcs-`해시`\" 형식으로 자동 생성된 MCS importer의 서비스 이름이 사전에 쉽게 알려지지 않는다는 것입니다. 위 예에서도 다시 API 서버를 사용하여 올바른 서비스 이름을 검색했습니다. 실제 사용 사례에서는 워크로드가 원격 서비스를 호출하기 전에 쿠버네티스 API 서버에 문의하는 것을 원치 않는 것은 당연합니다. 이는 추상화를 깨뜨리고 파드의 서비스 계정에 불필요한 권한이 필요하게 됩니다.\n\n클러스터셋 로컬 호스트 이름의 호기심스러운 사례#\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자동 생성되는 기억하기 어려운 서비스 이름 문제를 해결하기 위해 MCS가 제공하는 편리한 DNS 기반 솔루션을 사용할 수 있습니다. 각 가져온 서비스에 대해 \"SERVICE_EXPORT_NAME.NAMESPACE.svc.clusterset.local\" 형식의 DNS 항목을 만듭니다. 이 호스트 이름을 사용하여 생성된 서비스 이름을 식별하는 추가 단계 없이 서비스를 호출할 수 있는 결정론적인 방법이 생겼습니다. 가져온 서비스의 호스트 이름을 작성하고 클러스터 중 하나에서 팟 내부에서 호출할 수 있습니다:\n\n```js\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-eu -- \\\n  curl http://helloweb.shared-services.svc.clusterset.local:8080\n\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-us -- \\\n  curl http://helloweb.shared-services.svc.clusterset.local:8080\n```\n\n참고: 위 요청 중 하나에 대해 오류가 발생하면 DNS 캐싱 때문일 수 있습니다. 관리 DNS 존이 클러스터셋 로컬 DNS A 레코드를 나열하면 결국 팟에서 인식할 수 있습니다.\n\n처음에 예상하지 못한 흥미로운 점 중 하나는 clusterset.local DNS 존이 Cloud DNS UI에 노출되지 않는다는 것입니다. 하지만 우리 호스트 이름을 위해 레코드 세트가 있는 하부 관리 DNS 존이 있음을 다음 명령어를 실행하여 확인할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngcloud dns managed-zones list --location=us-central1-b\n\ngcloud dns managed-zones describe \u003cname of the zone from above\u003e --location=us-central1-b\n\ngcloud dns record-sets list --location=us-central1-b --zone \u003cname of the zone from above\n```\n\n만약 클라우드 콘솔에서 clusterset.local 호스트명을 보고 싶다면 Traffic Director로 이동할 수 있어요. GCP 콘솔에서 Traffic Director UI를 열면 라우팅 규칙 맵 탭에서 우리의 플릿과 연결된 정방향 규칙 및 helloweb 서비스가 연결된 서비스로 나열된 라우팅 규칙을 볼 수 있어요. 또한 이에 연결된 정방향 규칙도 표시돼요.\n\n\u003cimg src=\"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_3.png\" /\u003e\n\n라우팅 규칙의 이름을 클릭하면 정방향 규칙과 라우팅 규칙에서 사용된 호스트명 목록을 볼 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_4.png\" /\u003e\n\n# [옵션 부분] 계산기를 해체하고 다시 조립하는\n\n만약 그게 맞다면, 우리의 호스트 이름이 실제로 전달 규칙에서 처리되고 내부 로드 밸런서의 경우처럼 연결된 NEG로 보내진다고 가정하는 유혹을 느낄 수 있습니다. 이것이 맞다면, 우리는 미국 클러스터의 쿠버네티스 리소스가 EU 서비스와 통신하기 위해서는 서비스와 엔드포인트에 대한 Kubernetes 리소스가 필요하지 않을 것입니다. 여기서 우리는 다시 시작점으로 돌아와 계산기를 해체해 우리의 이해를 확인하는 유사성을 다시 살펴보는 지점에 도달합니다.\n\n이 가정을 확인하기 위해 미국 클러스터의 shared-services 네임스페이스를 삭제해볼 수 있습니다. 이렇게 하면 우리가 이전에 살펴본 서비스와 엔드포인트를 포함한 모든 네임스페이스 리소스를 삭제합니다. 마지막으로 미국 클러스터의 파드에서 curl을 다시 실행하고 싶을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl delete ns shared-services --context mcs-us\n\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-us -- \\\n  curl http://helloweb.shared-services.svc.clusterset.local:8080\n```\n\n위의 curl 명령은 실패할 것이며, MCS Importer가 shared-services 네임스페이스에 생성한 리소스가 실제로 필요했음을 확인합니다. 이것은 클러스터 외부의 라우트 규칙에서 호스트 이름이 구성되어 있더라도 해당된다는 것을 의미합니다. 계산기를 되돌려 놓고 MCS Importer가 리소스를 다시 생성할 수 있도록 shared-services 네임스페이스를 재생성합시다.\n\n```js\nkubectl create ns shared-services --context mcs-us\n```\n\nImporter가 서비스 및 엔드포인트 리소스를 다시 생성한 후, 우리는 버보즈 출력으로 curl 명령을 다시 실행합니다. 이렇게 하면 서비스를 삭제했을 때 위와 같은 이유로 실패했던 것을 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl run test-curl --image=curlimages/curl -it --rm \\\n  --pod-running-timeout=4m --context mcs-us -- \\\n  curl http://helloweb.shared-services.svc.clusterset.local:8080\n```\n\n여기서 볼 수 있듯이 호스트 이름이 우리 서비스의 클러스터 IP로 해석되어 MCS에 접근하기 위해 서비스 리소스가 여전히 필요합니다.\n\n# 결론\n\n이 모든 실험과 탐구를 통해 MCS에 대한 우리의 이해를 완성할 수 있습니다. 우리는 지금 관련된 구성 요소를 이해하고, 처음에는 다소 마술적으로 보였던 기능을 가능하게 하는 것에 대해 더 나은 그림을 그릴 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![GKE Multi-Cluster Services](/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_5.png)\n\n이 게시물에서는 MCS를 실제로 경험하면서 뿐만 아니라 여러 가지를 부수고 다시 조립하는 과정으로 탐구했습니다. 우리는 한 클러스터에 서비스를 생성하고, 그런 다음 MCS를 단계별로 구축하고 워크로드에서 서비스를 소비하는 방식으로 다른 클러스터에서 실행되는 워크로드 사이의 통신을 가능하게 하는 리소스를 살펴봄으로써 MCS를 살펴보았습니다.\n\n자신만의 멀티 클러스터 서비스 여정을 계속해 보고 싶다면 문서에서의 MCS 예제를 살펴보고, 멀티 클러스터 통신 위에 추가 기능을 제공하는 서비스 메시와 같은 대체 구현도 고려해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_0.png"},"coverImage":"/assets/img/2024-06-23-GKEMulti-ClusterServicesMCSFeelslikemagicatfirst_0.png","tag":["Tech"],"readingTime":18},{"title":"M 시리즈 맥에서 Multipass로 로컬 클러스터 쉽게 만들기","description":"","date":"2024-06-23 22:57","slug":"2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips","content":"\n\u003cimg src=\"/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_0.png\" /\u003e\n\n이 기사는 여러분의 기계에 k3s Kubernetes 환경을 설정하여 여러분의 POC를 테스트하고 CNCF 랜드스케이프의 더 많은 도구들을 탐색하는 방법을 보여줍니다.\n\n여러분의 Mac에서 K3S/K8S를 직접 실행할 수 없기 때문에 여러분은 Mac 위에 Linux 레이어를 설정해야 합니다. Mac M1에서 Linux VM을 설정하는 쉬운 방법은 Multipass를 사용하는 것입니다.\n\n왜 Multipass를 사용해야 하는지요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번의 명령어로 즉시 Ubuntu VM을 얻을 수 있어요.\n\n먼저, Multipass를 설치해야 해요.\n\n```js\nbrew install --cask multipass\n```\n\n설치되면 메모리 및 디스크 공간을 지정하여 새 VM을 생성해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmultipass launch --name k3s --memory 4G --disk 40G\n```\n\n우리는 심지어 VM에서 Mac 디렉터리를 마운트할 수도 있어요.\n\n```js\nmkdir ~/test/k8s\nmultipass mount ~/test/k8s k3s:~/k8s\n```\n\n호스트 디렉토리에서 변경 사항을 만들고 VM 내부의 클러스터에 변경 사항을 적용하려고 할 때 유용할 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nVM 내부에서 설치 스크립트를 실행하여 k3s를 설치할 수 있어요.\n\n```js\nmultipass shell k3s\n\nubuntu@k3s:~$ curl -sfL https://get.k3s.io | K3S_KUBECONFIG_MODE=\"644\" sh -\n```\n\nVM이 시작되면 VM 세부 정보를 확인할 수 있어요.\n\n```js\nmultipass info k3s\n\nName:           k3s\nState:          Running\nSnapshots:      0\nIPv4:           192.168.64.7\n                10.42.0.0\n                10.42.0.1\nRelease:        Ubuntu 24.04 LTS\nImage hash:     8263b4713896 (Ubuntu 24.04 LTS)\nCPU(s):         1\nLoad:           0.29 0.22 0.13\nDisk usage:     2.8GiB out of 38.7GiB\nMemory usage:   814.2MiB out of 3.8GiB\nMounts:         /Users/ibrahimmohamed/test/k8s =\u003e ~/k8s\n                    UID map: 501:default\n                    GID map: 20:default\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```shell\nK3S_IP=$(multipass info k3s | grep IPv4 | awk '{print $2}')\n\necho $K3S_IP\n\n192.168.64.7# kubeconfig 다운로드\n\nmultipass exec k3s cp /etc/rancher/k3s/k3s.yaml /home/ubuntu/k8s/\n\ncd ~/test/k8s\n\nsed -i '' \"s/127.0.0.1/${K3S_IP}/\" k3s.yaml\n\nexport KUBECONFIG=${PWD}/k3s.yaml\n```\n\n이제 kubeconfig이 있습니다:\n\n머신에 kubectl을 설치하세요:\n\n```shell\nbrew install kubectl\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```sh\nkubectl get nodes -o wide\n\nNAME   STATUS   ROLES                  AGE   VERSION        INTERNAL-IP    EXTERNAL-IP   OS-IMAGE           KERNEL-VERSION     CONTAINER-RUNTIME\nk3s    Ready    control-plane,master   12m   v1.29.5+k3s1   192.168.64.7   \u003cnone\u003e        Ubuntu 24.04 LTS   6.8.0-35-generic   containerd://1.7.15-k3s1\n\n\nkubectl get pods -A\n\nNAMESPACE     NAME                                      READY   STATUS      RESTARTS   AGE\nkube-system   coredns-6799fbcd5-dc8nd                   1/1     Running     0          41m\nkube-system   local-path-provisioner-6c86858495-9q524   1/1     Running     0          41m\nkube-system   helm-install-traefik-crd-p4xhh            0/1     Completed   0          41m\nkube-system   metrics-server-54fd9b65b-vmhvc            1/1     Running     0          41m\nkube-system   helm-install-traefik-5snzg                0/1     Completed   1          41m\nkube-system   svclb-traefik-ae8c3cf6-hntgn              2/2     Running     0          40m\nkube-system   traefik-7d5f6474df-48vsc                  1/1     Running     0          40m\n```\n\nNow let's view it through Lens\n\n![Lens](/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_1.png)\n\nNow you are ready to run any POC on your local machine.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nk3s 실험이 끝나면 VM을 삭제할 수 있습니다.\n\n```js\nmultipass delete k3s\nmultipass purge\n```\n\n화이팅!\n","ogImage":{"url":"/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_0.png"},"coverImage":"/assets/img/2024-06-23-LocalClusterMadeEasywithMultipassonMacMchips_0.png","tag":["Tech"],"readingTime":5},{"title":"Docker Compose를 사용한 로컬 MongoDB Replica Set 설정 가이드 완벽한 방법","description":"","date":"2024-06-23 22:55","slug":"2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed","content":"\n![이미지](/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_0.png)\n\n이 블로그 포스트에서는 MongoDB 레플리카 세트를 로컬에서 실행할 수 있는 다양한 Docker Compose 설정을 탐색해보려고 합니다. 레플리카 세트는 MongoDB의 강력한 기능인 트랜잭션, 변경 스트림 또는 oplog에 액세스하는 것과 같은 것들을 활용하려는 사람들에게 필수적입니다. 로컬에서 MongoDB 레플리카 세트를 실행하면 이러한 기능에 액세스할 뿐만 아니라 복제 메커니즘 및 일반적인 오류 허용성을 실험할 수 있는 일회용 샌드박스로도 작용합니다. 더 이상 기다리지 말고 시작해 봅시다!\n\n# 단일 노드 레플리카 세트 설정\n\n첫 번째 설정은 몇 초만에 MongoDB 단일 노드 레플리카 세트를 실행할 수 있는 준비된 Docker Compose 파일입니다. 클라우드 환경에서는 고가용성과 오류 허용성을 보장하기 위해 복수 노드가 필요할 것입니다. 그러나 로컬 개발에는 단일 노드 레플리카 세트가 충분하며 트랜잭션 및 변경 스트림에 액세스할 수 있습니다. 이는 로컬에서 MongoDB 인스턴스를 실행하는 데 필요한 CPU 및 메모리 리소스를 줄여 Google Chrome을 더 행복하게 만들어줍니다. rs0라는 이름의 단일 노드 레플리카 세트를 실행하는 docker-compose.yml 파일은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nversion: \"3.8\"\n\nservices:\n  mongo1:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27017\"]\n    ports:\n      - 27017:27017\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n    healthcheck:\n      test: echo \"try { rs.status() } catch (err) { rs.initiate({_id:'rs0',members:[{_id:0,host:'host.docker.internal:27017'}]}) }\" | mongosh --port 27017 --quiet\n      interval: 5s\n      timeout: 30s\n      start_period: 0s\n      start_interval: 1s\n      retries: 30\n    volumes:\n      - \"mongo1_data:/data/db\"\n      - \"mongo1_config:/data/configdb\"\n\nvolumes:\n  mongo1_data:\n  mongo1_config:\n```\n\n여기에서 무슨 일이 벌어지고 있는지 이해해보도록 합시다. 먼저, 우리는 이 글 작성 시 최신 MongoDB Community Edition 이미지인 mongo:7.0을 사용하고 있습니다. rs0라는 레플리카 셋 이름을 지정하기 위해 --replSet 플래그를 사용하고 있습니다. --bind_ip_all 플래그는 MongoDB 인스턴스를 모든 IPv4 주소에 바인딩하기 위해 사용되었으며, --port 플래그는 MongoDB 인스턴스가 수신 대기할 포트를 지정하기 위해 사용되었습니다. 27017은 MongoDB의 기본 포트입니다. 컨테이너 포트 27017을 호스트 포트 27017로 매핑하여 호스트 머신에서 MongoDB 인스턴스에 연결할 수 있도록 하고 있습니다. extra_hosts 섹션은 host.docker.internal 호스트 이름을 호스트 머신의 IP 주소에 매핑하는 데 사용되고 있습니다.\n\nhealthcheck 기능은 우리의 설정에서 레플리카 셋을 초기화하기 위해 재사용되었습니다. 레플리카 셋은 rs.initiate() 명령을 사용하여 초기화되어야 하며(이것은 replSetInitiate 데이터베이스 명령의 동일한 것입니다), 이 작업은 MongoDB 인스턴스가 시작되는 동안 실패할 수 있으므로 healthcheck 기능을 사용하여 작업이 성공할 때까지 재시도하고 있습니다. Docker의 healthcheck은 시작 단계에서 조금 더 공격적일 수 있도록 허용해줍니다. 이것이 start_interval이 1초로만 설정되어 있는 이유입니다. 유감스럽게도 Docker Compose에서 start_interval이 아직 지원되지 않고 있지만, 이것은 사양의 일부입니다. 이 기능에 대한 진행 상황은 해당 GitHub 이슈에서 확인할 수 있습니다. 그 동안 우리는 5초로 일반 interval 값을 설정할 수 있으며, 과도하게 공격적이거나 너무 오랫동안 기다리는 중간 지점입니다. 그러나 start_interval이 구현되면 interval 값을 몇 분 동안 올릴 수 있을 것입니다.\n\n여기서 rs.status()를 사용한 이유는 레플리카 셋이 초기화되지 않았을 때 예외를 throw하기 때문에, 레플리카 셋이 초기화될 때까지 rs.initiate()를 호출하기에 편리합니다. 그 후에는 rs.status()를 주기적으로 호출하는 것은 부담이 되지 않습니다. 또한 여기서 healthcheck가 의도한 대로 작동하고 있다는 점에 유의하십시오. 왜냐하면 우리는 bash 명령이 처음으로 레플리카 셋을 초기화하거나 레플리카 셋이 이미 초기화되어 있는 경우에만 성공적인 종료 코드를 리턴할 것으로 기대하고 있기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 우리는 mongo1_data라는 Docker 볼륨에 데이터를 영속화합니다. 이것은 컨테이너가 중지될 때 데이터가 손실되지 않도록 하는 최선의 방법입니다. 또 다른 볼륨인 mongo1_config은 복제 세트 구성을 영속화하는 데 사용됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*4FJZGrr5m7VuvOk-SmYxcg.gif)\n\n이 단일 노드 MongoDB 복제 세트에 액세스하기 위한 연결 문자열은 다음과 같습니다:\n\n```js\nmongodb://127.0.0.1:27017/?replicaSet=rs0\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쓰림 노드 복제본 설정\n\n이전에 말했듯이, 단일 노드 복제본은 로컬 개발에 충분합니다. 그러나 장애 허용성 및 고 가용성을 실험하려면 여러 노드가 필요합니다. 프로덕션 용도로 사용할 경우, MongoDB 문서에서는 적어도 세 개의 노드를 갖는 것을 권장합니다. 첫 번째 컨테이너는 기본 노드가 되고, 나머지 두 개의 컨테이너는 보조 노드가 됩니다. 다음은 rs0라는 세 개의 노드로 구성된 쓰림 복제본을 실행하기 위한 docker-compose.yml 파일입니다:\n\n```js\nversion: \"3.8\"\n\nservices:\n  mongo1:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27017\"]\n    ports:\n      - 27017:27017\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n    healthcheck:\n      test: echo \"try { rs.status() } catch (err) { rs.initiate({_id:'rs0',members:[{_id:0,host:'host.docker.internal:27017',priority:1},{_id:1,host:'host.docker.internal:27018',priority:0.5},{_id:2,host:'host.docker.internal:27019',priority:0.5}]}) }\" | mongosh --port 27017 --quiet\n      interval: 5s\n      timeout: 30s\n      start_period: 0s\n      start_interval: 1s\n      retries: 30\n    volumes:\n      - \"mongo1_data:/data/db\"\n      - \"mongo1_config:/data/configdb\"\n\n  mongo2:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27018\"]\n    ports:\n      - 27018:27018\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n    volumes:\n      - \"mongo2_data:/data/db\"\n      - \"mongo2_config:/data/configdb\"\n\n  mongo3:\n    image: mongo:7.0\n    command: [\"--replSet\", \"rs0\", \"--bind_ip_all\", \"--port\", \"27019\"]\n    ports:\n      - 27019:27019\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n    volumes:\n      - \"mongo3_data:/data/db\"\n      - \"mongo3_config:/data/configdb\"\n\nvolumes:\n  mongo1_data:\n  mongo2_data:\n  mongo3_data:\n  mongo1_config:\n  mongo2_config:\n  mongo3_config:\n```\n\n이 구성에서 기본 노드를 중지하고 보조 노드가 새로운 기본 노드를 선택하는 방식을 확인할 수 있습니다. 이 설정에서 mongo1 컨테이너에는 다른 두 컨테이너보다 약간 더 높은 우선순위가 부여됩니다. 이는 복제본 세트가 완전히 기능할 때 mongo1 컨테이너가 기본 노드로 선출되도록 하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보조 노드 중 하나를 중지하고 레플리카 세트가 계속 작동하는지 확인해 볼 수도 있어요. 모든 노드를 중지해 보고 레플리카 세트가 작동을 멈추는지도 확인할 수 있어요. 이는 내결함 허용성과 고가용성을 실험하는 좋은 방법이에요. 레플리카 세트 상태를 쿼리하고 어느 노드가 주 노드인지 확인하려면 rs.status() 몽고 쉘 명령어를 사용하세요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*w9Oxx6FtrIJ4SMj2ySOApA.gif)\n\n3개 노드 레플리카 세트 연결 문자열은:\n\n```js\nmongodb://127.0.0.1:27017,127.0.0.1:27018,127.0.0.1:27019/?replicaSet=rs0\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 연결 문제 해결하기\n\n![이미지](/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_1.png)\n\n만약 MongoDB 복제본 세트에 연결하는 데 문제가 있다면 Docker가 실행 중인지 확인해주세요. 또한 host.docker.internal 호스트명이 호스트 머신의 IP 주소로 해석될 수 있도록도 확인해주세요.\n\nWindows에서는 호스트 파일에 \\*.docker.internal 호스트명을 자동으로 추가하는 설정이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinux에서 host.docker.internal을 해결할 수 없는 경우, host.docker.internal을 IP 주소 127.17.0.1로 매핑하기 위해 /etc/hosts 파일에 한 줄을 추가해야 합니다.\n\n# healthcheck에 대한 추가 사항\n\n여기에서 healthcheck을 사용하여 복제 세트를 초기화하는 장점은 docker-compose.yml 파일이 자체 포함되어 있습니다. 수동으로 복제 세트를 초기화하는 것을 선호하는 경우, healthcheck 섹션을 제거하고 rs.initiate() mongosh 명령을 사용하여 복제 세트를 초기화할 수 있습니다.\n\n```js\ndocker compose exec mongo1 mongosh --port 27017 --quiet --eval \"rs.initiate({...})\" --json relaxed\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 docker-compose.yml 파일을 사용할 모든 개발자 여러분께서는 적어도 한 번은 이 작업을 기억해야 합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_0.png"},"coverImage":"/assets/img/2024-06-23-TheonlylocalMongoDBreplicasetwithDockerComposeguideyoulleverneed_0.png","tag":["Tech"],"readingTime":8},{"title":"코드에서 컨테이너로 Maven으로 Spring Boot 앱을 Dockerize하는 방법","description":"","date":"2024-06-23 22:54","slug":"2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven","content":"\n![이미지](/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_0.png)\n\n컨테이너화는 애플리케이션을 배포하는 방식을 혁신적으로 변화시켰습니다. 환경별 일관성을 제공하고 배포 프로세스를 간소화합니다. 이 가이드에서는 Maven을 사용하여 스프링 부트 애플리케이션을 원활하게 도커화하는 방법을 살펴보겠습니다. 개발부터 프로덕션까지 스무스하고 효율적인 워크플로우를 보장합니다.\n\n필수 사항\n\n1. Spring Boot 및 Maven의 기본 지식\n2. 시스템에 Docker가 설치되어 있어야 함\n\n단계 1: 스프링 부트 애플리케이션 설정하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 Spring Boot 애플리케이션을 만들려면 spring initializer (https://start.spring.io/)를 사용하세요. Spring web, Spring Boot dev tools와 같은 기본 종속성을 포함하세요.\n\n![spring initializer](/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_1.png)\n\n단계 2: Maven의 pom.xml에 도커 Maven 플러그인을 추가하세요.\n\nio.fabric8 플러그인은 Maven을 위한 도커 관련 활동의 공식 플러그인입니다.\n이제 새로운 \"containerize\"라는 Maven 프로필을 만들고 해당 프로필에서 도커-Maven 플러그인을 사용할 것입니다. 코드 스니펫을 추가했고, 코드를 설명하기 위해 주석을 사용했습니다.\n이 플러그인의 문서는 여기서 확인할 수 있습니다: https://dmp.fabric8.io/\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n\u003cprofile\u003e\n  \u003cid\u003econtainerize\u003c/id\u003e\n  \u003cbuild\u003e\n   \u003cplugins\u003e\n    \u003cplugin\u003e\n     \u003cgroupId\u003eio.fabric8\u003c/groupId\u003e\n     \u003cartifactId\u003edocker-maven-plugin\u003c/artifactId\u003e\n     \u003cversion\u003e0.44\u003c/version\u003e\n     \u003cconfiguration\u003e\n      \u003cimages\u003e\n       \u003cimage\u003e\n        \u003c!--플레이스홀더의 명명법입니다.\n          %g=매이븐 그룹 이름의 마지막 부분은 여기에서 중요합니다.\n          %v=프로젝트 버전. ${project.version}과 동의어입니다.\n           ....................................... --\u003e\n        \u003cname\u003e%g/docker-containerize:%v\u003c/name\u003e\n        \u003c!-- ....................................... --\u003e\n         \u003c!-- 이미지 생성을위한 빌드 구성 --\u003e\n        \u003c!-- ....................................... --\u003e\n        \u003cbuild\u003e\n         \u003cdockerFile\u003eDockerfile\u003c/dockerFile\u003e\n         \u003cassembly\u003e\n          \u003c!--매븐 어셈블리 플러그인에 대한 자세한 내용은 다음에서 찾을 수 있습니다:\n          https://maven.apache.org/plugins/maven-assembly-plugin/assembly.html--\u003e\n          \u003cbasedir\u003e/\u003c/basedir\u003e\n          \u003cinline xmlns=\"http://maven.apache.org/ASSEMBLY/2.2.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n              xsi:schemaLocation=\"http://maven.apache.org/ASSEMBLY/2.2.0 https://maven.apache.org/xsd/assembly-2.2.0.xsd\"\u003e\n           \u003cfileSets\u003e\n            \u003cfileSet\u003e\n             \u003cdirectory\u003e${project.basedir}/src/main/docker\u003c/directory\u003e\n             \u003coutputDirectory\u003e/\u003c/outputDirectory\u003e\n             \u003cincludes\u003e\n              \u003cinclude\u003edocker-entrypoint.sh\u003c/include\u003e\n             \u003c/includes\u003e\n             \u003cfileMode\u003e755\u003c/fileMode\u003e\n            \u003c/fileSet\u003e\n            \u003cfileSet\u003e\n             \u003cdirectory\u003e${project.basedir}/target\u003c/directory\u003e\n             \u003coutputDirectory\u003e/\u003c/outputDirectory\u003e\n             \u003cincludes\u003e\n              \u003cinclude\u003econtainerize-*.jar\u003c/include\u003e\n             \u003c/includes\u003e\n             \u003cfileMode\u003e755\u003c/fileMode\u003e\n            \u003c/fileSet\u003e\n           \u003c/fileSets\u003e\n          \u003c/inline\u003e\n         \u003c/assembly\u003e\n         \u003ctags\u003e\n          \u003ctag\u003e${project.version}\u003c/tag\u003e\n          \u003ctag\u003elatest\u003c/tag\u003e\n         \u003c/tags\u003e\n        \u003c/build\u003e\n       \u003c/image\u003e\n      \u003c/images\u003e\n     \u003c/configuration\u003e\n     \u003c!-- 라이프사이클에 훅 달기 --\u003e\n     \u003cexecutions\u003e\n      \u003cexecution\u003e\n       \u003cid\u003ebuild\u003c/id\u003e\n       \u003cgoals\u003e\n        \u003cgoal\u003ebuild\u003c/goal\u003e\n       \u003c/goals\u003e\n      \u003c/execution\u003e\n     \u003c/executions\u003e\n    \u003c/plugin\u003e\n   \u003c/plugins\u003e\n  \u003c/build\u003e\n \u003c/profile\u003e\n```\n\n```js\n위 구성에 대한 중요 사항:\n\nDockerFile -\u003e 이 플러그인은 src/main/docker 디렉토리에 배치된 도커 파일을 자동으로 가져올 것입니다.\n도커 파일의 이름만 전달해주면 됩니다. 여기서는 \u003cdockerFile\u003eDockerfile\u003c/dockerFile\u003e을 전달했습니다.\n\nAssembly plugin -\u003e \u003cbuild\u003e 내부의 \u003cassembly\u003e 요소는 XML 구조를 가지며, 빌드 아티팩트 및 기타 파일이\n도커 이미지로 진입하는 방식을 정의합니다. 여러 \u003cassembly\u003e 요소를 추가하여 명시할 수 있습니다.\n어셈블리 플러그인에 대한 자세한 내용은 여기에서 확인할 수 있습니다.\n\noutputDirectory -\u003e 이 플러그인에서 사용할 기본 출력 디렉터리입니다. 기본 값은 target/docker의\n매이븐 디렉터리입니다. 사용자는 이 디렉터리를 변경할 수 있는 옵션을 가지고 있습니다.\n\nFileSets -\u003e List\u003cFileSet\u003e 유형의 파일 설정으로, 포함된 각 모듈에서 어떤 그룹의 파일을 어셈블리에 포함할지 지정합니다.\n한 개 이상의 \u003cfileSet\u003e 하위 요소를 제공하여 fileSet을 지정합니다.\n여기서는 도커 파일에 필요한 어플리케이션 jar 및 docker-entrypoint.sh를 포함했습니다.\n\ntags -\u003e 빌드 후 이미지를 태깅할 추가 태그 요소 목록입니다. 여기서는 tag를 'latest'로 추가했으므로,\n이 플러그인은 이미지를 생성하고 해당 이미지에 'latest' 태그를 지정합니다.\nI이로 인해, 이 구성으로 2개의 이미지가 생성될 것입니다.\n```\n\nStep 3: Docker 파일 추가\n\n자바 17을 기본 이미지로 사용하는 Docker 파일을 작성합시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n###########################################################################\n# Dockerfile - Spring Boot Application Runner\n###########################################################################\n\n# 기본 이미지를 java17로 설정합니다.\n\nFROM openjdk:17-oracle\n\n# 파일 작성자 / 유지 관리자\nLABEL org.medium.image.authors=\"tauseef\"\n\n# 기본 환경 변수 정의\nENV APP_HOME=/opt/medium/containerize\n# 실행 가능한 artifact의 이름\nENV ARTIFACT_NAME=containerize-*.jar\n# Java 디버그 포트\nENV DEBUG_PORT=8000\n\n# 모든 artifact를 홈 디렉토리로 복사합니다\n# maven/에서 \u003cassembly\u003e 섹션에 지정된 파일은 수동으로 추가해야 합니다\nCOPY /maven/docker-entrypoint.sh /\nCOPY /maven/$ARTIFACT_NAME ${APP_HOME}/\n\n# 권한 부여\nUSER root\nRUN chmod 755 /docker-entrypoint.sh\n\n# 디렉토리에 쓰기 액세스를 위해 777 권한을 설정합니다\nRUN chmod -R 777 /opt/medium\n\n# 작업 디렉토리 설정\nWORKDIR /opt/medium\n\n# 주요 명령어\nUSER 185\nENTRYPOINT [\"/docker-entrypoint.sh\"]\n```\n\n이 도커 파일에서 ENTRYPOINT를 사용하고 있으며 이는 docker-entrypoint.sh를 가리킵니다. 파일은 다음과 같습니다.\n\n```js\n#!/bin/sh\nset -e\n\necho 'Starting containerize Spring Boot App'\n\nif [ \"$DEBUG\" = true ]; then\n  printf \"Running the application in debug mode\\n\"\n  JAVA_OPTS=\"$JAVA_OPTS -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:$DEBUG_PORT\"\nfi\n\n# 애플리케이션이 PID 1을 취하고 Docker stop 명령에 의해 보내진 SIGTERM을 수신할 수 있도록 합니다.\n# 여기를 참조하세요: https://docs.docker.com/engine/reference/builder/#/entrypoint\nexec java $JAVA_OPTS \\\n       -Djava.security.egd=file:/dev/./urandom -jar \\\n       ${APP_HOME}/$ARTIFACT_NAME\n\n# 인터럽트가 발생할 때까지 컨테이너를 계속 실행합니다\nsleep infinity\n```\n\nStep 4: 메이븐 프로필을 사용하여 이미지를 빌드합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 설정이 완료되었고, 이제 우리 애플리케이션의 이미지를 생성할 준비가 되었어요. 다음 명령어를 실행해봐요.\n\n```js\nmvn clean install -Pcontainerize\n```\n\n이 명령어는 docker-maven 플러그인을 실행시키고 이미지를 생성할 거에요. 빌드에 성공하면 터미널에 다음 로그 라인을 볼 수 있을 거에요.\n\n```js\n[INFO] DOCKER\u003e [medium/docker-containerize:0.0.1-SNAPSHOT]: Created docker-build.tar in 318 milliseconds\n[INFO] DOCKER\u003e [medium/docker-containerize:0.0.1-SNAPSHOT]: Built image sha256:e091d\n[INFO] DOCKER\u003e medium/docker-containerize:0.0.1-SNAPSHOT: Removed dangling image sha256:ea18f\n[INFO] DOCKER\u003e [medium/docker-containerize:0.0.1-SNAPSHOT]: Tag with 0.0.1-SNAPSHOT,latest\n[INFO] DOCKER\u003e Tagging image medium/docker-containerize:0.0.1-SNAPSHOT successful!\n[INFO] DOCKER\u003e Tagging image medium/docker-containerize:latest successful!\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 명령어를 실행하여 확인해주세요\n\n![image1](/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_2.png)\n\n이제 다음 이미지를 실행해주세요\n\n![image2](/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n따라서 컨테이너가 성공적으로 시작되었습니다.\n\n단계 5: 도커 메이븐 플러그인을 사용한 준비된 조립품\n\n도커 메이븐 플러그인은 사용자가 자세한 내용에 들어가서 조립품을 작성할 필요가 없도록 준비된 조립품을 지원합니다. 이는 descriptor-ref를 통해 수행할 수 있습니다. 조립품에서 지원되는 아티팩트 목록은 여기에서 찾을 수 있습니다.\n이 설명서를 따라, 우리는 pom 파일의 구성을 다음과 같이 수정하기만 하면 됩니다.\n\n```xml\n\u003cprofile\u003e\n   \u003cid\u003econtainerize2\u003c/id\u003e\n   \u003cbuild\u003e\n    \u003cplugins\u003e\n     \u003cplugin\u003e\n      \u003cgroupId\u003eio.fabric8\u003c/groupId\u003e\n      \u003cartifactId\u003edocker-maven-plugin\u003c/artifactId\u003e\n      \u003cconfiguration\u003e\n       \u003cimages\u003e\n        \u003cimage\u003e\n         \u003c!-- 플레이스홀더의 명명법\n          %g= Maven 그룹 이름의 마지막 부분은 여기서 미디엄에 해당합니다\n          %v= 프로젝트 버전. ${project.version}의 동의어\n          ....................................... --\u003e\n         \u003cname\u003e%g/docker-containerize2:%v\u003c/name\u003e\n         \u003c!-- ....................................... --\u003e\n         \u003c!-- 이미지 생성을 위한 빌드 구성 --\u003e\n         \u003c!-- ....................................... --\u003e\n         \u003cbuild\u003e\n          \u003cdockerFile\u003eDockerfile2\u003c/dockerFile\u003e\n          \u003cassemblies\u003e\n           \u003cassembly\u003e\n            \u003cdescriptorRef\u003eartifact\u003c/descriptorRef\u003e\n           \u003c/assembly\u003e\n          \u003c/assemblies\u003e\n          \u003ctags\u003e\n           \u003ctag\u003e${project.version}\u003c/tag\u003e\n           \u003ctag\u003elatest\u003c/tag\u003e\n          \u003c/tags\u003e\n         \u003c/build\u003e\n        \u003c/image\u003e\n       \u003c/images\u003e\n      \u003c/configuration\u003e\n      \u003c!-- 라이프사이클에 훅하기 --\u003e\n      \u003cexecutions\u003e\n       \u003cexecution\u003e\n        \u003cid\u003edocker-build\u003c/id\u003e\n        \u003cgoals\u003e\n         \u003cgoal\u003ebuild\u003c/goal\u003e\n        \u003c/goals\u003e\n       \u003c/execution\u003e\n      \u003c/executions\u003e\n     \u003c/plugin\u003e\n    \u003c/plugins\u003e\n   \u003c/build\u003e\n  \u003c/profile\u003e\n```\n\n```xml\n만약 주목했다면 다음과 같이 전달하기만 하면 됩니다.\n            \u003cassembly\u003e\n            \u003cdescriptorRef\u003eartifact\u003c/descriptorRef\u003e\n           \u003c/assembly\u003e\n그리고 이것은 jar 파일을 target/docker의 maven 디렉토리로 복사하고\n거기서 Docker 파일이 jar 파일을 선택할 것입니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결론\nSpring Boot 애플리케이션을 컨테이너화하는 것은 배포 프로세스를 효율적으로 만들 뿐만 아니라 다양한 환경에서의 확장성과 일관성을 향상시킵니다. 오늘부터 Spring Boot 프로젝트를 컨테이너화하여 현대적인 애플리케이션 배포의 혜택을 직접 경험해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_0.png"},"coverImage":"/assets/img/2024-06-23-FromCodetoContainerDockerizingSpringBootAppswithMaven_0.png","tag":["Tech"],"readingTime":11},{"title":"Ubuntu 2204에 Docker Desktop 설치하는 방법","description":"","date":"2024-06-23 22:53","slug":"2024-06-23-HowToInstallDockerDesktoponUbuntu2204","content":"\n\u003cimg src=\"/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_0.png\" /\u003e\n\n이 블로그에서는 Ubuntu 22.04에 Docker Desktop을 설정하는 방법을 살펴보겠습니다.\n\nDocker Desktop:\n\nDocker Desktop은 macOS, Linux 및 Windows 컴퓨터용 응용 프로그램으로, 컨테이너화된 응용 프로그램 및 마이크로서비스를 빠르고 안전하게 구축하고 공유할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDocker Desktop에는 응용 프로그램 개발을 위한 내장 Kubernetes 설정이 포함되어 있으며, 인증된 이미지, 템플릿, 그리고 원하는 언어와 도구를 사용할 수 있습니다. 개발 워크플로우는 Docker Hub를 활용하여 개발 환경을 안전한 저장소로 확장하여 빠른 자동 빌드, 지속적 통합 및 안전한 협업을 지원합니다.\n\n## 준비 사항\n\nPC가 다음 기본 요구 사항을 충족하는지 확인해주세요.\n\n- 가상화 지원이 활성화된 64비트 CPU\n- 적어도 4GB RAM\n- GUI 데스크톱 환경 (가능하면 GNOME, MATE 또는 KDE)\n- 관리자 권한이 있는 Sudo 사용자\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# KVM 가상화 지원\n\n호스트가 가상화 지원을 하는 경우 kvm 모듈은 자동으로 로드됩니다. 모듈을 수동으로 로드하려면 다음을 실행하세요:\n\n```js\nmodprobe kvm\n```\n\n호스트 머신의 프로세서에 따라 해당 모듈을 로드해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmodprobe kvm_intel  # 인텔 프로세서\nmodprobe kvm_amd    # AMD 프로세서\n```\n\n단계 1: Gnome 데스크톱이 없는 상황에서는 Gnome 터미널을 설치해야 합니다:\n\n```js\nsudo apt install gnome-terminal\n```\n\n단계 2: Linux용 Docker Desktop의 기술 미리보기 또는 베타 버전을 제거하세요. 실행하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsudo apt remove docker-desktop\n```\n\n# 우분투 22.04에 Docker 설치하기:\n\n이제 Docker를 설치해봅시다. 하지만 그 전에 패키지 목록을 업데이트하고 필수 종속성을 설치해야 합니다. 다음과 같이 입력해주세요.\n\n```js\n$ sudo apt update\n$ sudo apt install software-properties-common curl apt-transport-https ca-certificates -y\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설치가 완료되면 Docker의 GPG 서명 키를 추가해주세요.\n\n```js\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/trusted.gpg.d/docker-archive-keyring.gpg\n```\n\n다음으로, 아래와 같이 시스템에 공식 Docker 저장소를 추가해주세요.\n\n```js\n$ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레포지토리가 준비되었으면 다음과 같이 Docker 및 기타 도커 도구를 설치합니다.\n\n```js\n$ sudo apt install docker-ce docker-ce-cli containerd.io uidmap -y\n```\n\n도커가 실행 중인지 확인하려면 다음 명령어를 실행하세요:\n\n```js\nsudo systemctl status docker\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Docker 버전을 확인하는 방법입니다.\n\n```js\ndocker version\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우분투 22.04에 Docker Desktop 설치 방법:\n\n아래 wget 명령어를 사용하여 Docker Desktop을 설치하세요. Docker Desktop의 최신 버전은 Docker Desktop 버전 4.19.0입니다.\n\n```js\n$ wget https://desktop.docker.com/linux/main/amd64/docker-desktop-4.19.0-amd64.deb\n```\n\n또한 이 링크에서 DEB 패키지를 다운로드할 수 있고 아래 명령어를 사용하여 설치할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n$ sudo apt install ./docker-desktop-*-amd64.deb\n```\n\n![Docker Desktop Installation](/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_3.png)\n\n도커 데스크톱을 실행하세요:\n\n이제 애플리케이션 메뉴에서 도커 데스크톱을 실행하고 라이센스 약관을 수락하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_4.png\" /\u003e\n\n이제 CLI에서 명령어 대신 도커 데스크톱에서 컨테이너를 만들 수 있어요.\n\n즐거운 학습 되세요!\n","ogImage":{"url":"/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_0.png"},"coverImage":"/assets/img/2024-06-23-HowToInstallDockerDesktoponUbuntu2204_0.png","tag":["Tech"],"readingTime":6},{"title":"Docker 볼륨 이해하기 완벽 가이드","description":"","date":"2024-06-23 22:52","slug":"2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide","content":"\n도커(Docker)의 컨테이너는 상태를 유지하지 않고 쉽게 폐기할 수 있는 방식으로 설계되었습니다. 볼륨(Volumes)은 컨테이너가 생성하고 사용하는 데이터를 단일 컨테이너의 수명 주기를 넘어서 계속 유지하는 방법을 제공합니다. 이는 데이터베이스, 파일 저장소 및 지속적인 저장 공간이 필요한 다른 응용 프로그램에 필수적입니다.\n\n본 문서는 도커 볼륨을 생성하고 사용하는 다양한 방법을 탐구하며, 실제 응용 사례를 설명하기 위한 예제가 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Docker Volume 소개\n\nDocker 볼륨은 Docker 컨테이너에서 생성된 데이터를 저장하고 사용하기 위해 설계된 지속적인 저장 메커니즘입니다. 이들은 데이터 수명주기를 컨테이너 수명주기와 분리하여 데이터가 컨테이너가 삭제되거나 다시 생성되더라도 손상되지 않도록 보장합니다.\n\n# Docker Volume의 종류\n\n## Named Volumes\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이름이 지정된 볼륨은 사용자가 정의한 볼륨으로, 이름으로 쉽게 참조하고 여러 컨테이너 간에 재사용할 수 있습니다. 이러한 볼륨은 Docker의 내부 볼륨 저장소에 저장됩니다.\n\n```js\ndocker volume create myVolume\ndocker run -d --name my_container -v myVolume:/data node_container\n```\n\n## 익명 볼륨\n\n이름이 지정되지 않은 볼륨은 생성된 이름이 없을 때 생성됩니다. 이러한 볼륨들은 일반적으로 컨테이너의 수명주기를 넘어서 지속되지 않아야 하는 일시적인 데이터에 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 실행 -d --name my_container -v /data node_container\n```\n\n## 바인드 마운트\n\n바인드 마운트는 호스트 파일 시스템의 디렉터리나 파일을 컨테이너에 매핑합니다. 이를 통해 호스트 파일 시스템에 직접 액세스하여 데이터를 호스트와 컨테이너 간에 공유해야하는 시나리오에 이상적입니다.\n\n```js\n도커 실행 -d --name my_container -v /호스트/경로:/data node_container\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## tmpfs 볼륨\n\ntmpfs 볼륨은 컨테이너의 메모리에 임시 파일 시스템을 마운트합니다. 민감한 정보나 임시 파일과 같이 디스크에 쓰여서는 안 되는 비영구 데이터를 저장하는 데 유용합니다.\n\n```js\ndocker run -d --name my_container --tmpfs /data node_container\n```\n\n# Docker 볼륨 생성 및 관리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 볼륨 만들기\n\n이름이 지정된 볼륨을 만들려면 다음 명령을 사용하세요:\n\n```js\ndocker volume create myVolume\n```\n\n## 볼륨 검사\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n볼륨을 검사하고 세부 정보를 확인하려면\n\n```js\ndocker volume inspect myVolume\n```\n\n## 볼륨 제거\n\n더 이상 필요하지 않은 볼륨을 제거하려면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 볼륨 삭제 myVolume\n```\n\n![이미지](/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_2.png)\n\n# 도커 볼륨 사용하기\n\n## 명명된 볼륨 마운트하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 이름의 볼륨을 컨테이너에 마운트하려면:\n\n```js\ndocker run -d -v myVolume:/app/data myImage\n```\n\n## 익명 볼륨 마운트\n\n익명 볼륨을 마운트하려면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 실행 -d -v /app/data myImage\n```\n\n## 바인드 마운트 사용하기\n\n바인드 마운트를 사용하려면 호스트 경로와 컨테이너 경로를 지정하십시오:\n\n```js\n도커 실행 -d -v /host/data:/app/data myImage\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 예시\n\n## 1. 이름있는 볼륨을 사용하여 데이터 유지하기\n\n이름이 지정된 볼륨을 생성하고 컨테이너에서 사용하기\n\n```js\ndocker volume create mydata\ndocker run -d -v mydata:/app/data myImage\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컨테이너 내부의 /app/data 경로에 작성된 모든 데이터는 컨테이너가 삭제되더라도 유지됩니다.\n\n## 2. 컨테이너 간 데이터 공유\n\n여러 컨테이너 간 데이터를 공유하려면 명명된 볼륨을 사용할 수 있습니다:\n\n```js\ndocker volume create shared_data\ndocker run -d -v shared_data:/app/data container1\ndocker run -d -v shared_data:/app/data container2\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Understanding Docker Volumes](/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_3.png)\n\n두 컨테이너 모두 /app/data에 읽고 쓸 수 있어 데이터 공유가 가능합니다.\n\n## 개발을 위한 Bind Mount 사용\n\n호스트 디렉토리를 컨테이너에 매핑하는 Bind Mount를 사용하여 실시간 코드 변경을 가능하게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 실행 -d -v $(pwd):/app myImage\n```\n\n호스트 디렉토리의 파일에 대한 변경 사항은 즉시 컨테이너에 반영됩니다.\n\n# 간단한 Node.js 애플리케이션 예제\n\n## 단계 1: Node.js 애플리케이션 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 파일에 데이터를 작성하는 간단한 Node.js 애플리케이션을 만들어봅시다:\n\n![이미지](/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_4.png)\n\n## 단계 2: Dockerfile 생성\n\n다음으로 Node.js 애플리케이션을 위한 Dockerfile을 만들어봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nFROM node:14\n\nWORKDIR /app\n\nCOPY . .\n\nCMD [\"node\", \"app.js\"]\n```\n\n## Step 3: 이제 도커 이미지를 빌드하세요\n\n![Step 3](/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_5.png)\n\n## Step 4: 컨테이너를 실행하세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_6.png\" /\u003e\n\n- myVolume: 호스트 머신에있는 볼륨의 이름입니다.\n- :/app/data: 이는 컨테이너 내부의 마운트 포인트를 지정합니다. 이 경우 호스트의 myVolume 볼륨을 컨테이너 내부의 /app/data 디렉토리로 마운트합니다.\n\n## 단계 5: data.txt 파일의 내용을 확인합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_7.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_8.png\" /\u003e\n\n# 도커 볼륨 사용에 대한 최상의 방법\n\n- 컨테이너 수명 주기를 초과하는 데이터에 사용할 때는 명명된 볼륨을 사용합니다.\n- 개발 목적이거나 호스트 파일에 직접 액세스해야 할 때는 바인드 마운트를 사용합니다.\n- 사용되지 않는 볼륨을 정기적으로 검사하고 정리하여 공간을 확보합니다.\n- 보안 위험을 피하기 위해 바인드 마운트를 사용할 때 올바른 액세스 권한을 보장합니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 볼륨은 컨테이너화된 응용 프로그램의 유연성과 효율성을 향상시키는 강력한 기능입니다. 다양한 유형의 볼륨을 이해하고 관리하는 방법을 알면 도커를 사용하여 컨테이너 내에서 데이터를 지속적으로 유지, 공유 및 관리할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingDockerVolumesAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"쿠버네티스 Pod 간 통신 완벽 가이드 마스터하기 위한 모든 것","description":"","date":"2024-06-23 22:50","slug":"2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide","content":"\n\u003cimg src=\"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png\" /\u003e\n\n# 소개\n\nKubernetes는 컨테이너 오케스트레이션을 혁신하여 기업이 규모에 맞게 응용 프로그램을 배포하고 관리할 수 있게 하였습니다. Kubernetes의 주요 구성요소 중 하나인 pod는 하나 이상의 강하게 결합된 컨테이너들의 논리적 그룹입니다. pod가 서로 통신하는 방식을 이해하는 것은 Kubernetes 클러스터에서 탄력적이고 확장 가능한 응용 프로그램을 구축하는 데 중요합니다. 이 블로그 게시물에서는 Kubernetes pod 간 통신에 대해 깊이 알아보고 다양한 통신 패턴과 기술을 탐구할 것입니다.\n\n# Pod 네트워킹 이해하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠버네티스에서 Pods는 클러스터 내에서 고유한 IP 주소가 할당되어 직접 통신할 수 있습니다. 기본적으로 각 Pod는 격리되어 고유한 IP 주소를 가지며, 안전한 통신을 가능하게 하고 포트 충돌을 피할 수 있습니다. 이러한 IP 주소는 외부 액세스를 위해 특정 구성이 없는 한 쿠버네티스 클러스터 네트워크 내에서만 접근 가능합니다.\n\n# 쿠버네티스 네트워킹 모델\n\n- 동일 노드 내 Pod 간 통신: 동일한 노드에 여러 개의 Pod가 예약되면 localhost 또는 루프백 인터페이스를 사용하여 직접 통신할 수 있습니다. 이 통신은 주로 가상 이더넷(veth) 쌍 형태로 클러스터 내에 할당된 Pod의 IP 주소를 통해 이루어집니다. 이 통신은 네트워크 계층에서 발생하여 동일 노드의 Pod 간 높은 성능과 낮은 지연 시간 상호작용을 가능하게 합니다.\n- 노드 간 Pod 간 통신: 클러스터 내 서로 다른 노드 간에 통신이 필요한 경우, 쿠버네티스는 다양한 네트워킹 솔루션인 Container Network Interfaces (CNIs) 및 소프트웨어 정의 네트워킹(SDN) 기술을 활용합니다. 이러한 솔루션은 전체 클러스터를 가로지르는 가상 네트워크 오버레이를 생성하여 노드 간 Pod 간 통신을 가능하게 합니다. Calico, Flannel, Weave, Cilium 등이 인기 있는 CNIs 중 일부이며, 이러한 네트워킹 솔루션은 Pod의 IP 주소가 Reachable하도록 보장하며, 클러스터 내에서 Pod의 위치에 관계없이 투명한 네트워크 연결성을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 쿠버네티스 클러스터 내의 파드는 내부 IP 주소를 사용하여 서로 통신할 수 있습니다. 이 통신은 백그라운드의 컨테이너 런타임이나 네트워크 플러그인에서 제공하는 가상 네트워크 오버레이를 통해 이루어집니다. 내부 IP 주소는 쿠버네티스 클러스터 네트워킹 솔루션에 의해 할당되며 클러스터 내에서만 라우터링됩니다.\n\n# DNS 기반 서비스 검색\n\n쿠버네티스는 클러스터 내에서 서비스 검색을 위한 내장 DNS 서비스를 제공합니다. 서비스들은 기본 파드를 추상화한 안정적인 엔드포인트 역할을 합니다. 각 서비스는 DNS 이름이 할당되며, 해당 서비스를 지원하는 파드의 IP 주소로 해석됩니다. 이 DNS 기반 접근 방식을 통해 파드는 개별 파드 IP 주소를 직접 참조하는 대신 서비스 이름을 사용하여 서로 통신할 수 있습니다.\n\n# 서비스 로드 밸런싱\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 개의 팟이 동일한 애플리케이션을 제공할 때, Kubernetes는 이러한 팟들 간의 트래픽을 분산하는 데 사용하는 내장된 로드 밸런싱 기능을 제공합니다. 서비스 객체를 생성하고 이를 일련의 팟과 연결함으로써, Kubernetes는 사용 가능한 팟들 사이에 들어오는 요청을 자동으로 로드 밸런싱합니다. 이 로드 밸런싱 메커니즘은 애플리케이션의 고가용성과 확장성을 보장합니다.\n\n# 네트워크 정책\n\nKubernetes는 팟 간의 트래픽 흐름을 제어하기 위한 수단으로 네트워크 정책을 제공합니다. 네트워크 정책은 IP 주소, 포트 및 프로토콜과 같은 다양한 매개변수를 기반으로 어떤 팟이 서로 통신할 수 있는지를 지정하는 규칙을 정의합니다. 네트워크 정책을 시행함으로써, 애플리케이션의 네트워크 트래픽을 세분화하고 추가적인 보안 층을 추가할 수 있습니다.\n\n# 외부 통신\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKubernetes 클러스터 바깥의 리소스와 통신해야 하는 팟이 자주 있습니다. 외부 서비스나 데이터베이스와 통신하는 방법을 용이하게 해주는 여러 메커니즘이 Kubernetes에서 제공됩니다. 한 가지 접근법은 서비스 유형이 \"LoadBalancer\" 또는 \"NodePort\"인 서비스를 사용하여 팟 또는 팟 세트를 노출하는 것으로, 외부 클라이언트가 팟에 액세스할 수 있게 합니다. 또 다른 옵션은 Ingress 컨트롤러를 사용하는 것인데, 이를 통해 외부 클러스터로부터 들어오는 트래픽을 정의된 규칙에 따라 적절한 팟으로 라우팅할 수 있습니다.\n\n# 서비스 메쉬\n\n고급 네트워킹 시나리오를 위해, 서비스 메쉬를 사용하여 팟 간 통신을 강화할 수 있습니다. Istio나 Linkerd와 같은 서비스 메쉬는 Kubernetes 클러스터 상단에 있는 레이어로써 트래픽 관리, 관찰가능성, 보안과 같은 기능을 제공합니다. 서비스 메쉬를 사용하면 고급 라우팅 규칙, 회로 차단, 분산 추적을 통해 팟 간 통신을 제어하고 모니터링할 수 있습니다.\n\n# 예시\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKubernetes에서 pod 간 통신을 구성하는 방법을 보여드리기 위해 예제 사양을 살펴보겠습니다. 이 예제에서는 서비스를 사용하여 두 개의 파드를 생성하고 그들 간의 통신을 수립할 것입니다.\n\n- Pod A 생성: 먼저 간단한 웹 애플리케이션을 실행하는 Pod A를 생성해 보겠습니다. pod-a.yaml이라는 파일을 만들고 아래 내용을 추가하세요:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-a\nspec:\n  containers:\n    - name: web-app\n      image: your-web-app-image\n      ports:\n        - containerPort: 8080\n```\n\n\"your-web-app-image\"를 사용 중인 웹 애플리케이션의 적절한 이미지로 교체해 주세요. 이 사양은 지정된 포트 8080이 노출된 상태로 \"pod-a\"라는 이름의 파드를 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. Pod B를 생성하세요: 이제 Pod A와 통신하는 클라이언트 Pod인 Pod B를 생성해 봅시다. pod-b.yaml이라는 파일을 만들고 다음 내용을 추가해 주세요:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-b\nspec:\n  containers:\n    - name: client-app\n      image: your-client-app-image\n      command: [\"sleep\", \"infinity\"]\n```\n\nyour-client-app-image를 사용하고 있는 클라이언트 어플리케이션에 해당하는 이미지로 변경해 주세요. 이 명세는 \"pod-b\"라는 이름의 pod를 생성하고, 해당 컨테이너를 실행하여 pod를 계속 실행 상태로 유지할 수 있는 무한 sleep 명령을 실행합니다.\n\n3. 서비스 생성하기: Pod A와 Pod B 간의 통신을 가능하게 하기 위해 안전한 엔드포인트로 작동하는 서비스를 생성할 것입니다. service.yaml이라는 파일을 만들고 다음 내용을 추가하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: pod-service\nspec:\n  selector:\n    app: web-app\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n```\n\n이 구성은 \"pod-service\"라는 서비스를 생성하며, 이 서비스는 app: web-app 라벨을 가진 파드를 대상으로합니다 (우리가 Pod A에 추가 할 것입니다). 이 서비스는 포트 80을 노출하고 선택한 파드의 포트 8080으로 트래픽을 전달합니다.\n\n4. 설정 적용: 다음 명령을 사용하여 생성된 구성을 적용하십시오:\n\n```yaml\nkubectl apply -f pod-a.yaml\nkubectl apply -f pod-b.yaml\nkubectl apply -f service.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 쿠버네티스 클러스터에 Pod A, Pod B 및 서비스가 생성됩니다.\n\n5. 통신 테스트: 통신을 테스트하려면 Pod B에 접속하여 서비스의 DNS 이름을 사용하여 Pod A에 요청을 보낼 수 있습니다. 다음 명령어를 실행하세요:\n\n```sh\nkubectl exec -it pod-b -- sh\n```\n\nPod B 쉘에 들어간 후에 curl과 같은 도구를 사용하여 Pod A에 요청을 보낼 수 있습니다. 서비스 명세서에서 다른 이름을 사용했다면 실제 서비스 이름으로 pod-service를 대체하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ncurl pod-service\n```\n\n이 명령은 서비스로 요청을 보내어 트래픽을 로드 밸런싱하고 Pod A로 전달합니다.\n\n여기까지입니다! 이제 쿠버네티스에서 서비스를 사용하여 pod 간 통신을 설정했습니다. 다양한 통신 패턴을 탐색하거나 네트워크 정책을 적용하거나 특정 요구 사항을 충족시키기 위해 추가적인 쿠버네티스 기능을 활용하여 이 예시를 확장할 수 있습니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그를 변경하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringKubernetesPod-to-PodCommunicationAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":8},{"title":"마이크로서비스 아키텍처 모두가 알아야 할 필수 개념과 방법","description":"","date":"2024-06-23 22:48","slug":"2024-06-23-MicroservicesArchitectureAllYouNeedtoknow","content":"\n\u003cimg src=\"/assets/img/2024-06-23-MicroservicesArchitectureAllYouNeedtoknow_0.png\" /\u003e\n\n단일 버그가 전체 시스템을 충돌시킬 수 있는 단일체 응용 프로그램을 업데이트하는 악몽에 직면해 본 적이 있나요? 여러분, 응용 프로그램을 보다 견고하고 확장 가능하며 유지보수하기 쉽게 만들 수있는 방법이 있다는 것을 말해 드릴까요? 마이크로서비스의 세계로 환영합니다.\n\n컬러풀한 비유로 들어가 봅시다.\n\n니가 소개해 준 마이크로서비스는 대형 응용 프로그램의 느슨하게 결합된 작은 응용 프로그램들입니다. 각 마이크로서비스는 단일 기능 또는 프로세스에 책임을지어야 합니다. 코드 또는 데이터를 공유하면 안되며, 데이터 또는 코드를 공유하다가 데이터베이스가 다운되면 각 서비스/시스템 전체가 실패할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마이크로서비스의 경우 독립성과 자율성이 코드 재사용보다 더 중요합니다. 이들은 서로 직접 통신할 수 없지만 이벤트/메시지 버스를 활용하여 서로 통신합니다.\n\n## 전형적인 마이크로서비스 아키텍처\n\n![이미지](/assets/img/2024-06-23-MicroservicesArchitectureAllYouNeedtoknow_1.png)\n\n전형적인 마이크로서비스 아키텍처는 다음 구성 요소 또는 빌딩 블록으로 구성됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 클라이언트\n\n클라이언트는 웹 애플리케이션, 모바일 애플리케이션 또는 챗봇과 같은 다양한 인터페이스를 통해 시스템과 상호 작용하는 최종 사용자들을 말합니다. 이러한 인터페이스를 통해 사용자들은 마이크로서비스 아키텍처에서 제공되는 서비스에 액세스할 수 있습니다.\n\n## 컨테이너 호스트\n\n마이크로서비스는 일반적으로 애플리케이션을 실행하는 가벼운, 휴대 가능하고 일관된 환경인 컨테이너에 배포됩니다. Docker와 Kubernetes는 이러한 컨테이너를 관리하기 위한 인기 있는 선택지입니다. Docker는 컨테이너화를 제공하고, Kubernetes는 이러한 컨테이너를 조정하고 관리하여 효율적이고 신뢰성 있게 실행되도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 데이터베이스\n\n마이크로서비스 아키텍처에서 각 서비스는 자체 데이터베이스를 가질 수 있습니다. 이를 통해 각 서비스에 가장 적합한 데이터베이스 유형을 선택할 수 있습니다. 예를 들어 한 서비스가 PostgreSQL과 같은 관계형 데이터베이스를 사용할 수 있고, 다른 서비스는 MongoDB와 같은 NoSQL 데이터베이스를 사용할 수 있습니다. 이러한 분리는 서비스가 느슨하게 결합되어 독립적으로 확장될 수 있음을 보장합니다.\n\n## API 게이트웨이\n\nAPI 게이트웨이는 클라이언트와 마이크로서비스 간의 통신을 HTTP를 통해 할 수 있도록 중개자 역할을 합니다. 클라이언트가 각 마이크로서비스를 직접 호출하는 대신 API 게이트웨이에 요청을 보냅니다. API 게이트웨이는 이후 이러한 HTTP 요청을 적절한 마이크로서비스로 라우팅합니다. 이는 클라이언트 측 로직을 단순화시키는데 그치지 않고 인증, 로깅, 속도 제한, 부하 분산 등과 같은 다양한 관심사를 위한 단일 진입점을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 인증 서비스\n\n인증 서비스는 마이크로서비스에 대한 클라이언트 액세스를 보호하는 데 매우 중요합니다. 이는 클라이언트 애플리케이션을 인증하고 인증 토큰(일반적으로 JWT)을 제공합니다. 이 토큰은 각 HTTP 요청에 포함되어야 하며 마이크로서비스에 안전하게 액세스할 수 있도록 합니다.\n\n## 작동 방식\n\n- 토큰 요청: 클라이언트 애플리케이션은 먼저 인증 서비스에 HTTP 요청을 보내어 액세스 토큰을 획득합니다. 이 요청에는 일반적으로 클라이언트의 자격 증명(예: 사용자 이름과 비밀번호)이 포함됩니다.\n- 액세스 토큰: 성공적으로 인증된 경우, 인증 서비스는 클라이언트에게 액세스 토큰(JWT)을 발급합니다.\n- 마이크로서비스 액세스: 클라이언트는 이 액세스 토큰을 API 게이트웨이의 후속 HTTP 요청 헤더에 포함시킵니다. API 게이트웨이는 요청을 원하는 마이크로서비스로 라우팅하기 전에 토큰을 유효성 검사합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 토큰 만료 :\n\n액세스 토큰은 일반적으로 구성 가능한 시간 동안만 유효합니다. 예를 들어 토큰이 5분 동안 유효하다면, 클라이언트는 토큰이 만료되기 전에 여러 요청을 만들 수 있어 매 호출마다 새 토큰 요청을 할 필요가 없어집니다. 따라서 액세스 빈도와 만료 시간 사이에 균형을 유지하는 것이 중요합니다. 만료 시간이 짧을수록 요청이 더 안전해집니다.\n\n## 이벤트 버스\n\n이벤트 버스는 비동기, 이벤트 기반 메시징을 통해 마이크로서비스간의 통신을 용이하게합니다. 마이크로서비스가 강하게 결합되지 않으면서 상호 작용할 수 있도록 보장하는 데 중요한 역할을 하며, 전반적인 확장성과 유연성을 향상시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 작동 방식\n\n- 이벤트 생성 : 마이크로서비스들은 이벤트 생성기능을 통해 이벤트를 생성하거나 발행합니다. 이러한 이벤트는 새로운 사용자 생성, 거래 완료, 재고 수준 변화 등 다양한 상태 변경 또는 동작을 나타낼 수 있습니다.\n- 이벤트 소비 : 다른 마이크로서비스들은 이벤트 버스에 구독하고 특정 이벤트를 감지합니다. 관심 있는 이벤트가 발행되면, 해당하는 구독 중인 마이크로서비스는 해당 이벤트를 처리하고 소비합니다.\n- 겹합되지 않은 통신 : 발행 마이크로서비스는 이벤트를 소비하는 마이크로서비스를 알 필요가 없습니다. 마찬가지로 소비하는 마이크로서비스들은 이벤트의 출처를 알 필요가 없습니다. 이러한 겹합 없는 통신은 마이크로서비스들이 서로 영향을 미치지 않고 독립적으로 발전할 수 있도록 보장합니다.\n\n# 안티 패턴 (신화)\n\n안티 패턴은 일반적으로 반복되는 문제에 대한 해결책으로 매우 비생산적이거나 생산성이 낮은 것입니다. 이러한 것들을 고려해서는 안됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모든 것들은 **database를 제외하고 작아져야 합니다**: 하나의 database만 있다면, 그것은 잠재적인 단일 장애점이 될 수 있습니다. 모든 Microservices가 동일한 단일 database에 결합되어 있으면 개별적으로 실패할 수 없습니다.\n- Microservices가 마법처럼 나쁜 개발 관행을 해결해 주지는 않습니다\\*\\*: 오래된 아키텍처에서 나쁜 개발이나 배포 습관이 Microservices 아키텍처로 전이된다면, 더 큰 해를 불러올 수 있습니다. 아키텍처 선택과 관계없이 코딩 및 배포 최상의 관행은 항상 최우선 과제여야 합니다.\n- Microservices는 단일 시스템 기능 또는 프로세스를 해결하는 데 중점을 두기 때문에 개발 팀 간의 조정이 필요하지 않습니다\\*\\*: 신 개념이므로 항상 팀간의 조정이 필요합니다. 소프트웨어 아키텍트가 모든 팀에서 동일한 높은 기준과 최상의 관행에 따라 Microservices를 설계하는 것이 좋습니다.\n- Microservices 기술을 핵심에 두면 안 됩니다\\*\\*: Microservices는 도구와 기술 선택의 유연성을 제공하지만, 주요 초점이 되어서는 안 됩니다. 주요 초점은 시스템 기능을 Microservices로 어떻게 분해할지 및 각 Microservice의 목적을 정의하는 데 있어야 합니다.\n\n# Microservices의 이점은 무엇인가요?\n\n- 복잡성 감소: 각 Microservice당 더 작은 코드베이스로 복잡성이 줄어듭니다.\n- 모듈성 향상: 시스템을 이해, 개발 및 테스트하기 쉽게 만들어 모듈성을 향상시킵니다.\n- 확장성: 높은 확장성을 갖는 아키텍처를 만듭니다.\n- 분할 정복: 분할 정복 원칙을 적용하여 대규모 및 복잡한 애플리케이션의 지속적인 전달 및 개발을 가능하게 합니다.\n- 독립적 배포: 서비스는 독립적으로 배포될 수 있습니다.\n\n# 왜 Microservices는 RESTful API로 개발되었나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마이크로서비스는 종종 작은 RESTful API로 개발됩니다. RESTful API는 Representational State Transfer로 알려진 아키텍처 스타일을 기반으로 하는 웹 API 또는 서비스입니다. 클라이언트 응용 프로그램이 RESTful API와 HTTP를 통해 통신하는 방법을 정의합니다. 그렇다면 왜 RESTful API가 마이크로서비스에 적합한 것일까요? 주요 이유를 알아봅시다:\n\n- 간결함: CRUD에 기반한 HTTP 동사이므로 이해하기 쉽습니다.\n- 상태 없음: REST는 상태를 유지하지 않도록 설계되어 있으며 클라이언트와 서버의 역할을 분리합니다. 이는 서버가 클라이언트의 상태를 알 필요가 없거나 클라이언트가 서버의 상태를 걱정할 필요가 없음을 의미합니다.\n- 성능 및 확장성: REST 읽기는 성능과 확장성을 위해 캐싱될 수 있습니다.\n- 데이터 형식 유연성: REST는 많은 데이터 형식을 지원하지만 JSON의 주요 사용은 브라우저 클라이언트에서 더 나은 지원을 가능하게 합니다.\n\n# 직접적인 클라이언트 액세스의 문제 및 API 게이트웨이 사용의 이유\n\n- 직접적인 클라이언트 액세스는 많은 마이크로서비스 엔드포인트를 추적해야 하는 경우 클라이언트 통합의 복잡성을 증가시킵니다.\n- 이 경우 클라이언트는 자체적으로 로드 밸런싱 및 장애 감지를 구현해야 합니다.\n- 클라이언트가 여러 서비스에 공개적으로 액세스하려면 이러한 서비스들이 각자의 보안 문제를 다루어야 하며 SSL 종료 및 인증을 포함합니다.\n- API 게이트웨이는 클라이언트 애플리케이션이 마이크로서비스에 액세스하는 데 사용할 수 있는 통합된 진입점을 생성합니다.\n- 이는 클라이언트 요청을 원하는 백엔드 마이크로서비스로 라우팅하는 리버스 프록시 역할을 합니다.\n- API 게이트웨이는 클라이언트 인증, 로드 밸런싱 및 SSL 종료와 같은 중요한 기능을 수행할 수도 있습니다.\n- API 게이트웨이는 지정된 게이트웨이 경로에 허용되는 HTTP 동사의 유형을 제한할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 추가 읽을거리\n\n- 완전한 고수준 시스템 디자인 재생 목록\n\n---\n\nPS: 안녕하세요! 저는 Ankit Agarwal이라고 합니다. 소프트웨어 공학에 대한 열정을 가진 시니어 소프트웨어 엔지니어입니다.\n이 기사가 도움이 되셨나요? 멋집니다! 언제든지 제가 가진 소프트웨어 엔지니어링에 대한 지식과 열정을 공유하는 것을 기쁘게 생각합니다. 더 배우고 싶거나 연결하고 싶다면 LinkedIn에서 저를 찾아주십시오 @ https://www.linkedin.com/in/ankit-agarwal-87331a17b/\n","ogImage":{"url":"/assets/img/2024-06-23-MicroservicesArchitectureAllYouNeedtoknow_0.png"},"coverImage":"/assets/img/2024-06-23-MicroservicesArchitectureAllYouNeedtoknow_0.png","tag":["Tech"],"readingTime":8}],"page":"6","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"6"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>