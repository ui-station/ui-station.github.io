<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/105" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/105" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="유닉스 리눅스에서 ls 명령어 해부하기" href="/post/2024-05-18-DemystifyingthelsCommandinUnixLinux"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="유닉스 리눅스에서 ls 명령어 해부하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="유닉스 리눅스에서 ls 명령어 해부하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">유닉스 리눅스에서 ls 명령어 해부하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift Actors  깊이 있는 이해" href="/post/2024-05-18-SwiftActorsindepth"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift Actors  깊이 있는 이해" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-SwiftActorsindepth_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift Actors  깊이 있는 이해" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift Actors  깊이 있는 이해</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 174 출시 - 지금 꼭 시도해봐야 할 25가지 이상의 멋진 새로운 기능" href="/post/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 174 출시 - 지금 꼭 시도해봐야 할 25가지 이상의 멋진 새로운 기능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 174 출시 - 지금 꼭 시도해봐야 할 25가지 이상의 멋진 새로운 기능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 174 출시 - 지금 꼭 시도해봐야 할 25가지 이상의 멋진 새로운 기능</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">31<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스위프트 플레이그라운드에서 머신 러닝 모델을 사용하는 방법" href="/post/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스위프트 플레이그라운드에서 머신 러닝 모델을 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스위프트 플레이그라운드에서 머신 러닝 모델을 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">스위프트 플레이그라운드에서 머신 러닝 모델을 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="네이티브 iOS 느낌을 Compose Multiplatform 앱에서 가져오기" href="/post/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="네이티브 iOS 느낌을 Compose Multiplatform 앱에서 가져오기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="네이티브 iOS 느낌을 Compose Multiplatform 앱에서 가져오기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">네이티브 iOS 느낌을 Compose Multiplatform 앱에서 가져오기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요" href="/post/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드" href="/post/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피" href="/post/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터 애플리케이션에서 보안 강화하기" href="/post/2024-05-18-IncreasesecurityinyourFlutterapplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터 애플리케이션에서 보안 강화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터 애플리케이션에서 보안 강화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">플러터 애플리케이션에서 보안 강화하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="응용 프로그램 아키텍처 데이터 레이어" href="/post/2024-05-18-AppArchitectureDatalayer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="응용 프로그램 아키텍처 데이터 레이어" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-AppArchitectureDatalayer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="응용 프로그램 아키텍처 데이터 레이어" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">응용 프로그램 아키텍처 데이터 레이어</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link posts_-active__YVJEi" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"유닉스 리눅스에서 ls 명령어 해부하기","description":"","date":"2024-05-18 17:28","slug":"2024-05-18-DemystifyingthelsCommandinUnixLinux","content":"\nls 명령어의 기능을 간소화했어요.\n\n작은 이야기가 먼저!!!!\n\n3년 넘게 매일 리눅스 시스템과 함께 일했어요. 로봇처럼 생각 없이 과제를 수행했죠. 셸 스크립트와 Python 코드를 사용해서 자동화 작업을 했어요. 그러나 2024년 1월 29일, 어떤 명령어들이 작동하는 방식에 대한 호기심을 자극하는 문제를 마주했어요. 이 호기심은 명령어들이 어떻게 내부적으로 작동하는지 고려해보지 않은 저에게 놀라운 충격이었어요.\n\n누군가는 이 깨달음이 당연히 느껴질 수도 있겠지만, 제게는 진정한 성장의 순간이에요. 이 블로그를 지나치게 복잡하게 만들기보다, 현재 배우고 있는 것에 집중하고 싶어요. 저는 발견하는 모든 새로운 사실을 문서화하기로 결심했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제가 마주한 문제에 대해 이해하기 쉽게 설명하기 위해 나중 게시물에서 더 자세히 다룰 예정입니다. 여기서 설명하는 것이 가장 좋은 방법이 아닐 수 있으니 말이죠. 이제 첫 학습 경험을 향해 나아가 봅시다.\n\n# 그럼... 시작해봅시다!!\n\n설명에 따르면... Unix/Linux에서 ls Command 해석하기\n\n```js\nsilentstorm29@cloudmaniac ~ % ls -larth\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png)\n\n이게 일반적으로 우리가 사용하는 거잖아요??\n\nls 명령어는 Unix 및 Unix와 유사한 운영 체제의 중요한 요소입니다. 이 명령 줄 유틸리티는 디렉토리의 내용을 나열하는데, 보다 많은 기능을 제공합니다. 파일 및 디렉토리의 속성을 보기 위한 다양한 옵션을 제공하는데, 이는 권한, 소유권, 크기 및 수정 시간을 포함합니다.\n\n# ls 명령어의 힘을 발휘하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nls 명령어는 다양한 방식으로 사용할 수 있는 다재다능한 명령어입니다:\n\n- ls: 현재 디렉토리의 파일 및 디렉토리를 나열하는 간단한 방법입니다.\n- ls -l: 자세한 목록 형식으로 파일 및 디렉토리를 공개합니다.\n- ls -a: 숨겨진 파일 및 디렉토리를 모두 보여줍니다(점으로 시작하는 파일 포함).\n- ls -lh: 파일 및 디렉토리를 크기가 사용자 친화적인 형식으로 자세한 목록 형식으로 표시합니다.\n- ls /경로/디렉토리: 특정 디렉토리의 내용을 나열합니다.\n  ls 명령어는 유닉스와 비슷한 환경에서 중요한 위치를 차지하며 파일 시스템 탐색과 파일 관리에 필수적입니다.\n\n# 커튼 뒤: 시스템 호출\n\n유닉스와 비슷한 운영 체제에서 ls 명령어를 실행하면 여러 시스템 호출이 발생합니다. 다음은 발생하는 마법의 간소화된 순서입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 쉘(예: bash 또는 zsh)은 새 프로세스, 즉 쉘 프로세스의 복제본을 생성하기 위해 fork() 시스템 호출을 사용합니다.\n- 그런 다음, 새 프로세스는 exec() 시스템 호출을 사용하여 자신의 이미지를 ls 프로그램으로 대체하고 ls 프로그램을 메모리에 로드하여 실행을 시작합니다.\n- ls 프로그램은 디렉토리 내용을 읽고 파일에 대한 정보를 가져오기 위해 여러 시스템 호출을 활용합니다. 이러한 시스템 호출에는 open(), read(), getdents(), stat(), lstat(), fstat() 등이 포함됩니다.\n- ls 프로그램은 또한 write() 시스템 호출을 사용하여 디렉토리 목록을 표준 출력(일반적으로 여러분의 터미널)에 출력합니다.\n- ls 프로그램이 작업을 완료하면 exit()를 호출하여 종료합니다. ls 프로그램이 완료될 때까지 대기했던 원래 쉘 프로세스는 wait() 시스템 호출을 통해 완료 알림을 받습니다.\n\n# 옵션, 인수, 와일드카드 마스터하기\n\nls 명령은 옵션, 인수 및 와일드카드를 사용하여 동작을 수정할 수 있도록 유연하게 설계되어 있습니다. 각 구성 요소가 작동하는 방법을 살펴보겠습니다:\n\n옵션:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n옵션은 ls 명령어의 동작을 조절합니다. 예를 들어, -l은 자세한 형식으로 출력을 보여주고, -a는 숨겨진 파일을 포함한 모든 파일을 표시하며, -h는 파일 크기를 사람이 이해하기 쉬운 형식으로 표시합니다. ls 명령어는 이러한 옵션을 구문 분석하고 동작을 조정합니다. 이 과정에서 직접 시스템 호출을 수행하지는 않지만, 나중에 수행될 시스템 호출을 영향을 줄 수 있습니다. 예를 들어, -l 옵션은 ls가 각 파일에 대한 자세한 정보를 가져오기 위해 stat() 또는 lstat() 시스템 호출을 수행하도록 유도합니다.\n\n인수:\n\n인수는 일반적으로 ls가 작용해야 할 디렉터리 또는 파일의 이름입니다. 인수를 지정하지 않으면 ls는 현재 디렉터리의 내용을 나열합니다. 디렉터리 이름을 제공하면 해당 디렉터리의 내용을 나열합니다. 파일 이름을 제공하면 해당 파일만 표시합니다 (파일이 있는 경우). ls 명령어는 인수를 파일이나 디렉터리로 처리하여 나열합니다. 이때 인수가 디렉터리인지 파일인지 확인하기 위해 stat() 또는 lstat() 시스템 호출을 사용합니다. 디렉터리일 경우 ls는 open() 및 getdents() 시스템 호출을 사용하여 내용을 읽어옵니다.\n\n와일드카드:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n와일드카드는 다른 문자를 대표하는 기호입니다. 가장 흔한 와일드카드는 \"_\"로, 모든 문자의 어떤 개수를 나타냅니다. 예를 들어, ls _.txt는 .txt로 끝나는 모든 파일을 나열합니다. 또 다른 흔한 와일드카드는 \"?\"로, 어떤 하나의 문자를 나타냅니다. 예를 들어, ls ?.txt는 한 글자 이름을 가지고 .txt로 끝나는 모든 파일을 나열합니다. 쉘(=ls 명령어가 아닌)은 명령이 실행되기 전 와일드카드를 확장합니다. 예를 들어 ls _.txt를 실행하면 쉘은 현재 디렉토리에 있는 모든 .txt 파일의 이름으로 _.txt를 대체합니다. 이 과정에는 디렉터리 내용을 읽기 위해 open(), getdents(), close() 시스템 호출이 필요하며, 와일드카드 패턴에 따라 파일을 필터링하기 위해 stat() 또는 lstat()을 사용할 수도 있습니다. 와일드카드 확장 후, ls 명령이 확장된 인수와 함께 실행됩니다.\n\n옵션, 인수, 와일드카드를 함께 사용하는 예시는 다음과 같습니다:\n\n```js\nsilentstorm29@cloudmaniac ~ %ls -lh *.txt\n```\n\n\u003cimg src=\"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 디렉터리에서 .txt 파일을 자세한 형식으로 인간이 읽을 수 있는 파일 크기로 나열하는 이 명령어를 사용할 거에요.\n\n# 마무리!!\n\n`ls` 명령어의 내부 동작에 대해 파헤치는 것은 마술사의 마술 비밀을 발견하는 것과 같아요. 단순한 명령어가 정밀한 시스템 호출들이 조화롭게 작동하는 과정을 보는 것은 매우 흥미롭죠. 다음에 `ls`를 입력할 때 눈에 보이는 것보다 훨씬 많은 일이 벌어지고 있다는 것을 알게 될 거예요. 매일 사용하는 명령어 뒤의 마법을 계속 탐험하고 발견하세요 🔎. 질문은 댓글 섹션에서 환영합니다 — 즐거운 학습을 기대해요!\n\n\u003cimg src=\"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_2.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n잘 가!!\n","ogImage":{"url":"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png"},"coverImage":"/assets/img/2024-05-18-DemystifyingthelsCommandinUnixLinux_0.png","tag":["Tech"],"readingTime":6},{"title":"Swift Actors  깊이 있는 이해","description":"","date":"2024-05-18 17:26","slug":"2024-05-18-SwiftActorsindepth","content":"\n\u003cimg src=\"/assets/img/2024-05-18-SwiftActorsindepth_0.png\" /\u003e\n\n# 배우세요, 외우지 마세요.\n\n저는 개념의 내부 작동 원리를 이해하는 것을 좋아하는 사람입니다. 내재하는 메커니즘을 파악하지 못하면 개념에 대해 모든 것이 불분명하게 보이고 진정한 이해가 아닌 단순 외우기처럼 느껴집니다. 그래서 저는 여러 주요한 스위프트 개념인 액터(actors), 비동기/대기(async/await), 구조화된 동시성(structured concurrency), 그리고 AsyncSequence에 대해 탐구해왔습니다. 이러한 개념을 이해하기 쉽게 만들기 위해 각각의 개념을 실제적이고 현실적인 예를 사용하여 설명할 계획입니다. 먼저 액터에 대한 토론을 시작해보겠습니다.\n\n# 액터(actor)란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwift에서 Actor는 5.5 버전에서 도입된 참조 유형으로, 고급 동시성 모델의 일환으로 소개되었습니다. 주요 역할은 데이터 경쟁을 방지하고 동시 프로그래밍 환경에서 공유된 가변 상태에 안전하게 액세스하는 것입니다. 이를 더 잘 이해하기 위해 간단한 예시를 들어보겠습니다: 사무실의 프린터.\n\n![프린터](https://miro.medium.com/v2/resize:fit:1400/1*IEsYeP_QiG4ZmObPQ-vURA.gif)\n\n사무실에 모든 직원들이 사용할 수 있는 공유 프린터가 있는 상황을 상상해보세요. 어느 날 문서를 인쇄해야 해서 파일을 프린터에 보내고 수령하러 가는데, 프린터에 도착해보니 의외의 일이 벌어졌습니다: 출력된 페이지가 여러분의 파일과 일치하지 않습니다. 혼란스러운 상황에서 올바른 파일을 보냈다는 것을 재확인하더니, 다른 사람이 여러분의 인쇄 작업을 취소하고 자신의 작업을 시작한 것 같습니다. 이런 착각에 직면했을 때, 어떤 조치를 취할 것인지 고민해보실 거에요?\n\n![문제 해결](https://miro.medium.com/v2/resize:fit:960/1*mI-teGZmtwFc4VLeRWFh-Q.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문서를 출력한 후 확인 없이 그것을 바로 당신의 매니저에게 전달하는 상황을 상상해보십시오. 그것이 의도한 대로인지 확인하지 않은 채에, 문제가 발생할 수 있습니다. 공유 리소스를 다룰 때 프로그래밍에서도 비슷한 문제가 발생할 수 있습니다. Swift의 맥락에서, 클래스에 대해서 특히 중요한데, 이는 참조 유형입니다. 이 특성은 클래스의 인스턴스에 대한 모든 수정사항이 여러분의 애플리케이션에서 해당 클래스를 사용하는 모든 인스턴스에 반영될 것임을 의미합니다. 이는 공유 오피스 프린터에서 한 사람의 행동이 모두의 인쇄 작업에 영향을 미치는 것과 유사합니다. 이제, 특정 코드 예제를 살펴보겠습니다.\n\n```js\nclass Account {\n var balance: Int = 20//현재 사용자의 잔액은 20\n ...\n func withdraw(amount: Int) {\n  guard balance \u003e= amount else {return}\n  self.balance = balance - amount\n }\n}\n\nvar myAccount = Account()\nmyAccount.withdraw(20$)\n```\n\n우리 코드는 계좌에서 돈을 인출하는 간단한 작업을 수행합니다. 이 코드에서는 인출을 진행하기 전에 계정 잔액이 충분한지 확인합니다. 이 시나리오는 사무실에서 프린터를 사용하는 것과 유사합니다. 당신이 사무실에 혼자 있을 때, 프린터(계정 객체와 유사)를 사용하는 것은 문제가 없습니다. 그러나 다수의 사람(또는 우리의 프로그래밍 비유인 경우, 다수의 스레드)이 동시에 프린터를 사용하려고 하면 문제가 발생할 수 있습니다.\n\n이제, 멀티스레딩 환경에서의 Account 예제로 돌아가봅시다. 여러 CPU 코어가 있는 현대 모바일 장치와 같이 멀티스레딩 환경에서, 두 개의 스레드가 동시에 동일한 Account 객체에서 withdraw(20$) 함수를 실행하려고 시도한다고 상상해보십시오. 운영 체제는 이러한 스레드를 조절하고, CPU 코어를 할당하고, 그들의 실행을 관리하지만 우리는 정확한 작업 순서를 예측할 수 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요점은 다음과 같습니다: 첫 번째 스레드가 잔액을 확인하고 충분하다고 판단하면서(잔액 `= 금액) 출금을 하기 전에 문맥 전환으로 인해 두 번째 스레드가 실행을 시작합니다. 이 두 번째 스레드도 첫 번째 스레드가 아직 출금을 완료하지 않았기 때문에 잔액이 충분하다고 판단하여 돈을 인출하고 잔액을 0으로 만듭니다. 그런 다음, 첫 번째 스레드가 다시 실행되면, 두 번째 스레드에 의해 잔액이 이미 소진된 상태에서 돈을 인출하려고 시도합니다.\n\n이 상황은 두 명이 같은 프린터를 사용하려고 하는 것과 유사합니다. 이들이 조율하지 않으면 서로 방해하는 인쇄 명령을 보낼 수 있어 혼합이나 누락된 인쇄물이 발생할 수 있습니다. 계좌 예시에서, 이러한 조율의 부재는 계좌가 동일한 금액에 대해 두 번 차감되는 초과 인출로 이어지며, 프로그래밍에서 동시 액세스의 어려움을 보여줍니다.\n\n실제로 이전 예시에서는 잔액이 부족하여 두 출금 작업 중 하나가 거부되어야 했지만, 동시 액세스로 인해 두 작업이 모두 성공했습니다. 이 상황은 '경쟁 조건(Race Condition)'을 보여줍니다. 경쟁 조건은 여러 스레드가 동시에 공유 리소스인 여기서는 계좌 잔액을 액세스하고 수정하며, 이러한 작업의 최종 결과가 각 스레드의 실행 타이밍에 달렸을 때 발생합니다.\n\n경쟁 조건에서 결과는 프로그램의 제어 밖에 있는 특정 이벤트의 순서와 타이밍에 따라 예측할 수 없습니다. 계좌 예시에서의 문제는 두 스레드 모두 잔액을 확인하고 금액을 차감하기 전에 충분하다고 판단했기 때문에 발생했습니다. 이로 인해 두 스레드가 모두 인출을 진행하고, 잘못된 계좌 잔액이 발생했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 레이스 조건은 프로그래밍에서 심각한 문제입니다, 특히 데이터 일관성과 정확성이 중요한 시스템에서는 더욱 중요합니다. 이는 멀티 스레드 환경에서 공유 리소스를 신중하게 관리하여 작업이 안전하고 예측 가능한 방식으로 수행되도록하는 필요성을 강조합니다.\n\n# Actors\n\nSwift의 Actors는 이전에 논의한 동시성 문제에 대한 우아한 해결책을 제공합니다. Actors가 도입되기 전에는 DispatchQueue, Operations 및 Locks를 사용하여 동시 액세스를 관리하는 흔한 방법이 있었습니다. 이러한 방법은 효과적이었지만, 상당량의 수동 코드 및 관리가 필요했습니다.\n\n이제 Swift에서 Actor 유형을 도입함으로써 동시성 관리에 포함된 복잡성의 많은 부분이 숨겨졌습니다. 프린터 예에서 생각해보세요: 어떻게 해서 다른 사람의 인쇄 작업을 덮어 쓰지 않도록 보장할 수 있을까요? 이상적인 해결책은 인쇄 작업이 줄지어 있는 대기열이 있는 것입니다. 새 작업이 도착할 때마다 대기열에 가입하고 차례를 기다리며, 프린터는 각 작업을 순차적으로 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것이 정확히 배우는 방법입니다. Actor들은 내부 메일함을 가지고 있으며 이것은 큐처럼 작동합니다. Actor에 보내진 요청은 이 메일함에 저장되어 순차적으로 처리됩니다. 큐잉 메커니즘은 작업이 순서대로 실행되도록 보장해주어 경합 조건을 방지합니다. 게다가, 내부 큐와 메일함은 Actor 자체에서 관리되므로, 모든 복잡성이 개발자로부터 숨겨지게 됩니다. 이로써 Swift에서 동시성 작업을 처리하는 보다 간소화되고 오류 방지된 접근 방식이 가능해집니다.\n\n대박, 맞죠?\n\n![이미지](https://miro.medium.com/v2/resize:fit:400/1*CisZ-Zm-zu0MiLV45EpV9Q.gif)\n\n하지만 이것이 실제로 어떻게 작동하는지 궁금하시죠? Actor들은 '데이터 격리'를 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 격리를 이해하기 위해 사무실의 프린터 비유를 생각해보세요. 이 사무실 프린터를 별도의 방에 넣고 와이파이에서 분리한다고 상상해봅시다. 이제 누군가 인쇄하려면 물리적으로 이 방에 가서 차례를 기다려야 합니다. 이 설정은 프린터의 겹침이나 병행 사용을 효과적으로 방지하여 한 번에 한 사람만 사용할 수 있도록 합니다.\n\nSwift의 경우, 액터(actors)도 비슷하게 작동합니다. 액터 내부에 데이터를 캡슐화하면 프로그램의 다른 부분에서 직접 액세스할 수 없게 만듭니다. 데이터와 상호 작용하려면 액터를 통과해야 하는 코드가 필요하며, 효과적으로 '정렬'하여 차례를 기다립니다. 이는 동시성 환경에서도 액터가 데이터에 대한 액세스를 직렬화하여 한 번에 코드 한 개만 상호 작용할 수 있도록 합니다.\n\n이제 이 개념이 어떻게 실제로 적용되는지 알아보기 위해 코드를 살펴봅시다...\n\n개정된 Account 예제에서 클래스에서 액터로 전환은 놀랍도록 간단합니다. 정의에서 클래스를 액터로 변경하는 것만으로 Account 오브젝트가 스레드 안전해집니다. 이 변경은 구문적으로는 미미하지만, 동시성 환경에서 객체가 액세스되고 조작되는 방식에 중요한 영향을 미칩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nactor Account {\n var balance: Int = 20// 현재 사용자의 잔액은 20\n // ...\n func withdraw(amount: Int) {\n  guard balance \u003e= amount else {return}\n  self.balance = balance - amount\n }\n}\n```\n\n정말 쉽게 actor로 전환할 수 있습니다. 그러나 이 변경에는 일부 어려움이 딸립니다. 클래스를 actor로 전환한 후 코드를 컴파일하려고 하면 오류가 발생할 수 있습니다. 이는 actor의 특성과 데이터 고립 속성 때문에 발생하는 문제이며, 프린터를 별도의 방에 두고 Wi-Fi와 연결을 끊어버린 것에 비유할 수 있습니다.\n\n우리의 클래스를 actor로 변환하면 이제 해당 클래스의 속성과 메소드에 외부에서 직접 액세스할 수 없게 됩니다. actor는 스레드 안전을 보장하기 위해 엄격한 액세스 제어를 시행합니다. 따라서 이제는 이전에 Account 객체에 액세스했던 코드의 모든 지점을 업데이트해야 합니다. 일반적으로 Actor와 상호 작용하기 위해 async 및 await와 같은 비동기 패턴을 사용하여 메소드와 속성에 안전하게 직렬화된 액세스가 이루어지도록 해야 합니다.\n\n```swift\nvar myAccount = Account()\nmyAccount.withdraw(20$)  // 이 줄은 더 이상 유효하지 않습니다\nawait myAccount.withdraw(20$) // 좋아요\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 배우와 배역 간 참조\n\nSwift에서 배우가 데이터 격리를 보장한다고 말할 때, 이는 배우 내의 모든 가변 속성과 함수가 외부로부터 직접 액세스되는 것과 격리된다는 것을 의미합니다. 이 격리는 배우의 핵심 기능이며, 병렬 프로그래밍에서 스레드 안전성을 보장하기 위한 중요한 요소입니다. 그렇다면 이 격리는 이러한 속성과 함수에 액세스하고 수정하는 데 어떤 영향을 미칠까요?\n\n기본적으로 배우의 속성을 읽거나 값을 변경하거나 함수를 호출하려면 일반 클래스나 구조체처럼 직접 수행할 수 없습니다. 대신, 말그대로 '순서를 기다려야' 합니다. 이는 배우의 메일함에 요청을 보내는 것으로 이루어집니다. 그러면 요청이 대기열에 들어가 순서대로 처리됩니다. 요청이 처리될 차례가 되면 해당 요청을 처리할 수 있을 때만 배우의 속성을 읽거나 수정하거나 함수를 호출할 수 있습니다.\n\n이 과정을 배우 간 참조라고 합니다. 배우 외부에서 배우 내부의 내용을 참조하거나 액세스할 때 배우 간 참조를 하게 됩니다. 실제로는 비동기 패턴을 사용하여 배우와 상호 작용하는 것을 의미합니다. 이러한 구조를 사용하면 코드가 효과적으로 다음과 같이 말합니다. `이 배우 내부의 내용에 액세스하거나 수정해야 합니다. 여기가 제 요청입니다. 안전하고 적절한 시기가 돌아올 때까지 비동기로 기다리겠습니다.`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러니까, 배우들에서 데이터 격리는 배우의 내부 상태와 외부 세계 간의 모든 상호작용이 이를 통해 조절되는 비동기 프로세스를 통해 이루어져야 함을 의미합니다. 이를 통해 배우가 동시 액세스 충돌의 위험 없이 안전하게 상태를 관리할 수 있습니다.\n\n```js\nactor Account {\n var balance: Int = 20// 현재 사용자 잔액은 20입니다.\n // ...\n func withdraw(amount: Int) {\n  guard balance \u003e= amount else {return}\n  self.balance = balance - amount\n }\n}\n\nactor TransactionManager {\n    let account: Account\n\n    init(account: Account) {\n        self.account = account\n    }\n\n    func performWithdrawal(amount: Int) async {\n        await account.withdraw(amount: amount)\n    }\n}\n\n// 사용법\nlet account = Account()\nlet manager = TransactionManager(account: account)\n\n// TransactionManager 배우에서 인출 수행\nTask {\n    // 배우 간 참조\n    await manager.performWithdrawal(amount: 10)\n}\n\n// 배우 바깥에서 인출 수행\nTask {\n    // 배우 간 참조\n    await myAccount.withdraw(amount: 5)\n}\n```\n\nSwift의 동시성 모델에서 await 키워드는 배우와 함께 작업할 때 특히 중요한 구성 요소입니다. 흥미롭게도, 배우 내 withdraw 함수를 명확하게 async로 표시할 필요가 없었음을 알 수 있습니다. 이는 기본적으로 배우의 모든 함수가 배우 자체의 특성으로 인해 잠재적으로 비동기로 간주되기 때문입니다. 외부에서 배우와의 모든 상호작용은 본질적으로 비동기이며, 따라서 어떤 배우 간 참조도 await로 선행되어야 합니다.\n\nawait를 사용하는 것은 실행에서 잠재적인 일시 정지를 나타내는 것과 같습니다. 마치 다른 사람이 사무실 프린터를 사용할 때 차례를 기다리는 것과 유사합니다. 이는 Swift 런타임에게 코드에서 이 지점이 배우가 요청을 처리할 준비가 될 때까지 실행을 보류해야 할 수도 있다고 알려주는 것입니다. 이러한 보류는 항상 발생하는 것은 아닙니다. 배우가 다른 작업으로 바쁘지 않다면 코드는 즉시 계속 진행됩니다. 이것이 '가능성 있는' 보류 지점으로 표현하는 이유입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 출금 시나리오에 이를 적용하면, 구현이 훨씬 안전하고 예측 가능해집니다. 두 스레드가 동시에 같은 계좌 엑터에서 출금을 실행하려고 할 때를 상상해보세요. 엑터와 await가 준비되어 있으면, 운영 체제가 첫 번째 스레드에서 두 번째 스레드로 실행을 전환하더라도, 두 번째 스레드가 즉시 출금 함수에 진입하지 않습니다. 실행이 중간에 멈추고 await 지점에서 일시 중지되어, 첫 번째 작업이 완료될 때까지 기다립니다. 이렇게 하면 작업이 직렬화되어 첫 번째 스레드가 출금을 완료한 후에야 엑터가 두 번째 스레드의 요청을 처리합니다. 이 시점에서 두 번째 스레드는 잔액이 다음 출금에는 충분하지 않음을 발견하고, 함수가 계좌 잔액에 더 이상 변경을 가하지 않고 반환됩니다.\n\n이러한 방식으로, 엑터 모델은 비동기 액세스 패턴과 await 키워드로 공유 리소스인 계좌 객체에 대한 작업을 안전하게 처리하여 경쟁 조건을 방지하고 데이터 무결성을 유지합니다.\n\n# 직렬 실행기\n\nSwift의 엑터에 대한 논의에서, 각 엑터는 해당 메일박스 내의 작업(또는 '메일')을 하나씩 처리하는 내부 직렬 큐를 가지고 있다고 언급했습니다. 엑터의 내부 큐는 직렬 실행기(Serial Executor)로 알려져 있으며, 이는 직렬 DispatchQueue와 비슷한 역할을 합니다. 그러나 이들 사이에는 작업 실행 순서와 기본 구현의 처리 방식을 비롯한 중요한 차이점이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOne significant difference is that tasks waiting on an actor’s Serial Executor are not necessarily executed in the order they were awaited. This is a departure from the behavior of a Serial DispatchQueue, which adheres to a strict first-in-first-out (FIFO) policy. With a Serial DispatchQueue, tasks are executed exactly in the order they are received.\n\nOn the other hand, Swift’s actor runtime employs a lighter and more optimized queue mechanism compared to Dispatch, tailored to leverage the capabilities of Swift’s async functions. This difference stems from the fundamental nature of executors versus DispatchQueues. An executor is essentially a service that manages the submission and execution of tasks. Unlike DispatchQueues, executors are not bound to execute jobs strictly in the order they were submitted. Instead, executors are designed to prioritize tasks based on various factors, including task priority, rather than solely on submission order.\n\nThis nuanced difference in task scheduling and execution between Serial Executors and Serial DispatchQueues underpins the flexibility and efficiency of Swift’s actor model. Executors offer a more dynamic way to manage tasks, especially in a concurrent programming environment. I plan to explore Executors more deeply in a separate discussion to further elucidate their role and advantages in Swift’s concurrency model.\n\n# Rules\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 액터 내의 읽기 전용 속성에 접근할 때는 await을 사용할 필요가 없습니다. 왜냐하면 이들 값은 불변이기 때문에 변경되지 않기 때문이죠.\n\n```js\nactor Account {\n **let accountNumber: String = \"IBAN---\"**\n var balance: Int = 20 // 현재 사용자 잔액은 20입니다.\n // ...\n func withdraw(amount: Int) {\n  guard balance \u003e= amount else {return}\n  self.balance = balance - amount\n }\n}\n\n**/// 이 부분은 괜찮아요 ✅**\nlet accountNumber = account.accountNumber\nTask {\n **/// 이 부분은 괜찮아요 ✅**\n let balance = await account.balance\n\n **/// 이 부분은 좋지 않아요 ❌**\n let balance = ****account.balance // 에러\n}\n```\n\n2. 액터 간 참조에서 변경 가능한 변수를 수정하는 것은 금지되어 있습니다. await을 사용해도 안 됩니다.\n\n```js\n/// 이 부분은 좋지 않아요 ❌\naccount.balance = 12 // 에러\n\n/// 이 부분은 좋지 않아요 ❌\nawait account.balance = 12 // 에러\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 모든 액터에 고립된 함수는 await 키워드와 함께 호출되어야 합니다.\n\n# 고립되지 않은 함수\n\nSwift의 동시성 모델에서 액터 내의 비고립 멤버 개념이 중요한 역할을 합니다. 비고립 멤버를 통해 액터의 일부를 비동기 호출이나 액터 작업 대기 순번을 기다리지 않고도 액세스할 수 있습니다. 이는 액터 상태를 수정하지 않는 속성이나 메서드에 특히 유용하며, 이로 인해 경쟁 조건이나 다른 동시성 문제를 발생시키지 않습니다.\n\n```js\nactor Account {\n let accountNumber: String = \"IBAN...\" // 상수, 비고립 속성\n var balance: Int = 20 // 현재 사용자 잔고는 20\n  // 고립되지 않은 함수\n nonisolated func getMaskedAccountNumber() -\u003e String {\n  return String.init(repeating: \"*\", count: 12) + accountNumber.suffix(4)\n }\n func withdraw(amount: Int) {\n  guard balance \u003e= amount else { return }\n  self.balance = balance - amount\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet accountNumber = account.**getAccountNumber()**\n```\n\n당신의 예제에서 accountNumber는 Account actor 안에서 상수 속성(let)이며 변경불가능합니다. 이 불변성은 스레드 안전하고 격리가 필요하지 않다. 결과적으로, accountNumber는 actor의 일부임에도 불구하고 await 키워드 없이 동기적으로 액세스할 수 있습니다. 반면에 balance는 변경 가능한 속성이며 actor 내에서 격리가 필요합니다. withdraw 함수와 같은 balance와의 상호작용은 종종 비동기 액세스가 필요한 actor의 격리 프로토콜을 준수해야 합니다.\n\nactor 내부의 격리된 멤버와 격리되지 않은 멤버 사이의 구별은 중요합니다. 이는 엄격한 격리가 필요하지 않은 시나리오에서 성능을 최적화하고 코드를 간소화하는 데 도움이 됩니다. 동시성 관리와 안전성을 유지하면서도 actor 모델에 내재된 특성을 유지합니다.\n\n# 중요 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Concurrency Management에 대한 배우기: 우리는 Swift Actors를 Swift 5.5의 동시성 모델의 중요한 부분으로 소개했는데, 이는 공유 가능한 가변 상태를 안전하게 처리하고 데이터 레이스를 방지하기 위해 특별히 설계되었습니다.\n- 동시성 문제 해결: Race 조건, 데드락, 리블락과 같은 일반적인 동시성 문제에 대해 이야기하고, Actor가 이러한 문제를 완화하는 방법을 보여줬습니다. 이러한 문제들은 전통적으로 DispatchQueue, Operations, 그리고 Locks를 이용해 관리되었습니다.\n- 쓰레드 안전성과 직렬 실행: Actor는 Swift 애플리케이션의 쓰레드 안전성을 강화합니다. 내부 큐 안에서 직렬로 작업을 처리하여 큐 관리자처럼 작동함으로써 작업이 한 번에 처리되도록 보장하며 이로써 동시성 충돌을 피합니다.\n- Cross-actor Reference 이해: Cross-actor 참조의 개념은 중요합니다. 이는 Actor의 속성이나 메서드에 접근하기 위해 await 키워드를 사용함으로써 효율적인 작업 관리를 위한 중단 지점을 표시하는 것을 필요로 합니다.\n- 직렬 Executors 대 DispatchQueues: Actor의 직렬 Executor와 직렬 DispatchQueue의 주요 차이를 강조했습니다. Actor는 엄격한 선입선출 순서에 묶이지 않으며 여러 요인에 기반해 작업을 우선 순위로 처리할 수 있습니다.\n- Actor와 상호 작용하는 규칙: Actor와 상호 작용하는 특정 규칙을 개요로 설명했는데, 가변 속성에 대한 비동기 접근과 격리된 함수를 기다리는 필요성을 강조했습니다.\n- Actors 내의 비 격리 구성원: Actor 내의 비 격리 구성원 개념을 소개했습니다. 이는 쓰레드 안전성을 저해하지 않고 특정 속성이나 메서드에 동기적으로 액세스하는 데 유용합니다.\n- 더 나은 이해를 위한 실제 예시: Account actor 예시를 통해, 우리는 Actor가 어떻게 상태를 안전하게 유지할 수 있는지 효과적으로 활용할 수 있는 방법에 대해 실제로 보여줬습니다.\n- Exectors에 대한 미래 전망: 미래의 토론에서 Exectors에 대한 심층적인 탐구를 약속하며, Swift의 동시성 모델 이 측면에 대해 보다 자세히 탐구할 것을 기대하고 있습니다.\n\n# 결론\n\nSwift Actors의 세계를 완전히 탐험한 우리의 여정을 통해, Swift의 동시성 모델에서 이 강력한 기능의 심오함과 복잡성을 발견했습니다. Actor는 Swift 5.5의 기본 부분으로, 우리가 공유 가능한 가변 상태와 동시성 문제에 접근하는 방식을 재정의하여 제공하며, 전통적인 방법인 DispatchQueue, Operations, Locks와 비교해 보다 강력하고 안전한 동시성 프로그래밍 도전을 처리하는 방법을 제공합니다.\n\nActor가 Race 조건, 데드락, 리블락과 같은 일반적인 동시성 문제에 대한 보호 기능으로 작용함을 보았는데, 기존 방법보다 스트리밍되고 효율적인 접근을 제공합니다. Actor의 도입은 동시성 관리를 단순화하는 중요한 진전을 나타내어 개발자들에게 더 접근성이 높고 오류가 적은 방법으로 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앞으로 계속 발전해 나가는 동안, 미래 토론에서 Executor에 대해 더 심층적으로 파고들 수 있는 약속은 Swift의 동시성 모델에서 더 발전된 주제들을 다룰 수 있는 문을 열어줍니다. 이 탐험은 단지 프로그래밍 기능을 이해하는 데 그치지 않고, 더 안전하고 신뢰성이 높고 효율적인 Swift 코드를 작성하는 새로운 패러다임을 수용하는 데 관한 것입니다.\n\n맺음말로, Swift Actor는 Swift 개발자들에게 새로운 도구가 아닌, 우리가 동시성에 대해 생각하고 처리하는 방식에 근본적인 변화를 가져다 줍니다. 이는 코드를 더 안전하고 예측 가능하며 논리적으로 이해하기 쉽게 만들어줍니다. Swift Actor에 대한 이 탐험은 계속 발전하여 현대 소프트웨어 개발의 요구를 충족하기 위해 지속적으로 적응하고 개선하는 언어인 Swift의 진화의 증거입니다.\n","ogImage":{"url":"/assets/img/2024-05-18-SwiftActorsindepth_0.png"},"coverImage":"/assets/img/2024-05-18-SwiftActorsindepth_0.png","tag":["Tech"],"readingTime":18},{"title":"iOS 174 출시 - 지금 꼭 시도해봐야 할 25가지 이상의 멋진 새로운 기능","description":"","date":"2024-05-18 17:22","slug":"2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow","content":"\niOS 17.4 업데이트가 드디어 공개되었습니다.\n\n지금 말씀드리는 것이 과장이 아니라면, iOS 17.4는 iOS 역사상 가장 큰 소규모 업데이트 중 상위 다섯에 들 수 있습니다. 왜냐하면?\n\n애플은 싫어하지만, EU의 법률과 조치를 준수하기 위해 회사가 타사 앱 스토어 및 브라우저 엔진을 허용하기 위해 소극적인 조치를 취해야 했습니다.\n\n이것은 역대급의 대단한 움직임입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한 업데이트로 16가지 이상의 새 이모티콘, iMessage에 대한 역사상 최고 수준의 보안 및 Podcasts, Wallet, CarPlay에 대한 다양한 새로운 변경 사항이 도입되었습니다. 이 변경 사항은 당신의 iPhone을 전에 없던 것으로 만들어줍니다.\n\niOS 17.4의 모든 주목할만한 기능 및 변경 사항에 대한 정보를 여기에 소개하겠습니다. 이는 당신이 경험한 최고의 iOS 환경을 위해 알아야 할 모든 크고 작은 변경 사항입니다.\n\n# 이 기사에서 다루는 내용\n\nEU-특정 변경 사항\n1 — Sideloading 활성화됨!\n2 — 제 3자 브라우저 엔진 지원\n일반 변경 사항\n새로운 메시지 변경 사항\n3 — 16가지 새 이모티콘\n4 — 비즈니스용 메시지\n5 — Siri가 다른 언어로 메시지를 읽어줄 수 있음\n6 — 지금까지 가장 안전한 iMessage\n새로운 설정 변경 사항\n7 — 도난 단말기 보호에 대한 중요한 변경 사항\n8 — 혁신적인 배터리 UI\n새로운 Podcasts \u0026 Music 변경 사항\n9 — 라이브 전사본과 함께 Podcasts 팔로우\n10 — 정보 보기 위해 에피소드 이름 탭하기\n11 — Shazam에서 선택한 음악 재생목록에 추가하기\n일관성을 위한 변경 사항\n12 — 혁신적인 iCloud 아이콘\n13 — 책, 음악 및 Podcasts를 위한 홈 섹션\n14 — Podcasts의 '현재 재생 중' 막대가 Apple Music을 모방\n새로운 연락처 변경 사항\n15 — 연락처 페이지를 위한 새 UI\n16 — 업체에 대한 Apple-검증 정보가 표시되는 전화 식별\n17 — 통화 화면을 위한 흐릿한 배경화면\n새로운 홈 및 잠금 화면 변경 사항\n18 — 새로운 시계 위젯\n19 — 홈 화면으로부터 설정된 배경화면은 기본적으로 흐리지 않음\n새로운 Shortcuts 변경 사항\n20 — 새로운 Shortcut 블록\n21 — 홈 화면에 Shortcut 추가를 위한 새 UI\n새로운 Wallet 변경 사항\n22 — Apple Card에 대한 가상 카드 번호 획득\n23 — Apple Pay 개선\n새로운 CarPlay 변경 사항 공개\n24 — 차량을 꺼닐 때 CarPlay이 작별 인사를 합니다.\n25 — 새로운 CarPlay 앱 및 아이콘\n새로운 백엔드 변경 사항\n26 — 게임 스트리밍이 이제 가능함\n27 — 케이블을 위한 펌웨어 업데이트!?\n28 — 제 3자 브라우저의 Passkeys에 액세스\n새로운 잡다한 변경 사항\n29 — 앱 스토어에서 구매 기록\n30 — AirDrop 2.0을 사용하여 노트 및 게임 공동 작업\n31 — 독일어에서 Siri 호출 시 'Hey' 삭제\n32 — TV의 혁신적인 '시청 방법' UI\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# — 유럽 특별 변경사항 —\n\n# #1. 사이드로딩이 활성화되었습니다!\n\n사이드로딩이 iOS에 도착했습니다!\n— 이게 기술 역사상 가장 대단한 소식 중 하나 아닌가요?\n\n이 기능은 원본 앱 스토어 이외의 소스에서 앱을 설치할 수 있는 시설을 제공합니다 (대안적 앱 마켓이라고도 함) — 플레이 스토어, 아마존 앱스토어, \u0026 Setapp과 같이(이들이 iOS에 도착할지는 확실하지 않지만, 아이디어를 주기 위해 말씀 드립니다).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(앱 마켓플레이스 ≈ iOS 앱을 설치할 수 있는 iOS 앱)\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_0.png)\n\n이것은 애플의 원래 App Store 이외에 iPhone에서 여러 앱 스토어를 동시에 사용할 수 있다는 것을 의미합니다.\n\n가장 좋은 점은 대체 앱 스토어를 기본 앱 스토어로 설정할 수 있다는 것입니다. 이것은 기본 브라우저를 변경하는 것만큼 쉽게 할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만, Apple은 개인 정보 보호 및 보안 약속을 준수하여 대체 앱 스토어에서 설치된 앱의 악성 코드를 경고하고, 그렇다면 해당 앱을 열 수 없도록 합니다.\n\n또한 새로운 Screen Time 설정이 추가되어 부모님들이 자녀가 대체 앱 스토어에서 앱을 설치할 수 있는지 여부를 결정할 수 있게 됩니다.\n\n## 2. 3rd party 브라우저 엔진 지원\n\n또한 Apple은 타사 브라우저가 자체 브라우저 엔진을 사용할 수 있도록 지원합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n무엇이 브라우저 엔진인가요?\n모든 브라우저의 핵심적인 부품으로, 기본 HTML 문서를 아름다운 페이지로 변환해주는 역할을 합니다.\n각 브라우저는 엔진을 속도와 추가 기능을 개선할 수 있는 자유를 취할 수 있습니다.\n\n처음부터 Apple은 iOS에서 많은 브라우저를 허용해왔지만 엔진은 Webkit만 사용할 수 있었습니다 (Apple자체 엔진). 심지어 Blink와 Gecko를 다른 곳에서 사용하는 Chrome과 Firefox도 iOS에서는 WebKit에 고수해야 했습니다.\n\n이로 인해 제 3자 브라우저들이 많은 기능과 개선을 가져오는 자유가 제한되었습니다.\n\n하지만 이제 Apple이 iOS에서 WebKit 이외의 브라우저 엔진을 실행하는 데 관대한 태도를 취하기 시작했기 때문에, EU 지역 사용자들은 자신들이 좋아하는 브라우저에 더 많은 기능을 기대할 수 있습니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플은 iOS에서 엔진을 실행하기 전에 철저한 점검을 하지만, 대부분의 인기 있는 엔진은 잘 작동할 것으로 예상됩니다.\n\n# 일반적인 변경 사항\n\n## • 새 메시지 변경 사항\n\n### 3. 새 이모지 16개\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플이 Emoji 15.1 표준을 준수하는 새로운 16개의 이모티콘을 도입했어요. 이 이모티콘들에 대한 설명은 글의 끝에 모두 나와 있으니 참고하세요.\n\n- 첫 두 줄의 이모티콘은 새로운 개념이에요.\n- 세 번째 줄의 이모티콘은 이전의 왼쪽을 향한 이모티콘들의 혁신된 복사본이에요.\n- 네 번째 줄의 이모티콘은 가족 이모티콘 스위트(👨‍👩‍👧‍👦와 같은)들을 대체했어요.\n\n새로 추가된 이모티콘들과 그 설명을 게시글 끝에 모두 나열해 두었으니 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #4. 비즈니스를 위한 메시지\n\n설정 ⚙️ ` 메시지 💬에서 '비즈니스 및 개인 정보에 대한 메시지'라는 하이퍼링크가 있었습니다.\n\n이제 '비즈니스를 위한 메시지' 섹션으로 교체되었습니다.\n\n이 섹션에는 '비즈니스 업데이트'라는 단일 토글이 있어서, 비즈니스 웹 사이트에서 선택한 경우 주문 및 기타 거래에 대한 업데이트를받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_2.png)\n\nThe toggle is enabled by default.\n\n## #5. Siri can read out messages in different languages\n\nDid you know you could skip that step where Siri asks for confirmation before you send a message to someone?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_3.png)\n\nTo do that, toggle on ‘Automatically Send Messages’ in Settings ⚙️ Siri \u0026 Search. And bravo! You’ll never see that frustrating confirmation part again.\n\nHowever, with iOS 17.4, that section is replaced with ‘Messaging with Siri’ — where, along with Automatically Sending Messages, you can also select a few languages which Siri will use to read out messages for you.\n\n![Image 2](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 다양한 언어로 메시지를 주고 받는 국제적인 친구들이있으면 가장 도움이 됩니다. 여기서 설정한 언어는 Siri의 기본 언어에 영향을주지 않습니다.\n\n## #6. 가장 안전한 iMessage\n\n애플은 최근에 iMessage가 PQ3라고 불리는 혁신적인 후양자 암호 프로토콜을 사용하여 이제 보안될 것이라고 발표했습니다.\n\n이것은 iOS 17.4 (및 해당 버전)로 업데이트하는 모든 사람들을 위한 백엔드 변경 사항으로 사용자들이 \"선택\"해야 하는 것이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n회사는 PQ3의 보안이 \"널리 배포된 다른 모든 메시징 앱보다 뛰어나다\"며 \"세계에서 가장 강력한 보안 속성을 갖춘 다량 메시징 프로토콜이다\"고 주장합니다.\n\nApple은 PQ3가 어떻게 작동하는지 설명하고 있습니다:\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_5.png)\n\n회사는 PQ3가 소위 레벨 3 보안을 달성한다고 주장합니다 - 이는 \"초기 키 설정 및 계속되는 메시지 교환 모두를 보호\"합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# • 새로운 설정 변경 사항\n\n## #7. 스마트폰 도난 방지 기능에 중요한 변경 사항\n\niOS 17.3의 스마트폰 도난 방지 기능은 사용자의 개인 정보 보호와 보안을 위한 훌륭한 새로운 추가 기능입니다.\n\n이 기능은 중요한 시스템 설정을 변경하려는 경우 생체 인증 확인 및 1시간의 지연 시간을 설정합니다. 이 기사에서 자세한 정보 확인 →\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 익숙한 장소(집이나 직장과 같은)에 있는 경우에는 지연이 필요하지 않습니다. 낯선 장소에 있는 경우에만 두 가지를 모두 참석해야 합니다.\n\n그러나 iOS 17.4에서, Apple은 귀하의 iPhone이 위치에 관계없이 1시간의 지연을 시행할 수 있는 유용한 기능을 제공합니다. (설정에서 조정하세요 ⚙️ ' Face ID \u0026 Passcode 🙂 ' 스마트 기기 보호.)\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_6.png)\n\n- '항상'을 선택하면 항상 1시간의 지연이 시행됩니다.\n- '익숙한 장소에서 멀리 떨어져 있음'을 선택하면 지연을 시행하기 전에 위치를 확인합니다. 익숙한 경우, 빠른 Face ID 확인 후에 중요 설정에 즉시 액세스할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #8. 새롭게 개선된 배터리 UI\n\n애플이 왜 새로운 배터리 관련 변경 사항을 iPhone 15 시리즈에만 제공하는지 이해가 안 가네요. 어쨌든, 새로운 내용을 하나 또 소개해 드릴게요:\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_7.png)\n\niPhone 15 시리즈 모델을 소유하신다면, 설정 ⚙️ ` 배터리 🔋로 이동하시면 '배터리 상태 및 충전' 섹션이 두 부분으로 나누어진 것을 확인할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 배터리 상태: 배터리 상태, 최대 용량, 사이클 횟수, 제조 날짜 및 최초 사용 날짜를 표시합니다.\n- 충전 최적화: 깨끗한 에너지 충전을 위한 토글과 최적화된 배터리 충전, 80% 제한, 또는 없음 중 선택할 수 있는 기능이 포함되어 있습니다.\n\n또한 기억하신다면, 이전에는 사이클 횟수가 설정 ⚙️ `일반 ⚙️` 정보에 있었지만 이제 배터리 상태로 이동되었습니다.\n\n# • 새로운 팟캐스트 및 음악 변경 사항\n\n## 9. 라이브 대본과 함께 팟캐스트 팔로우하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_8.png\" /\u003e\n\n팟캐스트 사용자들이 영원히 사랑할 환상적인 기능이에요.\n\n이건 팟캐스트의 애플 뮤직 가사 버전이에요. 이제 팟캐스트와 대본을 함께 따라갈 수 있어요. 이를 활성화하려면 왼쪽 하단의 대본 표시를 탭하면 돼요.\n\n가장 좋은 부분은, 대본에서 단어나 구를 검색할 수 있다는 거에요. 좋아하는 부분으로 건너뛰고 싶을 때 매우 유용해요. 주의:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 트랜스크립트는 영어, 스페인어, 프랑스어 및 독일어를 지원합니다.\n- 트랜스크립트의 일부를 탭하여 팟캐스트의 해당 부분으로 건너뛸 수 있습니다.\n- 텍스트 크기, 대비 증가 및 VoiceOver와 같은 접근성 기능과 잘 작동합니다.\n\n## #10. 에피소드 이름을 탭하여 정보 보기\n\n이 기능은 꽤 멋진 기능입니다 — 이제 팟캐스트 에피소드의 이름을 탭하여 해당 정보 페이지로 이동할 수 있습니다.\n\n이를 Apple이 아래에 표시된대로 프롬프트로 제안할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Shazam](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_9.png)\n\n## #11. Shazam에서 선택한 음악 재생목록에 추가\n\nShazam은 항상 별도의 Apple Music 재생목록을 갖고 있어 Shazamed 곡을 저장할 수 있었습니다.\n\n그러나 이제 Shazam 앱이나 제어 센터를 통해 노래를 Shazam하면 '추가' 버튼이 나타나며, 이를 통해 원하는 Apple Music 재생목록에 노래를 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 Shazam에서 식별한 노래를 Spotify나 Apple Music Classical에서도 바로 재생할 수 있어요. 그냥 오른쪽 상단의 세 점을 탭해 보세요.\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_10.png)\n\n# • 일관성을 위한 변경 사항\n\n## #12. 새롭게 디자인된 iCloud 아이콘\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFiles 앱의 iCloud 아이콘이 업데이트되었습니다.\n\n![iCloud Icon](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_11.png)\n\n이제 아이콘이 투명해지며 Mac 아이콘과 비슷해졌어요. 이것은 모든 Apple OS에서 일관성을 유지하는 좋은 일이에요.\n\n## #13. 책, 음악 및 팟캐스트용 홈 섹션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플은 '홈'으로 Books, Music 및 Podcasts 앱의 모든 주요 섹션을 변경하여 간소화와 일관성을 제공했습니다.\n\n예를 들어:\n\n- Books: Read Now → Home\n- Music \u0026 Podcasts: Listen Now → Home\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_12.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 14. 팟캐스트의 '재생 중' 바가 애플 뮤직을 모방합니다\n\n또한, 팟캐스트 앱의 '재생 중' 바(하단)가 이제 애플 뮤직과 유사해졌습니다. 확인해보세요:\n\n이전에는:\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_13.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제는:\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_14.png)\n\n# • 새로운 연락처 변경 사항\n\n## #15. 연락처 페이지를 위한 새로운 UI\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 17.3 버전까지 연락처 페이지에서 연락처 사진이 화면의 절반 이상을 차지하여 더 많은 세부 정보를 확인하려면 아래로 스크롤해야 했습니다.\n\n하지만 이제 사진 공간이 상당히 축소되어 다른 세부 정보에 더 많은 공간이 남게 되었습니다. 내 생각에는 이게 더 좋습니다.\n\n![Contact Photo](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_15.png)\n\n## #16. 전화 식별은 비즈니스를 위한 애플 검증 정보를 표시합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 17.4 릴리스 노트에서 Apple은 Apple 식별 비즈니스로부터 전화를 받으면 iPhone의 통화 화면에 사용 가능한 경우 비즈니스 이름, 로고, 부서 이름이 표시된다고 언급합니다.\n\n#### 17. 통화 화면에 대한 흐릿한 배경 화면\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이폰으로 통화 중에 상대방과 이야기하고 있다면, 전화 화면의 배경이 더 이상 일반적인 회색이 아닌 당신의 배경화면의 흐린 버전으로 변경되었음을 알 수 있을 거에요.\n\n![](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_16.png)\n\n# • 새로운 홈 및 잠금 화면 변경\n\n## #18. 새로운 시계 위젯\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 새로운 시계 위젯을 받았어요 — '시티 디지털'이라고 해요:\n\n![City Digital](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_17.png)\n\n이 위젯은 다른 시티 위젯들이 보여주는 정보를 그대로 표시하지만, 정사각형 모양이고 디지털 시간을 표시해요.\n\n그리고 이 위젯은 하루 시간에 반응해서, 시골의 날이며 밤이면 검은색으로 변하고, 낮이면 흰색으로 보여요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #19. 홈 화면에서 벽지 설정 시 기본적으로 흐림 처리되지 않음\n\n애플이 사용자 친화성을 위해 이렇게 했습니다.\n\n- 잠금 화면에서 사진 앱의 벽지를 적용하면 홈 화면의 벽지가 기본적으로 흐리게 표시됩니다.\n- 그러나 사진 앱에서 직접 적용하는 경우(공유 ` 벽지로 사용) 홈 화면이 기본적으로 일반적으로 표시됩니다.\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_18.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지를 언제든지 흐리게하거나 흐리게 한 후에 다시 표시할 수 있습니다.\n\n# • 새로운 바로 가기 변경 내용\n\n## #20. 새로운 바로 가기 블록\n\n바로 가기 중독자 (나처럼)이라면, 여기 새로운 블록이 있어요 — Get Physical Activity 🚶‍♂️‍➡️.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_19.png)\n\n현재 움직임을 나타내는 신체 활동을 반환합니다 (걷기, 뛰기 또는 이동 차량).\n\niPhone, iPad 및 Apple Watch에서는 내장 센서를 사용하여 신체 활동을 결정하고 반환합니다. 다른 모든 기기에서는 \"알 수 없음\"을 반환합니다.\n\n## #21. 홈 화면에 바로 가기 추가를 위한 새로운 UI\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 놀라운 사용자 경험 변경입니다.\n홈 화면에 바로 가기를 추가하려고 하는 경우, 이제 실제 배경화면이 뒤에 있는 미리보기를 볼 수 있습니다.\n\n![Shortcut Preview](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_20.png)\n\n이것은 바로 가기의 색상과 아이콘이 배경과 잘 어울리는지 확인하는 데 도움이 될 것입니다.\n\n# • 새로운 월렛 변경내역\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #22. Apple Card용 가상 카드 번호 받기\n\n애플 캐시 카드는 애플 월렛에 필수적인 기능입니다.\n\n가장 간단한 방법으로 친구나 가족들에게 돈을 보내거나 받을 수 있습니다. 또한 Apple Pay를 허용하는 상점에서 기타 선불 카드와 같이 사용할 수도 있습니다.\n\n하지만 Apple Pay를 지원하지 않는 상점/웹사이트에서 카드 세부 정보를 요청하는 경우는 어떻게 해야 할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문제 없어요. iOS 17.4에서는 기존 가상 Apple Cash 카드에 대한 카드 번호, 만료 날짜 및 보안 코드 세트를 생성할 수 있어요.\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_21.png)\n\n가장 좋은 점은,\n\n- 카드 세부 정보가 침해되었을 경우 언제든지 새로운 세트를 생성할 수 있어요. 기존 세부 정보는 더 이상 사용할 수 없어요.\n- 업데이트된 카드 세부 정보는 자동으로 Safari Autofill에 저장돼요.\n- 보안 코드는 주기적으로 변경돼 안전을 보장해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #23. Apple Pay 개선\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_22.png)\n\n설정 ⚙️ `개인 정보 및 보안 ✋` 분석 및 개선 항목에 새로운 분석 옵션이 있습니다. 기본적으로 비활성화되어 있습니다.\n\n활성화하면, Apple이 Apple Pay 및 연결된 계정에서 귀하의 거래 정보를 익명으로 저장할 수 있어 Apple Pay를 개선할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 제가 항상 말씀드리듯이, 분석기를 꺼두면 배터리를 절약할 수 있어요.\n\n# • 새로운 CarPlay 변경 내용 공개\n\n애플이 WWDC22에서 차세대 CarPlay를 미리 보여주었고, 우리에게 2023년 말에 도입될 것이라고 말했어요. 그런데 안타깝게도, 이미 2023년은 지나갔죠!\n\n그래서 애플은 CarPlay 웹페이지를 업데이트하여 \"첫 번째 모델이 2024년에 도착할 것\"이라고 말했어요. 그리고 𝕏의 Aaron (@aaronp613)는 iOS 17.4의 코드에서 새로운 아이콘과 애니메이션을 발견했답니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #24. 차량을 끌 때 CarPlay이 작별 인사를 합니다\n\n차량을 끌 때, iPhone과 Mac이 부팅될 때 처럼 유사한 작별 애니메이션이 표시될 수 있습니다.\n\n![image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_23.png)\n\n## #25. 새로운 CarPlay 앱 및 아이콘\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAaron은 CarPlay 2.0에서 새 아이콘도 발견했어요. 𝕏에서의 그의 전체 쓰레드를 확인해보세요:\n\n그리고 MacRumors가 강조한 대로, 차세대 CarPlay에 추가될 새 앱이 8개가 있어요:\n\n- Auto Settings: 페어링된 아이폰을 관리하고 차량 설정을 변경할 수 있어요.\n- Car Camera: 차량 뒷면 카메라의 영상을 표시해줘요.\n- Charge (전기차 전용): 배터리 레벨, 충전 상태, 완전히 충전될 때까지 남은 시간 등을 표시해줘요.\n- Climate: 차량의 기후 제어 기능을 제어할 수 있어요 — AC 온도 조절, 팬 속도 조절, 시트 및 핸들 열선 등.\n- Closures: 문이 실수로 열린 상태 인지하고 차량의 경고 심볼을 표시해줘요.\n- Media: FM 및 AM 라디오를 재생할 수 있고, SiriusXM도 재생할 수 있어요. 하지만 SiriusXM은 위성을 통해 제공될지 아니면 인터넷 제한이 될지 확실하지 않아요.\n- Tyre Pressure: 각 타이어의 공기 압력을 표시하고 높은 또는 낮은 압력 및 평평한 타이어를 알립니다.\n- Trips: 여행 중 평균 속도, 연료 또는 에너지 효율성, 경과 시간 및 이동 거리 등의 정보를 제공합니다.\n\n많은 인기 있는 자동차 제조사들이\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nAcura, Aston Martin, Audi, Ford, Honda, Infiniti, Jaguar, Land Rover, Lincoln, Mercedes-Benz, Nissan, Polestar, Porsche, Renault, and Volvo\n```\n\n자동차에 CarPlay 2.0을 도입하기로 이미 약속한 것을 알고 있습니다.\n\n# • 새로운 백엔드 변경 사항\n\n## #26. 게임 스트리밍이 이제 가능합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플은 최근 개발자 기사에서 게임 스트리밍에 대해 이야기했습니다. 다음과 같이 나와 있어요:\n\n```js\n게임 스트리밍이란 무엇인가요?\n클라우드 서버에서 게임을 실행하고 게임의 비디오와 사운드를 사용자 디바이스로 직접 스트리밍하는 온라인 게임의 한 종류입니다.\n이를 통해 사용자들은 강력한 네트워크 연결만 있으면 저전력 장치에서도 고사양 게임을 쉽게 플레이할 수 있습니다.\n```\n\n지금까지 iOS에서의 게임 스트리밍은 웹앱을 통해 브라우저로만 이용할 수 있었는데, 이는 게임을 경험하기에 편하지도 몰입할 수 없는 방식이었습니다.\n\n하지만 이 동작은 Xbox Cloud Gaming과 Nvidia GeForce NOW와 같은 서비스가 스탠드얼론 앱으로 앱 스토어에 진입하게 해주며, 게임에 능숙한 사용자들에겐 큰 소식입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #27. 케이블용 펌웨어 업데이트!?\n\nAaron의 보도에 따르면, iOS 17.4 코드에 Apple이 다음을 위한 펌웨어 업데이트 지원을 추가한다는 내용이 포함되어 있습니다:\n\n- USB-C 커넥터가 장착된 EarPods\n- USB-C to 3.5 mm 헤드폰 잭 어댑터\n\n이것은 놀라운 소식인데요, 제가 예상했던 것보다 Apple이 심지어 구식 와이어에도 펌웨어 업데이트를 제공할 수 있다니요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n음향 품질 및 케이블의 데이터 전송에 대한 개선 사항을 각 업데이트마다 발견할 수 있을 것 같아요.\n\n## #28. 타사 브라우저용 패스키 액세스\n\n설정 ⚙️ ` 개인 정보 및 보안 ✋` 에 새로운 섹션인 웹 브라우저용 패스키 액세스가 있어요.\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_24.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에 애플은 당신이 저장한 패스키를 볼 수 있는 권한을 요청한 애플리케이션을 나열합니다. 여기에서 그들의 액세스를 손쉽게 켜거나 끌 수 있습니다.\n\n패스키가 무엇인지, 그리고 어떻게 작동하는지 알고 싶다면, 이 항목을 읽어보세요:\n\n# • 새로운 기타 변경사항\n\n## #29. 앱 스토어의 구매 내역\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱 스토어는 이제 '구매 기록'이라는 새 섹션에서 모든 구매 내역을 전체적으로 보여줄 수 있습니다.\n\n보시려면 앱 스토어를 열고 프로필을 클릭하여 '구매 기록'을 선택하십시오.\n\n![Purchase History](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_25.png)\n\n지불한 앱 및 게임, 구독, 인앱 구매가 모두 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, '구매한 제품' 섹션이 이제 '앱'으로 이름이 바뀌었습니다. 위의 이미지를 확인해보세요. 그것은 첫 번째입니다.\n\n## #30. 에어드랍 2.0을 이용하여 노트 및 게임 공동 작업\n\n애플은 iOS 17의 출시 이후 NameDrop을 소개했습니다. 이를 통해 사용자들은 서로 전화기를 탭하여 연락처를 교환할 수 있습니다.\n\n파일을 공유하는 데도 효과적입니다.\n그러나 iOS 17.4부터 한 단계 발전합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이폰을 서로 가까이 대조하여 협업 노트를 작성하거나 지원되는 게임을 플레이할 수 있습니다(게임 센터 사용).\n\n## #31. 독일어로 Siri 호출 시 Hey 생략\n\n이전에 Siri를 깨우려면 \"Hey Siri\"라고 말해야 했습니다. 그러나 iOS 17부터 그냥 \"Siri\"라고 줄여서 말할 수 있는 옵션이 추가되었습니다.\n\n![이미지](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_26.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 아직 모든 언어와 호환되지는 않습니다. 그리고 iOS 17.4에서는 독일어가 호환되는 언어로 포함되었습니다.\n\n## #32. TV의 새롭게 디자인된 ‘시청 방법’ UI\n\nApple TV 앱의 거의 모든 영화나 TV 프로그램에는 \"시청 방법\"이라는 섹션이 아래에 표시됩니다. 이 섹션에는 미디어를 호스팅하는 모든 스트리밍 서비스(디즈니+, 애플 TV+, 넷플릭스 등)가 표시됩니다.\n\niOS 17.3 이전까지 이들은 나란히 배치되어 있어서 더 많은 것을 보려면 왼쪽으로 스와이프해야 했습니다. 그러나 이제 이들은 서로 위에 쌓이도록 되어 있어서 일목요연하게 모두를 볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_27.png)\n\n## iOS 17이 대박인게 아니에요?\n\n## iOS 17의 290가지 이상의 새로운 기능: 연속 업데이트 중:\n\n## 마침내,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면 (저와 같은), Setapp을 구독해 보세요. 매월 $9.99에 240개 이상의 놀라운 앱이 든 컬렉션에 액세스할 수 있습니다. 이것은 개별 구매 시 수백 달러가 필요한 것들입니다.\n\n- Setapp 여행을 시작하는 내 제휴 링크를 사용하세요! (30일간 무료)\n- Setapp에서 100개 이상의 최고의 macOS 앱 목록을 무료로 받아보세요.\n\n새로운 이야기를 게시할 때마다 알림을 받으려면 460명 이상의 사람 중 하나가 되세요!\n\n# 부록: 모든 새 이모지 목록\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_28.png)\n\n## Emojis of first two lines\n\n- 🙂‍↕️ — Head shaking vertically\n- 🙂‍↔️ — Head shaking horizontally\n- ⛓️‍💥 — Broken chain\n- 🍄‍🟫 — Brown mushroom\n- 🍋‍🟩 — Lime\n- 🐦‍🔥 — Phoenix\n\n## Emojis of third Line\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 🚶‍➡️ — 오른쪽을 향해 걷는 사람\n- 🏃‍➡️ — 오른쪽을 향해 뛰는 사람\n- 🧎‍➡️ — 오른쪽을 향해 무릎을 꿇은 사람\n- 🧑‍🦯‍➡️ — 오른쪽을 향해 하얀 보조 지팡이를 쓴 사람\n- 🧑‍🦽‍➡️ — 오른쪽을 향해 수동 휠체어를 탄 사람\n- 🧑‍🦼‍➡️ — 오른쪽을 향해 전동 휠체어를 탄 사람\n\n더 많은 비슷한 이모티콘들과 성별·피부색을 나타내는 이모지들이 있어요. 모두 Emojipedia에서 확인해보세요.\n\n## 가족 이모지\n\n\u003cimg src=\"/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_29.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 네 개 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 👨‍👨‍👦 — 두 아빠와 아들이 있는 가족\n- 👨‍👨‍👧 — 두 아빠와 딸이 있는 가족\n- 👨‍👩‍👦 — 엄마, 아빠, 아들이 있는 가족\n- 👨‍👩‍👧 — 엄마, 아빠, 딸이 있는 가족\n- 👪 — 두 부모, 아이가 있는 가족\n- 👩‍👩‍👦 — 두 엄마와 아들이 있는 가족\n- 👩‍👩‍👧 — 두 엄마와 딸이 있는 가족\n\n세 번째 이모지를 대체합니다:\n\n- 👩‍👦‍👦 — 엄마와 두 아들이 있는 가족\n- 👩‍👧‍👦 — 엄마, 딸, 아들이 있는 가족\n- 👩‍👧‍👧 — 엄마와 두 딸이 있는 가족\n- 👨‍👦‍👦 — 아빠와 두 아들이 있는 가족\n- 👨‍👧‍👦 — 아빠, 딸, 아들이 있는 가족\n- 👨‍👧‍👧 — 아빠와 두 딸이 있는 가족\n\n네 번째 이모지를 대체합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그 변경하기:\n\n| 이모지 | 설명                    |\n| ------ | ----------------------- |\n| 👨‍👦     | 아빠와 아들이 있는 가족 |\n| 👨‍👧     | 아빠와 딸이 있는 가족   |\n| 👩‍👦     | 엄마와 아들이 있는 가족 |\n| 👩‍👧     | 엄마와 딸이 있는 가족   |\n","ogImage":{"url":"/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_0.png"},"coverImage":"/assets/img/2024-05-18-iOS174Released25AmazingNewFeaturesYouNEEDToTryNow_0.png","tag":["Tech"],"readingTime":31},{"title":"스위프트 플레이그라운드에서 머신 러닝 모델을 사용하는 방법","description":"","date":"2024-05-18 17:20","slug":"2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds","content":"\n\u003cimg src=\"/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png\" /\u003e\n\n많은 사람들처럼, 올해의 Swift Student Challenge 아이디어를 개발하면서 내가 많은 시간을 쏟으면서 내 인내심을 시험받는 여러 가지 장애물을 만났어. 그래서, 몇 밤을 잠 못 이루게 한 문제에 대한 해결책을 공유하고 싶어: Swift Playgrounds에서 CoreML을 구현하는 방법.\n\n앱이 SSC에 참가하기 위한 요구 사항 중 하나는 Swift Playground여야 한다는 것을 아실 것입니다. 그러나 이러한 종류의 프로젝트는 장단점을 갖고 있어. Swift Playground는 Apple이 만든 대화형 개발 환경으로, 개발자와 프로그래밍 학습자들이 빠르고 쉽게 Swift 코드를 작성, 테스트, 시각화할 수 있게 해줘. Swift Playgrounds는 macOS용 Apple의 종합 개발 스위트인 Xcode와 iPad용 독립형 앱으로 모두 사용할 수 있어. 이 환경은 프로그래밍을 배우거나 Swift로 새로운 아이디어나 알고리즘을 실험하는 데 특히 유용해.\n\n반면에 Core ML (Core Machine Learning)은 Apple이 개발한 프레임워크로, iOS, macOS, watchOS 및 tvOS 앱에 머신 러닝 모델을 통합할 수 있게 해줘. Core ML을 사용하면 개발자들은 사전 훈련된 머신 러닝 모델을 활용하여 이미지 인식, 자연어 처리, 데이터 분석 등의 작업을 인터넷 연결 없이 효율적이고 실시간으로 수행할 수 있어.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 표준 Swift 프로젝트에서 Core ML을 사용하는 것은 매우 간단합니다. 우리 모델을 프로젝트에 추가하기만 하면 앱에서 사용할 수 있습니다. 그러나 이 글을 작성하는 시점에서 Swift Playground에서의 사용은 조금 복잡합니다. 후자의 형식에서는 앱에서 모델을 사용하려면 해당 모델이 앱에 의해 사용되도록 설정해야 하는 일련의 단계를 따라야 합니다. 이는 잘 문서화되어 있고 웹의 다양한 위치에서 찾을 수 있습니다. 그럼에도 불구하고, Xcode 15가 출시되면서 사용자들 사이에 널리 알려지지 않은 마지막 단계가 있습니다.\n\n## 첫 번째 단계: 파일 가져오기\n\nSwift Playgrounds 프로젝트에서 ML 모델을 사용하려면, 모델의 .mlmodel 파일을 추가할 임시 Swift 프로젝트를 먼저 준비해야 합니다. 이 프로젝트를 컴파일함으로써 두 가지를 달성할 수 있습니다: 해당 프로젝트의 클래스 파일과 컴파일된 모델 얻기. 이 두 가지는 Playground를 통해서는 불가능하기 때문에, 많은 사람들이 첫 시도에서 CoreML 모델을 성공적으로 구현하지 못한 것일 수 있습니다.\n\n첫 번째 단계에서는, 단순히 임시 앱을 빌드하고, Xcode 파일 탐색기에서 .mlmodel 파일을 클릭한 다음 Model Class 옆에 우리 CoreML 모델의 이름을 클릭하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![ML model class file](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_1.png)\n\nThis will take you to the class file of our CoreML model, which acts as the interface between the model and our app. It allows us to provide information and receive a processed response from it.\n\n![Show in Finder](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_2.png)\n\nWhile completing the remaining steps, we need to create a copy of this file and save it in another folder. Right-click on the file, choose \"Show in Finder,\" and create a duplicate.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![ML model in Swift Playgrounds](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_3.png)\n\n![ML model in Swift Playgrounds](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_4.png)\n\n다음 단계는 CoreML 모델의 컴파일된 버전을 획득하는 것입니다. 이를 위해 먼저 응용 프로그램의 컴파일된 파일, 빌드에 액세스해야 합니다. 이를 찾으려면 Finder를 열고 명령 ⌘ + Shift + G를 사용하세요. 그런 다음 다음 경로로 이동하세요:\n\n~/Library/Developer/Xcode/DerivedData\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 디렉터리 내에서 임시 앱 이름으로된 폴더를 찾아 들어가야 해요.\n\n![Folder 5](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_5.png)\n\n폴더 안으로 들어가서 Build/Products/Debug-iphonesimulator로 이동해주세요.\n\n![Folder 6](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![그림1](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_7.png)\n\n![그림2](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_8.png)\n\n여기서 우리는 임시 앱 이름으로 된 파일을 찾을 수 있습니다. 이 파일에 마우스 오른쪽 버튼을 클릭하고 \"Package Contents 표시\"를 선택합니다.\n\n![그림3](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_9.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 우리가 원하던 것을 찾을 수 있습니다: 컴파일된 ML 모델, .mlmodelc 파일(c는 컴파일된 형태를 의미합니다). 클래스 파일과 마찬가지로 이 파일의 사본을 만들어 쉽게 접근할 수 있는 위치에 저장하세요.\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_10.png)\n\n이 두 파일을 가지고 있다면, 모델을 변경하거나 업데이트할 일이 없는 한 임시 앱에 대해서 잊을 수 있습니다. 모델을 변경하려면 이전 단계를 반복해야 합니다. 이제 우리는 플레이그라운드 프로젝트로 넘어가 마지막 단계를 수행하겠습니다.\n\n## 두 번째 단계: 플레이그라운드 설정하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 프로젝트를 구하는 데 도움이 된 단계로 넘어갑시다. 모델을 사용하려면 플레이그라운드를 마무리하려면 몇 가지 최종 조정이 필요합니다. 먼저, 클래스 파일을 프로젝트 내에 배치하십시오. 추가로, ML 모델을 넣을 폴더를 만들고 다른 것은 아무것도 넣지 마십시오. 저는 편의상 MLFile이라는 이름을 붙였습니다.\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_11.png)\n\n이제 Xcode를 닫고 Finder에서 프로젝트 위치로 이동해야 합니다. 파일에서 마우스 오른쪽 버튼을 클릭하고 \"패키지 내용 보기\"를 선택하십시오.\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_12.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 Playgrounds 프로젝트의 내용을 보여줄 것입니다. 그 안에서 Package.swift 파일을 찾아 열어봅니다.\n\n![Package.swift 파일](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_13.png)\n\n이 파일 안에는 프로젝트 구성 정보가 있습니다.\n\n![프로젝트 구성](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ntargets 섹션 내에서 .executableTarget() 메서드로 이동하여 아래 내용을 매개변수로 추가해주세요:\n\n```js\nresources: [\n                .process(\"Resources\"),\n                .copy(\"\u003cModelFolderName\u003e/\u003cYourModelName\u003e.mlmodelc\")\n            ]\n```\n\n저의 프로젝트에서는 다음과 같이 나타날 겁니다:\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_15.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 이제 모두 준비되었습니다!\n\n좋아요! 이제 Swift Playground App 프로젝트 내에서 우리의 ML 모델을 사용할 수 있게 되었습니다. 이 변경이 필요한 이유는 Playground가 일반 프로젝트와 다르게 작동하기 때문입니다. 우리가 리소스를 사용할 때 Playground는 프로젝트의 구조를 무시하고, 만들어 둔 폴더 구조를 존중하는 대신에 포함된 파일을 추출하여 모두 한데 모읍니다. 이는 동일한 이름의 파일이 다른 폴더에 있더라도 컴파일 중 충돌을 일으킬 수 있다는 것을 의미합니다. 이는 우리의 Swift Package 내 .process() 메서드의 덕분입니다. .copy()를 구현함으로써, 우리가 지정한 폴더나 파일에 대해 폴더 구조가 존중되도록 보장합니다.\n\n이제 우리 프로젝트가 요구하는 CoreML 구현을 계속하면 됩니다. 이 해결책이 여러분께 몇 시간의 불면의 밤을 덜어주고 프로젝트를 더 나은 수준으로 이끌 수 있기를 바랍니다. 행운을 빕니다!\n\n도움이 필요하거나 중간에 질문이 생기면 언제든지 연락해 주세요!\n","ogImage":{"url":"/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png"},"coverImage":"/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png","tag":["Tech"],"readingTime":8},{"title":"네이티브 iOS 느낌을 Compose Multiplatform 앱에서 가져오기","description":"","date":"2024-05-18 17:18","slug":"2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp","content":"\nCompose의 기본 모양과 느낌은 Material Design입니다. Compose Multiplatform에서는 일부 요소를 iOS에서 더 네이티브하게 느끼도록 조정했습니다. 예를 들어, 버전 1.5부터 iOS의 스크롤 효과를 해당 플랫폼의 것과 유사하도록 만들었습니다. 그러나 대부분의 UI 요소는 여전히 Material처럼 보입니다. 앱에서 iOS 네이티브 룩 앤 필을 더 얻는 쉬운 방법을 살펴보겠습니다.\n\n![image](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png)\n\n우리는 Compose Cupertino라는 라이브러리를 사용할 것입니다. 이 라이브러리는 여러 가지 버전으로 제공됩니다:\n\n- cupertino: Compose를 사용하여 iOS와 유사한 위젯을 구축했습니다;\n- cupertino-native: 네이티브 UIKit 구성 요소 주변의 래퍼;\n- cupertino-adaptive: 안드로이드에서 Material Design을 사용하는 적응형 테마/래퍼 및 iOS의 cupertino와 cupertino-native의 일부 위젯을 사용합니다 (이 글의 주된 내용);\n- cupertino-icons-extended: 가장 많이 사용되는 Apple SF Symbols 800개 이상(참고: 이들은 저작권이 있으며 라이센스 계약을 준수해야 합니다);\n- cupertino-decompose: 화면 전환 및 스와이프 동작의 네이티브 느낌.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글에서는 얼마나 쉽게 Adaptive 플레이버를 사용하여 앱의 시스템 바(상단바 + 내비게이션/탭바) 및 주요 구성 요소(버튼 + 로딩 인디케이터 + 대화상자)를 개선할 수 있는지 살펴볼 것입니다. 라이브러리에는 더 많은 기능이 있으므로 이 글은 그에 대한 소개이고 완벽한 안내서는 아닙니다. 또한 Android에서 iOS 모습을 테스트하는 방법도 알아볼 것입니다!\n\n# 작동 원리는 무엇인가요?\n\nCupertino의 네이티브 룩을 가진 위젯은 Compose를 사용하여 완전히 재구성된 iOS 구성 요소입니다. 이것은 실제 네이티브 컴포넌트가 아니라 그 모습을 그대로 보이도록 그려진 것이라는 것을 의미합니다. 그 점에 대해 우리는 걱정할 필요가 있을까요? 나는 그렇지 않다고 생각합니다. 왜냐하면 이것은 Compose 자체가 안드로이드 컴포넌트를 재구성하는 방식과 비슷하기 때문입니다. 이들은 레거시 android.view 컴포넌트에 의존하는 대신 캔버스에 그려집니다.\n\nCupertino Adaptive는 Material 컴포넌트뿐만 아니라 그들의 API를 염두에 두고 만들어졌습니다. 즉, 현재 사용 중인 많은 Material 컴포넌트를 Adaptive 대체품으로 사용 가능합니다. 단 몇 초 내에 교체할 수 있습니다. Android에서는 여전히 동일한 기본 코드를 호출하지만, iOS에서는 네이티브 컴포넌트처럼 보이게 그려집니다. 예외는 AdaptiveAlertDialogNative와 같이 \\*Native로 끝나는 적응형 위젯입니다. 그것은 대화 상자를 위한 실제 UIKit 컴포넌트를 호출하는 Cupertino Native 래퍼를 호출합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함께 해보겠습니다! 모든 코드는 https://github.com/jacobras/ComposeCupertinoSample 에서 확인할 수 있습니다.\n\n# 튜토리얼: Material을 Cupertino으로 적응하게 만들기\n\n이번에 사용할 샘플 프로젝트는 Kotlin Multiplatform Wizard로 생성되었습니다. 툴바, 두 개의 탭, 로딩 표시기, 그리고 대화상자를 포함한 Material3 구성 요소가 구현되어 있습니다. 시작 지점 코드베이스는 여기에서 확인할 수 있습니다: ComposeCupertinoSample/tree/starting-point.\n\n## 1: 의존성 추가하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 버전 카탈로그에 의존성을 추가하고 앱에서 구현했어요:\n\n```js\n// gradle/libs.versions.toml 파일:\ncupertino = { module = \"io.github.alexzhirkevich:cupertino-adaptive\", version = \"0.1.0-alpha03\" }\n\n// composeApp/build.gradle.kts 파일의 common.dependencies 안에:\nimplementation(libs.cupertino)\n```\n\n전체 커밋 내역: ComposeCupertinoSample/pull/2/commits/d7b05ad809bc03cf87c3c58a6f7765f5c6442b92\n\n## 2: 테마 업데이트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAppTheme은 현재 MaterialTheme을 사용합니다. 이것을 adaptive theme을 사용하도록 변경해야 합니다. material과 cupertino라는 두 가지 중요한 매개변수가 있습니다. material은 현재 MaterialTheme을 취하고, cupertino은 CupertinoTheme을 취합니다. 후자는 darkColorScheme() 또는 lightColorScheme()에 사용자 정의 색상을 전달하여 iOS 외관을 사용자 정의할 수 있습니다.\n\n```js\n// 변경 전\n@Composable\nfun AppTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -\u003e Unit\n) {\n    MaterialTheme(\n        colorScheme = if (useDarkTheme) {\n            darkColorScheme()\n        } else {\n          lightColorScheme()\n        },\n        content = content\n    )\n}\n\n// 변경 후\n@OptIn(ExperimentalAdaptiveApi::class)\n@Composable\nfun AppTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    theme: Theme = determineTheme(),\n    content: @Composable () -\u003e Unit\n) {\n    AdaptiveTheme(\n        material = {\n            MaterialTheme(\n                colorScheme = if (useDarkTheme) {\n                    androidx.compose.material3.darkColorScheme()\n                } else {\n                    androidx.compose.material3.lightColorScheme()\n                },\n                content = it\n            )\n        },\n        cupertino = {\n            CupertinoTheme(\n                colorScheme = if (useDarkTheme) {\n                    darkColorScheme()\n                } else {\n                    lightColorScheme()\n                },\n                content = it\n            )\n\n        },\n        target = theme,\n        content = content\n    )\n}\n```\n\ndetermineTheme() 메서드는 [androidMain]에서 Theme.Material을 반환하고 [iosMain]에서 Theme.Cupertino를 반환하는 expect/actual 함수입니다. 자세한 내용은 전체 커밋을 참조하세요: ComposeCupertinoSample/pull/2/commits/592b3e2a1d35ff8a9961dbc6739e0e25bf581b95\n\n지금 앱을 실행하면 아직 아무것도 변경되지 않습니다. 모든 것이 이전과 똑같이 보입니다. 왜냐하면 아직 적응형 컴포넌트를 사용하지 않았기 때문입니다. 이는 안드로이드에서는 모든 것이 변하지 않음을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3: 적응형 구성요소 사용하기\n\n이제 재미있는 부분이 시작됩니다! 이것은 또한 가장 쉬운 변경입니다. 모든 자료 구성요소를 찾아서 적응형 래퍼로 대체합니다. 예를 들어요:\n\n```js\n// Before\nButton(onClick = { showContent = !showContent }) {\n    Text(\"Click me!\")\n}\n\n// After\nAdaptiveButton(onClick = { showContent = !showContent }) {\n    Text(\"Click me!\")\n}\n```\n\n다른 구성요소들도 이와 같이 변경할 예정입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_1.png)\n\n패턴은 명확해야 합니다: iOS 스타일 컴포넌트에는 Cupertino[ComponentName]을 사용하고, 플랫폼에 따라 변경되는 컴포넌트에는 Adaptive[ComponentName]을 사용해야 합니다. 이 튜토리얼에서는 모두 Adaptive 컴포넌트만 사용할 것입니다.\n\n대부분은 매개변수를 변경하지 않고 이름만 변경하면 됩니다. AlertDialog은 text를 title로, confirmButton을 buttons로 변경해야 하는 예외입니다.\n\n전체 커밋: ComposeCupertinoSample/pull/2/commits/a8da43dd7db1187df15c0fbbca9af3ef705c64bd\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱을 iOS에서 다시 실행하면 변경 사항 이전을 보여주는 좌측 시뮬레이터와 변경 후를 보여주는 우측 시뮬레이터가 표시됩니다:\n\n![이미지1](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_2.png)\n\n정말 멋지게 보이네요! 다크 테마도 두 플랫폼에서 작동합니다:\n\n![이미지2](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 안드로이드에서의 테스트\n\n안드로이드에서 쿠퍼티노 스타일을 테스트하려면 Android 소스 세트의 determineTheme() 메서드만 변경하면 됩니다:\n\n```js\nactual fun determineTheme(): Theme = Theme.Material3\n```\n\n# 추가 단계 및 독서\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 이렇게 쉽고 영향력이 큰 작업이었는지 알겠죠. 더 할 수 있는 일이 있습니다. 아이폰/아이패드에서 iOS 아이콘을 사용하거나 더 많은 네이티브 모양의 구성 요소를 사용하는 것 등이 가능하지만, 결정은 여러분에게 달려 있습니다. 제가 제공한 것은 라이브러리를 시작하는 짧은 소개였죠.\n\n- GitHub: Compose Cupertino\n- GitHub: Compose Cupertino 샘플 앱\n","ogImage":{"url":"/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png"},"coverImage":"/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png","tag":["Tech"],"readingTime":9},{"title":"Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요","description":"","date":"2024-05-18 17:16","slug":"2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD","content":"\n![이미지](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png)\n\n내가 글을 쓸 때마다, 어떤 순간에라도, Apple의 생태계란 구문이 끼어들게 돼요.\n\n진짜 그 유혹에 맞섰다가도 다른 표현 방법이 떠오르지 않아요.\n\nApple은 우리 주변에 조용하게 그리고 매끄럽게 이 벽이 있는 정원을 쌓아 올렸어요. 우리가 알아채지 못하게. 틀림없이, 이것은 우리가 계속해서 Apple의 최신 제품을 사도록 매료하게 만드는 일부분이에요. 전반적으로, 이는 아주 효과적으로 작동해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 것조차 iPhone에서 iPhone으로 전환하는 것은 훨씬 쉬워요. 하나를 다른 쪽에 가져가면 거의 끝나요. iCloud는 마치 대가감 있게 모든 것을 감독하고 우리의 Apple 생활을 유지하는 데 필요합니다.\n\nApple 생활에 대해 칭찬하고 사랑할 만한 것이 많이 있어요. 예를 들어, 최근에 시작한 Photos 앱은 얼마나 강력한지 깨닫고 있는 앱이에요. 그것은 보석 같아요.\n\n그래, 우리 사진과 문서가 동기화되고 어디에서나 사용 가능하다는 것에 새로운 점은 없어요. 우리는 그것을 기대하죠. 그러나 Apple 생태계의 미세한 뉘앙스가 더 흥미로운 거예요. 여러 Apple 기기를 소유하는 것이 얼마나 매끄럽게 통합될 수 있는지를 만드는 요소들이에요.\n\n# Apple 생활\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n핸드오프는 가끔 언급하는 주제야 — 진짜 좋아해.\n\n아침 러닝 후에 집에 들어오면 핸드폰을 홈팟 중 하나에 건네면 방금 듣고 있던 앨범이나 팟캐스트가 계속 재생돼! 천재적이지!\n\n![이미지](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_1.png)\n\n유니버설 컨트롤은 여러 대의 맥에서 마우스를 공유하는 것이 정말 편리해. 지금 이 글을 쓰고 있는데 Studio Display 앞에는 16인치 맥북 프로 한 대와 한쪽에는 M2 맥북 에어가 있어 — 하지만 하나의 키보드, 하나의 마우스, 하나의 트랙패드로 모든 것을 제어할 수 있어. 진짜 멋져.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 나의 블루투스가 하루에 여러 번 무작위로 끊기고 있어서 M1 MacBook Pro에서 유니버설 컨트롤도 끊기는 현상이 발생하고 있어. 스튜디오 환경은 그대로인데 뭔가 이상한 점을 눈치 채신 분들 있을까 궁금해. 나는 Sonoma 14.3.1을 사용 중이야.\n\n하지만 그런 이상한 문제들은 제치고, 애플 제품을 사용하면 정말 대단한 기능을 체험할 수 있어. 매일 모든 것이 완벽하게 작동하는 게 정말 대단한 거지만, 예외가 발생하면 그때는...!\n\n애플 제품들과 함께하는 게 멋지긴 한데 가끔은 골치 아픈 순간들이 있어. 그럴 때는 짜증 나는 건 말할 것도 없고, 오늘은 나만의 일상적인 짜증거리들을 소개하고 싶어. 이 중에서 가장 먼저 소개할 건...\n\n# 시리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n음 - 아마 거기까지 둘 수도 있겠어요. 우리 모두가 Siri를 사용하는 데 어려움을 겪는 것을 알고 있지만, 적어도 언급하지 않고는 명백한 양심으로 이 이야기를 쓸 수 없을 것 같아요!\n\n저는 오직 Siri만 사용해왔고, 작년에 Pixel 8 Pro를 사용하면서 구글의 음성 어시스턴트 대안을 잠시 체험해 봤었는데, 그 차이에 놀랐습니다.\n\n이론적으로, 깨어나는 명령어가 단순한 Siri로 줄어들었지만, 저에게는 때로는 그렇게 작동하지 않아요. 가장 불안정한 반응은 차 안에서 Apple CarPlay을 사용할 때입니다.\n\n![이미지](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n차 안은 음성 어시스턴트가 아주 유용한 곳이지만 내 경험상 Siri는 차 안에서 최악입니다. 많은 경우에 응답을 받지 못하고 거의 어느 때나 일어나는 명령어를 인식하지 못합니다. 대신 예전의 \"Hey Siri\" 명령어를 사용해야 하고 심지어 CarPlay도 그 명령어를 잡지 못할 때가 있습니다. 대신 전화가 깨어나버립니다!\n\nSiri가 작동할 때 대답이나 응답이 대부분 이상하거나 이상합니다. 그 \"세부 정보를 전화로 보낼 수 있어요\" 멘트를 한 번 더 들으면 진짜 화가 나서 홈팟을 거실 창문으로 던질지도 모릅니다!\n\n솔직히 Siri는 엉망입니다! 우리는 올해 WWDC에서 Apple이 AI에 대한 견해를 공개하면서 Siri를 크게 개선할 것이라는 강력한 소문을 듣고 있습니다. 이번에는 제대로 처리하길 바랍니다.\n\n현재의 Siri는 다소 농담처럼 보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 지속성 카메라\n\n일단 이것에 대해 명확히 하고 싶은 것이 있어요 — 지속성 카메라 자체로는 정말 멋져요.\n\n아직 사용해보지 않았다면 꼭 사용해보세요! 당신이 가지고 있는 최고의 웹캠은 아마도 당신의 주머니 속에 있는 아이폰 카메라일 거에요 — 그리고 지속성 카메라를 사용하면 이를 맥북이나 아이맥에 연결해서 영상 통화에 아이폰 카메라를 사용할 수 있답니다.\n\n최신 tvOS로 업데이트했다면, 심지어 TV에서 FaceTime 통화에도 사용할 수 있어요 — HD로 자신을 55인치 패널에서 볼 수 있는 용기가 충분하다면 말이에요! 하지만 완벽하게 무선으로 작동하기 때문에 이용이 편리해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_3.png)\n\n그 모든 칭찬을 해도 오늘의 나쁜 목록에 올라간 이유가 무엇인가요?\n\n이것은 좀 사용자별이라고 인정하고 시작하겠습니다. 그러나 매번 Premiere Pro를 열 때마다 iPhone이 사진 입력으로 연결하려고 해서 짜즯네요! 너무 작은 일이라는 걸 알지만, 그저 Premiere를 영원히 잊으라고 말할 방법이 있었으면 좋겠어요. 그냥 프로젝트를 계속하고 싶은데 전화기를 계속 연결을 끊을 필요가 없어야 하는데요 — 어이쿠!\n\n그리고 유사한 일로...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 자동 전환\n\n다시 말해요 - 멋진 개념이지만 이것과 함께 살아가는 것은 꽤 골치 아파요.\n\n아마 여러 대의 맥을 가지고 계시다면 망상할 것 같아요. 만약 여러 대의 맥을 사용하는 AirPods 사용자라면, 한 대의 맥에서 작업을 하면서 무언가를 듣다가 다른 맥으로 전환하면, AirPods가 엄청 괴로워져요. 갑자기 다른 맥으로 따라오려고 하는 것 같아요 - 이상한 일은, 다른 맥에서 아무것도 재생되고 있지 않은 상태에서도 발생해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자동 전환은 이론적으로 유용한 기능 중 하나입니다... 어딘가 연구실에서는 그게 세상에서 가장 이치에 맞는 것처럼 보일지도 몰라요. 하지만 현실에서는 조금 다른 일이 일어날 수 있죠.\n\n# 무엇을 두고 왔나요?\n\n다시 한 번, 이런 일은 여러분에게도 일어날 것입니다.\n\n집에 돌아오는 길에 가게에 잠깐 들러 저녁을 사러 가면서 맥북이나 에어팟 맥스를 차 안에 두고 나온 적이 있을 거예요. 그럴 때마다 Apple Watch로 '무언가를 두고 나왔다'는 알림이 오면 마치 무언가를 훔쳐갔다고 생각되어 놀랍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네, Find My 앱에서 알림을 끌 수 있는 건 알고 있어요—하지만 항상 할 생각은 하지만 항상 잊게 돼요.\n\n알림이 너무 많다면—어떻게 생각하세요?\n\n# 침묵의 암살자\n\n그래서—요즘 대부분의 사람들처럼 전화 소리를 끈 상태로 핸드폰을 사용해요. 전화를 많이 받지 않고, 묵상적으로 소리가 없는 상태가 더 평온하다고 느껴지거든요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내가 전화를 받는 방법은 일반적으로 책상 앞에 놓인 전화로 전화를 보거나 Apple Watch의 진동 팔찌로 전화를 받는 것을 의지합니다.\n\n![Image](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_5.png)\n\n하지만 여기가 문제예요. 오늘 언급한 이 분규 중 많은 것들과 마찬가지로 이 기능은 때때로만 작동합니다. 그 이유나 근거가 없어 보이죠. 작동할 때는 최고의 방법 중 하나로 호출 알림을 받지만, 내가 이것에 의존할 수 없어요.\n\n또한 시계로 Mac 잠금 해제도 좀 이상해요. 웃기는 건 Mac이 가장 잘 작동하는 것은 제 오래된 2015년형 27인치 iMac이에요. Apple Watch가 작동해야 하는데 새로운 지문 인식 Magic Keyboard를 사는 걸 피하려고 했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단한 문제 해결 방법\n(paren은 괄호)\n\n1. 처음에 내가 지정한 form_tools라는 class를 넣었는데, HTML 태그와 같이 들어가서 CSS가 적용되지 않아서 문의했습니다. 아마도 TagUISetting쪽에도 포함시켜서 설정을 보완하는 것이 최선인 것 같습니다.\n2. 두 번째 문제는 TagAcceptCallback 함수를 정의하지 않았다는 것입니다. 그래서 문제 해결을 위해 함수를 추가했습니다. 이제 기능이 잘 작동합니다.\n3. 세 번째 문제는 항상 합의 가을로 떨어진다는 것입니다. 그래서 로직을 수정하여 기온이 5도 이상인지 아닌지에 따라 계절을 변화시키도록 했습니다. 그렇게 하니까 잘 작동했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n200개 이상의 생산성 앱을 한 곳에서 쉽게 확인하고 싶나요? 그렇다면 SetApp을 확인해보세요. 정말 멋진데요 — 매월 한 번의 요금으로 Bartender, CleanShot X, Paste, iStat Menus, 그리고 BetterTouchTool과 같은 훌륭한 앱 중에서 선택할 수 있습니다. 한 번 시도해보고 30일 무료 이용해 보고 싶다면 제 제휴 링크를 클릭하고 확인해보세요. 어떤 앱이 가장 마음에 들었는지 저에게 알려주세요.\n\n원문은 2024년 3월 8일에 https://talkingtechandaudio.com에서 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png"},"coverImage":"/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png","tag":["Tech"],"readingTime":9},{"title":"Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드","description":"","date":"2024-05-18 17:13","slug":"2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced","content":"\n아래는 Markdown 형식으로 변환되었습니다.\n\n![이미지](/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png)\n\n# 안드로이드에서의 네비게이션은 무엇인가요?\n\n네비게이션은 애플리케이션의 다른 구성 요소 간에 이동하는 방법을 이해하는 데 도움이 됩니다.\n\nAndroid JetPack 네비게이션은 고수준의 네비게이션을 간편하게 구현하는 데 도움을 줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네비게이션 컴포넌트는 세 가지 주요 부분으로 구성되어 있어요:\n\n- 네비게이션 그래프: 이는 모든 네비게이션 관련 데이터를 한 곳에 모아 둔 리소스입니다. 이에는 앱 내의 모든 위치인 목적지들과 사용자가 앱을 통해 이동할 수 있는 가능한 경로들이 포함됩니다. 앱에서 갈 수 있는 모든 장소와 그 있는 방법을 담은 큰 책처럼 생각하시면 좋아요. 이것은 지도와 안내서가 결합된 것으로 이해할 수 있어요.\n- NavHost: 이는 레이아웃에 포함할 수 있는 독특한 컴포저블(composable)입니다. 네비게이션 그래프에서 다양한 목적지를 표시해줘요. NavHost는 NavController를 네비게이션 그래프에 연결하여 네비게이션 사이를 이동할 수 있는 컴포저블 목적지를 지정하는 링크 역할을 합니다. 컴포저블 간을 이동하는 동안 NavHost의 내용은 자동으로 recompose됩니다. 네비게이션 그래프의 각 컴포저블 목적지는 경로에 연결돼 있어요.\n- NavController: NavController는 네비게이션 컴포넌트의 중심 API입니다. 이는 상태를 가지고 있으며, 앱의 화면을 구성하는 컴포저블들의 백 스택과 각 화면의 상태를 추적합니다.\n\n# Jetpack Compose에서의 네비게이션\n\n네비게이션 컴포넌트는 Jetpack Compose 애플리케이션을 지원해줍니다. 네비게이션 컴포넌트의 인프라와 기능을 활용하면서 컴포저블들 간을 이동할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJetpack Compose에서 탐색을 시작하려면 프로젝트의 build.gradle 파일에 필수 종속성을 포함해야 합니다:\n\n```js\nimplementation \"androidx.navigation:navigation-compose:2.7.1\"\n```\n\nJetpack Compose에서 탐색에 대한 기본 개념.\n\n## NavController:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNavController은 네비게이션 컴포넌트의 중심 API입니다. 상태를 유지하며, 앱의 화면을 구성하는 컴포저블의 백 스택 및 각 화면의 상태를 추적합니다.\n\n이러한 NavController는 다음과 같이 rememberNavController() 메서드를 사용하여 만들 수 있습니다:\n\n```js\nval navController = rememberNavController()\n```\n\nNavController를 만들 때는 모든 컴포저블이 해당 NavController에 액세스할 수 있는 컴포저블 계층구조의 적절한 위치에서 만들어야 합니다. 이는 상태 끌어올리기(state hoisting)의 원리를 따르며, 현재 currentBackStackEntryAsState()를 통해 제공되는 NavController 및 상태를 통해 화면 외부의 컴포저블을 업데이트하는 데 참고할 수 있도록 합니다. 이러한 기능의 예시는 바텀 네비게이션바와의 통합을 참고하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## NavHost:\n\n각 NavController는 단일 NavHost composable과 연결되어야 합니다. NavHost는 NavController를 네비게이션 그래프와 연결하여 이동할 수 있는 composable 목적지를 지정합니다. composable 사이를 이동하면 NavHost의 내용이 자동으로 recomposed됩니다. 네비게이션 그래프의 각 composable 목적지는 route와 연결됩니다.\n\nNavHost를 생성하려면 이전에 rememberNavController()를 통해 생성한 NavController와 그래프의 시작 목적지인 route가 필요합니다. NavHost 생성은 네비게이션 Kotlin DSL에서 lambda 구문을 사용하여 네비게이션 그래프를 구성합니다. composable() 메서드를 사용하여 네비게이션 구조를 추가할 수 있습니다. 이 메서드는 route 및 목적지에 연결할 composable를 제공해야 합니다:\n\n```js\nNavHost(navController = navController, startDestination = \"profile\") {\n    composable(\"profile\") { Profile(/*...*/) }\n    composable(\"friendslist\") { FriendsList(/*...*/) }\n    /*...*/\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시: 네비게이션 그래프, 네브호스트 및 네비게이션 아이템 설정하는 방법\n\n단계 1: 네비게이션을 위한 화면 이름 및 라우트를 하나의 파일에 정의합니다. 예시. AppNavigation.kt\n\n```kotlin\nenum class Screen {\n    HOME,\n    LOGIN,\n}\nsealed class NavigationItem(val route: String) {\n    object Home : NavigationItem(Screen.HOME.name)\n    object Login : NavigationItem(Screen.LOGIN.name)\n}\n```\n\n단계 2: NavHost 및 화면을 정의합니다. 예시. AppNavHost.kt\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun AppNavHost(\n    modifier: Modifier = Modifier,\n    navController: NavHostController,\n    startDestination: String = NavigationItem.Splash.route,\n    ... // 다른 매개변수\n) {\n    NavHost(\n        modifier = modifier,\n        navController = navController,\n        startDestination = startDestination\n    ) {\n        composable(NavigationItem.Splash.route) {\n            SplashScreen(navController)\n        }\n        composable(NavigationItem.Login.route) {\n            LoginScreen(navController)\n        }\n    }\n}\n```\n\n단계 3: MainActivity.kt 파일에서 AppNavHost를 호출합니다.\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            AutoPartsAppTheme {\n               Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    AppNavHost(navController = rememberNavController())\n                }\n            }\n        }\n    }\n}\n```\n\n## 네비게이션 인자:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네비게이션 Compose는 코틀린을 사용하여 콤포저블 목적지 간에 인수를 전달하는 것을 지원합니다. 이를 위해 기본 네비게이션 라이브러리를 사용할 때 딥 링크에 인수를 추가하는 방식과 유사한 방식으로 라우트에 인수 자리 표시자를 추가해야 합니다.\n\n## 사용 사례:\n\n- 인수가 없을 때\n- Int, String 등 미리 정의된 데이터 유형과 같은 간단한 인수를 사용할 때\n\n3. 사용자가 정의한 데이터 유형 같은 복잡한 인수를 사용할 때\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 선택적 매개변수\n\n5. 결과값으로 되돌아가기\n\n## 매개변수 없이:\n\n```js\nNavHost(navController = navController, startDestination = \"profile\") {\n    composable(\"profile\") { Profile(/*...*/) }\n    composable(\"friendslist\") { FriendsList(/*...*/) }\n    /*...*/\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 간단한 인수로:\n\n기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다:\n\n```js\nNavHost(startDestination = \"profile/{userId}\") {\n    ...\n    composable(\"profile/{userId}\") {...}\n}\n```\n\n기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nNavHost(startDestination = \"profile/{userId}\") {\n    ...\n    composable(\n        \"profile/{userId}\",\n        arguments = listOf(navArgument(\"userId\"){\n           type = NavType.StringType\n        })\n    ) {...}\n}\n```\n\n`composable(\"profile/{userId}\") { backStackEntry -\u003e\n   val userId = backStackEntry.arguments?.getString(\"userId\")\n   // 여기서 사용자 데이터를 가져와야 합니다\n   Profile(\n      navController, \n      // 사용자 데이터를 가져와서 전달하세요. 예: UserInfo\n   )\n}\n`\n\n대상으로 전달하려면 navigate 호출 시 경로에 추가해야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nnavController.navigate(\"profile/user1234\");\n```\n\n지원되는 유형 목록을 보려면 전달 방법을 참조하세요.\n\n## 복잡하거나 사용자 정의 인수로:\n\n이동할 때 복잡한 데이터 객체를 전달하는 것은 권장되지 않지만 대신 고유 식별자 또는 기타 형식의 ID와 같이 최소한의 정보를 인수로 전달해야합니다. 이를 통해 이동 작업 수행 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 새로운 대상으로 이동할 때 사용자 ID만 전달하실 때\nnavController.navigate(\"profile/user1234\");\n```\n\n복잡한 객체는 데이터 레이어와 같은 단일 진실의 원천으로 저장해야 합니다. 이동 후 목적지에 도착하면 전달된 ID를 사용하여 단일 진실의 원천에서 필요한 정보를로드할 수 있습니다. 데이터 레이어에 액세스하는 ViewModel에서 인수를 검색하려면 SavedStateHandle를 사용할 수 있습니다.\n\n```js\nclass UserViewModel(\n    savedStateHandle: SavedStateHandle,\n    private val userInfoRepository: UserInfoRepository\n) : ViewModel() {\n\n    private val userId: String = checkNotNull(savedStateHandle[\"userId\"])\n\n    // 전달된 userId 인수를 기반으로 데이터 레이어(예: userInfoRepository)에서 관련 사용자 정보 검색\n    private val userInfo: Flow\u003cUserInfo\u003e = userInfoRepository.getUserInfo(userId)\n\n   --------------- OR -----------------\n\n    // 네트워크 또는 데이터베이스에서 데이터 가져오기\n    private val _dataFlow =\n            MutableStateFlow\u003cUserInfo\u003e(userInfoRepository.getUserInfo(userId))\n    val dataFlow get() = _dataFlow.asStateFlow()\n}\n```\n\n적합한 기능\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n//Navhost\ncomposable(\"profile/{userId}\") { backStackEntry -\u003e\n   val userId = backStackEntry.arguments?.getString(\"userId\")\n   // 여기서 사용자 데이터를 가져와야 합니다\n   val userInfo by taskViewModel.dataFlow.collectAsState()\n   Profile(\n      navController,\n      userInfo\n   )\n}\n\n// 프로필 화면\n@Composable\nfun Profile(navController: NavController, userInfo: UserInfo){\n    // 여기서 작업을 수행합니다\n}\n```\n\n이 접근 방식은 구성 변경 중에 데이터 유실을 방지하고 해당 객체가 업데이트되거나 변경될 때 불일치를 방지합니다.\n\n복잡한 데이터를 인수로 전달하는 것을 피해야 하는 이유 및 지원되는 인수 유형 목록에 대한 보다 자세한 설명은 Best practice를 참조하세요.\n\n## 선택적 인수 추가하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNavigation Compose는 선택적 네비게이션 인수도 지원합니다. 선택적 인수는 필수 인수와 두 가지 방법으로 다릅니다:\n\n- 쿼리 매개변수 구문(\"?argName='argName'\")을 사용하여 포함되어야 합니다.\n- defaultValue가 설정되어 있어야 하거나 nullable = true이어야 합니다(이는 기본 값을 자동으로 null로 설정합니다).\n\n이는 모든 선택적 인수가 콤포저블() 함수에 명시적으로 추가되어야 한다는 것을 의미합니다:\n\n```js\ncomposable(\n    \"profile?userId={userId}/{isMember}\",\n    arguments = listOf(\n         navArgument(\"userId\") {\n            type = NavType.StringType\n            defaultValue = \"user1234\"\n           // 또는\n            type = NavType.StringType\n            nullable = true\n         },\n         navArgument(\"isNewTask\") {\n            type = NavType.BoolType\n         }\n     )\n) { backStackEntry -\u003e\n    val userId = backStackEntry.arguments?.getString(\"userId\")\n    val isMember = backStackEntry.arguments?.getBoolean(\"isMember\")?:false\n    Profile(navController, userId, isMember)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 대상에 인수가 전달되지 않더라도 defaultValue = \"user1234\"가 대신 사용됩니다.\n\n경로를 통해 인수를 처리하는 구조는 Composable이 Navigation과 완전히 독립되도록 하며 이로 인해 테스트하기 훨씬 더 용이해집니다.\n\n## 결과 값으로 되돌아가기\n\n결과 값을 사용하여 되돌아가는 것이 가장 일반적인 작업입니다. 즉, 필터 대화상자를 열고 필터를 선택한 다음 해당 필터를 적용하기 위해 선택된 필터와 함께 되돌아가는 경우입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 개의 화면이 있습니다. 1. 첫 번째 화면과 2. 두 번째 화면입니다. 우리는 두 번째 화면에서 첫 번째 화면으로 데이터를 필요로 합니다.\n\nNavHost.kt : 내비게이션 그래프 설정.\n\n```js\n val navController = rememberNavController()\n NavHost(\n     navController = navController,\n     startDestination = \"firstscreen\"\n ) {\n    composable(\"firstscreen\") {\n        FirstScreen(navController)\n    }\n    composable(\"secondscreen\") {\n        SecondScreen(navController)\n    }\n}\n```\n\nFirstScreen.kt: NavController의 현재 백 스택 항목의 savedStateHandle를 사용하여 두 번째 화면에서 다시 이동한 후 데이터를 검색합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun FirstScreen(navController: NavController) {\n    // 다음 화면에서 데이터를 가져옵니다\n    val msg =\n        navController.currentBackStackEntry?.savedStateHandle?.get\u003cString\u003e(\"msg\")\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Button(onClick = { navController.navigate(\"secondscreen\") }) {\n            Text(\"다음 화면으로 이동\")\n        }\n        Spacer(modifier = Modifier.height(8.dp))\n        msg?.let {\n            Text(it)\n        }\n    }\n}\n```\n\nSecondScreen.kt: 이전 백 스택 항목의 savedStateHandle 내에 데이터를 넣습니다.\n\n```kotlin\n@Composable\nfun SecondScreen(navController: NavController) {\n    var text by remember {\n        mutableStateOf(\"\")\n    }\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        TextField(\n            value = text, onValueChange = { text = it },\n            placeholder = {\n                Text(\"텍스트를 입력하세요\", color = Color.Gray)\n            }\n        )\n        Spacer(Modifier.height(8.dp))\n        Button(onClick = {\n\n           // 데이터를 savedStateHandle에 넣어 이전 화면에서 데이터를 가져옵니다\n\n            navController.previousBackStackEntry?.savedStateHandle?.set(\"msg\", text)\n            navController.popBackStack()\n        }) {\n            Text(text = \"제출\")\n        }\n    }\n}\n```\n\n비디오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://github.com/KaushalVasava/JetPackCompose_Basic/assets/49050597/1d96d44f-66e1-4f3b-bba1-2844ab6553cc\n\nGitHub 저장소: https://github.com/KaushalVasava/JetPackCompose_Basic/tree/navigate-back-with-result\n\n# 딥 링크\n\nNavigation Compose은 암시적 딥 링크를 지원하며 composable() 함수의 일부로 정의할 수 있습니다. 딥 링크 매개변수 deepLinks는 navDeepLink 메소드를 사용하여 빠르게 생성할 수 있는 NavDeepLinks 목록을 수용합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nval uri = \"https://www.example.com\"\ncomposable(\n    \"profile?id={id}\",\n    deepLinks = listOf(navDeepLink { uriPattern = \"$uri/{id}\" })\n) { backStackEntry -\u003e\n    Profile(navController, backStackEntry.arguments?.getString(\"id\"))\n}\n```\n\n이러한 딥 링크를 사용하면 특정 URL, 액션 또는 MIME 유형을 composable과 연결할 수 있습니다. 기본적으로 이러한 딥 링크는 외부 앱에 노출되지 않습니다. 이러한 딥 링크를 외부에서 사용 가능하게 하려면 앱의 manifest.xml 파일에 적절한 `intent-filter` 요소를 추가해야 합니다. 위의 딥 링크를 활성화하려면 manifest의 `activity` 요소 내에 다음을 추가해야 합니다:\n\n```js\n\u003cactivity …\u003e\n  \u003cintent-filter\u003e\n    ...\n    \u003cdata android:scheme=\"https\" android:host=\"www.example.com\" /\u003e\n  \u003c/intent-filter\u003e\n\u003c/activity\u003e\n```\n\n다른 앱에 의해 트리거된 경우 딥 링크가 활성화될 때 해당 composable로 자동으로 이동합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 동일한 딥 링크는 콤포저블에서 적절한 딥 링크와 함께 PendingIntent를 작성하는 데 사용할 수도 있습니다:\n\n```kotlin\nval id = \"exampleId\"\nval context = LocalContext.current\nval deepLinkIntent = Intent(\n    Intent.ACTION_VIEW,\n    \"https://www.example.com/$id\".toUri(),\n    context,\n    MyActivity::class.java\n)\nval deepLinkPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {\n    addNextIntentWithParentStack(deepLinkIntent)\n\n    val flag = if(Build.VERSION.SDK_INT \u003e Build.VERSION_CODES.S){\n                    PendingIntent.FLAG_IMMUTABLE\n                }\n                else\n                    PendingIntent.FLAG_UPDATE_CURRENT\n    getPendingIntent(0, flag)\n}\n```\n\n그런 다음 이 deepLinkPendingIntent를 다른 PendingIntent와 마찬가지로 사용하여 앱을 딥 링크 대상지에서 열 수 있습니다.\n\n# 중첩된 내비게이션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_1.png)\n\n앱의 UI에서 특정 플로우를 모듈화하기 위해 대상을 중첩 그래프로 그룹화할 수 있습니다. 이러한 예로는 독립적인 로그인 플로우가 있을 수 있습니다.\n\n중첩 그래프는 메인 그래프처럼 대상을 그룹화하며 해당 경로에 대한 지정된 시작 대상이 필요합니다. 이것은 중첩된 그래프의 경로에 액세스할 때 이동할 위치입니다.\n\nNavHost에 중첩된 그래프를 추가하려면 네비게이션 익스텐션 함수를 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nNavHost(navController, startDestination = \"home\") {\n    ...\n    // 그래프를 통해 경로('login')로 이동하면 자동으로\n    // 그래프의 시작 대상인 'username'으로 이동합니다.\n    // 이로써 그래프의 내부 라우팅 로직을 캡슐화합니다.\n    navigation(startDestination = \"username\", route = \"login\") {\n        composable(\"username\") { ... }\n        composable(\"password\") { ... }\n        composable(\"registration\") { ... }\n    }\n    ...\n}\n```\n\n그래프가 커질수록 여러 메소드로 나누는 것이 좋습니다. 이렇게 하면 여러 모듈이 각자의 네비게이션 그래프를 기여할 수 있습니다.\n\n```js\nfun NavGraphBuilder.loginGraph(navController: NavController) {\n    navigation(startDestination = \"username\", route = \"login\") {\n        composable(\"username\") { ... }\n        composable(\"password\") { ... }\n        composable(\"registration\") { ... }\n    }\n}\n```\n\nNavGraphBuilder를 확장 메소드로 만들면 미리 작성된 navigation, composable, dialog 익스텐션 메소드와 함께 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nNavHost(navController, startDestination = \"home\") {\n    ...\n    loginGraph(navController)\n    ...\n}\n```\n\n예시:\n\n```kotlin\nval navController = rememberNavController()\nNavHost(navController = navController, startDestination = \"home\") {\n    composable(\"about\") {}\n    navigation(\n        startDestination = \"login\",\n        route = \"auth\"\n    ) {\n        composable(\"login\") {\n            val viewModel = it.sharedViewModel\u003cSampleViewModel\u003e(navController)\n\n            Button(onClick = {\n                navController.navigate(\"calendar\") {\n                    popUpTo(\"auth\") {\n                        inclusive = true\n                    }\n                }\n            }) {\n            }\n        }\n        composable(\"register\") {\n            val viewModel = it.sharedViewModel\u003cSampleViewModel\u003e(navController)\n        }\n        composable(\"forgot_password\") {\n            val viewModel = it.sharedViewModel\u003cSampleViewModel\u003e(navController)\n        }\n    }\n    navigation(\n        startDestination = \"calendar_overview\",\n        route = \"calendar\"\n    ) {\n        composable(\"calendar_overview\") { }\n        composable(\"calendar_entry\") { }\n    }\n}\n```\n\nNavBackStack entry를 위한 확장 함수\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\ninline fun \u003creified T : ViewModel\u003e NavBackStackEntry.sharedViewModel(navController: NavController): T {\n    val navGraphRoute = destination.parent?.route ?: return viewModel()\n    val parentEntry = remember(this) {\n        navController.getBackStackEntry(navGraphRoute)\n    }\n    return viewModel(parentEntry)\n}\n```\n\n# 하단 탐색 막대와 통합\n\n조합 가능한 구조의 위쪽 수준에서 NavController를 정의함으로써, 네비게이션을 하단 탐색 막대와 같은 다른 구성 요소와 연결할 수 있습니다. 이를 통해 하단 막대에서 아이콘을 선택하여 탐색할 수 있습니다.\n\nBottomNavigation 및 BottomNavigationItem 구성 요소를 사용하려면 Android 애플리케이션에 androidx.compose.material 종속성을 추가하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n좌측 테이블을 Markdown 형식으로 변환했습니다.\n```\n\n하단 네비게이션바의 항목을 네비게이션 그래프의 루트에 링크하려면 Screen과 같은 sealed class를 정의하는 것이 좋습니다. 이 클래스는 목적지의 루트와 문자열 리소스 ID를 포함합니다.\n\n```js\nsealed class Screen(val route: String, @StringRes val resourceId: Int) {\n    object Profile : Screen(\"profile\", R.string.profile)\n    object FriendsList : Screen(\"friendslist\", R.string.friends_list)\n}\n```\n\n이후 BottomNavigationItem에서 사용할 수 있는 리스트에 해당 항목을 넣으십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nval items = listOf(\n    Screen.Profile,\n    Screen.FriendsList\n)\n```\n\nBottomNavigation 컴포저에서 currentBackStackEntryAsState() 함수를 사용하여 현재 NavBackStackEntry를 가져옵니다. 이 엔트리를 통해 현재 NavDestination에 액세스할 수 있습니다. 각 BottomNavigationItem의 선택 상태는 아이템의 경로를 현재 목적지 및 부모 목적지의 경로와 비교하여 결정할 수 있습니다 (중첩된 내비게이션을 사용하는 경우 처리하기 위해 NavDestination 계층구조를 통해).\n\n아이템의 경로는 또한 onClick 람다를 navigate 호출과 연결하는 데 사용되어 해당 아이템을 탭하면 해당 아이템으로 이동합니다. saveState 및 restoreState 플래그를 사용하여 해당 아이템의 상태와 백 스택이 올바르게 저장되고 전환될 때 해당 아이템의 상태가 올바르게 복원됩니다.\n\n```kotlin\nval navController = rememberNavController()\nScaffold(\n    bottomBar = {\n        BottomNavigation {\n            val navBackStackEntry by navController.currentBackStackEntryAsState()\n            val currentDestination = navBackStackEntry?.destination\n            items.forEach { screen -\u003e\n                BottomNavigationItem(\n                    icon = { Icon(Icons.Filled.Favorite, contentDescription = null) },\n                    label = { Text(stringResource(screen.resourceId)) },\n                    selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,\n                    onClick = {\n                        navController.navigate(screen.route) {\n                            popUpTo(navController.graph.findStartDestination().id) {\n                                saveState = true\n                            }\n                            launchSingleTop = true\n                            restoreState = true\n                        }\n                    }\n                )\n            }\n        }\n    }\n) { innerPadding -\u003e\n    NavHost(navController, startDestination = Screen.Profile.route, Modifier.padding(innerPadding)) {\n        composable(Screen.Profile.route) { Profile(navController) }\n        composable(Screen.FriendsList.route) { FriendsList(navController) }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNavController.currentBackStackEntryAsState() 메소드를 활용하여 네비게이션 컨트롤러 상태를 NavHost 함수 밖으로 빼내어 BottomNavigation 컴포넌트와 공유합니다. 이렇게 하면 BottomNavigation이 항상 최신 상태를 가지게 됩니다.\n\n읽어 주셔서 감사합니다. 🙌🙏✌\n\n더 많은 안드로이드 개발, 코틀린 및 KMP에 관한 유용한 기사를 보시려면 박수를 날려주세요 👏 그리고 팔로우해 주세요.\n\n안드로이드, 코틀린 및 KMP 관련 도움이 필요하시다면 언제든지 도와드리겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMedium, LinkedIn, Twitter, GitHub, Instagram에서 나를 팔로우하고 DM으로 앱 개발 프리랜싱 업무를 문의해주세요.\n","ogImage":{"url":"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png"},"coverImage":"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png","tag":["Tech"],"readingTime":25},{"title":"Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피","description":"","date":"2024-05-18 17:11","slug":"2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin","content":"\n코틀린 코루틴의 깨끗한 세계에서는 다양한 시간에 실행되는 많은 작업들이 놀랍게도 적은 스레드로 쌓이게 됩니다. 이러한 코루틴들은 종종 서로 통신을 해야합니다. 예를 들어 비동기 작업이 완료되어 결과를 보고해야 하거나 진행 중인 작업이 결과를 전달해야 할 때입니다.\n\n코틀린에는 이러한 통신을 관리하는 데 도움이 되는 여러 구조가 있습니다. 서스펜드 함수는 비동기 작업을 기다리는 데 도움이 되며, 여러 결과를 기대하는 경우 플로우가 필요합니다.\n\n이 기사에서는 일반적으로 비동기 처리에 대해 예시를 들고, 플로우를 소개합니다. 플로우가 왜 필요한지, 핫 플로우와 콜드 플로우의 차이, 그리고 콜백을 서스펜드 함수와 플로우로 변환하는 방법에 대해 알아보겠습니다.\n\n# 레시피 1: 자바 콜백, 어린날로의 돌아가기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우선, 여기에는 일시 중단 함수나 플로우가 아닌 것이 있습니다. Firestore에서 문서를 가져오는 방법은 다음과 같습니다:\n\n```js\nFirebase.firestore.collection(\"users\").document(\"me\")\n  .get()   // \"me\" 문서의 비동기 다운로드 시작\n  .addOnSuccessListener { result -\u003e\n    // 다운로드가 완료될 때이 함수가 호출됩니다\n  }\n```\n\n이는 비동기 콜백 패턴입니다. 요청을 하면 작업이 비동기적으로 수행되고 나중에 결과가 돌아옵니다.\n\nJava와 하위 호환성을 유지하며 작성된 API는 이와 같은 비동기 콜백을 가득 가지고 있습니다. 이 패턴은 오래된 것으로 간주되므로 Kotlin 스타일이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 레시피 2: Kotlin을 사용하여 콜백 처리하기: suspendCoroutine\n\n요청한 내용을 받고 나줌에 결과를 받는 상황을 처리하는 더 나은 방법은 코틀린 코루틴의 강력한 기능을 활용하는 대기 함수를 사용하는 것입니다. 제 최근 블로그 포스트에서 대기 함수에 대해 자세히 설명했었는데, 요약하자면: 대기 함수는 현재 코루틴을 일시 중단하지만 실행 중인 스레드를 차단하지 않습니다.\n\n좋은 소식은 콜백을 대기 함수로 변환할 수 있다는 것입니다\\*. 필요한 함수는 suspendCoroutine입니다:\n\n```js\nsuspend fun getDocument() = suspendCoroutine { continuation -\u003e\n  Firebase.firestore.collection(\"users\").document(\"me\")\n    .get()\n    .addOnSuccessListener { result -\u003e\n      // 받은 문서를 사용하여 일시 중단된 코루틴을 다시 실행합니다.\n      continuation.resume(result)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋아요. 이제는 getDocument()를 호출하는 방법이 훨씬 간단해졌어요. 예를 들어 ViewModel에서:\n\n```js\nviewModelScope.launch(Dispatchers.IO) {\n    val location = getDocument()\n}\n```\n\nJava의 모든 부가 기능을 제거한 Kotlin이 얼마나 아름다운지 보세요. 함수를 한 줄로 호출할 수 있어요. 아름다워요.\n\n# 안티-레시피 1: 일회성 함수는 한 번만 반환할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 만일 우리가 하나 이상의 응답을 예상하고 있다면 어떻게 해야 할까요?\n\nFirestore에게 문서의 새 버전을 얻을 때마다 업데이트를 유지하도록 요청할 수 있습니다. 이를 위해 addOnSnapshotListener를 사용하고 Firestore는 업데이트가 있을 때마다 리스너를 호출합니다:\n\n```js\nFirebase.firestore.collection(\"users\").document(\"me\")\n  .addOnSnapshotListener { snapshot, error -\u003e\n    // 이 함수는 \"me\" 문서가 업데이트될 때마다 호출됩니다.\n  }\n```\n\n이것을 대기 함수로 변경할 수 있을까요? 아뇨! 대기 함수는 한 번만 반환합니다. 여러 번 continuation.resume()을 호출하면 IllegalStateException(\"이미 재개되었습니다\")가 발생합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Recipe 3](/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png)\n\nSo we need something different. What we need is a flow.\n\n# Recipe 3: Using callbackFlow to return multiple things from an async callback\n\nWhen an object hits the flow’s conveyor belt, we say it’s been emitted by the flow. When it gets taken off the conveyor belt to be handled, we say it’s been collected by a collector.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 Firestore 예제에서는 문서 데이터가 로드되는 플로우를 생성해야 합니다. 나중에 그것을 수집하는 코드를 작성할 것입니다.\n\n## 멀티 샷 콜백을 플로우로 변환하기: callbackFlow\n\n여기서 우리는 흐름 \"컨베이어 벨트\"를 생성하고 업데이트된 문서를 올립니다. 업데이트된 문서는 콜백에서 얻은 스냅샷으로 나타납니다:\n\n```js\n// callbackFlow를 사용하여 플로우 \"컨베이어 벨트\"를 만듭니다.\nval documentFlow = callbackFlow {\n\n  // Firestore에게 \"me\" 문서의 변경 사항을 계속 업데이트하라고 요청합니다.\n  database.collection(\"users\").document(\"me\")\n    .addOnSnapshotListener { snapshot, error -\u003e\n      // 업데이트된 문서를 이 플로우의 \"컨베이어 벨트\"에 올립니다.\n      trySend(snapshot)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 Firestore에서 받은 각 스냅샷을 방출하는 flow 객체를 생성합니다.\n\n# 레시피 4: flow 수집하기\n\n이제 이 컨베이어 벨트를 설정했고, documentFlow라는 변수에 할당했습니다. 결과를 어떻게 얻을까요?\n\n답변: collect 함수를 사용하여 결과를 수집합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nviewModelScope.launch {\n  documentFlow.collect { snapshot -\u003e\n    // This is the snapshot placed on the conveyor belt earlier\n  }\n}\n```\n\n이 함수는 일시 중단되므로 코루틴 내에서 실행해야 합니다. collect에 전달하는 람다는 새 항목이 컨베이어 벨트에 나타날 때마다 호출됩니다.\n\n이것의 라이프사이클을 좀 고려해보죠. collect 함수는 컨베이어 벨트가 작동을 멈출 때까지 일시 중단됩니다.\n\n플로우 컨베이어 벨트가 작동을 멈출 수 있는 방법은 두 가지뿐입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 종료로: 발신자가 더 이상 전달할 것이 없으면 close()를 호출하여 컨베이어 벨트가 멈추도록 요청합니다.\n- 오류로: 발신자가 예외를 throw합니다. 이로 인해 자동으로 흐름이 닫힙니다.\n\n물론 위의 조건 중 어느 것도 발생하지 않을 수 있어서 컨베이어가 멈출 수도 없습니다. 따라서 collect 호출은 무한 루프를 나타낼 수 있습니다. 그러나 코루틴의 진정한 매력은 collect 함수가 취소 가능하다는 것입니다. 따라서 위의 예제에서는 viewModelScope가 취소되는 즉시 수집이 중지됩니다. 그렇기 때문에 위의 코드는 사실 완전히 안전합니다. 코루틴 범위, 컨텍스트, 작업에 대한 더 많은 내용은 블로그 글에서 확인하실 수 있습니다.\n\n# 레시피 5: Cold flows와 awaitClose\n\ncallbackFlow 람다 내의 코드는 수집기가 수집을 시작할 때 즉시 실행됩니다. 각 새로운 수집기는 다른 수집기와 병렬로 실행 중이더라도 코드가 다시 실행되게 합니다. 이것이 콜드 플로우 동작이라고 알려져 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이에 따라, 수집기가 수집을 멈출 때 Firestore 연결을 종료해야 합니다. 'awaitClose'를 사용하여 이를 자동으로 처리할 수 있습니다:\n\n```js\nval documentFlow = callbackFlow {\n  val listener = database.collection(\"users\").document(\"me\")\n    .addOnSnapshotListener { snapshot, error -\u003e\n      ...\n    }\n\n  // 이 코드 블록은 수집기가 수집을 멈출 때마다 실행됩니다\n  awaitClose {\n    // Firestore 연결 종료\n    listener.remove()\n  }\n}\n```\n\n'awaitClose' 블록은 수집기가 수집을 멈출 때마다 실행됩니다. 이를 사용하여 원격 데이터베이스의 리스너를 등록 해제합니다.\n\n우리의 더 높은 수준의 코드를 수정할 필요는 없습니다: 우리는 여전히 레시피 4의 문서 플로우 수집을 위해 documentFlow.collect를 호출합니다. 모든 것이 요구될 때 필요한대로 모두 종료되도록 보장하는 데 필요한 다른 작업은 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 레시피 6: SharedFlow 및 여러 수집기\n\n알고 계세요. callbackFlow 람다의 코드는 수집기가 수집을 시작하는 즉시 실행됩니다. 즉, 동시에 100개의 수집기가 작동하는 경우 Firestore로부터 100개의 연결이 열리게 됩니다. 한 개로도 충분히 해결할 수 있는 상황에서 매우 비효율적입니다.\n\n실제로 우리가 원하는 것은 여러 수집기를 사용할 수 있는 flow 입니다. 이 flow는 첫 번째 수집기가 데이터 수집을 시작할 때 Firestore 연결을 시작하고, 마지막 수집기가 멈출 때 해당 연결을 종료해야 합니다. 해당 시간 사이에 도착하는 다른 수집기는 새로운 Firestore 연결을 열지 않고 데이터의 사본을 받아야 합니다.\n\n다시 말해, flow의 지속적인 이벤트와 개별 수집기의 도착/사라짐 간의 연계를 어느 정도 분리하고자 합니다. 더 이상 냉각된 flow를 사용하고 싶지 않으며, hot flow를 원합니다. hot flow의 수집기를 구독자(subscriber)라고 합니다 — 이러한 언어의 약간의 변경은 flow가 수집자와 독립적으로 계속되는 사실을 강조하기 위한 것입니다. 구독자는 단지 \"확인\"하는 역할을 하며, flow를 운전하는 것이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 필요한 특정 종류의 핫 플로우는 SharedFlow입니다. SharedFlow는 데이터를 여러 구독자에게 방송하는 데 사용됩니다. 예를 들어 데이터를 SharedFlow 컨베이어 벨트에로드하는 코루틴이 여기에 있습니다.\n\n해당 코루틴이 실행중인 한 데이터는 컨베이어 벨트를 따라 이동합니다. 누군가 데이터를 수집하고 있든 상관없습니다.\n\n플로우가 흐르기 시작한 정확한 시점에 구독하면 순차적으로 0, 1, 2, 3, 4...가 출력됩니다. 그러나 몇 초 후에 수집을 시작하면 처음 몇 번의 에미션이 놓치고 7, 8, 9, 10, 11...이 출력됩니다. 이것은 플로우가 수집을 시작하기 전에 이미 흐르기 시작했음을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 레시피 7: 차가운 플로우를 공유해서 뜨겁게 만들기\n\n`shareIn()` 함수는 차가운 플로우를 가져와서 뜨겁게 만드는 데 사용됩니다. 즉, 이 함수는 코루틴을 시작하여 차가운 플로우를 수집하고 받은 모든 것을 구독자에게 다시 방송합니다. 구독자의 수는 0을 포함하여 제한이 없을 수 있습니다.\n\n다음은 `shareIn()` 함수의 정의입니다:\n\n```js\nfun \u003cT\u003e Flow\u003cT\u003e.shareIn(\n    scope: CoroutineScope,\n    started: SharingStarted,\n    replay: Int = 0\n): SharedFlow\u003cT\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한 Android Activity는 SharingStarted.WhileSubscribed()와 stopTimeoutMillis를 사용하는 예시입니다. 액티비티는 장치가 회전될 때 종료되고 다시 시작되기 때문에 해당 프로세스 중 구독자는 몇 밀리초 동안 사라집니다. 이를 방지하기 위해 코드 플로우를 즉시 종료하고 다시 시작하지 않도록하기 위해 shareIn의 coroutine은 5000밀리초 동안 유지됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내, replay 매개변수를 사용하여 구독자가 처음 구독할 때 현재 및 이전 값도 받을 수 있습니다.\n\n# 요약하면...\n\n- suspendCoroutine을 사용하여 비동기 단일 호출 콜백을 일시 중단 함수로 변환할 수 있습니다.\n- 다중 호출 콜백이 있는 경우 플로우가 필요합니다. callbackFlow를 사용하여 다중 호출 콜백을 플로우로 변환할 수 있습니다.\n- callbackFlow에서 생성된 것과 같은 Cold flows는 각 수집기에 대해 별도로 실행됩니다.\n- Hot flows는 수집기(구독자라고도 불림)와 독립적으로 실행됩니다.\n- SharedFlow와 같은 Hot flows 예는 여러 구독자에게 배출을 전파하는 SharedFlow입니다. cold flow를 sharedIn()를 사용하여 SharedFlow로 변환할 수 있습니다.\n\n도움이 되었기를 바랍니다. 모든 의견을 환영합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코틀린에서의 비동기 처리는 매우 넓은 주제입니다. 그 중에서도 특히 플로우(Flow)는 다양한 기능이 있습니다. 이에 대해 특정 소주제에 초점을 맞춘 더 많은 기사를 쓸 예정이니, 댓글이나 LinkedIn에서 어떤 내용이 도움이 될지 알려주세요.\n\n- Firestore 팬 여러분을 위해 말하자면, kotlinx-coroutines-play-services 라이브러리의 await()을 사용하여 이 특정 콜백을 중지할 수 있는 작업으로 바꿀 수 있다는 사실을 지적할 것입니다. 맞아요, 당연히 맞습니다. 하지만 이렇게 멋진 예제를 볼 수 없을 테지요? 🙃\n\n\\*\\* Firebase는 실제로 그것 이상으로 똑똑하며, 여러 연결을 열지 않도록 합니다. 위를 참조하세요.\n\n톰 콜빈(Tom Colvin)은 안드로이드의 Google 개발 전문가로, 20년간 소프트웨어 아키텍처를 설계해왔습니다. 그는 모바일 앱 전문가인 Apptaura의 공동 창업자이자 CTO이며, 컨설팅을 통해 사용 가능합니다.\n","ogImage":{"url":"/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png"},"coverImage":"/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png","tag":["Tech"],"readingTime":12},{"title":"플러터 애플리케이션에서 보안 강화하기","description":"","date":"2024-05-18 17:10","slug":"2024-05-18-IncreasesecurityinyourFlutterapplications","content":"\n![보안 강화하기](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png)\n\n현재의 디지털 세계에서 애플리케이션 보안은 절대적인 우선 순위입니다. 견고하고 안전한 Flutter 앱을 개발하는 것은 사용자 데이터를 보호하고 제품에 대한 신뢰를 유지하는 데 중요합니다. Flutter 애플리케이션 보안 여정을 시작하는 경우, 제 이전 기사를 읽어 보시기를 권장합니다. 해당 기사에서는 Gray Box 모드에서 응용 프로그램의 보안을 보장하기 위한 필수적인 실천 방법을 탐구했습니다(기사 링크).\n\n# 보안 분석: 주요 결론\n\nFlutter 애플리케이션의 보안 평가 중에 시장 경험을 토대로 가능한 취약점을 찾을 수 있는 여러 단계를 식별했습니다. 아래에서 자세히 이야기하도록 하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 인증 검토\n\n애플리케이션에서 사용되는 인증 메커니즘을 조사합니다. 인증 중 강력한 보안 메커니즘의 부재로 사용자 토큰에 민감한 데이터가 평문으로 포함되는 문제가 발생했다고 발견했습니다. 명확히 말하자면, JWT 토큰은 올바른 방식으로 발급되지 않으면 복호화될 수 있습니다. jwt.io 웹사이트에서는 토큰을 붙여넣으면 모든 내부 데이터를 제시해줍니다.\n\n![이미지1](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_1.png)\n\n![이미지2](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFigure 1에서는 웹 사이트에 추가된 JWT 토큰을 볼 수 있고, Figure 2에서는 분해된 데이터가 나타납니다. 이 토큰을 해독하는 데 도움이 되는 보안 키의 사용 방식을 강조할 가치가 있습니다. 이 키는 서버만 사용하여 컴파일하고 앱-클라이언트가 분해하는 데 사용됩니다. Figure 3에 표시된 대로입니다.\n\n![Image](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_3.png)\n\n## 액세스 제어의 평가와 문제 해결 방지\n\n또 다른 중요한 점은 프론트엔드의 액세스 제어이며, 여러 중요한 결함을 발견할 수 있는데, 애플리케이션이 안전하지 않은 기기에서 액세스되도록 허용합니다. 즉, 탈옥 또는 루팅된 것으로 간주되는 특정 기기에서 허용됩니다.\n이러한 기기는 너무 허용되어 있어 일반적인 운영 체제에서 적용된 보안 제약 사항 없이 작업을 수행하고 응용 프로그램을 설치할 수 있는 것을 의미합니다. 이러한 환경에서는 앱 보안 메커니즘이 쉽게 우회될 수 있어 민감한 데이터 및 중요한 기능이 잠재적인 공격자에게 노출될 수 있습니다. 이는 미약한 기기로부터의 액세스를 차단하고 탐지하기 위해 프론트엔드에 보다 엄격한 보안 제어를 구현해야 함을 강조합니다.\nFlutter에서 액세스 제어 결함을 극복하고 안전하지 않은 기기에서 애플리케이션을 보호하기 위해 여러 전략을 채택할 수 있습니다. 이 기기들을 감지하는 것이 중요합니다. Flutter에는 기기의 탈옥 또는 루팅 여부를 확인하는 데 도움이 되는 특정 라이브러리가 있습니다. 탈옥 또는 루팅된 기기를 감지하면 사용자에게 경고 메시지를 표시하고 액세스를 차단하여 앱이 작동하지 않도록 할 수 있습니다.\n또 다른 중요한 조치는 애플리케이션이 실행되는 환경의 무결성을 확인하는 것입니다. 이는 에뮬레이터를 감지하고 응용프로그램 바이너리가 변경되지 않았는지 확인하는 것을 포함할 수 있습니다. 이를 위해 디지털 서명 및 체크섬 확인 기술을 사용하여 애플리케이션 코드가 변경되지 않도록 보장할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, 로컬에 저장된 모든 민감한 데이터를 암호화하는 것이 중요합니다. 안전한 암호화 라이브러리를 사용하면 데이터가 평문으로 저장되지 않아 기기가 침해당해도 민감한 정보를 보호할 수 있습니다. 예를 들어, flutter_secure_storage 패키지는 Flutter에서 데이터를 안전하게 암호화하여 저장하는 방법을 제공합니다.\n\n마지막으로, 엄격한 서버 측 보안 정책을 시행하는 것이 중요합니다. 서버가 클라이언트의 확인이나 조치와는 독립적으로 모든 요청을 유효성을 검사하도록 하는 것이 필수적입니다. 서버는 설정된 보안 기준을 충족하지 않는 요청을 거부해야 하며, 가능한 공격에 대비한 추가적인 보호층을 추가해야 합니다.\n\n## 방지 방탈림 메커니즘의 실패\n\n또 다른 중요한 점은 안드로이드 애플리케이션을 디컴파일할 때 소스 코드를 변경하고 애플리케이션을 다시 컴파일할 수 있는지 확인하는 것입니다. APKTOOL과 같은 도구를 사용하여 APK를 디컴파일하고 획득한 Java 코드를 수정할 수 있습니다. 이 과정 이후에 텍스트 편집기인 Sublime Text와 같은 도구를 사용하여 변수를 변경할 수 있었습니다. 코드를 변경한 후에는 같은 APKTOOL을 사용하여 애플리케이션을 다시 컴파일하고 서명할 수 있었습니다. 이러한 프로세스가 완료된 후 수정된 소스 코드가 재컴파일된 애플리케이션에 적용되었는지 확인할 수 있습니다.\n\n이 취약점은 공격자가 역공학을 통해 애플리케이션의 내부 작업을 이해할 수 있게 하여 보안 메커니즘에 대한 공격을 개발할 수 있는 것을 의미합니다. 공격자는 왓츠앱이나 유튜브와 같은 앱에서 현재 매우 일반적인 사용자가 보낸 메시지를 삭제하지 못하도록 막거나 광고를 표시하는 등의 미인증된 새로운 기능을 추가할 수 있으며, 데이터 유출, 회사의 평판 및 이미지 훼손, 사기까지 발생할 수 있습니다.\n\n이러한 위험을 완화하기 위해 응용 프로그램이 컴파일 중에 수행한 코드 변경을 런타임에서 감지할 수 있어야 합니다. 응용 프로그램은 침해된 환경을 식별하고 서버에 위반 사항을 보고하거나 응용 프로그램을 종료함으로써 적절히 대응해야 합니다. 이러한 조치를 구현하는 것은 방탈림 시도에 대한 응용 프로그램의 보호와 사용자 데이터의 무결성 및 보안을 보장하는 데 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제까지 찾아낸 몇 가지 포인트들이 있어요. Flutter 애플리케이션에서 보안에 대해 더 알아보기를 권유합니다. 제공되는 자원을 활용하고 사이버보안 워크샵, 강좌 및 포럼에 참여해보세요. 보안은 공동 책임이며, 디지털 세계의 계속 변화하는 도전에 대비하기 위해 우리 모두가 교육받고 준비되어야 합니다.\n기억하세요, 보안은 목적지가 아니라 계속되는 여정입니다. 함께 하면 Flutter 앱을 모든 사용자들을 위해 더 안전하고 안전하게 만들 수 있습니다.\n공부하고 배우고, 애플리케이션을 통해 더 안전한 디지털 미래를 만들어 봅시다.\n\n도움이 되었나요? 커피 사주시겠어요?\n\n저를 팔로우해주세요.\n\n- Linkedin: raphaelkennedy\n- Youtube: raphaelpontes\n","ogImage":{"url":"/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png"},"coverImage":"/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png","tag":["Tech"],"readingTime":5},{"title":"응용 프로그램 아키텍처 데이터 레이어","description":"","date":"2024-05-18 17:09","slug":"2024-05-18-AppArchitectureDatalayer","content":"\n![AppArchitectureDatalayer_0](/assets/img/2024-05-18-AppArchitectureDatalayer_0.png)\n\n이전 글에서는 도메인 레이어를 안정적이고 플랫폼 독립적인 레이어로 다루었습니다. 오늘은 데이터 레이어의 목적을 다루겠습니다. 함께 알아봅시다.\n\n![AppArchitectureDatalayer_1](/assets/img/2024-05-18-AppArchitectureDatalayer_1.png)\n\n데이터 레이어는 앱의 나머지 부분에 데이터를 노출하는 역할을 합니다. 다양한 데이터 소스를 관리하고 그들 사이의 충돌을 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 저장소\n\n데이터 레이어는 Repository로 이루어져 있습니다. 이전 챕터에서 언급했듯이 도메인 레이어에 대해:\n\n데이터 레이어는 도메인 레이어의 저장소를 구현한 것입니다. Repository 클래스는 앱에서 처리하는 각기 다른 유형의 데이터를 나타내어야 합니다. 예를 들어:\n\n## 네이밍 규칙\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레포지토리 클래스는 담당하는 데이터를 따라 이름이 지어집니다.\n\n데이터 유형 + DataRepository와 같은 형식을 따릅니다.\n\n예를 들어 TicketRepository 인터페이스가 있으면 충돌을 피하기 위해 구현체는 TicketDataRepository로 지정됩니다.\n\n## 데이터 소스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레포지토리는 다양한 데이터 소스를 관리합니다 (예: 로컬, 메모리, 네트워크). 이 작업을 담당하는 구성 요소는 DataSource입니다. 이는 데이터베이스, 네트워크, ShearedPreference, WorkManager 및 파일과 같은 데이터 소스와 레포지토리 사이의 추상화입니다.\n\n- 데이터 소스는 한 번에 하나의 데이터 소스와만 작업해야 합니다.\n- 데이터 소스는 데이터 레이어를 위해 비공개이어야 하며 레포지토리를 통해서만 접근해야 합니다.\n\n## 네이밍 규칙\n\n데이터 소스 클래스는 그들이 책임지는 데이터와 사용하는 소스를 기반으로 명명됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 유형 + 소스 유형 + DataSource.\n\n데이터 유형으로는 Remote 또는 Local을 사용하여 구현이 변경될 수 있으므로 더 일반적으로 설정하세요 (예: FaresLocalDataSource 또는 FaresRemoteDataSource). 소스가 중요한 경우를 위해 소스 유형을 사용하여 더 구체적으로 설명하세요 (예: FaresNetworkDataSource 또는 FaresFileDataSource).\n\n구현 세부 정보를 기반으로한 이름을 피하세요. 예를 들어, UserSQLiteDataSource와 같이 구현 세부 정보에 기반한 이름을 사용하지 마세요. 해당 데이터 소스를 사용하는 리포지토리는 데이터가 어떻게 저장되는지 알 필요가 없습니다. 이 규칙을 따르면 데이터 소스의 구현을 변경(예: SQLite에서 DataStore로 마이그레이션)하더라도 해당 소스를 호출하는 계층에 영향을 주지 않습니다.\n\nUserApi 인터페이스는 네트워크 API 클라이언트의 구현을 숨깁니다. Retrofit 또는 GraphQL이 인터페이스를 지원하는데 차이가 없습니다. 인터페이스에 의존함으로써 앱에서 API 구현을 교체할 수 있습니다. 또한 이러한 방식은 유연성을 제공하며 의존성을 쉽게 교체할 수 있도록 합니다. 예를 들어, 테스트에서 가짜 데이터 소스 구현을 주입할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 원본은 오류 발생 시 예외 처리를 하는 좋은 위치입니다. 애플리케이션에 데이터 원본과 관련된 예외를 노출시키지 말고 대신 애플리케이션이 처리할 수 있는 예외로 매핑해야 합니다.\n\n이전에 언급했던 대로, 리포지토리는 데이터 소스와 동시성을 관리하는 데 더 중점을 둔 것입니다.\n\n위의 예시에서 보듯이, 우리는 로컬 캐시를 관리하고 로컬 및 원격 데이터 소스의 우선순위를 설정하는 전략을 구현했습니다. 리포지토리는 상태를 가질 수 있으며 예를 들어 Mutex를 사용하여 다른 스레드에서 변경 가능한 변수에 대한 읽기 및 쓰기 액세스를 관리할 수 있습니다. 따라서 리포지토리의 수명주기에 대해 고려해야 합니다.\n\n## 수명주기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가능하다면 리포지토리를 무상태로 만들 것을 권장합니다. 동시에 싱글톤으로 유지하여(instance-duplication of data sources와 같은 버그를 피하기 위해 DI를 통해 관리) 안정성을 높일 수 있습니다. DataSource도 마찬가지로 싱글톤으로 만들고 캐시는 리포지토리에서 관리하는 것을 권장합니다.\n\n## 동시성\n\n리포지토리는 어떤 CoroutineDispatcher에서 작업을 실행할지 결정해야 하는 곳입니다. 서로 다른 유형의 작업을 서로 다른 디스패처(또는 쓰레드 풀)에서 실행하는 것이 좋은 실천입니다. IO 작업을 수행하는 경우 Dispatcher.IO를 사용하는 것이 좋습니다. 테스트하기 쉽도록 클래스 생성자를 통해 디스패처를 전달해야 합니다.\n\n# 모델\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 레이어에는 도메인 레이어에서 모델을 반영하는 데이터 모델이 있지만 표현이 다를 수 있습니다. 별도의 데이터 모델을 사용하면 전송 프로토콜에 맞게 사용자 정의할 수 있는 유연성을 제공합니다. 예를 들어, 서버와 클라이언트 간의 통신에 JSON 형식을 사용하고 일부 필드는 JSON 프로토콜에 더 적합한 다른 유형을 가질 수 있습니다. 도메인 모델을 DTO로 매핑하는 로직 및 그 반대는 Repository 클래스에 배치되어야 합니다.\n\n- 데이터 레이어는 도메인 모델만 노출하고 입력으로 사용해야 합니다.\n- 데이터 모델은 Parcelable 및 Serializable와 같은 플랫폼별 직렬화 방식을 구현할 수 있습니다.\n- 사전에 모델 클래스가 정의된 경우, 한 팀의 구성원이 기능의 다른 레이어에 개별적으로 작업할 수 있습니다.\n- 이 레이어에서 노출된 데이터는 변경할 수 없어야 합니다.\n\n## 명명 규칙\n\n모델 클래스는 책임을 지는 데이터 유형의 이름으로 지어집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 유형 + DTO.\n\n예를 들어: RyderDTO, FareDTO.\n\n# 패키지 규칙\n\n```js\ndata/\n├─ local/\n│ ├─ dto/\n│ │ ├─ FareDTO\n│ │ ├─ RyderDTO\n│ ├─ FaresLocalDataSource\n│ ├─ FaresRemoteDataSource\n├─ network/\n│ ├─ api/\n│ │ ├─ UserNetworkApi // UserApi 인터페이스의 Retrofit 구현\n│ ├─ dto/\n│ │ ├─ UserDTO\n│ ├─ UserRemoteDataSource // UserApi 인터페이스 포함\n├─ repository/\n│ ├─ FaresDataRepository\n│ ├─ RydersDataRepository\n│ ├─ TicketsDataRepository\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리\n\n데이터 레이어는 도메인 레이어에 정의된 리포지토리 구현을 중심으로 구축되었습니다. 이는 데이터의 다양한 소스를 관리하고 사용하는 방법에 대한 전략을 관리하는 역할을 합니다.\n\n다음 앱 아키텍처 주제에 대해서는 계속해서 확인해보세요. 그동안 레이어 간 데이터 매핑 방법에 대해 읽어볼 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-AppArchitectureDatalayer_0.png"},"coverImage":"/assets/img/2024-05-18-AppArchitectureDatalayer_0.png","tag":["Tech"],"readingTime":6}],"page":"105","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":19,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"105"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>