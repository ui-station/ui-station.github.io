<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/105" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/105" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="델타 레이크 리퀴드 클러스터링 - 시각적 설명" href="/post/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="델타 레이크 리퀴드 클러스터링 - 시각적 설명" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="델타 레이크 리퀴드 클러스터링 - 시각적 설명" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">델타 레이크 리퀴드 클러스터링 - 시각적 설명</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Lakeview 대시보드를 통한 관측력 시리즈 - 기사 1 DBSQL 웨어하우스 어드바이저" href="/post/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Lakeview 대시보드를 통한 관측력 시리즈 - 기사 1 DBSQL 웨어하우스 어드바이저" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Lakeview 대시보드를 통한 관측력 시리즈 - 기사 1 DBSQL 웨어하우스 어드바이저" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Lakeview 대시보드를 통한 관측력 시리즈 - 기사 1 DBSQL 웨어하우스 어드바이저</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라우드 비용 최적화 핀옵스 마인드셋 수용하기" href="/post/2024-05-18-OptimizingCostsintheCloudEmbracingaFinOpsMindset"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라우드 비용 최적화 핀옵스 마인드셋 수용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-OptimizingCostsintheCloudEmbracingaFinOpsMindset_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라우드 비용 최적화 핀옵스 마인드셋 수용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">클라우드 비용 최적화 핀옵스 마인드셋 수용하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS S3와 CloudFront를 이용한 정적 웹사이트 호스팅 공개 vs 비공개" href="/post/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS S3와 CloudFront를 이용한 정적 웹사이트 호스팅 공개 vs 비공개" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS S3와 CloudFront를 이용한 정적 웹사이트 호스팅 공개 vs 비공개" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS S3와 CloudFront를 이용한 정적 웹사이트 호스팅 공개 vs 비공개</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 레이크하우스를 위한 엔드 투 엔드 데이터 엔지니어링 Airflow, Minio, Kafka, Apache Spark, Apache Flink, 그리고 Elasticsearch  PART 2" href="/post/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 레이크하우스를 위한 엔드 투 엔드 데이터 엔지니어링 Airflow, Minio, Kafka, Apache Spark, Apache Flink, 그리고 Elasticsearch  PART 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 레이크하우스를 위한 엔드 투 엔드 데이터 엔지니어링 Airflow, Minio, Kafka, Apache Spark, Apache Flink, 그리고 Elasticsearch  PART 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">데이터 레이크하우스를 위한 엔드 투 엔드 데이터 엔지니어링 Airflow, Minio, Kafka, Apache Spark, Apache Flink, 그리고 Elasticsearch  PART 2</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="서버리스 애플리케이션을 효과적으로 테스트하세요" href="/post/2024-05-18-Effectivelytestyourserverlessapplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="서버리스 애플리케이션을 효과적으로 테스트하세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="서버리스 애플리케이션을 효과적으로 테스트하세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">서버리스 애플리케이션을 효과적으로 테스트하세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS CloudFormation을 활용한 간편한 CICD 배포 설정 설정" href="/post/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS CloudFormation을 활용한 간편한 CICD 배포 설정 설정" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS CloudFormation을 활용한 간편한 CICD 배포 설정 설정" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS CloudFormation을 활용한 간편한 CICD 배포 설정 설정</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="블로그 포스트 제목 스타일로 번역하겠습니다프론트엔드 개발자입니다 위 문구를 친근한 톤으로 한국어로 번역하겠습니다프론트엔드 개발자 번역 부므타운 플레이테스팅" href="/post/2024-05-18-BoomtownPlaytesting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="블로그 포스트 제목 스타일로 번역하겠습니다프론트엔드 개발자입니다 위 문구를 친근한 톤으로 한국어로 번역하겠습니다프론트엔드 개발자 번역 부므타운 플레이테스팅" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-BoomtownPlaytesting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="블로그 포스트 제목 스타일로 번역하겠습니다프론트엔드 개발자입니다 위 문구를 친근한 톤으로 한국어로 번역하겠습니다프론트엔드 개발자 번역 부므타운 플레이테스팅" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">블로그 포스트 제목 스타일로 번역하겠습니다프론트엔드 개발자입니다 위 문구를 친근한 톤으로 한국어로 번역하겠습니다프론트엔드 개발자 번역 부므타운 플레이테스팅</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="대형 미국 게임 개발팀이 점점 사라지고 있습니다" href="/post/2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="대형 미국 게임 개발팀이 점점 사라지고 있습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="대형 미국 게임 개발팀이 점점 사라지고 있습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">대형 미국 게임 개발팀이 점점 사라지고 있습니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Godot을 평가하며" href="/post/2024-05-18-OnEvaluatingGodot"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Godot을 평가하며" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-OnEvaluatingGodot_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Godot을 평가하며" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Godot을 평가하며</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link posts_-active__YVJEi" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"델타 레이크 리퀴드 클러스터링 - 시각적 설명","description":"","date":"2024-05-18 16:27","slug":"2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation","content":"\n최소한의 노력으로 레이크하우스 데이터 저장 레이아웃을 최적화하는 방법\n\n![image](/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_0.png)\n\n# 소개\n\n데이터 레이크하우스는 오픈 테이블 형식을 사용하고 특정 공급 업체에 얽매이지 않아 장점을 누립니다. 그러나 이는 특정 읽기 및 쓰기 작업을 위해 데이터 처리를 최적화하기 위해 파일 저장 레이아웃을 최적화해야 한다는 추가적인 부담과 함께 옵니다. 읽기 또는 쓰기 작업에 의해 처리되는 데이터 양을 최소화하기 위해 가능한 한 많은 파일을 제거함으로써 작업을 효율적으로 만드는 것이 핵심 아이디어입니다. 제거는 특정 파일이 해당 쿼리에 관련이 없다는 암묵적 또는 명시적 메타데이터를 사용하여 발생합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n옛날에, Hive은 각 데이터 파티션을 HDFS 또는 클라우드 저장소의 단일 폴더로 범위를 지정하여 유명한 Hive 스타일의 파티셔닝을 소개했습니다. 그것은 작동이 잘 됩니다. 그러나 작은 파일 문제가 발생하거나 워크로드 특성 변경으로 인해 파티션 체계를 변경해야 할 때 문제가 발생합니다. 또한 Hive 스타일의 파티셔닝은 고 카디널리티 질의에 대해 도움이 되지 않습니다.\n\n오픈 테이블 형식에서 제공되는 DML 지원으로 인해, 조각 모음이나 GDPR에서 잊혀져야 할 권리와 같은 경우를 관리하기 위해 단일 또는 몇 개의 레코드를 업데이트/삭제하는 것이 매우 일반적해졌습니다. 이러한 시나리오에는 고 카디널리티 질의가 효율적이어야 합니다. 이러한 요구 사항을 충족하기 위해 Delta Lake Z-Ordering과 같은 기술이 소개되었습니다. Z-Ordering은 꽤 좋지만 OPTIMIZE 명령을 다시 실행할 때 전체 테이블(또는 파티션)을 최적화하는 반복적인 노력과 많은 낭비된 컴퓨팅 파워를 도입하는 일부 제한 사항이 있습니다. Delta Lake Z-Order의 더 자세한 탐구를 위해 Z-Order에 대한 저의 글을 살펴보십시오. 그 글에서는 낮은 수준의 세부 사항도 약간 논의됩니다.\n\nHive 스타일의 파티셔닝과 Z-Ordering의 이러한 제한 사항을 완화하기 위해 Databricks 및 Delta Lake 팀은 액체 클러스터링을 소개했습니다. 작성 시점에서 Delta Lake on Databricks에서는 아직 미리보기 상태이며 OSS Delta Lake에서는 실험적인 기능인 상태입니다. 그러나 설계 문서는 누구나 읽을 수 있습니다. 액체 클러스터링은 레코드-파일 할당 방법으로 Hilbert Curve를 사용할 것으로 예상됩니다. 액체 클러스터링의 비전은 다음과 같은 단일 최적화 기술을 가지는 것입니다:\n\n- 저 및 고 카디널리티 질의에 모두 잘 작동합니다.\n- \"이미 최적화된\" 파일을 최적화할 필요가 없습니다.\n- 클러스터링 열을 변경하면 전체 테이블을 다시 빌드할 필요가 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 게시물에서는 액체 클러스터링이 레코드를 파일에 할당하는 방식을 시각적으로 보여줄 것입니다. 목표는 기술적인 세부 내용을 파헤치는 대신에 해당 기술의 매우 높은 수준의 이해를 갖는 데 초점을 맞추는 것입니다. 여전히 상황이 조리실에 있기 때문에 세부 사항에 대해 심층적으로 파고들지 않습니다.\n\n# 기본으로 돌아가기 — 레코드를 파일에 할당하는 방법은?\n\n우리는 N개의 레코드가 있고 이를 M개의 파일에 쓰려고 한다고 가정해 봅시다. 파일 가지치기의 아이디어를 기억한다면, 비슷한 레코드를 동일한 파일에 저장하는 것이 필수적입니다. 작업 부하에 따라 비슷한 레코드는 같은 픽업 동네의 택시 여행이거나 같은 고객의 은행 거래일 수 있습니다.\n\n아래 streamlit 앱은 이 문제를 처리하는 데 3가지 방법을 보여줍니다. N 및 M에 대한 다양한 값을 사용하고 배치 방식을 조정하여 레코드가 파일에 할당되는 방식을 시각적으로 확인할 수 있습니다. 이 간단한 앱에서는 모든 레코드가 필드 그룹을 갖고 있지만 우리는 2차원 평면 상 좌표인 x 및 y라는 두 개의 정수 필드에 대한 쿼리를 최적화해야 합니다. 레코드는 N개의 레코드를 생성하도록 x와 y의 쌍별 조합을 균등하게 다루기 위해 생성됩니다. 배치 방법 선택에 따라 각 지점(레코드)이 특정 파일에 할당되며 이 할당은 파일 색상을 사용하여 지정됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 랜덤 할당\n\n이 방식은 사용자 정의 로직을 거의 사용하지 않습니다. 레코드가 무작위로 파일에 할당됩니다.\n\n![Image](/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_1.png)\n\n2. Z-Ordering 할당\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 방법은 Z-Ordering을 사용하여 각 레코드 (x와 y의 조합)마다 Z-Order 값을 계산하는 것입니다. 이는 평면 상의 이차원 점을 선 상의 점으로 효과적으로 변환합니다. 그런 다음 선을 M개의 세그먼트로 나눌 수 있으며, 각 세그먼트는 하나의 파일을 나타냅니다. 레코드가 Z-Order 값 z를 갖고 있다면, 파일 z % M에 할당됩니다. 이제 점들은 일차원 관련 값을 갖고 있기 때문에, 그러한 값들을 선으로 연결하여 매핑이 어떻게 이루어지는지 시각적으로 확인할 수 있습니다. 각 점 위에 마우스를 올려놓으면 선형 순서 값을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_2.png)\n\n공간적으로 서로 가까운 레코드들은 Z-Order 라인 상에서 서로 가까이 배치됩니다. 예를 들어, 위 스크린샷을 보면, 점 (2,4)와 (3,4)는 각각 36과 37의 Z-Order 값을 가지고 있습니다. (0,4)에서 (7,3)으로 이동하는 것과 같이, 공간적으로 멀리 떨어져 있지만 연이은 Z-Order 값을 가진 큰 점프가 보이기도 합니다. 그럼에도 불구하고, Z-Ordering은 좋은 데이터 로컬리티 할당을 생성합니다.\n\n3. 힐버트 곡선 할당\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n세 번째 방법은 레코드마다 두 차원 x와 y 값에 기초한 일차원 값을 할당하기 위해 힐버트 곡선을 사용하는 것입니다.\n\n![image](/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_3.png)\n\n이 Python 라이브러리를 사용하여 두 차원 점에 대한 힐버트 곡선 값을 도출했습니다. 이는 Z-Order와 비슷한데, 서로 가까운 포인트들은 동일한 파일에 들어가게 되지만, 일차원 할당에서 멀리 떨어진 지점이 연속적으로 배치되는 급격한 점프가 없다는 추가적인 이점이 있습니다.\n\n이제 우리는 Z-Order와 힐버트 곡선과 같은 공간 채우기 곡선을 사용하여 파일에 포인트를 할당하는 방법에 대한 아이디어가 생겼으니, Databricks에서 Liquid Clustering을 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Liquid clustering in action\n\n이 섹션의 실험은 최소한이지만 대표적입니다. 필요한 설정은 다음과 같습니다:\n\n- Azure 무료 평가판 계정 및 무료 Databricks 계정\n- Liqud 클러스터링을 지원하는 최신 DBR인 DBR 13.3을 사용하는 단일 노드 Databricks 클러스터\n- 빠른 속도와 모자이크가 작동하기 위해 클러스터에서 photon을 활성화\n\n우리는 유명한 뉴욕시 택시 데이터 세트를 사용하고 아래 워크로드를 위해 최적화할 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 대부분의 쿼리는 데이터의 한 해 또는 몇 해에 대해서 작동할 것입니다.\n- 많은 쿼리는 픽업 위치(위도 및 경도)를 기반으로 필터링하는 것이 포함될 것입니다.\n\nDatabricks 워크스페이스에 파이썬 노트북을 만들고 샌드박스 데이터베이스를 생성하는 방법을 시작해보세요.\n\n```js\n%sql\nCREATE DATABASE liquid_db;\n```\n\n다음으로, 맨해튼 섬 주변의 경계 상자를 기준으로 뉴욕시 택시 데이터셋을 기반으로 하는 테이블을 생성해보세요. 이 글의 몇 가지 미학적 이유로 테이블은 초기에 액체 클러스터링을 사용할 수 있지만, 모든 작업이 기본적으로 데이터를 클러스터링하는 것은 아님을 인식하셔야 합니다. 예를 들어, 데이터가 MERGE 작업으로 변경되면, 데이터를 클러스터링하기 위해 OPTIMIZE 작업을 실행해야 할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```sql\nCREATE TABLE liquid_db.trips\n    CLUSTER BY (pickup_datetime, pickup_latitude, pickup_longitude)\nAS\nSELECT *\nFROM delta.`dbfs:/databricks-datasets/nyctaxi/tables/nyctaxi_yellow`\nWHERE\n    pickup_longitude between -74.05186503267184 and -73.83200446816883 AND\n    pickup_latitude between 40.69286486137213 and 40.91947608519337\n```\n\n클러스터링 열 목록에서 첫 번째 열은 타임스탬프 열인 픽업 일시임을 주목해주세요. 우리는 하이브 스타일의 파티셔닝을 사용하기 위해 명시적으로 연도 열을 생성할 필요가 없습니다.\n\n나중에 특정 Delta Lake 트랜잭션에서 생성된 파일이 클러스터링되었는지 여부를 감지하는 방법을 보여줄 텐데요, 제 경우에는 파일이 액체 클러스터링되지 않았기 때문에 직접 클러스터링해야 했습니다.\n\n```sql\nOPTIMIZE liquid_db.trips\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n델타 레이크 Z-오더링과 달리, 리퀴드 클러스터링을 사용하여 테이블을 최적화할 때, 파일이 최적화되었는지 여부를 알려주는 트랜잭션 로그 메타데이터가 있습니다. 따라서 나중에 OPTIMIZE 명령을 실행하여 새로운 데이터를 클러스터링할 때 파일을 건너뛸 수 있습니다. 이러한 경우에 대해 더 많은 아이디어가 있지만, 핵심적인 차이점은 ADD 프로토콜 액션의 태그 부분에 LIQUID_METADATA_ID라는 새 메타데이터 항목이 있는 것입니다.\n\n```js\nimport pyspark.sql.functions as F\nsecond_log_file = \"dbfs:/user/hive/warehouse/liquid_db.db/trips/_delta_log/00000000000000000001.json\"\n(\n    spark.read\n    .json(second_log_file)\n    .where(\"add is not null\")\n    .select(\"add.size\", \"add.tags.*\")\n    .withColumn(\"size\", F.expr(\"cast(size/1024/1024 as int)\"))\n    .withColumnRenamed(\"size\", \"size_mb\")\n    .display()\n)\n```\n\n위 스니펫의 출력에서 제 경우 191개의 파일이 나오며 대부분의 크기는 100에서 300MB 범위에 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 OPTIMIZE 작업을 위해 트랜잭션 로그 엔트리 안에 수집된 최대 및 최소 메타데이터 값을 검토해 봅시다.\n\n```js\nimport pyspark.sql.functions as F\ndef load_stats_from_commit(commit_file):\n  df = spark.read.json(commit_file).where(\"add is not null\")\n  add_schema = \"\"\"\n  struct\n    \u003c\n      numRecords:long,\n      minValues: struct\u003cpickup_latitude: double,pickup_longitude: double, pickup_datetime: timestamp\u003e,\n      maxValues: struct\u003cpickup_latitude: double,pickup_longitude: double, pickup_datetime: timestamp\u003e\n    \u003e\n  \"\"\"\n\n  stats = (\n    df\n      .select(\"add.path\", \"add.size\",\n          F.from_json(\"add.stats\", add_schema).alias(\"stats\")\n      )\n      .selectExpr(\n        \"substring(path, 1, 10) as file\",\n        \"size\",\n        \"stats.minValues.pickup_datetime as min_pickup_datetime\",\n        \"stats.maxValues.pickup_datetime as max_pickup_datetime\",\n        \"stats.minValues.pickup_latitude as min_pickup_latitude\",\n        \"stats.maxValues.pickup_latitude as max_pickup_latitude\",\n        \"stats.minValues.pickup_longitude as min_pickup_longitude\",\n        \"stats.maxValues.pickup_longitude as max_pickup_longitude\"\n      )\n  )\n\n  stats = (\n    stats\n      .withColumn(\"rect\", F.expr(\n        \"\"\"\n          concat('POLYGON ((' ,\n            min_pickup_longitude, ' ', min_pickup_latitude, ',' ,\n            max_pickup_longitude, ' ', min_pickup_latitude, ',' ,\n            max_pickup_longitude, ' ', max_pickup_latitude, ',' ,\n            min_pickup_longitude, ' ', max_pickup_latitude, ',' ,\n            min_pickup_longitude, ' ', min_pickup_latitude,\n          '))'\n          )\n      \"\"\"))\n  )\n\n  return stats\n\nstats = load_stats_from_commit(second_log_file).orderBy(\"min_pickup_datetime\", \"max_pickup_datetime\")\nstats.display()\n```\n\n위의 \"난해한\" 코드 스니펫은 몇 가지 작업을 수행합니다:\n\n- 픽업 시간, 위도 및 경도에 대한 최소 및 최대 값 수집\n- 가독성 목적을 위해 파일 이름의 처음 10자를 고유 식별기로 사용\n- 파일 내의 모든 여행을 포함하는 경계 상자의 GeoJSON 표현 생성 (픽업 위치에 따라)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상단의 표 출력물은 특별히 흥미로운 것은 아니며, 파일이 클러스터링 열에 따라 어떻게 배치되었는지 쉽게 전달하지 않습니다. 그러나 이를 어떤 종류의 간트 차트로 시각화한다면, 파일이 시간별 범위를 포함하는 그룹으로 클러스터링되었음이 명백해질 것입니다. 파일 중첩이 발생할 수 있지만, 일반적인 주제는 시간 범위를 기반으로 한 클러스터링을 보여줍니다.\n\n```js\nimport plotly.express as px\nfig = px.timeline(stats.toPandas(),\n    x_start=\"min_pickup_datetime\",\n    x_end=\"max_pickup_datetime\",\n    y=\"file\")\nfig.update_yaxes(categoryorder=\"min ascending\")\nfig.show()\n```\n\n\u003cimg src=\"/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_5.png\" /\u003e\n\nJan 2009부터 April 2010까지의 파일을 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfile_group = (\n  stats\n    .where(\"\"\"\n    min_pickup_datetime \u003e= '2009-01-01' AND\n    max_pickup_datetime \u003c= '2010-04-30'\n    \"\"\"\n    )\n)\nfile_group.count()\n# 29개의 파일이 인쇄됩니다.\n```\n\n해당 Date Range를 공유하는 이 파일들이 커버하는 지리 공간 영역을 시각화하고 싶습니다.\n\n```js\n%pip install databricks-mosaic==0.4.0\n```\n\n```js\nimport mosaic as mos\nspark.conf.set(\"spark.databricks.labs.mosaic.index.system\", \"H3\")\nmos.enable_mosaic(spark, dbutils)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n%%mosaic_kepler\nfile_group \"rect\" \"geometry\"\n\n![Image](/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_6.png)\n\n동일한 파일 그룹에 대해 특정 날짜 범위를 포괄하는 파일들의 경우, 해당 파일들의 레코드는 잔여 클러스터링 키인 위도 및 경도를 기반으로 클러스터링됩니다. 이러한 공간 클러스터링을 통해 지구상의 특정 지점을 커버하는 파일 수가 현저히 줄어들어 파일 가지치기가 크게 향상됩니다.\n\n# 가지치기 혜택\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같은 쿼리를 실행하면 194개 파일 중 126개 파일을 제거합니다 (첫 번째 커밋에서 최적화되지 않은 파일이 3개 발생했습니다).\n\n```js\nSELECT payment_type, sum(total_amount) as total_amount\nFROM liquid_db.trips\nWHERE pickup_datetime \u003e= '2011-01-01' AND pickup_datetime \u003c '2012-01-01'\nGROUP BY payment_type\n```\n\n![이미지](/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_7.png)\n\n위의 쿼리는 8년 데이터 중 1년치의 집계 결과입니다. 순수 Hive 파티셔닝이면 더 좋은 프루닝이 가능할 수도 있지만, 여전히 집계 쿼리에 대한 일정한 값은 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 같은 해를 사용하지만 타임스 스퀘어 근처의 몇 가지 특정 레코드를 찾아보려 한다면, 더 나은 가지치기를 할 수 있어요.\n\n```js\nSELECT *\nFROM liquid_db.trips\nWHERE pickup_datetime \u003e= '2011-01-01' AND pickup_datetime \u003c '2012-01-01'\nAND pickup_latitude BETWEEN 40.757816 AND 40.757832\nAND pickup_longitude BETWEEN -73.985143 AND -73.985105\n```\n\n![이미지](/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_8.png)\n\n특정 워크로드에 유용한지 확인하기 위해 철저한 테스트와 벤치마킹이 필요하지만, 전반적으로 Delta Lake 테이블의 관리를 간편하게 해주는 Liquid 클러스터링은 매우 유망해 보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리\n\n리퀴드 클러스터링을 사용할 때 고려해야 할 측면이 많으며 특정 사용 사례에 맞는 동작을 조정하기 위해 많은 구성 값을 조정해야 할 것입니다. 본 게시물은 리퀴드 클러스터링이 어떻게 작동하는지를 높은 수준에서 시각적으로 보여주는 작은 시도입니다. 단순화된 사용 사례는 Hive 스타일의 파티셔닝과 Z-Order의 혜택을 결합하여 단일 최적화 방법을 사용하는 것입니다.\n\nliquid_db를 삭제하고 정리하려면 DROP DATABASE liquid_db CASCADE를 실행하는 것을 잊지 마십시오.\n\n# 추가 읽을거리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 델타 테이블에 리퀴드 클러스터링 사용하기\n- [디자인 문서] [공개] 리퀴드 클러스터링 — Google Docs\n- 힐버트 곡선 코딩 (youtube.com)\n- Yousry Mohamed의 미디엄에서 A부터 Z까지의 델타 레이크 Z-오더링\n","ogImage":{"url":"/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_0.png"},"coverImage":"/assets/img/2024-05-18-DeltaLakeLiquidClusteringAvisualexplanation_0.png","tag":["Tech"],"readingTime":15},{"title":"Lakeview 대시보드를 통한 관측력 시리즈 - 기사 1 DBSQL 웨어하우스 어드바이저","description":"","date":"2024-05-18 16:24","slug":"2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor","content":"\n표 태그를 Markdown 형식으로 변경해보세요.\n\n![Lakeview Dashboard](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_0.png)\n\n## 저자:\n\nCody Austin Davis\n\n# Lakeview 대시보드 템플릿 시리즈 - 기사 1 - DBSQL Warehouse Advisor\n\n## 소개\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLakeview 대시보드는 Databricks SQL에서 사용할 수 있는 새로운 가벼운 대시보드 도구입니다. 막 출시했음에도 불구하고 이미 놀라운 성능을 자랑하는데요. 추가 비용이나 관리 부담 없이 빠르게 대시보드를 개발하고 공유할 수 있는 기능을 제공합니다. 예를 들어, 대부분의 고객이 필요로 하는 가장 중요한 측면 중 하나는 데이터 플랫폼의 가시성입니다. 대부분의 고객이 특정 사용 사례에 대한 모니터링과 가시성을 필요로 하기 때문에 나는 Lakeview 템플릿 중 일부를 공개하여 누구나 가져다 쓰고 자신의 환경에서 사용할 수 있도록 했어요. 여러분의 노력을 아낄 수 있게끔 도와주고 Lakeview 대시보드가 무엇을 할 수 있는지 보여줄 수 있도록 했죠!\n\n이 기사에서는 DBSQL Warehouse Advisor 템플릿을 공유하고 소개할 거에요. 대시보드의 4개 섹션에 대해 간단히 검토하고 사용하는 방법을 가르쳐 드리며 각 섹션을 통해 어떤 핵심 질문을 해결할 수 있는지 논의할 거에요.\n\n먼저, 전반적으로, 이 대시보드가 무엇을 하는지와 어떤 부분에 초점을 맞추는지에 대해 알아볼까요. 공유될 여러 템플릿 중 첫 번째로, 템플릿을 언제, 어떻게 사용할지에 대한 맥락을 제시하고자 합니다.\n\nDBSQL Warehouse Advisor Lakeview 대시보드는 DBSQL에서 데이터 웨어하우스에 대해 필요한 모든 정보를 제공합니다. warehouse_events, billing, 그리고 query_history (system table의 프라이빗 프리뷰, API는 이미 GA에서 사용 가능) 시스템 테이블을 자동으로 구문 분석하여 다음과 같은 작업을 지원합니다:\n\n- 섹션 1 — 요금 모니터 — 시스템 내의 billing.usage 시스템 테이블을 모니터링하여 시간별 비용을 요약합니다. 웨어하우스가 너무 빨리 확장되는 시점을 보여주는 내장된 탄력 지표를 제공합니다. BI 워크로드는 특히 변동이 심할 수 있으므로, 부드러운 탄력 지표는 비용 경보에 대한 더 나은 측정 항목을 제공할 수 있습니다. 이 쿼리를 사용하여 경보를 설정할 수 있습니다!\n- 섹션 2 — 크기 조정 모니터 — warehouse_events 시스템 테이블을 모니터링하여 웨어하우스의 크기 조정 비용과 효율성을 요약합니다. 변동이 심하고 고 동시성 워크로드의 사용량을 예측하고 추정하기 어려울 수 있습니다. 이 시각화를 사용하면 웨어하우스가 다른 크기 조정 수준에서 얼마나 시간을 보냈는지 요약하고 계획하기 쉬워집니다.\n- 섹션 3 — 쿼리 성능 분석 — 이것은 매우 중요한 섹션입니다! (private preview 중인) query_history 시스템 테이블을 사용하여 웨어하우스의 전반적인 성능을 요약하고 문제가 되는 쿼리를 찾거나 병목 현상을 식별하며 SLAs를 추적하고 웨어하우스 시간이 어디에 소비되었는지 파악할 수 있습니다. 이 대시보드 하나에 고수준 모니터링부터 개별 쿼리 성능 튜닝까지 모두 담겨 있어요.\n- 섹션 4 — 쿼리 비용/시간 할당 요약 — 웨어하우스를 사용하여 내부 또는 외부 고객에게 서비스를 제공하고, 소비 기반의 가격 모델에 따라 그들에게 요금을 청구해야 한다면, 이 섹션을 사용하여 쿼리, 사용자 및 쿼리 태그 수준에서 웨어하우스 시간을 할당할 수 있습니다! 데이터 제품 및 많은 하위 팀에 서비스를 제공하는 중앙화된 데이터팀에게 매우 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요약을 보여줬으니 이제 섹션을 살펴보겠습니다. 함께 따라오고 싶다면 템플릿을 다운로드하고 대시보드를 환경에 가져와서 데이터웨어하우스 ID를 입력하면 됩니다!\\* 템플릿을 가져오면 전체 대시보드 시각화와 대시보드를 구동하는 전체 백엔드 쿼리와 매개변수를 확인할 수 있습니다. 이 템플릿은 여러분의 특정한 사용 사례에 맞게 필요한 대로 수정하고 확장할 수 있습니다.\n\n- \\*참고: query_history를 위한 시스템 테이블 비공개 미리보기 상태에 있지 않은 경우, query history API를 사용하여 공개 미리보기가 될 때까지 해당 테이블을 생성할 수도 있습니다.\n\n# 섹션 1 — 요금 모니터\n\n![이미지](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 DBSQL Warehouse Advisor의 청구 모니터입니다. 이 섹션은 간단합니다. Warehouse Id를 매개 변수에 입력하고 날짜 범위를 선택하여 DBUs 및 달러의 추이를 시간에 따라 볼 수 있습니다. 또한 해당 시간 프레임 내의 총 비용에 대한 큰 숫자 요약도 제공됩니다. 또한 DBSQL Warehouse의 목록 요금과 다른 경우에 사용할 클러스터 단위 가격 매개 변수도 있습니다.\n\n또한 시간에 맞춰 부드럽게 조정된 사용량의 추세를 추적할 수도 있어, 일시적인 사용량 변동에 과도하게 반응하는 것을 피할 수 있습니다. 고동시 BI 워크로드에서 일반적인 것으로, 관리자들은 종종 주어진 시간 범위 내에서 사용량이 특정 %로 상승하는 추세를 지켜보고 경보를 울리고 싶어 합니다. 이 운동량 지표 시각화를 사용하여 이를 수행할 수 있습니다:\n\n![이미지](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_2.png)\n\n이것은 앞서 소개한 \"높은 증가 % 장벽\" 매개 변수와 결합됨으로써, 사용 패턴을 \"높은 사용 증가 추세\"로 판단하고 그것을 강조하여 빨간색으로 표시하는 임계값을 정의할 수 있습니다. 그런 다음 최근 값 쿼리에 LIMIT 1을 추가하여 비용 추세에 대한 경보를 설정하는 데 사용할 수 있는 정확한 기본 SQL 쿼리를 사용할 수 있습니다. 이 지표 차트는 \"이전 기간보다 24시간 이동평균 증가량이 20% 이상 증가할 때 보여줘\"라고 말합니다. 이는 이 기능이 종종 발생하는 일시적인 변동보다 지속적이고 심각한 비용 증가에 대한 경보를 보내는 데 좋은 방법입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 섹션 2 — 데이터웨어하우스 동시성 스케일링 요약\n\n다음 섹션에서는 데이터웨어하우스 동시 사용량을 해석하는 데 도움이 되며, DBSQL의 \"모니터링\" 탭에있는 차트는 매우 가파르고 계획하기 어려울 수 있습니다. 특히 Serverless SQL을 사용할 때는 이 차트를 사용하기 어려울 수 있습니다...\n\n![이미지](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_3.png)\n\n...그리고 이를 예산 및 장기적인 워크로드 / 데이터웨어하우스 비용에 대한 기대로 전환하기 어렵습니다. 더구나, 클러스터 크기, 동시성 설정, 쿼리 성능 변경 시 어떤 일이 발생하는지 확인하기 어렵습니다. 이 탭을 사용하면 더 명확한 예측과 사용량에 대한 기대를 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Dashboard](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_4.png)\n\n이 대시보드는 해석이 어려운 모니터링 탭을 자동으로 가져와 시각화로 변환하여 창고에서 N개의 동시 클러스터로 확장해야 하는 빈도를 더 명확하게 보여줍니다. 좀 더 자세히 살펴보면, 특정 시간 기간 동안 창고가 N개 클러스터로 확장되기까지 소요된 시간 및 총 시간 중 % 비율을 정확하게 볼 수 있습니다.\n\n우리는 창고가 대략 80%의 시간 동안 1개 클러스터가 필요하고, 13%의 시간 동안 2개 클러스터가 필요하며, 대략 7%의 시간 동안 3개 클러스터, 그리고 1%의 시간 동안 4개 클러스터가 필요함을 명확히 볼 수 있습니다. 이를 통해 예측이 어려운 이러한 고비용 워크로드를 시간이 지남에 따라 얼마나 비용이 발생할지 예측하는데 도움이 되는 것은 물론, 이에 대한 변경 사항에 대해 계획하는 것도 더 쉽게 할 수 있습니다. 이 정보는 DBSQL의 어떠한 프로덕션 워크로드에 대비한 계획을 세우는 데 중요합니다.\n\n워크로드를 최적화하거나 POC를 실행하거나 사용 사례를 추가할 경우, 이 대시보드를 사용하여 사용 패턴에 미치는 영향을 정확히 파악하여 미리 계획할 수 있습니다. 이 부분은 작지만 굉장히 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 섹션 3 — 쿼리 성능 분석\n\n이 섹션은 가장 크며, 고수준 성능 메트릭부터 실행 시간, 디스크 스피릴, 데이터 읽기 등의 쿼리 수준 세부 사항까지 모두 담고 있습니다. 이 섹션의 세부 사항은 전적으로 별도의 블로그를 작성할 수 있을 정도로 방대하므로, 이 글에서는 포함된 고수준 메트릭 및 이 섹션을 사용할 때 일반적으로 고려할 수 있는 몇 가지 이유에 초점을 맞출 것입니다.\n\n이 섹션에서는 주로 쿼리 실행 시간과 대기 시간에 관심이 있습니다. 먼저 이러한 메트릭을 매우 고수준으로 하나의 큰 숫자 요약으로 살펴보고, 이후에는 SLA 차트와 함께 추세를 자세히 살펴볼 것입니다:\n\n![LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_5](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Lakeview Dashboards for Observability Series Article](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_6.png)\n\n![Lakeview Dashboards for Observability Series Article](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_7.png)\n\n쿼리 실행 시간 및 대기 시간 추이를 확인할 수 있습니다. 이제 데이터 웨어하우스가 언제 더 혼잡하거나 덜 혼잡해지는 지 쉽게 파악할 수 있어 문제를 빠르게 찾을 수 있게 되었습니다. 그러나 실제 워크로드에 대한 평균 실행 시간만 살펴본다고 해결되지 않습니다. 실제 SLA에 따라 쿼리 시간을 추적해야하며, 이를 위해 P90, P95 및 P99와 같은 표준 지표를 더 계산해야 합니다. 이 대시보드는 이러한 지표를 자동으로 계산하고 표시합니다. 위 시각적 자료를 통해 쿼리 실행 시간을 추적하여 쿼리 성능 문제가 발생하는 정확한 시기를 찾을 수 있습니다(중간에 큰 증가를 보았나요? 아마 확인해야할 이상 현상일 것입니다). 웨어하우스가 포화 상태에 있는지 추적하기 위해 동일한 방법으로 쿼리 대기 시간도 살펴볼 수 있고, 웨어하우스가 더 많은 동시성을 필요로 할 수도 있습니다. 실제로 여러분은 이 둘을 결합하여 사용 사례의 SLA 요구 사항에 맞게 클러스터 크기를 조절해야 합니다.\n\n예를 들어, Databricks SQL로 구동되는 Downstream 데이터 애플리케이션이 있다고 가정해보겠습니다. 사용자들은 앱이 대부분의 쿼리를 1~2초 이내 또는 그 이하로 수행할 것으로 예상하며, 10초 이상 걸리는 것은 용인할 수 없습니다. 쿼리 실행 시간 차트의 P99 및 P95 백분위 지표를 확인하여 SLA 준수를 먼저 확인할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_8.png)\n\n우리는 SLA 준수에 대해 멋져 보입니다. 대부분의 쿼리 (P95)가 1초 미만으로 실행됩니다. 우리의 가장 나쁜 쿼리도 약 5초 정도로 우리의 최종 사용자가 허용할 범위 내에 있습니다. 이러한 숫자가 허용 가능한 수준을 초과하면 쿼리를 최적화하거나 창고가 포화되었는지 대기 시간 시각화를 확인할 수 있습니다:\n\n![image](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_9.png)\n\n이제 필요한 SLA 범위 내에 있습니다. 그러나 만약 우리의 P99가 3초였다면 어떨까요? 그럴 경우 문제가 생길 수 있습니다. 먼저 할 일은 위의 대시보드에서 쿼리 대기 시간을 살펴보는 것입니다. 대기 시간은 각 쿼리가 실행할 수 있는 슬롯을 기다리며 대기하는 시간입니다. SLA를 준수할 때는 대기가 괜찮지만 그렇지 않은 경우, 소중한 시간이 낭비되고 더 많은 동시성이 필요합니다! 이 시각화는 평균 쿼리 실행 시간과는 다르게 해석되며, 보통 대기 시간이 낮아야 합니다(~0초). 1초보다 훨씬 높아지면 쿼리가 쌓여서 대기열에 앉아있기 시작한다는 것을 의미하며, 이는 우리의 SLA에 영향을 미칩니다. 갱신된 3초 SLA를 고려한 우리 예시에서, 우리의 P99는 현재 5초이며, 이는 허용할 수 없는 수준입니다. 위 시각화에서 많은 쿼리가 거의 2초씩 대기한다는 것을 볼 수 있습니다! 동시 용량을 늘리는 것이 SLA에 더 가까워지는 데 도움이 될 수 있음을 보여줍니다 (DBSQL의 최소 최대 클러스터).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**기억하세요 — 원하는 SLA에서 시작해서 거꾸로 진행하세요.**\n\n고수준 성능 지표 외에도 이 대시보드에는 많은 유용한 지표가 있습니다!\n\n![대시보드 이미지](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_10.png)\n\n우리는 쿼리 성능을 상태, 소스 및 문장 유형별로 시간에 따라 추세 분석할 수 있고, 심지어 쿼리 태그별 평균 쿼리 실행 시간도 모니터링할 수 있습니다. 대시보드에 내장된 기능이며, 다음 서명을 가진 템플릿된 코멘트를 찾습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n회사의 특정 사용 사례에 중점을 두어 전체 성능 분석에 도움을 줄 수 있습니다. 특히 ETL 워크로드에서 중요합니다.\n\n더욱 심층적으로 파고들 수 있습니다. \"쿼리 성능 상세\" 하위 섹션으로 이동하여 쿼리에서 발생하는 일반적인 문제와 병목 현상을 식별할 수 있습니다. 대시보드에서는 자동으로 플래그를 계산하여 장기 실행 중인 쿼리, 스피룰이 발생한 쿼리, 그리고 이례적으로 높은 데이터 양을 읽는 쿼리를 식별하는 데 도움이 됩니다.\n\n![image](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래로 내려가면 각 쿼리당 할당된 비용을 계산하고, 쿼리 태그별로 그룹화할 수 있습니다 (기본적으로 위에서 정의되었지만, 필요에 맞게 이 템플릿을 변경할 수 있습니다!). 또한 성능 문제의 근본 원인을 확인하기 위해 쿼리 수준의 세부 정보를 전체 출력할 수도 있습니다. 대시보드에서는 사용자별 할당된 창고 비용, 사용자별 계산 사용량 % 및 사용자별 쿼리 수를 볼 수도 있습니다.\n\n![image](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_12.png)\n\n이것은 시작점으로서 제공되는 것일 뿐이므로, 여러분의 사용 사례에 맞추기 위해 이 대시보드를 가져오고, 탐색하고, 확장하는 데 자유롭게 사용하세요!\n\n# 섹션 4 — 쿼리 비용 할당 요약\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션은 외부 데이터 제품을 가진 고객이 자신들의 데이터 제품에 합리적인 가격 모델을 개발하기 위해 쿼리 수준의 비용 가시성을 원하는 경우에 대해 우리가 자주 받는 질문입니다.\n\n![이미지](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_13.png)\n\n이 차트에서는 이미 쿼리를 어떻게 할당할지에 대해 작업이 이미 진행되었습니다. 당신은 warehouse_id를 정의하고 쿼리 범위를 선택하며 보고 싶은 \"파레토 지점\"을 정의할 수 있습니다. 이것은 당신에게 당신의 데이터 웨어하우스 전체 계산 시간의 상위 X%를 구성하는 쿼리들을 볼 수 있도록 합니다. 예를 들어, 위의 시각화는 SQL 쿼리가 이 시간대에 웨어하우스 계산 시간의 약 20%를 차지한 것을 보여줍니다. 파레토 분석을 통해 당신은 당신의 웨어하우스 활용도의 가장 큰 부분을 차지하는 쿼리들을 살펴볼 수 있으며, 작고 차이점이 없는 \"long tail\" 쿼리들을 걸러낼 수 있습니다.\n\n요약 뿐만 아니라 대시보드에는 데이터 제품에 대해 세부적인 쿼리 수준 리포트가 포함되어 있어, 당신의 데이터 제품에 대한 세부적인 가격 책정을 할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_14.png\" /\u003e\n\n이 보고서에서는 시간이 어디에 사용되는지 쉽게 확인할 수 있으며, 심지어 엔드 유저와 태그별로도 분석할 수 있습니다! 사용자 실행 분석은 이 쿼리를 실행하는 각 사용자의 실행 횟수와 오류율을 제공합니다. 이 정보는 워크로드에 대한 매우 투명한 비용 할당을 갖도록 필요한 모든 세부 정보를 제공합니다.\n\n주의해야 할 중요한 몇 가지 정의가 있습니다:\n\n데이터 웨어하우스 실행 시간 = 시간 창 동안의 모든 쿼리 실행의 총 실행 시간\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿼리 할당 비용 = 쿼리 실행 시간 / 데이터베이스 실행 시간\n\n# DBSQL Warehouse Advisor — DBT Version\n\nDBSQL Advisor 템플릿 외에도, DBT 데이터베이스에서 DBSQL로 푸시된 쿼리의 DBT 메타데이터를 이해하는 DBT 버전도 있습니다. 이를 통해 사용자들은 DBT 모델 및 개별 노드 ID에 대한 추가 정보를 즉시 얻을 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_15.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 쿼리 분석의 섹션 3과 4에서는 dbt 대상, 프로필 이름 또는 노드 ID와 같은 친숙한 메타데이터로 성능 및 쿼리 할당 지표를 분석할 수 있습니다. 이를 통해 DBT 모델에 대한 리소스가 정확히 어디에 사용되고 있는지 확인할 수 있습니다.\n\n![이미지1](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_16.png)\n\n![이미지2](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_17.png)\n\n![이미지3](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_18.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 대시보드를 사용하면 DBSQL의 Lakeview와 함께 DBT 파이프라인을 이해하고 모니터링하는 데 상당히 도움을 받을 수 있습니다! 내부 분석부터 완전한 데이터 제품 제작까지, 데이터 플랫폼에 대한 완전한 제어 및 시각성을 갖게 됩니다.\n\n# 다음 단계\n\n이 시리즈에서 제공하는 4가지 대시보드 템플릿 중 첫 번째로, 데이터브릭스 사용자들이 시스템 테이블과 Lakeview 대시보드를 통해 일반적이고 강력한 사용 사례에 대해 최대한 활용할 수 있도록 지원하는 것이 목표입니다. 우리가 제공하는 탁월한 기능 뿐만 아니라, 이러한 템플릿은 훌륭한 참조 자료가 되어 앞으로 구축하려는 대시보드에 흥미로운 디자인 패턴으로 사용될 수 있습니다!\n\n대시보드를 지원하는 SQL 논리 및 시각/매개변수 선택의 원천에 대해 깊이 파고들어 설명을 듣고 싶다면, 의견을 남겨주시면 감사하겠습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Lakeview Templates:\n\n- DBSQL Warehouse Advisor\n- DBT Version — DBSQL Warehouse Advisor\n\n## 사용 방법:\n\n- 위 링크에서 JSON 파일을 다운로드합니다.\n- 데이터브릭 워크스페이스의 “대시보드” 탭으로 이동합니다.\n- 오른쪽 상단 모서리에 있는 파란색 “대시보드 만들기” 버튼 옆의 화살표를 클릭합니다.\n- “파일에서 대시보드 가져오기”를 선택하고 다운로드한 JSON 템플릿을 업로드합니다.\n- 대시보드를 로드하고 사용 중인 데이터 웨어하우스 ID를 입력합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_19.png)\n","ogImage":{"url":"/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_0.png"},"coverImage":"/assets/img/2024-05-18-LakeviewDashboardsforObservabilitySeriesArticle1DBSQLWarehouseAdvisor_0.png","tag":["Tech"],"readingTime":16},{"title":"클라우드 비용 최적화 핀옵스 마인드셋 수용하기","description":"","date":"2024-05-18 16:21","slug":"2024-05-18-OptimizingCostsintheCloudEmbracingaFinOpsMindset","content":"\n![image](/assets/img/2024-05-18-OptimizingCostsintheCloudEmbracingaFinOpsMindset_0.png)\n\n서버리스 서비스를 설계할 때, 퍼즐의 각 조각, 선택하는 각 관리 서비스는 구매 선택입니다. 게다가 프로덕션 급 클라우드 서비스가 추가 비용을 야기하며, 주의를 기울이지 않으면 비용이 빠르게 증가할 수 있습니다.\n\n이 블로그에서는 아낌없는 조직이 FinOps 마인드셋에 기대어 클라우드 서비스의 비용을 최적화하고 효율을 극대화하는 데 중요한 역할을 하는 방법을 배우게 될 것입니다. 클라우드에서 재무와 운영 목표를 조율하는 데 필수적인 전략과 실행 항목을 공유할 것입니다.\n\n서버리스 서비스를 예로 들며, 클라우드 서비스 및 선택한 기술에 도움이 되는 통찰력, 자동화, 문화에 대해 설명할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 통찰은 저의 경험에 근거하여 CyberArk에서 AWS 기반 SaaS 제공 업체의 서버리스 서비스를 설계한 것에 기인합니다.\n\n![이미지](/assets/img/2024-05-18-OptimizingCostsintheCloudEmbracingaFinOpsMindset_1.png)\n\n이 블로그 게시물은 원래 \"Ran The Builder\" 웹사이트에 게시되었습니다.\n\n# 서버리스 비용에 대한 오해\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS 서버리스 히어로로서, 클라우드 비용과 서버리스 서비스에 대해 이야기할 때 놓치지 말아야 할 부분을 다루고 싶어요.\n\n서버리스는 사용한 만큼만 지불하고 0으로 스케일링이 가능하다는 것으로 알려져 있죠.\n\n만약 그게 사실이라면, 생산급 서버리스 서비스 비용이 비서버리스 서비스보다 낮을 거라고 생각할 수 있겠죠?\n\n음, 그건 가끔 정확한 말이에요. 확실히 Lambda, SNS, SQS, DynamoDB와 같은 \"참\" 서버리스 서비스에 대해서는 사실이지만, 서버리스에는 더 많은 서비스가 포함되어 있고, 매년 새로운 AWS 서버리스 서비스가 등장하고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, DynamoDB가 더 이상 요구 사항과 일치하지 않는 것을 깨달을 수도 있습니다. Amazon Aurora 서버리스를 사용하거나 Elasticache 서버리스를 혼합해 캐시를 추가하거나 OpenSearch 서버리스로 키워드 검색을 최적화할 수도 있습니다. 이러한 서비스들은 서버리스 변형이 있지만 영구로 스케일되지 않습니다. 고객 트래픽이 없더라도 최소 요금을 지불해야 합니다. 따라서 아마도 이러한 서비스들을 AWS가 관리하지만 진정한 서버리스 서비스는 아닌 것으로 부르는 것이 가장 좋을 수 있습니다. 또한, 이러한 서비스들은 VPC가 필요하며, ENI, VPC 엔드포인트 등으로 매월 고정 비용이 추가됩니다.\n\n그리고 Jeremy Daly는 Allen Helton의 훌륭한 팟캐스트에서 AWS의 최신 서비스들의 서버리스 또는 서버리스가 아닌 특성에 대해 논의했는데, 권해드립니다.\n\n# 프로덕션 등급은 추가 비용이 발생합니다.\n\n클라우드 서비스를 위해 선택한 기술에 관계없이 언젠가는 프로덕션을 준비해야 합니다. 규정, 보안 및 관측 요구 사항을 해결해야 하며, 이는 추가되는 과소 평가된 비용을 야기합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 사전 제품 서비스에 이러한 기능 몇 가지를 추가해 보는 건 어떨까요?\n\n우리는 서비스에 고객 데이터 암호화 기능을 추가해야 합니다. 우리는 KMS CMK를 사용하여 고객 데이터를 암호화하거나 서비스 간 통신을 용이하게 할 수 있습니다. CMK는 API 호출을 포함하지 않고 제공만 되어도 매달 1달러가 들고, 키 자동 회전을 활성화하면 추가 1달러가 소비됩니다. 10000명의 고객이 있을 것으로 예상하시나요? 멋져요, 당신의 AWS 청구서에 매달 추가로 20000달러가 더해집니다.\n\n프로덕션 준비 관행으로 넘어가 봅시다. 웹 보안과 관찰성을 더해봅시다.\n\nAPI Gateway나 CloudFront 분산에 웹 어플리케이션 방화벽을 활성화하고 CloudWatch 대시보드를 통해 관찰성을 향상시킬 수 있습니다. 이러한 리소스들은 매달 지속적인 가격이 부여되며, 서비스가 매달 트래픽을 전혀 받지 않더라도 이용료가 부과됩니다. 이와 유사한 사례들이 많이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스를 제품으로 제작할 때 수많은 작은 비용이 쌓입니다. 사람들은 이를 인식해야 합니다. 그럼에도, 그저 다른 CMK일 뿐이죠; AWS CDK에서 생성하는 한 줄 뿐이니까; 해로운 점이 뭐가 있을까요?\n\n여러 개의 계정을 사용한다면(당신이 해야 하는 대로) - 개발, 테스트, 제품 용으로 - 모든 비용 추가는 보유한 계정 수에 곱해질 수 있습니다. 한 계정당 5개의 지역에 배포하나요? 그럼 추가적으로 15(5\\*3 - 계정 수)개의 CMK가 생깁니다. 다시 한 번 곱하세요.\n\n이러한 비용은 개발 계정에서 특히 크게 누적됩니다. 자원이 배포되고 삭제되며 종종 콘솔을 통해 수동으로 생성해서 잊혀지기 쉽기 때문입니다. 하지만 AWS는 그 기록을 기억하고 당신은 달이 끝날 때 청구서를 받을 것입니다.\n\n## 고객이 다가온다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 대부분의 분들에게는 분명한 사실일 것이지만, 고객을 많이 모은다면 규모, API 호출 횟수, 그리고 저장 데이터 양이 커질 것입니다. 이 모든 것이 AWS 클라우드 요금 증대로 이어집니다. 이러한 추가 비용을 계획하고 수익 모델에 반영하지 않으면 비즈니스가 유지될 수 없습니다.\n\n요점은 프로덕션급 서버리스나 서버리스가 빠르게 증가할 수 있는 추가 고정 비용이 있다는 것입니다. 여러 비트와 바이트에 대해 지불해야 하며 처음부터 이를 인식해야 합니다. 예상 고객 트래픽 규모를 위한 예산을 설정하고 이를 지속적으로 모니터링하여 비용이 억제되도록 해야 합니다.\n\n이제 문제를 이해했으니 당신의 조직이 이 문제를 대처하고 비용을 줄이며 효율성을 향상시킬 수 있는 방법에 대해 이야기해 봅시다. 그것은 FinOps 마인드셋을 채택함으로써 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFinOps를 채택하고 비용을 인식하는 것은 조직의 C급 임원에게 중요합니다. 그러나 위에서 논의한 대로, 모든 설계 선택, 모든 CloudFormation 스택 배포, 모든 IT/DevOps 예약 작업 실행은 구매 선택입니다.\n\n귀하의 팀은 매일 AWS 계정에서 돈을 소비합니다.\n\n조직의 사고방식을 비용 인식적으로 바꾸고 싶다면, 그것은 아래부터 시작되어야 합니다. 아키텍트와 팀 리더가 선도할 수 있지만, 아래에 있는 병력들은 따라와서 목표를 이해해야 합니다. 개발자들이 다양한 리소스를 배포하는 것을 막는 자동화를 추가할 수 있지만, 장기적으로 이는 개발팀의 독립성을 방해하고 확장되지 않을 것입니다. 사람들은 FinOps 사고방식을 받아들이고, 이해하며, 개발의 모든 단계에서 클라우드 비용에 대해 생각해야 합니다.\n\n다음 섹션에서는 귀사에서 구현할 수 있는 구체적인 조치 항목을 설명하겠습니다. 아키텍트부터 DevOps, IT, 개발자까지 페르소나는 다를 수 있지만, 아이디어는 같습니다: AWS 비용을 줄이기 위해서는 한 마을이 필요하며, 모두가 함께해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 비용 고려한 디자인\n\n클라우드 아키텍트로써, 우리는 조직에서 전체 AWS 비용에 가장 큰 영향을 미치는 몇 안 되는 사용자 중 하나입니다.\n\n지난 AWS re:Invent에서 Vogels는 \"절약하는 아키텍트\" 가이드라인을 논의했는데, 이는 제 블로그 게시물 \"클라우드 아키텍트의 고수준 디자인 템플릿\"과 관련이 있습니다.\n\n그의 세션에서 주요 포인트는 모든 클라우드 아키텍처 디자인 선택이 구매 선택과 관련이 있다는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n건축가로서, 우리는 서비스의 고수준 디자인 뿐만 아니라 저수준 디자인에도 영향을 미칩니다. 우리 회사에서는 개발자들이 제 동행과 함께 저수준 디자인과 컨셉 증명을 수행합니다. 따라서, 이른 시기에 비용을 고려하는 것이 중요합니다.\n\n서버리스 서비스를 설계할 때는 종종 여러 가능한 아키텍처가 있습니다. 예를 들어, SNS 또는 EventBridge를 사용하여 이벤트를 구독자에게 발행할 수 있습니다.\n\n최선의 결정을 내리기 위해, 양쪽 솔루션을 비교할 수 있는 의사 결정 매트릭스를 사용하고 예상 비용을 비기능적 요구 사항으로 고려하는 것을 권장합니다.\n\n이 프로세스에 대해 자세히 설명한 블로그 포스트는 Cloud Architect's High-Level Design Template에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고객 수 및 규모에 대한 예상을 고려하고 이러한 숫자를 AWS 요금 계산기에 입력하세요. 이후에 AWS 비용이 나중에 급증하고 손쉽게 대체할 수 없는 비용이 들어간 제품이 프로덕션 환경에 배포되었을 때 놀라지 마세요.\n\n하지만 여기서 끝이 아닙니다. 아키텍트로서 모든 것을 감시할 수는 없고, 개발자들은 기능을 구현할 때 가격 선택을 합니다. 예를 들어, 내부 대시보드용으로 사용자 정의 CloudWatch 메트릭을 추가하지만 차원을 너무 많이 사용하여 비용이 크게 증가하는 경우가 있다(실제 사례!). 팀이 비용을 종합적으로 고려해 독립적으로 이러한 선택을 할 수 있도록 하여, 상당히 중요합니다. 거의 모든 리소스 배포나 API 호출이 추가 클라우드 비용을 발생시킨다는 점을 이해해야 합니다.\n\n# FinOps 문화\n\n조직 전체의 팀이 클라우드 비용을 이해하고 활발히 줄이고 최적화할 수 있도록 하는 문화적 실천 방법을 검토해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 금융 오퍼레이션 챔피언\n\n먼저, 각팀 (개발자, IT, 데브옵스 등)에서 금융 오퍼레이션 챔피언을 뽑는 것이 좋습니다. 그들은 GitHub PR이 예상치 못한 비용 증가를 유발하지 않도록 확인하는 역할을 맡고 있습니다. 이 챔피언들은 설계 검토 중에 비용 우려 사항을 제기하고 팀이 비용을 염두에 두도록 도와줍니다.\n\n이상적으로, 금융 오퍼레이션 챔피언은 항상 클라우드 비용을 고려합니다. 설계, 구현 또는 프로덕션 배포 단계에서 모두 해당합니다.\n\n이 챔피언은 제가 아래에 설명할 '청구서 모니터링' 섹션에 적극적으로 참여할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## FinOps Guild\n\n두 번째 실천 방법은 부서 간 및 조직 간 지식 공유입니다. 한 팀이 새로운 Lambda에서 프로비저닝된 동시성의 비용을 줄이는 최상의 실천 방법을 발견했다고 가정해 봅시다. 한 팀이 그 문제를 해결한 것은 좋지만, 동일한 최상의 실천 방법이 조직 전체에 구현되는 것이 더 좋을 것입니다. 이를 위해 지식을 공유할 수 있는 메커니즘이 필요합니다.\n\n그런 메커니즘 중 하나는 모든 FinOps 챔피언들이 매월 한 번 지식을 공유하는 FinOps 길드를 시작하는 것일 수 있습니다.\n\n내부 조직 외부 사람들을 만나 IT, 데브옵스, 제품 등과의 새로운 관계를 형성하는 것도 추가 가치입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고로, 공급된 사전 할당량 및 차가운 시작에 대해 더 알고 싶다면 여기에 있는 내 게시물을 확인해보세요.\n\n## FinOps 내부 교육\n\n길드 회의는 정보를 공유하는 좋은 방법입니다. 그러나 더 작은 대상을 대상으로 하는 한계가 있어서 이전 회의의 최상의 실천법이 잊혀질 수 있으므로 귀하의 최상의 실천법을 문서화하는 것이 가장 좋습니다. 간단한 내부 문서부터 시작하거나 내부 비디오 강좌를 만들기 위해 노력해보세요. 강좌는 전문적으로 편집된 비디오일 필요는 없습니다. 팀/슬랙 회의 녹화일 수도 있습니다. 콘텐츠는 신규 FinOps 챔피언을 신속하게 승격시키고 비용 절감 관행을 확산시키기 위한 빠른 방법으로 기능해야 합니다.\n\n## FinOps 해커톤\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 재미있는 아이디어입니다. FinOps를 게임처럼 만들고 직원들이 개선, 자동화 및 기타 비용 절감 방법에 대한 아이디어를 제시할 수 있는 해커톤을 소개해 보세요. 이를 흥미롭게 만들기 위해 가장 영향력 있는 아이디어에 대한 상품을 제공해 보세요.\n\n## 성공을 축하하세요\n\n이 행동 항목은 모든 문화에 중요한 부분이므로 가장 중요할 수 있습니다. 누구나 회사 이익을 개선하는 일에 대한 피드백을 감사히 받을 것이며, 특히 그 작업이 회사 수익을 증가시킬 때 더욱 그렇습니다. 조직 전체에서 성공을 인정하는 것은 긍정적인 효과를 창출하고 다른 팀들이 FinOps 방법을 도입하고 자신들의 비용을 줄일 때를 축하할 동기를 주게 할 것입니다.\n\n# 청구서를 모니터링하세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클라우드 재무를 관리할 때는 예산 계획을 따르는 것이 매우 중요합니다. 돈을 현명하게 쓰기 위해서는 AWS 비용 탐색기나 Anodot과 같은 타사 서비스와 같은 도구를 활용하여 지출 패턴을 파악하는 것이 좋습니다.\n\n예산 초과에 대한 경보를 설정하고 매달 지출 내역을 정기적으로 모니터링하여 각 팀이나 서비스와 관련된 비용에 집중할 수 있습니다.\n\n리소스마다 태그를 추가하여 팀 이름, 마이크로서비스 이름 또는 다른 태그를 포함하여 각 팀에 대한 비용을 파악할 수 있습니다. 여러 팀이 동일한 AWS 계정을 공유하는 경우 비용을 이해하는 데 도움이 됩니다. 그런 다음 AWS 비용 탐색기에서 필터링할 수 있습니다.\n\n더 자세한 내용은 이곳에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한 SaaS (Software as a Service) 제공업체이면 각 고객의 비용을 예산 편성, 라이선스 및 수익성을 위해 추정(또는 많은 경우에는 \"guesstimate\")하는 것이 중요합니다. 이 작업은 간단한 일이 아니며, 풀 또는 사일로 모델 테넌트 격리 전략을 사용하는 경우 도전이 매우 다릅니다. 그러나 이 주제는 이 게시물의 범위 내에서 다루기에는 너무 방대합니다.\n\n여러 계정을 관리하거나 여러 클라우드 공급 업체를 사용하는 조직에게는 Anodot과 같은 도구가 중요한 이점을 제공할 수 있습니다. Anodot은 비용 관리에 대한 집중된 접근 방식을 제공합니다.\n\n마지막으로, FinOps 챔피언 및 기타 이해 관계자가 이러한 도구에 액세스하고 대시보드를 보고 경보를 정의할 수 있도록하세요.\n\n# 비용 방어 자동화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클라우드 비용을 절감하는 방법 중 하나로 자원 삭제를 자동화하거나 일부 리소스가 처음부터 생성되지 않도록 하는 조직 정책이나 메커니즘을 추가할 수 있습니다.\n\n떠오르는 몇 가지 아이디어는 다음과 같습니다:\n\n- 사용되지 않는 KMS CMK와 같은 자원들을 자동으로 삭제합니다.\n- 삭제되지 못한 CloudFormation 스택 및 \"좀비\" 리소스가 남아 있는 스택을 자동으로 삭제합니다. 예를 들어 S3 버킷이 비어 있지 않아 삭제되지 못한 스택이 있습니다.\n- 개발자가 비인증 지역에 배포하는 것을 방지하는 정책을 시행합니다. AWS 서비스의 가격은 지역에 따라 다릅니다. 필요한 서비스를 사용할 수 있는 지역을 선택하고 고객에게 충분한 응답 시간을 제공할 수 있는 비용 대비 서비스를 선택합니다.\n- 비개발 계정에서 콘솔을 통해 자원을 생성하지 못하도록 하고, 인프라스트럭처-애스-코드(IAC) 방식으로만 생성하도록 합니다. 잊혀진 고아 자원을 생성할 위험을 줄입니다.\n- 스택에 속하지 않거나 사용하지 않는 고아 자원 또는 \"드리프트 된\" 자원을 찾아 삭제합니다.\n- 잠재적인 비용 급증을 알리는 경고를 설정하여 선제적으로 관리합니다. AWS의 비용 이상 탐지와 같은 도구를 사용하여 초기에 비정상적인 지출 패턴을 식별하는 데 도움을 받습니다.\n- 밤에 EC2 인스턴스를 자동으로 종료하는 예약된 작업을 만듭니다.\n- 그 외 다양한 방법이 있습니다. 사용 사례에 따라 다를 수 있습니다.\n\n여기서 가장 중요한 교훈은 선제적인 접근 방식을 채택하는 것입니다. 놀라지 마세요. 비용을 적극적으로 줄이기 위해 노력하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 지속적인 학습\n\n기사, AWS 모임 및 기타 교육 자료를 통해 계속해서 학습하는 것이 매우 중요합니다. 언제 어떤 새로운 기능이나 메커니즘을 발견할지 모릅니다. 혁신과 서비스 발표를 계속해서 파악하는 것도 중요합니다.\n\n모든 것은 변화와 리팩터링에 관한 것입니다.\n\n가끔은 HTTP를 REST API 게이트웨이로 대체하거나 Lambda Powertuning과 같은 도구를 활용하여 함수를 최적화하거나 CloudWatch 로그 보존 기간을 줄이고 로그 수준을 변경하는 등의 서비스 변경이 큰 비용 절감을 이끌 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n팁들이 지나치게 상세해 보일 수 있지만, 그것들은 단지 빙산의 일각에 불과해요. 각 AWS 서비스는 독특한 최적화 기회를 제공하며, FinOut의 DynamoDB 가격 도전과 Best Practices에서 제시된 구체적인 전략들이 그것을 보여줍니다.\n\n집중해서 연구하고 배우고 최적화하세요. 장기적으로 보면 그 노력이 보람 있을 거예요.\n\n# 요약\n\n이 글에서는 모든 조직이 FinOps 마인드셋을 채택해야 할 관행을 다루었습니다. 클라우드 비용을 예방적으로 관리하고 항상 최적화하고 줄이기 위해 전체 조직의 노력이 필요하다는 점을 논의했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 게시물이 귀하의 조직이 클라우드 비용 낙원을 실현하기 위해 FinOps 여정에서 도움이 되길 바랍니다. 행운을 빕니다!\n","ogImage":{"url":"/assets/img/2024-05-18-OptimizingCostsintheCloudEmbracingaFinOpsMindset_0.png"},"coverImage":"/assets/img/2024-05-18-OptimizingCostsintheCloudEmbracingaFinOpsMindset_0.png","tag":["Tech"],"readingTime":14},{"title":"AWS S3와 CloudFront를 이용한 정적 웹사이트 호스팅 공개 vs 비공개","description":"","date":"2024-05-18 16:19","slug":"2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate","content":"\n![Static Website Hosting on AWS S3 and CloudFront](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_0.png)\n\n정적 웹 사이트에는 HTML 페이지, 이미지, CSS 파일, 때로는 JavaScript 및 웹 사이트를 호스팅하는 데 필요한 모든 필수 파일이 포함됩니다. 그들은 변하지 않기 때문에 정적입니다. 웹 사이트를 방문할 때마다 항상 동일한 정보를 동일한 순서와 위치에 보게 됩니다. 이는 로그인한 사용자나 검색 내용에 따라 콘텐츠가 변경되는 동적 웹 사이트와는 달라요.\n\nAWS에서 정적 웹 사이트는 '무언가'라고 불리는 S3 버킷에 저장됩니다. 버킷은 웹 사이트와 관련된 모든 파일을 보관하는 호스트 또는 컨테이너로 비유될 수 있습니다. 서버 측 스크립팅이나 데이터베이스가 필요하지 않기 때문에 그들은 만들기 쉽고 호스팅하기 쉽습니다.\n\n다른 한편 AWS CloudFront는 컨텐츠 전달 네트워크(CDN) 서비스입니다. 주요 기능은 웹 페이지, 비디오, 이미지 및 기타 파일과 같은 콘텐츠를 고성능, 낮은 지연 시간 및 빠른 전송 속도로 사용자에게 전송하는 것입니다. 따라서 정적 웹 사이트를 호스팅하고 CDN으로 CloudFront를 사용하면 사용자에게 웹 사이트 콘텐츠를 전 세계적으로 제공하는 확장 가능하고 신뢰할 수 있으며 고성능 솔루션을 얻을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 AWS에서 정적 웹 사이트를 호스팅하는 두 가지 방법을 탐색할 것입니다. 이를 위해 공개 S3 버킷 또는 비공개 버킷을 사용할 수 있습니다.\n\n## 목차\n\n- Part A: 공개 S3 버킷에 정적 웹 사이트 호스팅 및 CloudFront에 연결하기\n- Part B: 비공개 S3 버킷에 정적 웹 사이트 호스팅 및 CloudFront로 액세스하기\n- 리소스 종료 및 정리\n\n## Part A: 공개 S3 버킷에 정적 웹 사이트 호스팅 및 CloudFront에 연결하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. AWS Management Console에서 S3를 검색하세요.\n\n![Step 1](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_1.png)\n\n2. N. Virginia 또는 us-east-1 지역에 있는지 확인하고 버킷 생성을 클릭하세요.\n\n![Step 2](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep 3: 일반 목적 버킷 유형, 고유한 버킷 이름을 선택하고 권장대로 ACL 비활성화합니다.\n\n![Step 3 Screenshot](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_3.png)\n\nStep 4: 웹 사이트에 대중 접근 가능하도록 공개 버킷에 호스팅하고 있으므로 'public access 차단'을 선택 해제하고 확인합니다.\n\n![Step 4 Screenshot](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 단계: 아래로 스크롤하여 버킷을 만드세요.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_5.png)\n\n다음 단계: 성공 알림을 받게 될 겁니다. 버킷 이름을 클릭하세요. 이제 웹사이트의 인덱스 파일과 이미지를 업로드할 시간입니다.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep 7: 업로드를 클릭하세요.\n\n![Upload](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_7.png)\n\nStep 8: 파일을 추가하세요. 이에는 index.html 파일, css (있을 경우), 자바스크립트 및 웹사이트에 있는 모든 이미지가 포함됩니다. 이 템플릿 웹사이트에서 또는 GitHub 저장소에서 웹사이트 파일을 다운로드하고 추출할 수 있습니다.\n\n![Add Files](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n9단계: 버킷 속성을 클릭하세요.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_9.png)\n\n10단계: 정적 웹사이트 호스팅으로 스크롤하여 편집하세요. 현재 비활성화 상태입니다.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_10.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n11단계: 정적 웹사이트 호스팅을 활성화하고 index.html을 인덱스 문서로 지정합니다. 변경 사항을 저장하세요.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_11.png)\n\n12단계: 다시 정적 웹사이트 호스팅으로 돌아가서 버킷 URL을 복사합니다. 브라우저의 새 탭에 붙여넣기하거나 직접 링크를 클릭하여 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_12.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n13. 결과: 403 금지됨. 버킷 정책을 첨부해야 해서 액세스가 거부되었습니다.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_13.png)\n\n14. 버킷으로 돌아가서 권한 탭을 클릭하세요.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n15단계: 버킷 정책으로 이동하여 편집하세요.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_15.png)\n\n16단계: 아래 정책을 복사하여 붙여넣으세요. 'resource'에 있는 ARN을 버킷 이름으로 바꾸세요.\n\n```js\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"PublicReadGetObject\",\n      \"Effect\": \"Allow\",\n      \"Principal\": \"*\",\n      \"Action\": \"s3:GetObject\",\n      \"Resource\": \"arn:aws:s3:::YOUR_BUCKET_NAME/*\"\n    }\n  ]\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 'ARN'을 복사하고 붙여넣기하세요. 버킷 ARN은 강조된 영역에 표시됩니다.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_16.png)\n\n단계 17: 변경 사항 저장하기.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_17.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단계 18: 브라우저를 새로고침하세요. 웹사이트가 성공적으로 호스팅되었습니다.\n\n![Image 1](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_18.png)\n\n단계 1: 관리 콘솔에서 CloudFront를 검색하세요.\n\n![Image 2](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_19.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep 2: 배포를 만듭니다.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_20.png)\n\nStep 3: 오리진으로 버킷 이름을 선택합니다.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_21.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep 4: 방화벽을 활성화하면 청구를 막기 위해 이 데모의 끝에 삭제해야 합니다.\n\n![image](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_22.png)\n\nStep 5: 아래로 스크롤하여 기본 루트로 이동하고 index.html을 입력하여 배포를 생성하세요.\n\n![image](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_23.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6단계: 배포가 완료되었습니다. 일반적으로 배포 과정이 완료되기까지 시간이 소요됩니다. 과정이 완료될 때까지 기다리신 후, 분배 도메인 이름을 복사하여 브라우저에 붙여넣어 주세요.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_24.png)\n\n7단계: 완료되었습니다!\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_25.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 파트 B: 프라이빗 S3 버킷에 정적 웹사이트 호스팅 및 CloudFront로 액세스하기\n\n단계 1: S3로 돌아가서 다른 고유한 버킷 이름을 선택하세요. ACL을 추천대로 비활성화하세요.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_26.png)\n\n단계 2: 모든 공개 액세스 차단하기.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그를 변경하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep 5: 아직 버킷 정책을 편집하지 마세요. CloudFront로 이동하여 새 유통을 만듭니다.\n\nStep 6: 원본 액세스 아래에서 원본 액세스 제어 설정을 선택하고 새로운 OAC를 생성하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_31.png)\n\n단계 7: Bucket 이름을 선택하고 생성하세요.\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_32.png)\n\n단계 8: 배포를 생성한 후 CloudFront는 웹 사이트에 액세스할 수 있는 버킷 정책을 제공할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Step 9](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_33.png)\n\nStep 9: You can choose either A or B.\n\n![Step 10](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_34.png)\n\nStep 10: If you enable a firewall, you will have to delete it at the end of this demo to avoid billing.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_35.png)\n\nStep 11: 기본 루트 객체에 index.html을 추가하고 변경 사항 저장.\n\n![Image](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_36.png)\n\nStep 12: 생성된 정책 문을 복사하고 안전한 곳에 보관하세요. 배포 상태를 현재 날짜로 변경할 수 있도록 허용하고, 분산 도메인 이름을 복사하여 브라우저에 붙여넣으세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_37.png\" /\u003e\n\n13 단계: 당신의 정책은 이와 유사해야 합니다.\n\n```js\n{\n        \"Version\": \"2008-10-17\",\n        \"Id\": \"PolicyForCloudFrontPrivateContent\",\n        \"Statement\": [\n            {\n                \"Sid\": \"AllowCloudFrontServicePrincipal\",\n                \"Effect\": \"Allow\",\n                \"Principal\": {\n                    \"Service\": \"cloudfront.amazonaws.com\"\n                },\n                \"Action\": \"s3:GetObject\",\n                \"Resource\": \"arn:aws:s3:::pemosi/*\",\n                \"Condition\": {\n                    \"StringEquals\": {\n                      \"AWS:SourceArn\": \"arn:aws:cloudfront::296532954493:distribution/E92LWG7KIDQE3\"\n                    }\n                }\n            }\n        ]\n      }\n```\n\n14 단계: S3 버킷으로 돌아가서 클라우드프런트에서 복사한 정책으로 버킷 정책을 편집하십시오. 변경사항을 저장하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_38.png\" /\u003e\n\n단계 15: 여기 왔어요! 이제 클라우드프론트로 웹 사이트에 접근할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_39.png\" /\u003e\n\n더 흥미롭게 만들기 위해 AWS Route 53을 사용하여 도메인 이름을 사용자 정의할 수 있습니다. 그래서 문자와 숫자의 연속이 아닌 당신의 이름 또는 선호하는 별칭으로 정적 웹 사이트가 제작됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 리소스 종료 및 정리\n\n청구를 피하기 위해 생성한 모든 리소스를 삭제하는 것이 좋습니다. 삭제되지 않은 리소스는 직불 카드에 요금이 부과됩니다.\n\n시작하려면 S3 버킷으로 돌아가세요.\n\n단계 1: 버킷 이름 옆의 원형 체크박스를 클릭하고 삭제를 클릭하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_40.png)\n\nStep 2: You’ll be prompted to empty your bucket first before deleting.\n\n![image](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_41.png)\n\nStep 3: Type ‘permanently delete’ in the space provided and empty.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_42.png)\n\n단계 4: 이제 버킷을 삭제할 수 있습니다. 다시 확인란을 선택하고 이번에는 삭제를 클릭하세요. 버킷 이름을 입력하여 삭제 요청을 확인하세요. 성공적으로 삭제되었습니다!\n\n![Image](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_43.png)\n\n단계 5: CloudFront로 이동하세요. 배포 확인란을 선택하고 비활성화하세요. 시간이 걸릴 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이미지 태그를 Markdown 형식으로 변경하십시오.\n\nStep 6: 비활성화한 후에 삭제할 수 있습니다.\n\nStep 7: 성공적으로 완료되었습니다! 앞으로 나가서 CloudFront를 위해 생성한 OAC를 분리하고 삭제하십시오!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_46.png)\n\n파이어월을 활성화했다면 저와 같이, 파이어월도 삭제해야 합니다. 콘솔에서 WAF를 검색하여 WAF 및 Shield를 선택합니다. 웹 ACLs를 선택합니다. 지역을 us-east-1에서 Global CloudFront로 변경한 후, 파이어월을 클릭하여 삭제합니다.\n\n본 문서는 Amazon S3 및 CloudFront에서 정적 웹사이트를 호스팅하는 과정을 안내했습니다. 이를 통해 다양한 객체를 S3 버킷에 저장하고 모든 종류의 웹사이트를 호스팅할 수 있습니다. 그러나 제작 목적 외의 모든 생성된 리소스는 항상 종료하여야 합니다.\n\n구름에서 만나요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저와 연락을 주세요:\nTwitter(X)\nLinkedIn\n협업 및 일자리? 이메일\n","ogImage":{"url":"/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_0.png"},"coverImage":"/assets/img/2024-05-18-StaticWebsiteHostingonAWSS3andCloudFrontPublicvsPrivate_0.png","tag":["Tech"],"readingTime":17},{"title":"데이터 레이크하우스를 위한 엔드 투 엔드 데이터 엔지니어링 Airflow, Minio, Kafka, Apache Spark, Apache Flink, 그리고 Elasticsearch  PART 2","description":"","date":"2024-05-18 16:15","slug":"2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2","content":"\n\u003cimg src=\"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_0.png\" /\u003e\n\n지난 섹션에서는 데이터 레이크하우스에 대한 중요한 세부 정보, 즉 무엇, 어떻게, 왜 현대 데이터 엔지니어링에서 중요한지에 대해 논의했습니다. 놓치셨다면 여기에서 확인할 수 있어요!\n\n이번 섹션에서는 이번 시리즈 전체를 통해 작업할 시스템의 아키텍처에 대해 논의할 예정입니다.\n\nAWS를 사례로 현대 데이터 엔지니어링과 클라우드를 활용한 경우, 몇 가지 액터가 S3 버킷에 데이터를 넣어 처리를 시작하고 복잡한 분석을 개발할 수 있습니다. 그러나 이 인프라를 계속 사용할수록 상황이 약간 모호해질 수 있고 비용 문제가 커질 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 아키텍처를 좀 더 자세히 살펴봐요; Airflow, Python, Java 또는 파일 업로드와 같은 몇 가지 액터들이 데이터를 Bronze 레이어/저장소에 저장해요. S3 버킷에 데이터를 업로드하는 것은 본질적으로 무료이기 때문에 이는 비용이 전혀 들지 않아요.\n\n![architecture](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_1.png)\n\n비디오 워크스루에 관심 있는 분들은 여기를 따라 갈 수 있어요:\n\n더 흥미로운 점은 이러한 서비스 위에 구축된 추가 서비스들의 사용이에요. AWS Glue Crawler와 같은 서비스가 여기에 속하며, 데이터 파일을 구조화된 데이터베이스와 테이블로 변환하는 데 사용돼요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n크롤러를 만든 후에는 두 가지 주요 옵션이 있습니다. 특정 간격에서 크롤러를 실행하도록 예약하거나 수동으로 계속해서 트리거하는 것입니다.\n\nAWS 문서에 따르면 AWS Glue 작업의 최소 예약 시간은 5분이며, 이는 더 낮은 대기 시간 처리 요구사항이 있을 경우 도착 시 목적이 무산되는 것을 의미합니다. 안타깝지만!\n\n![이미지](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_2.png)\n\n그러나 기다려보세요, 탈출할 수 있는 방법이 있습니다...맞습니다, AWS Lambda입니다! Lambda는 크롤러를 트리거하거나 처리를 자체적으로 처리함으로써 도움을 주는 다양한 기능을 제공할 수 있으며, 이로 인해 아래 아키텍처로 이어집니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_3.png\" /\u003e\n\n음... 이 문제를 해결하면서 또 다른 흥미로운 비용 측면이 발생했네요! 람다 및 첫 해 동안의 무료 티어(첫 해에 대한 요금 면제)에서 사용된 컴퓨팅 시간에 대해 요금이 부과되지만, 함수에 대한 첫 1백만 요청은 무료이며 그 이후 요청에 대해서는 요청 당 0.0000002달러가 청구됩니다. 이 가격은 여러 함수가 여러 버킷에 대해 실시간 변환을 수행하고 있을 때는 이상적으로 보이지만, 그런 경우에는 그렇게 저렴해 보이지 않습니다.\n\n데이터 레이크하우스 아키텍처에 대해 자세히 이야기하기 전에 현재 구현이 실제로 어떻게 보이는지 살펴보겠습니다.\n\n# S3 버킷 설정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS 계정이 있으면 검색 메뉴에서 S3를 검색하고 선택한 지역에 S3 버킷을 만들면 됩니다. 저는 버킷 이름으로 codewithyu를 선택했습니다.\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_4.png)\n\n생성 후에는 버킷에 파일을 업로드하고 Glue Crawler를 생성하여 파일을 처리할 수 있습니다. 버킷에 taxi_project라는 이름의 폴더를 만들어 파일을 업로드할 것입니다.\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# AWS Glue을 사용하여 데이터베이스 및 테이블 생성하기\n\n택시 프로젝트에서 파일 업로드를 완료하면 다음 단계는 AWS Glue로 이동하여 새 크롤러를 추가하는 것입니다.\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_6.png)\n\n해야 할 일은 크롤러에 이름을 지정하고 데이터 원본을 선택하고 출력을 데이터베이스로 설정하는 것뿐입니다 (데이터베이스가 없는 경우 생성할 수 있는 옵션이 있습니다). 그럼 테이블이 자동으로 채워질 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_7.png)\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_8.png)\n\n![image](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_9.png)\n\nFinally, here are the full properties of the crawler:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![screenshot 1](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_10.png)\n\n스크린샷에서 볼 수 있듯이, 출력 및 스케줄링에서는 출력이 \"On Demand\"로 설정되어 있습니다. 특정 간격에서 작업을 실행하려는 경우 CRON 표현식을 사용해야 합니다 (자세한 내용은 crontab.guru를 방문하세요).\n\n이 단계가 완료되면 다음으로 크롤러를 실행해야 합니다.\n\n![screenshot 2](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# AWS Lambda 통합\n\n크롤러를 성공적으로 만들고 완료까지 성공적으로 실행했으므로, 다음 단계는 버킷에 새 파일이 업로드될 때 크롤러를 트리거하는 것입니다. 이를 달성하는 두 가지 방법이 있습니다. 하나는 AWS Lambda 자체를 통해이를 수행하는 것이고, 다른 하나는 S3를 통해 수행하는 것입니다.\n\n## AWS Lambda 통합 — Lambda\n\nLambda를 통해 이를 통합하려면 Lambda 서비스로 이동하고 새 함수를 생성해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 표 태그를 마크다운 형식으로 변경해주세요.\n\n\u003cimg src=\"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_12.png\" /\u003e\n\n이 작업을 완료하려면 함수를 생성한 후 해당 람다 함수에 부여해야 할 권한을 추가해야 합니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_13.png\" /\u003e\n\n권한을 부여하려면 설정 탭으로 이동하여 필요한 권한을 선택하실 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image1](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_14.png)\n\nIn my case, I have added `AmazonS3FullAccess` and `AWSGlueConsoleFullAccess` permissions to the role attached to the function.\n\n![image2](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_15.png)\n\n## Writing the Lambda Function Code\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n체크리스트가 거의 완성되어서, 다음 단계는 S3 버킷에서 PUT 이벤트가 발생할 때 트리거될 람다 코드를 작성하는 것입니다.\n\n우리의 경우, 복잡한 변환 작업을 수행하지 않고 감지된 이벤트마다 크롤러를 실행하는 것이 필요합니다.\n\n```js\nimport json\nimport boto3\n\n# AWS 클라이언트 초기화\nglue = boto3.client('glue')\ns3 = boto3.client('s3')\n\ndef lambda_handler(event, context):\n    # S3 이벤트에서 버킷 이름과 파일 키 가져오기\n    bucket_name = event['Records'][0]['s3']['bucket']['name']\n    file_key = event['Records'][0]['s3']['object']['key']\n\n    # Glue 크롤러 이름 지정\n    crawler_name = 'taxi_crawler'\n\n    # Glue 크롤러 시작\n    try:\n        response = glue.start_crawler(Name=crawler_name)\n        print(f'Glue 크롤러 {crawler_name}이(가) 성공적으로 시작되었습니다.')\n    except Exception as e:\n        print(f'Glue 크롤러 {crawler_name} 시작 중 오류 발생: {e}')\n        raise e\n```\n\n이 함수를 Test 및 새 이벤트 생성을 선택하여 테스트할 수 있습니다. 템플릿에서 S3 아래 putTestEvent를 선택하면 다음과 같은 템플릿이 나타납니다. 버킷 이름 및 폴더를 나의 S3 버킷 및 폴더에 연결하도록 이름을 업데이트했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```json\n{\n  \"Records\": [\n    {\n      \"eventVersion\": \"2.0\",\n      \"eventSource\": \"aws:s3\",\n      \"awsRegion\": \"us-east-1\",\n      \"eventTime\": \"1970-01-01T00:00:00.000Z\",\n      \"eventName\": \"ObjectCreated:Put\",\n      \"userIdentity\": {\n        \"principalId\": \"EXAMPLE\"\n      },\n      \"requestParameters\": {\n        \"sourceIPAddress\": \"127.0.0.1\"\n      },\n      \"responseElements\": {\n        \"x-amz-request-id\": \"EXAMPLE123456789\",\n        \"x-amz-id-2\": \"EXAMPLE123/5678abcdefghijklambdaisawesome/mnopqrstuvwxyzABCDEFGH\"\n      },\n      \"s3\": {\n        \"s3SchemaVersion\": \"1.0\",\n        \"configurationId\": \"testConfigRule\",\n        \"bucket\": {\n          \"name\": \"codewithyu\",\n          \"ownerIdentity\": {\n            \"principalId\": \"EXAMPLE\"\n          },\n          \"arn\": \"arn:aws:s3:::codewithyu\"\n        },\n        \"object\": {\n          \"key\": \"taxi_test/filename.parquet\",\n          \"size\": 1024,\n          \"eTag\": \"0123456789abcdef0123456789abcdef\",\n          \"sequencer\": \"0A1B2C3D4E5F678901\"\n        }\n      }\n    }\n  ]\n}\n```\n\n작업을 완료한 후에는 호출을 선택하고 크롤러가 실행 중인지 확인하세요. 이제 크롤러가 실행되기 시작했을 것으로 예상됩니다.\n\n## S3와 Lambda 연결\n\nLambda를 S3에 연결하려면 Configuration 및 Trigger를 클릭하고 Add Trigger를 선택하여 새 트리거를 추가할 수 있습니다. taxi_project/ 접두사를 추가하는 것을 잊지 마세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_16.png)\n\nOnce done, click Add and you're all set!\n\n![Image 2](/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_17.png)\n\nOnce a file is uploaded to the taxi_project folder, the taxi_crawler should be automatically triggered.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 기사에서는 비용 효율적인 새로운 데이터 레이크하우스 아키텍처를 살펴볼 것입니다.\n\n# 그리고 마지막으로!\n\n아래 주제 중에 관심 있는 주제가 있다면:\n\n- Python\n- 데이터 엔지니어링\n- 데이터 분석\n- 데이터 과학\n- SQL\n- 클라우드 플랫폼 (AWS/GCP/Azure)\n- 기계 학습\n- 인공 지능\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 플랫폼에서 제 프로필을 좋아하고 팔로우해 주세요:\n\n- Github: airscholar\n- Twitter: @YusufOGaniyu\n- LinkedIn: Yusuf Ganiyu\n- Youtube: CodeWithYu\n- Medium: Yusuf Ganiyu\n\nLinkedIn, X, Medium 및 YouTube에서 매일 컨텐츠를 정기적으로 공유하고 있어요.\n\n데이터 엔지니어링 여정을 가속화하려면 Data Mastery Lab를 꼭 확인해 주세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 제 미디엄 팔로우를 통해 저와 소통해주세요:\n\n# Stackademic 🎓\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 좋아요도 눌러주시고 작가를 팔로우해주세요! 👏\n- 다음 링크를 통해 팔로우할 수 있습니다: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해보세요: In Plain English | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- Stackademic.com에서 더 많은 콘텐츠를 확인할 수 있습니다\n","ogImage":{"url":"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_0.png"},"coverImage":"/assets/img/2024-05-18-EndtoEndDataEngineeringforDataLakehousewithAirflowMinioKafkaApacheSparkApacheFlinkandElasticsearchPART2_0.png","tag":["Tech"],"readingTime":13},{"title":"서버리스 애플리케이션을 효과적으로 테스트하세요","description":"","date":"2024-05-18 16:11","slug":"2024-05-18-Effectivelytestyourserverlessapplications","content":"\n서버리스로 이동하는 것은 다른 종류의 아키텍처와 마찬가지로 장단점이 있습니다. 클라우드에 코드만 전달하고 서버를 사용자로부터 추상화하는 아이디어는 몇몇 사람들에게 게임 체인저가 될 수 있습니다. 그러나 이 비교적 새로운 종류의 기술은 대면에서 많은 놀라운 기능을 제공하지만 그 함의는 상당합니다.\n\nAWS에서 서버리스 솔루션을 구현해보기 시작하는 모든 개발자의 가장 핵심적인 질문은 이것입니다:\n\n![이미지](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_0.png)\n\nExpress 또는 Django와 같은 서버풀 프레임워크로부터 API를 작성하는 전통적인 배경에서 온 백엔드 개발자라면, nodemon, python manage.py runserver 또는 개발 프로세스 중에 컨테이너 볼륨을 활용한다면 docker-compose up -d와 같은 해당하는 핫 리로딩 기능에 익숙할 것입니다. 그러나 서버리스에서는 전통적인 백엔드의 개발자 경험을 완전히 포괄하거나 유사한 핫 리로딩 기능이 없다는 것을 알 수 있을 겁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버리스 솔루션을 구현하는 주요 이유 중 하나는 서버리스가 클라우드에 구축되기 때문에 개발자들에게 다소 독특한 경험을 제공한다는 것입니다. AWS Lambda 및 AWS의 모든 다른 서버리스 서비스들은 로컬 환경이 아닌 클라우드에서 최적의 작동을 합니다. 그러나 이러한 이념은 일부 사람들에게는 꽤 문제가 될 수 있습니다.\n\n그렇고 그렇지 않습니다. 서버리스에서는 클라우드에서 자체적인 순간적인 환경을 만들 수 있는 능력을 가지고 있습니다. 클라우드 컴퓨팅의 일반적인 요금 체계는 사용한 만큼만 지불해야 한다는 것입니다. 그러나 서버리스에서는 일정한 범위내에서 이는 사실이지만, 더 정확히 말하면 요금 체계를 정의하는 것은 최종 사용자가 사용한만큼만 지불해야 한다는 것입니다. 따라서, 서버리스의 요금 체계를 통해 클라우드에서 환경을 생성하고 소멸시킬 때 비용이 거의 발생하지 않습니다.\n\n클라우드에 자체 개발 환경을 배포할 수 있는 것은 제품 환경을 모방하는 데 매우 유리합니다. 그러나 여전히 모든 코드 변경마다 배포해야 한다는 것이 거부 사항으로 느껴질 수 있습니다. Serverless Framework나 AWS CDK와 같은 기존 IaC(Infrastructure as Code) 솔루션에서 서버리스를 사용하고 있다면, 가장 짜증나는 피드백 루프에 익숙할 지도 모릅니다.\n\n위에서 언급한 대로 클라우드에 임시 개발 환경을 배포하는 것은 코드가 예상대로 작동한다는 확신을 얻는 장점이 있습니다. 생산 환경으로 전송될 때의 동작도 마찬가지일 것입니다. 이 과정은 의심의 여지 없이 최적의 결과를 제공할 것이지만, 여전히 코드 변경마다 배포하고 각 개발자에게 클라우드 환경 접근을 허용해야 한다는 번거로움이 있습니다. 또한 각 배포는 애플리케이션의 크기에 따라 약 3~10분이 소요됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 느립고 번거로운 피드백 루프를 개선하기 위한 노력이 있었습니다. Serverless Framework의 서버리스 오프라인과 같은 기능은 로컬에서 API 게이트웨이 및 람다 함수를 에뮬레이트할 수 있게 해줍니다. 이 기능을 통해 개발 프로세스를 확실히 가속화할 수 있습니다. 그러나 이 기능은 API 게이트웨이 및 람다 함수를 에뮬레이트하는 데로 제한되어 있습니다. DynamoDB, SQS, SNS 또는 S3와 같은 다른 서버리스 서비스를 에뮬레이트할 수 있는 다른 플러그인들도 있지만, 이를 설정하려면 상당한 운영 오버헤드가 필요합니다. 현재의 로컬 에뮬레이터는 클라우드 환경을 완벽하게 모방할 수 없습니다. 로컬 환경은 생산 환경을 완벽하게 반영하지 못할 수 있어 동작 및 보안 구성에서 차이가 발생할 수 있습니다. 이 접근 방식은 \"내 컴퓨터에서는 작동하는데 실제 환경에서는 작동하지 않는다\"는 부정적인 결과를 가져올 수 있습니다.\n\n다른 예시로 AWS CDK의 cdk watch가 있습니다. AWS CDK는 완전히 단기적인 환경을 채택합니다. serverless offline 기능과 유사한 sam invoke local 같은 기능을 갖고 있지만, cdk watch는 로컬에서 Lambda 함수의 코드 변경 사항을 감지하고 해당 변경 사항만 배포합니다. 이 접근 방식은 피드백 루프를 완전히 새로 만들진 않지만 개발자 경험을 향상시킵니다. 서버리스 응용 프로그램 전체를 다시 배포하는 대신 코드가 변경된 Lambda 함수만 다시 배포하여 배포 속도를 높여줍니다(그러나 핫 리로딩만큼 빠르지는 않습니다). 그리고 터미널에서 스택내 Lambda 함수의 모든 CloudWatch 로그를 감시할 수 있습니다. AWS Management Console을 여는 번거로움 없이 콘솔에서 모든 로그를 확인할 수 있습니다.\n\n이 접근 방식은 우수한 개발자 경험과 최적의 결과를 위한 한 걸음입니다. 그러나 배포 대기 시간은 여전히 기존 백엔드와 비교했을 때 핫 리로딩만큼 빠르지 않아 전통적인 백엔드에 비해 여전히 생산성 저하 요인으로 여길 사람이 많습니다.\n\n서버리스 프레임워크나 AWS CDK와 같은 인프라스트럭처 코드 솔루션을 사용하는 것이 강력히 권고됩니다. 둘 중 하나를 선택하는 것은 크게 중요하지 않습니다. 이전 질문에 대한 대답으로, 코드 변경 시마다 재배포해야 할 경우, 이미 서버리스 프로젝트에서 이러한 IaC 솔루션을 사용하고 있다고 가정됩니다. 더 자세한 답변을 드리자면, 서버리스 응용 프로그램을 테스트하려면 여러분이 인프라 설정을 조정한 코드 변경마다 배포해야 하지만, Lambda 함수를 각 코드 변경마다 다시 배포할 필요가 없습니다. 이는 테스트를 통해 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 서버리스 애플리케이션을 테스트해야 하는 이유\n\n서버리스 애플리케이션에 대한 테스트를 생성하는 것은 로컬에서 해당 애플리케이션을 실행하는 또 다른 방법입니다. 개발자 경험, 생산성 및 코드 확신 사이의 완벽한 균형을 제공합니다. 이렇게 하면 프로덕션 환경으로 코드를 전달할 때 코드 확신을 얻을 때 개발자 경험을 희생할 필요가 없게 됩니다. 두 마리 토끼를 모두 잡을 수 있습니다!\n\n여기서 소개할 테스트 유형은 \"remocal testing\"입니다. 로컬 코드(람다 함수 코드)를 원격/배포된 AWS 서비스와 테스트할 것입니다. 이는 일시적 환경의 사용과 동시에 로컬 코드 호출을 활용합니다. 따라서 제안하는 피드백 루프는 다음과 같습니다:\n\n일찍 봤을 때, 이전의 피드백 루프와 비교했을 때 큰 차이는 없습니다. 그러나 이 방법은 더 빠르며 동시에 로컬 코드가 클라우드에서 작동할 것임을 더 많은 코드 확신을 제공합니다. 왜 그런 걸까요? 클라우드에서의 배포 단계가 다른 단계보다 자주 실행되지 않기 때문입니다. 이 단계는 본래 람다 함수 이외에 필요한 서비스를 배포하는 것으로, 예를 들어 DynamoDB 테이블이나 S3 버킷과 같은 서비스가 있겠습니다. 그러고나면 다시, 우리의 로컬 코드는 클라우드에서 이러한 배포된 서비스들을 대상으로 테스트됩니다. 이는 프로덕션 환경에 더 가까운 근사치를 제공합니다. 최종적으로, 여러분이 자주 만나게 될 피드백 루프는 아래와 같을 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 제안된 피드백 루프는 전통적인 백엔드와 매우 유사한 것이 아닌가요?\n\n로컬 코드가 작동하려면 기존 AWS 리소스에 의존하므로 전체 서버리스 애플리케이션을 배포해야 하는 경우는 다음과 같습니다:\n\n- 새로운 DynamoDB 테이블, S3 버킷 또는 람다 함수 이외에 필요한 서비스를 사용할 때.\n- 엔드 투 엔드 테스트를 수행할 준비가 된 경우.\n\n위 질문에 대한 답은 명백한 \"아니요\"입니다. 같은 것이 아니에요. 전체 서버리스 애플리케이션을 배포하는 데는 규모나 필요한 리소스의 수에 따라 5~10분이 걸릴 수 있습니다. 단일 람다 함수의 오타로 인해 다시 배포해야 할 경우를 상상해 보세요. 그럼 여러분은 변경 사항이 반영되고 함수의 동작을 테스트할 수 있도록 5~10분을 기다려야 합니다. 끔찍하죠? 반면 로컬 테스트는 실행되는 테스트의 양에 따라 최대 1분 정도 소요될 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게다가, 전통적인 백앤드를 지원하는 핫 리로딩과 유사한 동작을 원한다면, Jest와 같은 현대 테스트 프레임워크는 이미 파일의 변경을 감시하고 상호작용하며 테스트를 실행하는 watch 모드를 갖고 있습니다. 따라서 로컬 람다 함수 코드에서 코드 변경이 발생하자마자, 테스트 프레임워크가 해당 코드 변경과 관련된 모든 테스트를 자동으로 실행합니다.\n\n# 구현해야 할 테스트 유형은 무엇인가요?\n\n![2024-05-18-Effectivelytestyourserverlessapplications_1.png](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_1.png)\n\n이 질문에 대한 대답은 특정 유형의 테스트가 여러분에게 제공하는 투자 수익에 따라 실제로 달려있습니다. 서버리스 시스템이나 아마도 다른 분산 시스템에서 가치가 큰 테스트 유형은 통합 테스트입니다. 위의 테스트 허니콤을 참조할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_2.png)\n\n테스트의 양 또는 테스트 커버리지에 대해서는 얘기하지 않습니다. 중요한 것은 테스트가 어떤 투자 수익(Return of Investment)을 제공하는지입니다. 서버리스 유형의 아키텍처와 마이크로서비스를 촉진하는 경우, 통합 테스트를 구현하는 것이 더 많은 의미를 갖습니다. 왜냐하면 복잡성의 많은 부분이 람다 코드 외부에 존재하기 때문입니다. 마이크로서비스를 테스트하는 가장 좋은 방법은 코드가 다른 서비스와 상호 작용하는 방식을 테스트하는 것입니다.\n\n엔드투엔드 테스트는 애플리케이션 전체를 시작부터 끝까지 테스트합니다. 이는 최적의 수익을 제공하지만 실행하는 데 시간이 오래 걸리기 때문에 이러한 유형의 테스트의 투자 수익은 상당히 낮습니다. 반면, 유닛 테스트는 람다 함수의 도메인 로직을 처리할 수 있기 때문에 대부분 낮은 수익과 투자 수익을 제공할 것으로 예상됩니다. 유닛 테스트는 데이터베이스 레이어 및 다른 서비스와의 모든 상호 작용을 가짜로 만들어 가치를 거의 제공하지 않습니다.\n\n# 실전 예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_3.png\" /\u003e\n\n다음 REST API를 구현하여 블로그 게시물과 해당 테스트를 생성해 봅시다. 이 예시에서는 Serverless Framework를 내 선택의 IaC로 사용했습니다. 따라서 동일하게 따라갈 수 있는 저장소는 여기에서 찾을 수 있습니다:\n\n## 사전 준비사항\n\n- AWS 프로필 구성: export AWS_PROFILE=`you-profile-name`\n- 의존성 설치: npm install\n- serverless 애플리케이션 배포: npm run sls -- deploy --stage `your-ephemeral-environment-name`. 꼭! `your-ephemeral-environment-name`을 본인의 임시 환경 이름으로 변경하지 않도록 주의해 주세요.\n- 당신만의 .env.`your-ephemeral-environment-name`을 생성하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 환경 파일의 형식이어야 합니다.\n\n```js\nAPI_BASE_URL = XXX;\nBLOG_POSTS_TABLE = XXX;\nAWS_REGION = XXX;\n```\n\n이러한 환경 변수의 값을 AWS Management Console 또는 Serverless Framework에서 제공하는 플러그인을 통해 얻을 수 있습니다.\n\n## 제안된 피드백 루프\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 통합 테스트는 지역 Lambda 함수 코드(const handler = require(“@src/functions/createBlogPost).handler)를 가리키고 있습니다. 람다 함수가 클라우드에 배포된 것이 아닙니다. 따라서 우리가 통합 테스트를 실행할 때, 지역 람다 함수 코드가 실행되지만 그 모든 DynamoDB 작업은 클라우드의 DynamoDB 테이블로 전송됩니다. 이것은 원격 테스팅입니다. 여기서 지역 코드(이 경우 우리의 지역 람다 함수)가 원격/배포된 AWS 서비스(이 경우 DynamoDB 테이블)에 대해 테스트됩니다.\n\n다음은 통합 테스트를 실행하는 단계입니다:\n\n- export STAGE=`your-ephemeral-environment-name`. 이는 .env.`your-ephemeral-environment-name`을 참조하기 위함입니다.\n- npm run integration-test\n\n![테스트 이미지](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Lambda 함수를 편집하고 싶다면, 얼마든지 해보세요! 블로그 게시물의 제목과 내용 이외에도 스니펫 필드와 같은 다른 필드를 저장할 수도 있습니다. 스니펫 필드는 내용의 처음 50자를 보여주거나 created_at 및 updated_at 필드를 추가할 수도 있습니다. 간단히 테스트를 다시 실행하여 코드 동작을 확인해보세요. 배포하고 3분에서 5분을 기다리지 않아도 코드 동작을 확인할 수 있습니다.\n\n게다가, 자신의 IDE에서 스텝 디버거를 사용해보는 것도 좋아요. 이것들은 서버리스 애플리케이션을 테스트하는 큰 장점 중 일부일 뿐입니다. 속도와 민첩성을 제공하여 Lambda 코드를 개발하고 향상된 생산성을 실현할 수 있습니다.\n\n## 통합 테스트의 주의사항\n\n통합 테스트는 우리가 원하던 속도와 생산성을 제공하지만, 전체 사용자 여정을 완전히 다루지는 못한다는 점을 유의해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 질문에 대한 답변은 전제 조건으로 수행한 단계 중 하나이며, AWS 프로필을 내보낼 때 수행한 요소 중 하나입니다. 로컬 람다 코드는 현재 AWS 프로필의 AWS 자격 증명을 가정합니다.\n\n네, 무서운 것 맞죠? 그래서 로컬 람다 코드 작성 시 주의해야 합니다. 그러나 우리가 로컬 람다 코드를 클라우드로 배포할 때는 이와 같은 경우가 아닙니다. 람다 함수는 항상 기본 실행 역할을 가정합니다. Serverless Framework는 이를 추상화하는 데 훌륭한 작업을 하지만, 여전히 Lambda 함수가 다른 서비스와 통신하려면 특정 권한을 추가해야 합니다. serverless.yml에서 람다 함수를 만드는 방법을 살펴보세요:\n\n```js\n## serverless.yml\n\n...\n\nfunctions:\n  createBlogPost:\n    handler: src/functions/createBlogPost.handler\n    environment:\n      BLOG_POSTS_TABLE: !Ref BlogPostsTable\n    iamRoleStatements:\n      - Effect: Allow\n        Action:\n          - dynamodb:PutItem\n        Resource: !GetAtt BlogPostsTable.Arn\n    events:\n      - httpApi: \"POST /blogposts\"\n\n...\n```\n\n만약 람다 함수에 dynamodb:PutItem 권한을 부여해야 한다는 것을 명시하지 않으면, 클라우드의 람다 함수가 지정된 DynamoDB 테이블에 PutItem 작업을 호출할 권한이 없다는 오류가 발생할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 우리의 통합 테스트에서 찾지 못한 것입니다. 그래서 우리는 엔드 투 엔드 테스트라는 다른 유형의 테스트를 시도합니다. 이 create blog post 기능의 엔드 투 엔드 테스트는 다음과 같습니다:\n\n```js\n// __tests__/test_cases/e2e/createBlogPost.test.ts\n\nrequire(\"dotenv\").config({\n path: `.env.${process.env.STAGE}`,\n});\nimport axios from \"axios\";\nconst chance = require(\"chance\").Chance();\n\ndescribe(\"When we call POST /blogposts\", () =\u003e {\n it(\"should create a new item\", async () =\u003e {\n  console.log(`API_BASE_URL: ${process.env.API_BASE_URL}`);\n\n  const title = chance.sentence({ words: 5 });\n  const content = chance.paragraph();\n  let response;\n\n  try {\n   response = await axios.post(\n    `${process.env.API_BASE_URL}/blogposts`,\n    {\n     title,\n     content,\n    },\n    {\n     headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: \"test\",\n     },\n    }\n   );\n  } catch (error: any) {\n   console.error(error);\n  }\n\n  expect(response).toBeDefined();\n\n  if (response) {\n   expect(response.status).toBe(201);\n   expect(response.data.data.title).toBe(title);\n   expect(response.data.data.content).toBe(content);\n  }\n });\n});\n```\n\n먼저, 엔드 투 엔드 테스트가 작동하려면 먼저 람다 함수를 클라우드에 배포해야 한다는 사실을 알아두는 것이 중요합니다. 위의 코드에서 보듯이, 클라우드의 람다 함수를 호출하는데 이 람다 함수의 API 엔드포인트를 통해 호출되며, 해당 엔드포인트는 POST /blogposts입니다. 로컬 람다 함수 코드가 아닙니다.\n\n다음은 우리의 e2e 테스트를 실행하는 단계입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 애플리케이션을 배포하세요: npm run sls -- deploy --stage `당신의-임시환경이름`\n- export STAGE=`당신의-임시환경이름`. 이것은 .env.`당신의-임시환경이름`을 참조하기 위한 것입니다.\n- npm run e2e-test\n\n![효과적으로 서버리스 애플리케이션을 테스트하는 방법](/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_5.png)\n\n엔드 투 엔드 테스트는 API가 제대로 작동하는지 확인하는 데 많은 가치를 줄 수 있습니다. 그러나 우리가 e2e 테스트에 의존하기만 한다면 생산성이 크게 감소할 것입니다. 왜냐하면 앞서 설명한대로 매 코드 변경마다 배포해야 하기 때문에 개발자 경험을 향상시키는 목적을 반감시키게 됩니다.\n\n# 다음 단계와 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 예시를 보면 단위 테스트가 없다는 것을 알 수 있습니다. 신중한 고려 끝에, createBlogPost 람다 함수에 대한 단위 테스트를 만드는 것은 전혀 가치가 없다는 결론에 도달했습니다. 단순히 요청 본문을 가져와 해당 값을 데이터베이스에 저장하는 것뿐입니다. 그 안에 사용자 정의나 복잡한 로직이 전혀 없었기 때문입니다.\n\n그러나 우리 람다 함수의 이 코드 블록이 우리에게 단위 테스트를 작성해야 한다는 필요성을 알려준다고 주장할 수 있습니다:\n\n```js\n...\n\n const requestBody = JSON.parse(event.body || \"{}\");\n const title = requestBody.title;\n const content = requestBody.content;\n\n if (!title || !content) {\n  return {\n   statusCode: 400,\n   body: JSON.stringify({\n    message: \"Title and content are required\",\n   }),\n   headers: {\n    \"Content-Type\": \"application/json\",\n   },\n  };\n }\n\n...\n```\n\n그렇습니다, 제가 동의합니다. 이 코드 블록은 제목과 내용 필드가 없는지 확인하고 오류를 반환합니다. 이 코드 블록에 대한 단위 테스트를 작성하면 테스트 커버리지를 향상시킬 것이 확실합니다. 그러나 방금 전 언급했듯이 투자 수익에 관한 문제입니다. API Gateway 및 DynamoDB 테이블 관련 테스트가 즉시 필요한 \"블로그 글 작성\" 전체 구현의 다른 영역이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버리스로의 전환은 특히 기존의 전통적인 단일 구조 모델에 익숙한 개발자들에게 중요한 패러다임 변화를 의미합니다. 확장 가능성, 비용 효율성 및 운영 효율성의 매력을 제공하면서도, 응용 프로그램이 디자인, 배포 및 관리되는 방식에 근본적인 변화를 요구합니다. 이 전환의 초기 단계는 상태 없는 컴퓨팅, 이벤트 주도 아키텍처 및 제3자 서비스 및 API 통합과 같은 복잡성을 다루면서 특히 어려울 수 있습니다. 이러한 급격한 학습 곡선은 필수적이며 학습 및 실험에 시간과 자원을 투자해야 합니다.\n\n서버리스 솔루션을 구현하려고 노력한 모든 사람들은 이러한 문제를 모두 경험했으며, 제 자신도 개발자 경험을 개선하기 위해 몇 달의 연구와 개발을 진행했습니다. 서버리스는 정말 아름답고 당연히 계속 사용될 것입니다. 특히 중소기업 (MSMEs)을 위한 서버리스는 비용 효율적인 인프라 유형일 수 있지만, 여전히 완전히 새로운 개발자 경험을 받아들일 수 있는 학습 곡선이 존재합니다.\n\n결론적으로, 초기 장벽에도 불구하고, 서버리스 아키텍처를 숙달하는 여정은 매우 보람 있을 수 있습니다. MSMEs의 경우, 확장성, 비용 절감 및 신속한 혁신 능력 측면에서 수익이 명백합니다. 기술이 성숙해지고 주변 커뮤니티가 성장함에 따라, 아마도 현재의 피드백 루프가 이러한 전환을 용이하게 만들고 동시에 현재의 개발자 경험을 향상시킬 수 있을지도 모릅니다. 따라서, 초기 도전은 중요하지 않더라도, 장기적으로는 서버리스 컴퓨팅의 혜택이 기업이 클라우드를 활용해 디지털 전환 계획을 추진하는데 매력적인 선택지로 만듭니다.\n","ogImage":{"url":"/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_0.png"},"coverImage":"/assets/img/2024-05-18-Effectivelytestyourserverlessapplications_0.png","tag":["Tech"],"readingTime":16},{"title":"AWS CloudFormation을 활용한 간편한 CICD 배포 설정 설정","description":"","date":"2024-05-18 16:09","slug":"2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation","content":"\n\u003cimg src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_0.png\" /\u003e\n\n# CI/CD란 무엇인가요?\n\nCI 및 CD는 지속적 통합(Continuous Integration) 및 지속적 전달/지속적 배포(Continuous Delivery/Continuous Deployment)를 의미합니다. CI/CD 파이프라인은 소프트웨어 전달 프로세스를 자동화하여 코드 빌드, 테스트 실행, 새로운 소프트웨어 버전의 안전한 배포와 같은 작업을 포함합니다. 자동화는 인적 오류를 줄이고 소프트웨어 릴리스 프로세스에서 일관성을 보장하기 위한 것입니다.\n\n# 시작하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사의 목표는 AWS를 사용하여 애플리케이션을 구축, 테스트 및 배포하는 과정을 실제 예제를 통해 안내하는 것입니다.\n\n다음은 배포하는 애플리케이션에 맞게 조정된 단계입니다. 구체적으로 Java Spring MVC 웹 애플리케이션 (Java 버전 17)입니다.\n\n사용된 AWS 서비스 -\n\n- EC2\n- S3\n- VPC\n- CodeCommit\n- CodeBuild\n- CodeDeploy\n- CodePipeline\n- CloudFormation\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# AWS 아키텍처 다이어그램\n\n![AWS Architecture Diagram](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_1.png)\n\n# 시작해봅시다\n\n## 단계 1: CodeCommit\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS CodeCommit은 사용자가 소스 코드 및 자산을 안전하고 확장 가능하게 저장, 관리 및 버전 관리할 수 있도록 하는 AWS의 관리형 소스 제어 서비스입니다. 이는 GitHub이 하는 것과 마찬가지로 작동합니다.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_2.png)\n\n## 단계 2: AWS IAM에서 git 자격 증명 설정하기.\n\n‘AWS CodeCommit을 위한 HTTPS Git 자격 증명’ 섹션에서 ‘자격 증명 생성’을 클릭하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 나아가, 이 자격 증명을 다운로드하고, Git 자격 증명을 입력하라는 메시지가 표시됩니다. 앞서 다운로드한 사용자 이름과 비밀번호를 입력하세요.\n\n## 3단계: 프로젝트를 CodeCommit 저장소에 커밋하십시오\n\n저장소를 복제할 디렉터리로 이동합니다. 다음 명령을 실행하세요:\n\n```js\ngit clone \u003cyour-codecommit-repo-clone-https-url\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로컬 브랜치에서 CodeCommit 리포지토리로 변경 사항을 푸시하려면 다음 명령을 사용하세요:\n\n```js\ngit push origin master\n```\n\nCodeCommit 리포지토리로 변경 사항이 제대로 푸시되었는지 확인해주세요.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 4: S3 버킷 생성\n\n버킷 이름을 입력하고 버킷을 생성하고자 하는 지역을 선택하십시오. 이 버킷에 대한 블록 공개 액세스 설정 섹션에서 모든 공개 액세스 차단 상자를 해제하십시오. 다른 설정은 그대로 두고 '버킷 만들기'를 클릭하여 버킷을 생성하십시오.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_4.png)\n\n버킷이 성공적으로 생성되었는지 확인하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Step 5: CodeBuild](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_5.png)\n\nAs you can see our S3 bucket has been successfully created. Now, let’s dive into our AWS CodeBuild service\n\n![Step 5: CodeBuild](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS CodeBuild 서비스로 이동하여 아래와 같이 빌드 프로젝트를 생성하세요. 원하는 프로젝트 이름을 지정해주세요.\n\n![CodeBuild 프로젝트 생성](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_7.png)\n\n이제 소스 제공자로 AWS CodeCommit을 선택하여 프로젝트 파일을 CodeCommit 저장소에 저장했기 때문에 해당 저장소를 드롭다운 옵션으로 선택하세요.\n\n![CodeCommit 저장소 선택](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n환경 설정을 기본값으로 유지하십시오.\n\n다음으로 새 서비스 역할을 선택하고 다른 설정은 그대로 유지하십시오.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_9.png)\n\n빌드 사양에서는 buildspec.yml 파일을 사용할 것입니다. buildspec 파일의 이름을 지정하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참고: buildspec.yml 파일은 CodeCommit 리포지토리에 저장되어 있어야 합니다.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_10.png)\n\n아래는 우리 프로젝트에서 사용한 buildspec.yml 파일입니다:\n\n```js\nversion: 0.2\n\nphases:\n  install:\n    runtime-versions:\n      java: corretto17\n  pre_build:\n    commands:\n      - echo \"Maven 종속성 설치 중...\"\n      - mvn clean install -DskipTests=true\n  build:\n    commands:\n      - echo \"Spring MVC 애플리케이션 빌드 중...\"\n      - mvn package\n  post_build:\n    commands:\n      - echo \"빌드가 성공적으로 완료되었습니다!\"\nartifacts:\n  files:\n    - target/*.war\n    - scripts/*.sh\n    - appspec.yml\n  discard-paths: yes\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 아티팩트 섹션에서 아티팩트 유형으로 Amazon S3를 선택하고 \"Bucket Name\" 아래에서 생성한 버킷 이름을 선택하세요. 또한 버킷 내에서 빌드 아티팩트를 저장할 폴더 이름을 지정해주세요.\n\n참고: 아티팩트 패키징은 .zip으로 사용하세요.\n\n아래는 테이블 태그입니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_11.png\" /\u003e\n\n나머지 구성은 기본값으로 남겨두고 \"빌드 프로젝트 생성\"을 클릭하세요. \"빌드 프로젝트 생성\"을 클릭하면 새 인터페이스로 리디렉션되어 프로젝트 빌드를 시작할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_12.png)\n\n빌드 시작을 클릭하면 빌드 프로세스가 시작됩니다.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_13.png)\n\n빌드 소요 시간은 buildspec.yml 파일의 구성에 따라 다를 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_14.png\" /\u003e\n\n프로젝트가 성공적으로 빌드되었습니다. 모든 단계에서 성공 상태가 확인되었습니다. 빌드가 성공적으로 완료되었습니다!\n\n이제 빌드 아티팩트가 S3 버킷에 저장되었는지 확인해 봅시다.\n\n\u003cimg src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_15.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 빌드 아티팩트는 이제 \"cloud-project-codebuild-1.zip\"라는 폴더 아래 버킷에 안전하게 저장되어 있습니다. 이 지정된 버킷은 프로젝트 후속 단계에서 아티팩트를 배포하는 믿을 수 있는 저장소 역할을 할 것입니다.\n\n## 단계 6: 인프라 구축 설정\n\nAWS CloudFormation 템플릿의 도움으로 인프라를 시작했습니다. 자동화를 통해 품질을 향상시키고 비용을 절감하며 유연성을 향상시킬 수 있습니다. 원한다면 수동으로 리소스를 시작할 수도 있습니다.\n\n다음 링크로 CFT를 확인할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n노트: 위 템플릿으로 리소스를 출시하는 경우에는 반드시 AMI ID, 역할 및 기타 매핑을 사용하도록 해주세요.\n\n![Image 16](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_16.png)\n\n![Image 17](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_17.png)\n\n![Image 18](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_18.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스택이 성공적으로 시작되었고 모든 리소스가 준비되었습니다.\n\n## 단계 7: CodeDeploy\n\nCodeDeploy를 시작하려면 먼저 2가지 역할을 생성해야 합니다.\n\n- CodeDeploy 역할: 기본 CodeDeploy 권한\n- EC2를 위한 역할: AWSCodeDeployFullAccess 또는 EC2RoleForCodeDeploy AWS 관리 정책을 역할에 부여하세요. 이제 이 역할을 이전에 시작한 EC2 인스턴스에 부여하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_19.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_20.png\" /\u003e\n\nCodeDeploy는 기본적으로 appspec.yml이라는 YAML 파일을 사용하며 소스 코드 루트에서 찾을 수 있습니다. 파일 참조는 여기에 있습니다.\n\n```yaml\nversion: 0.0\nos: Linux\n\nfiles:\n  - source: /\n    destination: /home/ec2-user/server\n\npermissions:\n  - object: /\n    pattern: \"**\"\n    owner: ec2-user\n    group: ec2-user\n\nhooks:\n  BeforeInstall:\n    - location: server_clear.sh\n      timeout: 300\n      runas: ec2-user\n  AfterInstall:\n    - location: fix_privileges.sh\n      timeout: 300\n      runas: ec2-user\n  ApplicationStart:\n    - location: server_start.sh\n      timeout: 20\n      runas: ec2-user\n  ApplicationStop:\n    - location: server_stop.sh\n      timeout: 20\n      runas: ec2-user\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nThe appspec.yml file uses shell scripts to manage the hooks. You can find these scripts here.\n\nNext, navigate to the CodeDeploy service and create an application by specifying the application name.\n\n![Image 1](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_21.png)\n\n![Image 2](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_22.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어플리케이션이 생성된 후에 이제 배포 그룹을 만듭니다. 배포 그룹에 이름을 지정하세요.\n\n![image](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_23.png)\n\n이제 코드 배포 권한을 가진 역할을 선택하여 AWS CodeDeploy가 대상 인스턴스에 액세스할 수 있도록 합니다.\n\n배포 유형 선택중:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 변경 대상: 수정 사항이 적용될 때 애플리케이션이 잠시 오프라인 상태가 됩니다.\n- Blue/Green (선호): 수정 사항이 적용된 새 인스턴스가 시작되는 동안 이전 인스턴스는 여전히 사용자에게 서비스를 제공합니다. 여기서 업데이트는 다운타임 없이 이루어집니다.\n\n우리가 시작하는 애플리케이션은 그다지 중요하지 않으며 잠시 오프라인 상태가 되는 몇 초의 다운타임을 견딜 수 있기 때문에 In-Place 배포 방식을 선택할 것입니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_24.png\" /\u003e\n\n배포 설정에서 다른 구성은 기본 설정으로 유지합니다. 이제 배포 그룹을 생성하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image1](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_25.png)\n\n이제 \"배포 생성\"을 클릭하여 전진하세요. 모든 설정은 그대로 두고 아래 그림과 같이 리비전 유형만 선택하세요.\n\n참고: S3에 저장된 artifact의 URI를 복사하여 리비전 위치로 사용합니다.\n\n![image2](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_26.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 출발할 준비가 되었습니다. 배포를 시작하세요.\n\n![image](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_27.png)\n\n성공했습니다! 내 애플리케이션이 EC2 인스턴스에 배포되고 Auto Scaling 그룹에 의해 스케일링되었습니다. ALB DNS를 통해 애플리케이션에 액세스할 수 있습니다.\n\n## 단계 8: CodePipeline\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS 콘솔의 CodePipeline으로 이동하여 \"파이프라인 생성\"을 클릭하세요.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_28.png)\n\nCodeCommit 리포지토리, CodeBuild 프로젝트 및 CodeDeploy 응용 프로그램을 언급하여 파이프라인을 생성하세요.\n\n![이미지](/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_29.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 단계가 성공적으로 완료된 후, 엔드포인트 URL을 방문해주세요. 여러분의 웹 애플리케이션이 이제 라이브 상태여야 합니다.\n\n축하드립니다! 여러분은 원활한 최고급 AWS CICD 파이프라인을 성취하셨습니다 🔥\n\n# 결론\n\n이 글에서는 AWS와 CloudFormation을 사용하여 Java-17 Maven 애플리케이션의 CI/CD 파이프라인을 설정하고 최적화하는 과정을 살펴보았습니다. 빌드, 테스트 및 배포 단계를 자동화함으로써 더 효율적이고 안정적이며 확장 가능한 배포 프로세스를 구현했습니다. 이는 인간 에러 가능성을 줄일뿐만 아니라 소프트웨어 전달에 일관된 접근 방식을 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 프로젝트에서 소중한 협업을 해준 Mohit Jaiswal에게 감사의 말씀을 전하고 싶습니다. 함께 작업함으로써 배포 프로세스를 효율적으로 간소화하고 응용 프로그램을 최고 품질 기준으로 전달할 수 있었습니다.\n\n읽어주셔서 감사합니다! 이 안내서가 여러분이 AWS와 CloudFormation을 활용하여 CI/CD를 마스터하는 데 도움이 되기를 바라며, 궁금한 점이나 피드백이 있으시면 아래 댓글을 남겨주세요.\n\n즐거운 배포되시길 바랍니다!\n","ogImage":{"url":"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_0.png"},"coverImage":"/assets/img/2024-05-18-StreamlinedAWSCICDDeploymentwithCloudFormation_0.png","tag":["Tech"],"readingTime":16},{"title":"블로그 포스트 제목 스타일로 번역하겠습니다프론트엔드 개발자입니다 위 문구를 친근한 톤으로 한국어로 번역하겠습니다프론트엔드 개발자 번역 부므타운 플레이테스팅","description":"","date":"2024-05-18 16:05","slug":"2024-05-18-BoomtownPlaytesting","content":"\n\u003cimg src=\"/assets/img/2024-05-18-BoomtownPlaytesting_0.png\" /\u003e\n\n함께 게임을 즐기면 좋겠어요. 함께 하는 게임은 제 삶에서 소중한 관계의 기반이에요. 제 인생에서 사랑하는 모든 사람들과는 어떤 방식으로든 함께할 수 있는 게임이 있어요. 몇 시간을 함께 게임하면서 보낸 사람들 중에서 제가 알고 소중히 여기는 사람들이 많아요. 몇 년 전에 한 게임을 통해 시작된 우정은 앞으로 몇십 년 동안 이어질 거예요. 싫어하는 사람들조차도 게임을 함께 했다면 공통분모를 찾을 수 있어요. 저는 게임을 다른 사람과 함께 즐기는 것을 자유롭게 할 수 있기 때문에 게임을 디자인하는 이유 중 하나인 것 같아요.\n\n나에게 있어서 쓰는 것과 게임을 디자인하는 것의 차이는 외로움 때문이에요. 쓰는 것은 홀로 하는 작업인데, 계속해서 새로운 이유를 찾아 다른 사람들과 공유할 수밖에 없어요. 하지만 게임 디자인은 본래 다른 사람들과 함께 하는 활동이에요. \"내 글 좀 읽어줄래?\" 어휴! 그 말이 입에서 부끄러울 정도에요. 하지만 \"함께 게임 좀 할까요?\" 이제 그건 흥미진진한 시간을 약속하는 거고, 함께 춤추고, 공동체로 존재할 수 있는 방법이에요.\n\n게임은 사람들이 플레이할 때만 존재하고, 가끔은 게임 디자인의 기능은 이미 플레이된 게임을 기록하는 것이라고 주장하기도 해요 — 내 머릿속에서만 플레이했다 해도요. 일부 사람은 플레이테스팅에 대해 비판을 품지만, 저는 그것을 즐기죠. 다른 사람들과 함께 게임을 할 기회가 어디서도 얻을 수 없는 독특한 경험이기 때문이죠. 테이블의 필요에 맞게 게임을 바꾸는 것을 게임을 살아 숨쉬는 존재로서 직접 경험하는 아름다운 기회가 또 있을까요? 디자이너들에게 플레이테스트를 추천하는 건 최종 작품의 품질을 향상시킨다는 것 때문은 아니에요 (잘 활용한다면 물론, 그게 가치 있는 도구이긴 해요) 다만 그것이 정말 재미있어서 그래요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나는 13살 때부터 사용해 온 플레이 테스트 방법이 있습니다. 이 방법은 친구 Eclipse가 이 방법에 대한 글을 올리면서 그 가치와 역할에 대해 제 주의를 환기시켰을 때까지는 전혀 눈에 띄지 않는 방법인데요. 저는 이를 '커뮤니티 플레이테스팅'이라고 생각하고 있어요.\n\n![이미지](/assets/img/2024-05-18-BoomtownPlaytesting_1.png)\n\n본 글에서는 커뮤니티 플레이테스팅에 대해 설명하고, 플레이테스팅 방법으로 사용하는 내 생각을 소개하고, 최상의 실행 방법에 대한 조언, 그리고 흔히 발생하는 몇 가지 함정을 피하는 방법에 대해 이야기하려 합니다.\n\n# 커뮤니티 플레이테스팅이란?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n금이 강에서 발견되었습니다. 견습광부들은 눈앞이 반짝이며 도착합니다. 시내 주변에 집들이 솟아납니다. 상점 주인들은 물건을 옮기느라 서둘러합니다. 모든 사람들은 두 달 후에는 온 동네가 황무지가 될 것을 알지만, 현재는 살아있습니다. 커뮤니티 플레이테스팅은 매우 비슷한 프로젝트입니다. 특정 게임에 대한 플레이테스팅과 피드백만을 위해 만들어진 임시 커뮤니티 공간입니다. 이 커뮤니티 공간은 당신의 번창하는 마을, 활동과 흥분이 넘치는 곳이며 결국 가라앉을 겁니다.\n\n디지털 시대에 번창하는 마을을 만드는 여러 가지 방법이 있습니다. 2024년에는 디스코드 서버를 추천하겠지만, 페이스북 그룹, 포럼, 서브레딧 또는 심지어 이상한 캠핑 원정대도 사용할 수 있습니다. 선택한 매체는 게임 디자이너의 편안함과 매체에 대한 익숙함, 그리고 문제가 있는 번창하는 마을의 크기에 따라 달라집니다. 당신의 번창하는 마을이 평범한 테이블톱 팀이라면 그룹 채팅이 충분할 수도 있습니다.\n\n임시이자 집중된 번창하는 마을을 유지하는 것이 중요합니다. 이곳은 직접적으로 당신이 작업 중인 게임과 관련이 없는 다른 게임과 그들의 디자인을 위한 공간이 아닙니다. 디스코드 서버를 만드는 경우, 부주제 채널, 표출용 채널 및 밈 채널을 피하세요. 이것은 보다 넓은 커뮤니티의 중심지가 아니며, 정서 지원을 찾는 곳이나 게임 디자인 축제의 장소가 아닙니다. 이것은 기능을 갖춘 공간이며, 기능이 완료되면 그 공간은 버려질 수 있습니다.\n\n번창하는 마을은 당신의 게임을 위한 커뮤니티입니다. 친구와 플레이 파트너를 초대하세요 (그들이 항상 함께하진 않을 수 있으니 이해하세요!), 팬들을 초대하세요, 당신과 같은 작업을 하는 사람들을 초대하세요. 공간 안 모두가 당신의 이익을 생각하며 게임을 최고로 만들고자 하는 열망을 갖고 있고, 당신이 함께 플레이하고 싶은, 프로젝트에 열정적인 사람들입니다. 그들은 성심성의, 동정심, 흥분으로 당신이 만드는 모든 것에 참여할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**Boom Town**은 플레이테스트 및 반복에 사용되는 공간입니다. 게임을 자주 실행하고 커뮤니티가 본인의 게임을 실행할 수 있도록 권한을 부여하며 실험적인 아이디어를 시험해보라고 사람들을 격려하세요. 게임을 거의 당신만큼 잘 알고 있는 사람들로 가득 찬 방에서 아이디어를 교환하고 까다로운 설명을 해결하는 데 도움을 받으세요. 플레이스토밍 세션을 진행해보세요. 경험 많은 플레이테스터들과 음성 통화를 통해 아직 규칙을 만들지 않은 게임 부분을 다루며 새로운 메카닉을 어떻게 새롭게 만들 수 있는지 보세요.\n\n**Boom Town**이 가장 잘 작동할 때, 게임 내 아이디어를 반복하고 핵심 메카닉을 정제하며 게임 기능을 탐색하는 강력한 엔진으로 작동할 수 있습니다. 게임이 어떠해야 하는지에 대한 당신의 개념을 도전할 초기 시청자로서, 게임이 가장 중요한 본질로 정제되도록 이 과정을 통해 개선할 수 있습니다.\n\n# 커뮤니티 플레이테스팅과의 나의 역사\n\n저는 태보이기(TTRPG)에 손 대기도 전에 라이브 액션 롤플레이(LARP) 디자이너였습니다. 14살 때, Wayfinder Experience를 통해 거대한 인원들을 위한 LARP를 운영하며 전문 스텝과 제작 예산을 가졌습니다. 이러한 LARP는 모두 원샷이었고, 기계적 중첩이 있었지만 플레이테스트를 할 능력이 없었습니다. 한 번 운영한 후 버리고, 좋은 아이디어를 다음 것으로 가져갔습니다. 플레이테스트의 부재는 베타 리딩 및 피드백을 받아야 했지만, 실제로 게임을하지 않았습니다. 어떻게요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이른바 구글 문서의 초기 버전은 20명 이상의 다른 사람들의 메모들로 얽힌 엉망진창이었습니다. 구글 문서의 기능으로 댓글이 추가되기 전에는 친구마다 자신의 텍스트를 나타내기 위한 다른 색상을 선택했고, 게임 텍스트의 각 단락 아래에서 효과에 대해 논의하는 긴 대화를 나누었습니다. 나는 고등학교에 진학할 때, 이 무지개 교환이 곧 긴 코멘트 스레드와 이벤트를 준비하는 스태프와의 그룹 채팅으로 대체되었습니다.\n\n이것은 내 작업에 대한 엄격한 피드백을 받아들이기 시작한 첫 번째 순간이었습니다. 제작 스태프는 4주 동안 일하고 카페인, 니코틴, 벌레 살충제로 에너지를 보충하는 사람들보다 게임 메커닉에 더 냉정한 사람이 없습니다. 그래서 저에게 내 게임에 대해 코멘트를 남겨주도록 요청하는 비즈니스 파트너인 그래비라는 이유가 있습니다. 아름답고 지적인 여성이 나에게 비판적인 태도를 취하는 유일한 방법이니까요.\n\n게임 주변의 계속된 소란이 제 창조적 프로세스의 핵심입니다. 주변의 사람들이 피드백을 제공하면 제게는 필요합니다. 난립한 피드백 속에서 내가 사용할 수 있는 것을 찾아내야 합니다. 테이블탑 게임으로 이동하면서도 이 같은 과정을 플레이테스터들과 함께 진행했습니다. 게임이 완성될 때까지 수백 시간을 게임하는 것이 가능했기 때문에 플레이테스트저에게 수백 시간을 투자하게 되어 제 도움을 받았습니다. 게임의 크기와 복잡성에 따라 2부분으로 나누어 처리했습니다. 작은 게임 중 많은 것이 Possum Creek Patreon을 통해 커뮤니티로부터 플레이테스트 받습니다. 이 방법은 나에게 적합합니다. 작은 게임을 개발할 때는 친구들에게 아이디어를 계속해서 개인적으로 보내거나, Creekside 커뮤니티 센터 채널에서 이야기를 나누지만, 그것은 Boom Town 구조가 필요하지 않습니다.\n\n현재 내 열정적인 프로젝트는 The Seven-Part Pact라는 확장형 시뮬레이션 위자드 게임입니다. 게임의 구조에 많은 경험이 있는 플레이테스터들이 필요합니다. 압력이 많은 부분을 감지하고 약한 부분을 탐색할 수 있기 때문입니다. 나에게 수개월이나 몇 년이 걸릴 대규모 게임이며, 그래서 Boom Town은 장기적으로 유용할 것입니다. 그리고 이것은 이상하며, 소셜 미디어의 굶주린 입에 바로 던질 경우 많은 실험 없이는 분리될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 특정한 친구들과 Patreon 서버에 관심 있는 사람들을 함께 모아 'Boom Town'을 건설했어요. 현재 이 곳은 80명 이상의 대규모 커뮤니티이며, 누출되는 정보나 흘러들어오는 동안에 계속해서 성장하고 있어요. 저는 제게 게임 플레이테스트를 진행하는 사람들에게 서버로 자신의 친구를 초대하도록 허용하고 있어요. 이 서버에는 다음과 같은 채널들이 있어요:\n\n- #general 채널: 게임에 대한 널리 토의를 할 수 있는 공간입니다.\n- #questions 채널: 특정 규칙이 어떻게 작동하는지 의심스러울 때 질문하는 곳입니다.\n- #feedback 채널: 플레이 경험을 게시할 수 있는 곳입니다.\n- 플레이테스트를 조직할 수 있는 채널. (Seven-Part Pact의 경우, 실제 플레이테스트, 온라인 음성 플레이테스트, 포스트 형식의 플레이테스트로 구분됩니다.)\n- 게임 특정 채널(주문법 아이디어나 특정 위자드 주변 토론을 위한 채널 등), 당연히 다른 게임들에 대해서는 다를 수 있어요.\n- 제 자신이 사용하는 세 가지 \"읽기 전용\" 채널, 변경 사항을 게시하는 #to-do 채널, 플레이테스트용 게임 최신 복사본을 포함하는 #resources 채널, 문서에 대한 변경 사항을 게시하는 #updates 채널이 있어요.\n\n또한, 서버 목적에 대한 목표를 설명하고 커뮤니티 행동에 관한 일부 기준을 설정할 수 있는 행동 강령 채널을 마련하는 것을 장려해요. 저는 Patreon Discord의 행동 강령을 사용하고 있기 때문에 이 채널을 포함하지 않기로 결정했어요.\n\n모든 디자이너는 자신만의 구조를 필요로 할 것이며, 누구든지 자신의 공간을 원하는 대로 디자인할 수 있어요. 이것은 Seven-Part Pact에 대해서 제가 발견한 방식이며, 미래 플레이테스트를 위해서는 다르게 구조화할 것이지만요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 플레이테스트에 대한 비고\n\n일부 디자이너들은 플레이테스트를 좋아하지 않거나 플레이테스트가 필요하지 않다고 말합니다. 사실은, 아무것도 필요하지 않고 삶 자체가 큰 롤러코스터인 것 같아요. 작은 게임, 무료 게임, 실험용 게임, 가사 게임 — 이런 게임들은 거대한 전통적인 책과 같이 플레이테스트가 필요하지 않아요. 하지만, 어떤 게임이 플레이테스트를 거치지 않았다는 걸 느낄 수 있어요. 가끔 게임을 하다가 디자이너가 의도한 것과는 다른 명백한 오류를 만나면서, 이런 문제가 발견되었다면 아마도 이 게임은 좀 더 흥미로웠을 것 같다는 생각이 들어요. 이런 실용적인 이유로 플레이테스트를 하는 거죠; 게임에 대한 대화들을 예상하고 이런 순간을 예상할 수 있게 해줘요. 또 하나의 이유는 당신의 게임에 플레이테스트를 하는 것이 좋다는 거에요: 이상적으로, 당신의 게임은 당신에게 재미있어야 해요. 만약 당신에게 재미있지 않다면, 누구에게 재미있는 건지, 그리고 그들이 대신 플레이테스트해주길 원할까요?\n\n# 커뮤니티 플레이테스트에 대한 조언\n\n## 커뮤니티 관리는 기술입니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나는 어떻게 커뮤니티 플레이테스팅 공간을 운영하는 데 편안함을 느끼는 이유는 커뮤니티가 어떻게 작동하는지에 익숙하고 10년 이상의 커뮤니티 관리 경험이 있기 때문입니다. 이 분야가 익숙하지 않다면, 처음부터 커뮤니티를 시작하는 데 시간과 노력이 필요할 것입니다. 사람들은 처음에 말을 꺼리고 사회적 규범이 확립될 때 충돌이 있을 것입니다. 이를 해결할 수 있는 몇 가지 방법이 있어요!\n\n- 토론을 촉진하세요. 답글을 받지 못하더라도 업데이트를 계속해서 올려주세요. 게임을 운영하고 사람들을 끌어들인 다음 게임 후에 구체적인 플레이테스팅 질문으로 텍스트 대화를 유도하세요. 게임과 관련된 밈을 게시하세요. 모두가 게임을 하지 않을 때 체계적인 결과를 얻을 수 없다고 약속할 순 없지만, 그럼에도 불구하고 공간에서 가치 있는 것을 얻으려 노력하세요.\n- 다른 커뮤니티를 활용하세요. Boom Town의 대부분이 다른 커뮤니티 출신이라면 그 커뮤니티 규범을 명시적인 기준으로 활용하세요. 새로운 회원들이 이미 확립된 커뮤니티 규범에 적응하도록 Boom Town을 이 다른 공간의 확장판으로 대해주세요. 서로 알고 있는 사람들이나 게임을 통해 서로 알게 되는 사람들은 창의적인 초점을 유지하여 공간을 운영할 수 있어요.\n\n여전히 갈등과 불일치가 있을 거에요. 작업 환경에 초점을 맞추는 공간이라면 사회적 모임 공간이 아닌 경우, 그런 상황을 최소화할 수 있을 거에요. 공간의 목표를 사람들에게 상기시키고 사회적인 문제가 서버를 지배하지 못하도록 하세요. 우리는 예술을 더 나게 만들기 위해 여기에 있는 거잖아요! 커뮤니티 회원들이 바보 같은 연애를 하고 싶다면, 그 에너지를 DM으로 옮기라고 알려주세요.\n\n## 당신이 디자이너이지, 그들은 아닙니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n커뮤니티 플레이테스팅 공간에서 작업할 때는 받는 피드백과 응답의 폭풍에 압도당하기 쉽습니다. 게임에 투자한 사람들이 있을 것이고, 그들은 게임이 어떻게 되어야 하는지에 대한 강력한 조언을 가지고 있을 것입니다. 그들은 자신들의 소중한 게임 메커니즘이 제거될 때 슬퍼하고, 플레이테스터들을 만족시키기 위해 모든 것을 희생하는 유혹을 느낄 수도 있습니다.\n\n여러분은 디자이너입니다. 그들이 원하지 않는 한 모든 아이디어에 대해 \"아니오\"라고 말하세요. 그들의 소중한 것을 제거하고 여러분의 것을 지키기 위해 열심히 싸우세요. 커뮤니티 플레이테스팅은 여러분을 끌어올리고 과정을 명확하게 해줄 때 성공합니다. 그것이 의견의 폭풍에 여러분을 물에 빠트릴 때 실패합니다. 결국, 그들은 여러분의 게임을 플레이함으로써 여러분에게 도움을 주고 그들의 열정을 보는 것은 아름다울지라도, 여러분은 그들에게 아무 것도 갚지 않아도 됩니다. 게임을 가능한 한 최고로 만드는 데 집중하고 커뮤니티를 게임을 연마하는 수단으로 활용하세요. 지배하지 말고요.\n\n## 질문, 판단하는 게 아니에요\n\n유용한 커뮤니티 플레이테스팅은 일반적인 플레이테스팅 조언에서 나온 것인데, 공간 내 사람들의 수의 증가로 인해 더욱 향상됩니다. 게임의 새롭고 연약한 부분을 제시할 때, 가정하고 판단하는 것 대신 질문하고 탐구하는 문화를 만드세요. 누군가 처음으로 텍스트를 보는 경우, 그들은 그것이 어떻게 작동하는지에 대한 많은 질문을 가질 수 있지만, 실행해보기 전에는 그것이 어떻게 느껴지는지 알 수 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정한 피드백을 제공하기 위해 사용할 수 있는 도구는 대화를 중재하는 데 도움이 될 수 있습니다. 저는 피드백을 위해 Liz Lerman의 Critical Response Process를 수정한 것을 선호합니다.\n\n비슷하게...\n\n## 감정은 유효합니다, 조언은 아닙니다\n\n플레이테스트, 사용자 경험 디자인 및 베타 리딩에 대한 다른 기사에서 이미 다뤄졌지만, 여기서 간단히 설명하겠습니다. 게임 중에 플레이테스터가 감정적 경험을 한다면, 그들이 경험한 감정은 정확하고 유효합니다. 그러나 플레이테스터가 감정에 대해 어떻게 대처해야 하는지 제안하는 것은 아닐 수 있습니다. 플레이테스터가 자신의 클래스 능력이 부족하다고 불만스럽게 느낀다면, 해답은 반드시 능력을 강화하는 것이 아니라 다른 클래스를 약화시키거나 적을 약화시키거나 메카닉을 변경하는 것일 수도 있습니다. 게임은 종종 복잡한 기계처럼 느껴지는데, 누군가가 제대로 연기를 들이대기는 하지만 종종 그 연기의 원인을 올바르게 분명히 알 수 없거나 심지어 그 연기가 나쁜 것인지조차 잘못 알고 있는 경우가 많습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 버블에 갇히지 마세요\n\n언젠가는 게임을 커뮤니티 내에서 지옥 같이 플레이테스트했을 때가 올 거에요. 이제 외부로 나가서 실제 세계에서 게임이 어떻게 작동하는지 확인할 시간입니다. 이제 이전에 한 번도 플레이하지 않은 사람들과 게임을 진행해보세요. 다른 사람이 게임을 진행하는 것을 조용히 감시해 보세요. 게임을 사용할 사람들에게 건네 주고, 게임을 어떻게 하는지 시도하도록 보세요. 무슨 일을 해야 할지 알아보려고 하는 사람들을 지켜보세요. '붐 타운'은 고스킬 고참여 플레이어를 만드는 데 유용하지만, 처음 인상이나 새로운 플레이어의 직감을 평가하는 데는 좋지 않아요. 게임이 준비되면 한 번 시험해보고, 이러한 관찰을 커뮤니티에 가져가서 게임이 어떻게 자체적으로 높을 수 있는지 확인하세요.\n\n# 마무리\n\n'붐 타운'은 일시적인 공간이에요; 커뮤니티를 영원히 운영하고 싶지 않을 거예요. 게임이 끝나면(아마도 itch.io에 업로드하거나 크라우드펀딩을 하면서), '붐 타운'을 종료하기 시작하세요. 사람들이 만족할 수 있도록 대단한 최종 세션 하나 또는 둘 정도를 진행하세요. 사람들이 연락처를 교환하고 다른 서버에서 연락하도록 장려하세요. 게임에 특히 열정적인 사람이 있다면, 별도의 팬 스페이스를 만들 것을 권장하세요. 모두가 당신에게 자신의 이름을 제공할 방법을 제공하며, 최종 게임에서 그들에게 크레딧을 줄 수 있도록 하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임을 더 이상 플레이테스트할 필요가 없을 때가 오면, Boom Town을 종료할 수 있어요... 다음 게임이 나올 때까지요.\n\n이 글은 Creekside 커뮤니티 센터의 친절함과 지원 덕분에 가능했어요. 저희와 함께 계곡에서 독점 기사와 게임을 즐겨보세요. 새 콘텐츠를 먼저 만나보고, 앞서 언급된 일곱 부 Pact Boomtown 플레이테스트 서버에 접속하세요.\n","ogImage":{"url":"/assets/img/2024-05-18-BoomtownPlaytesting_0.png"},"coverImage":"/assets/img/2024-05-18-BoomtownPlaytesting_0.png","tag":["Tech"],"readingTime":12},{"title":"대형 미국 게임 개발팀이 점점 사라지고 있습니다","description":"","date":"2024-05-18 16:04","slug":"2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct","content":"\n![LargeAmericanGameDevTeamsAreGoingExtinct](/assets/img/2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct_0.png)\n\n미국 기반의 대규모 게임 개발 팀 시대가 접어들고 있습니다.\n\n일부 사람들은 이를 믿기 싫어합니다. 그것은 이해할 만한 일입니다. 가끔 획기적인 변화의 순간을 경험하고 있다는 느낌을 깨닫지 못할 수도 있습니다. 그렇지만 여기 우리는 \"흥미로운 시대\"에 몸 담고 있습니다. 그리고 여러 요소가 있지만, 핵심은 미국에서 AAA 게임을 만드는 데 사람들이 너무 오래 걸린다는 것입니다.\n\n게임 개발자들은 프로세스와 도구에 대해 보수적이라고 유명합니다. 옛 방식이 잘 돌아간다고 말합니다. 그래서 왜 그것을 바꿔야 하냐고 물을 수 있습니다. 그래서 대규모 게임을 다루기 위한 혁신적인 새 도구를 받아들이는 대신, 더 많은 사람을 추가합니다. 이로써 매월 소요량이 늘어납니다. 이 큰 팀들은 구식의 관리 구조와 프로세스에 의해 엉망으로 운영됩니다. 이로써 개발 시간이 더 길어집니다. 이 두 가지 값을 곱하면 문제를 볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 돈이 싸고 소비자들이 모든 것을 샀을 때는 이 모델이 지속 가능했습니다. 그러나 그 시대는 지나갔습니다. 인플레이션이 계속해서 증가하고 있으므로 지역 개발의 투자 수익률은 계속해서 감소하고 있습니다. 그러나 불변적으로 달러는 국제 시장에서 강하며, 따라서 저렴한 곳에서 개발하는 투자 수익률은 계속해서 증가하고 있습니다.\n\n요점은 명백합니다: 우리 지역 개발자 인구는 줄어들 것이며, 나머지는 적응해야 할 것입니다. 우리가 이해하고 기회를 잡을 수 있는 기회가 있지만, 그 전에 우리는 먼저 일이 영원히 변화되었다는 것을 받아들여야 합니다.\n\n한 출판사가 말하는 \"대규모 게임 개발이 스스로 무너지고 있다\"라고 하면 나는 믿는다. 왜냐하면 출판사가 세계에서 가장 비싼 지역에서 AAA를 개발하고 있는 동안, 세르비아의 AAA 개발자는 비용의 20%만 지불하지만 품질은 100%입니다.\n\n스튜디오 대표가 말하는 \"게임 제작 방식이 실패하고 있다\"라고 하면 나는 믿는다. 왜냐하면 폐쇄된 대부분의 스튜디오가 미국, 캐나다 및 영국에 있기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 주가 지난 후에 Microsoft가 그러한 영토에 위치한 스튜디오를 폐쇄하자, 폴란드에 하나를 열었습니다. 저는 놀라지 않아요, 왜냐하면 폴란드의 삶의 비용은 캘리포니아의 거의 50%나 적고, 개발자들도 아주 훌륭하기 때문이죠.\n\n누군가를 탓하는 것은 도움이 되지 않을 거에요. 하지만 새로운 현실을 받아들이는 것이 중요할 수 있어요. 그리고 그때 기회를 찾을 수 있어요.\n\n역사적으로, 미국의 산업 강점은 기술 혁신과 새로운 것을 추구하기 위해 옛 방식을 버릴 수 있는 능력이 포함되어 왔어요.\n\n저는 그것이 우리에게 나아갈 길을 가리킨다고 생각해요. 우리 자신만으로 거시경제 상황에 대처할 수 없으므로, 개발 시간의 투자수익률(ROI)을 높여 우리의 소규모 경제적 입지를 개선해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAI가 해결책인가요? 저는 그것이 일부라고 생각해요. 하지만 보다 넓은 시각은 과거의 엄격한 사고를 버리고 적응해야 한다는 것입니다. 그렇지 않으면 우리는 나갈 길에 자신을 발견할 위험이 있어요.\n","ogImage":{"url":"/assets/img/2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct_0.png"},"coverImage":"/assets/img/2024-05-18-LargeAmericanGameDevTeamsAreGoingExtinct_0.png","tag":["Tech"],"readingTime":3},{"title":"Godot을 평가하며","description":"","date":"2024-05-18 16:02","slug":"2024-05-18-OnEvaluatingGodot","content":"\n메가 크리트에서 진행한 내부 게임잼을 3주 동안 마무리했어요. 이번 게임잼은 Godot 엔진을 평가하기 위한 것이었어요.\n\n# 엔진 변경의 이유는?\n\n미래에서 오신 분들을 위해, 2023년 9월 12일 유니티가 런타임 요금을 발표했고 10일 후에 일부 요금을 철회했어요. 그 사이 기간 동안 혼란이 생겼는데, 이미 출시된 게임에 이 요금이 적용되는지 여부가 불분명했고, 런타임 요금의 정의가 모호했으며, 이 요금이 어떻게 감지되는지에 대한 우려가 있었고, 그들은 github 이용 약관(TOS) 페이지를 폐지했어요.\n\n유니티는 나중에 이 github 페이지의 트래픽이 충분치 않아 제거한다고 밝히면서, 이 방법으로 TOS를 투명하게 유지한다는 것이 충분한 관심을 끌지 못했다고 말했어요. ???\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-OnEvaluatingGodot_0.png)\n\n유니티는 불필요하게 이상한 후속 진술과 소극적인 설명을 더욱 깊게 파고들었고, 그들의 직원들은 다른 사람들처럼 혼란스러워하며 모두를 진정시키려고 최선을 다하고 있었습니다. 그것은 대재앙이었습니다.\n\n초기 문제에 대해 더 읽어보거나 여기에 이어지는 내용을 확인할 수 있습니다.\n\n유니티가 한 일은 정말 어리석은 일이었어요. 저는 그 엔진을 별로 좋아하지도 않아요. IPO 이후에 그들이 수수료를 부과하고 그들의 버그가 더 심해진 컴포넌트를 고치지 않는 이 \"커뮤니티를 위한\" 엔진이라고 말하면서 나는 매우 독립적인 인디 게임 개발자인데 말이죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n메가 크릿 팀과 저는 약 일주일간 고돗을 평가한 후 어떠한 함정이 있는지 살펴보기 위해 두 주 동안 게임을 만드는 것이 가장 좋을 것으로 결정했습니다. \"고돗으로 그런 건 안 된다\"라든지 아키텍처적인 함정과 같은 것들이죠. 만약 창조자가 ECS에 대해 과도하게 열정적이라면 누가 알겠습니까?\n\n# 그런데 왜 Godot일까요?\n\n게임 엔진을 선택할 때 제가 고려하는 몇 가지 요구 사항이 있습니다. 가장 먼저 떠오르는 것들은 다음과 같습니다:\n\n- 라이브러리 이상: SDL과 LWJGL에서 일한 경험이 있으므로 좀 더 안내를 받고 싶습니다. 자원을 로드하고 해제하거나 글꼴 처리, 디스플레이 처리에 대한 몇 가지 내부 API가 있으면 좋겠습니다. 그것들을 작성하기 싫어요; 게임을 만들고 싶어요!\n- 정적 유형 언어: 확실히 시각적 스크립팅, 드래그 앤 드롭만 가능한 편집기, 동적 스크립팅 같은 것은 싫어요. C++, C, #Objective-C, Java를 알고 있지만 Python과 JavaScript를 알긴 하지만 그저 제겐 지저분하게 느껴집니다. 이 언어들로 작성하는 코드가 아니라, 회사 내에서 모든 것을 정적으로 변수 유형을 지정할 수 있는 세상이 어디 있겠어요? 내 토끼가 어디에 똥을 누르는 것을 강요하는데도 적용할 수 없는데 말이죠.\n- 커뮤니티: Godot은 열정적인 대안으로 느껴집니다. 인기가 많다는 것은 더 일반적인 문제가 해결되고 토론되는 것을 의미합니다. 난 똑머니 없어요. 빠르게 문제를 해결할 수 없다면 무언가를 비틀어서 넣고 넘어가는데, 여전히 프로젝트에 대해 고품질로 느껴지는 솔루션을 찾고 구현하는 것을 선호할 거예요. 저희는 소규모로 운영되기 때문에 휠을 재발명할 필요가 없어요. 제가 직접 체적 구름을 구현하려 하겠냐구요? 저도 싫어요.\n- 포팅: 나만의 포팅을 하고 싶어요! 'Slay the Spire'에는 LibGDX를 선택한 이유가 PC, Mac 및 Linux에서 실행할 수 있었기 때문이죠. 네, JavaVM에서 실행되며 여러 문제가 있지만 한 번 작성하고 어디서나 실행할 수 있는 거 아니겠어요? 아니요. 콘솔에서는 돌아가지 않고 Mac과 Windows 업데이트가 계속 문제가 되죠. 어쨌든, 포팅은 어려운 일이지만 Godot은 W4Games가 포팅 도구를 개발 중이고, 다른 회사들도 콘솔용으로 포팅을 진행 중이죠! 아주 멋지죠. 스위치용 Brotato와 Cassette Beasts 👀!?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임 엔진을 선택하는 또 다른 이유도 있습니다. 일반 엔진 속도, 업데이트 정기성, 사용하기 즐거운 인터페이스, 소유주/설립자가 John Riccitiello-itis의 징후를 보이는지 여부 등이 있습니다.\n\n그래서 Godot은 이러한 요구 사항을 충족시켰고, C#도 지원한다고 합니다. 멋져요. 게임을 만들어 봅시다.\n\n# 댄싱 듀얼리스트(Dancing Duelists)는 무엇인가요?\n\n음, 바로 앞에서 이야기한 젬 게임입니다! 코어 프레임워크에 너무 많은 요리사가 몰리는 것을 원치 않아서 젬에 추가적으로 한 주를 더 투자하여 우리의 프로그래머 한 명이 \"큰 포트\" 작업을 시작하게 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Game content pipeline](/assets/img/2024-05-18-OnEvaluatingGodot_1.png)\n\nSo we worked on a deckbuilding autobattler because it’s familiar and it has a lot of bits and bobs which tend to be the types of games that we like making (content-heavy, deterministic).\n\n# Game Content Pipeline\n\nI think unlike most companies, we’re a design-first company AND both of our game designers (myself and Anthony) are technically proficient so we’re able to circumvent the making of several tools.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n유니티에서 작업할 때도 우리는 Prefab을 콘텐츠로 만들거나 콘텐츠 데이터를 저장하는 수단으로 Scriptable Objects를 사용하는 것에 반대했습니다. 왜냐하면 우리는 IDE를 사용하는 것이 훨씬 빠르다고 생각하기 때문이죠. 우리는 코드에서 정의/매개변수를 찾아가거나 강력한 검색 기능을 사용하며 엔진이 코드 라인을 가리킴으로써 버그를 해결하는 것이 더 쉽다고 생각합니다.\n\n이 콘텐츠-코드 아키텍처는 Slay the Spire와 같은 게임에서 사용하는 방식이며, 카드 게임을 만들어 보았을 때 Godot에서도 완벽하게 작동했습니다.\n\n프로그래밍에 대해 두려워하는 비전공 디자이너라면 아래 내용을 살펴보세요. 우리가 Backflip이라는 카드를 구현하는 방법입니다. 저는 이 방법이 인스펙터나 특별한 데이터 형식을 사용하는 것보다 더 효율적이라고 생각합니다. 하지만 개인의 선호에 따라 다를 수 있습니다.\n\n```js\npublic sealed class Backflip : CardModel\n{\n    public override string Title =\u003e \"Backflip\";\n    public override string Description =\u003e \"Deal 2 damage.\\nGain 2 HP.\";\n    protected override string PortraitPath =\u003e \"backflip.png\";\n\n    public override async Task OnPlay(FighterClashState owner, FighterClashState target)\n    {\n        await FighterCmd.Damage(target, 2, owner, this);\n        await FighterCmd.GainHp(owner, 2, owner);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임 콘텐츠를 실행하기 전에 화면 간 로직, UI, 애니메이션, VFX, 오디오, 폰트 등을 위한 프레임워크를 설정해야 했습니다. 이것은 대부분의 시간을 잠에서 차지했어요. 대부분의 엔진들에서는 매니저, 팩토리 설정, 게임 내에서 경합 조건을 방지하는 최적의 방법이 있기 때문에 게임 콘텐츠를 통합하고 문제 해결하는 과정을 가능한 즐겁게 만들어야 합니다.\n\n# 화면 및 객체\n\n화면을 로드하고 언로드하는 것을 싫어해요. 불필요하게 느리며, 이해하기 어려운 방식으로 \"정리\"되며, 서로 다른 데이터를 전달하기 위한 흥미로운 방법을 고민해야 합니다. 2D 게임처럼 작은 것을 로드하고 언로드해야 할 경우, 소수의 에셋을 언로드하고 새로운 것을 로드할 수 있어요. 자신감이 있다면 미리 비동기로 로드할 수도 있어요. Unity와 Godot은 여기에서 유연하며, 부모/자식 관계로 객체를 시각화하고 씬 다시로드를 사용하지 않도록 할 수 있어요. 현대적인 게임 엔진의 장점 중 하나에요. 때로는 객체를 놓고 가끔 씬 트리의 시각화 없이 빼먹을 때도 있어요. 그리고 Unity에는 씬과 프리팹이 있어요.\n\nGodot에서는 씬과 프리팹이 하나로 통합되어 tscn 형식으로 되어 있고 git과 호환되어요. 정말 대단하죠. 우리를 괴롭히는 Unity YAML이 있다는 것을 생각하게 했고, perforce가 실제로 유용한지에 대해 고민하게 했죠 (사실은 아니에요). 지옥 같은 프리팹 병합의 날들은 사라졌어요. 하지만 씬에서 많은 변경 사항이 있는 경우 약간의 문제가 생길 수 있어요. 그래도 큰 문제는 없어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 장면 내의 객체를 노드라고 합니다. 따라서 GameObject은 노드입니다. 많은 컴포넌트를 연결할 수는 없지만 대부분의 요구 사항을 처리해 주는 노드의 확장이 많이 있습니다. 그렇지 않다면, 기본 노드 클래스 위에 자체적으로 작성해야 합니다. 나는 심중지기적이어서 이것은 괜찮습니다. Unity의 프랑켄슈타인 구성 요소로 가득 찬 GameObject들은 항상 나를 불안하게 만들었습니다. 하루 종일 인스펙터를 스크롤해야 하는 것은 고통스럽습니다. 이것은 논란이 될 수도 있지만, 전체 모니터를 사용하여 비디오 게임을 만들고 싶고, 빠르고 아름답고 alt-tab을 그리 많이 누르기 싫습니다.\n\n그럼에도 불구하고 때로는 노드의 다양한 노브를 조작해야 하지만, 각 노드의 제한된 매개변수들이 우리를 체크하도록 유지한다는 것을 발견했습니다.\n\n# UI 레이아웃\n\n노드에 관해서 말씀드리자면, 부모 노드로의 조합 및 다양한 지점에 고정시키는 것은 게임 UI를 배치하고 다양한 종횡비와 화면 크기에 대한 호환성을 향상시키는 현대적인 방법입니다. 자체 엔진을 개발하는 개발자들이 UI 작업을 싫어하는 이유가, 이러한 종류의 시스템을 구현하고 싶어하지 않기 때문입니다. 이것은 귀찮으며, 게임이 더 이상 이상한 종횡비를 지원할 때 아무것도 달성한 기분이 들지 않습니다.\n\nUnity와 Godot은 회전 중심, 고정점 및 다양한 컨테이너가 있어서 항목을 목록이나 그리드로 구성하는 데 도움이 됩니다. 때로는 매우 혼란스러울 수 있습니다. 특정 변수가 잠겨있을 때는 매우 매우 명확해야 한다고 생각합니다. 그러나 그렇지 않습니다. 최악의 경우에는 \"당신의 부모가 당신에게 화난 것이기 때문에 그렇게 할 수 없습니다.\"라는 메시지가 표시됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요기에는 학습 곡선이 있어서 Unity가 UI Toolkit을 통해 전체를 다시 설계하기로 결정했어요. 기본적으로 비디오 게임에서 UI를 만드는 것은 앞으로 영원히 재앙이 될 것입니다. 왜냐하면 UI를 만드는 것을 즐기는 사람은 우리와 같이 6명 정도밖에 없고 Unity를 이끄는 사람은 아마도 프론트엔드 웹 개발자일 가능성이 높아요. 이제 모든 인디 개발자들이 그들의 방식을 배워야 한다는 점에 대해 애도를 표합니다.\n\n어쨌든, Godot과 Unity 모두 UI를 위한 특수 노드들이 좋지 않아요. 맞아요. 그것들은 항상 좋지 않았고 앞으로도 그대로일 겁니다. 게임에는 많은 복잡한 UI 문제가 있으며 일반적인 템플릿을 빌리면 게임이 엉망이 될 거예요. UI는 사용자 인터페이스의 줄임말입니다. 플레이어가 인터페이스(게임)와 상호 작용하는 방식을 의미합니다.\n\n새로운 개발자들은 기본값을 사용할 거에요. 버튼이 색상을 거의 눈에 띄지 않게 변경했을 때 \"아, 그건 게을러서 UI를 만드는 Unity 게임이구나.\" 마우스 커서가 실제로 텍스트의 벡터 모양에 닿아야만 글자 위로 커서를 올렸을 때 감지되는 경우? \"아, 그건 플래시 게임이야.\" 2023년에 어떻게 플래시 게임을 하는 거죠?\n\n그뿐만 아니라 Unity의 추악한 \"Font\" 구성 요소, 기본 버튼 및 UI 컨트롤에 대해 언급하기도 싫어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-05-18-OnEvaluatingGodot_2](/assets/img/2024-05-18-OnEvaluatingGodot_2.png)\n\nTextMeshPro는 정말 대단해요. 그것이 그립네요. 제발, 자동 크기 조정된 최소/최대 설정 글꼴 텍스트를 깔끔한 직사각형 가운데 정렬할 수 있게 해주세요. 우리는 예쁜 텍스트를 만들기 위해 직접 스크립트를 작성해야 했어요. 폰트와 텍스트에 대해 매우 신경 써요.\n\n![2024-05-18-OnEvaluatingGodot_3](/assets/img/2024-05-18-OnEvaluatingGodot_3.png)\n\n그래도, Godot에서 MSDF를 볼 수 있어 기쁘네요. 멋진 기술이죠! 모서리가 너무 날카롭고 크기를 잘 조절해요. 그들이 전혀 작동하지 않을 때가 제외하고요 😢\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-OnEvaluatingGodot_4.png)\n\n# 실제로 C#을 지원합니까?\n\n어떨 때는 C#에서 특정 API에 접근할 수 없을 수도 있습니다. 시장에서 오브젝트를 찾기 어려울 수도 있습니다. 코드를 컴파일할 때 항상 업데이트되거나 불안정할 수도 있습니다. 아마도 워크플로우가 좋지 않아서 IDE에서 Godot 편집기로 alt-tab을 누를 때마다 스크립트를 10초씩 컴파일해야 하는지도 모릅니다. 이러한 것들은 GDScript의 전도자가 C# 이야기를 할 때 제 무리한 두려움 중 일부였습니다.\n\n위에서 언급한 것도 있고 다시 한 번 언급하겠습니다. 저는 정적 타입 언어를 좋아합니다. 이러한 허물없는 동적 타입 var 를 원하지 않으며, 이 부분을 아무도 변경할 수 없습니다. 명시적이고 명백한 방식을 좋아합니다. 관련성이 있다면, 우리는 CSV 대신 JSON을 사용합니다. 같은 원리입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 C# 통합에 기분이 좋아지고 있습니다. 제가 선택한 IDE(JetBrains Rider)를 사용하는 설정이 쉬웠어요. 자동 완성이 잘 되고 IDE에서 게임을 기본적으로 실행할 수 있어 좋았어요. 게임을 Godot으로 전환하고 실행할 때 빠릅니다. 정말 빠르죠. Unity에서 항상 꿈에서도 괴로웠던 5~10초간의 \"스크립트 컴파일 중...\" 팝업도 사라졌습니다.\n\n# 빠른가요? 네\n\n스크립트 컴파일 하는 것이 없어지고 Godot은 Unity보다 훨씬 가볍습니다. 고급 그래픽이나 멋진 조명 기술을 다루려고 한다면 정말 대답을 드릴 수 없어요. 하지만 쉐이더, 입자 시스템, 재질 등을 다룰 수 있어요. 아마 가장 최신 기술은 아니겠지만... 전 밝은 장난감보다는... 독립 개발자니까요.\n\nGodot은 작고 게임을 실행하고 매개 변수를 변경하고 다시 실행하는 등 디버그 도구를 계속 사용하지 않고 게임을 실행하는 느낌이 좋아요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임이 실행 중일 때 반영되는 노드들의 변화도 가능해요! 유니티를 배우면서 \"와, 이거 너무 현대적이다.\" 라는 순간이 있었는데, Godot에서도 이것이 잘 동작하고 있다는 것을 보니 기뻤어요. Unity와 비교하면 몇 가지 제한 사항이 있지만 전반적으로 정말 멋진 기능들이에요.\n\n속도에 관한 이야기로 돌아와서, 프로젝트를 열 때 더 빨라지고 작동에 어떤 바보같은 인증도 필요하지 않아요. 프로젝트를 실행하는 속도도 더 빨라졌어요. 스크립트 작업 흐름도 더 빠르고 빌드를 내보내는 것도 더 빨라요. 정말 빠르죠!\n\n부록으로, 인터넷에서 raycast2d의 성능에 대한 불만이 있었어요. 많이 사용할 계획이라면 조금 관련 정보를 좀 더 찾아보길 권해요.\n\n# TexturePacking/TextureAtlas/SpriteAtlas\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좀 아쉽네요. 그게 전부에요. 적어도 TexturePacker로 생성된 파일을 읽을 수 있어서 다행이에요(세 번째 자료 압축 도구의 이름). 약간 짜즯다고 생각하시겠지만요. 하지만 유니티는 매번 게임을 실행할 때마다 패킹을 해야 한다니까, 실은 그것도 바보 같아요. 아마 어디든 이 작업 흐름이 이렇게 훌륭하지 않은 것일지도 몰라요?\n\nNinePatch 텍스처는 TextureAtlases로 설정하는 게 좀 귀찮아요. 그렇게 복잡한 문제는 아닌 것 같아서, 아마 기능 요청을 제출해볼까 합니다.\n\n# Dancing Duelists 디자인 미스\n\n그럼, Dancing Duelists로 돌아가서요. 프로젝트 범위를 줄이고 제한을 도입하여 시간 제약으로 완전히 탐구하지 못한 게임 디자인 영역 및 제한 사항을 살펴보려고 생각했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 덱이 너무 무작위로 설정됩니다: 초기 디자인은 플레이어가 원하는 순서대로 덱을 설정하여 플레이하도록 허용했습니다. 덱은 맨 위부터 자동으로 플레이됩니다. 이는 진정성 있는 사용자 경험을 만들기 위해 심각한 작업이 필요하며 균형을 맞춰야 할 많은 복잡성을 도입합니다. 우리는 게임을 빠르게 플레이테스트할 수 있는 것으로 기대하지 않았기 때문에 문제가 될 수 있는 콘텐츠를 반복적으로 플레이테스트 세션을 실행하여 개선할 수 없었습니다. 이러한 무작위성은 점수판을 더 간단하게 유지합니다.\n- 턴 순서 문제: 누가 먼저 움직일까요? 동점이면 어떻게 할까요? 멀티플레이라면 누가 먼저 가야 할까요? 속도 스텟? 동전 던지기? 당신이 먼저 가고 그들이 먼저 가는 것은 어떨까요? 솔직히 이것은 자동전투게임에서 공정성을 위해 해결해야 할 복잡한 문제입니다. 따라서 우리는 항상 플레이어가 먼저 가는 PvE 게임을 선택했습니다. 위에서 언급한 것처럼, 이는 것을 간단하게 만들지만 게임이 얇아지게 됩니다.\n- 비슷한 빌드: 이상적으로는 각 전투용 파이터마다 맞춤식 카드 풀을 만들어서 2-4가지 일반 아키타입을 향해 빌드할 수 있도록 할 것입니다. 우리는 멀티풀, 공유 풀, 그리고 아마도 보석 시스템에도 비슷한 것을 사용할 수 있게 만들 것입니다. 이렇게 많은 콘텐츠를 만들고 균형을 맞추고, 이러한 아키타입을 탐험하는 것은 거대한 작업일 것입니다. 죄송하지만, 이번 점수판에는 이번 점프를 위한 여러 카드가 들어 있습니다.\n\n더 많은 제약 사항이 있지만, 이러한 절하로 인해 짧은 시간 안에 게임을 출시할 수 있었던 것 같습니다. 게임이 전체 잠재력을 발휘하지 못하는 것은 안타깝지만, 게임 엔진을 탐색하기 위해 실행한 점프에 너무 감정적으로 연연하지 않는 것이 좋습니다.\n\n# 멀티플레이어?! 아쉽게도\n\n자동전투게임이 일반적으로 멀티플레이어 여부에 대해 좀 많이 고민했습니다. 그러나 몇 가지 디자인 문제를 해결하지 못했기 때문에 결국 그것에 대해 진전할 수 없었습니다. 이는 게임을 플레이하고 덱을 저장한 다음 이러한 덱과 대결해야 한다는 것을 의미했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플레이 테스트에서 이 데이터를 얻는 것은 예상보다 순조롭지 않아서 일부 자동화를 구축했어요. 아마도 \"머신 런어지?\", \"AI?\", \"신경망 뭐라뭐라?\"라고 묻고 계실지도 모르겠네요. 대답은 정말이지 그렇지 않아요. 우리가 사용한 건 무차별 공격이었어요. 이게 괜찮았던 이유는 게임이 \"턴 순서 문제\"로 비대칭이며, 각 전투 시작 시 덱이 무작위로 섞이는 것이 많은 변화를 준다는 것이죠.\n\n우리는 Godot이 빠르게 작동한다고 말했지만, 그에 비해 용량을 적게 차지한다는 것도 중요합니다.\n\n그래서 우리는 무차별 공격으로 카드를 선택하게 하고, 그것들을 우리가 만든 작은 플레이어 덱과 싸우게 했어요. 그들이 이기면 해당 덱을 저장하고 게임에 다시 통합시켰죠. 우리는 각 라운드 당 전투별 대략 20개의 고유한 덱을 원했고, 결국 약 1,200개의 고유한 상대를 만들어냈어요. 이들은 플레이어가 만든 덱을 이기는 최소 강도 요구 사항을 충족합니다. 말이 많아 보일 수 있지만, 파일 크기는 2MB에 불과해요. 이런 덱들은 JSON 파일로 저장돼요. 여기 예시 파일이 있습니다: jazzy_jasper_R2_1697423308.json\n\n```js\n{\n “name”: “player”,\n “round”: 2,\n “strength”: 3,\n “autogenerated”: true,\n “character”: “CHARACTER_MODEL.JAZZY_PACIFIST”,\n “trinkets”: [\n “TRINKET_MODEL.CIRCULAR_BREATHING”,\n “TRINKET_MODEL.GOTHIC_WARDROBE”\n ],\n “cards”: [\n “CARD_MODEL.GROOVE”,\n “CARD_MODEL.GROOVE”,\n “CARD_MODEL.GROOVE”,\n “CARD_MODEL.SMOOTH_SOLO”,\n “CARD_MODEL.POLYRHYTHM”,\n “CARD_MODEL.HEADSHOT”,\n “CARD_MODEL.LEG_DAY”,\n “CARD_MODEL.ASTEROID”,\n “CARD_MODEL.FIRE_BLAST”,\n “CARD_MODEL.MOONWALK”,\n “CARD_MODEL.ALACRITY”\n ]\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최종적으로 우리는 현재 전투사와 승리할 때마다 난이도가 증가하는 것을 도입하기 위해 의도된 강도 변수를 활용하지 않았습니다.\n\n# 마무리\n\n해냈어요! 딱 3주 만에 여러분이 지금 이곳에서 다운로드하고 플레이할 수 있는 실제 비디오 게임을 만들었어요: https://megacrit.itch.io/dancing-duelists\n\n![이미지](/assets/img/2024-05-18-OnEvaluatingGodot_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n입력, SDK 통합, 종횡비 처리, 로컬라이제이션, 하드웨어 호환성, 써드 파티 플러그인(Spine2D와 FMOD을 사용합니다), 그리고 수정 가능성과 같은 더 많은 주제가 더 있지만, 좋은 비디오 게임을 만드는 것은 단거리 경주가 아니라 장거리 마라톤이에요. 그럼, 여기서 마무리 지을게요. 전 하느님(Godot 전문가)은 아니지만, 진짜 2D 비디오 게임을 만들기 위한 도구는 있는 것 같아요.\n","ogImage":{"url":"/assets/img/2024-05-18-OnEvaluatingGodot_0.png"},"coverImage":"/assets/img/2024-05-18-OnEvaluatingGodot_0.png","tag":["Tech"],"readingTime":16}],"page":"105","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":16,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"105"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>