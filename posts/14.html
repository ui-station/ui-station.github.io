<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/14" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/14" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="다중 터치 ML 모델 최신 트렌드 및 사용 방법" href="/post/2024-06-23-Multi-touchMLModels"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다중 터치 ML 모델 최신 트렌드 및 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Multi-touchMLModels_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다중 터치 ML 모델 최신 트렌드 및 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">다중 터치 ML 모델 최신 트렌드 및 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법" href="/post/2024-06-23-BuildaniOSAppwitharevenue1338mo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">24<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지" href="/post/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SWIFT에서 STRUCT와 CLASS 비교 분석" href="/post/2024-06-23-STRUCTvsCLASSinSWIFT"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SWIFT에서 STRUCT와 CLASS 비교 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-STRUCTvsCLASSinSWIFT_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SWIFT에서 STRUCT와 CLASS 비교 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SWIFT에서 STRUCT와 CLASS 비교 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="얼마나 쉽게 탈취 가능 내가 도둑이라면 아이폰을 훔치는 단계별 방법" href="/post/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="얼마나 쉽게 탈취 가능 내가 도둑이라면 아이폰을 훔치는 단계별 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="얼마나 쉽게 탈취 가능 내가 도둑이라면 아이폰을 훔치는 단계별 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">얼마나 쉽게 탈취 가능 내가 도둑이라면 아이폰을 훔치는 단계별 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Diffable Data Source를 사용한 다중 필터 컬렉션 뷰 생성 방법" href="/post/2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Diffable Data Source를 사용한 다중 필터 컬렉션 뷰 생성 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Diffable Data Source를 사용한 다중 필터 컬렉션 뷰 생성 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Diffable Data Source를 사용한 다중 필터 컬렉션 뷰 생성 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" Jetpack Compose vs 전통적 안드로이드 반응형 UI를 위한 대결 " href="/post/2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" Jetpack Compose vs 전통적 안드로이드 반응형 UI를 위한 대결 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" Jetpack Compose vs 전통적 안드로이드 반응형 UI를 위한 대결 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl"> Jetpack Compose vs 전통적 안드로이드 반응형 UI를 위한 대결 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jetpack Glance - 알아두어야 할 주요 기능 및 장점" href="/post/2024-06-23-JetpackGlance"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Glance - 알아두어야 할 주요 기능 및 장점" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-JetpackGlance_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Glance - 알아두어야 할 주요 기능 및 장점" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Glance - 알아두어야 할 주요 기능 및 장점</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="뉴욕 타임즈 크로스워드에 손글씨 인식 적용 실험" href="/post/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="뉴욕 타임즈 크로스워드에 손글씨 인식 적용 실험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="뉴욕 타임즈 크로스워드에 손글씨 인식 적용 실험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">뉴욕 타임즈 크로스워드에 손글씨 인식 적용 실험</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드에서 공유 ViewModel의 내부 메커니즘 이해하기" href="/post/2024-06-23-TheInternalMechanismofSharedViewModelinAndroid"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드에서 공유 ViewModel의 내부 메커니즘 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheInternalMechanismofSharedViewModelinAndroid_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드에서 공유 ViewModel의 내부 메커니즘 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드에서 공유 ViewModel의 내부 메커니즘 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link posts_-active__YVJEi" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"다중 터치 ML 모델 최신 트렌드 및 사용 방법","description":"","date":"2024-06-23 01:46","slug":"2024-06-23-Multi-touchMLModels","content":"\n## iOS 앱으로 Python 기반 ML 모델 이식하기\n\n![image](/assets/img/2024-06-23-Multi-touchMLModels_0.png)\n\n## 소개\n\nGoogle과 Apple은 모바일 기기에서 AI 모델을 네이티브로 실행하는 주요 계획을 시작했습니다. 이는 원격 서버에서 모델을 실행하는 것에서 이동하여 AI 응용 프로그램에 대한 흥미로운 기회를 만들어내면서 사용자 개인정보를 유지하는 것입니다. 이러한 발전 중 많은 부분은 디바이스 제조업체가 기계 학습 작업에 사용되는 알고리즘을 처리하는 데 점점 효과적인 칩셋을 설계한 데서 나옵니다. 최근 트렌드를 고려하여, 나는 Python으로 작성된 ML 모델을 iOS에서 네이티브로 실행할 방법을 살펴보기로 결정했습니다. 이를 통해 전화기에서 더 복잡한 ML 구현으로 나아가는 계단으로 보고, 이러한 질문에 대답하기 위해 잘 알려진 데이터셋을 사용했습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ML 모델을 iPhone에서 실행할 수 있는 방법은 무엇인가요?\n- 그 모델과 상호작용하기 위한 직관적인 방법은 무엇인가요?\n- 모바일 앱이 데이터와 기계 학습 모델 사이의 관계를 찾는 것을 기술적이고 비기술적인 사용자 모두에게 더 쉽게 만들 수 있을까요?\n\n이 글은 이러한 질문들을 염두에 두고 iOS 앱을 어떻게 구축하는지에 대해 안내하겠습니다. 자세한 내용에 들어가기 전에 이 연습을 통해 얻은 주요 통찰을 공유하겠습니다.\n\n- 모델을 적응시키는 \"어떻게\"에 대한 질문은 애플의 Core ML 도구를 사용하여 해결할 수 있습니다. 이 도구는 파이썬 모델을 애플의 칩셋에 최적화된 Core ML 형식으로 변환할 수 있습니다.\n- 슬라이더는 모델 예측에 대해 특성 값을 조정하기 위한 직관적인 인터페이스로, 그러나 화면 공간을 많이 차지합니다.\n- 분할 스크롤은 상대적으로 작은 공간에서 수치적 비교를 가능케 합니다.\n- 이 앱은 데이터에 대한 배경을 가진 사람들에게 ML 모델을 설명하는 데 도움이 될 수 있지만, 사용자 인터페이스와 시각화에 대한 추가적인 조정으로 비기술적인 사용자를 돕을 수 있습니다.\n\n이 글은 모바일 ML 모델을 만드는 데 사용된 일반적인 기술에 대해 이야기할 것입니다. 프로젝트에 대한 GitHub 링크도 제공됩니다. 다음은 다룰 주제의 요약입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모델이 훈련된 데이터의 개요\n- Python에서 Core ML로 모델 변환하기\n- 데이터를 iOS 앱으로 내보내기\n- 모델과 데이터를 애플리케이션에 가져오기\n- 모델 및 데이터와 상호 작용하는 인터페이스 구축 방법\n- 결론\n\n완성된 앱은 다음과 같습니다. 시작해봅시다!\n\n![앱 스크린샷](/assets/img/2024-06-23-Multi-touchMLModels_1.png)\n\n## 모델이 훈련된 데이터의 개요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nML 모델을 학습하는 데 사용된 데이터에 대해 간단히 설명드리겠습니다. 우리는 인기 있는 Pima 인디언 당뇨병 데이터 세트를 사용할 것입니다. 이 데이터는 국립당뇨병 및 소화기 및 신장 질환 연구소에서 나온 것으로, 혈당, BMI, 연령 등과 같은 개인의 의학적 속성에 중점을 둔 더 큰 데이터베이스의 일부를 대표합니다. 대상은 적어도 21세 이상의 피마 인디언 여성입니다. 당뇨병 양성 진단을 받은 환자는 결과가 1이며, 당뇨병 음성 진단을 받은 환자는 결과가 0입니다. 데이터는 kaggle에서 수집되었습니다.\n\n이 프로젝트에서는 Python을 사용하여 모델 구축 및 데이터 변환을 수행하고, iOS 애플리케이션에는 Swift를 사용할 것입니다. Python 코드에서 각 기능에 대해 생성된 탐색적 시각화 및 몇 가지 더 구체적인 결과들이 구축되기 전에 기본 랜덤 포레스트 분류기 모델을 만들 것입니다. 앱을 위해 몇 가지 염두에 두어야 할 사항들:\n\n- 사용자가 모델 예측을 위해 현실적인 시작점을 갖도록 기본적으로 이러한 값으로 설정하는 경우에 나중에 앱 인터페이스를 만들 때 데이터의 각 기능에 대한 전반적인 중심 경향 측정치를 표시할 것입니다.\n- 원래 데이터와의 모델 예측을 테스트할 수 있도록 몇 가지 변수 간의 관계를 관찰할 것입니다.\n\n![image](/assets/img/2024-06-23-Multi-touchMLModels_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 등고선 플롯에서 극값을 참고하여, 매우 가능성 있는 당뇨 진단이 있는 경우와 당뇨가 덜 가능성 있는 경우를 찾기 위해 데이터를 필터링할 수 있습니다. 아래는 110에서 130 사이의 글루코스 값, BMI가 30에서 35 사이인 경우 및 양성 당뇨병 분류에 대한 중앙값이 제공됩니다. 나중에 이러한 값들을 선택하여 우리 모델이 양성 분류를 예측하는지 확인할 것입니다.\n\n우리 모델은 scikit-learn에서 가져온 기본 랜덤 포레스트 분류기입니다. 데이터에 표준 스케일러를 적용하는 전처리기로서 파이프라인을 사용함에 유의하세요. 현재 모델에 추가적인 최적화는 수행되지 않았으며, 제 현재 초점은 iOS 앱에 배포하는 방법을 보여주는 것입니다.\n\n```js\nclf = RandomForestClassifier((random_state = 42), (n_estimators = 500));\npipe = Pipeline([(\"scaler\", StandardScaler()), (\"rf\", clf)]);\npipe.fit(X_train, y_train);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델은 조정 없이 첫 번째 시도에서 테스트 데이터에서 0.8의 정확도 점수를 보였어요. 당뇨병 양성 진단을 예측하는 데 어려움을 겪는 반면, 음성 진단을 예측하는 데는 더 어려움이 있어요. 특성 중요도를 확인할 때 혈중 포도당 수준이 가장 큰 영향을 주며, 이어서 BMI, 나이, 그리고 환자의 당뇨병 가계식 기능이 나타났어요. 사용자에게 직관적인 방식으로 이러한 특성을 전달할 수 있는지 앱을 개발하는 과정에서 이러한 점을 염두에 두겠어요. 다음으로는 Python 모델을 Core ML 파일로 내보내고 iOS 앱에서 시각화를 위한 데이터를 준비해볼게요.\n\n## Python 모델을 Core ML로 내보내기\n\nPython 코드에서 Core ML 도구를 가져와서 ct로 별칭을 만들어요. Core ML 도구에는 여러 모델을 지원하는 컨버터 클래스가 있으며, 원핫 인코딩과 같은 전처리기를 포함하고 있어요. convert 메서드를 호출하면 외부에 저장하고 Xcode와 같은 앱 개발 환경에서 가져올 수 있는 모델이 생성되어요:\n\n```js\ncoreml_model = ct.converters.sklearn.convert(pipe, X_cols, \"Outcome\");\ncoreml_model.save(\"DiabetesTest.mlmodel\");\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCore ML 도구에 대한 문서를 읽어보세요. Python 라이브러리로 어떤 것이 지원되는지 확인할 수 있어요. PyTorch, TensorFlow와 같은 인기 있는 신경망 라이브러리 뿐만 아니라 scikit-learn, XGBoost, LibSVM과 같은 비신경망 라이브러리도 지원되요. 사용 중인 라이브러리가 지원되지 않는다면, 사용 가능한 것에 맞추기 위해 파이프라인을 다시 설계해야할 수도 있어요.\n\n## 소스 데이터를 JSON으로 내보내기\n\nAPI 데이터를 가져오는 것을 시뮬레이션하기 위해 .csv 파일을 JSON으로 변환하고 있어요. 이것은 반드시 최상의 방법은 아니지만, 일부 데이터 시각화에 우리 앱이 작동하려면 데이터가 이런 형식으로 포맷되어 있으면 편리할 거에요. iOS 앱에서 데이터를 인덱싱하는 데 도움이 되도록 내보내기 전에 데이터에 일부 수정을 가했어요:\n\n```js\nimport json\nout = pima.reset_index()\nout = out.rename({'index': 'id'}, axis=1)\nout = out.to_json(orient='records')\nparsed = json.loads(out)\nwith open('data/diabetes.json', 'w') as f:\n    f.write(out)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## iOS 애플리케이션으로 모델 가져오기\n\n이제 iOS 기기에 최적화된 형식으로 모델을 내보냈으니, 애플리케이션으로 불러와야 합니다. 이후에는 Apple의 Xcode 환경을 사용해 Swift로 개발하게 될 것입니다. Xcode에서는 파일 - \"파일 추가...\" 메뉴를 이용해 프로젝트에 파일을 추가할 수 있고, 그 후에는 Swift 코드로 참조하면 됩니다. 아래는 모델의 파일명이 DiabetesTest로 설정된 예시입니다.\n\n```Swift\nimport CoreML\nimport CreateMLComponents\n\nlet config = MLModelConfiguration()\nlet model = try DiabetesTest(configuration: config)\n```\n\n모델을 불러왔는데, 이제 앱에서 어떻게 예측을 만들 수 있을까요? 모델은 prediction() 메서드를 가지고 있으며, 데이터의 모든 특징을 매개변수로 사용합니다. 호출하는 방법은 아래와 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nlet prediction = try model.prediction(Pregnancies: pregnancies,\nGlucose: glucose,\nBloodPressure: bloodPressure,\nSkinThickness: skinThickness,\nInsulin: insulin,\nBMI: BMI,\nDiabetesPedigreeFunction: diabetesPedigreeFunction,\nAge: Age)\npredictionValue = Int(prediction.Outcome)\n\n## iOS 애플리케이션으로 JSON 데이터 가져오기\n\n데이터를 로드해야 합니다. 이 작업은 모델을 훈련하는 데 사용한 각 개인의 건강 데이터를 시각화하는 데 도움이 됩니다. Pima라는 구조체를 만들어서 시작하겠습니다. 이 구조체는 Codable 및 Identifiable로 만들어지며, 각 특징이 나열됩니다.\n\n```swift\nstruct Pima: Codable, Identifiable {\n    let id: Int\n    let Pregnancies: Float\n    let Glucose: Float\n    let BloodPressure: Float\n    let SkinThickness: Float\n    let Insulin: Float\n    let BMI: Float\n    let DiabetesPedigreeFunction: Float\n    let Age: Float\n    let Outcome: Float\n\n    var BMIString: String { BMI.formatted(.number) }\n    var GlucoseString: String { Glucose.formatted(.number) }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터를 가져오는 것은 JSON 디코딩이 필요할 거예요. 주요 단계의 요약은 아래에 있어요. 디코딩된 데이터는 클래스 데이터 객체에 저장돼요. 이 객체는 프로젝트 전체에서 공유할 거예요:\n\n```js\nlet bundlePath = Bundle.main.path(forResource: name,\n                                  ofType: \"json\"),\nlet jsonData = try String(contentsOfFile: bundlePath).data(using: .utf8)\nlet decodedData = try JSONDecoder().decode([Pima].self,\n                                           from: jsonData)\nself.pima = decodedData\n```\n\n## 모델 실험을 위한 인터페이스 구축\n\n이제 데이터를 불러왔으니, 앱 인터페이스 구성 요소를 만들어 볼 수 있어요. 이 구성 요소에는 다음이 포함돼요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 혈당, BMI, 연령 및 기타 측정치의 값을 수정할 수 있는 슬라이더. 환자의 당뇨병 가능성을 나타낼 예측이 값이 변경될 때마다 이루어집니다.\n- 당뇨병 분류 결과를 동반하는 차트로, 소스 데이터에서 두 그룹에 속한 환자 수를 표시합니다.\n- 데이터의 스크롤 가능한 뷰로, 선택한 값을 원본 데이터세트의 값과 비교하거나 양성 및 음성 분류 간을 비교할 수 있습니다.\n\n이러한 요소들의 조합은 다양한 배경을 가진 사람들이 모델과 소스 데이터를 실험을 통해 이해할 수 있도록 의도되었습니다. 예를 들어, 혈당 슬라이더를 조절하여 혈당이 증가함에 따라 산점도에 오렌지색 점의 증가와 이웃 막대 차트의 더 높은 오렌지색 막대가 나타나며, 더 많은 양성 케이스를 나타냅니다. 다른 기능들, 특히 연령과 BMI와 실험을 통해 이들 값과 양성 예측 사이의 관계를 비교하면 유사한 발견이 이뤄질 것입니다. 각 슬라이더 변경 시 모델은 예측을 수행하고 데이터를 필터링하여 현재 뷰와 함께 필터링된 데이터를 제공합니다.\n\n우리의 슬라이더를 구현하기 위해, 각 기능에 대해 데이터의 최소/최대 값을 범위로 설정할 수 있습니다. 슬라이더가 이동하고 값이 변경될 때마다, 차트에서 읽은 공유된 필터링된 데이터를 업데이트하고 현재 슬라이더 값을 사용하여 모델에 의한 예측을 실행합니다. 혈당 슬라이더를 사용한 예시는 아래와 같습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:590/1*ekxFVO-UDWH_2I9FQjQiPw.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 데이터 개요 섹션에서 관찰된 값들과 유사한 값을 사용하여 Glucose의 범위를 110에서 130으로 보여주는 컨투어 플롯이 있습니다. 이 플롯은 이 범위에서 당뇨병 양성 진닝의 높은 양을 나타냈습니다. 이러한 글루코스 값으로 업데이트한 후 모델이 양성 분류를 지정하는 것을 보는 건 격려가 됩니다!\n\n시각화를 만들려면 Charts 라이브러리가 필요하며, 우리는 당뇨병이 없는 환자를 나타내는 파란색, 당뇨병이 있는 환자를 나타내는 주황색으로 사용자 지정 색상을 가진 산점도를 보여줍니다. 막대 차트는 두 가지 당뇨병 결과를 따로 그룹화하고 현재 슬라이더 값에 따라 총계를 계산합니다. 다음은 막대 차트에 대한 코드 스니펫입니다:\n\n```js\n// 현재 선택 항목에 따른 총 수 카운트 찾기\nlet aggregatedData = Dictionary(grouping: filteredTable, by: { $0.Outcome })\n    .map { (outcome, items) in\n        (category: outcome, count: items.count)\n    }\n\n// 막대 차트 생성\nlet barChart = Chart(aggregatedData, id: \\.category) { item in\n    BarMark(\n        x: .value(\"카테고리\", item.category),\n        y: .value(\"수\", item.count)\n    )\n    .annotation(position: .top, alignment: .center) {\n        Text(\"\\(item.count)\")\n            .font(.caption)\n            .foregroundColor(.black)\n    }\n    .foregroundStyle(by: .value(\"카테고리\", item.category))\n}\n```\n\n이 시점에서 사용자에게 혈당, BMI 및 기타 기능의 값 선택이 실제 환자 데이터와 일치하는지를 보여줄 수 있습니다. 또한 우리의 모델이 그러한 선택을 기반으로 예측을 하는 방법을 동시에 보여줄 수 있습니다. 그러나 혈당, BMI 및 기타 기능에 대한 \"정상\" 값이 무엇인지에 대한 사용자에게 더 많은 컨텍스트를 제공하는 방법은 무엇일까요? 앱 설계 시에 이 문제를 몇 가지 마주쳤습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 화면 공간이 제한되어 있어 숫자들과 요약 통계의 벽이 잘 표시되지 않아요.\n- 최소 두 세트의 데이터를 동시에 비교할 수 있어야 하며 사용자가 비교하려는 데이터 포인트를 쉽게 선택할 수 있어야 합니다.\n- 사용자가 소스 데이터와 일치하지 않는 값을 실수로 선택하면 해당 값과 일치시킬 수 없게 됩니다.\n\n1번과 2번 문제에 대한 해결책은 스플릿 스크롤 뷰를 생성하는 것이었습니다. 뷰의 반은 하나의 데이터 세트에 투여되고, 다른 반은 비교할 대상에 투여됩니다. 두 가지를 빠르게 동시에 스크롤하여 값들을 비교할 수 있으므로 노력을 많이 들이지 않고도 비교할 수 있습니다. 이를 위해 새로운 두 가지 뷰를 생성했고, 앱 상단 오른쪽의 Stats 버튼을 클릭하여 이동할 수 있습니다. 첫 번째 뷰는 현재 선택 사항과 필터링된 데이터의 중앙/최소/최대 값을 비교할 수 있도록 합니다. 두 번째 뷰는 긍정적 결과로 필터링된 데이터와 부정적 결과로 필터링된 데이터 간의 비교를 제공합니다.\n\n\"이움 매체 데이터\"라고 표시된 추가 슬라이더를 추가하여 사용자가 데이터 포인트와 가깝지 않은 값을 선택할 때 대응했습니다. 이 슬라이더를 조정하면 사용자가 선택한 값의 위와 아래로 필터 범위가 증가하여 현재 선택 사항 주변에 점점 더 넓은 범위로 데이터를 검색합니다. 왼쪽 끝까지 슬라이드하면 모든 데이터 포인트가 표시됩니다. 다른 뷰의 중앙/최소/최대 계산은 이 데이터 선택을 기반으로 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:590/1*VEDrLQddT4Pi2rGqGK8G5A.gif\" /\u003e\n\n## 결론\n\n우리는 직관적인 스마트폰 인터페이스를 활용하여 데이터와 머신러닝 모델을 다루는 직관적인 방법을 만들 수 있습니다. Apple의 Core ML 도구를 사용하면 우리는 파이썬으로 모델을 개발하고 이를 iOS 네이티브 모델 형식으로 변환한 다음 앱에 가져올 수 있습니다. 우리의 앱은 사용자가 기능 값들을 수정할 수 있는 기능을 제공하여 모델을 훈련시키는 데 사용된 데이터 세트를 탐색하고 모델의 예측 출력을 볼 수 있게 합니다. 이 공간에서 탐색할 수 있는 많은 가능성이 있으며, 모델과 다른 인터페이스를 계속해서 만들면 다른 사람들에게 결과를 전달하는 새로운 방법을 열 수 있습니다!\n\n어떤 모델 인터페이스를 만들어 보고 싶으신가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 링크\n\nGitHub 저장소\n\n애플의 Core ML 도구\n\n피마 인디언 당뇨병 데이터베이스\n","ogImage":{"url":"/assets/img/2024-06-23-Multi-touchMLModels_0.png"},"coverImage":"/assets/img/2024-06-23-Multi-touchMLModels_0.png","tag":["Tech"],"readingTime":13},{"title":"매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법","description":"","date":"2024-06-23 01:43","slug":"2024-06-23-BuildaniOSAppwitharevenue1338mo","content":"\n완전한 튜토리얼이 함께 하면서 한 단계씩 안내해 드릴게요\n\n![iOS 앱 빌드 수익 내기](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_0.png)\n\n# 월 수익\n\n오랜 시간 동안 이 앱에 작업해온 결과, 매달 수익이 약 1300달러 정도 나오고 있습니다. 개발자들과 경험을 공유하고, 저와 같은 수익을 얻을 수 있도록 도와주고 싶어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마스 1부터 7까지의 수익, 광고 수익은 제외합니다.\n\n![Image](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_1.png)\n\n여기서 전체 수익을 확인할 수 있습니다.\n\n![Image](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 시작하기 전에\n\n이 튜토리얼은 고급 Swift를 배우고 싶은 소프트웨어 개발자를 대상으로 설계되었습니다. 이 튜토리얼은 Swift에 대한 충분한 이해와 어떻게 앱을 처음부터 만드는지에 대한 지식을 제공할 것입니다. 저는 개발자들이 깔끔한 코드로 자신만의 앱을 만드는 데 도움을 주고 싶어합니다. 대부분의 튜토리얼이 앱을 만드는 데 정말 좋은 참고 자료가 아니라는 것을 감안할 때, 여기서는 MVVM 아키텍처를 따르고 인앱 구매를 통합하는 방법에 대한 완전한 튜토리얼을 볼 수 있을 것입니다.\n\n이 튜토리얼을 진행하기 전에 컴퓨터 프로그래밍 용어와 프로그래밍 언어의 지식을 가지고 있어야 합니다.\n\n따라서, 초보자이고 Swift에 대해 많이 알지 못하는 경우에도 따라올 수 있지만, 더 많이 Swift에 대해 알고 시작하는 것이 가장 좋습니다. 왜냐하면 우리는 기본적인 Swift 세부 정보에 대해 다루지 않을 것이기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image1](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_3.png)\n\n# 애플리케이션 아키텍처\n\n소프트웨어를 개발할 때 디자인 패턴 뿐만 아니라 아키텍처 패턴 또한 중요합니다. 소프트웨어 공학에서는 다양한 아키텍처 패턴이 있습니다. 모바일 소프트웨어 공학에서 가장 널리 사용되는 것은 MVVM, Clean architecture 및 Redux 패턴입니다.\n\n![image2](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 여기에서 사용된 아키텍처 개념들\n\n- Clean Architecture [여기를 클릭하여 참고](https://blog.cleancoder.com/uncle-bob/2012/08/13-the-clean-architecture.html)\n- 고급 iOS 앱 아키텍처 [여기를 클릭하여 참고](https://www.raywenderlich.com/8477-introducing-advanced-ios-app-architecture)\n- MVVM\n- 데이터 바인딩\n- 의존성 주입\n- SwiftUI 및 UIKit 뷰 구현: 동일한 ViewModel 재사용 (최소 Xcode 11 필요)\n\n## 요구 사항\n\n- Xcode 버전 11.2.1 이상, Swift 5.0 이상\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# VPN\n\nVPN은 가상 사설 네트워크를 의미합니다. 다가오는 기사에서 VPN 서버를 설치하는 방법을 알아볼 것입니다. 앱을 개발하기 위해 iOS에서 사용할 수 있는 VPN 프로토콜을 정의할 것입니다. 애플 문서에 따르면 개인 VPN을 위해 IKEv2 및 IPsec 프로토콜을 지원할 수 있습니다. 네트워크 확장 및 능력에 대해 알아볼 것을 제안합니다.\n\n이 앱 개발을 시작했을 때 안드로이드와 iOS 두 플랫폼을 대상으로 지정하고 싶었습니다. 따라서 둘 다 작동할 수 있는 VPN 프로토콜을 사용하고 싶었고 오랜 시간을 투자해 조사하고 시도한 결과 IKEv2를 사용하는 것이 최선임을 알게 되었습니다.\n\nIKEv2가 무엇인지 이곳에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 코딩을 시작해봐요 🎉 💻\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_5.png\" /\u003e\n\n이렇게 마크다운 형식으로 코드를 작성하면 가독성이 높아지고 좋아요! 코딩을 시작하기 전에 앱에 무엇을 원하는지에 대해 조금 이야기해봐요! 간단하게 3개의 씬에서 작업하고 스토리보드를 사용할 거에요 🤒\n\n- OnboardigViewController\n- DashboardViewController\n- InAppPurchaseProViewController\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_6.png\" /\u003e\n\n## 코딩\n\n새 프로젝트를 만들고 원하는 이름을 지정할 수 있지만, 이 튜토리얼에서는 VPN Guard와 Secure VPN이라는 2개의 이름이 있습니다. VPN Guard는 여기서 참조로 사용할 Secure VPN을 기반으로 합니다.\n\n프로젝트를 명확하게 유지하는 가장 좋은 방법은 폴더를 구성하는 것이니, 우선 그 폴더들을 생성해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Screenshot 1](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_7.png)\n\nAfter grouping all the layers we have: Domain, Presentation, and Data Layers.\n\n![Screenshot 2](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_8.png)\n\nThe domain layer is totally isolated, the innermost part of the onion. This layer can be reused in other projects.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프레젠테이션 레이어에는 뷰 컨트롤러와 뷰 모델, XIB, SwiftUI 뷰 등 UI가 포함되어 있습니다. 뷰는 한 개 또는 여러 개의 유즈 케이스를 실행하는 뷰모델에 의해 조정됩니다. 프레젠테이션 레이어는 도메인 레이어에만 의존합니다.\n\n데이터 레이어에는 리포지토리 구현과 한 개 또는 여러 개의 데이터 소스가 포함됩니다. 리포지토리는 로컬 또는 외부의 다른 데이터 소스에서 데이터를 조정하는 역할을 합니다. 프레젠테이션 레이어와 마찬가지로 도메인 레이어에만 의존하며 매핑 및 디코딩 로직을 포함할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_9.png)\n\niOS에서 아키텍처 패턴에 대해 더 알고 싶으시면 여기에 댓글을 남겨주시면 더 자세한 내용의 아키텍처 패턴에 대한 다른 이야기를 올릴게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 대시보드 뷰 컨트롤러\n\n이제 대시보드 디자인을 구축할 수 있습니다. 가운데에 버튼이 있을 것입니다. 사용자가 해당 버튼을 탭하면 VPN 서버와의 연결을 설정할 것입니다.\n\nUILabel은 연결 상태를 표시할 것입니다.\n\n상단의 UIImage/UILabel은 사용자가 무료 또는 프로인지 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가운데에 VPN 서버의 국가 이름과 함께 국기 아이콘을 표시할 수 있습니다. 이 위에는 파이어베이스에서 가져온 VPN 서버 목록을 트리거하는 UIButton이 있을 것입니다.\n\n현재 공개 IP 주소를 표시하는 UILabel입니다.\n\n![이미지](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_10.png)\n\nAppDIContainer와 연결된 스토리보드와 인스턴스화할 viewController를 연결하기 위해 StoryboardInstantiable 프로토콜을 만들 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`instantiateViewController` 메서드는 fileName을 확인하며 이는 스토리보드 `DashboardViewController.swift`, `DashboardViewController.storyboard`의 동일한 이름이어야 하고 해당 스토리보드에서 ViewController를 생성하고 반환합니다.\n\n따라서, 우리의 DashboardViewController는 StoryboardInstantiable 프로토콜을 준수하며 DashboardViewController를 반환할 클래스 메서드를 정의할 것입니다.\n\n```swift\nfinal class func create(viewModel: DashboardViewModel) -\u003e DashboardViewController {\n```\n\n```swift\nlet view = DashboardViewController.instantiateViewController()\n    return view\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 ViewModel을 할당하기 위해 이 함수를 사용할 것입니다.\n\n연결 버튼을 viewController와 연결하고 클로저 내에서 액션 아웃렛으로 설정한 후에, 다음의 코드 라인을 추가합니다:\n\n```js\nviewModel.connectDisconnect();\n```\n\n이렇게 하면 물론 ViewModel이 없다는 오류가 발생할 것입니다. 걱정 마세요. 우리의 목표는 DashboardViewController용 ViewModel을 생성하는 것이기 때문에, viewController 내부에서 정의를 해볼 겁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprivate(set) var viewModel: DashboardViewModel!\n```\n\n그리고 이것은 DashboardViewModel 파일을 생성합니다. 이전에 말한대로 ViewModel은 하나 이상의 사용 사례를 가지므로, 뷰 모델의 책임은 서버에 연결/연결 해제를 트리거하는 것에 대해 고려해야 합니다.\n\nDashboardViewModel을 위해서 우리는 입력/출력을 정의합니다.\n\n이렇게 함으로써, 이 viewModel이 무엇을 할지 전체 아이디어를 가지게 될 것이며 나중에 필요하다면 새로운 기능을 추가할 수 있는 기회를 얻게 됩니다. 현재 VM의 로직이 복잡하기 때문에 새로운 것을 만들어도 기능은 변경되지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDashboardViewModelRoute는 이름에서 알 수있듯이 라우트를 포함하는 enum입니다.\n\nDashboardViewModelLoading은 서버에 연결하거나 API에서 데이터를 가져올 때 현재 상태를 View에 알릴 때 사용하는 enum입니다.\n\n여기서 viewModel을 엿볼 수 있습니다.\n\n## 사용 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 대시보드 뷰컨트롤러와 그 뷰모델이 준비되었으니, 사용 사례를 시작할 때입니다. 사용 사례는 도메인 레이어에 추가됩니다. 따라서 NetworkVPNUseCase를 만듭니다.\n\nVPN의 주요 사용 사례는 연결, 연결 해제, 구성 로드, 상태 가져오기이며, 서버를로드하기 위해 API를 사용하는 경우 서버 가져오기를 추가할 수 있습니다.\n\n다음과 같이 원하는 모든 경우를 포함하는 프로토콜을 정의합니다:\n\nNetworkVPNUseCase에 준수하는 DefaultNetworkVPNUseCase라는 final 클래스를 만듭니다. 아직 Data 레이어에 주입될 Repository가 누락되어 있습니다. 이 Repository에는 NetworkVPNUseCase의 동일한 경우가 있을 것입니다. 따라서 도메인에 이를 추가하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경로: Domain/interfaces/Repositories/\n\nDefaultNetworkVPNUseCase로 돌아가서 레포지토리의 private 속성을 선언합니다.\n\n```js\nprivate(set) var vpnManager: DVPNRepository\n```\n\n여기서 사용 사례 클래스의 최종 모습을 찾을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알다시피, 도메인 레이어는 격리되어 있고 내부에서는 제3자를 사용하지 않습니다. 따라서 NEVPNStatus에서 매핑할 VPN 상태 NetworkVPNStatus를 처리하기 위해 특별한 enum을 만들었습니다.\n\n이제 NetworkVPNUseCase를 완료한 후에는 DashboardViewModel로 돌아가서 사용 사례를 주입하면 됩니다. 곧 다시 그 부분으로 돌아갈 겁니다.\n\n## 데이터\n\n데이터 레이어 내에서 VPNRepository 및 VPNManager를 생성하여 연결 설정, 구성 로드 및 연결 해제 과정을 모두 처리할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1- IPSec/IKEv2 연결\n\n먼저 앱에 새로운 기능을 추가해야 합니다. 따라서 프로젝트를 선택하여 로그인 및 기능 설정으로 이동하세요.\n\n![앱이미지](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_11.png)\n\n왼쪽 상단의 기능을 클릭하고 개인 VPN을 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 테이블 형식을 Markdown 형식으로 바꿔주세요.\n\n|                                   이미지                                    |\n| :-------------------------------------------------------------------------: |\n| \u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_12.png\" /\u003e |\n|                             Keychain 공유 추가                              |\n| \u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_13.png\" /\u003e |\n|  Keychain에는 keychain 그룹 도메인을 추가하여 필요한 내용을 추가해주세요.   |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_14.png\" /\u003e\n\n## 설정\n\n다행히도 애플은 타사 라이브러리 없이 IPsec/IKEv2를 사용하여 VPN에 연결할 수 있는 좋은 API 세트를 제공합니다.\n\n코딩을 시작하기 전에 어떻게 작동하는지 설명해 드릴게요. DefaultVPNManager는 다음을 수행할 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 환경 설정 불러오기\n\n2. 새로운 값으로 환경 설정 변경하기 (사용자 이름, 비밀번호, 호스트 등)\n\n3. 환경 설정 저장하기\n\n4. 연결 시작하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정이 없는 경우에도 먼저 선호도를 로드한다는 것이 이상하게 들릴 수 있습니다. 그러나 이것이 애플이 일을 하는 방법입니다. 만약 로드하기 전에 설정을 저장했다면, 프로세스가 실패할 것입니다.\n\n비밀번호와 공유 키는 키체인에 저장됩니다. 나중에 키체인에 관한 기사를 쓸 예정이니, 준비되면 언제 인터넷에 올릴지 물어봐주세요 🙂 혹은 트위터에서 저를 팔로우해주세요 🐦(아직 제 계정은 새로운 상태입니다).\n\n![image](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_15.png)\n\nDefaultVPNManager는 Data/VPNManager/Repository에 위치한 VPNRepository를 준수할 것입니다. 이 프로토콜은 속성과 함수를 보유할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNEVPNManager은 여기에서 필요한 것입니다. VPN 구성을 생성하고 관리할 수 있는 능력을 제공합니다. Apple 문서를 여기에서 확인하세요. 🍏\n\nNEVPNManager의 인스턴스를 가지려면 NEVPNManager 프로토콜의 확장을 만들었습니다. 이것은 코딩을 하는 동안 우리의 삶을 좀 더 쉽게 해줄 것입니다.\n\n매니저를 호출할 때 NEVPNManager에 대한 참조를 계산된 값으로 얻게 됩니다. 더 많은 세부 정보는 여기에서 Swift의 속성에 대해 확인하세요.\n\n상태는 VPN의 현재 상태를 반환하며, 이것이 왜 새로운 enum을 생성하여 도메인 레이어 내에서 NetworkExtension을 사용하지 않을 이유입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`registerNotification()` 함수는 VPN 상태가 변경될 때 알림을 받습니다. NotificationCenter를 사용하는 이유는 `vpnManager.connection.startVPNTunnel()` 메서드가 성공해도 실제로 연결이 성립된 것은 아니고 VPN 터널 설정이 성공적으로 시작된 것을 의미하기 때문입니다. 따라서 실제 상태를 얻기 위해 우회 처리를 해야 했습니다. 곧 몇 분 안에 작동 방식을 확인하실 수 있을 거에요.\n\nDefaultVPNManager로 돌아가서 여기서 확인할 수 있습니다. `#if targetEnvironment(simulator)`와 같은 컴파일 조건이 있는 것을 알게 될 거에요. 아쉽게도 시뮬레이터에서 VPN이 작동하지 않기 때문에 UI 디버깅 중 충돌을 방지하기 위해 추가했습니다.\n\n또한, `manager.loadFromPreferences`와 `manager.saveToPreferences` 콜백은 비동기적으로 동작합니다.\n\n구성을 저장할 때, 먼저 사용 중인 프로토콜을 정의해야 합니다. 제 경우, 어플리케이션은 IPSec 및 IKEv2 둘 다 허용할 수 있습니다. 따라서 여기서 서버의 프로토콜 유형을 확인하여 해당 유형에 맞게 연결 및 구성을 시도하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIPSec에 대해:\n\n```js\n경우 .IPSec:\n```\n\n```js\nlet p = NEVPNProtocolIPSec();\n```\n\n```js\np.useExtendedAuthentication = true;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```javascript\np.localIdentifier = account.localID ?? \"VPN\";\n```\n\n```javascript\np.remoteIdentifier = account.remoteID;\n```\n\n```javascript\nif account.pskEnabled {\n```\n\n```javascript\np.authenticationMethod = .sharedSecret\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\np.sharedSecretReference = account.getPSKRef();\n```\n\n```js\n} else {\n```\n\n```js\np.authenticationMethod = .none\n```\n\n```js\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npt = p;\n```\n\nIKEv2의 경우:\n\n```js\ncase .IKEv2:\n```\n\n```js\nlet p = NEVPNProtocolIKEv2();\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```json\np.useExtendedAuthentication = true\n```\n\n```json\np.localIdentifier = account.localID\n```\n\n```json\np.remoteIdentifier = account.remoteID\n```\n\n```json\nif (account.pskEnabled) {\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\np.authenticationMethod = .sharedSecret\n```\n\n```js\np.sharedSecretReference = account.getPSKRef();\n```\n\n```js\np.passwordReference = account.getPasswordRef();\n```\n\n```js\n} else {\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\np.authenticationMethod = .none\n```\n\n```js\n}\n```\n\n```js\np.deadPeerDetectionRate = .medium\n```\n\n```js\npt = p;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nconfigOnDemand에 대해 지금은 해당 사항이 아니기 때문에 구성하지 않을 거에요.\n\n이제 개인 VPN을 구성한 후에는 도메인 레이어 리포지토리를 데이터 레이어에 주입할 시간이에요. 이를 위해 /Data/Repository 안에 createDefaultVPNRepository final 클래스를 만들 것이에요.\n\n우리는 DefaultVPNRepository를 DVPNRepository에 준수하도록 만들 것이며, 이를 사용할 수 있게 될 거에요. 전체 코드는 여기에서 확인할 수 있어요.\n\n이제 DashboardViewModel 설정을 완료할 준비가 되었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 대시보드 뷰모델 파트 2:\n\n뷰모델 안에서 다음과 같이 private 속성을 설정하였습니다:\n\n```js\nprivate var networkVPNUseCase: NetworkVPNUseCase\n```\n\n```js\ninit(networkVPNUseCase: NetworkVPNUseCase) {\n   ...\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 VPNManager에서 설정한 VPN 상태를 가져오기 위해 observer를 등록했어요.\n\n```js\nNotificationCenter.default.addObserver(self, selector: #selector(statusDidChange(_:)), name: NSNotification.Name.NEVPNStatusDidChange, object: nil)\n```\n\nstatusDidChange는 상태가 변경될 때 레이블을 업데이트할 거예요.\n\nviewDidLoad에서는 ViewModel에게 구성을 로드하도록 알릴 거예요. DefaultDashboardViewModel 쪽에서는 이렇게 될 거예요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunc viewDidLoad() {\n      self.observeStatus()\n      self.networkVPNUseCase.loadVPNConfig {}\n}\n```\n\n대시보드뷰컨트롤러의 connect 버튼을 누르면 ViewModel에게 연결 설정이 끊겨 있는지를 확인하고, 현재 상태가 연결된 상태인 경우에는 연결을 끊어야 한다고 알려줍니다.\n\n```js\nfunc didConnect() {\n    networkVPNUseCase.connect(configuration: vpnAccount.value)\n}\n```\n\n```js\nfunc didDisconnect() {\n    self.networkVPNUseCase.disconnect()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 논리는 어디에서 처리될까요? MVVM에서는 뷰가 어떤 종류의 논리도 처리해서는 안 되며, 현재 상태/동작을 ViewModel에만 알리고 VM이 적절한 동작을 수행해야 합니다. 이 논리를 수행하는 방법은 다음과 같습니다:\n\n```js\nfunc connectDisconnect() {\n    if status.value == .connected || status.value == .connecting {\n        self.networkVPNUseCase.disconnect()\n    } else if (status.value == .disconnected || status.value == .invalid) {\n        self.networkVPNUseCase.connect(configuration: vpnAccount.value)\n    }\n}\n```\n\n기본적으로 우리는 NSNotification.Name.NEVPNStatusDidChange를 통해 받은 상태를 확인하여 연결 또는 연결 해제합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 부분에서 놓친 부분은 ViewModel을 바인딩하는 것 뿐입니다.\n\n따라서 ViewController 내에서 viewDidLoad에서 bind(viewModel)를 수행합니다.\n\n여기서 bind()는 옵저버의 키를 설정하는 private 함수입니다.\n\n```js\nprivate func bind(_ viewModel: DashboardViewModel) {\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nviewModel.loadingType.observe(on: self, observerBlock: { [weak self] in self?.handleLoading($0)})\n\nviewModel.status.observe(on: self, observerBlock: { [weak self] in self?.handleConnectionStatus($0)})\n\nviewModel.route.observe(on: self, observerBlock: { [weak self] in self?.handleRouting($0)})\n\nviewModel.premiumStatus.observe(on: self, observerBlock: { [weak self] in self?.handlePurchaseStatus($0)})\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nviewModel.vpnAccount.observe(on: self, observerBlock: {[weak self] in self?.handleVPNSelection($0)})\n```\n\n```js\nviewModel.currentIP.observe(on: self, observerBlock: {[weak self] in self?.handleIPUpdates($0)})\n```\n\n```js\nviewModel.loadRequestAd.observe(on: self, observerBlock: {[weak self] in if $0 { self?.interstitial.load(GADRequest())}})\n```\n\n```js\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRx 대신 Observable 대신 RxSwift 라이브러리를 사용할 수 있어요.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*BwR548YaWSxEhs7RjlHzPw.gif)\n\n# 다음 파트가 곧 업데이트될 예정입니다\n\n## ✌️이 튜토리얼을 계속 진행하고 싶다면 여기나 Twitter에서 팔로우해주세요. 궁금한 점이 있으면 언제든지 물어보세요, 최선을 다해 답변해드릴게요 ❤️\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 👉 [파트 2]\n","ogImage":{"url":"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_0.png"},"coverImage":"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_0.png","tag":["Tech"],"readingTime":24},{"title":"여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지","description":"","date":"2024-06-23 01:40","slug":"2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen","content":"\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_0.png)\n\n과장이 아니지만, 숏컷(Shortcuts)은 아이폰에서 가장 과소평가된 앱입니다. 사용자들이 자신의 삶을 자동화하고 더 생산적으로 유지하는 미니 앱을 만들 수 있게 해줍니다.\n\n가장 좋은 점은, iOS 시스템 설정을 조정하고 조작할 수 있는 능력을 가지고 있다는 것입니다 - 제3자 앱들은 상상조차 할 수 없는 기능입니다.\n\n너무 강력해서 안타깝게도 잘 활용되지 못하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 11가지 복잡하고 고급 단축키에 대해 설명해 드릴게요 — 저는 대부분 이것들을 정기적으로 사용해요.\n\n# #1. 자동 메시지\n\n이 단축키는 연락처에 메시지를 예약해서 보낼 수 있게 도와줍니다 — 이는 기본 Messages 앱이 제공하지 않는 기능이에요 (Mail은 제공합니다).\n\n어떻게 할까요? 리마인더를 이용해서요.\n제가 설명해 드릴게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단축키를 시작하려면 다음을 수행해야 합니다: - 미리 알림 앱에서 새 목록을 생성합니다. 그리고 자동 메시지에 등록하여 작업에 사용하도록 설정합니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_1.png)\n\n이제 이런 작업을 찾기 위해 단축키를 트리거하십시오: (iOS 및 macOS에서 작동합니다)\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 옵션으로 메시지를 개별 연락처에 예약하는 기능을 시도해 보세요.\n\n클릭하면 다음을 안내합니다:\n\n- 연락처를 선택하세요,\n- 메시지를 입력하세요 (기본값: 클립보드),\n- 이미지를 첨부하세요 (와!),\n- 날짜와 시간을 선택하세요.\n\n선택한 시간을 기준으로 모든 세부 사항이 포함된 리마인더가 생성됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_3.png)\n\n설정된 시간에 알림을 받으면 URL을 간단히 탭하세요.\n\n그럼 해당 바로 가기가 이미지를 자동으로 검색하고 메시지를 가져와 선택한 Messages 또는 WhatsApp을 통해 연락처에게 전송합니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정말 멋지죠!\n\n자동으로 되지는 않지만, 특정 시간에 사람들에게 메시지를 보내놓을 것을 잊지 않도록 도와주는 매우 유용한 바로 가기 기능이에요.\n\n그리고 더 멋진 건, 아래와 같은 것을 할 수 있답니다.\n\n- 바로 가기 내에서 즐겨찾기 및 그룹 생성할 수 있어요.\n- 개별, 그룹 또는 다중 그룹에 메시지를 보낼 수 있어요.\n- 메시지를 재스케줄하거나 취소할 수 있어요.\n  (팁: 이를 직접 알림을 조정하여 할 수 있어요)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n직관적인 스크린샷이 지루할 수 있지만, 그 장치의 이미지로 프레임을 설정하면 환상적으로 보입니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 애플 블로거로서, 그것을 해야만 합니다. 제 기사들의 대부분의 스크린샷은 프레임 안에 삽화되어 있거든요.\n\n그렇다면 어떻게 하는 건가요?\n\n- Mac을 사용할 때는 Mockuuups Studio를 사용해요 (어필리에이트 링크 아님).\n- Mac이 근처에 없을 때는 iPhone에서 iFrames라는 단축키를 사용해요—그 앱만큼 강력해요.\n\niFrames가 어떻게 작동하는지 알아보세요:\n실행하면 iPhone, iPad, Mac, Apple Watch 또는 Apple TV에서 찍은 스크린샷과 해당 프레임으로 사용하고자 하는 기기를 요청합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n거의 다 이제 맥 모의도를 로컬에 저장할 수 있습니다.\n\n그게 끝이 아니에요, 여기 최고의 부분입니다:\n\n- 거의 모든 애플 장치가 iFrames에서 사용 가능합니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모의 모형을 생성하는 데 10초 미만이 걸립니다(안정적인 인터넷 연결 상태에서).\n- 자주 사용하는 프레임이 있다면 상단에 고정시키거나 오프라인으로 사용할 수도 있습니다!\n- iFrames는 사용 중인 기기를 자동으로 감지하고 상단에 제안합니다.\n- 스크린샷이 수평으로 보일 경우 어느 쪽에 배치할지 물어봅니다. (와우!)\n- 여러 스크린샷을 선택하면 세로, 가로 또는 그리드 형식으로 원하는대로 출력물을 결합할 수 있습니다. 예시:\n\n![Example Image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_7.png)\n\n또는 여기에서 직접 다운로드하세요.\n\n## 3. Song.Link\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 Apple Music을 좋아하는 팬인데, 제 친구들 대부분은 Spotify를 사용해요. 특히 안드로이드 기기를 사용하는 친구들이 그렇더라고요.\n\n그래서 Apple Music에서 좋아하는 노래를 발견했을 때, 그 노래를 친구에게 공유하고 싶다면요. 그러나 친구가 Apple Music을 사용하지 않으니 그냥 직접 링크를 보내는 것은 의미가 없겠죠?\n\n또, 제가 Spotify에서 직접 검색하여 링크를 보내는 것은 조금 후하진 않아요.\n\n그래서 제가 하는 방법은 — Song.Link(바로 가기)로 그 노래를 공유하는 거예요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_8.png)\n\nIt does the mundane job of retrieving the song’s links from all popular music platforms like Spotify, YouTube, Pandora, Amazon, \u0026 SoundCloud.\n\nThen I click Spotify and directly share its link to him, simple!\n\n![Image 2](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_9.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가장 좋은 부분은 곡을 Song.Link에 입력하는 방법이 5가지나 있답니다:\n\n- 클립보드에 있는 링크를 통해,\n- Apple Music에서 \"Now Playing\"으로 재생 중인 곡을 통해,\n- Shazam을 이용해,\n- iTunes 스토어에서 검색해,\n- 또는 키보드로 URL을 입력해요.\n\n또는 직접 다운로드할 수도 있어요.\n\n# YouTube의 단축키\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #4. SW-DLT\n\n내가 iPhone에서 YouTube 동영상을 다운로드하는 방법에 대해 알려줄게 — 엄청 쉬운 방법이야.\n\n우선, 설치해야 할 것이 있어. 바로 SW-DLT\\*와 두 앱 중 하나 — a-Shell 또는 a-Shell mini. 공간을 절약하려면 후자를 선호해.\n\n이제, 과정을 시작해보자:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Safari나 YouTube 앱에서 비디오를 열기\n- SW-DLT로 공유하기\n- '비디오 다운로드' 선택\n- 선호하는 품질과 프레임률 선택\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_10.png)\n\n그리고 비디오 다운로드가 시작됩니다…\n다운로드가 완료되면 즉시 시청할 수 있습니다. 저장하려면 공유`비디오 저장`을 클릭하십시오.\n\n무려 SW-DLT는 YouTube뿐만 아니라 다양한 웹사이트에서 미디어를 다운로드할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**YouTube PiP 기능은 SW-DLT -DL 도구를 위한 단축키 래퍼입니다.**\n\n- 비디오에서 오디오만,\n- 비디오 또는 오디오의 전체 재생 목록,\n- 전체 웹 페이지에서 미디어(GIF, 클립, 이미지)만.\n\n또는 직접 여기에서 다운로드하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nYouTube는 PiP(화면 안 화면) 기능을 프리미엄 구독자를 대상으로 한정했어요.\n\n만약 iPhone에서 무언가 다른 일(생산적인 일을 하길 희망합니다)을 하면서 영상을 시청하는 것을 선호한다면, 이 기능은 굉장히 편리할 거예요.\n\n돈을 지불하지 않고도 이를 실현하기 위한 해킹 방법이 있답니다 — YouTube PiP, 바로가기를 이용해보세요.\n\n- Safari나 YouTube 앱에서 동영상 열기\n- 'YouTube PiP'로 공유하기\n- 동영상 로드될 때까지 잠시 기다리기\n- 화면을 최소화하기.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 작업을 할 때 동영상이 계속 PiP로 재생됩니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_11.png)\n\n또는 여기에서 직접 다운로드할 수도 있어요.\n\nPS: 또 다른 방법으로 할 수 있는 방법이 있습니다 (앱을 사용하여) ↓\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# #6. 일부 알람 설정하기\n\n우리 인간들은 본질적으로 게으릅니다.\n그것에는 이유가 있습니다. 그것은 조상들이 에너지를 절약하여 다음 사냥을 위해 남긴 특성입니다.\n\n21세기에 있어서는 우리에게 불운이 될 때도 있습니다... 저는 종종 iPhone의 울리는 알람을 끄고 다시 누우면서 늦게 일어나는 바람에 느낍니다.\n\n그래서 나는 나를 괴롭히고 침대에서 일어나게끔 5분 간격으로 여러 개의 알람을 설정했습니다. - 그리고 많은 사람들이 비슷한 일을 한다고 확신합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자체적으로 모두 설정하는 대신 저는 이 바로가기를 사용해요: Set Some Alarms.\n\n이 바로가기를 사용하면\n\n- 특정 시간,\n- 설정할 총 알람 수,\n- 간격,\n- 알람이 지정된 시간에 시작할지 끝낼지를 선택할 수 있어요.\n\n그리고 다음 낮잠에서 깨워 줄 알람을 즉시 생성해 줘요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_12.png)\n\n요즘 내가 써본 최고의 부분은 첫 번째 알람이 울리기까지 얼마나 남았는지 보여준다는 거야 — MIUI를 사용했던 예전에도 좋아했던 기능이야.\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_13.png)\n\n# #7. DND 메뉴\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 및 macOS에서는 Do Not Disturb(또는 다른 포커스 모드)를 영구적으로 켜거나, 다음 세 가지 옵션에 따라 사용할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_14.png)\n\n안타깝게도 Apple은 이를 이벤트 종료 후 자동으로 꺼지거나 설정된 시간이 지난 후에 꺼지는 등의 기능을 기본적으로 허용하지 않습니다.\n\n그러나 DND Menu라는 바로 가기를 통해 이러한 기능을 사용할 수 있습니다. 이 바로 가기를 실행하면 두 가지 옵션을 볼 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_15.png)\n\n만약\n\n- 첫 번째 옵션을 선택하면, DND 포커스는 다음 캘린더 이벤트가 끝날 때까지 켜집니다.\n- 두 번째 옵션을 선택하면, DND가 유지될 시간을 설정할 수 있습니다.\n\n멋지죠!\n다음 20분 동안 집중하고 싶을 때나 30분 동안 주의를 집중시키고 싶을 때 큰 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해 드리겠습니다.\n\n또는 수정된 버전(제가 수정한 것)을 여기서 다운로드하세요.\n\n## #8. QR Anything\n\nQR Anything - 맞죠 - QR 코드로 거의 모든 것을 변환할 수 있습니다. 지원되는 형식:\n\n- Wi-Fi 네트워크\n- 이미지\n  (익명으로 Imgur에 업로드되고 해당 링크가 QR 코드로 변환됩니다)\n- URL\n- 텍스트\n- 클립보드 내용\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 트리거하면:\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_16.png)\n\nQR 코드로 변환하고 싶은 것을 선택하고 제공된 단계를 따라 주세요.\n\n만약 커피숍을 운영 중이라면, 고객들이 와이파이 비밀번호를 입력하는 데 어려움을 겪는 대신 네트워크를 위한 QR 코드를 만들어서 스캔하도록 하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혹시 링크를 QR 코드로 변환하고 친구를 속일 수도 있겠네요.\n\n그리고 더 좋은 점은, 어떤 것을 QR 코드로 변환하고 싶을 때는 'QR Anything'을 직접 공유 시트를 통해 공유하면 되니까, 바로 당신 스스로 단축키를 실행시킬 필요가 없다는 거죠.\n\n아니면 여기서 바로 다운로드도 받을 수 있어요.\n\n## 9. Google 번역\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGoogle 번역을 앱이나 웹사이트 없이 사용할 수 있는 단축키입니다. 무료 API를 이용하여 빠릅니다.\n\n이 단축키를 실행하면 자주 번역할 언어를 입력하라는 메시지가 표시됩니다. 이것은 나중에 바꿀 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_17.png)\n\n이제 번역을 시작하려면, 그냥 단축키를 실행하면 되요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 영어로 된 내용을 입력하세요,\n- 번역하고 싶은 언어를 선택하세요.\n\n그리고 1-2초 이내에 번역된 텍스트를 받게 됩니다. 복사 또는 공유할 수 있습니다.\n\n하지만, 만약 네덜란드어(또는 다른 언어)에서 번역하고 싶다면 이렇게 해보세요:\n\n\u003cimg src=\"/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_18.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 텍스트를 친절한 어조로 한국어로 번역하겠습니다:\n\n입력 텍스트: input_text\n언어: input_text_language\n\n위 내용을 포함한 딕셔너리를 만들어 ‘Google 번역’에 전달하십시오. 이제 이전과 같이 input_text를 원하는 언어로 번역할 수 있습니다.\n\n신기하죠?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 바로 다운로드할 수도 있어요.\n\n## #10. PowerUtil\n\n내 iPhone 배터리가 새 것일 때의 성능의 80%를 유지하고 있는지 여부를 아시나요? 500번의 충전 주기를 거치면 그렇습니다.\n\n(충전 주기란 배터리가 100%와 동등한 수준으로 방전될 때를 의미합니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n충전 주기 수는 배터리 수명에 대해 걱정하는 사람이라면 추적해야 할 중요한 지표입니다.\n\n하지만 안타깝게도, Apple은 사용자들에게 액세스 권한을 제공하지 않는다. 죄송합니다. 아래는 iPhone 15 시리즈 사용자를 위한 정보가 있습니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_19.png)\n\n음… 저는 iPhone 14 Pro Max를 사용 중이에요 (그리고 업그레이드할 확실한 이유가 없어요).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 아이폰 15 시리즈가 이를 표시하지 않는다는 것은 배터리 사이클을 추적하지 않는다는 것뿐만이 아닙니다. 그들은 하지만, 애플이 그들을 표시하지 않도록 프로그래밍했습니다.\n\n애플을 물어버려 .\n\n아이폰 15 시리즈를 사용하는 경우 배터리 사이클 수를 확인하는 방법은 다음과 같습니다:\n\n- 바로 가기인 PowerUtil을 설치합니다.\n- 설정으로 이동 ⚙️ `개인정보 및 보안 ✋` 분석 및 향상.\n- '아이폰 분석 공유' 아래의 '분석 데이터'를 클릭합니다.\n- 이름이 Analytics-20XX로 시작하는 (가장 최근의) 파일을 찾아 터치합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_20.png)\n\n- PowerUtil에 공유하기 (우측 상단의 공유 아이콘을 클릭하세요)\n\n![Image 2](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_21.png)\n\n- 이제 잠시 기다리고 나타나는 것을 확인해보세요. 여기엔 제 것이 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_22.png\" /\u003e\n\n와우! 멋져요! 내 배터리에 대한 정보를 보여주네요\n\n- 소비된 배터리 사이클 횟수,\n- 평균 온도,\n- 배터리 상태,\n  (설정에서 확인할 수 있습니다 ⚙️ `배터리 🔋` 배터리 상태 및 충전)\n- 더 정확한 배터리 상태.\n  (PowerUtil의 고유 알고리즘으로 계산됨)\n\n```js\n참고: 아이패드 사용자에게 더 유용할 수 있습니다 - 애플은 기본적으로 배터리 상태를 공개하지 않는 사용자들을 위한 것입니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(Analytics-20XX 파일에는 Cycle Count, 평균 온도 및 배터리 상태가 깊숙한 곳에 기록되어 있습니다. 단축키를 사용하면 정규식을 이용하여 이를 찾아서 표시합니다.)\n\n그런데 배터리 사이클을 확인하는 데 이 정도의 노력이 정말 필요한가요? 왜 애플이 iPhone 15 사용자들을 위해 이를 표시할 수 없는지 이해가 안 가요?\n\n```js\n참고: 'iPhone Analytics 공유'가 켜져 있어야 합니다.\n```\n\n또는 여기에서 직접 다운로드할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# #11. Snap (Mac 전용)\n\n나는 항상 창 관리를 위해 앱들을 사용해 왔어요. Magnet, Moom, Mozaic, One Menu, Spectacle, Swish 같은 앱들 말이죠. 그런데 단축키만 있으면 가능하다는 생각은 한 번도 안 해봤어요.\n\nSnap을 만나봐요.\n\nSnap은 창 관리자의 경량화된 단축키 버전으로, 간단하게 보이지만 실제로는 복잡한 코드가 내장되어 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 사용 방법이 있습니다:\n(먼저, 단축키에서 Snap을 마우스 오른쪽 버튼 클릭하고 ‘도크에 추가’를 클릭하십시오.)\n\n- 데스크톱에 활성 창을 유지합니다 (전체 화면이 아니고, 이름이 상단 왼쪽 구석에 Apple  로고 옆에 표시되는지 확인하십시오).\n- 도크에서 Snap을 트리거합니다.\n- 윈도우를 14가지 옵션 중 하나로 원하는 스냅 위치로 선택합니다:\n\n![snap](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_23.png)\n\n- 클릭하고 완료를 클릭합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그게 전부고, 창이 원하는 레이아웃에 맞게 자동으로 정렬됩니다. 제가 함께 한 내용 중 하나를 보여드릴게요:\n\n가장 좋은 부분은,\n\n- 정렬 위치를 변경하거나 원하지 않는 위치를 제거할 수 있습니다.\n- 스냅은 다른 바로 가기 키로부터 입력을 지원합니다:\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_24.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n재밌는 사실:\nSnap은 MacStories가 주최한 Automation April 대회에서 \"최고의 Mac 바로 가기\"상을 수상했습니다.\n```\n\n또는 바로 여기에서 다운로드할 수도 있습니다.\n\n## 마음에 드셨나요? 더 많은 유용한 Apple 바로 가기를 원하시나요?\n\n## 마지막으로,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면, Setapp에 가입하는 것을 고려해보세요. 매달 $9.99에 약 240개 이상의 멋진 앱을 소장할 수 있습니다. 이 앱을 개별로 구매하면 수백 달러가 들겠지요.\n\n- Setapp 여정을 시작하는 데 내 제휴 링크를 사용해보세요! (30일 동안 무료입니다)\n- Setapp에서 100개 이상의 최고의 macOS 앱 목록을 무료로 받아보세요.\n\n만약 이 이야기를 즐겼다면, 다른 사람들과 함께 새로운 이야기를 게시할 때마다 알림을 받기 위해 430명 이상의 구독자들에 합류해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_0.png"},"coverImage":"/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_0.png","tag":["Tech"],"readingTime":21},{"title":"SWIFT에서 STRUCT와 CLASS 비교 분석","description":"","date":"2024-06-23 01:38","slug":"2024-06-23-STRUCTvsCLASSinSWIFT","content":"\n스위프트에서는 Struct와 Class를 모두 사용하지만 언제 어떤 것을 사용해야 하는지와 그 차이점이 무엇인지 혼란스러울 수 있습니다. 이 둘 사이의 주요 차이점은 다음과 같습니다:\n\n![Struct vs Class in Swift](/assets/img/2024-06-23-STRUCTvsCLASSinSWIFT_0.png)\n\n구조체: 구조체는 값 타입으로, 각 인스턴스가 데이터의 고유한 복사본을 유지합니다. 한 인스턴스를 수정해도 다른 복사본에는 영향을 미치지 않습니다. Struct 인스턴스는 스택에 할당됩니다.\n\n더 나은 이해를 위해 예시를 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct Person {\n    var name: String\n}\n\nvar person1 = Person(name: \"Joy\")\nvar person2 = person1\n\nprint(person1.name) //prints \"Joy\"\nprint(person2.name) //prints \"Joy\"\n\nperson2.name = \"Mary\"\n\nprint(person1.name)//prints \"Joy\"\nprint(person2.name)//prints \"Mary\"\n```\n\n위 예제에서는 Person의 인스턴스인 person1을 만들었습니다. 이제 person1의 데이터를 복사하여 새 인스턴스 person2가 생성됩니다. 이 시점에서 person1과 person2는 초기값이 같은 두 개의 별도 인스턴스입니다. 따라서 person2를 수정해도 person1에는 영향을 미치지 않습니다.\n\n클래스: 클래스는 참조 유형이며, 클래스 인스턴스를 할당할 때 메모리 내의 동일한 인스턴스에 대한 참조를 전달합니다. 어떤 인스턴스에서 변경을 가하면 동일한 메모리를 가리키고 있는 다른 모든 인스턴스에 영향을 줍니다. 클래스 인스턴스는 힙에 할당됩니다.\n\n더 나은 이해를 위해 위 예제를 클래스 관점에서 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass Person {\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n}\n\nvar person1 = Person(name: \"Joy\")\nvar person2 = person1\n\nprint(person1.name)//prints \"Joy\"\nprint(person2.name)//prints \"Joy\"\n\nperson2.name = \"Mary\"\n\nprint(person1.name)//prints \"Mary\"\nprint(person2.name)//prints \"Mary\"\n```\n\n위 예제에서 우리는 Person의 인스턴스를 person1로 만들었습니다. 이제 새로운 인스턴스 person2가 person1에서 생성되었습니다. 이 시점에서 person1과 person2는 참조 유형이므로 동일한 메모리 주소를 가리킵니다. 따라서 person2를 수정하면 person1에 영향을 미칠 것입니다.\n\n구조체: 구조체는 상속을 지원하지 않습니다. 다른 구조체로부터 속성, 메서드 및 함수를 상속받는 기능이 없습니다.\n\n```js\nstruct Person {\n    var name: String\n}\n\nstruct Employee: Person { // 컴파일 시간 오류\n    // 프로토콜을 통해 이에 접근 가능\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스: 클래스는 상속을 지원합니다. 다른 클래스로부터 속성, 메서드 및 기능을 상속할 수 있습니다.\n\n```js\nclass Employee: Person {\n\n    var employeeId: Int\n\n    init(employeeId: Int, name: String) {\n        self.employeeId = employeeId\n        super.init(name: name)\n    }\n}\n\nvar obj = Employee(employeeId: 20, name: \"Abhay\")\n```\n\n구조체: 구조체 인스턴스가 var로 선언되면 가변이 될 수 있지만, 인스턴스가 let으로 정의되면 수정할 수 없습니다. 즉, 불변입니다.\n\n```js\nstruct Person {\n    var name: String\n}\n\nlet person1 = Person(name: \"Joy\")\nperson1.name = \"Mary\"// 오류가 발생합니다\n\nvar person1 = Person(name: \"Joy\")\nperson1.name = \"Mary\"// 올바르게 작동하여 수정됩니다\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스(Class): let 또는 var로 선언된 클래스는 변경 가능(mutable)합니다.\n\n```js\nclass Person {\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n}\n\nlet person1 = Person(name: \"Joy\") || var person1 = Person(name: \"Joy\")\nperson1.name = \"Mary\" // 둘 다 동일하게 작동합니다\n```\n\n구조체(Struct): 사용자 정의 이니셜라이저를 제공하지 않으면 구조체는 기본 멤버 지정 이니셜라이저를 갖습니다. 사용자 정의 이니셜라이저를 정의할 수도 있습니다.\n\n```js\nstruct Person {\n    var name: String\n}\n\n또는\n\nstruct Person {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\n// 둘 다 작동합니다\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스: 클래스에서는 모든 프로퍼티가 초기화되어 있어야 오류가 발생하지 않도록 해야 합니다. 클래스에는 지정 이니셜라이저와 편의 이니셜라이저가 있습니다.\n\n```js\nclass Person {\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n}\n```\n\n불변하고 작고 간단한 데이터를 다룰 때는 구조체를 사용해야 합니다. 구조체는 더 안전하며 ARC(Automatic Reference Counting)와 힙 할당이 일어나지 않습니다.\n\n상속, 가변 또는 참조 프로퍼티가 필요한 경우 클래스를 사용합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-STRUCTvsCLASSinSWIFT_0.png"},"coverImage":"/assets/img/2024-06-23-STRUCTvsCLASSinSWIFT_0.png","tag":["Tech"],"readingTime":5},{"title":"얼마나 쉽게 탈취 가능 내가 도둑이라면 아이폰을 훔치는 단계별 방법","description":"","date":"2024-06-23 01:33","slug":"2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step","content":"\n![image](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_0.png)\n\n이 게시물의 의도는 여러분에게 아이디어를 주는 것이 아닙니다.\n\n대신 애플의 보안 환경에 대해 깊은 이해를 가지고 있으며 여러분의 패스코드를 알면 단시간 내에 우회할 수 있는 영리한 도둑들로부터 스스로를 보호하는 데 도움이 되기 위한 것입니다.\n\n2년 넘게 애플에 대해 글을 쓰고 있는 블로거로서 나는 애플에 관한 꽤 괜찮은 지식을 갖고 있는 사람이라고 생각합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이폰을 훔치는 방법을 설명할게요 — 만약 제가 도둑이었다면 — 그리고\n\n- 영원히 Apple 기기 모두의 액세스를 막을 거에요,\n- 몇십 년 동안 소중히 여기던 사진을 모두 잃게 할 거에요,\n- 은행 계좌를 비울 거에요.\n\n미국에서 도둑이 아이폰을 훔치는 방법을 사용하는 범죄자들이 수백만 달러 가치의 아이폰을 훔치는 강력한 방법이라고 월스트리트 저널이 보도했습니다.\n\n마지막으로 해당 전략으로부터 아이폰을 보호하는 가장 좋은 보안 관행을 설명하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(진짜, 디지턈 ID가 쉽게 훔쳐질 줄 누가 알겠어요.)\n\n# 내용\n\n## 제1장: 도난\n\n1 — 쉬운 아이폰 찾기\n2 — 내 손에 넣기\n3 — 즉시 취해야 할 조치\n4 — Apple ID 훔치기\n5 — 은행 비우기\n6 — 아이폰 초기화 후 판매\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 장-2: 최상의 보안 관행\n\n1 — 패스코드는 왕이다\n2 — 아이클라우드 키체인 그만두기\n3 — 스크린 타임을 사용하여 계정 변경 금지\n4 — 새로운 iOS 17.3의 장치 도난 방지 기능\n\n# ~~장-1: 도난~~\n\n# #1. 쉬운 아이폰 찾기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쉽게 아이폰을 구할 수 있는 최고의 장소들은 바입니다.\n\n사람들은 거기서 쉬러 가므로 긴 시간을 머물 가능성이 높습니다. 그들이 보내는 시간이 길수록 아이폰을 훔칠 수 있는 기회가 더 많아집니다.\n\n(지역 열차나 쇼핑몰과 같은 붐비는 장소에서는 아이폰을 훔치는 것이 쉽지 않습니다.)\n\n나는 (훔치는) 아이폰을 안드로이드보다 선호합니다. 왜냐하면...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! iPhone은 안드로이드보다 재판매 가치가 더 높아요. iPhone을 사용하는 사람들은 보통 더 많은 돈을 가지고 있거나 적어도 큰 신용을 가지고 있어요.\n\niPhone을 찾을 때 제일 눈에 띄는 카메라 렌즈를 봐요:\n\n![아이폰 이미지](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_1.png)\n\n더 구체적으로 \"Pro\" iPhone을 찾을 거예요. 왜냐하면요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 사용된 비 Pro 모델은 보통 $300-400에 판매됩니다.\n- 그러나 사용된 Pro 모델은 저장 용량에 따라 $650 이상에 판매됩니다. 1TB면 심지어 $900까지도 붙일 수 있어요.\n\n다행히도 \"Pro\" 아이폰은 매우 쉽게 확인할 수 있어요. 모든 Pro 모델은 상징적인 3카메라 시스템을 갖고 있어요 — 위 이미지의 마지막 사진에 나와 있죠.\n\n## 2. 내 손에 당신의 iPhone 넘기기\n\n아, 멋진 iPhone을 발견했네요!\n이제 접근해서 음료를 제안하고 소소하게 이야기를 나눠보면, 당신이 나를 멋진 사람으로 생각할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신이 작년에 해변에서 가족과 찍은 사진을 보여주고 싶어할지도 몰라요 (또는 내가 호기심을 갖고 물어볼 지도 몰라요).\n\n여기서 제 첫 번째 임무는 당신의 패스코드를 알아내는 것이에요.\n\n## 시도-1:\n\n당신이 아이폰을 잠금 해제하여 사진을 보여줄 때, 당신의 손가락/화면을 관찰하여 패스코드를 얻을 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알겠어요. 이제 도둑질 할 시간이에요.\n\n## 시도-2: (시도-1이 실패했을 경우)\n\n만약 여러분의 패스코드를 알 수 없다면(또는 Face ID를 사용했다면), 사진을 찍기 위해 iPhone을 예의 바르게 받아들인 후, iPhone의 볼륨 업 버튼과 사이드 버튼을 눌러 진동이 오도록 하고, 그다음에 사이드 버튼을 눌러 잠그겠습니다.\n\n(\"이런! 잠겨 있어요. 여는 법 알려주실래요?\")\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 하면 다음에 iPhone을 잠금 해제하려고 할 때 Face ID를 사용할 수 없게 됩니다. 대신 패스코드를 사용해야 할 거에요 — 그러면 제 두 번째 기회가 됩니다.\n\n패스 코드를 얻었어요.\n\n## 시도-3: (시도-2가 실패한 경우)\n\n여전히 패스 코드를 얻지 못하면, 당신이 패스 코드를 입력하는 동안 어깨 뒤에서 비디오 녹화를 한 동료 도둑에게 물어볼거예요. 그가 패스 코드를 획득했는지 물을 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그렇다면, 강도 시간이다!\n\n나의 절도 기술로 당신의 아이폰을 훔쳐 갈 거에요. 당신이 알 때까지 당신은 그것을 알지 못할 거에요.\n\n### #3. 즉시 할 일\n\n빠르게 안전한 곳에 도착하여 다음 단계를 시작할 거에요. 그냥 당신을 영구적으로 Apple ID에서 차단하고 당신이 소유한 모든 것(디지털적으로)을 내 것으로 만들기 위해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 1: Apple ID 비밀번호 변경하기\n\n- 설정 ⚙️ `가능한_이름` 에서 로그인 및 보안 🛡️ `비밀번호 변경` 으로 이동합니다,\n- 인증을 위해 이미 알고 있는 iPhone 패스코드를 입력합니다,\n- 새 비밀번호를 입력하고 확인합니다.\n\n![이미지](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_2.png)\n\n## 단계 2: 모든 기기에서 로그아웃하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비밀번호를 변경한 후 iPhone에서는 Apple ID에서 다른 기기에서 로그아웃할 지 여부를 묻게 됩니다.\n\n![이미지](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_3.png)\n\n물론 저는 \"예\"를 선택하고 있습니다.\n\n그래서 iPhone을 잃어버렸다는 것을 깨달아도 Apple Watch나 친구의 iPhone에서 빠르게 로그인할 수 없게 되죠. 왜냐면요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 Apple ID 암호를 모르기 때문에 몇 번의 무의미한 시도를 계속하고 있네요.\n\n다음 단계를 실행할 시간이 충분히 남았어요... 휘파람.\n\n하지만 아직 Apple ID에 완전히 접근을 잃지 않았어요. 왜 그런지 알려드리겠고, 곧 처리해 드릴게요.\n\n## 단계-3: '내 iPhone 찾기' 끄기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nApple ID에 대한 액세스를 아직 잃지 않았으니, 위험을 감수하지 않겠습니다.\n\n손이 빠르다면, 복구 전화번호나 이메일을 사용하여 Apple Watch나 친구의 iPhone에서 Apple ID에 로그인하고 Find My를 통해 iPhone의 위치를 추적할 수 있습니다.\n\n따라서 빠르게 Find My iPhone을 끄겠습니다 (설정 ⚙️ `당신의_이름` Find My 🧭 `Find My iPhone`).\n\n![이미지](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그냥 번거로워서 꼭 필요하지는 않지만, 편안함을 위한 선택적 단계입니다. 당신의 Face ID에 제 얼굴을 등록합니다. 이렇게 하면 매번 암호를 입력해야 할 때마다 번거롭지 않고 간편하게 Face ID로 로그인할 수 있습니다.\n\n하지만 똑똑한 도둑으로서, 먼저 당신의 계정 복구 방법을 모두 닫아야 하기 때문에 이를 미루겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만, 내가 어떻게 할 지 말해줄게요:\n\n- Settings ⚙️ 로 이동하겠습니다. 'Face ID \u0026 Passcode’ 🙂,\n- 패스코드를 입력하고,\n- Face ID 재설정을 클릭하고 'Set Up Face ID’,\n- 그리고 iPhone의 Face ID에 내 얼굴을 사용하기 위해 단계를 따를 거예요.\n\n### #3. Apple ID를 도용하는 법\n\n#### (또는: 계정 복구 방법을 모두 막는 법)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n말했던 대로, 여전히 등록된 전화번호 및 이메일을 사용하여 Apple Watch 및 Mac을 통해 계정을 복구할 수 있는 기회가 있습니다.\n\n하지만 제가 싫어요 — 내 손에 있는 iPhone을 잠그실 수도 있어서요. 그래서 당신이 계정을 복구할 수 있는 방법을 모두 닫을 거에요.\n\n## 단계-1:\n\n- 설정 ⚙️ ` 로 이동합니다\n- 로그인 \u0026 보안 🛡️,\n- Apple ID에서 전화번호 및 이메일을 등록 해제합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Step-1](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_5.png)\n\n## Step-2\n\n- Tap on ‘Account Recovery’ on the same page,\n- Remove any recovery contacts you’ve set,\n\n![Step-3](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계-3\n\n- 동일한 페이지에서 '키 복구'로 이동,\n- 이전 키가 작동하지 않도록 끄거나 새로운 복구 키를 생성합니다.\n\n![이미지](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_7.png)\n\n이것으로 작업이 완료되었습니다. 이제 Apple ID에 액세스할 수 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n영원히 말이에요. 지구와 태양이 존재할 때까지.\n\n모든 연락처, 파일, 사진, 비밀번호, 메모, 캘린더 이벤트, Safari 브라우징 기록, 게임 진행 상황, 그리고 구독까지 모두 접근할 수 없어요. 모든 애플 기기들이 애플 ID에서 로그아웃돼요. 영원히요.\n\n심장을 아프게 할 거예요 — 하지만 돈을 벌어야 했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# #4. 당신의 자산 비우기\n\n가장 쉬운 대상부터 공격해보겠습니다 — Apple Cash.\n구매자 보호를 제공하지 않으며 분쟁을 제기해도 돈을 되찾을 수 없습니다.\n\n내가 모두 당신의 Apple Cash 잔고로 송금할 거에요 (Face ID를 사용하여).\n\n이어서, PayPal과 Venmo와 같은 지갑 앱으로 이동할 건데, 거래 비밀번호를 입력할 필요가 없어요. 그냥 Face ID만 있으면 돈이 내 계정으로 들어와요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 은행 앱을 이용해볼게요.\n만약 그것들이 Face-ID로 보호되어 있다면, 아주 좋아요. 이미 당신의 Face ID를 해킹했거든요.\n\n하지만, 만약 그것들이 비밀번호로 보호되어 있고 당신이 그 자격 증명을 iCloud 키체인에 저장해 뒀다면, 당신의 iPhone은 Face ID를 사용하여 자동으로 입력하도록 제안할 거에요. 그리고 저는 그것을 할 거에요.\n\n신의 길이 길으시기를 바랍니다만, 만약 2단계 인증을 활성화했다면...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 아이클라우드 키체인에서 확인 코드를 사용하면(Face ID로도 사용할 수 있도록 이 기사를 따라 하세요), 그것도 채울 수 있어요.\n- 전화 번호로 OTP를 사용하면,\n  문제 없어요... 이미 당신의 SIM 카드를 가지고 있으니까.\n- 좋아하는 장소가 어디냐, 엄마의 부친 이름이 뭐냐 하는 보안 질문을 사용하면, 당신의 사진과 노트에서 그것들을 찾아보겠어요.\n\n당신의 은행이 거래 PIN을 요구하면, 당신의 iPhone 암호를 시도할 거고요. 그게 안 먹히면, 당신의 노트나 문서에서 단서를 찾아볼 거에요.\n\n그리고 아시나요?\n카드, 공인 신분증, 그리고 다른 법적 문서들의 사본을 찍어서 암호화하지 않은 로컬에 저장해 두셨다면, 나는 더 운이 좋아질 거에요.\n\n은행이 거래가 사기인지 의심하고 당신을 확인하고 싶을 때, 그것들이 큰 도움이 될 거에요. 나는 당신을 대신해서 확인에 참석할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신의 은행을 비우신 후, Apple Wallet에 신용카드나 신용 한도가 있다면 쇼핑을 하러 갈 거에요. 당신의 신용을 다 써버릴 거에요. 다음 달에 그 비용을 지불하게 될 거예요.\n\n## 5. 아이폰 초기화 후 판매하기\n\n마지막으로, 당신의 아이폰을 초기화하고 판매할 거에요. 초기화하는 방법은 다음과 같아요:\n\n- 설정으로 이동해서 ⚙️ `일반` ⚙️ `iPhone 초기화나 재설정` 모든 콘텐츠 및 설정 지우기,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_9.png)\n\n- 계속 클릭한 후, 암호를 입력하세요.\n\n몇 초가 지나면 iPhone은 새 것처럼 되어 다시 판매할 준비가 됩니다.\n\n재판매 가격에 관해서는 이전에 언급한 것처럼,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 만약 Pro가 아닌 iPhone이라면, $300에서 $400에 판매할 수 있어요.\n- 만약 Pro iPhone이라면, $650에서 $900에 판매가 가능해요.\n\n제 노력에 상당한 보상이겠죠, 어떠세요?\n\n도둑 모자를 벗는다면...\n\n이미 말씀드렸지만, 이것이 미국에서 iPhone을 훔치는 도둑들의 방식, 특히 바에서 사람들로부터 하는 방법이에요. 여러분은 이것이 방탄 같은 전략임을 부인할 수 없죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그저 당신의 iPhone과 해당 암호만 필요해요. 그리고 퍼미션이 금방 사라져버려요.\n\n그래서 이제 저는 여러분께 이 iPhone을 해킹하는 데 사용하는 간단한 구멍에 대해 이야기해 드릴게요. 그리고 어떻게 바꿀 수 있는지도 알려 드릴게요.\n\n## **Chapter-2: 최고의 보안 관행**\n\n### **1. 암호가 최고**\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도난, Apple ID 액세스 상실 및 돈… 이 모든 일들은 도둑이 당신의 패스코드를 알고 있었다는 사실에 귀결됩니다.\n\n짧은 일련의 숫자를 알고 있다는 것만으로 그는 당신의 디지턈 집에 들어갈 수 있는 능력을 갖게 됩니다.\n\n패스코드의 기밀성이 얼마나 중요한지 강조할 수가 없어요.\n\n간단한 4자리 패스코드 대신 6자리 패스코드를 사용해보세요. 또는 더 나아가 사용자 지정 숫자 또는 알파벳 패스코드를 사용하세요. 그러면 도둑은 그것을 이해하는 데 어려움을 겪을 겁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_10.png\" /\u003e\n\n[“하지만 저에게 타이핑하기 어렵지 않나요?”\n걱정 마세요, 기기에 얼굴 인식 또는 터치 ID를 사용하면 비밀번호를 자주 입력할 일이 거의 없습니다. 아마 3일에 한 번 정도요.]\n\n또한, 공공장소에서 비밀번호를 입력할 때는 극도로 주의해야 합니다. ATM 핀 번호처럼 다루세요. 아무도 보지 못하도록 주의하세요 — 심지어 친구나 동료조차도.\n\n# #2. iCloud 키체인 버리기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이클라우드 키체인은 가장 안전하지 않은 비밀번호 관리자입니다. 왜냐하면?\n\n만약 당신의 아이폰 패스코드가 노출된다면, 모든 키체인 비밀번호가 자동으로 노출될 수 있습니다. 왜냐하면 그들은 당신의 패스코드로 보호되기 때문입니다.\n\n그러므로 대신 1Password, LastPass 또는 Dashlane과 같은 타사 비밀번호 관리자를 사용하고, 아이폰 패스코드가 아닌 별도의 패스코드로 잠그는 것을 고려해보세요.\n\n이를 통해 비밀번호 뿐만 아니라 여권이나 운전면허증 사본과 같은 중요 파일도 저장할 수 있습니다. 이러한 파일을 암호화되지 않은 채로 로컬 저장소에 남겨두지 않아도 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 도둑을 당신의 은행 계좌로부터 떨어뜨리고 그가 당신을 가장 확실히 사칭할 수 있는 중요 문서에 접근하는 것을 막습니다.\n\n## #3. Screen Time을 사용하여 계정 및 패스코드 변경 제한\n\nScreen Time은 iPhone에서 보내는 시간을 계산하는 것 이상의 일을 합니다. 그것은 또한 도둑들이 여기로 들어가는 것을 방지하는 데 도움이 됩니다️ ↓ (정확히 그들이 당신의 iPhone을 훔친 후 첫 방문하는 곳):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_11.png)\n\nHow? (Assuming you have Screen Time turned on)\n\n- Go to Settings ⚙️ ` Screen Time ⏳,\n- Set or change your Screen Time passcode to something that’s not your regular iPhone passcode,\n- Click on Content \u0026 Privacy Restrictions 🚫,\n- Turn on Content \u0026 Privacy Restrictions,\n- Scroll down and disallow ‘Passcode Changes’ \u0026 ‘Account Changes’.\n\nNow come back and you’ll see the area greyed out:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Step 12](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_12.png)\n\nNow no thief can access this area without your Screen Time passcode (that he doesn’t know anyways). And your account will be absolutely safe.\n\nHe also won’t be able to find Face ID \u0026 Passcode section in Settings ⚙️.\n\n![Step 13](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_13.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서 그가 당신의 아이폰을 훔칠 수 있지만, 그것은 그에게 벽돌만큼 좋습니다. 그리고 당신은 어디서든지 아이폰을 잠글 수 있는 기회가 있을 거에요.\n\n# #3. 새로운 iOS 17.3의 도난 방지 기능\n\n애플이 iOS 17.3에서 당신의 아이폰을 위한 새로운 보안 기능인 도난 방지를 소개합니다.\n\n이 업데이트는 1월 22일에 시작되는 주에 출시될 예정이며, 아마도 화요일인 1월 23일에 출시될 것으로 보입니다. (출처: Forbes)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 보안 기능은 기본 설정에서 비활성화되어 있습니다. 설정에서 활성화해야 합니다 ⚙️ ` Face ID \u0026 Passcode 🙂.\n\n\u003cimg src=\"/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_14.png\" /\u003e\n\n## 작동 방식은 어떻게 되나요?\n\n일반적으로 iOS는 민감한 작업에 접근할 때 두 번의 Face ID 시도를 제공하고, 그런 다음 패스코드 인증으로 넘어가는 것이 맞죠?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 장치 도난 방지가 활성화되면, Face/Touch ID가 민감한 작업에 대한 유일한 인증 방법이 될 것입니다 (곧 모두 나열할게요).\n\n그리고 이것은 당신 (또는 도둑)이 두 번의 Face ID 시도를 실패하면 나타날 것입니다:\n\n![Image](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_15.png)\n\n보안 장치 보호가 비활성화될 때까지 그는 작업에 패스코드를 사용할 수 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 도둑이 이를 끄려고 시도하면 생체 인증을 통과해야 하고 (그것은 불가능합니다) 그런 다음 이를 할 수 있기 전에 1시간의 카운트다운 지연이 필요합니다(공식적으로 보안 지연이라고 함).\n\n![이미지](/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_16.png)\n\n그러나 Apple은 iPhone이 집이나 직장과 같은 익숙한 위치에 있으면 딜레이가 없을 것이라고 합니다.\n\n이를 위해 부정 위치가 사용 가능해야 합니다(설정 ⚙️ `개인 정보 및 보안 ✋` 위치 서비스 📍 `시스템 서비스 ⚙️` 부정 위치).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 활성화되지 않았다면, iPhone은 집이나 사무실에서도 항상 보안 딜레이를 요구합니다.\n\n## 도난 방지 기능이 활성화되어 있는 경우 Face ID 또는 Touch ID를 요구하는 작업:\n\n- iCloud 키체인에 저장된 비밀번호나 패스키에 액세스\n- 새로운 Apple Card 신청\n- 가상 Apple Card 보기\n- 분실 모드 해제\n- 모든 콘텐츠 및 설정 삭제\n- 지갑에서 특정 Apple Cash 및 Saving 작업 수행\n- Safari에 저장된 카드 자동 작성\n- 새 iPhone 설정을 위해 iPhone 사용\n\n## 도난 방지 기능이 활성화되어 있는 경우 Face ID 또는 Touch ID, 그리고 보안 딜레이를 요구하는 작업:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Apple ID 비밀번호 변경\n- 일부 Apple ID 계정 보안 설정 업데이트 — 신뢰하는 기기, 전화 번호, 복구 키, 복구 연락처 관리\n- iPhone 암호 변경\n- Face ID 또는 Touch ID 추가/제거\n- 나만의 찾기 끄기\n- 도난 단말기 보호 끄기\n\n새 보안 기능 덕분에, 도둑이 아이폰을 훔쳐도 중요한 설정에 접근하기 위해 생체 인증을 통과할 수 없게 됩니다.\n\n그를 통과해도, 어떤 작업을 하려면 1시간의 보안 지연을 견뎌야 합니다.\n\n이를 통해 아이폰을 찾거나 원격으로 잠그거나 지울 시간을 충분히 확보할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신이 공공 장소에 있을 때는 항상 주머니에 iPhone이 있는지 규칙적으로 확인하십시오. 만약 없다면, Apple Watch나 친구의 iPhone을 사용하여 즉시 Lost Mode로 설정하십시오.\n\n보안 지연 시간이 끝나면, 당신의 iPhone은 평소와 같이 취약해집니다.\n\n## 놀라운 iPhone 숨은 기능을 더 알아보려면, 이 것들을 읽어보세요 →\n\n## 마침내,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면 (저와 같이), Setapp 구독을 고려해보세요. 매월 $9.99에 240개 이상의 멋진 앱을 선별하여 이용할 수 있습니다. 이것은 개별 구매 시 수백 달러가 들 수도 있는데요.\n\n- Setapp 여정을 시작하는 데 내 제휴 링크를 사용해보세요! (30일간 무료입니다)\n- Setapp의 100개 이상의 최고 macOS 앱 목록도 무료로 받아보세요.\n\n만약 이 이야기를 즐겼다면, 다른 440명 이상에 합류하여 새 이야기를 게시할 때마다 알림을 받아보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_0.png"},"coverImage":"/assets/img/2024-06-23-HeresHowIdStealYouriPhoneIfIWereAThiefStep-by-Step_0.png","tag":["Tech"],"readingTime":23},{"title":"Diffable Data Source를 사용한 다중 필터 컬렉션 뷰 생성 방법","description":"","date":"2024-06-23 01:30","slug":"2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource","content":"\n## iOS 프로덕션 코드에서 복잡한 UI 변경 사항을 확인하는 개념 증명\n\n저스트 잇 테이크어웨이 닷컴의 확장으로 음식 뿐만 아니라 식료품 및 다양한 다른 제품도 제공하기 위해 카테고리 및 하위 카테고리에서 선택 및 세부 사항을 걸러내는 새로운 UI를 구현해야 했습니다.\n\n![이미지](/assets/img/2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource_0.png)\n\n요구 사항:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 사용자는 첫 번째 캐로셀에서 하나의 카테고리만 선택할 수 있습니다. 항상 기본 카테고리가 선택됩니다.\n- 카테고리를 선택하면 두 번째 캐로셀에 모든 가능한 옵션이 표시되며 사용자는 여러 옵션을 선택할 수 있습니다.\n- 첫 번째와 두 번째 캐로셀에서 선택한 선택 사항을 반영하는 여러 섹션이 추가되어, 항목 간의 선택이 가능한 컬렉션 뷰가 만들어졌습니다.\n\n제품 코드를 구현하는 데 큰 노력이 필요하여, 우리는 제품에 코드를 구현하기 전에 간단한 증명 프로젝트를 사용하기로 결정했습니다.\n\n이 튜토리얼의 코드는 iOS에서 복잡한 사용자 인터페이스를 만들기 위한 증명 프로젝트로 사용되었습니다. 우리가 달성한 최종 목표는 그림에서 UI를 구현하는 것이었습니다.\n\n# 증명 프로젝트의 중요성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개념 증명 (Proof of Concept, PoC)은 개발 과정에서 중요한 단계입니다. 이를 통해 개발자들은 아이디어와 구현의 실행 가능성을 전체 개발에 앞서 더 작은 규모로 테스트할 수 있습니다.\n\nPoC를 만들면 잠재적인 문제를 빠르게 식별하고 가정을 검증하며 다양한 디자인 선택지를 탐색할 수 있습니다.\n\n이 방법을 통해 우량하고 효과적인 해결책만을 추구하여 시간과 자원을 절약할 수 있습니다.\n\n이 자습서에서 PoC는 최신 컬렉션 뷰 기술을 사용하여 복잡한 UI 요구사항을 관리하는 방법을 보여주며, 추가 개발을 위한 견고한 기반을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현실 세계 시나리오에서는 식당 API를 사용하여 데이터를 가져와 컬렉션 뷰에 표시하지만, 이 튜토리얼에서는 개 API를 사용하여 개념을 설명하고 즐거운 시간을 가질 겁니다!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*96GQ1GHslcj5tvtG6uwAeg.gif)\n\n이 튜토리얼에서는 UICollectionViewDiffableDataSource 및 UICollectionViewCompositionalLayout을 사용하여 여러 필터링 가능한 섹션을 포함하는 컬렉션 뷰를 만드는 방법을 안내합니다. 이 설정을 보여주기 위해 MultiFilterViewController 클래스를 사용할 것입니다.\n\n# 단계 1: 데이터 모델 정의하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 모델을 정의하여 컬렉션 뷰에서 섹션과 항목을 나타낼 수 있도록 해보세요. 이 모델들은 Hashable 프로토콜을 준수해야 합니다. 이 예시에서는 세 가지 데이터 모델을 정의합니다: Category, Breed, Image. Content 구조체는 컬렉션 뷰에 표시될 섹션 유형과 항목을 정의합니다.\n\n```swift\nstruct Category: Hashable {\n    let name: String\n    let range: ClosedRange\u003cString\u003e\n    let isSelected: Bool\n}\n\nstruct Breed: Hashable {\n    let breed: String\n    let apiKey: String\n    let isSelected: Bool\n}\n\nstruct Image: Hashable {\n    let url: URL\n}\n\nstruct Content {\n    enum SectionType: Int, Hashable {\n        case category\n        case breed\n        case images\n    }\n\n    struct Section: Hashable {\n        var id: String\n        var type: SectionType\n    }\n\n    enum Item: Hashable {\n        case category(Category)\n        case breed(Breed)\n        case image(Image)\n\n        func hash(into hasher: inout Hasher) {\n            switch self {\n            case .category(let item):\n                hasher.combine(item.hashValue)\n            case .breed(let item):\n                hasher.combine(item.hashValue)\n            case .image(let image):\n                hasher.combine(image)\n            }\n        }\n    }\n}\n```\n\n우리는 세 가지 종류의 섹션을 가지고 있습니다: category, breed, images. 각 섹션에는 고유한 식별자와 유형이 있습니다. Item 열거형은 각 섹션 내 항목을 나타냅니다. hash(into:) 메서드는 각 항목이 고유하게 식별되도록 구현되어 있습니다.\n\n# Step 2: 뷰 컨트롤러 설정하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뷰 컨트롤러 MultiFilterViewController을 생성하고 해당 속성을 정의하세요.\n\n```js\nclass MultiFilterViewController: UIViewController {\n\n    static let sectionHeaderElementKind = \"section-header-element-kind\"\n\n    var collectionView: UICollectionView!\n    var collectionViewLayout: UICollectionViewCompositionalLayout!\n\n    // 데이터를 가져오는 서비스\n    let service: APIServing = Service()\n\n    // 데이터를 관리하는 ViewModel\n    let viewModel = SectionViewModel()\n\n    var dataSource: UICollectionViewDiffableDataSource\u003cContent.Section, Content.Item\u003e?\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        updateInBackground()\n    }\n\n    init() {\n        super.init(nibName: nil, bundle: nil)\n        self.setupView()\n        self.setupConstraints()\n        self.dataSource = self.makeDataSource()\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"구현되지 않았습니다\")\n    }\n}\n```\n\n데이터를 가져오는 \"service\" 속성과 데이터를 관리하는 \"viewModel\" 속성을 정의했습니다. 또한 \"dataSource\" 속성을 사용하여 UICollectionViewDiffableDataSource를 통해 컬렉션 뷰 데이터 소스를 관리합니다. 컬렉션 뷰 레이아웃은 UICollectionViewCompositionalLayout을 사용하여 정의되었습니다.\n\n# 단계 3: 뷰 및 제약 조건 설정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컬렉션 뷰를 초기화하고 구성하여 레이아웃을 설정하고 필요한 셀 및 보조 뷰를 등록합니다.\n\n```js\nextension MultiFilterViewController {\n    func setupView() {\n        collectionViewLayout = buildCompositionalLayout()\n        collectionView = UICollectionView(frame: .zero, collectionViewLayout: collectionViewLayout)\n        collectionView.translatesAutoresizingMaskIntoConstraints = false\n        collectionView.allowsMultipleSelection = true\n        collectionView.delegate = self\n        view.backgroundColor = .white\n        title = \"Dog Breeds\"\n        view.addSubview(collectionView)\n    }\n\n    func setupConstraints() {\n        NSLayoutConstraint.activate([\n            collectionView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),\n            collectionView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor),\n            collectionView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),\n            collectionView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),\n        ])\n    }\n}\n```\n\n이 단계에서는 컬렉션 뷰를 설정하고 뷰 컨트롤러의 뷰에 추가합니다. 또한 컬렉션 뷰가 전체 화면을 채우도록 제약 조건을 정의합니다.\n\n# 단계 4: 셀 및 보조 뷰 등록하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 항목 유형에 대한 셀 등록 및 섹션 헤더에 대한 보충 뷰 등록을 정의합니다.\n\n```js\nextension MultiFilterViewController {\n\n    private func createLevelOneCellRegistration() -\u003e UICollectionView.CellRegistration\u003cLevelOneCollectionViewCell, Category\u003e {\n        UICollectionView.CellRegistration\u003cLevelOneCollectionViewCell, Category\u003e { [weak self] (cell, indexPath, item) in\n            cell.item = item\n            cell.icon = indexPath.row.isMultiple(of: 2) ? UIImage(systemName: \"pawprint\") : UIImage(systemName: \"pawprint.fill\")\n            if item.isSelected {\n                self?.collectionView.selectItem(at: indexPath, animated: false, scrollPosition: [])\n            }\n        }\n    }\n\n    private func createLevelTwoCellRegistration() -\u003e UICollectionView.CellRegistration\u003cLevelTwoCollectionViewCell, Breed\u003e {\n        UICollectionView.CellRegistration\u003cLevelTwoCollectionViewCell, Breed\u003e { [weak self] (cell, indexPath, item) in\n            cell.item = item.breed\n            Task { @MainActor in\n                guard let self else { return }\n                if let url = try await self.viewModel.randomImageURL(for: item, service: self.service) {\n                    cell.image = try await ImageManager.shared.getImage(for: url)\n                } else {\n                    cell.image = UIImage(systemName: \"pawprint\")\n                }\n            }\n            cell.position = indexPath.item\n            if item.isSelected {\n                self?.collectionView.selectItem(at: indexPath, animated: false, scrollPosition: [])\n            }\n        }\n    }\n\n    private func createCardCellRegistration() -\u003e UICollectionView.CellRegistration\u003cCardCollectionViewCell, Image\u003e {\n        UICollectionView.CellRegistration\u003cCardCollectionViewCell, Image\u003e { (cell, indexPath, item) in\n            Task { @MainActor in\n                cell.image = try await ImageManager.shared.getImage(for: item.url)\n            }\n        }\n    }\n\n    private func headerRegistration() -\u003e UICollectionView.SupplementaryRegistration\u003cSectionTitleView\u003e {\n        UICollectionView.SupplementaryRegistration\n        \u003cSectionTitleView\u003e(elementKind: MultiFilterViewController.sectionHeaderElementKind) { [weak self] (supplementaryView, string, indexPath) in\n            guard let section = self?.dataSource?.sectionIdentifier(for: indexPath.section) else { return }\n            supplementaryView.label.text = section.id\n            supplementaryView.backgroundColor = .white\n        }\n    }\n}\n```\n\n이 단계에서는 Category, Breed 및 Image와 같은 다양한 항목 유형에 대한 셀 등록을 정의합니다. 또한 섹션 헤더에 대한 보충 뷰 등록을 정의합니다. 셀 등록은 적절한 데이터와 이미지로 셀을 구성합니다. 보충 뷰 등록은 섹션 식별자를 기반으로 섹션 제목을 설정합니다.\n\n# 단계 5: 데이터 소스 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 단계에서는 `UICollectionViewDiffableDataSource`를 사용하여 diffable 데이터 소스를 생성합니다. 서로 다른 항목 유형에 대한 셀 프로바이더와 섹션 헤더를 위한 보충 뷰 프로바이더를 제공합니다. 셀 프로바이더는 항목 유형에 따라 적절한 셀을 대기열에서 꺼내옵니다. 그리고 보충 뷰 프로바이더는 섹션 헤더 뷰를 대기열에서 꺼내옵니다.\n\n# 단계 6: Compositional Layout 구축\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 단계에서는 컬렉션 뷰의 구성 레이아웃을 정의합니다. 섹션 제공자는 각 섹션의 레이아웃을 섹션 타입에 따라 반환합니다. 참고: dataSource를 사용하여 섹션 식별자를 검색하고 섹션 타입에 따라 레이아웃을 작성합니다.\n\n# 단계 7: 데이터 가져오기 및 업데이트하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뷰 모델에서 데이터를 가져와 diffable 데이터 소스의 snapshot을 업데이트하는 update() 메서드를 정의합니다.\n\n```js\nextension MultiFilterViewController {\n    func update() async throws {\n        let sections = try await viewModel.fetchData(service: service)\n        var snapshot = NSDiffableDataSourceSnapshot\u003cContent.Section, Content.Item\u003e()\n        let sectionKeys = sections.keys.sorted { section0, section1 in\n            guard section0.type == section1.type else { return section0.type.rawValue \u003c section1.type.rawValue }\n            return section0.id \u003c section1.id\n        }\n        for sectionKey in sectionKeys {\n            if let items = sections[sectionKey] {\n                snapshot.appendSections([sectionKey])\n                snapshot.appendItems(items, toSection: sectionKey)\n            }\n        }\n        dataSource?.apply(snapshot, animatingDifferences: true, completion: {\n            print(\"Apply snapshot completed!\")\n        })\n    }\n\n    func updateInBackground() {\n        Task {\n            do {\n                try await update()\n            } catch {\n                print(error)\n            }\n        }\n    }\n}\n```\n\n이 단계에서는 fetchData() 메서드를 사용하여 뷰 모델에서 데이터를 검색하고 섹션 및 항목으로 스냅샷을 만듭니다. 그런 다음 스냅샷을 데이터 소스에 적용하여 컬렉션 뷰를 업데이트합니다.\n\n# 단계 8: 델리게이트 메서드를 사용한 선택 처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUICollectionViewDelegate 메서드를 구현하여 항목 선택 및 선택 해제를 처리합니다.\n\n```js\nextension MultiFilterViewController: UICollectionViewDelegate {\n    func collectionView(_ collectionView: UICollectionView, shouldDeselectItemAt indexPath: IndexPath) -\u003e Bool {\n        guard let item = dataSource?.itemIdentifier(for: indexPath) else { return false }\n        switch item {\n        case .category(let item):\n            return item.name != viewModel.selectedCategory\n        case .breed:\n            return true\n        case .image:\n            return true\n        }\n    }\n\n    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {\n        guard let item = dataSource?.itemIdentifier(for: indexPath) else { return }\n        switch item {\n        case .category(let item):\n            collectionView.selectOneIndexInSection(at: indexPath, animated: true)\n            viewModel.selectCategory(category: item.name)\n            updateInBackground()\n        case .breed(let breed):\n            viewModel.toggleBreed(breed: breed.breed)\n            updateInBackground()\n        case .image(let image):\n            print(image)\n        }\n    }\n\n    func collectionView(_ collectionView: UICollectionView, didDeselectItemAt indexPath: IndexPath) {\n        guard let item = dataSource?.itemIdentifier(for: indexPath) else { return }\n        switch item {\n        case .category(let category):\n            print(category)\n        case .breed(let breed):\n            viewModel.toggleBreed(breed: breed.breed)\n            updateInBackground()\n        case .image(let image):\n            print(image)\n        }\n    }\n}\n```\n\n이 단계에서는 항목 선택 및 해제를 처리하기 위해 UICollectionViewDelegate 메서드를 구현했습니다. shouldDeselectItemAt 메서드를 사용하여 항목 유형에 따라 특정 항목의 선택 해제를 방지합니다. didSelectItemAt 메서드는 항목 선택을 처리하고 뷰 모델을 그에 맞게 업데이트합니다. didDeselectItemAt 메서드는 항목 해제를 처리하고 뷰 모델을 업데이트합니다.\n\n컬렉션 뷰에서 여러 항목을 선택할 수 있도록 여러 선택이 가능하도록 설정했습니다. 이는 섹션 내에서 여러 항목을 선택할 수 있도록 하기 위해 각 항목 유형에 대한 선택 및 선택 해제 로직을 처리해야 한다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경고: UICollectionView를 구성 레이아웃을 사용하도록 마이그레이션할 때 UICollectionViewDelegate가 업데이트되지 않은 모델을 참조하는 경우가 있습니다. UICollectionView의 진실의 원천은 diffable 데이터 소스이며 섹션 및 항목을 참조하는 데 사용해야 합니다. 이를 하지 않으면 앱 충돌이 발생할 수 있습니다.\n\n우리는 비용을 들여 배웠습니다. UICollectionViewDelegate가 UICollectionViewDiffableDataSource를 포함하는 클래스에 구현되어야 하며 올바르지 않은 모델을 참조하는 것을 방지해야 합니다. 항상 dataSource?.itemIdentifier(for: indexPath) 및 dataSource?.sectionIdentifier(for: section)을 사용하여 항목과 섹션을 참조하고 UICollectionView에서 직접 검색하지 않도록 해야 합니다.\n\n# 단계 9: 선택 관리를 위한 도우미 메서드 추가\n\n섹션 내에서 선택 및 선택 해제를 처리하는 도우미 메서드를 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nextension UICollectionView {\n    func deselectAllInSection(section: Int, animated: Bool) {\n        guard let selectedIndexesInSection = indexPathsForSelectedItems?\n            .filter({  $0.section == section }) else { return }\n        for index in selectedIndexesInSection {\n            deselectItem(at: index, animated: animated)\n        }\n    }\n\n    func selectOneIndexInSection(at indexPath: IndexPath, animated: Bool) {\n        deselectAllInSectionExcept(at: indexPath, animated: animated)\n        selectItem(at: indexPath, animated: animated, scrollPosition: [])\n    }\n\n    private func deselectAllInSectionExcept(at indexPath: IndexPath, animated: Bool) {\n        guard let selectedIndexesInSection = indexPathsForSelectedItems?\n            .filter({  $0.section == indexPath.section \u0026\u0026 $0.row != indexPath.row }) else { return }\n        for index in selectedIndexesInSection {\n            deselectItem(at: index, animated: animated)\n        }\n    }\n}\n```\n\n# 요약\n\n이제 UICollectionViewDiffableDataSource와 UICollectionViewCompositionalLayout을 사용하여 여러 필터링 가능한 섹션을 관리하는 MultiFilterViewController를 만들었습니다. 이 설정을 통해 동적이고 효율적인 데이터 업데이트와 유연한 항목 선택 및 선택 해제 처리가 가능해졌습니다. UICollectionView의 진리의 원천은 UICollectionViewDiffableDataSource이며, 항목 및 섹션을 참조할 때 사용해야 한다는 것을 배웠습니다. 이 자습서의 소스 코드는 여기에서 찾을 수 있습니다.\n\n# 참고문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Collection View 레이아웃의 진보\n- UI 데이터 소스의 진보\n- 현대적인 Collection Views 구현\n\nJust Eat Takeaway.com에서 채용 중입니다! 함께 일하고 싶으신가요? 지금 지원하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource_0.png"},"coverImage":"/assets/img/2024-06-23-CreatingaMulti-FilterCollectionViewwithDiffableDataSource_0.png","tag":["Tech"],"readingTime":17},{"title":" Jetpack Compose vs 전통적 안드로이드 반응형 UI를 위한 대결 ","description":"","date":"2024-06-23 01:29","slug":"2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs","content":"\n![이미지](/assets/img/2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs_0.png)\n\n# Jetpack Compose:\n\n- 적응형 레이아웃:\n\n  - 의미: Jetpack Compose는 다양한 화면 크기 및 방향에 매끄럽게 적응하는 레이아웃을 만들도록 권장합니다.\n  - 방법: fillMaxWidth, fillMaxHeight 및 padding과 같은 수정자를 사용하여 사용 가능한 공간에 따라 레이아웃 속성을 동적으로 조정합니다. 또한 Modifier.weight(f)를 사용하여 공간, 높이, 너비 또는 자식 Composables의 크기를 비례적으로 분배할 수 있습니다.\n\n- 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nColumn(\n    modifier = Modifier.fillMaxSize().padding(16.dp)\n) {\n    Row {\n      Text(text = \"안녕하세요!\", modifier = Modifier.weight(1f))\n      Text(text = \"컴포즈!\", modifier = Modifier.weight(1f))\n    }\n}\n```\n\n- 왜 중요한가요?: 적응형 레이아웃으로 여러 기기(소형 폰부터 대형 태블릿까지)에서 앱이 멋지게 보입니다.\n\n2. Compose의 ConstraintLayout:\n\n- 무엇인가요?: ConstraintLayout은 UI 요소 간의 관계를 정의할 수 있는 강력한 레이아웃 매니저입니다.\n- 어떻게 사용하나요?: 아래 예시에서 text1과 text2는 Text Composable에 할당된 레이아웃 ID이며, top.linkTo(text1.bottom)을 사용하여 요소를 text1 아래에 배치할 수 있습니다.\n- 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nConstraintLayout(Modifier.fillMaxSize()) {\n    val (text1, text2) = createRefs()\n    Text(\"Top\", modifier = Modifier.constrainAs(text1) {\n        top.linkTo(parent.top)\n    })\n    Text(\"Bottom\", modifier = Modifier.constrainAs(text2) {\n        top.linkTo(text1.bottom)\n    })\n}\n```\n\n- 왜 멋진가요: ConstraintLayout은 복잡한 UI 배열을 간소화하고 태블릿 및 휴대전화 모두에서 반응성을 보장합니다.\n\n3. 창 크기 클래스:\n\n- 이것들은 무엇인가요: 창 크기 클래스는 다양한 화면 크기(작은, 중간, 큰 등)를 나타냅니다.\n- 어떻게 사용하나요: LocalConfiguration.current.screenLayout를 통해 창 크기 클래스에 액세스할 수 있습니다.\n- 예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nval screenSize = LocalConfiguration.current.screenLayout\nwhen (screenSize) {\n    Configuration.SCREENLAYOUT_SIZE_SMALL -\u003e // 작은 화면 처리\n    Configuration.SCREENLAYOUT_SIZE_NORMAL -\u003e // 일반 화면 처리\n    // 기타 경우\n}\n```\n\n- 이유: 특정 차원을 하드코딩하지 않고 사용 가능한 공간에 기반하여 사용자 인터페이스를 맞춤화할 수 있습니다. 💃🏽🕺🏿\n\n# 전통적인 안드로이드 개발:\n\n- 리소스 한정자:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 무엇인가요: 자원 한정자를 사용하면 다양한 화면 크기와 밀도에 대해 다른 레이아웃을 제공할 수 있습니다.\n- 사용 방법: 레이아웃-작은, 레이아웃-큰 등과 같은 자원 폴더를 만들고 레이아웃 파일을 해당 폴더에 배치합니다. OS에서 기기 사양에 따라 어떤 레이아웃 파일을 inflate 할지 결정합니다.\n- 예시:\n\n```java\nres/\n    layout/\n        activity_main.xml\n    layout-large/\n        activity_main.xml (큰 화면에 최적화된 파일)\n```\n\n- 왜 중요한가요: 자원 한정자는 다양한 기기들 사이에서 일관된 UI를 보장합니다.\n\n2. 뷰 내 ConstraintLayout:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 무엇인가요: ConstraintLayout은 평평한 뷰 계층 구조로 복잡한 UI 레이아웃을 만들 수 있게 해줍니다 😊\n- 어떻게 사용하나요: 아래 XML은 두 개의 TextView 요소를 포함하는 ConstraintLayout을 정의합니다. 첫 번째 TextView는 부모의 시작에 고정되고 위쪽과 정렬됩니다. 두 번째 TextView는 첫 번째 TextView의 오른쪽에 위치하며 위쪽으로 정렬됩니다. 이 레이아웃은 두 개의 TextView가 ConstraintLayout 내에서 수평으로 인접하도록 보장합니다.\n- 예시:\n\n```js\n\u003candroidx.constraintlayout.widget.ConstraintLayout\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"match_parent\"\n\u003e\n  \u003cTextView\n    android:id=\"@+id/textView1\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"첫 번째 TextView\"\n    app:layout_constraintStart_toStartOf=\"parent\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n  /\u003e\n\n  \u003cTextView\n    android:id=\"@+id/textView2\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:text=\"두 번째 TextView\"\n    app:layout_constraintStart_toEndOf=\"@+id/textView1\"\n    app:layout_constraintTop_toTopOf=\"parent\"\n  /\u003e\n\u003c/androidx.constraintlayout.widget.ConstraintLayout\u003e\n```\n\n- 그들이 필수적인 이유: 모든 중첩된 레이아웃은 레이아웃 계산 중 추가적인 처리 시간을 소모합니다. ConstraintLayout은 뷰 간의 유연한 관계를 조성하고 중첩된 뷰 그룹을 최소화하여 전체 성능을 크게 향상시킵니다.\n\n반응형 Android 레이아웃을 개발하는 것은 다양한 화면 크기에 일관된 사용자 경험을 제공하기 위해 중요합니다. 다른 기기에서 레이아웃을 확인하여 예상치 못한 문제를 파악하는 것을 기억해 주세요. 그리고 위 Lonely T-Rex 이미지가 궁금하다면 - 그것은 구글 크롬 오프라인 게임으로, Jetpack Compose를 이용해 만들어진 것입니다 👍🏽 구글 플레이에서 다운로드하고 리뷰를 남겨서 이상한 알고리즘을 돕는 데 도움을 주세요 🚀📱\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🗣️: 문의해 주세요\nLinkedIn: [링크드인 프로필](https://www.linkedin.com/in/raphael-c-8b43612b6/)\n\n감사합니다,\nRC\n","ogImage":{"url":"/assets/img/2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs_0.png"},"coverImage":"/assets/img/2024-06-23-JetpackComposevsTraditionalAndroidTheBattleforResponsiveUIs_0.png","tag":["Tech"],"readingTime":6},{"title":"Jetpack Glance - 알아두어야 할 주요 기능 및 장점","description":"","date":"2024-06-23 01:28","slug":"2024-06-23-JetpackGlance","content":"\n## 안드로이드에서 아름다운 위젯을 만드는 Compose 방법\n\n![image](/assets/img/2024-06-23-JetpackGlance_0.png)\n\n여러 해 동안 위젯은 안드로이드 경험의 중요한 부분이었습니다. 그러나 이를 만들고 유지하는 것은 종종 괴로운 과정이었습니다. 전통적인 방법은 복잡할 수 있으며 명확한 설명 없이 예상치 못한 동작이 발생할 수 있습니다.\n\n여기서 Jetpack Glance가 혁신적인 새로운 방식으로 등장하여 문제를 해결합니다. Jetpack Compose의 선언적 UI의 강점을 활용하여 Glance는 위젯 개발을 간소화하고 더 쉽고 즐겁게 안드로이드 애플리케이션용 아름다운 기능적 위젯을 만드는데 도움을 줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근에 출시된 Jetpack Glance 1.1.0에 대해 얘기해볼까요? 이번 릴리즈는 위젯 개발을 간편하게 해줄 수 있는 잠재력에 대해 특별한 관심을 불러일으키는군요. 그래서 저는 Glance의 기능을 직접 경험해보기로 결심했습니다. 이 기능들을 시험해보기 위해, 저는 내 책 앱을 위한 위젯을 만들기로 했습니다. 이 위젯은 사용자 데이터에 접근하고 마지막으로 읽은 책을 계속할 수 있는 편리한 단축키를 제공하기 위해 Glance의 기능을 활용할 것입니다.\n\n개발 프로세스에 대해 자세히 살펴보고 전체적인 실습 경험을 위해 직접 위젯을 만들어보겠습니다.\n\n# 구조 정의\n\n어떠한 프로젝트라도 시작하기 전에 필요한 종속성을 설정하는 것부터 시작해야 합니다. 이 경우, 두 가지 주요 Jetpack Glance 라이브러리를 활용할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n[버전]\n\nglance = \"1.1.0\"\n...\n\n[라이브러리]\n\nglance-appwidget = { group = \"androidx.glance\", name = \"glance-appwidget\", version.ref = \"glance\" }\nglance-material = { group = \"androidx.glance\", name = \"glance-material3\", version.ref = \"glance\" }\n...\n```\n\n의존성이 설정된 상태에서 이제 코드 자체에 집중할 수 있습니다.\n\n코드 구성 및 재사용성을 증진하기 위해 위젯 전용 패키지를 별도로 생성하기로 결정했습니다. 이 접근 방식을 통해 위젯 관련 코드를 단일하고 명확한 위치에 그룹화할 수 있습니다.\n\n저희 Glance 위젯 개발은 MyBooksAppWidget과 MyBooksAppWidgetReceiver 두 가지 핵심 클래스를 설정하는 데서 시작됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- MyBooksAppWidget: 이 클래스는 GlanceAppWidget을 상속받습니다 (나의 경우에는 의존성 주입을 위해 Koin을 사용합니다. 선호하는 것을 선택할 수 있습니다). 이 클래스 안에서 위젯의 레이아웃을 정의할 것입니다.\n\n```js\nclass MyBooksAppWidget : GlanceAppWidget(), KoinComponent {\n...\n}\n```\n\n- MyBooksAppWidgetReceiver: 이 클래스는 GlanceAppWidgetReceiver를 상속받으며 위젯 인스턴스 (MyBooksAppWidget)의 초기화를 담당합니다.\n\n```js\nclass MyBooksAppWidgetReceiver : GlanceAppWidgetReceiver() {\n    override val glanceAppWidget: GlanceAppWidget = MyBooksAppWidget()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nxml 디렉토리에 새 리소스 파일을 만들어야 합니다 (저의 경우 my_book_widget_info로 이름 짓겠습니다). 이 파일은 위젯의 구성을 나타내며 홈 화면에서의 동작과 외관을 정의하는 다양한 속성을 제공합니다.\n\n```js\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003cappwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:resizeMode=\"horizontal|vertical\"\n    android:updatePeriodMillis=\"3600000\"\n    android:minHeight=\"50dp\"\n    android:minWidth=\"100dp\"\n    android:minResizeHeight=\"50dp\"\n    android:minResizeWidth=\"50dp\"\n    android:widgetCategory=\"home_screen\"\n    android:configure=\"com.stefanoq21.mybooks.MainActivity\"\n    android:widgetFeatures=\"configuration_optional|reconfigurable\"\n    android:previewImage=\"@drawable/widget_preview\"\n    android:maxResizeHeight=\"512dp\"\n    android:maxResizeWidth=\"512dp\"\n    android:targetCellWidth=\"2\"\n    android:targetCellHeight=\"1\"\n    android:initialLayout=\"@layout/glance_default_loading_layout\"\n    android:description=\"@string/widget_picker_description\"\n    \u003e\n\u003c/appwidget-provider\u003e\n```\n\n이제 주요 속성들을 살펴보고 사용자 경험에 어떻게 기여하는지 알아보겠습니다.\n\n- 최소/최대/조정 가능 폭 및 높이는 위젯의 경계를 정의하고 홈 페이지에서 어떻게 조절될 수 있는지를 나타냅니다.\n- initialLayout은 위젯이 데이터를 앱 로직이나 데이터베이스에서 검색하는 동안 표시될 레이아웃을 정의합니다. 이 임시 레이아웃은 사용자가 데이터 검색 과정 중에 빈 공간을 보지 않도록 플레이스홀더 역할을 합니다. glance_default_loading_layout를 사용하면 Glance 자체에서 제공하는 표준 로딩 화면을 활용할 수 있습니다.\n- previewImage 및 description은 위젯이 픽커 내에서 어떻게 보여질지를 정의합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-JetpackGlance_1.png\" /\u003e\n\nGlance 위젯의 기본 구조를 설정하는 마지막 단계는 AndroidManifest.xml 파일 내에서 수신기 클래스를 등록하는 것입니다. 이 등록 프로세스는 Android 시스템에 위젯 수신기의 존재를 알리고, 해당 브로드캐스트를 수신하여 위젯 업데이트를 트리거할 수 있도록합니다.\n\n```js\n\u003creceiver\n  android:name=\".widget.MyBooksAppWidgetReceiver\"\n  android:exported=\"true\"\n  android:label=\"@string/widget_receiver_label\"\n\u003e\n  \u003cintent-filter\u003e\n    \u003caction android:name=\"android.appwidget.action.APPWIDGET_UPDATE\" /\u003e\n  \u003c/intent-filter\u003e\n\n  \u003cmeta-data\n    android:name=\"android.appwidget.provider\"\n    android:resource=\"@xml/my_book_widget_info\"\n  /\u003e\n\u003c/receiver\u003e\n```\n\n핵심 구조를 확립했으므로 이제 위젯의 레이아웃 생성에 집중해 보겠습니다. Glance를 사용하면 다양한 시나리오에 대응하는 적응형 레이아웃을 디자인할 수 있습니다. 이러한 적응성은 데이터 수신 및 홈 화면에서 사용자가 선택한 크기에 따라 위젯이 표시를 조정함을 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 적응형 레이아웃\n\nMyBooksAppWidget 클래스는 위젯의 시각적 모습을 결정하는 중요한 역할을 합니다.\n\n여기에서는 레이아웃을 사용자 정의해야 하는 두 가지 중요한 오버라이드가 있습니다:\n\nsizeMode: 이것은 위젯이 홈 화면의 사용 가능한 공간에 따라 크기를 어떻게 관리하는지 제어합니다. Glance는 세 가지 옵션을 제공합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- SizeMode.Single: 위젯은 크기가 고정되어 있으며 크기 변경에 반응하지 않습니다.\n- SizeMode.Exact: 위젯은 시스템에서 모든 크기 업데이트를 받아들여 완전히 동적 레이아웃 조정이 가능합니다.\n- SizeMode.Responsive: 이 모드는 위젯이 적응해야 할 특정 크기를 정의하도록 허용하여 더 많은 제어를 제공합니다.\n\n내 예시에서는 SizeMode.Responsive를 선택하고 ICON_SQUARE, SMALL_SQUARE, MEDIUM_SQUARE라는 크기를 지정했습니다. 이를 통해 위젯이 사용 가능한 공간에 따라 레이아웃을 조정하고 서로 다른 크기에 대해 다른 내용이나 레이아웃을 표시할 수 있습니다.\n\n```js\nclass MyBooksAppWidget : GlanceAppWidget(), KoinComponent {\n\n    companion object {\n        internal val ICON_SQUARE = DpSize(50.dp, 50.dp)\n        internal val SMALL_SQUARE = DpSize(100.dp, 100.dp)\n        internal val MEDIUM_SQUARE = DpSize(150.dp, 150.dp)\n    }\n\n    override val sizeMode = SizeMode.Responsive(\n        setOf(\n            ICON_SQUARE,\n            SMALL_SQUARE,\n            MEDIUM_SQUARE,\n        )\n    )\n...\n```\n\nprovideGlance 함수는 위젯의 시각적 표현의 핵심을 형성합니다. 여기에서 Jetpack Compose 컴포저블을 사용하여 실제 레이아웃을 정의할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n...\n 재정의 suspend fun provideGlance(context: Context, id: GlanceId) {\n        val repository: DatabaseRepository by inject()\n        provideContent {\n            val book by repository.getLastOpenedLibraryItemFlow().collectAsState(null)\n            GlanceTheme {\n                if (book != null) {\n                    BookState(\n                        book!!, onClick =\n                        actionStartActivity(\n                            Intent(context.applicationContext, MainActivity::class.java)\n                                .setAction(Intent.ACTION_VIEW)\n                                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)\n                                .setData(\"https://com.stefanoq21.mybooks/ReaderEpub/${book!!.bookId}\".toUri())\n                        )\n                    )\n                } else {\n                    ZeroState(\n                       onClick =\n                        actionStartActivity(\n                            Intent(context.applicationContext, MainActivity::class.java)\n                                .setAction(Intent.ACTION_VIEW)\n                                .setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)\n                        )\n                    )\n                }\n            }\n        }\n    }\n```\n\n제공된 코드 조각은 귀하의 Glance 위젯 기능의 두 가지 주요 측면을 보여줍니다:\n\n- 조건부 레이아웃: 데이터가 있는 경우 (BookState)와 데이터가 없는 경우 (ZeroState)를 위한 두 가지 다른 레이아웃을 구현했습니다. 이를 통해 위젯이 다른 시나리오에서 사용자에게 적절한 피드백을 제공합니다.\n- 액션: onClick 매개변수로 전달된 액션들. 하나의 액션은 MainActivity를 실행하고, 다른 하나는 Jetpack Compose Navigation의 딥 링킹 기능을 활용하여 앱 내의 특정 화면으로 이동합니다. 이를 통해 위젯에서 앱의 관련 부분으로 원활하게 전환할 수 있습니다.\n\nZeroState 컴포저블은 표시할 관련 데이터가 없을 때 위젯에 표시되는 플레이스홀더 레이아웃으로 작동합니다. 이 시나리오는 사용자가 책을 읽기 전에 위젯을 추가한 경우에 발생합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nimport androidx.glance.Button\nimport androidx.glance.GlanceModifier\nimport androidx.glance.GlanceTheme\nimport androidx.glance.ImageProvider\nimport androidx.glance.LocalSize\nimport androidx.glance.action.Action\nimport androidx.glance.action.clickable\nimport androidx.glance.appwidget.components.Scaffold\nimport androidx.glance.appwidget.components.TitleBar\nimport androidx.glance.layout.Alignment\nimport androidx.glance.layout.Box\nimport androidx.glance.layout.fillMaxSize\n\n@Composable\nfun ZeroState(onClick: Action) {\n    val size = LocalSize.current\n    if (size.width \u003c= ICON_SQUARE.width) {\n        IconDimension(onClick)\n    } else {\n        Scaffold(\n            titleBar = {\n                TitleBar(\n                    startIcon = ImageProvider(R.drawable.ic_launcher_foreground),\n                    textColor = GlanceTheme.colors.onSurface,\n                    title = LocalContext.current.getString(R.string.widget_title),\n                )\n            },\n            backgroundColor = GlanceTheme.colors.widgetBackground,\n            modifier = GlanceModifier.fillMaxSize().clickable(onClick),\n        ) {\n            Box(modifier = GlanceModifier.fillMaxSize(), contentAlignment = Alignment.Center) {\n                Button(\n                    text = LocalContext.current.getString(R.string.start_reading),\n                    onClick = onClick\n                )\n            }\n        }\n    }\n}\n```\n\nGlance는 위젯에 대해 특별히 설계된 별도의 조합 기능을 제공한다는 점을 강조하기 위해 이 코드 조각에 import 문이 포함되어 있습니다.\n\nZeroState 조합은 Glance의 적응형 레이아웃을 만들어 사용 가능한 공간에 따라 프레젠테이션을 조정하는 능력을 보여줍니다. 이를 통해 사용자가 선택한 크기와 관계없이 위젯이 유용하고 정보 전달이 되도록합니다. 너비를 기준으로하면, 더 작은 크기에는 IconDimension 구성요소를 조건부로 렌더링하고, 보다 복잡한 레이아웃에서는 제목 표시줄과 버튼과 같은 구성요소를 조건부로 렌더링합니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*ukJec6XVolL-uwNf9VbUhQ.gif\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBookState 코움파서블은 ZeroState의 기반을 두고 있습니다. 사용자가 현재 읽고 있는 책 또는 최근 상호 작용한 책에 대한 정보를 표시하는 데 사용됩니다. ZeroState와 유사하게 버튼은 충분한 수직 공간이 있을 때에만 표시됩니다. 이는 레이아웃이 균형을 유지하고 시각적 혼란을 피하기 위해 보장합니다.\n\n```kotlin\n@Composable\nfun BookState(book: LibraryItem, onClick: Action) {\n    val size = LocalSize.current\n    if (size.width \u003c= MyBooksAppWidget.ICON_SQUARE.width) {\n        IconDimension(onClick)\n    } else {\n        Scaffold(\n            backgroundColor = GlanceTheme.colors.widgetBackground,\n            modifier = GlanceModifier.fillMaxSize().clickable(onClick)\n        ) {\n            Column(\n                modifier = GlanceModifier.fillMaxSize()\n                    .padding(bottom = 8.dp),\n                verticalAlignment = Alignment.Vertical.CenterVertically,\n                horizontalAlignment = Alignment.Horizontal.CenterHorizontally,\n            ) {\n                Text(\n                    text = book.title,\n                    style = TextStyle(\n                        fontWeight = FontWeight.Bold,\n                        fontSize = 16.sp,\n                        color = (GlanceTheme.colors.onSurface),\n                    ),\n                )\n                if (size.height \u003e= MyBooksAppWidget.MEDIUM_SQUARE.height) {\n                    Spacer(GlanceModifier.size(16.dp))\n                    Button(\n                        text = LocalContext.current.getString(R.string.widget_with_state_button),\n                        onClick = onClick\n                    )\n                }\n            }\n        }\n    }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*WqumbHh4UZoC8ewJXXcvCw.gif\" /\u003e\n\n# 위젯 업데이트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGlance는 위젯 구성(my_book_widget_info)에서 정의된 간격에 따라 위젯 업데이트를 관리하지만 즉시 업데이트를 원하는 경우가 있을 수 있습니다.\n\nGlance는 이 수동 업데이트를 수행하는 편리한 방법을 제공합니다. 앱 로직 내부에서 MyBooksAppWidget().updateAll(context)를 간단히 호출하면 됩니다. 이 방법은 Glance에게 사용자 홈 화면의 위젯 모든 인스턴스를 업데이트하도록 지시하여 최신 정보를 반영합니다.\n\n# 위젯 홍보하기\n\n가치 있는 Glance 위젯을 만드는 것은 첫 번째 단계일 뿐입니다. 사용자가 이를 발견하고 활용할 수 있도록하기 위해서는 효과적인 홍보 전략을 구현하는 것이 중요합니다.\n내 앱에서는 현재 책을 다시 읽을 수 있도록 도와주는 위젯을 개발했습니다. 그러나 사용자가 이를 찾아보기 위해 위젯 목록을 활발히 찾아보지 않을 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서 앱의 특정 지점에 위젯을 홍보하는 함수를 정의할 수 있습니다.\n\n```js\nfun promoteWidget(context: Context) {\n    val appWidgetManager = AppWidgetManager.getInstance(context)\n    val myProvider = ComponentName(context, MyBooksAppWidgetReceiver::class.java)\n    if (appWidgetManager.isRequestPinAppWidgetSupported) {\n        appWidgetManager.requestPinAppWidget(myProvider, null, null)\n    }\n}\n```\n\n만약 기기가 requestPinAppWidget 메소드를 지원하고 사용자 시스템이 허용한다면, 코드는 시스템에서 제공하는 하단 시트를 트리거할 것입니다. 해당 하단 시트는 사용자에게 위젯에 대해 안내하고 집 화면에 직접 추가할 수 있는 옵션을 제공할 것입니다. 이 접근 방식은 위젯 발견을 위한 매끄럽고 사용자 친화적인 경험을 제공합니다.\n\n결과물은 다음과 같을 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![JetpackGlance_2](/assets/img/2024-06-23-JetpackGlance_2.png)\n\n# 결론\n\n이 기사는 Glance 위젯을 만드는 과정을 안내했습니다. 우리는 위젯의 기본 구조를 설정하는 과정을 탐구하고, 다양한 시나리오에 대한 레이아웃을 정의하며, 사용자 상호작용을 처리하는 방법을 이해했습니다. 추가로, 위젯을 홍보하고 사용자의 채택을 촉진하는 전략을 탐구했습니다.\n\n이 지식을 활용하여 자신만의 Glance 위젯을 만들어 보세요! 다양한 기능을 실험하고 어떻게 앱과 사용자에게 이점을 줄 수 있는지 탐색해보세요. 기억하세요, 핵심은 가치를 제공하고 훌륭한 사용자 경험을 제공하는 데 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친구야! 댓글을 자유롭게 공유해 주세요. 또는 LinkedIn에서 연락해도 괜찮아요.\n\n좋은 하루 보내세요!\n","ogImage":{"url":"/assets/img/2024-06-23-JetpackGlance_0.png"},"coverImage":"/assets/img/2024-06-23-JetpackGlance_0.png","tag":["Tech"],"readingTime":16},{"title":"뉴욕 타임즈 크로스워드에 손글씨 인식 적용 실험","description":"","date":"2024-06-23 01:26","slug":"2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword","content":"\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_0.png)\n\n작성자: 샤픽 쿠라이쉬\n\n## 소개\n\n2023년 MakerWeek에서 시작된 뉴욕 타임스 매년 개최하는 해커톤에서 iOS 및 안드로이드 모바일 엔지니어들이 각 플랫폼에서 뉴욕 타임스 크로스워드 앱에 직접 손으로 쓰는 기능을 탐구했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n참여한 실험의 안드로이드 엔지니어로서 안드로이드 크로스워즈에 On Device ML을 구현하면서 플랫폼별 경험을 기대하고 있습니다.\n\n참고: 이 탐색은 아직 출시되지 않은 후속 기능을 위한 것입니다.\n\n## 초기 설정 및 요구 사항\n\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n뉴욕 타임스 크로스워드는 앱에 내장된 사용자 정의 소프트웨어 키보드를 갖고 있어요. 사용자가 키보드에서 글자를 입력하면 해당 사각형에 나타나요.\n\n손으로 쓰기를 가능하게 하기 위해, 우리가 먼저 해야 한 것은 실제로 사용자가 스타일러스나 손가락을 통해 텍스트를 수동으로 입력할 수 있도록 하는 것이었어요. 우리는 미니와 데일리 모두의 크로스워드 사각형마다 가져가서 '스케치박스'라고 불리는 사용자 정의 구성 요소로 변환했어요. 이 구성 요소는 사용자가 화면에 쓸 때 손가락이나 스타일러스로 그린 각 획을 캡처하고, 터치 및 드래그 이벤트를 감지하여 그린 글자 획을 표시하도록 특별히 설계되었어요.\n\n우리의 스케치박스가 캔버스로부터 얻은 결과 글자 픽셀을 캡처한 후, 그 데이터를 우리의 선택한 기계 학습 알고리즘에 전송할 수 있었어요.\n\n## 연필 타이밍\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_2.png\" /\u003e\n\n실제 필기 감지에 들어가기 전에, 섬세하지만 중요한 한 가지를 다룰 필요가 있습니다.\n\n사용자가 스케치박스에 쓰다 보면, 보통 손가락이나 스타일러스를 캔버스에서 떼곤 합니다, 특히 K, A, H 등과 같은 글자를 완성할 때 더욱 그렇습니다. 이것은 사용자가 각 획 사이에 정확히 언제 필기를 끝냈는지를 결정해야 한다는 것을 의미합니다. 예를 들어, 만약 사용자가 \"K\"의 줄기를 입력하면, 필기 도구를 캔버스에서 뗄 때 이 글자가 무엇일지 바로 감지하려고 하면 \"I\"로 해석될 수 있습니다.\n\n그렇다면 우리는 획 사이에서 얼마나 기다려야 할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 초기 구현에서는 뮤텍스와 유사한 입력 잠금 시스템 개념을 도입했습니다. 각 스트로크 사이에는 특정 조건에 따라 500에서 1000밀리초 사이의 값 실험을 진행했습니다. 스타일러스 잠금을 오랫동안 기다리고 싶지는 않았는데, 그렇게 되면 사용자 입력 경험이 떨어지고 버벅거릴 수 있습니다.\n\n이것은 우리가 필기 메커니즘을 설계할 때 고려해야 했던 많은 복잡성 중 하나이며, 향후 수정할 수 있는 부분입니다.\n\n## 데이터 준비, 조건부 및 정규화\n\n이미지를 텍스트로 변환하기 전에, 다양한 디바이스에서 다른 화면 크기와 해상도의 글자들이 입력되는 것을 고려해야 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알고리즘이 정확한 학습을 위해 필요한 데이터의 가장 간단한 형태를 얻는 것을 포함한 중요한 전처리 단계가 포함되어 있습니다. 이미지 데이터의 경우 비필수적인 잡음과 \"주저하는 지오메트리\"를 제거하는 것을 의미합니다. 우리는 문자 데이터를 축소 및 이진화하고, 그런 다음 128x128 크기의 원시 입력 문자를 훨씬 작고 효율적이며 간소화된 28x28 이미지로 변환했습니다.\n\n![image](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_3.png)\n\n그런 다음에야 우리는 라스터화된 캔버스 이미지 데이터를 우리의 교차 이력 앱이 이해하는 실제 문자로 어떻게 번역하는지에 대해 최종적으로 논의할 수 있었습니다.\n\n필기 인식은 광학 문자 인식(OCR) 내의 클래식한 기계 학습 과제입니다. 특히 1998년 Yann LeCun 박사의 LeNet-5 아키텍처로, Modified National Institute of Standards and Technology (MNIST) 데이터셋에서 digit 인식이 크게 향상되었습니다. MNIST 데이터셋에는 1부터 9까지의 다양한 숫자 변형이 수천개 포함되어 있으며, digit 인식의 대표적인 표준 데이터베이스입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 만들려고 했던 시스템의 고수준 아키텍처 다이어그램입니다:\n\n![아키텍처 다이어그램](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_5.png)\n\n선택한 기계 학습 알고리즘은 문자 데이터를 인식 클러스터로 가장 잘 분리해주도록 의도되었습니다. 아래에서 이상적인 형태로 구분한다면 시스템이 사용자가 'A'를 입력하려는지, 예를 들어 'C'를 입력하려는지 쉽게 판단할 수 있게 되었을 것입니다. 이러한 목적을 달성할 수 있도록 우리는 다층 합성곱 신경망 아키텍처를 사용하기로 결정하기 전에 여러 다른 옵션들을 탐색했습니다. 여기에서는 그에 대해 자세히 다루지 않겠습니다. 결과적으로, 우리가 선택한 Deep Convolutional Neural Network 아키텍처는 임무에 충분히 부합한다는 것을 입증했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_6.png)\n\n## 딥 컨볼루션 네트워크 구축하기\n\n깊은 CNN(컨볼루션 신경망)은 현대 이미지 기반 머신 러닝 시스템의 중추입니다. 이미지 데이터의 일부를 검토하고 학습 메커니즘을 사용하여 중요한 특징을 지능적으로 찾아 이미지를 식별하고 분류하는 데 도움이 되는 특수한 종류의 신경망입니다.\n\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 예시에서 보면, 신경망은 새의 입력 이미지를 받아와 새와 관련된 다양한 질적 요소에 해당하는 구조물을 탐지합니다. 이는 프로그램을 처음부터 설계하기 어려운 사람이 이미지의 일부분이 빽, 눈, 부리의 가장자리, 내부 부리 기하학 등과 같은 다양한 특징을 감지할 수 있습니다.\n\n가장 중요한 특징을 사용하여, 이는 새를 보고 어떤 종류의 새인지 판별할 수 있습니다. 또한, 새가 날아가거나 바라보는 방향과 같은 것들도 판별할 수 있습니다 - 단, 네트워크가 적절하게 훈련되어 있어야 합니다. 우리는 사용자가 우리의 크로스워드 앱에 입력하는 글자들에도 같은 원리를 적용합니다.\n\n기본 CNN은 다음 기본적인 레이어들의 조합으로 이루어져 있습니다. 이러한 구조물을 지능적으로 혼합하여 적절한 매개변수와 함께 사용하면, 우리가 감지하지 못하는 이미지 요소는 거의 없습니다:\n\n- 합성곱 레이어는 모델이 특징을 자동으로 추출할 수 있도록 합니다\n- 맥스 풀링 레이어는 Conv 레이어에서 얻은 특징을 좁힙니다\n- ReLU 레이어는 비선형성을 도입하고 복잡한 패턴 구별을 가능하게 합니다\n- 드롭아웃 레이어는 네트워크의 과적합을 완화합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_8.png\" /\u003e\n\n## TensorFlow Lite 및 모델 적재\n\n모델을 구축하는 것 외에도, 이를 기기에 전달하는 방법을 찾아야 했습니다. 저희는 Python으로 컴파일된 머신러닝 모델을 안드로이드 또는 iOS 기기에 설치하는 데 사용되는 모바일 프레임워크인 TensorFlow Lite를 선택했습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_9.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-뉴욕타임스크로스워드의필체인식실험_10.png\" /\u003e\n\n우리가 모델에 만족했을 때, 저희는 .tflite 파일로 컴파일하고 애플리케이션 안에 넣어서, 십자말 퍼즐 정사각형에서 오는 글씨 쓰기 이벤트를 청취하는 데 사용할 샤운트를 만들었습니다. 우리는 최종 결과에 만족할 때까지 서로 다른 모델과 구성을 여러 번 반복하여, 오직 100KB 가량의 학습된 파일로 변해 반영되었습니다 - 여기서는 공간을 고려해야 하는 모바일 애플리케이션에 적합합니다.\n\n## 숫자 인식\n\n전체 글자인식 문제에 접근하기 전, 우리는 간단히 시작하고 넘어갈 것으로 숫자인식 문제를 해결하기로 결정했습니다. 아래의 핵심 코드 섹션은 우리가 구현한 기본 CNN 설정을 제공합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_11.png\" /\u003e\n\n## 첫 번째 Digit Based CNN 모델 실패: 무엇이 잘못되었을까요?\n\n\u003cimg src=\"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_12.png\" /\u003e\n\nMNIST에서 얻은 풍부한 교육 데이터에도 불구하고, 우리의 인식 결과는 좋지 않았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n훈련 데이터가 \"너무 완벽하다\"라고 판단했습니다. 숫자는 서로의 작은 변형만 있었고, 대부분은 상자의 중앙에 있었습니다.\n\n이 방법은 사람들이 교차 워드 퍼즐 칸에 데이터를 입력하는 방식이 아닙니다. 사람들은 서로 다른 필기 스타일과 문자를 칸 안팎에 비스듬히 배치하는 방법을 가지고 있습니다.\n\n해결하기 위해 잘 알려진 머신러닝 기술인 데이터 증강을 사용해야 했습니다.\n\n데이터 증강은 훈련 데이터의 비스듬하고 왜곡된 버전을 자동으로 생성하여 수동 조정과 비틀음이 필요하지 않도록 합니다. 이를 통해 초기 데이터 세트의 다양한 변형을 가능하게 하며 문자의 크게 비중심 버전을 포함할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Experimenting with Handwriting Recognition for The New York Times Crossword](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_13.png)\n\n데이터 증강 기술을 적용하여, 우리는 데이터셋을 수천 개에서 중심에서 벗어나는 작은 이동, 회전, 확대/축소(어파인 변환 이라고도 함) 등을 적용하여 100만 개 이상의 샘플로 확장했습니다.\n\n## 숫자에 대한 데이터 증강 된 모델 성공\n\n![Experimenting Handwriting Recognition for The New York Times Crossword](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 표를 마크다운 형식으로 변경하십시오.\n\n## 풀 브론 글자 인식으로 이동하기\n\n![image](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_15.png)\n\n숫자 인식이 크로스워드에서 크게 개선되었다는 것을 확인할 수 있습니다. 이는 우리 작업에서의 중요한 성과입니다!\n\n이제 우리는 숫자를 해결했으니 다음 단계는 글자를 해결하는 것이었습니다. 이에는 26개의 소문자, 26개의 대문자 및 모든 변형이 포함됩니다. 이제 열 개의 숫자를 다루는 것이 아니라 62개의 문자를 처리해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEMNIST 데이터세트 (데이터 소스: http://arxiv.org/abs/1702.05373)를 사용할 수 있어요. 이는 MNIST 세트의 확장 버전으로, 문자뿐만 아니라 숫자와 구두점까지 포함하고 있어요. 이를 통해 모델을 더 잘 훈련할 수 있어요.\n\n그러나 향상된 데이터세트를 사용하더라도 숫자에 특화된 모델만으로는 우리의 요구를 충족시키기에는 충분하지 않아요. 이는 직관적으로 놀랍지 않아요. 왜냐하면 숫자 인식 모델은 강력하지만, 문자를 보는 데 도입된 문자 구조의 확장된 다양성에 대해 충분히 \"지능적\"이지 않기 때문이죠.\n\n## 매개변수 최적화를 통한 모델의 하이퍼 강화\n\n우리 모델의 성능을 높이기 위해, 우리는 네트워크에 훨씬 더 많은 깊이를 추가했어요. 또한, 증강된 훈련/검증 데이터의 무작위 하위 집합을 사용하여 다양성을 확보하기 위해 Stratified K-Fold 교차 검증을 사용했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 레이어가 최적으로 설계되었는지 확인하기 위해 무작위 매개변수 검색과 향상된 통계적 테스트를 사용했습니다. 이를 통해 모델의 최적 하이퍼파라미터를 찾는 데 성공했습니다. 이는 이전에 올바른 매개변수를 추측했던 우리의 전략보다 발전된 것으로 나타났습니다.\n\n테스트 단계에서 우리는 증강된 EMNIST 데이터셋에서 약 91%의 평균 검증 정확도를 달성했습니다. 이는 우리 모델이 작동할 것이라는 신뢰를 주었습니다.\n\n마침내: 성공!\n\n![이미지](/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_16.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기계 학습 모델 구축의 풍경을 탐험한 긴 여정 끝에 우리는 드디어 작동하는 크로스워드 모델에 도착했어요. 이는 정말 흥미로운 일이었죠. 우수한 결과를 이루었지만, 완벽한 크로스워드 경험을 위해 아직 해야 할 일이 많습니다. 부분적 글자 처리 및 불규칙한 간격으로 띄워진 글자들도 다루어야 합니다.\n\n## 결론\n\n안드로이드 크로스워드 앱에 필기 인식 기능을 구현하는 것은 실험적인 맥락에서도 흥미진진한 모험이었습니다. 필기 인식 외에도 “스크립 투 지우기” 감지와 같은 상호 작용 기능, 앱 내 자기 학습 메커니즘 가능성과 On-Device ML이 게임 앱에서 여는 다양한 문을 통해 가능성이 있습니다.\n\n새로운 기술과 기존 제품에 대한 강화를 실험해 볼 기회를 가지는 것은 타임즈에서 엔지니어로 일하는 것이 독특하고 가치 있는 이유의 핵심입니다. 우리는 언젠가 현재 사용자들을 위한 게임 경험을 강화하고 새 구독자를 유치하는 기능으로 발전시키는 날이 오기를 희망합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샤피크 쿠라이시는 뉴욕 타임스의 게임 팀에서 시니어 안드로이드 엔지니어로 일하고 있어요. 그는 머신 러닝과 인공 지능에 열정을 가지고 있어요. 업무 외에는 기타 연주, 글쓰기, 그리고 독특한 실험을 하는 것을 즐기고 있어요.\n","ogImage":{"url":"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_0.png"},"coverImage":"/assets/img/2024-06-23-ExperimentingwithHandwritingRecognitionforTheNewYorkTimesCrossword_0.png","tag":["Tech"],"readingTime":13},{"title":"안드로이드에서 공유 ViewModel의 내부 메커니즘 이해하기","description":"","date":"2024-06-23 01:24","slug":"2024-06-23-TheInternalMechanismofSharedViewModelinAndroid","content":"\n![이미지](/assets/img/2024-06-23-TheInternalMechanismofSharedViewModelinAndroid_0.png)\n\n# 안드로이드에서의 Shared ViewModel이란 무엇인가요?\n\n안녕하세요! 여러분은 앱의 다양한 부분을 데이터를 계속 주고받는 모든 번거로움 없이 동기화하는 방법을 궁금해 하신 적이 있나요? 그려면 Shared ViewModel을 소개할게요. 이는 앱 구성 요소를 위한 그룹 채팅처럼 작동합니다. 개별 메시지를 주고받는 대신에 모두가 자동으로 함께 유지됩니다. 정말 편리하죠?\n\n# Shared ViewModel은 어떻게 작동하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신이 서프라이즈 파티를 준비하고 있다고 상상해보세요. 여러 명의 친구들(당신의 조각들)이 계획에 대한 변경 사항마다 각각에게 전화를 걸지 않고도 업데이트를 유지해야 합니다. 이 때 공유된 ViewModel이 등장합니다. 이는 모두가 동일한 페이지에 머무를 수 있도록하는 마스터 파티 플래너와 같은 역할을 합니다.\n\n## 단계 1: 마스터 플래너(ViewModelProvider)\n\nViewModelProvider은 마스터 파티 플래너와 같습니다. 파티 세부 정보(ViewModel)를 요청하면 이미 계획이 있는지 확인합니다. 있으면 제공하고, 그렇지 않으면 새로운 계획을 작성합니다.\n\n다음은 ViewModel을 가져오는 방법입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nval viewModel = ViewModelProvider(requireActivity()).get(SharedViewModel::class.java)\n```\n\nrequireActivity()을 사용하면 ViewModel이 해당 activity의 모든 fragment들 사이에서 공유됩니다. 이는 파티 준비 위원회 전체를 위한 한 곳의 중앙 그룹 채팅을 가지는 것과 같습니다.\n\n## 단계 2: 저장 공간 (ViewModelStore)\n\n뒷면에는 모든 계획(ViewModels)이 보관되는 저장 공간(ViewModelStore)이 있습니다. 이 방은 활동의 수명주기에 묶여 있습니다. 따라서 활동이 살아있는 한 계획은 안전하게 보관됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 3: 계획의 수호자(ViewModelStoreOwner)\n\nViewModelStoreOwner은 보관실의 열쇠 소유자와 같습니다. 활동(Activity) 및 프래그먼트(Fragment)는 이 인터페이스를 구현하며, 공유된 계획에 접근할 수 있도록 보장합니다.\n\n다음은 활동에서의 사용 예시입니다:\n\n```java\npublic class MainActivity extends AppCompatActivity implements ViewModelStoreOwner {\n    private ViewModelStore mViewModelStore = new ViewModelStore();\n\n    @Override\n    public ViewModelStore getViewModelStore() {\n        return mViewModelStore;\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        mViewModelStore.clear(); // 활동이 종료될 때 ViewModelStore를 비움\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 4: 모두가 최신 상태 유지하기 (데이터 공유)\n\n모든 조각들이 동일한 그룹 채팅(ViewModel)의 일부이기 때문에 어떠한 변경 사항이 있더라도 자동으로 최신 상태를 유지합니다. 각 친구에게 개별적으로 전화할 필요가 없습니다.\n\n실제 작동 방식은 다음과 같습니다:\n\n```js\nclass SharedViewModel : ViewModel() {\n    val data = MutableLiveData\u003cString\u003e()\n}\n\nclass FirstFragment : Fragment() {\n    private lateinit var viewModel: SharedViewModel\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        viewModel = ViewModelProvider(requireActivity()).get(SharedViewModel::class.java)\n        viewModel.data.observe(viewLifecycleOwner, Observer { data -\u003e\n            // 새 데이터로 UI 업데이트\n        })\n        return inflater.inflate(R.layout.fragment_first, container, false)\n    }\n}\n\nclass SecondFragment : Fragment() {\n    private lateinit var viewModel: SharedViewModel\n\n    override fun onCreateView(\n        inflater: LayoutInflater, container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View? {\n        viewModel = ViewModelProvider(requireActivity()).get(SharedViewModel ::class.java)\n        viewModel.data.observe(viewLifecycleOwner, Observer { data -\u003e\n            // 새 데이터로 UI 업데이트\n        })\n        return inflater.inflate(R.layout.fragment_second, container, false)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFirstFragment이 viewModel.data를 업데이트하면, SecondFragment도 업데이트를 받습니다. 마치 한 친구가 그룹 채팅에 글을 올리면 모두가 즉시 메시지를 받는 것처럼 동작합니다.\n\n# 요약\n\n그래서 Shared ViewModel의 마법입니다! ViewModelProvider, ViewModelStore, ViewModelStoreOwner를 사용하여 추가 노력 없이 모든 fragment를 동기화 상태로 유지합니다. 항상 모두가 같은 페이지에 있는지 확인하는 수퍼 체계적인 파티 플래너가 있는 것처럼 동작합니다. 추가 질문이 있거나 더 깊이 파고들고 싶으시면 언제든지 알려주세요. 즐거운 코딩하세요! 😊\n","ogImage":{"url":"/assets/img/2024-06-23-TheInternalMechanismofSharedViewModelinAndroid_0.png"},"coverImage":"/assets/img/2024-06-23-TheInternalMechanismofSharedViewModelinAndroid_0.png","tag":["Tech"],"readingTime":5}],"page":"14","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"14"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>