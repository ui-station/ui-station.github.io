<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/1" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_buildManifest.js" defer=""></script><script src="/_next/static/-dPCbnM2yhdKNgXe92VJV/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="iOS에서 멀티스레딩 사용하는 방법 안내" href="/post/2024-06-23-GuidetoMultithreadinginiOS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS에서 멀티스레딩 사용하는 방법 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GuidetoMultithreadinginiOS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS에서 멀티스레딩 사용하는 방법 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS에서 멀티스레딩 사용하는 방법 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 다양한 그리드 뷰를 만드는 방법 종합 가이드" href="/post/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 다양한 그리드 뷰를 만드는 방법 종합 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 다양한 그리드 뷰를 만드는 방법 종합 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI에서 다양한 그리드 뷰를 만드는 방법 종합 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 172 출시  꼭 알아야 할 27가지 중요한 사항" href="/post/2024-06-23-iOS172Released27ThingsYouNEEDToKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 172 출시  꼭 알아야 할 27가지 중요한 사항" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 172 출시  꼭 알아야 할 27가지 중요한 사항" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 172 출시  꼭 알아야 할 27가지 중요한 사항</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="처음으로 Kotlin Multiplatform KMM 프로젝트를 Android Studio에서 빌드하는 방법" href="/post/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="처음으로 Kotlin Multiplatform KMM 프로젝트를 Android Studio에서 빌드하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="처음으로 Kotlin Multiplatform KMM 프로젝트를 Android Studio에서 빌드하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">처음으로 Kotlin Multiplatform KMM 프로젝트를 Android Studio에서 빌드하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 앱을 위한 UI 디자인 완벽 가이드" href="/post/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 앱을 위한 UI 디자인 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 앱을 위한 UI 디자인 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 앱을 위한 UI 디자인 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 " href="/post/2024-06-23-SettingupanewMacmytop3essentials"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SettingupanewMacmytop3essentials_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="WWDC 2024 Swift의 새로운 동시성 기능 탐구" href="/post/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="WWDC 2024 Swift의 새로운 동시성 기능 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="WWDC 2024 Swift의 새로운 동시성 기능 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">WWDC 2024 Swift의 새로운 동시성 기능 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI의 NavigationStack 사용 방법" href="/post/2024-06-23-HowtousetheSwiftUIsNavigationStack"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI의 NavigationStack 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI의 NavigationStack 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI의 NavigationStack 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Unowned self 개념의 문제점" href="/post/2024-06-23-TheCaseAgainstunownedself"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Unowned self 개념의 문제점" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Unowned self 개념의 문제점" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Unowned self 개념의 문제점</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법" href="/post/2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link posts_-active__YVJEi" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"iOS에서 멀티스레딩 사용하는 방법 안내","description":"","date":"2024-06-23 23:54","slug":"2024-06-23-GuidetoMultithreadinginiOS","content":"\n혹시 PR 댓글로 \"이것은 주요 큐에 들어가지 않는다\" 또는 비슷한 내용을 받았는데 왜 그런지 전혀 모르겠다고요? 이 기사가 딱 맞는 거에요!\n\n저희 모두가 디버그 네비게이터를 보면서 스택 트레이스를 살펴보며 꽤 많은 시간을 보냈다고 확신합니다. 스택 트레이스는 우리 프로그램을 실행하는 과정에서 실행된 스레드들의 백트레이스에 불과합니다. 스레드는 독립적으로 실행할 수 있는 명령어 집합이라고 볼 수 있습니다.\n\n모든 응용 프로그램에는 최소한 하나의 스레드, 즉 주요 스레드가 있습니다. 이것은 스레드 계층 구조에서 가장 높은 위치에 있는 스레드로, 다른 스레드들에게 작업을 위임할 수 있습니다. 주요 스레드가 여러 다른 백그라운드 스레드에 작업을 위임하는 것을 우리는 멀티스레딩이라고 부릅니다. 멀티스레딩은 단순히 여러 스레드에서 작업을 동시에 수행하여 애플리케이션의 성능을 개선하는 것입니다.\n\n![가이드 이미지](/assets/img/2024-06-23-GuidetoMultithreadinginiOS_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단일 코어 프로세서에서는 시간 조각내기로 동시성을 달성할 수 있지만 멀티스레딩과 동시성은 1950년대 멀티코어 프로세서가 등장하면서 인기를 얻었습니다. 단일 코어 프로세서와 달리 멀티코어 프로세서는 시간 조각내기에 관련된 문맥 전환 없이 병렬로 여러 스레드를 실행할 수 있습니다. 복수 스레드를 실행하는 이 능력을 사용하지 않으면 리소스를 최적으로 활용하지 않는다는 것을 의미하며 결과적으로 성능이 저하될 수 있습니다. 그리고 여기에서 Grand Central Dispatch(GCD)가 등장합니다.\n\n# Grand Central Dispatch란?\n\niOS 애플리케이션을 개발한 적이 있다면 멀티스레딩을 사용하고 있음을 깨닫겠지만 (스택 추적이 그 증거입니다!), 실제로 스레드와 상호 작용하지는 않는 것을 알게 될 것입니다. 이는 GCD가 이를 백그라운드에서 처리하기 때문입니다. GCD는 어떤 스레드가 어떤 작업을 실행할지 관리하는 책임이 있는데, 우리는 단지 실행해야 할 작업을 지정하기만 하면 됩니다. 이는 GCD가 시스템 수준에서 작동하고 시스템의 리소스, 리소스를 최적으로 활용할 수 있는 방법, 그리고 효율적으로 작업을 수행할 수 있는 방법을 더 잘 알고 있기 때문입니다.\n\nGCD는 디스패치 대기열 또는 일반적으로 대기열이라고도 하는 일부 관리하며, 여기에 우리의 작업을 올리고 예약하고 나중에 스레드 풀 내에서 실행할 수 있도록 분배합니다. 이 디스패치 대기열은 \"직렬\"일 수도 있고(즉, 작업을 순차적으로 실행), \"동시적\"일 수도 있고 작업을 병렬로 실행할 수 있습니다. 앞서 언급했듯이 동시성은 더 나은 성능으로 이어지므로 병행 대기열을 더 자주 사용할 것을 권장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# DispatchQueue.main.what…?\n\n메인 대기열(main queue)은 애플리케이션의 주 스레드에서 작업을 실행하는 GCD에서 제공하는 전역적으로 사용 가능한 시리얼 대기열입니다.\n\n하지만 주 스레드를 차단한다는 것은 무엇을 의미할까요? 그리고 이것이 사용자 경험에 실제로 영향을 미칠까요? 이미 알고 있듯이 주 스레드는 UI를 업데이트하는 데 사용됩니다. 이는 매우 리소스 집약적인 작업입니다. 대부분의 기기들이 이 작업을 매 초마다 여러 번 수행하기 때문에, 심지어 소수 초의 지연도 UI가 얼마나 부드러울지에 영향을 줄 수 있습니다. 애플리케이션이 UI를 여러 번 그릴 수 있게 하려면 필요한 리소스가 있어야 하는데, 만약 주 스레드에서 불필요한 작업을 수행한다면 이것은 불가능합니다.\n\n이를 피하기 위해, 주 대기열 외에도 GCD는 백그라운드 대기열로도 알려지는 여러 전역 대기열을 제공합니다. 이 대기열은 주 스레드에 속하지 않는 작업, 즉 UI 업데이트가 아닌 모든 작업을 수행하는 데 사용됩니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 특정 상태에 따라 애니메이션을 표시해야 하는 경우가 있습니다. 특정 동작을 반환하는 함수가 있습니다. 주요 대기열에서 애니메이션을 가져와 표시하는 대신, 전역 백그라운드 스레드에서 애니메이션을 가져오고 주요 스레드에서만 애니메이션을 표시하는 것이 합리적입니다.\n\n```js\nDispatchQueue.global(qos: .userInteractive).async { [weak self] in\n  // 상태에 따라 애니메이션 가져오기\n  // 주요 스레드를 차단하지 않도록 전체 백그라운드 스레드에서\n  let animation = getAnimation(status)\n  DispatchQueue.main.async { [weak self] in\n    // UI 업데이트이므로 주요 스레드에 애니메이션 표시\n    self?.showAnimation(animation)\n  }\n}\n```\n\n그리고 DispatchQueue.main.async에서 async는 무엇을 의미할까요? GCD는 동기적 또는 비동기적 방식으로 작업을 디스패치할 수 있습니다. sync를 사용하면 작업 실행을 완료한 후에만 호출자 함수에 제어를 반환합니다. 반면, async를 사용하면 작업 실행을 시작하고 호출자에게 즉시 제어를 반환하여 스레드를 차단하지 않고 실행합니다. 일반적으로 API 호출이나 CPU 집약적 작업을 수행할 때 async를 사용합니다. 또한, 주요 스레드에 대해 async를 사용했던 것처럼, 요구 사항에 따라 DispathQueue.global().async 또는 sync를 사용할 수 있습니다.\n\n# 그렇다면 왜 Operation Queues가 필요할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGCD는 멀티스레딩을 가능하게 하는 저수준 API인 것을 알고 있죠. 반면에 Operation queues는 GCD 위에서 구축된 추상화입니다. 이를 통해 우리는 작업에 우선 순위를 추가하고 그들 사이에 의존성을 설정할 수 있습니다. 디스패치 큐가 순수한 FIFO라면, operation queues는 그렇지 않습니다. 또한, 디스패치 큐가 직렬 또는 병렬일 수 있는 것을 기억하죠? Operation queues는 항상 병렬입니다. 우리는 의존성을 정의함으로써 특정 시퀀스를 설정할 수도 있지만, 순수하게 순차적일 수는 없습니다.\n\nOperation queues를 구현하기 위해 OperationQueue 또는 NSOperatioQueue 클래스를 사용하고, 이러한 큐에 추가된 작업 또는 연산에는 Operation 또는 NSOperation 클래스를 사용합니다. 이러한 연산들은 디스패치 큐 작업과 마찬가지로 독립적으로 실행할 수 있는 명령의 단위입니다.\n\nOperation queues의 실질적인 장점은 무엇일까요? 이러한 작업을 GCD로도 구현할 수는 없을까요?\n\n- 다른 작업의 결과에 따라 작업을 수행해야 할 때, 디스패치 큐의 FIFO 동작을 극복하기 위해 operation queues를 사용할 수 있습니다.\n- 디스패치 큐는 우선순위를 설정할 수 없습니다. 작업에 우선순위를 정해야 하는 경우에는 operation queues를 사용해야 합니다.\n- Operation queues를 사용하면 이미 예약된 작업을 취소할 수 있습니다. GCD는 투명성 면에서 유명하지 않기 때문에 이는 디스패치 큐로는 쉽게 구현할 수 없습니다. 우회 방법은 있지만 GCD로는 이것을 하는 좋은 방법이 없습니다. 또한, 한번 디스패치 큐에서 작업이 실행을 시작하면 중지할 수 없습니다. Operation queues는 이미 실행 중인 작업을 강제로 중지하지는 않지만, 취소된 프로퍼티를 true로 설정합니다. 각각의 작업에는 준비, 실행, 완료 상태가 있습니다. 완료가 true로 설정되면 실행이 성공적으로 완료된 것입니다. 작업과 연결된 완료 블록이 있다면, 완료 플래그가 설정될 때 실행됩니다. 그러나 취소된 작업의 경우, 완료 플래그가 설정되기 전에 취소 플래그가 설정됩니다. 따라서 완료 블록을 적절히 수정하여 필요한 경우 취소된 시나리오를 처리할 수 있습니다. 이것은 GCD로는 불가능한 일입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 작업 대기열이 동작하는 예시입니다.\n\n```swift\nimport Foundation\nlet queue = OperationQueue()\nqueue.maxConcurrentOperationCount = 3\n\nlet op1 = BlockOperation(block: {\n  print(\"op1 실행 중\")\n})\n\nlet op2 = BlockOperation(block: {\n  print(\"op2 실행 중\")\n})\n\nlet op3 = BlockOperation(block: {\n  print(\"op3 실행 중\")\n})\nlet op4 = BlockOperation(block: {\n  print(\"op4 실행 중\")\n})\n\nop4.queuePriority = .veryHigh\nop1.addDependency(op2)\n\nqueue.addOperation(op1)\nqueue.addOperation(op2)\nqueue.addOperation(op3)\nqueue.addOperation(op4)\nqueue.waitUntilAllOperationsAreFinished()\n```\n\n그리고 이로써 마무리합니다. 이것은 GCD와 Operation Queues를 사용한 스위프트에서의 멀티스레딩에 대한 간단한 소개였습니다. 읽어 주셔서 감사합니다. 질문이 있으시면 언제든지 물어보세요. 피드백은 언제나 환영이니 댓글을 남겨주세요!\n","ogImage":{"url":"/assets/img/2024-06-23-GuidetoMultithreadinginiOS_0.png"},"coverImage":"/assets/img/2024-06-23-GuidetoMultithreadinginiOS_0.png","tag":["Tech"],"readingTime":6},{"title":"SwiftUI에서 다양한 그리드 뷰를 만드는 방법 종합 가이드","description":"","date":"2024-06-23 23:53","slug":"2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide","content":"\n# LazyVGrid 그리고 LazyHGrid\n\nSwiftUI에서는 LazyVGrid 또는 LazyHGrid 뷰를 사용하여 반응형 그리드 뷰를 만들 수 있습니다. 만약 세로 그리드를 원한다면 LazyVGrid 뷰를 사용하고, 가로 그리드를 원한다면 LazyHGrid 뷰를 사용할 수 있습니다. 이러한 뷰들을 사용하면 다양한 화면 크기와 방향에 적응하는 항목 그리드를 생성할 수 있습니다.\n\nLazyVGrid\n\n그리드를 표시하는 가장 좋은 방법 중 하나는 적응형 열을 사용하는 것입니다. 화면 크기에 따라 자동으로 자식 요소를 적응시킵니다. SwiftUI를 사용하여 반응형 그리드 뷰를 생성하는 예시는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n\n    private var data  = Array(1...20)\n    private let adaptiveColumn = [\n        GridItem(.adaptive(minimum: 150))\n    ]\n\n    var body: some View {\n\n        ScrollView{\n            LazyVGrid(columns: adaptiveColumn, spacing: 20) {\n                ForEach(data, id: \\.self) { item in\n                    Text(String(item))\n                        .frame(width: 150, height: 150, alignment: .center)\n                        .background(Color.blue)\n                        .cornerRadius(10)\n                        .foregroundColor(Color.white)\n                        .font(.title)\n                }\n            }\n\n        } .padding()\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n출력:\n\n\u003cimg src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_0.png\" /\u003e\n\n.adaptive(minimum: 150) 으로 설정하면 가능한 한 많은 항목을 행당 씩, 각각 150포인트의 최소 크기를 사용하여 그리드에 맞게 설정하고 있다는 뜻입니다. 다양한 화면 사이즈에서 각 열에 표시되는 항목 수가 다르게 표시됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLazyVGrid에서 adaptive() 크기 수정자 외에도 fixed()이나 flexible() 크기 수정자와 같은 다른 수정자들을 사용할 수 있습니다.\n\nflexible() 크기 수정자\n\n각 열의 항목 수를 제어하려면 flexible() 크기 수정자를 사용할 수 있습니다.\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n\n    private var data = Array(1...20)\n    private let flexibleColumn = [\n\n        GridItem(.flexible(minimum: 100, maximum: 200)),\n        GridItem(.flexible(minimum: 100, maximum: 200)),\n        GridItem(.flexible(minimum: 100, maximum: 200))\n    ]\n\n    var body: some View {\n\n        ScrollView {\n            LazyVGrid(columns: flexibleColumn, spacing: 20) {\n                ForEach(data, id: \\.self) { item in\n                    Text(String(item))\n                        .frame(width: 100, height: 100, alignment: .center)\n                        .background(Color.blue)\n                        .cornerRadius(10)\n                        .foregroundColor(.white)\n                        .font(.title)\n                }\n            }\n        }\n        .padding()\n    }\n}\n\n# 미리보기 {\n    ContentView()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 사용 가능합니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_1.png\" /\u003e\n\nflexible() modifier를 사용하면 각 열의 항목 수를 제어할 수 있습니다. 그러나 뷰의 최소 크기를 수용할만큼 충분한 공간이 없는 경우 항목이 겹칠 수 있습니다.\n\nfixed() 크기 수정자\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 고정 크기의 열을 가진 LazyVGrid를 만들고 싶다면, 각 열에 .fixedSize() 수정자를 사용할 수 있습니다. 아래는 고정된 열을 가진 LazyVGrid를 생성하는 예시입니다:\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n\n    private var data = Array(1...20)\n    private let fixedColumn = [\n        GridItem(.fixed(100)),\n        GridItem(.fixed(100)),\n        GridItem(.fixed(100))\n    ]\n\n    var body: some View {\n\n        ScrollView {\n            LazyVGrid(columns: fixedColumn, spacing: 20) {\n                ForEach(data, id: \\.self) { item in\n                    Text(String(item))\n                        .frame(width: 100, height: 100, alignment: .center)\n                        .background(Color.blue)\n                        .cornerRadius(10)\n                        .foregroundColor(.white)\n                        .font(.title)\n                }\n            }\n        }\n    }\n}\n\nstruct ContentView_Previews: PreviewProvider {\n    static var previews: some View {\n        ContentView()\n    }\n}\n```\n\n출력:\n\n\u003cimg src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_2.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에서는 각 그리드 항목이 고정된 크기를 가지는 LazyVGrid를 만들었습니다. 열의 크기와 외관을 사용자 지정하여 특정 요구 사항에 맞출 수 있습니다.\n\nLazyHGrid\n\n그리드 항목을 수평으로 표시하려면 LazyHGrid를 사용할 수 있습니다. 이는 LazyVGrid와 정확히 같이 작동하지만 화면에 먼저 행을 맞추려고 합니다. 다음은 반응형 LazyHGrid 뷰를 사용하는 예시입니다.\n\n```js\nimport SwiftUI\n\n구조체 ContentView: View {\n\n    private var data = Array(1...20)\n    private let gridRows = [\n        GridItem(.adaptive(minimum: 150))\n\n    ]\n    var body: some View {\n\n        ScrollView(.horizontal) {\n            LazyHGrid(rows: gridRows, spacing: 20) {\n                ForEach(data, id: \\.self) { item in\n                    Text(String(item))\n                        .frame(width: 100, height: 100, alignment: .center)\n                        .background(.blue)\n                        .cornerRadius(10)\n                        .foregroundColor(.white)\n                        .font(.title)\n                }\n            }\n        }\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 출력 내용을 참고해주세요:\n\n\u003cimg src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_3.png\" /\u003e\n\n앱을 실행하면, 컨텐츠를 처음에는 위에서 아래로 채우려고 하다가 모든 항목이 들어갈 수 없으면 수평 스크롤이 가능해집니다. ScrollView에서는 수평 스크롤을 가능하게 하려면 .horizontal modifier를 포함해야 합니다.\n\nLazyVGrid와 같이 .fixed() 및 .flexible() modifier를 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게으른 그리드 뷰는 SwiftUI가 그들을 표시해야 할 때에만 자식 뷰를 생성합니다. 따라서, 메모리 최적화에 좋습니다.\n\n# 그리드 뷰\n\niOS 13에서 소개된 LazyVGrid 및 LazyHGrid입니다. iOS 16에서 Apple은 SwiftUI에서 Grid 뷰를 소개했습니다. 이제, 이미 Lazy Grid가 있기 때문에 그것이 불필요하거나 중복된 것으로 생각할 수도 있습니다. 그러나 Grid 뷰에 익숙해지면, 여러분의 인식이 바뀔 것입니다.\n\nGrid 뷰는 자식 뷰를 2차원 레이아웃으로 정렬합니다. 이를 통해 뷰를 테이블과 유사한 구조로 정리할 수 있습니다. HTML 테이블이나 어떤 테이블에 익숙하다면, SwiftUI를 사용하여 동일한 결과를 얻을 수 있습니다. 셀이나 열을 병합하거나, 빈 셀을 만들거나, 셀 간격을 설정하거나, 정렬을 제어하는 등의 작업을 할 수 있습니다. Grid 뷰는 복잡한 UI 개발에 강력한 도구를 제공합니다. 배울 것이 많습니다. 시작해보죠!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 GridView의 매우 기본적인 예제입니다:\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid ( horizontalSpacing: 20, verticalSpacing: 20 ) {\n            GridRow {\n                Text(\"R1, C1\")\n                Text(\"R1, C2\")\n            }\n            GridRow {\n                Text(\"R2, C1\")\n                Text(\"R2, C2\")\n            }\n        }\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n결과:\n\n\u003cimg src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가로 간격: 20, 세로 간격: 20으로 셀 간격을 사용했습니다.\n\n그리드 열\n\n그리드 뷰에 표시하려는 행 수를 제어하는 GridRow입니다. GridRow 내의 각 항목은 열 항목을 나타냅니다. 서로 다른 열 수로 행을 생성할 수 있습니다. 그렇게 하면 그리드가 행에 더 적은 열이있는 경우 자동으로 빈 셀을 행 끝에 추가합니다. 다음은 예시입니다:\n\n```js\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid {\n            GridRow {\n                Text(\"행 1\")\n                ForEach(0..\u003c3) { _ in Circle().foregroundColor(.red) }\n            }\n            GridRow {\n                Text(\"행 2\")\n                ForEach(0..\u003c5) { _ in Circle().foregroundColor(.green) }\n            }\n            GridRow {\n                Text(\"행 3\")\n                ForEach(0..\u003c4) { _ in Circle().foregroundColor(.mint) }\n            }\n        }\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 표 태그를 Markdown 형식으로 변경한 내용입니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_5.png\" /\u003e\n\n각 행이 다른 열의 수를 가질 때, 최대 열 수와 동일하게 맞추기 위해 빈 셀이 추가된 것을 관찰할 수 있습니다.\n\nGrid 너비와 높이:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리드의 너비와 높이는 해당 자식 뷰에 따라 증가합니다.\n\n- 그리드는 열의 모든 셀의 너비를 가장 넓은 셀에 맞춥니다.\n- 그리드는 특정 행의 가장 키가 큰 셀에 맞춰 전체 행의 높이를 설정합니다.\n\n그리드 내부의 뷰 확장\n\nGridRow 없이 그리드 뷰 내에 항목을 추가하면 전체 열을 확장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid(horizontalSpacing: 20, verticalSpacing: 20) {\n            GridRow {\n                Text(\"R1, C1\")\n                Text(\"R1, C2\")\n            }\n            Text(\"This will expand into full column\").font(.title)\n            GridRow {\n                Text(\"R2, C1\")\n                Text(\"R2, C2\")\n            }\n        }\n\n    }\n}\n\n# Preview {\n    ContentView()\n}\n```\n\n결과:\n\n\u003cimg src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_6.png\" /\u003e\n\n빈 셀\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 셀을 건너뛰고 어떤 뷰도 보여주고 싶지 않다면, Color.clear.gridCellUnsizedAxes([.horizontal, .vertical])를 사용하여 빈 셀을 추가할 수 있어요.\n\n여기 예시가 있어요:\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid {\n            GridRow {\n                ForEach(0..\u003c3) { _ in Circle().foregroundColor(.red) }\n            }\n            GridRow {\n                Circle().foregroundColor(.green)\n                Color.clear.gridCellUnsizedAxes([.horizontal, .vertical])\n                Circle().foregroundColor(.green)\n            }\n            GridRow {\n                ForEach(0..\u003c3) { _ in Circle().foregroundColor(.mint) }\n            }\n        }\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n결과:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Various kinds of GridView in SwiftUI - A Comprehensive Guide](/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_7.png)\n\n병합된 셀\n\n하나의 뷰가 두 개 이상의 열을 차지하도록 하려면 gridCellColumns(\\_:) 수정자를 사용하여 지정할 수 있습니다.\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n\n        Grid {\n            GridRow {\n                ForEach(0..\u003c3) { _ in Circle().foregroundColor(.red) }\n            }\n            GridRow {\n                Circle().foregroundColor(.green)\n                Text(\"2개의 셀 공간을 차지합니다\")\n                    .gridCellColumns(2)\n                    .font(.title)\n            }\n            GridRow {\n                ForEach(0..\u003c3) { _ in Circle().foregroundColor(.mint) }\n            }\n        }\n\n    }\n}\n\n#Preview {\n    ContentView()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 표 태그를 Markdown 형식으로 변경한 것입니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_8.png\" /\u003e\n\n그리드 뷰는 모든 자식 뷰를 한꺼번에 렌더링합니다. 앱의 성능을 높이려면 LazyHGrid나 LazyVGrid를 사용할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-23-VariousKindsofGridViewsinSwiftUIAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":14},{"title":"iOS 172 출시  꼭 알아야 할 27가지 중요한 사항","description":"","date":"2024-06-23 23:50","slug":"2024-06-23-iOS172Released27ThingsYouNEEDToKnow","content":"\n\u003cimg src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_0.png\" /\u003e\n\niOS 17.2가 오늘 드디어 공개되었습니다. 이번 iOS 17.x 업데이트는 다른 업데이트와는 다르답니다. 그만큼 많은 업데이트가 결합된 것보다 훨씬 크기 때문이에요.\n\n이번에는 여러분의 삶을 상당히 쉽게 만들어 줄 매우 유용한 새로운 기능이 수십 개 포함되어 있어요.\n\niOS 17.2에 대해 알아야 할 새로운 27가지 사항에 대해 소개해 드릴게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1 — 새로운 저널 앱\n새로운 Apple Music 변경 사항\n2 — 협업 플레이리스트\n3 — 즐겨 찾는 노래를 위한 독점 플레이리스트\n4 — 새로운 포커스 필터\n새로운 메시지 변경 사항\n5 — 메시지에 스티커 추가하는 새로운 방법\n6 — 당신의 Memoji 아바타를 위한 본체 선택\n7 — 세 가지 새로운 Memoji 포즈\n8 — iCloud로 메시지 강제 동기화\n9 — 그룹 채팅에서 최신 메시지로 이동하는 화살표\n새로운 위젯\n10 — 4가지 새로운 홈 화면 위젯\n11 — 새롭게 디자인된 잠금 화면 위젯\n새로운 Siri 변경 사항\n12 — 지리에 대해 더 많은 지식을 갖는 Siri\n13 — 전화 통화 시 어떤 앱을 사용할지 묻는 Siri\n새로운 연락처 변경 사항\n14 — FaceTime (및 전화)에서 이름과 사진 공유\n15 — 차단된 연락처가 FaceTime에 참여할 때 경고\n새로운 Apple TV 앱 변경 사항\n16 — 멋진 아이콘 재디자인\n17 — 새로운 버튼 — '정보' 및 '다음에 재생'\n새로운 UI 및 UX 변경 사항\n18 — 알람 울리는 UI 개선\n19 — 온라인 비디오 시청을 위한 UI 개선\n20 — 개인화된 공간 음향을 위한 간단한 프로세스\n21 — 근처 공유를 통한 지갑 패스 공유\n22 — iPhone 13 및 14 모델에 대한 Qi2 지원\n23 — 사미 키보드 지원\n24 — 날씨에서 강수량 총계\n25 — 앱 스토어 카테고리\n26 — Safari가 이전 기간을 기억하여 기록을 지우는 간편한 방법\n27 — AppleCare 및 보증이 이제 '커버리지'로 변경됨\n\n# #1. 새로운 저널 앱\n\n저널은 iOS 17과 함께 WWDC23에서 소개된 애플의 최신 앱입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJournal이라는 이름에서 알 수 있듯이, 이 애플의 일기 앱은 당신의 일상 활동으로부터 지적 제안을 받을 수 있는 기능과 영감을 주는 프롬프트와 같이 과거에는 없던 기능이 있습니다.\n\n## 내용에 대한 자세한 정보를 보려면 이것을 읽어보세요\n\n# 새로운 Apple Music 변경 사항\n\n## #2. 협업 재생 목록\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 17.2 Beta 3까지 Apple이 협업 재생 목록 - 스포티파이와 아마존 뮤직이 여러 년간 보유해 온 혁신적인 기능을 보여 주었습니다.\n\n하지만 안타깝게도 iOS 17.2 공식 릴리즈에는 아직 이 기능이 포함되지 않았어요. 그래도, 궁금하시면 아래 설명을 확인해보세요.\n\n(재생 목록을 협업 모드로 변경하려면, 상단 오른쪽 모서리에 있는 아이콘을 탭하세요:\n\n![이미지 변경](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 재생목록 링크를 공유하고 친구들이 참여할 수 있도록 허용하며, 재생목록에 곡을 추가, 삭제, 재정렬, 편집하고 노래에 이모지로 반응할 수 있습니다.\n\n카플레이에서는 승객이 곡을 추가할 수 있도록 SharePlay를 사용할 수 있습니다. 이 기능은 Apple Music 구독이 필요하지 않습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_3.png\" /\u003e\n\n최고의 파트,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 참여하기 전에 협력자를 승인할 수 있습니다.\n- 참여할 수 있는 사람 수에 제한이 없습니다.\n\n하지만 안타깝게도, 플레이리스트 링크는 7일 후에 만료되며, 그때 새로운 링크를 생성하여 더 많은 사람들을 위해 사용해야 합니다.\n\n## #3. 즐겨듣는 노래 전용 플레이리스트\n\n이제 즐겨듣는 모든 노래가 별도의 플레이리스트인 'Favourite Songs ⭐️'로 모아집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_4.png)\n\n노래 목록에서 일반적인 방법으로 곡을 삭제할 수 없습니다. 유일한 방법은 좋아요를 취소하는 것뿐입니다.\n\n## #4. 새로운 포커스 필터\n\nApple Music의 은밀 모드가 있습니다 — 바로 포커스 필터 형태로요. 설명해 드릴게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정으로 이동하세요 ⚙️ `컨트롤 센터 🌙` 선택 `필터 추가` 음악을 선택하고 '들은 음악'을 토글하세요.\n\n\u003cimg src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_5.png\" /\u003e\n\n이제, 활성화된 포커스 상태에서 재생하는 음악은\n\n- 추천 및 믹스에 영향을 미치지 않습니다.\n- 최근 재생 목록에 표시되지 않습니다.\n- 다른 사람들에게 Apple Music에서 표시되지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단히 말해, 이것은 Apple Music의 익명 모드입니다.\n\n누군가에게 iPhone을 빌려 음악을 듣도록 할 때에도 사용할 수 있어요. 그러면 그 사람의 선택이 여러분의 추천에 영향을 미치지 않아요.\n\n# 새로운 메시지 변경사항\n\n## #5. 메시지에 스티커 추가하는 새로운 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이메시지에 스티커를 붙일 수 있는 방법은 이미 알고 계실 거예요. 메시지 위에 드래그하여 스티커를 놓으면 스티커가 붙습니다. 아래와 같이요:\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_6.png)\n\n애플은 iOS 17.2에서 이 프로세스를 조금 더 쉽게 만들었어요.\n\n- 메시지를 간단히 햅틱한 상태로 누르고,\n- '스티커 추가'를 탭하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_7.png)\n\n- 선호하는 스티커를 선택하고,\n\n그리고 완료되었습니다.\n\n## #6. Memoji 아바타를 위한 몸을 선택하세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Memoji 아바타의 몸을 선택할 수 있어요.\n\n다음은 모든 가능한 섹션입니다:\n\n![Memoji](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_8.png)\n\n## #7. 새로운 세 가지 Memoji 포즈\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 Memoji의 의류와 몸을 변경하던 중, 세 가지 새로운 포즈를 발견했어요:\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_9.png)\n\n하지만 아직 스티커로 추가되지 않았어요.\n\n## #8. 메시지를 iCloud에 강제 동기화하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 17.2에서 Apple은 메시지를 iCloud에 강제 동기화할 수 있는 기능을 추가했어요. 메시지와 관련된 정보는 이제 '메시지' 대신 'iCloud 메시지'로 변경되었어요 (설정 ⚙️ `your_name` iCloud ☁️).\n\n메시지를 강제로 동기화하려면,\n\n- 'iCloud 메시지'로 들어가세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_10.png)\n\n- tap on Sync Now.\n\nYou may also wanna choose to keep your messages for 30 days, 1 year, or Forever in ‘Keep Messages’.\n\n## #9. Catch-Up Arrow for Group Chat\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플이 드디어 Messages에 Catch-Up 화살표를 추가했어요 (WWDC23에서 언급된 기능이에요).\n\n![Catch-Up arrow](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_11.png)\n\n이를 탭하면 놓친 긴 그룹 대화의 첫 메시지로 바로 이동할 수 있어요 — 그러니 이제 더 이상 메시지를 스스로 스크롤해야 할 필요가 없어요.\n\n# 새로운 위젯\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 10. 홈 화면 위젯이 4개 추가되었습니다\n\n3개의 새로운 날씨 위젯과 1개의 새로운 시계 위젯이 있습니다. 이것들:\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_12.png)\n\n첫 세 가지 위젯은\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 세부 사항: 강수 확률, 자외선 지수, 바람 등을 확인하세요.\n- 일일 날씨 예보: 특정 위치의 현재 날씨 조건과 일일 날씨 예보를 확인하세요.\n- 일출 및 일몰: 해당 위치의 곧 오는 일출 및 일몰을 확인하세요.\n\n네 번째 위젯은 현재 시간을 표시하는 디지털 시계입니다.\n\n## 11.1 Lock Screen 위젯 개편\n\niOS 17.2 베타에서 Weather의 Lock Screen Wind 위젯이 새로운 모양을 받았습니다. 🌬️\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 iOS 17.1에서 이랬다:\n\n![iOS 17.1](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_13.png)\n\niOS 17.2 Beta에서는 더 정확한 방향을 나타내기 위해 아날로그 방식으로 변경되었습니다.\n\n![iOS 17.2 Beta](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 iOS 17.2의 공개 릴리스에서는 iOS 17.1의 잠금 화면 바람 위젯으로 다시 변환되었습니다.\n\n# 새로운 Siri 변경 사항\n\n## #12. Siri가 지리적으로 더 높아졌어요\n\n- 고도:\n  iOS 17.1에서 Siri에게 고도를 물었더니 \"흥미로운 질문\"이라고 대답했어요 (좋은 회피, Siri). 그러나 iOS 17.2에서는 정확한 고도를 알려주고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_15.png)\n\n- ETA (예상 도착 시간):\n  Apple Maps로 어떤 장소로 이동 중이라면 (죄송해요 Google), 도착 예정 시간(ETA)을 알고 싶다면, 이제 Siri에게 간단히 물어볼 수 있어요.\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_16.png)\n\n## #13. 전화 걸 때 어떤 앱을 사용할지 묻는 Siri\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n옛날에는 Siri에게 전화할 대상을 요청하면 자동으로 전화 앱을 사용하도록 설정되었습니다.\n\n하지만 만약 카카오톡이나 페이스타임과 같은 다른 앱을 통화에 사용하고 싶다면 어떻게 해야 할까요? 명확히 언급해야 했습니다.\n\n하지만 iOS 17.2에서 Siri는 전화 앱이 아닌 다른 앱을 선호하는지 확인하기 위해 노력할 것입니다.\n\n![iOS 17.2](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_17.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 새로운 연락처 변경 내용\n\n## #14. FaceTime(그리고 전화)에서 이름과 사진 공유\n\n'이름과 사진 공유'는 새로운 기능이 아닙니다. 수 년 동안 iOS에 있던 기능입니다.\n\niMessage나 FaceTime을 통해 채팅하거나 대화하는 상대방에게 Apple ID 이름과 프로필 사진을 공개하거나 비공개로 유지할 수 있게 해줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 이제 iOS 17.1까지는 해당 설정을 설정 메뉴의 메시지 💬에서만 조정할 수 있었습니다 ⚙️.\n\n하지만 이제는 메시지 💬, 페이스타임 📹, 전화 📞에서도 조정할 수 있습니다. 모두 3가지에서 가능합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_18.png\" /\u003e\n\n## #15. 차단된 연락처가 페이스타임에 참가할 때 알림\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 17.2의 코드에는 차단된 연락처가 참여하는 FaceTime 통화에 대해 Apple이 경고할 수 있다는 내용이 나와요.\n\n![링크](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_19.png)\n\n이런 기능은 누군가로부터 스토킹을 받고 싶지 않은 사용자들을 위해 Apple이 브라보 프라이버시 조치를 취한 것이에요.\n\n# 새로운 Apple TV 앱 변경 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 16. 멋진 아이콘 재디자인\n\niOS 17.1의 TV 앱의 이전 하단 바를 살펴보세요:\n\n\u003cimg src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_20.png\" /\u003e\n\n이제 iOS 17.2에서 재디자인된 아이콘을 살펴보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_21.png)\n\n변경 사항:\n\n- '지금보기' 탭이 '홈'으로 이름이 변경되었으며 아이콘이 직사각형 모양으로 바뀌었습니다.\n- '(TV+) 오리지널' 탭은 이제 'Apple TV+'로 이름이 변경되었고, 아이콘도 unboxed로 바뀌었습니다.\n- '라이브러리' 아이콘에 플레이 버튼이 추가되었습니다.\n\n## #17. 새 버튼 - '정보' 및 '다음에'\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n영화나 시리즈를 시청할 때, 아래에 두 개의 새 버튼이 표시됩니다:\n\n![Info 버튼](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_22.png)\n\n- 정보:\n  콘텐츠 설명, 장르, 상영 시간을 보여주며, 비디오를 처음부터 재생하고 세부 정보를 확인할 수 있는 버튼이 있습니다.\n\n![Details 버튼](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_23.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다음에:\n  완전히 시청하지 않은 비디오를 보여줍니다. 계속 재생하고 싶을 것으로 기대합니다.\n\n![2024-06-23-iOS172Released27ThingsYouNEEDToKnow_24](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_24.png)\n\n# 새로운 UI 및 UX 변경\n\n## #18. 알람 울림을 위한 UI 전면 개편\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 작지만 멋지고 칭찬할 만한 UI 변경 사항입니다.\n\nDynamic Island을 사용하면서 알람이 울릴 때 iPhone을 사용하고 있다고 가정해 봅시다.\n\niOS 17.1까지는 이것이 그 UI였습니다(아주 단순한 UI):\n\n`![iOS 17.1 Old UI](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_25.png)`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 iOS 17.2에서 알람 시계가 흔들립니다 (긴급함을 느끼게 만듭니다):\n\n![알람 시계](https://miro.medium.com/v2/resize:fit:1400/1*9qbFme4APd2xa9Oc_yNZ7A.gif)\n\n## #19. 온라인 비디오 시청을 위한 새롭게 디자인된 UI\n\n저는 YouTube를 애플리케이션에서가 아니라 Safari에서 시청합니다. 왜일까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글의 #1에서 두 가지 이유를 설명했어요 →\n\n어쨌든, iOS 17.2의 전체 화면 비디오 UI가 변경되었다는 걸 발견했어요. 이전 UI는 다음과 같았어요:\n\n\u003cimg src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_26.png\" /\u003e\n\n하지만 요즘은,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 오른쪽에 있는 AirPlay 그림이 왼쪽 상단으로 이동합니다.\n세 점 메뉴 내의 재생 속도가 표시됩니다.\n\n현재 모습은 다음과 같습니다:\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_27.png)\n\n# #20. 개인화된 공간 오디오를 위한 간단한 프로세스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개인 맞춤형 공간 오디오 설정은 조금 귀찮은 작업일 수 있어요.\n\n- 먼저 얼굴 전체를 회전시켜 스캔해야 해요.\n- 그런 다음 왼쪽으로 돌아가면서 자신을 스캔해야 해요.\n- 그리고 오른쪽으로 돌아가면서 또 다시 스캔을 해야 해요.\n\n긴 과정이죠... 하지만 애플에서 이제 더 간단하게 했어요.\n\n이제 왼쪽으로 돌아가면서 얼굴을 한 번 스캔하고, 그리고 오른쪽으로 돌아가는 것만 하면 돼요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*CXhjvWRyxxUHbLpr1uT2ZQ.gif)\n\n이미 공간 오디오를 설정했다면 다시 설정할 필요가 없다는 것을 유념하세요.\n\n```js\n설정에서 공간 오디오 설정하기 ⚙️\n• AirPods_이름 🎧\n• 또는 소리 및 햅틱 🔊\n```\n\n# #21. 근처 공유를 통해 지갑 패스 공유하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 17에서 Apple은 NameDrop을 통해 연락처를 공유하고 두 대의 iPhone을 두드려 파일을 공유하는 혁신적인 기능을 선보였어요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1000/1*Nb3TsvnFTVCnyjD_hP6swA.gif)\n\n또한 iOS 17.2에서는 탑승권 및 영화 티켓과 같은 지갑 패스로 확장되었어요. 이제 동일한 방법으로 이들을 공유할 수 있어요.\n\n## 22. iPhone 13 및 14 모델용 Qi2 지원\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이폰 15 시리즈는 이미 Qi2 무선 충전을 지원합니다.\n\nIOS 17.2부터 Apple은 이전 두 시리즈인 13 및 14에도 Qi2 표준 무선 충전을 추가했습니다. 이로써 맥세이프 가격을 지불하지 않고 맥세이프 속도로 충전이 가능해졌습니다.\n\n멋지죠?\n\n# 23. 사미 키보드 지원\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플이 사미어를 위한 8개의 새 키보드를 선보였어요.\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_28.png)\n\n```js\n설정 ⚙️ \u003c 일반 ⚙️ \u003c 키보드 \u003c 키보드 \u003c 새 키보드 추가... 에서 사미어 키보드를 설정하세요.\n```\n\n# #24. 날씨에서 강수량\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n날씨 앱에 새로운 하위 섹션이 추가되었습니다. Precipitation Totals(시간별 예측 섹션).\n\n여기에는 다음이 표시됩니다.\n\n- 지난 24시간 강수량 및\n- 다음 24시간 예상 강수량.\n\n![이미지](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_29.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# #25. App Store의 카테고리\n\n앱 스토어가 멋진 새로운 디자인을 채택했어요.\n\nApps 또는 Games 섹션을 탭하면 이제 상단에 카테고리를 표시하는 내비게이션 바가 나타나요:\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_30.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 표를 변경하면 빠르게 스크롤하여 관심 있는 항목을 탭할 수 있습니다.\n\n이 기능은 이전에 아케이드에서만 제공되었었는데 (이것을 몰랐다면 지금 확인하세요), 이제 앱 및 게임에서도 제공됩니다.\n\n# #26. 사파리가 이전 시간대를 기억하여 히스토리 삭제\n\n사파리 히스토리를 정기적으로 삭제하는 경우, 여러분을 위한 (약간) 유용한 기능이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사파리(Safari)는 이제 당신이 히스토리를 지운 시간대를 기억합니다.\n\n![image](/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_31.png)\n\n예를 들어, '오늘'을 선택했다고 가정해 봅시다.\n다음에 히스토리를 지우러 오면, '오늘'이 이미 선택되어 있을 것입니다.\n\n하지만, 매번 히스토리를 지우려고 노력하는 대신에 왜 개인 탐색을 시도해보지 않으시겠어요? 더 안전하고 누구도 당신이 뭘 둘러봤는지 모를 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# #27. 보증은 이제 '애플케어 \u0026 보증'으로 변경되었습니다\n\n‘보증’은 모든 Apple 장치 및 보증 내용을 나열하는 섹션으로, 새로워진 이름과 위치로 바뀌었습니다.\n\n이전에는 설정 ⚙️ `일반 ⚙️` 정보에서 확인할 수 있었지만 이제 설정 ⚙️ ` 일반 ⚙️`으로 이동하였습니다. 한 걸음 더 간단해졌어요.\n\n\u003cimg src=\"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_32.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n및 이제는 AppleCare 및 보증으로 불립니다.\n\n## iOS 17 정말 멋지지 않나요?\n\n## iOS 17의 250여 가지 새로운 기능: 편집본 (항상 업데이트):\n\n## 마침내,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면 (저처럼), Setapp 구독을 고려해보세요. 매월 $9.99에 약 240여개의 멋진 앱을 이용할 수 있습니다. 이 앱들은 개별로 구매했을 때 수백 달러가 들 것이죠.\n\n- Setapp 여정을 시작할 수 있는 제 제휴 링크를 사용해보세요! (30일 무료 체험 가능)\n- Setapp에 있는 제 무료 70여가지 최고의 macOS 앱 목록을 받아보세요.\n\n새로운 이야기를 발행할 때마다 알림을 받기 위해 420여명과 함께 참여하세요!\n","ogImage":{"url":"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_0.png"},"coverImage":"/assets/img/2024-06-23-iOS172Released27ThingsYouNEEDToKnow_0.png","tag":["Tech"],"readingTime":23},{"title":"처음으로 Kotlin Multiplatform KMM 프로젝트를 Android Studio에서 빌드하는 방법","description":"","date":"2024-06-23 23:47","slug":"2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio","content":"\n![이미지](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_0.png)\n\n코틀린 멀티플랫폼(KMP)은 코틀린 프로그래밍 언어의 기능으로, 개발자가 단일 코드베이스를 사용하여 Android, iOS, JavaScript 및 JVM과 같은 여러 플랫폼에서 실행할 수 있는 코드를 작성할 수 있게 해줍니다.\n\n이 방식은 코드 재사용을 극대화하고 중복을 줄이기 위한 것으로, 공통 로직을 다른 플랫폼 간에 공유하면서 필요한 경우에 플랫폼별 코드를 사용할 수 있도록 합니다.\n\n# Kotlin 멀티플랫폼의 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 코드 재사용성: 공통 로직을 한 번 작성하고 여러 플랫폼에서 재사용하여 코드 중복 및 유지 보수 노력을 줄입니다.\n- 일관성: 동일한 코드베이스를 공유함으로써 다양한 플랫폼에서 일관된 동작을 보장합니다.\n- 생산성: 비즈니스 로직 및 기타 UI 이외의 구성 요소를 공유하여 개발 속도를 높입니다.\n- 유연성: 공유 코드베이스를 유지한 채 필요에 따라 플랫폼별 API 및 라이브러리를 사용합니다.\n\n이제 코드 작성을 시작하고 Android Studio에서 KMM 프로젝트가 어떻게 작동하는지 확인해보겠습니다.\n\n- Android Studio에 KMM 플러그인을 추가하고 플러그인이 추가되도록 IDE를 재시작합니다.\n\n![KMM project in Android Studio](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 안녕하세요! 안드로이드 스튜디오에서 새로운 KMM 앱을 만들고 있습니다. 프로젝트 구조가 아래와 같이 보일 것입니다.\n\n![프로젝트 구조](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_2.png)\n\n3. KMM 프로젝트의 shared 폴더는 코드 재사용성, 일관성, 효율적인 개발 목표를 달성하는 데 근본적인 역할을 합니다. 비즈니스 로직을 중앙 집중화하여 중복을 줄이고 유지보수를 간소화함으로써 더 나은 협업을 도모하고 플랫폼 간 일관된 동작을 보장합니다. 공유 코드를 활용함으로써 개발자들은 더 효율적이고 적은 리소스로 견고하고 기능이 풍부한 애플리케이션을 개발할 수 있습니다.\n\n![공유 폴더](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 리소스 및 이미지를 추가하기 위해 The IceRock Moko 라이브러리(Mobile Kotlin)를 사용할 예정입니다. 이 라이브러리는 Kotlin Multiplatform Mobile (KMM) 애플리케이션 개발을 간편하게 하는 데 사용되는 라이브러리 및 도구 세트입니다. 이러한 라이브러리는 iOS 및 Android를 위한 공유 코드 작성을 지원하여 개발자가 효율적으로 크로스 플랫폼 모바일 애플리케이션을 생성할 수 있도록 합니다. IceRock Moko는 네트워크 요청, 리소스, MVVM 아키텍처, 권한 처리 등과 같은 모바일 개발의 다양한 측면을 다루는 다양한 라이브러리를 제공합니다.\n\n5. build.gradle.kts (:shared) 업데이트\n\n```js\nplugins {\n    kotlin(\"multiplatform\")\n    id(\"com.android.library\")\n    id(\"dev.icerock.mobile.multiplatform-resources\")\n}\n\nkotlin {\n    android {\n        compilations.all {\n            kotlinOptions {\n                jvmTarget = \"1.8\"\n            }\n        }\n    }\n    task(\"testClasses\")\n\n    listOf(\n        iosX64(),\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach {\n        it.binaries.framework {\n            baseName = \"shared\"\n            isStatic = true\n            export(\"dev.icerock.moko:resources:0.22.3\")\n            export(\"dev.icerock.moko:graphics:0.9.0\")\n        }\n    }\n\n    sourceSets {\n        val commonMain by getting {\n            dependencies {\n                api(\"dev.icerock.moko:resources:0.22.3\")\n            }\n        }\n\n       val  commonTest by getting {\n           dependencies{\n               implementation(libs.kotlin.test)\n           }\n        }\n        val androidMain by getting\n        val iosX64Main by getting\n        val iosArm64Main by getting\n        val iosSimulatorArm64Main by getting\n        val iosMain by creating {\n            dependsOn(commonMain)\n            iosX64Main.dependsOn(this)\n            iosArm64Main.dependsOn(this)\n            iosSimulatorArm64Main.dependsOn(this)\n        }\n        val iosX64Test by getting\n        val iosArm64Test by getting\n        val iosSimulatorArm64Test by getting\n    }\n}\n\nandroid {\n    namespace = \"com.tokai.mobile.coffeeworld\"\n    compileSdk = 34\n    defaultConfig {\n        minSdk = 24\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n}\nmultiplatformResources {\n    multiplatformResourcesPackage = \"com.tokai.mobile.coffeeworld\"\n    multiplatformResourcesClassName = \"SharedRes\"\n}\n```\n\n6. build.gradle.kts(:androidApp) 업데이트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n플러그인 {\n    id(\"com.android.application\")\n    kotlin(\"android\")\n}\n\nandroid {\n    namespace = \"com.tokai.mobile.coffeeworld.android\"\n    compileSdk = 34\n    defaultConfig {\n        applicationId = \"com.tokai.mobile.coffeeworld.android\"\n        minSdk = 24\n        targetSdk = 34\n        versionCode = 1\n        versionName = \"1.0\"\n    }\n    buildFeatures {\n        compose = true\n    }\n    composeOptions {\n        kotlinCompilerExtensionVersion =\"1.4.4\"\n    }\n    packaging {\n        resources {\n            excludes += \"/META-INF/{AL2.0,LGPL2.1}\"\n        }\n    }\n    buildTypes {\n        getByName(\"release\") {\n            isMinifyEnabled = false\n        }\n    }\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n}\n\ndependencies {\n    implementation(projects.shared)\n    implementation(\"androidx.compose.ui:ui-tooling:1.6.8\")\n    implementation(\"androidx.compose.ui:ui-tooling-preview:1.6.8\")\n    implementation(\"androidx.compose.foundation:foundation:1.4.4\")\n    implementation(\"androidx.compose.material:material:1.4.0\")\n    implementation(\"androidx.activity:activity-compose:1.7.0\")\n    implementation(\"org.jetbrains.kotlin:kotlin-test:1.8.10\")\n    implementation(\"androidx.compose.material3:material3:1.1.2\")\n}\n```\n\n7. build.gradle.kts(CoffeeWorld)를 업데이트 합니다\n\n```js\n플러그인 {\n    // 동일한 플러그인 버전을 모든 서브 모듈에서 사용하기 위한 트릭\n    id(\"com.android.application\").version(\"8.0.1\").apply(false)\n    id(\"com.android.library\").version(\"8.0.1\").apply(false)\n    kotlin(\"android\").version(\"1.8.10\").apply(false)\n    kotlin(\"multiplatform\").version(\"1.8.10\").apply(false)\n}\nbuildscript {\n    dependencies {\n        classpath(\"dev.icerock.moko:resources-generator:0.22.3\")\n    }\n}\n\ntasks.register(\"clean\", Delete::class) {\n    delete(rootProject.buildDir)\n}\n```\n\nAndroid Studio에서 프로젝트를 다시 빌드하세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n8. 안드로이드 스튜디오에서 다음 버전들이 언급되었습니다.\n\n```js\nagp = \"8.0.1\";\nkotlin = \"1.8.10\";\ncompose = \"1.4.4\";\n```\n\n```js\ndistributionBase=GRADLE_USER_HOME\ndistributionPath=wrapper/dists\ndistributionUrl=https\\://services.gradle.org/distributions/gradle-8.0-bin.zip\nzipStoreBase=GRADLE_USER_HOME\nzipStorePath=wrapper/dists\n```\n\n9. 이제 공유 폴더인 commonMain 내 KMM 프로젝트에서 문자열 파일을 만들어 보겠습니다. resources라는 새 디렉토리를 만들었고, MR/base 및 MR/de를 만들었습니다. 영어 및 독일어 언어용 두 개의 문자열 파일을 생성했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_4.png\" /\u003e\n\nMR/base/strings.xml\n\n```js\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e\n\u003cresources\u003e\n    \u003cstring name=\"hello_world\"\u003e안녕 세계\u003c/string\u003e\n    \u003cstring name=\"hello_x\"\u003e안녕 %s\u003c/string\u003e\n\u003c/resources\u003e\n```\n\nMR/de/strings.xml\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e\n\u003cresources\u003e\n    \u003cstring name=\"hello_world\"\u003eHallo Welt\u003c/string\u003e\n    \u003cstring name=\"hello_x\"\u003eHallo %s\u003c/string\u003e\n\u003c/resources\u003e\n```\n\n10. shared 폴더 아래 iosMain과 androidMain에 String.kt 파일을 추가합니다.\n\n![image](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_5.png)\n\niosMain/Strings.kt\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n패키지 com.tokai.mobile.coffeeworld\n\nimport dev.icerock.moko.resources.StringResource\nimport dev.icerock.moko.resources.desc.Resource\nimport dev.icerock.moko.resources.desc.StringDesc\nimport dev.icerock.moko.resources.format\n\n실제 클래스 Strings() {\n    실제로 fun get(id: StringResource, args: List\u003cAny\u003e): String {\n        return if (args.isEmpty()) {\n            StringDesc.Resource(id).localized()\n        } else {\n            id.format(*args.toTypedArray()).localized()\n        }\n    }\n}\n```\n\nandroidMain/Strings.kt\n\n```js\n패키지 com.tokai.mobile.coffeeworld\n\nimport android.content.Context\nimport dev.icerock.moko.resources.StringResource\nimport dev.icerock.moko.resources.desc.Resource\nimport dev.icerock.moko.resources.desc.StringDesc\nimport dev.icerock.moko.resources.format\n\n실제 클래스 Strings(private val context: Context) {\n    실제로 fun get(id: StringResource, args: List\u003cAny\u003e): String {\n        return if (args.isEmpty()) {\n            StringDesc.Resource(id).toString(context = context)\n        } else {\n            id.format(*args.toTypedArray()).toString(context)\n        }\n    }\n}\n```\n\n11. 이제 프로젝트를 다시 빌드하고 KMM 프로젝트의 공용 폴더인 commonMain/resources/MR/images 경로에 이미지를 추가합니다. 이미지를 추가한 후 프로젝트를 다시 빌드합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_6.png)\n\n12. 이제 androidApp 내의 MainActivity에서 코드를 업데이트하고 프로젝트를 실행합니다.\n\n```js\nimport android.os.Bundle\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.tooling.preview.Preview\nimport com.tokai.mobile.coffeeworld.Greeting\nimport com.tokai.mobile.coffeeworld.SharedRes\nimport com.tokai.mobile.coffeeworld.Strings\nimport dev.icerock.moko.resources.StringResource\n\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyApplicationTheme {\n                Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    Column(\n                        modifier = Modifier.fillMaxSize(),\n                        verticalArrangement = Arrangement.Center,\n                        horizontalAlignment = Alignment.CenterHorizontally\n                    ) {\n                        Image(\n                            painter = painterResource(\n                                id = com.tokai.mobile.coffeeworld.R.drawable.coffee\n                            ),\n                            contentDescription = null\n                        )\n                        Text(\n                            text = stringResource(\n                                id = SharedRes.strings.hello_world\n                            )\n                        )\n                        Text(\n                            text = stringResource(\n                                id = SharedRes.strings.hello_x,\n                                \"Parita\"\n                            )\n                        )\n                    }\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun stringResource(id: StringResource, vararg args: Any): String {\n    return Strings(LocalContext.current).get(id, args.toList())\n}\n\n@Composable\nfun GreetingView(text: String) {\n    Text(text = text)\n}\n\n@Preview\n@Composable\nfun DefaultPreview() {\n    MyApplicationTheme {\n        GreetingView(\"Hello, Android!\")\n    }\n}\n```\n\n13. 결과물은 다음과 같이 보일 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_7.png)\n\n# 이 프로젝트의 Github 링크: https://github.com/paritadey/CoffeeWorld\n\nKMM에서의 다음 코딩 세트로 돌아오겠습니다. 그 동안 즐거운 코딩하세요!!\n","ogImage":{"url":"/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_0.png"},"coverImage":"/assets/img/2024-06-23-FirstKotlinMultiplatformKMMprojecttobuildinAndroidStudio_0.png","tag":["Tech"],"readingTime":14},{"title":"iOS 앱을 위한 UI 디자인 완벽 가이드","description":"","date":"2024-06-23 23:44","slug":"2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps","content":"\n\u003cimg src=\"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png\" /\u003e\n\niOS 앱을 위한 UI 디자인을 만드는 포괄적인 가이드를 공유하고 싶어요. 이 가이드는 우리가 애플 가이드라인과 일관성을 유지하면서 고품질 디자인을 만들기 위해 알아야 하는 필수 주제를 다룹니다.\n\n구성:\n\n- 레이아웃 및 그리드\n- 색상\n- 타이포그래피\n- 아이콘\n- 컴포넌트\n- 전환\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 레이아웃과 그리드\n\nFigma에서 iPhone용 다양한 아트보드 크기를 찾을 수 있고, 디자인을 위해 어떤 것을 선택해야 하는지 고민할 수 있습니다. 하지만 코드 수준에서 XCode는 자동으로 선택한 기기에 따라 레이아웃을 조정해줍니다. 따라서 가장 인기 있는 iPhone의 아트보드 크기를 선택하고, 이 모델의 레이아웃 사양을 고려하여 UI를 설계할 수 있습니다.\n\n아래 이미지는 iPhone 14 Pro의 레이아웃 영역과 사양을 보여줍니다.\n\n![iPhone 14 Pro Layout](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n☝️ 버튼 및 컨트롤과 같은 UI 요소는 상태 표시줄과 홈 인디케이터 영역에 가려지지 않는 영역에만 배치해야 합니다. 이렇게 하면 iOS 시스템 요소와의 상호 작용에 방해가 되지 않습니다.\n\n그리드는 콘텐츠를 구조적으로 배열하는 데 도움이 됩니다. 일반적으로 반응형 웹사이트 디자인에 사용되지만, 모바일 앱에서도 유용합니다.\n\n모바일 앱을 위한 그리드 정의 방법:\n\n- 화면 위에 요소를 정확히 배치하기 위해 8포인트 그리드를 생성합니다.\n- 좌우 여백을 16포인트의 최소 크기로 정의하세요. 이것은 iOS의 표준입니다.\n- 필요에 맞게 최적의 열 수를 정의하세요. 16포인트의 거터 크기가 가장 일반적이지만, 더 작거나 큰 거터 크기를 정의해야 한다면, 스트레치 그리드에서는 거터 크기가 열 너비에 영향을 미치므로, 거터 크기가 클수록 열 너비가 작아집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 이 멋진 기사를 확인해보세요! 여기서 모바일 그리드에 대해 더 배울 수 있어요.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_2.png)\n\n# 색상\n\niOS에는 활력, 접근성 설정 및 외형 모드에 자동으로 적응되는 시스템 및 의미론적 색상이 정의되어 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시멘틱 컬러는 목적을 설명하는 이름을 가진 색상입니다. 각 시멘틱 컬러에는 기본, 보조, 제3의 색상 변형이 있어서 등급에 따라 콘텐츠를 구분하는 데 사용됩니다. 예를 들어, 기본 배경에 대한 사용자 정의 색상을 정의하려면 색상 이름을 앱은 브랜드/앱의 약어이며 PrimaryBackground는 색상의 시멘틱 이름입니다. 사용자 지정 색상의 이름은 iOS 시스템 색상과 같아서는 안 됨을 언급할 가치가 있습니다.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_3.png)\n\n🎨 애플의 가이드라인을 고려하여 사용자 정의 색상 팔레트를 만드는 방법을 살펴보겠습니다.\n\n## 기본 색상\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱의 개성을 전달하는 데 기본적인 색상이 중요합니다. 이것은 팔레트의 기본 색상입니다. 대부분의 화면과 구성 요소에서 자주 표시되는 이 색상은 주요 작업을 나타내는 데 사용됩니다. 특정 UI 요소를 강조하거나 탭, 누름과 같은 상호 작용을 위한 UI 상태를 나타내는 데 주요 색상 쉐이드를 사용할 수도 있습니다.\n\nFigma에서 색상 쉐이드를 생성하려면 이 플러그인을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_4.png)\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 보조 및 강조 색상\n\n보조 색상은 주요 색상을 지원하고 디자인에 깊이와 다양성을 더합니다.\n\n![보조 색상](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_6.png)\n\n보조 색상 외에도 \"강조\" 색상 용어를 만날 수 있습니다. 강조 색상은 중요한 조치 및 컨트롤을 강조하는 데 사용되는 보조 색상의 일부로 고려할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n강조색은 다음에 가장 적합합니다:\n\n- 슬라이더 및 스위치와 같은 선택 컨트롤\n- 선택된 텍스트 강조\n- 진행 표시 막대\n- 링크 및 헤드라인\n\n기본 색을 보완하는 보조 색상을 찾으려면 Coolors와 같은 색 구성 생성기를 사용해보세요. 일반적으로 앱에는 1개의 주요 색상, 1-2개의 보조 색상 및 1-3개의 강조색이 있어야 합니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 채우기 색상\n\niOS에서는 채우기 색상이 UI 요소에 사용되며, 이를 통해 배경 색상이 나타납니다. 채우기 색상은 동일한 색상 값을 공유하지만 각 색상 변형마다 다양한 불투명도 수준을 갖고 있습니다.\n\niOS 채우기 색상 변형:\n\n- 기본 채우기 색상 — 슬라이더의 트랙과 같은 얇고 작은 모양에 사용됩니다.\n- 보조 채우기 색상 — 스위치의 배경과 같은 중간 크기의 모양에 사용됩니다.\n- 제 3위 채우기 색상 — 입력 필드, 검색 바 또는 버튼과 같은 큰 모양에 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image 8](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_8.png)\n\n![image 9](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_9.png)\n\n## 배경색상\n\niOS는 콘텐츠 및 요소의 그룹화를 구분하기 위해 배경색상의 색상 변형을 정의합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 전반적인 뷰의 기본적인 배경을 위한 기본(primary).\n- 전반적인 뷰 내에서 콘텐츠나 요소들을 그룹화하기 위한 보조(secondary).\n- 보조 요소 내에서 콘텐츠나 요소들을 그룹화하기 위한 제3 단계(tertiary).\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_10.png)\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_11.png)\n\n## 레이블 색상\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n라벨 색상에는 주요, 보조, 제 3 및 제 4 등급의 색상 변형이 있습니다. 중요도 수준에 따라 색상은 해당 투명도 수준을 갖습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_12.png)\n\n- 주요 레이블 색상은 사용자에게 강조해야 할 중요한 텍스트나 콘텐츠를 강조하는 데 사용됩니다. 예를 들어, 제목 및 헤드라인, 내비게이션 막대 페이지의 레이블, 양식에서의 필드 레이블 또는 입력 컨트롤에 주요 색상을 사용할 수 있습니다.\n- 보조 레이블 색상은 자막이나 지원 정보를 표시하는 데 사용됩니다. 보조 레이블은 양식과 입력 필드에서 필드나 입력 컨트롤에 대한 추가 컨텍스트나 지시사항을 제공하기 위해 사용될 수 있으며, 목록이나 테이블에서 목록이나 테이블 항목에 대한 보조 정보와 세부 정보를 표시하는 데 사용됩니다.\n- 제 3 등급 레이블 색상은 더 중요하지 않은 텍스트나 콘텐츠를 표시하는 데 사용됩니다. 더 이상 필수가 아닌 보충 정보나 앱 사용자의 이해에 필수적이지 않은 세부 정보를 표시하기 위해 사용됩니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_13.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 구분선 색상\n\n구분선은 콘텐츠 그룹을 시각적으로 구분하는 데 사용되는 가는 수평 선입니다. 표 뷰, 컬렉션 뷰 및 사용자 인터페이스의 다른 부분에서 시각적 계층 구조를 만들고 사용자가 콘텐츠의 구조를 이해하는 데 도움이 되도록 자주 사용됩니다.\n\niOS에서는 불투명도 수준을 가진 Separator 및 불투명 선 (일반 선) 두 가지 유형의 구분선 색상을 정의합니다.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_15.png\" /\u003e\n\n## 기능적인 색상\n\n기능적인 색상은 요소의 상태나 상태를 나타내거나 사용자에게 맥락이나 메시지를 제공하는 데 사용됩니다.\n\n기능적인 색상에 대한 지침:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 성공 상태: 성공 상태를 나타내기 위해 녹색이 자주 사용됩니다. 이는 작업이 성공적으로 완료되었거나 양식이 올바르게 작성되었음을 나타내는 데 사용될 수 있습니다.\n- 경고 상태: 노랑 또는 주황색이 경고 상태를 나타내는 데 흔히 사용됩니다. 이는 사용자에게 잠재적인 문제를 경고하거나 필수 조치가 아직 완료되지 않았음을 나타내는 데 사용될 수 있습니다.\n- 오류 상태: 빨강은 오류 상태를 나타내는 데 자주 사용됩니다. 이는 텍스트 또는 배경 색상, 또는 아이콘이나 버튼과 같은 요소에 사용될 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_16.png)\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_17.png)\n\n## 색상 관리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 Figma 플러그인이 있어서 색상 관리에 도움이 되는데요:\n\n- Color Palette Generator는 제공하는 단일 색상을 기반으로 색 팔레트를 생성합니다.\n- Color Contrast Checker는 두 색상 사이의 대조 비율을 확인하여 색상 선택이 접근성 지침을 준수하는지 확인하는 데 도움을 줍니다.\n- Colorblind Simulator을 사용하면 특정 유형의 색상 시각 결여를 가진 사람이 볼 때 디자인을 확인할 수 있습니다. 이를 통해 디자인이 모든 사용자에게 접근 가능한지 확인할 수 있습니다.\n- Dark Mode Magic을 사용하면 생성한 Light 테마를 기반으로 Dark 테마를 생성할 수 있습니다.\n\n# Typography\n\nApple은 San Francisco와 New York과 같은 내장된 글꼴 모음을 가지고 있습니다.\nSan Francisco에는 SF Pro를 포함한 여러 가지 변형이 있으며, SF Pro는 해당 글꼴의 표준 버전입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원하는 경우 사용자 정의 글꼴을 계속 사용할 수 있습니다. 몇 가지 고려해야 할 사항이 있습니다:\n\n- 글꼴이 가독성이 좋도록 해야 합니다. 가독성에 영향을 미치는 요소에는 문자 인식, 선 두께(문자를 구성하는 선의 두께), 트래킹(글자 간격), 리딩(줄 간격), 글꼴 크기 및 글꼴 스타일이 있습니다.\n- 모바일 앱에서 최대 두 가지 글꼴을 사용하여 간단하고 조화로운 인터페이스를 유지하는 것이 좋습니다.\n- 글꼴이 서로 어떻게 보왁 주위서 상치하는지를 고려하는 것이 중요합니다. 서로 너무 비슷한 글꼴 유형을 결합하는 것을 피해야 하며, 그렇지 않으면 서로 구별하기 어려울 수 있습니다.\n\nGoogle Fonts를 사용하여 다른 글꼴 조합을 미리보기하는 것을 고려해보세요. 또한 Figma가 제작한 준비된 Google 글꼴 유형 조합 팔레트를 사용할 수도 있습니다.\n\n## 글꼴 스타일 및 글꼴 크기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다양한 글꼴 크기와 굵기를 사용하여 제목, 헤딩, 본문 텍스트 및 캡션이란 텍스트 스타일을 구분합니다. 기본적으로 iOS에는 Large Title, Title 1, Title 2 등과 같은 미리 정의된 텍스트 스타일이 있습니다. 이러한 텍스트 스타일마다 기본 글꼴 크기와 다이나믹 타입 크기가 부여됩니다.\n\n다이나믹 타입은 iOS의 기능 중 하나로, 사용자가 앱 내 텍스트의 글꼴 크기를 조절할 수 있습니다. 사용자 정의 글꼴을 사용하려는 경우 기본 글꼴 크기뿐만 아니라, 다이나믹 타입 크기도 코드 수준에서 정의되어야 사용자가 텍스트의 글꼴 크기를 조절할 수 있도록 보장해야 합니다.\n\n사용자 정의 글꼴 스타일에 대해 기본 글꼴 크기를 선택하는 가이드로 다음 표를 고려해 보세요.\n\n![표](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_18.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 텍스트 레이아웃\n\n트래킹과 리딩은 최적의 가독성과 가시성을 위해 텍스트 레이아웃을 세밀하게 조정할 수 있는 필수적인 텍스트 속성입니다.\n\n트래킹은 글자 사이의 간격을 의미합니다. CSS에서는 \"letter-spacing\"으로 불리며, 트래킹과 letter-spacing은 동의어입니다.\n\n리딩은 텍스트 줄 사이의 간격을 말합니다. Figma와 CSS에서는 이 속성을 \"line-height\"라고 합니다. 줄 간격을 늘리거나 줄이는 것은 가독성을 향상시키는 데 도움이 될 수 있습니다. 리딩은 텍스트 기준선부터 측정됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 추적 및 리딩에 대한 몇 가지 팁:\n\n- 가독성을 높이려면 리딩을 증가시키세요. Figma는 가독성 있는 텍스트를 얻기 위한 최소한의 라인 높이로서 글꼴 크기의 1.125배(112.5%)로 설정할 것을 권장합니다. 그러나 값은 글꼴에 따라 다를 수 있습니다. 예를 들어, Apple은 본문 텍스트(SF Pro 글꼴)를 위한 리딩을 129%(22 pt)로 최소값으로 정의합니다. 그러나 긴 문단의 텍스트에 대한 좋은 가독성을 얻고 싶은 경우 141%(24 pt)로 리딩을 증가시키는 것을 권장합니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_19.png)\n\n- 좋은 가독성을 유지하려면 폰트 크기에 대한 추적 값을 너무 높거나 너무 낮게 사용하는 것을 피하는 것이 좋습니다. 시스템 글꼴의 최적 추적 값을 설명하는 Apple의 추적 테이블을 참고할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_20.png\" /\u003e\n\n# 아이콘\n\n아이콘은 인터페이스 항목, 작업 및 상태의 의미를 전달해야 하는 그래픽 요소입니다. 효과적인 아이콘은 사용자에게 간단하고 익숙하며 이해하기 쉬워야 합니다.\n\niOS에는 iOS 앱에서 사용할 수 있는 벡터 아이콘(SF Symbols) 세트가 제공됩니다. 여기 SF Symbols를 찾을 수 있는 Figma 파일이 있습니다. 또한 SF Symbols를 편집하고 사용자 정의하는 방법에 대한 상세한 비디오도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 앱에서 아이콘을 사용할 때 몇 가지 팁:\n\n- 사용자 정의 아이콘을 사용하려면 일관된 스타일, 크기 및 두께를 유지하는지 확인하세요.\n\n![Custom Icons](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_21.png)\n\n- 아이콘의 명암비를 테스트하세요. W3C에 따르면 아이콘과 같은 \"그래픽 객체\"는 적어도 3:1의 명암비를 가져야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_22.png)\n\n- 아이콘이 한눈에 알아볼 수 없으면 가능한 경우 텍스트 레이블을 추가하세요. 아래 예시에서 Headspace가 텍스트 레이블이 없다면, 왼쪽 아이콘(Today)의 의미를 빠르게 이해하기 어려울 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_23.png)\n\n- 모든 표준 화면에서 작동할 수 있도록 SVG와 같은 벡터 형식의 아이콘을 사용하세요. 1배 해상도의 표준 화면과 2배, 3배 고해상도의 레티나 디스플레이에 모두 작동해야 합니다.\n- 아이콘은 가독성이 있고 탭하기 쉬워야 합니다.\n- 일반 탭 바 아이콘의 크기는 적어도 25x25pt이어야 하며, 내비게이션 바의 아이콘은 20x20 또는 30x30pt가 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 아이콘에 대한 자세한 정보는 Apple의 문서를 확인해보세요.\n\n# 구성 요소\n\niOS에는 다양한 종류의 구성 요소 라이브러리가 있습니다. 이들을 모두 문서에서 찾을 수 있습니다. 여기서는 거의 모든 iOS 모바일 앱에서 찾을 수 있는 가장 인기 있는 세 가지 구성 요소 — 목록, 탭 바 및 네비게이션 바 — 에 대해 다루고, 각각에 대한 최선의 방법을 강조하고 싶습니다.\n\n## 목록과 표\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이템의 컬렉션을 표시하는 방법으로 목록과 표가 있습니다. 이 아이템들은 텍스트, 아이콘/이미지 또는 텍스트와 선택 컨트롤의 조합일 수 있습니다.\n\n![Image 1](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_24.png)\n\n![Image 2](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_25.png)\n\n최선의 방법들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 배경 전체에 다른 색상을 사용하여 배경과 콘텐츠 그룹 간의 시각적 대조를 만드세요.\n\n![Image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_26.png)\n\n- 테이블 콘텐츠를 논리적 그룹으로 분할하고 시각적으로 구분할 수 있도록 제목을 추가하세요. 이렇게 하면 사용자가 테이블에서 특정 항목을 쉽게 찾을 수 있습니다.\n\n![Image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_27.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n- 표 태그는 유사한 글꼴 스타일을 제목과 행 제목에 사용하지 마세요. 그렇게 하면 사용자가 컨텐츠 그룹을 구별하기 어려워질 수 있습니다.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_28.png)\n\n## 탭 바\n\n탭 바는 앱 내에서 다른 뷰로 전환할 수 있게 해주는 전역 탐색 컨트롤입니다. 각 탭은 의미 있고 설명적이어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**최상의 방법**\n\n- \"Home\" 또는 \"Overview\"와 같은 단일 탭에 관련 없는 콘텐츠를 그룹화하는 것을 피하세요. 예를 들어, 아래 이미지는 \"Home\" 탭이 \"검색\", \"즐겨찾기\", \"친구\"와 같은 관련 없는 기능을 결합한 것을 보여줍니다. 이는 사용자가 필요한 것을 찾기 어렵게 만듭니다. 이러한 문제를 해결하기 위해 핵심 기능과 섹션을 식별하여 콘텐츠를 각각 다른 탭으로 분리하고 관련된 콘텐츠만 그룹화하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 테이블 태그를 Markdown 형식으로 변경해주세요.\n\n![Image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_31.png)\n\n## 내비게이션 바\n\n내비게이션 바는 앱의 계층 구조를 통해 탐색할 수 있는 탐색 컨트롤입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_32.png)\n\n최상의 사용법\n\n- 네비게이션 바에 너무 많은 작업을 추가하는 것은 인터페이스를 지저분하게 만듭니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_33.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 네비게이션 바와 필터, 세그먼트 컨트롤 등과 같은 다른 요소 간에 충분한 대조가 있는지 확인합니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_34.png)\n\n# 전환\n\n전환은 한 뷰 또는 뷰 세트의 외관을 다른 것으로 변경하는 방법입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*-TfC1w0q9QTAExsVkopbGg.gif\" /\u003e\n\niOS는 일련의 표준 전환 스타일을 제공합니다. 사용자가 적응하는 데 추가 노력을 필요로 하는 것을 방지하기 위해 사용자 정의 애니메이션을 생성하려면 iOS 표준 스타일을 따르도록 확인하십시오. 그렇지 않으면 사용자 만족도가 감소할 수 있습니다.\n\n기억해야 할 권장 사항:\n\n- 사용자에게 혼란을 야기할 수 있는 복잡하거나 화려한 전환을 사용하지 마세요.\n- 일관된 지속 시간과 타임팅을 사용하여 사용자에게 부드럽고 연속적인 경험을 제공하세요.\n- 사용자의 주의를 산만하게 하는 너무 빠르거나 너무 느린 전환을 사용하지 마세요.\n- 코드 수준에서, 사용자 지정 전환은 \"모션 줄이기\"가 꺼져 있을 때 접근성 설정에 응답할 수 있도록 해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드 없이 사용자 정의 전환을 만들 수 있는 몇 가지 도구:\n\n- LottieFiles\n- ProtoPie\n- Flow\n\n# 결론\n\n이 글이 도움이 되었기를 바랍니다. 주제에 대한 피드백이나 제안이 있으면 기쁠 것입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 새 YouTube 채널 구독해보세요! UX/UI 디자인 통찰과 팁에 관한 영상을 만나보세요.\n\nLinkedIn에서 연락 주시거나 Twitter에서 팔로우해주세요. 감사합니다!\n","ogImage":{"url":"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png"},"coverImage":"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png","tag":["Tech"],"readingTime":20},{"title":"당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 ","description":"","date":"2024-06-23 23:40","slug":"2024-06-23-SettingupanewMacmytop3essentials","content":"\n![새 맥을 설정하기_2024-06-23](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_0.png)\n\n새로운 맥을 사는 것은 저에게는 섞인 감정이었습니다 — 애플 스토어에 가서 꼼꼼히 선택하고 집에 가져오는 것에서 늘 설렘이 있었지만, 그 후로는 적어도 제게는 잠정 두려움과 불안이 더해졌습니다.\n\n2015년에 내가 27인치 iMac을 산 때를 생생하게 기억합니다. 사무실 뒷쪽에 약 한 달 동안 방치되어 있었는데, 마침내 용기를 내어 개봉하고 작업에 들어갔습니다.\n\n어두운 그때, 새 맥을 설정하는 일은 따분하고 긴박한 위험을 감수해야 하는 연습이었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nApple 및 macOS는 멀리 왔습니다. 그들은 그것을 간단하고 세련된 것으로 만들었으며, 지금은 금상첨화처럼 매우 간편합니다.\n\n하지만 간단하다고는 하지만 — 여전히 선택해야 할 사항이 있습니다.\n\n![Setting up a new Mac](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_1.png)\n\n# 새로운 맥북 — 새로운 나\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nApple은 새로운 구매 제품을 설정하는 데 하나의 방법으로 기존 Mac에서 데이터를 이동하는 옵션을 제공합니다.\n\n이제 항상 그것이 유혹적으로 들리고 나는 옵션 위에 잠시나마 마우스를 올려놓곤 하는데… 그래도 나는 그것을 클릭하려는 용기를 내지 못한 적이 없습니다. Apple이 그 옵션을 빠르고 원활한 설정으로 만들었을 것이라는 것을 확신하지만, 새로운 Mac이 내 앞에 빛나는데, 나는 가능한 한 깨끗하고 혼란스럽지 않게 유지하고 싶습니다.\n\n나는 언제나 마이그레이션을 통해 앱, 데이터 및 일반적인 불필요한 소프트웨어가 함께 전송될 수 있다는 두려움을 항상 가지고 왔습니다.\n\n나는 내 Mac에 넣는 것에 대해 꽤 조심스러운 편이지만 — 나는 성질이 좋다고 말할 수 없으며 시간이 지남에 따라 혼란이 쌓일 것이라고 꽤 확신합니다. 나는 항상 새로운 Mac을 새로 시작할 수 있는 기회로 보는 편입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 모든 것의 열쇠\n\nApple의 정원에 갇힌 느낌이 든다면, 새 Mac에서 Apple ID에 로그인하는 순간에 이미 75% 정도는 끝났어요.\n\n최근 Nothing과 Bleeper에서 나온 모든 소식을 보면, 우리의 Apple ID의 중요성이 부각되었어요. 이는 Apple 생활에서 거의 모든 것의 열쇠입니다 — 비밀번호, 지갑 및 아이디일 수도 있어요. 그래서 Apple 이외의 누구와도 공유하는 것을 생각한다면 두려움에 떨게 돼요.\n\n저의 이야기를 오랜 시간 읽어온다면, 몇 달 전 해킹당할 뻔했다는 이야기를 알고 계실 거예요. 그 허니트랩에 속아 넘어졌어서 정말 바보 같았지만, 운이 좋아 무사했어요 — 하지만 소중한 교훈을 얻었죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정한 것 중 첫 번째는 즉시 Apple ID 로그인 세부 정보를 변경하는 것이었습니다. 우리 중 많은 사람들처럼 예전부터 같은 세부 정보를 계속 사용해 왔다고 의심합니다. 솔직히 이전 비밀번호는 웃기게 간단했습니다. 이제 더욱 안전한 새 비밀번호가 설정되어 있고, 가능한 한 많은 계정에서 사용하는 2단계 인증 앱을 가지고 있습니다. 결국에는 잠재적으로 나쁜 상황에서 좋은 결과가 나왔습니다.\n\n![새 Mac를 설정하는 중요한 3가지](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_2.png)\n\n하지만 iCloud 계정에 안전하게 로그인한 후에는 캘린더, 이메일, 노트, 알림, 스프레드시트 및 iMessage가 모두 설정되어 준비되어 있습니다. 그것은 그야말로 통증 없이 그리고 간단했습니다. 그 순간부터 작업을 시작할 수 있어요.\n\n# 문제를 복잡하게 만드는 것\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금 제 상황은 깔끔한 편입니다. 대체로 저는 모든 네이티브 애플 앱을 사용하는 편이라서 비밀번호 관리자를 포함한 애플 앱을 신뢰합니다. 애플에 대한 신뢰는 누구에게도 못지않고, 그들의 프라이버시 기록은 상당히 인상적입니다.\n\n그러나 제3자 비밀번호 관리자 및 캘린더 앱을 사용하고 있다면, 새로운 맥북에서 성능을 향상시킬 때 이러한 앱들이 우선 순위가 될 것입니다.\n\n'깔끔한 설치' 접근 방식이 조금 더 많은 작업을 유발할 수 있지만, 최소한 초기 몇 일, 주, 그리고 개월 동안은 해당 맥북에는 필수 도구만 설치되어 있다는 점을 알 수 있고, 네이티브 앱을 사용함으로써 macOS에 가능한 최적화되어 있는 것이 확실합니다.\n\n저에게 새로운 맥북은 지금은 다소 다르게 다가오는데, 종종 심사하면서 구매하는 경우가 많습니다. 하지만 설정하는 데 드는 고심은 변하지 않았습니다. 본질적으로 그래도 여전히 그 같은 애플 열광자인 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 새로운 M1 iMac의 경우, 이메일은 로컬에서 iCloud 이메일만 설정되어 있어요. 제가 정기적으로 사용하는 다른 두 이메일 계정은 클라우드 기반 솔루션에 의존하고 있어요. 적어도 로컬 메일함을 메꿔 버리지 않고도 어떤 일이 벌어지고 있는지 확인할 수 있어 좋아해요.\n\n새 맥을 설정할 때마다 간편하고 쉽고 빠르게 설정하는 것 같아요. 설정이 완료되면 새 맥에 설치할 필수 앱 세 가지를 선택하는 것이 결정사항인 거죠. 맥 앞에 앉은 사람에 대해 많은 얘기를 해주는 것 같아요.\n\n당신의 선택은 아마 다를 거예요. 하지만 내가 필수로 갖춰야 한다고 생각하는 것을 밝히고, 당신의 맥에서 가장 중요한 앱 3가지는 무엇인지에 대해 대화를 시작하고, 당신의 의견을 듣고 싶어요.\n\n# 1. Dropbox\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Setting up a new Mac](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_3.png)\n\n혹시 새롭게 시작한다면 — 현재처럼 Dropbox이 필요한 정도는 아마 제 목록에서 그리 높지 않았을 것 같아요.\n\n첫 iMac을 산 시점과 거의 동시에 Dropbox을 사용하기 시작했어요. 그러니까, 이 저장 서비스를 약 10년 동안 사용했고 많은 데이터를 저장했어요.\n\n저는 현재 3TB 비즈니스 요금제를 사용 중이며, 1.7TB를 사용 중입니다 — 그래서 상당히 많이 사용하는 사용자라고 할 수 있어요. 매년 $165를 지불하며, 이것은 꽤 좋은 가치라고 생각해요. 기대하건대 — 모든 그 동안에 서비스가 다운되거나 곤경에 처한 적은 없었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근 몇 년 동안 Dropbox는 훨씬 세련되어졌어요. 저는 지금 제공하는 많은 서비스를 사용하지는 않지만, 견고하고 신뢰성 있으며 가격이 합리적하고 사용하기 쉬운 클라우드 저장소로 충분히 잘 작동합니다.\n\n앞서 말한 대로, 새로 시작한다면 Dropbox을 선택하지 않을 수도 있어요. 다시 한 번 말하지만 그 이유는 Apple 때문입니다.\n\niCloud Drive는 Dropbox과 매우 유사한 방식으로 작동하며, 대신 그것을 사용하기로 결정할 수도 있을 것 같아요. Apple이 아직 따라 하지 않은 Dropbox의 Smart Sync 기능이 있어요. 처음에 발표된 그것은 정말 혁신적이었어요. 로컬로 저장하지 않고 모든 작업을 볼 수 있는 기능은 정말 대단한 발상이었죠.\n\n저는 Apple One 번들에 포함된 2TB iCloud Drive 저장 공간을 사용하고 있어요. 하지만 Apple의 업그레이드 옵션은 조금 이상해요. 저장 공간을 점진적으로 늘릴 수 없어요. 요금제는 월 £8.99로 2TB부터 시작해서 월 £26.99로 6TB로 늘어나고, 엄청난 월 £54.99로 12TB까지 늘어납니다. 모든 것이 Apple의 지원 아래에 있는 것은 마음에 들지만, 제가 바꿀 만큼의 가치가 없어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. Clean My Mac\n\n![Clean My Mac](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_4.png)\n\n이것은 분명히 애매모호한 순간이 될 것 같아요.\n\n먼저 말씀드리고 싶은 것은 제가 Clean My Mac과 재정적인 연결이 없다는 점입니다. 그들은 한 달 전에 제가 구입한 애플리케이션을 모든 Mac에서 사용한 몇 년 뒤에 동영상 중 하나를 후원해 주었었지만요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클린 마이 맥을 언급하자마자 반대하는 사람들이 나타나서 그것은 쓸데없고 도움이 안 된다고 빨리 말하지만, 난 경험 니 말이 스피크 해 보겠다.\n\n맥을 정말 좋아하는 만큼, 화면 뒤의 작동을 완전히 이해하는 데는 천재가 아니다.\n\n그래서 나와 같은 사람을 위해, 클린 마이 맥은 내 맥에서 쓰레기를 청소하고 건강하게 유지하는 데 도움이 되었던 간단한 솔루션을 제공한다. 또한 나는 그것이 언급한 해킹 시도에 어느 정도 도움이 되었다고 생각한다.\n\n## 3. 크리에이티브 클라우드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_5.png)\n\n네이티브 Apple 앱에서 작업하지 않을 때는 주로 Ulysses나 Adobe 앱 중 하나에서 작업할 것입니다.\n\nUlysses는 보통 일주일에 세 번 이상 사용합니다. 여기서 이야기를 모두 작성하고 비디오 스크립트를 작성합니다. 그러나 만약 절대적으로 필요하다면 다른 앱에서도 쓸 수 있습니다.\n\n하지만 Adobe의 경우, 창의적인 앱으로서 다른 앱에서는 재현하기 어려운 앱들이기 때문에 매일 Creative Cloud 앱 중 하나를 사용합니다. 주로 사용하는 앱은 Premiere, Photoshop, Lightroom, Audition, In Design입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nClean My Mac이랑 마찬가지로 Creative Cloud에 대해 부정적인 의견들이 종종 있습니다. 왜냐하면 이것이 구독만 가능한 서비스이기 때문이죠.\n\n여태까지 Adobe에 돈을 많이 썼다고 계산해보면 분명히 좀 찡하겠죠. 하지만 정말 괜찮습니다. 그들은 구독 방식을 가장 먼저 채택한 기업 중 하나였고, 지금은 돈이 나가는 것을 거의 느끼지 못합니다. 이를 경박하게 말하는 것이 아니라, 제게는 큰 가치가 있거든요. 4개나 5개의 앱을 사고 업데이트하는데 드는 비용도 싼 건 아니었을 테니까요!\n\n다시 말하지만, Dropbox와 유사하게, 현재 처음 시작한다면 아마도 Final Cut 및 Logic 경로(나의 애플 열렬한 팬이기도 해요!)를 시도할 수도 있을 거예요. 하지만 Adobe에서 너무 오랜 시간을 보내왔고, 그들의 앱이 어떻게 작동하는지에 대한 미묘한 세부 사항들은 다시 교육 받는 데 시간을 낭비할만큼 나이가 들었거든요.\n\n프로그램을 사용하는 것은 기본적인 작업을 할 때나 잘 동작할 때는 충분히 쉽다고 말씀드렸죠. 하지만 진짜 시험은 문제가 발생했을 때야 옵니다. 그때 당신이 소프트웨어를 알아야 하는 것이죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 지난 주 대부분을 새로운 맥 세트업 중 가장 최근에 나온 M3 iMac 작업에 할애했어요. 이 앱들은 이미 모두 설치되어 사용 중이에요.\n\n![이미지](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_6.png)\n\n저는 애플이 1월에 M3 Pro 칩이 탑재된 새로운 맥 미니를 출시할 것을 기대하고 있어요. 그렇다면 다시 이제는 시험된 설정 절차를 거치게 될 거에요.\n\n새로운 맥을 실행하는 가장 빠른 방법은 아닐 수도 있지만, 에이, '문제가 생기기 전까진 손대지 말라'는 속담을 따를 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n200개가 넘는 생산성 앱을 한 곳에서 쉽게 확인해보고 싶나요? 그렇다면 SetApp을 확인해보세요. 정말 멋져요 — 매달 정액 요금을 지불하면 Bartender, CleanShot X, Paste, iStat Menus, BetterTouchTool과 같은 훌륭한 앱들 중에서 선택할 수 있어요. 만약 시도해보고 30일 무료 체험을 원한다면 제 제휴 링크를 클릭해서 살펴보세요. 어떤 앱이 가장 마음에 드는지 알려주세요.\n\n매주 일요일마다 무료 회원 비디오 뉴스레터를 발송할 예정이에요. 받아보고 싶다면 여기에 세부사항을 남겨주세요.\n\n2023년 12월 12일에 https://talkingtechandaudio.com에서 원문이 게시되었어요.\n","ogImage":{"url":"/assets/img/2024-06-23-SettingupanewMacmytop3essentials_0.png"},"coverImage":"/assets/img/2024-06-23-SettingupanewMacmytop3essentials_0.png","tag":["Tech"],"readingTime":10},{"title":"WWDC 2024 Swift의 새로운 동시성 기능 탐구","description":"","date":"2024-06-23 23:39","slug":"2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency","content":"\nSwift Concurrency는 처음 소개되었을 때부터 화제가 되었고, WWDC 2024에서 발표된 혁신적인 기술들로 더욱 발전하였습니다. Apple은 개발자들이 안전하고 효율적이며 고성능의 비동기 코드를 작성할 수 있도록 지원하고 있습니다. 이 블로그에서는 WWDC 2024에서 발표된 Swift Concurrency의 새로운 기능과 개선 사항에 대해 알아보겠습니다. 이를 통해 이러한 개념을 설명하는 코드 스니펫을 제시할 것입니다.\n\n# Swift Concurrency 소개\n\n프로그래밍에서 Concurrency는 여러 작업이 동시에 실행되는 것을 의미하며, 특히 계산이 많거나 외부 자원을 기다리는 작업을 하는 애플리케이션의 성능을 크게 향상시킬 수 있습니다. Swift Concurrency는 Swift 5.5에서 처음 소개되었으며, async/await, actors, 그리고 구조적 동시성을 도입하여 비동기 코드를 더욱 쉽고 안전하게 다룰 수 있도록 하였습니다.\n\n# Swift Concurrency의 새로운 기능 (WWDC 2024)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 작업 그룹 업데이트\n\n작업 그룹을 사용하면 동시에 실행되는 작업 그룹을 생성할 수 있습니다. WWDC 2024에서의 개선 사항은 더 나은 오류 처리와 더 유연한 작업 관리를 포함하고 있습니다.\n\n## 코드 스니펫: 작업 그룹\n\n```js\nimport Foundation\nfunc fetchAllData() async throws -\u003e [Data] {\n    var results: [Data] = []\n    try await withThrowingTaskGroup(of: Data?.self) { group in\n        for url in [\"https://api.example.com/data1\", \"https://api.example.com/data2\"] {\n            group.addTask {\n                guard let url = URL(string: url) else { return nil }\n                return try? Data(contentsOf: url)\n            }\n        }\n        for try await result in group {\n            if let data = result {\n                results.append(data)\n            }\n        }\n    }\n    return results\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 여러 URL에서 동시에 데이터를 가져오기 위한 작업 그룹을 만듭니다. withThrowingTaskGroup은 이제 오류를 더 잘 처리하여 더 견고하고 오류에 강한 코드를 작성할 수 있습니다.\n\n## 2. Async Streams\n\nAsync Streams는 라이브 데이터 피드와 같은 비동기 값 시퀀스를 처리하는 과정을 간소화합니다.\n\n### 코드 조각: Async Streams\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nimport Foundation\nfunc fetchLiveUpdates() -\u003e AsyncStream\u003cString\u003e {\n    AsyncStream { continuation in\n        let timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in\n            continuation.yield(\"New update at \\(Date())\")\n        }\n\n        continuation.onTermination = { _ in\n            timer.invalidate()\n        }\n    }\n}\n\nTask {\n    for await update in fetchLiveUpdates() {\n        print(update)\n    }\n}\n```\n\n여기서 AsyncStream은 1초마다 새 값을 발행하는 라이브 업데이트 스트림을 생성하는 데 사용됩니다. continuation.onTermination 블록은 스트림이 종료될 때 타이머가 무효화되도록 합니다.\n\n# 3. 향상된 액터 모델\n\nSwift의 Actor는 동시성 환경에서 공유 가능한 가변 상태에 안전한 액세스를 보장합니다. 2024 업데이트에는 더 효율적인 데이터 액세스 패턴과 기존 Swift 코드와의 상호 운용성이 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 코드 조각: 향상된 Actor\n\n```js\nimport Foundation\n\nactor BankAccount {\n\n   private(set) var balance: Double = 0.0\n\n   func deposit(amount: Double) {\n        balance += amount\n   }\n\n   func withdraw(amount: Double) -\u003e Bool {\n        if balance \u003e= amount {\n            balance -= amount\n            return true\n        } else {\n            return false\n        }\n   }\n}\n\nlet account = BankAccount()\nTask {\n    await account.deposit(amount: 100.0)\n    let success = await account.withdraw(amount: 50.0)\n    print(\"출금 성공: \\(success), 잔액: \\(await account.balance)\")\n}\n```\n\n이 예제에서는 입금과 출금을 안전하게 처리하기 위해 BankAccount actor를 정의했습니다. await 키워드는 각 작업이 완료될 때까지 다음 작업이 시작되지 않도록 보장하여 데이터 무결성을 유지합니다.\n\n# 4. 작업 취소 개선 결과\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업 취소는 리소스를 관리하고 앱 반응성을 향상시키는 데 중요합니다. 최신 업데이트로 작업을 취소할 때 더 나은 제어와 예측 가능한 동작을 제공합니다.\n\n## 코드 스니펫: 작업 취소\n\n```js\nimport Foundation\n\nfunc performTask() async {\n    let task = Task {\n        for i in 1...10 {\n            if Task.isCancelled {\n                print(\"작업이 취소되었습니다\")\n                return\n            }\n            print(\"작업 실행 중: \\(i)\")\n            try await Task.sleep(nanoseconds: 1_000_000_000)\n        }\n    }\n\n    // 취소 시뮬레이션\n    await Task.sleep(nanoseconds: 3_000_000_000)\n    task.cancel()\n}\n\nTask {\n    await performTask()\n}\n```\n\n이 코드에서는 작업이 1초마다 메시지를 출력하는 루프를 실행합니다. 작업이 취소되면 (여기서 3초 뒤에 시뮬레이션됨), 취소 여부를 확인하고 정상적으로 종료됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 향상된 오류 처리\n\nSwift Concurrency의 개선된 오류 처리 기능은 비동기 코드에서 오류를 처리하고 전파하는 더 나은 메커니즘을 제공하여 더 견고한 애플리케이션을 만들 수 있게 돕습니다.\n\n## 코드 스니펫: 향상된 오류 처리\n\n```swift\nimport Foundation\nenum DataError: Error {\n    case invalidURL\n    case requestFailed\n}\nfunc fetchData(from urlString: String) async throws -\u003e Data {\n    guard let url = URL(string: urlString) else {\n        throw DataError.invalidURL\n    }\n    do {\n        let (data, _) = try await URLSession.shared.data(from: url)\n        return data\n    } catch {\n        throw DataError.requestFailed\n    }\n}\n\nTask {\n    do {\n        let data = try await fetchData(from: \"https://api.example.com/data\")\n        print(\"Data received: \\(data)\")\n    } catch {\n        print(\"Failed to fetch data: \\(error)\")\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제는 Swift의 async/await와 함께 에러 처리 메커니즘을 사용하여 비동기 함수에서 에러를 효과적으로 처리하는 방법을 보여줍니다.\n\n# 결론\n\nWWDC 2024에서 소개된 Swift Concurrency의 개선 사항은 개발자가 효율적이고 안전한 비동기 코드를 작성하는 데 더욱 쉽게 만들어 줍니다. 작업 그룹, async 스트림, actor 모델, 작업 취소 및 에러 처리에 대한 개선 사항을 통해 Swift는 현대 애플리케이션 개발을 위한 강력한 언어로 발전하고 있습니다.\n\n이러한 새로운 기능을 프로젝트에 통합하여 더 빠르고 견고한 응용 프로그램을 만들 수 있습니다. 항상 실험을 진행하고 Swift Concurrency의 기능을 탐색하여 개발 워크플로우에서 그 강력함을 최대한 발휘해보세요. 즐거운 코딩 되세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 아래는 테이블 태그를 Markdown 형식으로 변경하였습니다.\n\n![이미지](/assets/img/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency_0.png)\n\n퀵 커넥트:\n\n[LinkedIn 프로필](https://www.linkedin.com/in/shubhransh-gupta)\n","ogImage":{"url":"/assets/img/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency_0.png"},"coverImage":"/assets/img/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI의 NavigationStack 사용 방법","description":"","date":"2024-06-23 23:37","slug":"2024-06-23-HowtousetheSwiftUIsNavigationStack","content":"\n![Navigation in SwiftUI](/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png)\n\nSwiftUI에서의 네비게이션은 복잡하고 동적인 사용자 인터페이스를 생성하는 강력한 도구입니다. 직관적인 구문과 강력한 기능 세트를 갖춘 SwiftUI의 네비게이션 기능을 사용하면 원활하고 매력적인 앱 경험을 구축하기 쉽습니다. 간단한 프로토 타입을 만들거나 완전한 애플리케이션을 구축하더라도 SwiftUI의 네비게이션 도구를 사용하면 완벽한 사용자 경험을 만들 수 있습니다.\n\n네비게이션은 NavigationView를 사용하여 수행되었으나, iOS 16에서 사용 중단되었으며 새로운 두 개의 컨테이너인 NavigationStack와 NavigationSplitView로 분할되었으며, 각각의 컨테이너에는 새로운 기능이 추가되었습니다.\n\nNavigationStack은 다음 네비게이션에 뷰를 설정하기 위해 사용되며, 새로운 뷰를 이전 뷰 위에 쌓아 올리고 항상 상위에 뷰를 하나 유지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNavigationSplitView은 컬럼 기반 네비게이션을 만들어야 할 때 사용됩니다. 화면이 컬럼으로 나누어지며, 각 컬럼은 NavigationSplitView의 하위 뷰 중 하나입니다.\n\n이 기사에서는 NavigationStack의 기본에 중점을 둘 것입니다.\n\n## NavigationView를 NavigationStack으로 이관하기\n\n이전에 언급한 대로, NavigationView는 두 개로 분리되었으므로 모든 구현이 이관될 수 있는 것은 아닙니다. NavigationView가 스택 네비게이션 스타일을 사용할 때에만 직접적인 이관이 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드에서 볼 수 있듯이 .stack 함수를 사용하여 NavigationView를 사용했습니다.\n\n```js\n// IOS 16 이전 (사용 중단).\nstruct ContentView: View {\n var body: some View {\n\n  NavigationView {\n   VStack {\n    NavigationLink(\"스크린 1입니다\") {\n     Text(\"스크린 1로 이동\")\n    }\n    Spacer().frame(height: 10)\n    NavigationLink(\"스크린 2입니다\") {\n     Text(\"스크린 2로 이동\")\n    }\n   }\n  }\n  .navigationViewStyle(.stack)\n }\n}\n```\n\n그래서 이 마이그레이션을 수행하려면 내비게이션 스타일 함수를 제거하고 NavigationView를 NavigationStack으로 변경하면 됩니다.\n\n```js\n// IOS 16.\nstruct ContentView: View {\n var body: some View {\n\n  NavigationStack {\n   VStack {\n    NavigationLink(\"스크린 1입니다\") {\n     Text(\"스크린 1로 이동\")\n    }\n    Spacer().frame(height: 10)\n    NavigationLink(\"스크린 2입니다\") {\n     Text(\"스크린 2로 이동\")\n    }\n   }\n  }\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# NavigationStack 새로운 기능\n\n## 값 타입을 위한 NavigationDestination\n\n새로운 네비게이션 시스템으로 코드가 더 깔끔해졌습니다. 이제는 NavigationLink 생성과 관계없이 목적지를 정의할 수 있습니다.\n\n목적지를 정의하려면 NavigationLink의 상위 뷰에 navigationDestination() 함수를 추가해야 합니다. 이 함수에는 다음과 같은 매개변수가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파라미터:\n\n- Data: 이 대상과 일치하는 데이터의 유형입니다.\n- Destination: 스택의 탐색 상태에 `data` 유형의 값이 포함된 경우 표시할 뷰를 정의하는 뷰 빌더입니다. 이 클로저는 하나의 인수를 사용하며, 그것은 표시할 데이터의 값입니다.\n\n이전에 보았듯이, 파라미터 중 하나는 대상 데이터입니다. 이 정보를 navigationDestination()에 보내기 위해 NavigationLink에 값을 추가해야 합니다. 이 매개변수는 Hashable 프로토콜을 구현한 값만 수용합니다.\n\n아래 예제에서는 각 링크마다 스크린 번호가 포함된 문자열이 NavigationLink의 값 매개변수로 전송됩니다. 그런 다음 링크 컨테이너는 navigationDestination을 구현했습니다. 이것은 문자열 유형의 어떤 값이라도 전달될 때 호출될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct ContentView: View {\n\n var body: some View {\n  NavigationStack {\n   VStack {\n    NavigationLink(\"화면 1으로 이동\", value: \"1\")\n    Spacer().frame(height: 10)\n    NavigationLink(\"화면 2로 이동\", value: \"2\")\n   }.navigationDestination(for: String.self) { value in\n    Text(\"이것은 화면 번호 \\(value)입니다\")\n   }\n  }\n }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:784/1*GwLWWM6KAWYGQmaztzbqTw.gif\" /\u003e\n\n## 불리언 상태 변수에 대한 NavigationDestination\n\n또 다른 navigation 대상을 구현하는 방법은 불리언 상태 변수를 관찰하는 것입니다. 따라서 observable state가 변경될 때마다 대상이 트리거됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예제에서는 showDetails 변수를 true로 변경하는 버튼이 있습니다. 이 변수는 navigationDestination에 의해 관찰되며, destination에는 변수를 false로 변경하는 버튼이 포함되어 있습니다. 변수가 true이면 대상 뷰가 나타나고, false이면 사라집니다.\n\n```swift\nstruct ContentView: View {\n @State private var showDetails = false\n\n var body: some View {\n  NavigationStack {\n   VStack {\n    Button(\"세부 정보 업데이트\") {\n     showDetails = true\n    }\n   }\n   .navigationDestination(isPresented: $showDetails) {\n    VStack {\n     Text(\"세부 정보가 업데이트되었습니다\")\n     Button(\"닫기\") {\n      showDetails = false\n     }\n    }\n   }\n  }\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:784/1*mN4EwmCDiECEE6Iw_rKxBg.gif)\n\n## NavigationStack 경로 매개변수\n\n이 새로운 매개변수는 iOS 16에 도입된 최고의 새로운 기능 중 하나로, 딥링크 및 다른 특정 네비게이션 경우의 쉬운 구현을 가능하게 합니다.\n\n기본적으로 이 매개변수는 우리에게 새로운 대상으로의 미리 정의된 경로를 정의하고, 경로에 쌓인 모든 화면을 추적할 수 있도록 해줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예시에서는 패스 변수를 가지고 있으며, 해당 변수는 네비게이션 스택의 경로 매개변수로 설정되어 있습니다. 이 목록의 각 항목은 프로그램 시작 시에 열리는 화면과 대응합니다.\n\n```js\nstruct ContentView: View {\n\n @State var path: [String] = [\"1\", \"2\", \"3\"]\n\n var body: some View {\n  NavigationStack(path: $path) {\n   VStack {\n    NavigationLink(\"Go to screen 4\", value: \"4\")\n   }.navigationDestination(for: String.self) { value in\n    Text(\"This is screen number \\(value)\")\n   }\n  }\n }\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:784/1*UKAZP7Xn4iBP12FsyphWng.gif)\n\n## NavigationPath\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 주제에서 NavigationStack의 변수 경로로 사용하기 위해 String 목록이 생성되었습니다. 그런데 새로운 화면이 다른 유형을 매개변수로받아야하는 경우에는 어떻게 해야하며 여전히 모든 탐색을 추적하고 싶다면 어떻게 해야합니까?\n\nApple은이 문제를 해결하기 위해 데이터의 타입을 지워버리는 NavigationPath라는 목록을 만들었습니다.\n\nNavigationPath를 사용하는 방법을 더 잘 이해하기 위해 인물 모델을 만들겠습니다. NavigationLink의 값 매개변수와 마찬가지로 경로 목록에 추가될 모든 유형은 Hashable 프로토콜을 구현해야 합니다.\n\n```js\nstruct PersonModel: Hashable {\n  let name: String\n  let age: Int\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음, 우리는 두 가지 시작 경로와 함께 문자열 유형을 가진 NavigationPath를 만듭니다.\n\n그 후에, 새 경로가 NavigationStack의 경로 매개변수로 설정되고, NavigationPath의 유형 유연성을 테스트하기 위해 두 가지 새로운 NavigationsLinks를 만들 것입니다.\n\n첫 번째 링크는 정수를 값 매개변수로 사용하고, 두 번째 링크는 생성된 person 모델을 값으로 사용합니다. 서로 다른 유형의 값을 추가한 후, 이들에 대한 특정 대상을 정의해야 합니다.\n\n```js\nstruct ContentView: View {\n\n @State var path = NavigationPath([\"1\", \"2\"])\n\n var body: some View {\n  NavigationStack(path: $path) {\n   VStack {\n    NavigationLink(\"정수 화면으로 이동\", value: 1)\n    Spacer().frame(height: 10)\n    NavigationLink(\"사람 화면으로 이동\", value: PersonModel(name: \"Mark\", age: 32))\n\n   }.navigationDestination(for: String.self) { value in\n    Text(\"이것은 값이 있는 문자열 화면입니다: \\(value)\")\n   }.navigationDestination(for: Int.self) { value in\n    Text(\"이것은 값이 있는 정수 화면입니다: \\(value)\")\n   }.navigationDestination(for: PersonModel.self) { value in\n    Text(\"이것은 값이 있는 사람 화면입니다.\\n이름: \\(value.name), 나이: \\(value.age)\")\n   }\n  }\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:788/1*13DNutvSEBznr-r2hmWSlQ.gif\" /\u003e\n\n# 결론\n\n여기까지 새로운 iOS 16 내비게이션 방식의 강력함을 확인했고, 이제 SwiftUI가 제공하는 네이티브 도구를 사용하여 앱의 자체 내비게이션 시스템을 쉽게 구축할 수 있게 되었습니다.\n\niOS 개발 관련 질문이 있거나 대화를 나누고 싶으시다면 언제든지 LinkedIn으로 메시지를 남겨주세요! 🙂\n","ogImage":{"url":"/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png"},"coverImage":"/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png","tag":["Tech"],"readingTime":9},{"title":"Unowned self 개념의 문제점","description":"","date":"2024-06-23 23:36","slug":"2024-06-23-TheCaseAgainstunownedself","content":"\n![2024-06-23-TheCaseAgainstunownedself_0.png](/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png)\n\n클래스, 클로저 또는 액터를 사용할 때마다 Swift는 힙(heap)에 정보를 저장합니다. 전달하는 변수는 실제로 메모리의 주소(즉, 참조)를 가리키는 포인터입니다.\n\n옛날에는 Mac과 iOS 개발자들이 이 메모리를 수동으로 관리해야 했습니다. heap에 메모리 블록을 만들기 위해 alloc()을 사용하고 다른 참조를 추가하기 위해 retain()을 사용하며 메모리를 해제하기 위해 release()를 사용합니다.\n\n2011년, Apple은 ARC(자동 참조 카운트)를 소개했으며, 이를 통해 컴파일러가 이러한 보일러플레이트 메모리 관리 코드를 자동으로 작성하도록 하여, 축적된 개발 시간을 절약했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nARC는 다양한 종류의 참조 개념을 소개했습니다.\n\n## 강한 참조\n\n이것은 기본 참조입니다. 포인터가 사용 중일 때 가리키는 메모리를 유지합니다.\n\n강한 참조를 만드는 동안 힙 객체의 참조 카운트(또는 refCount)가 증가하고, refCount가 0이 되면 객체가 할당 해제되어 힙에 있는 메모리가 해제됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 약한 참조\n\n약한 참조는 힙 객체들이 서로를 가리키면서 유지주기 문제 없이 회피할 수 있게 해줍니다. 이를 통해 개발자들은 클로저와 델리게이트에서 클래스에 대한 참조를 생성하지만 불필요하게 객체들을 유지할 필요가 없어집니다.\n\n약한 참조는 refCount가 증가하지 않으면서 메모리의 힙 객체를 가리킵니다. 만약 refCount가 제로가 되면 객체는 해제되고 약한 참조는 nil이 됩니다— 이는 클로저에서 메모리 누수를 방지합니다.\n\n이 작동방식을 다루기 위해 약한 참조는 항상 optional로 래핑되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n// StoreViewModel.swift\n\nfunc loadStorefront() {\n    api.fetchInventory() { [weak self] inventory in\n        self?.inventory = inventory\n    }\n}\n```\n\n이 예에서 인벤토리는 네트워크를 통해 가져오며, 데이터가 도착하면 클로저 콜백이 실행됩니다. self는 약한 참조로 캡처되어 StoreViewModel의 속성이 클로저에서 업데이트될 수 있음을 의미합니다. 사용자가 화면을 나가면 뷰 모델의 강한 참조 수가 0이 되면 런타임이 뷰 모델을 해제할 수 있으므로, 콜백을 기다리는 동안 메모리에 유지되지 않고 인벤토리가 반환될 때 아무 일도 일어나지 않습니다.\n\n## Unowned references\n\n리테인 사이클을 방지하기 위해 Swift에서 세 번째 종류의 참조인 unowned가 소개되었습니다. 이는 약한 참조와 유사하게 동작하지만 참조 대상 객체의 메모리가 항상 해당 객체를 참조하는 unowned 포인터보다 오래 존속할 것으로 가정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n// StoreSingleton.swift\n\nstatic let sharedInstance = StoreSingleton()\n\nprivate init() {}\n\nfunc configureStorefront() {\n    api.fetchInventory() { [unowned self] inventory in\n        self.inventory = inventory\n    }\n}\n```\n\n여기에서 우리는 \"진정한 싱글톤\" (private init으로)을 가지고 있기 때문에 객체의 수명이 클로저보다 더 오래 지속된다는 것을 확신할 수 있습니다. 클로저 캡처 목록의 [unowned self]는 리테인 사이클이 생성되는 것을 방지합니다 (그러나 싱글톤의 경우 리테인 사이클에 대해 걱정할 필요가 실제로 없습니다).\n\n클로저는 약간 더 간단하며, unowned는 약한 참조와 비교하여 몇 가지 성능 이점을 제공합니다:\n\n- 옵셔널 체이닝이나 언래핑 작업을 사용할 필요가 없습니다.\n- unowned 참조는 힙 객체에 사이드 테이블을 만들지 않기 때문에 더 적은 메타데이터를 저장합니다.\n- 약한 참조가 가리키는 메모리에 액세스하는 경우 포인터 간의 추가 점프 또는 간접 레이어가 하나 더 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 성능이 좋다고 해도 이에는 한 가지 제약 사항이 있습니다: 만약 수명을 잘못 지정하고 클로저나 프로퍼티가 weak 참조보다 더 오래 존속된다면, 앱이 크래시할 수 있습니다.\n\n## unowned는 가치가 있을까요?\n\n당연히, 크래시는 상당히 나쁩니다. 그리고 Knuth가 종종 오인용된 것처럼 이른 최적화는 우리가 분명히 조심해야 할 유혹입니다. 그래서 성능을 약간 더 얻기 위해 unowned 참조를 마구 사용해서는 안 됩니다.\n\n제 블로그를 읽고 있다면, 아마 Swift에 대해 알고 있는 분일 것입니다. 하지만 당신의 팀원들이 모두 그렇다고 확신할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n금요일 오후 5시에 수행하는 모든 코드 리뷰가 'unowned' 키워드를 발견할 때마다 개체 소멸로 이어지는 많은 가지 코드 경로를 이해하는 데 신중하다는 것을 확신하실 수 있나요?\n\n궁극적으로, 'unowned'는 프로그래밍 문제가 아니라 인간 문제입니다.\n\n# 약한 참조의 성능 비용\n\n우리는 'unowned'의 위험을 이해합니다. 약한 참조와 비교했을 때 이점에 대해 이야기해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n성능에 관한 이야기예요.\n\n약한 참조를 옵셔널 언래핑하는 데 포함된 소수의 CPU 명령이 중요하다고 가정하지 않겠어요. 옵셔널은 사실 열거형이라는 비밀을 알고 계세요? 이 값 형식은 스택에 존재하죠. 이를 조작하는 오버헤드는 무시할 수준이에요. 왜냐하면 이들은 힙에 대한 쓰레드 안전한 잠긴 접근이 필요하지 않거든요.\n\n메모리에 대해 이야기해볼까요? 힙 객체를 약한 참조하는 것은 처음에 사이드 테이블을 만듭니다. 이는 힙 객체의 메모리 레이아웃 외부에 저장된 가벼운 메타데이터입니다. 사이드 테이블에는 힙 객체로의 포인터, 약한 참조 카운트; 그리고 정수 오버플로된 강한 참조 및 unowned 참조의 refCounts가 포함돼 있어요. unowned 참조 자체에는 사이드 테이블이 필요하지 않아요.\n\n이게 작은 비트들의 소수라는 느낌이 드시나요? 그렇게 생각하시면 맞아요. 추가 메모리량이 극히 소량이죠. 사실상 런타임은 약한 참조를 미리 nil 처리하려고 deinit에 추가 작업이 필요하지 않아요. 약한 참조가 폐기될 때까지 가벼운 사이드 테이블이 메모리에 남아 있어 힙 객체의 라이프사이클 상태를 체크해 nil 또는 객체를 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에는 약간의 오버헤드가 있습니다. 약한 참조는 이 쪽 테이블을 가리키고, 다시 이를 통해 실제 힙 객체를 가리킵니다. 이 간접 참조 때문에 약한 참조에 약간의 오버헤드가 추가되고, 비싼 CPU 캐시 미스가 발생할 위험이 있습니다.\n\n한편, 언올드 참조는 메모리의 힙 객체를 직접 가리킵니다. 간접 참조가 줄어듦에 따라 덜한 오버헤드가 발생하지만, 런타임은 여전히 힙 객체의 라이프사이클 상태를 확인해야 합니다. 따라서 객체를 반환해야 하는지, 아니면 swift_abortRetainUnowned로 크래시를 발생시켜야 하는지 알 수 있습니다.\n\n# 언올드를 사용하는 것이 합당한 경우\n\nSwift 소스를 살펴보며 약한 참조와 언올드 참조의 구현을 이해하면, 언올드를 사용하는 이점이 적고, 치명적인 오류를 발생시킬 위험 때문에 이 성능 이점이 가치가 없는 경우가 많다는 것이 분명해집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나, 컴퓨터 과학에서 모든 것은 트레이드오프에 관한 것이며, 이런 경우에는 트레이드오프가 합리적인 경우가 있습니다.\n\n- 참조(reference)가 많고 실행 시간 성능이 중요한 병목 현상이 되는 경우, 예를 들어 많은 화면 객체를 포함하는 게임 엔진을 개발하는 개발자가 있는 경우.\n- 참조(reference)의 수가 많고 메모리가 극도로 제한적해서 수 바이트를 저장하는 것이 관련이 있는 경우 — 예를 들어 코드 일부를 최적화하여 L1 CPU 캐시에 맞출 수 있는 경우.\n- 다른 기여자에 의존하지 않는 인디 개발자가, 무엇을 하는 지 정확히 알고 있으며, 프로덕션에서의 충돌 비용을 감당할 준비가 되어 있는 경우.\n\n그러나 하나의 클로저 콜백에서 [unowned self]를 사용하는 것이 몇 개의 시계 주기와 최악의 경우 몇 나노초의 캐시 미스를 위해 꽤 좋지 않은 트레이드오프라는 점에 동의해 주셨으면 합니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nARC에서 잠재 쓰레기 참조 문제를 방지하는 데 기여하는 비소유 참조(unowned references)는 런타임 성능 향상의 조각을 제공하지만 잘못 사용하면 충돌 위험이 따릅니다.\n\n매우 병목 상태인 시스템에 수많은 참조가 있는 경우 등 일부 상황에서는 사용할 만한 가치가 있지만, 단일 클로저 캡처 목록에 [unowned self]를 사용하는 것은 그중 하나가 아닙니다.\n\n[weak self]를 계속 사용하고 unowned는 예외적인 경우로 취급해 주세요. 이는 잘못 사용하면 예외를 받아들일 수 있는 경우라는 의미입니다.\n\n간단히 말해, 코드에서 unowned를 사용할 만큼 자신감이 있다면, 그냥 unowned(unsafe)를 사용하세요. 약간 더 성능적으로 우세합니다\\*.\n","ogImage":{"url":"/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png"},"coverImage":"/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png","tag":["Tech"],"readingTime":8},{"title":"Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법","description":"","date":"2024-06-23 23:35","slug":"2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling","content":"\n안녕하세요, Swift 개발자 여러분! 오늘은 우리의 일상 코딩 생활에서 매우 중요한 주제에 대해 이야기를 나누고 싶어요: 에러 처리입니다. 최근 WWDC 2024에서 Apple이 Swift에서 \"타입드 에러\"라 불리는 새로운 에러 처리 방법을 소개했어요. 따라서, 우리가 언타입드와 타입드 에러가 무엇인지, 그들이 어떻게 작동하는지, 그리고 왜 사용하고 싶을지 알아보도록 하겠습니다.\n\n## 언타입드 에러: 고전적인 방식\n\n먼저, 전통적인 방식인 언타입드 에러에 대해 이야기해보겠어요. Swift에서 오랫동안 코딩을 해왔다면, 이 방법에 익숙할 것입니다. Swift에서는 일반적으로 Error 프로토콜을 사용하여 에러를 처리합니다. 이 방법을 이용하면 Error 프로토콜을 준수하는 어떤 에러든 throw할 수 있어 매우 유연합니다. 그러나 때로는 너무 유연하여 어떤 종류의 에러를 기대해야 하는지 항상 알기 어려울 수 있습니다.\n\n```js\nenum StringParseError: Error {\n    case invalidCharacter(Character, at: String.Index)\n}\n\nfunc parseNumber(from input: String) throws -\u003e Int {\n    for (index, character) in input.enumerated() {\n        guard let _ = character.wholeNumberValue else {\n            throw StringParseError.invalidCharacter(character, at: input.index(input.startIndex, offsetBy: index))\n        }\n    }\n    return Int(input) ?? 0\n}\n\ndo {\n    let number = try parseNumber(from: \"12a45\")\n} catch let error as StringParseError {\n    switch error {\n    case .invalidCharacter(let character, let index):\n        print(\"Invalid character '\\(character)' found at index \\(index).\")\n    }\n} catch {\n    print(\"An unexpected error occurred: \\(error).\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 이곳에서 무슨 일이 일어나고 있나요:\n\n- StringParseError: Error 프로토콜을 준수하는 enum입니다.\n- parseNumber(from:): 이 함수는 문자열의 각 문자를 확인합니다. 유효하지 않은 문자를 발견하면 StringParseError를 throw합니다.\n- do-catch 블록: 이는 parseNumber 함수를 호출하고 발생 가능한 오류를 catch합니다. StringParseError 및 다른 오류는 일반적으로 처리됩니다.\n\n## Typed Errors: 새로운 접근 방식\n\n자, 이제 이 새롭고 멋진 기능인 typed errors에 대해 이야기해보겠습니다. WWDC 2024에서 소개된 이 기능은 함수가 throw할 수 있는 오류의 정확한 유형을 지정할 수 있게 해줍니다. 이를 통해 오류 처리를 더 정확하고 유형 안전하게 만들어줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n열거자 ParseError: 오류 {\n    case nonNumericCharacter(Character, at: String.Index)\n}\n\nfunc parseInt(from input: String) throws(ParseError) -\u003e Int {\n    for (index, character) in input.enumerated() {\n        if character.isNumber == false {\n            throw ParseError.nonNumericCharacter(character, at: input.index(input.startIndex, offsetBy: index))\n        }\n    }\n    return Int(input) ?? 0\n}\n\ndo {\n    let value = try parseInt(from: \"123x56\")\n} catch {\n    print(\"ParseError 발생: \\(error)\")\n}\n```\n\n# 여기에서 무슨 일이 벌어지고 있나요:\n\n- parseInt(from:): 이 함수는 이제 throws(ParseError)를 사용하여 ParseError만 throw할 수 있음을 나타냅니다.\n- do-catch 블록: 정확히 어떤 유형의 오류가 발생할 수 있는지 알기 때문에 catch 블록에서 오류 유형을 지정할 필요가 없습니다.\n\n# Any 및 Never 오류 유형\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n타입 애너효메이션을 사용하면 Error 및 Never를 지원하여 더 많은 유연성을 제공합니다.\n\n```js\nfunc parseValue(from input: String) throws(any Error) -\u003e Int {\n    if input.isEmpty {\n        throw NSError(domain: \"ParseDomain\", code: 100, userInfo: [NSLocalizedDescriptionKey: \"Input string is empty.\"])\n    }\n    return Int(input) ?? 0\n}\n\nfunc parseValue(from input: String) -\u003e Int {\n    return Int(input) ?? 0\n}\n\nfunc parseValue(from input: String) throws(Never) -\u003e Int {\n    return Int(input) ?? 0\n}\n```\n\n# 이곳에서 하는 일:\n\n- throws(any Error): 함수는 Error 프로토콜을 준수하는 모든 오류를 던질 수 있습니다.\n- throws(Never): 함수는 오류를 던지지 않으며 throws 키워드가 기술적으로 필요하지만 오류를 던지지 않는다는 것을 명시적으로 나타낼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리\n\n타입별 오류를 사용하면 오류 처리가 더 명확하고 이해하기 쉬워집니다. 함수가 던질 수 있는 오류 유형을 지정함으로써 코드를 더 안전하고 유지보수하기 쉽게 만들 수 있습니다. WWDC 2024에서 소개된 이 새로운 방식은 믿을 수 있고 유지보수 가능한 응용 프로그램을 작성하는 데 도움이 됩니다.\n\n다음에 Swift 프로젝트에서 오류 처리를 작업할 때는 타입별 오류를 한 번 시도해 보세요. 이를 통해 버그를 초기에 잡을 수 있고 코드를 더 예측 가능하며 디버깅하기 쉬워질 수 있습니다.\n\n즐거운 코딩 되세요! 여러분의 Swift 프로젝트가 오류 없이 잘 진행되길 바랍니다! 이 주제를 더 깊게 파고들고 싶다면, 공식 Swift 문서를 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling_0.png","tag":["Tech"],"readingTime":5}],"page":"1","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"1"},"buildId":"-dPCbnM2yhdKNgXe92VJV","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>