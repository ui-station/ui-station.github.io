<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/70" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/70" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="고 오류 정복하기 오류 반환과 처리에 관한 안내" href="/post/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="고 오류 정복하기 오류 반환과 처리에 관한 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="고 오류 정복하기 오류 반환과 처리에 관한 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">고 오류 정복하기 오류 반환과 처리에 관한 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 제품을 위한 데이터 조작" href="/post/2024-05-20-DataOrchestrationforDataProducts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 제품을 위한 데이터 조작" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 제품을 위한 데이터 조작" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">데이터 제품을 위한 데이터 조작</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="최대 요청 지터 - 비동기 Gunicorn 워커의 중추" href="/post/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="최대 요청 지터 - 비동기 Gunicorn 워커의 중추" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="최대 요청 지터 - 비동기 Gunicorn 워커의 중추" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">최대 요청 지터 - 비동기 Gunicorn 워커의 중추</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리액트 네이티브에서의 애니메이션으로 구현한 타이핑 효과의 매력" href="/post/2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리액트 네이티브에서의 애니메이션으로 구현한 타이핑 효과의 매력" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리액트 네이티브에서의 애니메이션으로 구현한 타이핑 효과의 매력" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">리액트 네이티브에서의 애니메이션으로 구현한 타이핑 효과의 매력</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AppDelegate, SceneDelegate, 그리고 SwiftUI 라이프사이클 이해하기" href="/post/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AppDelegate, SceneDelegate, 그리고 SwiftUI 라이프사이클 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AppDelegate, SceneDelegate, 그리고 SwiftUI 라이프사이클 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AppDelegate, SceneDelegate, 그리고 SwiftUI 라이프사이클 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모바일 개발 아이디어부터 구현까지 DevInterface와 함께" href="/post/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모바일 개발 아이디어부터 구현까지 DevInterface와 함께" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모바일 개발 아이디어부터 구현까지 DevInterface와 함께" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">모바일 개발 아이디어부터 구현까지 DevInterface와 함께</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안녕하세요 VSCode에서 플러터 앱을 실행하고 디버그하기 위해 안드로이드 기기를 WiFi로 연결하는 방법에 대해 이야기하겠습니다" href="/post/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안녕하세요 VSCode에서 플러터 앱을 실행하고 디버그하기 위해 안드로이드 기기를 WiFi로 연결하는 방법에 대해 이야기하겠습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안녕하세요 VSCode에서 플러터 앱을 실행하고 디버그하기 위해 안드로이드 기기를 WiFi로 연결하는 방법에 대해 이야기하겠습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안녕하세요 VSCode에서 플러터 앱을 실행하고 디버그하기 위해 안드로이드 기기를 WiFi로 연결하는 방법에 대해 이야기하겠습니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터 앱 성능 향상을 위한 권장 사항 탐색" href="/post/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터 앱 성능 향상을 위한 권장 사항 탐색" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터 앱 성능 향상을 위한 권장 사항 탐색" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">플러터 앱 성능 향상을 위한 권장 사항 탐색</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI 모양으로 하는 심장 애니메이션" href="/post/2024-05-20-SwiftUIHeartanimationwithshape"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI 모양으로 하는 심장 애니메이션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI 모양으로 하는 심장 애니메이션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI 모양으로 하는 심장 애니메이션</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS 푸시 알림 통합하기Using Swift" href="/post/2024-05-20-IntegratingiOSPushNotificationsUsingSwift"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 푸시 알림 통합하기Using Swift" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-IntegratingiOSPushNotificationsUsingSwift_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 푸시 알림 통합하기Using Swift" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 푸시 알림 통합하기Using Swift</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link posts_-active__YVJEi" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"고 오류 정복하기 오류 반환과 처리에 관한 안내","description":"","date":"2024-05-20 16:27","slug":"2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors","content":"\n\n## Go 오류 처리 마스터하기 위한 초보자 가이드\n\n![이미지](/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png)\n\n# 레벨 1: if err != nil\n\n이것은 오류를 반환하는 가장 간단한 방법입니다. 대부분의 사람들은 이 패턴에 익숙합니다. 오류를 반환할 수 있는 함수를 호출하고, 오류가 nil인지 확인하고, nil이 아니면 오류를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```Go\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc doSomething() (float64, error) {\n result, err := mayReturnError();\n if err != nil {\n  return 0, err\n }\n return result, nil\n}\n```\n\n## 이 방식의 문제점\n\n이 방식이 가장 간단하고 사실상 가장 많이 사용되는 방법이지만 중대한 문제점이 있습니다: 컨텍스트 부족. 깊은 호출 스택이 있는 경우 어떤 함수가 오류를 발생시켰는지 알 수 없습니다.\n\nA() 함수가 B()를 호출하고, B()가 C()를 호출하고, C()가 다음과 같은 오류를 반환하는 호출 스택을 상상해보십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npackage main\n\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc A(x int) (int, error) {\n result, err := B(x)\n if err != nil {\n  return 0, err\n }\n return result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n result, err := C(x)\n if err != nil {\n  return 0, err\n }\n return result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n if x \u003c 0 {\n  return 0, errors.New(\"negative value not allowed\")\n }\n return x * x, nil\n}\n\nfunc main() {\n // Call function A with invalid input\n result, err := A(-2)\n if err == nil {\n  fmt.Println(\"결과:\", result)\n } else {\n  fmt.Println(\"에러:\", err)\n }\n}\n```\n\n만약 이 프로그램을 실행하면 다음과 같이 출력됩니다.\n\n```js\n에러: negative value not allowed\n```\n\n우리는 호출 스택에서 이 오류가 어디에서 발생했는지에 대한 컨텍스트가 없습니다. 특정 오류 문자열을 찾아 해당 오류가 어디에서 발생했는지를 알아내기 위해 프로그램을 코드 편집기에서 열어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 레벨 2: 에러 감싸기\n\n에러에 대한 컨텍스트를 추가하기 위해 fmt.Errorf를 사용하여 에러를 감싸줍니다.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc A(x int) (int, error) {\n\tresult, err := B(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"A: %w\", err)\n\t}\n\treturn result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n\tresult, err := C(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"B: %w\", err)\n\t}\n\treturn result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n\tif x \u003c 0 {\n\t\treturn 0, fmt.Errorf(\"C: %w\", errors.New(\"음수 값은 허용되지 않습니다\"))\n\t}\n\treturn x * x, nil\n}\n\nfunc main() {\n\t// 잘못된 입력으로 함수 A를 호출합니다.\n\tresult, err := A(-2)\n\tif err == nil {\n\t\tfmt.Println(\"결과:\", result)\n\t} else {\n\t\tfmt.Println(\"에러:\", err)\n\t}\n}\n```\n\n이 프로그램을 실행하면 아래와 같은 출력을 얻게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n오류: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n이제 우리는 콜 스택을 이해했습니다.\n\n하지만 여전히 문제가 있습니다.\n\n## 이 방법의 문제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에러가 발생한 위치를 알게 되었지만 여전히 어떤 부분이 잘못되었는지는 알 수 없습니다.\n\n# Level 3: 세부적인 에러\n\n에러가 충분히 설명이 되지 않았습니다. 이것을 보다 복잡한 예제로 보여주기 위해 다음과 같이 조금 더 복잡한 예제가 필요합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps:%w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서 오류가 반환되면 어떤 작업이 실패했는지 명확하지 않습니다. StepOne인지 StepTwo인지 알 수 없습니다. 동일한 오류인 Error: DoSomething: DoSomethingElseWithTwoSteps: UnderlyingError가 발생합니다.\n\n그 문제를 해결하려면 발생한 구체적인 문제에 대한 문맥을 추가해야 합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepOne: %w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepTwo: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n이제 StepOne이 실패하면 Error: DoSomething: DoSomethingElseWithTwoSteps: StepOne failed: UnderlyingError를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이 방법의 문제점\n\n이 오류는 이제 함수 이름을 사용하여 호출 스택을 표현합니다. 그러나 오류의 본질을 표현하지는 않습니다. 오류는 이야기를 전달해야 합니다.\n\n좋은 예는 HTTP 상태 코드입니다. 404를 받으면 원하는 리소스가 존재하지 않음을 알 수 있습니다.\n\n# 레벨 4: 오류 표식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에러 센티널은 재사용할 수 있는 미리 정의된 오류 상수입니다.\n\n함수가 실패할 수 있는 원인은 다양할 수 있지만, 일반적으로 4가지 카테고리로 나눌 수 있습니다. \"찾을 수 없음\" 오류, \"이미 존재함\" 오류, \"실패한 전제조건\" 오류, 그리고 \"내부 오류\"입니다. 이는 gRPC 상태 코드에서 영감을 받았습니다. 각 카테고리를 한 문장으로 설명해 드릴게요. \n\n\"찾을 수 없음\" 오류: 호출자가 원하는 리소스가 존재하지 않습니다. 예시: 삭제된 게시물.\n\n\"이미 존재함\" 오류: 호출자가 생성하려는 리소스가 이미 존재합니다. 예시: 같은 이름을 가진 조직.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실패한 전제조건 오류: 작업 요청자가 실행하려는 작업이 실행 조건을 충족하지 않거나 나쁜 상태에 있습니다. 예시: 잔액이 0원인 계좌에서 출금을 시도하는 경우.\n\n내부 오류: 이러한 카테고리에 속하지 않는 다른 오류로 내부 오류가 발생한 경우입니다.\n\n이러한 종류의 오류만 가지고 있어도 충분하지 않습니다. 호출자에게 어떤 종류의 오류인지 알려주어야 합니다. 이를 위해 오류 센티널 및 errors.Is를 사용합니다.\n\n사용자가 지갑 잔액을 조회하고 업데이트할 수 있는 REST API가 있다고 상상해보세요. 데이터베이스에서 지갑을 조회할 때 오류 센티널을 활용하는 방법을 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\n// 이것들은 에러를 표현하는 상수들입니다.\nvar (\n  WalletDoesNotExistErr = errors.New(\"지갑이 존재하지 않습니다\") // 발견되지 않은 에러 타입\n  CouldNotGetWalletErr = errors.New(\"지갑을 가져올 수 없습니다\") // 내부 에러 타입\n)\n\nfunc getWalletFromDB(id int) (int, error) {\n // 더미 구현: 데이터베이스에서 지갑을 검색하는 시뮬레이션\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return 0, fmt.Errorf(\"%w: Wallet(id:%s)가 존재하지 않습니다: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return 0, fmt.Errorf(\"%w: 데이터베이스에서 Wallet(id:%s)를 가져올 수 없습니다: %w\", CouldNotGetWalletErr, id, err)\n  }\n }\n\n return *balance, nil\n}\n```\n\n이제 이제 REST 핸들러에서 다음과 같이 할 수 있는 것을 보여줍니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```\n\n다른 예제를 살펴보겠습니다. 사용자가 잔액을 업데이트하고자 하는 경우를 보겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\nvar (\n  WalletDoesNotExistErr = errors.New(\"Wallet does not exist\") // Not Found Error Type\n  CouldNotDebitWalletErr = errors.New(\"Could not debit Wallet\") // Internal Error Type\n  InsufficientWalletBalanceErr = errors.New(\"Insufficient balance in Wallet\") // Failed Precondition Error Type\n)\n\nfunc debitWalletInDB(id int, amount int) error {\n // Dummy implementation: simulate retrieving a wallet from a database\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return fmt.Errorf(\"%w: Wallet(id:%s) does not exist: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return fmt.Errorf(\"%w: could not get Wallet(id:%s) from db: %w\", CouldNotDebitWalletErr, id, err)\n  }\n }\n\n if *balance \u003c= 0 {\n   return 0, fmt.Errorf(\"%w: Wallet(id:%s) balance is 0\", InsufficientWalletBalanceErr, id)\n }\n\n updatedBalance := *balance - amount\n \n // Dummy implementation: simulate updating a wallet in a database\n err := db.update(id, updatedBalance)\n\n if err != nil {\n   return fmt.Errorf(\"%w: could not update Wallet(id:%s) in db: %w\", CouldNotDebitWalletErr, id, err)\n }\n\n return nil\n}\n```\n\n## Using sentinels for better error messages\n\nYou might have noticed that I have a particular way of formatting errors. I prefer structuring an error message in one of two ways:\n\n- `fmt.Errorf(\"%w: description: %w\", Sentinel, err)` or\n- `fmt.Errorf(\"%w: description\", Sentinel)`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 오류가 발생한 이유와 근본적인 원인을 알려주는 이야기를 만듭니다.\n\n이것은 중요합니다. 왜냐하면 위 예제에서 보는 바와 같이 동일한 유형의 오류가 두 가지 다른 근본적인 이슈로 인해 발생할 수 있기 때문입니다. 따라서 설명이 우리가 정확히 무엇이 잘못되었는지와 그 이유를 정확히 찾게 도와줍니다.\n\n# 보너스: 에러를 기록하는 곳\n\n당신이 발견한 모든 오류를 기록해서는 안 된다는 것에 놀랄지도 모릅니다. 왜냐하면 로그가 아래와 같이 보이기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n에러: C: 음수 값은 허용되지 않습니다\n에러: B: C: 음수 값은 허용되지 않습니다\n에러: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n에러를 기록하는 곳은 반드시 \"처리\"할 수 있는 경우에만 해야 합니다. 여기서 처리란 호출자가 에러를 받아서 무언가 처리하고 계속 실행할 수 있도록 하는 것을 의미합니다.\n\n전형적인 예시는 다시 말해 REST 핸들러일 것입니다. REST 핸들러가 에러를 받으면 해당 에러의 타입을 살펴보고, 적절한 상태 코드로 응답을 보내고 에러 전파를 중단할 수 있습니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if err != nil {\n  fmt.Printf(\"%w\", err) // 여기에서는 오직 에러를 로깅합니다\n }\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```","ogImage":{"url":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png"},"coverImage":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png","tag":["Tech"],"readingTime":9},{"title":"데이터 제품을 위한 데이터 조작","description":"","date":"2024-05-20 16:25","slug":"2024-05-20-DataOrchestrationforDataProducts","content":"\n\n이 문서는 Modern Data Stack 101에 처음 등장했습니다. 만일 Medium 회원이 아니라면, 무료로 여기에서 읽을 수 있어요 💸\n\n# 제 소개\n\n저는 후고 루입니다. 런던에서 M\u0026A로 일한 후 JUUL에 합류하여 데이터 엔지니어링에 빠져들게 되었습니다. 런던을 기반으로 하는 스케일업 기업 Codat의 데이터 기능을 이끌었습니다. 지금은 Orchestra의 CEO입니다. Orchestra는 데이터 팀이 신뢰성 있고 효율적으로 데이터를 프로덕션 환경으로 릴리즈할 수 있도록 도와주는 데이터 릴리즈 파이프라인 도구입니다. 🚀\n\n⭐️ 또한 우리의 Substack와 내부 블로그도 확인해 보세요 ⭐️\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 소개\n\n현재 데이터 팀들은 오르막길을 오르는 중입니다. 한편으로, 데이터 제품에 대한 수요는 이전보다 커졌습니다. AI가 데이터 기반의 기능, 제품 및 능력에 대한 수요를 높였고, CEO들의 욕망 또한 증가했습니다. 이러한 요구는 데이터 파이프라인 및 데이터 및 데이터 수집의 효율적 관리에 의해 가능케 되었습니다.\n\n다른 한편으로, 데이터 팀의 예산은 삭감되고 인력도 줄어들고 있습니다. 이로 인해 데이터를 조직하는 능력이 저하되었고, 결과적으로 조직이 활용할 수 없는 많은 다양한 데이터 소스(구조화된 및 비구조화된 데이터)가 계속되고 있습니다.\n\n성장과 성공을 위한 가장 큰 촉매제 중 하나는 수동 데이터 사용의 고통을 없애고 데이터 조종, 데이터 관측, 계보, 메타데이터 수집 및 경보를 통합하는 통합 제어 평면을 가지고 있는 것입니다. 이 글에서는 데이터 조종 프로세스가 데이터 및 AI 제품 속도를 가속화하는 데 어떤 역할을 하는지와 채택할 수 있는 방법을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 오픈 소스 워크플로 오케스트레이션 도구 대 전체 제어 플랜\n\nAirflow 및 Prefect와 같은 오픈 소스 워크플로 오케스트레이션 도구는 데이터 워크플로 관리 및 자동화에 강력한 기능을 제공하지만, 전체 제어 플랜과 비교할 때 접근 방식과 기능이 다릅니다.\n\nAirflow는 에어비앤비에서 개발한 오픈 소스 도구로, 워크플로 스케줄링, 모니터링 및 관리에 중점을 둡니다. Airflow는 방향성 비순환 그래프(DAG)를 사용하여 워크플로를 정의하고 다양한 외부 시스템과 통합을 지원합니다. Airflow의 장점은 유연성과 확장성에 있어, 사용자가 복잡한 워크플로를 생성하고 대량의 데이터를 처리할 수 있도록 합니다.\n\n반면 Prefect는 사용 편의성, 신뢰성 및 데이터 버전 관리를 강조하는 또 다른 오픈 소스 워크플로 오케스트레이션 도구입니다. Prefect는 워크플로를 정의하는 데 더 직관적인 인터페이스를 제공하며 자동 재시도 논리, 작업 의존성 및 워크플로를 모니터링하고 관리하는 중앙 대시보드와 같은 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오픈 소스 워크플로 오케스트레이션 도구인 Airflow와 Prefect를 All-in-One 제어 플레인인 Orchestra, Apache NiFi, DataOS 또는 AWS Step Functions과 같은 플랫폼 또는 프로프리터리 솔루션과 비교할 때, All-in-One 제어 플레인은 종종 더 간편한 사용자 경험을 제공하고 학습 커브가 낮다는 큰 차이점이 있습니다. 그들은 사용자들이 기술적 지식이 적은 사용자도 접근할 수 있게끔 그래픽 표현, 드래그 앤 드롭 기능, 일반적인 워크플로를 위한 미리 구축된 템플릿과 같은 선호하는 형태의 표준 인터페이스를 제공할 수 있습니다.\n\n그러나 제어 플레인의 진정한 힘은 데이터 생태계의 모든 엔티티와 상호 작용할 수 있는 능력에 있습니다. 이로 인해 불필요한 통합 오버헤드를 완전히 줄일 수 있습니다. 더 흥미로운 점은 중앙 제어 플레인이 글로벌 메타데이터 및 거버넌스 프로토콜에 접근할 수 있어 데이터 주변의 완전한 컨텍스트와 안전하게 작동할 수 있는 오케스트레이션을 제공할 수 있다는 것입니다.\n\n# OSS 오케스트레이션 시스템이 안티 패턴을 장려\n\n기존 OSS 워크플로는 데이터 아키텍처에 대한 통합적인 접근을 장려합니다. 이는 \"모던 데이터 스택\"의 모든 구성 요소를 처리할 수 있는 단일 저장소와 단일 애플리케이션이 있다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 사람들이 이 아키텍처를 간단히 갖고 있지 않습니다. 데이터 서비스를 구축하는 것은 어렵습니다. 데이터 파이프라인을 구축하는 것은 종종 파이프라인의 다른 부분에서 특화된 서비스가 필요합니다. 사실, 서로 다른 팀이 있는 것이 필요하게 만드는 경우가 많습니다.\n\n예를 들어, 데이터 엔지니어링 팀은 Kafka나 다른 이벤트 기반 스트리밍 응용 프로그램을 관리할 책임이 있을 수 있습니다. 분석 팀은 dbt 저장소를 관리할 수도 있습니다. 이들은 분리되어야 합니다.\n\n따라서 OSS Workflow Orchestration 도구로 현대 데이터 스택을 활용하는 것은 어느 정도 반대 패턴이며 추가적이고 비싼 감시 플랫폼이 필요합니다. \"Quis custodiet ipsos custodes?\" 또는 \"수호자를 지킬 자가 누구인가?\" 라는 문구가 떠오릅니다.\n\n![이미지](/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 제공: 작성자\n\n# 효율적인 마이크로서비스 아키텍처 활성화 방법\n\n데이터 제품 속도에 미치는 통합 데이터 조작의 영향\n\n데이터 조작 프로세스 자동화를 위한 통합 제어 평면을 갖는 것은 여러 가지 이점을 제공합니다.\n\n## 보일러플레이트 작업 제거\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기존 인프라를 사용하여 모든 중요한 계산을 처리하고 데이터 Orchestration 도구가 기존 프로세스를 조정하는 데 기여함으로써 엔지니어는 새로운 기술(Airflow 등)을 배우거나 인프라를 배포(Kubernetes 등)하거나 복잡한 UI에 대처할 필요가 없습니다.\n\n엔지니어와 데이터 팀은 데이터 수집, 데이터 정리, 분석 그리고 기계 학습에 집중하며 조정이 나머지 부분을 처리하도록 의지할 수 있습니다.\n\n## 비용과 메타데이터에 대해 걱정하지 마세요\n\n통합되지 않은 데이터 또는 Workflow Orchestration 도구를 사용하면 소중한 메타데이터가 원본 시스템 내에서 통합되지 않은 상태로 남아 있고 데이터 수명 주기 정책으로 인해 심지어 사라질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n통합 조작 및 감시는이 데이터가 실시간으로 효율적으로 수집되어 데이터 팀에서 사용할 수 있도록합니다. 이를 통해 이집트된 데이터 소스 간의 메타데이터 관리가 쉬워집니다.\n\n## 비즈니스 가치 계산\n\n통합 조작 플랫폼을 사용하면 데이터 엔지니어가 데이터 및 AI 제품의 비즈니스 가치를 정량화 할 수 있습니다. 예를 들어, 쿼리당 비용 데이터 및 AWS 컴퓨팅 비용을 가져오는 동시에 대시보드 및 머신러닝 모델 사용 통계를 볼 수 있습니다.\n\n이 비즈니스 중요한 운영 데이터를 데이터 제품 수준에서 가지면 데이터 팀은 좀 더 효율적으로 우선순위를 정할뿐만 아니라 기업에 그들의 가치와 가치를 보여줄 수있는 창문을 마침내 가질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n통합 데이터 조율 및 데이터 가시성 플랫폼은 모든 작업을 청소하는 것, 유용한 메타데이터를 수집하고 데이터 제품 수준에서 제공함으로써 제품 속도를 빠르게 가속화할 수 있습니다. 엔지니어들이 기술적인 도전을 극복하는 데 시간을 절약하고, 다수의 감각적 이점을 얻습니다.\n\n데이터 품질을 선제적으로 모니터링하고 데이터 문제를 예방하며 비즈니스 이해관계자에게 (따라서 신뢰를 얻으며) 데이터 및 AI 이니셔티브를 무제알고 효율적으로 우선순위를 설정하는 것은 모두 통합 데이터 조율 플랫폼 또는 데이터 제어 플레인으로 가능합니다. Orchestra와 같은 제어 플레인은 기업이 전례 없는 속도로 데이터를 활용할 수 있도록 길을 열고 있습니다.\n\n# 기존 데이터 조율 솔루션의 한계점\n\n기존 조율 솔루션은 여러 가지 중요한 영역에서 종종 한계점을 지니고 있습니다. 첫째, 그들은 종종 사용자들에게 파이썬 코드를 큰 monorepo에서 작성하도록 강요하여 코드베이스가 커질수록 규모화하고 관리하기 어렵게 만듭니다. 이는 복잡성과 유지보수 도전을 증가시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 많은 기존 도구들에서는 가시성과 종단간 메타데이터 추적이 부족합니다. 이로 인해 사용자들이 데이터 및 프로세스의 흐름을 이해하기 어려워지며, 디버깅과 모니터링에 문제가 발생할 수 있습니다.\n\n마지막으로, 데이터 및 AI 제품의 성능을 종합적으로 파악할 수 있는 사용자 친화적 인터페이스가 부족합니다. 이러한 UI의 부재로 사용자들은 워크플로우를 쉽게 모니터링하고 최적화하여 성능과 효율성을 향상시키기 어려워집니다.\n\n## Multi-Tenancy와 거버넌스 부재\n\n다양한 팀이 다양한 소프트웨어를 사용하는 환경에서는 전체 데이터 운영에 대한 다중 테넌트 뷰를 얻는 것이 불가능합니다. 이는 팀 간 디버깅 라인지 그래프를 어렵게 만들며, 협업에 있어서 도전을 초래하며, 데이터 파이프라인을 관리하기 어렵게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 보안 준수\n\n단일 저장소에서는 개인 및 클러스터 모두 필요 이상의 비밀 정보에 액세스할 수 있습니다. 이는 여러 사람이 실제로 액세스할 필요가 없는 코드 베이스의 일부에 액세스할 수 있어 장애 발생 가능성을 높이게 됩니다.\n\n## 경보 및 소유권\n\n다양한 팀이 사용하는 여러 저장소가 있는 경우, 경보 및 데이터 자산 소유는 도전적일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 원활한 지속적 통합\n\n자주 놓치는 요소 중 하나인 데이터 파이프라인 저장소의 지속적 통합은 서비스 기반의 데이터 수집 스크립트와 같은 서비스 기반의 마이크로서비스에 대해 비교적 직관적입니다.\n\n그러나 dbt를 활용한 분석 저장소의 경우, dbt Slim CI와 같은 것이 필요하거나 프로젝트 Nessie의 데이터를 위한 Git-Control이 필요합니다. 이러한 환경에서 최소한의 CI가 실행되도록 보장하는 것만으로도 챌린지입니다. 그리고 데이터 수집, 스트리밍, 변환, 운영 분석에 대한 코드가 동일한 위치에 있는 경우, 더 복잡해집니다.\n\n# 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n본질적으로, 기본 사항인 제품 접근 방식으로 내려가는 것이 중요합니다. 제품 중심이 되는 것은 무엇을 의미할까요? 사용자 경험과 개선에 대한 완전한 초점. XYZ 작업 수행을 위한 노력을 줄이는 것입니다.\n\n데이터 제품을 구축할 때, 우리는 고객을 '사용자'로만 다루지 않고, 데이터 엔지니어와 분석 엔지니어도 데이터 제품 접근 방식의 '사용자'로 취급합니다. 그들의 삶은 기관이 데이터를 구축하는 방식으로 지속적으로 영향을 받는데, 그것은 최종 사용자에도 항상 영향을 줍니다.\n\n제품 접근 방식은 거대한 전략이 아닙니다. 사실, 데이터 워크플로우의 작은 구석마다 그리고 마지막 순간마다 살아있는 원자적 전략입니다. 오케스트레이션은 이 이야기에서 제외되지 않으며 사실, 이를 상당부분 이끌어 내는 요소입니다. 데이터 제품의 맥락에서 오케스트레이션도 사용자 중심 접근 방식을 채택하여 데이터 및 분석 엔지니어가 약간 더 용이하게 호흡할 수 있도록 합니다.","ogImage":{"url":"/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png"},"coverImage":"/assets/img/2024-05-20-DataOrchestrationforDataProducts_0.png","tag":["Tech"],"readingTime":6},{"title":"최대 요청 지터 - 비동기 Gunicorn 워커의 중추","description":"","date":"2024-05-20 16:24","slug":"2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_0.png\" /\u003e\n\n안녕하세요! 어느 날 갑작스럽게 기본 백엔드 서버가 다운되었어요. 이런 상황은 모든 소프트웨어 엔지니어가 두려워하는 일이지요. 다행히도 저희는 메인 백엔드 어플리케이션을 위해 두 개의 ECS 작업(각 작업을 서버로 생각하시면 돼요)를 구성해 두었어요. 우리의 Auto Scaling 그룹은 항상 두 개의 작업이 실행 중인 상태를 유지하도록 설정되어 있어, 서버들은 자동으로 다시 시작되었답니다. 그러나 문제는 계속 발생했고 때로는 간헐적으로 일어났어요.\n\n멈춘 서버 작업의 로그를 조사하기 시작했어요. 관련 정보가 거의 없는 것을 발견했지만, Gunicorn이 oom-killer를 호출한 흔적을 발견했습니다.\n\n낮은 메모리가 문제일까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGunicorn이 UTC 오전 05:43:20에 out-of-memory (oom) 킬러를 호출했습니다. 이전에 UTC 오전 05:42:36에 ECS에서 작업이 건강하지 않다고 판단되었습니다. 낮은 메모리로 인해 Gunicorn이 요청을 처리하지 못했을 가능성이 있습니다. 이로 인해 요청에 응답을 중단하고 일정한 시간 초과 또는 버퍼 기간 후 oom 킬러를 호출했을 수 있습니다.\n\n양 서버에서 'top' 명령어를 통해 메모리가 잠재적으로 문제가 될 수 있다는 것을 시사했습니다. 이는 Gunicorn이 oom-killer를 호출하여 더 확신시켰습니다. 이러한 요소들로 인해 문제가 메모리 부족임이 확인되었습니다.\n\n초반에는 많은 양의 요청들이 서버의 메모리를 고갈시킬 수도 있다고 가정했습니다. 따라서 주어진 기간 내에 서비스된 요청 수를 추적하는 Athena 로그를 조사하기 시작했습니다. 그러나 결과는 놀라웠습니다. 서버가 멈출 때 API 요청은 없었고 건강 상태 확인 API 호출만 있었습니다. 저희의 설정에는 건강 상태 확인 API를 5초마다 호출하는 건강 상태 확인 구성이 포함되어 있습니다. 연속해서 두 번의 실패가 발생하면 호스트가 건강하지 않은 상태로 표시됩니다.\n\n어딘가 메모리 누수가 있는 건가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 메모리 사용량이 증가하는지 모니터링하기 위해 특정 요청 수를 초당 전송하는 군사 스크립트를 실행했습니다.\n\n애플리케이션이 동기 워커를 사용하여 실행되었을 때, 메모리 사용량은 330MB 정도로 안정적이었습니다.\n\n그러나 애플리케이션이 비동기 Gevent 워커를 사용하여 실행될 때, 메모리 사용량이 175MB에서 560MB로 증가했습니다. 군사 스크립트를 후속 실행할 때, 메모리 사용량은 550–560MB 정도로 안정적으로 유지되었습니다.\n\n이 동작은 워커가 요청을 처리한 후에도 메모리를 소비하고 해제하지 않았음을 시사했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGunicorn 설명서에서는 메모리 누수의 영향을 완화하기 위해 최대 요청 수에 제한을 설정하는 것을 권장합니다. max-requests 매개변수는 워커가 다시 시작되기 전에 처리할 수 있는 최대 요청 수를 정의합니다. 또한, max-requests-jitter 매개변수를 설정하여 워커 다시 시작을 무작위화하여 모든 워커가 동시에 다시 시작되는 것을 방지할 수 있습니다.\n\nhttps://docs.gunicorn.org/en/stable/settings.html#max-requests\n\nmax-requests 및 max-requests-jitter로 테스트\n\n- max-requests를 100, max-requests-jitter를 30으로 설정합니다.\n- 이렇게 하면 k가 무작위 지터 값인 경우에 워커는 100 + k 요청 후에 다시 시작됩니다. 이 값은 [0, 30] 범위 내에서 지연된 다시 시작을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n관찰:\n\n# 새로운 문제의 탄생\n\n![이미지](/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_1.png)\n\n구니콘 구성을 업데이트하는 도중에 max-requests 100을 구현하는 중요한 변경 사항이 도입되었습니다. 이 업데이트로 인해 서버 응답 시간에 예기치 않은 영향이 발생했으며, 우리의 메트릭에서 이러한 수치가 상당히 증가하는 것을 보고했습니다. 이 변경 사항은 중요하지 않았으며, 우리 제품 환경에서 여러 p99 경보가 트리거되어 잠재적인 문제의 명백한 표시가 되어 추가 조사와 해결이 필요하다는 것을 나타냈습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이러한 경고에 대응하여, 우리는 max_requests와 max_requests jitter의 다양한 조합을 활용한 포괄적인 테스트 세트를 시작했습니다.\n\n![](/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_2.png)\n\n우리가 결과를 조사하면서, 특정 구성이 눈에 띄었습니다. max_requests=250 및 max_requests_jitter=15의 조합은 테스트한 다른 구성과 비교했을 때 가장 유리한 결과를 보여주었습니다. 이 설정은 Maximum Memory 사용량이 468 mb로, 우리가 테스트한 다른 구성보다 현저히 낮은 측정값을 보여주었습니다. 또한, 모든 구성 중 가장 낮은 p99 결과인 1345를 나타냈습니다. 실패한 요청의 비율은 5/3330으로, 다른 구성의 비율과 일치했습니다.\n\n그러나, 테스트에서 유망한 결과를 얻었지만, 이러한 설정을 우리의 프로덕션 환경에 배포해도 p99 문제를 해결할 수 없었습니다. 이 차이로 인해 우리는 문제를 깊이 있게 들여다보고, 가능한 원인과 해결책에 대해 더 고찰해야 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가설은 작업자가 특정 수의 요청을 처리한 후 (이 경우 250+k를 초과하는 어떤 수), 재시작을 시작할 것이라는 것이었습니다. 이 재시작은 처음에는 무해해 보이지만 약간의 지연을 초래할 수 있었고, 이후에는 요청 대기열의 누적으로 이어질 수 있습니다.\n\n우리는 max_requests와 max_requests_jitter 매개변수에 대해 더 큰 숫자를 사용하여 실험을 실행하기로 결정했습니다: max_requests=3000 max_requests_jitter=50.\n\n우리의 수정된 가설은 작업자가 특정 수의 요청을 처리한 후 (구체적으로 250+k보다 큰 수), 재시작을 거쳐야 한다는 것을 제안했습니다. 이 재시작은 약간의 지연을 유발할 수 있어 대기 중인 요청이 늘어나게 될 수 있습니다. 우리는 250가 상대적으로 작은 수이므로, 작업자들이 자주 재시작되어 재시작 프로세스 중 간헐적인 지연이 발생한다고 추정했습니다.\n\n이에 대처하기 위해, 우리는 max_requests를 더 큰 수로 증가시키기로 결정했습니다. 이는 작업자 재시작 빈도를 줄이고, 동시에 이전의 메모리 누수 문제를 다시 도입하지 않도록 하는 목적으로 수행되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 전략을 따라서 max_requests를 3000으로, max_requests_jitter를 50으로 증가시켰습니다. 이러한 조치의 목적은 빈번한 워커 재시작과 이로 인한 지연 문제를 피하는 것이었습니다. 이러한 새로운 설정으로 워커가 다시 시작되기 전의 최대 메모리 소비량이 600MB로 관측되었습니다. 이는 gunicorn이 메모리 임계값인 700MB에 도달한 후에만 out of memory (OOM)을 발생시키기 때문에 수용 가능한 수준으로 판단되었습니다. p99는 로드 테스트에서 max_requests = 250, max_requests_jitter = 15 구성에서의 1345ms 대비 728ms로 상당히 낮아졌습니다. 이 실험적인 접근법은 p99 문제와 메모리 문제를 효과적으로 해결하여, 서버 관리에서 계속해서 테스트, 가설 형성, 혁신적 문제 해결의 중요성을 입증했습니다.","ogImage":{"url":"/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_0.png"},"coverImage":"/assets/img/2024-05-20-MaxRequestsJitterTheSpineofAsyncGunicornWorkers_0.png","tag":["Tech"],"readingTime":5},{"title":"리액트 네이티브에서의 애니메이션으로 구현한 타이핑 효과의 매력","description":"","date":"2024-05-20 16:23","slug":"2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative","content":"\n\n제 웹사이트에 방문해주셔서 감사합니다!\n\n![Click Here](https://miro.medium.com/v2/resize:fit:852/1*nUVr8lekbEbpfkq53IZ2fQ.gif)\n\n당신의 React Native 앱의 사용자 경험에 몇 가지 풍미를 더하고 싶나요? 애니메이션된 타자 효과의 매료되는 세계로 빠져들어보세요! 이 글에서는 글자가 한 글자씩 나타나는 화려한 애니메이션 효과를 생성하는 방법을 살펴볼 것입니다. 이 애니메이션은 사용자에게 매혹적인 타자 경험을 제공합니다.\n\n이 매혹적인 효과를 어떻게 달성하는지 단계별로 코드를 자세히 살펴보면서 시작해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 초기 설정: 필요한 모듈을 가져와 컴포넌트의 props를 정의하는 것으로 시작합니다.\n- 상태 관리: 컴포넌트는 React 훅 (useState 및 useRef)을 사용하여 상태와 참조를 관리합니다. text 상태는 현재 표시된 텍스트를 보유하고, completed는 입력이 완료되었는지를 나타내며, cursorColor는 커서 표시 여부를 관리합니다. 또한 textIndex를 추적하여 다음에 표시할 문자를 파악합니다.\n- 스타일링: StyleSheet.create를 사용하여 텍스트의 모양을 사용자 정의하는 스타일을 정의합니다.\n- 타이핑 애니메이션: typingAnimation 함수는 주요 애니메이션 논리를 처리합니다. text prop에서 문자를 순차적으로 추가하여 입력하는 것을 모방하여 현재 표시된 텍스트에 문자를 추가합니다. 부드러운 애니메이션을 위해 재귀적 setTimeout이 사용됩니다.\n- 커서 애니메이션: cursorAnimation 함수는 깜빡이는 효과를 만들기 위해 커서의 색상을 토글합니다.\n- 효과 및 정리: useEffect 훅은 애니메이션 타이밍과 정리를 관리합니다. 컴포넌트가 마운트될 때 타이핑 애니메이션 및 커서 깜박임을 시작하고 언마운트할 때 타이머를 정리합니다.\n\n이제 앱에서 이 컴포넌트를 생성하는 방법을 살펴보겠습니다:\n\n```js\nimport React, { useRef, useState, useEffect } from 'react';\nimport { StyleSheet, Text } from 'react-native';\n\ninterface AnimatedTypingProps {\n  text: string;\n  onComplete?: () =\u003e void;\n}\n\nconst AnimatedTyping: React.FC\u003cAnimatedTypingProps\u003e = (props) =\u003e {\n  // 코드 생략\n\nexport default AnimatedTyping;\n```\n\n컴포넌트에서 AnimatedTyping을 가져와 원하는 텍스트 및 onComplete 콜백과 함께 사용하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```jsx\n\u003cAnimatedTyping\n    text={query}\n    onComplete={handleAnimationDefaultComplete}\n/\u003e\n```\n\n저희와 함께 이 자극적인 애니메이션 기술을 살펴봐 주셔서 감사합니다! LinkedIn에서 의견과 피드백을 남겨주시면 감사하겠습니다. 연락해서 경험을 공유해주세요. 즐거운 코딩하세요!\n\n# 매우 쉽게 설명하기 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 저자를 응원하고 팔로우하기 잊지 마세요! 👏️️\n- 저희를 팔로우하세요: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼에서도 만나보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠를 만나보세요","ogImage":{"url":"/assets/img/2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative_0.png"},"coverImage":"/assets/img/2024-05-20-TheMagicofAnimatedTypingTransitioninReactNative_0.png","tag":["Tech"],"readingTime":2},{"title":"AppDelegate, SceneDelegate, 그리고 SwiftUI 라이프사이클 이해하기","description":"","date":"2024-05-20 16:21","slug":"2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png\" /\u003e\n\nAppDelegate는 무엇인가요?\n\niOS의 이전 버전에서, iOS 13 이전에는 AppDelegate라는 것이 있었습니다. 이것은 앱의 보스 역할을 했고, 앱이 시작하거나 중지되거나 백그라운드로 이동할 때 관리를 했습니다. 앱 시작 및 백그라운드 모드 같은 중요한 이벤트를 다뤘습니다.\n\n```swift\nimport UIKit\n\n@UIApplicationMain\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    \n    var window: UIWindow?\n    \n    func application(_ application: UIApplication, didFinishLaunchingWithOptions \n                     launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u003e Bool {\n        // 애플리케이션 시작 후 커스터마이징을 위한 오버라이드 포인트입니다.\n        return true\n    }\n    \n    func applicationWillResignActive(_ application: UIApplication) {\n        /*\n         애플리케이션이 비활성 상태로 이동할 때 전송됩니다. 일시적으로 인터럽트(예: 전화 통화 또는 SMS 메시지 수신)가 발생하거나 사용자가 애플리케이션을 종료하고 백그라운드 상태로 전환될때 발생할 수 있습니다.\n         계속 중인 작업을 일시 중지하고 타이머를 비활성화하며 그래픽 렌더링 콜백을 무효화하는 데 이 메서드를 사용합니다. 게임은 게임 일시 중지에 이 방법을 사용해야 합니다.\n         */\n    }\n    \n    func applicationDidEnterBackground(_ application: UIApplication) {\n        /*\n        공유 리소스를 해제하고 사용자 데이터를 저장하며 타이머를 무효화하며 애플리케이션 상태 정보를 충분히 저장하여 나중에 종료됐을 때 애플리케이션을 현재 상태로 복원하는 데 이 메서드를 사용합니다.\n        애플리케이션이 백그라운드 실행을 지원하는 경우, 이 방법은 사용자가 종료할 때 applicationWillTerminate: 대신 호출됩니다.\n         */\n    }\n    \n    func applicationWillEnterForeground(_ application: UIApplication) {\n        /*\n        백그라운드에서 활성 상태로 전환하는 일부로 호출됩니다;\n        여기서 백그라운드 진입 때에 수행되었던 변경을 취소할 수 있습니다.\n         */\n    }\n    \n    func applicationDidBecomeActive(_ application: UIApplication) {\n        /*\n        애플리케이션이 비활성 상태일 때 일시 중지된 작업(또는 아직 시작되지 않은 작업)을 다시 시작합니다.\n        애플리케이션이 이전에 백그라운드에 있었을 경우 선택적으로 사용자 인터페이스를 새로 고칩니다.\n         */\n    }\n    \n    func applicationWillTerminate(_ application: UIApplication) {\n        /*\n        애플리케이션이 종료되기 직전에 호출됩니다.\n        적절하다면 데이터를 저장합니다. 또한 applicationDidEnterBackground:도 참조하십시오.\n         */\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSceneDelegate- 뭐야?\n\niOS 13가 출시되었을 때 Apple은 SceneDelegate라는 새로운 기능을 추가했어. 이건 주로 iPad를 위한 거였는데, 이를 통해 다중 창을 사용할 수 있게 됐어. AppDelegate의 일부 업무가 SceneDelegate로 넘어가게 됐어. 그래서 이제 두 개가 함께 앱을 관리하게 되었어.\n\nAppDelegate.swift\n\n```js\nimport UIKit\n\n@main\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u003e Bool {\n        // 애플리케이션 시작 후 커스터마이징할 때 오버라이드 포인트\n        return true\n    }\n\n    // MARK: UISceneSession 생명주기\n\n    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -\u003e UISceneConfiguration {\n        // 새로운 씬 세션을 생성할 때 호출\n        // 이 메소드를 사용하여 새 씬을 만들기 위한 구성을 선택해\n        return UISceneConfiguration(name: \"Default Configuration\", sessionRole: connectingSceneSession.role)\n    }\n\n    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set\u003cUISceneSession\u003e) {\n        // 사용자가 씬 세션을 삭제했을 때 호출\n        // 응용프로그램이 실행 중이 아닌 경우 어떤 세션이 삭제되었다면, application:didFinishLaunchingWithOptions 이후에 이 메소드가 호출될 거야\n        // 폐기된 씬에 특정한 리소스를 해제하는 데 이 메소드를 사용해, 다시 돌아오지 않을 거니까\n    }\n\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSceneDelegate.swift\n\n```swift\nimport UIKit\n\nclass SceneDelegate: UIResponder, UIWindowSceneDelegate {\n\n    var window: UIWindow?\n\n\n    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {\n        // 이 메서드를 사용하여 UIWindow 'window'를 선택적으로 구성하고 UIWindowScene 'scene'에 연결합니다.\n        // Storyboard를 사용하는 경우 'window' 속성은 자동으로 초기화되어 scene에 연결됩니다.\n        // 이 델리게이트는 연결되는 scene이나 세션이 새로운 것임을 의미하지 않습니다 (대신 'application:configurationForConnectingSceneSession' 참조).\n        guard let _ = (scene as? UIWindowScene) else { return }\n    }\n\n    func sceneDidDisconnect(_ scene: UIScene) {\n        // 시스템에 의해 해제되는 즉시 scene이 호출됩니다.\n        // scene이 백그라운드로 들어가거나 해당 세션이 버려질 때 발생합니다.\n        // 이 scene과 관련된 재생성 가능한 리소스를 해제합니다.\n        // scene이 다시 연결될 수 있으므로 세션이 반드시 버려지지는 않습니다('application:didDiscardSceneSessions' 참조).\n    }\n\n    func sceneDidBecomeActive(_ scene: UIScene) {\n        // scene이 비활성 상태에서 활성 상태로 전환된 경우에 호출됩니다.\n        // scene이 비활성 상태였을 때 일시 중단되었던 작업을 다시 시작하는 데 이 메서드를 사용합니다.\n    }\n\n    func sceneWillResignActive(_ scene: UIScene) {\n        // scene이 활성 상태에서 비활성 상태로 전환될 때 호출됩니다.\n        // 일시적인 중단(예: 전화 통화 수신)으로 인해 발생할 수 있습니다.\n    }\n\n    func sceneWillEnterForeground(_ scene: UIScene) {\n        // scene이 백그라운드에서 전경으로 전환될 때 호출됩니다.\n        // 백그라운드로 전환할 때 발생한 변경 사항을 취소하는 데 이 메서드를 사용합니다.\n    }\n\n    func sceneDidEnterBackground(_ scene: UIScene) {\n        // scene이 전경에서 백그라운드로 전환될 때 호출됩니다.\n        // 데이터를 저장하고 공유 리소스를 해제하며 충분한 scene별 상태 정보를 저장하여\n        // scene을 현재 상태로 복원하는 데 이 메서드를 사용합니다.\n    }\n\n}\n```\n\n차이점은 SceneDelegate가 여러 창을 다루는 반면에 AppDelegate는 여전히 평소 역할을 합니다. 따라서 이제 앱은 다른 창에서 다른 내용을 동시에 표시하는 것과 같이 더 많은 일을 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 SwiftUI는요?\n\nSwiftUI를 사용하면 Apple의 새로운 앱 개발 방법으로, 더 이상 AppDelegate 또는 SceneDelegate가 필요하지 않을 수도 있어요. 대신에 Notification Event로 대부분의 작업을 처리할 수 있어요. 하지만 만약 프로젝트에 아직 AppDelegate 또는 SceneDelegate가 있다면, 코드를 깔끔하고 조직적으로 유지하는 데 도움이 될 거예요.\n\n그래서, 이것이 다른 iOS 버전에서 앱의 주요 매니저들이 작동하는 방식이에요.\n\nSwiftUI에서 AppDelegate를 구현하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- AppDelegate.swift 파일을 만듭니다.\n\n새 파일 추가로 이동 - `Cocoa Touch Class`를 선택합니다.\n\n![이미지](/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_1.png)\n\n이름(AppDelegate)을 입력하고 NSObject의 subclass를 선택합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle](/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_2.png)\n\nClick on “Next” will create Appdelegate.swift file which look like below\n\n```swift\nimport UIKit\nclass AppDelegate: NSObject {\n\n}\n```\n\n2. With following above process again we can create SceneDelegate.swift file.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_3](/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_3.png)\n\nAppDelegate.swift 파일과 처음으로 나타날 것입니다.\n\n```swift\nimport UIKit\nclass SceneDelegate: NSObject {\n\n}\n```\n\n이제 AppDelegate.swift와 SceneDelegate.swift 파일에 적용해야 할 실제 변경 사항을 아래에 안내해드립니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAppDelegate.swift\n\n```swift\nclass AppDelegate: NSObject, UIApplicationDelegate {\n \n     func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -\u003e Bool {\n         return true\n     }\n     \n     func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -\u003e UISceneConfiguration {\n         \n         let sceneConfig : UISceneConfiguration = UISceneConfiguration(name: nil, sessionRole: connectingSceneSession.role)\n         sceneConfig.delegateClass = SceneDelegate.self\n         return sceneConfig\n         \n     }\n }\n```\n\nUIApplicationDelegate은 iOS 개발에서 사용되는 프로토콜로, iOS 애플리케이션의 라이프사이클 이벤트를 관리하고 응답하는 일련의 메서드를 정의합니다. \n\n이 프로토콜은 앱 시작, 종료, 백그라운드 또는 포그라운드 진입, 푸시 알림 수신 등과 같은 이벤트를 처리하기 위한 중앙 허브 역할을 합니다. 제공된 코드의 AppDelegate와 같이 이 프로토콜을 준수하는 클래스는 이러한 메서드를 구현하여 애플리케이션의 동작을 라이프사이클 이벤트에 따라 맞춤화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 첫 번째 함수인 application(_:didFinishLaunchingWithOptions:)은 앱이 로딩을 마칠 때 호출됩니다. 이 함수는 실행이 성공적인지 여부를 나타내는 부울 값이 반환됩니다.\n- 두 번째 함수인 application(_:configurationForConnecting:options:)은 새로운 씬 세션을 생성할 때 호출됩니다. 이 함수는 씬의 속성을 구성하는 데 도움이 되는 UISceneConfiguration 객체를 반환합니다. 여기서 UISceneConfiguration 객체를 생성하고 이 씬 세션의 구성을 처리할 SceneDelegate 클래스를 해당 UISceneConfiguration 객체로 할당합니다.\n\nSceneDelegate.swift\n\n```js\nimport SwiftUI\n\nclass SceneDelegate: NSObject, UIWindowSceneDelegate {\n\n    var window: UIWindow?\n    \n    func scene(_ scene: UIScene, willConnectTo \n               session: UISceneSession, options\n               connectionOptions: UIScene.ConnectionOptions) {\n        guard let _ = scene as? UIWindowScene else {return}\n    }\n    \n    func sceneDidBecomeActive(_ scene: UIScene) {\n        \n    }\n    \n    func sceneDidEnterBackground(_ scene: UIScene) {\n        \n    }\n    \n    func sceneWillEnterForeground(_ scene: UIScene) {\n        \n    }\n    \n    func sceneWillResignActive(_ scene: UIScene) {\n        \n    }\n}\n```\n\nUIWindowSceneDelegate 프로토콜은 씬의 라이프사이클 이벤트에 응답하고 앱의 창 씬 동작을 관리할 수 있도록 해줍니다. 씬의 생성, 소멸, 상태 복원 및 씬 관련 이벤트를 처리하기 위한 구조화된 방법을 제공하여 견고하고 반응성 있는 iOS 애플리케이션을 만들 수 있습니다. 여기에 대한 설명:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. scene(_:willConnectTo:options:): 새 창 장면이 연결되기 전에 호출되는 메서드입니다. 일반적으로 장면의 초기 사용자 인터페이스를 설정하는 곳입니다.\n\n2. sceneDidBecomeActive(_:): 창 장면이 활성 상태가 되면 트리거됩니다. 이는 사용자 상호 작용을 위해 준비된 상태를 의미합니다. 여기서 애니메이션을 시작하거나 작업을 재개할 수 있습니다.\n\n3. sceneWillResignActive(_:): 창 장면이 활성 상태를 잃기 직전에 호출됩니다. 사용자가 전화를 받거나 다른 앱으로 전환할 때 발생할 수 있습니다.\n\n4. sceneDidEnterBackground(_:): 이 메서드는 창 장면이 백그라운드로 전환될 때 호출됩니다. 여기서 앱의 현재 상태를 저장하거나 진행 중인 작업을 일시 중지하는 데 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. sceneWillEnterForeground(_:): 화면이 백그라운드에 있었다가 다시 활성화될 때 호출됩니다. 여기서 사용자가 돌아오면 사용자 인터페이스를 준비할 수 있습니다.\n\n이러한 메서드를 사용하면 앱의 창 화면이 수명주기 동안의 동작을 사용자 정의하여 부드럽고 반응적인 사용자 경험을 보장할 수 있습니다.\n\n지금 SwiftUI 앱 라이프사이클에 AppDelegate를 연결해보세요.\n\n```swift\nimport SwiftUI\n\n@main\nstruct SwiftUIDemoApp: App {\n    \n    @UIApplicationDelegateAdaptor(AppDelegate.self) private var appdelegate\n    \n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwiftUI 앱에서는 App 구조체에서 AppDelegate 인스턴스에 접근할 수 있습니다. 이때 사용하는 프로퍼티 래퍼는 UIKit 앱에서 UIWindowSceneDelegate와 유사한 방식으로 작동합니다. 그러나 여기서 사용해야 하는 프로퍼티 래퍼는 @UIApplicationDelegateAdaptor입니다.\n\n- @UIApplicationDelegateAdaptor(AppDelegate.self)은 AppDelegate 인스턴스에 액세스할 수 있는 프로퍼티 래퍼입니다.\n- private var appDelegate는 AppDelegate 인스턴스에 대한 참조를 보유하는 프로퍼티입니다.\n\n이 Github URL을 시도해보세요! 궁금한 점이 있으면 언제든지 물어보세요.\n\nNEXT: SwiftUI를 사용하여 변수를 정의하고 키워드를 입력하는 방법에 대해 공유할게요.","ogImage":{"url":"/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png"},"coverImage":"/assets/img/2024-05-20-UnderstandingAppDelegateSceneDelegateandSwiftUILifecycle_0.png","tag":["Tech"],"readingTime":10},{"title":"모바일 개발 아이디어부터 구현까지 DevInterface와 함께","description":"","date":"2024-05-20 16:20","slug":"2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface","content":"\n\n![image](/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png)\n\n애플리케이션에 대한 아이디어가 있고 다음 단계가 무엇인지 궁금한가요?\n\n옵션은 무한하며 매일 새롭고 흥미로운 스마트폰 애플리케이션이 시장에 출시됩니다. 영감은 분명히 부족하지 않습니다. 그러나 부족한 것은 구현입니다. 사용자 지정 앱을 만들고 싶다면 어디서부터 시작해야 할까요?\n\n저희 글은 여러분이 아이디어를 실제로 구현할 수 있도록 제안하는 길을 안내해 드립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 개발 회사에 앞서 고려해야 할 사항...\n\n## 1) 내 앱이 이미 존재하는가?\n\nApp Store와 Google Play에는 수백만 개의 앱이 있습니다. 당신의 아이디어가 새로운 것일 가능성은 상대적으로 낮을 수 있습니다. 하지만 이로 인해 낙담해서는 안 됩니다. 귀하의 산업과 관련된 앱을 찾아서 테스트해보세요. 사용자 리뷰를 확인하고 귀하의 앱을 개선하는데 영감을 받으세요.\n\n## 2) 내 타겟 그룹은 무엇을 생각하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIf your idea seems really new and innovative, ask yourself: why? and seek expert advice as well. Your topic may not be suitable for app development or may even not be allowed. Also, your target group of potential users might be very narrow. Speak to a representative of your potential user group and try to get honest feedback: does my app idea really solve (your) problem?\n\n### 3) What problem does my app solve?\n\nAn app idea has potential if it solves a problem. In times of oversupply, a user approaching your product may rightfully ask: “What do I get by installing this app?”. Your app idea must address a specific and concrete challenge that your target group has recognized. It is also important to consider whether the problem is temporary or permanent.\n\n### Approaching a development company like DevInterface\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n귀하의 앱 개발이 성공적으로 이루어지도록 하기 위해 DevInterface에서는 다음 단계를 적용합니다:\n\n## 1) 앱 프로젝트 평가 분석\n\n### 아이디어 평가\n\n이 단계에서는 함께 앱 아이디어를 평가합니다. 이는 앱이 해결해야 하는 문제 또는 필요성을 식별하는 것을 의미합니다 (이전에 이미 이를 설명한 바 있다면 더 좋습니다). 시장을 분석하여 수요와 경쟁력을 이해하고 대상 청중을 정의합니다. 또한 사용 가능한 자원, 필요한 기술 및 마감일에 대한 아이디어의 실행 가능성을 확인하려고 노력합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기능\n\n아이디어와 관련된 다양한 측면을 평가한 후, 앱의 기능을 분석합니다. 기능 요구 사항을 식별하고 중요도에 따라 기능 우선 순위를 정하며, 앱을 풍부하게할 추가 기능을 정의하고 사용자 경험을 고려하여 사용자 인터페이스의 사용성 및 인체공학을 분석합니다.\n\n## 기술\n\n마지막으로, 프로젝트에 가장 적합한 개발 기술을 선택하여 첫 번째 부분을 마무리합니다. 이 과정에는 프로그래밍 언어, 프레임워크 및 데이터베이스의 선택뿐만 아니라 앱의 배포 플랫폼, 확장 가능성 및 성능 요구 사항, 사용자 데이터의 보호를 위한 보안 및 개인 정보 제약 사항을 고려하여 사용자 데이터의 보호를 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2) UX/UI 디자인\n\n## 사용자 연구 및 경쟁 분석\n\n저희에게 오는 고객 유형에 따라, UX/UI 디자인의 첫 단계로 사용자 연구를 실시하고 경쟁사를 분석하여 상황과 사용자 기대를 명확히 파악합니다.\n\n## 사용자 페르소나 및 시나리오 작성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수행한 연구를 통해 대상 사용자의 가상화된 표현인 사용자 페르소나를 만듭니다. 이를 통해 사용자의 요구 사항, 행동 및 목표를 더 잘 이해할 수 있습니다. 또한 응용 프로그램의 사용 사례 및 상호 작용 흐름을 설명하는 사용자 시나리오가 정의됩니다.\n\n## 정보 아키텍처 디자인\n\n정보 아키텍처를 통해 사용자 인터페이스의 구조와 조직을 정의합니다. 이는 사이트맵과 플로우차트를 작성하여 사용자가 응용 프로그램을 통해 탐색하는 것을 시각화하는 것을 포함합니다.\n\n## 와이어프레이밍 및 프로토타이핑\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 사용자 인터페이스를 개략적이고 상호 작용적인 방식으로 표현하는 낮은 중, 중간 정도의 친밀도를 가진 와이어프레임과 프로토타입을 작성합니다. 이로써 디자인 솔루션을 평가하고 테스트할 수 있으며, 시각 디자인 및 개발 단계로 진행하기 전에 초기 단계에서 진행합니다.\n\n## 시각 디자인과 스타일\n\n와이어프레임과 프로토타입이 확정되면 시각 디자인 단계로 진행합니다. 애플리케이션의 룩 앤 필을 정의하고, 색상, 서체 및 그래픽 요소 선택합니다. 목표는 브랜드와 일관성 있고 사용자에게 매력적인 디자인을 만드는 것입니다.\n\n## 사용성 테스트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트를 개발 팀에 넘기기 전에 중요한 마지막 단계는 사용성 테스트를 실시하여 사용자 인터페이스의 효과성과 사용자 경험을 평가하고 피드백을 수집하여 애플리케이션이 출시되기 전에 해결해야 할 사용성 문제를 식별하는 것입니다.\n\n# 3) 개발\n\n## 아키텍처 정의\n\n개발 단계는 앱 아키텍처의 정의로 시작됩니다. 이는 애플리케이션의 주요 구성 요소인 프론트엔드와 백엔드의 설계 및 그들 간의 상호작용의 정의를 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## API 및 백엔드 개발\n\n백엔드 서비스와 API를 개발하는 과정에서는 애플리케이션의 작업을 지원하기 위해 필요한 기능을 구현합니다. 데이터 관리, 사용자 인증, 외부 시스템과의 통합 등이 포함될 수 있습니다. 우리는 확장 가능하고 안전하며 성능이 우수한 백엔드 아키텍처를 제공하기 위해 노력합니다.\n\n## 앱 개발\n\n애플리케이션의 실제 개발 과정에서는 이전 단계에서 정의된 요구 사항과 기능을 코드로 번역합니다. 이는 사용자 인터페이스 개발, 비즈니스 로직 구현 및 백엔드 서비스와의 통합을 포함할 수 있습니다. 이 과정에서는 사용자 인터페이스 디자인 가이드라인을 준수하고 앱이 일관되고 사용자에게 직관적인지 확인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 테스트\n\n개발 단계에서 마지막으로 중요한 단계는 테스트입니다. 이는 개별 코드 구성 요소를 확인하는 단위 테스트, 앱의 다른 모듈이 올바르게 상호 작용하는지 확인하는 통합 테스트, 그리고 앱이 최종 사용자의 기대를 충족시키는지 확인하는 사용자 수용 테스트가 포함될 수 있습니다.\n\n# 4) 릴리스 및 유지 보수\n\n## 앱 릴리스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발 단계가 완료되고 품질 테스트를 통과한 후에는 응용 프로그램이 대상 플랫폼으로 배포됩니다. 이는 앱 스토어(예: Apple App Store, Google Play Store for Android) 또는 대상 대상자에 따라 다른 배포 플랫폼에 포함될 수 있습니다.\n\n## 성능 모니터링\n\n앱이 출시된 후에는 성능을 주의 깊게 모니터링하는 것이 중요합니다. 예를 들어 서버의 안정성과 성능에 대한 것이 포함될 수 있습니다.\n\n## 업데이트 및 유지보수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션의 수명 주기 동안은 업데이트와 버그 수정이 필요할 수 있습니다. 이러한 업데이트는 앱의 기능을 향상시키고 사용자가 마주친 문제를 해결하며 새로운 운영 체제 및 기기 버전과의 호환성을 보장하기 위해 주기적으로 출시될 수 있습니다.\n\n# 당신만의 앱을 만들어 보고 싶으신가요?\n\n이 글에서 읽으신 내용을 이미 CXOs, 마케팅 매니저, 제품 소유자, 그리고 디지털 매니저들이 우리에게 신뢰하여 자신의 앱을 만들어달라고 부탁한 다양한 프로젝트에 적용했습니다. 당신이 성공적인 앱을 개발하기 위한 방법, 도구, 프로세스, 그리고 팀을 만들어야 할 필요 없이 바로 시작하고자 한다면, 전략, 컨셉, 실행, 혹은 마케팅 단계에 있든 상관없이, 저희는 대부분의 작업을 기꺼이 맡아 처리하고 협력의 정신으로 전체 과정을 안내해 드릴 것입니다.\n\n따라서 당신은 핵심 활동에 집중하고 프로젝트를 착수할 수 있으며, 우리는 전략 및 개념의 전반적인 안내와 함께 원하신다면 전문 팀으로 직접 앱을 개발할 수 있는 점에 대해 안내해 드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 무료 상담을 제공합니다. 프로젝트 계획을 함께 세우고, 초기 전략부터 최종 릴리스까지 프로젝트가 성공적으로 진행되도록 안내해 드립니다.\n\n지금 바로 무료 상담 신청하세요.\n\n원문 게시 위치: https://www.devinterface.com.","ogImage":{"url":"/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png"},"coverImage":"/assets/img/2024-05-20-MobiledevelopmentfromideatoimplementationwithDevInterface_0.png","tag":["Tech"],"readingTime":5},{"title":"안녕하세요 VSCode에서 플러터 앱을 실행하고 디버그하기 위해 안드로이드 기기를 WiFi로 연결하는 방법에 대해 이야기하겠습니다","description":"","date":"2024-05-20 16:19","slug":"2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png\" /\u003e\n\n# 핸드폰 배터리 손상하지 말고 앱 테스트, 케이블 없이 디버깅하세요 (거의).\n\n이 게시물은 이미 USB 연결로 Android 기기에서 실행 및 디버깅을 구성했다고 가정합니다. Android 13 기기 및 Windows 10 컴퓨터에서 테스트되었습니다. 컴퓨터와 휴대폰 모두 동일한 네트워크에 연결되어 있어야 합니다.\n\n## 일회성 IDE 및 장치 구성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- [Optional] VSCode 확장 프로그램인 ADB Commands를 설치하세요. 안 깔았다면 adb 명령어를 사용할 수 있어요. 확장 프로그램을 사용하는 편이 더 직관적이고 설정할 게 거의 없어요.\n- 기기에서 무선 디버깅을 활성화하세요:\n  - 설정으로 이동해서 “debug”를 검색하세요.\n  - “무선 디버깅”을 탭한 후, 다시 “무선 디버깅” 옵션을 (토글이 아닌 전체 항목을 탭해서 상세 페이지로 이동하세요.\n  - “무선 디버깅 사용” 토글을 확인하세요. “이 네트워크에서 무선 디버깅 허용” 팝업에서 “이 네트워크에서 항상 허용”을 선택하고 “허용”을 탭하세요.\n  - “IP 주소 및 포트 정보”는 나중에 예약하세요 (대부분의 튜토리얼은 포트가 5555이라고 가정하지만, 제 브랜드 new Pixel 7에서는 다른 포트번호였어요).\n\n![Android Device](/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_1.png)\n\n## 기기 연결\n\n- [처음 연결할 때만] USB로 기기를 연결하세요.\n- VSCode에서 Ctrl+Shift+P를 누르고 “ADB:📱 Connect to device IP”를 검색하고 선택하세요:\n- IP 주소를 입력하고 엔터를 누르세요.\n- 포트 번호를 입력하세요.\n- “Connected to `IP`:`port`” 메시지가 나타나면 USB 케이블을 분리할 수 있어요.\n*참고: IP 주소는 사용하는 네트워크와 라우터 설정에 따라 달라질 수 있어요. 포트 번호는 매번 바뀔 수 있어요. 이렇게 되면 “ADB returned null value”나 다른 오류가 발생할 수 있어요.\n- VSCode에서 F5를 누르거나 \"Run \u003e Start Debugging\"으로 이동하세요. 즐겁게 개발하세요!","ogImage":{"url":"/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png"},"coverImage":"/assets/img/2024-05-20-ConnectYourAndroidDeviceOverWiFiinVSCodetoRunandDebugYourFlutterApp_0.png","tag":["Tech"],"readingTime":2},{"title":"플러터 앱 성능 향상을 위한 권장 사항 탐색","description":"","date":"2024-05-20 16:16","slug":"2024-05-20-ExploringFlutterappperformanceimprovementrecommendations","content":"\n\n앱 성능은 소프트웨어 제품을 개발할 때 항상 염두에 두어야 할 중요한 요소입니다. 앱 성능에 신경을 쓰면 앱을 믿을 수 있게 만들어주고 유용한 기능을 제공하고 멋진 사용자 인터페이스를 생성함으로써 기존 사용자를 유지하고 새 사용자를 유치하는 데 도움이 됩니다.\n\nFlutter 앱 성능을 향상시키는 팁을 찾을 수 있는 많은 훌륭한 기사와 비디오가 있습니다. 여기에서는 일반적인 개요를 제시하고, DevTools를 사용하여 몇 가지를 자세히 살펴볼 예정입니다.\n\nFlutter 앱은 기본적으로 성능이 우수합니다. 단순히 권장 사항을 따르기만 하면 됩니다. 이미 앱이 잘 작동하면 성능을 향상시키는 방법을 찾을 필요가 없습니다. 노력이 들어가지 않을 것입니다. 다음과 같은 주요 문제가 앱에 없는지 확인해야 합니다:\n\n- UI 지연 — 렌더링에 허용된 시간을 초과한다는 것을 의미하는 프레임을 건너뛰는 경우 (애니메이션이 끊기는 것을 관찰할 수 있음)\n- 배터리 소모가 빠른 경우\n- 기기가 과도하게 발열하는 경우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부가 관찰되면 문제가 발생한 곳을 찾아야 합니다. 앱 성능은 릴리스 모드와 비슷하지만 DevTools를 사용할 수 있는 프로파일 모드에서 실제 기기에서 조사되어야 합니다:\n\n```js\nflutter run --profile\n```\n\n성능 조사 목적으로 Profiling timeline 도구를 사용할 수 있습니다. 이 도구는 기기 화면에 렌더링된 프레임의 순서를 나타내는 차트입니다. UI 스레드와 래스터 스레드에서 데이터를 사용하며, 특정 시점에 실행된 프로그램 코드를 실제로 반영합니다. 코드가 효율적이지 않으면 (프레임 당 16.66밀리초 이상이 걸리면 — 초당 60프레임이 생성되어야 함) 막대는 빨간색으로 나타납니다. 그렇지 않으면 파란색으로 표시됩니다. Performance overlay 옵션을 활성화하면 차트를 기기 화면에 바로 추가할 수 있습니다.\n\n앱 성능에 대해 이야기할 때 리소스 소비를 의미한다는 것을 언급해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 시간 — 프로그램이나 코드의 실행에 필요한 시간량입니다. 초당 프레임 수(FPS), 앱 시작 시간, CPU 사용량 등으로 측정할 수 있습니다.\n- 공간 — 프로그램 실행에 필요한 데이터 저장 공간의 양입니다. 메모리(RAM) 사용량, 앱 크기 등으로 측정할 수 있습니다.\n\n소프트웨어 개발자들은 종종 앱 성능을 유지하기 위해 시간과 공간 소비 사이의 균형을 찾아야 합니다.\n\n더 구체적인 성능 지표는 다음 링크에서 확인할 수 있습니다: [https://docs.flutter.dev/perf/metrics](https://docs.flutter.dev/perf/metrics).\n\n# 성능 향상 권고사항 탐색\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n성능 향상을 위한 모든 권장 사항은 다음과 같이 요약할 수 있습니다:\n\n- 시간 관련:\n- 반복적인 작업을 수행하지 말고, 가능한 경우 캐싱을 사용하세요.\n- 비용이 많이 드는 작업은 필요할 때까지 지연시키세요. 이는 다소 모순적일 수 있습니다. 작업이 시간이 오래 걸리고 사용자가 결과가 필요한 높은 확률이 있다면, 사용자가 작업이 완료될 때까지 기다리지 않도록 미리 백그라운드에서 수행하는 것이 더 나은 솔루션이 됩니다.\n- 공간 관련:\n- 더 이상 필요하지 않고 나중에 필요하지도 않을 객체를 저장하지 마세요.\n- 미디어 파일 사용을 최적화하세요 (그리고 앱 크기를 일반적으로 최적화하세요).\n\n# 반복적인 작업을 수행하지 마세요\n\n반복 작업을 수행하지 말아야 한다는 권장 사항은 당연한 것처럼 들릴 수 있지만, 서두르지 마세요. 물론 필요 없이 동일한 작업을 다시 수행할 의향은 아무도 없을 것입니다. 그러나 프로젝트가 커질수록 논리도 복잡해지므로 누락될 수 있는 부분이 있을 수 있습니다. Flutter 프레임워크가 그러한 프로젝트로 간주될 수 있기 때문에 처음부터 주의 깊게 작업해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 가장 인기있는 권장 사항은 위젯의 빌드 메서드에서 실행 비용이 많이 드는 메서드를 호출하지 않는 것입니다. 빌드 메서드는 위젯을 초기화 한 후에 한 번만 호출되는 것이 아닙니다. 예를 들어 위젯이 다시 빌드될 때마다 서버 요청을 하는 것은 효율적이지 않습니다.\n\n그 외에 다시 빌드되는 횟수를 줄이는 것이 중요합니다. 다음 권장 사항을 따르면 이를 달성할 수 있습니다:\n\n- 컴파일 시간에 초기 상태를 결정할 수 있고 이후에 변경되지 않을 때만 사용할 수 있는 const 위젯을 사용하는 것. Flutter는 const 위젯의 단일 인스턴스를 만들어 위젯 트리에서 재사용하며 계속 만들고 다시 빌드하지 않습니다.\n- 위젯을 반환하는 메서드 대신 위젯을 선호하는 것. setState 메서드를 사용하여 자식 위젯이 나타내는 하위 트리만 업데이트할 때 전체 부모 위젯이 다시 빌드되는 것을 방지합니다. 위젯을 반환하는 메서드를 사용하면 전체 부모 위젯이 다시 빌드됩니다.\n- 위젯 트리의 중첩 수준(구조)과 유형을 변경하지 않는 것. Flutter는 이전 빌드에서 해당 위젯을 찾지 못하면 다시 빌드 중에 새 위젯을 만듭니다. 예를 들어 숨기려는 경우 위젯을 트리에서 제거하는 대신 IgnorePointer를 사용하여 무시 매개변수의 다른 값을 사용하는 것이 좋습니다. 중첩 수준을 변경해야 하는 경우 해당 위젯에 GlobalKey를 사용하는 것이 좋습니다.\n- 위젯에 가능한 캐싱을 사용하는 것. 예를 들어, AnimatedBuilder는 애니메이션 반복마다 다시 빌드되지 않을 위젯 서브트리를 저장하는 child 매개변수를 제공합니다. 그렇지 않으면 child 매개변수가 무시되고 해당 서브트리가 직접 builder 콜백에 지정된 경우 매번 다시 빌드될 것입니다.\n- RepaintBoundary 위젯을 사용하여 자식 위젯을 별도의 레이어로 분리하는 것. 더 많은 정보는 여기에서 확인할 수 있습니다 - https://www.youtube.com/watch?v=Nuni5VQXARo\n\n위젯이 다시 빌드되었을 때 확인하려면 안드로이드 스튜디오의 Flutter Inspector 탭에서 Widget rebuild stats를 사용하십시오. debugRepaintRainbowEnabled = true로 전역 변수를 설정하면 위젯 주변에 색상 경계가 표시되며 다시 빌드될 때 색상이 바뀝니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네! 테이블 태그를 마크다운 형식으로 변경해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass WidgetOptimizationPage extends StatefulWidget {\n  const WidgetOptimizationPage({super.key});\n\n  @override\n  State\u003cStatefulWidget\u003e createState() =\u003e _WidgetOptimizationPageState();\n}\n\nclass _WidgetOptimizationPageState extends State\u003cWidgetOptimizationPage\u003e {\n  @override\n  void didChangeDependencies() {\n    debugPrint('didChangeDependencies');\n    super.didChangeDependencies();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n        title: Text(\n          'Widget Optimization',\n        ),\n      ),\n      body: Column(\n        children: [\n          Container(\n            margin: const EdgeInsets.symmetric(vertical: 8),\n            height: 44,\n            width: 0.75 * MediaQuery.of(context).size.width,\n            child: const TextField(\n              decoration: InputDecoration(\n                border: OutlineInputBorder(),\n                hintText: 'Search',\n              ),\n            ),\n          ),\n          Expanded(\n            child: ListView.separated(\n              itemCount: 10,\n              itemBuilder: (BuildContext context, int index) {\n                return ListTile(\n                  visualDensity: VisualDensity.compact,\n                  title: Text('$index'),\n                );\n              },\n              separatorBuilder: (BuildContext context, int index) =\u003e const Divider(),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n```\n\n텍스트 필드에 포커스를 설정하여 키보드를 표시하고 Done 버튼을 클릭하여 숨기기를 시도하는 경우:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:704/1*u9fTFwbb5q-HzdNF6a9yoA.gif\" /\u003e\n\n콘솔에서 didChangeDependencies 메소드가 여러 번 실행된 것을 볼 수 있을 것입니다. 여기서 요청이 호출된 곳이었습니다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image 0](/assets/img/2024-05-20-Flutter성능개선권장사항탐색_0.png)\n\n위젯이 여러 번 다시 빌드되었음을 의미합니다. TextField는 총 3번 다시 빌드되었고 (화면이 열릴 때, 키보드가 나타났을 때, 키보드가 사라질 때), WidgetOptimizationPage는 12번 다시 빌드되었습니다:\n\n![image 1](/assets/img/2024-05-20-Flutter성능개선권장사항탐색_1.png)\n\ndidChangeDependencies 메서드가 InheritedWidget에서 알림에 대한 응답으로 작업을 수행하기에 적절한 위치임을 알려져 있습니다. 위젯이 어떤 변화들을 구독하는지 찾기로 결정했습니다. 위젯이 다소 복잡했기 때문에 몇 가지 가정을 하였지만, 위의 코드 예제에서는 명확하게 인식할 수 있습니다. 이유는 MediaQuery.of(context).size.width를 사용했기 때문입니다. MediaQuery는 기본적으로 다양한 매개변수를 가진 InheritedWidget으로, viewInsets와 padding을 포함하여 여러 매개변수가 있습니다. 이들은 키보드 애니메이션 중에 변경됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제의 해결 방법은 MediaQuery.sizeOf(context).width를 사용하는 것이었습니다. sizeOf는 해당 속성이 변경될 때마다 컨텍스트를 다시 빌드하며, MediaQueryData의 of 메서드에서 직접 속성을 가져 오는 것보다 우선해야 합니다.\n\n수정 후에 만든 아래 스크린샷에서 볼 수 있듯이 WidgetOptimizationPage가 한 번 다시 빌드되었습니다.\n\n![이미지](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_2.png)\n\n# 비용이 많이 드는 작업을 필요할 때까지 지연시키세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n성능 향상의 다음 원칙은 불필요한 작업을 하지 말아야 한다고 말합니다. 프로젝트의 구조, 상태 관리 방식, 사용하는 타사 라이브러리의 특성, 특정 화면의 내부 논리 등에 많이 따라 달라집니다. 이곳에서는 Dart에서 제공하는 몇 가지 사항을 언급하고 싶습니다.\n\n다트가 다른 프로그래밍 언어와 마찬가지로 복잡한 조건의 각 부분을 계산하지 않는다는 것을 모두 알고 있을 것입니다. 일부 조건이 일찍 결정될 수 있다면 다른 조건은 심지어 계산할 필요가 없게 됩니다. 예를 들어, 여러 조건이 OR 연산자로 연결된 조건인 경우 첫 번째 조건이 true를 반환하면 다른 조건들은 계산되지 않을 것입니다. 왜냐하면 그들은 전체 조건의 결과에 영향을 미치지 않기 때문이죠.\n\n```dart\nvoid testLateInitialization() async {\n  late final first = performCalculations();\n  late final second = performComplexCalculations();\n\n  if (first || second) {\n    debugPrint('Hello world');\n  }\n}\n\nbool performCalculations() {\n  // 여기에 일부 계산이 있다고 가정해봅시다.\n  return true;\n}\n\nbool performComplexCalculations() {\n  // 여기에 일부 복잡한 계산이 있다고 가정해봅시다.\n  return false;\n}\n```\n\n그리고 우리에게 중요한 한 가지 — late 키워드입니다. 이는 변수가 액세스하려고 시도할 때만 값을 가져온다는 것을 의미합니다. 이를 통해 조건을 의미있는 부분으로 분할하고 가독성을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDevTools의 Debugger 섹션에서는 아래 사진에 나와 있는 목록 아이콘 버튼을 선택하여 확인할 수 있습니다:\n   \n![List Icon](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_3.png)\n   \n함수 이름 앞에 초록색 선은 디버그 세션 중 호출된 것을 나타내고 빨간 선은 호출되지 않은 것을 나타냅니다.\n\n그리고 'late' 키워드에 대한 추가 정보 - 우리의 경우 비동기 함수에 사용할 수 없지만, 비동기 함수는 조건식에서 직접 호출할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nvoid testLateInitialization() async {\n  late final first = performCalculations();\n\n  if (first || await performComplexCalculations()) {\n    debugPrint('Hello world');\n  }\n}\n\nbool performCalculations() {\n  // Let's suppose here are some calculations\n  return true;\n}\n\nFuture\u003cbool\u003e performComplexCalculations() async {\n  // Let's suppose here are some complex calculations\n  return false;\n}\n```\n\n동기 함수에 대한 영향과 동일합니다 - 함수를 호출할 가치가 없으면 호출되지 않습니다.\n\n하나의 변수에 대한 늦은 초기화가 어떻게 작동하는지를 보여드렸습니다. 이제 게으른 컬렉션에 대해 이야기해 봅시다. Dart에서 List 객체에서 호출되는 많은 메서드는 Iterable을 반환합니다. Iterable은 자신의 항목을 반복하는 방법을 제공하는 추상 mixin입니다. 사실 List나 Set과 같은 컬렉션은 Iterable mixin을 구현합니다. Iterable의 요소는 요청될 때 계산되는 특징이 있습니다. 다음 코드를 살펴보겠습니다:\n\n```dart\nclass ListObject {\n  int value;\n\n  ListObject(this.value);\n}\n\nclass IterableObject {\n  String value;\n\n  IterableObject(this.value);\n}\n\nvoid testListVsIterable() {\n  final List\u003cint\u003e sourceList = List.generate(10, (index) =\u003e index);\n\n  final List\u003cListObject\u003e intObjectList = sourceList.map((e) =\u003e ListObject(e)).toList();\n  for (var element in intObjectList.take(5)) {\n    debugPrint('$element');\n  }\n\n  final stringObjectList = sourceList.map((e) =\u003e IterableObject('$e'));\n  for (var element in stringObjectList.take(5)) {\n    debugPrint('$element');\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 개의 클래스인 ListObject와 IterableObject을 만들었어요. 두 클래스는 값만을 가지고 있어서 거의 동일하며, 나중에 DevTools에서 구분하기 위해 만들었어요. testListVsIterable 함수에서 sourceList는 초기 데이터의 리스트이며, ListObject와 IterableObject의 컬렉션이 생성됩니다. map 함수는 Iterable을 반환하기 때문에 List`ListObject`를 얻기 위해 toList를 호출해야 합니다. 첫 5개 요소를 반복하고 DevTools에서 어떻게 작동하는지 살펴보세요. 어떤 클래스의 인스턴스가 할당되었는지 확인할 수 있어요. 메모리 - Trace Instances를 선택하고 검사하려는 클래스를 선택해주세요.\n\n![image](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_4.png)\n\n우리의 실험 결과, 10개의 ListObject 객체 인스턴스와 5개의 IterableObject 인스턴스가 할당되었어요. 사실, 나는 Iterable과 List 사이의 차이를 보여주기 위해 컬렉션의 첫 5개 요소만 반복하기로 결정했어요. 앞서 언급했듯이, Iterable은 객체가 생성되는 방법을 결정할 수 있지만 요청될 때만 생성됩니다. 반면 List는 즉시 컬렉션을 생성합니다. 따라서 전체 컬렉션을 반복한다면 차이가 없을 것입니다.\n\n특히 Iterable의 장점에도 불구하고, 이 경우에는 단점이 있어요 - 접근할 때마다 새 인스턴스가 생성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 두 번 반복해야 하는 경우 ListObject와 IterableObject 사이에 차이가 없어질 것입니다.\n\n```js\nvoid testListVsIterable() {\n  final List\u003cint\u003e sourceList = List.generate(10, (index) =\u003e index);\n\n  final List\u003cListObject\u003e intObjectList = sourceList.map((e) =\u003e ListObject(e)).toList();\n  for (var element in intObjectList.take(5)) {\n    debugPrint('$element');\n  }\n  for (var element in intObjectList.take(5)) {\n    debugPrint('$element');\n  }\n\n  final stringObjectList = sourceList.map((e) =\u003e IterableObject('$e'));\n  for (var element in stringObjectList.take(5)) {\n    debugPrint('$element');\n  }\n  for (var element in stringObjectList.take(5)) {\n    debugPrint('$element');\n  }\n}\n```\n\n![이미지](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_5.png)\n\n그리고 더 많은 횟수로 반복해야 하는 경우 List가 Iterable보다 효율적일 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 Iterable은 제가 만든 그런 인위적인 시나리오 뿐만 아니라 다른 상황에서도 유용할 수 있습니다. 앱 내에서 클래스 또는 레이어 간에 데이터를 전송해야 하는 경우, 매번 List로 변환하는 대신 Iterable을 사용하는 것을 고려해보세요. toList 메서드는 실제로 컬렉션을 반복합니다.\n\n요약하면, Iterable은 유용할 수 있지만 이로부터 이득을 얻으려고 할 때 조심해야 합니다.\n\n# 필요 없는 객체를 저장하지 마세요. 이후에도 필요하지 않을 예정이기 때문입니다.\n\n다음 권장 사항을 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문장을 확인하기 위해 몇 개의 화면을 만들었습니다. 첫 번째 화면인 AddingCounterPage는 기본적으로 설정된 것과 매우 유사한 카운터를 구현합니다. 새로운 Flutter 프로젝트를 설정할 때 기본적으로 제공되는 것과 매우 유사합니다. 이 페이지는 값에 2를 곱하는 MultiplyingCounterPage로 전파될 BehaviorSubject를 인스턴스화합니다.\n\n이러한 화면들을 앞뒤로 표시하고 메모리 뷰를 통해 메모리에 있는 개체를 확인해보겠습니다. 스트림 구독이 취소되지 않았을 때와 두 화면의 스트림 구독이 모두 취소된 경우에 대해 각각 메모리 스냅샷이 촬영되었습니다. 각 단계별로 (흐름이 나타나 있는 아래 그림의 녹색 직사각형에 이름이 표시된) 메모리 스냅샷을 비교하여 작성된 객체와 파괴된 객체가 무엇인지 이해했습니다.\n\n다음은 구독 취소 없이 진행되는 첫 번째 시나리오의 코드 일부입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass _AddingCounterPageState extends State\u003cAddingCounterPage\u003e {\n  final BehaviorSubject\u003cint\u003e counter = BehaviorSubject\u003cint\u003e.seeded(1);\n\n  @override\n  void initState() {\n    counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n  //...\n}\n\nclass _MultiplyingCounterPageState extends State\u003cMultiplyingCounterPage\u003e {\n  @override\n  void initState() {\n    widget.counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n}\n```\n\nmain-3 스냅샷에는 그들의 상태를 가진 AddingCounterPage와 MultiplyingCounterPage가 있었습니다 - 해당 시점에 메모리에 있었습니다. 구독과 관련된 여러 쌍의 객체도 있습니다. StartWithStreamTransformer, _StartWithStreamSink, _MultiControllerSink가 있습니다. 하나는 AddingCounterPage를 위한 것이고 다른 하나는 MultiplyingCounterPage를 위한 것입니다:\n\n![image](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_7.png)\n\n main-3와 main-4 스냅샷 사이에는 차이가 없습니다. MultiplyingCounterPage가 사라졌지만 모든 인스턴스가 메모리에 남아 있습니다:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Exploring Flutter App Performance Improvement Recommendations](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_8.png)\n\nAnd only after closing `AddingCounterPage`, the subscription objects were released with `AddingCounterPage` and `MultiplyingCounterPage`:\n\n![Exploring Flutter App Performance Improvement Recommendations](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_9.png)\n\nSubscription canceling should help get rid of this memory leak. We just save a `StreamSubscription` when adding the listener and cancel it when the widget is disposed:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nclass _AddingCounterPageState extends State\u003cAddingCounterPage\u003e {\n  final BehaviorSubject\u003cint\u003e counter = BehaviorSubject\u003cint\u003e.seeded(1);\n  late final StreamSubscription subscription;\n\n  @override\n  void initState() {\n    subscription = counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n  //...\n\n  @override\n  void dispose() {\n    subscription.cancel();\n    super.dispose();\n  }\n}\n\nclass _MultiplyingCounterPageState extends State\u003cMultiplyingCounterPage\u003e {\n  late final StreamSubscription subscription;\n\n  @override\n  void initState() {\n    subscription = widget.counter.listen((event) {\n      setState(() {});\n    });\n    super.initState();\n  }\n\n  //...\n  @override\n  void dispose() {\n    subscription.cancel();\n    super.dispose();\n  }\n}\n```\n\n두 번째 경우에서는 main-3 스냅샷은 이전 시나리오와 비슷한 모습이므로 여기에 추가하지 않았습니다. 그러나 main-3와 main-4 스냅샷 간의 차이점은 MultiplyingCounterPage 및 해당 구독 객체가 해제되었다는 것입니다:\n\n![이미지](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_10.png)\n\n마찬가지로, AddingCounterPage 및 해당 구독 객체는 main-5 스냅샷에서 해제되었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 실험을 통해 이 권장이 작동한다는 것을 입증했어요. 반드시 해지해야 하는 구독과 기타 해체가 필요한 객체(TextEditingController, AnimationController 등)들을 잊지 마세요. 그렇지 않으면 앱 성능에만 영향을 미칠 뿐만 아니라 프로그램 동작을 망가뜨릴 수도 있어요.\n\n# 미디어 파일 사용 최적화\n\n이미지와 비디오와 같은 미디어 파일을 다루는 것은 앱 성능에 중대한 영향을 미칩니다. 그들의 품질이 좋을수록, 메모리에서 차지하는 공간이 더 많이 필요하고 처리 및 렌더링하는 데 더 많은 시간이 필요합니다. 그들의 품질을 희생할 수 없기 때문에 일반적으로 가장 많은 리소스를 사용하는 객체들입니다. 따라서 미디어 파일 처리 방법을 최적화해야 합니다.\n\n이미지를 처리하는 방법을 최적화하는 방법은:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 대부분에 맞는 이미지 형식을 선택해보세요:\n- 사진과 같은 연속음 영상에는 JPEG를 사용합니다. 손실 압축 기능을 제공합니다.\n- GIF 및 PNG는 예리한 가장자리를 가진 이미지, 로고, 텍스트, 그래픽 및 투명성이 필요한 이미지에 적합합니다. 비손실 압축을 제공합니다.\n- JPEG와 PNG의 이점을 결합한 WebP 및 AVIF는 더 효율적인 압축을 제공합니다.\n- 로고, 텍스트 또는 아이콘과 같은 단순한 기하학적 모양에 대한 벡터 기반 그래픽용 SVG. XML 마크업으로 표현되며 품질 하락 없이 모든 해상도에서 렌더링할 수 있습니다.\n- 품질 압축은 이미지 크기를 바이트 수로 줄이는 방법입니다.\n- 손실 압축은 인치 당 픽셀 수의 이미지 해상도를 줄여 픽셀의 숫자를 줄임으로써 이미지 크기를 줄이는 것이 가능합니다. 소량의 품질 손실이 허용되는 경우 (예: 사진)에 적용됩니다.\n- 비손실 압축은 품질에 해를 입히지 않고 원래 이미지를 복원할 수 있는 이미지 인코딩을 제공합니다. 주로 의학 영상, 기술 도면 등의 보존 목적으로 더 적합합니다.\n- 높이와 너비처럼 이미지 크기인 차원을 줄입니다. 대규모 이미지를 작은 화면 (휴대전화 등)에 표시하는 것은 정보가 중복되어 있어 효율적이지 않습니다. 대규모 이미지를 작은 화면에 맞게 조정하려면 추가 계산이 필요합니다. 원하는 차원에 정확히 맞게 이미지를 조정함으로써 렌더링 프로세스를 더 효율적으로 처리할 수 있습니다.\n- 네트워크로부터 수신한 이미지를 캐싱합니다.\n\nFlutter의 이미지 최적화 기능을 살펴보겠습니다. 먼저 화면에 Image 위젯을 추가해야 합니다:\n\n```js\nImage.asset(\n  'lib/assets/landscape.jpg',\n),\n```\n\n하지만 이미지를 최적화해야 하는지 어떻게 알 수 있을까요? DevTools에는 과도한 크기의 이미지를 강조하는 옵션이 있어 항상 식별할 수 있습니다. Flutter Inspector 탭에서 해당 버튼을 클릭하여 이를 활성화할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 글로벌 매개변수를 프로그래밍 방식으로 설정하는 방법입니다:\n\n```js\ndebugInvertOversizedImages = true;\n```\n\n거대한 이미지는 색상이 반전되고 뒤집힙니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_12.png\" /\u003e\n\n로그에서 오류 메시지도 확인할 수 있습니다:\n\n```js\n이미지 lib/assets/landscape.jpg의 표시 크기는 640×360이지만 디코딩 크기는 1920×1080으로, 장치의 픽셀 비율을 2.0으로 가정하면 추가로 9600KB를 사용합니다.\n\n미리 크기를 조정하거나 cacheWidth 매개변수로 640, cacheHeight 매개변수로 360을 제공하거나 ResizeImage를 사용하는 것을 고려하십시오.\n```\n\n따라서 이미지가 비용이 많이 소비되는 자원으로 간주되는 이유는 큰 차원으로, 이는 렌더링 중에 추가 계산이 필요하다는 것을 의미합니다. 이 오류를 피하려면 cacheHeight 및 cacheWidth 매개변수를 사용해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```dart\nImage.asset(\n  'lib/assets/landscape.jpg',\n  cacheWidth: MediaQuery.of(context).devicePixelRatio.round() * MediaQuery.of(context).size.width.round(),\n),\n```\n\n여기서 cacheWidth는 디바이스 픽셀마다 논리적인 픽셀의 수인 devicePixelRatio와 화면 너비의 곱으로 계산됩니다. size.width만 사용하면 이미지가 흐릿해집니다. 이미지 품질에 대해 고려해야 합니다!\n\n![ExploringFlutterappperformanceimprovementrecommendations_13](/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_13.png)\n\n원활한 사용자 경험을 보장하기 위해 preacheImage 메서드를 사용할 수 있습니다. 이 메서드를 사용하면 위젯 초기화 또는 메인 메서드에서 이미지를 캐시에 미리 로드하여 활용할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 캐싱을 자동으로 처리해주는 Image.network 생성자를 사용하거나, cached_network_image와 같은 서드파티 라이브러리를 사용할 수도 있어요. cached_network_image는 이미지 다운로드 중에 플레이스홀더를 표시하고 요청이 실패한 경우 오류를 표시하는 기능을 제공해요.\n\n이미지 압축에 대해 이야기하자면 flutter_image_compress와 같은 플러그인을 사용할 수 있어요.\n\n전체 애플리케이션 크기에 대해 --analyze-size 명령어를 사용하여 더 명확한 그림을 얻고 최적화할 아이디어를 만들어볼 수 있어요. 코드 크기를 줄이려면 릴리스 버전을 빌드할 때 --split-debug-info를 사용하는 것이 좋아요.\n\n추가 권장 사항으로, 필요 없는 작업을 실행하지 않는 것이 중요해요. 예를 들어, Opacity와 ClipRRect을 필요할 때만 사용하고, 애니메이션에서 클리핑을 피해야 해요. 또한, 비싼 작업을 직접 메인 스레드에서 실행하지 않아야 해요. Isolate를 사용하여 UI에 영향을 주지 않도록 해야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 글에서는 플러터 앱 개발뿐만 아니라 유용한 앱 성능의 일반 원칙을 제시했습니다. 또한 DevTools를 이용한 플러터 앱 성능 개선에 대해 좀 더 자세히 살펴보았습니다. 도움이 되었으면 좋겠네요. 자세한 정보는 아래 자료 목록에서 찾을 수 있습니다.\n\n자료:\n\n- [https://docs.flutter.dev/perf](https://docs.flutter.dev/perf)\n- [https://docs.flutter.dev/tools/devtools/performance](https://docs.flutter.dev/tools/devtools/performance)\n- [플러터 성능 향상하는 방법:](https://www.youtube.com/watch?v=KH-3tbD7NoU)\n- [DevTools 깊게 들어가기:](https://www.youtube.com/watch?v=_EYk-E29edo)\n- [플러터에서 성능 및 최적화 팁 TOP 10:](https://medium.com/@slawomirprzybylski/top-10-performance-optimization-tips-in-flutter-3a4f3f31202b)\n- [플러터 성능 개선을 위한 경계 넘기기:](https://medium.com/@parthbhanderi01/raising-the-bar-for-flutter-app-performance-52418f7fa604)\n- [RepaintBoundary로 플러터 앱 성능 향상하기:](https://www.youtube.com/watch?v=Nuni5VQXARo)\n- [플러터에서 네트워크 이미지 최적화로 메모리 사용량 절약하기:](https://medium.com/make-android/save-your-memory-usage-by-optimizing-network-image-in-flutter-cbc9f8af47cd)\n- [MediaQuery와 성능 최적화의 플러터 스킬:](https://medium.com/codex/flutter-skill-of-mediaquery-and-performance-optimization-2fbf9c532fea)","ogImage":{"url":"/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_0.png"},"coverImage":"/assets/img/2024-05-20-ExploringFlutterappperformanceimprovementrecommendations_0.png","tag":["Tech"],"readingTime":19},{"title":"SwiftUI 모양으로 하는 심장 애니메이션","description":"","date":"2024-05-20 16:14","slug":"2024-05-20-SwiftUIHeartanimationwithshape","content":"\n\n\n![Heart Shape](/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png)\n\n사각형, 둥근 사각형, 원 및 캡슐은 SwiftUI에서 사용할 수 있지만 하트 모양은 제공되지 않으므로 저는 Shape Protocol을 사용하여 직접 만들었습니다.\n\n# 하트 만들기\n\n```swift\nstruct HeartShape: Shape {\n    let minX = 10\n    let centerX = 55\n    let maxX = 100\n    let minY = 10\n    let maxY = 100\n    \n    func path(in rect: CGRect) -\u003e Path {\n        Path { path in\n            path.move(to: CGPoint(x: centerX, y: maxY))\n            path.addQuadCurve(to: CGPoint(x: minX, y: 50), control: CGPoint(x: minX, y: 70))\n            path.addQuadCurve(to: CGPoint(x: centerX, y: 30), control: CGPoint(x: minX, y: minY))\n            path.addQuadCurve(to: CGPoint(x: maxX, y: 50), control: CGPoint(x: maxX, y: minY))\n            path.addQuadCurve(to: CGPoint(x: centerX, y: maxY), control: CGPoint(x: maxX, y: 70))\n            path.closeSubpath()\n        }\n    }\n}\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이곳에서 도형에 대해 더 많이 배워보세요\n\n# 애니메이션 추가\n\n```js\nimport SwiftUI\n\nstruct HeartAnimation: View {\n\n    // MARK: - Properties\n    @State private var to:CGFloat = 0\n\n    // MARK: - Body\n    var body: some View {\n        HeartShape()\n            .trim(from: 0, to: to)\n            .stroke(Color.pink, style: StrokeStyle(lineWidth: 5, lineCap: .round))\n            .frame(width: 110, height: 110)\n            .onAppear {\n                withAnimation(\n                    Animation\n                        .easeInOut(duration: 0.7)\n                        .repeatForever(autoreverses: false)) {\n                            to = 1\n                        }\n            }\n    }\n}\n```\n\n![이동](https://miro.medium.com/v2/resize:fit:590/1*_RXEvVkvqCafU2ke7Fe17Q.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n감사합니다!","ogImage":{"url":"/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png"},"coverImage":"/assets/img/2024-05-20-SwiftUIHeartanimationwithshape_0.png","tag":["Tech"],"readingTime":2},{"title":"iOS 푸시 알림 통합하기Using Swift","description":"","date":"2024-05-20 16:12","slug":"2024-05-20-IntegratingiOSPushNotificationsUsingSwift","content":"\n\n푸시 알림은 사용자 참여와 유지에 핵심적인 역할을 합니다. 사용자를 최신 상태로 유지하고 사용자가 구매로 이어지는 FOMO를 만들어내죠. 게다가 iOS에서는 Apple의 푸시 알림 서비스 (APNs)라는 추가 혜택이 있습니다. 이 서비스는 앱 서버와 사용자 장치 사이에 중개자 역할을 하면서 앱이 활성화되지 않았거나 사용자가 다른 앱을 확인하고 있어도 푸시 알림을 전달할 수 있게 해줍니다.\n\n이 기사에서는 iOS 앱에 푸시 알림을 단계별로 통합하는 방법을 살펴보고 구현의 중요한 측면을 논의하며 사용자 참여를 간소화하고 강화할 수 있는 몇 가지 제품 및 도구를 소개할 것입니다.\n\n하지만 먼저, 푸시 알림의 혜택이 무엇인가요?\n\niOS 푸시 알림은 사용자 참여, 유지 및 전체적인 사용자 경험을 개선합니다. 푸시 알림이 전략적으로 사용될 때 모바일 앱의 효과를 다양한 비즈니스 분야 전반에 크게 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 특정 목적을 위해 푸시 알림을 배포할 수 있습니다.\n\n- 사용자에게 예약 상태를 업데이트합니다.\n- 사용자가 배치한 주문에 대한 설명과 업데이트를 제공합니다.\n- 백 엔드에서 변경 사항을 사용자에게 알립니다.\n- 패키지를 추적하는 데 도움을 줍니다.\n- 앱과 관련된 이벤트에 대한 흥미를 자아내 줍니다.\n- 사용자에게 새로운 제안, 프로모션 및 기회를 소개합니다.\n- 호기심을 자극할 앱 기능을 시험해 보도록 사용자를 권장합니다.\n- 서버 업데이트 및 기타 백엔드 변경 사항을 알립니다.\n\n제때에 실행되면 푸시 알림은 iOS 사용자가 실제로 원하는 형식의 적시에 효과적인 정보를 제공하므로 우리의 전반적인 UX 및 확장 마케팅 전략에서 중요한 역할을 합니다.\n\n# iOS 알림의 구성 요소는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS 푸시 알림은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:\n\n- Apple Push Notification Service: 이것은 iOS 기기에 알림 메시지를 전달하는 데 책임을 지는 중앙 허브입니다. APNs를 활성화하려면 개발자는 유료 Apple 개발자 계정이 필요하며 앱 ID를 생성하여 Apple의 개발자 포털에서 푸시 알림을 추가로 구성해야 합니다.\n- 디바이스 토큰: 이것은 각 iOS 기기에 대해 생성된 고유 식별자입니다. APNs는 디바이스 토큰을 생성하고 알림 메시지를 토큰으로 전송하면 해당 기기에 알림이 전달됩니다. 개발자는 AppDelegate에서 푸시 알림을 위해 앱을 등록하여 이 디바이스 토큰을 얻어야 합니다.\n- 앱 서버: 앱 서버는 푸시 알림을 트리거하는 것을 담당합니다. 메시지 페이로드와 함께 APNs와 통신하고 알림 페이로드를 대상 기기로 전송합니다. 여기서는 메시지 페이로드를 관리하고 준비하고 APNs에 요청을 보내 알림 페이로드를 사용자의 기기로 전송합니다. 페이로드는 JSON 형식으로 작성됩니다.\n\n# iOS 푸시 알림 설정\n\n좋아요, 기본 내용을 다뤘습니다. 이제 Swift를 사용하여 iOS 푸시 알림 설정에 대해 좀 더 깊게 파고들어보겠습니다. 이는 Apple 개발자 포털, Xcode, 앱 서버 및 디바이스 토큰 등에서 중요한 단계를 거쳐 설정됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 앱 ID 및 프로비저닝 프로필 설정하기\n\nApple 개발자 계정을 생성했다면 Apple 개발자 포털에 로그인하여 App ID를 생성하고 푸시 알림 통합을 위해 구성할 수 있습니다.\n\nApple 개발자 포털에서 다음 단계를 따라주십시오 (참고: 소유자 또는 관리자 권한이 필요합니다).\n\n- 인증서, 식별자 및 프로필에서 식별자를 클릭합니다. 그런 다음 왼쪽 상단의 추가 버튼 (+)을 클릭합니다.\n- 옵션 목록에서 App ID를 선택하고 계속을 클릭합니다.\n- 옵션 목록에서 App ID 유형이 자동으로 선택된 것을 확인하고 계속을 클릭합니다.\n- 설명란에 App ID의 이름 또는 설명을 입력합니다.\n- 명시적 App ID를 선택하고 번들 ID 필드를 작성합니다. 여기에 입력하는 명시적 App ID는 Xcode의 타겟 요약 창에 입력한 번들 ID와 일치해야 합니다.\n- 이제 와일드카드 App ID를 선택하고 번들 ID 접미사를 번들 ID 필드에 입력합니다.\n- 사용하려는 앱 기능을 활성화하기 위해 해당 확인란을 선택합니다. 앱 및 프로그램 멤버십 유형에 따라 사용 가능한 기능은 기능 아래에 나타납니다. 확인란은 기술이 명시적 App ID를 요구하고 와일드카드 App ID를 만드는 경우에 비활성화되거나 기술이 기본적으로 활성화되어 있는 경우에 비활성화됩니다. 모든 플랫폼에 모든 기능이 적용되는 것은 아닙니다.\n- 계속을 클릭한 후 등록 정보를 검토한 다음 등록을 클릭합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 프로세스를 설명하는 비디오입니다:\n\n이제 푸시 알림 인증서를 만드는 단계를 따라 주세요:\n\n프로비저닝 프로필을 만들기 위해 다음 단계를 따를 수 있습니다:\n\n- Apple 개발자 포털을 엽니다.\n- iOS Dev 대시보드에서 Certificates, Identifiers \u0026 Profiles을 클릭합니다.\n- 개발자 대시보드에서 Profiles을 클릭하고 +를 클릭합니다.\n- iOS 앱 개발을 선택하고 계속을 클릭합니다.\n- 프로비저닝 프로필과 연결할 앱 ID를 선택하고 계속을 클릭합니다. 여러 앱에서 하나의 개발 프로비저닝 프로필을 사용하려면 가능한 경우 와일드카드 App ID를 선택하세요.\n- 프로비저닝 프로필에 포함할 하나 이상의 개발용 인증서를 선택하고 계속을 클릭합니다. 개발용 인증서만 나열됩니다.\n- 프로비저닝 프로필에 포함할 하나 이상의 장치를 선택하고 계속을 클릭합니다.\n- 프로필에 의미 있는 이름을 입력하고 생성을 클릭합니다.\n- 다운로드를 클릭하여 프로비저닝 프로필을 다운로드하고 Xcode에서 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Xcode 설정 구성하기\n\nXcode 프로젝트 설정에서 App ID를 사용해야 합니다. 이를 통해 푸시 알림이 활성화되고 프로비저닝 프로필을 활용할 수 있습니다.\n\n또한 프로젝트 설정의 기능(capabilities)에서 푸시 알림을 활성화해야 합니다.\n\n푸시 알림 기능을 활성화한 후에는 AppDelegate 파일에 푸시 알림 코드를 구현해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알림: 먼저 UserNotifications 프레임워크를 가져와야 합니다.\n\n```js\nimport UserNotifications\n```\n\n이제 사용자의 승인을 요청하여이 앱의 푸시 알림을 활성화해야합니다. UNUserNotificationCenter 클래스의 requestAuthorization 메서드를 사용할 수 있습니다.\n\n```js\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u003e Bool {\n    // 다른 설정 코드\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 알림 권한 요청\nUNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in\n    if granted {\n        print(\"알림 권한이 허용되었습니다\")\n        // 이제 알림을 예약하고 보낼 수 있습니다\n    } else {\n        print(\"알림 권한이 거부되었습니다\")\n        // 사용자가 알림 권한을 거부한 경우 처리\n    }\n}\nreturn true\n```\n\n사용자의 푸시 알림 권한 팝업에 대한 반응에 따라 '허용' 및 '거부된 액세스' 상황을 처리해야 합니다.\n\n# 원격 알림 등록\n\n원격 알림을 등록하려면 UIApplication의 registerForRemoteNotifications() 메서드를 호출해야 합니다. 앱의 AppDelegate에서 이를 호출하여 원격 알림을 등록하고 기기 토큰을 받아옵니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n```\n\n```swift\n    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u003e Bool {\n        // 알림 권한 요청\n        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge]) { granted, error in\n            if granted {\n                print(\"알림 권한 허용됨\")\n                // 원격 알림 등록\n                DispatchQueue.main.async {\n                    application.registerForRemoteNotifications()\n          UNUserNotificationCenter.current().delegate = self\n                }\n            } else {\n                print(\"알림 권한 거부됨\")\n                // 사용자가 알림 권한을 거부한 경우 처리\n            }\n        }\n        return true\n    }\n}\n```\n\n# 기기 토큰 등록 처리\n\n애플리케이션을 통해 알림을 등록한 후, 기기 토큰을 얻어야 합니다. 이는 사용자 기기를 식별하여 나중에 서버에서 알림을 보낼 수 있게 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예시에서는 성공적 및 실패적인 기기 등록 방법을 구현했습니다. 등록이 올바르게 작동하면 기기 토큰을 얻게 되며, 이후 서버로 해당 사용자에게 저장할 수 있도록 전송해야 합니다. 기기 토큰이 없으면 이 기기로 알림을 보낼 수 없습니다.\n\n# 원격 알림 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기기 토큰을 받은 후에는 앱이 알림을 수신할 준비가 되었습니다. 이제 서버로부터 수신되는 알림을 처리하기 위한 관련 메서드를 구현해야 합니다. 이러한 메서드는 앱의 상태에 기반하며, 앱이 전경 또는 배경에서 작동하는지에 따라 다를 것입니다.\n\n만약 앱이 전경에서 실행 중이라면\n\n여기서는 앱이 전경에서 실행 중일 때 푸시 알림을 처리하는 메서드를 구현하고 있습니다:\n\n```swift\nextension AppDelegate: UNUserNotificationCenterDelegate {\n    // 앱이 전경에서 실행 중일 때 알림을 처리\n    func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification, withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -\u003e Void) {\n        // 알림 표시를 처리합니다\n        completionHandler([.alert, .sound, .badge])\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱이 활성 상태로 실행 중인 경우, iOS는 알림을 알림 센터에 표시하지 않습니다. 대신, 앱으로 알림을 직접 전달할 것입니다. 사용자에게 경고를 표시하려면 코드를 작성해야 합니다.\n\n만약 앱이 백그라운드에서 실행 중인 경우,\n앱이 실행 중이 아닐 때 알림을 처리하려면 다음 메소드를 구현해야 합니다.\n\n```swift\n// 앱이 백그라운드에서 실행 중일 때 원격 알림 수신 처리\nfunc application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable: Any], fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -\u003e Void) {\n    // 받은 원격 알림 처리\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n    // 푸시 알림 페이로드를 출력합니다\n    print(\"원격 알림 수신: \\(userInfo)\")\n    // 알림 콘텐츠 처리\n    if let aps = userInfo[\"aps\"] as? [String: Any], let alert = aps[\"alert\"] as? String {\n        // 알림 페이로드에서 정보 추출\n        print(\"알림 메시지: \\(alert)\")\n    }\n    // 백그라운드 페치 작업 결과를 시스템에 알립니다\n    completionHandler(UIBackgroundFetchResult.newData)\n}\n```\n\n이 방법을 사용하면 알림을 수신한 후에 해당 알림을 처리하고 조치를 취할 수 있습니다.\n\n이제, 사용자가 알림을 탭하면 앱이 열립니다. 이 경우, 앱은 알림과의 상호 작용으로 열렸는지 여부를 감지하고 해당 작업을 수행할 수 있습니다. 특정 뷰 컨트롤러로 이동하는 등의 작업을 수행할 수 있습니다.\n\n# 앱 서버에서 알림 보내기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버에 저장된 디바이스 토큰을 사용하여 특정 디바이스로 알림을 보내려면 백엔드 서버에 코드를 구현해야 합니다. 이 코드는 애플 푸시 알림 서버로 요청을 트리거하고 해당 디바이스로 알림을 전송합니다.\n\nNode.JS에서 푸시 알림을 보내는 다음 코드를 사용할 수 있습니다:\n\n```js\nnpm install apn\n```\n\n```js\nconst apn = require('apn');\n// 자격 증명으로 APNs를 구성\nconst apnProvider = new apn.Provider({\n  token: {\n    key: 'path/to/APNsAuthKey.p8',  // APNs Auth Key의 경로\n    keyId: 'YourKeyID',\n    teamId: 'YourTeamID',\n  },\n  production: false,  // 운영 환경에 대해 true로 설정\n});\n// 알림 페이로드 생성\nconst notification = new apn.Notification({\n  alert: 'Hello Bugfender Testing!',\n  sound: 'default',\n  badge: 1,\n});\n// 대상 디바이스의 디바이스 토큰 지정\nconst deviceToken = 'xxxx';  // 실제 디바이스 토큰으로 대체\n// 알림 보내기\napnProvider.send(notification, deviceToken).then(result =\u003e {\n  console.log('알림을 보냈습니다:', result);\n}).catch(error =\u003e {\n  console.error('알림 보내기 오류:', error);\n});\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`table` 태그를 Markdown 형식으로 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 JSON 페이로드의 예시를 살펴봅시다:\n\n```js\n{\n  \"aps\": {\n    \"alert\": {\n      \"title\": \"Notification Title\",\n      \"body\": \"Notification Body\"\n    },\n    \"badge\": 1,\n    \"sound\": \"default\"\n  },\n  \"customKey\": \"Custom Value\" //원하는 사용자 지정 데이터나 객체\n}\n```\n\n예시에서 보듯이, 페이로드에는 customKey가 있습니다. 앱으로 보낼 알림과 관련된 모든 정보를 전달하고 필요한 작업을 수행하기 위해 필요한 만큼 많은 사용자 지정 키를 추가할 수 있습니다.\n\n크기 제한을 유의하십시오. 페이로드는 JSON 객체여야 하며 최대 크기 제한이 4KB입니다. 이 제한은 알림 전달에 문제가 없도록 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 조용한 알림\n\n조용한 알림을 보내고 싶다면 경고, 뱃지 및 사운드 키 없이 페이로드를 보내야 합니다. 조용한 알림을 사용하면 사용자에게 알리지 않고 앱에서 작업을 실행할 수 있습니다. 이러한 종류의 알림에 대한 몇 가지 사용 사례는 다음과 같습니다:\n\n- 백그라운드 데이터 새로고침: 서버에서 앱을 갱신하도록 알림을 트리거하여 사용자가 앱을 열 때 항상 최신 데이터를 받을 수 있습니다.\n- 분석: 앱을 강제로 분석 데이터 업데이트를 서버로 보내도록 하기 위해 조용한 알림을 사용할 수 있습니다. 이에는 어플 사용 통계 또는 진단 정보가 포함됩니다.\n- 데이터 동기화: 여러 장치에서 사용할 수 있는 앱이 있는 경우, 하나의 앱에서 변경이 발생하면 데이터 동기화를 강제할 수 있습니다.\n\n다음은 조용한 알림의 편리한 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n    \"aps\": {\n        \"content-available\": 1,\n        \"priority\": \"5\"\n    },\n    \"updateType\": \"newArticles\",\n    \"timestamp\": \"2024-01-12T10:00:00Z\"\n}\n```\n\n# 푸시 알림 로컬라이제이션\n\n서버에서 사용자의 선호 언어를 추적하면 다른 언어로 로컬라이즈된 알림 키를 보낼 수 있습니다.\n\n# 지역 알림\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS 로컬 알림은 특별한 분류로, 어플리케이션이 서버와 독립적으로 특정 시간에 또는 특정 이벤트에 응답하여 알림을 자체적으로 예약하는 것을 가능케 합니다. 이러한 알림은 알림, 캘린더 이벤트 또는 유사한 시나리오에 매우 유용합니다. 이를 작동시키려면 원격 푸시 알림과 마찬가지로 사용 권한을 요청해야 합니다.\n\n로컬 알림을 만드는 예시를 살펴봅시다:\n\n```js\nimport UserNotifications\n```\n\n```js\n// 알림 콘텐츠 생성\nlet content = UNMutableNotificationContent()\ncontent.title = \"리마인더\"\ncontent.body = \"새로운 업데이트를 확인하는 걸 잊지 마세요!\"\ncontent.sound = UNNotificationSound.default\n// 반복 이벤트로 트리거 생성\nlet trigger = UNTimeIntervalNotificationTrigger(timeInterval: 60, repeats: false)\n// 요청 생성\nlet uuidString = UUID().uuidString\nlet request = UNNotificationRequest(identifier: uuidString, content: content, trigger: trigger)\n// 시스템에 요청 등록\nUNUserNotificationCenter.current().add(request) { error in\n   if let error = error {\n       print(\"알림 일정 예약 에러: \\(error)\")\n   }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 푸시 알림을 테스트하고 실제 장치로 전송해보기\n\n푸시 알림을 성공적으로 통합한 후에는 푸시 알림 코드를 제대로 테스트하기 위해 앱을 실제 장치나 시뮬레이터(이미 Xcode 11.4 버전부터 제공되고 있습니다)에서 실행해야합니다.\n\n이전에 얻은 장치 토큰으로 서버 또는 Pusher와 같은 온라인 도구를 사용하여 테스트 알림을 전송할 수 있습니다.\n\n거기에 그치지 않아요: 서버나 도구에서 보낸 알림이 장치로 제대로 수신되었는지 확인할 수도 있고, 앱에서 구현한 경우 알림의 처리 및 리디렉션을 확인할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시뮬레이터에서 알림을 테스트하는 단계:\n\n- 시뮬레이터 장치를 선택하고 앱을 실행합니다.\n- Xcode에서 Features 메뉴로 이동하고 Push Notifications을 선택합니다.\n- 미리 정의된 알림을 선택하거나 사용자 정의 payload를 생성합니다.\n- Xcode에서 Run 버튼을 클릭합니다.\n\n알림을 보내기:\n\n다음 curl을 사용하여 테스트 푸시 알림을 보낼 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\ncurl --header \"apns-topic: your.bundle.identifier\" \\\\\n     --header \"apns-push-type: alert\" \\\\\n     --header \"authorization: bearer YOUR_AUTH_KEY\" \\\\\n     --data '{\"aps\": {\"alert\": {\"title\": \"Notification Title\", \"body\": \"Notification Body\"}, \"sound\": \"default\", \"badge\": 1}' \\\\\n     --http2 \\\\\n     --cert /path/to/your/certificate.pem \\\\\n     --cert-type PEM \\\\\n     --key /path/to/your/private-key.pem \\\\\n     \u003chttps://api.push.apple.com/3/device/YOUR_DEVICE_TOKEN\u003e\n```\n\n- 애플리케이션의 환경에 맞는 올바른 APNs 엔드포인트를 사용하는지 확인해야 합니다 (운영 환경의 경우 api.push.apple.com 또는 개발 환경의 경우 api.development.push.apple.com).\n- apns-push-type 및 apns-topic 헤더는 필수입니다.\n- 인증서와 개인 키가 PEM 형식으로 올바르게 포맷되어 있는지 확인하세요.\n\n# 푸시 알림 지원 제품\n\niOS 애플리케이션에서 푸시 알림을 쉽게 통합하고 테스트할 수 있는 여러 서드 파티 서비스 및 도구가 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 서비스들은 타겟팅된 메시지 전송, 분석 및 기타 기능을 포함하여 전체 푸시 알림 경험을 향상시키고 데이터를 분석하기 위한 다양한 기능을 제공합니다. 여기 몇 가지 주목할만한 제품들이 있습니다:\n\n- Firebase Cloud Messaging (FCM): 구글에서 제공하는 FCM은 iOS, Android 및 웹 앱에서 메시지를 신뢰성 있게 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다.\n- OneSignal: OneSignal은 다중 플랫폼을 지원하는 인기 있는 푸시 알림 서비스입니다. 고급 타겟팅, A/B 테스트, 앱 내 메시징 및 실시간 분석을 제공합니다.\n- Pusher Beams: Pusher Beams는 iOS 및 Android 기기로 푸시 알림을 전송할 수 있는 푸시 알림 API입니다.\n- Amazon Simple Notification Service (SNS): SNS는 AWS의 잘 관리되는 메시징 서비스로, 푸시 알림을 지원합니다. iOS 기기를 포함한 다양한 엔드포인트로 메시지를 보낼 수 있으며, 메시지 형식에 대해 유연성을 제공합니다.\n- Airship: Airship은 푸시 알림, 앱 내 메시징 및 자동화 기능을 포함한 모바일 참여 플랫폼을 제공합니다.\n- Pushwoosh: Pushwoosh는 다양한 플랫폼을 지원하는 푸시 알림 서비스입니다. 사용자 정의 푸시 알림, 지오 타겟팅, 그리고 실시간 분석과 같은 다양한 기능을 제공합니다.\n- IBM Push Notifications: IBM Push Notifications은 IBM 클라우드 서비스 중 하나로, iOS 및 기타 플랫폼으로 푸시 알림을 전송하는 확장 가능한 솔루션을 제공합니다.\n- CleverTap: CleverTap은 푸시 알림, 앱 내 메시징 및 사용자 참여 도구를 포함한 포괄적인 모바일 마케팅 플랫폼입니다.\n\n# iOS 푸시 알림 FAQ\n\n# iOS에서 푸시 알림이란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS에서의 푸시 알림은 서버에서 iOS 기기로 전송되는 짧은 메시지로, 사용자에게 기기에 설치된 앱과 관련된 새로운 정보, 업데이트 또는 이벤트를 알리는 데 사용됩니다. 이러한 알림은 사용자의 기기로 직접 전달되며, 앱이 실행되지 않은 상태에서도 받을 수 있습니다.\n\n# 사용자가 iOS에서 푸시 알림을 제어할 수 있나요?\n\n네, iOS 사용자는 어떤 앱이 푸시 알림을 보낼 수 있는지와 알림이 어떻게 표시되는지를 제어할 수 있습니다. 사용자는 iOS 설정 앱에서 알림 설정을 관리할 수 있으며, 특정 앱에 대한 알림을 활성화 또는 비활성화할 수 있고, 알림 스타일을 사용자 정의하거나 푸시 알림이 처리되는 방식을 제어할 수 있습니다.\n\n# 푸시 알림은 텍스트만으로 제한되나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, iOS의 푸시 알림은 풍족한 미디어를 포함할 수 있어요. iOS 개발자로서, 이미지, 소리 및 기타 상호 작용 항목을 포함할 수 있는 풍족한 푸시 알림을 보낼 수 있는 옵션이 있어요. 개발자와 마케터가 사용자의 관심을 더 잡을 수 있는 시각적으로 매력적인 알림을 만들 수 있게 해줘요.\n\n# 푸시 알림을 받으려면 인터넷 연결이 필요한가요?\n\n대부분의 경우 iOS 기기에서 푸시 알림을 받으려면 인터넷 연결이 필요해요. 사용자의 기기로 푸시 알림이 전송될 때, 이는 셀룰러 연결을 통해 전달되어요. 한 가지 예외가 있어요: 로컬 알림은 기기 자체에서 처리되므로 인터넷 연결 없이도 표시될 수 있어요.\n\n# 모든 iOS 기기에서 푸시 알림이 지원되나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 모든 iOS 기기에서 푸시 알림을 지원합니다. iPhone 및 iPad를 포함한 모든 기기에서 작동합니다. 해당 기기가 호환되는 iOS 버전을 실행 중이고 사용자가 해당 앱의 알림을 허용한 경우, 모든 iOS 기기에서 푸시 알림을 보내고 받을 수 있습니다.\n\n# iOS 푸시 알림을 보내는 데 비용이 드나요?\n\n푸시 알림을 보내는 것은 일반적으로 무료입니다. 그러나 알림을 관리하기 위해 제3자 서비스를 사용하면 프로젝트의 기능 및 규모에 따라 비용이 발생할 수 있습니다.\n\n# 요약하자면\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 단계와 원칙을 결합하여 개발자들은 사용자 만족도, 참여도 및 모바일 애플리케이션 전반적인 성공을 위한 동적이고 효과적인 알림 전략을 만들 수 있습니다.\n\n본 문서에서는 푸시 알림의 통합에 대한 완벽한 단계별 가이드를 제공했습니다. 앱 ID 구성부터 Xcode의 자세한 설정, 잘 구조화된 알림 페이로드 생성 및 iOS 앱에서 푸시 알림 테스트까지 다룹니다.\n\n푸시 알림 서비스를 선택하는 데 도움이 필요하다면, 손쉬운 통합, 플랫폼 지원, 확장 가능성, 분석 기능 및 가격 등의 다양한 요소를 고려해야 합니다. 각 제3자 서비스는 강점이 있으며 선택은 귀하의 요구 사항과 선호도에 따라 다릅니다.\n\n즐겁게 코딩하세요!","ogImage":{"url":"/assets/img/2024-05-20-IntegratingiOSPushNotificationsUsingSwift_0.png"},"coverImage":"/assets/img/2024-05-20-IntegratingiOSPushNotificationsUsingSwift_0.png","tag":["Tech"],"readingTime":14}],"page":"70","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"70"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>