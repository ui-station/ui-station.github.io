<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/29" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/29" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="루비 커맨드 라인 옵션을 다루는 OptionParser 사용 사례와 함께" href="/post/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비 커맨드 라인 옵션을 다루는 OptionParser 사용 사례와 함께" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비 커맨드 라인 옵션을 다루는 OptionParser 사용 사례와 함께" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비 커맨드 라인 옵션을 다루는 OptionParser 사용 사례와 함께</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프럼, 루비, 레일즈, 그리고 OS X" href="/post/2024-06-19-FrumRubyRailsandOSX"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프럼, 루비, 레일즈, 그리고 OS X" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FrumRubyRailsandOSX_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프럼, 루비, 레일즈, 그리고 OS X" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">프럼, 루비, 레일즈, 그리고 OS X</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새 프로그래밍 언어를 배울 때입니다" href="/post/2024-06-19-ItsTimeforaNewProgrammingLanguage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새 프로그래밍 언어를 배울 때입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-ItsTimeforaNewProgrammingLanguage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새 프로그래밍 언어를 배울 때입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">새 프로그래밍 언어를 배울 때입니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비로 LLM-파워 어플리케이션 만들기" href="/post/2024-06-19-BuildingLLM-poweredapplicationsinRuby"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비로 LLM-파워 어플리케이션 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비로 LLM-파워 어플리케이션 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비로 LLM-파워 어플리케이션 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내" href="/post/2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비를 잘 몰라요 더 이상" href="/post/2024-06-19-YouDontKnowRubyAnymore"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비를 잘 몰라요 더 이상" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-YouDontKnowRubyAnymore_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비를 잘 몰라요 더 이상" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비를 잘 몰라요 더 이상</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CodeCademy 2024 학생 및 개발자를 위한 50 할인" href="/post/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CodeCademy 2024 학생 및 개발자를 위한 50 할인" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CodeCademy 2024 학생 및 개발자를 위한 50 할인" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">CodeCademy 2024 학생 및 개발자를 위한 50 할인</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭" href="/post/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="비동기 로깅 자바 앱에 제공되는 속도 향상" href="/post/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="비동기 로깅 자바 앱에 제공되는 속도 향상" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="비동기 로깅 자바 앱에 제공되는 속도 향상" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">비동기 로깅 자바 앱에 제공되는 속도 향상</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 HashSet 초보자가 꼭 알아야 할 내용" href="/post/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 HashSet 초보자가 꼭 알아야 할 내용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 HashSet 초보자가 꼭 알아야 할 내용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 HashSet 초보자가 꼭 알아야 할 내용</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link posts_-active__YVJEi" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"루비 커맨드 라인 옵션을 다루는 OptionParser 사용 사례와 함께","description":"","date":"2024-06-19 10:24","slug":"2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase","content":"\n\n터미널에서 실행하는 간단한 응용 프로그램이나 스크립트를 명령줄 응용 프로그램이라고 합니다. 대부분의 경우, 명령줄 응용 프로그램을 사용할 때는 옵션과 인수를 사용하여 상호 작용해야 합니다.\n\n이 문서에서는 명령줄 옵션과 인수를 처리하기 위해 루비 OptionParser를 사용하는 방법을 배우게 될 것입니다. 간단한 사용 사례로도 배워보겠습니다.\n\n# 목차\n\n- 사용 사례\n- 디자인 구매\n- OptParse 동작\n- 결론\n- 참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사용 사례\n\n더 잘 이해하기 위해 간단한 사용 사례로 학습하겠습니다. 아래는 우리의 루비 스크립트에 대한 요구사항 목록입니다:\n\n- 이 스크립트는 3rd party 웹사이트로부터 데이터를 수집하는 scrapper.rb라고 불립니다.\n- 주어진 URL을 기반으로 데이터를 수집할 수 있어야 합니다.\n- verbose 옵션을 사용하여 데이터를 수집할 수 있지만, 이는 선택 사항입니다.\n- 수집된 데이터를 JSON 및 CSV로 내보낼 수 있어야 합니다.\n- 결과를 출력하기 위해 내보내기 또는 미내보내기를 사용할 수 있어야 합니다.\n- 짧은 이름 및 긴 이름 옵션을 사용할 수 있어야 합니다.\n- 필수 매개변수는 --target-url뿐입니다.\n- 사용 가능한 옵션과 매개변수를 확인하기 위해 --help 옵션을 사용할 수 있어야 합니다.\n\n# 디자인 구매하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 요구사항에 따라 아래와 같은 디자인이 완성되었습니다:\n\n![Ruby Command-line options using OptionParser With Use Case](/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_0.png)\n\n우리는 루비 스크립트를 scrapper.rb라는 이름으로 지었습니다. 선택적 옵션, 필수 옵션, 선택적 인자를 가지고 있음을 보실 수 있습니다. 그리고 가장 중요한 것은 사용 가능한 스크립트 옵션 목록을 표시하기 위해 --help 옵션을 구현해야 합니다.\n\n옵션 파서를 사용하여 처리하는 방법을 살펴보겠습니다. 정말로 생각보다 간단합니다 :))\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# OptionParser 활용하기\n\n위에서 설계한 내용을 OptionParser로 구현해봅시다.\n\n## ARGV\n\n시작하기 전에, 루비에는 명령행 옵션과 인수를 가져오기 위한 ARGV가 있습니다. 이는 우리 프로그램에서 배열로 출력됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_1.png)\n\n6번 라인을 살펴보세요. 옵션과 인자를 사용하여 스크립트를 실행하면 모든 값을 배열 값으로 출력합니다.\n\n```js\n➜ ruby scrapper.rb --name MyName --age 10\n[\"--name\", \"MyName\", \"--age\", \"10\"]\n```\n\nARGV에 대해 더 많이 알고 싶다면 [이 링크](https://link-to-more-info-about-ARGV)를 확인하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기본 설정 및 도움말 옵션\n\noptparse를 설정하고 --hello와 같은 샘플 옵션을 추가하여 스크립트가 제대로 작동하는지 확인합니다.\n\n![이미지](/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_2.png)\n\n긴 줄을 추가한 것 처럼 보여서 놀랐죠! 그러나 optparse를 사용할 때 기본 구조를 보여주는 것입니다. 자세한 내용은 아래와 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- line 1: optparse를 사용하려면 반드시 요구해야 합니다.\n- line 10: parser로 OptionParser 객체를 초기화합니다.\n- line 13: hello라는 간단한 옵션을 추가합니다. --hello로 사용할 수 있고 부울 값으로 반환됩니다.\n- line 16–17: options라는 빈 해시를 생성하고 17번째 줄에서 파싱 결과를 할당합니다.\n\n이제 scrapper.rb를 실행할 때 --help 및 --hello를 사용할 수 있습니다.\n\n```js\n➜ ruby scrapper.rb --hello\n[]\n{:hello=\u003etrue}\n\n➜ ruby scrapper.rb --help\nUsage: scrapper [options]\n        --hello                      hello world from parser\n```\n\n보시는 대로, --help를 사용하면 13번째 줄의 설명을 기반으로 명령 설명이 출력됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 맞아요. optparse은 자동으로 우리를 위해 --help 옵션을 만들어 줄 거에요.\n\n## 대상 URL\n\n--hello 옵션을 제거하고 라인 12를 사용해서 대체해요. 우리는 Short Name과 Long Name을 사용하고 필수 인자를 가진 옵션을 추가해요.\n\n![이미지](/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테스트해보세요:\n\n```js\n➜ ruby scrapper.rb --target-url\nscrapper.rb:17:in `\u003cmain\u003e': missing argument: --target-url (OptionParser::MissingArgument)\n\n➜ ruby scrapper.rb -t\nscrapper.rb:17:in `\u003cmain\u003e': missing argument: -t (OptionParser::MissingArgument)\n\n➜ ruby scrapper.rb --target-url https://MyTargetUrl\n[]\n{:\"target-url\"=\u003e\"https://MyTargetUrl\"}\n\n➜ ruby scrapper.rb -t https://MyTargetUrl\n[]\n{:\"target-url\"=\u003e\"https://MyTargetUrl\"}\n```\n\n## 내보내기\n\n내보내기를 위해 `[no]export`라는 새로운 옵션을 추가했습니다. 이 옵션의 값은 부울(boolean)입니다. 이것은 스크립트에서 `--export` 및 `--no-export` 옵션이 사용 가능하게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_4.png\" /\u003e\n\n테스트해보세요:\n\n```js\n➜ ruby scrapper.rb --export\n[]\n{:export=\u003etrue}\n\n➜ ruby scrapper.rb --no-export\n[]\n{:export=\u003efalse}\n```\n\n## 형식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 스크립트는 출력 형식 지원을 하며, JSON 및 CSV 형식만 지원합니다.\n\n이 경우를 처리하려면 명시적인 값을 사용해야 합니다. 간단히 [‘JSON’, ‘CSV’]를 추가하면 됩니다. 저희 스크립트는 정의된 명시적인 값만 허용할 것입니다.\n\n이와 관련된 자세한 내용은 아래 이미지를 참고해 주세요.\n\n![이미지](/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_5.png)\n\n테스트해 보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n➜ ruby scrapper.rb --format HTML\nscrapper.rb:19:in `\u003cmain\u003e': 올바르지 않은 인수입니다: --format HTML (OptionParser::InvalidArgument)\n\n➜ ruby scrapper.rb --format\nscrapper.rb:19:in `\u003cmain\u003e': 인수가 누락되었습니다: --format (OptionParser::MissingArgument)\n\n➜ ruby scrapper.rb --format JSON\n[]\n{:format=\u003e\"JSON\"}\n\n➜ ruby scrapper.rb -f JSON\n[]\n{:format=\u003e\"JSON\"}\n\n\n## 상세모드\n\n마지막으로 --verbose라는 옵션이 있으면 15번 라인에 이것을 추가하세요.\n\n![Ruby Command Line Options Using OptionParser with Use Case](/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_6.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 내용을 테스트해보세요:\n\n```js\n➜ ruby scrapper.rb -v\n[]\n{:verbose=\u003etrue}\n\n➜ ruby scrapper.rb --verbose\n[]\n{:verbose=\u003etrue}\n```\n\n## 도움말\n\n위에서 언급한대로, OptionParser는 자동으로 --help 옵션을 위한 명령어를 만들어줍니다. 스크립트를 업데이트하여 --help 옵션을 처리할 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종 도움말 출력을 확인해 봅시다.\n\n```js\n➜ ruby scrapper.rb --help\nUsage: scrapper [options]\n    -t, --target-url VALUE           데이터를 가져올 대상 URL입니다.\n        --[no-]export                데이터를 내보내려면 'export'를 사용하고, 터미널 출력만 되도록 하려면 'no-export'를 사용합니다.\n    -f, --format VALUE               JSON 또는 CSV로 출력 형식을 정의합니다.\n    -v, --verbose                    출력을 자세하게 설정합니다.\r\n```\n\n## 배너\n\n터미널에서 더 나은 출력 메시지를 위해 parser.banner를 사용할 때, 프리 텍스트로 배너 값을 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_7.png)\n\nTry it out:\n\n```js\n➜ ruby scrapper.rb --help\n사용법: scrapper.rb [options]\n    -t, --target-url VALUE           데이터를 가져올 대상 URL입니다.\n        --[no-]export                데이터를 내보내려면 'export', 터미널 출력만을 원하면 'no-export'를 사용하십시오.\n    -f, --format VALUE               JSON 또는 CSV로 출력 형식을 정의합니다.\n    -v, --verbose                    출력을 상세하게 설정합니다.\n```\n\n# 결론\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루비에는 많은 강력한 기능들이 있어요. 이 경우에는 옵션 파서를 사용하여 명령행 옵션과 인수를 다루고 있어요.\n\n이 글이 도움이 되었으면 좋겠어요. 읽어 주셔서 감사합니다.\n\n루비 친구들, 즐거운 하루 보내세요! 💎\n\n# 참고문헌","ogImage":{"url":"/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_0.png"},"coverImage":"/assets/img/2024-06-19-RubyCommand-lineoptionsusingOptionParserWithUseCase_0.png","tag":["Tech"],"readingTime":6},{"title":"프럼, 루비, 레일즈, 그리고 OS X","description":"","date":"2024-06-19 10:21","slug":"2024-06-19-FrumRubyRailsandOSX","content":"\n\n## OpenSSL 3를 찾아서\n\n몇 년 전에 러스트로 작성된 루비 버전 관리자인 Frum을 발견했습니다.\n\n빠르고 긍정적인 면에서는 실용적입니다. 필요 없는 기능은 없으면서 잘 유지되고 있습니다.\n\n그래서 Apple 실리콘 기반 OS X Sonoma에서 내 설정을 업데이트한 것을 보여드릴게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 홈브루를 설치해주세요. 이미 설치되어 있지 않다면, 아래 좋은 설치 가이드를 읽어보세요\n- 레일즈 설정에 유용한 몇 가지 라이브러리를 설치해주세요: brew install readline libyaml openssl nvm\n- 노드 설치하기 nvm install 22 (노드 버전 22가 최신 버전이었지만, 프로젝트에 필요한 버전으로 맞춰서 선택할 수 있어요)\n- 다음 명령어 실행하기 frum install 3.3.3 --with-openssl-dir=$(brew --prefix openssl@3) --with-libyaml-dir=$(brew --prefix libyaml)\n- .zprofile 또는 .zshrc에 다음 추가하기: eval “$(frum init)”\n\n그리고 와! 최신 openssl을 활용한 작동 중인 루비 3.3(.3)를 사용하게 되었어요.\n\nSSL 관련 문제가 있으면 안 되니까, 제 설정에는 버전 1로 다운그레이드하는 것은 선택지가 아니었어요.\n\n마지막으로, 이제 gem install rails을 실행하여 레일즈를 설치할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-19-FrumRubyRailsandOSX_0.png"},"coverImage":"/assets/img/2024-06-19-FrumRubyRailsandOSX_0.png","tag":["Tech"],"readingTime":1},{"title":"새 프로그래밍 언어를 배울 때입니다","description":"","date":"2024-06-19 10:21","slug":"2024-06-19-ItsTimeforaNewProgrammingLanguage","content":"\n\n\n![New Programming Language](/assets/img/2024-06-19-ItsTimeforaNewProgrammingLanguage_0.png)\n\n요즘은 프로그래밍 언어의 역사에서 다른 모든 시점과 비교할 때 선택의 여지가 많아서 선택 장애를 느낍니다. 언어 디자인의 발전, LLVM과 같은 도구 상자, 인터넷을 통한 프로그래밍의 민주화, 그리고 많은 다른 요인들이 새로운 언어들의 황금 시대로 이끌고 있습니다. 매주 Zig, Deno, Nim, Rust, Flutter, Kotlin, Go, Crystal, Carbon 등 많은 새로운 언어가 인기를 얻는 것을 볼 수 있습니다. 그러나 실제로 사용되는 언어들을 조사해 보면, 대부분 계속해서 JavaScript, TypeScript, Python, Java, Ruby, PHP 등 평범한 언어들이 사용되고 있습니다. 이에 대한 이유는 새로운 언어들이 항상 등장하지만, 일부는 혁신적인 디자인 결정이나 기본 기능을 갖추고 있더라도, 그중에서 심각한 제품 수준의 작업과 아키텍처를 위해 설계된 것이 거의 없다는 것입니다. 저는 그것들을 '장난감 언어'라고 부르기는 싫지만, Deno나 Crystal 같은 언어로 작동하는 심각한 제품 서비스가 곧 나올 것으로 생각되지는 않습니다.\n\n\"그러면 평범한 언어들에 무엇이 문제인가요?\" 라고 물어볼 수도 있습니다.\n\n그런데 그것은 정말 좋은 질문일 것입니다. 솔직히 말해서, 문제는 그들이 무엇이 잘못됐는지보다는, 어떻게 현재의 아키텍처와 생태계에 적합하며 어떤 종류의 작업을 수행할지입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자바스크립트, 타입스크립트, 노드JS, 커피스크립트 등\n\n자바스크립트는 프로그래밍 언어의 인간을 흉내 내려는 비명쳐 옷을 입은 세 마리 너구리입니다. 1995년 처음 등장한 이후에 계속해서 추가된 모든 기능은 그때의 디자인에는 고려되지 않았던 것들 같아요. 자바스크립트 안에서 모든 일을 수행하는 방법은 일반적으로 세 가지에서 여덟 가지까지 다양하며, 각각의 방법은 특이한 부작용과 위험을 가지고 있어요. 이 고대의 심연마법을 다뤄야 하는데, 이것은 V8 엔진의 물에서 세례를 받지 않은 사람에게는 자바스크립트를 효율적이고 효과적으로 작성하기 어렵게 만들어요. 프론트엔드와 백엔드 작업을 동일한 언어로 수행하는 아이디어는 좋은 아이디어로 들릴 수 있지만, 실제로 프론트엔드와 백엔드가 공통으로 가지고 있는 것은 기본 구문과 불필요한 3rd-party NPM 패키지를 사랑하는 것뿐이에요.\n\n노드JS, 타입스크립트, 커피스크립트 등 자바스크립트에서 파생된 다른 언어 또는 변형도 이 역시 같은 원리에 따라 작동합니다. 그들도 결국 다른 너구리를 추가하고 있죠.\n\n그리고, 자바스크립트가 얼마나 엉망인지 못 믿겠다면, 이 놀라운 번개 토크를 보세요: WAT\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파이썬\n\n파이썬을 정말 좋아합니다. 파이썬은 진입하기 쉽고, 구문이 명확하고 간결하며, 대부분의 작업을 잘 처리할 만큼 유연합니다. 최근 버전에서 타입 주석 및 match/case가 추가되면서 파이썬은 최근에 훌륭한 생활 편의성 개선을 이루었습니다. 그러나 이러한 기능들이 파이썬을 구원하지 못하는 주요 단점은 속도가 느리다는 것입니다. 다른 언어들과 비교했을 때 정말 느립니다. 해석되는 언어인 것이 이러한 측면에서 도움이 되지 않지만, 문제의 핵심은 GIL(Global Interpreter Lock)에 있습니다. GIL은 Python 코드가 스레드 안전을 위해 CPU의 단일 코어에서만 실행되도록 보장하지만, 병렬 컴퓨팅과 동시성에 대한 유연성과 속도가 저하됩니다. 쓰레드 사용을 포함한 병렬화를 단 하나의 코어로 제한하는 것은 무의미하다는 점이 있습니다.\n\n실제로 프로덕션 환경에서 파이썬 API는 일반적으로 그 자체만으로 배포되지 않습니다 (적어도 그래서 되어서는 안됩니다). Flask, Sanic, FastAPI 등은 모두 파이썬 앱과 동일한 제약 사항으로 묶여 있기 때문에 웹 트래픽을 신뢰성 있게 그리고 어느 정도 성능적으로 제공하기 위해 병렬 처리 프레임워크 내에서 실행되어야 합니다. 이로 인해 배포와 디버깅이 더 복잡해집니다.\n\n또한 파이썬 앱을 배포하는 방법에 대해 이야기해야 합니다. 그게 좋지 않다고요. pip, 파이썬의 패키지 관리자는 종속성을 전역적으로 설치하도록 기본값으로 설정되어 있어 한 번에 같은 라이브러리의 두 가지 버전을 설치할 수 없습니다. 이는 같은 기계에서 여러 개의 Python 앱을 사용하려고 할 때 문제가 발생합니다. 또한 배포 관련해서는 더 복잡해집니다. virtualenv나 poetry와 같은 도구가 종속성 격리를 쉽게 만들어 주긴 하지만, 이러한 도구를 사용해 Python을 기반으로 하는 도구를 최종 사용자에게 배포하는 데 의존하는 것은 어리석은 짓입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬의 구문은 깨끗하고 읽기 쉽습니다 - 대부분의 경우에요. 물론, 의미 있는 공백은 심각한 문제이며 그런 것은 결코 있어서는 안 되지만, 대부분 다른 부분들은 이치에 맞게 구성돼 있어요.\n\n# 루비\n\n내 의견으로는 루비는 최악이에요. 확고하고 표명적인 팬층을 가지고 있는데, 그건 확실한 것이지만, 이 언어는 구조적으로 좋지 않고 제거돼야 할 필요가 있어요.\n\n빠르지 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것은 쉽게 읽을 수 없어서 미안해요.\n\n그리고 대부분의 경우, 그것은 참혹하고 끔찍한 프레임워크와 함께 사용되어서 더는 앞으로 보거나 언급되어서는 안 될 정도로 깊은 심연으로 던져져야 하는 Rails입니다.\n\n루비 온 레일 애플리케이션은 장난감입니다. 그것들은 진지한 작업, 심각한 애플리케이션 또는 진지한 것을 위한 것이 아닙니다. 대형 루비 상점들이 다른 언어로 전환한 이유가 있습니다. Shopify가 대표적입니다.\n\n게다가, 루비 생태계와 관련된 문화는 나쁜 행동과 품질이 낮은 코드를 장려합니다. 실시간으로 실제 애플리케이션 상태를 수정하기 위해 Ruby 콘솔에 들어가야만 애플리케이션이 배포되거나 데이터베이스 마이그레이션을 할 수 있는 상황을 너무나 많이 겪어온 횟수는 정말 너무 많습니다. 그 행동을 장려하는 사람은 배척되어야 한다고 생각해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단히 말해서 루비는 💩야.\n\n\n# PHP\n\nPHP는 올바르게 하는 것들에 대해 모두, 보안 취약점과 성능 병목 현상의 거대한 혼란입니다. PHP의 멋진 점은 HTTP 요청의 맥락에서 독점적으로 실행될 수 있다는 것이고, 그게 멋진 점의 전부다.\n\nPHP의 구문은 말할 수 없을 만큼 이상해. .를 사용한 문자열 연결? 욕나올 정도로 추해.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2005년이 전화를 걸어왔어요. 그 모던하지 않은 웹 앱들을 돌려달라고 합니다!\n\n# 러스트\n\n러스트는 아마도 이 목록 중에서 가장 진지한 언어일 것입니다. 이것은 낮은 수준의 시스템 언어로 간주됩니다 (비교적으로 어셈블리어 수준은 아니고, 좀 더 C 수준으로 이해하셔야 합니다). 그리고 이 목록에 있는 다른 언어들과 달리, 러스트는 리눅스 커널이나 향후 윈도우 버전과 같은 주요 시스템에 중요한 부분이 될 수 있다는 점에서 매우 주목받고 있습니다.\n\n러스트는 매우 헌신적인 추종자 그룹을 갖고 있고, 그 이유가 충분합니다. 이 언어는 빠르고 메모리 안전하며, C나 C++보다 쓰기 편하면서도 이러한 언어들의 성능과 유연성을 모두 간직하고 있습니다. Cargo 패키지 매니저는 번창하는 생태계를 가지고 있습니다. 모두 좋은 일들이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 Rust가 아주 잘 하지 못하는 몇 가지가 있습니다. 그 중 가장 큰 것은 동시성입니다. Rust에서 동시성을 사용하는 애플리케이션을 작성하는 것은 즐거운 작업이 아니라고 합니다. 동시성은 사실상 여기저기에서 생각한 것보다는 별겄 것이었습니다. 미래에는 나아질 수 있겠지만, 현재로서는 조금 문제가 있는 상태입니다.\n\n동시에 Rust 커뮤니티에서는 현재 매크로를 어떻게 사용해야 하는지에 대한 논쟁이 있는 것으로 보입니다. \"큰 매크로 논쟁\"에 대한 논쟁이 해결될 때까지 조심하는 것이 좋을 것 같습니다.\n\n또한, 사소한 것이지만, Rust 구문은 두 가지 제가 가장 싫어하는 규칙을 사용합니다: 이중 콜론 (::) 및 세미콜론 (;).\n\n# Go\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"20년간의 소프트웨어 개발 업무를 무시하고 언어를 설계한다면 어떻게 될까?\"라는 질문에 대한 대답은 바로 Go입니다.\n\n이전에 Go에 대해 작성한 내용이 있는데, 특히 Go의 패키지 관리가 출시 당시 간과되었으며, 최근에야 어느 정도 개선되었다는 점을 언급했습니다. Go 1.0을 적절한 패키지 관리 기능 없이 공개한 것은 큰 실수였죠.\n\nGo는 일부 기능에서 정말로 뛰어났다고 할 수 있습니다. Go의 동시성은 고루틴을 통해 쉬우며 사용자 친화적입니다. 하지만 다른 기능들은 신중하게 고려되지 않았거나 산업 표준을 따라가지 못하거나 간단히 이상하게 설계되었습니다.\n- 구조체 태그는 프로그램이 어떻게 작동하는지를 바꾸는 마술 주석이라고 할 수 있습니다.\n- 에러 처리는 반복적이고 짜증 날 수 있습니다.\n- Go는 명확성 대신 관례를 선택합니다: 메서드 및 매개변수 노출은 키워드가 아닌 대소문자 변경으로 제어됩니다. 대문자로 시작하는 메서드 또는 속성은 공개되며, 소문자로 시작하는 것은 (myMethod는 비공개이고 MyMethod는 공개) 그렇지 않습니다.\n- 또한 일부 패키지와 기능은 CGO를 필요로 하고, 일부는 순수 Go입니다. 이로 인해 여러 플랫폼에 Go 앱을 배포하기 어렵게 만들 수 있습니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 나에게 있어 Go가 제대로 된 언어로 인정받기를 원한다면, 프로덕션 환경에서 사용할 수 있는 언어로서의 역할을 수행하려면 가장 필요한 기능 중 하나는 동적으로 공유 라이브러리에서 심볼을 가져올 수 있는 기능입니다. Go 애플리케이션은 항상 해당 프로그램을 실행하는 데 필요한 모든 코드를 포함하는 단일 이진 파일입니다. 애플리케이션은 외부 구성 또는 파일을 읽을 수 있지만 외부 파일에서 코드를 읽지 않습니다. 이것은 웹 앱과 같이 자체 포함된 애플리케이션을 작성하는 경우 매우 합리적으로 이해되지만, 확장성이 필요한 경우에는 어떠한 미친 듯한 우회 방법을 수행해야 합니다. 가장 일반적인 우회 방법은 주 프로세스가 완전히 다른 애플리케이션을 실행하는 자식 프로세스를 생성하고 두 프로세스가 RPC를 통해 통신하도록 하는 것입니다. 이러한 사례로는 Terraform이 좋은 예시입니다: Terraform 공급자는 Terraform 주 프로세스와 RPC를 통해 통신하는 자체 포함된 Go 애플리케이션일 뿐입니다. 다른 어떤 언어에서는 각 프로바이더를 위한 공통 인터페이스를 정의하고 단순히 메인 애플리케이션에 클래스나 구조체를 로드할 뿐입니다. 네트워킹 스택이 필요한 IPC 방법을 사용하면서 전체 프로세스를 생성하는 것이 아닙니다!\n\nGo는 제네릭과 slices.Contains()와 같은 편의 기능과 같이 처음부터 갖추어져야 했던 새로운 기능을 차츰 추가해왔지만, Go의 지도 팀은 너무 변화를 꺼려하여 나는 이 언어의 장기적인 방향을 믿지 못합니다.\n\n## 자바\n\n자바는 자바스크립트와 마찬가지로, 원래의 형태와는 구별이 어려울 정도로 여러 차례 개조되고 변형되어온 오래된 언어입니다. 처음에는 가정용 엔터테인먼트 시스템을 위해 설계되었지만, 지금은 포춘 500 대 기업 및 아직 앱릿을 개발하는 3명의 사람을 위한 표준 기업용 언어로 변모했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바의 장점 중 하나는 가상 머신(JVM)입니다. 이는 자바 바이트코드와 기계 코드 사이의 변환 계층이며, 동일한 코드를 상상할 수 있는 거의 모든 하드웨어나 플랫폼에서 실행할 수 있게 해줍니다. JVM이 모든 번역을 처리하기 때문에 ARM 기반 임베디드 장치를 위해 작성한 코드가 인텔 PC나 Apple Silicon Mac에서 실행되어 비싼 테스트 준비나 복잡한 가상화의 필요성이 없어집니다. 그러나 이 접근 방식의 단점은 속도입니다. Java 앱은 손수 사용, JIT 컴파일러 조정 및 선행 조치 없이는 \"빠르지\" 않을 수 있습니다. Spring과 같은 프레임워크는 매크로 프로그래밍과 코드 생성으로 인한 오버헤드를 더합니다.\n\n자바가 \"나쁨\"이라기보다는 타 세미콜론 사용 이외에는 별로 \"나쁜\" 요소가 없습니다. 그러나 \"좋은\" 요소도 많지 않기 때문에, 프로그래밍 언어 중에서 니켈백(Nickelback)같은 존재입니다. 우리가 그것을 포기하고 대신 새롭고 대체할 수 있는 것으로 다시 시작한다면 모두가 더 나은 결과를 얻을 것이라고 생각합니다.\n\n# 새로운 언어\n\n이제 일반적인 언어들이 모두 어떤 면에서 약간 불만족스럽다는 점에 대해 이야기했으니, 가상의 새 언어에 대해 생각해보는 재미 있는 부분에 대해 이야기해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 우리 언어가 다른 것들과 뚜렷히 구별되는 몇 가지 주요 원칙 또는 기능을 정의해야 한다고 생각해요:\n\n- 읽고 학습하기 쉬움 — Python과 같이 쉽게 시작하고 설정할 수 있으며 천천히 심층적인 내용에 녹아 들 수 있어야 해요.\n- 어디서나 사용 가능해야 함 — 특정 서버나 프로세서 몇 개로 한정되지 않고 어디서든 실행할 수 있어야 해요.\n- 병행 처리가 쉬워야 함\n\n그렇다면 이를 실제로 적용하면 어떻게 될까요?\n\n가장 먼저 할 일은 Java의 JVM 개념을 채택하는 것이 좋을 것 같아요. 그러나 한 가지 중요한 점을 바꿔야 해요: JVM과 실행 환경을 애플리케이션과 함께 번들로 제공할 거에요. 네, 이는 컴파일 시 타겟 아키텍처를 지정해야 하는 번거로움이 있겠지만, 컴파일 시 최적화와 정적 링킹을 통해 불필요한 코드를 제거할 수 있어 Java 9+의 사용자 지정 JRE 번들링과 유사한 방식으로 우리에게 Java보다 사이즈와 성능의 장점을 제공할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 Java, Go, JS 등에서 채택한 C 스타일 구문을 유지하는 것이 좋을 것 같아요. 다만 세미콜론은 필요 없으니 걱정 안 하셔도 돼요. 세미콜론 팬이신 분들도 계시겠지만, 매 줄마다 ; 를 입력하는 것은 짜증나고 불필요한 일이에요.\n\nPython에서는 편의 기능과 강력한 표준 라이브러리를 차용하고 싶어요. Python은 편의와 아름다움에 초점을 맞춘 언어인데, 이런 유용한 메서드와 함수들이 다른 많은 언어에서 소홀히 여겨지는 경우가 많아요. 특히 더 \"진지한\" 언어들에서 말이죠.\n\nGo에서는 확실히 병행성 모델을 가져와야 해요. 코루틴, 웨이트그룹, 채널을 통해 병행 작업을 효과적으로 처리하고 관리할 수 있어요. 코루틴에 대해 좀 더 제어할 수 있는 기능을 원해요. 시작하면 완벽한 코드를 작성하거나 루틴 자체에 어떤 종류의 안전장치를 구현해야 해요. 현재 실행 중인 코루틴을 볼 수 있고 필요하다면 강제로 중지시킬 수 있는 방법이 있으면 좋겠죠.\n\n또한 다중 코어 시스템의 장점을 활용할 수 있는 능력도 중요해요. 어떤 언어는 이를 더 잘 처리하지만, 응용 프로그램에서 사용 가능한 모든 컴퓨팅 자원과 메모리를 활용할 수 있는 것이 저희 새 언어의 장기적인 성공에 필수적이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGo와 다르게, 의미를 전달하기 위해 관행에 의존하는 대신 명시적으로 해야 한다고 생각해요. 이것은 메서드, 변수, 속성 등에 public 또는 export와 같은 키워드를 사용하는 것을 의미합니다.\n\n패키지 관리는 중요하며, Rust가 우리에게 가르쳐 준 것 중 하나는 견고한 패키지 관리 생태계의 중요성입니다. 우리 언어는 자체 패키지 관리자와 패키지 저장소를 갖추고 제 1일에 출시될 것입니다. Go나 Deno와 같은 몇 가지 최신 언어와는 달리, 저는 패키지에 대해 GitHub나 다른 버전 관리 시스템에 직접 의존하고 싶지 않아요.\n\n또한 Rust처럼, 컴파일러가 자세하고 합리적인 피드백과 오류 메시지를 제공하는 것이 중요합니다. Go 프로그램에서 문제를 만난 후에 암호화되고 도움이 되지 않는 오류 메시지를 받는 것보다 더 답답한 일은 없어요.\n\nJavaScript처럼, 우리 언어는 클라이언트 및 서버 측에서 모두 실행할 수 있는 것이 좋아요. 그것은 WebAssembly(또는 V8!)를 컴파일하는 것 중 하나가 되며, 브라우저를 타겟으로 하는 프로그램을 작성하는 데 필요한 네이티브 지원을 갖춰야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴파일된 애플리케이션은 정적으로 링크될 것이지만, 여전히 동적 링킹과 심볼 임포트를 지원해야 합니다. 이는 Go가 할 수 없는 확장성과 유연성을 제공할 것입니다.\n\n마지막으로, 그리고 아마도 가장 중요한 것은 파이썬의 문화와 방향을 받아들이고 싶다는 점입니다. 파이썬은 코드 스타일부터 새로운 기능에 이르기까지 모든 것이 파이썬 향상 제안(PEP)으로 자세히 설명되며, 공개적으로 투표를 거쳐 최종 채택이나 거부 여부를 결정하기 위해 이사회로 회부됩니다. 이러한 접근은 파이썬이 스타일(PEP-8)과 같은 것들을 표준화하는 데만 그치지 않고, 사용자가 원하는 대로 새로운 기능을 추가하고 최신 유지할 수 있도록 했습니다. 다만 합리적인 범위 내에서요.\n\n이 새로운 언어를 만드는 데 도움을 주고 싶다면, 댓글을 남겨주세요. 또한 빠뜨린 기능이나 원하는 기능을 댓글로 알려주세요!\n\n## 제가 하는 일을 좋아하시고 어떤 방식으로든 도움을 주고 싶으시다면, 커피 한 잔 사주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ☕ [https://ko-fi.com/peterfraedrich](https://ko-fi.com/peterfraedrich)","ogImage":{"url":"/assets/img/2024-06-19-ItsTimeforaNewProgrammingLanguage_0.png"},"coverImage":"/assets/img/2024-06-19-ItsTimeforaNewProgrammingLanguage_0.png","tag":["Tech"],"readingTime":9},{"title":"루비로 LLM-파워 어플리케이션 만들기","description":"","date":"2024-06-19 10:19","slug":"2024-06-19-BuildingLLM-poweredapplicationsinRuby","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_0.png\" /\u003e\n\n우선, 2024년 4월 14일에 Wroclove.rb에서 이러한 아이디어들을 발표했어요. 그 영상이 올라오면 링크를 포함하겠습니다. 그동안 제 친구 Stephen Margheim은 동반 블로그 글을 쓰도록 권유했어요.\n\n\u003cimg src=\"/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_1.png\" /\u003e\n\n생성 모델 인공지능은 텍스트, 이미지, 오디오, 비디오 등 다양한 유형의 콘텐츠를 생성할 수 있는 인공지능 기술입니다. 이 블로그 글의 범위 내에서는 주로 텍스트 생성에 초점을 맞출 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대규모 언어 모델(LLMs)은 일반적인 언어 이해 및 생성 기능을 갖춘 딥 러닝 인공 신경망(모델)으로, Transformers 아키텍처를 소개한 2017년 Attention Is All You Need 연구 논문 이후 인기를 얻으며 대폭 성장했습니다.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_2.png)\n\n생성형 AI와 LLM은 인공 지능에 대한 접근을 민주화했습니다. 프로덕션 수준 시스템의 배포 및 최적화 기간은 6~7개월에서 겨우 일주일로 단축되었습니다.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대형 언어 모델은 다음과 같은 작업에서 우수한 성과를 보입니다:\n\n- 엔지니어들이 애플리케이션에서 의지할 수 있는 JSON과 같은 구조화된 데이터로 텍스트 변환\n- 대량의 텍스트를 맥락화하고 요약 생성\n- 대량의 텍스트를 주제에 따라 분류\n- 언어 번역\n- 다양한 형태와 크기의 콘텐츠 생성\n- 질문에 대답\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_4.png)\n\n젠 AI 모델이 미래에는 데이터베이스, 캐시, 암호화, 큐, 람다 함수 등과 마찬가지로 각기 기술 스택의 필수 구성 요소가 될 것을 제안하고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 그것이 의미하는 것은 팀이 GitHub Copilot이나 ChatGPT를 사용하여 코드를 생성할 것이라는 것만이 아닙니다. AI는 코드 자체에서 지능적인 컴퓨팅 엔진이 될 것입니다.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_5.png)\n\n투자 관리 회사 Coatue는 AI를 중요한 새로운 인프라 응용 프로그램 개발자들이 상위에 놓을 핵심 부분으로 내세웁니다.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 실제 적용 예시가 있습니다: 의사 결정 트리 순회입니다.\n\n이전에는 모든 다양한 입력에서 출력까지의 조합을 나열해야 했지만, 이제 AI는 주어진 입력에 가장 적합한 옵션(출력 또는 호출할 함수)을 선택할 수 있게 되었습니다(이전에 본 적이 없는 입력도 포함).\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_7.png)\n\n루비 온 레일스 프레임워크가 그토록 사랑받는 이유는 개발자가 비즈니스 로직 작성에 집중할 수 있게 해주고 공학 문제 해결을 공학 문제 해결만을 위한 것으로 다루지 않기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레일즈 애플리케이션에서 대다수의 비즈니스 로직은 모델 및 서비스 객체에 있습니다. AI를 사용하면 일부 비즈니스 로직이 프롬프트에도 함께 존재하게 될 것입니다.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_8.png)\n\n예를 들어, 전자 상거래 스토어에서 주문 완료 절차, 반품 처리, 시즌 할인, 고객 충성도 프로그램 등에 대한 비즈니스 로직을 프롬프트에 작성할 수 있게 될 것입니다.\n\nAI는 비즈니스 로직을 조정하고 비즈니스가 구성된 서비스를 활용할 것입니다. 위의 슬라이드에서 AI는 왼쪽의 프롬프트를 활용하여 결제 게이트웨이, 재고 관리 시스템, 배송 서비스 및 기타 서비스를 연결합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실 이 실험을 진행하고 결과를 여기에 문서화했습니다: [https://github.com/patterns-ai-core/ecommerce-ai-assistant-demo](https://github.com/patterns-ai-core/ecommerce-ai-assistant-demo).\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_9.png)\n\n이것은 AI 에이전트의 개념으로 이어지는데, 이는 자율 주행형 LLM 프로그램입니다.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAI 에이전트는 비교적 신뢰할 수 없다고 알려져 있어요. AI 에이전트가 맡는 작업이 많을수록 더 믿을 수 없는 경향이 있어요. AI 에이전트가 작동하는 결정 트리의 가지와 잎이 적을수록 더 신뢰할 수 있어요.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_11.png)\n\n저의 주요 관심사와 작업은 오늘날 비즈니스 프로세스와 워크플로우 자동화를 위해 구축 중인 신뢰할 수 있는 AI 에이전트들이에요.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_12.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 이러한 시스템을 프로덕션 환경에 배포하는 데 망설이고 계신다면 — 외롭지 않습니다! Gen AI의 기업 채택이 예상한 것보다 훨씬 더 느리게 진행되고 있습니다.\n\n그 이유는 다음과 같습니다:\n\n- 현재 빠르게 변화하는 분야에 대한 투자는 계속해서 움직이는 목표를 추구하게 될 수 있습니다.\n- AI로 생성된 작품의 지적재산권 및 저작권 소유권에 대한 모호함.\n- EU 및 US의 새롭고 떠오르는 규제 환경에 대한 법적 준수에 대한 불확실성.\n- 부족한 툴링\n- AI 시스템의 블랙박스와 유사한 행동이 추가적인 리스크를 가져옵니다.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_13.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLLM은 환각 및 오래된 데이터(모델은 특정 시점의 데이터로 훈련되었습니다)와 같은 몇 가지 결함을 보여줍니다. 또한 특정 사용 사례에 대한 관련/동일 정보를 활용하지 않는다는 점도 그중 하나입니다.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_14.png)\n\n이러한 결함 중 일부는 \"Prompt Engineering\"을 통해 완화할 수 있지만, 특정 프롬프트가 더 나은(또는 나쁜) 결과를 가져오는 이유를 설명하지 못해 \"프롬프트 연금술\"이라고 부르고 있습니다.\n\n\"훈련 데이터에 있다!\"라고 말합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세부 사항을 조금 바꿔보는 것, 예를 들어 \"여기서 한 걸음 씩 생각해 봅시다\"나 \"깊게 숨을 들이마시고 이 문제를 해결해 봅시다\"와 같이 친근한 어조로 지시사항을 바꾸면, 큰 언어 모델이 최적화된 결과를 제되는 것으로 밝혀졌어요.\n\n![이미지 1](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_15.png)\n\n모델은 다양한 기법을 사용해 의도하지 않은 작업이나 발언을 하도록 강제할 수 있기도 해요. 예를 들면, 앤소픽에서 보고한 Many-shot 탈옥 기술과 같은 기법이 있어요.\n\n![이미지 2](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_16.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n외부 사용자의 자유 형식 입력을 모델에 프롬프트로 전달하는 것은 무한한 문제의 가능성을 열어둘 수 있습니다. 이러한 취약점의 99번째 백분위를 어떻게 다루어야 할지 배우기 전까지는 미래에는 AI 에이전트가 시스템 간 상호작용을 담당하고 고객과 시스템 간 상호작용을 담당하지 않게 될 것입니다.\n\n![Image](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_17.png)\n\nRAG(검색증대생성)가 등장했습니다. 이 기법은 외부 소스에서 가져온 사실로 LLM 모델의 정확성과 신뢰성을 높이는 기술입니다.\n\n현재 일반적으로 사용되는 사례는 AI 챗봇을 구축하여 독점적인 기업 데이터 위에 질문에 답할 수 있는 기능을 가지게 하는 것입니다. 물론, 상자 밖의 AI는 귀하의 조직의 독점적 데이터에 대해 훈련받지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식입니다.\n\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_18.png)\n\n다음은 RAG 컴포넌트 각각에 대해 자세히 살펴볼 것입니다:\n- 벡터 임베딩\n- 유사도 검색\n- RAG 프롬프트\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_19.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식입니다.\n\n\n![BuildingLLM-poweredapplicationsinRuby_20](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_20.png)\n\n벡터 임베딩은 데이터의 의미론적인 의미를 벡터 공간에서 나타냅니다. 이를 \"잠재 공간\"이라고도 합니다.\n\n![BuildingLLM-poweredapplicationsinRuby_21](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_21.png)\n\nLLM에 전달할 관련 컨텍스트를 찾기 위해 의미론적으로 유사한 문서들을 찾습니다. 보통 벡터 검색 데이터베이스에 저장된 벡터 임베딩 중에서 전달된 쿼리와의 거리를 계산하는 과정이 유사성 검색입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_22.png\" /\u003e\n\n순진한 RAG 구현의 마지막 단계는 컨텍스트와 원래 질문을 연결하여 RAG 프롬프트를 구성하는 것입니다. 선택적으로— 특정 행동이나 응답 스타일을 조절하기 위해 모델 지침을 지정할 수도 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_23.png\" /\u003e\n\n모두 함께 넣어 보면— 이것이 순진한 RAG 구현을 위해 얻게 되는 스키마입니다. 고급 RAG 전략은 현재 활발히 연구되고 있는 핫한 주제입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_24.png\" /\u003e\n\n이러한 고급 RAG 전략 중 하나의 예는 2 벡터 검색 데이터베이스 인덱스를 활용하는 것입니다: 하나는 소스 문서 요약의 임베딩을 저장하고, 다른 하나는 문서 청크 임베딩을 저장합니다.\n\n이 경우에는 다음과 같이 2개의 유사성 검색 단계를 실행합니다:\n\n- 관련 요약 찾기\n- 스텝 #1에서 찾은 문서 요약과 연결된 관련 문서 청크 찾기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_25.png)\n\n루비 소프트웨어 엔지니어가 LLM을 활용하여 애플리케이션을 구축하는 데 도움이 되는 루비 라이브러리를 작업해 왔고, 이 발표에서 논의된 많은 아이디어를 구현했습니다.\n\n![image](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_26.png)\n\n저희가 취하는 방식은 최고의 루비 온 레일즈 패션 — 배터리 포함 및 모범 사례를 포함한 방식입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![BuildingLLM-poweredapplicationsinRuby_27](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_27.png)\n\n내가 우리가 가장 인기 있는 벡터 검색 데이터베이스 중 하나와 함께 어떤 LLM 플레이버를 선택하고 사용할 수 있도록 유연성을 제공한다.\n\n![BuildingLLM-poweredapplicationsinRuby_28](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_28.png)\n\n루비는 인공 지능/기계 학습 또는 어떤 종류의 데이터 과학 작업에 관련이 있을 때 특히 역설적인 기술로 선택되어 왔다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAI 시대에는 특정 언어 선택보다는 전에는 그랬던 것보다 훨씬 덜 중요한 것 같아요. 저는 Ruby를 사용한 이유는 Ruby로 아이디어를 가장 효과적으로 전달할 수 있기 때문이에요.\n\n곧 AI가 대규모 코드베이스를 몇 시간이나 몇 분 안에 새롭고 트렌디한 프로그래밍 언어로 재작성할 수 있도록 해줄 거예요. AI가 인간 언어 번역을 다루는 방식으로 코드를 번역하면 되죠.\n\n![이미지](/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_29.png)\n\n인기 있는 오픈소스 프로젝트를 운영하면서 경험한 것을 통해, 다른 오픈소스 소프트웨어 유지보수자들에게 깊은 존경과 감사의 마음을 갖게 되었어요. 그들은 대부분 매우 친절하고 수면 부족한 사람들로, 낯선 사람들을 도와주기를 즐기면서 아무것도 기대하지 않고 도와줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_30.png\" /\u003e\n\n저희 프로젝트에 기여해준 모든 훌륭한 분들께 깊은 감사의 말씀을 전합니다.\n\nWroclove.rb 주최자분들께 감사의 인사를 전합니다. 지난 18개월 동안 AI 여정에서 만난 모든 분들께 큰 찬사를 보냅니다! 우리 프로젝트를 확인하고, Ruby AI 및 Langchain.rb 디스코드 서버에 참여해 주세요.\n\n## 참고문헌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Advanced RAG 기술: 그림으로 설명한 개요\n- LLM에서는 이제 임베딩 작업에 대한 도구를 제공합니다\n- 많은 샷으로 감옥 탈출\n- Optimizer로서 대형 언어 모델\n- RAGAS 프레임워크\n- Andrew Ng: AI 분야의 기회 - 2023\n- Adams가 홍보한 NYC AI 챗봇이 기업들에게 법을 어기라고 조언\n- 챗봇의 환청에 대해 Air Canada가 책임을 져\n- GM 딜러 챗봇이 2024 Chevy Tahoe를 1달러에 판매하는 것에 동의","ogImage":{"url":"/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingLLM-poweredapplicationsinRuby_0.png","tag":["Tech"],"readingTime":8},{"title":"루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내","description":"","date":"2024-06-19 10:17","slug":"2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide","content":"\n\n당신이 코드가 스스로 작성되길 바라거나, 실행 중에 자신을 수정, 확장 또는 자가검사할 수 있는 슈퍼파워를 가지기를 꿈꾼 적이 있나요? 새로운 지식을 터득하고 자유롭게 프로그램을 다루는 마술사처럼 프로그램을 제어하는 Ruby 메타프로그래밍이 여기 있다는 걸 알았군요!\n\n무엇이 메타프로그래밍인가요?\n\nRuby에서의 메타프로그래밍은 실행 중에 코드 자체를 수정, 확장 또는 자가검사할 수 있는 능력을 갖추는 것처럼 슈퍼파워를 지니고 있는 것과 같습니다. 이것은 프로그램이 새로운 기능을 터득하고 새로운 속성을 신속하게 알아차릴 수 있는 능력을 부여하는 것과 같습니다.\n\n가볍고 재미있게 진행하기 위해 Ruby 메타프로그래밍의 가장 매혹적인 주문… 즉, 기술들을 알아보도록 하죠. 걱정하지 마세요, 모든 것을 이해할 수 있도록 마법적인 상상력을 이용할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주문 #1: Method_missing\n\n마법사가 된 것처럼 상상해보세요. 누군가 알 수 없는 주문을 요청하면 당신은 그 즉시 마법을 만들어낼 수 있습니다. Ruby에서 method_missing은 당신이 그렇게 할 수 있게 해줍니다!\n\n```ruby\nclass Spellbook\n  def method_missing(name, *args)\n    puts \"#{name} 주문이 #{args.inspect}와 함께 사용되었습니다. 이 주문은 책에 없지만, 만들어볼까요?\"\n    # 여기서 동적으로 메소드를 생성할 수 있습니다.\n  end\nend\n\nwizard = Spellbook.new\nwizard.invisibility(\"10분 동안\") # invisibility 주문이 [\"10분 동안\"]와 함께 사용되었습니다. 이 주문은 책에 없지만, 만들어볼까요!\n```\n\nmethod_missing을 오버라이딩함으로써 정의되지 않은 메소드 호출을 잡아내어 처리하는 방법을 결정할 수 있습니다. 무한한 주문서를 가지고 있는 것과 같은 느낌이죠!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주문 #2: Define_method\n\n새로운 주문을 마음대로 만들고 싶나요? define_method이 당신의 선택된 주문입니다. 이 주문을 사용하면 클래스에 동적으로 메서드를 정의할 수 있습니다.\n\n```js\nclass Wizard\n  define_method(:conjure_fireball) do |size|\n    puts \"크기가 #{size}인 파이어볼을 창조합니다!\"\n  end\nend\n\n간달프 = Wizard.new\n간달프.conjure_fireball(\"큰\") # 크기가 큰 파이어볼을 창조합니다!\n```\n\ndefine_method을 사용하면 실행 시간에 클래스에 메서드를 추가할 수 있어서, 당신의 주문(그리고 코드)를 무한히 유연하게 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주문 #3: Class_eval과 Instance_eval\n\n만약 클래스나 객체의 본질을 조정하고 싶다면 어떻게 해야 할까요? 바로 class_eval과 instance_eval이 등장합니다. 이 둘은 각각 클래스나 인스턴스의 컨텍스트에서 코드를 실행할 수 있게 해줍니다.\n\n```js\nclass Dragon\nend\n\nDragon.class_eval do\n  def breathe_fire\n    puts \"용이 불을 뿜습니다!\"\n  end\nend\n\nsmaug = Dragon.new\nsmaug.breathe_fire # 용이 불을 뿜습니다!\n```\n\nclass_eval을 사용하면 실행 중에 클래스의 메소드를 추가하거나 구조를 변경할 수 있습니다. 마치 결투 중에 주문서를 다시 쓰는 것과 같은 느낌이죠!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실용적인 예제: DSL(Domain Specific Language) 만들기\n\n우리의 주문을 결합하여 마법 생물을 정의하는 간단한 DSL을 만들어 봅시다.\n\n```js\nclass MagicalCreature\n  def self.spell(name, \u0026block)\n    define_method(name, \u0026block)\n  end\nend\n\nclass Unicorn \u003c MagicalCreature\n  spell :sparkle do\n    puts \"The unicorn sparkles!\"\n  end\n\n  spell :fly do\n    puts \"The unicorn takes flight!\"\n  end\nend\n\ntwilight = Unicorn.new\ntwilight.sparkle # The unicorn sparkles!\ntwilight.fly # The unicorn takes flight!\n```\n\n클래스 메소드 내에서 define_method를 사용하여 마법 생물의 능력을 정의하는 간편하고 유연한 방법을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론\n\n루비 메타프로그래밍은 마법같은 특별한 능력을 소유하는 것과 같습니다. 이를 이용하면 코드를 더 유연하고 강력하게 만들 수 있지만, 지혜롭게 활용해야 합니다. 강력한 마법과 마찬가지로 무모하게 사용하면 위험할 수 있습니다. 주문(코드)을 명확하고 유지보수 가능하게 작성하고, 항상 마법같은 작품에 설명을 붙이세요.\n\n자, 젊은 코더여, 루비 메타프로그래밍의 마법을 이용하여 코드를 더욱 향상시켜 보세요!","ogImage":{"url":"/assets/img/2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide_0.png"},"coverImage":"/assets/img/2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"루비를 잘 몰라요 더 이상","description":"","date":"2024-06-19 10:14","slug":"2024-06-19-YouDontKnowRubyAnymore","content":"\n\n조심하세요! 시니어 루비 개발자분들께는 마음을 다치게 할 수도 있는 기사입니다.\n\n루비는 모든 현대 프로그래밍 언어처럼 발전하고 있습니다. 커뮤니티는 계속해서 새로운 기능을 소개하고 있지만 모두가 알지 못하는 것이 있습니다. 새로운 기능을 따라가지 않고 채택하지 않는 개발자들은 아마도 루비 3.3 시대에도 루비 1.9.2 코드를 작성하고 있을지도 모릅니다!\n\n루비의 성숙함과 오랜 역사에도 불구하고 사용자들 사이에는 오래된 관행을 고수하려는 경향이 있습니다. 새로운 기능을 받아들이기를 꺼리는 이러한 저항은 유감스럽습니다. 새로운 기능을 도입하는 것이 루비의 관련성을 유지하고 현대 프로그래밍 언어 중 하나로 자리 잡는 데 도움을 준다는 것을 명심해야 합니다.\n\n최근 루비 버전에서 중요한 새로운 기능과 개선 사항들을 소개하겠습니다. 더불어 커뮤니티에서는 아직 충분히 주목받지 못한 오래된 기능들도 소개할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# RBS (루비 서명)\n\n루비 코드에서 유형 안전성을 보장하려면 방대한 테스트와 문서 작업이 필요했고, 이로 인해 잠재적인 런타임 오류와 생산성 저하가 발생했죠.\n\nRBS (루비 서명)는 루비 3.1과 함께 소개된 새로운 언어로, 루비 코드의 유형과 인터페이스를 설명하는 데 사용됩니다. 이를 통해 정적 유형 확인과 IDE 자동 완성이 가능해져 코드 품질과 개발자 생산성이 향상됩니다.\n\nSorbet 및 유사한 커뮤니티 주도의 대안이 존재하지만, RBS는 Matz에 의해 지지된 점에서 돋보입니다. 별도의 젬으로 패키징되었지만, 프로그래밍 언어 환경에서 유형 확인 트렌드를 받아들이는 공식 방법으로 간주됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# Point.rbs\nclass Point\n  attr_reader x: Integer\n  attr_reader y: Integer\n\n  def initialize: (x: Integer, y: Integer) -\u003e void\nend\n\n# Point.rb\nclass Point\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x = x\n    @y = y\n  end\nend\n```\n\nSteep은 루비를 위한 정적 타입 검사 도구로, 타입 안전성을 보장하고 개발 과정에서 오류를 일찍 발견하는 데 도움을 줄 수 있어요.\n\n일반적인 GitHub Actions CI/CD 파이프라인에서는 Steep을 테스트 단계의 일부로 설정할 수 있어요. 이를 통해 루비 코드베이스를 RBS 파일에 대해 분석하고, 타입 오류를 확인하여 개발자에게 피드백을 제공할 수 있어요.\n\n```js\n# .github/workflows/ci.yml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Setup Ruby\n        uses: actions/setup-ruby@v1\n        with:\n          ruby-version: '3.3'\n\n      - name: Install dependencies\n        run: bundle install\n\n      - name: Run Steep\n        run: bundle exec steep check\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCI/CD 파이프라인에 Steep를 통합하면 코드 품질을 유지하고 유형 안정성을 강화하여 런타임 오류를 방지할 수 있습니다. 이는 최상의 관행을 촉진하며 Ruby 애플리케이션의 신뢰성을 향상시킵니다.\n\nRBS 도입은 학습과 도구 설정에 상당한 투자가 필요할 수 있습니다. 또한 코드베이스 옆에 유형 주석을 유지하는 데 추가 작업을 도입할 수 있습니다.\n\n# 패턴 매칭\n\n패턴 매칭은 Ruby 2.7에서 가장 기대되는 기능 중 하나였습니다. Ruby 창시자인 매츠는 Ruby를 더 표현력 있게 만들고 현대 프로그래밍 언어 트렌드에 맞추기 위해 패턴 매칭을 포함하고 싶다고 언급했습니다. 커뮤니티는 Ruby 메일링 리스트와 이슈 트래커에서 이에 대해 광범위히 논의했습니다. 해당 기능은 최종 포함되기 전에 여러 번의 반복과 수정을 거쳤습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패턴 매칭 이전에는 복잡한 데이터 구조를 비구조화하고 일치시키기 위해 다양한 if나 case 문을 사용하여 반복적이고 장황한 코드가 필요했습니다. 이로 인해 코드의 가독성과 유지보수성이 낮아지는 경우가 많았습니다.\n\n루비 2.7부터 도입된 패턴 매칭은 루비 3.0에서 더 발전하여 더 간결하고 표현력 있는 데이터 비구조화와 일치를 가능케 합니다. 이로써 코드가 더 깔끔하고 유지보수가 편해집니다.\n\n예시:\n\n```ruby\ndef company_location_contact_id(company_location_id)\n  query = \u003c\u003c~GRAPHQL\n    query($company_location_id: ID!) {\n      companyLocation(id: $company_location_id) {\n        ...\n      }\n    }\n  GRAPHQL\n\n  response =\n    @client.query(\n      query:,\n      variables: { company_location_id: \"gid://shopify/CompanyLocation/#{company_location_id}\" }\n    ).body\n\n  case response.deep_symbolize_keys\n  in errors: [{ message: error_message }]\n    Rollbar.error(\"#{error_message} for\", company_location_id:)\n  in data: { companyLocation: nil }\n    Rollbar.error(\"Company location not found\", company_location_id:)\n  in data: { companyLocation: { roleAssignments: { edges: [{ node: { companyContact: { id: contact_id } } }] } } }\n    contact_id\n  end\nend\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패턴 매칭을 사용하지 않으면, 코드는 일반적으로 중첩 조건문이나 응답 데이터의 수동 구문 분석으로 인한 오류를 유발할 수 있습니다. 같은 기능을 패턴 매칭 없이 어떻게 구현할 수 있는지 살펴봅시다:\n\n```js\ndef 회사_위치_연락처_ID(회사_위치_ID)\n  쿼리 = \u003c\u003c~GRAPHQL\n    query($company_location_id: ID!) {\n      companyLocation(id: $company_location_id) {\n        ...\n      }\n    }\n  GRAPHQL\n\n  응답 = @client.query(\n    query: 쿼리,\n    variables: { company_location_id: \"gid://shopify/CompanyLocation/#{회사_위치_ID}\" }\n  ).body\n\n  데이터 = 응답.deep_symbolize_keys\n\n  if 데이터.key?(:errors) \u0026\u0026 데이터[:errors].is_a?(Array) \u0026\u0026 데이터[:errors].first.key?(:message)\n    오류_메시지 = 데이터[:errors].first[:message]\n    Rollbar.error(\"#{오류_메시지} for\", company_location_id: 회사_위치_ID)\n  elsif 데이터.key?(:data) \u0026\u0026 데이터[:data].is_a?(Hash) \u0026\u0026 데이터[:data][:companyLocation].nil?\n    Rollbar.error(\"회사 위치를 찾을 수 없음\", company_location_id: 회사_위치_ID)\n  elsif 데이터.key?(:data) \u0026\u0026 데이터[:data].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].is_a?(Array) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].first.is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].first[:node].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].first[:node][:companyContact].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].first[:node][:companyContact].key?(:id)\n    데이터[:data][:companyLocation][:roleAssignments][:edges].first[:node][:companyContact][:id]\n  end\nend\n```\n\n패턴 매칭을 사용하지 않으면 코드가 상당히 장황하고 오류 발생 가능성이 높아집니다. 각 조건을 주의 깊게 확인하고 중첩해야 하므로 가독성 문제와 버그 발생 위험이 커집니다. 패턴 매칭을 통해 복잡한 데이터 구조를 해체하고 일치시키는 간결하고 가독성 있는 방법을 제공함으로써 이러한 프로세스를 간편화할 수 있습니다.\n\n그러나 패턴 매칭이 과도하게 사용되거나 부적절하게 사용된 경우 복잡성을 증가시킬 수도 있습니다. 또한 개발자가 새로운 구문과 패턴을 익히고 채택 속도가 처음에는 느려질 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 원 라인 패턴 매칭:\n\n해시나 배열의 구조 해체는 종종 여러 줄의 코드가 필요하여 간단한 할당이 다소 장황하고 복잡해지는 경우가 있습니다.\n\n루비 2.7에서 소개된 원 라인 패턴 매칭은 구조 해체를 한 줄로 처리하여 코드를 보다 간결하고 가독성 있게 만들어줍니다.\n\n```js\ndata = { user: { name: \"Alice\", details: { age: 25, city: \"Paris\" } } }\ndata =\u003e { user: { name:, details: { age:, city: } } }\nputs \"Name: #{name}, Age: #{age}, City: #{city}\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 줄 구문은 복잡한 패턴에 대해 가독성이 떨어질 수 있고, 개발자들은 새로운 구문을 완전히 활용하기 위해 익숙해져야 합니다.\n\n**오른쪽 할당:**\n\n이전 기능과 유사하게, `=` 연산자는 해체 및 패턴 매칭 없이 변수를 할당하는 방식으로 사용될 수 있으며, 코드의 흐름 방향과 더 자연스럽게 느낄 수 있는 다른 순서로 변수를 할당하는 방식입니다.\n\n루비 3.0에서 소개된 오른쪽 할당은 더 읽기 쉽고 간결한 방식으로 바로 할당을 수행할 수 있도록 구문을 간단화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nread_data() =\u003e user_data =\u003e { user: { name:, details: { age:, city: } }\nsave!(user_data)\nputs \"Name: #{name}, City: #{city}\"\n```\n\n이 구문은 일부 개발자들에게 익숙하지 않고 혼란스러울 수 있습니다. 또한 복잡한 표현식에서 과도하게 사용하면 코드를 덜 읽기 쉽게 만들 수 있습니다.\n\n# 개선 사항\n\n핵심 클래스를 전역적으로 수정하는 것은 예상치 못한 부작용과 충돌을 야기할 수 있으며, 특히 대규모 코드베이스나 공유 라이브러리에서는 특히 그렇습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루비 2.0에서 소개된 Refinements는 코어 클래스에 범위 지정 수정을 할 수 있는 방법을 제공합니다. 이를 통해 변경 사항을 특정 컨텍스트로 제한하여 부작용의 위험을 줄일 수 있습니다.\n\n```js\nmodule ArrayExtensions\n  refine Array do\n    def to_hash\n      Hash[*self.flatten]\n    end\n  end\nend\n\nclass Converter\n  using ArrayExtensions\n\n  def self.convert(array)\n    array.to_hash\n  end\nend\n\nputs Converter.convert([[:key1, \"value1\"], [:key2, \"value2\"]])\n```\n\n이것은 비교적 오래된 (그러나 소중한) 기능으로, 너무 적은 코드베이스에서 사용된 것을 본 적이 있습니다. 단점이 있지만, 우리가 그것을 인식하고 있을 때 강력한 도구로 작용합니다.\n\nRefinement를 사용할 때 중요한 함정 중 하나는, 코드가 실행되는 컨텍스트에서 Refinement가 활성화되어 있지 않을 때 예기치 못한 동작이 발생할 수 있다는 것입니다. Refinement는 특정 렉시컬 스코프 내의 코드에만 영향을 미치기 때문에, Refinement에 의존하는 코드는 실행되는 위치에 따라 다르게 동작할 수 있습니다. 이는 일관성이 떨어지고, 코드가 재사용되거나 다양한 컨텍스트에서 실행될 경우 진단하기 어려운 버그를 유발할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그냥 알아두세요.\n\n# Enumerator::Lazy\n\n대량 컬렉션에 대해 연산을 체인화하는 것은 중간 배열이 생성되어 메모리와 처리 시간을 소모하여 비효율적일 수 있습니다.\n\n루비 2.0에서 소개된 지연(Leazy) 열거자는 중간 배열을 만들지 않고 효율적인 연산 체인을 가능케 합니다. 이는 대량 컬렉션에 대해 더 나은 성능과 낮은 메모리 사용량을 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nlazy_numbers = (1..Float::INFINITY).lazy\nresult = lazy_numbers.select { |n| n % 2 == 0 }\n                     .map { |n| n * n }\n                     .take(10)\n                     .to_a\n\nputs result.inspect\n\n\n단점: 지연 열거자는 연산이 체인의 끝까지 연기되기 때문에 디버깅이 더 어려울 수 있습니다. 또한, 모든 열거자 메서드가 지연 열거자에서 사용 가능한 것은 아닙니다.\n\n# Enumerator::Chain\n\n여러 열거 가능한 항목을 연결하는 경우 연결이 필요했으며 표현력이 낮아 종종 가독성이 떨어지는 코드로 이어졌습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루비 2.6에 소개된 Enumerator::Chain은 열거자를 체인으로 묶는 깔끔하고 표현력 있는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.\n\n```js\nevens = (2..10).step(2)\nodds = (1..9).step(2)\ncombined = evens.each.chain(odds.each)\n\nputs combined.to_a.inspect\n```\n\n단점: 체이닝을 간단하게 만들지만, 개발자가 배워야 할 다른 개념을 소개할 수 있습니다. 복잡한 체이닝 시나리오에서 과도하게 사용될 경우 데이터의 원천을 가리거나 불분명하게 만들 수도 있습니다.\n\n# Module#prepend\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 바꾸는 것이 조금 더 간단하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 끝이 없는 메서드 정의\n\n단순한 메서드를 정의하는 데 여러 줄의 코드가 필요했었습니다. 메서드 본문이 하나의 표현식인 경우에도 말이죠. “;”를 사용하여 한 줄 메서드 정의를 작성하는 방법은 있었지만, 그렇게 하면 보기 좋지 않았습니다.\n\n```js\ndef power(base, exponent); base**exponent ; end\n```\n\nRuby 3.0에서 소개된 끝이 없는 메서드 정의는 단일 표현식을 반환하는 메서드에 대해 간결한 구문을 제공하여, 보일러플레이트를 줄이고 가독성을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass Calculator\n  def add(a, b) = a + b\n  def multiply(a, b) = a * b\n  def power(base, exponent) = base**exponent\nend\n\ncalc = Calculator.new\nputs calc.add(2, 3)       # 결과: 5\nputs calc.multiply(4, 5)  # 결과: 20\nputs calc.power(2, 3)     # 결과: 8\n```\n\n새로운 구문은 일부 개발자에게는 익숙하지 않을 수 있어 혼란스러울 수 있습니다. 또한, 더 복잡한 메소드에 과도하게 사용될 경우 가독성이 떨어질 수도 있습니다.\n\n# `it` 매개변수\n\n블록 변수를 명시적으로 사용하는 것은, 특히 map과 같이 단일 매개변수가 필요한 Enumerable 메소드들에 대한 간단한 작업에 대해 최대한 설명하기 위한 경우, 반복적이고 간결하지 않은 코드를 작성할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRuby 3.0에서 소개된 it 매개변수는 기본 블록 매개변수를 제공하여 블록 구문을 간략화하며 단순한 작업에 대해 코드를 더 간결하고 가독성 있게 만들어줍니다.\n\n```js\n[\"apple\", \"banana\", \"cherry\"].map { it.upcase.reverse }\n```\n\nRuby 2.7에서는 번호 매개변수(_1, _2 등)가 실험적 기능으로 도입되어 블록 구문을 간소화하고 인수를 자동으로 참조함으로써 목표를 달성했습니다. 그러나 커뮤니티 내에서 읽기 어려움과 혼란 가능성에 대한 우려가 제기되었고, 이는 기본 it 매개변수 주변의 토론과 유사합니다. Rubocop은 매개변수 _1 이외의 번호 매개변수 사용을 방지하도록 설정을 기본값으로 하며, 이는 it를 사용하는 것과 정확히 동일하지만 더 좋은 이름을 가지고 있습니다.\n\n단점: it의 암시적 성격은 코드를 더 복잡한 작업에 대해 읽기 어렵게 만들 수 있습니다. 또한 개발자가 배워야 할 새로운 규칙을 도입합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# String#casecmp?\n\n대소문자를 구별하지 않는 문자열 비교를 위해서는 복잡한 코드를 작성해야 했는데, 그것은 종종 여러 메서드 호출이나 정규 표현식을 포함하여 가독성을 떨어뜨리곤 했습니다.\n\nRuby 2.4에서 소개된 String#casecmp?는 대소문자를 구분하지 않는 비교를 위한 간편한 메서드를 제공하여 코드를 더 간결하고 표현력 있게 만들어줍니다.\n\n```ruby\nstrings = [\"Hello\", \"world\", \"HELLO\"]\nmatches = strings.select { |s| s.casecmp?(\"hello\") }\nputs matches.inspect # =\u003e [\"Hello\", \"HELLO\"]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Object#yield_self 그리고 then\n\n객체에 대한 연산을 연쇄적으로 사용할 때 중간 변수 없이는 가독성이 떨어질 수 있어 더 장황하고 부자연스러운 코드가 될 수 있습니다. 호출이 중첩되어 있을 때 코드 읽기 방향도 자연스럽지 않게 느껴질 수 있습니다.\n\n루비 2.5에서 소개된 Object#yield_self와 Ruby 3.0에서 소개된 then 별칭을 사용하면 더 깔끔한 연산 체이닝이 가능해져 코드 가독성과 유연성이 향상됩니다.\n\n```js\nresult = \"hello\"\n         .yield_self { |str| str.upcase }\n         .then { |str| str + \" WORLD\" }\n\nputs result  # Output: \"HELLO WORLD\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**단점:** 이러한 방법은 쉽게 오용되거나 과도하게 사용될 수 있어서, 체인이 너무 길거나 복잡해지면 코드가 덜 가독성이 될 수 있습니다.\n\n# 끝없는 범위:\n\n상한 또는 하한이 없는 범위를 정의하는 데는 Float::INFINITY 또는 다른 해결책이 필요했는데, 이는 번거로울 수 있고 직관적이지 않을 수 있습니다.\n\nRuby 2.6에서 소개된 끝없는 범위는 한쪽에 제한이 없이 범위를 정의할 수 있게 해주어 코드를 보다 간결하고 표현력있게 만들어줍니다. 특히 무한한 시퀀스나 무한 범위에 대해서 특히 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nalphabet = ('a'..'z')\nnumbers = (1..)\npositive_even_numbers = (2..).step(2)\n```\n\nActiveRecord을 사용하면 강력한 단축키가 될 수 있습니다:\n\n```js\n@posts = \n  Post.where(some_value: ..min_value).order(:id).paginate(page: params[:page])\n  # where('some_value \u003c ?', min_value)와 동일합니다\n```\n\n무한 범위는 조심히 사용하지 않으면 예상치 못한 동작으로 이어질 수 있습니다. 특히 범위가 무한대로 반복되는 경우에는 특별히 주의해야 합니다. 지나치게 또는 부적절하게 사용할 경우 가독성이 떨어질 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터 클래스:\n\n간단한 데이터 구조를 만들 때는 종종 속성 액세서와 초기화를 위한 보일러플레이트 코드를 작성해야 했습니다.\n\n루비 3.0에서 소개된 데이터 클래스는 속성을 가진 클래스를 정의하는 간결한 구문을 제공하여 보일러플레이트를 줄이고 코드 가독성을 향상시킵니다.\n\n```js\nclass Coordinates \u003c Data\n  attribute x: Float\n  attribute y: Float\nend\n\npoint = Coordinates.new(x: 10, y: 20)\nputs point.x # 출력: 10\nputs point.y # 출력: 20\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 클래스는 주로 간단한 데이터 구조를 위해 사용되며 복잡한 클래스 계층구조나 행위 중심 클래스에는 적합하지 않을 수 있습니다. 과도하게 사용할 경우 더 이상 캡슐화되지 않은 코드로 이어질 수도 있습니다.\n\n루비에서 Data와 Struct의 차이는 사용 목적과 기본 동작을 중심으로 하고 있습니다.\n\nStruct는 루비의 내장 클래스로, 이름이 지정된 속성을 가진 가벼운 데이터 구조를 생성할 수 있게 해줍니다. 클래스 전체를 명시적으로 정의하지 않고도 간단한 클래스를 정의하는 편리한 방법을 제공합니다. Struct를 생성할 때는 그 속성을 한 줄로 정의하고, 루비가 각 속성에 대한 접근자 메서드를 자동으로 생성합니다. Struct는 데이터 구조를 정의하는 간단한 구문을 제공하지만, 일반적인 클래스에서 사용 가능한 일부 고급 기능과 사용자 정의 옵션은 제공하지 않습니다.\n\n한편 Data는 루비 3.0에서 Ractor 실험적 API의 일부로 도입된 새로운 기능입니다. 이는 엄격한 속성 타입을 갖는 변경할 수 없는 데이터 클래스를 정의하는 데 특별히 설계되었습니다. Struct가 변경 가능한 속성을 가진 변경 가능한 클래스를 생성하는 데 반해, Data 클래스는 기본적으로 변경할 수 없으며, 인스턴스화 이후에는 속성을 수정할 수 없습니다. 또한 Data 클래스는 속성에 대한 엄격한 타입 지정을 강제하므로 지정된 유형의 값만이 속성에 할당될 수 있습니다. 이러한 변경 불가능성과 엄격한 타입 지정으로 인해 Data 클래스는 데이터 전송 객체(DTO), 데이터 페이로드 표현 및 변경 불가능성 및 유형 안전성이 중요한 시나리오를 모델링하는 데 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n루비는 읽기 쉽고 효율적이며 표현성이 향상된 많은 강력한 기능을 갖추고 진화했습니다. 이러한 새로운 기능을 활용함으로써 현대적이고 이디오매틱한 루비 코드를 작성할 수 있습니다. 여전히 루비 1.9 스타일 코드를 작성 중이라면, 최신 루비 표준을 반영하고 따라가기 위해 이러한 새로운 기능을 탐험하고 받아들이는 것이 시간입니다.","ogImage":{"url":"/assets/img/2024-06-19-YouDontKnowRubyAnymore_0.png"},"coverImage":"/assets/img/2024-06-19-YouDontKnowRubyAnymore_0.png","tag":["Tech"],"readingTime":13},{"title":"CodeCademy 2024 학생 및 개발자를 위한 50 할인","description":"","date":"2024-06-19 10:12","slug":"2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024","content":"\n\n## CodeCademy은 오늘 유료 요금제에 50% 할인을 제공합니다. 할인을 받으려면 코드 AISUMMER를 사용하십시오\n\n![이미지](/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_0.png)\n\n안녕하세요 여러분, 여러분과 공유하고 싶은 흥미로운 뉴스가 있어요. 코딩 및 웹 개발을 배우는 데 가장 인기 있는 웹 사이트 중 하나인 CodeCademy가 지금 유료 요금제에 50% 할인을 제공하고 있습니다.\n\n이제 프로 또는 프로 학생 요금제 1년 구독을 50% 할인된 가격에 잠그는 데 프로모션 코드 AISUMMER을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCodeCademy가 무엇인지 모르신다면 제 이야기를 들어보세요. 어떻게 CodeCademy를 만나고 나서 개발자들을 위한 많은 핵심 기술을 배우는 데 사용했는지 알려드릴게요.\n\n나는 7년 전에 CodeCademy를 처음 알게 되었어요. 당시 나는 자바스크립트에 대해 배울 무료 강의를 찾아보던 중이었죠. 사실, 전 자바스크립트를 활용한 프론트엔드가 작성된 풀스택 프로젝트를 작업 중이었는데, 코드를 읽기 위해 빠르게 배우고 싶었어요.\n\n그런 다음 그들의 '자바스크립트 입문' 코스를 알게 되었어요. 이 무료 코스는 200만 명 이상의 개발자들에 의해 수강되었답니다. 강의 구성 방식이 마음에 들었어요. 브라우저에서 코드를 작성하고 빠른 피드백을 볼 수 있다는 점이죠.\n\n수업은 작고 매우 매력적이었어요. 이는 코드에서 80% 사용되는 20%의 개념을 빠르게 배울 수 있도록 도와주었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 이후로 CodeCademy Pro Plan을 사용하고 있어요. 뭘 배우든지, 되새기든지 지루할 때는 항상 CodeCademy로 갑니다. 이제 동일한 요금제를 50% 할인된 가격에 구매할 수 있어요. 할인 코드는 AISUMMER를 사용하세요.\n\n링크는 여기 있어요 — [CodeCademy Pro Plan](https://www.example.com)\n\n![CodeCademy 50% 할인](/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_1.png)\n\n유료 요금제를 구입하면, 수요가 높은 기술을 배울 수 있는 최고의 CodeCademy 강좌를 확인할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 파이썬 3 배우기\n- 자바 배우기\n- SQL 배우기\n- 블록체인 및 암호화폐 소개 [무료 강좌]\n- Go 배우기\n- 무료 SQL 배우기\n- D3.js 배우기\n- PHP 배우기\n- 판다스를 사용한 데이터 분석 배우기\n- Git 배우기\n- HTML 배우기\n- C++ 배우기\n- CSS 배우기\n- C# 배우기\n- 코딩하는 방법 배우기\n- React 배우기\n- Redux 배우기\n- React Native 배우기\n- R 언어 배우기\n- PHP 배우기\n- Ruby 배우기\n- Swift 배우기\n- 명령줄 사용법 배우기\n\n여기서 CodeCademy 개발자들을 위한 훌륭한 혜택 내용이었습니다. CodeCademy에 가입하여 필수 기술을 빠르게 익힐 수 있는 훌륭한 기회입니다. HTML, CSS 또는 JavaScript와 같은 프론트엔드 기술 또는 Python, Java, Ruby와 같은 백엔드 기술을 배우고 싶다면, 지금 CodeCademy에 가입하여 프로그래밍 및 개발 여행을 50% 할인된 가격으로 시작하세요.\n\n행운을 빕니다! 그리고 즐거운 학습 되세요!\n\nJavin","ogImage":{"url":"/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_0.png"},"coverImage":"/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_0.png","tag":["Tech"],"readingTime":2},{"title":"Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭","description":"","date":"2024-06-19 10:11","slug":"2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication","content":"\n\nSpring Boot은 사용의 용이성과 빠른 개발 능력으로 유명하지만, 애플리케이션이 커짐에 따라 성능 문제가 발생할 수 있습니다. Spring Boot 애플리케이션의 기능을 향상시키면 응답 속도가 향상되고 리소스를 효율적으로 사용하며 전반적으로 강력한 프로그램이 될 수 있습니다. 이 블로그 글에서는 캐싱, 프로파일링 및 효과적인 데이터베이스 연결에 중점을 두고 Spring Boot 앱의 속도를 최적화하기 위한 중요한 지침과 전략을 살펴볼 것입니다.\n\n![Spring Boot Performance Tuning Tips and Tricks for Optimizing Your Application](/assets/img/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication_0.png)\n\n- Spring Boot Actuator 사용하기:\n\n최적화를 시작하기 전에 병목 현상이 어디에 있는지 이해해야 합니다. 프로파일링 도구를 사용하여 애플리케이션의 성능 문제를 식별할 수 있습니다.\nSpring Boot Actuator가 제공하는 운영 준비 기능을 활용하여 애플리케이션을 모니터링하고 제어할 수 있습니다. 이 기능은 어플리케이션이 얼마나 잘 수행되고 있는지에 대한 정보를 제공할 수 있는 여러 엔드포인트를 갖추고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n    \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\n아래는 application.properties 파일에서 필요한 엔드포인트를 활성화하는 방법입니다:\n\n\nmanagement.endpoints.web.exposure.include=health,info,metrics,threaddump,env\n\n\n성능 메트릭\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nActuator의 /metrics 엔드포인트를 이용하면 애플리케이션의 메모리 사용량, 가비지 수집 및 스레드 활동과 같은 메트릭을 수집할 수 있습니다. 이를 통해 최적화가 필요한 영역을 파악하는 데 도움이 됩니다.\n\n2. 캐싱:\n\n캐싱을 사용하면 데이터로드를 줄이고 응답 시간을 단축할 수 있습니다. Spring은 최소한의 설치로 훌륭한 지원을 제공합니다.\n\n```java\n@SpringBootApplication\n@EnableCaching\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring Boot은 EhCache, Hazelcast, 그리고 Redis를 포함한 여러 캐시 제공자를 지원합니다. 예를 들어, EhCache를 사용하려면 다음 종속성을 추가하십시오:\n\n```js\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n    \u003cartifactId\u003espring-boot-starter-cache\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003enet.sf.ehcache\u003c/groupId\u003e\n    \u003cartifactId\u003eehcache\u003c/artifactId\u003e\n\u003c/dependency\u003e\n```\n\n캐싱 어노테이션을 사용하여 캐싱 동작을 지정할 수 있습니다:\n\n- @Cacheable: 메소드 결과를 캐싱할 수 있음을 나타냅니다.\n- @CachePut: 메소드 결과로 캐시를 업데이트합니다.\n- @CacheEvict: 캐시에서 항목을 제거합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n```java\n@Cacheable(\"books\")\npublic Book findBookById(Long id) {\n    return bookRepository.findById(id).orElse(null);\n}\n```\n\n3. 좋은 데이터베이스 상호작용\n데이터베이스 상호작용은 종종 응용프로그램의 병목 현상이 될 수 있습니다. 데이터베이스 성능을 최적화하기 위한 몇 가지 팁을 소개합니다. 아래는 HikariCP를 사용한 예시 설정입니다:\n\n쿼리 최적화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n색인 만들기: 데이터베이스 테이블이 올바르게 색인화되었는지 확인하세요.\n\n- 일괄 처리: 대량 삽입 및 업데이트에는 일괄 처리를 사용하세요.\n- 지연 로딩: 엔티티 관계에 대해 지연 로딩을 활용하여 불필요한 데이터 로딩을 피하세요.\n\nJPA와 Hibernate 팁\n\n- 검색 유형: 컬렉션에 대해 FetchType.LAZY를 사용하여 불필요한 데이터로딩을 피하세요.\n- 두 번째 레벨 캐시: Hibernate의 두 번째 레벨 캐시를 활성화하여 데이터베이스 조회를 줄이세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nQuery Optimization: JPQL이나 네이티브 쿼리를 사용하여 최적화된 쿼리를 작성하세요.\n\n## 지연 로딩의 예시\n\n```js\n@Entity\npublic class Author {\n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"author\")\n    private Set\u003cBook\u003e books;\n}\n```\n\n## 데이터베이스 연결 풀링\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스 연결을 효율적으로 활용하기 위해 연결 풀을 구성하세요:\n\n```js\nspring.datasource.hikari.maximum-pool-size=15\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.idle-timeout=30000\nspring.datasource.hikari.connection-timeout=20000\nspring.datasource.hikari.max-lifetime=1800000\n```\n\n## 모니터링 및 분석\n\n데이터베이스 성능을 모니터링하고 느린 쿼리 또는 연결을 식별하기 위해 /metrics 및 /trace와 같은 액추에이터 엔드포인트를 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSpring Boot 애플리케이션의 성능을 최적화하려면 프로파일링, 캐싱 및 효율적인 데이터베이스 상호작용의 조합이 필요합니다. 애플리케이션의 성능 특성을 이해하고 이러한 모베스트 프랙티스를 적용하여 높은 성능과 확장 가능성을 갖춘 애플리케이션을 개발할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication_0.png"},"coverImage":"/assets/img/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication_0.png","tag":["Tech"],"readingTime":4},{"title":"비동기 로깅 자바 앱에 제공되는 속도 향상","description":"","date":"2024-06-19 10:10","slug":"2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps_0.png\" /\u003e\n\n소프트웨어 개발의 급속한 영역에서 밀리초가 문제가 되며 시스템 응답성이 품질 요건인 곳에서 전통적인 동기식(sync) 로깅에서 비동기식(async) 로깅으로의 여정은 게임 체인저로 입증되었습니다. 경험 많은 개발자로써, 특히 고도의 환경에서 성능을 최적화하는 중요성을 알고 계실 것입니다. 본격적인 투자 은행 응용 프로그램을 작업해왔을 때, 최적의 응답 시간을 달성하는 것에 대한 과제를 직면했습니다. 그 경계를 넘어 올 수 있는 것 같았던 것 — 400 TPS. 감사 작업은 중요했지만, 전통적인 로깅은 속도를 늦추는 앵커였습니다. 그런 다음, 우리는 대담한 결정을 내렸습니다: 비동기식 로깅. 그리고 말씀드리지만, 그것은 저희가 필요했다는 것을 전혀 모르고 있는 게임 체인저였습니다.\n\n우리가 어떻게 성취했는지 궁금하신가요? 준비됐나요? 이 블로그는 즐거운 비동기식 로깅의 세계로 다가갑니다. 저는 개발 이야기의 중요한 순간에 대해 더욱 자세히 살펴볼 것이며, 비동기식 로깅으로의 전환과 전략적인 응용 프로그램 및 인프라 조정이 예상을 충족시키는데 그친 것이 아닌 더 초과했던 순간에 대해 알아볼 것입니다.\n\n간단한 Java 응용 프로그램을 만들어 비동기식 로깅의 영향을 시연해보겠습니다. 저는 log4j-api.2.17.1, log4-core.2.17.1 및 lmax disruptor.4.0.0 같은 종속성을 가진 JDK 17을 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드는 GitHub에서 사용할 수 있습니다.\n\n주 Java 클래스는 아래와 같이 보일 것입니다. 두 가지 메서드인 syncConsoleLogging()과 asyncLo4j2Log()를 포함하고 있습니다. syncConsoleLogging() 메서드는 메시지를 동기적으로 Log4j2를 사용하여 콘솔에 로깅하며, asyncLo4j2Log() 메서드는 메시지를 비동기적으로 로깅합니다. 이 예제는 비동기 로깅이 성능을 향상시킬 수 있는 방법을 이해하는 데 도움이 됩니다, 특히 로깅 작업이 많은 시나리오에서.\n\n아래 log4j2.xml 스니펫은 두 개의 appender인 RandomAccessFile과 Console을 정의합니다. RandomAccessFile appender는 특정 패턴 레이아웃을 사용하여 \"target\" 디렉토리의 \"async.log\" 파일에 메시지를 로깅하며, Console appender는 다른 패턴 레이아웃으로 시스템 콘솔에 메시지를 로깅합니다. 파일 appender는 성능을 향상시키기 위해 일괄로 flush되도록 설정되어 있습니다. 추가로 루트 로거는 \"info\" 레벨의 메시지를 파일 appender에 로깅하도록 구성되어 있고, \"syncLogger\"라는 별도의 로거가 콘솔 appender에 메시지를 로깅하도록 정의되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n        \u003c!-- Async Loggers will auto-flush in batches, so switch off immediateFlush. --\u003e\n        \u003cRandomAccessFile name=\"RandomAccessFile\" fileName=\"target/async.log\" immediateFlush=\"false\" append=\"false\"\u003e\n            \u003cPatternLayout\u003e\n                \u003cPattern\u003e%d %p %c{1.} [%t] %m %ex%n\u003c/Pattern\u003e\n            \u003c/PatternLayout\u003e\n        \u003c/RandomAccessFile\u003e\n        \n        \u003cConsole name=\"Console\" target=\"SYSTEM_OUT\"\u003e\n            \u003cPatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/\u003e\n        \u003c/Console\u003e\n \n\n\n위 코드를 실행하면 Async 로깅의 영향을 확인할 수 있습니다. 제 개인 노트북에서 실행 후 아래 출력을 확인했습니다. 이 시나리오에서 Async 로깅이 동기 로깅보다 약 72.98% 빠름을 보여줍니다.\n\n\n=== 처리 시간 요약 ===\n동기 로깅 시간 2184 ms\nAsync 로깅 시간 590 ms\n\n\n## Async 로깅의 장점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자바 애플리케이션에 대한 비동기 로깅은 성능 및 응답성 향상부터 높은 로깅 양을 처리하고 확장성을 향상시키는 장점을 제공합니다.\n\n성능 향상: 애플리케이션의 주 스레드는 로깅 I/O가 완료될 때까지 기다리지 않으므로 응답성이 빨라집니다.\n\n응답성: 로깅이 사용자 상호작용이나 다른 중요한 작업을 차단하지 않습니다.\n\n확장성: 로깅 인프라는 더 많은 로그를 수용하도록 순조롭게 확장되어 애플리케이션의 핵심 기능에 영향을 주지 않습니다. 로깅을 주 애플리케이션 스레드로부터 분리함으로써 비동기 로깅은 수평 확장을 가능케 합니다. Disruptor 풀에 더 많은 워커 스레드를 추가함으로써 로깅 성능을 확장하여 더 높은 로그 양을 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자원 사용량 줄이기: 주 스레드의 컨텍스트 전환 오버헤드와 메모리 소비를 최소화하세요.\n\n고장 허용성 향상: 메인 스레드로부터 로깅을 분리하여 애플리케이션 충돌을 방지하세요. 디스크 공간이 가득 찼을 때 애플리케이션이 멈추거나 정지된 적이 있나요?\n\n## 고려 사항:\n\n- 복잡성: 비동기 로깅은 동기 로깅보다 더 많은 설정과 이해를 요구할 수 있습니다.\n- 오류 처리: 잠재적인 로깅 오류와 큐 오버플로우를 처리하는 강력한 전략을 구현하세요.\n- 로그 메시지의 순서: 비동기 로깅은 특히 여러 스레드가 동시에 로깅할 때 로그 메시지의 순서가 뒤죽박죽이 될 수 있습니다. 로거는 로그 메시지의 순서를 보존하려 노력하지만 로깅의 비동기적인 특성으로 인해 결정론적이지 않은 동작을 가져올 수 있습니다.\n- 디버깅 및 문제 해결: 비동기 로깅 문제를 디버깅하는 것은 도전적일 수 있습니다. 특히 레이스 컨디션, 데드락 또는 예상치 못한 로깅 동작과 관련된 경우에는 신중한 분석과 테스트가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\n축하해요! 이제 비동기 로깅을 이해하고 활용할 지식으로 무장했어요. 앞으로 가서 느린 시스템을 뒤로 한 채 빠르고 반응성 있는 어플리케이션을 만들어보세요!\n\n이 블로그는 비동기 로깅의 매력적인 세계를 탐험하며, 로깅을 주 애플리케이션에서 분리함으로써 가치 있는 리소스를 확보하는 방법을 보여줬어요. 비동기 로깅이 전통적인 동기 로깅과 비교했을 때 성능을 놀라운 72% 향상시킨 실제 자바 예제를 살펴봤어요. 네 맞아요, 더 빠른 로깅, 더 행복한 사용자, 그리고 더 적은 스트레스를 받을 거예요! 하지만 어떤 도구든 그것의 한계가 있죠. 비동기 로깅은 복잡성을 추가하며 신중한 구성이 필요하다는 것을 기억하세요.","ogImage":{"url":"/assets/img/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps_0.png"},"coverImage":"/assets/img/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps_0.png","tag":["Tech"],"readingTime":4},{"title":"자바 HashSet 초보자가 꼭 알아야 할 내용","description":"","date":"2024-06-19 10:08","slug":"2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow_0.png\" /\u003e\n\n# 소개\n\nJava HashSet은 Java에서 가장 일반적으로 사용되는 데이터 구조 중 하나입니다. 고유한 요소를 저장하고 효율적인 조회를 수행하는 간단하면서 강력한 방법을 제공합니다. 이 기사에서는 HashSet이 무엇인지, 어떻게 사용하는지, 일반적인 작업 및 사용 사례에 대해 탐구할 것입니다. 이 기사는 이미 HashSet에 익숙한 사람들에게도 좋은 리프레셔 역할을 할 것입니다.\n\n# HashSet이란 무엇인가?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHashSet은 Java Collections Framework의 일부이며 Set 인터페이스를 구현합니다. 이는 해시 테이블 (실제로는 HashMap 인스턴스)에 기반하며 중복 요소를 허용하지 않습니다. HashSet의 주요 특징은 다음과 같습니다:\n\n- 중복 요소 없음: HashSet은 중복을 자동으로 처리합니다. 집합에 이미 존재하는 요소를 추가하려고 시도하면 무시됩니다.\n- 순서 없음: HashSet의 요소는 특정 순서로 저장되지 않습니다. 요소가 추가되고 제거됨에 따라 순서가 변경될 수 있습니다.\n- 효율적: HashSet은 해시 함수가 요소를 적절하게 버킷에 분산시키는 경우 추가, 제거, 포함 여부, 크기 등의 기본 작업에 대해 상수 시간 성능을 제공합니다.\n\n## HashSet는 어떻게 동작합니까?\n\nHashSet은 해싱을 사용하여 요소를 저장하고 검색합니다. HashSet에 요소를 추가할 때 다음 단계가 발생합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 해시 코드 계산: 객체의 hashCode 메서드를 호출하여 해시 코드를 계산합니다. 이 해시 코드는 객체의 메모리 주소를 간단히 나타내는 정수 값입니다.\n- 해시 코드 모듈로 연산: 그런 다음 해시 코드를 해시 테이블의 버킷(슬롯) 수로 나누고 나머지를 사용하여 요소를 저장할 버킷의 인덱스로 사용합니다. 이를 통해 해시 코드가 사용 가능한 버킷의 범위 내에 매핑되도록 합니다.\n- 충돌 처리: 두 요소가 동일한 해시 코드를 가지는 경우(충돌), 이들은 같은 버킷에 저장되지만 해당 버킷 내에서 목록 또는 트리 구조로 연결됩니다.\n- 요소 저장: 결정된 버킷에 요소가 저장되고 해당 요소에 대한 참조가 유지됩니다.\n\ncontains 또는 remove와 같은 작업을 수행할 때 요소의 해시 코드가 계산되고 동일한 프로세스를 사용하여 적절한 버킷이 찾아지며 해당 버킷에서 요소가 발견되거나 제거됩니다.\n\n## 왜 HashSet을 사용해야 하는가?\n\nHashSet은 다양한 시나리오에 적합하게 만드는 여러 장점을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 중복 제거: HashSet은 각 요소가 고유하다고 자동으로 보장합니다. 이는 중복이 허용되지 않는 항목의 컬렉션을 저장해야 하는 경우 유용합니다. 예를 들어, 고유한 사용자 이름이나 제품 ID 목록 등.\n- 효율적인 조회: HashSet은 추가, 삭제, 요소 존재 여부 확인과 같은 기본 작업에 대해 상수 시간 성능을 제공합니다. 이로 인해 캐싱 메커니즘이나 멤버십 테스팅과 같이 빠른 조회가 중요한 사용 사례에 이상적입니다.\n- 메모리 효율성: HashSet은 해시 테이블로 지원되기 때문에 다른 자료구조인 트리나 연결 리스트와 비교했을 때 특히 요소 수가 많을 때 더 메모리 효율적일 수 있습니다.\n- 집합 연산: HashSet은 합집합, 교집합, 차집합과 같은 수학적 집합 연산을 수행하는 데 사용할 수 있습니다. 이러한 연산은 데이터 필터링, 컬렉션 간의 공통 요소 찾기, 특정 항목을 집합에서 제외하는 등의 시나리오에서 유용합니다.\n\n## HashSet 생성\n\nJava에서 HashSet을 생성하는 것은 간단합니다. 다음은 간단한 예제입니다:\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetExample {\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        \n        // HashSet에 요소 추가\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n        \n        // HashSet 출력\n        System.out.println(\"HashSet: \" + set);\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 문자열의 HashSet을 만들고 세 가지 요소를 추가합니다. System.out.println 문은 세트의 요소를 출력합니다. 요소의 순서가 보장되지 않는 점을 유의하세요.\n\n## HashSet의 내부 작동\n\n내부 작동에 대해 더 알아보려면 다음 사항을 고려해보세요:\n\n- 해시 함수: 객체의 hashCode 메서드가 중요합니다. 잘 설계된 해시 함수는 요소를 균일하게 버킷에 분산시켜 충돌 가능성을 줄이고 성능을 유지합니다.\n- 버킷 구조: HashSet의 각 버킷은 실제로 연결된 리스트나 균형 잡힌 트리(대규모 집합의 경우)입니다. 여러 요소가 동일한 버킷으로 해싱되면 이 리스트/트리에 저장됩니다.\n- 로드 팩터: 로드 팩터는 해시 테이블의 용량이 자동으로 증가되기 전에 얼마나 가득 찰 수 있는지를 측정하는 지수입니다. 기본 로드 팩터 0.75는 시간과 공간 비용 사이의 적절한 균형을 유지합니다.\n- 다시 해싱: 요소 수가 로드 팩터와 현재 용량의 곱을 초과하면 해시 테이블이 리사이징되고(일반적으로 크기가 두 배로 늘어남) 요소가 새 버킷에 다시 해싱됩니다. 이를 통해 HashSet이 성능 특성을 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 내부 메커니즘을 이해함으로써, 자바의 HashSets의 효율성과 유연성을 더 잘 이해할 수 있습니다.\n\n# HashSets에서의 기본 작업\n\n## 요소 추가 및 제거\n\nHashSet에 요소를 추가하는 방법은 add 메서드를 사용하는 것입니다. 이미 HashSet에 요소가 있는 경우 다시 추가되지 않습니다. 요소를 제거하는 방법은 remove 메서드를 사용하여 수행할 수 있습니다. 이 작업을 보여주는 예제는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetOperations {\n    public static void main(String[] args) {\n        // Creating a HashSet\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        \n        // Adding elements to the HashSet\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n        set.add(\"Avocado\"); // Duplicate element, won't be added\n        \n        System.out.println(\"HashSet after adding elements: \" + set);\n        \n        // Removing an element\n        set.remove(\"Peach\");\n        \n        System.out.println(\"HashSet after removing Peach: \" + set);\n    }\n}\n```\n\n이 예제에서는 문자열 HashSet을 만들고 중복되는 \"Avocado\"를 포함한 네 가지 요소를 추가합니다. 중복 요소는 무시됩니다. 그런 다음 세트에서 \"Peach\"를 제거합니다.\n\n## 요소 확인\n\nHashSet이 특정 요소를 포함하는지 확인하려면 contains 메서드를 사용할 수 있습니다. 이 메서드는 요소가 있으면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetContains {\n    public static void main(String[] args) {\n        // Creating a HashSet\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n        \n        // Checking for elements\n        boolean containsAvocado = set.contains(\"Avocado\");\n        boolean containsGrape = set.contains(\"Grape\");\n        \n        System.out.println(\"Contains Avocado: \" + containsAvocado);\n        System.out.println(\"Contains Grape: \" + containsGrape);\n    }\n}\n```\n\n이 예제에서는 HashSet에 \"Avocado\"와 \"Grape\" 요소가 포함되어 있는지 확인합니다. 출력 결과에 따르면 \"Avocado\"가 존재하지만 \"Grape\"는 존재하지 않습니다.\n\n## 요소 반복\n\nfor-each 루프나 반복자(iterator)를 사용하여 HashSet의 요소를 반복할 수 있습니다. HashSet은 요소의 특정 순서를 유지하지 않기 때문에 반복 순서는 보장되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFor-Each Loop을 사용하는 방법\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetIteration{\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n\n        // For-Each 루프 사용\n        System.out.println(\"For-Each 루프 사용:\");\n        for(String fruit : set) {\n            System.out.println(fruit);\n        }\n    }\n}\n```\n\nIterator 사용하는 방법\n\n```java\nimport java.util.HashSet;\nimport java.util.Iterator;\n\npublic class HashSetIterator {\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n        \n        // Iterator 사용\n        System.out.println(\"Iterator 사용:\");\n        Iterator\u003cString\u003e iterator = set.iterator();\n        while(iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 for-each 루프와 반복자가 모두 HashSet의 요소를 순회하는 데 사용됩니다. 요소들은 콘솔에 출력되지만 순회 순서는 지정되지 않습니다.\n\n## HashSet의 크기\n\nHashSet에있는 요소 수를 얻으려면 size 메서드를 사용하세요. 이 메서드는 현재 집합에 있는 요소 수를 나타내는 정수를 반환합니다.\n\n```js\nimport java.util.HashSet;\n\npublic class HashSetSize {\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n        \n        // HashSet의 크기 가져오기\n        int size = set.size();\n        \n        System.out.println(\"HashSet의 크기: \" + size);\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예에서는 size 메서드를 사용하여 HashSet의 요소 수를 결정하고 그 값을 콘솔에 출력합니다.\n\n## HashSet 지우기\n\nHashSet에서 모든 요소를 제거하려면 clear 메서드를 사용할 수 있습니다. 이 메서드는 모든 요소를 제거하여 집합을 효과적으로 비웁니다.\n\n```js\nimport java.util.HashSet;\n\npublic class HashSetClear {\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n        \n        // HashSet 지우기\n        set.clear();\n        \n        System.out.println(\"HashSet 지우기 후: \" + set);\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시에서 clear 메서드는 모든 요소를 제거하여 빈 세트를 만듭니다.\n\n## HashSet이 비어 있는지 확인하기\n\nHashSet이 비어 있는지 확인하려면 isEmpty 메서드를 사용하십시오. 이 메서드는 세트가 요소를 포함하지 않으면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetIsEmpty {\n    public static void main(String[] args) {\n        // HashSet 만들기\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        \n        // HashSet이 비어 있는지 확인\n        boolean isEmpty = set.isEmpty();\n        \n        System.out.println(\"HashSet이 비어 있는가? \" + isEmpty);\n        \n        // 요소 추가 후 다시 확인\n        set.add(\"Avocado\");\n        isEmpty = set.isEmpty();\n        \n        System.out.println(\"요소를 추가한 후 HashSet이 비어 있는가? \" + isEmpty);\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제에서는 HashSet에 요소를 추가하기 전후에 비어 있는지 확인합니다. 출력 결과는 집합의 상태 변화를 반영합니다.\n\n# 고급 사용법 및 팁\n\n## HashSet에 사용자 지정 객체\n\nHashSet은 사용자 지정 객체를 저장할 수 있지만, 이러한 객체에서 equals 및 hashCode 메소드를 올바르게 재정의하는 것이 중요합니다. 이렇게 하면 HashSet이 두 객체가 동일한지 올바르게 판별하고 해싱을 효과적으로 처리할 수 있습니다. 다음은 사용자 지정 Person 클래스 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\nimport java.util.HashSet;\nimport java.util.Objects;\n\nclass Person {\n    private String name;\n    private int age;\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age \u0026\u0026 Objects.equals(name, person.name);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n    \n    @Override\n    public String toString() {\n        return name + \" (\" + age + \")\";\n    }\n}\n\npublic class HashSetCustomObjects {\n    public static void main(String[] args) {\n        HashSet\u003cPerson\u003e set = new HashSet\u003c\u003e();\n        set.add(new Person(\"Alice\", 30));\n        set.add(new Person(\"Bob\", 25));\n        set.add(new Person(\"Alice\", 30)); // Duplicate, won't be added\n        \n        System.out.println(\"HashSet: \" + set);\n    }\n}\n```\n\n이 예제에서 Person 클래스는 equals 및 hashCode 메서드를 재정의하여 이름과 나이가 같은 두 Person 객체를 동일하게 처리할 수 있도록합니다. HashSet은 이러한 메서드를 사용하여 요소를 올바르게 관리합니다.\n\n## 성능 고려사항\n\nHashSet은 기본 연산에 대해 상수 시간 성능을 제공하지만 여러 요인이 효율에 영향을 미칠 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 해시 함수: 좋은 해시 함수는 성능에 중요합니다. 요소를 균일하게 버킷에 분산시켜 충돌을 최소화해야 합니다. 제대로 구현되지 않은 hashCode 메서드는 많은 충돌을 일으켜 성능을 저하시킬 수 있습니다.\n- 초기 용량 및 로드 요소: HashSet의 초기 용량과 로드 요소(기본값은 0.75)는 리해싱이 발생하는 시점을 결정합니다. 리해싱은 해시 테이블을 크기를 조정하고 요소를 재분배하는 비용이 많이 드는 작업을 포함합니다. 예상 요소 수에 기반하여 이러한 매개변수를 조정하면 성능을 최적화할 수 있습니다.\n- 충돌 처리: 충돌이 발생하면 요소가 동일한 버킷 내에 연결 목록이나 균형 잡힌 트리에 저장됩니다. 빈번한 충돌은 성능을 떨어뜨릴 수 있으므로 해시 코드의 좋은 분포를 보장하는 것이 중요합니다.\n\n## 일반적인 사용 사례\n\nHashSets는 다양한 시나리오에서 다양하게 사용할 수 있습니다:\n\n- 중복 제거: HashSets는 목록에서 중복 요소를 필터링하는 데 이상적입니다. 예를 들어 더 큰 컬렉션에서 고유한 사용자 이름 목록을 얻기 위해 HashSet를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class RemoveDuplicates {\n    public static void main(String[] args) {\n        List\u003cString\u003e usernames = new ArrayList\u003c\u003e();\n        usernames.add(\"Alice\");\n        usernames.add(\"Bob\");\n        usernames.add(\"Alice\"); // 중복\n\n        HashSet\u003cString\u003e uniqueUsernames = new HashSet\u003c\u003e(usernames);\n        \n        System.out.println(\"고유한 사용자명: \" + uniqueUsernames);\n    }\n}\n```\n\n- 멤버십 테스팅: HashSet은 요소가 집합의 일부인지 확인하는 효율적인 방법을 제공합니다. 사용자가 특정 역할을 가지고 있는지 확인하거나 재고에 제품이 있는지 확인하는 등의 시나리오에서 유용합니다.\n\n```java\nimport java.util.HashSet;\n\npublic class MembershipTesting {\n    public static void main(String[] args) {\n        HashSet\u003cString\u003e roles = new HashSet\u003c\u003e();\n        roles.add(\"Admin\");\n        roles.add(\"User\");\n        roles.add(\"Guest\");\n\n        String roleToCheck = \"Admin\";\n        if (roles.contains(roleToCheck)) {\n            System.out.println(roleToCheck + \" 역할이 있습니다.\");\n        } else {\n            System.out.println(roleToCheck + \" 역할이 없습니다.\");\n        }\n    }\n}\n```\n\n- 집합 연산: HashSet은 합집합, 교집합, 차집합과 같은 수학적 집합 연산을 수행할 수 있습니다. 이러한 연산은 데이터 필터링, 컬렉션 간 공통 요소 찾기, 특정 항목을 세트에서 제외하는 등의 시나리오에서 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```java\nimport java.util.HashSet;\n\npublic class SetOperations {\n    public static void main(String[] args) {\n        HashSet\u003cString\u003e set1 = new HashSet\u003c\u003e();\n        set1.add(\"Avocado\");\n        set1.add(\"Peach\");\n        set1.add(\"Cherry\");\n\n        HashSet\u003cString\u003e set2 = new HashSet\u003c\u003e();\n        set2.add(\"Peach\");\n        set2.add(\"Dragonfruit\");\n        set2.add(\"Elderberry\");\n\n        // Union\n        HashSet\u003cString\u003e union = new HashSet\u003c\u003e(set1);\n        union.addAll(set2);\n        System.out.println(\"Union: \" + union);\n\n        // Intersection\n        HashSet\u003cString\u003e intersection = new HashSet\u003c\u003e(set1);\n        intersection.retainAll(set2);\n        System.out.println(\"Intersection: \" + intersection);\n\n        // Difference\n        HashSet\u003cString\u003e difference = new HashSet\u003c\u003e(set1);\n        difference.removeAll(set2);\n        System.out.println(\"Difference: \" + difference);\n    }\n}\n```\n\n위 예제들에서는 HashSet을 사용하여 중복 제거, 멤버십 테스트 수행, 그리고 합집합, 교집합, 차집합과 같은 집합 연산을 수행하는 방법을 보여줍니다.\n\n# 결론\n\nJava의 HashSet은 고유한 요소의 컬렉션을 관리하는 멋진 도구입니다. 요소 추가, 제거, 확인을 위한 효율적인 작업을 제공하여 성능과 고유성이 중요한 시나리오에 이상적입니다. HashSet의 기본 사항, 고급 사용법 및 주요 사용 사례를 이해함으로써 이 유연한 데이터 구조를 사용하여 더 효과적이고 효율적인 Java 프로그램을 작성할 수 있습니다. 중복 필터링, 집합 연산 수행, 사용자 정의 객체 관리와 같은 작업을 수행할 때 HashSet은 컬렉션 요구 사항에 대한 강력한 솔루션을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Java HashSet 문서\n- Java 컬렉션 프레임워크\n\n읽어 주셔서 감사합니다! 만약 이 안내서가 도움이 되셨다면, 하이라이팅, 좋아요, 댓글 작성, Twitter/X를 통해 연락 주시면 정말 감사하겠습니다. 이는 매우 고마우며 이와 같은 콘텐츠를 무료로 제공할 수 있도록 도와줍니다!","ogImage":{"url":"/assets/img/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow_0.png"},"coverImage":"/assets/img/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow_0.png","tag":["Tech"],"readingTime":13}],"page":"29","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"29"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>