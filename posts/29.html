<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/29" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/29" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="테스트 주도 개발TDD을 피해야 하는 이유" href="/post/2024-06-22-FuckTestDrivenDevelopment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="테스트 주도 개발TDD을 피해야 하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-FuckTestDrivenDevelopment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="테스트 주도 개발TDD을 피해야 하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">테스트 주도 개발TDD을 피해야 하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리더십 단위 테스트 작성하는 방법 2024년 최신 가이드" href="/post/2024-06-22-LeadershipUnitTests"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리더십 단위 테스트 작성하는 방법 2024년 최신 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-LeadershipUnitTests_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리더십 단위 테스트 작성하는 방법 2024년 최신 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">리더십 단위 테스트 작성하는 방법 2024년 최신 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="엔지니어링 리더십 가이드 비용과 경비 추적하는 방법" href="/post/2024-06-22-TheEngineeringLeadershipPlaybookTrackingCostsandExpenses"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="엔지니어링 리더십 가이드 비용과 경비 추적하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TheEngineeringLeadershipPlaybookTrackingCostsandExpenses_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="엔지니어링 리더십 가이드 비용과 경비 추적하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">엔지니어링 리더십 가이드 비용과 경비 추적하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 IT 직업 시작 전에 무시했던 위험 신호들 8가지" href="/post/2024-06-22-TheRedFlagsIIgnoredBeforeStartingaNewTechJob"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 IT 직업 시작 전에 무시했던 위험 신호들 8가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TheRedFlagsIIgnoredBeforeStartingaNewTechJob_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 IT 직업 시작 전에 무시했던 위험 신호들 8가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">새로운 IT 직업 시작 전에 무시했던 위험 신호들 8가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="요구사항 및 API 분석하는 방법" href="/post/2024-06-22-RequirementsAPIAnalysis"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="요구사항 및 API 분석하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-RequirementsAPIAnalysis_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="요구사항 및 API 분석하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">요구사항 및 API 분석하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년에 유용할 고급 Shell 스크립팅 명령어 9선" href="/post/2024-06-22-AdvancedShellScriptingCommandsthatcanbehelpfulin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년에 유용할 고급 Shell 스크립팅 명령어 9선" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AdvancedShellScriptingCommandsthatcanbehelpfulin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년에 유용할 고급 Shell 스크립팅 명령어 9선" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년에 유용할 고급 Shell 스크립팅 명령어 9선</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="링크를 클릭했을 때 벌어지는 네트워킹 과정 " href="/post/2024-06-22-TheNetworkingbehindclickingalink"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="링크를 클릭했을 때 벌어지는 네트워킹 과정 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TheNetworkingbehindclickingalink_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="링크를 클릭했을 때 벌어지는 네트워킹 과정 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">링크를 클릭했을 때 벌어지는 네트워킹 과정 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유" href="/post/2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까" href="/post/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로그래밍 언어를 만드는 단계별 가이드" href="/post/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로그래밍 언어를 만드는 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로그래밍 언어를 만드는 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">프로그래밍 언어를 만드는 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">32<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link posts_-active__YVJEi" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"테스트 주도 개발TDD을 피해야 하는 이유","description":"","date":"2024-06-22 23:49","slug":"2024-06-22-FuckTestDrivenDevelopment","content":"\n![이미지](/assets/img/2024-06-22-FuckTestDrivenDevelopment_0.png)\n\n안녕하세요!\n\n저희는 현재 브랜딩 전략을 개발 중에 있으며 곧 자세한 정보를 공유할 예정입니다. 현재 Efsun은 포괄적인 게임 엔진 플랫폼으로, 우리는 이후 Efsun 이름 아래에서 기사를 발표하고자 합니다. 여기 TDD에 관한 새로운 기사가 있습니다. 오래 여정을 준비해주세요.\n\n# 서식지\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 기사에서는 역사, 사회학, 심리학 등과 같은 학문에 크게 의존하고 있어요. 소프트웨어 분야에 깊이 몰두하고 있지만, 인간의 영향력이 여전히 중요합니다. 인공지능이 모든 것을 독점하지는 못하기 때문이죠. 코딩과 기술에 종사하는 사람들은 역사, 사회학, 심리학과 같은 보다 광범위한 요인들에 불가피하게 영향을 받고 있어요.\n\n결국, 모든 현상을 기술적이거나 방법론적인 시각만으로 이해할 수 없어요. 이에 따라, 저는 TDD(테스트 주도 개발) 패러다임을 비판하거나 검토함으로써 특히 문제가 있다고 생각되는 사례를 강조하겠습니다. 또한, 제 사회학적인 통찰력이 다양한 분야에 적용될 수 있다고 주장하고 싶어요.\n\n# 무책임함\n\n저는 사람들을 관찰하는 것에 깊은 매혹을 느낍니다. 이는 동시에 즐겁고 매우 깨우침을 줍니다. 저는 인류의 가장 강력한 중독은 헤로인이 아니라 오히려 선뜻 따르고 순종하며 믿음에 기대하는 성향이라고 믿어요. 사람들은 어떤 물질보다 의심하지 않는 순종과 믿음에 더 중독되어 있는 것처럼 보입니다. 이 무조건적인 순종의 근원적인 이유는 놀랍게도 간단해요: “무책임함.”\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n부주의는 모든 계층과 분야의 개인들에게 궁극적인 피난처이자 탈출이죠. 인간의 자부심이 직접적으로 받아들이지 못하게 하지만, 문제없는 복종과 믿음으로부터 오는 책임과 양심에서의 해방만큼 자유로운 약이 존재하지 않습니다.\n\n한번 잠시 멈추어서 생각해보세요. 회사의 업무를 계속해서 완전한 책임을 지는 것이 더 직접적이고 선호되는 방식일까요, 아니면 그 책임을 매니저나 누군가에게 넘기는 것이 낫을까요?\n\n성공할 때, 대부분의 직원들은 대개 \"상사가 모든 단계에 대해 지시했기 때문에 칭찬은 그 들에게, 나에게는 아닌 것\"이라고 말하지 않습니다. 그러나 실패나 문제가 발생할 때, 대부분의 직원들은 \"상사가 나에게 그렇게 하라고 했기 때문에 책임은 그들이 져야 한다\"고 주장하는 경향이 있습니다. 네, 친애하는 독자여, 솔직해지죠, 아마 당신도 이와 같을 것입니다.\n\n\"상사가 지시한 대로 했을 뿐이에요\"라고 생각하면 마음이 편안해지기도 했나요? 어려운 순간에는 종종 책임을 다른 사람에게 전가하는 게 더 쉬운 법이지요. 많은 사람들이 누군가에게 책임을 맡기는 데 대한 안도를 경험해본 적이 있습니다. 솔직히 말해서, 그 느낌이 환상적이었죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n종교들이 메시아, 마다이, 그리고 성인 등의 구원자 인물을 가지는 이유는 우리가 용기와 인내심이 부족할 때 다른 누군가가 부담을 지도록 바라기 때문입니다. 이 경향은 다양한 종교에서 구원자 인물들이 나타나는 것을 통해 볼 수 있으며, 우리들이 어려운 업무를 처리할 수 있는 타인을 찾으려는 성향을 대변합니다.\n\n당신이 무언가를 개발하고, 코드를 작성하고, 실패한다면 누군가가 그 책임을 짊어지고 결과에 직면합니다. 정말 놀라운 순환 구조가 아닌가요?\n\n우리는 종종 주장합니다. \"코딩 대신 이메일을 작성하는 것\"이거나, \"바쁘게 이메일을 보내느라 코딩할 시간이 없다\"는 것입니다. 간단히 말해, 대부분의 이메일은 책임을 피하기 위한 수단에 불과합니다. 아무도 \"이 작업을 완료하겠습니다\"라고 말하려고 하지 않아서, 우리는 책임을 회피합니다.\n\n# The Poison\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전문가 세계에서 약 23년을 보낸 경험이 있습니다. 20년 이상 소프트웨어 또는 IT 작업으로 수입을 올린 적이 있어요. 제 여정은 최악의 상사가 있는 회사, 가장 흥미로운 스타트업, 가장 명문적인 기업 환경을 경험했어요.\n\n그래서 거의 모든 수준에서 독소를 만났고 여러 가지 쓴 경험을 했어요. 소프트웨어 산업에서 모든 고통 속에서 특히 치명적인 두 가지 독약을 식별했어요:\n\n- 근본적인 문제 대안보다 빠른 해결책을 선택하고 책임을 식별하는 것.\n- 방법론을 코드와 코드 품질의 세부사항보다 더 중요하게 여기는 것.\n\n# Test-Driven Development Creed\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 멘토들은 저가 존경하며, 하지만 절대로 그들이나 다른 누군가의 신념이나 말을 맹목적으로 받아들이지 않습니다.\n\n종교와 분파의 공통 특성은 검토와 비판에 대한 저항이라고 볼 수 있습니다. 그래서 제가 TDD를 사이비 종교나 종교로 특징지어 보는 겁니다. 그들은 교리주의적이고 정확하며 무오류로 간주됩니다. 이 시점에서 Google과 ChatGPT를 통해 TDD를 탐험해보겠습니다. 두 플랫폼에 동일한 질문을 해주세요.\n\n제가 Opera 브라우저를 통해 이 질문들을 제기했는데, 개인 탭과 VPN을 사용했습니다. 가능한 한 브라우저 히스토리가 결과에 미치는 영향을 최소화하기 위해 노력했습니다. (원하시는 설정을 사용하셔도 됩니다.)\n\n- Test-Driven 개발의 비용은 무엇입니까?\n- Test Driven Development의 단점은 무엇입니까?\n- Test Driven Development 비용은?\n- Test Driven Development의 단점은?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과는 Google과 ChatGPT가 TDD에 대해 과도하게 부정적인 응답을 제공하는 것을 피하는 것을 보여줍니다. 그들은 약점을 강조할 때에도 그것을 장점과 균형있게 조화시키려고 노력합니다. 부정적인 측면이나 비판은 일반적으로 완화되거나 최소화됩니다.\n\n# 테스트 주도 개발의 실제 비용\n\n내 관측에서는 이 문제에 대한 실질적인 연구를 만나지 못했습니다. 이 주제에 대한 실질적인 연구가 부족합니다. 몇몇 기사는 TDD가 개발 시간을 13-30% 증가시킨다고 제안합니다. 이런 경우에 대부분 최악의 경우 시나리오를 생각하며, 대략 30%로 고려합니다. 그럼에도 불구하고, TDD에 필요한 추가 시간은 훨씬 더 높을 것으로 믿어져서, 60%를 초과할 수도 있습니다. TDD 유지 관리 단계를 계산하는 것은 거의 불가능하기 때문입니다.\n\n이 관점을 더 탐구하되, TDD의 심층 기술적 측면이 아닌 개발 주기에 초점을 맞추어보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Test Driven Development](/assets/img/2024-06-22-FuckTestDrivenDevelopment_1.png)\n\n프로젝트 내에서 테스트할 클래스와 함수들이 결정되며, 이를 위한 원자 단위 테스트가 작성됩니다.\n\n- 함수 성공과 유닛 테스트에 관한 사항\n\n- 함수는 유닛 테스트를 통과하면 성공으로 간주됩니다.\n- 함수가 유당 테스트를 통과하지 못하면, 밑바닥의 이슈나 버그를 해결하기 위해 대응하도록 유도됩니다.\n- 유당 테스트는 함수의 성공을 검증하며, 어떤 실패도 버그 해결과 재테스트의 필요성을 나타냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. TDD에서 'Refactoring'으로 버그 해결하는 것은 종종 'Refactoring'이라고 합니다만, 이 용어를 혼동하지 않는 것이 중요합니다.\n\n- TDD 주기에서 버그 해결은 'Refactoring'으로 분류되지만, 이는 전통적인 버그 해결 방법과 구분됩니다.\n- TDD 과정은 버그 해결을 'Refactoring'으로 레이블링하지만, 이는 일반적인 버그 해결 방법과 다릅니다.\n\n3. 버그 해결과 리팩터링 구분하기\n\n- TDD의 'Refactoring' 단계를 통해 버그를 해결하는 것은 표준적인 버그 해결과 동일하지 않습니다.\n- TDD의 버그 수정과 실제 리팩터링 활동을 구별하는 것이 중요합니다.\n- TDD에서 'Refactoring'의 일환으로 버그를 해결하는 것은 전통적인 버그 해결 방법과 동의어가 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서 TDD 리팩터링과 더 리팩터링은 꽤 다른 전략입니다. TDD를 간단히 설명하자면 리팩터링은 버그를 해결하는 것뿐이에요.\n\n질문들\n\n- TDD를 구현하면 버그 없는 프로젝트를 보장할까요? 그렇지 않을 때는 어떻게 대응하나요?\n- TDD를 사용하는 프로젝트에서 버그를 찾는 것은 모순적이지 않나요?\n- TDD 원칙을 준수하는 프로젝트에서도 어떻게 버그가 발생할 수 있나요?\n- 프로젝트에서 TDD를 사용할 때 UAT 테스트에서 발견된 버그를 식별하고 해결하는 방법은 무엇인가요?\n- TDD를 사용해도 최종 제품에서 최종 사용자가 버그를 발견하는 것은 정상인가요?\n- TDD를 적용한 프로젝트에서 최종 사용자가 만난 버그를 잡고 해결하기 위해 어떤 단계를 거쳐야 할까요?\n\n위 질문들을 확장하고 다양화할 수 있지만, TDD가 충분히 답하지는 못할 수도 있어요. TDD는 이상적인 실험실 환경, 특정 매개변수, 알려진 계산 및 예측 가능한 반환 값으로 작동한다는 가정하에 운영됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결과적으로 작성된 테스트는 오직 이 이상적인 시나리오만 다룹니다. 하지만 사용자나 테스터들이 예기치 못한 동작을 수행하는 현실 세계에서는, TDD로 개발된 많은 함수들이 기대와 다르게 동작하지 않거나 에러를 발생시킬 수 있습니다. 다시 말해, 사용자나 테스터가 예기치 않은 동작을 수행할 때, 많은 TDD 적용 함수들이 기대대로 동작하지 않거나 에러를 발생할 수 있습니다.\n\n고등학교 화학에서 우리는 일반적인 조건과 이상적인 조건이 다르다는 것을 알고 있습니다. 예를 들어, 어떤 자동차 제조사는 그들의 T 모델이 100 km당 5리터를 사용한다고 명시할지라도, 이것은 제조사에 의해 설정된 이상적인 조건에 기반한 것이며, 90 km/h의 일정 속도를 의미합니다.\n\n실제 세계에서는 다양한 조건으로 인해 결과가 다르게 나타나며, 심지어 반복적인 테스트도 변동성을 보일 것입니다. 따라서, 이 차이점은 이상적인 조건과 일반적인 조건 간의 차이를 강조하며, TDD가 비이상적인 조건에서 기능적이고 효과적이지 않을 수 있다는 것을 나타냅니다.\n\n복잡하거나 긴 예시 대신, 제품을 조회하는 간단한 UI - API Backend - Database 흐름을 검토해보겠습니다. 어떤 이유로 제품에 연속적인 ID를 할당하고 이 ID를 쿼리에서 사용합니다. 사용된 기술 스택은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- **UI** – JavaScript\n- **API Backend I** – JavaScript\n- **API Backend II** – Java\n- **Database** – MongoDB\n\n**Query Flow** – UI – API Backend I – API Backend II – Database\n\nJavaScript은 타입 안전하지 않은 언어입니다. 데이터 형식에 관계없이 실행하고 작업을 수행하려고 합니다.\n\nJava는 타입 안전한 언어로 데이터 형식에 기반하여 작동합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMongoDB은 NoSQL 데이터베이스이며, 순차 ID가 숫자로 정의되어 있을 때 형식 검사가 항상 보장되지는 않습니다. 따라서 소프트웨어 개발자는 형식 검사를 관리하기 위한 조치를 취해야 합니다.\n\n### 테스트 유형\n\n- 단위 테스트\n- 통합 테스트 (INT)\n- 사용자 수용 테스트 (UAT)\n- 사용자 경험 테스트 (최종 또는 실제 테스트)\n\n# 단위 테스트의 다양한 측면\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제품 쿼리 플로우를 검토해 볼까요? 각 쿼리 단계에 대해 요구 사항에 따라 하나 이상의 함수를 만들 수 있습니다. 우리는 몇 가지를 만들었어요.\n\n- UI에서 사용자가 제품 ID를 입력할 수 있는 폼이 생성됩니다.\n- 백엔드 I가 UI에서 요청을 처리하고 편집한 후 백엔드 II로 전달됩니다.\n- 백엔드 II가 백엔드 I로부터의 요청을 처리하고 데이터베이스로 전송하여 결과를 검색한 후 백엔드 I로 반환합니다.\n- 백엔드 I가 백엔드 II의 결과를 처리하고 UI로 전송합니다.\n- UI가 사용자에게 결과를 표시합니다.\n\n제품 쿼리 테스트 플로우를 검토해 볼까요? 이 테스트는 단위 테스트로 간주되며, 서로 독립적으로 작성하고 실행해야 합니다. 이러한 테스트에는 유형 또는 Null 체크 등이 포함될 수 있습니다.\n\n- UI: 폼의 필드를 유효성 검사하는 일부 단위 테스트가 포함된 UI가 작성됩니다.\n- 백엔드: UI에서 요청을 처리하는 백엔드 함수에 대한 단위 테스트가 작성됩니다.\n- 데이터베이스: 데이터베이스 필드와 사양의 무결성을 확인하는 단위 테스트를 작성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 이 테스트들은 서로 독립적입니다. 또한 UI -` 백앤드 I -` 백앤드 II -` DB에 걸쳐야 하는 통합 테스트도 작성해야 합니다. TDD에 열정적이고 주석을 달거나, 로깅하거나, 디버깅하는 것을 피하려는 사람들을 위해 이후에 이에 대해 다루겠습니다.\n\n이상적인 TDD 시나리오에서, 테스트 대 코드의 비율은 극단적일 수 있습니다. 1 대 3 또는 1 대 4처럼 말이죠. 만약 한 줄의 코드를 작성하고, 버그 없이 작동하는 것을 세 줄의 테스트 코드로 확인할 수 있다면, 분명 TDD의 열렬한 지지자가 될 것입니다.\n\n\"유닛 테스트의 다채로움\"을 다시 살펴봅시다. 이 ID 필드를 대상으로 설계된 테스트에서 어떤 일들이 벌어질 수 있을까요?\n\n- Null 값 확인\n- 숫자 유효성 검사\n- 알파벳 및 숫자 조합 유효성 검사\n- 길이 확인\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI: 자바스크립트로 코딩되어 있기 때문에 이러한 검증 사항들을 세심하게 설정하고 테스트해야 합니다. 어느 하나도 놓치거나 건너뛸 여유가 없기 때문에 모든 검증을 해야 합니다. 1개의 필드 → 4가지의 검증 → 4개의 단위 테스트로 생각해 보세요.\n\n백엔드: UI가 REST 요청을 통해 백엔드와 상호 작용하는데, 이것을 1개의 필드 당 1개의 API → 1개의 JSON 파서 → 4가지의 검증 → 5개의 단위 테스트로 개념화할 수 있습니다.\n\n데이터베이스: 1개의 영역 → 적어도 4개의 단위 테스트\n\n이러한 검증 사항들을 하나의 단위 테스트에 포함할 수도 있고, 여러 개의 테스트를 작성할 수도 있습니다. 단일 책임 원칙을 자랑스럽게 지키기 위해 TDD 추종자들은 여러 개의 테스트를 옹호할 것입니다. 😊\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 문제 발생\n\n이상적인 상황에서 TDD는 마치 원더랜드 같을 수 있어요. 하지만 현실 세계의 복잡성은 더 많은 주의를 요구합니다. 앞서 언급한 모든 점검 사항들을 잊게 되면 광범위한 부정적 영향이나 실패로 이어질 수 있어요. 이런 상황에 직면할 때 TDD의 신뢰성은 매우 중요해집니다. 우리는 예기치 않은 것에 대해 자세히 살펴보겠습니다.\n\n모든 필요한 점검을 완료하고 성공적인 테스트 결과를 달성한 후, JavaScript와 웹 브라우저의 데이터 무결성에 관한 역사적인 신뢰성 부족에 주목하는 것이 중요합니다. JavaScript와 웹 브라우저는 데이터 무결성을 유지하는 데 일관성이 부족하다는 것으로 잘 알려져 있어요.\n\n- 브라우저 오류가 발생하는 경우를 가정해 보겠습니다: 사용자가 제품 검색 필드에 숫자가 아닌 문자를 동시에 입력하여 조회를 시작할 수 있어요. 브라우저는 이 작업을 제한 없이 허용할 수 있습니다.\n- 악의적인 사용자가 API를 중간에 가로채서 제품 쿼리에 예상치 못한 문자를 삽입할 수 있어요.\n- UI와 백엔드 API에 대해 서로 다른 개발 노력이 진행되어 프로젝트 전반에 일관적으로 이러한 제어가 구현되지 않을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI에서 잘못된 ID를 받았고 API-I에서 숫자-알파벳 검사를 놓친 경우 또는 테스트하지 않은 경우, TDD 또는 당신이 취할 행동은 무엇인가요?\n\n- 백엔드 API-I는 JavaScript로 구성되어 있어서 타입 안전을 강제하지 않고 요청을 그 규칙에 따라 처리한 후 API-II로 전달합니다.\n- 일부러든 실수든 백엔드 API-2 내부의 오류 처리나 타입 체크에 문제가 발생하면 요청이 여전히 데이터베이스로 전달됩니다.\n- 데이터베이스 요청이 단순한 get/select 작업임을 고려하면, 데이터베이스는 쿼리와 일치하는 제품을 찾을 수 없다는 응답을 반환할 가능성이 높습니다. 오류를 throw하지 않습니다.\n\n이러한 과정에서 오류나 이상이 없다면 사용자에게 제품이 없음을 알려줍니다. 그러나 이 요청이 어떤 이유로든 반복되거나 프로세스가 제대로 작동하지 않으면 사용자는 제품을 항상 찾을 수 없을 수 있습니다.\n\n심각한 문제는 사용자/소비자가 다른 API를 사용하는 경우 요청이 끊임없이 반복될 수 있다는 것입니다. 그 API는 올바른 응답을 받을 때까지 서비스를 계속 시도할 수 있습니다. TDD는 이러한 시나리오에 어떻게 대응할까요? (이러한 시나리오는 곱셈될 수 있습니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예기치 못한 상황에서 API와 TDD는 모두 마비 상태에 놓일 수 있습니다. TDD가 의인화된다면, 그것은 움직이지 않는 물고기와 같을 것이며 대응할 수 없을 겁니다. 프로젝트 구성 요소 전체의 개발자들은 모든 단위 테스트가 성공적으로 실행되었고 이전에 이러한 문제를 만나지 않았다고 주장할 수 있으며, \"내 컴퓨터에서는 작동하는데\" 증후군으로 이어집니다.\n\n작동 중에 오류를 감지 못할 경우 문제의 흔적이나 실마리가 없어서 새로운 테스트 시나리오를 개발하고 실행하기 불가능합니다. 그런데, TDD의 신성하고 변혁적인 힘이 어디에 있을까요?\n\n# 진정한 영웅 — 디버그와 로그\n\n이러한 상황에서 프로젝트 테스터 또는 모든 개발자들은 힘을 모아 시나리오를 재현하고 전체 프로젝트를 세심하게 디버깅하고 중요한 위치에 임시 로그를 남겨야 합니다. 디버깅에 대해 주저하는 사람이나 가치를 부정하는 사람들에게: 디버깅은 반드시 필요합니다. 디버깅을 싫어하거나 디버깅이 쓸모없다고 말하는 사람들에게는, 디버깅이 당신의 장례식을 치를 것임을 확신하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 우리가 주요한 실패나 큰 실수에 대해 이야기한다면, 그것은 결함이 있는 이러한 시나리오의 반복입니다. 대부분의 경우, 이러한 결함이 있는 시나리오를 반복할 수 없습니다. 숙련된 개인이나 광범위한 프로젝트에 깊이 참여한 사람들은 사용자가 마주한 동일한 오류를 잡고 반복하는 것이 종종 오류 자체를 해결하는 것보다 더 어려울 수 있다는 것을 알고 있습니다.\n\n이러한 예측할 수 없는 버그를 포착하는 가장 효과적인 방법은 절망적인 테스트 작성이나 끝없는 테스트 실행이 아니라 견고한 오류 처리 및 로깅을 구현하는 것입니다. 이렇게 함으로써 발생한 오류를 신속하게 식별하고 기록할 수 있습니다.\n\n많은 개발자들과 협업할 때 로깅을 옹호할 때 종종 저항을 마주합니다. 그들은 마치 나를 악마로 보는 듯 합니다. 로깅을 코드에 불필요한 부담으로 여기는 경향이 있습니다. 그리고 일부 개발자는 로깅을 코드 작업의 불필요한 복잡성으로 여기기도 합니다. 그들에 따르면 프로그래밍 언어나 응용 프로그램 서버가 로깅을 충분히 처리하므로 개발자들이 로깅에 시간을 투자할 필요가 없다고 합니다. 이러한 편견 있는 개발자 유형은 TDD나 Agile Development와 같은 종교가 등장한 후에 매우 흔해졌습니다.\n\n# 기억하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저의 개인 경험을 공유하고 싶습니다. 제 목표는 제 행동을 자랑하거나 특정 회사나 팀을 탓하는 것이 아닙니다. 대신 대규모 프로젝트와 팀의 맥락 속에서 발생한 작은 실수들이 어떻게 크고 해결하기 어려운 문제로 번질 수 있는지를 강조하고 싶습니다.\n\n몇 년 전, 저는 터키에 있는 유럽 최대의 결제 서브시스템 개발자 회사의 R\u0026D 사무실에서 잠시 일했습니다. 그 경험이 짧았지만 여전히 지속적인 인상을 남겼습니다. 그 회사의 주요 결제 인프라는 약 20만 줄의 코드를 포함했습니다. 저의 임기 중에는 구조적인 실수로 인해 다양한 은행을 위한 맞춤화가 코드 복제로 이어져 코드베이스가 80만 줄로 확장되었습니다. 저는 그 회사의 규모를 강조하고 코드 저장소의 복잡성을 강조하고 싶었습니다.\n\n처음에 저는 약 20만 줄의 코드로 이루어진 다른 프로젝트를 관리하도록 지정되었는데, 이게 제 첫 만남이었습니다. 새로운 직장에서는 보통 처음 3~4개월 동안 모든 것과 모든 사람을 관찰하고 듣는 것을 선호합니다. 모든 측면에 곧바로 뛰어들거나 즉시 모든 일에 참여하는 것을 삼가고 있죠.\n\n저는 합류했을 때 이미 제 팀이 심각한 문제에 직면하고 있었습니다. 첫날에 동료들이 그 문제에 대해 화이트보드에서 토의하고 있는 상황이었습니다. 테스트와 디버깅을 45~50일 동안 진행한 후에 팀은 \"저희는 철저히 테스트하고 디버깅했지만 고객이 오류를 경험했던 시나리오를 재현할 수 없어 문제를 정확히 파악하고 해결할 수가 없습니다.\" 라며 한탄하고 있었습니다. 동료들에게 몇 가지 질문을 하면서 함수의 작동 및 가능한 시나리오에 중점을 두었습니다. 그들의 설명으로 문제의 근원이 우리 함수에 있지 않다고 확신하였습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 API를 사용하고 있다고 상상해봐요. 60일 후에 문제가 우리 쪽이 아닌 당신 쪽에서 발생했다고 말한다면 나를 대신해 꽤 좌절스러울 거 같아요. 60일이나 걸려 버그가 우리 것인 걸 발견하는 데, 만약 버그가 당신 것이었다면 360일이 걸렸을 것이고, 내 칭찬의 끝은 상당히 어둡지 않았을까 생각해봐요.\n\n상황을 뒤집어 생각하고, 당신이 그 회사의 소유주이거나 매니저라고 상상해봐요. 한 프로젝트에서 미해결된 문제가 60일 동안 계속되고, 당신의 팀은 원인을 명확히 찾아내지 못했다. 고객들이나 최고 관리자들이 점점 스트레스를 받고 공격적이었죠. 그런데 새 팀원이 조인하여 콘솔 로그에 몇 줄을 추가하는 걸 제안하면서 상황이 바뀌었어요. 마지못해 당신의 팀이 이를 실행하자, 수 시간 내에 문제가 당신 것이 아닌 파트너의 외부 API로 인한 것임을 발견했죠.\n\n이 경우에서 어떤 부분이 가장 좌절스럽거나 실망스러울까요?\n\n- 1,440시간 동안 문제를 찾지 못했지만, 새로 온 누군가에 의해 4시간 만에 해결되었네요. 어떻게 그런 일이 일어났을까요?\n- 1,440시간 동안 고객들과 다른 프로젝트 소유자들이 삶을 힘들게 했네요.\n- 1,440시간이 지난 뒤 문제가 당신의 잘못이 아니었음을 깨달았을 때, 상당한 탓과 좌절을 느낄 수 있었네요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다시 TDD\n\n이 API는 이스탄불의 활발한 교통 수집 시스템을 관리하는 다섯 개 플랫폼 중 하나의 구성 요소일 뿐입니다. 다섯 개의 다른 기관이 통합 및 동기화된 응용 프로그램을 사용하여 결제 거래를 처리하고 있습니다. 빠르게 몇 가지 질문을 떠올려 봅시다.\n\n- 5개의 플랫폼이 통합적으로 작동할 때 단위 테스트는 얼마나 중요한가?\n- 하나가 제대로 사용하지 않으면 모든 것이 망가질까요?\n- 이 혼돈을 어떻게 관리할까요? 혹시 누가 그런 역할을 맡을 수 있을까요?\n- 소프트웨어 신뢰성과 품질 측면에서, Agile, 워터폴 또는 다른 방법론을 사용하더라도 통합 및 UAT 테스트가 철저하지 않으면 중요한가요?\n- 통합 및 UAT 테스트가 철저하지 않으면 프로그래밍 언어와 디자인 패턴이 중요할까요?\n- 생산 환경에서 오류를 발견하는 데 몇 주가 걸리는데, 위 세 가지를 신경 쓰는 것이 의미가 있을까요?\n\n가장 중요한 질문은 다음과 같습니다: 우리는 TDD를 사용하여 이상적인 조건을 철저히 테스트하고 프로젝트를 성공적으로 배포했습니다. 그런데 간단한 오류나 복잡한 오류를 포착하고 관리할 수 있는 메커니즘이 없습니다. 우리의 응용 프로그램 또는 API가 다양한 사용자나 플랫폼에 의해 다양한 방식으로 액세스되는 상황에서 이러한 신흥 오류를 어떻게 해결할 것인가요? 오류 관리가 불가능하거나 하찮다면, 왜 TDD와 같은 신성한 방법론에 투자하는 건가요? 그냥 코딩하고 배포하면 되지 않나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# TDD에 대한 소강점, 결론\n\n개별적으로 볼 때, 나는 TDD 패러다임에 대해 이의를 제기할 만한 것이 거의 없다고 생각한다. 그러나 광범위한 의미에서 보면, TDD를 완벽하고 틀림없는 해결책으로 다루는 것에 반대한다. 한 때 애자일 방법론과 마이크로서비스가 비슷한 방식으로 찬양받았던 적이 있었다.\n\n예를 들어 제시된 예시처럼 유일하고 반복할 수 없는 상황에서는 TDD나 기타 패키지 솔루션 방법론이 비효과적이거나 마비 상태에 빠질 수 있다. 대규모 프로젝트에서 개발자들이 마주하는 오류 중 적어도 15~20%는 이러한 반복할 수 없는 유형이라는 것을 명심해야 한다.\n\n이러한 오류는 귀여운 TDD 논리로는 잡을 수 없다. 별도의 테스트를 개발하거나 특별한 테스트 팀을 구성해도, 이러한 오류를 찾고 상황을 재현할 확률은 매우 낮다. 특히 현재의 마이크로서비스 열풍 속에서는 거의 불가능하다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상상해보세요. 수천 개의 서비스가 있고 서로 호출하고 있는데, 그 중 하나가 모든 것을 호출하고 모든 것이 한 가지를 호출하는 상황을 말해보세요. 천 개의 서비스가 서로 복잡하게 상호작용하면 인프라가 쉽게 혼란스러운 막다른 골목이 될 수 있습니다.\n\n예를 들어, 클라우드 플랫폼을 개발했다고 합시다. 핵심에는 \"미디 서비스\" 아키텍처 내에 1,000개가 넘는 엔드포인트를 갖는 30개 이상의 복제 가능한 API가 있습니다. 서비스가 어느 시점에서든 오류를 받으면, 오류의 심각성에 따라 즉시 경고가 생성되거나 로깅됩니다. 오류가 발생하면, 그 오류가 어떻게 발생했는지 묻지 않습니다. 우리는 로그에서 직접 흐름을 검토하고 오류 발생 시점, 오류 기능 및 원인을 찾습니다. 참고: 이 일을 JavaScript/Node.js로 수행하며 성능 손실이 전혀 없습니다. 몇몇 사람이 이해해줄 것 같아요.\n\n잘 설계된 API, 효과적인 디버깅 및 포괄적인 로깅으로 과대포장된 방법론이나 과시된 방법론은 필요하지 않습니다. 사람들은 종종 \"작은 프로젝트에는 TDD가 필요 없지만 큰 프로젝트에는 필수적이다\"라고 주장합니다. 정말 그럴까요? 저는 이것이 업계에서 가장 큰 신화나 오해 중 하나라고 생각합니다. 그래서 여기 질문이 있습니다:\n\n어떤 것이 더 현명한가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- TDD로 반복적인 코드 및 테스트 반복에 따른 비용이 발생합니다.\n- 잘 설계된 오류 처리 및 로깅 메커니즘에 따른 비용이 발생합니다.\n\nTDD의 유지보수가 가장 중요한 고려 사항 중 하나입니다. 의심스러운 분들께는 TDD로 유지, 업데이트 및 새로운 기능 추가하는 비용이 상당히 높을 수도 있다는 점을 발견할 것입니다. TDD의 결과물이 이러한 비용에 가치 있는지 평가하는 것이 중요합니다. 제가 말씀드리기를, 소프트웨어 개발의 계획 및 모니터링을 간소화하는 것이 매우 효과적이거나 기적적일 수 있습니다, 아마 무엇보다도요.\n\n다음 에피소드에서는 로그 중심 개발이 무엇을 포함하며, 그 기능 및 한계에 대해 심도 있게 다룰 것입니다. 이 방법이 잘 알려진 간결함에도 불구하고 매우 강력할 수 있다는 점을 알아볼 것입니다.\n\n행운을 빕니다,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAlper Akalın\n\n연구원 \u0026 엔지니어 @EfsunEngine\n","ogImage":{"url":"/assets/img/2024-06-22-FuckTestDrivenDevelopment_0.png"},"coverImage":"/assets/img/2024-06-22-FuckTestDrivenDevelopment_0.png","tag":["Tech"],"readingTime":21},{"title":"리더십 단위 테스트 작성하는 방법 2024년 최신 가이드","description":"","date":"2024-06-22 23:47","slug":"2024-06-22-LeadershipUnitTests","content":"\n![LeadershipUnitTests_0](/assets/img/2024-06-22-LeadershipUnitTests_0.png)\n\n매니저로 일하시는 분들은 업무를 시작하자마자 느낄 수 있는 것 중 하나가 피드백 루프가 이전과 다르다는 것입니다. 느립니다. 모호합니다. 회의를 진행하거나 프로세스를 변경하거나 새로운 직원을 고용하는 경우, 자신이 잘 한 일인지 아닌지 판단하기 어렵습니다. 결과가 나타날 때까지 수개월이 걸릴 수 있으며, 심지어 이후에도 어느 정도 자신의 행동이 그 결과로 이어졌는지 정확히 알기는 어려울 수 있습니다.\n\n특히 소프트웨어 엔지니어링 분야에서 매니저로 전향한 경우, 충격일 겁니다. 엔지니어로서 우리는 명확한 피드백을 지속적으로 받았습니다. 코드 작성하기. 코드 실행하기. 현대적인 도구를 사용하지 않아도 우리는 우리의 노력 결과를 볼 수 있었습니다. 타입 체커 및 린터, 자동화된 테스팅이 등장함으로써 피드백 루프가 단축되었습니다. 결과를 확인하려면 실제로 코드를 실행할 필요조차 없었습니다. 우리가 작성한 조금씩 좋은 코드마다 수천 번이나 확인되었습니다. ✔️\n\n좋은 소식은 매니저들 및 비매니저 리더들을 위한 피드백 루프가 느리고 모호한 것이 그리 나쁘지 않을 수 있다는 것입니다. 소프트웨어 엔지니어들이 코드의 피드백 루프를 개선하기 위해 새로운 도구 및 기술을 개발하던 동안, 리더들은 사람들과의 업무에 대해 같은 일을 하고 있었습니다. 이것이 리더십 버전의 유닛 테스팅, 즉 1:1 미팅을 구현한 이유입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n믿지 않으신다구요? 단위 테스트가 제공하는 혜택 목록을 살펴보도록 하죠:\n\n## 문제를 더 빨리 발견하기\n\n작고 빠른 테스트를 통해 엔지니어들은 문제를 빨리 발견할 수 있습니다. 코드베이스에 통합되기 전이나 고객에게 제공되기 전에 문제를 발견하면, 그 문제들이 더 작고 해결하기 쉬워집니다.\n\n문제를 조기에 발견할수록 해결하기 쉽고 저렴해지는 것은 코드 문제 뿐만 아니라, 발견 시 더 쉽고 저렴하게 해결할 수 있는 사람 간의 문제들도 포함됩니다. 방치된 채로 두면 확산되거나 적개심이 생겨날 수 있습니다. “밥이 자기가 할 수 있는 일을 계속 부탁하는 건 짜증스러워” 라는 말을 들은 것과 대놓고 싸움하는 상황과 해결하는 게 완전히 다릅니다. 승진에 대해 담당자가 당신이 준비되지 않았다고 생각한다는 것을 알고 있는 것은 성과 검토 회의 전에 알 수록 더 가치 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n잘 운영되는 일대일 미팅은 양쪽이 문제를 제기할 수 있는 안전한 공간을 제공하며, 문제를 유발할 충분한 자극과 충분한 빈도를 제공하여 그 문제가 큰 문제로 발전하기 전에 조치를 취할 수 있습니다.\n\n## 문제 해결을 쉽게하기\n\n작은 문제는 큰 문제보다 자연스럽게 디버깅하기 쉽습니다. 단위 테스트도 더 나은 인터페이스를 제공하여 디버깅을 도와줍니다. 프로드를 망가뜨릴 걱정은 없습니다. 전체 코드베이스를 빌드할 필요도 없습니다. 버그를 재현하기 위해 모든 단계를 거쳐야 할 필요도 없습니다. 버그에 대한 가설을 빠르게 개발하고 (부족)증명하고 필요할 때 반복함으로써 최소한의 마찰로 진행할 수 있습니다.\n\n일대일 미팅에도 똑같이 적용됩니다. 문제를 식별했을 때 (예: 밥이 짜증나, 승진에 대해 의견이 일치하지 않음), 두 사람은 더 쉽게 이에 대해 이야기할 수 있습니다. \"왜 밥이 짜증나요?\" \"왜 승진에 대해 준비가 되지 않다고 생각하시나요?\" \"이를 해결하기 위해 우리가 무엇을 할 수 있을까요?\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 명의 대상을 대상으로 메시지를 맞춤 설정하는 것이 더 쉬워집니다. 문제에 대한 이 사람의 관점과 그에 대한 감정에 초점을 맞추어 전체 그룹의 다양한 해석을 관리하려고 하는 대신 빠른 솔루션을 찾을 수 있는 상호 대화형 일대일 미팅이 중요합니다.\n\n## 안전하게 변경 사항 적용하기\n\n잘 작성된 테스트 스위트는 코드베이스에 적용된 변경 사항이 안전한지를 확신할 수 있도록 합니다. 문제를 발견하는 것 이상으로 유닛 테스트는 문제가 없음을 확인할 수 있지만(보장하지는 않음), 엔지니어들이 코드를 리팩터링하거나 라이브러리를 업데이트하거나 익숙하지 않은 코드에서 작업할 때 테스트 스위트가 문제가 있는지 알려줄 수 있다는 것을 의미합니다.\n\n리더의 일은 변경을 촉진하는 것의 무시할 수 없는 부분입니다. 문화 전환, 프로세스 재작성, 인사, 직원 조직 변경 등. 일대일 미팅을 통해 주변 사람들과의 관계를 구축하여 보다 자신 있게 변경사항을 수용할 수 있게 됩니다. 주변 사람들이 어떤 종류의 변경을 수용할 수 있을지, 무서워할지를 배웠습니다. (희망적으로) 그들은 변경 사유가 충분하지 않으면 변경 사항을 도입하지 않는다는 것을 배웠습니다. 미팅을 통해 변경 사항을 내보낼 전에도 후에도 모든 사람들이 변경 사항을 의문시 하고 설명하고 조정할 수 있는 장소가 제공됩니다. 간단한 \"무엇을 생각하십니까...\"라는 질문으로 변경 사항을 배포하기 전에 직접 테스트할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 인터페이스 향상하기\n\n라이브러리나 API를 작성할 때, 해당 코드의 첫 번째 사용자는 대개 테스트입니다. 설계는 문서상으로 잘 보일 수 있지만, 구현은 여전히 사용하기 어렵거나 실행이 느릴 수 있거나 디버깅하기 어려울 수 있습니다. 코드가 테스트하기 어렵다면, 사용하기도 어려울 것입니다.\n\n대부분의 일대일 미팅은 문제를 찾거나 디버깅하는 데 관한 것이 아닙니다. 변경 사항을 도입하는 것도 아닙니다. 그것들은 관계를 구축하고 신뢰를 유발하는 데 관한 것입니다. 각자가 상대방이 가치를 두는 것과 무서워하는 것에 대해 배우며, 상대방이 에너지를 얻는 것과 소모되는 것에 대해 알게 되는 것입니다. 서로 더 잘 협업하는 방법을 배우며, 리스크가 적은 환경에서 피드백 주고받는 연습을 합니다. 그러면 까다로운 대화 중에 그것에 대해 고민하지 않아도 되겠죠.\n\n물론, 유닛 테스트가 이러한 혜택을 제공하지 않는 많은 코드베이스가 있습니다. 테스트가 불안정하고 신뢰할 수 없거나 크고 느린 경우가 있습니다. 또는 코드 커버리지 봇을 달래기 위한 것이거나, 행동을 확인하기 위해 작성된 것이 아닌 구현을 검증하기 위한 것인 경우도 있습니다. 이것만으로도 어떤 사람에게는 유닛 테스트가 시간 낭비임을 증명하는 충분한 증거가 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비슷하게, 많은 1:1 미팅이 큰 이득을 주지 않는 경우가 많습니다. 상태 업데이트 미팅. 한 쪽이 참여하지 않거나 듣지 않는 1:0 미팅. 탄탄한 안건 미팅으로 탐색할 여지가 없는 경우. 너무 짧거나 너무 자주 열리는 미팅. “그냥 해야 되니까”라는 이유로 열리는 무의미한 미팅. 이것들은 1:1 미팅이 시간 낭비라고 생각하는 이에게 충분한 증거가 됩니다.\n\n단위 테스트와 1:1 미팅은 잘하기 위해 기술이 필요합니다. 그렇지 않다면... 그외에 더 많은 능력 있는 프로그래머와 관리자들이 있었을 것입니다. 네 맞아요, 처음에는 너무 많은 노력으로 느껴질 수 있습니다.\n\n하지만 제대로 활용하면, 문제가 발생했을 때 감지할 수 있고 수정할 수 있으며 자신 있게 변경을 가할 수 있고 제품 출시 전 시도해볼 수 있게 도와줍니다. 이 점은 엔지니어로써 가치 있었습니다. 당신의 피드백 루프가 몇 주가 걸리는 리더로서는 더 가치 있게 느껴집니다. 그러니 소홀히 하지 마십시오.\n","ogImage":{"url":"/assets/img/2024-06-22-LeadershipUnitTests_0.png"},"coverImage":"/assets/img/2024-06-22-LeadershipUnitTests_0.png","tag":["Tech"],"readingTime":5},{"title":"엔지니어링 리더십 가이드 비용과 경비 추적하는 방법","description":"","date":"2024-06-22 23:46","slug":"2024-06-22-TheEngineeringLeadershipPlaybookTrackingCostsandExpenses","content":"\n귀하의 응용 프로그램이 사용자에게 제공해야 하는 서비스를 적절한 성능과 신뢰성 수준으로 제공하기 위해 매달 얼마의 금액이 필요한가요? 또한 시스템을 축소하고 어려운 시간과 줄어드는 시간 동안 조명만 켜두는 경우 팀이 필요한 최소 금액은 얼마인가요?\n\n이것들은 어떤 팀이라도 대답할 수 있어야 할 가장 중요한 질문 중 일부이지만, 상당수의 소프트웨어 엔지니어와 팀은 일상적인 활동의 재정 측면을 무시하며 이를 중요한 요소로 간주하지 않거나 구현 후 계획에서 빼 놓습니다.\n\n회사가 지불하는 다음과 같은 분야 및 서비스에 대한 재정적 통찰력을 제공하는 자세하고 최신의 비용 보고서를 보유하는 것이 항상 현명합니다:\n\n- 서버, 호스팅(클라우드 또는 온프레미스) 및 저장 공간.\n- 데이터베이스 서버 및 인스턴스, 복제본 및 백업 포함.\n- 개발, 테스트 및 스테이징(그리고 당연히 프로덕션) 환경. 배포 및 타사 통합 포함.\n- 대역폭, 지원, 유지보수 및 계속되는 운영 비용.\n- 보안, 모니터링 및 관측 도구 및 플랫폼.\n- 라이선스 및 구독.\n- 당직 및 사건 관리 도구 및 플랫폼.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-TheEngineeringLeadershipPlaybookTrackingCostsandExpenses_0.png\" /\u003e\n\n이러한 정보에 액세스하면 엔지니어링 팀이 작업 및 지출에 대한 시정성 및 통제를 얻을 수 있습니다. 이는 다음과 같은 결정을 지원할 수 있습니다:\n\n- 현재 요구 사항과 회사의 성장 단계에 기초하여 스케일링 계획을 개발하는 팀을 활성화합니다.\n- 비용 최적화 또는 확장성 및 성장에 중점을 둔 기술 프로젝트의 우선순위가 있는 백로그를 유지할 수 있도록 지원합니다. 제품과 회사를 다음 단계에 대비하여 준비합니다.\n- 플랫폼 업그레이드, 대체 클라우드 제공업자 평가 또는 파트너십 기회 탐색 등을 고려합니다. 이러한 재정적 인텔리전스는 토론을 시작하고 철저한 비용 대비 분석을 수행하는 데 중요합니다.\n- CAC 및 사용자에 제공된 서비스당 비용과 같은 중요한 메트릭으로 재무, 제품 및 비즈니스 팀과 같은 다른 기능과 팀 간의 협력을 용이하게 합니다.\n- 어려운 시기에 팀이 핵심 기능 및 기본적인 운영의 연속성을 보장하면서 비용을 줄일 장소에 대해 신중한 결정을 내릴 수 있습니다.\n\n관리자로서, 여러분의 주요 책임 중 하나는 팀의 비용을 위에서 나열된 영역에서 지속적으로 추적하는 것입니다. 여러분의 팀은 분명히 운영 중이고 비용이 드는 여러 서비스, 데이터베이스, 도구 및 기타 자산을 소유하고 있습니다. 기술 스코핑 및 계획 단계에서 항상 비용 요소를 고려하도록 팀을 격려하세요. 또한 그들은 사업 분야의 성공 지표를 알고 이해하고, 그들의 결정이 이러한 지표에 미치는 영향을 보아야 합니다. 많은 엔지니어링 팀과 스타트업이 문제 해결 및 지불을 포함한 모든 것을 소유하는 문화를 만들어 성공을 찾았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 마지막으로\n\n팀이 이 연습에 처음 참여할 때 저마다 얼마나 많은 쉬운 문제를 발견하게 될지에 놀랄 것입니다. 저는 많은 팀이 이 연습을 통해 발전과 비용 최적화를 위한 상당한 영역을 식별한 것을 목격했습니다. 흔하게 발견되는 사례로는 자원을 지나치게 소모하는 중요하지 않은 기능, 사용되지 않는 서버, 더 이상 유효하거나 필요하지 않은 데이터를 보관하는 테라바이트 단위의 저장 공간, 월별로 색인화되고 있는 로그 수백만 개지만 실제로 필요로 하는 사람이 아무도 없는 것, 또는 시작했지만 팀이 완성하고 통합하지 못한 POC/MVP 프로젝트의 구성 요소 등이 있습니다.\n\n\"Engineering Leadership Playbook\"은 어떤 엔지니어링 관리 또는 리더십 역할을 수행하는 데 필요한 몇 가지 측면과 책임을 조명하는 기사 시리즈가 될 예정입니다. 이것이 해당 역할을 수행하는 누구든지 또는 언젠가 이를 원하는 사람에게 가치 있는 정보가 되길 바랍니다.\n","ogImage":{"url":"/assets/img/2024-06-22-TheEngineeringLeadershipPlaybookTrackingCostsandExpenses_0.png"},"coverImage":"/assets/img/2024-06-22-TheEngineeringLeadershipPlaybookTrackingCostsandExpenses_0.png","tag":["Tech"],"readingTime":3},{"title":"새로운 IT 직업 시작 전에 무시했던 위험 신호들 8가지","description":"","date":"2024-06-22 23:45","slug":"2024-06-22-TheRedFlagsIIgnoredBeforeStartingaNewTechJob","content":"\n![이미지](/assets/img/2024-06-22-TheRedFlagsIIgnoredBeforeStartingaNewTechJob_0.png)\n\n지금 나의 현재 직책에 매우 불만족스러워요.\n\n예를 들어, 문제가 많아요. 내 상사는 나에게 조차 면회를 해주지 않아요.\n\n하지만 나는 시작하기 전에 문제점을 알아야 했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 현재의 불행으로 이어진 기술 직업 탐색에서 기꺼이 무시했던 빨간 깃발들입니다.\n\n### 채용 담당자 경고 1\n\n저는 연수 기간에 대해 물었고, 채용 담당자가 \"여기서 파이어 당할려면 좀 노력해야겠지.\"라고 말했습니다.\n\n이 발언은 당신이 안심될 수 있도록 하는 취지로 했다고 생각되지만, 실제로 이는 회사가 성과에 대한 기준이 낮다는 것을 시사했습니다 (그리고 이것이 사실이었던 것이 나중에 나타났습니다). 나중에 무능함도 용인된다는 것을 알게 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해고되기 어려운 곳은 보통 평범함이 상식이 되는 곳이며, 이 특정 회사에서도 마찬가지입니다.\n\n# 채용 담당자 경고 2\n\n영상 통화 중인 채용 담당자가 자신이 좋아하는 축구팀의 스포츠 상의를 입고 있었는데, 이러한 의류가 가져올 편향적인 경쟁 의식에 대해 몰랐는지 보였습니다.\n\n사소해 보일 수 있지만, 이는 전문성의 부재를 시사했습니다. 채용 담당자가 직무를 진지하게 대하지 않는다면, 회사가 다르게 할 이유가 무엇이 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로 시작한 이후에 항상 카메라를 끄는 것을 알았어요, 그래서 집에서 편안하게 입은 것이 무엇인지 궁금해졌어요.\n\n# 노트북 인수\n\n“일을 시작하기 전 주의 시작 날짜 한 주 전에 왜 회사 노트북을 가져가지 않겠어요?”라고 물었어요. 전 직장이 내 월급을 지불하고 있었기 때문에 평소처럼 일하는 줄로 생각했어요.\n\n이 요청은 계획이 떨어지고 내 시간을 고려하지 않는 분명한 신호였어요. 이는 회사가 종엽 프로세스에 대해 느슨한 접근 방식을 가지고 있을 수 있다는 것을 시사했죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 접근 방식이 얼마나 완화된 것인지 전혀 몰랐어요.\n\n# 첫 날\n\n첫 날에 누군가 나를 만나기로 한 사람이 없었어요. 나는 IT 지원 담당자를 만나기로 했고, 그렇게 하여 나의 노트북을 받았어요. 그는 늦었고, 그래서 나는 첫 입사 콜을 놓쳤어요.\n\n키카드가 없어서 접수대에서 기다렸는데, 내 팀에서는 나를 맞이할 사람이 없었어요. 나는 새 노트북을 가지고 빈 사무실에서 혼자 앉아 있었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이게 공포 이야기처럼 들린다면, 그렇게 들리는 게 맞습니다. 첫 날이 기대되는 일들을 보여줬다면, 조직의 무질서, 의사 소통 부족, 그리고 고립이 내 직무의 반복되는 주제가 되었습니다.\n\n# 결론\n\n새로운 직장이 필요합니다. 새로운 직장이 필요합니다. 새로운 직장이 필요합니다.\n\n다음 면접에서 행운을 빌어주세요, 제 정신건강이 여기서 계속해서 손상되고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 저자 소개\n\n프로 소프트웨어 개발자 \"The Secret Developer\"는 Twitter에서 @TheSDeveloper로 찾을 수 있으며, 주로 Medium.com을 통해 기사를 정기적으로 발행합니다.\n\nThe Secret Developer은 빨간 깃발에 대해 별로 신경 쓰지 않습니다. 사실 아무것도.\n","ogImage":{"url":"/assets/img/2024-06-22-TheRedFlagsIIgnoredBeforeStartingaNewTechJob_0.png"},"coverImage":"/assets/img/2024-06-22-TheRedFlagsIIgnoredBeforeStartingaNewTechJob_0.png","tag":["Tech"],"readingTime":4},{"title":"요구사항 및 API 분석하는 방법","description":"","date":"2024-06-22 23:43","slug":"2024-06-22-RequirementsAPIAnalysis","content":"\n이전 장: https://medium.com/analysts-corner/requirements-api-definitions-3f75a7308ae6\n\n이 장에서는 먼저 API에 대한 요구 사항이 필요한 이유와 요구 사항 분류 프레임워크에서의 위치를 이해할 것입니다. 그런 다음 요구 사항 엔지니어링 프로세스 및 고려해야 할 구체적인 측면을 검토할 것입니다.\n\n# 왜 API를 위한 요구 사항이 필요한가요?\n\nAPI 요구 사항에 대해 비즈니스 분석가들이 갑자기 작업을 시작하는 이유에 대해 답해보겠습니다. 약 10년 전, IT에서 비즈니스 분석가로서 경력을 시작했을 때, 일반적인 BA 책임의 일부가 아니었습니다. 지금은 더 많은 BAs, POs 및 PMs의 채용 공고에서 API 지식이 필요하다는 것을 알 수 있습니다. 그리고 그런 일이 일어난 이유에 대한 주관적 설명이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당시 소프트웨어 아키텍처 접근 방식은 온프레미스 배포된 단일 애플리케이션이었습니다. 간단히 말해, 그것은 데스크톱이나 웹 UI 클라이언트와 통신하는 백엔드 서비스가 함께하는 형태였습니다. 해당 백엔드는 FTP를 통해 파일 업로드와 같은 여러 내부 또는 외부 서비스와 통합되었습니다.\n\n비즈니스 분석가는 비즈니스 능력 및 그들이 UI 측에서 나타나는 방식에 집중했습니다. 또한 매핑 및 요청 논리와 같은 통합을 위한 요구 사항을 다루었습니다. 백엔드, UI 클라이언트 및 통합 시스템 사이의 상세 상호작용은 기술 담당자의 책임이었습니다.\n\n그러나 클라우드, SaaS 및 마이크로서비스 아키텍처(MSA)가 시스템 디자인의 주요 트렌드로 부상하면서 상황이 변하기 시작했습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근의 트렌드로 인해 시스템끼리의 연결이 이전보다 더 많아졌습니다. 일부 서비스는 API를 우선으로 하는데, 이는 API를 통해서만 사용할 수 있다는 뜻입니다. 그러므로 API는 더 높은 요구사항을 갖는 비즈니스 모델이 되었습니다. 이에 따라 이해관계자, 규정, 제한 등이 발생하며, 비즈니스 분석가, 제품 소유자, 제품 관리자들이 이를 책임집니다.\n\nAPI 클라이언트의 수가 웹, 모바일 어플리케이션, 사물 인터넷 등을 포함하여 급격히 증가했습니다. 게다가, 마이크로서비스는 시스템 내에서 서로 API를 통해 통신합니다. 그 결과, 각각의 이해관계자와 특정 요구사항을 갖춘 수직 및 수평 방향의 다양한 외부 및 내부 클라이언트들이 존재합니다.\n\n또 다른 중요한 측면은 API가 시스템에 침입할 수 있는 직접적인 경로를 제공하기 때문에 공격에 취약하다는 점입니다. 그러므로, API를 디자인하고 구현하는 것 뿐만 아니라 그들의 보안을 보장하는 것이 중요합니다.\n\n요약하자면, 클라우드, MSA, SaaS의 부상으로 인한 API의 \"비즈니스화\", 클라이언트 수의 증가, 높은 보안 위험, 그리고 산업 및 정부의 규정은 API를 비즈니스 분야의 모든 종류의 사람들에게 관심을 가지게 만들었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것은 그 변화에 대한 철저한 설명은 아니지만, 나의 시각에서 그렇게 보입니다. 댓글에 당신의 생각을 보고 싶어요.\n\n# 요구 사항 분류\n\nBA 이론에 뛰어들기 전에, API 요구 사항이 기능적이지 않다는 점을 명확히 해보죠. UI가 가장 가까운 비유입니다. 시스템 기능(기능)과 사용자가 그에 접근하는 여러 가지 방법이 있습니다. 이전 장에서, 우리는 API를 배포 채널로 확인했습니다. 그리고 이것은 UI, Command-line interface (CLI), Chatbot 등 모든 공개 인터페이스에 대해 동일합니다.\n\nAPI 디자인을 통해 기능 요구 사항을 표현할 수 있습니다. 그러나 API 자체는 시스템 기능의 직접적인 관심사가 아닙니다. UI 비유로 돌아가보죠: 디자인 패턴, 사용할 컴포넌트, 또는 색 구성표는 UX에 중요하지만, 우리는 그것들을 기능 요구 사항이라고 부르지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, \"시스템은 X로 필터링된 항목 목록을 반환하고 Z로 정렬한다\"는 기능 요구 사항입니다. 그러나 이 목록을 UI와 API로 어떻게 반환하는지는 다를 수 있습니다. 단일 프런트 엔드가 그 API 엔드포인트를 활용하는 경우, UI 관점에서 설명하는 것만으로 충분합니다. 이 단일 클라이언트가 여기서 주요 이해관계자 역할을 합니다. 그러나 여러 클라이언트가 목록을 사용하려면, 그들과 소통하고 그들이 얻어야 하는 것과 이유를 맞추는 데 추가 시간을 투자해야 합니다. 그 결과는 UI에 목록 항목을 어떻게 반환하는지와는 크게 다를 수 있습니다.\n\nAPI 요구 사항은 기능적이 아니기 때문에 어떤 유형의 요구 사항에 속하는 것일까요? 몇 가지 출처를 살펴봅시다.\n\n켐 웨거스(K. Wiegers)와 C. 호캔슨(C. Hokanson)의 최근 \"소프트웨어 요구 사항 필수\"에서는 \"외부 인터페이스 요구 사항\"을 정의합니다.\n\nK. Wiegers와 J. Beatty의 고전적인 \"소프트웨어 요구 사항\" 3판은 비기능적 요구 사항과 인터페이스 간의 상호 연결성을 강조합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nISO/IEC/IEEE 29148:2018 표준 \"시스템 및 소프트웨어 공학 - 수명 주기 프로세스 - 요구 공학\"에 따르면 Interface requirements(인터페이스 요구 사항)이라는 요구 유형이 있습니다(5.2.8.3):\n\n인터페이스 요구 사항은 비기능적인 것이 아닙니다. 왜냐하면 인터페이스는 자체적인 품질 속성을 가지고 있기 때문입니다. 보안, 호환성, 사용성, 규정 준수 등이 그에 해당합니다. 인터페이스는 특정 기능의 품질 속성에 불과하지 않습니다. 그러나 엉망인 인터페이스는 사용자 경험을 저하시킬 수 있습니다, UI 또는 API에 대한 이야기를 할 때도 그렇습니다.\n\n또한 선택된 기술과 디자인 패턴은 인터페이스에 대한 제약 사항을 내포하고 있습니다. 따라서 소프트웨어 아키텍처는 분석 프로세스에 영향을 미치며, 특히 API의 경우에 그렇습니다. 예를 들어, API가 동기화되어야 하는지 비동기화되어야 하는지(이벤트 기반)는 아키텍처 및 사용된 프로토콜에 따라 달라집니다.\n\n인터페이스 요구 사항(여기에 UI 및 CLI가 포함됨)에서는 시스템이 소비자로서 동작할 때 통합 요구 사항을 분리하는 것이 합리적입니다. 제조자인 경우 API 요구 사항(이전 섹션을 참조하십시오)은 다소 흥미로운 결과를 나타냅니다. 후자의 결과는 운영 API 엔드포인트를 의미합니다. 한편, 시스템 간의 작업 상호 작용은 첫 번째 결과입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요구 엔지니어링\n\nBABOK v3 (IIBA, 2015)은 API 또는 통합 요구 사항을 분류하지 않습니다. 하지만 API 및 일반적인 인터페이스에 대해 이야기하는 인터페이스 분석 기법 (10.24)을 설명합니다. 이 분석은 다음과 같은 3단계로 구성됩니다:\n\n- 상호작용 주체의 상호작용을 연구하여 어떤 인터페이스가 필요한지 식별하고 이해하기 위해 준비 작업을 수행합니다.\n- 각 향후 인터페이스의 기능을 설명하고 인터페이스 유형과 초기 설계를 평가하여 식별 작업을 수행합니다.\n- 입력, 출력, 검증 등을 포함한 인터페이스를 정의합니다.\n\n요구 사항 개발은 \"전통적인\" 비즈니스 분석 프로세스와 크게 다르지 않습니다. 요구 수집, 분석, 명세 및 검증 단계가 있습니다. 현재 우리는 주로 첫 단계에 주안점을 두고 있습니다. 명세와 추가적인 검증은 어떤 특징을 가지고 있지만, HTTP 프로토콜 기본 및 API 구조에 대해 자세히 알아볼 필요가 있습니다. 이 내용은 이후 챕터에서 다룰 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 시작점\n\n여기에 고려해야 할 많은 질문들이 있어요:\n\n- 이게 왜 필요한가요?\n\n예를 들어, 저희는 제품을 통해 생성되는 데이터를 UI가 아닌 유료 공개 API로 외부의 제3자들이 얻을 수 있는 접속점을 만들고 싶어해요. 간단히 말해, 새로운 유통 채널을 추가하고 수익을 창출하고 싶어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 누구를 위해 이것을 하는 건가요?\n\n예를 들면, 의료 데이터 브로커는 우리의 데이터를 활용하여 시장 예측 모델을 구축할 것입니다.\n\n- 이것이 무엇을 할까요?\n\n예를 들면, 제공된 기간에 대한 세트 구매 기록을 반환할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이들이 어떻게 할 것인가요?\n\n예를 들어, 토큰으로 승인하고 사업 ID와 시작 및 종료 날짜를 제공합니다.\n\n## 선행 요건\n\n다음 단계는 API 호출의 선결 조건을 정의하는 것입니다 — 인증 및 권한 부여:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 인증은 클라이언트를 확인하고 API와 통신할 수 있도록 허용하는 것을 의미합니다.\n- 인가는 특정 클라이언트가 특정 API 요청을 수행하고 특정 데이터를 볼 수 있도록 권한을 부여하는 것입니다.\n- 또 다른 중요한 포인트는 소비자가 호출을 수행하는 데 필요한 모든 입력 데이터를 가지고 있는지 여부입니다.\n- 새로운 API 엔드포인트에 관련된 새 권한이 필요한지 또는 기존 권한을 재사용해야 하는지를 이해해야 합니다.\n\n# 기능적 차이\n\n또 다른 중요한 질문은 시스템이 이미 그러한 기능을 제공하는지여부입니다. 그렇다면 어떤 개선이 필요한지 알아봐야 합니다.\n\n현재 시스템 기능과 원하는 인터페이스 간에 차이가 있다면, 해결책 요구 사항의 문제입니다. 그래서 전통적인 BA(비즈니스 분석) 방법을 사용해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 새로운 API 엔드포인트에 대한 새로운 검색 기준이 있다면, 해당 기준이 검색 인덱스에 포함되도록 해야 합니다. 그것은 이미 백엔드와 관련된 문제입니다.\n\n인터페이스를 통해 해결책을 설명하려면, 모든 측면을 다루기에는 충분하지 않을 것입니다. 최소한 데이터 모델인 데이터 사전이나 엔터티 관계도를 갖고 새 API가 사용될 장소를 설명하는 좋은 사용 사례가 필요합니다.\n\n과제는 한 개 또는 여러 API 엔드포인트가 활용될 사용 사례를 확인하고 설명하는 것입니다. 요즘에는 API가 매우 촘촘하기 때문에 단일 API만으로는 맥락이 명확하지 않습니다. 따라서 특정 엔티티와 관련된 특정 작업이 여러 API 호출로 이루어지는 시나리오가 더 낫습니다.\n\n# 계약 및 검은 상자\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI를 단순하게 살펴보면 다음과 같이 보일 수 있어요\n\n![API Analysis](/assets/img/2024-06-22-RequirementsAPIAnalysis_1.png)\n\n분석의 결과는 설명된 입력/요청 구조와 결과/응답입니다. 이는 우리가 API 계약이라고도 부를 수 있는 블랙 박스를 나타냅니다.\n\n- API 계약은 생산자와 소비자 간의 기대되는 입력과 결과에 대한 합의입니다.\n- 계약은 엄격하게 형식화되며, 클라이언트는 API를 사용하기 시작할 때 이를 준수하기로 동의합니다.\n- API 생산자는 계약의 일관성을 유지하는 책임을 집니다.\n- API 계약을 어기면 법적인 처벌이 가해질 수 있습니다.\n- API 계약은 구현 전에 정의될 수 있어서 양쪽이 병행하여 작업할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n거기 중요한 두 가지가 있어요:\n\n- 요청/응답 모델, 즉 API 모델은 데이터베이스의 데이터 모델과 동일하지 않아요. API는 데이터베이스 위에 구축된 추상화로, 외부 세계와의 상호 작용을 보호하는 역할을 해요. 모델은 이름, 노출된 속성 집합, 그리고 일부 데이터 유형에서도 차이가 있을 수 있어요.\n- 새로운 API는 기존 시스템 API와 일관성을 유지해야 해요. 특정한 방식으로 불리우는 것이 있다면, 그에 따라야 해요. 가능한 혼란을 피하고 소비자들의 인지 부하를 줄일 수 있도록 도와줄 거예요.\n\nAPI 모델은 다음과 같이 설명할 수 있어요:\n\n- 공식적인 방법으로는 XML 및 JSON과 같은 데이터 형식 또는 OpenAPI와 같은 명세 형식이 있어요. OpenAPI는 HTTP에 대한 가장 일반적인 공식 API 명세 형식이에요.\n- 비공식적인 방법으로는 Excel 스프레드시트나 텍스트 형식 등이 있을 수 있어요. 비공식 포맷은 일반적으로 OpenAPI를 모방하지만 보다 사용자 친화적인 방식으로 표현돼요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요청 로직은 블랙 박스(글래스 박스) 내부에서 무엇이 발생하는지를 처리합니다. 이것은 다음과 같이 설명될 수 있습니다:\n\n- 비공식적으로(여러 단계를 포함한 텍스트 설명)\n- 시각적으로: UML 활동 또는 순서 다이어그램 등\n- 형식화된 명세서 형태\n\n요청 로직은 Entity 객체에 대한 간단한 CRUD 명령일 수도 있습니다. 또한 몇 개의 내부 API가 관련된 정교한 집계된 요청일 수도 있습니다. 이 내용은 이후 장에서 다루겠습니다.\n\n# 너무 촉박하지 않게요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI 작업을 하면 API보다 변경 사항을 소개하기가 쉽습니다. 사용자 경험을 파괴할 위험이 있지만, 일반적으로 사용자가 새로운 것에 적응하는 데 들어가는 인지적 노력에 관한 문제입니다. 그들은 당신의 변화에 대해 돈을 내지 않습니다.\n\n반면에 소비자들은 사용 중인 API의 파괴적인 변경 사항에 적응하거나 새로운 것으로 마이그레이션하는 데 대가를 지불합니다. 클라이언트 코드 변경부터 자동 테스트, 문서 업데이트 등 추가적인 통합 및 유지 보수 노력이 필요합니다.\n\n따라서 모든 \"반복적 유연성\"은 API에 대해서는 그리 많이 다루지 않습니다. 그들은 분명히 자신들의 수명 주기 동안 진화합니다. 그러나 API 계약을 자주 파괴하는 것은 지속 가능성을 달성하는 좋은 방법이 아닙니다. 이를 완화하는 방법이 있지만, 확실히 모든 API 생산자가 이를 염두에 둬야 합니다.\n\n요구 엔지니어링 관점에서, 특히 여러 소비자가 사용할 유료 공개 API인 경우에는 보다 철저한 분석이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 주제에 대해 읽기\n\n- API 요구 사항의 정의\n- 비기능 요구 사항 및 API\n- 파괴적인 변경 및 역 하위 호환성\n- IIBA 벨라루스의 \"요구 사항 및 API\" 웨비나 요약\n\n다음 장: 구조 (진행 중)\n\n원문 게시물: https://ilyazakharau.com.\n","ogImage":{"url":"/assets/img/2024-06-22-RequirementsAPIAnalysis_0.png"},"coverImage":"/assets/img/2024-06-22-RequirementsAPIAnalysis_0.png","tag":["Tech"],"readingTime":12},{"title":"2024년에 유용할 고급 Shell 스크립팅 명령어 9선","description":"","date":"2024-06-22 23:42","slug":"2024-06-22-AdvancedShellScriptingCommandsthatcanbehelpfulin2024","content":"\n![이미지](/assets/img/2024-06-22-AdvancedShellScriptingCommandsthatcanbehelpfulin2024_0.png)\n\n안녕하세요! 저는 최근 회사에서 일하는 동안 일반 업무 외에도 쉘 스크립팅을 사용하여 도구를 만들었습니다.\n\n쉘의 구문은 다른 프로그래밍 언어와 비교했을 때 약간 복잡하여 이해하고 구현하기가 조금 어렵지만, 쉘 스크립팅은 자동화를 위한 다양한 용도로 사용됩니다. 쉘 스크립팅을 공부하면서 얻은 지식으로 매우 만족스럽습니다.\n\n다음은 제가 사용하고 코딩하는 동안 도움이 된 일련의 명령어입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- grep: 쉘 스크립팅에서 사용되는 매우 유용한 명령어로, 파일에서 패턴이나 정규 표현식을 찾아 해당 grep이 제공하는 옵션에 따라 출력을 내용에 맞게 얻을 수 있습니다.\n\n```js\ngrep [options] pattern filename\n```\n\n일부 옵션은 다음과 같습니다:-\n\n- c: 이 옵션은 파일에서 패턴을 포함하는 일치하는 행의 수를 세는데 사용됩니다. 예를 들어 grep -c “hello” sample.txt\n- -l: 이 옵션은 해당 패턴을 포함하는 행을 출력합니다. 예를 들어 grep -l “finding” commentsTracker.sh\n- -i: 이 옵션은 대소문자를 구별하지 않고 파일 내에서 검색하므로 해당 단어의 어떤 형태든 검색됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. mailx: 리눅스에서 자동화된 작업에서 메일을 보내는 데 사용됩니다. 우리의 경우에는 특정 시나리오 하에서 mailx를 사용하여 메일을 보내는 것이 상당히 유용했어요.\n\n```sh\necho -e \"내용\" | mailx -s \"제목\" -r 발신자 수신자1 수신자2\n```\n\n여기서 내용을 우리가 원하는 본문 내용으로, 제목을 이메일 본문의 제목으로 대체할 수 있어요.\n\nmailx를 사용하면 -c를 사용하여 참조 메일 수신자도 추가할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\necho -e \"내용\" | mailx -s \"제목\" -r 발신자 -c 참조사용자1,참조사용자2,참조사용자3 수신자1 수신자2\n```\n\n여기서 우리는 참조 사용자 ccuser1, ccuser2, ccuser3과 수신자1 및 수신자2가 메일 수신함에 있을 사용자 세 명을 가지고 있음을 볼 수 있습니다.\n이 기능은 매우 흥미로운 것입니다.\n\n3. ` :- 이 파일에 데이터를 쓰는 데 사용됩니다. 데이터가 이미 존재하는 경우 데이터가 덮어쓰여집니다.\n\n파일이 없으면 파일이 만들어집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\necho \"Hello Medium\" \u003e file.txt\n```\n\nfile.txt:- Hello Medium\n\n` :- On the other hand, this appends data to the file instead of overwriting it.\n\n```js\necho \"Adding this text\" \u003e\u003e file.txt\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 내용을 Markdown 형식으로 변경해보세요.\n\n파일.txt: - 안녕하세요 Medium. 이 텍스트를 추가합니다.\n\n4. \\**: - *검색할 문자열을 사용할 수 있습니다.\\*\n\n예: search_string = \"어디에 있나요\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 변수인 description에 정확한 문자열 search_string1을 포함하는 문자열에서 이 연산자를 사용하여 문자열을 검색할 수 있습니다. 정확히 동일한 문자열을 검색하므로 공백도 문제가 될 수 있습니다.\n\n```js\nif [[ $description == *\"$search_string1\"* ]]; then\n      echo \"description에 search_string1이 있습니다.\"\n```\n\n5. =~:- =~를 사용하여 지정된 문자열에서 부분 문자열을 일치시킬 수 있고, 해당 문자열에 부분 문자열이 있는지 확인할 수 있습니다.\n\n```js\nif [[ $variable =~ YES|Yes|Y ]]; then\n  echo \"변수에 YES 또는 Yes 또는 Y 부분 문자열이 포함되어 있습니다.\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 지정된 문자열을 검색할 때 사용자에게 정말 편리합니다.\n\n6. Export:- 이 명령은 변수를 내보내어 후속 프로세스가 나중에 액세스할 수 있도록 하는 데 사용됩니다.\n\n```js\nexport BATCH_DATE=\"29042001\"\n```\n\n예를 들어 셸 스크립트에서 BATCH_DATE를 내보내고 나중에이 셸 스크립트가 호출한 파일 내에서 액세스합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\necho $BATCH_DATE\n\n일반적으로 코드 내에서 변수 condition을 내보내고 사용하고 싶을 때 사용됩니다.\n\n이 글에서 무언가를 얻었다면 좋아요와 댓글 부탁드립니다. 이는 제가 더 많은 유용한 글을 작성할 자극이 됩니다.\n\nLinkedIn에서 저와 연결하고 팔로우해주세요: https://www.linkedin.com/in/devendu-negi-142b6618b/\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 YouTube 채널을 한 번 둘러보시는 것을 고려해 주시면 좋겠어요! 저는 힌디어로 콘텐츠를 올리고 있으며 일상 명언의 짧은 영상도 함께 제작하고 있어요.\n\nhttps://www.youtube.com/channel/UCaGvN7VhqTRa9sCHxcgJ-Pw\n\n누군가가 DSA에 대해 1대1로 안내를 받고 싶다면 topmate에서 저와 연락할 수 있어요: https://topmate.io/devendu_negi/\n\n커피 한 잔 사주시면 감사하겠어요!\nhttps://buymeacoffee.com/devendunegi\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 내 다른 글들이 당신의 소프트웨어 엔지니어링 여정에 가치를 더했다면, 더 많은 글을 보기 위해 내 계정을 팔로우해보세요.\n\n코딩을 즐기며, 당신의 목표를 이루길 바라요 :)\n","ogImage":{"url":"/assets/img/2024-06-22-AdvancedShellScriptingCommandsthatcanbehelpfulin2024_0.png"},"coverImage":"/assets/img/2024-06-22-AdvancedShellScriptingCommandsthatcanbehelpfulin2024_0.png","tag":["Tech"],"readingTime":6},{"title":"링크를 클릭했을 때 벌어지는 네트워킹 과정 ","description":"","date":"2024-06-22 23:41","slug":"2024-06-22-TheNetworkingbehindclickingalink","content":"\n\u003cimg src=\"/assets/img/2024-06-22-TheNetworkingbehindclickingalink_0.png\" /\u003e\n\n하이퍼링크를 클릭하면 브라우저가 원격 서버에서 링크의 콘텐츠를로드하고 렌더링합니다. 배경에서는 연결 설정, 세션 암호화, 프로토콜 협상, 리다이렉션, 도메인 표시 등이 발생합니다.\n\n이 기사에서는 브라우저에서 하이퍼링크를 클릭할 때 발생하는 네트워킹 측면을 안내하겠습니다. 데모 용도로 내 강좌 링크 중 하나를 사용할 것입니다.\n\n기사에서 언급하는 클라이언트는 TLS 1.3 및 HTTP/2를 지원하는 브라우저를 의미합니다. 현대의 모든 브라우저가 이러한 프로토콜을 2022년에 지원합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# backend.husseinnasser.com\n\n저의 소프트웨어 엔지니어링 각각의 강좌마다, DNS 공급 업체가 호스팅하는 CNAME 레코드가 있어 고유한 Netlify 도메인으로 연결됩니다. Netlify에서는 HTML 페이지를 호스팅하여 실제 강좌 링크로 리디렉션합니다. 이렇게 함으로써 CNAME 도메인을 소셜 미디어에서 공유할 수 있으면서 강좌 쿠폰을 업데이트하거나 전체적으로 다른 링크로 리디렉트할 때 완전한 제어를 갖게 됩니다. 원래 링크는 그대로 유지됩니다.\n\n제 최신 강좌인 '백엔드 엔지니어링 기초' 강좌인 backend.husseinnasser.com을 살펴봅시다. 링크를 클릭하면 브라우저가 udemy의 강좌로 리디렉션됩니다. 이 프로세스는 DNS, TCP, TLS, ALPN/SNI 및 HTTP/2를 통해 진행되며, 각 섹션을 자세히 설명하겠습니다.\n\n```js\nbackend.husseinnasser.com\n ---\u003e zen-mccarthy-34c0bb.netlify.app\n ---\u003e udemy.com/backendcourse\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# DNS\n\nhttps://backend.husseinnasser.com에 클릭하면 HTTP 클라이언트(당신의 브라우저)가 backend.husseinnasser.com의 IP 주소를 얻기 위해 DNS 조회를 발행합니다. backend.husseinnasser.com은 DNS 권위 있는 이름 서버 enom에서 호스팅된 CNAME(정규 이름)으로 내 HTML 파일이 호스팅되어 있는 Netlify DNS 레코드 zen-mccarthy-34c0b.netlify.app를 가리킵니다.\n\nDNS 쿼리는 backend.husseinnasser.com의 IP 주소를 요청하는 고유한 쿼리 ID가 포함된 UDP 데이터그램입니다. DNS 쿼리의 첫 번째 중단점은 당신의 DNS 리커서(또는 리졸버)입니다. 이는 Google 8.8.8.8 또는 Cloudflare의 1.1.1.1과 같을 수 있습니다. 리커서는 루트 DNS 서버에 .com 최상위 도메인(TLD) 서버를 요청합니다. 그런 다음 리커서는 husseinnasser.com이 호스팅된 권위 있는 이름 서버를 요청하기 위해 TLD에 쿼리를 보내 한 of my enom servers를 반환합니다. 마지막으로 리커서는 IP 주소를 얻기 위해 enom 서버로 backend.husseinnasser.com의 DNS 쿼리를 전송합니다. 그것은 zen-mccarthy-34c0bb.netlify.app을 가리키는 CNAME임을 발견하고 zen-mccarthy-34c0bb.netlify.app의 IP 주소를 찾기 위해 새로운 DNS 쿼리를 수행하고 IP 주소가 발견될 때까지 프로세스가 반복됩니다. 이 모든 것은 캐시가 없다고 가정합니다.\n\n우리는 이를 도메인에 대한 nslookup(또는 dig)를 수행함으로써 볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-22-TheNetworkingbehindclickingalink_1.png)\n\nDNS 쿼리의 일부로 zen-mccarthy 도메인을 받았을 때, zen-mccarthy netlify 도메인의 IPv4 주소와 연관된 A 레코드 두 개도 함께 받습니다. 클라이언트는 IP 중 하나를 선택하고 35.247.66.204로 TCP 연결을 설정합니다.\n\n# TCP\n\n이제 IP 주소가 있으므로 TCP 연결을 설정할 수 있습니다. TCP 연결 설정에는 소스 IP, 소스 포트, 대상 IP 및 대상 포트의 4개 튜플이 필요합니다. 클라이언트는 연결하기 전에 이 네 가지가 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고객이 DNS 덕분에 목적지 IP를 알고 있습니다. 35.247.66.204이며, 목적지 포트는 링크가 명시적으로 https://를 사용하고 있으므로 443입니다. 소스 포트는 0에서 2¹⁶ 사이의 사용 가능한 모든 포트가 될 수 있으며, 소스 IP는 여러분의 기기입니다.\n\n이 4개의 튜플로 고객은 IP 패킷에 실려있는 SYN TCP 세그먼트를 보냅니다. 서버는 SYN을 받고 목적지 IP를 고객의 IP(보통은 게이트웨이)로 바꿔서 SYN/ACK를 응답합니다. 마지막으로 고객은 ACK를 통해 핸드셰이크를 완료합니다. 이제 연결이 수립되었습니다.\n\n```js\n고객 ------------SYN -------\u003e netlify (35.247.66.204)\n       \u003c---------SYN/ACK------\n       ------------ACK--------\u003e\n```\n\n# TLS\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 TCP 연결에서 전송되는 모든 데이터는 일반 텍스트이며 교통량을 가로채는 사람이 관찰할 수 있습니다. 따라서 통신은 보안을 보장하기 위해 암호화됩니다 (HTTPS의 S).\n\n암호화를 위한 우리의 프로토콜 선택은 TLS 또는 전송 계층 보안입니다. TLS의 주요 부분은 핸드셰이크이며 주요 목표는 다음과 같습니다:\n\n- 암호화에 사용할 수 있는 대칭 키 교환\n- 응용 프로그램 프로토콜 협상\n- 서버 표시 및 인증\n\n클라이언트는 TLS 클라이언트 헬로 메시지를 보내어 TLS 핸드셰이크를 시작하고 세션 암호화를 요청하며 이 과정에서 HTTP/1.1과 HTTP/2를 제안합니다. 서버는 TLS 핸드셰이크를 완료하기 위해 서버 헬로 메시지로 응답합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nClient ------------SYN -------\u003e netlify (35.247.66.204)\n       \u003c---------SYN/ACK------\n       ------------ACK--------\u003e\n       ------Client Hello ----\u003e\n       \u003c-----Server Hello------\n```\n\n고객은 클라이언트 헬로 메시지의 일부로 여러 TLS 확장을 설정합니다. 특히 우리는 두 가지를 중점적으로 살펴볼 것입니다. 첫 번째는 \"ALPN\"으로 응용 프로그램 계층 프로토콜 협상을 의미하며, 두 번째는 \"SNI\"으로 서버 이름 지정을 의미합니다. 이들의 목적에 대해 설명하겠습니다.\n\n## ALPN\n\nALPN은 고객이 지원하는 응용 프로그램 프로토콜을 나타내는 TLS 확장입니다. 여기서 고객은 ALPN의 일부로 HTTP/1.1 및 HTTP/2 (h1 및 h2)를 제안하며, 고객 및 서버 양측에서 지원하는 가장 높은 프로토콜이 일반적으로 선택됩니다. 이 경우 서버는 HTTP/2를 선택합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-22-TheNetworkingbehindclickingalink_2.png)\n\n## SNI\n\nTLS 핸드셰이크에서 가장 중요한 요소는 아마도 SNI 또는 서버 이름 표시일 것입니다. 이 확장은 클라이언트가 관심 있는 도메인을 서버에 알려줍니다. 이는 한 IP 주소가 수천 개의 웹사이트를 호스팅할 수 있으므로 도메인을 표시함으로써 서버가 클라이언트가 관심 있는 정확한 웹사이트를 알 수 있게 되어 증명서를 반환할 때 어떤 웹사이트의 증명서를 반환해야 하는지 알 수 있습니다.\n\n클라이언트의 SNI는 backend.husseinnasser.com으로 설정되어 있습니다. Netlify 서버는 TLS 클라이언트 헬로 핸드셰이크를 수신하고 SNI를 이용하여 인증을 위해 클라이언트에 제공해야 하는 정확한 인증서를 파악할 수 있습니다. 이 인증서는 Netlify에서 내 도메인을 등록했을 때 Netlify가 생성한 것으로, 인증 기관은 Let's Encrypt입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-22-TheNetworkingbehindclickingalink_3.png)\n\n서버는 백엔드인 husseinnasser.com 인증서, 암호화 매개변수 및 선택한 응용 프로그램 프로토콜(HTTP/2)을 포함한 TLS 핸드셰이크를 완료하기 위해 서버 헬로를 보냅니다. 클라이언트와 서버 모두 암호화를 위한 대칭 키를 가지고 있으며, 이제 HTTP 요청을 암호화하여 보낼 준비가 되어 있습니다.\n\n# HTTP/2\n\nTCP 연결 위에 암호화된 세션이 있습니다. 이제 클라이언트는 페이지를 가져오기 위해 HTTP GET 요청을 보낼 수 있습니다. 선택한 응용 계층 프로토콜은 HTTP/2이므로 클라이언트는 요청을 보낼 HTTP/2 스트림이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 새로운 연결이기 때문에, 클라이언트가 요청을 위해 새로운 스트림을 생성합니다 (스트림 1). 클라이언트는 GET 메서드를 사용하여 HTTP 요청을 보내며, 경로는 / 입니다. backend.husseinnasser.com 다음에 아무것도 없기 때문입니다. 그리고 프로토콜 버전은 HTTP/2 입니다. 클라이언트는 HTTP 헤더를 설정하고 요청을 보냅니다.\n\n이렇게 보이는 예시가 있습니다. Host 헤더에 주목해 주세요. 이는 가장 중요한 HTTP 헤더 중 하나입니다.\n\n![이미지](/assets/img/2024-06-22-TheNetworkingbehindclickingalink_4.png)\n\n## Host 헤더\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n호스트 헤더가 없으면 모든 것이 망가집니다. 호스트 헤더는 웹 마스터들을 위한 몇 가지 문제를 해결하기 위해 HTTP/1.0에 선택적으로 추가되었습니다. 이러한 도전 과제들은 다음과 같습니다:\n\n- 하나의 IP 주소에서 여러 웹사이트 호스팅 가능\n- 프록시 서버 지원\n\n이에 따라 호스트 헤더는 나중에 HTTP/1.1 및 향후 프로토콜에서 필수 요소로 지정되었습니다.\n\n넷리파이를 예로 들어보면, IP 35.247.66.204는 수천 개의 웹사이트를 호스팅합니다. 많은 클라이언트가 동일한 IP 주소에 연결하지만, 넷리파이 서버가 클라이언트가 실제로 소비하려는 웹사이트를 어떻게 알 수 있을까요. 서버는 호스트 헤더를 사용하여 정확히 어떤 웹사이트를 가져올지 알 수 있습니다. 클라이언트가 백엔드.husseinnasser.com을 호스트 헤더로 설정하면 넷리파이 서버는 내 깃허브 레포지토리 내용의 사본을 가리키고 HTML 페이지를 제공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클라이언트가 GET 요청과 함께 쿠키 헤더를 보낼 수도 있습니다. 서버는 이를 사용하여 사용자를 식별합니다.\n\n프록시 구성에서 클라이언트의 목적지 IP는 프록시이므로, 클라이언트가 실제로 연결하려는 웹 사이트를 프록시가 알기 위해 응용 프로그램 레이어에서 추가 표시가 필요합니다.\n\n서버는 스트림 1에서 GET 요청을 받고 호스트 헤더를 확인하여 기본 페이지 index.html을 가져옵니다. 쿠키가 전송되었는지 여부에 따라 서버는 같은 스트림으로 다른 HTTP 응답을 보냅니다.\n\n# udemy로 리디렉션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클라이언트가 index.html 페이지와 함께 HTTP 응답을 드디어 받습니다. 이 페이지는 다음과 같이 간단한 HTML을 포함하고 있습니다.\n\n```js\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n    \u003cmeta charset=\"UTF-8\"\u003e\n    \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e\n    \u003cmeta http-equiv=\"refresh\" content=\"0; URL=https://www.udemy.com/course/fundamentals-of-backend-communications-and-protocols/?couponCode=BACKEND10V2\" /\u003e\n\n    \u003ctitle\u003e백엔드 통신 디자인 패턴과 프로토콜 기초\u003c/title\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n   \u003ch1\u003eudemy로 리디렉팅 중...\u003c/h1\u003e\n   \u003ch2\u003e제 백엔드 엔지니어링 강좌를 즐기세요\u003c/h2\u003e\n\n\u003c/body\u003e\n\u003c/html\u003e\n```\n\nmeta 헤더 중 http-equiv refresh와 content=0 그리고 URL에 주목해주세요. 이것은 브라우저에 해당 URL로 즉시 리다이렉트하라고 알려줍니다. 사용자가 다른 링크를 클릭한 것처럼 정확히 동일한 단계가 반복됩니다. 여기서 수행되는 정확한 단계들은:\n\n- udemy.com의 IP 주소 DNS를 조회\n- TCP 연결 생성\n- TLS 설정\n- HTTP 프로토콜 협상\n- HTTP/2 스트림 생성\n- 경로가 /course/fundamentals-of-backend-communications-and-protocols/?couponCode=BACKEND10V2인 새로운 GET 요청 보내기\n- udemy에 로그인되어 있다면 쿠키가 전송됨\n- Udemy 서버는 회원 가입 상태에 따라 코스 페이지로 응답합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠폰 코드는 URL 끝에 couponCode라는 쿼리 매개변수로 지정됩니다. 매달 쿠폰을 업데이트하고 변경 사항을 GitHub에 푸시하여 Netlify 재빌드를 트리거합니다. backend.husseinnasser.com을 방문하는 사람은 항상 최신 쿠폰을 받을 수 있습니다. 나중에 코스 제공업체를 변경하기로 결정한다면 index.html에서 URL을 업데이트하면 됩니다. 원래 링크는 결코 변경하지 않습니다.\n\n# 요약\n\n이 기사의 목표는 소프트웨어 엔지니어링의 기술을 알리는 데 있습니다. 인터넷을 구동하는 통신 프로토콜을 설계하고 구현한 우수 엔지니어들이 수고를 아끼지 않았습니다.\n\n저는 엔지니어로서 이 작업이 종종 당연히 여기고 감사히 여겨지지 않는다고 생각합니다. 프로토콜이 어떻게 작동하는지 이해하는 것은 네트워크 엔지니어링의 진화에 기여하고 더 나은 프로토콜을 만들 수 있는 첫걸음입니다. 링크를 클릭하는 등 간단한 작업을 수행하는 데 필요한 것을 보셨습니다. 그러면, 더 나은 방법으로 만들 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n읽어주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-06-22-TheNetworkingbehindclickingalink_0.png"},"coverImage":"/assets/img/2024-06-22-TheNetworkingbehindclickingalink_0.png","tag":["Tech"],"readingTime":11},{"title":"표준화된 주택이 더 나은 확장 가능한 소프트웨어 개발에 필요한 이유","description":"","date":"2024-06-22 23:39","slug":"2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware","content":"\n대규모 팀 개발에 대해 이야기할 때, 또는 더 정확히 말하면 여러 팀이 공통 목표를 향해 협력해야 하는 프로젝트에서는 무엇이 잘 되고 무엇이 잘 안 되는지의 역학이 빠르게 변합니다. 10명 또는 심지어 20명의 팀에 효과적인 것이 100명 이상의 팀에는 효과적이지 않을 가능성이 있음을 분명히 알 수 있습니다. 더 작은 팀으로 나누어져 있더라도 의존성과 과정이 강력하다면, 그들은 사실상 훨씬 큰 가상 팀이 되어버립니다 (이에 대해 이전에 기사에서 논의했습니다).\n\n본 기사에서는 많은 주제를 다룰 수 있지만, 확장이 큰 문제이기에 한 가지 개념에 초점을 맞출 것입니다. 그리고 이 개념은 도시 계획 단체인 '강한 도시'의 배움을 통해 더 잘 이해될 수 있습니다. 내 직관과 소프트웨어 공학 매뉴얼에 설명되어 있음에도 불구하고, 강한 도시가 등장하기 전까지는 완전히 이해하고 모델링하지 못했습니다. 그리고 이제 여러분과 이 배움을 공유하고 싶습니다, 여러분도 그 혜택을 받을 수 있도록요.\n\n놀라우신가요? 도시와 도시 계획을 개선하기 위해 전념하는 단체의 연구가 소프트웨어 개발로 전달할 수 있는 의미 있는 통찰과 모델을 제공할 수 있는가요? 그러나 이것을 생각해 보면, 그리 놀랄 일은 아닙니다, 맞죠? 더 구체적이고 일상적인 것들에서 비유를 사용하여 더 추상적이고 개념적인 측면을 이해하고(모델링)하는 데 도움이 되기 때문입니다. 예를 들어 전기를 물로 생각하는 것은 많은 속성을 이해하는 데 도움이 됩니다(물론 모든 것을 이해하는 데 도움이 되는 것은 아닙니다).\n\n그래서, 강한 도시에서 어떤 개념이 내가 대개 큰 팀들이 잘못 관리되는 것을 다시 생각하게 했을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘, 나는 Charles Marohn(강력한 도시의 대통령이자 설립자)이 계획된 도시 발전의 문제에 대해 이야기하는 것을 많은 시간동안 듣고 있었어. 그리고 이번에는 한 가지 개념이 나에게 더 깊게 와닿았고, 소프트웨어 엔지니어링 세계와도 직접적인 관련성을 느꼈어.\n\n그의 말씀은 다음과 같았어:\n\n내가 무엇을 깨달았는지 생각해볼 수 있겠니?\n\n큰 팀을 위한 아키텍트의 역할을 생각해볼 때, 많은 사람들을 모아 팀을 조직하는 역할에 대해 고려해봤을 때, 보통의 접근 방식은 종종 동질화하는 것이야. '모두가 같은 도구를 사용한다면, 우리는 지식과 해결책을 널리 활용할 수 있겠지'라는 생각이야. 나도 오랫동안 이것을 믿었어. 나는 이것을 정말 놀랍게 여기기도 했고, 솔직히 말해서 그 당시에는 미니프론트엔드나 미니프레임워크 같은 방법론이 각 팀이 자신에 맞는 프레임워크나 라이브러리, 데이터베이스 등을 선택할 수 있다고 가정한 것을 비웃기도 했어. 나에게는 이것이 순수한 혼돈과 재앙의 레시피로 느껴졌지.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음 경험이 찾아왔어요. 종이 위에서 잘 작동해야 했던 모든 것이 예상대로 되지 않았음을 관찰했습니다. 간단해 보이는 작은 변화도 대규모이며, 느리고 모든 팀 또는 모든 팀이 참여해야 하는 프로젝트로 변모했으며, 수개월 또는 몇 년이 걸렸습니다. 모든 것이 바람을 맞서 있었어요.\n\n이를 보며, 마이크로프론트엔드 또는 마이크로프레임워크(기본적으로 DDD, 도메인 주도 설계)로부터의 모든 가르침들을 감사히 여기기 시작했습니다. 그러나 뭔가가 부족했어요 — 일어나고 있는 일의 모델을 내면화하는 능력이죠. 물의 비유를 이해함으로써 전기를 이해하는 데 도움이 되었던 것과 마찬가지로, 이 한 부분은 'Strong Towns'의 단편이 프로젝트를 이해하는 데 어떻게 재앙이 될 수 있는지 명확히 보여줬어요.\n\n제가 이전에 언급한 인용구를 고려해 보면 이해하기 쉬워요. '모든 집이 같은 방식으로 지어진다'라고 이야기 합니다. 이제 이를 소프트웨어 개발에 확장해 보아요. 프로젝트의 프론트엔드 프레임워크로 Angular 18(당시의 최신 버전)이어야 한다고 결정한 경우를 상상해 보세요. 그러면 모든 팀이 이것과 함께 작업하게 됩니다. 그러나 인용문이 어떻게 이어지는가요? '모든 지붕이 동시에 고장날 것이다.' 소프트웨어에서도 동일한 일이 벌어질 것입니다. 언젠가 '와, Angular 18은 이제 너무 오래됐네요. Angular 26로 업데이트해야 할 필요가 있어요.' 라는 말을 할 수가 있잖아요. 이게 무슨 의미인가요? 개발을 중단하고 모든 팀을 이전시키고, 모두에게 동일한 업그레이드라고 생각해도 사실은 그렇지 않을 것입니다. 각 팀은 다양한 문제를 마주하며 다른 단계가 필요할 것이고, 누군가는 쉽게 해결하겠지만, 누군가는 매우 어려워할 것입니다. 이는 거대한 결정이 됩니다. 모든 팀에 통일된 것을 변경하는 비용은 행한 어떤 결정에도 적용되며, 표준 라이브러리, 패턴, 아키텍처, 데이터베이스, 환경 등을 포함합니다. 모든 변경에는 엄청난 비용이 발생할 것입니다. 우리는 엄청난 가격을 지불하거나 낡은 기술로 고정된 취약한 해결책에 얽매이는 선택을 해야할 것입니다 — 마치 팟캐스트가 설명한 것처럼, 모든 집이 동시에 악화되기 시작하고 동네가 저하되며 가치를 잃는 20년 이상이 지난 후에 어떻게 될 것인지 생각해 보세요. 궁극적으로, 우리는 갇히게 될 것입니다.\n\n해결책은 무엇일까요? 팟캐스트에서 설명한 것은?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n'해결책'은 끝 부분에 나옵니다. 이는 스트롱 타운즈(Strong Towns)의 철학을 반영하고 있습니다: 점진적 적응. 큰 변화를 만들지 말고, 대신 작은 개선에 집중해보세요. 한꺼번에 100채의 집을 짓지 말고 2채를 개조하고, 또 다른 것을 개조하고, 이런 식으로 진행하세요. 고대부터 도시가 가지고 있던 유기적 발전을 이어갔으면 좋겠고, 현재 멋을 준 계획을 피하면서 떨어진 모양을 피해야 합니다.\n\n소프트웨어 개발로 번역하면 DDD 방법론, 마이크로서비스 및 마이크로프론트엔드의 권고 사항과 일치합니다. 각 팀이 자신의 필요에 따라 선택하고 발전할 수 있게 놔두세요. 그렇다고 모든 팀을 이리저리 옮기기 어렵고, 더 많은 스택을 모니터링해야 할 것입니다. 하지만 더 민첩해질 것입니다. 팀이 라이브러리를 적응해야 할 때, 다른 팀들을 중단시키지 않고 그 작업을 수행할 수 있습니다. 점진적으로 전체 응용프로그램 및 모든 팀을 업데이트할 수 있습니다. 모두 한꺼번에 하는 것이 아니라 스트롱 타운즈가 제안하는 대로 유기적으로 진행될 것입니다. 라이브러리에 심각한 문제가 발생하여 모든 개발을 급작스럽게 중단할 수 있는 대규모 실패는 발생하지 않을 것이며, 대신 모든 것이 더 적응 가능해질 것입니다. 그리고 민첩해질 것입니다.\n\n사실 이와 연결하여 한때 막혀있거나 실패한 소프트웨어를 구하는데 관한 안내서를 작성해보았습니다. 이것도 동일한 아이디어를 기반으로 하고 있습니다. 모든 것을 새롭게 다시 하는 것은 필요하지 않습니다. 그냥 매일 최상의 조건에서 작업하도록 노력하고, 가장 생산적인 환경에서 작업하며, 손대지 않아도 되고 잘 작동하는 코드를 그대로 두세요.\n\n재미있지 않나요? 스트롱 타운즈의 철학과 애자일(Agile)이 얼마나 유사한지? 그러나 생각해보면 그리 놀랍지는 않을 것입니다. 스트롱 타운즈는 사람들이 함께(도시적으로) 진보하고 발전하는 방법에 중점을 둡니다. 이를 효율적으로 수행하는 방법은 반복적이고, 작은 단계로 진행하면서 배우는 것입니다. 사물을 유기적으로 발전하게 해서 이미 작동 중인 구조를 활용하고, 더 나은 결과를 위해 그 위에 쌓는 것입니다. 본질적으로 이것이 과학적 방법의 기초이며, 이것이 리안 제조 및 애자일 정신을 지지하는 바탕이기도 합니다. 그럼, 어째서 오리브 캔의 물류에 대한 이야기를 들을 때, 팀의 효율성을 10배로 향상시킬 방법을 찾게 될지 모르겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n읽어 주셔서 감사합니다. 일반적으로 소프트웨어 엔지니어링을 어떻게 이해하고 적용하는지 고민하며 이를 통해 우리가 어떻게 개선할 수 있는지에 대해 이야기하는 것을 좋아합니다. 이 글이 마음에 드셨다면 박수를 치거나 댓글을 남겨주세요. 더 많은 통찰력과 토론을 위해 제가 Medium에 올린 가장 성공적인 이야기들을 살펴보세요.\n","ogImage":{"url":"/assets/img/2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware_0.png"},"coverImage":"/assets/img/2024-06-22-HowCookie-CutterHomesTeachUstoWriteBetterScalableSoftware_0.png","tag":["Tech"],"readingTime":5},{"title":"Uber는 어떻게 매일 페타바이트 규모의 Spark 셔플 데이터를 처리할까","description":"","date":"2024-06-22 23:37","slug":"2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday","content":"\n## 원격 외부 서비스 (RSS)\n\n# 목차\n\n- Uber의 Apache Spark\n- 원래의 셔플\n- MapReduce에 대한 새로운 생각\n- RSS 아키텍처\n\n# TL;DR\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스파크 셔플 데이터의 대규모 규모는 Uber에 약간의 문제를 일으킵니다. 이에 대응하여 Uber는 원격 셔플 서비스(RSS)를 사용하여 셔플 데이터를 원격으로 관리하기로 결정했습니다. RSS의 주요 아이디어는 스파크 실행자가 맵 작업에서 셔플 데이터를 원격 서버로 보내도록 한 다음 리듀서가 거기서 데이터를 가져오도록하는 것입니다. 게다가, Uber는 솔루션을 더 효율적으로 만들기 위해 원본 MapReduce 패러다임을 역전시켰습니다.\n\n# 소개\n\n내 글 쓰기 역사를 돌이켜보면, 내 첫 블로그는 BigQuery가 셔플 작업을 처리하는 방법에 대한 기사입니다. 그 블로그에서는 Google이 Dremel의 셔플 도전 과제를 해결하기 위해 전용 인메모리 셔플 서버를 구축할 때 사용한 흥미로운 접근 방식에 대한 메모를 공유했습니다. Dremel 맵 워커가 로컬 디스크에 셔플 레코드를 쓰는 대신 결과를 원격 서버에 쓰고 리듀스 워커가 데이터를 가져오도록 했습니다. Google은 이 방법이 셔플 스케일링 도전 과제에 대응하는 데 도움이 되었다고 말했지만, 원격 셔플 솔루션의 세부 사항에 대해서는 자세히 설명하지 않았습니다.\n\nDremel의 셔플 작업이 Google에 문제를 일으키는 요소 중 하나는 처리해야 하는 데이터의 거대한 양입니다. 이로 인해 나는 궁금해졌습니다: \"셔플 작업에서 문제를 일으키는 거대한 규모의 데이터를 처리해야하는 다른 기업이 있는가?\". 조사한 결과, Uber가 Dremel과 같은 문제를 겪고 있는 Spark에 문제가 있다는 것을 발견했습니다. Uber의 글에는 Spark 셔플 작업을 처리하기 위해 전용 서버를 개발했다는 내용이 있습니다. 다행이도 글은 솔루션이 어떻게 동작하는지에 대한 내용을 자세히 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 주의 글은 우버(UBER)에서 공개한 훌륭한 블로그 게시물을 읽은 후에 작성한 제 노트입니다: 높은 확장성과 분산 셔플 서비스.\n\n## 우버(Uber)에서의 아파치 스파크\n\n스파크는 우버(Uber)의 주요 컴퓨팅 엔진으로, 라이드, 우버 이츠(Uber Eats) 또는 지도와 같은 운영을 지원합니다. 데이터 웨어하우징, 데이터 과학, 그리고 AI/ML에 있어서 필수적입니다. 우버의 스파크 사용량은 기하급수적으로 증가했으며, 하루에 수 백 페타바이트의 데이터를 처리하는 10,000대 이상의 프로덕션 노드에서 실행됩니다. 현재 스파크 작업은 분석 클러스터 계산 자원의 95% 이상을 사용하고 있습니다. 우버의 규모에 맞게 스파크를 운영하는 것은 데이터 이동과 관련된 도전에 직면하며, 특히 잘 알려진 셔플이라고 불리는 작업 단계 간 데이터 전송에 있어서 중요한 문제가 있습니다. 다음 섹션에서는 우버에게 중요한 원래의 스파크 셔플과 그것이 가지는 중요한 도전에 대해 알아보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_0.png)\n\n과거의 Spark 셔플러에는 두 가지 종류의 작업이 있었습니다: 맵과 리듀스. 첫 번째는 셔플 데이터를 생성하고, 후자는 이를 사용합니다. Spark에서 작업 교환은 풀 모델을 사용하여 데이터를 섞습니다. 맵 작업은 셔플 데이터를 로컬 디스크에 작성합니다. 그런 다음 리듀스 작업은 여러 맵 작업에게 해당 데이터를 가져오기 위해 연결합니다.\n\n## 셔플 쓰기\n\n![이미지](/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우버의 초기 Spark 셔플 구현은 맵 작업이 셔플 데이터를 실행자의 로컬 디스크에 쓸 수 있게 했습니다. 먼저 데이터를 메모리 버퍼에 씁니다. 버퍼가 가득 차면 데이터를 임시 파일로 디스크에 흘립니다. 나중에 모든 흘림 파일을 최종 셔플 파일로 병합합니다. 우버는 이 프로세스가 최적화되지 않았음을 깨달았습니다. 많은 경우에, 장애 파일에서 여러 디스크 작업(읽기 및 쓰기)을 수행해야 하여 지연을 초래합니다.\n\n## 셔플 읽기\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*f9fRJZZBKeHhtBtZsVFTyw.gif)\n\n맵 호스트에서는 여러 파티션에서 많은 데이터 파일이 오는데, 호스트는 또한 각 파일이 어느 파티션에 속하는지 추적하기 위해 파티션 오프셋을 유지하는 인덱스 파일을 유지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nreduce 작업은 각 맵퍼 호스트에서 실행 중인 셔플 서비스와 통신하여 해당 호스트에서 셔플 파티션 출력을 가져옵니다. 셔플 서비스가 요청을 받으면 인덱스 파일에서 오프셋을 읽고 reduce 작업에 필요한 데이터를 찾아 반환합니다. 그 후에 reduce 작업은 데이터를 메모리 버퍼로 가져와서 리듀서 프로세스에서 사용할 이터레이터를 생성합니다. 이 과정은 비효율적입니다. 왜냐하면 리듀서가 파티션 데이터를 가져오기 위해 많은 맵퍼 호스트에 요청해야 하며, 이로 인해 네트워크 오버헤드가 발생하고 맵퍼 호스트가 많은 디스크 작업을 수행해야 합니다.\n\n## 도전과제\n\nUber가 대규모로 Spark 셔플을 운영할 때 여러 도전 과제가 있었습니다:\n\n- 하드웨어 신뢰성: 매일 SSD에 쓰이는 대량의 셔플 데이터로 인해 초기 설계에서 예상한 것보다 더 빨리 Uber 디스크가 소모됩니다. 3년간 유지될 것으로 예상되었던 디스크는 대신 6개월 만에 소모됩니다.\n- 셔플 실패: 리듀서가 동일한 기계에서 모든 맵퍼 작업의 데이터를 가져올 때, 서비스가 사용 불가능해지며, 이로 인해 많은 셔플 실패가 발생합니다.\n- 노이즈 이슈: 더 많은 셔플 데이터를 작성하는 응용 프로그램은 해당 기계의 디스크 공간을 모두 차지하여 다른 응용 프로그램이 디스크가 가득 찼다는 예외로 실패할 수 있습니다.\n- 셔플 서비스 신뢰성 문제: Uber는 Spark에서 YARN 및 Mesos를 사용하여 외부 셔플 서비스를 사용합니다. 그들은 종종 일련의 노드에서 셔플 서비스를 사용할 수 없다는 경험을 가졌습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Uber가 문제를 해결하기 위한 노력\n\nUber는 지역 데이터 저장이 위에서 언급한 문제의 근본 원인 중 하나라는 것을 깨달은 후, 원격 기기에 셔플 데이터를 저장하는 여러 가지 접근 방식을 시도해 보았습니다:\n\n- 다른 저장소 플러그인 사용: Uber는 Spark를 위한 셔플 관리자를 작성하여 다양한 저장소 플러그인을 지원하도록 하고, 셔플 파일을 HDFS 또는 NFS에 쓸 수 있는 플러그인을 개발했습니다. 그러나 테스트 결과, Spark 작업의 실행 시간이 2배에서 5배 증가했습니다.\n- 스트리밍 쓰기: Uber는 Spark 실행기로부터 스트림을 수락할 수 있는 스트리밍 서버를 구축했습니다. 이들은 이러한 스트림의 싱크 대상으로 HDFS 및 로컬 저장소를 사용했지만, 작업 지연이 1.5배에서 3배 증가했습니다.\n\n# MapReduce에 대한 새로운 접근 방식\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 번의 실험 끝에 Uber는 매퍼에서 원격 서버로 스트리밍 쓰기를 통해 문제를 해결할 수 있다는 것을 발견했습니다. 그러나 이 방식의 성능은 현재 지역 머신 성능(맵 태스크가 데이터를 로컬 디스크에 쓰는 곳)과 비교할 수 없다고 합니다. 따라서 Uber는 원격 쓰기를 위해 맵-리듀스 패러다임을 역전시켰습니다.\n\n처음에 맵 태스크는 데이터를 로컬 머신에 기록하고, 그 후 리듀스 태스크가 단일 파티션의 데이터를 얻기 위해 여러 매퍼 머신에 도달하였습니다. 이렇게 함으로써 리듀서는 각 맵 머신으로 이동하여 데이터를 가져오고 이를 최종적으로 병합하여 리듀스 프로세스를 수행하는 데 많은 시간이 소요되었습니다.\n\nApache Spark를 위해 Remote Shuffle Service(RSS)를 구현하기 위해, 매퍼는 셔플 데이터를 원격 서버로 써야 합니다. Uber는 매퍼가 동일 파티션의 데이터를 고유한 RSS 서버로 쓰도록 지정하여, 리듀서가 하나의 RSS 서버에서만 데이터를 가져오도록 했습니다. 이를 통해 Uber는 이제 리듀서가 여러 매퍼에 통신할 필요가 없어져서 원격 셔플 서버에서의 Spark 작업 지연을 완화할 수 있었습니다.\n\n# RSS 아키텍처\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![RSS architecture](https://miro.medium.com/v2/resize:fit:1400/1*SthOAIxcxzMl_pM5yqVdlw.gif)\n\n다음은 RSS의 전반적인 아키텍처입니다:\n\n- RSS에서 모든 Spark executor들은 서비스 레지스트리와 RSS 서버와 통신하기 위해 클라이언트를 사용합니다.\n- 초기에 Spark 드라이버는 Zookeeper를 활용하여 동일한 파티션에 대한 고유한 RSS 서버 인스턴스를 식별합니다.\n- 드라이버는 이 정보를 모든 매퍼와 리듀서에게 전달합니다.\n- 매퍼와 리듀서는 이 정보를 사용하여 셔플 데이터 프로세스를 처리합니다.\n\n## RSS 클라이언트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRSS는 클라이언트 측 jar 파일을 가지고 있으며 Apache Spark가 제공하는 Shuffle Manager 인터페이스를 구현합니다. 드라이버는 서비스 레지스트리를 쿼리하여 Shuffle을 처리할 RSS 서버 목록을 선택합니다. 그런 다음 드라이버는 이 메타데이터를 Shuffle 핸들 내에 인코딩합니다. Spark 머신은 Shuffle 핸들(다른 인터페이스)을 맵-리듀스 작업에 전달할 것입니다.\n\n위에서 언급한대로, 모든 매퍼는 특정 파티션의 Shuffle 데이터를 단일 RSS 서버로 보냅니다. 따라서 리듀서는 특정 파티션의 Shuffle 데이터를 읽기 위해 단일 RSS 서버에 연결하기만 하면 됩니다.\n\nRSS 클라이언트는 Shuffle 데이터의 복제 팩터를 여러 RSS 서버에 지정할 수도 있습니다. 매퍼는 단일 서버에 기록하는 대신, 서버 다운에 대한 내고장성을 추가하기 위해 두 개 이상의 서버로 데이터를 기록할 것입니다.\n\n전체 클라이언트는 Shuffle Manager 인터페이스에서 구현되므로 Spark 코드베이스에는 코드 변경이 없습니다. Spark 작업 관점에서는 모든 것이 같지만, 매퍼가 이제 로컬 디스크에 쓰기 대신 Shuffle 데이터를 RSS 서버로 보내야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 서비스 레지스트리\n\nRSS에서 서비스 레지스트리는 사용 가능한 RSS 서버 목록을 유지합니다. Uber는 서비스 레지스트리로 Zookeeper를 사용합니다. 각 RSS 서버는 주기적으로 상태를 업데이트하기 위해 ZooKeeper와 장시간 연결을 유지합니다. 셔플 등록 중에 Spark 드라이버는 Zookeeper에서 모든 사용 가능한 RSS 서버 목록을 검색합니다. 그런 다음 드라이버는 지연 시간, 셔플 파티션, 활성 연결 등 여러 요소를 기반으로 서버를 선택합니다. 이 프로세스를 마치면 드라이버는 사용 가능한 서버 목록을 셔플 핸들 내의 매퍼 및 리듀서에 전달합니다.\n\n이 접근 방식은 각 RSS 인스턴스가 자체를 서비스 레지스트리에 등록해야 한다는 것을 필요로 합니다. 인스턴스는 실패하고 서비스 레지스트리에 연결을 잃으면 자동으로 등록 해제됩니다. 익스큐터는 사용 가능한 인스턴스 및 데이터 셔플 위치에 대한 정보를 얻기 위해 서비스 레지스트리와 통신합니다.\n\n## 셔플 매니저\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**Shuffle Manager** in RSS는 Spark의 셔플 관리자 인터페이스를 구현하는 구성 요소입니다. 이는 원격 셔플 서비스 인스턴스를 선택하고 추적하여 (매퍼) 데이터를 업로드하고 (리듀서) 다운로드하기 위한 책임을 가지고 있습니다.\n\n## RSS 서버\n\n![RSS Server](/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_2.png)\n\n각 매퍼는 셔플 데이터를 고유한 RSS 서버에 작성합니다. 클라이언트로부터 복제된 설정이 있는 경우 데이터는 내결함성을 위해 하나 이상의 서버에 작성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n셔플 데이터 스트림은 각 레코드가 파티션 ID와 실제 데이터를 가지고 있는 셔플 레코드의 시퀀스입니다. RSS 서버가 매퍼로부터 셔플 레코드를 받으면, 해당 파티션 ID를 기반으로 로컬 파일을 선택하고 레코드를 파일 끝에 추가합니다.\n\nRSS 서버에서는 미접근된 셔플 데이터를 주기적으로 확인하고 36시간 이내에 접근되지 않은 데이터를 삭제하는 정리 스레드가 실행됩니다. Uber는 RSS 서버 당 동시 연결 수를 제한하여 RSS 서버가 과중되지 않도록 합니다.\n\n# 고장 허용\n\n- RSS 서버가 바쁠 때: 클라이언트가 RSS 서버에 도달하지 못할 경우, 서버에 부담을 주지 않도록 지수 함수적 백오프 재시도를 수행합니다.\n- RSS 서버 다시 시작: 서버는 로컬 디스크로 셔플 데이터 파일을 읽어 다시 시작한 후 이전 상태를 복구합니다. 이러한 상황에서 맵 태스크가 실패하면 Spark 애플리케이션이 새로운 태스크 시도 ID로 이러한 실패한 태스크를 재시도합니다. RSS 서버는 파일에 저장된 각 셔플 레코드의 시도된 태스크를 유지합니다. 서버는 최종으로 성공한 태스크 시도 ID만 저장합니다. 리듀서는 마지막으로 성공한 시도가 있는 셔플 레코드만 수락합니다.\n- 서버 다운: RSS 서버를 사용할 수 없는 경우 복제는 유용합니다. 셔플 데이터는 하나 이상의 RSS 서버에서 제공될 수 있습니다. 이러한 상황에서 필요하면 Spark 드라이버가 영향을 받는 매퍼/리듀서 스테이지를 다시 예약합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 하드웨어 신뢰성\n\n거의 10 PB의 디스크 쓰기를 원격 서버로 오프로딩하여 최적화된 I/O-하드웨어로, RSS를 사용하여 SSD의 내구 시간을 3개월에서 36개월로 연장된다. 원래의 셔플 구현에 있어 3개월의 수명주기를 갖고 있던 SSD 디스크는 이제 RSS 서버를 도입한 이후 거의 3년 동안 사용할 수 있다.\n\n# 애플리케이션 신뢰성\n\n운영 환경에 RSS를 배포한 후, Spark 작업의 실패율이 크게 감소했다; 셔플 실패로 인한 실패율은 거의 95%로 줄었다. 또한, RSS 서버가 다운되는 경우를 대비해 장애 허용 기능을 추가함으로써 Uber는 99.99% 이상의 신뢰성을 달성했다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 확장성\n\n현재 우버의 RSS는 하루에 약 220k 개의 애플리케이션을 처리하며, 약 80k 번의 셔플 및 일일 10 PB의 데이터를 처리합니다. 하나의 셔플마다 약 40 TB의 데이터를 처리하는 프로덕션 작업을 갖고 있습니다. RSS는 셔플 프로세스에 더 많은 RSS 서버를 참여시킴으로써 이러한 대규모 셔플을 쉽게 처리할 수 있습니다. 이는 스파크의 기본 외부 셔플에서는 불가능했으며, 각 기계의 디스크 크기에 의해 제한되었으며, 일반적으로 1 TB SSD를 사용했습니다.\n\n# 마무리\n\n이 기사를 통해 우버 블로그 게시물에서 얻은 주요 통찰을 문서화했습니다. 스파크의 원래 셔플 작업의 도전과제를 논의한 뒤 우버가 원격 셔플 서비스를 도입함으로써 이를 극복한 방법을 살펴보았습니다. 셔플 데이터의 원격 쓰기 및 읽기로의 전환은 네트워크를 통해 이제 이러한 작업을 수행해야 하므로 추가된 대기 시간의 가능성을 도입합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만, 이 변경 역시 상당한 혜택을 가져다줍니다. 예를 들어, 줄어든 worker는 이제 입력 데이터를 읽기 위해 여러 map worker와의 통신이 필요 없어졌으며, 하나의 서버에서만 데이터를 읽으면 됩니다. 셔플된 데이터를 로컬 디스크로 이동하는 것은 Uber에게 다양한 엔지니어링 기회를 제공합니다. 예를 들어, map worker에 장애가 발생하더라도, 데이터가 RSS 서버에 원격으로 저장되어 있기 때문에 처리된 데이터에는 영향을 주지 않습니다.\n\n이번 주는 여기까지 입니다. 읽어 주셔서 감사합니다.\n\n다음 주에 뵙겠습니다.\n\n# 참고문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해 드릴게요.\n","ogImage":{"url":"/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_0.png"},"coverImage":"/assets/img/2024-06-22-HowdoesUberhandlepetabytesofSparkshuffledataeveryday_0.png","tag":["Tech"],"readingTime":13},{"title":"프로그래밍 언어를 만드는 단계별 가이드","description":"","date":"2024-06-22 23:34","slug":"2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage","content":"\n## 몇 시간 안에 처음부터 프로그래밍 언어 구축하기\n\n![이미지](/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_0.png)\n\n세상에는 다양한 용도로 만들어진 프로그래밍 언어가 가득합니다. 이러한 언어 중 대다수는 매우 일반적인 목적을 위해 만들어졌지만 때로는 매우 특정한 용도에 맞는 언어를 설계하기를 원할 수 있습니다(예: Facebook은 React를 개발하여 웹 응용 프로그램을 보다 쉽게 개발하기 위해 설계했고, Apple은 최근 Pkl이라는 언어를 개발하여 구성을 보다 쉽게 만들었습니다. 다양한 분야에서 이와 같은 예가 많이 있습니다). 따라서 프로그래밍 언어를 구축하는 방법을 알고 있는 것은 가지고 있는 것이 유용한 기술입니다.\n\n이 문서에서는 처음부터 해석형 프로그래밍 언어를 만들고 람다 대수와 프로그래밍 언어 전반에 대해 알아가는 과정을 조금 배웁니다. 여기서 만들어볼 언어는 꽤 독특할 수 있지만, 이 과정을 통해 당신이 자신만의 특정 용도 언어를 설계하는 방법과 프로그래밍 언어가 어떻게 작동하는지에 대해 유용한 정보를 가르칠 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 게임 계획\n\n저희는 해석형 언어¹을 개발 중이니, 우리의 전반적인 흐름은 다음과 같을 것입니다:\n\n![프로젝트 이미지](/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_1.png)\n\n기본적으로, 우리는 우리가 작성하려는 대상 언어로 된 몇 가지 구체적인 구문(코드)으로 시작하고, 이를 추상 구문 트리로 변환하는 구문 분석기에 전달합니다(이것은 작업하기 쉬운 코드의 트리 표현입니다). 그 후에 실행된 추상 구문 트리를 우리에게 최종 결과를 제공하는 해석기에 전달합니다. 구문 분석기와 해석기는 이미 존재하는 호스트 언어로 작성됩니다 — 예를 들어 C 언어의 초기 구문 분석기와 컴파일러는 어셈블리어로 작성되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\\*\\*참고: 여기서 사용하는 \"파서\"는 파싱 프로세스 전체를 포괄합니다. 일반적으로 렉싱은 \"파싱\" 이전에 수행됩니다. 그러나 이 경우 파싱은 구체적인 구문을 추상 구문으로 변환하는 프로세스입니다. 이 프로세스에는 다양한 형태가 있을 수 있습니다.\n\n예를 들어, 기본 산술 연산을 위한 간단한 언어에 대한 다음 명세를 고려해보십시오:\n\n```js\nEXPR =\n  number | (EXPR + EXPR) | (EXPR - EXPR) | (EXPR * EXPR) | (EXPR / EXPR) | EXPR;\n```\n\n위의 내용은 컨텍스트-프리 문법에 대한 EBNF입니다. 여기서 깊이 들어가진 않겠지만, 이 형태의 프로그래밍 언어는 모두 CYK 알고리즘을 통해 다항 시간 내에 파싱할 수 있습니다. 이 EBNF에서 (4 + 4) \\* 3과 같은 것은 유효한 프로그램이지만, def f(x): return 5; f(5)와 같은 것은 유효하지 않습니다.\\*\\*\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 우리가 구체적인 구문 (4 + 4) \\* 3을 주어졌다고 가정해 봅시다. 파싱 후에는 다음과 같은 추상 구문 트리(AST)를 얻어야 합니다:\n\n![AST](/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_2.png)\n\n그런 다음 우리의 해석기는 루트에서 시작하여 트리를 재귀적으로 타고 내려가면서 답인 24를 얻습니다.\n\n이 문법이 모호한 점에 대한 간단한 언급을 해보면 — 예를 들어, 표현식 4 + 4 _ 3은 어떻게 파싱되어야 할까요? 이것은 위에 언급된 ((4 + 4) _ 3)로 파싱되거나, 4 + (4 \\* 3)로 파싱될 수 있습니다 — 이 둘 다 유효한 파싱 트리이기 때문에 더 이상 “정확한” 파싱이라고 말할 수 없습니다. 이와 같은 경우에는 파서가 언어를 파싱하는 방법에 대해 임의로 결정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 저희 구문 설계하기\n\n플로 차트에 따르면, 첫 번째 단계로 저희는 구체적인 구문을 설계해야 합니다. 구문을 만드는 방법은 완전히 당신에게 달려 있어요. 저는 EmojiLang이라는 (형편없는) 언어를 만들기로 결정했어요. 이 언어는 당신이 타이핑할 때 매우 다채로운 화면을 보장합니다. 문법은 아래와 같아요:\n\n```js\ngrammar EmojiLang;\n\nprogram: '🏃‍♂️🏃‍♂️🏃‍♂️' expr '🛑🛑🛑' EOF;\n\nexpr: '(' (ID\n         | atom\n         | ifCond\n         | anonFunctionDefn\n         | funApplication\n         | varAssignment\n         | READ_FLOAT\n         | READ_STRING\n         | printExpr\n         | sequentialOp\n         | baseComputation) ')';\n\natom: NUMBER | BOOLEAN | STRING;\nifCond: '🤔' cond=expr '❓' ontrue=expr ':' onfalse=expr;\nanonFunctionDefn: '🧑‍🏭' arg=ID '⚒️' body=expr;\nfunApplication: '🏭' fun=expr arg=expr;\nvarAssignment: '📦' var=ID '🔜' val=expr;\nprintExpr: '🖨️' expr;\nsequentialOp: '📋' first=expr second=expr;\nbaseComputation: left=expr op=('➕' | '➖' | '✖️' | '➗' | '🟰' | '≤') right=expr;\n\n\nID: [a-zA-Z_][a-zA-Z0-9_]*;\nNUMBER: [0-9]+ ('.' [0-9]+)?;\nBOOLEAN: '👍' | '👎';\nSTRING: '\"' ~[\\r\\n\"]* '\"';\nREAD_FLOAT: '🔢';\nREAD_STRING: '🔤';\n\n\nWHITESPACE: [ \\t\\r\\n]+ -\u003e skip;\nCOMMENT: '😴' .*? '⏰' -\u003e skip;\nLINE_COMMENT: '🥱' ~[\\r\\n]* -\u003e skip;\n```\n\n\\*\\* 참고: 위 명세서는 ANTLR이라는 도구에서 사용되도록 작성되었으며, 곧 다시 이에 대해 다룰 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론 언어 자체가 우스꽝스러워 보이지만 몇 가지 이유로 흥미로운 점들이 있어요. 우선, 모든 표현은 괄호로 둘러싸야 하는 것이 필수적이에요. 이렇게 하니 코드 작성이 매우 귀찮지만, 문법이 모호하지 않다는 장점이 있어요. 둘째로, 익명 함수만 정의할 수 있다는 점을 주목해봐요 — 파이썬의 def와 같은 구문이 없어요. 마지막으로, 이 언어의 모든 함수 (기본 계산 외)는 정확히 하나의 인수를 가져야 해요. 조금 후에 이 두 가지 설계 결정의 영향을 살펴볼게요.\n\n# 파싱\n\n물론, 우리 스스로 파서를 작성할 수 있어요. 그러나 다행히도 임의의 문맥-자유 문법을 구문 분석할 수 있는 도구들이 있어요. 이 튜토리얼에서는 ANTLR을 사용할 거에요 (여기서 다운로드할 수 있어요). ANTLR은 위와 같은 문법 명세를 받아들여 이를 다양한 대상 언어의 파서로 생성해주는 매우 좋고 쉬운 도구에요 (이 튜토리얼에서는 Python을 사용할 거예요).\n\n사용법은 꽤 간단해요. 아래 단계를 따라해보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 여기에서 ANTLR Java 이진 파일을 다운로드하세요.\n- 문법에 맞는 .g4 파일(위와 같은)을 만드세요. ANTLR는 이모지를 잘 처리하지 못하기 때문에, 언어에 이모지를 사용할 계획이라면 다음 파이썬 스크립트를 실행하여 문법에서 이모지를 제거해주십시오:\n\n```js\nimport emoji\nimport sys\n\ndef demojify_file(input_file, output_file):\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        input_text = f.read()\n\n    input_text = emoji.demojize(input_text)\n\n    with open(output_file, \"w\", encoding=\"utf-8\") as f:\n        f.write(input_text)\n\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    output_file = sys.argv[2]\n    demojify_file(input_file, output_file)\n```\n\n3. java -Xmx500M -cp `path_to_antlr.jar` org.antlr.v4.Tool -Dlanguage=Python3 `your_grammar.g4` 명령을 실행하여 파서를 생성하세요.\n\n그런 다음 생성된 구문 분석 파일을 가져와 다음과 같이 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom antlr4 import *\nfrom EmojiLangLexer import EmojiLangLexer\nfrom EmojiLangParser import EmojiLangParser\nfrom EmojiLangListener import EmojiLangListener\nimport emoji\n\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        input_text = f.read()\n\n    input_text = emoji.demojize(input_text)\n    input_stream = InputStream(input_text)\n    lexer = EmojiLangLexer(input_stream)\n    token_stream = CommonTokenStream(lexer)\n    parser = EmojiLangParser(token_stream)\n    tree = parser.program()\n\n    if parser.getNumberOfSyntaxErrors() \u003e 0:\n        exit(1)\n```\n\n아마도 이 경우에는 데모지징 단계가 필요하지 않을 것입니다. 그런 경우에는 InputStream 대신 antlr4의 FileStream를 사용할 수 있지만, 실제로 큰 차이가 없습니다. 이제 우리는 쉽게 처리할 수 있는 매우 좋은 추상 구문 트리를 갖게 되었고, 이제 어려운 부분인 해석으로 넘어갈 차례입니다³\n\n# 해석기 구축\n\n트리를 다루고 있기 때문에 우리의 해석기는 자연스럽게 재귀적인 개념이 될 것입니다. 그러나 일부 기능을 정확히 어떻게 구현할지에 대한 선택지가 있습니다. 이 튜토리얼에서는 변수를 주소에 바인딩하는 환경을 사용한 뒤, 주소를 값에 매핑하는 가변 스토어를 사용하는 해석기를 구축할 것입니다. 이 아이디어는 꽤 흔한데, 모든 곳에서 사용되는 것은 아니지만 적절한 범위를 유지하고 변수 변이를 지원할 수 있게 합니다. 구현의 편의를 위해 우리의 해석기는 공통 값 구조체를 반환하도록 할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 값, 저장소 및 환경\n\n먼저, 우리의 인터프리터가 출력할 수 있는 것을 정의해 봅시다. 우리의 EBNF에는 세 가지 명백한 기본 사례가 있습니다(즉, 부울 값, 문자열 및 숫자), 따라서 해당 값을 가지고 있는 객체를 만들어 봅시다:\n\n```js\nclass Value:\n    def __init__(self, value):\n        self.value = value\n\n    def __str__(self) -\u003e str:\n        return str(self.value)\n\nclass NumValue(Value):\n    def __init__(self, value: float):\n        super().__init__(value)\n\nclass StringValue(Value):\n    def __init__(self, value: str):\n        super().__init__(value)\n\nclass BoolValue(Value):\n    def __init__(self, value: bool):\n        super().__init__(value)\n```\n\n변수를 값들로 매핑하기 위해, 우리는 환경과 저장소도 만들어 볼 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nclass EnvLookupException(Exception):\n    pass\n\nclass Environment:\n    def __init__(self):\n        self.vars = {}\n\n    def set_var(self, name, addr: int):\n        self.vars[name] = addr\n\n    def get_var(self, name):\n        if name not in self.vars:\n            raise EnvLookupException(f\"Variable {name} not found in environment\")\n        return self.vars[name]\n\n    def copy(self):\n        new_env = Environment()\n        new_env.vars = self.vars.copy()\n        return new_env\n\nclass Store:\n    def __init__(self):\n        self.store = []\n\n    def alloc(self, value: Value):\n        self.store.append(value)\n        return len(self.store) - 1\n\n    def get(self, addr: int):\n        if addr \u003e= len(self.store):\n            raise EnvLookupException(f\"Address {addr} not found in store\")\n        return self.store[addr]\n\n    def set(self, addr: int, value: Value):\n        if addr \u003e= len(self.store):\n            raise EnvLookupException(f\"Address {addr} not found in store\")\n        self.store[addr] = value\n```\n\n우리의 환경은 변수 → 주소 바인딩을 저장하고, store는 주소 → 값 바인딩을 유지합니다. 현재 기능 세트에서 store는 필요하지 않을 수 있지만, 참조에 의한 변수 변경을 허용한다면 유용할 것입니다.\n\n이상적으로, 함수를 변수로 전달할 수도 있기를 원하므로, 더 많은 값을 나타낼 수 있는 하나의 값이 필요합니다. 이를 위해 우리는 클로저를 생성합니다. 클로저에는 함수의 매개변수, 본문, 및 생성된 환경이 포함됩니다:\n\n```python\nclass ClosureValue(Value):\n    # Body should be an antlr4 tree\n    def __init__(self, param: str, body: object, env: 'Environment'):\n        super().__init__(None)\n        self.param = param\n        self.body = body\n        self.env = env\n\n    def __str__(self) -\u003e str:\n        return f\"\u003cfunction\u003e\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n너가 환경을 함수에 저장해야 하는 이유에 대해 물을 수도 있겠지만, 만약에 우리가 다음과 같은 함수 값을 가지고 있는 경우를 상상해보자:\n\n```js\nclass FunctionValue(Value):\n    # Body should be an antlr4 tree\n    def __init__(self, param: str, body: object):\n        super().__init__(None)\n        self.param = param\n        self.body = body\n\n    def __str__(self) -\u003e str:\n        return f\"\u003cfunction\u003e\"\n```\n\n이제, 우리 언어에서 다음과 같은 코드와 동등한 코드를 가졌다고 가정해보자:\n\n```js\n# ----------------\n# ENV MUST PERSIST\n# ----------------\ndef f(x):\n  def g(y):\n    return x + y\n  return g(x)\n\nprint((f(4))(5))  # 9\n\n# ----------------\n# ENV MUST CLEAR\n# ----------------\ndef f2(x):\n  return x + y\n\ndef g2(y):\n  return f(5)\n\nprint(f(4))  # Should crash\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 케이스에서 g에 대한 여전히 y 범위를 보장하려면 동적 스코핑을 구현해야 합니다 (프로그램이 실행되는 동안 변수가 지워지지 않고 환경에 추가되는 범위). 서퍼 코드가 실제로 실행되고 9를 인쇄할 수 있도록 클로저 없이 동적 스코핑을 적용해야 합니다. 그러나 하단 코드가 제대로 충돌하려면 동적 스코프를 구현할 수 없습니다. 따라서 함수가 생성된 환경을 효과적으로 기억하도록 하려면 환경을 클로저 클래스에 추가해야 합니다⁵.\n\n## 인터프리터\n\n이제 실제 인터프리터를 작성할 준비가 되었습니다. ANTLR에서 인터프리터는 EmojiLangListener 클래스를 확장할 것입니다. 또한 최상위 환경을 만들고 인터프리터에 저장소를 제공해야 합니다:\n\n```js\nclass EmojiLangException(Exception):\n    pass\n\nTOP_ENV = Environment()\n\nclass Interpreter(EmojiLangListener):\n    def __init__(self):\n        self.store = Store()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 모든 표현 사례를 처리하는 interp 메서드를 생성해야 합니다. 아래와 같이 보일 것입니다:\n\n```js\ndef interp(self, prog, env: Environment) -\u003e Value:\n    if prog.ID():\n        return self.interp_id(prog.ID())\n    elif prog.atom():\n        return self.interp_atom(prog.atom())\n    elif prog.anonFunctionDefn():\n        return self.interp_function_defn(prog.anonFunctionDefn())\n    elif prog.READ_FLOAT():\n        return self.interp_read_float()\n    elif prog.READ_STRING():\n        return self.interp_read_string()\n    elif prog.printExpr():\n        return self.interp_print_expr()\n    elif prog.ifCond():\n        return self.interp_if(prog.ifCond(), env)\n    elif prog.sequentialOp():\n        return self.interp_sequential_op(prog.sequentialOp(), env)\n    elif prog.baseComputation():\n        return self.interp_base_computation(prog.baseComputation(), env)\n    elif prog.varAssignment():\n        return self.interp_var_assignment(prog.varAssignment(), env)\n    elif prog.funApplication():\n        return self.interp_fun_application(prog.funApplication(), env)\n```\n\n우리의 기본 사례(ID, atom, 함수 정의, 읽기, 출력)는 꽤 단순하기 때문에, 우리는 이렇게 적을 수 있습니다:\n\n```js\ndef interp(self, prog, env: Environment) -\u003e Value:\n    if prog.ID():\n        return self.store.get(env.get_var(prog.ID().getText()))\n    elif prog.atom():\n        return self.interp_atom(prog.atom())\n    elif prog.anonFunctionDefn():\n        return ClosureValue(prog.anonFunctionDefn().arg.text, prog.anonFunctionDefn().body, env)\n    elif prog.READ_FLOAT():\n        try:\n            return NumValue(float(input(\"\u003e \")))\n        except ValueError:\n            raise EmojiLangException(\"Expected float input\")\n    elif prog.READ_STRING():\n        return StringValue(input(\"\u003e \"))\n    elif prog.printExpr():\n        value = self.interp(prog.printExpr().expr(), env)\n        if isinstance(value, StringValue):\n            # print without quotes\n            print(str(value)[1:-1])\n        else:\n            print(value)\n        return value\n    # ...\n\ndef interp_atom(self, atm):\n    if atm.NUMBER():\n        return NumValue(float(atm.NUMBER().getText()))\n    elif atm.BOOLEAN():\n        return BoolValue(atm.BOOLEAN().getText() == \":thumbs_up:\")\n    elif atm.STRING():\n        return StringValue(atm.STRING().getText())\n    # 이런 경우는 절대 발생해서는 안 됩니다.\n    raise EmojiLangException(f\"Unknown atom {atm.getText()}\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 if 조건은 꽤 간단합니다. 조건을 해석한 다음, 조건이 참이면 참인 경우를 해석한 결과를 반환하고 거짓인 경우는 거짓인 경우를 해석한 결과를 반환하면 됩니다. 코드는 다음과 같습니다.\n\n```js\ndef interp_if(self, if_cond, env: Environment):\n    cond = self.interp(if_cond.cond, env)\n    if not isinstance(cond, BoolValue):\n        raise EmojiLangException(f\"Expected boolean when evaluating if condition, got {cond}\")\n    return self.interp(if_cond.ontrue if cond.value else if_cond.onfalse, env)\n```\n\n연속적인 동작도 마찬가지로 간단합니다. 첫 번째 표현식을 해석한 다음 두 번째 표현식을 해석하면 됩니다. 따라서 해당 블록의 코드를 다음과 같이 바꿀 수 있습니다.\n\n```js\ndef interp(self, prog, env: Environment) -\u003e Value:\n  # ...\n  elif prog.sequentialOp():\n    self.interp(prog.sequentialOp().first, env)\n    return self.interp(prog.sequentialOp().second, env)\n  # ...\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 기본 계산이 있습니다. 많은 작업을 처리해야하기 때문에 코드 양이 상당한 편이지만, 복잡하지는 않아요:\n\n```js\ndef interp_base_computation(self, base_computation, env: Environment):\n    left, right = self.interp(base_computation.left, env), self.interp(base_computation.right, env)\n    if base_computation.op.text == \":plus:\":\n        if isinstance(left, NumValue) and isinstance(right, NumValue):\n            return NumValue(left.value + right.value)\n        elif isinstance(left, StringValue) and isinstance(right, StringValue):\n            return StringValue(left.value + right.value)\n        raise EmojiLangException(f\"{left}과 {right}을(를) 더할 수 없습니다\")\n    if base_computation.op.text == \":heavy_equals_sign:\":\n        if type(left) != type(right):\n            return BoolValue(False)\n        if isinstance(left, ClosureValue):\n            raise EmojiLangException(\"함수를 비교할 수 없습니다\")\n        return BoolValue(left.value == right.value)\n\n    # 숫자만 계산\n    if not isinstance(left, NumValue) or not isinstance(right, NumValue):\n        raise EmojiLangException(f\"기본 계산 평가 시 숫자가 예상됩니다. {left}과 {right}을(를) 받았습니다\")\n    if base_computation.op.text == \":minus:\":\n        return NumValue(left.value - right.value)\n    elif base_computation.op.text == \":multiply:\":\n        return NumValue(left.value * right.value)\n    elif base_computation.op.text == \":divide:\":\n        if right.value == 0:\n            raise EmojiLangException(\"0으로 나눌 수 없습니다\")\n        return NumValue(left.value / right.value)\n    elif base_computation.op.text == \"≤\":\n        return BoolValue(left.value \u003c= right.value)\n```\n\n아마도 사전(dictionary)을 사용하여 조금 정리할 수도 있지만, 그것은 크게 중요하지 않아요. 그 다음에는 변수 할당이 있습니다. 이것도 별로 복잡하지 않죠. 여기서 우리가 정확히 무엇을 원하는지에 대한 몇 가지 선택 사항이 있습니다. 구체적으로, 새 변수가 새롭게 생성되는 것을 허용할지 기존 변수만 수정할지 결정해야 합니다. 저는 후자를 선택하겠습니다. 그 결과 코드는 다음과 같습니다:\n\n```js\ndef interp_var_assignment(self, var_assign, env: Environment):\n    value = self.interp(var_assign.val, env)\n    addr = env.get_var(var_assign.var.text)\n    self.store.store[addr] = value\n    return value\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 함수 적용이 있습니다. 여기서는 네 가지 단계를 따라야 합니다. 먼저 호출하는 함수를 해석하여 클로저를 가져옵니다. 그런 다음 인수를 해석합니다. 그런 다음 인수를 클로저의 환경 복사본에 바인딩합니다. 마지막으로 새로운 환경에서 클로저의 본문을 해석합니다. 코드는 다음과 같이 보이게 됩니다:\n\n```js\ndef interp_fun_application(self, fun_app, env: Environment):\n    closure = self.interp(fun_app.fun, env)\n    if not isinstance(closure, ClosureValue):\n        raise EmojiLangException(f\"함수 적용을 평가할 때 함수가 예상되었습니다. 해당 함수: {closure}\")\n    arg = self.interp(fun_app.arg, env)\n    new_env = closure.env.copy()\n    new_env.set_var(closure.param, self.store.alloc(arg))\n    return self.interp(closure.body, new_env)\n```\n\n이제 우리의 해석기가 완벽히 동작합니다! 이제 우리가 실행할 프로그램에 대해 메인 프로그램을 수정하는 것만 남았습니다:\n\n```js\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        input_text = f.read()\n\n    # 입력에서 이모지를 데모지로 변환하기 위해 전처리\n    input_text = emoji.demojize(input_text)\n\n    input_stream = InputStream(input_text)\n    lexer = EmojiLangLexer(input_stream)\n    token_stream = CommonTokenStream(lexer)\n    parser = EmojiLangParser(token_stream)\n    tree = parser.program()\n\n    if parser.getNumberOfSyntaxErrors() \u003e 0:\n        exit(1)\n\n    interpreter = Interpreter()\n    interpreter.interp(tree.expr(), TOP_ENV)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 우리 언어로 놀아보기\n\n이제 우리 언어로 프로그램 작성을 시작할 준비가 끝났어요. 이모지 언어 (EML)로 작성한 간단한 'Hello World!' 프로그램을 확인해보세요:\n\n```js\n🏃‍♂️🏃‍♂️🏃‍♂️\n    (🖨️ (\"Hello World!\"))\n🛑🛑🛑\n```\n\n그리고 이를 실행하려면 단순히 이렇게 하시면 돼요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003e python emoji_lang.py helloworld.eml\n\u003e Hello World!\n\n(위 코드는 물론, 해당 프로그램이 helloworld.eml이라는 파일에 존재한다고 가정합니다.)\n\n## 커링\n\n첫 번째 섹션에서 언급했듯이, 우리의 프로그래밍 언어는 함수가 하나의 인수만을 가져야 한다는 점에서 흥미로운 특징을 가지고 있습니다. 그렇다면 다변수 함수와 유사한 효과를 어떻게 만들 수 있을까요? 예를 들어, 다음의 파이썬 코드를 살펴보십시오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndef f(x, y):\n  return x + y\n\nprint(f(3, 4))\n```\n\n여기서 f 는 arity 2 — 즉, 두 개의 argument 를 가집니다. 그러나, addition 을 제외한 함수의 arity 가 1 인 함수들만 사용하는 동등한 코드를 아래와 같이 작성할 수 있습니다:\n\n```python\ndef f(x):\n  def g(y):\n    return x + y\n  return g\n\nprint((f(3))(4))\n```\n\n위와 같은 고차 arity 함수를 일변량 함수로 변환하는 개념을 currying 이라고 합니다. 이는 어떤 arity 의 함수에 대해서도 동작하며, arity 가 n 인 함수 f 에 대해 n-1 번의 currying 만을 수행하면 됩니다. 이를 이모지 언어에서 표현하면 다음과 같이 프로그램을 작성할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🏃‍♂️🏃‍♂️🏃‍♂️\n(📋\n(🖨️ (\"두 숫자를 입력하여 합계를 계산합니다.\"))\n(🖨️\n(🏭\n(🏭\n(🧑‍🏭 x ⚒️\n(🧑‍🏭 y ⚒️\n((x) ➕ (y))\n)\n)\n(🔢))\n(🔢))\n)\n)\n🛑🛑🛑\n\n이것의 Python 번역은:\n\nprint(\"두 숫자를 입력하여 합계를 계산합니다.\")\nprint(((lambda x: (lambda y: x + y)))(float(input()))(float(input())))\n\n또는 더 읽기 쉽게,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprint(\"두 숫자를 입력하여 합산합니다.\")\n\ndef f(x):\n  def g(y):\n    return x + y\n  return g\n\nx = float(input())\ny = float(input())\n\nprint(f(x)(y))\n```\n\n또한 처음의 Python 반복이 이름이 지정된 함수를 사용하지 않았다는 것에 유의하십시오. 하지만 우리가 실제로 필요하지는 않지만, 물론 가독성을 위해 유용합니다. 그런 다음,\n\n```js\n\u003e python emoji_lang.py currying.eml\n두 숫자를 입력하여 합산하시오\n\u003e 4\n\u003e 5\n9.0\n```\n\n## 재귀\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 똑똑한 작은 요령을 쓸 수 있어요. 함수들이 값이기 때문에, 함수를 호출할 때 자기 자신에 대한 함수를 전달할 수 있어요. 그렇게 하면 재귀 호출이 가능해져요.\n\n예를 들어 다음 파이썬 코드를 봐봅시다:\n\n```js\nn = int(input())\nwhile n \u003e 0:\n  print(n)\n  n -= 1\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 이를 재귀 버전으로 변환할 수 있습니다. 다음과 같은 방법을 사용할 수 있어요:\n\n```js\ndef while_loop(condition, body):\n  \"\"\"\n  while 루프의 재귀적 구현.\n\n  Arguments\n  -------------\n  - condition: 부울값을 반환하는 매개변수가 없는 함수\n  - body: condition이 true를 반환하는 동안 실행할 매개변수가 없는 함수\n  \"\"\"\n  if condition():\n    body()\n    while_loop(condition, body)\n  else:\n    return False\n\nclass Box:\n    def __init__(self, n):\n        self.n = n\n\n    def set_n(self, n):\n        self.n = n\n\n    def get_n(self):\n        return self.n\n\nn = Box(int(input()))\n\ndef body():\n    print(n.get_n())\n    n.set_n(n.get_n() - 1)\n\nwhile_loop(lambda: n.get_n() \u003e 0, body)\n```\n\n하지만 여기서 문제가 있습니다. while_loop 함수가 자기 자신을 호출하는 것을 주목해주세요. 익명 함수만으로는 언어에서 그렇게는 할 수 없기 때문에 어떻게 해결할까요? 답은 다음과 같이 할 수 있습니다:\n\n```js\ndef while_loop(self, condition, body):\n  if condition():\n    body()\n    self(self, condition, body)\n  else:\n    return False\n\n# ...\n# (상자로 n을 정의)\n# ...\n\ndef body():\n    print(n.get_n())\n    n.set_n(n.get_n() - 1)\n\ndef call_while(loop_func, condition, body):\n    loop_func(loop_func, condition, body)\n\ncall_while(while_loop, lambda: n.get_n() \u003e 0, body)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제로, while_loop 함수가 자신을 매개변수로 취하도록 만듭니다. 그럼에도 불구하고 while_loop 함수 내에서 자신을 호출할 수 있게 되어 while_loop 함수가 재귀적으로 자신을 호출할 수 있게 됩니다.\n\n물론, 우리의 언어에 lambda화하고 커링해야 하므로, 다음과 동등한 코드를 만들어야 합니다:\n\n```js\n(((lambda while_loop:\n    lambda n:\n        while_loop(while_loop)\n                  (lambda bogus: n.get_n() \u003e 0)\n                  (lambda bogus: print(n.get_n()) or n.set_n(n.get_n() - 1)))\n(lambda self:\n    lambda cond:\n        lambda body:\n            (body(\"BOGUS\") or self(self)(cond)(body)) if cond(\"BOGUS\") else False))\n(Box(int(input()))))\n```\n\n이것은 약간 복잡할 수 있지만 작동합니다. 이를 이모지 언어로 표현하면\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n🏃‍♂️🏃‍♂️🏃‍♂️\n    (🏭\n        (🏭\n            (🧑‍🏭 while ⚒️\n                (🧑‍🏭 n ⚒️\n                    (🏭 (🏭 (🏭 (while) (while))\n                        (🧑‍🏭 bogus ⚒️ (🤔 ((n) ≤ (0)) ❓ (👎) : (👍))))\n                        (🧑‍🏭 bogus ⚒️ (📋\n                            (🖨️ (n))\n                            (📦 n 🔜 ((n) ➖ (1)))\n                        )))\n                ))\n            😴\n                아래는 while 함수입니다. 재귀 호출을 위해 자신을 인자로 받습니다\n                (이 외에도 이를 수행하는 다른 방법이 있지만, 재귀 호출을 통한 자기 전달은 상당히 간단합니다)\n\n                ARGS:\n                1. self(자기 자신)\n                2. condition_func (참 또는 거짓을 반환하는 0인자 함수)\n                3. body (참일 때 실행할 아무것도 반환하지 않는 0인자 함수)\n\n                RETURNS:\n                끝날 때 거짓 반환\n            ⏰\n            (🧑‍🏭 self ⚒️\n                (🧑‍🏭 condition_func ⚒️\n                    (🧑‍🏭 body ⚒️\n                        (\n                            🤔 (🏭 (condition_func) (\"BOGUS\")) ❓\n                                (📋\n                                    (🏭 (body) (\"BOGUS\"))\n                                    (🏭 (🏭 (🏭 (self) (self))\n                                            (condition_func))\n                                            (body))) :\n                                (👎)\n                        ))))\n        )\n    (🔢))\n🛑🛑🛑\n```\n\n그런 다음\n\n```js\n\u003e python emoji_lang.py while_loop.eml\n\u003e 4\n4.0\n3.0\n2.0\n1.0\n```\n\n## 추가 보너스: Y 컴비네이터\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 호출할 때마다 while에 자체를 전달하는 것은 다소 귀찮은 작업일 수 있습니다. 그래서 이미 커리된 상태로 자체가 있는 while 함수를 만들 수 있다면 어떨까요? 이를 달성할 수 있는 것이 Y Combinator입니다. Y 컴비네이터는 다음과 같이 보입니다:\n\n```js\nY = lambda g: (lambda f: g(lambda arg: f(f)(arg))) (lambda f: g(lambda arg: f(f)(arg)))\n```\n\n이것은 완전히 터무니없는 것이지만, 함수를 효과적으로 \"저장\"할 수 있게 해줍니다. 이에 대해 자세히 설명은 생략하겠지만, 더 알고 싶다면 이 훌륭한 기사를 참고하는 것이 좋습니다.\n\n이 컴비네이터를 사용하면 우리의 코드를 다음과 같이 변경할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🏃‍♂️🏃‍♂️🏃‍♂️\n(🏭\n(🏭\n(🏭\n(🧑‍🏭 y_combinator ⚒️\n(🧑‍🏭 while ⚒️\n(🧑‍🏭 n ⚒️\n(📋\n🥱 y-combinate our while\n(📦 while 🔜 (🏭 (y_combinator) (while)))\n(🏭 (🏭 (while)\n(🧑‍🏭 bogus ⚒️ (🤔 ((n) ≤ (0)) ❓ (👎) : (👍))))\n(🧑‍🏭 bogus ⚒️ (📋\n(🖨️ (n))\n(📦 n 🔜 ((n) ➖ (1)))\n))\n)\n)\n)\n)\n)\n😴\nOur y combinator function - this allows for recursion without e.g. self passing\nby effectively currying the function and passing it to itself.\n⏰\n(🧑‍🏭 fn_nr ⚒️\n(🏭\n(🧑‍🏭 cc ⚒️\n(🏭 (fn_nr)\n(🧑‍🏭 x ⚒️ (🏭 (🏭 (cc) (cc)) (x)))\n)\n)\n(🧑‍🏭 cc ⚒️\n(🏭 (fn_nr)\n(🧑‍🏭 x ⚒️ (🏭 (🏭 (cc) (cc)) (x)))\n)\n)\n)\n)\n)\n(🧑‍🏭 while ⚒️\n(🧑‍🏭 condition_func ⚒️\n(🧑‍🏭 body ⚒️\n(\n🤔 (🏭 (condition_func) (\"BOGUS\")) ❓\n(📋\n(🏭 (body) (\"BOGUS\"))\n(🏭 (🏭 (while)\n(condition_func))\n(body))) :\n(👎)\n))))\n)  \n (🔢))  \n🛑🛑🛑\n\n이제, y-컴비네이트 된 후 while에 대한 호출이 그 자신을 전달할 필요가 없이 조건과 본문을 전달하는 것만 포함되어 있다는 점에 주목하세요. 그리고 여전히 다음 결과를 얻을 수 있습니다.\n\n```js\n\u003e python emoji_lang.py y_comb_while.eml\n\u003e 4\n4.0\n3.0\n2.0\n1.0\n```\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n축하드려요! 이제 아마도 여러분만의 프로그래밍 언어를 만들었고 그 안에서 재미있는 일들을 코딩했을 거예요. EmojiLang 같은 것은 실제로 많은 유용성이 없지만, 여러분만의 언어를 만들어 다양한 용도로 활용해볼 수 있다는 것을 상상할 수 있어요. 예를 들어 자주 하는 작업을 빠르게 수행할 수 있는 초 특정한 스크립팅 언어를 만들어보는 것 등이 있겠죠.\n\n도전을 좋아하신다면, 아래 연습 문제들을 시도해보세요:\n\n**연습 1:** ANTLR를 사용하지 않고 아래 언어에 대한 간단한 파서와 인터프리터를 만드세요. 괄호가 우선순위를 갖고, 그 외 연산은 동등한 우선순위를 갖도록 해보세요. (예: 4 + 4 \\* 3은 24로 계산되어야 하며, 16이 아니어야 합니다)\n\n```js\nEXPR =\n  숫자 | (EXPR + EXPR) | (EXPR - EXPR) | (EXPR * EXPR) | (EXPR / EXPR) | EXPR;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nExercise 2: 위의 코드를 수정하여 연산자 우선순위를 추가해보세요.\n\nExercise 3 (Tricky): 모든 함수를 익명으로 만들 필요는 없습니다. 다음 언어를 위한 인터프리터를 구현해보세요 (ANTLR을 사용해도 되지만, 직접 .g4 파일을 작성해야 합니다):\n\n```js\nprogram = (FUNDEF | EXPR)* // 하나 이상의 함수 정의 또는 표현식\n\n// 참고: \u003csomething\u003e은 해당 것이 문자열임을 의미합니다\n// 또한, 공백을 무시하거나 세미콜론을 추가하거나 괄호를 추가하여\n// 표현식 또는 함수 정의를 원하는 대로 작성하세요\n\nEXPR = 숫자\n     | 함수적용\n     | 계산\n\nFUNDEF = 'def' \u003cname\u003e '(' \u003cargs\u003e* '):' EXPR\n\n함수적용 = \u003cname\u003e '(' EXPR* ')' // 예: f(1, 2+2, g(3))\n계산 = EXPR + EXPR\n       | EXPR - EXPR\n       | EXPR * EXPR\n       | EXPR / EXPR\n       | (EXPR)\n```\n\nExercise 4 (Easy → Very Very Hard): 다양한 실제 언어에 대한 .g4 파일은 여기서 찾을 수 있습니다. 그 중 하나에 대한 인터프리터를 구현해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 문의 사항이 있으시면 mchak@calpoly.edu 로 연락해주세요.\n\n부. CS 430 교수님 브라이언 존스에게 많은 것을 가르쳐 주셔서 감사합니다.\n\n모든 이미지는 작성자 소유이나 그렇지 않은 경우를 제외하고 있습니다.\n\n- 컴파일된 언어들은 약간 다릅니다. 생성된 추상 구문 트리는 대신 컴파일러로 전달되어 다른 기존 언어(대부분 어셈블리)로 코드로 변환됩니다. 그런 다음 결과 코드를 실행할 수 있습니다.\n- 기술적으로 이것은 실제 EBNF에 있는 것은 아니지만, 충분히 가깝습니다. 궁금하시다면 EBNF에 대해 더 읽어보세요.\n- 참고: 일부 언어들은 해석기로 전달하기 전에 AST에 최적화를 수행할 수 있습니다. 여기서는 그렇게 하지는 않겠습니다.\n- 여전히 환경에서 상자 값을 사용하여 변이를 허용할 수는 있지만, 스토어는 대부분의 언어가 하는 것과 더 유사하며, 적어도 나에게는 더 직관적입니다.\n- 자세한 정보는 7 Functions Anywhere (brown.edu) 참조하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6. 여기서 상자를 사용해야 하는 이유는 Python 환경이 우리와 같은 방식으로 작동하지 않기 때문입니다. 예를 들어, 다음을 실행할 수 없습니다:\n\n```js\n# ...\ndef get_body_and_cond(inp):\n    n = inp\n    condition = lambda: n \u003e 0\n\n    def body():\n        print(n)\n        n -= 1\n    return condition, body\n\nc, b = get_body_and_cond(float(input()))\n\nwhile_loop(c, b)\n```\n\n7. 실제로 우리의 언어는 즉시 무엇을 평가하기 때문에 Z-콤비네이션이 되었습니다만, 효과는 같습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_0.png"},"coverImage":"/assets/img/2024-06-22-AStep-By-StepGuidetoBuildingaProgrammingLanguage_0.png","tag":["Tech"],"readingTime":32}],"page":"29","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"29"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>