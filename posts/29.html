<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/29" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/29" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_buildManifest.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Swift에서의 관점 지향 프로그래밍" href="/post/2024-05-20-Aspect-OrientedProgramminginSwift"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서의 관점 지향 프로그래밍" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서의 관점 지향 프로그래밍" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift에서의 관점 지향 프로그래밍</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift에서 SOLID 원칙에 대한 예제" href="/post/2024-05-20-SOLIDprinciplesinSwiftwithexamples"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서 SOLID 원칙에 대한 예제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-SOLIDprinciplesinSwiftwithexamples_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서 SOLID 원칙에 대한 예제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift에서 SOLID 원칙에 대한 예제</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 iOS 18 기능으로 iPhone 사용 방법이 혁신됩니다" href="/post/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 iOS 18 기능으로 iPhone 사용 방법이 혁신됩니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 iOS 18 기능으로 iPhone 사용 방법이 혁신됩니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">새로운 iOS 18 기능으로 iPhone 사용 방법이 혁신됩니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="월마트 소프트웨어 엔지니어 III - IOS IN3 면접 경험" href="/post/2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="월마트 소프트웨어 엔지니어 III - IOS IN3 면접 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="월마트 소프트웨어 엔지니어 III - IOS IN3 면접 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">월마트 소프트웨어 엔지니어 III - IOS IN3 면접 경험</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드 리뷰에서 논의하는 것 그만 하고 린트 규칙으로 강제해 보세요" href="/post/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드 리뷰에서 논의하는 것 그만 하고 린트 규칙으로 강제해 보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드 리뷰에서 논의하는 것 그만 하고 린트 규칙으로 강제해 보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코드 리뷰에서 논의하는 것 그만 하고 린트 규칙으로 강제해 보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코틀린의 Any, Unit, Nothing 이해하기" href="/post/2024-05-20-UnderstandingKotlinsAnyUnitNothing"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코틀린의 Any, Unit, Nothing 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코틀린의 Any, Unit, Nothing 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코틀린의 Any, Unit, Nothing 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="친구야, Kotlin 20 - Android 프로젝트 이전 안내" href="/post/2024-05-20-Kotlin20Androidprojectmigrationguide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="친구야, Kotlin 20 - Android 프로젝트 이전 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="친구야, Kotlin 20 - Android 프로젝트 이전 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">친구야, Kotlin 20 - Android 프로젝트 이전 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신의 안드로이드 앱에 다국어 지원다국어 추가하기" href="/post/2024-05-20-AddMultilingualsupportMultipleLanguagestoyourAndroidApp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신의 안드로이드 앱에 다국어 지원다국어 추가하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-AddMultilingualsupportMultipleLanguagestoyourAndroidApp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신의 안드로이드 앱에 다국어 지원다국어 추가하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">당신의 안드로이드 앱에 다국어 지원다국어 추가하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="디자인 시스템 워크플로우를 Kelp 플러그인으로 Android Studio에서 강화해보세요 " href="/post/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="디자인 시스템 워크플로우를 Kelp 플러그인으로 Android Studio에서 강화해보세요 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="디자인 시스템 워크플로우를 Kelp 플러그인으로 Android Studio에서 강화해보세요 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">디자인 시스템 워크플로우를 Kelp 플러그인으로 Android Studio에서 강화해보세요 </strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="매뉴얼에서 선언적 방식으로 빠르게 성장하는 회사에서의 Terraform과 IaC" href="/post/2024-05-20-FrommanualtodeclarativeTerraformandIaCinafastgrowingcompany"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="매뉴얼에서 선언적 방식으로 빠르게 성장하는 회사에서의 Terraform과 IaC" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-FrommanualtodeclarativeTerraformandIaCinafastgrowingcompany_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="매뉴얼에서 선언적 방식으로 빠르게 성장하는 회사에서의 Terraform과 IaC" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">매뉴얼에서 선언적 방식으로 빠르게 성장하는 회사에서의 Terraform과 IaC</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link posts_-active__YVJEi" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Swift에서의 관점 지향 프로그래밍","description":"","date":"2024-05-20 17:49","slug":"2024-05-20-Aspect-OrientedProgramminginSwift","content":"\n\n\u003cimg src=\"/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png\" /\u003e\n\n# 소개\n\nAspect-oriented programming (AOP로 앞으로 표기함)은 코드 베이스에 교차하는 관심사를 확장 가능한 방식으로 추가하는 것에 관한 것입니다.\n\n\"Aspect Oriented Programming\"이라는 용어를 처음 만났던 그 때를 아직 기억합니다. 많은 시간이 흘렀고, Swift가 아직 존재하지 않았으며, 우리는 기쁘게 Objective-C 코드를 작성하고 있었습니다. ARAnalytics는 AOP 패러다임을 채택하여 코드 베이스 전반에 걸쳐 분석을 추가하는 것을 간단하게 한 최초의 라이브러리 중 하나였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드를 더 자세히 살펴보면 Objective-C에서 AOP를 구현하는 것이 Peter Steinberger가 그의 Aspects 라이브러리에서 언급한 것처럼 메소드 스위즐링을 구현하는 것이라는 것을 알 수 있어요.\n\nObjective-C와는 달리 Swift는 메시지를 가로채고 실행 중에 동작을 변경할 기능이 많지 않은 엄격하고 정적으로 타입이 지정된 언어에요. 실제로는, 이것은 우리의 코드에 교차 관심을 적용하는 영향을 최소화하기 위해 좋은 디자인의 기초를 설정해야 한다는 의미에요. 우리는 두 가지 주요 구성요소가 필요할 거에요:\n\n- 지연 바인딩을 적용하고 필요에 따라 기반이 되는 구현을 변경할 수 있도록 하는 종속성 주입 기능이 필요해요.\n- 런타임에서 우리가 원하는 동작을 변경할 수 있도록 해주는 가로채기 디자인 패턴인 데코레이터 패턴이 필요해요.\n\n시작해봐요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Swift에서의 AOP: 좋은 디자인을 향해서\n\n우리 애플리케이션을 모델링하는 매우 일반적인 접근 방식은 특정 도메인 모델 주변의 모든 기능을 번들로 묶는 단일 “store/repository/service/aggregate”를 가지는 것입니다. 만약 애플리케이션이 할 일을 관리하는 것이라면, 어떤 형식의 “TodoService”가 있을 것입니다. 만약 TV 프로그램을 관리하는 앱이라면, “ShowService”가 있을 것입니다. 아이디어를 얻으셨죠. 이러한 접근 방식은 많은 중간 규모의 앱에 대해 완벽하게 유효한 것이지만, 다른, 더 복잡한 애플리케이션에는 문제가 될 수 있습니다. 소프트웨어의 대부분은 마찬가지로 모든 것이 의존합니다.\n\n다음과 같이 보이는 ShowService를 상상해보십시오:\n\n```js\nprotocol ShowService {\n    func allShows() async -\u003e [Show]\n    func allEpisodes(for show: Show) async -\u003e [Episode]\n    func markEpisodeAsWatched(episode: Episode) async\n    func markShowAsWatched(_ show: Show, until episode: Episode?) async\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 말했던 대로 소프트웨어의 대부분은 주관적이며 특정 맥락에 따라 토론의 여지가 있음에도 불구하고, 우리를 안내하는 \"원칙\"들이 있으면 좋습니다. 그 원칙들은 보통 SOLID 원칙들입니다.\n\n## ISP 위반\n\n대부분의 대규모 인터페이스와 마찬가지로, ShowService가 인터페이스 분리 원칙을 위반할 가능성이 매우 높습니다. 이는 클라이언트가 필요하지 않은 메서드를 구현하도록 강제함으로써 나타납니다. 특히 목업을 구현할 때 XCTFail과 같은 메서드들을 사용하여 이를 확인하는 것이 매우 흔합니다.\n\n```js\nstruct ShowServiceMock: ShowService {\n    var shows: [Show]\n\n    func allShows() -\u003e [Show] {\n        shows\n    }\n    \n    func allEpisodes(for show: Show) -\u003e [Episode] {\n        XCTFail(\"호출되지 않아야 함\")\n        return []\n    }\n\n    func markEpisodeAsWatched(episode: Episode) {\n        XCTFail(\"호출되지 않아야 함\")\n    }\n\n    func markShowAsWatched(_ show: Show, until episode: Episode?) {\n        XCTFail(\"호출되지 않아야 함\")\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## SRP 위반\n\nISP를 위반할 때, SRP를 위반하는 일도 상당히 흔합니다. SRP는 응집성과 한 가지 이유로만 변경해야 한다는 것과 관련이 있습니다. ShowService 인터페이스에 있는 메서드 수가 늘어날수록, 그 응집성과 SRP를 유지하기가 더욱 어려워질 것입니다.\n\n## OCP 위반\n\nTV 프로그램과 관련된 새로운 기능을 추가하려면 ShowService에 새로운 메서드를 추가해야 하며, 서비스의 모든 구현이 그 변경 사항을 수용하고 컴파일 오류를 수정해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 큰 인터페이스는 병목 현상을 유발하기 쉽습니다\n\n하루의 끝에 이렇게 큰 인터페이스를 갖고 있다면, 해당 도메인 모델과 관련된 새로운 동작을 추가할 때 병목 현상이 발생할 것입니다. 어떠한 새로운 변경이라도 앱 전체에서 컴파일 오류 및 다시 컴파일을 유발합니다. 좋은 소프트웨어 디자인의 한 가지 주의사항은 자주 변경되지 않는 모듈에 의존하는 것입니다. 우리의 의존성 그래프에서 잎 모듈은 가장 안정된 것이어야 합니다. 왜냐하면 그들이 변경될 때마다 전체 그래프가 다시 컴파일되도록 강제할 것입니다. ShowService를 더 자세히 살펴보면, 매우 빈번하게 변경되는 매우 불안정한 모듈에 전체 앱이 의존한다는 점을 알 수 있습니다. 그런 해롭은 일종의 재앙이네요 😅. 참고로, 이러한 병목 현상은 백엔드 및 마이크로서비스 아키텍처에서도 매우 흔히 발생하며, \"엔티티 서비스 안티패턴(The Entity Service Antipattern)\"이라고 불립니다.\n\n## 첫 번째 접근 방식: CQRS\n\n첫 번째 접근 방식은 큰 인터페이스를 읽기와 쓰기를 위한 두 가지 구분된 인터페이스로 분리하는 것입니다. 이를 Command Query Responsibility Segregation(CQRS)이라고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n// 읽기\nprotocol ShowQueryService {\n    func allShows() async -\u003e [Show]\n    func allEpisodes(for show: Show) async -\u003e [Episode]\n}\n\n// 쓰기\nprotocol ShowCommandService {\n    func markEpisodeAsWatched(episode: Episode) async\n    func markShowAsWatched(_ show: Show, until episode: Episode?) async\n}\n```\n\n보통 이렇게 분리하는 것이 읽기와 쓰기에 필요한 기능이 매우 다르기 때문에 합리적입니다. 예를 들어 상태를 변경할 때(쓰기)만 적용되는 보안 정책이 있을 수 있습니다.\n\n하지만 상상할 수 있듯이, 이것은 큰 개선이 아닙니다. 변경의 영향을 더 잘 제한했지만 여전히 자주 변경될 두 가지 \"큰 인터페이스\"가 존재합니다. 더 좋은 방법이 있을 수 있습니다.\n\n## 두 번째 접근 방법: 작은 서비스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 깨끗한 아키텍처와 유즈 케이스로 작업하는 데 익숙하다면, 이것들이 정확히 그것입니다.\n\n일부 장단점이 있습니다. 각 메서드 당 프로토콜을 갖는 것은 인터페이스의 폭발을 일으킬 수 있습니다. 그러나 이것은 이전에 이야기한 일부 SOLID 원칙을 준수하는 주요 이점도 가지고 있습니다. 이제 ISP(인터페이스 분리 원칙)를 준수하고 있고 아마도 SRP(단일 책임 원칙)을 준수하고 있을 것입니다. 또한 새로운 기능을 추가할 때는 새로운 튜플(인터페이스, 구현)을 만들기만 하면 되므로 코드를 많이 수정하거나 재컴파일하는 영향을 최소화할 수 있습니다. 그러니 전체가 나쁜 것만은 아닙니다. 기억하세요, 모든 것은 의존합니다. 소프트웨어는 모든 것이 트레이드오프에 관한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 \"Aspects\"에 대해 생각해보면, 필요한 각 측면마다 프로토콜 당 하나의 구현을 해야 합니다. 예를 들어 \"로그 기록 Aspect\"를 구현하려면 AllShowsLoggingService와 MarkShowAsWatchedLoggingService 등이 필요합니다. 그래서 우리 앱에서 관심사를 구현하는 데 적합한 방법이 아닌 것 같습니다.\n\n세 번째, 마지막 방법으로 가봅시다.\n\n## 세 번째 방법: 통합된 서비스 인터페이스\n\nAOP를 확장 가능한 방식으로 구현하려면 \"aspects\"를 적용할 모든 서비스에 대해 단일 인터페이스/시마가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n프로토콜 Service\u003cInput, Output\u003e {\n    associatedtype Input\n    associatedtype Output\n\n    func callAsFunction(input: Input) async throws -\u003e Output\n}\n```\n\n편의성을 위해 다음도 추가해 봅시다.\n\n```js\nextension Service where Input == Void{\n    func callAsFunction() async throws -\u003e Output {\n        try await callAsFunction(input: ())\n    }\n}\n```\n\n단일 인터페이스를 가지고 있어, 다음과 같은 것을 할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nclass AllShowsService: Service {\n    suspend operator fun invoke(input: Void): List\u003cShow\u003e {\n        // Implementation...\n    }\n}\n\nclass MarkShowAsWatchedService: Service {\n    suspend operator fun invoke(input: Pair\u003cShow, Episode?\u003e) {\n        // Implementation...\n    }\n}\n\ntypealias AllShowsServiceType = Service\u003cVoid, List\u003cShow\u003e\u003e\ntypealias MarkShowAsWatchedServiceType = Service\u003cPair\u003cShow, Episode?\u003e, Void\u003e\n\nclass ViewModel\u003cAllShowsService: AllShowsServiceType, MarkShowAsWatchedService: MarkShowAsWatchedServiceType\u003e {\n    private val allShowsService: AllShowsService\n    private val markShowAsWatchedService: MarkShowAsWatchedService\n\n    init(allShowsService: AllShowsService, markShowAsWatchedService: MarkShowAsWatchedService) {\n        this.allShowsService = allShowsService\n        this.markShowAsWatchedService = markShowAsWatchedService\n    }\n\n    suspend fun markAllShowsAsWatchedButtonTapped() {\n        try {\n            val allShows = allShowsService(Void)\n            coroutineScope {\n                allShows.map { show -\u003e\n                    launch {\n                        markShowAsWatchedService(Pair(show, null))\n                    }\n                }\n            }\n        } catch (e: Exception) {\n            println(\"Some error happened $error\")\n        }\n    }\n}\n```\n\n지금은 ViewModel을 생성할 때 두 개의 입력값을 주입하면 됩니다:\n\n- Service`Void, [Show]`\n- Service`(show: Show, episode: Episode?), Void`\n\nService가 단일 인터페이스이기 때문에 앱 전체의 모든 서비스에 적용할 수 있는 각 측면마다 인터페이스의 구현만 있으면 됩니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 몇 가지를 구현해 보겠습니다! 확인하시겠지만, 모든 측면은 데코레이터 패턴을 따라 매우 유사합니다.\n\n## 로깅 측면\n\n서비스에 몇 가지 로깅 기능을 추가하는 것은 매우 일반적이고 유용한 측면입니다. 다음과 같이 간단히 구현할 수 있습니다:\n\n```js\nclass LoggingService\u003cDecoratee: Service\u003e: Service {\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n    \n    init(decoratee: Decoratee) {\n        self.decoratee = decoratee\n    }\n\n    func callAsFunction(input: Input) async throws -\u003e Output {\n        let output = try await decoratee(input: input)\n        dump(output)\n        return output\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프리미엄 사용자 측면\n\n애플리케이션에서 매우 유용한 교차 기능 중 하나는 사용자가 프리미엄 사용자인 경우에만 일부 작업을 수행할 수 있도록 허용하는 것일 수 있습니다. 사용자가 프리미엄 사용자인지 여부를 확인하는 방법을 추상화하기 위해 간단한 `async` 함수를 주입하여 PremiumService 데코레이터를 다음과 같이 만들 수 있습니다:\n\n```js\nclass PremiumService\u003cDecoratee: Service\u003e: Service {\n    struct Error: Swift.Error {}\n\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n    let isPremiumUser: () async -\u003e Bool\n\n    init(decoratee: Decoratee, isPremiumUser: @escaping () async -\u003e Bool) {\n        self.decoratee = decoratee\n        self.isPremiumUser = isPremiumUser\n    }\n\n    func callAsFunction(input: Input) async throws -\u003e Output {\n        guard await isPremiumUser() else {\n            throw Error()\n        }\n        return try await decoratee(input: input)\n    }\n}\n```\n\n## 캐싱 측면\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또 다른 일반적인 측면은 캐싱 또는 메모이제이션입니다. 단순히 서비스 입력을 해시 가능한 것으로 제한하고 출력을 Codable로 정의함으로써 모든 서비스에 대해 구현할 수 있습니다.\n\n```js\nprivate(set) var cache: [AnyHashable: Data] = [:]\n\nclass CachingService\u003cDecoratee: Service\u003e: Service where Decoratee.Output: Codable, Decoratee.Input: Hashable {\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n\n    init(decoratee: Decoratee) {\n        self.decoratee = decoratee\n    }\n\n    func callAsFunction(input: Input) async throws -\u003e Output {\n        if let cachedData = cache[input] {\n            return try JSONDecoder().decode(Output.self, from: cachedData)\n        }\n\n        let output = try await decoratee(input: input)\n        cache[input] = try JSONEncoder().encode(output)\n        return output\n    }\n}\n```\n\n## 지연 측면\n\n네트워크 링크 조절기(Network Link Conditioner)는 다양한 유형의 네트워크 상황을 시뮬레이션하고 인터넷 연결을 매우 나쁘게 만드는 매우 유용한 도구입니다. 우리는 여기에 측면(Aspect)을 활용하여 정확히 그것을 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass DelayService\u003cDecoratee: Service\u003e: Service {\n    typealias Input = Decoratee.Input\n    typealias Output = Decoratee.Output\n\n    let decoratee: Decoratee\n    let duration: UInt64\n\n    init(decoratee: Decoratee, nanoseconds duration: UInt64) {\n        self.decoratee = decoratee\n        self.duration = duration\n    }\n\n    func callAsFunction(input: Input) async throws -\u003e Output {\n        try await Task.sleep(nanoseconds: duration)\n        return try await decoratee(input: input)\n    }\n}\n```\n\n또는 예를 들어 항상 오류를 강제할 수 있는 다른 측면을 추가할 수도 있습니다.\n\n## 측면은 조립 가능합니다.\n\n모든 측면을 준비한 후에는 간단히 뷰 모델을 수정하여 필요한 서비스 유형을 주입하고 여러 측면으로 꾸밀 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet viewModel = ViewModel( allShowsService: DelayService(decoratee: LoggingService(decoratee: AllShowsService()), nanoseconds: 5 * NSEC_PER_SEC), markShowAsWatchedService: LoggingService(decoratee: MarkShowAsWatchedService()) )\n```\n\n이렇게 보시다시피 서로 다른 측면을 연쇄시켰습니다. 조립 가능한 요소들이죠.\n\n하지만 중요한 점은 데코레이터 추가는 어플리케이션의 메인 모듈에서 할 수 있다는 것입니다. 여기서 전체 오브젝트 그래프를 구성할 것으로 가정하고, 일종의 구성 루트 패턴을 통해 서비스의 동작을 변경할 수 있습니다. 이렇게 함으로써, 모듈 중 어느 것도 건드리거나 다시 컴파일할 필요 없이 서비스의 행동을 변경할 수 있게 됩니다.\n\n## 편의성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데코레이터를 연결하는 것은 조금 귀찮을 수 있지만, 확장 기능을 활용하여 작업성을 개선하고 더 관용적으로 조합할 수 있습니다.\n\n```js\nextension Service {\n    var withLogging: LoggingService\u003cSelf\u003e {\n        LoggingService(decoratee: self)\n    }\n\n    func withDelay(nanoseconds duration: UInt64) -\u003e DelayService\u003cSelf\u003e {\n        DelayService(decoratee: self, nanoseconds: duration)\n    }\n}\n\n// 이렇게 하는 대신\nDelayService(decoratee: LoggingService(decoratee: AllShowsService()), nanoseconds: 5 * NSEC_PER_SEC),\n\n// 이제 이렇게 할 수 있습니다\nAllShowsService()\n    .withLogging\n    .withDelay(nanoseconds: 5 * NSEC_PER_SEC)\n```\n\n## 데코레이터 자동화\n\nSourcery는 많은 보일러플레이트 코드를 자동화하는 훌륭한 메타프로그래밍 도구입니다. 데코레이터는 이 도구를 적용하기에 좋은 후보입니다. 특히 동일한 측면을 많은 다른 인터페이스에 적용하려는 경우에 유용합니다. 여기를 확인해보세요.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이러한 작업에 Objective-C의 동적 특성이 그립다는 것은 사실이지만, Swift에서 쉽게 AOP를 적용할 수 있는 런타임 지원의 부족은 좋은 설계 원칙을 적용하여 해결할 기회로 보고 있습니다.\n\nAOP를 활성화하는 것이 코드를 더 좋게 만든다는 보장은 없습니다. 마찬가지로 테스트 가능한 코드를 가지고 있다고 해서 좋은 코드라는 보장도 없습니다. 오히려 반대의 경우가 더 맞습니다. 코드를 테스트할 수 없는 것은 문제입니다. 테스트할 수 있는 것이라고 해서 그게 무조건 좋은 것은 아닙니다. AOP도 비슷한 맥락에서 볼 수 있습니다.\n\n우리는 코드에서 AOP 기능을 활성화하기 위한 흥미로운 연습을 했습니다. 하지만 우리가 추가한 복잡성을 잊어서는 안 됩니다. 미래에 더 잘 적응하기 위해 추가된 복잡성과 느슨한 결합 사이의 균형을 찾는 것은 개발자로서 가장 어려운 일 중 하나입니다. 이 글은 그저 도구에 불과합니다. 항상 올바른 도구를 올바르게 사용하세요.","ogImage":{"url":"/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png"},"coverImage":"/assets/img/2024-05-20-Aspect-OrientedProgramminginSwift_0.png","tag":["Tech"],"readingTime":12},{"title":"Swift에서 SOLID 원칙에 대한 예제","description":"","date":"2024-05-20 17:46","slug":"2024-05-20-SOLIDprinciplesinSwiftwithexamples","content":"\n\n위 문서의 향상된 버전을 확인하세요. 향상된 구문 강조와 최신 업데이트가 모두 포함된 개인 블로그에서 확인할 수 있습니다! 피드백과 참여를 환영하며 앞으로의 콘텐츠 제작을 지원해주세요:\n\n# (S) 단일 책임 원칙\n\n단일 책임 원칙(SRP)은 각 엔티티가 단 하나의 작업이나 문제 해결만을 담당해야 한다는 원칙을 말합니다.\n\n일반적으로 SRP를 따르지 않고 코드를 작성하는 예시를 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport Foundation\n\n구조체 처리기 {\n\n    개인 처리기\n\n    함수 처리() {\n\n        // 사람 데이터 가져오기\n        let personAsData = 가져오기()\n\n        // 데이터를 필요한 객체로 파싱\n        let person = 파싱(personAsData)\n\n        // 개인 객체 지역적으로 저장\n        저장하기(person)\n    }\n\n    사적 함수 가져오기() -\u003e 데이터 {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n        \n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n    사적 함수 파싱(_ data: Data) -\u003e 개인 {\n        try! JSONDecoder().decode(개인.self, from: data)\n    }\n\n    사적 함수 저장하기(_ person: 개인) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n}\n\n구조체 개인: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\n우리의 SRP가 깨진 부분은 Handler 엔티티 자체 내에서 모든 작업을 수행하고 있기 때문에 이를 각각의 엔티티로 분리하고 따로 처리해야 합니다. 이제 SRP를 따르는 코드를 살펴보겠습니다:\n\n```js\nimport Foundation\n\n구조체 처리기 {\n\n    개인 가져오기: 가져오기 핸들러\n    개인 파싱: 변환 핸들러\n    개인 저장: 저장 핸들러\n\n    이달함수(init: FetchHandler, ParseHandler, SaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n\n    함수 처리() {\n\n        // 사람 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n\n        // 데이터를 필요한 객체로 파싱\n        let person = parseHandler.parse(personAsData)\n\n        // 개인 객체 지역적으로 저장\n        saveHandler.save(person)\n    }\n\n}\n\n구조체 가져오기 핸들러 {\n\n    함수 가져오기() -\u003e 데이터 {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n        \n        }\n        \"\"\".data(using: .utf8)!\n    }\n\n}\n\n구조체 변환 핸들러 {\n     \n    함수 파싱(_ data: Data) -\u003e 개인 {\n        try! JSONDecoder().decode(개인.self, from: data)\n    }\n\n}\n\n구조체 저장 핸들러 {\n\n    함수 저장(_ person: 개인) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n\n}\n\n구조체 개인: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\nSRP는 다음과 같은 이점을 제공합니다:\n \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 더 높은 응집력\n- 코드 중복 가능성 감소\n- 부풀어 오른 클래스 감소\n- 테스트 및 유지 관리가 용이\n- 여러 책임이 분리되어 코드가 깔끔해짐\n\n# (O) 개방-폐쇄 원칙\n\n개방-폐쇄 원칙(OCP)은 엔티티가 확장에 대해 열려 있지만 수정에 대해서는 닫혀 있어야 한다는 것을 말합니다. 이는 클래스가 기존 코드를 수정하지 않고 쉽게 확장 가능해야 함을 의미합니다.\n\n처음에는 정의가 모순적으로 들릴 수 있지만 규모에 맞게 이 원칙을 따르기 시작하면 더 많은 의미를 갖게 됩니다. 이 원칙을 정말로 좁혀보면: 클래스를 만들고 확장할 수 있지만 원본 클래스를 수정할 수 없습니다. 이렇게하는 이유는:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다른 사람이 클래스를 작성했고 여기에 기능을 추가하거나 변경을 해야 할 때 원래 작성자에게 계속 변경을 요청해야 하거나 직접 변경해야 할 수 있었습니다. 이제 원 작성자는 기능이 작동하도록 작성한 모든 코드에 대해 다른 생각 과정을 가질 수 있습니다.\n- 게다가 클래스는 더 많은 관심사(또는 간단히 기능)를 통합(또는 단순히 추가)할 수 있는데, 이는 SRP를 깨뜨릴 수 있습니다.\n\n위에서 SRP가 활성화된 예에서 고려해보겠습니다. 여기에서는 사용자 개체를 UserDefaults에 저장했지만 이제 CoreData에도 저장하려고 합니다. 우리의 go-to 접근법은 다음과 같습니다:\n\n```js\nimport Foundation\n\nstruct Handler {\n    \n    private let fetchHandler: FetchHandler\n    private let parseHandler: ParseHandler\n    private let saveHandler: SaveHandler\n    \n    init(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: SaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n    \n    func handle() {\n        \n        // 사용자 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n        \n        // 데이터를 필요한 개체로 구문 분석\n        let person = parseHandler.parse(personAsData)\n        \n        // 사용자 개체를 UserDefaults에 로컬로 저장\n        saveHandler.saveToUserDefaults(person)\n        \n        // 사용자 개체를 CoreData에 로컬로 저장\n        saveHandler.saveToCoreData(person)\n    }\n   \n}\n\nstruct FetchHandler {\n    \n    func fetch() -\u003e Data {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n        \n        }\n        \"\"\".data(using: .utf8)!\n    }\n    \n}\n\nstruct ParseHandler {\n     \n    func parse(_ data: Data) -\u003e Person {\n        try! JSONDecoder().decode(Person.self, from: data)\n    }\n    \n}\n\nstruct SaveHandler {\n    \n    func saveToUserDefaults(_ person: Person) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n    \n    func saveToCoreData(_ person: Person) {\n        // CoreData에 데이터를 저장하는 매우 복잡한 코드\n    }\n    \n}\n\nstruct Person: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\n이는 우리가 철저히 테스트하고 나중에 배포한 save-to-User-Defaults의 원래 구현을 변경하고 있어 OCP를 깨뜨립니다. OCP를 수용하기 위해 클래스를 통해 상속을 사용하거나 우리 스위프트 개발자가 사용하기를 사랑하는 단순히 프로토콜 준수를 사용할 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nimport Foundation\n\nstruct Handler {\n    \n    private let fetchHandler: FetchHandler\n    private let parseHandler: ParseHandler\n    private let saveHandler: PersistenceHandler\n    \n    init(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: PersistenceHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n    \n    func handle() {\n        \n        // 사람 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n        \n        // 데이터 구문 분석하여 필요한 객체로 변환\n        let person = parseHandler.parse(personAsData)\n        \n        // 사람 객체를 로컬에 저장\n        saveHandler.save(person)\n    }\n   \n}\n\nstruct FetchHandler {\n    \n    func fetch() -\u003e Data {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n        \n        }\n        \"\"\".data(using: .utf8)!\n    }\n    \n}\n\nstruct ParseHandler {\n     \n    func parse(_ data: Data) -\u003e Person {\n        try! JSONDecoder().decode(Person.self, from: data)\n    }    \n}\n\nprotocol PersistenceType {\n    func save(_ person: Person)\n}\n\nstruct UserDefaultsPersistenceHandler: PersistenceType {\n    \n    func save(_ person: Person) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }    \n}\n\nstruct CoreDataPersistenceHandler: PersistenceType {\n    \n    func save(_ person: Person) {\n        // Core data에 데이터를 저장하기 위한 매우 포괄적인 코드\n    }\n}\n\nstruct PersistenceHandler {\n    \n    let userDefaultsPersistenceHandler: UserDefaultsPersistenceHandler\n    let coreDataPersistenceHandler: CoreDataPersistenceHandler\n    \n    init(userDefaultsPersistenceHandler: UserDefaultsPersistenceHandler, coreDataPersistenceHandler: CoreDataPersistenceHandler) {\n        self.userDefaultsPersistenceHandler = userDefaultsPersistenceHandler\n        self.coreDataPersistenceHandler = coreDataPersistenceHandler\n    }\n    \n    func save(_ person: Person) {\n        userDefaultsPersistenceHandler.save(person)\n        coreDataPersistenceHandler.save(person)\n    }\n}\n\nstruct Person: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\n만약 프로토콜 준수를 사용하고 싶지 않다면, 클래스를 통해 상속을 사용하여 동일한 결과를 달성할 수 있습니다:\n\n```kotlin\nimport Foundation\n\nstruct Handler {\n    \n    private let fetchHandler: FetchHandler\n    private let parseHandler: ParseHandler\n    private let saveHandler: ModifiedSaveHandler\n    \n    init(fetchHandler: FetchHandler, parseHandler: ParseHandler, saveHandler: ModifiedSaveHandler) {\n        self.fetchHandler = fetchHandler\n        self.parseHandler = parseHandler\n        self.saveHandler = saveHandler\n    }\n    \n    func handle() {\n        \n        // 사람 데이터 가져오기\n        let personAsData = fetchHandler.fetch()\n        \n        // 데이터 구문 분석하여 필요한 객체로 변환\n        let person = parseHandler.parse(personAsData)\n        \n        // 사람 객체를 로컬에 저장\n        saveHandler.save(person)\n    }\n   \n}\n\nstruct FetchHandler {\n    \n    func fetch() -\u003e Data {\n        \"\"\"\n        {\n            \"name\": \"Shubham Bakshi\",\n            \"age\": 28,\n            \"canTakeANapAnywhere\": true\n        \n        }\n        \"\"\".data(using: .utf8)!\n    }\n    \n}\n\nstruct ParseHandler {\n     \n    func parse(_ data: Data) -\u003e Person {\n        try! JSONDecoder().decode(Person.self, from: data)\n    }\n    \n}\n\nclass SaveHandler {\n    \n    func save(_ person: Person) {\n        UserDefaults.standard.set(person, forKey: \"person\")\n    }\n    \n}\n\nfinal class ModifiedSaveHandler: SaveHandler {\n    \n    override func save(_ person: Person) {\n        super.save(person)\n        \n        // Core data에 데이터를 저장하기 위한 매우 포괄적인 코드\n    }\n    \n}\n\nstruct Person: Codable {\n    let name: String\n    let age: Int\n    let canTakeANapAnywhere: Bool\n}\n```\n\nOCP의 이점은 다음과 같을 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 코드를 유지 및 검토하는 것이 쉽습니다.\n- 추상화 및 다형성의 사용을 촉진합니다.\n- 이미 테스트되고 배포 준비가 된 기존 코드를 수정할 수 없도록 하므로 잠재적 버그를 줄이는 데 도움이 됩니다.\n\n# (L) 리스코프 치환 원칙\n\n솔직히 말해서, 리스코프 치환 원칙(LSK)은 처음에는 아마도 가장 혼란스러운 원칙 중 하나일지도 모릅니다!\n\n그것이 실제로 말하는 것은 슈퍼클래스의 객체는 해당 서브클래스의 객체로 교체할 수 있어야 하는데 프로그램의 정확성에 영향을 미치지 않아야한다는 것입니다. LSK는 단순히 추가 단계를 통한 상속이라고 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상기한 예시를 사용하여 LSK(Liskov Substitution Principle)를 설명하는 것이 어렵고 혼란스러울 수 있으므로 다른 간단한 예시를 사용하겠습니다. 또한, 이미 해당 내용이 인터넷에 널리 퍼져 있고 때로는 혼란스러울 수 있기 때문에 사각형과 정사각형 예시를 사용하지 않겠습니다.\n\n```js\nimport Foundation\n\nclass Bird {\n    func fly() {\n        print(\"I can fly\")\n    }\n}\n\nfinal class Duck: Bird {\n    /// ✅ Duck은 날 수 있는 새이므로 LSP를 따릅니다.\n}\n\nfinal class Ostrich: Bird {\n    /// ❌ 사실 타조는 새이지만 날지 못하므로 LSP를 위반합니다.\n}\n```\n\n그렇다면 이 문제를 어떻게 해결할까요? 우리는 날 수 있는 새를 위한 별도의 클래스를 만듭니다:\n\n```js\nimport Foundation\n\nclass Bird {\n    \n}\n\nclass FlyingBird: Bird {\n    func fly() {\n        print(\"I can fly\")\n    }\n}\n\nfinal class Duck: FlyingBird {\n    /// ✅ Duck은 날 수 있는 새이므로 LSP를 따릅니다.\n}\n\nfinal class Ostrich: Bird {\n    /// ✅ 타조는 이제 날 필요가 없으므로 LSP를 따릅니다.\n    /// (그리고 이제는 다른 일에 집중할 수 있게 되었죠,\n    /// 예를 들어 사람 뒤를 더 빠르게 쫓아가서 겁을 줄 수 있는 방법에 대해)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLSP의 이점은 다음과 같습니다:\n\n- 코드는 유연하고 모듈식으로 유지됩니다.\n- 코드 중복을 줄입니다.\n\n# (I) 인터페이스 분리 원칙\n\n인터페이스 분리 원칙(ISP)은 클라이언트가 사용하지 않는 인터페이스를 강제로 구현하거나 클라이언트가 사용하지 않는 메서드에 의존하도록 강요해서는 안된다는 것을 명시합니다. 간단히 말하면, 하나의 뚱뚱한 인터페이스(또는 프로토콜) 대신에 많은 작은 인터페이스를 사용하여 제공하는 메서드에 기반을 둔다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nISP(Interface Segregation Principle)은 SRP(Single Responsibility Principle)와 비슷하지만, SRP는 일반적으로 구조체/클래스에 적용되고, ISP는 프로토콜에 적용됩니다.\n\n위의 샘플에서 Bird 예시를 사용하여 ISP를 설명할 수 있지만, 프로토콜(또는 다른 언어에서의 인터페이스)을 사용하여 우리의 entity가 하나 이상의 프로토콜을 준수할 수 있도록 할 것입니다:\n\n```js\nimport Foundation\n\nprotocol Bird {\n    \n    func fly()\n    \n    func swim()\n    \n    func mimic()\n}\n\nfinal class Duck: Bird {\n    /// ❌ Duck는 날 수 있고 헤엄칠 수 있지만 모방할 수는 없으므로 ISP를 위반함\n}\n\nfinal class Parrot: Bird {\n    /// ❌ Parrot은 날 수 있고 모방할 수 있지만 헤엄쳐갈 수는 없으므로 ISP를 위반함\n}\n\nfinal class Penguin: Bird {\n    /// ❌ Penguin은 헤엄칠 수 있지만 날 수 없으며 모방할 수도 없으므로 ISP를 위반함\n}\n```\n\n이 문제를 해결하기 위해 Bird 프로토콜을 하위 프로토콜로 분리하여 각 메서드를 수용할 수 있도록 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nimport Foundation\n\nprotocol FlyingBird {\n    func fly()\n}\n\nprotocol SwimmingBird {\n    func swim()\n}\n\nprotocol MimickingBird {\n    func mimic()\n}\n\nfinal class Duck: FlyingBird, SwimmingBird {\n    /// ✅ Follows ISP since duck can fly and swim without needing to mimic\n}\n\nfinal class Parrot: FlyingBird, MimickingBird {\n    /// ✅ Follows ISP since parrot can fly and mimic without needing to swim\n}\n\nfinal class Penguin: SwimmingBird {\n    /// ✅ Follows ISP since penguin can swim without needing to fly or mimic\n}\n```\n\nISP의 장점은 다음과 같습니다:\n\n- 더 집중된 및 일관된 인터페이스\n- 불필요한 종속성을 피할 수 있음\n- 단일 부풀린 인터페이스를 피할 수 있음\n- 결합을 촉진함\n\n# (D) 의존성 역전 원칙 (Dependency Inversion principle)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의존 역전 원칙(Dependency Inversion Principle, DIP)은 고수준 모듈이 저수준 모듈에 의존하지 않아야 하며, 둘 다 추상화에 의존해야 한다고 설명합니다. 간단하게 말하면: 구성원은 구상체(concretions)가 아닌 추상화(abstractors)에 의존해야 한다는 것이죠.\n\n이렇게 함으로써 코드가 가능한한 작은 표면적 영역에 의존하도록 보장됩니다. 실제로 코드 자체에 의존하지 않고, 단지 그 코드가 어떻게 행동해야 하는지를 정의하는 계약에만 의존하게 됩니다. 이렇게 함으로써 코드의 한 부분에 오류가 발생해도 다른 의존하는 부분에서 코드가 연쇄적으로 망가지는 결과를 막을 수 있습니다.\n\nDIP는 OCP와 꽤 비슷하게 들리지만 예시로서도 OCP의 예시를 사용할 수 있을 정도이기도 합니다. 그러나 여기서는 다른 예시를 사용하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예제는 DIP(Dependency Inversion Principle)를 위반합니다. Payment 클래스는 CreditCardPayment과 강하게 결합되어 있으며, 이는 고수준 모듈인 Payment 클래스가 저수준 모듈인 CreditCardPayment에 의존하고 있음을 의미합니다. DIP에 따르면 추상화/프로토콜에 의존해야 합니다.\n\n```js\nimport Foundation\n\nprotocol PaymentMethod {\n    func pay(_ amount: Double)\n}\n\nstruct DebitCardPayment: PaymentMethod {\n    func pay(_ amount: Double) { }\n}\n\nstruct CreditCardPayment: PaymentMethod {\n    func pay(_ amount: Double) { }\n}\n\nstruct ApplePayPayment: PaymentMethod {\n    func pay(_ amount: Double) { }\n}\n\nstruct Payment {\n    \n    private let paymentMethod: PaymentMethod\n    \n    init(method: PaymentMethod) {\n        paymentMethod = method\n    }\n    \n    func makePayment(of amount: Double) {\n        paymentMethod.pay(amount)\n    }\n}\n\nlet creditCardPaymentMethod = CreditCardPayment()\n\nlet payment = Payment(method: creditCardPaymentMethod)\npayment.makePayment(of: 500)\n```\n\nDIP의 장점:\n\n- 결합 감소를 장려함\n- 코드를 보다 유연하고 재사용 가능하며, 민첩하게 만듦\n- 구성 요소 간의 계약을 정의하기 위해 인터페이스 또는 프로토콜 사용을 장려함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모두를 종합하자면, 앱에 SOLID 원칙을 통합하는 것에는 많은 이점이 있습니다:\n\n- 코드를 이해, 유지 및 확장하기 쉽게 만들어줍니다.\n- 엔티티의 책임이 적을수록, 엔티티를 변경할 때 코드가 깨지는 가능성이 줄어듭니다.\n- 더 확장 가능하고 테스트하기 쉬운 코드를 작성할 수 있습니다.\n- 코드를 리팩터링하는데 더 적은 복잡성으로 도와줍니다.\n- 딱 맞는 수준의 결합을 사용할 수 있도록 도와줍니다 - 함께 있어야 할 것들은 함께 두고, 분리되어야 하는 것들은 분리합니다.\n\n여기까지, 여러분! 즐거운 코딩하세요!\n\nLinkedIn에서 저와 연결해보세요 👱🏻 또는 다른 채널로 연락할 수 있습니다 📬","ogImage":{"url":"/assets/img/2024-05-20-SOLIDprinciplesinSwiftwithexamples_0.png"},"coverImage":"/assets/img/2024-05-20-SOLIDprinciplesinSwiftwithexamples_0.png","tag":["Tech"],"readingTime":14},{"title":"새로운 iOS 18 기능으로 iPhone 사용 방법이 혁신됩니다","description":"","date":"2024-05-20 17:45","slug":"2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone","content":"\n\n![image](/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_0.png)\n\n우리 모두가 알고 있는 대로, 애플은 항상 기술을 모든 사람들에게 접근 가능하게 만드는 선두에 서 있습니다.\n\n분명히 시청 또는 청각 장애를 가진 사람들이 아이폰으로 어떻게 삶이 더 편해진다고 칭찬하는 소셜 미디어 포스트나 비디오를 보았을 겁니다.\n\niOS 18에서는 아이폰이 그들의 삶을 더욱 쉽게 만든 새로운 접근성 기능이 많이 소개되었습니다. 이 기능들은 iOS 업데이트와 개발자 베타 버전 공식 발표 한 달 전에 도입되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 흥미로운 점은 이것들이 일반적인 접근성 기능이 아니라는 것입니다; iPhone에 추가된 몇 가지 멋진 기능은 청각이나 시각 장애를 가진 사람뿐만 아니라 모두에 의해 활용될 수 있습니다.\n\n눈으로 iPhone을 제어하거나, 좋아하는 노래의 비트를 진동을 통해 느끼거나, 자주 사용하는 앱을 사용자 정의 사운드로 실행하는 것에 대해 얘기하고 있습니다.\n\nTony Stark가 할 것 같은 소리가 날 수도 있지만, 이 모든 것이 iOS 18 업데이트의 일환으로 소개된 최신 기능으로 이루어져 있습니다.\n\n이 게시물에서는 Apple이 개발한 가장 흥미로운 새로운 접근성 기능에 대해 자세히 살펴보고, iPhone 경험을 더 직관적이고 개인화된, 재미있는 것으로 만드는 방법에 대해 알아볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작해봅시다!\n\n## 눈으로 iPhone을 제어하세요 (눈폰? 👀)\n\niOS 18은 iPhone과 상호 작용하는 방식을 바꿀 것이며, 업데이트의 일부로 제공되는 새로운 눈 추적 기능이 그 대표적인 예시입니다.\n\n이 기능은 신체적 장애를 가진 사람들을 고려하여 설계되었으며, 눈을 움직이는 것만으로 iPhone이나 iPad를 제어할 수 있습니다. 네, 정말 매우 놀라운 일이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 작동 방식입니다:\n\n해당 기능 자체는 미래 지향적이고 복잡해 보일 수 있지만, 실제로는 놀랍도록 간단합니다. 따라서 iPhone의 전면 카메라가 모션 추적을 수행하고 화면에서 동작으로 변환하는 모든 작업을 처리합니다.\n\n아마 iPhone의 카메라가 항상 켜져 있고 개인 정보에 대해 걱정하실 수 있겠지만 걱정하지 마세요. 이 모든 작업은 기기 내에서 이루어지므로 데이터가 누구와도 공유되지 않기 때문에 Apple을 포함한 누구에게도 개인 정보가 노출되는 우려가 없습니다.\n\n![iOS 18 새로운 기능으로 아이폰과 상호 작용하는 방식을 새롭게 정의](/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, 흥미로운 점은 이 눈 추적 기능이 접근성에 관한 것뿐만 아니라 일상 업무에 손쉽게 활용할 수 있는 게임 체인저가 될 수 있다는 점입니다. 말 그대로, 당신은 팔을 올리지 않아도 잠재적으로 인스타그램 피드를 스크롤하거나, 이메일에 답장하거나, 비디오를 건너뛸 수도 있어요.\n\n가장 좋은 점은 추가 하드웨어 없이 iPadOS 및 iOS 앱 전체에서 매끄럽게 작동한다는 것입니다. 이는 카메라나 앱 스토어와 같은 시스템 앱부터 노트, 알림 및 캘린더와 같은 생산성 앱에 이르기까지 모든 것과 함께 사용할 수 있다는 것을 의미해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS 18에서는 새로운 '음악 햅틱스' 기능이 소개됩니다. 아이폰의 알림을 위해 진동하는 기술이죠. 다만 이번에는 좋아하는 노래의 소리를 진동으로 번역해줄 거예요. 아이폰이 바지 주머니에 있을 때는 활성화하지 않도록 주의하세요. (물론, 그런 스타일이라면 활성화해도 좋지요!)\n\n이 기능의 가장 좋은 점은 일부 곡에만 제한되지 않는다는 것입니다. Apple은 음악 햅틱스가 Apple Music 카탈로그의 수백만 곡과 함께 작동하도록 설계되었다고 언급했습니다. 또한 Apple은 음악 햅틱스를 API로 제공할 예정이라고 밝혔는데, 곧 Spotify나 YouTube Music 같은 앱에서도 볼 수 있을 겁니다.\n\n저는 이 기능이 스트리밍 및 비디오 앱에 도입되어, 폭발이나 싸움 장면과 같은 장면에서 손에 멋진 진동 효과를 줄 수 있기를 희망합니다. 하지만 우선 너무 앞서서 생각해보지는 말아요. 이것이 배터리 수명에도 영향을 줄 것이라고 확신합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만, 이 기능을 통해 음악을 새로운 차원에서 경험하고, 아마도 비디오까지도 즐길 수 있게 될 거예요. 아이폰에서 이 기능을 시도해 보고, 슬픈 노래를 들을 때 내 손과 내 마음에 미치는 효과를 느껴보고 싶네요.\n\n## 안녕 시리, 너 해고야\n\n세계 여러 사람들이 사용하는 iPhone의 기능인 음성 제어가 iOS 18 업데이트에서 크게 개선됩니다.\n\n실제로 음성 제어 기능에 추가되는 것은 두 가지입니다. 첫 번째는 보컬 단축키(Vocal Shortcuts)로, 기본 '애리시리' 깨우는 문구를 원하는 사용자 정의 문구로 바꿀 수 있게 해줍니다. (네, '자비스'로 바꿀 수 있어요)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 새로운 업데이트를 통해 좋아하는 앱을 실행하거나 스마트 홈 장치를 제어하거나 Siri와 함께 하던 모든 작업을 더 자연스럽고 개인적인 명령어로 수행할 수 있게 될 거예요.\n\n신기한 기능이나 재미있는 파티 트릭 이상으로, 음성 단축키는 실제로 말능력에 어려움을 겪는 사람들에게 아이폰을 더 접근 가능하게 해줄 수 있어요. 업데이트에 추가된 두 번째 중요한 기능은 '이상 발화 감지'라는 동반 기능입니다.\n\n이 기능은 기기 내 기계 학습을 사용하여 다양한 발화 패턴에 자동적으로 적응하게 됩니다. 이는 척수성 마비나 ALS와 같은 질병을 앓는 사람들에게 큰 혜택이 될 거예요. 이들은 종종 Siri와 같은 전통적인 음성 비서에게 자신을 이해시키기 어려워 하지만, 솔직히 말하면 Siri는 기본적으로 누구든지 이해하는 데 어려움을 겪죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n농담은 빼면서도, Apple이 개인 맞춤형 음성 인식으로 나아가는 것은 접근성에 대한 중요한 진전이며, 인공 지능이 기술을 모든 사람에게 포용적이고 사용자 친화적으로 만드는 방법의 좋은 예입니다.\n\n삼성과 구글과 같은 다른 대기업들이도 이에 합류하고 그러한 기능을 자사 기기에 구현하기를 희망합니다. 그저 가짜 달 사진 찍기나 흔히 알려진 이미지 생성과 같은 획기적인 기능뿐만 아니라 말이죠.\n\n## 멀미와 작별하기 🤢\n\n움직이는 차량 내에서 핸드폰을 사용하려고 할 때 거부감을 느낀 적이 없으면 부러워요. 이동 중에 핸드폰을 사용하려고 할 때 너무 불편한 느낌 중 하나일 것입니다. 여행할 때 가장 최악의 느낌 중 하나인데, 자주 지루하고, 토할 것 같은 욕구를 느낄 때 핸드폰을 사용할 수조차 없으니까요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS 18 업데이트에서 소개된 이 새로운 접근성 기능 '차량 동작 안내'에 대해 무척 기대되는 이유를 설명한 것입니다. 이미 제 개인적으로 가장 선호하는 기능이기도 한데요.\n\n이 기능이 어떻게 동작하는지 설명하기 전에 멀미가 어떻게 발생하는지 설명하겠습니다. 멀미는 주로 보는 것과 느끼는 것 사이의 불일치로 인해 발생합니다. 눈은 정적인 화면에 집중되어 있지만 몸은 움직임을 느끼기 때문에 메스꺼움이 발생할 수 있습니다.\n\niOS 18의 '차량 동작 안내' 기능은 iPhone 화면 가장자리에 애니메이션 점을 표시하여 이 간극을 메우고자 합니다. 이러한 점들은 자동차의 움직임과 동기화되게 약간 움직이며, 뇌에 시각적인 참조점을 제공하여 몸이 경험하는 것과 일치하는 것을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 간단한 개념처럼 들릴 수 있지만 실제로 매우 효과적일 수 있어요. iPhone이나 iPad의 내장 센서를 사용하여, Vehicle Motion Cues는 자동으로 차량 이동 감지하고 그에 따라 활성화되는 기능이에요. 심지어 자동으로 켜지도록 설정할 수 있어서 여행할 때마다 그것에 대해 생각할 필요가 없어요.\n\n저에게는 iOS 18에서 가장 흥미로운 새로운 기능 중에서도 이것이 터무니없이 흥미로워요. 제 요구 사항에 딱 맞춰져 있는 것 같아서 기쁘고요. 이제 멀리 가는 차 안에서도 메스꺼움을 느끼지 않고 핸드폰을 사용할 수 있다는 게 너무 설레고요. 많은 사람들에게 영향을 미치는 문제에 대처하면서 창의적으로 생각해 주신 애플에게 감사드리고 싶어요. 이런 기능을 만들어낸 애플 직원은 아마도 멀미를 하지 않을까 싶어요.\n\n## 약간의 다른 작은 개선사항 ✨\n\n위에서 언급한 새롭고 흥미로운 기능 이외에도, iOS 18에는 iPhone에 미치는 큰 향상을 가져다주는 몇 가지 다른 작은 접근성 기능이 포함되어 있어서 많은 사람들이 그것을 감사히 받아들일 것이라고 확신해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보이스오버 사용자들은 새로운 목소리, 사용자 정의 가능한 음성 로터, 그리고 Mac에서 키보드 단축키를 맞춤 설정할 수 있는 기능과 함께 개인화와 제어를 더욱 즐길 수 있게 되었습니다.\n\n새로운 리더 모드를 제공하는 확대기 옵션을 통해 텍스트를 더욱 읽기 쉽게 만들 수 있으며, 감지 모드에 쉽게 접근하여 사용자들이 주변 환경을 더 편리하게 탐색할 수 있게 됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_3.png\" /\u003e\n\n더불어, 라이브 스피치 사용자들은 새로운 카테고리와 라이브 캡션과의 원활한 통합을 통해 혜택을 받게 되며, 운동 기능 장애가 있는 사용자들을 위해 새롭고 개선된 가상 트랙패드가 아이폰을 탐색하는 편리한 방법을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 보이스 컨트롤이 업그레이드되어 사용자 정의 어휘와 복잡한 단어를 더 잘 인식하여 더 많은 사람들에게 유용해졌습니다.\n\niOS 18 업데이트에서 도입되는 가장 멋진 기능과 가장 혁명적인 접근성 기능에 대해 저와 같이 흥분하고 계시길 바랍니다.\n\n물론, 우리가 보았듯이 이러한 기능은 장애를 가진 사람들만을 위한 것이 아닙니다. 이것들은 우리가 아이폰과 아이패드와 상호 작용하는 방식을 혁신할 수 있으며, 일상적인 작업을 더 쉽고 직관적으로, 아마 더 재미있게 만들 수 있습니다.\n\n차 안에서 전화를 받거나 사용할 때 멀미하지 않고 휴대폰을 사용할 수 있는 가능성에 개인적으로 열광하지만, 또한 다른 사람들이 이러한 기능을 활용하는 방법을 보는 것도 기대됩니다. 눈으로 전화를 제어하거나 음악을 손으로 느끼거나 사용자 정의 음성 명령을 만드는 것, iOS 18에는 우리 모두를 위한 것이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 댓글 섹션에서 어떤 기능을 제일 기대하고 시도해보고 싶은지 알려주세요! 만약 이러한 기능을 활용하는 새로운 방법을 발견하면 공유도 해주세요. 흥미로운 사용 사례를 발견하는 것을 기대할게요!\n\n만약 워크플로에 새로운 유용한 앱을 발견하고 추가하는 것을 좋아한다면, 맥과 아이폰 앱 스토어인 Setapp을 정말 좋아하실 것입니다. 이 앱 스토어는 200개 이상의 프리미엄 앱을 단일 월 구독료 9.99달러로 이용할 수 있습니다.\n\n아래 내 제휴 링크를 사용하여 Setapp을 30일간 무료로 이용해보세요! 'usefultech' 코드를 사용하여 혜택을 받으실 수 있습니다.\n\n아래 링크를 통해 Setapp의 200여 개 프리미엄 앱을 30일간 무료로 이용하고 동시에 제 블로그를 직접 지원해주세요!","ogImage":{"url":"/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_0.png"},"coverImage":"/assets/img/2024-05-20-NewiOS18FeaturesReimagineHowYouInteractWithYouriPhone_0.png","tag":["Tech"],"readingTime":6},{"title":"월마트 소프트웨어 엔지니어 III - IOS IN3 면접 경험","description":"","date":"2024-05-20 17:44","slug":"2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience","content":"\n\n![image](/assets/img/2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience_0.png)\n\n안녕하세요, 모두 여러분. 최근에 월마트 글로벌 테크에서 소프트웨어 엔지니어 III — IOS 직책에 대한 면접을 보았어요. 총 3차론의 기술 면접이 모두 같은 날에 예정되었어요. 전체 면접 경험에 대해 자세히 말씀드릴게요.\n\n## 어떻게 지원했나요?\n\n링크드인에서 채용 담당자가 회사 내에서 열린 직책에 관해 나에게 연락했어요. 그 기회에 관심이 있었고, 채용 담당자에게 해당 직책에 관심이 있다고 답변했어요. 그런 다음 면접이 5일 후에 예정되었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 면접 라운드.\n\n## 라운드 1: 자료 구조와 알고리즘 라운드.\n\n이 라운드는 월마트의 소프트웨어 엔지니어가 진행했습니다. 면접관은 먼저 자기 소개를 하고 제 소개를 요청한 후 면접 문제로 넘어갔어요. 첫 번째 문제는 Best Time to Buy and Sell Stock라는 leetcode 쉬운 문제였습니다. 저는 O(n²) 시간 복잡도의 방법을 설명했고, 이후 O(n) 시간 복잡도의 방법을 설명했습니다. 면접관은 후자에 납득하고 코딩을 요처했어요. 그 후, 두 번째 문제인 Buy Two Chocolates라는 leetcode 쉬운 문제를 설명하고 O(n²) 시간 복잡도 및 O(n) 시간 복잡도로 접근하여 코딩했습니다. 면접관은 제 방법을 좋아하셨고 모든 테스트 케이스를 통과하는 것을 확인했어요. 그리고 면접관은 추가로 2개 대신 \"n\" 개의 초콜릿을 추가하라는 요구사항을 제시했습니다. 저는 최소 힙을 사용할 것을 말했고 면접관은 코드를 작성해보라고 했지만 시간적 제약으로 인해 소화하지 못했습니다.\n\n면접은 60분 동안 진행되었고 피드백은 전반적으로 긍정적이었으며 두 번째 라운드를 위해 인사 담당자로부터 전화를 받았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 라운드 2: Swift/iOS 라운드\n\n이번 라운드는 월마트의 소프트웨어 엔지니어가 진행했습니다. 인터뷰어가 먼저 자기소개를 한 후, 나에게 나의 소개를 요청했습니다. 나는 자신을 소개하고 나서 인터뷰 질문으로 넘어갔습니다. 질문은 다음과 같습니다.\n\n- 구조체 vs 클래스.\n- 프로토콜: 델리게이션, 프로토콜 내 메서드 건너뛰기 또는 무시하기.\n- 클로저: 탈출 클로저 vs 비탈출 클로저.\n- ARC: 약한 참조, 미소유 참조, 강한 참조.\n- 메인 스레드와 백그라운드 스레드.\n- MVVM vs MVC 아키텍처.\n- 싱글턴 클래스.\n- Swift에서의 제네릭.\n- 오픈 vs 퍼블릭 액세스 제어.\n- iOS의 애플리케이션 및 뷰 라이프사이클.\n\n나는 질문의 약 95%에 대답할 수 있었습니다. 인터뷰는 60분 동안 진행되었습니다. 전체적으로 피드백은 긍정적이었고, 다음 라운드를 위해 인사담당자로부터 전화를 받았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Round 3: 채용 담당자 라운드\n\n이 라운드는 월마트의 시니어 엔지니어링 매니저가 진행했습니다. 그는 안드로이드 개발 분야 출신이었습니다. 인터뷰어는 자신을 소개하고, 그 후에 저에게 자기 소개를 부탁했습니다. 저는 제 소개를 하고, 그 후에 바로 질문들이 시작되었습니다. 질문은 다음과 같았어요.\n\n- 전환 이유는 무엇인가요?\n- iOS 앱이 잘 작동하는 것을 어떻게 보장할 건가요?\n- 이전 조직에서 내가 한 기여는?\n- 현재 조직에서 좋지 않은 점 2가지는 무엇인가요?\n- 네이티브 앱이 하이브리드보다 더 나은 이유는 무엇인가요?\n\n그런 다음에 제가 질문이 있는지 물었고, 저는 회사 문화, 앱 아키텍처 등에 관한 일부 질문을 했습니다. 인터뷰는 약 45분 동안 이어졌어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전체적으로 이번 라운드는 꽤 잘 진행된 것 같아요. 그러나 면접 중에 몇 가지를 실수한 것 같고, 대답하는 내용에 대해 확신이 없는 부분이 있었어요. 이번 라운드 이후에 리쿠루터로부터 소식을 전혀 듣지 못했어요.\n\n그래서 이것이 제 면접 경험에 대한 이야기에요. 난이도는 5점 중 3점으로 평가할 수 있을 것 같아요. 그들로부터 추가 소식을 아직 받지 못했어요.\n\n# 결론과 배울 점\n\n- iOS 라운드를 위해 Swift와 Apple 문서에서 모든 것을 알고 있어야 해요.\n- DSA 라운드를 위해 leet code 쉬운, 중급 문제에 대비해야 해요.\n- Hiring Manager 라운드에 대비해 항상 아주 잘 준비됐어야 해요. 설득력 있는 대답을 준비하고 항상 자신감 있어야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 아무 것이나 있으면, 저와 연락하세요: [링크드인 프로필](https://www.linkedin.com/in/kapil-shanbhag)\n\n## 감사합니다!","ogImage":{"url":"/assets/img/2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience_0.png"},"coverImage":"/assets/img/2024-05-20-WalmartSoftwareEngineerIIIIOSIN3InterviewExperience_0.png","tag":["Tech"],"readingTime":3},{"title":"코드 리뷰에서 논의하는 것 그만 하고 린트 규칙으로 강제해 보세요","description":"","date":"2024-05-20 17:41","slug":"2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules","content":"\n\n## Konsist를 사용하여 아키텍처와 최상의 실천 방법을 단위 테스트로 강화하는 방법\n\n![Code Review Comments](/assets/img/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules_0.png)\n\n이제 다음 코드 리뷰 댓글을 살펴보겠습니다:\n\n물론 가장 중요한 것은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 이것들을 알고 계셨나요? 이것들은 모두 코드 리뷰에서 나타나는 문제들이에요! (네, 이 용어가 실제로 존재합니다. 안타깝게도 이 용어를 만든 사람은 저가 아닙니다.)\n\n코드 스타일, 프로젝트 아키텍처, 또는 일반적으로 건강하고 유지보수가 용이한 코드베이스를 유지하기 위해 따라야 하는 모베스트 프렉티스에 대한 일정 정렬이 필요할 때, 우리는 그것을 강제하는 자동화를 구축해야 합니다. 그리고 그것이 바로 lint rule입니다.\n\n개발자들이 새로운 기능을 개발할 때, 어떻게 진행해야 할지 자신감을 가져야 합니다. 그들은 아키텍처의 각 레이어, 각 클래스의 역할, 그리고 우리가 정립한 규칙을 이해할 수 있어야 합니다. 그리고 새 직원들은 가능한 빨리 코드베이스에 적응하여 헷갈리지 않고 진행할 수 있어야 합니다.\n\n우리 팀과 함께 새로운 사례들을 발견하고 그것에 동의하며 조인하는 과정에서 주로 토론의 여지가 없는 표준들을 강제하는 좋은 프로세스가 이미 마련되어 있기 때문에요. 물론 이 프로세스는 계속해서 발전하며 우리가 시간이 지남에 따라 새로운 모베스트 프렉티스를 발견하고 이에 동의할 때마다 업데이트될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 왜 Konsist를 사용해야 하나요? 이미 린터가 있지 않나요?\n\n맞아요, 린터는 이미 여러 년 동안 사용해 왔어요! 심지어 안드로이드 스튜디오에는 기본으로 내장되어 있어요. 하지만 PSS에서 우리 안드로이드 앱에서 몇 가지 대안을 시도한 후, 하나를 깨달았어요: 모두가 높은 학습 곡선을 가지고 있었고, 아키텍처 규칙을 유지보수 가능한 방식으로 강제할 수 없었기 때문에 코드 리뷰 중에 위반 사항을 발견하는 데 특히 조심해야 했어요. 코드가 읽기 어려웠고, CI/CD 시스템과의 통합은 간단한 작업이 아니었고, 궁극적으로 아무도 정말 사용자 지정 린트 규칙을 작성하고 싶어하지 않았어요.\n\n![image](/assets/img/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules_1.png)\n\n다행히도 우리는 마침내 Konsist에 도달했어요. Konsist는 Lint 규칙을 단위 테스트 형식으로 작성하는 주요 원칙을 가진 비교적 새로운 프로젝트에요. 그것이 큰 차이를 만들어 주는 것이죠. 대부분의 개발자들이 이미 단위 테스트를 작성하는 데 익숙하기 때문에, 린트 규칙을 작성하는 데도 빨리 적응하게 될 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노트: 단위 테스트 작성에 어려움을 겪는다면, 포괄적인 단위 테스팅 가이드(Unit Testing Diet)를 확인해 보세요.\n\n# Konsist로 lint 규칙 작성하기\n\nKonsist에서 lint 규칙은 단위 테스트이므로, JUnit 5, JUnit 4 또는 Kotest를 사용하여 테스트 작성과 유사하게 작성할 수 있습니다.\n\n저희 프로젝트에서는 테스트를 Given-When-Then 스타일로 구성하는 것을 선호하므로, lint 규칙에도 Kotest의 Behavior Spec을 사용해 동일한 방식으로 작성하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 주어진 것: 이것은 우리 테스트의 설정입니다. 우리는 리엔트 규칙이 적용되어야 하는 파일이나 클래스를 지정할 것입니다.\n- 하는 중: 유닛 테스트에서 이것은 일반적으로 결과를 평가하기 전에 수행되는 작업입니다. 리엔트 규칙은 특정 작업과 관련이 없기 때문에, 이 단계는 선택 사항입니다. 하지만, 우리는 여전히 이전 단계에서 지정한 파일에 대한 추가 필터링을 위해 사용할 수 있습니다 (예: 클래스의 속성, 생성자, 함수 등을 필터링).\n- 그러면: 이것은 우리의 단언입니다. 우리는 강제하려는 리엔트 규칙을 위반하지 않음을 주장할 것입니다.\n\n다음은 모든 ViewModel이 BaseViewModel을 확장하도록 강제하는 리엔트 규칙의 예시입니다:\n\n```js\ndependencies {\n    testImplementation(\"com.lemonappdev:konsist:$konsistVersion\")\n    testImplementation(\"io.kotest:kotest-runner-junit5:$kotestVersion\")\n}\n```\n\n```js\nclass ViewModelsExtendBaseViewModel : BehaviorSpec() {\n\n    init {\n        Given(\"모든 프로덕션 코드 클래스\") {\n            val scope = Konsist.scopeFromProduction().classes()\n\n            When(\"ViewModel이 있을 때\") {\n                val viewModels = scope.withNameEndingWith(\"ViewModel\")\n\n                Then(\"BaseViewModel을 확장하도록 한다\") {\n                    viewModels.assertTrue {\n                        it.hasParentWithName(\"BaseViewModel\")\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드가 무엇을 하는지 분석해보겠습니다:\n\n- 주어진 것: 먼저 대상으로 삼고자 하는 파일 또는 클래스를 나타내는 범위를 정의합니다. 이 경우에는 프로덕션 코드의 모든 클래스(테스트 클래스 제외)가 포함됩니다. 특정 모듈, 소스 세트, 패키지 또는 디렉토리를 대상으로 지정할 수도 있습니다. 사용 가능한 모든 옵션에 대해서는 문서를 참고할 수 있습니다.\n- 조건부: 클래스를 필터링하여 이름이 `ViewModel`으로 끝나는 클래스만 가져옵니다.\n- 결과: 필터링된 클래스들이 `BaseViewModel`를 확장하고 있는지 단언합니다.\n\n그게 전부입니다! 상당히 간단하죠? 이제 우리는 유닛 테스트를 실행하는 방식으로 동일하게 Gradle이나 Android Studio를 사용하여 Lint 규칙을 실행할 수 있는 자체 Lint 규칙을 갖추게 되었습니다. 그리고 가장 좋은 점은 테스트 주도 개발(TDD)을 따를 수 있다는 것입니다. 코드 냄새를 확인하면 실패하는 테스트를 작성한 후 위반 사항을 수정하고 테스트(Lint 규칙)가 통과되는 것을 확인할 수 있습니다.\n\n## 사용자 정의 메시지 추가하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발자에게 친화적인 방식으로 린트 규칙의 오류 메시지를 개선하려면 assertTrue 함수의 additionalMessage 매개변수를 사용하여 왜 이 릴 스규칙을 강제해야 하는지 설명하는 사용자 정의 메시지를 추가하는 것을 권장합니다:\n\n```js\n/* ... */\n\nviewModels.assertTrue(additionalMessage = MESSAGE) {\n    it.hasParentWithName(\"BaseViewModel\")\n}\n\n/* ... */\n\nprivate companion object {\n    private const val MESSAGE =\n        \"새 ViewModel을 만들 때 항상 BaseViewModel을 확장하여 라이프사이클 이벤트 및 제공하는 기타 기능을 활용하십시오.\"\n}\n```\n\n## 기준 지정\n\n이제 방금 작성한 테스트(린트 규칙)를 실행해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Lint Rule Violation](/assets/img/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules_2.png)\n\nOops! It looks like we've encountered some violations of the lint rule in our project. This gives us two options:\n\n- Either resolve the violations by refactoring our ViewModels to extend the BaseViewModel.\n- Or add the violating classes to the baseline. The baseline is a list of files or classes that we intentionally exclude from this lint rule. This could include legacy code we're not ready to refactor yet or valid cases where the lint rule shouldn't be applied.\n\nTo apply a baseline, we can create a BASELINE array in the companion object and pass it as a parameter in the withoutName function to filter out those classes. In our case, we will add the BaseViewModel to the baseline since it can't extend itself.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n/* ... */\n\nval viewModels = scope.withNameEndingWith(\"ViewModel\").withoutName(*BASELINE)\n\n/* ... */\n\nprivate companion object {\n    private const val MESSAGE =\n        \"Always extend the BaseViewModel when creating a new ViewModel, to take advantage of the lifecycle events and other features it provides.\"\n\n    private val BASELINE = arrayOf(\"BaseViewModel\")\n}\n```\n\n라이브러리 룰에서 클래스를 제외하는 대체 방법은 각 파일 또는 클래스에서 제외하려는 것에 @Suppress 어노테이션을 사용하는 것이 있습니다. 그러나 이러한 룰의 예외 사항을 한눈에 확인할 수 있도록 테스트에서 직접 BASELINE 배열을 사용하는 것을 권장합니다.\n\n참고: 기술 부채를 해결하는 과정에서 베이스라인에 포함되는 클래스 수를 점차 감소시키는 것이 좋습니다. 그 목록이 계속 늘어나면 좋지 않은 신호입니다.\n\n# 혜택 #1: 아키텍처 강제화\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 리뷰의 아키텍처에 대한 코멘트는 가장 중요하면서도 가장 방해가 되는 부분 중 하나입니다. 개개인이 아키텍처를 재설계하는 데 몇 시간이 소요될 수 있을 뿐만 아니라, 이러한 코멘트들은 종종 \"나중에 이것을 고칠 수 있을까요?\" 라는 일반적인 반대 의견을 받는 경우가 많습니다 (그리고 결국 고쳐지지 않습니다).\n\n여기서 Konsist의 강점이 드러납니다. 특히 다중 모듈 프로젝트에서 아키텍처 규칙을 강제하는 능력이죠. 몇 가지 예시를 살펴보겠습니다:\n\n- ViewModels는 생성자에서 Repository를 주입해서는 안 됩니다. 이렇게 함으로써 ViewModels가 데이터를 보내거나 검색할 때 UseCase 레이어만과 통신하도록 보장됩니다:\n\n```js\nclass ViewModelsDoNotInjectRepositories : BehaviorSpec() {\n\n    init {\n        Given(\"All classes in production code\") {\n            val scope = Konsist.scopeFromProduction().classes()\n\n            When(\"There is a ViewModel\") {\n                val viewModels = scope.withNameEndingWith(\"ViewModel\")\n\n                Then(\"No Repository is listed in the constructor parameters\") {\n                    viewModels.withConstructor {\n                        it.hasParameter { param -\u003e\n                            param.type.name.endsWith(\"Repository\")\n                        }\n                    }.assertEmpty()\n                }\n            }\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 저장소는 저장소 모듈 내에 있어야 합니다. 이는 우리 아키텍처의 다른 레이어와의 깔끔한 분리를 강제하는 것입니다:\n\n```js\nclass RepositoriesResideInRepositoriesModule : BehaviorSpec() {\n\n    init {\n        Given(\"프로덕션 코드의 모든 클래스\") {\n            val scope = Konsist.scopeFromProduction().classes()\n\n            When(\"Repository가 존재할 때\") {\n                val repositories = scope.withNameEndingWith(\"Repository\")\n\n                Then(\"그 Repository는 repositories 모듈에 속해 있어야 합니다\") {\n                    repositories.assertTrue {\n                        it.resideInModule(\"data/repositories\")\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n- 도메인 레이어 모듈은 DTO를 가져오지 않아야 합니다. 이는 도메인 레이어를 응용 프로그램 레이어와 분리하여 깨끗한 아키텍처와 도메인 주도 설계에 부합합니다.\n\n```js\nclass DomainLayerDoesNotImportDTOs : BehaviorSpec() {\n\n    init {\n        Given(\"도메인 레이어 모듈\") {\n            val scope = Konsist.scopeFromDirectory(\"domain\").files\n\n            Then(\"DTO를 가져오지 않습니다\") {\n                scope.assertFalse {\n                    it.text.contains(\"com.perrystreet.dto\")\n                }\n            }\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 디자인 시스템은 도메인 모델을 가져오지 않아야 합니다. 이렇게 하면 디자인 시스템이 우리 앱의 기능과 독립적이며 중립적이라는 것을 보장할 수 있습니다:\n\n```js\nclass DesignSystemDoesNotImportDomainModels : BehaviorSpec() {\n\n    init {\n        Given(\"디자인 시스템 모듈\") {\n            val scope = Konsist.scopeFromDirectory(\"design-system\").files\n\n            Then(\"도메인 모델을 가져오지 않습니다\") {\n                scope.assertFalse {\n                    it.text.contains(\"com.perrystreet.domain.models\")\n                }\n            }\n        }\n    }\n}\n```\n\n# 혜택 #2: 버그 방지\n\n일반적으로 코드베이스에서 버그를 만나면, 우리는 다음 질문을 스스로에게 하게 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이메일에 마음이 아프셨을 수도 있을 것 같아요! 소중한 피드백 감사드립니다. 그러나, 이메일을 수십 번이나 보내실 필요는 없어요. 결과를 기다리고 계셨다는 걸 알기에 충분해요. 걱정마세요! 결과가 나올 때까지 조금만 기다려보세요. 결과가 나올 때 바로 알려드릴게요. 편안하게 기다려주세요! 🕒😊\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 프로젝트에서 최근에 실제로 겪은 버그를 보호해주는 린트 규칙을 살펴보겠습니다.\n\nRetrofit에서 다음과 같은 함수를 고려해봅시다. 이 함수는 서버에 id와 name을 @Field 매개변수로 보내는 POST 요청을 수행합니다.\n\n```js\n@POST(PATH)\nfun postProfile(@Field(\"id\") id: Long, @Field(\"name\") name: String)\n```\n\n그러나 실행을 시도하면 앱이 다음과 같은 오류로 중단될 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\njava.lang.IllegalArgumentException: @Field 매개변수는 form 인코딩과 함께만 사용할 수 있습니다. (매개변수 #1)\n    postProfile 메서드에 대해\n```\n\n@Field 주석은 데이터를 form-URL로 인코딩하여 보내며, 함수에 @FormUrlEncoded 주석이 필요합니다. 그렇지 않으면 앱이 다운될 수 있습니다:\n\n```js\n@POST(PATH)\n@FormUrlEncoded\nfun postProfile(@Field(\"id\") id: Long, @Field(\"name\") name: String)\n```\n\n이 문제를 방지하기 위한 린트 규칙을 만드는 것이 얼마나 완벽한 사용 사례인가요!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nclass RetrofitFieldParamsUseFormUrlEncoded: BehaviorSpec() {\n\n    init {\n        Given(\"프로덕션 코드의 모든 함수를 가져옵니다.\") {\n            val scope = Konsist.scopeFromProduction().functions()\n\n            When(\"@POST 주석이 있는 함수가 있는 경우\") {\n                val functions = scope.withAnnotationNamed(\"POST\")\n\n                And(\"@Field 매개변수가 하나 이상 있는 경우\") {\n                    val functionsWithFieldParams = functions.withParameter {\n                        it.hasAnnotationWithName(\"Field\")\n                    }\n\n                    Then(\"@FormUrlEncoded 주석이 있는 경우\") {\n                        functionsWithFieldParams.assertTrue {\n                            it.hasAnnotationWithName(\"FormUrlEncoded\")\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n```\n\n여기에 코드의 요약이 있습니다:\n\n- Given: 우리는 프로덕션 코드에서 모든 함수를 가져올 것입니다.\n- When: @POST 주석이 있는 함수를 필터링합니다.\n- And: 추가적인 필터를 적용하여 @Field 주석이 하나 이상 있는 함수를 가져올 것입니다.\n- Then: 이러한 필터링된 함수들이 @FormUrlEncoded 주석도 가지고 있는지 확인합니다.\n\n# Konsist와 함께한 프로젝트 구조\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 본 바와 같이 Konsist 린트 규칙은 단위 테스트와 같습니다. 즉, 이를 실행하려면 해당 규칙을 프로젝트의 테스트 소스 세트에 배치해야 합니다. 나머지 단위 테스트와 함께 두어야 합니다.\n\n그러나 특히 멀티 모듈 프로젝트에서 작업 중이라면 더 나은 접근 방식이 있습니다. 린트 규칙을 다른 단위 테스트에서 분리하기 위해 모든 린트 규칙을 담을 전용 모듈을 만들 수 있습니다:\n\n![이미지](/assets/img/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules_4.png)\n\n그리고 모듈 구조 및 build.gradle.kts 파일은 이렇게 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmd\n![이미지](/assets/img/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules_5.png)\n\n```js\nplugins {\n    id(\"kotlin\")\n}\n\njava {\n    sourceCompatibility = JavaVersion.VERSION_17\n    targetCompatibility = JavaVersion.VERSION_17\n}\n\ntasks.test {\n    useJUnitPlatform()\n}\n\ndependencies {\n    testImplementation(\"com.lemonappdev:konsist:$konsistVersion\")\n    testImplementation(\"io.kotest:kotest-runner-junit5:$kotestVersion\")\n}\n```\n\n참고: 여기에 모듈의 나머지를 종속성으로 추가할 필요가 없습니다. Konsist는 기본적으로 전체 프로젝트에 액세스할 수 있으며 명시적인 종속성이 필요하지 않습니다.\n\n이 접근 방식으로 다른 이점은 코드 리뷰에서 리뷰하는 대신 리뷰어가 관례 규칙을 집행할 수 있다는 것입니다. 단위 테스트와 별도로 출력을 실행할 수 있습니다. `:'module':test` Gradle 작업을 사용하여 린트 규칙을.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종적으로 중복 코드를 줄이기 위해 린트 규칙을 작성할 때, 흔히 사용하는 범위를 포함하는 KonsistUtils.kt 파일을 생성하는 것을 권장합니다:\n\n```js\nobject KonsistUtils {\n\n    val productionCode\n        get() = Konsist.scopeFromProduction()\n\n    val classes\n        get() = productionCode.classes()\n\n    val interfaces\n        get() = productionCode.interfaces()\n\n    val viewModels\n        get() = classes.withNameEndingWith(\"ViewModel\")\n\n    val useCases\n        get() = classes.withNameEndingWith(\"UseCase\")\n\n    val repositories\n        get() = classes.withNameEndingWith(\"Repository\")\n\n    val domainModule\n        get() = Konsist.scopeFromDirectory(\"domain\")\n\n    val designSystemModule\n        get() = Konsist.scopeFromDirectory(\"design-system\")\n\n    /* ... */\n}\n```\n\n# CI/CD에서 린트 규칙 실행하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, Konsist 모듈을 설정하고 사용자 정의 린트 규칙을 작성하는 데 많은 노력을 기울인 끝에, 한 가지가 남았습니다: 만약 린트 규칙을 위반하면 병합할 풀 리퀘스트를 차단하는 방법은 무엇일까요?\n\n이미 유닛 테스트를 위한 파이프라인을 설정했다면, 이 작업은 매우 간단할 것입니다. 필요한 것은 이전에 만든 Konsist 모듈의 유닛 테스트를 실행할 추가 단계뿐입니다.\n\nGitHub Actions 또는 Bitrise를 사용한 예제 구성을 살펴보겠습니다:\n\n## GitHub 액션 구성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 GitHub Action은 저장소를 체크아웃하고 Java와 Gradle을 설정한 다음, konsist 모듈에서 모든 단위 테스트(린트 규칙)를 실행하는 Gradle 작업을 실행합니다. 이 작업은 풀 리퀘스트가 올라올 때 트리거됩니다:\n\n```js\nname: Run Konsist lint rules\non:\n  pull_request:\n    types: [opened, synchronize]\n\njobs:\n  run-lint-rules:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: 17\n\n      - name: Setup Gradle\n        uses: gradle/actions/setup-gradle@v3\n\n      - name: Run Konsist lint rules Gradle task\n        run: ./gradlew :konsist:test\n```\n\nGitHub Action을 설정한 후, 해당 동작을 레포지토리 설정의 브랜치 보호 규칙에서 필수 상태 체크로 지정해 둘 수 있습니다. 이렇게 하면 린트 규칙을 위반하는 경우 풀 리퀘스트가 병합되지 못하도록 막을 수 있습니다.\n\n## Bitrise 구성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Bitrise를 사용 중이라면, 단순히 워크플로에 추가할 추가 단계로 :konsist:test Gradle 작업을 실행하면 됩니다:\n\n![이미지](/assets/img/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules_6.png)\n\n마지막으로, 모든 모듈에서 Konsist 린트 규칙을 포함하여 병렬로 모든 단위 테스트를 실행하려면, 이들을 하나의 Gradle 작업에 결합하여 상위 레벨 build.gradle.kts 파일에 정의할 수 있습니다:\n\n```js\ntasks.register(\"runAllTests\") {\n    dependsOn(\n        \":app:test\",\n        \":domain:test\",\n        \":other-module:test\",\n        // ...\n        \":konsist:test\"\n    )\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Summary\n\n린트 규칙은 코드베이스의 구조와 팀의 수립된 최상의 및 필수적인 실천 방법에 대한 서면 약정으로 작용합니다. 그것들은 모호성을 제거하여 코드베이스를 일관되게 유지하는 데 도움을 주며, 우리의 프로젝트를 미묘한 버그로부터 보호하고 코드 작성 및 리뷰 속도를 크게 높일 수 있습니다.\n\nKonsist를 통해, 우리는 안드로이드에서 린트 규칙 작성을 단순하고 접근 가능하게 만들어주는 오랜 기다림이 이루어졌습니다. 이 도구는 확실히 사용자 테스트로 재해석하는 탁월한 아이디어로 사용자 정의 릴 규칙 작성에 있어 이정표를 세우게 됩니다.\n\n프로젝트를 지원하는 방법을 알아보려면 Konsist 기여 가이드라인을 꼭 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## PS. iOS는 어떻게 되었나요?\n\n우리 팀은 iOS에서 SwiftLint를 사용해왔습니다. 이 도구는 파일 이름 패턴 일치를 사용하여 정규식 기반 규칙을 작성할 수 있는 강력한 기능을 갖추고 있어 대부분의 구조적인 규칙을 작성할 수 있게 해줍니다. 그러나 모든 규칙을 작성할 수 있는 것은 아닙니다. 이에 대해 곧 블로그 포스트를 통해 더 많은 내용을 알려드릴 예정입니다.\n\n# 저자 소개\n\n스텔리오스 프란티스카키스는 Perry Street Software의 스탭 엔지니어입니다. 해당 회사는 LGBTQ+ 데이팅 앱 SCRUFF와 Jack'd를 제작하여 전 세계 3000만 명 이상의 회원을 보유하고 있습니다.","ogImage":{"url":"/assets/img/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules_0.png"},"coverImage":"/assets/img/2024-05-20-StopDebatinginCodeReviewsStartEnforcingwithLintRules_0.png","tag":["Tech"],"readingTime":15},{"title":"코틀린의 Any, Unit, Nothing 이해하기","description":"","date":"2024-05-20 17:40","slug":"2024-05-20-UnderstandingKotlinsAnyUnitNothing","content":"\n\n\n![Understanding Kotlin's Any, Unit, Nothing](/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png)\n\nKotlin은 Java에서 사용하던 것과는 매우 다른 독특한 유형을 제공합니다. 이 블로그에서는 Any, Unit, 그리고 Nothing과 같은 세 가지 유형을 탐색해 볼 것입니다.\n\n## Any\n\n```js\n// 소스 코드\npackage kotlin\n/**\n * 코틀린 클래스 계층 구조의 루트. 모든 코틀린 클래스는 [Any]를 슈퍼 클래스로 갖습니다.\n */\npublic open class Any {\n    public open operator fun equals(other: Any?): Boolean\n    public open fun hashCode(): Int\n    public open fun toString(): String\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클래스 계층 구조의 루트입니다. 모든 Kotlin 클래스는 Any로부터 상속받습니다.\n- Java의 Object에 해당됩니다.\n- 우리가 오버라이드할 수 있는 세 가지 메소드를 제공합니다: equals(), hashCode(), toString(). 이것이 어떤 클래스에서 메소드를 오버라이드할 때 IDE에서 이 세 가지 옵션이 자주 제시되는 이유입니다.\n- 기본적으로 Nullable이 아닙니다. 변수가 null을 저장할 수 있도록 필요하다면 Any?를 사용할 수 있습니다.\n\n예제\n\n```js\nfun printAny(value: Any?) {\n    println(value.toString())\n}\n\nfun main() {\n    printAny(\"Hello, World!\")  // 출력: Hello, World!\n    printAny(123)  // 출력: 123\n}\n```\n\n```js\n// 디컴파일할 때 Any는 Java의 Object로 변환됩니다\npublic static final void printAny(@Nullable Object value) {\n   String var1 = String.valueOf(value);\n   System.out.println(var1);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Unit\n\n```js\n//SOURCE CODE\npackage kotlin\n/**\n * `Unit` 객체만 있는 유형입니다. 이 유형은 Java의 `void` 유형에 해당합니다.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n```\n\n- Java의 void와 동등하지만 void와 달리 Unit은 하나의 인스턴스만 있는 실제 클래스입니다 (싱글톤).\n- 의미 있는 값을 반환하지 않는 함수를 나타냅니다.\n- 함수의 반환 유형을 명시하지 않으면 Kotlin은 기본 반환 유형으로 Unit을 사용합니다.\n\n예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfun printMessage(message: String) { // Unit을 명시적으로 작성할 필요가 없습니다.\n    println(message)\n}\n\nfun main() {\n    printMessage(\"안녕, Unit!\")  // 출력: 안녕, Unit!\n}\n```\n\n```js\n// 변환된 결과, Unit은 Java에서 void로 변환됩니다.\npublic static final void printMessage(@NotNull String message) {\n   Intrinsics.checkNotNullParameter(message, \"message\");\n   System.out.println(message);\n}\n```\n\n예시: 함수형 타입\n\n```js\nfun runBlock(block: ()-\u003eUnit) {\n    block()\n}\n\nfun main() {\n    runBlock { println(\"여기\") } // 출력: 여기\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 () -` Unit은 함수 유형을 나타내며 Unit은 해당 함수 유형이 의미 있는 값을 반환하지 않음을 나타냅니다.\n\n함수 유형을 지정할 때 Unit을 명시하는 것이 필수입니다.\n\n# Nothing\n\n```js\n//SOURCE CODE\npackage kotlin\n/**\n * Nothing에는 인스턴스가 없습니다. Nothing을 사용하여 \"존재하지 않는 값\"을 표현할 수 있습니다: 예를 들어,\n * 반환 유형이 Nothing인 함수의 경우, 이는 결코 반환하지 않음을 의미합니다 (항상 예외를 throw함).\n */\npublic class Nothing private constructor()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 아무 값이 없음을 나타내며 함수가 일반적인 방식으로 반환하지 않을 것을 나타냅니다.\n- 사용자가 정의한 Kotlin 유형을 포함한 모든 형식의 하위 유형입니다.\n- 예외를 throw하거나 무한 루프에 들어가기 때문에 결코 반환되지 않는 함수에서 사용됩니다.\n- Nothing의 인스턴스를 만들거나 어떤 클래스도 상속할 수 없습니다.\n- 반환 유형이 Nothing인 함수는 기본 반환 유형인 Unit조차 반환하지 않습니다.\n- Kotlin의 Nothing 반환 유형은 반환하지 않는다는 것을 명확히 하여 잠재적인 버그로부터 우리를 보호합니다. 반환 유형이 Nothing인 아무 함수가 호출되면 컴파일러는 이 함수 호출을 넘어가지 않고 접근할 수 없는 코드 경고를 알려 줍니다.\n\n예시\n\n```js\nfun fail(message: String): Nothing {\n    throw IllegalArgumentException(message)\n}\n\nfun main() {\n    // 이것은 예외를 throw하고 일반적으로 반환하지 않을 것입니다.\n    fail(\"에러 발생!\")\n    println(\"안녕\") // 컴파일러가 \"접근할 수 없는 코드\" 경고를 줍니다.\n}\n```\n\n```js\n// Decompile되었을 때, Nothing은 Java에서 Void가 됩니다\n// Void는 java.lang 패키지의 일부이며, void Java 원시 유형을 래핑하는 객체에 대한 참조 역할을 합니다. 생성할 수 없습니다.\n@NotNull\npublic static final Void fail(@NotNull String message) {\n   Intrinsics.checkNotNullParameter(message, \"message\");\n   throw (Throwable)(new IllegalArgumentException(message));\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소스 코드: 깃허브\n\n# 연락처:\n\n링크드인, 트위터\n\n코딩 즐기세요! ✌️","ogImage":{"url":"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png"},"coverImage":"/assets/img/2024-05-20-UnderstandingKotlinsAnyUnitNothing_0.png","tag":["Tech"],"readingTime":4},{"title":"친구야, Kotlin 20 - Android 프로젝트 이전 안내","description":"","date":"2024-05-20 17:39","slug":"2024-05-20-Kotlin20Androidprojectmigrationguide","content":"\n\n\n![Kotlin 2.0 Release](/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_0.png)\n\n코틀린은 처음 출시된 이후로 많은 여정을 거쳐왔습니다. 이제 새로운 이정표에 접어들고 있는데요—2.0 릴리스입니다. 이 글을 작성하는 시점에서 2.0.0-RC3 버전이 릴리스되었는데, 이는 거의 최종 버전에 가까운 버전입니다. 저는 코틀린 EAP의 구성원이었고, 내 프라이빗 안드로이드 프로젝트의 설정을 변경하여 코틀린 2.0에 적응하는 과정을 간단히 알려드리고 싶습니다.\n\n# K2 컴파일러\n\n이것은 새로운 코틀린 버전의 가장 큰 기능일 것입니다. JetBrains 팀은 2배 빠른 컴파일 시간을 약속하고 있습니다. 현실은 이 \"2배\"는 아마도 컴파일 작업의 합에만 해당할 것입니다. 실제 세계에서, Gradle은 몇 가지 작업을 병렬로 실행하여 이득 중 일부를 상쇄시키게 됩니다. 제 경험상 15–30% 정도의 향상이 되었다고 할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJetBrains 팀은 IntelliJ IDEA 기반 IDE의 경험을 크게 향상시킬 것이라고 말합니다. K2 모드로 이클립스는 프로젝트를 작성하면서 컴파일하며 맞춤법 검사, 코드 자동 완성 등을 제공합니다. 새로운 K2 모드로 작성 경험이 더욱 원활해질 것이라고 약속하지만, 현재 Alpha 단계이며 버그가 많습니다.\n\n## 이전 방법\n\n재미있는 사실: K2 컴파일러는 이전 코틀린 버전에서 gradle.properties 플래그와 함께 실험적 버전으로 사용할 수 있었습니다! 코틀린 2.0부터 K2 컴파일러가 기본 컴파일러로 설정되어 더 이상 아무것도 할 필요가 없습니다. 코틀린 버전을 2.0으로 업데이트하면 자동으로 활성화됨을 기억하세요.\n\n# .kotlin — 새로운 빌드 디렉토리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코틀린 2.0에서는 새로운 빌드 출력 디렉토리인 .kotlin이 소개되었습니다. 코틀린 1.8.20부터 코틀린 컴파일러는 일부 컴파일 데이터를 Gradle 디렉토리에 저장하기 시작했지만, 해당 디렉토리는 Gradle 데이터를 위해 예약되어 있습니다. 코틘린 2.0에서 팀은 Kotlin 컴파일 데이터를 위해 예약된 새로운 디렉토리인 .kotlin으로 마이그레이션하기로 결정했습니다.\n\n## 마이그레이션 방법\n\n이것이 새로운 빌드 디렉토리이므로 그 내용이 커밋에 나타나지 않도록하기 위해 .gitignore 파일에 추가해야 합니다:\n\n```js\n# Kotlin 2.0\n.kotlin/\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 디렉토리가 프로젝트에 적합하지 않다면, kotlin.project.persistent.dir gradle 속성을 사용하여 변경할 수 있습니다.\n\n# kotlinOptions 호출이 deprected되었습니다\n\n![이미지](/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_1.png)\n\n이전에는 JDK 버전을 설정하거나 일부 컴파일러 인수를 추가하기 위해 모든 KotlinCompile 작업을 설정해야 했고, 그 작업을 위해 kotlinOptions 개체에 액세스해야 했습니다. 그러나 Kotlin 2.0부터 이 접근 방식은 deprected되었으며, 이러한 설정을 수행할 수 있는 새 API가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이전 방법\n\ncompilerOptions를 소개해 드리겠습니다:\n\n![이미지](/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_2.png)\n\nGradle 규칙 플러그인용 버전은 여기 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_3.png\" /\u003e\n\n# Compose 컴파일러 버전\n\n2.0 버전 이전에는 Kotlin Compose 컴파일러 버전을 수동으로 제공해야 했습니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 코틀린 버전과 호환되어야 하므로 유지보수가 다소 귀찮았습니다. Compose 버전과 다르며 IDE에서 버전 업그레이드를 권장하지 않았습니다. 코틀린 버전을 업그레이드할 때마다 호환되는 Compose 컴파일러 버전을 구글에서 검색해야 했죠. 코틀린 2.0 버전에서 이 문제가 해결되었습니다.\n\n## 이주하는 방법\n\nCompose 컴파일러 버전이 코틀린 버전과 강하게 결합되어 있기 때문에, 코틀린 버전과 함께 Compose 컴파일러 버전도 받아서 더는 걱정하지 않을까요? 구글과 JetBrains가 이 결론에 도달했고, Kotlin 2.0 작업 중에 이를 해결하고 JetBrains가 Compose 컴파일러를 쉽게 제공할 수 있도록 JetBrains 리포지토리로 이동하였습니다. 이제 여러분을 위해 모든 것을 설정해 줄 새로운 Gradle 플러그인을 소개할게요:\n\n```js\n[plugins]\nkotlin-compose-compiler = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCompose 모듈에 플러그인을 적용하세요:\n\n![image](/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_5.png)\n\n그리고 끝입니다! 이 플러그인은 현재 사용 중인 Kotlin 버전을 기반으로 Compose 컴파일러 버전을 설정해 줍니다. 또한 Compose 설정을 위한 새로운 설정 블록을 도입했습니다:\n\n![image](/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 Gradle 관례 플러그인용 버전도 있습니다:\n\n```js\n[라이브러리]\n# ComposeCompilerGradlePluginExtension 클래스에 액세스하려면 gradle 관례 모듈에 구현합니다\nplgn-kotlin-compose-compiler = { module = \"org.jetbrains.kotlin:compose-compiler-gradle-plugin\", version.ref = \"kotlin\" }\n```\n\n\u003cimg src=\"/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_7.png\" /\u003e\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지 프로젝트 설정에 변경된 내용이 이것뿐입니다. 많이 변경된 것 같지는 않지만 대부분의 변경 사항은 백그라운드에서 일어났습니다. 앞으로 코틀린 언어 개발자들이 제공할 기능이 어떤 것인지 기대해 봅시다 (명시적 백킹 필드는 이미 실험적입니다🤞).\n\n만약 새로운 산출물을 확인하고 Android 프로젝트 설정에서 더 많은 변경 사항을 발견했다면 자유롭게 코멘트해 주세요. 새로운 내용이 이곳에 언급할 가치가 있는 것으로 생각된다면 기사를 업데이트하겠습니다.","ogImage":{"url":"/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_0.png"},"coverImage":"/assets/img/2024-05-20-Kotlin20Androidprojectmigrationguide_0.png","tag":["Tech"],"readingTime":4},{"title":"당신의 안드로이드 앱에 다국어 지원다국어 추가하기","description":"","date":"2024-05-20 17:37","slug":"2024-05-20-AddMultilingualsupportMultipleLanguagestoyourAndroidApp","content":"\n\n\n![다국어 지원 이미지](/assets/img/2024-05-20-AddMultilingualsupportMultipleLanguagestoyourAndroidApp_0.png)\n\n여러 언어를 지원하는 것은 애플리케이션을 확장하고 대중에 도달하는 데 중요합니다. 인도의 약 25%와 유럽의 64%의 작업 성인 인구가 다국어를 구사하며 미국도 다국어 구사자가 약 194% 증가했습니다. (출처)\n\n또한, 소비자의 65% 이상이 선호하는 언어로 콘텐츠를 소비하는 것으로 나타나므로 이는 Amazon, WhatsApp, Facebook 등 대부분의 선도적인 애플리케이션에서 이미 제공되는 중요한 기능으로 고려되어야 합니다.\n\n그러니 다국어 세계를 위해 함께 만들어봅시다!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 문자열 리소스를 체계화하세요.\n\n코드에서 하드코딩된 문자열 값을 사용하지 마세요.\n\n올바르게\n\n```js\nText(stringResources(R.string.follow_me))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUsing strings.xml, we will have a common place for all our string resources and we can then support multiple languages by adding more strings.xml files.\n\n## 2. Add Multiple Languages\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미 모든 문자열 리소스를 저장할 수 있는 곳이 있습니다. 이제 모든 문자열 리소스를 다른 지원되는 언어로 번역하기만 하면 됩니다.\n\n```js\n//힌디어 문자열 리소스 파일 예제\n\u003cresources\u003e\n    \u003cstring name=\"subscribe_to_sagar_malhotra\"\u003eसागर मल्होत्रा की सदस्यता लें\u003c/string\u003e\n    \u003cstring name=\"language\"\u003eहिन्दी\u003c/string\u003e\n\u003c/resources\u003e\n```\n\n이 작업을 수행하기 위해 \"AndroidLocalize\"라는 Android Studio 플러그인을 사용하고 있습니다.\n\n![이미지](/assets/img/2024-05-20-AddMultilingualsupportMultipleLanguagestoyourAndroidApp_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 언어 변경 트리거\n\n어떤 UI를 사용하더라도(여기서는 ExposedDropDownMenu), 애플리케이션의 로캘을 변경했음을 OS에 알리기 위해 onClick 이벤트를 트리거해야 합니다. 이렇게 하면 OS도 특정 언어의 strings.xml 파일로 전환할 수 있습니다.\n\n```js\nonClick = {\n    // 사용자가 선택한 로캘에 따라 앱 로캘 설정\n    AppCompatDelegate.setApplicationLocales(\n        LocaleListCompat.forLanguageTags(\n            \"hi\"// 힌디어를 위한 ISO 코드\n        )\n    )\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n귀하는 해당 언어의 ISO-639 코드를 전달하여 OS에 언어 환경 설정 변경을 알릴 필요가 있습니다.\n\n## 3.1 문제 해결\n\n현재 이 방법은 AppCompatActivity에만 작동하므로 귀하의 애플리케이션에 맞지 않을 수도 있습니다. 특정 Activity에 ComponentActivity를 확장하고 있는지 확인하십시오.\n\n```js\nclass MainActivity : AppCompatActivity() { ... }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAppCompatActivity를 확장한 후에도, 특정 활동을 위해 지원되는 테마를 변경해야 합니다.\n\n```js\n\u003cstyle name=\"Theme.MultilingualApp\" parent=\"Theme.AppCompat.Light.NoActionBar\" /\u003e\n```\n\n## 4. 로케일 설정 저장\n\nAndroid 12 이하 버전에서는 선택한 언어 환경 값을 수동으로 저장하거나 AndroidX가 로케일 환경을 스스로 처리하도록 AndroidManifest에서 이 구성을 사용해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n\u003cservice//Inside application tag\n    android:name=\"androidx.appcompat.app.AppLocalesMetadataHolderService\"\n    android:enabled=\"false\"\n    android:exported=\"false\"\u003e\n    \u003cmeta-data\n        android:name=\"autoStoreLocales\"\n        android:value=\"true\" /\u003e\n\u003c/service\u003e\n```\n\n## 5. Android OS Per-App Language Preferences\n\nIn Android 13 and above, the Android OS also supports changing the Per-App Language preference from system settings.\n\n\u003cimg src=\"/assets/img/2024-05-20-AddMultilingualsupportMultipleLanguagestoyourAndroidApp_2.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n귀하의 응용 프로그램이 여러 언어도 지원한다는 것을 운영 체계에 알리려면 AndroidManifest 파일에 필요한 구성을 추가하십시오.\n\n```js\n// application 태그에 다음을 추가하세요\nandroid:localeConfig=\"@xml/locale_config\"\n```\n\nlocal_config.xml 파일에 모든 지원하는 언어를 정의하세요.\n\n```js\n\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e\n\u003clocale-config xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e\n    \u003clocale android:name=\"en\" /\u003e\n    \u003clocale android:name=\"gu\" /\u003e\n    \u003clocale android:name=\"hi\" /\u003e\n    \u003clocale android:name=\"ar-AE\" /\u003e\n\u003c/locale-config\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 앱에서 시스템 설정에서 언어를 변경하는 것도 지원하게 됩니다.\n\n## 6. 활동 재생성 피하기\n\n앱 언어를 변경할 때 활동이 재생성되는 것을 눈치챌 수 있습니다. 이는 로캘을 변경하는 것도 구성 변경의 한 종류이기 때문에 기본적으로 활동이 구성 변경이 발생할 때마다 재생성됩니다.\n\nAndroidManifest를 사용하여 이 기본 동작을 방지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n// 특정 활동 태그에 다음을 추가하십시오\nandroid:configChanges=\"layoutDirection|locale\"\n\n\n## 비디오:\n\n이 기능이 보다 많은 관객에 도움이 되기를 바라며, 더 많은 유용한 콘텐츠를 위해 저를 팔로우하시기 바랍니다.\n","ogImage":{"url":"/assets/img/2024-05-20-AddMultilingualsupportMultipleLanguagestoyourAndroidApp_0.png"},"coverImage":"/assets/img/2024-05-20-AddMultilingualsupportMultipleLanguagestoyourAndroidApp_0.png","tag":["Tech"],"readingTime":4},{"title":"디자인 시스템 워크플로우를 Kelp 플러그인으로 Android Studio에서 강화해보세요 ","description":"","date":"2024-05-20 17:35","slug":"2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio","content":"\n\n\n![Kelp Plugin for Android Studio](/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_0.png)\n\n안녕하세요! 안드로이드 개발자 여러분! 저희는 항상 업무 흐름을 최적화하고 생산성을 향상시킬 도구를 찾고 있어요. 그리고 여기에 Kelp이 등장합니다. 강력한 안드로이드 스튜디오 플러그인인 Kelp은 사용자 정의 디자인 시스템을 안드로이드 스튜디오에 원활하게 통합하여 UI 개발을 빠르고 쉽게 만들어주는 다양한 기능을 제공해요.\n\n## 왜 Kelp을 사용해야 할까요? 🤔\n\nKelp은 안드로이드 스튜디오 내에서 직관적이고 자동화된 지원을 통해 사용자 정의 디자인 시스템 사용 시 발생하는 일반적인 문제점을 해결해요. 아이콘, 색상 또는 구성 요소 함수를 다루더라도 Kelp은 가시성과 접근성을 향상시켜 주어요. 그렇게 함으로써 여러분은 뛰어난 앱을 만드는 데 집중할 수 있게 되어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 주요 기능\n\n## 🔧 컴포넌트 기능용 사용자 정의 아이콘\n\nKelp를 통해 디자인 시스템 컴포넌트 기능에 사용자 정의 아이콘을 설정할 수 있습니다. 이 아이콘은 코드 완성 드롭다운에 표시되며, R.drawable 리소스가 표시되는 방식과 유사합니다. 이 시각적 지원을 통해 프로젝트 전반에 걸쳐 컴포넌트를 식별하고 일관되게 사용하는 것이 더 쉬워집니다.\n\n![Kelp 플러그인을 사용하여 디자인 시스템 작업 흐름 향상](/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 🎨 디자인 시스템 아이콘\n\nKelp를 사용하면 디자인 시스템 아이콘을 코드 완성 드롭다운 및 거터에서 네이티브 안드로이드 drawable 리소스처럼 렌더링할 수 있습니다. 이 기능을 통해 쉽게 적절한 아이콘을 찾아 전환 없이 바로 사용할 수 있습니다.\n\n![Kelp Plugin](/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_2.png)\n\n## 🌈 색상 미리보기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKelp는 코드 완성 드롭다운 및 거터에서 색상 미리보기를 통해 디자인 시스템의 색상 팔레트를 살아있게 만듭니다. 이 기능은 기본 R.color 리소스를 반영하여 올바른 색상을 적용하는 프로세스를 간단하게하는 즉각적인 시각 참조를 제공합니다.\n\n![Kelp Plugin](/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_3.png)\n\n## 📱 데모 앱 통합\n\n디자인 시스템 구성 요소를 쇼케이스하는 데모 앱 설치 및 탐색이 이제 더욱 간편해졌습니다. Kelp는 APK 설치를 용이하게 하고 코드에서 직접 특정 구성 요소 페이지를 열 수 있는 의도 작업을 제공하여 개발 프로세스를 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_4.png\" /\u003e\n\n## 🖼️ KDoc Image Rendering\n\nKelp의 뛰어난 기능 중 하나는 Android Studio의 현재 제한 사항에도 불구하고 KDoc에서 이미지를 렌더링할 수 있는 능력입니다. 이 기능은 컴포넌트에 대한 내용을 인라인 이미지 참조를 허용하여 문서 작성을 향상시켜주어 더 나은 이해와 활용을 돕습니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_5.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ⌨️ 라이브 템플릿\n\n맞춤 설정 가능한 라이브 템플릿으로 코딩 속도를 높이세요. 이러한 템플릿은 사용자의 디자인 시스템 코드에서 자주 사용하는 코드 조각을 포함하도록 맞춤 설정할 수 있으며, 개발 속도를 더 높이기 위해 코드 완성 팝업을 자동으로 트리거합니다.\n\n![image](/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_6.png)\n\n## 🧩 사용자 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n켈프의 진정한 힘은 구성 가능성에 있습니다. config.json 파일을 수정하여 플러그인을 프로젝트의 고유한 요구 사항에 맞게 조정할 수 있습니다. 이 JSON 기반 구성은 함수 접두사부터 색상 및 아이콘 렌더링에 이르기까지 세부적인 사용자 정의를 지원합니다.\n\n게다가, 이것은 파일이기 때문에 Git에 저장하여 팀 전체에서 공유할 수 있어 일관성을 유지하고 각 사용자가 Android Studio의 설정 UI를 수동으로 구성할 필요성을 제거할 수 있습니다.\n\n다음은 주석이 포함된 전체 구성 파일입니다:\n\n```js\n{\n  // 이러한 기능 중 일부를 비활성화하려면\n  // json 파일에 해당 섹션을 포함하지 않기만 하면 됩니다.\n\n  // 디자인 시스템 구성 요소의 기본 아이콘을 사용자 정의 아이콘으로 교체\n  // 코드 완성에서 사용자 정의 아이콘이 표시됨\n  // 사용자 정의 아이콘은\n  // 1. svg여야 함\n  // 2. 크기 - 40x40\n  // 3. 여기에 위치해야 함: /.idea/kelp/dsComponentFunIcon.svg\n  // 4. 선택 사항으로 다크 버전 추가 가능:\n  // /.idea/kelp/dsComponentFunIcon_dark.svg\n  \"componentFunHighlighting\": {\n    // 사용자 정의 아이콘이이 패키지의 모든 함수에 추가됨\n    \"functionFqnPrefix\": \"com.your.designsystem.package.components.\",\n    \"functionSimpleNamePrefix\": \"Ds\" // 선택 사항\n  },\n\n  // 코드 완성 및 구두에 디자인 시스템 색상 표시\n  // 일반적인 안드로이드 자원과 비슷합니다.\n  \"colorPreview\": {\n    \"codeCompletionEnabled\": true,\n    \"gutterEnabled\": true,\n    // 선택 사항, 열거형 클래스에서 색상 토큰\n    \"enumColorTokensEnabled\": true,\n  },\n  \n  // 코드 완성 및 구두에 디자인 시스템 아이콘 렌더링\n  // 일반적인 안드로이드 자원과 비슷합니다.\n  \"iconsRendering\": {\n    \"codeCompletionEnabled\": true,\n    \"gutterEnabled\": true,\n    // 아이콘을 반환하고\n    // 이름이 아이콘이라는 많은 속성을 가진 클래스\n    \"containerClassName\": \"com.your.designsystem.package.DsIcons\",\n    \n    // 선택 사항: 아이콘이 아닌 속성을 필터링\n    \"propertyNameFilter\": {\n      // 선택 사항:이 접두사가있는 속성만\n      // 아이콘으로 간주\n      \"startsWith\": [\"ic_\"],\n      // 선택 사항:이 접두사가있는 모든 속성은 건너뜀\n      \"doesNotStartWith\": [\"allIconsAsList\", \"otherProperty\"]\n    },\n    \n    // 속성 이름을 drawable 자원 이름으로 매핑\n    \"propertyToResourceMapper\": {\n      \"addPrefix\": \"ic_\", // 선택 사항\n      \"convertToSnakeCase\": true // 선택 사항; 예: \"AddAccount\" -\u003e \"add_account\"\n    }\n  },\n  \n  // 의도 작업을 통해 데모 앱에서 구성 요소 페이지 열기\n  \"demoApp\": {\n    // 선택 사항: 의도 작업의 사용자 지정 이름\n    \"intentionName\": \"🚀 Open in MY CUSTOM design system demo app\",\n    \"functionFqnPrefix\": \"com.your.designsystem.package.components.\",\n    \"functionSimpleNamePrefix\": \"Ds\", // 선택 사항\n    // 데모 앱의 패키지 이름\n    \"appPackageName\": \"com.your.designsystem.package.demo\",\n    // 데모 앱에서 구성 요소 페이지를 열기 위해 사용되는 딥 링크.\n    // DS_COMPONENT_FQN_DEEPLINK_PLACEHOLDER가로 교체됩니다\n    // 완전히 정규화 된 이름, 예 : com.your.designsystem.package.components.Badge\n    \"componentDeeplink\": \"yourscheme://component/DS_COMPONENT_FQN_DEEPLINK_PLACEHOLDER\",\n    \n    // 선택 사항\n    // 데모 앱 (쇼케이스 앱)의 apk 파일을 설치 (미설치되어 있으면)합니다.\n    \n    // 데모 앱 apk는 여기에 있어야합니다.\n    // 이 이름 :/.idea/kelp/demoApp-VERSION_NAME.apk\n    // 예 :/.idea/kelp/demoApp-0.12.0.apk\n    // 플러그인은 최신 버전을 얻습니다.\n    // apk 파일 이름에서 (예 : 0.12.0).\n    // 앱이 설치되어 있지 않거나 설치되어 있지만 하위 버전인 경우\n    // 플러그인은 장치에 apk를 설치합니다.\n    \"apkInstallation\": true\n  },\n  \n  // IDE에 라이브 템플릿 설치\n  // \"MaterialTheme.colors.\"와 같은\n  // 자주 사용하는 코드 작성에 유용합니다.\n  // 완성 후 코드 완성을 엽니다\n  // $CODE_COMPLETION$ 자리에, 더 많은 노력을 절약합니다.\n  \"liveTemplates\": [\n    {\n      \"abbreviation\": \"dt\",\n      \"text\": \"com.your.designsystem.DsTheme.$CODE_COMPLETION$\",\n      \"description\": \"\\\"DsTheme.\\\" 쓰기\"\n    },\n    {\n      \"abbreviation\": \"dtc\",\n      \"text\": \"com.your.designsystem.DsTheme.colors.$CODE_COMPLETION$\",\n      \"description\": \"\\\"DsTheme.colors\\\" 쓰기\"\n    },\n    {\n      \"abbreviation\": \"dtt\",\n      \"text\": \"com.your.designsystem.DsTheme.typography.$CODE_COMPLETION$\",\n      \"description\": \"\\\"DsTheme.typography\\\" 쓰기\"\n    },\n    {\n      \"abbreviation\": \"dtt\",\n      \"text\": \"com.your.designsystem.DsTheme.icons.$CODE_COMPLETION$\",\n      \"description\": \"\\\"DsTheme.icons\\\" 쓰기\"\n    }\n  ]\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 🛠️ 설치\n\nKelp를 사용하여 시작하려면:\n\n- Android Studio Koala | 2024.1.1 Canary 3 또는 그 이상 버전을 사용하는지 확인합니다.\n- Kelp GitHub 저장소에서 최신 릴리스를 다운로드하여 설정/환경설정에서 수동으로 설치합니다. ` 플러그인 ` ⚙️ ` 디스크에서 플러그인 설치`...\n- 원하는 경우, 모든 팀원이 플러그인을 사용하고 있는지 확실하게 하기 위해 externalDependencies.xml 파일을 생성하여 팀에 알립니다.\n- 프로젝트에 Kelp를 구성하기 위해 config.json 파일을 생성하고 필요에 따라 사용자 정의합니다.\n\n## 🚀 개발 효율성을 높이세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKelp은 안드로이드 스튜디오 내에서 디자인 시스템과 상호 작용하는 방식을 변화시킵니다. 시각적 단서와 디자인 리소스에 간편하게 접근할 수 있도록 IDE에 직접 통합함으로써 추측을 제거하고 적절한 구성 요소를 찾는 데 소요되는 시간을 줄입니다.\n\nKelp를 사용하면 일관성을 보장하고 코드 가독성을 향상시키며 궁극적으로 더 나은 제품을 빠르게 제공할 수 있습니다. 지금 Kelp를 개발 워크플로에 통합하고 그 차이를 경험해보세요.\n\n더 자세한 안내와 예제는 공식 Kelp 저장소를 방문해주세요.\n\nKelp의 잠재력에 흥분하신다면 GitHub에서 ⭐️을 부탁드립니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해 주세요.","ogImage":{"url":"/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_0.png"},"coverImage":"/assets/img/2024-05-20-EnhanceYourDesignSystemWorkflowwithKelpPluginforAndroidStudio_0.png","tag":["Tech"],"readingTime":7},{"title":"매뉴얼에서 선언적 방식으로 빠르게 성장하는 회사에서의 Terraform과 IaC","description":"","date":"2024-05-20 17:31","slug":"2024-05-20-FrommanualtodeclarativeTerraformandIaCinafastgrowingcompany","content":"\n\n우리의 여정은 수동으로 인프라 리소스를 프로비저닝하고 유지하는 것에서 완전히 선언적 인프라 코드(IaC)로 이동하는 것이었습니다.\n\n작성자: 워커블의 시니어 사이트 신뢰성 엔지니어 테오도어 커키리스, 워커블의 시니어 사이트 신뢰성 엔지니어 콘스탄티노스 루소프로스\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*VLL84MCp0Wo4Ec3zwuoVvA.gif)\n\n# 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 Workable에서의 인프라스트럭처 코드 (IaC) 여정을 논의할 것입니다. 이미 IaC에 익숙하신 분들 중에서 Terraform을 선호하는 도구로 채택한 분들은 이미 코드를 DRY하게, 간단하고 유지 보수가 쉽도록 구성하는 데 오는 도전과 불편함을 이해하고 계실 겁니다. (다름이 아니라 버그나 오타 하나로 생산 리소스가 중대한 문제를 일으킬 수 있습니다.) 동시에 확장 가능하고 유연하며 변화하는 빠르게 성장하는 회사의 요구 사항을 충족하기 위해 확장 가능하고 유연하며 확장 가능하게 만들기 위한 도구로 Terraform을 채택한 고객이 이미 이러한 도전과 불편함을 이해하고 있을 겁니다.\n\n이 기사는 여러 해 동안의 IaC의 발전을 제공하지만, 만약 귀하가 귀사의 IaC를 구조화하는 방법에 대한 제안을 찾는 중이라면 마지막 섹션으로 건너뛰어도 됩니다. 해당 섹션에서는 현재 아키텍처를 설명하며, DRY(반복하지 마세요), 유연하며 우리 팀이 지속적으로 성장하는 인프라를 효과적으로 관리하는 데 효율적이고 확신을 주는 아키텍처로 믿고 있습니다.\n\nWorkable의 엔지니어링 발전 일부를 간단히 소개하기 위해 언급되었지만, 이것은 완전한 여정은 아닙니다. 더 알고 싶으시다면 우리의 엔지니어링 부사장들이 Voxxed Days에서 하는 훌륭한 발표를 시청해 보세요.\n\n2012년 Workable이 시작됐을 때, 아주 소수의 엔지니어 팀은 최초 세대에서 작업했습니다. 이는 매우 적은 인프라 리소스를 요구하는 모놀리스 였습니다. 우리는 주로 PostgreSQL을 주요 지속성 계층으로, Solr를 텍스트 검색, Redis를 분산 캐싱으로 사용했습니다. 코드는 Heroku에 배포되었습니다. Heroku는 통합된 데이터 서비스를 제공하고 현대 어플리케이션을 배포하고 실행하기 위한 강력한 생태계를 제공하는 컨테이너 기반 플랫폼 서비스였습니다. 이를 통해 개발자들은 생산용 용량에서 인프라 관리의 복잡성 없이도 응용 프로그램 로직에 집중할 수 있었습니다.\n\n제품은 연도가 흘러가면서 계속 성장했고, 2016년으로 빨리 앞으로 가면 이미 엔지니어링 팀은 사용자 경험을 향상시키는 보다 다양한 기능을 제공하기 위해 몇 개의 마이크로서비스를 도입했습니다. 그러나 이러한 마이크로서비스는 모놀리스의 스택과 도메인에 잘 들어맞지 않았으며 더 많은 마이크로서비스가 추가될 것이었습니다. 코드는 여전히 Heroku에 배포되었지만 제품은 상당히 커졌습니다. 우리는 이미 외부 제공업체의 서비스 (클라우드 저장소, 데이터베이스 등)를 사용하기 시작했고, 인프라 유지 및 모니터링은 엔지니어링 팀 간의 공동 책임으로 남아 있었습니다. 이때 SRE 팀이 형성되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 처음에 인프라를 관리하고 어떻게 관리해야 할지 평가하는 동안 모든 것을 수동으로 프로비저닝했어요. 회사로서 성장하던 2017년, 우리는 인프라를 프로비저닝, 구성 및 관리하는 더 효율적인 방법이 필요한 지점에 이르렀어요. 반복적이고 복잡해지며 실수하기 쉬운 수동 작업에서 벗어나 우리의 인프라 구성을 단순화하고 표준화하며 최소한의 노력으로 확장할 수 있는 프로세스가 필요했어요.\n\n이것이 테라폼과 함께 하는 이야기: 우리 회사와 함께 성장하고 변화하는 인프라스트럭처를 정의하는 여정입니다.\n\n# 1G IaC — 테라폼 도입\n\n인프라스트럭처 코드 (IaC) 도구는 설정 파일을 사용하여 인프라를 관리할 수 있게 해줍니다. 이러한 도구들은 자원 구성을 정의하여 버전 관리, 재사용, 공유가 가능하게 함으로써 안전하고 일관되며 반복 가능한 방식으로 인프라를 구축, 수정 및 유지할 수 있도록 도와줍니다. 테라폼은 이러한 도구 중 하나로 HashiCorp에서 개발했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테라폼은 인간이 읽기 쉬운 구성 파일을 사용하여 리소스와 인프라를 정의할 수 있게 해줍니다. 이는 HashiCorp가 개발한 선언형 언어인 HCL(HashiCorp Configuration Language)을 사용합니다. 선언형이란 인프라를 위한 원하는 최종 상태를 설명하는 것을 의미하며, 잘 정의된 단계별 지침이 필요한 절차적 프로그래밍 언어와는 다릅니다(예: Ansible은 IaC 영역에서 사용됩니다).\n\n또한 테라폼은 인프라의 수명 주기를 관리하도록 허용하여 상태 파일을 유지함으로써 인프라의 원하는 최종 상태가 정의된 구성과 일치하는지 확인하고 변경 사항을 식별하고 적용합니다. 또한 리소스 간의 종속성을 결정하고 올바른 순서로 생성하거나 제거할 수 있습니다.\n\n초기 단계에서 우리의 인프라 요구 사항은 매우 복잡하지 않았으며 단일 제공업체에 한정되었습니다. 결과적으로, 우리의 테라폼 코드의 디렉토리 구조는 소규모에서 중간 복잡성의 인프라에 대한 당시 표준을 따르고 있었습니다:\n\n```js\ninfrastructure\n└── aws\n    ├── production\n    │   ├── eu-west-1\n    │   │   ├── ec2\n    │   │   ├── lambda\n    │   │   └── ...\n    │   ├── global\n    │   │   └── iam\n    │   └── us-east-1\n    │       ├── ec2\n    │       ├── rds\n    │       └── ...\n    └── staging\n        └── ...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 리소스를 관리하는 데는 문제가 없었고 깔끔하며 어떤 리소스가 어디에 설정되었는지 쉽게 추적할 수 있었으며, 프로덕션 및 스테이징 환경을 완전히 격리시킵니다. 그러나 마이크로서비스 아키텍처를 채택하고 개발, 테스트 및 프로덕션용 여러 환경으로 확장하면 다음과 같이 복잡해졌습니다:\n\n- 모듈을 사용하지 않았기 때문에 코드가 DRY(반복이 줄어든 개발) 또는 표준화되지 않았습니다.\n- 동일한 AWS 리소스의 인스턴스가 한 파일에 도입될수록 구성 파일이 더욱 장황해졌습니다:\n  - 업데이트/검토하는 데 더 많은 시간과 노력이 필요했습니다.\n  - Terraform이 계획을 더 많이 수행하고 적용하는 데 시간이 더 오래 걸렸습니다.\n\n![FrommanualtodeclarativeTerraformandIaCinafastgrowingcompany_0.png](/assets/img/2024-05-20-FrommanualtodeclarativeTerraformandIaCinafastgrowingcompany_0.png)\n\n우리는 각각이 있는 상당수의 마이크로서비스의 인프라를 관리해야 했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다른 리소스 세트가 필요합니다.\n- 약간 다른 구성으로 여러 환경에 배포됩니다.\n\n그리고 비즈니스 로직을 추가하여 조건부로 인프라를 생성하고 구성하는 코드를 넣으세요. 예를 들어:\n\n- 마이크로서비스는 프로덕션을 위해 전용 리소스가 필요하지만 개발 또는 테스트 환경에서는 공유 리소스를 사용할 수 있습니다. 예: 클라우드 저장소\n- 개발 및 테스트 환경을 위한 인프라는 꼭 고가용성이 필요 없습니다.\n\n그러나 디렉터리 구조가 마이크로서비스 아키텍처를 반영하지 않아서 모든 필요한 리소스를 하나의 마이크로서비스에 번들로 제공하지 못했습니다. 이는 모두 동시에 프로비저닝하거나 폐기하는 것이 어려워져서 임시로 사용하지 않는 리소스를 남길 수 있는 가능성이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상기 내용 외에도 2018년에는 Heroku를 포기하고 배포 플랫폼으로 Kubernetes를 도입하기로 결정했습니다. Heroku가 우수한 선택이었지만, 회사가 성장하며 새로운 리소스 수요가 증가함에 따라 비용 부담이 커졌습니다. 또한 필요한 유연성과 자세한 모니터링 기능이 부족했습니다. 이 결정으로 Terraform을 사용하여 관리해야 할 인프라의 크기와 복잡성이 상당히 증가했습니다. 그 당시 우리는 간단한 구조가 확장 가능하지 않음을 깨닫고 IaC 아키텍처를 다시 고려해야 한다는 것을 알았습니다.\n\nTerraform은 인프라를 관리하는 데 탁월한 도구이지만, 2018년 당시 제한이 있었습니다. 비즈니스 로직을 구현하는 것이 어려웠고, 설정 파일을 공유하는 것이 간단하지 않았으며, \"환경별 애플리케이션\"을 지원하기 위해 디렉터리 구조를 변경하는 것은 네이티브로 처리할 수 없었습니다. Terraform 모듈을 사용하더라도 각 모듈과 환경마다 상당한 양의 코드를 수동으로 중복해야 했기 때문에 우리의 설정은 DRY 원칙을 따르지 못하며 리소스를 묶어 함께 처리하는 문제는 해결되지 않았습니다.\n\n지금은 CI/CD에 대해 생각하고 있을 수 있습니다. 당신의 의견을 이해합니다만, 아직 그 단계에는 이르지 못했습니다.\n\n목표는 리소스 기반 구조에서 마이크로서비스 기반 구조로 전환하는 것이었지만, Terraform은 IaC를 재설계하는 데 필요한 주요 기능이 부족했습니다. 그때 Terragrunt가 등장했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2G IaC — Terragrunt으로 구조화된 Terraform 코드\n\nTerragrunt은 Gruntwork에서 개발한 Terraform 래퍼로, 설정을 DRY 유지하고 여러 Terraform 모듈을 사용하며 원격 상태를 관리하는 추가 도구를 제공합니다.\n\nTerragrunt을 사용하면 다음과 같은 작업을 수행할 수 있습니다:\n\n- Terraform 코드를 DRY 상태로 유지\n- 중복된 백엔드 코드 삭제\n- 상위 디렉토리에서 설정 상속\n- 한 번에 여러 모듈 적용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 통해 우리는 원하는 마이크로서비스 블루프린트를 만들고 IaC를 재구성할 수 있게 되었습니다.\n\n이 단계에서는 코드의 디렉토리 구조를 재설계하여 우리의 인프라 구조에 맞추었습니다. 클라우드 공급업체나 서비스 제공자에 중립적인 디자인으로 조직화되어 있으며, 스코프의 명확한 격리를 가지고 있습니다.\n\n- 조직, 예: 스테이징, 프로덕션 등\n- 환경, 예: 테스트, 개발, 프로덕션 등\n- 마이크로서비스\n\nIaC를 재구성하고 보다 일관성 있게 만들기로 결정했기 때문에, 우리는 리소스에 대한 새로운 일관된 명명 규칙을 수립해야 했습니다. 이 명명 규칙은 Terraform 리소스와 실제 클라우드 인프라에 적용될 것이며, 각 환경을 최상위 추상화 수준으로 보고 리소스가 다른 환경 간에 공유되지 않을 것을 고려하여 Terraform 리소스 이름, 변수 이름 및 리소스 태그에 대한 명명 규칙 제안을 마련했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 모듈\n\n명확한 디렉토리 구조와 명명 규칙을 가지고 인프라를 모듈로 분할하여 아키텍처를 기반으로 인프라를 기술하는 것이 목표였습니다. Terraform의 최상의 관행을 따라, 각 마이크로서비스를 위한 리소스를 번들로 제공하고 조건부 프로비저닝 및 구성을 위한 비즈니스 로직을 통합하기 위해 재사용 가능한 모듈을 만들었습니다.\n\n최종적으로, 디렉토리 구조는 다음과 같이 보이게 되었습니다:\n\n\nmodules/\n├── README.md\n└── organization\n    └── infrastructure\n        └── environments\n            ├── gke\n            │   ├── firewall.tf\n            │   ├── iam.tf\n            │   ├── main.tf\n            │   ├── nodepools.tf\n            │   ├── providers.tf\n            │   ├── remote_state.tf\n            │   └── variables.tf\n            ├── microservice1\n            │   ├── README.md\n            │   ├── iam.tf\n            │   ├── mongo.tf\n            │   ├── providers.tf\n            │   ├── s3.tf\n            │   └── variables.tf\n            └── microservice2\n                ├── README.md\n                ├── cloudfront.tf\n                ├── iam.tf\n                ├── iam_policy.json\n                ├── postgres.tf\n                ├── providers.tf\n                ├── remote_state.tf\n                ├── s3.tf\n                ├── s3_policy.json\n                └── variables.tf\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테라폼 모듈로 전환함으로써 필요한 추상화를 달성할 수 있었습니다. 그러나 각 모듈을 인스턴스화하고 입력 변수에 값을 설정하고 출력 변수를 정의하며, 공급자를 구성하고 원격 상태를 제공하는 코드는 여전히 많은 유지 보수 부담을 야기했습니다.\n\n## 라이브\n\nTerragrunt를 사용하여 코드의 추상화 수준을 추가하고 서로 다른 환경에서 코드의 버전화된, 변경 불가능한 artifact를 제공할 수 있었습니다. 이 도구는 일반적인 테라폼 코드에 존재하는 원격 테라폼 구성을 가져올 수 있으며, 환경 간에 다를 수 있는 값에 대해 입력 값을 요구합니다.\n\n별도의 저장소에서 비슷한 디렉토리 구조를 따라 우리의 모든 환경에 대한 라이브 코드를 정의했습니다. 이제 라이브 코드는 단 3개의 파일로 이루어져 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- [필수] 코드의 소스를 지정하는 Terragrunt .hcl 파일\n- [필수] 리소스를 구성하는 데 필요한 키/값 쌍만 포함해야 하는 Terraform .auto.tfvars 파일\n- [선택 사항] Terraform 비밀 .auto.tfvars 파일은 구성에 비밀을 유지하려는 경우에만 사용됩니다. 비밀을 안전하게 유지하기 위해 git-crypt를 사용하여 git 저장소에서 파일의 투명한 암호화 및 해독을 가능하게 합니다.\n\n이 방법으로 모듈은 조직 및 환경에 구애받지 않으며, 구성 코드는 다른 환경 및 조직 간에 각 마이크로서비스마다 다를 것입니다. 최종적으로 우리의 라이브 구성은 다음과 같았습니다:\n\nlive/\n├── production\n│   ├── org_config.auto.tfvars\n│   ├── production1\n│   │   ├── env_config.auto.tfvars\n│   │   ├── gke\n│   │   │   ├── terragrunt.hcl\n│   │   │   ├── variables.auto.tfvars\n|   |   |   └── secrets.auto.tfvars\n│   │   ├── microservice1\n│   │   │   ├── terragrunt.hcl\n│   │   │   └── variables.auto.tfvars\n│   │   └── microservice2\n│   │       ├── terragrunt.hcl\n│   │       └── variables.auto.tfvars\n│   └── production2\n│       ├── env_config.auto.tfvars\n│       ├── gke\n│       │   ├── terragrunt.hcl\n│       │   ├── variables.auto.tfvars\n|       |   └── secrets.auto.tfvars\n│       ├── microservice1\n│       │   ├── terragrunt.hcl\n│       │   └── variables.auto.tfvars\n│       └── microservice2\n│           ├── terragrunt.hcl\n│           └── variables.auto.tfvars\n└── staging\n    ├── dev\n    │   ├── env_config.auto.tfvars\n    │   ├── gke\n    │   │   ├── terragrunt.hcl\n    │   │   ├── variables.auto.tfvars\n    |   |   └── secrets.auto.tfvars\n    │   ├── microservice1\n    │   │   ├── terragrunt.hcl\n    │   │   └── variables.auto.tfvars\n    │   └── microservice2\n    │       ├── terragrunt.hcl\n    │       └── variables.auto.tfvars\n    ├── org_config.auto.tfvars\n    └── qa\n        ├── env_config.auto.tfvars\n        ├── gke\n        │   ├── terragrunt.hcl\n        │   ├── variables.auto.tfvars\n        |   └── secrets.auto.tfvars\n        ├── microservice1\n        │   ├── terragrunt.hcl\n        │   └── variables.auto.tfvars\n        └── microservice2\n            ├── terragrunt.hcl\n            └── variables.auto.tfvars\n\n그러한 방법으로 코드 측면에서 모든 것이 갖추어졌고 대부분의 경우에 잘 작동했습니다. Terraform은 애플리케이션이 실행될 인프라를 생성하고 관리하는 도구입니다. 리소스와 그 사양을 선언적인 방식으로 정의하고, 의존성을 매핑하고, 모든 것을 구축하고, 심지어 현재 인프라와 원하는 최종 상태 간의 일치를 보장하기 위해 상태를 유지할 것입니다. 그러나, 소프트웨어에는 적용되지 않습니다. Terraform은 리소스 자체를 생성하는 데 사용되지만 실행 중인 소프트웨어를 관리하지는 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쿠버네티스에서 대부분의 워크로드를 실행하고 일부는 가상 머신(VMs)에서 실행하면 많은 클러스터 및 개별 서버를 특정 소프트웨어 관점에서 일정 수준의 사용자 정의로 관리해야 했습니다. 예를 들어, GitOps 파이프라인(Flux)을 구축하고 클러스터의 네트워킹 기능을 확장하는 소프트웨어를 원하거나, VM에서 실행 중인 Redash 및 Airflow와 같은 주로 내부 도구와 같은 서비스를 부트스트랩하는 것이 목표였습니다.\n\n여러 환경을 유지하기 위해서는 소프트웨어를 설치, 구성 및 관리하는 일련의 일관된, 신뢰할 수 있고 안전한 방법이 필요했습니다. 이것이 Ansible이 등장한 곳입니다. 일부 관리 되는 리소스용 Terraform 프로바이더가 그 때에 이미 사용 가능했지만, 팀의 역량 및 기존 Ansible에 대한 친숙함과 함께 특정 사용자 정의 작업, 주로 소프트웨어 설치를 위해 채택하는 결정을 내렸습니다.\n\nAnsible\n\nAnsible은 시스템을 구성하고 소프트웨어를 배포하며 연속 배포나 제로 다운타임 롤링 업데이트와 같은 보다 고급 IT 작업을 조정할 수 있는 IT 자동화 (IaC) 도구입니다. Ansible은 미리 정의된 단계 집합을 실행하고 원하는 최종 상태보다는 자동화 프로세스에 집중합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테라폼과 앤서블은 상호 배타적이지 않지만 둘 다 인프라스트럭처 코드 (IaC)에 사용할 수 있는 도구들입니다. 테라폼은 선언적인 접근 방식을 따라 구성 파일에 기반하여 인프라스트럭처 리소스를 프로비저닝, 수정, 관리 및 파괴하는 데 이상적입니다. 한편, 앤서블은 주로 절차적인 방식을 따르는 구성 관리 도구로, 특정 단계가 특정 순서로 실행되어야 하는 상황에서 리소스를 구성하는 데 뛰어납니다. 예를 들어 소프트웨어 설치/업데이트, 런타임 환경 설정, 시스템 구성 파일 업데이트 등.\n\n테라폼과 앤서블을 결합함으로써 새로운 인프라스트럭처를 구축하고 필요한 하드웨어와 소프트웨어를 구성하는 유연한 워크플로우를 만들었습니다. 우리는 테라폼의 로컬 실행자(provisioner)를 활용하여 모듈 내부에서 앤서블 플레이북을 실행하고, 테라폼 변수를 기반으로 플레이북을 사용자 정의하기 위해 템플릿을 사용했습니다. 이 하이브리드 접근 방식을 통해 워크로드의 의존성에 필요한 클러스터를 빠르게 구성할 수 있었습니다. 게다가, 플레이북이 모듈에 통합되어 있었기 때문에 모든 프로비저닝된 리소스가 동일한 방식으로 구성되도록 일관성을 확보할 수 있었습니다. 또한, 모든 환경에서 일관성을 유지함으로써 유지 관리와 문제 해결을 단순화했습니다… 또는 아니었을지도 모릅니다 :)\n\n모든 것이 준비되어 좋은 시작이었지만, 우리가 작업을 완료할 쯤 다른 영역에서 비롯된 다른 유형의 제약 조건에 부딪히기 시작했습니다.\n\n## 문제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWET 코드\n우리의 대부분의 마이크로서비스는 RDS 인스턴스나 S3 버킷과 같은 다양한 종류의 리소스가 필요합니다. 그래서 우리는 리소스 기반에서 마이크로서비스 기반 설계로 전환하기로 결정했습니다. 그러나 동일한 유형의 리소스 정의를 서로 다른 모듈 간에 중복하는 실천은 WET 코드뿐만 아니라 구성에서의 일관성 부족을 만들어내기도 했습니다. 우리 모든 S3 버킷에 대해 데이터 암호화를 강제하는 등 변경 사항을 적용해야 하는 경우에 코드 일관성을 보장하기 위해 상당한 인지적 부담이 도입되었습니다.\n\n하나의 모듈로 모두 통합\n다양한 리소스를 재사용 가능한 모듈로 번들링하고 비즈니스 로직을 포함하는 것이 가야 였습니다(그리고 우리는 여전히 그것이 옳다고 믿습니다). 그러나 서로 다른 팀에서 자주 다른 환경에 대한 요구사항을 갖고 장비 제공 및 동일한 마이크로서비스의 구성을 관리하는 것은 모든 가능한 시나리오를 수용하기 위한 지루한 양의 비즈니스 로직을 유발했습니다.\n\n예를 들어, 클라우드 스토리지와 그에 접근하기 위한 서비스 계정, 포스트그레SQL 데이터베이스 및 CDN이 필요한 단일 마이크로서비스를 고려해 봅시다. 일부 잠재적인 시나리오는 다음과 같습니다:\n\n- QA 팀: 여러 번 파일을 업로드할 필요가 없도록 X 환경에 생성된 공유 버킷을 사용해야 함\n- 개발 팀: 여러 출처를 유지 관리할 필요가 없도록 Y 환경에 생성된 공통 CDN을 사용해야 함\n- 프로덕션 환경: 리소스 분리 및 격리가 필요함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앤서블을 실행하는 것이 무서워졌어요 \n우리의 인프라 구조 요구 사항이 증가하고 제품 아키텍처가 더 복잡해지면서, 앤서블에 의해 수행된 사용자 정의 및 구성이 점점 관리하기 어려워졌어요. 1000줄 이상의 단일 플레이북과 100개의 앤서블 태스크가 있는 상황에서는 제어하고 변경 사항을 추적하기 어려워졌습니다. 테라폼과 달리, 앤서블은 어떤 태스크가 리소스를 수정할지 여부를 명확하게 제공하지 않았어요. 특히 더 많은 중요한 소프트웨어가 앤서블로 관리되는 상황에서 프로덕션 환경에서 실행해야 할 때 마다 불안함을 가중시키기도 했죠.\n\n그때 우리는 다음과 같은 결정을 내렸어요:\n\n- 가능한 것을 테라폼 프로바이더로 이동시키기로 했어요: 쿠버네티스 및 헬름 오퍼레이터는 이 시점에서 더 성숙해졌으므로, kubectl 명령을 실행하거나 직접 헬름 차트를 설치하는 대신 이들을 사용하기 시작했어요.\n- 쿠버네티스 서비스 설치를 테라폼 밖으로 이동하기로 결정했어요: 가능하고 적절한 경우, 쿠버네티스 서비스의 설치 프로세스를 Flux에 의해 관리되는 GitOps 워크플로로 이동했어요.\n새로운 환경, 일관성 및 자동화에 대해 궁금해할 수 있어요. 우리의 헬름 / Flux 설정은 별도의 기사가 필요한 지금, 대부분의 기능이 헬름 차트 방향으로 이동되었지만 이 서비스들에 대한 헬름 릴리스는 여전히 테라폼을 통해 관리되며, 테라폼을 통해 이 서비스에 대한 헬름 릴리스를 실행하고 있습니다.\n- 남은 작업을 개별 플레이북으로 분해하기로 결정했어요: 관리를 단순화하고 유연성을 향상시키기 위해 남은 작업을 더 작고 명확한 작업을 수행하는 개별 플레이북으로 분할했기 때문에 이들을 필요에 따라 별도로 실행할 수 있어요.\n\n문서화\n모듈의 복잡성 증가는 이들을 이해, 업데이트 및 새로운 환경에서 리소스 프로비저닝에 사용하기 어렵게 만들었습니다. 기능을 명확히 파악하고 입력 변수를 구성할 필요가 있는 값을, 예상 결과를 파악하기 위한 오퐋이 미비하다는 사실이 점점 명백해졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3G IaC — Terraform의 귀환\n\nTerraform를 v1.x.x로 업그레이드 한 후, 우리는 현재 구조의 한계와 직면한 문제를 평가하기 시작할 좋은 위치에 있었습니다.\n\n지금까지 사용해온 IaC의 마이크로서비스 기반 조직은 필요한 빌딩 블록을 만들고 필요한 비즈니스 로직을 통합하여 비즈니스 요구 사항을 충족하는 데 유익한 것으로 입증되었습니다. 이 방식은 새로운 마이크로서비스를 도입하거나 기존 마이크로서비스를 개선하는 데 용이했습니다. 예를 들어, 만약 마이크로서비스 X가 NoSQL 데이터베이스를 활용해야 한다면, 해당 모듈을 업데이트하여 Mongo 클러스터를 포함시키고 이 변경 사항을 마이크로서비스 X가 배포된 모든 환경에 적용하면 됩니다. 그러나 모든 마이크로서비스의 NoSQL 데이터베이스에 대해 수평적인 변경을 수행해야 하는 경우에는 점점 더 지루해지는 일이었습니다. 회사가 성장함에 따라 코드 기반이 점점 커지고 관리하기 어려워지며, 보다 복잡한 요구 사항을 구현하는 것이 어려워졌기 때문에 모든 위의 문제를 가능한 빨리 해결해야 했습니다.\n\n우리의 현재 구조를 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-FrommanualtodeclarativeTerraformandIaCinafastgrowingcompany_1.png\" /\u003e\n\n## 코어 리소스로서의 자식 모듈\n\n이전 문제를 해결하기 위해 우리는 자식 모듈의 사용을 도입하여 추상화의 추가 층을 더했습니다.\n\n자식 모듈을 개발하기 시작하려면 일관성과 균일성을 보장하기 위한 규칙 세트를 확립해야 했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Terraform 리소스를 항상 함께 배치해야 하는 번들로 구성합니다. 예를 들어, 파라미터가 있는 PostgreSQL RDS 인스턴스, 서브넷 및 보안 그룹입니다.\n- 인프라 전역에 적용되는 기본 값을 설정하고 강제합니다. 예를 들어, S3 버킷은 공개 액세스 차단, HTTP 요청 거부 및 서버 측 암호화를 사용해야 합니다.\n- 어떠한 비즈니스 로직도 포함해서는 안 됩니다.\n\"비즈니스 논리\"는 Terraform 리소스를 특정 환경 및 애플리케이션에 맞게 구성하는 방식 및 이러한 리소스를 번들로 묶는 방식을 가리킵니다. 모든 비즈니스 로직은 루트 모듈에 유지되어야 합니다.\n- 하나의 제공업체를 대상으로 한 리소스가 포함됩니다.\n\n하위 모듈에는 동일한 제공업체의 리소스만 포함되어야 합니다. 이것은 이러한 모듈에 따라 가야 할 파일 구조에서 더 잘 보여집니다.\n\n```js\nmodules-terraform/\n├── aiven\n│  └── kafka\n│     ├── README.md\n│     ├── main.tf\n│     ├── outputs.tf\n│     ├── variables.tf\n│     └── versions.tf\n├── aws\n│  └── db_instance\n│     ├── README.md\n│     ├── main.tf\n│     ├── outputs.tf\n│     ├── variables.tf\n│     └── versions.tf\n└── gcp\n   └── storage_bucket\n      ├── README.md\n      ├── main.tf\n      ├── outputs.tf\n      ├── variables.tf\n      └── versions.tf\n```\n\n자식 모듈은 더 포괄적인 자식 모듈을 만들기 위해 연결될 수 있습니다. 예를 들어, AWS RDS 인스턴스에 Postgres DB를 인스턴스화하는 경우, 모든 Postgres 인스턴스에 걸쳐 적용하는 표준 Postgres 구성이 있는 Postgres 자식 모듈을 갖습니다. 그럼에도 불구하고 인기 있는 RDS 구성 (로그 기록, SSL, 휴면 시 암호화 등)과 모든 표준 구성물을 포함하며 Postgres에 특정한 표준 구성 사항을 위해 Postgres 자식 모듈을 활용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 새 구조에 하위 모듈이 추가된 것은 다음과 같이 표현될 수 있습니다:\n\n![구조](/assets/img/2024-05-20-FrommanualtodeclarativeTerraformandIaCinafastgrowingcompany_2.png)\n\n자원 번들링 및 비즈니스 로직을 위한 Terragrunt 루트 모듈\n\nTerraform 루트 모듈은 여러 하위 모듈을 인스턴스화하고, 특정 마이크로서비스에 대한 모든 자원을 제공하며, 환경 및 마이크로서비스 요구사항에 따른 \"비즈니스 로직\"을 담당합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 마이크로서비스를 위해 새로운 RDS 데이터베이스를 만들어야 한다고 가정해봅시다:\n\n우리의 요구 사항:\n\n- 각 환경/애플리케이션(비즈니스 로직)에 대한 네이밍 규칙 적용\n클라우드 인프라의 네이밍 규칙은 다음과 같습니다: \n`environment_name`-`service_name`-`resource_type`-`random_id`\n- 인프라 전반에 표준 태그 적용 (비즈니스 로직)\n태그는 항상 이름, 제공자, 팀, 애플리케이션, 환경, 조직을 포함해야 합니다\n- 원격 상태에서 VPC 보안 그룹 사용** (비즈니스 로직)\n- 한꺼번에 모든 것 생성 (Child 모듈)\nRDS PostgreSQL 인스턴스, SSL 적용을 강제하는 매개변수 그룹, 서브넷 그룹, 모든 아웃바운드 트래픽을 허용하는 보안 그룹을 만듭니다.\n이 경우 모든 것이 한 번에 처리될 것이며, 이 요구 사항은 항상 이러한 리소스를 함께 프로비저닝해야 한다는 것입니다. 심지어 SSL을 강제하지 않는 것을 허용하지 않는 엄격한 보안 요구 사항 같은 유효성 검사도 Child 모듈에서 처리될 것입니다.\n\n```js\n변수 \"db_parameter_group_parameters\" {\n  description = \"적용할 DB 매개변수 맵 목록\"\n  타입        = 목록(맵(문자열))\n  기본값     = []\n\n  유효성 {\n    조건 = alltrue(\n      [\n        매개변수 중에 var.db_parameter_group_parameters :\n        (\n          !포함([\"rds.force_ssl\"], 매개변수[\"이름\"])\n        )\n      ]\n    )\n    에러 메시지 = \"force_ssl을 덮어쓸 수 없습니다.\"\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 새로운 구조를 사용하면 이 작업을 단 40줄의 코드로 손쉽게 수행할 수 있습니다.\n\n```js\nlocals {\n  identifier = (var.microservice_pg_identifier == null\n    ? \"${var.env_name}-${var.microservice_name}-pg-${random_id.id.hex}\"\n    : var.microservice_pg_identifier\n  )\n  db_parameter_group_name = \"${var.env_name}-${var.microservice_name}-postgres-${element(split(\".\", var.microservice_pg_engine_version), 0)}\"\n  db_subnet_group_name    = \"${var.env_name}-${var.microservice_name}-${var.aws_region}-db-subnet\"\n  db_security_group_name  = \"${var.env_name}-${var.microservice_name}-${var.aws_region}-db-sg\"\n\n  tags = {\n    name        = local.identifier\n    provisioner = \"terraform\"\n    team        = var.team_name\n    app         = var.microservice_name\n    env         = var.env_name\n    org         = var.org_name\n  }\n}\n\nresource \"random_id\" \"id\" {\n  byte_length = 2\n}\n\nmodule \"microservice_pg\" {\n  source = \"../../../../modules-terraform/aws/db_instance\"\n\n  identifier        = local.identifier\n  engine_version    = var.microservice_pg_engine_version\n  allocated_storage = var.microservice_pg_allocated_storage\n\n  vpc_security_group_ids = [\n    data.terraform_remote_state.vpc.outputs.postgres_security_group_production_id,\n    data.terraform_remote_state.vpc.outputs.postgres_security_group_staging_id,\n    data.terraform_remote_state.vpc.outputs.postgres_security_group_services_id,\n  ]\n\n  backup_retention_period = var.microservice_pg_backup_retention_period\n\n  db_subnet_group_name       = local.db_subnet_group_name\n  db_subnet_group_subnet_ids = data.terraform_remote_state.vpc.outputs.vpc_id\n\n  db_parameter_group_name   = local.db_parameter_group_name\n  db_parameter_group_family = var.microservice_pg_parameter_group_family\n\n  db_security_group_name   = local.db_security_group_name\n  db_security_group_vpc_id = data.terraform_remote_state.vpc.outputs.vpc_id\n\n  tags = local.tags\n}\n```\n\n실시간 설정\n\n실제 설정에서는 Terragrunt를 사용하여 전역 구성 변수를 설정하고 프로바이더 버전을 생성하며, 인프라 전체에 걸쳐 화이트리스트로 지정된 IP를 조작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테라폼 프로바이더 버전 관리\n\n테라폼 프로바이더 버전을 관리하기 위해 각 모듈마다 versions.tf 파일을 생성하는 데 Terragrunt를 사용합니다. 루트 Terragrunt 구성에서 생성 블록을 추가하고 로컬 블록에서 현재 사용 중인 프로바이더 버전이 포함된 YAML 파일을 디코딩합니다. 이를 통해 전체 모듈에 걸쳐 프로바이더 버전을 업데이트할 수 있습니다. 특정 모듈이 프로바이더의 다른 버전을 사용하길 원한다면, 해당 모듈의 라이브 구성에서 덮어쓸 수 있습니다.\n\n루트 terragrunt.hcl:\n\n```js\nlocals {\n  provider_version = yamldecode(file(\"provider_versions.yaml\"))\n  [...]\n}\n\ngenerate \"versions\" {\n  path      = \"versions.tf\"\n  if_exists = \"overwrite\"\n  contents  = \u003c\u003cEOF\n  terraform {\n    required_version = \"\u003e= 1.0\"\n    required_providers {\n      aws = {\n        source  = \"hashicorp/aws\"\n        version = \"${local.provider_version.aws}\"\n      }\n      [...]\n    }\n  }\nEOF\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nprovider_versions.yaml:\n\n```yaml\naws: \"3.74.1\" # [AWS Provider](https://registry.terraform.io/providers/hashicorp/aws/3.74.1)\ngoogle: \"3.90.1\" # [Google Cloud Provider](https://registry.terraform.io/providers/hashicorp/google/3.90.1)\n[...]\n```\n\nWhat about Ansible?\n\nAs mentioned earlier, we have decided to simplify Ansible and migrate as much as possible to more suitable IaC or GitOps workflows. In our IaC code, we only use Ansible for:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Istio 설치. 우리가 리펙터링을 진행한 당시, Istio의 생산 준비가 된 유일한 설치 방법은 istioctl이었으며, 여전히 istioctl에서 Helm으로 이동하려면 삭제 및 재설치가 필요하므로 우리의 프로덕션 환경에 신중히 계획해야 합니다.\n- VM 구성 및 관리. Ansible, Chef, 그리고 Puppet과 같은 절차적 도구들이 아직도 VM 소프트웨어를 구성하고 유지하는 데 최적의 선택지입니다. Ansible의 장점 중 하나는 클라이언트 측에서 실행될 수 있으므로 VM이 구성 관리 도구에 액세스할 필요가 없다는 것입니다.\n\n# CI\n\n이 내용은 이 글의 범위를 벗어나므로 자세히 다루지 않겠습니다. 하지만 조만간...\n\nIaC CI/CD 여정을 설명할 후속 기사가 곧 공개될 예정입니다.","ogImage":{"url":"/assets/img/2024-05-20-FrommanualtodeclarativeTerraformandIaCinafastgrowingcompany_0.png"},"coverImage":"/assets/img/2024-05-20-FrommanualtodeclarativeTerraformandIaCinafastgrowingcompany_0.png","tag":["Tech"],"readingTime":20}],"page":"29","totalPageCount":61,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"29"},"buildId":"0asLlD6on3tm8cIfzBaxd","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>