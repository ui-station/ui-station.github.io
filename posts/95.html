<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/95" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/95" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="루비 온 레일즈로 CORS 구성하기 - 2부" href="/post/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비 온 레일즈로 CORS 구성하기 - 2부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비 온 레일즈로 CORS 구성하기 - 2부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비 온 레일즈로 CORS 구성하기 - 2부</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴" href="/post/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지" href="/post/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">33<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능" href="/post/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱" href="/post/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기" href="/post/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LeetCode 3068번 문제 해결하기 노드 값의 최대 합 찾기" href="/post/2024-05-20-SolvingLeetCode3068FindtheMaximumSumofNodeValues"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LeetCode 3068번 문제 해결하기 노드 값의 최대 합 찾기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-20-SolvingLeetCode3068FindtheMaximumSumofNodeValues_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LeetCode 3068번 문제 해결하기 노드 값의 최대 합 찾기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">LeetCode 3068번 문제 해결하기 노드 값의 최대 합 찾기</strong><div class="PostList_meta__VCFLX"><span class="date">May 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="의료 기록의 개인 정보는 신뢰에 달려 있습니다" href="/post/2024-05-18-ThePrivacyoftheMedicalRecordReliesonTrust"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="의료 기록의 개인 정보는 신뢰에 달려 있습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-ThePrivacyoftheMedicalRecordReliesonTrust_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="의료 기록의 개인 정보는 신뢰에 달려 있습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">의료 기록의 개인 정보는 신뢰에 달려 있습니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신만의 개인 AI 코드 어시스턴트 로컬 머신에서 오프라인 LLM 사용 초보자 가이드" href="/post/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신만의 개인 AI 코드 어시스턴트 로컬 머신에서 오프라인 LLM 사용 초보자 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신만의 개인 AI 코드 어시스턴트 로컬 머신에서 오프라인 LLM 사용 초보자 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">당신만의 개인 AI 코드 어시스턴트 로컬 머신에서 오프라인 LLM 사용 초보자 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2023년에 블록하지 않고 알려지지 않은 번호로부터 WhatsApp 메시지 수신을 중지하는 방법" href="/post/2024-05-18-HowtoStopReceivingWhatsAppMessagesfromUnknownNumbersWithoutBlocking2023"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2023년에 블록하지 않고 알려지지 않은 번호로부터 WhatsApp 메시지 수신을 중지하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-HowtoStopReceivingWhatsAppMessagesfromUnknownNumbersWithoutBlocking2023_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2023년에 블록하지 않고 알려지지 않은 번호로부터 WhatsApp 메시지 수신을 중지하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2023년에 블록하지 않고 알려지지 않은 번호로부터 WhatsApp 메시지 수신을 중지하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/81">81</a><a class="link" href="/posts/82">82</a><a class="link" href="/posts/83">83</a><a class="link" href="/posts/84">84</a><a class="link" href="/posts/85">85</a><a class="link" href="/posts/86">86</a><a class="link" href="/posts/87">87</a><a class="link" href="/posts/88">88</a><a class="link" href="/posts/89">89</a><a class="link" href="/posts/90">90</a><a class="link" href="/posts/91">91</a><a class="link" href="/posts/92">92</a><a class="link" href="/posts/93">93</a><a class="link" href="/posts/94">94</a><a class="link posts_-active__YVJEi" href="/posts/95">95</a><a class="link" href="/posts/96">96</a><a class="link" href="/posts/97">97</a><a class="link" href="/posts/98">98</a><a class="link" href="/posts/99">99</a><a class="link" href="/posts/100">100</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"루비 온 레일즈로 CORS 구성하기 - 2부","description":"","date":"2024-05-20 15:49","slug":"2024-05-20-ConfiguringforCORSwithRubyonRailsPartII","content":"\n여러 달 전에, 프록시를 사용하여 CORS 오류를 해결하는 방법에 대해 게시물을 게시했었어요. 배포할 때까지는 잘 되지만, 프록시를 설정하는 것이 최선의 방법이 아니라는 것을 빨리 깨달았어요. 이전 포스트에서 놓친 요소 중 하나는 Ruby on Rails API를 빌드할 때 사용자 인증을 통합하는 경우에 Rack-CORS를 구성하는 것이었어요. 이 포스트는 개인 프로젝트에서 개발 및 프로덕션에서 CORS 오류를 디버깅하면서 배운 내용을 요약한 것이에요.\n\n처음에 제가 채택한 접근 방식은 순수한 Ruby를 사용하는 것이었어요. 이 방법은 분명 더 복잡했지만, 사전 플라이트 HTTP 요청 주변의 세부 사항을 이해하고 요청/응답 헤더가 동작하는 실제 내용을 이해하는 데 도움이 되었어요. 그래서 이 방법을 간소화하기 전에 CORS 오류를 해결하는 첫 번째 방법으로 제시하고 있어요.\n\n## CORS 사전 체크 — HTTP OPTIONS 요청\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_1.png)\n\n가장 먼저 이해해야 할 것은 프런트엔드가 백엔드에 보내는 HTTP 요청의 유형에 따라 해당 요청이 처리되기 전에 완료되는 CORS 사전검사입니다. 이는 보내려는 HTTP 요청이 안전한지 여부를 결정합니다. 사전검사는 HTTP OPTIONS 메서드를 통해 수행됩니다. 개발 도구의 네트워크 탭에서 사전검사 및 fetch 요청을 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_2.png)\n\nOPTIONS 요청에는 다음과 같은 요청 헤더가 포함될 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Origin: 요청이 온 곳을 나타냅니다. 예를 들어, 개발 중이라면 \"http://localhost:3000\"이거나 배포된 앱이라면 \"http://127.0.0.1:5173\" 또는 \"http://yourwebsite.production.app\"입니다.\n- Access-Control-Request-Method: 사용 가능한 HTTP 메소드를 나타냅니다. 예를 들어, GET, POST, PUT, PATCH, DELETE, OPTIONS가 있습니다.\n- Access-Control-Request-Headers: 실제 요청을 보낼 때 프론트엔드 애플리케이션이 보낼 수 있는 HTTP 헤더를 지정합니다.\n- Access-Control-Request-Credentials: 요청이 인증을 요구하는지를 결정합니다. 요구되면 true로 설정하고, 그렇지 않으면 생략됩니다. 이 헤더의 유효한 값은 true뿐입니다.\n- Access-Control-Max-Age: 프리플라이트 요청의 결과를 캐싱할 수 있는 시간(초)을 결정하는 선택적인 헤더입니다. MDN 문서에 따르면, 기본값은 5초이며 최대 24시간(86400초)입니다.\n\n만약 서버가 프리플라이트 확인에 적절한 응답 헤더를 제공한다면, 그때에만 프론트엔드가 실제 HTTP 요청을 계속할 수 있습니다. 프리플라이트 확인이 실패하면 적절한 헤더가 제공되지 않았기 때문에 아래와 같이 콘솔에서 볼 수 있는 오류의 예시가 있습니다:\n\n\u003cimg src=\"/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_3.png\" /\u003e\n\n## 루비 온 레일즈를 이용한 CORS 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법을 사용하면 추가적인 젬이나 종속성을 설치할 필요가 없습니다. 첫 번째 단계는 요청을 CORS 컨트롤러로 라우팅할 config/routes.rb에 OPTIONS 라우트를 추가하는 것입니다. 아래 예시에서는 ' /login', ' /signup', ' /logout', '그리고 ' /users' 네 개의 라우트를 추가했습니다.\n\n```js\n# config/routes.rb에 추가\n\nRails.application.routes.draw do\n\n  match '/login', controller: 'cors', action: 'cors_preflight_check', via: [:options]\n  match '/signup', controller: 'cors', action: 'cors_preflight_check', via: [:options]\n  match '/logout', controller: 'cors', action: 'cors_preflight_check', via: [:options]\n  match '/users', controller: 'cors', action: 'cors_preflight_check', via: [:options]\n  # ... 다른 라우트들은 여기에 추가\n\nend\n```\n\n구성하려는 특정 엔드포인트들이 있으면 아래와 같이 개별적으로 추가하여 `path`와 `컨트롤러의 이름`을 대체할 수 있습니다:\n\n```js\nmatch '\u003cpath\u003e', controller: \"\u003c컨트롤러의 이름\u003e\", action: 'cors_preflight_check', via: [:options]\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 애플리케이션은 약 20개의 엔드포인트로 끝났어요. OPTIONS 요청을 경로하는 DRY한 방법은 아래와 같습니다. 모든 OPTIONS 요청을 와일드카드 \"\\*\" 경로를 사용하여 한 컨트롤러와 메소드에 경로하려면 이 방법이 작동합니다.\n\n```js\n# config/routes.rb에 추가\n\nRails.application.routes.draw do\n\n  options '*path', to: 'application#cors_preflight_check'\n  # ... 다른 루트\n\nend\n```\n\n그 다음으로 app/controllers에 cors_controller.rb 파일을 생성하고 다음 메소드를 추가하세요. HTTP 메소드가 OPTIONS인 경우 cors_preflight_check 메소드가 cors_set_access_control_headers 메소드를 실행합니다.\n\n```js\n# app/controllers/cors_controller.rb에 추가:\n\nclass CorsController \u003c ApplicationController\n\n    def cors_preflight_check\n        if request.method == 'OPTIONS'\n          cors_set_access_control_headers\n          render text: '', content_type: 'text/plain'\n        end\n      end\n\n    protected\n\n    def cors_set_access_control_headers\n        response.headers['Access-Control-Allow-Origin'] = \"http://localhost:4000\"\n        response.headers['Access-Control-Allow-Credentials'] = \"true\"\n        response.headers['Access-Control-Allow-Methods'] = 'POST, GET, PUT, PATCH, DELETE, OPTIONS'\n        response.headers['Access-Control-Allow-Headers'] = 'Origin, Content-Type, Accept, Authorization, Token, Auth-Token, Email, X-User-Token, X-User-Email'\n        response.headers['Access-Control-Max-Age'] = '86400'\n    end\n\nend\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ncors_set_access_control_headers 메서드는 적절한 응답 헤더를 설정합니다. Access-Control-Allow-Methods, Access-Control-Allow-Headers 및 Access-Control-Max-Age에 대해 각각 모든 HTTP 메소드, 허용되는 모든 헤더 및 최대 캐시 기간을 나열했습니다.\n\nOrigin 및 Credentials에 초점을 맞추고 싶습니다. 인증된 요청이 필요하지 않다면 Origin 헤더에 와일드카드 \"_\"를 사용하여 서버가 모든 원본에서 요청을 수락하도록 할 수 있습니다. 그러나 로그인, 가입 등과 같은 인증이 필요한 HTTP 요청의 경우, 원본으로 와일드카드 \"_\"를 사용할 수 없습니다. 시도하면 다음과 같은 오류가 발생합니다.\n\n\u003cimg src=\"/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_4.png\" /\u003e\n\n따라서 인증이 필요한 경우 프론트엔드 애플리케이션의 원본을 명시해야 합니다. API에 액세스를 허용하고 싶은 여러 원본이 있는 경우, response.headers['Access-Control-Allow-Origin']을 다음과 같이 업데이트할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# in app/controllers/cors_controller.rb:\ndef cors_set_access_control_headers\n        response.headers['Access-Control-Allow-Origin'] = check_origin\n        response.headers['Access-Control-Allow-Credentials'] = \"true\"\n        response.headers['Access-Control-Allow-Methods'] = 'POST, GET, PUT, PATCH, DELETE, OPTIONS'\n        response.headers['Access-Control-Allow-Headers'] = 'Origin, Content-Type, Accept, Authorization, Token, Auth-Token, Email, X-User-Token, X-User-Email'\n        response.headers['Access-Control-Max-Age'] = '86400'\nend\n\ndef check_origin\n        permitted_origins = Set[\n            \"http://localhost:4000\",\n            \"http://127.0.0.1:4000\",\n            \"http://yourwebsite.production.app\",\n            /\\Ahttps:\\/\\/deploy-preview-\\d{1,4}--yourwebsite\\.domain\\.app\\z/\n        ]\n\n        origin = request.origin\n\n        if permitted_origins.include?(origin)\n            origin\n        else\n            render json: { error: \"Origin not permitted\" }\n        end\nend\n```\n\ncheck_origin 메소드 내에서, 허용된 origin을 Set으로 정의합니다. 여기에 Rail API가 허용할 origin을 추가합니다: 포트 번호가 포함된 localhost 및 프론트엔드 응용 프로그램이 배포된 경우의 프로덕션 URL 등이 포함됩니다.\n\n[선택사항] 내 응용 프로그램에서 프론트엔드를 배포하기 위해 Netlify를 사용하고 있었으며, Netlify의 CI/CD의 일부로 \"https://deploy-preview-123--yourwebsite.netlify.app\"와 같은 형식의 배포 미리보기가 생성됩니다. 여기서 \"123\"은 길이가 3 이상인 정수 문자열일 수 있습니다. 이것을 해결하기 위해 유연성을 제공하고 Netlify의 미리보기 모드로 배포된 앱을 계속 테스트할 수 있도록 하기 위해 정규식을 추가했습니다.\n\n[주의] Origin을 정의할 때 슬래시(/)가 앞뒤로 제대로 있는지에 주의하십시오. 이를 제대로 맞추기 위해 백엔드를 5번 재배포해야 할 것 같았습니다..\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그게 다입니다! Rails 서버를 다시 시작하면 CORS 오류가 더 이상 표시되지 않아야 합니다.\n\n## Postman에 대한 참고 사항\n\nAPI를 테스트할 때 Postman을 사용할 때, Postman에 대한 origin이 설정되어 있지 않아도 CORS가 발생하지 않는 것을 알았습니다. 이는 Postman의 기본 origin이 “nil”로 설정되어 있기 때문입니다. 따라서 Postman은 API를 테스트하는 데 훌륭하지만, 프론트엔드와 백엔드 응용 프로그램을 연결하고 HTTP 요청이 다른 도메인에서 전송되는 경우에만이 문제가 발생한다는 점을 기억해 주세요. 저는 개발 중에, 배포 중에, 그리고 CI/CD에서 여러 번 이 문제를 겪었습니다 (즐겁게요...)!\n\n## Rack-CORS Gem 사용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Vanilla Ruby를 사용하여 상세 구현을 살펴 보았습니다. Rack-CORS gem을 사용하여 이를 간단하게 만들어 봅시다.\n\n먼저 Gemfile에 rack-cors gem을 추가하세요. 이미 추가되어 있을 수 있으므로 주석 처리만 해제해야 할 수도 있습니다.\n\n```js\n# Gemfile에 추가\ngem 'rack-cors'\n```\n\n그런 다음 다음 명령어로 설치하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n번들 설치\n\ncors.rb를 구성하세요. 일반적인 Ruby 케이스에서 위와 같은 구성을 달성하려면 config/initializers/cors.rb로 이동하여 미들웨어 구성 코드 블록 주석 처리를 해제하고 다음과 같이 수정하세요:\n\n```js\n# in config/initializers/cors.rb\n\nRails.application.config.middleware.insert_before 0, Rack::Cors do\n  allow do\n    origins \"http://localhost:4000\"\n            \"http://127.0.0.1:4000\",\n            \"http://yourwebsite.production.app\",\n            /\\Ahttps:\\/\\/deploy-preview-\\d{1,4}--yourwebsite\\.domain\\.app\\z/\n\n    resource \"*\",\n      headers: :any,\n      methods: [:get, :post, :put, :patch, :delete, :options, :head],\n      credentials: true,\n      max_age: 86400\n  end\nend\n```\n\n그런 다음 서버를 재시작하면 문제 없이 작동해야 합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRack-CORS를 사용하면 훨씬 쉬워지고 초반에 이를 어떻게 구성해야 할지 이해했더라면 훨씬 많은 시간을 절약할 수 있었을 텐데요. 하지만 HTTP 요청과 CORS 사전 확인에 대해 깊이 파헤친 것은 가치 있는 학습 경험이었습니다. 이를 통해 이러한 원칙을 다른 언어와 프레임워크로 번역할 수 있었죠. 예를 들어, CORS와 사전 확인 요청/응답 헤더를 이해하고 구성하는 것이 파이썬/Django로 CORS를 이해하고 구성하는 데 도움이 되었습니다.\n\n읽어 주셔서 감사합니다.\n","ogImage":{"url":"/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_0.png"},"coverImage":"/assets/img/2024-05-20-ConfiguringforCORSwithRubyonRailsPartII_0.png","tag":["Tech"],"readingTime":11},{"title":"루비 온 레일스 개발자로서 알아야 할 5가지 디자인 패턴","description":"","date":"2024-05-20 15:48","slug":"2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper","content":"\n\u003cimg src=\"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_0.png\" /\u003e\n\n소프트웨어 개발에서 디자인 패턴은 흔한 문제에 대한 검증된 해결책을 제공하기 때문에 중요합니다. Ruby on Rails 개발자에게는 이러한 패턴을 이해하고 구현하는 것이 유지보수 가능하고 확장 가능하며 효율적인 응용 프로그램을 만들 수 있게 도와줍니다. Ruby on Rails 개발자가 꼭 알아야 할 다섯 가지 중요한 디자인 패턴을 소개합니다:\n\n# MVC (Model-View-Controller)\n\n## 개요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMVC 패턴은 루비 온 레일 애플리케이션의 아키텍처에 근간을 두고 있어요. 애플리케이션을 세 가지 연결된 구성 요소로 구분합니다:\n\n- Model: 데이터와 비즈니스 로직을 관리합니다.\n- View: 정보의 표시를 관리합니다.\n- Controller: 사용자 입력을 처리하고 Model과 상호 작용하여 View를 렌더링합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_1.png)\n\n## 장점\n\n역할의 분리: 각 구성 요소가 명확한 책임을 갖고 있어 코드베이스가 더 정리되고 관리하기 쉬워집니다.\n\n테스트 용이성: 각 구성 요소를 격리시켜 개별적으로 테스트하기가 더 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시\n\n\u003cimg src=\"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_2.png\" /\u003e\n\n# 서비스 객체\n\n## 개요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스 객체는 모델이나 컨트롤러에 자연스럽게 맞지 않는 비즈니스 로직을 캡슐화합니다. 이 패턴을 사용하면 모델과 컨트롤러를 가볍게 유지하고 주요 책임에 집중할 수 있습니다.\n\n![이미지](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_3.png)\n\n## 장점\n\n단일 책임 원칙: 각 서비스 객체는 특정 작업을 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n재사용성: 비즈니스 로직은 애플리케이션의 다른 부분에서 재사용할 수 있습니다.\n\n## 예시\n\n![이미지](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_4.png)\n\n# 데코레이터 패턴\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 개요\n\n데코레이터 패턴은 동일한 클래스의 다른 객체들의 동작에 영향을 미치지 않으면서 개별 객체에 동작이나 책임을 추가하는데 사용됩니다. Rails에서는 Draper 젬이 데코레이터를 구현하는 데 자주 사용됩니다.\n\n## 이점\n\n확장성: 기존 코드를 변경하지 않고 쉽게 새로운 기능을 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프레젠테이션 로직 분리: 모델에서 프레젠테이션 로직을 유지합니다.\n\n## 예시\n\n![Example](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_5.png)\n\n# FORM OBJECT PATTERN\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 개요\n\n폼 객체 패턴은 여러 모델을 관련시키는 양식 관련 로직을 캡슐화합니다. 이 패턴은 여러 모델과 상호 작용하거나 사용자 정의 유효성 검사가 필요한 복잡한 양식에 특히 유용합니다.\n\n![이미지](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_6.png)\n\n## 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n관심사 분리: 모델과 컨트롤러에서 양식 로직을 분리합니다.\n\n재사용성: 양식 객체는 응용 프로그램 전체에서 비슷한 양식에 재사용할 수 있습니다.\n\n## 예시\n\n![image](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쿼리 오브젝트 패턴\n\n## 개요\n\n쿼리 오브젝트 패턴은 데이터베이스 쿼리 로직을 캡슐화하여 복잡한 쿼리를 더 깔끔하고 재사용 가능한 방식으로 관리하는 것을 제공합니다. 이는 모델을 가볍고 데이터를 표현하는 데 집중할 수 있도록 도와줍니다.\n\n## 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 관심사의 분리: 쿼리 논리를 모델 외부로 유지합니다.\n\n재사용성: 쿼리 객체는 응용 프로그램의 다양한 부분에서 재사용할 수 있습니다.\n\n![image](/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_8.png)\n\n## 예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_9.png\" /\u003e\n\n# 결론\n\n이 디자인 패턴을 이해하고 구현하는 것은 Ruby on Rails 애플리케이션의 품질을 크게 향상시킬 수 있습니다. 이러한 패턴은 깔끔하고 조직적이며 확장 가능한 코드를 유지하는 데 도움이 되어 개발을 더 효율적이고 관리하기 쉽게 만듭니다. Rails 개발자로서成해 나감에 따라, 이러한 패턴들은 개발 툴킷에서 가치 있는 도구가 될 것입니다.\n","ogImage":{"url":"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_0.png"},"coverImage":"/assets/img/2024-05-20-5DesignPatternsYouShouldKnowasaRubyonRailsDeveloper_0.png","tag":["Tech"],"readingTime":6},{"title":"25가지 이유 2024년에도 왜 자바가 여전히 인기 있는지","description":"","date":"2024-05-20 15:42","slug":"2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024","content":"\n![Java Image](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_0.png)\n\n“프로그래밍 언어는 두 종류밖에 없어: 사람들이 불평하며 사용하는 것과 아무도 사용하지 않는 것.” — 바르네 스트롭스트룹.\n\n제가 Java를 배웠을 때, 객체지향 프로그래밍 열풍이 불었고 (90년대 후반), Java는 그 개념을 실제로 구현한 유일한 언어였던 것 같아요 (이전에 C++도 공부했지만, 정말로 한계라고 생각했죠).\n\n제가 Java가 어떻게 발전해 왔는지 정말 좋아했어요. Python을 살펴봤었는데, 사람들에게 열정을 일으키는 것 같지만, 저는 딱히 그 열풍에 휩싸이지 않았어요; 다시 말해서, 제가 충분히 깊은 수준으로 들어가지 못했을 수도 있어요. 제가 정말 큰 Java 프로젝트에서 일한 적이 있는데, 그들은 (합리적으로) 꽤 잘 다뤘어요; Python은 그 규모에서 상상도 못 해요. 하지만, 최근의 프로젝트들은 미니 서비스 방향으로 향하고 있는 것 같아요 — 아마 Python은 그것에 적합할지도 모르겠지만, 제게는 잘 모르는 분야예요. Java는 그 부분에 대해서는 알고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바를 배울 때는 90년대 후반에 OOP 열풍이 한창이었고, 자바는 실제로 그 개념들을 구현한 언어로 빛이 났죠 (전에 C++을 배웠었지만, 정말). 저는 자바의 플랫폼 독립성을 감사히 여겼어요.\n\n제 생각에는 간결함보다는 구조와 일관성을 선호하는 편이기 때문에 자바를 계속 사용하고 있네요.\n\n제 경력 동안에는 이상적이지 않은 자바 코드베이스와 여러 번 마주치게 되었는데, 때로는 자바에 조금 심심해하기도 했어요. 하지만 다른 많은 훌륭한 프로젝트들에 참여하면서 자바를 다시 사랑하게 되었죠.\n\n자바에 대해 비판하고 불평하는 사람들은 종종 자바스크립트에 더 노출된 젊은 세대인 것 같아요. JS와 비교하면 자바는 조금 무겁고 제한적으로 느껴질 수 있어요 — 보일러플레이트가 많고, 컴파일러에 의해 엄격하게 시행되는 타입 시스템 등이 그 예시죠. 하지만 선택이 주어진다면, 저는 분명 자바 코드베이스가 서브옵티멀하더라도 JS보다는 자바를 선택할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현실 세계에서 일정 경험을 쌓은 후 수백 개의 파일에 흩어진 코드를 처리하면서, 자바의 이른바 \"한계\"는 실제로 발목을 다치지 않도록 방지하는 안전장치라는 것을 깨닫게 됩니다.\n\n\"C++의 창시자인 바네 스트롭스트룹이 할 말을 인용하면, '프로그래밍 언어는 두 가지 종류뿐이다: 사람들이 불평하는 것과 아무도 사용하지 않는 것'\"입니다.\n\n자바에 대한 불평이 많다고 생각하십니까? C++를 보세요. 사람들은 그 언어를 사랑하거나 미워하며 마치 피할 수 없는 학대적인 관계인 것처럼 대합니다.\n\n파이썬도 불평을 많이 받았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사람들은 계속해서 GIL(글로벌 인터프리터 락)이 진정한 효율적인 멀티스레딩을 방해한다고 말합니다. Python 코어의 많은 부분이 GIL에 의존하기 때문에 아마도 결코 제거되지 않을 것입니다. 그 결과로 사람들은 여러 프로세스를 사용하고 프로세스 간에 통신하기 위해 메시지 전달 체계를 만들어 이를 해결해야 했습니다. Python의 성능 또한 C/C++로 hotpaths를 다시 작성하지 않으면 굉장히 느립니다. 물론 Python 2에서 3으로의 전환도 그렇죠.\n\n한 번 Django 프로젝트를 작업했을 때(그때는 뜨거운 주제였던 시절) Python이 유형화된 언어보다 더 나은 것으로 생각했습니다(사용 용도에 따라 다르겠지만 1000개 이상의 클래스가 있는 복잡한 시스템에서는 아닙니다).\n\n이 프로젝트가 저 혼자 개발자인 상태에서 여러 사람이 참여하고 코드가 10,000줄 이상이 된 순간, 유지보수가 복잡해졌습니다.\n\nJava로 전환하고 다시 발견했을 때 놀랍다는 생각이 들었습니다. Java와 그 생태계를 사랑하는 것을 깨달았죠. 그래서 Java 생태계에 대해 좋아하는 몇 가지를 메모해 보기로 했습니다. 그래서 Java를 욕하는 누군가가 있다면, 그들이 틀렸다는 이유를 25가지로 설명해 줄 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 생태계가 성숙합니다\n\n자바는 25년 이상 되었습니다. 이 생태계에서 개발자로 일해온 경험을 토대로, 이 생태계가 몇 년 동안 얼마나 성숙해졌는지 되돌아보는 것이 흥미롭습니다.\n\n자바의 넓은 생태계 중 가장 좋은 점은 다양한 라이브러리, 빌드 도구 및 프레임워크를 선택할 수 있다는 것입니다.\n\nJVM 생태계는 완벽하게 다양하며, 최상의 라이브러리로 거의 모든 문제에 대한 해법이 있으며 모두 고성능이며 잘 유지됩니다. 빌드 도구를 선택할 때 다양한 선택지가 있습니다. 예를 들어 빠르고 재현 가능한 빌드를 위해 Gradle, Maven 및 Bazel을 사용할 수 있습니다. 아직 이 생태계에 익숙하지 않은 경우, 자바는 기본 구현체로 로깅, 데이터베이스 연결, 메시징 및 응용 프로그램 서버와 같은 다양한 기능을 제공하여 좋은 출발점이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 애플리케이션에 로깅이 필요한 경우를 생각해보겠습니다. 걱정하지 마세요. Java는 JDK에 기본 로깅 옵션이 내장되어 있어 여러분을 지원해줍니다. 기본 옵션을 좋아하지 않거나 충분하지 않다면 어떻게 할까요? 기본 로깅은 로깅 API에 대한 참조 구현에 불과합니다. 선택할 수 있는 다른 훌륭한 로깅 라이브러리들이 있습니다.\n\n그리고 로깅 뿐만 아니라, Java 생태계는 데이터베이스 연결, 메시징, 애플리케이션 서버, 서블릿 등 다양한 옵션을 제공해줍니다.\n\n## 2. 한 번 작성하면 어디서나 실행하기 (WORA)\n\n이것은 Java 언어의 크로스 플랫폼 이점을 가리키는 우리가 자주 사용하는 슬로건입니다. 여기서 원한 말고 말하자면, 요즘 Java를 배우는 대부분의 개발자들은 이 기능이 소프트웨어 개발에 어떤 혁신적 영향을 미쳤는지 모를 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJava가 탄생하기 10년 전, C++가 주를 이루던 프로그래밍 언어였습니다. 그러나 개발자들이 직면한 문제 중 하나는 C++의 플랫폼 의존적인 성격이었습니다. C++로 작성된 코드는 다른 운영 체제나 하드웨어 아키텍처에서 실행되려면 재컴파일 및 종종 수정이 필요했습니다.\n\n![image](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_1.png)\n\n### 3. 하위 호환성\n\n만약 새로운 Java 버전이 나올 때마다 프로그램을 위한 코드를 다시 작성해야 한다면 어떨까요? 특히 대규모 기관들에게는 매우 비용이 많이 들고 시간이 많이 소요될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바는 오랜 시간동안 사용되어 왔기 때문에 예전 버전의 자바를 기반으로 한 소프트웨어 제품이 많이 존재하며, 다양한 분야에서 중요한 기능을 제공하며 기업의 주요 기반을 형성하고 있습니다.\n\n대규모이고 복잡한 프로젝트가 진행되는 기업 개발에서는 이러한 시스템을 최신 자바 버전으로 이관하는 작업은 신중한 계획과 실행이 필요합니다.\n\n자바의 하위 호환성은 개발자나 조직이 시스템 개발에 많은 투자를 한 상태라도 시스템이 계속 운영되며 완전한 재작성을 필요로하지 않고 유지 관리할 수 있음을 보장해줍니다. 자바(JVM)의 하위 호환성은 또한 마이그레이션 프로세스를 간소화시키며, 기존 시스템의 안정성을 저해하지 않으면서 새로운 기능과 개선 사항을 도입하는 것을 용이하게 합니다.\n\n# 4. 자바 강한 타입 시스템\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바는 파이썬과 같이 느슨하게 유형이 지정된 언어와는 달리 강력하게 유형이 지정된 언어입니다. 파이썬과 함께 일해본 적이 있다면, 서로 다른 유형의 값을 동일한 변수에 할당할 수 있는 유연성을 즉시 느낄 수 있으며, 언어가 동적으로 적응된다는 것을 느끼게 될 것입니다.\n\nint age = 25;\n\nString name = “John”;\n\n하지만 이러한 유연성은 대가가 따릅니다. 제가 기억하는 한, 다양한 숫자 데이터 유형을 사용하는 복잡한 계산을 다루는 금융 응용 프로그램에서 작업했었습니다. 자바의 강력한 유형 지정으로 인해, 컴파일러는 호환되지 않는 데이터 유형을 혼합하거나 데이터 손실이나 예기치 않은 결과로 이어질 수 있는 작업을 수행하려는 모든 시도에 경고를 표시했습니다. 이러한 명백한 버그 중 일부는 파이썬과 같은 언어로 작업할 때 런타임까지 눈에 띄지 않았을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것이 왜 Java가 기업 애플리케이션을 개발하는 데 흥미로운 이유 중 하나인데요, 특히 은행 및 금융과 같은 산업에서 신뢰성과 보안이 중요한 분야입니다. Java의 강력한 타입 시스템은 런타임 오류를 줄이는 데 도움이 될 뿐만 아니라 변수, 매개변수 및 반환 값의 의도된 데이터 유형을 이해하기 쉽게 해서 코드의 가독성을 향상시킵니다.\n\n## 5. RELEASE CYCLE — 지속적인 개선\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_2.png)\n\n일반적으로 Java 개발자로서, 몇 년마다 주요 릴리스에 이어 새로운 Java 기능을 얻는 데 익숙했습니다. 그러나 현대 프로그래밍 요구 사항에 따라 Java의 릴리스 주기가 Java 9 릴리스 후 6개월로 바뀌었습니다. 그러나 새 버전으로 넘어가지 않아도 되는 기업 기관을 위해, Oracle은 3년마다 LTS(Long-Term Support) 버전을 릴리스할 것을 제안했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 자주 발생하는 작은 릴리스는 새로운 자바 버전으로 업그레이드할 때 발생하는 복잡성과 위험을 줄입니다. 점진적인 변경 사항은 역호환성을 더 고려하여 설계되어 있기 때문에 개발자들이 주요 호환성 문제에 직면할 가능성이 적어집니다.\n\n# 6. 최고의 IDE\n\nJava는 다양한 변경과 기능으로 현대적인 개발에 탁월하게 맞는 언어로 발전해 왔습니다. 그러나 IntelliJ IDEA, Eclipse, NetBeans와 같은 강력한 통합 개발 환경(IDE)의 지원을 받지 않는다면 이는 유용하지 않을 수도 있습니다.\n\n지능적인 코드 완성, 자동 리팩터링, 원활한 버전 관리 통합 등과 같은 기능이 없는 환경에서 코드를 작성하는 것은 상상하기 어렵습니다. 그러나 특히 초기의 자바 시대에는 항상 그랬다고 당당히 주장하는 것도 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최신 IDE인 IntelliJ와 Eclipse로 빠르게 이동하면, 이들은 Java 개발을 간편하게 만들어 주었습니다. 이 IDE들은 Maven 및 Gradle과 완벽하게 통합되어 컴파일, 의존성 해결 및 프로젝트 관리를 처리합니다. 지능적인 코드 완성 기능과 내장 정적 코드 분석 도구를 통해 Java가 덜 장황하게 느껴지며, 플러그인을 통한 액세스로 환경을 원하는 대로 사용자 정의할 수 있습니다.\n\n# 7. GRAALVM 네이티브 이미지 지원\n\n이미 JVM이 Java를 영광으로 이끌어 주었던 원츄r 개론 자 애플리케이션에서 실행 시간이 지연되므로 애플리케이션이 JVM 상에서 실행되는 것보다 빠르게 시작하는 것입니다. 젠하는 것입니다. 이 이있는데, 나와 같은 개 개발자는 대부분 마이크로서비스, 서버리스 컴퓨팅 및 빠른 시작 및 최적화된 리소스 사용이 중요한 환경으로 이동하고 있으므로, 특히 이제는 프로그램 정보와 시작 시간을 빠르게 시작하기 위해 노력을 기울이고 있습니다. 사용하기 위한 해법 중 하나로 Oracle GraalVM의 고성능 JDK이며, Graal 컴파일러라는 대체 JIT(Just-in-Time) 컴파일러를 사용하여 Java 및 JVM 기반 애플리케이션의 성능을 농도로vey합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGraalVM에는 Java 바이트코드를 미리 컴파일하는 네이티브 이미지 유틸리티가 포함되어 있어서 애플리케이션이 거의 즉시 시작될 수 있습니다. Graal 컴파일러는 AOT 컴파일러로도 작동하여 네이티브 실행 파일을 생성합니다. 입력은 Java 바이트코드이고 출력은 네이티브 실행 파일입니다.\n\n여기 재귀를 사용하여 문자열을 뒤집는 작은 Java 프로그램 예제가 있습니다.\n\n```js\npublic class Example {\n    public static void main(String[] args) {\n        String str = \"Native Image is awesome\";\n        String reversed = reverseString(str);\n        System.out.println(\"The reversed string is: \" + reversed);\n    }\n    public static String reverseString(String str) {\n        if (str.isEmpty())\n            return str;\n        return reverseString(str.substring(1)) + str.charAt(0);\n    }\n}\n```\n\n이 Java 클래스에서 컴파일하고 네이티브 이미지를 빌드할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\njavac Example.java\nnative-image Example\n```\n\n네이티브 이미지 빌더는 Example 클래스를 사전 컴파일하여 현재 작업 디렉토리에 독립 실행 파일인 \"example\"로 생성합니다. 그런 다음 해당 실행 파일을 실행할 수 있습니다.\n\n```js\n./example\n```\n\n# 8. 오픈 소스 라이브러리 및 프레임워크.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오픈 소스 라이브러리와 프레임워크는 Java가 내 도구상에서 특별한 자리를 차지하는 주요 이유 중 하나입니다.\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_3.png)\n\n이러한 라이브러리와 프레임워크는 내 프로젝트에 원활하게 통합할 수 있는 구성 요소와 같습니다. 개발자로서 일반적인 기능을 새롭게 만들 필요 없이 바퀴를 다시 발명할 필요가 없습니다. 마치 잘 작성되고 테스트된 코드 저장소를 편하게 사용할 수 있는 것과 같습니다.\n\n이러한 라이브러리의 양이 많아서 한 가지 솔루션에 갇히지 않습니다. 내 요구에 가장 적합한 것을 항상 선택할 수 있습니다. 이러한 라이브러리의 오픈 속성은 투명성과 책임성을 장려합니다. 또한 소스 코드를 살펴볼 수 있고 내부 작동 방식을 이해할 수 있으며 개선 작업에 기여할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJava에서는 Jackson 및 Gson과 같은 JSON 파싱 라이브러리, Log4j, SLF4j 및 LogBack와 같은 로깅 라이브러리, JUnit, Mockito 및 PowerMock를 포함한 유닛 테스트 라이브러리, 데이터베이스 연결 라이브러리, 메시징 라이브러리 등이 포함된 오픈 소스 라이브러리 목록이 있습니다.\n\n또한 Java는 다양한 프레임워크의 확장성이 있어서 널리 알려진 프로그래밍 언어입니다. Spring과 Springboot는 제가 좋아하는 조합 중 하나입니다. 또 다른 제가 작업한 프레임워크로는 Jakarta Faces, Struts, Hibernate 및 Quarkus 등이 있습니다.\n\n# 9. 멀티스레딩\n\nJava는 멀티스레딩을 지원하여 데이터 처리, 사용자 상호작용 처리, 백그라운드 계산 관리 등을 동시에 처리할 수 있는 애플리케이션을 설계할 수 있습니다. Java는 Runnable 인터페이스를 구현하거나 Thread Class를 확장함으로써 멀티스레딩을 지원합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바의 java.util.concurrent 패키지는 ExecutorService, ScheduledExecutorService, Future, CyclicBarrier 등을 포함한 고수준 동시성 유틸리티를 제공하여 동시성 응용 프로그램을 개발하는 데 도움을 줍니다.\n\n```java\npublic class MyRunnable implements Runnable {\n   public void run() {\n       // 새로운 스레드에서 실행될 코드\n   }\n}\nMyRunnable myRunnable = new MyRunnable();\nThread myThread = new Thread(myRunnable);\nmyThread.start();\n```\n\n# 10. 자바의 객체지향적 특성\n\n여러분이 생각하는 것을 알고 있어요: 자바는 유일한 객체지향 언어가 아니기 때문에, Python이나 C와 같은 언어와 무엇이 다른 점을 만드는 걸까요? 실제로 어떤 프로그래밍 언어들은 객체지향의 요소를 채택하거나 객체지향 개념을 지원하는 기능을 도입한 반면, 자바는 객체지향 원칙을 처음부터 고려하여 설계되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바는 추상화, 상속, 다형성, 캡슐화와 같은 객체 지향 원칙을 준수하여 복잡하고 확장 가능하며 유지보수가 용이한 소프트웨어 시스템을 구축하는 데 좋은 선택지입니다. 자바가 OOP 패러다임을 지원하는 데서 얻을 수 있는 많은 혜택이 있습니다. 이러한 혜택으로는 모듈화, 유연성, 가독성, 유지보수 용이성 및 확장 가능성이 포함됩니다.\n\n# 11. 메모리 관리와 가비지 컬렉션\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_4.png)\n\n출처: Digital Ocean\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n솔직히 말해서, 쓰레기를 버리는 걸 싫어해요. 그 일은 항상 귀찮게 느껴지는 가사일 중 하나에요. 많은 분들이 공감하실 거예요. 수동 메모리 관리에서는 개발자가 메모리를 할당하고 해제해야 하는 책임이 있어요. 마치 쓰레기를 버릴 때와 같이 언제 어떻게 각 조각을 처분할지를 결정하는 것과 비슷해요. 쓰레기를 버리는 것을 잊어버리면 혼란스러운 상황이 생기듯, 메모리를 해제하는 것을 잊어버리면 메모리 누수와 성능 문제가 발생할 수 있어요.\n\n자바의 자동 메모리 관리를 생각해보세요. 신뢰할 수 있는 쓰레기 수거 서비스가 있는 것과 같아요. 자바에서는 쓰레기 수거자가 성실하게 메모리를 식별하고 폐기하는 역할을 합니다.\n\n저는 자바로 전향하기 전 C++을 사용한 경험이 있어요. C++는 메모리 관리에 대한 막연한 통제를 제공하지만 메모리 누수가 없는지 확인하기 위한 개발자로서의 책임도 크지요.\n\n반면 자바에서는 저수준 시스템 기술적인 세부사항이나 수동 쓰레기 수거, 기본 OS 또는 메모리 할당 및 해제 추적에 대해 걱정할 필요가 없어요. 쓰레기 수거자가 더 이상 필요하지 않은 메모리를 자동으로 식별하고 회수합니다. 이로 인해 메모리 누출의 위험을 줄일 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표준 프로파일러.\n\nVisualVM.\n\nVisualVM은 Java 애플리케이션의 내부 작동을 이해하는 데 필수적인 도구입니다. JConsole 및 VisualGC를 통합하여 쓰레드, 힙 사용량 및 CPU 프로파일링을 모니터링할 수 있는 시각적인 플레이그라운드를 제공합니다. 또한 다양한 JDK 유틸리티와 원활하게 작동하여 신뢰할 수 있는 도구로 유용합니다.\n\nYourKit.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로파일러는 내 도구 상자에 비밀 요원이 있는 것 같아요. 이것은 메소드 수준의 세부 정보를 깊이 파고들어 실행 시간과 메모리 할당을 드러냅니다. 이것은 클라우드, 컨테이너 및 클러스터 환경에서 프로파일링하는 간단하고 쉽고 안전한 방법을 제공합니다.\n\nAPM 도구.\n\n뉴 렐릭.\n\n뉴 렐릭은 어플리케이션 성능 모니터링 (APM)에 가장 좋은 선택지예요. 내 애플리케이션을 24시간 내내 감시하는 개인적인 비서가 있는 느낌입니다. 실시간 통찰력부터 자세한 트랜잭션 추적까지. 경고 기능은 예기치 않은 동작에 대해 알림을 받도록 하는 안전망이에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 표로 변경해주세요.\n\nAppDynamics.\n\nAppDynamics, 나의 성능 아티스트! 데이터베이스 및 서버부터 클라우드 네이티브 및 하이브리드 환경까지 전체 기술 스택을 모니터링, 관찰 및 시각화하는 전체적인 방법을 취합니다. 성능이 최종 사용자에 미치는 영향을 이해하는 데 도움을 주어 감사합니다. 이로써 이는 모니터링 도구뿐만 아니라 사용자 만족 도구가 됩니다.\n\nLogging Solutions.\n\nLog4j.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 로깅 프레임워크의 노인 같은 존재입니다. 믿고 의존할 수 있게 이벤트와 오류를 충실하게 기록해 왔습니다. 애펜더와 필터를 구성하는 유연성 덕분에 로깅 필요에 신뢰할 수 있는 일말의 일력으로 떠드는 중입니다.\n\nSLF4J.\n\nSLF4J는 바로 내 로깅 스위스 아미 나이프 같은 존재입니다. 직접 로그를 남기지 않고 퍼사드 역할을 하며, 서로 다른 로깅 구현체들을 편리하게 연결할 수 있게 해줍니다. 이 유연성 덕분에 라이브러리의 로깅 기본 사양을 준수하는 다양한 작업 시 슬기로운 선택지가 됩니다.\n\nJava에서의 관측 가능성.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다이그마: Continuous Feedback (FC).\n\n코드가 실제 세계에서 어떻게 실행되는지 보지 못하면, 설계 결정을 내릴 수 없고 변경 사항의 영향을 평가할 수 없습니다. 관측 가능성과 코드 사이의 루프를 닫음으로써, 다이그마는 새로운 개발 방법을 열어줍니다.\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_5.png)\n\n다이그마는 Continuous Feedback(CF) 도구로, OTEL 관측 가능성 소스에서 코드에 대한 데이터를 수집하고 처리하는 작업을 간소화하도록 설계되었습니다. 다이그마는 IDE 플러그인으로 로컬에서 실행되며, 코딩하는 동안 추적부터 로그 및 지표까지 코드에 대한 데이터를 수집합니다. 이는 실시간으로 문제를 발견하고 통찰력을 얻을 수 있음을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로메테우스와 그라파나.\n\n프로메테우스와 그라파나, 나의 다이내믹 듀오! 프로메테우스는 나의 애플리케이션에서 메트릭을 수집하고, 그라파나는 이러한 메트릭을 아름답고 사용자 정의 가능한 대시보드로 변환해줍니다. 이 도구들 주변의 활발한 커뮤니티와 오픈 소스 성격 때문에 이 둘은 나의 다이내믹한 관측성 듀오입니다.\n\nElastic Stack (ELK).\n\n인공 지능과 검색 기술을 기반으로 한 오픈형, 확장 가능한 풀 스택 관측성입니다. 일라스틱서치, 로그스태시, 키바나는 함께 로그를 검색, 분석 및 시각화하기 위한 강력한 도구를 구성합니다. 로그, 메트릭 및 추적을 상호 연관시킬 수 있는 능력은 나에게 완전한 조사 툴킷을 제공해줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 13. 함수형 프로그래밍 지원\n\n자바는 자바 8부터 지원하는 또 다른 프로그래밍 패러다임인 함수형 프로그래밍을 제공합니다. 함수형 프로그래밍에서는 함수를 일급 시민으로 취급하여 변수에 할당하거나 인수로 전달하고 반환할 수 있습니다.\n\n이 패러다임의 일부 기능으로 자바는 매력적인 프로그래밍 언어가 되었습니다. 자바의 함수형 프로그래밍 기능을 받아들이면서 개발자로서 제 삶에 큰 영향을 주었습니다. 람다 표현식과 함수형 인터페이스의 도입으로 코드를 더 간결하고 표현력 있게 작성할 수 있었습니다. 멀티코어 프로세서에서 병렬 처리를 활용할 수 있는 Stream API 덕분에 제 애플리케이션의 성능을 향상시킬 수 있었습니다.\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\npublic class Main {\n    public static void main(String[] args) {\n        List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(1, 2, 3, 4, 5));\n\n        int sum = list.stream().reduce(0, (a, b) -\u003e a + b);\n        System.out.println(sum);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n델리클러티브 스타일을 채택하면 함수형 프로그래밍에서 권장하는 대로 코드가 더 읽기 쉽고 이해하기 쉬워집니다. 불변성을 강조하고 부작용을 피하는 것이 실제로 영향을 미쳤으며, 코드를 더 예측 가능하고 유지보수 가능하게 만들었습니다. 그리고 테스트에 있어서 순수 함수의 보편성은 테스트하기 쉬워졌다는 것을 알았어요.\n\n## 14. 자바의 풍부한 문서화\n\n팀 프로젝트에 참여할 기회가 있다면 문서화의 중요성을 분명히 이해하게 될 것입니다. 저는 개인적으로 문서화를 코드가 무엇을 하는지, 어떻게 하는지, 그리고 왜 그렇게 하는지 설명해주는 사용자 매뉴얼로 간주합니다. 그리고 자바를 배우는 초보자라면, 그것은 마치 옆에서 멘토가 함께하는 것과 같습니다.\n\n문서에는 다양한 코드 샘플, 튜토리얼, 개발자 가이드, API 문서 등이 포함되어 있어서 프로토타입을 빠르게 개발하고 실제 응용 프로그램으로 스케일을 확장할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문서는 최신 상태가 아니면 별로 도움이 되지 않습니다. Java의 문서는 생태계의 새로운 개발 내용을 개발자와 전문가들이 반영하기 위해 정기적으로 최신 상태로 유지되며 개정됩니다. 또한 문서는 특정 클래스, 메소드 또는 개념에 대한 정보를 쉽게 찾을 수 있도록 구조화되어 있습니다.\n\n# 15. 빌드 도구 및 의존성 관리\n\n평균적인 Java/Spring 부트 프로젝트는 직접 및 간접 의존성이 수십 개에서 수백 개가 될 수 있습니다. 특히 대규모 기업 프로젝트를 처리할 때 버전 호환성과 같은 문제로 인해 이러한 의존성을 수동으로 관리하는 것은 머리아플 수 있습니다. 빌드 도구를 활용하면 여러 개발자가 로컬에서 빌드를 실행하는 상황에서 이산된 빌드를 통합할 수 있습니다.\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 Maven 및 Gradle과 같은 빌드 도구는 빌드, 테스트 및 종속성 관리를 간소화하여 개발자로서 일을 더 쉽게 만듭니다. 이러한 도구들은 시작부터 여러분이 다양한 종속성에 대한 업데이트와 보안 패치에 대해 알아야 하는 불편함을 덜어줍니다. 저장소에서 종속성을 가져와 자동으로 업데이트를 확인하므로 직접 업데이트 정보를 찾아가지 않아도 됩니다.\n\n빌드 도구는 또한 프로젝트 구조 및 구성에 대한 관례와 표준을 강제하므로 다른 Java 개발자 팀과 함께 작업하기 쉽고 이해하기 쉽습니다.\n\n# 16. 견고한 테스트 기능\n\n우리 개발자들이 버그를 해결하고 QA 엔지니어와 협업하는 것을 꺼리지만, 포괄적인 테스트는 응용 프로그램이 가능한 한 버그가 없도록 보장하는 가장 효과적인 방법 중 하나라고 인정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n견고한 테스트 기능을 갖춘 언어를 선택하면 부담이 줄어들고 더 신뢰할 수 있고 유지보수가 쉬운 코드베이스를 구축하는 데 도움이 됩니다. 그것이 왜 나는 Java를 버그가 없는 소프트웨어를 만들기 위한 기본 프로그래밍 언어로 지지하는 이유 중 하나입니다.\n\n단위 테스트, 통합 테스트, 또는 종단간 테스팅이든 Java는 포괄적인 테스트를 작성하기 위한 도구 세트를 제공합니다. JUnit은 Java의 단위 테스트의 표준입니다. 테스트를 작성하고 실행하기 위한 간단하고 우아한 방법을 제공합니다. JUnit은 @Test, @Before, @After, @BeforeClass, @AfterClass와 같은 어노테이션을 사용하여 테스트 메서드의 라이프사이클을 정의합니다. 이를 통해 테스트를 실행하기 전에 사전 조건을 설정할 수 있습니다.\n\n개발자들이 버그를 해결하고 QA 엔지니어들과 협업하는 것을 꺼리지만, 아플리케이션이 가능한 한 버그가 없는 것을 보장하는 가장 효과적인 방법 중 하나가 포괄적인 테스트임을 인정합니다.\n\n견고한 테스트 기능을 갖춘 언어를 선택하면 부담이 줄어들고 더 신뢰할 수 있고 유지보수가 쉬운 코드베이스를 구축하는 데 도움이 됩니다. 그것이 왜 나는 Java를 버그가 없는 소프트웨어를 만들기 위한 기본 프로그래밍 언어로 지지하는 이유 중 하나입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단위 테스트, 통합 테스트 또는 엔드투엔드 테스트든, Java는 포괄적인 테스트를 작성할 수 있는 풍부한 도구 세트를 제공해요. JUnit은 Java에서 단위 테스트의 표준이며 간단하고 우아한 방식으로 테스트를 작성하고 실행할 수 있어요. JUnit은 @Test, @Before, @After, @BeforeClass, @AfterClass와 같은 주석을 사용하여 테스트 메서드의 라이프사이클을 정의합니다. 이를 통해 테스트 실행 전 사전 조건을 설정할 수 있어요.\n\n```java\n// EmployeeServiceTest.java\nimport org.junit.jupiter.api.Test;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n@SpringBootTest\npublic class EmployeeServiceTest {\n    @Mock\n    private EmployeeRepository employeeRepository;\n    @InjectMocks\n    private EmployeeService employeeService;\n    @Test\n    public void testGetAllEmployees() {\n        // Mocking repository response\n        when(employeeRepository.findAll()).thenReturn(new ArrayList\u003c\u003e());\n        // Test case for getAllEmployees method\n        List\u003cEmployee\u003e result = employeeService.getAllEmployees();\n        // Assertion\n        assertEquals(0, result.size());\n        // Verify that the repository method was called\n        verify(employeeRepository, times(1)).findAll();\n    }\n}\n```\n\nJUnit을 사용하여 테스트를 작성하는 것은 간단하고, Eclipse, IntelliJ IDEA, NetBeans와 같은 인기있는 Java IDE(통합 개발 환경)와 원활하게 통합됩니다.\n\nJava 생태계에서 테스트하는 데 유용한 다른 도구로는 통합 테스트용 TestNG, 행동 주도 개발에 대한 Cucumber, 기능 및 회귀 테스트 케이스를 자동화하는 Selenium이 있습니다. Mockito는 JUnit 및 TestNG와 함께 사용할 수 있는 강력한 mocking 프레임워크입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 17. 대규모 커뮤니티\n\n자바 커뮤니티는 나의 자바 개발자로서의 여정에서 중요한 역할을 해왔습니다. 자바 커뮤니티로부터 도움과 지침을 여러 차례 구했는데 그 횟수를 셀 수 없을 정도입니다. 버그에 막혔을 때, 새로운 라이브러리를 탐구할 때, 새로운 솔루션을 구현할 때 최고의 실천 방법을 찾을 때, 커뮤니티는 매우 가치 있는 정보의 근원임이 증명되었습니다.\n\n자바 커뮤니티는 가장 응답이 빠른 커뮤니티 중 하나이며 거의 즉각적으로 도움을 받을 수 있습니다. 예를 들어, 저는 수천 명의 자바 개발자로 이루어진 레딧의 r/java 커뮤니티의 일원입니다. Stack Overflow와 GitHub와 같은 다른 플랫폼의 커뮤니티 또한 초보자부터 베테랑 전문가까지 다양한 개발자들이 포함되어 있습니다. 이 다양성은 각종 도메인과 경험 수준을 다루는 다양한 전문성이 있음을 의미하여 강점으로 작용합니다.\n\n온라인 커뮤니티 외에도 여러 자바 이벤트, 컨퍼런스, 그리고 밋업을 통해 개발자들이 직접 만나 경험을 공유하고 서로 배우는 기회를 제공합니다. 이러한 모임들은 네트워킹과 협업을 촉진하여 자바 개발자 커뮤니티 감각에 기여합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 18. 자바 어노테이션 지원\n\n자바 어노테이션은 매우 인기 있는 주제이지만 논란이 많습니다. 어노테이션은 자바 5에서 소개되었고, 우리 모두 흥분했습니다. 개인적으로도 이 열정을 나눴습니다. 어노테이션의 도입은 확장된 Hibernate 또는 Spring XML 구성 파일 시대에서 떠났음을 나타냈습니다. 대신, 어노테이션을 사용하여 우리는 필요한 곳에 정확하게 정보, 지시 또는 구성을 직접 내장할 수 있게 되었습니다.\n\nPredefined annotations\n@Deprecated\n@Override\n@SuppressWarnings\n@SafeVarargs\n@FunctionalInterface 2. Meta-annotations\n@Retention\n@Documented\n@Target\n@Inherited\n@Repeatable 3. Custom annotations\n우리만의 사용자 정의 어노테이션을 만들 수도 있습니다.\n\n자바 어노테이션은 확실히 외부 문서를 참조할 필요성을 줄이는 것으로 코드의 명확성과 표현력을 향상시켰습니다. 어노테이션은 반복적인 작업이나 구성을 캡슐화하여 일부 보일러플레이트 코드를 줄이는 데 도움이 될 수도 있습니다. 예를 들어, 어노테이션을 사용하여 의존성 주입, ORM 매핑, 트랜잭션 범위와 같은 측면을 정의할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 개발자들은 주석이 편리하고 여러 이점이 있지만, 일부 주석에 대해 의심을 품고 있는 것 같아요.\n\n# 보안 기능\n\n우리가 작성하는 프로그램은 코드 라인뿐만 아니라, 개인 사용자 데이터, 금융 세부 정보 및 독점 비즈니스 정보와 같은 민감한 정보도 처리합니다. 사용자는 우리에게 그들의 정보를 보호하고 안전한 환경을 제공하기를 기대합니다. 소프트웨어 개발이나 혁신에 관여하는 비즈니스에 대해, 의지재산 침탈을 예방하기 위해 애플리케이션을 보호하는 것이 중요합니다. 소스 코드, 알고리즘 및 독점 정보를 보호하는 것은 경쟁 우위를 유지하는 데 중요합니다.\n\nJava는 안전한 애플리케이션을 개발하기 쉽게 하는 많은 기능을 가지고 있어요. 이러한 기능 중 일부에는 암호화, 공개 키 인프라, 안전한 통신, 인증 및 접근 제어가 포함됩니다. 암호화에서부터 스마트 카드 I/O 및 안전한 통신을 보장하는 인증 프로토콜에 이르기까지, Java 애플리케이션에 보안 조치를 원활하게 통합할 수 있는 다양한 API 및 도구에 접근할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 목록은 완전하지 않아요. 공식 Java 보안 가이드에서 더 많은 기능을 배울 수 있어요.\n\n# 20. RICH API SET\n\n![이미지](/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_7.png)\n\nJava는 풍부한 응용 프로그램 프로그래밍 인터페이스(APIs) 세트로도 알려져 있어요. 이들은 여러 소프트웨어 구성요소, 라이브러리 및 서비스와 상호 작용하는 표준화된 방법을 제공해요. 이 API에는 준비된 기능을 제공하는 미리 컴파일된 클래스, 인터페이스 및 메소드들의 풍부한 컬렉션이 포함되어 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n차를 처음부터 만들고 있다고 가정해보겠습니다. Java API를 사용하면 이미 제조업체로부터 입수한 부품들을 조립하는 것과 같은 느낌을 받게 됩니다. 즉, 부품을 직접 제조하는 대신 필요한 부품들을 조립하는 방식입니다. 이 경우, 필요에 딱 맞는 API를 선택할 수 있는 유연성이 있습니다. 이 API들은 표준화되어 있고 잘 문서화되어 있어 사용하기 쉽습니다.\n\nJava의 API가 가지고 있는 장점은 구성 요소 빌드의 복잡한 세부 사항들을 추상화하여 완전히 기능적인 자동차를 조립하는 데 집중할 수 있게 해준다는 점입니다. 이 API들을 사용하여 네트워킹, IO, 파일 처리, 데이터베이스 연결, 멀티스레딩 등 다양한 도메인에서 다양한 작업을 수행할 수 있습니다.\n\nJava API는 여러 패키지로 구성되어 있습니다. 가장 일반적인 것들 중 일부는 java.lang, java.util, java.io, java.net 등이 있습니다.\n\n# 21. JAVA의 성능\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 이유는 Java를 오랜 기간 동안 사용하게 한 것은 Java의 성능이 지속적으로 향상되는 것을 목도하면서, 이것이 주 프로그래밍 언어로서의 선택을 유효하게 만들었습니다.\n\n성능 면에서의 이러한 개선은 문제를 해결하는 데 큰 도움을 주었으며, 현대 고객을 대상으로 하는 성능 우수한 응용 프로그램을 개발할 수 있는 기회를 제공했습니다. 몇 가지 주목할 만한 것도 있습니다.\n\n예를 들어, Java 가상 머신(JVM)은 각 새로운 릴리스마다 상당한 최적화가 이루어졌습니다. Just-in-time(JIT) 컴파일러의 개선, 가비지 수집 기능의 향상, 그리고 더 나은 런타임 프로파일링이 함께 빠른 실행과 낮은 메모리 소요를 기여했습니다.\n\nProject Valhalla는 값 타입을 도입하여 더 효율적이고 간결한 데이터 구조를 정의할 수 있게 했습니다. 이는 메모리 소모를 줄이고 캐시 지역성을 향상시키며, 특히 대량의 데이터가 있는 시나리오에서 상당한 성능 향상을 가져왔습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근에 JDK 21에서 키 캡슐화 메커니즘 API, 가상 스레드, 및 문자열 템플릿 및 구조화된 동시성 미리보기와 같은 15개의 기능이 도입되었습니다. 이러한 변경 사항은 자바를 크게 향상시킵니다.\n\n# JDK 21에서 가상 스레드와 기타 기능으로 한 발 LEAP FORWARD\n\n# 22. 구조화된 동시성\n\n제안된 구조화된 동시성을 위한 API는 JDK 21의 주요 기능으로 유지되며 관련 작업 그룹을 다른 스레드에서 단일 작업 단위로 다루어 동시 프로그래밍을 간단하게 하는 것을 목표로 합니다. 이 접근 방식은 오류 처리, 취소, 신뢰성 및 관측성을 향상시킵니다. 이 기능은 java.util.concurrent의 기존 동시성 구조를 대체할 목적이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기능을 통해 ExecutorService 및 Future와 같은 기존 구조를 활용하여 병행 프로그래밍에서 작업 및 하위 작업을 관리하는 복잡성을 제거할 수 있습니다. 작업과 하위 작업 간의 내재적인 관계 부재로 오류 처리, 취소 및 관찰에 어려움이 있습니다. 제안된 구조화된 동시성 접근 방식은 코드의 구문 구조를 작업의 실행 계층 구조와 일치시켜 주어 병행 프로그래밍을 더 가독성 있고 유지보수가능하며 신뢰할 수 있도록 합니다.\n\n# 23. 가상 스레드\n\n처음에는 JDK 19 및 JDK 20에서 미리보기 기능으로 소개되었지만 이제 JDK 21에서 공식적으로 도입된 가상 스레드입니다. java.lang.Thread의 각 인스턴스는 일반적으로 여타 플랫폼 스레드에 연결되어 수명 주기 동안 기본 OS 스레드에 바인딩됩니다.\n\n그러나 가상 스레드는 패러다임 변화를 가져왔습니다. 여전히 java.lang.Thread의 인스턴스가 존재하지만 이제 Java 코드를 백그라운드 OS 스레드에서 실행하여 해당 스레드를 독점하지 않는 방식으로 작동합니다. 이 혁신은 여러 가상 스레드가 효율적으로 단일 OS 스레드를 공유할 수 있도록 합니다. 플랫폼 스레드와는 달리 가상 스레드는 소중한 OS 스레드를 제한하지 않으며, 그 숫자는 OS 스레드의 제약을 크게 초월할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가상 스레드는 JDK 21의 매력적인 새로운 기능입니다. 이는 특히 동시 작업이 매우 많은 시나리오에서 애플리케이션 성능에 상당한 긍정적인 영향을 미칠 수 있습니다. 이러한 시나리오에서는 종종 수천 개 이상의 동시 작업이 발생합니다.\n\n이제 애플리케이션의 특정 요구 사항에 따라 가상 스레드와 전통적인 플랫폼 스레드 중에서 선택할 수 있는 유연성이 생겼습니다.\n\n# 24. SWITCH 문을 위한 패턴 매칭\n\n이 흥미로운 기능은 JDK 17 제안에서 시작되어 JDK 18, JDK 19 및 JDK 20에서 일련의 개선 작업을 거친 후, 이제 Java 커뮤니티의 피드백과 경험을 바탕으로 JDK 21의 일부로 정식으로 도입되어 추가로 발전했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기능의 주요 목적은 switch 표현식과 문장의 기능과 다양성을 확장하는 것입니다. 또한 경우 레이블에서 패턴이 더 중요한 역할을 하도록하여, null 값 처리에 대해 더 유연성을 제공하고, 패턴 switch 문을 사용하여 가능한 모든 입력 값에 대한 포괄적인 커버리지를 요구함으로써 switch 문을 더 안전하게 만드는 데 관한 것입니다.\n\n이미 switch 표현식과 문장을 사용하고 있다면 걱정하지 마세요. 목표는 어떠한 변경도 필요하지 않게 현재처럼 작동하도록 보장하는 것입니다.\n\n# 25. 문자열 템플릿\n\n문자열 템플릿이 Java에 도입되어, 개발자가 오래 전부터 바라왔던 문자열 보간을 지원하게 되었습니다. 지금까지 여러 문자열을 결합하거나 string.format을 사용해야 했는데, 솔직히 말해서 귀찮았습니다. 그러나 Java 21에서 우리는 즐거움을 느낄 것입니다. 이 새로운 기능은 개발자들에게 Java의 문자열 리터럴과 텍스트 블록을 문자열 템플릿으로 채울 수 있는 기능을 부여합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nint x = 10;\nint y = 20;\nString s = STR.\"\\{x} + \\{y} = \\{x + y}\";\n\n주요 목표는 런타임에서 컴파일될 수 있는 값들을 표현하는 데 있어서 동적 문자열 생성을 간소화하는 것입니다. 또 다른 목표는 StringBuilder 및 StringBuffer 클래스와 관련된 장황함을 해결하여 가독성을 향상시키는 것입니다. 마지막으로, 문자열 템플릿은 다른 프로그래밍 언어의 존재하는 문자열 보간 기술과 관련된 보안 문제를 극복하는 데 도움이 될 것입니다.\n\n# 요약\n\n자바는 더 쉽지는 않지만 더 나은 것이죠! 또한, 현대적인 자바는 매우 빠릅니다. 읽기 쉽고 - 유지 보수가 쉬워요. 자바에서 똑똑해지려고 애쓰는 것은 어렵습니다 - 록스타 동료들과 싸우지 않아도 됩니다. 그리고 모두 솔직해지자면, 우리는 급여에 관심이 있죠. 자바 개발자들은 높은 급여를 받습니다. 대부분의 기업과 대규모 조직에서 주 언어로 자바를 사용하기 때문에 많은 일자리가 있습니다. 아직 자바 8을 사용하고 행복해하는 사람들도 알고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n무료로 Digma를 설치하세요!\n\n# 자주 묻는 질문 (FAQ)\n\nJava가 인기 있는 프로그래밍 언어로 손꼽히는 이유는 무엇인가요?\n\nJava는 플랫폼 독립성, 견고함, 그리고 방대한 커뮤니티 지원으로 인해 인기를 얻었습니다. 웹 개발부터 기업 애플리케이션에 이르기까지 다양한 분야에서 널리 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대용량 엔터프라이즈 애플리케이션에 Java를 사용하는 이점은 무엇인가요?\n\nJava는 안정적이고 확장 가능한 환경을 제공하며, 멀티스레딩을 지원하며, Spring Boot와 같은 많은 라이브러리와 프레임워크로 엔터프라이즈 애플리케이션 개발을 단순화합니다.\n\nJava는 어떻게 크로스 플랫폼 개발을 지원하나요?\n\nJava는 \"한 번 작성하고, 모두에서 실행\" 원칙을 통해 크로스 플랫폼 호환성을 달성하며, Java 코드를 Java Virtual Machine (JVM)을 사용하는 모든 장치에서 실행할 수 있도록 합니다.\n","ogImage":{"url":"/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_0.png"},"coverImage":"/assets/img/2024-05-20-25REASONSWHYJAVAISSTILLAROUNDIN2024_0.png","tag":["Tech"],"readingTime":33},{"title":"스프링 부트 대 Go 프레임워크 데이터베이스 조회 성능","description":"","date":"2024-05-20 15:41","slug":"2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance","content":"\n\u003cimg src=\"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_0.png\" /\u003e\n\n안녕하세요! 이 글은 요청받은 기사입니다. 독자들이 Spring Boot와 가상 스레드를 비교하고 Gin, Fiber, Echo와 같은 인기 있는 Go 프레임워크를 최신 버전으로 비교해 달라고 요청했습니다. Spring Boot는 매우 포괄적이고 다양한 기능 세트를 갖춘 프레임워크인 반면에 언급된 Go 프레임워크들은 비교적 간단하며(Express와 유사한) 기능이 간단한 것에 유의해 주세요.\n\n이전 기사에서 우리는 가장 간단한 \"hello world\" 케이스에서 Spring Boot가 Go 프레임워크와 어떻게 맞붙는지 살펴보았습니다.\n\n이번 기사에서는 좀 더 실제적인 케이스에 초점을 맞출 것입니다: 데이터베이스 조회입니다. 간단한 사용 예는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- HTTP 요청 받기\n- 요청 본문(JSON)에서 userEmail 매개변수 추출하기\n- 추출된 이메일로 데이터베이스 조회 수행\n- HTTP 응답에서 사용자 레코드 반환\n\n# 테스트 설정\n\n모든 테스트는 MacBook Pro M2에서 16GB RAM 및 8+4 CPU 코어를 사용하여 실행되었습니다. 소프트웨어 버전은 다음과 같습니다:\n\n- SpringBoot 3.2.5 (Java 21.0.3)\n- Go 1.22.3\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테스트는 Bombardier 로드 테스터를 사용하여 진행됩니다.\n\n모바일 앱에서는 Bun ORM을 사용하고 있습니다 (Bun JS 런타임과 혼동하지 마세요).\n\n애플리케이션 코드는 다음과 같습니다:\n\nSpringBoot\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기록을 표시해왔던 다음과 같은 과정을 반복하셨습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 차트 형식으로 결과가 제공됩니다:\n\n- ![이미지1](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_1.png)\n- ![이미지2](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_2.png)\n- ![이미지3](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_4.png)\n\n![Image 2](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_5.png)\n\n![Image 3](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_6.png)\n\n![Image 4](/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_8.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_9.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_10.png\" /\u003e\n\n# 분석\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, Spring Boot와 Go 프레임워크는 매우 다릅니다. Spring의 기능 세트는 간단한 Go 프레임워크에 비해 너무 방대합니다.\n\n데이터베이스 읽기와 같이 I/O 집중적인 경우에는 Go 프레임워크가 Spring Boot에 비해 2배 빠릅니다. Go 측에서 가장 빠른 것은 38K RPS를 제공하는 Fiber입니다.\n\nSpring Boot의 CPU 사용량은 모든 Go 프레임워크와 비교할 만큼 유사합니다. 그러나 Spring Boot의 메모리 사용량은 Go 프레임워크와 비교했을 때 너무 높습니다.\n\n승자: Fiber\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에 비슷한 \"hello world\" 비교가 있습니다:\n","ogImage":{"url":"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_0.png"},"coverImage":"/assets/img/2024-05-20-SpringBootvsGoFrameworksDatabasereadPerformance_0.png","tag":["Tech"],"readingTime":5},{"title":"스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱","description":"","date":"2024-05-20 15:39","slug":"2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing","content":"\n![Spring Cloud Gateway](/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png)\n\nSpring Cloud Gateway는 Spring Boot 애플리케이션에서 API 게이트웨이를 구축하는 강력하고 유연한 솔루션을 제공합니다. 다양한 기능을 갖춘 Spring Cloud Gateway는 라우팅, 요금 제한, 보안 및 장애 관리를 처리할 수 있습니다.\n\n![Spring Cloud Gateway](/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_1.png)\n\n마이크로서비스 아키텍처 시대에는 견고하고 확장 가능한 시스템 구축이 중요합니다. Spring Boot와 Spring Cloud의 발전으로 개발자들은 이전 Netflix Zuul에 의존하지 않고도 견고한 마이크로서비스 기반 애플리케이션을 생성할 수 있는 강력한 도구를 사용할 수 있습니다. 이 블로그 포스트에서는 Spring Boot 3.0과 함께 Spring Cloud Gateway를 사용하여 현대적인 마이크로서비스 아키텍처를 어떻게 만들 수 있는지 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSpring Boot이 계속 발전함에 따라 더 최신 기술과 모범 사례에 적응하는 것이 중요합니다. Spring Boot 3.0에서는 마이크로서비스를 구축하기 위한 현대적인 솔루션에 중점을 두고 있습니다. Spring WebFlux 기반으로 구축된 강력한 API 게이트웨이인 Spring Cloud Gateway가 그러한 솔루션 중 하나로, 라우팅, 필터링, 로드 밸런싱과 같은 기능을 제공합니다.\n\n게이트웨이를 설명하기 위해 적합한 아키텍처가 필요합니다.\n\n- Eureka 서버: 마이크로서비스를 관리하기 위한 서비스 레지스트리 및 디스커버리 서버입니다. Eureka 서버와 함께 스프링 부트 프로젝트를 생성하세요.\n- Payment MS: 테스트를 위한 사용자 정의 마이크로서비스로, 웹 및 Eureka 클라이언트 종속성 및 설정이 있는 간단한 마이크로서비스입니다.\n- Spring Cloud Gateway: 적절한 마이크로서비스로 요청을 라우팅하는 API 게이트웨이입니다.\n\n아래 종속성을 가진 Spring Boot 애플리케이션을 만들어 보세요. Eureka는 서비스 디스커버리 서버로 사용될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성 테이블을 다음과 같이 변경해보세요:\n\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e\n    \u003cartifactId\u003espring-cloud-starter-netflix-eureka-server\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n- @EnableEurekaServer 주석을 사용하여 주 클래스에 Eureka 서버를 활성화하세요.\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class MyEurekaServerApplication {\n```\n\n```java\n public static void main(String[] args) {\n  SpringApplication.run(MyEurekaServerApplication.class, args);\n }\n}\n```\n\n그리고 My application.properties 파일에도 변경을 적용해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```bash\n// application.properties\neureka.client.fetch-registry=false\neureka.client.register-with-eureka=false\nserver.port=8761\nspring.application.name=MY-EUREKA-SERVER\n```\n\n아래 종속성을 사용하여 Spring Boot 어플리케이션을 생성하세요.\n\n```js\n\u003cdependency\u003e\n   \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n   \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n   \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e\n   \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e\n\u003c/dependency\u003e\n```\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n  \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e\n  \u003cscope\u003etest\u003c/scope\u003e\n\u003c/dependency\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버 포트를 출력하는 REST API를 작성해보세요. 이것은 테스트 중에 호출된 서비스의 어떤 인스턴스인지 식별하는 데 도움이 될 것입니다 [로드 밸런싱]\n\n```java\n@RestController\n@RequestMapping(\"/payment\")\npublic class PayController {\n```\n\n```java\n@Value(\"${server.port}\")\nprivate String serverPort;\n\n@GetMapping(\"/say\")\npublic String getMethodName() {\n    return new String(\"안녕하세요, Payment MS에서 온 메시지입니다. \"+serverPort);\n}\n```\n\n그리고 Eureka 서버 세부 정보를 추가하고 메인 클래스에 Eureka 클라이언트를 활성화하는 주석을 추가하는 것을 잊지 마세요 (@EnableDiscoveryClient)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class PaymentMsApplication {\n\n public static void main(String[] args) {\n  SpringApplication.run(PaymentMsApplication.class, args);\n }\n}\n```\n\n- 그리고 나의 MS를 위한 어플리케이션 프로퍼티\n\n```java\nspring.application.name=PAYMENT-SERVICE\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\nserver.port=9811 (어플리케이션을 실행하기 전에 다른 포트를 사용 중입니다)\neureka.instance.ip-address=localhost\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cdependency\u003e\n   \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e\n   \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n\u003c!--\nhttps://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-gateway --\u003e\n\u003cdependency\u003e\n   \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e\n   \u003cartifactId\u003espring-cloud-starter-gateway\u003c/artifactId\u003e\n   \u003cversion\u003e4.1.2\u003c/version\u003e\n\u003c/dependency\u003e\n\n그래서 최신 버전(내 경우 3.2.4v)의 스프링 부트 프로젝트를 만들고 위의 종속성을 추가합니다.\n\n- application.yml 파일에 라우팅 구성을 추가하십시오. `service-name` 프로토콜을 사용하여 API 게이트웨이에 서비스 검색을 지시합니다. 두 개의 payment-service 인스턴스가 있으므로 부하 처리가 필요하고 동적으로 처리해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\nspring:\n  application:\n    name: gateway\n  cloud:\n    gateway:\n      routes:\n        - id: payment-service\n          uri: lb://payment-service\n          predicates:\n            - Path=/payment/**\n```\n\n- API Gateway는 마이크로서비스로도 불리우며 유레카 서버에 등록되어야 합니다. 메인 클래스에 `@EnableDiscoveryClient`를 추가하지 않는 것을 잊지 마세요.\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ApiGtApplication {\n```\n\n```java\n public static void main(String[] args) {\n  SpringApplication.run(ApiGtApplication.class, args);\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 지금 테스트해 보세요!\n\n진행 방법:\n\n- 유레카 서버 실행\n- 포트 9810 및 9811에서 결제 서비스 실행\n- API 게이트웨이 서비스 실행\n\n![이미지](/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n브라우저에서 게이트웨이 엔드포인트를 방문해서 확인해보세요 (http://localhost:8080/payment/say)\n\n/payment은 술어 패턴입니다 — 이 패턴이 발생하면 API 게이트웨이는 요청을 지불 서비스로 라우팅하고 지불 서비스에는 컨트롤러 /payment과 GET 메소드 /say가 있습니다. 이것이 실행되어 응답을 게이트웨이로 반환합니다. 유레카는 API 게이트웨이로 인스턴스 정보를 보내기 위한 것이며 내부 통신을 위한 것이 아닙니다.\n\n독자 여러분의 읽어주셔서 감사합니다. 도움이 되었다면 공유하고 좋아요를 눌러주세요.\n","ogImage":{"url":"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png"},"coverImage":"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png","tag":["Tech"],"readingTime":8},{"title":"도메인을 최우선으로 하는 생각을 Hexagonal Architecture를 활용한 모듈식 단일체에 도입하기","description":"","date":"2024-05-20 15:36","slug":"2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture","content":"\n![Image](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png)\n\nPart 1:\n\nPart 2:\n\nIn the first blog, we explored the concept of Modular Monolith, what is a module and how DDD strategy patterns can be used to create modular applications.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 번째 블로그에서는 Spring Modulith가 모듈 모노리스 응용 프로그램에서 아키텍처 유효성 검사, 독립 모듈의 테스팅 및 이벤트 기반 통합을 어떻게 용이하게 하는지 살펴보았어요.\n\n이 블로그에서는 단일 모듈을 자세히 살펴보고 헥사고날 아키텍처가 핵심 비즈니스 로직의 유지보수성 및 테스트를 어떻게 향상시키는지 이해할 거에요. 또한 헥사고날 아키텍처가 DDD 및 모듈 모노리스 응용 프로그램의 맥락 속에 어떻게 맞는지도 이해할 거에요.\n\n헥사고날 아키텍처를 배우는 데 한 가지 어려움은 용어로 오인될 수 있다는 것이에요. 헥사곤 모양이나 숫자 여섯과는 아무런 상관이 없답니다. \"포트\"와 \"어댑터\"라는 용어가 과부하되어 있어서 여러분은 무엇을 의미하는지 배우기 전에 스스로의 해석을 잊어야 해요. 아키텍처의 층이 없다는 점(바깥쪽과 안쪽 이외에)과 의견이 분분하지 않은 아키텍처의 특성으로 인해 누구나 자신의 방식대로 구현할 수 있어요.\n\n나는 헥사고날 아키텍처를 이해하고 Java와 Spring Boot 응용 프로그램에서 적용하는 방법에 대해 시도했을 때, 헥사고날을 사용하지 않고 응용 프로그램을 작성한 후 문제를 겪고 하나씩 해결하여 어떤 것이 헥사고날인지 알아냈어요. 하지만 그것은 몇 년이 걸릴 수 있어요! 이 블로그(시리즈)에서는 이 과정을 더 짧은 시간 안에 기록하고 싶어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기업 문제를 해결하기 위한 애플리케이션을 개발하는 업무를 맡았습니다. 해당 애플리케이션은 웹을 통해 접속되며, 일부 비즈니스 로직을 구현하고 데이터를 데이터베이스에 저장할 것입니다 (당연히). 애플리케이션을 설계하는 과정에서 어떤 생각을 가지게 되시나요?\n\n- 웹 애플리케이션이어야 하므로, 최신하면서 반짝이는 자바스크립트 프레임워크(React?)를 사용하여 JSON을 제공하는 REST API 및 멋진 UI를 구축할 것입니다.\n- 비즈니스 요구 사항이 NoSQL DB를 필요로 하지 않는 한 관계형 데이터베이스를 사용할 것입니다.\n- 비즈니스 요구 사항을 바탕으로 여러 엔티티를 식별하고 ERD에 매핑할 것입니다.\n\n이런 내용이 익숙하시나요?\n\n3번 항목에 집중해 봅시다. ERD 여부와 상관없이, 데이터 모델을 도출하기 위해 여러 엔티티를 식별하고 그것을 시간이 흘러도 발전시킬 수 있는 것은 모든 웹 백엔드 엔지니어가 해야 하는 일이며 시작점이 될 수도 있습니다! 저는 이를 여러 차례 경험해 보았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법은 (의식적인 아키텍처가 적용되지 않을 때 기본으로 사용되는) 계층화된/N계층 아키텍처로 구성된 애플리케이션을 만들게 됩니다. 데이터 모델은 JPA 엔티티로 구성되며, Repositories를 통해 영속화되고, 비즈니스 로직은 Services에 구현됩니다.\n\n이러한 구현의 핵심 특성 중 하나는 비즈니스 로직(Services)이 데이터 모델에서 작동하며 데이터베이스에 의존하는 것입니다. 특히 JPA/JDBC가 실제 데이터베이스 기술을 추상화하고 있기 때문에 바로 알아차리기 어렵습니다. 하지만 데이터베이스 구현(테이블 구조, 외래 키 관계, 인덱스 등)이 비즈니스 로직 구현을 주도하는 것이 아니라 그 반대로 작용하고 있습니다. 아래 그림에서 보듯이, 애플리케이션 서비스는 Spring과 JPA/Hibernate와 같은 기술과 강하게 결합됩니다.\n\n![이미지](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_1.png)\n\n## 의존성 역전\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 이제 우리는 다르게 생각하고 문제에 접근해 보겠습니다. 데이터 모델에 초점을 맞추는 대신, 비즈니스 로직과 제약 조건을 포착하는 여러 클래스를 만들어 보겠습니다. 이를 도메인 모델이라고 부르겠습니다.\n\n이 접근 방식에서는, 서비스가 스프링 데이터 리포지토리를 직접 사용하는 대신, 의존성을 반전시키기 위해 인터페이스를 도입하여 서비스가 필요로 하는 동작을 정의하고 이것이 어떻게 구현되었는지 신경쓰지 않습니다. 실은 스프링 데이터 리포지토리는 Java 인터페이스로 정의되어 있지만, 다이내믹 프록시를 통해 구현을 결합하는 인터페이스는 아닙니다.\n\n의존성을 반전시키기 위해 사용된 인터페이스를 포트(port)로, 인터페이스의 구현은 어댑터(adapter)로 부릅니다. 이들은 도메인 모델에 의해 주도(들어온)되므로 주도 또는 보조(secondary)로 알려져 있습니다. 이는 헥사고날 아키텍처에서 사용되는 용어입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한편, 유스 케이스를 구현하는 데 사용되는 Application 서비스도 포트입니다. 차이점은 Java 인터페이스가 아니라 일반 클래스임을 의미합니다. 또한 해당 어댑터와 함께 사용됩니다. 이 어댑터는 기술을 접근하여 우리의 사용 사례에 연결합니다(REST API, GraphQL, 람다 등). 이러한 포트와 어댑터는 도메인 모델을 사용하므로 드라이버 또는 주요 요소로 알려져 있습니다. 이들은 우리 모델의 사용을 이끌어냅니다.\n\n![그림 안내](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_3.png)\n\n기본 및 보조 포트와 어댑터를 결합하면 헥사고날(또는 포트 및 어댑터) 아키텍처로 이어집니다.\n\n새로운 접근 방법을 적용하는 데 도움이 되도록 몇 가지 제약 조건을 소개해 보겠습니다. 우리는 프레임워크/구현이 우리의 생각을 이끌도록 허용하지 않겠습니다. 이는 데이터베이스 라이브러리 (JPA/JDBC), 이벤트 프레임워크 (Apache Kafka) 및 애플리케이션 프레임워크 (Spring)를 배제한다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n남은 것은 순수한 자바 (또는 응용 프로그램을 개발하는 언어)와 해당 비즈니스 로직 구현의 단위 테스트입니다.\n\n잠시 후에 기존 응용 프로그램을 위의 과정을 따르도록 리팩터링할 것입니다. 하지만, 이것을 왜 신경 써야 할까요? 어떤 이점이 있을까요?\n\n## 핵심 비즈니스 로직은 구현 세부 정보에서 자유롭습니다\n\n비즈니스 로직을 반영하는 도메인 모델(도메인 또는 내부라고 부르겠습니다)은 구현 세부 정보(인프라스트럭처 또는 외부라고 부르겠습니다)에 영향을 받지 않습니다. 새로운 기능 요청을 구축해야 하나요? 도메인 모델에서 구현하고 단위 테스트로 유효성을 검사하세요. Spring Boot나 Hibernate를 업데이트해야 하나요? 걱정 마세요, 도메인 모델은 영향을 받지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 도메인 모델이 구현을 주도합니다\n\n도메인 모델은 아키텍처의 핵심에 있습니다. 다른 모든 것은 도메인 모델에서 출발합니다. 비즈니스 로직의 구현을 주도합니다. 이전에 구현을 주도했던 데이터 모델은 이제 영속성에만 관련된 사소한 세부사항입니다. REST API가 필요하다면, 스케줄러가 필요하다면 밤에 실행되는 확인 작업을 주도해야 한다면, AWS 람다를 트리거해야 한다면 — 이 모든 것은 도메인 모델과는 상관이 없습니다.\n\n## 지연된 결정\n\n어떤 사용 사례에 관계형 데이터베이스를 사용해야 할지 아직 확실하지 않나요? 아키텍트가 REST 대 GraphQL 사용에 대한 궁금증에 대답하지 않았나요? 그런 결정들이 비즈니스 로직의 구현을 막아선 안됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좋아요, 이제 새로운 사고 방식으로 비즈니스 로직을 작성하여 도서관 사용 사례를 구현하는 방법을 살펴볼까요?\n\n## 대여 Bounded Context (헥사고날 아키텍처로 구현)\n\n아래의 패키지 구조로 대여 모듈을 구성할 것입니다. 응용 프로그램 및 도메인 패키지는 헥사곤의 \"내부\"를 나타내고 인프라스트럭처 패키지는 \"외부\"를 나타냅니다.\n\n```js\nsrc/main/java\n└── example\n    ├── borrow\n    │   ├── application\n    │   │   └── ...\n    │   ├── domain\n    │   │   └── ...\n    │   └── infrastructure\n    │       └── ...\n    └── LibraryApplication\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 규칙을 패키지에 대해 따를 것입니다 (모두에게 해당되는 보편적인 규칙이 아니고, 우리가 직접 정한 것입니다). 이 구현의 복잡성과 아키텍처 원칙을 엄격하게 준수하는 현실적인 접근 사이의 적절한 균형을 유지하고 있다고 생각합니다.\n\n- 도메인 패키지에는 도메인 모델(Aggregates, Entities, Value Objects) 및 인프라스트럭처가 구현할 인터페이스를 제공하는 Secondary / Driven 포트가 포함됩니다. 우리는 표준 자바, Lombok(많은 코드를 줄이기 위한) 및 JMolecules(스테레오타입을 문서화하기 위해) 라이브러리만 사용할 것입니다.\n- 애플리케이션 패키지에는 애플리케이션의 유스케이스를 구현하는 Primary / Driver 포트가 포함됩니다. 우리는 Spring의 @Transactional 및 Modulith의 @ApplicationModuleListener 주석을 사용할 수 있습니다.\n- 인프라스트럭처 패키지에는 REST API 및 JPA 어댑터를 빌드하는 코드가 포함됩니다. 이것은 야생 서부입니다. 제한 사항이 없으며, 모든 라이브러리를 자유롭게 사용할 수 있습니다.\n\n책을 대출하는 사용 사례를 살펴보겠습니다. 사용자는 이용 가능한 책에 예약을 할 수 있습니다. 아래는 사용 사례를 구현하는 주요 포트의 Java 예시입니다. @PrimaryPort 주석이 어디서 온 것인지 궁금하다면 계속 읽어보세요!\n\n```java\n@PrimaryPort\npublic class CirculationDesk {\n\n    private final BookRepository books;\n    private final HoldRepository holds;\n    private final HoldEventPublisher eventPublisher;\n\n    @Transactional\n    public HoldDto placeHold(PlaceHold command) {\n        books.findAvailableBook(command.inventoryNumber())\n                .orElseThrow(() -\u003e new IllegalArgumentException(\"Book not found\"));\n\n        return Hold.placeHold(command)\n                .then(holds::save)\n                .then(eventPublisher::holdPlaced)\n                .to(HoldDto::from);\n    }\n\n    record PlaceHold(Barcode inventoryNumber,\n                     String patronId,\n                     LocalDate dateOfHold) {\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성을 역전시키기 위해, 모든 집합체를 위한 Repository 인터페이스를 도입했습니다 (Spring Data와는 혼동하지 마세요).\n\n```js\n@SecondaryPort\n인터페이스 BookRepository {\n\n    Optional\u003cBook\u003e findAvailableBook(Book.Barcode inventoryNumber);\n\n    Optional\u003cBook\u003e findOnHoldBook(Book.Barcode inventoryNumber);\n\n    Book save(Book book);\n\n    Optional\u003cBook\u003e findByBarcode(String barcode);\n}\n\n@SecondaryPort\n인터페이스 HoldRepository {\n\n    Hold save(Hold hold);\n\n    Optional\u003cHold\u003e findById(Hold.HoldId id);\n\n    List\u003cHold\u003e activeHolds();\n}\n```\n\nCirculationDesk 응용 프로그램 서비스는 위의 리포지터리 인터페이스를 사용합니다. 이를 통해 구현 기술(Spring Data, JPA, JDBC 등)과 독립시켰습니다.\n\n## 집합체로부터 도메인 이벤트 트리거하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하나의 사용 사례 결과는 Aggregate의 업데이트된 상태를 지속시키는 것입니다. 또 다른 결과는 도메인 이벤트를 발생시켜 모노리스의 다른 모듈 (또는 동일 모듈 내의 다른 Aggregate)에서 대응할 수 있도록 하는 것일 수 있습니다.\n\nAggregate를 지속시키는 것 (Repository 사용)과 이벤트를 발생시키는 것 (Event Publisher 사용)은 헥사고날 아키텍처에서 이차/드라이븐 포트입니다. 구현은 비즈니스 로직과 관련이 없습니다.\n\n사용 사례 실행 후에는 BookPlacedOnHold 이벤트가 발생합니다. 이 이벤트는 Book Aggregate에서 도서 상태를 데이터베이스에서 업데이트하기 위해 사용됩니다. 이벤트 처리는 비즈니스 로직의 중요한 부분이므로 주/드라이버 포트의 책임입니다.\n\n```java\n// 실제로 이벤트가 발행되는 방법에 대한 구현에 대한 이해가 없는\n// 이벤트 퍼블리셔 인터페이스\n@SecondaryPort\npublic interface HoldEventPublisher {\n\n    void holdPlaced(BookPlacedOnHold event);\n\n    default Hold holdPlaced(Hold hold) {\n        BookPlacedOnHold event = new BookPlacedOnHold(hold.getId().id(), hold.getOnBook().barcode(), hold.getDateOfHold());\n        this.holdPlaced(event);\n        return hold;\n    }\n}\n\n// 이벤트 핸들러는 Spring Modulith 리스너를 사용하여\n// 이벤트에 신뢰성있게 대응합니다.\n@PrimaryPort\nclass CirculationDeskEventHandler {\n\n    private final BookRepository books;\n    private final HoldEventPublisher eventPublisher;\n\n    @ApplicationModuleListener\n    public void handle(BookPlacedOnHold event) {\n        books.findAvailableBook(new Book.Barcode(event.inventoryNumber()))\n                .map(Book::markOnHold)\n                .map(books::save)\n                .orElseThrow(() -\u003e new IllegalArgumentException(\"중복 예약?\"));\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 육각형 구조의 \"내부\" (비즈니스 로직) 단위 테스트\n\n![이미지](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_4.png)\n\n프레임워크 종속성 없이 비즈니스 로직을 구현하는 큰 장점은 통합 테스트가 필요하지 않고 코드를 단위 테스트할 수 있다는 것입니다. Repository 포트의 인메모리 구현을 사용하여 placeHold 유스케이스를 유효성 검사하는 단위 테스트의 예시가 여기 있습니다(CirculationDeskTest.java 참조).\n\n```java\nclass CirculationDeskTest {\n\n    CirculationDesk circulationDesk; // 애플리케이션 서비스\n\n    BookRepository bookRepository; // 보조 포트\n\n    HoldRepository holdRepository; // 보조 포트\n\n    @BeforeEach\n    void setUp() {\n        bookRepository = new InMemoryBooks();\n        holdRepository = new InMemoryHolds();\n        circulationDesk = new CirculationDesk(bookRepository, holdRepository, new InMemoryHoldsEventPublisher());\n    }\n\n    @Test\n    void patronCanPlaceHold() {\n        var command = new Hold.PlaceHold(new Book.Barcode(\"12345\"), LocalDate.now());\n        var holdDto = circulationDesk.placeHold(command);\n        assertThat(holdDto.getBookBarcode()).isEqualTo(\"12345\");\n        assertThat(holdDto.getDateOfHold()).isNotNull();\n    }\n\n    @Test\n    void bookStatusUpdatedWhenPlacedOnHold() {\n        var command = new Hold.PlaceHold(new Book.Barcode(\"12345\"), LocalDate.now());\n        var hold = Hold.placeHold(command);\n        circulationDesk.handle(new BookPlacedOnHold(hold.getId().id(), hold.getOnBook().barcode(), hold.getDateOfHold()));\n        //noinspection OptionalGetWithoutIsPresent\n        var book = bookRepository.findByBarcode(\"12345\").get();\n        assertThat(book.getStatus()).isEqualTo(ON_HOLD);\n    }\n}\n\n// 테스트 픽처 (보조 포트를 구현하는 보조 어댑터 역할)\nclass InMemoryBooks implements BookRepository {\n\n    private final Map\u003cString, Book\u003e books = new HashMap\u003c\u003e();\n\n    public InMemoryBooks() {\n        var booksToAdd = List.of(\n                Book.addBook(new Book.AddBook(new Book.Barcode(\"12345\"), \"A famous book\", \"92972947199\")),\n                Book.addBook(new Book.AddBook(new Book.Barcode(\"98765\"), \"Another famous book\", \"98137674132\"))\n        );\n        booksToAdd.forEach(book -\u003e books.put(book.getInventoryNumber().barcode(), book));\n    }\n\n    ...\n}\n\n// 테스트 픽처 (보조 포트를 구현하는 보조 어댑터 역할)\nclass InMemoryHolds implements HoldRepository {\n  // InMemoryBooks와 유사한 구현\n  ...\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도메인 모델이 집계를 지속하거나 이벤트를 트리거하기 위해 인터페이스에 의존하고 있는 점을 감안할 때, 유닛 테스트는 이 인터페이스 메서드를 실행할 수 있도록 테스트 픽스처가 필요합니다. 유당 테스트가 작동하려면 모든 보조/드라이븐 포트에 대한 구현이 필요합니다.\n\n전체 코드는 아래 GitHub 저장소에서 확인할 수 있습니다.\n\n## 아키텍처 규칙 테스트하기\n\nSpring Modulith 및 jMolecules 라이브러리는 ArchUnit과 함께 사용되어 우리의 솔루션에서 적용된 아키텍처와 Modular Monolith 애플리케이션의 모듈 간 상호 작용을 테스트할 수 있게 합니다. 이는 새로운 개발자들이 작업을 시작함에 따라 우리의 애플리케이션이 선택한 아키텍처에서 벗어나지 않도록 하는 데 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 모듈형 모놀리스 응용 프로그램에는 이제 Catalog 및 Borrow 두 개의 모듈이 있습니다. Catalog 모듈은 Layered/N-tier 아키텍처를 사용하고 Borrow 모듈은 Hexagonal 아키텍처를 사용하고 있어요. 다음과 같이 테스트할 수 있어요 (BorrowJMoleculesTests 및 CatalogJMoleculesTests 참고).\n\n```js\n@AnalyzeClasses(packages = \"example.catalog\")\npublic class CatalogJMoleculesTests {\n\n    @ArchTest\n    ArchRule dddRules = JMoleculesDddRules.all();\n\n    @ArchTest\n    ArchRule layering = JMoleculesArchitectureRules.ensureLayering();\n}\n\n@AnalyzeClasses(packages = \"example.borrow\")\npublic class BorrowJMoleculesTests {\n\n    @ArchTest\n    ArchRule dddRules = JMoleculesDddRules.all();\n\n    @ArchTest\n    ArchRule hexagonal = JMoleculesArchitectureRules.ensureHexagonal();\n}\n```\n\n@AnalyzeClasses 주석을 사용하여 테스트할 모듈을 선택할 수 있어요.\n\n## Hexagonal 아키텍처의 \"외부\"를 통합 테스트하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기술이 도메인 모델과 상호 작용하는 외부 부분은 동작을 확인하기 위해 통합 테스트로 테스트해야 합니다. 여기에 예제가 있습니다 (영속성인 CirculationDeskIT.java 및 REST인 CirculationDeskControllerIT.java):\n\n```js\n// from CirculationDeskIT\n@Test\nvoid patronCanPlaceHold(Scenario scenario) {\n    var command = new Hold.PlaceHold(new Book.Barcode(\"13268510\"), LocalDate.now());\n    scenario.stimulate(() -\u003e circulationDesk.placeHold(command))\n            .andWaitForEventOfType(BookPlacedOnHold.class)\n            .toArriveAndVerify((event, dto) -\u003e {\n                assertThat(event.inventoryNumber()).isEqualTo(\"13268510\");\n            });\n}\n\n// from CirculationDeskControllerIT\n@Test\nvoid placeHoldRestCall() throws Exception {\n    mockMvc.perform(post(\"/borrow/holds\")\n                    .contentType(MediaType.APPLICATION_JSON)\n                    .content(\"\"\"\n                            {\n                              \"barcode\": \"64321704\",\n                              \"patronId\": 5\n                            }\n                            \"\"\"))\n            .andExpect(status().isOk());\n}\n```\n\n## jMolecules로 클래스 스테레오타입 시각화\n\n이전 블로그 시리즈에서 언급했듯이 jMolecules Intellij 플러그인을 사용하여 다양한 스테레오타입을 시각화할 수 있습니다. 그러나 jMolecules 라이브러리가 헥사고날 아키텍처에 대한 주석을 지원하더라도 플러그인은 해당 주석을 지원하지 않습니다. 저는 관련 주석을 추가하여 플러그인을 수정했습니다. 플러그인을 활성화하고 관련 주석을 추가한 후 대여 모듈 내부 클래스가 어떻게 보이는지 확인하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_5.png)\n\n주요 포트 및 어댑터 클래스를 쉽게 식별할 수 있습니다.\n\n## 헥사고날 아키텍처에 헌신해야 할까요?\n\n모듈형 단일체 애플리케이션을 구축할 때, 모든 모듈에 대해 헥사고날 아키텍처를 사용해야 할지에 대해 고려해야 합니다. 만약 모듈이 자체 비즈니스 규칙을 갖고 있거나 (또는 나중에 갖게 될 것으로 예상된다면), 헥사고날 아키텍처가 좋은 아이디어일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 해결책에 더 많은 클래스와 장황성을 추가합니다. Layered 아키텍처에는 보조 포트와 어댑터가 없습니다. Spring Data 리포지토리 인터페이스는 Service 클래스에 직접 의존성을 추가하는 대가로 보조 포트와 어댑터의 역할을 취합니다.\n\n결국, 헥사고날 아키텍처를 채택하는 이점이 비용을 크게 상회합니다. 최소한 코드베이스에서 불필요한 결합을 줄이기 위해 의존성 역전의 원칙을 적용할 수 있는지 항상 확인해야 합니다.\n\n## 헥사고날 아키텍처를 구현하는 데 DDD가 필요한가요?\n\n아니요. 도메인 주도 설계(DDD)는 도메인이 모델링되는 방식에만 관련이 있습니다. 아키텍처와는 관련이 없습니다(헥사고날이든 그 외). DDD를 사용해야 하는가요? 클래스와 필드를 명명할 때 항상 모든 지식의 언어를 사용하는 것을 추천합니다. 도메인 전문가가 사용하는 용어와 동일한 용어를 사용하는 코드는 항상 이해하기 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDDD의 Aggregate 및 기타 전략적 패턴을 사용하는 것은 애플리케이션의 필요성과 복잡성에 따라 다릅니다. 정당화되지 않은 경우에는 트랜잭션 스크립트나 액티브 레코드를 대신 사용할 수 있습니다.\n\n## 헥사고날 아키텍처의 순수 구현 회피\n\n헥사곤의 내부는 핵심 비즈니스 로직의 구현이며, 헥사곤 외부에서 사용된 프레임워크와 기술로부터 자유롭게 유지해야 합니다. 몇몇 구현이 이 규칙을 신앙적으로 따라 코드를 복잡하게 만드는 것을 본 적이 있습니다.\n\n예를 들어, 애플리케이션 서비스 코드는 트랜잭션 내에서 실행되어야 합니다. Spring의 @Transactional을 사용하면 쉽게 달성할 수 있습니다. 그러나 이를 피하려면 애플리케이션 서비스를 Spring으로부터 자유롭게 유지하기 위해 사용자 정의 어노테이션과 AOP를 도입해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n헥사곤 안의 내부는 Application과 Domain으로 구성되어 있습니다. 도메인은 이상적으로는 프레임워크 없이 유지되어야 하지만, Application은 Spring을 사용할 수 있습니다. 이 질문을 Vaughn Vernon에게 던졌고, 그는 좋은 설명을 제공했습니다.\n\n![이미지](/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_6.png)\n\n## 도메인 모델로부터 만들어진 분리된 JPA 엔티티를 병합하기\n\n아래 코드 스니펫을 확인하여 Hold를 배치하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic HoldDto placeHold(Hold.PlaceHold command) {\n    ...\n\n    Hold.placeHold(command) // Hold 도메인 모델 객체 생성\n            .then(holds::save) // JPA 엔티티로 변환하여 데이터베이스에 저장\n            .then(eventPublisher::holdPlaced) // HoldPlaced 이벤트를 트리거\n\n    ...\n  );\n}\n```\n\nholds::save는 Secondary 포트 인터페이스에서의 호출로, Secondary 어댑터 구현을 트리거합니다:\n\n```js\npublic Hold save(Hold hold) {\n    holds.save(HoldEntity.fromDomain(hold));\n    return hold;\n}\n\n// HoldEntity 클래스에서\npublic static HoldEntity fromDomain(Hold hold) {\n    var entity = new HoldEntity();\n    entity.id = hold.getId().id(); // 도메인 모델 식별자와 JPA 엔티티 PK가 동일합니다!\n    entity.book = hold.getOnBook();\n    entity.dateOfHold = hold.getDateOfHold();\n    entity.status = HoldStatus.HOLDING;\n    entity.version = 0L;\n    return entity;\n}\n```\n\nHold 도메인 모델은 영속화되기 전에 분리된 HoldEntity JPA 엔티티로 변환되어야 합니다. 엔티티 생성에는 기본 키 ID를 알아야 합니다. 도메인 모델이 PK를 따로 저장하거나 모델 식별자로 사용해야 합니다. 저의 예시에서는 후자를 선택했지만, 이 문제를 어떻게 해결할지 궁금합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n이 블로그에서는 계층 구조 대신 헥사고날 아키텍처를 사용하여 대출 모듈을 다시 구현했습니다. 이 과정에서 동일한 단일 코드 베이스의 일부임에도 불구하고 카탈로그 모듈에는 절대적으로 변경이 필요하지 않았음을 보여주었습니다. 이는 이벤트 기반 통합 덕분에 느슨한 결합이 활성화되었음을 확인했습니다.\n\n헥사고날에 대한 여러분의 경험은 어떠한가요? 댓글에서 공유해 주시면 감사하겠습니다.\n\n아래에서 업데이트된 코드를 확인할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png"},"coverImage":"/assets/img/2024-05-20-AdoptingDomain-FirstThinkinginModularMonolithwithHexagonalArchitecture_0.png","tag":["Tech"],"readingTime":21},{"title":"LeetCode 3068번 문제 해결하기 노드 값의 최대 합 찾기","description":"","date":"2024-05-20 15:34","slug":"2024-05-20-SolvingLeetCode3068FindtheMaximumSumofNodeValues","content":"\n# 문제 설명:\n\n0부터 n - 1까지 번호가 매겨진 노드로 구성된 무방향 트리가 있습니다. 길이가 n - 1인 0을 기준으로 한 2차원 정수 배열 edges가 주어지는데, edges[i] = [ui, vi]는 트리의 노드 ui와 vi 사이에 간선이 있음을 나타냅니다. 또한 양의 정수 k와 길이가 n인 0을 기준으로 한 음이 아닌 정수 배열 nums가 주어집니다. 여기서 nums[i]는 i번째로 번호가 매겨진 노드의 값을 나타냅니다.\n\n앨리스는 트리 노드의 값의 합을 최대로 하려고 합니다. 이를 위해 앨리스는 다음 작업을 트리에서 원하는 횟수만큼 (포함하여) 수행할 수 있습니다:\n\n- 노드 u와 v를 연결하는 [u, v] 간선을 선택하고, 그들의 값들을 다음과 같이 업데이트합니다:\n- nums[u] = nums[u] XOR k\n- nums[v] = nums[v] XOR k\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAlice가 작업을 여러 번 수행하여 얻을 수 있는 값의 최대 합을 반환합니다.\n\n예시 1:\n\n![image](/assets/img/2024-05-20-SolvingLeetCode3068FindtheMaximumSumofNodeValues_0.png)\n\n```js\nInput: nums = [1,2,1], k = 3, edges = [[0,1],[0,2]]\nOutput: 6\nExplanation: Alice가 다음을 수행하여 최대 합 6을 얻을 수 있습니다:\n- [0,2] 엣지를 선택합니다. nums[0] 및 nums[2]는 다음과 같이 변경됩니다: 1 XOR 3 = 2이고, 배열 nums는 [1,2,1] -\u003e [2,2,2] 로 변합니다.\n값의 총 합은 2 + 2 + 2 = 6 입니다.\n가능한 최대 값 합은 6임을 보여줄 수 있습니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예제 2:\n\n![그림](/assets/img/2024-05-20-SolvingLeetCode3068FindtheMaximumSumofNodeValues_1.png)\n\n```js\nInput: nums = [2,3], k = 7, edges = [[0,1]]\nOutput: 9\nExplanation: Alice can achieve the maximum sum of 9 using a single operation:\n- Choose the edge [0,1]. nums[0] becomes: 2 XOR 7 = 5 and nums[1] become: 3 XOR 7 = 4, and the array nums becomes: [2,3] -\u003e [5,4].\nThe total sum of values is 5 + 4 = 9.\nIt can be shown that 9 is the maximum achievable sum of values.\n```\n\n예제 3:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nInput: nums = [7,7,7,7,7,7], k = 3, edges = [[0,1],[0,2],[0,3],[0,4],[0,5]]\nOutput: 42\nExplanation: 최대 가능한 합은 42로, Alice가 작업을 수행하지 않고 이를 달성할 수 있습니다.\n```\n\n제한사항:\n\n- 2 `= n == nums.length `= 2 \\* 104\n- 1 `= k `= 109\n- 0 `= nums[i] `= 109\n- edges.length == n - 1\n- edges[i].length == 2\n- 0 `= edges[i][0], edges[i][1] `= n - 1\n- 입력은 edges가 유효한 트리를 나타내도록 생성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 방법: 탐욕법 (정렬 기반 접근)\n\n## 직관\n\n노드 U에 대해 실행된 작업이 있다면, 노드의 새로운 값은 nums[U] XOR k가 됩니다. 각 노드에 대해, 작업을 수행한 후 값의 순 변화는 netChange[U] = nums[U] XOR k - nums[U]로 주어집니다.\n\n만약 이 순 변화가 양수라면, 모든 노드 값의 총합은 증가합니다. 그렇지 않으면 감소합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"가정해보겠습니다. 노드 쌍에서 노드 합에 가장 큰 증가를 제공하는\" 효율적인 작업 \"을 수행하려고 한다고 가정해봅시다. 가장 큰 양수 netChange 값을 가진 노드를 선택하면 노드 합에 가장 큰 증가를 제공할 것입니다.\n\n모든 노드에 대해 위에서 논의한 공식을 사용하여 net change 값을 계산할 수 있습니다. 이 값들을 내림차순으로 정렬한 후에는 positive sum을 가진 pair를 정렬 된 netChange 배열의 시작부터 선택할 수 있습니다.\n\n쌍의 합이 양수이면이 쌍에 대한 작업을 수행할 때 총 노드 합의 값을 증가시킵니다.\n\n## 알고리즘\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. nums의 크기인 n의 netChange 배열과 현재 nums의 합을 저장하는 정수 nodeSum을 초기화합니다.\n\n2. nums 배열을 반복합니다 (0부터 n-1까지):\n\n- 각 인덱스마다 intuition에서 논의한 아이디어를 사용하여 netChange의 값을 저장합니다.\n\n3. netChange 배열을 내림차순으로 정렬합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. netChange 배열을 반복합니다 (0부터 n-1까지, 단계 크기 = 2):\n\n- 인접한 요소의 쌍을 만들 수 없는 경우, 반복을 중단합니다.\n- 인접한 요소의 쌍의 합이 양수인 경우 이 합을 nodeSum에 추가합니다.\n\n5. 모든 netChange 요소를 반복한 후, 수행한 작업 이후 노드의 최대 가능한 합인 nodeSum을 반환합니다.\n\n## 구현\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nclass Solution {\n    public long maximumValueSum(int[] nums, int k, int[][] edges) {\n        int n = nums.length;\n        int[] netChange = new int[n];\n        long nodeSum = 0;\n\n        for (int i = 0; i \u003c n; i++) {\n            netChange[i] = (nums[i] ^ k) - nums[i];\n            nodeSum += nums[i];\n        }\n\n        Arrays.sort(netChange);\n\n        for (int i = n-1; i \u003e= 1; i -= 2) {\n            // If netChange contains odd number of elements break the loop\n            if (i - 1 == -1) {\n                break;\n            }\n            long pairSum = netChange[i] + netChange[i - 1];\n            // Include in nodeSum if pairSum is positive\n            if (pairSum \u003e 0) {\n                nodeSum += pairSum;\n            } else {\n                return nodeSum;\n            }\n        }\n        return nodeSum;\n    }\n}\n```\n\n## 복잡도 분석\n\n노드 값 목록에 포함된 요소 수를 n이라고 합시다.\n\n- 시간 복잡도: O(n⋅logn)\n  - 정렬을 제외하고 목록에 대해 단순 선형 작업을 수행하기 때문에 런타임은 정렬의 O(n⋅logn) 복잡성에 지배됩니다.\n- 공간 복잡도: O(n)\n  - 새로운 크기 n의 netChange 배열을 만들고 정렬하기 때문에 추가 공간은 netChange 배열에 대한 O(n)이고 정렬에 대해 O(logn) 또는 O(n)이므로 순 공간 복잡도는 O(n)입니다.\n","ogImage":{"url":"/assets/img/2024-05-20-SolvingLeetCode3068FindtheMaximumSumofNodeValues_0.png"},"coverImage":"/assets/img/2024-05-20-SolvingLeetCode3068FindtheMaximumSumofNodeValues_0.png","tag":["Tech"],"readingTime":6},{"title":"의료 기록의 개인 정보는 신뢰에 달려 있습니다","description":"","date":"2024-05-18 21:12","slug":"2024-05-18-ThePrivacyoftheMedicalRecordReliesonTrust","content":"\n## 프린세스 케이트의 의료 기록 뉴스\n\n![의료 기록의 개인정보 보호는 신뢰에 달려 있습니다](/assets/img/2024-05-18-ThePrivacyoftheMedicalRecordReliesonTrust_0.png)\n\n저는 저희 병원 부서의 입원 결정 지점이었습니다. 이 말은 즉, 환자가 우리 부서로 추천된 경우 입원 간호사가 해당 환자의 적절성에 대해 중요한 의문을 제기했을 때, 저는 해당 환자와 의무기록을 검토하고 최종 결정을 내렸다는 것을 의미했습니다.\n\n다양한 의료 서비스 유형의 면허에 대해 많은 규정과 규정이 존재합니다. 부서장으로서, 저는 해당 규정을 알아야만 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전자 의료 기록이 신뢰에 의존한다는 사실에 놀랐어요. 환자에 할당된 의료진만이 컴퓨터를 보고 그 환자의 기록을 볼 수 있는 권한이 있었죠. 병원 관련 의사 결정을 위해 차트를 검토하고 다른 제한적이고 합법적인 이유로 의료 기록을 열어 본 사람들도 모두 필요에 따라 열어본 거예요.\n\n## 의료 기록에 무단 접근 금지\n\n의료 기관들은 명확하게 밝혔어요. 환자 의료 차트에 무단 접근하면 즉시 해고 또는 다른 조치의 대상이 된다는 거였죠. 예를 들어, 어른 부모라도 어린 아동의 차트를 엿보지 못했어요. 배우자의 차트에 접근할 수도 없었고요. 특히 궁금한 사람의 차트에 접근하는 건 금지돼 있었어요 - 이웃, 친구 또는 연예인 같은 사람의 차트를 확인하는 건 특히 안 돼요.\n\n뉴스 매체에서는 무단으로 연예인 의료 기록을 엿본 직원들에 대한 이야기를 다루었어요. 프린세스 케이트와 알려지지 않은 수술로 입원한 일이 지금 의료 기록 유출 사례로 뉴스에 소개되고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대부분의 의료 센터들은 자신들의 단점을 공개하고 싶어하지 않을 것이기 때문에, 이 뉴스 이야기가 언론에서 판매되거나 보도될 수 있는 것을 막기 위한 예방적인 움직임이라고 생각해요. 런던 클리닉은 이 이야기가 공개될 수 있는 다른 이유가 있다면 적극적으로 대응할 지도 모를 거예요. 또한 다른 직원들에게 의료 기록에 접근하지 말라는 경고로 작용합니다.\n\n환자는 주기적으로 자신의 차트에 접근한 사람을 검토할 권리가 있어요. 대부분의 사람들은 이 옵션을 알지 못하거나 사용하지 않아요. 제가 일했던 병원은 목적지 병원이었기 때문에 유명인들도 왔어요. 그들의 차트는 무단 접근을 더 자주 확인했으므로, 호기심이 많은 사람들은 빠르게 발각되곤 했어요. 개인 정보 보호를 위한 이 규정은 엄격하게 집행되었어요.\n\n근무 중인 간호사나 차트에 접근해야 하는 전문의와 같이 담당 환자를 할당받은 어떤 간호사도 그 차트에 접근할 수 있는 능력은, 모든 의료 직원에게 차트가 사용 가능해야 한다는 것을 의미해요. 이것은 대규모 병원의 의료 기록의 난제입니다.\n\n저희 병원에서 행동 건강 기록을 검토해야 할 경우에는, 그 기록을 검토할 필요가 있는 의료 직원이 그것에 접근할 수 있도록 하기 위해, 컴퓨터 화면에 메디컬 필요성에 관한 추가적인 경고문을 건너야 했어요. 판단력에 영향을 미치는 상태로 치료받으면서 시스템에서 활동 중인 의료 시스템 직원에 대해 제가 부사장인 상급 간부에게 상담을 요청했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의료기록의 개인정보 보호 목적이 절대적이라는 것을 그녀가 말했습니다. 그 정보를 전달할 수 없었어요. 의사와 환자 사이의 것이기 때문이에요. 유일한 결정권은 입원 여부 뿐이었습니다.\n\n의료 이사가 알려져 있는 의학적 상태를 가진 정신 보건 사회복지사의 의료 기록을 검토할 때 비슷한 딜레마를 알게 되었어요. 의료 이사는 의료 기록을 검토할 때 관련된 치료 이유를 가져야 했습니다. 일자리에 어떤 영향을 미쳤는지 궁금해하는 게 아니었어요. 결과를 몰랐지만 의료 이사가 남았다는 사실을 알고 있어요. 아마도 그녀의 인사 기록에 메모가 되었거나 만약 불이행이었다면 경고가 있었을지도 몰라요.\n\n병원에서 일하기 전에 의료 기록의 개인정보 보호가 보호되고 있다고 생각했었습니다. 그렇죠, 하지만 단순한 기계적이거나 기술적 장벽이 아니라 꼭 알아야 할 열람 권한의 신뢰에 의해 보호되고 있어요. 대형 병원은 일년 동안 수천 명의 환자를 만날 수 있으므로 발생하는 무시무시한 일은 결코 발견되지 않을 수도 있어요. 그 차트에 접근한 사람과 그들의 역할에 대한 목록을 찾아볼 수 있지만, 그건 적극적인 단계, 기술적 요청이어야 합니다.\n\n한 명의 의사가 쓴 한 문장으로부터 우리를 판단하던 주요 수사관과 오해가 있었어요. 수백 개의 전자 페이지로 이루어진 차트에 숨겨진 그 문장 때문에 책임을 져야 했어요. 그 지시사항에 대해 우리가 책임을 져야 했었어요. 의사는 자신의 메모에 관심을 끌지 못해 매우 미안해했고, 컴퓨터 다른 곳에 입력했어야 했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n국가 조사관은 전체 차트를 읽는 데 약 여덟 시간이 필요하다는 것을 이해하지 못했어요. 전체 차트를 읽는 간호사는 교대를 시작하지 못할 거예요. 그래서 그녀는 최신 업데이트를 읽었어요. 의료 상태에 변화가 있는지 여부로만 차트를 확인했어요. 국가 조사관은 환자와 작업하는 의료진에게 \"전체 차트를 읽을 것을 예상했다\"고 언급했어요.\n\n## 의료 기록은 매우 복잡한 전자 기록입니다.\n\n각 우려 사항에는 별도의 탭, 페이지 및 검토가 있어요. 약국, 물리 치료, 행동 건강, 간호, 진단 목록... 페이지가 계속 이어져요. 복잡성 자체가 위험이 될 수 있어요. 역사가 더 복잡하고 길수록 간단한 체크 상자를 놓치기 쉬워지거든요.\n\n우리 시스템을 업데이트했을 때, 각 부서에서 필요한 여러 작은 수정이 있었어요. 우리에게 그 업데이트의 예가 눈에 보이지 않던 기록에 날린 의사 선언이었답니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n언제나 선제적인 환자가 되는 것을 믿어왔어요. 이제 내 의사를 방문할 때, 그녀는 노트북에 타이핑을 하는 기술을 마스터했어요. 컴퓨터를 보면서 저를 살펴보고 눈을 맞추면서 말이에요. 예전의 행정 데이터 포인트가 여전히 유효하다면, 그녀는 표준 스무 분 진료 방문 당 환자 한 명을 보고 있을 거예요.\n\n건강 제공자들에게 질문하세요. 그들의 삶은 당신이 알고 있는 것보다 더 복잡할 수 있어요. 중요한 의료 상태를 제공자에게 상기시켜 주거나 건강에 작은 변화가 있었는지 알려주세요. 상태 치료에 중요한 정보는 내게는 사소한 것처럼 보일 수 있어요.\n\n당신의 건강 데이터를 올바르게 관리하는 데 가장 큰 투자를 한 사람은 당신이에요.\n","ogImage":{"url":"/assets/img/2024-05-18-ThePrivacyoftheMedicalRecordReliesonTrust_0.png"},"coverImage":"/assets/img/2024-05-18-ThePrivacyoftheMedicalRecordReliesonTrust_0.png","tag":["Tech"],"readingTime":5},{"title":"당신만의 개인 AI 코드 어시스턴트 로컬 머신에서 오프라인 LLM 사용 초보자 가이드","description":"","date":"2024-05-18 21:11","slug":"2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine","content":"\n# 당신의 개인 AI 코딩 어시스턴트 — 인터넷 연결이 필요 없음\n\n![이미지](/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_0.png)\n\n로컬 머신에 개인 생성 AI 모델을 설정하고 사용하는 방법을 배우세요 — 완전 무료입니다. 기본적인 \"Mac을 어떻게 사용하나요\" 지식은 포함되어 있습니다 — 어쨌든 우리가 설정하는 것은 코드 어시스턴트니까요.\n\n이 비교적 빠른 가이드는 클라우드 서비스로 데이터가 업로드되지 않는 개인용 로컬 오프라인 대규모 언어 모델 (LLM)을 시작하는 방법을 설명합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이 프로세스가 작동하는 방식부터 시작해서 모델을 선택하는 데 도움을 드립니다.\n- 노트북에 구성하는 방법을 설명해 드립니다.\n\n## 지구를 위해 비용을 지불하지 않는 로컬 오프라인 GenAI 어시스턴트가 필요하세요?\n\n지금 제가 여러분이 \"생성적 AI\"를 손끝에서 경험하고 싶어하실 것이라고 확신합니다. 하지만 아마 염려하시는 것은... 여러분이 실행 중인 메가 비밀 코드가 StackOverflow에는 없을 것이고, 여러분이 처음부터 복사한 곳에 데이터가 훈련되고 있다는 점이 아닌가요. 맞죠? 그렇죠, 맞죠?\n그러나 여러분은 여전히 특별하고 안전한 느낌을 가지길 원하시며, '집에서 일하기' #밴라이프 여행 중에 숲, 들판, 해변 또는 고원에서 전화를 기다리는 동안 항상 누군가와 대화할 사람 — 맞죠, 코드와 함께 대화할 사람이 필요하실 것입니다.\n\n하지만, 여기서 얼마 후에 우리는 공감을 얻을 수 있을 거라고 확신합니다. Google Astra 또는 GPT-4의 실제 리테일 사용이 가능해질 때에 대해 별도로 다룰 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요즘 우리는 개인용 개인 AI 어시스턴트를 찾고 있죠. 개인 정보를 존중하며 인터넷 연결이 없어도 마법을 부리는 일이 가능한 어시스턴트 말이에요. 이제 과학 소설이 아니에요. 노트북에서 강력한 AI 모델을 직접 실행하는 것은 가능할 뿐만 아니라 놀랍게도 쉽답니다.\n\n이번 달에는 Gemma, Llama3, Phi3와 Mixtral의 변형체(예: Dolphin) 등 새로운, 놀라운 능력을 가진 모델이 나왔어요. 이들은 Apple의 M-시리즈 칩으로 작동하는 일상적인 개발용 머신에서 원활하게 작동할 만큼 충분히 작아졌어요.\n\n자, 이제 직접 개인용 개인 AI 어시스턴트를 만드는 방법을 알아볼까요?\n\n# 여기서 시작해보세요 — 기본 사항을 먼저 알아봐요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_1.png)\n\n## \"최고의 모델\"이란 것은 없어요 — 항상 절충이 필요해요.\n\n가장 풍부한 모델, 다시 말해 매개변수가 가장 많은 모델은 일반적으로 크고 무겁고 실행하기 비싸며, CPU 및 메모리를 소모하여 마치 난로로 사용할 수 있을 정도로 비효율적일 수 있어요.\n\n이 글을 쓰는 시점에서 Huggingface의 LLM Repo에는 658,281개의 모델이 있어요. 맞아요, 잘 이해하셨어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_2.png)\n\nIt’s mostly found on Huggingface, but there are other repos like Kaggle — Think of it as a “Dockerhub for LLMs”. We won`t go into LLM Model formats available, as we can be here all day, and this post will shortly be long enough.\n\n## Checkout Model Leaderboard to help pick the LLMs you’re after\n\nHuggingface Does have handy leaderboards, where you can pick the “Best Performing Model for it’s purpose” be it for chat, reasoning, Coding and other use cases, may want to poke around here to have an idea of what model you may want to pick for You use case — perhaps even in the future.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_3.png)\n\n신나시나요? 정말 멋진 거죠?\n하지만 너무 흥분하지 마세요. 알고 계셔야 할 것은 여러 LLM/모델이 있습니다. 이것들 중에서는 일부가 클라우드에서 온디맨드로 실행되어야 하기 때문에 당신의 노트북에서 실행할 수 없을 수도 있어요.\n\n우리는 성능 우수한 것을 로컬에서 오프라인으로 실행하고 싶어요. 저는 여러분을 도울 거예요!\n\n## 들어보세요. 주의해야 할 점이 있어요. 쉽거나 어려울 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n생성적(오프라인) AI 모델의 세계에서 \"최고\"를 찾는 것은 단순히 벤치마킹에서 성능이 우수한 것을 선택하는 것만큼 간단하지 않습니다. 성능과 기계가 처리할 수 있는 것 사이의 적절한 균형을 찾는 것입니다.\n\n그것은 미묘합니다.\n\n예를 들어, M 클래스 MacBook을 가진 개발자로써 여러 능숙한 모델을 실행할 수 있는 능력이 있습니다. 그러나 이상적인 모델을 선택하는 것은 귀하의 특정한 요구 사항에 따라 달라집니다.\n\n- 빠른 JavaScript 스니펫을 생성하기 위한 가벼운 모델을 찾고 있습니까, 아니면 복잡한 작업을 위한 보다 강력한 모델을 찾고 있습니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKaggle 및 Hugging Face와 같은 리소스는 모델 기능 및 요구 사항에 대한 자세한 정보를 제공합니다. 평가 결과를 찾아보고 모델 크기 및 계산 요구 사항을 고려할 수 있습니다.\n\n# 이제 뭘 해야 할까요?\n\n알았어요, 알았어요, — 우리에게 \"시작\"은 간단함을 의미합니다. 그리고 위의 내용이 너무 많다고 느낀다면, 2-3단계로 더 요약된 옵션을 제시해 드리겠습니다.\n\n## 1. Ollama로 시작해보세요. 다운로드하세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLM Studio와 유사하지만 내 개인 의견으로 Ollama는 훨씬 간단하고 깔끔하다고 생각해요.\n\n![image](/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_4.png)\n\n- LLMs 다운로드 - 문서를 확인해보세요. 하지만, 터미널에서 'ollama3'을 실행하면 최소한의 작업량으로 즉시 로컬 오프라인 모델과 대화할 수 있어요. 웹사이트의 정갈하게 정리된 목록에서 볼 수 있는 어떤 모델이든 빠르고 쉽게 설치할 수 있는 방법이죠.\n- 선택 사항: 특정 포트에 로컬로 LLM 서비스 제공. 저는 RAG/스크립트를 사용하여 동일한 포트를 사용하는 LM Studio에 대한 별칭(alias)이 있어요. 그래서 터미널에서 'ollamaserve'는 'OLLAMA_HOST=0.0.0.0:11434 ollama serve'로 설정되어 있어요.\n\n## 2. IDE에 로컬 모델 LLM 확장프로그램 다운로드하기.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 저는 VSCode를 사용하고 있어요. Continue.dev를 좋아하며, 또는 Cody LLM을 사용할 수도 있어요. 이것 또한 시작하기 쉽고 깔끔해요.\n\n![image1](/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_5.png)\n\n- 확장 프로그램을 구성하여 Ollama/Locally 호스트된 모델을 사용해 보세요.\n\n![image2](/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 완료\n\n여기 Ollama와 함께 사용할 수 있는 내 모델에 대한 내 견해입니다. 내가 원하는 목적에 맞게 특정 모델을 선택하고 선택할 수 있습니다.\n\n다양한 모델의 장단점을 이해함으로써, AI 지원 개발 목표를 달성하면서 시스템을 압도하지 않는 모델을 선택할 수 있습니다.\n\n# 마무리. 끝났고, 설정되었으니 — 행운을 빕니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상상해보세요 — 창의적인 텍스트 생성, 빠른 코드 작성, 아이디어 떠올리기, 심지어 매력적인 대화를 나누기까지, 모두 클라우드로 데이터를 보내지 않아도 가능합니다. 이것이 오프라인 생성 AI 모델을 실행하는 마법입니다.\n\n이것이 명백한 사실이 될 수도 있고 아닐 수도 있지만, 혜택을 다시 요약해보겠습니다:\n\n- 개인정보 보호: 데이터에 완전한 통제권 — 제3자 접근에 대한 우려 없음.\n- 비용 효율성: 구독료나 사용량 제한 없음. 완전히 무료입니다! (최대한 멍청한 질문을 해도 부담 없고 아무도 알아차리지 못합니다.)\n- 오프라인 신뢰성: 그리드에서 벗어나도 AI 도구에 액세스 가능합니다.\n- 맞춤 설정: 모델을 필요에 맞게 세밀조정하고 선호도에 맞게 조정합니다. (나만의 데이터셋과 맥락에 바탕을 둬보세요 — 고급 사용법)\n\n도움이 되었으면 좋겠습니다. LinkedIn에서 #GenAI의 #지수 및 #혁신적 시대에 대한 나의 생각을 공유해주시기 바랍니다. 좋아요, 공유하기, 구독하기, 팔로우해주시면 감사하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# OwnYourAI를 통해 AI를 소유하여 당신과 조화를 이루세요.\n\nJP\n","ogImage":{"url":"/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_0.png"},"coverImage":"/assets/img/2024-05-18-YourPrivateAICodeAssistantABeginnersGuidetoOfflineLLMonYourLocalMachine_0.png","tag":["Tech"],"readingTime":9},{"title":"2023년에 블록하지 않고 알려지지 않은 번호로부터 WhatsApp 메시지 수신을 중지하는 방법","description":"","date":"2024-05-18 21:10","slug":"2024-05-18-HowtoStopReceivingWhatsAppMessagesfromUnknownNumbersWithoutBlocking2023","content":"\n![How to Stop Receiving WhatsApp Messages from Unknown Numbers Without Blocking](/assets/img/2024-05-18-HowtoStopReceivingWhatsAppMessagesfromUnknownNumbersWithoutBlocking2023_0.png)\n\nIf you want to stop receiving WhatsApp messages from unknown numbers without resorting to blocking, there are a few steps you can take to manage your privacy and reduce unwanted messages. Here’s a guide on how to do it:\n\n# How to Stop receiving spam calls and messages from Unknown Numbers.\n\n## Privacy settings\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWhats App을 열고 메뉴에서 \"설정\"으로 이동하세요. \"계정\"을 선택한 다음 \"개인정보\"를 클릭하세요. 여기에서 프로필 사진, 상태 및 최종 활동을 볼 수 있는 사람을 사용자 정의할 수 있습니다. 이러한 옵션을 연락처에만 제한하면 알 수 없는 번호가 이 정보에 액세스하거나 이를 기반으로 대화를 시작할 수 없습니다.\n\n## 메시징을 위한 개인 정보 설정 변경\n\n같은 \"개인정보\" 섹션에서 메시지를 보낼 수 있는 사람을 수정할 수 있습니다. \"누가 나에게 메시지를 보낼 수 있는지\"를 선택하고 \"내 연락처\"를 선택하여 주소록에 있는 사람만이 메시지를 보낼 수 있도록 설정하세요. 이 설정은 무작위 알 수 없는 번호가 당신의 수신함에 도달하는 것을 방지합니다.\n\n## 그룹 초대 제한\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알 수 없는 번호에 의해 무작위 그룹에 추가되는 것을 피하려면 \"개인 정보\" 섹션으로 돌아가 \"그룹\"을 탭하세요. 거기에는 \"모두\", \"내 연락처\", \"제외한 연락처\" 세 가지 옵션이 제공됩니다. \"내 연락처\" 또는 \"제외한 연락처\"를 선택하면 동의 없이 타인이 당신을 그룹에 추가하는 것을 방지할 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-HowtoStopReceivingWhatsAppMessagesfromUnknownNumbersWithoutBlocking2023_1.png)\n\n## 연락처 차단\n\n특히 성가신 알 수 없는 번호에서 메시지를 받으면 해당 번호를 개별적으로 차단할 수 있습니다. 채팅을 열고 상단의 연락처 이름을 탭한 후 \"차단\"을 선택하세요. 이 동작은 해당 특정 번호로부터의 추가 메시지를 방지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 스팸 신고\n\nWhats App은 스팸 메시지를 신고할 수 있는 기능을 제공합니다. 알 수 없는 번호에서 스팸으로 의심되는 수신 메시지를 받으면 Whats App에 신고할 수 있습니다. 채팅을 열고 해당 연락처의 이름을 누르고 \"신고\"를 선택하세요. 이 정보는 Whats App이 스팸 탐지를 개선하고 다른 사용자를 보호하는 데 도움이 됩니다.\n\n이러한 단계를 따르면 Whats App에서의 개인 정보 보호를 강화하고 모르는 번호에서 오는 메시지 수를 줄일 수 있으며 모든 사용자를 차단하지 않아도 됩니다. 선호도와 필요에 맞게 개인 정보 설정을 정기적으로 확인하도록 하세요.\n\n자세한 내용 및 더 많은 기능은 TechToTools.com을 방문하여 전체 기사를 읽어보세요. 감사합니다. 좋아요 | 댓글 | 공유.\n","ogImage":{"url":"/assets/img/2024-05-18-HowtoStopReceivingWhatsAppMessagesfromUnknownNumbersWithoutBlocking2023_0.png"},"coverImage":"/assets/img/2024-05-18-HowtoStopReceivingWhatsAppMessagesfromUnknownNumbersWithoutBlocking2023_0.png","tag":["Tech"],"readingTime":3}],"page":"95","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"95"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>