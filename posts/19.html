<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/19" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/19" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_buildManifest.js" defer=""></script><script src="/_next/static/wfHLuDA3kTGBYfaM5IGXk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="엔지니어를 위한 Redis 클러스터 업그레이드 마스터하기 무중단 전환 가이드" href="/post/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="엔지니어를 위한 Redis 클러스터 업그레이드 마스터하기 무중단 전환 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="엔지니어를 위한 Redis 클러스터 업그레이드 마스터하기 무중단 전환 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">엔지니어를 위한 Redis 클러스터 업그레이드 마스터하기 무중단 전환 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Kubernetes에서 OOM 생존 가이드 Java 애플리케이션을 위한 팁" href="/post/2024-06-23-SurvivingOOMinKubernetesJavaApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kubernetes에서 OOM 생존 가이드 Java 애플리케이션을 위한 팁" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kubernetes에서 OOM 생존 가이드 Java 애플리케이션을 위한 팁" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Kubernetes에서 OOM 생존 가이드 Java 애플리케이션을 위한 팁</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 스레딩 필수 버추얼 스레드와 플랫폼 스레드 비교 분석" href="/post/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 스레딩 필수 버추얼 스레드와 플랫폼 스레드 비교 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 스레딩 필수 버추얼 스레드와 플랫폼 스레드 비교 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 스레딩 필수 버추얼 스레드와 플랫폼 스레드 비교 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기" href="/post/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Spring Boot3에서 트레이싱 활용하는 방법" href="/post/2024-06-23-TracinginSpringBoot3"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Spring Boot3에서 트레이싱 활용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TracinginSpringBoot3_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Spring Boot3에서 트레이싱 활용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Spring Boot3에서 트레이싱 활용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상" href="/post/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시네크론 자바 인터뷰 질문 및 답변 경력 2-4년" href="/post/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시네크론 자바 인터뷰 질문 및 답변 경력 2-4년" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시네크론 자바 인터뷰 질문 및 답변 경력 2-4년" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">시네크론 자바 인터뷰 질문 및 답변 경력 2-4년</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift에서 부분 적용 함수 사용하는 방법" href="/post/2024-06-23-PartiallyAppliedFunctionsinSwift"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서 부분 적용 함수 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-PartiallyAppliedFunctionsinSwift_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서 부분 적용 함수 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift에서 부분 적용 함수 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유" href="/post/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="다중 터치 ML 모델 최신 트렌드 및 사용 방법" href="/post/2024-06-23-Multi-touchMLModels"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다중 터치 ML 모델 최신 트렌드 및 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Multi-touchMLModels_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다중 터치 ML 모델 최신 트렌드 및 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">다중 터치 ML 모델 최신 트렌드 및 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link posts_-active__YVJEi" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"엔지니어를 위한 Redis 클러스터 업그레이드 마스터하기 무중단 전환 가이드","description":"","date":"2024-06-23 20:36","slug":"2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition","content":"\n# 소개\n\nAWS ElastiCache에서 Redis 클러스터를 업그레이드하는 것은 지속적인 성능과 보안을 보장하기 위해 꼼꼼한 계획과 실행이 필요한 중요한 작업입니다. 여러 번의 Redis 업그레이드를 직접 이끈 경험을 통해 해당 블로그 게시물에서 과정을 반복 가능한 일련의 단계로 정리했습니다. Redis 클러스터 업그레이드의 복잡성에 대해 자세히 살펴보며, 최선의 사례, 세부적인 전개 전략, 그리고 필수적인 롤백 계획에 대해 다룰 것입니다.\n\n이 과정은 준비 단계, 전개 단계 및 전개 후 단계로 자연스럽게 나눌 수 있습니다.\n\n# 준비 단계\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 부분은 아마도 가장 많은 시간을 소비하지만 매우 중요한 단계로 볼 수 있습니다. 주요 고려 사항은 다음과 같습니다:\n\n# 1. 호환성 매트릭스\n\nRedis 및 선택한 클라이언트 라이브러리(예: Java용 Jedis)에서 제공한 호환성 매트릭스를 철저히 검토해보세요. 이 매트릭스는 버전 간의 잠재적인 호환성 문제를 강조해줍니다.\n\n![MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0](/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRedis 자체의 릴리스 노트 및 클라우드 제공 업체 문서(예: AWS 문서)를 면밀히 살펴보세요. 이를 통해 새로운 기능, 버그 수정, 사용 중단 예정 기능 및 패치 베이스가 있는 변경 사항을 알 수 있습니다.\n\n## 2. 릴리스 노트\n\nRedis 및 클라이언트 라이브러리의 릴리스 노트를 주의 깊게 읽는 것이 매우 중요합니다. 이는 새로운 기능, 버그 수정, 사용 중단 예정 기능 및 변경 사항에 대한 중요한 정보를 제공합니다. 이러한 릴리스 노트는 Redis 문서에서 찾을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 Redis 호환 서비스를 제공하는 클라우드 제공업체는 변경 사항을 요약하여 제공합니다. 예를 들어 AWS 문서는 데이터베이스 엔진에 대한 중요한 변경 사항을 잘 요약합니다.\n\n# 3. 스테이징 환경에서 테스트\n\n프로덕션 설정과 유사한 스테이징 환경을 만듭니다. 다음을 포함합니다:\n\n- 인스턴스 유형 및 크기: 프로덕션과 동일한 AWS 인스턴스 유형 및 크기 사용.\n- 네트워크 구성: VPC, 서브넷 및 보안 그룹 설정을 미러링.\n- 데이터 양: 동일한 양의 데이터로 스테이징 환경을 채웁니다. 이것은 실제 업그레이드를 시작하기 전에 데이터 백업을 수행하는 데 걸리는 시간을 이해하는 데 매우 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스테이징 환경이 생성되면 새로운 Redis 버전과 함께 애플리케이션을 테스트하기 시작하는 시간입니다. 테스트는 다음 세 가지 하위 섹션으로 나눌 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_2.png)\n\n- 기능 테스트\n  새 버전과 완벽하게 작동하는지 확인합니다. 애플리케이션 코드베이스에 있는 모든 Redis 명령이 호환되는지 확인해야 합니다.\n  Lua 스크립트가 있는 경우 모든 사용자 정의 스크립트가 올바르게 실행되는지 확인하는 것이 중요합니다.\n- 성능 테스트\n  Redis는 일반적으로 지연 시간이 민감한 중요한 응용 프로그램에서 사용됩니다. 따라서 Gatling이나 Apache JMeter와 같은 부하 테스트 도구를 사용하여 업그레이드된 Redis 클러스터의 성능을 측정하는 것이 중요합니다.\n  Redis 엔진 업그레이드 중에는 더 높은 성능을 제공하는 경우가 있습니다. 이를 확인하기 위해 철저한 부하 테스트를 수행할 수 있습니다. 또한 클라이언트 라이브러리 설정을 조정하여 더 나은 성능을 얻을 수 있습니다.\n- 신뢰성 테스트\n  신뢰성 테스트는 제품 환경에 영향을 미치기 전에 잠재적인 문제를 발견하기 위한 것입니다. 장애 및 스트레스 시나리오를 시뮬레이션하여 업그레이드된 Redis 클러스터가 실제 환경에서 직면할 도전에 견딜 수 있는지 확인할 수 있습니다.\n  애플리케이션의 Redis 클라이언트가 노드 장애, 네트워크 중단 및 클러스터 재구성을 처리하는 방식을 테스트합니다. 이러한 클라이언트가 신속하게 새로운 노드에 연결하고 데이터 불일치를 우아하게 처리하는지 확인합니다.\n\nRedis 클라이언트 라이브러리는 노드 IP를 캐시합니다. 다중 샤딩 및 다중 노드 Redis 클러스터에서는 클라이언트 라이브러리에서 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 클라이언트 라이브러리에서 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운\\_IWPAৰ새로 운용할 수 있도록 해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4. 위험한 명령어 비활성화\n\n대부분의 경우, CPU가 Redis에서 병목 현상을 일으킵니다. 따라서 이러한 블로킹 명령어의 사용을 비활성화하거나 제한하는 것이 중요합니다. 여기에는 두 가지 범주가 있습니다.\n\n- 블로킹 명령어 — KEYS\\* , 대량 데이터 세트에서의 SORT 등\n- 비용이 많이 드는 명령어 — HGETALL , 범위가 큰 ZRANGE\n\nRedis는 명령어 이름을 변경하는 기능을 제공하며, FLUSHALL과 같은 명령어를 \\_DO_NOT_USE_FLUSHALL과 같이 애매한 이름으로 변경할 수 있습니다. ElastiCache를 사용하면 명령어 동작에 영향을 미치는 매개변수를 수정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 고가의 명령을 실행할 수 있는 느린 클라이언트를 자동으로 연결 해제하는 타임아웃 설정을 조정할 수 있습니다.\n\n## 5. 모니터링 및 로깅\n\n### 가. 향상된 모니터링\n\n중요한 메트릭인 CPU 사용량, 메모리 사용량 및 네트워크 처리량과 같은 주요 메트릭을 추적하기 위해 향상된 모니터링을 활성화하세요. AWS Elasticache는 Redis 클러스터에 대해 약 40여 가지 메트릭을 제공하며, 이러한 메트릭은 클러스터의 전반적인 상태를 파악하는 데 도움을 줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## b. 로깅 및 알림\n\nRedis 명령에 대한 로깅을 설정하고 중요 지표에 대한 알림을 구성하십시오. 이는 문제를 신속히 식별하고 진단하는 데 도움이 됩니다.\n\n업그레이드 단계에서는 Engine Logs와 Slow Logs를 활성화하고 이러한 로그 위에 경고를 설정하는 것이 중요합니다.\n\n# 롤아웃 단계\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n항목을 준비해 둔 후, 상세한 전개 계획을 작성하는 시간이에요. 서비스가 적거나 없는 시간대에 일정을 잡아 방해를 최소화 해보세요. 중요한 애플리케이션의 경우, 업그레이드 창을 신중하게 선택해야 해요. 왜냐하면 업그레이드를 위한 데이터 백업 과정은 상당한 Redis CPU 자원을 소비할 수 있기 때문이죠.\n\n꼭 기억해야 할 몇 가지 포인트가 있어요 —\n\n- 전체 백업: 시작하기 전에 Redis 클러스터 데이터의 전체 백업을 만들어 보세요. 스냅샷이나 선택한 지속성 메커니즘을 사용해보세요. 백업 및 복원 시간을 제품 환경에서 측정하여 업그레이드 창에 미치는 전반적인 영향을 이해하세요.\n- 데이터 일관성 확인: 백업 이후, 기본 및 레플리카 노드 간에 데이터 크기 및 키/값 쌍이 일치하는지 확인해보세요. 이 단계는 진행하기 전에 데이터 무결성을 보장하기 위해 중요해요.\n- 문서 버전: 철저한 롤백 절차를 문서화해보세요. 이에는 백업에서 복원 및 이전 버전에서 클러스터 다시 시작에 대한 상세 단계가 포함돼야 해요. 롤백을 예상대로 작동하는지 확인하기 위해 롤백의 시뮬레이션을 진행하세요.\n- 클라이언트 연결: 애플리케이션 팟이 새 Redis 클러스터에 연결할 수 있는지 확인해보세요. 클라이언트 라이브러리가 DNS 항목을 캐시하는 경우, 최신 연결 정보를 얻기 위해 Refresh Rate를 줄이거나 팟의 Rolling Restart를 실행해야 할 수도 있어요.\n- Thundering Herd 완화: Redis가 데이터베이스의 캐시 역할을 한다면, 캐시가 무효화되거나 실패할 경우 \"Thundering Herd\" 효과에 대비해야 해요. 이는 데이터베이스를 압도할 수 있어요. 데이터베이스 용량을 평가하고, 부담이 더 큰 작업을 처리할 수 있도록 필요에 따라 확장을 고려하세요.\n- 단계별 업그레이드: 새 버전의 안정성을 테스트하기 위해 중요하지 않은 노드(예: 읽기 레플리카)부터 업그레이드를 시작해보세요. 모든 것이 순조롭게 진행되면, 점진적으로 나머지 노드를 업그레이드하면서 프로세스 전반에 걸쳐 애플리케이션이 계속 작동하는지 확인하세요.\n- 커뮤니케이션: 유지보수 창에 대해 모든 이해당사자 및 애플리케이션/서비스 이용자에게 알리세요. 이를 통해 다른 팀이 즉각적으로 발생한 문제나 비정상적인 현상을 보고할 수 있게 돕습니다.\n\n전개 자체에는 여러 가지 방식이 있을 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 노드별 업그레이드: 중요한 애플리케이션의 경우, 시간이 오래 걸리지만 빠른 문제 감지가 가능한 한 번에 한 노드씩 업그레이드하는 방법이 있습니다.\n- 클러스터 재생성 (AWS ElastiCache): AWS 및 다른 클라우드 공급업체는 종종 클러스터 재생성 전략을 사용합니다. 이는 이전 클러스터의 스냅샷을 새 버전이 적용된 새 클러스터에 적용하고 데이터 동기화를 보장한 다음 DNS를 새 클러스터로 전환하는 과정을 포함합니다.\n\n## 중요 사항:\n\n전략의 선택은 특정 요구 사항, 리스크 허용 수준 및 애플리케이션의 성격에 따라 다릅니다.\n\n# 롤아웃 후 단계\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n롤아웃 후기 단계는 주로 모니터링과 문서화에 초점을 맞추며, 업그레이드된 Redis 클러스터의 안정성과 성능을 보장합니다. 클러스터를 단계별로 업그레이드한 후(먼저 읽기 레플리카, 그 다음 비중요 샤드, 마지막으로 주 노드) 다음 단계가 중요합니다:\n\n- 지속적인 모니터링\n  업그레이드된 클러스터를 긴 기간 동안 높은 수준으로 모니터링하여 예기치 못한 문제를 신속하게 감지하고 해결하세요. 이전 Redis 클러스터에서 역사적인 메트릭을 내보내고 저장하는 것을 강력히 권장합니다. 이를 통해 현재 성능을 이전 기준선(예: 1개월, 3개월 전)과 비교함으로써 이상 징후를 탐지할 수 있습니다.\n- 문서화\n  철저한 문서화가 중요합니다. 업그레이드 과정 전체를 기록하고 타임라인, 수행된 구체적인 단계, 그리고 마주친 어려움을 기록하세요. 이 문서화는 미래 업그레이드에 대한 소중한 참고 자료가 되며, 데이터 백업 기간, 동기화 프로세스, 그리고 현재 데이터 양과 관련된 기타 주요 메트릭에 대한 통찰을 제공합니다.\n\n# 결론\n\nRedis 클러스터를 업그레이드하는 것은 원활한 전환과 응용 프로그램의 안정성과 성능을 유지하기 위해 구조화된 방식이 요구됩니다. 이 글에서 제안된 전략과 모범 사례를 따르면, 위험을 크게 줄이고 새로운 Redis 기능 및 향상 사항을 성공적으로 통합할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 번의 Redis 업그레이드 경험과 통찰을 공유했지만, 언제나 더 배우고 싶습니다. 추가 팁, 제안 또는 실제 예시가 있으시면 아래 댓글을 남겨주세요. 여러분의 피드백은 우리 모두가 Redis 업그레이드 프로세스를 더 견고하게 만들고 발전시키는 데 도움이 될 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png","tag":["Tech"],"readingTime":9},{"title":"Kubernetes에서 OOM 생존 가이드 Java 애플리케이션을 위한 팁","description":"","date":"2024-06-23 20:35","slug":"2024-06-23-SurvivingOOMinKubernetesJavaApplications","content":"\n![Surviving OOM in Kubernetes Java Applications](/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_0.png)\n\n자바 애플리케이션의 세계에서 OutOfMemoryError (OOM) 문제는 할당된 메모리를 소진할 때 발생하는 과제입니다. 기존의 표준 자바 설정에서 OOM을 다룰 때 일반적으로 힙 덤프를 트리거링함으로써 처리합니다. 이는 특정 시점의 응용 프로그램 메모리 스냅샷을 제공하여 개발자가 애플리케이션의 메모리 사용 상태에 대한 통찰력을 제공하는 진단 도구입니다.\n\nKubernetes에서 Java 앱이 OOM을 경험할 때 플랫폼은 원활한 작동을 유지하기 위해 다시 시작됩니다. OOM이 완전한 종료로 이어지는 기존 설정과는 달리 Kubernetes는 자동으로 다시 기동하여 지속적 가용성을 보장합니다. 이 자동 재시작 기능은 힙 덤프를 캡처하려고 할 때 일련의 복잡성을 추가하며, 힙 덤프를 포드가 삭제되기 전에 잡을 잡아야 합니다.\n\n# 접근 방법 1:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOOM이 발생하기 전에 힙 덤프를 트리거하세요.\n\nPrometheus 메트릭을 사용하는 방법 중 하나입니다.\n\njvm 메모리의 90%와 같은 임계값을 선택하고 해당 임계값이 초과되면 웹훅이나 Robusta와 같은 도구를 사용하여 힙 덤프를 트리거할 수 있습니다.\n\n단점:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 외부 웹훅을 개발하거나 클러스터에 Robusta를 설치해야 합니다.\n- 애플리케이션에 Jmap이 있거나 일시적 컨테이너를 허용해야 합니다. 이 두 가지는 프로덕션에 일반적이지 않습니다.\n\n## 접근 방식 2:\n\n팟이 OOM을 받을 때 Heap 덤프를 생성합니다.\n\n하지만 기다려주세요. 만약 JVM의 최대 메모리에 도달하면, 팟은 다시 시작되는 것이 아니었나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그곳에 일부 JVM 매개변수가 유용하게 사용됩니다. 다음 JAVA_OPTS를 설정하여 킬 신호가 전송될 때 힙 덤프를 생성할 수 있습니다.\n\n```js\nJAVA_OPTS = \"XX:+HeapDumpOnOutOfMemoryError\";\n```\n\n좋아요! 이제 파드 내에 생성된 힙 덤프가 있습니다. 하지만 이것은 파드가 다시 시작될 때 삭제되기 때문에 우리에게 큰 도움이 되지 않습니다.\n\n![이미지](/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나중에 분석할 힙 덤프를 영구 저장하기 위해 몇 가지 옵션을 살펴볼 거에요.\n\n## 사이드카:\n\nJava 어플리케이션을 포함하는 각각의 파드에는 해당 컨테이너들 사이에서 볼륨을 공유하는 사이드카가 있을 수 있어요. 사이드카의 역할은 힙 덤프를 가져와 우리가 힙 덤프를 영구로 저장하길 원하는 곳에 업로드하는 거에요.\n\nJAVA_OPTS에 우리의 경우, 이런 식으로 힙 덤프를 공유된 볼륨에 넣는 설정을 추가할 거에요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n-XX:HeapDumpPath=/etc/shared-path/${pod_name}.hprof\"\n```\n\n아키텍처는 이렇게 보일 것입니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_2.png\" /\u003e\n\n단점:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 코드 유지보수 - 이제 모든 파드가 사이드카를 가져야 하며 2개의 컨테이너 사이에 마운트가 필요합니다(이를 Helm 라이브러리를 사용하여 수행할 수 있습니다).\n- CPU 및 메모리 사용량 - 각각의 사이드카는 비록 휴면 상태일지라도 약간의 풋프린트를 갖고 있으며, 많은 파드가 실행 중일 때 이는 빠르게 누적될 수 있습니다.\n\n이러한 2가지 단점으로 인해 다른 접근 방식을 취할 필요가 있습니다.\n\n## 네트워크 볼륨(예: NFS):\n\n단일 NFS 볼륨을 생성하고 모든 클러스터 노드에 마운트할 수 있습니다. 이를 통해 관련 파드를 호스트 경로에 마운트하고 힙 덤프를 이 경로로 직접 지정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n-XX:HeapDumpPath=/etc/efs-mount/${pod_name}.hprof\"\n```\n\n이제 남은 것은 지속적으로 실행되고 NFS 볼륨을 모니터링하며 이를 대상지(예: S3 버킷)로 복사할 별도의 pod입니다.\n\n이제 아키텍처는 다음과 같이 보일 것입니다:\n\n![아키텍처](/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모니터링 팟은 다음과 같이 작은 파이썬 앱일 수 있습니다:\n\n```python\nimport boto3\nimport os\nimport logging\nimport time\n\nDUMP_FOLDER = '/etc/efs-mount'\nBUCKET_PATH = 'heap-dumps'\nBUCKET_NAME = 'my-app-heap-dumps'\n\ndef main():\n    files_list = os.listdir(DUMP_FOLDER)\n    s3 = boto3.resource('s3')\n\n    if len(files_list) == 0:\n        logging.info(\"업로드할 힙 덤프가 없습니다.\")\n    else:\n        for file in files_list:\n            full_file_path = '{}/{}'.format(DUMP_FOLDER, file)\n            logging.info(\"{}을(를) {}에 업로드 중\".format(file, BUCKET_NAME))\n            s3.meta.client.upload_file(full_file_path, '{}-{}'.format(BUCKET_NAME), '{}/{}'.format(BUCKET_PATH, file))\n            os.remove(full_file_path)\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    while True:\n        main()\n        time.sleep(300)\n```\n\n이 해결책은 한 가지 유휴 리소스(모니터링 팟)만 사용하므로 더 저렴한 비용을 제공합니다. 그리고 마운트된 저장소는 사실상 무료입니다(예: EFS), 많은 양을 저장하지도 않고 몇 분 이상 저장하지 않기 때문입니다.\n\n주의사항:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 클라우드 스토리지(예: S3 버킷)에 대한 인증을 하려면 kube2iam과 같은 것을 사용하는 것을 권장합니다.\n- 예제와 같이 힙 덤프를 팟 이름으로 명명하십시오. 이 작업의 까다로운 부분은 매니페스트 아규먼트가 아니라 팟의 엔트리포인트에 넣어야 한다는 것입니다.\n- 이는 포드 제한에 도달해서 발생하는 OOM에 대한 해결책이 아닙니다.\n\n요약하면, JVM OOM을 처리하는 다양한 방법이 있습니다. 환경에 가장 적합한 방법을 선택하십시오.\n","ogImage":{"url":"/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_0.png"},"coverImage":"/assets/img/2024-06-23-SurvivingOOMinKubernetesJavaApplications_0.png","tag":["Tech"],"readingTime":6},{"title":"자바 스레딩 필수 버추얼 스레드와 플랫폼 스레드 비교 분석","description":"","date":"2024-06-23 20:34","slug":"2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained","content":"\n이 기사에서는 쓰레드와 \"가상 쓰레드\"라고 불리는 최근 기능에 대해 알아볼 것입니다. 이 플랫폼 쓰레드와 가상 쓰레드가 어떻게 성격이 다르며 어떻게 애플리케이션의 성능 향상에 기여하는지에 대해 알아보겠습니다.\n\n![이미지](/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_0.png)\n\n## 클래식 쓰레드 배경:\n\n외부 API를 호출하거나 데이터베이스 상호작용과 같은 시나리오를 살펴보고 실행 중인 쓰레드 수명주기를 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 메모리에 생성되고 서비스를 제공할 수 있는 스레드입니다.\n- 요청이 접근하면 스레드 중 하나에 매핑되어 외부 API를 호출하거나 데이터베이스 쿼리를 실행합니다.\n- 스레드는 서비스나 데이터베이스로부터 응답을 받을 때까지 대기합니다.\n- 응답을 받자마자 후속 활동을 실행한 후 풀로 다시 반환합니다.\n\n![이미지](/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_1.png)\n\n위 생명주기에서 스레드가 아무것도 하는 대기 단계인 단계 3을 관찰하십시오. 이것은 주로 대기하여 시스템 리소스를 비효율적으로 사용하므로 단점이며 수명 주기 중 대부분의 스레드가 응답을 기다리며 아무것도 하지 않습니다.\n\nJava 19 이전에는 스레드를 생성하는 표준 방법 또는 존재하는 스레드가 Native Threads 또는 Platform Threads로 불립니다. 이 아키텍쳐 스타일에서 Platform 스레드와 OS 스레드 사이에 1:1 매핑이 있습니다. 이는 운영 체제 스레드가 완료될때까지 기다리기만 하고 아무 것도하지 않아서 미사용 상태이며 이를 무겁고 비싸게 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 가상 스레드:\n\n자바의 가상 스레드는 자바가 동시성 및 멀티스레딩을 다루는 방식에서 중대한 발전을 나타냅니다. 오라클의 프로젝트 룸(Projext Loom)의 일환으로 소개된 가상 스레드는 고성능의 동시 애플리케이션을 작성, 유지 및 관찰하기 위한 도전에 대응하기 위한 이니셔티브로, 개발자가 동시성을 더 쉽게 다룰 수 있도록 설계되었습니다.\n\n가상 스레드는 운영 체제가 아닌 Java 가상 머신(JVM)에 의해 관리되는 가볍고 자원소모가 적은 스레드입니다. 플랫폼 스레드와는 달리 가상 스레드는 쉽게 생성 및 해제할 수 있습니다. 그들은 적은 수의 플랫폼 스레드에 매핑되어 수천 개 또는 수백만 개의 작업을 더 적은 자원으로 동시에 처리할 수 있게 합니다.\n\n![가상 vs 플랫폼 스레드](/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 가상 스레드의 장점 Platform 스레드 대비\n\n자바에서 가상 스레드의 장점은 많습니다. 먼저, 가상 스레드를 통해 시스템 자원을 더 효율적으로 사용할 수 있습니다. 가상 스레드는 가벼워서 플랫폼 스레드보다 적은 메모리와 CPU 자원을 소비합니다. 이 효율성으로 인해 동시성의 정도를 높일 수 있어 하나의 JVM에서 많은 수의 동시 작업을 실행할 수 있습니다.\n\n둘째, 가상 스레드는 자바에서 동시 프로그래밍을 간단하게 만듭니다. 개발자들은 비동기 프로그래밍 모델의 복잡성을 다루지 않고 동기식 코드를 작성하는 것과 유사한 간단하고 명령형 스타일로 코드를 작성할 수 있습니다. 이 간소화를 통해 교착상태나 경쟁 조건과 같은 일반적인 동시성 관련 버그의 발생 가능성을 줄일 수 있습니다.\n\n게다가, 가상 스레드는 CPU 이용률을 향상시켜줍니다. 기존의 스레드 모델에서는 많은 수의 스레드 사이의 관리와 컨텍스트 스위칭으로 많은 CPU 시간이 소비될 수 있습니다. 가상 스레드는 컨텍스트 스위칭과 관련된 오버헤드를 줄여 동시 작업을 효율적으로 실행할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 실용적인 방법:\n\n만약 우리가 일을 완료하기 위해 클래식 플랫폼 스레드를 생성하고 싶다면, 아래와 같이 할 수 있습니다. PlatformThreadDemo.java 파일을 만들고 아래 내용을 복사하세요.\n\n```js\npackage org.vaslabs;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class PlatformThreadDemo {\n    private static final Logger logger = LoggerFactory.getLogger(PlatformThreadDemo.class);\n\n    public static void main(String[] args) {\n        attendMeeting().start();\n        completeLunch().start();\n    }\n\n    private static Thread attendMeeting(){\n        var message = \"Platform Thread [Attend Meeting]\";\n        return new Thread(() -\u003e {\n            logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n        });\n    }\n\n    private static Thread completeLunch(){\n        var message = \"Platform Thread [Complete Lunch]\";\n        return new Thread(() -\u003e {\n            logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n        });\n    }\n\n    // using builder pattern to create platform threads\n    private static void attendMeeting1(){\n        var message = \"Platform Thread [Attend Meeting]\";\n        Thread.ofPlatform().start(() -\u003e {\n            logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n        });\n    }\n\n    private static void completeLunch1(){\n        var message = \"Platform Thread [Complete Lunch]\";\n        Thread.ofPlatform().start(() -\u003e {\n            logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n        });\n    }\n}\n```\n\n위 예제는 플랫폼 스레드를 생성하는 두 가지 방법을 보여줍니다.\n\n1. Thread 생성자를 사용하여 람다 런너블을 전달하는 방법\n2. Thread의 빌더 메서드 ofPlatform()을 사용하는 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 복잡한 코딩을 보고 가상 스레드를 동시에 생성하는 방법을 알아보겠습니다. DailyRoutineWorkflow.java 파일을 생성하고 아래 코드를 복사하세요.\n\n```js\npackage org.vaslabs;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class DailyRoutineWorkflow {\n    static final Logger logger = LoggerFactory.getLogger(DailyRoutineWorkflow.class);\n\n    static void log(String message) {\n        logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n    }\n\n\n    private static void sleep(Long duration) throws InterruptedException {\n        TimeUnit.MILLISECONDS.sleep(duration);\n    }\n\n    private static Thread virtualThread(String name, Runnable runnable) {\n        return Thread.ofVirtual().name(name).start(runnable);\n    }\n\n    static Thread attendMorningStatusMeeting() {\n        return virtualThread(\n                \"Morning Status Meeting\",\n                () -\u003e {\n                    log(\"아침 상태 회의에 참석하겠습니다.\");\n                    try {\n                        sleep(1000L);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    log(\"아침 상태 회의를 마쳤습니다.\");\n                });\n    }\n\n    static Thread workOnTasksAssigned() {\n        return virtualThread(\n                \"Work on the actual Tasks\",\n                () -\u003e {\n                    log(\"할당된 작업에 대해 실제 작업을 시작합니다.\");\n                    try {\n                        sleep(1000L);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    log(\"할당된 작업에 대한 실제 작업을 마쳤습니다.\");\n                });\n    }\n\n    static Thread attendEveningStatusMeeting() {\n        return virtualThread(\n                \"Evening Status Meeting\",\n                () -\u003e {\n                    log(\"저녁 상태 회의에 참석하겠습니다.\");\n                    try {\n                        sleep(1000L);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    log(\"저녁 상태 회의를 마쳤습니다.\");\n                });\n    }\n\n    static void concurrentRoutineExecutor() throws InterruptedException {\n        var morningMeeting = attendMorningStatusMeeting();\n        var actualWork = workOnTasksAssigned();\n        var eveningMeeting = attendEveningStatusMeeting();\n        morningMeeting.join();\n        actualWork.join();\n        eveningMeeting.join();\n    }\n}\n```\n\n위의 코드는 팩토리 메서드를 사용한 가상 스레드 생성을 보여줍니다. 팩토리 메서드 외에도 java.util.concurrent.ExecutorService를 사용하여 가상 스레드를 구현할 수 있습니다. 이를 통해 ExecutorService를 사용해 동일한 기능을 아래와 같이 구현할 수 있습니다.\n\n```js\npackage org.vaslabs;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class DailyRoutineWorkflowUsingExecutors {\n    static final Logger logger = LoggerFactory.getLogger(DailyRoutineWorkflowUsingExecutors.class);\n\n    static void log(String message) {\n        logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n    }\n\n    private static void sleep(Long duration) throws InterruptedException {\n        TimeUnit.MILLISECONDS.sleep(duration);\n    }\n\n    public static void executeJobRoute() throws ExecutionException, InterruptedException {\n        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            var morningMeeting = executor.submit(() -\u003e {\n                log(\"아침 상태 회의에 참석하겠습니다.\");\n                try {\n                    sleep(1000L);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                log(\"아침 상태 회의를 마쳤습니다.\");\n            });\n\n            var actualWork = executor.submit(() -\u003e {\n                log(\"할당된 작업에 대해 실제 작업을 시작합니다.\");\n                try {\n                    sleep(1000L);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                log(\"할당된 작업에 대한 실제 작업을 마쳤습니다.\");\n            });\n\n            var eveningMeeting = executor.submit(() -\u003e {\n                log(\"저녁 상태 회의에 참석하겠습니다.\");\n                try {\n                    sleep(1000L);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n                log(\"저녁 상태 회의를 마쳤습니다.\");\n            });\n\n            morningMeeting.get();\n            actualWork.get();\n            eveningMeeting.get();\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결과에 대한 심층 분석\n\n위의 코드를 팩토리 메서드나 ExecutorServices를 사용하여 실행하면 아래와 비슷한 결과가 나올 것입니다.\n\n![이미지](/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_3.png)\n\n정보 로그를 주의 깊게 살펴보면 \"|\" (파이프 기호)의 양쪽에 두 섹션이 표시됩니다. 첫 번째 섹션은 VirtualThread[#26]/runnable@ForkJoinPool-1-worker-3와 같이 가상 스레드에 대한 정보를 설명합니다. 이 섹션은 가상 스레드[#26]가 platform 스레드인 runnable@ForkJoinPool-1-worker-3에 매핑됨을 나타내며, 다른 섹션은 로그의 정보 부분입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 스레드 로컬 및 가상 스레드:\n\n자바의 ThreadLocal은 변수를 스레드별로 저장할 수 있는 메커니즘입니다. ThreadLocal 변수에 접근하는 각 스레드는 변수의 독립적으로 초기화된 복사본을 얻게 되며, 이를 통해 다른 스레드의 동일한 변수에 영향을 주지 않고 접근하고 수정할 수 있습니다. 이는 사용자 세션 또는 데이터베이스 연결과 같이 스레드별 상태를 유지하고자 하는 경우에 특히 유용합니다.\n\n그러나 Project Loom의 일환으로 소개된 가상 스레드와 함께 ThreadLocal을 사용할 때 동작이 크게 변경됩니다. 가상 스레드는 자바 가상 머신(JVM)에 의해 관리되는 가벼운 스레드로, 운영 체제의 스레드 관리에 묶여 있는 전통적인 플랫폼 스레드와 달리 대량으로 스케줄되도록 설계되었습니다.\n\n가상 스레드는 수백만 개로 생성될 수 있기 때문에 ThreadLocal의 사용은 메모리 누수를 발생시킬 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npackage org.vaslabs;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ThreadLocalDemo {\n    private static ThreadLocal\u003cString\u003e stringThreadLocal = new ThreadLocal\u003c\u003e();\n\n    static final Logger logger = LoggerFactory.getLogger(DailyRoutineWorkflow.class);\n\n    static void log(String message) {\n        logger.info(STR.\"{} | \\{message}\", Thread.currentThread());\n    }\n\n    private static void sleep(Long duration) throws InterruptedException {\n        TimeUnit.MILLISECONDS.sleep(duration);\n    }\n\n    public static void virtualThreadContext() throws InterruptedException {\n        var virtualThread1 = Thread.ofVirtual().name(\"thread-1\").start(() -\u003e {\n            stringThreadLocal.set(\"thread-1\");\n            try {\n                sleep(1000L);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            log(STR.\"thread name is \\{stringThreadLocal.get()}\");\n        });\n        var virtualThread2 = Thread.ofVirtual().name(\"thread-2\").start(() -\u003e {\n            stringThreadLocal.set(\"thread-2\");\n            try {\n                sleep(1000L);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            log(STR.\"thread name is \\{stringThreadLocal.get()}\");\n        });\n        virtualThread1.join();\n        virtualThread2.join();\n    }\n}\n```\n\n## 결론:\n\n요약하면, 이 Java 스레딩 모델에 관한 기사는 Virtual Threads, Platform Threads 및 ThreadLocal의 세부 사항을 살펴봄으로써 Java에서 동시성 프로그래밍의 진화하는 풍경을 밝혀줍니다. Virtual Threads은 가벼우면서 효율적인 동시성을 제공하며 리소스 집약적인 Platform Threads의 본질과는 대조적인 점을 보여줍니다. 이들은 대규모의 동시 작업을 최소한의 리소스 오버헤드로 실행하여 프로그래밍 모델을 간소화하고 응용프로그램 확장성을 향상시키는 방식으로 Java의 스레드 처리 방법을 혁신합니다.\n\n그러나 이 새로운 맥락에서 ThreadLocal 사용의 복잡성은 신중한 고려가 필요함을 강조합니다. ThreadLocal은 기존 스레딩에서 스레드별 데이터를 유지하는 강력한 도구로 남아 있지만, 가상 스레드에서는 더 복잡해지므로 상태 및 컨텍스트 관리를 위한 대체 전략이 필요합니다. 이러한 개념들은 Java의 동시성 패러다임에서 중대한 변화를 나타내며, 개발자들이 보다 반응성이 뛰어나고 확장 가능하며 효율적인 애플리케이션을 구축할 수 있는 새로운 기회를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 스택아데믹\n\n끝까지 읽어주셔서 감사합니다. 마지막으로:\n\n- 작가를 응원하고 팔로우해주시길 바랍니다! 👏\n- 트위터(X), 링크드인, YouTube에서 팔로우해주세요.\n- 전 세계적으로 프로그래밍 교육을 무료로 제공하는 방법에 대해 자세히 알아보려면 Stackademic.com을 방문해주세요.\n","ogImage":{"url":"/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_0.png"},"coverImage":"/assets/img/2024-06-23-JavaThreadingEssentialsVirtualvsPlatformThreadsExplained_0.png","tag":["Tech"],"readingTime":14},{"title":"깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기","description":"","date":"2024-06-23 20:33","slug":"2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach","content":"\n![2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png](/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png)\n\n# 소개\n\n우리 조직의 애플리케이션 기능을 향상시키는 과정에서, JSON 조작에 관련된 매력적인 문제를 만났습니다. 특정 경로에 있는 JSON 노드의 값을 수정하는 작업은 트리 구조를 탐색하는 것과 유사한 문제입니다. 이를 해결하기 위해 Depth-First Search (DFS) 접근 방식을 활용해보았고, 이 방법이 이 문제를 효과적으로 해결하는 데 도움이 되었습니다.\n\n# 문제 이해하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJSON (JavaScript Object Notation)은 컴퓨터 과학에서 사용되는 트리와 유사한 계층 구조와 간결함으로 인해 데이터 교환에 널리 사용됩니다. 문제는 이와 같은 트리 구조 내에서 특정 경로의 값을 동적으로 액세스하고 수정해야 하는 것이 필요했습니다. 예를 들어, 경로 a.b.c에서 '\"a\": '\"b\": '\"c\": 123''를 변환하는 것은 전형적인 JSON 탐색 및 수정을 보여줍니다.\n\n# 접근 방식 및 통찰\n\n## 1. JSON을 트리로 다루기\n\nJSON의 중첩된 키-값 쌍은 트리에서 노드로 해석될 수 있으며, 객체는 내부 노드를 나타내고 배열은 노드들의 집합을 나타냅니다. 각 노드는 루트에서 리프 노드까지 탐색하는 것과 유사하게 경로를 통해 액세스할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 깊이 우선 탐색 (DFS) 응용\n\nDFS는 기본적인 트리 순회 알고리즘으로, 다음 문제 해결에 중요한 역할을 했습니다:\n\n- 재귀적 탐색: 루트(최상위 객체)에서 시작하여 중첩된 객체와 배열을 재귀적으로 탐색합니다.\n- 경로 탐색: 제공된 경로 문자열 (a.b.c - `[\"a\", \"b\", \"c\"])을 사용하여 중첩된 구조물을 효율적으로 탐색합니다.\n- 유연한 수정: 대상 노드를 식별한 후, 간단한 값 업데이트 또는 배열 내 요소 변환 등 구체적인 요구에 따라 값을 수정할 수 있습니다.\n\n## 3. 구현 여정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- JSON 파싱: Java의 org.json과 같은 라이브러리를 활용하여 JSON 객체를 분석하고 조작하는 작업을 원활하게 수행했습니다.\n- 경로 처리: 경로 문자열을 동적으로 분할하고 해석하여 중첩된 객체를 탐색하는 데 활용했습니다.\n- 시나리오 처리: JSON 객체 내에 배열이 존재하는 경우와 같은 시나리오를 다루며, 모든 요소가 수정되어야 하는 경우를 대응했습니다.\n\n# 코드 구현 예제\n\n```java\nimport org.json.*;\n\npublic class JsonManipulation {\n\n    public static String modifyJsonNode(String json, String path) {\n        JSONObject jsonObj = new JSONObject(json);\n        String[] keys = path.split(\"\\\\.\");\n        modifyNode(jsonObj, keys, 0);\n        return jsonObj.toString();\n    }\n\n    private static void modifyNode(JSONObject jsonObj, String[] keys, int index) {\n        String key = keys[index];\n        if (index == keys.length - 1) {\n            if (jsonObj.get(key) instanceof JSONArray) {\n                JSONArray array = jsonObj.getJSONArray(key);\n                for (int i = 0; i \u003c array.length(); i++) {\n                    array.put(i, \"modified\");\n                }\n            } else {\n                jsonObj.put(key, \"modified\");\n            }\n        } else {\n            modifyNode(jsonObj.getJSONObject(key), keys, index + 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        String json = \"{\\\"a\\\": {\\\"b\\\": {\\\"c\\\": 123}}\";\n        String path = \"a.b.c\";\n        System.out.println(modifyJsonNode(json, path));\n    }\n}\n```\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDFS를 활용한 JSON 조작 탐구는 이 알고리즘이 JSON과 같은 계층 구조 데이터를 탐색하고 수정하는 다양성을 강조합니다. DFS 원칙을 적용함으로써 우리는 특정 경로를 기반으로 JSON 노드에 동적으로 접근하고 수정하는 작업을 효율적으로 처리했습니다.\n\n소프트웨어 엔지니어로서 DFS와 같은 알고리즘 기법을 받아들이면 복잡한 데이터 조작 작업을 자신 있게 다룰 수 있습니다. 이 여정은 일상적인 코딩 과제에서 알고리즘적 사고의 중요성을 강조하며 문제 해결 능력과 소프트웨어 개발 혁신 능력을 함께 향상시킵니다.\n","ogImage":{"url":"/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png"},"coverImage":"/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png","tag":["Tech"],"readingTime":4},{"title":"Spring Boot3에서 트레이싱 활용하는 방법","description":"","date":"2024-06-23 20:31","slug":"2024-06-23-TracinginSpringBoot3","content":"\n![2024-06-23-TracinginSpringBoot3_0](/assets/img/2024-06-23-TracinginSpringBoot3_0.png)\n\n제 초창기 전문가 시절을 돌이켜보면, 프로덕션 문제 해결 방식에서 조금 놀라운 점이 있었습니다. 모든 것을 다 다루는 프로젝트에서 일했는데, 고객과의 인터페이싱부터 코딩, 배포, 그리고 문제 해결까지 모든 것을 처리했죠. 문제가 발생하면 명쾌한 해결책이 없는 상황이었고, 그때의 나는 프로덕션 데이터베이스 덤프를 떠서 해당 데이터베이스를 이용해 내 컴퓨터에서 애플리케이션을 실행한 다음 고객과 통화하면서 그들이 하는 작업을 재현하고 문제점을 확인하기 위해 필요한 디버그 지점 및 출력문을 사용했어요. 그 방식은 그 당시에는 효과적이었습니다. 애플리케이션은 작고 사용자 베이스가 제한적이었으며, 단일 개발자로는 완전히 관리할 수 있었지만, 그때는 여전히 로깅의 중요성을 이해하지 못했죠.\n\n몇 년 후, 이제는 여러 개발자, 제품 소유자, 스크럼 마스터, 운영팀, 인프라팀, 그리고 물론 수백만 명의 사용자가 참여하는 프로젝트에서 일하고 있습니다. 중요한 점은 개발자에게는 프로덕션 환경이 대부분 접근 불가능하며, 또한 고객이 개발자와 직접 커뮤니케이션할 수 없으므로 우리를 미치게 만든다는 사실입니다.\n\n운영팀은 이 두 영역 사이의 다리 역할을 했습니다. 그들의 주요 업무는 시스템, 애플리케이션 로그, 필요시 데이터베이스를 조사하여 문제를 해결하는 것이었죠. 해결책을 찾지 못하거나 향상 시야를 가지고 있다면 해당 데이터로 개발자에게 접근하게 됐습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 환경에서 작업하면서 로그의 중요성을 점차 알게 되었습니다. 로그는 응용프로그램이나 거래의 이벤트를 추적하는 데 도움이 됩니다. 적절한 분석을 통해 패턴을 찾거나 이상 현상을 예측하는 데 도움이 됩니다.\n\n하지만 분산 추적에 대해 아직 많이 알지 못했습니다. 다양한 식별자(전화번호, 사용자 ID 등)를 추가하여 운영팀이 고객 문제를 적절히 조사할 수 있도록 했습니다.\n\n그러나 이 방법에도 문제가 있었습니다. 동일한 고객이 시스템과 다양한 상호 작용을 할 수 있어, 해당 식별자로 여러 로그 스트림이 생성되었습니다. 따라서 문제에 대한 정확한 로그를 찾는 것은 여전히 번거로웠습니다. 여러 애플리케이션이 관련될 때의 고통은 시작도 못 했죠. 서비스 호출 간 페이로드에 수동으로 UUID를 추가하고 로그를 남겼습니다.\n\n결국에는 내 현재 접근 방식이 부족하다는 것이 명백해졌습니다. 내 일부 응용프로그램은 다른 팀이 유지보수하는 다른 애플리케이션 사이에서 미들웨어로 작용했습니다. 그들이 내 불편함을 용인해야 할 이유가 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음, Sleuth를 발견했어요. 정말 놀라웠죠; 단 하나의 의존성을 추가하고 로깅을 구성하기만 하면 어플리케이션 전체에 대한 추적을 활성화할 수 있었어요. 여러 개의 마이크로서비스를 사용하더라도 서비스 간 추적 ID를 전파하기 위한 추가적인 조치가 필요하지 않았어요.\n\nSpring Boot 3 이전에는 프로젝트를 시작할 때마다 항상 Spring Cloud Sleuth를 포함해 분산 추적을 활성화했어요.\n\n그런 다음 Spring Boot 3이 나오면서 Sleuth가 Micrometer로 이관되었어요. 이 기사에서는 Micrometer 추적을 활용해 Spring Boot 3에서 Sleuth와 유사한 기능을 어떻게 구현하는지 살펴볼 거예요.\n\n지금은 컨트롤러와 서비스가 있는데, 일부 로그를 사용하고 있어요. 포스트맨으로 컨트롤러 엔드포인트에 요청을 보내면 다음과 같은 로그를 얻게 돼요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n2024-02-23T23:28:18.043+06:00  INFO 14443 --- [rest-api] [nio-8080-exec-2] x.r.t.restapi.web.MessageController   : Received message: Message(header=some header, content=some content)\n2024-02-23T23:28:18.046+06:00  INFO 14443 --- [rest-api] [nio-8080-exec-2] x.r.t.r.service.MessageServiceImpl    : Handling message Message(header=some header, content=some content)\n```\n\n추적이 없다는 것을 명확하게 알 수 있어요. 이제 다음 종속성을 추가할 거에요:\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\n  \u003cartifactId\u003emicrometer-tracing-bridge-brave\u003c/artifactId\u003e\n  \u003cscope\u003ecompile\u003c/scope\u003e\n\u003c/dependency\u003e\n```\n\n동일한 엔드포인트를 한 번 더 호출해보세요. 그런데 여전히 운이 없거나 로그가 없어요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인터넷 검색 결과를 통해 작업을 수행하기 위해 액추에터도 추가해야 한다는 것을 알아냈습니다.\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n  \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\n  \u003cscope\u003ecompile\u003c/scope\u003e\n\u003c/dependency\u003e\n```\n\n동일한 엔드포인트를 다시 요청하면 다음과 같은 로그가 생성됩니다:\n\n```js\n2024-02-24T00:11:06.050+06:00  INFO 18463 --- [rest-api] [nio-8080-exec-1] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.r.t.restapi.web.MessageController   : Received message: Message(header=some header, content=some content)\n2024-02-24T00:11:06.053+06:00  INFO 18463 --- [rest-api] [nio-8080-exec-1] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.r.t.r.service.MessageServiceImpl    : Handling message Message(header=some header, content=some content)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 보세요. [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] 이 부분에는 트레이스 ID와 스팬 ID가 포함되어 있습니다.\n\n이제 다른 서비스를 호출할 수 있는지 확인해 봅시다. 그리고 트레이스 ID가 거기로 전달되는지도 확인해 봅니다.\n\n저는 rest-api-2 라는 다른 서비스를 만들었습니다. 해당 서비스에는 필요한 컨트롤러, 서비스 및 필요한 종속성이 포함되어 있습니다.\n\n이제 새롭고 화려한 rest-client를 사용하여 rest-api에서 rest-api-2로 HTTP 호출을 해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nrest-api에서 MessageServiceImpl을 수정한 내용은 다음과 같습니다:\n\n```js\n@Service\n@Slf4j\npublic class MessageServiceImpl implements MessageService {\n\n private final RestClient restClient;\n public MessageServiceImpl(@Value(\"${rest-api-2.url}\") String restApi2Url) {\n     this.restClient  = RestClient.builder().baseUrl(restApi2Url)\n         .defaultHeader(\"Content-Type\", MediaType.APPLICATION_JSON_VALUE).build();\n\n }\n\n @Override\n public void handleMessage(Message message) {\n     log.info(\"처리할 메시지: {}\", message);\n     this.restClient.post().uri( \"/process-message\").body(message).retrieve();\n\n }\n\n}\n```\n\n여기서 생성자에서 rest 클라이언트의 인스턴스를 선언했습니다. 그런 다음, 서비스에서 rest-api-2로 호출을 수행했습니다.\n\nrest-api의 로그:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n2024-02-24T14:31:13.060+06:00  INFO 29880 --- [rest-api] [nio-8080-exec-5] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.r.t.restapi.web.MessageController   : Received message: Message(header=some header, content=some content)\n2024-02-24T14:31:13.061+06:00  INFO 29880 --- [rest-api] [nio-8080-exec-5] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.r.t.r.service.MessageServiceImpl    : Handling message Message(header=some header, content=some content)\n```\n\nrest-api-2의 로그:\n\n```js\n2024-02-24T14:31:13.072+06:00  INFO 29563 --- [rest-api-2] [nio-8081-exec-7] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.r.t.r.web.MessageProcessorController   : Received message for processing Message(header=some header, content=some content)\n2024-02-24T14:31:13.072+06:00  INFO 29563 --- [rest-api-2] [nio-8081-exec-7] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.r.t.r.s.MessageProcessorServiceImpl : Processing Message Message(header=some header, content=some content)\n```\n\nrest-api-2의 traceId와 spanId가 있는 것을 확인할 수 있어요. 하지만, 이들은 일치하지 않아요! 각 요청마다 새로운 추적 컨텍스트를 시작하고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 첫 번째 애플리케이션에서의 traceId가 두 번째 애플리케이션으로 전파되지 않는 것을 의미합니다.\n\n이를 확인해 보겠습니다.\n\nrest-api-2 애플리케이션을 중지하고, 해당 애플리케이션이 실행되던 포트를 듣기 시작한 것을 netcat이라는 도구로 확인했습니다:\n\n![이미지](/assets/img/2024-06-23-TracinginSpringBoot3_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 엔드포인트가 호출되면 다음과 같은 내용을 받습니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_2.png\" /\u003e\n\n보시다시피, traceId를 포함한 일부 헤더가 있어야 하는데 없습니다. 요청에 추적 컨텍스트가 포함된 적절한 헤더가 있는지 확인해야 합니다.\n\n이건 그렇게 어렵지 않아요. 우리는 스프링 부트가 자동으로 구성한 기본 restClient 빌더를 사용해야 합니다. 이것은 traceId를 전파하기 위한 필요한 지식을 갖고 있습니다. 다음과 같이 할 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic MessageServiceImpl(@Value(\"${rest-api-2.url}\") String restApi2Url, RestClient.Builder restClientBuilder) {\n     this.restClient  = restClientBuilder.baseUrl(restApi2Url)\n         .defaultHeader(\"Content-Type\", MediaType.APPLICATION_JSON_VALUE).build();\n\n }\n```\n\n우리는 서비스의 생성자를 통해 기본 RestClient.Builder를 받았습니다. 코드의 나머지 부분은 간단합니다. 이제 요청을 초기화하면 다음과 같은 것을 볼 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_3.png\" /\u003e\n\n이제 우리에게 traceId를 포함한 traceparent라는 헤더가 있습니다. 이제 netcat을 중지하고 rest-api-2 애플리케이션을 시작하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 애플리케이션 로그:\n\n![2024-06-23-TracinginSpringBoot3_4.png](/assets/img/2024-06-23-TracinginSpringBoot3_4.png)\n\n두 번째 애플리케이션 로그:\n\n![2024-06-23-TracinginSpringBoot3_5.png](/assets/img/2024-06-23-TracinginSpringBoot3_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 빙고!\n\n두 애플리케이션 간에 트레이스 ID가 일치하는 것을 볼 수 있습니다. 단, spanId는 일치하지 않지만, 이는 예상한 바입니다.\n\n서비스를 리팩토링할 수 있는 좋은 시기라고 생각합니다. 여기서 rest-client를 선언하는 대신, 구성 클래스에서 재사용 가능한 빈으로 선언할 것입니다.\n\nRest client 구성 클래스는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n@Configuration\npublic class RestClientConfig {\n @Bean(\"restApi2Client\")\n RestClient restApi2Client(@Value(\"${rest-api-2.url}\") String restApi2Url, RestClient.Builder restClientBuilder) {\n     return restClientBuilder.baseUrl(restApi2Url)\n         .defaultHeader(\"Content-Type\", MediaType.APPLICATION_JSON_VALUE).build();\n }\n\n}\n```\n\nAnd refactored MessageServiceImpl class:\n\n```java\n@Service\n@Slf4j\npublic class MessageServiceImpl implements MessageService {\n\n private final RestClient restClient;\n\n public MessageServiceImpl(@Qualifier(\"restApi2Client\") RestClient restClient) {\n     this.restClient = restClient;\n }\n\n\n @Override\n public void handleMessage(Message message) {\n     log.info(\"Handling message {}\", message);\n     this.restClient.post().uri( \"/process-message\").body(message).retrieve();\n\n }\n\n}\n```\n\nCleaner right ?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 단순한 데모입니다. Micrometer를 활용하여 다른 관측 가능성 사용 사례에 대해 더 많이 쓸 예정이에요.\n\n여기 모든 코드가 있는 레포입니다.\n\n즐거운 코딩하세요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*5D9ZTssrYkDI-7hN0fAVkw.gif)\n","ogImage":{"url":"/assets/img/2024-06-23-TracinginSpringBoot3_0.png"},"coverImage":"/assets/img/2024-06-23-TracinginSpringBoot3_0.png","tag":["Tech"],"readingTime":12},{"title":"Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상","description":"","date":"2024-06-23 20:29","slug":"2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond","content":"\n![BuildinggdocwebwithJava21SpringBoot3xandBeyond](/assets/img/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond_0.png)\n\n새 프로젝트를 시작하는 것은 항상 흥분과 어려운 결정의 조합입니다, 특히 Google Docs와 GitHub Pages 같은 익숙한 도구들을 함께 사용할 때는 더욱 그렇습니다. 이것은 많은 사람들에게 삶을 더 쉽게 만들어줄 것으로 기대한 도구 gdocweb을 구축한 이야기입니다. Java 21과 Spring Boot 3.x를 선택한 이유, 일부 시행착오를 거친 뒤 GraalVM을 포기한 이유, 그리고 좀 더 복잡한 옵션보다 간단한 VPS와 Docker Compose가 이겼다는 이야기를 들려드리겠습니다. 저는 또한 Postgres와 JPA를 선택했지만 Flyway와 같은 마이그레이션 도구는 피했습니다. 이것은 유용하고 효율적인 것을 만들려는 엔지니어의 선택, 변화 및 가끔의 '아하' 순간들을 솔직하게 기록한 이야기입니다.\n\n# gdocweb 소개\n\ngdocweb을 구축하는 기술적 세부 사항과 의사 결정의 미로에 빠지기 전에, gdocweb이 무엇이며 어떤 문제를 해결하는지를 이해하는 것부터 시작해볼까요? 간단히 말해, gdocweb은 Google Docs를 GitHub Pages에 연결하는 것입니다. GitHub의 모든 강력함과 Google Docs의 모든 사용 편의성을 갖춘 무료 사이트를 생성하는 간단한 웹 빌더입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n웹사이트 구축 및 문서 작성에 일반적으로 동반되는 복잡성을 제거하기 위해 gdocweb를 개발하기로 결정했어요. 이는 콘텐츠를 발행하고 유지 관리하는 데 번거로움 없이 사용하고자 하는 사용자들을 위한 것이지만, GitHub의 강력함에는 빠져들지만 마크다운의 세세한 부분까지 다루고 싶지 않은 숙달된 사용자들을 위한 것입니다.\n\n일반 대중을 위해 gdocweb를 설명하는 짧은 비디오가 있어요:\n\n# Java 21 및 Spring Boot 3.x: 혁신과 성숙함\n\ngdocweb와 같이 프로젝트를 혼자 이끌 때, 팀이나 기업 환경에서는 더 어려울 수 있는 기술 선택을 마음대로 할 수 있어요. 이 자유로움으로 인해 이 프로젝트에서 Java 21 및 Spring Boot 3.x를 선택했어요. 현재 장기 지원(LTS) 버전인 Java를 선택한 결정은 올바른 선택이었어요. 최신 기술을 사용하는 것이 항상 유혹적이지만, Java 21을 선택한 이유는 새로운 것을 사용하는 데 그치지 않고, 시대를 견뎌낼 수 있고 현대적인 개발 요구를 충족시키기 위해 진화한 플랫폼을 활용하고자 했기 때문이에요. 가상 쓰레드는 Java 21 선택의 주요 부분이었어요. 이러한 프로젝트에서 비용은 매우 중요한 요소이며, 서버로부터 최대 처리량을 뽑아내는 것은 이러한 상황에서 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바는 이미 성숙한 기술로, 최신 버전에서도 신뢰감을 제공합니다. 비슷하게, 최신 버전인 스프링 부트 3.x도 견고하고 테스트된 프레임워크 계보에서 나온 제품입니다. 오랜 명성을 자랑하는 보수적인 선택이지만 기능과 성능 측면에서 혁신적입니다.\n\n하지만 이 결정도 순탄치 않았어요. Google API 접근을 통합하는 과정에서 보안 CASA 티어 2 검토를 거쳐야 했죠. 이때 자바 21을 선택한 것이 문제였습니다. 해당 검토 도구는 JDK 11을 위해 제작됐기 때문에 JDK 21에서도 작동은 했지만 프로세스에 약간의 스트레스를 준 케이스였습니다. 최신 기술 버전을 다룰 때 예상치 못한 어려움이 있을 수 있다는 것을 다시 상기시켜 주었죠. 심지어 자바와 같이 성숙한 기술이더라도요.\n\n스프링 부트 3.x로 전환하는 과정도 다양한 도전이 있었는데, 특히 보안 구성 변경 때문에 어려움을 겪었습니다. 이러한 수정으로 인해 대부분의 온라인 샘플과 안내서가 사용할 수 없게 되어 초기 설정을 많이 망가뜨렸죠. 이러한 변화에 적응하고 새로운 방법을 찾는 학습 곡선이었지만, 대부분의 다른 측면은 비교적 간단했고, 스프링 부트 3.x에 대해 할 수 있는 가장 좋은 칭찬은 스프링 부트 2.x와 매우 유사하다는 점입니다.\n\n# 효율을 위한 GraalVM 네이티브 이미지\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGraalVM 네이티브 이미지에 대한 저의 관심은 기본적으로 메모리 사용량을 줄이고 시작 시간을 빠르게 하는 약속 때문이었습니다. 낮은 메모리 요구 사항으로 더 많은 서버 인스턴스를 실행하여 더 나은 확장성과 내구성을 가질 수 있다는 아이디어를 갖고 있었고, 시작 시간이 빨라지면 장애로부터 더 빠른 회복이 가능해져 신뢰할 수 있는 서비스를 유지하는 데 중요했습니다.\n\n# GraalVM 구현\n\nGraalVM을 동작시키는 것은 쉽지 않았지만 너무 어렵지는 않았습니다. 몇 차례의 시행착오 끝에 GraalVM 프로젝트를 빌드하고 Docker에 업로드하는 지속적 통합(CI) 프로세스를 설정할 수 있었습니다. 제가 M1 Mac을 사용하고 있지만 서버는 Intel 아키텍쳐에서 실행 중이었기 때문에 이러한 설정이 필요했습니다. 이러한 설정으로 업데이트마다 18분의 대기 시간을 처리해야 했는데, 개발 주기에 상당한 지연이었습니다.\n\n# 프로덕션에서 직면한 문제들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로젝트의 프로덕션 및 스테이징 환경을 테스트하기 시작하면서 상황이 복잡해졌어요. 네이티브 이미지에서 빠진 라이브러리 코드로 '두더지 잡기' 상황이 벌어졌죠. 해결한 문제마다 새로운 문제가 발생하고, 각 업데이트마다 18분씩 걸리는 과정이 답답함을 더했어요.\n\n문제의 결정적 순간은 Google API 라이브러리와의 호환성 문제를 깨달았을 때였어요. 이 문제를 해결하기 위해서는 GraalVM 빌드에서의 철저한 테스트가 필요했는데, 이미 느린 빌드 시간으로 부담을 느끼고 있었죠. 제 작은 프로젝트에 대해선 수고에 비해 이득이 미미한 병목 현상이었어요.\n\n# 진행 방향 결정\n\nGraalVM은 자원을 아낄 수 있는 이상적인 선택처럼 보였지만, 현실은 다르았어요. 제한된 GitHub Actions 분을 사용하고 철저한 테스트를 요구하여, 이 프로젝트 규모에선 실용적이지 않았죠. 결국, GraalVM 경로를 포기하기로 결정했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 GraalVM을 사용하기로 결정하신다면, 저는 다음 GitHub Actions 스크립트를 사용했었는데요. 여러분의 여정에 도움이 됐으면 좋겠어요:\n\n```js\nname: Java CI with Maven\non:\n  push:\n    branches: [ \"master\" ]\n  pull_request:\n    branches: [ \"master\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:latest\n        env:\n          POSTGRES_PASSWORD: yourpassword\n        ports:\n          - 5432:5432\n        options: \u003e-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    steps:\n    - uses: actions/checkout@v3\n    - uses: graalvm/setup-graalvm@v1\n      with:\n        java-version: '21'\n        version: '22.3.2'\n        distribution: 'graalvm'\n        cache: 'maven'\n        components: 'native-image'\n        native-image-job-reports: 'true'\n        github-token: ${ secrets.GITHUB_TOKEN }\n    - name: Wait for PostgreSQL\n      run: sleep 10\n    - name: Build with Maven\n      run: mvn -Pnative native:compile\n    - name: Build Docker Image\n      run: docker build -t autosite:latest .\n    - name: Log in to Docker Hub\n      uses: docker/login-action@v1\n      with:\n        username: ${ secrets.DOCKERHUB_USERNAME }\n        password: ${ secrets.DOCKERHUB_TOKEN }\n    - name: Push Docker Image\n      run: |\n        docker tag autosite:latest mydockeruser/autosite:latest\n        docker push mydockeruser/autosite:latest\n```\n\n이 구성은 GraalVM의 혜택을 활용하기 위한 제 시도의 중요한 부분이었지만, 프로젝트가 진화함에 따라 기술 선택에서 이상주의와 배포 및 유지보수의 실용성 사이의 상충을 이해하는 데 도움이 되었습니다.\n\n# 배포: VPS 및 Docker Compose\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ngdocweb을 배포할 때 고려해야 할 여러 가지 방법이 있었어요. 각 옵션에는 각각의 장단점이 있었지만, 신중한 평가 끝에 Docker Compose를 사용하는 Virtual Private Server (VPS)를 사용하기로 결정했어요. 제 생각 프로세스를 자세히 살펴보고, 이 선택이 제 요구 사항에 가장 적합한 이유를 알아봐요.\n\n# 원시 VPS 배포 피하기\n\nVPS에 애플리케이션을 직접 설치하는 간단한 방법을 제외했어요. 이 방법은 이주 편의성, 테스트 및 유연성 면에서 부족했어요. 컨테이너는 더 간편하고 효율적인 접근 방식을 제공해요. 서로 다른 환경 사이에서 추상화 수준과 일관성을 제공하여 매우 가치 있는 것이에요.\n\n# 관리형 컨테이너 및 오케스트레이션 회피하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n관리형 컨테이너와 오케스트레이션 (예: k8s)은 다른 옵션이었고, 확장성과 관리 용이성을 제공하지만 다른 영역에서 복잡성을 도입합니다. 예를 들어, 관리형 Kubernetes 서비스를 사용할 때 데이터베이스에 대해 클라우드 스토리지에 의존해야 한다는 것이 종종 곧 비용이 빠르게 증가할 수 있다는 것을 의미합니다. 나의 철학은 프로젝트 초기 단계에서 횡적 규모보다는 비용에 초점을 맞추는 것이었습니다.\n\n작은 규모에서 최적화하고 안정화하지 않으면 성장함에 따라 문제가 점점 더 심각해질 것입니다. 확장은 이상적으로는 수직 확장부터 시작해야 하며, 이후에 수평 확장으로 이동해야 합니다. 수직 확장은 더 많은 CPU/RAM을 의미하고, 수평 확장은 추가적인 머신을 추가합니다. 수직 확장은 비용 효율적일 뿐만 아니라 기술적 측면에서도 중요합니다. 간단한 프로파일링 도구를 사용하여 성능 병목 현상을 식별하기가 더 쉬워집니다.\n\n반면에, 수평 확장은 더 많은 인스턴스를 추가하여 이러한 문제를 숨기는 경우가 많습니다. 이는 높은 비용과 숨겨진 성능 문제로 이어질 수 있습니다.\n\n# Docker Compose의 선택\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 컴포즈는 몇 가지 이유로 명백한 우승자로 떴어요. 데이터베이스와 응용 프로그램 컨테이너를 원활하게 통합할 수 있게 해주었습니다. 그들의 통신은 폐쇄된 네트워크 안에서 이루어지므로 외부에서 접근할 수 있는 포트가 없어 안전성이 높아졌습니다. 또한 비용은 고정되어 예측 가능하며 사용량에 따른 뜻밖의 추가 비용이 없다는 장점이 있어요.\n\n이러한 설정은 더 확장된 컨테이너 오케스트레이션 시스템의 부담과 복잡성 없이 유연성과 컨테이너화의 쉬움을 제공했어요. 배포 프로세스를 복잡하게 만들지 않으면서도 필요한 기능을 충분히 제공하는 완벽한 중간 지점이었습니다.\n\n도커 컴포즈를 사용함으로써 환경을 효율적으로 제어하고 배포 프로세스를 간단하고 관리하기 쉽게 유지했어요. 이 결정은 gdocweb의 일반적인 이념 — 간결함, 효율성, 실용성과 완벽하게 부합했어요.\n\n# 프론트엔드: 현대적인 대안들보다 Thymeleaf를 선호합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ngdocweb의 프론트엔드 개발은 나에게 조금 도전이었습니다. React와 유사한 프레임워크가 주를 이루는 시대에 Thymeleaf를 선택하는 것은 거꾸로 보일 수 있지만, 이 결정은 실용적인 고려와 프로젝트 요구 사항 및 개발자로서의 내 강점에 대한 명확한 이해를 기반으로 합니다.\n\n# React: 현대적이지만 일치하지 않는 해결책\n\nReact는 틀림없이 현대적이고 강력하지만, 그것만의 복잡성이 딸려옵니다. React에 대한 내 경험은 많은 개발자들이 편안한 영역을 벗어나 시도하는 것과 유사합니다 - 기능적이지만 정확히 능숙하지는 않습니다. 내 코드를 보는 시니어 React 개발자들이 느끼는 당황한 표정을 보았습니다. 다른 사람이 작성한 복잡한 Java 코드를 읽을 때 내가 느끼는 것과 비슷합니다.\n\nReact의 학습 곡선과 특정 시나리오에서의 성능 저하, 깊은 전문 지식 없이는 세련된 결과물을 얻을 수 없는 위험 등을 고려하여 gdocweb에 적합성을 재고하게 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Thymeleaf의 매력\n\nThymeleaf는 다른 방면에서 더 직관적인 접근 방식을 제공하며, 이 프로젝트의 간결함과 효율성에 잘 맞습니다. React와 같은 프레임워크와 비교할 때 낡은 것으로 여겨질 수 있는 HTML 기반의 인터페이스가 상당한 장점을 가지고 있습니다:\n\n- 페이지 흐름의 간단함: Thymeleaf는 이해하기 쉽고 디버깅하기 쉬운 흐름을 제공하여 이 프로젝트에 실용적인 선택이 됩니다.\n- 성능과 속도: 빠른 성능으로 유명하며, 좋은 사용자 경험을 제공하는 중요한 요소입니다.\n- NPM이 필요 없음: Thymeleaf는 추가적인 패키지 관리가 필요 없으므로 복잡성과 잠재적인 취약점을 줄입니다.\n- 클라이언트 측 취약점의 위험 감소: Thymeleaf의 서버 측 성격은 클라이언트 측 문제의 위험을 본질적으로 줄입니다.\n\n# 동적 기능에 대한 HTMX 고려\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHTMX를 사용하여 프론트엔드의 동적 동작을 구현하는 아이디어가 머릿속을 스쳤어요. HTMX는 동적 기능을 쉽게 추가할 수 있다고 해서 얼마 전부터 주목하고 있었어요. 그러나 기본적으로 간단한 위자드인 gdocweb과 같은 도구에 HTMX가 정말 필요한지 스스로에게 물어보았어요. 제 결론은 HTMX를 선택하는 것이 기술적인 필요성보다는 내가 이력서에 쓰기 좋을 것 같아하는 Resume Driven Design (RDD)일지도 모른다는 것이었어요.\n\n요약하면, Thymeleaf 선택은 실용성, 익숙함, 효율성을 결합한 것이었어요. 더 현대적이지만 복잡성과 과도한 부담이 있는 다른 프레임워크를 사용할 필요는 없었지만 빠르고 간편하며 효과적인 프론트엔드를 구축할 수 있게 했어요.\n\n# 마지막으로\n\n이 글에서 중요한 점은 기술 선택에서 실용성의 중요성입니다. 우리가 직접 프로젝트를 구축할 때는 더 최신 기술을 실험하기 쉽지만, 이는 가파른 경사입니다. 실험을 하면서도 익숙한 지식을 바탕으로 균형을 유지해야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGraalVM을 사용하면서 기술 선택을 프로젝트 요구 사항과 조화롭게 맞추고 도전에 적응하는 유연성이 얼마나 중요한지를 깨달았어요. 기술에서 때로는 더 간단하고 시험된 길이 가장 효과적일 수 있다는 것을 상기시켜 주는 것 같아요.\n","ogImage":{"url":"/assets/img/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond_0.png"},"coverImage":"/assets/img/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond_0.png","tag":["Tech"],"readingTime":11},{"title":"시네크론 자바 인터뷰 질문 및 답변 경력 2-4년","description":"","date":"2024-06-23 20:27","slug":"2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp","content":"\n\"안녕하세요 여러분, 이 글에서는 Synechron 기술 회사에서 Java 개발자 직무를 위한 인터뷰 질문과 답변을 공유하겠습니다. 함께 알아보세요.\"\n\n![이미지](/assets/img/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp_0.png)\n\nJava의 Stream API는 Java 8에서 도입된 기능입니다. 이는 Stream이라는 새로운 추상화를 제공하여 데이터를 선언적인 방식으로 처리할 수 있게 합니다. Stream API는 객체 컬렉션을 처리하는 데 사용되며, 복잡한 작업을 일련의 단계로 수행할 수 있도록 합니다.\n\nJava의 Stream은 일련의 요소를 지원하며 순차적 및 병렬 집계 작업을 지원합니다. 이러한 작업에는 데이터 필터링, 매핑, 정렬 또는 기타 데이터 조작이 포함될 수 있습니다.\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 내부적으로 작동 방식을 설명합니다:\n\n- 생성: 스트림은 배열, 컬렉션 또는 I/O 채널과 같은 소스에서 생성됩니다. 소스는 스트림 객체로 래핑됩니다.\n- 구성: 스트림 객체는 일련의 변환 작업으로 구성됩니다. 이러한 변환 작업은 즉시 적용되지 않고 대신 작업 파이프라인으로 저장됩니다. 각 작업은 스트림을 입력으로 사용하고 스트림을 출력으로 생성하는 함수입니다.\n- 실행: 스트림 객체에서 collect, reduce, forEach 등과 같은 최종 작업이 호출되면 처리가 시작됩니다. 데이터는 파이프라인의 모든 작업을 통해 한 번에 하나씩 파이프로 이동합니다. 작업은 \"게으른(lazy)\" 방식으로 처리되며 필요할 때만 실행됩니다.\n- 사용: 스트림이 사용되고 다시 사용할 수 없습니다. 데이터를 다시 탐색해야 하는 경우 새로운 스트림을 생성해야 합니다.\n\n```java\nList\u003cString\u003e names = Arrays.asList(\"John\", \"Jane\", \"Adam\", \"Eve\");\nList\u003cString\u003e uppercaseNames = names.stream()  // 스트림 생성\n    .filter(name -\u003e name.startsWith(\"A\"))      // \"A\"로 시작하는 이름 필터링\n    .map(String::toUpperCase)                  // 대문자로 변환\n    .collect(Collectors.toList());             // 결과를 리스트로 수집\n```\n\n이 예제에서는 스트림 API를 사용하여 이름 목록을 필터링하고 대문자로 변환하는 방법을 보여줍니다. filter와 map 메서드는 중간 작업으로 스트림을 구성하며, collect 메서드는 처리를 트리거하고 결과를 새로운 리스트로 수집하는 최종 작업입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSOLID은 소프트웨어 시스템을 설계할 때 유지보수 및 확장이 용이한 다섯 가지 원칙을 나타내는 약어입니다. 다음은 예와 함께 나열되어 있어요:\n\n- SRP(Single Responsibility Principle): 한 클래스는 변경되는 이유가 하나여야 합니다. 이것은 클래스가 한 가지 작업 또는 책임만 가지도록 해야 한다는 의미입니다.\n- 예시: User 클래스가 있을 때, 해당 클래스는 사용자와 직접 관련된 것만 책임져야 합니다. 예를 들어 데이터베이스에서 사용자 데이터를 로드하는 것은 해당 클래스가 담당하면 안됩니다. 별도의 UserRepository 클래스가 해당 책임을 져야 합니다.\n- OCP(Open-Closed Principle): 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 열려 있어야 하지만 수정에는 닫혀 있어야 합니다. 이것은 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있어야 한다는 것을 의미합니다.\n- 예시: Shape 클래스가 있고 새로운 모양을 추가하려는 경우, Shape를 상속하는 새 클래스를 추가함으로써 Shape 클래스나 기존 클래스를 수정하지 않고도 가능해야 합니다.\n- LSP(Liskov Substitution Principle): 하위 유형은 상위 유형으로 대체 가능해야 합니다. 이것은 프로그램이 기본 클래스를 사용하고 있을 때 하위 클래스를 사용할 수 있어야 하며, 프로그램이 오류 없이 작동해야 한다는 것을 의미합니다.\n- 예시: Bird 클래스에 fly() 메서드가 있는 경우 Bird를 상속하는 Penguin 클래스는 fly() 메서드를 지원하지 않는다면 LSP를 위반하고 있습니다. 해결책으로는 비행하는 새들을 위한 별도의 FlyingBird 클래스를 만드는 것이 될 수 있습니다.\n- ISP(Interface Segregation Principle): 클라이언트는 사용하지 않는 인터페이스에 의존하도록 강요되어서는 안 됩니다. 이는 클래스가 사용하지 않는 메서드를 구현할 필요가 없어야 한다는 것을 의미합니다.\n- 예시: IPrinter 인터페이스에 print(), fax(), scan() 메서드가 있고, SimplePrinter 클래스가 인쇄만 지원하는 경우 ISP를 위반하고 있습니다. 해결책으로는 IPrinter, IFax, IScanner에 대한 별도의 인터페이스를 만드는 것이 될 수 있습니다.\n- DIP(Dependency Inversion Principle): 고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 둘 다 추상화에 의존해야 합니다. 이는 구현이 아니라 추상화에 의존해야 한다는 의미입니다.\n- 예시: NotificationService 클래스가 직접 EmailService 클래스를 사용하여 이메일을 보내는 경우 DIP를 위반하고 있습니다. 해결책으로는 EmailService가 구현하는 IMessageService 인터페이스를 사용하고, NotificationService는 EmailService보다는 IMessageService에 의존해야 합니다.\n\n이 원칙들은 지침이며 엄격한 규칙은 아닙니다. 다른 목표를 달성하기 위해 원칙을 위반하는 것이 합리적인 경우도 있을 수 있습니다. 그러나 이러한 원칙을 이해하면 더 유지보수 가능하고 확장 가능한 소프트웨어를 설계하는 데 도움이 될 거예요.\n\nJava 8에서는 특히 java.util.function, java.util.stream, java.time 패키지에서 새로운 클래스와 인터페이스가 소개되었습니다. 여기에 중요한 것들이 몇 가지 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- java.util.function 패키지의 함수형 인터페이스:\n\n  - Predicate`T`\n  - Function`T,R`\n  - Consumer`T`\n  - Supplier`T`\n  - UnaryOperator`T`\n  - BinaryOperator`T`\n\n- java.util.stream 패키지의 Stream API 클래스 및 인터페이스:\n\n  - Stream`T`\n  - IntStream\n  - LongStream\n  - DoubleStream\n  - Collector`T,A,R`\n  - Collectors\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\njava.time 패키지의 Date and Time API 클래스:\n\n- LocalDate\n- LocalTime\n- LocalDateTime\n- ZonedDateTime\n- Period\n- Duration\n- Instant\n- ZoneId\n\njava.util 패키지의 Optional 클래스:\n\n- Optional`T`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\njdk.nashorn.api.scripting 패키지에 새로운 JavaScript 엔진 클래스가 추가되었습니다:\n\n- NashornScriptEngineFactory\n\n이러한 새로운 클래스와 인터페이스는 함수형 프로그래밍, 스트림 처리 및 개선된 날짜 및 시간 API와 같은 강력한 새로운 기능을 제공합니다.\n\nwait() 및 join()은 자바의 멀티스레딩에서 사용되는 두 가지 메서드로, 각각 다른 목적을 제공합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- wait(): 이 메서드는 Object 클래스에 정의되어 있으며 스레드 간 통신에 사용됩니다. 스레드가 wait()를 호출하면 휴면 상태로 들어가며 개체에 보유한 락을 해제하여 다른 스레드가 락을 가져가고 고유한 중요한 부분을 실행할 수 있도록 합니다. 해당 스레드는 같은 개체에 대해 notify() 또는 notifyAll()이 호출될 때까지 대기 상태에 머무릅니다.\n\n예시:\n\n```js\nsynchronized(object) {\n    while(\u003c조건이 참이 아닌 동안\u003e)\n        object.wait();\n    // 로직 처리\n}\n```\n\njoin(): 이 메서드는 Thread 클래스에 정의되어 있으며 현재 스레드를 지정된 스레드가 종료될 때까지 일시 정지시키는 데 사용됩니다. 즉, 스레드 A가 스레드 B에 대해 join()을 호출하면 A는 B가 실행을 완료할 때까지 기다립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```java\nThread t1 = new Thread(new MyRunnable());\nt1.start();\ntry {\n    t1.join();\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n}\n// t1이 종료될 때까지 logic 계속 진행\n```\n\n요약하면, wait()은 스레드 간 통신에 사용되며 객체의 잠금을 해제하며, join()은 스레드가 종료될 때까지 기다리는 데 사용되며 어떤 잠금도 해제하지 않습니다.\n\n만약 해당 객체에 대해 동기화를 먼저 실행하지 않고 객체에 대해 wait()를 호출하는 경우, 런타임에 IllegalMonitorStateException이 발생합니다. 이는 wait(), notify(), notifyAll() 메서드가 동기화를 달성하도록 설계되어 다중 스레드 환경에서 사용되며, synchronized 컨텍스트 내에서만 호출할 수 있기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요기에는 Java 문서에 대한 wait() 메서드 설명이 있어요:\n\n현재 스레드는 이 객체의 모니터를 소유해야 합니다. 스레드는 이 모니터의 소유권을 해제하고 이 객체의 모니터에서 대기 중인 스레드를 깨우기 위해 notify() 메서드 또는 notifyAll() 메서드를 호출하여 다른 스레드에 의해 깨어날 때까지 기다립니다. 그럼 스레드는 다시 모니터의 소유권을 재획득할 때까지 대기하고 실행을 다시 시작합니다.\n\n따라서 객체에 대해 작동 중인 4개의 스레드가 있고 synchronized 블록이나 메서드 없이 wait()를 호출하면 IllegalMonitorStateException이 발생합니다.\n\n또한, notify() 또는 notifyAll()을 호출하지 않는 경우, 객체에서 대기 중인 스레드는 깨우기 위한 통지할 것이 없기 때문에 대기 상태에 계속 남게 됩니다. 이는 스레드가 영원히 대기하는 상황을 초래할 수 있으며, 이를 스레드 기아라고 일컫는 경우가 많습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSpring Framework과 Spring Boot은 모두 엔터프라이즈급 애플리케이션을 구축하는 데 사용되는 Java 프레임워크입니다. 두 프레임워크는 관련이 있지만 다른 목적을 가지고 있습니다.\n\nSpring Framework: 이는 Java 애플리케이션을 구축하는 데 사용되는 포괄적인 프레임워크입니다. 의존성 주입, 관점 지향 프로그래밍, 데이터 액세스, 트랜잭션 관리, 웹 애플리케이션을 위한 MVC 등 다양한 기능을 제공합니다. 그러나 Spring Framework를 사용하여 프로젝트를 설정하는 것은 많은 구성을 수동으로 처리해야 하기 때문에 복잡할 수 있습니다.\n\nSpring Boot: 이는 Spring Framework 위에 구축된 프로젝트입니다. Spring 애플리케이션의 설정 및 개발을 단순화시켜 코드 구성에 대한 기본값을 제공하고, Spring 애플리케이션을 실행시키기 위해 필요한 노력을 줄입니다. 또한 스탠드얼론 서버 (Tomcat, Jetty 또는 Undertow)를 제공하여 Spring 애플리케이션을 직접 메인 메서드에서 실행할 수 있고, 애플리케이션 배포 및 모니터링을 단순화하기 위한 많은 추가 기능을 제공합니다.\n\n이것이 주요한 차이점입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설정: 스프링은 설정을 위해 많은 수동 구성이 필요합니다. 그러나 스프링 부트는 이 복잡성을 줄이기 위해 자동 구성을 제공합니다.\n- 프로젝트 설정: 스프링에서 프로젝트를 설정하는 것은 약간 복잡할 수 있으며 내부 동작에 대한 깊은 이해가 필요합니다. 스프링 부트는 Spring Initializr 웹 기반 프로젝트 생성기를 통해 이 과정을 쉽게 만듭니다.\n- 독립형: 스프링 부트 애플리케이션은 내장 서버가 포함된 jar로 패키징할 수 있습니다. 기존의 스프링 MVC 애플리케이션에서는 애플리케이션을 별도 서버에 배포해야 합니다.\n- 의존성 관리: 스프링 부트는 starter POMs 기능을 제공하여 Maven 구성 및 의존성 관리를 간소화합니다.\n- 프로덕션 준비: 스프링 부트는 상자에서 건강 상태 확인 및 메트릭과 같은 기능을 기본 제공하여 프로덕션 환경에 적합합니다.\n\n만약 Employee 클래스의 hashCode() 메서드가 항상 같은 값을 반환한다면, 데이터를 잃거나 잘못된 결과를 얻는 것은 아닙니다. 그러나 해시 기반의 컬렉션인 HashMap, HashSet 등의 성능이 저하될 수 있습니다.\n\n이것이 그 이유입니다:\n\n예를 들어 HashMap에서 hashCode()는 키-값 쌍을 저장해야 하는 버킷을 결정하는 데 사용됩니다. 만약 모든 키에 동일한 해시 코드가 있는 경우, 모두 동일한 버킷에 들어가게 됩니다. 이로 인해 HashMap은 성능 측면에서 연결 목록으로 변하게 되며, 모든 항목이 해당 단일 버킷의 노드 체인으로 저장됩니다. 이는 모든 조회, 삽입 또는 삭제가 모든 항목을 선형 검색해야 하므로 매우 비효율적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n객체를 HashMap의 키로 사용할 때는 hashCode()와 equals() 메서드를 올바르게 재정의해야 합니다. hashCode() 메서드는 키를 버킷에 고르게 분배하여 성능을 향상시키는 데 중요하며, equals()는 키의 동등성을 결정하는 데 사용됩니다.\n\n따라서 동일한 해시코드를 반환하더라도 데이터 손실이나 잘못된 결과는 발생하지 않지만, 해시 기반 컬렉션을 사용할 때 성능이 저하될 수 있습니다.\n\n애플리케이션의 성능을 최적화하는 데 몇 가지 단계가 포함됩니다:\n\n- 프로파일링: 애플리케이션의 병목 현상을 식별합니다. CPU 사용량, 메모리 누수, 느린 데이터베이스 쿼리 등이 포함될 수 있습니다. VisualVM, JProfiler 또는 YourKit과 같은 도구를 사용하여 Java 애플리케이션을 프로파일링할 수 있습니다.\n- 코드 최적화: 비효율적인 코드를 찾아 최적화합니다. 이는 더 효율적인 데이터 구조 사용, 알고리즘의 시간 복잡도 감소, 데이터베이스 호출 감소 등을 포함할 수 있습니다.\n- 동시성: 적절한 곳에서 멀티스레딩을 사용하여 여러 코어를 활용하고 작업을 병렬로 수행합니다.\n- 캐싱: 비싼 작업의 결과를 저장하기 위해 캐싱을 구현하여 같은 입력이 다시 발생할 때 반복을 피합니다.\n- 데이터베이스 최적화: 데이터베이스 쿼리를 최적화하고 인덱싱을 사용하며 필요에 따라 정규화 또는 비정규화를 수행합니다.\n- 최신 라이브러리/프레임워크 사용: 일반적으로 성능 향상이 있는 최신 라이브러리나 프레임워크를 사용하도록 항상 노력해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쓰레드 덤프를 가져오려면:\n\n- jstack: 이것은 JDK와 함께 제공되는 명령줄 유틸리티입니다. 실행 중인 Java 애플리케이션의 쓰레드 덤프를 가져 오는 데 사용할 수 있습니다. 명령어는 jstack `pid`이며 여기서 pid는 Java 애플리케이션의 프로세스 ID입니다.\n- VisualVM: 이것은 실행 중인 Java 애플리케이션을 모니터링하는 데 사용할 수있는 그래픽 도구입니다. 또한 쓰레드 덤프를 가져 오는 데도 사용할 수 있습니다.\n- JConsole: 이것은 JDK와 함께 제공되는 또 다른 그래픽 도구입니다. 실행 중인 Java 애플리케이션을 모니터링하고 쓰레드 덤프를 가져 오는 데 사용할 수 있습니다.\n\nJava 8에서 \"스트림\"이라는 용어는 일반적으로 java.util.stream 패키지에 소개 된 새로운 추상화를 가리킵니다. 이를 사용하여 요소 스트림에 대해 함수 스타일 작업을 수행할 수 있습니다. Stream API는 객체 컬렉션을 처리하는 데 사용됩니다. 스트림은 다양한 메서드를 지원하는 객체 시퀀스로, 원하는 결과를 생성하는 데 파이프라인으로 연결될 수 있습니다.\n\nJava 8에서 사용할 수있는 세 가지 유형의 스트림이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Sequential Stream: 순차 스트림은 단일 파이프라인을 갖고 있으며 요소를 순차적으로만 처리할 수 있습니다. stream() 메서드를 호출할 때 기본적으로 생성됩니다.\n\n```java\nList\u003cString\u003e list = Arrays.asList(\"A\", \"B\", \"C\");\n\nStream\u003cString\u003e stream = list.stream();\n```\n\n- Parallel Stream: 병렬 스트림은 여러 파이프라인을 가지고 있어 요소를 병렬로 처리할 수 있습니다. 멀티코어 머신에서 대용량 데이터셋에 대해 순차 스트림보다 빠를 수 있습니다. parallelStream() 메서드를 호출할 때 생성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nList\u003cString\u003e list = Arrays.asList(\"A\", \"B\", \"C\");\n\nStream\u003cString\u003e parallelStream = list.parallelStream();\n\nInfinite Stream: These are streams that don’t have a fixed size, as in they can keep on growing. The Stream.iterate and Stream.generate methods can be used to create infinite streams.\n\nStream\u003cInteger\u003e infiniteStream = Stream.iterate(0, i -\u003e i + 2);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 유형의 스트림은 다른 종류의 작업을 위해 설계되었습니다. 연속 및 병렬 스트림은 일반적으로 유한한 수의 요소와 함께 사용되며, 무한 스트림은 필요할 때 값 시퀀스를 생성하는 데 사용됩니다.\n\n만약 t가 현재 실행 중인 스레드를 가진 Thread 객체라면, t.join()은 현재 스레드가 t의 스레드가 종료될 때까지 실행을 일시 중지시킵니다.\n\n다음은 간단한 예제입니다:\n\n```js\nThread t1 = new Thread(new MyRunnable());\nt1.start();\ntry {\nt1.join(); // 현재 스레드는 t1이 실행을 완료할 때까지 기다립니다\n} catch (InterruptedException e) {\nThread.currentThread().interrupt();\n}\n// t1의 실행이 완료된 후 로직 계속 수행\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예에서 현재 스레드는 t1이 실행을 마칠 때까지 기다립니다. 이는 다른 스레드를 시작하여 일부 작업을 수행하고 그 결과가 필요한 경우에 유용할 수 있습니다.\n\n또한 join()에 대한 오버로드된 버전이 있으며, 다른 스레드가 작업을 완료할 때까지 기다리기 원하는 최대 시간을 지정할 수 있습니다:\n\n- join(long millis) 이 스레드가 종료될 때까지 millis 밀리초만큼 기다립니다.\n- join(long millis, int nanos) 이 스레드가 종료될 때까지 millis 밀리초와 nanos 나노초만큼 최대 기다립니다.\n\n만약 지정된 시간 내에 스레드가 작업을 완료하지 않으면, join() 호출은 어쨌든 반환되고 현재 스레드는 실행을 계속합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바 7에서 소개된 Objects 클래스는 객체를 다루는 정적 메서드를 제공하는 유틸리티 클래스입니다. 이 유틸리티에는 객체의 해시 코드를 계산하는 데 사용되는 null-안전 혹은 null-허용 메서드, 객체에 대한 문자열을 반환하는 메서드, 두 객체를 비교하는 메서드 등이 포함되어 있습니다.\n\n다음은 Objects 클래스에서 자주 사용되는 메서드 몇 가지입니다:\n\nequals(Object a, Object b): 두 개체가 equals() 메서드에 따라 동일한지 확인합니다. 이 메서드는 null-안전입니다. 즉, 두 개체가 모두 null이면 true를 반환하고, 하나는 null이면 false를 반환합니다.\n\nObjects.equals(“test”, new String(“test”)); // true를 반환\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nObjects.equals(null, \"test\"); // false 반환\n\nObjects.equals(null, null); // true 반환\n\nhashCode(Object o): null이 아닌 인수의 해시 코드를 반환하고, null 인수의 경우 0을 반환합니다. null 안전 해시 코드 계산에 유용합니다.\n\nObjects.hashCode(null); // 0 반환\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nObjects.hashCode(\"test\"); // 문자열 \"test\"의 해시 코드를 반환합니다.\n\ntoString(Object o): null이 아닌 인수에 대해 toString을 호출한 결과를 반환하고, null 인수에 대해 \"null\"을 반환합니다.\n\nObjects.toString(null); // \"null\"을 반환합니다.\n\nObjects.toString(\"test\"); // \"test\"를 반환합니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nrequireNonNull(T obj): 지정된 객체 참조가 null이 아닌지 확인합니다. 이 방법은 주로 메서드 및 생성자에서 매개변수 유효성을 검사하기 위해 설계되었습니다.\n\nObjects.requireNonNull(null); // NullPointerException 발생\n\nObjects.requireNonNull(\"test\"); // \"test\" 반환\n\ncompare(T a, T b, Comparator`? super T` c): 지정된 Comparator로 두 객체를 비교하며, null에 안전합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`Objects` 클래스는 null-안전한 메소드를 제공하여 더 깨끗하고 견고한 코드를 작성하는 데 도움이 됩니다.\n\n`flat` 및 `flatMap`은 데이터의 컬렉션이나 스트림에서 사용되는 연산입니다. 그들 사이의 차이점은 중첩 구조물을 어떻게 처리하는지에 있습니다.\n\n- Flat: `flat` 연산(Java에는 없지만 다른 언어에는 존재)은 일반적으로 여러 단계로 중첩되어 있는 구조를 하나의 단계로 줄이는 작업을 합니다. 구조를 한 단계 평준화합니다. 예를 들어, 리스트의 리스트가 있다면, `flat` 연산은 모든 내부 리스트 요소를 포함하는 단일 리스트를 제공합니다.\n- FlatMap: `flatMap` 연산은 `map` 및 `flat` 연산의 조합입니다. 먼저 구조 안의 각 요소에 함수를 적용하고 결과를 평준화합니다. 이는 각 요소에 적용할 함수가 컬렉션이나 스트림을 생성할 때 유용합니다.\n\n여기 Java에서의 예시입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nList\u003cString\u003e list = Arrays.asList(\"Hello World\", \"Java Stream\");\n// map 작업\nList\u003cString[]\u003e mapResult = list.stream()\n.map(s -\u003e s.split(\" \"))\n.collect(Collectors.toList());\n// flatMap 작업\nList\u003cString\u003e flatMapResult = list.stream()\n.flatMap(s -\u003e Arrays.stream(s.split(\" \")))\n.collect(Collectors.toList());\n```\n\n이 예제에서 map 작업은 각 문자열을 단어 배열로 분할하여 List`String[]`을 생성합니다. flatMap 작업은 각 문자열을 단어로 분할하지만 결과를 List`String`으로 평평하게 만들어 각 단어가 개별 요소로 있는 List를 생성합니다.\n\n따라서 flatMap의 주요 차이점은 스트림의 각 요소를 여러 요소로 변환하거나(또는 전혀 변환하지 않는 상황) 평면적인 결과 스트림으로 종료하고 중첩 구조가 아닌 결과 내용을 얻고 싶을 때 사용할 수 있다는 것입니다.\n\n자바에서 java.util.concurrent 패키지는 멀티스레딩에 유용한 여러 유형의 블로킹 큐를 제공합니다. 블로킹 큐는 큐가 비어 있고 Dequeue하려고 하면 블로킹되거나, 큐가 이미 가득 차있고 Enqueue하려고 하면 블로킹되는 큐입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바에서 사용되는 블로킹 큐의 종류는 다음과 같아요:\n\n- ArrayBlockingQueue: 배열을 기반으로 하는 유계된 블로킹 큐이에요. 이 큐는 FIFO(먼저 들어온 것이 먼저 나가는) 순서로 요소들을 처리해요. '유계된'이란 큐가 고정된 수의 요소를 초과해서 저장할 수 없다는 것을 의미해요.\n\n- LinkedBlockingQueue: 링크드 노드를 기반으로 하는 선택적으로 유계된 블로킹 큐예요. 선택적 용량 제한 생성자 인수는 큐가 너무 많이 확장되는 것을 방지하기 위한 방법으로 사용돼요. 용량 제한이 없으면 연결된 큐는 일반적으로 배열 기반 큐보다 더 많은 요소를 보관해요.\n\n- PriorityBlockingQueue: PriorityQueue 클래스와 동일한 규칙을 사용하며 블로킹 검색 작업을 지원하는 무제한 블로킹 큐에요. 이 큐는 논리적으로는 무제한이지만 리소스 고갈로 인해 추가가 실패할 수도 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDelayQueue: 지연된 요소들의 무한 대기 큐로, 요소의 지연이 만료되었을 때에만 요소를 가져올 수 있습니다.\n\nSynchronousQueue: 각 삽입 작업은 다른 스레드에 의한 해당 제거 작업을 기다려야 하며, 그 반대도 마찬가지입니다. 동기식 큐는 내부 용량을 가지지 않으며, 하나의 용량조차도 없습니다.\n\nLinkedTransferQueue: 링크된 노드를 기반으로 한 무한 TransferQueue입니다. 이 큐는 어떤 생성자에 대해선 FIFO(먼저 들어온 것이 먼저 나가는) 순서로 요소를 정렬합니다.\n\nLinkedBlockingDeque: 링크된 노드를 기반으로 한 선택적으로 유한한 블로킹 덱입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 종류의 블로킹 큐는 다중 스레드 프로그래밍에서 작업 요구 사항에 따라 고유한 사용 사례를 갖습니다.\n\n# 읽어 주셔서 감사합니다\n\n- 👏 이야기에 박수를 보내고 저를 팔로우해주세요 👉\n- 📰 미디엄에서 더 많은 콘텐츠를 읽어보세요 (자바 개발자 인터뷰에 관한 60편의 이야기)\n\n제 책은 여기서 찾아볼 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 아마존에서 이 책을 구입하여 기본 Java 개발자 인터뷰를 준비하세요 (킨들북).\n- Gumroad에서 PDF 형식으로 Spring-Boot Microservice 인터뷰를 준비하는 방법 안내서를 확인하세요.\n- Gumroad (PDF 형식) 및 아마존 (킨들 eBook)에서 Spring-Boot Microservice 인터뷰를 준비하는 방법 안내서를 확인하세요.\n- 🔔 저를 팔로우하세요: LinkedIn | Twitter | Youtube\n","ogImage":{"url":"/assets/img/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp_0.png"},"coverImage":"/assets/img/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp_0.png","tag":["Tech"],"readingTime":21},{"title":"Swift에서 부분 적용 함수 사용하는 방법","description":"","date":"2024-06-23 01:50","slug":"2024-06-23-PartiallyAppliedFunctionsinSwift","content":"\nSwift에서 부분 적용 함수는 일부 매개변수로 호출된 함수를 의미합니다. 이는 남은 매개변수를 입력으로 받는 새로운 함수를 만듭니다.\n\n# 부분 적용 함수 예시:\n\nSwift에서 간단한 함수를 고려해보겠습니다:\n\n```swift\nfunc multiply(_ a: Int, _ b: Int) -\u003e Int {\n return a * b\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 기능을 만들고 싶다면 항상 2배를 곱하는 함수를 부분적용할 수 있습니다.\n\n```js\nlet multiplyByTwo = multiply(2, _);\n```\n\n이제 `multiplyByTwo`는 하나의 매개변수를 받는 함수입니다.\n\n```js\nlet result = multiplyByTwo(5); // 결과는 10\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Swift 컴파일러가 부분 적용 함수를 사용하는 이유는 무엇인가요?\n\n부분 적용 함수는 여러 이유로 유용합니다:\n\n1. 코드 재사용성: 일반적인 함수에서 더 구체적인 함수를 다시 작성하지 않고 만들 수 있어 더 모듈식이고 재사용 가능한 코드를 작성할 수 있습니다.\n\n2. 함수형 프로그래밍: 부분 적용 함수는 함수형 프로그래밍의 핵심이며 함수를 일급 시민으로 사용하는 함수형 프로그래밍 패러다임을 강조합니다. Swift는 함수형 프로그래밍 패러다임을 지원하며, 부분 적용 함수는 고차 함수를 만드는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 클로저 간소화: 클로저 생성을 간단하게 해줍니다. 전체 클로저를 작성하는 대신 부분 적용을 사용하여 더 간결한 효과를 얻을 수 있습니다.\n\n4. 가독성 향상: 중복을 줄임으로써 코드를 더 읽기 쉽게 만들어줍니다. 공통 매개변수로 반복적으로 동일한 함수 호출을 작성하는 대신, 부분 적용된 함수를 만들 수 있습니다.\n\n# 예시 문맥 안에서\n\n다음은 더 포괄적인 예시입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분이 수를 담은 리스트가 있고 짝수를 필터링하고 싶다면 부분적용 함수를 사용할 수 있습니다.\n\n```js\nlet numbers = [1, 2, 3, 4, 5, 6]\nfunc isDivisibleBy(_ divisor: Int, _ number: Int) -\u003e Bool {\n return number % divisor == 0\n}\nlet isEven = isDivisibleBy(2, _:)\nlet evenNumbers = numbers.filter(isEven)\n// evenNumbers will be [2, 4, 6]\n```\n\n이 예제에서 `isDivisibleBy`가 부분적용으로 `isEven`을 만들어 배열을 필터링하는 데 사용되는 것을 볼 수 있습니다.\n\n# 컴파일러가 부분적용 함수를 사용하는 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nThe Swift 컴파일러는 여러 가지 이유로 부분 적용 함수를 사용할 수 있습니다:\n\n1. 최적화: 컴파일러는 부분 적용 함수를 최적화하여 성능을 향상시킬 수 있으며, 특히 고계 함수와 클로저가 포함된 시나리오에서 유용합니다.\n\n2. 유형 추론: Swift의 유형 추론 시스템은 부분 적용 함수를 효과적으로 처리하여 명시적 유형 주석의 필요를 줄이고 코드를 더 깔끔하게 만들 수 있습니다.\n\n3. 중간 표현: 컴파일 중에 부분 적용 함수는 코드의 변환과 최적화를 단순화하는 중간 표현으로 사용될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 기능적 패러다임: Swift는 객체지향 및 함수형 프로그래밍 패러다임을 모두 지원합니다. 부분 함수 적용은 함수형 프로그래밍에 자연스럽게 적합하며 사용하면 더 표현력이 풍부하고 간결한 코드를 작성할 수 있습니다.\n\n# Swift 컴파일러와 부분 함수 적용\n\nSwift 컴파일러는 고수준 추상화 및 효율적인 최적화 처리를 수행할 수 있도록 설계되었습니다. 부분 함수 적용은 컴파일러가 성능을 향상시키고 코드 관리를 용이하게 하는 데 활용할 수 있는 핵심 기능입니다.\n\n## 1. 중간 표현들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스위프트 코드를 작성할 때, 스위프트 컴파일러는 중간 표현 (IR)으로 번역합니다. 부분 적용된 함수는 이 중간 형태로 표현될 수 있어, 컴파일러가 쉽게 최적화를 수행할 수 있습니다.\n\n- 함수 커링: 함수형 프로그래밍에서 커링은 여러 인수를 갖는 함수를 하나의 인수로 있는 각각의 함수의 순서로 변환하는 것입니다. 스위프트 컴파일러는 함수 호출을 최적화하기 위해 자동으로 커링을 적용할 수 있습니다.\n- 람다 리프팅: 이 기술은 중첩 함수를 추가 매개변수를 갖는 최상위 함수로 변환하는 것을 포함합니다. 부분적으로 적용된 함수를 최상위 엔티티로 표현함으로써, 컴파일러가 더 잘 관리하고 최적화할 수 있습니다.\n\n이제 스위프트에서 함수 커링과 람다 리프팅의 예를 살펴보겠습니다.\n\n함수 커링\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n커링은 여러 인수를 사용하는 함수를 한 인수를 사용하는 함수의 시퀀스로 변환하는 과정입니다. 이 기술은 더 유연하고 재사용 가능한 코드를 작성하는 함수형 프로그래밍에서 유용하게 활용됩니다.\n\n## 스위프트에서 함수 커링 예제\n\n두 정수를 더하는 간단한 함수로 시작해보겠습니다:\n\n```js\nfunc add(_ a: Int, _ b: Int) -\u003e Int {\n return a + b\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 함수를 커리한 버전으로 변환할 수 있습니다:\n\n```swift\nfunc curriedAdd(_ a: Int) -\u003e (Int) -\u003e Int {\n    return { b in\n        return a + b\n    }\n}\n```\n\n이제 `curriedAdd`는 정수 `a`를 받아 정수 `b`를 받고 `a`와 `b`의 합을 반환하는 새 함수를 반환하는 함수입니다.\n\n## 사용법:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet addFive = curriedAdd(5); // addFive은 이제 함수(Int) -\u003e Int입니다.\nlet result = addFive(3); // 결과는 8입니다.\n```\n\n직접 사용할 수도 있습니다:\n\n```js\nlet resultDirect = curriedAdd(5)(3); // resultDirect는 8입니다.\n```\n\n## 람다 리프팅\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n람다 끌어올리기는 중첩 함수(람다)를 추가 매개변수를 가진 최상위 함수로 변환하는 프로세스입니다. 이 변환은 함수가 주변 컨텍스트와 독립적이 되도록 만듭니다.\n\n## Swift에서 람다 끌어올리기 예제\n\n중첩 함수(클로저)가 있는 함수로 시작해봅시다:\n\n```js\nfunc outerFunction(_ x: Int) -\u003e Int {\n func innerFunction(_ y: Int) -\u003e Int {\n return x + y\n }\n return innerFunction(5)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서 `innerFunction`은 `outerFunction` 내에 중첩되어 있으며 변수 `x`에 의존합니다.\n\n## 람다 릴팅 변환\n\n`innerFunction`을 최상위 수준으로 이동시키려면 명시적 매개변수로 `x`를 추가해야 합니다:\n\n```js\nfunc liftedInnerFunction(_ x: Int, _ y: Int) -\u003e Int {\n return x + y\n}\nfunc outerFunction(_ x: Int) -\u003e Int {\n return liftedInnerFunction(x, 5)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 `liftedInnerFunction`은 주변 컨텍스트의 변수에 의존하지 않는 최상위 함수입니다.\n\n## 사용법:\n\n```js\nlet result = outerFunction(3); // result is 8\n```\n\n`innerFunction`을 최상위 수준으로 올리면 더 재사용 가능하고 더 이해하기 쉬워지며, 더 이상 둘러싸는 함수의 상태에 의존하지 않게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 인라인 처리와 특수화\n\nSwift 컴파일러는 부분적으로 적용된 함수를 인라인 처리하여 함수 호출을 함수의 본문으로 대체할 수 있습니다. 이는 함수 호출의 오버헤드를 줄이고 성능을 크게 향상시킬 수 있습니다.\n\n- 함수 인라인 처리: 부분적으로 적용된 함수가 인라인 처리될 때 컴파일러는 중간 클로저를 생성할 필요 없이 함수의 로직을 직접 해당 위치에 삽입할 수 있습니다.\n- 특수화: 컴파일러는 특정 유형이나 매개변수 값에 대해 함수의 특수화된 버전을 생성할 수 있습니다. 이는 특히 부분적으로 적용된 함수에 유용하며, 컴파일러가 가장 일반적인 사용 사례에 최적화할 수 있게 합니다.\n\n함수 인라인 처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수 인라인은 컴파일러가 함수 호출을 해당 함수의 실제 코드로 대체하는 최적화 기술입니다. 이는 레지스터의 저장 및 복원과 같은 함수 호출과 관련된 오버헤드를 제거할 수 있으며, 컴파일러에 의해 추가적인 최적화를 가능하게 할 수 있습니다.\n\n인라인은 작고 빈번히 호출되는 함수에 특히 유용합니다.\n\n예시\n\n다음과 같은 간단한 함수를 고려해보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunc add(_ a: Int, _ b: Int) -\u003e Int {\n return a + b\n}\n```\n\n이 함수를 호출하면:\n\n```js\nlet result = add(2, 3);\n```\n\n컴파일러는 이 호출을 함수의 본문으로 대체할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet result = 2 + 3;\n```\n\n이렇게 하면 함수 호출의 오버헤드를 제거할 수 있어요.\n\n## `@inline(__always)`를 사용한 명시적 인라인화\n\nSwift에서는 `@inline(__always)` 속성을 사용하여 항상 함수를 인라인으로 처리하도록 컴파일러에 제안할 수 있어요. 이는 성능에 중요한 코드에 유용할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n@inline(__always)\nfunc multiply(_ a: Int, _ b: Int) -\u003e Int {\n return a * b\n}\n```\n\n사용 방법:\n\n```swift\nlet result = multiply(4, 5)\n```\n\n여기서 컴파일러는 `multiply`를 인라인으로 권장받아 호출을 효과적으로 다음과 같이 대체합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet result = 4 * 5;\n```\n\n## 인라인 사용 시기 및 이유\n\n- 성능: 인라인은 함수 호출 오버헤드를 제거하고 추가적인 컴파일러 최적화를 가능하게 함으로써 성능을 향상시킬 수 있습니다.\n\n- 작은 함수: 작고 자주 호출되는 함수는 인라인에 적합한 후보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 중요한 경로: 매 밀리초가 소중한 성능에 영향을 미치는 코드 경로에서는 인라인화가 유익할 수 있습니다.\n\n그러나 지나치게 많은 인라인화는 이진 크기가 크게 증가하여 캐시 미스와 증가된 메모리 사용량으로 인한 성능 저하를 초래할 수 있습니다. 따라서, 인라인화를 분별하여 사용하는 것이 중요합니다.\n\n## 인라인화에 대한 컴파일러 결정\n\nSwift 컴파일러는 함수를 인라인으로 처리할지 여부를 결정하는데 여러 가지 휴리스틱을 사용합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기능 크기: 작은 함수는 큰 함수보다 인라인화될 가능성이 높습니다.\n- 호출 빈도: 자주 호출되는 함수는 오버헤드를 줄이기 위해 인라인화될 수 있습니다.\n- 복잡성: 간단한 논리를 가진 함수는 인라인화하기에 적합합니다.\n- 주석: `@inline(__always)` 또는 `@inline(never)`와 같은 속성은 인라인화 결정에 대한 힌트를 컴파일러에 제공합니다.\n\n예시\n\n주어진 함수를 배열의 각 요소에 적용하는 고차 함수를 고려해보세요:\n\n```js\nfunc applyToEach(_ array: [Int], _ transform: (Int) -\u003e Int) -\u003e [Int] {\n return array.map { transform($0) }\n}\n@inline(__always)\nfunc increment(_ x: Int) -\u003e Int {\n return x + 1\n}\nlet numbers = [1, 2, 3, 4]\nlet incrementedNumbers = applyToEach(numbers, increment)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인라인 없이:\n\n`applyToEach` 함수는 배열의 각 요소마다 `increment`를 호출하여 여러 함수 호출을 발생시킵니다.\n\n인라인 사용:\n\n컴파일러는 `increment`를 인라인으로 처리하여 함수 호출 대신 `map` 클로저 내에서 증가 연산을 바로 수행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet incrementedNumbers = numbers.map { $0 + 1 }\n```\n\n함수 호출 오버헤드를 제거하고 더 효율적인 코드를 만들 수 있습니다.\n\n## 3. 클로저 최적화\n\n부분적으로 적용된 함수는 클로저와 밀접한 관련이 있습니다. Swift 컴파일러는 부분적으로 적용된 함수에 이로운 여러 전략을 사용하여 클로저를 최적화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 스택 할당: 클로저(또는 부분 적용 함수)가 정의된 범위에서 벗어나지 않는다면, 컴파일러는 메모리 할당 오버헤드를 줄이기 위해 힙 대신 스택에 할당할 수 있습니다. 이것은 클로저에 `@escaping` 속성을 사용하여 직접 제어할 수 있습니다.\n- 컨텍스트 캡처: 컴파일러는 클로저가 캡처하는 변수를 분석하고 이러한 변수의 저장을 최적화하여 캡처 및 컨텍스트 저장의 오버헤드를 최소화합니다.\n\n## 4. 타입 추론 및 제네릭 함수\n\nSwift의 강력한 타입 추론 시스템은 부분 적용 함수와 원활하게 작동하여 명시적인 타입 주석이 필요 없이 코드를 더 간결하게 만듭니다.\n\n- 제네릭 함수: 컴파일러는 부분 적용 함수를 사용하여 제네릭 처리를 더 효과적으로 다룰 수 있으며, 사용되는 맥락에 기반하여 함수의 타입을 추론하고 특수화된 버전을 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 애플의 공식 설명\n\n애플의 공식 Swift 문서는 클로저와 부분 적용 함수를 포함한 함수형 프로그래밍 패러다임을 강조합니다. 다음은 애플의 문서와 관련 자료에서 주요한 내용들입니다:\n\n- 클로저: 애플은 클로저를 자체 포함된 기능 블록으로 설명하며, 변수와 상수에 대한 참조를 캡처하고 저장할 수 있는 기능입니다. 부분 적용 함수는 일부 매개변수가 고정된 클로저의 특수한 경우입니다.\n- 함수형 프로그래밍: Swift는 함수형 프로그래밍 방식을 장려하며, 부분 적용 함수는 이 방식에 중요한 역할을 합니다. 애플의 문서는 Swift의 함수 유형과 1급 함수가 유연하고 표현력 있는 코드를 가능하게 한다는 점을 강조합니다.\n- 최적화 기법: 사용자에게 명시적으로 자세히 설명되지는 않지만, 백그라운드에서 컴파일러 최적화 기능을 통해 언어의 고급 기능을 활용합니다. 이는 인라인 최적화, 제네릭 특수화, 효율적인 클로저 처리 등을 포함합니다.\n\n# 애플 문서 예시\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플의 Swift 문서에서 간단한 map 함수 예제를 살펴보겠습니다:\n\n```js\nlet numbers = [1, 2, 3, 4]\nlet doubled = numbers.map { $0 * 2 }\n```\n\n여기서 ' $0 \\* 2 '의 클로저는 부분 적용 함수로 볼 수 있습니다. 컴파일러는 이를 최적화하기 위해 다음을 수행합니다:\n\n- 클로저의 논리를 맵 함수로 직접 인라인 처리합니다.\n- 정수 배열에 대한 맵 함수를 특수화하여 일반적인 유형 처리의 오버헤드를 제거합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwift 컴파일러는 이를 통해 함수형 스타일 코드가 가능한 한 효율적임을 보장합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-PartiallyAppliedFunctionsinSwift_0.png"},"coverImage":"/assets/img/2024-06-23-PartiallyAppliedFunctionsinSwift_0.png","tag":["Tech"],"readingTime":15},{"title":"Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유","description":"","date":"2024-06-23 01:49","slug":"2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall","content":"\n![Image](/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_0.png)\n\nApple의 WWDC 키노트는 올 가을에 Apple 기기로 오는 강력한 새로운 AI 기능들로 우리를 감명시켰습니다. Apple Intelligence는 현재의 Siri의 인상적이지 않은 혼란스러운 부분에 상당한 업그레이드가 될 예정입니다.\n\n그러나 보이는 바와 같이, Apple의 \"우리를 위한 AI\"는 대부분의 사람들을 제외합니다.\n\niPhone에서 Apple Intelligence를 사용하려면 iPhone 15 Pro 또는 iPhone 15 Pro Max가 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정규 iPhone 15 또는 이전 모델을 사용 중인 분은 신청하지 않으셔도 됩니다.\n\n실제로 작년에 출시된 플래그십 스마트폰인 iPhone 14 Pro와 iPhone 14 Pro Max조차 충분하지 않은 것 같아요.\n\n![image](/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_1.png)\n\n# 왜 iPhone 사용자의 90%를 제외하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이폰 15 Pro와 Pro Max는 훌륭한 핸드폰이에요. 제가 정말 좋아해요. 하지만 아이폰 14 Pro도 충분히 좋은 성능을 가지고 있어요. 왜 Apple Intelligence에서 제외되었는지 궁금하네요.\n\n아마 아이폰 14 시리즈가 너무 오래되었다는 주장에 동의할 수도 있겠죠. 그렇다면 일반 아이폰 15와 아이폰 15 Plus는 어떨까요?\n\n아니에요. 그것들도 아닌 것 같아요.\n\n이러한 기능을 최신 모델 기기로 제한하는 것은 처리 성능과 하드웨어가 필요하기 때문에 합리적으로 보입니다. 하지만 신경망 엔진 처리는 아이폰에 새로운 기능은 아니에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n왜 대부분의 기기를 제외했나요?\n\n이는 RAM 문제인 것 같아요.\n\nApple Intelligence를 지원하는 모든 기기들은 적어도 8GB의 RAM을 가지고 있어요.\n\niPhone 15 Pro와 iPhone 15 Pro Max는 각각 8GB의 RAM을 가지고 있고, iPhone 14 Pro, 14 Pro Max, iPhone 15 및 15 Plus는 모두 6GB의 RAM을 가지고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 M-시리즈 칩을 장착한 맥은 적어도 8GB의 RAM을 가지고 있어요.\n\nM1 아이패드 프로는 8GB 또는 16GB의 RAM을 가지고 있어요.\n\n그게 정답일까요? 8GB의 RAM이요?\n\n다른 많은 경쟁사와 달리, Apple Intelligence는 대부분 디바이스 내에서 운영되어 외부 서버로의 요청을 보내지 않아요 — 그건 좋은 점이에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 그건 RAM이 필요해요.\n\n# 전형적인 애플의 행동?\n\n애플이 여기에서 하드웨어 벽에 맞서 싸우고 있다는 것은 가능합니다. 하지만 제 의심 많은 두뇌는 여기에 더 많은 일들이 벌어지고 있는지 궁금해합니다.\n\n분석가 Ming-Chi Kuo는 애플 인텔리전스가 2GB 또는 그 이하의 RAM을 필요로 한다고 보고했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 무슨 생각이야?\n\n최근 일부 모델에서 사용 가능한 6GB RAM 중 2GB를 차지하는 것에 대해 Apple이 신경을 쓸 수 있다는 가능성이 있습니다. iPhone 13은 단지 4GB RAM을 갖추고 iOS 18을 지원하기 때문에, Apple이 6GB RAM을 갖춘 사용자에게 Apple Intelligence를 제공할 수 있을지 궁금해지는 것은 그리 멀지 않습니다. 성능은 특정 상황에서 약간 떨어질 수 있지만 해당 서비스를 제공할 수도 있습니다.\n\n하지만 Apple은 새로운 기능을 선택적으로 특정 기기로 제한함으로써 현재 기기에서 작동할 수 있는지 여부와 상관없이 고객들이 업그레이드하도록 유도하는 듯한 역사가 있습니다.\n\nApple이 6GB RAM을 갖는 기기를 위해 약간 축소된 버전의 Apple Intelligence를 제공할 수 있을지 궁금합니다. 이를 통해 iPhone 13 Pro 및 Pro Max, iPhone 14 및 14 Plus, iPhone 14 Pro 및 Pro Max, iPhone 15 및 iPhone 15 Plus를 대상으로 할 수 있을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근 iPhone 15 Pro 또는 iPhone 15 Pro Max에 큰 돈을 지불한 사용자들에겐 더 많은 기능과 완전한 경험이 남겨질 것 같아요.\n\n모든 것에 대한 전문가는 아니지만, Apple이 이전 최신 모델에서 Apple Intelligence를 작동시키고 싶다면 어느 정도는 가능할 것 같아요. 비록 완전한 경험은 아닐지라도요.\n\n제가 요구하는 건 AI 이미지를 생성하는 능력이 아니에요. 현재 시리가 할 수 있는 것 이상의 무언가를 원할 뿐이에요.\n\n아마도 Apple이 여기서 강력한 제약에 맞닥뜨리고 있어서 이전 모델로 Apple Intelligence를 가져오고 동일한 수준의 성능을 유지하는 건 불가능할 수 있어요. 하지만 분명히 무언가는 할 수 있을 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저거 속이시려고 하는 거야?\n\n# Apple Intelligence를 얻기 위해 업그레이드해야 할까요?\n\n아직 iPhone 12, 13 또는 14 시리즈를 사용 중이라면 Apple Intelligence를 위해 업그레이드해야 할까요? 그렇게 해야 할까요?\n\niPhone은 여러 년 동안 지속되는 경향이 있으며, 각 새로운 모델이 출시될 때마다 더 이상 이전 모델이 모든 새로운 소프트웨어 기능을 지원하지 않을 수 있습니다. 몇 가지는 업그레이드할 가치가 없을 수도 있지만, 다른 것들은 그렇지 않을 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 제품이 업그레이드할 가치가 있는지 궁금해요? Apple Intelligence가 큰 패러다임 변화로 충분히 오래된 기기를 교체하거나 새로운 기기를 구입할 가치가 있다고 생각하나요?\n\n만약 여러분이 Siri의 몇 가지 단순한 작업을 수행할 수 없다는 듯한 능력에 만족하지 못하고, 여러 회사의 비서들이 수행할 수 있는 작업들에 감명을 받지 못하며 더 강력한 AI 도우미가 있다면, 호환 가능한 기기로 업그레이드하는 것은 가치가 있을 수 있어요.\n\n하지만 그렇지 않다면, 이를 위해 더 많은 돈을 지불하기가 어려울 거예요. Apple이 우리가 원한다는 것을 명백하게 표현해도 말이에요.\n\niPhone 15 Pro 소유자로써, 그것은 제가 답변할 필요가 있는 질문이 아닙니다. 하지만 그것이 의미하는 바가 많은 기기를 사용 중인 수많은 iPhone 사용자들을 냉담하게 방치하는 Apple에 대해 저 또한 분노를 느낍니다.\n","ogImage":{"url":"/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_0.png"},"coverImage":"/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_0.png","tag":["Tech"],"readingTime":6},{"title":"다중 터치 ML 모델 최신 트렌드 및 사용 방법","description":"","date":"2024-06-23 01:46","slug":"2024-06-23-Multi-touchMLModels","content":"\n## iOS 앱으로 Python 기반 ML 모델 이식하기\n\n![image](/assets/img/2024-06-23-Multi-touchMLModels_0.png)\n\n## 소개\n\nGoogle과 Apple은 모바일 기기에서 AI 모델을 네이티브로 실행하는 주요 계획을 시작했습니다. 이는 원격 서버에서 모델을 실행하는 것에서 이동하여 AI 응용 프로그램에 대한 흥미로운 기회를 만들어내면서 사용자 개인정보를 유지하는 것입니다. 이러한 발전 중 많은 부분은 디바이스 제조업체가 기계 학습 작업에 사용되는 알고리즘을 처리하는 데 점점 효과적인 칩셋을 설계한 데서 나옵니다. 최근 트렌드를 고려하여, 나는 Python으로 작성된 ML 모델을 iOS에서 네이티브로 실행할 방법을 살펴보기로 결정했습니다. 이를 통해 전화기에서 더 복잡한 ML 구현으로 나아가는 계단으로 보고, 이러한 질문에 대답하기 위해 잘 알려진 데이터셋을 사용했습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ML 모델을 iPhone에서 실행할 수 있는 방법은 무엇인가요?\n- 그 모델과 상호작용하기 위한 직관적인 방법은 무엇인가요?\n- 모바일 앱이 데이터와 기계 학습 모델 사이의 관계를 찾는 것을 기술적이고 비기술적인 사용자 모두에게 더 쉽게 만들 수 있을까요?\n\n이 글은 이러한 질문들을 염두에 두고 iOS 앱을 어떻게 구축하는지에 대해 안내하겠습니다. 자세한 내용에 들어가기 전에 이 연습을 통해 얻은 주요 통찰을 공유하겠습니다.\n\n- 모델을 적응시키는 \"어떻게\"에 대한 질문은 애플의 Core ML 도구를 사용하여 해결할 수 있습니다. 이 도구는 파이썬 모델을 애플의 칩셋에 최적화된 Core ML 형식으로 변환할 수 있습니다.\n- 슬라이더는 모델 예측에 대해 특성 값을 조정하기 위한 직관적인 인터페이스로, 그러나 화면 공간을 많이 차지합니다.\n- 분할 스크롤은 상대적으로 작은 공간에서 수치적 비교를 가능케 합니다.\n- 이 앱은 데이터에 대한 배경을 가진 사람들에게 ML 모델을 설명하는 데 도움이 될 수 있지만, 사용자 인터페이스와 시각화에 대한 추가적인 조정으로 비기술적인 사용자를 돕을 수 있습니다.\n\n이 글은 모바일 ML 모델을 만드는 데 사용된 일반적인 기술에 대해 이야기할 것입니다. 프로젝트에 대한 GitHub 링크도 제공됩니다. 다음은 다룰 주제의 요약입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모델이 훈련된 데이터의 개요\n- Python에서 Core ML로 모델 변환하기\n- 데이터를 iOS 앱으로 내보내기\n- 모델과 데이터를 애플리케이션에 가져오기\n- 모델 및 데이터와 상호 작용하는 인터페이스 구축 방법\n- 결론\n\n완성된 앱은 다음과 같습니다. 시작해봅시다!\n\n![앱 스크린샷](/assets/img/2024-06-23-Multi-touchMLModels_1.png)\n\n## 모델이 훈련된 데이터의 개요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nML 모델을 학습하는 데 사용된 데이터에 대해 간단히 설명드리겠습니다. 우리는 인기 있는 Pima 인디언 당뇨병 데이터 세트를 사용할 것입니다. 이 데이터는 국립당뇨병 및 소화기 및 신장 질환 연구소에서 나온 것으로, 혈당, BMI, 연령 등과 같은 개인의 의학적 속성에 중점을 둔 더 큰 데이터베이스의 일부를 대표합니다. 대상은 적어도 21세 이상의 피마 인디언 여성입니다. 당뇨병 양성 진단을 받은 환자는 결과가 1이며, 당뇨병 음성 진단을 받은 환자는 결과가 0입니다. 데이터는 kaggle에서 수집되었습니다.\n\n이 프로젝트에서는 Python을 사용하여 모델 구축 및 데이터 변환을 수행하고, iOS 애플리케이션에는 Swift를 사용할 것입니다. Python 코드에서 각 기능에 대해 생성된 탐색적 시각화 및 몇 가지 더 구체적인 결과들이 구축되기 전에 기본 랜덤 포레스트 분류기 모델을 만들 것입니다. 앱을 위해 몇 가지 염두에 두어야 할 사항들:\n\n- 사용자가 모델 예측을 위해 현실적인 시작점을 갖도록 기본적으로 이러한 값으로 설정하는 경우에 나중에 앱 인터페이스를 만들 때 데이터의 각 기능에 대한 전반적인 중심 경향 측정치를 표시할 것입니다.\n- 원래 데이터와의 모델 예측을 테스트할 수 있도록 몇 가지 변수 간의 관계를 관찰할 것입니다.\n\n![image](/assets/img/2024-06-23-Multi-touchMLModels_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 등고선 플롯에서 극값을 참고하여, 매우 가능성 있는 당뇨 진단이 있는 경우와 당뇨가 덜 가능성 있는 경우를 찾기 위해 데이터를 필터링할 수 있습니다. 아래는 110에서 130 사이의 글루코스 값, BMI가 30에서 35 사이인 경우 및 양성 당뇨병 분류에 대한 중앙값이 제공됩니다. 나중에 이러한 값들을 선택하여 우리 모델이 양성 분류를 예측하는지 확인할 것입니다.\n\n우리 모델은 scikit-learn에서 가져온 기본 랜덤 포레스트 분류기입니다. 데이터에 표준 스케일러를 적용하는 전처리기로서 파이프라인을 사용함에 유의하세요. 현재 모델에 추가적인 최적화는 수행되지 않았으며, 제 현재 초점은 iOS 앱에 배포하는 방법을 보여주는 것입니다.\n\n```js\nclf = RandomForestClassifier((random_state = 42), (n_estimators = 500));\npipe = Pipeline([(\"scaler\", StandardScaler()), (\"rf\", clf)]);\npipe.fit(X_train, y_train);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델은 조정 없이 첫 번째 시도에서 테스트 데이터에서 0.8의 정확도 점수를 보였어요. 당뇨병 양성 진단을 예측하는 데 어려움을 겪는 반면, 음성 진단을 예측하는 데는 더 어려움이 있어요. 특성 중요도를 확인할 때 혈중 포도당 수준이 가장 큰 영향을 주며, 이어서 BMI, 나이, 그리고 환자의 당뇨병 가계식 기능이 나타났어요. 사용자에게 직관적인 방식으로 이러한 특성을 전달할 수 있는지 앱을 개발하는 과정에서 이러한 점을 염두에 두겠어요. 다음으로는 Python 모델을 Core ML 파일로 내보내고 iOS 앱에서 시각화를 위한 데이터를 준비해볼게요.\n\n## Python 모델을 Core ML로 내보내기\n\nPython 코드에서 Core ML 도구를 가져와서 ct로 별칭을 만들어요. Core ML 도구에는 여러 모델을 지원하는 컨버터 클래스가 있으며, 원핫 인코딩과 같은 전처리기를 포함하고 있어요. convert 메서드를 호출하면 외부에 저장하고 Xcode와 같은 앱 개발 환경에서 가져올 수 있는 모델이 생성되어요:\n\n```js\ncoreml_model = ct.converters.sklearn.convert(pipe, X_cols, \"Outcome\");\ncoreml_model.save(\"DiabetesTest.mlmodel\");\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCore ML 도구에 대한 문서를 읽어보세요. Python 라이브러리로 어떤 것이 지원되는지 확인할 수 있어요. PyTorch, TensorFlow와 같은 인기 있는 신경망 라이브러리 뿐만 아니라 scikit-learn, XGBoost, LibSVM과 같은 비신경망 라이브러리도 지원되요. 사용 중인 라이브러리가 지원되지 않는다면, 사용 가능한 것에 맞추기 위해 파이프라인을 다시 설계해야할 수도 있어요.\n\n## 소스 데이터를 JSON으로 내보내기\n\nAPI 데이터를 가져오는 것을 시뮬레이션하기 위해 .csv 파일을 JSON으로 변환하고 있어요. 이것은 반드시 최상의 방법은 아니지만, 일부 데이터 시각화에 우리 앱이 작동하려면 데이터가 이런 형식으로 포맷되어 있으면 편리할 거에요. iOS 앱에서 데이터를 인덱싱하는 데 도움이 되도록 내보내기 전에 데이터에 일부 수정을 가했어요:\n\n```js\nimport json\nout = pima.reset_index()\nout = out.rename({'index': 'id'}, axis=1)\nout = out.to_json(orient='records')\nparsed = json.loads(out)\nwith open('data/diabetes.json', 'w') as f:\n    f.write(out)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## iOS 애플리케이션으로 모델 가져오기\n\n이제 iOS 기기에 최적화된 형식으로 모델을 내보냈으니, 애플리케이션으로 불러와야 합니다. 이후에는 Apple의 Xcode 환경을 사용해 Swift로 개발하게 될 것입니다. Xcode에서는 파일 - \"파일 추가...\" 메뉴를 이용해 프로젝트에 파일을 추가할 수 있고, 그 후에는 Swift 코드로 참조하면 됩니다. 아래는 모델의 파일명이 DiabetesTest로 설정된 예시입니다.\n\n```Swift\nimport CoreML\nimport CreateMLComponents\n\nlet config = MLModelConfiguration()\nlet model = try DiabetesTest(configuration: config)\n```\n\n모델을 불러왔는데, 이제 앱에서 어떻게 예측을 만들 수 있을까요? 모델은 prediction() 메서드를 가지고 있으며, 데이터의 모든 특징을 매개변수로 사용합니다. 호출하는 방법은 아래와 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nlet prediction = try model.prediction(Pregnancies: pregnancies,\nGlucose: glucose,\nBloodPressure: bloodPressure,\nSkinThickness: skinThickness,\nInsulin: insulin,\nBMI: BMI,\nDiabetesPedigreeFunction: diabetesPedigreeFunction,\nAge: Age)\npredictionValue = Int(prediction.Outcome)\n\n## iOS 애플리케이션으로 JSON 데이터 가져오기\n\n데이터를 로드해야 합니다. 이 작업은 모델을 훈련하는 데 사용한 각 개인의 건강 데이터를 시각화하는 데 도움이 됩니다. Pima라는 구조체를 만들어서 시작하겠습니다. 이 구조체는 Codable 및 Identifiable로 만들어지며, 각 특징이 나열됩니다.\n\n```swift\nstruct Pima: Codable, Identifiable {\n    let id: Int\n    let Pregnancies: Float\n    let Glucose: Float\n    let BloodPressure: Float\n    let SkinThickness: Float\n    let Insulin: Float\n    let BMI: Float\n    let DiabetesPedigreeFunction: Float\n    let Age: Float\n    let Outcome: Float\n\n    var BMIString: String { BMI.formatted(.number) }\n    var GlucoseString: String { Glucose.formatted(.number) }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터를 가져오는 것은 JSON 디코딩이 필요할 거예요. 주요 단계의 요약은 아래에 있어요. 디코딩된 데이터는 클래스 데이터 객체에 저장돼요. 이 객체는 프로젝트 전체에서 공유할 거예요:\n\n```js\nlet bundlePath = Bundle.main.path(forResource: name,\n                                  ofType: \"json\"),\nlet jsonData = try String(contentsOfFile: bundlePath).data(using: .utf8)\nlet decodedData = try JSONDecoder().decode([Pima].self,\n                                           from: jsonData)\nself.pima = decodedData\n```\n\n## 모델 실험을 위한 인터페이스 구축\n\n이제 데이터를 불러왔으니, 앱 인터페이스 구성 요소를 만들어 볼 수 있어요. 이 구성 요소에는 다음이 포함돼요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 혈당, BMI, 연령 및 기타 측정치의 값을 수정할 수 있는 슬라이더. 환자의 당뇨병 가능성을 나타낼 예측이 값이 변경될 때마다 이루어집니다.\n- 당뇨병 분류 결과를 동반하는 차트로, 소스 데이터에서 두 그룹에 속한 환자 수를 표시합니다.\n- 데이터의 스크롤 가능한 뷰로, 선택한 값을 원본 데이터세트의 값과 비교하거나 양성 및 음성 분류 간을 비교할 수 있습니다.\n\n이러한 요소들의 조합은 다양한 배경을 가진 사람들이 모델과 소스 데이터를 실험을 통해 이해할 수 있도록 의도되었습니다. 예를 들어, 혈당 슬라이더를 조절하여 혈당이 증가함에 따라 산점도에 오렌지색 점의 증가와 이웃 막대 차트의 더 높은 오렌지색 막대가 나타나며, 더 많은 양성 케이스를 나타냅니다. 다른 기능들, 특히 연령과 BMI와 실험을 통해 이들 값과 양성 예측 사이의 관계를 비교하면 유사한 발견이 이뤄질 것입니다. 각 슬라이더 변경 시 모델은 예측을 수행하고 데이터를 필터링하여 현재 뷰와 함께 필터링된 데이터를 제공합니다.\n\n우리의 슬라이더를 구현하기 위해, 각 기능에 대해 데이터의 최소/최대 값을 범위로 설정할 수 있습니다. 슬라이더가 이동하고 값이 변경될 때마다, 차트에서 읽은 공유된 필터링된 데이터를 업데이트하고 현재 슬라이더 값을 사용하여 모델에 의한 예측을 실행합니다. 혈당 슬라이더를 사용한 예시는 아래와 같습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:590/1*ekxFVO-UDWH_2I9FQjQiPw.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 데이터 개요 섹션에서 관찰된 값들과 유사한 값을 사용하여 Glucose의 범위를 110에서 130으로 보여주는 컨투어 플롯이 있습니다. 이 플롯은 이 범위에서 당뇨병 양성 진닝의 높은 양을 나타냈습니다. 이러한 글루코스 값으로 업데이트한 후 모델이 양성 분류를 지정하는 것을 보는 건 격려가 됩니다!\n\n시각화를 만들려면 Charts 라이브러리가 필요하며, 우리는 당뇨병이 없는 환자를 나타내는 파란색, 당뇨병이 있는 환자를 나타내는 주황색으로 사용자 지정 색상을 가진 산점도를 보여줍니다. 막대 차트는 두 가지 당뇨병 결과를 따로 그룹화하고 현재 슬라이더 값에 따라 총계를 계산합니다. 다음은 막대 차트에 대한 코드 스니펫입니다:\n\n```js\n// 현재 선택 항목에 따른 총 수 카운트 찾기\nlet aggregatedData = Dictionary(grouping: filteredTable, by: { $0.Outcome })\n    .map { (outcome, items) in\n        (category: outcome, count: items.count)\n    }\n\n// 막대 차트 생성\nlet barChart = Chart(aggregatedData, id: \\.category) { item in\n    BarMark(\n        x: .value(\"카테고리\", item.category),\n        y: .value(\"수\", item.count)\n    )\n    .annotation(position: .top, alignment: .center) {\n        Text(\"\\(item.count)\")\n            .font(.caption)\n            .foregroundColor(.black)\n    }\n    .foregroundStyle(by: .value(\"카테고리\", item.category))\n}\n```\n\n이 시점에서 사용자에게 혈당, BMI 및 기타 기능의 값 선택이 실제 환자 데이터와 일치하는지를 보여줄 수 있습니다. 또한 우리의 모델이 그러한 선택을 기반으로 예측을 하는 방법을 동시에 보여줄 수 있습니다. 그러나 혈당, BMI 및 기타 기능에 대한 \"정상\" 값이 무엇인지에 대한 사용자에게 더 많은 컨텍스트를 제공하는 방법은 무엇일까요? 앱 설계 시에 이 문제를 몇 가지 마주쳤습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 화면 공간이 제한되어 있어 숫자들과 요약 통계의 벽이 잘 표시되지 않아요.\n- 최소 두 세트의 데이터를 동시에 비교할 수 있어야 하며 사용자가 비교하려는 데이터 포인트를 쉽게 선택할 수 있어야 합니다.\n- 사용자가 소스 데이터와 일치하지 않는 값을 실수로 선택하면 해당 값과 일치시킬 수 없게 됩니다.\n\n1번과 2번 문제에 대한 해결책은 스플릿 스크롤 뷰를 생성하는 것이었습니다. 뷰의 반은 하나의 데이터 세트에 투여되고, 다른 반은 비교할 대상에 투여됩니다. 두 가지를 빠르게 동시에 스크롤하여 값들을 비교할 수 있으므로 노력을 많이 들이지 않고도 비교할 수 있습니다. 이를 위해 새로운 두 가지 뷰를 생성했고, 앱 상단 오른쪽의 Stats 버튼을 클릭하여 이동할 수 있습니다. 첫 번째 뷰는 현재 선택 사항과 필터링된 데이터의 중앙/최소/최대 값을 비교할 수 있도록 합니다. 두 번째 뷰는 긍정적 결과로 필터링된 데이터와 부정적 결과로 필터링된 데이터 간의 비교를 제공합니다.\n\n\"이움 매체 데이터\"라고 표시된 추가 슬라이더를 추가하여 사용자가 데이터 포인트와 가깝지 않은 값을 선택할 때 대응했습니다. 이 슬라이더를 조정하면 사용자가 선택한 값의 위와 아래로 필터 범위가 증가하여 현재 선택 사항 주변에 점점 더 넓은 범위로 데이터를 검색합니다. 왼쪽 끝까지 슬라이드하면 모든 데이터 포인트가 표시됩니다. 다른 뷰의 중앙/최소/최대 계산은 이 데이터 선택을 기반으로 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:590/1*VEDrLQddT4Pi2rGqGK8G5A.gif\" /\u003e\n\n## 결론\n\n우리는 직관적인 스마트폰 인터페이스를 활용하여 데이터와 머신러닝 모델을 다루는 직관적인 방법을 만들 수 있습니다. Apple의 Core ML 도구를 사용하면 우리는 파이썬으로 모델을 개발하고 이를 iOS 네이티브 모델 형식으로 변환한 다음 앱에 가져올 수 있습니다. 우리의 앱은 사용자가 기능 값들을 수정할 수 있는 기능을 제공하여 모델을 훈련시키는 데 사용된 데이터 세트를 탐색하고 모델의 예측 출력을 볼 수 있게 합니다. 이 공간에서 탐색할 수 있는 많은 가능성이 있으며, 모델과 다른 인터페이스를 계속해서 만들면 다른 사람들에게 결과를 전달하는 새로운 방법을 열 수 있습니다!\n\n어떤 모델 인터페이스를 만들어 보고 싶으신가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 링크\n\nGitHub 저장소\n\n애플의 Core ML 도구\n\n피마 인디언 당뇨병 데이터베이스\n","ogImage":{"url":"/assets/img/2024-06-23-Multi-touchMLModels_0.png"},"coverImage":"/assets/img/2024-06-23-Multi-touchMLModels_0.png","tag":["Tech"],"readingTime":13}],"page":"19","totalPageCount":116,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"19"},"buildId":"wfHLuDA3kTGBYfaM5IGXk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>