<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/47" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/47" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_buildManifest.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요" href="/post/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드" href="/post/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피" href="/post/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플러터 애플리케이션에서 보안 강화하기" href="/post/2024-05-18-IncreasesecurityinyourFlutterapplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플러터 애플리케이션에서 보안 강화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플러터 애플리케이션에서 보안 강화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">플러터 애플리케이션에서 보안 강화하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="응용 프로그램 아키텍처 데이터 레이어" href="/post/2024-05-18-AppArchitectureDatalayer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="응용 프로그램 아키텍처 데이터 레이어" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-AppArchitectureDatalayer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="응용 프로그램 아키텍처 데이터 레이어" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">응용 프로그램 아키텍처 데이터 레이어</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제트팩 코파 서체에서 Window Insets 이해하기" href="/post/2024-05-18-UnderstandingWindowInsetsinJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제트팩 코파 서체에서 Window Insets 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제트팩 코파 서체에서 Window Insets 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">제트팩 코파 서체에서 Window Insets 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법" href="/post/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트" href="/post/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로" href="/post/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl"> 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드" href="/post/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link posts_-active__YVJEi" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요","description":"","date":"2024-05-18 17:16","slug":"2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD","content":"\n\n![이미지](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png)\n\n내가 글을 쓸 때마다, 어떤 순간에라도, Apple의 생태계란 구문이 끼어들게 돼요.\n\n진짜 그 유혹에 맞섰다가도 다른 표현 방법이 떠오르지 않아요.\n\nApple은 우리 주변에 조용하게 그리고 매끄럽게 이 벽이 있는 정원을 쌓아 올렸어요. 우리가 알아채지 못하게. 틀림없이, 이것은 우리가 계속해서 Apple의 최신 제품을 사도록 매료하게 만드는 일부분이에요. 전반적으로, 이는 아주 효과적으로 작동해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 것조차 iPhone에서 iPhone으로 전환하는 것은 훨씬 쉬워요. 하나를 다른 쪽에 가져가면 거의 끝나요. iCloud는 마치 대가감 있게 모든 것을 감독하고 우리의 Apple 생활을 유지하는 데 필요합니다.\n\nApple 생활에 대해 칭찬하고 사랑할 만한 것이 많이 있어요. 예를 들어, 최근에 시작한 Photos 앱은 얼마나 강력한지 깨닫고 있는 앱이에요. 그것은 보석 같아요.\n\n그래, 우리 사진과 문서가 동기화되고 어디에서나 사용 가능하다는 것에 새로운 점은 없어요. 우리는 그것을 기대하죠. 그러나 Apple 생태계의 미세한 뉘앙스가 더 흥미로운 거예요. 여러 Apple 기기를 소유하는 것이 얼마나 매끄럽게 통합될 수 있는지를 만드는 요소들이에요.\n\n# Apple 생활\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n핸드오프는 가끔 언급하는 주제야 — 진짜 좋아해.\n\n아침 러닝 후에 집에 들어오면 핸드폰을 홈팟 중 하나에 건네면 방금 듣고 있던 앨범이나 팟캐스트가 계속 재생돼! 천재적이지!\n\n![이미지](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_1.png)\n\n유니버설 컨트롤은 여러 대의 맥에서 마우스를 공유하는 것이 정말 편리해. 지금 이 글을 쓰고 있는데 Studio Display 앞에는 16인치 맥북 프로 한 대와 한쪽에는 M2 맥북 에어가 있어 — 하지만 하나의 키보드, 하나의 마우스, 하나의 트랙패드로 모든 것을 제어할 수 있어. 진짜 멋져.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘 나의 블루투스가 하루에 여러 번 무작위로 끊기고 있어서 M1 MacBook Pro에서 유니버설 컨트롤도 끊기는 현상이 발생하고 있어. 스튜디오 환경은 그대로인데 뭔가 이상한 점을 눈치 채신 분들 있을까 궁금해. 나는 Sonoma 14.3.1을 사용 중이야. \n\n하지만 그런 이상한 문제들은 제치고, 애플 제품을 사용하면 정말 대단한 기능을 체험할 수 있어. 매일 모든 것이 완벽하게 작동하는 게 정말 대단한 거지만, 예외가 발생하면 그때는...!\n\n애플 제품들과 함께하는 게 멋지긴 한데 가끔은 골치 아픈 순간들이 있어. 그럴 때는 짜증 나는 건 말할 것도 없고, 오늘은 나만의 일상적인 짜증거리들을 소개하고 싶어. 이 중에서 가장 먼저 소개할 건...\n\n# 시리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n음 - 아마 거기까지 둘 수도 있겠어요. 우리 모두가 Siri를 사용하는 데 어려움을 겪는 것을 알고 있지만, 적어도 언급하지 않고는 명백한 양심으로 이 이야기를 쓸 수 없을 것 같아요!\n\n저는 오직 Siri만 사용해왔고, 작년에 Pixel 8 Pro를 사용하면서 구글의 음성 어시스턴트 대안을 잠시 체험해 봤었는데, 그 차이에 놀랐습니다.\n\n이론적으로, 깨어나는 명령어가 단순한 Siri로 줄어들었지만, 저에게는 때로는 그렇게 작동하지 않아요. 가장 불안정한 반응은 차 안에서 Apple CarPlay을 사용할 때입니다.\n\n![이미지](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n차 안은 음성 어시스턴트가 아주 유용한 곳이지만 내 경험상 Siri는 차 안에서 최악입니다. 많은 경우에 응답을 받지 못하고 거의 어느 때나 일어나는 명령어를 인식하지 못합니다. 대신 예전의 \"Hey Siri\" 명령어를 사용해야 하고 심지어 CarPlay도 그 명령어를 잡지 못할 때가 있습니다. 대신 전화가 깨어나버립니다!\n\nSiri가 작동할 때 대답이나 응답이 대부분 이상하거나 이상합니다. 그 \"세부 정보를 전화로 보낼 수 있어요\" 멘트를 한 번 더 들으면 진짜 화가 나서 홈팟을 거실 창문으로 던질지도 모릅니다!\n\n솔직히 Siri는 엉망입니다! 우리는 올해 WWDC에서 Apple이 AI에 대한 견해를 공개하면서 Siri를 크게 개선할 것이라는 강력한 소문을 듣고 있습니다. 이번에는 제대로 처리하길 바랍니다.\n\n현재의 Siri는 다소 농담처럼 보입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 지속성 카메라\n\n일단 이것에 대해 명확히 하고 싶은 것이 있어요 — 지속성 카메라 자체로는 정말 멋져요.\n\n아직 사용해보지 않았다면 꼭 사용해보세요! 당신이 가지고 있는 최고의 웹캠은 아마도 당신의 주머니 속에 있는 아이폰 카메라일 거에요 — 그리고 지속성 카메라를 사용하면 이를 맥북이나 아이맥에 연결해서 영상 통화에 아이폰 카메라를 사용할 수 있답니다.\n\n최신 tvOS로 업데이트했다면, 심지어 TV에서 FaceTime 통화에도 사용할 수 있어요 — HD로 자신을 55인치 패널에서 볼 수 있는 용기가 충분하다면 말이에요! 하지만 완벽하게 무선으로 작동하기 때문에 이용이 편리해요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_3.png)\n\n그 모든 칭찬을 해도 오늘의 나쁜 목록에 올라간 이유가 무엇인가요?\n\n이것은 좀 사용자별이라고 인정하고 시작하겠습니다. 그러나 매번 Premiere Pro를 열 때마다 iPhone이 사진 입력으로 연결하려고 해서 짜즯네요! 너무 작은 일이라는 걸 알지만, 그저 Premiere를 영원히 잊으라고 말할 방법이 있었으면 좋겠어요. 그냥 프로젝트를 계속하고 싶은데 전화기를 계속 연결을 끊을 필요가 없어야 하는데요 — 어이쿠!\n\n그리고 유사한 일로...\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자동 전환\n\n다시 말해요 - 멋진 개념이지만 이것과 함께 살아가는 것은 꽤 골치 아파요.\n\n아마 여러 대의 맥을 가지고 계시다면 망상할 것 같아요. 만약 여러 대의 맥을 사용하는 AirPods 사용자라면, 한 대의 맥에서 작업을 하면서 무언가를 듣다가 다른 맥으로 전환하면, AirPods가 엄청 괴로워져요. 갑자기 다른 맥으로 따라오려고 하는 것 같아요 - 이상한 일은, 다른 맥에서 아무것도 재생되고 있지 않은 상태에서도 발생해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자동 전환은 이론적으로 유용한 기능 중 하나입니다... 어딘가 연구실에서는 그게 세상에서 가장 이치에 맞는 것처럼 보일지도 몰라요. 하지만 현실에서는 조금 다른 일이 일어날 수 있죠.\n\n# 무엇을 두고 왔나요?\n\n다시 한 번, 이런 일은 여러분에게도 일어날 것입니다.\n\n집에 돌아오는 길에 가게에 잠깐 들러 저녁을 사러 가면서 맥북이나 에어팟 맥스를 차 안에 두고 나온 적이 있을 거예요. 그럴 때마다 Apple Watch로 '무언가를 두고 나왔다'는 알림이 오면 마치 무언가를 훔쳐갔다고 생각되어 놀랍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, Find My 앱에서 알림을 끌 수 있는 건 알고 있어요—하지만 항상 할 생각은 하지만 항상 잊게 돼요.\n\n알림이 너무 많다면—어떻게 생각하세요?\n\n# 침묵의 암살자\n\n그래서—요즘 대부분의 사람들처럼 전화 소리를 끈 상태로 핸드폰을 사용해요. 전화를 많이 받지 않고, 묵상적으로 소리가 없는 상태가 더 평온하다고 느껴지거든요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내가 전화를 받는 방법은 일반적으로 책상 앞에 놓인 전화로 전화를 보거나 Apple Watch의 진동 팔찌로 전화를 받는 것을 의지합니다.\n\n![Image](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_5.png)\n\n하지만 여기가 문제예요. 오늘 언급한 이 분규 중 많은 것들과 마찬가지로 이 기능은 때때로만 작동합니다. 그 이유나 근거가 없어 보이죠. 작동할 때는 최고의 방법 중 하나로 호출 알림을 받지만, 내가 이것에 의존할 수 없어요.\n\n또한 시계로 Mac 잠금 해제도 좀 이상해요. 웃기는 건 Mac이 가장 잘 작동하는 것은 제 오래된 2015년형 27인치 iMac이에요. Apple Watch가 작동해야 하는데 새로운 지문 인식 Magic Keyboard를 사는 걸 피하려고 했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 문제 해결 방법\n(paren은 괄호)\n1. 처음에 내가 지정한 form_tools라는 class를 넣었는데, HTML 태그와 같이 들어가서 CSS가 적용되지 않아서 문의했습니다. 아마도 TagUISetting쪽에도 포함시켜서 설정을 보완하는 것이 최선인 것 같습니다.\n2. 두 번째 문제는 TagAcceptCallback 함수를 정의하지 않았다는 것입니다. 그래서 문제 해결을 위해 함수를 추가했습니다. 이제 기능이 잘 작동합니다.\n3. 세 번째 문제는 항상 합의 가을로 떨어진다는 것입니다. 그래서 로직을 수정하여 기온이 5도 이상인지 아닌지에 따라 계절을 변화시키도록 했습니다. 그렇게 하니까 잘 작동했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n200개 이상의 생산성 앱을 한 곳에서 쉽게 확인하고 싶나요? 그렇다면 SetApp을 확인해보세요. 정말 멋진데요 — 매월 한 번의 요금으로 Bartender, CleanShot X, Paste, iStat Menus, 그리고 BetterTouchTool과 같은 훌륭한 앱 중에서 선택할 수 있습니다. 한 번 시도해보고 30일 무료 이용해 보고 싶다면 제 제휴 링크를 클릭하고 확인해보세요. 어떤 앱이 가장 마음에 들었는지 저에게 알려주세요.\n\n원문은 2024년 3월 8일에 https://talkingtechandaudio.com에서 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png"},"coverImage":"/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png","tag":["Tech"],"readingTime":6},{"title":"Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드","description":"","date":"2024-05-18 17:13","slug":"2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced","content":"\n\n아래는 Markdown 형식으로 변환되었습니다.\n\n![이미지](/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png)\n\n# 안드로이드에서의 네비게이션은 무엇인가요?\n\n네비게이션은 애플리케이션의 다른 구성 요소 간에 이동하는 방법을 이해하는 데 도움이 됩니다.\n\nAndroid JetPack 네비게이션은 고수준의 네비게이션을 간편하게 구현하는 데 도움을 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네비게이션 컴포넌트는 세 가지 주요 부분으로 구성되어 있어요:\n\n- 네비게이션 그래프: 이는 모든 네비게이션 관련 데이터를 한 곳에 모아 둔 리소스입니다. 이에는 앱 내의 모든 위치인 목적지들과 사용자가 앱을 통해 이동할 수 있는 가능한 경로들이 포함됩니다. 앱에서 갈 수 있는 모든 장소와 그 있는 방법을 담은 큰 책처럼 생각하시면 좋아요. 이것은 지도와 안내서가 결합된 것으로 이해할 수 있어요.\n- NavHost: 이는 레이아웃에 포함할 수 있는 독특한 컴포저블(composable)입니다. 네비게이션 그래프에서 다양한 목적지를 표시해줘요. NavHost는 NavController를 네비게이션 그래프에 연결하여 네비게이션 사이를 이동할 수 있는 컴포저블 목적지를 지정하는 링크 역할을 합니다. 컴포저블 간을 이동하는 동안 NavHost의 내용은 자동으로 recompose됩니다. 네비게이션 그래프의 각 컴포저블 목적지는 경로에 연결돼 있어요.\n- NavController: NavController는 네비게이션 컴포넌트의 중심 API입니다. 이는 상태를 가지고 있으며, 앱의 화면을 구성하는 컴포저블들의 백 스택과 각 화면의 상태를 추적합니다.\n\n# Jetpack Compose에서의 네비게이션\n\n네비게이션 컴포넌트는 Jetpack Compose 애플리케이션을 지원해줍니다. 네비게이션 컴포넌트의 인프라와 기능을 활용하면서 컴포저블들 간을 이동할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJetpack Compose에서 탐색을 시작하려면 프로젝트의 build.gradle 파일에 필수 종속성을 포함해야 합니다:\n\n```js\nimplementation \"androidx.navigation:navigation-compose:2.7.1\"\n```\n\nJetpack Compose에서 탐색에 대한 기본 개념.\n\n## NavController:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNavController은 네비게이션 컴포넌트의 중심 API입니다. 상태를 유지하며, 앱의 화면을 구성하는 컴포저블의 백 스택 및 각 화면의 상태를 추적합니다.\n\n이러한 NavController는 다음과 같이 rememberNavController() 메서드를 사용하여 만들 수 있습니다:\n\n```js\nval navController = rememberNavController()\n```\n\nNavController를 만들 때는 모든 컴포저블이 해당 NavController에 액세스할 수 있는 컴포저블 계층구조의 적절한 위치에서 만들어야 합니다. 이는 상태 끌어올리기(state hoisting)의 원리를 따르며, 현재 currentBackStackEntryAsState()를 통해 제공되는 NavController 및 상태를 통해 화면 외부의 컴포저블을 업데이트하는 데 참고할 수 있도록 합니다. 이러한 기능의 예시는 바텀 네비게이션바와의 통합을 참고하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## NavHost:\n\n각 NavController는 단일 NavHost composable과 연결되어야 합니다. NavHost는 NavController를 네비게이션 그래프와 연결하여 이동할 수 있는 composable 목적지를 지정합니다. composable 사이를 이동하면 NavHost의 내용이 자동으로 recomposed됩니다. 네비게이션 그래프의 각 composable 목적지는 route와 연결됩니다.\n\nNavHost를 생성하려면 이전에 rememberNavController()를 통해 생성한 NavController와 그래프의 시작 목적지인 route가 필요합니다. NavHost 생성은 네비게이션 Kotlin DSL에서 lambda 구문을 사용하여 네비게이션 그래프를 구성합니다. composable() 메서드를 사용하여 네비게이션 구조를 추가할 수 있습니다. 이 메서드는 route 및 목적지에 연결할 composable를 제공해야 합니다:\n\n```js\nNavHost(navController = navController, startDestination = \"profile\") {\n    composable(\"profile\") { Profile(/*...*/) }\n    composable(\"friendslist\") { FriendsList(/*...*/) }\n    /*...*/\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시: 네비게이션 그래프, 네브호스트 및 네비게이션 아이템 설정하는 방법\n\n단계 1: 네비게이션을 위한 화면 이름 및 라우트를 하나의 파일에 정의합니다. 예시. AppNavigation.kt\n\n```kotlin\nenum class Screen {\n    HOME,    \n    LOGIN,\n}\nsealed class NavigationItem(val route: String) {\n    object Home : NavigationItem(Screen.HOME.name)\n    object Login : NavigationItem(Screen.LOGIN.name)\n}\n```\n\n단계 2: NavHost 및 화면을 정의합니다. 예시. AppNavHost.kt\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n@Composable\nfun AppNavHost(\n    modifier: Modifier = Modifier,\n    navController: NavHostController,\n    startDestination: String = NavigationItem.Splash.route,\n    ... // 다른 매개변수\n) {\n    NavHost(\n        modifier = modifier,\n        navController = navController,\n        startDestination = startDestination\n    ) {\n        composable(NavigationItem.Splash.route) {\n            SplashScreen(navController)\n        }\n        composable(NavigationItem.Login.route) {\n            LoginScreen(navController)\n        }\n    }\n}\n```\n\n단계 3: MainActivity.kt 파일에서 AppNavHost를 호출합니다.\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            AutoPartsAppTheme {\n               Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    AppNavHost(navController = rememberNavController())\n                }\n            }\n        }\n    }\n}\n```\n\n## 네비게이션 인자:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네비게이션 Compose는 코틀린을 사용하여 콤포저블 목적지 간에 인수를 전달하는 것을 지원합니다. 이를 위해 기본 네비게이션 라이브러리를 사용할 때 딥 링크에 인수를 추가하는 방식과 유사한 방식으로 라우트에 인수 자리 표시자를 추가해야 합니다. \n\n## 사용 사례:\n\n- 인수가 없을 때\n- Int, String 등 미리 정의된 데이터 유형과 같은 간단한 인수를 사용할 때\n\n3. 사용자가 정의한 데이터 유형 같은 복잡한 인수를 사용할 때\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 선택적 매개변수\n\n5. 결과값으로 되돌아가기\n\n## 매개변수 없이:\n\n```js\nNavHost(navController = navController, startDestination = \"profile\") {\n    composable(\"profile\") { Profile(/*...*/) }\n    composable(\"friendslist\") { FriendsList(/*...*/) }\n    /*...*/\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 간단한 인수로:\n\n기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다:\n\n```js\nNavHost(startDestination = \"profile/{userId}\") {\n    ...\n    composable(\"profile/{userId}\") {...}\n}\n```\n\n기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nNavHost(startDestination = \"profile/{userId}\") {\n    ...\n    composable(\n        \"profile/{userId}\",\n        arguments = listOf(navArgument(\"userId\"){\n           type = NavType.StringType \n        })\n    ) {...}\n}\n```\n\n`composable(\"profile/{userId}\") { backStackEntry -\u003e\n   val userId = backStackEntry.arguments?.getString(\"userId\")\n   // 여기서 사용자 데이터를 가져와야 합니다\n   Profile(\n      navController, \n      // 사용자 데이터를 가져와서 전달하세요. 예: UserInfo\n   )\n}\n`\n\n대상으로 전달하려면 navigate 호출 시 경로에 추가해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nnavController.navigate(\"profile/user1234\")\n```\n\n지원되는 유형 목록을 보려면 전달 방법을 참조하세요.\n\n## 복잡하거나 사용자 정의 인수로:\n\n이동할 때 복잡한 데이터 객체를 전달하는 것은 권장되지 않지만 대신 고유 식별자 또는 기타 형식의 ID와 같이 최소한의 정보를 인수로 전달해야합니다. 이를 통해 이동 작업 수행 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 새로운 대상으로 이동할 때 사용자 ID만 전달하실 때\nnavController.navigate(\"profile/user1234\")\n```\n\n복잡한 객체는 데이터 레이어와 같은 단일 진실의 원천으로 저장해야 합니다. 이동 후 목적지에 도착하면 전달된 ID를 사용하여 단일 진실의 원천에서 필요한 정보를로드할 수 있습니다. 데이터 레이어에 액세스하는 ViewModel에서 인수를 검색하려면 SavedStateHandle를 사용할 수 있습니다.\n\n```js\nclass UserViewModel(\n    savedStateHandle: SavedStateHandle,\n    private val userInfoRepository: UserInfoRepository\n) : ViewModel() {\n\n    private val userId: String = checkNotNull(savedStateHandle[\"userId\"])\n\n    // 전달된 userId 인수를 기반으로 데이터 레이어(예: userInfoRepository)에서 관련 사용자 정보 검색\n    private val userInfo: Flow\u003cUserInfo\u003e = userInfoRepository.getUserInfo(userId)\n\n   --------------- OR -----------------\n \n    // 네트워크 또는 데이터베이스에서 데이터 가져오기    \n    private val _dataFlow =\n            MutableStateFlow\u003cUserInfo\u003e(userInfoRepository.getUserInfo(userId))\n    val dataFlow get() = _dataFlow.asStateFlow()\n}\n```\n\n적합한 기능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n//Navhost\ncomposable(\"profile/{userId}\") { backStackEntry -\u003e\n   val userId = backStackEntry.arguments?.getString(\"userId\")\n   // 여기서 사용자 데이터를 가져와야 합니다\n   val userInfo by taskViewModel.dataFlow.collectAsState()   \n   Profile(\n      navController, \n      userInfo\n   )\n}\n\n// 프로필 화면\n@Composable\nfun Profile(navController: NavController, userInfo: UserInfo){\n    // 여기서 작업을 수행합니다\n}\n```\n\n이 접근 방식은 구성 변경 중에 데이터 유실을 방지하고 해당 객체가 업데이트되거나 변경될 때 불일치를 방지합니다.\n\n복잡한 데이터를 인수로 전달하는 것을 피해야 하는 이유 및 지원되는 인수 유형 목록에 대한 보다 자세한 설명은 Best practice를 참조하세요.\n\n## 선택적 인수 추가하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNavigation Compose는 선택적 네비게이션 인수도 지원합니다. 선택적 인수는 필수 인수와 두 가지 방법으로 다릅니다:\n\n- 쿼리 매개변수 구문(\"?argName='argName'\")을 사용하여 포함되어야 합니다.\n- defaultValue가 설정되어 있어야 하거나 nullable = true이어야 합니다(이는 기본 값을 자동으로 null로 설정합니다).\n\n이는 모든 선택적 인수가 콤포저블() 함수에 명시적으로 추가되어야 한다는 것을 의미합니다:\n\n```js\ncomposable(\n    \"profile?userId={userId}/{isMember}\",\n    arguments = listOf(\n         navArgument(\"userId\") {\n            type = NavType.StringType\n            defaultValue = \"user1234\"\n           // 또는\n            type = NavType.StringType\n            nullable = true\n         },\n         navArgument(\"isNewTask\") {\n            type = NavType.BoolType\n         }\n     )\n) { backStackEntry -\u003e\n    val userId = backStackEntry.arguments?.getString(\"userId\")\n    val isMember = backStackEntry.arguments?.getBoolean(\"isMember\")?:false\n    Profile(navController, userId, isMember)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 대상에 인수가 전달되지 않더라도 defaultValue = \"user1234\"가 대신 사용됩니다.\n\n경로를 통해 인수를 처리하는 구조는 Composable이 Navigation과 완전히 독립되도록 하며 이로 인해 테스트하기 훨씬 더 용이해집니다.\n\n## 결과 값으로 되돌아가기\n\n결과 값을 사용하여 되돌아가는 것이 가장 일반적인 작업입니다. 즉, 필터 대화상자를 열고 필터를 선택한 다음 해당 필터를 적용하기 위해 선택된 필터와 함께 되돌아가는 경우입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 개의 화면이 있습니다. 1. 첫 번째 화면과 2. 두 번째 화면입니다. 우리는 두 번째 화면에서 첫 번째 화면으로 데이터를 필요로 합니다.\n\nNavHost.kt : 내비게이션 그래프 설정.\n\n```js\n val navController = rememberNavController()\n NavHost(\n     navController = navController,\n     startDestination = \"firstscreen\"\n ) {\n    composable(\"firstscreen\") {\n        FirstScreen(navController)\n    }\n    composable(\"secondscreen\") {\n        SecondScreen(navController)\n    }\n}\n```\n\nFirstScreen.kt: NavController의 현재 백 스택 항목의 savedStateHandle를 사용하여 두 번째 화면에서 다시 이동한 후 데이터를 검색합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n@Composable\nfun FirstScreen(navController: NavController) {\n    // 다음 화면에서 데이터를 가져옵니다\n    val msg = \n        navController.currentBackStackEntry?.savedStateHandle?.get\u003cString\u003e(\"msg\")\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Button(onClick = { navController.navigate(\"secondscreen\") }) {\n            Text(\"다음 화면으로 이동\")\n        }\n        Spacer(modifier = Modifier.height(8.dp))\n        msg?.let {\n            Text(it)\n        }\n    }\n}\n```\n\nSecondScreen.kt: 이전 백 스택 항목의 savedStateHandle 내에 데이터를 넣습니다.\n\n```kotlin\n@Composable\nfun SecondScreen(navController: NavController) {\n    var text by remember {\n        mutableStateOf(\"\")\n    }\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        TextField(\n            value = text, onValueChange = { text = it },\n            placeholder = {\n                Text(\"텍스트를 입력하세요\", color = Color.Gray)\n            }\n        )\n        Spacer(Modifier.height(8.dp))\n        Button(onClick = {\n\n           // 데이터를 savedStateHandle에 넣어 이전 화면에서 데이터를 가져옵니다\n   \n            navController.previousBackStackEntry?.savedStateHandle?.set(\"msg\", text)\n            navController.popBackStack()\n        }) {\n            Text(text = \"제출\")\n        }\n    }\n}\n```\n\n비디오: \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://github.com/KaushalVasava/JetPackCompose_Basic/assets/49050597/1d96d44f-66e1-4f3b-bba1-2844ab6553cc\n\nGitHub 저장소: https://github.com/KaushalVasava/JetPackCompose_Basic/tree/navigate-back-with-result\n\n# 딥 링크\n\nNavigation Compose은 암시적 딥 링크를 지원하며 composable() 함수의 일부로 정의할 수 있습니다. 딥 링크 매개변수 deepLinks는 navDeepLink 메소드를 사용하여 빠르게 생성할 수 있는 NavDeepLinks 목록을 수용합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nval uri = \"https://www.example.com\"\ncomposable(\n    \"profile?id={id}\",\n    deepLinks = listOf(navDeepLink { uriPattern = \"$uri/{id}\" })\n) { backStackEntry -\u003e\n    Profile(navController, backStackEntry.arguments?.getString(\"id\"))\n}\n```\n\n이러한 딥 링크를 사용하면 특정 URL, 액션 또는 MIME 유형을 composable과 연결할 수 있습니다. 기본적으로 이러한 딥 링크는 외부 앱에 노출되지 않습니다. 이러한 딥 링크를 외부에서 사용 가능하게 하려면 앱의 manifest.xml 파일에 적절한 `intent-filter` 요소를 추가해야 합니다. 위의 딥 링크를 활성화하려면 manifest의 `activity` 요소 내에 다음을 추가해야 합니다:\n\n```js\n\u003cactivity …\u003e\n  \u003cintent-filter\u003e\n    ...\n    \u003cdata android:scheme=\"https\" android:host=\"www.example.com\" /\u003e\n  \u003c/intent-filter\u003e\n\u003c/activity\u003e\n```\n\n다른 앱에 의해 트리거된 경우 딥 링크가 활성화될 때 해당 composable로 자동으로 이동합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 동일한 딥 링크는 콤포저블에서 적절한 딥 링크와 함께 PendingIntent를 작성하는 데 사용할 수도 있습니다:\n\n```kotlin\nval id = \"exampleId\"\nval context = LocalContext.current\nval deepLinkIntent = Intent(\n    Intent.ACTION_VIEW,\n    \"https://www.example.com/$id\".toUri(),\n    context,\n    MyActivity::class.java\n)\nval deepLinkPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {\n    addNextIntentWithParentStack(deepLinkIntent)\n    \n    val flag = if(Build.VERSION.SDK_INT \u003e Build.VERSION_CODES.S){\n                    PendingIntent.FLAG_IMMUTABLE\n                } \n                else \n                    PendingIntent.FLAG_UPDATE_CURRENT\n    getPendingIntent(0, flag)\n}\n```\n\n그런 다음 이 deepLinkPendingIntent를 다른 PendingIntent와 마찬가지로 사용하여 앱을 딥 링크 대상지에서 열 수 있습니다.\n\n# 중첩된 내비게이션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_1.png)\n\n앱의 UI에서 특정 플로우를 모듈화하기 위해 대상을 중첩 그래프로 그룹화할 수 있습니다. 이러한 예로는 독립적인 로그인 플로우가 있을 수 있습니다.\n\n중첩 그래프는 메인 그래프처럼 대상을 그룹화하며 해당 경로에 대한 지정된 시작 대상이 필요합니다. 이것은 중첩된 그래프의 경로에 액세스할 때 이동할 위치입니다.\n\nNavHost에 중첩된 그래프를 추가하려면 네비게이션 익스텐션 함수를 사용할 수 있습니다.\n  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nNavHost(navController, startDestination = \"home\") {\n    ...\n    // 그래프를 통해 경로('login')로 이동하면 자동으로\n    // 그래프의 시작 대상인 'username'으로 이동합니다.\n    // 이로써 그래프의 내부 라우팅 로직을 캡슐화합니다.\n    navigation(startDestination = \"username\", route = \"login\") {\n        composable(\"username\") { ... }\n        composable(\"password\") { ... }\n        composable(\"registration\") { ... }\n    }\n    ...\n}\n```\n\n그래프가 커질수록 여러 메소드로 나누는 것이 좋습니다. 이렇게 하면 여러 모듈이 각자의 네비게이션 그래프를 기여할 수 있습니다.\n\n```js\nfun NavGraphBuilder.loginGraph(navController: NavController) {\n    navigation(startDestination = \"username\", route = \"login\") {\n        composable(\"username\") { ... }\n        composable(\"password\") { ... }\n        composable(\"registration\") { ... }\n    }\n}\n```\n\nNavGraphBuilder를 확장 메소드로 만들면 미리 작성된 navigation, composable, dialog 익스텐션 메소드와 함께 사용할 수 있습니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nNavHost(navController, startDestination = \"home\") {\n    ...\n    loginGraph(navController)\n    ...\n}\n```\n\n예시:\n\n```kotlin\nval navController = rememberNavController()\nNavHost(navController = navController, startDestination = \"home\") {\n    composable(\"about\") {}\n    navigation(\n        startDestination = \"login\",\n        route = \"auth\"\n    ) {\n        composable(\"login\") {\n            val viewModel = it.sharedViewModel\u003cSampleViewModel\u003e(navController)\n\n            Button(onClick = {\n                navController.navigate(\"calendar\") {\n                    popUpTo(\"auth\") {\n                        inclusive = true\n                    }\n                }\n            }) {\n            }\n        }\n        composable(\"register\") {\n            val viewModel = it.sharedViewModel\u003cSampleViewModel\u003e(navController)\n        } \n        composable(\"forgot_password\") {\n            val viewModel = it.sharedViewModel\u003cSampleViewModel\u003e(navController)\n        }\n    }\n    navigation(\n        startDestination = \"calendar_overview\",\n        route = \"calendar\"\n    ) {\n        composable(\"calendar_overview\") { }\n        composable(\"calendar_entry\") { }\n    }\n}\n```\n\nNavBackStack entry를 위한 확장 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\n@Composable\ninline fun \u003creified T : ViewModel\u003e NavBackStackEntry.sharedViewModel(navController: NavController): T {\n    val navGraphRoute = destination.parent?.route ?: return viewModel()\n    val parentEntry = remember(this) {\n        navController.getBackStackEntry(navGraphRoute)\n    }\n    return viewModel(parentEntry)\n}\n```\n\n# 하단 탐색 막대와 통합\n\n조합 가능한 구조의 위쪽 수준에서 NavController를 정의함으로써, 네비게이션을 하단 탐색 막대와 같은 다른 구성 요소와 연결할 수 있습니다. 이를 통해 하단 막대에서 아이콘을 선택하여 탐색할 수 있습니다.\n\nBottomNavigation 및 BottomNavigationItem 구성 요소를 사용하려면 Android 애플리케이션에 androidx.compose.material 종속성을 추가하십시오.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n좌측 테이블을 Markdown 형식으로 변환했습니다.\n```\n\n하단 네비게이션바의 항목을 네비게이션 그래프의 루트에 링크하려면 Screen과 같은 sealed class를 정의하는 것이 좋습니다. 이 클래스는 목적지의 루트와 문자열 리소스 ID를 포함합니다.\n\n```js\nsealed class Screen(val route: String, @StringRes val resourceId: Int) {\n    object Profile : Screen(\"profile\", R.string.profile)\n    object FriendsList : Screen(\"friendslist\", R.string.friends_list)\n}\n```\n\n이후 BottomNavigationItem에서 사용할 수 있는 리스트에 해당 항목을 넣으십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nval items = listOf(\n    Screen.Profile,\n    Screen.FriendsList\n)\n```\n\nBottomNavigation 컴포저에서 currentBackStackEntryAsState() 함수를 사용하여 현재 NavBackStackEntry를 가져옵니다. 이 엔트리를 통해 현재 NavDestination에 액세스할 수 있습니다. 각 BottomNavigationItem의 선택 상태는 아이템의 경로를 현재 목적지 및 부모 목적지의 경로와 비교하여 결정할 수 있습니다 (중첩된 내비게이션을 사용하는 경우 처리하기 위해 NavDestination 계층구조를 통해).\n\n아이템의 경로는 또한 onClick 람다를 navigate 호출과 연결하는 데 사용되어 해당 아이템을 탭하면 해당 아이템으로 이동합니다. saveState 및 restoreState 플래그를 사용하여 해당 아이템의 상태와 백 스택이 올바르게 저장되고 전환될 때 해당 아이템의 상태가 올바르게 복원됩니다.\n\n```kotlin\nval navController = rememberNavController()\nScaffold(\n    bottomBar = {\n        BottomNavigation {\n            val navBackStackEntry by navController.currentBackStackEntryAsState()\n            val currentDestination = navBackStackEntry?.destination\n            items.forEach { screen -\u003e\n                BottomNavigationItem(\n                    icon = { Icon(Icons.Filled.Favorite, contentDescription = null) },\n                    label = { Text(stringResource(screen.resourceId)) },\n                    selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,\n                    onClick = {\n                        navController.navigate(screen.route) {\n                            popUpTo(navController.graph.findStartDestination().id) {\n                                saveState = true\n                            }\n                            launchSingleTop = true\n                            restoreState = true\n                        }\n                    }\n                )\n            }\n        }\n    }\n) { innerPadding -\u003e\n    NavHost(navController, startDestination = Screen.Profile.route, Modifier.padding(innerPadding)) {\n        composable(Screen.Profile.route) { Profile(navController) }\n        composable(Screen.FriendsList.route) { FriendsList(navController) }\n    }\n}\n```  \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNavController.currentBackStackEntryAsState() 메소드를 활용하여 네비게이션 컨트롤러 상태를 NavHost 함수 밖으로 빼내어 BottomNavigation 컴포넌트와 공유합니다. 이렇게 하면 BottomNavigation이 항상 최신 상태를 가지게 됩니다.\n\n읽어 주셔서 감사합니다. 🙌🙏✌\n\n더 많은 안드로이드 개발, 코틀린 및 KMP에 관한 유용한 기사를 보시려면 박수를 날려주세요 👏 그리고 팔로우해 주세요.\n\n안드로이드, 코틀린 및 KMP 관련 도움이 필요하시다면 언제든지 도와드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMedium, LinkedIn, Twitter, GitHub, Instagram에서 나를 팔로우하고 DM으로 앱 개발 프리랜싱 업무를 문의해주세요.","ogImage":{"url":"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png"},"coverImage":"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png","tag":["Tech"],"readingTime":19},{"title":"Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피","description":"","date":"2024-05-18 17:11","slug":"2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin","content":"\n\n코틀린 코루틴의 깨끗한 세계에서는 다양한 시간에 실행되는 많은 작업들이 놀랍게도 적은 스레드로 쌓이게 됩니다. 이러한 코루틴들은 종종 서로 통신을 해야합니다. 예를 들어 비동기 작업이 완료되어 결과를 보고해야 하거나 진행 중인 작업이 결과를 전달해야 할 때입니다.\n\n코틀린에는 이러한 통신을 관리하는 데 도움이 되는 여러 구조가 있습니다. 서스펜드 함수는 비동기 작업을 기다리는 데 도움이 되며, 여러 결과를 기대하는 경우 플로우가 필요합니다.\n\n이 기사에서는 일반적으로 비동기 처리에 대해 예시를 들고, 플로우를 소개합니다. 플로우가 왜 필요한지, 핫 플로우와 콜드 플로우의 차이, 그리고 콜백을 서스펜드 함수와 플로우로 변환하는 방법에 대해 알아보겠습니다.\n\n# 레시피 1: 자바 콜백, 어린날로의 돌아가기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선, 여기에는 일시 중단 함수나 플로우가 아닌 것이 있습니다. Firestore에서 문서를 가져오는 방법은 다음과 같습니다:\n\n```js\nFirebase.firestore.collection(\"users\").document(\"me\")\n  .get()   // \"me\" 문서의 비동기 다운로드 시작\n  .addOnSuccessListener { result -\u003e\n    // 다운로드가 완료될 때이 함수가 호출됩니다\n  }\n```\n\n이는 비동기 콜백 패턴입니다. 요청을 하면 작업이 비동기적으로 수행되고 나중에 결과가 돌아옵니다.\n\nJava와 하위 호환성을 유지하며 작성된 API는 이와 같은 비동기 콜백을 가득 가지고 있습니다. 이 패턴은 오래된 것으로 간주되므로 Kotlin 스타일이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 레시피 2: Kotlin을 사용하여 콜백 처리하기: suspendCoroutine\n\n요청한 내용을 받고 나줌에 결과를 받는 상황을 처리하는 더 나은 방법은 코틀린 코루틴의 강력한 기능을 활용하는 대기 함수를 사용하는 것입니다. 제 최근 블로그 포스트에서 대기 함수에 대해 자세히 설명했었는데, 요약하자면: 대기 함수는 현재 코루틴을 일시 중단하지만 실행 중인 스레드를 차단하지 않습니다.\n\n좋은 소식은 콜백을 대기 함수로 변환할 수 있다는 것입니다*. 필요한 함수는 suspendCoroutine입니다:\n\n```js\nsuspend fun getDocument() = suspendCoroutine { continuation -\u003e\n  Firebase.firestore.collection(\"users\").document(\"me\")\n    .get()\n    .addOnSuccessListener { result -\u003e\n      // 받은 문서를 사용하여 일시 중단된 코루틴을 다시 실행합니다.\n      continuation.resume(result)\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋아요. 이제는 getDocument()를 호출하는 방법이 훨씬 간단해졌어요. 예를 들어 ViewModel에서:\n\n```js\nviewModelScope.launch(Dispatchers.IO) {\n    val location = getDocument()\n}\n```\n\nJava의 모든 부가 기능을 제거한 Kotlin이 얼마나 아름다운지 보세요. 함수를 한 줄로 호출할 수 있어요. 아름다워요.\n\n# 안티-레시피 1: 일회성 함수는 한 번만 반환할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 만일 우리가 하나 이상의 응답을 예상하고 있다면 어떻게 해야 할까요?\n\nFirestore에게 문서의 새 버전을 얻을 때마다 업데이트를 유지하도록 요청할 수 있습니다. 이를 위해 addOnSnapshotListener를 사용하고 Firestore는 업데이트가 있을 때마다 리스너를 호출합니다:\n\n```js\nFirebase.firestore.collection(\"users\").document(\"me\")\n  .addOnSnapshotListener { snapshot, error -\u003e\n    // 이 함수는 \"me\" 문서가 업데이트될 때마다 호출됩니다.\n  }\n```\n\n이것을 대기 함수로 변경할 수 있을까요? 아뇨! 대기 함수는 한 번만 반환합니다. 여러 번 continuation.resume()을 호출하면 IllegalStateException(\"이미 재개되었습니다\")가 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Recipe 3](/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png)\n\nSo we need something different. What we need is a flow.\n\n# Recipe 3: Using callbackFlow to return multiple things from an async callback\n\nWhen an object hits the flow’s conveyor belt, we say it’s been emitted by the flow. When it gets taken off the conveyor belt to be handled, we say it’s been collected by a collector.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 Firestore 예제에서는 문서 데이터가 로드되는 플로우를 생성해야 합니다. 나중에 그것을 수집하는 코드를 작성할 것입니다.\n\n## 멀티 샷 콜백을 플로우로 변환하기: callbackFlow\n\n여기서 우리는 흐름 \"컨베이어 벨트\"를 생성하고 업데이트된 문서를 올립니다. 업데이트된 문서는 콜백에서 얻은 스냅샷으로 나타납니다:\n\n```js\n// callbackFlow를 사용하여 플로우 \"컨베이어 벨트\"를 만듭니다.\nval documentFlow = callbackFlow {\n\n  // Firestore에게 \"me\" 문서의 변경 사항을 계속 업데이트하라고 요청합니다.\n  database.collection(\"users\").document(\"me\")\n    .addOnSnapshotListener { snapshot, error -\u003e\n      // 업데이트된 문서를 이 플로우의 \"컨베이어 벨트\"에 올립니다.\n      trySend(snapshot)\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 Firestore에서 받은 각 스냅샷을 방출하는 flow 객체를 생성합니다.\n\n# 레시피 4: flow 수집하기\n\n이제 이 컨베이어 벨트를 설정했고, documentFlow라는 변수에 할당했습니다. 결과를 어떻게 얻을까요?\n\n답변: collect 함수를 사용하여 결과를 수집합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nviewModelScope.launch {\n  documentFlow.collect { snapshot -\u003e\n    // This is the snapshot placed on the conveyor belt earlier\n  }\n}\n```\n\n이 함수는 일시 중단되므로 코루틴 내에서 실행해야 합니다. collect에 전달하는 람다는 새 항목이 컨베이어 벨트에 나타날 때마다 호출됩니다.\n\n이것의 라이프사이클을 좀 고려해보죠. collect 함수는 컨베이어 벨트가 작동을 멈출 때까지 일시 중단됩니다.\n\n플로우 컨베이어 벨트가 작동을 멈출 수 있는 방법은 두 가지뿐입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 종료로: 발신자가 더 이상 전달할 것이 없으면 close()를 호출하여 컨베이어 벨트가 멈추도록 요청합니다.\n- 오류로: 발신자가 예외를 throw합니다. 이로 인해 자동으로 흐름이 닫힙니다.\n\n물론 위의 조건 중 어느 것도 발생하지 않을 수 있어서 컨베이어가 멈출 수도 없습니다. 따라서 collect 호출은 무한 루프를 나타낼 수 있습니다. 그러나 코루틴의 진정한 매력은 collect 함수가 취소 가능하다는 것입니다. 따라서 위의 예제에서는 viewModelScope가 취소되는 즉시 수집이 중지됩니다. 그렇기 때문에 위의 코드는 사실 완전히 안전합니다. 코루틴 범위, 컨텍스트, 작업에 대한 더 많은 내용은 블로그 글에서 확인하실 수 있습니다.\n\n# 레시피 5: Cold flows와 awaitClose\n\ncallbackFlow 람다 내의 코드는 수집기가 수집을 시작할 때 즉시 실행됩니다. 각 새로운 수집기는 다른 수집기와 병렬로 실행 중이더라도 코드가 다시 실행되게 합니다. 이것이 콜드 플로우 동작이라고 알려져 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이에 따라, 수집기가 수집을 멈출 때 Firestore 연결을 종료해야 합니다. 'awaitClose'를 사용하여 이를 자동으로 처리할 수 있습니다:\n\n```js\nval documentFlow = callbackFlow {\n  val listener = database.collection(\"users\").document(\"me\")\n    .addOnSnapshotListener { snapshot, error -\u003e\n      ...\n    }\n  \n  // 이 코드 블록은 수집기가 수집을 멈출 때마다 실행됩니다\n  awaitClose {\n    // Firestore 연결 종료\n    listener.remove()\n  }\n}\n```\n\n'awaitClose' 블록은 수집기가 수집을 멈출 때마다 실행됩니다. 이를 사용하여 원격 데이터베이스의 리스너를 등록 해제합니다.\n\n우리의 더 높은 수준의 코드를 수정할 필요는 없습니다: 우리는 여전히 레시피 4의 문서 플로우 수집을 위해 documentFlow.collect를 호출합니다. 모든 것이 요구될 때 필요한대로 모두 종료되도록 보장하는 데 필요한 다른 작업은 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 레시피 6: SharedFlow 및 여러 수집기\n\n알고 계세요. callbackFlow 람다의 코드는 수집기가 수집을 시작하는 즉시 실행됩니다. 즉, 동시에 100개의 수집기가 작동하는 경우 Firestore로부터 100개의 연결이 열리게 됩니다. 한 개로도 충분히 해결할 수 있는 상황에서 매우 비효율적입니다.\n\n실제로 우리가 원하는 것은 여러 수집기를 사용할 수 있는 flow 입니다. 이 flow는 첫 번째 수집기가 데이터 수집을 시작할 때 Firestore 연결을 시작하고, 마지막 수집기가 멈출 때 해당 연결을 종료해야 합니다. 해당 시간 사이에 도착하는 다른 수집기는 새로운 Firestore 연결을 열지 않고 데이터의 사본을 받아야 합니다.\n\n다시 말해, flow의 지속적인 이벤트와 개별 수집기의 도착/사라짐 간의 연계를 어느 정도 분리하고자 합니다. 더 이상 냉각된 flow를 사용하고 싶지 않으며, hot flow를 원합니다. hot flow의 수집기를 구독자(subscriber)라고 합니다 — 이러한 언어의 약간의 변경은 flow가 수집자와 독립적으로 계속되는 사실을 강조하기 위한 것입니다. 구독자는 단지 \"확인\"하는 역할을 하며, flow를 운전하는 것이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 필요한 특정 종류의 핫 플로우는 SharedFlow입니다. SharedFlow는 데이터를 여러 구독자에게 방송하는 데 사용됩니다. 예를 들어 데이터를 SharedFlow 컨베이어 벨트에로드하는 코루틴이 여기에 있습니다.\n\n해당 코루틴이 실행중인 한 데이터는 컨베이어 벨트를 따라 이동합니다. 누군가 데이터를 수집하고 있든 상관없습니다.\n\n플로우가 흐르기 시작한 정확한 시점에 구독하면 순차적으로 0, 1, 2, 3, 4...가 출력됩니다. 그러나 몇 초 후에 수집을 시작하면 처음 몇 번의 에미션이 놓치고 7, 8, 9, 10, 11...이 출력됩니다. 이것은 플로우가 수집을 시작하기 전에 이미 흐르기 시작했음을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 레시피 7: 차가운 플로우를 공유해서 뜨겁게 만들기\n\n`shareIn()` 함수는 차가운 플로우를 가져와서 뜨겁게 만드는 데 사용됩니다. 즉, 이 함수는 코루틴을 시작하여 차가운 플로우를 수집하고 받은 모든 것을 구독자에게 다시 방송합니다. 구독자의 수는 0을 포함하여 제한이 없을 수 있습니다.\n\n다음은 `shareIn()` 함수의 정의입니다:\n\n```js\nfun \u003cT\u003e Flow\u003cT\u003e.shareIn(\n    scope: CoroutineScope, \n    started: SharingStarted, \n    replay: Int = 0\n): SharedFlow\u003cT\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 Android Activity는 SharingStarted.WhileSubscribed()와 stopTimeoutMillis를 사용하는 예시입니다. 액티비티는 장치가 회전될 때 종료되고 다시 시작되기 때문에 해당 프로세스 중 구독자는 몇 밀리초 동안 사라집니다. 이를 방지하기 위해 코드 플로우를 즉시 종료하고 다시 시작하지 않도록하기 위해 shareIn의 coroutine은 5000밀리초 동안 유지됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, replay 매개변수를 사용하여 구독자가 처음 구독할 때 현재 및 이전 값도 받을 수 있습니다.\n\n# 요약하면...\n\n- suspendCoroutine을 사용하여 비동기 단일 호출 콜백을 일시 중단 함수로 변환할 수 있습니다.\n- 다중 호출 콜백이 있는 경우 플로우가 필요합니다. callbackFlow를 사용하여 다중 호출 콜백을 플로우로 변환할 수 있습니다.\n- callbackFlow에서 생성된 것과 같은 Cold flows는 각 수집기에 대해 별도로 실행됩니다.\n- Hot flows는 수집기(구독자라고도 불림)와 독립적으로 실행됩니다.\n- SharedFlow와 같은 Hot flows 예는 여러 구독자에게 배출을 전파하는 SharedFlow입니다. cold flow를 sharedIn()를 사용하여 SharedFlow로 변환할 수 있습니다.\n\n도움이 되었기를 바랍니다. 모든 의견을 환영합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코틀린에서의 비동기 처리는 매우 넓은 주제입니다. 그 중에서도 특히 플로우(Flow)는 다양한 기능이 있습니다. 이에 대해 특정 소주제에 초점을 맞춘 더 많은 기사를 쓸 예정이니, 댓글이나 LinkedIn에서 어떤 내용이 도움이 될지 알려주세요.\n\n* Firestore 팬 여러분을 위해 말하자면, kotlinx-coroutines-play-services 라이브러리의 await()을 사용하여 이 특정 콜백을 중지할 수 있는 작업으로 바꿀 수 있다는 사실을 지적할 것입니다. 맞아요, 당연히 맞습니다. 하지만 이렇게 멋진 예제를 볼 수 없을 테지요? 🙃\n\n** Firebase는 실제로 그것 이상으로 똑똑하며, 여러 연결을 열지 않도록 합니다. 위를 참조하세요.\n\n톰 콜빈(Tom Colvin)은 안드로이드의 Google 개발 전문가로, 20년간 소프트웨어 아키텍처를 설계해왔습니다. 그는 모바일 앱 전문가인 Apptaura의 공동 창업자이자 CTO이며, 컨설팅을 통해 사용 가능합니다.","ogImage":{"url":"/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png"},"coverImage":"/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png","tag":["Tech"],"readingTime":8},{"title":"플러터 애플리케이션에서 보안 강화하기","description":"","date":"2024-05-18 17:10","slug":"2024-05-18-IncreasesecurityinyourFlutterapplications","content":"\n\n\n![보안 강화하기](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png)\n\n현재의 디지털 세계에서 애플리케이션 보안은 절대적인 우선 순위입니다. 견고하고 안전한 Flutter 앱을 개발하는 것은 사용자 데이터를 보호하고 제품에 대한 신뢰를 유지하는 데 중요합니다. Flutter 애플리케이션 보안 여정을 시작하는 경우, 제 이전 기사를 읽어 보시기를 권장합니다. 해당 기사에서는 Gray Box 모드에서 응용 프로그램의 보안을 보장하기 위한 필수적인 실천 방법을 탐구했습니다(기사 링크).\n\n# 보안 분석: 주요 결론\n\nFlutter 애플리케이션의 보안 평가 중에 시장 경험을 토대로 가능한 취약점을 찾을 수 있는 여러 단계를 식별했습니다. 아래에서 자세히 이야기하도록 하겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 인증 검토\n\n애플리케이션에서 사용되는 인증 메커니즘을 조사합니다. 인증 중 강력한 보안 메커니즘의 부재로 사용자 토큰에 민감한 데이터가 평문으로 포함되는 문제가 발생했다고 발견했습니다. 명확히 말하자면, JWT 토큰은 올바른 방식으로 발급되지 않으면 복호화될 수 있습니다. jwt.io 웹사이트에서는 토큰을 붙여넣으면 모든 내부 데이터를 제시해줍니다.\n\n![이미지1](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_1.png)\n\n![이미지2](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFigure 1에서는 웹 사이트에 추가된 JWT 토큰을 볼 수 있고, Figure 2에서는 분해된 데이터가 나타납니다. 이 토큰을 해독하는 데 도움이 되는 보안 키의 사용 방식을 강조할 가치가 있습니다. 이 키는 서버만 사용하여 컴파일하고 앱-클라이언트가 분해하는 데 사용됩니다. Figure 3에 표시된 대로입니다. \n\n![Image](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_3.png)\n\n## 액세스 제어의 평가와 문제 해결 방지\n\n또 다른 중요한 점은 프론트엔드의 액세스 제어이며, 여러 중요한 결함을 발견할 수 있는데, 애플리케이션이 안전하지 않은 기기에서 액세스되도록 허용합니다. 즉, 탈옥 또는 루팅된 것으로 간주되는 특정 기기에서 허용됩니다.\n이러한 기기는 너무 허용되어 있어 일반적인 운영 체제에서 적용된 보안 제약 사항 없이 작업을 수행하고 응용 프로그램을 설치할 수 있는 것을 의미합니다. 이러한 환경에서는 앱 보안 메커니즘이 쉽게 우회될 수 있어 민감한 데이터 및 중요한 기능이 잠재적인 공격자에게 노출될 수 있습니다. 이는 미약한 기기로부터의 액세스를 차단하고 탐지하기 위해 프론트엔드에 보다 엄격한 보안 제어를 구현해야 함을 강조합니다.\nFlutter에서 액세스 제어 결함을 극복하고 안전하지 않은 기기에서 애플리케이션을 보호하기 위해 여러 전략을 채택할 수 있습니다. 이 기기들을 감지하는 것이 중요합니다. Flutter에는 기기의 탈옥 또는 루팅 여부를 확인하는 데 도움이 되는 특정 라이브러리가 있습니다. 탈옥 또는 루팅된 기기를 감지하면 사용자에게 경고 메시지를 표시하고 액세스를 차단하여 앱이 작동하지 않도록 할 수 있습니다.\n또 다른 중요한 조치는 애플리케이션이 실행되는 환경의 무결성을 확인하는 것입니다. 이는 에뮬레이터를 감지하고 응용프로그램 바이너리가 변경되지 않았는지 확인하는 것을 포함할 수 있습니다. 이를 위해 디지털 서명 및 체크섬 확인 기술을 사용하여 애플리케이션 코드가 변경되지 않도록 보장할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 로컬에 저장된 모든 민감한 데이터를 암호화하는 것이 중요합니다. 안전한 암호화 라이브러리를 사용하면 데이터가 평문으로 저장되지 않아 기기가 침해당해도 민감한 정보를 보호할 수 있습니다. 예를 들어, flutter_secure_storage 패키지는 Flutter에서 데이터를 안전하게 암호화하여 저장하는 방법을 제공합니다.\n\n마지막으로, 엄격한 서버 측 보안 정책을 시행하는 것이 중요합니다. 서버가 클라이언트의 확인이나 조치와는 독립적으로 모든 요청을 유효성을 검사하도록 하는 것이 필수적입니다. 서버는 설정된 보안 기준을 충족하지 않는 요청을 거부해야 하며, 가능한 공격에 대비한 추가적인 보호층을 추가해야 합니다.\n\n## 방지 방탈림 메커니즘의 실패\n\n또 다른 중요한 점은 안드로이드 애플리케이션을 디컴파일할 때 소스 코드를 변경하고 애플리케이션을 다시 컴파일할 수 있는지 확인하는 것입니다. APKTOOL과 같은 도구를 사용하여 APK를 디컴파일하고 획득한 Java 코드를 수정할 수 있습니다. 이 과정 이후에 텍스트 편집기인 Sublime Text와 같은 도구를 사용하여 변수를 변경할 수 있었습니다. 코드를 변경한 후에는 같은 APKTOOL을 사용하여 애플리케이션을 다시 컴파일하고 서명할 수 있었습니다. 이러한 프로세스가 완료된 후 수정된 소스 코드가 재컴파일된 애플리케이션에 적용되었는지 확인할 수 있습니다. \n\n이 취약점은 공격자가 역공학을 통해 애플리케이션의 내부 작업을 이해할 수 있게 하여 보안 메커니즘에 대한 공격을 개발할 수 있는 것을 의미합니다. 공격자는 왓츠앱이나 유튜브와 같은 앱에서 현재 매우 일반적인 사용자가 보낸 메시지를 삭제하지 못하도록 막거나 광고를 표시하는 등의 미인증된 새로운 기능을 추가할 수 있으며, 데이터 유출, 회사의 평판 및 이미지 훼손, 사기까지 발생할 수 있습니다. \n\n이러한 위험을 완화하기 위해 응용 프로그램이 컴파일 중에 수행한 코드 변경을 런타임에서 감지할 수 있어야 합니다. 응용 프로그램은 침해된 환경을 식별하고 서버에 위반 사항을 보고하거나 응용 프로그램을 종료함으로써 적절히 대응해야 합니다. 이러한 조치를 구현하는 것은 방탈림 시도에 대한 응용 프로그램의 보호와 사용자 데이터의 무결성 및 보안을 보장하는 데 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제까지 찾아낸 몇 가지 포인트들이 있어요. Flutter 애플리케이션에서 보안에 대해 더 알아보기를 권유합니다. 제공되는 자원을 활용하고 사이버보안 워크샵, 강좌 및 포럼에 참여해보세요. 보안은 공동 책임이며, 디지털 세계의 계속 변화하는 도전에 대비하기 위해 우리 모두가 교육받고 준비되어야 합니다. \n기억하세요, 보안은 목적지가 아니라 계속되는 여정입니다. 함께 하면 Flutter 앱을 모든 사용자들을 위해 더 안전하고 안전하게 만들 수 있습니다. \n공부하고 배우고, 애플리케이션을 통해 더 안전한 디지털 미래를 만들어 봅시다.\n\n도움이 되었나요? 커피 사주시겠어요?\n\n저를 팔로우해주세요.\n\n- Linkedin: raphaelkennedy \n- Youtube: raphaelpontes","ogImage":{"url":"/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png"},"coverImage":"/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png","tag":["Tech"],"readingTime":4},{"title":"응용 프로그램 아키텍처 데이터 레이어","description":"","date":"2024-05-18 17:09","slug":"2024-05-18-AppArchitectureDatalayer","content":"\n\n\n![AppArchitectureDatalayer_0](/assets/img/2024-05-18-AppArchitectureDatalayer_0.png)\n\n이전 글에서는 도메인 레이어를 안정적이고 플랫폼 독립적인 레이어로 다루었습니다. 오늘은 데이터 레이어의 목적을 다루겠습니다. 함께 알아봅시다.\n\n![AppArchitectureDatalayer_1](/assets/img/2024-05-18-AppArchitectureDatalayer_1.png)\n\n데이터 레이어는 앱의 나머지 부분에 데이터를 노출하는 역할을 합니다. 다양한 데이터 소스를 관리하고 그들 사이의 충돌을 처리합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 저장소\n\n데이터 레이어는 Repository로 이루어져 있습니다. 이전 챕터에서 언급했듯이 도메인 레이어에 대해:\n\n데이터 레이어는 도메인 레이어의 저장소를 구현한 것입니다. Repository 클래스는 앱에서 처리하는 각기 다른 유형의 데이터를 나타내어야 합니다. 예를 들어:\n\n## 네이밍 규칙\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레포지토리 클래스는 담당하는 데이터를 따라 이름이 지어집니다.\n\n데이터 유형 + DataRepository와 같은 형식을 따릅니다.\n\n예를 들어 TicketRepository 인터페이스가 있으면 충돌을 피하기 위해 구현체는 TicketDataRepository로 지정됩니다.\n\n## 데이터 소스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레포지토리는 다양한 데이터 소스를 관리합니다 (예: 로컬, 메모리, 네트워크). 이 작업을 담당하는 구성 요소는 DataSource입니다. 이는 데이터베이스, 네트워크, ShearedPreference, WorkManager 및 파일과 같은 데이터 소스와 레포지토리 사이의 추상화입니다.\n\n- 데이터 소스는 한 번에 하나의 데이터 소스와만 작업해야 합니다.\n- 데이터 소스는 데이터 레이어를 위해 비공개이어야 하며 레포지토리를 통해서만 접근해야 합니다.\n\n## 네이밍 규칙\n\n데이터 소스 클래스는 그들이 책임지는 데이터와 사용하는 소스를 기반으로 명명됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 유형 + 소스 유형 + DataSource.\n\n데이터 유형으로는 Remote 또는 Local을 사용하여 구현이 변경될 수 있으므로 더 일반적으로 설정하세요 (예: FaresLocalDataSource 또는 FaresRemoteDataSource). 소스가 중요한 경우를 위해 소스 유형을 사용하여 더 구체적으로 설명하세요 (예: FaresNetworkDataSource 또는 FaresFileDataSource).\n\n구현 세부 정보를 기반으로한 이름을 피하세요. 예를 들어, UserSQLiteDataSource와 같이 구현 세부 정보에 기반한 이름을 사용하지 마세요. 해당 데이터 소스를 사용하는 리포지토리는 데이터가 어떻게 저장되는지 알 필요가 없습니다. 이 규칙을 따르면 데이터 소스의 구현을 변경(예: SQLite에서 DataStore로 마이그레이션)하더라도 해당 소스를 호출하는 계층에 영향을 주지 않습니다.\n\nUserApi 인터페이스는 네트워크 API 클라이언트의 구현을 숨깁니다. Retrofit 또는 GraphQL이 인터페이스를 지원하는데 차이가 없습니다. 인터페이스에 의존함으로써 앱에서 API 구현을 교체할 수 있습니다. 또한 이러한 방식은 유연성을 제공하며 의존성을 쉽게 교체할 수 있도록 합니다. 예를 들어, 테스트에서 가짜 데이터 소스 구현을 주입할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 원본은 오류 발생 시 예외 처리를 하는 좋은 위치입니다. 애플리케이션에 데이터 원본과 관련된 예외를 노출시키지 말고 대신 애플리케이션이 처리할 수 있는 예외로 매핑해야 합니다. \n\n이전에 언급했던 대로, 리포지토리는 데이터 소스와 동시성을 관리하는 데 더 중점을 둔 것입니다.\n\n위의 예시에서 보듯이, 우리는 로컬 캐시를 관리하고 로컬 및 원격 데이터 소스의 우선순위를 설정하는 전략을 구현했습니다. 리포지토리는 상태를 가질 수 있으며 예를 들어 Mutex를 사용하여 다른 스레드에서 변경 가능한 변수에 대한 읽기 및 쓰기 액세스를 관리할 수 있습니다. 따라서 리포지토리의 수명주기에 대해 고려해야 합니다.\n\n## 수명주기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가능하다면 리포지토리를 무상태로 만들 것을 권장합니다. 동시에 싱글톤으로 유지하여(instance-duplication of data sources와 같은 버그를 피하기 위해 DI를 통해 관리) 안정성을 높일 수 있습니다. DataSource도 마찬가지로 싱글톤으로 만들고 캐시는 리포지토리에서 관리하는 것을 권장합니다.\n\n## 동시성\n\n리포지토리는 어떤 CoroutineDispatcher에서 작업을 실행할지 결정해야 하는 곳입니다. 서로 다른 유형의 작업을 서로 다른 디스패처(또는 쓰레드 풀)에서 실행하는 것이 좋은 실천입니다. IO 작업을 수행하는 경우 Dispatcher.IO를 사용하는 것이 좋습니다. 테스트하기 쉽도록 클래스 생성자를 통해 디스패처를 전달해야 합니다.\n\n# 모델\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 레이어에는 도메인 레이어에서 모델을 반영하는 데이터 모델이 있지만 표현이 다를 수 있습니다. 별도의 데이터 모델을 사용하면 전송 프로토콜에 맞게 사용자 정의할 수 있는 유연성을 제공합니다. 예를 들어, 서버와 클라이언트 간의 통신에 JSON 형식을 사용하고 일부 필드는 JSON 프로토콜에 더 적합한 다른 유형을 가질 수 있습니다. 도메인 모델을 DTO로 매핑하는 로직 및 그 반대는 Repository 클래스에 배치되어야 합니다.\n\n- 데이터 레이어는 도메인 모델만 노출하고 입력으로 사용해야 합니다.\n- 데이터 모델은 Parcelable 및 Serializable와 같은 플랫폼별 직렬화 방식을 구현할 수 있습니다.\n- 사전에 모델 클래스가 정의된 경우, 한 팀의 구성원이 기능의 다른 레이어에 개별적으로 작업할 수 있습니다.\n- 이 레이어에서 노출된 데이터는 변경할 수 없어야 합니다.\n\n## 명명 규칙\n\n모델 클래스는 책임을 지는 데이터 유형의 이름으로 지어집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 유형 + DTO.\n\n예를 들어: RyderDTO, FareDTO.\n\n# 패키지 규칙\n\n```js\ndata/\n├─ local/\n│ ├─ dto/\n│ │ ├─ FareDTO\n│ │ ├─ RyderDTO\n│ ├─ FaresLocalDataSource\n│ ├─ FaresRemoteDataSource\n├─ network/\n│ ├─ api/\n│ │ ├─ UserNetworkApi // UserApi 인터페이스의 Retrofit 구현\n│ ├─ dto/\n│ │ ├─ UserDTO\n│ ├─ UserRemoteDataSource // UserApi 인터페이스 포함\n├─ repository/\n│ ├─ FaresDataRepository\n│ ├─ RydersDataRepository\n│ ├─ TicketsDataRepository\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리\n\n데이터 레이어는 도메인 레이어에 정의된 리포지토리 구현을 중심으로 구축되었습니다. 이는 데이터의 다양한 소스를 관리하고 사용하는 방법에 대한 전략을 관리하는 역할을 합니다.\n\n다음 앱 아키텍처 주제에 대해서는 계속해서 확인해보세요. 그동안 레이어 간 데이터 매핑 방법에 대해 읽어볼 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-18-AppArchitectureDatalayer_0.png"},"coverImage":"/assets/img/2024-05-18-AppArchitectureDatalayer_0.png","tag":["Tech"],"readingTime":4},{"title":"제트팩 코파 서체에서 Window Insets 이해하기","description":"","date":"2024-05-18 17:07","slug":"2024-05-18-UnderstandingWindowInsetsinJetpackCompose","content":"\n\n\n![Image](/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png)\n\n# 인셋이란 무엇인가요?\n\n인셋은 상태 바, 네비게이션 바, 디스플레이 컷아웃(노치 또는 핀홀로 자주 불림), IME 키보드와 같은 시스템 UI 요소로 인해 화면에서 완전히 사용할 수 없는 영역을 가리킵니다.\n\n기본적으로, 우리 앱의 UI는 상태 바와 네비게이션 바와 같은 시스템 UI 내에 레이아웃되도록 제한됩니다. 이는 시스템 UI 요소가 앱의 콘텐츠를 가리지 않도록 보장합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그렇다면 왜 우리가 모습들에 대해 걱정해야 할까요?\n\n현대 스마트폰이 엣지 투 엣지 화면과 다양한 화면 비율을 맞이하면서, 인셋(insets) 관리가 중요도를 더욱 높이고 있습니다.\n\n본질적으로, 우리는 시스템 제어를 받는 인셋 패러다임에서 개발자들이 엣지 투 엣지 디스플레이를 활성화하거나 시스템 UI 요소 뒤로 그림을 그리며 인셋 관리를 직접 제어하는 방식으로 전환 중입니다!\n\n# 시작하는 방법은?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 초기 설정\n\n우리 앱이 콘텐츠를 그릴 영역을 완전히 제어하도록 설정해야 합니다. 이 설정을 하지 않으면 앱이 시스템 UI 뒤에 검정색이나 단색을 그리거나 소프트웨어 키보드와 동기화되지 않을 수 있습니다.\n\n- Activity onCreate에서 enableEdgeToEdge 함수를 호출합니다.\n\n이 호출은 우리 앱에 시스템 UI 뒤에 표시하도록 요청합니다. 그런 다음 앱은 해당 간격이 UI를 조정하는 데 어떻게 사용되는지를 제어합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n\n    enableEdgeToEdge()\n\n    setContent {\n        // 앱 내용을 여기에 추가합니다\n    }\n}\n```\n\n- Activity AndroidManifest.xml에서 android:windowSoftInputMode=\"adjustResize\"를 설정하세요.\n\n이 설정을 추가하면 앱이 소프트웨어 IME의 크기를 받아들일 수 있으며, 이를 사용하여 IME가 앱에서 나타나고 사라질 때 내용을 적절하게 패딩 및 정렬할 수 있습니다.\n\n```xml\n\u003cactivity\n  android:name=\".ui.MainActivity\"\n  android:label=\"@string/app_name\"\n  android:windowSoftInputMode=\"adjustResize\"\n  android:theme=\"@style/Theme.MyApplication\"\n  android:exported=\"true\"\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 앱이 현재 어떻게 보이는지 아래 코드를 통해 살펴봅시다:\n\n```js\nsetContent {\n    Box(\n        modifier = Modifier\n             .fillMaxSize()\n             .background(color = Color.DarkGray)\n       )\n}\n```\n\n![이미지](/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_1.png)\n\n컬러로 채워진 Box가 화면 전체를 채우고 시스템 바(상단 상태 바 및 하단 네비게이션 바) 뒤에 그려짐을 확인할 수 있습니다. 이것은 우리의 코드가 이제 시스템 UI 뒤에 그리는 능력을 갖추고 있고 이러한 영역을 스스로 제어할 수 있다는 것을 의미합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 여백 제어하기\n\n시스템 UI 뒤에 표시되고 모든 여백을 수동으로 처리하는 상태인 경우, Compose API를 사용하여 앱의 상호 작용 가능한 콘텐츠가 시스템 UI와 겹치지 않도록 할 수 있습니다.\n\n이러한 API는 또한 앱의 레이아웃을 여백 변경과 동기화시킵니다.\n\n조정할 수 있는 Composable 레이아웃을 조정하기 위해 Inset 유형을 사용하는 주요 방법은 패딩 수정자와 여백 크기 수정자가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패딩 수정자\n\n창 인셋을 패딩으로 적용하는 방법은 Modifier.windowInsetsPadding(windowInsets: WindowInsets)를 사용할 수 있습니다. 이는 Modifier.padding와 매우 유사하게 작동합니다.\n\nWindowInsets.systemBars, WindowInsets.statusBars, WindowInsets.navigationBars 등과 같은 몇 가지 내장된 창 인셋이 있습니다. 이를 사용하여 원하는 패딩을 제공할 수 있습니다.\n\n예를 들어 이전 코드에서 상태 바와 네비게이션 바를 제외하고 회색 상자를 그리고 싶다면, 다음과 같이 할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nsetContent {\n    Box(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(color = Color.LightGray)\n            .windowInsetsPadding(WindowInsets.systemBars)\n    ) {\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.DarkGray)\n        )\n    }\n}\n```\n\nModifier windowInsetsPadding(WindowInsets.systemBars)은 상단 상태 표시줄과 하단 네비게이션 바에 패딩을 추가하며, 이들은 이해를 돕기 위해 LightGray로 칠해졌습니다. 이로써 우리 앱은 다음과 같이 보일 것입니다:\n\n![이미지](/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_2.png)\n\n우리는 또한 windowInsetsPadding(WindowInsets.statusBars) 또는 windowInsetsPadding(WindowInsets.navigationBars)를 사용하여 이러한 Insets를 별도로 제어할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 일반적인 종류의 Insets에 대한 많은 내장 메소드도 있습니다. 예를 들어:\n\n- safeDrawingPadding(), windowInsetsPadding(WindowInsets.safeDrawing)에 해당하는 메소드\n- safeContentPadding(), windowInsetsPadding(WindowInsets.safeContent)에 해당하는 메소드\n- safeGesturesPadding(), windowInsetsPadding(WindowInsets.safeGestures)에 해당하는 메소드\n\nInset 크기 조정기\n\n이러한 조정기는 컴포넌트의 크기를 insets의 정확한 크기로 설정하는 데 도움을 줍니다. Spacer 크기를 설정하는 데 유용합니다.Inset 크기를 차지하면서 화면을 만들 때 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, Inset 크기 수정자를 사용하여 상태 표시줄과 내비게이션 바에 패딩을 제공하도록 마지막 코드를 다음과 같이 작성할 수 있습니다. 이렇게 하면 동일한 결과가 생성됩니다.\n\n ```js\nsetContent {\n    Column {\n        Spacer(\n            modifier = Modifier\n                .fillMaxWidth()\n                .background(color = Color.LightGray)\n                .windowInsetsTopHeight(WindowInsets.statusBars)\n        )\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.DarkGray)\n                .weight(1f)\n        )\n        Spacer(\n            modifier = Modifier\n                .fillMaxWidth()\n                .background(color = Color.LightGray)\n                .windowInsetsBottomHeight(WindowInsets.navigationBars)\n        )\n    }\n}\n```\n\n이전과 같이 DarkGrey Box에 Insets 패딩을 추가하는 대신, 상태 표시줄과 내비게이션 바의 정확한 크기를 차지하는 LightGray Spacer를 추가했습니다.\n\n## 키보드 IME와 함께 구성 요소 패딩 크기 조정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가끔 키보드 IME가 열려 있는지 닫혀 있는지에 따라 UI 컴포넌트에 동적 패딩을 적용하고 싶을 때가 있습니다. 좋은 사용 사례는 목록 맨 아래에 입력 필드를 추가하는 경우입니다.\n\n다음과 같은 코드를 고려해보세요:\n\n```js\nsetContent {\n    Column(\n        modifier = Modifier.fillMaxSize().systemBarsPadding()\n    ) {\n        LazyColumn(\n            modifier = Modifier.weight(1f),\n            reverseLayout = true\n        ) {\n            items(100) { index -\u003e\n                Text(text = \"Item $index\", modifier = Modifier.padding(16.dp).fillMaxWidth())\n            }\n        }\n\n        var textFieldValue by remember { mutableStateOf(TextFieldValue()) }\n\n        TextField(\n            modifier = Modifier.fillMaxWidth(),\n            value = textFieldValue,\n            onValueChange = { textFieldValue = it },\n            placeholder = {\n                Text(text = \"Type something here\")\n            }\n        )\n    }\n}\n```\n\n만약 TextField의 패딩을 처리하지 않는다면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Keyboard Opening](https://miro.medium.com/v2/resize:fit:600/1*8HIx9O4S3Lk3mpUJRqI21g.gif)\n\n키보드가 열릴 때 텍스트 필드가 화면 하단에 고정되어 있어서 사용자 경험이 그리 좋지 않음을 볼 수 있습니다.\n\n텍스트 필드 패딩을 조정한 후:\n\n위의 텍스트 필드에는 단순히 `imePadding()` 수정자를 추가하면 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 코드는 다음과 같이 보입니다:\n\n```js\n// 이전 코드와 동일\n\nTextField(\n    modifier = Modifier.fillMaxWidth().imePadding(), // IME 패딩 추가\n    value = textFieldValue,\n    onValueChange = { textFieldValue = it },\n    placeholder = {\n        Text(text = \"여기에 무언가를 입력하세요\")\n    }\n)\n```\n\n이제 TextField 패딩이 변경되며 또한 IME의 상태 변화와 함께 애니메이션되어 입력 필드가 키보드와 함께 이동하는 효과를 만듭니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:600/1*IQIdBM5ovhwMcHmJ0qCOZQ.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 스크롤할 때 키보드 IME를 애니메이션화하자:\n\n스크롤 컨테이너에 추가하는 실험적 API 수정자 imeNestedScroll()가 있습니다. 이 수정자를 스크롤 컨테이너에 추가하면 컨테이너의 맨 아랫부분으로 스크롤할 때 키보드가 애니메이션으로 열립니다.\n\n위 코드를 수정해서 LazyColumn에 이 수정자를 추가하면 다음과 같습니다:\n\n```js\n// 위 코드와 같음\n\nLazyColumn(\n    modifier = Modifier.weight(1f).imeNestedScroll(), // 수정자 추가\n    reverseLayout = true\n) {\n\n// 이전과 같은 코드\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 경험을 제공할 예정입니다:\n\n![image](https://miro.medium.com/v2/resize:fit:600/1*dciSCS0k29yCh1Z4lAM85A.gif)\n\n# 패딩 소비\n\n이제 이 시점에서 우리 마음 속에 몇 가지 질문이 떠오를 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 내부 삽입 패딩 수정자(예: safeDrawingPadding())를 고려할 때, Composable 계층 구조에서 이를 한 번만 적용해야 할까요? 한 번 이상 적용하면 어떻게 되나요? 부모에 적용한 다음에 하위 자식에 다시 적용하면 패딩이 두 번 추가될까요?\n\n내장된 삽입 패딩 수정자는 자동으로 적용된 인셋의 일부를 패딩으로 사용합니다. 구성 트리를 깊게 들어가면, 중첩된 삽입 패딩 수정자와 자식 Composable에 적용된 인셋 크기 조절 수정자는 외부 수정자에 의해 이미 소비(또는 적용 또는 고려)된 인셋의 일부를 알고 있어 해당 인셋을 다시 적용하지 않고 건너뛰어 중복 공간을 피합니다.\n\n이를 이해하기 위해 예시를 살펴봅시다:\n\n```js\nsetContent {\n    var textFieldValue by remember { mutableStateOf(TextFieldValue()) }\n    LazyColumn(\n        Modifier.windowInsetsPadding(WindowInsets.statusBars).imePadding()\n    ) {\n        items(count = 30) {\n            Text(\n                modifier = Modifier.fillMaxWidth().padding(16.dp),\n                text = \"Item $it\"\n            )\n        }\n        item {\n            TextField(\n                modifier = Modifier.fillMaxWidth().height(56.dp),\n                value = textFieldValue,\n                onValueChange = { textFieldValue = it },\n                placeholder = { Text(text = \"Type something here\") }\n            )\n        }\n        item {\n            Spacer(\n                Modifier.windowInsetsBottomHeight(\n                    WindowInsets.systemBars\n                )\n            )\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 LazyColumn에 긴 항목 목록을 표시합니다. 목록의 맨 아래에는 사용자 입력을 위한 TextField가 있고, 끝에는 창 간격 크기 수정자를 사용하여 하단 시스템 내비게이션 바에 공간을 제공하는 Spacer가 있습니다. 또한 LazyColumn에 imePadding이 적용되어 있습니다.\n\n여기서 키보드가 닫힌 경우 IME의 높이가 없어 imePadding() 수정자가 패딩을 적용하지 않습니다. 따라서 인셋이 사용되지 않고, 이 때 Spacer의 높이는 하단 시스템 바의 크기가 됩니다. 키보드가 열리면 IME 인셋이 IME의 크기에 맞도록 애니메이션화되며 imePadding() 수정자가 LazyColumn에 하단 패딩을 적용하기 시작합니다. 결과적으로 해당 인셋량도 \"소비\"하기 시작합니다.\n\n이제 이 시점에서 imePadding() 수정자에 의해 하단 시스템 바의 일부 여백이 이미 적용되어 Spacer의 높이가 감소하기 시작합니다. 어느 시점에서는 IME 패딩 크기가 하단 시스템 바의 크기를 초과하여 Spacer의 높이가 제로가 됩니다. 키보드가 닫히면 동일한 메커니즘이 반대로 발생합니다.\n\n이 동작은 모든 windowInsetsPadding 수정자 간의 통신을 통해 달성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드가 작동하는 방식을 확인해보세요:\n\n![Code](https://miro.medium.com/v2/resize:fit:600/1*8ZLXFWRuKcZXvPtRmjxPJQ.gif)\n\n또 다른 예시를 살펴보겠습니다:\n\n이 예시에서는 Modifier.consumedWindowInsets(insets: WindowInsets)를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 수정자는 Modifier.windowInsetsPadding과 같은 방식으로 패딩을 소비하기 위해 사용됩니다. 그러나 소비된 인셋을 패딩으로 적용하지 않습니다.\n\n다른 수정자인 Modifier.consumedWindowInsets(paddingValues: PaddingValues)은 임의의 PaddingValues를 소비합니다.\n\n인셋 패딩 수정자가 아닌 일반 Modifier.padding 또는 고정 높이 간격과 같은 다른 메커니즘으로 패딩 또는 간격을 제공할 때 자식에게 알리는 데 유용합니다.\n\n다음 코드를 참고하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nsetContent {\n    Scaffold { innerPadding -\u003e\n        // innerPadding에는 사용하고 적용할 인셋 정보가 포함되어 있습니다\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.LightGray)\n                .padding(innerPadding)\n        ) {\n            Box(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .background(color = Color.Red)\n                    .windowInsetsPadding(WindowInsets.safeDrawing)\n            ) {\n                Box(\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .background(color = Color.DarkGray)\n                )\n            }\n        }\n    }\n}\n```\n\n이 코드의 결과는 다음과 같이 보일 것입니다:\n\n\u003cimg src=\"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_3.png\" /\u003e\n\n우리는 이 결과물에 문제가 있는 것을 볼 수 있습니다. Scaffold 람다에서 얻은 innerPadding을 바깥 Box에 패딩으로 적용했지만, 내부 Box의 windowInsetsPadding(WindowInsets.safeDrawing)은 중복 패딩(빨간색으로 나타남)을 생성합니다. 즉, 어떤 이유로 인해 여기에서 인셋 소비가 발생하지 않았다는 의미입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 Scaffold는 우리가 사용하고 활용할 수 있는 insets를 매개변수 paddingValues로 제공합니다. Scaffold는 콘텐츠에 insets를 적용하지 않으며, 이 책임은 우리에게 있습니다.\n\n따라서 우리가 이중 패딩을 피하고 싶다면, consumeWindowInsets(innerPadding) 수정자를 사용하여 패딩을 직접 소비해야 합니다.\n\n다음은 업데이트된 코드를 고려해보세요:\n\n```js\nsetContent {\n    Scaffold { innerPadding -\u003e\n        // innerPadding은 사용하고 적용할 인셋 정보를 포함합니다\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.LightGray)\n                .padding(innerPadding)\n                // 이 인셋을 소비하여, 아래 계층에서 safeDrawing을 사용할 때 다시 적용되지 않도록 합니다\n                .consumeWindowInsets(innerPadding)\n        ) {\n              // 나머지 코드\n          }\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 내용을 한국어로 다음과 같이 번역하면 됩니다:\n\n이렇게 작성하면 됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_4.png\" /\u003e\n\n그러므로 innerPadding이 outer Box에 의해 소비되면 inner Box의 windowInsetsPadding(WindowInsets.safeDrawing)에 중복 패딩이 적용되지 않습니다.\n\n이로써 이 기사는 마칩니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글을 통해 많은 개발자들이 Insets의 필요성에 대해 이해하고, 효과적으로 활용하는 방법을 배울 것이라 확신합니다.\n\n모든 예시는 다음 저장소에서 확인할 수 있습니다: [https://github.com/pushpalroy/ComposeInsetsPlayground](https://github.com/pushpalroy/ComposeInsetsPlayground)\n\n팔로우 하기: @pushpalroy","ogImage":{"url":"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png","tag":["Tech"],"readingTime":12},{"title":"AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법","description":"","date":"2024-05-18 17:04","slug":"2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay","content":"\n\n\n![LLM](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png)\n\nLLM 어플리케이션은 OpenAI와 같은 타사 호스팅 LLM을 사용하도록 개발되었을 때 MLOps 오버헤드가 필요하지 않습니다. 이러한 컨테이너화된 LLM 파워드 앱 또는 마이크로서비스는 DevOps 관행을 따르며 배포할 수 있습니다. 본 문서에서는 우리의 LLM 앱을 AWS와 같은 클라우드 제공업체에 자동으로 배포하는 방법을 탐색해보겠습니다. LlamaIndex는 커뮤니티를 위한 준비된 RAGs 챗봇을 보유하고 있습니다. 우리는 샘플 앱으로 RAGs를 사용하겠습니다.\n\n# IaC Self-Service\n\nIaC는 Infrastructure as Code의 줄임말로 인프라 프로비저닝을 자동화하여 구성이 일관성 있고 반복 가능하게 보장합니다. IaC를 실행할 수 있는 여러 도구들이 있습니다. 본 문서에서는 Terraform을 중점으로 다룰 것인데, Terraform은 클라우드에 중립적인 특성을 가지고 있기 때문입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIaC self-service의 주요 목적은 개발자들이 더 많은 액세스, 제어 및 소유권을 통해 파이프라인에 대한 생산성을 향상시키는 데 도움을 주는 것입니다.\n\n관심 있으신 분들을 위해, 약 1년 전에 DevOps self-service 모델에 관한 5부작 시리즈를 작성했습니다. DevOps self-service 모델에 관련된 모든 측면에 대해 자세히 다루었습니다.\n\n# 고수준 배포 다이어그램\n\nAWS에 컨테이너화된 응용 프로그램을 배포하는 다양한 옵션이 있습니다. ECS Fargate는 몇 가지 좋은 이유로 눈에 띕니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컨테이너용 서버리스 컴퓨팅, 서버 관리 없이 가능\n- 확장성과 확장성 증가\n- 배포 간소화\n\n먼저 RAGs 앱을 위한 고수준 배포 다이어그램을 작성합니다.\n\n![image](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_1.png)\n\nAWS에 RAGs를 배포하려면 파이프라인이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파이프라인 개요\n\n먼저, 내가 만든 3-2-1 규칙을 기반으로 한 자가 서비스 파이프라인 아키텍처를 탐색해보겠습니다:\n\n- 3가지 유형의 소스 코드: Terraform 코드, 앱 소스 코드 및 GitHub Actions 워크플로 코드.\n- 2가지 유형의 파이프라인: 인프라 파이프라인 및 애플리케이션 파이프라인.\n- 1개의 파이프라인 통합 글루: GitHub Secrets 생성 자동화.\n\n![image](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 한번 자세히 살펴봅시다.\n\n# 인프라 파이프라인\n\n저희는 인프라 파이프라인에서 terraform init, terraform plan, terraform apply 등 테라폼의 핵심 기능을 사용합니다. 아래 다이어그램을 참조해주세요. 2023년 8월 테라폼의 라이센스 변경에도 불구하고, 테라폼의 핵심 기능은 여전히 오픈 소스로 유지됩니다.\n\nterraform init 이전에 몇 가지 단계를 추가합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 워크플로우 보안을 위한 Harden Runner\n- 클라우드 비용 관리를 위한 Infracost\n- 린트를 위한 TFLint\n- 정적 IaC 코드 분석을 위한 Checkov\n\n이러한 도구에 대한 자세한 내용은 파이프라인 보안 및 가드레일에 관한 제 논문을 확인해주세요.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_3.png)\n\n우리는 Terraform에서 IaC 코드를 처음부터 작성해야 할까요? 아닙니다. 잘 알려진 오픈 소스 Terraform 재사용 가능한 모듈인 terraform-aws-modules를 활용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Terraform AWS 모듈\n\nterraform-aws-modules은 AWS에서 리소스를 관리하기 위해 명시적으로 설계된 사전 제작, 재사용 가능한 오픈 소스 Terraform 모듈의 다양한 모음입니다. Anton Babenko가 이끄는 terraform-aws-modules는 지금까지 57개의 모듈을 보유하고 있습니다! 이러한 모듈은 AWS에서 인프라 프로비저닝을 간소화하고 자동화하며, 모범 사례를 표준화하고, 인프라 코드를 작성하는 데 덜 신경 쓰고 빠른 배포를 달성할 수 있도록 돕습니다.\n\nGCP의 경우 terraform-google-modules, Azure의 경우 Azure-Verified-Modules가 있습니다.\n\n자신만의 재사용 가능한 모듈을 작성할 수도 있지만, 이 오픈 소스 재사용 가능한 모듈은 커뮤니티에서 지원하고 테스트됩니다. 인프라 파이프라인 개발을 빠르게 시작하는 데 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 RAGs 앱을 위해, 새 AWS 계정에 배포할 예정이며, terraform-aws-modules에서 다음 모듈들을 최소한으로 선택할 것입니다. \"최소한\" 이라고 말한 이유는 프로젝트 요구에 따라 추가로 리소스를 이 스택에 추가할 수 있습니다. 예를 들어 인증/인가 등을 위한 리소스 등이 있습니다. 그러나 이 POC 데모 앱에서는 자가 서비스 모델을 보여주고 오픈소스 IaC 재사용 가능 모듈을 소개하기 위해 최소 요구 사항을 준수할 것입니다. 두 가지 재료를 숙지하면 프로젝트 요구에 따라 추가 리소스를 프로비저닝하기 위해 재사용 가능 모듈을 선택하실 수 있습니다.\n\n![링크](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_4.png)\n\n- terraform-aws-vpc: 새 VPC, 공용/개인 서브넷, 인터넷 게이트웨이, NAT 게이트웨이, 경로 테이블 등을 프로비저닝하는 네트워킹 모듈입니다.\n- terraform-aws-s3-bucket: ALB 로그용 S3 버킷.\n- terraform-aws-alb: ECS 클러스터용 응용 프로그램 로드 밸런서 (ALB).\n- terraform-aws-ecs: RAGs를 배포할 ECS 클러스터에 대한 Elastic Container Service (ECS) Fargate 인스턴스.\n- terraform-aws-ecr: 앱용 도커 이미지를 저장하는 Elastic Container Registry (ECR).\n\n## 구현 전 요구 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- AWS에서 OpenID Connect (OIDC) 구성: 우리는 GitHub Actions 워크플로를 사용하여 인프라 프로비저닝을 위한 Terraform 모듈을 시작할 것입니다. OIDC는 AWS 자격 증명을 GitHub 측에 저장하지 않고 GitHub Actions 워크플로가 AWS에 액세스할 수 있도록 합니다. GitHub에는 AWS에서 OIDC를 구성하는 방법에 대한 자세한 지침이 있습니다. 이 단계는 한 번만 AWS 계정당 수행하면 됩니다.\n- Terraform 원격 상태 관리: 인프라 상태는 Terraform 작업의 중요한 부분이며, 실제 세계 리소스를 구성에 매핑하고 메타데이터를 추적하여 대규모 인프라에서 성능을 향상시킵니다. Terraform 원격 상태를 사용하면 사용자가 인프라 상태를 원격 데이터 저장소에 저장하여 중앙 집중화, 보안, 일관성 및 기타 이점을 얻을 수 있습니다. 이 단계도 한 번만 AWS 계정당 수행하면 됩니다. 나는 원격 상태 관리를 위해 S3 버킷과 상태 잠금을 위한 DynamoDB를 통해 처리하는 Terraform 재사용 가능한 모듈을 개발했습니다. 소스 코드는 내 GitHub 리포지토리에 있습니다. 시작하려면 내 샘플 워크플로와 유사한 GitHub Actions 워크플로를 사용할 수 있습니다. GitHub Actions를 익숙하지 않은 경우 \"Application Pipelines\" 섹션을 참조하세요.\n\n## 단계 1: GitHub 환경 생성\n\nGitHub 환경은 시크릿/변수를 세 가지 레벨에서 저장할 수 있어서 파이프라인에서 인프라 프로비저닝 또는 애플리케이션 CI/CD 중에 시크릿/변수를 전달하여 파이프라인 작업을 돕는 중요한 역할을 합니다.\n\n우리의 RAGs 앱을 위해 dev라는 GitHub 환경을 만들고 애플리케이션 파이프라인을 위한 ROLE_TO_ASSUME과 인프라 파이프라인을 위한 TERRAFORM_ROLE_TO_ASSUME 두 환경 변수를 생성해보겠습니다. 이 때 값은 이미 상위 섹션의 사전 준비 지침을 따라 IAM 역할을 만들었다고 가정하고 각각의 IAM 역할 ARN으로 지정해주세요. 여기서 두 가지 다른 역할을 사용하는 이유는 서로 다른 권한을 할당할 수 있기 때문입니다. 참고로, \"Settings\" 탭을 보려면 레포지토리에서 관리자 권한이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_5.png\" /\u003e\n\n동일한 \"설정\" 탭 아래에서 우리는 저장소 수준에서 몇 가지 비밀을 생성합니다. 이는 동일한 앱에 대해 다른 환경에 적용할 수 있음을 의미합니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_6.png\" /\u003e\n\n- NPM_TOKEN: 이 토큰이 필요한 이유는 애플리케이션이 Terraform 재사용 모듈을 호출할 때 이러한 자격 증명을 전달하지 않기 때문입니다. Terraform 재사용 모듈을 호출하는 앱이 Terraform 재사용 모듈이 있는 저장소에 연결하려면 저장소 범위의 토큰이 필요합니다. 특히 저장소가 개인 저장소인 경우 이것은 매우 중요합니다.\n- PIPELINE_TOKEN: 이 토큰은 Terraform이 GitHub 제공자를 호출하여 ECS_CLUSTER, ECS_SERVICE 등과 같은 GitHub 시크릿/변수를 자동으로 생성하게 하는 데 필요합니다. Terraform이 프비저단할 리소스를 기반으GitHub 시크릿/변수 생성의 자동화는 인프라 파이프라인을 애플리케이션 파이프라인과 통합하여 인프라 제공과 애플리케이션의 CI/CD 사이를 완벽하게 이어줍니다. 이 토큰은 저장소 및 read:public_key 스코프를 가져야 합니다.\n- OPENAI_KEY: 여기에는 OpenAI API 키를 저장합니다. 여기에 비밀로 저장되면 소스 코드에 노출되지 않습니다. CI 파이프라인에 이 비밀을 검색하여 전달하는 방법은 \"애플리케이션 파이프라인\" 섹션에서 자세히 살펴볼 것입니다.\n- INFRACOST_API_KEY: Infracost의 API 키입니다. 이는 클라우드 비용 관리를 자동화하는 인프라 비용 관리 도구로 사용될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 2: 인프라 파이프라인 코드 추가\n\n마지막으로, 우리의 인프라 파이프라인 코드를 리포지토리에 추가해 봅시다. 아래 파일/폴더와 관련된 인프라 파이프라인을 확인해보세요. 샘플 코드는 내 리포지토리에서 확인할 수 있습니다. 이렇게 구성된 우리의 Terraform 코드가 왜 이런 구조를 갖는지에 대해 자세히 알아보려면 Terraform 프로젝트 구조에 대한 내 기사를 참고하세요.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_7.png)\n\nmain.tf 파일은 Terraform 재사용 가능 모듈을 위한 주요 래퍼입니다. 귀하의 스택에 따라 이 파일에서 한 개 이상의 재사용 가능 모듈을 호출할 수 있습니다. 우리의 RAGs 앱의 경우, 우리는 인프라를 프로비저닝하기 위해 terraform-aws-modules 섹션에서 언급된 다섯 개의 재사용 가능 모듈을 호출합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nterraform-aws-modules의 각 재사용 가능한 모듈에 대해 해당 모듈의 사용 패턴에 대한 예제 코드를 참조하십시오. 사용 사례에 따라 단순 또는 완전한 예제 중 하나를 선택하여 해당 재사용 가능한 모듈을 main.tf의 기반이로 사용할 수 있습니다.\n\n그런 다음, 샘플 예제 코드를 매개변수화하여 특정 환경의 terraform.tfvars 파일 아래 .env 폴더로 변수를 외부화합니다. 예를 들어, 프로덕션 환경의 CPU/메모리 값은 개발 환경에서 사용되는 값과 다를 가능성이 높습니다. 따라서 CPU/메모리는 매개변수화하기에 좋은 후보입니다.\n\n아래와 같이 ECS 프로비저닝을 위한 샘플 Terraform 코드의 주요 요소 몇 가지를 살펴보겠습니다.\n\n- Line 174는 우리가 재사용 가능한 모듈 terraform-aws-ecs를 호출하는 곳입니다.\n- Line 177 이후는 클러스터 이름과 같은 변수를 재사용 가능한 모듈로 전달하는 곳입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_8.png\" /\u003e\n\n귀하의 사용 사례에 따라, 비슷한 AWS 스택을 공유하는 많은 애플리케이션이 있다면 main.tf의 대부분 로직을 중앙 집중형 재사용 가능한 모듈 리포지토리로 이동하여 원래 terraform-aws-modules 위에 또 다른 추상화 레이어를 구현할 수 있습니다. 이 접근 방식은 IaC 코드의 추가 재사용성을 허용하여 호출자 리포지토리가 매개변수화를 위한 최소한의 IaC 코드를 갖도록 합니다. 제가 작성한 Terraform 프로젝트 구조에 대한 기사에서는 이와 같은 중앙 리포지토리가 조직 내에서 재사용 가능한 모듈을 보유하는 구현 방법을 자세히 설명하고 있습니다. 확인해보세요.\n\n## 단계 3: 인프라 파이프라인을 위한 GitHub Actions 워크플로우 추가\n\n테라폼 프로비저닝을 위한 재사용 가능한 GitHub Actions 워크플로우를 만들었습니다. 워크플로우 보안, 클라우드 비용 관리, IaC 린팅, 스캔 및 마지막으로 terraform init, plan, apply와 같은 단계를 포함하고 있습니다. 이는 샘플 워크플로우로, 귀하의 요구에 맞게 수정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 RAGs 리포지토리에서 .github/workflows 디렉토리 아래에 terraform-aws.yml을 추가했습니다. 이 워크플로우의 주요 로직은 아래 빨간색으로 강조된 부분입니다:\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_9.png)\n\n- permissions: GitHub Actions 워크플로우가 OIDC를 사용하여 AWS에 인증할 수 있도록 id-token: write를 명시하는 것이 중요합니다.\n- uses: 이 줄은 재사용 가능한 워크플로우를 호출하며, 동일한 로직을 다른 워크플로우 또는 다른 리포지토리로부터 중복으로 작성하는 것을 방지합니다.\n- secrets: inherit: 이 줄은 환경/리포지토리/조직 수준에서 구성된 secrets/변수를 다른 리포지토리의 재사용 가능한 워크플로우로 전달할 수 있게 합니다.\n\n## 단계 4: 인프라스트럭처 파이프라인 시작\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금, 모든 일이 순조롭게 진행 중이에요. RAGs 저장소에서 \"Terraform AWS 프로비저닝\" 워크플로를 트리거하여 인프라 파이프라인을 시작해 봅시다.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_10.png)\n\n이 워크플로는 저희 개발 환경에서 AWS 자원을 프로비저닝할 거에요. 완료되면 Terraform Apply 단계에서 나오는 결과를 주의 깊게 확인해 주세요. 아래 스크린샷을 참고해 주세요. 나중에 RAGs 앱을 실행할 때 alb_dns 값을 사용할 거에요. 이 값을 메모해 두세요.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS에 로그인하여 VPC 리소스 맵을 확인해 보세요. 아래 스크린샷을 참조하세요. 네트워킹 (VPC, 서브넷, 라우팅 테이블 등)가 성공적으로 프로비저닝되었습니다. 또한 새로운 ECS 클러스터, ECR, ALB가 준비되었는지 확인하세요.\n\n![AWS 스크린샷](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_12.png)\n\n# 애플리케이션 파이프라인 (CI/CD)\n\n이제 AWS에서 앱을 배포할 수 있는 인프라가 준비되었습니다. 새로 구성된 ECS 클러스터로 앱을 빌드하고 배포하는 것으로 넘어갑시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 다이어그램은 CI (Continuous Integration) 파이프라인의 주요 단계를 나열한 것입니다.\n\n![CI Pipeline](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_13.png)\n\n그리고 우리의 샘플 CD (Continuous Deployment) 파이프라인은 다음과 같습니다:\n\n![CD Pipeline](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 1: 앱을 컨테이너화하세요 (컨테이너화되어 있지 않은 경우)\n\n먼저 RAGs 리포지토리에 Dockerfile을 추가하여 코드를 Docker 이미지로 빌드하고 AWS의 새로 프로비저닝된 ECR에 푸시해야 합니다. 아래 예시 Dockerfile 스니펫을 참조해 주세요.\n\n```js\nFROM python:3.9-slim\n\nWORKDIR /app\nCOPY requirements.txt requirements.txt\nCOPY . .\n\nRUN pip install -r requirements.txt\n\nEXPOSE 8501\nCMD [\"streamlit\", \"run\", \"1_🏠_Home.py\"]\n```\n\n## 단계 2: CI/CD를 위한 GitHub Actions 워크플로우 추가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발 목적으로 CI/CD를 하나의 단일 워크플로에 통합할 수 있습니다. 그러나 실제로는 특히 고급 환경에서는 이미지 불변성을 보장하기 위해 CI/CD를 두 개의 다른 워크플로로 분리하는 것이 좋습니다. GitHub Actions 워크플로 오케스트레이션에 대해 더 자세히 확인하려면 제 GitHub Actions 워크플로 조정에 대한 글을 참조하세요.\n\nCI 및 CD를 처리하는 두 가지 재사용 가능한 GitHub Actions 워크플로를 만들었습니다:\n\n- python-build-image.yml: Python 앱을 위한 도커 이미지를 빌드합니다.\n- deploy-to-ecs.yml: 도커 이미지를 AWS ECS Fargate에 배포합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 이미지 빌드 워크플로우에서의 단계로, 워크플로우는 인프라 파이프라인의 단계 1에서 정의된 GitHub 리포지토리 시크릿을 통해 OpenAI API 키를 검색한 후, 해당 키를 .streamlit 디렉토리 아래의 secrets.toml 파일에 작성합니다. 시크릿 처리를 CI 파이프라인에 위임함으로써 API 키와 같은 시크릿을 관리할 때 걱정 없이 사용할 수 있습니다. API 키와 같은 시크릿을 소스 코드에 절대로 푸쉬하면 안 됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_15.png\" /\u003e\n\n## 단계 3: CI/CD 파이프라인 시작\n\n코드 푸시 또는 PR 생성/병합에 의해 CI/CD 파이프라인이 자동으로 트리거되는 것이 좋습니다. GitHub Actions의 주요 장점 중 하나는 GitHub 레포지토리와 원활하게 통합되어 있기 때문에 이와 같이 작동합니다. 워크플로우에서 샘플 트리거는 다음과 같이 정의할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\n\n이제 애플리케이션 파이프라인을 시작할 시간입니다. 도커 이미지를 빌드하고 ECS에 배포하기 위해 수동으로 실행하거나 코드를 푸시/PR합니다. 아래에 성공적인 CI/CD 워크플로우 실행을 확인하세요.\n\n![CI/CD Workflow](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_16.png)\n\n## 단계 4: RAGs 앱 시작하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 RAGs 앱을 시작할 시간이에요. 이제 AWS ECS Fargate에 성공적으로 배포되었어요. 이전에 Terraform Apply 단계에서 인프라 파이프라인의 출력을 기억하시나요? 그 URL을 입력하여 RAGs 앱을 시작해보세요. 잘 작동할 거예요!\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_17.png)\n\n# 제거 및 정리\n\n마지막으로, AWS 리소스를 제거하고 정리해야 해요. 우리의 Terraform GitHub Actions 워크플로 파일에는 제거를 위한 대체 플로우가 구축되어 있어요. 제거 워크플로우는 앱의 제거 브랜치를 생성하고 해당 브랜치를 선택하여 Terraform 워크플로우를 트리거함으로써만 실행될 수 있어요. 이와 같은 활동을 위해 별도의 제거 브랜치를 만드는 이유는 사용자가 제거 작업을 실수로 트리거하지 않도록 보호하는 추가적인 안전 장치를 제공하기 위함이에요. 아래 스크린샷을 보고 Terraform AWS 프로비저닝 워크플로우를 트리거하여 AWS 리소스를 제거해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_18.png\" /\u003e\n\n# 주요 end-to-end 구현 포인트\n\n저희의 파이프라인의 주요 end-to-end 구현 포인트를 GitHub 저장소, GitHub Actions 워크플로우 및 Terraform 코드에서 살펴봅시다. 다음 다이어그램은 코드부터 구성, 통합 지점까지의 end-to-end 흐름을 강조합니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_19.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n본 기사에서는 DevOps 셀프 서비스 모델을 사용하여 LlamaIndex의 RAGs 챗봇을 AWS ECS fargate에 배포하는 방법을 탐색했습니다. MLOps를 필요로 하지 않는 LLM 기반 앱의 경우, DevOps 셀프 서비스 모델을 사용하여 AWS와 같은 클라우드 제공업체에 배포하는 데 탁월하게 작동합니다.\n\n이 셀프 서비스 모델이 제공하는 파이프라인 프레임워크와 terraform-aws-modules와 같은 다양한 오픈 소스 IaC 재사용 모듈을 결합하면 프로젝트 요구 사항에 따라 재사용 가능한 모듈을 혼합하여 파이프라인에 대한 더 많은 액세스, 제어 및 소유권을 확보하여 생산성을 높일 수 있습니다.\n\n본 기사가 도움이 되었기를 바랍니다. 이 프레임워크의 완전한 소스 코드는 제 GitHub 저장소에 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- https://github.com/wenqiglantz/reusable-workflows-modules\n- https://github.com/wenqiglantz/rags\n\n코딩을 즐기세요!\n\n## 참고 자료:\n\n- terraform-aws-modules GitHub 저장소\n- 아마존 웹 서비스에서 OpenID Connect 구성\n- 개발 운영자동화(Self-Service)로 향하는 길: 5부작 시리즈\n- 개발 운영자동화(Self-Service) 중심의 파이프라인 통합\n- 개발 운영자동화(Self-Service) 중심의 파이프라인 보안 및 가드레일\n- 개발 운영자동화(Self-Service) 중심의 GitHub Actions 워크플로 오케스트레이션\n- 개발 운영자동화(Self-Service) 중심의 Terraform 프로젝트 구조\n- 개발 운영자동화(Self-Service) 파이프라인 아키텍처와 3-2-1 규칙\n- Infracost + Terraform + GitHub Actions = 클라우드 비용 관리 자동화","ogImage":{"url":"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png"},"coverImage":"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png","tag":["Tech"],"readingTime":13},{"title":"테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트","description":"","date":"2024-05-18 17:01","slug":"2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet","content":"\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png)\n\n# 목차\n\n- 목차\n- Terraform CLI 및 명령어 치트 시트\n  - 초기화:\n  - 구성 관리:\n  - 인프라 관리:\n  - 상태 관리:\n  - 워크스페이스:\n  - 로그:\n  - 로그 레벨 활성화 및 제어:\n  - 로그 파일 지정:\n  - 셸 명령으로 로그 캡처:\n  - 다른 유용한 명령어:\n  - 추가 팁:\n- 결론\n- 나에 대해\n- 참고 문헌\n\n# Terraform CLI 및 명령어 치트 시트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테라폼 명령어는 인프라를 자동으로 프로비저닝하고 관리합니다. 이를 통해 수동으로 구성 작업을 줄이고 시간을 절약하며 오류를 줄일 수 있습니다.\n\n테라폼은 인프라를 코드로 관리하기 위한 다양한 명령어를 제공합니다.\n\n아래는 자주 사용되는 명령어에 대한 빠른 참조 가이드입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 초기화:\n\n- terraform init: 플러그인을 다운로드하고 백엔드 구성을 수행하여 작업 디렉토리를 초기화합니다.\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_2.png)\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 구성 관리:\n\n- terraform fmt: Terraform 구성 파일을 가독성 있게 형식화합니다.\n- terraform validate: Terraform 구성 구문을 유효성 검사합니다.\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_4.png)\n\n## 인프라 관리:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- terraform plan: 인프라 변경에 대한 자세한 실행 계획을 생성합니다.\n- terraform apply: 계획된 인프라 변경을 계획에 따라 적용합니다.\n- terraform apply -auto-approve: 확인 프롬프트 없이 계획을 적용합니다 (주의하여 사용해주세요!).\n- terraform destroy: Terraform 구성에 따라 기존 인프라를 파괴합니다.\n- terraform destroy -auto-approve: 확인 없이 인프라를 파괴합니다 (주의하여 사용해주세요!).\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_5.png)\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_6.png)\n\n## 상태 관리:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- terraform state list: Terraform이 관리하는 모든 리소스를 상태 파일에서 나열합니다.\n- terraform state show: 상태 파일에서 특정 리소스의 세부 정보를 표시합니다.\n- terraform state rm: 리소스를 Terraform 상태에서 제거하지만 공급자에서 파괴하지는 않습니다.\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_7.png)\n\n더 많은 정보는 여기에서 확인할 수 있습니다:\n\n## Workspaces:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- terraform workspace new: 새 워크스페이스를 만듭니다.\n- terraform workspace select: 기존 워크스페이스를 선택합니다.\n- terraform workspace list: 사용 가능한 모든 워크스페이스를 나열합니다.\n\n## 로그:\n\n테라폼 자체에는 전통적인 방식으로 로그를 볼 수 있는 내장 명령어가 없습니다. 그러나 환경 변수를 사용하여 테라폼의 로깅 동작을 제어할 수 있습니다. 다음은 테라폼 로그를 관리하는 방법입니다:\n\n## 로그 레벨 활성화 및 제어하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 테라폼은 TF_LOG 환경 변수를 사용하여 로그의 상세 수준을 제어합니다. 이를 다음 수준 중 하나로 설정할 수 있습니다:\n- ERROR: 오직 오류만 기록합니다 (기본값)\n- WARN: 경고 및 오류를 기록합니다\n- INFO: 정보 메시지, 경고 및 오류를 기록합니다\n- DEBUG: 자세한 디버그 정보를 기록합니다\n- TRACE: 가장 상세한 추적 정보를 기록합니다 (불안정한 형식)\n- 예시 (디버그 로그를 활성화):\n\n```js\nexport TF_LOG=\"DEBUG\"\nterraform plan\n```\n\n## 로그 파일 지정하기:\n\n- TF_LOG_PATH 환경 변수를 사용하여 테라폼이 로그를 작성할 특정 파일을 정의합니다.\n- 예시 (로그를 “terraform.log”에 작성):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport TF_LOG_PATH=\"terraform.log\"\nterraform apply\n```\n\n## 셸 명령어로 로그 캡처하기:\n\n- 테라폼 명령어를 셸 기능과 결합하여 로그를 캡처하고 형식화할 수 있습니다:\n- 예시 (디버그 로그와 함께 플랜 출력 캡처):\n\n```js\nterraform plan -no-color 2\u003e\u00261 | tee plan.log\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_8.png)\n\n- 설명:\n  - no-color: 색이 없는 출력을 사용하여 해석을 쉽게 할 수 있습니다.\n  - 2\u003e\u00261: 표준 출력(stdout)과 표준 오류(stderr)를 다음 명령어로 리디렉션합니다.\n  - tee plan.log: \"plan.log\"이라는 파일을 생성하고 캡처한 출력을 해당 파일에 기록합니다.\n\n## 기타 유용한 명령어:\n\n- terraform get: Terraform 모듈을 다운로드하고 설치합니다. (프로젝트 내의 모듈에 대해서)\n- terraform providers: 구성된 제공자에 관한 정보를 표시합니다.\n- terraform output: Terraform 구성에서 출력 값들을 표시합니다.\n- terraform version: Terraform 버전 정보를 표시합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 추가 팁:\n\n- 자세한 도움말을 얻으려면 모든 명령어에 -help 플래그를 사용하세요 (예: terraform init -help).\n- 모든 명령어와 옵션에 대한 포괄적인 정보를 위해 공식 Terraform 문서를 참조하세요 https://developer.hashicorp.com/terraform/cli/commands.\n\n# 결론\n\nTerraform CLI를 숙달하고 중요한 명령어와 구성을 이해하면 인프라를 코드로 효율적으로 관리하고, 배포를 간소화하며, 확장 가능하고 재현 가능한 환경을 유지할 수 있습니다. 이는 인프라의 신뢰성과 민첩성을 향상시킬 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n감사합니다! 🙌🏻 구독하지 않고 CLAP 👏을 누르지 말고 잊지 마세요! 다음 기사에서 만나요.🤘\n\n# 저에 대해\n\n“안녕하세요! Joel O’Wembo입니다. AWS 인증 클라우드 아키텍트이자 백엔드 개발자이자 AWS 커뮤니티 빌더입니다. 저는 필리핀에 거주하고 있습니다 🇵🇭 클라우드 아키텍처, 데브옵스, 그리고 고가용성(HA) 원칙에 대한 깊은 이해력을 바탕으로 강력한 전문성을 제공합니다. 제 지식을 활용하여 고가용성을 갖춘 견고하고 확장 가능한 클라우드 응용프로그램을 효율적인 기업 배포를 위해 오픈 소스 도구를 사용하여 만듭니다.”\n\n저자(Joel O. Wembo)에 대한 더 많은 정보는 방문하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n링크:\n\n- Linkedin: [https://www.linkedin.com/in/joelotepawembo/](https://www.linkedin.com/in/joelotepawembo/)\n- 웹사이트: [https://joelwembo.com](https://joelwembo.com)\n- 트위터: [https://twitter.com/joelwembo1](https://twitter.com/joelwembo1)\n- GitHub: [https://github.com/joelwembo](https://github.com/joelwembo)\n- 포트폴리오: [joelwembo.github.io](joelwembo.github.io)\n- Patreon: [https://www.patreon.com/joelwembo](https://www.patreon.com/joelwembo)\n\n# 참고 문헌","ogImage":{"url":"/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png"},"coverImage":"/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png","tag":["Tech"],"readingTime":5},{"title":" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로","description":"","date":"2024-05-18 16:59","slug":"2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible","content":"\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png\" /\u003e\n\n쿠버네티스에서 MERN 웹 애플리케이션을 위한 완벽한 CI/CD 파이프라인을 알아보고 테라폼을 GitHub Actions와 통합하여 인프라 프로비저닝 및 관리를 자동화합니다. AWS EC2 구성, Kubernetes (K3s) 설치 및 EC2에 풀 스택 MERN 프로젝트를 배포하는 데 Ansible을 사용합니다.\n\n# 🛠️사전 요구 사항\n\n- 필요한 권한을 갖춘 AWS 계정\n- 전체 스택 응용 프로그램(MERN)을 컨테이너화\n- HCP Terraform, GitHub 및 Docker Hub 계정\n- AWS 클라우드의 기본 지식\n- DNS 편집 권한이 있는 도메인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 조금 길어요. 그래서 마지막 단계로 따라와서 테라폼을 사용해 쿠버네티스에 MERN 앱용 엔드투엔드 CI/CD 파이프라인을 구축하는 방법을 배우시면 좋겠네요. GitHub Actions와 Ansible을 활용해요.\n\n이 프로젝트는 고급 수준의 프로젝트에요. 그래서 AWS, 테라폼, 앤서블, MERN 프로젝트, GitHub Actions의 기본 개념이 명확하다고 가정할게요. 기본 수준은 말하지 않아요. 그냥 프로젝트를 통합하고 구현했어요.\n\n이 기사는 세 가지 섹션으로 구성되어 있어요:\n\n섹션 1: GitHub Actions를 사용해 테라폼을 활용해 AWS 인프라 배포를 자동화하기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSection 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible을 사용하여 MERN 앱 배포하기.\n\nSection 3: GitHub Actions를 사용한 Kubernetes (K3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구성.\n\n그럼, 지금 가보자, 만약 이 글에 대한 질문이 있거나 도움이 필요하면 언제든지 연락해 주세요.\n\n# 📘Section 1: GitHub Actions를 이용하여 Terraform을 사용하여 AWS 인프라 자동화하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우선 GitHub에서 Terraform을 사용하여 AWS 인프라를 생성하기 위해 GitHub 액션을 이용해 git 저장소(terraform)를 복제하세요.\n\n단계 1: 로컬 머신에서 저장소를 복제합니다.\n\n```js\ngit clone https://github.com/bjnandi/terraform-ci-cd-aws.git\n```\n\n복제 후에는 VS Code 편집기의 Dev Container에서 해당 저장소를 엽니다. Dev Container를 사용하면 주요 머신으로부터 환경(Terraform)을 격리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계 2: HCP Terraform Cloud 설정하기\n우리가 생성할 GitHub Action은 HCP Terraform Cloud에 연결하여 구성을 계획하고 적용할 것입니다. 액션 워크플로우를 설정하기 전에, HCP Terraform Cloud에 로그인하고 조직 내에서 워크스페이스를 생성한 다음 AWS 자격 증명을 HCP Terraform 워크스페이스에 추가해야 합니다. 다음 단계를 따라주세요:\n\n조직 ` 워크스페이스 ` 변수\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_1.png)\n\n단계 3: API 토큰 생성하기\nHCP Terraform 사용자 API 토큰을 생성하세요. 이를 위해 HCP Terraform 사용자 설정의 토큰 페이지로 이동하세요. API 토큰 생성을 클릭한 다음 \"Generate token\"을 클릭하여 GitHub Actions 토큰을 설명란에 입력하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_2.png)\n\n**단계 4:** GitHub Secrets에 GitHub 저장소에 API 토큰을 설정합니다.\n자세한 내용은 GitHub Secrets에서 확인하실 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.\n\nGitHub ` 저장소 이름 ` 설정 ` 시크릿과 변수 ` 작업 ` 저장소 시크릿 ` 새 저장소 시크릿 :\n\nTF_API_TOKEN: HCP Terraform 사용자 설정에서 생성된 API 토큰입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_3.png\" /\u003e\n\n5단계: VS Code 편집기로 돌아가서 \"tf-infa-test\"라는 이름의 새 브랜치를 만듭니다.\n\n```js\ngit checkout -b 'tf-infa-test'\n```\n\n그런 다음 \"env/dev\" 디렉토리의 main.tf 파일을 엽니다. HCP Terraform에서 생성된 HCP Terraform 조직 및 워크스페이스 이름으로 \"organization\"과 \"workspaces\"를 설정한 다음 파일을 저장하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n  cloud {\n    organization = \"YOUR-ORGANIZATION-HERE\"\n\n    workspaces {\n      name = \"YOUR-WORKS-SPACE\"\n    }\n  }\n```\n\n그런 다음 \".github/workflows/\" 디렉토리에서 두 개의 워크플로 파일 (terraform-plan.yml 및 terraform-plan.yml)을 엽니다.\n\n- terraform-plan.yml\n- terraform-plan.yml\n\n“TF_CLOUD_ORGANIZATION” 및 “TF_WORKSPACE”를 HCP Terraform 조직 및 워크스페이스의 이름으로 업데이트하고 파일을 저장하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n6단계: 저희의 테라폼 파일 구조는 루트 작업 디렉토리가 \"env/dev\"인 블루프린트 모델입니다. 그래서 HCP 테라폼 클라우드에서 테라폼 작업 디렉토리에 \"env/dev\"를 추가했습니다.\n\n이를 위해 테라폼 클라우드로 이동하십시오:\n\nOrganizations ` Workspaces ` Workspace Name ` Setting ` Terraform Working Directory\n\n```js\nenv/dev\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 코드를 추가하세요.\n\n\n![image](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_4.png)\n\n\n마지막으로 \"Save settings\"를 클릭하세요.\n\n이제 GitHub Actions를 사용하여 인프라 프로비저닝을 준비했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**단계 7: 풀 리퀘스트 생성하기**\n이제 VS Code 편집기로 돌아가서 데모 테스트용 코드를 약간 수정한 후, 해당 코드를 GitHub \"tf-infa-test\" 브랜치에 커밋하고 푸시하세요. 그런 다음 GitHub에서 이 브랜치에 대한 풀 리퀘스트를 생성하세요.\n\n풀 리퀘스트를 생성한 후 GitHub 워크플로우(테라폼 플랜)를 실행하여 테라폼 플랜을 확인하세요.\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_5.png)\n\n**단계 8: 풀 리퀘스트 검토 및 병합**\n\"Terraform plan\"에 만족한다면, 'main' 브랜치에 '병합' 코드로 풀 리퀘스트를 닫은 다음 인프라 구축을 위해 워크플로우(테라폼 애플라이)를 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Step 9](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_6.png)\n\n9단계: 프로비전된 EC2 인스턴스 확인\n\n모든 리소스가 생성되었습니다.\n\n![Step 9](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 📘 섹션 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible를 사용하여 MERN 앱 배포\n\n인프라 프로비저닝이 완료되면 GitHub의 두 번째 git 저장소 (Ansible)로 이동하여 AWS EC2를 구성하고 Kubernetes (K3s)를 설치하고 Ansible를 사용하여 MERN 앱을 배포합니다.\n\n단계 1: 로컬 머신에서 저장소를 복제합니다.\n\n```js\ngit clone https://github.com/bjnandi/ansible-k3s-nginx-lb.git\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깃 저장소를 복제한 후, VS Code의 Dev Container에서 열어보세요. Dev Container는 환경(Ansible)을 메인 머신과 격리시킵니다.\n\n단계 2: SSH 키를 위해 \".ssh\" 폴더에 \"linux.pem\" 파일을 만드세요.\n\n```bash\nnano ~/.ssh/linux.pem\n```\n\n여기에 \"pem\" 파일 코드를 붙여넣고 파일을 저장하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nStep 3: \"linux.pem\" 파일의 권한을 설정하세요\n\n```js\nchmod 400 ~/.ssh/linux.pem\n```\n\nStep 4: 이제 디렉토리의 권한을 설정하세요. Dev Container는 모든 사용자에 대해 기본 권한으로 디렉토리를 마운트합니다.\n\n```js\nchmod 755 /workspaces/ansible-k3s-nginx-lb\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계 5: 이제 우리의 AWS EC2 IP 주소로 IP 주소를 업데이트하세요.\n\n- “hosts” 파일에서:\n\n- bastion (공용 IP)\n- k3s_nodes, additional_agent_nodes 및 nginx_lb (사설 IP)\n- nginx_lb(사설 IP)\n- ProxyCommand용 (공용 IP)\n\n```js\n[bastion]\nbastion ansible_host=34.195.33.137\n[bastion:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\n\n[k3s_nodes]\nmaster ansible_host=10.0.1.222\n[k3s_nodes:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\nansible_ssh_common_args='-o ProxyCommand=\"ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\n\n[additional_agent_nodes]\nworker1 ansible_host=10.0.2.244\nworker2 ansible_host=10.0.1.236\n[additional_agent_nodes:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\nansible_ssh_common_args='-o ProxyCommand=\" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\n\n[nginx_lb]\nnginx_lb ansible_host=10.0.5.187\n[nginx_lb:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\nansible_ssh_common_args='-o ProxyCommand=\" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. \"nginx.conf\" 파일에서:\n\n- 업스트림 클라이언트 및 API 서버\n\n```js\n   upstream client {\n        server 10.0.1.222:30001; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.2.244:30001; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.1.236:30001; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n    }\n\n    upstream apiserver {\n        server 10.0.1.222:30005;  # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.2.244:30005; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.1.236:30005; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n    }\n```\n\n3. 이제 \"project_vars\" 파일에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmaster_ip: 10.0.1.222\n```\n\n단계 6: Ansible 구성이 실행 준비 완료되었습니다\n\n- Makefile을 사용하여 모든 구성을 한 주석에서 실행하려면:\n\n```js\nmake run_ansible\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 하나씩 실행하려면:\n\n```js\n ansible-playbook -i hosts k3s_install.yaml\n\n ansible-playbook -i hosts k3s_mern_deploy.yaml\n\n ansible-playbook -i hosts config_nginx_lb.yaml\n\n ansible-playbook -i hosts config_bastion.yaml\n```\n\n이제, 모든 EC2를 구성하고 Kubernetes(k3s)를 설치한 다음 Kubernetes(k3s)에 MERN 앱을 배포합니다.\n\n단계 7: 이제 도메인 DNS 설정으로 이동하여 \"A\" 레코드를 업데이트합니다. 저희 도메인은 Squarespace에서 제공합니다. 그래서, Squarespace DNS 설정에서 이 도메인 DNS를 업데이트했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 앱에 대해 EC2 인스턴스(개발 로드밸런서)의 공개 IP로 두 개의 사용자 정의 \"A\" 레코드를 추가했어요.\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_8.png)\n\n단계 8: 이제 도메인을 사용하여 앱을 보여줄 차례에요.\n\n이 도메인(http://bjtechlife.com)에서 우리 앱을 봤어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Docker Hub repository 이미지가 있거나 수동으로 이미지를 빌드하여 Docker Hub에 푸시했다면, 먼저 출력에서 앱 UI를 확인할 수 있습니다. 그렇지 않은 경우 (섹션 3)를 완료한 다음 출력에서 앱 UI를 확인할 수 있습니다.\n\n\n![](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_9.png)\n\n\n# 📘세션 3: Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구축하기 (GitHub Actions 사용)\n\nEC2 구성, (k3s) 설치 및 앱 배포를 완료하고, AWS EC2 인스턴스에서 GitHub Actions를 사용하여 Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인을 만들기 위해 GitHub의 세 번째 git 저장소(MERN 프로젝트)로 이동하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스텝 1: 로컬 머신에서 저장소를 복제하세요\n\n```js\ngit clone https://github.com/bjnandi/ci-cd-pipeline-MERN-k3s.git\n```\n\n복제한 후, VS Code 에디터에서 열어주세요.\n\n\".github/workflows/\" 디렉토리에 두 개의 워크플로우 파일 (docker-ci 및 k3s-cd)이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- docker-ci.yml\n- k3s-cd.yml\n\n첫 번째 워크플로우 \"docker-ci.yml\" 파일은 이미지를 빌드하여 Docker Hub에 푸시하고, 다른 워크플로우 \"k3s-cd.yml\" 파일은 Kubernetes(k3s)에서 이미지를 업데이트합니다.\n\n단계 2: 이제 GitHub Secrets를 사용하여 시크릿을 채워넣어야합니다. GitHub 리포지토리에 추가할 수 있습니다. 자세한 정보는 GitHub Secrets에서 확인할 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.\n\nGithub `Repo Name` 설정 `Secrets and variables` 작업 `Repository Secrets` 새 리포지토리 시크릿 :\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEC2_HOST: 배스천 호스트 EC2 인스턴스의 공개 IP 주소는 대략 이와 같을 것입니다. \"34.195.33.137\".\n\nMASTER_NODE: k8s-instance-master EC2 인스턴스의 사설 IP 주소는 대략 이와 같을 것입니다. \"10.0.1.222\".\n\nEC2_USERNAME: EC2 인스턴스의 사용자 이름은 일반적으로 \"ubuntu\"입니다.\n\nSSH_PRIVATE_KEY: 인스턴스에 로그인하는 데 사용할 “.pem” 파일입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDOCKER_USERNAME: 이것은 도커 허브 계정 프로필로 이동하면 확인할 수 있는 도커 허브의 \"사용자 이름\"입니다. 도커 이미지를 도커 허브에 푸시하는 데 사용됩니다.\n\nDOCKER_PASSWORD: 이것은 도커 허브 계정의 \"비밀번호\"입니다.\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_10.png)\n\n단계 3: \"VS Code Editor\"로 돌아가서 데모 테스트를 위해 코드나 UI 파일을 편집하거나 작은 변경 사항을 수행한 후, 현재 파일에서 앱의 CI/CD 테스트를 위해 GitHub의 \"main\" 브랜치에 코드를 커밋하고 푸시하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고객님, `src` 폴더의 `components` 폴더 안에 있는 `Navbar.js` 파일을 수정해야 합니다.\n\n\"CRUD\" 텍스트를 \"CRUD test\"로 변경한 다음, 변경사항을 커밋하고 메인 브랜치에 푸시하세요.\n\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_11.png\" /\u003e\n\n\n빌드, 푸시, 그리고 배포하는 데 시간이 걸릴 수 있습니다. 나중에 앱 UI(http://bjtechlife.com)에 변경 사항이 표시되고 데이터를 삽입하는 것과 같이 제대로 작동하는 것을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_12.png\" /\u003e\n\n와우! 😎🚀 여기에는 우리가 코드에서 변경한 \"CRUD 테스트\"가 나와 있네요.\n\n저희 앱 UI에서 서로 다른 변경을 계속해서 적용하면 변경 사항을 볼 수 있어요.\n\n결과적으로, GitHub Actions를 사용하여 Kubernetes(k3s)에서 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 완료했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🌟축하합니다!!🌟, 저희가 GitHub Actions 및 Ansible을 사용하여 Kubernetes에서 Terraform을 활용하여 MERN 앱을 위한 End-to-End CI/CD 파이프라인을 성공적으로 구축했습니다.\n\n✨이제 AWS에서 리소스를 제거할 시간입니다. 그러므로, Terraform 저장소 VS Code 편집기 터미널(/workspaces/terraform-ci-cd-aws/env/dev)로 돌아가서 다음을 실행해주세요:\n\n```js\nterraform login\nterraform init\nterraform destroy -auto-approve\n```\n\n이렇게 함으로써 저와 함께 오래 집중해 주셔서 감사합니다. 앞으로 또 다른 주제로 포스팅하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# K8s #쿠버네티스 #k3s #테라폼 #앤서블 #MERN #풀스택 #도커 #웹애플리케이션 #컨테이너화 #데브옵스 #컨테이너화된앱 #EC2 #MERN스택 #도커화된웹앱 #MERN앱 #도커컨테이너 #CI/CD 파이프라인 #GitHub 액션 #제로다운타임 #CI/CD #자동화 #배포 #기술팁\n\n만일 쿠버네티스에서 테라폼을 사용하여 GitHub 액션 및 앤서블을 이용해 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 구축하는 데 문제가 발생한다면 언제든지 저에게 연락해 주세요. 최선을 다해 도와드리겠습니다. 감사합니다.\n\n# 평문으로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작가를 응원하고 팔로우를 눌러주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼도 방문해보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요","ogImage":{"url":"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png"},"coverImage":"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png","tag":["Tech"],"readingTime":12},{"title":"풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드","description":"","date":"2024-05-18 16:55","slug":"2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool","content":"\n\n![Pulumi vs Terraform](/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png)\n\n클라우드 네이티브 시대에는 인프라스트럭처 코드 (IaC)가 클라우드 인프라 관리의 표준이 되었습니다. Terraform은 거의 10년 동안 존재해왔고 경쟁사들이 출현하기 전까지 몇 년 동안 유일한 클라우드-비지니스 옵션이었습니다. 하지만 현재는 AWS CDK, CDK for Terraform과 상대적으로 새로운 Pulumi와 같이 다양한 선택지가 있습니다.\n\n하지만 더 많은 선택지가 있다는 것은 우리의 삶을 쉽게 만들어주지는 않습니다. 의사 결정 프로세스는 복잡할 수 있으며 모든 옵션을 조사하는 데 몇 일 또는 몇 주가 소요될 수 있습니다. 그러나 빠르게 변화하는 클라우드 네이티브/데브옵스 시대에는 그것만 하는 여유가 없는 사람들도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n걱정하지 마세요: 이 블로그에서는 Pulumi 대 Terraform을 깊이 파헤치고 (AWS CDK/CDK for Terraform의 메커니즘에도 약간 언급할 것입니다) 비교 차트, 의사 결정 트리, 팁 및 FAQ가 포함될 것입니다 (요약: 마지막 두 섹션으로 건너뛰세요) 작업에 적합한 올바른 도구를 선택하는 데 도움을 더할 것입니다.\n\n그럼, 더 이상 미루지 말고 지금 시작해 봅시다.\n\n# 1 Terraform\n\nIaC 도구에 대해 이야기하고 있으므로 Terraform을 무시할 수 없습니다. 가장 오래된 도구 중 하나입니다. 네, AWS CloudFormation과 같이 더 오랜 역사를 가진 클라우드별 솔루션이 있지만 클라우드에 독립적이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, Pulumi에 대해 언급하기 전에 먼저 Terraform을 살펴보겠습니다.\n\n## 1.1 Terraform의 간단한 역사\n\n2014년 HashiCorp에 의해 처음으로 출시된 Terraform은 2016년과 2017년에 많은 관심을 얻기 시작했는데, 이 기간 동안 거의 모든 데브옵스 엔지니어들이 열정적으로 사용하거나 적어도 그에 대해 이야기했습니다.\n\n비록 2021년에 v1.0이라는 공식 버전이 출시되었지만, 특히 2017년부터 2019년 사이의 v0.11 및 v0.12와 같은 이전 버전들은 이미 다양한 비즈니스 분야의 기업들에 의해 크게 받아들여지고 개발 환경 뿐만 아니라 프로덕션 환경에서도 널리 사용되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모든 역사는 Terraform을 신뢰할 수 있다는 것을 의미합니다. 오랜 기간 실제 제품 환경에서 테스트되었으며, 그와 같이 입증된 성적표가 있는 Terraform으로는 다른 대안들을 시도할 시간이 없거나 귀찮아도 잘못 갈 수 없습니다.\n\n## 1.2 Terraform의 내부 작업 원리\n\nTerraform을 더 잘 이해하기 위해 (그리고 사실은 모든 IaC 도구에 대해), 다음으로는 Terraform이 어떻게 작동하는지 살펴봅시다: 코어-플러그인 아키텍처.\n\n간단히 말해, 코어는 상태 머신입니다. 현재 인프라 상태를 선언적 코드로 정의된 원하는 상태와 비교하여, 인프라를 선언 적으로 정의된 상태로 가져 오기 위해 해당 변경/작업을 수행 할 수 있도록 계획하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 변경 또는 작업은 플러그인(또는 프로바이더라고도 불리며, 이 문맥에서는 같은 것을 가리키는 다른 용어일 뿐입니다)에 의해 수행됩니다. 코어는 특정 상태에서 무엇을 해야 하는지 플러그인과 소통합니다.\n\n요약하면, 코어는 상태를 관리하고 플러그인은 작업을 수행합니다: 이것이 모든 IaC 도구가 동작하는 기본적인 방식입니다. 상태를 관리해야 하며, 클라우드 인프라를 운영하는 데 필요한 작업을 수행해야 합니다.\n\n테라폼에 대해 언급할 가치가 있는 몇 가지 추가 정보는 대부분의 플러그인이 Golang으로 구현된다는 점입니다 (물론 테라폼의 코어-플러그인 프레임워크를 통해 다른 프로그래밍 언어로 작성된 플러그인을 사용할 수 있게 됩니다). 따라서 실제 CRUD 작업을 수행하기 위해 플러그인은 클라우드 Go SDK가 필요합니다.\n\n이 세부 정보가 약간 복잡해 보인다면 걱정하지 마세요. 우리는 테라폼 사용자이니까 (개발자/기여자가 아니라), 플러그인 구현에 대해 고민할 필요가 없습니다. 또한 우리는 Go 코드를 작성하는 게 아니라 HCL만 작성합니다. 우리는 HCL로 인프라를 정의하는데, 실제로 테라폼은 이를 구현하기 위해 Go 플러그인을 호출하도록 어떤 변환을 수행하고, 이 플러그인은 다시 클라우드 Go SDK를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1.3 Terraform HCL\n\n테라폼에서 인프라를 정의하는 것은 간단합니다. 구성 언어로 HCL (HashiCorp Configuration Language)을 사용하여 인프라를 정의합니다.\n\nAWS에서 S3 버킷을 생성하는 HCL 예제를 살펴보겠습니다:\n\n```js\nresource \"aws_s3_bucket\" \"example\" {\n  bucket = \"my-tf-test-bucket\"\n\n  tags = {\n    Name        = \"My bucket\"\n    Environment = \"Dev\"\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 구문을 아시는 분이라면 위 문법은 너무 낯설지 않을 것입니다. HCL은 블록과 속성이라는 두 가지 개념을 중심으로 구축된 것이 분명하며, 위 예시에서:\n\n- 전체 리소스 ...은 리소스를 정의하는 블록으로, 첫 번째 키워드가 나타냅니다.\n- aws_s3_bucket은 리소스의 유형입니다. AWS 공급자 문서를 참조하여 모든 지원되는 AWS 리소스 목록을 얻을 수 있습니다.\n- 예시 부분은 리소스의 이름입니다.\n- 블록 내에서 키-값 쌍은 해당 리소스의 속성 또는 인수입니다. 다시 한번, 공급자의 문서를 참조하여 지원되는 인수가 무엇인지, 필수적인지 등을 알아내야 합니다.\n\nHCL에 대한 학습 곡선이 존재하지만, 다른 프로그래밍 언어를 배우는 것만큼 가파르지는 않습니다. 왜냐하면 HCL은 실제 프로그래밍 언어가 아니라 구성 목적으로 사용되기 때문입니다. 이것은 당신의 철학적 성향에 따라 장단점이 될 수 있습니다:\n\n- 한편으로, HCL이 실제 프로그래밍 언어가 아니라 단순한 구성 언어이기 때문에 많은 이점이 있습니다: 기본적으로 키-값 쌍으로, 매우 사람이 읽기 편하고 쉽습니다.\n- 다른 한편으로, 단순성 때문에 반복문이나 분기와 같이 복잡한 작업을 쉽게 수행할 수 없습니다(특별한 구문을 사용하여 이를 구현할 수 있지만, 이는 파이썬과 같은 실제 프로그래밍 언어에서 `for ...` 또는 `if/else`를 작성하는 것만큼 간단하지는 않습니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 IaC 도구로서, Terraform은 다소 중간 정도의 학습 곡선과 제한 사항을 갖고 있습니다 (HCL 때문에 두 가지로 인해: 이를 배워야 하며, 이를 사용하여 인프라를 정의해야 합니다). 이러한 상황을 개선하기 위해 많은 다른 IaC 도구들이 등장했습니다. 계속해서 읽어보세요.\n\n# 2 Pulumi\n\n이전 섹션에서 언급했듯이, Terraform은 완벽하지 않습니다. 이 문제를 해결하기 위해 많은 도구들이 등장했는데, Pulumi는 그 중 가장 최근의 시도 중 하나입니다.\n\nPulumi가 무엇인가요? 간단히 말해, 이것은 Terraform과 마찬가지로 IaC 도구입니다. 그러나 Terraform이 특정 구문 (HCL)을 사용하는 반면, Pulumi는 거의 모든 프로그래밍 언어를 사용하여 인프라를 정의할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그렇다고 하면 너무나 부정확하고 크게 과장된 발언일 것입니다만, 단 하나의 문장으로 Pulumi가 무엇인지 알고 싶은 초보자를 위해 말하자면: Pulumi는 Python/Go/Java/Node.js 등에서 Terraform과 같은 기능을 하는 것이라고 말할 수 있습니다.\n\n## 2.1 Pulumi의 간단한 역사\n\nPulumi는 2018년에 처음 오픈소스로 공개되었으며, 이는 그리 새로운 것으로 보이지는 않지만, 현재 버전인 v3는 이전 버전과 비교했을 때 몇 가지 중요한 변경 사항을 갖고 있습니다. 2021년에 릴리스되었으며, 그 이후로 이전에 비해 많은 사람들이 Pulumi를 주목하기 시작했습니다. (믿지 못한다면 Google Trend에 물어보세요.)\n\n오늘날에는 Terraform과 비교했을 때, Google 검색에서 Pulumi에 대한 관심은 훨씬 적습니다. Pulumi의 블로그에 따르면, 2023년에는 고객 수가 2,000명 미만이었는데, 이는 Terraform보다 수십 배 적은 수치입니다. (인터넷의 여러 데이터 소스로부터 도출된 정보에 따르면)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서, 이것은 새로운 기술이고 널리 수용되지 않았습니다. 그럼에도 불구하고, Pulumi를 선택하는 이유는 무엇일까요? 그 이유는 바로 Pulumi의 가장 강력한 기능인 다국어 지원 때문입니다.\n\n## 2.2 Pulumi: 다국어 지원\n\nTerraform을 선택하면 HCL을 작성해야 합니다. 많은 사람들에게 이것은 부담일 수 있습니다.\n\n예를 들어, Go로 주로 프로그램을 작성하고 가끔 클라우드 인프라를 관리하는 백엔드 엔지니어들은 왜 Go로 인프라를 정의할 수 있는데 HCL을 배워야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프론트엔드/풀스택 엔지니어들이 JavaScript/TypeScript로 주로 쓰는 경우도 동일합니다. 이미 사용 중인 기술에 HCL을 더하는 것은 부담이 될 뿐만 아니라 기술 스택의 복잡성을 증가시킵니다. 기술 스택에 관해서는 대개 더 작을수록 더 나은 경우가 많습니다.\n\nPulumi에서는 다음 언어로 인프라를 정의할 수 있습니다:\n\n- TypeScript (Node.js)\n- Python\n- C#, VB, F# (.NET)\n- Go\n- Java\n- YAML\n\n예를 들어, 이전 섹션에서 언급된 것과 정확히 동일한 AWS S3 버킷을 Pulumi와 Python을 사용하여 생성하려면 간단히 다음과 같이 작성하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nimport pulumi\nimport pulumi_aws as aws\n\nbucket = aws.s3.Bucket(\"bucket\",\n    acl=\"private\",\n    tags={\n        \"Environment\": \"Dev\",\n        \"Name\": \"My bucket\",\n    })\n```\n\n아니면 파이썬이 어울리지 않는다면 TypeScript로 작성해 보고 싶을 수도 있어요:\n\n```js\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst bucket = new aws.s3.Bucket(\"bucket\", {\n    acl: \"private\",\n    tags: {\n        Environment: \"Dev\",\n        Name: \"My bucket\",\n    },\n})\n```\n\n재미있게 사용해보세요!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2.3 Pulumi의 내부 구조\n\n요약하자면, Pulumi는 Terraform과 마찬가지로 상기된 코어 플러그인 아키텍처를 가지고 작동합니다.\n\nTerraform과 마찬가지로 Pulumi도 내부적으로 클라우드 SDK 및 라이브러리를 사용합니다. Pulumi는 플러그인 자체가 여러 언어로 구현되어 있기 때문에 여러 언어를 지원합니다. 예를 들어, 여기서 Pulumi의 AWS 프로바이더를 살펴보면 다양한 언어로의 여러 구현체를 볼 수 있습니다. 이로 인해 파이썬으로 인프라를 정의할 때는 pulumi_aws를 aws로 가져오고, TypeScript로 한다면 Node.js용으로 완전히 다른 패키지인 “@pulumi/aws”를 사용합니다.\n\nAWS Cloud Development Kit (AWS CDK) 및 Terraform용 CDK (CDKTF)와 같이 많은 언어로 인프라 코드를 정의할 수 있는 다른 옵션이 있음을 언급할 가치가 있습니다. 그러나 기본적으로 AWS CDK와 CDKTF는 다른 방법으로 다중 언어 지원을 구현합니다: AWS CDK와 CDKTF는 JavaScript 클래스와 자연스럽게 상호 작용할 수 있도록 어떤 언어의 코드든 JavaScript 클래스와 상호 작용할 수 있게 하는 라이브러리 jsii에 의존합니다. 따라서 AWS CDK (CDKTF도 마찬가지)는 TypeScript 코드를 다양한 언어로 변환하여 다중 언어를 지원하는 데 jsii를 사용하지만, Pulumi는 그저 여러 언어로 작성된 프로바이더만을 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3 Pulumi vs. Terraform: 주요 유사점과 차이점\n\n## 3.1 Pulumi와 Terraform의 주요 유사점\n\n가장 큰 유사점은 작동 방식인 코어 플러그인 아키텍처입니다.\n\n먼저, 코어입니다. 혹은 다른 말로 표현하면, 실제로는 상태입니다. 둘 다 현재 인프라 및 코드로 정의된 내용을 기반으로 상태를 유지하기 위해 코어를 사용하여 계산할 수 있도록 하여 인프라를 정의된 상태로 가져오기 위한 작업 계획을 생성할 수 있습니다. 그리고 둘 다 상태를 로컬, S3 버킷, 또는 클라우드/SaaS 솔루션에 저장할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째로는 플러그인입니다. 이전에도 언급했듯이, 두 툴 모두 상태를 관리하고 변경을 수행하기 위해 핵심 플러그인 아키텍처를 사용합니다.\n\n## 3.2 Pulumi와 Terraform의 주요 차이점\n\n가장 큰 차이는 물론, 멀티 언어 지원입니다.\n\nTerraform은 HCL을 사용하는데, 이것은 완전한 프로그래밍 언어가 아니라 구성 언어에 불과합니다. 그러므로 본질적으로 다른 프로그래밍 언어만큼 많은 작업을 수행할 수 없습니다. 하지만 이전에 언급했듯이, 이것은 당신에게 좋은 점일 수 있는데, 읽기 쉽고 단순한 게 더 나을 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPulumi는 다양한 언어를 지원하며 이겪엔 가장 중요한 차이점 중 하나입니다. 어떤 이유로든 Python/Go/Java 또는 기타 주요 프로그래밍 언어로 인프라를 정의해야 하는 경우, Terraform와 Pulumi 사이에는 경쟁이 없습니다.\n\n언급할 가치가 있는 또 다른 차이점은 Pulumi를 사용하여 인프라 코드의 테스트 가능성입니다. Pulumi를 사용하면 프로그래밍 언어와 함께 제공되는 단위 테스트 및 기능 테스트와 도구의 이점을 누릴 수 있습니다. Terraform에서는 주로 통합 테스트로 수행할 수 있는 테스트 방법이 제한됩니다.\n\n물론 Terraform과 Pulumi 사이에는 다수의 세부적인 기능 차이가 있습니다 (놀랍게도 Pulumi 공식 문서에서는 한 둘보다 훨씬 많은 차이점을 찾을 수 있습니다). 그러나 어느 것도 실질적인 결정 요인이 되지는 않습니다. 예를 들어, 오픈 소스 라이선스나 상태의 기본 구성이 어디에 있는지는 아마도 귀하의 목록 상단에 있는 것이 아닐 것입니다.\n\n# Pulumi에 관한 4가지 오해\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 여러분이 이 블로그를 읽고 계시다면, 이겢이 Pulumi 대 Terraform에 관한 첫 번째 기사가 아닐 것입니다; 아마도 여러분은 상당한 조사를 하고 각각의 장단점을 많이 읽은 것 같습니다.\n\n하지만, 다른 많은 기사들에서 Pulumi에 대해 Terraform과 비교했을 때 가장 흔히 언급되는 몇 가지 단점은 사실 오해이며 더는 사실이 아닙니다. 저는 그것들을 다루어서 Pulumi에 대한 공정하고 정확한 견해를 얻을 수 있도록 하고자 합니다. 그것은 중요하기 때문에 별도의 장으로 다루어져야 한다고 생각합니다.\n\n## 4.1 오해 1: Pulumi 문서 부족\n\n이젠 사실이 아닙니다(시작했을 때는 그랬을지도 모릅니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPulumi는 설치 방법부터 시작하는 방법까지 매우 상세하고 단계별 설명서를 제공합니다. 더 깊이 알고 싶다면, Pulumi의 핵심 개념에 대한 훌륭한 섹션이 있습니다. 게다가 Pulumi에는 다수의 클라우드 제공업체에 대한 상세한 설명서와 예제가 있습니다.\n\n플러그인/제공자에 대해 특정 제공자(예: AWS) 또는 PagerDuty Pulumi 제공자와 같이 덜 인기 있는 제공자를 검색하고, Terraform의 문서와 비교해 보면 \"Pulumi 문서가 부족하다\"는 결론에 도달하지 않을 것입니다. 왜냐하면 사실이 아니기 때문이죠.\n\n## 4.2 오해 2: Pulumi 커뮤니티가 작다.\n\n이제 더 이상 사실이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n풀루미의 공식 블로그에 따르면, 이 회사는 2000명의 고객과 15만 명의 최종 사용자를 보유하고 있습니다. GitHub에 따르면, 주요 저장소 pulumi/pulumi만으로도 18.8k개 이상의 스타를 받았으며, 1.9k개의 이슈와 184개의 오픈된 풀 리퀘스트가 있습니다.\n\n어떤 지표를 보더라도, 커뮤니티 규모를 측정하는 기준에 상관없이 풀루미의 커뮤니티는 분명히 거대합니다. 테라폼보다는 작을 수 있지만, 절대적으로 말해 그 커뮤니티는 작다고 할 수 없습니다.\n\n## 4.3 오해 3: Pulumi는 모든 환경에 적합하지 않다\n\n다시 한 번, 이는 사실이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 사람들이 Pulumi가 더 최근에 나왔기 때문에 모든 분야에 적용되지 않는다고 결론 지을 것으로 생각할 수 있지만, 실제로는 그렇지 않습니다.\n\n프로그래밍 언어에 대해 이야기할 때, Pulumi는 사실 대부분의 주요 언어를 지원합니다.\n\n플러그인 및 프로바이더에 대해 이야기할 때, 새로운 도구가 존재 기간이 짧다는 이유로 플러그인이 적을 것으로 생각할 수 있지만, 현실은 그렇지 않습니다. Pulumi는 모든 주요 퍼블릭 클라우드 프로바이더를 지원합니다. 게다가, 클라우드 이외의 인프라(예: 특정 소프트웨어에서 팀 및 사용자 관리)를 관리할 때도 Terraform과 비슷한 범위를 갖추고 있습니다.\n\n예를 들어, 대기업에서 GitHub, PagerDuty, DataDog, Sentry 등을 관리하는 여러 개의 데브옵스 도구가 있을 수 있습니다. 아마도 이러한 도구들의 사용자/팀/권한을 IaC로 관리하고 싶을 수도 있습니다. 이 경우, 이 도구들의 플러그인을 검색하면 Pulumi가 모두 갖추고 있다는 놀라운 사실을 알게 될 것입니다. 이러한 플러그인은 널리 사용되지 않는 클라우드 관련 플러그인이더라도 Terraform과 마찬가지로 모두 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n말씀하신 대로, Pulumi/Terraform을 객관적으로 평가하고, \"문서가 부족하다\" 또는 \"커뮤니티가 작다\"는 어딘가에서 읽은 이유만으로 Pulumi를 부정적으로 평가하지 말고, 심지어 \"최신 버전은 보편성이 낮다\"고 생각하지 말아주셨으면 좋겠습니다.\n\n## 5. Pulumi 대 Terraform: 실제로 살펴보기\n\n이전 절에서는 Terraform과 Pulumi의 구문과 사용법을 설명하기 위해 코드 조각들을 제공했지만, 이들은 실세계에서 의미 있는 것을 나타내기에는 너무 간단하고 \"Hello World\" 수준이었습니다. 실세계에서는 일반적으로 사물이 기하급수적으로 커지기 때문에 코드를 간단하고 가독성 있게 유지하고 동시에 확장 가능하게 유지하는 것이 어렵습니다.\n\n다음으로, Pulumi 대 Terraform을 살펴보고 이들이 이러한 실제 문제에 대처하는 방식을 비교해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5.1 Pulumi 대비 Terraform: 코드 구조, 가독성 및 확장성\n\nTerraform에서는 모듈을 정의하고 재사용하여 최대 코드 재사용성을 달성할 수 있습니다. 전형적인 단일식 Terraform 저장소는 다음과 같이 보일 수 있습니다:\n\n```js\n.\n├── dev\n│   ├── config.tf\n│   ├── main.tf\n│   ├── output.tf\n│   └── variables.tf\n├── modules\n│   ├── module_a\n│   └── module_b\n└── prod\n    ├── config.tf\n    ├── main.tf\n    ├── output.tf\n    └── variables.tf\n```\n\n단일 저장소에는 강점이 있습니다. 매우 사람이 읽기 쉽고 설명 없이 쉽게 이해할 수 있습니다. 그리고 Terraform의 특성 상, 디렉토리 구조가 두 단계 또는 최대 세 단계로 설정될 수 있어 한눈에 쉽게 파악하고 관리하기 쉽습니다. 또한, 또 다른 환경을 만드는 것은 기존 저장소에 \"test\"라는 폴더를 추가하는 것만큼 복잡하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 깔끔한 코드 기반을 기준으로 프로젝트가 커질 때 여러 가지 개선 방법이 있습니다. 인프라의 다른 부분들을 서로 다른 저장소로 분리하거나 모듈들을 다른 저장소 하나 또는 몇 개로 이동하거나 서로 다른 환경을 다른 저장소로 이동할 수 있습니다. 모든 선택 사항은 유연하며 모두 새로운 저장소를 만들어 깔끔하고 이해하기 쉬운 디렉토리 구조를 유지합니다.\n\nPulumi를 사용하면 상황이 약간 복잡해질 수 있습니다. 전형적인 단일체 Pulumi 프로젝트는 다음과 같이 보일 수 있습니다:\n\n```js\n.\n├── Pulumi.dev.yml\n├── Pulumi.prod.yml\n├── Pulumi.yml\n├── api-gateway\n│   ├── index.ts\n│   └── micro-service-01\n│       └── index.ts\n├── database\n│   └── table-01.ts\n├── index.ts\n├── package-lock.json\n├── package.json\n├── sns\n│   └── topics.ts\n└── queues.ts\n├── pkg\n│   └──application\n│     └── app.go\n└── .etc\n```\n\nTerraform과 마찬가지로 일반적인 내용을 패키지로 만들어 프론트엔드 또는 백엔드 프로젝트에서 작업한 것과 같이 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트가 커질수록, 프로젝트를 별도로 관리되는 더 작은 프로젝트로 분할하는 마이크로-스택스 접근 방식을 사용할 수 있습니다. 그리고 각 프로젝트는 위에서 설명한 것과 같을 수 있습니다.\n\n그러나 프로젝트가 커지면 디렉토리 구조가 더 복잡해지고 많은 디렉토리와 수준이 더 많아져 혼란스러울 수 있습니다. Java나 혹은 지금까지 경험했던 실제 프로젝트를 상상해보세요. 그 프로젝트 전체를 빠르게 이해하기 쉬운가요? 아니요, 많은 폴더와 디렉토리 수준이 많아서 무엇이 무엇인지 심지어 어디서 시작해야 하는지도 모를 정도입니다.\n\nPulumi의 가장 강력한 장점은 다국어 지원이지만, 큰 힘은 큰 책임을 수반합니다. 코드를 이해하고 유지 관리하기 쉽게 구성하는 것이 중요하며, 이는 사용하는 도구에 상관 없이 사실입니다.\n\n## 5.2 Pulumi 대 Terraform: 통합\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 경우, IaC가 단순히 IaC를 수행하고 끝나는 것이 아닙니다. 인프라 부분은 CI/CD 파이프라인과 같은 다른 요소들과 통합되어야 합니다. 다행히, Terraform과 Pulumi는 변경 사항을 배포하는 데 하나의 명령만 필요하므로 이들은 통합하기에 이상적입니다. 그러나 차이점도 있습니다.\n\n경우에 따라 IaC 파이프라인이 시작되기 전에 뭔가를 수행하고 싶을 수 있습니다.\n\n예를 들어, 사용자, 팀, 멤버십, 권한을 관리하기 위해 IaC를 사용하고 싶다고 가정해 봅시다. 새로운 사용자를 추가할 때, 코드베이스를 열어서 복사하여 수정하고 커밋하는 것은 번거로울 수 있습니다. 사용자 목록을 어딘가에 저장해두고, 그 파일을 검색하여 일부 템플릿 도구를 사용하여 IaC 코드를 자동으로 생성할 수 있습니다.\n\n이 경우, Terraform의 경우 추가 도구(예: 일부 Python 스크립트)에 의존해야 할 수도 있습니다. 파일을 다운로드하고 구문 분석하고 템플릿을 사용하여 생성된 IaC 파일을 커밋한 다음 IaC 파이프라인을 실행하기 전에 모든 작업을 수행해야 할 수 있습니다. Pulumi의 경우, 모든 것을 한 번에 처리할 수 있어서 훨씬 간단할 수 있습니다. 사용할 수 있는 프로그래밍 언어를 사용하여 파일을 다운로드/구문 분석하고, 동일한 언어를 사용하여 for 루프를 통해 간단히 작업을 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 경우에는 IaC가 끝난 후에 무언가를 수행하고 싶을 수 있습니다. 예를 들어, IaC 부분의 출력에 사용하려는 로드 밸런서 URL이 포함되어 있을 수 있습니다. Terraform의 경우 다시 다른 스크립트를 실행해야 할 수도 있지만, Pulumi를 사용하면 IaC 코드 이후에도 그대로 진행하여 이를 수행할 수 있습니다. \n\n간략히 말하면, Terraform과 스크립트를 통합하는 데 어려움을 겪는 경우에는 Pulumi를 사용해 보는 것이 좋을 것입니다.\n\n## 5.3 Pulumi 대 Terraform: 보안\n\n보안은 항상 코드에 중요한 주제이며, 인프라 코드 역시 코드입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 보안을 위한 가장 기본적인 원칙은 아마도 코드에 비밀을 평문으로 저장하지 않는 것입니다. 이 부분에서 Terraform과 Pulumi는 모두 잘 작동합니다. Terraform은 다양한 시크릿 매니저와 통합될 수 있으며, Pulumi에서는 시크릿 매니저에서 한 줄의 코드로 읽는 것도 쉽습니다. 예를 들어, Terraform에서 시크릿을 관리하는 블로그가 있습니다.\n\n코드 보안에 대해 더 말씀드릴 수 있습니다: Terraform으로 HCL을 작성하면 구성 코드가 생성, 읽기, 업데이트 및 삭제 리소스에 대한 API 호출로 변환됩니다. 물론, Terraform 코어와 플러그인 자체에도 보안 문제와 CVE가 발생할 수 있지만, 다른 IaC 옵션에 대해서도 동일하게 말할 수 있습니다. Pulumi의 경우, IaC 코드를 여러 언어로 작성하고 훨씬 더 많은 작업을 수행할 수 있기 때문에 공격 표면이 증가할 수 있습니다. 이는 Pulumi의 단점으로 보일 수 있지만, 다행히도 인프라 코드를 스캔하는 데 사용되는 최선의 방법과 도구 (SAST 및 DAST와 같은)가 있어서 보안을 강화할 수 있습니다.\n\nTerraform 및 IaC 보안에 관심이 있다면, Terraform을 사용한 IaC 보안에 대한 블로그와 Terraform의 몇 가지 모베스트 프랙티스에 관한 블로그를 읽어보세요 (걱정하지 마세요, 이전에 읽은 것과는 달라요).\n\n코드 보안을 떠나서, IaC 도구는 인프라를 관리하고 중요한 정보가 실제로 상태에 저장되기 때문에 상태의 보안도 중요합니다. Terraform과 Pulumi는 민감한 정보를 상태에 평문으로 출력되지 않도록 암호화할 수 있습니다. 그리고 두 도구 모두 암호화된 상태를 저장하기 위한 다양한 백엔드를 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 섹션을 마무리하기 위한 몇 가지 권장 사항:\n\n- IaC 툴을 사용하여 민감한 데이터를 관리하는 경우(데이터베이스 비밀번호, 사용자 비밀번호 또는 개인 키와 같은), 상태 자체를 민감한 데이터로 처리해야 합니다. 즉:\n- 상태를 원격으로 저장하면 더 나은 보안을 제공할 수 있으며 상태에 로컬 디스크를 사용하지 않도록합니다.\n- 쉽히 상태 데이터를 암호화할 수 있는 백엔드를 사용하세요.\n\n# 6 Summary: Choosing Your IaC Tool\n\n## 6.1 Comparison Table\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 작업을 쉽게 하기 위해 두 가지 주요 기능을 빠르게 비교할 수 있는 다음 표를 보겠습니다:\n\n![Comparison Table](/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_1.png)\n\n## 6.2 IaC 도구 선택\n\n더 재미있게 하기 위해, 다음 플로 차트를 만들어 여러분이 적합한 도구를 선택하는 데 도움이 되도록 하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 6.3 작업에 적합한 도구 선택하기\n\n재미있는 이야기는 떠나고, 작업에 적합한 도구를 선택하는 몇 가지 팁을 제공해 드리겠습니다:\n\n- 여전히 앱 코드를 작성하는 것이 본업이고 인프라 코드를 관리하는 것이 부분적인 업무라면, Pulumi가 더 나은 선택이 될 수도 있습니다.\n- 만약 Terraform에 경험이 있고 불만족스럽다면, 의문없이 Pulumi를 시도해 보세요. Terraform으로는 할 수 있는 중요한 일을 Pulumi로 할 수 없는 것은 없습니다.\n- 모든 것을 지배할 도구를 선택할 필요는 없습니다. Pulumi 대 Terraform은 싸움이 아니며, 어떤 것이 더 나은지, 무엇이 틀린지를 결정해야 하는 것도 아닙니다. 사실 둘 다 사용할 수 있습니다. 프로젝트가 확장될수록 단일 인프라 저장소를 관리하는 것은 어려워지며, 마이크로서비스 스타일의 인프라 프로젝트를 가지고 있다면, 각 부분에 맞는 올바른 도구를 사용하여 최선의 선택을 할 수 있습니다. 올바른 도구를 선택하면 특정 작업을 더 쉽게 처리할 수 있습니다.\n- 직접 체험해 보세요. 블로그와 기사를 읽어도 괜찮지만, 결과적으로 두 도구를 짧게 체험하면 마음이 원하는 것을 알 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자주 묻는 질문\n\n## Q: Terraform은 오래된 기술인가요?\n\n네, 그렇습니다.\n\n네, Terraform은 많은 해동안 사용되어 왔습니다. 그러나 약간의 한계도 갖고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나, HCL을 사용해야 한다는 점을 제외하고는, Terraform은 거의 모든 것을 다 다루며, 그것들을 잘 처리합니다.\n\nTerraform은 다른 프로그래밍 언어로 인프라를 정의할 수 있는 CDKTF를 지원한다는 점을 언급할 가치가 있습니다.\n\n## 질문: Pulumi가 Terraform보다 나은가요?\n\n예와 아니요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 다른 프로그래밍 언어를 선택하여 인프라를 정의할 수도 있습니다.\n\n하지만, 완전한 프로그래밍 언어로 큰 프로젝트를 개발하면 간단한 구성 언어보다 이해하기 어렵고 읽기 어려울 수 있습니다.\n\n각 도구는 강점을 가지고 있으며 누가 더 좋은지는 말할 수 없습니다.\n\n## Q: Pulumi가 Terraform이 할 수 있는 모든 것을 할 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네.\n\n음, 그렇게 말해도 될 것 같아요. 두 도구 모두 각자의 독특한 점과 기능을 갖고 있지만, IaC에 관한 기본적인 기능은 두 도구 모두 갖추고 있어요. 만약 Pulumi를 선택하고 나중에 Terraform이 훌륭히 수행하는 몇 가지 마법 같은 기능을 Pulumi가 수행하지 못한다고 알게 되더라도, 불편한 상황에 처할 일은 없을 거에요.\n\n## 질문: Pulumi의 단점은 무엇인가요?\n\n정말 없어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘하는 것은 그것이 하는 일을 아주 잘하고, 사용하는 프로그래밍 언어를 선택하여 할 수 있어요. 게다가 문서와 커뮤니티 모두 좋아요.\n\nPulumi를 조금 더 세밀하게 살펴보자면, Python, Go 또는 JavaScript로 만든 큰 코드베이스를 관리하기가 HCL 구성 파일 저장소보다 어려울 수 있어요. 하지만 이는 Pulumi가 이 난관을 가져온 것이 아니라 프로그래밍 부분 때문이에요. 게다가 HCL을 사용한다고 해서 코드베이스가 자동으로 더 읽기 쉬워지거나 관리가 쉬워지는 것은 아니에요: 분명히 엉망으로 만들 수 있어요. 결국, 깔끔한 코드를 작성하고 유지하는 것은 프로그래머들의 몫이에요.","ogImage":{"url":"/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png"},"coverImage":"/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png","tag":["Tech"],"readingTime":17}],"page":"47","totalPageCount":61,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"47"},"buildId":"R1x9p1CQYDDJESXyLXKOK","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>