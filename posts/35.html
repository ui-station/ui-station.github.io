<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/35" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/35" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험" href="/post/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">29<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Argo CD v212 릴리스 후보판" href="/post/2024-06-19-ArgoCDv212ReleaseCandidate"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Argo CD v212 릴리스 후보판" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-ArgoCDv212ReleaseCandidate_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Argo CD v212 릴리스 후보판" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Argo CD v212 릴리스 후보판</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="도커에서 자체 서명 인증서를 사용한 NGINX" href="/post/2024-06-19-NGINXwithSelf-SignedCertificateonDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="도커에서 자체 서명 인증서를 사용한 NGINX" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="도커에서 자체 서명 인증서를 사용한 NGINX" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">도커에서 자체 서명 인증서를 사용한 NGINX</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="편리한 클라우드 배포 Terraform과 GitHub Actions를 활용하여 AWS에서 NET API와 Angular 프론트엔드를 런칭하기 PART 23" href="/post/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="편리한 클라우드 배포 Terraform과 GitHub Actions를 활용하여 AWS에서 NET API와 Angular 프론트엔드를 런칭하기 PART 23" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="편리한 클라우드 배포 Terraform과 GitHub Actions를 활용하여 AWS에서 NET API와 Angular 프론트엔드를 런칭하기 PART 23" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">편리한 클라우드 배포 Terraform과 GitHub Actions를 활용하여 AWS에서 NET API와 Angular 프론트엔드를 런칭하기 PART 23</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ollama - Langchain을 사용해 챗봇 만들기, 도커로 배포하기" href="/post/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ollama - Langchain을 사용해 챗봇 만들기, 도커로 배포하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ollama - Langchain을 사용해 챗봇 만들기, 도커로 배포하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Ollama - Langchain을 사용해 챗봇 만들기, 도커로 배포하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="원격 개발, 또는 메인프레임을 사랑하게 된 방법" href="/post/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="원격 개발, 또는 메인프레임을 사랑하게 된 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="원격 개발, 또는 메인프레임을 사랑하게 된 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">원격 개발, 또는 메인프레임을 사랑하게 된 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스프링 부트 개발자를 위한 도커에 오신 것을 환영합니다" href="/post/2024-06-19-WelcometoDockerforSpringBootDevelopers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스프링 부트 개발자를 위한 도커에 오신 것을 환영합니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-WelcometoDockerforSpringBootDevelopers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스프링 부트 개발자를 위한 도커에 오신 것을 환영합니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">스프링 부트 개발자를 위한 도커에 오신 것을 환영합니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="컨테이네라이제이션의 힘을 발휘하기 데이터 과학자들이 도커와 쿠버네티스를 배워야 하는 이유" href="/post/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="컨테이네라이제이션의 힘을 발휘하기 데이터 과학자들이 도커와 쿠버네티스를 배워야 하는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="컨테이네라이제이션의 힘을 발휘하기 데이터 과학자들이 도커와 쿠버네티스를 배워야 하는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">컨테이네라이제이션의 힘을 발휘하기 데이터 과학자들이 도커와 쿠버네티스를 배워야 하는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라라벨 세일과 도커 컴포즈 파일을 사용자 정의하는 방법" href="/post/2024-06-19-HowtoCustomizeLaravelSailwithDockerComposeFiles"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라라벨 세일과 도커 컴포즈 파일을 사용자 정의하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtoCustomizeLaravelSailwithDockerComposeFiles_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라라벨 세일과 도커 컴포즈 파일을 사용자 정의하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">라라벨 세일과 도커 컴포즈 파일을 사용자 정의하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법" href="/post/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link posts_-active__YVJEi" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"나의 쿠버네티스 클러스터에 MongoDB No-SQL 데이터베이스를 추가한 경험","description":"","date":"2024-06-19 13:00","slug":"2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster","content":"\n## SQL과 No-SQL 데이터베이스 사이를 선택하는 방법에 대해 읽었다면, Kubernetes 클러스터에 No-SQL MongoDB 데이터베이스를 추가할 수 있는지 궁금할 것입니다. 이 글에서는 그것을 어떻게 수행했는지 설명하고 Spring Boot 애플리케이션과 함께 사용하는 방법에 대해 알려드리겠습니다.\n\n![이미지](/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png)\n\n# 시작하기\n\n일반적으로 Kubernetes 서비스를 개발할 때는, 개발을 위해 로컬 Kind Kubernetes 클러스터에서 시작합니다. Kind를 설정하는 방법에 대해 이전에 썼었고, 이 글에 관련된 GitHub 저장소에는 이를 수행하는 데 필요한 구성 파일이 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클론하기 위해 저장소를 다음과 같이 복제할 수 있어요:\n\n```js\ngit clone git@github.com:MartinHodges/aquarium-with-mongo-db.git\n```\n\n# 왜 MongoDB를 사용해야 하나요?\n\n이전 기사에서 SQL 대 No-SQL 결정에 대해 다뤄 보았어요. 여러분이 이 글을 읽고 계신다면 No-SQL을 선택하겠다고 결정하신 거겠죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일단 그 결정이 내렸다면, 이제 No-SQL 데이터베이스를 어떤 것을 선택할지가 문제가 됩니다. MongoDB는 가장 가까운 경쟁상대보다 2배 더 높은 시장 점유율을 보유하고 있습니다. 그것은 매우 정교하며 커뮤니티 버전과 엔터프라이즈 버전 둘 다 가지고 있습니다. 전형적으로 가장 많이 사용되는 No-SQL 데이터베이스입니다.\n\n다른 데이터베이스와의 기술적인 비교는 이 기사의 범위를 벗어나지만, MongoDB가 인기 있는 이유와 일하도록 충분히 할 수 있는 사실에 기반하여 이 기사에서는 MongoDB를 선택했습니다!\n\n# MongoDB 설치\n\nKubernetes 클러스터에 MongoDB를 설치하는 방법은 다른 응용프로그램과 유사하게 operator를 사용하여 수행됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_1.png\" /\u003e\n\n쿠버네티스 오퍼레이터는 당신을 대신하여 응용 프로그램을 관리합니다. 응용 프로그램의 라이프사이클을 설치하고 관리하며 모니터링하고 필요한 조치를 취할 수 있습니다.\n\n데이터베이스의 경우 데이터베이스 클러스터를 생성하거나 확장하거나 백업하는 등의 작업을 수행할 수 있습니다. 일반적으로 오퍼레이터는 그 자체의 '쿠버네티스 구성 언어'를 제공하는 사용자 정의 리소스 정의 (CRD)를 설치하기에 의존합니다. 이는 클러스터에 사용자 정의 리소스를 추가하기 위한 요청을 감지하고 당신을 대신하여 작동합니다.\n\n## 개발용 쿠버네티스 클러스터 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKind를 설치했다고 가정하면, 다음 구성을 사용하여 Kind 클러스터를 만들 수 있습니다:\n\nkind/kind-config.yml\n\n```js\napiVersion: kind.x-k8s.io/v1alpha4\nkind: Cluster\nnodes:\n- role: control-plane\n  extraPortMappings:\n  # apis\n  - containerPort: 30080\n    hostPort: 30080\n- role: worker\n- role: worker\n- role: worker\n```\n\n이렇게 하면 1개의 컨트롤러 및 3개의 워커로 구성된 4개 노드 클러스터가 생성됩니다. 또한 개발 머신의 포트 30080을 사용할 수 있습니다. 이를 사용하여 로컬 Kubernetes 클러스터를 생성할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```shell\nkind create cluster --config kind/kind-config.yml\n```\n\n## 오퍼레이터 설치\n\nHelm을 사용하여 커뮤니티 지원 오퍼레이터를 설치할 수 있습니다.\n\n먼저 다음과 같이 로컬 리포지토리에 Helm 링크를 추가하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhelm repo add mongodb https://mongodb.github.io/helm-charts\n```\n\n아래 명령어로 이 리포지토리가 추가한 차트를 확인할 수 있어요:\n\n```js\nhelm search repo mongo\n```\n\n리스트에서 커뮤니티 오퍼레이터를 확인할 수 있을 거에요. 이것을 사용할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희는 오퍼레이터와 데이터베이스를 별도의 네임스페이스로 mongo라는 이름으로 분리해서 배치할 겁니다. 다음과 같이 생성해보겠습니다:\n\n```js\nkubectl create namespace mongo\n```\n\n이제 다음 명령으로 오퍼레이터를 설치할 수 있어요:\n\n```js\nhelm install community-operator mongodb/community-operator -n mongo\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 명령어를 사용하여 준비 상태가 1/1로 Running인지 확인할 수 있어요:\n\n```sh\nkubectl get pods -n mongo\n```\n\n이제 운영자가 작동 중인 것을 볼 수 있습니다. 설치된 CRD는 다음을 통해 확인할 수 있어요:\n\n```sh\nkubectl get crds\nkubectl describe crd mongodbcommunity.mongodbcommunity.mongodb.com\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 MongoDB 클러스터를 생성할 준비가 되었습니다.\n\n## 클러스터 생성\n\n오퍼레이터가 설치되었으므로 MongoDB 데이터베이스를 생성하는 요청을 대기 중입니다. 우리는 오퍼레이터에 의해 로드된 CRD를 사용하여 쿠버네티스 클러스터에 MongoDB 매니페스트를 적용하여 요청을 할 수 있습니다.\n\n이를 하기 전에 데이터베이스 사용자의 비밀번호를 쿠버네티스 시크릿으로 설정해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 비밀을 생성하세요 (‘…’를 선택한 비밀번호로 교체하세요):\n\n```js\nkubectl create secret generic my-user-password -n mongo --from-literal=\"password=\u003c당신의 비밀번호\u003e\"\n```\n\n다음 명령어로 확인할 수 있어요:\n\n```js\nkubectl get secrets -n mongo my-user-password -o jsonpath={.data.password} | base64 -d; echo\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 쿠버네티스 시크릿은 base64로 인코드되어 있기 때문에 비밀번호를 디코딩하는 데 base64 -d를 사용하는 것을 알 수 있습니다. 우리가 --from-literal을 사용하였기 때문에 create secret 명령어에 의해 비밀번호가 자동으로 base64로 인코드되었습니다.\n\n이제 비밀번호가 준비되었으니, 이 비밀번호를 사용하는 관리자 사용자가 있는 MonogoDB 클러스터와 데이터베이스를 생성할 수 있습니다.\n\n매니페스트 파일을 생성해 보세요:\n\nk8s/my-mongo-db.yml\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\napiVersion: mongodbcommunity.mongodb.com/v1\nkind: MongoDBCommunity\nmetadata:\n  name: my-mongo-db\n  namespace: mongo\nspec:\n  members: 3\n  type: ReplicaSet\n  version: \"7.0.11\"\n  security:\n    authentication:\n      modes: [\"SCRAM\"]\n  users:\n    - name: my-user\n      db: admin\n      passwordSecretRef: # a reference to the secret that will be used to generate the user's password\n        name: my-user-password\n        key: password\n      roles:\n        - name: clusterAdmin\n          db: admin\n        - name: userAdminAnyDatabase\n          db: admin\n      scramCredentialsSecretName: my-user-scram\n  additionalMongodConfig:\n    storage.wiredTiger.engineConfig.journalCompressor: zlib\n```\n\n이제 다음과 같이 적용할 수 있습니다:\n\n```bash\nkubectl apply -f k8s/my-mongo-db.yml\n```\n\n그리고 진행 상황을 다음과 같이 확인할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl get pods -n mongo\n```\n\n3개의 인스턴스가 생성될 때까지 기다리고 있어요. 제 MacBook Pro(M2 Max Apple 실리콘)에서 4노드 Kind 클러스터를 사용하면, 모든 3개의 인스턴스를 시작하는 데 약 5분 정도 걸렸어요.\n\n시작되고 나면, 다음 명령어로 서비스가 정상적으로 작동하는지 확인할 수 있어요:\n\n```js\nkubectl get svc -n mongo\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 하면:\n\n```js\nNAME              TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)     AGE\nmy-mongo-db-svc   ClusterIP   None         \u003cnone\u003e        27017/TCP   6m\n```\n\n## 데이터베이스 테스트\n\n우리 애플리케이션에서는 쿠버네티스 내부에서 직접 데이터베이스에 연결할 것입니다. 데이터베이스의 서비스를 이용해 DNS 이름으로 연결하려고 하지만, 테스트 목적으로는 로컬 개발 머신에서 연결하고 싶습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n처음으로 이를 시도할 때 로컬 개발 머신으로 MonogoDB 파드 중 하나를 포워딩하기 위해 포트 포워딩을 사용했고, 어떤 변경을 시도했을 때 다음과 같은 오류 메시지를 받았습니다:\n\n```js\nMongoServerError[NotWriteablePrimary]: not primary\n```\n\n이것은 포트 포워딩한 파드가 클러스터의 주 파드가 아니기 때문에 발생한 문제입니다. 보조 파드는 읽기 전용 복사본이기 때문에 모든 쓰기 작업은 주 파드를 통해 이루어져야 합니다.\n\n이 문제를 피하려면 주 파드에 연결해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 노드가 기본 노드인지 알고 싶다면 다음 노드 중 하나의 로그를 조사하면 됩니다:\n\n```js\nkubectl logs my-mongo-db-0 -n mongo -c mongod | grep \"\\\"primary\\\":\"\n```\n\n만약 결과가 없다면, 기본 노드에 도달한 것입니다.\n\n만약 결과를 얻는다면, 몇 줄만 출력될 수 있지만, 그것들은 매우 길고 읽기 어려울 수 있습니다. JSON pretty printer 같은 것(jq와 같은)을 가지고 있다면 다음을 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl logs my-mongo-db-0 -n mongo -c mongod | grep \"\\\"primary\\\":\" | jq\n```\n\n그러면 다음과 같은 줄을 볼 수 있습니다:\n\n```js\n...\n\"primary\": \"my-mongo-db-1.my-mongo-db-svc.mongo.svc.cluster.local:27017\",\n...\n```\n\n여기에 연결해야 하는 pod의 이름이 나옵니다 (제 경우: my-mongo-db-1). 이제 해당 pod를 포트 포워드할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl port-forward my-mongo-db-1 -n mongo 27017:27017\n```\n\n이 포트 포워딩이 설정되면 데이터베이스에 연결해야 합니다. MongoDB Compass 클라이언트를 사용할 수 있습니다. 해당 클라이언트는 https://www.mongodb.com/try/download/compass 에서 다운로드할 수 있습니다.\n\n설치 후 데이터베이스에 연결할 수 있어야 합니다. 연결 문자열(mongodb://localhost:27017)이 제안됩니다만, 몇 가지 설정을 변경해야합니다.\n\n고급 연결 옵션을 클릭하고 직접 연결을 클릭하십시오 (이 설정을 변경하지 않으면 내부 쿠버네티스 주소를 사용하려고 시도하여 찾을 수 없는 주소가 발생합니다).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인증 탭을 클릭해주세요. 사용자 이름/비밀번호를 선택하고 이전에 선택한 사용자 이름(my-user)과 비밀번호를 입력해주세요. Admin을 데이터베이스로 추가하고 SCRAM-SHA-256 인증 메커니즘을 선택해주세요 (필요하다면 아래로 스크롤).\n\n저장 및 연결을 클릭하고 연결 이름을 지정한 후, 데이터베이스에 연결된 Compass 콘솔이 표시됩니다.\n\n클러스터 내에서 admin, config 및 local 데이터베이스가 생성된 것을 확인하실 수 있습니다.\n\n여기까지 오셨다면, MongoDB 클러스터가 정상적으로 실행 중임을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 애플리케이션 사용자 생성\n\n우리의 MongoDB에 연결할 모든 애플리케이션이 우리가 생성한 my-user를 사용할 수 있을 것이라고 생각할 수 있습니다. 하지만, 이 사용자는 실제로 데이터베이스 유지 관리를 위한 것이기 때문에 그렇지 않습니다.\n\n애플리케이션이 데이터베이스 클러스터를 사용할 수 있도록하려면 데이터베이스와 해당 데이터에 액세스할 사용자를 생성해야 합니다.\n\nCompass 창의 맨 아래에 `_MONGOSH` 프롬프트가 나타납니다. 이를 클릭하여 명령줄에 액세스할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음과 같이 사용자를 생성할 것입니다:\n\n```js\nuse aquarium\ndb.createUser( { user: \"my-app-user\",\n              pwd: \"\u003cpassword\u003e\",\n              roles: [ {db: \"aquarium\", role: \"dbOwner\"} ] } )\n```\n\n알아둬야 할 몇 가지 사항이 있습니다. 첫번째로, 생성되기 전에 존재하지 않는 데이터베이스(aquarium)로 전환합니다. 이는 사용하기 전에 아무 것도 정의할 필요가 없다는 원칙에 부합합니다. 데이터베이스 및 모든 컬렉션은 문서를 추가할 때 처음 생성됩니다.\n\n두번째는 새 데이터베이스에 할당된 역할입니다. MongoDB에는 사용자에게 부여할 수 있는 소수의 기본 역할이 있습니다. 이 경우 dbOwner 역할은 사용자가 데이터베이스를 읽고 쓰고 관리할 수 있도록 합니다. 실제 운영에서는 사용자 권한을 적절히 제한해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n...\nok: 1,\n...\n```\n\n사용자를 확인하기 위해 새 Compass 연결을 열어보세요. 이는 메뉴를 통해 할 수 있습니다. 혹은 MacOS에서는 Cmd N을 누르세요. 창이 열릴 때까지 몇 초가 걸릴 수 있는데, 아무런 표시가 없으므로 한 번만 누르세요!\n\n새 연결 창이 나타나면, 이전에 저장한 연결을 복제하는 것이 더 쉽다고 생각합니다(연결 옆의 ... 메뉴를 사용하세요).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자 이름과 비밀번호를 변경해주세요. 또한 Authentication Database를 aquarium으로 변경해주세요. 그런 다음 연결하세요.\n\n이제 새로운 aquarium 데이터베이스를 확인할 수 있어야 합니다. \"fishes\"라는 collection을 생성해보면서 테스트해 볼 수 있습니다. 데이터베이스에 문서 형태로 데이터를 추가할 수 있습니다.\n\n```js\n{\n  \"_id\": 123,\n  \"fish\": \"Guppy\"\n}\n```\n\n이 시점에서 Spring Boot 애플리케이션과 함께 사용할 준비가 된 MongoDB가 준비되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 스프링 부트 애플리케이션 만들기\n\n간단한 데이터베이스 지원 예제를 만들 때는 제가 제일 먼저 수족관 애플리케이션을 사용합니다. REST API를 사용하여 물고기와 수족관을 만들고 관리할 수 있습니다. 그런 다음 물고기를 여러분의 수족관 중 하나에 추가할 수 있습니다.\n\n## 코드\n\n저는 코드를 여기에 포함하려는 의도는 없지만 관련된 GitHub 저장소에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 종속성\n\nSpring Boot 애플리케이션을 시작하는 것은 항상 https://start.spring.io/에서 Spring Initializr를 사용하는 것이 더 쉽습니다. 사용 방법을 알고 있다고 가정합니다.\n\n이 프로젝트에서 Spring Web과 Spring Data MongoDB를 종속성으로 추가하고 프로젝트를 생성합니다.\n\n## 패키지 구조\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내가 만드는 애플리케이션에 따라, 패키지 구조를 구성하는 데 컴포넌트 유형(예: 컨트롤러, 서비스 및 리포지토리)에 기반을 둘 수도 있고, 비즈니스 도메인에 기반을 둘 수도 있습니다.\n\n물고기와 수조 두 가지 비즈니스 도메인만 있는 작은 애플리케이션인 경우, 이 프로젝트를 이러한 도메인을 기반으로 해서 다음과 같이 만들 것입니다:\n\n```js\nfishes;\nFishController;\nFishService;\nFishRepository;\nfishtanks;\nFishTankController;\nFishTankService;\nFishTankRepository;\n```\n\n보시다시피, 컨트롤러, 서비스 및 리포지토리 레이어를 사용하여 표준 계층 구조를 따르고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## API 엔드포인트\n\n이 컨트롤러들은 각각의 API에 대해 생성, 조회, 업데이트 및 삭제 (CRUD) 엔드포인트를 제공합니다.\n\n## 엔티티 및 문서\n\n만약 JPA와 Postgres와 같은 SQL 데이터베이스에 익숙하다면, 엔티티와 리포지토리로 익숙할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNo-SQL 데이터베이스에서는 테이블이 컬렉션으로 대체되고, 테이블 내의 행은 문서로 대체됩니다.\n\n이는 No-SQL 데이터베이스를 위한 리포지토리가 SQL 데이터베이스와는 조금 다르다는 것을 의미합니다.\n\nNo-SQL 데이터베이스는 어떤 구조든 다룰 수 있기 때문에, 엔티티(또는 문서)는 간단한 Plain Old Java Objects (POJOs)가 됩니다. 이는 우리 예시 애플리케이션에서 다음과 같이 엔티티를 생성할 수 있다는 것을 의미합니다:\n\naquarium/fishes/Fish.java\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n...\n\n@Setter\n@Getter\n@Document(\"fishes\")\n@NoArgsConstructor\npublic class Fish {\n\n  @Id\n  public UUID id;\n\n  public String type;\n\n  public Fish(String type) {\n      this.id = UUID.randomUUID();\n      this.type = type;\n  }\n  ...\n}\n```\n\n친구야, 여기 몇 가지 주의할 점이 있어요:\n\n- @Entity를 정의하는 대신 컬렉션의 이름을 사용하는 @Document를 정의하고 있어요.\n- 자체 UUID Id를 관리할 수 있도록 @mongoId 대신에 (필수는 아니지만 MongoDB가 제공하지 않은 경우 MongoDB로 제공할 수 있기 때문에) @Id를 사용하고 있어요.\n- Lombok(예: @Getter)을 사용하여 보일러플레이트 코드 일부를 제거하는 것을 좋아해요.\n\n이제 비슷한 방식으로 물고기 수조를 만들 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n수족관/fishtanks/FishTank.java\n\n```java\n@Setter\n@Getter\n@Document(\"fish tanks\")\n@NoArgsConstructor\npublic class FishTank {\n\n    @Id\n    public UUID id;\n\n    public String name;\n\n    public FishTank(String name) {\n        this.id = UUID.randomUUID();\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\n                \"FishTank[id=%s, type='%s']\",\n                id.toString(), name);\n    }\n}\n```\n\n## Repositories\n\n자, 이제 우리의 문서들이 준비되었어요. 이제 이들에 어떻게 접근할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제가 보여드릴 것은 우리 저장소의 변경 사항입니다. 물고기 저장소를 예로 들어보겠습니다:\n\n```js\n...\npublic interface FishRepository extends MongoRepository\u003cFish, UUID\u003e {\n\n    public List\u003cFish\u003e findAll();\n\n    public Optional\u003cFish\u003e findFirstById(UUID id);\n\n    public Optional\u003cFish\u003e findFirstByType(String type);\n}\n...\n```\n\n이것이 SQL 데이터베이스에서 찾을 수 있는 Repository 유형과 거의 동일하다는 것을 알 수 있습니다. 유일한 차이점은 인터페이스가 CrudRepository가 아닌 MongoRespository를 확장한다는 것뿐입니다.\n\n한 대 다 및 다른 매핑 주제는 다른 기사로 미루겠습니다. 그래서 현재로서는 물고기와 어항을 생성하고 관리할 수 있을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 어플리케이션 속성\n\n데이터베이스와 작업할 때는 어플리케이션이 어떻게 연결해야 하는지를 알려줘야 합니다. 우리는 SQL 데이터베이스와 마찬가지로 어플리케이션 속성을 통해 이를 수행합니다.\n\n나는 Spring Boot 속성 파일에 YAML 파일을 사용하는 것을 선호하며, 내 구성은 다음과 같이 보입니다 (나의 값으로 ` ` 필드를 교체해주시기 바랍니다):\n\nresources/application.yml\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\nspring:\n  application:\n    name: aquarium-with-mongo-db\n\n  data:\n    mongodb:\n      host: localhost\n      port: 27017\n      database: aquarium\n      username: my-app-user\n      password: \u003cpassword\u003e\n```\n\n나중에 프로필에 대해 이야기할 때 다시 돌아올게요.\n\n## 컨트롤러 및 서비스\n\n이제 SQL 데이터베이스와 마찬가지로 컨트롤러와 서비스를 추가할 수 있습니다. GitHub 저장소에서 이용 가능하므로 별도로 제시하지 않겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 애플리케이션 테스트\n\n코드를 완성하거나(또는 제 저장소를 복제)하여 IDE 내에서 애플리케이션을 실행하십시오. 여전히 주 서버로 포트 포워딩 중인 경우, 애플리케이션이 시작되어야 합니다.\n\n그런 다음 다음 curl 명령을 사용하여 테스트할 수 있습니다:\n\n```js\ncurl localhost:8080/api/v1/fishes -H \"Content-Type: application/json\" -d '{\"type\": \"guppy2\"}'\ncurl localhost:8080/api/v1/fish-tanks -H \"Content-Type: application/json\" -d '{\"name\": \"big one\"}'\ncurl localhost:8080/api/v1/fishes\ncurl localhost:8080/api/v1/fish-tanks\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 컴퍼스 클라이언트로 이동하여 아쿠아리움 데이터베이스를 새로 고침하면 fishes 및 fish tanks 두 개의 컬렉션이 표시됩니다. 이러한 컬렉션 내에는 만든 fishes 및 fish tanks가 표시됩니다.\n\n# 최종 단계\n\n이 시점에서 저희는 쿠버네티스 클러스터에서 실행 중인 MongoDB에 연결된 Spring Boot 애플리케이션을 갖추었습니다. 이제 해야 할 마지막 단계, 즉 Spring Boot 애플리케이션을 쿠버네티스 클러스터에 로드하는 것이 남았습니다.\n\n이를 위해 다음을 수행해야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 팻 JAR 파일을 생성합니다 (모든 종속성이 포함됨)\n- 해당 JAR에서 Docker 이미지를 생성합니다\n- 이미지를 Docker 저장소에 업로드합니다\n- 배포 매니페스트 파일을 생성합니다\n- 배포 매니페스트를 Kubernetes 클러스터에 적용합니다\n\n제가 Kind를 사용하고 있기 때문에, 3단계를 간단한 로드 단계로 대체할 수 있습니다. 이렇게 하면 Docker 저장소를 사용할 필요가 없습니다.\n\n## 프로필\n\nJAR 파일을 생성하기 전에 Spring Boot 프로필 두 개를 생성하는 것이 유용합니다. 이를 통해 애플리케이션을 연결된 모드 (지금까지 한 것처럼) 및 Kubernetes 클러스터 내에서 실행할 수 있습니다. Spring Boot 프로필 두 개를 생성하겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `connected` ... 클러스터 외부에서 실행 중일 때 사용되는 모드\n- `local-cluster` ... 클러스터 내부에서 실행 중일 때 사용되는 모드\n\n현재 실행 중인 모드는 첫 번째입니다. 이는 우리가 간단히 application.yml(또는 application.properties) 파일을 application-connected.yml로 복사할 수 있다는 것을 의미합니다. 그런 다음 JVM 명령줄에 다음 JVM 인수를 추가할 수 있습니다:\n\n```js\n-Dspring.profiles.active=connected\n```\n\n로컬 클러스터 파일에 대해서도 동일한 작업을 수행하지만 이번에는 변경이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n...\n  data:\n    mongodb:\n      host: my-mongo-db-svc.mongo.svc.cluster.local\n      port: 27017\n...\n```\n\nDNS 이름을 사용하여 올바른 팟에 연결할 수 있습니다. 팟에서 DNS 검색 규칙이 설정되어 있어 my-mongo-db-svc.mongo.svc와 같은 이름 일부를 생략할 수 있습니다. 이를 통해 다른 클러스터로 배포하고도 응용 프로그램이 작동할 수 있습니다.\n\n## 이미지 생성\n\n이제 이미지를 만드는 방법을 살펴보겠습니다. GitHub에 있는 프로젝트가 Gradle 프로젝트이므로 루트 프로젝트 폴더에서 다음과 같이 JAR 파일을 생성할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngradle build\n```\n\ngradle.build에 아래 내용이 추가되었음을 유의해주세요. 이는 manifest가 주 애플리케이션 파일을 가리키도록 합니다:\n\ngradle.build\n\n```js\njar {\n    manifest {\n        attributes \"Main-Class\": \"com.requillion_solutions.aquarium.AquariumWithMongoDbApplication\"\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이렇게 하면 jar 파일이 생성됩니다: build/libs/aquarium-with-mongo-db-0.0.1-SNAPSHOT.jar.\n\n도커 이미지를 만들기 위해서는 도커 파일이 필요합니다. 아래 내용대로 만들어보세요:\n\nDockerfile\n\n```js\nFROM openjdk:17.0.2-slim-buster\nRUN addgroup --system spring \u0026\u0026 useradd --system spring -g spring\nUSER spring:spring\nARG JAR_FILE=build/libs/*.jar\nCOPY ${JAR_FILE} app.jar\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]\nEXPOSE 8080\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 Java 17 기반 이미지를 시작으로 합니다 (이것은 롬복과의 문제를 피하기 위해 필요합니다) 그리고 새 사용자 (spring)를 추가하여 루트로 실행하지 않도록 합니다. 그런 다음 JAR 파일이 이미지로 복사되고 응용 프로그램을 실행하는 엔트리포인트가 생성됩니다.\n\n다음 명령어로 도커 이미지를 생성하세요:\n\n```bash\ndocker build -t aquarium .\n```\n\n그리고 만약 Kind를 사용 중이라면, 다음 명령어로 직접 Kubernetes 클러스터에 로드하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkind load docker-image aquarium\n```\n\n이 작업이 완료되면 클러스터에서 실행하기 위한 배포 매니페스트를 생성할 준비가 되었습니다.\n\n## 배포 매니페스트\n\n이제 쿠버네티스 클러스터에 도커 이미지를 로드했으므로 배포 매니페스트를 사용하여 배포할 수 있습니다. 다음 파일을 만들어주세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nk8s/deployment.yml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: aquarium\n  namespace: default\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: aquarium\n  template:\n    metadata:\n      labels:\n        app: aquarium\n    spec:\n      containers:\n        - name: aquarium\n          image: aquarium\n          imagePullPolicy: IfNotPresent\n          ports:\n            - containerPort: 8080\n          env:\n            - name: SPRING_PROFILES_ACTIVE\n              value: local-cluster\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: aquarium\n  namespace: default\nspec:\n  selector:\n    app: aquarium\n  type: NodePort\n  ports:\n    - port: 8080\n      targetPort: 8080\n      nodePort: 30080\n```\n\n알아두어야 할 사항이 몇 가지 있어요:\n\n- 어플리케이션이 default 네임스페이스에 배포되었어요 (네임스페이스가 지정되지 않으면 사용되는 곳이죠)\n- 레플리카는 1개뿐이에요\n- 이미지는 이전에 불러왔으므로, 이미지가 없을 때만 불러와요\n- 프로필은 local-cluster로 설정돼요\n- 서비스가 생성되어 어플리케이션의 포트 8080을 개발 머신의 포트 30080으로 매핑돼요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음과 같이 배포할 수 있습니다:\n\n```js\nkubectl apply -f k8s/deployment.yml\n```\n\n시작이 성공적으로 이루어졌는지 확인해보세요:\n\n```js\nkubectl get pods\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번이 배포되면 API는 이전에 사용한 것과 동일한 curl 명령으로 테스트할 수 있습니다. 단, 포트를 30080으로 변경해 주세요.\n\n```js\ncurl localhost:30080/api/v1/fishes -H \"Content-Type: application/json\" -d '{\"type\": \"guppy2\"}'\ncurl localhost:30080/api/v1/fish-tanks -H \"Content-Type: application/json\" -d '{\"name\": \"big one\"}'\ncurl localhost:30080/api/v1/fishes\ncurl localhost:30080/api/v1/fish-tanks\n```\n\nCompass UI에서 새 문서를 확인할 수도 있습니다 (포트 포워드가 여전히 유지되는지 확인해 주세요).\n\n# 요약\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사는 Kind Kubernetes 클러스터로 MongoDB를 설치하고 Spring Boot 애플리케이션과 통합하는 과정에 대해 다루었습니다.\n\n이 연습은 꽤 간단하지만 그냥 어떻게 하는지 보여주는 것뿐입니다. 실제로는 보안, 백업 및 장애 조치에 작업이 필요할 것입니다.\n\n다른 기사에서는 문서간의 관계를 어떻게 관리할 수 있는지도 보여드릴 예정입니다.\n\n이 연습을 통해 No-SQL 데이터베이스가 Kubernetes와 Spring Boot와 간단하게 사용될 수 있다는 것을 보여줬으면 좋겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글을 즐겁게 읽으셨기를 바라며, 새로운 것을 배우며 기술을 향상시켰기를 바랍니다. 작은 거라도 새로운 지식을 얻었다면 좋겠네요.\n\n이 글이 유익하게 느껴진다면, 박수 한 번 부탁드립니다. 그렇게 하면 미래에 어떤 글을 써야 하는지 파악할 수 있고, 다음 글을 결정하는 데 도움이 됩니다. 개선 사항이나 제안 사항이 있다면 메모나 답글로 추가해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png"},"coverImage":"/assets/img/2024-06-19-MyexperienceaddingaMongoDBNo-SQLdatabasetomyKubernetescluster_0.png","tag":["Tech"],"readingTime":29},{"title":"Argo CD v212 릴리스 후보판","description":"","date":"2024-06-19 12:59","slug":"2024-06-19-ArgoCDv212ReleaseCandidate","content":"\n저희가 기쁜 마음으로 Argo CD v2.12 릴리스 후보판이 공개되었다는 소식을 전해드립니다! 이번 릴리스에는 30개 이상의 새로운 기능, 70여 개의 버그 수정, 그리고 60개의 문서 업데이트가 포함되어 있어요.\n\n곧바로 릴리스 후보판을 테스트하고 마주한 어떤 버그나 문제에 대한 피드백을 보내주시면 감사하겠습니다. 이는 여러분이 의견을 전할 수 있고 Argo CD가 더 나아지도록 도와줄 수 있는 큰 기회입니다.\n\n# Multi-source application advancements\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 소스에서 Argo CD 애플리케이션을 생성하는 것은 오랜 시간 동안 가장 요청이 많았던 Argo CD 기능 중 하나였습니다. 이 기능을 통해 여러 위치(예: 공개 Helm 차트 및 로컬 값 파일)에서 정보를 그룹화하여 단일 Argo CD 애플리케이션을 형성할 수 있습니다. 여러 소스를 정의하는 초기 지원은 이미 Argo CD 버전 2.6에 추가되었고, CLI를 위한 지원은 2.11에 추가되었습니다. UI는 여전히 애플리케이션이 단일 소스를 가지고 있다고 가정하고 롤백과 같은 특정 CLI 기능은 여러 소스를 가진 애플리케이션에 대해 아직 지원되지 않았습니다.\n\nArgo CD 버전 2.12에서는 여러 소스 애플리케이션의 롤백이 이제 Argo CD UI 및 CLI에서 모두 가능합니다.\n\n롤백 기능 외에도, 애플리케이션 세부 정보 페이지에 새로운 \"소스\" 탭이 추가되어 사용자가 애플리케이션의 소스를 관리(보기 및 편집)할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-ArgoCDv212ReleaseCandidate_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKeith Chong (Red Hat)과 Jorge Turrado에게 이러한 기능들을 구현해 줘서 감사합니다.\n\n# 프로젝트별 저장소 자격증명 개선사항\n\n현재 Argo CD API에서는 동일한 URL을 공유하는 여러 저장소 자격증명을 허용하지 않습니다. 저장소 자격증명이 argocd 네임스페이스에 직접 추가된 경우, argocd-server는 오류를 반환하지 않지만 이 작업은 작동하지 않습니다. URL과 일치하는 첫 번째 시크릿이 반환되며 순서도 정의되어 있지 않기 때문입니다.\n\nArgo CD 버전 2.12부터는 여러 앱 프로젝트가 동일한 URL을 가진 별도의 저장소 자격증명을 가질 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요 Blake Pettersson님(Akuity)!\n\n# Kubernetes 이벤트에 레이블 추가하기\n\nArgo CD 버전 2.12에서 사용자들은 Argo CD에서 생성된 k8s 이벤트에 애플리케이션 레이블을 노출할 수 있게 될 것입니다. `resource.includeEventLabelKeys`에서 정의된 특정 레이블 키를 가진 애플리케이션에 대해 생성된 이벤트에 대응하는 레이블이 이벤트에 첨부될 것입니다. 이 연결은 이러한 레이블을 사용하는 애플리케이션을 기반으로 이벤트를 필터링하거나 처리하는 것을 더 간단하게 만들어 줍니다.\n\n이 기능을 구현해준 Siddhesh Ghadi(Red Hat)님에게 감사드립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 일관성있는 샤딩 알고리즘\n\nArgo CD는 다른 Argo CD 애플리케이션 컨트롤러에 대한 샤딩 적용 기능을 제공합니다. 이를 통해 특정 클러스터를 특정 컨트롤러에 할당하여 부하를 다양한 샤드로 분산시킬 수 있습니다.\n\n기존의 샤딩 알고리즘인 레거시 방법과 라운드 로빈 알고리즘을 포함한 기존 방식은 최적의 부하 분산 유지와 불필요한 클러스터-샤드 할당 변경을 최소화하는 데 제한 사항이 있었습니다.\n\nArgo CD 버전 2.12부터 새로운 샤딩 알고리즘인 \"일관적 해싱(consistent-hashing)\"이 소개되었으며, 이는 클러스터-샤드 할당 변경을 줄이고 리소스 이용률을 최적화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이번 특징을 구현한 Akram Ben Aissi (Red Hat)에게 감사드립니다.\n\n# 기타 주목할만한 변경 사항\n\n릴리스에 추가된 몇 가지 새로운 변경 사항은 다음과 같습니다.\n\n- 시멘틱 버전 태그 해결을 위한 git 클라이언트 업데이트 (Stone Payments의 Pablo Aguilar가 수행)\n- Application Set Git Generator가 이제 GPG 서명 확인을 지원합니다 (Red Hat의 Ishita Sequeira가 수행)\n- ls-remote 요청 실패 지표 추가 (Jack-R-lantern이 수행)\n- 새로운 주석 argocd.argoproj.io/sync-options: Force=true 추가 (CyberAgent, Inc.의 Kota Kimura가 수행)\n- gRPC 메시지 크기를 환경 변수로 설정하는 지원 추가 (Codefresh의 Pavel Kostohrys가 수행)\n- 삭제 팝업에서 종속 리소스 목록 표시 (Intuit의 Alexandre Gaudreault가 수행)\n- old tracking label applications.argoproj.io/app-name에 대한 지원 제거 (Akuity의 Soumya Ghosh Dastidar가 수행)\n- Argo CD CLI에 대한 fish 쉘 완성 지원 추가 (Sn0rt가 수행)\n- 로컬로 존재하는 체크아웃할 커밋이 있는 경우 git fetch 호출 건너뛰기 (Shady Rafehi가 수행)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 새 릴리스는 어디에서 받을 수 있나요?\n\n더 자세한 내용과 설치 지침은 릴리스 노트와 업그레이드 지침을 확인해주세요. 릴리스 후보를 시도하고 피드백을 공유해주세요. Argo 커뮤니티의 모든 기여자와 사용자들께 기여, 피드백 및 릴리스 테스트에서 도와준 점에 크게 감사드립니다!\n","ogImage":{"url":"/assets/img/2024-06-19-ArgoCDv212ReleaseCandidate_0.png"},"coverImage":"/assets/img/2024-06-19-ArgoCDv212ReleaseCandidate_0.png","tag":["Tech"],"readingTime":5},{"title":"도커에서 자체 서명 인증서를 사용한 NGINX","description":"","date":"2024-06-19 12:57","slug":"2024-06-19-NGINXwithSelf-SignedCertificateonDocker","content":"\n\u003cimg src=\"/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_0.png\" /\u003e\n\n저희 코드를 작업하는 동안 HTTPS에서 작업이 잘되는지 또는 더 중요한 것은 HTTPS에서 작동하는 방식을 빠르게 확인해야할 때가 많습니다. 온라인에서는 CSR(Certificate Sign Request)를 생성하고 해당 CSR을 자체로 서명하고 웹 서버의 구성을 수동으로 수정하여 해당 인증서를 사용하도록 만드는 방법을 보여주는 가이드가 많이 있습니다.\n\n이 기사에서는 어떤 것도 생성하거나 수동으로 편집하지 않고도 도커를 사용하여 자체 서명된 인증서가 있는 NGINX 컨테이너를 빠르게 실행하는 완전 자동화된 프로세스를 제시하겠습니다!\n\n# 보안 주의사항과 경고\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 자체 서명된 인증서는... 당신만 신뢰할 수 있습니다. 생산 환경에서 데이터를 제공하는 수단으로 사용할 수 없습니다. 그런 경우에는 적절한 인증서를 사용하세요.\n- 이 글에서 제시된 HTTPS로 콘텐츠를 제공하게끔 NGINX 구성은 작업을 수행하기 위한 최소한의 것입니다. 본격적인 TLS가 적용된 프로덕션 NGINX를 수정하려면 공식 가이드를 참고하세요.\n\n공개 키 암호화를 처음 시작하는 경우, 도움이 될 수 있는 소개 기사를 작성했습니다.\n\n# 설계 디자인\n\n빌드는 2단계 Docker 빌드로 설계되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_1.png\" /\u003e\n\n첫 번째 단계에서 Alpine Linux 이미지를 사용합니다. Alpine의 패키지 관리자인 APK를 사용하여 OpenSSL을 설치합니다. 다음 단계에서 OpenSSL을 사용하여 셀프 서명 인증서와 관련 개인 키를 생성합니다.\n\n두 번째 단계에서 NGINX 이미지를 사용합니다. 빌드는 이전 단계에서 생성된 인증서와 개인 키를 포함하도록 이미지를 수정하고 HTTPS를 활성화하기 위한 간단한 NGINX 구성을 작성합니다.\n\n# Dockerfile\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# syntax=docker/dockerfile:1\n# 이 Dockerfile을 빌드하려면 Docker BuildKit가 활성화되어 있어야 합니다.\n\n# 사용할 Alpine 및 NGINX 버전을 정의합니다.\nARG ALPINE_VERSION=3.17.3\nARG NGINX_VERSION=1.23.4\n\n# OpenSSL을 사용하기 위해 Alpine 기반 이미지를 준비합니다.\nFROM alpine:${ALPINE_VERSION} as alpine\nARG DOMAIN_NAME=localhost\nARG DAYS_VALID=30\n\nRUN apk add --no-cache openssl\nRUN echo \"${DAYS_VALID}일 동안 유효한 ${DOMAIN_NAME} 도메인을 위한 자체 서명 인증서를 생성합니다.\" \u0026\u0026 \\\n    openssl \\\n    req -x509 \\\n    -nodes \\\n    -subj \"/CN=${DOMAIN_NAME}\" \\\n    -addext \"subjectAltName=DNS:${DOMAIN_NAME}\" \\\n    -days ${DAYS_VALID} \\\n    -newkey rsa:2048 -keyout /tmp/self-signed.key \\\n    -out /tmp/self-signed.crt\n\n# 위에서 생성한 인증서를 사용하여 NGINX 기반 이미지를 준비합니다.\nFROM nginx:${NGINX_VERSION} as nginx\nCOPY --from=alpine /tmp/self-signed.key /etc/ssl/private\nCOPY --from=alpine /tmp/self-signed.crt /etc/ssl/certs\nCOPY \u003c\u003cEOF /etc/nginx/conf.d/default.conf\nserver {\n    listen 80;\n    listen [::]:80;\n    listen 443 ssl;\n    listen [::]:443 ssl;\n    ssl_certificate /etc/ssl/certs/self-signed.crt;\n    ssl_certificate_key /etc/ssl/private/self-signed.key;\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm;\n    }\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n}\nEOF\n```\n\n👉 위의 Dockerfile을 시도하기 전에 Docker BuildKit가 활성화되어 있는지 확인해주세요. BuildKit는 레거시 빌더를 대체하는 개선된 백엔드로, Docker 데스크톱 및 Docker Engine 버전 23.0부터 사용자들에게 기본 빌더로 제공됩니다.\n\n## Stage 1: 인증서 생성\n\n인증서 및 개인 키를 생성하기 위해 OpenSSL을 사용하며 필요한 모든 정보를 인수로 전달하여 대화형 모드가 아닌 모드에서 명령을 실행합니다. 다음과 같은 Docker ARG를 지정하여 이 단계를 자신의 요구에 맞게 조정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- DOMAIN_NAME: 이는 인증서가 유효한 도메인입니다. 이는 자체 서명된 인증서이므로 여기에 지정한 도메인 이름은 중요한 역할을 하지 않지만, 해당 인증서를 사용해야 하는 응용 프로그램이 있는 경우, 액세스할 리소스의 도메인 이름과 일치하도록 변경해야 할 수 있습니다. 빌드에 사용된 기본 도메인은 localhost입니다.\n- DAYS_VALID: 인증서가 유효한 일수입니다. 테스트를 완료할 수 있도록 충분히 큰 숫자를 사용하십시오. 빌드에 사용된 기본 유효 기간은 30일입니다.\n\n## 단계 2: 수정된 NGINX 이미지 생성\n\n이 단계에서는 이전 단계에서 생성된 인증서와 개인 키를 가져와 새로 생성된 이미지로 복사합니다. 또한 HTTPS를 활성화하기 위해 간단한 NGINX 구성을 생성하기 위해 heredoc를 사용합니다.\n\n직접 이미지 상에 다른 구성을 사용하려는 경우, heredoc를 자체 콘텐츠로 대체하거나 결과 이미지를 확장하여 자체 이미지에 추가할 수 있습니다. 이미지를 자체 구성 파일로 확장하는 경우, 해당 파일은 다음 위치에 배치해야 합니다.\n/etc/nginx/conf.d/default.conf.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이미지 빌드하기\n\n알파인 이미지와 NGINX 이미지는 매우 작기 때문에 빌드 속도가 정말 빠릅니다. 다음으로 빌드를 시작하세요:\n\n```bash\ndocker build . -t nginx-self-signed\n```\n\n![이미지](/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이미지 실행하기\n\n이미지를 실행할 때, Docker Engine이 실행 중인 컴퓨터에서 80번 포트를 HTTP용, 그리고 443번 포트를 HTTPS용으로 사용할 수 있도록 해 주세요. 아래 명령어를 사용하여 컨테이너를 시작할 수 있습니다:\n\ndocker run -p 80:80 -p 443:443 nginx-self-signed\n\n![NGINXwithSelf-SignedCertificateonDocker_3](/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이미지 테스트 중\n\n신뢰할 수 있는 curl을 사용해서 몇 가지 테스트를 해봅시다. 만약 도커 엔진이 로컬 호스트에서 실행되지 않는다면 localhost를 적절한 주소로 바꿔주셔야 합니다.\n\n## HTTP 접근\n\ncurl localhost\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Screenshot](/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_4.png)\n\n여기에 볼 건 별거 없어요. HTTP 접근은 예상대로 작동합니다.\n\n## HTTPS 접근\n\ncurl https://localhost\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_5.png\" /\u003e\n\n여기서 NGINX가 HTTPS 요청에 응답했지만 curl은 다음과 같은 오류로 처리를 거부했습니다:\n\ncurl: (60) SSL certificate problem: self signed certificate\n\n이것은 HTTPS를 위한 기본 TLS를 설정하는 데 사용된 자체 서명된 인증서가 컴퓨터에 의해 신뢰되지 않기 때문입니다. 그렇다면 어떻게 해야 할까요? 여기에는 몇 가지 다른 옵션이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 자체 서명된 인증서를 OS의 신뢰/인증서 저장소에 가져올 수 있습니다.\n- curl에 보안 인증서를 수락하도록 지시할 수 있습니다.\n\n보안 인증서를 수락하도록 curl에 요청해 봅시다:\n\ncurl https://localhost --insecure\n\n![이미지](/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ncurl은 이제 기초 리소스의 내용을 즐겁게 출력합니다.\n\n마찬가지로, HTTPS URL을 인터넷 브라우저로 열어보려고 하면 보안 경고가 표시됩니다. 실제 경고 메시지와 진행 방법은 각각 다른 인터넷 브라우저마다 다를 수 있습니다. Chrome에서는 다음과 같이 표시됩니다:\n\n![Chrome에서의 보안 경고](/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_7.png)\n\nChrome에서 '고급' 버튼을 클릭한 다음 'localhost로 진행(안전하지 않음)' 옵션을 클릭할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_8.png\" /\u003e\n\n# 추가 콘텐츠\n\n가기 전에, 여기서 생성한 이미지를 사용하여 여러분 자신의 콘텐츠와 함께 사용할 수 있는 몇 가지 추가 팁이 있습니다.\n\n## 1. 여러분 자신의 콘텐츠 제공\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본 NGINX 환영 페이지를 제공하는 것은 누구에게나 큰 가치가 없을 것 같아요. 자신의 콘텐츠로 사용자 정의 NGINX 이미지를 가리킬 수 있도록 로컬 폴더를 컨테이너에 마운트하면 됩니다:\n\n```js\ndocker run \\\n  -p 80:80 -p 443:443 \\\n  -v {YOUR-PATH}:/usr/share/nginx/html \\\nnginx-self-signed\n```\n\n## 2. 자신의 콘텐츠에 대한 역방향 프록시 구성\n\n컨테이너 내부에 콘텐츠를 마운트하고 싶지 않을 경우, NGINX를 구성하여 이미 실행 중인 다른 서버에 대한 역방향 프록시로 사용할 수 있습니다. 다음 코드 조각은 이러한 구성을 설정하는 데 도움이 되나요. 그러나 역방향 프록시는 아래의 간단한 예제보다 더 복잡한데, 실제로 프록시하는 내용에 따라 다양한 문제가 발생할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNGINX 설정 파일의 상단에 upstream 서버를 정의해주세요:\n\n```js\nupstream api-gateway {\n  server http://some-server:80;\n}\n```\n\nNGINX 설정 파일의 server 블록을 다음과 같이 업그레이드해주세요:\n\n```js\nlocation /api/ {\n    proxy_pass                http://api-gateway;\n    proxy_redirect            off;\n    proxy_set_header          X-Real-IP $remote_addr;\n    proxy_set_header          X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header          X-NginX-Proxy true;\n    proxy_ssl_session_reuse   off;\n    proxy_set_header Host     $http_host;\n    proxy_cache_bypass        $http_upgrade;\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 글에서는 자체 서명 인증서를 사용하는 NGINX 도커 컨테이너를 빠르게 설정하는 방법을 소개했습니다. 컴퓨터에 OpenSSL을 설치할 필요가 없으며 인증서를 생성하기 위해 openssl 명령을 실행할 필요가 없습니다. 모든 작업이 Docker 빌드의 일부로 실행됩니다.\n\n또한 결과물인 NGINX 이미지에 자신의 콘텐츠를 통합하는 두 가지 예제를 제공했습니다. 컨테이너 내에서 콘텐츠를 마운트하거나 이미 실행 중인 다른 서버로 역방향 프록시하는 방법 등이 있습니다.\n\n이 글을 읽어주셔서 감사합니다. 다음 글에서 다시 뵙기를 기대합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🔔 새 이야기를 발행할 때마다 알림을 받고 싶으세요? 제 콘텐츠는 항상 제가 본 것이나 일했던 것을 바탕으로 한 실용적인 기술 팁과 소프트웨어 엔지니어링 조언을 제공합니다:\nhttps://nmichas.medium.com/subscribe\n\n🚀 아직 Medium 회원이 아니신가요? 커피 한 잔 가격으로 매월 제 이야기에 액세스할 수 있습니다 (그리고 Medium의 수천 명의 다른 작가들의 이야기에도):\nhttps://medium.com/@nmichas/membership\n","ogImage":{"url":"/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_0.png"},"coverImage":"/assets/img/2024-06-19-NGINXwithSelf-SignedCertificateonDocker_0.png","tag":["Tech"],"readingTime":12},{"title":"편리한 클라우드 배포 Terraform과 GitHub Actions를 활용하여 AWS에서 NET API와 Angular 프론트엔드를 런칭하기 PART 23","description":"","date":"2024-06-19 12:54","slug":"2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23","content":"\n\u003cimg src=\"/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_0.png\" /\u003e\n\n# 소개\n\n이 기사에서는 이전 기사에서 시작한 설정을 계속할 것입니다: IaC 기본: Terraform 및 GitHub Actions를 사용한 RDS 배포. 목표는 AWS에서 완전히 기능하는 .NET 백엔드(API)를 구성하는 것입니다. 응용 프로그램은 공개적으로 액세스 가능하며 RDS 데이터베이스에 연결될 것입니다. 민감한 정보 검색에 Secrets Manager를 활용할 것입니다.\n\nPART 1에서 이미 다음을 설정했습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Terraform을 지원하기 위한 AWS 백엔드 (S3에 상태 파일, DynamoDB에 상태 잠금 기능 포함).\n- Terraform을 이용해 인프라를 배포하기 위한 GitHub Actions.\n- DBeaver를 사용하여 테스트된 공개적으로 접근 가능한 RDS 데이터베이스.\n\nPART 2에서는 다음을 다룰 예정입니다::\n\n- RDS, ECR 및 Secrets Manager를 포함한 인프라 저장소 설정.\n- Secrets Manager에 비밀을 전송하는 인프라 파이프라인 생성 (데이터베이스 호스트, 사용자, 비밀번호).\n- API용 Dockerfile 정의.\n- 어플리케이션을 위해 Docker 컨테이너를 실행하는 ECS 서비스 구성.\n- API를 노출시키기 위해 로드 밸런서 구현.\n\n이 글을 마치면 GitHub Actions와 Terraform을 이용해 CI/CD 파이프라인을 통해 AWS에서 .NET 백엔드를 완벽히 설정할 수 있게 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 인프라 구성하기\n\n나는 논리적 구성 요소를 별도의 저장소로 분리하기로 결정했습니다. 이 접근법은 구조를 읽기 쉽게 만들 뿐만 아니라 인프라스트럭처의 코드 (IaC) 정의를 단순화합니다.\n\n![이미지](/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_1.png)\n\n인프라 프로젝트는 자주 변경되지 않는 리소스를 만드는 것에 책임을 지기 때문에 분리됩니다. 이 프로젝트에서는 RDS, ECR 및 Secrets Manager의 생성을 구성했습니다. 파이프라인은 RDS 확장, ECR 또는 Secrets Manager 이름 변경과 같은 경우에 가끔 실행해야 할 수 있지만, 이러한 인스턴스는 드물 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 설정을 사용하여 개별 환경(개발, 스테이징 및 프로덕션과 같은)을 관리하는 데 상당한 잠재력이 있습니다. 그러나 이 기사는 이 측면을 다루지 않도록 중점을 두고 있습니다.\n\n# App.Infra 프로젝트\n\n이전에 언급했듯이, 인프라 프로젝트는 RDS, ECR 저장소 및 Secrets Manager(보강에 RDS 암호 저장)를 설정합니다. 이 분리는 인프라 관점에서 상대적으로 정적인 이러한 구성 요소 때문에 의도적입니다. 또한, ECR 저장소가 준비되어 있어야 하는 것이 중요합니다. Docker 이미지의 대상 역할을 합니다. 따라서 빌드 순서도 관련이 있습니다.\n\n이제 테라폼 파일로 직접 들어가 봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n공급업체 \"aws\" {\n  지역 = var.aws_region\n}\n\n리소스 \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n\n  tags = {\n    Name = \"main\"\n  }\n}\n\n리소스 \"aws_subnet\" \"main_subnet_1\" {\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = \"10.0.1.0/24\"\n  availability_zone = \"eu-north-1a\"\n\n  tags = {\n    Name = \"main-subnet-1\"\n  }\n}\n\n리소스 \"aws_subnet\" \"main_subnet_2\" {\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = \"10.0.2.0/24\"\n  availability_zone = \"eu-north-1b\"\n\n  tags = {\n    Name = \"main-subnet-2\"\n  }\n}\n\n리소스 \"aws_security_group\" \"rds_sg\" {\n  name        = \"rds_security_group\"\n  description = \"어디서나 접근 허용하는 RDS용 보안 그룹\"\n  vpc_id      = aws_vpc.main.id\n\n  ingress {\n    from_port   = 5432\n    to_port     = 5432\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  tags = {\n    Name = \"rds_security_group\"\n  }\n}\n\n리소스 \"aws_db_subnet_group\" \"default\" {\n  name       = \"main-subnet-group\"\n  subnet_ids = [aws_subnet.main_subnet_1.id, aws_subnet.main_subnet_2.id]\n\n  tags = {\n    Name = \"main-subnet-group\"\n  }\n}\n\n리소스 \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n}\n\n리소스 \"aws_route_table\" \"public\" {\n  vpc_id = aws_vpc.main.id\n\n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.main.id\n  }\n}\n\n리소스 \"aws_route_table_association\" \"subnet_association_1\" {\n  subnet_id      = aws_subnet.main_subnet_1.id\n  route_table_id = aws_route_table.public.id\n}\n\n리소스 \"aws_route_table_association\" \"subnet_association_2\" {\n  subnet_id      = aws_subnet.main_subnet_2.id\n  route_table_id = aws_route_table.public.id\n}\n\n리소스 \"aws_db_instance\" \"default\" {\n  allocated_storage    = 20\n  engine               = \"postgres\"\n  engine_version       = \"16.2\"\n  instance_class       = var.db_instance_class\n  db_name              = var.db_name\n  username             = var.db_username\n  password             = var.db_password\n  parameter_group_name = \"default.postgres16\"\n  skip_final_snapshot  = true\n  publicly_accessible  = true\n\n  vpc_security_group_ids = [aws_security_group.rds_sg.id]\n  db_subnet_group_name   = aws_db_subnet_group.default.name\n}\n\n리소스 \"aws_ecr_repository\" \"app_repository\" {\n  name = \"app-repo\"\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n  image_tag_mutability = \"MUTABLE\"\n}\n\n리소스 \"aws_secretsmanager_secret\" \"rds_secret\" {\n  name        = \"app-secrets-manager\"\n  description = \"APP 비밀\"\n}\n\n리소스 \"aws_secretsmanager_secret_version\" \"rds_secret_version\" {\n  secret_id     = aws_secretsmanager_secret.rds_secret.id\n  secret_string = jsonencode({\n    DB_HOST     = aws_db_instance.default.endpoint\n    DB_USER     = var.db_username\n    DB_PASSWORD = var.db_password\n    DB_NAME     = var.db_name\n  })\n}\n```\n\n위 글에서는 VPC 및 RDS 구성요소가 PART 1에서 다뤄졌습니다. 이제 ECR 및 Secrets Manager에 집중해 보겠습니다.\n\n## ECR 리포지토리\n\n```js\n리소스 \"aws_ecr_repository\" \"app_repository\" {\n  name = \"app-repo\"\n  image_scanning_configuration {\n    scan_on_push = true\n  }\n  image_tag_mutability = \"MUTABLE\"\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 블록은 Docker 이미지를 저장하기 위한 Elastic Container Registry (ECR) 리포지토리를 생성하며, 이미지 푸시 시 이미지 스캔이 활성화되어 있습니다.\n\n## Secrets Manager\n\n```js\nresource \"aws_secretsmanager_secret\" \"rds_secret\" {\n  name        = \"app-secrets-manager\"\n  description = \"APP secrets\"\n}\n\nresource \"aws_secretsmanager_secret_version\" \"rds_secret_version\" {\n  secret_id     = aws_secretsmanager_secret.rds_secret.id\n  secret_string = jsonencode({\n    DB_HOST     = aws_db_instance.default.endpoint\n    DB_USER     = var.db_username\n    DB_PASSWORD = var.db_password\n    db_name     = var.db_name\n  })\n}\n```\n\n이 블록은 Secrets Manager를 생성하고 그 안에 RDS 데이터베이스 자격 증명을 저장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n액션 정의는 기사의 이전 부분과 비교해 변경되지 않았습니다. 우리는 표준 경로를 실행합니다: AWS에 로그인 - `Init` - `Validate` - `Plan` - `Apply Terraform`. Github 액션을 활성화하고 실행합니다. 결과적으로 로컬 DB 클라이언트에서 RDS와 통신할 수 있어야 하며, AWS 콘솔에서 연결 문자열을 구축하기 위한 미리 입력된 시크릿이 포함된 Secrets Manager와 ECR(컨테이너 레지스트리)를 찾아야 합니다.\n\n## C#을 사용하여 Secrets Manager에 액세스\n\n어플리케이션의 보안을 보장하는 것은 인터넷에 노출되는 서비스를 개발하는 중요한 측면입니다. 코드나 환경 변수또는 Docker 컨테이너에 비밀번호를 저장하면 민감한 정보가 노출될 수 있습니다. 더 안전한 접근 방식은 민감한 데이터를 관리하기 위해 AWS Secrets Manager를 사용하는 것입니다.\n\n아래에서는 AWS Secrets Manager에 저장된 시크릿을 사용하여 PostgreSQL 연결 문자열을 구성하는 방법을 보여드리겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 AWSSDK.SecretsManager nuget을 다운로드해야 합니다. 작업이 완료되면 SecretsManagerService를 빌드해 봅시다:\n\n```js\nusing Amazon;\nusing Amazon.SecretsManager;\nusing Amazon.SecretsManager.Model;\n\nnamespace AppMonitor.AWS\n{\n    public class SecretsManagerService\n    {\n        private readonly IAmazonSecretsManager _secretsManager;\n\n        public SecretsManagerService(IAmazonSecretsManager secretsManager)\n        {\n            _secretsManager = secretsManager;\n        }\n\n        public async Task\u003cstring\u003e GetSecretValueAsync(string secretName)\n        {\n            var request = new GetSecretValueRequest\n            {\n                SecretId = secretName\n            };\n\n            var response = await _secretsManager.GetSecretValueAsync(request);\n            return response.SecretString;\n        }\n    }\n}\n```\n\n다음으로, DBConnectionStringProvider 클래스에서 SecretsManagerService를 사용합니다:\n\n```js\nusing Newtonsoft.Json.Linq;\nusing System.Configuration;\n\nnamespace AppMonitor.AWS\n{\n    public class AwsDatabaseConnectionStringProvider\n    {\n        private readonly SecretsManagerService _secretsManagerService;\n\n        public AwsDatabaseConnectionStringProvider(SecretsManagerService secretsManagerService)\n        {\n            _secretsManagerService = secretsManagerService;\n        }\n\n        public async Task\u003cstring\u003e GetConnectionStringAsync()\n        {\n            var secretValue = await _secretsManagerService.GetSecretValueAsync(\"app-secrets-manager\");\n            var secretJson = JObject.Parse(secretValue); //newtonsoft.json\n\n            var host = secretJson[\"DB_HOST\"].ToString();\n            var user = secretJson[\"DB_USER\"].ToString();\n            var password = secretJson[\"DB_PASSWORD\"].ToString();\n            var dbName = secretJson[\"DB_NAME\"].ToString();\n\n            return $\"Host={host};Port=5432;Database={dbName};User ID={user};Password={password};\";\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로, 우리 스타트업에서 서비스를 설정해야 합니다 (이 스니펫은 AWSSDK.Extensions.NETCore.Setup 너겟을 필요로 합니다):\n\n```js\n  context.Services.AddAWSService\u003cIAmazonSecretsManager\u003e();\n  context.Services.AddSingleton\u003cSecretsManagerService\u003e();\n  context.Services.AddSingleton\u003cAwsDatabaseConnectionStringProvider\u003e();\n```\n\n# .NET 앱을 위한 Docker 이미지 빌드\n\n도커는 가벼운 이식 가능한 컨테이너를 생성함으로써 응용 프로그램을 패키지화하고 배포하는 효율적인 방법을 제공합니다. 이러한 컨테이너는 쉽게 ECR로 푸시하고 AWS의 ECS 서비스로 배포할 수 있습니다. 아래는 우리 .NET 애플리케이션을 위한 Dockerfile입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nFROM mcr.microsoft.com/dotnet/aspnet:8.0 AS base\nWORKDIR /app\nEXPOSE 44360\n\nFROM mcr.microsoft.com/dotnet/sdk:8.0 AS build\nWORKDIR /src\n\nCOPY [\"AppMonitor/\", \"AppMonitor/\"]\nRUN dotnet restore \"TheApp/TheApp.csproj\"\n\nCOPY . .\n\nWORKDIR \"/src/TheApp\"\nRUN dotnet build \"TheApp.csproj\" -c Release -o /app/build\n\nFROM build AS publish\nRUN dotnet publish \"TheApp.csproj\" -c Release -o /app/publish\n\nFROM base AS final\nWORKDIR /app\nCOPY --from=publish /app/publish .\n\nENV ASPNETCORE_URLS=http://*:44360\nENTRYPOINT [\"dotnet\", \"TheApp.dll\"]\n```\n\n다음 부분에서는 ECS를 구성하여 이 Docker 컨테이너를 실행하고 API를 노출하는 로드 밸런서를 구현할 것입니다.\n\n## ECS 및 로드 밸런서 소개\n\nAmazon Elastic Container Service (ECS)는 Docker를 사용하여 컨테이너화된 응용 프로그램을 배포, 관리 및 확장하기 쉽게 만들어주는 완전관리형 컨테이너 오케스트레이션 서비스입니다. ECS를 활용하면 기본 인프라를 관리할 필요없이 응용 프로그램을 구축하는 데 집중할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로드 밸런서(LB)는 여러 대상(예: ECS 작업) 사이로 들어오는 응용 프로그램 트래픽을 분산하는 서비스입니다. 로드 밸런서는 트래픽을 건강한 대상으로 라우팅하고 부하를 균형있게 분배하여 리소스 활용을 최적화하여 고가용성과 신뢰성을 보장합니다.\n\n이 설정에서는 우리의 ECS 작업이 AWS Secrets Manager에 액세스하는 권한을 갖게되어 민감한 데이터의 안전한 관리를 보장합니다. 작업은 애플리케이션별 트래픽을 허용하도록 구성된 보안 그룹이 구성된 VPC에 배포될 것입니다. 애플리케이션 로드 밸런서(ALB)는 ECS 작업 간의 트래픽을 분산하여 부드럽고 신뢰할 수 있는 응용 프로그램 성능을 보장합니다.\n\n## ECS를 위한 Terraform 구성\n\n코드 예시\n\n# main.tf\n\nprovider \"aws\" {\nregion = \"eu-north-1\"\n}\n\ndata \"aws_vpc\" \"main\" {\nfilter {\nname = \"tag:Name\"\nvalues = [\"main\"]\n}\n}\n\n...\n\nresource \"aws_iam_role_policy\" \"ecs_task_secrets_policy\" {\nname = \"ecs-task-secrets-policy\"\nrole = aws_iam_role.ecs_task_execution_role.id\n\npolicy = jsonencode({\nVersion = \"2012-10-17\",\nStatement = [\n{\nEffect = \"Allow\",\nAction = [\n\"secretsmanager:GetSecretValue\"\n],\nResource = \"\\*\"\n}\n]\n})\n}\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# load_balancer.tf\n\nresource \"aws_lb\" \"app_lb\" {\n  name               = \"app-lb\"\n  internal           = false\n  load_balancer_type = \"application\"\n  security_groups    = [aws_security_group.ecs_sg.id]\n  subnets            = [data.aws_subnet.main_subnet_1.id, data.aws_subnet.main_subnet_2.id]\n\n  enable_deletion_protection = false\n}\n\nresource \"aws_lb_listener\" \"http_listener\" {\n  load_balancer_arn = aws_lb.app_lb.arn\n  port              = \"80\"\n  protocol          = \"HTTP\"\n\n  default_action {\n    type             = \"forward\"\n    target_group_arn = aws_lb_target_group.app_tg.arn\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_lb_target_group\" \"app_tg\" {\n  name     = \"app-tg\"\n  port     = 80\n  protocol = \"HTTP\"\n  vpc_id   = data.aws_vpc.main.id\n  target_type = \"ip\"\n\n  health_check {\n    interval            = 30\n    protocol            = \"HTTP\"\n    timeout             = 5\n    healthy_threshold   = 5\n    unhealthy_threshold = 2\n  }\n\n  lifecycle {\n    create_before_destroy = true\n  }\n}\n\nresource \"aws_ecs_cluster\" \"main\" {\n  name = \"main-cluster\"\n}\n\nresource \"aws_ecs_service\" \"app_service\" {\n  name            = \"app-service\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.app_task.arn\n  desired_count   = 1\n  launch_type     = \"FARGATE\"\n\n  network_configuration {\n    subnets         = [data.aws_subnet.main_subnet_1.id, data.aws_subnet.main_subnet_2.id]\n    security_groups = [aws_security_group.ecs_sg.id]\n    assign_public_ip = true\n  }\n\n  load_balancer {\n    target_group_arn = aws_lb_target_group.app_tg.arn\n    container_name   = \"app-container\"\n    container_port   = 44360\n  }\n\n  depends_on = [\n    aws_lb_listener.http_listener\n  ]\n}\n```\n\n## Provider and VPC Data Sources:\n\n- The aws provider is set to the eu-north-1 region.\n- Data sources are defined to fetch details of the existing VPC and subnets based on tags.\n\n## Security Group for ECS:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 보안 그룹 ecs_sg가 생성되어 HTTP, HTTPS 및 애플리케이션 트래픽 (포트 44360)을 허용하도록 설정되어 있습니다.\n\n## IAM 역할 및 인스턴스 프로필:\n\n- ECS 작업 실행 및 인스턴스 역할에 필요한 정책이 포함된 IAM 역할이 생성되었습니다.\n- 인스턴스 프로필이 생성되고 인스턴스 역할에 연결되었습니다.\n\n## 시작 구성 밑 오토 스케일링 그룹:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ECS 인스턴스를 위한 ECS 최적화 AMI로 시작 구성이 생성됩니다.\n- Auto Scaling 그룹이 ECS 인스턴스의 원하는 용량을 유지하도록 구성되어 있습니다.\n\n## ECR Repository:\n\n- ECR 저장소인 app-repo가 Docker 이미지를 가져오도록 참조됩니다.\n\n## ECS 작업 정의:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 작업 정의는 Docker 컨테이너 구성을 지정하는 것으로, 이미지, 포트 매핑 및 환경 변수를 포함합니다.\n- 작업에는 AWS Secrets Manager에 액세스할 수 있도록 IAM 정책이 있습니다.\n\n## 로드 밸런서 구성:\n\n- 어플리케이션 로드 밸런서(ALB)가 설정되어 있으며, 리스너 및 타겟 그룹을 사용하여 ECS 작업으로의 트래픽 관리가 이루어집니다.\n- 건강 점검이 구성되어 ALB가 건강한 인스턴스에만 트래픽을 라우팅하도록 합니다.\n\n## ECS 클러스터 및 서비스:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ECS 클러스터 main-cluster가 생성되었습니다.\n- ECS 서비스 app-service는 Fargate 런치 유형을 사용하도록 구성되어 있어, 자동 스케일링 기능을 갖춘 서버리스 운영이 보장됩니다.\n\n# Github 액션 정의 및 테스트\n\nGithub 액션의 워크플로우 정의는 간단하고 명확합니다. 도커 이미지 빌드 및 AWS 내 Elastic Container Registry로 푸시하는 것을 강조할 만한 유일한 사항입니다. YAML 정의로 들어가 봅시다:\n\n```js\nname: AWS로 배포\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 코드 가져오기\n        uses: actions/checkout@v2\n\n      - name: .NET Core 설정\n        uses: actions/setup-dotnet@v1\n        with:\n          dotnet-version: '8.0.x'\n\n      - name: 종속성 복원\n        run: dotnet restore src\n\n      - name: 빌드\n        run: dotnet build src --configuration Release --no-restore\n\n      - name: 게시\n        run: dotnet publish src --configuration Release --output ./output\n\n      - name: 도커 빌드 설정\n        uses: docker/setup-buildx-action@v1\n\n      - name: Terraform을 위한 AWS 자격 증명 구성\n        uses: aws-actions/configure-aws-credentials@v1\n        with:\n          aws-access-key-id: ${secrets.AWS_ACCESS_KEY_ID}\n          aws-secret-access-key: ${secrets.AWS_SECRET_ACCESS_KEY}\n          aws-region: ${secrets.AWS_REGION}\n\n      - name: Amazon ECR에 로그인\n        id: login-ecr\n        uses: aws-actions/amazon-ecr-login@v1\n\n      - name: 도커 이미지 빌드 및 푸시\n        run: |\n          REPOSITORY_URI=$(aws ecr describe-repositories --repository-names app-repo --query \"repositories[0].repositoryUri\" --output text --region eu-north-1)\n          docker build -t $REPOSITORY_URI:latest -f src/Dockerfile src\n          docker push $REPOSITORY_URI:latest\n        env:\n          AWS_REGION: eu-north-1\n\n      - name: Terraform 설정\n        uses: hashicorp/setup-terraform@v1\n        with:\n          terraform_version: 1.8.5\n\n      - name: Terraform 초기화\n        run: terraform init -input=false\n        working-directory: infra\n\n      - name: Terraform 계획 수립\n        run: terraform plan -input=false\n        working-directory: infra\n        env:\n          TF_VAR_db_password: ${secrets.DB_PASSWORD}\n          TF_VAR_aws_region: ${secrets.AWS_REGION}\n\n      - name: Terraform 적용\n        id: apply\n        run: terraform apply -auto-approve -input=false\n        working-directory: infra\n        env:\n          TF_VAR_db_password: ${secrets.DB_PASSWORD}\n          TF_VAR_aws_region: ${secrets.AWS_REGION}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상기 GitHub 액션 설정은 .NET 앱을 AWS로 쉽게 배포할 수 있도록 해주는 내용입니다. 이 설정에는 .NET Core 설정부터 의존성 복원, 앱 빌드 및 게시, 그리고 컨테이너화를 위한 Docker 통합까지 모두 다루는 여러 단계가 포함되어 있습니다. 또한 AWS 자격 증명을 처리하고 Docker 이미지를 Amazon ECR에 빌드 및 푸시하며, Terraform을 사용하여 인프라 구축도 수행합니다. 기본적으로 전체 프로세스를 자동화하여 배포가 완전히 간편해집니다.\n\n빌드가 성공적으로 완료되면 API의 URL을 얻기 위해 AWS 콘솔을 방문해보세요.\n\n![이미지](/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_2.png)\n\nDNS 이름을 가져와 브라우저에서 해당 URL을 열어보세요. 모든 것이 잘 되었다면 API 백엔드가 응답해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n조금 길었지만, Terraform을 사용하여 AWS에 컨테이너화된 .NET API를 배포하는 모든 중요한 단계를 다루었습니다. 이 가이드가 새 프로젝트를 처음부터 시작하거나 인프라 설정의 복잡성을 탐색하는 데 도움이 되기를 바랍니다. 화이팅!\n","ogImage":{"url":"/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_0.png"},"coverImage":"/assets/img/2024-06-19-EffortlessclouddeploymentLaunchNETAPIwithAngularFrontendonAWSUsingTerraformandGitHubActionsPART23_0.png","tag":["Tech"],"readingTime":21},{"title":"Ollama - Langchain을 사용해 챗봇 만들기, 도커로 배포하기","description":"","date":"2024-06-19 12:53","slug":"2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker","content":"\n## 생성적 AI 시리즈\n\n이 블로그는 생성적 AI에 관한 지속적인 시리즈이며 이전 블로그의 연장선입니다. 이 블로그 시리즈에서는 Ollama를 탐색하고 도커를 사용하여 분산 아키텍처에 배포할 수 있는 응용 프로그램을 구축할 것입니다.\n\nOllama는 강력한 언어 모델을 손쉽게 컴퓨터에서 실행할 수 있도록 도와주는 프레임워크입니다. Ollama 소개에 대해서는 2024년 2월에 A B Vijay Kumar에 의해 작성된 [Ollama — Brings runtime to serve LLMs everywhere. | by A B Vijay Kumar | Feb, 2024 | Medium](링크)를 참조해주세요. 이 블로그에서는 langchain 애플리케이션을 구축하고 도커에 배포할 것입니다.\n\n## Ollama를 위한 Langchain 챗봇 애플리케이션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLangshan을 사용하여 챗봇 애플리케이션을 개발해 보겠습니다. Python 애플리케이션에서 모델에 액세스하기 위해 간단한 Streamlit 챗봇 애플리케이션을 만들 것입니다. 이 Python 애플리케이션을 컨테이너에 배포하고 다른 컨테이너에서 Ollama를 사용할 것입니다. Docker-compose를 사용하여 인프라를 구축할 것입니다. 만약 Docker 또는 docker-compose를 사용하는 방법을 모르신다면, 계속 진행하기 전에 인터넷에서 몇 가지 자습서를 참고해 주세요.\n\n아래 그림은 컨테이너 간 상호 작용과 접근하는 포트를 보여주는 아키텍처를 보여줍니다.\n\n![아키텍처 그림](/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_0.png)\n\n컨테이너를 2개 생성할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Ollama 컨테이너는 모델을 저장하고 로드하기 위해 호스트 볼륨을 사용합니다 (/root/.ollama는 로컬 ./data/ollama로 매핑됩니다). Ollama 컨테이너는 내부적으로 11434로 매핑된 외부 포트인 11434에서 수신 대기합니다.\n- Streamlit 챗봇 애플리케이션은 내부적으로 8501로 매핑된 외부 포트인 8501에서 수신 대기합니다.\n  코딩을 시작하기 전에 Python 가상 환경을 설정하겠습니다.\n\n```shell\npython3 -m venv ./ollama-langchain-venv\nsource ./ollama-langchain-venv/bin/activate\n```\n\n다음은 streamlit 애플리케이션의 소스 코드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_1.png\" /\u003e\n\n제가 이전 블로그에서 작성한 것과 매우 유사한 소스 코드입니다. 이 코드가 어떻게 작동하는지에 대한 자세한 내용은 다른 블로그인 \"Retrieval Augmented Generation(RAG) - LlamaIndex를 사용한 문서용 챗봇\"을 참조하실 수 있어요. 주요 차이점은 Ollama를 사용하고 Ollama Langchain 라이브러리를 통해 모델을 호출한다는 점이에요 (이는 langchain_community의 일부입니다).\n\nrequirements.txt에서 종속성을 정의해 봅시다.\n\n\u003cimg src=\"/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_2.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Streamlit 애플리케이션의 도커 이미지를 빌드하기 위한 Dockerfile을 정의해 보겠습니다.\n\n![image](/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_3.png)\n\n우리는 베이스 이미지로 python 도커 이미지를 사용하고, /app이라는 작업 디렉토리를 생성합니다. 그런 다음 애플리케이션 파일을 해당 디렉토리로 복사하고, pip를 사용하여 모든 종속성을 설치합니다. 그 후에 포트 8501을 노출하고 Streamlit 애플리케이션을 시작합니다.\n\n아래에 표시된 대로 docker build 명령을 사용하여 도커 이미지를 빌드할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![docker_image_4](/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_4.png)\n\n도커 이미지가 빌드되었는지 확인할 수 있어야 합니다. 다음에 표시된 것처럼 `docker images` 명령어를 사용하세요.\n\n![docker_image_5](/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_5.png)\n\n이제 스트림릿 애플리케이션 및 올라마 컨테이너의 네트워크를 정의하는 docker-compose 구성 파일을 만들어보겠습니다. 이렇게 하면 두 애플리케이션이 상호 작용할 수 있습니다. 또한 위의 그림에서 보듯이 다양한 포트 구성을 정의할 것입니다. 올라마에 대해서는 모델들이 영구적으로 유지되도록 볼륨 매핑도 수행할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_6.png\" /\u003e\n\n도커 컴포즈 업 명령을 실행하면 어플리케이션을 실행할 수 있습니다. 도커 컴포즈 업을 실행하면 아래 스크린샷에 표시된 대로 두 컨테이너가 모두 실행되고 있는 것을 확인할 수 있어야 합니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_7.png\" /\u003e\n\n아래 스크린샷에 표시된 대로 도커 컴포즈 ps 명령을 실행하여 컨테이너가 실행 중인 것을 확인할 수 있어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image1](/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_8.png)\n\n올라마가 실행 중인지 확인하려면 아래 스크린샷에 표시된 대로 http://localhost:11434을 호출해야 합니다.\n\n![image2](/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_9.png)\n\n이제 아래에 표시된 대로 docker exec 명령을 사용하여 도커 컨테이너에 로그인하여 필요한 모델을 다운로드해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ndocker exec -it ollama-langchain-ollama-container-1 ollama run phi\n```\n\n우리는 모델 phi를 사용 중이므로 해당 모델을 가져와서 실행하여 테스트 중입니다. 아래 스크린샷을 참고하세요. phi 모델이 다운로드되고 실행을 시작할 것입니다 (-it 플래그를 사용하므로 샘플 프롬프트로 상호작용 및 테스트가 가능해집니다).\n\n\u003cimg src=\"/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_10.png\" /\u003e\n\n로컬 폴더 ./data/ollama에서 다운로드된 모델 파일 및 매니페스트를 확인할 수 있어야 합니다. 이 폴더는 내부적으로 컨테이너에 매핑되어 있으며(Ollama가 다운로드된 모델을 제공하기 위해 찾는 위치인 /root/.ollama에 매핑됨)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 변경한 테이블입니다.\n\n| `\u003cimg src=\"/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_11.png\" /\u003e`                                                                   |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Lets now run access our streamlit application by opening [http://localhost:8501](http://localhost:8501) on the browser. The following screenshot shows the interface |\n\n| `\u003cimg src=\"/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_12.png\" /\u003e`                                                                                                   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Lets try to run a prompt “generate a story about dog called bozo”. You shud be able to see the console logs reflecting the API calls, that are coming from our Streamlit application, as shown below |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 스크린샷에서 확인할 수 있듯이, 내가 보낸 프롬프트에 대한 응답을 받았어요.\n\n도커 컴포즈 다운을 호출하여 배포를 중지할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 스크린샷은 결과를 보여줍니다.\n\n![output](/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_15.png)\n\n여기 있습니다. 이 블로그를 준비하면서 랭체인과 함께 Ollama가 작동하고 Docker-Compose를 사용하여 Docker에 배포하는 것이 정말 즐거웠어요.\n\n도움이 되었기를 바랍니다. 더 많은 실험으로 돌아오겠습니다. 그 동안 즐기고 코딩하세요!!! 곧 다시 만나요!!!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 전체 소스 코드에 액세스할 수 있습니다. abvijaykumar/ollama-langchain (github.com)\n\n참고 자료\n\n- Ollama\n- Docker Compose 개요 | Docker 문서\n- Docker 문서\n- Ollama — LLM을 어디서나 제공하는 런타임을 제공합니다. | 작성자: A B Vijay Kumar | 2024년 2월 | Medium\n","ogImage":{"url":"/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_0.png"},"coverImage":"/assets/img/2024-06-19-OllamaBuildaChatBotwithLangchainOllamaDeployonDocker_0.png","tag":["Tech"],"readingTime":9},{"title":"원격 개발, 또는 메인프레임을 사랑하게 된 방법","description":"","date":"2024-06-19 12:50","slug":"2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe","content":"\n![2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_0](/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_0.png)\n\n리모트 서버에서의 개발은 생각보다 어렵지 않습니다. 사실 저렴한 VPS 도플릿이나 클러스터를 사용하는 것은 로컬 이진 해석기를 여러 개 사용하거나 Mac용 Docker를 사용하는 것보다 미쳤다고 할 정도의 혜택이 있습니다.\n\n2022년 업데이트: 요즘에는 님버스(Nimbus)만 사용합니다.\n\n여기에서 한 발 더 나아가서, 컨테이너 중심 환경에서 어떻게 작업하는지 배워보겠습니다. 여기서 우리는 완전한 네이티브 리눅스 성능과 17시간 배터리, 그리고 제로 팬 소음을 얻을 것입니다. 우리는 작은 도플릿 VPS를 임대하고, VSCode 및 JetBrains의 IntelliJ Idea CE를 통해 원격 개발 환경을 설정할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n항상 글이 너무 길어서 연구 과정을 이야기하는데, 읽기 싫다면 \"클라우드에서 로컬 개발 환경을 실행하세요. 생각한 것만큼 어렵지 않습니다\" 라는 것만 기억해 주세요. 여기에 목차가 있습니다:\n\n- 🐳 개발에서의 Docker\n  — Swapping and swinging\n  — Docker For Mac을 포기한 이유\n  — Parallels 모험\n- 💻 개발에서 얇은 클라이언트의 경우\n  — 가격\n  — 성능\n  — 학습 기회\n- 🛰 원격 개발 서버 설정\n  — 보안에 대한 메모\n  — 자동 생성\n- 🌍 원격 개발 기능이 있는 코드 편집기\n  — 서버에 액세스하기 위해 VSCode Remote 사용\n  — 원격 서버와 함께 JetBrains Projector 사용 방법\n\n# Docker에서 개발\n\n생산 환경에서 컨테이너를 사용하도록 설득하려고 하지 않을 것입니다. 그것은 이미 너무나 당연한 일입니다. 여기서 제가 살펴보고 있는 것은 Docker가 팀의 통합성과 생산성에 미치는 흔히 언급되지 않은 영향입니다. - 맥에서의 개발용 Docker.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n몇 년 전, 저는 꽤 큰 기업에서 꽤 큰 핵심 제품을 다루는 다양한 시니어도 함께하는 30명의 엔지니어 팀을 이끌었습니다. 시험적인 프로젝트로 Docker를 우리 프로덕션 환경에 (조심스럽게) 도입하는 것을 맡게 되었습니다.\n\n![이미지](/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_1.png)\n\n대부분 사람들이 Docker에 대해 이야기할 때, 그것이 프로덕션에 미치는 이점에 대해 얘기를 합니다. 그러나 누구도 팀에 어떤 영향을 미치는지에 대해 이야기하지 않습니다. 저는 개발에서 그것이 효과적이라는 것을 직접 경험했습니다. 오늘날 이것은 모든 개발자가 이해하고 사용해야 할 중요한 도구로 간주합니다.\n\n- 팀 내에서 평등화 작용을 합니다. 주니어들이 스택의 나머지에서 덜 고립되게 합니다. 시니어들은 이국적인 설정을 할 수 없습니다. 모두가 전체 스택을 더 잘 이해하고 덜 두려워하며 실험에 더 열려지게 됩니다.\n- 모든 엔지니어들에게 로컬을 프로덕션과 같은 환경으로 생각하도록 강제시킵니다. 어떤 꼼수도 허용되지 않습니다.\n- 설정 및 문서화를 추상화합니다. 앱 자체에 집중할 수 있게 합니다.\n- 그 결과, 공유된 비밀 및 데이터베이스 관리가 더 이상 yaml 파일을 잔뜩 다루고 구성 관련 문제를 처리하는 수동 작업이 아니었습니다.\n- 코드 편집기, 린터, 테스트, 종속성은 모두 애플리케이션과 같은 런타임에서 실행됩니다.\n- 로컬에서 많은 프로젝트를 한꺼번에 처리하기 쉬워졌습니다. 다른 팀의 엔지니어도 참여할 수 있습니다. 더 많은 협업, 멤버 교체 및 상호 교류가 이루어집니다.\n- 이제 코드 리뷰에 로컬 체크아웃, 테스트 실행 및 심지어 QA까지 포함됩니다.\n- 프로그램 코드 또는 설정 변경, 프로덕션 업그레이드 또는 잘못된 에셋 배치와 같은 지저분한 실천 방지합니다.\n- 그리고 더 많은 이점들이 있습니다...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드베이스의 일부로 최상위 레이어 또는 인프라를 유지하는 것은 모든 이해 관계자에게 도움이 됩니다. 이 방법으로 도구들을 서로 분리시키고 팀이 설정을 자유롭게 실험하고 매우 빨리 반복할 수 있게 합니다.\n\n저에게는 개발/운영 일치성은 인프라, 구조 또는 설정을 자유롭게 변경하고 장애 없이 배포할 수 있는 것을 의미합니다. 자동화된 다양한 테스트와 CI 파이프라인이 환경별로 동일한 동작을 할 것이라는 확신을 줍니다.\n\n내게 첫 번째 \"자랑스러운 아빠의 순간\"은 프론트엔드 엔지니어가 PR을 만들었을 때 발생했습니다. 거기에는 몇 가지 복잡한 빌드/자산 폴더와 모든 관련된 셸 스크립트를 스스로 이동했습니다. 그들이 한 해 전에 시도조차 하지 않았던 단계였습니다.\n\n이제 그들은 자신만의 스택을 소유하고 자랑스러워합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어쨌든, Docker가 좋은 성과를 냈습니다. 회사에서는 오늘날까지도 사용하고 있고, 제가 더 이상 그곳의 일원이 아니더라도, 그들이 널리 도입할 계획을 세우고 있다는 소식을 듣고 기뻤습니다.\n\n[![이미지](/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_2.png)](이미지 주소)\n\n## 교체와 전환\n\n2021년에 대한 영감을 줄만한 재미있는 전쟁 스토리 시간입니다...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n언젠가 오래 전에, 교수 블라디미르 렐리카닌은 저희 반에게 Git과 MAMP 환경 설정에 대해 가르치고 계셨어요. 농담으로 무언가 말씀하셨는데, 오늘까지 기억나는데요: \"새 컴퓨터에 앉아서 30분 이내에 완전히 설정이 되고 코딩을 시작하지 못하면 시간을 낭비하는 거예요. 무언가가 잘못되었다는 신호에요. 아마도 스택을 이해하지 못하고 있다는 거죠\".\n\n이제는 2021년인데, 5분 이내로 처리하고 싶네요. 그보다 더 빨리요.\n\n오래된 멘토이자 친구인 보리스 체라닉은 /Sites 폴더 전체를 Dropbox에 보관했어요. 이렇게 하면 모든 컴퓨터에서 단순히 모든 변경 사항이나 편집기 구성을 빠르게 반영할 수 있었죠.\n\n이제는 2021년이고, VPN과 SSH 키 뒤에 코드를 보관하는 게 더 좋을 것 같아요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2016년에는 3D 및 VR 작업을 많이 수행하는 회사에서 일했습니다. 제 동료 Kole는 모든 것을 Dropbox에 보관했습니다. 만약 그가 강력한 컴퓨터가 필요한 프로젝트를 작업 중이었다면, 그는 그냥 Cmd+S를 눌러 더 강력한 데스크탑으로 전환할 수 있었습니다.\n\n이제 2021년이 되어서 필요할 때 VPS의 규모를 확장하는 것이 더 좋습니다.\n\n## Docker For Mac을 버리게 된 이유\n\n내 30명의 엔지니어 팀을 기억하시나요? 모두에게 불행한 일이 되어버렸는데, Docker가 관련된 경우 Mac에서 코딩하는 성능과 일반적인 사용성에 만족스럽지 못했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n숙고하며 구멍 속으로 들어갈수록 더 어둡기만 했어요. 때로는 정말로 돌아갈 길이 없는 것 같아서 막막했죠. 회사로서는 200대의 우분투 컴퓨터를 사서 관련된 모두에게(그들의 코드베이스도 포함하여) 스위칭하는 법을 가르쳐야 했어요.\n\n저는 이 시리즈의 이전 두 부분에서 보았던 것처럼 문제를 해결할 방법을 찾았어요. 그러나 동시에, 제 우리가 부족한 도구로 인해 얼마나 많은 엔지니어링 에너지와 시간을 소비하는지를 더욱 명확하게 깨달았어요. 이제 저는 절대적으로 확신을 가지게 되었어요. 모든 도구, 편집기, 코드베이스, 이진파일을 반복가능하게(그리고 확장 가능하게) 설정하는 쉬운 방법이 있다면, 저희의 속도를 최소 30% 이상 높일 수 있을 것이라고, 그 영향이 학습과 멘토링에 미칠 효과가 시간이 지남에 따라 나타날 것이라고 확신합니다.\n\n회사에서 새로운 도구를 챔피언하는 것은 수월해야 해요. 이전 시스템보다 훨씬 좋아야 해요. 그 차이가 명확해야 해요. 그 이유가 널리 이해되어야 해요. Docker for Mac을 저희 팀에 도입하는 것은 이런 것들 중 한 가지도 아니었어요.\n\n## Parallels 모험\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대처 전략 중 하나(파트#2에 개요되어 있음)은 D4M을 제거하고 새로운 도커 컨텍스트를 위한 하이퍼바이저로 Parallels VM을 사용하는 것이었습니다. 이를 통해 우분투용으로 개발된 Parallels 팀이 여러 해 동안 개발한 모든 멋진 최적화 기능을 활용할 수 있었습니다.\n\n이로써, 우리는 어떤 꼼수도 쓰지 않고 작동하는 도커를 가지게 되었고, 개발/프로덕션 둘 간의 일치성을 되찾았습니다. 성능은 거의 네이티브 수준이었고, 대표적으로 어려운 Symfony 캐시나 노드 모듈 폴더에 대한 완전한 동기화에도 그랬습니다.\n\n이 모두를 고려할 때, 우리는 코드를 VM에 유지하고, 그곳에서 실행시키며, 우리 컴퓨터와 동기화시키고 있습니다. 호스트에서 코드 편집기를 실행하고 있습니다. 도커 컨텍스트, DNS, 포트 포워딩, 원격 해석기와 같은 기교를 사용합니다. SSH와 HTTP를 통해 그것과 소통합니다. VM은 우리 호스트 관점에서 원격 머신입니다.\n\n그러므로 한 가지 의문이 제기됩니다 — 이미 많은 어려움을 겪고 이러한 모든 도구를 사용하고 있는데, 왜 우리는 VM을 완전히 제거하지 않고 그냥 그것을 원격 위치로 보내고, 멋지고 강력한 곳에 연결하여 같은 도구를 사용하지 않는지요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_3.png\" /\u003e\n\n# 개발에서 얇은 클라이언트 사용 사례\n\nMVP 시간이네요! DigitalOcean에서 가장 저렴한 드롭렛을 구입했고, SSH 키를 만들고, 몇 개의 Elixir 저장소를 다운로드하고 그들의 도커 프로젝트를 시작했어요. 좋아, 예상대로 잘 작동했어요, 이제 뭘 해야 할까요?\n\n빠르게 VSCode 인스턴스를 SSH를 통해 드롭렛에 연결하고 원격 폴더를 선택했어요. 코드를 편집하고 페이지를 다시로드했어요. 좋아, 충분히 잘 작동하네요, 예상대로요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_4.png)\n\n## 가격\n\n원격 개발 방법의 가격은 노트북을 구매하는 것과 비슷합니다. 시장에서 절대 최고의 노트북을 구할 수 있습니다 — 저렴한 M1 MacBook Pro. 프로젝트 및 팀 구성원에 따라 다르지만, 약 500달러에서 1500달러 정도를 절약했습니다.\n\n이제 드롭렛이나 EC2 인스턴스를 임대하고, 매월 15달러부터 50달러까지 지불합니다. 업타임만 지불한다면 훨씬 적게 지불할 수 있습니다. 그래도 가장 비싼 것을 가정해보면, 50달러입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서, 우리가 처음으로 저축한 돈은 이제 VPS 공급업체에 매월 작은 지불로 연중에 걸쳐 분할될 것입니다(절대 최악의 경우).\n\n일년이 지나가고, 혹은 두 해, 혹은 석 년이 지나가도 여전히 지출이 급증하지 않고 사람들은 새로운 컴퓨터가 필요하지 않습니다. Mac은 능력을 유지하는 시간으로 유명합니다. 더 심각한 프로젝트를 마주했나요? 그러면 드롭렛을 확장하세요!\n\n## 성능\n\n내 현재 노트북은 BTO MacBook입니다. 미친 듯이 $4000에 가까운 가격을 태웠죠. 원격 개발 세계에서, 저는 배터리가 오래 가고 열이 덜 발생하는 $900의 M1 기계와 제 노트북보다 훨씬 강력한 드롭렛을 구입했습니다. $3000 할인으로 더 나은 두 가지 도구를 얻었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_5.png)\n\n물론 어느 기준에서도 인상적한 160GB의 RAM과 40개의 CPU 코어로 확장 가능한 드롭렛이 있습니다. 30분 안에 ML을 훈련해야 한다면, 그 유명한 Turbo 버튼을 눌러 몬스터 드롭렛을 생성해보세요.\n\nEC2 인스턴스는 심지어 더 나은 성능을 자랑합니다 (다만 관리하고 예측하기 어려울 수 있습니다). GPU 최적화된 작업 부하를 사용하거나 운영 업무 시간을 기준으로 청구 금액을 절약할 수 있는 매우 구체적인 인스턴스를 사용할 수 있습니다.\n\n숙련도가 충분하다면 기존 k8s 클러스터에 연결하고 이미 사용 가능한 다른 서비스를 사용할 수도 있습니다. 이에 대해 자세히 모르지만 Telepresence와 같이 해당 목적에 맞춘 특수 도구가 있다는 것은 여러해 전부터 알고 있습니다. 그렇지 않으면 DigitalOcean 관리 클러스터를 생성해보세요. 1클릭/무난한 작업으로 간단합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_6.png\" /\u003e\n\n요즘에는 제 노트북 CPU 사용량이 항상 20%를 넘지 않고 온도도 34도에서 안정적으로 유지되고 있어요. 이제 무리없이 무릎 위에 올려두고 사용할 수 있고, 한 번도 충전기를 꽂지 않고도 하루 종일 일할 수 있어요. 개발 활동보다 크롬이 더 많은 배터리를 소비하니 (광고: 그래서 저는 Safari를 사용하는 것을 추천해요).\n\n\u003cimg src=\"/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_7.png\" /\u003e\n\n## 학습 기회\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 사람들은 주니어들이 이것을 받아들이기가 어려울 것이라고 할지도 모릅니다. 하지만 제 경험상 시니어 개발자들이 저항을 표했지만, 주니어들은 실제로 아주 빨리 이해했어요. 그들은 CLI 사용에 조금 더 배워야 할 수도 있고, 때로는 전체 서버를 망칠 수도 있지만 — 그러니까 뭐요? 로컬 머신과는 다르게, 새로운 서버를 생성하고, 단 둘만에 다시 트랙에 올라갈 수 있어요.\n\n그리고 이것은 엄청난 학습 기회입니다. 모든 형태와 크기의 개발자들이 실제 서버에서 운전대를 잡게 될 거예요! 그들은 SSH 사용하는 법, 자신의 코드가 어디에 저장되어 있는지, docker가 그에 어떻게 맞는지 등을 이해하게 될 거예요.\n\n이것은 어떤 사람들에게는 그렇게 중요하지 않아 보일 수 있지만, 저는 프론트엔드 개발자가 이 개념을 이해하는 것이 코드 페어링 워크샵보다 크로스폴리네이션 전략으로서 더 가치 있다고 주장할 거예요. 그리고 한 번만 배우면 돼요.\n\n# 원격 개발 서버 설정하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n업데이트 16.11.2021: 이후로 저는 새로운 워크박스를 생성해야 할 때 사용하는 Readme 파일을 조금 작성하기 시작했습니다. 언젠가는 자동화할 거지만, 지금은 매우 대략적인 Readme.md를 제공해요.\n\n제가 좋아하는 것은 간단함입니다. DigitalOcean 패널에 접속하고 새로운 드롭렛을 생성하세요. 최신 Ubuntu나 다른 것들 중 마음에 드는 것을 선택하세요. 지불할 크기를 선택하세요. 요즘에는 일반적으로 4 CPU 사이즈를 사용하지만, 실제로는 조금 과잉이에요.\n\n![이미지](/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_8.png)\n\n한 달에 20달러에 2 CPU는 꽤 좋은 거래에요. 충분한 RAM이 있어서 yarn 설치가 영원히 걸리지 않거나, 의존성 트리 계산 중에 Garbage Collection 한계에 부딪혀서 compose 설치가 실패하지 않아요. 여분의 돈이 있다면, 8GB/4CPU 설정을 추천합니다. 그 가치가 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가장 가까운 데이터 센터를 선택해주세요. 지연 시간은 별다른 문제가 없지만, 왜 안 하시겠어요! 옵션이 제공된다면 SSH 키와 모니터링을 삽입해주세요. 귀여운 이름을 지어서 만들어보세요!\n\nSSH를 통해 VPS에 액세스하고, SSH 키를 생성하여 GitHub 계정에 추가해주세요. 귀하의 저장소를 복제할 수 있어야 하므로 GitHub에 추가해야 합니다.\n\n패키지 목록을 업데이트하고, 시스템을 업그레이드하고, git, zip, docker 및 docker-compose와 같은 일반 소프트웨어를 설치해주세요.\n\n## 보안에 대한 참고사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정 중에 SSH 키를 추가하지 않았다면, 구글링해보세요. DigitalOcean에는 그것을 하는 방법과 비밀번호 인증을 비활성화하는 방법에 대한 많은 자습서가 있어요.\n\n이 목적으로 root 사용자를 사용하는 것을 좋아해요. 이것이 금기시되고 표식화된 주제라는 것을 알지만, 특정 사용 사례에서 여기서 더 이상 나아가는 필요성은 전혀 없어요. 기억하세요, 이 특정 기계는 아무것도 실행하지 않으며 공개적으로 접근할 수 없어요.\n\n블로그 글 등의 리소스가 있는데 이들은 이러한 서버를 공급하고 제품 서버를 보호하는 방식과 동일하게 보호합니다.\n\n저의 겸손한 의견으로는 이는 필요하지 않아요. SSH 키가 충분한 보호가 될 거에요 (안전하게 보관한다면요). 누군가가 HTTP로 공격하거나 스크랩을 하길 우려한다면, ufw에서 IP 주소를 화이트리스트에 추가하세요. 회사로서 이것을 읽는다면, 아마도 이미 회사 VPN을 가지고 계실 텐데, DigitalOcean에서 사설 네트워크를 생성하세요. 이에 대해 여전히 걱정이 된다면, DigitalOcean에 몇 가지 아이디어가 있는 것 같아요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 자동 생성물\n\nDO에는 HTTP API, 테라폼 지원 및 심지어 앤서블 스크립트 지원이 있습니다. 회사나 기업에서 이 워크플로우를 다루고 있다면, 이 시점에서 기본 스냅샷 이미지를 만들고 필요할 때마다 작은 드롭릿을 생성합니다.\n\n사실, 휴가를 떠날 때 계획할 때는 비슷한 프로세스를 수행합니다. — 머신의 스냅샷을 만들고, 그런 다음 파괴합니다. 이렇게하면 보관할 수 있고, 비용을 지불할 필요가 없습니다.\n\n# 원격 개발 기능이 있는 코드 편집기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2021년이고 편집기들이 이 필요성을 알아보기 시작했다. 언제나 그래왔듯이, 오래된 학교의 편집기인 emacs와 vim은 이미 기본 설정으로 이 설정을 지원한다. 왜냐하면 그들을 droplet이나 컨테이너 내에서 실행할 수 있기 때문에 이 설정에 이미 액세스할 수 있다고!\n\n최근 편집기들로 넘어올 때 (나는 아주 늦게 채택했기 때문에 냉소적인 미소를 짓는 중), VSCode를 사용하는 것을 권할 것이다. 원격 편집 기능이 있고, 그 주변의 전체 아키텍처가 내가 하는 일에 더 적합하다.\n\n## 서버에 액세스하려면 VSCode 원격 사용\n\nVSCode에는 내장된 \"원격 컨테이너에 연결\" 기능이 있습니다. 이 기능은 실제 편집기를 생성하고 컨테이너 내의 네이티브 인터프리터와 직접 작업할 수 있게 해줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 할 일은 VSCode를 사용하여 원격 VPS에 SSH 워크스페이스로 연결하는 것입니다. .vscode/workspace.code-workspace 위치에 새 파일을 만들어 해당 폴더를 여러 프로젝트의 루트로 정의해야 합니다. 여기에는 표준 vscode 설정을 포함할 수도 있습니다. 예시는 다음과 같습니다:\n\n```js\n{\n \"folders\": [\n  {\n   \"path\": \"..\"\n  }\n ],\n \"settings\": {\n  \"remote.autoForwardPorts\": false,\n  \"workbench.editor.labelFormat\": \"medium\",\n  \"workbench.colorCustomizations\": {\n   \"activityBar.activeBackground\": \"#1f6fd0\",\n   \"activityBar.activeBorder\": \"#ee90bb\",\n   \"activityBar.background\": \"#1f6fd0\",\n   \"activityBar.foreground\": \"#e7e7e7\",\n   \"activityBar.inactiveForeground\": \"#e7e7e799\",\n   \"activityBarBadge.background\": \"#ee90bb\",\n   \"activityBarBadge.foreground\": \"#15202b\",\n   \"statusBar.background\": \"#1857a4\",\n   \"statusBar.foreground\": \"#e7e7e7\",\n   \"statusBarItem.hoverBackground\": \"#1f6fd0\",\n   \"statusBarItem.remoteBackground\": \"#c92121\",\n   \"statusBarItem.remoteForeground\": \"#d3d3d3\",\n   \"titleBar.activeBackground\": \"#1857a4\",\n   \"titleBar.activeForeground\": \"#e7e7e7\",\n   \"titleBar.inactiveBackground\": \"#1857a499\",\n   \"titleBar.inactiveForeground\": \"#e7e7e799\"\n  }\n },\n \"extensions\": {\n  \"recommendations\": [\n   \"hashicorp.terraform\",\n   \"ms-azuretools.vscode-docker\",\n   \"eamodio.gitlens\",\n   \"k--kato.intellij-idea-keybindings\",\n   \"mutantdino.resourcemonitor\",\n   \"ow.vscode-subword-navigation\",\n   \"redhat.vscode-yaml\",\n   \"mikestead.dotenv\",\n   \"ms-vscode-remote.remote-containers\",\n   \"ckolkman.vscode-postgres\",\n   \"mohsen1.prettify-json\",\n   \"buianhthang.xml2json\"\n  ]\n }\n}\n```\n\n여기서 터미널에 액세스하여 프로젝트를 클론하거나 시작할 수 있습니다. 그러나 여기에서는 편집을 진행하지 않습니다. 편집은 컨테이너 내부에서 수행됩니다.\n\n컨테이너화된 앱을 시작하고, 쉘 파일, 도커 또는 도커 컴포즈가 됐던, 실행 중인 컨테이너에 \"Attach to a Running Container\" 기능을 사용하여 편집을 원하는 런타임을 포함한 컨테이너를 선택합니다. 이렇게 하면 해당 프로젝트가 있는 새 창이 열리며, 해당 프로젝트의 모든 설정과 린트가 표시됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nVSCode는 표준 .vscode 구성 파일에서 내린 모든 결정을 존중해줍니다. 그래서 보통처럼 자유롭게 사용할 수 있어요! 이러한 파일들은 일반적으로 프로젝트 내부에 커밋되어 프로젝트에 대해 모든 팀 멤버가 동일한 규칙과 에디터 설정을 사용하도록 보장합니다. 의존성과 규칙을 추가하는 방법을 아래 예시를 참고하세요:\n\n```js\n$ cat .vscode/extensions.json\n{\n    \"recommendations\": [\n        \"jakebecker.elixir-ls\",\n        \"pgourlain.erlang\",\n        \"mutantdino.resourcemonitor\",\n        \"mikestead.dotenv\",\n        \"eamodio.gitlens\"\n    ]\n}\n```\n\n제 편집 작업 흐름이 어떻게 보이는지 빠르게 살펴볼까요? 이를 비디오로 설명하는 게 조금 더 쉽겠지만, 괜찮으시겠지요?\n\n이것이 저에게 다른 프로젝트를 이동하고 시작하고 중지하고 파일을 이동하며 도트파일, 설정 파일 또는 컨테이너를 만드는 매우 좋은 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 docker-compose를 통해 프로젝트를 시작할 수 있습니다. 서로 다른 편집기 창을 서로 다른 컨테이너에 연결할 수 있습니다.\n\n프로젝트 특정 창에서는 해당 런타임과 파일 시스템에 대한 접근이 가능합니다. 이는 편집기 내의 모든 린팅 및 구문 분석이 동일한 런타임으로 수행된다는 것을 의미합니다. 저는 호스트 머신이나 VPS에 node를 로컬로 설치하지 않았습니다. Intellisense가 정상적으로 작동합니다.\n\n원한다면 두 런타임을 동일한 컨테이너에 유지할 수 있습니다. 하지만 저는 이들을 분리하는 것을 강력히 권장합니다.\n\n재미를 위해, 동일한 VPS에서 동시에 다른 클라이언트를 위한 완전히 다른 프로젝트를 시작해 보죠. 해당 프로젝트는 elixir로 실행되며 다른 컨테이너나 그들의 런타임에 대해 전혀 알지 못합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 VSCode 창마다 실제로 각 프로젝트 및 해당 런타임에 대해 매우 특화되고 간소화되어 있다는 것을 의미합니다. 각각이 서로 다른 설정(색상도 다름)을 가지고 있으며, 프로젝트의 로컬 .vscode 파일을 준수하고 서로 다른 일련의 확장 기능이 실행됩니다. Out of the box.\n\n## 원격 서버와 함께 JetBrains Projector를 사용하는 방법\n\n업데이트: 이 방법은 더 이상 진행하지 않기로 결정했습니다. macOS에서는 키 바인딩이 때때로 랜덤하게 작동하지 않는 것 같은 버그가 발생합니다.\n\nJetBrains는 다른 아이디어를 가지고 있습니다. Docker 컨테이너 내에서 편집기를 생성한 다음, Projector 앱이나 브라우저를 사용하여 연결하는 방법을 허용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n편집기는 프로젝트의 컨테이너 내에서 실행되지 않습니다. 대신 호스트에서 실행되며 호스트의 파일시스템 개요에 액세스할 수 있습니다. VPS에 직접 이진 파일로 설치하거나 Docker를 통해 별도의 컨테이너로 생성할 수 있습니다.\n\n여기서의 작업 흐름은 드롭렛에 연결하여 프로젝트를 시작하고, Docker 컨테이너 기반 편집기를 시작하는 것입니다. 모든 파일이 VPS 호스트와 동기화되어 있기 때문에 편집기는 VPS 파일 시스템에서 파일을 편집할 수 있습니다.\n\n그러나 JetBrains는 원격 인터프리터 사용을 가능하게 하는 데 많은 투자를 했기 때문에 모든 \"두꺼운\" 편집기가 원격 컨테이너 내에서 실행 중에 실행을 사용할 수 있습니다. 이는 편집기가 앱 실행과 동일한 런타임을 사용할 수 있는 능력이 있음을 의미합니다. 편집기는 컨테이너에 연결하고 편집기가 수행하는 컴파일에 대한 실행 시간을 사용할 수 있게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Example image](/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_10.png)\n\n상상할 수 있겠지만, 이 방법에는 몇 가지 단점이 있습니다. 관리하기 어려울 뿐만 아니라 개발자가 코드를 컨테이너를 먼저 보는 관점을 보는 것만큼 깔끔하지 않습니다. 그러나 이 접근 방식은 로컬 에디터에서 했던 것과 매우 비슷합니다.\n\n저는 JetBrains 제품을 오랫동안 사용해왔습니다. 그들이 얼마나 부피가 크고 압도적인지 항상 싫어했지만, 동시에 PHP, Ruby, Java 또는 Python을 다룰 때에는 더 좋은 IDE가 없다는 것을 직접 경험했습니다. 그러나 지난 몇 년간 특히 Python 및 PHP에서는 VSCode로 점점 더 많이 기울어졌습니다. 제 기능을 잃는 것이 어떻게든 개발의 용이성으로 보상된다는 점 때문입니다.\n\n따라 주셔서 감사합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저에게 귀하의 생각을 듣고 싶습니다. 완벽하지는 않지만, 지금까지 만들어본 최고의 설정입니다.\n\n배포하기 쉽고, 확장하기 쉽고, 파괴하기 쉽고, 사용하기 쉽습니다.\n\n한 가지 확실한 것은 이를 둘러싼 도구들은 앞으로 점점 더 나아질 것이며, 우리는 이를 통해 얻을 수밖에 없습니다!\n\n다음에 뵙겠습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_0.png"},"coverImage":"/assets/img/2024-06-19-RemotedevelopmentorHowIlearnedtostopworryingandlovetheMainframe_0.png","tag":["Tech"],"readingTime":21},{"title":"스프링 부트 개발자를 위한 도커에 오신 것을 환영합니다","description":"","date":"2024-06-19 12:47","slug":"2024-06-19-WelcometoDockerforSpringBootDevelopers","content":"\n![Docker](/assets/img/2024-06-19-WelcometoDockerforSpringBootDevelopers_0.png)\n\n현대 소프트웨어 아키텍처에서 컨테이너는 선택사항에서 필수 요소로 전환되어 가고 있습니다. 다양한 플랫폼에서 소프트웨어를 이주하고 실행하는 민첩한 방법을 제공하여 전통적인 웹 서버 모델에 비해 속도, 이식성, 확장성 등의 혜택을 제공합니다. 이러한 작고 유연한 컨테이너는 더 큰이고 적응력이 덜한 세팅을 대체하며 특히 마이크로서비스를 향상시킵니다.\n\n본 문서는 Docker를 소개하며, 주요 클라우드 제공업체와의 호환성을 위해 선택된 컨테이너 기술입니다. Docker 기본 사항 및 Maven을 사용한 Spring Boot에서 Docker 실행 및 이미지 작성과 같은 실용적 작업에 대해 다룹니다.\n\n# Docker란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커는 2013년 Solomon Hykes에 의해 개발된 널리 사용되는 오픈 소스 컨테이너 엔진입니다. 초기에는 편리성으로 인식되었지만, 응용 프로그램 내에서 컨테이너를 관리하고 시작하는 데 중요한 도구로 진화하여 가상 머신(VM)과 같은 하드웨어 할당 대신 물리적 머신에서 자원 공유를 가능케했습니다.\n\nIBM, Microsoft, Google 등 주요 기업들의 지원으로 인해 도커는 소프트웨어 개발자들을 위한 필수 도구로 부상했습니다.\n\n서버, REST API 및 명령줄 인터페이스(CLI)로 구성된 Docker Engine은 도커 시스템의 핵심을 형성하여 서버 간에 컨테이너 배포를 용이하게 합니다.\n\n# 도커 엔진 구성 요소\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본 구성 요소는 다음과 같습니다:\n\n- Docker 데몬: Docker 이미지를 생성하고 관리하는 서버(dockerd)로, REST API 및 CLI로부터 명령을 받습니다.\n- Docker 클라이언트: 사용자는 Docker 클라이언트를 통해 Docker와 상호 작용하며, 이 클라이언트는 데몬에 명령을 전송합니다.\n- Docker 레지스트리: Docker 이미지를 저장하는 곳으로, 공개(예: Docker 허브) 또는 비공개 레지스트리 옵션이 있습니다.\n- Docker 이미지: Docker 컨테이너를 생성하는 지침을 포함하는 읽기 전용 템플릿으로, 레지스트리에서 가져오거나 Dockerfile을 사용하여 새 이미지를 만들 수 있습니다.\n- Docker 컨테이너: 'docker run' 명령을 사용하여 Docker 이미지에서 만들어지며, 응용 프로그램 및 환경을 호스팅하며 Docker API 또는 CLI를 통해 관리할 수 있습니다.\n- Docker 볼륨: Docker 컨테이너에서 생성되고 사용되는 데이터에 대한 우선적인 저장 메커니즘으로, Docker API 또는 CLI를 통해 관리할 수 있습니다.\n- Docker 네트워크: 컨테이너가 통신을위한 여러 네트워크에 연결되도록 허용하며, 다섯 가지 네트워크 드라이버 유형이 있습니다: bridge, host, overlay, none 및 macvlan.\n\n# Dockerfiles\n\nDockerfile은 Docker 이미지를 자동으로 생성하고 구성하는 지침을 포함하는 텍스트 파일입니다. Linux와 유사한 명령을 사용하여 이미지 생성을 간소화하고 가독성을 향상시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDockerfile을 생성한 후에는 Docker 이미지를 빌드하기 위해 docker build 명령을 실행합니다. 그런 다음, Docker 이미지가 준비되면 실행 명령을 사용하여 컨테이너를 생성합니다.\n\n가장 일반적인 Dockerfile 명령어:\n\n- FROM: 빌드 프로세스를 시작하는 기본 이미지를 지정합니다.\n- LABEL: 이미지에 메타데이터를 키-값 쌍 형식으로 추가합니다.\n- ARG: 사용자가 docker build 명령을 사용하여 빌더로 전달할 수 있는 변수를 정의합니다.\n- COPY: 호스트 시스템에서 파일이나 디렉토리를 Docker 이미지로 복사합니다.\n- ADD: COPY와 비슷하지만 원격 URL을 가져오고 tar 파일의 자동 추출과 같은 추가 기능을 지원합니다.\n- VOLUME: 볼륨 마운트를 생성합니다.\n- RUN: 이미지 빌드 중에 명령을 실행합니다.\n- CMD: 컨테이너가 시작될 때 실행할 기본 명령을 지정합니다.\n- ENTRYPOINT: 컨테이너가 실행 가능으로 설정됩니다.\n- ENV: 컨테이너 내에서 환경 변수를 설정합니다.\n\n# Docker Compose\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDocker Compose은 여러 컨테이너 애플리케이션을 관리하기 위한 도구입니다. 단일 YAML 파일을 사용하여 서비스를 정의하고 제어하며, 간단한 명령을 사용하여 전체 애플리케이션 스택을 시작하고 중지하고 관리할 수 있습니다.\n\nDocker Compose 사용 방법:\n\n- docker-compose.yml이라는 YAML 구성 파일을 생성합니다.\n- docker-compose config로 파일을 유효성 검사합니다.\n- docker-compose up을 사용하여 서비스를 시작합니다.\n\n샘플 docker-compose.yml 파일은 데이터베이스와 애플리케이션과 같은 서비스를 정의합니다. 명령어는 다음과 같습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이미지를 빌드하고 서비스를 시작하려면 `docker-compose up -d`를 사용하세요.\n- 배포 정보를 확인하려면 `docker-compose logs`를 사용하세요.\n- 컨테이너 목록을 보려면 `docker-compose ps`를 사용하세요.\n- 서비스를 중지하려면 `docker-compose stop`을 사용하세요.\n- 모든 컨테이너를 중지하고 제거하려면 `docker-compose down`을 사용하세요.\n\n다음은 MySQL 및 Redis와 함께 Spring Boot 애플리케이션을 위한 Docker Compose YAML 파일(docker-compose.yml)의 예시입니다:\n\n```yaml\nversion: \"3.8\"\n\nservices:\n  spring-boot-app:\n    image: spring-boot-image:latest\n    ports:\n      - \"8080:8080\"\n    depends_on:\n      - mysql-db\n      - redis-cache\n    environment:\n      SPRING_DATASOURCE_URL: jdbc:mysql://mysql-db:3306/database_name\n      SPRING_DATASOURCE_USERNAME: $MYSQLDB_USERNAME\n      SPRING_DATASOURCE_PASSWORD: $MYSQLDB_PASSWORD\n      SPRING_REDIS_HOST: redis-cache\n\n  mysql-db:\n    image: mysql:latest\n    ports:\n      - \"3306:3306\"\n    environment:\n      MYSQL_ROOT_PASSWORD: mysql_root_password\n      MYSQL_DATABASE: database_name\n      MYSQL_USERNAME: $MYSQLDB_USERNAME\n      MYSQL_PASSWORD: $MYSQLDB_PASSWORD\n\n  redis-cache:\n    image: redis:latest\n    ports:\n      - \"6379:6379\"\n```\n\n이 파일에서:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- spring-boot-app은 Spring Boot 애플리케이션을 위한 서비스입니다.\n- mysql-db는 MySQL 데이터베이스를 위한 서비스입니다.\n- redis-cache는 Redis 캐시를 위한 서비스입니다.\n\n각 서비스를 위한 이미지(image)를 정의하고 필요한 포트(ports)를 노출시키며, 데이터베이스 연결 세부 정보를 위한 환경 변수(environment)를 설정합니다.\n\nSpring Boot 앱은 MySQL과 Redis에 의존하며(dependes_on), Spring Boot 앱보다 먼저 시작되도록 합니다.\n\n# Spring Boot으로 Docker 이미지 만들기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSpring Boot 2.3에서는 Spring Boot 애플리케이션용 Docker 이미지를 만드는 간단하고 효율적인 방법을 소개했습니다. 기존에는 Docker 이미지를 Dockerfile 및 docker build 명령을 사용하여 만들었지만, 이 방법은 몇 가지 단점이 있었습니다.\n첫째로 Spring Boot이 생성한 fat jar에 의존했기 때문에, 특히 컨테이너 환경에서 부팅 시간에 영향을 줄 수 있습니다. 이를 해결하기 위해 jar 파일의 폭발된 내용을 포함할 수 있습니다.\n둘째로 Docker 이미지는 계층으로 구성됩니다. Spring Boot fat jar을 사용하면 모든 애플리케이션 코드와 타사 라이브러리가 하나의 계층으로 묶입니다. 이는 작은 코드 변경이라도 전체 계층을 다시 빌드해야 한다는 것을 의미합니다.\n이미지를 빌드하기 전에 jar 파일을 폭파시키면 애플리케이션 코드와 타사 라이브러리가 별도 계층으로 구성됩니다. 이를 통해 Docker의 캐싱 메커니즘을 활용할 수 있습니다. 결과적으로 코드 변경이 발생하면 해당 계층만 재빌드하면 되어 효율성이 크게 향상되고 빌드 시간이 줄어듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSpring Boot 2.3에서 소개된 두 가지 새로운 기능은 이미지 작성 기술을 개선하는 데 도움이 되었습니다: Buildpacks와 Layered jars support.\n\n## Buildpacks\n\nBuildpacks는 Docker 이미지 작성을 간편화하여 필요한 프레임워크 및 응용 프로그램 종속성을 자동으로 제공하여 Dockerfile이 필요하지 않도록합니다. Spring Boot에서는 Maven과 Gradle이 buildpacks를 지원하여 간편한 이미지 생성을 가능하게합니다.\n\n예를 들어, Maven을 사용하여 pom.xml 파일을 변경하지 않고 다음을 실행합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n./mvnw spring-boot:build-image -Dspring-boot.build-image.imageName=myorg/app\n```\n\nGradle를 사용하는 경우:\n\n```js\n./gradlew bootBuildImage --imageName=myorg/app\n```\n\n첫 번째 빌드는 컨테이너 이미지 및 JDK를 다운로드해야 하기 때문에 시간이 오래 걸릴 수 있지만, 그 이후의 빌드는 빠릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령어는 먼저 표준 Fat Jar를 빌드한 다음 Docker 이미지 생성을 시작합니다. Packeto 빌더를 사용하여 클라우드 네이티브 빌드팩을 구현합니다. 이는 프로젝트를 분석하고 필요한 프레임워크 및 라이브러리(예: Spring Boot)를 식별하여 이미지에 추가합니다.\n\n이후의 빌드는 Docker의 레이어링을 활용하여, 애플리케이션 코드만 변경될 때에는 빌드 시간을 단축할 수 있습니다. 이 효율성은 빌드팩을 통해 도커 이미지를 생성하는 데 간편하고 빠른 옵션으로 만들어줍니다.\n\n## 계층화된 JARS\n\nSpring Boot은 jar에 레이어 인덱스 파일을 추가하는 것을 지원합니다. 이 인덱스는 레이어 목록과 해당 레이어에 포함되어야 하는 jar의 부분을 제공합니다. 인덱스의 레이어 목록은 Docker/OCI 이미지에 추가할 순서로 정렬됩니다. 기본적으로 다음 레이어가 지원됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 종속성\n- spring-boot-loader\n- snapshot-dependencies\n- application\n\n다음은 layers.idx 파일의 예시를 보여줍니다:\n\n```js\n- \"dependencies\":\n  - BOOT-INF/lib/library1.jar\n  - BOOT-INF/lib/library2.jar\n- \"spring-boot-loader\":\n  - org/springframework/boot/loader/launch/JarLauncher.class\n  - ... \u003cother classes\u003e\n- \"snapshot-dependencies\":\n  - BOOT-INF/lib/library3-SNAPSHOT.jar\n- \"application\":\n  - META-INF/MANIFEST.MF\n  - BOOT-INF/classes/a/b/C.class\n```\n\n이 레이어링은 응용 프로그램 빌드 간에 얼마나 자주 변경될 수 있는지에 따라 코드를 분리하는 데 사용됩니다. 라이브러리 코드는 빌드 간에 변경될 가능성이 낮기 때문에 캐시로부터 레이어를 재사용할 수 있도록 자체 레이어에 배치됩니다. 응용 프로그램 코드는 빌드 간에 변경될 가능성이 더 높기 때문에 별도의 레이어에 격리됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDocker 이미지를 만드는 데 이것을 어떻게 활용할 수 있는지 살펴보겠습니다.\n\n- 계층화된 JAR 생성: 먼저 pom.xml 파일의 Spring Boot Maven 플러그인에 계층 구성을 추가하세요. 아래는 예시 스니펫입니다:\n\n```js\n\u003cplugin\u003e\n  \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n  \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e\n  \u003cconfiguration\u003e\n    \u003clayers\u003e\n      \u003cenabled\u003etrue\u003c/enabled\u003e\n    \u003c/layers\u003e\n  \u003c/configuration\u003e\n\u003c/plugin\u003e\n```\n\n- JAR 재빌드: pom.xml을 구성한 후에는 mvn clean package를 사용하여 Spring Boot JAR을 재빌드하여 새로운 계층화된 JAR을 생성하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플리케이션의 루트 디렉토리로 이동한 다음 다음 명령어를 실행하여 레이어와 그 순서를 표시하세요:\n\n```js\njava -Djarmode=layertools -jar target/app.jar list\n```\n\n- 레이어 도구(jar 모드)를 사용하여 jar 파일을 실행하세요:\n\n```js\n$ java -Djarmode=layertools -jar app.jar\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Dockerfile 생성하기: Docker 이미지에 이러한 레이어들을 포함하는 가장 쉬운 방법은 Dockerfile을 사용하는 것입니다:\n\n```js\nFROM eclipse-temurin:17-jre as builder\n\nWORKDIR application\nARG JAR_FILE=target/*.jar\nCOPY ${JAR_FILE} application.jar\nRUN java -Djarmode=layertools -jar application.jar extract\n\nFROM eclipse-temurin:17-jre\nWORKDIR application\n\nCOPY --from=build application/dependencies/ ./\nCOPY --from=build application/spring-boot-loader/ ./\nCOPY --from=build application/snapshot-dependencies/ ./\nCOPY --from=build application/application/ ./\n\nENTRYPOINT [\"java\", \"org.springframework.boot.loader.JarLauncher\"]\n```\n\n이 Dockerfile에서는 우리의 fat jar를 별도의 레이어로 분리하고 각 레이어를 Docker 이미지에 추가하는 방법을 제시했습니다. COPY 명령을 사용할 때마다 Docker 이미지에 새로운 레이어가 생성됩니다.\n\n- Docker 이미지 빌드하기: 위의 Dockerfile이 현재 디렉토리에 있다고 가정하면, 도커 이미지는 docker build . 명령을 사용하여 빌드할 수 있습니다. 또는 다음 예시와 같이 애플리케이션 jar 파일의 경로를 지정할 수도 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n$ docker build --build-arg JAR_FILE=path/to/app.jar .\n```\n\n# Jib을 사용하여 Java 컨테이너 빌드하기\n\nJib은 구글이 개발한 Java 도구로 Java 앱을 위한 Docker 이미지를 쉽게 빌드할 수 있습니다. Dockerfile을 작성할 필요도 없고 시스템에 Docker를 설치할 필요도 없어요.\n\nJib은 의존성, 리소스, 클래스와 같은 애플리케이션을 구별하는 레이어로 구성하고 Docker 이미지 레이어 캐싱을 이용하여 변경 사항만 다시 빌드하는 방식으로 빌드를 빠르게 유지합니다. Jib의 레이어 구조와 작은 베이스 이미지는 전체 이미지 크기를 작게 유지하여 성능과 이식성을 향상시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n배포하기 전에 Docker 저장소에 대한 로컬 인증 설정을 하는 것이 매우 중요합니다. 예를 들어 DockerHub 자격 증명을 .m2/settings.xml 파일에 포함할 수 있습니다. 그러나 이 파일에 암호를 평문으로 저장하는 것은 권장되지 않습니다.\n\n```js\n\u003csettings\u003e\n  ...\n  \u003cservers\u003e\n    ...\n    \u003cserver\u003e\n      \u003cid\u003eregistry.hub.docker.com\u003c/id\u003e\n      \u003cusername\u003e내_사용자명\u003c/username\u003e\n      \u003cpassword\u003e{내_시크릿}\u003c/password\u003e\n    \u003c/server\u003e\n  \u003c/servers\u003e\n\u003c/settings\u003e\n```\n\nid 필드가 이 자격 증명이 지정된 레지스트리 서버와 일치하는지 확인하세요.\n\nJib를 사용하여 Docker Hub에 배포하려면 jib-maven-plugin이나 그와 동등한 Gradle을 사용할 수 있습니다. 간단히 다음과 같은 명령을 실행하면 됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmvn compile com.google.cloud.tools:jib-maven-plugin:3.1.1:build -Dimage=$IMAGE_PATH\n```\n\n예를 들어, 이미지를 DockerHub에 업로드하려면 $IMAGE_PATH를 registry.hub.docker.com/my-repo/my-app과 같은 값으로 설정하세요.\n\n이 명령은 앱의 Docker 이미지를 빌드하고 DockerHub로 푸시합니다. Google Container Registry나 Amazon Elastic Container Registry와 같은 다른 레지스트리에도 비슷한 방식으로 이미지를 업로드할 수 있습니다.\n\n## 추가 커스터마이징\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJib 빌드를 Dockerfile과 비슷한 방식으로 사용자 정의할 수 있습니다. 이는 환경 변수를 추가하는 등의 방식입니다. 아래는 그 방법입니다:\n\n```js\n\u003cproject\u003e\n  ...\n  \u003cbuild\u003e\n    \u003cplugins\u003e\n      ...\n      \u003cplugin\u003e\n        \u003cgroupId\u003ecom.google.cloud.tools\u003c/groupId\u003e\n        \u003cartifactId\u003ejib-maven-plugin\u003c/artifactId\u003e\n        \u003cversion\u003e3.1.1\u003c/version\u003e\n        \u003cconfiguration\u003e\n          \u003cto\u003e\n            \u003cimage\u003e${IMAGE_PATH}\u003c/image\u003e\n          \u003c/to\u003e\n          \u003ccontainer\u003e\n            \u003cenvironment\u003e\n              \u003cENV_VAR\u003eVALUE\u003c/ENV_VAR\u003e\n            \u003c/environment\u003e\n          \u003c/container\u003e\n        \u003c/configuration\u003e\n      \u003c/plugin\u003e\n      ...\n    \u003c/plugins\u003e\n  \u003c/build\u003e\n  ...\n\u003c/project\u003e\n```\n\n이 변경으로 Maven 명령을 간소화할 수 있습니다:\n\n```js\nmvn compile jib:build\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n옵션으로 Docker를 설치한 경우, 로컬 Docker 설치로 빌드할 수 있습니다. 이렇게 하면 이미지를 다른 로컬 컨테이너처럼 검사하거나 실행할 수 있습니다:\n\n```js\nmvn compile jib:dockerBuild\n```\n\n# 결론\n\nDocker는 현대 소프트웨어 개발에 있어 필수 요소가 되었습니다. 민첩성과 확장성을 제공합니다. 본 문서에서는 Docker의 기초를 소개하고 Maven을 사용하여 Spring Boot 앱용 이미지를 생성하는 방법을 알아보았습니다. Spring Boot 2.3은 효율적인 이미지 생성을 위해 Buildpacks와 Layered Jars를 도입하였습니다. Google의 Jib는 Java 앱을 위한 Docker 이미지 생성을 간단하게 해줍니다. 이러한 도구들을 활용하면 배포를 간소화하고 생산성을 향상시킬 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-WelcometoDockerforSpringBootDevelopers_0.png"},"coverImage":"/assets/img/2024-06-19-WelcometoDockerforSpringBootDevelopers_0.png","tag":["Tech"],"readingTime":16},{"title":"컨테이네라이제이션의 힘을 발휘하기 데이터 과학자들이 도커와 쿠버네티스를 배워야 하는 이유","description":"","date":"2024-06-19 12:44","slug":"2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes","content":"\n데이터 과학 분야가 계속 발전함에 따라, 전문가들이 최신 도구와 기술에 대해 최신 정보를 학습하는 것이 점점 더 중요해지고 있습니다. 이 중 가장 중요한 두 가지는 Docker와 Kubernetes입니다. 이 두 도구는 소프트웨어 응용 프로그램을 개발하고 배포하는 방식을 변화시켰습니다. 그렇다면 이 도구들은 정확히 무엇이고, 데이터 과학자에게 어떤 이점을 제공할까요?\n\n이 글에서는 Docker와 Kubernetes에 대한 포괄적인 소개를 제공하겠습니다. 그들의 주요 기능과 이점에 대해 개요를 제공할 것입니다. 또한 이 두 기술 간의 차이를 탐구하고, 데이터 과학자가 두 기술을 모두 학습해야 하는 이유를 살펴볼 것입니다. 이 글을 마치면 컨테이너화와 오케스트레이션이 데이터 과학자로서 더 효율적으로 일할 수 있는 방법에 대한 확고한 이해를 갖게 될 것입니다.\n\n![이미지](/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_0.png)\n\n## 목차:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도커에 대한 포괄적인 소개\n  1.1. 도커란 무엇인가요?\n  1.2. 컨테이너란 무엇인가요?\n  1.3. 도커 도구 및 용어\n  1.4. 도커의 장점\n- 쿠버네티스에 대한 포괄적인 소개\n  2.1. 쿠버네티스란 무엇인가요?\n  2.2. 쿠버네티스를 통한 컨테이너 오케스트레이션\n  2.3. 쿠버네티스의 역할은 무엇인가요?\n  2.4. 쿠버네티스의 장점\n- 도커와 쿠버네티스의 차이\n- 데이터 과학자로서 쿠버네티스와 도커를 왜 배워야 할까요?\n  4.1. 데이터 과학자로서 도커를 배워야 하는 이유는 무엇인가요?\n  4.2. 데이터 과학자가 데브옵스 팀이 있는 상황에서 도커를 배워야 하는가\n  4.3. 데이터 과학자로서 도커를 배우는 장점은?\n  4.4. 데이터 과학자가 쿠버네티스를 배워야 하는가?\n\n만약 무료로 데이터 과학 및 기계 학습을 공부하고 싶다면, 다음 자료를 확인해보세요:\n\n- 스스로 데이터 과학 및 기계 학습을 배울 수 있는 무료 대화형 로드맵. 여기에서 시작하세요: [https://aigents.co/learn/roadmaps/intro](https://aigents.co/learn/roadmaps/intro)\n- 데이터 과학 학습 자료를 위한 검색 엔진 (무료). 즐겨찾기에 추가하고, 완료된 기사를 표시하고, 학습 노트를 추가하세요. [https://aigents.co/learn](https://aigents.co/learn)\n- 멘토와 학습 커뮤니티의 지원을 받아 처음부터 데이터 과학을 배우고 싶나요? 무료로 이 스터디 서클에 가입하세요: [https://community.aigents.co/spaces/9010170/](https://community.aigents.co/spaces/9010170/)\n\n데이터 과학 및 인공 지능 분야에서 경력을 시작하고 싶지만 어떻게 시작해야 할지 모르겠다면, 데이터 과학 멘토링 세션과 장기적인 경력 멘토링을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 멘토링 세션: [링크](https://lnkd.in/dXeg3KPW)\n- 장기 멘토링: [링크](https://lnkd.in/dtdUYBrM)\n\n무제한으로 계속 학습하려면 5달러에 미디엄 멤버십 프로그램에 가입하세요. 아래 링크를 사용해 가입하면 추가 비용 없이 회원비의 일부가 저에게 전달됩니다.\n\n# 1. Docker의 포괄적 인트로덕션\n\n![이미지](/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1.1. 도커란 무엇인가요?\n\n도커는 개발자가 컨테이너를 구축, 배포 및 실행하는 데 도움이 되는 상용 컨테이너화 플랫폼 및 런타임입니다. 도커는 간단한 명령어와 단일 API를 통해 자동화된 클라이언트-서버 아키텍처를 사용합니다.\n\n도커를 사용하면 개발자는 도커 파일(Dockerfile)을 작성하여 컨테이너화된 응용 프로그램을 만들 수 있습니다. 도커는 이러한 컨테이너 이미지를 빌드하고 관리하기 위한 일련의 도구를 제공하며, 개발자가 응용 프로그램을 일관적이고 재현 가능한 방식으로 패키지화하고 배포하는 것을 더 쉽게 만듭니다.\n\n이러한 컨테이너 이미지들은 Kubernetes, Docker Swarm, Mesos 또는 HashiCorp Nomad와 같은 컨테이너를 지원하는 어떤 플랫폼에서도 실행할 수 있습니다. 도커의 플랫폼은 개발자가 이러한 컨테이너 이미지를 생성하고 관리하기 쉽도록하며, 다양한 환경에서 응용 프로그램을 빌드하고 배포하는 프로세스를 간소화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커는 컨테이너화된 애플리케이션을 패키징하고 배포하는 효율적인 수단을 제공하지만, 대규모로 컨테이너를 관리하고 실행하는 것은 상당한 어려움을 야기할 수 있습니다. 여러 서버 또는 클러스터 간에 컨테이너를 조정하고 예약하고, 다운타임을 유발하지 않고 애플리케이션을 배포하며, 컨테이너 건강 상태를 모니터링하는 것만 몇 가지 복잡성 중 일부에 해당합니다.\n\n이러한 도전 과제를 해결하기 위해 Kubernetes, Docker Swarm, 메소스, HashiCorp Nomad 등의 오케스트레이션 솔루션이 등장했습니다. 이러한 플랫폼은 조직이 많은 수의 컨테이너 및 사용자를 관리하고, 리소스 할당을 최적화하며, 인증 및 보안을 제공하고, 다중 플랫폼 배포를 지원하는 등의 능력을 제공합니다. 컨테이너 오케스트레이션 솔루션을 활용함으로써 조직은 컨테이너화된 애플리케이션 및 인프라를 보다 쉽고 효율적으로 관리할 수 있습니다.\n\n현재 도커 컨테이너화는 마이크로소프트 윈도우 및 애플 맥OS와도 호환됩니다. 개발자는 어떤 운영 체제에서도 도커 컨테이너를 실행할 수 있으며, 아마존 웹 서비스(AWS), 마이크로소프트 애저, IBM 클라우드 등 주요 클라우드 제공업체 대부분은 도커로 컨테이너화된 애플리케이션을 구축, 배포 및 실행하는 데 도움이 되는 특정 서비스를 제공합니다.\n\n## 1.2. 컨테이너란 무엇인가?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_2.png)\n\n컨테이너는 코드, 라이브러리, 시스템 도구 및 설정을 포함하여 응용 프로그램을 실행하는 데 필요한 모든 것이 포함된 가볍고 휴대 가능한 실행 가능한 소프트웨어 패키지입니다.\n\n컨테이너는 컨테이너의 내용과 구성을 정의하는 이미지에서 생성되며, 호스트 운영 체제 및 동일한 시스템의 다른 컨테이너로부터 격리됩니다.\n\n이 격리는 가상화 및 프로세스 격리 기술을 사용하여 가능하며, 이를 통해 컨테이너는 호스트 운영 체제의 하나의 인스턴스의 자원을 공유하면서 응용 프로그램을 실행하는 안전하고 예측 가능한 환경을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컨테이너는 소프트웨어 개발 및 배포에서 널리 사용되는데, 응용 프로그램 관리를 간소화하고 확장성을 향상시키며 인프라 비용을 줄일 수 있기 때문에 매력적입니다.\n\nLinux 커널은 프로세스 격리 및 가상화 기능을 제공하여 컨테이너를 실현 가능하게 합니다. 이러한 기능에는 프로세스 간에 리소스를 할당하는 Cgroups와 프로세스의 다른 시스템 리소스나 영역에 대한 액세스를 제한하는 네임스페이스가 포함되어 있습니다.\n\n이러한 기능을 활용하면 다양한 응용 프로그램 구성 요소가 호스트 운영 체제 인스턴스의 리소스를 공유할 수 있으며, 하이퍼바이저가 단일 하드웨어 서버의 CPU, 메모리 및 기타 리소스를 여러 가상 머신(VM)이 공유하는 방식과 유사합니다.\n\n결과적으로 컨테이너 기술은 VM의 모든 기능과 이점(응용 프로그램 격리, 비용 효율적인 확장성 및 처분 가능성을 포함)을 제공하는 동시에 중요한 추가 혜택을 제공합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 더 가벼운 무게: 컨테이너는 필요한 운영 체제 프로세스와 종속성만 포함하여 애플리케이션 코드를 실행하는 반면, 가상 머신(VM)과는 큰 차이가 있습니다. 이로 인해 컨테이너는 일반적으로 메가바이트로 측정되며, VM은 기가바이트 저장 공간을 필요로 할 수 있는 반면, 컨테이너는 훨씬 작습니다. 또한, 컨테이너는 하드웨어 리소스를 더 효율적으로 활용하며 VM보다 훨씬 빨리 시작할 수 있습니다.\n\n- 개발자 생산성 향상: 컨테이너를 사용하면 애플리케이션을 한 번 개발하고 다양한 환경에 심플하게 배포할 수 있어서 이동성과 적응성이 뛰어납니다. VM과 비교했을 때 컨테이너는 배포하기도, 프로비저닝하기도, 다시 시작하기도 더 간단하고 빠릅니다. 결과적으로 CI/CD(지속적 통합/지속적 배포) 파이프라인 구현에 뛰어난 선택지가 됩니다. 이는 팀이 빠르게 개발, 테스트, 애플리케이션 출시할 수 있도록 도와주어 Agile 및 DevOps 방법론을 실천하는 개발팀에 적합합니다. 컨테이너는 빠른 소프트웨어 개발, 테스트, 배포를 촉진하기 때문에 중단이 적고 최적 생산성을 제공합니다.\n\n- 자원 효율성 향상: 컨테이너를 사용하면 개발자는 VM을 사용할 때보다 동일한 하드웨어에서 응용 프로그램 복사본을 여러 배 더 많이 실행할 수 있습니다. 이로 인해 클라우드 비용을 절감할 수 있습니다.\n\n## 1.3. Docker 도구 및 용어\n\n- DockerFile: 모든 Docker 컨테이너는 Docker 컨테이너 이미지를 빌드하는 방법에 대한 지침이 포함된 간단한 텍스트 파일로 시작합니다. DockerFile은 Docker 이미지 생성 프로세스를 자동화합니다. 이는 Docker 엔진이 이미지를 조립하기 위해 실행하는 명령줄 인터페이스(CLI) 명령어 목록입니다. Docker 명령어 목록은 방대하지만 표준화되어 있습니다: Docker 작업은 내용, 인프라, 또는 다른 환경 변수에 관계없이 동일하게 작동합니다.\n\n- Docker Image: Docker 이미지는 실행 가능한 애플리케이션 소스 코드뿐만 아니라 모든 도구, 라이브러리 및 종속성을 포함하고 있습니다. Docker 이미지를 실행하면 컨테이너의 한 인스턴스(또는 여러 인스턴스)가 됩니다. Docker 이미지를 처음부터 만들 수 있지만 대부분의 개발자는 이러한 이미지를 일반적인 저장소에서 다운로드합니다. 동일한 베이스 이미지로부터 여러 Docker 이미지를 만들고 그들의 스택에서 일반적인 사항을 공유할 수 있습니다.\n- Docker 컨테이너: Docker 컨테이너는 Docker 이미지의 실시간 실행 인스턴스입니다. Docker 이미지는 읽기 전용 파일이지만, 컨테이너는 실행 가능한 일회성 내용입니다. 사용자는 이와 상호 작용할 수 있으며, 관리자는 Docker 명령어를 사용하여 설정 및 조건을 조정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커는 개발자가 간단한 명령어를 사용하여 이러한 네이티브 컨테이너화 기능에 액세스할 수 있도록 하고, 작업을 절약하는 응용 프로그램 프로그래밍 인터페이스(API)를 통해 자동화할 수 있습니다. 도커는 다음을 제공합니다:\n\n- 향상된 및 매끄러운 컨테이너 이식성: 도커 컨테이너는 수정 없이 모든 데스크톱, 데이터 센터 또는 클라우드 환경에서 실행됩니다.\n- 더 가벼우면서 더 세부적인 업데이트: 여러 프로세스를 하나의 컨테이너 내에서 결합할 수 있습니다. 이를 통해 애플리케이션을 구축하고 있는 동안 그 중 하나의 부분이 업데이트나 수리를 위해 중단되더라도 계속 실행할 수 있습니다.\n- 자동화된 컨테이너 생성: 도커는 애플리케이션 소스 코드를 기반으로 자동으로 컨테이너를 빌드할 수 있습니다.\n- 컨테이너 버전 관리: 도커는 컨테이너 이미지의 버전을 추적하고 이전 버전으로 되돌릴 수 있으며, 어떻게 버전을 빌드했는지 및 누가 빌드했는지를 추적할 수 있습니다. 기존 버전과 새 버전 간의 차이점만 업로드할 수도 있습니다.\n- 컨테이너 재사용: 기존 컨테이너를 기본 이미지로 사용할 수 있습니다. 이는 사실상 새로운 컨테이너를 구축하는 템플릿과 같은 역할을 합니다.\n- 공유 컨테이너 라이브러리: 개발자는 수천 개의 사용자 기여 컨테이너가 포함된 오픈소스 레지스트리에 액세스할 수 있습니다.\n\n# 2. Kubernetes에 대한 포괄적인 소개\n\n![이미지](/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2.1. 쿠버네티스란?\n\n쿠버네티스(Kubernetes), 줄여서 K8s로도 불리는 이는 클러스터된 네트워크 리소스 위에서 컨테이너 런타임 시스템을 조립하기 위해 설계된 유명한 오픈소스 플랫폼입니다. 독립적으로 작동하거나 Docker와 같은 다른 컨테이너화 도구와 함께 작동할 수 있습니다.\n\nGoogle에서 최초 개발된 쿠버네티스는 수십억 개의 컨테이너를 대규모로 실행하기 위한 도전에 대응하기 위해 만들어졌습니다. Google은 2014년 이 플랫폼을 오픈소스 도구로 제공했으며, 이후 컨테이너 조립 및 분산 애플리케이션 배포를 위한 시장 리더 및 산업 표준 솔루션이 되었습니다.\n\nGoogle에 따르면 쿠버네티스는 복잡한 분산 시스템의 배포와 관리를 단순화하면서 컨테이너화의 장점을 활용하여 리소스 활용을 최적화하는 데 설계되었습니다. 쿠버네티스의 널리 퍼지는 채택으로 인해 제품 환경에서 컨테이너화된 응용 프로그램의 관리 및 확장에 중요한 도구로 부상했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쿠버네티스는 독립적인 기능이 있는 각각의 컨테이너를 실행하는 Docker와는 달리, 하나의 머신에서 여러 컨테이너 그룹을 관리하여 네트워크 오버헤드를 줄이고 자원 이용을 최적화할 수 있는 실용적인 해결책을 제공합니다. 예를 들어, 컨테이너 세트는 응용 프로그램 서버, Redis 캐시, 그리고 SQL 데이터베이스로 구성될 수 있습니다.\n\n쿠버네티스는 서비스 검색, 클러스터 내 로드 밸런싱, 자동 배포 및 롤백, 실패한 컨테이너의 자가 치유, 그리고 구성 관리 등 다양한 기능을 제공하여 데브옵스 팀에게 매우 가치 있는 도구입니다. 게다가, 쿠버네티스는 견고한 데브옵스 지속적 통합/지속적 전달 (CI/CD) 파이프라인을 구축하는 데 필수적인 도구입니다.\n\n하지만 쿠버네티스는 완전한 플랫폼 서비스(PaaS)가 아니며, 쿠버네티스 클러스터를 구축하고 관리할 때 염두에 두어야 할 사항이 몇 가지 있습니다. 쿠버네티스를 관리하는 복잡성은 많은 고객이 클라우드 공급 업체가 제공하는 관리형 쿠버네티스 서비스를 선호하는 주요 이유 중 하나입니다.\n\n## 2.2. 쿠버네티스를 사용한 컨테이너 오케스트레이션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컨테이너의 보급으로 기업들은 수백 개나 수천 개의 컨테이너를 가지게 될 수 있습니다. 이는 운영 팀이 컨테이너 배포, 네트워킹, 확장성 및 가용성을 자동화하는 것이 중요하다는 것을 필수적으로 만듭니다. 이것이 컨테이너 오케스트레이션 시장의 출현으로 이어졌습니다.\n\n다른 컨테이너 오케스트레이션 옵션인 Docker Swarm, Apache Mesos 등이 처음에는 인기를 얻었지만 Kubernetes가 빠르게 가장 널리 채택되었습니다. 사실 어느 순간부터 역사상 가장 빠르게 성장하는 오픈소스 프로젝트가 되었습니다.\n\n개발자들은 Kubernetes를 폭넓은 기능, 계속 성장하는 오픈소스 지원 도구 생태계, 다양한 클라우드 서비스 제공업체를 지원하고 교차 작동할 수 있는 능력 때문에 선택했습니다. 아마존 웹 서비스(AWS), 구글 클라우드, IBM 클라우드, 마이크로소프트 애저를 비롯한 모든 주요 공개 클라우드 제공업체들은 Kubernetes를 완전히 관리하는 서비스를 제공하며 이는 업계 전체적으로 인기가 있다는 것을 강조합니다.\n\n## 2.3. Kubernetes가 하는 일은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKubernetes는 애플리케이션 수명 주기 전반에 걸쳐 컨테이너 관련 작업을 스케줄하고 자동화합니다. 이러한 작업에는 다음이 포함됩니다:\n\n- 배포: 지정된 호스트에 지정된 수의 컨테이너를 배포하고 원하는 상태로 유지합니다.\n- 롤아웃: 롤아웃은 배포에 대한 변경 사항을 의미합니다. Kubernetes를 사용하면 롤아웃을 시작하거나 일시 중지하거나 다시 시작하거나 롤백할 수 있습니다.\n- 서비스 검색: Kubernetes는 컨테이너를 DNS 이름 또는 IP 주소를 사용하여 자동으로 인터넷이나 다른 컨테이너에 노출시킬 수 있습니다.\n- 스토리지 프로비저닝: Kubernetes를 설정하여 필요에 따라 컨테이너에 지속적인 로컬 또는 클라우드 스토리지를 마운트할 수 있습니다.\n- 부하 분산: CPU 이용률 또는 사용자 정의 지표를 기반으로 한 Kubernetes 부하 분산은 네트워크 전체에 작업 부하를 분산하여 성능과 안정성을 유지할 수 있습니다.\n- 자동 스케일링: 트래픽이 급증할 때 Kubernetes 자동 스케일링은 필요에 따라 추가 작업 부하를 처리하기 위해 새로운 클러스터를 생성할 수 있습니다.\n- 고가용성을 위한 자가 치유: 컨테이너가 실패하면 Kubernetes가 자동으로 다시 시작하거나 교체하여 다운타임을 방지할 수 있습니다. 또한 건강 검사 요구 사항을 충족하지 못하는 컨테이너를 중지할 수도 있습니다.\n\n## 2.4. Kubernetes의 장점\n\n- 자동화된 작업: Kubernetes는 효율적인 자동화를 가능하게 하는 강력한 API 및 명령줄 유틸리티인 kubectl을 갖추고 있습니다. Kubernetes는 컨트롤러 패턴을 통해 응용 프로그램/컨테이너가 자신의 사양에 정확히 따라 실행되도록 보장합니다.\n- 인프라 추상화: Kubernetes는 배정된 리소스를 대신하여 관리하고 응용프로그램 코드 작성에 집중할 수 있도록 해줍니다. 이를테면 컴퓨팅, 네트워킹 또는 스토리지의 기본 인프라 대신에 개발자가 애플리케이션 코드를 작성할 수 있습니다.\n- 서비스 상태 모니터링: Kubernetes는 운영 환경을 지속적으로 모니터링하고 의도된 구성과 일치 여부를 확인합니다. 서비스에 대한 건강 검사를 자동으로 수행하고 실패나 중단이 발생한 경우 컨테이너를 다시 시작합니다. Kubernetes는 서비스가 가동되어 있을 때에만 서비스를 노출합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Docker \u0026 Kubernetes의 차이점\n\n![Docker vs Kubernetes](/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_4.png)\n\nDocker와 Kubernetes는 모두 컨테이너화 생태계에서 중요한 구성 요소로, 각각 다른 목적으로 사용됩니다. Docker는 주로 컨테이너를 생성하고 실행하는 데 사용되며, Kubernetes는 호스트 클러스터 전체에서 컨테이너의 배포, 확장 및 관리를 조정하고 자동화하는 데 활용됩니다.\n\nDocker는 컨테이너화에 대해 직관적이고 효과적인 방법을 제공하는 반면, Kubernetes는 자동 스케일링, 자가 치유, 컨테이너 배포 등과 같은 고급 기능을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 4. 데이터 과학자로서 Kubernetes 및 Docker를 배워야 하는 이유\n\n![이미지](/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_5.png)\n\n## 4.1. 데이터 과학자로서 Docker를 배워야 하는 이유\n\n상상해보세요. 로컬 머신에서 완벽하게 작동하는 머신러닝 솔루션이 개발되었다고 가정해봅시다. 그러나 이를 다른 운영 체제나 라이브러리 버전이 다른 서버에 배포하려고 하면 코드가 예상대로 작동하지 않을 수 있습니다. 이는 개발자들에게는 좌절스러운 경험이 될 수 있지만, 이는 흔히 발생하는 일입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 문제의 해결책은 Docker를 사용하는 것입니다. Docker를 사용하면 프로젝트에 일관성 있고 정확한 환경을 정의할 수 있습니다. Docker를 사용하면 코드를 모든 필요한 종속성과 라이브러리와 함께 패키징하여 어느 기기에서나 실행할 수 있는 컨테이너로 만들 수 있습니다. 이는 대상 배포 환경에 관계없이 코드가 원활하고 일관되게 실행되도록 보장합니다.\n\n## 4.2. 데이터 과학자가 DevOps 팀이 존재하는 상황에서 Docker를 배워야 할까요\n\n데이터 과학자인 경우, 프로젝트의 인프라 측면을 처리하기 위해 전담된 DevOps 팀이 있는 경우에도 Docker를 배워야 할 필요성에 대해 의문을 갖을 수 있습니다. 그러나 Docker가 데이터 과학 작업 흐름에서 중요한 역할을 한다는 점을 인식하는 것이 중요합니다. DevOps 팀이 있더라도 Docker가 작업의 여러 측면을 간소화하고 효율화할 수 있다는 점을 발견하게 될 것입니다. 따라서 Docker가 데이터 과학자에게 귀중한 도구인 이유를 이해하는 것이 중요합니다.\n\n## 4.3. 데이터 과학자로서 Docker를 배우는 이점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 과학자로서 Docker를 배우는 것은 여러 가지 이점을 제공합니다:\n\n- 일관성과 재현성: Docker를 사용하면 코드, 종속성 및 환경을 모두 포함한 전체 프로젝트를 단일 컨테이너에 패키징하여 배포할 수 있습니다. 이를 통해 작업이 다른 기계와 환경에서 일관되게 실행되며 호환성 및 버전 관리 문제를 제거할 수 있습니다. 또한 Docker 컨테이너는 언제든지 작업을 정확히 재현할 수 있어 과거 결과를 다시 확인하거나 다른 사람들과 작업을 공유하는 데 용이합니다.\n- 쉬운 배포: Docker를 사용하면 프로젝트를 로컬 컴퓨터나 클라우드와 같은 다양한 환경에 쉽게 배포할 수 있습니다. 프로젝트를 컨테이너에 묶어두면 최소한의 구성으로 배포할 수 있고 종속성이나 호환성 문제를 걱정하지 않아도 됩니다.\n- 협업: Docker를 통해 동일 프로젝트에 참여하는 팀원들 간에 쉽게 협력할 수 있습니다. 작업을 컨테이너에 패키징함으로써 모두가 동일한 환경에서 작업하도록 보장하여 코드를 공유하고 결과를 재현하기가 더욱 쉬워집니다.\n- 빠른 실행: Docker 컨테이너는 가벼우며 빠르게 시작되므로 전통적인 방법보다 코드를 테스트하고 실행하는 속도가 빠릅니다. 이는 더욱 효율적인 작업 흐름과 빠른 반복 시간으로 이어질 수 있습니다.\n\n## 4.4. 데이터 과학자가 Kubernetes를 배워야 할까요?\n\n데이터 과학자가 Kubernetes를 배워야 하는지에 대한 의견은 분분할 수 있지만, 컨테이너화 및 Kubernetes와 같은 오케스트레이션 기술에 대한 기본적인 이해를 갖는 것이 유익하다고 널리 인정받고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 이유 중 하나는 데이터 과학자가 데브옵스 및 인프라 팀과 더 잘 소통할 수 있도록 도울 수 있다는 것입니다. 쿠버네티스에 대한 기본적인 이해를 갖고 있는 데이터 과학자는 모델 및 응용 프로그램을 프로덕션 환경에 배포하기 위한 인프라 요구 사항을 이해할 수 있습니다. 이는 데이터 과학자와 다른 팀 간의 원활한 소통과 협력을 촉진하여 더 효율적인 워크플로 및 빠른 배포 시간을 이끌어낼 수 있습니다.\n\n게다가, 쿠버네티스는 데이터 과학자들에게 확장 가능하고 신뢰할 수 있는 방식으로 모델 및 응용 프로그램을 쉽게 배포하고 관리할 수 있는 수단을 제공할 수 있습니다. 쿠버네티스를 사용하면 데이터 과학자들은 모델의 배포 및 확장을 자동화하여 대량의 데이터 및 요청을 처리하기가 더 쉬워집니다.\n\n게다가, 머신러닝 모델과 응용 프로그램이 더 복잡해지면 효율적으로 실행하기 위해 더 많은 인프라 자원이 필요할 때가 많습니다. 쿠버네티스는 데이터 과학자가 이러한 자원을 효과적으로 관리할 수 있게 하여 복잡한 모델과 응용 프로그램을 인프라 제약 사항에 대해 걱정하지 않고 규모에 맞게 실행할 수 있도록 도와줄 수 있습니다.\n\n종합하면, 데이터 과학자가 쿠버네티스 전문가가 될 필요는 없을지라도 이 기술에 대한 기본적인 이해를 갖는 것은 다른 팀과 더 효과적으로 작업하고 모델 및 응용 프로그램을 더 효율적으로 배포하는 데 도움이 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 주제에 대해 더 많은 정보를 보려면 다음 블로그 포스트를 참조하세요:\n\n- 데이터 과학 워크로드에 쿠버네티스가 좋은 이유\n- 데이터 과학자가 쿠버네티스를 알 필요가 없는 이유\n- 데이터 과학을 위해 쿠버네티스가 정말 필요한가요?\n\n# 참고 자료:\n\n- 도커(Docker)란 무엇인가요?\n- Kubernetes vs. Docker: Kubernetes와 Docker의 주요 차이점 및 컨테이너화에 대한 역할\n- Kubernetes vs. Docker: 포괄적인 비교\n- 데이터 과학을 위한 도커: 소개\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 글을 좋아하고 제를 지원하고 싶으시다면, 반드시:\n\n- 👏 이 글에 박수를 보내주세요 (50번) - 이 글이 주목받을 수 있도록 도와주세요\n- 제 Medium 계정을 팔로우해주세요\n- 📰 제 Medium 프로필에서 더 많은 콘텐츠를 확인해주세요\n- 🔔 나를 팔로우해주세요: LinkedIn | Youtube | GitHub | Twitter\n\n5달러로 Medium 멤버십 프로그램에 가입하여 제한 없이 계속 학습할 수 있습니다. 만약 다음 링크를 사용하신다면 추가 비용 없이 멤버십 요금의 일부를 제가 받게 됩니다.\n\n데이터 과학과 인공지능 분야에서 경력을 시작하고자 하지만 방법을 모르는 경우. 데이터 과학 멘토링 세션과 장기적인 경력 멘토링을 제공합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 멘토링 세션: [링크](https://lnkd.in/dXeg3KPW)\n- 장기 멘토링: [링크](https://lnkd.in/dtdUYBrM)\n\n![이미지](/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_6.png)\n","ogImage":{"url":"/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_0.png"},"coverImage":"/assets/img/2024-06-19-UnlockingthePowerofContainerizationWhyDataScientistsNeedtoLearnDockersandKubernetes_0.png","tag":["Tech"],"readingTime":19},{"title":"라라벨 세일과 도커 컴포즈 파일을 사용자 정의하는 방법","description":"","date":"2024-06-19 12:42","slug":"2024-06-19-HowtoCustomizeLaravelSailwithDockerComposeFiles","content":"\n![](/assets/img/2024-06-19-HowtoCustomizeLaravelSailwithDockerComposeFiles_0.png)\n\n라라벨 Sail은 라라벨 개발에 혁명을 일으키는 도구입니다. 필요한 모든 서비스가 이미 설치된 미리 구성된 도커 환경을 제공합니다. 이를 통해 수동 설정이 필요없어지고, 팀 전체에 일관된 개발 환경을 제공합니다. 하지만 프로젝트에 특정 요구 사항이 있다면 어떨까요? 라라벨 Sail은 도커 컴포즈 파일을 사용하여 쉽게 사용자 정의할 수 있는 기능을 제공합니다.\n\n도커 컴포즈는 Sail의 핵심입니다. 여러 도커 컨테이너의 구성 및 조정을 관리합니다. docker-compose.yml 파일이 도커 컴포즈의 핵심이며, 애플리케이션에 필요한 서비스(컨테이너)를 정의합니다. 이 파일을 조정함으로써 Sail 환경을 프로젝트 요구 사항에 맞게 완벽히 맞출 수 있습니다.\n\n이 문서에서는 Docker Compose를 사용하여 라라벨 Sail을 사용자 정의하는 방법에 대해 알아보겠습니다. 서비스, 볼륨, 포트, 환경 변수를 조정하여 개발 경험을 효율적으로 만들고 프로젝트 요구 사항에 완벽하게 부합하도록 만들어 보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도커-컴포즈.yml 파일 이해하기\n\n도커-컴포즈.yml 파일은 Laravel Sail 환경의 청사진으로 작용합니다. 이 파일은 도커 컴포즈에게 어떻게 설정하고 관리해야 하는지 지시하여 애플리케이션이 원활하게 실행되도록 하는 다양한 서비스(컨테이너)를 제어합니다. 이 파일을 텍스트 편집기에서 열면 일반적으로 다음과 같은 여러 주요 섹션을 포함하는 구조화된 형식을 볼 수 있습니다:\n\n# 1. 버전\n\n이 섹션은 도커 컴포즈 파일 형식 버전을 지정합니다. 최신 버전이 더 많은 기능을 제공하지만, Sail은 보다 널리 접근 가능한 지원되는 버전을 사용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. 서비스\n\n이것은 구성의 핵심입니다. 이것은 응용 프로그램에 필요한 각 서비스(컨테이너)를 정의합니다. 일반적인 Sail 서비스는 다음과 같습니다:\n\n- laravel.test: Laravel 응용 프로그램을 실행하는 컨테이너입니다.\n- mysql: 데이터베이스 컨테이너로, 일반적으로 MySQL을 사용합니다.\n- phpmyadmin: 데이터베이스를 관리하기 위한 그래픽 사용자 인터페이스(GUI)를 제공하는 컨테이너입니다.\n\n각 서비스 정의에는 기본 이미지(예: php:8.1), 노출할 포트(예: 웹 트래픽용으로 80:80), 마운트할 볼륨(프로젝트 코드 및 데이터) 및 구성에 대한 환경 변수와 같은 세부 정보가 포함됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3. 볼륨\n\n이 섹션은 컨테이너 재시작 시에도 데이터를 유지하는 이름이 지정된 볼륨을 정의합니다. 예를 들어, 애플리케이션 코드와 데이터베이스 파일을 볼륨으로 마운트하여, 컨테이너가 중지되고 다시 생성되어도 그 데이터가 보존되도록 할 수 있습니다.\n\n# 4. 네트워크\n\n이 섹션은 컨테이너 간 통신을 위한 사용자 정의 네트워크를 정의합니다. 기본적으로 Sail은 환경 내에서 서비스 간 통신을 위해 브리지 네트워크를 사용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 환경\n\n이 섹션에서는 애플리케이션 컨테이너 내에서 액세스할 수 있는 환경 변수를 정의할 수 있습니다. 이러한 변수는 데이터베이스 자격 증명이나 API 키와 같은 애플리케이션의 다양한 측면을 구성하는 데 사용할 수 있습니다.\n\n도커 컴포즈(.yml) 파일의 각 섹션의 목적과 구조를 이해하는 것은 사용자 정의에 들어가기 전에 중요합니다. 이러한 섹션들을 숙지하여 스스로를 잘 준비시켜 변경하고 Sail 환경을 프로젝트의 특정 요구 사항에 맞게 맞춤화할 수 있을 것입니다.\n\n# 서비스 사용자 정의하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 본 것처럼, docker-compose.yml 파일의 서비스 섹션은 Sail 환경에서 실행되는 각 컨테이너를 정의합니다. 이것이 맞춤화의 마법이 일어나는 곳입니다! 프로젝트에 맞춰 서비스를 개인화하는 몇 가지 방법을 살펴봅시다:\n\n## 1. 베이스 이미지:\n\n베이스 이미지는 컨테이너 내의 운영 체제 및 미리 설치된 소프트웨어를 지정합니다. 기본적으로 Sail은 laravel.test 서비스에 특정 PHP 버전 이미지(예: php:8.1)를 사용합니다. 그러나 프로젝트가 새로운 기능을 위해 다른 PHP 버전을 필요로 하는 경우(예: php:8.2), docker-compose.yml 파일에서 단순히 베이스 이미지 정의를 수정할 수 있습니다. 다음은 예시입니다:\n\n## 2. 포트:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 Sail은 특정 컨테이너 포트를 호스트 머신 포트로 매핑합니다. 이를 통해 편리한 URL(일반적으로 http://localhost:80)을 통해 응용 프로그램에 액세스할 수 있습니다. 그런데 여러 프로젝트를 동시에 작업하고 있을 때는 어떻게 해야 할까요? 각 프로젝트의 laravel.test 서비스에 대해 포트를 사용자 정의하여 충돌을 피할 수 있습니다. 다음은 방법입니다:\n\n이 구성은 컨테이너의 포트 80(웹 트래픽)를 호스트 머신의 포트 8080으로 노출합니다. 이제 http://localhost:8080에서 응용 프로그램에 액세스할 수 있습니다.\n\n# 3. 볼륨:\n\n볼륨은 호스트 머신과 컨테이너 간에 공유되는 디렉터리입니다. 이를 통해 컨테이너가 다시 생성되어도 응용 프로그램 코드 및 데이터베이스 파일과 같은 데이터를 지속적으로 유지할 수 있습니다. Sail은 일부 볼륨을 사전 구성하지만 특정 요구 사항에 따라 추가 볼륨을 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 프로젝트 디렉토리 외부에 사용자 지정 구성 파일이 있다고 상상해보세요. laravel.test 서비스에서 이 파일을 볼륨으로 마운트할 수 있습니다.\n\n이는 호스트 머신의 my-custom-config.php 파일을 컨테이너 내의 /var/www/html 디렉토리로 마운트하여 응용 프로그램에서 이에 액세스할 수 있도록 하는 것입니다.\n\n# 4. 환경 변수:\n\n환경 변수는 코드 자체를 수정하지 않고 응용 프로그램을 구성하는 방법을 제공합니다. Sail은 일부 기본 환경 변수를 정의하지만, 프로젝트에 특정한 사용자 정의 환경 변수를 추가할 수 있습니다. 다음은 예시입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 환경 변수는 env() 도우미 함수를 사용하여 Laravel 애플리케이션 내에서 액세스할 수 있습니다.\n\n# Sail 고급 사용자 정의\n\n이전 섹션에서는 핵심 서비스 사용자 정의에 초점을 맞췄지만, Laravel Sail은 숙련된 개발자들을 위해 더 많은 유연성을 제공합니다. 여기에는 고급 옵션 중 일부를 살펴볼 수 있습니다:\n\n# 1. 네트워크:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 Sail은 서비스간 통신을 위해 브릿지 네트워크를 사용합니다. 그러나 더 세밀한 제어가 필요한 복잡한 애플리케이션의 경우, docker-compose.yml 파일에서 사용자 정의 네트워크를 정의할 수 있습니다. 이러한 네트워크를 사용하면 서비스를 격리하고 통신 패턴을 제어할 수 있습니다.\n\n중요한 참고 사항: 사용자 정의 네트워크 구성은 Docker 네트워킹 개념에 대한 심층적인 이해가 필요하며, 고급 Docker Compose 기술에 익숙한 개발자를 대상으로 권장됩니다.\n\n# 2. 커스텀 서비스 추가하기:\n\nSail은 MySQL과 같은 미리 구성된 서비스를 제공하지만, 캐싱을 위해 Memcached나 이메일 테스트를 위해 Mailhog와 같은 추가 서비스가 필요한 경우는 어떨까요? Docker Compose의 장점은 다양한 서비스를 통합할 수 있는 능력에 있습니다. docker-compose.yml 파일에서 원하는 이미지와 구성 옵션을 지정하여 사용자 정의 서비스를 정의할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어 Memcached 서비스를 추가하려면:\n\n기억하세요: 사용자 정의 서비스를 추가하려면 그들의 목적과 구성 옵션을 이해해야 합니다. 선택한 서비스 이미지의 공식 문서를 참조하여 구체적인 지침을 얻을 수 있습니다.\n\n# 3. 도커 Secrets 사용하기:\n\n보안이 중요합니다. 데이터베이스 자격 증명과 같은 민감한 정보를 docker-compose.yml 파일에 직접 저장하는 것은 권장되지 않습니다. Docker Compose는 \"비밀\"이라고 불리는 안전한 솔루션을 제공합니다. 이 비밀은 docker-compose.yml 파일 외부에서 정의하고 서비스 내에서 환경 변수를 사용하여 참조할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n중요 사항: Docker 시크릿을 사용하려면 추가 구성이 필요하며, 민감한 정보를 위한 별도의 파일을 관리해야 할 수도 있습니다. 이 옵션을 구현하기 전에 Docker 보안 모베스트 프랙티스를 충분히 이해해야 합니다.\n\n이러한 고급 사용자 정의 옵션은 Laravel Sail 환경에 대한 새로운 수준의 유연성을 제공합니다. 그러나 이를 주의 깊게 다루고 Docker Compose 개념에 대해 꽤 꽤 잘 알고 있어야 합니다. 초심자들에게는 고급 구성으로 들어가기 전에 핵심 서비스 사용자 정의를 숙달해야 합니다.\n\n# 결론\n\nLaravel Sail은 사전 구성된 Docker 환경을 활용하여 Laravel 개발 워크플로우를 간소화할 수 있습니다. 하지만 진정한 매력은 사용자 정의할 수 있다는 점에 있습니다. Docker Compose 파일을 활용하여 Sail 설정을 프로젝트 요구 사항에 완벽히 맞게 조정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 서비스 베이스 이미지 및 포트를 조정하여 볼륨을 마운트하고 사용자 정의 환경 변수를 정의하는 등 다양한 사용자 정의 옵션을 살펴보았습니다. 우리는 심화된 영역으로 들어가 커스텀 네트워크를 추가하고 서비스를 추가하며 Docker 시크릿을 활용하여 보안을 강화했습니다.\n\n기억하세요, 사용자 정의는 강력한 도구이지만 효과적으로 사용하려면 docker-compose.yml 파일과 Docker Compose 개념을 이해해야 합니다. 작은 규모로 시작하여 기본 사용자 정의를 실험하고 확신이 생기면 점진적으로 고급 옵션을 탐험해보세요.\n\n라라벨 Sail의 전체 잠재력을 발휘하고 싶나요? 깊이 있는 내용은 공식 Sail 문서를 참조하고 온라인 Docker Compose 자료의 방대한 세계를 탐험해보세요. 아래 댓글 섹션에서 여러분의 경험을 공유하고 질문해도 좋습니다. 즐거운 사용자 정의 되세요!\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoCustomizeLaravelSailwithDockerComposeFiles_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoCustomizeLaravelSailwithDockerComposeFiles_0.png","tag":["Tech"],"readingTime":9},{"title":"FastAPI, Docker, 그리고 GCP를 활용하여 ML 솔루션 배포하는 방법","description":"","date":"2024-06-19 12:40","slug":"2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP","content":"\nFull Stack Data Science의 시리즈 중 5번째 기사입니다. 이 기사에서는 ML 기반 검색 API의 배포 방법을 안내합니다. 무수히 많은 방법으로 수행할 수 있지만, 여기에서는 거의 모든 머신 러닝 솔루션에 적용할 수 있는 간단한 3단계 접근법에 대해 설명합니다. 예시 코드는 GitHub 저장소에서 자유롭게 이용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png)\n\n머신 러닝이 모델 훈련에 관한 멋진 모델만이 아니라는 것을 생각하면, 실제로 모델 스스로는 가치를 만들어내지 않습니다. ML 모델을 ML 솔루션(즉, 가치 있는 것)으로 만들기 위해 \"배포\"해야 합니다.\n\n이를 다양한 형태로 구현할 수 있습니다. 예를 들어 사용자가 모델과 상호 작용할 수 있는 웹 인터페이스를 생성하거나, 기존 소프트웨어 시스템에 모델을 통합하거나, 개발자가 모델에 액세스할 수 있는 API를 설정하는 것 등이 있습니다 (OpenAI와 같은 사례를 생각해보세요).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 설명하는 3단계 전략은 모든 예제와 호환됩니다. 이는 다음으로 구성됩니다:\n\n- 추론 API 생성 (FastAPI 사용)\n- API 컨테이너화 (도커를 통해)\n- 클라우드 플랫폼에서 컨테이너 실행 (여기서는 GCP 사용)\n\n# FastAPI\n\n이 배포 전략의 첫 번째 단계는 모델을 API(즉, 응용 프로그램 프로그래밍 인터페이스)로 랩핑하는 것입니다. 간단히 말해, API를 사용하면 응용 프로그램과 프로그래밍 방식으로 상호 작용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 단계를 수행하는 한 가지 방법은 파이썬 함수를 API 엔드포인트로 변환하는 매우 쉬운 방법을 제공하는 Python 라이브러리인 FastAPI를 사용하는 것입니다. 아래 코드는 구체적인 예제를 제공합니다.\n\n## Docker\n\n우리의 추론 API를 직접 클라우드에 배포할 수 있지만, 먼저 \"컨테이너화\"하는 것이 좋습니다. 이때 Docker가 필요합니다.\n\nDocker를 사용하면 API의 종속성을 모두 포함하는 가벼운 래퍼를 생성할 수 있어서 새로운 컴퓨터에서 더 쉽게 구동할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업은 2 단계 프로세스를 통해 수행됩니다. 첫째, 우리는 Docker 이미지를 생성합니다. 이는 기본적으로 시스템에 API를 제로에서 어떻게 구동할지 알려주는 레시피입니다 (걱정하지 마세요, 만들기 쉽습니다). 둘째, Docker가 설치된 시스템에서 이미지를 실행할 수 있습니다. 실행 중인 이미지를 컨테이너라고 하며, 이는 더 큰 시스템에 있는 작은 가상 머신과 같습니다.\n\n# Google Cloud Run\n\n마지막으로, Docker 이미지를 실행할 컴퓨팅 리소스가 필요합니다. 물론 노트북에서 이 작업을 수행할 수도 있지만 (아마 좋은 아이디어는 아닙니다), 온프레미스 서버나 클라우드 제공업체를 통해 이를 수행할 수 있습니다.\n\n여기서는 Google Cloud Run을 사용하여 Docker 컨테이너를 실행하는 GCP 서비스를 사용합니다. 이 서비스에는 무료 티어도 있으므로 불필요한 비용이 발생하지 않고 프로젝트를 배포할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 예시 코드: 시맨틱 검색 API 배포하기\n\n기본 개념을 이해했으니, 실제 코드에서 이 프로세스가 어떻게 보이는지 살펴봅시다. 아래 예시는 이 시리즈의 이전 기사들을 바탕으로 구축되었으며, 제 유튜브 비디오의 제목과 대본을 가져와 텍스트 임베딩으로 변환한 것을 사용합니다.\n\n간단히 말해, 텍스트 임베딩은 텍스트의 의미론적인 의미 있는 숫자 표현으로, 새로운 종류의 검색(시맨틱 검색이라고도 함)을 가능하게 합니다.\n\n여기에서는 제 유튜브 비디오의 모든 제목과 대본에 대한 시맨틱 검색 시스템을 위한 API를 구축하고 배포할 것입니다. 이 API는 Hugging Face spaces에서 실행되는 실시간 검색 애플리케이션의 백엔드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 앱의 백엔드와 프론트엔드의 코드 저장소가 모두 무료로 제공됩니다.\n\n## 단계 1: API 만들기\n\nFastAPI를 사용하면 기존의 Python 스크립트를 몇 줄의 추가 코드로 API로 변환하는 것이 매우 쉽습니다. 이게 바로 그 모습입니다.\n\n먼저 유용한 라이브러리를 import할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom fastapi import FastAPI\nimport polars as pl\nfrom sentence_transformers import SentenceTransformer\nfrom sklearn.metrics import DistanceMetric\nimport numpy as np\nfrom app.functions import returnSearchResultIndexes\n```\n\n이제 우리는 시맨틱 검색 기능의 구성 요소를 정의할 겁니다. 구체적으로 텍스트 임베딩 모델, 우리가 검색하려는 비디오들의 제목 및 대본 임베딩, 그리고 사용자 쿼리에 가장 관련성 높은 비디오를 평가하는 거리 측정 기준입니다. 시맨틱 검색에 대해 더 깊게 알아보고 싶다면, 이에 대해 이전에 다룬 글을 참조해주세요.\n\n```js\n# define model info\nmodel_name = 'all-MiniLM-L6-v2'\n\n# load model\nmodel = SentenceTransformer(model_name)\n\n# load video index\ndf = pl.scan_parquet('app/data/video-index.parquet')\n\n# create distance metric object\ndist_name = 'manhattan'\ndist = DistanceMetric.get_metric(dist_name)\n```\n\n이제 API 작업을 정의합니다. 여기서 3개의 GET 요청을 생성할 것입니다. 첫 번째 요청은 아래 코드 블록에 표시되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\n# FastAPI 객체 생성\napp = FastAPI()\n\n# API 동작\n@app.get(\"/\")\ndef health_check():\n    return {'health_check': 'OK'}\n```\n\n위 블록에서는 FastAPI() 클래스를 사용하여 새 FastAPI 애플리케이션을 초기화하고 \"health check\" 엔드포인트를 만듭니다.\n\n이를 위해 입력이 없고 \"health_check\" 키와 값이 \"OK\"인 사전을 반환하는 Python 함수를 정의합니다. 이 함수를 API 엔드포인트로 변환하려면 단순히 데코레이터를 추가하고 엔드포인트의 경로를 지정하면 됩니다. 여기서는 루트인 즉, \"/\"를 사용합니다.\n\n또 다른 예제를 살펴보겠습니다. 여기서는 API에 대한 자세한 정보를 반환하는 info라는 엔드포인트가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n@app.get(\"/info\")\ndef info():\n    return {'name': 'yt-search', 'description': \"Shaw Talebi의 YouTube 비디오를 검색하는 API입니다.\"}\n```\n\n이 엔드포인트는 헬스 체크와 매우 유사한 것을 볼 수 있습니다. 그러나 이것은 \"/info\" 엔드포인트에 위치합니다.\n\n마지막으로 사용자 쿼리를 받아 가장 관련 있는 비디오의 제목과 ID를 반환하는 검색 엔드포인트를 만들어 봅시다.\n\n```js\n@app.get(\"/search\")\ndef search(query: str):\n    idx_result = returnSearchResultIndexes(query, df, model, dist)\n    return df.select(['title', 'video_id']).collect()[idx_result].to_dict(as_series=False)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 엔드포인트에는 입력이 필요합니다: 사용자의 쿼리입니다. 이 쿼리는 다른 스크립트에 정의된 또 다른 Python 함수로 전달됩니다. 이 함수는 검색에 대한 모든 수학 연산을 수행합니다. 여기서 자세히 다루지는 않겠지만, 궁금한 독자는 코드를 GitHub에서 볼 수도 있고 YouTube에서 검색 함수의 코드 설명을 볼 수도 있습니다.\n\n이 함수는 검색 결과의 행 번호만 df 데이터프레임에서 반환하므로, 우리는 이 출력을 사용하여 관심 있는 제목과 비디오 ID를 가져와서 이를 Python 사전으로 반환해야 합니다. API 엔드포인트의 모든 출력이 사전이어야 하는데요, 이는 API의 표준 JSON 형식을 준수하기 때문입니다.\n\n위 코드 블록에서 설명한대로, 두 개의 외부 파일인 app/functions.py 및 app/data/video-index.parquet을 참조합니다. 이는 다음 디렉토리 구조를 시사합니다.\n\n![image](https://example.com/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 API를 로컬에서 실행하려면 루트 디렉토리로 이동하여 다음 명령을 실행할 수 있습니다.\n\n```js\nuvicorn app.main:app --host 0.0.0.0 --port 8080\n```\n\nuvicorn은 FastAPI를 사용하여 작성한 웹 애플리케이션을 실행할 수 있게 해주는 파이썬 라이브러리입니다. 이 명령은 이 API를 로컬에서 http://0.0.0.0:8080에서 실행합니다. 나중에 Google Cloud Run에 배포할 때 이 호스트와 포트를 사용하는 이유를 나준내게 될 것입니다.\n\n## 단계 2: 도커 이미지 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우와, 우리 API가 로컬에서 작동하고 있어요! 이제 클라우드에서 실행할 수 있도록 다음 단계를 진행해 봐요.\n\n이를 위해서 API용 Docker 이미지를 생성할 거에요. 이를 위해 Dockerfile, requirements.txt, 그리고 app/**init**.py 이 3가지 파일을 만들어야 해요. 우리 디렉토리는 아래와 같이 보여야 해요.\n\n![이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_2.png)\n\nDockerfile은 Docker 이미지를 실행하는 단계별 지침을 포함하고 있어요. requirements.txt는 API를 실행하는 데 필요한 Python 라이브러리(버전 포함)를 지정해요. 마지막으로 app/**init**.py 파일은 app 폴더를 Python 패키지로 지정해주어, 컨테이너에서 실행될 때 Python이 API 코드를 찾고 적절하게 가져올 수 있도록 해줘요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 Dockerfile 내부의 내용입니다.\n\n```js\n# python 기본 이미지에서 시작\nFROM python:3.10-slim\n\n# 작업 디렉토리 변경\nWORKDIR /code\n\n# 요구 사항 파일을 이미지에 추가\nCOPY ./requirements.txt /code/requirements.txt\n\n# Python 라이브러리 설치\nRUN pip install --no-cache-dir --upgrade -r /code/requirements.txt\n\n# Python 코드 추가\nCOPY ./app/ /code/app/\n\n# 기본 명령어 지정\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8080\"]\n```\n\n첫 번째 줄은 기존에 Python 3.10이 설치된 이미지 위에 저희의 이미지를 부트스트랩합니다. 다음으로 작업 디렉토리를 루트에서 /code로 변경합니다.\n\n그런 다음 요구 사항 파일을 코드베이스에서 Docker 이미지로 복사합니다. 이를 통해 pip를 사용하여 요구 사항을 설치할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 다음으로, API에 대한 모든 코드를 복사합니다.\n\n참고: Python 패키지를 먼저 복사하고 설치했습니다. 이렇게 함으로써 요구 사항의 설치를 캐시할 수 있습니다. 개발 중에 빠르게 Docker 이미지를 실행할 때 의존성을 설치하는 데 몇 분을 기다릴 필요가 없도록 도와줍니다.\n\n마지막으로, 개발 중에 API를 실행할 때 지역에서 실행했던 것과 동일한 기본 명령을 지정합니다.\n\n## 단계 3: Google Cloud에 배포\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 시점에서 우리는 Docker 이미지를 빌드하고 Docker Hub에 푸시하여 여러 다른 클라우드 서비스에 쉽게 배포할 수 있습니다. 하지만 여기서는 대안 전략을 따를 거에요.\n\n대신에, 우리 모든 코드를 GitHub에 푸시할 거에요. 그럼 바로 이 코드를 Google Cloud Run에 컨테이너 배포할 수 있어요. 이 방법에는 두 가지 주요 장점이 있어요.\n\n첫째로, 로컬 시스템과 Google Cloud Run이 사용하는 시스템 아키텍처 간의 차이를 해결하느라 시간을 들일 필요가 없어요 (특히 저는 Mac이 ARM64로 동작하기 때문에 이 문제가 있었어요). 둘째로, GitHub 리포지토리에서 배포함으로써 지속적인 배포가 가능해져요. 그래서 API를 업데이트하고 싶다면, 그냥 새 코드를 리포지토리에 푸시하면 새 컨테이너가 자동적으로 생성돼요.\n\n우리는 새 GitHub 리포지토리를 만들면서 시작해볼게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_3.png\" /\u003e\n\n이제 리포지토리를 복제하고 코드를 추가한 후 GitHub로 푸시합니다. 코드를 추가한 후 디렉토리 구조는 다음과 같이 보입니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_4.png\" /\u003e\n\n코드가 준비되었으면 새 Google Cloud Platform 프로젝트를 만들 수 있습니다. GCP 콘솔로 이동하여 프로젝트 목록을 클릭한 다음 \"새 프로젝트\"를 선택하여 진행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_5.png\" /\u003e\n\n프로젝트가 생성되면 해당 프로젝트를 열고 검색 창에 \"cloud run\"을 입력할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_6.png\" /\u003e\n\n그것을 열면 \"CREAT SERVICE\"를 클릭할 것입니다. 이렇게 하면 서비스를 구성할 수 있는 페이지가 열립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 GitHub에서 서비스를 배포할 옵션을 선택합니다. 그런 다음 \"CLOUD BUILD로 설정\"을 클릭하세요.\n\n[이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_7.png)\n\n저장소 소스로는 GitHub을 선택하고 방금 만든 저장소를 선택합니다.\n\n[이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지점을 ^main$으로 유지하고 \"Build Type\"을 Dockerfile로 선택합니다.\n\n![이미지](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_9.png)\n\n다음으로, 서비스 구성 화면으로 돌아갑니다. 서비스의 이름을 마음대로 지정할 수 있습니다 (저는 자동 생성된 이름을 그대로 두겠습니다). 지역은 us-central1로 남겨두겠습니다. 이 지역은 가장 저렴한 컴퓨팅 옵션을 제공하는 Tier 1이기 때문에 이 예시에서는 무료입니다.\n\n간단히 유지하려면 \"인증되지 않은 호출 허용\"을 선택합니다. 물론 대부분의 시스템에는 인증이 필요할 것입니다. 그런 다음, 나머지를 기본값으로 남겨둡니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 \"컨테이너, 볼륨, 네트워킹, 보안\" 아래에서 컨테이너를 편집하여 1 GiB의 메모리를 할당하세요. Dockerfile에서 구성한 대로 PORT가 8080으로 설정되어 있기 때문에 이것을 변경하시면 안 됩니다.\n\n나머지 설정은 기본값으로 그대로 두고 화면 아래의 \"생성\"을 클릭하세요. 수 분 후 컨테이너가 활성화될 것입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_12.png)\n\n그런 다음 페이지 상단 근처에 지정된 URL을 사용하여 API에 액세스할 수 있습니다. 링크를 클릭하면 루트 엔드포인트가 열립니다. 이 엔드포인트는 건강 상태 확인이었습니다.\n\n![image](/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_13.png)\n\n다음 URL을 사용하여 검색 API에 대한 GET 요청을 수동으로 실행할 수 있습니다: [여기에 앱의 URL 입력]/search?query=LLMs. 이를 통해 LLMs와 관련된 비디오를 검색할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_14.png\" /\u003e\n\n## 보너스: UI에 통합하기\n\nAPI 백엔드를 설정한 후, 사용자 친화적 인터페이스에 연결할 수 있습니다. 저는 Hugging Face Spaces를 통해 이를 수행합니다. 이 곳은 완전히 무료로 ML 앱을 호스팅합니다.\n\n이것이 같은 검색이 UI를 통해 어떻게 보이는지입니다. 여기서 UI를 테스트하고 코드를 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*St0OCAxBpqORc95WDpq4Pg.gif)\n\n# 결론\n\n데이터 과학은 멋진 모델을 훈련시키는 것 이상의 의미를 가지고 있습니다. 문제를 해결하고 가치를 창출하는 것이 중요합니다. 종종, 이를 위해서는 모델을 배포하여 최대 효과를 발휘할 수 있는 환경으로 이전해야 합니다. 여기에서는 FastAPI, Docker 및 GCP를 사용하여 ML 모델을 배포하는 간단한 3단계 전략을 살펴보았습니다.\n\n풀 스택 데이터 과학 시리즈를 마치는 글이지만, 이 글들은 이 검색 도구를 생성하는 과정에 관련된 실험에 대한 보너스 비디오가 포함된 YouTube 플레이리스트와 함께 제공됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFull Stack Data Science에 관해 더 알아보기 👇\n\n# 자료\n\n연결하기: [내 웹사이트](링크) | 전화 상담 예약\n\n소셜 미디어: [YouTube 🎥](링크) | [LinkedIn](링크) | [Twitter](링크)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSupport: 커피 한 잔 사주세요 ☕️\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoDeployMLSolutionswithFastAPIDockerandGCP_0.png","tag":["Tech"],"readingTime":16}],"page":"35","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"35"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>