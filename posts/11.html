<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/11" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/11" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법" href="/post/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">30<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Callback 대신 Coroutine 사용하는 방법" href="/post/2024-06-23-HowtouseaCoroutineinsteadofCallback"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Callback 대신 Coroutine 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtouseaCoroutineinsteadofCallback_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Callback 대신 Coroutine 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Callback 대신 Coroutine 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="WhatsApp 앱을 삭제하면 일어나는 일 정확히" href="/post/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="WhatsApp 앱을 삭제하면 일어나는 일 정확히" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="WhatsApp 앱을 삭제하면 일어나는 일 정확히" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">WhatsApp 앱을 삭제하면 일어나는 일 정확히</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까" href="/post/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법" href="/post/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드 UI 레이어 속성 완전 정복  Part 2" href="/post/2024-06-23-CrashCourseontheAndroidUILayerPart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 UI 레이어 속성 완전 정복  Part 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 UI 레이어 속성 완전 정복  Part 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 UI 레이어 속성 완전 정복  Part 2</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기초부터 배우는 Kotlin 코루틴 사용법" href="/post/2024-06-23-KotlinCoroutinesFundamentals"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기초부터 배우는 Kotlin 코루틴 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기초부터 배우는 Kotlin 코루틴 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">기초부터 배우는 Kotlin 코루틴 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시스템 설계를 처음부터 배우기 레슨 1" href="/post/2024-06-23-StartingfromScratchSystemDesignLesson1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시스템 설계를 처음부터 배우기 레슨 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-StartingfromScratchSystemDesignLesson1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시스템 설계를 처음부터 배우기 레슨 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">시스템 설계를 처음부터 배우기 레슨 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법" href="/post/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">35<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법" href="/post/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">27<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link posts_-active__YVJEi" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법","description":"","date":"2024-06-23 23:29","slug":"2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose","content":"\n## 안드로이드에서 조합을 활용한 창의적인 애니메이션 구축\n\n![이미지](/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png)\n\n# 소개\n\n애니메이션은 사용자 인터페이스를 생생하고 매력적으로 만드는 힘을 지니고 있습니다. 안드로이드에서는 Jetpack Compose를 활용하여 이 힘을 직접 경험할 수 있습니다. 이러한 고급 도구를 제공함으로써 동적인 UI를 만들 수 있는 Jetpack Compose의 애니메이션에 대해 이 글에서는 기본을 넘어 더 깊게 알아보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 플루이드하고 물리학적인 움직임을 만드는 것부터 복잡한 코레오그래피 시퀀스를 만들어 인터페이스에 서사적인 품질을 더하는 기술 범위를 다룰 것입니다. 여러분이 기술을 미세하게 조정하거나 가능한 영역에 대해 궁금해하는 경우, 이 여정은 앱을 매끄럽게 작동하는 것뿐만 아니라 모든 상호작용에서 사용자를 즐겁게 만드는 실용적인 통찰력을 제공할 것입니다.\n\n자세히 알아보고 이러한 애니메이션들이 UI 디자인 접근 방식을 변화시키고 사용자에게 더 직관적이고 반응성 있으며 즐거운 경험을 제공하는 방법을 발견해 봅시다.\n\n# 섹션 1 — Jetpack Compose에서 사용자 정의 애니메이션 핸들러\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*C1_mzDHNHOfSZkIiULgRzw.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 사용자 지정 애니메이션으로 동적 상호작용 수용하기\n\n이 섹션에서는 Jetpack Compose에서 고급 사용자 지정 애니메이션 핸들러의 사용에 대해 탐구하여 동적이고 대화식 UI 요소를 만드는 방법을 살펴봅니다. 우리의 초점은 사용자 상호작용이 의미 있는 방식으로 애니메이션에 영향을 미치는 실제 예제에 있습니다.\n\n## 예제 - 대화식 게임 캐릭터 이동\n\n게임 캐릭터(얼굴 아이콘으로 표시되는)가 사용자가 드래그할 수 있는 제어 지점에 의해 결정된 경로를 따라가는 예제로 이 개념을 설명하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun GameCharacterMovement() {\n    val startPosition = Offset(100f, 100f)\n    val endPosition = Offset(250f, 400f)\n    val controlPoint = remember { mutableStateOf(Offset(200f, 300f)) }\n    val position = remember { Animatable(startPosition, Offset.VectorConverter) }\n\n    LaunchedEffect(controlPoint.value) {\n        position.animateTo(\n            targetValue = endPosition,\n            animationSpec = keyframes {\n                durationMillis = 5000\n                controlPoint.value at 2500 // 가운데 지점은 드래그 가능한 컨트롤포인트로 제어됩니다\n            }\n        )\n    }\n\n    val onControlPointChange: (offset: Offset) -\u003e Unit = {\n        controlPoint.value = it\n    }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n\n        Icon(\n            Icons.Filled.Face, contentDescription = \"로컬라이즈된 설명\", modifier = Modifier\n                .size(50.dp)\n                .offset(x = position.value.x.dp, y = position.value.y.dp)\n        )\n\n        DraggableControlPoint(controlPoint.value, onControlPointChange)\n    }\n}\n```\n\n## 설명\n\n- GameCharacterMovement 함수는 게임 캐릭터를 나타내는 아이콘을 애니메이션화합니다. 애니메이션 경로는 사용자 상호 작용에 의해 설정 및 업데이트되는 controlPoint으로 제어됩니다.\n- Animatable은 startPosition에서 endPosition으로 아이콘의 위치를 부드럽게 전환하기 위해 사용됩니다.\n- LaunchedEffect는 controlPoint 값의 변경 사항을 감지하고, 제어 지점이 이동할 때마다 애니메이션을 다시 트리거합니다.\n- animationSpec은 애니메이션의 지속 시간, 지연 및 이징을 정의하는 구성이며, 애니메이션된 값이 시간에 따라 어떻게 변하는지 결정합니다.\n- keyframes를 통해 애니메이션의 중간 지점을 제어 지점에서 최종 위치까지 정의할 수 있습니다. 중요한 역할을 하는 복잡한, 조정된 애니메이션을 만드는 데 특히 유용합니다.\n- keyframes 블록은 키프레임의 시퀀스로 애니메이션을 정의합니다. 2500 밀리초(절반 지점)에서 캐릭터가 제어 지점에 도달한 후 최종 위치로 이동합니다.\n\n```kotlin\n@Composable\nfun DraggableControlPoint(controlPoint: Offset, onControlPointChange: (Offset) -\u003e Unit) {\n    var localPosition by remember { mutableStateOf(controlPoint) }\n    Box(\n        modifier = Modifier\n            .offset {\n                IntOffset(\n                    x = localPosition.x.roundToInt() - 15,\n                    y = localPosition.y.roundToInt() - 15\n                )\n            }\n            .size(30.dp)\n            .background(Color.Red, shape = CircleShape)\n            .pointerInput(Unit) {\n                detectDragGestures(onDragEnd = {\n                    onControlPointChange(localPosition)\n                }) { _, dragAmount -\u003e\n                    // 화면 범위에 맞춰 조정\n                    val newX = (localPosition.x + dragAmount.x).coerceIn(0f, 600f)\n                    val newY = (localPosition.y + dragAmount.y).coerceIn(0f, 600f)\n                    localPosition = Offset(newX, newY)\n                }\n            }\n    )\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설명\n\n- DraggableControlPoint는 사용자가 제어 지점의 위치를 인터랙티브하게 변경할 수 있게 하는 컴포저블입니다.\n- 제어 지점을 드래그하면 localPosition이 업데이트되고, 이후 드래그 제스처가 완료될 때 (onDragEnd) 이를 GameCharacterMovement에 반영합니다. 이 상호 작용은 애니메이션된 아이콘의 경로를 변경합니다.\n\n## 실제 사용 사례\n\n- 상호 작용적인 교육 앱: 교육 앱에서는 애니메이션을 통해 학습을 더 매료적으로 만들 수 있습니다. 예를 들어, 천문학 앱에서 행성을 따라 원거리를 끌어서 다양한 별자리를 볼 수 있습니다.\n- 상호 작용적인 이야기 전달과 게임: 디지털 이야기 전달이나 게임 앱에서 사용자가 드래그 가능한 요소를 통해 이야기나 게임 환경에 영향을 미칠 수 있도록 하는 것은 더 몰입적인 경험을 만들어냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 섹션 2 — Jetpack Compose에서 복잡한 애니메이션 조정하기\n\n## 조화로운 효과를 위한 여러 요소의 동기화\n\n이 섹션에서는 Jetpack Compose에서 복잡한 애니메이션을 조율하는 기술에 대해 다룹니다. 여러 요소가 매끄럽게 상호작용하는 동기화된 애니메이션을 만드는 데 초점을 맞춰 전체 사용자 경험을 향상시킵니다.\n\n## A) 연쇄 반응 애니메이션 — 도미노 효과\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![domino effect](https://miro.medium.com/v2/resize:fit:1400/1*iNeJJU3ixcdcZnQFHHSWYw.gif)\n\nUI에서 도미노 효과를 만드는 방법은 하나의 애니메이션이 완료되면 다음 애니메이션을 시작하도록 설정하는 일련의 애니메이션을 만들어내면 됩니다.\n\n```kotlin\n@Composable\nfun DominoEffect() {\n    val animatedValues = List(6) { remember { Animatable(0f) } }\n\n    LaunchedEffect(Unit) {\n        animatedValues.forEachIndexed { index, animate -\u003e\n            animate.animateTo(\n                targetValue = 1f,\n                animationSpec = tween(durationMillis = 1000, delayMillis = index * 100)\n            )\n        }\n    }\n\n    Box (modifier = Modifier.fillMaxSize()){\n      animatedValues.forEachIndexed { index, value -\u003e\n        Box(\n            modifier = Modifier\n                .size(50.dp)\n                .offset(x = ((index+1) * 50).dp, y = ((index+1) * 30).dp)\n                .background(getRandomColor(index).copy(alpha = value.value))\n        )\n      }\n    }\n}\n\nfun getRandomColor(seed: Int): Color {\n    val random = Random(seed = seed).nextInt(256)\n    return Color(random, random, random)\n}\n```\n\n## 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- animatedValues는 상자의 불투명도를 제어하는 Animatable 값 목록입니다.\n- LaunchedEffect는 이러한 값들에 대한 일련의 애니메이션을 트리거하여 각 상자가 이전 상자 뒤에 나타나는 비슷한 도미노가 넘어지는 효과를 만듭니다.\n- getRandomColor 함수는 각 상자에 대해 무작위 회색을 생성하여 시퀀스의 각 구성 요소에 고유한 시각적 요소를 추가합니다.\n- 상자들은 화면 대각선상에 배치되어 도미노 효과를 더욱 부각시킵니다.\n\n## B) 대화식 스크롤 가능한 타임라인\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Kk-V0g5pEqy83NajRy_6lA.gif)\n\n이 타임라인에서 사용자가 타임라인을 스크롤하면 각 요소가 서서히 나타나고 위치로 이동합니다. 스크롤 가능한 목록에는 LazyColumn을 사용하고 애니메이션에는 Animatable을 사용할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun InteractiveTimeline(timelineItems: List\u003cString\u003e) {\n    val scrollState = rememberLazyListState()\n\n    LazyColumn(state = scrollState) {\n        itemsIndexed(timelineItems) { index, item -\u003e\n            val animatableAlpha = remember { Animatable(0f) }\n            val isVisible = remember {\n                derivedStateOf {\n                    scrollState.firstVisibleItemIndex \u003c= index\n                }\n            }\n\n            LaunchedEffect(isVisible.value) {\n                if (isVisible.value) {\n                    animatableAlpha.animateTo(\n                        1f, animationSpec = tween(durationMillis = 1000)\n                    )\n                }\n            }\n\n            TimelineItem(\n                text = item,\n                alpha = animatableAlpha.value,\n            )\n        }\n    }\n}\n\n@Composable\nfun TimelineItem(text: String, alpha: Float) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(Color.DarkGray.copy(alpha = alpha))\n            .padding(16.dp),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Text(\n            text = text,\n            color = Color.White,\n            modifier = Modifier.fillMaxWidth(),\n            textAlign = TextAlign.Center,\n            fontSize = 18.sp,\n            fontWeight = FontWeight.SemiBold\n        )\n    }\n}\n```\n\n## 설명\n\n- animatableAlpha은 각 타임라인 아이템의 투명도 (투명도)를 제어하며, 초기에 0 (완전히 투명)로 설정됩니다.\n- isVisible 상태는 현재 스크롤 위치에서 파생되어 항목이 표시될지 여부를 결정합니다.\n- 사용자가 스크롤하면 LaunchedEffect가 뷰포트에 들어오는 항목에 대한 페이드인 애니메이션을 트리거합니다.\n\n## 사용 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 상호작용형 타임라인은 사용자에게 시각적으로 매력적인 방식으로 일련의 이벤트나 단계를 제시하고 싶은 응용 프로그램에 이상적입니다. 애니메이션은 항목이 나타날 때 주목을 끌어 사용자 참여도를 높입니다.\n\n# 섹션 3 — 젯팩 콤포즈에서 현실감 있는 물리 기반 애니메이션\n\n![애니메이션 이미지](https://miro.medium.com/v2/resize:fit:1400/1*lZ_rpGorcFzewpUJN6WPAQ.gif)\n\n## UI 다이내믹스 향상을 위한 물리학 활용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 물리학 원리를 Jetpack Compose와 통합하여 UI에 현실성과 상호 작용성을 더하는 방법을 살펴보겠습니다. 탄탄한 드래그 상호 작용 예시에 초점을 맞출 것입니다.\n\n## 드래그 시 탄탄한 효과\n\n이 예시에서는 아이콘에 탄탄한 드래그 상호 작용을 보여줍니다. 수직으로 드래그할 때 아이콘이 늘어나고 탄탄한 효과로 튕기며, 스프링이나 고무줄의 행동을 모방합니다.\n\n```js\n@Composable\nfun ElasticDraggableBox() {\n    var animatableOffset by remember { mutableStateOf(Animatable(0f)) }\n\n    Box(modifier = Modifier.fillMaxSize().background(Color(0xFFFFA732)), contentAlignment = Alignment.Center) {\n        Box(\n            modifier = Modifier\n                .offset(y = animatableOffset.value.dp)\n                .draggable(\n                    orientation = Orientation.Vertical,\n                    state = rememberDraggableState { delta -\u003e\n                        animatableOffset = Animatable(animatableOffset.value + delta)\n                    },\n                    onDragStopped = {\n                        animatableOffset.animateTo(0f, animationSpec = spring())\n                    }\n                )\n                .size(350.dp),\n            contentAlignment = Alignment.Center\n        ) {\n            Icon(\n                Icons.Filled.Favorite,\n                contentDescription = \"heart\",\n                modifier = Modifier.size(animatableOffset.value.dp + 150.dp),\n                tint = Color.Red\n            )\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설명\n\n- 드래그할 수 있는 modifier를 사용하여 아이콘을 포함하는 Box Composable을 만듭니다.\n- animatableOffset은 드래깅으로 인한 아이콘의 수직 오프셋을 추적합니다.\n- 드래그하는 동안 아이콘의 크기가 드래그 양에 따라 변경되어 스트레칭 효과를 만듭니다.\n- 드래그가 멈추면 (onDragStopped), animatableOffset을 스프링 애니메이션을 사용하여 0f로 다시 애니메이션화하여 아이콘이 원래 크기와 위치로 되돌아가도록 합니다.\n\n# 섹션 4 — 제스처 기반 애니메이션(Jetpack Compose에서)\n\n## 사용자 경험을 향상시키는 반응형 제스처들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 사용자 동작으로 제어되는 애니메이션을 생성하는 데 Jetpack Compose를 사용하는 방법을 살펴봅니다. 두 가지 예제에 중점을 두겠습니다 - 멀티터치로 변환 가능한 이미지 및 제스처로 제어되는 오디오 파형입니다.\n\n## A) 멀티 터치로 변환 가능한 이미지\n\n이 예제에서는 사용자가 핀치, 줌 및 회전과 같은 멀티터치 제스처를 사용하여 상호 작용할 수 있는 이미지 뷰를 생성합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*34WxcBivTWhiCY6KVSVelQ.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun TransformableImage(imageId: Int = R.drawable.android) {\n    var scale by remember { mutableStateOf(1f) }\n    var rotation by remember { mutableStateOf(0f) }\n    var offset by remember { mutableStateOf(Offset.Zero) }\n\n    Box(modifier = Modifier.fillMaxSize().background(Color.DarkGray), contentAlignment = Alignment.Center) {\n        Image(\n            painter = painterResource(id = imageId),\n            contentDescription = \"Transformable image\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier\n                .size(300.dp)\n                .graphicsLayer(\n                    scaleX = scale,\n                    scaleY = scale,\n                    rotationZ = rotation,\n                    translationX = offset.x,\n                    translationY = offset.y\n                )\n                .pointerInput(Unit) {\n                    detectTransformGestures { _, pan, zoom, rotate -\u003e\n                        scale *= zoom\n                        rotation += rotate\n                        offset += pan\n                    }\n                }\n        )\n    }\n}\n```\n\n## 설명\n\n- 이미지 컴포저블은 scale, rotation, translation과 같은 변환을 적용하기 위해 graphicsLayer로 수정되었습니다.\n- detectTransformGestures가 사용되는 pointerInput은 멀티 터치 제스처를 처리하고, scale, rotation, offset을 해당 값을 따라 업데이트합니다.\n\n## B) 제스처 컨트롤 웨이브폼\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자 제스처(스와이프 및 핀치)에 따라 와브폼 시각화가 모양을 바꿉니다. 이를 통해 진폭 및 주파수와 같은 요소를 제어할 수 있습니다.\n\n![waveform visualization](https://miro.medium.com/v2/resize:fit:1400/1*qKzb1XpUrSGKdCL-OxhtLw.gif)\n\n```js\n@Composable\nfun GestureControlledWaveform() {\n    var amplitude by remember { mutableStateOf(100f) }\n    var frequency by remember { mutableStateOf(1f) }\n\n    Canvas(modifier = Modifier\n        .fillMaxSize()\n        .pointerInput(Unit) {\n            detectDragGestures { _, dragAmount -\u003e\n                amplitude += dragAmount.y\n                frequency += dragAmount.x / 500f\n                // 드래그에 기반한 주파수 조정\n            }\n        }\n        .background(\n            Brush.verticalGradient(\n                colors = listOf(Color(0xFF003366), Color.White, Color(0xFF66B2FF))\n            )\n        )) {\n        val width = size.width\n        val height = size.height\n        val path = Path()\n\n        val halfHeight = height / 2\n        val waveLength = width / frequency\n\n        path.moveTo(0f, halfHeight)\n\n        for (x in 0 until width.toInt()) {\n            val theta = (2.0 * Math.PI * x / waveLength).toFloat()\n            val y = halfHeight + amplitude * sin(theta.toDouble()).toFloat()\n            path.lineTo(x.toFloat(), y)\n        }\n\n        val gradient = Brush.horizontalGradient(\n            colors = listOf(Color.Blue, Color.Cyan, Color.Magenta)\n        )\n\n        drawPath(\n            path = path,\n            brush = gradient\n        )\n    }\n}\n```\n\n## 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 진폭과 주파수는 각각 웨이브폼의 진폭과 주파수를 제어하는 상태 변수입니다.\n- Canvas composable은 웨이브폼을 그리는데 사용됩니다. Canvas 내부의 그리기 로직은 사인 함수에 기반하여 각 X 위치에 대한 Y 위치를 계산하여 파동 효과를 만듭니다.\n- detectDragGestures 수정자는 사용자의 드래그 제스처에 기반하여 진폭과 주파수를 업데이트하는데 사용됩니다. 가로 드래그는 주파수를 조절하고, 세로 드래그는 진폭을 조절합니다.\n- 사용자가 화면을 가로지르면, 웨이브폼의 형태가 그에 따라 변경되어 상호 작용하는 경험을 제공합니다.\n\n## 참고\n\n- 이것은 기본 구현입니다. 보다 현실적인 오디오 웨이브폼을 만들려면 실제 오디오 데이터를 통합해야 합니다.\n- 제스처에 대한 웨이브폼의 반응은 드래그하는 동안 진폭과 주파수가 어떻게 수정되는지 조정하여 미세 조정할 수 있습니다.\n\n이 예제는 Compose에서 기본 대화형 웨이브폼을 만드는 방법을 보여주며, 더 복잡한 사용 사례에 확장하거나 수정하여 더 복잡한 제스처를 처리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 섹션 5 — Jetpack Compose에서 상태 주도 애니메이션 패턴\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*nkfhmC6JjQnshL3y_izhKg.gif)\n\n## 데이터 및 상태 변경에 따른 UI 애니메이션\n\n이 섹션은 데이터 또는 UI 상태 변경으로 구동되는 애니메이션을 생성하는 데 초점을 맞추어 앱의 상호 작용성과 반응성을 향상시킵니다. 우리는 데이터 그래프를 애니메이션화하고 다중 상태 UI에서 상태 전이를 구현하는 두 가지 구체적인 예시를 살펴볼 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## A) 데이터 기반 그래프 애니메이션\n\n이 예시는 데이터 세트의 변화에 반응하여 그래프의 경로가 애니메이션되는 라인 그래프를 보여줍니다.\n\n```js\n@Composable\nfun AnimatedGraphExample() {\n    var dataPoints by remember { mutableStateOf(generateRandomDataPoints(5)) }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(Color.DarkGray)\n    ) {\n        AnimatedLineGraph(dataPoints = dataPoints)\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Button(\n            onClick = {\n                dataPoints = generateRandomDataPoints(5)\n            },\n            modifier = Modifier.align(Alignment.CenterHorizontally),\n            colors = ButtonDefaults.buttonColors(containerColor = Color.Green)\n        ) {\n            Text(\n                \"데이터 업데이트\",\n                fontWeight = FontWeight.Bold,\n                color = Color.DarkGray,\n                fontSize = 18.sp\n            )\n        }\n    }\n}\n\n@Composable\nfun AnimatedLineGraph(dataPoints: List\u003cFloat\u003e) {\n    val animatableDataPoints = remember { dataPoints.map { Animatable(it) } }\n    val path = remember { Path() }\n\n    LaunchedEffect(dataPoints) {\n        animatableDataPoints.forEachIndexed { index, animatable -\u003e\n            animatable.animateTo(dataPoints[index], animationSpec = TweenSpec(durationMillis = 500))\n        }\n    }\n\n    Canvas(\n        modifier = Modifier\n            .fillMaxWidth()\n            .height(400.dp)\n    ) {\n        path.reset()\n        animatableDataPoints.forEachIndexed { index, animatable -\u003e\n            val x = (size.width / (dataPoints.size - 1)) * index\n            val y = size.height - (animatable.value * size.height)\n            if (index == 0) path.moveTo(x, y) else path.lineTo(x, y)\n        }\n        drawPath(path, Color.Green, style = Stroke(5f))\n    }\n}\n\nfun generateRandomDataPoints(size: Int): List\u003cFloat\u003e {\n    return List(size) { Random.nextFloat() }\n}\n```\n\n## 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- AnimatedGraphExample composable은 라인 그래프의 데이터 포인트를 업데이트할 수 있는 환경을 생성합니다.\n- 그래프는 Canvas 내에서 그려지며 drawPath 메서드는 animatableDataPoints에서 애니메이션 값을 사용합니다.\n- 그래프의 각 데이터 포인트에 대해 캔버스 상에서 해당 x (수평) 및 y (수직) 위치를 계산해야 합니다.\n- x 계산 — x 위치는 데이터 포인트의 인덱스와 캔버스의 총 너비에 기반하여 계산됩니다. 데이터 포인트를 캔버스 너비를 따라 균일하게 분산합니다.\n\n```js\nval x = (size.width / (dataPoints.size - 1)) * index\n```\n\n- y 계산 — y 위치는 데이터 포인트의 값 (animatable.value) 및 캔버스의 높이에 기반하여 계산됩니다.\n\n```js\nval y = size.height - (animatable.value * size.height)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 경로는 첫 번째 데이터 포인트에서 시작하여 lineTo를 사용하여 각 후속 포인트로 선을 그려 그래프 선을 생성합니다.\n- 경로는 데이터 포인트의 애니메이션 값에 기반하여 그려지며, 데이터가 변경될 때 애니메이션 효과를 만듭니다.\n\n## B) 다중 상태 UI에서 상태 전환\n\n다중 상태 UI에서 상태 전환을 구현하는 방법은 Animatable을 사용하여 다른 UI 상태 간에 애니메이션을 적용하는 것입니다.\n\n```js\nenum class UIState { StateA, StateB, StateC }\n\n@Composable\nfun StateTransitionUI() {\n    var currentState by remember { mutableStateOf(UIState.StateA) }\n\n    Box(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(getBackgroundColorForState(currentState)),\n        contentAlignment = Alignment.Center\n    ) {\n        AnimatedContent(currentState = currentState)\n\n        Button(\n            onClick = { currentState = getNextState(currentState) },\n            modifier = Modifier.align(Alignment.BottomCenter)\n        ) {\n            Text(\"다음 상태\")\n        }\n    }\n}\n\n@Composable\nfun AnimatedContent(currentState: UIState) {\n    AnimatedVisibility(\n        visible = currentState == UIState.StateA,\n        enter = fadeIn(animationSpec = tween(durationMillis = 2000)) + expandVertically(),\n        exit = fadeOut(animationSpec = tween(durationMillis = 2000)) + shrinkVertically()\n    ) {\n        Text(\"현재 상태는 ${currentState.name} 입니다\", fontSize = 32.sp)\n    }\n\n    // B와 C에 대한 유사한 블록\n\n}\n\nfun getBackgroundColorForState(state: UIState): Color {\n    return when (state) {\n        UIState.StateA -\u003e Color.Red\n        UIState.StateB -\u003e Color.Green\n        UIState.StateC -\u003e Color.Blue\n    }\n}\n\nfun getNextState(currentState: UIState): UIState {\n    return when (currentState) {\n        UIState.StateA -\u003e UIState.StateB\n        UIState.StateB -\u003e UIState.StateC\n        UIState.StateC -\u003e UIState.StateA\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설명\n\n- 이 예시에서 AnimatedVisibility는 각 상태의 콘텐츠가 나타나고 사라질 때 애니메이션 효과를 적용하는 데 사용됩니다. 이는 상태가 변경될 때 부드러운 전환 효과를 추가합니다.\n- 각 상태(StateA, StateB, StateC)마다 해당 콘텐츠의 가시성을 페이드 및 확장/축소 애니메이션으로 제어하는 AnimatedVisibility 블록이 있습니다.\n- AnimatedVisibility의 enter 및 exit 매개변수는 콘텐츠가 표시되거나 숨겨질 때의 애니메이션을 정의합니다.\n\n# 섹션 6 — Compose에서 모양 변환\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*q82EIocVzR8XBMuG_14mdg.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도형 간 변환 애니메이션은 이러한 도형의 속성을 보간하는 것을 포함합니다.\n\n```js\n@Composable\nfun ShapeMorphingAnimation() {\n    val animationProgress = remember { Animatable(0f) }\n\n    LaunchedEffect(Unit) {\n        animationProgress.animateTo(\n            targetValue = 1f,\n            animationSpec = infiniteRepeatable(\n                animation = tween(2000, easing = LinearOutSlowInEasing),\n                repeatMode = RepeatMode.Reverse\n            )\n        )\n    }\n\n    Canvas(modifier = Modifier.padding(40.dp).fillMaxSize()) {\n        val sizeValue = size.width.coerceAtMost(size.height) / 2\n        val squareRect = Rect(center = center, sizeValue)\n\n        val morphedPath = interpolateShapes(progress = animationProgress.value, squareRect = squareRect)\n        drawPath(morphedPath, color = Color.Blue, style = Fill)\n    }\n}\n\nfun interpolateShapes(progress: Float, squareRect: Rect): Path {\n    val path = Path()\n\n    val cornerRadius = CornerRadius(\n        x = lerp(start = squareRect.width / 2, stop = 0f, fraction = progress),\n        y = lerp(start = squareRect.height / 2, stop = 0f, fraction = progress)\n    )\n\n    path.addRoundRect(\n        roundRect = RoundRect(rect = squareRect, cornerRadius = cornerRadius)\n    )\n\n    return path\n}\n\nfun lerp(start: Float, stop: Float, fraction: Float): Float {\n    return (1 - fraction) * start + fraction * stop\n}\n```\n\n## 설명\n\n- ShapeMorphingAnimation은 animationProgress 값을 0과 1 사이로 토글하는 무한 애니메이션을 설정합니다.\n- Canvas 콤포저블을 사용하여 도형을 그립니다. 여기서 캔버스 크기에 기반하여 정사각형의 크기(squareRect)를 정의합니다.\n- interpolateShapes는 현재 애니메이션 진행도와 정사각형 사각형을 가져와 원과 정사각형 사이를 보간합니다. 변형되는 모양을 나타내는 둥근 직사각형의 cornerRadius를 서서히 조절하기 위해 lerp(선형 보간)를 사용합니다.\n- 진행도가 0일 때 cornerRadius는 직사각형의 반만큼이므로 도형은 원이 됩니다. 진행도가 1일 때 cornerRadius는 0이 되어 도형이 정사각형이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 실제 사용 사례\n\n- 로딩 및 진행 상태 표시기 — 모프 형태는 더 매력적인 로딩 또는 진행 상태 표시기를 만드는 데 사용될 수 있습니다. 진행 상태나 로딩 상태를 나타내는 더욱 시각적으로 흥미로운 방법을 제공합니다.\n- UI 내 아이콘 전환 — 모프 아이콘은 사용자 작업에 대한 시각적 피드백을 제공하는 데 사용할 수 있습니다. 예를 들어, 클릭할 때 플레이 버튼이 일시 중지 버튼으로 변하는 경우 또는 햄버거 메뉴 아이콘이 뒤로 이동하는 화살표로 변하는 경우 등.\n- 데이터 시각화 — 복잡한 데이터 시각화에서 모프는 사용자가 시간에 따른 변경 또는 범주 간의 변화를 따라가고 이해하기 쉽도록 돕는 데 도움이 될 수 있습니다.\n\n# 눈 오는 소리 좀?\n\n간단한 입자 시스템을 사용하여 눈이 내리는 효과를 만들어보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경합니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*E26GhhxDZLGTpE8gMvJoHw.gif\" /\u003e\n\n```js\ndata class Snowflake(\n    var x: Float,\n    var y: Float,\n    var radius: Float,\n    var speed: Float\n)\n\n@Composable\nfun SnowfallEffect() {\n    val snowflakes = remember { List(100) { generateRandomSnowflake() } }\n    val infiniteTransition = rememberInfiniteTransition(label = \"\")\n\n    val offsetY by infiniteTransition.animateFloat(\n        initialValue = 0f,\n        targetValue = 1000f,\n        animationSpec = infiniteRepeatable(\n            animation = tween(durationMillis = 5000, easing = LinearEasing),\n            repeatMode = RepeatMode.Restart\n        ), label = \"\"\n    )\n\n    Canvas(modifier = Modifier.fillMaxSize().background(Color.Black)) {\n        snowflakes.forEach { snowflake -\u003e\n            drawSnowflake(snowflake, offsetY % size.height)\n        }\n    }\n}\n\nfun generateRandomSnowflake(): Snowflake {\n    return Snowflake(\n        x = Random.nextFloat(),\n        y = Random.nextFloat() * 1000f,\n        radius = Random.nextFloat() * 2f + 2f, // Snowflake size\n        speed = Random.nextFloat() * 1.2f + 1f  // Falling speed\n    )\n}\n\nfun DrawScope.drawSnowflake(snowflake: Snowflake, offsetY: Float) {\n    val newY = (snowflake.y + offsetY * snowflake.speed) % size.height\n    drawCircle(Color.White, radius = snowflake.radius, center = Offset(snowflake.x * size.width, newY))\n}\n```\n\n## 설명\n\n- SnowfallEffect는 여러 개의 눈송이(Snowflake 객체)를 가진 입자 시스템을 설정합니다.\n- 각 Snowflake는 위치 (x, y), 반지름 (크기), 속도와 같은 속성을 갖습니다.\n- rememberInfiniteTransition 및 animateFloat은 눈이 내리는 것을 시뮬레이션하기 위한 연속적인 수직 이동 효과를 생성하는 데 사용됩니다.\n- Canvas composable은 각 눈송이를 그리는 데 사용됩니다. drawSnowflake 함수는 속도와 애니메이션된 offsetY에 기반하여 각 눈송이의 새 위치를 계산합니다.\n- 눈송이들은 아래로 떨어진 후 다시 위로 나타나며, 반복되는 눈내림 효과를 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n제트팩 구성에서 애니메이션을 탐색하면서 마무리하는 시점에서, 애니메이션이 시각적 장식 이상의 중요한 도구라는 것이 분명해졌습니다. 애니메이션은 매력적이고 직관적이며 즐거운 사용자 경험을 만드는 데 중요한 도구입니다.\n\n## 상호 작용 포용\n\n게임 캐릭터의 동적인 움직임부터 인터랙티브 타임라인까지, 우리는 애니메이션이 사용자 상호작용을 더 매력적이고 유익하게 만들 수 있는 방법을 알아보았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 현실적인 경험 구현하기\n\n눈 내리는 효과와 형태 변화는 이 도구상자가 디지털 영역에 현실감과 유동성을 표현하는 능력을 보여줍니다. 이러한 애니메이션들은 사용자와 공감을 형성하는 몰입형 경험을 만들어줍니다.\n\n## 복잡함을 간단하게 만들기\n\n여러 요소를 조정하거나 상태 전환을 애니메이션화하는 경우, 이것이 할 수 있는 간단함이 돋보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리 인사\n\n만약 읽은 것이 마음에 들었다면, 소중한 피드백이나 감사의 말을 자유롭게 남겨주세요. 저는 항상 개발자 친구들과 함께 배우고 협력하며 성장하고자 노력하고 있습니다.\n\n질문이 있으시다면 언제든지 메시지를 보내주세요!\n\n더 많은 기사를 보시려면 저의 Medium 프로필을 팔로우해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinkedIn과 트위터에서 저와 연결해주세요. 협업 기회가 있을지도 몰라요.\n\n애니메이션 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png","tag":["Tech"],"readingTime":30},{"title":"Callback 대신 Coroutine 사용하는 방법","description":"","date":"2024-06-23 23:28","slug":"2024-06-23-HowtouseaCoroutineinsteadofCallback","content":"\n콜백을 코루틴으로 대체하는 것은 비동기 작업을 처리하기 위해 콜백을 사용하는 코드를 코루틴 기반 코드로 변환하는 것을 의미합니다. 이렇게하면 코드가 더 읽기 쉽고 유지 관리하기 쉬워집니다. Kotlin에서 코루틴은 복잡한 콜백 체인 없이 비동기 작업을 처리할 수 있습니다.\n\n아래는 콜백 기반 접근 방식을 코루틴으로 대체하는 방법입니다:\n\n콜백 수신을 위한 인터페이스:\n\n```js\ninterface Callback\u003cT\u003e {\n    fun onSuccess(response: T)\n    fun onFailure(e: Throwable)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상화 계층 추가를 위한 서비스 인터페이스:\n\n```kotlin\ninterface FruitService {\n    fun fetchFruits(callback: Callback\u003cList\u003cString\u003e\u003e)\n}\n```\n\n과일 목록을 가져오는 데이터 소스:\n\n```kotlin\nclass FruitsDataSource : FruitService {\n    override fun fetchFruits(callback: Callback\u003cList\u003cString\u003e\u003e) {\n        Thread {\n            try {\n                Thread.sleep(1000) // API 호출을 시뮬레이션하기 위한 지연\n                callback.onSuccess(fruits)\n            } catch (e: Exception) {\n                callback.onFailure(e)\n            }\n        }.apply {\n            start()\n            join()\n        }\n    }\n\n    private companion object {\n        val fruits = listOf(\n            \"사과\",\n            \"망고\",\n            \"체리\",\n            \"바나나\",\n            \"레몬\",\n            \"수박\",\n            \"달콤한 라임\",\n            \"오렌지\",\n            \"키위\"\n        )\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI 호출을 하는 저장소:\n\n```js\nclass FruitsRepository(\n    fruitService: FruitService\n) {\n\n    private var _service: FruitService = fruitService\n\n    fun fetchFruits(callback: Callback\u003cList\u003cString\u003e\u003e) {\n        _service.fetchFruits(callback)\n    }\n}\n```\n\n# 1. Callback 접근 방식 이해\n\n일반적인 콜백 기반 함수부터 시작해봅시다. 비동기 작업을 하는 과일 데이터를 가져오는 작업이 있으며 결과를 반환하기 위해 콜백을 사용한다고 가정해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nfun fetchFruitsLegacyWay(repository: FruitsRepository) {\n    repository.fetchFruits(object : Callback\u003cList\u003cString\u003e\u003e {\n        override fun onSuccess(response: List\u003cString\u003e) {\n            println(\"fetchFruitsLegacyWay: onSuccess: $response \")\n        }\n\n        override fun onFailure(e: Throwable) {\n            println(\"fetchFruitsLegacyWay: onFailure: ${e.message} \")\n        }\n    })\n}\n```\n\nCallback을 사용하여 API 호출하는 방법:\n\n```kotlin\nfun main() {\n    val repository = FruitsRepository(LegacyDataSource())\n    fetchFruitsLegacyWay(repository)\n}\n```\n\n# 2. 코루틴으로 변환하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이를 코루틴 기반 접근 방식으로 변환하려면 다음 단계를 따르세요:\n\n- 서스펜드 함수 생성: 콜백 함수를 서스펜드 함수로 변경합니다.\n- 코루틴 빌더 사용: launch 또는 async를 사용하여 코루틴 스코프 내에서 서스펜드 함수를 호출합니다.\n- 예외 처리: 콜백 오류 메서드 대신 코루틴 내에서 try-catch를 사용하여 예외를 처리합니다.\n\n## 단계별 변환\n\n서스펜드 함수 정의: 콜백을 제거하고 함수를 서스펜드로 변경하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 내용을 추가하여 Service Interface를 업데이트하세요:\n\n```kotlin\nsuspend fun fetchFruits(): List\u003cString\u003e // 새로운 중단 함수\n```\n\n아래 코드를 추가하여 FruitsDataSource를 업데이트하세요:\n\n```kotlin\n// 과일 목록을 가져오는 중단 함수\noverride suspend fun fetchFruits(): List\u003cString\u003e {\n    delay(1000) // API 호출을 모방하기 위한 지연\n    return fruits\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 코드를 추가하여 FruitsRepository를 업데이트해주세요:\n\n```kotlin\noverride suspend fun fetchFruits(): List\u003cString\u003e  {\n    return _service.fetchFruits()\n}\n```\n\n사용하는 Suspend Function 호출하기: launch 또는 async와 같은 코루틴 빌더를 사용하여 suspend function을 호출합니다.\n\n## launch를 사용한 예시''\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprivate suspend fun fetchFruitsUsingCoroutine(repository: FruitsRepository) {\n    try {\n        println(\"fetchFruitsUsingCoroutine 성공:${repository.fetchFruits()}\")\n    } catch (ex: Exception) {\n        println(\"fetchFruitsUsingCoroutine 실패:${ex.message}\")\n    }\n}\n```\n\n```js\nfun main() = runBlocking {\n    // IO 컨텍스트에서 코루틴 실행\n    launch(Dispatchers.IO) {\n        try {\n            val repository = FruitsRepository(LegacyDataSource())\n            fetchFruitsUsingCoroutine(repository)\n            println(result) // Output: 서버로부터의 과일 목록\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n}\n```\n\n# 3. Async/Await를 사용한 여러 작업 처리\n\n만약 여러 비동기 태스크를 수행해야 한다면, 코루틴은 동시 실행을 위해 async를, 결과를 기다리기 위해 await를 사용하여 더 우아하게 처리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 코루틴을 이용한 여러 작업\n\n```js\nfun main() = runBlocking {\n  val repository = FruitsRepository(LegacyDataSource())\n\n  val fruits1 = async { repository.fetchFruits() } //API 호출 1\n  val data1 = fruits1.await()\n  println(\"Data1: $data1\") // 출력: 서버에서 과일 목록\n\n  val fruits2 = async { repository.fetchFruits() } // API 호출 2\n  val data2 = fruits2.await()\n  println(\"Data2: $data2\") // 출력: 서버에서 과일 목록\n}\n```\n\n# 4. 기존 코드 통합\n\n기존 콜백을 사용하는 레거시 시스템과 통합할 때, suspendCoroutine 또는 suspendCancellableCoroutine을 사용하여 콜백 기반 코드를 코루틴으로 래핑할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 코루틴을 이용한 콜백 감싸기\n\n```kotlin\nprivate suspend fun fetchFruitsUsingCoroutines(repository: FruitsRepository) {\n  suspendCoroutine { continuation -\u003e\n      repository.fetchFruits(object : Callback\u003cList\u003cString\u003e\u003e {\n          override fun onSuccess(response: List\u003cString\u003e) {\n              continuation.resume(response)\n          }\n\n          override fun onFailure(e: Throwable) {\n              continuation.resumeWithException(e)\n          }\n      })\n  }.let {\n      println(\"fetchFruitsUsingCoroutines: Response: $it\")\n  }\n}\n```\n\n# 5. 코루틴 사용의 장점\n\n- 가독성: 코루틴을 사용하면 동기 코드처럼 보이고 동작하는 비동기 코드를 간편하게 작성할 수 있습니다.\n- 확장성: 코루틴은 가벼우며 많은 수의 동시 작업을 효율적으로 처리할 수 있습니다.\n- 구조화된 병행성: 비동기 작업의 라이프사이클을 보다 효과적으로 관리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n콜백을 코루틴으로 변환하면 코드를 현대화하여 유지 및 확장하기 쉬워집니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtouseaCoroutineinsteadofCallback_0.png"},"coverImage":"/assets/img/2024-06-23-HowtouseaCoroutineinsteadofCallback_0.png","tag":["Tech"],"readingTime":8},{"title":"WhatsApp 앱을 삭제하면 일어나는 일 정확히","description":"","date":"2024-06-23 23:26","slug":"2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly","content":"\nWhatsApp 앱을 스마트폰에서 삭제하면 어떻게 될까요? 필요한 모든 정보가 여기 있습니다.\n\n![WhatsApp](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_0.png)\n\n안녕하세요, WhatsApp 애찬러 여러분! WhatsApp을 삭제하면 어떻게 될지 생각해 보신 적이 있나요? 너무 많은 알림을 받아 지친다거나 소셜 미디어에서 쉬고 싶어서 삭제를 고려 중이시라면 어쨌든, WhatsApp을 삭제하면 어떤 일이 일어나는지 그리고 이것이 좋은 생각인지 탐구해보려고 합니다.\n\n# WhatsApp을 삭제하면 어떤 일이 벌어질까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n휴대폰에서 WhatsApp을 삭제하기로 결정했군요. 그럼 이제 어떻게 해야 할까요? 먼저 홈 화면에서 앱 아이콘이 사라진 것에 놀라실 것입니다.\n\n걱정 마세요. 채팅 기록과 미디어 파일은 기기에 저장되어 있어, 나중에 앱을 재설치하기로 결정하면 이를 검색할 수 있습니다. 그러나 WhatsApp 계정을 삭제하기 전에 앱을 삭제한다면, 채팅 기록과 미디어 파일은 영원히 손실됩니다. 그러니 그 '삭제' 버튼을 누르기 전에 잘 생각해 보세요!\n\n![WhatsApp 삭제 vs. 삭제](https://miro.medium.com/v2/resize:fit:1000/0*mx-YpBjt4SgHRRd_.gif)\n\n# WhatsApp 삭제 vs. 삭제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, WhatsApp 계정을 삭제하는 것과 삭제하는 것의 차이점을 명확히 해보겠습니다. WhatsApp 계정을 삭제하면 더 이상 아무도 당신의 WhatsApp 프로필이나 상태 메시지를 볼 수 없으며, 당신에게 메시지를 보낼 수도 없습니다.\n\n하지만 여전히 스마트폰에 WhatsApp 앱이 남아 있게 됩니다.\n\nWhatsApp 계정을 사용하여 받은 모든 미디어 파일, 오디오, 이미지 및 비디오는 그대로 남게 됩니다.\n\n그러나 앱을 삭제(삭제)만 한다면, 여전히 당신의 프로필 사진과 WhatsApp 상태 메시지가 모든 연락처에게 표시되고, 메시지를 보낼 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:700/0*H3kj8ruicOo_ZvVG.gif)\n\n앱을 삭제하면 기기에서 완전히 제거되며, 백업을 하지 않은 경우에는 채팅 기록이 함께 삭제됩니다. 따라서 삭제 버튼을 누르기 전에 신중하게 생각해보세요. 모든 부끄러운 채팅 메시지를 잃고 싶지 않으시죠!\n\nWhatsApp 앱을 삭제하면 먼저 해당 애플리케이션이 기기에서 제거됩니다. 그러나 WhatsApp을 통해 받은 미디어 파일은 여전히 기기에 남아 있습니다. 이를 모바일 갤러리에서 확인할 수 있습니다.\n\nWhatsApp 폴더에 접근하여 파일 관리자를 통해 WhatsApp 백업 파일을 찾을 수 있습니다. 따라서 앱을 다시 설치할 때 앱 내에서 빠르게 백업 복원을 시작하고 모든 채팅 및 대화를 다시 받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 왓츠앱 앱을 삭제한 후 채팅 메시지는 어떻게 됩니까?\n\n왓츠앱을 백업하지 않고 삭제하면 채팅 메시지가 영원히 사라집니다. 따라서 앱을 삭제하기 전에 데이터를 백업하는 것이 중요합니다.\n\n게다가, 데이터를 백업하는 것은 매우 쉽습니다 — 왓츠앱 설정으로 이동하여 “채팅”을 클릭한 다음 “채팅 백업”을 선택하세요. 왓츠앱을 삭제하기 전에 꼭 이 작업을 해 주세요! 이렇게 하면 나중에 왓츠앱을 다시 설치하면 채팅 메시지를 복구할 수 있습니다.\n\n# 그룹 대화는 어떻게 됩니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아, 사랑받는 그룹 채팅. WhatsApp을 삭제하거나 제거하면 그룹 채팅이 어떻게 될까요? 그룹 대화에 참여 중인 경우 앱을 삭제하거나 제거해도 그룹에서 제거되지는 않지만 백업을 수행하지 않았다면 채팅 내용이 삭제됩니다.\n\n하지만 걱정하지 마세요. WhatsApp 백업을 가지고 있다면 채팅 내용을 되찾을 수 있습니다.\n\n# WhatsApp 연락처에는 여전히 나를 볼 수 있나요?\n\n네, 연락처는 여전히 내 연락처를 저장한 사람에게는 보이게 됩니다. 게다가 WhatsApp 프로필과 WhatsApp 소개글은 여전히 그들에게 보이게 됩니다. 그러나 WhatsApp은 6개월 동안 접근되지 않은 계정을 자동으로 삭제하는 정책을 가지고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 마크다운 형식으로 표 태그(table tag)를 변경해주세요.\n\n![이미지](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_1.png)\n\nWhatsApp을 삭제하기로 결정했다면, 6개월 이내에 앱을 재설치하면 계정이 그대로 유지됩니다. 하지만 6개월 동안 앱을 삭제한 채 유지한다면, WhatsApp은 자동으로 계정을 삭제합니다.\n\n# WhatsApp 삭제 여부 확인하는 방법\n\n만약 누군가가 WhatsApp을 삭제했는지 궁금하다면, 몇 가지 지표를 주목하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n얼굴책 앱을 제거한 사람에게 특별한 알람이 없습니다. 그러나 텍스트를 보내면 메시지가 전달되지 않았다는 것을 알 수 있습니다.\n\n아래 스크린샷을 보면 언인스톨한 WhatsApp 어카운트가 어떻게 보이는지 확인할 수 있습니다.\n\n프로필을 선택하면 유료 프로필 사진과 소개가 여전히 보이는 것을 알 수 있습니다.\n\n![WhatsApp 어플 제거 시 모습](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# WhatsApp을 삭제하는 경우의 잠재적 인과:\n\nWhatsApp을 삭제하면 고려하지 못했을 일부 결과가 발생할 수 있습니다. 예를 들어 WhatsApp은 비즈니스 목적으로 일반적으로 사용됩니다. 앱을 삭제하면 고객이나 동료로부터 중요한 메시지를 놓칠 수 있습니다. 게다가 WhatsApp을 사용하는 친구나 가족이 있다면 중요한 업데이트나 초대장을 놓칠 수도 있습니다.\n\n하지만 걱정하지 마세요. WhatsApp 대신 사용할 수 있는 Telegram 또는 Signal과 같은 대안 메시징 앱이 있습니다. 또는 시크릿 텍스트 앱을 사용할 수도 있습니다.\n\n# WhatsApp 삭제 이유\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWhatsApp을 제거하기로 결정한 이유는 여러 가지가 있을 수 있어요. 개인 정보 보호에 대해 걱정되고 소셜 미디어 사용을 제한하고 싶은 경우도 있을 것이고, 너무 많은 알림을 받아 지쳤을 수도 있어요.\n당신의 이유가 무엇이든, 중요한 건 당신의 개인적인 필요와 선호에 따라 결정해야 한다는 것을 기억하는 것이 중요해요.\n\n![WhatsApp Uninstall](https://miro.medium.com/v2/resize:fit:702/0*ag0UkOO8ba1z6xrG.gif)\n\n# WhatsApp 제거에 대한 제 경험\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n왜 WhatsApp를 제거하면 어떤 일이 벌어질지 궁금한가요? 진정한 WhatsApp 사용자로서, 제가 직접 실험을 해보고 결과를 공유해봤어요.\n\n우선, 폰에서 WhatsApp을 삭제했어요. 그 폰에는 소중한 대화와 그룹 채팅이 있었는데요.\n\n만약 WhatsApp을 삭제하면, 다른 사람들이 여전히 연락처 정보를 볼 수 있습니다. 그들이 여전히 당신의 전화번호를 연락처에 저장해 놓았다면, 당신의 프로필을 볼 수 있고 WhatsApp 소개글을 확인할 수 있어요.\n\n# 다시 앱을 설치할 때\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWhatsApp을 재설치하여 대화 및 백업이 어떻게 되는지 확인하고 앱이 없는 상태에서 받은 새 메시지가 있는지 확인해 보았어요.\n\n![이미지](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_3.png)\n\n놀랍게도, 해당 WhatsApp 계정으로 여전히 메시지를 보낼 수 있었어요. 메시지가 전송되었지만 전달된 것은 아닌 틱으로 표시되었어요.\n\n# 백업 없이 WhatsApp을 재설치한 후 발생한 일들:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 휴대전화 번호를 입력하고 OTP를 받은 후, WhatsApp은 내 이름을 입력하고 모두 허용하기만 하면 앱에 재접속하라고 요청했어요. 그런데, 세 명의 연락처가 나에게 메시지를 보냈지만, 그 메시지들은 처음부터 목록에 없었다는 것을 깨달았어요.\n\n![그림](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_4.png)\n\nWhatsApp은 최근 그룹에 가입했다는 메시지를 표시해요. WhatsApp을 백업하지 않고 삭제한 후 재설치하면 이전에 가입한 모든 그룹을 여전히 볼 수 있어요.\n\n또한, 여러분이 앱을 사용하지 않을 때 누군가가 메시지를 보낸 경우, 그 메시지들은 \"메시지 대기 중\"으로 표시돼요. 재설치 후 몇 분 후에는 그 메시지들이 표시되지만, 15일 또는 28일 이상된 이미지를 받았다면 다운로드할 수 없을 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실험 결과, WhatsApp을 삭제해도 프로필과 대화를 완전히 삭제되지 않을 수 있다는 것을 보여줬어요. 그러나 삭제하기 전에 백업을 하지 않으면 몇 가지 메시지와 이미지를 놓칠 수 있습니다.\n\n그래서, 다음에 WhatsApp을 삭제하려면 삭제 전에 백업을 하는 것이 좋아요!\n\n# 결론\n\n그래서, WhatsApp을 삭제해야 할까요? 개인적인 선호도와 필요에 따라 다릅니다. 개인 정보 보호에 대해 걱정되거나 소셜 미디어에서 잠시 쉬어야 할 때 WhatsApp을 삭제하는 것이 좋은 아이디어일 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 업무나 친구, 가족과의 소통에 WhatsApp을 의존하고 있다면, 앱을 삭제하기 전에 한 번 더 신중히 생각해야 할 것입니다.\n\n최종 결정은 여러분에 달려 있지만, WhatsApp을 삭제한다면 대체 메시징 앱이 있음을 기억해야 합니다.\n\n요약하면, WhatsApp을 삭제하는 것은 즉각적인 영향과 아직 고려하지 못한 잠재적인 결과를 초래할 수 있습니다.\n\n그러므로 개인적인 필요와 선호 사항을 고려해 최선의 결정을 내리는 데 시간을 들이세요! 결정을 내리기 전에 장단점을 따져보고, WhatsApp을 삭제하기로 결정할 경우 대체 메시징 앱이 있음을 잊지 마세요.\n","ogImage":{"url":"/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_0.png"},"coverImage":"/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_0.png","tag":["Tech"],"readingTime":9},{"title":"애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까","description":"","date":"2024-06-23 23:25","slug":"2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini","content":"\n![Beeper](/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png)\n\n내가 미쳤다고 생각할지도 모르는 전환 속에, 나는 Apple이 Beeper가 iMessage를 Android로 가져오려는 시도를 차단한 것이 완전히 옳았다고 믿습니다. iMessage가 Android에서 작동하는 것이 나쁠 것이라고 하는 게 아니라, Beeper가 운영 방식이 내 책에서는 그리 괜찮았기 때문입니다.\n\nBeeper의 블로그는 \"안드로이드 및 iPhone 고객들은 고화질 이미지/비디오, 암호화, 이모티콘, 타이핑 상태, 읽은 표시 및 모든 최신 채팅 기능과 함께 채팅할 수 있기를 간절히 원한다\"고 주장합니다.\n\niMessage는 이러한 기능을 제공합니다. 다만, Android 폰에는 그렇지 않습니다. Beeper의 해결책은 무엇인가요? iMessage를 Android로 가져오는 것입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문제는 실행 방식에 있습니다.\n\niMessage는 Apple 기기인 iPhone, iPad, Mac 및 Apple Watch와 함께 사용하도록 만들어졌습니다. Android나 Android 기기와 함께 사용하거나 이용할 수 있도록 만들어지지 않았습니다.\n\n그리고 iMessage를 작동시키려면 Beeper가 시스템을 속여야 합니다.\n\n# Beeper Mini란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBeeper Mini는 안드로이드 앱으로, Apple의 iMessage 프로토콜을 역공학으로 메시지를 보내어 어떤 안드로이드 폰이라도 iMessage를 사용할 수 있도록 설계되었습니다.\n\nBeeper는 기기에서 암호화 키를 생성하고 공개 키를 Apple에 업로드합니다. 그러나 iMessage가 있는 iPhone에서와 같이 Apple 푸시 알림 서비스를 사용하는 대신, Beeper는 Apple의 서버와 상호작용하고 새 메시지 알림을 사용자에게 통지하는 Beeper Push Notification(BPN) 서비스를 개발했습니다.\n\n여기서 주목할 점은, 이것이 iMessage의 단순한 모방이 아니라는 것입니다. Beeper의 시스템은 권한 없이 실제로 Apple 서버를 사용하도록 설계되었습니다.\n\nBeeper는 Android로 iMessage를 가져오려는 첫 번째 시도가 아닙니다. Nothing Chats는 성공적으로 - 잠시 동안 - Nothing 폰에서 iMessage를 작동시켜마지만 중단되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정말로, Beeper는 똑똑한 시스템입니다. 그리고 그것은 작동하는 것처럼 보입니다. 하지만 그것이 옳다고는 할 수 없습니다.\n\n# 애플에 의한 종료\n\nBeeper Mini가 처음 출시된 후 얼마 지나지 않아 애플에 의해 종료되었습니다. 애플은 Beeper가 애플의 재산을 오용했다는 우려를 제기하면서 이를 타당하게 꼽았습니다.\n\n분명히, Beeper가 iMessage를 사용하는 방식을 기준으로 볼 때, 이것이 iMessage의 규정 위반인 것처럼 보이지는 않습니다. 그것은 좋은 소식입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만, 애플 시스템을 오용하는 것은 아닙니다.\n\n일부 사람들은 애플이 Beeper Mini를 폐쇄한 주된 또는 유일한 동기가 iMessage의 독점성을 보존하는 것인지 주장해왔습니다. 애플은 진정으로 보안에 관심이 없고 안드로이드 사용자를 제외하기만을 원한다고 말하는 사람들도 있습니다.\n\n이것이 사실인지 아닌지 논쟁할 수 있습니다. 하지만 실제로 그렇다 하더라도, 애플이 자사 시스템과 지적 재산을 보호할 권리는 없을까요?\n\n네, 정답은 네입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서의 문제는 두 가지입니다:\n\n- Beeper가 아이폰 간의 메시지를 주고받는 것으로 시스템을 속이기 위해 직접 Apple 서버에 연락하고 있습니다.\n- Beeper는 \"네이티브 iMessage 앱과 Apple 서버 간에 전송되는 트래픽을 분석하고 동일한 요청을 보내고 동일한 응답을 이해하는 자체 앱을 개발했다\"고 주장합니다. 다시 말하면, 그들은 Apple의 지적 재산을 역공학으로 분석했습니다.\n\nBeeper가 종료된 지 얼마 후에 약간의 수정을 거쳐 다시 온라인으로 돌아왔습니다.\n\n현재 상황은 좋은 점과 나쁜 점이 혼재되어 있습니다 -- 어떤 사람에게는 작동되는 반면 다른 사람에게는 작동되지 않을 수 있습니다. 내 추측으로는, Apple이 비공식적으로 모두 종료하게 될 것으로 생각됩니다. 그리고 Beeper가 다시 돌아온다 하더라도, 그들이 앞으로 하게 될 일은 그냥 야생의 고양이와 마우스 장난일 것으로 예상합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# “Apple just wants to keep iMessage exclusive.”\n\n애플을 비판하는 사람들은 Beeper를 종료하기로 한 애플의 결정이 그 서비스 및 사용자의 보안을 위해서가 아닌 사악하게 행동했다고 주장합니다. 그들은 애플이 iMessage의 독점성을 보전하고 안드로이드 사용자를 생태계 밖으로 배제하기 위해 행동했다고 주장합니다.\n\n일단 그게 사실이라고 가정해 봅시다. 가정해 봅시다.\n\n그게 잘못된 건가요? 그게 문제가 될까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n회사가 자신의 재산에 대해 원하는 대로 할 권리가 없습니까? Apple이 iPhone 사용자를 위한 독점 기능으로 자사의 재산 인 iMessage을 유지할 권리가 없습니까? 물론, 그 권리가 있습니다.\n\n그러나 여기에는 더 많은 것이 작용할 수 있다고 말할 수도 있습니다.\n\nBeeper는 제3자 응용 프로그램을 통해 Apple 서버로 메시지를 보내고, 이 응용 프로그램 자체가 역공학이 된 iMessage 프로토콜을 사용하여 작동합니다.\n\n모든 면에서 그것은 걱정스럽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알았어요! 테이블 태그를 마크다운 형식으로 변경할게요.\n\n| 번호 | 제품   | 가격 |\n| ---- | ------ | ---- |\n| 1    | 사과   | $1   |\n| 2    | 바나나 | $2   |\n| 3    | 체리   | $3   |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플은 아직도 다른 애플 기기가 아닌 기기들과 통신하기 위해 SMS를 사용하고 있다는 사실이 맞아요. 그렇죠. 그리고 이것이 바뀌어야 한다는 사실도 맞아요 (그리고 곧 바뀔 예정이에요).\n\n하지만 이게 변명이 될까요?\n\n애플 시스템을 일부러 남용하는 것을 옹호할 이유가 될까요?\n\n아마 그렇지 않아요. 그렇지 않다고 생각해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사실 안드로이드 및 iPhone 사용자들은 SMS를 사용하지 않고도 함께 채팅할 수 있는 방법이 있습니다.\n\n메신저, WhatsApp, Signal 등을 통해 누군가에게 메시지를 보내려면 상대방도 해당 앱의 사용자여야 하지만, 그런 건 어렵지 않죠.\n\n안드로이드 및 iOS 사용자들이 iMessage 사용자들이 오늘날 즐기는 많은 채팅 기능을 곧 누리게 될 때를 기대합니다.\n\n애플의 시스템을 잘못 사용하는 것은 좋은 해결책이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# \"애플이 보안에 중요시한다면, 왜 아직도 SMS를 사용하나요?\"\n\n확실히 상대적으로 보안 수준이 낮은 SMS에서 전진할 수 있다면 좋을텐데, 다행히 Apple은 곧 SMS를 버리고 RCS를 선호하게 될 것입니다.\n\n하지만 여러 번 읽어본 바에 의하면, Apple이 Beeper를 차단한 것은 사실상 iMessage 독점성을 보호하기 위한 조치일 뿐이며, 여전히 SMS를 사용한다는 점 때문에 보안에 중점을 두지 않고 있다는 주장을 볼 수 있습니다.\n\n다시 말해, 정말로 보안과 개인 정보 보호를 중요시한다면, 먼저 SMS를 대체할 것에 집중해야 한다는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 그게 어떻게 작동하는지 아시나요? 이건 빨간 물고기라고 할만한 거예요.\n\n우리는 집 침입을 변론할 때 창문 잠금에 실패한 집 주인을 꺼내들어 가장하지 않아요. 창문을 잠그지 않아서 잘못했나요? 네. 그럼 침입은 여전히 잘못인가요? 네.\n\n두 가지가 모두 맞아요. 둘 다 나쁘지만, 사실이에요.\n\n# 여기서 객관적으로 생각해 보기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 사람들이 나를 애플 열광자로 생각할 수 있다는 걸 방지하기 위해 먼저 말하지만, 전 그렇지 않아요. 쿠퍼티노에서 보여준 소비자에게 해로운 여러 가지 결정들에 대해 공개적으로 비판했어요. 그 중 일부는 다른 것보다 더 화나게 만들기도 했죠.\n\n나는 소비자들에게 해로운 것으로 생각되는 결정들을 눈치 없이 비판하는 데 전혀 문제가 없고 때로는 절대적으로 악의적이라고 생각되는 결정들도 있어요. 오랫동안 나의 글을 따라온 사람들은 그것을 알 것이에요.\n\n그러나 한 발 물러나서 명확한 머리로 생각해보면 분명해요: 여기서 나쁜 사람은 애플이 아니에요.\n\nBeeper는 애플의 프로토콜을 역공학적으로 재구성하여 복사했고 (이것이 첫 번째 문제입니다), 이를 사용하여 애플의 서버와 통신하며 사실상 사용자를 대신해 애플 기기인 척 했어요. (여기가 두 번째 문제입니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n너아 둘 다 괜찮은 게 아니야.\n\n일단, Beeper가 하려고 했던 것이 나쁜 것은 아니야. iMessage는 훌륭하고, 안드로이드 사용자가 공식적으로 사용할 수 있으면 좋겠어. 하지만 지금까지 그런 일은 일어나지 않았어.\n\n아무도 채팅에서 \"초록색 버블\"이 되어서 부끄러워하거나 나쁜 기분을 가져야 하는 일은 없어야 해 — 네, 그렇게 되는 경우도 있지. 나는 그것이나 그런 행동을 옹호하고 있지 않아.\n\n하지만 애플의 지적 재산권을 역공학하고 애플 시스템을 속이기 위해 사용하는 것은 해결책이 될 수 없어 — 비록 그 취지가 좋다고 해도.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 어떻게 변경해야 할까요?\n\n전체적으로 iPhone을 사용하고 iMessage를 즐겨 사용하는 것을 알려드리고 싶어요. 그래서 이 서비스를 좋아합니다. 이 서비스를 통해 일상적인 모든 문자 메시지 교류에 사용할 수 있다면 좋을텐데, 몇 가지 좋은 기능을 제공하기 때문이에요. 예를 들어, 누군가가 내 메시지를 확인했거나 응답을 입력 중이거나 하는 것을 볼 수 있어요. 이런 기능들은 당연하게 여기고 사용하고 있습니다.\n\n하지만 이런 기능들이 2023년에 모두에게 제공되지 않는다는 것은 안타깝네요. 그래서 Android 사용자들도 이런 기능을 사용할 수 있도록 만들어지면 좋겠어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현대화된 문자 메시징이 필요한 시대입니다: RCS. 그 불충분한 기능을 가진 SMS는 마치 1990년대의 것처럼 느껴집니다. 아마 그래서 iMessage가 많은 사람들에게 매력적으로 느껴지는 이유일지도 모르겠네요?\n\n제가 여기서 확실히 말씀드리고 싶은 것은, 저는 애플의 구식한 문자 메시징 방식을 결코 옹호하는 것이 아닙니다. 그들은 이제야 현대화되어야 했다고 생각해요.\n\n하지만, 그래도 Beeper의 행동을 변명할 수는 없어요.\n","ogImage":{"url":"/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png"},"coverImage":"/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png","tag":["Tech"],"readingTime":10},{"title":"Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법","description":"","date":"2024-06-23 23:23","slug":"2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell","content":"\n소프트웨어 개발의 빠르게 변화하는 세계에서는 효율성과 속도가 프로젝트의 성공을 좌우합니다. 저희 터크셀의 데브옵스 팀은 백엔드, 프론트엔드 및 모바일 플랫폼을 아우르는 다양한 프로젝트의 조율을 맡고 있습니다. 각 프로젝트마다 기술적으로 복잡하고 도전적인 부분이 있지만, 이들을 모두 연결짓는 공통 요소는 신속한 빌드 프로세스의 필요성입니다.\n\n![이미지](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png)\n\n그러나 기존의 설정은 큰 어려움을 겪고 있었습니다. 빌드 시간이 길어지면서 배달 일정과 개발자 생산성에 영향을 미치고 있었습니다.\n\n이 문제로 저희는 Gradle의 빌드 캐시 노드 기능을 탐구하고 최종적으로 구현하게 되었습니다. 이 게시물에서는 우리가 이 기능을 OpenShift에 구현한 여정, 직면한 어려움, 창조한 해결책 및 달성한 결과에 대해 나눌 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 빌드 환경에 대한 배경\n\n터키셀의 디지털 서비스에서는 Bip, TV+, Fizy, Lifebox 등과 같은 다양한 안드로이드 프로젝트 포트폴리오를 관리합니다. 각 프로젝트는 고유한 종속성과 빌드 프로세스를 갖고 있어 복잡성과 빌드 시간을 증가시키는 요소로 작용합니다.\n\n저희 파이프라인은 기존에는 Jenkins를 사용하고 있으며 빌드 에이전트로 openshift 포드를 활용하고 있습니다. Jenkinsfile과 포드 템플릿 YAML로 프로세스를 관리합니다. 그러나 이 컨테이너화된 환경에서는 각 빌드가 청소된 상태에서 시작되므로 빌드 사이에 아티팩트가 유지되지 않습니다.\n\n# 해결책 탐색\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 지역 캐시\n\n우선, Maven 프로젝트에서 사용하는 지역 캐싱 솔루션을 구현할 수 있다고 생각했습니다. OpenShift의 Persistent Volume Claims (PVCs)를 사용하여 빌드 아티팩트 및 종속성을 저장하여 다운로드 시간과 빌드 소요 시간을 줄이는 목표를 가졌습니다. 구조는 단순히 pvc를 로컬 디스크로 사용하고 해당 경로를 지역 캐시로 지정하는 것입니다.\n\n```js\ngradle ${GRADLE_OPTIONS} --build-cache --project-cache-dir=${PVC_PATH}/gradle/android/ ${GRADLE_TASKS}\n```\n\nGradle과 함께 사용할 때 이 접근 방식에는 치명적인 결함이 있었습니다. 종속성과 빌드 스크립트를 효율적으로 처리하지만 캐시를 사용할 때 잠금 메커니즘이 발생합니다. 이 잠금 메커니즘은 동시 빌드가 캐시를 손상시키는 것을 방지하지만 동시에 한 번에 하나의 빌드만 캐시를 사용할 수 있음을 의미합니다. 이는 고도로 동시성 환경에서 효과를 크게 감소시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 빌드 캐시 노드\n\n철저한 조사와 고려 끝에, 중앙 캐시로 Gradle의 빌드 캐시 노드를 설정하기로 결정했습니다. Openshift에서 구축하는 것이 가장 좋다고 결정했습니다. 다음 단계는 배포를 설계하고 구현하여 우리의 OpenShift 환경과 호환되도록 견고하게 만드는 것이었습니다. PVC, 배포, 서비스 및 라우트를 적용한 뒤, 우리의 노드가 가동되었습니다.\n\n# 기술적 구현\n\n## 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희는 전용 PVC를 사용한 배포를 구현했어요.\n\nPVC Yaml:\n\n```js\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: gradle-remote-cache-pvc\nspec:\n  accessModes:\n    - ReadWriteMany\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: ocs-external-storagecluster-cephfs\n  volumeMode: Filesystem\n```\n\n배포 Yaml:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: gradle-remote-cache\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: gradle-remote-cache\n  template:\n    metadata:\n      labels:\n        app: gradle-remote-cache\n    spec:\n      volumes:\n        - name: gradle-remote-cache-pvc\n          persistentVolumeClaim:\n            claimName: gradle-remote-cache-pvc\n      containers:\n        - name: build-cache-node\n          args: [\"start\"]\n          image: gradle/build-cache-node:18.1\n          ports:\n            - containerPort: 5071\n              protocol: TCP\n          resources: {}\n          volumeMounts:\n            - name: gradle-remote-cache-pvc\n              mountPath: /data\n          imagePullPolicy: IfNotPresent\n      restartPolicy: Always\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 25%\n      maxSurge: 25%\n```\n\n회사 전체에서 사용할 수 있도록 하려면 서비스와 라우트를 통해 열어야 합니다.\n\n서비스 Yaml:\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: gradle-remote-cache\nspec:\n  selector:\n    app: gradle-remote-cache\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 5071\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루트 Yaml:\n\n```yaml\nkind: Route\napiVersion: route.openshift.io/v1\nmetadata:\n  name: gradle-remote-cache\nspec:\n  host: \u003c캐시 라우트 URL\u003e\n  to:\n    kind: Service\n    name: gradle-remote-cache\n    weight: 100\n  port:\n    targetPort: 5071\n  tls:\n    termination: edge\n  wildcardPolicy: None\n```\n\n설치 후, 콘솔 로그에 제공된 자격 증명을 사용하여 앱에 로그인합니다. 푸시 권한이 있는 사용자를 만들어 CI/CD 프로세스에서 사용합니다. 또한 개발자들이 로컬 빌드에서 리드 권한만으로 원격 캐시를 사용할 수 있도록 허용합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 사용법\n\n먼저 settings.gradle에 원격 캐시 구성을 추가해야 합니다.\n\n```js\nboolean isJenkins = System.getenv().containsKey(\"IS_JENKINS\")\n\nbuildCache {\n    if (isJenkins){\n        remote(HttpBuildCache) {\n            url = '\u003c캐시 경로 URL\u003e/cache/'\n            push = true\n            credentials {\n                username = System.getenv(\"GRADLE_REMOTE_CACHE_USERNAME\")\n                password = System.getenv(\"GRADLE_REMOTE_CACHE_PASSWORD\")\n            }\n        }\n    }\n}\n```\n\n빌드 명령에서 캐싱을 활성화해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngradle ${GRADLE_OPTIONS} --build-cache ${GRADLE_TASKS}\n```\n\n# 초기 결과 및 분석\n\n## 결과\n\n모든 프로젝트를 구현한 후 캐시 크기와 빌드 시간을 관찰했습니다. 초기에는 50GB 공간을 볼륨으로 설정했습니다. 마지막으로 50GB를 초과하여 크기를 200GB까지 늘렸습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Gradle Remote Cache for Multi-Project Environment at Turkcell](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_2.png)\n\n성공 결과 시간이 각 프로젝트마다 다릅니다. 일부는 34분에서 11분으로 단축되었습니다.\n\n![Gradle Remote Cache for Multi-Project Environment at Turkcell](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_3.png)\n\n![Gradle Remote Cache for Multi-Project Environment at Turkcell](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 프로젝트에서는 시간이 감소하지 않았습니다.\n\n![Image 1](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_5.png)\n\n![Image 2](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_6.png)\n\n빌드 캐시 노드는 많은 프로젝트의 빌드 시간을 크게 개선했지만 일부 프로젝트에는 개선되지 않았습니다. 이 솔루션의 전체 잠재력은 계속된 개선과 각 프로젝트의 고유한 특성에 대한 더 깊은 이해를 통해 실현될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다음 단계\n\nGradle 빌드 캐시 노드가 이제 구현되어 일부 프로젝트 빌드 시간을 상당히 개선하는 결과를 보여주고 있으므로, 다음 단계는 개발자들에 이를 인계하는 것입니다.\n\n초기 결과와 원격 캐시의 효율성을 향상시키는 방법에 대한 제안을 개발 팀에 공유했습니다.\n\n이 도구가 제공하는 장점을 완전히 활용하기 위해서는 시스템을 설정하는 데 그치지 말고, 개발자들이 시스템을 지속적으로 최적화하고 사용하는 것이 필요합니다. 캐싱 메커니즘의 효과적인 사용, 캐시 가능한 작업의 적절한 식별, 의존성 관리, 캐시 히트율을 높이기 위한 필요한 조정은 개발자들이 적극적으로 실시함으로써 이루어질 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n마무리하며, Gradle의 빌드 캐시 노드를 OpenShift에 구현하는 여정은 도전적이고 보람찼습니다. 우리는 많은 프로젝트의 빌드 시간을 크게 줄여 제공 일정의 효율성을 높이고 개발자 생산성을 향상시키는 데 성공했습니다.\n\n하지만, 이로 끝이 아닙니다. 우리는 이 솔루션의 잠재력을 완전히 이용하기 위해 개발자들이 시스템의 사용법을 지속적으로 최적화해야 한다는 점을 인식합니다. 이는 캐시할 수 있는 작업 식별, 의존성 관리, 및 캐시 히트율을 높이기 위해 필요한 조치를 취하는 것을 포함합니다.\n\n# 참고문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://docs.gradle.com/build-cache-node/\n\nhttps://docs.gradle.org/current/userguide/build_cache.html\n\nhttps://medium.com/@cesarmcferreira/using-gradle-build-cache-server-73d7680baf2a\n","ogImage":{"url":"/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png"},"coverImage":"/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png","tag":["Tech"],"readingTime":10},{"title":"안드로이드 UI 레이어 속성 완전 정복  Part 2","description":"","date":"2024-06-23 23:20","slug":"2024-06-23-CrashCourseontheAndroidUILayerPart2","content":"\n## 상태 보유자 및 상태 저장\n\n이 블로그 포스트 시리즈는 Android 개발자 안내를 UI 레이어에 대해 요약하는 것을 목표로 합니다. 우리는 이에 관련된 모든 엔티티들을 탐색하고, 각 부분이 하는 역할을 이해하며, 최선의 실천법을 논의할 것입니다.\n\n첫 번째 부분에서는 UI와 UI 상태에 대해 다루었습니다. 이미 UI 레이어에 존재하는 다양한 엔티티와 UI 및 UI 상태를 효과적으로 생각하는 방법을 알고 있어야합니다.\n\n이제 Part 2로 넘어가 보겠습니다! 상태 보유자 및 Android에서 UI 상태를 어디에 저장하고 상태를 어디에 끌어올려야하는지와 같은 기타 UI 레이어 관련 주제들을 다룰 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 비디오 형식으로 이 콘텐츠를 보시는 것을 선호하신다면, 2023년 Droidcon 런던에서 제가 진행한 강연을 확인해보세요:\n\n## 상태 보유자\n\n상태 보유자는 로직을 처리하거나 UI 상태를 노출함으로써 UI를 간소화합니다. 이 섹션에서는 어떻게 상태 보유자를 구현하는지와 고려해야 할 구현 세부 사항을 살펴볼 것입니다.\n\n구현 세부 사항을 결정하기 위해 먼저 안드로이드 앱에서 일반적으로 발견되는 로직 유형을 식별해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 논리 유형\n\n이미 비즈니스 논리가 애플리케이션 데이터가 생성, 저장 및 수정되는 방법을 지정하는 제품 요구 사항을 구현하는 것을 의미한다는 것을 이야기했습니다. UI 레이어에 비즈니스 논리가 있는 경우, 이 논리를 화면 수준에서 관리하는 것이 좋습니다. 이후에 더 자세히 살펴보겠습니다.\n\n또 다른 유형의 논리는 UI 논리입니다. UI 논리는 화면 상태 변경을 어떻게 표시할지를 결정합니다. 비즈니스 논리가 데이터를 처리하는 방법을 지시하는 반면, UI 논리는 시각적으로 어떻게 표시할지를 결정합니다. UI 논리는 UI 구성에 의존합니다.\n\n예를 들어, 전형적인 앱에서 세부 화면을 표시하는 것은 휴대폰에서 실행 중일 때 탐색을 포함할 수 있습니다. 그러나 태블릿에서 실행 중일 때는 다른 요소를 옆에 표시하는 것을 의미할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png\" /\u003e\n\n다른 유형의 로직은 구성 변경에 다르게 반응합니다:\n\n- UI 로직은 구성 변경에 영향을 받는 경우 다시 실행해야 합니다.\n- 비즈니스 로직은 일반적으로 구성 변경 후에 계속되어야 합니다.\n\n예를 들어, 화면 크기 구성 변경 후에 하단 바 또는 네비게이션 레일을 표시할지 여부를 결정하는 UI 로직은 다시 실행하거나 재평가되어야 합니다. 반면, 특정 관심사를 따르거나 업데이트를 새로 고칠 때 사용자가 기기를 회전하거나 펼친다고 해서 비즈니스 로직을 취소하거나 다시 시작해서는 안 됩니다. 그러한 중단은 사용자 경험을 제공하지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 어떤 로직을 처리해야 할까요?\n\nUI 레이어에서 비즈니스 로직은 화면 수준에 가깝게 처리해야 합니다. 대부분의 비즈니스 로직은 데이터 레이어에서 처리됩니다. 따라서, 화면에 가까이 유지함으로써 로직을 올바르게 범위 지정하는 것이 쉬워지고, 저수준 UI 컴포넌트가 비즈니스 로직과 긴밀하게 결합되는 것을 방지할 수 있습니다.\n\n비즈니스 로직은 일반적으로 androidX.ViewModel에서 확장된 화면 수준 상태 홀더가 처리해야 합니다.\n\nUI 로직에 관련된 것은 비교적 간단한 경우, UI 자체에서 관리하는 것이 가능합니다. 그러나 UI가 더 복잡해지면 해당 UI 로직의 복잡성을 일반 클래스 상태 홀더로 위임하는 것이 좋은 아이디어입니다. 이 경우, 상태 홀더는 androidX.ViewModel에서 확장되지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 섹션에서 이것에 대해 더 자세히 살펴볼거에요! 이제 상태의 다양한 유형과 로직이 서로 어떻게 관련되는지 살펴봅시다:\n\n![image](/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_1.png)\n\n전형적인 화면에서 발생하는 일에 대한 요약으로, 데이터 레이어는 애플리케이션 데이터를 전체 계층에 노출시킵니다. 그런 다음 ViewModel은 그 데이터에 비즈니스 로직을 적용하여 화면 UI 상태를 생성합니다. UI 자체 또는 일반 상태 홀더 클래스는 화면 UI 상태를 관찰하여 UI 요소나 해당 상태를 수정합니다.\n\n# 비즈니스 로직 처리하기 — androidX.ViewModel\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 androidX.ViewModel 또는 Architecture Components ViewModel 클래스를 화면 수준 상태 보유자로의 구현 세부사항으로 상세하게 논의해 왔습니다.\n\n아래 코드 조각에서 우리는 주요 기능을 관찰할 수 있습니다: 1) 화면 UI 상태 노출 및 2) 비즈니스 로직 처리.\n\n```js\n@HiltViewModel\nclass InterestsViewModel @Inject constructor(\n  private val userDataRepository: UserDataRepository,\n  authorsRepository: AuthorsRepository,\n  topicsRepository: TopicsRepository\n) : ViewModel() {\n\n  val uiState: StateFlow\u003cInterestsUiState\u003e = ...\n\n  fun followTopic(followedTopicId: String, followed: Boolean) {\n    viewModelScope.launch {\n      userDataRepository.toggleFollowedTopicId(followedTopicId, followed)\n    }\n  }\n\n  ...\n}\n```\n\n그런데 왜 이러한 기능이 ViewModel에 적합한 것일까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## androidX.ViewModel의 장점\n\n가장 큰 장점은 ViewModel이 구성 변경을 견뎌내며 화면 자체보다 더 오랜 수명을 제공한다는 것입니다. ViewModel은 Activity, Fragment, Navigation 그래프 또는 Navigation 그래프의 대상에 대해 범위를 설정할 수 있습니다. 구성 변경이 발생할 때 시스템은 ViewModel의 동일한 인스턴스를 제공합니다.\n\n구성 변경을 견뎌내는 것은 androidX.ViewModel을 화면 UI 상태를 노출하고 비즈니스 로직을 처리하기에 완벽한 위치로 만듭니다. 화면 UI 상태는 구성 변경 전후에도 캐시되어 즉시 사용할 수 있습니다. 그리고 비즈니스 로직은 ViewModel-범위 CoroutineScope(예: viewModelScope로 시작된 경우)로 시작된 경우 계속 실행됩니다.\n\n또 다른 이점은 다른 Jetpack 라이브러리와의 완벽한 통합에 있습니다. 특히 Jetpack Navigation과의 통합이 원활합니다. Navigation은 대상이 백 스택의 일부인 경우 메모리에 ViewModel의 동일한 인스턴스를 유지합니다. 이를 통해 백 스택의 대상 간에 왕복할 수 있으며 데이터가 즉시 화면에 사용 가능하게 하여 해당 대상으로 다시 이동할 때마다 데이터를 다시로드할 필요가 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n젯팩 네비게이션은 목적지가 백 스택의 일부가 아닐 때 ViewModel의 인스턴스를 자동으로 파괴합니다. 이로 인해 이전 사용자 데이터가 화면에 표시되지 않고 이전 목적지로 안전하게 이동할 수 있습니다.\n\n다른 젯팩 통합에는 Hilt도 포함됩니다. @HiltViewModel 주석을 사용하면 도메인이나 데이터 레이어의 종속성이 있는 ViewModel을 손쉽게 얻을 수 있습니다.\n\n## androidX.ViewModel 모범 사례\n\nViewModel의 스코프는 화면 수준 상태 보유자의 구현 세부 정보로 이 유형을 적합하게 만듭니다. 그러나 이 권한을 남용해서는 안 됩니다. 이 클래스를 사용할 때 명심해야 할 몇 가지 모범 사례가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 화면 레벨에서 사용하세요. 재사용 가능한 UI 요소의 복잡성을 처리하기 위해 ViewModel을 사용하지 마세요. 동일한 ViewModel 스코프 내에서 동일한 UI 요소는 동일한 ViewModel의 인스턴스를 받게 되는데, 대부분의 경우 이는 바람직하지 않습니다.\n- ViewModel을 충분히 일반화하여 모든 UI 형식을 수용할 수 있도록 해주세요. ViewModel은 자신을 사용하는 UI가 무엇인지 인식하면 안 됩니다. ViewModel의 API 표면(공개된 Screen UI 상태 및 노출된 함수)은 UI별 세부 사항을 포함하는 대신 처리하는 응용 프로그램 데이터를 나타내야 합니다. 예를 들어, 데이터를 로딩 중임을 나타낼 때, 화면 UI 상태에는 showLoadingSpinner 대신 isLoading이라는 필드가 포함될 수 있습니다. UI가 데이터 로딩을 사용자에게 통지하는 방법은 UI에만 관련이 있습니다.\n- Lifecycle 관련 API에 대한 참조를 유지하지 마세요. ViewModel은 UI보다 오랜 수명을 가지고 있으며 Context나 Resources 객체에 대한 참조를 유지하면 메모리 누수로 이어질 수 있습니다.\n- ViewModel을 전달하지 마세요. 언급된 모든 점을 고려하면 ViewModel 클래스를 화면 수준에 가능한 가깝게 유지하세요. 그렇지 않으면 저수준 구성 요소에 실제로 필요한 상태와 로직보다 더 많은 액세스 권한을 암묵적으로 부여할 수 있습니다.\n\n## androidX.ViewModel 주의사항\n\nViewModel 영역은 모든 면에서 완벽하지 않습니다. 특히 ViewModel의 viewModelScope에 대한 몇 가지 고려할 사항이 있습니다:\n\n- viewModelScope를 사용하여 시작된 작업은 ViewModel이 메모리에 있는 동안 계속 실행됩니다. 이는 좋은 점이지만 작업이 긴 시간 동안 실행될 경우 문제가 발생할 수도 있습니다. 10초 이상 소요될 수 있는 장기 실행 작업의 경우 WorkManager와 같은 다른 대안을 고려해야 합니다. 배경 작업에 대한 자세한 내용은 문서를 참조하세요.\n- viewModelScope에 의해 트리거된 작업을 단위 테스트하기 위해서는 테스트 환경에서 추가 설정이 필요합니다. 테스트에서 MainDispatcher를 교체해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## AndroidX의 ViewModel 사용\n\n이 섹션은 항상 ViewModel을 사용해야 한다는 것을 의미합니까? 네, 화면 수준의 상태 보유자로의 구현을 말하면 그렇습니다. 하지만 이점이 앱에 적용된다면 사용해야 합니다.\n\n구성 변경에 관심이 있다면 (그래야 합니다!) 그리고/또는 다른 Jetpack 라이브러리를 사용 중이라면 이를 사용하는 것이 좋을 수 있습니다. 그러나 사용하지 않기로 결정하더라도, 화면 수준에서 비즈니스 로직 복잡성을 다루는 간단한 화면 수준 상태 보유자 클래스를 도입하는 것을 고려해보세요.\n\n# UI 로직 처리 — 간단한 상태 보유자 클래스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI가 점점 복잡해지면 상태 보유 클래스를 도입해야 합니다. 기준은 당신과 팀에 달렸습니다. UI를 간소화해야 할 필요성을 느끼는 때입니다.\n\n다가오는 코드 스니펫에서 UI에 대한 상태 보유자를 생성할 필요가 없습니다. 사용자가 UI와 상호 작용할 때 변경되는 확장된 부울 값만 포함되어 있습니다.\n\n```js\n@Composable\nfun \u003cT\u003e NiaDropdownMenuButton(items: List\u003cT\u003e, ...) {\n  var expanded by remember { mutableStateOf(false) }\n\n  Box(modifier = modifier) {\n    NiaOutlinedButton(\n      onClick = { expanded = true },\n      ...\n    )\n    NiaDropdownMenu(\n      expanded = expanded,\n      onDismissRequest = { expanded = false },\n      ...\n    )\n}\n```\n\nUI에 더 많은 상태가 필요하고 관련 로직이 더 복잡해지면 상태 보유자를 도입하세요. Compose 라이브러리가 일부 구성 요소에 대해 수행하는 것과 정확히 동일합니다. 다음 코드 스니펫은 다양한 Drawer 구성 구성 요소의 상태 보유자에 속합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin {.line-numbers}\n@Stable\nclass DrawerState(\n  initialValue: DrawerValue,\n  confirmStateChange: (DrawerValue) -\u003e Boolean = { true }\n) {\n  internal val swipeableState = SwipeableState(...)\n\n  val currentValue: DrawerValue\n    get() { return swipeableState.currentValue }\n\n  val isOpen: Boolean\n    get() = currentValue == DrawerValue.Open\n\n  suspend fun open() = animateTo(DrawerValue.Open, AnimationSpec)\n\n  suspend fun animateTo(targetValue: DrawerValue, anim: AnimationSpec\u003cFloat\u003e) {\n    swipeableState.animateTo(targetValue, anim)\n  }\n}\n```\n\n여기 몇 가지 주요 포인트가 있어요:\n\n- 이 클래스는 Drawer의 현재 값을 나타내는 것처럼 상태를 유지합니다.\n- 상태 홀더들은 합성 가능합니다. DrawerState는 내부적으로 다른 상태 홀더인 SwipeableState에 의존합니다.\n- UI 로직을 관리하며, 서랍을 여는 동작 및 특정 값으로 애니메이션 하는 등의 작업을 포함합니다.\n\nCompose가 이러한 상태 홀더를 제공하는 것처럼, 당신의 프로젝트에서도 UI를 단순화하기 위해 비슷한 패턴을 구현할 수 있어요. 다음 코드 스니펫은 NiaApp 구성 요소 함수의 상태 홀더인 NiaAppState에 속합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Stable\nclass NiaAppState(\n  val navController: NavHostController,\n  val windowSizeClass: WindowSizeClass\n) {\n  val currentDestination: NavDestination?\n    @Composable get() = navController\n      .currentBackStackEntryAsState().value?.destination\n\n  val shouldShowBottomBar: Boolean\n    get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n      windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n\n  fun navigate(...) { ... }\n\n  fun onBackClick() { ... }\n}\n```\n\n비슷한 방식으로,이 클래스는 currentDestination 및 하단 바를 표시해야 하는지 여부와 같은 UI 상태를 노출하고, 네비게이션 및 백 버튼 클릭 이벤트 처리와 같은 UI 논리를 관리합니다.\n\n## 일반적인 상태 보유 클래스의 최상의 관행\n\n재사용 가능한 UI 구성 요소를 위한 상태 보유자를 만드는 것이 좋습니다. 이는 UI의 재사용성을 향상시키고 외부 제어를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반 상태 보유 클래스는 수명주기 관련 API의 참조를 보유할 수 있습니다. 이 인스턴스들은 UI 수명주기를 따릅니다. UI가 구성 변경을 겪을 때마다 상태 보유 클래스의 새 인스턴스가 생성됩니다. 따라서 Context나 Resources에 대한 참조를 보유해도 메모리 누수가 발생하지 않습니다. Jetpack Compose에서 이러한 상태 보유 클래스는 Composition에도 스코프가 지정됩니다.\n\n일반 클래스가 비즈니스 로직이 필요한 경우, 해당 기능을 클래스에 주입하는 것이 좋은 실천 방법입니다. 이 기능을 주입하는 쪽은 UI 범위를 벗어나도록 보장할 수 있습니다.\n\n## 대규모 ViewModels 다루기\n\nViewModel이 여러 큰 UI 요소들의 비즈니스 로직 복잡성을 처리하고 있는 경우, 이는 크고 관리하기 어렵고 추론하기 어려울 수 있습니다. ViewModel을 어떻게 간소화할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도메인 레이어를 소개합니다. ViewModel의 비즼스 로직 복잡성을 다양한 리포지토리와 상호 작용을 처리하는 유즈 케이스에 위임합니다. 그러나 이 접근 방식은 여전히 ViewModel이 의존해야 하는 상당한 수의 유즈 케이스 목록을 일으킬 수 있습니다.\n- UI의 다양한 요소에 대해 여러 상태 홀더를 만들어 그 이점을 모두 누릴 수 있도록 ViewModel에 이를 넣어두세요. ViewModel은 핵심적으로 구성 변경을 견디는 상태 전달 메커니즘이 됩니다.\n- #2 대신, 재사용할 수 없는 UI 요소의 복잡성을 관리하기 위해 여러 개의 ViewModel을 만드는 것을 고려해 볼 수 있습니다. 이러한 방식은 허용되지만, ViewModel은 메모리가 제한되지 않는 상태로 작동하며, 여러 ViewModel을 가지면 그 크기와 메모리 풋프린트를 모니터링하기 어려워질 수 있음을 염두에 두세요.\n\n# 상태를 어디에 둘 것인가\n\n상태를 읽거나 쓰는 가장 낮은 공통 조상에 둘 것을 권장합니다.\n\n요약하면: UI에서 상태가 전혀 없을 수 있고, UI 자체에 상태가 있을 수도 있고, UI를 단순화하기 위해 상태 홀더에 상태가 있을 수도 있고, 다른 구성 요소 호출자나 조상이 상태를 제어할 수 있도록 UI 트리 상단에 상태를 올릴 수도 있고, 비즈니스 로직에서 필요한 경우 ViewModel에 상태를 올릴 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIf the state is required by business logic, whether for reading or writing, it should be hoisted in the screen-level state holder. If not, it should be placed in the appropriate node of the UI tree.\n\nLet’s take a look at the UI hierarchy of a typical Chat app and discuss why certain state is placed where it is:\n\n![UI Hierarchy](/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_2.png)\n\n- The screen UI state should be placed in the ViewModel (#5) because the ViewModel applies business logic to create it.\n- The LazyList is part of the ConversationScreen and not the MessagesList because the screen has additional functionality that require that state, such as scrolling to the most recent messages when the user sends a new message in UserInput.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 주제에 대해 더 알아보려면 Alejandra Stamato가 하는 State hoisting in Compose 이야기를 확인해보세요.\n\n# UI 상태 저장하기\n\n이 블로그 포스트에서는 androidx.ViewModel API를 사용하여 구성 변경 사항에 걸쳐 상태를 유지하는 수단으로 탐색했습니다. 그러나 안드로이드는 상태를 더 효과적으로 보호하는 추가 대안을 제공합니다.\n\nSavedState API를 사용하면 구성 변경과 시스템에서 시작된 프로세스 종료를 통해 상태가 지속될 수 있습니다. 시스템은 이 데이터를 Bundle에 저장하며, 저장을 위해 데이터를 parcel화해야 합니다. 전형적으로 사용자 입력이나 탐색에 따라 달라지는 일시적 UI 상태를 저장할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래도, 위에서 언급한 것뿐만 아니라 예상치 못한 앱 종료(예: 사용자가 앱을 강제로 종료)에도 살아남기 위해 지속적인 저장소를 사용할 수 있습니다. 이것은 디스크 공간 제한을 고려해야 하며 일반적으로 응용 프로그램 데이터를 저장하는 데 사용됩니다.\n\n![Crash Course on the Android UI Layer Part 2_3](/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_3.png)\n\n이 주제에 대한 자세한 내용은 Android에서 UI 상태 저장하기 토크를 확인하세요.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI 계층에 대한 이 간단한 소개를 읽은 후에는 이 계층 내에서 발생하는 프로세스와 상태 및 로직을 효과적으로 관리하는 데 필요한 도구에 대한 일반적인 이해를 가지고 있을 것입니다.\n\n안드로이드는 앱을 다양한 UI 구성 및 기기에 반응적으로 만들도록 설계되어 있어, 일부 개발자들이 원하는 것보다 약간 복잡한 API 결정 트리들을 만듭니다. 그러나 동시에 예상대로 앱이 동작하도록 하는 도구를 제공해주어 훌륭한 사용자 경험을 전달할 수 있게 해줍니다.\n\n이 내용을 즐기셨기를 바랍니다! 의견을 공유하거나 질문을 하고 싶으시다면 댓글 섹션에서 자유롭게 남겨주세요! 감사합니다 😊\n\n만약 비디오 형식으로 내용을 소화하고 싶다면, 2023년 드로이드콘 런던에서 발표한 제 이야기를 확인해보세요!\n","ogImage":{"url":"/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png"},"coverImage":"/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png","tag":["Tech"],"readingTime":16},{"title":"기초부터 배우는 Kotlin 코루틴 사용법","description":"","date":"2024-06-23 23:18","slug":"2024-06-23-KotlinCoroutinesFundamentals","content":"\n코루틴은 이미 오랫동안 존재하고 있고 여러 다양한 기사들이 그 주변에 존재합니다. 그러나 그것에는 깊은 학습 곡선이 존재하여 Coroutines의 기본 원리를 실제로 이해하는 데 꽤 많은 시간이 걸렸습니다. 그래서 내가 이해한 바에 따라 몇 가지 배운 점을 공유하고 싶다고 생각했습니다.\n\n# 코루틴이란 무엇인가?\n\n코루틴은 협력하는 함수를 의미합니다. 비동기 작업을 처리하는 더 효율적이고 읽기 쉬운 방법을 제공합니다. 쓰레드와 유사하다는 점에서, 일련의 코드 블록을 실행하는데 사용되며 나머지 코드와 동시에 작동합니다. 그러나 코루틴은 특정 쓰레드에 묶이지 않습니다. 한 쓰레드에서 실행을 일시 중단할 수 있고 다른 쓰레드에서 다시 실행할 수 있습니다. 코루틴은 코틀린 1.3 버전에서 출시되었습니다.\n\n# 코루틴의 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 코루틴은 가볍습니다 - 지원하는 ​​일시 정지로 인해 한 쓰레드에서 많은 코루틴을 실행할 수 있습니다. 여기서 일시 정지란 몇 가지 명령을 실행한 다음 해당 코루틴을 실행 중간에 중지하고 원하는 때 이어서 실행할 수 있다는 것을 의미합니다. 일시 정지는 많은 동시 작업을 지원하면서도 차단보다 메모리를 절약합니다.\n- 코루틴은 메모리 누수가 적습니다 - 코루틴은 구조화된 동시성 원칙을 따르며, 각 코루틴은 특정 컨텍스트 내에서 특정한 수명을 갖고 시작되어야 합니다. 구조화된 동시성은 코루틴의 수명이 특정 범위에 묶여 범위 자체가 완료되기 전에 범위 내에서 시작된 모든 코루틴이 완료되도록 하는 방식입니다. 이는 코루틴 누출을 방지하고 리소스 관리를 단순화하는 데 도움이 됩니다.\n- Android에서 코루틴은 Main 안전성을 제공합니다 - 코루틴은 메인 스레드를 블로킹하고 응용 프로그램이 응답하지 않게 만들 수 있는 긴 시간 소요 작업을 관리하는 데 도움이 됩니다. Main 안전성을 통해 어느 suspend 함수도 메인 스레드에서 호출할 수 있도록 할 수 있습니다.\n- 코루틴은 내장된 취소 지원을 제공합니다 - 코루틴의 가장 중요한 메커니즘 중 하나는 취소입니다. Android에서 거의 모든 코루틴이 어떤 뷰와 관련이 있으며 이 뷰가 파괴되면 해당 코루틴은 필요하지 않으므로 취소되어야 합니다. 이는 개발자들에게 많은 노력이 필요했던 중요한 기능이지만, 코루틴은 간단하고 안전한 취소 메커니즘을 제공합니다.\n- 코루틴은 협력적으로 멀티태스킹됩니다 - 이는 코루틴이 협력적으로 실행할 일련의 명령을 실행하고 운영 체제가 코루틴에 의해 수행되는 작업이나 프로세스의 스케줄링을 제어하지 않음을 의미합니다. 대신, 프로그램과 해당 코루틴을 실행하는 플랫폼에 의존합니다. 따라서 코루틴은 다른 쓰레드가 실행되도록 제어를 양보하여 스케줄러에 다시 제어를 위임할 수 있습니다. 운영 체제의 스케줄러는 이러한 쓰레드들이 작업을 수행할 수 있도록 책임을 집니다. 필요한 경우 일시 중단하여 같은 리소스를 다른 쓰레드가 사용할 수도 있습니다.\n\n# 코루틴의 키워드\n\n코루틴에 대해 학습할 때 마주치게 될 몇 가지 일반적인 키워드입니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 중지 함수\n- Coroutine Scope (Dispatchers, Job 포함)\n- Coroutine 빌더\n- Coroutine Context\n\n## `중지` 함수\n\n중지 함수는 일시 중지되고 나중에 계속할 수 있는 함수입니다. 중지 함수는 해당 함수가 중지될 수 있다는 것을 나타내며, 비차단 작업이 완료될 때까지 기다리는 동안 다른 코루틴이 실행될 수 있습니다. 중지 함수가 실행되는 동안 해당 코루틴은 실행되던 스레드를 해제하고 다른 코루틴이 그 스레드에 액세스할 수 있도록 합니다(코루틴은 협력적이기 때문입니다).\n\n중지 함수의 구문은 일반 함수의 구문과 동일하지만 `suspend` 키워드가 추가됩니다. 중지 함수는 코루틴이나 다른 중지 함수에서만 호출할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nsuspend fun doSomething(): Int {\n    delay(1000L) // 여기서 유용한 작업을 수행하는 것처럼 가정합니다\n    return 13\n}\n```\n\n## 코루틴 스코프\n\n코루틴 스코프는 코루틴의 수명 주기/수명을 정의합니다. 일련의 코루틴 및 해당 컨텍스트의 수명을 제어하는 역할을 합니다. CoroutineScope는 생성된 모든 코루틴을 추적합니다. 따라서 스코프를 취소하면 생성된 모든 코루틴이 취소됩니다. 부모 코루틴 내에서 자식 코루틴이 시작될 때 부모 스코프를 상속합니다(별도로 지정하지 않은 경우) 따라서 부모 코루틴이 중지되면 자식 코루틴도 중지됩니다.\n\nAndroid에서는 코루틴에는 세 가지 기본 스코프가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 글로벌 범위: GlobalScope는 전체 애플리케이션 수명 동안 지속되는 미리 정의된 코루틴 범위입니다. 편리할 수 있지만 일반적으로 구조화된 동시성을 보장하기 위해 사용자 정의 코루틴 범위를 사용하는 것이 권장됩니다.\n\n```kotlin\nGlobalScope.launch {\n        val config = fetchConfigFromServer() // 네트워크 요청\n        updateConfiguration(config)\n    }\n```\n\n- LifeCycle 범위: LifecycleOwner(프래그먼트 액티비티)의 수명에 바인딩됩니다. 프래그먼트 액티비티가 파괴되면 이 범위의 코루틴도 취소됩니다. LifecycleScope를 사용하면 특별한 실행 조건을 사용할 수도 있습니다:\n\n* launchWhenCreated는 라이프사이클이 최소한 생성 상태에 있을 때 코루틴을 시작하고 파괴 상태에 있을 경우 일시 중단합니다.\n* launchWhenStarted는 라이프사이클이 최소한 시작 상태에 있을 때 코루틴을 시작하고 중지 상태에 있을 경우 일시 중단합니다.\n* launchWhenResumed는 라이프사이클이 최소한 재개 상태에 있을 때 코루틴을 시작하고 일시 중단합니다.\n\n```kotlin\nlifecycleScope.launchWhenResumed {\n  println(\"로딩 중..\")\n  delay(3000)\n  println(\"작업 완료\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ViewModel Scope: ViewModel의 수명에 바인딩됩니다. ViewModel이 해제되면이 범위 내의 코루틴도 취소됩니다.\n\n```js\nviewModelScope.launch {\n  println(\"로딩 중..\")\n  delay(3000)\n  println(\"작업이 완료되었습니다\")\n}\n```\n\n## 코루틴 빌더\n\n코루틴 빌더는 새로운 코루틴을 초기화하거나 생성하기 위한 함수입니다. 코루틴의 실행을 시작하고 제어하는 편리한 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `launch`: 새로운 coroutine을 동시에 시작합니다. 예를 들어, 현재 스레드를 차단하지 않고 시작됩니다. 해당 작업이 취소될 때 자동으로 취소되며 결과 작업이 취소될 때 결과를 반환하지 않습니다. `launch`의 반환 유형은 `Job`입니다. 따라서 해당 작업과 상호 작용하여 coroutine의 라이프사이클을 제어할 수 있습니다. `job.cancel()`을 호출하여 쉽게 취소할 수 있습니다. `launch`는 ViewModel에서 비-suspending 코드에서 suspending 코드로 연결을 생성하는 데 자주 사용됩니다.\n\n```js\nlaunch {\n    delay(1000L)\n    println(\"Hello World!\")\n}\n```\n\n- `runBlocking`: 새로운 coroutine을 실행하고 현재 스레드를 해당 완료까지 차단합니다. 다시 말해, 해당 coroutine에서 실행되는 스레드는 주어진 기간 동안 해당 괄호 내의 모든 코드 블록이 실행을 완료할 때까지 차단됩니다.\n\n```js\nfun main() = runBlocking { // this: CoroutineScope\n    doWorld()\n}\n\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"Hello Kotlin!\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- async: 컨테이너{launch} 함수처럼, 새로운 코루틴을 시작하는 데 사용되며, 차이점은 Job 대신 deferred를 반환한다는 것입니다. deferred는 결과를 나중에 전달할 것을 약속하는 비차단(future)인데, 결과 deferred가 취소되면 실행 중인 코루틴도 취소됩니다. async 빌더를 사용하면 반환된 값을 얻으려면 `await`를 호출하면 됩니다.\n\n```kotlin\nfun main() = runBlocking\u003cUnit\u003e {\n\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n\n}\n```\n\n- delay: 특정 시간 동안 함수를 중단하고 그 후에 다시 시작하는 용도로 사용되는 중단 함수입니다. 백그라운드 스레드를 차단하지 않고 다른 코루틴들이 실행되고 백그라운드 스레드를 사용할 수 있도록 합니다.\n\n```kotlin\nlaunch {\n    delay(2000L)\n    println(\"World 2\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- withContext: 현재 코루틴 내에서 코루틴 컨텍스트를 전환하는 데 사용되는 지연 함수입니다. 현재 코루틴을 일시 중단하고 지정된 컨텍스트로 전환한 후 새 컨텍스트에서 실행을 계속합니다. 일반적으로 해당 함수를 사용하여 코루틴이 실행될 디스패처를 전환합니다. withContext를 사용하면 콜백을 도입하지 않고 코드가 어느 스레드에서 실행될지 제어할 수 있기 때문에 데이터베이스에서 읽기나 네트워크 요청과 같은 매우 작은 함수에 적용할 수 있습니다.\n\n```kotlin\nfun main() = runBlocking {\n    val data = withContext(Dispatchers.IO) {\n        fetchData()\n    }\n    println(\"Response = $data\")\n}\n\nsuspend fun fetchData(): String {\n    return \"Hello world!\"\n}\n```\n\n## 코루틴 컨텍스트\n\n코루틴 컨텍스트는 코루틴의 동작과 특성을 정의하는 요소들의 세트입니다. 디스패처, 작업, 예외 처리기 및 코루틴 이름과 같은 요소를 포함합니다. 이 컨텍스트는 코루틴이 어떻게 어디에서 실행될지 결정하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n디스패처\n\n코루틴 디스패처는 코루틴이 실행될 스레드를 결정하는 역할을 합니다. 디스패처에는 4가지 유형이 있습니다:\n\n- 메인 디스패처(Main Dispatchers) — 메인 디스패처는 코루틴을 메인 스레드에서 실행합니다. 메인 디스패처는 대부분의 UI 작업을 수행합니다.\n- IO 디스패처(IO Dispatchers) — IO 디스패처는 IO 스레드에서 코루틴을 시작합니다. 이 디스패처는 필요할 때 생성되는 스레드 풀을 사용합니다. 파일 읽기 또는 쓰기, 데이터베이스 쿼리 수행, 네트워크 요청 등 실행 스레드를 차단할 수 있는 I/O 작업에 적합합니다.\n- 기본 디스패처(Default Dispatchers) — 다른 디스패처가 명시적으로 지정되지 않은 경우 사용되는 기본 디스패처입니다. 공유 백그라운드 스레드 풀을 활용합니다. CPU 자원이 필요한 계산 집약적인 코루틴에 적합한 선택지입니다.\n- 비제한 디스패처(Unconfined Dispatcher) — 코루틴이 어떤 스레드에서도 실행되도록 허용합니다. 각 resume마다 다른 스레드에서 실행될 수 있습니다. 특정 스레드에 한정된 CPU 사용이나 공유 데이터 업데이트가 필요 없는 코루틴에 적합합니다.\n\n```js\nfun main() = runBlocking {\n    launch { // 부모의 콘텍스트인 메인 runBlocking 코루틴\n        println(\"main runBlocking      : 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n    launch(Dispatchers.Unconfined) { // 제한 없음 -- 메인 스레드에서 작동\n        println(\"Unconfined            : 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n    launch(Dispatchers.Default) { // DefaultDispatcher에 디스패치됩니다\n        println(\"Default               : 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // 자체 새로운 스레드를 가져옵니다\n        println(\"newSingleThreadContext: 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코루틴을 실행하려면 Executor.asCoroutineDispatcher() 확장 기능을 사용하여 코루틴 디스패처로 변환하여 쓰레드 풀에서 실행할 수도 있습니다. 프라이빗 쓰레드 풀은 다음을 사용하여 생성할 수 있습니다:\n\n- newSingleThreadContext(): 내장된 yield 지원이 있는 전용 쓰레드를 사용하여 코루틴 실행 환경을 만듭니다. 원시 자원(스레드 자체)을 할당하는 믹서된 API로 조심스럽게 관리가 필요합니다.\n- newFixedThreadPoolContext: 고정 크기의 쓰레드 풀을 사용하여 코루틴 실행 환경을 설정하여, 코루틴의 병렬 실행을 가능하게 하면서 스레드 자원을 주의 깊게 관리합니다.\n\n코루틴 작업\n\n생성된 매 코루틴마다 Job 인스턴스가 반환되는데, 이를 통해 해당 코루틴을 고유하게 식별하고 라이프사이클을 관리할 수 있습니다. Job은 대기열에서의 코루틴을 가리키는 핸들 역할을 합니다. Job은 다음과 같은 상태를 가집니다: New, Active, Completing, Completed, Cancelling, Cancelled. 상태 자체에는 접근할 수 없지만, Job의 속성: isActive, isCancelled 및 isCompleted에 접근할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nval job = launch { // 새로운 코루틴을 시작하고 해당 작업에 대한 참조를 유지합니다\n    delay(1000L)\n    println(\"안녕, 세상아!\")\n}\njob.join() // 자식 코루틴이 완료될 때까지 기다립니다\nprintln(\"완료\")\n```\n\nSupervisorJob — 이것은 자식 코루틴에 대한 감독자 역할을 하는 Job의 구현입니다. 일반 Job과 유일한 차이점은 그 자식들이 서로 독립적으로 실패할 수 있다는 것입니다. 자식의 실패나 취소는 감독자 작업의 실패를 일으키거나 다른 자식에 영향을 주지 않으므로 감독자는 자식의 실패에 대한 고유 정책을 작성할 수 있습니다.\n\n```kotlin\nfun main() = runBlocking {\n    val supervisorJob = SupervisorJob()\n\n    val coroutine1 = launch(supervisorJob) {\n        println(\"코루틴 1\")\n        throw RuntimeException(\"코루틴 1에서 오류 발생\")\n    }\n\n    val coroutine2 = launch(supervisorJob) {\n        println(\"코루틴 2\")\n        delay(500)\n        println(\"코루틴 2 완료\")\n    }\n\n    coroutine1.join()\n    coroutine2.join()\n\n    println(\"부모 코루틴: ${supervisorJob.isActive}\") // 출력: 부모 코루틴: true\n}\n```\n\n## 코루틴 취소\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코루틴에서 취소는 Job을 통해 관리됩니다(Job은 코루틴에 대한 핸들이며 수명주기가 있습니다). 우리는 코루틴을 Job의 .cancel() 함수를 호출하여 취소할 수 있습니다. 여러 개의 코루틴을 시작할 때, 전체 스코프 내에 생성된 모든 자식 코루틴을 취소하기 위해 의존할 수 있습니다.\n\n취소는 CancellationException을 throw하는 것 이상의 것이 아닙니다. 여기서의 중요한 차이점은 코루틴이 CancellationException을 throw하면 정상적으로 취소된 것으로 간주되며, 다른 예외는 실패로 간주됩니다. 코루틴 라이브러리에서 제공되는 일시정지 함수는 취소할 수 있지만, 코드를 작성할 때는 항상 취소와 협력하는 것을 고려해야 합니다.\n\n- 코드를 취소할 수 있게 만드는 한 가지 방법은 현재 Job의 상태를 명시적으로 확인하는 것입니다. CoroutineContext와 CoroutineScope에서 모두 isActive() 확장 함수를 사용할 수 있습니다.\n- 다른 일반적인 취소 확인 방법은 ensureActive()를 호출하는 것입니다. 이것은 Job, CoroutineContext 및 CoroutineScope에 사용할 수 있는 확장 함수입니다.\n\n취소에 대한 자세한 내용은 여기와 여기에서 찾을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친구들이 읽어주셔서 감사합니다! 코루틴에 대해 다뤄본 건 정말 많았지만, 유용한 정보였길 바랍니다. 댓글란에 의견을 남겨주세요.\n\n코딩 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png"},"coverImage":"/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png","tag":["Tech"],"readingTime":13},{"title":"시스템 설계를 처음부터 배우기 레슨 1","description":"","date":"2024-06-23 23:17","slug":"2024-06-23-StartingfromScratchSystemDesignLesson1","content":"\n가장 중요한 것은 모든 시스템 디자인 질문에 대해 마음속에 일반적인 구조를 만들고 그 기본 구조를 토대로 스스로를 발전시키고 향상시켜야 한다는 것을 기억해야 합니다.\n\n다음 설계를 살펴보고 이를 향후 레슨의 기본으로 활용해 봅시다.\n\n너에게 너무나 압도적으로 보일지도 몰라요...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n깊게 숨을 들이펴 보세요, 단계별로 차근차근 진행할 거에요. :)\n\n# BABY STEPS :)\n\n- 먼저 API-Gateway로 요청이 전달되어 시스템의 입구 역할을 합니다.\n- 그런 다음 로드 밸런서에 요청이 전달됩니다. 이는 한 대의 서버가 너무 많은 요청을 받지 않도록 관리하는 역할을 합니다. 요청은 다른 인스턴스로 분산되어 시스템이 올바르게 작동할 수 있도록 보장합니다.\n- 분산 캐시가 사용되어 지연 시간을 줄일 수 있습니다. 항상 백엔드로 호출할 필요는 없습니다.\n- 그리고 쿠버네티스, 도커 및 여러 백엔드 서비스 인스턴스를 사용하는 구조가 나옵니다. 간단히 말해 백엔드 서비스는 비즈니스 요구사항을 충족하며, 쿠버네티스는 모든 인스턴스가 켜져 있을 필요가 없는 경우 자동으로 확장을 관리합니다.\n- 그런 다음 캐시를 사용할 수 있습니다. (여기서 주의해야 할 점: 캐시 무효화, 캐시 제거 정책)\n- 구조적인 데이터는 RDBMS로 이동합니다.\n\n이곳에서 리더-팔로워 아키텍처가 따라지며 (리플리케이션 전략은 높은 읽기 요구량을 처리하고 리더가 다운되었을 때 데이터 손실을 줄이는 데 사용됩니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. 필요한 데이터는 비즈니스 로직이 요구사항을 처리하고 프로세스가 성공했을 때 서비스로 다시 전송됩니다.\n\n7a. 데이터는 또한 ELK, Kibana, Grafana로 전송되어 관측 메트릭 및 로그 추적이 이루어집니다.\n\n8. 9. 10.\n\n사용자는 요청이 완료되었음을 알림받아야 합니다. 이를 위해 알림 메시지가 알림 대기열로 전송되어 사용자가 오프라인 상태라도 메시지가 지속됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예외:\n\n8`a-8`b\n\n연결 문제 또는 기술적 결함으로 요청이 성공적으로 처리되지 않은 경우, 해당 요청(또는 메시지)은 다시 서비스로 전송되어 재처리됩니다.\n\n5`a-5`b\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 비구조화된 데이터를 저장해야 하는 사용 사례에서는 NoSQL 데이터베이스에 데이터를 저장하고 Kibana/Grafana/ELK로 데이터를 보내어 분석 목적이나 로그 추적에 활용합니다.\n\n감사합니다. 저희 사람들을 계속 성장해 주세요!\n","ogImage":{"url":"/assets/img/2024-06-23-StartingfromScratchSystemDesignLesson1_0.png"},"coverImage":"/assets/img/2024-06-23-StartingfromScratchSystemDesignLesson1_0.png","tag":["Tech"],"readingTime":3},{"title":"쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법","description":"","date":"2024-06-23 23:14","slug":"2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel","content":"\n피츠오는 앰비언트 모드로 전환하고 있어요 — 사이드카 없는 모델로 말이죠. 마침내 우리는 CPU와 메모리 소비가 많은 사이드카를 버릴 수 있게 되었어요!\n\n다가오는 장마시즌을 맞아, 저는 피츠오 앰비언트 메시에 간접적으로 참여해보기로 했어요.\n\n이 블로그를 사용하여 여행을 문서화하고, 비슷한 생각을 가진 피츠오 사용자들이 함께 따라올 수 있게 도와볼 거예요 :P.\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제가 나름대로 번역해보겠습니다:\n\n안녕하세요! Part 1에서는 주변 메시 실험을 위해 로컬 클러스터 설정을 완벽하게 진행할 예정입니다. 그런 다음 메시의 ztunnel 구성 요소를 탐험할 것입니다.\n\nPart 2에서는 L4 인증 정책에 대해 이야기하고 waypoint 프록시를 시작하는 방법을 살펴볼 것입니다.\n\n# Ambient란 무엇인가요?\n\nIstio Ambient Mesh는 사이드카 없이 Istio의 새로운 데이터플레인 모드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적인 Istio 모드에서는 모든 응용 프로그램 Pod이 envoy 프록시로 주입되었다는 것을 기억하십시오. 그러나 이 새로운 모드에서는 응용 프로그램 Pod이 건드리지 않을 거에요 :) 그리고 그들은 자신의 응용 프로그램 컨테이너만 가지게 될 거에요.\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_1.png)\n\n가장 먼저 떠오르는 큰 장점 중 하나는 인프라 비용이 크게 절감된다는 것입니다. 컴퓨팅 코어 및 메모리 관점에서 얼마나 많은 돈을 절약하고 있는지 상상해보세요 !!\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Ambient Architecture\n\n과거와 현재의 Ambient Architecture를 상상해 보는 시간입니다. 데이터 평면의 트래픽 흐름 경로에서 그들이 어떻게 다른지 살펴봅시다.\n\n## Sidecar 모드\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 전통적인 사이드카 모델이며 각 서비스 팟에는 애플리케이션 컨테이너와 Envoy 사이드카가 결합되어 있습니다. 애플리케이션으로부터 오고 가는 모든 트래픽은 사이드카에 의해 가로채집니다.\n\n## Ambient 모드, ztunnel 사용\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_4.png)\n\n이 새로운 ambient 모드에서 애플리케이션 팟은 사이드카가 없는 독립적인 팟입니다. 그러나 이 경우에는 클러스터의 각 Kubernetes 노드마다 데몬셋 팟이 실행될 것입니다 - 강력한 ztunnel (제로 트러스트 터널). 노드 내 팟간의 모든 트래픽은 ztunnel에 의해 가로채집됩니다. Ztunnel은 각 노드당 L4 프록시입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Ambient mode, with ztunnel + waypoint\n\n![Image](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_5.png)\n\nZtunnel은 L4 프록시가 필요한 워크로드 간 네트워킹에 충분합니다. http 헤더 기반 라우팅, L7 권한 부여와 같은 L7 요구 사항을 충족시키기 위해 waypoint 프록시라는 워크로드를 배포합니다. 이는 애플리케이션당 envoy 팟으로, 동일한 노드 또는 다른 노드에서 실행될 수 있습니다.\n\n이 경우 ztunnel에서 생성된 트래픽은 waypoint 프록시에 도달하고, waypoint는 그것을 목적지 ztunnel로 전달합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러므로, 어플리케이션이 L7 처리를 요구하지 않는 경우 waypoint를 없애고 ztunnel만 사용할 수 있습니다. 이전 방식에서는, 우리가 L4 요구사항만 가지고 있더라도 envoy sidecars를 반드시 사용해야 했습니다.\n\n# 클러스터 설정 깊이에 대한 정보\n\n이상적으로 지원되는 환경에서 사용할 수 있는 유효한 CNI 설정으로 Kind 클러스터를 설정하는 데 많은 조정이 필요했습니다. 현재는 어떤 공개 GKE/AKS/EKS k8s 클러스터에 대한 실험을 할 수 있는 권한이 없습니다.\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러므로 로컬 Kind 클러스터를 홈 설정하겠습니다.\n\n## 시스템 사양\n\n- Mac M1 (Apple-Silicon 아키텍처)를 사용하며 기본 구성으로 진행됩니다.\n\n시스템 아키텍처(Linux/Windows/Apple Intel)를 고려하여 비슷하게 진행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Rancher Desktop\n\n저희 k8s 클러스터를 위해 도커 런타임이 필요한데, 저는 SUSE의 Rancher Desktop을 사용할 예정입니다 — https://rancherdesktop.io/.\n\n다른 대안으로는 Docker Desktop이 있습니다 — https://www.docker.com/products/docker-desktop/\n\n- Kind\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 Multi-Node K8s 클러스터가 필요하다고 생각해요. 그래서 우리가 사용할 최상의 도구는 Kind를 이용해 클러스터를 부트스트랩하는 거죠. 여기 https://kind.sigs.k8s.io/docs/user/quick-start 에서 보다 자세한 정보를 얻을 수 있어요.\n\n이를 통해 우리는 k8s 노드에 ssh로 접속하고 노드 구성을 실험해볼 수도 있을 거에요.\n\n그리고 블로그에 나온대로 istio-ambient 프로필을 설치한 후에는 Kind 노드에서 문제가 발생할 수 있어요. 여기 https://kind.sigs.k8s.io/docs/user/known-issues/#pod-errors-due-to-too-many-open-files 에서 문제를 해결할 수 있어요. 영향을 받는 노드의 sysctl.conf를 수정한 후에는 istio-system pods가 문제없이 생성될 거에요.\n\n\u003cimg src=\"/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_7.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- CNI(Container Networking Interface)\n\n\"Istio Ambient Mode\"은 Calico, Cilium 등과 같은 CNI와 함께 지원됩니다. Kind 클러스터의 기본 CNI는 \"kindnetd\"이며, 저는 직접 테스트해 본 결과 ztunnel 팟이 실행되지 않았습니다. 그래서 다른 CNI가 필요했습니다.\n\n- Cilium CNI도 Mac M1에서 제대로 로드되지 않았습니다. 즉, cilium 데몬셋 팟이 실행되지 않았습니다.\n- 마침내 Calico CNI로 Kind를 설정하는 방법을 찾았습니다. Kind에서 기본 CNI를 비활성화하고 다음과 같이 진행합니다: [https://docs.tigera.io/calico/latest/getting-started/kubernetes/kind](https://docs.tigera.io/calico/latest/getting-started/kubernetes/kind)\n- 이 설정에서 마지막 단계를 따를 수도 있습니다: [https://alexbrand.dev/post/creating-a-kind-cluster-with-calico-networking/](https://alexbrand.dev/post/creating-a-kind-cluster-with-calico-networking/)\n\n# Istio 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 클러스터 개요\n\n이스티오를 시작하기 전에 클러스터 스펙을 살펴봅시다.\n\n다음은 Kind 클러스터 설정 스크립트입니다.\n\n마스터 노드 1개와 워커 노드 2개가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kg 노드\n이름                    상태     역할           생성 시간    버전\nambient-control-plane   준비     제어 플레인    117분     v1.30.0\nambient-worker          준비     \u003c없음\u003e         116분     v1.30.0\nambient-worker2         준비     \u003c없음\u003e         116분     v1.30.0\n```\n\n또한 Calico CNI 데몬세트가 실행 중인지 확인합니다. 클러스터 CoreDNS도 준비되어 있는지 확인합니다.\n\n```js\n(⎈|kind-ambient:kube-system)➜  ~ kgpo\n이름                                            준비     상태      재시작      생성 시간\ncalico-kube-controllers-564985c589-xmsrp        1/1     실행 중  1 (96분 전)  117분\ncalico-node-796kq                               1/1     실행 중  0             116분\ncalico-node-l6fsg                               1/1     실행 중  0             116분\ncalico-node-zkckp                               1/1     실행 중  0             116분\ncoredns-7db6d8ff4d-h88q6                        1/1     실행 중  0             118분\ncoredns-7db6d8ff4d-rtncd                        1/1     실행 중  0             118분\n```\n\n## Istio Ambient 프로필 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설치는 간단하게 진행됩니다. 여기에서 찾을 수 있어요: [https://istio.io/v1.20/docs/ops/ambient/getting-started/](https://istio.io/v1.20/docs/ops/ambient/getting-started/)\n\n```js\nsabuj $ istioctl install --set profile=ambient --set \"components.ingressGateways[0].enabled=true\" --set \"components.ingressGateways[0].name=istio-ingressgateway\" --skip-confirmation\n✔ Istio core가 설치되었습니다\n✔ Ztunnel이 설치되었습니다\n✔ Istiod가 설치되었습니다\n✔ CNI가 설치되었습니다\n✔ 인그레스 게이트웨이가 설치되었습니다\n✔ 설치가 완료되었습니다\n이 설치를 주입과 유효성 검사를 위한 기본 설정으로 지정합니다.\n```\n\n- 내가 사용 중인 Istio 버전은 다음과 같아요.\n\n```js\n(⎈|kind-ambient:kube-system)➜  ~ istioctl version\nclient version: 1.15.0\ncontrol plane version: 1.22.1\ndata plane version: 1.22.1 (4 프록시)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Ztunnel은 각 노드에서 실행되는 데몬세트입니다 — 이 경우 3개의 노드가 있습니다. istio-system 네임스페이스에서 ztunnel이 제대로 실행 중인지 확인해 봅시다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kgpo -owide\nNAME                                    READY   STATUS    RESTARTS   AGE    IP               NODE                    NOMINATED NODE   READINESS GATES\nistio-cni-node-7q6z7                    1/1     Running   0          117m   172.18.0.2       ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nistio-cni-node-fg6n4                    1/1     Running   0          117m   172.18.0.4       ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nistio-cni-node-gwvl8                    1/1     Running   0          117m   172.18.0.3       ambient-control-plane   \u003cnone\u003e           \u003cnone\u003e\nistio-ingressgateway-6f48dfb7db-862sm   1/1     Running   0          117m   192.168.184.70   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nistiod-6875bc5c58-n4j7d                 1/1     Running   0          118m   192.168.246.2    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nztunnel-62hp8                           1/1     Running   0          117m   192.168.246.3    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nztunnel-fv5f8                           1/1     Running   0          117m   192.168.184.71   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nztunnel-gs52c                           1/1     Running   0          117m   192.168.208.1    ambient-control-plane   \u003cnone\u003e           \u003cnone\u003e\n\n(⎈|kind-ambient:istio-system)➜  ~ kg ds\nNAME             DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE\nistio-cni-node   3         3         3       3            3           kubernetes.io/os=linux   119m\nztunnel          3         3         3       3            3           kubernetes.io/os=linux   118m\n```\n\n정말로 3개의 파드가 있네요 !\n\n- 비슷하게 Istio-cni는 또 다른 설치된 데몬세트입니다.\n- Istio 제어 평면인 istiod도 실행 중입니다.\n- 우리는 공개 트래픽을 위해 기본 istio ingressgateway도 설치했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 작업량 설정\n\n이 프로젝트의 모든 매니페스트 파일은 여기에서 찾을 수 있습니다: https://github.com/JanaSabuj/istio-ambient-mesh-exploration\n\n## 안건\n\n- 우리는 앰비언트 프로필 없이 앱을 설정하고, 일반 Istio crds를 사용할 것입니다. 그 후에 앱을 호출할 예정입니다. i) 인그레스 ii) 디버그 클라이언트 pod\n- 그 후에, Istio 데이터 평면 모드를 앰비언트로 전환하고, ztunnel pod를 통해 흐르는 트래픽 경로의 변화를 관찰할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 네임스페이스\n\nambient-demo라는 네임스페이스를 만들어 보겠습니다. 이 네임스페이스에서 앱을 호스팅할 예정입니다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ k create ns ambient-demo\n\n(⎈|kind-ambient:istio-system)➜  ~ kg ns\nNAME                 STATUS   AGE\ndefault              Active   132m\nistio-system         Active   125m\nkube-node-lease      Active   132m\nkube-public          Active   132m\nkube-system          Active   132m\nlocal-path-storage   Active   132m\n```\n\n## 애플리케이션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 배포, 서비스 및 서비스 어카운트 yaml을 사용하여 애플리케이션을 배포합니다.\n\n클러스터에서는 다음과 같이 보입니다.\n\n```bash\n(⎈|kind-ambient:ambient-demo)➜  ~ kg all\nNAME                          READY   STATUS    RESTARTS   AGE\npod/httpbin-6f4dc97cb-5dpz9   1/1     Running   0          3m21s\npod/httpbin-6f4dc97cb-swdlb   1/1     Running   0          3m31s\n\nNAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE\nservice/httpbin   ClusterIP   10.96.157.221   \u003cnone\u003e        80/TCP    143m\n\nNAME                      READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/httpbin   2/2     2            2           143m\n\nNAME                                 DESIRED   CURRENT   READY   AGE\nreplicaset.apps/httpbin-6f4dc97cb    2         2         2       3m31s\n```\n\n## Istio 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n외부 세계에 노출하기 위해 Istio Gateway 및 Istio VirtualService를 생성하여 Istio Ingress를 통해 액세스할 수 있게 만듭니다.\n\n- 우리는 Istio Ingress 파드에 8081 포트를 통해 게이트웨이를 추가하고 있습니다.\n- 그 다음으로, VirtualService를 통해 ambient-demo 네임스페이스에서 실행되는 httpbin 서비스로 라우팅합니다.\n\n## Istio Ingress를 통한 확인\n\n이제 우리의 응용 프로그램에 액세스할 수 있는지 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kgs\nNAME                   TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)                                      AGE\nistio-ingressgateway   LoadBalancer   10.96.77.172   \u003cpending\u003e     15021:30807/TCP,80:30587/TCP,443:31004/TCP   147m\n```\n\nKind가 인그레스 서비스를 위한 외부 IP를 제공하지 않았기 때문에, 원하는 리스너 8081에서 인그레스 파드를 포트포워딩하여 외부 액세스를 시뮬레이션할 것입니다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kpf istio-ingressgateway-6f48dfb7db-862sm 8081\nForwarding from 127.0.0.1:8081 -\u003e 8081\nForwarding from [::1]:8081 -\u003e 8081\n```\n\n브라우저에서 127.0.0.1:8081을 입력하여 애플리케이션을 확인할 수 있습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhttp://127.0.0.1:8081/\n\nhttpbin.org\n 0.9.2\n[ Base URL: 127.0.0.1:8081/ ]\n간단한 HTTP 요청 및 응답 서비스입니다.\n\n로컬에서 실행: $ docker run -p 80:80 kennethreitz/httpbin\n\n개발자 - 웹사이트\n개발자에게 이메일 보내기\n```\n\n- 또 다른 확인 방법은 로컬에서 curl을 통해 하는 것입니다. 우리는 요청이 istio-envoy 파드에 의해 처리된 것을 확인합니다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ curl 127.0.0.1:8081 -v\n*   Trying 127.0.0.1:8081...\n* Connected to 127.0.0.1 (127.0.0.1) port 8081\n\u003e GET / HTTP/1.1\n\u003e Host: 127.0.0.1:8081\n\u003e User-Agent: curl/8.6.0\n\u003e Accept: */*\n\u003e\n\u003c HTTP/1.1 200 OK\n\u003c server: istio-envoy\n\u003c date: Sun, 16 Jun 2024 11:52:13 GMT\n\u003c content-type: text/html; charset=utf-8\n\u003c content-length: 9593\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 271\n\u003c\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n...\n```\n\n## 디버그 클라이언트 파드를 통한 확인\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 메쉬 내부 호출을 테스트해보려고 합니다. 따라서 각 노드마다 클라이언트 팟이 하나씩 있는 것이 좋습니다. 이를 위해 디버거 데몬세트 클라이언트 워크로드를 설정할 수 있습니다 — https://github.com/digitalocean/doks-debug\n\n사용한 수정된 Manifest: https://gist.github.com/JanaSabuj/a4dd2504752b8c2b30d2d2d05320f7ef\n\n저는 이 데몬세트를 우리 ambient-demo 네임스페이스에 배포했습니다.\n\n```js\n(⎈|kind-ambient:ambient-demo)➜  ~ kg ds\nNAME         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE\ndoks-debug   3         3         3       3            3           \u003cnone\u003e          89m\n\n(⎈|kind-ambient:ambient-demo)➜  ~ kgpo -owide\nNAME                      READY   STATUS    RESTARTS   AGE   IP               NODE                    NOMINATED NODE   READINESS GATES\ndoks-debug-j9mm5          1/1     Running   0          90m   192.168.246.5    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\ndoks-debug-rdhgq          1/1     Running   0          90m   192.168.184.73   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\ndoks-debug-v7cld          1/1     Running   0          90m   192.168.208.3    ambient-control-plane   \u003cnone\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테스트해 보기 위해 디버그 팟으로 진입하여 k8s fqdn httpbin.ambient-demo.svc.cluster.local을 curl을 시도해 보았습니다.\n\n200 OK를 반환하고 있습니다.\n\n```js\n(⎈|kind-ambient:ambient-demo)➜  ~ k exec -it doks-debug-j9mm5 -- /bin/bash\n\nroot@doks-debug-j9mm5:~# curl httpbin.ambient-demo.svc.cluster.local -v\n*   Trying 10.96.157.221:80...\n* Connected to httpbin.ambient-demo.svc.cluster.local (10.96.157.221) port 80 (#0)\n\u003e GET / HTTP/1.1\n\u003e Host: httpbin.ambient-demo.svc.cluster.local\n\u003e User-Agent: curl/7.88.1\n\u003e Accept: */*\n\u003e\n\u003c HTTP/1.1 200 OK\n\u003c Server: gunicorn/19.9.0\n\u003c Date: Sun, 16 Jun 2024 12:06:11 GMT\n\u003c Connection: keep-alive\n\u003c Content-Type: text/html; charset=utf-8\n\u003c Content-Length: 9593\n\u003c Access-Control-Allow-Origin: *\n\u003c Access-Control-Allow-Credentials: true\n\u003c\n```\n\n# Ambient Injection\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지 앰비언트 모드가 활성화되지 않았습니다. Istio 게이트웨이에서 추가 된 리스너로 인해 요청은 Istio 인그레스 파드에 도착한 다음 VirtualService를 통해 앱 파드로 라우팅됩니다.\n\n매쉬 내부 호출의 경우, 클라이언트와 서버 파드 사이에 직접적인 포드 간 통신이 이루어집니다.\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_8.png)\n\n앰비언트를 주입하는 동안 우리는 또한 다음 로그를 계속 추적할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- istio-cni\n- ztunnel\n\nIstio가 네임스페이스 ambient-demo에 대한 Ambient Dataplane 모드를 활성화하도록 내부적으로 라우트, iptables 등을 설정했는지 확인하려면 아래 명령어를 사용해보세요.\n\n```js\n(⎈|kind-ambient:ambient-demo)➜\n~ kubectl label namespace ambient-demo istio.io/dataplane-mode=ambient\n```\n\n## 관찰된 로그\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- istio-cni\n\n```js\n(⎈|kind-ambient:ambient-demo)➜ ~ stern istio-cni -n istio-system\n\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.243451Z info ambient Namespace ambient-demo is enabled in ambient mesh\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.264500Z info ambient in pod mode - adding pod ambient-demo/httpbin-5bd875fbdd-84vs8 to ztunnel\nistio-cni-node-gwvl8 install-cni 2024-06-16T10:13:59.291505Z info ambient Namespace ambient-demo is enabled in ambient mesh\nistio-cni-node-fg6n4 install-cni 2024-06-16T10:13:59.281587Z info ambient Namespace ambient-demo is enabled in ambient mesh\nistio-cni-node-fg6n4 install-cni 2024-06-16T10:13:59.313668Z info ambient in pod mode - adding pod ambient-demo/httpbin-5bd875fbdd-dp4ct to ztunnel\n\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.264500Z info ambient in pod mode - adding pod ambient-demo/httpbin-5bd875fbdd-84vs8 to ztunnel\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.325907Z info iptables Running iptables-restore with the following input:\nistio-cni-node-7q6z7 install-cni * nat\nistio-cni-node-7q6z7 install-cni -N ISTIO_OUTPUT\nistio-cni-node-7q6z7 install-cni -A OUTPUT -j ISTIO_OUTPUT\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT -d 169.254.7.127 -p tcp -m tcp -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT -p tcp -m mark --mark 0x111/0xfff -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT ! -d 127.0.0.1/32 -o lo -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT ! -d 127.0.0.1/32 -p tcp -m mark ! --mark 0x539/0xfff -j REDIRECT --to-ports 15001\nistio-cni-node-7q6z7 install-cni COMMIT\nistio-cni-node-7q6z7 install-cni * mangle\nistio-cni-node-7q6z7 install-cni -N ISTIO_PRERT\nistio-cni-node-7q6z7 install-cni -N ISTIO_OUTPUT\nistio-cni-node-7q6z7 install-cni -A PREROUTING -j ISTIO_PRERT\nistio-cni-node-7q6z7 install-cni -A OUTPUT -j ISTIO_OUTPUT\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT -m mark --mark 0x539/0xfff -j CONNMARK --set-xmark 0x111/0xfff\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT -s 169.254.7.127 -p tcp -m tcp -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT ! -d 127.0.0.1/32 -p tcp -i lo -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT -p tcp -m tcp --dport 15008 -m mark ! --mark 0x539/0xfff -j TPROXY --on-port 15008 --tproxy-mark 0x111/0xfff\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT -p tcp -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT ! -d 127.0.0.1/32 -p tcp -m mark ! --mark 0x539/0xfff -j TPROXY --on-port 15006 --tproxy-mark 0x111/0xfff\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT -m connmark --mark 0x111/0xfff -j CONNMARK --restore-mark --nfmask 0xffffffff --ctmask 0xffffffff\nistio-cni-node-7q6z7 install-cni COMMIT\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.335115Z info Running command (with wait lock): iptables-restore --noflush -v --wait=30\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.550687Z info ambient About to send added pod: 3ab72f78-8e2b-4e49-bc47-45fa4f90dbf7 to ztunnel: add:{uid:\"3ab72f78-8e2b-4e49-bc47-45fa4f90dbf7\" workload_info:{name:\"httpbin-5bd875fbdd-84vs8\" namespace:\"ambient-demo\" service_account:\"default\" trust_domain:\"cluster.local\"}\n```\n\n많은 로그가 생성되었습니다. 우리는 각 httpbin pod를 ambient-demo 네임스페이스에 추가하여 ztunnel을 통해 ambient 경로에 추가하고 있음을 확인할 수 있습니다.\n\n- ztunnel\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```plaintext\n(⎈|kind-ambient:ambient-demo)➜ ~ stern ztunnel -n istio-system\n\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.559505Z 정보 inpod::statemanager pod WorkloadUid(\"3ab72f78-8e2b-4e49-bc47-45fa4f90dbf7\")가 netns를 수신하고 프록시를 시작합니다.\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.557545Z 정보 inpod::statemanager pod WorkloadUid(\"7f8be6a6-64f2-40e9-8926-6c3a618eb7d9\")가 netns를 수신하고 프록시를 시작합니다.\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.560458Z 정보 proxy::inbound 리스너가 구성되었으며 주소=[::]:15008 구성요소=\"inbound\" 투명=true\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.561604Z 정보 proxy::inbound_passthrough 리스너가 구성되었으며 주소=[::]:15006 구성요소=\"inbound plaintext\" 투명=true\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.561647Z 정보 proxy::outbound 리스너가 구성되었으며 주소=[::]:15001 구성요소=\"outbound\" 투명=true\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.573883Z 정보 proxy::inbound 리스너가 구성되었으며 주소=[::]:15008 구성요소=\"inbound\" 투명=true\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.586596Z 정보 proxy::inbound_passthrough 리스너가 구성되었으며 주소=[::]:15006 구성요소=\"inbound plaintext\" 투명=true\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.586819Z 정보 proxy::outbound 리스너가 구성되었으며 주소=[::]:15001 구성요소=\"outbound\" 투명=true\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.811460Z 정보 xds::client:xds{id=14}가 응답을 수신했습니다. type_url=\"type.googleapis.com/istio.workload.Address\" 크기=2  삭제=0\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.816352Z 정보 xds::client:xds{id=14}가 응답을 수신했습니다. type_url=\"type.googleapis.com/istio.workload.Address\" 크기=2  삭제=0\nztunnel-gs52c istio-proxy 2024-06-16T10:13:59.821310Z 정보 xds::client:xds{id=14}가 응답을 수신했습니다. type_url=\"type.googleapis.com/istio.workload.Address\" 크기=2  삭제=0\n```\n\nztunnel이 자체 내부 및 외부 리스너를 설정 중인 것으로 보입니다.\n\n## 트래픽 흐름 - Istio Ingress를 통해\n\n이전과 마찬가지로, istio-ingress pod로 포트 포워딩을 설정하고 localhost를 통해 액세스합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 개의 호출을 각각 2개의 httpbin 팟에 대응하도록 인그레스에서 호출을 추출하려고 합니다. 그리고 동시에 동일한 ztunnel 로그를 캡처하려고 합니다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kpf istio-ingressgateway-6f48dfb7db-862sm 8081\nForwarding from 127.0.0.1:8081 -\u003e 8081\n\n$ curl localhost:8081/\n$ curl localhost:8081/\n```\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ stern ztunnel -n istio-system\n\nztunnel-fv5f8 istio-proxy 2024-06-16T12:26:24.154500Z\ninfo access connection complete src.addr=192.168.184.70:52792\nsrc.workload=istio-ingressgateway-6f48dfb7db-862sm src.namespace=istio-system\nsrc.identity=\"spiffe://cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account\"\ndst.addr=192.168.184.74:80 dst.hbone_addr=192.168.184.74:80\ndst.service=httpbin.ambient-demo.svc.cluster.local\ndst.workload=httpbin-6f4dc97cb-swdlb dst.namespace=ambient-demo\ndst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\"\ndirection=\"inbound\" bytes_sent=51083 bytes_recv=4180 duration=\"2166ms\"\n\nztunnel-62hp8 istio-proxy 2024-06-16T12:28:40.267690Z\ninfo access connection complete src.addr=192.168.184.70:55036\nsrc.workload=istio-ingressgateway-6f48dfb7db-862sm src.namespace=istio-system\nsrc.identity=\"spiffe://cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account\"\ndst.addr=192.168.246.6:80 dst.hbone_addr=192.168.246.6:80\ndst.service=httpbin.ambient-demo.svc.cluster.local\ndst.workload=httpbin-6f4dc97cb-5dpz9 dst.namespace=ambient-demo\ndst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\"\ndirection=\"inbound\" bytes_sent=41251 bytes_recv=2007 duration=\"2331ms\"\n```\n\n인그레스가 주변 데이터 플레인 경로에 떨어지지 않기 때문에 인그레스 팟에서의 호출은 주변 데이터 플레인 경로로 직접 ztunnel 팟으로 이어집니다. 한 번에 하나의 노드로 이동한 후 해당 내부 노드 팟으로 inbound됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 로그 캡처에서 확인한 내용입니다\n\n```js\ndirection = \"inbound\";\n```\n\n- 이는 주변 레이블이 붙은 네임스페이스 파드로의 트래픽이 항상 ztunnel을 통해 이동함을 확인합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndst.hbone_addr=192.168.184.74:80\ndst.hbone_addr=192.168.246.6:80\n\nhttpbin-6f4dc97cb-5dpz9 1/1 Running 0 56m 192.168.246.6 ambient-worker2 \u003cnone\u003e \u003cnone\u003e\nhttpbin-6f4dc97cb-swdlb 1/1 Running 0 56m 192.168.184.74 ambient-worker \u003cnone\u003e \u003cnone\u003e\n\n- 이것은 실제 httpbin pod ip에 해당하는 dest pod ip를 캡처합니다.\n\n## 트래픽 흐름 — Mesh 내부를 통해\n\n클라이언트 디버그 pod에 exec하여 httpbin 서비스로의 Mesh 내부 호출을 시도하고 동시에 ztunnel 로그를 캡쳐하여 동일한 동작을 확인해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n(⎈|kind-ambient:ambient-demo)➜  ~ kgpo -owide\nNAME                      READY   STATUS    RESTARTS   AGE    IP               NODE                    NOMINATED NODE   READINESS GATES\ndoks-debug-j9mm5          1/1     Running   0          122m   192.168.246.5    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\ndoks-debug-rdhgq          1/1     Running   0          122m   192.168.184.73   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\ndoks-debug-v7cld          1/1     Running   0          122m   192.168.208.3    ambient-control-plane   \u003cnone\u003e           \u003cnone\u003e\nhttpbin-6f4dc97cb-5dpz9   1/1     Running   0          56m    192.168.246.6    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nhttpbin-6f4dc97cb-swdlb   1/1     Running   0          56m    192.168.184.74   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\n```\n\n그냥 같은 노드에 있는 클라이언트와 앱 팟들을 연결하기 위해 —\n\n```js\n(⎈|kind-ambient:ambient-demo)➜  ~ kgpo -A -owide | grep \"ambient-worker \"\nambient-demo         doks-debug-rdhgq                                1/1     Running   0               133m    192.168.184.73   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nistio-system         ztunnel-fv5f8                                   1/1     Running   0               3h24m   192.168.184.71   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nambient-demo         httpbin-6f4dc97cb-swdlb                         1/1     Running   0               68m     192.168.184.74   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\n\n\n(⎈|kind-ambient:ambient-demo)➜  ~ kgpo -A -owide | grep \"ambient-worker2\"\nkube-system          doks-debug-9nlh7                                1/1     Running   0               3h6m    192.168.246.4    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nistio-system         ztunnel-62hp8                                   1/1     Running   0               3h23m   192.168.246.3    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nambient-demo         httpbin-6f4dc97cb-5dpz9                         1/1     Running   0               67m     192.168.246.6    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\n```\n\ndebug pod인 doks-debug-rdhgq를 실행하기 위해 ambient-worker 노드에 스케줄된 상태로 들어가보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_10.png\" /\u003e\n\n```js\n테이블 1: 동일 노드 내의 클라이언트 및 서버\n---------\nztunnel-fv5f8 istio-proxy 2024-06-16T12:40:48.707707Z info access connection complete src.addr=192.168.184.73:56463 src.workload=doks-debug-rdhgq src.namespace=ambient-demo src.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/default\" dst.addr=192.168.184.74:80 dst.hbone_addr=192.168.184.74:80 dst.service=httpbin.ambient-demo.svc.cluster.local dst.workload=httpbin-6f4dc97cb-swdlb dst.namespace=ambient-demo dst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\" direction  =\"inbound\" bytes_sent=9832 bytes_recv=84 duration=\"178ms\"\nztunnel-fv5f8 istio-proxy 2024-06-16T12:40:48.708070Z info access connection complete src.addr=192.168.184.73:34190 src.workload=doks-debug-rdhgq src.namespace=ambient-demo src.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/default\" dst.addr=192.168.184.74:15008 dst.hbone_addr=192.168.184.74:80 dst.service=httpbin.ambient-demo.svc.cluster.local dst.workload=httpbin-6f4dc97cb-swdlb dst.namespace=ambient-demo dst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\" direction=\"outbound\" bytes_sent=84 bytes_recv=9832 duration=\"203ms\"\n```\n\n동일 노드 내의 클라이언트와 서버의 경우, 파드에서 ztunnel로 외부 패킷이 들어오면 동일한 ztunnel을 통해 대상 파드로 들어오는 내부 패킷으로 리디렉션됩니다.\n\n따라서, 동일 노드 내의 클라이언트 및 서버에서는 한 ztunnel이 외부 패킷과 내부 패킷을 받습니다. \"bound\"는 동일 노드 내의 응용 프로그램 파드로부터/받는 방향을 지정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n캡처 2: 클라이언트 및 서버가 다른 노드에 있는 경우\n---------\nztunnel-62hp8 istio-proxy 2024-06-16T12:48:51.792527Z info access connection complete src.addr=192.168.184.73:53265 src.workload=doks-debug-rdhgq src.namespace=ambient-demo src.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/default\" dst.addr=192.168.246.6:80 dst.hbone_addr=192.168.246.6:80 dst.service=httpbin.ambient-demo.svc.cluster.local dst.workload=httpbin-6f4dc97cb-5dpz9 dst.namespace=ambient-demo dst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\" direction=\"inbound\" bytes_sent=9832 bytes_recv=84 duration=\"60ms\"\nztunnel-fv5f8 istio-proxy 2024-06-16T12:48:51.793112Z info access connection complete src.addr=192.168.184.73:60162 src.workload=doks-debug-rdhgq src.namespace=ambient-demo src.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/default\" dst.addr=192.168.246.6:15008 dst.hbone_addr=192.168.246.6:80 dst.service=httpbin.ambient-demo.svc.cluster.local dst.workload=httpbin-6f4dc97cb-5dpz9 dst.namespace=ambient-demo dst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\" direction=\"outbound\" bytes_sent=84 bytes_recv=9832 duration=\"61ms\"\n```\n\n만약 클라이언트와 서버가 다른 노드에 있는 경우, 출발 트래픽은 동일한 노드인 ztunnel에서 외부 트래픽 패킷을 만나고, 그런 다음 목적지 파드의 노드의 ztunnel로 전송되어 들어오는 패킷으로 처리됩니다.\n\n# 결론\n\n이 실험을 통해 Istio Ambient Mesh에서 ztunnel을 통한 패킷 흐름을 시각화할 수 있었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_11.png)\n\n다음 파트에서는 ztunnel을 통해 적용할 수 있는 L4 인증 정책을 탐색할 것입니다.\n\n또한 Ambient에 있는 L7 프록시인 Waypoint Proxy에 대해 탐구할 것입니다.\n\n다른 기술 블로그는 여기에서 확인할 수 있습니다: [링크](https://janasabuj.github.io/posts/)\n","ogImage":{"url":"/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_0.png"},"coverImage":"/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_0.png","tag":["Tech"],"readingTime":35},{"title":"클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법","description":"","date":"2024-06-23 23:10","slug":"2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer","content":"\n## 이 기사에서는 쿠버네티스 클러스터 내에서 Kong을 API 게이트웨이로 배포하여 서비스에 관리된 액세스를 제공하는 방법을 살펴봅니다. 이를 클라우드 서비스에서 수행합니다. 이 클라우드 서비스는 쿠버네티스 호환 외부 로드 밸런서 서비스를 제공하지 않습니다. 또한 Ingress 리소스 대신 최신 Kubernetes Gateway를 사용합니다.\n\n저와 이전 기사 중 한 가지 이상을 따르신 분들은 저의 이전 기사들 중 하나를 따라오셨을 것입니다. 저는 신뢰할 수 있고 비용 효율적이지만 제한된 범위의 서비스를 제공하는 호주 클라우드 제공자인 Binary Lane을 사용합니다.\n\n제한된 범위의 서비스만 제공하는 것은 모든 쿠버네티스 작업을 직접해야 하므로, 배우고 솔루션의 작동 방식을 제어할 수 있는 기회를 제공합니다. 또한 어떤 클라우드 공급 업체에도 얽매이지 않을 수 있습니다. 또한 비용 효율적입니다.\n\n이 기사에서는 Kubernetes 클러스터에 Kong API 게이트웨이를 추가하여 서비스에 액세스하는 방법을 살펴봅니다. 할 일이 꽤 많기 때문에 이 기사는 좀 길지만, API 게이트웨이의 역할에 대한 이론 부분을 별도의 기사로 분리했습니다. API 게이트웨이의 역할을 이해하지 못하신다면 먼저 해당 기사를 읽는 것을 권장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKong은 신뢰할 만한 엔터프라이즈급 API 게이트웨이이지만 설정하기가 매우 까다로울 수 있습니다. 이 기사의 끝에서 문제를 디버그하는 방법에 대한 일부 힌트를 제공하겠습니다. 이 기사에서 설계를 조정하는 경우, 이름과 포트를 올바르게 구성했는지 확인하세요.\n\n# 네트워크 디자인\n\nKubernetes 네트워킹은 복잡한 주제이며 여기서 다루기 어렵지만, 고수준에서 네트워크 디자인에 대해 생각해야 합니다.\n\n![네트워크 디자인](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 기사를 따라오셨다면, 이제 이진 레인(또는 다른 클라우드 제공업체) 서버에 Kubernetes 클러스터가 설치되어 있어야 합니다. 인터넷에서 접근이 불가능한 가상 사설 클라우드 (VPC) 개인 서브넷에 세 개의 노드가 설치되어 있을 것입니다. 이러한 노드들은 인터넷을 통해 접속이 가능한 전용 VPN을 통해서만 연결됩니다(위에는 표시되지 않음). 인터넷 및 VPC 인터페이스를 모두 가지고 있는 게이트웨이 서버가 있어서, 인터넷에서 클러스터로 들어오는 접속(inress)과 클러스터에서 인터넷으로 나가는 접속(egress)을 제공합니다.\n\n기본 네트워크 토폴로지가 이제 갖추어 졌습니다. 이제 우리는 서비스가 외부 세계에 제공하는 API를 관리할 수 있기를 원합니다. 이 작업은 Kong Gateway API를 통해 수행됩니다.\n\n# 인터넷에서 연결 설정하기 (인그레스)\n\nAWS, 구글 클라우드 또는 Azure와 같은 풀 서비스 제공업체를 사용하면, LoadBalancer 유형의 Kubernetes 서비스를 사용하여 인터넷 연결이 자동으로 생성되는 방식으로 Kubernetes를 설정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n바이너리 레인에는 로드 밸런서 서비스가 있지만 쿠버네티스를 통해 관리할 수는 없으므로 로드 밸런서를 직접 생성하고 구성하거나 고유한 인그레스 포인트를 만들어야 합니다. 특정 클라우드 제공 업체의 기능에 구속되지 않기 위해, 저는 개인적으로 내 gw 서버에서 NGINX 역방향 프록시를 실행하여 고유한 인그레스 포인트를 만드는 것을 선호합니다.\n\n이 아키텍처에서 gw 서버에서 실행되는 NGINX는 두 가지 기능을 수행합니다:\n\n- 유효한 요청을 모두 쿠버네티스 클러스터로 라우팅하여 Kong이 처리\n- 쿠버네티스 노드 간 요청을 로드 밸런싱\n\nKong이 NodePort 서비스로 노출될 것이므로 클러스터의 모든 노드에서 액세스할 수 있습니다. 이를 통해 NGINX가 노드 간 요청을 로드 밸런싱할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스 자체가 사용 가능한 파드 전체에 무작위로 로드 밸런싱을 수행하므로 NGINX에 의한 로드 밸런싱이 노드 장애나 과부하 상황을 견딜 목적으로만 사용된다는 것을 유의한 점입니다. 서비스 로드 밸런싱에 대해 더 읽어보실 수 있습니다.\n\n본 솔루션에서 NGINX를 수동으로 구성된, 대체될 수 있는 외부 로드 밸런서로 간주하실 수 있습니다.\n\n# 쿠버네티스 서비스\n\n쿠버네티스 서비스는 하나 이상의 파드가 제공하는 서비스에 대한 액세스를 허용합니다. 이를 통해 파드가 종료되고 재예약되더라도 특정 노드에서 요청이 발생하더라도 서비스가 계속하여 요구에 따른 대로 요청을 라우팅하는 단일 접점으로 유지됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_1.png)\n\n서비스를 사용함으로써 요청을 보낼 수 있는 단일하고 안정적인 IP 주소가 제공됩니다. 서비스는 사용 가능한 Pod들 사이에서 부하 분산 기능을 제공합니다. Kubernetes는 또한 클러스터의 DNS에 서비스에 대한 참조를 추가함으로써 서비스가 이름으로 액세스될 수 있게 합니다. 여러 가지 다른 변형이 등록됩니다:\n\n```js\n\u003c서비스 이름\u003e.\u003c네임스페이스\u003e.svc.local\n\u003c서비스 이름\u003e.\u003c네임스페이스\u003e.svc\n\u003c서비스 이름\u003e.\u003c네임스페이스\u003e\n\u003c서비스 이름\u003e\n```\n\n# API 게이트웨이\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNGINX 게이트웨이와 쿠버네티스 서비스는 서비스에 대한 외부 인터페이스를 제공하는 데 도움이 되지만 기능이 제한적이며 수동으로 설정해야 합니다.\n\nAPI 게이트웨이는 이 문제를 해결하는 클러스터 구성 요소입니다. 이 게이트웨이는 솔루션의 일부로 구성되며 서비스 앞에 위치하여 여기서 설명하는 추가 기능을 제공합니다.\n\n![image](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_2.png)\n\nAPI 게이트웨이는 클러스터의 일부로 있기 때문에 클러스터 내 리소스의 변경에 따라 자동으로 구성될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Kong API Gateway\n\n다양한 API 게이트웨이 기술이 있지만, 이 글에서는 무료 오픈 소스 솔루션인 Kong을 선택했습니다. 유료 엔터프라이즈 설치도 가능합니다. 여기에서 Kong에 대한 포괄적인 공식 문서를 찾을 수 있습니다.\n\nKong은 쿠버네티스 커뮤니티와 적극적으로 협력하여 클러스터 내에서 게이트웨이에 대한 새로운 표준을 정의하고 있습니다. 이로 인해 게이트웨이 자체와 혼동되어서는 안 되는 새로운 쿠버네티스 리소스 유형인 게이트웨이 API가 만들어졌습니다.\n\n이것이 Kong이 어떻게 작동하는지 대략적으로 설명했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_3.png)\n\n클러스터 외부의 모든 클라이언트로부터 들어오는 트래픽이 Kong에 도달합니다. Kong은 구성 내의 규칙에 따라 요청을 처리하고 클러스터 내외의 적절한 서비스로 요청을 전달합니다.\n\nKong은 Kubernetes 리소스 매니페스트에서 정적으로 또는 데이터베이스에서 구성을 가져올 수 있습니다 (DB-less 설치). Kong은 이제 DB-less 설치를 새로운 설치에 사용할 것을 권장하며, 이를 따를 것입니다.\n\nKong은 성숙한 플러그인 기능을 갖추고 있습니다. 이를 통해 제3자가 Kong의 플러그인으로 기능 확장을 개발할 수 있습니다. 플러그인은 트래픽 흐름에 위치하여 속도 제한 및 인증과 같은 작업에 도움을 줄 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로 Kong을 관리하기 위해 플러그인, 구성 등을 관리할 수 있도록 Management UI를 제공합니다. Management UI는 Admin API를 통해 Kong과 상호 작용합니다.\n\nKong에 대해 상세한 문서를 살펴보면 여기서 다룰 수 있는 내용보다 더 많음을 알 수 있습니다. 그래서 제가 다루는 내용은 기본 사항에만 초점을 맞추겠습니다.\n\n## DB-less 설치\n\nDB-less 설치가 어떻게 작동하는지 이해하는 것이 중요하다고 생 생각합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 구성에서 Kong은 두 가지 구성요소를 설치합니다:\n\n- Kong Ingress Controller (KIC)\n- Kong Gateway\n\n게이트웨이는 프록시를 통해 모든 사용자 트래픽의 경로 지정을 처리합니다. Kong Ingress Controller (KIC)는 Kubernetes 리소스 정의 (예: HTTPRoute)에서 구성을 가져와서 프록시가 이해하는 규칙으로 변환하고 실시간으로 프록시에 규칙을 업로드합니다. 이러한 방식으로 Kubernetes 구성의 변경 사항이 자동으로 프록시에 적용됩니다.\n\nKIC는 내부 Kubernetes API를 사용하여 Kubernetes 클러스터에 대한 정보를 얻습니다. 이 API는 클러스터를 관리하는 데 사용되는 것으로, kubectl을 사용할 때 실제로는 Kubernetes API와 상호 작용합니다. 이 API를 통해 Kong 및 kubectl과 같은 애플리케이션은 클러스터에 대한 정보를 찾거나 변경할 수 있습니다. KIC는 이 API를 통해 백업 데이터베이스가 필요 없이 클러스터 리소스 파일과 Gateway를 동기화할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 테스트할 서비스\n\nKong 배포에 들어가기 전에 Kong을 통해 접근할 수 있는 서비스를 가지고 있어야 합니다. 어차피 API Gateway에 API가 없다면 그리 유용하지 않을 것이니까요!\n\n가장 간단한 방법은 NGINX를 웹 서버로 배포하고 정적 콘텐츠로 구성하는 것입니다. Kubernetes에서 이 작업을 한 적이 없다면 다른 기사 하나에서 그 방법을 읽어볼 수 있습니다.\n\n2개의 서비스를 생성하는 것을 제안합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 안녕하세요 world 1: 2개의 레플리카\n- 안녕하세요 world 2: 1개의 레플리카\n\n이들은 클러스터 내 파드에서 ClusterIP 서비스를 통해 접근할 수 있어야 합니다. 이러한 서비스를 설정하는 내 기사에서는 브라우저에서 서비스를 확인할 수 있도록 NodePort 서비스를 생성합니다. 이를 수행할 경우 내부 클러스터 IP 및 포트를 사용해야 합니다. 서비스 유형에 대한 자세한 내용은 다른 기사에서 확인할 수 있습니다.\n\n두 서비스가 올바르게 실행되고 Hello World HTML을 제공할 수 있는지 확인하세요.\n\n내가 여기서 설명하는 예제에서, 내 두 서비스는 다음과 같이 위치해 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- http://`node IP 주소`:30082 — 'Hello World 1 !!'라고 응답합니다.\n- http://`node IP 주소`:30082 — 'Hello World 2 !!'라고 응답합니다.\n\n어느 경로도 필요하지 않으며 경로를 추가하면 (예: http://`node IP 주소`:30082/world1) 404 오류가 발생합니다. 이 사실을 인식하지 못하면 나중에 문제가 될 수 있으므로 주의해야 합니다.\n\n이제 서비스가 실행 중이므로 Kong을 통해 액세스해 보겠습니다.\n\n# 쿠버네티스 게이트웨이 자원 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDB 미사용 모드에서는 Kong API 게이트웨이를 구성할 때 Kubernetes Ingress 또는 HTTPRoute 리소스를 생성합니다. 이러한 리소스를 클러스터에 적용하면 Kong이 프록시 구성 요소 내에서 라우팅 규칙을 정의하는 데 사용됩니다. 이를 통해 들어오는 트래픽이 서비스로 전달됩니다.\n\nIngress 리소스는 작동하지만 기능이 제한적입니다. Kubernetes 커뮤니티와 함께 Kong에서 개발한 새 Gateway 리소스를 사용하면 API를 더 정교하게 관리할 수 있습니다.\n\n우리는 Kong과 함께 Gateway 리소스를 사용할 것입니다. 이를 위해 먼저 GatewayClass 및 Gateway 리소스를 지원하는 새로운 Custom Resource Definitions (CRD)를 클러스터에 적용해야 합니다. 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다. 저의 경우에는 제 k8s-master 서버에서 이를 실행합니다.\n\n```js\nkubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n본 문서에서는 사용하지 않을 실험적 기능 몇 가지를 소개해드리겠습니다만, 참고용으로 여기에 추가해두었습니다.\n\n```js\nkubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/experimental-install.yaml\n```\n\n이제 Kubernetes를 위해 GatewayClass 및 Gateway 두 리소스를 정의할 수 있습니다. 이들이 무엇을 하는 지에 대해 설명했으니, 이를 다시 반복하지는 않겠습니다. 간결함을 위해 해당 내용은 여기서 생략합니다.\n\n## GatewayClass\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKong 기술을 클러스터에 소개하는 GatewayClass를 정의할 것입니다. 다음 파일을 생성해주세요:\n\nkong-gw-class.yml\n\n```yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: kong-class\n  annotations:\n    konghq.com/gatewayclass-unmanaged: \"true\"\nspec:\n  controllerName: konghq.com/kic-gateway-controller\n```\n\n이 파일에 대해 몇 가지 주의할 사항이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이것은 클러스터 수준 리소스이기 때문에 네임스페이스가 없습니다.\n- 주석은 솔루션별 옵션을 정의하며 Kong의 경우 konghq로 시작합니다.\n- konghq.com/gatewayclass-unmanaged 주석은 'true'(문자열)로 설정되어 있습니다. 왜냐하면 Kong이 오퍼레이터를 통해 자동으로 설정되는 것이 아니라 수동으로 설정되고 있기 때문입니다.(다른 옵션도 있으니 여기를 참조하세요)\n- 인그레스 컨트롤러는 Kong 인그레스 컨트롤러(konghq.com/kic-gateway-controller)이며 contollerName 필드에서 구성됩니다.\n\n이제 다음과 같이 클래스를 생성하세요:\n\n```js\nkubectl apply -f kong-gw-class.yml\n```\n\n이제 이 클래스를 사용하는 게이트웨이를 생성할 수 있습니다. 동일한 GatewayClass를 참조하는 여러 Gateway 인스턴스를 생성할 수 있다는 점을 유의하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 게이트웨이\n\n수동으로 설치된 Kong 게이트웨이의 경우 (우리가 생성중인 것과 같이), 다음 파일을 만들어야 합니다:\n\nkong-gw-gateway.yml\n\n```yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: kong-gateway\n  namespace: kong\nspec:\n  gatewayClassName: kong-class\n  listeners:\n    - name: world-selector\n      hostname: worlds.com\n      port: 80\n      protocol: HTTP\n      allowedRoutes:\n        namespaces:\n          from: All\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파일에서 유의해야 할 몇 가지 사항이 또 있습니다:\n\n- 나중에 참조할 수 있는 이름이 있습니다 (kong-gateway)\n- GatewayClass는 위에서 생성한 GatewayClass의 이름을 의미합니다\n- 이 Gateway는 이 API Gateway의 진입점인 하나의 리스너만 정의합니다\n- 리스너에는 URL 호환성이 있는 고유한 이름이 지정됩니다\n- 리스너는 포트 80에 바인드됩니다\n- 호스트명은 일치 필드로 사용되며 옵션입니다\n- 이 리스너에 연결할 서비스(allowedRoutes)를 제어할 수 있으며 해당 서비스들은 네임스페이스를 통해 연결됩니다 - 동일한 네임스페이스를 기본으로 사용하여 다른 네임스페이스로 연결하기 위해 모든 네임스페이스로 변경됩니다\n- Gateway 사양은 게이트웨이가 HTTP를 통해 단일 포트(80)에서 수신하는 것을 예상합니다.\n\nGateways는 네임스페이스에 특정하며 API Gateway를 설치하기 전에 생성해야 합니다:\n\n```js\nkubectl create namespace kong\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음 명령을 사용하여 리소스를 만드세요:\n\n```js\nkubectl apply -f kong-gw-gateway.yml\n```\n\n이제 GatewayClass 및 Gateway 리소스가 정의되었으므로, 애플리케이션 자체를 설치하여 이 두 리소스의 구현을 형성할 수 있습니다.\n\n# Kong 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 Helm 차트를 사용하여 Kong을 설치할 것입니다. 만약 Helm이 없다면, Helm을 설치하는 방법은 여기에서 찾을 수 있습니다.\n\n## Kong CRDs\n\nKong을 설치하기 전에 Kong Custom Resource Definitions (CRDs)를 설치해야 합니다. 이 작업은 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 수행할 수 있습니다. 제 경우에는 k8s-master 서버에서 이 작업을 수행하고 있습니다.\n\n```js\nkubectl apply -k https://github.com/Kong/kubernetes-ingress-controller/config/crd\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Kong Application\n\nKong을 Kubernetes 클러스터에 설치할 때, 두 가지 구성 요소가 설치됩니다:\n\n- Kong 인그레스 컨트롤러 (KIC) — 쿠버네티스 리소스 정의를 Kong 게이트웨이 구성으로 변환합니다.\n- Kong 게이트웨이 — Kong 인그레스 컨트롤러 (KIC)에 의해 삽입된 구성을 기반으로 서비스로의 라우팅을 담당합니다.\n\n먼저, 로컬 헬름에 Kong 저장소를 추가하십시오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhelm repo add kong https://charts.konghq.com\nhelm repo update\n```\n\n만약 다음 명령어로 Helm 차트를 검색하면:\n\n```js\nhelm search repo kong\n```\n\n두 개의 항목을 찾을 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n이름           차트 버전  앱 버전  설명\nkong/kong    2.33.3    3.5       클라우드 네이티브 인그레스 및 API 관리\nkong/ingress 0.10.2    3.4       콩 인그레스 컨트롤러 및 콩 게이트웨이 배포\n```\n\nDB 레스 구성을 사용할 것이므로 kong/ingress를 사용할 것입니다. 설치하기 전에 몇 가지 값을 재정의해야 합니다. 다음 파일을 만들어주세요:\n\nkong-values.yml\n\n```js\n#controller:\n#  ingressController:\n#    env:\n#      LOG_LEVEL: trace\n#      dump_config: true\n\ngateway:\n  admin:\n    http:\n      enabled: true\n  proxy:\n    type: NodePort\n    http:\n      enabled: true\n      nodePort: 32001\n    tls:\n      enabled: false\n#  ingressController:\n#    env:\n#      LOG_LEVEL: trace\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKIC 및 Kong Gateway를 부모 Helm 차트를 통해 설치하고 있기 때문에 이 두 애플리케이션의 구성은 각각 컨트롤러 및 게이트웨이 레이블 아래에 있습니다. 컨트롤러는 단순히 알림으로 남겨두었습니다.\n\n또한, 주석 처리된 여러 줄을 볼 수 있습니다. 이것들은 Pod 로그를 통해 무엇이 발생하는지 디버그하고 싶을 때 유용합니다.\n\nBinary Lane은 Kubernetes가 구성할 수 있는 로드 밸런서를 제공하지 않기 때문에 프록시 구성을 재정의하고 있습니다. Kubernetes에게 LoadBalancer 서비스 대신 NodePort 서비스를 설정하도록 지시하고 있습니다. 게이트웨이를 클러스터의 모든 노드에서 사용할 수 있도록 포트 32001에 노출하고 있습니다.\n\n이전에 kong 네임스페이스를 생성했으므로 이제 Kong을 설치할 준비가 되었습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhelm install kong kong/ingress -f kong-values.yml -n kong\n```\n\n이제 설치가 예상대로 작동하는지 확인할 수 있습니다. 준비되는 데 1-2분 정도 걸릴 수 있습니다:\n\n```js\nkubectl get all -n kong\n```\n\n다음과 같은 결과를 얻어야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### NAME READY STATUS RESTARTS AGE\n\n- pod/kong-controller-68cddcbcb7-z46lh 1/1 Running 0 45s\n- pod/kong-gateway-687c5b78db-5qvgd 1/1 Running 0 45s\n\n### NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\n\n- service/kong-controller-validation-webhook ClusterIP 10.110.172.40 \u003cnone\u003e 443/TCP 46s\n- service/kong-gateway-admin ClusterIP None \u003cnone\u003e 8444/TCP 46s\n- service/kong-gateway-manager NodePort 10.100.254.169 \u003cnone\u003e 8002:30698/TCP,8445:30393/TCP 46s\n- service/kong-gateway-proxy NodePort 10.96.24.196 \u003cnone\u003e 80:32001/TCP 46s\n\n### NAME READY UP-TO-DATE AVAILABLE AGE\n\n- deployment.apps/kong-controller 1/1 1 1 45s\n- deployment.apps/kong-gateway 1/1 1 1 45s\n\n### NAME DESIRED CURRENT READY AGE\n\n- replicaset.apps/kong-controller-68cddcbcb7 1 1 1 45s\n- replicaset.apps/kong-gateway-687c5b78db 1 1 1 45s\n\nManagement UI 서비스가 NodePort를 통해 노출됩니다. 이는 관리 API를 볼 수 있는 것을 기대하고 작동하지 않을 것입니다. DB-less 설치를 하고 있기 때문에, 관리 UI의 유일한 사용은 설정을 확인하는 것뿐입니다.\n\n클러스터 내 노드에서 프록시 주소를 curl로 테스트할 수 있습니다:\n\n```js\ncurl localhost:32001\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요청한 표는 Markdown 형식으로 변경해야 합니다.\n\n```json\n{\n  \"message\": \"해당 값으로 일치하는 경로가 없습니다.\",\n  \"request_id\": \"7fc9db053e3029105581890e81effe12\"\n}\n```\n\n요청 ID는 해당 거래에 고유하며 curl 명령을 다시 실행하면 다른 값을 볼 수 있습니다. 이는 Kong에서 추가되어 시스템을 통해 요청을 추적할 수 있게 합니다. 멋지죠?\n\n이제 새 API 게이트웨이를 구성하여 이전에 생성한 테스트 서비스로 요청을 라우트할 준비가 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 라우트 추가하기\n\n게이트웨이 리소스에 라우트를 추가하려면 HTTPRoute 리소스를 사용합니다. 다른 수준의 라우팅을 위한 다른 리소스 유형도 있습니다. 이제 worlds.com/world1을 hello-world-1-svc에, worlds.com/world2를 hello-world-2-svc에 연결하기 위해 이러한 리소스 중 하나를 생성할 것입니다.\n\n저는 하나의 HTTPRoute 리소스를 설명하겠고, 다른 하나는 여러분에게 만들어 달라고 요청할 것입니다. 리소스 파일을 생성해주세요:\n\nhello-world-1-route.yml\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: example-1\n  annotations:\n    konghq.com/strip-path: \"true\"\nspec:\n  parentRefs:\n    - name: kong-gateway\n      namespace: kong\n  hostnames:\n    - worlds.com\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /world1\n      backendRefs:\n        - name: hello-world-1-svc\n          port: 80\n          kind: Service\n```\n\n이 파일에서는 'true'로 설정된 Kong 특정 주석인 konghq.com/strip-path를 추가했습니다. 이는 수신된 일치하는 경로를 요청에서 southbound 서비스로 줄일 것입니다. 다른 줄에는 다음이 포함되어 있습니다:\n\n- 사용할 게이트웨이의 정의(ParentRefs에서)는 이름과 네임스페이스로 참조됩니다.\n- 게이트웨이에서 적절한 수신기에 일치시킬 호스트명에 대한 선택적 참조\n- 이 경로에 대해 들어오는 요청과 일치시키는 규칙\n- 요청을 이 일치에 대해 경로지정할 서비스를 정의하는 backendRefs(서비스의 내부 DNS 이름이름이며 포트는 서비스에 대한 매핑되지 않은 클러스터 IP 포트임을 주의하세요)\n\n이 경로에서 일치는 /world1의 접두사이며, 그 후 서비스로 전달되기 전에 제거됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음 라우트를 만듭니다:\n\n```js\nkubectl apply -f hello-world-1-route.yml\n```\n\nNodePort 서비스를 사용하여 게이트웨이를 만들었습니다. 이제 서비스를 테스트할 수 있습니다. NodePort 서비스는 클러스터의 모든 노드에서 사용할 수 있습니다. 보통 저는 k8s-master 노드를 사용하지만 다른 노드도 사용할 수 있습니다. 다음 명령어로 테스트할 수 있습니다:\n\n```js\ncurl -H \"Host: worlds.com\" \u003ck8s-master IP 주소\u003e:32001/world2\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원하는 요청 라우팅을 위해 Host 헤더로 호스트명을 worlds.com으로 설정했습니다. 테스트 서비스 응답이 돌아오는 것을 확인할 수 있어야 합니다.\n\n이제 두 번째 HTTPRoute 리소스를 추가하여 두 번째 서비스의 요청을 관리할 수 있습니다.\n\n이제 클러스터 노드에서 서비스에 액세스할 수 있으므로 최종 단계 진행할 수 있습니다 - gw 서버 구성.\n\n# 인그레스 지점 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 AWS, Azure, 또는 Google Cloud에서 작업 중이었다면, Gateway 서비스를 LoadBalancer로 유지하고 자동으로 인그레스 포인트가 생성되도록 할 수 있었을 텐데 Binary Lane에서 작업 중이므로 직접 만들어야 합니다.\n\n제 글을 따라오셨다면 알겠지만, 저희는 클러스터로부터 인터넷으로의 인그레스 포인트로 작용하는 gw 서버가 있다는 것을 알고 계실 것입니다. 이 서버는 간단하게 NGINX를 사용하여 구성되어 있습니다.\n\n우리는 이것을 모든 요청을 라운드 로빈 로드 밸런서를 사용하여 클러스터 내 모든 노드로 경로를 설정하도록 구성할 것입니다.\n\ngw 서버에 로그인하고 root 사용자로 다음 파일을 업데이트하십시오 (``에 자신의 값으로 필드를 교체하는 것을 잊지 마세요):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 worlds.conf 파일의 내용입니다.\n\n```js\nupstream k8s_cluster {\n  server \u003ck8s-master\u003e:32001;\n  server \u003ck8s-node1\u003e:32001;\n  server \u003ck8s-node2\u003e:32001;\n}\n\nserver {\n    listen 80;\n    listen [::]:80;\n\n    server_name worlds.com;\n\n    location / {\n        proxy_pass http://k8s_cluster;\n        include proxy_params;\n    }\n}\n```\n\n일반적으로 프록시 매개변수는 별도의 파일에 설정됩니다:\n\n`/etc/nginx/proxy_params`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nproxy_set_header Host $http_host;\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\n```\n\n이렇게 하면 Host 헤더 및 기타 세부 정보가 전달되어 라우팅이 효율적으로 작동할 수 있습니다.\n\n이제 사이트를 활성화하고 구성을 테스트한 다음 NGINX를 재시작하십시오:\n\n```js\nln -s /etc/nginx/sites-available/worlds.conf /etc/nginx/sites-enabled/\nnginx -t\nsystemctl restart nginx\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 테스트할 수 있습니다 ( ' '필드를 귀하의 값으로 대체하세요):\n\n```js\ncurl -H \"Host: worlds.com\" \u003cgw 서버 공인 IP 주소\u003e/world1\n```\n\n서버로부터 응답을 받아야 합니다.\n\n축하합니다! 이제 콩(Kong)을 설치하고 서비스에 연결하도록 구성하는 데 성공했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Kong 디버깅\n\n만약 Kong에서 문제가 발생하면 디버깅하는 것이 어려울 수 있어요. 제가 Kong 설치 과정에서 발견한 몇 가지 지침을 공유해드릴게요:\n\n- GatewayClass, Gateway, 그리고 controller/gateway 포드에 kubectl describe를 사용해서 결과물을 주의깊게 살펴보세요. 이런 방법을 이용해 해결책을 찾을 때까지 곤란한 상황에 직면한 적이 있어요.\n- controller와 gateway 로그를 다음과 같이 확인해보세요:\n\n```js\nkubectl logs \u003cpod name\u003e -n kong\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- kong-values.yml 파일을 사용하여 로깅 레벨을 높이세요 (이전에 보여준 라인의 주석을 제거하세요)\n- NodePort 주소를 얻기 위해 kubectl get svc -n kong를 사용하여 관리 UI에 접속하세요 — HTTP 포트를 사용하고 Admin API를 포트 포워딩하세요 (서비스를 외부로 바인딩하기 위해 --address 옵션을 추가하세요):\n\n```js\nkubectl port--forward \u003c게이트웨이 파드 이름\u003e 8001:8001 --address \u003ck8s-마스터 IP 주소\u003e\n```\n\n- 포트 8001을 포워딩한 이후, Postman와 같은 REST API 도구를 사용하여 Admin UI에 접속하세요\n- 접속할 수 있는 디버그 포트가 있습니다:\n\n```js\nkubectl port-forward -n kong \u003c컨트롤러 파드 이름\u003e  10256:10256 --address \u003ck8s-마스터 IP 주소\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n이 글은 API Gateway인 Kong을 설치하기 위해 필요한 모든 단계를 함께 수행해야 하기 때문에 길었습니다.\n\n이 글에서 우리는:\n\n- 네트워크 토폴로지를 검토했습니다.\n- 서비스가 서비스에 접근하는 데 도움이 되는 방법을 살펐습니다.\n- Kong이 Kubernetes와 어떻게 작동하는지 살펐습니다.\n- 사용할 테스트 서비스를 생성했습니다.\n- GatewayClass 및 Gateway 리소스를 설치하고 구성했습니다.\n- Kong을 설치하고 구성했습니다.\n- 자체 외부 로드 밸런서를 구성했습니다.\n- API Gateway 설치 문제를 해결하는 방법을 고려했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내 저희는 Kong API 게이트웨이를 통해 인터넷에서 저희의 테스트 서비스에 접속할 수 있었습니다.\n\n이 기사가 흥미롭게 여겨진다면 박수를 부탁드립니다. 이는 미래에 어떤 기사를 쓸지 판단하는 데 도움이 됩니다. 의견이 있으시면 댓글에 남겨주시기 바랍니다.\n","ogImage":{"url":"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png"},"coverImage":"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png","tag":["Tech"],"readingTime":27}],"page":"11","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"11"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>