<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/11" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/11" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="iOS 앱을 위한 UI 디자인 완벽 가이드" href="/post/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS 앱을 위한 UI 디자인 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS 앱을 위한 UI 디자인 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS 앱을 위한 UI 디자인 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 " href="/post/2024-06-23-SettingupanewMacmytop3essentials"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SettingupanewMacmytop3essentials_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="WWDC 2024 Swift의 새로운 동시성 기능 탐구" href="/post/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="WWDC 2024 Swift의 새로운 동시성 기능 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="WWDC 2024 Swift의 새로운 동시성 기능 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">WWDC 2024 Swift의 새로운 동시성 기능 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI의 NavigationStack 사용 방법" href="/post/2024-06-23-HowtousetheSwiftUIsNavigationStack"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI의 NavigationStack 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI의 NavigationStack 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI의 NavigationStack 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Unowned self 개념의 문제점" href="/post/2024-06-23-TheCaseAgainstunownedself"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Unowned self 개념의 문제점" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Unowned self 개념의 문제점" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Unowned self 개념의 문제점</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법" href="/post/2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Kotlin Flows 기본 개념 이해하기" href="/post/2024-06-23-KotlinFlowsFundamentals"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kotlin Flows 기본 개념 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-KotlinFlowsFundamentals_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kotlin Flows 기본 개념 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Kotlin Flows 기본 개념 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ" href="/post/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법" href="/post/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">30<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Callback 대신 Coroutine 사용하는 방법" href="/post/2024-06-23-HowtouseaCoroutineinsteadofCallback"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Callback 대신 Coroutine 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtouseaCoroutineinsteadofCallback_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Callback 대신 Coroutine 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Callback 대신 Coroutine 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link posts_-active__YVJEi" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"iOS 앱을 위한 UI 디자인 완벽 가이드","description":"","date":"2024-06-23 23:44","slug":"2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps","content":"\n\u003cimg src=\"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png\" /\u003e\n\niOS 앱을 위한 UI 디자인을 만드는 포괄적인 가이드를 공유하고 싶어요. 이 가이드는 우리가 애플 가이드라인과 일관성을 유지하면서 고품질 디자인을 만들기 위해 알아야 하는 필수 주제를 다룹니다.\n\n구성:\n\n- 레이아웃 및 그리드\n- 색상\n- 타이포그래피\n- 아이콘\n- 컴포넌트\n- 전환\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 레이아웃과 그리드\n\nFigma에서 iPhone용 다양한 아트보드 크기를 찾을 수 있고, 디자인을 위해 어떤 것을 선택해야 하는지 고민할 수 있습니다. 하지만 코드 수준에서 XCode는 자동으로 선택한 기기에 따라 레이아웃을 조정해줍니다. 따라서 가장 인기 있는 iPhone의 아트보드 크기를 선택하고, 이 모델의 레이아웃 사양을 고려하여 UI를 설계할 수 있습니다.\n\n아래 이미지는 iPhone 14 Pro의 레이아웃 영역과 사양을 보여줍니다.\n\n![iPhone 14 Pro Layout](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n☝️ 버튼 및 컨트롤과 같은 UI 요소는 상태 표시줄과 홈 인디케이터 영역에 가려지지 않는 영역에만 배치해야 합니다. 이렇게 하면 iOS 시스템 요소와의 상호 작용에 방해가 되지 않습니다.\n\n그리드는 콘텐츠를 구조적으로 배열하는 데 도움이 됩니다. 일반적으로 반응형 웹사이트 디자인에 사용되지만, 모바일 앱에서도 유용합니다.\n\n모바일 앱을 위한 그리드 정의 방법:\n\n- 화면 위에 요소를 정확히 배치하기 위해 8포인트 그리드를 생성합니다.\n- 좌우 여백을 16포인트의 최소 크기로 정의하세요. 이것은 iOS의 표준입니다.\n- 필요에 맞게 최적의 열 수를 정의하세요. 16포인트의 거터 크기가 가장 일반적이지만, 더 작거나 큰 거터 크기를 정의해야 한다면, 스트레치 그리드에서는 거터 크기가 열 너비에 영향을 미치므로, 거터 크기가 클수록 열 너비가 작아집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 이 멋진 기사를 확인해보세요! 여기서 모바일 그리드에 대해 더 배울 수 있어요.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_2.png)\n\n# 색상\n\niOS에는 활력, 접근성 설정 및 외형 모드에 자동으로 적응되는 시스템 및 의미론적 색상이 정의되어 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시멘틱 컬러는 목적을 설명하는 이름을 가진 색상입니다. 각 시멘틱 컬러에는 기본, 보조, 제3의 색상 변형이 있어서 등급에 따라 콘텐츠를 구분하는 데 사용됩니다. 예를 들어, 기본 배경에 대한 사용자 정의 색상을 정의하려면 색상 이름을 앱은 브랜드/앱의 약어이며 PrimaryBackground는 색상의 시멘틱 이름입니다. 사용자 지정 색상의 이름은 iOS 시스템 색상과 같아서는 안 됨을 언급할 가치가 있습니다.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_3.png)\n\n🎨 애플의 가이드라인을 고려하여 사용자 정의 색상 팔레트를 만드는 방법을 살펴보겠습니다.\n\n## 기본 색상\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n앱의 개성을 전달하는 데 기본적인 색상이 중요합니다. 이것은 팔레트의 기본 색상입니다. 대부분의 화면과 구성 요소에서 자주 표시되는 이 색상은 주요 작업을 나타내는 데 사용됩니다. 특정 UI 요소를 강조하거나 탭, 누름과 같은 상호 작용을 위한 UI 상태를 나타내는 데 주요 색상 쉐이드를 사용할 수도 있습니다.\n\nFigma에서 색상 쉐이드를 생성하려면 이 플러그인을 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_4.png)\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 보조 및 강조 색상\n\n보조 색상은 주요 색상을 지원하고 디자인에 깊이와 다양성을 더합니다.\n\n![보조 색상](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_6.png)\n\n보조 색상 외에도 \"강조\" 색상 용어를 만날 수 있습니다. 강조 색상은 중요한 조치 및 컨트롤을 강조하는 데 사용되는 보조 색상의 일부로 고려할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n강조색은 다음에 가장 적합합니다:\n\n- 슬라이더 및 스위치와 같은 선택 컨트롤\n- 선택된 텍스트 강조\n- 진행 표시 막대\n- 링크 및 헤드라인\n\n기본 색을 보완하는 보조 색상을 찾으려면 Coolors와 같은 색 구성 생성기를 사용해보세요. 일반적으로 앱에는 1개의 주요 색상, 1-2개의 보조 색상 및 1-3개의 강조색이 있어야 합니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 채우기 색상\n\niOS에서는 채우기 색상이 UI 요소에 사용되며, 이를 통해 배경 색상이 나타납니다. 채우기 색상은 동일한 색상 값을 공유하지만 각 색상 변형마다 다양한 불투명도 수준을 갖고 있습니다.\n\niOS 채우기 색상 변형:\n\n- 기본 채우기 색상 — 슬라이더의 트랙과 같은 얇고 작은 모양에 사용됩니다.\n- 보조 채우기 색상 — 스위치의 배경과 같은 중간 크기의 모양에 사용됩니다.\n- 제 3위 채우기 색상 — 입력 필드, 검색 바 또는 버튼과 같은 큰 모양에 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image 8](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_8.png)\n\n![image 9](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_9.png)\n\n## 배경색상\n\niOS는 콘텐츠 및 요소의 그룹화를 구분하기 위해 배경색상의 색상 변형을 정의합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 전반적인 뷰의 기본적인 배경을 위한 기본(primary).\n- 전반적인 뷰 내에서 콘텐츠나 요소들을 그룹화하기 위한 보조(secondary).\n- 보조 요소 내에서 콘텐츠나 요소들을 그룹화하기 위한 제3 단계(tertiary).\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_10.png)\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_11.png)\n\n## 레이블 색상\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n라벨 색상에는 주요, 보조, 제 3 및 제 4 등급의 색상 변형이 있습니다. 중요도 수준에 따라 색상은 해당 투명도 수준을 갖습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_12.png)\n\n- 주요 레이블 색상은 사용자에게 강조해야 할 중요한 텍스트나 콘텐츠를 강조하는 데 사용됩니다. 예를 들어, 제목 및 헤드라인, 내비게이션 막대 페이지의 레이블, 양식에서의 필드 레이블 또는 입력 컨트롤에 주요 색상을 사용할 수 있습니다.\n- 보조 레이블 색상은 자막이나 지원 정보를 표시하는 데 사용됩니다. 보조 레이블은 양식과 입력 필드에서 필드나 입력 컨트롤에 대한 추가 컨텍스트나 지시사항을 제공하기 위해 사용될 수 있으며, 목록이나 테이블에서 목록이나 테이블 항목에 대한 보조 정보와 세부 정보를 표시하는 데 사용됩니다.\n- 제 3 등급 레이블 색상은 더 중요하지 않은 텍스트나 콘텐츠를 표시하는 데 사용됩니다. 더 이상 필수가 아닌 보충 정보나 앱 사용자의 이해에 필수적이지 않은 세부 정보를 표시하기 위해 사용됩니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_13.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 구분선 색상\n\n구분선은 콘텐츠 그룹을 시각적으로 구분하는 데 사용되는 가는 수평 선입니다. 표 뷰, 컬렉션 뷰 및 사용자 인터페이스의 다른 부분에서 시각적 계층 구조를 만들고 사용자가 콘텐츠의 구조를 이해하는 데 도움이 되도록 자주 사용됩니다.\n\niOS에서는 불투명도 수준을 가진 Separator 및 불투명 선 (일반 선) 두 가지 유형의 구분선 색상을 정의합니다.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_15.png\" /\u003e\n\n## 기능적인 색상\n\n기능적인 색상은 요소의 상태나 상태를 나타내거나 사용자에게 맥락이나 메시지를 제공하는 데 사용됩니다.\n\n기능적인 색상에 대한 지침:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 성공 상태: 성공 상태를 나타내기 위해 녹색이 자주 사용됩니다. 이는 작업이 성공적으로 완료되었거나 양식이 올바르게 작성되었음을 나타내는 데 사용될 수 있습니다.\n- 경고 상태: 노랑 또는 주황색이 경고 상태를 나타내는 데 흔히 사용됩니다. 이는 사용자에게 잠재적인 문제를 경고하거나 필수 조치가 아직 완료되지 않았음을 나타내는 데 사용될 수 있습니다.\n- 오류 상태: 빨강은 오류 상태를 나타내는 데 자주 사용됩니다. 이는 텍스트 또는 배경 색상, 또는 아이콘이나 버튼과 같은 요소에 사용될 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_16.png)\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_17.png)\n\n## 색상 관리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 Figma 플러그인이 있어서 색상 관리에 도움이 되는데요:\n\n- Color Palette Generator는 제공하는 단일 색상을 기반으로 색 팔레트를 생성합니다.\n- Color Contrast Checker는 두 색상 사이의 대조 비율을 확인하여 색상 선택이 접근성 지침을 준수하는지 확인하는 데 도움을 줍니다.\n- Colorblind Simulator을 사용하면 특정 유형의 색상 시각 결여를 가진 사람이 볼 때 디자인을 확인할 수 있습니다. 이를 통해 디자인이 모든 사용자에게 접근 가능한지 확인할 수 있습니다.\n- Dark Mode Magic을 사용하면 생성한 Light 테마를 기반으로 Dark 테마를 생성할 수 있습니다.\n\n# Typography\n\nApple은 San Francisco와 New York과 같은 내장된 글꼴 모음을 가지고 있습니다.\nSan Francisco에는 SF Pro를 포함한 여러 가지 변형이 있으며, SF Pro는 해당 글꼴의 표준 버전입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원하는 경우 사용자 정의 글꼴을 계속 사용할 수 있습니다. 몇 가지 고려해야 할 사항이 있습니다:\n\n- 글꼴이 가독성이 좋도록 해야 합니다. 가독성에 영향을 미치는 요소에는 문자 인식, 선 두께(문자를 구성하는 선의 두께), 트래킹(글자 간격), 리딩(줄 간격), 글꼴 크기 및 글꼴 스타일이 있습니다.\n- 모바일 앱에서 최대 두 가지 글꼴을 사용하여 간단하고 조화로운 인터페이스를 유지하는 것이 좋습니다.\n- 글꼴이 서로 어떻게 보왁 주위서 상치하는지를 고려하는 것이 중요합니다. 서로 너무 비슷한 글꼴 유형을 결합하는 것을 피해야 하며, 그렇지 않으면 서로 구별하기 어려울 수 있습니다.\n\nGoogle Fonts를 사용하여 다른 글꼴 조합을 미리보기하는 것을 고려해보세요. 또한 Figma가 제작한 준비된 Google 글꼴 유형 조합 팔레트를 사용할 수도 있습니다.\n\n## 글꼴 스타일 및 글꼴 크기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다양한 글꼴 크기와 굵기를 사용하여 제목, 헤딩, 본문 텍스트 및 캡션이란 텍스트 스타일을 구분합니다. 기본적으로 iOS에는 Large Title, Title 1, Title 2 등과 같은 미리 정의된 텍스트 스타일이 있습니다. 이러한 텍스트 스타일마다 기본 글꼴 크기와 다이나믹 타입 크기가 부여됩니다.\n\n다이나믹 타입은 iOS의 기능 중 하나로, 사용자가 앱 내 텍스트의 글꼴 크기를 조절할 수 있습니다. 사용자 정의 글꼴을 사용하려는 경우 기본 글꼴 크기뿐만 아니라, 다이나믹 타입 크기도 코드 수준에서 정의되어야 사용자가 텍스트의 글꼴 크기를 조절할 수 있도록 보장해야 합니다.\n\n사용자 정의 글꼴 스타일에 대해 기본 글꼴 크기를 선택하는 가이드로 다음 표를 고려해 보세요.\n\n![표](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_18.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 텍스트 레이아웃\n\n트래킹과 리딩은 최적의 가독성과 가시성을 위해 텍스트 레이아웃을 세밀하게 조정할 수 있는 필수적인 텍스트 속성입니다.\n\n트래킹은 글자 사이의 간격을 의미합니다. CSS에서는 \"letter-spacing\"으로 불리며, 트래킹과 letter-spacing은 동의어입니다.\n\n리딩은 텍스트 줄 사이의 간격을 말합니다. Figma와 CSS에서는 이 속성을 \"line-height\"라고 합니다. 줄 간격을 늘리거나 줄이는 것은 가독성을 향상시키는 데 도움이 될 수 있습니다. 리딩은 텍스트 기준선부터 측정됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 추적 및 리딩에 대한 몇 가지 팁:\n\n- 가독성을 높이려면 리딩을 증가시키세요. Figma는 가독성 있는 텍스트를 얻기 위한 최소한의 라인 높이로서 글꼴 크기의 1.125배(112.5%)로 설정할 것을 권장합니다. 그러나 값은 글꼴에 따라 다를 수 있습니다. 예를 들어, Apple은 본문 텍스트(SF Pro 글꼴)를 위한 리딩을 129%(22 pt)로 최소값으로 정의합니다. 그러나 긴 문단의 텍스트에 대한 좋은 가독성을 얻고 싶은 경우 141%(24 pt)로 리딩을 증가시키는 것을 권장합니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_19.png)\n\n- 좋은 가독성을 유지하려면 폰트 크기에 대한 추적 값을 너무 높거나 너무 낮게 사용하는 것을 피하는 것이 좋습니다. 시스템 글꼴의 최적 추적 값을 설명하는 Apple의 추적 테이블을 참고할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_20.png\" /\u003e\n\n# 아이콘\n\n아이콘은 인터페이스 항목, 작업 및 상태의 의미를 전달해야 하는 그래픽 요소입니다. 효과적인 아이콘은 사용자에게 간단하고 익숙하며 이해하기 쉬워야 합니다.\n\niOS에는 iOS 앱에서 사용할 수 있는 벡터 아이콘(SF Symbols) 세트가 제공됩니다. 여기 SF Symbols를 찾을 수 있는 Figma 파일이 있습니다. 또한 SF Symbols를 편집하고 사용자 정의하는 방법에 대한 상세한 비디오도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 앱에서 아이콘을 사용할 때 몇 가지 팁:\n\n- 사용자 정의 아이콘을 사용하려면 일관된 스타일, 크기 및 두께를 유지하는지 확인하세요.\n\n![Custom Icons](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_21.png)\n\n- 아이콘의 명암비를 테스트하세요. W3C에 따르면 아이콘과 같은 \"그래픽 객체\"는 적어도 3:1의 명암비를 가져야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_22.png)\n\n- 아이콘이 한눈에 알아볼 수 없으면 가능한 경우 텍스트 레이블을 추가하세요. 아래 예시에서 Headspace가 텍스트 레이블이 없다면, 왼쪽 아이콘(Today)의 의미를 빠르게 이해하기 어려울 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_23.png)\n\n- 모든 표준 화면에서 작동할 수 있도록 SVG와 같은 벡터 형식의 아이콘을 사용하세요. 1배 해상도의 표준 화면과 2배, 3배 고해상도의 레티나 디스플레이에 모두 작동해야 합니다.\n- 아이콘은 가독성이 있고 탭하기 쉬워야 합니다.\n- 일반 탭 바 아이콘의 크기는 적어도 25x25pt이어야 하며, 내비게이션 바의 아이콘은 20x20 또는 30x30pt가 될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 아이콘에 대한 자세한 정보는 Apple의 문서를 확인해보세요.\n\n# 구성 요소\n\niOS에는 다양한 종류의 구성 요소 라이브러리가 있습니다. 이들을 모두 문서에서 찾을 수 있습니다. 여기서는 거의 모든 iOS 모바일 앱에서 찾을 수 있는 가장 인기 있는 세 가지 구성 요소 — 목록, 탭 바 및 네비게이션 바 — 에 대해 다루고, 각각에 대한 최선의 방법을 강조하고 싶습니다.\n\n## 목록과 표\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이템의 컬렉션을 표시하는 방법으로 목록과 표가 있습니다. 이 아이템들은 텍스트, 아이콘/이미지 또는 텍스트와 선택 컨트롤의 조합일 수 있습니다.\n\n![Image 1](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_24.png)\n\n![Image 2](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_25.png)\n\n최선의 방법들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 배경 전체에 다른 색상을 사용하여 배경과 콘텐츠 그룹 간의 시각적 대조를 만드세요.\n\n![Image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_26.png)\n\n- 테이블 콘텐츠를 논리적 그룹으로 분할하고 시각적으로 구분할 수 있도록 제목을 추가하세요. 이렇게 하면 사용자가 테이블에서 특정 항목을 쉽게 찾을 수 있습니다.\n\n![Image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_27.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그를 변경해주세요.\n\n- 표 태그는 유사한 글꼴 스타일을 제목과 행 제목에 사용하지 마세요. 그렇게 하면 사용자가 컨텐츠 그룹을 구별하기 어려워질 수 있습니다.\n\n![image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_28.png)\n\n## 탭 바\n\n탭 바는 앱 내에서 다른 뷰로 전환할 수 있게 해주는 전역 탐색 컨트롤입니다. 각 탭은 의미 있고 설명적이어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**최상의 방법**\n\n- \"Home\" 또는 \"Overview\"와 같은 단일 탭에 관련 없는 콘텐츠를 그룹화하는 것을 피하세요. 예를 들어, 아래 이미지는 \"Home\" 탭이 \"검색\", \"즐겨찾기\", \"친구\"와 같은 관련 없는 기능을 결합한 것을 보여줍니다. 이는 사용자가 필요한 것을 찾기 어렵게 만듭니다. 이러한 문제를 해결하기 위해 핵심 기능과 섹션을 식별하여 콘텐츠를 각각 다른 탭으로 분리하고 관련된 콘텐츠만 그룹화하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 테이블 태그를 Markdown 형식으로 변경해주세요.\n\n![Image](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_31.png)\n\n## 내비게이션 바\n\n내비게이션 바는 앱의 계층 구조를 통해 탐색할 수 있는 탐색 컨트롤입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_32.png)\n\n최상의 사용법\n\n- 네비게이션 바에 너무 많은 작업을 추가하는 것은 인터페이스를 지저분하게 만듭니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_33.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 네비게이션 바와 필터, 세그먼트 컨트롤 등과 같은 다른 요소 간에 충분한 대조가 있는지 확인합니다.\n\n![이미지](/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_34.png)\n\n# 전환\n\n전환은 한 뷰 또는 뷰 세트의 외관을 다른 것으로 변경하는 방법입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*-TfC1w0q9QTAExsVkopbGg.gif\" /\u003e\n\niOS는 일련의 표준 전환 스타일을 제공합니다. 사용자가 적응하는 데 추가 노력을 필요로 하는 것을 방지하기 위해 사용자 정의 애니메이션을 생성하려면 iOS 표준 스타일을 따르도록 확인하십시오. 그렇지 않으면 사용자 만족도가 감소할 수 있습니다.\n\n기억해야 할 권장 사항:\n\n- 사용자에게 혼란을 야기할 수 있는 복잡하거나 화려한 전환을 사용하지 마세요.\n- 일관된 지속 시간과 타임팅을 사용하여 사용자에게 부드럽고 연속적인 경험을 제공하세요.\n- 사용자의 주의를 산만하게 하는 너무 빠르거나 너무 느린 전환을 사용하지 마세요.\n- 코드 수준에서, 사용자 지정 전환은 \"모션 줄이기\"가 꺼져 있을 때 접근성 설정에 응답할 수 있도록 해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드 없이 사용자 정의 전환을 만들 수 있는 몇 가지 도구:\n\n- LottieFiles\n- ProtoPie\n- Flow\n\n# 결론\n\n이 글이 도움이 되었기를 바랍니다. 주제에 대한 피드백이나 제안이 있으면 기쁠 것입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👉 새 YouTube 채널 구독해보세요! UX/UI 디자인 통찰과 팁에 관한 영상을 만나보세요.\n\nLinkedIn에서 연락 주시거나 Twitter에서 팔로우해주세요. 감사합니다!\n","ogImage":{"url":"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png"},"coverImage":"/assets/img/2024-06-23-AcomprehensiveguideoncreatingUIdesignsforiOSapps_0.png","tag":["Tech"],"readingTime":20},{"title":"당신의 새로운 맥 설정 시 필수 3가지 필수 앱도구 ","description":"","date":"2024-06-23 23:40","slug":"2024-06-23-SettingupanewMacmytop3essentials","content":"\n![새 맥을 설정하기_2024-06-23](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_0.png)\n\n새로운 맥을 사는 것은 저에게는 섞인 감정이었습니다 — 애플 스토어에 가서 꼼꼼히 선택하고 집에 가져오는 것에서 늘 설렘이 있었지만, 그 후로는 적어도 제게는 잠정 두려움과 불안이 더해졌습니다.\n\n2015년에 내가 27인치 iMac을 산 때를 생생하게 기억합니다. 사무실 뒷쪽에 약 한 달 동안 방치되어 있었는데, 마침내 용기를 내어 개봉하고 작업에 들어갔습니다.\n\n어두운 그때, 새 맥을 설정하는 일은 따분하고 긴박한 위험을 감수해야 하는 연습이었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nApple 및 macOS는 멀리 왔습니다. 그들은 그것을 간단하고 세련된 것으로 만들었으며, 지금은 금상첨화처럼 매우 간편합니다.\n\n하지만 간단하다고는 하지만 — 여전히 선택해야 할 사항이 있습니다.\n\n![Setting up a new Mac](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_1.png)\n\n# 새로운 맥북 — 새로운 나\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nApple은 새로운 구매 제품을 설정하는 데 하나의 방법으로 기존 Mac에서 데이터를 이동하는 옵션을 제공합니다.\n\n이제 항상 그것이 유혹적으로 들리고 나는 옵션 위에 잠시나마 마우스를 올려놓곤 하는데… 그래도 나는 그것을 클릭하려는 용기를 내지 못한 적이 없습니다. Apple이 그 옵션을 빠르고 원활한 설정으로 만들었을 것이라는 것을 확신하지만, 새로운 Mac이 내 앞에 빛나는데, 나는 가능한 한 깨끗하고 혼란스럽지 않게 유지하고 싶습니다.\n\n나는 언제나 마이그레이션을 통해 앱, 데이터 및 일반적인 불필요한 소프트웨어가 함께 전송될 수 있다는 두려움을 항상 가지고 왔습니다.\n\n나는 내 Mac에 넣는 것에 대해 꽤 조심스러운 편이지만 — 나는 성질이 좋다고 말할 수 없으며 시간이 지남에 따라 혼란이 쌓일 것이라고 꽤 확신합니다. 나는 항상 새로운 Mac을 새로 시작할 수 있는 기회로 보는 편입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 모든 것의 열쇠\n\nApple의 정원에 갇힌 느낌이 든다면, 새 Mac에서 Apple ID에 로그인하는 순간에 이미 75% 정도는 끝났어요.\n\n최근 Nothing과 Bleeper에서 나온 모든 소식을 보면, 우리의 Apple ID의 중요성이 부각되었어요. 이는 Apple 생활에서 거의 모든 것의 열쇠입니다 — 비밀번호, 지갑 및 아이디일 수도 있어요. 그래서 Apple 이외의 누구와도 공유하는 것을 생각한다면 두려움에 떨게 돼요.\n\n저의 이야기를 오랜 시간 읽어온다면, 몇 달 전 해킹당할 뻔했다는 이야기를 알고 계실 거예요. 그 허니트랩에 속아 넘어졌어서 정말 바보 같았지만, 운이 좋아 무사했어요 — 하지만 소중한 교훈을 얻었죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정한 것 중 첫 번째는 즉시 Apple ID 로그인 세부 정보를 변경하는 것이었습니다. 우리 중 많은 사람들처럼 예전부터 같은 세부 정보를 계속 사용해 왔다고 의심합니다. 솔직히 이전 비밀번호는 웃기게 간단했습니다. 이제 더욱 안전한 새 비밀번호가 설정되어 있고, 가능한 한 많은 계정에서 사용하는 2단계 인증 앱을 가지고 있습니다. 결국에는 잠재적으로 나쁜 상황에서 좋은 결과가 나왔습니다.\n\n![새 Mac를 설정하는 중요한 3가지](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_2.png)\n\n하지만 iCloud 계정에 안전하게 로그인한 후에는 캘린더, 이메일, 노트, 알림, 스프레드시트 및 iMessage가 모두 설정되어 준비되어 있습니다. 그것은 그야말로 통증 없이 그리고 간단했습니다. 그 순간부터 작업을 시작할 수 있어요.\n\n# 문제를 복잡하게 만드는 것\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금 제 상황은 깔끔한 편입니다. 대체로 저는 모든 네이티브 애플 앱을 사용하는 편이라서 비밀번호 관리자를 포함한 애플 앱을 신뢰합니다. 애플에 대한 신뢰는 누구에게도 못지않고, 그들의 프라이버시 기록은 상당히 인상적입니다.\n\n그러나 제3자 비밀번호 관리자 및 캘린더 앱을 사용하고 있다면, 새로운 맥북에서 성능을 향상시킬 때 이러한 앱들이 우선 순위가 될 것입니다.\n\n'깔끔한 설치' 접근 방식이 조금 더 많은 작업을 유발할 수 있지만, 최소한 초기 몇 일, 주, 그리고 개월 동안은 해당 맥북에는 필수 도구만 설치되어 있다는 점을 알 수 있고, 네이티브 앱을 사용함으로써 macOS에 가능한 최적화되어 있는 것이 확실합니다.\n\n저에게 새로운 맥북은 지금은 다소 다르게 다가오는데, 종종 심사하면서 구매하는 경우가 많습니다. 하지만 설정하는 데 드는 고심은 변하지 않았습니다. 본질적으로 그래도 여전히 그 같은 애플 열광자인 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 새로운 M1 iMac의 경우, 이메일은 로컬에서 iCloud 이메일만 설정되어 있어요. 제가 정기적으로 사용하는 다른 두 이메일 계정은 클라우드 기반 솔루션에 의존하고 있어요. 적어도 로컬 메일함을 메꿔 버리지 않고도 어떤 일이 벌어지고 있는지 확인할 수 있어 좋아해요.\n\n새 맥을 설정할 때마다 간편하고 쉽고 빠르게 설정하는 것 같아요. 설정이 완료되면 새 맥에 설치할 필수 앱 세 가지를 선택하는 것이 결정사항인 거죠. 맥 앞에 앉은 사람에 대해 많은 얘기를 해주는 것 같아요.\n\n당신의 선택은 아마 다를 거예요. 하지만 내가 필수로 갖춰야 한다고 생각하는 것을 밝히고, 당신의 맥에서 가장 중요한 앱 3가지는 무엇인지에 대해 대화를 시작하고, 당신의 의견을 듣고 싶어요.\n\n# 1. Dropbox\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Setting up a new Mac](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_3.png)\n\n혹시 새롭게 시작한다면 — 현재처럼 Dropbox이 필요한 정도는 아마 제 목록에서 그리 높지 않았을 것 같아요.\n\n첫 iMac을 산 시점과 거의 동시에 Dropbox을 사용하기 시작했어요. 그러니까, 이 저장 서비스를 약 10년 동안 사용했고 많은 데이터를 저장했어요.\n\n저는 현재 3TB 비즈니스 요금제를 사용 중이며, 1.7TB를 사용 중입니다 — 그래서 상당히 많이 사용하는 사용자라고 할 수 있어요. 매년 $165를 지불하며, 이것은 꽤 좋은 가치라고 생각해요. 기대하건대 — 모든 그 동안에 서비스가 다운되거나 곤경에 처한 적은 없었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근 몇 년 동안 Dropbox는 훨씬 세련되어졌어요. 저는 지금 제공하는 많은 서비스를 사용하지는 않지만, 견고하고 신뢰성 있으며 가격이 합리적하고 사용하기 쉬운 클라우드 저장소로 충분히 잘 작동합니다.\n\n앞서 말한 대로, 새로 시작한다면 Dropbox을 선택하지 않을 수도 있어요. 다시 한 번 말하지만 그 이유는 Apple 때문입니다.\n\niCloud Drive는 Dropbox과 매우 유사한 방식으로 작동하며, 대신 그것을 사용하기로 결정할 수도 있을 것 같아요. Apple이 아직 따라 하지 않은 Dropbox의 Smart Sync 기능이 있어요. 처음에 발표된 그것은 정말 혁신적이었어요. 로컬로 저장하지 않고 모든 작업을 볼 수 있는 기능은 정말 대단한 발상이었죠.\n\n저는 Apple One 번들에 포함된 2TB iCloud Drive 저장 공간을 사용하고 있어요. 하지만 Apple의 업그레이드 옵션은 조금 이상해요. 저장 공간을 점진적으로 늘릴 수 없어요. 요금제는 월 £8.99로 2TB부터 시작해서 월 £26.99로 6TB로 늘어나고, 엄청난 월 £54.99로 12TB까지 늘어납니다. 모든 것이 Apple의 지원 아래에 있는 것은 마음에 들지만, 제가 바꿀 만큼의 가치가 없어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. Clean My Mac\n\n![Clean My Mac](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_4.png)\n\n이것은 분명히 애매모호한 순간이 될 것 같아요.\n\n먼저 말씀드리고 싶은 것은 제가 Clean My Mac과 재정적인 연결이 없다는 점입니다. 그들은 한 달 전에 제가 구입한 애플리케이션을 모든 Mac에서 사용한 몇 년 뒤에 동영상 중 하나를 후원해 주었었지만요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클린 마이 맥을 언급하자마자 반대하는 사람들이 나타나서 그것은 쓸데없고 도움이 안 된다고 빨리 말하지만, 난 경험 니 말이 스피크 해 보겠다.\n\n맥을 정말 좋아하는 만큼, 화면 뒤의 작동을 완전히 이해하는 데는 천재가 아니다.\n\n그래서 나와 같은 사람을 위해, 클린 마이 맥은 내 맥에서 쓰레기를 청소하고 건강하게 유지하는 데 도움이 되었던 간단한 솔루션을 제공한다. 또한 나는 그것이 언급한 해킹 시도에 어느 정도 도움이 되었다고 생각한다.\n\n## 3. 크리에이티브 클라우드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_5.png)\n\n네이티브 Apple 앱에서 작업하지 않을 때는 주로 Ulysses나 Adobe 앱 중 하나에서 작업할 것입니다.\n\nUlysses는 보통 일주일에 세 번 이상 사용합니다. 여기서 이야기를 모두 작성하고 비디오 스크립트를 작성합니다. 그러나 만약 절대적으로 필요하다면 다른 앱에서도 쓸 수 있습니다.\n\n하지만 Adobe의 경우, 창의적인 앱으로서 다른 앱에서는 재현하기 어려운 앱들이기 때문에 매일 Creative Cloud 앱 중 하나를 사용합니다. 주로 사용하는 앱은 Premiere, Photoshop, Lightroom, Audition, In Design입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nClean My Mac이랑 마찬가지로 Creative Cloud에 대해 부정적인 의견들이 종종 있습니다. 왜냐하면 이것이 구독만 가능한 서비스이기 때문이죠.\n\n여태까지 Adobe에 돈을 많이 썼다고 계산해보면 분명히 좀 찡하겠죠. 하지만 정말 괜찮습니다. 그들은 구독 방식을 가장 먼저 채택한 기업 중 하나였고, 지금은 돈이 나가는 것을 거의 느끼지 못합니다. 이를 경박하게 말하는 것이 아니라, 제게는 큰 가치가 있거든요. 4개나 5개의 앱을 사고 업데이트하는데 드는 비용도 싼 건 아니었을 테니까요!\n\n다시 말하지만, Dropbox와 유사하게, 현재 처음 시작한다면 아마도 Final Cut 및 Logic 경로(나의 애플 열렬한 팬이기도 해요!)를 시도할 수도 있을 거예요. 하지만 Adobe에서 너무 오랜 시간을 보내왔고, 그들의 앱이 어떻게 작동하는지에 대한 미묘한 세부 사항들은 다시 교육 받는 데 시간을 낭비할만큼 나이가 들었거든요.\n\n프로그램을 사용하는 것은 기본적인 작업을 할 때나 잘 동작할 때는 충분히 쉽다고 말씀드렸죠. 하지만 진짜 시험은 문제가 발생했을 때야 옵니다. 그때 당신이 소프트웨어를 알아야 하는 것이죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 지난 주 대부분을 새로운 맥 세트업 중 가장 최근에 나온 M3 iMac 작업에 할애했어요. 이 앱들은 이미 모두 설치되어 사용 중이에요.\n\n![이미지](/assets/img/2024-06-23-SettingupanewMacmytop3essentials_6.png)\n\n저는 애플이 1월에 M3 Pro 칩이 탑재된 새로운 맥 미니를 출시할 것을 기대하고 있어요. 그렇다면 다시 이제는 시험된 설정 절차를 거치게 될 거에요.\n\n새로운 맥을 실행하는 가장 빠른 방법은 아닐 수도 있지만, 에이, '문제가 생기기 전까진 손대지 말라'는 속담을 따를 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n200개가 넘는 생산성 앱을 한 곳에서 쉽게 확인해보고 싶나요? 그렇다면 SetApp을 확인해보세요. 정말 멋져요 — 매달 정액 요금을 지불하면 Bartender, CleanShot X, Paste, iStat Menus, BetterTouchTool과 같은 훌륭한 앱들 중에서 선택할 수 있어요. 만약 시도해보고 30일 무료 체험을 원한다면 제 제휴 링크를 클릭해서 살펴보세요. 어떤 앱이 가장 마음에 드는지 알려주세요.\n\n매주 일요일마다 무료 회원 비디오 뉴스레터를 발송할 예정이에요. 받아보고 싶다면 여기에 세부사항을 남겨주세요.\n\n2023년 12월 12일에 https://talkingtechandaudio.com에서 원문이 게시되었어요.\n","ogImage":{"url":"/assets/img/2024-06-23-SettingupanewMacmytop3essentials_0.png"},"coverImage":"/assets/img/2024-06-23-SettingupanewMacmytop3essentials_0.png","tag":["Tech"],"readingTime":10},{"title":"WWDC 2024 Swift의 새로운 동시성 기능 탐구","description":"","date":"2024-06-23 23:39","slug":"2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency","content":"\nSwift Concurrency는 처음 소개되었을 때부터 화제가 되었고, WWDC 2024에서 발표된 혁신적인 기술들로 더욱 발전하였습니다. Apple은 개발자들이 안전하고 효율적이며 고성능의 비동기 코드를 작성할 수 있도록 지원하고 있습니다. 이 블로그에서는 WWDC 2024에서 발표된 Swift Concurrency의 새로운 기능과 개선 사항에 대해 알아보겠습니다. 이를 통해 이러한 개념을 설명하는 코드 스니펫을 제시할 것입니다.\n\n# Swift Concurrency 소개\n\n프로그래밍에서 Concurrency는 여러 작업이 동시에 실행되는 것을 의미하며, 특히 계산이 많거나 외부 자원을 기다리는 작업을 하는 애플리케이션의 성능을 크게 향상시킬 수 있습니다. Swift Concurrency는 Swift 5.5에서 처음 소개되었으며, async/await, actors, 그리고 구조적 동시성을 도입하여 비동기 코드를 더욱 쉽고 안전하게 다룰 수 있도록 하였습니다.\n\n# Swift Concurrency의 새로운 기능 (WWDC 2024)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 1. 작업 그룹 업데이트\n\n작업 그룹을 사용하면 동시에 실행되는 작업 그룹을 생성할 수 있습니다. WWDC 2024에서의 개선 사항은 더 나은 오류 처리와 더 유연한 작업 관리를 포함하고 있습니다.\n\n## 코드 스니펫: 작업 그룹\n\n```js\nimport Foundation\nfunc fetchAllData() async throws -\u003e [Data] {\n    var results: [Data] = []\n    try await withThrowingTaskGroup(of: Data?.self) { group in\n        for url in [\"https://api.example.com/data1\", \"https://api.example.com/data2\"] {\n            group.addTask {\n                guard let url = URL(string: url) else { return nil }\n                return try? Data(contentsOf: url)\n            }\n        }\n        for try await result in group {\n            if let data = result {\n                results.append(data)\n            }\n        }\n    }\n    return results\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 여러 URL에서 동시에 데이터를 가져오기 위한 작업 그룹을 만듭니다. withThrowingTaskGroup은 이제 오류를 더 잘 처리하여 더 견고하고 오류에 강한 코드를 작성할 수 있습니다.\n\n## 2. Async Streams\n\nAsync Streams는 라이브 데이터 피드와 같은 비동기 값 시퀀스를 처리하는 과정을 간소화합니다.\n\n### 코드 조각: Async Streams\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nimport Foundation\nfunc fetchLiveUpdates() -\u003e AsyncStream\u003cString\u003e {\n    AsyncStream { continuation in\n        let timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in\n            continuation.yield(\"New update at \\(Date())\")\n        }\n\n        continuation.onTermination = { _ in\n            timer.invalidate()\n        }\n    }\n}\n\nTask {\n    for await update in fetchLiveUpdates() {\n        print(update)\n    }\n}\n```\n\n여기서 AsyncStream은 1초마다 새 값을 발행하는 라이브 업데이트 스트림을 생성하는 데 사용됩니다. continuation.onTermination 블록은 스트림이 종료될 때 타이머가 무효화되도록 합니다.\n\n# 3. 향상된 액터 모델\n\nSwift의 Actor는 동시성 환경에서 공유 가능한 가변 상태에 안전한 액세스를 보장합니다. 2024 업데이트에는 더 효율적인 데이터 액세스 패턴과 기존 Swift 코드와의 상호 운용성이 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 코드 조각: 향상된 Actor\n\n```js\nimport Foundation\n\nactor BankAccount {\n\n   private(set) var balance: Double = 0.0\n\n   func deposit(amount: Double) {\n        balance += amount\n   }\n\n   func withdraw(amount: Double) -\u003e Bool {\n        if balance \u003e= amount {\n            balance -= amount\n            return true\n        } else {\n            return false\n        }\n   }\n}\n\nlet account = BankAccount()\nTask {\n    await account.deposit(amount: 100.0)\n    let success = await account.withdraw(amount: 50.0)\n    print(\"출금 성공: \\(success), 잔액: \\(await account.balance)\")\n}\n```\n\n이 예제에서는 입금과 출금을 안전하게 처리하기 위해 BankAccount actor를 정의했습니다. await 키워드는 각 작업이 완료될 때까지 다음 작업이 시작되지 않도록 보장하여 데이터 무결성을 유지합니다.\n\n# 4. 작업 취소 개선 결과\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n작업 취소는 리소스를 관리하고 앱 반응성을 향상시키는 데 중요합니다. 최신 업데이트로 작업을 취소할 때 더 나은 제어와 예측 가능한 동작을 제공합니다.\n\n## 코드 스니펫: 작업 취소\n\n```js\nimport Foundation\n\nfunc performTask() async {\n    let task = Task {\n        for i in 1...10 {\n            if Task.isCancelled {\n                print(\"작업이 취소되었습니다\")\n                return\n            }\n            print(\"작업 실행 중: \\(i)\")\n            try await Task.sleep(nanoseconds: 1_000_000_000)\n        }\n    }\n\n    // 취소 시뮬레이션\n    await Task.sleep(nanoseconds: 3_000_000_000)\n    task.cancel()\n}\n\nTask {\n    await performTask()\n}\n```\n\n이 코드에서는 작업이 1초마다 메시지를 출력하는 루프를 실행합니다. 작업이 취소되면 (여기서 3초 뒤에 시뮬레이션됨), 취소 여부를 확인하고 정상적으로 종료됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. 향상된 오류 처리\n\nSwift Concurrency의 개선된 오류 처리 기능은 비동기 코드에서 오류를 처리하고 전파하는 더 나은 메커니즘을 제공하여 더 견고한 애플리케이션을 만들 수 있게 돕습니다.\n\n## 코드 스니펫: 향상된 오류 처리\n\n```swift\nimport Foundation\nenum DataError: Error {\n    case invalidURL\n    case requestFailed\n}\nfunc fetchData(from urlString: String) async throws -\u003e Data {\n    guard let url = URL(string: urlString) else {\n        throw DataError.invalidURL\n    }\n    do {\n        let (data, _) = try await URLSession.shared.data(from: url)\n        return data\n    } catch {\n        throw DataError.requestFailed\n    }\n}\n\nTask {\n    do {\n        let data = try await fetchData(from: \"https://api.example.com/data\")\n        print(\"Data received: \\(data)\")\n    } catch {\n        print(\"Failed to fetch data: \\(error)\")\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제는 Swift의 async/await와 함께 에러 처리 메커니즘을 사용하여 비동기 함수에서 에러를 효과적으로 처리하는 방법을 보여줍니다.\n\n# 결론\n\nWWDC 2024에서 소개된 Swift Concurrency의 개선 사항은 개발자가 효율적이고 안전한 비동기 코드를 작성하는 데 더욱 쉽게 만들어 줍니다. 작업 그룹, async 스트림, actor 모델, 작업 취소 및 에러 처리에 대한 개선 사항을 통해 Swift는 현대 애플리케이션 개발을 위한 강력한 언어로 발전하고 있습니다.\n\n이러한 새로운 기능을 프로젝트에 통합하여 더 빠르고 견고한 응용 프로그램을 만들 수 있습니다. 항상 실험을 진행하고 Swift Concurrency의 기능을 탐색하여 개발 워크플로우에서 그 강력함을 최대한 발휘해보세요. 즐거운 코딩 되세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 아래는 테이블 태그를 Markdown 형식으로 변경하였습니다.\n\n![이미지](/assets/img/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency_0.png)\n\n퀵 커넥트:\n\n[LinkedIn 프로필](https://www.linkedin.com/in/shubhransh-gupta)\n","ogImage":{"url":"/assets/img/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency_0.png"},"coverImage":"/assets/img/2024-06-23-WhatsNewinWWDC2024ExploringSwiftConcurrency_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI의 NavigationStack 사용 방법","description":"","date":"2024-06-23 23:37","slug":"2024-06-23-HowtousetheSwiftUIsNavigationStack","content":"\n![Navigation in SwiftUI](/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png)\n\nSwiftUI에서의 네비게이션은 복잡하고 동적인 사용자 인터페이스를 생성하는 강력한 도구입니다. 직관적인 구문과 강력한 기능 세트를 갖춘 SwiftUI의 네비게이션 기능을 사용하면 원활하고 매력적인 앱 경험을 구축하기 쉽습니다. 간단한 프로토 타입을 만들거나 완전한 애플리케이션을 구축하더라도 SwiftUI의 네비게이션 도구를 사용하면 완벽한 사용자 경험을 만들 수 있습니다.\n\n네비게이션은 NavigationView를 사용하여 수행되었으나, iOS 16에서 사용 중단되었으며 새로운 두 개의 컨테이너인 NavigationStack와 NavigationSplitView로 분할되었으며, 각각의 컨테이너에는 새로운 기능이 추가되었습니다.\n\nNavigationStack은 다음 네비게이션에 뷰를 설정하기 위해 사용되며, 새로운 뷰를 이전 뷰 위에 쌓아 올리고 항상 상위에 뷰를 하나 유지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNavigationSplitView은 컬럼 기반 네비게이션을 만들어야 할 때 사용됩니다. 화면이 컬럼으로 나누어지며, 각 컬럼은 NavigationSplitView의 하위 뷰 중 하나입니다.\n\n이 기사에서는 NavigationStack의 기본에 중점을 둘 것입니다.\n\n## NavigationView를 NavigationStack으로 이관하기\n\n이전에 언급한 대로, NavigationView는 두 개로 분리되었으므로 모든 구현이 이관될 수 있는 것은 아닙니다. NavigationView가 스택 네비게이션 스타일을 사용할 때에만 직접적인 이관이 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드에서 볼 수 있듯이 .stack 함수를 사용하여 NavigationView를 사용했습니다.\n\n```js\n// IOS 16 이전 (사용 중단).\nstruct ContentView: View {\n var body: some View {\n\n  NavigationView {\n   VStack {\n    NavigationLink(\"스크린 1입니다\") {\n     Text(\"스크린 1로 이동\")\n    }\n    Spacer().frame(height: 10)\n    NavigationLink(\"스크린 2입니다\") {\n     Text(\"스크린 2로 이동\")\n    }\n   }\n  }\n  .navigationViewStyle(.stack)\n }\n}\n```\n\n그래서 이 마이그레이션을 수행하려면 내비게이션 스타일 함수를 제거하고 NavigationView를 NavigationStack으로 변경하면 됩니다.\n\n```js\n// IOS 16.\nstruct ContentView: View {\n var body: some View {\n\n  NavigationStack {\n   VStack {\n    NavigationLink(\"스크린 1입니다\") {\n     Text(\"스크린 1로 이동\")\n    }\n    Spacer().frame(height: 10)\n    NavigationLink(\"스크린 2입니다\") {\n     Text(\"스크린 2로 이동\")\n    }\n   }\n  }\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# NavigationStack 새로운 기능\n\n## 값 타입을 위한 NavigationDestination\n\n새로운 네비게이션 시스템으로 코드가 더 깔끔해졌습니다. 이제는 NavigationLink 생성과 관계없이 목적지를 정의할 수 있습니다.\n\n목적지를 정의하려면 NavigationLink의 상위 뷰에 navigationDestination() 함수를 추가해야 합니다. 이 함수에는 다음과 같은 매개변수가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파라미터:\n\n- Data: 이 대상과 일치하는 데이터의 유형입니다.\n- Destination: 스택의 탐색 상태에 `data` 유형의 값이 포함된 경우 표시할 뷰를 정의하는 뷰 빌더입니다. 이 클로저는 하나의 인수를 사용하며, 그것은 표시할 데이터의 값입니다.\n\n이전에 보았듯이, 파라미터 중 하나는 대상 데이터입니다. 이 정보를 navigationDestination()에 보내기 위해 NavigationLink에 값을 추가해야 합니다. 이 매개변수는 Hashable 프로토콜을 구현한 값만 수용합니다.\n\n아래 예제에서는 각 링크마다 스크린 번호가 포함된 문자열이 NavigationLink의 값 매개변수로 전송됩니다. 그런 다음 링크 컨테이너는 navigationDestination을 구현했습니다. 이것은 문자열 유형의 어떤 값이라도 전달될 때 호출될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct ContentView: View {\n\n var body: some View {\n  NavigationStack {\n   VStack {\n    NavigationLink(\"화면 1으로 이동\", value: \"1\")\n    Spacer().frame(height: 10)\n    NavigationLink(\"화면 2로 이동\", value: \"2\")\n   }.navigationDestination(for: String.self) { value in\n    Text(\"이것은 화면 번호 \\(value)입니다\")\n   }\n  }\n }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:784/1*GwLWWM6KAWYGQmaztzbqTw.gif\" /\u003e\n\n## 불리언 상태 변수에 대한 NavigationDestination\n\n또 다른 navigation 대상을 구현하는 방법은 불리언 상태 변수를 관찰하는 것입니다. 따라서 observable state가 변경될 때마다 대상이 트리거됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예제에서는 showDetails 변수를 true로 변경하는 버튼이 있습니다. 이 변수는 navigationDestination에 의해 관찰되며, destination에는 변수를 false로 변경하는 버튼이 포함되어 있습니다. 변수가 true이면 대상 뷰가 나타나고, false이면 사라집니다.\n\n```swift\nstruct ContentView: View {\n @State private var showDetails = false\n\n var body: some View {\n  NavigationStack {\n   VStack {\n    Button(\"세부 정보 업데이트\") {\n     showDetails = true\n    }\n   }\n   .navigationDestination(isPresented: $showDetails) {\n    VStack {\n     Text(\"세부 정보가 업데이트되었습니다\")\n     Button(\"닫기\") {\n      showDetails = false\n     }\n    }\n   }\n  }\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:784/1*mN4EwmCDiECEE6Iw_rKxBg.gif)\n\n## NavigationStack 경로 매개변수\n\n이 새로운 매개변수는 iOS 16에 도입된 최고의 새로운 기능 중 하나로, 딥링크 및 다른 특정 네비게이션 경우의 쉬운 구현을 가능하게 합니다.\n\n기본적으로 이 매개변수는 우리에게 새로운 대상으로의 미리 정의된 경로를 정의하고, 경로에 쌓인 모든 화면을 추적할 수 있도록 해줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예시에서는 패스 변수를 가지고 있으며, 해당 변수는 네비게이션 스택의 경로 매개변수로 설정되어 있습니다. 이 목록의 각 항목은 프로그램 시작 시에 열리는 화면과 대응합니다.\n\n```js\nstruct ContentView: View {\n\n @State var path: [String] = [\"1\", \"2\", \"3\"]\n\n var body: some View {\n  NavigationStack(path: $path) {\n   VStack {\n    NavigationLink(\"Go to screen 4\", value: \"4\")\n   }.navigationDestination(for: String.self) { value in\n    Text(\"This is screen number \\(value)\")\n   }\n  }\n }\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:784/1*UKAZP7Xn4iBP12FsyphWng.gif)\n\n## NavigationPath\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 주제에서 NavigationStack의 변수 경로로 사용하기 위해 String 목록이 생성되었습니다. 그런데 새로운 화면이 다른 유형을 매개변수로받아야하는 경우에는 어떻게 해야하며 여전히 모든 탐색을 추적하고 싶다면 어떻게 해야합니까?\n\nApple은이 문제를 해결하기 위해 데이터의 타입을 지워버리는 NavigationPath라는 목록을 만들었습니다.\n\nNavigationPath를 사용하는 방법을 더 잘 이해하기 위해 인물 모델을 만들겠습니다. NavigationLink의 값 매개변수와 마찬가지로 경로 목록에 추가될 모든 유형은 Hashable 프로토콜을 구현해야 합니다.\n\n```js\nstruct PersonModel: Hashable {\n  let name: String\n  let age: Int\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음, 우리는 두 가지 시작 경로와 함께 문자열 유형을 가진 NavigationPath를 만듭니다.\n\n그 후에, 새 경로가 NavigationStack의 경로 매개변수로 설정되고, NavigationPath의 유형 유연성을 테스트하기 위해 두 가지 새로운 NavigationsLinks를 만들 것입니다.\n\n첫 번째 링크는 정수를 값 매개변수로 사용하고, 두 번째 링크는 생성된 person 모델을 값으로 사용합니다. 서로 다른 유형의 값을 추가한 후, 이들에 대한 특정 대상을 정의해야 합니다.\n\n```js\nstruct ContentView: View {\n\n @State var path = NavigationPath([\"1\", \"2\"])\n\n var body: some View {\n  NavigationStack(path: $path) {\n   VStack {\n    NavigationLink(\"정수 화면으로 이동\", value: 1)\n    Spacer().frame(height: 10)\n    NavigationLink(\"사람 화면으로 이동\", value: PersonModel(name: \"Mark\", age: 32))\n\n   }.navigationDestination(for: String.self) { value in\n    Text(\"이것은 값이 있는 문자열 화면입니다: \\(value)\")\n   }.navigationDestination(for: Int.self) { value in\n    Text(\"이것은 값이 있는 정수 화면입니다: \\(value)\")\n   }.navigationDestination(for: PersonModel.self) { value in\n    Text(\"이것은 값이 있는 사람 화면입니다.\\n이름: \\(value.name), 나이: \\(value.age)\")\n   }\n  }\n }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:788/1*13DNutvSEBznr-r2hmWSlQ.gif\" /\u003e\n\n# 결론\n\n여기까지 새로운 iOS 16 내비게이션 방식의 강력함을 확인했고, 이제 SwiftUI가 제공하는 네이티브 도구를 사용하여 앱의 자체 내비게이션 시스템을 쉽게 구축할 수 있게 되었습니다.\n\niOS 개발 관련 질문이 있거나 대화를 나누고 싶으시다면 언제든지 LinkedIn으로 메시지를 남겨주세요! 🙂\n","ogImage":{"url":"/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png"},"coverImage":"/assets/img/2024-06-23-HowtousetheSwiftUIsNavigationStack_0.png","tag":["Tech"],"readingTime":9},{"title":"Unowned self 개념의 문제점","description":"","date":"2024-06-23 23:36","slug":"2024-06-23-TheCaseAgainstunownedself","content":"\n![2024-06-23-TheCaseAgainstunownedself_0.png](/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png)\n\n클래스, 클로저 또는 액터를 사용할 때마다 Swift는 힙(heap)에 정보를 저장합니다. 전달하는 변수는 실제로 메모리의 주소(즉, 참조)를 가리키는 포인터입니다.\n\n옛날에는 Mac과 iOS 개발자들이 이 메모리를 수동으로 관리해야 했습니다. heap에 메모리 블록을 만들기 위해 alloc()을 사용하고 다른 참조를 추가하기 위해 retain()을 사용하며 메모리를 해제하기 위해 release()를 사용합니다.\n\n2011년, Apple은 ARC(자동 참조 카운트)를 소개했으며, 이를 통해 컴파일러가 이러한 보일러플레이트 메모리 관리 코드를 자동으로 작성하도록 하여, 축적된 개발 시간을 절약했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nARC는 다양한 종류의 참조 개념을 소개했습니다.\n\n## 강한 참조\n\n이것은 기본 참조입니다. 포인터가 사용 중일 때 가리키는 메모리를 유지합니다.\n\n강한 참조를 만드는 동안 힙 객체의 참조 카운트(또는 refCount)가 증가하고, refCount가 0이 되면 객체가 할당 해제되어 힙에 있는 메모리가 해제됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 약한 참조\n\n약한 참조는 힙 객체들이 서로를 가리키면서 유지주기 문제 없이 회피할 수 있게 해줍니다. 이를 통해 개발자들은 클로저와 델리게이트에서 클래스에 대한 참조를 생성하지만 불필요하게 객체들을 유지할 필요가 없어집니다.\n\n약한 참조는 refCount가 증가하지 않으면서 메모리의 힙 객체를 가리킵니다. 만약 refCount가 제로가 되면 객체는 해제되고 약한 참조는 nil이 됩니다— 이는 클로저에서 메모리 누수를 방지합니다.\n\n이 작동방식을 다루기 위해 약한 참조는 항상 optional로 래핑되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n// StoreViewModel.swift\n\nfunc loadStorefront() {\n    api.fetchInventory() { [weak self] inventory in\n        self?.inventory = inventory\n    }\n}\n```\n\n이 예에서 인벤토리는 네트워크를 통해 가져오며, 데이터가 도착하면 클로저 콜백이 실행됩니다. self는 약한 참조로 캡처되어 StoreViewModel의 속성이 클로저에서 업데이트될 수 있음을 의미합니다. 사용자가 화면을 나가면 뷰 모델의 강한 참조 수가 0이 되면 런타임이 뷰 모델을 해제할 수 있으므로, 콜백을 기다리는 동안 메모리에 유지되지 않고 인벤토리가 반환될 때 아무 일도 일어나지 않습니다.\n\n## Unowned references\n\n리테인 사이클을 방지하기 위해 Swift에서 세 번째 종류의 참조인 unowned가 소개되었습니다. 이는 약한 참조와 유사하게 동작하지만 참조 대상 객체의 메모리가 항상 해당 객체를 참조하는 unowned 포인터보다 오래 존속할 것으로 가정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n// StoreSingleton.swift\n\nstatic let sharedInstance = StoreSingleton()\n\nprivate init() {}\n\nfunc configureStorefront() {\n    api.fetchInventory() { [unowned self] inventory in\n        self.inventory = inventory\n    }\n}\n```\n\n여기에서 우리는 \"진정한 싱글톤\" (private init으로)을 가지고 있기 때문에 객체의 수명이 클로저보다 더 오래 지속된다는 것을 확신할 수 있습니다. 클로저 캡처 목록의 [unowned self]는 리테인 사이클이 생성되는 것을 방지합니다 (그러나 싱글톤의 경우 리테인 사이클에 대해 걱정할 필요가 실제로 없습니다).\n\n클로저는 약간 더 간단하며, unowned는 약한 참조와 비교하여 몇 가지 성능 이점을 제공합니다:\n\n- 옵셔널 체이닝이나 언래핑 작업을 사용할 필요가 없습니다.\n- unowned 참조는 힙 객체에 사이드 테이블을 만들지 않기 때문에 더 적은 메타데이터를 저장합니다.\n- 약한 참조가 가리키는 메모리에 액세스하는 경우 포인터 간의 추가 점프 또는 간접 레이어가 하나 더 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 성능이 좋다고 해도 이에는 한 가지 제약 사항이 있습니다: 만약 수명을 잘못 지정하고 클로저나 프로퍼티가 weak 참조보다 더 오래 존속된다면, 앱이 크래시할 수 있습니다.\n\n## unowned는 가치가 있을까요?\n\n당연히, 크래시는 상당히 나쁩니다. 그리고 Knuth가 종종 오인용된 것처럼 이른 최적화는 우리가 분명히 조심해야 할 유혹입니다. 그래서 성능을 약간 더 얻기 위해 unowned 참조를 마구 사용해서는 안 됩니다.\n\n제 블로그를 읽고 있다면, 아마 Swift에 대해 알고 있는 분일 것입니다. 하지만 당신의 팀원들이 모두 그렇다고 확신할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n금요일 오후 5시에 수행하는 모든 코드 리뷰가 'unowned' 키워드를 발견할 때마다 개체 소멸로 이어지는 많은 가지 코드 경로를 이해하는 데 신중하다는 것을 확신하실 수 있나요?\n\n궁극적으로, 'unowned'는 프로그래밍 문제가 아니라 인간 문제입니다.\n\n# 약한 참조의 성능 비용\n\n우리는 'unowned'의 위험을 이해합니다. 약한 참조와 비교했을 때 이점에 대해 이야기해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n성능에 관한 이야기예요.\n\n약한 참조를 옵셔널 언래핑하는 데 포함된 소수의 CPU 명령이 중요하다고 가정하지 않겠어요. 옵셔널은 사실 열거형이라는 비밀을 알고 계세요? 이 값 형식은 스택에 존재하죠. 이를 조작하는 오버헤드는 무시할 수준이에요. 왜냐하면 이들은 힙에 대한 쓰레드 안전한 잠긴 접근이 필요하지 않거든요.\n\n메모리에 대해 이야기해볼까요? 힙 객체를 약한 참조하는 것은 처음에 사이드 테이블을 만듭니다. 이는 힙 객체의 메모리 레이아웃 외부에 저장된 가벼운 메타데이터입니다. 사이드 테이블에는 힙 객체로의 포인터, 약한 참조 카운트; 그리고 정수 오버플로된 강한 참조 및 unowned 참조의 refCounts가 포함돼 있어요. unowned 참조 자체에는 사이드 테이블이 필요하지 않아요.\n\n이게 작은 비트들의 소수라는 느낌이 드시나요? 그렇게 생각하시면 맞아요. 추가 메모리량이 극히 소량이죠. 사실상 런타임은 약한 참조를 미리 nil 처리하려고 deinit에 추가 작업이 필요하지 않아요. 약한 참조가 폐기될 때까지 가벼운 사이드 테이블이 메모리에 남아 있어 힙 객체의 라이프사이클 상태를 체크해 nil 또는 객체를 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에는 약간의 오버헤드가 있습니다. 약한 참조는 이 쪽 테이블을 가리키고, 다시 이를 통해 실제 힙 객체를 가리킵니다. 이 간접 참조 때문에 약한 참조에 약간의 오버헤드가 추가되고, 비싼 CPU 캐시 미스가 발생할 위험이 있습니다.\n\n한편, 언올드 참조는 메모리의 힙 객체를 직접 가리킵니다. 간접 참조가 줄어듦에 따라 덜한 오버헤드가 발생하지만, 런타임은 여전히 힙 객체의 라이프사이클 상태를 확인해야 합니다. 따라서 객체를 반환해야 하는지, 아니면 swift_abortRetainUnowned로 크래시를 발생시켜야 하는지 알 수 있습니다.\n\n# 언올드를 사용하는 것이 합당한 경우\n\nSwift 소스를 살펴보며 약한 참조와 언올드 참조의 구현을 이해하면, 언올드를 사용하는 이점이 적고, 치명적인 오류를 발생시킬 위험 때문에 이 성능 이점이 가치가 없는 경우가 많다는 것이 분명해집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나, 컴퓨터 과학에서 모든 것은 트레이드오프에 관한 것이며, 이런 경우에는 트레이드오프가 합리적인 경우가 있습니다.\n\n- 참조(reference)가 많고 실행 시간 성능이 중요한 병목 현상이 되는 경우, 예를 들어 많은 화면 객체를 포함하는 게임 엔진을 개발하는 개발자가 있는 경우.\n- 참조(reference)의 수가 많고 메모리가 극도로 제한적해서 수 바이트를 저장하는 것이 관련이 있는 경우 — 예를 들어 코드 일부를 최적화하여 L1 CPU 캐시에 맞출 수 있는 경우.\n- 다른 기여자에 의존하지 않는 인디 개발자가, 무엇을 하는 지 정확히 알고 있으며, 프로덕션에서의 충돌 비용을 감당할 준비가 되어 있는 경우.\n\n그러나 하나의 클로저 콜백에서 [unowned self]를 사용하는 것이 몇 개의 시계 주기와 최악의 경우 몇 나노초의 캐시 미스를 위해 꽤 좋지 않은 트레이드오프라는 점에 동의해 주셨으면 합니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nARC에서 잠재 쓰레기 참조 문제를 방지하는 데 기여하는 비소유 참조(unowned references)는 런타임 성능 향상의 조각을 제공하지만 잘못 사용하면 충돌 위험이 따릅니다.\n\n매우 병목 상태인 시스템에 수많은 참조가 있는 경우 등 일부 상황에서는 사용할 만한 가치가 있지만, 단일 클로저 캡처 목록에 [unowned self]를 사용하는 것은 그중 하나가 아닙니다.\n\n[weak self]를 계속 사용하고 unowned는 예외적인 경우로 취급해 주세요. 이는 잘못 사용하면 예외를 받아들일 수 있는 경우라는 의미입니다.\n\n간단히 말해, 코드에서 unowned를 사용할 만큼 자신감이 있다면, 그냥 unowned(unsafe)를 사용하세요. 약간 더 성능적으로 우세합니다\\*.\n","ogImage":{"url":"/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png"},"coverImage":"/assets/img/2024-06-23-TheCaseAgainstunownedself_0.png","tag":["Tech"],"readingTime":8},{"title":"Swift에서 Typed 오류와 Untyped 오류 이해하기 새로운 에러 처리 방법","description":"","date":"2024-06-23 23:35","slug":"2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling","content":"\n안녕하세요, Swift 개발자 여러분! 오늘은 우리의 일상 코딩 생활에서 매우 중요한 주제에 대해 이야기를 나누고 싶어요: 에러 처리입니다. 최근 WWDC 2024에서 Apple이 Swift에서 \"타입드 에러\"라 불리는 새로운 에러 처리 방법을 소개했어요. 따라서, 우리가 언타입드와 타입드 에러가 무엇인지, 그들이 어떻게 작동하는지, 그리고 왜 사용하고 싶을지 알아보도록 하겠습니다.\n\n## 언타입드 에러: 고전적인 방식\n\n먼저, 전통적인 방식인 언타입드 에러에 대해 이야기해보겠어요. Swift에서 오랫동안 코딩을 해왔다면, 이 방법에 익숙할 것입니다. Swift에서는 일반적으로 Error 프로토콜을 사용하여 에러를 처리합니다. 이 방법을 이용하면 Error 프로토콜을 준수하는 어떤 에러든 throw할 수 있어 매우 유연합니다. 그러나 때로는 너무 유연하여 어떤 종류의 에러를 기대해야 하는지 항상 알기 어려울 수 있습니다.\n\n```js\nenum StringParseError: Error {\n    case invalidCharacter(Character, at: String.Index)\n}\n\nfunc parseNumber(from input: String) throws -\u003e Int {\n    for (index, character) in input.enumerated() {\n        guard let _ = character.wholeNumberValue else {\n            throw StringParseError.invalidCharacter(character, at: input.index(input.startIndex, offsetBy: index))\n        }\n    }\n    return Int(input) ?? 0\n}\n\ndo {\n    let number = try parseNumber(from: \"12a45\")\n} catch let error as StringParseError {\n    switch error {\n    case .invalidCharacter(let character, let index):\n        print(\"Invalid character '\\(character)' found at index \\(index).\")\n    }\n} catch {\n    print(\"An unexpected error occurred: \\(error).\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 이곳에서 무슨 일이 일어나고 있나요:\n\n- StringParseError: Error 프로토콜을 준수하는 enum입니다.\n- parseNumber(from:): 이 함수는 문자열의 각 문자를 확인합니다. 유효하지 않은 문자를 발견하면 StringParseError를 throw합니다.\n- do-catch 블록: 이는 parseNumber 함수를 호출하고 발생 가능한 오류를 catch합니다. StringParseError 및 다른 오류는 일반적으로 처리됩니다.\n\n## Typed Errors: 새로운 접근 방식\n\n자, 이제 이 새롭고 멋진 기능인 typed errors에 대해 이야기해보겠습니다. WWDC 2024에서 소개된 이 기능은 함수가 throw할 수 있는 오류의 정확한 유형을 지정할 수 있게 해줍니다. 이를 통해 오류 처리를 더 정확하고 유형 안전하게 만들어줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n열거자 ParseError: 오류 {\n    case nonNumericCharacter(Character, at: String.Index)\n}\n\nfunc parseInt(from input: String) throws(ParseError) -\u003e Int {\n    for (index, character) in input.enumerated() {\n        if character.isNumber == false {\n            throw ParseError.nonNumericCharacter(character, at: input.index(input.startIndex, offsetBy: index))\n        }\n    }\n    return Int(input) ?? 0\n}\n\ndo {\n    let value = try parseInt(from: \"123x56\")\n} catch {\n    print(\"ParseError 발생: \\(error)\")\n}\n```\n\n# 여기에서 무슨 일이 벌어지고 있나요:\n\n- parseInt(from:): 이 함수는 이제 throws(ParseError)를 사용하여 ParseError만 throw할 수 있음을 나타냅니다.\n- do-catch 블록: 정확히 어떤 유형의 오류가 발생할 수 있는지 알기 때문에 catch 블록에서 오류 유형을 지정할 필요가 없습니다.\n\n# Any 및 Never 오류 유형\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n타입 애너효메이션을 사용하면 Error 및 Never를 지원하여 더 많은 유연성을 제공합니다.\n\n```js\nfunc parseValue(from input: String) throws(any Error) -\u003e Int {\n    if input.isEmpty {\n        throw NSError(domain: \"ParseDomain\", code: 100, userInfo: [NSLocalizedDescriptionKey: \"Input string is empty.\"])\n    }\n    return Int(input) ?? 0\n}\n\nfunc parseValue(from input: String) -\u003e Int {\n    return Int(input) ?? 0\n}\n\nfunc parseValue(from input: String) throws(Never) -\u003e Int {\n    return Int(input) ?? 0\n}\n```\n\n# 이곳에서 하는 일:\n\n- throws(any Error): 함수는 Error 프로토콜을 준수하는 모든 오류를 던질 수 있습니다.\n- throws(Never): 함수는 오류를 던지지 않으며 throws 키워드가 기술적으로 필요하지만 오류를 던지지 않는다는 것을 명시적으로 나타낼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리\n\n타입별 오류를 사용하면 오류 처리가 더 명확하고 이해하기 쉬워집니다. 함수가 던질 수 있는 오류 유형을 지정함으로써 코드를 더 안전하고 유지보수하기 쉽게 만들 수 있습니다. WWDC 2024에서 소개된 이 새로운 방식은 믿을 수 있고 유지보수 가능한 응용 프로그램을 작성하는 데 도움이 됩니다.\n\n다음에 Swift 프로젝트에서 오류 처리를 작업할 때는 타입별 오류를 한 번 시도해 보세요. 이를 통해 버그를 초기에 잡을 수 있고 코드를 더 예측 가능하며 디버깅하기 쉬워질 수 있습니다.\n\n즐거운 코딩 되세요! 여러분의 Swift 프로젝트가 오류 없이 잘 진행되길 바랍니다! 이 주제를 더 깊게 파고들고 싶다면, 공식 Swift 문서를 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingTypedandUntypedErrorsinSwiftANewApproachtoErrorHandling_0.png","tag":["Tech"],"readingTime":5},{"title":"Kotlin Flows 기본 개념 이해하기","description":"","date":"2024-06-23 23:34","slug":"2024-06-23-KotlinFlowsFundamentals","content":"\n지난 주에는 Kotlin 코루틴에 대해 더 알아보았어요. 이전 글에서는 CoroutineContext, CoroutineScope, Coroutine Builder 등 코루틴의 기초 중 일부에 초점을 맞췄죠. 약속대로, 지금은 그에 대한 후속 글로 Flows에 대해 다루려고 해요.\n\n# Flows가 뭔가요?\n\n비동기로 계산할 수 있는 데이터의 스트림을 Flow라고 합니다. Flow는 LiveData와 RxJava 스트림과 같이 옵저버 패턴을 구현할 수 있게 해줍니다. 옵저버 패턴은 상태 변경이 일어날 때 해당 상태를 관찰하는 객체(소스)와 그 상태 변경을 자동으로 알리는 의존 객체들(수집자)으로 이루어진 소프트웨어 디자인 패턴입니다. Flow는 일시 중지 함수를 사용하여 값을 비동기적으로 생성하고 소비합니다.\n\nFlow를 생성하려면 먼저 프로듀서를 만들어야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nval randomFlow: Flow\u003cInt\u003e = flow {\nrepeat(10) { it -\u003e\nemit(it+1) // flow에 대한 요청 결과를 내보낸다\ndelay(1000) // 코루틴을 1초 동안 일시 중단한다\n}\n}\n\nFlow를 수집하려면 먼저 Flow가 내부적으로 코루틴에서 작동하기 때문에, Coroutine을 시작해야 합니다. collect 연산자는 emit된 값들을 수집하는 데 사용됩니다.\n\n```kotlin\nlifecycleScope.launch {\n    viewModel.uiStateFlow.collect { it -\u003e\n        binding.uiText.text = it.toString()\n    }\n}\n```\n\nFlow에는 두 가지 서로 다른 유형이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Cold Flow — 값을 수집하기 시작할 때까지 값을 생성하지 않습니다. 오직 하나의 구독자만 가질 수 있으며 데이터를 저장하지 않습니다.\n\n```js\n// Regular Flow 예시\nval coldFlow = flow {\n     emit(0)\n     emit(1)\n     emit(2)\n}\n\nlaunch { // 처음으로 collect를 호출\n    coldFlow.collect { value -\u003e\n        println(\"cold flow collector 1이 받은 값: $value\")\n    }\n\n    delay(2500)\n\n  // 두 번째로 collect를 호출\n  coldFlow.collect { value -\u003e\n        println(\"cold flow collector 2이 받은 값: $value\")\n    }\n}\n\n// 결과\n// 두 수집자는 처음부터 모든 값을 받게 됩니다.\n// 두 수집자에 대해 해당 Flow는 처음부터 시작합니다.\nflow collector 1이 받은 값: [0, 1, 2]\nflow collector 1이 받은 값: [0, 1, 2]\n```\n\n- Hot Flow — 아무도 수집하지 않아도 값을 생성합니다. 여러 구독자를 가질 수 있으며 데이터를 저장할 수 있습니다.\n\n```js\n// SharedFlow 예시\nval sharedFlow = MutableSharedFlow\u003cInt\u003e()\n\nsharedFlow.emit(0)\nsharedFlow.emit(1)\nsharedFlow.emit(2)\nsharedFlow.emit(3)\nsharedFlow.emit(4)\n\nlaunch {\n    sharedFlow.collect { value -\u003e\n        println(\"SharedFlow 수집자 1이 받은 값: $value\")\n    }\n\n    delay(2500)\n\n  // 두 번째로 collect를 호출\n  sharedFlow.collect { value -\u003e\n        println(\"SharedFlow 수집자 2이 받은 값: $value\")\n    }\n}\n\n// 결과\n// 수집자는 수집을 시작한 곳부터 값을 받습니다.\n// 여기서 1번째 수집자는 모든 값을 받게 됩니다. 하지만 2번째 수집자는\n// 2500밀리초 후에 수집을 시작했기 때문에 그 이후에 방출된 값만을 받습니다.\nSharedFlow 수집자 1이 받은 값: [0, 1, 2, 3, 4]\nSharedFlow 수집자 2이 받은 값: [2, 3, 4]\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 cold flow라도 stateIn() 및 shareIn() 연산자를 사용하여 각각 뜨거운 flow로 변환할 수 있습니다.\n\n## SharedFlow 및 StateFlow\n\n- StateFlow — StateFlow는 한 번에 하나의 값을 보유하는 상태를 나타내는 뜨거운 flow입니다. 또한 conflated flow이며, 새 값이 발행될 때 가장 최근 값이 보존되고 즉시 새 수집기에 발행됩니다. 상태에 대한 단일 진실 원천을 유지하고 모든 수집기를 자동으로 최신 상태로 업데이트해야 할 때 유용합니다. 항상 초기 값이 있으며 최신으로 발행된 값만 저장합니다.\n\n```js\nclass HomeViewModel : ViewModel() {\n\n    private val _textStateFlow = MutableStateFlow(\"Hello World\")\n    val stateFlow =_textStateFlow.asStateFlow()\n\n    fun triggerStateFlow(){\n        _textStateFlow.value=\"State flow\"\n    }\n}\n\n// Activity/Fragment에서 StateFlow 수집\nclass HomeFragment : Fragment() {\n    private val viewModel: HomeViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\nlifecycleScope.launchWhenStarted {\n\n  // Flow를 트리거하고 값 수집 시작\n\n  // collectLatest()는 Kotlin의 Flow API의 고차 함수로\n  // Flow로부터 발행된 값을 수집하고 최신 값에 대해 변환할 수 있는 함수입니다.\n  // 모든 발행된 값들을 수집하는 collect()와 유사하지만,\n  // collectLatest는 최신으로 발행된 값만 처리하고\n  // 아직 처리되지 않은 이전 값들을 무시합니다.\n    viewModel.stateFlow.collectLatest {\n          binding.stateFlowButton.text = it\n    }\n  }\n}\n\n// Compose에서 StateFlow 수집\n@Compose\nfun HomeScreen() {\n // Compose는 flow에서 값을 수집하고 사용할 최신 값을 제공하는\n // collectAsStateWithLifecycle 함수를 제공합니다.\n // 새로운 flow 값이 발행되면 업데이트된 값을 얻고,\n // 재구성을 통해 값의 상태를 업데이트합니다.\n // LifeCycle.State.Started를 기본값으로 사용하여 수집을 시작합니다.\n // 지정된 상태의 라이프사이클에 있을 때 값 수집을 시작하고,\n // 해당 상태 아래로 떨어질 때 멈춥니다.\n  val someFlow by viewModel.flow.collectAsStateWithLifecycle()\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- SharedFlow — SharedFlow는 여러 개의 수집기(collector)를 가질 수 있는 HotFlow입니다. 수집기들과 독립적으로 값을 방출할 수 있으며, 다수의 수집기들이 동일한 flow에서 값을 수집할 수 있습니다. 하나의 값을 여러 수집기에 브로드캐스팅하거나 동일한 데이터 스트림에 대해 여러 구독자를 가질 때 유용합니다. 초기값이 없으며, 새롭게 추가된 수집기들을 위해 이전에 방출된 값을 일정 수만큼 저장할 replay 캐시를 구성할 수 있습니다.\n\n```js\nclass HomeViewModel : ViewModel() {\n    private val _events = MutableSharedFlow\u003cEvent\u003e() // 비공개 mutable shared flow\n    val events = _events.asSharedFlow() // 외부에 노출된 읽기 전용 shared flow\n\n    suspend fun produceEvent(event: Event) {\n        _events.emit(event) // 모든 구독자가 받을 때까지 실행이 중단됩니다\n    }\n}\n\n// Activity/Fragment에서 StateFlow 수집\nclass HomeFragment : Fragment() {\n    private val viewModel: HomeViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        lifecycleScope.launchWhenStarted {\n\n            // 플로우를 트리거하고 값을 수신하기 시작합니다\n\n            // collectLatest()는 Kotlin의 Flow API에서 제공되는 고차 함수로,\n            // Flow에서 방출된 값을 수집하고 최신 값에 대해 변환을 수행할 수 있습니다.\n            // collect()와 유사하게 모든 방출된 값을 수집하는데 사용되지만,\n            // collectLatest는 최신 값만 처리하고 아직 처리되지 않은 이전 값들을 무시합니다.\n            viewModel.events.collectLatest {\n                binding.eventFlowButton.text = it\n            }\n        }\n    }\n}\n\n// Compose에서 StateFlow 수집\n@Compose\nfun HomeScreen() {\n    // Compose는 collectAsStateWithLifecycle 함수를 제공하며,\n    // 플로우에서 값을 수집하고 필요한 최신 값을 제공합니다.\n    // 새로운 플로우 값이 방출되면 업데이트된 값을 얻고,\n    // 값의 상태를 업데이트하기 위해 다시 조합(composition)이 발생합니다.\n    // 기본적으로 LifeCycle.State.Started를 사용하여 수집을 시작하고,\n    // 지정된 상태에 있을 때 값을 수집하며, 해당 상태보다 낮아지면 중지합니다.\n    val someFlow by viewModel.events.collectAsStateWithLifecycle()\n}\n```\n\n# 플로우에서 예외 처리\n\nKotlin Flow는 예외와 오류를 처리하기 위한 여러 메커니즘을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- try-catch 블록 — 예외를 처리하는 기본적인 방법 중 하나는 흐름 내에서 try-catch 블록을 사용하는 것입니다.\n\n```js\nflow {\n    try {\n        emit(productsService.fetchProducts())\n    } catch (e: Exception) {\n        emitError(e)\n    }\n}\n```\n\n- catch 연산자 — Flow의 catch 연산자를 사용하면 예외를 한 곳에서 오류 처리 논리를 캡슐화하여 처리할 수 있습니다.\n\n```js\nflow {\n    emit(productsService.fetchProducts())\n}.catch { e -\u003e\n    emitError(e)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- onCompletion Operator — Flow가 성공적으로 또는 예외로 완료되고 난 후 코드를 실행할 때 사용됩니다.\n\n```js\nflow {\n    emit(productsService.fetchProducts())\n}.onCompletion { cause -\u003e\n    if (cause != null) {\n        emitError(cause)\n    }\n}\n```\n\n- 사용자 정의 오류 처리 — Android의 복잡한 시나리오에서는 애플리케이션에 적합한 방식으로 오류를 처리하기 위해 사용자 정의 연산자나 확장 함수를 만들 수 있습니다.\n\n```js\nfun \u003cT\u003e Flow\u003cT\u003e.sampleErrorHandler(): Flow\u003cResult\u003cT\u003e\u003e = transform { value -\u003e\n    try {\n        emit(Result.Success(value))\n    } catch (e: Exception) {\n        emit(Result.Error(e))\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Flows vs LiveData\n\n- LiveData는 라이프사이클을 인식하므로 옵저버의 라이프사이클을 자동으로 관리하여 옵저버가 활성 상태인 경우에만 업데이트가 전달됩니다. 반면에 Flow는 기본적으로 라이프사이클을 인식하지 않습니다. Compose에서는 collectLatest() 또는 collectAsStateWithLifecycle() 함수를 사용하여 Flow로부터 결과를 수집할 수 있습니다.\n- Flow는 더 많은 유연성을 제공하며 더 복잡한 비동기 데이터 작업에 적합하며, LiveData는 일반적으로 간단한 UI 업데이트에 사용됩니다.\n- Flow는 백프레셔(backpressure)를 내장 지원하여 데이터 방출 및 처리 속도를 제어할 수 있지만, LiveData는 백프레셔 처리를 지원하지 않습니다.\n- Flow는 순차적 및 구조화된 처리를위한 다양한 연산자를 제공하며, LiveData는 옵저버에게 최신 데이터를 제공하는 데 중점을 둡니다.\n\n읽어 주셔서 감사합니다! 이 기사가 유익하고 즐거우셨기를 바랍니다. 의견은 댓글 섹션에 남겨 주세요.\n\n좋은 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-06-23-KotlinFlowsFundamentals_0.png"},"coverImage":"/assets/img/2024-06-23-KotlinFlowsFundamentals_0.png","tag":["Tech"],"readingTime":9},{"title":"샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ","description":"","date":"2024-06-23 23:32","slug":"2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ","content":"\n샤오미 폰의 가장 중요한 장점 중 하나로 높은 배터리 용량이 손꼽히죠. 그러나 가끔씩은 샤오미 폰의 배터리 소모가 예상보다 빠르게 느껴질 수도 있어요. 안드로이드 시스템이 샤오미 폰의 빠른 배터리 소모의 주요 원인일 수 있답니다.\n\n이 글에서는 핸드폰의 배터리 소모 원인을 식별하고 샤오미 폰의 빠른 배터리 소모를 고치는 방법을 설명할 거에요. 또한 샤오미 폰의 배터리 수명을 연장하는 방법에 대해서도 다뤄볼 거예요.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_0.png)\n\n## 샤오미 어플리케이션의 배터리 사용량을 확인해보세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 단계에서는 Xiaomi 폰에서 배터리가 빨리 소모되는 원인 앱을 확인해야 합니다.\n\n- Xiaomi 폰 설정으로 이동합니다.\n- 앱 목록과 배터리 사용량을 확인하려면 아래로 스크롤합니다.\n- 어떤 앱이 과도한 배터리 소모를 일으키는 경우 해당 앱의 백그라운드 활동이나 배터리 사용량을 제한할 수 있습니다. 해당 앱을 삭제하고 대신 웹 버전을 사용할 수도 있습니다.\n\n# 배터리 빠른 소모의 주된 원인인 msa 비활성화\n\n만약 Android 시스템이 배터리를 빠르게 소모하는 경우 msa를 비활성화해야 합니다. Msa는 MIUI 시스템 광고를 의미하는 MIUI 시스템 광고(MIUI System Ads)의 약자입니다. msa를 비활성화하면 더 이상 많은 MIUI 시스템 광고를 볼 수 없습니다. 이 앱이 필요하지 않으며 비활성화해도 Xiaomi 폰에 해가 되지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설정으로 이동하세요.\n- \"비밀번호 및 보안\" 섹션으로 이동하세요.\n- \"인가 및 취소\"를 탭하세요.\n- 이제 새 페이지에서 msa를 비활성화할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_1.png)\n\n# 보안 앱 업데이트 제거 방법\n\n- 기기의 설정으로 이동하세요. 앱 섹션으로 이동하세요.\n- 앱 관리 페이지를 열고 화면 상단의 세 개의 점이 모인 아이콘을 탭하세요.\n- 이제 \"모든 앱 표시\" 옵션을 선택하고 새 목록에서 보안 앱을 찾으세요.\n- 앱을 찾으면 업데이트를 제거하려면 \"업데이트 제거\"를 선택하세요. 앞으로 이 앱을 업데이트하지 않고 배터리 소모 문제를 피하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Google Play 서비스 데이터 지우기\n\n매달 다음 단계를 반복하세요:\n\n- 핸드폰 설정으로 이동하세요. 앱 섹션으로 이동하여 \"앱 관리\"를 탭합니다.\n- Google Play 서비스를 찾아 클릭합니다.\n- 화면 하단에 있는 \"데이터 지우기\" 옵션을 선택하세요.\n\n# 앱 권한 확인하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설정으로 이동하세요.\n- \"개인 정보\"로 이동한 다음 \"권한 관리자\"로 이동하세요.\n- 새 페이지에서 핸드폰의 다양한 앱의 권한을 변경할 수 있습니다. 예를 들어, 구글 맵과 같이 필수 앱 이외의 앱들이 위치 정보에 접근하는 것을 허용하지 않을 수 있습니다.\n\n# 기본 Xiaomi 앱 비활성화\n\n다운로드와 같은 기본 시스템 앱을 비활성화하려면 Google Play의 MIUI 앱에 대한 숨겨진 설정을 설치하세요. 이 앱에서 \"애플리케이션 관리\"를 탭하여 MIUI의 숨겨진 설정 페이지를 열 수 있습니다. 이 페이지에서 사용하지 않는 Xiaomi 앱을 비활성화하거나 제거할 수 있습니다. 기본 앱을 제거해도 핸드폰에 해를 끼치지 않지만, 다이얼러 및 MIUI 프레임워크와 같이 핸드폰 성능과 관련된 앱을 비활성화하면 안됩니다.\n\n# Wi-Fi 스캐닝 및 블루투스 스캐닝 끄기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샤오미 폰의 위치 설정으로 이동해주세요. 이 설정을 찾을 수 없는 경우, 제어 센터를 아래로 스와이프하여 위치 아이콘을 길게 누르세요. 그런 다음, 위치 서비스로 이동하여 Wi-Fi 스캔 및 블루투스 스캔을 해제하세요.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_2.png)\n\n# 샤오미 폰의 급속 배터리 배출을 방지하는 조치\n\n샤오미 폰은 우수한 성능과 저렴한 가격으로 유명하지만, 다른 스마트폰과 마찬가지로 배터리 소모 문제가 발생할 수 있습니다. 샤오미 폰을 계속 충전해야 하는 번거로움을 느끼신다면, 배터리 수명을 연장하는 여러 가지 방법이 있습니다. (이 부분의 절반은 AI의 도움으로 작성되었습니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다크 모드 활성화: 샤오미 핸드폰에서 다크 모드나 어두운 테마를 활성화하면 배터리 수명을 보존하는 데 도움이 됩니다. 밝은 모드보다 조명이 적게 필요하기 때문에 다크 모드가 더 적은 전력을 사용합니다.\n- 항상 켜진 디스플레이 끄기: 항상 켜진 디스플레이는 폰을 잠그고 있을 때도 중요한 정보를 화면에 표시해주는 유용한 기능이지만, 이 기능은 많은 배터리 소모를 일으킬 수 있습니다. 끄면 배터리 수명이 향상될 수 있습니다.\n- 핫스팟 끄기: 핸드폰을 핫스팟으로 사용하는 것은 편리할 수 있지만 배터리를 빨리 소모시킬 수 있습니다. 핫스팟 기능을 사용하지 않는 경우에는 꺼두는 것이 좋습니다.\n- 샤오미 위치 끄기: 이 기능을 사용하지 않는 경우도 끄기.\n- 햅틱 피드백 끄기: 화면을 터치할 때 진동이나 햅틱 피드백도 많은 배터리 소모를 일으킬 수 있습니다. 이 기능을 끄면 배터리 수명이 늘어날 수 있습니다.\n- Mi 계정 로그아웃: Mi 서비스나 앱을 사용하지 않는 경우, Mi 계정에서 로그아웃하세요. 이렇게 하면 배터리를 소모할 수 있는 백그라운드 프로세스를 줄일 수 있습니다.\n- Google Play 스토어에서 앱 업데이트: Google Play에서 앱을 업데이트하면 버그를 수정하고 성능을 개선할 수 있어 배터리 소모도 줄일 수 있습니다.\n- 안드로이드 운영 체제 업데이트: 안드로이드 OS를 최신 상태로 유지하면 핸드폰 성능과 배터리 수명을 향상시킬 수 있습니다. 최신 업데이트가 나오면 반드시 설치하세요.\n- 불필요한 앱 삭제: 사용하지 않는 앱이 백그라운드에서 실행되어 배터리를 소모할 수 있습니다. 이러한 앱들을 삭제하면 핸드폰 배터리 수명을 향상시킬 수 있습니다.\n- 배터리 절약 모드 사용하기.\n- 핸드폰을 80%까지만 충전하기: 핸드폰을 80%까지만 충전하고 플러그를 뽑으면 배터리 수명이 향상될 수 있습니다. 배터리가 30% 이하로 내려가면 다시 80%까지 충전하는 것이 좋습니다.\n- 충전 중에 핸드폰 사용 피하기: 핸드폰을 충전하면서 사용하면 발열되어 배터리에 손상을 줄 수 있습니다. 충전 중에 핸드폰 사용을 피하고 케이스를 제거하는 것이 좋습니다.\n- 샤오미 핸드폰 배터리 교정하기.\n- 공식 충전기 사용하기: 가짜 충전기는 샤오미 배터리에 심각한 손상을 줄 수 있습니다. 다른 휴대폰의 충전기나 다른 샤오미 핸드폰의 충전기를 사용하지 말아주세요.\n- 마지막에 핸드폰을 끄고 다시 켜기.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_3.png)\n\n# 샤오미 핸드폰 공장 초기화\n\n이전 방법을 시도해도 샤오미 핸드폰의 빠른 배터리 소모 문제를 해결할 수 없다면 공장 설정으로 복원할 수 있습니다. 이를 하기 전에 데이터(사진, 비디오, 노트, 메시지, 연락처 등)를 백업해두는 것이 좋습니다. 공장 초기화를 하면 모든 데이터가 지워지니 유의하세요. 아래 단계를 따라하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Xiaomi 핸드폰의 설정으로 이동하세요.\n- \"휴대폰 정보\"를 클릭하세요.\n- 먼저 \"백업 및 재설정\"을 선택한 다음 \"공장 데이터 초기화\"를 선택하세요.\n- 새 페이지의 지시에 따라 진행하세요.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_4.png)\n\n# 결론\n\n가끔 안드로이드 시스템이 Xiaomi 핸드폰의 배터리를 빠르게 소모시킬 수 있습니다. 문제를 식별하고 MSA를 비활성화하고 초기화를 수행하여 배터리 소모 속도를 줄일 수 있으며, 핸드폰을 충전한 후 좀 더 긴 사용 시간을 즐길 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 전화가 배터리가 빈다고 비어 있지 않을 때도 자주 꺼지는 등의 문제가 발생하면, 배터리 소모 문제 외에도 전화를 조사해볼 전문 기술자와 상의하는 것이 좋습니다.\n\n어떤 조언이 빠른 배터리 소모 문제를 해결하는 데 도움이 되었나요? 여러분의 경험을 공유하고 다른 사람들을 도울 수 있는 코멘트를 남겨주세요. 저는 여러 주제에 대한 전문 지식을 가진 콘텐츠 작가입니다. 저와 같은 전문가를 찾고 있다면 망설이지 마시고 LinkedIn에서 메시지를 보내주세요.\n\n# 샤오미 폰에서 발생하는 빠른 배터리 소모 문제에 대한 자주 묻는 질문\n\n샤오미 폰에서 발생하는 빠른 배터리 소모 문제와 관련하여 자주 묻는 질문이 다른 샤오미 폰 사용자와 동일할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Xiaomi 폰의 배터리가 왜 빨리 소모되나요?\n\nXiaomi 폰의 배터리가 빨리 소모되는 이유 중 하나로, 인스타그램이나 트위터와 같은 소셜 미디어 네트워크, 스파이웨어 VPN, 백그라운드 실행 앱, 그리고 Wi-Fi 및 위치 서비스의 과도한 사용이 있습니다. 배터리 설정 항목에서 배터리가 빨리 소모되는 이유를 확인할 수 있습니다.\n\n## 시스템 업데이트 후 Xiaomi 폰의 배터리가 빨리 소모되는 것이 정상인가요?\n\n시스템 업데이트로 인해 설정이 변경되고 새로운 기능이 추가될 수 있기 때문에 Xiaomi 폰 업데이트 후 배터리가 빨리 소모되는 것은 정상적인 일입니다. 이 문제는 몇 일 후에 해결될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 제 직접새본 Ziaomi 핸드폰 배터리 바꿀 수 있을까요?\n\nXiaomi 핸드폰의 배터리는 집에서 스스로 교체하지 않는 것이 좋습니다. 이렇게 하면 핸드폰에 손상을 줄 수 있습니다. Xiaomi 핸드폰인 Redmi와 Poco의 배터리 교체 작업은 전문 기술자에게 맡기는 것이 좋습니다.\n\n## 배터리 절약 모드 사용이 Xiaomi 핸드폰 성능에 영향을 미칩니까?\n\n배터리 절약 모드를 사용하여 배터리 수명을 연장하면 Xiaomi 핸드폰의 성능에 일부 영향을 줄 수도 있습니다. 그러나 대부분의 경우에는 그 영향이 크지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 배터리 절약 앱을 사용하면 Xiaomi 핸드폰에 손해가 갈까요?\n\n일부 배터리 절약 앱은 Xiaomi 핸드폰의 빠른 배터리 소모를 해결할 수 있지만, 다른 것들은 Xiaomi 배터리의 건강에 해를 줄 수도 있습니다. Google Play Store와 같은 신뢰할 만한 소스에서 유명한 앱을 사용하는 것을 권장합니다.\n\n## 다크 모드를 사용하면 Xiaomi 핸드폰의 빠른 배터리 소모를 막을 수 있을까요?\n\n전문가들은 이 질문에 대해 서로 다른 의견을 가지고 있습니다. 어둡게 설정된 색상은 더 적은 전원을 필요로 하기 때문에 일부 사람들은 다크 모드가 Xiaomi 핸드폰의 배터리 수명을 연장하는 데 도움이 될 수 있다고 합니다. 다른 사람들은 Xiaomi 핸드폰의 다크 모드에서 절전되는 양은 사용자 설정과 사용 패턴에 따라 다를 수 있다고 믿습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 제 Xiaomi 핸드폰 배터리를 교정하는 방법은 무엇인가요?\n\nXiaomi 핸드폰의 배터리를 교정할 필요는 없습니다. 핸드폰 소프트웨어가 배터리를 자동으로 교정할 수 있게 설계되어 있습니다. 그러나 배터리를 처음부터 완전히 충전하고 완전히 소진시킨 후 다시 완전히 충전하는 방법을 시도해 볼 수 있습니다.\n\n## Xiaomi 핸드폰 배터리는 얼마나 가용 시간이 있는가요?\n\nXiaomi 핸드폰의 배터리 수명은 모델, 사용 방식 및 설정에 따라 다를 수 있습니다. 그러나 대부분의 Xiaomi 핸드폰은 약 3000-5000mAh의 배터리 용량을 가지고 있으며, 중간 정도의 사용량으로 하루 동안 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 샤오미 폰에서 빠른 충전기를 사용하면 배터리 수명에 영향을 미치나요?\n\n빠른 충전기를 사용하는 것이 샤오미 폰의 배터리 수명에 반드시 영향을 미치지는 않습니다. 샤오미 폰은 빠른 충전을 지원하도록 설계되어 있으며, 충전 속도는 배터리에 손상을 예방하기 위해 최적화되어 있습니다. 그러나 폰과 호환되지 않는 서드파티 충전기나 케이블을 사용하는 경우 배터리에 손상을 줄 수 있습니다.\n\n## 샤오미 폰 홈 화면에 위젯을 많이 사용하면 배터리 소모와 관련이 있나요?\n\n네, 샤오미 폰 홈 화면에 위젯을 많이 사용하는 것은 배터리를 소모할 수 있습니다. 위젯은 CPU와 RAM과 같은 리소스를 사용하여 정보를 업데이트하고 표시하기 때문에 배터리를 빨리 소모시킬 수 있습니다. 배터리 소모를 해결하려면 필수적인 위젯만 사용하고 홈 화면에서 사용하지 않는 위젯을 제거하는 것이 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 FAQ의 내용은 AI의 도움을 받아 작성되었습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_0.png","tag":["Tech"],"readingTime":11},{"title":"Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법","description":"","date":"2024-06-23 23:29","slug":"2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose","content":"\n## 안드로이드에서 조합을 활용한 창의적인 애니메이션 구축\n\n![이미지](/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png)\n\n# 소개\n\n애니메이션은 사용자 인터페이스를 생생하고 매력적으로 만드는 힘을 지니고 있습니다. 안드로이드에서는 Jetpack Compose를 활용하여 이 힘을 직접 경험할 수 있습니다. 이러한 고급 도구를 제공함으로써 동적인 UI를 만들 수 있는 Jetpack Compose의 애니메이션에 대해 이 글에서는 기본을 넘어 더 깊게 알아보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 플루이드하고 물리학적인 움직임을 만드는 것부터 복잡한 코레오그래피 시퀀스를 만들어 인터페이스에 서사적인 품질을 더하는 기술 범위를 다룰 것입니다. 여러분이 기술을 미세하게 조정하거나 가능한 영역에 대해 궁금해하는 경우, 이 여정은 앱을 매끄럽게 작동하는 것뿐만 아니라 모든 상호작용에서 사용자를 즐겁게 만드는 실용적인 통찰력을 제공할 것입니다.\n\n자세히 알아보고 이러한 애니메이션들이 UI 디자인 접근 방식을 변화시키고 사용자에게 더 직관적이고 반응성 있으며 즐거운 경험을 제공하는 방법을 발견해 봅시다.\n\n# 섹션 1 — Jetpack Compose에서 사용자 정의 애니메이션 핸들러\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*C1_mzDHNHOfSZkIiULgRzw.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 사용자 지정 애니메이션으로 동적 상호작용 수용하기\n\n이 섹션에서는 Jetpack Compose에서 고급 사용자 지정 애니메이션 핸들러의 사용에 대해 탐구하여 동적이고 대화식 UI 요소를 만드는 방법을 살펴봅니다. 우리의 초점은 사용자 상호작용이 의미 있는 방식으로 애니메이션에 영향을 미치는 실제 예제에 있습니다.\n\n## 예제 - 대화식 게임 캐릭터 이동\n\n게임 캐릭터(얼굴 아이콘으로 표시되는)가 사용자가 드래그할 수 있는 제어 지점에 의해 결정된 경로를 따라가는 예제로 이 개념을 설명하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun GameCharacterMovement() {\n    val startPosition = Offset(100f, 100f)\n    val endPosition = Offset(250f, 400f)\n    val controlPoint = remember { mutableStateOf(Offset(200f, 300f)) }\n    val position = remember { Animatable(startPosition, Offset.VectorConverter) }\n\n    LaunchedEffect(controlPoint.value) {\n        position.animateTo(\n            targetValue = endPosition,\n            animationSpec = keyframes {\n                durationMillis = 5000\n                controlPoint.value at 2500 // 가운데 지점은 드래그 가능한 컨트롤포인트로 제어됩니다\n            }\n        )\n    }\n\n    val onControlPointChange: (offset: Offset) -\u003e Unit = {\n        controlPoint.value = it\n    }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n\n        Icon(\n            Icons.Filled.Face, contentDescription = \"로컬라이즈된 설명\", modifier = Modifier\n                .size(50.dp)\n                .offset(x = position.value.x.dp, y = position.value.y.dp)\n        )\n\n        DraggableControlPoint(controlPoint.value, onControlPointChange)\n    }\n}\n```\n\n## 설명\n\n- GameCharacterMovement 함수는 게임 캐릭터를 나타내는 아이콘을 애니메이션화합니다. 애니메이션 경로는 사용자 상호 작용에 의해 설정 및 업데이트되는 controlPoint으로 제어됩니다.\n- Animatable은 startPosition에서 endPosition으로 아이콘의 위치를 부드럽게 전환하기 위해 사용됩니다.\n- LaunchedEffect는 controlPoint 값의 변경 사항을 감지하고, 제어 지점이 이동할 때마다 애니메이션을 다시 트리거합니다.\n- animationSpec은 애니메이션의 지속 시간, 지연 및 이징을 정의하는 구성이며, 애니메이션된 값이 시간에 따라 어떻게 변하는지 결정합니다.\n- keyframes를 통해 애니메이션의 중간 지점을 제어 지점에서 최종 위치까지 정의할 수 있습니다. 중요한 역할을 하는 복잡한, 조정된 애니메이션을 만드는 데 특히 유용합니다.\n- keyframes 블록은 키프레임의 시퀀스로 애니메이션을 정의합니다. 2500 밀리초(절반 지점)에서 캐릭터가 제어 지점에 도달한 후 최종 위치로 이동합니다.\n\n```kotlin\n@Composable\nfun DraggableControlPoint(controlPoint: Offset, onControlPointChange: (Offset) -\u003e Unit) {\n    var localPosition by remember { mutableStateOf(controlPoint) }\n    Box(\n        modifier = Modifier\n            .offset {\n                IntOffset(\n                    x = localPosition.x.roundToInt() - 15,\n                    y = localPosition.y.roundToInt() - 15\n                )\n            }\n            .size(30.dp)\n            .background(Color.Red, shape = CircleShape)\n            .pointerInput(Unit) {\n                detectDragGestures(onDragEnd = {\n                    onControlPointChange(localPosition)\n                }) { _, dragAmount -\u003e\n                    // 화면 범위에 맞춰 조정\n                    val newX = (localPosition.x + dragAmount.x).coerceIn(0f, 600f)\n                    val newY = (localPosition.y + dragAmount.y).coerceIn(0f, 600f)\n                    localPosition = Offset(newX, newY)\n                }\n            }\n    )\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설명\n\n- DraggableControlPoint는 사용자가 제어 지점의 위치를 인터랙티브하게 변경할 수 있게 하는 컴포저블입니다.\n- 제어 지점을 드래그하면 localPosition이 업데이트되고, 이후 드래그 제스처가 완료될 때 (onDragEnd) 이를 GameCharacterMovement에 반영합니다. 이 상호 작용은 애니메이션된 아이콘의 경로를 변경합니다.\n\n## 실제 사용 사례\n\n- 상호 작용적인 교육 앱: 교육 앱에서는 애니메이션을 통해 학습을 더 매료적으로 만들 수 있습니다. 예를 들어, 천문학 앱에서 행성을 따라 원거리를 끌어서 다양한 별자리를 볼 수 있습니다.\n- 상호 작용적인 이야기 전달과 게임: 디지털 이야기 전달이나 게임 앱에서 사용자가 드래그 가능한 요소를 통해 이야기나 게임 환경에 영향을 미칠 수 있도록 하는 것은 더 몰입적인 경험을 만들어냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 섹션 2 — Jetpack Compose에서 복잡한 애니메이션 조정하기\n\n## 조화로운 효과를 위한 여러 요소의 동기화\n\n이 섹션에서는 Jetpack Compose에서 복잡한 애니메이션을 조율하는 기술에 대해 다룹니다. 여러 요소가 매끄럽게 상호작용하는 동기화된 애니메이션을 만드는 데 초점을 맞춰 전체 사용자 경험을 향상시킵니다.\n\n## A) 연쇄 반응 애니메이션 — 도미노 효과\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![domino effect](https://miro.medium.com/v2/resize:fit:1400/1*iNeJJU3ixcdcZnQFHHSWYw.gif)\n\nUI에서 도미노 효과를 만드는 방법은 하나의 애니메이션이 완료되면 다음 애니메이션을 시작하도록 설정하는 일련의 애니메이션을 만들어내면 됩니다.\n\n```kotlin\n@Composable\nfun DominoEffect() {\n    val animatedValues = List(6) { remember { Animatable(0f) } }\n\n    LaunchedEffect(Unit) {\n        animatedValues.forEachIndexed { index, animate -\u003e\n            animate.animateTo(\n                targetValue = 1f,\n                animationSpec = tween(durationMillis = 1000, delayMillis = index * 100)\n            )\n        }\n    }\n\n    Box (modifier = Modifier.fillMaxSize()){\n      animatedValues.forEachIndexed { index, value -\u003e\n        Box(\n            modifier = Modifier\n                .size(50.dp)\n                .offset(x = ((index+1) * 50).dp, y = ((index+1) * 30).dp)\n                .background(getRandomColor(index).copy(alpha = value.value))\n        )\n      }\n    }\n}\n\nfun getRandomColor(seed: Int): Color {\n    val random = Random(seed = seed).nextInt(256)\n    return Color(random, random, random)\n}\n```\n\n## 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- animatedValues는 상자의 불투명도를 제어하는 Animatable 값 목록입니다.\n- LaunchedEffect는 이러한 값들에 대한 일련의 애니메이션을 트리거하여 각 상자가 이전 상자 뒤에 나타나는 비슷한 도미노가 넘어지는 효과를 만듭니다.\n- getRandomColor 함수는 각 상자에 대해 무작위 회색을 생성하여 시퀀스의 각 구성 요소에 고유한 시각적 요소를 추가합니다.\n- 상자들은 화면 대각선상에 배치되어 도미노 효과를 더욱 부각시킵니다.\n\n## B) 대화식 스크롤 가능한 타임라인\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Kk-V0g5pEqy83NajRy_6lA.gif)\n\n이 타임라인에서 사용자가 타임라인을 스크롤하면 각 요소가 서서히 나타나고 위치로 이동합니다. 스크롤 가능한 목록에는 LazyColumn을 사용하고 애니메이션에는 Animatable을 사용할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun InteractiveTimeline(timelineItems: List\u003cString\u003e) {\n    val scrollState = rememberLazyListState()\n\n    LazyColumn(state = scrollState) {\n        itemsIndexed(timelineItems) { index, item -\u003e\n            val animatableAlpha = remember { Animatable(0f) }\n            val isVisible = remember {\n                derivedStateOf {\n                    scrollState.firstVisibleItemIndex \u003c= index\n                }\n            }\n\n            LaunchedEffect(isVisible.value) {\n                if (isVisible.value) {\n                    animatableAlpha.animateTo(\n                        1f, animationSpec = tween(durationMillis = 1000)\n                    )\n                }\n            }\n\n            TimelineItem(\n                text = item,\n                alpha = animatableAlpha.value,\n            )\n        }\n    }\n}\n\n@Composable\nfun TimelineItem(text: String, alpha: Float) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(Color.DarkGray.copy(alpha = alpha))\n            .padding(16.dp),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Text(\n            text = text,\n            color = Color.White,\n            modifier = Modifier.fillMaxWidth(),\n            textAlign = TextAlign.Center,\n            fontSize = 18.sp,\n            fontWeight = FontWeight.SemiBold\n        )\n    }\n}\n```\n\n## 설명\n\n- animatableAlpha은 각 타임라인 아이템의 투명도 (투명도)를 제어하며, 초기에 0 (완전히 투명)로 설정됩니다.\n- isVisible 상태는 현재 스크롤 위치에서 파생되어 항목이 표시될지 여부를 결정합니다.\n- 사용자가 스크롤하면 LaunchedEffect가 뷰포트에 들어오는 항목에 대한 페이드인 애니메이션을 트리거합니다.\n\n## 사용 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 상호작용형 타임라인은 사용자에게 시각적으로 매력적인 방식으로 일련의 이벤트나 단계를 제시하고 싶은 응용 프로그램에 이상적입니다. 애니메이션은 항목이 나타날 때 주목을 끌어 사용자 참여도를 높입니다.\n\n# 섹션 3 — 젯팩 콤포즈에서 현실감 있는 물리 기반 애니메이션\n\n![애니메이션 이미지](https://miro.medium.com/v2/resize:fit:1400/1*lZ_rpGorcFzewpUJN6WPAQ.gif)\n\n## UI 다이내믹스 향상을 위한 물리학 활용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 물리학 원리를 Jetpack Compose와 통합하여 UI에 현실성과 상호 작용성을 더하는 방법을 살펴보겠습니다. 탄탄한 드래그 상호 작용 예시에 초점을 맞출 것입니다.\n\n## 드래그 시 탄탄한 효과\n\n이 예시에서는 아이콘에 탄탄한 드래그 상호 작용을 보여줍니다. 수직으로 드래그할 때 아이콘이 늘어나고 탄탄한 효과로 튕기며, 스프링이나 고무줄의 행동을 모방합니다.\n\n```js\n@Composable\nfun ElasticDraggableBox() {\n    var animatableOffset by remember { mutableStateOf(Animatable(0f)) }\n\n    Box(modifier = Modifier.fillMaxSize().background(Color(0xFFFFA732)), contentAlignment = Alignment.Center) {\n        Box(\n            modifier = Modifier\n                .offset(y = animatableOffset.value.dp)\n                .draggable(\n                    orientation = Orientation.Vertical,\n                    state = rememberDraggableState { delta -\u003e\n                        animatableOffset = Animatable(animatableOffset.value + delta)\n                    },\n                    onDragStopped = {\n                        animatableOffset.animateTo(0f, animationSpec = spring())\n                    }\n                )\n                .size(350.dp),\n            contentAlignment = Alignment.Center\n        ) {\n            Icon(\n                Icons.Filled.Favorite,\n                contentDescription = \"heart\",\n                modifier = Modifier.size(animatableOffset.value.dp + 150.dp),\n                tint = Color.Red\n            )\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설명\n\n- 드래그할 수 있는 modifier를 사용하여 아이콘을 포함하는 Box Composable을 만듭니다.\n- animatableOffset은 드래깅으로 인한 아이콘의 수직 오프셋을 추적합니다.\n- 드래그하는 동안 아이콘의 크기가 드래그 양에 따라 변경되어 스트레칭 효과를 만듭니다.\n- 드래그가 멈추면 (onDragStopped), animatableOffset을 스프링 애니메이션을 사용하여 0f로 다시 애니메이션화하여 아이콘이 원래 크기와 위치로 되돌아가도록 합니다.\n\n# 섹션 4 — 제스처 기반 애니메이션(Jetpack Compose에서)\n\n## 사용자 경험을 향상시키는 반응형 제스처들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 사용자 동작으로 제어되는 애니메이션을 생성하는 데 Jetpack Compose를 사용하는 방법을 살펴봅니다. 두 가지 예제에 중점을 두겠습니다 - 멀티터치로 변환 가능한 이미지 및 제스처로 제어되는 오디오 파형입니다.\n\n## A) 멀티 터치로 변환 가능한 이미지\n\n이 예제에서는 사용자가 핀치, 줌 및 회전과 같은 멀티터치 제스처를 사용하여 상호 작용할 수 있는 이미지 뷰를 생성합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*34WxcBivTWhiCY6KVSVelQ.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun TransformableImage(imageId: Int = R.drawable.android) {\n    var scale by remember { mutableStateOf(1f) }\n    var rotation by remember { mutableStateOf(0f) }\n    var offset by remember { mutableStateOf(Offset.Zero) }\n\n    Box(modifier = Modifier.fillMaxSize().background(Color.DarkGray), contentAlignment = Alignment.Center) {\n        Image(\n            painter = painterResource(id = imageId),\n            contentDescription = \"Transformable image\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier\n                .size(300.dp)\n                .graphicsLayer(\n                    scaleX = scale,\n                    scaleY = scale,\n                    rotationZ = rotation,\n                    translationX = offset.x,\n                    translationY = offset.y\n                )\n                .pointerInput(Unit) {\n                    detectTransformGestures { _, pan, zoom, rotate -\u003e\n                        scale *= zoom\n                        rotation += rotate\n                        offset += pan\n                    }\n                }\n        )\n    }\n}\n```\n\n## 설명\n\n- 이미지 컴포저블은 scale, rotation, translation과 같은 변환을 적용하기 위해 graphicsLayer로 수정되었습니다.\n- detectTransformGestures가 사용되는 pointerInput은 멀티 터치 제스처를 처리하고, scale, rotation, offset을 해당 값을 따라 업데이트합니다.\n\n## B) 제스처 컨트롤 웨이브폼\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자 제스처(스와이프 및 핀치)에 따라 와브폼 시각화가 모양을 바꿉니다. 이를 통해 진폭 및 주파수와 같은 요소를 제어할 수 있습니다.\n\n![waveform visualization](https://miro.medium.com/v2/resize:fit:1400/1*qKzb1XpUrSGKdCL-OxhtLw.gif)\n\n```js\n@Composable\nfun GestureControlledWaveform() {\n    var amplitude by remember { mutableStateOf(100f) }\n    var frequency by remember { mutableStateOf(1f) }\n\n    Canvas(modifier = Modifier\n        .fillMaxSize()\n        .pointerInput(Unit) {\n            detectDragGestures { _, dragAmount -\u003e\n                amplitude += dragAmount.y\n                frequency += dragAmount.x / 500f\n                // 드래그에 기반한 주파수 조정\n            }\n        }\n        .background(\n            Brush.verticalGradient(\n                colors = listOf(Color(0xFF003366), Color.White, Color(0xFF66B2FF))\n            )\n        )) {\n        val width = size.width\n        val height = size.height\n        val path = Path()\n\n        val halfHeight = height / 2\n        val waveLength = width / frequency\n\n        path.moveTo(0f, halfHeight)\n\n        for (x in 0 until width.toInt()) {\n            val theta = (2.0 * Math.PI * x / waveLength).toFloat()\n            val y = halfHeight + amplitude * sin(theta.toDouble()).toFloat()\n            path.lineTo(x.toFloat(), y)\n        }\n\n        val gradient = Brush.horizontalGradient(\n            colors = listOf(Color.Blue, Color.Cyan, Color.Magenta)\n        )\n\n        drawPath(\n            path = path,\n            brush = gradient\n        )\n    }\n}\n```\n\n## 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 진폭과 주파수는 각각 웨이브폼의 진폭과 주파수를 제어하는 상태 변수입니다.\n- Canvas composable은 웨이브폼을 그리는데 사용됩니다. Canvas 내부의 그리기 로직은 사인 함수에 기반하여 각 X 위치에 대한 Y 위치를 계산하여 파동 효과를 만듭니다.\n- detectDragGestures 수정자는 사용자의 드래그 제스처에 기반하여 진폭과 주파수를 업데이트하는데 사용됩니다. 가로 드래그는 주파수를 조절하고, 세로 드래그는 진폭을 조절합니다.\n- 사용자가 화면을 가로지르면, 웨이브폼의 형태가 그에 따라 변경되어 상호 작용하는 경험을 제공합니다.\n\n## 참고\n\n- 이것은 기본 구현입니다. 보다 현실적인 오디오 웨이브폼을 만들려면 실제 오디오 데이터를 통합해야 합니다.\n- 제스처에 대한 웨이브폼의 반응은 드래그하는 동안 진폭과 주파수가 어떻게 수정되는지 조정하여 미세 조정할 수 있습니다.\n\n이 예제는 Compose에서 기본 대화형 웨이브폼을 만드는 방법을 보여주며, 더 복잡한 사용 사례에 확장하거나 수정하여 더 복잡한 제스처를 처리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 섹션 5 — Jetpack Compose에서 상태 주도 애니메이션 패턴\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*nkfhmC6JjQnshL3y_izhKg.gif)\n\n## 데이터 및 상태 변경에 따른 UI 애니메이션\n\n이 섹션은 데이터 또는 UI 상태 변경으로 구동되는 애니메이션을 생성하는 데 초점을 맞추어 앱의 상호 작용성과 반응성을 향상시킵니다. 우리는 데이터 그래프를 애니메이션화하고 다중 상태 UI에서 상태 전이를 구현하는 두 가지 구체적인 예시를 살펴볼 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## A) 데이터 기반 그래프 애니메이션\n\n이 예시는 데이터 세트의 변화에 반응하여 그래프의 경로가 애니메이션되는 라인 그래프를 보여줍니다.\n\n```js\n@Composable\nfun AnimatedGraphExample() {\n    var dataPoints by remember { mutableStateOf(generateRandomDataPoints(5)) }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(Color.DarkGray)\n    ) {\n        AnimatedLineGraph(dataPoints = dataPoints)\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Button(\n            onClick = {\n                dataPoints = generateRandomDataPoints(5)\n            },\n            modifier = Modifier.align(Alignment.CenterHorizontally),\n            colors = ButtonDefaults.buttonColors(containerColor = Color.Green)\n        ) {\n            Text(\n                \"데이터 업데이트\",\n                fontWeight = FontWeight.Bold,\n                color = Color.DarkGray,\n                fontSize = 18.sp\n            )\n        }\n    }\n}\n\n@Composable\nfun AnimatedLineGraph(dataPoints: List\u003cFloat\u003e) {\n    val animatableDataPoints = remember { dataPoints.map { Animatable(it) } }\n    val path = remember { Path() }\n\n    LaunchedEffect(dataPoints) {\n        animatableDataPoints.forEachIndexed { index, animatable -\u003e\n            animatable.animateTo(dataPoints[index], animationSpec = TweenSpec(durationMillis = 500))\n        }\n    }\n\n    Canvas(\n        modifier = Modifier\n            .fillMaxWidth()\n            .height(400.dp)\n    ) {\n        path.reset()\n        animatableDataPoints.forEachIndexed { index, animatable -\u003e\n            val x = (size.width / (dataPoints.size - 1)) * index\n            val y = size.height - (animatable.value * size.height)\n            if (index == 0) path.moveTo(x, y) else path.lineTo(x, y)\n        }\n        drawPath(path, Color.Green, style = Stroke(5f))\n    }\n}\n\nfun generateRandomDataPoints(size: Int): List\u003cFloat\u003e {\n    return List(size) { Random.nextFloat() }\n}\n```\n\n## 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- AnimatedGraphExample composable은 라인 그래프의 데이터 포인트를 업데이트할 수 있는 환경을 생성합니다.\n- 그래프는 Canvas 내에서 그려지며 drawPath 메서드는 animatableDataPoints에서 애니메이션 값을 사용합니다.\n- 그래프의 각 데이터 포인트에 대해 캔버스 상에서 해당 x (수평) 및 y (수직) 위치를 계산해야 합니다.\n- x 계산 — x 위치는 데이터 포인트의 인덱스와 캔버스의 총 너비에 기반하여 계산됩니다. 데이터 포인트를 캔버스 너비를 따라 균일하게 분산합니다.\n\n```js\nval x = (size.width / (dataPoints.size - 1)) * index\n```\n\n- y 계산 — y 위치는 데이터 포인트의 값 (animatable.value) 및 캔버스의 높이에 기반하여 계산됩니다.\n\n```js\nval y = size.height - (animatable.value * size.height)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 경로는 첫 번째 데이터 포인트에서 시작하여 lineTo를 사용하여 각 후속 포인트로 선을 그려 그래프 선을 생성합니다.\n- 경로는 데이터 포인트의 애니메이션 값에 기반하여 그려지며, 데이터가 변경될 때 애니메이션 효과를 만듭니다.\n\n## B) 다중 상태 UI에서 상태 전환\n\n다중 상태 UI에서 상태 전환을 구현하는 방법은 Animatable을 사용하여 다른 UI 상태 간에 애니메이션을 적용하는 것입니다.\n\n```js\nenum class UIState { StateA, StateB, StateC }\n\n@Composable\nfun StateTransitionUI() {\n    var currentState by remember { mutableStateOf(UIState.StateA) }\n\n    Box(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(getBackgroundColorForState(currentState)),\n        contentAlignment = Alignment.Center\n    ) {\n        AnimatedContent(currentState = currentState)\n\n        Button(\n            onClick = { currentState = getNextState(currentState) },\n            modifier = Modifier.align(Alignment.BottomCenter)\n        ) {\n            Text(\"다음 상태\")\n        }\n    }\n}\n\n@Composable\nfun AnimatedContent(currentState: UIState) {\n    AnimatedVisibility(\n        visible = currentState == UIState.StateA,\n        enter = fadeIn(animationSpec = tween(durationMillis = 2000)) + expandVertically(),\n        exit = fadeOut(animationSpec = tween(durationMillis = 2000)) + shrinkVertically()\n    ) {\n        Text(\"현재 상태는 ${currentState.name} 입니다\", fontSize = 32.sp)\n    }\n\n    // B와 C에 대한 유사한 블록\n\n}\n\nfun getBackgroundColorForState(state: UIState): Color {\n    return when (state) {\n        UIState.StateA -\u003e Color.Red\n        UIState.StateB -\u003e Color.Green\n        UIState.StateC -\u003e Color.Blue\n    }\n}\n\nfun getNextState(currentState: UIState): UIState {\n    return when (currentState) {\n        UIState.StateA -\u003e UIState.StateB\n        UIState.StateB -\u003e UIState.StateC\n        UIState.StateC -\u003e UIState.StateA\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설명\n\n- 이 예시에서 AnimatedVisibility는 각 상태의 콘텐츠가 나타나고 사라질 때 애니메이션 효과를 적용하는 데 사용됩니다. 이는 상태가 변경될 때 부드러운 전환 효과를 추가합니다.\n- 각 상태(StateA, StateB, StateC)마다 해당 콘텐츠의 가시성을 페이드 및 확장/축소 애니메이션으로 제어하는 AnimatedVisibility 블록이 있습니다.\n- AnimatedVisibility의 enter 및 exit 매개변수는 콘텐츠가 표시되거나 숨겨질 때의 애니메이션을 정의합니다.\n\n# 섹션 6 — Compose에서 모양 변환\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*q82EIocVzR8XBMuG_14mdg.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도형 간 변환 애니메이션은 이러한 도형의 속성을 보간하는 것을 포함합니다.\n\n```js\n@Composable\nfun ShapeMorphingAnimation() {\n    val animationProgress = remember { Animatable(0f) }\n\n    LaunchedEffect(Unit) {\n        animationProgress.animateTo(\n            targetValue = 1f,\n            animationSpec = infiniteRepeatable(\n                animation = tween(2000, easing = LinearOutSlowInEasing),\n                repeatMode = RepeatMode.Reverse\n            )\n        )\n    }\n\n    Canvas(modifier = Modifier.padding(40.dp).fillMaxSize()) {\n        val sizeValue = size.width.coerceAtMost(size.height) / 2\n        val squareRect = Rect(center = center, sizeValue)\n\n        val morphedPath = interpolateShapes(progress = animationProgress.value, squareRect = squareRect)\n        drawPath(morphedPath, color = Color.Blue, style = Fill)\n    }\n}\n\nfun interpolateShapes(progress: Float, squareRect: Rect): Path {\n    val path = Path()\n\n    val cornerRadius = CornerRadius(\n        x = lerp(start = squareRect.width / 2, stop = 0f, fraction = progress),\n        y = lerp(start = squareRect.height / 2, stop = 0f, fraction = progress)\n    )\n\n    path.addRoundRect(\n        roundRect = RoundRect(rect = squareRect, cornerRadius = cornerRadius)\n    )\n\n    return path\n}\n\nfun lerp(start: Float, stop: Float, fraction: Float): Float {\n    return (1 - fraction) * start + fraction * stop\n}\n```\n\n## 설명\n\n- ShapeMorphingAnimation은 animationProgress 값을 0과 1 사이로 토글하는 무한 애니메이션을 설정합니다.\n- Canvas 콤포저블을 사용하여 도형을 그립니다. 여기서 캔버스 크기에 기반하여 정사각형의 크기(squareRect)를 정의합니다.\n- interpolateShapes는 현재 애니메이션 진행도와 정사각형 사각형을 가져와 원과 정사각형 사이를 보간합니다. 변형되는 모양을 나타내는 둥근 직사각형의 cornerRadius를 서서히 조절하기 위해 lerp(선형 보간)를 사용합니다.\n- 진행도가 0일 때 cornerRadius는 직사각형의 반만큼이므로 도형은 원이 됩니다. 진행도가 1일 때 cornerRadius는 0이 되어 도형이 정사각형이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 실제 사용 사례\n\n- 로딩 및 진행 상태 표시기 — 모프 형태는 더 매력적인 로딩 또는 진행 상태 표시기를 만드는 데 사용될 수 있습니다. 진행 상태나 로딩 상태를 나타내는 더욱 시각적으로 흥미로운 방법을 제공합니다.\n- UI 내 아이콘 전환 — 모프 아이콘은 사용자 작업에 대한 시각적 피드백을 제공하는 데 사용할 수 있습니다. 예를 들어, 클릭할 때 플레이 버튼이 일시 중지 버튼으로 변하는 경우 또는 햄버거 메뉴 아이콘이 뒤로 이동하는 화살표로 변하는 경우 등.\n- 데이터 시각화 — 복잡한 데이터 시각화에서 모프는 사용자가 시간에 따른 변경 또는 범주 간의 변화를 따라가고 이해하기 쉽도록 돕는 데 도움이 될 수 있습니다.\n\n# 눈 오는 소리 좀?\n\n간단한 입자 시스템을 사용하여 눈이 내리는 효과를 만들어보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경합니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*E26GhhxDZLGTpE8gMvJoHw.gif\" /\u003e\n\n```js\ndata class Snowflake(\n    var x: Float,\n    var y: Float,\n    var radius: Float,\n    var speed: Float\n)\n\n@Composable\nfun SnowfallEffect() {\n    val snowflakes = remember { List(100) { generateRandomSnowflake() } }\n    val infiniteTransition = rememberInfiniteTransition(label = \"\")\n\n    val offsetY by infiniteTransition.animateFloat(\n        initialValue = 0f,\n        targetValue = 1000f,\n        animationSpec = infiniteRepeatable(\n            animation = tween(durationMillis = 5000, easing = LinearEasing),\n            repeatMode = RepeatMode.Restart\n        ), label = \"\"\n    )\n\n    Canvas(modifier = Modifier.fillMaxSize().background(Color.Black)) {\n        snowflakes.forEach { snowflake -\u003e\n            drawSnowflake(snowflake, offsetY % size.height)\n        }\n    }\n}\n\nfun generateRandomSnowflake(): Snowflake {\n    return Snowflake(\n        x = Random.nextFloat(),\n        y = Random.nextFloat() * 1000f,\n        radius = Random.nextFloat() * 2f + 2f, // Snowflake size\n        speed = Random.nextFloat() * 1.2f + 1f  // Falling speed\n    )\n}\n\nfun DrawScope.drawSnowflake(snowflake: Snowflake, offsetY: Float) {\n    val newY = (snowflake.y + offsetY * snowflake.speed) % size.height\n    drawCircle(Color.White, radius = snowflake.radius, center = Offset(snowflake.x * size.width, newY))\n}\n```\n\n## 설명\n\n- SnowfallEffect는 여러 개의 눈송이(Snowflake 객체)를 가진 입자 시스템을 설정합니다.\n- 각 Snowflake는 위치 (x, y), 반지름 (크기), 속도와 같은 속성을 갖습니다.\n- rememberInfiniteTransition 및 animateFloat은 눈이 내리는 것을 시뮬레이션하기 위한 연속적인 수직 이동 효과를 생성하는 데 사용됩니다.\n- Canvas composable은 각 눈송이를 그리는 데 사용됩니다. drawSnowflake 함수는 속도와 애니메이션된 offsetY에 기반하여 각 눈송이의 새 위치를 계산합니다.\n- 눈송이들은 아래로 떨어진 후 다시 위로 나타나며, 반복되는 눈내림 효과를 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n제트팩 구성에서 애니메이션을 탐색하면서 마무리하는 시점에서, 애니메이션이 시각적 장식 이상의 중요한 도구라는 것이 분명해졌습니다. 애니메이션은 매력적이고 직관적이며 즐거운 사용자 경험을 만드는 데 중요한 도구입니다.\n\n## 상호 작용 포용\n\n게임 캐릭터의 동적인 움직임부터 인터랙티브 타임라인까지, 우리는 애니메이션이 사용자 상호작용을 더 매력적이고 유익하게 만들 수 있는 방법을 알아보았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 현실적인 경험 구현하기\n\n눈 내리는 효과와 형태 변화는 이 도구상자가 디지털 영역에 현실감과 유동성을 표현하는 능력을 보여줍니다. 이러한 애니메이션들은 사용자와 공감을 형성하는 몰입형 경험을 만들어줍니다.\n\n## 복잡함을 간단하게 만들기\n\n여러 요소를 조정하거나 상태 전환을 애니메이션화하는 경우, 이것이 할 수 있는 간단함이 돋보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리 인사\n\n만약 읽은 것이 마음에 들었다면, 소중한 피드백이나 감사의 말을 자유롭게 남겨주세요. 저는 항상 개발자 친구들과 함께 배우고 협력하며 성장하고자 노력하고 있습니다.\n\n질문이 있으시다면 언제든지 메시지를 보내주세요!\n\n더 많은 기사를 보시려면 저의 Medium 프로필을 팔로우해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinkedIn과 트위터에서 저와 연결해주세요. 협업 기회가 있을지도 몰라요.\n\n애니메이션 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png","tag":["Tech"],"readingTime":30},{"title":"Callback 대신 Coroutine 사용하는 방법","description":"","date":"2024-06-23 23:28","slug":"2024-06-23-HowtouseaCoroutineinsteadofCallback","content":"\n콜백을 코루틴으로 대체하는 것은 비동기 작업을 처리하기 위해 콜백을 사용하는 코드를 코루틴 기반 코드로 변환하는 것을 의미합니다. 이렇게하면 코드가 더 읽기 쉽고 유지 관리하기 쉬워집니다. Kotlin에서 코루틴은 복잡한 콜백 체인 없이 비동기 작업을 처리할 수 있습니다.\n\n아래는 콜백 기반 접근 방식을 코루틴으로 대체하는 방법입니다:\n\n콜백 수신을 위한 인터페이스:\n\n```js\ninterface Callback\u003cT\u003e {\n    fun onSuccess(response: T)\n    fun onFailure(e: Throwable)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상화 계층 추가를 위한 서비스 인터페이스:\n\n```kotlin\ninterface FruitService {\n    fun fetchFruits(callback: Callback\u003cList\u003cString\u003e\u003e)\n}\n```\n\n과일 목록을 가져오는 데이터 소스:\n\n```kotlin\nclass FruitsDataSource : FruitService {\n    override fun fetchFruits(callback: Callback\u003cList\u003cString\u003e\u003e) {\n        Thread {\n            try {\n                Thread.sleep(1000) // API 호출을 시뮬레이션하기 위한 지연\n                callback.onSuccess(fruits)\n            } catch (e: Exception) {\n                callback.onFailure(e)\n            }\n        }.apply {\n            start()\n            join()\n        }\n    }\n\n    private companion object {\n        val fruits = listOf(\n            \"사과\",\n            \"망고\",\n            \"체리\",\n            \"바나나\",\n            \"레몬\",\n            \"수박\",\n            \"달콤한 라임\",\n            \"오렌지\",\n            \"키위\"\n        )\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI 호출을 하는 저장소:\n\n```js\nclass FruitsRepository(\n    fruitService: FruitService\n) {\n\n    private var _service: FruitService = fruitService\n\n    fun fetchFruits(callback: Callback\u003cList\u003cString\u003e\u003e) {\n        _service.fetchFruits(callback)\n    }\n}\n```\n\n# 1. Callback 접근 방식 이해\n\n일반적인 콜백 기반 함수부터 시작해봅시다. 비동기 작업을 하는 과일 데이터를 가져오는 작업이 있으며 결과를 반환하기 위해 콜백을 사용한다고 가정해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nfun fetchFruitsLegacyWay(repository: FruitsRepository) {\n    repository.fetchFruits(object : Callback\u003cList\u003cString\u003e\u003e {\n        override fun onSuccess(response: List\u003cString\u003e) {\n            println(\"fetchFruitsLegacyWay: onSuccess: $response \")\n        }\n\n        override fun onFailure(e: Throwable) {\n            println(\"fetchFruitsLegacyWay: onFailure: ${e.message} \")\n        }\n    })\n}\n```\n\nCallback을 사용하여 API 호출하는 방법:\n\n```kotlin\nfun main() {\n    val repository = FruitsRepository(LegacyDataSource())\n    fetchFruitsLegacyWay(repository)\n}\n```\n\n# 2. 코루틴으로 변환하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이를 코루틴 기반 접근 방식으로 변환하려면 다음 단계를 따르세요:\n\n- 서스펜드 함수 생성: 콜백 함수를 서스펜드 함수로 변경합니다.\n- 코루틴 빌더 사용: launch 또는 async를 사용하여 코루틴 스코프 내에서 서스펜드 함수를 호출합니다.\n- 예외 처리: 콜백 오류 메서드 대신 코루틴 내에서 try-catch를 사용하여 예외를 처리합니다.\n\n## 단계별 변환\n\n서스펜드 함수 정의: 콜백을 제거하고 함수를 서스펜드로 변경하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 내용을 추가하여 Service Interface를 업데이트하세요:\n\n```kotlin\nsuspend fun fetchFruits(): List\u003cString\u003e // 새로운 중단 함수\n```\n\n아래 코드를 추가하여 FruitsDataSource를 업데이트하세요:\n\n```kotlin\n// 과일 목록을 가져오는 중단 함수\noverride suspend fun fetchFruits(): List\u003cString\u003e {\n    delay(1000) // API 호출을 모방하기 위한 지연\n    return fruits\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 코드를 추가하여 FruitsRepository를 업데이트해주세요:\n\n```kotlin\noverride suspend fun fetchFruits(): List\u003cString\u003e  {\n    return _service.fetchFruits()\n}\n```\n\n사용하는 Suspend Function 호출하기: launch 또는 async와 같은 코루틴 빌더를 사용하여 suspend function을 호출합니다.\n\n## launch를 사용한 예시''\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprivate suspend fun fetchFruitsUsingCoroutine(repository: FruitsRepository) {\n    try {\n        println(\"fetchFruitsUsingCoroutine 성공:${repository.fetchFruits()}\")\n    } catch (ex: Exception) {\n        println(\"fetchFruitsUsingCoroutine 실패:${ex.message}\")\n    }\n}\n```\n\n```js\nfun main() = runBlocking {\n    // IO 컨텍스트에서 코루틴 실행\n    launch(Dispatchers.IO) {\n        try {\n            val repository = FruitsRepository(LegacyDataSource())\n            fetchFruitsUsingCoroutine(repository)\n            println(result) // Output: 서버로부터의 과일 목록\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n}\n```\n\n# 3. Async/Await를 사용한 여러 작업 처리\n\n만약 여러 비동기 태스크를 수행해야 한다면, 코루틴은 동시 실행을 위해 async를, 결과를 기다리기 위해 await를 사용하여 더 우아하게 처리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 코루틴을 이용한 여러 작업\n\n```js\nfun main() = runBlocking {\n  val repository = FruitsRepository(LegacyDataSource())\n\n  val fruits1 = async { repository.fetchFruits() } //API 호출 1\n  val data1 = fruits1.await()\n  println(\"Data1: $data1\") // 출력: 서버에서 과일 목록\n\n  val fruits2 = async { repository.fetchFruits() } // API 호출 2\n  val data2 = fruits2.await()\n  println(\"Data2: $data2\") // 출력: 서버에서 과일 목록\n}\n```\n\n# 4. 기존 코드 통합\n\n기존 콜백을 사용하는 레거시 시스템과 통합할 때, suspendCoroutine 또는 suspendCancellableCoroutine을 사용하여 콜백 기반 코드를 코루틴으로 래핑할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 코루틴을 이용한 콜백 감싸기\n\n```kotlin\nprivate suspend fun fetchFruitsUsingCoroutines(repository: FruitsRepository) {\n  suspendCoroutine { continuation -\u003e\n      repository.fetchFruits(object : Callback\u003cList\u003cString\u003e\u003e {\n          override fun onSuccess(response: List\u003cString\u003e) {\n              continuation.resume(response)\n          }\n\n          override fun onFailure(e: Throwable) {\n              continuation.resumeWithException(e)\n          }\n      })\n  }.let {\n      println(\"fetchFruitsUsingCoroutines: Response: $it\")\n  }\n}\n```\n\n# 5. 코루틴 사용의 장점\n\n- 가독성: 코루틴을 사용하면 동기 코드처럼 보이고 동작하는 비동기 코드를 간편하게 작성할 수 있습니다.\n- 확장성: 코루틴은 가벼우며 많은 수의 동시 작업을 효율적으로 처리할 수 있습니다.\n- 구조화된 병행성: 비동기 작업의 라이프사이클을 보다 효과적으로 관리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n콜백을 코루틴으로 변환하면 코드를 현대화하여 유지 및 확장하기 쉬워집니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtouseaCoroutineinsteadofCallback_0.png"},"coverImage":"/assets/img/2024-06-23-HowtouseaCoroutineinsteadofCallback_0.png","tag":["Tech"],"readingTime":8}],"page":"11","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"11"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>