<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/11" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/11" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_buildManifest.js" defer=""></script><script src="/_next/static/0asLlD6on3tm8cIfzBaxd/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="파이썬에서 쉘 명령어를 올바르게 실행하는 방법" href="/post/2024-05-23-TheRightWaytoRunShellCommandsFromPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬에서 쉘 명령어를 올바르게 실행하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬에서 쉘 명령어를 올바르게 실행하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">파이썬에서 쉘 명령어를 올바르게 실행하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="신호, 셸 및 도커 발을 쏘는 축적체" href="/post/2024-05-23-Signalsshellsanddockeranonionoffootguns"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="신호, 셸 및 도커 발을 쏘는 축적체" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-Signalsshellsanddockeranonionoffootguns_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="신호, 셸 및 도커 발을 쏘는 축적체" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">신호, 셸 및 도커 발을 쏘는 축적체</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="높은 성능의 Swift 앱" href="/post/2024-05-23-HighPerformanceSwiftApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="높은 성능의 Swift 앱" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-HighPerformanceSwiftApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="높은 성능의 Swift 앱" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">높은 성능의 Swift 앱</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안녕하세요 안드로이드 프로젝트에서 자주 마주치는 성가신 문제들을 살펴보겠습니다 함께 해요" href="/post/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안녕하세요 안드로이드 프로젝트에서 자주 마주치는 성가신 문제들을 살펴보겠습니다 함께 해요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안녕하세요 안드로이드 프로젝트에서 자주 마주치는 성가신 문제들을 살펴보겠습니다 함께 해요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안녕하세요 안드로이드 프로젝트에서 자주 마주치는 성가신 문제들을 살펴보겠습니다 함께 해요</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="첫째 날 - M4 iPad Pro" href="/post/2024-05-23-1stDayM4iPadPro"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="첫째 날 - M4 iPad Pro" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-1stDayM4iPadPro_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="첫째 날 - M4 iPad Pro" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">첫째 날 - M4 iPad Pro</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2단계 인증 앱이 012345를 받았을 때 알려주는 기능" href="/post/2024-05-23-The2FAappthattellsyouwhenyouget012345"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2단계 인증 앱이 012345를 받았을 때 알려주는 기능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2단계 인증 앱이 012345를 받았을 때 알려주는 기능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2단계 인증 앱이 012345를 받았을 때 알려주는 기능</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">28<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS용 Fastlane과 GitHub Actions를 사용하여 CICD 파이프라인 구성하기" href="/post/2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS용 Fastlane과 GitHub Actions를 사용하여 CICD 파이프라인 구성하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS용 Fastlane과 GitHub Actions를 사용하여 CICD 파이프라인 구성하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS용 Fastlane과 GitHub Actions를 사용하여 CICD 파이프라인 구성하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024 OWASP 모바일 탑 10 변경 사항에 대한 소식이 뭐길래" href="/post/2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024 OWASP 모바일 탑 10 변경 사항에 대한 소식이 뭐길래" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024 OWASP 모바일 탑 10 변경 사항에 대한 소식이 뭐길래" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024 OWASP 모바일 탑 10 변경 사항에 대한 소식이 뭐길래</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CSRF로 인해 계정이 삭제될 수 있습니다" href="/post/2024-05-23-CSRFLeadstoDeleteAccount"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CSRF로 인해 계정이 삭제될 수 있습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CSRF로 인해 계정이 삭제될 수 있습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">CSRF로 인해 계정이 삭제될 수 있습니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Android Kotlin 개발자를 위한 Swift 참고 자료" href="/post/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Android Kotlin 개발자를 위한 Swift 참고 자료" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Android Kotlin 개발자를 위한 Swift 참고 자료" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Android Kotlin 개발자를 위한 Swift 참고 자료</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link posts_-active__YVJEi" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"파이썬에서 쉘 명령어를 올바르게 실행하는 방법","description":"","date":"2024-05-23 15:08","slug":"2024-05-23-TheRightWaytoRunShellCommandsFromPython","content":"\n\u003cimg src=\"/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png\" /\u003e\n\n파이썬은 모든 것을 자동화하는 데 인기 있는 선택지입니다. 이는 시스템 관리 작업을 자동화하거나 다른 프로그램을 실행하거나 운영 체제와 상호 작용하는 작업을 포함합니다. 그러나 파이썬에서 이를 수행하는 많은 방법이 있습니다. 대부분은 논란이 될 수 있는 방법입니다.\n\n그래서 이 기사에서는 다른 프로세스를 실행하는 데 사용할 수 있는 파이썬 옵션을 모두 살펴볼 것입니다. 나쁜 방법, 좋은 방법, 그리고 무엇보다도 올바른 방법을 중점적으로 살펴보겠습니다.\n\n# 옵션들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬은 다른 프로그램과 상호 작용하는 내장 옵션이 너무 많습니다. 그 중에서도 어떤 것은 좋고 나쁨이 있지만 솔직히 말해서 나는 어느 것도 좋아하지 않아요. 각 옵션을 빠르게 살펴보고 특정 모듈을 사용해야 하는 시점(있는 경우)을 확인해 봅시다.\n\n# 내장 도구\n\n일반적인 지침은 다른 프로그램이나 OS 명령을 직접 호출하는 대신 기본 기능을 사용하는 것이어야 합니다. 그래서 먼저 파이썬의 기본 옵션을 살펴보겠습니다:\n\n- pathlib — 파일/디렉토리를 생성하거나 삭제해야 하거나 파일이 존재하는지 확인하거나 권한을 변경해야 할 때는 시스템 명령을 실행할 이유가 없습니다. 단순히 pathlib을 사용하세요. 필요한 모든 것이 포함되어 있습니다. pathlib를 사용하기 시작하면 glob이나 os.path와 같은 다른 파이썬 모듈을 잊을 수 있다는 것을 깨닫게 될 거예요.\n- tempfile — 비슷하게, 임시 파일이 필요할 때는 tempfile 모듈을 사용하세요. /tmp에 수동으로 접근할 필요가 없습니다.\n- shutil — pathlib은 파이썬에서 대부분의 파일 관련 요구 사항을 충족할 것입니다. 그러나 파일을 복사하거나 이동하거나 chown 또는 아카이브를 생성해야 하는 경우에는 shutil을 사용해야 합니다.\n- signal — 신호 핸들러를 사용해야 하는 경우에 필요합니다.\n- syslog — Unix syslog에 대한 인터페이스를 위해 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 위에 제공된 내장 옵션들 중에서 아무것도 원하는 대로 만족스럽지 않다면, 그때만 운영 체제나 다른 프로그램과 직접 상호 작용하는 것이 의미가 있습니다.\n\n# OS 모듈\n\n최악의 옵션부터 시작해서 os 모듈은 운영 체제와 상호 작용하기 위한 저수준 함수를 제공하지만, 많은 함수들이 다른 모듈에서 대체되었습니다.\n\n단순히 다른 프로그램을 호출하고 싶다면 os.system 함수를 사용할 수 있지만, 사용하면 안 됩니다. 당신에게 예시를 들어 주고 싶지 않아요, 왜냐하면 그냥 사용하지 말아야 하기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nos는 처음 선택하긴 좋지 않지만, 유용하게 사용할 수 있는 몇 가지 함수가 있습니다:\n\n```js\nimport os\n\nprint(os.getenv('PATH'))\n# /home/martin/.local/bin:/usr/local/sbin:/usr/local/bin:...\nprint(os.uname())\n# posix.uname_result(sysname='Linux', nodename='...', release='...', version='...', machine='x86_64')\nprint(os.times())\n# posix.times_result(user=0.01, system=0.0, children_user=0.0, children_system=0.0, elapsed=1740.63)\nprint(os.cpu_count())\n# 16\nprint(os.getloadavg())\n# (2.021484375, 2.35595703125, 2.04052734375)\nold_umask = os.umask(0o022)\n# 파일 처리...\nos.umask(old_umask)  # 이전 umask로 되돌리기\n\n# 'random' 모듈의 의사 난수보다 더 좋은 난수가 필요한 경우에만 사용하세요:\nfrom base64 import b64encode\n\nrandom_bytes = os.urandom(64)\nprint(b64encode(random_bytes).decode('utf-8'))\n# C2F3kHjdzxcP7461ETRj/YZredUf+NH...hxz9MXXHJNfo5nXVH7e5olqLwhahqFCe/mzLQ==\n```\n\n위에 설명된 함수들 외에도, fd(파일 기술자), 파이프, PTY 열기, chroot, chmod, mkdir, kill, stat을 생성하는 함수들이 있지만, 더 좋은 옵션이 있기 때문에 사용을 권장하지 않습니다. 심지어 os.popen, os.spawn 또는 os.system을 사용하지 않도록 docs에 나온 부분에서 os를 subprocess 모듈로 대체하는 방법을 보여줍니다.\n\n파일/경로 작업에 os 모듈을 사용하지 말아주세요. os.path 및 기타 경로 관련 함수 대신 pathlib를 사용하는 방법에 대한 전체 섹션이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nos 모듈의 대부분의 남은 함수는 OS(또는 C 언어) API에 직접적으로 연결되어 있습니다. 예를 들어 os.dup, os.splice, os.mkfifo, os.execv, os.fork 등이 있습니다. 이러한 모든 함수를 사용해야 한다면 파이썬이 그 작업에 적합한 언어인지 확신하지 못합니다.\n\n# 서브프로세스 모듈\n\n파이썬에서 두 번째 — 약간 나은 — 옵션은 서브프로세스 모듈입니다. 아래는 서브프로세스 모듈의 예시입니다:\n\n```js\nimport subprocess\n\np = subprocess.run('ls -l', shell=True, check=True, capture_output=True, encoding='utf-8')\n\n# 'p'는 'CompletedProcess(args='ls -la', returncode=0)'의 인스턴스입니다\nprint(f'Command {p.args} exited with {p.returncode} code, output: \\n{p.stdout}')\n# Command ls -la exited with 0 code\n\n# total 36\n# drwxrwxr-x  2 martin martin  4096 apr 22 12:53 .\n# drwxrwxr-x 42 martin martin 20480 apr 22 11:01 ..\n# ...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문서에서 설명된대로:\n\n대부분의 경우 subprocess.run을 사용하여 kwargs를 전달하여 해당 동작을 변경하는 것이 충분합니다. 예를 들어 shell=True를 사용하면 명령을 단일 문자열로 전달할 수 있고, check=True를 사용하면 종료 코드가 0이 아닌 경우 예외를 throw하고, capture_output=True를 사용하면 stdout 속성을 채울 수 있습니다.\n\nsubprocess.run()은 프로세스를 호출하는 권장되는 방법입니다. 이 모듈에서 다른 (불필요하고 사용되지 않는) 옵션도 있습니다: call, check_call, check_output, getstatusoutput, getoutput. 일반적으로 아래와 같이 run과 Popen만 사용해야 합니다:\n\n```js\nwith subprocess.Popen(['ls', '-la'], stdout=subprocess.PIPE, encoding='utf-8') as process:\n    # process.wait(timeout=5)  # 코드만 반환: 0\n    outs, errs = process.communicate(timeout=5)\n    print(f'Command {process.args}가 {process.returncode} 코드로 종료되었으며 출력: \\n{outs}')\n\n# 파이프\nimport shlex\nls = shlex.split('ls -la')\nawk = shlex.split(\"awk '{print $9}'\")\nls_process = subprocess.Popen(ls, stdout=subprocess.PIPE)\nawk_process = subprocess.Popen(awk, stdin=ls_process.stdout, stdout=subprocess.PIPE, encoding='utf-8')\n\nfor line in awk_process.stdout:\n    print(line.strip())\n    # .\n    # ..\n    # examples.py\n    # ...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 첫 번째 예제는 이전에 소개된 subprocess.run의 Popen 등가물을 보여줍니다. 그러나 run이 제공하는 것보다 더 많은 유연성이 필요할 때만 Popen을 사용해야 합니다. 두 번째 예제에서는 한 명령의 출력을 다른 명령으로 파이핑하는 방법을 볼 수 있습니다. ls -la | awk `'print $9'`를 효과적으로 실행하는 방법입니다. 또한, shlex.split을 사용했는데, 이는 문자열을 토큰의 배열로 분할하는 편리한 함수로, shell=True를 사용하지 않고 Popen이나 run으로 전달할 수 있습니다.\n\nPopen을 사용할 때, 프로세스와 더 많은 상호작용을 위해 terminate(), kill() 및 send_signal()을 추가적으로 사용할 수 있습니다.\n\n이전 예제에서는 실제로 오류 처리를 거의 하지 않았지만, 다른 프로세스를 실행할 때 많은 문제가 발생할 수 있습니다. 간단한 스크립팅의 경우, check=True가 있으면 충분할 것으로 생각됩니다. 이는 호출 프로세스가 0이 아닌 반환 코드를 만나면 CalledProcessError가 발생하므로 프로그램이 빠르고 강하게 실패합니다. timeout 인수도 설정하면 TimeoutExpired 예외도 받을 수 있지만, 일반적으로 subproccess 모듈의 모든 예외는 SubprocessError에서 상속받습니다. 예외를 잡고 싶을 경우에는 SubprocessError를 감시하면 됩니다.\n\n# 올바른 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬의 신조(격언)은 다음과 같습니다:\n\n하지만 지금까지 파이썬의 내장 모듈들로 많은 방법을 보았습니다. 하지만 그 중에 어떤 것이 옳은 것일까요? 내 의견으로는 그 중 하나도 아닙니다.\n\n파이썬의 표준 라이브러리를 좋아하지만, subprocess 모듈이 더 나은 \"배터리\" 중에 하나라고 생각합니다.\n\n만약 파이썬에서 다른 프로세스를 많이 조합하는 상황이라면, sh 라이브러리를 한 번 살펴보는 것을 권장합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n# https://pypi.org/project/sh/\n# pip install sh\nimport sh\n\n# $PATH에 있는 어떤 명령어든 실행...\nprint(sh.ls('-la'))\n\nls_cmd = sh.Command('ls')\nprint(ls_cmd('-la'))  # 명시적으로\n# total 36\n# drwxrwxr-x  2 martin martin  4096 apr  8 14:18 .\n# drwxrwxr-x 41 martin martin 20480 apr  7 15:23 ..\n# -rw-rw-r--  1 martin martin    30 apr  8 14:18 examples.py\n\n# 만약 PATH에 명령어가 없다면:\ncustom_cmd = sh.Command('/path/to/my/cmd')\ncustom_cmd('some', 'args')\n\nwith sh.contrib.sudo:\n    # 'sudo'를 사용하여 작업 수행...\n    ...\n```\n\nsh.some_command을 호출하면, sh 라이브러리가 해당 이름의 내장 셸 명령어나 $PATH에 있는 이진 파일을 찾습니다. 그런 명령어를 찾으면 그대로 실행됩니다. 명령어가 $PATH에 없는 경우에는 Command의 인스턴스를 생성하고 그렇게 호출할 수 있습니다. sudo를 사용해야 하는 경우에는 contrib 모듈의 sudo context manager를 사용할 수 있습니다. 너무 간단하고 직관적이죠?\n\n명령어의 결과를 파일에 쓰려면, 함수에 \\_out 인수를 제공하면 됩니다:\n\n```bash\nsh.ip.address(_out='/tmp/ipaddr')\n# 'ip address \u003e /tmp/ipaddr'와 같습니다\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에는 하위 명령을 호출하는 방법도 보여 줍니다. - 점을 사용하세요.\n\n마지막으로 \\_인 인수를 사용하여 파이프(|)를 사용할 수도 있습니다:\n\n```js\nprint(sh.awk('{print $9}', _인=sh.ls('-la'))\n# \"ls -la | awk '{print $9}'\"과 동일합니다\n\nprint(sh.wc('-l', _인=sh.ls('.', '-1'))\n# \"ls -1 | wc -l\"과 동일합니다\n```\n\n오류 처리에 대해선 ErrorReturnCode 또는 TimeoutException 예외를 감시하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```md\n시도:\nsh.cat('/tmp/doesnt/exist')\nexcept sh.ErrorReturnCode as e:\nprint(f'Command {e.full_cmd} exited with {e.exit_code}') # Command /usr/bin/cat /tmp/doesnt/exist exited with 1\n\ncurl = sh.curl('https://httpbin.org/delay/5', \\_bg=True)\ntry:\ncurl.wait(timeout=3)\nexcept sh.TimeoutException:\nprint(\"Command timed out...\")\ncurl.kill()\n```\n\n선택적으로, 만약 프로세스가 시그널에 의해 종료된다면, SignalException을 받게 될 거에요. 특정 시그널을 확인할 수 있는데 예를 들면 SignalException_SIGKILL(또는 \\_SIGTERM, \\_SIGSTOP 등)으로 확인할 수 있어요.\n\n이 라이브러리에는 내장된 로깅 지원도 있어요. 켜기만 하면 되는데요. 다음 코드가 도와줄 거에요:\n\n```md\nimport logging\n\n# 기본 로깅 켜기:\n\nlogging.basicConfig(level=logging.INFO)\nsh.ls('-la')\n\n# INFO:sh.command:\u003cCommand '/usr/bin/ls -la', pid 1631463\u003e: process started\n\n# 로그 레벨 변경:\n\nlogging.getLogger('sh').setLevel(logging.DEBUG)\nsh.ls('-la')\n\n# INFO:sh.command:\u003cCommand '/usr/bin/ls -la', pid 1631661\u003e: process started\n\n# DEBUG:sh.command:\u003cCommand '/usr/bin/ls -la'\u003e: starting process\n\n# DEBUG:sh.command.process:\u003cCommand '/usr/bin/ls -la'\u003e.\u003cProcess 1631666 ['/usr/bin/ls', '-la']\u003e: started process\n\n# ...\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예제들은 대부분의 사용 사례를 다룰 수 있지만, 더 고급/난해한 경우에는 라이브러리 문서의 튜토리얼이나 FAQ를 확인해보세요. 여기에는 추가적인 예제들이 있습니다.\n\n# 마지막으로\n\n다시 강조하고 싶은 점은 항상 시스템 명령어를 사용하는 대신 네이티브 Python 함수를 선호해야 한다는 것입니다. 또한 CLI 명령어를 직접 실행하는 대신 Kubernetes-client나 클라우드 제공업체의 SDK와 같은 서드파티 클라이언트 라이브러리를 사용하는 것을 항상 선호해야 합니다. 내 의견으로는, 쉘 대신 Python에 더 익숙하다면 시스템 관리자 배경에서 오더라도 적용됩니다. 마지막으로, Python은 쉘보다 훨씬 강력하고 견고한 언어이지만, 다른 프로그램/명령어를 너무 많이 연결해야 하는 경우에는 아마도 쉘 스크립트를 작성하는 것이 나을 수도 있습니다.\n\n```js\n연락하고 싶으세요?\n\n이 글은 원본이 martinheinz.dev에 게시되었습니다.\n````\n","ogImage":{"url":"/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png"},"coverImage":"/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png","tag":["Tech"],"readingTime":9},{"title":"신호, 셸 및 도커 발을 쏘는 축적체","description":"","date":"2024-05-23 15:06","slug":"2024-05-23-Signalsshellsanddockeranonionoffootguns","content":"\n가끔은 POSIX 시그널(SIGINT, SIGTERM 등)을 디버깅해야 할 때가 있었습니다. 불가피하게 쉘도 포함되어 있죠. 어느 날, 시그널, 쉘 및 컨테이너 간 이상한 상호 작용을 디버깅하던 중에 일부 행동에 혼란스러워졌습니다. Linux에 대해 자신 있다고 생각하는 사람들조차도 우리 조사 결과의 일부 내용이 놀라울 정도로 신기할 것이라 생각됩니다. 이런 종류의 내용이 여러분이 노트북을 창문 밖으로 던지고 알파카 농부 은둔자가 되고 싶지 않는다면 계속 읽어보세요.\n\n![이미지](/assets/img/2024-05-23-Signalsshellsanddockeranonionoffootguns_0.png)\n\n# 범행 현장\n\n저희 Benchling에서는 꽤 표준적인 테스트/지속적 통합(CI) 설정이 있습니다: 코드를 푸시하여 풀 리퀘스트 브랜치에 올리면 테스트를 실행합니다. 몇 년 전, 푸시를 다시 하고 이전 커밋에서 여전히 테스트가 실행 중이면 이전 테스트 실행을 취소하는 최적화를 추가했습니다. 아마 여러분은 그 실행에 대해 신경 쓸 필요가 없을 것이고 약간의 비용을 절약할 것입니다... 아니면 그렇게 될까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 테스트를 실행하는 코드는 기본적으로 이렇습니다\n\n```js\ndef test_pipeline() -\u003e int:\n    test_result = subprocess.run([\"pytest\", …])\n    report_test_metrics()\n    upload_artifacts()\n    return test_result.returncode\n```\n\n그래서 우리의 프로세스 트리는 다음과 같습니다\n\n```js\ntest_pipeline\n└──pytest\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nsubprocess.run은 자식 프로세스가 종료될 때까지 블로킹되므로 대부분의 시간이 걸릴 것입니다. CI 로그에서 테스트가 중간에 중단되고 더 이상 로그가 표시되지 않는 것을 보았는데, 확실히 작동 중인 것처럼 보입니다. 하지만 우리는 취소된 실행에 대한 메트릭스와 아티팩트를 얻을 수 있습니다. 이것은 전혀 이치에 맞지 않습니다. 나중에 우리는 실행이 취소되었고 로그 전달이 중지되었음을 보고했지만 pytest가 계속 실행되고 있음을 나준 낼 것입니다.\n\n# 기초로 돌아가기\n\ntest_pipeline에서 pytest로 신호를 전달하지 않는 문제일 수도 있다고 생각하여 우리는 먼저 기본 신호 처리에 대해 고려했습니다. zsh를 실행 중인 터미널에서 zsh의 pid를 다음과 같이 얻을 수 있습니다.\n\n```bash\n$ echo $$\n20147\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 zsh 안에서 bash를 실행하고 (테스트와 같이 매우 느린 명령어) bash 안에서 infinity로 sleep할 수 있어요.\n\n```js\n$ bash\n$ sleep infinity\n```\n\n다른 쉘에서는 프로세스 트리를 확인할 수 있어요.\n\n```js\n$ pstree -p 20147\nzsh(20147)───bash(65453)───sleep(65904)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(pstree은 Debian/Ubuntu에서는 psmisc 패키지에 포함되어 있고, brew에는 pstree 공식이 있습니다.) 여기서는 기대한 대로 zsh가 bash를 실행하고 bash가 sleep를 실행하는 것이 나타납니다. 이제 우리가 ctrl+c로 SIGINT를 보내면 sleep가 멈춥니다.\n\n이게 왜 그럴까요? 터미널은 ctrl+c를 \"SIGINT를 전송\"으로 해석합니다. zsh가 SIGINT를 받아서 기본 셸 프로세스인 bash에 전달하고, bash가 이 신호를 sleep에 전달합니다. sleep는 SIGINT에 대한 자체 시그널 핸들러를 설정하지 않았고, 기본 시그널 핸들러가 종료합니다 (SIGINT에는 \"term\" 처리 방식이 있습니다).\n\n조사 시작 시에는 이것이 셸 신호 처리에 대한 우리의 개념 모델이었습니다.\n\n# 대화형이 아닌 셸\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 문제가 발생한 것은 셸 스크립트가 bash로 실행될 때 나타났습니다 (위의 파이썬 코드를 bash 스크립트에서 실행합니다).\n\n```js\nbash\n  └─test_pipeline\n      └─pytest\n```\n\n대화식 셸(다른 차이 사항 중 stdin을 읽는)이 비대화식 셸이나 \"스크립트\"와 다르게 작동할 수 있다고 생각하여, 파일에 2줄을 작성했습니다.\n\n```js\nsleep infinity\necho done\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n돌렸다\n\n```js\n$ ./test.sh\n```\n\n다른 쉘에서는 똑같은 프로세스 트리를 볼 수 있었어요\n\n```js\n$ pstree -p 20147\nzsh(20147)───bash(65910)───sleep(65911)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 다음, 우리는 직접 bash에게 신호를 보냈습니다.\n\n```js\n$ kill -s INT 65910\n```\n\n하지만 아무 일도 일어나지 않았습니다. bash 문서(man bash)에 숨겨진 \"신호(signals)\" 섹션에는\n\n대화식 쉘에 대해서 기본적으로 작업 제어가 켜져 있고, 스크립트에 대해서는 꺼져 있다는 내용이 있습니다(“모니터 모드”에 대한 문서 참조). 그래서 아무 일도 일어나지 않았던 이유는 bash가 sleep(전경에 있는 명령)가 종료되기를 기다리고 있었기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 여기에 프로세스 그룹에 관한 힌트도 있습니다. `pstree` 명령을 사용하면 이를 확인할 수 있습니다 (macOS에서는 작동하지 않음):\n\n```js\n$ pstree -pg 20147\nzsh(20147,20147)───bash(65910,65910)───sleep(65911,65910)\n```\n\n여기서 볼 수 있듯이, 대화식 zsh에서 실행한 bash가 자체 프로세스 그룹을 갖고 있다는 것을 알 수 있습니다. 반면, 비대화식 bash에서 실행한 sleep는 bash와 동일한 pgid를 공유합니다. 그룹 내의 두 프로세스에 대해 신호를 보내려면 pid를 부정화하면 됩니다:\n\n```js\n$ kill -s INT -65910\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 sleep이 SIGINT를 수신하여 종료됩니다. bash도 SIGINT를 받아서 문서에 나와 있는 대로 자체적으로 종료됩니다. 상호작용식 zsh로 돌아와서 다음을 실행할 수 있습니다.\n\n```js\n$ sleep infinity\n```\n\n그리고 sleep이 예상대로 자체 pgid를 받는 것을 확인할 수 있습니다.\n\n```js\n$ pstree -p 20147\nzsh(20147,20147)───sleep(65916,65916)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비 대화형 셸에서의 마지막 명령어\n\n지금은 종종 셸이 자식 프로세스로 신호를 전달하지 않을 수 있다는 것을 알게 되었습니다. 어떤 사람이 한 번 bash -c `sleep infinity`를 실행하여 이것을 재현하려 했습니다. 그들은 ctrl+c를 눌러 sleep를 중지시킬 수 있었습니다. 그러나 이는 비 대화형 셸이므로 bash가 SIGINT를 전달해서는 안 되는 것 아닌가요? 왜 그럴까요?\n\n```js\n$ bash -c ‘sleep infinity’\n```\n\n보통의 경우, 다른 쉘에서:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n$ pstree -p 20147\nzsh(20147)───sleep(65920)\n```\n\n어이쿠, bash가 어디로 갔지? 우리는 bash를 실행했는데요! 왜 pstree가 zsh가 sleep을 실행 중이라고 하는 걸까요?\n\n프로그램을 \"실행\"할 때 일반적으로 하는 것은 fork한 후에 exec하는 것을 의미합니다. fork는 새로운 프로세스의 부모 pid를 설정하여 나중에 pstree와 같은 도구가 이쁜 트리를 그릴 수 있도록 합니다. exec는 새로운 프로세스의 명령을 설정하여 pstree와 같은 도구가 해당 pid가 무슨 일을 하는지 유의미한 정보를 보여줄 수 있도록 합니다.\n\n하지만 이곳에서 일어난 일은 bash가 단순히 sleep을 exec해주기 전에 fork하는 것을 건너뛴 것입니다. 이 동작에 대한 문서를 찾을 수 없어서, 대신 해드릴 수 있는 것은 ash 소스 코드입니다:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n```js\n/* 포크를 피할 수 있을까요? 예를 들어, 스크립트나 서브셸에서\n * 가장 마지막 명령은 포킹이 필요 없습니다,\n * 그냥 실행(exec)할 수 있습니다.\n */\n```\n\n바쉬가 자신을 sleep으로 교체하고 pstree에 보여지는 것은, 이제 sleep을 실행 중인 것의 부모가 zsh 임을 보여줍니다. 대신 `bash -c 'sleep infinity \u0026\u0026 done'`을 실행함으로써 이전 동작을 얻을 수 있습니다.\n\n실제로 우리는 bash 스크립트를 sh -c로 실행하기 때문에, 우리의 정신적 모델은 다음과 같습니다.\n\n```js\nsh\n└─bash\n    └─test_pipeline\n        └─pytest\n```\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잠깐만요! 나무 구조에서 'sh'가 자체 PID가 아니라는 것을 깨달을 때까지는...\n\n# sh, bash, dash, 그리고 ash에 관한 간단한 쉬는 시간\n\n아쉬가 뭐죠? 제가 보낸 것은 무관한 코드 링크인가요? (네, 어느 정도 맞아요. bash와 동일한 동작을 하지만 소스 코드는 조금 덜...추상화되어 있죠.)\n\nsh는 Bourne 쉘(보통 \"POSIX sh\"로 불립니다.)이며, Bash는 Bourne 쉘의 확장 버전입니다. 역사적으로는 많은 시스템에서 sh를 bash에 연결한 적이 있었습니다. bash는 argv[0]을 확인하고 sh 호환 모드에서 실행했죠. 현대의 리눅스 시스템에서는 sh가 일반적으로 dash로 대체되었지만 macOS에서는 여전히 sh 모드에서 bash를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1989년 NetBSD를 위해 작성된 Almquist 셸이 원래 ash였습니다. 이것은 Linux로 이식되어 dash(Debian Almquist 셸)로 이름이 변경되었습니다. 요즘에는 \"ash\"가 일반적으로 busybox ash를 가리키는데, 이는 dash의 파생물입니다. 네, 맞아요. 계보는 ash → dash → ash입니다. 쉘 프로그래머들은 명명하는 데에 뛰어난 능력이 없다고 할 수 있겠네요.\n\n그런데 sh 호환 모드에서 bash와 ash는 모두 이전 섹션에서 설명한 exec-without-fork 동작을 구현하지만, dash는 그렇지 않습니다. 또한 Docker Hub의 공식 bash 이미지에서 sh를 실행하려고 하면 (docker run -it --rm bash sh), sh 호환 모드의 bash를 기대했겠지만 ash가 실행됩니다 (ash와 혼동해서는 안 되는 것입니다).\n\n# 플로우차트\n\n여기가 바로 쉘 신호 처리의 껍질을 벗기기 전에 있었으면 좋았을 플로우차트입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n![Image](/assets/img/2024-05-23-Signalsshellsanddockeranonionoffootguns_1.png)\n\n# 범죄 현장으로 돌아가기\n\n우리는 편리한 플로우차트를 가지고, ci-agent의 코드를 읽기 위해 이동했고, 빌드가 취소되면 실행 중인 작업에 SIGTERM을 보낸다는 것을 발견했습니다.\n\n```js\nci-agent\n    └─bash\n        └─test_pipeline\n            └─pytest\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"배시가 비대화식으로 실행되었고, test_pipeline이 마지막 명령어가 아니어서 어 anyway 신호가 전달되지 않았습니다. 그게 무슨 일이 발생한 걸 설명해주나요?\n\n우리는 bash를 exec test_pipeline.py로 만들어 트리에서 제거하려 했지만, 문제가 해결되지 않았습니다. 그것은 우리의 프로세스 트리가 여전히 잘못되어 있다는 것을 의미할 것입니다.\n\n# 컨테이너\n\nci-agent는 사실상 도커에게 스크립트를 실행하라고 지시하는 것 뿐입니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```md\nci-agent\n└─docker\n└─bash\n└─test_pipeline\n└─pytest\n```\n\n도커가 신호를 베쉬에게 전달하나요? 도커는 각 컨테이너마다 새로운 pid 네임스페이스를 생성하기 때문에 실행되는 명령이 pid 1이 됩니다. 1은 매우 특별한 pid입니다 (일반적으로 init 프로세스) 그리고 기본 신호 처리기를 가져오지 않습니다. 이 문제를 해결하기 위해 tini 또는 dumb-init을 pid 1로 사용하는 것이 일반적입니다.\n\n이미지를 조사한 결과 이미 우리는 dumb-init을 사용하고 있었다는 것이 밝혀졌습니다. 그래서 다음과 같은 트리가 남았습니다.\n\n```md\nci-agent\n└─docker\n└─dumb-init\n└─bash\n└─test_pipeline\n└─pytest\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제에 대한 설명이 없네요.\n\n# 이것이 마지막 트리에요, 정말\n\n사실, 우리는 도커 컨테이너를 직접 실행하지 않아요. 대신 도컴 포즈로 실행해요.\n\n```js\nci-agent\n    └─docker compose\n        └─docker\n            └─dumb-init\n                └─bash\n                    └─test_pipeline\n                        └─pytest\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 트리를 마친 후 우리는 문제를 재현할 수 있었습니다. 문제는 docker-compose v2.0.0에서 v2.19.0 사이의 버전에서 발생합니다. 여기서 docker-compose run이 시그널을 전달하지 못하는 문제가 발생합니다. 우리가 이 문제를 보고한 후에 이 문제가 해결되었습니다.\n\n이 버그는 docker-compose(v1)에서 docker compose(v2)로 업그레이드할 때 발생했습니다. 이 문제를 이해하는 데는 하이픈(hyphen)이 빠져있는 것을 발견하는 것이 필요했습니다. 이 누락된 하이픈을 발견하는 것은 중요했지만, 두 버전은 거의 동일한 매개변수를 가지고 있고, 거의 동일한 동작을 하기 때문에 발견하기 어려웠습니다. 이 이야기를 읽으면서 얻는 교훈 중 하나는, 이름을 짓는 것은 어렵지만 중요하다는 것입니다. 만약 \"하이픈(-)을 공백으로 바꿔서 Compose V2를 사용하도록 스크립트를 업데이트하세요\"와 같은 문서를 작성하게 되면, 아마도 중요한 명명 오류를 범한 것입니다.\n\n이 문제를 디버깅하는 데 어려웠던 점 중에 하나는 전체 소유권 체인을 이해해야 했기 때문입니다. 시그널은 각 프로세스가 자식에게 전달해야 합니다. pytest가 시그널을 받지 못한 이유를 이해하려면 전파 체인이 깨진 지점까지 트리를 구성해야 했는데, 이 경우에는 상당히 멀리 있었습니다.\n\n우리는 docker compose v1로 다시 다운그레이드하는 것을 고려했지만, 대신 CI 단계에서 실행된 컨테이너를 추적하고 끝에 도달하면 docker kill하는 방법을 선택했습니다. 나중에 상류에서 이 문제를 해결한 후, 우리의 완화책이 실제로 활성화되지 않았습니다. 문제가 해결된 후에는 이제 CI 실행이 다시 원하는 대로 중단됩니다. PR 브랜치로 여러 번 빠르게 푸시되면 이전 커밋을 실행하여 사이클을 낭비하지 않게 되어 전체 실행이 더 빨라졌습니다! (취소된 실행에 대한 측정 값을 더 이상 보고하지 않기 때문에 불안한 테스트를 식별하는 데 큰 도움이 됩니다.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프론트그라운드 프로세스 보너스\n\n\"비대화된 쉘\" 섹션에서 우리는 다음과 같은 프로세스 트리를 가졌습니다.\n\n```js\nzsh(20147)───bash(65910)───sleep(65911)\n```\n\n직접적으로 bash에 시그널을 보내는 방법을 다루었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sh\n$ kill -s INT -65910\n```\n\nzsh에 직접 신호를 보내지 않았던 이유가 뭔가요? zsh가 상호작용으로 실행 중이기 때문에 SIGINT를 bash로 전달해야 되지 않나요? 다음을 시도해 볼 수 있습니다.\n\n```sh\n$ kill -s INT -20147\n```\n\n하지만 아무 일도 일어나지 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현 상황에서 ctrl+c를 누르면 터미널이 zsh가 아니라 bash에 SIGINT를 보낸다는 걸 알게 되었어요. 이것은 zsh가 더 이상 전경 프로세스 그룹에 속해 있지 않기 때문입니다. 이것을 확인하기 위해 다음과 같이 실행해 볼 수 있어요.\n\n```js\n$ ps -xO stat\n   PID STAT S TTY          TIME COMMAND\n 20147 Ss   S pts/0    00:00:00 zsh\n 65910 S+   S pts/0    00:00:00 bash\n 65911 S+   S pts/0    00:00:00 sleep\n```\n\nman ps의 \"프로세스 상태 코드\" 섹션에 의하면\n\nbash와 sleep은 보이는데 zsh는 보이지 않네요. 그들이 동시에 전경 프로세스 그룹에 있을 수 없기 때문에, zsh가 상호작용적으로 실행 중이기 때문에 zsh는 bash에 자체 프로세스 그룹을 설정했어요. 그래서 \"zsh가 SIGINT를 받아서 bash로 전달한다\"고 말했지만, 실제로는 그게 사실이 아니었던 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 bash의 프로세스 그룹이 왜 전경 그룹인가요? tcsetpgrp. 이것은 ltrace로 확인할 수 있습니다:\n\n```js\n$ ltrace -e tcsetpgrp bash\nbash-\u003etcsetpgrp(255, 0xa9850, 0, 0x7f290bdb2fe4) = 0\n```\n\n그리고 bash가 종료되면 부모 쉘(zsh에서 확인됨)이 동일한 호출로 전경 상태를 다시 획득합니다.\n","ogImage":{"url":"/assets/img/2024-05-23-Signalsshellsanddockeranonionoffootguns_0.png"},"coverImage":"/assets/img/2024-05-23-Signalsshellsanddockeranonionoffootguns_0.png","tag":["Tech"],"readingTime":10},{"title":"높은 성능의 Swift 앱","description":"","date":"2024-05-23 15:03","slug":"2024-05-23-HighPerformanceSwiftApps","content":"\n두 주 전에 Check ‘em: The Based 2FA 앱을 출시했어요.\n\n그 컨셉은 정말 간단했어요: 정말 멋진 숫자가 나타날 때마다 알림을 보내주는 2단계 인증 앱이에요. 알림을 탭하여 그 숫자를 영구적으로 컬렉션에 추가할 수 있어요.\n\nReddit의 착한 사용자들은 저의 아이디어, 증명 개념, 출시까지를 즐겁게 받아주셨어요. 그래서 저를 프로그래밍 카테고리에서 세 번째로 올려놓게 해주셨어요.\n\n![image](/assets/img/2024-05-23-HighPerformanceSwiftApps_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCheck ‘em은 수백만 개의 2FA 코드를 미래로 계산하고 각 숫자를 처리하여 흥미로운 코드인지 확인하고 푸시 알림(GETs)으로 흥미로운 코드를 예약합니다.\n\nv1.0은 꽤 잘 작동하지만, 오늘은 성능에 집중할 거에요.\n\n제 앱 성능 평가 프로세스는 세 가지 단계로 진행됩니다:\n\n- 실제 기기에서 테스트하여 사용자를 직면한 문제를 식별합니다.\n- 병목 현상을 식별하기 위해 Instruments를 사용하여 앱을 프로필링합니다.\n- 이를 가이드로 사용하여 코드 개선을 구현합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제 우선 접근 방식을 통해, 자전거 에관한 논의를 피하고 실제 병목 현상에 집중할 수 있어요.\n\n이 방법을 통해 사용자들에게 혜택을 주지 않는 일반적인 코드 개선에 시간을 낭비하지 않아도 돼요 (그래서 싱글톤이 여전히 사용되는 이유입니다 — 죄송하지만 이대로 가야겠죠).\n\n# 디바이스에서의 테스트\n\n## 처리 속도\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n큰 성능 문제는 바로 여기에 있어요: 2단계 인증 코드를 계산하는 동안 숫자를 처리할 때 발생합니다. 이 처리는 앱에 로그인할 때, 2단계 인증 계정을 변경하거나 GETs 선택 사항을 업데이트할 때마다 실행됩니다.\n\nTOTP 계산 자체는 간단하지 않은 기능으로, 바이트 조작, 문자열 생성 및 암호 작업이 포함됩니다. 이 코드들은 그 후에 여러 가지 흥미로운 유형으로 확인되며, 가장 흥미로운 코드에 대한 푸시 알림을 예약합니다.\n\n이 처리는 사용자가 일반 GETs(예: 004444 또는 123321과 같은 회문)를 활성화한 경우에는 꽤 빠릅니다. 이들 코드 중 몇 개를 하루에 발견할 때, 미래까지 계산할 필요가 없어서 64개의 알림(이OS에서의 한도)을 예약할 때까지 계속 실행됩니다.\n\n사용자가 희귀한 GETs(예: 055555 또는 012340와 같은 근처 계수 순서)를 보고 싶어하는 경우, 총 처리 시간이 10초를 초과할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*e66r8CS6JsTQmQzq_wIytA.gif)\n\nRarity increases exponentially with each tier. With only ultra-rare GETs enabled, such as sexts (e.g. 666666) or counting sequences (e.g. 012345), my screamingly powerful A17 chip takes take over a minute. This increases even more if you only choose one or two ultra-rare options.\n\nAs expected, this is by far the biggest performance bottleneck.\n\n## Time-to-first code\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱이 상당히 간단해서 Swift로 1500줄 정도밖에 안 되기 때문에 잠재적 성능 문제의 표면적인 영역은 꽤 제한적입니다.\n\n한 가지 조금 불편한 문제는 앱을 새로 실행할 때마다 발생합니다. 자체적인 런칭이 번개처럼 빠른데, 처음 2FA 코드가 나타나기까지 약간의 시간이 걸립니다.\n\n사용자가 이 앱을 일상에서 2FA 코드로 사용했으면 좋겠기 때문에 유용한 코드가 즉시 나타나면 이 앱의 기능적 사용 사례를 위한 사용자 경험을 향상시킬 것입니다.\n\n![GIF](https://miro.medium.com/v2/resize:fit:1400/1*D1B8yFO7YH8fN6FHT0_NQA.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Instruments를 이용한 프로파일링\n\n이제 두 가지 주요 사용자 성능 문제를 식별했으므로 Xcode Instruments를 사용하여 자세한 분석을 수행할 수 있습니다. 이 프로파일링을 통해 코드의 병목 현상을 정확히 감지할 수 있습니다.\n\n## Instruments 설정\n\n성능 프로파일링에 새로 오신 분들을 위해 Instruments는 별도의 앱으로, Xcode 개발자 도구 메뉴에서 열 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-HighPerformanceSwiftApps_1.png\" /\u003e\n\n저희의 주요 도구인 Time Profiler는 CPU 코어를 모니터링하는 도구입니다. 이 도구는 초당 1000번씩 이 코어들을 샘플링하며 실행 중인 함수들의 스택 추적을 기록합니다. 결과적으로 나타나는 보고서에는 코드의 어떤 부분이 컴퓨팅 자원을 독식하는지 보여줍니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-HighPerformanceSwiftApps_2.png\" /\u003e\n\n이제 모든 설정이 완료되었으니 조사를 시작할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 처리 속도\n\n우리 앱을 열고 알림 재계산을 모니터링하면, Check 'em이 흥미로운 코드를 찾을 때 약 20초 정도 소요되는 비동기 프로세스가 실행되는 것을 볼 수 있습니다.\n\n이를 이해하기 쉽게하기 위해 'Call Tree' 메뉴에서 토글할 수 있는 설정이 3가지 있습니다:\n\n- '스레드별 분리'는 기능 호출을 같은 그룹으로 묶는 대신 프로세스를 스레드별로 분리합니다. 이렇게 하면 병렬로 실행되는 프로세스가 개별적으로 시간 프로필이 표시됩니다.\n- 'Call Tree 반전'은 측정된 되추적(traceback)을 반전시킵니다. 즉, CPU에서 실행되는 저수준 iOS 시스템 호출이 아닌 우리 자신의 기능을 호출 스택 상단에 표시할 수 있습니다.\n- '시스템 라이브러리 숨기기'는 시스템 라이브러리 프로세스를 제거하여 보고서를 정리하고 자신의 코드를 쉽게 찾을 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 우리는 예상대로 백그라운드 스레드에서 발생하는 모든 처리 작업을 쉽게 볼 수 있습니다.\n\n우리의 TOTP 생성은 복잡하지만 매우 명확한 알고리즘을 사용합니다. 만약 이를 가속화하는 방법을 개척했다면, 나는 썬더한 어딘가에서 요트 위에서 이 기사를 쓰고 있을 것입니다.\n\n내가 말하려는 것은, 우리가 이 TOTP 생성 과정을 가속화할 수 있는 새롭고 반짝이는 알고리즘을 찾기는 어렵다는 것입니다. 따라서, 우리는 먼저 OTP.init() 메서드보다 느리게 동작하는 모든 것을 개선하고 싶습니다.\n\n우리는 증거를 찾았습니다. 지금까지 가장 느린 계산은 checkThoseSexts() 메서드인데, 이 메서드는 엄청난 계산 비용이 드는 것으로 보이는 정규식을 감싸고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nextension String {\n    func checkThoseSexts() -\u003e Bool {\n        (try? /(\\d)\\1\\1\\1\\1\\1/.firstMatch(in: self)) != nil\n    }\n}\n```\n\n이런 극도의 부하를 격는 대체 방법으로의 정규식 교체가 성능을 거의 두 배로 향상시킬 수 있을 것으로 생각됩니다.\n\n이 분석을 통해 더 깨달은 것이 있습니다: 이러한 과중 처리는 단일 백그라운드 스레드에서 직렬로 실행되며, 모든 중요한 작업이 고우선순위 인배체 Task로부터 생성된 \\_dispatch_workloop_worker_thread에 전적으로 할당됩니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단일 CPU 코어가 TOTP를 생성하고 그들의 흥미로움을 확인하는 역할만 한다는 뜻입니다. 만일 똑똑하게 처리한다면, 이 프로세스는 병렬화될 수 있을 것입니다.\n\n## 첫 번째 코드 작성 시간\n\n다른 사용자가 직면하는 문제는 앱을 열고 유용한 2단계 인증 코드가 표시되기까지의 상대적으로 느린 시간입니다.\n\n코드에서 찾아야 하는 정확한 시작점과 끝점을 알고 있다면 — 앱을 실행하여 처음 나타나는 코드까지 — print() 문과 타임스탬프를 사용하여 이 문제를 프로파일링할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n07:35:54.2640 - 앱 초기화\n07:35:56.0280 - 코드 표시\n\n```\n\n현재 앱은 앱을 초기화한 후 유용한 2FA 코드를 보는 데 매우 큰 1.764초가 소요됩니다. 출시부터 코드 생성까지의 코드 경로를 따르면 더 명확한 그림이 나타납니다:\n\n```js\n07:50:10.5640 앱 초기화\n07:50:11.1980 나타날 때\n07:50:11.2290 계정 설정\n07:50:12.1630 계정 새로고침\n07:50:12.1640 코드 표시\n```\n\n여기에는 두 번의 비교적 긴 대기 시간이 표시됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 메인 뷰에서 앱 초기화와 onAppear 작동 사이의 시간\n- 뷰 모델에서 계정 설정 및 TOTP 코드를 얻기 위해 이를 새로 고칠 때의 시간\n\n키체인 작업을 통해 계정을 가져오고 이어지는 코드 생성 단계는 실제로 상당히 빠르기 때문에 총 시간에 큰 영향을 미치지 않습니다.\n\n이제 우리는 주요 성능 병목 현상을 확인했으므로, 정확한 코드 개선을 시작할 수 있게 되었습니다.\n\n# 코드 개선\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCheck ‘em의 기본 실행에서 두 가지 성능 문제가 발견되었습니다:\n\n- 수백만 개의 TOTP 처리 및 흥미로운지 확인\n- 초기 2FA 코드의 느린로딩\n\n우리의 자세한 분석을 토대로 우리는 다음과 같은 3가지 구체적인 개선점을 발견했습니다:\n\n- 흥미로움을 평가하기 위해 사용되는 regex를 더 효율적인 알고리즘으로 대체합니다.\n- TOTP와 흥미를 계산하는 병렬성을 도입합니다.\n- 초기 코드 생성을 런칭 후 빨리 실행하도록 변경합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 앱에서 얼마나 많은 속도를 뽑아낼 수 있는지 확인해봅시다!\n\n## 효율적인 알고리즘\n\nInstruments를 사용하여 첫 번째 큰 병목 현상은 느린 정규식으로 발견되었습니다. 총 처리 시간의 50% 이상을 차지합니다.\n\n계산에서는 극히 드물게 발생하는 GET만 사용하여 우리의 결과를 벤치마킹해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n흔하지 않으니까 이 CPU는 이 흥미로운 GET을 찾기 위해 TOTP를 100배 더 많이 연산해야 해요. 그래서 64개의 흥미로운 GET을 찾는 데는 훨씬 더 오래 걸려요.\n\n우리는 시간을 경신해야 합니다!\n\n이 백그라운드 스레드에서 처리에 47초가 걸렸어요. 여기 정규식에 대한 제 첫 번째 대안을 제시할게요. 간단한 문자열 매치 방법을 사용했어요.\n\n```js\nfunc checkThoseSexts() -\u003e Bool {\n    checkRepeatedDigits(count: 6)\n}\n\n// 쿼드와 퀸트를 확인할 수 있도록 잘 구성되어 있어요\nprivate func checkRepeatedDigits(count: Int) -\u003e Bool {\n    (0...9).map {\n        String(repeating: String($0), count: count)\n    }.contains(where: { self.contains($0) })\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번의 단일 기능 변경으로 섹츄플 확인 작업 자체가 10배 이상 빠르게 동작하여 총 연산 시간이 21초로 줄었습니다. 그래 동작이 두 배 가까이 빨라졌어요!\n\n병목 지점에 집중하는 힘을 보여준 거죠.\n\n저는 멋진 코드를 작성했지만 실제로 상당히 비효율적이에요. 000000부터 999999까지 10개의 문자열을 할당하고, 이후에는 섹츄플용 TOTP를 확인할 때마다 O(n) 문자열 일치 작업을 수행하고 있습니다. 따라서 이 작업은 여전히 TOTP 생성 자체에 이은 두 번째로 무겁고 이루어지고 있어요.\n\n더 간편한 방법이 있습니다. 수 많은 숫자 목록을 하드코딩하는 방식이죠. 이를 통해 비용이 많이 드는 문자열 할당을 반복하는 일을 피할 수 있어요. 우리는 퀘트, 퀸트, 그리고 카운팅을 찾는 무거운 작업에도 동일한 방법을 적용할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// Interestingness.swift\n\nfunc checkThoseSexts() -\u003e Bool {\n    Self.sexts.contains(self)\n}\n\nprivate static let sexts: Set\u003cString\u003e = [\n    \"000000\",\n    \"111111\",\n    \"222222\",\n    \"333333\",\n    \"444444\",\n    \"555555\",\n    \"666666\",\n    \"777777\",\n    \"888888\",\n    \"999999\"\n]\n\nfunc checkThatCounting() -\u003e Bool {\n    Self.counting.contains(self)\n}\n\nprivate static let counting: Set\u003cString\u003e = [\n    \"012345\",\n    \"123456\",\n    \"234567\",\n    \"345678\",\n    \"456789\",\n    \"567890\"\n]\n```\n\nWe’ve handily eliminated the biggest bottleneck: The checkThoseSexts method has gone from a cumulative time of 27.54s to just 899ms — a 30x increase in speed.\n\nNow, this gives me a bright idea.\n\nThere are only 1 million possible 6-digit TOTPs. Perhaps, as an upper bound, 1 in 100 are interesting*.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만 가지 숫자는 그리 크지 않아요. 이들을 사전(dictionary)과 같은 효율적 데이터 구조에 저장하고, 메모리에 보관하여 어렵지 않게 처리할 수 있습니다. 이렇게 하면 메모리에서 관심 있는 정보를 O(1) 연산으로 조회할 수 있어요.\n\n게다가, 이 방법은 사용자로부터 연산을 내 맥북에게 넘기고 환경을 보호할 수 있어요.\n\n하지만, 이것은 밝은 아이디어이긴 하지만 병목 현상이 아니에요! 그래서 지금은 안타깝지만 이것을 저지를 것 같아요. TOTP 계산이 처리 시간의 대부분을 차지하고 있거든요.\n\n이것은 CPU 코어를 활용하는 적절한 시기입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 병렬 처리\n\n현재 모든 계산은 단일 백그라운드 스레드에서 수행됩니다. 이를 어떻게 개선할 수 있을지 고민 중이었어요.\n\n자연스러운 아이디어는 TOTP 계산을 '청크 단위'로 분할하고 각 청크를 다른 스레드에 넣는 것일 것입니다. 그런데 이 청킹을 어떻게 적용할 수 있을까요?\n\n일별, 주별 또는 월별로 그렇게 할 수는 없어요. 왜냐하면 우리가 사용하지 못할 정도로 많은 계산을 실행할 수도 있습니다 — iOS에서는 한 번에 최대 64개의 알림을 예약할 수밖에 없거든요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n복잡성을 최소화하는 방법을 찾아봅시다.\n\nCPU 아키텍처를 가이드로 삼아보죠: 현대 iPhone 프로세서에는 6개의 코어가 포함되어 있습니다. 그러므로 동시에 6개의 청크를 사용하는 것을 목표로 합시다. taskGroup을 사용하여 이 6개의 병렬 프로세스를 설정할 수 있습니다.\n\n```js\n// CodeViewModel.swift\n\notpComputationTask = Task.detached(priority: .high) {\n    await withTaskGroup(of: Void.self) { group in\n        (0..\u003c6).forEach { startingIncrement in\n            group.addTask {\n                CodeGenerator.shared.generateCodes(\n                    accounts: accounts,\n                    startingIncrement: startingIncrement\n                )\n            }\n        }\n    }\n}\n```\n\n이후, 이 6개의 병렬 프로세스를 실행하여 미래로부터 매 6번째 TOTP 코드를 계산할 수 있습니다. 각 프로세스는 총 흥미로운 숫자 중 1/6을 찾으면 종료됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n// CodeGenerator.swift\n\nfunc generateCodes(accounts: [Account], startingIncrement: Int) {\n    var increment = startingIncrement\n    var interestingCodesCount = 0\n    while Double(interestingCodesCount) \u003c (Double(Constants.localNotificationLimit - 2) / 6).rounded(.up) {\n        // TOTP calculation ...\n        increment += 6\n    }\n}\n```\n\n이것은 더 빠르게 처리되는 것 같았지만 완전히 UI가 멈춰 버렸어요. TOTP 코드를 처리하는 동안 앱이 거의 멈추고 응답하지 않았어요.\n\n이는 6개의 고우선순위 프로세스를 한 번에 강제로 일어나게 해서, 메인 스레드가 이 비용이 많이 드는 계산과 렌더링 주기를 공유해야 했기 때문이에요.\n\n이는 6개의 코어를 가진 많은 오래된 아이폰에서 더욱 나빠질 것입니다. 그래서, 프로세스의 수를 CPU 코어당 하나로 제한하고, UI 스레드를 위한 하나의 코어를 여분으로 남겨두는 것이 좋겠어요.\n\n`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nProcessInfo.processInfo.processorCount - 1\n```\n\n이야~ 이제 꼭 좋아졌네요! 이렇게 하면 5개의 무거운 작업 쓰레드와 한 개의 아주 차분한 UI 쓰레드가 나올 거예요. 홈으로 돌아가서 손 편지를 쓸 만큼의 지루한 시간은 전혀 없어요.\n\n병렬 처리를 통해 우리가 가장 멀리 호송시키던 쓰레드의 처리속도를 최악 6.74초로 낮춰버렸어요. 이전의 15.37초 대비 56% 감소했답니다.\n\n우리는 5개의 코어를 사용하고 있어요. 왜 이건 깔끔하게 5배 더 빨라지지 않는 걸까요?```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 수학과 배우들\n\n우리의 방식에는 여전히 문제가 있습니다: 각각의 n개 스레드는 독립적으로 흥미로운 숫자를 찾습니다. 그 숫자는 64/n을 찾을 때까지 계속 찾고 있습니다.\n\n가장 빠른 스레드는 다음 2주 이내에 64/n개의 코드를 모두 찾을 수 있고, 가장 느린 스레드는 운이 나쁘면 다음 달까지 앞으로 계속해서 계산할 수 있습니다 — TOTPs는 30초 간격으로 배치되어 있으며 코드의 흥미로움은 무작위로 분포됩니다.\n\n이 문제는 두 가지 측면으로 나뉩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 먼저, 일부 스레드에서 숫자를 너무 많이 세고, 다른 스레드에서는 너무 적게 세어 잠재적인 숫자들을 놓치고 있습니다.\n- 둘째, 스레드가 처리하는 시간이 매우 다르기 때문에 각 스레드가 정확히 동일한 시간을 소요하는 것에 비해 CPU를 효율적으로 활용하지 못하고 있습니다.\n\n이에, 각 스레드가 독립적으로 실행되어 다음 미계산 코드를 계산하도록 하는 대신, 오프셋에서 작업하는 대신 다음 미계산 30초 날짜 증가를 사용하도록 보장하고 상태를 안전하게 공유할 수 있는 방법이 필요합니다.\n\nSwift는 이 문제에 Actors로 깔끔한 해결책을 제공하며, Actors는 상태에 대한 직렬 액세스를 강제합니다.\n\n```js\n// CodeIncrementor.swift\n\nactor CodeIncrementor {\n\n    private var _increment: Int = 0\n\n    func increment() -\u003e Int {\n        defer { _increment += 1 }\n        return _increment\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 병렬화 시도와 비교했을 때, 각 스레드가 독립적으로 모든 5번째 TOTP를 계산하는 것을 허용했던 방법과 달리, 이 접근 방식은 프로세스 간의 조정이 필요합니다.\n\n이 조정은 추가 오버헤드를 발생시킵니다. 각 프로세스는 개별적으로 약간 느려지며, 이는 액터의 시리얼 익스큐터에서 increment()를 호출하기 위해 기다려야 할 수 있기 때문입니다. 한 번에 한 프로세스만이 이를 호출할 수 있습니다.\n\n결과적으로 increment()가 호출될 때마다, 스레드는 올바른 오프셋을 안전하게 얻을 수 있으므로, 우리는 다음에 계산되지 않은 TOTP 코드만 계산하여 그 흥미로움을 평가할 수 있습니다.\n\n```js\n// CodeGenerator.swift\n\nfunc generateCodes(accounts: [Account], incrementor: CodeIncrementor) async {\n    // ...\n    while Double(await incrementor.codes) \u003c (Double(Constants.localNotificationLimit - 2)) {\n        let increment = await incrementor.increment()\n        // 날짜 증분에서 TOTP 생성 ...\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 얼마나 성능을 발휘하는지 측정해 봅시다!\n\n이 액터 기반 접근 방식은 한 번에 여러 개의 스레드를 생성합니다. Swift 동시성은 CPU 코어 당 대략 하나의 스레드가 실행되도록 하여 초기 병렬성 목표에 부합하며, 시스템 인식 협력 스레드 풀을 사용하여 스레딩을 관리합니다.\n\n기기의 instruments에서 제공된 총 누적 실행 시간은 각 스레드별로 합산된 것입니다. 이는 물론 사용자가 기다리는 시간을 대변하는 것은 아닙니다. 적절한 측정을 위해 다시 한 번 신뢰할 수 있는 타임스탬프를 사용하여, 초희귀 GET에 대한 흥미로움 계산의 총 속도를 측정해 봅시다.\n\n## 병렬성이 없는 원래 스피드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n23:10:55.2940 Computation 시작\n23:11:09.9220 Computation 완료\n\n\n총 14.628초 소요됐습니다.\n\n## 청킹과 (n-1) 쓰레드를 사용한 속도\n\n\n23:07:00.4700 Computation 시작\n23:07:09.5980 Computation 완료\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n9.128 seconds in total.\n\n## Actor 협조를 사용한 속도\n\n```js\n23:01:38.7080 계산이 시작됨\n23:01:46.5300 계산이 완료됨\n```\n\n7.822 seconds in total.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 액터를 사용하여 추가 쓰레드 조절 오버헤드를 감당할 가치가 있다는 것을 보여줍니다. 이 프로세스는 더 정확하고 CPU 코어를 더 효율적으로 활용하며, 전체적으로 이 계산 단계를 47% 빠르게 만듭니다!\n\n# 이전 코드 생성\n\n우리의 성능 프로파일링의 마지막 단계에서, print 문과 타임스탬프를 사용하여, 우리의 유저들에게 유용한 2단계 인증 코드가 나타나기 전에 두 가지 큰 대기 상태를 발견했습니다: 메인 뷰에서 onAppear를 기다리는 것과 코드 자체를 refresh() 하는 것을 기다리는 것입니다.\n\n```js\n// CodeView.swift\n\n@State private var viewModel = CodeViewModel()\n@State private var timer = Timer.publish(every: 1, tolerance: 0, on: .current, in: .common).autoconnect()\n\nvar body: some View {\n    // ...\n    .onReceive(timer) { _ in\n        viewModel.refresh()\n    }\n    .onAppear {\n        refreshUI()\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 onAppear가 나타나도록 기다렸다가 뷰 모델에서 계정을 설정하고, 1초 타이머가 작동할 때 다시 기다립니다.\n\n이는 매우 간단한 수정입니다: 뷰 수명주기 이벤트에서 계정 가져오기 및 TOTP 계산을 분리합니다.\n\n```js\n// CodeViewModel.swift\n\nfinal class CodeViewModel {\n\n    init() {\n        timestamp(\"View model init\")\n        configureAccounts()\n        refresh()\n    }\n\n// ...\n```\n\n앱 로드와 코드 생성 간의 시간이 1.764초에서 0.400초로 대폭 줄어듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n20:41:35.6890 앱 초기화\n20:41:36.0830 뷰 모델 초기화\n20:41:36.0890 코드 표시됨\n```\n\n이제 코드들이 거의 즉시 화면에 나타납니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Z78ZtydZwUrguRDZel0d1w.gif)\n\n# 결론\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCheck ‘em — The Based 2FA App은 제가 사이드 프로젝트로 만들었던 열정적인 아이디어였는데, 정말 즐거운 시간을 보냈어요.\n\n제가 기대하지 못한 것은 두 번째(v1.1) 릴리스의 중심에 극도로 흥미로운 성능 최적화 퍼즐을 만날 것이었다는 것이에요.\n\n지금은 앱이 최고로 돌아가고 있어요:\n\n- 2FA 코드가 시작하자마자 나타나요.\n- 흥미로운 코드를 찾는 알고리즘이 훨씬 빠릅니다.\n- 강력한 멀티 코어 CPU가 병렬 계산으로 완전히 활용되고 있어요.\n\n","ogImage":{"url":"/assets/img/2024-05-23-HighPerformanceSwiftApps_0.png"},"coverImage":"/assets/img/2024-05-23-HighPerformanceSwiftApps_0.png","tag":["Tech"],"readingTime":14},{"title":"안녕하세요 안드로이드 프로젝트에서 자주 마주치는 성가신 문제들을 살펴보겠습니다 함께 해요","description":"","date":"2024-05-23 15:00","slug":"2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects","content":"\n한 회사에서 오래 일하지 않으면 다양한 단계의 여러 프로젝트에 참여할 기회가 많지 않을 수 있습니다. 이러한 경험을 통해 작은 개인 프로젝트나 대규모 기업의 어려움을 보게 될 수 있습니다.\n\n많은 문제가 종종 무시되고 이로 인해 예상치 못한 문제나 버그가 발생할 수 있습니다. 이 중 일부는 매우 쉽게 해결할 수 있고 프로젝트를 조금 더 쉽게 이어나갈 수 있게 해줍니다. 여기에는 대부분 안드로이드 애플리케이션 개발과 관련된 권장 사항이 포함되어 있지만 대부분의 내용은 어떤 기술의 프로젝트에도 적용됩니다. 이것은 대부분 개인 경험과 실패의 모음인데, 다른 사람의 실수로부터 배우는 것이 더 재미있지 않을까요?\n\n# 프로젝트 구조\n\nIDE가 처음부터 새 프로젝트를 생성하면 프로젝트에 불필요하거나 방해가 되는 많은 파일과 폴더가 생성될 수 있습니다. 여기서 기본 구조와 작업해야 하는 구성 요소를 이해하는 것이 중요합니다: 모듈, 구성, 아무도 작성하지 않을 테스트 😁\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.gitignore 파일을 살펴보면, 대략 20-30개의 규칙이 있을 겁니다. 대부분이 다섯 가지 경우에 사용되지만, 그 중에도 종종 부적절하게 기재된 경우가 많습니다. local.properties가 프로젝트에 추가된 적이 있다면, 실제로는 무시 목록에 포함되어 있지만 IDE가 신경을 쓰지 않을 수도 있습니다. 그런 소프트웨어를 믿을 이유가 있을까요?\n\n언제나 더 나은 방법이 있을 수 있습니다. 한 회사에서 첫 근무일에 안드로이드(1.5GB)와 iOS(4.5GB) 저장소를 다운로드해야 했던 적이 있었습니다. 문제는 선배들이 Google Play에 업로드된 애플리케이션의 모든 버전을 프로젝트에 커밋했기 때문에 저장소가 비합리적으로 커진 것이었습니다. 이 프로젝트를 빌드하고 몇 가지 테스트를 실행해야 할 때마다 CI/CD가 이 프로젝트를 클론해야 하는 상황을 생각해보세요 😉\n\n내가 알기로는 각 빌드에는 대략 40분이 걸렸던 것 같네요. 가장 흥미로운 점은 git 히스토리를 정리함으로써 해결할 수 있다는 것이었습니다. 실제로 이것을 시도해 보았고, 그 결과 프로젝트 크기가 1.5GB대 대신 100MB가 되었습니다. 그러나 이것이 최종적으로 해결되었는지 여부는 저에게는 알 수 없습니다.\n\n\n![안드로이드 모바일 프로젝트에서의 귀찮은 문제들](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_0.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난에 개발한 기능 중 하나로 프로젝트에서 천 개 이상의 파일을 제거했어요. 클릭베이트 제목으로 좋을 거예요, 하지만 실제로는 훨씬 간단해요 — 이전 담당자가 TypeScript 프로젝트를 Android 프로젝트로 복제했을 때, 전체 node_modules 폴더를 커밋하지 않고 얼마 전 사용한 노드 모듈 폴더(.gradle이나 build 폴더와 유사한)를 포함했어요. 왜냐고요? 다행히 매달 또는 두 달에 한 번 특별한 파일을 생성하고 그 파일을 프로젝트에 사용할 수 있게 하기 위해서예요. 왜 별도의 IDE에서 프로젝트를 열고 거기서 코드 생성을 하지 않을까요? 저도 잘 모르겠어요.\n\n![2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_1.png] (/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_1.png)\n\n좋은 방법 중에 템플릿이 언급될 수 있어요. 이 기능 덕분에 프로젝트를 한 번 생성하고 필요에 딱 맞게 만들어진 구조를 사용할 수 있어요. 특히 많은 마이크로서비스를 보유한 회사에게 관련이 있어요.\n\n# 읽어볼 내용이 없어요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_2.png\" /\u003e\n\n프로젝트를 열 때 빌드되지 않는 문제에 대한 이야기를 남겨보세요. 또는 몇 시간 동안 그 문제를 해결하기 위해 애쓰게 되는 경험에 대해 이야기해보세요.\n\n한 번만 개발 환경을 설정하는 데 도움을 받을 수도 있지만, 새 노트북을 사용하거나 새로운 동료가 합류할 때마다 동일한 문제가 반복되곤 합니다.\n\nREADME를 만들기 위해서만 만드는 것은 가치가 없죠. 종종 적절한 명명법으로 이미 명확한 모듈 설명이나 2년 전에 유효했던 문서들을 볼 때가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n누군가가 모바일 개발자가 아닌 사람이 모바일 프로젝트를 열면, 반대의 경우도 마찬가지지만, 무언가를 빌드할 수 없다면 먼저 README를 확인할 것입니다. 특히 iOS 프로젝트에서는 여전히 pods를 사용하는 경우나 Docker 또는 다른 설정이 많이 필요한 프로젝트의 경우에 이는 특히 흔합니다.\n\n꽤 좋은 습관은 그 공정들과 모든 스크립트들을 설명하는 것입니다. 그 공정들이 뒷담화처럼 작동하는 것에 대해, 그것들을 자동화하기 위해 한 주 동안을 쏟아부었지만 한 시간 안에 할 수 있는 일을 한 주 쏟아 부을 수도 있습니다.\n\n# 설정 파일 없음\n\n불일치하는 간격으로 커밋을 자주 보곤 했나요? 동료들이 코드를 마음대로 서식을 맞추다보면 모든 것이 엉망이 되고, 다음 코드 리뷰에 +100500줄을 추가하는 일이 벌어지곤 했나요? 또는 변경된 파일마다 imports가 뒤죽박죽이 되어 충돌을 수동으로 해결해야 하는 경우가 있긴 했나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 이슈는 코드 스타일, EditorConfig 및 정적 분석과 함께 Reformat 코드 기능으로 쉽게 해결할 수 있어요.\n\n가장 중요한 점은 귀하의 팀(또는 권한이 충분하다면 개인적으로)이 특정 규칙을 모두가 동일하게 준수해야 한다고 결정하고 이를 따르아야 한다는 것입니다. 이러한 구성은 프로젝트에 추가되어 IDE가 모두에게 동일한 설정을 지정할 수 있게 합니다. 코드 포맷팅 덕분에 수입, 들여쓰기, 형식 지정 및 일반적으로 코드 리뷰 중에 거슬리는 다른 사항들에 대한 문제가 더 이상 발생하지 않을 거예요.\n\n# 의존성 업데이트\n\n![의존성 업데이트](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 귀찮은 일에 대해 신경 쓸 필요는 없을 수도 있지만, 고객은 생산성에서 안정성을 요구할 것입니다... 기술적 부채 티켓을 만들어 동료 / 관리자 / 고객에게 이 단계의 중요성을 설명해 보는 게 좋겠죠. 이런 문제가 있는 여러 프로젝트를 상기하며, 개인적으로 문제를 겪었던 한 가지 사례가 있었어요 :)\n\nGoogle은 단순히 targetSDK를 올리지 않으면 업데이트를 거부했는데 (안드로이드 개발자들에게 큰 고통이었습니다), 이 지원에 상당한 시간이 필요했죠. 그래서 모든 노력이 새로운 OS 버전 지원이 추가된 앱의 새 버전을 준비하는 데 집중되어, 클라이언트는 제때 업데이트를 받지 못했어요.\n\n또한 특정 사용자들이 구글 라이브러리 버전의 버그로 인해 충돌이 발생하기도 했었는데, 매우 드문 일이었지만 실제로 발생했습니다. 그 버그는 스택 트레이스를 남겨두었는데 원인이 명확하지 않았어요. 라이브러리를 업데이트하고 나서 그 충돌은 발생하지 않았습니다.\n\n한 번은 프로젝트에서 난독화가 활성화되어 있었는데, 긴급하게 업데이트를 릴리스해야 해서 GSON을 업데이트하지 않고 AGP만 업데이트했던 적이 있었어요. 라이브러리를 업데이트하려면 특정 이주가 필요했습니다. 문제는 테스터들이 조금 다른 앱 버전을 가지고 있었고, 그것이 나중에 Google Play에 릴리스된 것이었지만 라이브러리는 새 AGP 규칙을 준비하지 못했단 거죠. 그 결과, 난독화로 네트워크 모델의 필드가 제거되었습니다. 충돌은 없었지만 앱의 주요 기능이 중단되어 데이터의 절반이 손실된 채로 남았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 건축의 부재/“건축”의 존재\n\n아, 파트타임 직업 또는 더 나쁜 경우, 본 업무에서 프로젝트를 열고 난 후, 필요한 파일을 찾을 수 없거나 프로젝트에 있는 전반적인 기능을 이해하는 데 고난을 겪고 있는 상황이군요. 다중 모듈 아키텍처, 추상화, 깔끔한 코드? 그런 건 잊어버리세요. 나중에 아무도 읽지도 유지 보수하지도 않을 거고, 일 년 후에는 버려지고 처음부터 다시 쓰여질 가능성이 높습니다. 그렇게 된다면 괜찮겠지만, 분명히 당신 다음에 누군가 새로운 기능을 추가할 것이고 그 후에 젠장할 것입니다.\n\n한 번, 고객이 6개월 동안 6명의 다른 사람들에 의해 작성된 약 열 개의 문제를 고치라고 요청했던 적이 있었습니다. 어려웠나요? 그런 것은 별로 어렵지 않았습니다. 왜냐하면 프로젝트 자체가 기술적으로 복잡하지 않았기 때문이죠. KMM에서 상업적 경험이 전혀 없는 사람들이 작성했으며, 앱 자체는 주요 복잡성이 항상 비즈니스 로직에 있었습니다. 그래서 대부분은 보이기-편집하기-보내기-다시 모든 것을 보이는 종류의 앱이었습니다.\n\n이 프로젝트에서 가장 큰 문제는 유증의 열망이 놀랍게도 있었다는 것이었습니다. 매우 단순하고 명백한 기능마다 함수 입력 매개변수를 사용할 수 있는데도, 사용 사례가 만들어지고 한 번만 사용되었습니다. 더 나쁜 점은 수량조차 것이 아니라 여러 사용 사례의 카스케이드 사용이었는데, 디버깅을 믿을 수 없을 정도로 어렵게 만들었으며, 브레이크포인트의 수가 IDE를 넘도록 압도했습니다. 그 뿐만 아니라 이러한 것들은 비동기 함수조차 아니라 예전의 콜백 지옥이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_4.png)\n\n# 댓글\n\n지혜로운 사람들은 코드가 주석 없이도 명확해야 한다고 말합니다. 그렇게 해야 한다는 조언은 귀중하지만 비즈니스에서 요구사항이 나타나면 완벽한 코드에 큰 지팡이를 삽입해야 한다는 요청이 옵니다. 지금 이 작업을 기억하지만 한 달 후 성공적으로 잊을 겁니다.\n\n무언가를 문서화해야 한다고 생각된다면, 그것이 다소 명백하다 해도 수행해야 합니다. 그리고 올바른 Git 전략과 관련하여, 나중에 요구사항을 쉽게 파악하고 코드를 작동 상태로 유지하는 지팡이가 무엇인지 이해할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_5.png\" /\u003e\n\n# 정적 분석\n\n하지만 모든 동료가 코드를 완벽하게 서식 지정하기 위해 두 개의 버튼을 누를 것은 아닙니까? 그래서 프로젝트에 린터를 설정하는 가치가 있습니다. 전반적으로 그들은 좋은 목적을 갖고 발명되었으며 릴리스 시에 끄지 않도록 해야 합니다.\n\n정적 코드 분석 덕분에 사람 눈으로는 보이지 않거나 단순 부주의로 인해 발생할 수 있는 다양한 종류의 버그를 예방할 수 있습니다. 프로젝트에서 표준 Android 린터를 사용하여 리소스 관련 문제에 대해서는 꽤 좋거나 코드에 대한 추가적인 린터를 사용할 수 있습니다. 저는 현재 ktlint를 사용 중이며, 프로젝트마다 동반되는 제 자체 gradle 플러그인과 .editorconfig를 사용하여 코드 분석을 수행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n팀원 전체에 이메일을 보내고, 모든 빌드가 초록색이 될 때까지 코드 리뷰를 하지 말겠다는 합의를 한다는 것은 코드 청결도에 대한 좋은 동기부여가 될 수 있습니다.\n\n![AnnoyingproblemswithAndroidmobileanyprojects](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_6.png)\n\n# 프로젝트 속 쓰레기\n\n프로젝트를 여는데, 알 수 없는 개발자가 넣은 무서운 라이브러리가 있고, 이를 이 프로젝트로 끌어들인 동료는 이제 오랫동안 프로젝트를 떠난 자이며, 당신의 차례로 영어로 된 메뉴얼을 읽어야 할지도 모릅니다. 이를 경험하지 못한 경우 정말 운이 좋습니다! 저는 그렇게 운이 좋지 않았으니, 최근 기억에 남는 몇 가지 사례를 소개해 드릴게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 프로젝트에서는 난독화가 없으며, 앱은 다이어트를 해야 할 것 같아요. 호기심에 한 번 앱의 용량을 확인해보았더니 익숙하지 않은 폴더가 5-6MB 가량 있었는데 APK 자체는 52MB만 있더라구요. 의존성을 확인하고 구글링을 좀 해보니 PDF 파일을 표시하기 위한 라이브러리라는 것을 알게 되었는데, 추가 의존성도 몇 메가 바이트에 달하는 크기였어요. 만약 고유한 프로젝트이거나 최대한 유연성이 필요한 경우였다면 납득할 만했겠지만, 안 들리는데로 PDF를 표시하기 위한 기능은 이미 안드로이드 SDK에 있는 것을 이미 알고 있는 거죠. 총알 문서를 읽고 프로그래밍을 한 시간 했더니 모든 것이 정말 원활하게 작동했어요. 한 시간 뒤에는 삭제된 컴포넌트를 찾아내게 되어 앱이 총 12MB나 다이어트를 성공한 셈이 되었어요.\n\n작년 이맘때부터 White Label 원칙에 따라 만든 하이브리드 애플리케이션에 대해 일해오고 있는데, 이 해결책은 거의 모든 고객에게 적용할 수 있지만 특정 구성을 통해 다른 클라이언트를 위해 기능을 맞춤화하고 확장할 수 있어요. 많은 도전이 이미 있었는데, 그 중 하나는 Compose를 사용하여 화면 탐색을 하는 라이브러리였어요. 이 솔루션을 사용하는 것이 간단하다고 말하기는 조금 과장되었을 것이고, 조금 전에 팀이 해당 라이브러리를 프로젝트에서 제거할 계획이라는 것을 알게 되었어요. 안드로이드에서 탐색을 한 번 다뤄본 적이 있다면, 단계적으로 할 수 있는 것이 아니라 한꺼번에 모든 것을 이주해야 하는 과정이 필요하다는 것을 이해하실 겁니다. 알 수 있는 한, 프로젝트에 대한 부적절한 의존성 선택은 장기적으로 도태되는 손해를 일으킬 수 있습니다.\n\n![annoyingproblemswithAndroidmobileanyprojects](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_7.png)\n\n### 난독화 없음 / 리소스 축소\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 개발자들이 이러한 설정을 조정하는 것을 정말 싫어합니다. 앱을 심각하게 망가뜨릴 수 있기 때문에 그것들을 비활성화하고 테스트를 시작할 때까지 어디가 문제인지 알 수 없을 수도 있습니다. 또한, 여러 사용하지 않는 자원을 제거할 수 있게 해주어서 애플리케이션의 크기에 상당한 영향을 미칩니다. 특히 Compose를 사용할 때 그 효과가 좋습니다.\n\n![이미지](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_8.png)\n\n# Git 전략이 없음\n\nParticular Software의 분산 시스템 디자인 기초 과정에서는 기업의 창립자가 개발 경험이 15년 이상인 사람들에게 커밋의 이름 짓는 것이 매우 중요하다고 얘기합니다. 아니요, 농담이 아닙니다. 이 문제는 일반적으로 자주 언급되지 않지만 개발 과정에서 매우 중요합니다. \"수정\"이라는 텍스트로 커밋을 푸시할 수 있는 상황에서 꼭 신중하게 작성해야 할까요? 좀 더 자세히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 브랜치 명명에 대해 알아보겠습니다. 프로그래머들은 종종 대량의 코드 개정을 동시에 다루는데, 현재 보고 있는 코드 버전이 무엇인지 정확히 이해하는 것이 중요합니다. 올바른 브랜치를 찾아야 하거나 비슷한 이름을 가진 여러 개의 브랜치 중 하나를 선택해야 할 때, 때로는 필요한 종류를 찾아야 할 수도 있는데, 이는 혼란스럽고 시간이 오래 걸릴 수 있습니다. 팀이 특정 유형의 구조에 합의했다면, 모든 것을 간단하게 만들 수 있습니다. 이 경우 cicd/sonar-cube-check-implementation 또는 bugfix/superuser-right-are-not-properly-assigned, 또는 feature/property-detail-screen과 같은 네이밍 규칙은 각 브랜치에 무엇이 있는지 논리적으로 이해하는 데 도움이 됩니다.\n\n또한 GitHub, JIRA 또는 다른 도구와 같은 이슈 추적 시스템과 버전 관리 시스템 간의 강력한 통합에 대해 이야기해볼 가치가 있습니다. cicd/123-sonar-cube-check-implementation과 같이 브랜치를 명명하면, 여기서 123은 이슈나 티켓 번호이며, 시스템은 자동으로 이를 연결하여 해당 이슈 범위 내에서 어떤 변경 사항이 있었는지와 현재 브랜치 상태를 확인하는 데 도움을 줍니다. 항상 혼란을 예방하는 것은 아니지만, 한 번 EM이 티켓에서 브랜치가 병합되었음을 보고 클라이언트에게 전달했지만, 프로젝트가 무언가 문제를 일으키는 git 전략을 가지고 있어 잘못된 위치로 병합되었음을 못 봤던 적이 있었죠. 하지만 상황을 빠르게 이해하는 데 도움이 되죠.\n\n커밋 메시지에 대해 이야기해보자면 - 주로 한 두 단어만 적힐 때가 많은데도 50개의 파일이 변경될 수 있습니다. 이제 한 브랜치에 10개의 커밋이 있다고 상상해보세요. 그리고 10개의 커밋이 모두 \"fixes\"라고 한다면 어떨까요? :)\n\n순전히 실용적인 관점에서, 동료들을 통해 경험적으로 테스트한 결과, 다음 유형의 통합이 상당히 잘 작동하는 것으로 밝혀졌습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 브랜치 가시성: 작업 X를 나타내는 브랜치가 사라지지 않아요. 매니저는 개발자가 작업 상태를 업데이트하는 것을 잊어도 언제든지 작업이 진행 중인지 완료된 상태인지 확인할 수 있어요.\n- 작업 기록: 작업 X에서는 6개월 지난 후에도 완료하기 위해 변경된 모든 파일을 찾을 수 있어요. \"이 작업 기억 나요? 다시 모두 다시 해야 해\"라는 비즈니스 요구가 오더라도 변경된 로직을 찾는 데 시간을 낭비할 필요가 없어요. 나중에 이 작업을 수행하는 다른 사람들이 있더라도 작업 기록에 액세스하여 관련 히스토리를 확인하기 쉽게 해요.\n- 명확한 커밋 메시지: 각 커밋은 명확하게 설명되고 작업에 연결돼요. 작업이 커밋 하나로 완료됐더라도, 나중에 개발자가 변경이나 추가 사항이 필요하다는 것을 깨달아 작업 X의 일부인 경우가 있어요. 그럼 이런 경우에는 히스토리에 작업 X와 관련된 두 개의 커밋이 남아 있어요.\n- 커밋 사이의 이동이 쉬워요: 큰 기능이 포함된 10개의 커밋이 있는 상황을 상상해보세요. 어떤 중요한 부분을 찾아야 할 때나 기능이 어디서 망가졌는지 확인해야 할 때 유용해요. 특히 큰 기능이나 오랜 기간동안 중요한 정보를 찾아야 할 때는, 구조화된 메시지에서 한 단어 메시지보다 요지를 파악하기 훨씬 쉬워요.\n\n당연히 이 방법이 여러분과 팀에 적합하지 않을 수도 있지만, 어떤 형태로든 존재함으로써 팀의 작업을 크게 간소화할 수 있어요.\n\n![Annoying problems with Android mobile any projects](/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_9.png)\n\n# CI/CD 설정 오류 및 미구성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 인터뷰 중에, 어떤 개발자가 CI/CD가 필요하지 않다고 주장했어요. 그 이유는 자신의 노트북에서 어플리케이션을 원활하게 빌드할 수 있도록 도와주는 작은 스크립트가 있기 때문이라고 했어요. 실제로 그의 주장은 옳았습니다. 그가 이 프로세스를 최적화하고 완벽한 빌드를 격리된 환경에서 작업할 수 있었으니까요. 그러나 보다 심각한 프로젝트에 대해서는 CI/CD가 꼭 필요하고 시간을 절약할 수 있어요.\n\n예를 들어, 하나의 화이트라벨 제품을 다루는 회사가 있었는데, 이 제품은 여러 가지 설정을 가지고 있었고 수작업으로 배포 과정이 매우 느렸어요. 어플리케이션을 빌드하고 필요한 곳에 배포하는 것을 상상해보세요. 일반적으로 이 프로세스는 수작업으로 약 10분이 소요되었습니다. 그런데 만약 20개, 50개, 100개 이상의 어플리케이션이 필요하다면 어떨까요? 그리고 이미 테스트된 것이 출시 준비가 된 상태인데도 개발자가 휴가 중인 경우 어떡하죠? CI/CD 덕분에 이 프로세스를 자동화하고 최대한 빠르게 만들었어요. 병렬화를 통해 모든 클라이언트가 15분 내에 배포를 받을 수 있게 되었죠. 비즈니스에게는 모든 것을 자동화하는 것이 편리하고, 개발자에게는 단조로운 작업을 하지 않고 해낼 수 있는 점이 편리합니다.\n\n또한 모바일 데브옵스 같은 사람들이 이러한 프로세스를 설치하는 경우가 있다는 것도 언급할 가치가 있어요. 멋진 회사에서는 이들이 모바일 작업방식을 잘 이해하고 필요한 모든 작업을 처리하는 똑똑한 사람들입니다. 그런데 모든 사람이 그만큼 능숙한 것은 아닐 수 있어요. 미국 스타트업에서 안드로이드 아키텍트로 일했을 때, 빌드 컴파일 시간에 상당한 영향을 미치는 문제를 발견했습니다. 기억하시다시피, assemble이라는 gradlew 작업이 있어요. 기본적으로 모든 버전의 어플리케이션을 빌드합니다. 한 번에 빌드하는 데 15분이 걸린다면, 어플리케이션이 2가지 설정이 있다면 이 작업은 필요한 하나만을 빌드하는 데 1시간이 걸릴 거예요. CI/CD 파이프라인 관점에서 모든 것이 잘 설정되어 있었지만, 이 필요성을 이해하고 올바른 구성 조정을 할 수 있는 사람은 모바일 개발자만 알 수 있는 사실이죠.\n\n\u003cimg src=\"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_10.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지 여기까지입니다. 목록이 완전하지 않고 무작위이며 추가할 주제가 있습니다. 개발자가 APK를 이메일로 보내거나 슬랙에 게시하는 프로젝트를 진행해본 적이 있다면 댓글에 작성해 주세요. 또한 다른 프로젝트에서 자주 마주치는 문제를 공유해주세요.\n","ogImage":{"url":"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_0.png"},"coverImage":"/assets/img/2024-05-23-AnnoyingproblemswithAndroidmobileanyprojects_0.png","tag":["Tech"],"readingTime":12},{"title":"첫째 날 - M4 iPad Pro","description":"","date":"2024-05-23 14:58","slug":"2024-05-23-1stDayM4iPadPro","content":"\n\n![iPad Image](/assets/img/2024-05-23-1stDayM4iPadPro_0.png)\n\n이제 iPad를 완전 활용할 날이에요.\n\n콘텐츠를 만드는 것은 조금 이따긴 하지만 이상한 거예요. 48시간 전 오늘 iPad와 함께 보낸 첫날, 거의 사용할 기회가 없었어요. 그 날은 iPad의 B롤 샷을 찍고 첫 생각을 다룬 비디오를 만드는 데 시간을 보내다 보니 거의 사용하거나 만지작거리기조차 하지 못했어요. 상자에서 꺼내 셋업하는 것 말고는 아무것도 하지 않은 채로였죠. 밤 11시쯤 '놀이'를 시작하고 앱에 로그인하며 그것을 내 것으로 만들기 시작한 거예요.\n\n어제는 몇 가지 미팅 때문에 런던에 있었어요 - 그리고 그 중 유일하게 이상한 점은 집을 떠날 때 아이폰 이외의 기기가 iPad 뿐이었어요. 몇 시간 동안 밖에 나갈 때 거의 항상 Mac을 들고 다니는 편이에요. 그래서 더 쉽게 작업할 수 있죠. 하지만 어제 MacBook Air를 집에 두고 나갔다는 건 조금 이상했어요 - 마치 벌써 기기가 없는 기분이었죠. 옛 버릇이라 그런 건지도 몰라요...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오늘은 iPad 생활의 내 전체 첫 번째 날이 될 거에요! 오늘은 글쓰기와 상당히 일반적인 관리 업무로 가득할 것 같아요. 그래서 이게 이루어질 수 있는 최고의 날이 되겠네요.\n\n지금은 모든 게 좀 낯설게 느껴져요. 분명히 느릴 테지만 iPad 생활에 적응해야만 솔직한 리뷰를 할 수 있을 거라고 알아요. 그러니까 이제 충분히 숙달할 때까지 집중해야겠죠. 그럼 첫 iPad에서 쓰는 이야기와 첫 인상에 대해 시작해볼게요.\n\n# iPad 생활\n\n첫 번째로, 외관에 대해서...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nM4 iPad Pro는 듣던 대로 정말 얇습니다. 애플이 오랫동안 완벽한 iPad로 손꼽아 온 유리 패널 이념에 가장 가까운 제품입니다.\n\n![1stDayM4iPadPro_1](/assets/img/2024-05-23-1stDayM4iPadPro_1.png)\n\n지금은 USB-C 어댑터가 태블릿보다 두꺼울 정도로 놀랍도록 얇아졌습니다. 무게 배분이 아주 좋아요. 무거운 느낌이나 어색한 느낌이 전혀 없습니다. 액세서리까지 (나중에 더 이야기할게요) 구매하면 상당한 비용이 듭니다. 제 경우에는 2500파운드나 되어서 프리미엄 제품이어야 합니다.\n\n![1stDayM4iPadPro_2](/assets/img/2024-05-23-1stDayM4iPadPro_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼요!\n\n안타깝게도 아이폰과는 달리, 아이패드는 매직 키보드에 살게 될 거에요. 이것 없이 사용하려고 하는 건 불가능해요. 하지만 이렇게 함으로써, 아이패드의 아름다운 느낌과 촉감은 사라지게 되는데요 — 어쩔 수 없지 않나요.\n\n아이패드OS에 대해 감이 오기 시작했어요 — 이건 제게 있어서 최초의 진지한 아이패드 체험이자 일을 하는 첫 날이에요. 제 시각으로는, 이는 iOS와 macOS의 조합 같아요. 사용하고자 하는 것들이 살짝 익숙해지는 느낌인데 — 약간의 변화가 있는 거죠. 지금은 아무것도 제게 유창하게 다가오지 않아요.\n\n예를 들어, 제 쓰기 앱인 율리시스 — 처음으로 다운로드한 앱 중 하나인데, 그래머리가 작동하지 않아요. 맥에서는 그래머리를 제게 이중 확인해주는 도구로 쓰는데, 지금까지 작동시키지 못했어요... 추천하실 만한 게 있나요? 제가 이 글을 쓴 뒤에 할 일은 맥에서 그걸 확인하고 이미지를 추가하는 것이겠네요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이게 바로 익숙하지만 느리다는 게 정확히 내 말하는 바야. 맥에서는 보통 포토샵으로 이미지 크기를 조정한 다음, 데스크톱이나 다운로드 폴더에 이미지를 넣은 후 Ulysses에서 이미지를 삽입할 텐데요. 여기서는 맥에서 SD 카드에 있는 이미지를 먼저 Lightroom에 가져와서 iPad에서 Lightroom에서 편집하고 iPad에서 포토샵으로 크기를 조정해야겠죠. 그런 다음 파일에 폴더를 만들고 거기서 가져오는 방법 밖에 생각나지 않네요. 정말 번거로울 것 같아요.\n\n![이미지](/assets/img/2024-05-23-1stDayM4iPadPro_3.png)\n\n하지만 버텨내야 해요. 몇 시간 후에 겁먹고 iPad를 다시 사용하지 않는 건 아닌데요. 시간이 지나면 더욱 익숙해질 거예요. 제가 그렇게 믿어요.\n\n# 모두 정상\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어젯밤, iPad에서 최대한 많은 시간을 보내기로 결정했어요. 지금은 4시간 또는 5시간 정도 사용 중이에요.\n\n이 태블릿으로 얼마나 많은 파워를 사용하지 않고 있다는 것에 대해 웃음이 나오네요. 이 태블릿으로 가능한 많은 일을 할 수 있는데, 아직 제대로 활용하지 못하고 있어요.\n\n하지만 오늘은 아직까지 iPad만 사용하고 있어요. 여기에서 시청자의 댓글에 답변하고, 이전에 인스타그램에 올린 사진을 위해 Lightroom에서 작업을 하기도 했어요.\n\n집에서 작업할 때 Studio Display에 iPad을 연결하여 사용하는데, 바로 집에서 더 편안해진 느낌이에요. iPad 화면에서 글을 쓰는 동안에는 그 디스플레이에서 Safari, 음악 및 메일을 열어 놓고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단계 관리자는 맥에서 전혀 이해할 수 없는데 아이패드에서는 그 사용법을 점차 느끼고 있어요. 한 쪽에 설정된 스택은 열려 있는 것을 빠르게 시각적으로 확인할 수 있어서 쉽게 탐색할 수 있어요.\n\n아이패드에서의 유니버설 컨트롤을 사용해서 화면과 다른 두 대의 맥에서 작업합니다. 다른 맥을 인식하는 데는 약간 느렸지만 그 후로는 가끔 불편한 지체를 제외하고는 괜찮았어요. 제작된 소형 책상 세트가 확 준비된 듯한 느낌이 들어요.\n\n얼마 전에 스크린샷을 찍어 다른 앱에 넣어야 하는 경우가 있었는데 — 다시 한 번 제대로 한 아이패드 해결책을 생각해내지 못했어요 — 그래서 맥을 사용했어요.\n\n# 디스플레이\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어제 런던에 있었다고 말씀드렸죠 — 하루 중 일부는 브롬프턴 로드 애플 스토어에서 회의를 한 것이었어요.\n\n![이미지](/assets/img/2024-05-23-1stDayM4iPadPro_4.png)\n\n거기서 나노 텍스처 마감이 적용된 iPad의 디스플레이를 보면서 일반적인 제품과 비교해 보았어요.\n\n차이가 더 두드러질 것으로 예상했는데 실제로는 큰 차이가 없었어요. 약간 더 색상과 대조가 평평해진 것 같긴 했지만 그렇게 큰 차이는 없었어요. 곁에 놓고 비교했을 때 바로 교체하고 싶을 것 같았는데, 지금은 그렇게 확신이 서지 않네요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 눈에 더 편한 나노 텍스처 버전을 갖고 있을 때는 반짝임이 적고 반사도 적어 더 나은 작업 환경이었어요. 총적으로 지금 있는 것을 유지하기로 결정했어요.\n\n오늘 이것에 써 보았는데, Ulysses를 밝은 (어두운 대신) 모드로 설정해 뒀어요. 검은 글씨가 아주 진하게 보여요 — 내 맥북에서 볼 때보다 더 진해요.\n\n# 이것이 무엇을 할 수 있을까요\n\n여기서 비디오를 편집하는 것이 제 최종 목표입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n월요일에 공개되는 Final Cut Camera 앱을 기다리고 있어요. 그리고 나중에 iPad 2에 Final Cut Pro를 다운로드할 거예요(연간 £49 또는 월별 £4.95). 어떤 느낌인지 확인해보고 싶어요. 전문적으로 편집하는 데는 절대 사용하지 않을 거 같아요. 특히 플러그인을 실행할 수 없을 때, 하지만 최소한 그 정도까지 해봐야겠어요.\n\n그런데, 오늘 여기에서 Lightroom을 사용했다고 이야기했죠. 몇 가지 사전 설정을 추가했고, 약간의 렌즈 블러와 노이즈 제거를 했는데, 생각해보니 꽤 강력했더라구요. 물론 그럼에도 불구하고 내가 내보내기할 때까지 명백한 딜레이가 없이 흘끔 암시도 하지 않았어요.\n\n방금까지 내가 그것을 얼마나 쉽게 처리했는지 생각하니, 내보내기할 때 명백한 지연이 없이 얼마나 잘 다루었는지 감을 잡을 수 있어요. 이 태블릿이 얼마나 완성도 있게 만들어졌는지 대략 감이 오시죠.\n\n#액세서리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n펜슬을 거의 사용한 적이 없어요. Lightroom에서 간단히 사용했지만 새로운 기능을 사용할 이유가 없었어요. 앞으로 며칠 동안 그 이유를 찾아보겠어요. 그런데 구매할 때부터 나를 위한 제품은 아니라는 것을 알고 있었어요.\n\n\u003cimg src=\"/assets/img/2024-05-23-1stDayM4iPadPro_5.png\" /\u003e\n\n조금만 사용해 봤지만 화면에서 살짝 끌림을 느낄 수 있어요. 섬세한데 종이 표면을 드러내는 느낌이 약간 있어요.\n\n그와는 달리 Magic Keyboard는 와우! 예전 버전과 비교는 못하지만 정말 편하게 사용할 수 있어요. 책상 위에 아주 평평하게 놓이기 때문에 손목 통증이 없어요. 레이아웃은 제 손에는 약간 협소한데 13인치 MacBook Air에서 겪었던 똑같은 문제예요. 여유있는 큰 손을 가지고 있음을 알기에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새롭게 추가된 기능 키 행이 어색할 것을 우려했는데, 실제로는 이를 아주 편안하게 사용할 수 있어요. 밝기와 볼륨 조절이 손에 닿으니 너무나 편리해요. 또한 이제 상판이 금속으로 만들어져 전체적인 경험이 좀 더 맥스럽게 느껴져요.\n\n![이미지](/assets/img/2024-05-23-1stDayM4iPadPro_6.png)\n\nFace ID가 아주 잘 작동하고 홈 화면의 큰 위젯들을 정말 좋아해요. 스피커를 사용하면 책상에서 일반적인 청취 목적으로는 충분히 좋았어요. 비디오 통화용 카메라와 마이크도 좋았어요 - 특히 Studio Display 출시때보다 낫다는 건 분명해요.\n\n# 다음 단계는 무엇일까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그거 좀 더 통제력을 가지겠다는 거야, 그게 중요한 거야.\n\n오늘은 조용히 업무에 집중할 시간이 있어서 기쁘다. 나는 더 강력한 iPad 사용자가 될 수 있을까? 아니, 비디오 편집과 오디오 편집을 이렇게 많이 하는 것을 고려하면 Mac 사용자로 남을 것 같아. 그래도 다음 몇 주 동안 MacBook Air보다 이것을 더 자주 사용해 보겠다 - 그게 직접적인 경쟁 상대니까.\n\n그러나 마침내 iPad 및 iPadOS에 대한 얘기에 참여할 수 있게 되었다. 유출되고 있는 소문이 사실이라면, 나는 파티에 참여하기에 완벽한 시기를 선택한 것 같다. 약간의 시간이 지나 WWDC는 OS의 성공을 앞당길 수 있을 것이다. 오랜 시간 동안 하드웨어는 양호했지만 소프트웨어는 아쉽게 낙폭이 컸다. 이제 변화가 오는 걸까? 6월 10일 월요일, 우리 모두 알게 될 것이다.\n\n지금은 최대한 사용해 보면서 익숙해지는 데 집중하겠다 - 지금까지는 만족스럽다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제, Grammarly를 작동시킬 수만 있다면 좋겠어요...\n\n아이폰에 중복 항목이 많이 있는 것을 발견했거나 속도가 원하는 대로 빠르지 않은 것 같다면 이제 그에게 약간의 관심을 기울이는 시간입니다. 봄이 코앞에 와 있는데, MacPaws의 NEW CleanMyPhone으로 아이폰을 봄청소해보는 건 어떠세요? 멋진 CleanMyMac의 제작사에서 만든 이 제품은 훌륭하며 간편하게 사용할 수 있어서 순식간에 전화기를 정리해줍니다. 저의 링크를 사용해 직접 시도해보세요. 이를 통해 저를 작가로 지원할 수 있습니다.\n\n2024년 5월 17일에 게시된 원문은 https://talkingtechandaudio.com에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-23-1stDayM4iPadPro_0.png"},"coverImage":"/assets/img/2024-05-23-1stDayM4iPadPro_0.png","tag":["Tech"],"readingTime":6},{"title":"2단계 인증 앱이 012345를 받았을 때 알려주는 기능","description":"","date":"2024-05-23 14:53","slug":"2024-05-23-The2FAappthattellsyouwhenyouget012345","content":"\n이른 시기 2010년대에 성장한 모든 회복된 엣지로드와 같이 나는 4chan과 같은 이미지 보드의 전성기를 약간 그리워합니다. 그들은 나치들이 모든 것을 망쳐 버리기 전에 야생 서부 초기 인터넷의 마지막 요새였어요.\n\n클래식한 밈 중 하나는 GET이었는데, 당신이 랜덤으로 생성된 게시물 ID가 흥미로운 숫자 시퀀스를 포함할 것으로 정확히 예상했을 때 자부심을 느끼게 됩니다.\n\n![그림](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png)\n\n요즘에는 이제 모든 보통 사람들이 성장하고 직장을 찾은 지금, 옛날의 마법에 제일 가까이 올 수 있는 것은 이중 인증 코드뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 알고 있으면 좋아요.\n\n은행, 이메일 또는 클라우드 서비스에 다시 인증해야 하는 번거로움. 787000 또는 123450 같이 정말 좋은 숫자를 받았을 때의 작은 기쁨.\n\n영감을 받았어요.\n\n이 MFA 코드들은 매 30초마다 갱신되는 공통 알고리즘을 사용해요. 우리가 6자리 인증 코드에서 가능한 더블, 트리플, 쿼드, 퀸텀플, 섹스텀플 중에 매우 일부만을 경험하고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 독립 프로젝트들처럼, 내 주변에 하나의 명확한 비전이 있었으며 그 주위에 구축할 수 있었습니다:\n\n내가 뭘 해야 하는지 알았어요.\n\n### 컨셉 증명\n\n이게 작동하는지 알아야 하는 움직이는 부품은 많이 필요하지 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 2FA 비밀 키를 입력해주세요.\n- 로컬에서 6자리 2FA 코드를 생성합니다.\n- 쿼드/퀸트/섹스트가 생성될 때 푸시 알림을 보냅니다.\n\n## 최소 기능 제품\n\n만약 멋진 2FA 번호가 생성될 때 알림을 받는 개념이 유지된다면, 몇 가지 주요 기능을 갖춘 실제 앱으로 발전시킬 수 있습니다:\n\n- 카메라로 2FA 비밀을 캡처합니다.\n- 여러 2FA 코드를 저장합니다.\n- 더 많은 숫자 패턴을 구현합니다.\n- 사용자가 알고 싶은 패턴을 선택할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내가 뭔가를 알고 있었다는 걸 알았어: 내가 이걸 설명한 사람들의 90%는 나를 멍청이로 생각했어. 나머지 10%는 순수한 창의성만을 보았어.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_1.png)\n\n# Proof of Concept 구축\n\n## TOTP\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTOTP 또는 시간 기반 일회용 비밀번호는 놀랍도록 간단한 개념입니다. 이는 두 가지 입력을 사용하는 인증 프로세스입니다:\n\n- 인증 서비스 및 자신의 장치에 저장된 비밀 키\n- 현재 시간 또는 더 정확히 말하면 유닉스 시간 이후 경과한 30초 간격의 수\n\n이 알고리즘은 두 입력을 결정론적으로 해시하여 여러분이 알고 사랑하는 6자리 코드를 생성합니다. 이 해싱 알고리즘은 Apple의 CryptoKit에서 찾을 수 있는 매우 흔한 것입니다. Apple 포럼의 우리 친구들 덕분에 여기 TOTP 알고리즘의 전체 영광이 있습니다.\n\n```js\n// CodeGenerator.swift\n\nprivate let secret = Data(base64Encoded: \"AAAAAAAAAAAAAAAAAAAAAAAAAAA\")!\n\nfunc otpCode(date: Date = Date()) -\u003e String {\n    let digits = 6\n    let period = TimeInterval(30)\n    let counter = UInt64(date.timeIntervalSince1970 / period)\n    let counterBytes = (0..\u003c8).reversed().map { UInt8(counter \u003e\u003e (8 * $0) \u0026 0xff) }\n    let hash = HMAC\u003cInsecure.SHA1\u003e.authenticationCode(for: counterBytes, using: SymmetricKey(data: secret))\n    let offset = Int(hash.suffix(1)[0] \u0026 0x0f)\n    let hash32 = hash\n        .dropFirst(offset)\n        .prefix(4)\n        .reduce(0, { ($0 \u003c\u003c 8) | UInt32($1) })\n    let hash31 = hash32 \u0026 0x7FFF_FFFF\n    let pad = String(repeating: \"0\", count: digits)\n    return String((pad + String(hash31)).suffix(digits))\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 텍스트를 친근한 분위기로 한국어로 번역하면 다음과 같습니다.\n\n\"작업이 올바르게 진행되었는지 확인하기 위해, 구글 계정에 2단계 인증을 설정하고 해당 앱에서 비밀을 알고리즘을 사용하여 표시했어요.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_2.png)\n\n그리고, 마법처럼 (약간 번거로운 base32에서 base64로의 변환 후에), 구글이 내 2단계 인증을 승인했어요!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_3.png)\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 2단계 인증의 기본적인 부분이 작동 중이니, 컨셉 증명 퍼즐의 마지막 조각인 알림 생성을 구현할 수 있습니다.\n\n## 앱 제한 사항\n\n저희의 주요 제한 사항은 모바일 장치에 있습니다.\n\n실제로 2단계 인증 생성과 같은 백그라운드 프로세스를 영원히 실행할 수 없으며, 반드시 사용자 비밀을 백엔드 푸시 서버에 저장할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러므로 이 개념이 작동하도록하려면 약간 교묘해야합니다: 앞으로 2FA 코드를 미리 계산하고, 그들이 실제로 출현하는 시간에 전달을 예약해야합니다.\n\n또한, iOS에서 동시에 64개의 푸시를 예약할 수 있으므로, 다음을 고려해야합니다:\n\n- 사용자에게 앱을 다시 입력하도록 요청하는 알림 하나 또는 두 개를 저장합니다.\n- 알림을 터치하여 사용자가 앱을 열도록 유도하여 2FA 코드를 재계산하도록합니다.\n\n이제 POC가 작동하는 방법을 알았으니, 빌드를 시작합시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 첫 번째 GETs 찾기\n\n우리의 보잘것없는 2FA 코드를 향상시켜 봅시다.\n\n우리는 많은 코드를 미리 계산한 후, 각 코드가 GET인지를 확인하는 레귤러 표현식을 구현할 계획입니다.\n\n제 아주 간단한 SwiftUI 뷰는 UICollectionView를 백업으로 사용하여 성능이 훌륭하도록 보장하기 위해 이러한 코드를 편리하게 표시할 수 있습니다 (ScrollView의 기본 VStack은 10,000개의 항목 이전에 멀쩡히 오작동하기 시작할 것입니다!).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n// ContentView.swift\n\nstruct ContentView: View {\n\n    var body: some View {\n        List {\n            ForEach(makeOTPs(), id: \\.self) {\n                Text($0)\n                    .font(.custom(\"Courier\", size: 20))\n                    .font(.title)\n                    .kerning(4)\n            }\n            .frame(maxWidth: .infinity)\n        }\n    }\n\n    func makeOTPs() -\u003e [String] {\n        (0..\u003c10_000).map {\n            otpCode(increment: $0)\n        }\n    }\n}\n```\n\n잘 진행되고 있어요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_4.png)\n\n이제, 세 자리 숫자가 연속으로 나타나는 TOTP(예: 120333)를 확인하는 간단한 정규 표현식 평가기를 추가할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nextension String {\n    func checkThoseTrips() -\u003e Bool {\n        (try? /(\\d)\\1\\1/.firstMatch(in: self)) != nil\n    }\n}\n```\n\nText 뷰에 fontWeight 수정자를 추가하여 스크롤할 때 이 GET을 쉽게 감지할 수 있습니다.\n\n```swift\nText($0)\n    .fontWeight($0.checkThoseTrips() ? .heavy : .light)\n```\n\n에쟈! 그 여행을 확인하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_5.png\" /\u003e\n\n우리는 심지어 우리의 정규 표현식을 신성한 네 숫자를 감지하기 위해 기본 수정할 수도 있어요 — 이건 독자들에게 연습문제로 남길게요.\n\n\u003cimg src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_6.png\" /\u003e\n\n## 전혀 소용없지만 재미있는 관찰\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 부주의한 ForEach 구현으로 인해 다음 경고 메시지가 발생했습니다:\n\n```js\nForEach\u003cArray\u003cString\u003e, String, Text\u003e: the ID 312678 occurs multiple\ntimes within the collection, this will give undefined results!\n```\n\n실제로 이 경고를 수십 번 받았습니다!\n\n\u003cimg src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_7.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 10,000개의 OTP를 생성했기 때문에, 여러 개가 일치할 가능성이 매우 높습니다. 이는 생일 문제와 같은 원리이며, 가능한 일치 쌍의 수는 백만 이상이 됩니다.\n\n## 희귀한 GET 생성하기\n\n이제 몇 가지 흥미로운 코드를 계산해 보겠습니다.\n\n여기서 중요한 점은 미리 계산하여 미래를 예측하는 것입니다: TOTP는 비밀과 날짜 입력의 결정적 해시이기 때문에, 우리는 미래의 오랜 일련의 날짜를 입력하여 특정 시간에 어떤 OTP 코드를 볼 수 있는지 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 코드와 날짜를 반환하도록 OTP 생성 방식을 조정해보겠습니다:\n\n```js\n// TOTP.swift\n\nstruct OTP {\n    let date: Date\n    let code: String\n}\n\nfunc otpCode(date: Date = Date(), increment: Int = 0) -\u003e OTP {\n    let digits = 6\n    let period = TimeInterval(30)\n    let adjustedDate = date.addingTimeInterval(period * Double(increment))\n    let counter = UInt64(adjustedDate.timeIntervalSince1970 / period)\n    let counterBytes = (0..\u003c8).reversed().map { UInt8(counter \u003e\u003e (8 * $0) \u0026 0xff) }\n    let hash = HMAC\u003cInsecure.SHA1\u003e.authenticationCode(for: counterBytes, using: SymmetricKey(data: secret))\n    let offset = Int(hash.suffix(1)[0] \u0026 0x0f)\n    let hash32 = hash\n        .dropFirst(offset)\n        .prefix(4)\n        .reduce(0, { ($0 \u003c\u003c 8) | UInt32($1) })\n    let hash31 = hash32 \u0026 0x7FFF_FFFF\n    let pad = String(repeating: \"0\", count: digits)\n    let code = String((pad + String(hash31)).suffix(digits))\n    return OTP(date: adjustedDate, code: code)\n}\n```\n\n이를 테스트하기 위해 다수의 코드를 생성하고, GETs: quints (5개의 중복번호)를 검색해 보겠습니다.\n\n```js\nfunc interestingCodes() -\u003e [OTP] {\n    (0..\u003c1_000_000)\n        .map { otpCode(increment: $0) }\n        .filter { $0.code.checkThoseQuints() }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 M1이 해싱 함수를 실행하는 동안 몇 번의 숫자 계산 후, 약 30초 동안 진행된 결과물은 몇몇 굉장히 확인 가능한 GET들로 이어졌어요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_8.png)\n\n## 우리의 알림 일정 설정하기\n\n좋은 숫자를 볼 수 있어서 재미있긴 하지만, 만약 실제로 GETs를 실생활에서 진짜 인증을 위해 사용할 수 없다면, 이 앱 개념은 그냥 무작위 번호 생성기와 다를게 없죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 흥미로운 숫자가 도착하는 시점을 알게 되었으니, 번호를 실시간으로 받을 수 있도록 푸시 알림을 대기열에 넣고 있어요:\n\n```js\n// NotificationScheduler.swift\n\nprivate func createNotification(for otp: OTP) {\n    let center = UNUserNotificationCenter.current()\n    let content = UNMutableNotificationContent()\n    content.title = \"Quads GET!!\"\n    content.body = otp.code\n    content.sound = UNNotificationSound.default\n    let components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second], from: otp.date)\n    let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    center.add(request) { (error) in\n        // ...\n    }\n}\n```\n\n이 알림은 우리 뷰에서 사용하는 흥미로운 코드를 생성한 직후 예약되어 있어요. 그리고 잠시 후, 한꺼번에 2개의 멋진 푸시 알림을 받았답니다!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 통지가 실제로 나타나는 번호와 일치한다는 것을 확인하니, 더욱 흥미로워졌어요!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_10.png)\n\n아래 앱은 무작위 번호 생성기를 넘어서, 이 코드가 실제로 내 Google 계정에 로그인하는 데 도움이 된단 걸 알게 되었어요.\n\n## 흥미로움\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 종류의 흥미로운 숫자를 결정하려면 흥미로움의 개념을 소개해야 합니다. 이는 반복되는 숫자, 연속하는 숫자, 수학적으로 흥미로운 숫자(예: 파이 또는 e), 회문을 포함할 수 있습니다.\n\n이러한 종류의 흥미로운 숫자는 ... 우리가 생성하는 각 OTP에 대해 선택적으로 만들어진 열거형 케이스로 열거될 수 있습니다.\n\n```js\n// 흥미로움.swift\n\n열거형 흥미로움 {\n\n    케이스 섹스텀\n    케이스 퀸츠\n    케이스 쿼드\n\n    이니셜라이저(code: String) {\n        if code.checkThoseSexts() {\n            self = .sexts\n        // ...\n\n    변수 타이틀: String {\n        switch self {\n        case .sexts: return \"Sextuples GET!!!\"\n        // ...\n\n    함수 본문(code: String) -\u003e String {\n        switch self {\n        case .sexts: return \"체크해 보세요 섹스텀: \\(code)\"\n        // ...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 checkThose 메소드는 다른 정규식을 래핑하며, 우리는 가장 중요한 순서대로 실행합니다. 예를 들어, 섹스튜플은 쿼드보다 100배 더 드물다.\n\n오랜만에 리팩터를 해서 우리는 개념 증명을 만들었습니다. 요약해보겠습니다:\n\n- 앱은 (하드코딩된) 2FA 보안 키를 입력할 수 있게 해줍니다.\n- 앱은 로컬에서 매 30초마다 6자리 2FA 코드를 생성합니다.\n- 앱은 쿼드, 퀸트, 섹스가 생성될 때 푸시 알림을 예약합니다.\n\n몇 일 동안 앱을 사용해보려고 쉬는 시간을 가질 것입니다. 내 손에 멋진 앱을 만들 수 있을 것 같다고 예상하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 최소 기능 제품 구축\n\n얼마 되지 않아, 몇 일 동안 제 아이디어의 핵심을 담은 앱, 즉 우선 증명 개념 버전을 사용해왔어요. 그리고 정말 좋아해요. 처음으로 여섯 번째 메시지를 받을 때까지 기다릴 수가 없네요.\n\n이제는 뼈대에 고기를 붙여 완전히 다듬어진 2FA 앱을 구축할 때입니다. 이전에 설명한 대로, 실제로 4가지 주요 새로운 기능만 추가하면 됩니다:\n\n- 2FA QR 코드를 스캔하여 안전하게 키체인에 저장하기\n- 사용자 인터페이스에서 여러 2FA 계정을 표시하고 관리하기\n- 사용자가 중요하게 여기는 번호 설정하기\n- 더 많은 종류의 재미있는 기능 구현하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 기능적이 아닌 요구 사항: 매우 느린 코드 생성을 최적화하는 작업을 해야 합니다. 배치 처리 또는 로컬 지속성을 활용할 수도 있을 것 같아요.\n\n## 인간 인터페이스 가이드라인\n\n디자인에 대해 별다른 특별한 것을 할 계획은 없어요. 표준 애플 List 뷰 구성 요소를 사용하여 HIG를 따를 것이에요.\n\nUX는 멋지고 간단하게 유지합시다: 주로 푸시 알림에 기능이 집중되어 있으며 매우 완벽해요. 이 말은 QR 스캐너와 설정을 툴바 버튼 뒤에 숨기고, 모달 플로우가 표시되도록 하는 것을 의미해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Scanning 2FA Secrets](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_11.png)\n\n## Scanning 2FA Secrets\n\nA couple of open-source libraries will save me a ton of time on cookie-cutter tasks. CodeScanner to supply simple SwiftUI QR code scanning, and KeychainAccess to easily store these 2FA account secrets in the keychain.\n\n![Scanning 2FA Secrets](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_12.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 스캐너 라이브러리는 카메라 접근을 사용하여 QR 코드를 쉽게 구문 분석할 수 있는 URL로 변환합니다. 아래와 같은 형식으로 변환됩니다:\n\n```js\notpauth://totp/Google%3Atest%40gmail.com?secret=bv7exx7sltbcqffec1qyxscueydwsu5h\u0026issuer=Google\n```\n\n이제 앱에 우리의 계정을 쉽게 추가할 수 있게 되었어요!\n\n\u003cimg src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_13.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 선호하는 숫자 선택하기\n\nSwiftUI @AppStorage를 사용하여 List 및 몇 가지 Toggles와 함께 사용하면 쉽게 사용자 설정 화면을 구축할 수 있습니다.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_14.png)\n\n나는 onDisappear에서 부모 뷰에게 다시 숫자 처리를 시작하고 알림을 다시 예약하라고 알리기 위해 클로저를 사용했습니다. 이것은 토글이 변경될 때마다 비싼 계산을 실행하는 대신 모든 것을 일괄 처리하는 가장 간단한 방법이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n// CodeView.swift\n\nvar body: some View {\n    // ...\n    .sheet(isPresented: $showSettings) {\n        SettingsView(onDisappear: {\n            viewModel.recomputeNotifications()\n        })\n    }\n}\n```\n\n## Belated Customer Research\n\n안녕하세요, 저는 독립 개발자에요. 프로젝트 빌드 과정 중간에 이것을 할 수 있어요!\n\n몇 가지 다른 2FA 앱을 다운로드해서 아이디어를 베낄 만한 것이 있는지 살펴보기로 결정했어요. 사실, 꽤 혼잡하고 경쟁력 있는 앱 시장을 기대했는데, 이 중 일부는 정말 형편없었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변환:\n\n\n![이미지1](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_15.png)\n\n정말이지, 그 중 50% 이상이 매우 공격적인 페이월을 설정해 놓고 사용하기 전에 이겼다... 무료 옵션이 완전히 제공되는 상황일 때 말이죠.\n\n이 페이월이 넘쳐난다 해도, 좋은 아이디어를 빌려올 수 있었던 몇 가지를 기록해 두었어요.\n\n![이미지2](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_16.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 여러 개의 2FA 계정\n\n여러 개의 계정을 가진 사람들에겐 이것이 매우 중요하죠. 계정이 많으면 더 많은 GET 기회가 생기기도 하거든요!\n\n내 키체인 코드를 업데이트했어요. 이제 여러 개의 QR 코드를 스캔할 수 있게 되었고, 계정 데이터(비밀 정보를 포함한)도 저장하게 되었어요. 이제 나의 다양한 계정으로 로그인하는 데 완벽하게 작동했어요!\n\n![QR 코드 이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_17.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 적절한 내장 목록 기능을 구현하여 이제 우리가 더 이상 필요하지 않은 코드를 삭제할 수 있습니다.\n\n경쟁사 분석을 하면서, 구글 인증 프로그램이 예전 아이폰에 추가한 2단계 인증 코드를 몇 년 전부터 계속 보관하고 있는 것을 발견했어요!\n\n그때 제 데이터 계층에서 두 가지 실수를 발견했습니다.\n\n- iCloud와 동기화하지 않았던 점\n- 키패인 밖에 계정을 지속하려고 한 점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, iCloud에 대한 키체인을 동기화하면 계정이 다른 모든 Apple 기기에 나타납니다. Keychain Access 라이브러리를 사용하면 쉽게 할 수 있어요:\n\n```js\n// KeychainManager.swift\n\nself.keychain = Keychain().synchronizable(true);\n```\n\n둘째, 저는 반짝이는 물건 증후군으로 고생했어요: SwiftData를 영속성 레이어로 사용하기 위해 서두르다 보니 Keychain만을 비밀로 사용하고 나머지 계정 메타데이터는 새로운 프레임워크를 통해 영속화하고 있었어요.\n\n이것은 다른 장치에서 나의 계정을 가져올 수 없었다는 것을 의미해요 — 비밀만으로는 쓸모가 없어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 전 Account 객체 전체를 키체인에 저장해야 한다는 것을 깨달았어요.\n\n새로운 접근 방식은 QR 코드 URL을 키체인에 그대로 저장하는 것입니다. 이제 Account 객체 자체는 일시적입니다; 앱을 로드할 때마다 URL에서 다시 계산됩니다.\n\n이렇게 하면 로드할 때마다 Accounts가 로그인한 모든 iDevice에 나타날 수 있습니다! 이 일시적인 방식은 두 마리의 새끼를 한 방에 잡는 멋진 방법입니다. 이제 필요할 때 키체인에서 Accounts를 가져올 때 사용합니다:\n\n```swift\n// AccountManager.swift\n\nfunc fetchAccounts() throws -\u003e [Account] {\n    try KeychainManager.shared.fetchAll()\n        .compactMap { createAccount(from: $0) }\n}\n\nprivate func createAccount(from urlString: String) -\u003e Account? {\n    guard let url = URL(string: urlString),\n          let account = SecretURLParser.shared.account2FA(from: url) else {\n        return nil\n    }\n    return account\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반 코딩 작업을 많이 하여 UI를 개선하고 코드를 잘 리팩토링하는 작업을 했어요. 그런데 개발 과정에서 흥미로운 것들도 몇 가지 있었답니다.\n\n## 계정 아이콘 찾기\n\n이건 꽤 좋은 기능이에요. 하지만 최고의 오픈 소스 앱이 똑같은 일을 하길래, 적어도 그것만큼 좋아야 한다고 느꼈어요.\n\n다행히도, 웹 사이트에서 FavIcon을 검색하고 여러 해상도로 다운로드할 수 있는 Google API가 있답니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹사이트를 어떻게 디자인하면 좋을지 고민 중이군요. QR 코드의 발행자 속성을 사용하여 .com 도메인을 시도하는 방법으로 좋은 결과를 얻었다고 하셨군요.\n\n```swift\nstruct FavIcon {\n\n    let url: URL\n\n    init(issuer: String) {\n        let domain = \"\\(issuer).com\"\n        let url = URL(string: \"https://www.google.com/s2/favicons?sz=128\u0026domain=\\(domain)\")!\n        self.url = url\n    }\n}\n```\n\n아이콘의 빠른 로딩을 위해 CachedAsyncImage 라이브러리를 사용한 거군요. 이렇게 하면 성능이 더 빨라질 거에요.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_18.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배경 제거를 처리하고 아이콘을 좀 더 돋보이게 만들기 위해 Metal 셰이더를 추가했어요.\n\n여기 SwiftUI View 확장 부분이에요:\n\n```js\n//  View+ColorEffect.swift\n\nimport SwiftUI\n\nextension View {\n\n    func eraseBackground(backgroundColor: Color = Color(uiColor: UIColor.secondarySystemBackground)) -\u003e some View {\n        modifier(EraseBackgroundShader(backgroundColor: backgroundColor))\n    }\n}\n\nstruct EraseBackgroundShader: ViewModifier {\n\n    let backgroundColor: Color\n\n    func body(content: Content) -\u003e some View {\n        content\n            .colorEffect(ShaderLibrary.eraseBackground(\n                .color(backgroundColor)\n            ))\n    }\n}\n```\n\n그리고 물론 MSL 셰이더 코드도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```cpp\n#include \u003cmetal_stdlib\u003e\n#include \u003cSwiftUI/SwiftUI_Metal.h\u003e\nusing namespace metal;\n\n[[ stitchable ]]\nhalf4 eraseBackground(\n    float2 position,\n    half4 color,\n    half4 backgroundColor\n) {\n\n    if (color.r \u003e= 0.95 \u0026\u0026 color.g \u003e= 0.95 \u0026\u0026 color.b \u003e= 0.95) {\n        return backgroundColor;\n    }\n\n    return color;\n}\n```\n\n여기에 그들이 어떻게 보이는지 있어요. 그들은 나쁘지 않지만 놀라운 것은 아니에요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_19.png)\n\n난 지나치게 엔지니어링을 시작했어. 이것에 핀을 꽂아 놓고 나중에 다시 생각해 봐요.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## UI 디자인 개선\n\n기본 2단계 인증 앱으로서 이미 꽤 잘 작동하고 있습니다.\n\n대부분의 사람들을 앞선 존재가 되기 위해서는, 극도로 공격적인 유료 벽을 두지 않으면 되는구나 ($4.99 매주? 정말?!)\n\n일부 기본 소프트웨어 개발 작업을 통해 타이밍, 기본 UI 및 데이터 저장 작업을 수행한 후, 이제는 정말로 아주 잘 작동하고 있습니다. - 기본 SwiftUI 구성 요소를 사용하는 것은 작업이 \"그냥 작동\"되도록하는 빛나는 방법입니다*.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*TUkFn9ejk93WczTL02Jlrg.gif)\n\n저는 경쟁사 조사를 통해 찾은 tap-to-copy와 같은 편의 기능 몇 가지를 구현했어요.\n\n@ScaledMetric와 ViewThatFits 같은 접근성 도구를 활용하여 시각적 요구에 관계없이 앱이 원할하게 작동하도록 했어요. Apple의 기본 SwiftUI 구성 요소와 색상에 밀접하게 따라가면서 무료로 라이트 모드도 구현되었어요.\n\n```js\n// AccountView.swift\n\n@ScaledMetric(relativeTo: .largeTitle) private var iconSize: CGFloat = 36\n\nprivate var icon: some View {\n    CachedAsyncImage(url: FavIcon(issuer: account.issuer).url, content: {\n        $0\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n\n    }, placeholder: {\n        Text(String(account.issuer.first?.uppercased() ?? account.name.first?.uppercased() ?? \"\"))\n            .font(.largeTitle)\n            .monospaced()\n    })\n    .frame(width: iconSize, height: iconSize, alignment: .center)\n}\n\nprivate var code: some View {\n    ViewThatFits {\n        HStack(alignment: .center, spacing: 16) {\n            codeText\n        }\n        VStack(alignment: .leading, spacing: 4) {\n            codeText\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_20.png\" /\u003e\n\n## 앱을 더 흥미롭게 만들기\n\n진정한 핵심 가치 제안을 개선하기 위해 흥미로운 옵션을 더 많이 구현했습니다:\n\n- 000000과 같은 섹스투플렛 및 쿼드투플렛\n- 012345와 같은 순서대로 계속되는 수열\n- 300000처럼 백만단위의 수\n- 000001과 같은 일의 자리, 000010과 같은 십의 자리\n- 원주율 파이(314159)와 같은 수학 상수\n- 플랑크 상수(6.6x10⁻³⁴)와 같은 물리 상수\n- 012210과 같은 회문\n- 121212와 123123과 같은 반복된 이차, 삼차 수열\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Markdown 형식으로 표 태그를 변경한 코드입니다.\n\n```js\nfunc checkThatCounting() -\u003e Bool {\n    let characters = Array(self)\n    for i in 1..\u003ccharacters.count {\n        if let prevDigit = Int(String(characters[i - 1])),\n           let currentDigit = Int(String(characters[i])),\n           currentDigit != prevDigit + 1 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc checkThatPalindrome() -\u003e Bool {\n    self == String(self.reversed())\n}\n\nfunc checkThoseRepeatedThrees() -\u003e Bool {\n    self.prefix(3) == self.suffix(3)\n}\n\nfunc checkThoseHunderedThousands() -\u003e Bool {\n    suffix(5) == \"00000\"\n}\n```\n\n## 확률 이론\n\n이제 설정 UI를 업데이트하여 흔함, 드물음, 초 희귀함으로 정렬하거나 반복, 상수, 순서 또는 라운드 숫자와 같은 유형으로 정렬할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`\u003cimg src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_21.png\" /\u003e`\n\n각 희귀 수준의 확률을 어떻게 계산하나요?\n\n012345와 같은 완벽한 숫자 시퀀스의 경우, 1백만 개의 가능한 번호 조합 중 6가지만 가능합니다 (567890까지).\n\n30초에 1백만 개의 조합을 곱하고 가능한 시퀀스인 6으로 나누면, 각 계정당 평균적으로 완벽한 카운팅 시퀀스가 발생할 수 있다는 것은 약 5백만 초마다 발생할 수 있다는 것을 의미합니다 — 평균적으로 58일마다 한 번씩입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 정도라니, 정말 희귀한 것이죠.\n\n하지만 123321과 같은 회문 수는 만들 수 있는 3자리 수가 1000개에 달합니다. 이는 평균적으로 매일 0.34번씩 볼 수 있다는 뜻이에요! 훨씬 더 흔하죠.\n\n중간에는 141414와 같이 반복되는 숫자들이 있습니다. 이런 경우 가능한 숫자는 00부터 99까지의 100개인데요, 그래서 이들은 평균적으로 3.5일에 한 번씩 발생합니다. 그래서, 정말 희귀하지만, 극도로 희귀하지는 않은 편이에요.\n\n이 중 일부인 쿼드와 같은 일련 번호들은 조금 더 많은 계산이 필요한데, 그래서 수천만 개의 OTP(일회용 비밀번호)를 생성하고 각 흥미로운 종류별로 발생 빈도를 세어 상대적 빈도를 감을 수 있게 했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 성능 향상\n\n앱은 모든 일반적인 흥미로운 코드를 활성화한 상태에서만 아주 빠르게 64개의 흥미로운 2FA 코드를 처리할 수 있지만, 초희귀한 GET만 원할 때는 처리 시간이 오래 걸립니다.\n\n수백만 개의 잠재적인 OTP를 처리하는 동안, 유효한 흥미로운 코드를 발견하자마자 알림을 반환하고 예약하는 것이 필요합니다.\n\n오래된 친구인 Combine 프레임워크는 깔끔한 해결책을 제공해줍니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n// CodeGenerator.swift\n\nvar codeSubject = PassthroughSubject\u003cOTP, Never\u003e()\n\nfunc generateCodes(accounts: [Account]) {\n    // ...\n    codeSubject.send(otp)\n}\n```\n\n또한 사용자가 중간에 설정을 변경하는 경우를 대비하여 작업을 취소하고 다시 시작할 수 있도록 일부 작업을 사용했습니다. 작업을 분리함으로써 암호 해독 및 문자열 분석 작업을 UI 스레드에서 유지하지 않을 수 있습니다.\n\n```swift\n// CodeViewModel.swift\n\nprivate var otpComputationTask: Task\u003cVoid, Never\u003e?\nprivate var notificationSchedulingTask: Task\u003cVoid, Never\u003e?\n\nfunc recomputeNotifications() {\n    handleNotificationScheduling()\n    handleOTPComputation()\n}\n\nprivate func handleNotificationScheduling() {\n    notificationSchedulingTask?.cancel()\n    notificationSchedulingTask = Task.detached(priority: .high) {\n        guard await NotificationScheduler.shared.isAuthorized() else { return }\n        NotificationScheduler.shared.cancelNotifications()\n        for await (code, count) in CodeGenerator.shared.codeSubject.values {\n            try? await NotificationScheduler.shared.scheduleNotification(for: code)\n        }\n    }\n}\n\nprivate func handleOTPComputation() {\n    let accounts = accounts\n    otpComputationTask?.cancel()\n    otpComputationTask = Task.detached(priority: .high) {\n        guard await NotificationScheduler.shared.isAuthorized() else { return }\n        CodeGenerator.shared.generateCodes(accounts: accounts)\n    }\n}\n```\n\n이제 일정이 시퀀스대로 아니라 하나의 큰 덩어리로 나오지 않고 꽤 부드럽게 작동합니다!\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\nScheduled repeatedTwos: 292929 @ 2024-02-25 23:33:30 +0000\nScheduled repeatedTwos: 878787 @ 2024-02-26 06:03:30 +0000\nScheduled quints: 666660 @ 2024-02-26 10:54:00 +0000\nScheduled quints: 255555 @ 2024-02-26 21:11:00 +0000\nScheduled repeatedTwos: 606060 @ 2024-02-26 23:27:00 +0000\nScheduled sexts: 666666 @ 2024-04-16 23:22:00 +0000\nScheduled boltzmannConstant: 141023 @ 2024-04-19 02:05:00 +0000\nScheduled counting: 012345 @ 2024-04-20 04:51:30 +0000\nScheduled planksConstant: 661034 @ 2024-04-20 05:38:00\n\n\n\n## 앱 아이콘\n\n이 거래 그냥 사라지고 싶었어요. 앱 아이콘에 진짜로 체크하려면 이제 목멸에 달렸거든요. 정말 완벽해요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_22.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 제 친구가 Lionsgate Films의 친구들이 조금 소송을 제기할 수도 있다고 지적했습니다.\n\n하지만 난 그걸 가져야 했어!\n\n어쨌든 희망이 있다면:\n\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_23.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그냥 개인정보를 꼭 보호하세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n달리(DALL-E)는 정말 손등을 그리는 걸 좋아하지 않았어요. 저는 노력해 봤지만요.\n\n# 마지막 손질\n\n그 개념은 증명되었어요. 어플이 잘 작동하고 있어요! Check 'em의 즐거움을 세상에 보여주기 전에 약간의 마무리와 작은 기능을 추가할 시간이에요.\n\n첫 릴리스를 만들기 전에 V1에서 구현할 수 있는 새로운 기능과 버그 수정 사항들을 목록으로 만들었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 높은 우선순위 -\n// TODO: - 주문 추가 - 저장된 URL에 쿼리 항목으로 정렬 추가\n// TODO: - 새로 고침 시 햅틱 진동\n// TODO: - 푸시 알림 요청은 설정 화면에 진입했을 때에만\n// TODO: - 알림 활성화를 위한 설정 링크 추가\n// TODO: - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시 - 이미 있는 경우 계정에 스캔을 추가하지 않음\n// TODO: - 설정 화면을 열 때 처리 작업 취소\n// TODO: - 푸시 알림 딥 링크 - GET이 여전히 존재할 때 앱 리뷰 프롬프트로 이동\n// TODO: - 매우 드문 GET가 전송되지 않는 것 같음?? 시뮬레이터에서 로컬로 발생하지 않지만 quints는 괜찮음 - 큐에 들어가는 것처럼 보임\n// TODO: - 버그 - 두 번째 로드에서 진행 상황 보기가 나타나지 않음\n// TODO: - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시 - 이미 있는 경우 계정에 스캔을 추가하지 않음\n// TODO: - 버그 - 2개의 동시 계산이 있을 때 백분율이 계속 변동하는 버그 발생\n// TODO: - QR 및 설정에 TipKit 추가\n\n// 낮은 우선순위 -\n// TODO: - 상태 복원을 위해 @SceneStorage 사용 - 키패인 작업을 기다리지 않아도 되도록\n// TODO: - 한 단계 또는 뒤로 이동\n// TODO: - 딥 링크를 사용하여 \"컬렉션\" 화면 생성 - 보관된 항목으로 본 GET 수집 (키패인의 사전으로)\n```\n\n당연히, 제게 제품 관리자가 없기 때문에 최저 우선 순위의 작업을 즉시 시작했습니다: 딥 링크로 컬렉션을 구축하는 것 - 내 드문 GET가 헛되이 낭비되는 것을 원하지 않아요!\n\n## 컬렉션\n\n이 부분은 원본 개념 증명에서 식별한 문제에 도움이 됩니다: 사용자들이 알림과 상호 작용하도록 유도하여 앱에 재진입하도록 해야합니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컬렉션 뷰를 만드는 것은 조금 까다로울 수 있어요. 왜냐하면 몇 가지 부분을 고려해야 되거든요:\n\n- 사용자가 알림을 탭하고 앱으로 딥 링크 할 수 있게 합니다.\n- 탭한 코드의 흥미로운 부분을 안전하게 저장합니다.\n- 이것들을 컬렉션 화면에 렌더링합니다.\n\n알림에 딥 링크를 추가하는 것은 꽤 간단했어요.\n\n```js\n// Notifications.swift\n\n// ...\ncontent.userInfo = [\"deepLink\": \"checkem://\\(otp.code)\"]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 약간 거슬리지만, 알림을 처리하기 위해 AppDelegate를 만들어야 했어요 — SwiftUI는 아직 완전히 자체적으로 이를 다루지 못합니다.\n\n```swift\n// AppDelegate.swift\n\nfunc userNotificationCenter(_ center: UNUserNotificationCenter,\n                            didReceive response: UNNotificationResponse,\n                            withCompletionHandler completionHandler: @escaping () -\u003e Void) {\n\n    let userInfo = response.notification.request.content.userInfo\n\n    if let deepLinkString = userInfo[\"deepLink\"] as? String,\n       let deepLinkURL = URL(string: deepLinkString) {\n        guard let code = deepLinkURL.code else { return }\n        try? CollectionManager.shared.save(code: code)\n    }\n\n    completionHandler()\n}\n```\n\n마지막으로, Keychain에 저장된 코드들의 긴 쉼표로 구분된 목록을 게으르게 추가했어요.\n\n```swift\n// KeychainManager.swift\n\nfunc storeCollectionItem(code: String) throws {\n    var collection = try keychain.get(Constants.collectionKey) ?? \"\"\n    if !collection.isEmpty {\n        collection.append(\",\")\n    }\n    collection.append(code)\n    try keychain.set(collection, key: Constants.collectionKey)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빠르게 출시하기 위한 욕망의 결과인 것이지, 신중하게 고려된 엔지니어링 결정의 결과는 아닙니다. 사용자가 Keychain 항목 당 4kB의 소프트 제한에 가까워지는 경우 후회할 수 있는 결정이었습니다(하드 제한은 대략 16MB 이므로 괜찮을 것 같아요!).\n\n이 작업은 빠르게 성과를 거두었는데, 컬렉션 화면은 빠르게 내 소중한 GET들로 가득 차기 시작했어요!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_27.png)\n\n원래는 사용자가 알림을 탭할 때까지 컬렉션을 숨겼었는데, 사용자가 '모두 수집하기'에 도전하도록 하는 것이 더 매력적이라고 깨달았어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_28.png\" /\u003e\n\n## 진동\n\niOS 17 sensoryFeedback API를 사용하면 매우 섬세한 진동을 재생할 수 있습니다. 사실 너무 섬세해서 저는 마음에 들지 않았어요. 그래서 Carbn에서 진동 엔진을 뽑아내어 여기에 재사용했어요.\n\n기존 새로고침 코드에 정말 가혹한 부작용을 추가했어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n// CodeView.swift\n\n.onReceive(timer) { _ in\n    let didChange = viewModel.refresh()\n    if didChange {\n        HapticEngine.shared.play(haptic: .refresh)\n    }\n}\n```\n\n집에서는 시도하지 마세요, 친구들!\n\n## 이미지 로딩 버그\n\nCachedAsyncImage 라이브러리에서 FavIcons가 존재하지 않음에도 불구하고 열심히 로딩되는 버그가 있습니다. 이로 인해 희미한 지구 모양이 나타납니다... 하지만 이대로 릴리스할 것 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 경우 90% 정도는 잘 작동하며, 제가 개발한 Third-party SwiftUI 라이브러리 중 하나를 바꾸는 대신 배포하는 게 더 좋을 것 같아요.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_29.png)\n\n## 중복 버그\n\n배포 전에 나머지 버그들 중 일부는 더 주의 깊게 살펴보았지만, 이 문제는 특히 나쁩니다. 누군가가 QR 코드를 두 번 스캔하면 동일한 계정의 이상한 중복이 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// TODO: - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시하도록 해주세요 - 이미 있는 경우 계정에 스캔을 추가하지 마세요\n```\n\n시간을 절약할 수 있는 라이브러리를 뜯어내고 교체하는 대신, 이 버그는 한 줄의 코드 수정으로 해결되었습니다.\n\n```js\n// CodeViewModel.swift\n\nfunc create(account: Account, url: URL) throws {\n    guard !accounts.contains(where: { $0.name == account.name }) else { return }\n    // ...\n}\n```\n\n2FA 계정을 이름을 기준으로 하는 키체인이기 때문에, 이 수정은 매우 합리적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 코드가 로드되지 않음\n\n코드가 대기열에 들어가지 않는 다른 문제를 발견했어요.\n\n```js\n// TODO: - 초희귀한 GET가 전송되지 않나요?? 에뮬레이터에서 로컬에서 발생시키질 못하겠는데 퀸트는 잘 됩니다 - 들어가야 할 것 같아요\n```\n\n알고 보니 @AppStorage가 실제로 작동하는 방식을 잘못 이해했던 것 같아요 — 기본값은 실제로 사용자 기본 설정에 저장하는 대신 UI에만 적용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n// SettingsView.swift\n\n@AppStorage(\"sexts\") private var sexts: Bool = true\n```\n\n첫 번째 앱 로드 시 UserDefaults를 채우는 함수가 이 문제를 해결했습니다.\n\n```swift\n// CheckEmApp.swift\n\n@main\nstruct CheckEmApp: App {\n\n    init() {\n        initializeDefaultsIfRequired()\n    }\n\n    // ...\n\n    func initializeDefaultsIfRequired() {\n        guard UserDefaults.standard.object(forKey: \"sexts\") == nil else { return }\n        CodeGenerator.shared.initializeDefaults()\n    }\n```\n\n## TipKit\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 iOS 17 TipKit를 사용하여 조금 더 개선했어요. 사용자가 앱을 처음 로드할 때 무엇을 해야 하는지 간단히 이해할 수 있게 도와주는 기능이 추가되었답니다.\n\n![app screenshot](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_30.png)\n\n이 새로운 API로 구현하는 것이 의외로 간단했어요.\n\n```js\n// CodeView.swift\n\n@ViewBuilder\nprivate var tips: some View {\n    TipView(QRTip()).tipImageSize(CGSize(width: tipImageSize, height: tipImageSize))\n    TipView(SettingsTip()).tipImageSize(CGSize(width: tipImageSize, height: tipImageSize))\n    TipView(CollectionTip()).tipImageSize(CGSize(width: tipImageSize, height: tipImageSize))\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 상점 상품 목록\n\n출시할 준비가 끝났다고 생각해요.\n\n![상품 목록](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_31.png)\n\nAppScreens를 통해 상점 상품 목록을 설정 중이에요. 저희의 캣츠가 등장하는 Check 'em의 진정한 힘을 보여주는 두 번째 스크린샷을 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n---\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_32.png)\n\n진짜요?\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_33.png)\n\n알겠어요, 제가 세계에서 가장 자유주의자적인 사람은 아니지만, 시장을 1% 증가시키기 위해 여러 가지 번거로움을 겪는 건 싫어요. 좀 더 나은 방법이 있지 않을까요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(내 프랑스 독자 여러분 죄송해요)\n\n간단히 말해서, 우리는 앱 스토어 커넥트에 설정을 완료했고 버튼을 누르기 ready해요!\n\n## 결론\n\n저의 여정을 따라 읽어주셔서 감사합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트는 정말 재미있었어요! 패턴을 찾는 것을 좋아하는 내 내재적인 IT 열정을 만졌을 뿐만 아니라, 멋진 처리, 스레딩, 최적화 문제를 다루어 볼 수 있었어요!\n\n다음 단계로, v1.1 릴리스에 대한 성능에 완전히 초점을 맞춘 상태입니다. 이제 OTP(일회용 암호)를 더 빠르게 처리하고 빠르게 불러올 거예요!\n\n이 앱을 좋아하시면, 보고 싶은 숫자에 대한 의견을 주세요! 마지막으로, Android 버전을 원하는 분들이 계신다면, 제 소스 코드를 공유해드리고 함께 개발할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png"},"coverImage":"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png","tag":["Tech"],"readingTime":28},{"title":"iOS용 Fastlane과 GitHub Actions를 사용하여 CICD 파이프라인 구성하기","description":"","date":"2024-05-23 14:50","slug":"2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions","content":"\n\n현재 소프트웨어 개발에서 필수적인 실천 방법인 지속적 통합 및 지속적 배포 (CI/CD)는 애플리케이션의 테스트, 빌드, 그리고 배포 과정을 자동화합니다. iOS 개발자들에게는 GitHub Actions와 Fastlane을 활용하여 이러한 방식을 효율적으로 구현할 수 있습니다.\n\nCI/CD 파이프라인은 코드 품질을 유지하고 신속하고 신뢰할 수 있는 소프트웨어 제공을 보장하는 데 중요합니다. CI는 코드 변경 사항을 자동으로 테스트하여 문제를 조기에 감지하는 반면, CD는 코드가 빠르고 안전하게 프로덕션 환경에 배포될 수 있도록 합니다. CI/CD를 도입하면 개발자들이 수동 테스트 및 배포에 소비하는 시간을 크게 줄일 수 있어 코드 작성에 집중할 수 있습니다.\n\niOS 개발에서 GitHub Actions와 Fastlane은 서로 완벽하게 보완적입니다:\n\n- GitHub Actions: GitHub에 직접 통합되어 있는 유연하고 확장 가능한 CI/CD 서비스로, 워크플로우를 자동화할 수 있습니다.\n- Fastlane: iOS 및 Android 앱을 빌드, 테스트 및 릴리스 자동화하는 오픈 소스 플랫폼으로, 복잡한 작업의 설정 및 관리를 간편화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일련의 테이블 태그를 Markdown 형식으로 변경해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 개발 프로세스는 새로운 기능을 작업하거나 버그를 수정하는 개발자로부터 시작됩니다. 이 작업은 주요 개발 브랜치에서 파생된 별도 브랜치에서 수행됩니다.\n\n2. 개발자가 풀 리퀘스트(Pull Request)를 생성합니다:\n\n- 개발자가 변경 사항을 완료하면, 그들은 자신의 브랜치를 주요 개발 브랜치에 병합하기 위해 풀 리퀘스트(PR)를 만듭니다.\n\n3. CI가 단위 테스트를 실행합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 풀 리퀘스트를 생성하면 CI (Continuous Integration) 시스템이 자동으로 유닛 테스트를 실행하게 됩니다. 이 단계는 새 코드가 회귀를 발생시키지 않거나 기존 기능을 파괴하지 않았는지를 확인합니다.\n\n팀원들은 코드 변경 사항을 검토합니다:\n\n- CI 시스템이 테스트를 실행하는 동안, 팀원들은 코드 변경 사항을 검토합니다. 코드 품질, 코딩 표준 준수 여부, 그리고 구현의 정확성을 확인합니다.\n\n만약 코드가 팀에서 좋게 보이고 유닛 테스트가 통과하면, 개발자가 풀 리퀘스트를 병합합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 유닛 테스트가 통과하고 코드 리뷰가 만족스러운 경우, 개발자가 풀 리퀘스트를 메인 개발 브랜치에 병합합니다.\n\n6. 풀 리퀘스트가 병합되면 CI가 빌드를 생성하여 TestFlight로 전송합니다:\n\n- 풀 리퀘스트가 병합되면 CI 시스템이 빌드 프로세스를 트리거합니다. 이 빌드는 자동으로 TestFlight로 업로드되며, TestFlight는 iOS 베타 앱을 테스터에게 배포하는 데 사용되는 플랫폼입니다.\n\n이 워크플로우는 새로운 코드 변경사항이 본 브랜치에 통합되기 전에 철저히 테스트되고 리뷰되도록 보장합니다. CI/CD의 사용은 테스트 및 배포 프로세스를 자동화하여 효율성을 향상시키고 프로덕션 환경에 오류를 도입할 가능성을 줄입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 전제 조건\n\nCI/CD 파이프라인을 설정하기 전에 다음 사항을 확인해주세요:\n\n- iOS 프로젝트용 GitHub 저장소\n- Apple 개발자 계정\n- 로컬 머신에 Xcode 설치\n\n# CI/CD 설정 단계별 안내\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 초기 설정\n\n먼저, 귀하의 저장소를 복제하고 로컬로 이동하세요:\n\n```js\ngit clone https://github.com/yourusername/your-ios-repo.git\ncd your-ios-repo\n```\n\n# 2. Fastlane 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFastlane을 RubyGems를 이용하여 설치해보세요:\n\n```js\nsudo gem install fastlane -NV\n```\n\n다음으로, 프로젝트 디렉토리로 이동하고 Fastlane을 초기화해보세요:\n\n```js\ncd your-ios-repo\nfastlane init\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트용 Fastlane을 설정하는 방법을 따라하세요. 베타 배포와 테스팅을 자동화하는 옵션을 선택하세요.\n\n# 3. Fastlane 설정하기\n\n프로젝트의 fastlane 디렉토리에 Fastlane에 의해 생성된 Fastfile을 열어보세요. 앱을 빌드하고 테스트하는 레인을 정의하세요. 예를 들면:\n\n```js\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"모든 테스트 실행\"\n  lane :test do\n    scan\n  end\n\n  desc \"베타 배포용 앱 빌드\"\n  lane :beta do\n    build_app\n    upload_to_testflight\n  end\nend\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. GitHub Actions 설정하기\n\n프로젝트 루트에 .github/workflows 디렉토리를 생성해주세요. 만약 없다면, 새로 만들어주세요. 이 디렉토리 안에 ci.yml이라는 파일을 만들어주세요:\n\n```yaml\nname: CI\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Ruby\n        uses: actions/setup-ruby@v1\n        with:\n          ruby-version: 2.7\n\n      - name: Install Fastlane\n        run: gem install fastlane\n\n      - name: Install dependencies\n        run: bundle install\n\n      - name: Run tests\n        run: fastlane test\n```\n\n이 설정은 main 브랜치로의 모든 push 및 pull request에서 workflow를 트리거합니다. macOS 환경을 설정하고, Ruby와 Fastlane을 설치한 후 Fastlane 구성에서 정의된 테스트를 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 내용을 한국어로 번역하겠습니다.\n\n- on: 이 키는 workflow를 트리거하는 이벤트를 정의합니다.\n- push: 지정된 브랜치에 푸시가 발생할 때마다 workflow가 실행되어야 함을 나타냅니다.\n- branches: 푸시 이벤트를 트리거하는 브랜치를 나열합니다. 여기에서는 주 브랜치로 설정되어 있습니다.\n- pull_request: 지정된 브랜치를 대상으로 하는 pull request에 대해 workflow가 실행되어야 함을 나타냅니다. 다시 말해, 주 브랜치입니다.\n- jobs: workflow를 구성하는 작업을 정의합니다. 이 예시에서는 빌드라는 단일 작업이 있습니다.\n- build: 이것은 작업의 이름입니다.\n- runs-on: 작업을 실행할 기계의 유형을 지정합니다. macos-latest은 GitHub의 호스팅된 러너에서 사용 가능한 macOS의 최신 버전에서 작업이 실행됨을 나타냅니다.\n- steps: 작업을 구성하는 개별 단계를 정의합니다. 각 단계는 단일 작업을 실행합니다.\n- name: 단계를 설명합니다. 가독성을 위해 단계가 무엇을 하는지 식별하는 데 도움이 됩니다.\n- uses: GitHub Actions marketplace에서 사용할 액션을 지정합니다. actions/checkout@v2는 저장소 코드를 확인하여 이후 단계에서 액세스할 수 있게 하는 동작입니다.\n- uses: GitHub Actions marketplace의 다른 동작입니다. actions/setup-ruby@v1은 Ruby 환경을 설정합니다.\n- with: 동작에 대한 추가 매개변수를 지정합니다.\n- ruby-version: 사용할 Ruby 버전을 정의합니다. 여기에서는 2.7입니다.\n- run: 셸 명령을 실행합니다. 이 단계에서는 Fastlane이라는 iOS 및 Android 배포를 자동화하는 도구를 설치하기 위해 gem install fastlane 명령을 실행합니다.\n- run: 이 단계에서는 bundle install을 실행하여 Gemfile에서 지정된 종속성을 설치합니다. 모든 필요한 gem이 설치됨을 보장합니다.\n- run: 이 단계에서는 Fastfile에서 정의된 Fastlane 테스트 라인을 실행합니다. 일반적으로 iOS 프로젝트의 단위 테스트를 실행하는 것을 포함합니다.\n\n이 workflow의 각 단계는 iOS 프로젝트의 CI 프로세스를 자동화하기 위해 설계되었습니다:\n\n- 코드 가져오기: 저장소의 코드를 검색합니다.\n- Ruby 설정: Ruby 환경을 준비합니다.\n- Fastlane 설치: Fastlane 도구를 설치합니다.\n- 종속성 설치: Bundler를 사용하여 필요한 프로젝트 종속성을 설치합니다.\n- 테스트 실행: 코드가 올바르게 작동하는지 확인하기 위해 Fastlane에 정의된 테스트를 실행합니다.\n\n# 5. 보안 관리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱을 배포하려면 API 키 및 인증서와 같은 민감한 정보를 안전하게 저장해야 합니다. GitHub 저장소에서 Settings \u003e Secrets 메뉴로 이동하여 필요한 시크릿을 추가하세요:\n\n- APP_STORE_CONNECT_API_KEY\n- MATCH_PASSWORD\n- FASTLANE_SESSION\n\n자세한 지시 사항은 Fastlane 문서에서 시크릿 및 API 키를 관리하는 방법을 참조하세요.\n\n# 6. 워크플로우 실행하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깃허브에 변경 사항을 푸시하세요. 이 작업은 ci.yml에서 정의한 워크플로를 트리거합니다. 깃허브 저장소의 Actions 탭에서 워크플로 진행 상황을 확인할 수 있습니다.\n\n# 결론\n\nGitHub Actions와 Fastlane을 사용하여 iOS 개발을 위한 CI/CD 파이프라인을 설정하면 자동화된 테스트, 빌드 및 배포를 제공하여 개발 워크플로를 크게 향상시킬 수 있습니다. 위에서 설명한 단계는 이러한 설정이 신속하게 구현될 수 있음을 보여주며, 코드 품질을 유지하고 릴리스 프로세스를 가속화할 수 있도록 도와줍니다. 이러한 도구를 활용하여 견고하고 효율적인 개발 주기를 보장함으로써 팀이 훌륭한 앱을 만들 수 있도록 돕는 것입니다.\n\n지속적 통합 및 배포가 구현되면 문제를 빨리 파악하고 코드 품질을 보장하며 기능을 더 빠르고 신뢰할 수 있게 사용자에게 제공할 수 있습니다. 이는 현대 소프트웨어 개발의 최상의 관행을 구현하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 축하드려요! 🥳\n\n![이미지](/assets/img/2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions_1.png)","ogImage":{"url":"/assets/img/2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions_0.png"},"coverImage":"/assets/img/2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions_0.png","tag":["Tech"],"readingTime":6},{"title":"2024 OWASP 모바일 탑 10 변경 사항에 대한 소식이 뭐길래","description":"","date":"2024-05-23 14:48","slug":"2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes","content":"\n\n# 소개\n\n먼저, 2024년 새해 복 많이 받으세요 🎉 이미 2월이 되었지만, 올해 첫 게시물이라 조금 늦었다는 점 이해해 주시면 감사하겠습니다.\n\n그 외에도, 좋은 소식은 올해 모바일 보안 분야에서 이미 흥미로운 소식으로 시작되었다는 것입니다. 이 게시물에서는 2024년을 위한 OWASP Mobile Top 10의 변경 사항을 살펴보고, 그것이 보안에 민감한 개발자인 여러분에게 무슨 의미가 있는지 알아보겠습니다!\n\n저의 OWASP Mobile Top 10 강의나 포스트에 이미 익숙한 분들은 당연히 \"OWASP의 정상\" 섹션으로 건너뛰어서 흥미로운 내용을 확인할 수 있습니다. 그러나 OWASP가 무엇이며 최근 변경 사항이 모바일 보안 분야에서 큰 영향을 미친다는 사실에 대해 잘 알지 못하거나 간단히 상기시키고 싶다면, 함께 머물러 주시면 OWASP란 무엇이며 최근 변경 사항이 모바일 보안 분야에서 왜 중요한지에 대해 다시 한 번 요약해 드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# OWASP이 뭐죠? 🐝\n\n모바일 보안에 새로 오신 분이나 제 블로그 게시물을 처음 보시는 분, 혹은 한동안 돌아본 적이 없는 분들께 질문드립니다. OWASP와 그들이 하는 훌륭한 작업에 대해 아시지 못할 수 있습니다.\n\n2001년에 설립된 OWASP(Open Worldwide Application Security Project) 재단은 비영리 단체로, 소프트웨어 보안 관행에 대한 교육 자료, 도구, 교육 자원 및 다른 다양한 커뮤니티 기반 서비스를 제공합니다. 우리 분야에서 선두적인 어플리케이션 보안 커뮤니티로 널리 인정받으며 다양한 프로젝트에서 모바일 보안을 다루는 프로젝트를 비롯한 많은 헌신적인 자원봉사자들이 있습니다.\n\nOWASP가 제공하는 안내 중 하나는 'Top 10' 위협 목록입니다. 이 목록은 OWASP가 특정 영역의 보안에 대한 자신의 상위 10위 위협 목록으로, 모든 개발자에게 매우 유용한 자원입니다¹.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 이전에 그들의 지난 안내에 대해 다양한 콘텐츠를 제공했습니다. 더 자세히 알고 싶다면, 제 발표 페이지와 이전 OWASP 관련 블로그를 확인해보세요. 그 곳에는 더 많은 자세한 내용과 관련 링크가 있습니다.\n\n보다 실용적인 학습자라면, 제 OWASP 발표를 위한 동반 앱도 있습니다. 그 앱은 제가 소개한 주제 중 일부를 보여줍니다.\n\n어쨌든, 2024년은 거의 10년 만에 가장 중요한 Mobile Top 10의 수정이 이루어지고 있습니다. 그래서 더 이상 말 할 필요 없이, 무엇이 변했는지 살펴보겠습니다! 👀\n\n# “OWASP의 꼭대기\" ✨\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n긴 협의 기간과 여러 차례의 수정을 거친 끝에, 최근 발표된 OWASP Mobile Top Ten 2024는 2014년 최초 발표 이후 세 번째이자 최신 주요 개정판입니다.\n\n2024년 발표 버전은 2016년 버전을 대체하며, 현재의 모바일 보안 환경을 더 잘 반영하기 위해 네 가지 새로운 위협 범주와 위협의 완전한 재배열을 포함한 명백한 변경 사항을 가져왔습니다.\n\n이 모든 것은 잘 된 일이지만, 실제로 무엇이 변경되었고 이 모든 의미가 무엇을 의미하는지 궁금하십니까? 😅 음, 진짜 Billboard 차트 스타일로 (이나 영국인으로서는 Top of the Pops 스타일로), 각 위협에 대해 순서를 거꾸로하여 번호 10부터 간단히 설명해 보겠습니다!\n\n![이미지](https://miro.medium.com/v2/resize:fit:768/1*9ESds38QHiOyqz_CkOXM7A.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## #10: 부적절한 암호화 ⬇️\n\n2016년 5위에서 내려온 부적절한 암호화는 모바일 앱이 현대 암호화 최상의 방법을 채택하지 못해 겪는 위협입니다. 이는 안전하지 않은 알고리즘(SHA-1, MD5 등)을 구현하거나 안전한 데이터 전송(HTTPS)을 사용하지 않거나 심지어 키에 맛있는 소금을 쓰지 않는 것으로 나타납니다 🧂.\n\n암호화를 사용할 때, 특정 필요에 맞는 최상의 방법을 따르도록 하십시오. 예를 들어, AES와 같은 알고리즘을 사용하면서 최소 128비트 블록 크기 또는 최소 2048비트 RSA를 사용하는 것이 좋습니다. 의문이 생길 경우, 전문가에게 질의하거나 Google의 tink 라이브러리와 같은 신뢰할 수 있는 도구를 활용하십시오.\n\n앞으로 제 블로그에서 관련 포스트가 올라올 예정입니다 (희망적으로) 📝.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## #9: 안전하지 않은 데이터 저장 ⬇️\n\n2016년 목록에서 크게 순위가 변동한 항목 중 하나는 안전하지 않은 데이터 저장이었어요. 2위에서 9위로 내려왔네요. 아파요 😣\n\n만약 데이터(네트워크 호출 포함)를 로그에 출력하거나, 비밀번호나 토큰을 저장하거나, 임시 파일을 생성하거나, 또는 SQL 데이터베이스나 Shared Preferences와 같은 표준 저장 기술을 사용하고 있다면, 당신의 앱은 안전하지 않은 데이터 저장에 취약할 수 있습니다.\n\n저는 이전에도 안전하지 않은 데이터 저장에 대해 자세히 다뤘었어요. 그래서 제 글을 꼭 확인하고, 앱의 데이터가 안전하고 안전하게 저장되어 있는지 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언제나 강조해야 할 점은 가능한 경우 기기에 민감한 데이터를 저장하는 것을 피하는 것이 최선의 실천 방법입니다!\n\n## 8번: 보안 구성 오류 ⬆️\n\n10위에서 상승한 이 ‘보안 구성 오류’라는 새로운 명칭의 ‘Extraneous Functionality’에 대해 이야기해 보겠습니다.\n\n‘RTFM’ 개념을 알고 있다면, 이 위협이 무엇인지 알 수 있을 것입니다. 이는 종종 개발자가 제품 빌드에서 잘못된 설정을 사용하거나 필요하지 않은 상승된 액세스나 권한을 요청하거나 원래는 애플리케이션 내부로 의도된 기능을 노출하는 데 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문서화는 종종 친구가 될 수 있어요. 읽는 걸 소홀히 하지 마세요. 🥲 커피를 가져다가 실수에 갇히세요!\n\n## #7: 바이너리 보호 미비 ⬆️\n\n크림, 오디오스레이브 또는 아톰 포 피스와 같이 유명한 밴드들처럼, 2016년 8위와 9위(코드 위조 및 역공학)가 합쳐져 7위로 올라왔어요. 😎\n\n바이너리 보호는 앱의 바이너리(즉, 안드로이드의 .apk/.aar 또는 iOS의 .ipa 파일)가 정보를 유출하지 않거나 다시 패키징되지 않도록 하는 데 초점을 맞춥니다. 앱을 제대로 난독화하지 않거나 무결성 검사를 제대로 하지 않으면 공격자가 악성 코드를 주입하여 앱을 역공학하거나 재분배할 수 있는 가능성이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 좋은 친구 Guardsquare과 그들의 훌륭한 도구(예: DexGuard 및 Proguard Playground)를 적극 추천합니다. 이 도구들은 특정 위협으로부터 앱을 안전하게 유지하는 데 도움이 됩니다. 또는 R8 및 Google Play 무결성 API에 대해 더 알아보는 데 투자하는 것도 도움이 될 수 있어요!\n\n## #6: 불충분한 개인정보 보호 기능 🆕\n\n6위로 새롭게 입성한 '불충분한 개인정보 보호 기능'입니다.\n\n당신의 앱이 사용자의 개인 식별 정보(예: 전체 이름, 정확한 위치, 금융 상세 정보, 성향 등)를 다룬다면, 이 정보들이 잘못된 손에 들어가면 해당 사용자를 사칭하거나 괴롭히거나 사기를 저질 수 있는 경우가 발생할 수 있습니다. 이 경우 이것이 해당될 수도 있어요! 🥸\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플리케이션이 저장하거나 기록하는 개인 식별 정보(PII)를 로컬에 저장하지 않도록하고 사용자로부터의 정보 최소한만 요청/전송하십시오. 이렇게 하면 저장소나 데이터 전송의 취약점을 통해 PII가 노출될 가능성이 크게 줄어듭니다.\n\n예를 들어, 영화 예매 앱에서 성적 지향이나 정확한 위치가 필요합니까? 아마 아니죠! 대신 코스 위치를 요청하여 인근 영화관을 찾고 사용자가 추천을 받기 위해 추가 개인 정보를 제공할 수 있도록 요청하고, 나중에 그것을 선택적으로 거부할 수 있도록 하는 것이 훨씬 나을 것입니다.\n\n## #5: 통신 불안전 ⬇️\n\n또 다른 이동! 2016년 3위인 '통신 불안전'이 5위로 두 단계 하락했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 전송이나 수신과 관련된 위협을 다루고 있어요. 대부분의 응용프로그램은 인터넷을 통해 이를 수행하지만, 여러분의 앱은 NFC나 블루투스와 같은 다른 통신 방법을 사용할 수도 있어요. 데이터 통신이 있으면, 거기에는 위험이 연결되어 있을 거라고 확신할 수 있어요!\n\n이 문제에 대해 더 자세히 다루지는 않겠어요. 이전에 보안 통신에 대해 블로그를 썼었기 때문에 그 부분도 꼭 확인해보시길 바래요.\n\n## #4: 충분하지 않은 입력/출력 유효성 검사 🆕\n\n4번 항목의 새로운 주제는 사용자 입력 및 출력을 다뤄봅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모바일 앱 및 API가 사용자 입력을 통신하거나 출력할 때 올바로 처리되도록 하는 것이 매우 중요합니다 🛁 그렇지 않으면 SQL 인젝션 또는 교차 사이트 스크립팅 (XSS)과 같은 위협이 발생할 수 있으며 이는 민감한 사용자 데이터를 노출하거나 더 심각한 경우 기기가 위협받을 수 있습니다. 원하는 값 및 형식을 얻고 해당 기준에 충족하지 않는 경우는 버려야 합니다.\n\nWhatsApp에서 유포된 ‘Effective Power’ 또는 ‘Black Spot’ 메시지를 기억하시나요? WhatsApp 메시지에 특별히 디자인된 입력이 출력될 때 발생한 문제였는데, 이는 일종의 ‘서비스 거부’로 설계된 것이었습니다. — 여기서 살균 처리가 문제를 해결했을까요? 아마도 가능합니다!\n\n요약하면, 입출력 조심하면 ‘작은 바비 테이블’이 문제를 일으키지 않아도 안심할 수 있습니다 ⁶.\n\n## #3: 안전하지 않은 인증/인가 ⬆️\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIn the new ranking, insecurities related to authentication and authorization have moved up to the 3rd place, combining aspects from the previous 4th and 6th spots.\n\nTo prevent confusion due to similar names, let's clarify that authentication confirms the user's identity, while authorization verifies if the user has the necessary roles or credentials to access specific resources.\n\nIt's crucial to perform authentication and authorization checks on the server side to prevent vulnerabilities from potential binary modifications or other methods.\n\nWhen interacting with APIs that need authorization, make sure to use revocable tokens linked to the device. This way, users can revoke tokens if their device is lost or stolen. Remember to refresh tokens regularly and ensure your backend team authenticates properly when authorizing access to restricted resources!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다시, Insecure Authentication에 대한 자세한 내용은 해당 주제에 대한 이전 블로그를 확인해 보세요 🤠 이어서 Insecure Authorization에 대한 더 많은 정보를 확인할 수 있을 거에요.\n\n## #2: 부적절한 공급망 보안 🆕\n\n제 2위에 새로운 항목이 추가되었는데, 이는 우리 앱을 구축하는 데 사용하는 도구와 프로세스에 초점을 맞추고 있어요.\n\n'공급망 공격'은 사용하는 도구에 대한 공격을 말하며, 감지되지 않고 도구에 취약점, 보안 위협 또는 악의적인 코드를 도입하는 것을 의미해요. 조직 내부에서는 부정직한 직원에 의해, 또는 시스템이나 도구에 특권 액세스를 얻은 악의적인 행위자에 의해 외부에서 이루어질 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 보안을 강화하기 위해 코드 검토 프로세스를 철저히 실시하는 것이 중요합니다. 뿐만 아니라 공급망의 액세스 제어에 대한 정기적인 감사도 수행해야 합니다. 앱의 종속성을 모니터링하고 이들이 정기적으로 검토되도록 하여 보안 취약성을 방지해야 합니다.\n\n이미 확인하지 않았다면, 저는 이전에 공급망 공격과 Gradle 작업 시 어떻게 완화할 수 있는지에 대해 블로그 게시 및 강의를 진행했습니다.\n\n## #1: 부적절한 자격 증명 사용 🆕\n\n대망의 순간입니다 🥁 OWASP에 따르면 모바일 보안의 가장 큰 위협은... 부적절한 자격 증명 사용입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 사용자 자격 증명, API 키부터 그 사이의 모든 것에 적용되는 보안 부적절로 인한 케이스를 포괄하는 범주입니다!\n\n알람이 울리는 2021 보고서에 따르면 추정 200개 애플리케이션 중 1개가 하드코딩된 API 키를 통해 AWS 자격 증명을 유출한 것으로 추정되었습니다 😅 이처럼 API 키 또는 하드코딩된 자격 증명이 노출되면 파괴적인 결과가 초래될 수 있습니다. 이러한 종류의 자격 증명 유출은 이전에 Uber, Verizon, Accenture 등 주요 기업들에게 피해를 입히고, 고객 데이터(포함된 개인 식별 정보 및 결제 정보)가 노출된 데이터 침해를 발생시켰습니다 🙀 일반적으로 로컬에 저장해야 하는 민감한 데이터는 항상 암호화되어야하며, 암호화에 사용되는 키는 하드웨어 보호 키 저장소에 안전하게 저장되어야 합니다.\n\n이 모든 소리들이 겁나게 들리지만, 자신이 부적절한 자격 증명 처리에 걸리지 않는 방법은 꽤 간단합니다. 사용자 자격 증명(비밀번호 등)을 장치에 저장하지 않으며, 제3자 API 키를 정기적으로 교체하고, 언제나 HTTPS를 통해 자격 증명을 안전하게 전송해야 합니다. 간단하죠! 🙌\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리로... 🐝\n\n마지막으로, 2016년과 2024년 목록 사이에 상당한 변화가 있었지만, 보안에 민감한 개발자로서 여러분은 항상 응용 프로그램을 잠재적인 위협에 대해 지속적으로 모니터링해야 합니다. 상위 10개가 변경되었을 수 있지만, 많은 개발자들이 모바일 보안을 제대로 이해하지 못한다는 현실은 여전합니다. 더 많이 배우고 이 지식을 공유함으로써 이를 바꿀 수 있습니다!\n\n이 글에서 하나의 교훈을 얻는다면, 모바일 애플리케이션에 대한 잠재적인 위협에 대해 여러분과 팀원들이 숙지되어 있는지 확인하고 (MASVS와 같은 훌륭한 자원이나 저의 블로그를 읽는 것처럼) AppSweep, MobSF, Snyk, 또는 SonarQube와 같은 도구를 통합하여 코드/바이너리를 이러한 문제에 계속적으로 점검해보시기 바랍니다.\n\n마지막까지 완주하셨네요! 2024년이 멋지고 안전한 한 해 되길 바랍니다 🥰 🔐\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 감사합니다 🌟\n\n언제나 읽어 주셔서 감사합니다! 이 포스트를 재밌게 보셨으면 @Sp4ghettiCode로 피드백을 트윗해 주세요. 반응이나 좋아요, 트윗, 공유, 스타 등도 잊지 말고 해 주세요 🙂\n\n## 더 읽기\n\n- OWASP Top Five Companion App (2016 버전)\n- OWASP Mobile Top Ten 2024\n- Mobile Application Security Verification Standard: MASVS\n- Mobile Application Security Testing Guide: MASTG\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 각주\n\n[1]: 보안 중심의 모바일 개발자이시라면, 업데이트된 MASVS 및 MASTG에 특히 주의를 기울여 모바일 앱의 보안 모델을 적용하고 테스트해야 합니다.\n\n[2]: 염화 나트륨과는 아무 상관이 없습니다. 이 문맥에서의 \"솔트(salt)\"는 동일한 평문이 여러 번 입력되더라도 다른 해시값이 생성되도록 보장하기 위해 평문에 연결된 임의의 데이터를 의미합니다.\n\n[3]: 불편하기는 해도, 2024년 Top 10이 5위에 있을 때 대부분 완성된 \"Insufficient Cryptography\" 글은 최종적으로 10위가 아니라는 것을 알았습니다. (그런데 누가 10부작 블로그 시리즈를 생각해냈을까요!?)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[4]: 제발 제품에서 네트워크 호출을 로깅하는 것을 그만둬주세요. 이미 2024년이에요. 🥲\n\n[5]: 'F'는 정말 옳은 것을 가리키는 것이에요 😅\n\n[6]: https://xkcd.com/327/","ogImage":{"url":"/assets/img/2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes_0.png"},"coverImage":"/assets/img/2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes_0.png","tag":["Tech"],"readingTime":9},{"title":"CSRF로 인해 계정이 삭제될 수 있습니다","description":"","date":"2024-05-23 14:47","slug":"2024-05-23-CSRFLeadstoDeleteAccount","content":"\n\n# 안녕하세요!\n\n![이미지](/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png)\n\n# 소개\n\n- 대상: 안드로이드 애플리케이션\n- 날짜: 2024년 5월\n- 요약: Corp 앱에서 CSRF 취약점을 발견했습니다. 이 취약점을 이용하여 사용자 계정을 삭제할 수 있는 Deeplink와 delete-account 엔드포인트 간의 상호작용이 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 복제 단계\n\n- 먼저 AndroidMainfast.xml을 살펴봅니다.\n\n```xml\n        \u003cactivity android:theme=\"@style/Theme.Thredup.Splash\" android:name=\"com.example.android.feature.splash.SplashActivity\" android:exported=\"true\" android:launchMode=\"singleTask\" android:screenOrientation=\"behind\" android:configChanges=\"screenSize|orientation\" android:noHistory=\"true\"\u003e\n            \u003cintent-filter android:autoVerify=\"true\"\u003e\n                \u003caction android:name=\"android.intent.action.VIEW\"/\u003e\n                \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e\n                \u003ccategory android:name=\"android.intent.category.BROWSABLE\"/\u003e\n                \u003cdata android:host=\"www.example.com\" android:pathPrefix=\"/account\"/\u003e\n                \u003cdata android:scheme=\"https\"/\u003e\n                \u003cdata android:scheme=\"http\"/\u003e\n            \u003c/intent-filter\u003e\n        \u003c/activity\u003e\n```\n\n- 'adb'를 사용하여 호출한 후에 /account/라는 Path로 이 Deeplink를 발견했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 지금은 설정에 있어요;\n- 잠시만 android:pathPrefix=/account/는 무슨 의미일까요?\n- android:pathPrefix 속성은 Intent 객체의 경로의 초기 부분에만 일치하는 부분 경로를 지정합니다. 그래서 아마도 /account/ 뒤에 무언가를 찾을 수 있을지도 모릅니다.\n- 설정 이후에 API 호출을 가로챈 후, 비밀번호 변경이나 계정 삭제와 같은 설정 후의 API 엔드포인트를 Deeplink에서 사용해 봅시다.\n\n```js\nadb shell am start -a android.intent.action.VIEW -n com.thredup.android/com.thredup.android.feature.splash.SplashActivity -d \"https://www.example.com/account/change_password\"\n\nadb shell am start -a android.intent.action.VIEW -n com.thredup.android/com.thredup.android.feature.splash.SplashActivity -d \"https://www.example.com/account/delete_password\"\n```\n\n- 지금 CSRF로 만들어 봐요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n\u003c!DOCTYPE html\u003e\n\u003chtml\u003e\n\u003ca href=\"https://www.example.com/account/change_password\"\u003eCSRF DEMO\u003c/a\u003e\n\u003c/html\u003e\n```\n\n# Proof of Concept","ogImage":{"url":"/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png"},"coverImage":"/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png","tag":["Tech"],"readingTime":3},{"title":"Android Kotlin 개발자를 위한 Swift 참고 자료","description":"","date":"2024-05-23 14:45","slug":"2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers","content":"\n안녕하세요! 안드로이드 개발자들은 대부분 Kotlin으로 작업합니다. 그러나 iOS에서 어떤 기능이 구현되는 방법을 참조할 때 Swift를 읽고 이해하는 것도 도움이 될 수 있습니다. 또한 Kotlin Multiplatform을 탐색하는 경우에도 유용합니다.\n\niOS 개발자도 Android 코드를 살펴볼 때 이와 같은 원리가 적용됩니다. Kotlin을 읽고 이해하는 방법을 알면 보다 쉬워집니다.\n\n우리는 iOS 코드를 살펴볼 때 볼 수 있는 몇 가지 일반적인 Swift 패턴에 대해 다루고, 이해하려고 노력하고 Kotlin에서의 구현과 비교해 볼 것입니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 기본 사항\n\n## 변수\n\nSwift에서 변수와 상수는 각각 var 및 let 키워드를 사용하여 정의됩니다. 세미콜론을 사용하여 유형 주석을 제공할 수 있지만 필수는 아닙니다.\n\n```js\n// Swift\nlet animDurationMillis: Int = 500\nvar clickCount = 0\n\n// Kotlin\nval animDurationMillis: Int = 500\nvar clickCount = 0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 시점에서 두 언어의 유일한 차이점은 읽기 전용 변수를 정의하는 let 대 val 키워드입니다.\n\n## 옵셔널 / 널 가능성\n\n옵셔널이나 널 가능한 유형의 경우, 두 언어 모두 같은 ? 문자를 사용하지만, 값이 없는 상태에 대해서는 nil 대 null이 유일한 차이점입니다.\n\n```swift\n// Swift\nvar foundItem: String? = nil\n\n// Kotlin\nvar foundItem: String? = null\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnil 상태를 처리하는 여러 가지 방법이 있습니다:\n\n- 값 확인을 위해 if 표현식을 사용하는 방법 (이 내용은 뒤에서 다룹니다),\n- 옵셔널 바인딩을 사용하는 방법 (이 내용은 뒤에서 다룹니다),\n- 대체/기본값을 제공하는 방법,\n- 강제 언래핑을 하는 방법.\n\n마지막 두 가지 접근법의 예시가 여기 있습니다. 코틀린이 거의 동일한 방식을 제공한다는 것을 알 수 있습니다. 문법에 약간의 차이가 있습니다 (?? vs ?: 및 ! vs !!).\n\n```js\n// Swift\n//  - 대체/기본값\nlet actualFoundItem = foundItem ?? \"empty\"\n//  - 강제 언래핑\nlet actualFoundItem = foundItem!\n\n// Kotlin\n//  - 대체/기본값\nval actualFoundItem = foundItem ?: \"empty\"\n//  - 강제 언래핑\nval actualFoundItem2 = foundItem!!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 제어 흐름\n\nif 문은 Kotlin과 거의 동일한데, Swift에서는 괄호를 생략할 수 있다는 작은 차이가 있습니다.\n\n```js\n// Swift\nif foundItem != nil {\n  // 무언가를 수행\n}\n\n// Kotlin\nif (foundItem != null) {\n  // 무언가를 수행\n}\n```\n\n두 언어 모두 else if/else 분기에 대해 동일한 구문을 사용하며, 두 언어 모두 표현식으로 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 스위프트\nlet description = if delta \u003c= 10 {\n  \"low\"\n} else if delta \u003e= 50 {\n  \"high\"\n} else {\n  \"medium\"\n}\n\n// 코틀린\nval description = if (delta \u003c= 10) {\n    \"low\"\n} else if (delta \u003e= 50) {\n    \"high\"\n} else {\n    \"medium\"\n}\n```\n\n## Functions\n\nSwift에서 함수는 func 키워드로 선언되며, 함수 이름, 입력 매개변수 및 반환 유형이 이어집니다.\n\n```js\nfunc addTwoNumbers(a: Int, b: Int) -\u003e Int {\n    return a + b\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코틀린에서는 fun 키워드와 :을 사용하여 반환 유형을 정의합니다. -` 대신에 Markdown 형식으로 표를 변경해주세요.\n\n```kotlin\nfun addTwoNumbers(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n# 2. 구조체 및 클래스\n\nSwift는 데이터 모델링 관점에서 비슷한 구조체와 클래스를 지원합니다. 둘 다 속성과 함수를 정의할 수 있지만, 클래스는 참조에 의해 전달되고 구조체는 값에 의해 전달됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 구조체를 사용하는 것이 권장됩니다. 상속, Objective-C 호환성 등 추가 기능이 필요할 때는 클래스를 사용하세요.\n\n```js\nstruct VehicleStructure {\n    var maxSpeed = 0\n\n    func printInfo() {\n        print(\"최대 속도 \\(maxSpeed)\")\n    }\n}\n\nclass VehicleClass {\n    var maxSpeed = 0\n\n    func printInfo() {\n        print(\"최대 속도 \\(maxSpeed)\")\n    }\n}\n```\n\n인스턴스를 생성하려면 구조체나 클래스 이름 뒤에 빈 괄호를 사용합니다.\n\n구조체는 기본적으로 변경 불가능하므로 속성의 값 변경이 필요한 경우 let 대신 var로 선언해야 합니다. 멤버 속성의 값을 설정하기 위해 자동으로 생성된 이니셜라이저를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 변경 가능한 구조체 인스턴스 생성\nvar car = VehicleStructure()\ncar.maxSpeed = 250\ncar.printInfo()\n\n// 변경 불가능한 구조체 인스턴스 생성\nlet carSimple = VehicleStructure(maxSpeed: 200)\ncarSimple.printInfo()\n\n// 클래스 인스턴스 생성\nlet bike = VehicleClass()\nbike.maxSpeed = 50\nbike.printInfo()\n```\n\n## Kotlin\n\nKotlin에서의 주요 구성 요소는 클래스입니다. 그 선언과 사용법은 Swift와 거의 동일합니다.\n\n```js\nclass Vehicle {\n    var maxSpeed = 0\n\n    fun printInfo(){\n        println(\"최대 속도는 $maxSpeed입니다.\")\n    }\n}\n\n// 클래스 인스턴스 생성\nval vehicle = Vehicle()\nvehicle.maxSpeed = 250\nvehicle.printInfo()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKotlin은 클래스 생성 시 모든 클래스 속성에 값을 제공해야하는 클래스 생성자도 지원합니다.\n\n```kotlin\nclass Vehicle(var maxSpeed: Int) {\n\n    fun printInfo(){\n        println(\"최대 속도는 $maxSpeed 입니다.\")\n    }\n}\n\nval vehicle = Vehicle(250)\n```\n\nKotlin은 추상 클래스, 데이터 클래스, 인터페이스 및 실드 클래스 및 인터페이스와 같은 다른 관련 구조를 지원합니다. 더 많은 내용은 https://kotlinlang.org/docs/classes.html에서 확인할 수 있습니다.\n\n# 3. Optional Binding\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## if let 사용법\n\nSwift 코드베이스에서 자주 볼 수 있는 패턴 중 하나는 다음과 같습니다:\n\n```js\nlet fetchedUserId: String? = \"Optional id of the fetched user\"\nif let userId = fetchedUserId {\n    // userId를 선택적인(non-optional) 상수로 사용할 수 있습니다.\n    print(userId)\n} else {\n    // fetchedUserId가 nil/null인 경우\n    throw Error(\"Missing user id\")\n}\n\n// fetchedUserId와 userId를 if 문 바깥에서 사용할 수 있습니다.\n// 그러나 둘 다 여전히 옵셔널이므로 unwrapping이 필요합니다.\n```\n\n이를 선택적 바인딩(optional binding)이라고 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 선택적으로 검색된 fetchedUserId 변수가 nil이 아닌 값으로 존재하는지 확인합니다.\n- true이면 새로운 선택 불가능한 상수인 userId에 값을 할당합니다.\n- 새로운 상수 userId는 코드 블록 내에서 참조할 수 있습니다.\n- fetchedUserId가 nil이라면 else 블록을 실행합니다.\n\n기존 변수 이름을 사용하여 더욱 간단하게 코드를 작성할 수 있습니다:\n\n```js\nlet fetchedUserId: String? = \"검색된 사용자의 선택 사항 ID\"\nif let fetchedUserId {\n    // fetchedUserId를 선택 불가능한 상수로 사용할 수 있습니다.\n    print(fetchedUserId)\n}\n```\n\n두 경우 모두 fetchedUserId와 userId 상수를 if 문 바깥에서 사용할 수 있지만, 두 상수 모두 여전히 선택적으로 간주되기 때문에 추가로 언래핑이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코틀린\n코틀린에는 이에 해당하는 특수한 패턴이 없습니다. 하나의 옵션은 if/else 문을 사용하는 것입니다. 그러나 이는 로컬 변수에 대해서만 작동하며 전역 변수에는 작동하지 않습니다. 전역 변수를 지원하려면 먼저 값을 새로운 로컬 변수/상수에 할당해야 합니다.\n\n```js\n// 글로벌 클래스 속성\nvar fetchedUserId: String? = \"피치된 사용자의 선택 가능한 ID\"\n\nval userId = fetchedUserId\nif (userId != null) {\n  // userId는 선택 사항 없이 사용할 수 있습니다\n} else {\n  throw Exception(\"사용자 ID가 누락되었습니다\")\n}\n\n// userId는 선택 사항 없이 어디서든 사용할 수 있습니다\n```\n\n위의 경우에는 if 문 이후에도 userId 상수를 선택 사항 없이 참조할 수 있으며, 이는 옵셔널 바인딩 패턴을 사용한 스위프트에서는 지원되지 않습니다.\n\n대안적인 해결책은 `.let`과 같은 스코프 함수를 사용하는 것입니다. 함수 내부의 코드는 fetchedUserId가 null이 아닌 경우에만 실행됩니다. 이 코드 블록 이후에 fetchedUserId에 대한 참조는 여전히 변수가 선택 사항으로 간주되므로 널 안전성이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```kotlin\nfetchedUserId?.let { userId -\u003e\n  // userId가 옵셔널이 아닌 것으로 사용할 수 있습니다\n} ?: throw Exception(\"사용자 ID가 누락되었습니다\")\n```\n\n## 보호자\n\n또 다른 일반적인 패턴은 가드문입니다. 이는 if let 패턴과 유사합니다. 주로 함수 내에서 조기에 종료할 때 사용됩니다. 다른 점은 else 블록이 필수적이라는 것입니다.\n\n```swift\nfunc checkUsernameValid(username: String?) -\u003e Bool {\n    guard let username else {\n        // username이 nil이므로 평가할 수 없습니다\n        return false\n    }\n    // username을 옵셔널이 아닌 것으로 사용할 수 있습니다\n    return username.count \u003e 3\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서 함수는 선택적으로 변수 username을 받습니다. 그런 다음 guard문을 사용하여 username이 값이 있는지 확인합니다. 값이 없는 경우 함수를 종료합니다. 값이 있는 경우 나머지 함수에서는 username을 선택사항이 아닌 것처럼 사용할 수 있습니다.\n\nKotlin\nKotlin에서는 몇 가지 다른 방법으로 이를 작성할 수 있습니다. 두 가지 제안을 보여드리겠습니다:\n\n```js\nfun checkUsernameValid(username: String?): Boolean {\n    if (username.isNullOrEmpty()){\n        return false\n    }\n    return username.length \u003e 3\n}\n\n// 또는\n\nfun checkUsernameValid(username: String?): Boolean {\n    val actualUsername = username ?: return false\n    return actualUsername.length \u003e 3\n}\n```\n\n# 4. Enums\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwift에서는 enum 키워드를 사용하여 열거형을 정의합니다. 값은 case 키워드를 사용하고 그 뒤에 열거형 케이스의 이름을 작성합니다. 열거형 케이스의 이름은 소문자로 작성하는 것이 권장되며 단수형으로 작성하는 것이 좋습니다. 각 케이스를 새로운 줄에 작성해야 합니다. 여러 케이스를 한 줄에 작성할 때는 쉼표로 구분합니다.\n\n```js\nenum Direction {\n    case left\n    case up\n    case right\n    case down\n}\n\n// 또는\n\nenum Direction {\n    case left, up, right, down\n}\n```\n\nenum 케이스를 사용하려면 유형(Direction)과 사용하려는 케이스를 참조합니다. 나중에 유형을 생략하고 더 짧은 점 구문을 사용하여 케이스를 직접 참조할 수 있습니다.\n\n```js\nvar selectedDirection = Direction.up\nselectedDirection = .right\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n열거형 값 확인을 위해 switch 문을 사용할 수 있습니다. Xcode는 switch 문의 모든 분기를 자동으로 작성합니다. 열거형에 대한 switch 문이 전체적이어야 하기 때문입니다.\n\n```js\nswitch(selectedDirection){\ncase .left:\n    goLeft()\ncase .up:\n    goForward()\ncase .right:\n    goRight()\ncase .down:\n    goBackward()\n}\n```\n\nSwift 열거형은 연관 값도 지원합니다. 즉, 각 열거형 케이스마다 다른 수의 값 유형을 가질 수 있습니다. 이는 Kotlin의 sealed class와 유사한 강력한 도메인 모델링 도구 역할을 합니다.\n\n더 알아보기: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 코틀린\n\n코틀린에서는 enum 클래스 키워드를 사용하여 Enum을 정의합니다. 값은 쉼표로 구분하여 정의합니다. Enum 값 이름은 일반적으로 대문자로 작성하는 것이 관례이지만, 프로젝트의 스타일에 따라 다를 수 있습니다.\n\n```js\nenum class Direction {\n    LEFT, UP, RIGHT, DOWN\n}\n```\n\nEnum을 사용할 때는 클래스 이름과 사용하려는 값으로 참조합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvar selectedDirection = Direction.UP;\n```\n\n우리는 값 확인을 위해 when 문을 사용할 수 있습니다. 가능한 모든 열거형 값을 포함해야합니다.\n\n```js\nwhen(selectedDirection){\n    Direction.LEFT -\u003e goLeft()\n    Direction.UP -\u003e goForward()\n    Direction.RIGHT -\u003e goRight()\n    Direction.DOWN -\u003e goBackward()\n}\n```\n\nKotlin 열거형 클래스는 각 열거형 값이 값을 제공해야하는 추가 속성을 정의하는 것을 지원합니다. 그러나 Swift의 관련 값과 달리 속성은 클래스 수준에 있으며 값 레벨이 아니므로 각 값에 대해 동일한 형식이어야 합니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Kotlin 공식 문서 링크입니다: https://kotlinlang.org/docs/enum-classes.html\n\n# 5. 사전 / 맵\n\nSwift의 딕셔너리와 Kotlin의 맵 사이의 구문은 매우 다르지만 비슷한 기본 개념을 사용합니다.\n\n## Kotlin\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n딕셔너리는 키와 값을 동일한 유형으로 연결해주는 Swift의 데이터 구조입니다. 키-값 쌍은 순서가 없이 저장됩니다. 각 키는 연결된 값을 액세스하기 위한 기준값을 나타냅니다.\n\n딕셔너리를 선언하려면 키-값 쌍을 [Key: Value] 형식으로 대괄호 안에 쉼표로 구분하여 정의합니다. 최소 하나의 키-값 쌍을 정의하면 형식 선언을 생략할 수 있어 컴파일러가 유형을 결정할 수 있습니다.\n\n```js\nvar httpErrorCodes: [Int: String] = [404: \"Not found\", 401: \"Unauthorized\"]\n```\n\n키를 사용하여 딕셔너리에서 값을 읽기 위해 서브스크립트 구문(dictionary[key])을 사용할 수 있습니다. 딕셔너리에 키가 없으면 nil을 반환합니다. ?? 연산자를 사용하여 기본값을 제공할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunc getHttpErrorCodeMessage(code: Int) -\u003e String {\n    let errorCodeMessage = httpErrorCodes[code] ?? \"Unknown\"\n    return \"Http error code \\(errorCodeMessage)\"\n}\n```\n\n딕셔너리에 새로운 값을 쓰려면 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍을 컬렉션에 추가합니다. 키가 이미 존재하면 값을 업데이트합니다.\n\n```js\n// 새로운 키:값 쌍 추가\nhttpErrorCodes[500] = \"Internal Server Error\";\n\n// 기존 키의 값 업데이트\nhttpErrorCodes[401] = \"Requires authentication\";\n```\n\n가변 또는 불변(읽기 전용) 딕셔너리를 사용하는지는 할당에 달려있습니다. let을 사용하면 선언한 후에만 읽을 수 있는 딕셔너리를 정의합니다. 쓰기를 지원하려면 var로 선언해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자세히 읽기: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Dictionaries\n\n## Kotlin\n\n맵은 고유한 키와 값의 쌍을 보유하고 각 키에 해당하는 값을 효율적으로 가져오는 컬렉션입니다.\n\nKotlin에서 불변(읽기 전용) 맵을 선언하려면 Map`KeyType, ValueType` 유형을 사용하고 mapOf(varargs pairs: Pair`KeyType, ValueType`) 표준 라이브러리 함수를 사용하여 초기화합니다. 적어도 하나의 키-값 쌍을 제공하면 명시적인 변수 유형 선언을 생략할 수 있습니다. 컴파일러가 유형을 결정할 수 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n값을 선언할 때 Pair(key, value) 클래스를 직접 사용하거나 객체를 만들어주는 to 인픽스 함수를 사용할 수 있습니다.\n\n```kotlin\nval httpErrorCodes: Map\u003cInt, String\u003e = mapOf(\n    404 to \"찾을 수 없음\",\n    Pair(401, \"권한이 없음\"),\n)\n```\n\n키를 사용하여 맵에서 값을 읽을 때 대괄호 표기법(map[key])을 사용할 수 있습니다. 키가 맵에 존재하지 않으면 null이 반환됩니다. ?: 연산자를 사용하여 기본값을 제공할 수 있습니다.\n\n```kotlin\nfun getHttpErrorCodeMessage(code: Int): String {\n    val errorCodeMessage = httpErrorCodes[code] ?: \"알 수 없음\"\n    return \"Http 오류 코드: $errorCodeMessage\"\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n맵에 새로운 값을 작성하려면 MutableMap KeyType, ValueType 형식과 mutableMapOf() 팩토리 함수를 사용하여 가변 맵을 선언해야 합니다. 그런 다음 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍이 컬렉션에 추가됩니다. 키가 이미 존재하면 해당 값을 업데이트합니다.\n\n```js\n// 새 키:값 쌍 추가\nhttpErrorCodes[500] = \"내부 서버 오류\";\n\n// 기존 키에 대한 값 업데이트\nhttpErrorCodes[401] = \"인증이 필요함\";\n```\n\n더 읽어보기: https://www.baeldung.com/kotlin/maps\n\n# 6. 확장\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n확장(extension)은 기존 클래스나 구조체에 새로운 기능을 추가하는 방법입니다. 때로는 코드에 액세스할 수 없는 것들에 대해서도 확장을 적용할 수 있습니다.\n\nSwift에서는 extension 키워드를 사용하여 확장을 정의할 수 있습니다. 확장은 다른 클래스나 구조체 외부의 최상위 레벨에서 선언되어야 합니다.\n\n```js\nextension String {\n    func doubled() -\u003e String {\n        return self + self\n    }\n}\n```\n\n위 예제에서는 String 타입에 doubled() 확장 함수를 정의했습니다. 이제 이 함수를 문자열의 인스턴스에서 호출할 수 있으며 마치 원래 정의에 포함된 것처럼 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlet originalStr = \"Swift\";\nlet doubledStr = originalStr.doubled();\nprint(doubledStr); // prints \"SwiftSwift\"\n```\n\n## Kotlin\n\nKotlin은 동일한 방식으로 작동하는 확장 함수를 사용하며 기존 클래스에 새 기능을 추가할 수 있습니다. 우리는 확장하려는 클래스 이름과 함께 점과 함수 이름이 이어지는 최상위 함수로 정의합니다.\n\n```js\nfun String.doubled(): String {\n    return this + this\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이 함수를 사용하여 원래 정의의 일부인 문자열 인스턴스에서 호출할 수 있습니다.\n\n```js\nval originalStr = \"Kotlin\"\nval doubledStr = originalStr.doubled()\nprintln(doubledStr) // \"KotlinKotlin\" 출력\n```\n\n# 7. 프로토콜\n\nSwift에서 프로토콜은 클래스, 구조체 또는 열거형이 해당 요구 사항의 실제 구현을 제공함으로써 채택할 수 있는 속성, 메서드 및 기타 요구 사항의 집합입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로토콜을 정의할 때는 프로토콜 키워드 뒤에 프로토콜 이름을 붙이면 됩니다. 이는 구조체나 클래스 선언과 유사합니다. 프로토콜 내부에서는 get할 수 있는(' get ') 또는 get과 set이 모두 가능한(' get set ') 속성을 정의할 수 있습니다.\n\n```js\nprotocol RequestError {\n    var errorCode: Int { get }\n    var isRecoverable: Bool { get set }\n}\n\nprotocol PrintableError {\n    func buildErrorMessage() -\u003e String\n}\n```\n\n위 예시에서는 RequestError라는 프로토콜을 정의했는데, 이 프로토콜에는 errorCode라는 get할 수 있는 속성과 isRecoverable이라는 set이 가능한 속성이 포함되어 있습니다. 또한, adopter가 구현해야 하는 buildErrorMessage() 함수를 포함하는 PrintableError라는 프로토콜도 정의했습니다.\n\n프로토콜을 채택하기 위해서는 클래스나 구조체를 정의하고 이름 뒤에 : ProtocolName을 추가해야 합니다. 여러 프로토콜을 선언하려면 쉼표를 사용하면 됩니다. 그런 다음 클래스나 구조체의 본문에서 프로토콜로부터 요구되는 내용을 정의해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nclass ServerHttpError: RequestError, PrintableError {\n    var errorCode: Int = 500\n    var isRecoverable: Bool = false\n\n    func buildErrorMessage() -\u003e String {\n        return \"Server side http error with error code \\(errorCode)\"\n    }\n}\n\nstruct ConnectionError: RequestError, PrintableError {\n    var errorCode: Int\n    var isRecoverable: Bool\n\n    func buildErrorMessage() -\u003e String {\n        return \"Local connection error\"\n    }\n}\n```\n\n우리는 RequestError와 PrintableError 프로토콜을 채택하는 ServerHttpError 클래스를 정의했고, 두 속성의 기본값과 함수의 구현을 정의했습니다. 또한 두 속성을 선언하고 함수의 구현을 제공하는 ConnectionError 구조체를 가지고 있습니다.\n\n이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고 이들을 RequestError 또는 PrintableError 유형으로 전달할 수 있습니다. RequestError 유형을 수락하는 onRequestError() 함수에서 error가 PrintableError 프로토콜을 준수하는지 확인하여 오류 메시지를 구성합니다.\n\n```js\nfunc onRequestError(error: RequestError) {\n    if let printableError = error as? PrintableError {\n        print(printableError.buildErrorMessage())\n    }\n    print(\"Is recoverable: \\(error.isRecoverable)\")\n}\n\nlet firstError = ServerHttpError()\nfirstError.errorCode = 503\nfirstError.isRecoverable = false\n\nlet secondError = ConnectionError(errorCode: 404, isRecoverable: true)\n\n// \"Server side http error with error code 503. Is recoverable: false\"\nonRequestError(error: firstError)\n// \"Local connection error. Is recoverable: true\"\nonRequestError(error: secondError)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 프로토콜을 사용하는 간단한 예시입니다. Swift의 프로토콜은 상속, 합성, 연관 타입, 제네릭 등과 같이 더 고급적인 사용 사례를 지원합니다. 더 많은 내용은 https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols에서 확인할 수 있어요.\n\n## Kotlin\n\n위의 예시는 인터페이스, 추상 클래스, sealed 클래스 등을 사용하여 Kotlin으로 여러 방법으로 작성할 수 있습니다. 그러나 Swift의 프로토콜을 가장 가깝게 표현하는 것은 아마도 인터페이스일 것입니다. 이는 속성과 함수를 정의하며, 상속, 구성, 그리고 제네릭을 지원합니다.\n\n인터페이스를 정의할 때는 interface 키워드를 사용하고 이름을 이어서 작성합니다. 본문에서는 속성과 함수를 정의합니다. 읽기 전용 속성은 val 키워드를 사용하여 정의하고, 읽기/쓰기 속성은 var 키워드를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 인터페이스를 구현하도록 클래스에 지정하는 방법은, 클래스 이름 뒤에 InterfaceName을 사용합니다. 여러 인터페이스를 구현하려면 쉼표를 사용합니다. 그런 다음 모든 속성과 함수를 override 키워드와 함께 정의해야 합니다.\n\n```js\ninterface RequestError {\n    val errorCode: Int\n    var isRecoverable: Boolean\n}\n\ninterface PrintableError {\n    fun buildErrorMessage(): String\n}\n\nclass ServerHttpError(\n    override val errorCode: Int,\n    override var isRecoverable: Boolean\n) : RequestError, PrintableError {\n    override fun buildErrorMessage(): String {\n        return \"Server side http error with error code $errorCode\"\n    }\n}\n\nclass ConnectionError : RequestError, PrintableError {\n    override val errorCode: Int\n        get() = 404\n    override var isRecoverable: Boolean = true\n\n    override fun buildErrorMessage(): String {\n        return \"Local connection error\"\n    }\n}\n```\n\n이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고, 함수에 RequestError 유형으로 전달할 수 있습니다.\n\n```js\nfun onRequestError(error: RequestError) {\n    if (error is PrintableError) {\n        println(error.buildErrorMessage())\n    }\n    println(\"$errorMessage. Is recoverable: ${error.isRecoverable}\")\n}\n\nval firstError = ServerHttpError(errorCode = 503, isRecoverable = false)\nval secondError = ConnectionError()\n// \"Server side http error with error code 503. Is recoverable: false\"\nonRequestError(firstError)\n// \"Local connection error. Is recoverable: true\"\nonRequestError(secondError)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nRead more at https://kotlinlang.org/docs/interfaces.html\n\n# 결론\n\n일반적인 Swift 패턴을 이해하고 Kotlin에서 어떻게 번역되는지 알면 코드가 하는 일을 더 잘 이해할 수 있습니다. 이웃 플랫폼에서 어떤 기능이 구현되었는지 보거나 코드 검토를 수행하거나 기술 사양/제안서를 검토하거나 작업을 Kotlin Multiplatform으로 수행하는 여러 방법이 있습니다.\n\nSwift 언어의 기본적인 내용과 Kotlin과 비교하는 방법을 살펴보았습니다. 또한, 선택적 바인딩, 딕셔너리, 익스텐션, 구조 및 프로토콜과 같은 전형적인 iOS 프로젝트에서 발견할 수 있는 일반적인 패턴에 대해서도 다루었습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문이 도움이 되었다면 댓글로 알려주세요! Swift 코드를 읽거나 검토하거나 작성하는 경험에 대해 공유하는 것을 장려합니다.\n\n참고 자료:\n\n- https://kotlinlang.org/docs/home.html\n- https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics\n\nAndrej Rolih 님의 검토와 피드백에 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png"},"coverImage":"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png","tag":["Tech"],"readingTime":17}],"page":"11","totalPageCount":61,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"11"},"buildId":"0asLlD6on3tm8cIfzBaxd","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>