<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/39" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/39" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 FocusState를 마스터하기 고급 기능을 활용한 동적 폼 관리" href="/post/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 FocusState를 마스터하기 고급 기능을 활용한 동적 폼 관리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 FocusState를 마스터하기 고급 기능을 활용한 동적 폼 관리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI에서 FocusState를 마스터하기 고급 기능을 활용한 동적 폼 관리</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="MVVM 아키텍처로 SwiftUI 앱 구축하기 실전 안내" href="/post/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="MVVM 아키텍처로 SwiftUI 앱 구축하기 실전 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="MVVM 아키텍처로 SwiftUI 앱 구축하기 실전 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">MVVM 아키텍처로 SwiftUI 앱 구축하기 실전 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Linker command failed with exit code 1 오류 해결하기" href="/post/2024-06-19-FixingLinkercommandfailedwithexitcode1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Linker command failed with exit code 1 오류 해결하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Linker command failed with exit code 1 오류 해결하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Linker command failed with exit code 1 오류 해결하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="iOS에서 Swift를 사용하여 견고한 네트워크 계층 구축하기" href="/post/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="iOS에서 Swift를 사용하여 견고한 네트워크 계층 구축하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="iOS에서 Swift를 사용하여 견고한 네트워크 계층 구축하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">iOS에서 Swift를 사용하여 견고한 네트워크 계층 구축하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift로 강력한 네트워크 레이어 만들기 파트 2" href="/post/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift로 강력한 네트워크 레이어 만들기 파트 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift로 강력한 네트워크 레이어 만들기 파트 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift로 강력한 네트워크 레이어 만들기 파트 2</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬에서 typingTYPE_CHECKING이 30초 안에 설명하기" href="/post/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬에서 typingTYPE_CHECKING이 30초 안에 설명하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬에서 typingTYPE_CHECKING이 30초 안에 설명하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">파이썬에서 typingTYPE_CHECKING이 30초 안에 설명하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="이 12개의 YouTube 채널로 12가지를 배워보세요" href="/post/2024-06-19-Learn12ThingswithThese12YouTubeChannels"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="이 12개의 YouTube 채널로 12가지를 배워보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="이 12개의 YouTube 채널로 12가지를 배워보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">이 12개의 YouTube 채널로 12가지를 배워보세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="잘 검토할 수 있는 풀 리퀘스트를 만드는 방법" href="/post/2024-06-19-HowICreateEasy-to-ReviewPullRequests"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="잘 검토할 수 있는 풀 리퀘스트를 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="잘 검토할 수 있는 풀 리퀘스트를 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">잘 검토할 수 있는 풀 리퀘스트를 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="현실 대면이 가상보다 더 나은 이유를 깨달은 방법" href="/post/2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="현실 대면이 가상보다 더 나은 이유를 깨달은 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="현실 대면이 가상보다 더 나은 이유를 깨달은 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">현실 대면이 가상보다 더 나은 이유를 깨달은 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 과학이 죽었을까요 반박하기" href="/post/2024-06-19-IsDataSciencedeadTheRebuke"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 과학이 죽었을까요 반박하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-IsDataSciencedeadTheRebuke_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 과학이 죽었을까요 반박하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">데이터 과학이 죽었을까요 반박하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link posts_-active__YVJEi" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"SwiftUI에서 FocusState를 마스터하기 고급 기능을 활용한 동적 폼 관리","description":"","date":"2024-06-19 10:59","slug":"2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures","content":"\n\u003cimg src=\"/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png\" /\u003e\n\n사용자의 포커스를 효과적으로 관리하는 것은 모든 애플리케이션에서 매끈하고 직관적인 사용자 경험을 만들기 위해 중요합니다. SwiftUI는 FocusState라는 강력한 기능을 제공하는데, 이를 사용하면 개발자가 폼 입력 및 기타 대화형 요소의 포커스 상태를 동적으로 관리할 수 있습니다. 이 블로그 포스트에서는 FocusState를 사용하여 사용자 상호작용에 따라 포커스를 조정하는 사용자 지정 입력 폼을 만드는 방법을 살펴보겠습니다. 또한 조건부 포커스, 키보드 관리 및 사용자 정의 포커스 처리와 같은 고급 기능을 포함하고 있습니다.\n\n## FocusState 이해하기\n\nFocusState는 SwiftUI에서 도입된 프로퍼티 래퍼로, 텍스트 필드와 같은 뷰의 포커스 상태를 관리하는 데 도움을 주는 역할을 합니다. FocusState를 사용하면 어떤 입력 필드에 포커스를 맞출지를 프로그래밍적으로 제어할 수 있어 사용자 경험을 더 부드럽게 만들 수 있습니다, 특히 폼에서의 경우에 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 커스텀 입력 폼 만들기\n\n사용자 입력에 따라 동적으로 포커스가 변경되는 여러 텍스트 필드가 있는 포괄적인 양식을 만들어 봅시다. 조건부 포커스, 키보드 해제 및 사용자 정의 포커스 로직과 같은 고급 기능을 통합할 것입니다.\n\n## 구현 단계별\n\n1. 양식 필드와 포커스 상태 정의하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 다양한 폼 필드를 나타내는 열거형을 정의합니다. 그런 다음, 폼 상태와 포커스 상태를 나타내는 구조체를 생성합니다.\n\n```js\nimport SwiftUI\n\nenum FormField: Hashable {\n    case firstName\n    case lastName\n    case email\n    case password\n    case confirmPassword\n}\n\nstruct FormState {\n    var firstName: String = \"\"\n    var lastName: String = \"\"\n    var email: String = \"\"\n    var password: String = \"\"\n    var confirmPassword: String = \"\"\n}\n```\n\n2. 폼 뷰 생성하기:\n\n이제, 폼 필드를 포함하는 뷰를 생성해보겠습니다. @FocusState 프로퍼티 래퍼를 사용하여 포커스 상태를 관리하고 더 많은 고급 기능을 추가할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct CustomFormView: View {\n    @State private var formState = FormState()\n    @FocusState private var focusedField: FormField?\n\n    var body: some View {\n        VStack {\n            Form {\n                TextField(\"이름\", text: $formState.firstName)\n                    .focused($focusedField, equals: .firstName)\n                    .onSubmit {\n                        focusedField = .lastName\n                    }\n                    .submitLabel(.next)\n\n                TextField(\"성\", text: $formState.lastName)\n                    .focused($focusedField, equals: .lastName)\n                    .onSubmit {\n                        focusedField = .email\n                    }\n                    .submitLabel(.next)\n\n                TextField(\"이메일\", text: $formState.email)\n                    .focused($focusedField, equals: .email)\n                    .keyboardType(.emailAddress)\n                    .onSubmit {\n                        focusedField = .password\n                    }\n                    .submitLabel(.next)\n\n                SecureField(\"비밀번호\", text: $formState.password)\n                    .focused($focusedField, equals: .password)\n                    .onSubmit {\n                        focusedField = .confirmPassword\n                    }\n                    .submitLabel(.next)\n\n                SecureField(\"비밀번호 확인\", text: $formState.confirmPassword)\n                    .focused($focusedField, equals: .confirmPassword)\n                    .onSubmit {\n                        validateForm()\n                    }\n                    .submitLabel(.done)\n            }\n            .padding()\n\n            Button(\"제출\") {\n                validateForm()\n            }\n            .padding()\n            .buttonStyle(.borderedProminent)\n        }\n        .onTapGesture {\n            // 필드 외부를 탭하면 키보드 닫기\n            focusedField = nil\n        }\n        .toolbar {\n            ToolbarItemGroup(placement: .keyboard) {\n                Spacer()\n                Button(\"완료\") {\n                    focusedField = nil\n                }\n            }\n        }\n    }\n\n    private func validateForm() {\n        // 여기서 폼 유효성 검사 및 제출 로직 수행\n        guard !formState.firstName.isEmpty,\n              !formState.lastName.isEmpty,\n              isValidEmail(formState.email),\n              formState.password == formState.confirmPassword else {\n            // 오류 메시지 표시 또는 유효성 검사 실패 처리\n            return\n        }\n\n        // 폼 제출 처리\n        print(\"폼이 제출되었습니다: \\(formState)\")\n        focusedField = nil\n    }\n\n    private func isValidEmail(_ email: String) -\u003e Bool {\n        // 기본적인 이메일 유효성 검사 로직\n        let emailRegEx = \"[A-Z0-9a-z._%+-]+@[A-Z0-9a-z.-]+\\\\.[A-Za-z]{2,64}\"\n        let emailPred = NSPredicate(format: \"SELF MATCHES %@\", emailRegEx)\n        return emailPred.evaluate(with: email)\n    }\n}\n```\n\n3. Form View 미리보기:\n\n마지막으로 SwiftUI 미리보기에서 Form View를 미리볼 수 있습니다.\n\n```swift\n#Preview {\n  CustomFormView()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Explanation\n\n- **포커스 관리:** 각 TextField 및 SecureField는 `.focused($focusedField, equals: .formField)` 수정자를 사용하여 특정 포커스 상태와 연결됩니다. 이를 통해 사용자가 하나의 필드를 제출할 때 다음 필드로 포커스가 전환됩니다.\n\n- **동적 포커스 조정:** `onSubmit` 수정자는 반환 키 작업을 처리하는 데 사용됩니다. 사용자가 현재 필드를 제출하면 포커스가 다음 필드로 변경됩니다.\n\n- **사용자 지정 키보드 툴바:** 키보드에 사용자 정의 툴바가 추가되어 \"완료\" 버튼을 탭함으로써 키보드를 해제할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n• 양식 제출 및 유효성 검사: validateForm 함수는 양식 제출과 유효성 검사를 처리합니다. 비어있는 필드, 유효한 이메일 형식 및 일치하는 비밀번호를 확인한 후에야 양식 제출이 진행됩니다.\n\n• 키보드 해제: onTapGesture 수정자는 사용자가 입력 필드 외부를 탭할 때 키보드를 해제하는 데 사용됩니다.\n\n## 결론\n\nSwiftUI에서 FocusState를 사용하면 입력 필드의 포커스 상태를 관리하여 동적이고 사용자 친화적인 양식을 만들 수 있습니다. 조건부 포커스, 키보드 관리 및 사용자 정의 유효성 검사와 같은 고급 기능을 통합함으로써 SwiftUI 애플리케이션에서 사용자 경험을 향상시키고 더 견고한 양식을 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원하는 경우 원시 모바일 개발에 대해 더 알아보려면 여기에서 다른 기사들을 확인해보세요: [https://medium.com/@wesleymatlock](https://medium.com/@wesleymatlock)\n\n코딩을 즐기세요! 🚀\n","ogImage":{"url":"/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png","tag":["Tech"],"readingTime":7},{"title":"MVVM 아키텍처로 SwiftUI 앱 구축하기 실전 안내","description":"","date":"2024-06-19 10:58","slug":"2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide","content":"\n이 튜토리얼에서는 MVVM(Model-View-ViewModel) 아키텍처를 사용하여 간단한 SwiftUI 애플리케이션을 만드는 방법을 안내합니다. 데이터 처리 및 네트워킹을 위해 Combine 프레임워크를 활용할 것입니다. 이 예제에서는 REST API에서 데이터를 가져오고 게시하는 방법을 보여줍니다.\n\n# 개요\n\n다음과 같은 간단한 앱을 만들 것입니다:\n\n- 서버에서 게시물 목록을 가져오기.\n- SwiftUI 뷰에서 게시물을 표시하기.\n- 새 게시물을 생성하기.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 프로젝트 설정\n\n먼저 Xcode에서 새로운 SwiftUI 프로젝트를 생성하세요. 그런 다음, 더 나은 구성을 위해 다음과 같은 폴더를 설정합니다:\n\n- Models\n- ViewModels\n- Views\n- Services\n\n# Models\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"Post\" 모델을 시작해봅시다. 이 모델은 Identifiable과 Codable을 준수합니다.\n\n```swift\n// Models/Post.swift\n\nimport Foundation\n\nstruct Post: Identifiable, Codable {\n    let id: Int\n    let title: String\n    let body: String\n}\n```\n\n# 서비스\n\n네트워크 요청을 처리하기 위한 서비스 레이어가 필요합니다. ApiService와 ApiEndpoints를 만들 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n// Services/ApiEndpoints.swift\n\nimport Foundation\n\nclass ApiEndpoints {\nstatic let baseURL = \"https://jsonplaceholder.typicode.com\"\n\n    static var posts: String { return \"\\(baseURL)/posts\" }\n    static func post(id: Int) -\u003e String { return \"\\(baseURL)/posts/\\(id)\" }\n\n}\n\n// Services/ApiService.swift\n\nimport Foundation\nimport Combine\n\nclass ApiService {\nstatic let shared = ApiService()\nprivate init() {}\n\n    private func makeRequest\u003cT: Decodable\u003e(url: String, method: String, body: Data? = nil) -\u003e AnyPublisher\u003cT, Error\u003e {\n        guard let url = URL(string: url) else {\n            fatalError(\"Invalid URL\")\n        }\n\n        var request = URLRequest(url: url)\n        request.httpMethod = method\n        if let body = body {\n            request.httpBody = body\n            request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        }\n\n        return URLSession.shared.dataTaskPublisher(for: request)\n            .tryMap { output in\n                guard let response = output.response as? HTTPURLResponse,\n                      response.statusCode \u003e= 200 \u0026\u0026 response.statusCode \u003c 300 else {\n                    throw URLError(.badServerResponse)\n                }\n                return output.data\n            }\n            .decode(type: T.self, decoder: JSONDecoder())\n            .eraseToAnyPublisher()\n    }\n\n    func get\u003cT: Decodable\u003e(url: String) -\u003e AnyPublisher\u003cT, Error\u003e {\n        return makeRequest(url: url, method: \"GET\")\n    }\n\n    func post\u003cT: Decodable, U: Encodable\u003e(url: String, body: U) -\u003e AnyPublisher\u003cT, Error\u003e {\n        guard let bodyData = try? JSONEncoder().encode(body) else {\n            fatalError(\"Invalid body data\")\n        }\n        return makeRequest(url: url, method: \"POST\", body: bodyData)\n    }\n\n    func delete\u003cT: Decodable\u003e(url: String) -\u003e AnyPublisher\u003cT, Error\u003e {\n        return makeRequest(url: url, method: \"DELETE\")\n    }\n\n}\n\n# ViewModels\n\n이제, PostViewModel을 만들어서 게시물을 가져오고 만들어봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n// ViewModels/PostViewModel.swift\n\nimport Foundation\nimport Combine\n\nclass PostViewModel: ObservableObject {\n    @Published var posts: [Post] = []\n    @Published var isLoading = false\n    @Published var errorMessage: String? = nil\n\n    private var cancellables = Set\u003cAnyCancellable\u003e()\n    private let apiService = ApiService.shared\n\n    func fetchPosts() {\n        self.isLoading = true\n        self.errorMessage = nil\n\n        apiService.get(url: ApiEndpoints.posts)\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { [weak self] completion in\n                self?.isLoading = false\n                switch completion {\n                case .failure(let error):\n                    self?.errorMessage = error.localizedDescription\n                case .finished:\n                    break\n                }\n            }, receiveValue: { [weak self] posts in\n                self?.posts = posts\n            })\n            .store(in: \u0026cancellables)\n    }\n\n    func createPost() {\n        let newPost = Post(id: 101, title: \"New Post\", body: \"This is a new post.\")\n\n        apiService.post(url: ApiEndpoints.posts, body: newPost)\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { completion in\n                switch completion {\n                case .failure(let error):\n                    print(\"Error: \\(error.localizedDescription)\")\n                case .finished:\n                    print(\"Post created successfully\")\n                }\n            }, receiveValue: { (post: Post) in\n                print(\"Created post: \\(post)\")\n            })\n            .store(in: \u0026cancellables)\n    }\n}\n```\n\n# Views\n\n마지막으로, SwiftUI 뷰를 생성하여 게시물을 표시하고 사용자 상호작용을 처리합니다.\n\n```swift\n// Views/PostListView.swift\n\nimport SwiftUI\n\nstruct PostListView: View {\n    @StateObject private var viewModel = PostViewModel()\n\n    var body: some View {\n        NavigationView {\n            VStack {\n                if viewModel.isLoading {\n                    ProgressView(\"로딩 중...\")\n                } else if let errorMessage = viewModel.errorMessage {\n                    Text(\"오류: \\(errorMessage)\")\n                } else {\n                    List(viewModel.posts) { post in\n                        VStack(alignment: .leading) {\n                            Text(post.title)\n                                .font(.headline)\n                            Text(post.body)\n                                .font(.subheadline)\n                        }\n                    }\n                }\n            }\n            .navigationTitle(\"게시물\")\n            .onAppear {\n                viewModel.fetchPosts()\n            }\n            .toolbar {\n                Button(action: {\n                    viewModel.createPost()\n                }) {\n                    Image(systemName: \"plus\")\n                }\n            }\n        }\n    }\n}\n\nstruct PostListView_Previews: PreviewProvider {\n    static var previews: some View {\n        PostListView()\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 모두 함께 적용하기\n\n모두가 동작하는 것을 보려면 PostListView를 App 구조체의 진입점으로 설정하세요.\n\n```js\n// demoApp.swift\n\nimport SwiftUI\n\n@main\nstruct demoApp: App {\n    var body: some Scene {\n        WindowGroup {\n            PostListView()\n        }\n    }\n}\n```\n\n이 튜토리얼에서는 SwiftUI 애플리케이션에서 간단한 MVVM 아키텍처를 구현했습니다. 이 구조는 관심사를 분리하여 코드를 보다 깨끗하고 유지보수하기 쉽게 만들어주며, Combine과 같은 Swift의 강력한 기능을 활용하여 비동기 데이터 스트림 처리에도 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 안내를 따르면 SwiftUI 프로젝트에서 MVVM을 설정하고 사용하는 방법에 대해 잘 이해할 수 있을 것입니다. 코딩을 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide_0.png","tag":["Tech"],"readingTime":8},{"title":"Linker command failed with exit code 1 오류 해결하기","description":"","date":"2024-06-19 10:58","slug":"2024-06-19-FixingLinkercommandfailedwithexitcode1","content":"\n\u003cimg src=\"/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png\" /\u003e\n\niOS 개발 중 에러를 만나면 “Linker command failed with exit code 1”과 같은 알 수 없는 메시지가 표시되면 특히 답답할 수 있습니다. 그러나 걱정하지 마세요! 이 블로그 포스트에서는 이 오류를 해결하고 iOS 프로젝트를 다시 가동할 수 있는 몇 가지 간단한 단계를 안내해 드릴 거에요.\n\n이 오류가 의미하는 바:\n\n“Linker command failed with exit code 1” 오류는 주로 Xcode가 프로젝트 파일을 함께 연결할 수 없을 때 발생합니다. Xcode가 파일을 읽는 데 어려움을 겪는 경우는 파일을 삭제했지만 제대로 삭제되지 않은 복사본이나 종속성이 제대로 읽을 수 없는 경우입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 이 오류를 해결하는 데 따를 수 있는 몇 가지 단계입니다:\n\n- 팟 다시 설치\n\n  1.  먼저 맥에서 터미널을 엽니다.\n  2.  아래 명령어를 따릅니다:\n\n      cd 당신의*프로젝트*경로\n      pod deintegrate\n      pod update\n\n만약 문제가 계속되면 다음을 시도해보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- pod deintegrate\n- pod clean\n- rm Podfile\n- pod init\n- pod install\n\n2. Go to your Project navigator - Target - Build settings - Set BUILD ACTIVE ARCHITECTURE ONLY to NO\n3. Add archicture arm64 and x86_64 in Project navigator - Target - Build settings - EXCLUDED ARCHECTURES\n\n4. Reinstall swift packages\n\n- Remove swift packages and add them again in your project. Don’t remove all the packages at once, start by removing and immediately adding the package that you installed last.\n- Reinstall one package and build your project. If the error still persists, remove another package and reinstall it. Keep doing it with all the packages you have in your project.\n- Don’t forget to press cmd+shift+k to clean build folder before building the project.\n- Also, clean derived data from your project and run Reset package content in your project\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결론:\n그런 걸로 끝났어요! 이 간단한 단계를 따라하면 iOS 프로젝트에서 \"Linker command failed with exit code 1\" 오류를 해결할 수 있을 겁니다. 기억하세요, 에러 해결은 iOS 개발의 필수적인 부분이에요. 조금의 인내와 적절한 도구가 있다면 모든 어려움을 극복할 수 있습니다.\n\n즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png"},"coverImage":"/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png","tag":["Tech"],"readingTime":3},{"title":"iOS에서 Swift를 사용하여 견고한 네트워크 계층 구축하기","description":"","date":"2024-06-19 10:56","slug":"2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift","content":"\n![이미지](/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png)\n\n현대 iOS 개발에서 API 호출 및 데이터 검색을 효율적이고 안전하게 처리하기 위해 잘 구조화된 네트워크 레이어를 갖는 것이 중요합니다. 이 기사에서는 제공된 코드를 기반으로 Swift로 견고한 네트워크 레이어를 만드는 방법을 안내합니다.\n\n# 개요\n\n우리의 네트워크 레이어는 여러 중요한 구성 요소로 구성됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- NetworkError: 다양한 종류의 네트워크 오류를 처리하기 위한 포괄적 인템.\n- NetworkRequest: 네트워크 요청에 필요한 속성과 메소드를 정의하는 프로토콜.\n- NetworkManager: 네트워크 요청 수행, 응답 해석 및 파일 다운로드 처리를 담당하는 싱글톤 클래스입니다.\n\n또한 이러한 구성 요소를 예시 API 호출 및 파일 다운로드와 함께 사용하는 방법을 보여줄 것입니다.\n\n# 단계 1: 네트워크 오류 정의하기\n\n다양한 네트워크 관련 오류를 깨끗하고 조직된 방식으로 처리하는 데 도움이 되는 NetworkError 열거형을 정의하는 것부터 시작해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport Foundation\n\nenum NetworkError: Error {\n    case badURL\n    case requestFailed(Error)\n    case invalidResponse\n    case dataNotFound\n    case decodingFailed(Error)\n    case encodingFailed(Error)\n    case notFound\n    case internalServerError\n    case unknownError(statusCode: Int)\n}\n\nstruct DecodingError: Error {\n    let message: String\n}\n```\n\n설명:\n\nNetworkError Enum: 이 Enum은 발생할 수 있는 가능한 네트워크 관련 오류를 나열하여 오류 처리를 더 쉽게 할 수 있게 합니다.\n\n- badURL: 유효하지 않은 URL을 나타냄.\n- requestFailed: 네트워크 요청 실패를 나타내며 원래 오류를 저장함.\n- invalidResponse: 받은 응답이 유효하지 않음을 나타냄.\n- dataNotFound: 응답에서 기대하는 데이터를 찾을 수 없음을 나타냄.\n- decodingFailed: 응답 데이터를 기대하는 타입으로 디코딩하는 데 실패함을 나타냄.\n- encodingFailed: 요청 매개변수 인코딩 실패를 나타냄.\n- notFound: 404 오류를 나타냄.\n- internalServerError: 500 오류를 나타냄.\n- unknownError: 연결된 상태 코드와 함께 알 수 없는 오류를 나타냄.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n표 태그를 Markdown 형식으로 변경하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네트워크 요청 프로토콜: 모든 네트워크 요청이 따라야 하는 구조를 정의합니다.\n\n- url: 엔드포인트 URL입니다.\n- method: HTTP 메서드(GET, POST 등)입니다.\n- headers: 요청에 필요한 헤더입니다.\n- parameters: 인코딩 가능 프로토콜을 준수하는 요청 매개변수입니다.\n\nHTTPMethod Enum: 요청에 사용되는 다양한 HTTP 메서드를 나타냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHTTPHeader Enum: 일반적인 HTTP 헤더 필드를 나타냅니다.\n\nContentType Enum: HTTP 헤더의 일반적인 콘텐츠 유형을 나타냅니다.\n\n# 단계 3: URLRequest 생성을 위해 NetworkRequest 확장\n\nNetworkRequest 프로토콜을 확장하여 URLRequest 객체를 생성하는 메서드를 포함시킵니다. 이 확장은 HTTP 헤더 및 매개변수 설정을 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nextension NetworkRequest {\n    func urlRequest() throws -\u003e URLRequest {\n        guard let url = url else {\n            throw NetworkError.badURL\n        }\n\n        var request = URLRequest(url: url)\n        request.httpMethod = method.rawValue\n\n        if let headers = headers {\n            for (key, value) in headers {\n                request.setValue(value, forHTTPHeaderField: key.rawValue)\n            }\n        }\n\n        if let parameters = parameters {\n            if method == .get {\n                var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false)\n                let parameterData = try JSONEncoder().encode(parameters)\n                let parameterDictionary = try JSONSerialization.jsonObject(with: parameterData, options: []) as? [String: Any]\n                urlComponents?.queryItems = parameterDictionary?.map { URLQueryItem(name: $0.key, value: \"\\($0.value)\") }\n                request.url = urlComponents?.url\n            } else {\n                do {\n                    let jsonData = try JSONEncoder().encode(parameters)\n                    request.httpBody = jsonData\n                } catch {\n                    throw NetworkError.encodingFailed(error)\n                }\n            }\n        }\n\n        return request\n    }\n}\n```\n\n해설:\n\nURLRequest 생성 메소드: NetworkRequest를 URLRequest 객체로 변환합니다.\n\n- 유효한 URL을 확인하고, 그렇지 않으면 badURL 오류를 발생시킵니다.\n- HTTP 메소드 설정합니다.\n- 제공된 헤더를 설정합니다.\n- 매개변수를 인코딩하고 설정합니다:\n  - GET 요청의 경우, 매개변수를 쿼리 항목으로 추가합니다.\n  - 다른 메소드의 경우, 매개변수를 JSON으로 인코딩하고 요청 본문으로 설정합니다.\n- 인코딩에 실패하면 encodingFailed 오류를 발생시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 4: NetworkManager 구현\n\nNetworkManager는 네트워크 요청을 수행하고 응답을 처리하는 싱글톤 클래스입니다. 이 클래스는 역 호환성을 위해 async/await 및 completion handlers를 모두 지원합니다.\n\n# Async/Await 구현\n\n```js\nimport Foundation\nimport UIKit\n\nclass NetworkManager {\n    static let shared = NetworkManager()\n    private let urlSession = URLSession.shared\n\n    private init() {}\n\n    func perform\u003cT: Decodable\u003e(_ request: NetworkRequest, decodeTo type: T.Type) async throws -\u003e T {\n        if #available(iOS 15.0, *) {\n            let urlRequest = try request.urlRequest()\n            let (data, response) = try await urlSession.data(for: urlRequest)\n            try processResponse(response: response)\n            return try decodeData(data: data, type: T.self)\n        } else {\n            return try await withCheckedThrowingContinuation { continuation in\n                perform(request, decodeTo: type) { result in\n                    switch result {\n                    case .success(let data):\n                        continuation.resume(returning: data)\n                    case .failure(let error):\n                        continuation.resume(throwing: error)\n                    }\n                }\n            }\n        }\n    }\n\n    private func decodeData\u003cT: Decodable\u003e(data: Data, type: T.Type) throws -\u003e T {\n        do {\n            let decodedObject = try JSONDecoder().decode(T.self, from: data)\n            return decodedObject\n        } catch let decodingError {\n            throw NetworkError.decodingFailed(decodingError)\n        }\n    }\n\n    private func processResponse(response: URLResponse?) throws {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n\n        switch httpResponse.statusCode {\n        case 200...299:\n            return\n        case 404:\n            throw NetworkError.notFound\n        case 500:\n            throw NetworkError.internalServerError\n        default:\n            throw NetworkError.unknownError(statusCode: httpResponse.statusCode)\n        }\n    }\n\n    func downloadFile(from url: URL) async throws -\u003e URL {\n        if #available(iOS 15.0, *) {\n            let (localURL, response) = try await urlSession.download(from: url)\n            try processResponse(response: response)\n            return localURL\n        } else {\n            return try await withCheckedThrowingContinuation { continuation in\n                downloadFile(from: url) { result in\n                    switch result {\n                    case .success(let localURL):\n                        continuation.resume(returning: localURL)\n                    case .failure(let error):\n                        continuation.resume(throwing: error)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설명:\n\nNetworkManager Singleton: 네트워크 요청을 수행하기 위한 단일 인스턴스를 제공합니다.\n\n- shared: 싱글톤 인스턴스입니다.\n- urlSession: 네트워크 작업을 위한 공유 URLSession 인스턴스입니다.\n- init(): 여러 인스턴스 생성을 방지하기 위한 비공개 이니셜라이저입니다.\n\nperform 메서드:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- iOS 15.0 이상인 경우:\n  - NetworkRequest에서 URLRequest를 생성합니다.\n  - 요청을 비동기적으로 처리합니다.\n  - 응답을 처리합니다.\n  - 응답 데이터를 지정된 유형으로 디코딩합니다.\n- 이전 iOS 버전의 경우:\n  - 완료 핸들러를 사용하여 요청을 처리하는 데 continuation을 사용합니다.\n\ndecodeData 메서드: 데이터를 지정된 유형으로 디코딩하고 디코딩에 실패하면 decodingFailed 오류를 throw합니다.\n\nprocessResponse 메서드: HTTP 응답을 유효성 검사하고 상태 코드에 따라 적절한 오류를 throw합니다.\n\ndownloadFile 메서드: 지정된 URL에서 파일을 다운로드하며 역호환성을 위해 async/await 및 완료 핸들러를 모두 지원합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 완료 핸들러 구현\n\n오래된 iOS 버전을 위해 완료 핸들러를 사용하여 네트워크 요청을 구현합니다.\n\n```swift\nextension NetworkManager {\n    private func perform\u003cT: Decodable\u003e(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result\u003cT, NetworkError\u003e) -\u003e Void) {\n        do {\n            let urlRequest = try request.urlRequest()\n            urlSession.dataTask(with: urlRequest) { data, response, error in\n                if let error = error {\n                    completion(.failure(.requestFailed(error)))\n                    return\n                }\n\n                guard let data = data else {\n                    completion(.failure(.dataNotFound))\n                    return\n                }\n\n                do {\n                    try self.processResponse(response: response)\n                    let decodedObject = try self.decodeData(data: data, type: T.self)\n                    completion(.success(decodedObject))\n                } catch {\n                    completion(.failure(error as? NetworkError ?? .invalidResponse))\n                }\n            }.resume()\n        } catch {\n            completion(.failure(error as? NetworkError ?? .invalidResponse))\n        }\n    }\n\n    private func downloadFile(from url: URL, completion: @escaping (Result\u003cURL, NetworkError\u003e) -\u003e Void) {\n        urlSession.downloadTask(with: url) { localURL, response, error in\n            if let error = error {\n                completion(.failure(.requestFailed(error)))\n                return\n            }\n\n            guard let localURL = localURL else {\n                completion(.failure(.dataNotFound))\n                return\n            }\n\n            do {\n                try self.processResponse(response: response)\n                completion(.success(localURL))\n            } catch {\n                completion(.failure(error as? NetworkError ?? .invalidResponse))\n            }\n        }.resume()\n    }\n}\n```\n\n설명:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n완료 핸들러를 사용하여 perform 메소드:\n\n- URLRequest를 생성하고 URLSession.dataTask를 사용하여 요청을 수행합니다.\n- 오류를 처리하고 응답 유효성을 확인합니다.\n- 응답 데이터를 디코딩하고 결과로 완료 핸들러를 호출합니다.\n\n완료 핸들러를 사용하여 downloadFile 메소드:\n\n- URLSession.downloadTask를 사용하여 파일을 다운로드합니다.\n- 오류를 처리하고 응답 유효성을 확인합니다.\n- 다운로드된 파일의 로컬 URL로 완료 핸들러를 호출합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 5: 이미지 다운로드 및 캐싱\n\n이미지 다운로드를 처리하고 선택적으로 캐싱하는 NetworkManager를 확장합니다.\n\n```js\nextension NetworkManager {\n    func downloadImage(from url: URL, cacheEnabled: Bool = true) async -\u003e Result\u003cUIImage, NetworkError\u003e {\n        do {\n            if cacheEnabled, let cachedImage = try getCachedImage(for: url) {\n                return .success(cachedImage)\n            }\n\n            let localURL = try await NetworkManager.shared.downloadFile(from: url)\n            let imageData = try Data(contentsOf: localURL)\n            if let image = UIImage(data: imageData) {\n                if cacheEnabled {\n                    cacheImage(imageData, for: url)\n                }\n                return .success(image)\n            } else {\n                return .failure(.decodingFailed(DecodingError(message: \"Failed to decode image data\")))\n            }\n        } catch {\n            return .failure(error as? NetworkError ?? .invalidResponse)\n        }\n    }\n\n    private func cacheImage(_ imageData: Data, for url: URL) {\n        let cachedResponse = CachedURLResponse(response: HTTPURLResponse(url: url, statusCode: 200, httpVersion: nil, headerFields: nil)!, data: imageData)\n        URLCache.shared.storeCachedResponse(cachedResponse, for: URLRequest(url: url))\n        checkAndClearCache()\n    }\n\n    private func checkAndClearCache() {\n        let cacheSize = URLCache.shared.currentDiskUsage\n        let cacheLimit: Int = 100 * 1024 * 1024 // 100 MB\n        if cacheSize \u003e cacheLimit {\n            URLCache.shared.removeAllCachedResponses()\n        }\n    }\n\n    private func getCachedImage(for url: URL) throws -\u003e UIImage? {\n        if let cachedResponse = URLCache.shared.cachedResponse(for: URLRequest(url: url)),\n           let image = UIImage(data: cachedResponse.data) {\n            return image\n        }\n        return nil\n    }\n}\n```\n\n설명:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 친절한 톤으로 번역한 내용입니다.\n\ndownloadImage 메서드: URL에서 이미지를 다운로드하며 선택적으로 캐싱합니다.\n\n- 캐싱이 활성화된 경우 먼저 캐시를 확인합니다.\n- async/await 또는 이전 iOS 버전을 위한 완료 핸들러를 사용하여 다운로드를 수행합니다.\n- 응답을 처리하고 이미지 데이터를 디코딩합니다.\n- 캐싱이 활성화된 경우 이미지를 캐시에 저장합니다.\n\ncacheImage 메서드: 이미지를 캐시에 저장합니다.\n\nloadImageFromCache 메서드: 캐시에서 이미지를 로드합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 예시 사용법\n\n# API 호출 요청\n\n```js\nstruct ExampleAPIRequest: NetworkRequest {\n    var url: URL? {\n        return URL(string: \"https://api.example.com/data\")\n    }\n    var method: HTTPMethod {\n        return .get\n    }\n    var headers: [HTTPHeader: String]? {\n        return [.contentType: ContentType.json.rawValue]\n    }\n    var parameters: Encodable? {\n        return ExampleParameters(param1: \"value1\", param2: \"value2\")\n    }\n}\n\nstruct ExampleParameters: Encodable {\n    let param1: String\n    let param2: String\n}\n\nstruct ExampleData: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchExampleData() async {\n    let request = ExampleAPIRequest()\n\n    if #available(iOS 15.0, *) {\n        do {\n            let data: ExampleData = try await NetworkManager.shared.perform(request, decodeTo: ExampleData.self)\n            print(\"데이터 가져오기 성공: \\(data)\")\n        } catch {\n            print(\"데이터 가져오기 실패: \\(error)\")\n        }\n    } else {\n        NetworkManager.shared.perform(request, decodeTo: ExampleData.self) { result in\n            switch result {\n            case .success(let data):\n                print(\"데이터 가져오기 성공: \\(data)\")\n            case .failure(let error):\n                print(\"데이터 가져오기 실패: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n설명:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`ExampleAPIRequest Struct`: 네트워크 요청을 나타내며 `NetworkRequest` 프로토콜을 준수하는 구조체입니다.\n\n- URL, HTTP 메서드, 헤더 및 매개변수를 지정합니다.\n\n`ExampleParameters Struct`: `Encodable`을 준수하는 요청 매개변수를 나타내는 구조체입니다.\n\n`ExampleData Struct`: `Decodable`을 준수하는 응답 데이터를 나타내는 구조체입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`table` 태그를 Markdown 형식으로 변경해주세요.\n\nfetchExampleData 함수: async/await를 활용하여 요청을 수행하고 응답을 처리하는 방법을 보여줍니다.\n\n# 이미지 다운로드\n\n```js\nimport SwiftUI\n\nstruct HomeView: View {\n    @State private var image: UIImage? = nil\n\n    var body: some View {\n        VStack {\n            if let image = image {\n                Image(uiImage: image)\n                    .resizable()\n                    .aspectRatio(contentMode: .fit)\n                    .frame(width: 200, height: 200)\n            } else {\n                ProgressView()\n            }\n        }\n        .onAppear {\n            let imageURL = URL(string: \"https://picsum.photos/200/200\")!\n            Task {\n                let result = await NetworkManager.shared.downloadImage(from: imageURL, cacheEnabled: false)\n                switch result {\n                case .success(let success):\n                    self.image = success\n                case .failure(_):\n                    self.image = nil\n                }\n            }\n        }\n    }\n}\n\nstruct HomeView_Previews: PreviewProvider {\n    static var previews: some View {\n        HomeView()\n    }\n}\n```\n\n설명:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHomeView Struct는 URL에서 다운로드된 이미지를 표시하는 SwiftUI 뷰입니다.\n\n- 이미지 상태를 관리하기 위해 @State를 사용합니다.\n- 이미지를 로드하는 동안 ProgressView를 표시합니다.\n- appear될 때 async/await를 사용하여 이미지를 다운로드합니다.\n- 다운로드 결과를 처리합니다.\n\n# 파일 다운로드\n\n```js\nimport Foundation\n\nfunc downloadExampleFile() async {\n    let fileURL = URL(string: \"https://example.com/file.zip\")!\n\n    if #available(iOS 15.0, *) {\n        do {\n            let localURL = try await NetworkManager.shared.downloadFile(from: fileURL)\n            print(\"다운로드한 파일 경로: \\(localURL)\")\n        } catch {\n            print(\"파일 다운로드 실패: \\(error)\")\n        }\n    } else {\n        NetworkManager.shared.downloadFile(from: fileURL) { result in\n            switch result {\n            case .success(let localURL):\n                print(\"다운로드한 파일 경로: \\(localURL)\")\n            case .failure(let error):\n                print(\"파일 다운로드 실패: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설명:\n\ndownloadExampleFile 함수: async/await를 사용하여 파일을 다운로드하는 방법을 보여줍니다.\n\n- 이전 iOS 버전을 위한 async/await 및 완료 핸들러를 모두 지원합니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 네트워크 계층이 구현되면 iOS 애플리케이션이 API 요청을 처리하고 응답을 처리하며 파일 다운로드를 관리하는 데 더 잘 준비될 것입니다. 이 구조화된 접근 방식은 코드베이스를 더 깔끔하게 만들 뿐만 아니라 유지 보수가 용이하고 확장성이 뛰어난 장점을 제공합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png","tag":["Tech"],"readingTime":21},{"title":"Swift로 강력한 네트워크 레이어 만들기 파트 2","description":"","date":"2024-06-19 10:54","slug":"2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2","content":"\n\u003cimg src=\"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png\" /\u003e\n\n현대 iOS 개발에서는 API 호출 및 데이터 검색을 효율적이고 안전하게 처리하는 데 잘 구조화된 네트워크 레이어가 필수적입니다. 본 후속 기사에서는 SOLID 원칙을 준수하고 클래스 기반에서 구조체 기반으로 전환하여 네트워크 레이어를 개선하고 리팩터링한 내용을 안내해 드릴 것입니다. 이를 통해 코드베이스를 더 잘 유지보수할 수 있고 확장 가능하도록 보장할 것입니다.\n\n# 개요\n\n저희가 업그레이드한 네트워크 레이어에는 다음 구성요소가 포함되어 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- NetworkError: 다양한 네트워크 오류를 처리하기 위한 포괄적인 열거형입니다.\n- NetworkRequest: 네트워크 요청을 위한 필수 속성 및 메서드를 정의하는 프로토콜입니다.\n- HTTPResponseHandler: HTTP 응답을 처리하고 디코딩하는 프로토콜입니다.\n- NetworkEngine: 네트워크 요청 수행, 로깅 및 응답 처리를 담당하는 구조체입니다.\n\n이러한 구성 요소를 예제 API 호출과 함께 사용하는 방법을 보여드리겠습니다.\n\n# 단계 1: 네트워크 오류 정의\n\n먼저 NetworkError 열거형을 정의하여 다양한 네트워크 관련 오류를 깔끔하고 조직적으로 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nimport Foundation\n\nenum NetworkError: Error {\n    case badURL\n    case requestFailed(Error)\n    case invalidResponse\n    case dataNotFound\n    case decodingFailed(Error)\n    case encodingFailed(Error)\n    case notFound\n    case timeout\n    case internalServerError\n    case unknownError(statusCode: Int)\n}\n\nstruct DecodingError: Error {\n    let message: String\n}\n```\n\n해설:\n\n- NetworkError: 이 열거형은 네트워크 작업 중 발생할 수 있는 다양한 유형의 오류를 캡슐화합니다. 각 case는 특정 오류 시나리오를 나타냅니다:\n  - badURL: URL이 잘못되었음을 나타냅니다.\n  - requestFailed: 요청을 만드는 데 실패한 것을 나타내며 내장된 오류를 캡슐화합니다.\n  - invalidResponse: 응답이 유효하지 않음을 나타냅니다.\n  - dataNotFound: 응답에서 데이터를 찾을 수 없음을 신호합니다.\n  - decodingFailed: 응답 데이터를 해독하는 데 실패한 것을 나타내며 해독 오류를 캡슐화합니다.\n  - encodingFailed: 요청 매개변수를 인코딩하는 데 실패한 것을 나타내며 인코딩 오류를 캡슐화합니다.\n  - notFound: 요청한 리소스를 찾을 수 없음을 나타냅니다 (HTTP 404).\n  - timeout: 타임아웃 오류를 나타냅니다.\n  - internalServerError: 서버 오류임을 나타냅니다 (HTTP 500).\n  - unknownError: 다른 HTTP 상태 코드 오류를 나타내며 상태 코드를 캡슐화합니다.\n\nDecodingError: 해독 중 추가 오류 정보를 제공하기 위한 사용자 정의 오류 구조체입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 2: NetworkRequest 프로토콜 생성하기\n\nNetworkRequest 프로토콜은 URL, HTTP 메소드, 헤더, 매개변수 및 타임아웃 간 필수적인 속성을 정의합니다.\n\n```js\nimport Foundation\n\nenum HTTPMethod: String {\n    case get = \"GET\"\n    case post = \"POST\"\n    case put = \"PUT\"\n    case delete = \"DELETE\"\n}\n\nenum HTTPHeader: String {\n    case contentType = \"Content-Type\"\n    case authorization = \"Authorization\"\n}\n\nenum ContentType: String {\n    case json = \"application/json\"\n    case xml = \"application/xml\"\n    case formUrlEncoded = \"application/x-www-form-urlencoded\"\n}\n\nprotocol NetworkRequest {\n    var url: URL? { get }\n    var method: HTTPMethod { get }\n    var headers: [HTTPHeader: String]? { get }\n    var parameters: Encodable? { get }\n    var timeoutInterval: TimeInterval { get }\n}\n\nextension NetworkRequest {\n    var timeoutInterval: TimeInterval {\n        return 30\n    }\n\n    func urlRequest() throws -\u003e URLRequest {\n        guard let url = url else {\n            throw NetworkError.badURL\n        }\n\n        var request = URLRequest(url: url)\n        request.httpMethod = method.rawValue\n\n        if let headers = headers {\n            for (key, value) in headers {\n                request.setValue(value, forHTTPHeaderField: key.rawValue)\n            }\n        }\n\n        if let parameters = parameters {\n            if method == .get {\n                var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false)\n                let parameterData = try JSONEncoder().encode(parameters)\n                let parameterDictionary = try JSONSerialization.jsonObject(with: parameterData, options: []) as? [String: Any]\n                urlComponents?.queryItems = parameterDictionary?.map { URLQueryItem(name: $0.key, value: \"\\($0.value)\") }\n                request.url = urlComponents?.url\n            } else {\n                do {\n                    let jsonData = try JSONEncoder().encode(parameters)\n                    request.httpBody = jsonData\n                } catch {\n                    throw NetworkError.encodingFailed(error)\n                }\n            }\n        }\n\n        return request\n    }\n}\n```\n\n설명:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- HTTPMethod: 우리가 사용할 HTTP 메소드(GET, POST, PUT, DELETE)를 나타내는 enum입니다.\n- HTTPHeader: 일반적인 HTTP 헤더를 위한 enum입니다.\n- ContentType: HTTP 헤더에서 사용되는 일반적인 콘텐츠 유형을 위한 enum입니다.\n- NetworkRequest: 네트워크 요청에 필요한 속성을 정의하는 프로토콜입니다.\n  - url: 요청을 위한 URL입니다.\n  - method: 요청을 위한 HTTP 메소드입니다.\n  - headers: 요청에 대한 선택적 헤더입니다.\n  - parameters: 인코딩 가능한 형식을 준수하는 요청에 대한 선택적 매개변수입니다.\n  - timeoutInterval: 요청의 타임아웃 간격입니다.\n- 프로토콜 확장은 timeoutInterval의 기본 구현과 속성에서 URLRequest를 만들기 위한 urlRequest() 메소드를 제공합니다.\n  - 만약 메소드가 GET이면, 매개변수는 URL에 쿼리 아이템으로 추가됩니다.\n  - 다른 메소드의 경우, 매개변수는 JSON으로 인코딩되어 요청 바디에 추가됩니다.\n  - 헤더는 요청에 추가됩니다.\n\n# 단계 3: HTTPResponseHandler 구현하기\n\nHTTPResponseHandler 프로토콜은 HTTP 응답을 처리하고 디코딩하기 위한 메소드를 정의합니다.\n\n```js\nimport Foundation\n\npublic protocol HTTPResponseHandler {\n    func handleStatusCode(response: URLResponse?) throws\n    func decode\u003cT: Decodable\u003e(data: Data, to type: T.Type) throws -\u003e T\n    func extractETag(from response: URLResponse?) -\u003e String?\n}\n\nextension HTTPResponseHandler {\n    public func decode\u003cT: Decodable\u003e(data: Data, to type: T.Type) throws -\u003e T {\n        do {\n            let decodedObject = try JSONDecoder().decode(T.self, from: data)\n            return decodedObject\n        } catch let decodingError {\n            throw NetworkError.decodingFailed(decodingError)\n        }\n    }\n\n    public func handleStatusCode(response: URLResponse?) throws {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n\n        switch httpResponse.statusCode {\n        case 200...299:\n            return\n        case 404:\n            throw NetworkError.notFound\n        case 500:\n            throw NetworkError.internalServerError\n        default:\n            throw NetworkError.unknownError(statusCode: httpResponse.statusCode)\n        }\n    }\n\n    public func extractETag(from response: URLResponse?) -\u003e String? {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            return nil\n        }\n        return httpResponse.allHeaderFields[\"ETag\"] as? String\n    }\n}\n\npublic struct DefaultHTTPResponseHandler: HTTPResponseHandler {\n    public init() {}\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설명:\n\n- HTTPResponseHandler: HTTP 응답을 처리하고 해독하는 메서드를 정의하는 프로토콜입니다.\n  - handleStatusCode(response:): HTTP 상태 코드를 확인하고 적절한 오류를 throw합니다.\n  - decode(data:to:): Decodable을 준수하는 특정 타입으로 데이터를 디코딩합니다.\n  - extractETag(from:): 응답 헤더에서 ETag을 추출합니다.\n\n이 확장(extension)은 다음을 제공합니다:\n\n- decode(data:to:)은 데이터를 디코딩하기 위해 JSONDecoder를 사용하고 실패할 경우 NetworkError.decodingFailed를 throw합니다.\n- handleStatusCode(response:)은 HTTP 상태 코드를 확인하고 공통 오류(404, 500)에 대해 특정 NetworkError 케이스를 throw하며, 다른 상태 코드에 대해서는 알 수 없는 오류를 throw합니다.\n- extractETag(from:)은 응답 헤더에서 ETag을 가져옵니다.\n- DefaultHTTPResponseHandler: HTTPResponseHandler의 구체적인 구현체입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 4: NetworkEngine 구현\n\nNetworkEngine 구조체는 네트워크 요청을 수행하고 응답을 처리하는 역할을 담당합니다.\n\n```js\nimport Foundation\n\nstruct NetworkRequestContext\u003cT: Decodable\u003e {\n    let request: NetworkRequest\n    let type: T.Type\n    let completion: (Result\u003cT, NetworkError\u003e) -\u003e Void\n    let requestInvokeTime: Date\n}\n\nprotocol NetworkEngineAdapter {\n    func invokeEngine\u003cT: Decodable\u003e(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result\u003cT, NetworkError\u003e) -\u003e Void)\n}\n\npublic struct NetworkEngine {\n    private let urlSession: URLSession\n    private let logger: Logger\n    private let responseHandler: HTTPResponseHandler\n\n    public init(urlSession: URLSession = .shared,\n                logger: Logger = DefaultLogger(),\n                responseHandler: HTTPResponseHandler = DefaultHTTPResponseHandler()) {\n        self.urlSession = urlSession\n        self.logger = logger\n        self.responseHandler = responseHandler\n    }\n}\n\nextension NetworkEngine: NetworkEngineAdapter {\n    func invokeEngine\u003cT\u003e(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result\u003cT, NetworkError\u003e) -\u003e Void) where T: Decodable {\n        let requestInvokeTime = Date()\n        let context = NetworkRequestContext(request: request, type: type, completion: completion, requestInvokeTime: requestInvokeTime)\n        fetch(context)\n    }\n\n    private func fetch\u003cT\u003e(_ context: NetworkRequestContext\u003cT\u003e) where T: Decodable {\n        do {\n            var urlRequest = try context.request.urlRequest()\n            urlRequest.timeoutInterval = context.request.timeoutInterval\n\n            urlSession.dataTask(with: urlRequest) { data, response, error in\n                let requestFinishTime = Date()\n                let duration = requestFinishTime.timeIntervalSince(context.requestInvokeTime)\n\n                logger.logMetrics(startTime: context.requestInvokeTime, endTime: requestFinishTime, duration: duration, request: urlRequest)\n\n                if let error = error {\n                    context.completion(.failure(.requestFailed(error)))\n                    return\n                }\n\n                guard let data = data else {\n                    context.completion(.failure(.dataNotFound))\n                    return\n                }\n\n                do {\n                    try responseHandler.handleStatusCode(response: response)\n                    let decodedObject = try responseHandler.decode(data: data, to: context.type)\n                    context.completion(.success(decodedObject))\n                } catch let error as NetworkError {\n                    context.completion(.failure(error))\n                } catch {\n                    context.completion(.failure(.unknownError(statusCode: (response as? HTTPURLResponse)?.statusCode ?? -1)))\n                }\n            }.resume()\n        } catch {\n            context.completion(.failure(.requestFailed(error)))\n        }\n    }\n}\n```\n\n설명:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- NetworkRequestContext: 네트워크 요청의 컨텍스트를 캡슐화하는 구조체로, 요청 자체, 디코딩할 유형, 완료 핸들러, 그리고 요청이 호출된 시간을 포함합니다.\n- NetworkEngineAdapter: 네트워크 엔진을 요청과 함께 호출하고, 디코딩할 유형을 지정하며 완료 핸들러를 제공하는 메소드를 정의하는 프로토콜입니다.\n- NetworkEngine: 네트워크 작업을 수행하는 주요 구조체입니다:\n  - urlSession: 요청을 만드는 데 사용되는 URLSession 인스턴스입니다.\n  - logger: 메트릭 및 오류를 기록하기 위한 로거입니다.\n  - responseHandler: 응답 처리를 위한 HTTPResponseHandler의 인스턴스입니다.\n  - init: NetworkEngine을 urlSession, logger 및 responseHandler에 대한 옵션 매개변수로 초기화합니다.\n- invokeEngine 메소드는 NetworkRequestContext를 생성하고 fetch 메소드를 호출합니다.\n\nfetch 메소드:\n\n- NetworkRequest로부터 URLRequest를 만들려고 시도합니다.\n- 타임아웃 간격을 설정합니다.\n- urlSession.dataTask를 사용하여 네트워크 요청을 수행합니다.\n- 요청에 대한 메트릭을 기록합니다.\n- 오류, 누락된 데이터 및 상태 코드를 처리합니다.\n- 데이터를 디코딩하고 결과와 함께 완료 핸들러를 호출합니다.\n\n# 단계 5: 네트워크 레이어 사용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시는 iOS에서 NetworkEngine을 사용하는 방법을 보여줍니다.\n\n## 네트워크 요청 정의하기\n\n먼저, NetworkRequest 프로토콜을 준수하는 PostService enum을 정의합니다. 이 enum은 네트워크 요청의 세부 사항을 캡슐화합니다.\n\n```swift\nimport Foundation\n\nenum PostService {\n    case fetchPosts\n}\n\nextension PostService: NetworkRequest {\n    var url: URL? {\n        switch self {\n        case .fetchPosts:\n            return URL(string: \"https://2e84f9d6-0dcb-4b93-9238-8b272604b4c1.mock.pstmn.io/v1/posts\")\n        }\n    }\n\n    var method: HTTPMethod {\n        switch self {\n        case .fetchPosts:\n            return .get\n        }\n    }\n\n    var headers: [HTTPHeader : String]? {\n        return [.contentType: ContentType.json.rawValue]\n    }\n\n    var parameters: (any Encodable)? {\n        switch self {\n        case .fetchPosts:\n            return nil\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 PostService는 URL, HTTP 메서드, 헤더 및 요청에 대한 매개변수를 정의하는 단일 case fetchPosts를 갖습니다. 필요에 따라 더 추가할 수 있어요.\n\n## Repository 생성\n\n다음으로, NetworkEngine를 사용하여 요청을 실행할 repository 클래스를 만듭니다. 이 repository는 게시물을 가져오는 작업을 처리할 거에요:\n\n[연결](/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nprotocol PostsListRepositoryProtocol {\n  func fetchPostsList\u003cT: Decodable\u003e(with request: NetworkRequest, responseType: T.Type, completion: @escaping (Result\u003cT, NetworkError\u003e) -\u003e Void)\n}\n\nfinal class DefaultPostsListRepository: PostsListRepositoryProtocol {\n    private let engine: NetworkEngine\n\n    init(engine: NetworkEngine = NetworkEngine()) {\n        self.engine = engine\n    }\n\n    func fetchPostsList\u003cT\u003e(with request: NetworkRequest, responseType: T.Type, completion: @escaping (Result\u003cT, NetworkError\u003e) -\u003e Void) where T : Decodable {\n        engine.invokeEngine(request, decodeTo: responseType, completion: completion)\n    }\n}\n```\n\n이 저장소에서 fetchPostsList 메서드는 NetworkRequest와 응답을 디코딩할 responseType을 사용합니다. NetworkEngine을 사용하여 요청을 실행하고 결과를 전달하기 위해 완료 핸들러를 호출합니다. 이 저장소를 직접 ViewModel이나 보기 UseCase에 사용할 수 있습니다.\n\n# 결론\n\n이 코드베이스의 네트워크 레이어 디자인은 모듈화, 확장 가능성, 견고한 오류 처리, 테스트 용이성 및 성능 모니터링을 강조하여 확장 가능한 애플리케이션에 적합합니다. 이러한 특성들은 유지 보수성과 신뢰성을 저해하지 않고 앱이 기능과 복잡성을 향상시킬 수 있음을 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 많은 통찰과 업데이트를 원하시면 LinkedIn에서 저를 팔로우해주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png","tag":["Tech"],"readingTime":16},{"title":"파이썬에서 typingTYPE_CHECKING이 30초 안에 설명하기","description":"","date":"2024-06-19 10:53","slug":"2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds","content":"\n\u003cimg src=\"/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png\" /\u003e\n\n근무 중인 Python 코드베이스에서 이러한 코드 조각을 본 적이 있을 수 있습니다. 이 코드가 무슨 일을 하는지 궁금했던 적이 있다면, 오늘은 여기 있어서 설명해 드리겠습니다.\n\n# typing.TYPE_CHECKING은 그냥 False입니다\n\n```python\nfrom typing import TYPE_CHECKING\n\nprint(TYPE_CHECKING)\n\n# False\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적인 경우에는 TYPE_CHECKING 변수가 그냥 False로 설정되어 있습니다. 하지만 이 경우에 왜 사용하는 걸까요?\n\ntyping.TYPE_CHECKING은 정적 타입 체크(myppy 등)를 할 때 True로 설정된다고 가정됩니다.\n\n그러나 코드를 보통 실행할 때는 단순히 False입니다. 그러면 왜 이걸 사용하는 걸까요?\n\n# 경우 1 — 개 대 인간\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에는 서로 가져오는 dog.py와 human.py가 있습니다.\n\n```python\n# dog.py\n\nfrom human import Human\n\nclass Dog:\n    def get_human() -\u003e Human:\n      ...\n```\n\n```python\n# human.py\n\nfrom dog import Dog\n\nclass Human:\n    def get_dog() -\u003e Dog:\n        ...\n```\n\n여기서 서로를 가져오는 순환 포함이 있다는 것을 주의하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- dog.py에서 human.py를 가져오고\n- human.py에서는 dog.py를 가져옵니다\n\n그래서 dog.py나 human.py 또는 dog.py나 human.py를 가져오는 다른 Python 스크립트 중 하나를 실행하면 순환 임포트 오류가 발생합니다:\n\n```js\nImportError: cannot import name 'Human' from\npartially initialized module 'human'\n(most likely due to a circular import)\n```\n\n# Case 2 — Dog VS Human, but with TYPE_CHECKING\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDog와 Human만 유형 주석에 필요하기 때문에 `-` Human과 `-` Dog와 같이 전체 클래스를 가져올 필요는 실제로 없습니다. 원형 가져오기 문제를 피하기 위해 다음 구문을 사용할 수 있습니다.\n\n```js\n# dog.py\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n  from human import Human\n\nclass Dog:\n    def get_human() -\u003e \"Human\":\n      ...\n```\n\n```js\n# human.py\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n  from dog import Dog\n\nclass Human:\n    def get_dog() -\u003e \"Dog\":\n        ...\n```\n\n여기에서 이전 코드에 몇 가지 변경 사항을 가했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `typing`에서 `TYPE_CHECKING`을 import하는 부분을 추가했어요.\n- `TYPE_CHECKING` 조건문 아래에서 import 문들을 옮겼어요.\n- Dog와 Human 타입 어노테이션 주변에 따옴표를 추가했어요.\n\n그리고 코드를 실행해보면, 이제는 순환 import 문제가 없어졌어요.\n\n# 왜 순환 import 문제가 사라졌을까요?\n\n```js\ndef get_human() -\u003e Human:\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 예제는 다음과 같이 변경되었습니다:\n\n```python\ndef get_human() -\u003e \"Human\":\n```\n\n따라서 Python은 더 이상 human.py에서 실제 Human 클래스를 가져오려고 시도하지 않습니다 (이는 순환 임포트 문제를 발생시킵니다).\n\n# 그렇다면 TYPE_CHECKING이 왜 필요한가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n큰 파이썬 프로젝트에서는 어쩌면 언젠가는 mypy와 같은 정적 타입 체커를 사용할 것입니다.\n\n정적 타입 체커를 실행할 때 typing.TYPE_CHECKING 변수를 True로 설정하고 실제로 클래스를 가져옵니다. (걱정 마세요 - 정적 타입 체커는 순환 Import 문제를 다른 방식으로 처리할 수 있습니다)\n\n하지만 코드를 보통 실행하고 정적 타입 체커를 다룰 필요가 없을 때는 실제 클래스를 가져올 필요가 없습니다.\n\n요컨대, TYPE_CHECKING이 추가된 이유는:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 순환 가져오기 문제가 발생하지 않습니다\n- 해당 스크립트를 실행할 때 정적 유형 검사를 여전히 제대로 수행할 수 있습니다 (원래 유형 주석을 제거할 필요가 없음)\n\n# 결론\n\n확실하고 이해하기 쉬웠기를 바랍니다.\n\n# 만약 제작자로서 저를 지원하고 싶다면\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이 이야기에 대해 50번 박수를 쳐주세요\n- 생각을 말씀해 주시는 댓글을 남겨주세요\n- 이야기 중 가장 좋아하는 부분을 강조해주세요\n\n감사합니다! 이 작은 행동들이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: https://www.youtube.com/@zlliu246\n\nLinkedIn: https://www.linkedin.com/in/zlliu/\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 Ebooks: [https://zlliu.co/ebooks](https://zlliu.co/ebooks)\n","ogImage":{"url":"/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png"},"coverImage":"/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png","tag":["Tech"],"readingTime":6},{"title":"이 12개의 YouTube 채널로 12가지를 배워보세요","description":"","date":"2024-06-19 10:52","slug":"2024-06-19-Learn12ThingswithThese12YouTubeChannels","content":"\n\u003cimg src=\"/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png\" /\u003e\n\n새로운 것을 배우고 성장하고 싶으세요? 좋은 소식입니다! 유튜브를 시청하면 그것이 가능합니다! 여러분이 다양한 분야에서 도움을 받을 수 있는 12가지 멋진 채널을 소개합니다.\n\n- FreeCodeCamp: 코딩 배우기\n  컴퓨터 프로그램을 만드는 방법을 배우고 싶다면 FreeCodeCamp를 확인해보세요. 초보자를 위한 쉬운 레슨과 전문가를 위한 더 어려운 것도 있습니다.\n- TED: 영감을 얻기\n  TED는 다양한 주제에 대해 이야기합니다. 전 세계 사람들이 아이디어와 이야기를 나눕니다. 새로운 것을 배우고 영감을 받는 좋은 방법입니다.\n- Jeff Nippard: 피트니스 팁\n  건강하고 강한 모습을 유지하는 것을 좋아한다면 Jeff Nippard가 도움이 될 것입니다. 운동 및 건강한 식습관에 대한 조언과 설명에는 과학적 근거가 포함되어 있습니다.\n- Veritasium: 재미있는 과학\n  Veritasium은 과학을 즐겁게 합니다! 멋진 실험을 수행하고 어려운 것을 쉽게 설명합니다. 당신도 곧 과학 전문가가 될 거예요!\n- Charisma on Command: 더 매력적으로\n  더 매력적이 되고 싶나요? Charisma on Command가 가르쳐 줍니다. 사람들이 당신을 좋아하게끔 말하고 행동하는 방법을 배우세요.\n- Miles Beckler: 디지털 마케팅 팁\n  Miles Beckler은 디지털 마케팅을 이해하는 데 도움이 됩니다. 온라인 비즈니스를 키우고 싶다면, 그의 조언은 매우 유용할 수 있습니다.\n- Ahrefs: SEO 마스터\n  Ahrefs는 웹사이트를 검색 엔진에 표시하는 팁을 제공합니다. 복잡해 보일 수 있지만, 그들은 쉽게 이해할 수 있게 설명해줍니다.\n- Khan Academy: 모든 것 배우기\n  Khan Academy는 다양한 주제에 대한 무료 레슨을 제공합니다. 컴퓨터에 교사가 있는 것처럼 느껴집니다. 모든 연령층에게 좋습니다!\n- Mindvalley: 개인적으로 성장하기\n  Mindvalley는 자신을 더 나아지게 하는 것에 대한 모든 것입니다. 영적 성장, 생산성 및 기타 도움이 되는 주제에 대해 배웁니다.\n- Athlean-X: 건강하고 강해지기\n  건강하고 강해지고 싶다면 Athlean-X가 가야할 곳입니다. Jeff Cavaliere가 운동 및 훈련에 대한 전문적인 조언을 제공합니다.\n- Nerdwriter1: 깊이 생각하기\n  Nerdwriter1은 예술과 문화에 대해 간단히 이야기합니다. 흥미로운 것을 설명해주는 현명한 친구가 당신에게 흥미로운 것을 설명해줍니다.\n- Vsauce: 재미있는 사실 배우기\n  Vsauce는 흥미로운 질문에 재미있게 대답합니다. 멋진 사실을 배우며 즐길 수 있습니다.\n\n이 유튜브 채널들은 여러분만의 교사와 멘토가 있는 것과 같습니다. 그러니 편히 앉아서 배우고 성장하는 여정을 시작해보세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글을 읽어 주셔서 감사합니다! 🙏😊\n","ogImage":{"url":"/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png"},"coverImage":"/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png","tag":["Tech"],"readingTime":2},{"title":"잘 검토할 수 있는 풀 리퀘스트를 만드는 방법","description":"","date":"2024-06-19 10:51","slug":"2024-06-19-HowICreateEasy-to-ReviewPullRequests","content":"\n## 생산성 | 프로그래밍 | 혁신\n\n![이미지](/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png)\n\n리뷰하기 쉬운 풀 리퀘스트(Pull Requests)를 작성하면 머지 프로세스가 빨라집니다. 머지 속도를 높이면 비즈니스 진행 속도와 제품 품질 향상 속도가 빨라집니다.\n\n그러므로, 리뷰하기 쉬운 풀 리퀘스트를 만드는 것이 매우 중요하다고 생각합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1. 변경된 파일이 너무 많습니까?\n\n풀 리퀘스트를 생성하기 전 (또는 구현하기 전) 확인해야 할 사항 중 하나는 작업의 세분성입니다. 작업의 세분성이 너무 크면 한 번의 풀 리퀘스트에서 변경된 파일의 수가 증가하여 리뷰어의 작업 부담이 커집니다. 변경된 파일의 수가 10개를 초과하면 해당 기능을 분할할 수 있는지 다시 고려하게 됩니다.\n\n하나의 기능을 모두 한 번에 풀 리퀘스트에 들어가게 하기보다는 작업을 분할하고 개별적으로 릴리스할 수 있는 단위로 풀 리퀘스트를 그룹화하는 것이 리뷰어의 작업 부담을 줄일 수 있습니다. 따라서 작업을 세분화하여 리뷰하기 쉬운 풀 리퀘스트를 생성하는 것이 중요하다고 생각합니다.\n\n## 2. 요약 섹션 강화하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가장 중요한 것은 풀 리퀘스트 요약 섹션을 개선하는 것이라고 생각해요. 리뷰에 필요한 모든 정보를 요약 섹션에 모아두는 걸 염두에 두고 있어요.\n\n일부 내용은 디자인 제안서 링크와 같은 것들이 명세를 요약한 계획 문서와 중복되지만, 풀 리퀘스트의 요약 섹션에 요약함으로써 전환을 쉽게하고 리뷰 시간을 줄일 수 있다고 생각해요. 구체적으로는 다음 내용을 포함하고 있어요.\n\n- 기능이 필요한 배경\n- 작업 세부 내용\n- 작동 확인된 항목\n- 구현 영향 범위\n- 구현하는 동안 고민했던 포인트\n- 스크린샷 (디자인 변경이 있는 경우)\n- 다양한 링크\n- 작업 티켓 링크\n- 계획 문서 링크\n- 명세를 논의하는 채팅이 있다면 링크 제공\n- Figma와 같은 디자인 아이디어 링크\n\n또한 팀 내에서 템플릿을 만들고 해당 항목에 따라 만드는 것도 중요하다고 생각해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3. 리뷰 요청하기 전 자가 검토\n\n리뷰 요청을 하기 전에 자가 검토를 하는 것이 중요합니다. 요약 섹션이 이해하기 쉬운지, 팀의 코딩 규칙을 위반하는 부분이 있는지, 영향 범위 내의 빠뜨린 부분이 있는지 다시 한번 확인할 것입니다.\n\n자가 검토 항목을 준비하고 이전 리뷰에서 받았던 동일한 코멘트를 받지 않도록 주의하고 있습니다. 리뷰를 요청하기 전에 자가 검토를 실시함으로써 구현 중에 보지 못했던 실수를 알 수 있고 더 나은 구현 방법을 발견할 수 있습니다.\n\n자가 검토를 실시함으로써 리뷰를 요청하기 전 리드 타임은 조금 더 길어지지만 그 결과로 리뷰어의 부담이 줄어들고 리뷰해야 할 영역에 집중할 수 있습니다. 우리는 자가 검토를 중요시합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 자기평가 항목 중 일부를 소개하고 싶어요. 이것은 어떤 사람들은 너무 자명해서 확인할 필요가 없다고 생각할 수 있는 항목이라고 생각해요. 그러나 두려움이나 긴장 상태일 때는 이런 중요한 항목도 놓치기 쉬우니, 리뷰를 제출하기 전에 이 항목들을 한 번 확인해요.\n\n## 코드 확인\n\n- 라우팅 추가 부분은 ABC 순서로 정리되어 있나요?\n- 스키마 파일에 추가된 열은 응집력을 고려하여 정렬되었나요?\n- 업데이트나 저장과 같은 레코드 저장 메서드는 save!나 update!와 같은 예외를 일으키는 방식으로 사용되었나요?\n- N + 1 문제가 있나요?\n\n## 코드 이외의 확인할 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 파일 변경 사항이 너무 많나요? 10개 이상의 파일이 있는 경우 주의하세요.\n- 풀 리퀘스트를 생성할 때 자신을 할당했나요?\n- 중요한 디자인 변경 사항이 포함된 작업의 경우, 스마트폰 또는 PC 화면뿐만 아니라 태블릿 화면에서도 표시를 확인했나요? (화면 캡처도 함께 첨부해야 합니다)\n\n## 개요\n\n이번에는 '리뷰하기 쉬운 풀 리퀘스트를 제출하는 방법'이라는 제목의 기사를 작성했습니다. 작업의 세분화, 요약 및 자가 검토는 특별한 일이 아니며, 모두 당연한 것으로 여겨질 수 있습니다.\n\n그러나 저는 보통의 일을 철저히 하는 것이 중요하다고 믿습니다. 비즈니스 성장 속도를 높이기 위해, 계속해서 리뷰하기 쉬운 풀 리퀘스트를 작성할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 스택아데믹\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 응원하고 팔로우해 주시면 감사하겠습니다! 👏\n- 저희를 팔로우해 주세요! X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 만나보세요: In Plain English | CoFeed | Venture\n","ogImage":{"url":"/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png"},"coverImage":"/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png","tag":["Tech"],"readingTime":4},{"title":"현실 대면이 가상보다 더 나은 이유를 깨달은 방법","description":"","date":"2024-06-19 10:51","slug":"2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual","content":"\n## 나의 시선을 바꾼 사무실 하루\n\n오늘 사무실에서 생산적인 하루를 보냈습니다.\n\n마이크로소프트(Microsoft) 인도는 하이브리드 근무 모델을 따르고 있습니다. 제 팀에서는 저는 새로 온 보드 단계에 있기 때문에 필요할 때 사무실에 오는 유연성이 주어집니다.\n\n제 프로젝트가 변경되어 5월 첫 주에 이 팀에 합류했습니다. 지난 한 달 동안 사무실에는 몇 차례만 갔습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 그런 날 중 하나였어요.\n\n온보딩 프로세스를 돕기 위해 친구가 지정되었어요.\n\n일반적으로 배정된 문서와 위키에서 많은 질문이 생기지만, 가끔 사무실을 방문하는 빈도가 낮기 때문에 필요한 질문만 가상으로 할 수밖에 없어요.\n\n개인적인 이유로 사무실을 자주 방문하지 않게 되었어요. 다른 블로그 포스트 주제가 되겠네요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 오늘 사무실에 있어서 더 많은 질문을 할 기회가 있었어요.\n\n가상 회의는 시간에 제약을 받을 때가 많지만 직접 만나는 회의는 더 유연하고 매력적인 편입니다. 보통 예정된 시간을 넘어가는 경우가 많죠. 왜냐하면 너무 많이 관여하게 되어서 그렇습니다.\n\n우리는 많은 질문과 후속 질문을 하며 좋은 토론을 진행했어요.\n\n또한 몇 가지 기능 제안도 했어요. 제 친구는 몇 가지 구현할 수 없는 이유를 설명해주었지만, 제 아이디어 중 하나를 좋아했고 그것을 우리 매니저에게 논의할 것이라고 말했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나가려던 순간, 이 프로젝트에서 처음으로 중요한 업무를 맡게 되었는데, 다음에 할 일을 기대하고 있어요.\n\n직접 만나서 하는 미팅이 생산적일 수 있는 이유를 좋아해요. 그 덕분에 더 많이 배우고, 더 나은 상호작용과 깊은 이해를 할 수 있거든요.\n\n오늘 사무실에서 생산적인 하루를 보냈고, 직접적인 대화가 원격 대화보다 더 잘 통한다는 것을 깨달았어요.\n\n그리고 사무실 삼시세끼 중 커피도 즐겁게 마시고, 점심으로 맛있는 채식 샐러드도 먹었어요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기술적인 토론 이외에도, 나는 주변을 돌아다니며 점심 시간에 팀원들과 수다 떨었고, 화장실에서 거울 셀카 몇 장을 찍기도 했어.\n\n이 외에 무엇이 더 필요했을까? 사무실 벤딩 머신에서 간식을 가져왔어. 단지 이 정도로만! 😋\n\n![이미지](/assets/img/2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual_0.png)\n\n완벽한 하루였어!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신은 WFO와 WFH 중 어떤 것을 선호하시나요?\n근무 시간 사이의 짧은 휴식 시간에는 무엇을 하시나요?\n\n읽어 주셔서 감사합니다.\n\n만약 이 내용을 좋아하셨다면, 50번 클랩을 눌러 주세요! 😊\n저자의 업데이트를 놓치지 않으려면 여기에서 구독해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual_0.png"},"coverImage":"/assets/img/2024-06-19-HowIRealisedIn-PersonisBetterthanVirtual_0.png","tag":["Tech"],"readingTime":3},{"title":"데이터 과학이 죽었을까요 반박하기","description":"","date":"2024-06-19 10:49","slug":"2024-06-19-IsDataSciencedeadTheRebuke","content":"\n## EDITOR’S PICK | AI \u0026 DATA SCIENCE | DEEP DIVES\n\n![Is Data Science Dead?](/assets/img/2024-06-19-IsDataSciencedeadTheRebuke_0.png)\n\n내 이전 기사 \"데이터 과학은 죽었을까?\"는 상당한 파장을 일으켰어요.\n\n제목은 도발적이었지만, 많은 데이터 과학자들의 머릿속에 이 질문이 떠오르고 있습니다. 그것을 다루는 가치가 있는 주제였습니다. 이 기사는 꽤 많은 댓글과 반응을 유발했죠. 댓글의 성격을 요약해보라면 다음과 같은 주제가 나오겠네요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터 과학은 코딩 이상입니다.\n  대부분의 의견은 데이터 과학이 코드 작성 뿐만 아니라, 실제로 데이터 과학자 작업의 5~10%를 차지한다는 것입니다. 데이비드 플러머가 말한대로 \"데이터 과학자 작업의 나머지 부분은 해결해야 할 문제를 정의하고, 문제를 해결할 적절한 방법론을 찾아내고, 고수준의 솔루션 설계를 만들고 그것을 구성 요소로 분해하며, 데이터를 수집하고 보증하고, 약간의 코딩, 불확실성 추정, 검증 및 검증이 차지한다.”\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제로, 데이터 과학은 코딩에 그치지 않습니다. 성공적인 프로젝트를 위해 지식, 디자인, 분석 및 커뮤니케이션 기술이 필요합니다. 누구도 의심하지 않겠지만, AI가 소개된 후에는 명백해졌습니다. AI가 이 수용 프로세스를 가속화시켰는지, 아니면 모두에게 항상 명백했던 것인지 논란이 있을 수 있겠지만, 내 의견은 AI가 Python 코딩이 데이터 과학자가 하는 유일한 일이 아님을 명확히 보여 주었다고 생각합니다.\n\n제 동료 중 한 분이 말하는 대로, 데이터 과학은 이제 \"더 많은 사고, 덜 만지작거림\"(코딩)을 요구합니다. 데이터 과학자들은 실제로 데이터가 다양한 소스를 통해 어떻게 흐르고 변환 작업 및 분석 모듈을 거쳐 데이터를 다시 기록하거나 보고서를 내보내거나 모델을 배포할지에 집중해야 합니다.\n\n# 취업 시장은 어떻게 변화할까요?\n\n그렇다면, 데이터 과학자에게 남아 있는 일은 무엇인가요? 이것이 취업 시장에 영향을 줄까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAI가 작업을 빠르게 만들어 줄 것이지만, 결과는 검증되어야 합니다. 잘못된 AI 생성 결과의 제시는 흔히 경험하는 일입니다. 현재 방법론과 라이브러리가 AI 출력물을 이중 확인하기 위해 개발 중에 있습니다. 그러나 현재로서는, 출력물 확인과 결과 해석은 전문 데이터 과학자의 책임이라는 보편적인 느낌이 있습니다.\n\nAI 도입의 결과로 피어날 다른 분야는 데이터 엔지니어링입니다. AI 모델은 많은 양의 데이터를 필요로 합니다 - 조직화되고 구조화되며 깨끗한 데이터입니다. 따라서 데이터 엔지니어링 기술은 이 새로운 직업 시장의 요구를 충족하기 위해 중요도를 높일 것입니다.\n\n세 번째로, 복합적인 데이터 과학 응용에 대한 언급이 있었습니다. 현재 AI는 쉬운 데이터 과학 응용 프로그램을 쉽게 재생산할 수 있지만, 보다 복잡한 솔루션의 모든 단계를 디자인할 수는 없습니다. AI는 향상될 것이며, 복잡성 수준을 좀 더 높일 것이지만, 새로운 복잡한 솔루션을 만들어내는 데 성공할 것이라고는 의심스럽습니다. 복잡한 데이터 과학 응용프로그램은 여전히 전문 데이터 과학자가 필요할 것입니다.\n\n요약하면, 데이터 전문가는 데이터 엔지니어링, 신속한 엔지니어링, 보안, 출력물 확인, 그리고 더 복잡한 응용프로그램 디자인을 위해 필요할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# AI는 미래를 대비할 수 있을까요?\n\n다른 의견 그룹은 AI와 미래에 관련된 것입니다. 현재 AI는 웹 상의 모든 지식과 다양한 스마트 사용자들이 여러 해 동안 올린 정보에 의존하고 있습니다. 그러나 이러한 지식이 변경된다면, AI가 적응하기까지 얼마나 시간이 걸릴까요? AI는 새로운 문서와 예제가 필요하며, 이러한 새로운 문서와 예제가 발표될 때까지 기다려야 합니다.\n\n현재 이 질문은 다양한 방안으로 다루고 있습니다 (예: RAG의 새로운 고급 품종과 세부 조정 기술은 매일 제안되어 모델에 사용자 지정 지식을 주입하고 있습니다). 그럼에도 불구하고 AI의 윤리적 문제와 AI 답변의 객관성에 대한 미해결된 문제들은 아직 해결되지 않았습니다.\n\n그렇다면, AI는 얼마나 미래를 대비할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데이터 과학자들은 미래를 대비할 수 있을까요?\n\n데이터 과학자들에게도 같은 질문이 제기되어야 합니다. 데이터 과학자들이 미래를 대비할 수 있을까요? 대학생들이 데이터 과학 수업에서 배우는 것이 이 새로운 AI 트렌드에서 충분히 활용하고 통제할 수 있을 정도인가요?\n\n일부 응답자는 AI에 프롬프트를 제공하는 것만으로는 데이터 과학의 기초를 배우지 않을 것이라고 한탄했습니다. 그렇다면 그들이 어떻게 데이터 과학 프로세스를 통제할 것을 기대할 수 있을까요?\n\n이는 타당한 질문입니다. 하지만 학생들과 주니어들의 적응 능력을 과소평가하는 것일 수도 있습니다. 학생들과 협업할 때 지금도 개념적인 실수가 많이 있습니다. 그러나 이러한 실수를 바로 잡음으로써 새로운 지식이 생성되고 습득되고 있습니다. 데이터 과학 수업의 기초를 잘 가르침으로써 AI가 존재하는 상황에서도 적절한 교육을 통해 훌륭한 훈련이 가능할 것이라고 확신합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 오픈 소스로 경쟁 우위 확보하기\n\n이번에 발견한 이 노트는 매우 통찰력이 있었어요. 댓글에서는 오픈 소스 전략이 AI 모델의 성공에 중심적인 역할을 한다고 강조했어요.\n\n이전에는 오픈 소스 코드였고, 지금은 오픈 소스 모델이 최신 알고리즘에 접근하고 개발 속도를 높이는 면에서 다른 전략과 비교했을 때 경쟁 우위를 가지고 있는 것 같아요.\n\n# 감사합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 글에 생생한 통찰과 지식 있는 댓글, 흥미로운 관찰을 제공해주신 모든 독자분들께 마지막으로 감사의 말씀을 전하고 싶습니다. 주제에 대해 배우고 깊이 생각해보며, 경우에 따라서는 제 생각을 다듬는 기회가 되었습니다.\n\n전체 글 \"데이터 과학이 죽었을까?\"와 그 댓글들은 Medium 저널 \"데이터 과학을 위한 로 코드(Low Code for Data Science)\"에서 확인하실 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-IsDataSciencedeadTheRebuke_0.png"},"coverImage":"/assets/img/2024-06-19-IsDataSciencedeadTheRebuke_0.png","tag":["Tech"],"readingTime":5}],"page":"39","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"39"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>