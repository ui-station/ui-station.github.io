<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/40" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/40" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기" href="/post/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="접근성 테스트에서 코틀린 Compose - 이름, 역할, 값" href="/post/2024-06-19-AccessibilityTestsinComposeNameRoleValue"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="접근성 테스트에서 코틀린 Compose - 이름, 역할, 값" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="접근성 테스트에서 코틀린 Compose - 이름, 역할, 값" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">접근성 테스트에서 코틀린 Compose - 이름, 역할, 값</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다" href="/post/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법" href="/post/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="테라폼 인터뷰 질문들" href="/post/2024-06-19-TerraformInterviewQuestions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="테라폼 인터뷰 질문들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-TerraformInterviewQuestions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="테라폼 인터뷰 질문들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">테라폼 인터뷰 질문들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="테라폼 안전하고 고가용성이 높으며 고장 허용성이 있는 클라우드 인프라 배포하기" href="/post/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="테라폼 안전하고 고가용성이 높으며 고장 허용성이 있는 클라우드 인프라 배포하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="테라폼 안전하고 고가용성이 높으며 고장 허용성이 있는 클라우드 인프라 배포하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">테라폼 안전하고 고가용성이 높으며 고장 허용성이 있는 클라우드 인프라 배포하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="OCI에서 Active Directory 게임을 실행하는 방법  1부" href="/post/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="OCI에서 Active Directory 게임을 실행하는 방법  1부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="OCI에서 Active Directory 게임을 실행하는 방법  1부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">OCI에서 Active Directory 게임을 실행하는 방법  1부</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="의존성 관리자 Dependabot GitHub 및 Terraform 버전 관리" href="/post/2024-06-19-DependabotGitHubandTerraformversionsmanagement"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="의존성 관리자 Dependabot GitHub 및 Terraform 버전 관리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="의존성 관리자 Dependabot GitHub 및 Terraform 버전 관리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">의존성 관리자 Dependabot GitHub 및 Terraform 버전 관리</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Azure Storage Account에 개인 엔드포인트와 Terraform을 사용하여 컨테이너 문제 해결하는 방법" href="/post/2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Azure Storage Account에 개인 엔드포인트와 Terraform을 사용하여 컨테이너 문제 해결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Azure Storage Account에 개인 엔드포인트와 Terraform을 사용하여 컨테이너 문제 해결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Azure Storage Account에 개인 엔드포인트와 Terraform을 사용하여 컨테이너 문제 해결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년에 사용할 수 있는 가장 유용한 Terraform 도구들" href="/post/2024-06-19-MostUsefulTerraformToolstoUsein2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년에 사용할 수 있는 가장 유용한 Terraform 도구들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년에 사용할 수 있는 가장 유용한 Terraform 도구들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년에 사용할 수 있는 가장 유용한 Terraform 도구들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link posts_-active__YVJEi" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기","description":"","date":"2024-06-19 13:43","slug":"2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid","content":"\n![PDFViewer](/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png)\n\nPDF는 우리가 매일 사용하는 가장 일반적인 파일 형식 중 하나입니다. 그러나 Jetpack Compose에서 공식 PDF 뷰어가 아직 없습니다. 그렇다면 왜 만들지 않을까요?\n\n## 어떻게 가능한가요?\n\n우리의 계획 개요를 살펴봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- PDF 파일이 있는 원격 URL 또는 전화 저장소가 있습니다.\n- 하나씩 페이지를 보여줄 수 있습니다.\n- 페이지는 확대 및 이동할 수 있어야 합니다.\n- 서버 PDF를 로컬 캐시/저장소에 다운로드하고 저장해야 합니다.\n- PDF를 '페이지'를 나타내는 '비트맵' 목록으로 변환할 수 있습니다.\n- 그런 다음 간단히, 비트맵을 지원하는 이미지 컴포저블을 사용하여 세로로 페이지를 하나씩 모두 표시할 것입니다.\n\n## 단계 1: PDF 다운로드 및 저장\n\n이 시점에서 PDF의 URL만 있습니다. 이를 다운로드하는 기능을 만들어 보겠습니다.\n\n먼저 AndroidManifest.xml에 다음 권한을 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n\u003cuses-permission android:name=\"android.permission.INTERNET\" /\u003e\n\u003cuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /\u003e\n```\n\n우리는 HttpURLConnection 객체를 사용하여 연결을 설정하고 InputStream을 가져올 것입니다.\n\n```java\nval connection = URL(url).openConnection() as HttpURLConnection\nconnection.connect()\n```\n\n위의 코드들이 작동하여 PDF 파일을 가져올 것입니다. 작업이 완료되었고 필요한 Input stream을 얻었는지 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nif (connection.responseCode != HttpURLConnection.HTTP_OK) {\n    connection.disconnect()\n    return@withContext null\n}\n\nval inputStream = connection.inputStream\n```\n\n작업이 끝나면 꼭 연결을 끊어 주세요.\n\n```kotlin\nconnection.disconnect()\n```\n\n이제 다운로드 부분이 완료되었으니 사용자의 로컬 스토리지에 저장해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nfile = File.createTempFile(fileName, \".pdf\")\nval outputStream = FileOutputStream(file)\ninputStream.copyTo(outputStream)\noutputStream.close()\n```\n\n변경 후 전체 함수는 다음과 같습니다:\n\n```kotlin\nsuspend fun downloadAndGetFile(url: String, fileName: String): File? {\n    if (isFileExist(fileName)) return File(fileName) // 이 줄은 중복 파일 생성을 피하기 위해 중요합니다.\n    var connection: HttpURLConnection? = null\n    var file: File? = null\n    try {\n        withContext(Dispatchers.IO) {\n            connection = URL(url).openConnection() as HttpURLConnection\n            connection!!.connect()\n\n            if (connection!!.responseCode != HttpURLConnection.HTTP_OK) {\n                return@withContext null\n            }\n\n            val inputStream = connection!!.inputStream\n            file = File.createTempFile(fileName, \".pdf\")\n            val outputStream = FileOutputStream(file)\n            inputStream.copyTo(outputStream)\n            outputStream.close()\n        }\n    } catch (e: IOException) {\n        // UI에 응답을 전송합니다.\n    } finally {\n        connection?.disconnect()\n    }\n    return file\n}\n```\n\n```kotlin\nfun isFileExist(path: String): Boolean {\n    val file = File(path)\n    return file.exists()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2: 파일 객체를 List`Bitmap`으로 변환합니다.\n\n이 변환에는 PdfRenderer 클래스를 사용할 것입니다:\n\n```js\nPdfRenderer renderer = new PdfRenderer(ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY));\n```\n\n하지만 이것을 직접 사용하는 것은 Jetpack Compose에서 좋지 않고 많은 RAM을 소비할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 다음과 같이 사용할 것입니다:\n\n```js\nval rendererScope = rememberCoroutineScope()\nval mutex = remember { Mutex() }\nval renderer by produceState\u003cPdfRenderer?\u003e(null, file) {\n    rendererScope.launch(Dispatchers.IO) {\n        val input = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)\n        value = PdfRenderer(input)\n    }\n    awaitDispose {\n        val currentRenderer = value\n        rendererScope.launch(Dispatchers.IO) {\n            mutex.withLock {\n                currentRenderer?.close()\n            }\n        }\n    }\n}\n```\n\n이제 우리가 만든 \"PDFRenderer\" 객체인 \"renderer\"를 사용하여 모든 페이지를 가져와 비트맵 객체에 렌더링할 것입니다.\n\n```js\nrenderer?.let {\n    it.openPage(index).use { page -\u003e\n        page.render(destinationBitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 모든 페이지에 대한 비트맵을 가져올 수 있습니다. UI에서 모든 페이지에 표시할 시간입니다.\n\n## 단계 3: UI에 목록`비트맵` 표시 + 줌 및 이동 기능 추가:\n\nPDFViewer Composable의 전체 코드가 필요하면 이를 참조하십시오:\n\n여기서 설명이 시작됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- BoxWithConstraints를 사용하는 이유는 페이지의 높이와 너비를 정의하고 줌 및 이동을 위해 화면의 높이와 너비가 필요하기 때문입니다.\n\n```js\n            val width = with(LocalDensity.current) { maxWidth.toPx() }.toInt()\n            val height = (width * sqrt(2f)).toInt()\n            val pageCount by remember(renderer) { derivedStateOf { renderer?.pageCount ?: 0 } }//Used ahead\n\n            var scale by rememberSaveable {\n                mutableFloatStateOf(1f)\n            }\n            var offset by remember {\n                mutableStateOf(Offset.Zero)\n            }\n            val state = //Used for Zoom and Move\n                rememberTransformableState { zoomChange, panChange, rotationChange -\u003e\n                    scale = (scale * zoomChange).coerceIn(1f, 5f)\n\n                    val extraWidth = (scale - 1) * constraints.maxWidth\n                    val extraHeight = (scale - 1) * constraints.maxHeight\n\n                    val maxX = extraWidth / 2\n                    val maxY = extraHeight / 2\n\n                    offset = Offset(\n                        x = (offset.x + scale * panChange.x).coerceIn(-maxX, maxX),\n                        y = (offset.y + scale * panChange.y).coerceIn(-maxY, maxY),\n                    )\n                }\n```\n\nZoom 구현을 자세히 이해하려면 이 비디오를 시청하세요.\n\n2. 이 상태를 LazyColumn과 함께 간단히 사용하고 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n            LazyColumn(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .graphicsLayer {\n                        scaleX = scale\n                        scaleY = scale\n                        translationX = offset.x\n                        translationX = offset.y\n                    }\n                    .transformable(state)\n```\n\n3. 호출할 때 이미 PDF 파일을 다운로드하고 저장했습니다.\n\n```kotlin\nLaunchedEffect(key1 = Unit) {\n        file = async { downloadAndGetFile(url, fileName) }.await()\n    }\n```\n\n4. \"cacheKey\"로부터 Bitmap 객체를 만들어야 합니다. 이미지도 캐시에 저장될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nval cacheKey = MemoryCache.Key(\"${file!!.name}-$index\")\nval cacheValue: Bitmap? = imageLoader.memoryCache?.get(cacheKey)?.bitmap\nvar bitmap: Bitmap? by remember { mutableStateOf(cacheValue) }\n```\n\n5. 이후에는 각 페이지의 비트맵을 가져와 Coil ImageRequest 객체로 표시합니다.\n\n```kotlin\nval request = ImageRequest.Builder(context)\n    .size(width, height)\n    .memoryCacheKey(cacheKey)\n    .data(bitmap)\n    .build()\n\nImage(\n    modifier = Modifier\n        .background(Color.Transparent)\n        .border(1.dp, MaterialTheme.colors.background)\n//        .aspectRatio(1f / sqrt(2f))\n        .fillMaxSize(),\n    contentScale = ContentScale.Fit,\n    painter = rememberAsyncImagePainter(request),\n    contentDescription = \"Page ${index + 1} of $pageCount\"\n)\n```\n\n나머지 부분은 상당히 직관적이고 이해하기 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 새로운 것을 배웠다면, 좋다면 팔로우 버튼을 눌러 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png","tag":["Tech"],"readingTime":10},{"title":"접근성 테스트에서 코틀린 Compose - 이름, 역할, 값","description":"","date":"2024-06-19 13:42","slug":"2024-06-19-AccessibilityTestsinComposeNameRoleValue","content":"\n\u003cimg src=\"/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png\" /\u003e\n\n앱을 위한 테스트를 작성할 때는 접근성 관련 사항을 테스트하는 것도 고려해야 합니다. 이해합니다. 어디서부터 시작해야 할지 알기 어려울 수 있죠. 그래서 저는 어떻게 일부 접근성 측면을 테스트할지에 대해 이 블로그 글을 쓰기로 결정했습니다.\n\n이 글에서는 클릭 가능, 선택 가능, 토글 가능한 수정자를 사용하여 구성된 세 가지 사용자 정의 구성 요소에 대한 일부 접근성 관련 테스트를 추가할 것입니다. 이러한 구성 요소는 제가 썼던 블로그 글에서 만들어진 것입니다: Jetpack Compose에서 수정자를 활용한 Android 접근성 향상.\n\n# 무엇을 테스트하는 중인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 작성하는 테스트는 컴포넌트에 이름, 역할 및 값이 있는지 확인합니다. 하지만 이 그룹은 어디에서 왔을까요? 배경은 웹 콘텐츠 접근성 가이드라인(WCAG)이 \"이름, 역할, 값\"이라는 성공 기준을 가지고 있어요. 이는 모든 요소가 프로그래밍 방식으로 결정 가능한 이름과 역할을 가지고 있음을 보장합니다. 또한 사용자가 변경할 수 있는 상태, 속성 및 값은 프로그래밍 방식으로 변경 가능해야 합니다.\n\n그리고 지금, \"웹\"이라는 것을 언급하는 이유가 궁금하다면, WCAG은 이름과는 상관없이 모바일 앱의 최소 접근성 수준을 결정하는 데도 사용됩니다.\n\n여기서 '이름'은 이용자에게접근성을 제공하는 이름을 의미합니다. 요소의 텍스트 표현이 될 수 있습니다. 예를들어 버튼의 텍스트, 아이콘 버튼의 내용 설명, 스위치의 레이블 등이 있습니다. 스크린 리더를 사용하는 사람이 듣는 내용입니다. 음성 액세스 사용자는 대화형 요소를 활성화할 때 사용합니다.\n\n그리고 '역할'은 요소의 역할을 말합니다. 예를들어 버튼일 수 있습니다 - 이것은 사용자에게 '여기 버튼이 있어요, 그리고 이 버튼은 버튼처럼 행동해야 해'라고 알려줍니다. 역할은 작동해야 하는 방식에 대한 약속입니다. 따라서 역할을 추가한다면 올바른 상호작용도 추가해야 합니다. 그러나 역할은 웹보다는 Android에서 덜 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n값은 요소의 상태, 속성 또는 값에 대한 참조를 할 수 있습니다. 각 요소마다 정확한 의미가 다릅니다. 예를 들어, 체크박스의 경우 값은 체크 여부를 알려주고, 아코디언의 경우 상태가 열렸는지 닫혔는지를 나타냅니다.\n\n다음 섹션에서는 소개 부분에서 언급된 몇 가지 사용자 지정 컴포넌트에 대한 \"이름, 역할, 값\" 성공 기준을 테스트하는 구체적인 예제를 살펴보겠습니다.\n\n# 테스트 작성, 예시\n\n처음에 언급한 대로, 이러한 테스트는 이전에 작성한 블로그 게시물을 위한 컴포넌트에 대해 작성된 것입니다. 세 가지 컴포넌트를 어떻게 테스트할지 살펴보겠습니다: 스위치, 라디오 버튼 그룹 및 클릭 가능한 행.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n블로그 게시물의 구성 요소가 예제를 위해 단순화되었기 때문에 이 테스트들도 간소화되었습니다. 실제 프로덕션 코드에서는 일반적으로 테스트되는 구성 요소를 찾는 더 정교한 전략이 있습니다.\n\n## Toggleable\n\n테스트하는 첫 번째 구성 요소는 아래 사진에 나와있는 스위치와 같습니다:\n\n![Toggleable Component](/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 세 가지를 테스트하고 싶어합니다: 먼저, 컴포넌트에 접근 가능한 이름(따라서, 스위치의 레이블)이 있는지 확인하고 싶습니다. 둘째, 역할이 올바른지-토글 가능한 컴포넌트여야 합니다. 셋째, 스위치를 토글한 후에도 값이 올바른지 확인하고 싶습니다, 따라서 스위치가 켜져 있는지 꺼져 있는지에 상관없이.\n\n테스트를 작성해봅시다:\n\n첫째, 테스트에는 설정이 필요하므로, composeTestRule 및 콘텐츠 설정과 같은 것들이 필요합니다. 그런 다음 테스트 가능한 컴포넌트를 test 태그인 accessible-toggle로 가져옵니다. 마지막으로, 이름, 역할, 값에 대한 테스트가 있습니다.\n\n이름을 확인하는 테스트는 간단합니다: 요소의 텍스트 내용이 레이블의 단어와 같은지 확인하고 싶습니다. assertTextEquals를 사용하여 이를 확인할 수 있습니다. 역할을 테스트하기 위해 유용한 assert 함수인 assertIsToggleable을 사용할 수 있습니다. 마지막으로 값(즉, 확인된 상태)이 올바른지 확인하기 위해, assertIsOff 및 assertIsOn과 같은 유틸리티 함수를 사용할 수 있으며, 상태를 토글하기 위해 performClick을 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 선택 가능한 요소\n\n다음으로 테스트하는 컴포넌트는 라디오 버튼 그룹입니다. 사진에서 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_2.png)\n\n이 컴포넌트에서 우리는 두 옵션이 모두 이름(즉, \"옵션 A\"와 \"옵션 B\" 레이블), 선택 가능한 역할 및 선택된 항목의 값을 가지고 있는지 확인합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 구성 요소의 테스트는 다음과 같습니다:\n\n구조는 이전 테스트와 매우 유사합니다. 먼저 설정하고, 그런 다음 요소를 가져 와서 이름, 역할 및 값에 대해 단언합니다. 요소의 레이블(즉, 이름)을 확인하기 위해 동일한 assertTextEquals를 사용합니다. toggleable과 마찬가지로, 선택 가능한 요소의 역할과 값을 확인하는 함수가 있습니다: isSelectable(), assertIsSelected(), 그리고 .assertIsNotSelected().\n\n## 클릭 가능\n\n이 블로그 글의 마지막 맞춤형 구성 요소는 아이템을 즐겨찾기하는 데 사용할 수 있는 맞춤형 버튼입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Accessibility test](/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_3.png)\n\n우리는 아이템에 이름(즉, \"이 항목 즐겨찾기\")과 버튼 역할, 그리고 해당 항목이 즐겨찾기되었는지 여부를 알리는 상태가 있는지 확인하고 싶습니다.\n\n다음 테스트는 다음을 보장합니다:\n\n다시 말하지만, 이름의 설정과 확인은 다른 두 구성 요소와 유사합니다. 그러나 구성 요소가 버튼 역할을 갖고 있는지 확인하려면 SemanticsMatcher를 사용해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`SemanticsMatcher`은 시맨틱 노드를 매칭하기 위한 래퍼입니다. 요소의 시맨틱 속성 Role이 Role.Button과 일치하는지 확인하고 싶습니다. 이를 위해서 SemanticMatcher로 우리의 체크를 래핑하고, element에서 element.config.getOrNull(SemanticsProperties.Role)을 사용해 element의 SemanticProperties.Role을 가져와 해당 값이 일치하는지 확인할 수 있습니다.\n\n이와 같은 패턴은 element의 state description을 테스트하는 데에도 동일하게 적용됩니다. 코드 중복을 피하기 위해 element의 state description을 확인하는 데 사용되는 extension function인 `assertStateDescription`을 만들었습니다.\n\n# 마무리\n\n이 블로그 포스트에서는 WCAG 성공 기준 4.1.2: Name, Role, Value에 대한 접근성 테스트 작성에 대해 논의했습니다. 이러한 테스트는 모바일 접근성에 항상 적용되는 것은 아니지만, 본 블로그 포스트에서는 접근성 테스트 작성 방법에 대한 예시를 제공하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안드로이드에서 접근성에 대한 테스트를 작성해 보았나요? 공유해 주시면 감사하겠어요!\n\n# 블로그 글 링크\n\n- Jetpack Compose에서 Modifier를 사용하여 안드로이드 접근성 향상하기\n- 이름, 역할, 값\n- SemanticsMatcher\n","ogImage":{"url":"/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png"},"coverImage":"/assets/img/2024-06-19-AccessibilityTestsinComposeNameRoleValue_0.png","tag":["Tech"],"readingTime":7},{"title":"제가 Zomato 앱을 역공학으로 분석해 나만의 주문 추적 알림 시스템을 만들었던 과정입니다","description":"","date":"2024-06-19 13:40","slug":"2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem","content":"\n(고지: 저는 독립 개발자/개인이며 Zomato 엔지니어 팀에서 일하고 있지 않습니다)\n\n최종 제품이 어떻게 작동하는지 확인하려면 여기를 클릭하세요: [https://youtu.be/E89Etnvq6rY](https://youtu.be/E89Etnvq6rY)\n\n코드를 확인하려면 여기를 클릭하세요: [https://github.com/oddlyspaced/zomato-notification/tree/main](https://github.com/oddlyspaced/zomato-notification/tree/main)\n\n---\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nZomato Android 앱을 매일 사용하는 사용자이자 앱 엔지니어로서, 나는 이 앱의 디자인과 어디에서나 음식 주문이 가능하다는 편의성을 사랑하게 되었습니다. 그러나 항상 음식 배달 상태를 확인하기 위해 앱을 열어야 한다는 점이 불편하다고 느꼈습니다. 앱은 훌륭한 주문 추적 화면을 제공하지만, iOS 버전의 Zomato 앱이 iOS 활동 인디케이터를 활용하여 제공하는 지속성과 쉬운 액세스를 제공하지 못한다는 점이 마음에 듭니다. 이에 영감을 받아 Zomato Android 앱을 역공학하여 주문 추적 경험을 향상시킬 수 있는 사용자 정의 솔루션을 구축하기로 결심했습니다. 이 글에서는 필요한 API 엔드포인트를 발견하고, 앱의 시스템 아키텍처를 설계하며, 반복적으로 Zomato 앱을 열 필요 없이 실시간 주문 추적 정보를 제공하는 지속적인 알림을 구현하는 과정을 공유하겠습니다.\n\n# 파트 1: 앱 트래픽 이해\n\n정보를 표시하는 방법을 이해하려면, 앱이 필요한 정보를 가져오는 방법을 파악해야 합니다. 앱과 서버 간의 네트워크 트래픽을 검사하는 것이 시작점으로 좋습니다. 이를 통해 앱으로 전송되는 정보에 대한 정확한 지식을 얻을 수 있습니다. 나중에 독립적으로 호출해야 하는 API 엔드포인트에 대한 정보를 제공해 줄 것입니다.\n\n이를 위해 다음 도구를 활용했습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- apktool\n- Charles Proxy\n- Android Emulator\n\n앱을 디버깅하기 위한 설정 과정은 간단합니다. 이 글에서는 다루지 않겠습니다.\n\n다음 글을 참고해주세요 :\n\n# Part 2: 앱 트래픽 분석\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n환경 설정이 완료되었으므로 이제 트래픽을 분석하고 요청 내용을 확인할 수 있습니다. 주문 내역을 가져오는 요청을 찾으려면 앱의 주문 내역 페이지로 이동하여 동시에 Charles의 활동을 확인합니다. 이 페이지에 접속할 때마다 호출되는 특정 엔드포인트가 있는 것으로 보입니다. 바로 이것입니다:\n\n```js\nhttps://api.zomato.com/gw/order/history/online_order\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png\" /\u003e\n\n이것에 대한 응답을 확인해 봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 샘플의 요약된 응답입니다. 전체 샘플 응답은 여기 있습니다.\n\nJSON 구조를 연구하면 결과 목록이 있고 레이아웃 구성 및 order_history_snippet_type_2 키가 있는 객체가 있음을 알 수 있습니다. order_history_snippet_type_2 객체에는 사용할 수 있는 정보가 포함되어 있습니다. click_action 객체에는 딥링크 문자열이 포함되어 있어 주문 ID를 추출하는 데 사용할 수 있습니다. 주문 ID는 다른 위치에도 있지만, 이것이 제 기준으로는 굉장히 간단한 장소로 보였습니다. 우리가 필요로 하는 다른 모든 정보가 포함된 top_container 및 bottom_container도 있습니다. 레스토랑 이름은 top_container의 title 객체 안에 있는 텍스트 항목에서 추출할 수 있습니다. 주문 ID는 딥링크에서 시작 태그를 대체하고 숫자를 유지하여 간단히 추출할 수 있습니다. 주문 상태는 top_container의 title 객체 안에 있는 텍스트 항목에서 추출할 수 있습니다. 주문 배달 시간은 bottom_container의 title 객체 안에 있는 텍스트 항목에서 추출할 수 있습니다.\n\n마찬가지로 주문을 배치하고 앱의 주문 상세 페이지에서 트래픽 활동을 분석하면 다음 API Endpoint가 반복적으로 호출됩니다:\n\n```js\nhttps://api.zomato.com/v2/order/crystal_v2\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 엔드포인트의 응답에는 많은 개인 정보가 포함되어 있기 때문에 샘플 응답을 공유할 수 없습니다. 그러나 참고로 응답에서 다음 태그들은 다음 정보를 제공합니다 :\n\n```js\nresponse -\u003e order_details -\u003e res_name = 음식점 이름\nresponse -\u003e order_details -\u003e tab_id = 주문 ID\nresponse -\u003e header_data -\u003e pill_data -\u003e left_data -\u003e title -\u003e text  = 예상 시간 (문자열) [예: 5분 후 도착 예정]\nresponse -\u003e header_data -\u003e subtitle2 -\u003e text = 텍스트 형식의 주문 상태 [예: 길을 가는 중, 곧 픽업될 예정 등]\nresponse -\u003e header_data -\u003e pill_data -\u003e right_data -\u003e title -\u003e text = 주문 예상 상태 [예: 제 시간, 지연됨]\n```\n\n# Part 3: 알림 디자인\n\n데이터 가져오기 부분이 해결되었으므로, iOS의 활동 표시기에서 영감을 받은 알림 시스템을 구축하고 싶습니다. 이는 Zomato가 iOS 앱에서 활동 표시 서비스를 활용하는 방식입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Figma 디자인으로 만든 Android 알림의 유사한 레이아웃입니다:\n\n![Android 알림 디자인](/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_2.png)\n\niOS 활동 지시기와 마찬가지로 앱에서 생성된 알림은 레스토랑 이름, 현재 주문 상태의 텍스트 표현, 배송 시간 예상 상태 및 실제 배송 전달 시간 예상을 표시합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 파트 3: 정보 흐름 처리 및 알림 관리\n\n![이미지](/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_3.png)\n\n정기적으로 업데이트할 수 있는 알림을 갖기 위해 Foreground Service를 활용하고 주문 세부 정보를 계속 가져오도록 하는 기능이 필요합니다. 이 서비스를 \"OrderTrackService\"라고 부르겠습니다. 이 서비스의 주요 목적은 주문 ID를 수락하고 crystal_v2 API를 호출하여 주문 상태 정보를 가져온 다음 해당 정보를 알림에 표시하는 것입니다. 이 작업은 30초 간격으로 반복되며 주문 상태가 \"배달 완료\"가 될 때까지 실행됩니다.\n\n알림을 처리하기 위해 주문 정보를 표시하는 사용자 정의 레이아웃을 만들 것입니다. 알림은 특정 ID로 표시됩니다. Android에서 동일한 ID로 알림을 다시 보내면 알림 패널에 이미 표시된 기존 알림이 자동으로 업데이트됩니다. 따라서 우리는 주문 정보를 가져와 기존 ID를 사용하여 알림을 다시 만들고 표시하는 이 논리를 활용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스를 제어하고 시작하기 위해서는 Activity도 필요합니다. 이 Activity의 주요 목적은 주문 내역을 가져와 목록으로 표시하는 것입니다. 이 목록을 통해 어떤 주문 ID를 OrderTrackService에 전달하여 알림을 처리할지 선택할 수 있습니다.\n\n# 파트 4: 모두 함께 사용하기\n\n디자인과 시스템이 명확하게 정해지면 이제 아이디어를 현실로 구현할 때입니다. 먼저 Jetpack Compose를 사용하여 MainActivity를 구현하여 시작했습니다. 메인 액티비티에는 세 개의 버튼이 있습니다. 첫 번째 버튼은 앱에 POST_NOTIFICATION 권한을 요청하는 기능을 합니다. 두 번째 버튼은 Foreground 서비스를 시작하는 기능을 하며, 마지막 버튼은 주문 내역을 가져오는 데 사용됩니다. \"주문 가져오기\" 버튼을 탭하면 앱은 online_order API를 호출하고 주문 상태가 \"배달완료\"가 아닌 결과를 필터링합니다. 필터링된 주문은 현재 활성화된 주문입니다.\n\nAPI 엔드포인트를 호출하기 위해 retrofit 라이브러리를 구현하고 필요한 헤더와 함께 적절한 인터페이스를 만들었습니다. 코드 품질을 보장하기 위해 모든 것을 MVVM 패턴을 사용하여 구현했고 Retrofit 인스턴스를 처리하기 쉽도록 의존성 주입을 위해 Hilt를 사용했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOrderTrackService 클래스는 Service 클래스의 확장입니다. 우리는 여기서 알림 로직을 처리할 것입니다. MainActivity와 OrderTrackService 간의 통신은 Broadcast Intents를 통해 설정됩니다. MainActivity에 표시된 목록의 각 주문에 대응하는 버튼은 주문 ID가 Intent의 데이터 번들 일부로 포함된 Broadcast Intent를 보냅니다. 이 Broadcast Intent를 받으면 Foreground Service가 작동하여 crystal_v2 API를 호출하여 지정된 주문 ID에 대한 주문 세부 정보를 가져옵니다. 그런 다음 정보를 표시하는 알림을 생성합니다. 가져오기 및 게시 로직은 Kotlin Flow 내에서 작동하도록 제작되어 여러 알림을 독립적으로 처리할 수 있도록 지원하며 필요한 경우 반복적인 Flow를 시작합니다. Flow를 사용하면 원하는대로 작업을 일시 중지/반복할 수 있으므로 동일한 작업을 원하는 지연 시간(우리의 경우 여기서는 30초)으로 반복할 수도 있습니다.\n\n\n\u003cimg src=\"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_4.png\" /\u003e\n\n\n# 최종:\n\n이 사용자 지정 앱은 내 시간을 절약할 뿐만 아니라 주문 상태를 효율적으로 파악하는 더 나은 방법을 제공합니다. 개발 이후로 앱을 여러 번 들여다보지 않고도 주문 상태를 손쉽게 추적할 수 있어서 매우 편리합니다. 본문이 역공학 및 네트워크 호출의 구현 과정에 대한 통찰을 제공했기를 바랍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 프로젝트의 완전한 소스 코드를 GitHub 리포지토리에서 확인할 수 있어요:\n\n[https://github.com/oddlyspaced/zomato-notification/tree/main](https://github.com/oddlyspaced/zomato-notification/tree/main)\n\n자유롭게 탐색하고 실험하며, 더 많은 향상을 위한 아이디어가 있으면 프로젝트에 기여해주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png"},"coverImage":"/assets/img/2024-06-19-HowIreverseengineeredtheZomatoapptobuildmyownOrderTrackingnotificationsystem_0.png","tag":["Tech"],"readingTime":9},{"title":"다중 환경에서 Terraform을 사용하여 AWS Lambda 함수를 배포하는 방법","description":"","date":"2024-06-19 13:38","slug":"2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform","content":"\n## 여러 환경에 걸쳐 AWS Lambda 함수를 배포하는 방법 배우기 — Hashicorp Terraform을 통해 가능하게 하기\n\n![이미지](/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png)\n\nAWS Lambda는 서버를 프로비저닝하거나 관리하지 않고 코드를 실행할 수 있는 서버리스 컴퓨팅 서비스로, 배포 프로세스를 간소화하고 비즈니스가 자동으로 확장할 수 있게 합니다. 그러나 특히 여러 환경에 걸쳐 Lambda 함수를 배포하는 것은 개발 라이프사이클을 복잡하게 만들 수 있는 특정한 도전을 야기합니다.\n\n# Lambda 배포 도전\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS 람다 함수를 배포하는 가장 기본적인 방법은 주로 AWS 관리 콘솔을 통해 zip 파일을 수동으로 업로드하거나 AWS CLI 명령을 사용하는 것입니다. 그러나 이 방법은 몇 가지 어려움을 야기할 수 있습니다:\n\n- 일관성 문제: 수동 프로세스는 실수하기 쉽습니다. 개발, 테스트 및 프로덕션 환경을 거치는 반복 배포가 신중하게 관리되지 않으면 일관성 문제를 야기할 수 있습니다.\n- 확장성 제한: 애플리케이션이 성장함에 따라 여러 함수를 수동으로 관리하는 것은 다루기 어렵고 실수를 유발할 수 있습니다.\n- 구성 관리: 다른 환경(예: 개발, 스테이징, 프로덕션)에 대한 다른 구성을 수동으로 처리하는 것은 복잡하며 구성 드리프트를 야기할 수 있습니다.\n- 버전 관리: 수동 배포는 기본적으로 버전 관리를 지원하지 않으며, 변경 사항을 추적하거나 이전 버전의 함수로 롤백하는 것이 어려울 수 있습니다.\n\n# Terraform을 활용하여 다중 환경 도전을 해결하기\n\n개발, 스테이징, 프로덕션과 같은 여러 환경에 걸쳐 람다 함수를 배포하려면 구성 및 인프라를 일관되게 처리하는 전략이 필요합니다. 이것이 Terraform이 이러한 문제들에 대처하는 방법입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 인프라스트럭처를 코드로 정의함으로써 Terraform은 배포가 다양한 환경에서 반복 가능하고 일관성 있게 이루어지도록 합니다. 이는 \"내 컴퓨터에서는 작동한다\" 문제를 제거합니다.\n- 환경 분리: Terraform은 워크스페이스나 변수 파일을 활용하여 동일한 코드로 여러 환경을 관리할 수 있습니다. 각 환경은 Terraform의 상태 파일을 통해 구성을 관리함으로써 격리를 보장하고 교차 환경 오염의 위험을 최소화합니다.\n- 자동화된 배포: Terraform은 자원 생성, 수정 및 삭제 과정을 자동화하여 인간 에러 가능성을 줄이고 효율성을 높입니다.\n- 변경 관리와 버전 관리: Terraform을 사용하면 모든 변경 사항이 버전 관리되고 적용되기 전에 검토되어 수정 사항에 대한 감사 트레일을 제공하고 쉬운 롤백 매커니즘을 제공합니다.\n\n# Terraform을 활용한 실용적인 구현\n\n제공된 Terraform 코드는 Lambda 함수용 필요한 인프라를 설정하는 방법을 보여줍니다. IAM 역할, 정책, 그리고 Lambda 함수 자체를 구성하고 Terraform 변수를 사용하여 환경별 구성을 설정합니다.\nAWS Terraform 프로바이더에 익숙하지 않은 경우, Terraform을 AWS에 연결하는 방법을 이해하기 위해 해당 문서를 읽어보세요.\n\n1. IAM 역할 및 정책 설정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n람다 함수는 다른 AWS 리소스와 상호작용할 것입니다. 이를 위해 IAM 역할을 가정해야 합니다. 먼저 해당 역할을 만들어 봅시다.\n\n```js\n# 람다 함수가 가정할 IAM 역할을 정의합니다.\nresource \"aws_iam_role\" \"lambda_role\" {\n  name               = \"lambda_function_role\"\n  assume_role_policy = \u003c\u003cEOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": \"sts:AssumeRole\",\n      \"Principal\": {\n        \"Service\": \"lambda.amazonaws.com\"\n      },\n      \"Effect\": \"Allow\",\n      \"Sid\": \"\"\n    }\n  ]\n}\nEOF\n}\n```\n\n## 설명\n\n이 IAM 역할을 생성하고 해당 가정 역할 정책을 첨부함으로써, 람다 함수가 이 역할을 가정할 수 있게 합니다. 즉, 람다 함수는 이 역할과 관련된 권한을 사용하여 다른 AWS 리소스와 상호작용할 수 있습니다. 예를 들어, 이 역할에 S3 버킷에 액세스를 허용하는 정책을 첨부하면, 람다 함수는 이 역할을 사용하여 해당 버킷에서 읽거나 쓰는 작업을 수행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_1.png\" /\u003e\n\n참고: 본 튜토리얼에서는 환경 변수가 어떻게 사용되는지 간단하게 알 수 있도록 실제 버킷과 AWS 정책은 사용하지 않습니다. 하지만 다음 기사에서 사용할 예정입니다.\n\n# 람다 함수 배포\n\n환경에 따라 다른 변수를 출력하는 기본 \"Hello World!\" 파이썬 함수를 배포할 것입니다. 람다 패키지는 두 개의 파일로 구성됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# index.py, 핸들러가 있는 곳입니다\nfrom config import BUCKET_NAME\n\ndef lambda_handler(event, context):\n   message = f\"버킷 사용 중: {BUCKET_NAME}\"\n   return {\n       'message' : message\n   }\n```\n\n```js\n# config.py, 환경 변수를 가져와 다른 구성을 할 수 있습니다\nimport os\n\n# 지정되지 않은 경우 'mybucket'으로 기본 설정\nBUCKET_NAME = os.getenv('BUCKET_NAME', 'mybucket')\n```\n\n먼저, Lambda 함수 코드가 있는 \"code\" 폴더를 압축하여 배포에 사용할 ZIP 파일로 만들기 위해 Terraform 아카이브 파일 데이터 원본을 정의할 것입니다.\n\n```js\n# Lambda 배포를 위해 Python 코드를 zip 파일로 묶습니다.\ndata \"archive_file\" \"zip_the_code\" {\n  type        = \"zip\"\n  source_dir  = \"./code/\"\n  output_path = \"./code/test-terraform.zip\"\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 화면 구조를 명확하게하기 위해 스크린샷을 여기에 넣었습니다.\n\n![폴더 구조 이미지](/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_2.png)\n\n이제 우리는 람다 자원을 생성하기 위해 출력을 사용할 수 있습니다. 여기서 source_code_hash 속성이 매우 중요합니다. 소스 코드 해시 덕분에 Terraform이 코드의 변경을 감지할 수 있습니다.\n\n```js\n# 환경별 변수로 Lambda 함수를 배포합니다.\nresource \"aws_lambda_function\" \"terraform_lambda_func\" {\n  filename         = data.archive_file.zip_the_code.output_path\n  function_name    = \"MyLambdaFunction\"\n  role             = aws_iam_role.lambda_role.arn\n  handler          = \"index.lambda_handler\"\n  source_code_hash = data.archive_file.zip_the_code.output_base64sha256\n  runtime          = \"python3.8\"\n  environment {\n    variables = {\n      BUCKET_NAME = var.BUCKET_NAME\n    }\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 주요 요소는 환경 블록입니다. 이 블록을 정의함으로써 AWS Lambda가 실행 중에 읽을 수 있는 환경 변수인 BUCKET_NAME의 값을 지정할 수 있습니다.\n\n# 여러 환경 관리\n\n여러 환경을 관리하는 방법으로는 Terraform 워크스페이스를 사용하거나 서로 다른 변수 파일로 Terraform을 실행하여 각 환경별로 리소스를 분리하고 상태를 별도로 관리하는 데 도움이 됩니다:\n\n```js\n# 새 워크스페이스를 생성하고 개발 환경을 위한 리소스를 배포합니다.\nterraform workspace new development\nterraform apply -var=\"BUCKET_NAME=dev-bucket\"\n\n# 프로덕션 워크스페이스로 전환하고 리소스를 배포합니다.\nterraform workspace new production\nterraform apply -var=\"BUCKET_NAME=prod-bucket\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔은 많은 환경 변수를 정의해야 할 때가 있습니다. 그럴 땐 환경에 따라 다른 테라폼 변수 파일을 가리킬 수 있습니다.\n\n## 예시\n\n```js\nterraform apply -var-file=\"dev-variables.tfvars\"\nterraform apply -var-file=\"prod-variables.tfvars\"\n```\n\n## 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS Lambda 함수를 여러 환경에 배포하기 위해 Terraform을 사용하면 배포를 표준화하고 서버리스 애플리케이션을 간단하게 관리할 수 있어요.\n\n다음에는 GitHub 액션, CSV 파일 및 적절한 폴더 구조를 사용하여 오늘 본 개념과 기술을 어떻게 제품화하는지 보여 드릴게요.\n\n읽어 주셔서 감사합니다. 저는 Infostrux의 데이터 아키텍트인 Mehdi Sidi Boumedine입니다. LinkedIn에서 저와 연락하거나 팔로우하고 Infostrux 블로그의 최신 기고를 확인해 주세요. 다음 글도 기대해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png"},"coverImage":"/assets/img/2024-06-19-DeploymentofAWSLambdaFunctionsAcrossMultipleEnvironmentsUsingTerraform_0.png","tag":["Tech"],"readingTime":8},{"title":"테라폼 인터뷰 질문들","description":"","date":"2024-06-19 13:37","slug":"2024-06-19-TerraformInterviewQuestions","content":"\n먼저, 아래 Markdown 형식으로 표 태그를 변경하실 수 있습니다.\n\n![image](/assets/img/2024-06-19-TerraformInterviewQuestions_0.png)\n\nQ1: 테라폼을 사용하여 ec2 인스턴스를 만들었다고 가정해보겠습니다. 그리고 생성 후, 상태 파일에서 해당 항목을 제거했습니다. 그럼, terraform apply를 실행하면 어떻게 될까요?\n\n- 상태 파일에서 항목을 제거했기 때문에 terraform은 더 이상 해당 리소스를 관리하지 않게 됩니다. 따라서, 다음 apply에서는 새로운 리소스를 생성하게 됩니다.\n\nQ2: Terraform에서 상태 파일(State file)이란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 상태 파일은 Terraform이 배포한 모든 인프라를 추적하는 파일입니다.\n\nQ3: 테라폼 상태 파일을 저장하는 가장 좋은 방법은 무엇인가요?\n\n- 상태 파일을 저장하는 가장 좋은 방법은 S3 또는 GitLab 관리 테라폼 상태와 같은 원격 백엔드에 유지하는 것입니다. 이렇게 하면 여러 사람이 동일한 코드 자원에 작업할 때 자원 중복이 발생하지 않습니다.\n\nQ4: 테라폼 상태 잠금이란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 테라폼 코드를 작성할 때 terraform plan, apply 또는 destroy를 실행하면 테라폼이 파괴적인 작업을 방지하기 위해 상태 파일을 잠근다.\n\nQ5: 테라폼 백엔드란 무엇인가요?\n\n- 백엔드는 테라폼이 상태 데이터 파일을 저장하는 위치를 정의합니다. 테라폼은 관리하는 리소스를 추적하기 위해 지속적인 상태 데이터를 사용합니다.\n\nQ6: 테라폼에서 플러그인이란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 플러그인은 HCL 코드를 API 호출로 변환하고 해당 공급업체(AWS, GCP)에 요청을 보내는 역할을 합니다.\n\nQ7: 널 리소스(null resource)란 무엇인가요?\n\n- 널(null)이라는 접두어가 붙어 있는 것을 보니 이 리소스는 클라우드 인프라에 존재하지 않을 것을 의미합니다.\n- Terraform의 null_resource는 다음과 같은 시나리오에서 사용할 수 있습니다 -\n- 쉘 명령 실행\n- 로컬 프로비저너 및 원격 프로비저너와 함께 사용할 수 있습니다.\n- Terraform 모듈, Terraform count, Terraform 데이터 소스, 로컬 변수와 함께 사용할 수 있습니다.\n- 출력 블록에도 사용할 수 있습니다.\n\nQ8: 프로비저너의 종류는 무엇이 있나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 원격 exec: 원격 서버에서 Terraform을 사용하여 명령 실행\n- 로컬 exec: 로컬 시스템에서 Terraform을 사용하여 명령 실행\n\nQ9: Terraform 모듈의 사용 목적은 무엇인가요?\n\n- 한 번만 terraform 모듈을 생성하고 필요할 때마다 재사용할 수 있습니다.\n- 코드를 표준화하려고\n- 코드 중복을 줄이려고\n- 모듈을 버전별로 관리할 수 있습니다.\n\nQ10: Terraform으로 EC2와 VPC를 생성했는데 불행하게도 tfstate 파일이 삭제되었습니다. 복구할 수 있나요? (파일은 S3나 Dynamo DB에 있지 않고 로컬 머신에만 있음)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Terraform import 명령을 사용하여 Terraform에 의해 생성된 리소스를 가져올 수 있습니다. 그러면 해당 리소스가 상태 파일에 저장됩니다.\n\nQ11: 만약 VPC, EC2, 보안 그룹, 액세스 키, 서브넷과 같이 여러 모듈을 생성했다면, Terraform은 어떻게 첫 번째로 배포할 리소스를 알 수 있을까요?\n\n- Terraform은 코드 내의 리소스 참조를 기반으로 종속성 그래프를 자동으로 파악합니다. 리소스간의 관계를 이해하고, 이 정보를 사용하여 리소스를 생성 또는 수정해야 할 순서를 결정합니다.\n- depends_on 키워드를 사용하여 명시적인 종속성을 정의할 수 있습니다.\n\nQ12: 어떻게 로직을 변경하지 않고 특정 리소스를 삭제/파괴할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- taint과 destroy 명령어 사용하기\n- 해당 리소스를 taint하려면 terraform taint RESOURCE_TYPE.RESOURCE_NAME 명령어를 사용해야 합니다.\n- 리소스를 taint한 후, tainted된 리소스를 제거하기 위해 terraform destroy -target=RESOURCE_TYPE.RESOURCE_NAME 명령어를 실행할 수 있습니다.\n\nQ13: 테라폼에서 리소스 이름을 변경하는 방법은 무엇인가요?\n\n- 테라폼 mv 명령어를 사용하여 리소스 이름을 변경할 수 있습니다.\n\nQ14: 테라폼을 사용하여 EC2 인스턴스를 생성했는데, 누군가 수동으로 변경을 했다면, 다음에 Terraform plan을 실행하면 무엇이 발생하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Terraform 상태가 일치하지 않으면 Terraform이 EC2 인스턴스를 원하는 상태로 수정합니다. 즉, .tf 파일에 정의한 것과 일치하게 됩니다.\n\nQ15: Terraform에서 locals와 variables의 차이점은 무엇인가요?\n\n- 변수는 variables.tf 파일에 정의되거나 variables 키워드를 사용하여 정의됩니다. 변수는 덮어쓸 수 있지만 로컬 변수는 덮어쓸 수 없습니다.\n- 따라서 변수를 덮어쓰지 못하게 제한하려면 locals을 사용해야 합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-TerraformInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-06-19-TerraformInterviewQuestions_0.png","tag":["Tech"],"readingTime":5},{"title":"테라폼 안전하고 고가용성이 높으며 고장 허용성이 있는 클라우드 인프라 배포하기","description":"","date":"2024-06-19 13:35","slug":"2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures","content":"\n## \"구름의 공포\"\n\n![Image](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_0.png)\n\n# 소개\n\n강력하고 신뢰할 수 있는 클라우드 인프라는 기업이 고객에게 원활한 서비스를 제공하는 데 중요합니다. 고가용성과 내결함성은 이러한 인프라의 중요한 구성 요소입니다. 이를 달성하기 위해 많은 조직이 Terraform과 같은 인프라 자동화 도구를 활용하여 클라우드 자원을 배포하고 관리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글에서는 Terraform을 사용하여 AWS에 높은 가용성과 장애 허용성을 갖춘 클라우드 환경을 배포하는 방법을 살펴보겠습니다. 사용자 정의 VPC의 프라이빗 서브넷에 걸쳐 두 가용 영역을 포함하는 Auto Scaling 그룹 (ASG)을 포함한 환경을 만들어봅니다. 또한 ASG를 퍼블릭 서브넷에 놓인 애플리케이션 로드 밸런서 (ALB)로 프론트 엔드로 사용하고, 적절한 게이트웨이와 라우트 테이블 구성에 대해 살펴봅니다.\n\n결과적으로, Terraform을 활용하여 안정적이고 확장 가능한 클라우드 인프라를 구축하는 방법에 대한 깊은 이해를 갖게 될 것입니다. 이를 통해 고트래픽을 처리하고 각 구성요소의 개별 실패에도 가동 시간을 유지할 수 있는 클라우드 인프라를 구축할 수 있게 됩니다.\n\n자, 함께 알아보겠습니다!\n\n# 배경\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 테라폼\n\n이전에 작성한 기사 \"밤을 통해 테라포밍\"에서는 테라폼에 대해 잘 설명하고, 그 이점 및 테라폼의 가장 기본적인 개념 중 일부를 소개했어요.\n\n오늘의 데모를 위해 신속하게 준비하려면 해당 기사로 이동하여 소개 및 배경 그리고 기본 테라폼 명령어 섹션을 읽어보는 걸 권장합니다.\n\n## 아마존 EC2 오토 스케일링 그룹 (ASG)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS에서 제공하는 Amazon EC2 Auto Scaling 그룹은 수요에 따라 그룹 내 EC2 인스턴스의 수를 자동으로 조정해주는 서비스입니다.\n\n이를 통해 워크로드를 처리할 수 있는 원하는 인스턴스 수를 유지하고, 필요에 따라 인스턴스를 자동으로 추가하거나 제거할 수 있습니다. 이를 통해 애플리케이션은 수요에 따라 신축성 있게 확장 또는 축소할 수 있으며, 필요한 인스턴스만 실행하여 비용을 최적화할 수 있습니다.\n\nEC2 Auto Scaling 그룹은 다양한 스케일링 정책, 런치 구성, 인스턴스 유형을 구성하여 효율적이고 안정적인 애플리케이션 성능을 보장할 수 있습니다.\n\n## 애플리케이션 부하 분산기 (ALB)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS의 Application Load Balancer(ALB)는 애플리케이션 수준 콘텐츠를 기반으로 EC2 인스턴스와 같은 여러 대상에 대한 들어오는 트래픽을 분산시킬 수 있습니다.\n\nALB는 고급 라우팅 규칙을 기반으로 다양한 대상으로 트래픽을 지능적으로 라우팅할 수 있습니다. 이러한 라우팅 규칙에는 경로 기반 라우팅, 호스트 기반 라우팅, HTTP 헤더 기반 라우팅이 포함됩니다.\n\nALB는 SSL/TLS 오프로딩, 연결 드레이닝, 스티키 세션과 같은 다양한 기능을 제공하며, AWS의 자동 확장 및 탄력성 기능과 함께 사용하여 최적의 성능과 확장성을 보장할 수 있습니다.\n\n# 필수 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Terraform 개념과 명령어에 대한 기본 지식 및 이해도\n- 기본적인 리눅스 명령 줄 지식\n- IAM 사용자 및 관리 권한이 있는 AWS 계정\n- 사용할 준비가 된 AWS Cloud9 IDE\n- AWS CLI가 설치되어 Cloud9 IDE에 구성됨\n- Amazon EC2 키페어\n\n# 사용 사례\n\n전자 상거래 회사인 REX TECH Corp는 휴일 시즌 동안 트래픽 증가를 처리해야 합니다. 회사는 웹 사이트가 고객에게 항상 응답 가능하고 이용 가능하도록 하기를 원합니다.\n\n당신의 매니저가 AWS에 클라우드 인프라를 배포하여 가용성과 고장 허용성을 보장할 것을 지시했습니다. 당신은 고객이 항상 웹 사이트에 접속할 수 있도록 하기 위해 트래픽에 따라 EC2 Auto Scaling 그룹(ASG)을 배포하기 위해 Terraform을 활용하기로 결정했습니다. 이 그룹은 개인 서브넷에 배포되며 공개 서브넷의 응용 프로그램 로드 밸런서(ALB)에 의해 선전되며, 트래픽에 따라 자동으로 확장 또는 축소되어 웹 사이트가 항상 고객에게 응답 가능하도록 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 목표\n\n- 두 개의 공용 서브넷, 두 개의 사설 서브넷이 있는 사용자 정의 가상 사설망(VPC)을 생성합니다.\n- 공용 서브넷에 NAT 게이트웨이를 활용하고, 인터넷 게이트웨이를 사용하여 외부 인터넷 트래픽을 제공합니다.\n- 공용 라우팅 테이블과 사설 라우팅 테이블을 구성합니다.\n- 공용 서브넷에 ALB를 시작합니다.\n- 사설 서브넷에 Auto Scaling 그룹을 시작합니다.\n- ALB의 공용 DNS를 출력하고 해당 URL을 사용하여 웹 서버에 도달 가능한지 확인합니다.\n\n# 단계 0: IDE 환경에서 최신 Terraform 버전 설치\n\nAWS Cloud9은 Terraform이 사전 설치되어 있지만, 최신 버전으로 업그레이드하여 해당 기능과 기능을 완전히 활용하는 것이 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클라우드9 IDE에 최신 Terraform 버전을 설치하려면 다음 명령어를 차례대로 실행해주세요 —\n\n```js\nsudo yum install -y yum-utils\nsudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo\nsudo yum -y install terraform\n```\n\n클라우드9 터미널에서 \"terraform version\"을 실행하여 최신 버전이 정상적으로 설치되었는지 확인해주세요 —\n\n![이미지](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이해를 높이고 데모를 더 효과적으로 따르기 위해 아래 링크를 클릭하여 GitHub에서 프로젝트 저장소를 클론해 주세요. 계속 진행하면서 필요한 대로 파일을 편집해도 괜찮아요.\n\n이제 Step 1로 이동해봅시다. - 커스텀 VPC 생성 및 구성.\n\n# Step 1: 커스텀 AWS VPC 생성 및 구성\n\n우리의 초기 목표는 AWS 환경 내에서 모든 리소스를 배포할 수 있는 커스텀 VPC를 구축하는 것입니다. 이를 위해 논리적으로 격리된 CIDR 블록을 정의하고 적합한 서브넷 및 해당 가용 영역(AZ)을 신중히 선택하여 배포해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 테라폼 파일 코드를 검토해 봅시다. 사용자 정의 VPC를 생성하고 구성하는 코드입니다.\n\n## 코드 설명\n\n여기서는 지정된 CIDR 블록과 인스턴스 테넌시를 사용하여 AWS VPC를 생성합니다. 그런 다음 네 개의 서브넷을 생성합니다. 두 개는 공개 서브넷이고 두 개는 사설 서브넷입니다. 각 서브넷은 지정된 CIDR 블록을 가지며 앞서 생성된 VPC와 연결되어 지정된 가용 영역에 배포되도록 정의되어 있습니다.\n\n공개 서브넷은 map_public_ip_on_launch 속성이 true로 설정되어 있어 해당 서브넷에 배포된 인스턴스에는 자동으로 공개 IP 주소가 할당됩니다. 사설 서브넷은 해당 속성이 false로 설정되어 있어 해당 서브넷에 배포된 인스턴스는 NAT 게이트웨이를 통해 인터넷에서 접속할 수 없습니다. 각 서브넷에는 태그를 사용하여 이름이 지정되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 사용자 정의 VPC를 생성하고 구성했으니, 2단계로 넘어가서 인터넷 게이트웨이와 NAT 게이트웨이를 생성해 봅시다.\n\n# 2단계: 공용 서브넷에 인터넷 게이트웨이 및 NAT 게이트웨이 생성\n\nVPC에서 리소스를 배포할 때, 인터넷에 안전하고 효율적으로 연결되도록하는 것이 중요합니다. 이를 위해 공용 서브넷에 인터넷 게이트웨이와 NAT 게이트웨이를 생성하는 방법 중 하나입니다.\n\n인터넷 게이트웨이는 VPC 구성요소로서 VPC 내의 인스턴스와 인터넷 간의 통신을 허용합니다. 한편, NAT 게이트웨이는 사설 서브넷에 있는 인스턴스가 인터넷이나 다른 AWS 서비스에 연결할 수 있도록하며, 외부 트래픽에 대한 추가 보안도 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래에서 Terraform 파일을 만들고 구성하여 인터넷 게이트웨이와 NAT 게이트웨이를 생성하는 코드를 살펴보겠습니다 —\n\n## 코드 설명\n\n먼저, 인터넷 게이트웨이를 생성하고 사용자 정의 VPC에 연결합니다. 또한 Elastic IP 주소와 NAT 게이트웨이를 생성하고 Elastic IP와 공용 서브넷에 연결합니다. 인터넷 게이트웨이가 NAT 게이트웨이를 생성하기 전에 먼저 생성되도록 합니다.\n\n좋아요! 이제 인터넷 게이트웨이와 NAT 게이트웨이가 생성되었으니, 다음은 — 3단계로 넘어가 공용 및 사설 라우트 테이블을 구성하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 3: 공용 라우트 테이블 및 사설 라우트 테이블 구성\n\n이 시점에서, 우리는 맞춤형 VPC와 게이트웨이를 성공적으로 생성했습니다. 그러나, 지금 직면한 문제는 VPC에 배포된 서비스 및 다른 구성 요소들 간의 통신을 관리하는 것입니다. 이곳에서 VPC 내에서의 네트워크 트래픽 흐름을 구성하는 것이 중요해집니다. 이를 위해, 서브넷 간의 네트워크 트래픽을 안내하기 위해 라우팅 테이블을 설정하는 것이 효과적입니다.\n\n아래의 코드를 검토하여 각각의 라우트 테이블을 생성하고 구성하는 방법을 확인해보겠습니다 —\n\n## 코드 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에서는 두 개의 라우팅 테이블을 생성 중입니다 — 공개 라우팅 테이블과 사설 라우팅 테이블. 공개 라우팅 테이블은 인터넷 게이트웨이로의 기본 경로를 갖고 있으며, 사설 라우팅 테이블은 NAT 게이트웨이로의 기본 경로를 갖고 있습니다.\n\n공개 라우팅 테이블은 두 개의 공개 서브넷과 연결되어 있고, 사설 라우팅 테이블은 두 개의 사설 서브넷과 연결되어 있습니다. 사설 리소스 연결은 사설 라우팅 테이블이 생성된 후에 수립됩니다. 이 라우팅 테이블에는 태그를 사용하여 이름이 지정되어 있습니다.\n\n이제, Step 4로 계속해 봅시다! 공개 서브넷에서 새 ALB를 실행합니다.\n\n# Step 4: 공개 서브넷에 ALB를 실행합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자의 ALB를 활성화하기 위한 과정을 살펴보겠습니다. 사용자 정의 VPC의 공용 서브넷에서 ALB를 생성하는 것은 여러 단계를 거칩니다. 이 단계에는 보안 그룹 생성, 대상 그룹, 리스너 및 라우팅 규칙 설정이 포함됩니다.\n\n아래의 Terraform 코드를 검토해보세요. 이 코드는 ALB와 연결할 보안 그룹을 생성합니다.\n\n## 코드 설명\n\n이 Terraform 코드에서는 ALB와 함께 사용할 보안 그룹을 생성합니다. 보안 그룹은 이름과 설명과 함께 정의되며, 사용자 정의 VPC와 연관됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIngress 규칙을 통해 특정 CIDR 블록에서 HTTP 및 SSH 트래픽을 허용하고, 모든 트래픽을 허용하는 egress 규칙도 있습니다. 또한 보안 그룹에 쉽게 식별할 수 있도록 이름을 태그합니다.\n\n이제 ALB를 생성하고 구성하는 코드를 검토할 수 있습니다 —\n\n## 코드 설명\n\n여기서 ALB 및 해당 리소스를 생성합니다. 먼저 ALB를 생성하고, 사용할 이름, 서브넷 및 보안 그룹을 지정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nALB가 트래픽을 전달할 타겟 그룹을 생성하여 이름, 포트, 프로토콜 및 헬스 체크 구성을 지정합니다.\n\n마지막으로 ALB를 위해 리스너를 생성하여 수신할 포트와 프로토콜을 지정하고, 기본 작업을 이전에 생성한 타겟 그룹으로의 트래픽 전달로 설정합니다. 이렇게 하면 리스너 규칙과 타겟 그룹의 구성에 따라 적절한 리소스로 트래픽이 전달됩니다.\n\n이제 다음 단계로 계속해 보죠. Terraform 구성 파일을 검토하여 사용자 정의 VPC를 생성하고 해당 적절한 서브넷을 구성하며, 인터넷 및 NAT 게이트웨이, 그리고 공용 및 비공용 라우팅 테이블을 설정했습니다. ALB의 구성이 이제 완료되어 준비되었으므로, Step 5로 이동할 수 있습니다 — 비공용 서브넷에서 ASG를 시작합니다.\n\n# Step 5: 비공용 서브넷에서 자동 스케일링 그룹 시작하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오토 스케일링 그룹(ASG)은 일반적으로 공용 서브넷에 배포되지만, 민감한 데이터를 다루거나 규제 요구 사항을 준수해야 하는 경우와 같이 사설 서브넷을 선호하는 경우가 많이 있습니다.\n\n아래 코드를 살펴보면, 두 가용 영역(AZ)에 걸쳐 EC2 ASG를 사설 서브넷에서 시작하는 단계를 설명합니다 —\n\n## 코드 설명\n\n우선, ASG 런치 템플릿용 보안 그룹을 생성하고, 이를 이전에 생성한 사용자 정의 VPC와 연결해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보안 그룹은 ALB의 보안 그룹에서 엄격히 HTTP 및 SSH 프로토콜에 대한 인바운드 트래픽을 허용합니다. 이렇게 함으로써 ASG에 대한 액세스는 ALB에서만 가능하게 되어 보안이 제공됩니다. 보안 그룹은 상태를 유지하므로 정의된 변수에서 지정된 CIDR 블록으로 어디서든지 아웃바운드 트래픽을 허용합니다.\n\n## Bash 스크립트\n\nASG를 생성하기 위해 우리가 준비할 것은 ASG의 런치 템플릿에 통합될 bash 스크립트를 먼저 작성하는 것입니다. 이 스크립트는 EC2 인스턴스의 사용자 데이터 역할을 하여 Apache 웹 서비스의 설치 및 시작, 그리고 맞춤식 웹 페이지의 생성을 자동화합니다.\n\n아래의 bash 스크립트를 살펴봅시다 —\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 코드 설명\n\n이 스크립트에서는 먼저 모든 yum 패키지 저장소를 업데이트한 다음 yum을 사용하여 Apache Web Server 패키지를 설치합니다. 그런 다음 Apache 서비스를 시작하고 부팅 시 자동으로 시작되도록 활성화합니다.\n\n또한 이 스크립트는 흔히 사용되는 소프트웨어 패키지를 쉽게 설치할 수 있게 하는 Extra Packages for Enterprise Linux (EPEL) 저장소를 설치합니다.\n\n또한 스크립트는 인스턴스를 고부하로 테스트하는 데 사용할 수 있는 stress 패키지를 설치합니다. 마지막으로 스크립트는 기본 index.html 파일에 REX TECH에 오신 것을 환영합니다! 메시지가 포함된 사용자 정의 웹페이지를 Apache 문서 루트 디렉토리 /var/www/html/에 추가합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## ASG 생성 및 구성\n\n우리의 ASG 보안 그룹 및 Bash 스크립트가 생성되었으므로 이제 ASG를 만들고 구성할 차례입니다 —\n\n## 코드 설명\n\nASG를 생성할 때 최소, 최대 및 원하는 용량을 설정해야 합니다. 또한 ASG는 서브넷 ID로 식별되는 두 개의 사설 서브넷에서 시작됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n런치 템플릿(Launch Template)은 Amazon Machine Image (AMI), 인스턴스 유형 및 키파일과 같은 구성과 함께 생성됩니다. 여기에는 이전에 생성한 Bash 스크립트를 base64로 인코딩한 사용자 데이터 파일로 지정합니다. 이는 Apache 웹 서버를 설치하고 시작하고 사용자 정의 웹 페이지를 생성하는 스크립트를 실행합니다.\n\n마지막으로 ASG를 ALB의 대상 그룹에 자동 확장 첨부를 사용하여 연결합니다. 이를 통해 ASG가 들어오는 트래픽에 대응하여 인스턴스 간 부하를 자동으로 균형 잡아 최적의 성능과 가용성을 보장합니다.\n\n이제 6단계로 넘어가서 output.tf 파일을 활용하여 ALB의 퍼블릭 DNS를 얻어봅시다.\n\n# Step 6: output.tf 파일을 활용하여 ALB의 퍼블릭 DNS를 얻기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nALB를 만든 후에는 ALB의 공개 DNS에 직접 액세스하는 것이 귀찮을 수 있습니다. 다행히도, 테라폼에서 output.tf 파일을 생성하여 ALB의 공개 DNS를 즉시 얻을 수 있는 쉬운 해결책을 제공할 수 있습니다. 이를 통해 들어오는 트래픽이 올바르게 타깃 그룹 내의 인스턴스로 경로 지정되도록 보장할 수 있습니다.\n\n아래 output.tf 파일을 확인해 봅시다 —\n\n## 코드 설명\n\nOutputs를 사용하면 테라폼 인프라에서 생성된 리소스의 값들을 볼 수 있습니다. 여기서 우리는 테라폼 인프라를 위해 여러가지 output을 생성합니다. 각 output은 다른 리소스를 참조합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희의 출력물에는 VPC의 ID, 퍼블릭 및 프라이빗 서브넷의 ID, 인터넷 게이트웨이와 ALB의 DNS 이름이 포함됩니다. 이러한 출력물은 인프라에 대한 정보를 제공하기 위해 사용될 것입니다.\n\n이제, 7단계로 넘어갑시다 — 리소스 인자의 동적 값에 대한 변수 생성.\n\n# Step 7: 리소스 인자의 동적 값에 대한 변수 생성\n\nTerraform을 사용하여 인프라스트럭처를 생성할 때 리소스 인자에 동적 값들을 사용하는 것이 일반적입니다. 이러한 동적 값들은 사용자 입력, 환경 변수 또는 다른 리소스의 출력 값에 기반할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 동적 값들을 관리하기 위해 변수를 사용하는 것이 중요합니다. 변수를 사용하면 배포 사항 전반에 걸쳐 일관성을 유지하고, 코드를 읽고 유지하기 쉽게 만들며, 코드의 재사용성을 가능케 합니다.\n\n아래 코드에서 정의한 많은 변수들을 살펴봅시다 —\n\n## 코드 설명\n\n이곳에서는 이 Terraform 프로젝트에서 동적 값들을 사용할 수 있게 해주는 일련의 변수들을 정의합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 변수에는 이름, 기본값 및 유형이 있습니다. 기본값은 Terraform 코드를 실행할 때 특정 값이 지정되지 않은 경우 변수가 설정되는 값을 나타냅니다. 유형은 변수의 예상 데이터 유형을 지정합니다.\n\n예를 들어, aws_region 변수는 기본값으로 us-east-1을 가지고 있으며 문자열 유형을 갖습니다. 이는 문자열 값을 예상한다는 것을 의미합니다. 마찬가지로 auto-assign-ip 변수는 기본값으로 true를 가지고 있으며 불리언(bool) 유형을 갖습니다. 이는 불리언 값을 예상한다는 것을 의미합니다.\n\n일부 변수는 인프라의 네트워킹 구성 요소와 관련되어 있으며 VPC, 공용 서브넷 및 사설 서브넷의 이름과 같은 값을 지정합니다.\n\n변수를 정의함으로써 주요 구성 파일을 수정하지 않고 값이 쉽게 변경될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알겠어요! 이제 우리가 모든 Terraform 구성 파일들을 검토했으니, Step 8로 넘어갈게요 — 정의된 인프라를 배포하기 위해 Terraform 워크플로우를 실행해봅시다.\n\n# Step 8: Terraform 워크플로우 실행해서 초기화, 유효성 검사, 계획 및 적용하기\n\nCloud9 터미널에서 필요한 공급자를 초기화하려면 Cloud9 터미널에서 다음 명령을 실행해주세요 —\n\n```js\nterraform init\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n초기화 프로세스가 완료되면 아래와 같이 성공적인 프롬프트가 표시됩니다.\n\n![이미지](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_2.png)\n\n이제 다음 명령을 실행하여 코드에 구문 오류가 없는지 확인해보겠습니다 —\n\n```js\nterraform validate\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 유효한 것으로 확인되는 성공 메시지를 생성하는 명령어여야 합니다.\n\n![image](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_3.png)\n\n이제 다음 명령어를 실행하여 Terraform이 적용할 모든 수정 사항 목록을 생성해 봅시다. —\n\n```js\nterraform plan\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테라폼이 기대하는 인프라 리소스에 적용할 변경 목록을 표시해야 합니다. \"+\" 기호는 추가될 내용을 나타내고, \"-\" 기호는 제거될 내용을 나타냅니다.\n\n![변경 목록](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_4.png)\n\n이제 이 인프라를 배포해 봅시다! 다음 명령을 실행하여 변경 사항을 적용하고 리소스를 배포하세요.\n\n참고 - 이 명령을 실행한 후에 변경 사항에 동의하기 위해 \"yes\"를 입력해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nterraform apply\n```\n\n테라폼은 인프라에 대한 모든 변경 사항을 적용하는 프로세스를 시작할 것입니다. 배포 프로세스가 완료될 때까지 잠시 기다려주시기 바랍니다.\n\n![이미지](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_5.png)\n\n# 성공!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 추가된, 수정된 및 삭제된 리소스의 총 수를 명시하고 \"적용 완료\"라는 메시지로 프로세스를 마무리해야 합니다. 몇 가지 리소스 출력과 함께 해야 합니다.\n\n브라우저에서 웹 페이지에 액세스하려면 ALB의 DNS URL을 복사하여 저장하세요.\n\n![ALB DNS URL](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_6.png)\n\n이제 리소스가 생성되었는지 확인하기 위해 관리 콘솔에서 검토해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계 9: ASG 및 대상 그룹의 건강 상태에서 EC2 인스턴스 생성 확인\n\nAWS 관리 콘솔에서 EC2 대시보드로 이동하여 ASG에서 시작된 두 대 서버가 있는지 확인하세요.\n\n![이미지](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_7.png)\n\n또한 왼쪽 창으로 이동하여 대상 그룹을 선택하고 대상 그룹을 확인하고, 하단으로 스크롤하여 인스턴스의 건강 상태가 정상인지 확인하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_8.png\" /\u003e\n\n좋아요! ASG가 예상대로 EC2 인스턴스를 생성했고, 모든 대상 그룹의 상태가 정상적으로 표시되고 있는 것을 성공적으로 확인했습니다. 이제 ALB를 통해 ASG의 웹 서버에 액세스할 수 있는지 확인해 봅시다.\n\n# 단계 10: 브라우저에서 URL을 사용하여 웹 서버에 도달 가능한지 확인하기\n\n설정한 브라우저를 열고 ALB의 DNS URL을 브라우저에 붙여넣어 주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**알림** - ALB에 연결하려면 \"http://\" 프로토콜을 사용해야 합니다. \"https://\"는 사용하지 마세요.\n\n![사진](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_9.png)\n\n# 축하합니다!\n\n\"The Terror In The Clouds\"를 성공적으로 완료했어요. Terraform을 사용하여 신뢰할 수 있고 확장 가능한 클라우드 인프라를 구축하는 방법을 배웠습니다. 이 인프라는 높은 트래픽을 다룰 수 있으며 개별 구성 요소의 장애가 발생해도 가동 시간을 유지할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 정리하기\n\n## 인프라 파괴\n\n아래 명령어를 실행하여 이전에 Terraform으로 프로비저닝한 모든 리소스를 삭제/제거/해제하세요 —\n\n```js\nterraform destroy\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"작업이 완료될 때까지 기다려주세요. 마침내 '파괴가 완료되었습니다'라는 메시지와 함께 파괴된 리소스의 양이 표시됩니다.\n\n지금까지 읽어 주셔서 감사합니다! 유익했기를 바랍니다.\n\n![TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_10.png)\n\nIfeanyi Otuonye는 클라우드/데브옵스 엔지니어로 클라우드 기술과 데브옵스 문화에 광신적인 엔지니어입니다. 배우려는 열정으로 움직이며 협업 환경에서 번영합니다. 정보 기술과 프로젝트 관리의 배경을 가지고 있으며 프로 선수의 삶을 균형 있게 유지하고 있습니다. 2021년 말부터 클라우드/데브옵스 엔지니어로 나아가기 위해 자기 학습을 시작했으며, 최근에는 Level Up In Tech 프로그램에 참여하였습니다!\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Master DynamoDB\n\n지금 'TOWARDSAWS' 코드를 사용하여 DynamoDB Book을 35% 할인된 가격으로 구매하세요.\n\n![DynamoDB Book](/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_11.png)\n","ogImage":{"url":"/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_0.png"},"coverImage":"/assets/img/2024-06-19-TerraformDeployingSecureHighlyAvailableandFault-TolerantCloudInfrastructures_0.png","tag":["Tech"],"readingTime":23},{"title":"OCI에서 Active Directory 게임을 실행하는 방법  1부","description":"","date":"2024-06-19 13:32","slug":"2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1","content":"\n제가 정말 즐겁게 즐겼던 프로젝트 중 하나는 GOAD입니다. 게임 오브 스로운즈 팬으로서 사이버 지식을 시험하고 동시에 즐길 수 있는 수단이었습니다. 만약 여러분이 스로운즈의 팬이라면, 이 Windows/AD/SCCM 랩은 여러분을 위한 것입니다.\n\n처음에는 중첩 가상화 서버를 만들려고 했는데, 테라폼과 앤서블 지식이 거의 없어서 어려움을 겪었습니다. 하지만 저는 자동화로 나아가기로 결정했습니다. 일상적인 작업에서 시간을 절약하고, 올바르게 구현된다면 인간 에러를 줄일 수 있기 때문에 자동화가 많은 도움이 된다는 점에 동의합니다.\n\n`Game of Active Directory (GOAD)` 프로젝트는 현실적이고 실용적인 경험을 통해 사이버 보안 기술을 향상시키는 포괄적인 랩 환경입니다. Oracle Cloud Infrastructure (OCI)에서 호스팅되며, 다양한 OCI 서비스와 통합하여 현실 세계의 보안 시나리오를 모의할 수 있습니다.\n\nhttps://github.com/adibirzu/GOAD/blob/main/docs/install_with_oci.md\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n랩 환경으로서 VCN 보안 목록에서 엄격한 ACL을 구현하지는 않았어요. 그러나 모든 포트에서 192.168.0.0/16에서의 액세스는 허용했어요.\n\n1- 우리는 OCI의 Windows Server/Ubuntu 이미지를 사용할 거에요. 이 선택은 PAYG 요금제를 사용해. Windows Server 평가판을 사용할 계획이라면, 자체 이미지를 빌드하고 테라폼 스크립트를 사용자 정의 이미지 OCID로 설정해야 해요:\n\nOracle Cloud Infrastructure 이미지\n\n2- 테라폼 스크립트와 PowerShell 스크립트는 ad →GOAD →providers →OCI 하위에 추가됐어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Screenshot](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_0.png)\n\n```js\n./goad.sh -t check -l GOAD -p oci -m local\n```\n\n3- 서로 다른 공급업체에서 사용자들이 알고 있는 동일한 워크플로를 제공하기 위해 goad.sh 스크립트에 제공자로 oci를 추가했습니다.\n\n![Screenshot](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOCI에서 우분투의 기본 사용자는 ubuntu이므로 goad.sh의 모든 참조는 ubuntu 사용자를 사용할 것입니다:\n\n![2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_2](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_2.png)\n\n4. 스크립트 아래에, 저는 설치 후 우분투 서버의 선행 조건을 설치하기 위해 setup_oci.sh 스크립트를 만들었습니다.\n\n![2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_3](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n5- 오라클 클라우드 인프라에서 랩을 프로비저닝하는 방법을 설명하는 docs/install_with_oci.md를 업데이트했습니다.\n\n6- ad →GOAD →providers →oci →ssh_keys →ubuntu-jumpox.pem에 개인 키를 배치하여 Ubuntu 인스턴스에 연결을 테스트했습니다.\n\n!!!! 이 키를 매우 주의해서 다루고, git에 공개하지 마세요.\n\n![이미지](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경하였습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n9- ad → GOAD → providers → oci → terraform 폴더에 Terraform/PowerShell 파일을 만들어주세요:\n\n- windows_cloud_init.ps1\n\n```js\n# 변수\n$adminUsername = “ansible”\n$adminPassword = ConvertTo-SecureString “YourSecurePassword123!” -AsPlainText -Force\n\n# ansible 사용자 생성\nNew-LocalUser $adminUsername -Password $adminPassword -FullName $adminUsername -Description “Ansible admin user”\nAdd-LocalGroupMember -Group “Administrators” -Member $adminUsername\n\n# WinRM 활성화\nwinrm quickconfig -q\nwinrm set winrm/config/service/auth @{Basic=”true”}\nwinrm set winrm/config/service @{AllowUnencrypted=”true”}\nwinrm set winrm/config/service @{EnableCompatibilityHttpsListener=”true”}\nwinrm set winrm/config/service @{EnableCompatibilityHttpListener=”true”}\n$cert = New-SelfSignedCertificate -DnsName $(hostname) -CertStoreLocation Cert:\\LocalMachine\\My\nwinrm create winrm/config/Listener?Address=*+Transport=HTTPS @{Hostname=$(hostname); CertificateThumbprint=$($cert.Thumbprint)}\nSet-Service -Name winrm -StartupType Automatic\nStart-Service -Name winrm\n\n# WinRM을 위한 기본 인증 및 암호화 트래픽 활성화\nSet-Item -Path WSMan:\\localhost\\Service\\Auth\\Basic -Value $true\nSet-Item -Path WSMan:\\localhost\\Service\\AllowUnencrypted -Value $true\n\n# WinRM 방화벽 예외 설정\nNew-NetFirewallRule -Name \"WinRM-HTTP\" -DisplayName \"WinRM (HTTP-In)\" -Protocol TCP -LocalPort 5985 -Action Allow -Enabled True\nNew-NetFirewallRule -Name \"WinRM-HTTPS\" -DisplayName \"WinRM (HTTPS-In)\" -Protocol TCP -LocalPort 5986 -Action Allow -Enabled True\n\n# TLS 1.2 프로토콜 설정\n[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12\n\n# NuGet 공급자 설치 및 PowerShellGet 업데이트\nInstall-PackageProvider -Name NuGet -Force -Confirm:$false\nUpdate-Module -Name PowerShellGet -Force -AllowClobber -Confirm:$false\n```\n\n- profile.tf\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprovider \"oci\" {\n  tenancy_ocid      = var.tenancy_ocid\n  user_ocid         = var.user_ocid\n  fingerprint       = var.fingerprint\n  private_key_path  = var.private_key_path\n  region            = var.region\n}\n```\n\nvariables.tf\n\n```js\nvariable \"tenancy_ocid\" {\n  description = \"The OCID of your tenancy.\"\n  type        = string\n}\n\nvariable \"user_ocid\" {\n  description = \"The OCID of the user calling the API.\"\n  type        = string\n}\n\nvariable \"fingerprint\" {\n  description = \"The fingerprint of the API key.\"\n  type        = string\n}\n\nvariable \"private_key_path\" {\n  description = \"The path to the private key.\"\n  type        = string\n  default     = \"/Users/abirzu/.ssh/newpemkey.pem\"\n}\n\nvariable \"region\" {\n  description = \"The region to use.\"\n  type        = string\n  default     = \"eu-frankfurt-1\"\n}\n\nvariable \"compartment_ocid\" {\n  description = \"The OCID of the compartment to use.\"\n  type        = string\n}\n\nvariable \"availability_domain\" {\n  description = \"The availability domain to use.\"\n  type        = string\n  default     = \"NoEK:EU-FRANKFURT-1-AD-1\"\n}\n\nvariable \"shape\" {\n  description = \"The shape of the instance to be created.\"\n  type        = string\n  default     = \"VM.Standard.E5.Flex\"\n}\n\nvariable \"ocpus\" {\n  description = \"The number of OCPUs to allocate.\"\n  type        = number\n  default     = 1\n}\n\nvariable \"memory_in_gbs\" {\n  description = \"The amount of memory in GBs.\"\n  type        = number\n  default     = 12\n}\n\nvariable \"ssh_authorized_keys\" {\n  description = \"The public key for SSH access to the instances.\"\n  type        = string\n}\n\nvariable \"image_ocid\" {\n  description = \"The OCID of the image to use.\"\n  type        = string\n}\n\nvariable \"windows2016_image_ocid\" {\n  description = \"The OCID of the Windows Server 2016 image.\"\n  type        = string\n}\n\nvariable \"windows2019_image_ocid\" {\n  description = \"The OCID of the Windows Server 2019 image.\"\n  type        = string\n}\n```\n\nnetwork.tf\n\n```js\n\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nresource “oci_core_vcn” “generated_oci_core_vcn” {\n cidr_block = “192.168.0.0/16”\n compartment_id = var.compartment_ocid\n display_name = “goad-virtual-network”\n dns_label = “goadvcn”\n}\nresource “oci_core_subnet” “public_subnet” {\n cidr_block = “192.168.57.0/24”\n compartment_id = var.compartment_ocid\n display_name = “public-subnet”\n dns_label = “publicsubnet”\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n route_table_id = oci_core_route_table.public_route_table.id\n}\nresource “oci_core_subnet” “private_subnet” {\n cidr_block = “192.168.56.0/24”\n compartment_id = var.compartment_ocid\n display_name = “private-subnet”\n dns_label = “privatesubnet”\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n route_table_id = oci_core_route_table.private_route_table.id\n prohibit_internet_ingress = true\n prohibit_public_ip_on_vnic = true\n security_list_ids = [oci_core_security_list.winrm_rdp_security_list.id]\n}\nresource “oci_core_internet_gateway” “generated_oci_core_internet_gateway” {\n compartment_id = var.compartment_ocid\n display_name = “Internet Gateway goad-virtual-network”\n enabled = true\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n}\nresource “oci_core_nat_gateway” “generated_oci_core_nat_gateway” {\n compartment_id = var.compartment_ocid\n display_name = “NAT Gateway goad-virtual-network”\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n}\nresource “oci_core_route_table” “public_route_table” {\n compartment_id = var.compartment_ocid\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n display_name = “public-route-table”\nroute_rules {\n destination = “0.0.0.0/0”\n destination_type = “CIDR_BLOCK”\n network_entity_id = oci_core_internet_gateway.generated_oci_core_internet_gateway.id\n }\n}\nresource “oci_core_route_table” “private_route_table” {\n compartment_id = var.compartment_ocid\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n display_name = “private-route-table”\nroute_rules {\n destination = “0.0.0.0/0”\n destination_type = “CIDR_BLOCK”\n network_entity_id = oci_core_nat_gateway.generated_oci_core_nat_gateway.id\n }\n}\n  options {\n    type                  = \"DomainNameServer\"\n    server_type           = \"CustomDnsServer\"\n    custom_dns_servers    = [\"192.168.56.10\",\"8.8.8.8\"]\n  }\n options {\n        type = \"SearchDomain\"\n        search_domain_names = [ \"sevenkingdoms.local\" ]\n    }\n}\nresource “oci_core_security_list” “winrm_rdp_security_list” {\n compartment_id = var.compartment_ocid\n vcn_id = oci_core_vcn.generated_oci_core_vcn.id\n display_name = “winrm_rdp_security_list”\negress_security_rules {\n protocol = “all”\n destination = “0.0.0.0/0”\n stateless = false\n }\ningress_security_rules {\n protocol = “all”\n source = “192.168.0.0/16”\n stateless = false\n }\n}\n```\n\n```js\nresource “oci_core_default_dhcp_options” “default_dhcp_options” {\n manage_default_resource_id = oci_core_vcn.generated_oci_core_vcn.default_dhcp_options_id\noptions {\n type = “DomainNameServer”\n server_type = “CustomDnsServer”\n custom_dns_servers = [“192.168.56.10”]\n search_domain_names = [“sevenkingdoms.local”]\n }\n```\n\nThe DHCP configuration part is essential, as if it’s not properly configured, it will result in the failure of the ansible jobs. If the terraform variable will not add the search domain, you need to do this manually:\n\nGo to the VCN → DHCP Options:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_7.png\" /\u003e\n\n화면 오른쪽 상단에 있는 3 점을 클릭한 후 편집을 선택하세요. 여기에서 외부 DNS 서버를 추가하고 사용자 정의 검색 도메인인 Seven Kingdoms를 추가할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_8.png\" /\u003e\n\n이 부분에서 DNS 문제를 해결해야합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\noptions {\ntype = \"도메인 네임 서버\"\nserver_type = \"사용자 정의 DNS 서버\"\ncustom_dns_servers = [\"192.168.56.10\",\"8.8.8.8\"]\n}\noptions {\ntype = \"검색 도메인\"\nsearch_domain_names = [\"seven kingdoms.local\"]\n}\n```\n\njumpbox.tf\n\n```js\nresource \"oci_core_instance\" \"jumpbox\" {\n availability_domain = var.availability_domain\n compartment_id = var.compartment_ocid\n display_name = \"jumpbox\"\n shape = var.shape\nshape_config {\n baseline_ocpu_utilization = \"BASELINE_1_1\"\n memory_in_gbs = var.memory_in_gbs\n ocpus = var.ocpus\n }\nsource_details {\n source_id = var.image_ocid\n source_type = \"이미지\"\n }\n#이미지 OCID’S https://docs.oracle.com/en-us/iaas/images/image/bd616d0a-fae4-490e-bd31-a9406095b844/\n create_vnic_details {\n assign_ipv6ip = false\n assign_private_dns_record = true\n assign_public_ip = true\n subnet_id = oci_core_subnet.public_subnet.id\n }\nmetadata = {\n ssh_authorized_keys = var.ssh_authorized_keys\n }\nagent_config {\n is_management_disabled = false\n is_monitoring_disabled = false\nplugins_config {\n desired_state = \"사용 안 함\"\n name = \"취약점 스캐닝\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"관리 에이전트\"\n }\n plugins_config {\n desired_state = \"사용함\"\n name = \"사용자 지정 로그 모니터링\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"컴퓨팅 RDMA GPU 모니터링\"\n }\n plugins_config {\n desired_state = \"사용함\"\n name = \"컴퓨팅 인스턴스 모니터링\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"컴퓨팅 HPC RDMA 자동 구성\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"컴퓨팅 HPC RDMA 인증\"\n }\n plugins_config {\n desired_state = \"사용함\"\n name = \"클라우드 가드 워크로드 보호\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"블록 볼륨 관리\"\n }\n plugins_config {\n desired_state = \"사용 안 함\"\n name = \"바스천\"\n }\n }\navailability_config {\n is_live_migration_preferred = true\n recovery_action = \"인스턴스 복원\"\n }\nplatform_config {\n is_symmetric_multi_threading_enabled = true\n type = \"AMD_VM\"\n }\ninstance_options {\n are_legacy_imds_endpoints_disabled = false\n }\n}\n```\n\nwindowsvm.tf\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n리소스 \"oci_core_instance\" \"windows_instance\" {\n for_each = {\n kingslanding = {\n name = \"kingslanding\"\n private_ip_address = \"192.168.56.10\"\n admin_username = \"ansible\"\n admin_password = \"8dCT-DJjgScp\"\n image_ocid = var.windows2019_image_ocid\n }\n winterfell = {\n name = \"winterfell\"\n private_ip_address = \"192.168.56.11\"\n admin_username = \"ansible\"\n admin_password = \"NgtI75cKV+Pu\"\n image_ocid = var.windows2019_image_ocid\n }\n castelblack = {\n name = \"castelblack\"\n private_ip_address = \"192.168.56.22\"\n admin_username = \"ansible\"\n admin_password = \"NgtI75cKV+Pu\"\n image_ocid = var.windows2019_image_ocid\n }\n meereen = {\n name = \"meereen\"\n private_ip_address = \"192.168.56.12\"\n admin_username = \"ansible\"\n admin_password = \"Ufe-bVXSx9rk\"\n image_ocid = var.windows2016_image_ocid\n }\n braavos = {\n name = \"braavos\"\n private_ip_address = \"192.168.56.23\"\n admin_username = \"ansible\"\n admin_password = \"978i2pF43UJ-\"\n image_ocid = var.windows2016_image_ocid\n }\n }\navailability_domain = var.availability_domain\n compartment_id = var.compartment_ocid\n display_name = each.value.name\n shape = \"VM.Standard.E5.Flex\"\nshape_config {\n ocpus = 2\n memory_in_gbs = 32\n }\nsource_details {\n source_id = each.value.image_ocid\n source_type = \"image\"\n }\ncreate_vnic_details {\n assign_ipv6ip = false\n assign_private_dns_record = true\n assign_public_ip = false\n subnet_id = oci_core_subnet.private_subnet.id\n hostname_label = each.value.name\n private_ip = each.value.private_ip_address\n }\nmetadata = {\n user_data = base64encode(file(\"${path.module}/windows_cloud_init.ps1\"))\n admin_password = each.value.admin_password\n }\n}\n```\n\noutputs.tf\n\n```js\noutput \"ubuntu_jumpbox_ip\" {\n value = oci_core_instance.jumpbox.public_ip\n}\noutput \"windows_instance_opc_passwords\" {\n value = { for k, v in oci_core_instance.windows_instance : k =\u003e v.metadata.admin_password }\n sensitive = true\n}\n```\n\n프로비저닝 중 발생한 일반적인 오류입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 Markdown 형식에 맞게 표 태그를 변경하십시오.\n\n![이미지](/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_9.png)\n\n모든 TF가 생성된 후, GOAD git 저장소가 정상적으로 동기화된 경우 다음을 실행해야 합니다:\n\nabirzu@abirzu-mac GOAD % ./goad.sh -t destroy -l GOAD -p oci -m local\n\n모든 서버가 가동되고 작동 중인 것을 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_10.png\" /\u003e\n\n축하합니다! 환경이 작동 중에 있습니다.\n\n# 서버\n\n이 랩은 실제로 다섯 개의 가상 머신으로 구성되어 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- kingslanding: DC01는 Windows Server 2019에서 실행 중입니다(기본으로 windefender가 활성화됨)\n- winterfell: DC02는 Windows Server 2019에서 실행 중입니다(기본으로 windefender가 활성화됨)\n- castelblack: SRV02는 Windows Server 2019에서 실행 중입니다(windefender가 기본적으로 비활성화됨)\n- meereen: DC03은 Windows Server 2016에서 실행 중입니다(기본으로 windefender가 활성화됨)\n- braavos: SRV03은 Windows Server 2016에서 실행 중입니다(기본으로 windefender가 활성화됨)\n\n도메인: north.sevenkingdoms.local\n\n- winterfell: DC01\n- castelblack: SRV02: MSSQL / IIS\n\n도메인: sevenkingdoms.local\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- kingslanding: DC02\n- castelrock: SRV01 (자원 부족으로 비활성화됨)\n\n# 도메인: essos.local\n\n- braavos: DC03\n- meeren: SRV03: MSSQL / ADCS\n\n인터넷에서 몇 가지 가이드를 따르거나 자신만의 방법을 찾아 시작할 수 있습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAD | Mayfly (mayfly277.github.io)\n\nSolving Game of Active Directory (GOAD) by Orange Cyberdefense Part-1 | by n00🔑 | Medium\n\n제1부에서는 OCI에서 GOAD 랩을 만드는 방법을 소개했고, 다음 부분에서는 다음에 초점을 맞출 것입니다:\n\nOCI 통합:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. OCI Management Agent:\n\n- 설명: 클라우드 작업을 자동화하고 모니터링합니다.\n- 통합: GOAD 환경 내 자원의 배포 및 관리를 간소화합니다.\n\n2. Sysmon 및 로깅 분석:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n• 설명: Sysmon은 시스템 활동을 기록하여 침입 탐지를 지원합니다.\n\n• 통합: Sysmon 이벤트를 수집하고 OCI Logging Analytics로 전송하여 고급 로그 분석 및 시각화를 지원합니다. 자세한 내용은 여기에서 확인하세요.\n\n3. Arkime 통합:\n\n• 설명: Arkime은 오픈 소스 패킷 캡처 및 검색 도구입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n• 통합: 효율적인 데이터 색인 및 검색을 위해 OCI OpenSearch를 활용합니다. 자세한 내용은 여기에서 확인할 수 있습니다.\n\n4. 클라우드 가드 인스턴스 보안:\n\n• 설명: 클라우드 가드는 포괄적인 클라우드 보안 관리를 제공합니다.\n\n• 통합: 로깅 분석을 활용하여 인스턴스 보안을 강화하며 실시간 위협 감지 및 대응이 가능합니다. 더 많은 정보는 여기에서 확인할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_0.png"},"coverImage":"/assets/img/2024-06-19-HowtorunGameofActiveDirectoryinOCIPart1_0.png","tag":["Tech"],"readingTime":20},{"title":"의존성 관리자 Dependabot GitHub 및 Terraform 버전 관리","description":"","date":"2024-06-19 13:30","slug":"2024-06-19-DependabotGitHubandTerraformversionsmanagement","content":"\n![image](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_0.png)\n\n프로젝트가 성장함에 따라 언젠가는 패키지, 모듈 및 차트 버전을 업그레이드해야 할 필요성이 생길 것입니다.\n\n물론 수동으로 할 수도 있지만, 어느 정도까지만 가능합니다. 결국에는 물리적으로 모든 업데이트 사항을 추적하고 업데이트하는 것이 불가능해질 수 있습니다.\n\n이와 같은 프로세스를 자동화하는 다양한 솔루션이 있지만, 가장 일반적으로 사용되는 것은 Renovate와 Dependabot입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우크라옵스 슬랙 투표 결과에 따르면, Renovate가 훨씬 많은 투표를 받았으며 실제로 Dependabot보다 더 많은 작업을 수행할 수 있습니다.\n\n반면, Dependabot는 이미 GitHub 저장소에서 사용 가능하며 모든 가격 요금제에서 이용 가능합니다. 그러니까, GitHub를 사용하는 경우, Dependabot을 설정하려면 구성 파일을 추가하기만 하면 됩니다. 앞으로 봤을 때, Renovate를 설정하는 것이 더 쉬우나, 다음 게시물에서 더 자세히 다루겠습니다 — Renovate: GitHub 및 Helm 차트 버전 관리.\n\n실제로, Dependabot를 거의 모든 플랫폼에서 사용할 수 있습니다 — GitHub, Github 엔터프라이즈, Azure DevOps, GitLab, BitBucket 및 AWS CodeCommit 등. Dependabot를 실행하는 방법을 확인하려면 How to run Dependabot을 참조하세요.\n\n그러나 — 이게 제게는 큰 놀램이었습니다 — Dependabot은 Helm 차트와 함께 작동하지 않습니다. 그러나 Terraform에서 작동하며 이미 일부 파이썬 코드 저장소에서 사용 가능합니다. 그러니 먼저 그것에 대해 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다시 미래를 내다보면, 저는 Renovate를 훨씬 더 좋아했고, 이후에는 Renovate를 사용할 것입니다.\n\n# Dependabot가 작동하는 방식\n\n다음은 그 방식입니다:\n\n- 저장소에 Dependabot 구성 파일을 만듭니다.\n- 파일 내에서 무엇을 정확히 확인해야 하는지 설명합니다 — pip 라이브러리, Terraform 모듈 등을\n- 특히 관심 있는 것을 설명합니다 — 보안 업데이트 또는 버전 업데이트\n- 업데이트를 발견하면 — Dependabot은 Pull Request를 만들어 해당 업데이트에 대한 상세 정보를 추가합니다\n- …\n- 수익 창출!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 무엇을 할까요?\n\n- 우리는 모니터링을 위한 GitHub 저장소를 갖고 있어요\n- 거기에 Terraform 코드가 있고\n- Dependabot을 사용하여 버전 확인 및 PR 생성을 구성할 거예요\n\n문서 — Dependabot Quick Start Guide, dependabot.yml 파일 구성 옵션.\n\n지원되는 저장소 및 생태계 — Dependabot이 지원하는 시스템을 확인하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Dependabot과 Terraform\n\nTerraform의 맥락에서 Dependabot으로 모니터링할 수 있는 것은 프로바이더 및 모듈의 버전입니다.\n\n예를 들어, 제공자 버전이 설정된 versions.tf와 여러 모듈을 사용하는 lambda.tf와 같은 두 파일이 있습니다. 모듈에는 terraform-aws-modules/security-group/aws, terraform-aws-modules/lambda/aws 등이 있습니다:\n\n![이미지](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 Dependabot가 이들에서 버전을 모니터링하도록 시작하려면 디렉토리 .github를 생성하고 그 안에 dependabot.yml 파일을 만듭니다:\n\n![이미지](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_2.png)\n\n파일에 다음과 같이 매개변수를 설정합니다:\n\n```js\nversion: 2\nupdates:\n  - package-ecosystem: \"terraform\"\n    directory: \"/terraform\"\n    schedule:\n      interval: \"daily\"\n      time: \"09:00\"\n      timezone: \"Europe/Kyiv\"\n    assignees:\n      - arseny-zinchenko\n    reviewers:\n      - arseny-zinchenko\n    open-pull-requests-limit: 10\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n보편적으로 매개변수 이름에서 모든 것이 명확해요:\n\n- package-ecosystem: 이 설정이 Terraform을 위한 것이므로, 우리는 이것을 지정합니다\n- directory: Terraform 파일은 리포지토리 루트의 terraform 디렉토리에 있습니다\n- schedule: 체크 일정 - 먼저 dependabot.yml 파일을 추가하면 체크가 즉시 시작되며, 나중에 수동으로 실행할 수 있습니다\n- assignees and reviewers: 나를 위해 즉시 PR을 만들어주세요\n- open-pull-requests-limit: 기본적으로 Dependabot은 최대 5개의 PR을 엽니다. 이 매개변수로 증가시킬 수 있습니다\n\n리포지토리에 푸쉬하고 상태를 확인해보세요.\n\n리포지토리에서 Insights `Dependency graph` Dependabot로 이동하여 체크가 시작되었음을 확인하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_3.png)\n\nIn a minute, we’ll have open Pull Requests:\n\n![image](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_4.png)\n\n![image](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n동시에, Dependabot은 업데이트에 대한 세부 정보를 주석으로 추가합니다 — 릴리스 노트, 변경 내역 등:\n\n![이미지](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_6.png)\n\n그러나 이 모든 것이 어디서는 안 될 수도 있습니다.\n\n예를 들어, Lambda 모듈의 업데이트는 세부 정보 없이 생성되었습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_7.png)\n\nBut Renovate does it much better.\n\n# Dependabot, and GitHub Secrets\n\nAnother nuance is the GitHub Secrets that are available to Dependabot.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로젝트의 terraform 디렉토리에 변경 내용이 있는 PR이 올라오면, 우리는 GitHub Actions Workflow를 실행합니다. 해당 Workflow에서는 Terraform의 체크를 수행합니다 (GitHub Actions: Terraform deployments with a review of planned changes 참조).\n\n이 Workflow는 전용 저장소에 위치해 있으며, 접근하기 위해 GitHub 배포용 키가 GitHub Actions Secrets를 통해 호출하는 Workflow로 전달됩니다.\n\n그러나 Dependabot에서 시작된 GitHub Actions 작업에서 다음 단계가 실패했습니다:\n\n![Dependabot Error](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n워크플로 자체는 모든 비밀을 secrets: inherit:를 통해 전달합니다.\n\n```js\n...\njobs:\n  terraform-test:\n    # Reusable Workflow 파일 호출\n    uses: ORG_NAME/atlas-github-actions/.github/workflows/call-terraform-check-and-plan.yml@master\n    with:\n      aws-iam-role: ${ vars.AWS_IAM_ROLE }\n      aws-env: ${ vars.AWS_ENV }\n      pr-num: ${ github.event.pull_request.number }\n      environment: ops\n      slack-channel: '#cicd-devops'\n    secrets:\n      inherit\n```\n\n그러나 Dependabot에서는 이러한 비밀 정보를 Actions의 secrets 및 변수가 아닌 Actions의 secrets와 변수인 Dependabot에 별도로 설정해야 합니다:\n\n\u003cimg src=\"/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_9.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 비밀을 추가했고, 이제 확인이 작동합니다:\n\n![Dependabot, and private registries/repositories](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_10.png)\n\n# Dependabot 및 개인 레지스트리/저장소\n\n다른 것들 중에, 우리는 개인 저장소에 저장된 자체 Terraform 모듈을 가지고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성 보트에 액세스할 때 \"의존성 보트가 ORG_NAME/atlas-tf-modules에 액세스할 수 없습니다\"라는 오류가 발생합니다:\n\n![image](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_11.png)\n\n첫 번째 옵션은 dependabot.yml 파일에서이 저장소 또는 다른 레지스트리를 명시적으로 추가하는 것입니다. - 개인 레지스트리 구성 항목 참조.\n\n두 번째 옵션은 단순히 '액세스 권한 부여'를 클릭하는 것입니다. 이렇게 하면 조직의 모든 저장소에 대해 해당 저장소의 액세스가 열립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 테이블 태그를 마크다운 형식으로 변경하거나 수동으로 변경하세요. 조직 설정으로 이동한 후 `보안 코드` 및 `전역 설정`으로 이동하여 `사적 저장소에 Dependabot 액세스 권한 부여` 섹션에서 원하는 저장소에 대한 액세스를 추가하세요:\n\n![Dependabot GitHub and Terraform versions management](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_12.png)\n\n# Dependabot 및 수동 실행\n\n접근 권한을 추가했다면, 다시 저장소로 돌아가 Insights -\u003e Dependency graph -\u003e Dependabot으로 이동한 후 업데이트 확인을 클릭하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 작동 중입니다:\n\n![Image 1](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_13.png)\n\n![Image 2](/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_14.png)\n\n일반적으로 그게 전부에요. 이제 우리는 모든 저장소를 직접 관리하지 않아도 Terraform 업데이트를 받게 될 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한번 더 말해도, Renovate가 정말로 더 좋아. Renovate: GitHub을 보고, Helm Charts 버전 관리를 확인해봐.\n\n원문은 RTFM: Linux, DevOps, 그리고 시스템 관리에서 공개되었습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_0.png"},"coverImage":"/assets/img/2024-06-19-DependabotGitHubandTerraformversionsmanagement_0.png","tag":["Tech"],"readingTime":11},{"title":"Azure Storage Account에 개인 엔드포인트와 Terraform을 사용하여 컨테이너 문제 해결하는 방법","description":"","date":"2024-06-19 13:28","slug":"2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform","content":"\n\u003cimg src=\"/assets/img/2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform_0.png\" /\u003e\n\n오늘은 Terraform으로 Azure Storage Account와 Private Endpoint를 배포할 때 발생하는 일반적인 오류에 대해 이야기해보겠습니다.\n\n저희가 스토리지 계정 컨테이너를 추가하려고 시도하면, 다음과 같은 오류가 발생합니다:\n\n# 1. 우리의 시나리오\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 테라폼이 실행 중인 가상 머신이 있습니다.\n\n- 리소스 그룹 \"kopicloud-core-dev-we-rg\"\n- 가상 네트워크 \"kopicloud-core-dev-we-vnet\"\n- 서브넷 \"kopicloud-core-dev-we-subnet\"\n\n2. 기존의 \"privatelink.blob.core.windows.net\" 프라이빗 DNS 영역이 있습니다.\n\n- 리소스 그룹 \"kopicloud-core-dev-we-dns-rg\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 새로운 Azure Storage Account와 프라이빗 엔드포인트를 배포할 것입니다.\n\n- 리소스 그룹 \"kopicloud-storage-dev-we-rg\"\n- 가상 네트워크 \"kopicloud-storage-dev-we-vnet\"\n- 서브넷 \"kopicloud-storage-dev-we-endpoint-subnet\"\n\n# 2. Azure Storage Account와 프라이빗 엔드포인트를 배포하는 Terraform 코드\n\n이 코드에 대해 설명은 이 이야기에서 하지 않겠습니다. 더 자세한 내용은 \"Terraform을 사용한 Azure Storage Account의 프라이빗 엔드포인트\" 이야기를 확인해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 \"network-variables.tf\" 파일입니다:\n\n```js\nvariable \"network-vnet-cidr\" {\n  type        = string\n  description = \"네트워크 VNET의 CIDR\"\n}\n\nvariable \"network-endpoint-subnet-cidr\" {\n  type        = string\n  description = \"네트워크 서브넷의 CIDR\"\n}\n```\n\n아래는 \"network.tf\" 파일입니다:\n\n```js\n# 네트워크를 위한 리소스 그룹 생성\nresource \"azurerm_resource_group\" \"network-rg\" {\n  name     = \"kopicloud-storage-dev-we-rg\"\n  location = var.location\n}\n\n# 네트워크 VNET 생성\nresource \"azurerm_virtual_network\" \"network-vnet\" {\n  name                = \"kopicloud-storage-dev-we-vnet\"\n  address_space       = [var.network-vnet-cidr]\n  resource_group_name = azurerm_resource_group.network-rg.name\n  location            = azurerm_resource_group.network-rg.location\n}\n\n# Endpoint 서브넷 생성\nresource \"azurerm_subnet\" \"endpoint-subnet\" {\n  name                 = \"kopicloud-storage-dev-we-endpoint-subnet\"\n  address_prefixes     = [var.network-endpoint-subnet-cidr]\n  virtual_network_name = azurerm_virtual_network.network-vnet.name\n  resource_group_name  = azurerm_resource_group.network-rg.name\n\n  private_endpoint_network_policies_enabled = true\n\n  service_endpoints = [\"Microsoft.Storage\"]\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"storage-account.tf\" 파일:\n\n```js\n# 기존 Private DNS Zone 참조\ndata \"azurerm_private_dns_zone\" \"dns-zone\" {\n  name                = \"privatelink.blob.core.windows.net\"\n  resource_group_name = \"kopicloud-core-dev-we-dns-rg\"\n}\n\n# Private DNS Zone 네트워크 링크 생성\nresource \"azurerm_private_dns_zone_virtual_network_link\" \"network_link\" {\n  name                  = \"kopicloud-storage-dev-we-vnet-link\"\n  resource_group_name = data.azurerm_private_dns_zone.dns-zone.resource_group_name\n  private_dns_zone_name = data.azurerm_private_dns_zone.dns-zone.name\n  virtual_network_id    = azurerm_virtual_network.network-vnet.id\n}\n\n# 스토리지 계정 생성\nresource \"azurerm_storage_account\" \"storage\" {\n  name                = \"kopicloudstoragedevwesta\"\n  resource_group_name = azurerm_resource_group.network-rg.name\n  location            = azurerm_resource_group.network-rg.location\n\n  account_kind             = \"StorageV2\"\n  account_tier             = \"Standard\"\n  account_replication_type = \"LRS\"\n}\n\n# 프라이빗 엔드포인트 생성\nresource \"azurerm_private_endpoint\" \"endpoint\" {\n  name                = \"kopicloudstoragedevwesta-pe\"\n  resource_group_name = azurerm_resource_group.network-rg.name\n  location            = azurerm_resource_group.network-rg.location\n  subnet_id           = azurerm_subnet.endpoint-subnet.id\n\n  private_service_connection {\n    name                           = \"kopicloudstoragedevwesta-psc\"\n    private_connection_resource_id = azurerm_storage_account.storage.id\n    is_manual_connection           = false\n    subresource_names              = [\"blob\"]\n  }\n}\n\n# DNS A 레코드 생성\nresource \"azurerm_private_dns_a_record\" \"dns_a\" {\n  name                = \"kopicloudstoragedevwesta\"\n  resource_group_name = data.azurerm_private_dns_zone.dns-zone.resource_group_name\n  zone_name = data.azurerm_private_dns_zone.dns-zone.name\n  ttl                 = 300\n  records             = [azurerm_private_endpoint.endpoint.private_service_connection.0.private_ip_address]\n}\n```\n\n# 3. 공개 액세스 해제\n\n기본적으로 이 코드는 공개 액세스가 있는 스토리지 계정을 생성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform_1.png)\n\n공개 액세스를 종료해야만 Private Endpoint를 구현하는 의미가 있습니다.\n\n따라서 \"azurerm_storage_account\" 리소스를 수정하여 public_network_access_enabled = false 라인을 추가하겠습니다.\n\n```js\n// 스토리지 계정 생성\nresource \"azurerm_storage_account\" \"storage\" {\n  name                = \"${lower(replace(var.company,\" \",\"-\"))}${var.app_name}${var.environment}${var.shortlocation}sta\"\n  resource_group_name = azurerm_resource_group.network-rg.name\n  location            = azurerm_resource_group.network-rg.location\n\n  account_kind             = \"StorageV2\"\n  account_tier             = \"Standard\"\n  account_replication_type = \"LRS\"\n\n  public_network_access_enabled = false\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"Terraform Apply\" 명령을 실행하여 공개 액세스가 비활성화되었음을 확인했습니다.\n\n![이미지](/assets/img/2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform_2.png)\n\n# 4. 스토리지 계정 컨테이너 생성\n\n이제 다음 코드로 스토리지 계정 컨테이너를 생성할 차례입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 외부 저장소 계정용 Azure Storage 컨테이너 생성\nresource \"azurerm_storage_container\" \"external\" {\n  name                  = \"container\"\n  storage_account_name  = azurerm_storage_account.storage.name\n  container_access_type = \"private\"\n}\n```\n\n\"Terraform Apply\" 명령을 실행했는데 오류가 발생했습니다.\n\n# 4. 특정 네트워크에서 액세스 권한 활성화\n\n따라서 이 문제를 해결하기 위해 특정 네트워크에서의 공개 액세스를 허용할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 \"azurerm_storage_account\" 리소스를 수정하여 public_network_access_enabled = true 라인을 추가하겠습니다.\n\n```js\n// 저장소 계정 생성\nresource \"azurerm_storage_account\" \"storage\" {\n  name                = \"${lower(replace(var.company,\" \",\"-\"))}${var.app_name}${var.environment}${var.shortlocation}sta\"\n  resource_group_name = azurerm_resource_group.network-rg.name\n  location            = azurerm_resource_group.network-rg.location\n  account_kind             = \"StorageV2\"\n  account_tier             = \"Standard\"\n  account_replication_type = \"LRS\"\n\n  public_network_access_enabled = true\n}\n```\n\n또한 지정된 네트워크에서 액세스 허용하도록 \"Azure Storage Account Network Rules\" 리소스를 생성해야 합니다; 이 경우 Storage Account Subnet에서 액세스를 허용할 것입니다.\n\n```js\n# Azure Storage Account Network Rules 생성\nresource \"azurerm_storage_account_network_rules\" \"rules\" {\n  storage_account_id = azurerm_storage_account.storage.id\n\n  default_action = \"Deny\"\n  virtual_network_subnet_ids = [ azurerm_subnet.endpoint-subnet.id ]\n  bypass         = [\"Metrics\", \"Logging\", \"AzureServices\"]\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n“Terraform Apply” 명령을 실행했을 때 다시 403 오류가 발생했어요.\n\n# 5. Azure Storage Account 네트워크 규칙 업데이트\n\n가시성을 위해 규칙을 변경하여 VM이 Terraform을 실행할 때 서브넷에서의 트래픽을 허용하도록 할게요. 우리는 데이터를 사용하여 서브넷 ID를 가져올 거에요.\n\n```js\n# 핵심 서브넷을 참조합니다\ndata \"azurerm_subnet\" \"core\" {\n  name                 = \"kopicloud-core-dev-we-subnet\"\n  virtual_network_name = \"kopicloud-core-dev-we-vnet\"\n  resource_group_name  = \"kopicloud-core-dev-we-rg\"\n}\n\n# Azure Storage Account 네트워크 규칙 생성\nresource \"azurerm_storage_account_network_rules\" \"rules\" {\n  storage_account_id = azurerm_storage_account.storage.id\n\n  default_action = \"Deny\"\n  virtual_network_subnet_ids = [ azurerm_subnet.endpoint-subnet.id, data.azurerm_subnet.core.id ]\n  bypass         = [\"Metrics\", \"Logging\", \"AzureServices\"]\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"Terraform Apply\" 명령을 실행했는데 다시 403 오류가 발생했어요.\n\n포털을 살펴보니 규칙이 구현되지 않았다는 것을 알았어요. 컨테이너가 이전에 실패했기 때문이에요.\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform_3.png\"/\u003e\n\n# 6. 코어와 스토리지 가상 네트워크 간 피어링 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 후에, 어쩌면 두 가상 네트워크 사이에 피어링이 필요할지도 모른다고 생각했어요.\n\n그래서 \"peering.tf\" 파일을 만들고 이 코드를 추가했어요:\n\n```js\nlocals {\n  core_rg_name = \"kopicloud-core-dev-we-rg\"\n  core_vnet_name = \"kopicloud-core-dev-we-vnet\"\n}\n\n// Core VNET에 대한 참조\ndata \"azurerm_virtual_network\" \"core\" {\n  name                = local.core_vnet_name\n  resource_group_name = local.core_rg_name\n}\n\n// Core에서 스토리지로 피어링 생성\nresource \"azurerm_virtual_network_peering\" \"core-to-storage\" {\n  name                      = \"Core-to-Storage\"\n  resource_group_name       = local.core_rg_name\n  virtual_network_name      = local.core_vnet_name\n  remote_virtual_network_id = azurerm_virtual_network.network-vnet.id\n}\n\n// 스토리지에서 Core로 피어링 생성\nresource \"azurerm_virtual_network_peering\" \"storage-to-core\" {\n  name                      = \"Storage-to-Core\"\n  resource_group_name       = azurerm_resource_group.network-rg.name\n  virtual_network_name      = azurerm_virtual_network.network-vnet.name\n  remote_virtual_network_id = data.azurerm_virtual_network.core.id\n}\n```\n\n그리고 \"Terraform Apply\" 명령어를 실행했더니, 마침내 우리 코드가 잘 실행되고 있어요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최종 네트워크 구성은 다음과 같아야 합니다:\n\n![이미지](/assets/img/2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform_4.png)\n\n그리고 이것이 전부에요. 만약 이 이야기를 좋아하셨다면 👏을 눌러 서포트를 보여주세요. 읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoTroubleshootanAzureStorageAccountwithaPrivateEndpointandaContainerwithTerraform_0.png","tag":["Tech"],"readingTime":12},{"title":"2024년에 사용할 수 있는 가장 유용한 Terraform 도구들","description":"","date":"2024-06-19 13:26","slug":"2024-06-19-MostUsefulTerraformToolstoUsein2024","content":"\n개발자로서 2년정도 경력이 있고, 많은 도구들이 갑자기 등장하는 것을 보았어요. 요즘 제품을 쉽게 만들기 때문만이 아니라, 전체 Terraform 개발 라이프사이클 내에서 해결해야 할 많은 문제들이 있기 때문이에요. 그리고 제품의 각 미세 카테고리에서 오픈 소스, 무료, 프리미엄, 또는 맞춤 요금제와 같이 수천 가지 선택지가 있는 걸 잊지 마세요.\n\n그래서, 여기 귀하는 위한 모든 것을 간단히 해주기 위해 발견하고 철저히 테스트한 최고의 해결책을 소개합니다:\n\n# 전통적인 데브옵스 엔지니어가 사용하는 도구\n\n![Most Useful Terraform Tools to Use in 2024](/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 할 일은 Infrastructure as Code (IaC)의 기본 형태로 돌아가서 엔지니어들이 일을 어떻게 하는지와 전체 라이프사이클이 얼마나 어려운지를 이해하는 것이었습니다.\n\n## 인프라 다이어그램:\n\n인프라 다이어그램은 종종 화이트보드에 그려졌습니다. Microsoft Visio나 Draw.io가 최고의 다이어그램 솔루션이었지만, 이 다이어그램들은 그저 다이어그램일 뿐이었고 종종 오래되어 있었습니다.\n\n## 코드 정의:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n공학자들은 CLI(Command Line Interface)를 사용하여 코드를 정의했어요.\n\n## 버전 관리 및 배포:\n\n오픈 소스 인프라스트럭처 코드(IaC) 도구인 terraform과 같은 도구들이 인프라 버전 관리에 인기를 끌게 되었어요. 지금은 OpenTofu와 같은 것이 등장해서, 좀 다른 것 같아요. 모든 것은 Git을 통해 배포되었어요.\n\n## 인프라스트럭처 관리:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전체 인프라는 클라우드 제공 업체 콘솔을 통해 관리되었습니다. 클라우드 제공 업체 중심의 자원 관리가 일반적이었습니다.\n\n## 모니터링:\n\nDatadog와 같은 도구가 등장하기 전에는 홈메이드 제품이 초기에 인프라 모니터링에 사용되었습니다.\n\n## 보안 도구:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오픈 소스 보안 도구들은 여전히 널리 사용되고 있어요. Terrascan, Checkov, 그리고 OPA (Open Policy Agent)와 같은 도구들은 여전히 중요합니다.\n\n# Terraform을 위한 도구들\n\n![이미지](/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_1.png)\n\n## TFLint: 코드 품질\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_2.png\" /\u003e\n\nTFLint는 Terraform을 위한 강력한 오픈 소스 린트 도구로 솟아납니다. 그 실력은 구문 오류부터 리소스 명명 규칙 및 사용되지 않는 변수까지 다양한 문제를 식별하는 데 있습니다. TFLint는 여러분의 도구 상자의 필수품으로, Terraform 코드가 높은 품질 기준을 준수하도록 보장합니다.\n\n## Terrascan: 보안 및 규정 준수\n\n\u003cimg src=\"/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_3.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTerrascan은 보안 및 규정 준수에 초점을 맞춘 정적 코드 분석기로 무대에 올라섭니다. 전통적인 린트 이상으로 나아가 구성 오류, 보안이 취약한 리소스 설정 및 정책 위반을 식별합니다. 보안이 최우선 사항인 만큼 Terrascan은 Terraform 인프라를 견고하게 만들어 주는 경계를 지킵니다.\n\n## Checkov: Hashicorp Sentinel 대체안\n\n![이미지](/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_4.png)\n\nCheckov은 인프라 코드 파일을 세심하게 검사하는 보안 스캐너로 등장합니다. Checkov의 역할은 Terraform 코드를 면밀히 검사하여 보안 취약성과 정책 위반 사항을 발견하는 것입니다. 사이버 보안이 중요시되는 시대에, Checkov은 감시병으로 작용하여 귀하의 인프라가 견고하고 규정을 준수할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 인프라코스트: 클라우드 비용\n\n![이미지](/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_5.png)\n\n테라폼 배포 비용을 예측하는 것은 효과적인 예산 편성에 중요합니다. 인프라코스트는 오픈 소스 툴로, 정확한 비용 추정을 제공하여 이러한 요구를 지원합니다. 다양한 클라우드 공급업체와 온프레미스 인프라를 수용함으로써 인프라코스트는 인프라 요구 사항을 절충하지 않고 예산 제약 내에서 유지할 수 있도록 합니다.\n\n## 브레인보드: 테라폼 GUI\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Brainboard](https://miro.medium.com/v2/resize:fit:1400/1*F9cAb0NT-xSvFhnEXx9SiQ.gif)\n\nBrainboard은 클라우드 인프라 관리를 위한 최첨단 플랫폼으로 나타납니다. 그 강점은 복잡한 클라우드 아키텍처를 디자인, 배포 및 관리하는 직관적인 시각적 인터페이스를 제공하는 데 있습니다. 프로세스를 단순화하고 협업을 강화함으로써, Brainboard는 클라우드 인프라를 효율적이고 확장 가능하게 만들어 현대의 데브옵스 팀에게 꼭 필요한 도구가 됩니다.\n\n## Terragrunt: Module Management\n\n![Terragrunt](/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTerragrunt은 Terraform 모듈의 조정 및 배포를 관리하는 도구입니다. 모듈 처리 기능 이상으로, Terragrunt은 Terraform 테스트를 용이하게하고 전체 개발 수명주기를 최적화하는 데 능숙합니다.\n\n## Terradozer: 사용되지 않는 인프라를 위한\n\n![Terradozer](/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_7.png)\n\nTerradozer는 강력한 정리 도구로 등장하여 Terraform 상태 파일의 모든 리소스를 파괴하는 것을 목적으로 합니다. 이 기능은 사용되지 않는 인프라를 정리하고 효율적인 환경을 조성하는 데 매우 소중합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Eagle-Eye: 종속성 시각화\n\n![이미지](/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_8.png)\n\n이글 아이(Eagle-Eye)란 복잡한 Terraform 구성을 탐색하는 것이 더 쉬워집니다. AWS를 위한 이 강력한 시각화 도구는 리소스 간 종속성에 대한 상세한 그래픽 표현을 생성하여 디버깅 및 복잡한 인프라 구성 이해에 중요한 통찰을 제공합니다.\n\n## DiagramGPT: D2 다이어그램\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_9.png)\n\nEraser.io의 DiagramGPT는 자연어 프롬프트를 사용하여 다이어그램을 만드는 혁신적인 도구로 빛을 발합니다. 고급 AI 기술을 활용하여 텍스트 설명에서 자세하고 정확한 다이어그램을 생성하는 과정을 간단화합니다. 이 도구는 생산성과 명확성을 향상시켜 전문가들이 문서 작성과 시각화 작업을 간소화하는 데 꼭 필요한 자산입니다.\n\n하나의 도구로는 모든 요구 사항이 충족되지 않지만, 특정 요구 사항마다 완벽한 도구가 있습니다. 현명하게 선택하고 도구 상자에 새로운 도구를 추가해야 하는지 알려주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_0.png"},"coverImage":"/assets/img/2024-06-19-MostUsefulTerraformToolstoUsein2024_0.png","tag":["Tech"],"readingTime":7}],"page":"40","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"40"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>