<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/15" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/15" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-V5DKFTZ6BX"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-V5DKFTZ6BX');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/baeec1f16d6ea8b8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/baeec1f16d6ea8b8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_buildManifest.js" defer=""></script><script src="/_next/static/R1x9p1CQYDDJESXyLXKOK/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="100일간의 스팀 세일 분석" href="/post/2024-05-23-100DaysofSteamSalesAnalysis"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="100일간의 스팀 세일 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="100일간의 스팀 세일 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">100일간의 스팀 세일 분석</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로듀서로부터 온 편지" href="/post/2024-05-23-LetterfromtheProducer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로듀서로부터 온 편지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-LetterfromtheProducer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로듀서로부터 온 편지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">프로듀서로부터 온 편지</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로모션에 대한 공학 매니저의 고백" href="/post/2024-05-23-ConfessionofanEngineeringManageronPromotions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로모션에 대한 공학 매니저의 고백" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로모션에 대한 공학 매니저의 고백" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">프로모션에 대한 공학 매니저의 고백</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="꿈같은 원격 인턴십을 얻은 방법" href="/post/2024-05-23-HowILandedaDreamRemoteInternship"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="꿈같은 원격 인턴십을 얻은 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="꿈같은 원격 인턴십을 얻은 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">꿈같은 원격 인턴십을 얻은 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요" href="/post/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">24<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="분산 애플리케이션에서 캐싱 마스터하기" href="/post/2024-05-23-MasteringCachinginDistributedApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="분산 애플리케이션에서 캐싱 마스터하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="분산 애플리케이션에서 캐싱 마스터하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">분산 애플리케이션에서 캐싱 마스터하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AI-강화 주제 탐구로 예술 창작을 재정의하기" href="/post/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AI-강화 주제 탐구로 예술 창작을 재정의하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AI-강화 주제 탐구로 예술 창작을 재정의하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AI-강화 주제 탐구로 예술 창작을 재정의하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 " href="/post/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl"> 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 </strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법" href="/post/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="크로스 플랫폼 앱 개발 로드맵" href="/post/2024-05-23-Cross-PlatformAppDevelopmentRoadmap"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="크로스 플랫폼 앱 개발 로드맵" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-23-Cross-PlatformAppDevelopmentRoadmap_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="크로스 플랫폼 앱 개발 로드맵" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">크로스 플랫폼 앱 개발 로드맵</strong><div class="PostList_meta__VCFLX"><span class="date">May 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link posts_-active__YVJEi" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"100일간의 스팀 세일 분석","description":"","date":"2024-05-23 13:36","slug":"2024-05-23-100DaysofSteamSalesAnalysis","content":"\n게임 개발 산업에 종사한 사람이라면, 성공적인 게임을 만드는 것이 얼마나 어려운지 알 것입니다. 누구도 그 공식을 알아내지 못했습니다. 모든 것을 올바르게 해도 실패할 수 있죠.\n\n우리는 소중한 성공 사례에 감격합니다. Stardew Valley, Lethal Company, Undertale. 가능합니다. 그러나 성공 사례마다 수천 개의 잊혀진 실패 사례가 있습니다.\n\n우리는 우리의 열정적인 프로젝트에 수백 시간을 투자합니다. 고용주들이 수십만 달러를 쓸 것이라고 확신할 수도 있는 노동이죠. 대신 우리는 모든 걸 스스로에게 걸어, 대부분 몇 달러만 돌려받게 됩니다.\n\n우리는 용감한 건지, 그냥 바보인 건지요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 질문을 해결하고 동료 개발자들에게 희망을 줄 수 있기를 바라며, 2023년 1월 1일부터 스팀에서 출시된 게임 100일을 살펴보고 판매 성적을 분석하여 모두가 꿈을 이루는 확률을 알아보았습니다.\n\n# 개요\n\n100일 동안 총 2823개의 유료 게임이 출시되었으며, 하루 평균 새로운 게임은 28개입니다.\n\n스팀 수수료를 고려한 평균 매출은 228,723달러(미국 달러)였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n처음에는 좋아 보일 수 있지만, 스팀 세일은 공격적인 파레토 분포를 따릅니다. 이는 일반적으로 '80:20' 규칙으로 알려진데, 입력의 20%가 결과의 80%를 만든다는 의미입니다.\n\n스팀 세일은 조금 더 극단적입니다:\n\n\n![Steam Sales Analysis](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png)\n\n\n중앙값 수익, 즉 평균 게임이 벌어들인 금액에 더 관심이 있습니다. 이를 시각화하기 쉽게 만들기 위해 10만 달러 이상 벌어든 모든 게임을 제거해 보겣습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Image](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_1.png)\n\n`스팀`의 수익 중앙값은 `대단한` $799 미국 달러였습니다. 처참해 보일 수 있지만, 이 데이터를 다른 말로 바꾸면 더 희망적으로 보일 수 있습니다.\n\n출시된 게임 중 1개당 $1,000,000 이상을 벌어들인 게임은 42개 중 1개이며, 매주 4개의 초대 성공적인 게임을 나타냅니다.\n\n게임 중 1개당 $100,000 이상을 벌어들인 게임은 12개 중 1개이며, 주당 17개의 성공적인 게임을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 당신의 게임이 상위 8%에 들면 생계를 유지할 수 있어요. 상위 2%에 들면 거액의 수익을 올릴 수 있어요.\n\n어렵긴 하지만 불가능하진 않아요.\n\n안타깝게도, 5개 중 1개 게임은 $100 미만 수익을 올렸어요. 매주 40개의 실패한 게임이 있어요.\n\n**방법**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSteams API를 사용하여 100일 간의 게임 출시를 가져 와 파싱하기 위해 파이썬을 사용했습니다. 나쁜 항목을 제거하고 JSON 구조를 단순화 한 후 CSV로 변환하여 다음과 같이 구글 스프레드 시트로 가져왔습니다:\n\n[구글 스프레드 시트 링크](https://docs.google.com/spreadsheets/d/1T-Tw6PwxEAqYMnos5pYwRbwcNVacYn9zCt6HpL9jLfQ/edit?usp=sharing)\n\n\u003cimg src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_2.png\" /\u003e\n\n스팀 API에서 얻을 수 없는 유일한 측정 항목은 수익이었습니다. 그러나 스팀 게임이 소유자 대 리뷰 비율이 30 대 1로 매우 잘 알려져 있으며 이는 모든 게임에 90%의 상관 관계를 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소스: https://vginsights.com/insights/article/further-analysis-into-steam-reviews-to-sales-ratio-how-to-estimate-video-game-sales\n\n스팀은 플랫폼의 매출에서 30%의 수수료를 가져갑니다. 이는 순수 매출로 이어집니다.\n\n# 양적 데이터\n\n장르, 콘텐츠 등급 및 VR 지원과 같은 기능과 같은 요인별 중앙값 매출을 분석해 봅시다. 먼저 장르부터 시작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_3.png\" /\u003e\n\n친구들 게임이 MMO RPG보다 현저히 성적이 안 좋다는 것을 알 수 있어요. 하지만 이러한 모바일 게임들이 몇 일 만에 만들어질 수 있다는 사실을 고려해야 해요. 한편 MMO는 큰 예산과 수 년의 생산 시간을 요구해요.\n\n다음은 플랫폼 분포를 살펴봅시다.\n\n\u003cimg src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파레토 분포에 관한 보편적인 사실 중 하나는 그의 공격적인 정도가 데이터 세트의 크기와 비례한다는 것입니다. 다시 말해, 경쟁이 더 많은 시장에서는 불평등이 더 많이 나타납니다.\n\n간단히 맥(mac)의 게임이 더 적기 때문에 경쟁이 적고, 구매자가 게임을 선택할 기회가 더 많습니다.\n\n재미있게도, VR의 수익성은 크게 감소했습니다. 일정 시점에는 게임 수가 적어서 매출 중앙값이 $150,000에 이르렀습니다.\n\n마지막으로 콘텐츠 등급을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_5.png)\n\n데이터 세트에서 대략 10%의 게임이 '성인 전용'으로 표시되어 있습니다. 이들은 평균적인 게임만큼 잘 할 수 있었습니다. 다른 한편으로, 폭력은 명백히 경쟁에서 우위를 차지했습니다.\n\n이 데이터의 타당성도 살펴보겠습니다. 각 게임이 출시 월에 따라 얼마나 많은 수익을 올렸는지부터 시작해 보죠.\n\n![image](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_6.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2023년 1월 1일을 선택한 이유는 데이터를 최근 것으로 유지하면서도 게임이 수익을 얻을 수 있는 충분한 시간을 주기 위해서예요.\n\n여기서 볼 수 있듯이 중간 수준의 게임은 한 해 후에도 월 평균 90달러 정도의 수익을 올리고 있어요.\n\n마지막으로, 상관관계와 인과관계를 다루고 있음을 강조하기 위해, 게임 이름의 첫 글자로 매출을 시각화한 것이 재미있을 것 같아서요.\n\n![그림](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 게임 제목을 'y'로 시작하게 하면 'v'로 시작하는 것보다 수익이 15배 많아진다는 정말인가요?\n\n아마 그렇지 않을 거에요.\n\n데이터를 살펴보는 것이 중요하지만, 이렇게 많은 불확실성 속에서 세세한 부분에 대해 파고들어가는 것은 그다지 유용하지 않을 수 있어요.\n\n# 질적 데이터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 확실히 첫 번째로 스팀 세일을 분석하려는 사람은 아니에요. 이미 그에 관한 전체 웹사이트들이 있어요. 이 연구를 시작한 후에야 알게 된 사실이에요:\n\n하지만, 질적 연구에 참여하는 사람을 별로 보지 못해요. 즉, 개별 항목을 보다 자세히 살피는 것이죠. 제 데이터 세트에 게임 스크린샷을 추가한 이유 중 하나는 어떤 게임이 잘 되고 있는지 감을 잡을 수 있도록 도와주고자 했기 때문이에요.\n\n그래서 이제 3가지 예시를 질적으로 분석해보려고 해요:\n\n- 데이터를 기반으로 매우 성공적인 게임이지만, 사실 그렇지 않아야 했던 게임.\n- 대부분의 개발자에게 이룰 수 있는 것처럼 보이는 성공한 게임들.\n- 실패한 게임(또는 숨겨진 보석). 실패했지만, 더 나은 성과를 이루었을지도 모르는 게임들.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 놀랍게 성공한\n\nPizza Tower ($20,033,360):\n\n![Pizza Tower](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_8.png)\n\nPizzas Tower는 GameMaker로 만든 '잘 못 그린' 예술이 특징인 2D 플랫포머 게임입니다. 이런 상황에도 불구하고 Pizza Tower는 풍자, 주제, 혁신을 적절히 조합하여 성공을 거두었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2D 플랫포머는 가장 경쟁력이 있고 매출 성적이 가장 낮은 장르 중 하나입니다. Pizza Tower는 모든 규칙을 깨고 어떤 꿈의 게임이든 가능함을 보여줍니다.\n\n4년 개발 주기로 2,000만 달러의 매출을 달성했어요.\n\n## 중간 성공적이고 가능성 있는 게임\n\nInto the Flames ($406,627)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_9.png\" /\u003e\n\nhttps://store.steampowered.com/app/1222300/Into_The_Flames/\n\nInto the Flames는 활발히 개발 중인 소방 시뮬레이션 게임으로, 한 명의 개발자가 개발하고 있을 수 있습니다. 그래픽은 최고는 아니지만, 어떤 흥미를 끌고 있는 특정 주제를 다루고 있습니다.\n\n제 꿈의 세팅($255,085)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n~~\u003cimg src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_10.png\" /\u003e~~\n\n[링크](https://store.steampowered.com/app/2200780/My_Dream_Setup/)\n\n내 꿈의 세팅은 간단하지만 매우 정교한 시뮬레이션 게임으로, 최고의 게이밍 룸을 만드는 데 초점을 맞추고 있습니다.\n\n이는 모든 게이머가 익숙한 주제를 다루고 있으며, $5의 가격표로 쉽게 구매할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBeton Brutal ($117,945)\n\n![Screenshot](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_11.png)\n\nAnother game from a solo developer. A single player parkour game with some beautiful, brutalist inspired architecture.\n\nFinding success with any of the above games would, at the very least, fund your solo development endeavors for years to come.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 실패한 게임 (숨은 보물들)\n\n지금까지 카테고리 예시를 찾는 것은 쉬웠습니다. 왜냐하면 우리는 게임 중 상위 8%만 살펴보면 되기 때문이죠. 이제 우리는 그 꿈을 이루지 못한 2600개의 다른 타이틀로 깊게 파고들어봅니다.\n\n좋은 소식은 무언가 돋보이는 게임을 발견하려고 수천 개의 게임을 스크롤해야 했다는 것입니다. 즉, 대부분의 게임들이 열등한 위치에 있는게 타당하다는 것을 뜻하는 더 좋은 방법입니다.\n\nA Rum Tale ($63)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_12.png)\n\n[A Rum Tale](https://store.steampowered.com/app/2246310/A_Rum_Tale/)\n\n이 게임은 정말 잘 만들어진 플랫포머 게임입니다. 하지만 리뷰가 단 3개밖에 없네요.\n\n그래픽이 탁 트이고 체적 안개 기능까지 갖추고 있는데, 이 정도면 좀 더 많은 관심을 받았으면 하는데요. 소규모 팬덤도 없는 것이 놀랍네요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 정보를 찾기 어려울 수 있습니다. 이는 마케팅 실패를 보여줄 수 있습니다.\n\n플레임 키퍼 ($9,933)\n\n![이미지](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_13.png)\n\n[링크](https://store.steampowered.com/app/1374230/Flame_Keeper/)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n귀엽고 테마가 매력적인 액션 로그 라이트 게임입니다. $9,000에 매력적인 요소를 보였지만, 개발자가 투자금을 회수했는지 의문스럽습니다.\n\n아마도 75%의 리뷰 평점 때문에 인기를 얻지 못한 것 같아요.\n\n킹에게 공격 ($198)\n\n![이미지](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://store.steampowered.com/app/2108410/Attack_on_King_Reloaded/\n\n이 VR 게임은 RPG 전략 장르를 완전히 몰입형으로 조합한 흥미로운 작품입니다. 정교한 그래픽을 갖추고 있는 것으로 보입니다.\n\n그러나 독특한 스타일에도 불구하고 주목을 받지 못하고 있다고 하네요.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 연구 결과를 기반으로, 이것은 나에게 그리고 다른 인디 개발자들에게 제안할 팁입니다.\n\n## 큰 그림을 그리라아니면 집에 귀환하라.\n\n게임을 작게 유지하는 것에 대한 모든 관습적인 조언에도 불구하고, 자신이 감당할 수 있는 것 이상의 일을 성공적으로 해낸 개발자들이 가장 높은 곳에 도달하는 것처럼 보입니다.\n\n왜냐하면 이 세계는 승자가 모두를 가져가는 것이기 때문입니다. '괜찮은' 게임을 만들었다고해서 어떤 칭찬도 받을 수 없는 것이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게임이 복잡해야 한다는 뜻은 아니에요. 간단한 게임도 충분하죠. 그저 꼭 필요한 것만 잘 갖추어 주면 돼요. 예를 들어, 예술, 상점 페이지, 음악, 시각 효과, 게임 플레이, 플레이어 경험 등이 선택한 장르에 맞게 최고 수준이어야 해요.\n\n## 향수를 활용하세요\n\n개발자로서 우리는 창의성과 독창성을 자랑스러워해요. 여러분이 좋아하는 게임을 그대로 복사해서 만들라는 건 아니에요. 그런 게임들은 대체로 성공하지 않거든요. 하지만 사랑받는 시리즈에서 영감을 받으면 플레이어들과 감성적으로 연결될 수 있어요.\n\n만일 여러분의 게임 이미지가 플레이어들에게 좋은 추억을 떠올리게 하면서 동시에 새롭고 흥미로운 것을 제공한다면, 누르는 클릭을 유도하는 데 성공할 가능성이 높아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오늘날에도 '뱀파이어 생존자' 장르 중에서 새로운 게임들이 약간 다르고 조금 더 나은 점으로 성공을 거두고 있어요.\n\n새로운 장르를 창조하는 것은 판매를 한다고 느껴질 수도 있지만, 플레이어들에게 자신의 게임을 이해하고 그 시간과 돈을 투자하는 가치가 있다고 설득하는 것은 어렵다는 문제가 있어요.\n\n## 위대함은 부정할 수 없어요.\n\n매주 스팀에서는 매출이 100만 달러 이상이 될 4개의 게임이 출시되어요. 그것은 연간 200개 이상이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n200 명 중 한 명이 될 수 있다고 믿나요? 제가 그렇게 생각해요. 그게 아니었다면 이 글을 읽고 있지 않으셨을 거예요.\n\n위대한 게임은 부정할 수 없어요. 그것들은 피할 수 없어요. 그만큼 열려 있는 가능성이 크거든요.\n\n당신의 게임에서 '출시' 버튼을 누르면, 만약 그 날 다른 27명이 출시한 게임보다 나은 퀄리티라면, 당신은 성공했다고 볼 수 있어요.\n\n그렇지 않다면, 내일이 또 있을 거예요. 함께 힘내봐요!\n","ogImage":{"url":"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png"},"coverImage":"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png","tag":["Tech"],"readingTime":9},{"title":"프로듀서로부터 온 편지","description":"","date":"2024-05-23 13:35","slug":"2024-05-23-LetterfromtheProducer","content":"\n# 2024년 5월\n\n![이미지](/assets/img/2024-05-23-LetterfromtheProducer_0.png)\n\n안녕하세요,\n\nBitcraft Closed Alpha(1)가 4월 30일에 종료되었고, 참으로 멋진 여정이었습니다! 먼저, 참가해 주신 모든 테스터 여러분께 감사드립니다. 피드백을 공유해 주시고 버그를 신고해 주신 노력에 진심으로 감사드리며, 가장 중요한 것은 언제나 함께하는 커뮤니티 여러분이 조금 험난한 여정 속에서도 인내심과 이해를 보여 주신 점에 감사드립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 것이 처음에는 잘 진행되었지만 며칠 지나고 나면 몇 가지 문제가 발생하기 시작했고, 특히 여러 플레이어들이 긴 시간 동안 동일한 세계를 공유할 때 그 문제들이 더욱 두드러지게 나타났습니다. 바로 이것이 테스트의 요점입니다 — 하지만 어쨌든, 서버를 두 달 이상 닫아놓은 것은 우리가 희망하지 않았던 일이었습니다. BitCraft를 다시 작동시키기 위해 힘들게 노력하는 동안 커뮤니티로부터 받은 지원에 다시 한 번 감사드립니다.\n\n![LetterfromtheProducer_1](/assets/img/2024-05-23-LetterfromtheProducer_1.png)\n\n아울러, 알파 테스트 중 BitCraft의 비디오를 제작하고 스트리밍한 모든 콘텐츠 크리에이터들에게도 인사를 전합니다. 우리는 프리-알파에서 클로즈드 알파로 전환된 게임의 NDA가 없을 위험이 있었고, 그것이 완성도 있는 게임 경험을 제공하지 않을 것이라는 것을 알고 있었습니다. 여러분 모두가 스트리밍하면서 실시간으로 기술적 문제를 다루는 동안 훌륭한 대우를 해 주고 이해해 주셨습니다.\n\n다행히도 몇 번의 야행 끝에 BitCraft를 다시 발표할 수 있는 상태로 만들었으며, 두 번째 테스트의 후반부는 비교적 원활하게 진행되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![LetterfromtheProducer_2](/assets/img/2024-05-23-LetterfromtheProducer_2.png)\n\n테스트 서버를 종료한 다음 주, Clockwork Labs 팀은 회사 워크샵에 참석했어요! 이번이 많은 분들이 오랜 시간 동료들을 첫 만남했던 시간이었어요! 저희는 등산, 보트 여행, 탈출 게임, 캠프파이어 모임을 통해 에너지를 모았고 BitCraft, SpacetimeDB 및 Clockwork Labs 전체의 다음 단계를 논의하고 계획했어요.\n\n![LetterfromtheProducer_3](/assets/img/2024-05-23-LetterfromtheProducer_3.png)\n\n이제 저희는 돌아와서 다가올 도전에 대처할 준비가 되었어요. 하지만 먼저, BitCraft Closed Alpha one에서 배운 내용을 간단히 살펴볼게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![LetterfromtheProducer_4](/assets/img/2024-05-23-LetterfromtheProducer_4.png)\n\nRound-up — Closed Alpha 1\n\nLet’s start with a few numbers. 6452 players tested BitCraft for more than one hour. A total of 2211 claim totems have been built. We will make adjustments to the onboarding experience here, to make players feel less pressured to immediately settle down but maybe join a claim during their first steps in BitCraft. 128 claims had 5 or more members and 83 players had joined the largest settlement.\n\n![LetterfromtheProducer_5](/assets/img/2024-05-23-LetterfromtheProducer_5.png)\n\nWe were excited to see testers building larger villages and cooperating to quickly leave the Stone Age and reach higher-tier technology. Many players started specializing, and we are happy with the direction the cooperative gameplay went with coordination. The tester feedback will help us further improve, polish, and continuously develop the basic systems already in place like chat and claim management. Specifically, we will also address the hurdles some solo testers faced with their claim — nobody should have to worry about losing their progress during the first hours of playing BitCraft. But everything considered, we are happy with the results and believe that the town-scale gameplay is heading in the right direction.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 기계 및 구현을 더 자세히 살펴봐야 하는 요소는 플레이어 간 상품 거래입니다. 시험 결과, 정착지 간 번창하는 거래에 필요한 적절한 도구와 인센티브가 아직 부족하다는 것이 확인되었습니다. 게임 디자이너들은 많은 플레이어와 이야기를 나누어 상황을 완전히 이해하고 식별된 문제를 해결할 계획을 이미 가지고 있으며, 이는 비트크래프트의 상인 생활을 재미있고 보람찬 경험으로 만들어 낼 것입니다.\n\n또한 이동 시스템이 있습니다. 우리는 클릭해서 이동하는 시스템을 구현함으로써 최상의 장기적 게임 경험을 제공할 것으로 믿지만, 사실은 거의 모든 새로운 테스터가 적응하는 데 시간이 필요하다는 것이 분명해졌습니다. 우리는 WASD 이동을 요청하는 열정적인 초기 피드백을 받았지만, 익숙해지면 포인트투클릭이 더 나은 편리한 게임 경험을 제공한다는 것에 대해 숙련된 테스터들 간에 토론이 이루어졌습니다.\n더 나은 경험을 위해 나아가면서 첫날 잠재적 플레이어를 잃는 것은 분명히 우리의 의도가 아닙니다. WASD 이동이 구현된 이후 나중에 Alpha Test(닫힌 알파 2가 아님)를 실행할 계획입니다. 이 테스트에서의 데이터와 피드백은 우리가 올바른 방향으로 나아갈 수 있도록 도와줄 것입니다.\n\n이제 다음 단계 — 닫힌 알파 2\n우리의 현재 계획은 2024년 6월 16일에 다음 테스트를 시작하는 것입니다. 알파 2는 제국 시스템의 첫 번째 반복 테스트에 초점을 맞출 것입니다. 이는 데이터 및 피드백을 수집하기 위해 진행되는 짧은 시범 테스트로 예상됩니다.\n기간, 테스터 수 및 초대 절차 등 세부 정보는 아직 논의 중에 있습니다. 추후 공지를 통해 안내해드릴 예정입니다.\n다음 테스트에서 제국 시스템이 중점이 될 것이지만, 기존 콘텐츠를 계속해서 보강할 것입니다. 게임 밸런스 개선, 새로운 아트 자산 및 다양한 세부사항이 시간이 지남에 따라 추가될 것으로 기대할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n감사합니다! 더 많은 소식을 기대해주세요!\n\n감사합니다,\nAlessandro\n","ogImage":{"url":"/assets/img/2024-05-23-LetterfromtheProducer_0.png"},"coverImage":"/assets/img/2024-05-23-LetterfromtheProducer_0.png","tag":["Tech"],"readingTime":4},{"title":"프로모션에 대한 공학 매니저의 고백","description":"","date":"2024-05-23 13:33","slug":"2024-05-23-ConfessionofanEngineeringManageronPromotions","content":"\n\n![이미지](/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png)\n\n많이 들어온 것 중에 한 가지 예제로 좋은 매니저의 핵심 지표는 누군가를 승진시키는 능력이라고 들거나 들어 봤습니다. 표면적으로는 충분히 합리적으로 들립니다. 결국, 매니저는 자신의 사람들을 승진시킬 수 없다면 무엇을 하는 걸까요?\n\n더 깊이 들어가보면, 이 명제는 오해를 불러일으킵니다.\n\n저는 듣긴 했고, 유감스럽게도 스스로도 이를 말해본 적이 있습니다. 엔지니어링 매니저로서 승진 판정 회의에 참여하면 마치 후보를 대신해서 타석에 들어가는 것이 야구에서 대타수 비슷하다는 말씀을 들어왔습니다. 후보는 스트라이크 피치이고, 매니저의 일은 대타로서 4구짜리 패스트볼을 홈런으로 쳐야 하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특이사항이 잘못되었습니다.\n\n다른 변수 중 두 가지만 고려하세요: 상승 시장 대 하락 시장, 대기업 대 중소기업.\n\n## 시장 상황\n\n첫째, 좋은 시기에는 기업들이 유동성과 낮은 이자율로 자극을 받고, 경영진의 목표는 성장을 위해 모두 사용하게 됩니다. 이러한 환경에서 조직은 가로 및 세로로 확장해야 하므로, 빠르게 사람을 승진시키는 것은 필수적인 일과 신입사원을 유치하는 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어려운 시기에는 프로모션이 종종 지연되거나 훨씬 더 엄격한 검토를 받을 수 있습니다. 대형 테크 기업은 일반적으로 해고(유감없는)와 이직(유감 있는)으로 구성된 최소 15%의 교체 대상을 갖고 있습니다. 시장이 활발할 때, 자발적인 이직은 일반적으로 적어도 10%는 발생하기 때문에 해고를 최소화하려고 합니다. 그러나 시장이 침체할 때, 이직은 감소하고 기업은 해고를 증가시키고 인력을 오래 유지하려고 합니다.\n\n## 자본 지출\n\n둘째로, 인재에 지출할 자본이 적은 중소기업이나 기업은 종종 직함 팽창이나 빠른 승진 경로에 의존하곤 합니다. 제 경험상으로, 기업들이 비문으로 제정하지 않은 인상과 가장 많은 이직을 두려워하는 사람에 대한 역순 스택 랭킹만을 기반으로 승진시키는 경우를 보았습니다. 그들은 성과를 보상으로 승진시킨다고 말할 수 있습니다.\n\n그에 비해 대기업들 및 특히 대규모 기술 기업들은 종종 그 반대로 행동합니다. 그들은 모든 분야에서 다음 단계에 존재함이 입증될 때까지 직원들을 현재 수준에 유지시키곤 합니다. 냉소적으로 바라보면, 누군가가 확실하게 다음 수준에 준비되어 있지 않으면 승진이 불가능하다는 뜻입니다. 또한, 그러한 기업에서는 고문련 엔지니어 포지션이 일반적으로 경력의 맥이며, 그 이후의 다음 수준으로 진출하는 탈출 속도가 다른 곳보다 훨씬 높습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 나쁜 경우 — 뜨거운 시장에서 소규모 회사, 승진은 대부분 담당자가 자신의 직원을 구두로 잘 홍보하는 능력에 달려 있습니다. 지정타자의 비유가 꼭 어울립니다. 결과는 종종 잘못 계산되고 불공평할 수 있습니다. 자신의 매니저가 황금처럼 말 잘하는 사람은 다른 사람의 비용으로 승진할 수 있습니다.\n\n승진은 데이터 비교의 표준화되고 투명한 프로세스여야 하며 충분한 명확성이 있어야 합니다. 매니저의 역할은 데이터를 신중하게 기록하고 쇼케이스하며, 직원의 공헌과 영향을 양적 및 질적으로 깊게 이해해야 합니다. 아래는 예시 목록입니다:\n\n양적 데이터 샘플\n\n- 코딩: diff\\* 개수, diff 당 평균 수정 횟수, 코드 리뷰 횟수\n- 문서화: 설계 문서 (RFC\\*\\*) 개수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- diff는 주 코드베이스에 병합된 코드 변경의 단위이며, 병합 요청 등으로도 알려져 있어요.\n\n\\*\\* RFC(의견 요청); 디자인 및 리뷰를 위한 표준화된 문서\n\n질적 데이터 샘플\n\n- 코딩: 디자인 패턴, 코드 커버리지\n- 디자인: 디자인의 견고성, 코멘트 대응\n- 운영: 인시던트 관리, 당직 교대체제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 제기된 비정상적인 상황을 제외하고 승진을 안정적으로 이룰 수 있는 세 가지 중요 권고 사항입니다:\n\n```js\n1. 현재 수준에서 뛰어나게 성과를 올린 후, \"위로 치“\n2. 미래 승진 추천자들과 협력\n3. 경쟁 상황 파악하기\n```\n\n## 현재 수준에서 뛰어나게 성과를 올린 후, “위로 치“\n\n어떤 사람들은 현재 수준에서 뛰어난 성과를 낸 후에야 그보다 한 단계 높은 수준의 성과를 얻으려는 실수를 범할 때가 있습니다. 예를 들어, 중급 직원에게 요구되는 평가 지표는 일반적으로 우수한 코딩 생산성입니다(시니어 직원보다 더 높은 수준). 코드 작성 능력이 탁월하고 빠른 속도로 작업을 완료하는 능력을 보여주지 않은 채 프로젝트를 주도하려는 것은 실수일 수 있습니다. 결국, 제한된 시간 내에 두 가지 모두 최적화하는 것은 매우 어려울 수 있습니다. 여기에서 매니저의 역할은 직원들의 승진 경로를 저해하지 않도록 올바르게 배치하는 일입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 미래 프로모션 엔도서와 협업하기\n\n프로모션을 위해 팀 외부 엔도서가 필요하기 때문에 안정적으로 지지를 받으려면 상호 기능적 프로젝트에서 기회를 찾아 수준 +2/3/4 직원과 협업해야 합니다. 인정받을만한 일을 해내고 그에 대해 인정받는 것이 유일한 방법입니다. 간단히 말해서, 외부 시니어 직원들과의 상호 기능적 프로젝트에서 협업하지 않으면 승진하기가 거의 불가능합니다.\n\n이 과정은 밀어서와 끌어서 둘 다 필요합니다: 매니저는 \"승진 가능한\" 직원을 눈에 띄는 프로젝트에 배치해야 하며 직원들도 이와 같은 프로젝트를 적극적으로 요청해야 합니다.\n\n\\*현재 수준이 중급이라면 L+2는 스태프 엔지니어, L+3은 시니어 스태프 엔지니어가 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 경쟁사 파악하기\n\n누구의 말도 믿지 마세요. 매 프로모션 주기마다, 홍보를 위한 예산과 업무 성과 향상 계획(PIP)이 할당됩니다. 즉, 경영진은 직원들을 순위에 따라 정렬하고 최상위 및 최하위 업무 성과자를 식별합니다. 일반적으로 상위 15%와 하위 15%로 나누어집니다.\n\n매니저와 성장 가능성이 있는 직원은 경영진의 최고 성과자가 누구인지 충분히 조사하고 주기적으로 그들의 양적 및 질적 지표를 모니터링해야 합니다. 기준이 어디에 있는지 주의 깊게 살펴보고 동일한 리그에 속하기 위해 노력해야 합니다. 매니저가 이를 미리 발견했고 직원이 차이를 알고 있다면, 프로모션 케이스가 이루어지지 않는다면 놀라울 일이 없을 것입니다.\n\n지표는 업무 성과의 대리품이지만 그 자체로는 아니기 때문에 조작될 수 있습니다. 매니저로서, 자신의 직원을 홍보하고 다른 직원을 방해하는 것이 아닌, 종종 칭찬받는 좋은 매니저의 질로 자신의 직원에 대해 종합적이고 진실한 데이터를 제시하는 것이 더 유익합니다. 또한 다른 매니저들이 정직하게 유지할 수 있도록 하는 것이 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n후보의 코딩 생산성이 비정상적으로 높은가요? 구성 변경이 이에 포함되나요? 설계 문서의 저자로 명시된 후보가 실제 참여한 내용이 다른 공동 저자보다 적은가요? 관리자는 플랫폼 팀 대비 제품 팀의 코딩 생산성을 구분하나요? 현재 수준에서 뛰어나지 않은 상태에서 \"짧은 장면\"을 보이나요?\n\n마지막 고백: 대부분의 경우 지금 시대의 대형 기술 기업에서 수석급으로 승진하려면 어려운 과제이며, 대개 대형 기술 기업 외부의 레벨 +1에서 새로운 직장을 구하는 것보다 더 어려울 수 있다고 말하자면, 참여가 쉽지 않습니다. 내 관찰에 따르면, 가장 견고한 5시간 인터뷰 루프 조차도 흔히 판정위원회보다 더 부담을 받으며 여러 가지 눈가림이 존재합니다. 희망하는 후보에게는 단순히 새로운 직장을 찾는 것이 유리할 수 있습니다(충분한 시도만 하면).\n","ogImage":{"url":"/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png"},"coverImage":"/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png","tag":["Tech"],"readingTime":4},{"title":"꿈같은 원격 인턴십을 얻은 방법","description":"","date":"2024-05-23 13:32","slug":"2024-05-23-HowILandedaDreamRemoteInternship","content":"\n\n여러 인턴십과 소프트웨어 개발 분야의 다양한 경험을 쌓은 뒤, 원격 인턴십을 위한 엄격한 채용 프로세스를 거친 내 최근 여정을 기쁘게 공유하려고 합니다. 이 모든 과정이 어떻게 진행되었는지 살펴보겠습니다.\n\n# 제 소개\n\n# 경험\n\n- SDE 인턴, NewGen Software\n- 풀스택 개발자 @Infiniti Solutions\n- 프론트엔드 엔지니어 @Spotline, USA (원격 근무)\n- UI/UX 디자이너, Fiverr\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기술 스택\n\n- 언어: C++, JavaScript, Java\n- 백엔드 개발: Express.js, Node.js, Backend TypeScript\n- 프론트엔드 개발: HTML, CSS, React.js, TypeScript, Next.js, Tailwind\n- 데이터베이스: Firebase, MySQL, MongoDB, Prisma, Postgres\n- 버전 관리: Git, GitHub, Docker\n\n# 기회의 출처\n\n나는 직접 연락을 받아온 맴버로부터 Twitter DM을 통해 이 기회를 발견했어.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 면접 프로세스\n\n## 1차 심층 면접\n\n첫 번째 라운드는 역할과 관련 기술 스택에 대해 논의하는 간단한 30 ~ 40분간의 심층 면접이었습니다. 이 역할은 Next.js, TypeScript 및 Postgres와 AWS에 중점을 둔 풀-스택 SWE 인턴십을 위한 것이었습니다. 저는 이전 경험 및 인턴십을 자세히 설명하며 특히 Next.js 프로젝트에서의 업무를 강조했습니다.\n\n## 코딩 라운드 1\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 단계는 빠른 속도의 라이브 코딩 라운드였어요. 프론트엔드에 전자 메일 콘텐츠와 여러 이메일 주소를 입력할 수 있는 두 개의 입력 상자를 만드는 것이 제 몫이었어요. 시스템은 이메일 목록을 표시하고 이메일을 삭제하고 메일링 익스텐션을 통합해야 했어요. 저는 더미 이메일을 보내기 위해 Node-mailer와 Mailtrap을 선택했어요. 압박 속에서도 이러한 기능들을 성공적으로 구현했어요.\n\n![이미지](/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png)\n\n# 코딩 라운드 2/시스템 디자인\n\n이 라운드는 시스템 디자인과 코딩을 결합하여 거의 2시간 동안 진행되었어요. 저에게는 Excalidraw를 사용하여 레스토랑을 위한 팁 시스템을 디자인하라는 임무가 주어졌어요. 이 작업에는 화면 계획, 업로드 서비스 또는 AWS를 사용한 이미지 저장, 그리고 빠른 로딩 시간을 보장하는 것이 포함되었어요. 시스템 디자인을 완료한 후에는 빠르게 이 시스템의 초기 프론트엔드 화면을 코딩했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 이전 라운드에서 소개했던 메일링 시스템을 새롭게 업데이트하여 Prisma DB 통합을 추가하여 사용자를 추가하고 삭제하는 기능과 이메일에 구독 해지 버튼이 추가되었습니다. 이 시연은 내 작업 능력을 강력하게 증명하는 계기가 되었습니다.\n\n# 문화적 적합성\n\n최종 라운드는 인사팀 및 팀 문화 적합성 인터뷰로, 내 사고 방식과 팀에 얼마나 잘 적응할 수 있는지에 중점을 두었습니다.\n\n# 결과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일주일 후에, 인턴십에 선발되었다는 이메일을 받게 되었어요! 이 경험 전체가 믿을 수 없을 정도로 보람찼고, 이 새로운 여정을 시작할 수 있어 너무 흥분되고 있어요.\n\n![이미지](/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_1.png)\n\n# 회고와 조언\n\n과거의 기술 능력, 준비, 그리고 강력한 이전 작업의 시연이 성공에 중요한 역할을 했던 것으로 돌아봤을 때, 비슷한 기회에 대비하는 분들에게 다음을 추천해요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기술 스킬: 자신의 기술 스킬을 끊임없이 향상시키세요. 특히 해당 역할과 관련된 기술에 집중해보세요.\n- 준비: 정기적으로 코딩 및 시스템 설계 문제를 연습해보세요.\n- 프레젠테이션: 이전 작업물을 선보일 준비를 하고, 여러분의 사고 과정을 명확하게 설명할 수 있도록 준비하세요.\n- 문화적합성: 회사의 문화를 이해하고, 면접 중에 어떻게 그것과 일치하는지를 보여주세요.\n\n입사 시즌은 스트레스를 유발할 수 있지만, 끈기와 지속적인 개선이 중요합니다. 때로는 기회가 예상치 못한 때에 찾아올 수 있고, 모든 경험은 여러분의 여정에 가치를 더할 것입니다. 앞으로 나아가며, 성공은 따를 것입니다.\n\n이 상세한 설명이 비슷한 채용 과정을 거치는 분들에게 유용한 통찰을 제공했으면 좋겠습니다. 궁금한 점이 있거나 추가적인 조언이 필요하시면 얼마든지 연락해주세요. 여러분의 여정에 행운을 빕니다!","ogImage":{"url":"/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png"},"coverImage":"/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png","tag":["Tech"],"readingTime":3},{"title":"50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요","description":"","date":"2024-05-23 13:27","slug":"2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer","content":"\n## 이 법칙을 따르지 않으면 해고당할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png)\n\n수백 또는 아마 수천 가지의 파이썬 최고의 관행들이 있습니다. 누구에게 물어도 다소 다른 실천 방법을 얻을 수 있습니다.\n\n인터넷은 모든 사람에게 의견 표명의 권리를 부여했습니다. 심지어 저도 말이죠. 하지만 이 기사에서는 암호화된 50가지 파이썬 최고의 관행을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n신이라도 조작할 수 없는 기술들이 있어요. 이러한 기술들은 전문가와 아마추어를 구분하며 다양한 프로그래밍 언어에도 적용할 수 있어요.\n\n대부분의 파이썬 개발자들은 코드를 빠르게 테스트하거나 오류를 디버그할 곳이 필요해요. 제가 만든 python-fiddle.com 이라는 웹사이트를 이용하면 코드를 빠르게 테스트하고 AI/LLMs를 사용하여 가능한 오류의 해결책을 찾아줄 수 있어요.\n\n만약 웹 스크래퍼를 만들거나 데이터를 분석하거나 암호화폐 관련 프로젝트를 개발하거나 기계 학습 모델을 만들거나 Django 또는 Flask 웹사이트를 만들거나 작업을 자동화하거나 SQL 관련 프로젝트 등이 필요하다면, 이 사람에게 메시지를 보내보세요.\n\n## 법칙 1: 가능한 한 주석을 피하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코멘트는 종종 사실과는 다른 내용을 전달할 수 있는 방식을 갖고 있어요. 코드가 실제로 무엇을 하는지가 아닌 다른 사람이 말하는대로 어떤 일을 하고 있는지를 읽는 사람의 마음을 벗어낼 수 있어요.\n\n시간이 흐르고 코드가 업데이트되거나 변경될 때 이 문제가 매우 심각해질 수 있어요. 어느 순간, 코멘트가 거짓이 되고 이제 모든 사람들은 거짓을 통해 진실을 관찰해야 할 수도 있어요.\n\n모든 비용을 피해야 하는 것이 코멘트에 대한 태도예요. 코멘트는 독자가 당신의 과거적인 생각을 상속받도록 강요해요. 함수나 클래스가 변경되면 대부분 코멘트는 함께 변경되지 않을 가능성이 높아요. 대부분, 코멘트는 독자가 앞으로 생각하도록 막을 수 있어요.\n\n코멘트는 작성자가 명확한 클래스, 함수 또는 변수 이름을 제시하지 못했다는 것을 나타냅니다. 이는 프로그래머의 태도의 부족을 드러내고 팀에 그러한 태도를 상속받도록 강요해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주석을 가능한 한 피해야 합니다.\n\n로우 14와 15에서는 언제 주석을 사용해야 하고 언제 사용하면 안 되는지 알 수 있습니다.\n\n## 로우 2: 변수에 타입 속성을 이름으로 사용하지 마세요\n\n가끔 특정 변수가 문자열인지 정수형인지를 명시하고 싶을 때가 있습니다. 따라서 일부 개발자는 변수를 다음과 같이 지정할 수 있습니다: name_of_variable_str 또는 name_of_variable_int.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변수가 문자열인 것이 직관적으로 이해되는 경우와 같이, 변수가 결코 int(정수) 타입이 될 수 없는 경우에는 이것이 상당히 중복될 수 있습니다.\n\n그러나 변수 타입이 직관적이지 않은 경우에는 변수명을 지정할 때 타입을 명시하는 대신 타입 어노테이션을 사용하는 것이 가장 좋은 방법입니다.\n\nname_of_variable:str = value 대신 name_of_variable_str = value를 사용하는 대신 이 방법을 사용하면 모두가 변수가 문자열인 것을 알 수 있으며 코드를 깔끔하고 간결하게 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법률 3: 클래스 이름은 명사여야 합니다.\n\n클래스 이름을 명사로 유지하는 것이 항상 최선의 실천 방법입니다.\n\n이는 대부분 클래스 객체가 특징과 동작을 식별하거나 표현하는 데 사용되기 때문입니다. 어떻게 양이 어떤 특징(뿔)과 행동(주변 사람에게 고개를 끄덕이다)을 나타내듯이요.\n\n이는 코드를 매우 가독성 있고 중복되지 않게 만듭니다. 예를 들어, Goat.get_horn_length() 대신 GetGoat.get_horn_length()을 사용하는 대신 Goat.get_horn_length()을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법칙 4: 함수 이름은 동사여야 합니다\n\n함수는 인접한 개발자가 수행하는 작업을 명확하게 이해할 수 있도록 동사로 가장 잘 명명되어야 합니다.\n\n이는 주석이 필요 없어지게 하고 어떤 개발자든 원시 코드를 확인하지 않고도 정신적으로 개념화할 수 있도록 해줍니다.\n\n## 법칙 5: 함수는 매개변수와 반환 형식을 명시해야 합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수를 정의할 때는 항상 인수의 유형 및 함수의 결과가 반환하는 데이터 유형을 명시해야 합니다.\n\n이렇게 하면 당신과 팀의 개발자들 모두 print 문을 계속 사용하지 않고도 예상되는 결과를 알 수 있게 됩니다.\n\n![이미지1](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_1.png)\n\n![이미지2](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법칙 6: 함수는 한 가지 기능만 수행해야 합니다\n\n주니어 개발자들은 종종 이 규칙을 어기기 좋아합니다. 함수가 한 가지 기능만을 수행하는 것은 버그가 어디에 있는지 노출시키고 재사용성을 높이며, 함수 이름이 하는 일을 정확히 수행하도록 해줍니다.\n\n다음과 같은 일을 하고 싶지 않을 것입니다...\n\n![Img](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주소가 유효한지 확인하고 확인 후 위도와 경도를 반환합니다. 이 함수는 두 가지 작업을 수행합니다. 주소가 유효한지 확인하고 해당 주소의 지리적 위치를 반환합니다.\n\n다음은 더 나은 방법입니다.\n\n![Better Way](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_4.png)\n\n위의 함수들은 하나의 일만을 하고 그 이상의 일을 하지 않습니다. 덜 간결해 보일 수 있지만 훨씬 간결하고 가독성이 높습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수의 \"하나\" 기능을 정확히 알아내는 것은 새로운 개발자들에게는 약간 어려울 수 있어요. 함수가 무엇을 수행해야 하는지를 매우 구체적으로 명시해야 해요.\n\n보통은 함수 내에서 일부 작업을 추출하거나 그룹화하여 다른 하나의 함수로 만들 수 있다면, 아마도 함수가 한 가지 이상의 일을 수행하고 있는 것일지도 모르겠어요.\n\n또 다른 방법은 함수가 여러 수준의 추상화를 갖는지 여부를 확인하는 것이에요...\n\n## LAW 7: 함수는 동일한 추상화 수준에 있어야 해요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수가 동일한 추상화 수준에 있을 때 언급하는 것은 함수가 단일하고 명확한 작업을 수행해야 한다는 아이디어를 가리킵니다. 해당 작업은 함수 전체에서 일관된 추상화 수준에 있어야 합니다.\n\n다시 말해, 함수는 특정한 세부 사항이나 복잡성에 집중해야 하며, 모든 함수의 작업은 동일한 수준에서 작동해야 합니다.\n\n![image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_5.png)\n\n이 함수는 낮은 추상화 수준의 명령문을 가지고 있습니다. sum, len 등과 같은 것들이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_6.png\" /\u003e\n\n예를 들어, 이 함수에는 여러 수준의 추상화가 있습니다. get_numbers()는 높은 수준의 추상화, 리스트 내포(list comprehension)는 중간 수준의 추상화이며 sum은 낮은 수준의 추상화입니다.\n\n## 제8의 법칙: 함수와 인수는 형제 자매처럼\n\n함수 이름은 매우 밀접하게 그 인수와 관련되어야 합니다. 함수 이름과 관련성이 없는 인수를 전달하는 것은 좋은 방법이 아닙니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 코드를 Markdown 형식으로 변경해보세요.\n\n\nwrite(True)\n\nwrite(name)\n\n두 번째 예시가 함수가 정확히 무엇을 하는지 더 잘 설명하고 있어요. 이것을 읽는 사람에게 이름을 작성하고 있다는 사실이 명확해요.\n\n첫 번째 예시는 두 번째 예시만큼 명시적이지 않아요. 추측을 하거나 함수 전체를 살펴봐야 할 수도 있어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법칙 9: 함수는 작아야 합니다\n\n함수는 재사용 가능하도록 설계되었습니다. 그리고 함수가 커질수록 재사용 가능성이 낮아집니다. 이는 함수가 한 가지 일만 해야 하는 이유와 관련이 있습니다. 한 가지 일만 하면 함수가 작을 가능성이 높습니다.\n\n## 법칙 10: 불필요한 단어 및 중복 단어 피하기\n\n개발자가 변수나 함수의 의미를 더 명확하게 해주는 단어가 아닌 단어를 사용하는 시간도 있습니다. 이런 목록화:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_7.png)\n\n함수의 구현에 대한 사전 지식이 없으면 이를 본 개발자는 어떤 함수를 사용해야 하는지 알 수 없습니다.\n\n## LAW 11: 더러운 프로그래머가 되지 말라\n\n시니어 개발자라면 그가 코드가 깨끗할 때에만 정신적으로 맑다고 말할 것입니다. 이것은 더러운 코드를 작성하는 것이 더러운 프로그래머를 만들기 때문입니다. 깨끗한 코드는 팀의 모든 이들에게 깨끗한 코드를 계속 작성하도록 장려합니다. 항상 깨끗한 코드를 작성하도록 노력해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 깨끗한 코드란 무엇일까요? 깨끗한 코드는 잘 구조화되어 정리되어 있습니다.\n\n깨끗한 코드는 버그를 숨기지 않습니다. 프로그래머가 버그가 숨을 수 있는 어떤 곳이든 드러내며, 완전한 리팩토링 없이 쉽게 수정할 수 있는 공간을 마련해줍니다.\n\n## LAW 12: 개방폐쇄 원칙\n\n개방폐쇄 원칙(Open Closed Principles, OCP)은 클래스, 메서드 또는 함수가 확장을 위해 열려 있지만 수정에는 닫혀 있어야 한다고 말합니다. 이는 정의된 모든 클래스, 메서드 또는 함수가 코드를 변경하지 않고 여러 인스턴스에 재사용하거나 확장할 수 있도록 만든다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 예제를 들어보겠습니다. address라는 클래스가 있다고 가정해 봅시다.\n\n\n![address class](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_8.png)\n\n\n이것은 OCP를 준수하지 못한 것입니다. 새로운 국가가 추가될 때마다, 해당 국가를 보충하기 위해 새로운 if 문을 작성해야 합니다. 지금은 간단해 보일 수 있지만, 상상해 보세요. 100개 이상의 국가를 고려해야 한다면 어떻게 될까요?\n\n여기서 OCP가 중요한 역할을 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_9.png)\n\n이제 클래스나 함수를 수정할 필요가 없어서 보다 견고한 해결책입니다. 어떤 나라와 그 나라의 수도를考え하고 싶을 때 capital 사전만 조정하면 됩니다.\n\n또 다른 흔한 예는 클래스 상속을 사용하는 것입니다.\n\n예를들어:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 다른 지불 방법을 추가할 때마다 항상 PaymentProcessor 클래스를 수정해야한다는 것이 잘못된 방법입니다.\n\n더 나은 방법은 다음과 같습니다:\n\n\n![이미지](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_11.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이렇게 하면 새로운 결제 옵션을 추가해야 할 때마다, 예를 들어 암호화폐나 페이팔 같은 것, 이를 달성하기 위해 어떤 클래스도 수정할 필요가 없습니다. 단순히 다음과 같이 하면 됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_12.png\" /\u003e\n\n## 법칙 13: 리스코프 치환 원칙\n\n이 전 원칙을 살펴보면, 암호화폐를 사용하여 결제할 때 우리는 정확히 어떤 암호화폐를 보내는지 명시적으로 지정하지 않습니다. 금액만 명시합니다. 그래서 만약 우리가 암호화폐를 명시하고 싶어한다면, 일반적으로 다음과 같이 할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom abc import abstractmethod\n\nclass PaymentProcessor:\n\n   @abstractmethod\n   def pay_tax(amount, crypto):\n      pass\n```\n\n그런 다음 각 결제 프로세서를 호출할 때 crypto 인수를 None 타입으로 선언하거나 필요하지 않은 경우 인수를 전달하지 않도록 기본값을 지정합니다. 이 두 경우 모두 Liskov Substitution Principle을 준수하지 못합니다.\n\n이는 부모 클래스 또는 추상 클래스가 대부분의 하위 클래스에게 관련이 없는 인수를 포함하고 있기 때문입니다.\n\n리스코프 치환 원칙(LSP)은 \"슈퍼클래스의 객체는 하위 클래스의 객체로 교체해도 프로그램의 정확성에 영향을 미치지 않아야 한다\"는 것을 명시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLSP를 준수하기 위해 CryptoPaymentProcessor 클래스 내에서 암호화폐를 정의해야합니다. 이렇게 하면 다른 하위 클래스와의 불필요한 충돌을 방지할 수 있습니다.\n\n```js\nclass CryptoPaymentProcessor(PaymentProcessor):\n   def __init__(self, crypto):\n      self.crypto = crypto\n\n   def pay_tax(amount):\n      print(f'당신의 {self.crypto} 지갑으로 세금 지불이 진행됩니다')\n      print(f'{amount}을(를) 청구할 예정입니다.')\n```\n\n## LAW 14: 언제 코멘트를 사용해야 할지 알기\n\n코멘트를 사용해야 할 때마다 코드로 표현하지 못한 것에 대해 부끄러워해야 합니다. 그러나 댓글을 사용하면 실제로 코드 자체보다 코드의 기본 작업을 잘 설명하는 데 도움이 되는 경우도 있습니다. 여기 \"좋음\" 코멘트의 5가지 좋은 예제가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n친절한 메모\n코드를 읽는 사람에게 코드를 더 잘 전달하는 데 도움이 되는 정보가 있는 메모를 작성하는 것은 언제나 좋습니다. 예를 들어 함수의 반환 값을 강조하는 메모는 더 많은 명확성을 제공할 수 있습니다. 그러나 이러한 메모는 명확한 함수 또는 변수 이름을 사용하여 불필요하게 만들 수 있습니다.\n\n할 일 메모\n이러한 메모는 다른 프로그래머들이 이 함수/작업이 아직 미완성이거나 수정이 필요하다는 것을 알 수 있도록 도와줍니다. 특정 함수를 구현하는 더 나은 방법이 있을 수도 있습니다. 때로는 코드가 주기적으로 실패할 수 있습니다.\n\n당신의 이유에 상관없이, 이러한 메모는 가져가는 것보다 더 많은 가치를 제공합니다. 할 일 메모는 일반적으로 과업이 완료되었거나 제대로 수정된 후에 제거되어야 한다는 것을 기억하기 때문에 코드가 변경되거나 개선될 때 거의 손대지 않는 경향이 있습니다.\n\n후행 작용 경고\n가끔은 다른 개발자들에게 잠재적인 위험을 알리고 싶을 때가 있습니다. 이 위험에 발을 딛게 되면 예기치 못한 결과가 생길 수 있습니다. 우리는 모두 하루를 생존하고 싶어합니다. 이 상황에서 메모가 문제를 해결하는 데 도움이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 코드가 시간이 걸리거나 특정 시스템을 과부하시킬 가능성이 있는 경우, 독자나 다른 프로그래머에게 \"#COMPUTING RESOURCES를 많이 소비함\"과 같은 경고가 도움이 될 수 있습니다.\n\n## 법칙 15: 언제 주석이 나쁜가요?\n\n소음 주석\n이러한 주석들은 당연한 것을 다시 강조하는 주석입니다. 추가 정보를 제공하지 않고 코드의 더 많은 길이만 늘립니다. 많은 시간, 우리는 이러한 주석을 건너뛰곤 합니다. 소음 주석의 예시는 다음과 같습니다:\n\n```js\n# 동물 리스트에 추가합니다\nanimal.append(dog)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비 로컬 정보\n프로그래머들이 주석을 사용할 때 범하는 실수 중 하나는 전역 정보를 로컬에서 제공하는 것입니다. 주석을 작성할 때는 해당 함수나 문을 참조하는 것에만 관련되도록 유지하십시오. 그 외의 부분은 제거해야 합니다.\n\n명확하지 않은 주석\n우리가 알기에는 분명한 주석을 작성하기 쉽습니다만 다른 사람에게는 명확하지 않을 수 있습니다. 주석과 함수 간의 연결은 명확해야 합니다. 둘 다 동일한 단계나 절차를 따라야 합니다. 주석이 또 다른 주석을 필요로 하지 않도록 해야 합니다.\n\n짧은 함수\n짧은 함수에 대해 주석이 필요하지 않을 가능성이 높습니다. 함수가 짧을수록 좋은 이름으로 설명할 수 있는 가능성이 높습니다. 따라서 이러한 함수는 보통 자기 설명적입니다.\n\n## 법칙 16: 소스 파일을 짧게 유지하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소스 파일은 최대 500줄이지만 100–200줄 사이로 유지하는 것이 좋습니다. 매우 좋은 이유가 없는 한 다른 방법을 선택하는 것을 권장하지 않습니다. 소스 파일을 짧게 유지하면 재사용성과 가독성과 같은 다양한 명백한 이점이 있습니다. 또한 연결할 내용을 찾느라 스크롤하고 시간을 낭비하는 일이 줄어들기 때문에 유지 및 업데이트하기가 더 쉽습니다.\n\n## 법칙 17: 빈 줄 사용 시점을 알아두세요\n\n빈 줄은 새로운 개념과 분리된 부분으로 진행하고 있다는 것을 독자에게 알려주는 방법입니다. 각 줄 그룹은 완전한 생각을 나타냅니다. 이는 독자가 생각이 끝났는지를 이해하는 데 도움이 됩니다.\n\n## 법칙 18: 관련된 코드/함수/클래스를 가까이 유지하세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 가지가 강하게 관련이 없음을 나타내기 위해 공백을 사용하고, 강하게 연관된 것들은 공백을 사용하지 않습니다. 예를 들어 함수를 정의할 때...\n\n```js\ndef create(name):\n    print(name)\n```\n\n함수와 이름 변수 사이에 공백이 없습니다. 만약 공백이 있다면, 매우 조화롭지 않고 조직되지 않은 모습이 될 것입니다...\n\n```js\ndef create (name):\n    print (name)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수에 전달되는 인수는 구별되어야 합니다.\n\n## 법칙 20: 팀 규칙 준수\n\n거의 모든 개발자는 자신만의 스타일을 갖고 있습니다. 파일 이름 짓는 방식부터 print 문 작성 방식까지.\n\n하지만 다른 개발자들과 협업할 때는 개인적인 취향을 내려놓고 팀의 선호도를 받아들이는 것이 좋습니다. 다른 사람들이 당신의 코드에서 아름다움을 느끼지 못할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## LAW 21: 마법 숫자 피하기\n\n마법 숫자란 나중에 변경될 수 있는 하드 코딩된 값으로, 그래서 업데이트하기 어려울 수 있습니다.\n\n예를 들어, \"나의 주문\" 개요 페이지에서 마지막 50개 주문을 보여주는 페이지가 있다고 가정해봅시다. 여기서 50은 마법 숫자입니다. 왜냐하면 표준이나 규약으로 설정되지 않았으며, 명세서에 기술된 이유로 임의로 정한 숫자입니다.\n\n이제 50을 서로 다른 곳에 넣으시는 것입니다 — SQL 스크립트 (SELECT TOP 50 \\* FROM orders), 웹사이트 (마지막 50개 주문), 주문 로그인 (for (i = 0; i ` 50; i++)) 그리고 가능한 다른 많은 장소에.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 나쁨\nSELECT TOP 50 * FROM orders\n\n# 좋음\nNUM_OF_ORDERS = 50\nSELECT TOP NUM_OF_ORDERS * FROM orders\n\n\n## LAW 22: 깊은 중첩 피하기\n\n루프, 조건문 또는 함수 내의 중첩 수준을 제한하여 가독성을 향상시킵니다.\n\n\n# 나쁨\nif x:\n    if y:\n        do_something()\n\n# 좋음\nif x and y:\n    do_something()\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## LAW 23: 임시 변수 피하기\n\n```js\n# 나쁜 예\ntemp_result = calculate(x, y)\nfinal_result = temp_result * 2\n\n# 좋은 예\nfinal_result = calculate(x, y) * 2\n```\n\n## LAW 24: 암호적 줄임말 피하기\n\n가독성을 높이기 위해 암호적 줄임말 대신 설명적인 이름을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```md\n# 나쁜 예시\n\ndef calc(x, y):\npass\n\n# 좋은 예시\n\ndef calculate_total_price(quantity, unit_price):\npass\n```\n\n## 법칙 25: 경로 하드코딩 피하기\n\n파일 경로나 URL을 하드코딩하지 말고, 대신 구성 파일 또는 환경 변수를 사용해주세요.\n\n```md\n# 나쁜 예시\n\nfile_path = \"/path/to/file.txt\"\n\n# 좋은 예시\n\nimport os\nfile_path = os.getenv(\"FILE_PATH\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## LAW 26: 항상 Try-Catch-Finally 문 사용하기\n\n코드를 작성할 때, 오류 처리를 반드시 포함하는 것이 가장 좋습니다. 이렇게 하면 디버깅 프로세스를 가속화하고 코드의 정교성을 높일 수 있을 뿐만 아니라 코드를 깔끔하고 관리하기 쉽게 유지할 수도 있습니다.\n\n특정 코드에서 오류가 발생할 가능성이 높은 경우 try-catch 문을 사용하고 싶어할 것입니다.\n\nAPI 요청, 파일 처리 등의 작업은 어떤 이유로든 실패하거나 오류를 일으킬 가능성이 높습니다. 반면에 곱셈이나 나눗셈과 같은 작업에 대해 try-catch 문을 사용하는 것은 오히려 문제를 더 만들어내기 때문에 지양해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법칙 27: 예외와 함께 컨텍스트 제공하기\n\n예외가 발생했을 때는 해당 예외가 발생한 위치와 디버깅할 수 있도록 충분한 컨텍스트를 제공해야 합니다.\n\n예외와 함께 유용한 오류 메시지를 생성해야 합니다. 오류를 출력할 때 해당 작업이 실패한 컨텍스트와 실패 유형을 명시해야 합니다.\n\n## 법칙 28: 여러 예외 클래스 사용 피하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같은 코드를 본 적이 있나요?\n\n```js\ntry:\n    pass\nexcept ValueError:\n    pass\nexcept TypeError:\n    pass\nexcept IndexError:\n    pass\nexcept KeyError:\n    pass\nexcept FileNotFoundError:\n    pass\n```\n\n이 코드는 매우 부적절하며, 오류 처리에 추가 도움을 제공하는 대신 가독성, 복잡성 및 유지보수 측면에서 문제를 일으킵니다.\n\n우리가 마주칠 수 있는 모든 종류의 오류를 처리하기 위해 보다 일반적인 예외를 사용하는 것이 종종 더 나은 방법입니다. 기본적으로 이 유형의 예외는 우리가 받은 오류의 유형을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ntry:\n pass\nexcept Exception:\n pass\n```\n\n특정 유형의 오류를 잡고 싶을 때 다른 모든 오류가 통과될 수 있도록 해주세요.\n\n## 법칙 29: 함수는 변이하거나 값을 반환해야 하나 둘 다 하면 안 된다.\n\n함수를 작성할 때 해당 함수가 정확히 무엇을 해야 하는지 유의해야 합니다. 인수를 변이시킬까요? 아니면 반환해야 하나요?```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 함수가 전달된 인수를 변형시키면, 그 함수 안에서만 그 작업을 하면 됩니다. 그 이외의 곳에서는 건드릴 필요가 없어요.\n\n하지만 여기서 변형이 무엇을 의미하는 걸까요? 함수가 인수의 내용을 변경하거나 인수의 데이터 유형을 변경하는 경우 변형됩니다.\n\n```js\ndef changed(array):\n    array.append('hello')\n```\n\n만약 인수가 다른 변수를 만들기 위해 사용된다면 그것은 변형이 아닙니다. 예를 들어, 시간이라는 인수가 거리를 계산하는 데 사용된다면, 그것은 변형이 아니기 때문에 거리는 그 함수에서 반환될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndef calculate_distance(time, speed):\n    distance = speed * time\n    return distance\n```\n\n하지만 두 마리 토끼를 모두 잡는 방법이 있어요. 함수의 인수를 복사하고 그에 대한 변이(mutation)를 수행할 수 있어요. 이렇게 하면 부작용을 피할 수 있어요.\n\n```js\ndef changed(array):\n    array_copy = array[:]\n    array_copy.append(4)\n    return array_copy\n```\n\n## 법칙 30: 모든 함수 이름이 동사일 필요는 없어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 알겠어요. 이전에 제가 언급했던 것처럼 모든 함수명은 일반적으로 동사여야 한다고 했었는데, 때로는 함수명이 명사 형태여야 하는 경우가 있습니다. 이것이 언제 그런지 아는 것은 이전 법칙/법칙 29에 근거합니다.\n\n인수를 변형하지 않고 무언가를 반환하는 함수라면, 함수명은 명사여야 합니다. 반면에 인수를 변형하고 반환하지 않는 함수는 동사여야 합니다.\n\n이것은 파이썬 자체에 내장된 일반적인 관례입니다. sort나 append와 같은 메서드는 데이터 유형을 변형하고 None을 반환하기 때문에 동사입니다. 반면에 sorted, sum, product와 같은 메서드들은 전달된 인수를 변형하지 않고 데이터의 새 복사본을 반환하기 때문에 모두 명사입니다.\n\n물론 이에는 예외가 있고, 한 번 예외 상황을 마주했을 때는 언제든지 동사를 사용하도록 되돌아가도 괜찮습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법칙 31: 클래스는 작아야 합니다\n\n그렇습니다! 클래스는 가능한 작아야 합니다. 함수와 마찬가지로요.\n\n함수에서는 크기가 함수 내의 줄 수에 의해 결정되지만 클래스에서는 책임의 수에 따라 결정됩니다.\n\n일반적으로 클래스 이름은 해당 클래스가 가질 수 있는 책임의 종류를 나타냅니다. 그러나 이름이 모호하거나 너무 일반적인 경우, 대부분 너무 많은 책임을 부여하고 있는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이는 클래스가 하나의 이유, 즉 변경할 책임이 하나만 있어야 한다는 SRP(단일 책임 원칙)로 되돌아가게 됩니다.\n\n## LAW 32: 클래스는 인스턴스 변수의 개수를 적게 가져야 합니다.\n\n인스턴스 변수는 클래스가 정의되거나 인스턴스화될 때 정의된 변수입니다.\n\n```js\nclass Animal:\n    def __init__(self, name):\n        self.name = name #인스턴스 변수\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 모든 우리의 함수가 클래스 책임과 관련이 있다면, 많은 인스턴스 변수를 가질 이유가 없어요.\n\n수많은 인스턴스 변수가 생기기 시작하는 건, 클래스의 핵심 역할에서 벗어난 함수 때문입니다.\n\n이러한 함수들은 다른 함수가 필요하지 않은 자체 변수를 가지게 됩니다.\n\n## 법칙 33: 당신의 클래스는 응집력이 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스 내의 모든 함수는 하나 이상의 인스턴스 변수를 포함해야 합니다. 함수가 클래스 내의 인스턴스 변수와 관련이 많거나 해당 변수를 포함하면 클래스의 응집력이 더 높아집니다.\n\n## 법칙 34: 자원 관리를 위해 with 문 사용하기\n\n파일이나 데이터베이스 연결과 같은 자원을 자동으로 관리하려면 with 문을 사용하여 해당 자원이 제대로 닫히거나 해제되도록 합니다.\n\n```js\n# 나쁜 예\nfile = open(\"example.txt\", \"r\")\ndata = file.read()\nfile.close()\n\n# 좋은 예\nwith open(\"example.txt\", \"r\") as file:\n    data = file.read()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법칙 35: 복잡한 삼항 표현식 피하기\n\n과도하게 복잡한 삼항 표현식 사용을 삼가하고, 코드를 더 잘 이해할 수 있도록 간결함보다 가독성을 선호하세요.\n\n```js\n# 나쁨\nresult = \"even\" if number % 2 == 0 else \"odd\" if number % 3 == 0 else \"neither\"\n\n# 좋음\nif number % 2 == 0:\n    result = \"even\"\nelif number % 3 == 0:\n    result = \"odd\"\nelse:\n    result = \"neither\"\n```\n\n## 법칙 36: 정체성 비교에 ‘is’와 ‘is not’ 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 경우, 우리는 두 변수 사이의 비교를 확인하기 위해 ==를 사용합니다. 불변 데이터 유형인 문자열이나 정수와 같은 경우에는 보통 두 변수가 동일한 메모리 위치에 저장되기 때문에 메모리 위치 확인은 필요하지 않습니다.\n\n그러나 list, dict 및 사용자 정의 객체와 같은 가변 데이터 유형과 작업할 때는 종종 변수의 서브 유형과 메모리 위치를 확인하는 is 비교 연산자를 사용하는 것이 더 좋습니다.\n\n가변 객체의 메모리 위치는 Python의 작동 방식 때문에 보통 같지 않습니다. Python은 가변 객체를 서로 다른 메모리 위치에 저장합니다. 이것은 언제든지 변경될 수 있으며 각 객체가 다른 객체와 독립적이어야 하기 때문입니다.\n\n문자열, 튜플 및 정수는 생성된 후에 변경할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n아래 링크를 사용하여 이 코드를 실행해보세요:\nhttps://python-fiddle.com/saved/nV6iEIyBuHm2mevD9Bhg\n\n# 예시 2: 두 리스트가 동일한 객체를 참조하는지 확인\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]\n\n# 선호되지 않는 방법: == 사용\nif list1 == list2:\n    print(\"리스트는 동일한 값을 가집니다\")\n\n# 선호되는 방법: is 사용\nif list1 is list2:\n    print(\"리스트는 동일한 객체를 참조합니다\")\n\n# 참고: 이 경우에, list1과 list2는 동일한 값을 가진 다른 객체이므로,\n# `is`를 사용하면 `==`와 다른 결과가 나옵니다.\n```\n\n## LAW 37: 의존 역전 원칙\n\n의존 역전 원칙(Dependency Inversion Principle, DIP)은 객체 지향 설계의 중요한 원칙으로, 컴포넌트 간의 느슨한 결합을 촉진하고 소프트웨어 시스템의 보다 쉬운 유지보수와 확장을 돕습니다.\n\n고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다시 말해서, 클래스는 구체적인 구현이 아닌 인터페이스 또는 추상 클래스에 의존해야 합니다.\n\n```js\n# 나쁜 예\nclass Logger:\n    def log(self, message):\n        with open('log.txt', 'a') as f:\n            f.write(message + '\\n')\n\nclass Calculator:\n    def __init__(self):\n        self.logger = Logger()\n\n    def add(self, x, y):\n        result = x + y\n        self.logger.log(f\"{x}와 {y}를 더했습니다. 결과 = {result}\")\n        return result\n```\n\n위 예시에서 Logger 클래스를 정의하고 Calculator 클래스에서 직접 인스턴스를 생성합니다. 이로 인해 Calculator는 이제 Logger 클래스에 의존하며, Logger 클래스를 변경하면 Calculator 클래스도 수정해야 합니다.\n\n또한 이는 개방-폐쇄 원칙(확장에는 열려 있고 수정에는 닫혀 있음)을 지키지 못하는 것을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 좋은 코드\nfrom abc import ABC, abstractmethod\n\nclass LoggerInterface(ABC):\n    @abstractmethod\n    def log(self, message):\n        pass\n\nclass Logger(LoggerInterface):\n    def log(self, message):\n      with open('log.txt', 'a') as f:\n          f.write(message + '\\n')\n\nclass Calculator:\n    def __init__(self, logger: LoggerInterface):\n        self.logger = logger\n\n    def add(self, x, y):\n        result = x + y\n        self.logger.log(f\"Added {x} and {y}, result = {result}\")\n        return result\n```\n\n이 기능은 테스트하기가 더 어려울 수 있지만, 가짜 로거 클래스를 사용하여 테스트할 수 없게 만든다는 문제가 있습니다.\n\n이렇게 하면 인터페이스가 일관성을 유지하는 한 한 요소의 변경이 다른 요소에 변경을 요구하지 않기 때문에 모듈화를 촉진합니다.\n\n이 모듈성은 코드베이스를 더 쉽게 이해, 수정 및 확장할 수 있도록 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법칙 38: 데이터 유효성 검사에 'assert' 사용을 피하십시오\n\n'assert' 문은 디버깅 및 개발 목적으로만 사용하고, 제품 코드에서 데이터 유효성 검사에는 사용을 피하십시오.\n\n```js\n# 안 좋은 예\nassert x \u003e 0, \"x는 양수여야 합니다.\"\n\n# 좋은 예\nif x \u003c= 0:\n    raise ValueError(\"x는 양수여야 합니다.\")\n```\n\n## 법칙 39: 하드 코딩된 숫자를 피하십시오\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n명확성을 높이고 코드 수정을 쉽게 만들기 위해 의미 있는 이름으로 상수를 작성하십시오.\n\n```js\nDISCOUNT_RATE = 0.1\n\ndef calculate_discount(price):\n    discount = price * DISCOUNT_RATE\n    return price - discount\n```\n\n위 예제는 10% 할인을 나타내는 하드 코딩된 숫자 0.1을 사용합니다.\n\n이로 인해 숫자의 의미를 이해하기 어렵고 다른 부분에서 필요시 할인율을 조정하는 것이 어려워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\ndef calculate_discount(price):\n    TEN_PERCENT_DISCOUNT = 0.1\n    discount = price * TEN_PERCENT_DISCOUNT\n    return price - discount\n```\n\n개선된 코드는 숫자를 하드코딩하는 대신 TEN_PERCENT_DISCOUNT라는 이름이 지정된 상수로 대체합니다. 이 이름은 값의 의미를 즉시 전달하여 코드를 자체 문서화하는 데 도움이 됩니다.\n\n## LAW 40: DRY (Don’t Repeat Yourself) 원칙을 따르세요\n\n같은 코드를 한 번 이상 작성하지 않도록 합니다. 대신 함수, 클래스, 모듈, 라이브러리 또는 기타 추상화를 사용하여 코드를 재사용하세요. 이렇게 하면 코드가 더 효율적이고 일관되며 유지 보수가 용이해집니다.\n\n````\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 표를 변경하여 마크다운 형식으로 변환해보세요.\n\n```js\n# 나쁜 예\n\ndef calculate_book_price(quantity, price):\n    return quantity * price\ndef calculate_laptop_price(quantity, price):\n    return quantity * price\n\n# 좋은 예\n\ndef calculate_product_price(product_quantity, product_price):\n    return product_quantity * product_price\n````\n\n## LAW 41: 존중할 만한 코딩 기준을 따르세요.\n\n공백, 주석, 그리고 명명에 대한 일반적으로 인정받은 컨벤션을 따르는 것이 중요합니다. 대부분의 프로그래밍 언어에는 커뮤니티에서 인정하는 코딩 표준과 스타일 가이드가 있습니다. 예를 들어, Python의 경우 PEP 8가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 사용되는 관례들은 다음과 같습니다:\n\n- 변수, 함수 및 클래스 이름에는 snake_case를 사용합니다.\n- 들여쓰기에는 탭 대신 공백을 사용합니다.\n- 들여쓰기 단계마다 4개의 공백을 사용합니다.\n- 모든 줄을 최대 79자로 제한합니다.\n- 2진 연산자 앞에 줄바꿈을 넣습니다.\n\n## 법칙 42: 데메테르의 법칙\n\n데메테르의 법칙은 간단히 말하면 모듈/함수/클래스는 주변 모듈/함수/클래스에 대한 지식이나 참조를 가질 수 있지만 그 이상의 지식은 가져서는 안 된다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인접한 이웃이라 함은 직접 액세스할 수 있는 메소드, 함수 또는 변수를 의미합니다.\n\n예제를 통해 설명해드리겠습니다...\n\n```js\nclass Order:\n    def __init__(self, customer):\n        self.customer = customer\n\n    def get_customer_name(self):\n        # 위반 사항: 주문이 고객의 구조에 대해 너무 많이 알고 있습니다\n        return self.customer.get_profile().get_name()\n```\n\n이 예제에서 Order 클래스는 고객의 프로필에 직접 접근하여 고객의 이름을 검색합니다. Order는 고객 객체의 내부 구조에 액세스하여 프로필 및 이름에 접근하고 있으므로 이는 데메테르 법칙을 위반합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주변 이웃을 넘어서고 이제 고객 개체에 대해 너무 많이 알게 되었습니다.\n\n```js\nclass Order:\n    def __init__(self, customer):\n        self.customer = customer\n\n    def get_customer_name(self):\n        # 준수 사항: 주문은 직접적인 협력자와만 상호 작용합니다\n        return self.customer.get_name()\n```\n\n이 준수 사례에서 Order 클래스는 해당 고객 개체와만 상호 작용하고 고객의 이름을 검색하기 위해 직접적으로 메서드를 호출합니다.\n\n고객 개체의 내부 구조에 접근하지 않으므로 Demeter의 법칙을 따릅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법칙 43: 간결함보다 가독성이 중요합니다\n\n코드는 기계가 해석할 수 있어야 합니다. 그러나 다른 개발자들도 코드를 이해할 수 있어야 합니다. 특히 여러 명이 참여하는 프로젝트에서 작업할 때는 더욱 중요합니다.\n\n소프트웨어 개발에서 가독성은 항상 코드의 간결성보다 중요합니다.\n\n만약 다른 개발자들이 이해할 수 없는 간결한 코드를 작성한다면, 그것은 별 의미가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법칙 44: Import를 깨끗하게 유지하세요\n\n필요한 모듈과 심볼만을 가져와서 import 섹션을 깔끔하게 유지하고 가독성을 향상시키세요. 모듈에서 모든 (\\*) 것을 가져올 때, 모든 변수, 함수 및 클래스도 가져오게 되어 특정 함수/클래스가 어디서 온 것인지 알기 어려워지며, 최신 IDE를 사용할 때 번거로울 수 있습니다.\n\n예를 들어, get_file이라는 함수를 작성하고 싶다고 상상해보세요. g를 클릭하면 IDE가 g로 시작하는 함수/클래스/변수 목록을 추천해줍니다. 이렇게 되면 꽤 혼란스러워질 수 있습니다.\n\n이것이 더 큰 문제로 변하는 경우가 있습니다. 함수를 호출하려고 할 때 더욱 문제가 될 수 있습니다. 함수 이름이 추천 목록 사이에 잃어버릴 수 있고, 이제 IDE가 효율적인 해결책보다는 문제로 변할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n# 나쁜 예\nfrom module import *\n\n# 좋은 예\nfrom module import symbol1, symbol2\n\n\n## LAW 45: Null/None을 반환하지 마세요\n\n보통 함수를 정의할 때, 기본적으로 반환 값이 지정되지 않은 경우 None이 반환됩니다. 그렇지만 우리가 명시적으로 None을 반환할 때는, 해당 함수가 None 이외의 다른 값을 반환할 수 있다는 것을 간접적으로 읽는 사람에게 알리는 것입니다.\n\n만약 이게 사실이 아니라면, 많은 오해를 불러올 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 법률 46: 건설과 사용 분리하기\n\n관심사의 분리는 소프트웨어 공학에서 매우 기본적인 원칙이 되어왔습니다. 우리는 소프트웨어의 건설 방식을 사용 방식으로부터 분리하는 방법을 알아야 합니다.\n\n이는 종종 시작 과정, 즉 의존성 및 객체들이 결합되는 때와 실행 시간 로직, 즉 응용 프로그램 로직이 사용자 입력이나 다른 트리거로부터 실행되는 경우와 같은 것들을 분리하는 것을 의미합니다.\n\n건설과 사용을 분리하는 일반적인 방법은 main이라는 파일/함수/모듈에서 응용 프로그램 로직을 구성하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 기능은 응용 프로그램이 원활하게 실행되도록 필요한 객체를 구축합니다. 이렇게 함으로써 다른 모듈이 응용 프로그램에 강하게 결합되지 않도록하고 재사용성과 모듈성을 증진시킵니다.\n\n## LAW 47: 간단한 디자인에는 모든 이러한 규칙이 포함됩니다\n\n모든 테스트 실행: 시스템은 문서상으로 완벽한 디자인을 가질 수 있지만, 시스템이 의도한 대로 작동하는지 확인할 수 있는 방법이 없다면, 문서상의 디자인은 의문스러워집니다.\n\n중복이 포함되지 않음: 중복은 잘 설계된 시스템의 주요 적인 적수입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로그래머의 의도를 표현합니다\n\n클래스와 메소드의 수를 최소화합니다\n\n## LAW 48: 중첩된 Try-Except 블록 피하기\n\n너무 복잡한 오류 처리 논리를 방지하기 위해 try-except 블록을 과도하게 중첩하는 것을 삼가세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 나쁜 예시\ntry:\n    try:\n        # 오류가 발생할 수 있는 코드\n        pass\n    except ValueError:\n        # ValueError 처리\n        pass\nexcept Exception as e:\n    # 다른 예기치 않은 오류 처리\n    pass\n\n# 좋은 예시\ntry:\n    # 오류가 발생할 수 있는 코드\n    pass\nexcept ValueError:\n    # ValueError 처리\n    pass\nexcept Exception as e:\n    # 다른 예기치 않은 오류 처리\n    pass\n```\n\n## 법칙 49: 필요할 때만 동시성 사용하기\n\n동시성 기능을 구현할 때 나쁜 코드를 작성하기가 매우 쉽습니다.\n\n또한, 매우 결함이 많은 동시성 기능을 구현할 때 깔끔한 코드를 작성하는 것도 매우 쉽습니다. 보통 시스템에 많은 스트레스가 가해질 때까지 잘못되었다는 것을 인식하지 못할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n너는 매우 현명하게 전투를 선택하길 원해.\n\n너의 동시성 코드가 실패할 수 있는 여러 이유들이 있다. 여기 몇 가지 예시가 있다:\n\n굶주림(Starvation): 굶주림은 스레드나 프로세스가 공유 자원에 접근할 수 없어 계속해서 시도해도 영원히 실패하는 경우 발생한다. 이는 다른 스레드나 프로세스가 계속해서 자원을 확보하고 보유하여 굶주는 스레드가 진행하지 못하게 하는 경우에 발생할 수 있다.\n\n교착상태(Deadlocks): 교착상태는 두 개 이상의 스레드나 프로세스가 상호적으로 서로 자원을 해제하기를 무한정 대기하고 있는 경우 발생한다. 이는 각 프로세스가 한 자원을 보유하고 다른 프로세스가 보유한 다른 자원을 기다리며 순환 의존성을 만들어 서로 대기하는 경우에 발생할 수 있다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## LAW 50: 49가지 법칙을 따르세요\n\n이 법칙들은 당신을 소프트웨어 엔지니어로서의 여정에서 안내하기 위해 존재합니다. 필요할 때마다 이를 준수해야 합니다.\n\n그러나 경험과 기술이 쌓일수록, 특정 규칙을 따를 때와 그렇지 않을 때를 판단할 수 있는 능력을 가지고 싶을 것입니다.\n\n이 직관은 자신의 기술을 숙달한 사람들에게만 주어지며, 만약 초보자이거나 2년 전에 경력을 시작한 경우라면, 이 법칙을 하늘로 가는 유일한 티켓으로 여기는 것이 가장 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 파이썬 개발자들은 코드를 빠르게 테스트하거나 오류를 디버깅하는 곳이 필요합니다. 저는 python-fiddle.com이라는 웹사이트를 개발했습니다. 여기에서 빠르게 코드를 테스트하고 AI/LLMs를 활용하여 가능한 오류의 해결책을 찾을 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png"},"coverImage":"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png","tag":["Tech"],"readingTime":24},{"title":"분산 애플리케이션에서 캐싱 마스터하기","description":"","date":"2024-05-23 13:23","slug":"2024-05-23-MasteringCachinginDistributedApplications","content":"\n![마스터링 분산 애플리케이션의 캐싱](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png)\n\n소프트웨어 시스템의 캐싱 구현에서 버그를 만날 때마다 1달러가 있다면... 아마도 Redis Enterprise의 연간 기업 구독 비용을 지불할만큼의 돈이 쌓였을 것입니다.\n\n캐싱은 거의 올바르게 할 수 있지만, 결코 완벽하게 할 수 없는 것처럼 보입니다. 그것에는 좋은 이유가 있습니다. 결국 - 캐싱(또는 캐시 무효화)은 컴퓨터 과학에서 가장 어려운 두 가지 기본 문제 중 하나로 간주됩니다. 다른 하나는 변수의 명명이겠지요.\n\n농담인지 아니든 - 캐싱을 제대로 이해하는 것은 정말 어렵습니다 - 특히 대규모 분산 애플리케이션에서. 결과적으로 팀은 종종 캐싱 전략과 구현을 조정하기 위한 반복과 실험 과정을 거치며 - 마침내, 어느 정도 합리적이고 반최적적인 상태로 이르기를 희망하며.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 종종 간과되거나 오해되는 캐싱에 대한 몇 가지 측면을 명확하게 하고자 합니다.\n\n이 글을 읽은 후에는 캐싱이 무엇인지, 캐싱의 주요 접근 방식, 주의해야 할 사항 및 다양한 캐싱 기술을 실제 사용 사례에 어떻게 적용하는지에 대해 더 명확한 이해를 가지게 될 것입니다.\n\n그러니 더 이상 미루지 말고....\n\n# 캐싱이란?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캐싱은 간략히 말해서 데이터를 임시 저장하는 동작으로, 데이터를 원본 저장소(기록 시스템)에서 검색하는 것보다 더 저렴하거나 빠르거나 최적화된 방법으로 검색할 수 있는 임시 매체에 데이터를 저장하는 것을 말합니다.\n\n다른 말로 하면, 다음과 같은 사용 사례를 상상해보세요.\n\n주문 관리 시스템이 재고 시스템에서 제품 정보를 검색해야 하는 상황입니다. 재고 시스템이 그다지 효율적이지 않다고 가정해보겠습니다. 요청이 들어올 때마다 제품 정보를 가져오기 위해 중앙 데이터베이스로 이동해야 합니다. 이 데이터베이스는 느리며 너무 많은 병렬 요청을 처리할 수 없습니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n성능을 향상시키고 재고 데이터베이스에 가해지는 부담을 완화하기 위해 캐싱 레이어를 도입했습니다. 이제 동일한 제품 정보를 저장하는 캐시가 추가되었습니다. 이제 버거운 데이터베이스를 거치지 않고 먼저 캐시에 접근하며, 캐시에 데이터가 있다면 그곳에서 가져옵니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_2.png)\n\n여기서 한 일은 성능을 향상시키고 원본 재고 데이터베이스의 자원 사용을 최적화하기 위해 임시 저장 매체(캐시)를 도입한 것입니다.\n\n# “캐시”란 무엇을 의미할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사람들이 혼동하기 시작하는 지점 중 하나는 캐시의 기술적 성격에 대해입니다.\n\n소프트웨어 개발 분야에 종사하는 대다수의 사람들은 \"캐시\"라는 용어를 들었을 때 매우 구체적인 연상을 갖게 됩니다. 종종 이 용어를 Redis, Memcached 또는 EHCache와 같은 분산 캐시 제품과 연관시킵니다. 때로는 브라우저 캐시, 데이터베이스 캐싱, OS 캐싱 또는 하드웨어 캐싱을 떠올리기도 합니다.\n\n이것이 바로 핵심입니다. 캐시의 개념은 컴퓨터 과학 분야 내의 특정 제품이나 영역으로 제한되지 않습니다. \"캐싱\"은 널리 생각되는 바에 따르면, 우리가 어떤 레코드 시스템으로부터 데이터를 복제하는 임시 매체의 어떤 형태라도 될 수 있습니다. 그렇게 하는 이유는 그 데이터를 임시 매체에 저장하는 것이 한 방이나 다른 방식으로 유리하기 때문입니다.\n\n이는 일반적으로 비용 절감, 성능 향상 또는 원본 저장소보다 더 나은 확장성 때문에 그렇습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 주문 관리 및 재고 시스템의 예제를 살펴보면 캐싱 레이어는 이론상 여러 가지로 구성될 수 있습니다:\n\n- 분산 캐싱 제품(예: Redis)\n- 자체 데이터베이스를 갖춘 다른 마이크로서비스\n- 실제 재고 관리 시스템 내부의 인메모리 저장소\n\n위의 모든 것은 서로 다른 구현이지만 각각 캐시의 조건을 충족할 것입니다.\n\n간단히 말하면 위에 언급된 모든 것들이 캐시가 될 수 있습니다. 컴퓨터 시스템 스택의 모든 수준과 다양한 디지털 도메인에서 캐싱이 구현될 수 있다는 개념으로, 직접 적용될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 용어정의\n\n계속하기 전에 캐싱 주제 주변의 다양한 용어를 이해하는 것이 중요합니다.\n\n- **시스템 레코드(System of Record):** 데이터가 저장되는 영구 저장소입니다. 대부분 데이터베이스일 가능성이 높습니다. 참 값 시스템(source-of-truth system)이라고도 합니다.\n\n- **캐시 미스(Cache Miss):** 응용프로그램이 캐시를 쿼리하지만 해당 레코드가 캐시에 존재하지 않을 때 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로 고침된 데이터: 캐시에 있는 레코드가 기본 시스템과 얼마나 동기화되어 있는지를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캐시 만료: 캐시 레코드를 에백션 프로세스의 일부로 또는 캐시 무효화의 일부로 시간 기반으로 제거하는 것을 의미합니다.\n\n이제 우리 모두가 캐싱 용어에 완전히 익숙해졌으니, 캐시가 구현될 수 있는 몇 가지 장소와 계층에 대해 살펴보겠습니다.\n\n# 캐싱은 어디에 구현되나요?\n\n이미 언급했듯이, 캐싱은 기술 영역 전반에 걸쳐 사용되며, 모든 수준 및 다양한 기술 스택 내에서 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하드웨어 수준에서 캐싱은 CPU 아키텍처의 일부로 사용되며, 예를 들어 레벨 1-3 (L1/L2/L3) 캐시 형식으로 사용됩니다.\n\n운영 체제 커널 수준에서는 페이지 캐시라고 알려진 디스크 캐시 형식이 있습니다. 다른 형태도 있습니다.\n\n웹 기반 시스템에서는 물론 브라우저 캐시와 CDN(Content Delivery Networks)가 있습니다. 이 캐시는 일반적으로 정적 리소스(이미지, 스타일시트 등)를 사용자에게 빠르고 효율적으로 제공하고 대역폭을 줄이는 데 사용됩니다.\n\n다양한 종류의 응용 프로그램 및 미들웨어에도 자체 캐시가 있습니다. 예를 들어, 데이터베이스는 자주 사용되는 쿼리 및 자주 반환되는 결과 집합을 저장하기 위해 캐싱을 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, Redis, EHCache, Memcached, Hazelcast, Infinispan 등과 같은 많은 견고한 소프트웨어 캐싱 제품이 존재합니다. 이 제품들은 분산 애플리케이션 내에서 확장 가능한 분산 캐싱을 가능하게 합니다.\n\n이제 강조할 한 가지는 \"분산\" 캐시 개념이 \"로컬\" 또는 \"지역화된\" 캐시와 대조될 수 있다는 점입니다. 분산 캐시는 네트워크 상에서 여러 기기에 분산된 캐시 형태입니다. 로컬 캐시는 한 기기에만 존재합니다.\n\n이 두 개념 간의 차이를 이해하는 가장 좋은 방법은 클러스터 서버에 배포된 애플리케이션을 상상해보는 것입니다. 다시 말해, 동시에 여러 애플리케이션 인스턴스가 실행되는 것이 큰 규모 애플리케이션 개발자에게 익숙한 상황일 것입니다.\n\n이러한 시스템에 분산 캐시를 도입한다면, 어떤 애플리케이션 인스턴스에서든 해당 캐시에 접근하고 레코드를 수정할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 한편으로, 로컬 캐시가 있다면 각 인스턴스마다 자체 캐시가 있을 것입니다. 그 캐시는 대부분 해당 인스턴스의 메모리 내에 위치할 것입니다. 서로 다른 인스턴스들은 다른 인스턴스의 캐시에 접근할 수 없을 것입니다. 그들은 자신들의 캐시에만 접근할 수 있을 것입니다.\n\n이러한 두 가지 접근 방식에는 장단점이 있습니다.\n\n한편으로, 여러 인스턴스가 캐시에 접근하는 경우 - 동기화 문제, 경쟁 조건, 데이터 손상 및 분산 애플리케이션에서 발생하는 기타 도전 과제를 해결해야 할 수도 있습니다. 다른 한편으로, 공유 캐시는 강력한 개념입니다. 왜냐하면 그것으로 가능했던 사용 사례를 처리할 수 있게 해줍니다. 로컬, 더 단순한 캐시로는 불가능했던 것들도 처리할 수 있게 해주기 때문입니다.\n\n예를 들어, 여러 가용 영역 내에서 클라우드 환경에 애플리케이션을 배포할 수 있습니다. 각 가용 영역은 애플리케이션을 실행하는 VM 인스턴스 클러스터를 가질 것입니다. 이러한 클러스터는 아마도 각각 자체 분산 캐시를 가질 것입니다. 분산 캐시의 전제조건 중 하나는 그것에 빠르고 효과적으로 액세스할 수 있어야 한다는 것입니다. 이는 캐시의 인스턴스에 서비스하는 네트워크 근접성(물리적일 필요는 없지만 가상적일 수도 있음)을 가지는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동시에 분산 및 로컬 캐싱에 공통적으로 발생하는 몇 가지 도전 과제가 있습니다.\n\n주요 도전 과제는 데이터 신선도 유지, 최적의 캐시 무효화 및 제거, 그리고 캐시 관리 방식을 특정 사용 사례에 잘 맞추는 것 사이의 꾸준한 균형입니다.\n\n캐시 관리 — 캐싱 패턴은 다음에 다룰 중요한 개념입니다.\n\n소프트웨어 엔지니어링에서의 대부분의 결정과 마찬가지로, 각 접근 방식에는 각자의 절충안(또는 다른 말로 장단점)이 있습니다. 아래에서 각 접근 방식의 장단점을 다룰 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캐싱은 소프트웨어 엔지니어와 소프트웨어 아키텍트 모두가 이해해야 하는 중요한 개념입니다. 그러나 이것이 유일한 개념이라고는 할 수 없습니다.\n\n내 안내서 — 소프트웨어 아키텍트의 경력을 여는 법, 에서는 시니어 이상의 소프트웨어 엔지니어 및 소프트웨어/솔루션 아키텍트가 숙달해야 할 다른 개념, 기술 및 기술을 설명합니다.\n\n여기에서 확인하세요\n\n![마스터링 분산 애플리케이션에서의 캐싱 이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 로컬 및 분산 캐싱 시스템의 패턴\n\n캐싱 시스템에는 다섯 가지 주요 캐싱 패턴이 있으며, 이들은 캐시가 데이터를 읽고 쓰는 방식 및 기본 시스템과 동기화하는 방식과 관련이 있습니다.\n\n# 캐시 옆에\n\n캐시 옆에 캐싱 전략은 아마도 가장 인기 있는 전략이며 대부분의 소프트웨어 엔지니어가 익숙한 전략입니다. 이 캐싱 접근 방식은 애플리케이션에 캐시 쓰기 및 읽기 제어를 완전히 맡깁니다. 여기서 애플리케이션은 데이터베이스 또는 캐시에서 읽을 때와 쓸 때를 모두 제어합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 그것이 작동하는 방법에 대한 예시입니다.\n\n당신의 애플리케이션이 사용자의 로그인 요청을 받고, 결과적으로 사용자의 우편 주소를 가져오게 된다고 상상해보세요.\n\n- 애플리케이션은 먼저 사용자의 주소가 캐시 내에 존재하는지 확인합니다.\n- 만약 해당 사용자의 주소 항목이 없다면, 애플리케이션은 데이터를 데이터베이스에서 가져옵니다.\n- 그러나 캐시 내에서 정보가 존재한다면, 해당 데이터는 즉시 검색되어 데이터베이스로의 여행을 절약합니다.\n- 새로운 정보를 가져온 후, 애플리케이션은 해당 데이터를 캐시에 기록합니다.\n\n2단계에서, 특정 아이템을 위한 캐시에 항목이 없다면 — 이것은 \"캐시 미스\"로 자주 언급됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_4.png)\n\n## 장점\n\n- 구현이 간단합니다.\n- 제어권은 애플리케이션에 완전히 남습니다.\n- 필요할 때만 캐시된 항목을 가져오므로 (게으른 로딩), 최소한의 메모리를 사용합니다. (이론적으로는)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### Write-Through Caching\n\n- 캐시 미스 발생 시 더 느린 저장소에서 데이터를 가져와야 하므로 지연 시간이 높아집니다. 캐시 미스가 많아지면 성능에 영향을 줄 수 있습니다.\n- 애플리케이션 로직이 더 복잡해집니다 (전반적인 아이디어는 구현하기 쉽지만요).\n\n### 사용 시기\n\n- 캐시가 어떻게 채워지는지에 대한 완전한 제어를 원할 때.\n- 데이터베이스 읽기/쓰기를 관리할 수 있는 캐싱 제품이 없을 때.\n- 캐시에 대한 액세스 패턴이 불규칙할 때.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWrite-Through 캐싱은 캐시와 기본 영속 데이터 저장소 사이의 일관성을 보장합니다. 다시 말해, 쓰기가 발생할 때 캐시와 데이터베이스 양쪽으로 동시에 전파됩니다.\n\n다음은 예시입니다:\n\n- 재무 애플리케이션이 사용자 계정을 새로운 잔액으로 업데이트하는 요청을 받습니다.\n- 사용자 계정 잔액은 데이터베이스와 캐시 둘 다에 존재합니다.\n- 데이터베이스와 캐시가 동일한 트랜잭션 내에서 새 값으로 업데이트됩니다.\n- 다른 요청이 발생하면, 이번에는 사용자의 잔액을 읽는 요청이 옵니다. 먼저 캐시에서 값을 찾아 사용합니다. 캐시가 가장 최신 값을 가지고 있기 때문에 기본 데이터베이스와 동기화되지 않을까 걱정할 필요가 없습니다.\n\n참고로 3단계는 애플리케이션 로직을 통해 수행할 수 있습니다. 그러나 실제 캐싱 제품에서는 해당 역할을 하게 됩니다. 예를 들어 EHCache나 Infinispan을 사용하는 경우 애플리케이션은 Redis 캐시를 업데이트하고, 다시 데이터베이스를 업데이트할 수 있도록 구성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 코드가 Markdown 형식으로 변경된 것입니다.\n\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_5.png)\n\n# 장점\n\n- 캐시와 기본 데이터 저장소 사이의 일관성을 보장합니다.\n\n# 단점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 트랜잭션 복잡성은 이제 캐시와 데이터베이스 업데이트 모두를 보장하기 위해 어떤 종류의 2단계 커밋 로직이 필요합니다 (캐시에 의해 제어되지 않는 한)\n- 운영상의 복잡성, 위의 어느 하나가 실패하면 사용자 경험을 세련되게 처리해야 합니다.\n- 쓰기가 더 느려집니다. 왜냐하면 이제 두 군데 (캐시 및 데이터 저장소)를 업데이트해야 하기 때문에 데이터 저장소에 하나만 업데이트할 때보다 더 많은 시간이 걸리게 됩니다.\n\n# 사용 시기\n\nStrong data consistency를 필요로 하고 퇴보된 데이터를 제공할 여유가 없는 애플리케이션에 적합합니다. 데이터가 작성된 직후 즉시 정확하고 최신 상태여야 하는 환경에서 흔히 사용됩니다.\n\n# Write-Around Caching\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 전략은 기본 저장소를 채우지만 캐시 자체는 채우지 않습니다. 다시 말해, 이 쓰기는 캐시를 우회하고 기본 저장소에만 쓰입니다. 이 기술과 Cache-Aside 기술 간에는 일부 중첩이 있습니다.\n\n차이점은 Cache-Aside에서 읽기와 지연로딩에 초점을 맞추는 반면, Write-Around 캐싱에서는 쓰기 성능에 초점을 맞추는 것입니다. 이 기술은 자주 데이터를 쓰지만 드물게 읽을 때 캐시 오염을 피하기 위해 종종 사용됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_6.png\" /\u003e\n\n# 장점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 캐시 오염이 줄어듭니다. 이는 모든 쓰기 작업에서 캐시가 채워지지 않기 때문입니다.\n\n## 단점\n\n- 일부 레코드가 자주 읽히고 캐시에 사전으로 로드되어 첫 번째 히트 시 데이터베이스로의 전송을 방지해야 하는 경우 성능이 저하됩니다.\n\n## 언제 사용해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은 양의 쓰기 작업이 이루어지지만 읽기 작업은 상대적으로 적을 때 자주 사용됩니다.\n\n# Write-Back (Write-Behind) 캐싱\n\n쓰기 작업이 먼저 캐시를 채우고 데이터 저장소에 기록됩니다. 이곳의 핵심은 데이터 저장소에 쓰기가 비동기적으로 발생한다는 점입니다. 그러므로 이러한 경우 두 단계 트랜잭션 커밋이 필요 없어집니다.\n\n쓰기 지연 캐싱 전략은 보통 캐싱 제품에서 처리됩니다. 캐싱 제품이 이러한 메커니즘을 갖고 있다면, 응용 프로그램은 캐시에 쓰기를 하고, 캐싱 제품은 변경 사항을 데이터베이스로 전송하는 책임이 있습니다. 만약 캐시 제품에서 이를 지원하지 않는다면, 응용 프로그램 자체가 데이터베이스로 비동기적인 업데이트를 트리거할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_7.png)\n\n## 장점\n\n- 초기 트랜잭션 내에서 캐시에만 쓰기 작업이 발생하므로 쓰기 속도가 빨라집니다. 데이터베이스는 나중에 업데이트됩니다.\n- 흐름을 캐싱 제품이 처리하면 애플리케이션 로직이 덜 복잡해집니다.\n\n## 단점\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터베이스와 캐시가 새로운 변경 사항을 수신하게 될 때까지 둘 사이에 불일치 가능성이 있습니다.\n- 캐시가 최종적으로 데이터베이스를 업데이트하려고 할 때 오류가 발생할 위험이 있습니다. 이 경우 데이터베이스가 가장 최신 데이터를 수신하도록 보장하기 위해 더 복잡한 메커니즘이 필요할 수 있습니다.\n\n# 사용 시기\n\n쓰기 퍼포먼스가 중요하고 데이터베이스의 데이터가 캐시와 잠시 동안 약간 동기화되어 있어도 괜찮을 때 쓰기 지연 캐싱을 사용할 수 있습니다. 높은 쓰기 부하를 처리해야 하지만 일관성 요구사항이 덜 엄격한 애플리케이션에서 적합합니다. 이 방법이 사용될 수 있는 한 예는 캐시된 콘텐츠를 빠르게 업데이트한 다음 레코드 시스템에 동기화하는 CDNs(콘텐츠 전송 네트워크)입니다.\n\n# 읽기 - 스루\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캐시 생성 방식은 일반적으로 캐시 옆에 두어 캐시 미스 발생 시 데이터베이스로부터 데이터를 가져온후 캐시에 저장하는 것에 유사합니다. 그러나 캐시 생성 방식은 애플리케이션에게 캐시와 데이터베이스를 모두 질의하는 책임을 맡기는 반면, 읽기-스루는 해당 메카니즘을 가지고 있을 경우 해당 제품에게 질의하는 방식입니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_8.png)\n\n# 장점\n\n- 간편함 — 모든 로직이 캐싱 애플리케이션에 캡슐화되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단점\n\n- 캐시 미스 발생 시 데이터베이스에서 데이터를 읽을 때 잠재적인 지연이 발생할 수 있습니다. 데이터 업데이트를 위한 복잡한 무효화 메커니즘이 필요합니다.\n\n# 사용 시기\n\n리드-스루 캐싱은 데이터에 접근하는 코드를 간소화하고자 할 때 사용됩니다. 또한, 캐시가 항상 데이터 저장소의 가장 최근 데이터를 포함하도록 보장하고 싶을 때 사용됩니다. 쓰기보다 읽기가 더 자주 발생하는 애플리케이션에 유용합니다. 그러나 여기서 중요한 점은 캐싱 제품이 구성 또는 기본 시스템에서 이러한 읽기를 수행할 수 있는 능력을 가져야 한다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 캐싱 전략 요약\n\n다섯 가지 캐싱 패턴에 대해 이야기한 내용을 아래에서 요약했습니다.\n\n## 캐시 옆에 캐싱\n\n애플리케이션이 캐시에서 데이터를 찾지 못하고 요청할 때만 요청에 따라 데이터가 캐시로 로드됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 예시: 온디맨드로 제품 세부 정보를 캐싱하는 전자 상거래 웹사이트.\n\n데이터베이스 작업 책임: 응용 프로그램\n\n## 쓰기-스루\n\n일괄 쓰기 작업은 일괄 캐시 및 기본 데이터 저장소에 동시에 작성되어 일관성을 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 예시: 거래마다 일관된 계좌 잔액을 유지하기 위한 은행 시스템\n\nDB 작업 책임: 캐싱 제품 또는 애플리케이션\n\n## Write-Behind (Write-Back)\n\n쓰기 작업은 먼저 캐시에 기록되고 나중에 데이터 저장소에 비동기적으로 기록됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 예시: CDN이 먼저 캐시에 콘텐츠를 업데이트하고 나중에 스토리지 시스템에 동기화하는 방식입니다.\n\nDB 작업 책임: 제품 또는 애플리케이션 캐싱\n\n## 라이트-어라운드\n\n쓰기 작업은 캐시를 우회하고 데이터 저장소를 직접 업데이트하여 즉시 필요하지 않은 데이터를 캐싱하는 것을 피합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 예시: 로그 작업에 대한 어디에서 캐싱없이 직접 스토리지로 기록합니다.\n\n데이터베이스 작업 책임: 애플리케이션\n\n## Read-Through\n\n캐시는 읽기를 위한 주요 인터페이스 역할을 합니다. 캐시에 데이터가 없으면 시스템에서 해당 데이터를 가져와 캐시에 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 예시: 사용자 프로필 서비스가 캐시 미스 상황에서 사용자 데이터를 가져오고 캐싱하는 경우.\n\nDB 작업 책임: 제품 또는 응용 프로그램 캐싱\n\n## 캐시 무효화\n\n이제 우리는 캐시를 채우는 다양한 방법을 이해했으니, 기록 시스템과 동기화하여 유지하는 방법도 이해해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캐시 무효화에 관한 두 가지 주요 접근 방식은 시간 기반 방식과 이벤트 기반 방식입니다. 무효화를 위한 시간 기반 접근 방식은 대부분의 캐싱 제품에서 제공되는 TTL(Time-To-Live) 설정으로 제어할 수 있습니다. 이벤트 기반 접근 방식은 응용 프로그램이나 다른 요소가 새 레코드를 캐시로 전송해야 합니다.\n\n데이터 캐시에 대한 중요한 점은 거의 항상 기본 데이터 저장소(시스템 기록)와 어느 정도 동기화되어 있지만 매우 빨리 구식이 된다는 것입니다. 다시 말해 — 구식 상태가 됩니다. 캐시를 가능한 한 시스템 기록과 동기화된 상태로 유지하기 위해 캐시 무효화 전략을 구현해야 합니다.\n\n다시 말해, 캐시 내에서 데이터 \"신선도\"를 보장해야 합니다.\n\n캐시 무효화는 새 레코드가 시스템 기록으로부터 검색되어 캐시로 입력되는 현상을 유발합니다. 따라서 캐시 무효화와 위에서 논의한 캐싱 전략 사이의 관계를 이해하는 것이 매우 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캐싱 전략은 데이터가 캐시에서 로드되고 검색되는 방식과 관련이 있습니다. 반면에 캐시 무효화는 시스템 레코드와 캐시 간 데이터 일관성과 신선도와 더 관련이 있습니다.\n\n따라서 이 두 가지 개념 사이에는 약간의 중첩이 있으며 일부 캐싱 전략에서는 무효화가 다른 것보다 간단할 수 있습니다. 예를 들어 캐시-쓰기 쓰기 방식의 경우 캐시가 모든 쓰기마다 업데이트되므로 추가 구현이 필요하지 않습니다. 하지만 삭제는 반영되지 않을 수 있기 때문에 명시적으로 이를 다루는 응용 프로그램 논리가 필요할 수 있습니다.\n\n캐싱 엔트리를 무효화하는 두 가지 방법이 있습니다:\n\n## 이벤트-드리븐\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이벤트 기반 접근 방식을 사용하면 응용 프로그램이 기록의 기반 저장소에서 변경이 발생할 때마다 캐시를 알립니다. 레코드가 변경될 때마다 동기적 또는 비동기적으로 캐시에 알림을 트리거합니다.\n\n이 작업은 응용 프로그램을 통해 수행할 수 있으며, 코드가 캐시를 최신 상태로 유지하는 것에 책임이 있습니다. 또는 일부 캐싱 제품에서는 퍼브/섭 기능이 제공될 수 있으며, 캐싱 제품이 이러한 유형의 알림에 가입할 수 있습니다. 그 경우 응용 프로그램에서 할 작업이 덜 할 수 있지만, 여전히 이러한 알림 이벤트를 생성해야 합니다.\n\n## 시간 기반\n\n시간 기반 접근 방식을 사용하면 모든 캐시 레코드에 TTL(임시 소멸 시간)이 지정됩니다. 레코드의 TTL이 만료되면 해당 캐시 레코드가 삭제됩니다. 이것은 일반적으로 캐싱 제품에 의해 제어됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 캐시 축출 전략\n\n캐시 축출은 기존 캐시 레코드를 제거하는 캐시 무효화와 유사합니다. 그러나 캐시 축출은 캐시가 가득 차서 더 이상 레코드를 수용할 수 없는 경우에 필요합니다.\n\n기억하세요, 캐시의 목적은 가장 자주 액세스되는 레코드의 부분 집합을 저장하는 것입니다. 전체 진실의 원본 시스템을 복제하는 것이 아닙니다. 따라서 캐시의 크기는 일반적으로 데이터베이스 / 진실의 원본 / 기록 시스템에 저장된 데이터의 크기보다 훨씬 작을 것입니다.\n\n따라서 레코드를 \"축출\" 또는 다른 말로 삭제할 수 있는 메커니즘이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n동시에 캐시의 존재 이유를 완전히 무의미하게 만들지 않기 위해 애플리케이션이 제일 필요하지 않을 것으로 생각되는 레코드부터 시작해야 합니다.\n\n최적으로 레코드를 제거하는 방법을 보장하기 위해 사용할 수 있는 몇 가지 퇴직 전략이 있습니다:\n\n## Least Recently Used (LRU)\n\n이 접근 방식을 통해, 얼마 동안 사용되지 않은 레코드를 제거합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용 시기: 데이터가 마지막으로 액세스된 후 시간이 경과함에 따라 데이터가 곧 액세스될 가능성이 줄어드는 시나리오에서 효과적입니다. 미래 액세스의 강력한 지표인 액세스 최근성을 고려하는 일반적인 캐싱에 적합합니다.\n\n사용하지 말아야 할 때: 데이터 액세스 패턴이 최근성과 관련이 없는 워크로드에는 이상적이지 않습니다.\n\n## 먼저 들어온 것이 먼저 나간다 (FIFO)\n\n다른 레코드보다 이전에 캐시에 저장된 레코드를 제거합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용할 때: 데이터의 나이가 액세스 빈도나 최근성보다 중요한 캐시에 유용합니다. 예측 가능한 수명을 가진 데이터를 캐싱하는 데 적합합니다.\n\n사용하지 않을 때: 이전 데이터가 여전히 빈번하게 액세스되는 워크로드에는 최적이 아닙니다.\n\n## 최소 사용 빈도 순서 (LFU)\n\n빈번하게 사용되지 않거나 액세스되지 않는 레코드를 삭제합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용 시기: 오랜 기간 동안 자주 액세스되는 데이터를 보관해야 하는 상황에 가장 적합합니다. 안정된 액세스 패턴을 갖는 애플리케이션에 적합합니다.\n\n사용하지 말아야 하는 경우: 액세스 패턴이 크게 변할 수 있는 환경에서는 효과가 떨어집니다. 자주 액세스되지 않는 항목들이 캐시를 오염시킬 수 있습니다.\n\n## Time To Live (TTL)\n\n미리 결정된 Time-To-Leave 기간에 따라 퇴거합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용 시기: 특정 기간 이후에 만료되거나 변하지 않는 데이터에 이상적입니다.\n\n사용하지 말아야 할 때: 유효성이 시간이 지나면 자연스럽게 종료되지 않고 다른 요인에 따라 캐시에 영원히 남아있어야 하는 데이터에 적합하지 않습니다.\n\n## 무작위 치환\n\n기록을 무작위로 대체합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용 시점: 고급 추적 메커니즘의 비용이 혜택을 상쇄하는 상황이거나 액세스 패턴이 예측할 수 없어 다른 제거 전략이 적합하지 않은 경우에 사용할 수 있습니다.\n\n사용하지 않는 시점: 대체로 다른 전략에 비해 대부분 예측 가능한 액세스 패턴이 있는 실제 시나리오에서는 효율이 떨어질 수 있습니다.\n\n# 요약\n\n분산 응용 프로그램에서 캐싱의 중요성과 올바른 캐싱 전략을 선택하는 중요성에 대해 이야기했습니다. 일반적으로 사용되는 여러 전략이 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 캐시 오프 (Cache-aside)\n- 쓰기-스루 캐시 (Write-through cache)\n- 읽기-스루 캐시 (Read-through cache)\n- 쓰기 배후 캐시 (Write-behind cache)\n- 쓰기 주변 캐시 (Write Around)\n\n우리는 또한 시간 기반 또는 이벤트 기반 접근 방식을 사용하여 캐시 무효화에 대해 이야기했습니다.\n\n캐시 제거의 중요성과 어떤 전략이 그 일을 수행하는지에 대해 주목했습니다. 이것들은 다음과 같습니다:\n\n- LRU\n- FIFO\n- LFU\n- TTL\n- 임의(Random)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 캐시는 로컬 또는 분산 형태일 수 있습니다. 전자는 단일 기계/응용프로그램 인스턴스에 한정되어 있습니다. 후자는 여러 기계에 걸쳐 확장되며 일반적으로 (필수는 아니지만) 인스턴스 클러스터에 한정되어 있습니다.\n\n많은 혁신이 시장에서 발생하고 있는 캐시 제품과 관련된 기술들과 유행에 대해 몇 가지 명확한 정보를 제공했기를 바랍니다. 왜 캐싱이 중요한지, 그리고 캐싱 기술을 다룰 때 이해해야 하는 모든 다른 용어와 미묘한 점에 대한 직관력을 향상시켜주길 바랍니다.\n\n# 캐싱: 미래\n\n다른 기술들과 마찬가지로 캐싱 제품이 시장에서 엄청난 혁신이 일어나고 있습니다. 일부 주목할만한 하이라이트는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 에지 컴퓨팅과 통합\n\n에지 컴퓨팅이 계속해서 성장함에 따라, 캐싱 전략은 더 분산화되어 데이터를 네트워크 가장자리에 필요한 위치에 더 가까이 이동시킵니다. 이 근접성은 레이턴시, 대역폭 및 데이터 제공 비용을 줄입니다. 이는 IoT 및 모바일 앱과 같은 실시간 응용 프로그램에 매우 중요합니다.\n\n예시: 자율 주행 차량은 에지 컴퓨팅을 사용하여 실시간 데이터를 로컬에서 처리합니다. 지도 및 교통 상황과 같은 핵심 데이터를 에지 노드에서 캐싱하면 중앙 서버를 쿼리하는 레이턴시 없이 신속한 의사결정을 할 수 있습니다.\n\n# AI와 머신 러닝 기반 캐싱\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAI와 머신 러닝은 데이터 사용 패턴을 예측하고 예상된 필요에 따라 미리 데이터를 캐싱함으로써 캐싱 메커니즘을 향상시킬 수 있습니다. 이러한 예방적인 접근 방식은 효율성을 크게 향상시킬 수 있습니다. 특히 데이터 액세스 패턴이 자주 변경되는 동적 환경에서는 더욱 그렇습니다.\n\n예시: 아마존은 머신 러닝을 사용하여 사용자 행동을 예측하고 블랙 프라이데이와 같은 피크 타임에 사용자가 구매할 가능성이 높은 제품을 미리 캐싱합니다. 이는 로드 시간을 줄이면서 사용자 경험을 향상시킵니다.\n\n# 인메모리 데이터 그리드 (IMDG)\n\nIMDG는 분산 시스템 전반에 걸쳐 저지연 복잡한 데이터 액세스를 제공하는 캐싱의 강력한 솔루션이자 빠르게 발전하고 있습니다. IMDG는 데이터를 캐싱뿐만 아니라 캐시 레이어 내에서 다양한 데이터 처리 기능, 실시간 분석 및 의사 결정 기능을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시: 고주파 트레이딩 플랫폼은 IMDG를 활용하여 시장 데이터와 거래 주문을 메모리에 캐시합니다. 이를 통해 서브초 단위 거래 결정을 내리는 데 필수적인 빠른 액세스와 처리가 가능해집니다.\n\n안녕하세요, 저는 야코프입니다. CloudWay Digital Inc을 운영하고 있는 소프트웨어 아키텍처 컨설팅 기관인 Developer.Coach에서 소프트웨어 엔지니어와 아키텍트들이 경력을 향상시키는 데 도와드리고 있습니다.\n\n제 Medium 무료 기사 외에도, 소프트웨어 엔지니어링 전문가들의 경력 향상에 도움이 되는 가이드 몇 편을 작성했습니다. 아래 링크를 통해 확인해보세요:\n\n👉 소프트웨어 아키텍트의 경력 잠금 해제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n👉 소프트웨어 아키텍트 인터뷰 마스터하기\n\n👉 소프트웨어 엔지니어링 경력 잠금 해제: 중급에서 시니어로\n\n원본 게시물: 2024년 5월 17일, https://www.cloudwaydigital.com 에서 게시됨.\n","ogImage":{"url":"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png"},"coverImage":"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png","tag":["Tech"],"readingTime":16},{"title":"AI-강화 주제 탐구로 예술 창작을 재정의하기","description":"","date":"2024-05-23 13:21","slug":"2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration","content":"\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png)\n\n기술의 끊임없는 발전 속에서 AI는 계속해서 한계를 넓히고 가능성을 재정의합니다.\n\nAsycd에서는 스스로에게 이렇게 물었습니다: AI를 활용하여 예술적인 과정을 혁신할 수 있는 방법은 무엇일까요? 이 질문은 TEV1 – 테마틱 익스플로러 V1의 탄생으로 이어졌습니다. 그러나 TEV1의 변화의 힘에 대해 들어가기 전에, 그 탄생 배경과 갖추고 있는 탁월한 기능들을 탐험해보겠습니다.\n\n# 왜 우리가 TEV1을 만들었는가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![TEV1 Image 1](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_1.png)\n\nTEV1의 시작은 예술적 창작 프로세스를 단순화하고 향상시키는 욕망에서 비롯되었습니다. 우리는 작가, 작가 및 크리에이터들이 종종 자신의 비전과 일치하는 주제를 개념화하고 시각물을 생성하는 데 상당한 시간을 소비한다는 것을 인지했습니다. 우리의 목표는 이러한 시간과 노력을 줄이고, 창작자들이 핵심 창작 작업에 더 집중할 수 있는 도구를 디자인하는 것이었습니다.\n\n게다가, 특히 DALL-E 3 및 GPT-4o와 같은 도구를 통한 인공 지능의 발전으로 고품질의 특정 주제 이미지를 생성하는 잠재력이 실행 가능하고 매력적해졌습니다. TEV1은 이러한 잠재력을 활용하기 위한 우리의 대응책으로, 창작자들에게 강력하고 직관적인 도구를 제공하여 세계 어디서나 사용할 수 있도록 합니다.\n\n![TEV1 Image 2](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 이미지 생성 능력의 발전에 큰 투자 관심을 가지고 있습니다. 이미지 생성 도구를 사용하여 아이디어를 반영적 이미지로 변환하는 능력은 이미 훌륭하지만, 우리가 생각하는 것과 볼 수 있는 것 사이의 간격을 좁히는 것이 중요합니다.\n\n마음에 떠오르는 무작위 아이디어를 화면이나 캔버스, 심지어 의류 디자인으로 구현하는 것이 TEV1의 목적입니다.\n\n# TEV1 작동 원리\n\nTEV1은 최첨단 AI 기술인 DALL-E 3과 이미지 생성 및 콘텍스트 이해, 이미지 프롬프트 향상을 위해 GPT-4o를 사용하여 구축되었습니다. 사용자가 주제를 입력하면 TEV1은 이러한 고급 모델을 사용하여 주제를 분석하고 해당 주제의 본질을 담은 시각적 표현물을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_3.png)\n\n저희 도구에는 컨텍스트 로딩, 자동 데이터 처리 및 RAG와 같은 복잡한 기능이 포함되어 있어 생성된 이미지가 관련성을 가지고 미학적으로 매력적인 것을 보장합니다. 현재는 관심도 및 성능을 측정하기 위한 샘플 생성에 제한되어 있지만, TEV1은 지속적인 사용자 피드백과 모델 훈련을 통해 발전하도록 설계되었습니다.\n\n## 데이터에서 아트로 — 우리가 새로운 아트워크를 위해 역사적 데이터를 활용하는 방법\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAsycd의 설립 이후로 우리는 예술을 생성하고 텍스트 설명을 만드는 작업을 진행해 왔습니다. 이러한 텍스트 설명은 대부분 내부에서 저장되어 사용되어 왔지만, 앞으로 출시될 웹 애플리케이션을 위한 TEV1 모델 훈련에 사용될 예정입니다.\n\n오늘을 기준으로 이러한 설명 중 일부는 저희 웹사이트에서 접근 가능한 곳에 공개되어 있습니다. 이 데이터를 사용하여 이전과 동일한 프롬프트 기술과 스타일을 활용하여 새로운 작품을 만들고 있습니다. 이 과정에 대해 자세히 다룰 예정이며, 이는 매우 상세한 과정이기 때문입니다.\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_5.png)\n\n우리는 이 데이터를 활용하여 이전 작품에 성공적인 프롬프트 기술과 스타일을 사용하여 새로운 작품을 생성합니다. 이를 통해 과거 작업에서 영감을 빨아들이면서도 지속적이고 고품질의 예술을 만들어낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# TEV1: 예시 및 사용 사례 소개\n\nTEV1은 다양한 시각 디자인 분야에서 사용되며 다양한 매체에 대한 매우 상세한 그래픽을 생성할 수 있습니다.\n\n## 예술적 영감\n\nTEV1의 주요 사용 사례 중 하나는 예술적 영감을 제공하는 것입니다. 예술가들은 '어두운 심리학'부터 '로맨티시즘'까지 다양한 주제를 입력할 수 있으며, TEV1은 이러한 주제와 일치하는 이미지를 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Image](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_6.png)\n\nTEV1은 짧은 아이디어나 개념을 이야기를 담은 예술작품으로 변화시킬 수 있어요. 빠르게 떠오르는 영감을 활용하기에 안성맞춤이에요. 첨단 프롬프트 공학과 다양한 대형 언어 모델의 다층구조 덕분에, 테마 익스플로러 V1은 이미지뿐만 아니라 주제에 맞는 시각적 일치 작품을 생성해요.\n\n이 종합적인 방법론은 덧없는 생각을 다채롭고 표현력 풍부한 작품으로 변모시켜요. 이 작품들은 소셜 미디어 게시물부터 마케팅 자료 등 다양한 용도로 사용할 수 있어요.\n\n## 그래픽 디자인과 웹 디자인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n취미로 즐기는 분들과 열정적인 창작가들을 위해 TEV1은 개인 프로젝트를 현실로 만들어 주는 견고한 플랫폼을 제공합니다. 개인 블로그를 위한 독특한 시각적 콘텐츠 작성, 소설을 위한 스토리보드 디자인, DIY 프로젝트를 위한 주제별 아트워크 초안 작성 등, TEV1은 창작하는 여러분의 작품에 전문적인 손길을 더해줍니다.\n\n우리는 이 도구를 사용하여 웹사이트의 장식을 완전히 맞춤화했고, 지속적인 개선 노력 덕분에 우리 웹사이트가 이전보다 더 멋지게 변했습니다!\n\n![TEV1 이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_7.png)\n\n웹 디자이너들은 TEV1 이미지 생성기를 활용하여 자신들의 웹사이트에 완벽한 배경 씬을 설정할 수 있는 매료되는 이미지를 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래픽 디자이너들에게 TEV1 세대는 가능성의 보물창고입니다. 그들은 끝없는 패턴, 생동감 넘치는 디자인, 그리고 고유한 구성에 접근하여 창의적인 과정을 시작하거나 프로젝트에 마지막 손짓을 더할 수 있습니다. 이는 올해 초부터 \"VALENHEARTS\" 컬렉션에서 작업한 예술가들에 의해 그렇게 사용되었고, 이 도구의 창의적인 힘을 조금 오박사 단계에서 목격했습니다.\n\n![TEV1](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_8.png)\n\n## 모든 것을\n\n우리는 이것을 창의적이거나 디자인 중심의 모든 것에 사용할 수 있다고 생각합니다. 우리는 캔버스로 시작했지만, 희망적으로 다른 모든 가능한 사용 사례를 탐색할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 마케팅 및 광고: 캠페인, 소셜 미디어 게시물 및 광고를 위한 독특하고 화려한 시각물을 제작합니다.\n- 게임 개발: 컨셉 아트, 캐릭터 디자인 및 환경 텍스처를 생성합니다.\n- 패션 디자인: 원단을 위한 패턴과 프린트를 개발합니다.\n- 인테리어 디자인: 커스텀 이미지로 방 구성과 장식을 시각화합니다.\n- 교육: 설명적인 다이어그램과 창의적인 이미지로 학습 자료를 향상합니다.\n- 엔터테인먼트: 음악 앨범, 책 표지 및 프로모션 포스터를 위한 아트워크를 제작합니다.\n\n# 곧 만나요!\n\nTEV1을 계속 개발하고 개선하는 동안, 여러분은 여기에서 시도해보시고 피드백을 제공해 주시기 바랍니다. 웹 앱의 예상 출시일은 6월 말이니 조금만 기다려 주시고, 계속 영감을 얻어 주세요!\n\n“항상 할 수 있는 것이 있다” - \"Asycd\"\n","ogImage":{"url":"/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png"},"coverImage":"/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png","tag":["Tech"],"readingTime":5},{"title":" 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 ","description":"","date":"2024-05-23 13:20","slug":"2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign","content":"\n\n요즘에는 인공 신경망에 대해 많은 사람들이 이야기하지만 자신의 신경 체계에 대해 알고있는 사람은 매우 드물어요.\n\n![이미지](/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png)\n\n제품 개발에 관여하는 모든 사람들에게 중요한 것은 사용자가 제품을 인지하는 데 필요한 것을 이해하는 것입니다:\n\n1) 제품에 주목하게 만드는 것 (외생적 주의),\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2) Keep a sustained interest (internal attention),\n\n3) Purchase the product with the belief that it will meet your needs.\n\nTherefore, we have three main neural networks:\n\n✅ 1. Default Mode Network - which controls our social reasoning. You might remember how you naturally start thinking about your family, coworkers, or someone who was rude to you in line.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 조상들이 작은 그룹에서 함께 생활하며 형성된 가능성이 높아요. 이것은 그들이 부족한 것들 사이에서 모든 사회적 상호작용을 이해하고 지켜주는 데 도움을 주었고, 한 마디로 말해 전체 네트워크를 형성했어요 — 이것이 뇌의 기본 시스템이에요. 이 기본 시스템은 다른 이들의 반응을 예측할 수 있어요. 수천 년 동안 우리 뇌는 신체적으로 크게 변하지 않았지만, 해야 할 일들의 목록은 크게 증가했어요. 우리는 다양한 문제를 해결하기 위해 같은 DMN을 사용하며, 사람들을 일시적으로 그것에서 떼어내어 해방된 공간에 사실, 추상적인 개념, 숫자, 그래프를 채워 넣어 일을 할 수 있어요.\n\n✅ 2. Salience Network — 이 시스템은 특정 지적 작업에 집중할 수 있는 능력을 제공해요. 들어오는 정보를 처리하고 외부 자극을 평가해요.\n\n✅ 3. Central Executive Network — 또한 들어오는 정보를 처리하고 외부 자극을 평가하고 분석해요.\n\n중요한 점은 이 세 시스템이 서로 경쟁한다는 것이에요🤓.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 작업에 집중할 때 (주의 네트워크) 주변에 덜 주의를 기울이게 되고, 그러면 어쩌다가 누군가와의 불쾌한 대화에 대해 생각하게 되는 경우가 생길 수 있어요 (기본 모드 네트워크가 우세해집니다).\n\n💡 광고에 있어서 외부 주의 (광고 배너와 같은 외부 신호로 인한 주의)가 어떻게 작용하는지 이해하는 것이 중요합니다.\n\n💡 온보딩에 있어서 중요한 것은 관심이 인위적으로 유발될 수 있다는 것을 깨달아야 합니다. 뇌는 어떤 것에 대한 이해의 모형을 형성하기 전에 사실들의 집합을 축적할 수 있는 능력을 갖고 있어요. 처음에는 흥미로워 보이지 않더라도, 사실이 축적되고 성공적인 작업 완료로 강화되는 경우, 흥미가 발전할 수 있어요. 이것이 온보딩의 주요 기능 중 하나에요.\n\nP.S. 다음에는 우리 뇌가 구매 결정을 내리는 방식에 대해 이야기할 거에요 😇.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png"},"coverImage":"/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png","tag":["Tech"],"readingTime":2},{"title":"SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법","description":"","date":"2024-05-23 13:19","slug":"2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro","content":"\n\u003cimg src=\"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png\" /\u003e\n\n안녕하세요! 오늘은 여러분께, 널리 확장된 로직을 사용하지 않고 모든 텍스트 필드를 한꺼번에 유효성을 검사하는 방법을 보여드리려고 합니다. 이번에는 텍스트 필드의 유효성을 검사하는 나쁜 방법과 좋은 방법을 구분하는 것을 목표로 하고 있어요.\n\n먼저, 예제를 아주 간단하게 유지할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 개의 텍스트 필드와 사용자 입력을 저장하는 비밀번호를 위한 한 개의 보안 필드가 있는 화면이 있다고 가정해봅시다. 이 숫자는 간단히 유지하기 위한 것이며, 실제 상황에서는 10개가 될 수도 있습니다.\n\n```js\nstruct ContentView: View {\n   @State var email : String = \"\"\n   @State var password : String = \"\"\n   @State var name : String = \"\"\n   @State var surname : String = \"\"\n    var body: some View {\n          VStack {\n             TextField(\"이메일\", text: $email)\n             TextField(\"이름\", text: $name)\n             TextField(\"성\", text: $surname)\n             SecureField(\"비밀번호\", text: $password)\n             Spacer().frame(height: 300)\n             Button {\n\n\n             } label: {\n                Text(\"여기를 눌러보세요!\")\n                   .padding(.all)\n                   .background(.red)\n                   .cornerRadius(16)\n             }\n          }\n          .padding()\n       }\n}\n```\n\n이제 나쁜 방식과 좋은 방식을 구분하여 느껴보겠습니다.\n\n#나쁜 방식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nButton {\n    // 먼저 원하는 방식으로 유효성을 확인합니다.\n    if email.count \u003e 6 \u0026\u0026 password.count \u003e 12\n            \u0026\u0026 !name.isEmpty \u0026\u0026 !surname.isEmpty {\n        // 네트워킹 호출 수행!\n        // 이것은 영원히 계속됩니다.\n        // 읽기가 어렵고 확장 가능하지 않으며 재사용 가능하지 않습니다.\n    } else {\n        // 얼럿 팝업 등을 표시합니다.\n    }\n\n} label: {\n    Text(\"여기를 탭하여 시도해보세요!\")\n        .padding(.all)\n        .background(.red)\n        .cornerRadius(16)\n}\n```\n\n# 좋은 방법\n\n이제 진짜 작업이 시작되었지만, 먼저 이 솔루션을 사용하기 위해 SwiftUI의 일부 주요 기능을 알아야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**PreferenceKey**\n\nPreferenceKey 유형은 자식 뷰에서 부모 뷰로 뷰 트리를 업데이트하는 데이터 흐름을 처리하는 솔루션인데, 어떤 종류의 위임이나 생성자 핸들러를 사용하지 않고도 작업할 수 있습니다. 제가 본 바로는 널리 사용되지 않지만, 정말 복잡하지는 않습니다. 어느 정도로 보면, @EnvironmentObject의 역이라고 할 수 있습니다.\n\nPreferenceKey는 이미 NavigationView의 타이틀이나 TabViews 선택 및 자식의 id 등에 사용되고 있습니다.\n\n우리가 어떻게 사용자 정의 preference key를 정의할 수 있는지 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n구조체 ValidationPreferenceKey : PreferenceKey {\n   static var defaultValue: [Bool] = []\n\n   static func reduce(value: inout [Bool], nextValue: () -\u003e [Bool]) {\n      value += nextValue()\n   }\n}\n```\n\n이것은 사용자 지정 PreferenceKey를 정의하는 구문입니다. 이 특정 프로토콜을 준수하기 위해 두 가지를 구현해야 합니다.\n\n```js\nstatic var defaultValue: [Bool] = []\n```\n\n이 기본 값은 Equatable을 준수하는 한 어떤 것이든 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nstatic func reduce(value: inout [Bool], nextValue: () -\u003e [Bool]) {\n      value += nextValue()\n   }\n```\n\n우리는 이 줄이 키가 등록된 키의 여러 반복에서 무엇을 해야 하는지를 정의하는 리덕션 함수를 구현해야 합니다.\n\n예를 들어, TabView가 있고 그 안에 여러 개의 하위 뷰가 있고 모두 .id() 수정자를 가지고 있다고 하면, 이 reduce 함수는 모든 id 수정자 값에 사용됩니다.\n\nTextField에서 이를 사용하려면 두 단계가 필요합니다\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1- 뷰 수정자\n\n2- 익스텐션\n\n이제 이를 위해 ViewModifier를 어떻게 구현하는지 보여드릴게요\n\n```js\nstruct ValidationModifier : ViewModifier  {\n   let validation : () -\u003e Bool\n   func body(content: Content) -\u003e some View {\n         content\n            .preference(\n               key: ValidationPreferenceKey.self,\n               value: [validation()]\n            )\n      }\n   }\n````\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 수정자는 그 특정 뷰에 해당하는 키를 등록합니다.\n\n```js\nlet validation: () -\u003e Bool\n```\n\n이 변수는 우리가 유효성 검사에 사용할 로직을 보유할 것입니다.\n\n그리고 이 확장은 이를 일부 특정 유형의 뷰에 대해서만 적용합니다. TextFields 및 SecureFields와 같은 뷰입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\nextension TextField {\n   func validate(_ flag: @escaping () -\u003e Bool) -\u003e some View {\n      self\n         .modifier(ValidationModifier(validation: flag))\n   }\n}\n\nextension SecureField {\n   func validate(_ flag: @escaping () -\u003e Bool) -\u003e some View {\n      self\n         .modifier(ValidationModifier(validation: flag))\n   }\n}\n```\n\n여기서 중요한 두 가지 아쉬움이 있습니다. 첫째로, 우리는 TextFields 텍스트를 노출할 수 없습니다. 이것은 이니셜라이저에서만 사용 가능하며 Apple에 의해 노출되지 않습니다.\n\n둘째로, TextField와 SecureField는 View가 아닌 동일한 형식에서 상속되지 않기 때문에 이것을 단일 확장으로 줄일 수 없습니다. 해결 방법이 있다면 알려주세요!\n\n이 modifier를 다른 뷰에서 사용할 수 없도록 유지하려면 동일한 파일에서 modifier와 확장을 정의하고 modifier를 private으로 만들 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막 부분 빼고는 설정이 완료되었어요.\n\n마지막으로, 이 키의 업무를 처리할 뷰를 정의해야 해요.\n\n```js\nstruct TextFormView\u003cContent : View\u003e : View {\n   @State var validationSeeds : [Bool] = []\n   @ViewBuilder var content : (( @escaping () -\u003e Bool)) -\u003e Content\n   var body: some View {\n         content(validate)\n         .onPreferenceChange(ValidationPreferenceKey.self) { value in\n            validationSeeds = value\n         }\n   }\n\n   private func validate() -\u003e Bool {\n      for seed in validationSeeds {\n         if !seed { return false}\n      }\n      return true\n   }\n}\n```\n\n이 컨테이너 뷰는 이 키 타입에서 로직을 실행하고, Vstack 또는 TabView와 같은 뷰를 내부에 가져옵니다. .onPreferenChange 수정자를 본 적 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 수정자는 이 키에서 자식 뷰 업데이트를 잡습니다.\n\n그래서\n\n```js\n.preference(\n               key: ValidationPreferenceKey.self,\n               value: [validation()]\n            )\n```\n\n이렇게 업데이트됩니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n.onPreferenceChange(ValidationPreferenceKey.self) { value in\n  validationSeeds = value\n}\n```\n\n각 자식 뷰의 키 값을 캐치해요. [Bool]가 아니라 Bool로 반환했던 것 기억하시죠? 이건 단지 validationSeeds 변수에 할당하기 위한 것이에요. 이 validationSeeds 변수는 .validate() 확장 ValidationPreferenceKey로 수정된 각 자식 뷰를 보유하고 있어요.\n\n이제 모든 필드의 Key 값이 TextFormView에 있으니 이 데이터를 처리하고 무언가를 구축할 수 있어요.\n\n```js\nprivate func validate() -\u003e Bool {\n  for seed in validationSeeds {\n    if !seed { return false }\n  }\n  return true\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 함수는 그냥 제가 생각해 낸 것일 뿐이에요. 필수적이지는 않지만 저는 좋아해요.\n\n```js\n@ViewBuilder var content : ((@escaping () -\u003e Bool)) -\u003e Content\n                        // (validate) -\u003e Content 이게 무슨 뜻인지에요.\n```\n\n우리는 그냥 이 TextFormView 바깥으로 이 validate 함수를 노출시키는 것 뿐이에요.\n\n이제 이것을 우리 뷰에서 사용할 수 있고, 다음과 같이 될 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 유효성 검사를 만들었지만, 실제 상황에서는 정규식과 다른 로직을 사용하여 유효성을 검사해야 합니다. 어쩌다 그렇게 했어요.\n\n```swift\nstruct ContentView: View {\n   @State var email : String = \"\"\n   @State var password : String = \"\"\n   @State var name : String = \"\"\n   @State var surname : String = \"\"\n   var body: some View {\n\n       TextFormView  { validate  in // -\u003e 이 부분이 바로 validate 함수에요\n          VStack {\n             TextField(\"Email\", text: $email)\n                .validate {\n                   email.count \u003e 6\n                }\n             TextField(\"Name\", text: $name)\n                .validate {\n                   !name.isEmpty\n                }\n             TextField(\"Surname\", text: $surname)\n                .validate {\n                   !surname.isEmpty\n                }\n             SecureField(\"Password\", text: $password)\n                .validate {\n                   password.count \u003e 10\n                }\n             Spacer().frame(height: 300)\n             Button {\n                if !validate() {\n                   return\n                }\n                // 네트워크 호출을 해주세요\n             } label: {\n                Text(\"Tap here to try!\")\n                   .padding(.all)\n                   .background(.red)\n                   .cornerRadius(16)\n             }\n          }\n       }\n          .padding()\n    }\n\n}\n```\n\n미리 말씀드린 대로 이미지 삽입과 함께, 어떻게 동작하는지 보여주기 위해 validate()을 출력했어요. 모든 필드가 함께 유효성을 검사하는 모습이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기까지 읽어 주셔서 감사합니다.\n\n이것은 시작에 불과하다는 것을 잊지 마세요. 이것을 사용하여 오류 메시지를 반환하거나 어떤 필드가 유효하지 않은지 선택할 수 있습니다. 나중에 이를 사용자 정의할 수도 있을 것 같네요.\n\n어쨌든 나중에 뵙겠습니다! 즐거운 시간 보내세요!\n","ogImage":{"url":"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png"},"coverImage":"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png","tag":["Tech"],"readingTime":8},{"title":"크로스 플랫폼 앱 개발 로드맵","description":"","date":"2024-05-23 13:17","slug":"2024-05-23-Cross-PlatformAppDevelopmentRoadmap","content":"\n\n오늘날의 디지털 시대에서 모바일 앱 개발은 고객과 소통하고 영향을 확대하려는 기업들에게 중요한 요소가 되었습니다.\n\n그러나 모바일 장치와 운영 체제의 다양성이 개발자들에게 어려움을 제공합니다. 이것이 크로스 플랫폼 앱 개발이 필요한 이유입니다.\n\n여기에는 크로스 플랫폼 앱 개발을 잘하기 위한 로드맵이 제시되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 크로스 플랫폼 앱 개발에서의 도전\n\n크로스 플랫폼 개발은 많은 이점을 제공하지만, 고유한 도전 과제들도 함께 따라옵니다.\n\n## 성능 문제\n\n가장 흔한 고민은 크로스 플랫폼 앱의 성능 문제입니다. 개발자들은 코드를 최적화하고 플랫폼별 최적화를 활용하여 원할한 성능을 보장해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 네이티브 기능 제한\n\n크로스 플랫폼 프레임워크는 특정 네이티브 기능 및 기능에 액세스하는 데 제한이 있을 수 있으며, 이로 인해 개발자는 해결책이나 대안적인 솔루션을 찾아야 할 수 있습니다.\n\n## 호환성 문제\n\n다양한 기기, 화면 크기 및 운영 체제 간의 호환성을 보장하는 것은 어려운 작업일 수 있습니다. 철저한 테스트와 최적화가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 적절한 크로스 플랫폼 프레임워크 선택\n\n크로스 플랫폼 앱 개발 프로젝트의 성공을 위해 적절한 프레임워크 선택이 중요합니다.\n\n## 인기 프레임워크 개요\n\nReact Native, Xamarin, Flutter와 같은 프레임워크는 각각 독특한 기능과 능력을 제공하여 다양한 프로젝트 요구사항 및 개발자 선호도에 부합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 크로스 플랫폼 모바일 앱 개발을 위해 고려해야 할 사항\n\n성능, 커뮤니티 지원, 학습 곡선 및 기존 기술과의 통합과 같은 고려 사항이 프레임워크 선택 프로세스에 영향을 미쳐야 합니다.\n\n## 준비 및 계획\n\n개발에 들어가기 전에 철저한 준비와 계획이 필요하며, 이는 프로젝트의 성공을 위해 필수적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 앱 요구 사항 정의\n\n앱의 기능, 기능 및 타겟 대상을 명확히 정의하여 개발 노력이 비즈니스 목표와 일치하도록합니다.\n\n## 타겟 대상 및 시장 조사\n\n사용자 선호도, 시장 동향 및 경쟁사를 이해하면 디자인 및 개발 결정에 영향을 미쳐 사용자 기대치를 충족시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프로젝트 일정 및 중요한 이벤트 설정\n\n명확한 일정과 이벤트 설정은 개발 프로세스를 추적하고 효율적인 프로젝트 관리를 가능하게 합니다.\n\n## 사용자 인터페이스 디자인\n\n잘 디자인된 사용자 인터페이스는 플랫폼 간에 원활한 사용자 경험을 제공하는 데 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 크로스 플랫폼 앱 개발에서 반응형 디자인의 중요성\n\n앱의 레이아웃과 기능을 다양한 화면 크기와 해상도에 맞게 조정하기 위해 반응형 디자인 원칙을 활용하세요.\n\n## 일관된 사용자 경험 생성\n\n모든 플랫폼에서 디자인 요소, 내비게이션 패턴, 브랜딩을 일관되게 유지하여 사용성과 브랜드 인지도를 향상시키세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 개발 단계\n\n기본 작업이 완료되었으므로, 개발자들은 이제 코드를 작성하고 앱을 구현할 수 있습니다.\n\n## 선택한 프레임워크를 사용하여 코드 작성\n\n선택한 프레임워크의 기능과 기능성을 활용하여 앱 로직, 사용자 인터페이스 요소 및 백엔드 통합을 구현하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 테스트 및 디버깅\n\n철저한 테스트는 버그를 식별하고 수정하여 앱이 다양한 기기와 플랫폼에서 의도한 대로 작동하도록 하는 데 중요합니다.\n\n## 반복적인 개발 프로세스\n\n반복적인 접근 방식을 채택하여 사용자 피드백을 통합하고 앱의 기능과 디자인을 점진적으로 개선하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 성능 최적화\n\n성능 최적화는 반응성 있고 효율적인 앱 경험을 제공하는 데 중요합니다.\n\n## 앱 성능 향상을 위한 기술\n\n코드 최적화, 캐싱 및 지연 로딩과 같은 전략을 구현하여 앱 반응성을 향상시키고 로딩 시간을 줄일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 일반적인 병목 현상 대응\n\n메모리 누수, 비효율적 알고리즘 및 과도한 리소스 사용과 같은 성능 병목 현상을 식별하고 대응하세요.\n\n## 네이티브 기능 통합\n\n원활한 사용자 경험을 제공하기 위해 개발자는 플랫폼별 기능과 기능을 앱에 통합해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기기별 기능에 액세스하기\n\nGPS, 카메라 및 푸시 알림과 같은 기기 기능에 액세스하려면 플랫폼별 API 및 라이브러리를 활용하세요.\n\n## 플랫폼별 API 구현\n\n네이티브 능력을 활용하기 위해 필요한 곳에서 플랫폼별 코드를 구현하는 모듈식 접근 방식을 채택하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 크로스 플랫폼 앱 개발에서의 테스트 및 품질 보증\n\n품질 보증은 앱이 사용자의 기대를 충족하고 각 플랫폼에서 안정적으로 작동하는 것을 보장하는 데 매우 중요합니다.\n\n## 엄격한 테스트의 중요성\n\n자동화된 테스트 도구와 수동 테스트 기술을 활용하여 버그, 사용성 문제 및 성능 병목 현상을 식별하고 해결하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용자 인수 테스트\n\n베타 테스트와 포커스 그룹을 통해 실제 사용자로부터 피드백을 수집하여 개선할 부분을 식별하고 앱의 기능 및 디자인을 개선하세요.\n\n# 배포 전략\n\n개발이 완료되면 앱을 출시 및 배포할 준비가 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 앱 스토어 제출 프로세스\n\n애플 앱 스토어 및 구글 플레이 스토어와 같은 앱 스토어의 지침과 요구 사항을 따라 앱을 검토 및 승인을 위해 제출하세요.\n\n## 베타 테스트 및 피드백 수집\n\n공식 런칭 전에 초기 사용자로부터 피드백을 수집하고 남은 문제를 해결하기 위해 앱의 베타 버전을 출시하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 지속적 통합 및 배포\n\n빌드, 테스트 및 배포 프로세스를 자동화하는 지속적 통합 및 배포 파이프라인을 구현하여 업데이트 및 패치를 효율적으로 제공합니다.\n\n# 개발 후 지원 및 유지보수\n\n앱 출시로 끝나는 것이 아닙니다. 지속적인 지원 및 유지보수는 장기적인 성공에 필수적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 업데이트 및 패치 관리\n\n새로운 기능, 버그 수정 및 보안 패치를 포함하여 앱을 정기적으로 업데이트하여 사용자들을 즐겁게 유지하고 보호하세요.\n\n## 앱 성능 모니터링\n\n애널리틱스 도구 및 모니터링 플랫폼을 활용하여 앱 성능, 사용자 참여 및 피드백을 추적하여 데이터 기반의 의사 결정을 할 수 있도록하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사용자 피드백 대응\n\n사용자 피드백을 듣고 사용자의 요구사항과 선호도에 따라 기능 요청과 버그 수정을 우선순위에 따라 설정하여 충성스러운 사용자 커뮤니티를 육성합니다.\n\n# 성공적인 크로스 플랫폼 앱 예시\n\n실제 사례를 통해 크로스 플랫폼 앱 개발이 비즈니스 목표를 달성하고 탁월한 사용자 경험을 제공하는 데 얼마나 효과적인지를 강조합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인기 있는 크로스 플랫폼 앱인 Airbnb, Instagram 및 Uber의 사례 연구를 살펴보면, 그들의 독특한 기능과 개발 과제를 보여줍니다.\n\n# 실제 프로젝트에서 얻은 교훈\n\n크로스 플랫폼 앱 개발을 채택한 개발자 및 기업의 경험에서 통찰을 얻어, 그들의 성공과 실패로부터 배우세요.\n\n# 크로스 플랫폼 앱 개발의 혜택\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 비용 효율성\n\n여러 플랫폼을 위한 단일 코드베이스를 활용하면 개발 비용을 크게 줄일 수 있고 시장 진입 시간을 단축할 수 있습니다.\n\n## 빠른 개발 시간\n\n크로스 플랫폼 프레임워크는 개발 프로세스를 간소화하는 도구와 라이브러리를 제공하여 개발자가 앱을 효율적으로 구축하고 배포할 수 있도록 도와줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 더 넓은 관객층 도달\n\n크로스 플랫폼 접근 방식을 통해 앱은 다양한 기기와 운영 체제에서 보다 넓은 관객층에게 도달할 수 있으며, 잠재적 사용자 베이스를 극대화할 수 있습니다.\n\n# 크로스 플랫폼 앱 개발의 미래 트렌드\n\n기술이 발전함에 따라, 새로운 트렌드와 혁신이 크로스 플랫폼 앱 개발의 미래를 선도하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 부상 중인 기술 및 프레임워크\n\n증강 현실, 머신 러닝, 블록체인과 같은 부상 중인 기술들에 대해 알아두세요. 교차 플랫폼 개발에 대한 그들의 영향도를 고려해보세요.\n\n## 교차 플랫폼 개발의 미래에 대한 예측\n\n전문가들은 도구, 프레임워크, 개발자 생태계의 발전을 주도로 하여 교차 플랫폼 개발 분야에서 지속적인 성장과 혁신이 예측됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앱 경험을 다양한 플랫폼에서 향상시키기 준비가 되셨나요? Ropstam Solutions에 연락하여 전문적인 크로스 플랫폼 개발을 경험해보세요. Ropstam의 크로스 플랫폼 개발자들은 iOS, Android 및 기타 플랫폼에서 여러분의 비전을 원활하게 통합합니다. 함께 협력하여 차세대 앱을 만들어보세요! 지금 Ropstam에 연락해보세요.\n\n# 결론\n\n크로스 플랫폼 앱 개발은 여러 플랫폼에서 일관된 사용자 경험을 제공하며 넓은 관중에 접근할 수 있는 비용 효율적이고 효과적인 솔루션을 제공합니다.\n\n계획 수립, 디자인, 개발, 테스트 및 유지보수를 포함한 전략적인 로드맵을 따르면, 개발자들은 사용자와 기업 모두의 요구를 충족시키는 성공적인 크로스 플랫폼 앱을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자주 묻는 질문들\n\n## 크로스 플랫폼과 네이티브 앱 개발의 차이점은 무엇인가요?\n\n크로스 플랫폼 개발은 코드를 한 번 작성한 후 여러 플랫폼에 배포하는 것을 의미하며, 네이티브 개발은 각 플랫폼별로 별도의 코드베이스를 생성하는 것을 의미합니다.\n\n## 제 프로젝트에 가장 적합한 크로스 플랫폼 프레임워크는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제일 좋은 프레임워크는 프로젝트 요구사항, 개발자 전문 지식 및 성능 목표 등과 같은 요소에 따라 다릅니다. 결정을 내리기 전에는 각 프레임워크의 기능과 제한 사항을 평가하는 것이 중요합니다.\n\n## 모든 기기에서 교차 플랫폼 앱이 잘 작동되도록 어떻게 할 수 있을까요?\n\n코드 최적화, 캐싱 및 기기별 테스트와 같은 성능 최적화 기술을 활용하면 다양한 기기와 플랫폼에서 앱이 잘 작동하는 것을 보장할 수 있습니다.\n\n## 교차 플랫폼 앱 개발에서 피해야 할 일반적인 함정은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 함정으로는 플랫폼별 기능을 무시하거나 성능 고려를 과소평가하는 것, 그리고 사용자 경험과 디자인 일관성을 우선시하지 않는 것이 있습니다.\n\n## 모든 종류의 앱에 크로스 플랫폼 앱 개발이 적합한가요?\n\n크로스 플랫폼 개발은 많은 종류의 앱에 적합하지만, 특정 플랫폼 기능과 깊은 통합이 필요한 고도로 특화되거나 자원 집약적인 애플리케이션에는 최선의 선택이 아닐 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-23-Cross-PlatformAppDevelopmentRoadmap_0.png"},"coverImage":"/assets/img/2024-05-23-Cross-PlatformAppDevelopmentRoadmap_0.png","tag":["Tech"],"readingTime":6}],"page":"15","totalPageCount":61,"totalPageGroupCount":4,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"15"},"buildId":"R1x9p1CQYDDJESXyLXKOK","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>