<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/15" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/15" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기" href="/post/2024-06-23-UnityArchitectureGameObjectComponentPattern"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TRALA 프로젝트 Zksync 블록체인에서 게임의 미래를 선도하는 방법" href="/post/2024-06-23-TRALAProjectPioneeringtheFutureofGamingontheZksyncBlockchain"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TRALA 프로젝트 Zksync 블록체인에서 게임의 미래를 선도하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TRALAProjectPioneeringtheFutureofGamingontheZksyncBlockchain_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TRALA 프로젝트 Zksync 블록체인에서 게임의 미래를 선도하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">TRALA 프로젝트 Zksync 블록체인에서 게임의 미래를 선도하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Arrowhead의 헬다이버스 2 리뷰 폭탄 케이프의 수수께끼와 전략적 출시  GameSpotlight" href="/post/2024-06-23-ArrowheadsHelldivers2TheMysteriousCompletedReviewBombCapeandItsStrategicReleaseGameSpotlight"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Arrowhead의 헬다이버스 2 리뷰 폭탄 케이프의 수수께끼와 전략적 출시  GameSpotlight" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ArrowheadsHelldivers2TheMysteriousCompletedReviewBombCapeandItsStrategicReleaseGameSpotlight_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Arrowhead의 헬다이버스 2 리뷰 폭탄 케이프의 수수께끼와 전략적 출시  GameSpotlight" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Arrowhead의 헬다이버스 2 리뷰 폭탄 케이프의 수수께끼와 전략적 출시  GameSpotlight</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기본 이동 플랫폼 구현 방법 Godot 4 C" href="/post/2024-06-23-ImplementingabasicmovingplatformGodot4C"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기본 이동 플랫폼 구현 방법 Godot 4 C" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ImplementingabasicmovingplatformGodot4C_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기본 이동 플랫폼 구현 방법 Godot 4 C" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">기본 이동 플랫폼 구현 방법 Godot 4 C</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">30<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="가장 이상한 잊혀진 레고 게임" href="/post/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가장 이상한 잊혀진 레고 게임" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가장 이상한 잊혀진 레고 게임" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">가장 이상한 잊혀진 레고 게임</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착" href="/post/2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="편안한 게임 장르, 이제 과포화 상태일까" href="/post/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="편안한 게임 장르, 이제 과포화 상태일까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="편안한 게임 장르, 이제 과포화 상태일까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">편안한 게임 장르, 이제 과포화 상태일까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24" href="/post/2024-06-23-Leashtofollowplayerdevblog24"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Leashtofollowplayerdevblog24_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="현대 웹 API 이해하기 Part 1 RESTful API 사용법" href="/post/2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="현대 웹 API 이해하기 Part 1 RESTful API 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="현대 웹 API 이해하기 Part 1 RESTful API 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">현대 웹 API 이해하기 Part 1 RESTful API 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="건축 알아야 할 필수 요약 정보" href="/post/2024-06-23-ArchitectureThecheatsheet"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="건축 알아야 할 필수 요약 정보" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ArchitectureThecheatsheet_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="건축 알아야 할 필수 요약 정보" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">건축 알아야 할 필수 요약 정보</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link posts_-active__YVJEi" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Unity 아키텍처 GameObject 컴포넌트 패턴 이해하기","description":"","date":"2024-06-23 22:21","slug":"2024-06-23-UnityArchitectureGameObjectComponentPattern","content":"\n지난 블로그 글에서는 \"스파게티 패턴\"에 대해 살펴보았습니다. 이는 아무런 패턴이 없는 게임을 묘사하기 위해 사용되는 농담적인 용어입니다.\n\n많은 신규 개발자들이 이를 선택하는 이유는 게임을 빠르고 쉽게 제작할 수 있다는 점 때문입니다. 하지만 이후에 자신의 지식을 확장하지 못하는 경우가 많습니다.\n\n프로토타입을 만드는 데 뛰어난 장점이 있지만, 코드가 엉망으로 변하여 어수선하고 복잡한 코드 구조로 이어질 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러한 코드베이스는 긴, 엉킨 메소드, 싱글톤 게임 매니저와 같은 \"God Objects\"에 지나치게 의존하며, 각 새로운 기능이 추가될 때마다 증가하는 끝없는 버그 나열로 악명높습니다.\n\n다행히도, 이러한 문제 중 많은 것을 해결해 줄 수 있는 패턴 중 하나는 GameObject-Component Pattern이며, 이는 Unity의 원래 비전이자 Unity Editor의 공식 프레임워크입니다.\n\n이 패턴은 큰 \"God Objects\"를 더 작고 모듈식 컴포넌트로 분해함으로써 이런 문제들을 해결합니다. 이렇게 하면 새 코드를 작성하지 않고도 GameObject에서 컴포넌트를 쉽게 추가, 수정 또는 제거할 수 있습니다. 본 이론에 따르면, 더 유연하고 유지 보수가 쉬운 코드베이스로 이끌어줄 것입니다.\n\n![Unity Architecture GameObject Component Pattern](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서, 이 패턴이 정말 멋져 보인다면 왜 아무도 사용하지 않는 것 같은걸까요? 심지어 Unity조차 이를 버리고 Scriptable Objects와 ECS를 선호합니다.\n\n나는 '스파게티 프로토타입'을 50시간 이상 리팩토링하여 GameObject Component를 모든 면에서 완전히 활용하고, 그 장점과 약점을 발견했습니다.\n\n# 시간 0 — 게임 매니저의 종말\n\n내 게시물을 따라오신다면 게임 매니저에 대한 절규를 들어볼 수 있을 텐데, 그들은 종종 스파게티 코드베이스에 대한 징후라는 점입니다. 그러므로 그것이 필요 없다는 것을 증명하기 위해 우리는 그것을 삭제할 겁니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 매니저가 객체들에게 무엇을 해야 하는지 말하지 않고 게임의 흐름을 어떻게 제어할까요?\n\n우리는 새로운 코딩 개념을 소개해야 합니다. 이벤트입니다.\n\n이벤트는 응용 프로그램에서 제어 흐름의 방향을 반대로 전환할 수 있습니다. 다른 객체들에게 매니저가 지시하는 대신, 이러한 객체들은 매니저의 변화에 반응하는 방식으로 동작합니다.\n\n![Unity Architecture](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이벤트를 사용하면 게임 매니저에서 모든 종속성을 제거하여 대부분의 기능을 제거할 수 있습니다. 그럼으로써, 남은 데이터를 몇 가지 간단한 구성 요소로 분해할 수 있습니다. 예를 들어, 게임 상태와 같은 핵심 이벤트를 담는 컨테이너입니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_3.png)\n\n# 2시간 — 캡슐화\n\n이러한 경향을 이어가며, 코드를 깨끗하게 유지하기 위해 클래스가 적절하게 캡슐화되어야 한다는 것이 중요하다는 것을 알았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 코드를 개선하는 가장 간단한 방법은 serialize field 속성을 사용하는 것입니다. 이렇게 함으로써 클래스가 자신의 데이터에 대한 단일 권한 출처로 유지되도록 할 수 있습니다.\n\n```js\n// 나쁨. 캡슐화 깨짐.\npublic int currentHealth;\n\n// 좋음. 캡슐화 유지.\n[SerializeField]\nprivate int currentHealth;\n\n// 좋음. 읽기 전용 액세스 제공하면서 캡슐화 유지.\n[field:SerializeField]\npublic int currentHealth { get; private set; }\n```\n\n유니티 이벤트는 또 다른 중요한 도구로, 에디터에 깊게 내장되어 있으며, 컴포넌트들 간의 결합을 느슨하게 할 수 있습니다.\n\n예를 들어, 플레이어와 적이 동일한 Death Handler 컴포넌트를 사용하지만 전혀 새로운 코드 없이 새로운 동작을 만들어낼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_4.png\" /\u003e\n\n그러나 이 코드 의존성 부족은 두날날날날 모낫날剌몫몿 때날이카. Unity Events를 과도하게 사용하면 성능 문제가 발생할 수 있으며 에디터에서 시간이 오래 걸리는 수동 설정으로 이어질 수 있습니다.\n\n이러한 이유로, 자주 발생하거나 중요한 게임 이벤트에 대해 고전적인 C# 동작을 사용했습니다.\n\n마지막으로, Gold와 Achievements와 같은 구성 요소는 싱글톤 계정 관리자에 의존하는 대신 자체 저장 데이터를 처리하도록 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리팩토링은 튼튼한 시작을 했어요.\n\n# 7시간 - 성능\n\n대규모 게임에 대한 확장성과 유지 관리성이 중요하지만 성능도 그렇습니다. GameObject-Component 자체는 스파게티보다 빠르지 않습니다 (사실 느릴 수도 있음), 그러나 리팩토링의 정신에 따라 이러한 문제를 해결해야 합니다.\n\n가장 중요한 기술은 Object Pooling의 사용입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n총알, 체력 팩, 입자 및 적을 생성하고 제거하는 과정으로 인해 Garbage Collector가 엄청난 스트레스를 받고 fps에 영향을 줍니다.\n\n그렇기 때문에 이러한 객체들을 파괴하는 대신 재활용하는 것이 해결책입니다.\n\n```js\n/* 컴포넌트는 풀에서 객체를 '빌려오고' 작업을 마치면 돌려놓을 수 있음.\n   현재 사용 중인 객체가 없는 경우에만 새 객체가 생성됨. */\npublic class GameObjectPool : MonoBehaviour\n{\n  [SerializeField] private GameObject prefab;\n  private readonly Queue\u003cGameObject\u003e _inactivePool = new();\n\n  public GameObject Get()\n  {\n    return _inactivePool.Count \u003e 0 ?\n           _inactivePool.Dequeue() :\n           Instantiate(prefab, null);\n  }\n\n  public void Return(GameObject item)\n  {\n    item.SetActive(false);\n    _inactivePool.Enqueue(item);\n  }\n}\n```\n\n이 기술은 발사체, 적, 입자 효과, 오디오 소스 및 모든 UI 요소(피해 수치와 같은)를 단일 캔버스로 통합함으로써 성능을 향상시켰습니다. 제어된 스트레스 테스트로 60FPS에서 100FPS로 최대 66%의 성능 향상을 달성했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 시간 10 — 의존성 그래프 수정하기.\n\n스파게티 패턴에 대한 내 정의 중 하나는 구성 요소 사이에 교차하는 선들의 웹을 만들지 않고는 시각화할 수없는 의존성 그래프였습니다.\n\n이러한 문제를 피하는 간단한 묘수는 구상 대신 구체적인 참조에 의존하는 대신 추상화에 의존하는 것입니다. 특히 이 경우에서는 상속을 사용하여.\n\n![Unity Architecture Game Object Component Pattern](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임 상태에 의존하는 구성 요소가 모두 GamePlayComponent 클래스에서 상속되도록 보장하면 이러한 동작을 체크하고도 직접적으로 참조하지 않고도 무차별적인 상태 관리를 할 수 있습니다.\n\n이 기술은 사용자 인터페이스를 분리하는 데 다시 사용되었습니다. 스파게티 코드에서 흔한 문제는 게임이 올바르게 작동하려면 UI에 대한 강력한 의존성이 필요하다는 것입니다. 개발자로서 UI 없이도 스크립트, 콘솔 명령 또는 API를 통해 게임의 어떤 상태든 액세스할 수 있어야 합니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_6.png)\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 20시간 — 싱글턴 제거하기\n\n안녕하세요! 싱글턴은 악이 아니지만, 많은 개발자들이 과도하게 의존하고 있습니다. 대안을 제대로 탐색하기 위해 이 리팩토링에서는 싱글턴을 삭제하기로 결정했습니다.\n\n이것은 씬에 직렬화된 객체에 대해서는 쉽게 할 수 있습니다. 그러나 동적으로 생성된 프리팹들은 도전을 제공합니다. 프리팹은 씬 객체를 참조할 수 없습니다. 이 문제를 해결하기 위해 팩토리 패턴을 사용해야 합니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n공장은 생성될 때 프리팹의 종속성을 주입합니다. 이는 새로운 오브젝트 풀과 잘 작동합니다. 이로 인해 싱글톤이 필요 없어졌지만, 코드에 복잡성과 보일러플레이트가 추가되었습니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_9.png)\n\n특히 게임이 여러 씬을 사용하는 경우 이 문제가 악화됩니다. 여러 씬 간의 참조를 해결해야하기 때문에 DontDestroyOnLoad(), 코루틴 및 FindObjectOfType`T`를 결합하여 사용해야 합니다.\n\n이 추가된 복잡성은 구성 기반 아키텍처의 복잡성과 결합되어 많은 예측할 수 없는 버그를 발생시켰습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*3BLCk1jFCCHxxns9MfhzHQ.gif)\n\nGameObject Component는 컴포넌트 간 상호 작용에서 행동이 발생하도록 설계되었습니다. 불행하게도 버그도 발생합니다.\n\n스파게티 패턴과는 달리, 매니저 클래스를 따라가면서 문제를 찾을 수 없습니다. 버그는 특정한 코드 줄에서 발생하는 것이 아니라, 컴포넌트들의 상호 작용에 이상이 있어서 발생하는 것입니다.\n\n문제를 해결하려고 10시간 동안 노력한 후에도 전혀 진전이 없는 것 같았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*mXQ-sSlR0wSAtb5KPmrJQA.gif)\n\n# 30시간째 — 절망의 구렁이와 마주치다\n\n알게 된 대로, 게임 오브젝트 컴포넌트는 스파게티 코드에 비해 많은 초기 비용이 필요하다. 스파게티 코드로는 게임이 선형적으로 진행되어 경험이 매우 보상적인 결과를 가져온다.\n\n반면, 게임 오브젝트 컴포넌트는 모든 필요한 구성 요소가 실제로 테스트될 수 있을 때까지 존재해야 한다. 'Health.cs' 스크립트가 충분한지 여부를 알기 어렵다. 그 외의 모든 구성 요소와 함께 사용될 때까지는.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 모든 일은 동적으로 생성된 오브젝트를 다루고, 컴포넌트를 풀링하고 재활용하면서 함께 작동하도록 시도하다 보니 결과를 보지 못하는 등 너무 압도되었어요.\n\n그렇게 해서 2개월 동안 개발을 중단했죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임을 조각조각 다듬는 내 계획은 망가졌어요. 그래서 다른 일들로 넘어가고 게임 오브젝트 컴포넌트는 쓴맛을 남겼어요.\n\n# 시간 40 —조합 이해하기\n\n두 달 동안의 휴식 후, 깨달음이 찾아왔을 때 프로젝트를 끝내려는 결심을 내렸어요. 스파게티 코드 사용을 그만 두었지만, 여전히 스파게티 브레인을 사용하고 있었어요.\n\n게임오브젝트-컴포넌트의 본질은 컴포넌트를 공유하는 데 있어요. '플레이어'와 '적'을 구분하는 것은 이 아키텍처의 정신을 위반해요. 그래서 플레이어와 적이 동일한 컴포넌트에 의존하도록 확실히 했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_12.png)\n\n이전에 '플레이어 이동'과 '적 체력'이 있었습니다. 목표는 구성 요소를 단순화하여 '식별성'이 없어도 존재할 수 있도록하는 것입니다.\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_13.png)\n\n10시간의 개발을 버리고 합성 마인드셋으로 리팩토링을 시작했습니다. 이것은 아키텍처에 대한 점점 쌓이는 경험과 결합되어 이 어려움을 극복하고 핵심 게임을 다시 작동시킬 수 있었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 50시간째 — 보상\n\n게임을 리팩토링하는 데 처음부터 만드는 시간보다 더 오랜 시간이 걸렸어요. 코드는 더 깔끔해졌지만 정말 그만한 가치가 있었을까요?\n\n![이미지](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_14.png)\n\n지난 포스트에서 언급했듯이 프로젝트 막바지에 진행 상황 바를 구현하는 데 5시간이 걸렸는데, 이번에는 단 25분만에 완료했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n게임 오브젝트-컴포넌트는 처음에는 개발 속도가 느렸지만, 유지보수성과 확장성에서 그 가치를 입증합니다. 유니티 에디터와의 원활한 통합과 코드의 내재적 \"깔끔함\"은 부정할 수 없는 장점입니다.\n\n![GameObject-Component](/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_15.png)\n\n그렇다면 최고의 아키텍처인가요?\n\n아니요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 패턴은 주의 깊은 계획, Unity에 대한 심층적인 이해 및 정교한 종속성 관리를 필요로 합니다. 짜증나는 버그 발생과 혜택 대비 비용이 높다는 이유 때문에 많은 개발자들이 이를 사용하지 않는 것일 수 있습니다.\n\n그렇지만, 이 패턴에서 요소들을 통합하면 스파게티 코드 기반 프로젝트를 크게 향상시킬 수 있으며, 최종적인 리팩터링이 덜 괴로운 경험을 할 수 있습니다.\n\n만약 해당 하이브리드의 예시를 보고 싶다면, 게임 SoulStone Survivors의 역컴파일을 확인해보세요.\n\n또는 해당 패턴과 스파게티 패턴의 전체 소스 코드를 github에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것에 대해 더 나은 해결책이 존재하는지에 대해 고민하게 만듭니다.\n\nScriptable Object Pattern에 대하여 자세히 살펴보고 리팩터링할 때 발견할 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png"},"coverImage":"/assets/img/2024-06-23-UnityArchitectureGameObjectComponentPattern_0.png","tag":["Tech"],"readingTime":14},{"title":"TRALA 프로젝트 Zksync 블록체인에서 게임의 미래를 선도하는 방법","description":"","date":"2024-06-23 22:19","slug":"2024-06-23-TRALAProjectPioneeringtheFutureofGamingontheZksyncBlockchain","content":"\n소개\n\n![이미지](/assets/img/2024-06-23-TRALAProjectPioneeringtheFutureofGamingontheZksyncBlockchain_0.png)\n\nTRALA 프로젝트는 블록체인 게임 분야에서 혁신적인 역할을 할 것으로 기대됩니다. Zksync 생태계 내에서 운영되는 TRALA는 Web 2 사용자들을 화려한 Web 3 환경으로 원활하게 이동시키는 것을 목표로 하고 있습니다. NFT 및 기타 디지털 자산을 거래할 수 있는 시장을 제공함으로써, TRALA는 게임 분야에서 새로운 시대를 열고 있습니다.\n\n비전과 미션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTRALA Lab의 주요 임무는 블록체인에 AAA-등급의 Web3 게임 시리즈를 출시하여 게임 경험을 크게 향상시키는 것입니다. 그들의 라인업에는 FreeStyle과 Gunship Battles와 같은 주목할만한 타이틀이 포함되어 있습니다. 그들은 웹 2 사용자들을 웹 3로 유입시키는 것을 희망합니다.\n\n강력한 지원과 커뮤니티 참여\n\nTRALA 프로젝트는 최근 Matterlabs(Zksync를 개발한 팀)와 Animoca Brands와 같은 주요 기관들로부터 지원과 많은 자금 지원을 받았습니다. 또한 prom, petoshi 및 기타 큰 주목할만한 프로젝트들과의 다수의 파트너십을 맺고 있습니다.\n\n![TRALAProjectPioneeringtheFutureofGamingontheZksyncBlockchain](/assets/img/2024-06-23-TRALAProjectPioneeringtheFutureofGamingontheZksyncBlockchain_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근 TRALA가 주최한 이벤트에서 참가자들은 TRALA OG NFT를 획득하고 가챠 포인트를 축적할 기회를 얻었습니다. 이 포인트와 OG NFT는 충성스러운 커뮤니티에게 수많은 혜택을 제공합니다.\n\n토큰노믹스\n\n또한 TRALA는 전체 공급량이 10억 개인 TRALA 네이티브 토큰을 출시할 것을 발표했습니다. 아직 구체적인 시기는 없지만, 토큰 분배는 생태계의 지속 가능한 성장과 발전을 보장하기 위해 설계되었습니다:\n\n- 생태계 기금: 30%\n- 개발자 기금: 25%\n- 팀: 15%\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 개인 판매: 15%\n\n- 마케팅: 5%\n- 예비 기금: 5%\n- 파트너십: 5%\n\n이 전략적 할당은 프로젝트 성장의 다양한 측면을 지원하며, 개발 및 마케팅부터 가치있는 파트너십 형성까지 지원할 것입니다.\n\n![이미지](/assets/img/2024-06-23-TRALAProjectPioneeringtheFutureofGamingontheZksyncBlockchain_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결론\n\nTRALA는 Web 3 생태계 내에서 게임 세계에 중요한 영향을 미치기 위해 준비를 하고 있습니다. 강력한 지원, 혁신적인 게임, 그리고 튼튼한 토큰 경제 계획으로 TRALA는 블록체인 게임 분야에서 선두 주자가 되기 위한 길을 걸어가고 있습니다.\n\nTRALA가 웹 3에서 게임 세계를 지배할 시점에 함께해 주시기를 초대합니다.\n\nX: x.com/TRALA_Official\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n디스코드 : https://discord.gg/trala-official\n\n웹사이트 : trala.me\n","ogImage":{"url":"/assets/img/2024-06-23-TRALAProjectPioneeringtheFutureofGamingontheZksyncBlockchain_0.png"},"coverImage":"/assets/img/2024-06-23-TRALAProjectPioneeringtheFutureofGamingontheZksyncBlockchain_0.png","tag":["Tech"],"readingTime":3},{"title":"Arrowhead의 헬다이버스 2 리뷰 폭탄 케이프의 수수께끼와 전략적 출시  GameSpotlight","description":"","date":"2024-06-23 22:18","slug":"2024-06-23-ArrowheadsHelldivers2TheMysteriousCompletedReviewBombCapeandItsStrategicReleaseGameSpotlight","content":"\n## HELLDIVERS 2: ARROWHEAD'S FINISHED 'REVIEW BOMB CAPE' TEASED BY DIRECTOR\n\n![Image](/assets/img/2024-06-23-ArrowheadsHelldivers2TheMysteriousCompletedReviewBombCapeandItsStrategicReleaseGameSpotlight_0.png)\n\n안녕하세요, Helldivers 팬 여러분! 열심히 기다리고 있던 후속작인 Helldivers 2가 곧 출시될 예정이며, 이에 관한 놀라운 소식이 있어서 여러분을 더욱 기대하게 만들 것입니다. Arrowhead Game Studios가 유명한 \"Review Bomb Cape\"가 극히 진짜임은 물론 완전히 마무리되었다고 확인했습니다. 그러나 주목할 점은, 스튜디오가 적절한 시기가 올 때까지 발표를 미루고 있는 중이라는 점입니다. 이에 따라 이상적인 타이밍을 기다리고 있습니다.\n\n## Helldivers 커뮤니티는 이 공개로 인해 분노에 휩싸인 상태입니다. 궁금한 점이 있으시다면, 여기 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 완전히 계획이 세워지고 사용 가능한 것으로 확인된 케이프가 마침내 완성되었습니다.\n- 출시 시기: 현재는 비밀로 유지되지만 전략적으로 준비되었습니다.\n- 플레이어들의 참여와 의겢에 대한 인정과 감사의 의도로 만들어졌습니다.\n\n이번 흥미로운 업데이트가 출시되면서 기대감은 한층 높아졌습니다. 리뷰 폭탄 케이프가 독특한 이유와 Arrowhead의 타이밍이 게임에서 결정적인 요소가 될 수 있는 이유를 함께 살펴봅시다.\n\nHelldivers 2 커뮤니티가 특히 갈등을 겪던 리뷰 단계를 지나며, 리뷰 그래프를 게임 아이템으로 그대로 남기기로 결정했습니다. 이것이 리뷰 폭탄 케이프 아이디어의 기원입니다. Arrowhead Game Studios는 이 제안을 가볍게 받아들이지 않고, 오히려 열정적으로 마음을 다해 환영했습니다. 곧 개발 중이라고 발표된 뒤, 지지 커뮤니티에 더 많은 높은 수준의 기대감을 불러일으켰습니다.\n\n이 케이프가 독특한 이유는 무엇일까요? 먼저, 이것은 게임의 활성 플레이어 베이스와 그들이 게임 발전에 미친 영향을 보여주는 것의 증명입니다. 어려움과 연대의 상징일 뿐만 아니라, 게임 역사의 특정 시기를 실체화한 물리적 추억입니다. 케이프의 정교한 디자인은 아마도 리뷰 그래프에서 표현된 dramatic한 고점과 저점을 반영할 것입니다. 이를 통해 케이프는 커뮤니티의 집단적 경험의 일부를 처음으로 포착할 수 있을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n망했다고 생각했던 유저들을 다시 끌어낼 가능성이 있는 케이프가 적시에 공개되면 열정이 되살아나고 게이머들이 다시 참여할 수 있을 것입니다. 속담에는 시기가 모든 것이라고 합니다. 이 방법을 사용함으로써 Arrowhead는 현재의 어려움을 Helldivers 2 이야기의 유명한 구성 요소로 변모시키는 잠재력을 가질 수 있어서 플레이어들의 참여와 충성도를 높일 수 있을 것입니다.\n\n한편, 게임의 최신 업그레이드가 중요한데, LAS-99 퀘이사 캐논의 재충전 시간 조정 및 다른 무기의 향상과 같은 사항은 Arrowhead가 게임 메타를 개선하기 위해 헌신하는 것을 보여줍니다. 이러한 수정 사항은 Review Bomb Cape의 상징적인 공개와 함께, Arrowhead가 커뮤니티의 피드백을 주의 깊게 듣고 활발한 플레이어들에게 중요한 방향으로 게임을 발전시키고자 한다는 인상을 줍니다.\n\n케이프의 도착을 열망하는 동안, 한 가지는 분명합니다: Arrowhead Game Studios는 기대감과 관련된 흥분을 유지할 수 있습니다. Helldivers 여러분, 기대해 주세요. 분명히, 다음 장이 기록에 남을 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-23-ArrowheadsHelldivers2TheMysteriousCompletedReviewBombCapeandItsStrategicReleaseGameSpotlight_0.png"},"coverImage":"/assets/img/2024-06-23-ArrowheadsHelldivers2TheMysteriousCompletedReviewBombCapeandItsStrategicReleaseGameSpotlight_0.png","tag":["Tech"],"readingTime":3},{"title":"기본 이동 플랫폼 구현 방법 Godot 4 C","description":"","date":"2024-06-23 22:15","slug":"2024-06-23-ImplementingabasicmovingplatformGodot4C","content":"\n비디오 게임은 캐릭터, 아바타 및 NPC에 관한 것이지만, 환경, 풍경 및 장식에서 멋진 동적 객체에 관한 것이기도 합니다! 전형적으로, 모험/플랫포머 게임을 만들 때 언젠가는 반드시 애니메이션된 플랫폼을 만들어야 할 것입니다.\n\n그래서 오늘은 간단한 이동 플랫폼을 Godot 4/C#에서 어떻게 만드는지 살펴보겠습니다!\n\n이 문서를 끝까지 읽으면 경로(Path) 및 PathFollow 노드를 사용하여 플랫폼 객체가 특정 경로를 따라 이동하도록 만드는 방법, 이 플랫폼이 루프되거나 반대 방향으로 이동하는 방법, 마지막으로 플랫폼의 충돌기(collider)가 시각적으로 제대로 따라갈 수 있도록 하는 방법을 알게 될 것입니다.\n\n물론, 이 자습서에서는 3D 예시를 살펴보겠지만, 우리가 공부할 노드들의 2D 버전에서도 동일하게 작동합니다 :)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론, 이 예시에 대한 데모 씬과 모든 에셋은 제 Github에서 확인할 수 있다 🚀 그리고 내 다른 Godot 튜토리얼들이 모두 있어!\n\n🔶 더불어, 이 에셋들은 Kenney의 놀라운 무료 라이브러리에서 제공된 것이다!\n\n이 튜토리얼은 비디오로도 제공되며, 텍스트 버전은 아래에 있다:\n\n이렇게 말씀드렸으니, 이제 Godot 4와 C#에서 움직이는 플랫폼을 설정하는 방법을 알아보자!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어, 그리고 그리고: 여전히 Godot 4와 C# 게임 개발에 조금 낯설다면, 내 새로운 \"짧은 글\" eBook인 L’Almanach: 시작하기를 확인해보세요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:720/0*8zhDhZgu2yB4wJzv.gif)\n\n이 빠르고 실용적인 안내서는 기초를 탐험하게 해주며, 시선을 설치하는 방법을 가르쳐줄 것입니다. C#로 코딩하고, UI를 설계하고, 심지어 당신만의 3목 게임을 한 걸음씩 만드는 방법까지 :)\n\n따라서 100페이지 미만의 분량으로 Godot 4/C# 여정을 시작하고, 저렴한 가격으로 즐길 수 있다면, Gumroad 페이지를 꼭 확인해보세요...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 경로 설정하기\n\n알겠어요, 먼저 플랫폼을 경로를 따라 쉽게 이동시킬 수 있는 방법을 살펴봅시다.\n\nGodot에서 이러한 유형의 경우에 매우 유용한 노드 유형이 실제로 몇 가지 있습니다: 경로(Path) 및 경로 따르기(PathFollow) 노드. 이전 시리즈 튜토리얼 중 2D 예제에서, 적들의 웨이브를 규칙적으로 생성하고 미리 정의된 경로를 따라 이동하는 방법을 살펴볼 때에 이에 대해 이야기했습니다:\n\n오늘은 비슷한 작업을 3D로 수행하되, 객체의 이동을 좀 더 사용자 정의하고자 합니다. 그리고 아, 케니의 놀라운 무료 라이브러리에서 에셋을 사용할건데, 그것은 그의 새로운 미니 던전 키트입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 튜토리얼에서는 이미 데모 씬과 사용할 플랫폼 프리팹을 준비해 두었습니다. 이렇게 생겼죠:\n\n그림에서 볼 수 있듯이, CollisionShape3D 하위 노드를 가진 간단한 물리 바디 노드와 시각적인 부분을 위한 몇 가지 메쉬가 포함되어 있습니다.\n\n그러나 환경 객체로 Godot에서 예상하는 StaticBody3D가 루트 노드가 아닙니다. 대신, 레벨에서 개체가 이동하고 여전히 물리 객체의 나머지 부분과 충돌하도록 원하는 경우 훌륭한 노드 유형을 사용할 수 있습니다: AnimatableBody3D.\n\n기본적으로 이 노드는 다양한 방식으로 이동할 수 있습니다(예: 코드를 통해, 여기와 같은 경로로, 애니메이션을 사용하거나 심지어 트윈 객체를 사용하여…), 그러나 이동과 관련하여 Sync To Physics 옵션을 활성화하면 Godot에게 이 동작을 씬의 다른 물리 객체와 동기화하라고 지시하여 여전히 충돌이나 트리거를 얻을 수 있습니다 :)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서 이제, 플랫폼과 데모 씬이 이미 준비되어 있으니, 여기서 첫 번째 단계는 Path3D 노드 내부에 플랫폼이 따라갈 경로를 그리는 것입니다. 물론 이번에는 3D에 있기 때문에 세 가지 방향으로 포인트를 배치하고 수평이 아닌 경로를 만들 수 있습니다:\n\n이제 경로를 그렸다면, 그 다음 단계는 PathFollow3D 자식 노드를 추가하고 플랫폼을 생성하는 것뿐입니다:\n\n이후에는 PathFollow3D 노드의 Progress 또는 ProgressRatio 매개변수를 사용해 이동 경로를 따라 플랫폼이 움직이는 것을 볼 수 있습니다:\n\n그런데 PathFollow3D 노드의 회전 모드를 회전 없음(None)으로 변경해야 합니다. 이동 중에 플랫폼이 회전하지 않게 하려면 Loop 옵션도 해제해야 합니다. 이렇게 하면 플랫폼의 움직임을 더 잘 제어할 수 있습니다(나중에 스크립트에서 처리할 것입니다):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론, 코드를 통해 진행 상황 업데이트를 할 수 있다는 것도 알고 계실 거라 생각해요. 그래서 우리 PathFollow3D 노드에 새로운 C# 스크립트인 MovingPlatform.cs를 간단히 만들어봅시다.\n\n여기서 우리는 아직 \\_Process() 함수만 남길 거에요. 이 함수 안에서 오브젝트를 움직이도록 진행 값을 수정할 거랍니다.\n\n```js\nusing Godot;\n\npublic partial class MovingPlatform : PathFollow3D\n{\n    public override void _Process(double delta)\n    {}\n}\n```\n\n일반적으로, 플랫폼에 대한 \\_speed 값을 정의하고 내보내면, 그 값을 \\_Process() 메서드에서 사용하여 ProgressRatio 값을 증가시킬 수 있어요. 이렇게 하면 경로의 끝에 도달하기 전까지 플랫폼 오브젝트를 이동시킬 수 있습니다. 우리는 간단히 정규화된 ProgressRatio 값이 1과 같은지를 확인하여 경로의 끝을 확인할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic partial class MovingPlatform : PathFollow3D\n{\n    [Export] private float _speed;\n\n    public override void _Process(double delta)\n    {\n        if (ProgressRatio \u003c 1)\n            ProgressRatio += _speed * (float)delta;\n    }\n}\n```\n\n프로젝트를 다시 빌드한 후에는 인스펙터에서 원하는 대로 속도 값을 조정할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n중요한 참고사항: 이 속도를 조정해야 할 필요가 있고, 튜토리얼을 진행하면서 우리의 플랫폼이 어떻게 움직이는지 수정하기도 할 수 있어요... 꼭 테스트하여 어떻게 보이는지 확인해 보세요 ;)\n\n오케이 - 이 시점에서, 우리는 멋지게 보이고 우리가 기대한대로 경로를 따라 움직이는 멋진 움직이는 플랫폼을 가지고 있어요:\n\n그러나 두 가지 큰 문제가 있어요:\n\n- 첫째, 현재 구현에서는 플랫폼이 여정을 한 번만 수행하고 나서 끝에서 멈춰버려요 - 우리의 작은 데모처럼 어드벤처/플랫포머 게임에 이상적이지 않다는 것은 분명해요.\n- 둘째, 실제로 플랫폼에는 어떤 충돌도 없어요! 그래서 내 장면에 플레이어 개체를 추가하고 플랫폼이 절벽 가까이로 이동할 때 플랫폼으로 이동하면 그냥 통과해 버리겠네요...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 두 가지 문제를 해결하는 방법을 살펴보겠습니다.\n\n# 좀 더 개선된 플랫폼 이동을 준비하기\n\n## 기능 개요\n\n우선, \"원샷\" 이동 문제를 해결해보겠습니다. 여기에 설정하고 싶은 것은 게임 디자이너 사용자들에게 몇 가지 옵션을 제공하는 시스템입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 먼저, 플랫폼은 우리의 경로 상 각 지점에서 잠시 멈출 수 있고, 중간 웨이포인트로 사용할 수 있습니다. 이것은 실제로 비디오 게임에서 매우 일반적인 기능이며, 전반적인 경로 동안 플랫폼에 뛰어오르고 내리기가 쉬워집니다.\n- 두 번째, 플랫폼이 경로의 끝에 도달하면 즉시 처음으로 순식간에 이동하거나(루프 옵션을 활성화한 것처럼), 같은 방식으로 경로를 따라 반대 방향으로 이동할 수 있습니다. 나는 사용자가 이 두 모드 사이를 쉽게 전환할 수 있도록 하고 싶어요.\n\n이 모든 것을 위해, C# 스크립트를 개선하여 \"웨이포인트\" 개념을 이해하고 현재 이동 방향을 추적할 수 있도록 해야합니다.\n\n그러나 먼저, 우리의 클래스에서 두 가지 새로운 내보낸 변수를 간단히 정의할 수 있습니다: \\_pauseTimeAtWaypoints 와 \\_jumpToStart:\n\n```js\npublic partial class MovingPlatform : PathFollow3D\n{\n    [Export] private float _speed;\n    [Export] private float _pauseTimeAtWaypoints = 0;\n    [Export] private bool _jumpToStart = false;\n\n    public override void _Process(double delta) { ... }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 변수인 (\\_pauseTimeAtWaypoints)은 부동 소수점입니다. 각 웨이포인트에서 기다릴 시간 (초)을 나타냅니다. 값이 0이면 현재 동작과 똑같이 동작하며, 플랫폼은 중간 웨이포인트를 무시합니다. 값이 0이 아니면, 각 웨이포인트에서 속도를 줄이고 잠시 멈춘 뒤 다음 위치에 도착하기 위해 다시 가속합니다.\n\n두 번째 변수인 (\\_jumpToStart)은 부울 값입니다. 값이 true이면 플랫폼은 끝에 도달하면 시작 지점으로 순간이동합니다. false이면 반대 방향으로 경로를 따라 이동하여 다시 시작점으로 되돌아갑니다.\n\n이를 염두에 두고 이제 웨이포인트별 메커니즘을 추가하는 방법을 살펴보겠습니다.\n\n## 웨이포인트 시스템 뒷받침하는 이론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서의 아이디어는 곡선 내의 다른 점들의 위치와 현재 웨이포인트 인덱스를 저장하여 플랫폼이 따라 가야 할 경로의 일부를 알아내는 것입니다.\n\n핵심은 이 중간 지점들의 정규화된 위치를 사용하는 것입니다. 이렇게 하면 경로의 시작점(0)부터 끝점(1)까지의 값들을 갖게 됩니다:\n\n그런 다음, 플랫폼의 현재 웨이포인트 인덱스에 따라, 어떤 세그먼트를 고려해야 하는지 알 수 있습니다. 그리고 첫 번째 \"from\" 지점과 이 하위 경로의 두 번째 \"to\" 지점 사이에 부동 소수점 값을 보간할 수 있을 것입니다:\n\n이 보간은 선형일 수도 있고, 각 웨이포인트에서 멈추고 더 자연스러운 느낌을 원한다면 속도를 높이거나 감소시킬 수도 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 플랫폼 이동을 매우 맞춤화할 수 있게 만들고, 동시에 디자이너들에게 정의하기 쉽게 만들 것입니다. 디자이너들은 중간 정거장을 만들기 위해 경로에 추가 점을 생성하기만 하면 될 거예요.\n\n정말 중요한 부분은 플랫폼의 속도를 올바르게 결정하여 경로 상에서 일정한 것으로 유지하는 것입니다. 실제로, Godot PathFollow 노드의 ProgressRatio를 사용할 때 경로를 이동하는 데 필요한 상대 속도가 달라지는 문제가 발생할 수 있어요.\n\n이 문제를 피하기 위해서, 우리는 기본 물리학 공식을 사용하고, 예상 여행 시간을 기반으로 보간을 진행하면 됩니다.\n\n아마도 알고 있겠지만, 물체의 속도 S는 이동한 거리 D를 이동하는 데 걸린 시간 T로 나눈 것으로 계산될 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이미 플랫폼 속도를 \\_speed 변수로 검사자에 노출했기 때문에 사용자가 정의한 데이터입니다.\n- 그리고 우리의 waypoint 비율 및 전체 곡선 길이 L을 기반으로 이동해야 하는 거리를 쉽게 식별할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-ImplementingabasicmovingplatformGodot4C_2.png)\n\n그 말은 우리는 이 시간 양 T를 카운트다운하는 카운터를 쉽게 설정할 수 있으며, 그 후 플랫폼의 위치를 우리의 곡선 부분 청크를 따라 선형 보간하여 처음 waypoint에 카운트다운이 시작될 때, 그리고 시간이 경과하여 두 번째 waypoint에서 위치하도록 할 수 있다는 것을 의미합니다.\n\n좋아요 — 많은 이론이었죠! 그래서 실습으로 이 모든 것을 정리해보는 시간이군요 :)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Waypoint 메커니즘 구현\n\n우리의 스크립트로 돌아와서, 이 waypoint 메커니즘에 대한 몇 가지 추가 변수를 추가할 것입니다.\n\n우리는 곡선의 총 길이, waypoint의 수, 현재 waypoint의 인덱스 및 waypoint 비율 목록을 추적해야 합니다. 이 비율은 부동 소수점(float)의 리스트로 저장됩니다.\n\n```js\nusing Godot;\nusing System.Collections.Generic;\n\npublic partial class MovingPlatform : PathFollow3D\n{\n    // ...\n\n    private float _totalCurveLength;\n    private int _nWaypoints;\n    private int _curWaypointIdx;\n    private List\u003cfloat\u003e _waypointRatios;\n\n    public override void _Process(double delta) { ... }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼, \\_Ready() 함수에서 경로의 곡선 데이터를 가져올 거에요:\n\n```js\npublic partial class MovingPlatform : PathFollow3D\n{\n    // ...\n\n    public override void _Ready()\n    {\n        Curve3D c = GetParent\u003cPath3D\u003e().Curve;\n    }\n}\n```\n\n이렇게 하면 곡선의 포인트 수를 가져와 각 포인트를 순회하면서 그 비율을 얻고, 마지막으로 곡선의 총 길이를 저장할 수 있어요:\n\n```js\npublic override void _Ready()\n{\n    Curve3D c = GetParent\u003cPath3D\u003e().Curve;\n    _nWaypoints = c.PointCount;\n    _waypointRatios = new();\n    _totalCurveLength = c.GetBakedLength();\n    float curLength = 0;\n    for (int i = 0; i \u003c _nWaypoints; i++) {\n        if (i \u003e 0) {\n            float r1 = c.GetClosestOffset(c.GetPointPosition(i - 1));\n            float r2 = c.GetClosestOffset(c.GetPointPosition(i));\n            curLength += r2 - r1;\n        }\n        _waypointRatios.Add(curLength / _totalCurveLength);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주석: GetClosestOffset() 및 GetPointPosition() 메서드를 이와 같이 중첩하여 사용하면 경로가 직선으로 구성되지 않은 경우에도 올바른 웨이포인트 비율을 얻을 수 있습니다 ;)\n\n이 초기화 단계의 끝에는 ProgressRatio와 웨이포인트 인덱스를 0으로 재설정하여 곡선의 시작 부분에서 플랫폼 이동을 시작하는 것도 잊지 말아요:\n\n```js\npublic override void _Ready()\n{\n    Curve3D c = GetParent\u003cPath3D\u003e().Curve;\n    _nWaypoints = c.PointCount;\n    _waypointRatios = new();\n    _totalCurveLength = c.GetBakedLength();\n    float curLength = 0;\n    for (int i = 0; i \u003c _nWaypoints; i++) {\n        if (i \u003e 0) {\n            float r1 = c.GetClosestOffset(c.GetPointPosition(i - 1));\n            float r2 = c.GetClosestOffset(c.GetPointPosition(i));\n            curLength += r2 - r1;\n        }\n        _waypointRatios.Add(curLength / _totalCurveLength);\n    }\n\n    ProgressRatio = 0;\n    _curWaypointIdx = 0;\n}\n```\n\n그런 다음, 스크립트에 새로운 비공개 메서드 \\_StartMove()를 만들고 \\_Ready() 함수에서 이 메서드를 호출합시다. 이 함수는 경로 따라 플랫폼이 웨이포인트에서 다음으로 이동하도록 하는 기능을할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic partial class MovingPlatform : PathFollow3D\n{\n    // ...\n\n    public override void _Ready()\n    {\n        // ...\n        _StartMove();\n    }\n\n    private void _StartMove() {}\n}\n```\n\n우리는 이 메서드를 비트 단위로 구현할 것이기 때문에, 지금은 간단하게 점수를 하나씩 증가시키는 것으로 갈꺼에요:\n\n```js\nprivate void _StartMove()\n{\n    _curWaypointIdx += 1;\n}\n```\n\n이제 우리는 이야기했던 이동 시간 계산기와 위치 보간을 처리하는 데 필요한 모든 것을 설정할 것입니다. 우리는 스크립트에게 어떤 구간의 경로에서 작업 중인지, 이동 시간이 얼마인지, 그리고 카운트다운의 어디에 있는지 알려주어야 해요...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서, 이 모든 것은 다음 변수들이 필요합니다:\n\n- 첫째, 마지막 인덱스의 포인트와 관련된 비율인 \\_moveFrom 값(즉, 관심 있는 경로 하위 청크의 첫 번째 포인트).\n- 둘째, 현재 인덱스의 포인트와 관련된 비율인 \\_moveTo 값(즉, 관심 있는 경로 하위 청크의 마지막 포인트).\n- 셋째, \\_moveTime 값으로, 우리가 말한 대로, 두 비율 사이의 차이를 취하여 총 커브 길이로 곱한 후 속력으로 나누어 계산됩니다.\n- 넷째, 우리가 0으로 초기화하고 \\_Process() 메서드에서 \\_moveTime 값에 도달할 때까지 증가시킬 \\_moveDelay 값입니다. 그러면 실제 시간 카운터가 될 것입니다.\n- 마지막으로, 업데이트해야 할 시간 계수인지 여부를 쉽게 파악하기 위해 \\_moving 부울도 설정해 봅시다.\n\n```js\npublic partial class MovingPlatform : PathFollow3D\n{\n    // ...\n\n    private bool _moving;\n    private float _moveFrom, _moveTo;\n    private float _moveTime, _moveDelay;\n\n    private void _StartMove()\n    {\n        _curWaypointIdx += 1;\n\n        _moveFrom = _waypointRatios[_curWaypointIdx - 1];\n        _moveTo = _waypointRatios[_curWaypointIdx];\n        _moveTime = Mathf.Abs(_moveTo - _moveFrom) * _totalCurveLength / _speed;\n        _moveDelay = 0;\n        _moving = true;\n    }\n}\n```\n\n모든 준비가 되었으니, 이제 우리의 \\_Process() 메서드로 돌아가서 현재 로직을 보간 시스템으로 교체해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, 우리가 움직이지 않는다면, 거기서 일찍 반환할 수 있어요:\n\n```js\npublic override void _Process(double delta)\n{\n    if (!_moving) return;\n}\n```\n\n그렇지 않고 우리가 움직인다면, 두 가지 경우가 있어요:\n\n- 만약 우리의 딜레이가 이동 시간보다 짧다면 — 이 경우에는 프레임 시간 델타를 더하여 카운터를 업데이트하고 플랫폼을 이동해야 해요\n- 또는 우리가 이동 시간 임계값에 도달했다면, 이동을 멈춰야 하며, 선택적으로 웨이포인트에서 멈추고 곡선의 다음 부분으로 진행을 계속해야 해요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic override void _Process(double delta)\n{\n    if (!_moving) return;\n\n    if (_moveDelay \u003c _moveTime) {\n        _moveDelay += (float) delta;\n        // move our platform!\n    } else {\n        // stop our movement, wait at waypoint, continue progress...\n    }\n}\n```\n\n이제 플랫폼을 이동시키기 위해 우리는 그것의 위치를 보간하여 정규화하고자 한다고 말했습니다. 이것은 Mathf.Lerp() 메서드 덕분에 쉽게 할 수 있습니다.\n\n이 내장 함수는 보간할 \"from\" 및 \"to\" 값들을 가져와 마지막으로 우리가 t-값이라고 부르는 값을 취합니다. 이 세 번째 매개변수는 우리의 서브패스 위에서 얼마나 진행했는지를 결정하는 0에서 1까지의 값입니다.\n\n간단히 시작하여 선형 이동을 만들기 위해 이 t-값을 \\_moveDelay를 \\_moveTime으로 나눈 값으로 설정합니다. (말그대로, 시간 카운터를 \"정규화\"하는 것입니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic override void _Process(double delta)\n{\n    if (!_moving) return;\n\n    if (_moveDelay \u003c _moveTime) {\n        _moveDelay += (float) delta;\n        float t = _moveDelay / _moveTime;\n        ProgressRatio = Mathf.Lerp(_moveFrom, _moveTo, t);\n    } else {\n        // stop our movement, wait at waypoint, continue progress...\n    }\n}\n```\n\n마지막으로, 카운터가 완료되면 플랫폼이 반드시 웨이포인트에 정확히 위치하고, \\_moving 부울 변수를 다시 false로 설정하고 직접 다음 웨이포인트로 이동하는 작은 함수를 호출해야합니다.\n\n```js\npublic partial class MovingPlatform : PathFollow3D\n{\n    // ...\n\n    public override void _Process(double delta)\n    {\n        if (!_moving) return;\n\n        if (_moveDelay \u003c _moveTime) {\n            _moveDelay += (float) delta;\n            float t = _moveDelay / _moveTime;\n            ProgressRatio = Mathf.Lerp(_moveFrom, _moveTo, t);\n        } else {\n            ProgressRatio = _moveTo;\n            _moving = false;\n            _ReachWaypoint();\n        }\n    }\n\n    private void _ReachWaypoint()\n    {\n        _StartMove();\n    }\n}\n```\n\n그러나 이동을 다시 시작하기 전에 \\_pauseTimeAtWaypoints가 null이 아닌 경우에는 추가 로직을 실행하기 전에 Godot에게 해당 시간만큼 기다리도록 지시하고 싶습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 이 값을 타임아웃으로 하는 미니 원샷 타이머를 생성해보겠습니다. 함수를 비동기 함수로 만들고(async 키워드 사용), 타이머 줄 앞에 await 키워드를 추가해봅시다:\n\n```js\nprivate async void _ReachWaypoint()\n{\n    if (_pauseTimeAtWaypoints \u003e 0) {\n        await ToSignal(\n            GetTree().CreateTimer(_pauseTimeAtWaypoints),\n            Timer.SignalName.Timeout);\n    }\n    _StartMove();\n}\n```\n\n함께 이 코드를 \\_Ready() 함수에도 복사해보세요. 이렇게 하면 플랫폼이 움직이기 전에 시스템이 아주 처음에 대기하도록 할 수 있습니다. \\_Ready() 함수도 반드시 async로 만들어 주세요 ;)\n\n```js\npublic async override void _Ready()\n{\n    // ...\n\n    ProgressRatio = 0;\n    _curWaypointIdx = 0;\n\n    if (_pauseTimeAtWaypoints \u003e 0) {\n        await ToSignal(\n            GetTree().CreateTimer(_pauseTimeAtWaypoints),\n            Timer.SignalName.Timeout);\n    }\n\n    _StartMove();\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 시점에서 우리의 게임을 실행하면, 이전 시도와 매우 유사한 결과를 얻게 될 것입니다... 다만 모든 웨이포인트를 고려하고 있는 차이가 있습니다! 따라서 만약 정지 시간을 0보다 큰 값으로 설정하면, 플랫폼이 정말로 각 지점에서 잠시 멈추는 것을 볼 수 있을 거예요 :)\n\n그러나 물론, 이 급격한 정지는 매우 자연스럽지 않아요. 이상적으로는 플랫폼이 웨이포인트에 도달할 때 속도를 줄이길 원할 거에요...\n\n# 우리의 정지 부드럽게 만들기\n\n움직임을 더 부드럽게 만들기 위해, 우리는 사용자 정의 이징 함수로 보조 보간 시스템을 강화할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 t 값을 그대로 사용하므로, 선형 이동이 발생합니다:\n\n우리의 움직임을 좀 더 자연스럽게 만들기 위해서는 이 t 값을 특별한 계산 함수 안에 넣어 더 흥미로운 곡선으로 변환해야 합니다:\n\n다행히도, easings.net이라는 훌륭한 웹사이트가 있어 다양한 즐거운 보간 곡선의 공식을 제공합니다!\n\n일반적으로 여기서는 quart ease-in-out 함수를 선택할 것이며, 썸네일을 클릭해 코드를 가져오면 됩니다. C# 스크립트에서 다음과 같이 재구현할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```cs\npublic partial class MovingPlatform : PathFollow3D\n{\n    // ...\n\n    private float _EaseInOutQuart(float x) {\n        return x \u003c 0.5f ? 8 * x * x * x * x : 1 - Mathf.Pow(-2 * x + 2, 4) / 2;\n    }\n}\n```\n\n여기서 t 값만 easing 함수 호출로 래핑해주면 됩니다:\n\n```cs\npublic override void _Process(double delta)\n{\n    if (!_moving) return;\n\n    if (_moveDelay \u003c _moveTime) {\n        _moveDelay += (float) delta;\n        float t = _EaseInOutQuart(_moveDelay / _moveTime);\n        ProgressRatio = Mathf.Lerp(_moveFrom, _moveTo, t);\n    } else { ... }\n}\n```\n\n그게 다에요! 게임을 다시 실행하면, 이제 플랫폼이 웨이포인트까지 멋지게 감속하고 잠시 멈춘 다음 다시 가속하여 다음 경로 청크로 이동합니다 :)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 표 태그를 Markdown 형식으로 변경해보세요.\n\n```js\npublic override void _Process(double delta)\n{\n    if (!_moving) return;\n\n    if (_moveDelay \u003c _moveTime) {\n        _moveDelay += (float) delta;\n        float t = _pauseTimeAtWaypoints \u003e 0\n            ? _EaseInOutQuart(_moveDelay / _moveTime)\n            : _moveDelay / _moveTime;\n        ProgressRatio = Mathf.Lerp(_moveFrom, _moveTo, t);\n    } else { ... }\n}\n```\n\n여기까지 왔어요 :)\n\n우리의 플랫폼 이동 기능은 이제 선택적인 중지 및 제어 가능한 속도로 굉장히 멋져졌어요... 다만, 경로의 끝에 도달하면 코드가 고장나기 시작하는데요, 비율 목록 밖의 지점 인덱스를 찾으려고 하기 때문입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 우리의 이동의 마지막 단계를 처리해야 합니다: 시작 지점으로 되돌아 가는 것...\n\n# 복귀 여정 다루기\n\n이전에 말했듯이, 우리는 디자이너가 두 가지 다른 시스템 중에서 선택할 수 있도록 하고 싶습니다:\n\n- 시작 지점으로 직접 순간 이동\n- 또는 실제로 플랫폼이 반대 방향으로 돌아가는 경로를 다시 걸어가는 왕복 방식\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 경우는 구현하기가 매우 쉽습니다.\n\n간단하게 \\_StartMove() 함수로 돌아가서 현재 인덱스를 확인하고, 현재 인덱스가 점 수와 같으면 (즉, 마지막 지점에 도달했음을 의미함), 웨이포인트 인덱스를 1로 다시 설정하면 됩니다:\n\n```js\nprivate void _StartMove()\n{\n    _curWaypointIdx += 1;\n    if (_curWaypointIdx == _nWaypoints) {\n        _curWaypointIdx = 1;\n    }\n\n    _moveFrom = _waypointRatios[_curWaypointIdx - 1];\n    _moveTo = _waypointRatios[_curWaypointIdx];\n    _moveTime = Mathf.Abs(_moveTo - _moveFrom) * _totalCurveLength / _speed;\n    _moveDelay = 0;\n    _moving = true;\n}\n```\n\n이렇게 하면 우리가 곡선의 첫 부분으로 즉시 돌아올 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 번째 경우에는 조금 더 작업이 필요합니다.\n\n우선 물론, 어떤 방향으로 가고 있는지 알기 위해 새 변수가 필요합니다. 이를 전방방향에 +1을, 후방방향에 -1을 설정하여 설정합니다. (+1은 기본 설정) 아래와 같이:\n\n```js\npublic partial class MovingPlatform : PathFollow3D\n{\n    // ...\n    private int _platformDirection = 1; // 1: 전방, -1: 후방\n}\n```\n\n이 변수를 \\_StartMove() 로직에서 인덱스 증가 값으로 사용할 수 있을 뿐만 아니라, \\_moveFrom 계산에서도 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprivate void _StartMove()\n{\n    _curWaypointIdx += _platformDirection;\n    if (_curWaypointIdx == _nWaypoints) {\n        _curWaypointIdx = 1;\n    } else if (_curWaypointIdx == -1) {\n    }\n\n    _moveFrom = _waypointRatios[_curWaypointIdx - _platformDirection];\n    _moveTo = _waypointRatios[_curWaypointIdx];\n    _moveTime = Mathf.Abs(_moveTo - _moveFrom) * _totalCurveLength / _speed;\n    _moveDelay = 0;\n    _moving = true;\n}\n```\n\n이렇게 하면 +1 또는 -1 값을 기준으로 리스트에서 이전 또는 다음 지점을 얻게 되어 플랫폼이 한 방향 또는 다른 방향으로 이동합니다.\n\n하지만, 이로 인해 극값 확인이 약간 복잡해집니다. 실제로, 이제는 현재 인덱스가 곡선의 점 수와 같은지 확인할 뿐만 아니라 -1과 일치하는지도 확인해야 합니다.\n\n```js\nprivate void _StartMove()\n{\n    _curWaypointIdx += _platformDirection;\n    if (_curWaypointIdx == _nWaypoints) {\n        _curWaypointIdx = 1;\n    } else if (_curWaypointIdx == -1) {\n    }\n\n    _moveFrom = _waypointRatios[_curWaypointIdx - _platformDirection];\n    _moveTo = _waypointRatios[_curWaypointIdx];\n    _moveTime = Mathf.Abs(_moveTo - _moveFrom) * _totalCurveLength / _speed;\n    _moveDelay = 0;\n    _moving = true;\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 이유는 우리가 경로의 양 끝에 다다를 수 있기 때문이에요 ;)\n\n이전 체크에서는 \\_jumpToStart 플래그를 사용하여 이전 코드를 분리한 후 시작할 거에요. 만약 이 플래그가 false인 경우(즉, 플랫폼을 실제로 경로를 따라 시작점 쪽으로 이동하길 원하는 경우), 우리는 방향 변수를 -1로 변경하고 현재 인덱스를 감소시킬 거예요:\n\n```js\nprivate void _StartMove()\n{\n    _curWaypointIdx += _platformDirection;\n    if (_curWaypointIdx == _nWaypoints) {\n        if (_jumpToStart) _curWaypointIdx = 1;\n          else {\n              _platformDirection = -1;\n              _curWaypointIdx -= 2;\n          }\n    }  else if (_curWaypointIdx == -1) {\n    }\n\n    _moveFrom = _waypointRatios[_curWaypointIdx - _platformDirection];\n    _moveTo = _waypointRatios[_curWaypointIdx];\n    _moveTime = Mathf.Abs(_moveTo - _moveFrom) * _totalCurveLength / _speed;\n    _moveDelay = 0;\n    _moving = true;\n}\n```\n\n이 값에 2를 줄이는 것이 필요한데, 1이 아닌 2를 감소시켜야 하는 이유는 이미 코드가 다른 방향으로 이동해야 한다고 \"인식\"하기 전에 증가시켰기 때문에 이 추가적인 오프셋을 고려해야하기 때문이에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비슷하게, 만약 우리의 인덱스가 -1에 도달하면 방향을 다시 +1로 설정하고 인덱스에 2를 더해야 합니다:\n\n```js\nprivate void _StartMove()\n{\n    _curWaypointIdx += _platformDirection;\n    if (_curWaypointIdx == _nWaypoints) {\n        if (_jumpToStart) _curWaypointIdx = 1;\n          else {\n              _platformDirection = -1;\n              _curWaypointIdx -= 2;\n          }\n    }  else if (_curWaypointIdx == -1) {\n        _platformDirection = 1;\n        _curWaypointIdx += 2;\n    }\n\n    _moveFrom = _waypointRatios[_curWaypointIdx - _platformDirection];\n    _moveTo = _waypointRatios[_curWaypointIdx];\n    _moveTime = Mathf.Abs(_moveTo - _moveFrom) * _totalCurveLength / _speed;\n    _moveDelay = 0;\n    _moving = true;\n}\n```\n\n좋아요, 정말 멋지네요! 이제 여러 순환 옵션을 처리하고 조정 가능성이 높은 완전한 이동 체계를 갖고 있습니다. 인스펙터에서 쉽게 사용자 정의할 수 있어요 :)\n\n이제 튜토리얼을 마무리하면서, 마지막 문제를 해결하는 방법을 살펴보겠습니다: 우리의 무형 플랫폼 바닥 문제!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 충돌 수정\n\n알겠어요 — 정말 기능하는 플랫폼 시스템을 얻으려면 해결해야 할 마지막 문제는 플랫폼을 통과해 버리는 우리 플레이어 아바타입니다:\n\n이전에 언급한 대로, 우리의 플랫폼은 AnimatableBody3D 노드이고 우리의 플레이어 아바타는 이전 에피소드에서 논의했던 것처럼 CharacterBody3D입니다...\n\n그래서 작동해야 하지 않나요? 문제가 뭘까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사실 일어나고 있는 것은, 우리 플랫폼이 PathFollow 노드의 도움으로 경로를 따라 이동하지만 콜라이더는 따라오지 않는다는 것이죠!\n\n이것을 확인하는 방법은 디버그 메뉴로 이동하여 콜라이더 디버그를 활성화하는 것이죠:\n\n이것은 PathFollow 노드를 사용하여 AnimatableBody 노드를 이동시킬 때 알려진 주의 사항입니다. 그러나 다행히 쉬운 해결 방법이 있습니다!\n\nRemoteTransform3D 노드를 사용하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요컨대이 노드는 매우 간단합니다. 다른 노드의 변환 속성을 동기화하여 소스의 위치, 회전 및/또는 크기를 쉽게 대상 노드에 적용할 수 있습니다.\n\n따라서 충돌을 해결하는 데 있어 요령은 PathFollow 노드의 하위 요소로 플랫폼을 직접 넣고 이렇게 이동하는 대신, 해당 충돌기의 위치를 제대로 업데이트하지 않고 충돌을 무효화하는 것이 아니라, PathFollow 노드의 자식으로 RemoteTransform3D 노드를 사용하고, 해당 위치를 다른 곳에 있는 플랫폼으로 적용하는 것입니다.\n\n따라서 장면 트리를 업데이트하는 것 외에도, 물론 RemoteTransform3D 노드의 인스펙터에서 Remote Path 속성으로 플랫폼을 대상으로 지정해야 합니다.\n\n업데이트 섹션에서는 위치에만 관심이 있는 경우 회전 및 크기 동기화를 끌 수도 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 마칩니다! 이제 플랫폼은 이전과 똑같이 움직이지만, 걸어보면 충돌이 발생하여 플레이어가 바닥을 통과하지 않게 되었어요 :)\n\n# 결론\n\n그럼 이제 기본 이동 플랫폼 시스템을 Godot과 C#에서 설정하는 방법을 알게 되셨습니다! 이 튜토리얼이 마음에 들었기를 바라고, 보간법, 이징 또는 Godot의 경로와 RemoteTransform3D 노드와 같은 개념을 이해하는 데 도움이 되었기를 희망합니다.\n\n이 튜토리얼을 즐겼다면, 기사에 박수를 치고 다음 기사를 놓치지 않도록 팔로우해주시기 바랍니다. 또한, 학습하고 싶은 Godot 트릭에 대한 아이디어를 남겨주시고 망설이지 마세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n언제나 읽어주셔서 감사합니다!\n\n더 많은 콘텐츠와 다양한 작가의 기사를 보시려면 Medium 회원이 되어 팔로우해주세요!\n\n잘 지내세요 :)\n","ogImage":{"url":"/assets/img/2024-06-23-ImplementingabasicmovingplatformGodot4C_0.png"},"coverImage":"/assets/img/2024-06-23-ImplementingabasicmovingplatformGodot4C_0.png","tag":["Tech"],"readingTime":30},{"title":"가장 이상한 잊혀진 레고 게임","description":"","date":"2024-06-23 22:13","slug":"2024-06-23-TheCoolestForgottenLegoGameIsSoWeird","content":"\n![이미지](/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_0.png)\n\n레고 게임 시리즈는 방대하며 현재 많은 회사와 스튜디오에서 개발 중입니다. 하지만 여전히 Traveler's Tales 또는 TT Games와 가장 연관이 있는 것으로 여겨집니다. 그들은 수년 동안 엄청난 수의 게임을 출시했는데, 그 대부분은 기본적인 협동 액션 어드벤처 게임으로, 선형 레벨 진행을 통해 물체를 치고 간단한 퍼즐을 해결하는 게임이었습니다.\n\n2018년쯤에 그런 내용의 콘텐츠 시리즈가 끝나고, 2022년에 TT Games는 새로운 엔진 플랫폼과 거대한 오픈 월드 게임인 레고 스타 워즈: 더 스카이워커 사가를 출시하며 시리즈를 재시작했습니다. 이 게임은 상업적으로 성공을 거두었으며, 현재 시장에서 잘 팔리는 일반적인 게임들과 더 잘부합되도록 시리즈를 융합한 작품입니다.\n\n그 성공적인 공식적인 액션 게임의 연속과 거대한 오픈 월드 스타 워즈 모험 사이에, 2019년에는 레고 무비 2 비디오게임이 출시되었습니다. 표면상 이것은 영화를 인용한 레벨을 통해 단순히 놀 수 있는 게임으로 보일 수 있지만, 실제로는 Minecraft와 90년대 후반 슈퍼 마리오 64의 성공 이후에 출시된 3D 플랫포머 게임과 이상하게 결합된 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTT Games는 Lego Worlds로 한 번 더 Minecraft를 모방해보기도 했습니다. 그것은 유명한 블록 건설 게임을 뻔뻔스럽게 복제한 것으로, 건설 도구와 생태 지대뿐만 아니라 일부 경쾌한 플랫포밍도 제공했습니다. 그것은 직접 영감받은 것보다 훨씬 더 나은 점은 없었지만, 특히 친구와 함께 할 때는 어떤 즐거움이 있는 것이었습니다.\n\n레고 무비2 비디오게임은 레고 월드 프레임워크 위에 구축되었습니다. 이것은 이야기 중심의 액션 게임이지만, 모든 레벨은 해당 보다 자유로운 엔진 내에서 구축되었습니다. 게임 플레이는 대부분의 이전 레고 게임이 제공했던 표준적인 \"모든 것을 치고 문을 열기\" 경험이 아닙니다. 오히려, 이 중심은 World의 빌드 도구를 사용하여 여러 가지 영리한 용도를 가진 정말 이상한 물건을 창조하는 환경 퍼즐 해결을 중심으로 합니다. 구축할 수 있는 것들은 환경을 폭파해 벽돌을 수집해야하지만, 전투 중심이 훨씬 적고 플레이어 창의력과 숙련된 플랫포밍에 훨씬 더 의존합니다.\n\n이것은 시리즈가 되돌아 보았을 때 신선한 일반적인 액션 사가가 아니라 어떤 것일지 상상할 때 거이 그렇습니다. 그리고 이것이 흥미로운 부분입니다.\n\n![image](/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레고 게임 열차에서 떨어진 적이 있어요. 무비 2가 나올 때였죠. 그때까지 몇 년 동안 하나도 끝내지 못했는데, 출시 시 구매하고 완료하는 습관이 있었어요. 그런데 농담 같은 이 게임을 너무 많이 했어요. PS4에서 끝내고, 원래 2019년에 너무 긴 리뷰를 썼기 때문에 스위치에서도 상당히 많이 했어요. 아닌가? 14분을 읽을 것을 알렉스, 뭔가 장난하나? 예전 나는 이 이상한 영화 타이인 게임에 대해 왜 이렇게 많은 이야기를 했을까요? 그 후에도 계속해서 게임을 했어요. 스위치 버전을 끝냈어요. 세 번째로 엑스박스에서도 했어요.\n\n그리고, 이 기사 제목의 영감을 받아 완전히 그것을 잊어버렸어요.\n\n2020년 말에 새로운 콘솔 출시의 열기에 휩쓸렸어요. 2022년에 열창적인 오픈 월드 스타워즈 스타일로 레고 시리즈가 부활했을 때 정말 즐겼어요. 영화 2와 같은 작은 규모의 창의적인 레고 게임을 더 원했던 내가 얼마나 괴로웠는지 잊어버렸죠. 그 영화가 가진 문제점을 많이 해결했고, 창조적인 에너지가 여전히 TT Games 제작 공장 안에 끓어오르고 있음을 보여주는 재미있고 가볍고 유쾌한 것입니다. 다시 돌아가봤을 때에도 여전히 즐겁습니다. \"최고\" 게임은 아니지만요. 하지만 노력하는 걸 잘 보여주고, 마인크래프트 클론으로 설계된 엔진에서 감탄할 만한 플랫포머를 만들 수 있다는 게 대단하죠. 3D 플랫포머 초기에는 누구나 슈퍼 마리오 64를 본받으려고 했고, 결과적으로 더 다채로운 세계로 이어지는 문을 여는 데용 둥둥 뛰어다니고 둥둥 모으는 장난기 많은 이야기들이 있었죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"The Lego Movie 2\" 게임은 옛날 타이틀과 매우 흡사하다는 것을 말하면서도 칭찬의 뜻을 가지고 있다. 찾을 수 있는 것들이 땅 곳곳에 흩어져 있고, 점프나 건설 시스템 중 하나에 대해 충분한 기술이 필요하므로 찾아내기 충분합니다. 지도는 숨겨진 벽돌을 수퍼 마리오 오디세이의 심오한 달들처럼 끝없이 사냥할 필요가 없도록 힌트를 제공하지만, 도전 과제는 여전히 단순하게 느껴지지만 충분히 만족스럽게 느껴지도록 잘 만들어졌습니다. 오늘 아침에 내 기억을 되살리기 위해 게임의 첫 번째 행성을 완전히 플레이했고, 이제 이 게임을 네 번째로 끝내고 싶습니다.\n\n음향 디자인도 언급할 만합니다. 강렬하고 다이내믹하며 놀라운 서라운드 채널 모멘트로 가득합니다. 게임은 대형 예산 액션 게임에 잘 어울리는 효과 작업과 피드백을 제공하며, 순전히 귀여운 가족용 플랫포머에 적합한 것으로 너무 과하게 믹싱되어 있습니다. 비슷한 목소리 캐스트는 매 line을 열정적으로 전달하는 데 훌륭한 일을 합니다. 음악은 포함된 영화 트랙의 수준에 미치지 못하지만, 그 영화 트랙은 너무 재미있고 압도적이라 복제하기가 매우 어렵습니다.\n\n90년대 추억의 플랫폼 게임을 떠올리게 하는 것 외에도 이 게임은 2019년 게임 산업을 외치는 이상한 디자인 요소를 가지고 있습니다: 무작위로 선택된 전리품 상자 언락. 세트를 넘어서 크고자하는 스티커, 건축물, 구조물에 대한 액세스 권한을 얻을 수 있지만 대부분의 이 내용은 무작위로 배치된 전리품 상자 시스템을 통해 언락됩니다. 이것은 Destiny의 스타일로 매우 복잡하고 계층적입니다. 당신은 상자에서 리플릭스라고 불리는 색상 구슬을 얻고 때로는 적에서 얻어내서 그것들을 상점에서 현금화시키기 위해 두 번째 과정을 거쳐 무엇을 포함하고 있는지 확인해야 합니다.\n\n이것은 오늘날에는 조금 의심스럽고 시대에 뒤떨어진 느낌이 들지만, 적어도 이 아이템들을 실제 돈으로 사는 방법을 구현하지 않았습니다. 전리품은 무작위 요소가 있어 무슨 종류의 것을 얻게 될지 알 수 없기 때문에 일정 수준의 재생 가능성을 더해준다고 생각하지만, Lego Worlds 엔진 디자인의 유령과 같이 이 영화 게임을 의미있게 향상시키지는 않는다고 확실합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스카이워커 사가의 불가피하고 명백한 성공으로 TT Game의 운명이 봉인된 것 같아요. 이제 그들은 영원히 오픈 월드 게임을 만들게 될 거에요. 소니 제작, Studio Gobo 개발의 레고 호라이즌 게임은 재미있어 보이지만, 예전 TT Games가 대량으로 내놓던 공식적인 것과 더 비슷해 보여요. 레고 무비 2는 독특하고 멋진 변화를 보여줍니다. 필요한 창의력의 숨통 고르기, 그리고 그저 부숴버리는 것이 아닌 무언가를 만드는 주요 레고 비디오 게임을 만들려는 진정한 시도인 것 같아요.\n\n![이미지](/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_2.png)\n\n이런 게임을 10개 더 즐거워했을 텐데, 그런 상상된 내용의 미래는 이제 매우 불가능해 보이네요. 레고 무비 2는 원작을 그저 복제하는 것 이상의 멋진 시도를 해본 그 드물고도 귀한 영화 기반 게임 중 하나에요. 지쳐가던 긴 시리즈 게임을 새롭게 살리려 한 것이 주목할 만해요. 안전한 IP 세트와 함께 작업하는 희귀한 창의적 위험인데도 마켓에서 조용히 사라졌어요. 메타크리틱 페이지에는 좋지 않은 숫자들이 즐비해 있고, 영화도 이전 시리즈만큼 잘되지 않았기 때문에 여러 사람들에게 목표적인 실패를 가져온 것 같아요. 최근 과도하게 짧고 비싼 마이크로트랜잭션으로 넘치는 레고 2K 드라이브가 이를 능가했다는 점이 화나네요.\n\n가족용 게임이 반드시 나쁜 게임일 필요는 없어요. 그들은 다를 수 있고 흥미로울 수 있으며, 다른 게임들과 같은 주의를 받고 비평적 사고를 받을 가치가 있어요. 수백만 명의 사람들이 이러한 프랜차이즈에 노출되고 있어요. 그것들은 신중하고 좋아야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"The Lego Movie 2\" 게임이 시간이 흘러도 더욱 좋게 기억될 것을 바랍니다. 하지만 아마 이것은 헛된 개인적인 성찰인 것 같아요. 더 큰 프랜차이즈는 이제 다른 \"더 큰\" 게임들을 흉내내고 있지만, 새로운 하지만 안전한 시도들은 여러 스튜디오로부터 나오고 있어요. 혹시 몇 년 후에 이 흥미로운 곳에 다시 도달할 수 있는 게 있는지 - 그것 역시 다르다는 이유로 제쳐지는 걸 겪게 될지도 몰라요.\n\n위 제목들과 관련된 어떤 사람에게서도 글을 쓰라는 요청이나 대가를 받지 않았어요.\n","ogImage":{"url":"/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_0.png"},"coverImage":"/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_0.png","tag":["Tech"],"readingTime":6},{"title":"플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착","description":"","date":"2024-06-23 22:12","slug":"2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow","content":"\n## 내일의 시스템 소프트웨어 업데이트로 플레이스테이션 포털 리모트 플레이어 기능이 업그레이드됩니다\n\n좋아하는 플레이스테이션 게임을 새로운 방식으로 경험할 준비가 되셨나요? 기대해 주세요, 오랫동안 기다려온 플레이스테이션 포털 리모트 플레이어가 드디어 출시됩니다! 내일 출시되는 이 멋진 기기는 와이파이 범위 내에서 어디에서나 플레이스테이션5 게임을 스트리밍할 수 있게 되어 게임하는 방식을 혁신할 것을 약속합니다.\n\n하지만 이것만이 아닙니다. 이 획기적인 출시와 함께 게이머 경험을 향상시키기 위해 설계된 기능과 개선 사항이 가득한 주요 시스템 소프트웨어 업데이트가 함께 제공됩니다. 소니에 따르면:\n\n궁금하시죠? 새로운 멋진 기능을 발견하고 그것이 어떻게 게임 라이프스타일을 변화시킬 수 있는지 계속 읽어보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플레이스테이션 포털 리모트 플레이어는 당신이 좋아하는 게임과 소통하는 방식을 혁신할 준비가 되어 있습니다. 8인치 LCD 화면을 특징으로 하는 이 혁신적인 장치는 PS5 타이틀을 매끄럽게 1080p 해상도에서 60fps로 플레이할 수 있도록 해줍니다. 집 안 어디서든 게임 컬렉션을 손쉽게 불러오고 사랑하는 플레이스테이션 시리즈의 몰입적인 세계로 뛰어들어 보세요.\n\n하지만 그게 다가 아닙니다. 리모트 플레이어는 호평받는 듀얼센스 무선 컨트롤러에서 발견되는 첨단 기술을 활용합니다. 이는 적응형 트리거와 햅틱 피드백을 경험하게 해줘서 모든 행동이 더 다이나믹하고 현실적으로 느껴집니다. 게임 속에 직접 들어간 것만큼 실감 나죠.\n\n가장 흥미로운 점은 무엇일까요? 플레이스테이션 포털 리모트 플레이어는 매력적인 $199.00의 가격으로 이용할 수 있으며, 무료 반품 혜택까지 제공합니다. 거실의 한계를 벗어나 게임 여행을 확장시킬 수 있는 게임 체인저인 이 제품을 확인해보세요.\n\n당신의 게이밍 경험을 향상시킬 준비가 되었나요? 이 업데이트는 곧 출시될 예정이니, 내일부터 플레이스테이션 게임의 새로운 세계에 뛰어들 준비를 해보세요!\n","ogImage":{"url":"/assets/img/2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow_0.png"},"coverImage":"/assets/img/2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow_0.png","tag":["Tech"],"readingTime":2},{"title":"편안한 게임 장르, 이제 과포화 상태일까","description":"","date":"2024-06-23 22:11","slug":"2024-06-23-CouldtheCozyGameGenrebegaspOversaturated","content":"\n저번에 소개한 Cozy Games에 관한 제 마지막 글 이후로 (얼마 지나지 않은) 새해에는 해당 장르에 더 많은 관심이 집중되고 있음을 알게 되었습니다. 2024년에는 YouTube 동영상과 글로 20개 이상의 새로운 cozy game 게임이 출시되는 것을 볼 수 있는데, cozy game 장르가 너무 일찍 포화되고 있는 것은 아닌가하는 의문이 듭니다.\n\n작년에는 이미 Dreamlight Valley, Fae Farm, Palia, Coral Island과 같은 농장 게임이 많이 출시되었으며, 저는 지난 글에서 게임이 더 많아질수록 더 넓은 영향을 줄 것이라고 주장했지만, 현재 시장은 해당 장르를 잠재적인 수익원으로 보고 있는 것으로 보입니다.\n\n## Cozy Games의 증가\n\nThe Sims, Animal Crossing 시리즈, Story of Seasons 프랜차이즈 등을 통해 언제나 편안한 게임의 개념이 존재해 왔지만, \"cozy games\"라는 용어는 지난 2년간 큰 관심을 받아 지난 크리스마스에 정점을 찍었습니다. 빠른 Google 트렌드 검색 결과는 2020년 이후로 용어의 인기가 증가하고 있음을 보여주고 있으며, 최근 Animal Crossing 출시로 인해 이러한 트렌드가 증가한 것으로 보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_0.png\" /\u003e\n\n높은 수요에는 큰 공급이 따른다. 이전의 첫인격 슈팅 게임과 배틀 로얄 게임이 유행했던 것처럼, 현기증난 것도 온 가족을 따라 숨은 팬데믹을 따라오는 안락함을 찾는 이들의 급증을 포착한 회사들은 가능한 빨리 유행을 타기로 결정했습니다. 디즈니의 드림라이트 밸리와 아발란치의 호그와트 레거시가 훌륭한 예시입니다.\n\n안타깝게도, 안락 게임을 대량 생산하려는 러시는 종종 저질 제품으로 이어졌습니다, 바로 패스트 패션의 아이디어와 닮은. 알렉시아 달린은 자신의 글 \"안락한 게임의 패스트 패션화\"에서 다음과 같이 설명합니다:\n\n그래서 우리가 이미 존재하는 안락 게임 풀에 이미 과잉인 것으로 보이는 똑같은 농장 기능, 동일한 도구 및 동일한 제어를 통합한 또 다른 게임을 만나면, 우리는 새로운 장르와 기존과 이미 많은 겹치는 메타포에 보입니다. 해당 장르는 현재 너무 혼잡한 것으로 보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 새로운 장르 흐름\n\n많은 아늑한 게임에서 농업이 주요하게 다뤄지긴 하지만, 이것은 필수적인 요소는 아닙니다. 이 장르는 그것이 일으키는 느낌으로 정의되며, 그 매커니즘만으로만이 아닙니다. 따라서 많은 개발자들이 이 장르가 곧 자신의 라벨을 벗어나게 될 수도 있다고 언급했습니다.\n\n예를 들어, 몬트리올에 본사를 둔 Alblune의 공동 창업자인 루시 레스큐이어(Lucie Lescuyer)는 최근 발매된 The Spirit and the Mouse를 통해 \"사람들은 지금 게임이 다르다는 것을 이해할 수 있도록 라벨이 필요합니다... 폭력적이지 않습니다. 그러나 몇 년 안에 라벨이 사라질 수도 있습니다. 모두에게 그러한 유형의 게임들을 즐기는 것이 보편화될 것이기 때문입니다.\"\n\n그렇다, 특히 농업 매커니즘의 유입이 2023년에 급증했지만, 게임들은 더욱더 \"아늑함\"을 느끼게 하는 다양한 주제나 매커니즘을 탐구하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_1.png)\n\n몇몇 아늑한 게임들은 더 많은 탐험 메커니즘(리틀 캣, 빅 시티)이나 티니 글레이드와 메멘토와 같은 장식 게임들이 인지도를 높이고 있습니다.\n\n저는 아늑한 게임에서 이야기 요소가 없어서는 안 된다고 믿습니다. 이야기에 열정을 가지고 있으며 전투 메커니즘 없이도 이야기를 전달할 수 있는 완벽한 매체로 게임이 있다고 봅니다. 따라서, 아늑한 장르 내의 개발자들은 여전히 우리에게 기대 이상의 농장 경험을 제공하는 새로운 게임을 혁신하고 있다고 생각합니다.\n\n## 걱정 마세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아늑한 게임 장르가 포화 상태에 이르렀을까요? 어쩌면 그럴 수도 있어요. 회사들이 트렌드를 잡아들고, Stardew Valley의 성공을 모방하려고 노력하고 있기는 한 것 같아요. 그러나 또한 우리에게 안락한 느낌을 줄 수 있는 매체를 통해 자신들의 이야기를 전하고 싶어하는 개발자들도 있다고 믿어요.\n\n어떤 다른 장르와 마찬가지로 조금의 선별이 필요할지도 모르겠지만, 아늑한 게임들은 여전히 더 넓은 관객들을 유치하고 있습니다. 이 장르에 사람들이 적극적으로 찾고 있는 것을 알게 된 게임 스튜디오에 충분히 관심을 둔 사람들이 있어서 우리는 감사해해야 합니다. 더 많은 관심. 더 많은 게임. 더 많은 편안함. 왜 안 될까요?\n\n읽어 주셔서 감사합니다! 만약 제 글이 마음에 드셨다면, 다른 기사들도 중계로 확인해 보세요. 여기서도 제 소셜 미디어를 확인할 수 있어요.\n","ogImage":{"url":"/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_0.png"},"coverImage":"/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_0.png","tag":["Tech"],"readingTime":4},{"title":"플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24","description":"","date":"2024-06-23 22:10","slug":"2024-06-23-Leashtofollowplayerdevblog24","content":"\n게임에 새로운 도구가 추가되었습니다 - 리드입니다. 이 도구는 동물을 \"플레이어를 따르도록\" 또는 \"따르지 않도록\" 전환하는 데 사용됩니다.\n\n저는 이 전환을 어떻게 구현할지 오랜 시간 고민했고 처음에는 리드를 사용하고 싶지 않았습니다. 그러나 마침내 모든 옵션 중에서 리드가 가장 논리적이고 직관적인 것으로 결론이 났습니다. 실제로 동물은 리드에 묶여 있는 것이 아니며, 플레이어에 물리적으로 묶여 있지 않고 먹이를 먹으러 다닐 수 있습니다. 오히려 \"나를 따라와\" 또는 \"나를 따르지 말아라\"라는 표시와 비슷합니다. 현실적으로 들리지 않을 수 있지만, 게임 속에서는 (적어도 저에게는) 일반적인 게임 논리처럼 느껴집니다.\n\n동물 위로 마우스를 가져가면 이제 \"따르는 중\" 또는 \"따르지 않는 중\"이라고 표시됩니다. 나중에는 이를 텍스트 없이 표시하고 싶지만, 아직 최적의 방법을 고려 중입니다 (동물의 외관을 변경할까요? 영구적인 라벨을 추가할까요? 캐릭터에 연결하는 선을 그릴까요? 동물 주변에 어떤 효과? 따르는 동물들의 초상화를 어딘가에 그릴까요?).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-06-23-Leashtofollowplayerdevblog24_1](/assets/img/2024-06-23-Leashtofollowplayerdevblog24_1.png)\n\nI also drew animations for the kittens to eat and sleep, so now they eat and sleep nicely.\n\n![2024-06-23-Leashtofollowplayerdevblog24_2](/assets/img/2024-06-23-Leashtofollowplayerdevblog24_2.png)\n\nI slightly adjusted the logic for how an animal recognizes that it’s near food or a bed. If the cat’s rectangle and the bed’s rectangle overlap, then the cat is at the target. Previously, an overlap was counted if they intersected by even one pixel. Now there are three types:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 적어도 한 픽셀 이상 겹침\n- 중간으로 겹침\n- 완전히 겹침\n\n고양이는 이제 침대 위에 완전히 올라가서 눕고 자야 해요.\n\n![고양이](https://miro.medium.com/v2/resize:fit:1400/1*GcFnFoDejJB1cV4l-uP2cg.gif)\n\n그리고 고양이는 음식 위에 반이라도 올라가서 먹어야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*NGkoOBqXnR9MaUpWq6e40g.gif)\n\n현재, 새끼 고양이는 플레이어가 먹는 것과 같은 음식을 먹을 수 있고 배부름도 100%가 됩니다. 하지만 미래에는 그들만의 음식이 생기고, 그 음식은 다른 배고픔 영향을 가질 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-23-Leashtofollowplayerdevblog24_0.png"},"coverImage":"/assets/img/2024-06-23-Leashtofollowplayerdevblog24_0.png","tag":["Tech"],"readingTime":3},{"title":"현대 웹 API 이해하기 Part 1 RESTful API 사용법","description":"","date":"2024-06-23 22:09","slug":"2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs","content":"\n# 소개\n\nAPIs (Application Programming Interface)는 현대 웹 개발의 필수 요소가 되었습니다. 이를 통해 클라이언트와 서버를 분리하여 클라이언트가 UI/UX에 집중할 수 있도록 하며, 복잡한 비즈니스 로직을 이해하지 않고도 백엔드와 상호작용할 수 있게 합니다.\n\n다양한 종류의 웹 API 중에서 RESTful, GraphQL 및 gRPC가 가장 두드러지는데요. 이 블로그에서는 RESTful API에 대해 자세히 살펴보면서 원칙, 이점 및 실용적인 사용법을 탐구해 보겠습니다.\n\n# RESTful API란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nREST은 Representational State Transfer의 약자입니다. 이 용어는 2000년 Roy Fielding의 박사 학위 논문에서 처음 소개되었습니다. REST는 API를 구축하기 위한 도구나 기술이 아니라 웹 자원 사이의 일관된 인터페이스를 설계하기 위한 제약 조건과 원칙의 집합입니다.\n\n# RESTful API 설계의 주요 원칙\n\n## 자원 중심 디자인\n\nRESTful API에서 모든 것이 자원으로 간주되며 URI (Uniform Resource Identifier)로 식별될 수 있습니다. 자원은 컬렉션 또는 개별 항목이 될 수 있습니다. 예를 들어:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- collections: /customers\n- item: /customers/1\n\n리소스 간에도 연관 관계가 있습니다.\n\n- 연결된 컬렉션: /customers/1/orders\n- 연결된 항목: /customers/1/orders/2\n\n리소스는 단순히 데이터베이스의 테이블이 아닙니다. 대신 API를 통해 주소 지정 및 조작할 수 있는 데이터 모음을 나타냅니다. 응용 프로그램이 도메인 주도 설계(DDD)를 사용하는 경우, 도메인(또는 집계)을 리소스의 경계를 정의하는 주요 고려 사항으로 삼는 것이 좋습니다. 이 접근 방식은 비즈니스 도메인과 논리적으로 일치하고 유지 관리하기 쉬운 API를 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, 프론트엔드 요구 사항을 충족하기 위해 API 설계를 최적화하는 것이 중요합니다. 이는 API 성능을 개선하고 전반적인 사용자 경험을 향상시킬 수 있습니다.\n\n## HTTP 표준\n\nRESTful API는 표준 HTTP 메소드를 활용하여 CRUD(Create, Read, Update, Delete) 작업을 수행합니다.\n\n- POST: 새로운 리소스 생성\n- GET: 단일 또는 여러 리소스 검색\n- PUT: 단일 또는 여러 리소스 업데이트\n- DELETE: 단일 또는 여러 리소스 삭제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 API들은 주로 HTTP/1.1에 의존하며, 이는 클라이언트와 서버 간의 각 상호작용이 하나의 요청과 응답 쌍으로 이루어진 텍스트 기반 통신 프로토콜입니다. RESTful API는 일반적으로 JSON 형식으로 데이터를 교환합니다. 또한 미디어 유형을 활용하여 데이터 형식을 지정합니다.\n\n- Content-Type: 리소스의 미디어 유형을 나타냅니다 (예: application/json, application/problem+json)\n- Accept: 클라이언트가 허용할 미디어 유형을 지정합니다 (예: application/json)\n\n## 상태 없음(Statelessness)\n\nRESTful API에서 요청은 상태를 유지하지 않아야 합니다. 각 요청에는 처리에 필요한 모든 정보가 포함되어 있어 백엔드가 각 요청을 독립적으로 처리할 수 있게 합니다. 이는 요청이 순차적이지 않아도 되고, 병렬로 여러 서버가 요청을 처리할 수 있도록 합니다. HTTP가 본질적으로 상태를 유지하지 않기 때문에 RESTful API가 HTTP 프로토콜에 적합하게 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 장점\n\n## 간편성\n\nRESTful API는 복잡한 리소스를 다룰 때라도 쉽게 이해하고 구현할 수 있습니다. 표준 HTTP 메서드와 명확한 URL 구조의 사용은 개발자가 신속하게 대상 리소스를 확인하고 수행 중인 작업을 이해할 수 있도록 도와줍니다.\n\n## 널리 사용되며 신뢰성이 검증됨\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRESTful API는 산업 전반에 널리 채택되어, 다양한 성공 사례와 모범 사례가 있습니다. 라우팅, 데이터 직렬화, API 테스트와 같은 일반적 작업을 위한 준비된 솔루션도 많이 있습니다.\n\n## 확장성\n\n상태가 없는 특성 때문에 RESTful API는 쉽게 확장할 수 있습니다. 웹 애플리케이션은 여러 웹 서버에 요청을 분산하여 많은 수의 요청을 수용할 수 있습니다. 따라서 RESTful API는 클라우드 환경과 분산 시스템에 잘 어울립니다.\n\n# 더불어\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## API 스키마\n\nRESTful API는 데이터 교환을 위해 JSON을 일반적으로 사용하며 유연한 스키마를 제공합니다. 그러나 이 유연성은 때로는 프론트엔드와 백엔드 간 불일치로 이어질 수 있습니다. 예를 들어 프론트엔드 엔지니어가 응답의 일부로 문서화된 속성이 실제 백엔드 응답에서 누락된 문제에 직면할 수 있습니다.\n\n이러한 문제를 완화하기 위해 API 주도 설계는 백엔드 및 프론트엜드 구성 요소를 구현하기 전에 API 스키마를 먼저 정의하는 것을 권장합니다. OpenAPI와 같은 도구는 이러한 프로세스를 용이하게하기 위해 HTTP API를 설명하는 공식 표준을 제공하여 개발자가 API 스키마를 명확하게 지정하고 API 모델 및 클라이언트를 자동으로 생성할 수 있도록 지원합니다. 이를 통해 양쪽 모두가 미리 정의된 계약에 맞추어 효율적으로 개발하고 일치하게 할 수 있습니다.\n\n## 버전 관리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n웹 API를 개발할 때는 항상 역호환성을 보장하는 것이 중요합니다. 이러한 호환성을 유지할 수 없을 때는 API 버전 관리가 필요합니다. 호환되지 않는 변경 사항이 발생할 때마다 버전 번호가 증가합니다.\n\nRESTful API는 URL 버전 관리, 쿼리 문자열 버전 관리 및 HTTP 헤더 버전 관리와 같은 다양한 버전 관리 방법을 지원합니다. URL 버전 관리의 예로는 api.example.com/v1/customers가 있습니다.\n\n# 학습 자료\n\n웹에서 찾은 가장 좋은 RESTful API 학습 자료 중 하나입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 링크를 확인해보세요: [Azure API 디자인에 대한 최상의 모범 사례](https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design). 여기에 유용한 정보가 많이 있을 거예요! 😊\n","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs_0.png","tag":["Tech"],"readingTime":6},{"title":"건축 알아야 할 필수 요약 정보","description":"","date":"2024-06-23 22:08","slug":"2024-06-23-ArchitectureThecheatsheet","content":"\n![Architecture Patterns](/assets/img/2024-06-23-ArchitectureThecheatsheet_0.png)\n\n이 논문은 다양한 소프트웨어 아키텍처 패턴, 모델, 철학 및 전략에 대한 간결한 요약을 제공하여 이러한 패턴의 독특한 특성, 응용 및 소프트웨어 디자인에 미치는 영향에 대한 통찰을 제공합니다. 이러한 패턴은 현대 소프트웨어 공학에서 주요 접근 방식과 전략을 대표하며 각각 특정 요구 사항과 도전에 대응합니다. 이 패턴은 특정 필요에 가장 적합한 접근 방법을 선택하는 아키텍트와 개발자를 지원하는 것을 목표로 합니다.\n\n소프트웨어 아키텍처 패턴은 소프트웨어 개발 중복잡한 아키텍처적 도전에 대응하기 위해 사용되는 기본 지침입니다. 이는 반복되는 문제에 대한 구조화된 솔루션을 제공하여 효율성, 확장성 및 유지보수 가능성을 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Backend For Frontend (BFF)\n\n개별 프런트엔드 애플리케이션의 요구 사항에 맞춘 특정 백엔드 서비스를 생성하여 통신 및 데이터 전달을 최적화하는 것을 포함합니다.\n\n주요 포커스: 특정 프런트엔드 애플리케이션에 맞춘 백엔드 서비스 생성.\n\n장점: 통신 및 데이터 전달을 최적화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n## Trade-offs\n\n- 중복 로직 발생 가능\n- 추가 유지보수 필요\n\n## 발행/구독 패턴\n\n주요 내용: 메시징 시스템에서 생성자와 소비자 간의 결합도 낮춤.\n\n장점: 확장성 향상 및 시스템 유연성 제고, 비동기 통신 지원.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 트레이드오프: 메시지 관리 복잡성 증가, 브로커 신뢰에 의존.\n\n## 사이드카 패턴\n\n주요 응용 프로그램 기능을 향상하거나 확장하는 데 중점을 둡니다.\n\n혜택: 기능을 격리하고 모듈화하며, 유지 보수가 쉬워집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n| Trade-offs              | Can increase system complexity, additional resource consumption. |\n| ----------------------- | ---------------------------------------------------------------- |\n| **Data-Driven Testing** |                                                                  |\n| **Focus**               | Enhancing testing processes by using data-driven methodologies.  |\n| **Benefits**            | Increases test coverage, improves efficiency.                    |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n타협: 철저한 데이터 관리가 필요하며, 데이터 관련 오류가 발생할 수 있습니다.\n\n## 회로 차단기\n\n분산 시스템의 실패를 고상하게 처리하고, 고장이 전파되지 않도록 막아주는 방법을 제공합니다. 전기 회로 차단기처럼 작동하여, 서비스 고장 시 요청의 흐름을 중지시켜 회복을 허용합니다.\n\n주요 기능: 분산 시스템에서 고장 처리.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혜택: 서비스들이 복구할 시간을 확보하여 연쇄 실패를 방지합니다.\n\n희생 요소: 잘못된 경계 값을 피하기 위해 신중한 임계값 설정이 필요합니다.\n\n## API 게이트웨이\n\n클라이언트로부터 요청을 관리하고 라우팅하는 중간 계층 역할을 하는데, 통합된 인터페이스, 보안 및 기타 횡단 관심사를 제공하여 다양한 서비스로 요청을 라우팅합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n읽기 및 쓰기 작업을 구별하여 별도의 모델로 최적화하여 성능과 확장성을 향상시킵니다, 특히 복잡하고 고수요 환경에서 특히 유용합니다.\n\n핵심: 읽기 및 쓰기 작업을 분리합니다.\n\n혜택: 성능과 확장성을 최적화합니다.\n\n타협: 복잡성을 더하며, 최종 일관성 문제를 발생시킬 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아웃박스 패턴\n\n분산 시스템에서 신뢰할 수 있는 메시지 전달을 보장하는 도구로, 특히 마이크로서비스 아키텍처에서 메시지를 전달하기 전에 일시적으로 저장합니다.\n\n주요 포인트: 분산 시스템에서 신뢰할 수 있는 메시지 전달을 보장합니다.\n\n이점: 전송 실패 중에 데이터 유실을 방지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTrade-offs: 구현 복잡성 추가, 지연 가능성이 발생할 수 있습니다.\n\n## 멀티 테넌시\n\nKeycloak를 사용하여 인증을 수행하고, Angular와 Springboot를 각각 프론트엔드 및 백엔드 개발에 사용하여 멀티 테넌트 시스템을 구현하는 방법에 대해 논의합니다.\n\n중점: 특정 기술을 사용하여 멀티 테넌트 시스템을 구현하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혜택: SaaS 애플리케이션에서 효율적인 인증 관리.\n\n희생해야 할 점: 복잡한 설정, 여러 기술 통합이 필요함.\n\n## 아키텍처 안티 패턴\n\n소프트웨어 아키텍처에 대한 일반적인 함정과 ‘안티 패턴’을 강조하여 건강하고 효율적인 소프트웨어 시스템을 유지하기 위해 피해야 할 내용에 대한 통찰을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 아키텍처 도구\n\n이 섹션에서는 아키텍처 실무를 향상시키기 위해 사용되는 모델, 철학 및 전략에 대해 설명합니다. 이들은 패턴으로 간주되지 않지만 여전히 훌륭한 시스템을 구축하는 데 매우 유용합니다.\n\n## C4 모델\n\n소프트웨어 아키텍처의 포괄적인 시각화를 제공하는 데 초점을 맞추며, Context, Containers, Components 및 Code 네 가지 수준으로 분해합니다. 서로 다른 추상화 수준에서 소프트웨어 구조를 이해하고 소통하는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n중점: 소프트웨어 아키텍처 시각화 - 네 가지 수준을 통해\n\n혜택: 소프트웨어 구조의 이해와 커뮤니케이션 강화\n\nTrade-offs: 작은 시스템에는 너무 복잡할 수 있음\n\n## Domain-Driven Design (DDD)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소프트웨어 디자인을 도메인 복잡성에 밀접하게 맞추며, 모델 주도 접근 방식을 사용합니다. 기술 및 도메인 전문가 간의 협업을 강조하여 공통 언어와 공유된 이해를 만들어냅니다.\n\n중점: 소프트웨어 디자인을 도메인 복잡성에 맞추기\n\n장점: 협업을 용이하게 하고 공통 언어를 만들어냄\n\n불리한 점: 도메인에 대한 심층적인 이해가 필요하며, 복잡할 수 있음\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Strangler Pattern\n\n레거시 시스템의 일부를 점진적으로 대체하여 새로운 기술로의 원활한 이행 및 업데이트를 가능하게 하는 것을 목표로 합니다.\n\n주요 내용: 레거시 시스템의 점진적인 대체\n\n혜택: 기존 기능을 중단하지 않고 점진적 업데이트가 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTrade-offs: 느리고 자원을 많이 소비할 수 있습니다.\n\n저는 디지털 회사의 CTO이자 건축 부서장입니다. 기술 전략의 개발, 솔루션 설계 및 R\u0026D 프로젝트를 주도적으로 진행하고 있습니다.\n\n읽어주셔서 감사합니다! 이 기사가 마음에 드셨다면, 👏을 눌러주시고 다른 사람들이 이를 발견할 수 있도록 도와주세요. 아래 댓글 섹션에 의견을 공유해주세요.\n\n# Scub Lab\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나기 전에:\n\n- 작가에게 박수를 보내고 팔로우해주세요! 👏\n- lab.scub.net에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입해주세요. 🗞️\n- 트위터(X), 링크드인, 그리고 우리의 웹사이트에서 우리를 팔로우해주세요.\n","ogImage":{"url":"/assets/img/2024-06-23-ArchitectureThecheatsheet_0.png"},"coverImage":"/assets/img/2024-06-23-ArchitectureThecheatsheet_0.png","tag":["Tech"],"readingTime":9}],"page":"15","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"15"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>