<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/23" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/23" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기" href="/post/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Spring Boot3에서 트레이싱 활용하는 방법" href="/post/2024-06-23-TracinginSpringBoot3"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Spring Boot3에서 트레이싱 활용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TracinginSpringBoot3_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Spring Boot3에서 트레이싱 활용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Spring Boot3에서 트레이싱 활용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상" href="/post/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시네크론 자바 인터뷰 질문 및 답변 경력 2-4년" href="/post/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시네크론 자바 인터뷰 질문 및 답변 경력 2-4년" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시네크론 자바 인터뷰 질문 및 답변 경력 2-4년" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">시네크론 자바 인터뷰 질문 및 답변 경력 2-4년</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift에서 부분 적용 함수 사용하는 방법" href="/post/2024-06-23-PartiallyAppliedFunctionsinSwift"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift에서 부분 적용 함수 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-PartiallyAppliedFunctionsinSwift_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift에서 부분 적용 함수 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift에서 부분 적용 함수 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유" href="/post/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="다중 터치 ML 모델 최신 트렌드 및 사용 방법" href="/post/2024-06-23-Multi-touchMLModels"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="다중 터치 ML 모델 최신 트렌드 및 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Multi-touchMLModels_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="다중 터치 ML 모델 최신 트렌드 및 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">다중 터치 ML 모델 최신 트렌드 및 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법" href="/post/2024-06-23-BuildaniOSAppwitharevenue1338mo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">24<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지" href="/post/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">21<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SWIFT에서 STRUCT와 CLASS 비교 분석" href="/post/2024-06-23-STRUCTvsCLASSinSWIFT"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SWIFT에서 STRUCT와 CLASS 비교 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-STRUCTvsCLASSinSWIFT_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SWIFT에서 STRUCT와 CLASS 비교 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SWIFT에서 STRUCT와 CLASS 비교 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link posts_-active__YVJEi" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"깊이 우선 탐색DFS 방법으로 JSON 조작 탐구하기","description":"","date":"2024-06-23 20:33","slug":"2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach","content":"\n![2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png](/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png)\n\n# 소개\n\n우리 조직의 애플리케이션 기능을 향상시키는 과정에서, JSON 조작에 관련된 매력적인 문제를 만났습니다. 특정 경로에 있는 JSON 노드의 값을 수정하는 작업은 트리 구조를 탐색하는 것과 유사한 문제입니다. 이를 해결하기 위해 Depth-First Search (DFS) 접근 방식을 활용해보았고, 이 방법이 이 문제를 효과적으로 해결하는 데 도움이 되었습니다.\n\n# 문제 이해하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJSON (JavaScript Object Notation)은 컴퓨터 과학에서 사용되는 트리와 유사한 계층 구조와 간결함으로 인해 데이터 교환에 널리 사용됩니다. 문제는 이와 같은 트리 구조 내에서 특정 경로의 값을 동적으로 액세스하고 수정해야 하는 것이 필요했습니다. 예를 들어, 경로 a.b.c에서 '\"a\": '\"b\": '\"c\": 123''를 변환하는 것은 전형적인 JSON 탐색 및 수정을 보여줍니다.\n\n# 접근 방식 및 통찰\n\n## 1. JSON을 트리로 다루기\n\nJSON의 중첩된 키-값 쌍은 트리에서 노드로 해석될 수 있으며, 객체는 내부 노드를 나타내고 배열은 노드들의 집합을 나타냅니다. 각 노드는 루트에서 리프 노드까지 탐색하는 것과 유사하게 경로를 통해 액세스할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 깊이 우선 탐색 (DFS) 응용\n\nDFS는 기본적인 트리 순회 알고리즘으로, 다음 문제 해결에 중요한 역할을 했습니다:\n\n- 재귀적 탐색: 루트(최상위 객체)에서 시작하여 중첩된 객체와 배열을 재귀적으로 탐색합니다.\n- 경로 탐색: 제공된 경로 문자열 (a.b.c - `[\"a\", \"b\", \"c\"])을 사용하여 중첩된 구조물을 효율적으로 탐색합니다.\n- 유연한 수정: 대상 노드를 식별한 후, 간단한 값 업데이트 또는 배열 내 요소 변환 등 구체적인 요구에 따라 값을 수정할 수 있습니다.\n\n## 3. 구현 여정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- JSON 파싱: Java의 org.json과 같은 라이브러리를 활용하여 JSON 객체를 분석하고 조작하는 작업을 원활하게 수행했습니다.\n- 경로 처리: 경로 문자열을 동적으로 분할하고 해석하여 중첩된 객체를 탐색하는 데 활용했습니다.\n- 시나리오 처리: JSON 객체 내에 배열이 존재하는 경우와 같은 시나리오를 다루며, 모든 요소가 수정되어야 하는 경우를 대응했습니다.\n\n# 코드 구현 예제\n\n```java\nimport org.json.*;\n\npublic class JsonManipulation {\n\n    public static String modifyJsonNode(String json, String path) {\n        JSONObject jsonObj = new JSONObject(json);\n        String[] keys = path.split(\"\\\\.\");\n        modifyNode(jsonObj, keys, 0);\n        return jsonObj.toString();\n    }\n\n    private static void modifyNode(JSONObject jsonObj, String[] keys, int index) {\n        String key = keys[index];\n        if (index == keys.length - 1) {\n            if (jsonObj.get(key) instanceof JSONArray) {\n                JSONArray array = jsonObj.getJSONArray(key);\n                for (int i = 0; i \u003c array.length(); i++) {\n                    array.put(i, \"modified\");\n                }\n            } else {\n                jsonObj.put(key, \"modified\");\n            }\n        } else {\n            modifyNode(jsonObj.getJSONObject(key), keys, index + 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        String json = \"{\\\"a\\\": {\\\"b\\\": {\\\"c\\\": 123}}\";\n        String path = \"a.b.c\";\n        System.out.println(modifyJsonNode(json, path));\n    }\n}\n```\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDFS를 활용한 JSON 조작 탐구는 이 알고리즘이 JSON과 같은 계층 구조 데이터를 탐색하고 수정하는 다양성을 강조합니다. DFS 원칙을 적용함으로써 우리는 특정 경로를 기반으로 JSON 노드에 동적으로 접근하고 수정하는 작업을 효율적으로 처리했습니다.\n\n소프트웨어 엔지니어로서 DFS와 같은 알고리즘 기법을 받아들이면 복잡한 데이터 조작 작업을 자신 있게 다룰 수 있습니다. 이 여정은 일상적인 코딩 과제에서 알고리즘적 사고의 중요성을 강조하며 문제 해결 능력과 소프트웨어 개발 혁신 능력을 함께 향상시킵니다.\n","ogImage":{"url":"/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png"},"coverImage":"/assets/img/2024-06-23-ExploringJSONManipulationUsingDepth-FirstSearchDFSApproach_0.png","tag":["Tech"],"readingTime":4},{"title":"Spring Boot3에서 트레이싱 활용하는 방법","description":"","date":"2024-06-23 20:31","slug":"2024-06-23-TracinginSpringBoot3","content":"\n![2024-06-23-TracinginSpringBoot3_0](/assets/img/2024-06-23-TracinginSpringBoot3_0.png)\n\n제 초창기 전문가 시절을 돌이켜보면, 프로덕션 문제 해결 방식에서 조금 놀라운 점이 있었습니다. 모든 것을 다 다루는 프로젝트에서 일했는데, 고객과의 인터페이싱부터 코딩, 배포, 그리고 문제 해결까지 모든 것을 처리했죠. 문제가 발생하면 명쾌한 해결책이 없는 상황이었고, 그때의 나는 프로덕션 데이터베이스 덤프를 떠서 해당 데이터베이스를 이용해 내 컴퓨터에서 애플리케이션을 실행한 다음 고객과 통화하면서 그들이 하는 작업을 재현하고 문제점을 확인하기 위해 필요한 디버그 지점 및 출력문을 사용했어요. 그 방식은 그 당시에는 효과적이었습니다. 애플리케이션은 작고 사용자 베이스가 제한적이었으며, 단일 개발자로는 완전히 관리할 수 있었지만, 그때는 여전히 로깅의 중요성을 이해하지 못했죠.\n\n몇 년 후, 이제는 여러 개발자, 제품 소유자, 스크럼 마스터, 운영팀, 인프라팀, 그리고 물론 수백만 명의 사용자가 참여하는 프로젝트에서 일하고 있습니다. 중요한 점은 개발자에게는 프로덕션 환경이 대부분 접근 불가능하며, 또한 고객이 개발자와 직접 커뮤니케이션할 수 없으므로 우리를 미치게 만든다는 사실입니다.\n\n운영팀은 이 두 영역 사이의 다리 역할을 했습니다. 그들의 주요 업무는 시스템, 애플리케이션 로그, 필요시 데이터베이스를 조사하여 문제를 해결하는 것이었죠. 해결책을 찾지 못하거나 향상 시야를 가지고 있다면 해당 데이터로 개발자에게 접근하게 됐습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 환경에서 작업하면서 로그의 중요성을 점차 알게 되었습니다. 로그는 응용프로그램이나 거래의 이벤트를 추적하는 데 도움이 됩니다. 적절한 분석을 통해 패턴을 찾거나 이상 현상을 예측하는 데 도움이 됩니다.\n\n하지만 분산 추적에 대해 아직 많이 알지 못했습니다. 다양한 식별자(전화번호, 사용자 ID 등)를 추가하여 운영팀이 고객 문제를 적절히 조사할 수 있도록 했습니다.\n\n그러나 이 방법에도 문제가 있었습니다. 동일한 고객이 시스템과 다양한 상호 작용을 할 수 있어, 해당 식별자로 여러 로그 스트림이 생성되었습니다. 따라서 문제에 대한 정확한 로그를 찾는 것은 여전히 번거로웠습니다. 여러 애플리케이션이 관련될 때의 고통은 시작도 못 했죠. 서비스 호출 간 페이로드에 수동으로 UUID를 추가하고 로그를 남겼습니다.\n\n결국에는 내 현재 접근 방식이 부족하다는 것이 명백해졌습니다. 내 일부 응용프로그램은 다른 팀이 유지보수하는 다른 애플리케이션 사이에서 미들웨어로 작용했습니다. 그들이 내 불편함을 용인해야 할 이유가 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음, Sleuth를 발견했어요. 정말 놀라웠죠; 단 하나의 의존성을 추가하고 로깅을 구성하기만 하면 어플리케이션 전체에 대한 추적을 활성화할 수 있었어요. 여러 개의 마이크로서비스를 사용하더라도 서비스 간 추적 ID를 전파하기 위한 추가적인 조치가 필요하지 않았어요.\n\nSpring Boot 3 이전에는 프로젝트를 시작할 때마다 항상 Spring Cloud Sleuth를 포함해 분산 추적을 활성화했어요.\n\n그런 다음 Spring Boot 3이 나오면서 Sleuth가 Micrometer로 이관되었어요. 이 기사에서는 Micrometer 추적을 활용해 Spring Boot 3에서 Sleuth와 유사한 기능을 어떻게 구현하는지 살펴볼 거예요.\n\n지금은 컨트롤러와 서비스가 있는데, 일부 로그를 사용하고 있어요. 포스트맨으로 컨트롤러 엔드포인트에 요청을 보내면 다음과 같은 로그를 얻게 돼요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n2024-02-23T23:28:18.043+06:00  INFO 14443 --- [rest-api] [nio-8080-exec-2] x.r.t.restapi.web.MessageController   : Received message: Message(header=some header, content=some content)\n2024-02-23T23:28:18.046+06:00  INFO 14443 --- [rest-api] [nio-8080-exec-2] x.r.t.r.service.MessageServiceImpl    : Handling message Message(header=some header, content=some content)\n```\n\n추적이 없다는 것을 명확하게 알 수 있어요. 이제 다음 종속성을 추가할 거에요:\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eio.micrometer\u003c/groupId\u003e\n  \u003cartifactId\u003emicrometer-tracing-bridge-brave\u003c/artifactId\u003e\n  \u003cscope\u003ecompile\u003c/scope\u003e\n\u003c/dependency\u003e\n```\n\n동일한 엔드포인트를 한 번 더 호출해보세요. 그런데 여전히 운이 없거나 로그가 없어요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인터넷 검색 결과를 통해 작업을 수행하기 위해 액추에터도 추가해야 한다는 것을 알아냈습니다.\n\n```js\n\u003cdependency\u003e\n  \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n  \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\n  \u003cscope\u003ecompile\u003c/scope\u003e\n\u003c/dependency\u003e\n```\n\n동일한 엔드포인트를 다시 요청하면 다음과 같은 로그가 생성됩니다:\n\n```js\n2024-02-24T00:11:06.050+06:00  INFO 18463 --- [rest-api] [nio-8080-exec-1] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.r.t.restapi.web.MessageController   : Received message: Message(header=some header, content=some content)\n2024-02-24T00:11:06.053+06:00  INFO 18463 --- [rest-api] [nio-8080-exec-1] [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] x.r.t.r.service.MessageServiceImpl    : Handling message Message(header=some header, content=some content)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 보세요. [65d8dfb96a137925ba56091d26f33e80-ba56091d26f33e80] 이 부분에는 트레이스 ID와 스팬 ID가 포함되어 있습니다.\n\n이제 다른 서비스를 호출할 수 있는지 확인해 봅시다. 그리고 트레이스 ID가 거기로 전달되는지도 확인해 봅니다.\n\n저는 rest-api-2 라는 다른 서비스를 만들었습니다. 해당 서비스에는 필요한 컨트롤러, 서비스 및 필요한 종속성이 포함되어 있습니다.\n\n이제 새롭고 화려한 rest-client를 사용하여 rest-api에서 rest-api-2로 HTTP 호출을 해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nrest-api에서 MessageServiceImpl을 수정한 내용은 다음과 같습니다:\n\n```js\n@Service\n@Slf4j\npublic class MessageServiceImpl implements MessageService {\n\n private final RestClient restClient;\n public MessageServiceImpl(@Value(\"${rest-api-2.url}\") String restApi2Url) {\n     this.restClient  = RestClient.builder().baseUrl(restApi2Url)\n         .defaultHeader(\"Content-Type\", MediaType.APPLICATION_JSON_VALUE).build();\n\n }\n\n @Override\n public void handleMessage(Message message) {\n     log.info(\"처리할 메시지: {}\", message);\n     this.restClient.post().uri( \"/process-message\").body(message).retrieve();\n\n }\n\n}\n```\n\n여기서 생성자에서 rest 클라이언트의 인스턴스를 선언했습니다. 그런 다음, 서비스에서 rest-api-2로 호출을 수행했습니다.\n\nrest-api의 로그:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n2024-02-24T14:31:13.060+06:00  INFO 29880 --- [rest-api] [nio-8080-exec-5] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.r.t.restapi.web.MessageController   : Received message: Message(header=some header, content=some content)\n2024-02-24T14:31:13.061+06:00  INFO 29880 --- [rest-api] [nio-8080-exec-5] [65d9a95114390c055da56f5c4e138be3-5da56f5c4e138be3] x.r.t.r.service.MessageServiceImpl    : Handling message Message(header=some header, content=some content)\n```\n\nrest-api-2의 로그:\n\n```js\n2024-02-24T14:31:13.072+06:00  INFO 29563 --- [rest-api-2] [nio-8081-exec-7] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.r.t.r.web.MessageProcessorController   : Received message for processing Message(header=some header, content=some content)\n2024-02-24T14:31:13.072+06:00  INFO 29563 --- [rest-api-2] [nio-8081-exec-7] [65d9a9513ed86cb5ea2477e08166b9d2-ea2477e08166b9d2] x.r.t.r.s.MessageProcessorServiceImpl : Processing Message Message(header=some header, content=some content)\n```\n\nrest-api-2의 traceId와 spanId가 있는 것을 확인할 수 있어요. 하지만, 이들은 일치하지 않아요! 각 요청마다 새로운 추적 컨텍스트를 시작하고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 첫 번째 애플리케이션에서의 traceId가 두 번째 애플리케이션으로 전파되지 않는 것을 의미합니다.\n\n이를 확인해 보겠습니다.\n\nrest-api-2 애플리케이션을 중지하고, 해당 애플리케이션이 실행되던 포트를 듣기 시작한 것을 netcat이라는 도구로 확인했습니다:\n\n![이미지](/assets/img/2024-06-23-TracinginSpringBoot3_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 엔드포인트가 호출되면 다음과 같은 내용을 받습니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_2.png\" /\u003e\n\n보시다시피, traceId를 포함한 일부 헤더가 있어야 하는데 없습니다. 요청에 추적 컨텍스트가 포함된 적절한 헤더가 있는지 확인해야 합니다.\n\n이건 그렇게 어렵지 않아요. 우리는 스프링 부트가 자동으로 구성한 기본 restClient 빌더를 사용해야 합니다. 이것은 traceId를 전파하기 위한 필요한 지식을 갖고 있습니다. 다음과 같이 할 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npublic MessageServiceImpl(@Value(\"${rest-api-2.url}\") String restApi2Url, RestClient.Builder restClientBuilder) {\n     this.restClient  = restClientBuilder.baseUrl(restApi2Url)\n         .defaultHeader(\"Content-Type\", MediaType.APPLICATION_JSON_VALUE).build();\n\n }\n```\n\n우리는 서비스의 생성자를 통해 기본 RestClient.Builder를 받았습니다. 코드의 나머지 부분은 간단합니다. 이제 요청을 초기화하면 다음과 같은 것을 볼 수 있습니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-TracinginSpringBoot3_3.png\" /\u003e\n\n이제 우리에게 traceId를 포함한 traceparent라는 헤더가 있습니다. 이제 netcat을 중지하고 rest-api-2 애플리케이션을 시작하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 애플리케이션 로그:\n\n![2024-06-23-TracinginSpringBoot3_4.png](/assets/img/2024-06-23-TracinginSpringBoot3_4.png)\n\n두 번째 애플리케이션 로그:\n\n![2024-06-23-TracinginSpringBoot3_5.png](/assets/img/2024-06-23-TracinginSpringBoot3_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 빙고!\n\n두 애플리케이션 간에 트레이스 ID가 일치하는 것을 볼 수 있습니다. 단, spanId는 일치하지 않지만, 이는 예상한 바입니다.\n\n서비스를 리팩토링할 수 있는 좋은 시기라고 생각합니다. 여기서 rest-client를 선언하는 대신, 구성 클래스에서 재사용 가능한 빈으로 선언할 것입니다.\n\nRest client 구성 클래스는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n@Configuration\npublic class RestClientConfig {\n @Bean(\"restApi2Client\")\n RestClient restApi2Client(@Value(\"${rest-api-2.url}\") String restApi2Url, RestClient.Builder restClientBuilder) {\n     return restClientBuilder.baseUrl(restApi2Url)\n         .defaultHeader(\"Content-Type\", MediaType.APPLICATION_JSON_VALUE).build();\n }\n\n}\n```\n\nAnd refactored MessageServiceImpl class:\n\n```java\n@Service\n@Slf4j\npublic class MessageServiceImpl implements MessageService {\n\n private final RestClient restClient;\n\n public MessageServiceImpl(@Qualifier(\"restApi2Client\") RestClient restClient) {\n     this.restClient = restClient;\n }\n\n\n @Override\n public void handleMessage(Message message) {\n     log.info(\"Handling message {}\", message);\n     this.restClient.post().uri( \"/process-message\").body(message).retrieve();\n\n }\n\n}\n```\n\nCleaner right ?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 단순한 데모입니다. Micrometer를 활용하여 다른 관측 가능성 사용 사례에 대해 더 많이 쓸 예정이에요.\n\n여기 모든 코드가 있는 레포입니다.\n\n즐거운 코딩하세요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*5D9ZTssrYkDI-7hN0fAVkw.gif)\n","ogImage":{"url":"/assets/img/2024-06-23-TracinginSpringBoot3_0.png"},"coverImage":"/assets/img/2024-06-23-TracinginSpringBoot3_0.png","tag":["Tech"],"readingTime":12},{"title":"Java 21과 Spring Boot 3x를 사용한 gdocweb 개발 및 그 이상","description":"","date":"2024-06-23 20:29","slug":"2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond","content":"\n![BuildinggdocwebwithJava21SpringBoot3xandBeyond](/assets/img/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond_0.png)\n\n새 프로젝트를 시작하는 것은 항상 흥분과 어려운 결정의 조합입니다, 특히 Google Docs와 GitHub Pages 같은 익숙한 도구들을 함께 사용할 때는 더욱 그렇습니다. 이것은 많은 사람들에게 삶을 더 쉽게 만들어줄 것으로 기대한 도구 gdocweb을 구축한 이야기입니다. Java 21과 Spring Boot 3.x를 선택한 이유, 일부 시행착오를 거친 뒤 GraalVM을 포기한 이유, 그리고 좀 더 복잡한 옵션보다 간단한 VPS와 Docker Compose가 이겼다는 이야기를 들려드리겠습니다. 저는 또한 Postgres와 JPA를 선택했지만 Flyway와 같은 마이그레이션 도구는 피했습니다. 이것은 유용하고 효율적인 것을 만들려는 엔지니어의 선택, 변화 및 가끔의 '아하' 순간들을 솔직하게 기록한 이야기입니다.\n\n# gdocweb 소개\n\ngdocweb을 구축하는 기술적 세부 사항과 의사 결정의 미로에 빠지기 전에, gdocweb이 무엇이며 어떤 문제를 해결하는지를 이해하는 것부터 시작해볼까요? 간단히 말해, gdocweb은 Google Docs를 GitHub Pages에 연결하는 것입니다. GitHub의 모든 강력함과 Google Docs의 모든 사용 편의성을 갖춘 무료 사이트를 생성하는 간단한 웹 빌더입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n웹사이트 구축 및 문서 작성에 일반적으로 동반되는 복잡성을 제거하기 위해 gdocweb를 개발하기로 결정했어요. 이는 콘텐츠를 발행하고 유지 관리하는 데 번거로움 없이 사용하고자 하는 사용자들을 위한 것이지만, GitHub의 강력함에는 빠져들지만 마크다운의 세세한 부분까지 다루고 싶지 않은 숙달된 사용자들을 위한 것입니다.\n\n일반 대중을 위해 gdocweb를 설명하는 짧은 비디오가 있어요:\n\n# Java 21 및 Spring Boot 3.x: 혁신과 성숙함\n\ngdocweb와 같이 프로젝트를 혼자 이끌 때, 팀이나 기업 환경에서는 더 어려울 수 있는 기술 선택을 마음대로 할 수 있어요. 이 자유로움으로 인해 이 프로젝트에서 Java 21 및 Spring Boot 3.x를 선택했어요. 현재 장기 지원(LTS) 버전인 Java를 선택한 결정은 올바른 선택이었어요. 최신 기술을 사용하는 것이 항상 유혹적이지만, Java 21을 선택한 이유는 새로운 것을 사용하는 데 그치지 않고, 시대를 견뎌낼 수 있고 현대적인 개발 요구를 충족시키기 위해 진화한 플랫폼을 활용하고자 했기 때문이에요. 가상 쓰레드는 Java 21 선택의 주요 부분이었어요. 이러한 프로젝트에서 비용은 매우 중요한 요소이며, 서버로부터 최대 처리량을 뽑아내는 것은 이러한 상황에서 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바는 이미 성숙한 기술로, 최신 버전에서도 신뢰감을 제공합니다. 비슷하게, 최신 버전인 스프링 부트 3.x도 견고하고 테스트된 프레임워크 계보에서 나온 제품입니다. 오랜 명성을 자랑하는 보수적인 선택이지만 기능과 성능 측면에서 혁신적입니다.\n\n하지만 이 결정도 순탄치 않았어요. Google API 접근을 통합하는 과정에서 보안 CASA 티어 2 검토를 거쳐야 했죠. 이때 자바 21을 선택한 것이 문제였습니다. 해당 검토 도구는 JDK 11을 위해 제작됐기 때문에 JDK 21에서도 작동은 했지만 프로세스에 약간의 스트레스를 준 케이스였습니다. 최신 기술 버전을 다룰 때 예상치 못한 어려움이 있을 수 있다는 것을 다시 상기시켜 주었죠. 심지어 자바와 같이 성숙한 기술이더라도요.\n\n스프링 부트 3.x로 전환하는 과정도 다양한 도전이 있었는데, 특히 보안 구성 변경 때문에 어려움을 겪었습니다. 이러한 수정으로 인해 대부분의 온라인 샘플과 안내서가 사용할 수 없게 되어 초기 설정을 많이 망가뜨렸죠. 이러한 변화에 적응하고 새로운 방법을 찾는 학습 곡선이었지만, 대부분의 다른 측면은 비교적 간단했고, 스프링 부트 3.x에 대해 할 수 있는 가장 좋은 칭찬은 스프링 부트 2.x와 매우 유사하다는 점입니다.\n\n# 효율을 위한 GraalVM 네이티브 이미지\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGraalVM 네이티브 이미지에 대한 저의 관심은 기본적으로 메모리 사용량을 줄이고 시작 시간을 빠르게 하는 약속 때문이었습니다. 낮은 메모리 요구 사항으로 더 많은 서버 인스턴스를 실행하여 더 나은 확장성과 내구성을 가질 수 있다는 아이디어를 갖고 있었고, 시작 시간이 빨라지면 장애로부터 더 빠른 회복이 가능해져 신뢰할 수 있는 서비스를 유지하는 데 중요했습니다.\n\n# GraalVM 구현\n\nGraalVM을 동작시키는 것은 쉽지 않았지만 너무 어렵지는 않았습니다. 몇 차례의 시행착오 끝에 GraalVM 프로젝트를 빌드하고 Docker에 업로드하는 지속적 통합(CI) 프로세스를 설정할 수 있었습니다. 제가 M1 Mac을 사용하고 있지만 서버는 Intel 아키텍쳐에서 실행 중이었기 때문에 이러한 설정이 필요했습니다. 이러한 설정으로 업데이트마다 18분의 대기 시간을 처리해야 했는데, 개발 주기에 상당한 지연이었습니다.\n\n# 프로덕션에서 직면한 문제들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로젝트의 프로덕션 및 스테이징 환경을 테스트하기 시작하면서 상황이 복잡해졌어요. 네이티브 이미지에서 빠진 라이브러리 코드로 '두더지 잡기' 상황이 벌어졌죠. 해결한 문제마다 새로운 문제가 발생하고, 각 업데이트마다 18분씩 걸리는 과정이 답답함을 더했어요.\n\n문제의 결정적 순간은 Google API 라이브러리와의 호환성 문제를 깨달았을 때였어요. 이 문제를 해결하기 위해서는 GraalVM 빌드에서의 철저한 테스트가 필요했는데, 이미 느린 빌드 시간으로 부담을 느끼고 있었죠. 제 작은 프로젝트에 대해선 수고에 비해 이득이 미미한 병목 현상이었어요.\n\n# 진행 방향 결정\n\nGraalVM은 자원을 아낄 수 있는 이상적인 선택처럼 보였지만, 현실은 다르았어요. 제한된 GitHub Actions 분을 사용하고 철저한 테스트를 요구하여, 이 프로젝트 규모에선 실용적이지 않았죠. 결국, GraalVM 경로를 포기하기로 결정했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 GraalVM을 사용하기로 결정하신다면, 저는 다음 GitHub Actions 스크립트를 사용했었는데요. 여러분의 여정에 도움이 됐으면 좋겠어요:\n\n```js\nname: Java CI with Maven\non:\n  push:\n    branches: [ \"master\" ]\n  pull_request:\n    branches: [ \"master\" ]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:latest\n        env:\n          POSTGRES_PASSWORD: yourpassword\n        ports:\n          - 5432:5432\n        options: \u003e-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    steps:\n    - uses: actions/checkout@v3\n    - uses: graalvm/setup-graalvm@v1\n      with:\n        java-version: '21'\n        version: '22.3.2'\n        distribution: 'graalvm'\n        cache: 'maven'\n        components: 'native-image'\n        native-image-job-reports: 'true'\n        github-token: ${ secrets.GITHUB_TOKEN }\n    - name: Wait for PostgreSQL\n      run: sleep 10\n    - name: Build with Maven\n      run: mvn -Pnative native:compile\n    - name: Build Docker Image\n      run: docker build -t autosite:latest .\n    - name: Log in to Docker Hub\n      uses: docker/login-action@v1\n      with:\n        username: ${ secrets.DOCKERHUB_USERNAME }\n        password: ${ secrets.DOCKERHUB_TOKEN }\n    - name: Push Docker Image\n      run: |\n        docker tag autosite:latest mydockeruser/autosite:latest\n        docker push mydockeruser/autosite:latest\n```\n\n이 구성은 GraalVM의 혜택을 활용하기 위한 제 시도의 중요한 부분이었지만, 프로젝트가 진화함에 따라 기술 선택에서 이상주의와 배포 및 유지보수의 실용성 사이의 상충을 이해하는 데 도움이 되었습니다.\n\n# 배포: VPS 및 Docker Compose\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ngdocweb을 배포할 때 고려해야 할 여러 가지 방법이 있었어요. 각 옵션에는 각각의 장단점이 있었지만, 신중한 평가 끝에 Docker Compose를 사용하는 Virtual Private Server (VPS)를 사용하기로 결정했어요. 제 생각 프로세스를 자세히 살펴보고, 이 선택이 제 요구 사항에 가장 적합한 이유를 알아봐요.\n\n# 원시 VPS 배포 피하기\n\nVPS에 애플리케이션을 직접 설치하는 간단한 방법을 제외했어요. 이 방법은 이주 편의성, 테스트 및 유연성 면에서 부족했어요. 컨테이너는 더 간편하고 효율적인 접근 방식을 제공해요. 서로 다른 환경 사이에서 추상화 수준과 일관성을 제공하여 매우 가치 있는 것이에요.\n\n# 관리형 컨테이너 및 오케스트레이션 회피하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n관리형 컨테이너와 오케스트레이션 (예: k8s)은 다른 옵션이었고, 확장성과 관리 용이성을 제공하지만 다른 영역에서 복잡성을 도입합니다. 예를 들어, 관리형 Kubernetes 서비스를 사용할 때 데이터베이스에 대해 클라우드 스토리지에 의존해야 한다는 것이 종종 곧 비용이 빠르게 증가할 수 있다는 것을 의미합니다. 나의 철학은 프로젝트 초기 단계에서 횡적 규모보다는 비용에 초점을 맞추는 것이었습니다.\n\n작은 규모에서 최적화하고 안정화하지 않으면 성장함에 따라 문제가 점점 더 심각해질 것입니다. 확장은 이상적으로는 수직 확장부터 시작해야 하며, 이후에 수평 확장으로 이동해야 합니다. 수직 확장은 더 많은 CPU/RAM을 의미하고, 수평 확장은 추가적인 머신을 추가합니다. 수직 확장은 비용 효율적일 뿐만 아니라 기술적 측면에서도 중요합니다. 간단한 프로파일링 도구를 사용하여 성능 병목 현상을 식별하기가 더 쉬워집니다.\n\n반면에, 수평 확장은 더 많은 인스턴스를 추가하여 이러한 문제를 숨기는 경우가 많습니다. 이는 높은 비용과 숨겨진 성능 문제로 이어질 수 있습니다.\n\n# Docker Compose의 선택\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 컴포즈는 몇 가지 이유로 명백한 우승자로 떴어요. 데이터베이스와 응용 프로그램 컨테이너를 원활하게 통합할 수 있게 해주었습니다. 그들의 통신은 폐쇄된 네트워크 안에서 이루어지므로 외부에서 접근할 수 있는 포트가 없어 안전성이 높아졌습니다. 또한 비용은 고정되어 예측 가능하며 사용량에 따른 뜻밖의 추가 비용이 없다는 장점이 있어요.\n\n이러한 설정은 더 확장된 컨테이너 오케스트레이션 시스템의 부담과 복잡성 없이 유연성과 컨테이너화의 쉬움을 제공했어요. 배포 프로세스를 복잡하게 만들지 않으면서도 필요한 기능을 충분히 제공하는 완벽한 중간 지점이었습니다.\n\n도커 컴포즈를 사용함으로써 환경을 효율적으로 제어하고 배포 프로세스를 간단하고 관리하기 쉽게 유지했어요. 이 결정은 gdocweb의 일반적인 이념 — 간결함, 효율성, 실용성과 완벽하게 부합했어요.\n\n# 프론트엔드: 현대적인 대안들보다 Thymeleaf를 선호합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ngdocweb의 프론트엔드 개발은 나에게 조금 도전이었습니다. React와 유사한 프레임워크가 주를 이루는 시대에 Thymeleaf를 선택하는 것은 거꾸로 보일 수 있지만, 이 결정은 실용적인 고려와 프로젝트 요구 사항 및 개발자로서의 내 강점에 대한 명확한 이해를 기반으로 합니다.\n\n# React: 현대적이지만 일치하지 않는 해결책\n\nReact는 틀림없이 현대적이고 강력하지만, 그것만의 복잡성이 딸려옵니다. React에 대한 내 경험은 많은 개발자들이 편안한 영역을 벗어나 시도하는 것과 유사합니다 - 기능적이지만 정확히 능숙하지는 않습니다. 내 코드를 보는 시니어 React 개발자들이 느끼는 당황한 표정을 보았습니다. 다른 사람이 작성한 복잡한 Java 코드를 읽을 때 내가 느끼는 것과 비슷합니다.\n\nReact의 학습 곡선과 특정 시나리오에서의 성능 저하, 깊은 전문 지식 없이는 세련된 결과물을 얻을 수 없는 위험 등을 고려하여 gdocweb에 적합성을 재고하게 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Thymeleaf의 매력\n\nThymeleaf는 다른 방면에서 더 직관적인 접근 방식을 제공하며, 이 프로젝트의 간결함과 효율성에 잘 맞습니다. React와 같은 프레임워크와 비교할 때 낡은 것으로 여겨질 수 있는 HTML 기반의 인터페이스가 상당한 장점을 가지고 있습니다:\n\n- 페이지 흐름의 간단함: Thymeleaf는 이해하기 쉽고 디버깅하기 쉬운 흐름을 제공하여 이 프로젝트에 실용적인 선택이 됩니다.\n- 성능과 속도: 빠른 성능으로 유명하며, 좋은 사용자 경험을 제공하는 중요한 요소입니다.\n- NPM이 필요 없음: Thymeleaf는 추가적인 패키지 관리가 필요 없으므로 복잡성과 잠재적인 취약점을 줄입니다.\n- 클라이언트 측 취약점의 위험 감소: Thymeleaf의 서버 측 성격은 클라이언트 측 문제의 위험을 본질적으로 줄입니다.\n\n# 동적 기능에 대한 HTMX 고려\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHTMX를 사용하여 프론트엔드의 동적 동작을 구현하는 아이디어가 머릿속을 스쳤어요. HTMX는 동적 기능을 쉽게 추가할 수 있다고 해서 얼마 전부터 주목하고 있었어요. 그러나 기본적으로 간단한 위자드인 gdocweb과 같은 도구에 HTMX가 정말 필요한지 스스로에게 물어보았어요. 제 결론은 HTMX를 선택하는 것이 기술적인 필요성보다는 내가 이력서에 쓰기 좋을 것 같아하는 Resume Driven Design (RDD)일지도 모른다는 것이었어요.\n\n요약하면, Thymeleaf 선택은 실용성, 익숙함, 효율성을 결합한 것이었어요. 더 현대적이지만 복잡성과 과도한 부담이 있는 다른 프레임워크를 사용할 필요는 없었지만 빠르고 간편하며 효과적인 프론트엔드를 구축할 수 있게 했어요.\n\n# 마지막으로\n\n이 글에서 중요한 점은 기술 선택에서 실용성의 중요성입니다. 우리가 직접 프로젝트를 구축할 때는 더 최신 기술을 실험하기 쉽지만, 이는 가파른 경사입니다. 실험을 하면서도 익숙한 지식을 바탕으로 균형을 유지해야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGraalVM을 사용하면서 기술 선택을 프로젝트 요구 사항과 조화롭게 맞추고 도전에 적응하는 유연성이 얼마나 중요한지를 깨달았어요. 기술에서 때로는 더 간단하고 시험된 길이 가장 효과적일 수 있다는 것을 상기시켜 주는 것 같아요.\n","ogImage":{"url":"/assets/img/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond_0.png"},"coverImage":"/assets/img/2024-06-23-BuildinggdocwebwithJava21SpringBoot3xandBeyond_0.png","tag":["Tech"],"readingTime":11},{"title":"시네크론 자바 인터뷰 질문 및 답변 경력 2-4년","description":"","date":"2024-06-23 20:27","slug":"2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp","content":"\n\"안녕하세요 여러분, 이 글에서는 Synechron 기술 회사에서 Java 개발자 직무를 위한 인터뷰 질문과 답변을 공유하겠습니다. 함께 알아보세요.\"\n\n![이미지](/assets/img/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp_0.png)\n\nJava의 Stream API는 Java 8에서 도입된 기능입니다. 이는 Stream이라는 새로운 추상화를 제공하여 데이터를 선언적인 방식으로 처리할 수 있게 합니다. Stream API는 객체 컬렉션을 처리하는 데 사용되며, 복잡한 작업을 일련의 단계로 수행할 수 있도록 합니다.\n\nJava의 Stream은 일련의 요소를 지원하며 순차적 및 병렬 집계 작업을 지원합니다. 이러한 작업에는 데이터 필터링, 매핑, 정렬 또는 기타 데이터 조작이 포함될 수 있습니다.\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 내부적으로 작동 방식을 설명합니다:\n\n- 생성: 스트림은 배열, 컬렉션 또는 I/O 채널과 같은 소스에서 생성됩니다. 소스는 스트림 객체로 래핑됩니다.\n- 구성: 스트림 객체는 일련의 변환 작업으로 구성됩니다. 이러한 변환 작업은 즉시 적용되지 않고 대신 작업 파이프라인으로 저장됩니다. 각 작업은 스트림을 입력으로 사용하고 스트림을 출력으로 생성하는 함수입니다.\n- 실행: 스트림 객체에서 collect, reduce, forEach 등과 같은 최종 작업이 호출되면 처리가 시작됩니다. 데이터는 파이프라인의 모든 작업을 통해 한 번에 하나씩 파이프로 이동합니다. 작업은 \"게으른(lazy)\" 방식으로 처리되며 필요할 때만 실행됩니다.\n- 사용: 스트림이 사용되고 다시 사용할 수 없습니다. 데이터를 다시 탐색해야 하는 경우 새로운 스트림을 생성해야 합니다.\n\n```java\nList\u003cString\u003e names = Arrays.asList(\"John\", \"Jane\", \"Adam\", \"Eve\");\nList\u003cString\u003e uppercaseNames = names.stream()  // 스트림 생성\n    .filter(name -\u003e name.startsWith(\"A\"))      // \"A\"로 시작하는 이름 필터링\n    .map(String::toUpperCase)                  // 대문자로 변환\n    .collect(Collectors.toList());             // 결과를 리스트로 수집\n```\n\n이 예제에서는 스트림 API를 사용하여 이름 목록을 필터링하고 대문자로 변환하는 방법을 보여줍니다. filter와 map 메서드는 중간 작업으로 스트림을 구성하며, collect 메서드는 처리를 트리거하고 결과를 새로운 리스트로 수집하는 최종 작업입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSOLID은 소프트웨어 시스템을 설계할 때 유지보수 및 확장이 용이한 다섯 가지 원칙을 나타내는 약어입니다. 다음은 예와 함께 나열되어 있어요:\n\n- SRP(Single Responsibility Principle): 한 클래스는 변경되는 이유가 하나여야 합니다. 이것은 클래스가 한 가지 작업 또는 책임만 가지도록 해야 한다는 의미입니다.\n- 예시: User 클래스가 있을 때, 해당 클래스는 사용자와 직접 관련된 것만 책임져야 합니다. 예를 들어 데이터베이스에서 사용자 데이터를 로드하는 것은 해당 클래스가 담당하면 안됩니다. 별도의 UserRepository 클래스가 해당 책임을 져야 합니다.\n- OCP(Open-Closed Principle): 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 열려 있어야 하지만 수정에는 닫혀 있어야 합니다. 이것은 기존 코드를 수정하지 않고 새로운 기능을 추가할 수 있어야 한다는 것을 의미합니다.\n- 예시: Shape 클래스가 있고 새로운 모양을 추가하려는 경우, Shape를 상속하는 새 클래스를 추가함으로써 Shape 클래스나 기존 클래스를 수정하지 않고도 가능해야 합니다.\n- LSP(Liskov Substitution Principle): 하위 유형은 상위 유형으로 대체 가능해야 합니다. 이것은 프로그램이 기본 클래스를 사용하고 있을 때 하위 클래스를 사용할 수 있어야 하며, 프로그램이 오류 없이 작동해야 한다는 것을 의미합니다.\n- 예시: Bird 클래스에 fly() 메서드가 있는 경우 Bird를 상속하는 Penguin 클래스는 fly() 메서드를 지원하지 않는다면 LSP를 위반하고 있습니다. 해결책으로는 비행하는 새들을 위한 별도의 FlyingBird 클래스를 만드는 것이 될 수 있습니다.\n- ISP(Interface Segregation Principle): 클라이언트는 사용하지 않는 인터페이스에 의존하도록 강요되어서는 안 됩니다. 이는 클래스가 사용하지 않는 메서드를 구현할 필요가 없어야 한다는 것을 의미합니다.\n- 예시: IPrinter 인터페이스에 print(), fax(), scan() 메서드가 있고, SimplePrinter 클래스가 인쇄만 지원하는 경우 ISP를 위반하고 있습니다. 해결책으로는 IPrinter, IFax, IScanner에 대한 별도의 인터페이스를 만드는 것이 될 수 있습니다.\n- DIP(Dependency Inversion Principle): 고수준 모듈은 저수준 모듈에 의존해서는 안 됩니다. 둘 다 추상화에 의존해야 합니다. 이는 구현이 아니라 추상화에 의존해야 한다는 의미입니다.\n- 예시: NotificationService 클래스가 직접 EmailService 클래스를 사용하여 이메일을 보내는 경우 DIP를 위반하고 있습니다. 해결책으로는 EmailService가 구현하는 IMessageService 인터페이스를 사용하고, NotificationService는 EmailService보다는 IMessageService에 의존해야 합니다.\n\n이 원칙들은 지침이며 엄격한 규칙은 아닙니다. 다른 목표를 달성하기 위해 원칙을 위반하는 것이 합리적인 경우도 있을 수 있습니다. 그러나 이러한 원칙을 이해하면 더 유지보수 가능하고 확장 가능한 소프트웨어를 설계하는 데 도움이 될 거예요.\n\nJava 8에서는 특히 java.util.function, java.util.stream, java.time 패키지에서 새로운 클래스와 인터페이스가 소개되었습니다. 여기에 중요한 것들이 몇 가지 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- java.util.function 패키지의 함수형 인터페이스:\n\n  - Predicate`T`\n  - Function`T,R`\n  - Consumer`T`\n  - Supplier`T`\n  - UnaryOperator`T`\n  - BinaryOperator`T`\n\n- java.util.stream 패키지의 Stream API 클래스 및 인터페이스:\n\n  - Stream`T`\n  - IntStream\n  - LongStream\n  - DoubleStream\n  - Collector`T,A,R`\n  - Collectors\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\njava.time 패키지의 Date and Time API 클래스:\n\n- LocalDate\n- LocalTime\n- LocalDateTime\n- ZonedDateTime\n- Period\n- Duration\n- Instant\n- ZoneId\n\njava.util 패키지의 Optional 클래스:\n\n- Optional`T`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\njdk.nashorn.api.scripting 패키지에 새로운 JavaScript 엔진 클래스가 추가되었습니다:\n\n- NashornScriptEngineFactory\n\n이러한 새로운 클래스와 인터페이스는 함수형 프로그래밍, 스트림 처리 및 개선된 날짜 및 시간 API와 같은 강력한 새로운 기능을 제공합니다.\n\nwait() 및 join()은 자바의 멀티스레딩에서 사용되는 두 가지 메서드로, 각각 다른 목적을 제공합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- wait(): 이 메서드는 Object 클래스에 정의되어 있으며 스레드 간 통신에 사용됩니다. 스레드가 wait()를 호출하면 휴면 상태로 들어가며 개체에 보유한 락을 해제하여 다른 스레드가 락을 가져가고 고유한 중요한 부분을 실행할 수 있도록 합니다. 해당 스레드는 같은 개체에 대해 notify() 또는 notifyAll()이 호출될 때까지 대기 상태에 머무릅니다.\n\n예시:\n\n```js\nsynchronized(object) {\n    while(\u003c조건이 참이 아닌 동안\u003e)\n        object.wait();\n    // 로직 처리\n}\n```\n\njoin(): 이 메서드는 Thread 클래스에 정의되어 있으며 현재 스레드를 지정된 스레드가 종료될 때까지 일시 정지시키는 데 사용됩니다. 즉, 스레드 A가 스레드 B에 대해 join()을 호출하면 A는 B가 실행을 완료할 때까지 기다립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```java\nThread t1 = new Thread(new MyRunnable());\nt1.start();\ntry {\n    t1.join();\n} catch (InterruptedException e) {\n    Thread.currentThread().interrupt();\n}\n// t1이 종료될 때까지 logic 계속 진행\n```\n\n요약하면, wait()은 스레드 간 통신에 사용되며 객체의 잠금을 해제하며, join()은 스레드가 종료될 때까지 기다리는 데 사용되며 어떤 잠금도 해제하지 않습니다.\n\n만약 해당 객체에 대해 동기화를 먼저 실행하지 않고 객체에 대해 wait()를 호출하는 경우, 런타임에 IllegalMonitorStateException이 발생합니다. 이는 wait(), notify(), notifyAll() 메서드가 동기화를 달성하도록 설계되어 다중 스레드 환경에서 사용되며, synchronized 컨텍스트 내에서만 호출할 수 있기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요기에는 Java 문서에 대한 wait() 메서드 설명이 있어요:\n\n현재 스레드는 이 객체의 모니터를 소유해야 합니다. 스레드는 이 모니터의 소유권을 해제하고 이 객체의 모니터에서 대기 중인 스레드를 깨우기 위해 notify() 메서드 또는 notifyAll() 메서드를 호출하여 다른 스레드에 의해 깨어날 때까지 기다립니다. 그럼 스레드는 다시 모니터의 소유권을 재획득할 때까지 대기하고 실행을 다시 시작합니다.\n\n따라서 객체에 대해 작동 중인 4개의 스레드가 있고 synchronized 블록이나 메서드 없이 wait()를 호출하면 IllegalMonitorStateException이 발생합니다.\n\n또한, notify() 또는 notifyAll()을 호출하지 않는 경우, 객체에서 대기 중인 스레드는 깨우기 위한 통지할 것이 없기 때문에 대기 상태에 계속 남게 됩니다. 이는 스레드가 영원히 대기하는 상황을 초래할 수 있으며, 이를 스레드 기아라고 일컫는 경우가 많습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSpring Framework과 Spring Boot은 모두 엔터프라이즈급 애플리케이션을 구축하는 데 사용되는 Java 프레임워크입니다. 두 프레임워크는 관련이 있지만 다른 목적을 가지고 있습니다.\n\nSpring Framework: 이는 Java 애플리케이션을 구축하는 데 사용되는 포괄적인 프레임워크입니다. 의존성 주입, 관점 지향 프로그래밍, 데이터 액세스, 트랜잭션 관리, 웹 애플리케이션을 위한 MVC 등 다양한 기능을 제공합니다. 그러나 Spring Framework를 사용하여 프로젝트를 설정하는 것은 많은 구성을 수동으로 처리해야 하기 때문에 복잡할 수 있습니다.\n\nSpring Boot: 이는 Spring Framework 위에 구축된 프로젝트입니다. Spring 애플리케이션의 설정 및 개발을 단순화시켜 코드 구성에 대한 기본값을 제공하고, Spring 애플리케이션을 실행시키기 위해 필요한 노력을 줄입니다. 또한 스탠드얼론 서버 (Tomcat, Jetty 또는 Undertow)를 제공하여 Spring 애플리케이션을 직접 메인 메서드에서 실행할 수 있고, 애플리케이션 배포 및 모니터링을 단순화하기 위한 많은 추가 기능을 제공합니다.\n\n이것이 주요한 차이점입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설정: 스프링은 설정을 위해 많은 수동 구성이 필요합니다. 그러나 스프링 부트는 이 복잡성을 줄이기 위해 자동 구성을 제공합니다.\n- 프로젝트 설정: 스프링에서 프로젝트를 설정하는 것은 약간 복잡할 수 있으며 내부 동작에 대한 깊은 이해가 필요합니다. 스프링 부트는 Spring Initializr 웹 기반 프로젝트 생성기를 통해 이 과정을 쉽게 만듭니다.\n- 독립형: 스프링 부트 애플리케이션은 내장 서버가 포함된 jar로 패키징할 수 있습니다. 기존의 스프링 MVC 애플리케이션에서는 애플리케이션을 별도 서버에 배포해야 합니다.\n- 의존성 관리: 스프링 부트는 starter POMs 기능을 제공하여 Maven 구성 및 의존성 관리를 간소화합니다.\n- 프로덕션 준비: 스프링 부트는 상자에서 건강 상태 확인 및 메트릭과 같은 기능을 기본 제공하여 프로덕션 환경에 적합합니다.\n\n만약 Employee 클래스의 hashCode() 메서드가 항상 같은 값을 반환한다면, 데이터를 잃거나 잘못된 결과를 얻는 것은 아닙니다. 그러나 해시 기반의 컬렉션인 HashMap, HashSet 등의 성능이 저하될 수 있습니다.\n\n이것이 그 이유입니다:\n\n예를 들어 HashMap에서 hashCode()는 키-값 쌍을 저장해야 하는 버킷을 결정하는 데 사용됩니다. 만약 모든 키에 동일한 해시 코드가 있는 경우, 모두 동일한 버킷에 들어가게 됩니다. 이로 인해 HashMap은 성능 측면에서 연결 목록으로 변하게 되며, 모든 항목이 해당 단일 버킷의 노드 체인으로 저장됩니다. 이는 모든 조회, 삽입 또는 삭제가 모든 항목을 선형 검색해야 하므로 매우 비효율적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n객체를 HashMap의 키로 사용할 때는 hashCode()와 equals() 메서드를 올바르게 재정의해야 합니다. hashCode() 메서드는 키를 버킷에 고르게 분배하여 성능을 향상시키는 데 중요하며, equals()는 키의 동등성을 결정하는 데 사용됩니다.\n\n따라서 동일한 해시코드를 반환하더라도 데이터 손실이나 잘못된 결과는 발생하지 않지만, 해시 기반 컬렉션을 사용할 때 성능이 저하될 수 있습니다.\n\n애플리케이션의 성능을 최적화하는 데 몇 가지 단계가 포함됩니다:\n\n- 프로파일링: 애플리케이션의 병목 현상을 식별합니다. CPU 사용량, 메모리 누수, 느린 데이터베이스 쿼리 등이 포함될 수 있습니다. VisualVM, JProfiler 또는 YourKit과 같은 도구를 사용하여 Java 애플리케이션을 프로파일링할 수 있습니다.\n- 코드 최적화: 비효율적인 코드를 찾아 최적화합니다. 이는 더 효율적인 데이터 구조 사용, 알고리즘의 시간 복잡도 감소, 데이터베이스 호출 감소 등을 포함할 수 있습니다.\n- 동시성: 적절한 곳에서 멀티스레딩을 사용하여 여러 코어를 활용하고 작업을 병렬로 수행합니다.\n- 캐싱: 비싼 작업의 결과를 저장하기 위해 캐싱을 구현하여 같은 입력이 다시 발생할 때 반복을 피합니다.\n- 데이터베이스 최적화: 데이터베이스 쿼리를 최적화하고 인덱싱을 사용하며 필요에 따라 정규화 또는 비정규화를 수행합니다.\n- 최신 라이브러리/프레임워크 사용: 일반적으로 성능 향상이 있는 최신 라이브러리나 프레임워크를 사용하도록 항상 노력해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쓰레드 덤프를 가져오려면:\n\n- jstack: 이것은 JDK와 함께 제공되는 명령줄 유틸리티입니다. 실행 중인 Java 애플리케이션의 쓰레드 덤프를 가져 오는 데 사용할 수 있습니다. 명령어는 jstack `pid`이며 여기서 pid는 Java 애플리케이션의 프로세스 ID입니다.\n- VisualVM: 이것은 실행 중인 Java 애플리케이션을 모니터링하는 데 사용할 수있는 그래픽 도구입니다. 또한 쓰레드 덤프를 가져 오는 데도 사용할 수 있습니다.\n- JConsole: 이것은 JDK와 함께 제공되는 또 다른 그래픽 도구입니다. 실행 중인 Java 애플리케이션을 모니터링하고 쓰레드 덤프를 가져 오는 데 사용할 수 있습니다.\n\nJava 8에서 \"스트림\"이라는 용어는 일반적으로 java.util.stream 패키지에 소개 된 새로운 추상화를 가리킵니다. 이를 사용하여 요소 스트림에 대해 함수 스타일 작업을 수행할 수 있습니다. Stream API는 객체 컬렉션을 처리하는 데 사용됩니다. 스트림은 다양한 메서드를 지원하는 객체 시퀀스로, 원하는 결과를 생성하는 데 파이프라인으로 연결될 수 있습니다.\n\nJava 8에서 사용할 수있는 세 가지 유형의 스트림이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Sequential Stream: 순차 스트림은 단일 파이프라인을 갖고 있으며 요소를 순차적으로만 처리할 수 있습니다. stream() 메서드를 호출할 때 기본적으로 생성됩니다.\n\n```java\nList\u003cString\u003e list = Arrays.asList(\"A\", \"B\", \"C\");\n\nStream\u003cString\u003e stream = list.stream();\n```\n\n- Parallel Stream: 병렬 스트림은 여러 파이프라인을 가지고 있어 요소를 병렬로 처리할 수 있습니다. 멀티코어 머신에서 대용량 데이터셋에 대해 순차 스트림보다 빠를 수 있습니다. parallelStream() 메서드를 호출할 때 생성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nList\u003cString\u003e list = Arrays.asList(\"A\", \"B\", \"C\");\n\nStream\u003cString\u003e parallelStream = list.parallelStream();\n\nInfinite Stream: These are streams that don’t have a fixed size, as in they can keep on growing. The Stream.iterate and Stream.generate methods can be used to create infinite streams.\n\nStream\u003cInteger\u003e infiniteStream = Stream.iterate(0, i -\u003e i + 2);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 유형의 스트림은 다른 종류의 작업을 위해 설계되었습니다. 연속 및 병렬 스트림은 일반적으로 유한한 수의 요소와 함께 사용되며, 무한 스트림은 필요할 때 값 시퀀스를 생성하는 데 사용됩니다.\n\n만약 t가 현재 실행 중인 스레드를 가진 Thread 객체라면, t.join()은 현재 스레드가 t의 스레드가 종료될 때까지 실행을 일시 중지시킵니다.\n\n다음은 간단한 예제입니다:\n\n```js\nThread t1 = new Thread(new MyRunnable());\nt1.start();\ntry {\nt1.join(); // 현재 스레드는 t1이 실행을 완료할 때까지 기다립니다\n} catch (InterruptedException e) {\nThread.currentThread().interrupt();\n}\n// t1의 실행이 완료된 후 로직 계속 수행\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예에서 현재 스레드는 t1이 실행을 마칠 때까지 기다립니다. 이는 다른 스레드를 시작하여 일부 작업을 수행하고 그 결과가 필요한 경우에 유용할 수 있습니다.\n\n또한 join()에 대한 오버로드된 버전이 있으며, 다른 스레드가 작업을 완료할 때까지 기다리기 원하는 최대 시간을 지정할 수 있습니다:\n\n- join(long millis) 이 스레드가 종료될 때까지 millis 밀리초만큼 기다립니다.\n- join(long millis, int nanos) 이 스레드가 종료될 때까지 millis 밀리초와 nanos 나노초만큼 최대 기다립니다.\n\n만약 지정된 시간 내에 스레드가 작업을 완료하지 않으면, join() 호출은 어쨌든 반환되고 현재 스레드는 실행을 계속합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바 7에서 소개된 Objects 클래스는 객체를 다루는 정적 메서드를 제공하는 유틸리티 클래스입니다. 이 유틸리티에는 객체의 해시 코드를 계산하는 데 사용되는 null-안전 혹은 null-허용 메서드, 객체에 대한 문자열을 반환하는 메서드, 두 객체를 비교하는 메서드 등이 포함되어 있습니다.\n\n다음은 Objects 클래스에서 자주 사용되는 메서드 몇 가지입니다:\n\nequals(Object a, Object b): 두 개체가 equals() 메서드에 따라 동일한지 확인합니다. 이 메서드는 null-안전입니다. 즉, 두 개체가 모두 null이면 true를 반환하고, 하나는 null이면 false를 반환합니다.\n\nObjects.equals(“test”, new String(“test”)); // true를 반환\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nObjects.equals(null, \"test\"); // false 반환\n\nObjects.equals(null, null); // true 반환\n\nhashCode(Object o): null이 아닌 인수의 해시 코드를 반환하고, null 인수의 경우 0을 반환합니다. null 안전 해시 코드 계산에 유용합니다.\n\nObjects.hashCode(null); // 0 반환\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nObjects.hashCode(\"test\"); // 문자열 \"test\"의 해시 코드를 반환합니다.\n\ntoString(Object o): null이 아닌 인수에 대해 toString을 호출한 결과를 반환하고, null 인수에 대해 \"null\"을 반환합니다.\n\nObjects.toString(null); // \"null\"을 반환합니다.\n\nObjects.toString(\"test\"); // \"test\"를 반환합니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nrequireNonNull(T obj): 지정된 객체 참조가 null이 아닌지 확인합니다. 이 방법은 주로 메서드 및 생성자에서 매개변수 유효성을 검사하기 위해 설계되었습니다.\n\nObjects.requireNonNull(null); // NullPointerException 발생\n\nObjects.requireNonNull(\"test\"); // \"test\" 반환\n\ncompare(T a, T b, Comparator`? super T` c): 지정된 Comparator로 두 객체를 비교하며, null에 안전합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`Objects` 클래스는 null-안전한 메소드를 제공하여 더 깨끗하고 견고한 코드를 작성하는 데 도움이 됩니다.\n\n`flat` 및 `flatMap`은 데이터의 컬렉션이나 스트림에서 사용되는 연산입니다. 그들 사이의 차이점은 중첩 구조물을 어떻게 처리하는지에 있습니다.\n\n- Flat: `flat` 연산(Java에는 없지만 다른 언어에는 존재)은 일반적으로 여러 단계로 중첩되어 있는 구조를 하나의 단계로 줄이는 작업을 합니다. 구조를 한 단계 평준화합니다. 예를 들어, 리스트의 리스트가 있다면, `flat` 연산은 모든 내부 리스트 요소를 포함하는 단일 리스트를 제공합니다.\n- FlatMap: `flatMap` 연산은 `map` 및 `flat` 연산의 조합입니다. 먼저 구조 안의 각 요소에 함수를 적용하고 결과를 평준화합니다. 이는 각 요소에 적용할 함수가 컬렉션이나 스트림을 생성할 때 유용합니다.\n\n여기 Java에서의 예시입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nList\u003cString\u003e list = Arrays.asList(\"Hello World\", \"Java Stream\");\n// map 작업\nList\u003cString[]\u003e mapResult = list.stream()\n.map(s -\u003e s.split(\" \"))\n.collect(Collectors.toList());\n// flatMap 작업\nList\u003cString\u003e flatMapResult = list.stream()\n.flatMap(s -\u003e Arrays.stream(s.split(\" \")))\n.collect(Collectors.toList());\n```\n\n이 예제에서 map 작업은 각 문자열을 단어 배열로 분할하여 List`String[]`을 생성합니다. flatMap 작업은 각 문자열을 단어로 분할하지만 결과를 List`String`으로 평평하게 만들어 각 단어가 개별 요소로 있는 List를 생성합니다.\n\n따라서 flatMap의 주요 차이점은 스트림의 각 요소를 여러 요소로 변환하거나(또는 전혀 변환하지 않는 상황) 평면적인 결과 스트림으로 종료하고 중첩 구조가 아닌 결과 내용을 얻고 싶을 때 사용할 수 있다는 것입니다.\n\n자바에서 java.util.concurrent 패키지는 멀티스레딩에 유용한 여러 유형의 블로킹 큐를 제공합니다. 블로킹 큐는 큐가 비어 있고 Dequeue하려고 하면 블로킹되거나, 큐가 이미 가득 차있고 Enqueue하려고 하면 블로킹되는 큐입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바에서 사용되는 블로킹 큐의 종류는 다음과 같아요:\n\n- ArrayBlockingQueue: 배열을 기반으로 하는 유계된 블로킹 큐이에요. 이 큐는 FIFO(먼저 들어온 것이 먼저 나가는) 순서로 요소들을 처리해요. '유계된'이란 큐가 고정된 수의 요소를 초과해서 저장할 수 없다는 것을 의미해요.\n\n- LinkedBlockingQueue: 링크드 노드를 기반으로 하는 선택적으로 유계된 블로킹 큐예요. 선택적 용량 제한 생성자 인수는 큐가 너무 많이 확장되는 것을 방지하기 위한 방법으로 사용돼요. 용량 제한이 없으면 연결된 큐는 일반적으로 배열 기반 큐보다 더 많은 요소를 보관해요.\n\n- PriorityBlockingQueue: PriorityQueue 클래스와 동일한 규칙을 사용하며 블로킹 검색 작업을 지원하는 무제한 블로킹 큐에요. 이 큐는 논리적으로는 무제한이지만 리소스 고갈로 인해 추가가 실패할 수도 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDelayQueue: 지연된 요소들의 무한 대기 큐로, 요소의 지연이 만료되었을 때에만 요소를 가져올 수 있습니다.\n\nSynchronousQueue: 각 삽입 작업은 다른 스레드에 의한 해당 제거 작업을 기다려야 하며, 그 반대도 마찬가지입니다. 동기식 큐는 내부 용량을 가지지 않으며, 하나의 용량조차도 없습니다.\n\nLinkedTransferQueue: 링크된 노드를 기반으로 한 무한 TransferQueue입니다. 이 큐는 어떤 생성자에 대해선 FIFO(먼저 들어온 것이 먼저 나가는) 순서로 요소를 정렬합니다.\n\nLinkedBlockingDeque: 링크된 노드를 기반으로 한 선택적으로 유한한 블로킹 덱입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 종류의 블로킹 큐는 다중 스레드 프로그래밍에서 작업 요구 사항에 따라 고유한 사용 사례를 갖습니다.\n\n# 읽어 주셔서 감사합니다\n\n- 👏 이야기에 박수를 보내고 저를 팔로우해주세요 👉\n- 📰 미디엄에서 더 많은 콘텐츠를 읽어보세요 (자바 개발자 인터뷰에 관한 60편의 이야기)\n\n제 책은 여기서 찾아볼 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 아마존에서 이 책을 구입하여 기본 Java 개발자 인터뷰를 준비하세요 (킨들북).\n- Gumroad에서 PDF 형식으로 Spring-Boot Microservice 인터뷰를 준비하는 방법 안내서를 확인하세요.\n- Gumroad (PDF 형식) 및 아마존 (킨들 eBook)에서 Spring-Boot Microservice 인터뷰를 준비하는 방법 안내서를 확인하세요.\n- 🔔 저를 팔로우하세요: LinkedIn | Twitter | Youtube\n","ogImage":{"url":"/assets/img/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp_0.png"},"coverImage":"/assets/img/2024-06-23-SynechronJavaInterviewQuestionsandanswersfor24Exp_0.png","tag":["Tech"],"readingTime":21},{"title":"Swift에서 부분 적용 함수 사용하는 방법","description":"","date":"2024-06-23 01:50","slug":"2024-06-23-PartiallyAppliedFunctionsinSwift","content":"\nSwift에서 부분 적용 함수는 일부 매개변수로 호출된 함수를 의미합니다. 이는 남은 매개변수를 입력으로 받는 새로운 함수를 만듭니다.\n\n# 부분 적용 함수 예시:\n\nSwift에서 간단한 함수를 고려해보겠습니다:\n\n```swift\nfunc multiply(_ a: Int, _ b: Int) -\u003e Int {\n return a * b\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 기능을 만들고 싶다면 항상 2배를 곱하는 함수를 부분적용할 수 있습니다.\n\n```js\nlet multiplyByTwo = multiply(2, _);\n```\n\n이제 `multiplyByTwo`는 하나의 매개변수를 받는 함수입니다.\n\n```js\nlet result = multiplyByTwo(5); // 결과는 10\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Swift 컴파일러가 부분 적용 함수를 사용하는 이유는 무엇인가요?\n\n부분 적용 함수는 여러 이유로 유용합니다:\n\n1. 코드 재사용성: 일반적인 함수에서 더 구체적인 함수를 다시 작성하지 않고 만들 수 있어 더 모듈식이고 재사용 가능한 코드를 작성할 수 있습니다.\n\n2. 함수형 프로그래밍: 부분 적용 함수는 함수형 프로그래밍의 핵심이며 함수를 일급 시민으로 사용하는 함수형 프로그래밍 패러다임을 강조합니다. Swift는 함수형 프로그래밍 패러다임을 지원하며, 부분 적용 함수는 고차 함수를 만드는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 클로저 간소화: 클로저 생성을 간단하게 해줍니다. 전체 클로저를 작성하는 대신 부분 적용을 사용하여 더 간결한 효과를 얻을 수 있습니다.\n\n4. 가독성 향상: 중복을 줄임으로써 코드를 더 읽기 쉽게 만들어줍니다. 공통 매개변수로 반복적으로 동일한 함수 호출을 작성하는 대신, 부분 적용된 함수를 만들 수 있습니다.\n\n# 예시 문맥 안에서\n\n다음은 더 포괄적인 예시입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러분이 수를 담은 리스트가 있고 짝수를 필터링하고 싶다면 부분적용 함수를 사용할 수 있습니다.\n\n```js\nlet numbers = [1, 2, 3, 4, 5, 6]\nfunc isDivisibleBy(_ divisor: Int, _ number: Int) -\u003e Bool {\n return number % divisor == 0\n}\nlet isEven = isDivisibleBy(2, _:)\nlet evenNumbers = numbers.filter(isEven)\n// evenNumbers will be [2, 4, 6]\n```\n\n이 예제에서 `isDivisibleBy`가 부분적용으로 `isEven`을 만들어 배열을 필터링하는 데 사용되는 것을 볼 수 있습니다.\n\n# 컴파일러가 부분적용 함수를 사용하는 방법\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nThe Swift 컴파일러는 여러 가지 이유로 부분 적용 함수를 사용할 수 있습니다:\n\n1. 최적화: 컴파일러는 부분 적용 함수를 최적화하여 성능을 향상시킬 수 있으며, 특히 고계 함수와 클로저가 포함된 시나리오에서 유용합니다.\n\n2. 유형 추론: Swift의 유형 추론 시스템은 부분 적용 함수를 효과적으로 처리하여 명시적 유형 주석의 필요를 줄이고 코드를 더 깔끔하게 만들 수 있습니다.\n\n3. 중간 표현: 컴파일 중에 부분 적용 함수는 코드의 변환과 최적화를 단순화하는 중간 표현으로 사용될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 기능적 패러다임: Swift는 객체지향 및 함수형 프로그래밍 패러다임을 모두 지원합니다. 부분 함수 적용은 함수형 프로그래밍에 자연스럽게 적합하며 사용하면 더 표현력이 풍부하고 간결한 코드를 작성할 수 있습니다.\n\n# Swift 컴파일러와 부분 함수 적용\n\nSwift 컴파일러는 고수준 추상화 및 효율적인 최적화 처리를 수행할 수 있도록 설계되었습니다. 부분 함수 적용은 컴파일러가 성능을 향상시키고 코드 관리를 용이하게 하는 데 활용할 수 있는 핵심 기능입니다.\n\n## 1. 중간 표현들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스위프트 코드를 작성할 때, 스위프트 컴파일러는 중간 표현 (IR)으로 번역합니다. 부분 적용된 함수는 이 중간 형태로 표현될 수 있어, 컴파일러가 쉽게 최적화를 수행할 수 있습니다.\n\n- 함수 커링: 함수형 프로그래밍에서 커링은 여러 인수를 갖는 함수를 하나의 인수로 있는 각각의 함수의 순서로 변환하는 것입니다. 스위프트 컴파일러는 함수 호출을 최적화하기 위해 자동으로 커링을 적용할 수 있습니다.\n- 람다 리프팅: 이 기술은 중첩 함수를 추가 매개변수를 갖는 최상위 함수로 변환하는 것을 포함합니다. 부분적으로 적용된 함수를 최상위 엔티티로 표현함으로써, 컴파일러가 더 잘 관리하고 최적화할 수 있습니다.\n\n이제 스위프트에서 함수 커링과 람다 리프팅의 예를 살펴보겠습니다.\n\n함수 커링\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n커링은 여러 인수를 사용하는 함수를 한 인수를 사용하는 함수의 시퀀스로 변환하는 과정입니다. 이 기술은 더 유연하고 재사용 가능한 코드를 작성하는 함수형 프로그래밍에서 유용하게 활용됩니다.\n\n## 스위프트에서 함수 커링 예제\n\n두 정수를 더하는 간단한 함수로 시작해보겠습니다:\n\n```js\nfunc add(_ a: Int, _ b: Int) -\u003e Int {\n return a + b\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 함수를 커리한 버전으로 변환할 수 있습니다:\n\n```swift\nfunc curriedAdd(_ a: Int) -\u003e (Int) -\u003e Int {\n    return { b in\n        return a + b\n    }\n}\n```\n\n이제 `curriedAdd`는 정수 `a`를 받아 정수 `b`를 받고 `a`와 `b`의 합을 반환하는 새 함수를 반환하는 함수입니다.\n\n## 사용법:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet addFive = curriedAdd(5); // addFive은 이제 함수(Int) -\u003e Int입니다.\nlet result = addFive(3); // 결과는 8입니다.\n```\n\n직접 사용할 수도 있습니다:\n\n```js\nlet resultDirect = curriedAdd(5)(3); // resultDirect는 8입니다.\n```\n\n## 람다 리프팅\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n람다 끌어올리기는 중첩 함수(람다)를 추가 매개변수를 가진 최상위 함수로 변환하는 프로세스입니다. 이 변환은 함수가 주변 컨텍스트와 독립적이 되도록 만듭니다.\n\n## Swift에서 람다 끌어올리기 예제\n\n중첩 함수(클로저)가 있는 함수로 시작해봅시다:\n\n```js\nfunc outerFunction(_ x: Int) -\u003e Int {\n func innerFunction(_ y: Int) -\u003e Int {\n return x + y\n }\n return innerFunction(5)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서 `innerFunction`은 `outerFunction` 내에 중첩되어 있으며 변수 `x`에 의존합니다.\n\n## 람다 릴팅 변환\n\n`innerFunction`을 최상위 수준으로 이동시키려면 명시적 매개변수로 `x`를 추가해야 합니다:\n\n```js\nfunc liftedInnerFunction(_ x: Int, _ y: Int) -\u003e Int {\n return x + y\n}\nfunc outerFunction(_ x: Int) -\u003e Int {\n return liftedInnerFunction(x, 5)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 `liftedInnerFunction`은 주변 컨텍스트의 변수에 의존하지 않는 최상위 함수입니다.\n\n## 사용법:\n\n```js\nlet result = outerFunction(3); // result is 8\n```\n\n`innerFunction`을 최상위 수준으로 올리면 더 재사용 가능하고 더 이해하기 쉬워지며, 더 이상 둘러싸는 함수의 상태에 의존하지 않게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 인라인 처리와 특수화\n\nSwift 컴파일러는 부분적으로 적용된 함수를 인라인 처리하여 함수 호출을 함수의 본문으로 대체할 수 있습니다. 이는 함수 호출의 오버헤드를 줄이고 성능을 크게 향상시킬 수 있습니다.\n\n- 함수 인라인 처리: 부분적으로 적용된 함수가 인라인 처리될 때 컴파일러는 중간 클로저를 생성할 필요 없이 함수의 로직을 직접 해당 위치에 삽입할 수 있습니다.\n- 특수화: 컴파일러는 특정 유형이나 매개변수 값에 대해 함수의 특수화된 버전을 생성할 수 있습니다. 이는 특히 부분적으로 적용된 함수에 유용하며, 컴파일러가 가장 일반적인 사용 사례에 최적화할 수 있게 합니다.\n\n함수 인라인 처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수 인라인은 컴파일러가 함수 호출을 해당 함수의 실제 코드로 대체하는 최적화 기술입니다. 이는 레지스터의 저장 및 복원과 같은 함수 호출과 관련된 오버헤드를 제거할 수 있으며, 컴파일러에 의해 추가적인 최적화를 가능하게 할 수 있습니다.\n\n인라인은 작고 빈번히 호출되는 함수에 특히 유용합니다.\n\n예시\n\n다음과 같은 간단한 함수를 고려해보세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunc add(_ a: Int, _ b: Int) -\u003e Int {\n return a + b\n}\n```\n\n이 함수를 호출하면:\n\n```js\nlet result = add(2, 3);\n```\n\n컴파일러는 이 호출을 함수의 본문으로 대체할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet result = 2 + 3;\n```\n\n이렇게 하면 함수 호출의 오버헤드를 제거할 수 있어요.\n\n## `@inline(__always)`를 사용한 명시적 인라인화\n\nSwift에서는 `@inline(__always)` 속성을 사용하여 항상 함수를 인라인으로 처리하도록 컴파일러에 제안할 수 있어요. 이는 성능에 중요한 코드에 유용할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\n@inline(__always)\nfunc multiply(_ a: Int, _ b: Int) -\u003e Int {\n return a * b\n}\n```\n\n사용 방법:\n\n```swift\nlet result = multiply(4, 5)\n```\n\n여기서 컴파일러는 `multiply`를 인라인으로 권장받아 호출을 효과적으로 다음과 같이 대체합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet result = 4 * 5;\n```\n\n## 인라인 사용 시기 및 이유\n\n- 성능: 인라인은 함수 호출 오버헤드를 제거하고 추가적인 컴파일러 최적화를 가능하게 함으로써 성능을 향상시킬 수 있습니다.\n\n- 작은 함수: 작고 자주 호출되는 함수는 인라인에 적합한 후보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 중요한 경로: 매 밀리초가 소중한 성능에 영향을 미치는 코드 경로에서는 인라인화가 유익할 수 있습니다.\n\n그러나 지나치게 많은 인라인화는 이진 크기가 크게 증가하여 캐시 미스와 증가된 메모리 사용량으로 인한 성능 저하를 초래할 수 있습니다. 따라서, 인라인화를 분별하여 사용하는 것이 중요합니다.\n\n## 인라인화에 대한 컴파일러 결정\n\nSwift 컴파일러는 함수를 인라인으로 처리할지 여부를 결정하는데 여러 가지 휴리스틱을 사용합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 기능 크기: 작은 함수는 큰 함수보다 인라인화될 가능성이 높습니다.\n- 호출 빈도: 자주 호출되는 함수는 오버헤드를 줄이기 위해 인라인화될 수 있습니다.\n- 복잡성: 간단한 논리를 가진 함수는 인라인화하기에 적합합니다.\n- 주석: `@inline(__always)` 또는 `@inline(never)`와 같은 속성은 인라인화 결정에 대한 힌트를 컴파일러에 제공합니다.\n\n예시\n\n주어진 함수를 배열의 각 요소에 적용하는 고차 함수를 고려해보세요:\n\n```js\nfunc applyToEach(_ array: [Int], _ transform: (Int) -\u003e Int) -\u003e [Int] {\n return array.map { transform($0) }\n}\n@inline(__always)\nfunc increment(_ x: Int) -\u003e Int {\n return x + 1\n}\nlet numbers = [1, 2, 3, 4]\nlet incrementedNumbers = applyToEach(numbers, increment)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인라인 없이:\n\n`applyToEach` 함수는 배열의 각 요소마다 `increment`를 호출하여 여러 함수 호출을 발생시킵니다.\n\n인라인 사용:\n\n컴파일러는 `increment`를 인라인으로 처리하여 함수 호출 대신 `map` 클로저 내에서 증가 연산을 바로 수행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nlet incrementedNumbers = numbers.map { $0 + 1 }\n```\n\n함수 호출 오버헤드를 제거하고 더 효율적인 코드를 만들 수 있습니다.\n\n## 3. 클로저 최적화\n\n부분적으로 적용된 함수는 클로저와 밀접한 관련이 있습니다. Swift 컴파일러는 부분적으로 적용된 함수에 이로운 여러 전략을 사용하여 클로저를 최적화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 스택 할당: 클로저(또는 부분 적용 함수)가 정의된 범위에서 벗어나지 않는다면, 컴파일러는 메모리 할당 오버헤드를 줄이기 위해 힙 대신 스택에 할당할 수 있습니다. 이것은 클로저에 `@escaping` 속성을 사용하여 직접 제어할 수 있습니다.\n- 컨텍스트 캡처: 컴파일러는 클로저가 캡처하는 변수를 분석하고 이러한 변수의 저장을 최적화하여 캡처 및 컨텍스트 저장의 오버헤드를 최소화합니다.\n\n## 4. 타입 추론 및 제네릭 함수\n\nSwift의 강력한 타입 추론 시스템은 부분 적용 함수와 원활하게 작동하여 명시적인 타입 주석이 필요 없이 코드를 더 간결하게 만듭니다.\n\n- 제네릭 함수: 컴파일러는 부분 적용 함수를 사용하여 제네릭 처리를 더 효과적으로 다룰 수 있으며, 사용되는 맥락에 기반하여 함수의 타입을 추론하고 특수화된 버전을 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 애플의 공식 설명\n\n애플의 공식 Swift 문서는 클로저와 부분 적용 함수를 포함한 함수형 프로그래밍 패러다임을 강조합니다. 다음은 애플의 문서와 관련 자료에서 주요한 내용들입니다:\n\n- 클로저: 애플은 클로저를 자체 포함된 기능 블록으로 설명하며, 변수와 상수에 대한 참조를 캡처하고 저장할 수 있는 기능입니다. 부분 적용 함수는 일부 매개변수가 고정된 클로저의 특수한 경우입니다.\n- 함수형 프로그래밍: Swift는 함수형 프로그래밍 방식을 장려하며, 부분 적용 함수는 이 방식에 중요한 역할을 합니다. 애플의 문서는 Swift의 함수 유형과 1급 함수가 유연하고 표현력 있는 코드를 가능하게 한다는 점을 강조합니다.\n- 최적화 기법: 사용자에게 명시적으로 자세히 설명되지는 않지만, 백그라운드에서 컴파일러 최적화 기능을 통해 언어의 고급 기능을 활용합니다. 이는 인라인 최적화, 제네릭 특수화, 효율적인 클로저 처리 등을 포함합니다.\n\n# 애플 문서 예시\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플의 Swift 문서에서 간단한 map 함수 예제를 살펴보겠습니다:\n\n```js\nlet numbers = [1, 2, 3, 4]\nlet doubled = numbers.map { $0 * 2 }\n```\n\n여기서 ' $0 \\* 2 '의 클로저는 부분 적용 함수로 볼 수 있습니다. 컴파일러는 이를 최적화하기 위해 다음을 수행합니다:\n\n- 클로저의 논리를 맵 함수로 직접 인라인 처리합니다.\n- 정수 배열에 대한 맵 함수를 특수화하여 일반적인 유형 처리의 오버헤드를 제거합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSwift 컴파일러는 이를 통해 함수형 스타일 코드가 가능한 한 효율적임을 보장합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-PartiallyAppliedFunctionsinSwift_0.png"},"coverImage":"/assets/img/2024-06-23-PartiallyAppliedFunctionsinSwift_0.png","tag":["Tech"],"readingTime":15},{"title":"Apple의 AI 기술 기대하지 마세요 - 당신이 Apple 인공지능을 못 받을지도 모르는 이유","description":"","date":"2024-06-23 01:49","slug":"2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall","content":"\n![Image](/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_0.png)\n\nApple의 WWDC 키노트는 올 가을에 Apple 기기로 오는 강력한 새로운 AI 기능들로 우리를 감명시켰습니다. Apple Intelligence는 현재의 Siri의 인상적이지 않은 혼란스러운 부분에 상당한 업그레이드가 될 예정입니다.\n\n그러나 보이는 바와 같이, Apple의 \"우리를 위한 AI\"는 대부분의 사람들을 제외합니다.\n\niPhone에서 Apple Intelligence를 사용하려면 iPhone 15 Pro 또는 iPhone 15 Pro Max가 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정규 iPhone 15 또는 이전 모델을 사용 중인 분은 신청하지 않으셔도 됩니다.\n\n실제로 작년에 출시된 플래그십 스마트폰인 iPhone 14 Pro와 iPhone 14 Pro Max조차 충분하지 않은 것 같아요.\n\n![image](/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_1.png)\n\n# 왜 iPhone 사용자의 90%를 제외하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아이폰 15 Pro와 Pro Max는 훌륭한 핸드폰이에요. 제가 정말 좋아해요. 하지만 아이폰 14 Pro도 충분히 좋은 성능을 가지고 있어요. 왜 Apple Intelligence에서 제외되었는지 궁금하네요.\n\n아마 아이폰 14 시리즈가 너무 오래되었다는 주장에 동의할 수도 있겠죠. 그렇다면 일반 아이폰 15와 아이폰 15 Plus는 어떨까요?\n\n아니에요. 그것들도 아닌 것 같아요.\n\n이러한 기능을 최신 모델 기기로 제한하는 것은 처리 성능과 하드웨어가 필요하기 때문에 합리적으로 보입니다. 하지만 신경망 엔진 처리는 아이폰에 새로운 기능은 아니에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n왜 대부분의 기기를 제외했나요?\n\n이는 RAM 문제인 것 같아요.\n\nApple Intelligence를 지원하는 모든 기기들은 적어도 8GB의 RAM을 가지고 있어요.\n\niPhone 15 Pro와 iPhone 15 Pro Max는 각각 8GB의 RAM을 가지고 있고, iPhone 14 Pro, 14 Pro Max, iPhone 15 및 15 Plus는 모두 6GB의 RAM을 가지고 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 M-시리즈 칩을 장착한 맥은 적어도 8GB의 RAM을 가지고 있어요.\n\nM1 아이패드 프로는 8GB 또는 16GB의 RAM을 가지고 있어요.\n\n그게 정답일까요? 8GB의 RAM이요?\n\n다른 많은 경쟁사와 달리, Apple Intelligence는 대부분 디바이스 내에서 운영되어 외부 서버로의 요청을 보내지 않아요 — 그건 좋은 점이에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 그건 RAM이 필요해요.\n\n# 전형적인 애플의 행동?\n\n애플이 여기에서 하드웨어 벽에 맞서 싸우고 있다는 것은 가능합니다. 하지만 제 의심 많은 두뇌는 여기에 더 많은 일들이 벌어지고 있는지 궁금해합니다.\n\n분석가 Ming-Chi Kuo는 애플 인텔리전스가 2GB 또는 그 이하의 RAM을 필요로 한다고 보고했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 무슨 생각이야?\n\n최근 일부 모델에서 사용 가능한 6GB RAM 중 2GB를 차지하는 것에 대해 Apple이 신경을 쓸 수 있다는 가능성이 있습니다. iPhone 13은 단지 4GB RAM을 갖추고 iOS 18을 지원하기 때문에, Apple이 6GB RAM을 갖춘 사용자에게 Apple Intelligence를 제공할 수 있을지 궁금해지는 것은 그리 멀지 않습니다. 성능은 특정 상황에서 약간 떨어질 수 있지만 해당 서비스를 제공할 수도 있습니다.\n\n하지만 Apple은 새로운 기능을 선택적으로 특정 기기로 제한함으로써 현재 기기에서 작동할 수 있는지 여부와 상관없이 고객들이 업그레이드하도록 유도하는 듯한 역사가 있습니다.\n\nApple이 6GB RAM을 갖는 기기를 위해 약간 축소된 버전의 Apple Intelligence를 제공할 수 있을지 궁금합니다. 이를 통해 iPhone 13 Pro 및 Pro Max, iPhone 14 및 14 Plus, iPhone 14 Pro 및 Pro Max, iPhone 15 및 iPhone 15 Plus를 대상으로 할 수 있을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n최근 iPhone 15 Pro 또는 iPhone 15 Pro Max에 큰 돈을 지불한 사용자들에겐 더 많은 기능과 완전한 경험이 남겨질 것 같아요.\n\n모든 것에 대한 전문가는 아니지만, Apple이 이전 최신 모델에서 Apple Intelligence를 작동시키고 싶다면 어느 정도는 가능할 것 같아요. 비록 완전한 경험은 아닐지라도요.\n\n제가 요구하는 건 AI 이미지를 생성하는 능력이 아니에요. 현재 시리가 할 수 있는 것 이상의 무언가를 원할 뿐이에요.\n\n아마도 Apple이 여기서 강력한 제약에 맞닥뜨리고 있어서 이전 모델로 Apple Intelligence를 가져오고 동일한 수준의 성능을 유지하는 건 불가능할 수 있어요. 하지만 분명히 무언가는 할 수 있을 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저거 속이시려고 하는 거야?\n\n# Apple Intelligence를 얻기 위해 업그레이드해야 할까요?\n\n아직 iPhone 12, 13 또는 14 시리즈를 사용 중이라면 Apple Intelligence를 위해 업그레이드해야 할까요? 그렇게 해야 할까요?\n\niPhone은 여러 년 동안 지속되는 경향이 있으며, 각 새로운 모델이 출시될 때마다 더 이상 이전 모델이 모든 새로운 소프트웨어 기능을 지원하지 않을 수 있습니다. 몇 가지는 업그레이드할 가치가 없을 수도 있지만, 다른 것들은 그렇지 않을 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 제품이 업그레이드할 가치가 있는지 궁금해요? Apple Intelligence가 큰 패러다임 변화로 충분히 오래된 기기를 교체하거나 새로운 기기를 구입할 가치가 있다고 생각하나요?\n\n만약 여러분이 Siri의 몇 가지 단순한 작업을 수행할 수 없다는 듯한 능력에 만족하지 못하고, 여러 회사의 비서들이 수행할 수 있는 작업들에 감명을 받지 못하며 더 강력한 AI 도우미가 있다면, 호환 가능한 기기로 업그레이드하는 것은 가치가 있을 수 있어요.\n\n하지만 그렇지 않다면, 이를 위해 더 많은 돈을 지불하기가 어려울 거예요. Apple이 우리가 원한다는 것을 명백하게 표현해도 말이에요.\n\niPhone 15 Pro 소유자로써, 그것은 제가 답변할 필요가 있는 질문이 아닙니다. 하지만 그것이 의미하는 바가 많은 기기를 사용 중인 수많은 iPhone 사용자들을 냉담하게 방치하는 Apple에 대해 저 또한 분노를 느낍니다.\n","ogImage":{"url":"/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_0.png"},"coverImage":"/assets/img/2024-06-23-NoAIforYouYouMightNOTBeGettingAppleIntelligenceAfterall_0.png","tag":["Tech"],"readingTime":6},{"title":"다중 터치 ML 모델 최신 트렌드 및 사용 방법","description":"","date":"2024-06-23 01:46","slug":"2024-06-23-Multi-touchMLModels","content":"\n## iOS 앱으로 Python 기반 ML 모델 이식하기\n\n![image](/assets/img/2024-06-23-Multi-touchMLModels_0.png)\n\n## 소개\n\nGoogle과 Apple은 모바일 기기에서 AI 모델을 네이티브로 실행하는 주요 계획을 시작했습니다. 이는 원격 서버에서 모델을 실행하는 것에서 이동하여 AI 응용 프로그램에 대한 흥미로운 기회를 만들어내면서 사용자 개인정보를 유지하는 것입니다. 이러한 발전 중 많은 부분은 디바이스 제조업체가 기계 학습 작업에 사용되는 알고리즘을 처리하는 데 점점 효과적인 칩셋을 설계한 데서 나옵니다. 최근 트렌드를 고려하여, 나는 Python으로 작성된 ML 모델을 iOS에서 네이티브로 실행할 방법을 살펴보기로 결정했습니다. 이를 통해 전화기에서 더 복잡한 ML 구현으로 나아가는 계단으로 보고, 이러한 질문에 대답하기 위해 잘 알려진 데이터셋을 사용했습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ML 모델을 iPhone에서 실행할 수 있는 방법은 무엇인가요?\n- 그 모델과 상호작용하기 위한 직관적인 방법은 무엇인가요?\n- 모바일 앱이 데이터와 기계 학습 모델 사이의 관계를 찾는 것을 기술적이고 비기술적인 사용자 모두에게 더 쉽게 만들 수 있을까요?\n\n이 글은 이러한 질문들을 염두에 두고 iOS 앱을 어떻게 구축하는지에 대해 안내하겠습니다. 자세한 내용에 들어가기 전에 이 연습을 통해 얻은 주요 통찰을 공유하겠습니다.\n\n- 모델을 적응시키는 \"어떻게\"에 대한 질문은 애플의 Core ML 도구를 사용하여 해결할 수 있습니다. 이 도구는 파이썬 모델을 애플의 칩셋에 최적화된 Core ML 형식으로 변환할 수 있습니다.\n- 슬라이더는 모델 예측에 대해 특성 값을 조정하기 위한 직관적인 인터페이스로, 그러나 화면 공간을 많이 차지합니다.\n- 분할 스크롤은 상대적으로 작은 공간에서 수치적 비교를 가능케 합니다.\n- 이 앱은 데이터에 대한 배경을 가진 사람들에게 ML 모델을 설명하는 데 도움이 될 수 있지만, 사용자 인터페이스와 시각화에 대한 추가적인 조정으로 비기술적인 사용자를 돕을 수 있습니다.\n\n이 글은 모바일 ML 모델을 만드는 데 사용된 일반적인 기술에 대해 이야기할 것입니다. 프로젝트에 대한 GitHub 링크도 제공됩니다. 다음은 다룰 주제의 요약입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모델이 훈련된 데이터의 개요\n- Python에서 Core ML로 모델 변환하기\n- 데이터를 iOS 앱으로 내보내기\n- 모델과 데이터를 애플리케이션에 가져오기\n- 모델 및 데이터와 상호 작용하는 인터페이스 구축 방법\n- 결론\n\n완성된 앱은 다음과 같습니다. 시작해봅시다!\n\n![앱 스크린샷](/assets/img/2024-06-23-Multi-touchMLModels_1.png)\n\n## 모델이 훈련된 데이터의 개요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nML 모델을 학습하는 데 사용된 데이터에 대해 간단히 설명드리겠습니다. 우리는 인기 있는 Pima 인디언 당뇨병 데이터 세트를 사용할 것입니다. 이 데이터는 국립당뇨병 및 소화기 및 신장 질환 연구소에서 나온 것으로, 혈당, BMI, 연령 등과 같은 개인의 의학적 속성에 중점을 둔 더 큰 데이터베이스의 일부를 대표합니다. 대상은 적어도 21세 이상의 피마 인디언 여성입니다. 당뇨병 양성 진단을 받은 환자는 결과가 1이며, 당뇨병 음성 진단을 받은 환자는 결과가 0입니다. 데이터는 kaggle에서 수집되었습니다.\n\n이 프로젝트에서는 Python을 사용하여 모델 구축 및 데이터 변환을 수행하고, iOS 애플리케이션에는 Swift를 사용할 것입니다. Python 코드에서 각 기능에 대해 생성된 탐색적 시각화 및 몇 가지 더 구체적인 결과들이 구축되기 전에 기본 랜덤 포레스트 분류기 모델을 만들 것입니다. 앱을 위해 몇 가지 염두에 두어야 할 사항들:\n\n- 사용자가 모델 예측을 위해 현실적인 시작점을 갖도록 기본적으로 이러한 값으로 설정하는 경우에 나중에 앱 인터페이스를 만들 때 데이터의 각 기능에 대한 전반적인 중심 경향 측정치를 표시할 것입니다.\n- 원래 데이터와의 모델 예측을 테스트할 수 있도록 몇 가지 변수 간의 관계를 관찰할 것입니다.\n\n![image](/assets/img/2024-06-23-Multi-touchMLModels_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 등고선 플롯에서 극값을 참고하여, 매우 가능성 있는 당뇨 진단이 있는 경우와 당뇨가 덜 가능성 있는 경우를 찾기 위해 데이터를 필터링할 수 있습니다. 아래는 110에서 130 사이의 글루코스 값, BMI가 30에서 35 사이인 경우 및 양성 당뇨병 분류에 대한 중앙값이 제공됩니다. 나중에 이러한 값들을 선택하여 우리 모델이 양성 분류를 예측하는지 확인할 것입니다.\n\n우리 모델은 scikit-learn에서 가져온 기본 랜덤 포레스트 분류기입니다. 데이터에 표준 스케일러를 적용하는 전처리기로서 파이프라인을 사용함에 유의하세요. 현재 모델에 추가적인 최적화는 수행되지 않았으며, 제 현재 초점은 iOS 앱에 배포하는 방법을 보여주는 것입니다.\n\n```js\nclf = RandomForestClassifier((random_state = 42), (n_estimators = 500));\npipe = Pipeline([(\"scaler\", StandardScaler()), (\"rf\", clf)]);\npipe.fit(X_train, y_train);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델은 조정 없이 첫 번째 시도에서 테스트 데이터에서 0.8의 정확도 점수를 보였어요. 당뇨병 양성 진단을 예측하는 데 어려움을 겪는 반면, 음성 진단을 예측하는 데는 더 어려움이 있어요. 특성 중요도를 확인할 때 혈중 포도당 수준이 가장 큰 영향을 주며, 이어서 BMI, 나이, 그리고 환자의 당뇨병 가계식 기능이 나타났어요. 사용자에게 직관적인 방식으로 이러한 특성을 전달할 수 있는지 앱을 개발하는 과정에서 이러한 점을 염두에 두겠어요. 다음으로는 Python 모델을 Core ML 파일로 내보내고 iOS 앱에서 시각화를 위한 데이터를 준비해볼게요.\n\n## Python 모델을 Core ML로 내보내기\n\nPython 코드에서 Core ML 도구를 가져와서 ct로 별칭을 만들어요. Core ML 도구에는 여러 모델을 지원하는 컨버터 클래스가 있으며, 원핫 인코딩과 같은 전처리기를 포함하고 있어요. convert 메서드를 호출하면 외부에 저장하고 Xcode와 같은 앱 개발 환경에서 가져올 수 있는 모델이 생성되어요:\n\n```js\ncoreml_model = ct.converters.sklearn.convert(pipe, X_cols, \"Outcome\");\ncoreml_model.save(\"DiabetesTest.mlmodel\");\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCore ML 도구에 대한 문서를 읽어보세요. Python 라이브러리로 어떤 것이 지원되는지 확인할 수 있어요. PyTorch, TensorFlow와 같은 인기 있는 신경망 라이브러리 뿐만 아니라 scikit-learn, XGBoost, LibSVM과 같은 비신경망 라이브러리도 지원되요. 사용 중인 라이브러리가 지원되지 않는다면, 사용 가능한 것에 맞추기 위해 파이프라인을 다시 설계해야할 수도 있어요.\n\n## 소스 데이터를 JSON으로 내보내기\n\nAPI 데이터를 가져오는 것을 시뮬레이션하기 위해 .csv 파일을 JSON으로 변환하고 있어요. 이것은 반드시 최상의 방법은 아니지만, 일부 데이터 시각화에 우리 앱이 작동하려면 데이터가 이런 형식으로 포맷되어 있으면 편리할 거에요. iOS 앱에서 데이터를 인덱싱하는 데 도움이 되도록 내보내기 전에 데이터에 일부 수정을 가했어요:\n\n```js\nimport json\nout = pima.reset_index()\nout = out.rename({'index': 'id'}, axis=1)\nout = out.to_json(orient='records')\nparsed = json.loads(out)\nwith open('data/diabetes.json', 'w') as f:\n    f.write(out)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## iOS 애플리케이션으로 모델 가져오기\n\n이제 iOS 기기에 최적화된 형식으로 모델을 내보냈으니, 애플리케이션으로 불러와야 합니다. 이후에는 Apple의 Xcode 환경을 사용해 Swift로 개발하게 될 것입니다. Xcode에서는 파일 - \"파일 추가...\" 메뉴를 이용해 프로젝트에 파일을 추가할 수 있고, 그 후에는 Swift 코드로 참조하면 됩니다. 아래는 모델의 파일명이 DiabetesTest로 설정된 예시입니다.\n\n```Swift\nimport CoreML\nimport CreateMLComponents\n\nlet config = MLModelConfiguration()\nlet model = try DiabetesTest(configuration: config)\n```\n\n모델을 불러왔는데, 이제 앱에서 어떻게 예측을 만들 수 있을까요? 모델은 prediction() 메서드를 가지고 있으며, 데이터의 모든 특징을 매개변수로 사용합니다. 호출하는 방법은 아래와 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nlet prediction = try model.prediction(Pregnancies: pregnancies,\nGlucose: glucose,\nBloodPressure: bloodPressure,\nSkinThickness: skinThickness,\nInsulin: insulin,\nBMI: BMI,\nDiabetesPedigreeFunction: diabetesPedigreeFunction,\nAge: Age)\npredictionValue = Int(prediction.Outcome)\n\n## iOS 애플리케이션으로 JSON 데이터 가져오기\n\n데이터를 로드해야 합니다. 이 작업은 모델을 훈련하는 데 사용한 각 개인의 건강 데이터를 시각화하는 데 도움이 됩니다. Pima라는 구조체를 만들어서 시작하겠습니다. 이 구조체는 Codable 및 Identifiable로 만들어지며, 각 특징이 나열됩니다.\n\n```swift\nstruct Pima: Codable, Identifiable {\n    let id: Int\n    let Pregnancies: Float\n    let Glucose: Float\n    let BloodPressure: Float\n    let SkinThickness: Float\n    let Insulin: Float\n    let BMI: Float\n    let DiabetesPedigreeFunction: Float\n    let Age: Float\n    let Outcome: Float\n\n    var BMIString: String { BMI.formatted(.number) }\n    var GlucoseString: String { Glucose.formatted(.number) }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터를 가져오는 것은 JSON 디코딩이 필요할 거예요. 주요 단계의 요약은 아래에 있어요. 디코딩된 데이터는 클래스 데이터 객체에 저장돼요. 이 객체는 프로젝트 전체에서 공유할 거예요:\n\n```js\nlet bundlePath = Bundle.main.path(forResource: name,\n                                  ofType: \"json\"),\nlet jsonData = try String(contentsOfFile: bundlePath).data(using: .utf8)\nlet decodedData = try JSONDecoder().decode([Pima].self,\n                                           from: jsonData)\nself.pima = decodedData\n```\n\n## 모델 실험을 위한 인터페이스 구축\n\n이제 데이터를 불러왔으니, 앱 인터페이스 구성 요소를 만들어 볼 수 있어요. 이 구성 요소에는 다음이 포함돼요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 혈당, BMI, 연령 및 기타 측정치의 값을 수정할 수 있는 슬라이더. 환자의 당뇨병 가능성을 나타낼 예측이 값이 변경될 때마다 이루어집니다.\n- 당뇨병 분류 결과를 동반하는 차트로, 소스 데이터에서 두 그룹에 속한 환자 수를 표시합니다.\n- 데이터의 스크롤 가능한 뷰로, 선택한 값을 원본 데이터세트의 값과 비교하거나 양성 및 음성 분류 간을 비교할 수 있습니다.\n\n이러한 요소들의 조합은 다양한 배경을 가진 사람들이 모델과 소스 데이터를 실험을 통해 이해할 수 있도록 의도되었습니다. 예를 들어, 혈당 슬라이더를 조절하여 혈당이 증가함에 따라 산점도에 오렌지색 점의 증가와 이웃 막대 차트의 더 높은 오렌지색 막대가 나타나며, 더 많은 양성 케이스를 나타냅니다. 다른 기능들, 특히 연령과 BMI와 실험을 통해 이들 값과 양성 예측 사이의 관계를 비교하면 유사한 발견이 이뤄질 것입니다. 각 슬라이더 변경 시 모델은 예측을 수행하고 데이터를 필터링하여 현재 뷰와 함께 필터링된 데이터를 제공합니다.\n\n우리의 슬라이더를 구현하기 위해, 각 기능에 대해 데이터의 최소/최대 값을 범위로 설정할 수 있습니다. 슬라이더가 이동하고 값이 변경될 때마다, 차트에서 읽은 공유된 필터링된 데이터를 업데이트하고 현재 슬라이더 값을 사용하여 모델에 의한 예측을 실행합니다. 혈당 슬라이더를 사용한 예시는 아래와 같습니다:\n\n![image](https://miro.medium.com/v2/resize:fit:590/1*ekxFVO-UDWH_2I9FQjQiPw.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 데이터 개요 섹션에서 관찰된 값들과 유사한 값을 사용하여 Glucose의 범위를 110에서 130으로 보여주는 컨투어 플롯이 있습니다. 이 플롯은 이 범위에서 당뇨병 양성 진닝의 높은 양을 나타냈습니다. 이러한 글루코스 값으로 업데이트한 후 모델이 양성 분류를 지정하는 것을 보는 건 격려가 됩니다!\n\n시각화를 만들려면 Charts 라이브러리가 필요하며, 우리는 당뇨병이 없는 환자를 나타내는 파란색, 당뇨병이 있는 환자를 나타내는 주황색으로 사용자 지정 색상을 가진 산점도를 보여줍니다. 막대 차트는 두 가지 당뇨병 결과를 따로 그룹화하고 현재 슬라이더 값에 따라 총계를 계산합니다. 다음은 막대 차트에 대한 코드 스니펫입니다:\n\n```js\n// 현재 선택 항목에 따른 총 수 카운트 찾기\nlet aggregatedData = Dictionary(grouping: filteredTable, by: { $0.Outcome })\n    .map { (outcome, items) in\n        (category: outcome, count: items.count)\n    }\n\n// 막대 차트 생성\nlet barChart = Chart(aggregatedData, id: \\.category) { item in\n    BarMark(\n        x: .value(\"카테고리\", item.category),\n        y: .value(\"수\", item.count)\n    )\n    .annotation(position: .top, alignment: .center) {\n        Text(\"\\(item.count)\")\n            .font(.caption)\n            .foregroundColor(.black)\n    }\n    .foregroundStyle(by: .value(\"카테고리\", item.category))\n}\n```\n\n이 시점에서 사용자에게 혈당, BMI 및 기타 기능의 값 선택이 실제 환자 데이터와 일치하는지를 보여줄 수 있습니다. 또한 우리의 모델이 그러한 선택을 기반으로 예측을 하는 방법을 동시에 보여줄 수 있습니다. 그러나 혈당, BMI 및 기타 기능에 대한 \"정상\" 값이 무엇인지에 대한 사용자에게 더 많은 컨텍스트를 제공하는 방법은 무엇일까요? 앱 설계 시에 이 문제를 몇 가지 마주쳤습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 화면 공간이 제한되어 있어 숫자들과 요약 통계의 벽이 잘 표시되지 않아요.\n- 최소 두 세트의 데이터를 동시에 비교할 수 있어야 하며 사용자가 비교하려는 데이터 포인트를 쉽게 선택할 수 있어야 합니다.\n- 사용자가 소스 데이터와 일치하지 않는 값을 실수로 선택하면 해당 값과 일치시킬 수 없게 됩니다.\n\n1번과 2번 문제에 대한 해결책은 스플릿 스크롤 뷰를 생성하는 것이었습니다. 뷰의 반은 하나의 데이터 세트에 투여되고, 다른 반은 비교할 대상에 투여됩니다. 두 가지를 빠르게 동시에 스크롤하여 값들을 비교할 수 있으므로 노력을 많이 들이지 않고도 비교할 수 있습니다. 이를 위해 새로운 두 가지 뷰를 생성했고, 앱 상단 오른쪽의 Stats 버튼을 클릭하여 이동할 수 있습니다. 첫 번째 뷰는 현재 선택 사항과 필터링된 데이터의 중앙/최소/최대 값을 비교할 수 있도록 합니다. 두 번째 뷰는 긍정적 결과로 필터링된 데이터와 부정적 결과로 필터링된 데이터 간의 비교를 제공합니다.\n\n\"이움 매체 데이터\"라고 표시된 추가 슬라이더를 추가하여 사용자가 데이터 포인트와 가깝지 않은 값을 선택할 때 대응했습니다. 이 슬라이더를 조정하면 사용자가 선택한 값의 위와 아래로 필터 범위가 증가하여 현재 선택 사항 주변에 점점 더 넓은 범위로 데이터를 검색합니다. 왼쪽 끝까지 슬라이드하면 모든 데이터 포인트가 표시됩니다. 다른 뷰의 중앙/최소/최대 계산은 이 데이터 선택을 기반으로 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:590/1*VEDrLQddT4Pi2rGqGK8G5A.gif\" /\u003e\n\n## 결론\n\n우리는 직관적인 스마트폰 인터페이스를 활용하여 데이터와 머신러닝 모델을 다루는 직관적인 방법을 만들 수 있습니다. Apple의 Core ML 도구를 사용하면 우리는 파이썬으로 모델을 개발하고 이를 iOS 네이티브 모델 형식으로 변환한 다음 앱에 가져올 수 있습니다. 우리의 앱은 사용자가 기능 값들을 수정할 수 있는 기능을 제공하여 모델을 훈련시키는 데 사용된 데이터 세트를 탐색하고 모델의 예측 출력을 볼 수 있게 합니다. 이 공간에서 탐색할 수 있는 많은 가능성이 있으며, 모델과 다른 인터페이스를 계속해서 만들면 다른 사람들에게 결과를 전달하는 새로운 방법을 열 수 있습니다!\n\n어떤 모델 인터페이스를 만들어 보고 싶으신가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 링크\n\nGitHub 저장소\n\n애플의 Core ML 도구\n\n피마 인디언 당뇨병 데이터베이스\n","ogImage":{"url":"/assets/img/2024-06-23-Multi-touchMLModels_0.png"},"coverImage":"/assets/img/2024-06-23-Multi-touchMLModels_0.png","tag":["Tech"],"readingTime":13},{"title":"매월 1,338달러 수익을 올리는 iOS 앱 만드는 방법","description":"","date":"2024-06-23 01:43","slug":"2024-06-23-BuildaniOSAppwitharevenue1338mo","content":"\n완전한 튜토리얼이 함께 하면서 한 단계씩 안내해 드릴게요\n\n![iOS 앱 빌드 수익 내기](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_0.png)\n\n# 월 수익\n\n오랜 시간 동안 이 앱에 작업해온 결과, 매달 수익이 약 1300달러 정도 나오고 있습니다. 개발자들과 경험을 공유하고, 저와 같은 수익을 얻을 수 있도록 도와주고 싶어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마스 1부터 7까지의 수익, 광고 수익은 제외합니다.\n\n![Image](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_1.png)\n\n여기서 전체 수익을 확인할 수 있습니다.\n\n![Image](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 시작하기 전에\n\n이 튜토리얼은 고급 Swift를 배우고 싶은 소프트웨어 개발자를 대상으로 설계되었습니다. 이 튜토리얼은 Swift에 대한 충분한 이해와 어떻게 앱을 처음부터 만드는지에 대한 지식을 제공할 것입니다. 저는 개발자들이 깔끔한 코드로 자신만의 앱을 만드는 데 도움을 주고 싶어합니다. 대부분의 튜토리얼이 앱을 만드는 데 정말 좋은 참고 자료가 아니라는 것을 감안할 때, 여기서는 MVVM 아키텍처를 따르고 인앱 구매를 통합하는 방법에 대한 완전한 튜토리얼을 볼 수 있을 것입니다.\n\n이 튜토리얼을 진행하기 전에 컴퓨터 프로그래밍 용어와 프로그래밍 언어의 지식을 가지고 있어야 합니다.\n\n따라서, 초보자이고 Swift에 대해 많이 알지 못하는 경우에도 따라올 수 있지만, 더 많이 Swift에 대해 알고 시작하는 것이 가장 좋습니다. 왜냐하면 우리는 기본적인 Swift 세부 정보에 대해 다루지 않을 것이기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image1](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_3.png)\n\n# 애플리케이션 아키텍처\n\n소프트웨어를 개발할 때 디자인 패턴 뿐만 아니라 아키텍처 패턴 또한 중요합니다. 소프트웨어 공학에서는 다양한 아키텍처 패턴이 있습니다. 모바일 소프트웨어 공학에서 가장 널리 사용되는 것은 MVVM, Clean architecture 및 Redux 패턴입니다.\n\n![image2](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 여기에서 사용된 아키텍처 개념들\n\n- Clean Architecture [여기를 클릭하여 참고](https://blog.cleancoder.com/uncle-bob/2012/08/13-the-clean-architecture.html)\n- 고급 iOS 앱 아키텍처 [여기를 클릭하여 참고](https://www.raywenderlich.com/8477-introducing-advanced-ios-app-architecture)\n- MVVM\n- 데이터 바인딩\n- 의존성 주입\n- SwiftUI 및 UIKit 뷰 구현: 동일한 ViewModel 재사용 (최소 Xcode 11 필요)\n\n## 요구 사항\n\n- Xcode 버전 11.2.1 이상, Swift 5.0 이상\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# VPN\n\nVPN은 가상 사설 네트워크를 의미합니다. 다가오는 기사에서 VPN 서버를 설치하는 방법을 알아볼 것입니다. 앱을 개발하기 위해 iOS에서 사용할 수 있는 VPN 프로토콜을 정의할 것입니다. 애플 문서에 따르면 개인 VPN을 위해 IKEv2 및 IPsec 프로토콜을 지원할 수 있습니다. 네트워크 확장 및 능력에 대해 알아볼 것을 제안합니다.\n\n이 앱 개발을 시작했을 때 안드로이드와 iOS 두 플랫폼을 대상으로 지정하고 싶었습니다. 따라서 둘 다 작동할 수 있는 VPN 프로토콜을 사용하고 싶었고 오랜 시간을 투자해 조사하고 시도한 결과 IKEv2를 사용하는 것이 최선임을 알게 되었습니다.\n\nIKEv2가 무엇인지 이곳에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 코딩을 시작해봐요 🎉 💻\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_5.png\" /\u003e\n\n이렇게 마크다운 형식으로 코드를 작성하면 가독성이 높아지고 좋아요! 코딩을 시작하기 전에 앱에 무엇을 원하는지에 대해 조금 이야기해봐요! 간단하게 3개의 씬에서 작업하고 스토리보드를 사용할 거에요 🤒\n\n- OnboardigViewController\n- DashboardViewController\n- InAppPurchaseProViewController\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_6.png\" /\u003e\n\n## 코딩\n\n새 프로젝트를 만들고 원하는 이름을 지정할 수 있지만, 이 튜토리얼에서는 VPN Guard와 Secure VPN이라는 2개의 이름이 있습니다. VPN Guard는 여기서 참조로 사용할 Secure VPN을 기반으로 합니다.\n\n프로젝트를 명확하게 유지하는 가장 좋은 방법은 폴더를 구성하는 것이니, 우선 그 폴더들을 생성해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Screenshot 1](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_7.png)\n\nAfter grouping all the layers we have: Domain, Presentation, and Data Layers.\n\n![Screenshot 2](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_8.png)\n\nThe domain layer is totally isolated, the innermost part of the onion. This layer can be reused in other projects.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프레젠테이션 레이어에는 뷰 컨트롤러와 뷰 모델, XIB, SwiftUI 뷰 등 UI가 포함되어 있습니다. 뷰는 한 개 또는 여러 개의 유즈 케이스를 실행하는 뷰모델에 의해 조정됩니다. 프레젠테이션 레이어는 도메인 레이어에만 의존합니다.\n\n데이터 레이어에는 리포지토리 구현과 한 개 또는 여러 개의 데이터 소스가 포함됩니다. 리포지토리는 로컬 또는 외부의 다른 데이터 소스에서 데이터를 조정하는 역할을 합니다. 프레젠테이션 레이어와 마찬가지로 도메인 레이어에만 의존하며 매핑 및 디코딩 로직을 포함할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_9.png)\n\niOS에서 아키텍처 패턴에 대해 더 알고 싶으시면 여기에 댓글을 남겨주시면 더 자세한 내용의 아키텍처 패턴에 대한 다른 이야기를 올릴게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 대시보드 뷰 컨트롤러\n\n이제 대시보드 디자인을 구축할 수 있습니다. 가운데에 버튼이 있을 것입니다. 사용자가 해당 버튼을 탭하면 VPN 서버와의 연결을 설정할 것입니다.\n\nUILabel은 연결 상태를 표시할 것입니다.\n\n상단의 UIImage/UILabel은 사용자가 무료 또는 프로인지 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가운데에 VPN 서버의 국가 이름과 함께 국기 아이콘을 표시할 수 있습니다. 이 위에는 파이어베이스에서 가져온 VPN 서버 목록을 트리거하는 UIButton이 있을 것입니다.\n\n현재 공개 IP 주소를 표시하는 UILabel입니다.\n\n![이미지](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_10.png)\n\nAppDIContainer와 연결된 스토리보드와 인스턴스화할 viewController를 연결하기 위해 StoryboardInstantiable 프로토콜을 만들 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`instantiateViewController` 메서드는 fileName을 확인하며 이는 스토리보드 `DashboardViewController.swift`, `DashboardViewController.storyboard`의 동일한 이름이어야 하고 해당 스토리보드에서 ViewController를 생성하고 반환합니다.\n\n따라서, 우리의 DashboardViewController는 StoryboardInstantiable 프로토콜을 준수하며 DashboardViewController를 반환할 클래스 메서드를 정의할 것입니다.\n\n```swift\nfinal class func create(viewModel: DashboardViewModel) -\u003e DashboardViewController {\n```\n\n```swift\nlet view = DashboardViewController.instantiateViewController()\n    return view\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 ViewModel을 할당하기 위해 이 함수를 사용할 것입니다.\n\n연결 버튼을 viewController와 연결하고 클로저 내에서 액션 아웃렛으로 설정한 후에, 다음의 코드 라인을 추가합니다:\n\n```js\nviewModel.connectDisconnect();\n```\n\n이렇게 하면 물론 ViewModel이 없다는 오류가 발생할 것입니다. 걱정 마세요. 우리의 목표는 DashboardViewController용 ViewModel을 생성하는 것이기 때문에, viewController 내부에서 정의를 해볼 겁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprivate(set) var viewModel: DashboardViewModel!\n```\n\n그리고 이것은 DashboardViewModel 파일을 생성합니다. 이전에 말한대로 ViewModel은 하나 이상의 사용 사례를 가지므로, 뷰 모델의 책임은 서버에 연결/연결 해제를 트리거하는 것에 대해 고려해야 합니다.\n\nDashboardViewModel을 위해서 우리는 입력/출력을 정의합니다.\n\n이렇게 함으로써, 이 viewModel이 무엇을 할지 전체 아이디어를 가지게 될 것이며 나중에 필요하다면 새로운 기능을 추가할 수 있는 기회를 얻게 됩니다. 현재 VM의 로직이 복잡하기 때문에 새로운 것을 만들어도 기능은 변경되지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDashboardViewModelRoute는 이름에서 알 수있듯이 라우트를 포함하는 enum입니다.\n\nDashboardViewModelLoading은 서버에 연결하거나 API에서 데이터를 가져올 때 현재 상태를 View에 알릴 때 사용하는 enum입니다.\n\n여기서 viewModel을 엿볼 수 있습니다.\n\n## 사용 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 대시보드 뷰컨트롤러와 그 뷰모델이 준비되었으니, 사용 사례를 시작할 때입니다. 사용 사례는 도메인 레이어에 추가됩니다. 따라서 NetworkVPNUseCase를 만듭니다.\n\nVPN의 주요 사용 사례는 연결, 연결 해제, 구성 로드, 상태 가져오기이며, 서버를로드하기 위해 API를 사용하는 경우 서버 가져오기를 추가할 수 있습니다.\n\n다음과 같이 원하는 모든 경우를 포함하는 프로토콜을 정의합니다:\n\nNetworkVPNUseCase에 준수하는 DefaultNetworkVPNUseCase라는 final 클래스를 만듭니다. 아직 Data 레이어에 주입될 Repository가 누락되어 있습니다. 이 Repository에는 NetworkVPNUseCase의 동일한 경우가 있을 것입니다. 따라서 도메인에 이를 추가하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경로: Domain/interfaces/Repositories/\n\nDefaultNetworkVPNUseCase로 돌아가서 레포지토리의 private 속성을 선언합니다.\n\n```js\nprivate(set) var vpnManager: DVPNRepository\n```\n\n여기서 사용 사례 클래스의 최종 모습을 찾을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알다시피, 도메인 레이어는 격리되어 있고 내부에서는 제3자를 사용하지 않습니다. 따라서 NEVPNStatus에서 매핑할 VPN 상태 NetworkVPNStatus를 처리하기 위해 특별한 enum을 만들었습니다.\n\n이제 NetworkVPNUseCase를 완료한 후에는 DashboardViewModel로 돌아가서 사용 사례를 주입하면 됩니다. 곧 다시 그 부분으로 돌아갈 겁니다.\n\n## 데이터\n\n데이터 레이어 내에서 VPNRepository 및 VPNManager를 생성하여 연결 설정, 구성 로드 및 연결 해제 과정을 모두 처리할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1- IPSec/IKEv2 연결\n\n먼저 앱에 새로운 기능을 추가해야 합니다. 따라서 프로젝트를 선택하여 로그인 및 기능 설정으로 이동하세요.\n\n![앱이미지](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_11.png)\n\n왼쪽 상단의 기능을 클릭하고 개인 VPN을 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 테이블 형식을 Markdown 형식으로 바꿔주세요.\n\n|                                   이미지                                    |\n| :-------------------------------------------------------------------------: |\n| \u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_12.png\" /\u003e |\n|                             Keychain 공유 추가                              |\n| \u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_13.png\" /\u003e |\n|  Keychain에는 keychain 그룹 도메인을 추가하여 필요한 내용을 추가해주세요.   |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_14.png\" /\u003e\n\n## 설정\n\n다행히도 애플은 타사 라이브러리 없이 IPsec/IKEv2를 사용하여 VPN에 연결할 수 있는 좋은 API 세트를 제공합니다.\n\n코딩을 시작하기 전에 어떻게 작동하는지 설명해 드릴게요. DefaultVPNManager는 다음을 수행할 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 환경 설정 불러오기\n\n2. 새로운 값으로 환경 설정 변경하기 (사용자 이름, 비밀번호, 호스트 등)\n\n3. 환경 설정 저장하기\n\n4. 연결 시작하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설정이 없는 경우에도 먼저 선호도를 로드한다는 것이 이상하게 들릴 수 있습니다. 그러나 이것이 애플이 일을 하는 방법입니다. 만약 로드하기 전에 설정을 저장했다면, 프로세스가 실패할 것입니다.\n\n비밀번호와 공유 키는 키체인에 저장됩니다. 나중에 키체인에 관한 기사를 쓸 예정이니, 준비되면 언제 인터넷에 올릴지 물어봐주세요 🙂 혹은 트위터에서 저를 팔로우해주세요 🐦(아직 제 계정은 새로운 상태입니다).\n\n![image](/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_15.png)\n\nDefaultVPNManager는 Data/VPNManager/Repository에 위치한 VPNRepository를 준수할 것입니다. 이 프로토콜은 속성과 함수를 보유할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNEVPNManager은 여기에서 필요한 것입니다. VPN 구성을 생성하고 관리할 수 있는 능력을 제공합니다. Apple 문서를 여기에서 확인하세요. 🍏\n\nNEVPNManager의 인스턴스를 가지려면 NEVPNManager 프로토콜의 확장을 만들었습니다. 이것은 코딩을 하는 동안 우리의 삶을 좀 더 쉽게 해줄 것입니다.\n\n매니저를 호출할 때 NEVPNManager에 대한 참조를 계산된 값으로 얻게 됩니다. 더 많은 세부 정보는 여기에서 Swift의 속성에 대해 확인하세요.\n\n상태는 VPN의 현재 상태를 반환하며, 이것이 왜 새로운 enum을 생성하여 도메인 레이어 내에서 NetworkExtension을 사용하지 않을 이유입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n`registerNotification()` 함수는 VPN 상태가 변경될 때 알림을 받습니다. NotificationCenter를 사용하는 이유는 `vpnManager.connection.startVPNTunnel()` 메서드가 성공해도 실제로 연결이 성립된 것은 아니고 VPN 터널 설정이 성공적으로 시작된 것을 의미하기 때문입니다. 따라서 실제 상태를 얻기 위해 우회 처리를 해야 했습니다. 곧 몇 분 안에 작동 방식을 확인하실 수 있을 거에요.\n\nDefaultVPNManager로 돌아가서 여기서 확인할 수 있습니다. `#if targetEnvironment(simulator)`와 같은 컴파일 조건이 있는 것을 알게 될 거에요. 아쉽게도 시뮬레이터에서 VPN이 작동하지 않기 때문에 UI 디버깅 중 충돌을 방지하기 위해 추가했습니다.\n\n또한, `manager.loadFromPreferences`와 `manager.saveToPreferences` 콜백은 비동기적으로 동작합니다.\n\n구성을 저장할 때, 먼저 사용 중인 프로토콜을 정의해야 합니다. 제 경우, 어플리케이션은 IPSec 및 IKEv2 둘 다 허용할 수 있습니다. 따라서 여기서 서버의 프로토콜 유형을 확인하여 해당 유형에 맞게 연결 및 구성을 시도하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIPSec에 대해:\n\n```js\n경우 .IPSec:\n```\n\n```js\nlet p = NEVPNProtocolIPSec();\n```\n\n```js\np.useExtendedAuthentication = true;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```javascript\np.localIdentifier = account.localID ?? \"VPN\";\n```\n\n```javascript\np.remoteIdentifier = account.remoteID;\n```\n\n```javascript\nif account.pskEnabled {\n```\n\n```javascript\np.authenticationMethod = .sharedSecret\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\np.sharedSecretReference = account.getPSKRef();\n```\n\n```js\n} else {\n```\n\n```js\np.authenticationMethod = .none\n```\n\n```js\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\npt = p;\n```\n\nIKEv2의 경우:\n\n```js\ncase .IKEv2:\n```\n\n```js\nlet p = NEVPNProtocolIKEv2();\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```json\np.useExtendedAuthentication = true\n```\n\n```json\np.localIdentifier = account.localID\n```\n\n```json\np.remoteIdentifier = account.remoteID\n```\n\n```json\nif (account.pskEnabled) {\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\np.authenticationMethod = .sharedSecret\n```\n\n```js\np.sharedSecretReference = account.getPSKRef();\n```\n\n```js\np.passwordReference = account.getPasswordRef();\n```\n\n```js\n} else {\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\np.authenticationMethod = .none\n```\n\n```js\n}\n```\n\n```js\np.deadPeerDetectionRate = .medium\n```\n\n```js\npt = p;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nconfigOnDemand에 대해 지금은 해당 사항이 아니기 때문에 구성하지 않을 거에요.\n\n이제 개인 VPN을 구성한 후에는 도메인 레이어 리포지토리를 데이터 레이어에 주입할 시간이에요. 이를 위해 /Data/Repository 안에 createDefaultVPNRepository final 클래스를 만들 것이에요.\n\n우리는 DefaultVPNRepository를 DVPNRepository에 준수하도록 만들 것이며, 이를 사용할 수 있게 될 거에요. 전체 코드는 여기에서 확인할 수 있어요.\n\n이제 DashboardViewModel 설정을 완료할 준비가 되었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 대시보드 뷰모델 파트 2:\n\n뷰모델 안에서 다음과 같이 private 속성을 설정하였습니다:\n\n```js\nprivate var networkVPNUseCase: NetworkVPNUseCase\n```\n\n```js\ninit(networkVPNUseCase: NetworkVPNUseCase) {\n   ...\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 VPNManager에서 설정한 VPN 상태를 가져오기 위해 observer를 등록했어요.\n\n```js\nNotificationCenter.default.addObserver(self, selector: #selector(statusDidChange(_:)), name: NSNotification.Name.NEVPNStatusDidChange, object: nil)\n```\n\nstatusDidChange는 상태가 변경될 때 레이블을 업데이트할 거예요.\n\nviewDidLoad에서는 ViewModel에게 구성을 로드하도록 알릴 거예요. DefaultDashboardViewModel 쪽에서는 이렇게 될 거예요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunc viewDidLoad() {\n      self.observeStatus()\n      self.networkVPNUseCase.loadVPNConfig {}\n}\n```\n\n대시보드뷰컨트롤러의 connect 버튼을 누르면 ViewModel에게 연결 설정이 끊겨 있는지를 확인하고, 현재 상태가 연결된 상태인 경우에는 연결을 끊어야 한다고 알려줍니다.\n\n```js\nfunc didConnect() {\n    networkVPNUseCase.connect(configuration: vpnAccount.value)\n}\n```\n\n```js\nfunc didDisconnect() {\n    self.networkVPNUseCase.disconnect()\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 논리는 어디에서 처리될까요? MVVM에서는 뷰가 어떤 종류의 논리도 처리해서는 안 되며, 현재 상태/동작을 ViewModel에만 알리고 VM이 적절한 동작을 수행해야 합니다. 이 논리를 수행하는 방법은 다음과 같습니다:\n\n```js\nfunc connectDisconnect() {\n    if status.value == .connected || status.value == .connecting {\n        self.networkVPNUseCase.disconnect()\n    } else if (status.value == .disconnected || status.value == .invalid) {\n        self.networkVPNUseCase.connect(configuration: vpnAccount.value)\n    }\n}\n```\n\n기본적으로 우리는 NSNotification.Name.NEVPNStatusDidChange를 통해 받은 상태를 확인하여 연결 또는 연결 해제합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 부분에서 놓친 부분은 ViewModel을 바인딩하는 것 뿐입니다.\n\n따라서 ViewController 내에서 viewDidLoad에서 bind(viewModel)를 수행합니다.\n\n여기서 bind()는 옵저버의 키를 설정하는 private 함수입니다.\n\n```js\nprivate func bind(_ viewModel: DashboardViewModel) {\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nviewModel.loadingType.observe(on: self, observerBlock: { [weak self] in self?.handleLoading($0)})\n\nviewModel.status.observe(on: self, observerBlock: { [weak self] in self?.handleConnectionStatus($0)})\n\nviewModel.route.observe(on: self, observerBlock: { [weak self] in self?.handleRouting($0)})\n\nviewModel.premiumStatus.observe(on: self, observerBlock: { [weak self] in self?.handlePurchaseStatus($0)})\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nviewModel.vpnAccount.observe(on: self, observerBlock: {[weak self] in self?.handleVPNSelection($0)})\n```\n\n```js\nviewModel.currentIP.observe(on: self, observerBlock: {[weak self] in self?.handleIPUpdates($0)})\n```\n\n```js\nviewModel.loadRequestAd.observe(on: self, observerBlock: {[weak self] in if $0 { self?.interstitial.load(GADRequest())}})\n```\n\n```js\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRx 대신 Observable 대신 RxSwift 라이브러리를 사용할 수 있어요.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*BwR548YaWSxEhs7RjlHzPw.gif)\n\n# 다음 파트가 곧 업데이트될 예정입니다\n\n## ✌️이 튜토리얼을 계속 진행하고 싶다면 여기나 Twitter에서 팔로우해주세요. 궁금한 점이 있으면 언제든지 물어보세요, 최선을 다해 답변해드릴게요 ❤️\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 👉 [파트 2]\n","ogImage":{"url":"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_0.png"},"coverImage":"/assets/img/2024-06-23-BuildaniOSAppwitharevenue1338mo_0.png","tag":["Tech"],"readingTime":24},{"title":"여기까지 보고 놀랄 수밖에 없는 애플 단축어 11가지","description":"","date":"2024-06-23 01:40","slug":"2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen","content":"\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_0.png)\n\n과장이 아니지만, 숏컷(Shortcuts)은 아이폰에서 가장 과소평가된 앱입니다. 사용자들이 자신의 삶을 자동화하고 더 생산적으로 유지하는 미니 앱을 만들 수 있게 해줍니다.\n\n가장 좋은 점은, iOS 시스템 설정을 조정하고 조작할 수 있는 능력을 가지고 있다는 것입니다 - 제3자 앱들은 상상조차 할 수 없는 기능입니다.\n\n너무 강력해서 안타깝게도 잘 활용되지 못하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 11가지 복잡하고 고급 단축키에 대해 설명해 드릴게요 — 저는 대부분 이것들을 정기적으로 사용해요.\n\n# #1. 자동 메시지\n\n이 단축키는 연락처에 메시지를 예약해서 보낼 수 있게 도와줍니다 — 이는 기본 Messages 앱이 제공하지 않는 기능이에요 (Mail은 제공합니다).\n\n어떻게 할까요? 리마인더를 이용해서요.\n제가 설명해 드릴게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단축키를 시작하려면 다음을 수행해야 합니다: - 미리 알림 앱에서 새 목록을 생성합니다. 그리고 자동 메시지에 등록하여 작업에 사용하도록 설정합니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_1.png)\n\n이제 이런 작업을 찾기 위해 단축키를 트리거하십시오: (iOS 및 macOS에서 작동합니다)\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 옵션으로 메시지를 개별 연락처에 예약하는 기능을 시도해 보세요.\n\n클릭하면 다음을 안내합니다:\n\n- 연락처를 선택하세요,\n- 메시지를 입력하세요 (기본값: 클립보드),\n- 이미지를 첨부하세요 (와!),\n- 날짜와 시간을 선택하세요.\n\n선택한 시간을 기준으로 모든 세부 사항이 포함된 리마인더가 생성됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_3.png)\n\n설정된 시간에 알림을 받으면 URL을 간단히 탭하세요.\n\n그럼 해당 바로 가기가 이미지를 자동으로 검색하고 메시지를 가져와 선택한 Messages 또는 WhatsApp을 통해 연락처에게 전송합니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정말 멋지죠!\n\n자동으로 되지는 않지만, 특정 시간에 사람들에게 메시지를 보내놓을 것을 잊지 않도록 도와주는 매우 유용한 바로 가기 기능이에요.\n\n그리고 더 멋진 건, 아래와 같은 것을 할 수 있답니다.\n\n- 바로 가기 내에서 즐겨찾기 및 그룹 생성할 수 있어요.\n- 개별, 그룹 또는 다중 그룹에 메시지를 보낼 수 있어요.\n- 메시지를 재스케줄하거나 취소할 수 있어요.\n  (팁: 이를 직접 알림을 조정하여 할 수 있어요)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n직관적인 스크린샷이 지루할 수 있지만, 그 장치의 이미지로 프레임을 설정하면 환상적으로 보입니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 애플 블로거로서, 그것을 해야만 합니다. 제 기사들의 대부분의 스크린샷은 프레임 안에 삽화되어 있거든요.\n\n그렇다면 어떻게 하는 건가요?\n\n- Mac을 사용할 때는 Mockuuups Studio를 사용해요 (어필리에이트 링크 아님).\n- Mac이 근처에 없을 때는 iPhone에서 iFrames라는 단축키를 사용해요—그 앱만큼 강력해요.\n\niFrames가 어떻게 작동하는지 알아보세요:\n실행하면 iPhone, iPad, Mac, Apple Watch 또는 Apple TV에서 찍은 스크린샷과 해당 프레임으로 사용하고자 하는 기기를 요청합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n거의 다 이제 맥 모의도를 로컬에 저장할 수 있습니다.\n\n그게 끝이 아니에요, 여기 최고의 부분입니다:\n\n- 거의 모든 애플 장치가 iFrames에서 사용 가능합니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모의 모형을 생성하는 데 10초 미만이 걸립니다(안정적인 인터넷 연결 상태에서).\n- 자주 사용하는 프레임이 있다면 상단에 고정시키거나 오프라인으로 사용할 수도 있습니다!\n- iFrames는 사용 중인 기기를 자동으로 감지하고 상단에 제안합니다.\n- 스크린샷이 수평으로 보일 경우 어느 쪽에 배치할지 물어봅니다. (와우!)\n- 여러 스크린샷을 선택하면 세로, 가로 또는 그리드 형식으로 원하는대로 출력물을 결합할 수 있습니다. 예시:\n\n![Example Image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_7.png)\n\n또는 여기에서 직접 다운로드하세요.\n\n## 3. Song.Link\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 Apple Music을 좋아하는 팬인데, 제 친구들 대부분은 Spotify를 사용해요. 특히 안드로이드 기기를 사용하는 친구들이 그렇더라고요.\n\n그래서 Apple Music에서 좋아하는 노래를 발견했을 때, 그 노래를 친구에게 공유하고 싶다면요. 그러나 친구가 Apple Music을 사용하지 않으니 그냥 직접 링크를 보내는 것은 의미가 없겠죠?\n\n또, 제가 Spotify에서 직접 검색하여 링크를 보내는 것은 조금 후하진 않아요.\n\n그래서 제가 하는 방법은 — Song.Link(바로 가기)로 그 노래를 공유하는 거예요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_8.png)\n\nIt does the mundane job of retrieving the song’s links from all popular music platforms like Spotify, YouTube, Pandora, Amazon, \u0026 SoundCloud.\n\nThen I click Spotify and directly share its link to him, simple!\n\n![Image 2](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_9.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가장 좋은 부분은 곡을 Song.Link에 입력하는 방법이 5가지나 있답니다:\n\n- 클립보드에 있는 링크를 통해,\n- Apple Music에서 \"Now Playing\"으로 재생 중인 곡을 통해,\n- Shazam을 이용해,\n- iTunes 스토어에서 검색해,\n- 또는 키보드로 URL을 입력해요.\n\n또는 직접 다운로드할 수도 있어요.\n\n# YouTube의 단축키\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## #4. SW-DLT\n\n내가 iPhone에서 YouTube 동영상을 다운로드하는 방법에 대해 알려줄게 — 엄청 쉬운 방법이야.\n\n우선, 설치해야 할 것이 있어. 바로 SW-DLT\\*와 두 앱 중 하나 — a-Shell 또는 a-Shell mini. 공간을 절약하려면 후자를 선호해.\n\n이제, 과정을 시작해보자:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Safari나 YouTube 앱에서 비디오를 열기\n- SW-DLT로 공유하기\n- '비디오 다운로드' 선택\n- 선호하는 품질과 프레임률 선택\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_10.png)\n\n그리고 비디오 다운로드가 시작됩니다…\n다운로드가 완료되면 즉시 시청할 수 있습니다. 저장하려면 공유`비디오 저장`을 클릭하십시오.\n\n무려 SW-DLT는 YouTube뿐만 아니라 다양한 웹사이트에서 미디어를 다운로드할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**YouTube PiP 기능은 SW-DLT -DL 도구를 위한 단축키 래퍼입니다.**\n\n- 비디오에서 오디오만,\n- 비디오 또는 오디오의 전체 재생 목록,\n- 전체 웹 페이지에서 미디어(GIF, 클립, 이미지)만.\n\n또는 직접 여기에서 다운로드하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nYouTube는 PiP(화면 안 화면) 기능을 프리미엄 구독자를 대상으로 한정했어요.\n\n만약 iPhone에서 무언가 다른 일(생산적인 일을 하길 희망합니다)을 하면서 영상을 시청하는 것을 선호한다면, 이 기능은 굉장히 편리할 거예요.\n\n돈을 지불하지 않고도 이를 실현하기 위한 해킹 방법이 있답니다 — YouTube PiP, 바로가기를 이용해보세요.\n\n- Safari나 YouTube 앱에서 동영상 열기\n- 'YouTube PiP'로 공유하기\n- 동영상 로드될 때까지 잠시 기다리기\n- 화면을 최소화하기.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 작업을 할 때 동영상이 계속 PiP로 재생됩니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_11.png)\n\n또는 여기에서 직접 다운로드할 수도 있어요.\n\nPS: 또 다른 방법으로 할 수 있는 방법이 있습니다 (앱을 사용하여) ↓\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# #6. 일부 알람 설정하기\n\n우리 인간들은 본질적으로 게으릅니다.\n그것에는 이유가 있습니다. 그것은 조상들이 에너지를 절약하여 다음 사냥을 위해 남긴 특성입니다.\n\n21세기에 있어서는 우리에게 불운이 될 때도 있습니다... 저는 종종 iPhone의 울리는 알람을 끄고 다시 누우면서 늦게 일어나는 바람에 느낍니다.\n\n그래서 나는 나를 괴롭히고 침대에서 일어나게끔 5분 간격으로 여러 개의 알람을 설정했습니다. - 그리고 많은 사람들이 비슷한 일을 한다고 확신합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자체적으로 모두 설정하는 대신 저는 이 바로가기를 사용해요: Set Some Alarms.\n\n이 바로가기를 사용하면\n\n- 특정 시간,\n- 설정할 총 알람 수,\n- 간격,\n- 알람이 지정된 시간에 시작할지 끝낼지를 선택할 수 있어요.\n\n그리고 다음 낮잠에서 깨워 줄 알람을 즉시 생성해 줘요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_12.png)\n\n요즘 내가 써본 최고의 부분은 첫 번째 알람이 울리기까지 얼마나 남았는지 보여준다는 거야 — MIUI를 사용했던 예전에도 좋아했던 기능이야.\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_13.png)\n\n# #7. DND 메뉴\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\niOS 및 macOS에서는 Do Not Disturb(또는 다른 포커스 모드)를 영구적으로 켜거나, 다음 세 가지 옵션에 따라 사용할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_14.png)\n\n안타깝게도 Apple은 이를 이벤트 종료 후 자동으로 꺼지거나 설정된 시간이 지난 후에 꺼지는 등의 기능을 기본적으로 허용하지 않습니다.\n\n그러나 DND Menu라는 바로 가기를 통해 이러한 기능을 사용할 수 있습니다. 이 바로 가기를 실행하면 두 가지 옵션을 볼 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_15.png)\n\n만약\n\n- 첫 번째 옵션을 선택하면, DND 포커스는 다음 캘린더 이벤트가 끝날 때까지 켜집니다.\n- 두 번째 옵션을 선택하면, DND가 유지될 시간을 설정할 수 있습니다.\n\n멋지죠!\n다음 20분 동안 집중하고 싶을 때나 30분 동안 주의를 집중시키고 싶을 때 큰 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해 드리겠습니다.\n\n또는 수정된 버전(제가 수정한 것)을 여기서 다운로드하세요.\n\n## #8. QR Anything\n\nQR Anything - 맞죠 - QR 코드로 거의 모든 것을 변환할 수 있습니다. 지원되는 형식:\n\n- Wi-Fi 네트워크\n- 이미지\n  (익명으로 Imgur에 업로드되고 해당 링크가 QR 코드로 변환됩니다)\n- URL\n- 텍스트\n- 클립보드 내용\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 트리거하면:\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_16.png)\n\nQR 코드로 변환하고 싶은 것을 선택하고 제공된 단계를 따라 주세요.\n\n만약 커피숍을 운영 중이라면, 고객들이 와이파이 비밀번호를 입력하는 데 어려움을 겪는 대신 네트워크를 위한 QR 코드를 만들어서 스캔하도록 하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혹시 링크를 QR 코드로 변환하고 친구를 속일 수도 있겠네요.\n\n그리고 더 좋은 점은, 어떤 것을 QR 코드로 변환하고 싶을 때는 'QR Anything'을 직접 공유 시트를 통해 공유하면 되니까, 바로 당신 스스로 단축키를 실행시킬 필요가 없다는 거죠.\n\n아니면 여기서 바로 다운로드도 받을 수 있어요.\n\n## 9. Google 번역\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGoogle 번역을 앱이나 웹사이트 없이 사용할 수 있는 단축키입니다. 무료 API를 이용하여 빠릅니다.\n\n이 단축키를 실행하면 자주 번역할 언어를 입력하라는 메시지가 표시됩니다. 이것은 나중에 바꿀 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_17.png)\n\n이제 번역을 시작하려면, 그냥 단축키를 실행하면 되요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 영어로 된 내용을 입력하세요,\n- 번역하고 싶은 언어를 선택하세요.\n\n그리고 1-2초 이내에 번역된 텍스트를 받게 됩니다. 복사 또는 공유할 수 있습니다.\n\n하지만, 만약 네덜란드어(또는 다른 언어)에서 번역하고 싶다면 이렇게 해보세요:\n\n\u003cimg src=\"/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_18.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 텍스트를 친절한 어조로 한국어로 번역하겠습니다:\n\n입력 텍스트: input_text\n언어: input_text_language\n\n위 내용을 포함한 딕셔너리를 만들어 ‘Google 번역’에 전달하십시오. 이제 이전과 같이 input_text를 원하는 언어로 번역할 수 있습니다.\n\n신기하죠?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서 바로 다운로드할 수도 있어요.\n\n## #10. PowerUtil\n\n내 iPhone 배터리가 새 것일 때의 성능의 80%를 유지하고 있는지 여부를 아시나요? 500번의 충전 주기를 거치면 그렇습니다.\n\n(충전 주기란 배터리가 100%와 동등한 수준으로 방전될 때를 의미합니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n충전 주기 수는 배터리 수명에 대해 걱정하는 사람이라면 추적해야 할 중요한 지표입니다.\n\n하지만 안타깝게도, Apple은 사용자들에게 액세스 권한을 제공하지 않는다. 죄송합니다. 아래는 iPhone 15 시리즈 사용자를 위한 정보가 있습니다.\n\n![이미지](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_19.png)\n\n음… 저는 iPhone 14 Pro Max를 사용 중이에요 (그리고 업그레이드할 확실한 이유가 없어요).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 아이폰 15 시리즈가 이를 표시하지 않는다는 것은 배터리 사이클을 추적하지 않는다는 것뿐만이 아닙니다. 그들은 하지만, 애플이 그들을 표시하지 않도록 프로그래밍했습니다.\n\n애플을 물어버려 .\n\n아이폰 15 시리즈를 사용하는 경우 배터리 사이클 수를 확인하는 방법은 다음과 같습니다:\n\n- 바로 가기인 PowerUtil을 설치합니다.\n- 설정으로 이동 ⚙️ `개인정보 및 보안 ✋` 분석 및 향상.\n- '아이폰 분석 공유' 아래의 '분석 데이터'를 클릭합니다.\n- 이름이 Analytics-20XX로 시작하는 (가장 최근의) 파일을 찾아 터치합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_20.png)\n\n- PowerUtil에 공유하기 (우측 상단의 공유 아이콘을 클릭하세요)\n\n![Image 2](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_21.png)\n\n- 이제 잠시 기다리고 나타나는 것을 확인해보세요. 여기엔 제 것이 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_22.png\" /\u003e\n\n와우! 멋져요! 내 배터리에 대한 정보를 보여주네요\n\n- 소비된 배터리 사이클 횟수,\n- 평균 온도,\n- 배터리 상태,\n  (설정에서 확인할 수 있습니다 ⚙️ `배터리 🔋` 배터리 상태 및 충전)\n- 더 정확한 배터리 상태.\n  (PowerUtil의 고유 알고리즘으로 계산됨)\n\n```js\n참고: 아이패드 사용자에게 더 유용할 수 있습니다 - 애플은 기본적으로 배터리 상태를 공개하지 않는 사용자들을 위한 것입니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n(Analytics-20XX 파일에는 Cycle Count, 평균 온도 및 배터리 상태가 깊숙한 곳에 기록되어 있습니다. 단축키를 사용하면 정규식을 이용하여 이를 찾아서 표시합니다.)\n\n그런데 배터리 사이클을 확인하는 데 이 정도의 노력이 정말 필요한가요? 왜 애플이 iPhone 15 사용자들을 위해 이를 표시할 수 없는지 이해가 안 가요?\n\n```js\n참고: 'iPhone Analytics 공유'가 켜져 있어야 합니다.\n```\n\n또는 여기에서 직접 다운로드할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# #11. Snap (Mac 전용)\n\n나는 항상 창 관리를 위해 앱들을 사용해 왔어요. Magnet, Moom, Mozaic, One Menu, Spectacle, Swish 같은 앱들 말이죠. 그런데 단축키만 있으면 가능하다는 생각은 한 번도 안 해봤어요.\n\nSnap을 만나봐요.\n\nSnap은 창 관리자의 경량화된 단축키 버전으로, 간단하게 보이지만 실제로는 복잡한 코드가 내장되어 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기 사용 방법이 있습니다:\n(먼저, 단축키에서 Snap을 마우스 오른쪽 버튼 클릭하고 ‘도크에 추가’를 클릭하십시오.)\n\n- 데스크톱에 활성 창을 유지합니다 (전체 화면이 아니고, 이름이 상단 왼쪽 구석에 Apple  로고 옆에 표시되는지 확인하십시오).\n- 도크에서 Snap을 트리거합니다.\n- 윈도우를 14가지 옵션 중 하나로 원하는 스냅 위치로 선택합니다:\n\n![snap](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_23.png)\n\n- 클릭하고 완료를 클릭합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그게 전부고, 창이 원하는 레이아웃에 맞게 자동으로 정렬됩니다. 제가 함께 한 내용 중 하나를 보여드릴게요:\n\n가장 좋은 부분은,\n\n- 정렬 위치를 변경하거나 원하지 않는 위치를 제거할 수 있습니다.\n- 스냅은 다른 바로 가기 키로부터 입력을 지원합니다:\n\n![image](/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_24.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n재밌는 사실:\nSnap은 MacStories가 주최한 Automation April 대회에서 \"최고의 Mac 바로 가기\"상을 수상했습니다.\n```\n\n또는 바로 여기에서 다운로드할 수도 있습니다.\n\n## 마음에 드셨나요? 더 많은 유용한 Apple 바로 가기를 원하시나요?\n\n## 마지막으로,\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면, Setapp에 가입하는 것을 고려해보세요. 매달 $9.99에 약 240개 이상의 멋진 앱을 소장할 수 있습니다. 이 앱을 개별로 구매하면 수백 달러가 들겠지요.\n\n- Setapp 여정을 시작하는 데 내 제휴 링크를 사용해보세요! (30일 동안 무료입니다)\n- Setapp에서 100개 이상의 최고의 macOS 앱 목록을 무료로 받아보세요.\n\n만약 이 이야기를 즐겼다면, 다른 사람들과 함께 새로운 이야기를 게시할 때마다 알림을 받기 위해 430명 이상의 구독자들에 합류해보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_0.png"},"coverImage":"/assets/img/2024-06-23-The11craziestandmostadvancedAppleshortcutsIveeverseen_0.png","tag":["Tech"],"readingTime":21},{"title":"SWIFT에서 STRUCT와 CLASS 비교 분석","description":"","date":"2024-06-23 01:38","slug":"2024-06-23-STRUCTvsCLASSinSWIFT","content":"\n스위프트에서는 Struct와 Class를 모두 사용하지만 언제 어떤 것을 사용해야 하는지와 그 차이점이 무엇인지 혼란스러울 수 있습니다. 이 둘 사이의 주요 차이점은 다음과 같습니다:\n\n![Struct vs Class in Swift](/assets/img/2024-06-23-STRUCTvsCLASSinSWIFT_0.png)\n\n구조체: 구조체는 값 타입으로, 각 인스턴스가 데이터의 고유한 복사본을 유지합니다. 한 인스턴스를 수정해도 다른 복사본에는 영향을 미치지 않습니다. Struct 인스턴스는 스택에 할당됩니다.\n\n더 나은 이해를 위해 예시를 살펴봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nstruct Person {\n    var name: String\n}\n\nvar person1 = Person(name: \"Joy\")\nvar person2 = person1\n\nprint(person1.name) //prints \"Joy\"\nprint(person2.name) //prints \"Joy\"\n\nperson2.name = \"Mary\"\n\nprint(person1.name)//prints \"Joy\"\nprint(person2.name)//prints \"Mary\"\n```\n\n위 예제에서는 Person의 인스턴스인 person1을 만들었습니다. 이제 person1의 데이터를 복사하여 새 인스턴스 person2가 생성됩니다. 이 시점에서 person1과 person2는 초기값이 같은 두 개의 별도 인스턴스입니다. 따라서 person2를 수정해도 person1에는 영향을 미치지 않습니다.\n\n클래스: 클래스는 참조 유형이며, 클래스 인스턴스를 할당할 때 메모리 내의 동일한 인스턴스에 대한 참조를 전달합니다. 어떤 인스턴스에서 변경을 가하면 동일한 메모리를 가리키고 있는 다른 모든 인스턴스에 영향을 줍니다. 클래스 인스턴스는 힙에 할당됩니다.\n\n더 나은 이해를 위해 위 예제를 클래스 관점에서 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass Person {\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n}\n\nvar person1 = Person(name: \"Joy\")\nvar person2 = person1\n\nprint(person1.name)//prints \"Joy\"\nprint(person2.name)//prints \"Joy\"\n\nperson2.name = \"Mary\"\n\nprint(person1.name)//prints \"Mary\"\nprint(person2.name)//prints \"Mary\"\n```\n\n위 예제에서 우리는 Person의 인스턴스를 person1로 만들었습니다. 이제 새로운 인스턴스 person2가 person1에서 생성되었습니다. 이 시점에서 person1과 person2는 참조 유형이므로 동일한 메모리 주소를 가리킵니다. 따라서 person2를 수정하면 person1에 영향을 미칠 것입니다.\n\n구조체: 구조체는 상속을 지원하지 않습니다. 다른 구조체로부터 속성, 메서드 및 함수를 상속받는 기능이 없습니다.\n\n```js\nstruct Person {\n    var name: String\n}\n\nstruct Employee: Person { // 컴파일 시간 오류\n    // 프로토콜을 통해 이에 접근 가능\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스: 클래스는 상속을 지원합니다. 다른 클래스로부터 속성, 메서드 및 기능을 상속할 수 있습니다.\n\n```js\nclass Employee: Person {\n\n    var employeeId: Int\n\n    init(employeeId: Int, name: String) {\n        self.employeeId = employeeId\n        super.init(name: name)\n    }\n}\n\nvar obj = Employee(employeeId: 20, name: \"Abhay\")\n```\n\n구조체: 구조체 인스턴스가 var로 선언되면 가변이 될 수 있지만, 인스턴스가 let으로 정의되면 수정할 수 없습니다. 즉, 불변입니다.\n\n```js\nstruct Person {\n    var name: String\n}\n\nlet person1 = Person(name: \"Joy\")\nperson1.name = \"Mary\"// 오류가 발생합니다\n\nvar person1 = Person(name: \"Joy\")\nperson1.name = \"Mary\"// 올바르게 작동하여 수정됩니다\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스(Class): let 또는 var로 선언된 클래스는 변경 가능(mutable)합니다.\n\n```js\nclass Person {\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n}\n\nlet person1 = Person(name: \"Joy\") || var person1 = Person(name: \"Joy\")\nperson1.name = \"Mary\" // 둘 다 동일하게 작동합니다\n```\n\n구조체(Struct): 사용자 정의 이니셜라이저를 제공하지 않으면 구조체는 기본 멤버 지정 이니셜라이저를 갖습니다. 사용자 정의 이니셜라이저를 정의할 수도 있습니다.\n\n```js\nstruct Person {\n    var name: String\n}\n\n또는\n\nstruct Person {\n    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\n\n// 둘 다 작동합니다\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n클래스: 클래스에서는 모든 프로퍼티가 초기화되어 있어야 오류가 발생하지 않도록 해야 합니다. 클래스에는 지정 이니셜라이저와 편의 이니셜라이저가 있습니다.\n\n```js\nclass Person {\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n}\n```\n\n불변하고 작고 간단한 데이터를 다룰 때는 구조체를 사용해야 합니다. 구조체는 더 안전하며 ARC(Automatic Reference Counting)와 힙 할당이 일어나지 않습니다.\n\n상속, 가변 또는 참조 프로퍼티가 필요한 경우 클래스를 사용합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-STRUCTvsCLASSinSWIFT_0.png"},"coverImage":"/assets/img/2024-06-23-STRUCTvsCLASSinSWIFT_0.png","tag":["Tech"],"readingTime":5}],"page":"23","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"23"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>