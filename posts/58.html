<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/58" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/58" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_buildManifest.js" defer=""></script><script src="/_next/static/JlBEgQDLGRx6DYlBnT8eD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="SwiftUI Photo Picker 앱을 PhotosUI로 만들기" href="/post/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI Photo Picker 앱을 PhotosUI로 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI Photo Picker 앱을 PhotosUI로 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI Photo Picker 앱을 PhotosUI로 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SwiftUI 얼럿alerts 사용 방법" href="/post/2024-05-27-SwiftUIHowtousealerts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SwiftUI 얼럿alerts 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SwiftUIHowtousealerts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SwiftUI 얼럿alerts 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">SwiftUI 얼럿alerts 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift 동시성 뒤엉킨 것들 풀어내기" href="/post/2024-05-27-SwiftConcurrencyUn-tangledup"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift 동시성 뒤엉킨 것들 풀어내기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift 동시성 뒤엉킨 것들 풀어내기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Swift 동시성 뒤엉킨 것들 풀어내기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기" href="/post/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="맵핑 대 이터러블 맵핑 간단히 해석하기" href="/post/2024-05-27-MappingsvsIterableMappingsSimplified"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="맵핑 대 이터러블 맵핑 간단히 해석하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="맵핑 대 이터러블 맵핑 간단히 해석하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">맵핑 대 이터러블 맵핑 간단히 해석하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요" href="/post/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기" href="/post/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="새로운 Kotlin 어노테이션 프로세서 KSP를 사용해보세요" href="/post/2024-05-27-KapttoKSP"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="새로운 Kotlin 어노테이션 프로세서 KSP를 사용해보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-KapttoKSP_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="새로운 Kotlin 어노테이션 프로세서 KSP를 사용해보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">새로운 Kotlin 어노테이션 프로세서 KSP를 사용해보세요</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ViewChild를 사용하지 말아요" href="/post/2024-05-27-StopusingViewChild"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ViewChild를 사용하지 말아요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-StopusingViewChild_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ViewChild를 사용하지 말아요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">ViewChild를 사용하지 말아요</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="APKTOOL을 사용하여 APK를 디컴파일하고 재컴파일하는 방법 초보자 안내" href="/post/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="APKTOOL을 사용하여 APK를 디컴파일하고 재컴파일하는 방법 초보자 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="APKTOOL을 사용하여 APK를 디컴파일하고 재컴파일하는 방법 초보자 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">APKTOOL을 사용하여 APK를 디컴파일하고 재컴파일하는 방법 초보자 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link posts_-active__YVJEi" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"SwiftUI Photo Picker 앱을 PhotosUI로 만들기","description":"","date":"2024-05-27 16:26","slug":"2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI","content":"\n![이미지](/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png)\n\nSwiftUI와 PhotosUI는 iOS 앱에서 풍부하고 인터랙티브한 사용자 인터페이스를 만드는 강력한 도구를 제공합니다. 이 튜토리얼에서는 사용자가 사진 라이브러리에서 사진을 선택하고 표시할 수 있는 앱을 만들겠습니다.\n\n# 프로젝트 설정\n\n- Xcode를 열고 새 SwiftUI 프로젝트를 생성합니다.\n- 프로젝트의 이름을 지정합니다 (예: \"PhotoPickerApp\").\n- 사용자 인터페이스로 SwiftUI를 선택하고 프로그래밍 언어로 Swift를 선택해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 코드 설명\n\n## 단계 1: 필요한 프레임워크 가져오기\n\n```js\nimport SwiftUI\nimport PhotosUI\n```\n\n- SwiftUI: 사용자 인터페이스를 구축하기 위한 프레임워크입니다.\n- PhotosUI: 사진 및 비디오 선택 및 관리를 위한 프레임워크입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2: 상태 변수 정의\n\n```js\nstruct ContentView: View {\n   @State private var selectedPhotos: [PhotosPickerItem] = []\n   @State private var images: [UIImage] = []\n   @State private var errorMessage: String?\n\n   // ... 나머지 코드\n}\n```\n\n- selectedPhotos: 선택된 사진 항목을 저장합니다.\n- images: 불러온 이미지를 저장합니다.\n- errorMessage: 발생한 오류 메시지를 저장합니다.\n\n## 단계 3: 메인 뷰 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```swift\nvar body: some View {\n    VStack {\n        Form {\n            photoPickerSection\n            imagesSection\n        }\n        if let errorMessage = errorMessage {\n            Text(errorMessage)\n                .foregroundColor(.red)\n                .padding()\n        }\n    }\n}\n```\n\n- VStack: 폼과 에러 메시지를 포함합니다.\n- Form: 사진 선택기와 이미지를 위한 섹션을 포함합니다.\n\n## 단계 4: 사진 선택기 섹션 정의\n\n```swift\nprivate var photoPickerSection: some View {\n    Section {\n        PhotosPicker(selection: $selectedPhotos, maxSelectionCount: 3, matching: .images) {\n            Label(\"사진 선택\", systemImage: \"photo\")\n        }\n        .onChange(of: selectedPhotos) { _ in\n            loadSelectedPhotos()\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- PhotosPicker: 사진을 선택하는 UI 구성 요소입니다.\n- selection: `selectedPhotos`에 바인딩됩니다.\n- maxSelectionCount: 선택을 3개의 사진으로 제한합니다.\n- matching: 이미지로 제한된 선택을 합니다.\n- .onChange: `selectedPhotos`이 변경될 때 `loadSelectedPhotos`를 호출합니다.\n\n## 단계 5: 이미지 섹션 정의하기\n\n```js\nprivate var imagesSection: some View {\n    Section {\n        ForEach(images, id: \\.self) { image in\n            Image(uiImage: image)\n                .resizable()\n                .scaledToFit()\n                .frame(maxWidth: .infinity)\n                .clipShape(RoundedRectangle(cornerRadius: 10.0))\n                .padding(.vertical, 10)\n        }\n    }\n}\n```\n\n- ForEach: `images` 배열을 반복합니다.\n- Image(uiImage:): 각 이미지를 표시합니다.\n- .resizable(), .scaledToFit(), .frame(maxWidth: .infinity), .clipShape(), .padding(): 이미지를 스타일링합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 6: 선택한 사진 불러오기\n\n```js\nprivate func loadSelectedPhotos() {\n    images.removeAll()\n    errorMessage = nil\n\n    Task {\n        await withTaskGroup(of: (UIImage?, Error?).self) { taskGroup in\n            for photoItem in selectedPhotos {\n                taskGroup.addTask {\n                    do {\n                        if let imageData = try await photoItem.loadTransferable(type: Data.self),\n                           let image = UIImage(data: imageData) {\n                            return (image, nil)\n                        }\n                        return (nil, nil)\n                    } catch {\n                        return (nil, error)\n                    }\n                }\n            }\n\n            for await result in taskGroup {\n                if let error = result.1 {\n                    errorMessage = \"한 개 이상의 이미지를 불러오지 못했습니다.\"\n                    break\n                } else if let image = result.0 {\n                    images.append(image)\n                }\n            }\n        }\n    }\n}\n```\n\n- images.removeAll(): 기존 이미지를 지웁니다.\n- errorMessage = nil: 오류 메시지를 초기화합니다.\n- Task: 비동기 작업을 시작합니다.\n- withTaskGroup: 사진을 로드하는 동시 작업을 관리합니다.\n- photoItem.loadTransferable(type: Data.self): 사진 데이터를 로드합니다.\n- UIImage(data: imageData): 데이터를 `UIImage`로 변환합니다.\n- errorMessage: 오류 발생 시 업데이트됩니다.\n- images.append(image): 로드된 이미지를 배열에 추가합니다.\n\n## 단계 7: 뷰 미리보기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Preview {\n    ContentView()\n}\n```\n\n- # Preview: Xcode 캔버스에서 `ContentView`를 미리 볼 수 있습니다.\n\n# 프로젝트 실행\n\n이제 프로젝트를 시뮬레이터나 실제 장치에 실행하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](https://miro.medium.com/v2/resize:fit:720/1*AtvjZ8d79WvKb85R-jBVVg.gif)\n\n# 요약\n\n이 튜토리얼은 사용자가 사진을 선택하고 표시할 수 있는 SwiftUI 앱을 만드는 방법을 안내했습니다. 상태 관리, 비동기 작업 및 이미지 처리를 다루었습니다. 이 앱은 사진 편집, 저장 또는 공유와 같은 추가 기능으로 확장할 수 있습니다. SwiftUI와 PhotosUI를 활용하여 앱의 기능과 사용자 경험을 향상시켜 보세요.\n\n즐거운 코딩되세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 완성된 코드\n\n이 저장소를 복제하거나 다운로드하여 완전한 코드를 확인하십시오.\n","ogImage":{"url":"/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png"},"coverImage":"/assets/img/2024-05-27-SwiftUIPhotoPickerAppwithPhotosUI_0.png","tag":["Tech"],"readingTime":7},{"title":"SwiftUI 얼럿alerts 사용 방법","description":"","date":"2024-05-27 16:25","slug":"2024-05-27-SwiftUIHowtousealerts","content":"\n\u003cimg src=\"/assets/img/2024-05-27-SwiftUIHowtousealerts_0.png\" /\u003e\n\n이 기사는 .alert()를 사용하여 사용자에게 뭔가를 확인하라는 팝업을 표시하는 방법을 보여줍니다.\n이것을 사용하는 방법은 iOS 15 이후 많이 변경되었습니다.\niOS 14 및 이전 버전의 알림을 사용하는 방법에 대한 자세한 정보는 아래를 참조하세요.\n\n- Environment\n- Basic Usage\n- Example of Use\n- Install Multiple Buttons\n- Specifying Button Display Style\n- Example of Use\n- Use Multiple Alerts\n\n# 환경\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사는 다음 버전을 사용합니다:\n\n- **Xcode** 13.0\n- **Swift** 5.5\n- **iOS** 15.0\n- **macOS** Big Sur 버전 11.6\n\n## 기초 사용법\n\nSwiftUI에서 코딩은 선언적이며 절차적이 아닙니다. 경고(alerts)도 이 규칙을 따릅니다. \"알림을 표시\"하는 단계별 프로세스를 코딩하는 대신, 경고를 정의하고 언제 나타날지를 정의합니다. 경고를 정의하려면 .alert() 수정자(modifier)를 사용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n.alert(\"제목\", isPresented: Binding\u003cbool\u003e, actions: { 액션 버튼 목록 }, message: { 메시지 })\n```\n\n또는\n\n```js\n.alert(\"제목\", isPresented: Binding\u003cbool\u003e) {\n     // 액션 버튼 목록\n} message: {\n     // 메시지\n}\n```\n\n“제목”\n제목에 표시할 텍스트를 지정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nisPresented\n알림이 표시될지를 결정하는 표시 플래그 변수입니다. 사용자가 알림 액션을 탭하면 표시 플래그가 자동으로 거짓으로 변경됩니다.\n\nActions\nButton() 목록을 사용하여 알림에 표시할 작업 버튼을 나열합니다. 특정 작업이 없는 경우 \"OK\" 버튼이 기본으로 표시됩니다. 알림의 모든 버튼은 닫히며, 표시 플래그를 거짓으로 설정합니다.\n\nmessages (선택 사항)\nText를 사용하여 제목 아래에 자세한 메시지를 설정할 수 있습니다. 그러나 스타일을 적용하거나 여러 Text를 표시할 수는 없습니다.\n\n# 사용 예제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서는 Button에 대해 alert 수정자가 설정되어 있지만, 직접적으로 해당 Button에 연결되어 있지는 않습니다. 경고는 Button 자체가 아닌 표시 플래그에 의해 제어됩니다.\n\n```js\nimport SwiftUI\n\nstruct AlertsBootCamp: View {\n\n    // MARK: - 속성\n    @State private var isShowAlert: Bool = false\n\n    // MARK: - 본문\n    var body: some View {\n        Button(action: {\n           isShowAlert = true\n        }, label: {\n            Text(\"알림 표시\")\n                .font(.headline)\n                .fontWeight(.bold)\n                .foregroundStyle(.white)\n                .padding()\n                .background(content: {\n                    RoundedRectangle(cornerRadius: 25.0, style: .continuous)\n                        .foregroundStyle(Color.black)\n                })\n        })\n        .alert(\"제목\", isPresented: $isShowAlert) {\n            Button(\"눌러주세요\") {\n                // 버튼이 눌릴 때 수행되는 작업\n            }\n        } message: {\n            Text(\"메시지\")\n        }\n    }\n}\n```\n\n![이미지](/assets/img/2024-05-27-SwiftUIHowtousealerts_1.png)\n\n# 여러 버튼 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport SwiftUI\n\nstruct AlertsBootCamp: View {\n\n    // MARK: - Properties\n    @State private var isShowAlert: Bool = false\n\n    // MARK: - Body\n    var body: some View {\n        Button(action: {\n           isShowAlert = true\n        }, label: {\n            Text(\"Display Alert\")\n                .font(.headline)\n                .fontWeight(.bold)\n                .foregroundStyle(.white)\n                .padding()\n                .background(content: {\n                    RoundedRectangle(cornerRadius: 25.0, style: .continuous)\n                        .foregroundStyle(Color.black)\n                })\n        })\n        .alert(\"Title\", isPresented: $isShowAlert) {\n            Button(\"Button 1\") {\n                // button 1 action will come here\n            }\n            Button(\"Button 2\") {\n                // button 2 action will come here\n            }\n        } message: {\n            Text(\"Message\")\n        }\n    }\n}\n```\n\n두 개의 버튼이 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-27-SwiftUIHowtousealerts_2.png\" /\u003e\n\n세 개 이상 설치하시면 아래와 같이 수직으로 배열됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3개의 버튼이 있는 테이블을 만들려면\n다음 Markdown 형식을 사용하실 수 있습니다.\n\n| Header1 | Header2 | Header3 |\n| ------- | ------- | ------- |\n| Data1   | Data2   | Data3   |\n| Data4   | Data5   | Data6   |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nButton(\"Title\", role: ButtonRole?, action: { action button })\n```\n\n3가지 유형을 지정할 수 있습니다:\n\n1. 취소\n\n2. 파괴성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 아무 값도 지정하지 않으면 버튼은 기본 스타일인 파란색으로 나타납니다.\n\n.cancel\n취소 버튼은 진한 파란색으로 스타일이 지정됩니다. 버튼이 두 개인 경우 항상 왼쪽에 위치하며, 세 개 이상인 경우에는 맨 아래에 위치합니다.\n\n.destructive\n이 스타일은 삭제와 같은 파괴적인 작업을 나타내며 빨간색으로 표시됩니다. 적어도 하나의 이 유형 버튼이 있는 경우 취소 버튼이 자동으로 추가됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 사용 예시\n\n버튼에 .destructive 역할을 부여하면 자동으로 취소 버튼이 추가됩니다.\n\n```js\nimport SwiftUI\n\nstruct AlertsBootCamp: View {\n\n    // MARK: - Properties\n    @State private var isShowAlert: Bool = false\n\n    // MARK: - Body\n    var body: some View {\n        Button(action: {\n            isShowAlert = true\n        }, label: {\n            Text(\"알림 표시\")\n                .font(.headline)\n                .fontWeight(.bold)\n                .foregroundStyle(.white)\n                .padding()\n                .background(content: {\n                    RoundedRectangle(cornerRadius: 25.0, style: .continuous)\n                        .foregroundStyle(Color.black)\n                })\n        })\n        .alert(\"제목\", isPresented: $isShowAlert) {\n\n            Button(\"삭제\", role: .destructive) {\n                // 동작이 여기에 들어갑니다.\n            }\n        } message: {\n            Text(\"메시지\")\n        }\n    }\n}\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-SwiftUIHowtousealerts_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 여러 경고 사용하기\n\n한 화면에 여러 경고를 사용하려면 여러 디스플레이 플래그 변수를 사용하세요.\niOS14 이전에는 특별한 조치가 필요했습니다.\n\n```js\nstruct ContentView: View {\n\n    // MARK: - Properties\n    @State private var isShowAlert1: Bool = false\n    @State private var isShowAlert2: Bool = false\n\n    // MARK: - Body\n    var body: some View {\n        VStack {\n            Button(\"경고 1 표시\") { isShowAlert1 = true }\n            Button(\"경고 2 표시\") { isShowAlert2 = true }\n        }\n        .alert(\"경고 1\", isPresented: $isShowAlert1) { }\n        .alert(\"경고 2\", isPresented: $isShowAlert2) { }\n    }\n}\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:590/1*y3FoT4bWzWZcph2TnxqMzg.gif\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-27-SwiftUIHowtousealerts_0.png"},"coverImage":"/assets/img/2024-05-27-SwiftUIHowtousealerts_0.png","tag":["Tech"],"readingTime":9},{"title":"Swift 동시성 뒤엉킨 것들 풀어내기","description":"","date":"2024-05-27 16:24","slug":"2024-05-27-SwiftConcurrencyUn-tangledup","content":"\n\u003cimg src=\"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png\" /\u003e\n\nSwift 5.5부터는 concurrent programming을 위해 async/await 접근 방식이 도입되어 비동기 작업 관리가 변경되었습니다. 이 방식은 올바르게 구현할 때 많은 이점을 제공하며 고려해야 할 사항도 몇 가지 있습니다.\n\n# 이것은 무엇인가요?\n\nConcurrency는 concurrent code를 처리하는 도구를 제공하는 라이브러리로, 이러한 도구는 쓰레드를 다룰 때 안전성을 제공하기 위한 것입니다. 이는 쓰레드를 관리할 때 발생하는 모든 종류의 문제를 포함하며, 흔한 문제 몇 가지를 들자면 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터 레이스(Data races). 여러 스레드가 동시에 동일한 데이터 조각에 액세스하여 조작하려고 할 때 발생합니다.\n- 데드락(Deadlocks). 여러 스레드가 서로가 완료되기를 기다리고 계속 지장을 일으킬 때 발생합니다.\n- 우선순위 역전(Priority inversion). 낮은 우선순위 작업이 높은 우선순위 작업의 실행을 차단할 때 발생합니다.\n\n## 병렬성 vs 순차성\n\n예제를 시작하기 전에, 이 주제 아래에서 두 가지 개념, 병렬성과 순차성을 이해해야 합니다.\n\n- 병렬 코드는 다른 작업이 끝나기를 기다릴 필요 없이 동시에 실행될 수 있는 코드입니다.\n- 순차 코드는 이전 결과가 완료되어야 다음 작업을 계속할 수 있는 코드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 구현 방법\n\n## 비동기 및 대기\n\n이 프레임워크는 두 가지 주요 키워드 async와 await를 사용합니다. 각각은 다른 목적으로 사용됩니다.\n\n- Async는 비동기 작업을 표시하는 데 주로 사용되며, 작업 내에서 가능한 비동기 기능을 노출하는 데도 사용됩니다. 다시 말해, async 메서드 안에는 비동기 작업이 포함될 수 있습니다.\n- Await은 현재 컨텍스트의 실행이 중지될 수 있는 가능성이 있는 중단 지점을 표시하는 데 사용되며, 그 시간 동안 리소스를 사용하여 다른 작업을 수행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 일반적인 데이터 가져오기 방법은 완료될 때까지 시간이 걸릴 수 있습니다. 왜냐하면 로컬이거나 클라우드인 데이터베이스에 도달해야 하기 때문이죠.\n\n```js\nfunc fetchData(completion: @escaping (Result\u003cData, Error\u003e) -\u003e Void) {\n    let url = URL(string: \"https://itunes.apple.com/search/media=music\u0026entity=song\u0026term=avicii\")!\n\n    URLSession.shared.dataTask(with: url) { data, response, error in\n        if let error {\n            return completion(.failure(error))\n        }\n        guard let data else {\n            return completion(.failure(URLError(.unknown)))\n        }\n        return completion(.success(data))\n    }.resume() // 항상 세션 작업을 재개하는 것을 기억하세요 :)\n}\n\nfetchData { result in\n    switch result {\n    case let .success(data):\n        print(\"Itunes 정보를 가져왔습니다: \\(data.description)\")\n    case let .failure(error):\n        print(\"문제가 발생했습니다: \\(error.localizedDescription)\")\n    }\n}\n\n// 출력: \"Itunes 정보를 가져왔습니다: 80075 bytes\"\n```\n\n이는 원격 서버에서 정보를 가져오는 비동기 작업을 완료하기 위해 기다리는 일반적인 패턴입니다. 완료 핸들러는 한 번 작업이 완료되면 호출되는 익명 함수(클로저)입니다. 그러나 이러한 패턴은 중첩된 클로저로 코드베이스를 쉽게 더럽힐 수 있습니다(콜백 지옥).\n\n비동기/대기 접근 방식을 사용하면 다음과 같이 개선될 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모든 시간이 걸릴 수 있는 작업 또는 다른 시간이 많이 소요되는 작업을 async로 표시하여 컴파일러가 가능한 비동기 작업을 알 수 있게 합니다.\n- await로 가능한 중단 지점을 찾아보세요. 이 경우 URLSession은 이미 async/await 버전의 dataTask(with:)를 제공합니다. async context 내에서 사용할 수 있으며 완료까지 시간이 소요됩니다.\n- 처리될 함수를 async context 내에서 호출하세요.\n\n```js\nfunc fetchData() async throws -\u003e Data { // 1\n    let url = URL(string: \"https://itunes.apple.com/search/media=music\u0026entity=song\u0026term=avicii\")!\n    let (data, _) = try await URLSession.shared.data(from: url) // 2\n    return data\n}\n\nTask { // 3\n    do {\n        let data = try await fetchData()\n        print(\"Itunes info has been retreived: \\(data.description)\")\n    } catch {\n        print(\"Something went wrong: \\(error.localizedDescription)\")\n    }\n}\n```\n\n여기 몇 가지 향상된 점이 있습니다:\n\n- 오류가 발생할 수 있는 가능성을 나타내기 위해 throws를 사용하세요.\n- 이러한 오류를 처리하세요(예: do-catch 블록 사용)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 혜택 및 고려 사항은 무엇인가요?\n\n이 기능은 많은 혜택을 제공하며, 구현할 때 고려해야 할 몇 가지 사항이 있습니다. async/await 방식을 사용하면\n\n- 가독성 개선. 주요 키워드를 쉽게 식별하고 특정 작업에서 무슨 일이 일어나고 있는지 이해할 수 있어 중첩 코드를 줄이고 유지보수성을 향상시킵니다.\n- 스레드 관리 오류 감소. 단순화된 접근 방식은 동기화 작업을 조작할 때 로직 오류를 줄이는 데 도움이 되어 신뢰성을 향상시킵니다.\n- 성능 향상. 동시성 코드 작성시의 정확성이 향상되어 컴파일러가 실행 시간이 아닌 컴파일 시간에 문제를 감지할 수 있습니다.\n\n## 고려 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 호환성. Async/Await을 사용하는 데 일부 우려 사항이 있는데, 이는 Swift 5.5부터 지원되며, 더 최신 버전은 사용법과 기능을 개선합니다.\n- Actors. 여러 동시 작업에서 액세스해서는 안 되는 기능을 격리하기 위해 액터의 사용을 고려해보세요.\n- 구조화된 및 구조화되지 않은 동시성. 그룹 및 오류 처리는 동시 작업의 사용 및 상호 작용을 조직화하는 데 도움이 되며, 반면 구조화되지 않은 작업은 자유롭지만 가능한 문제를 처리하기 위해 수동 지원이 필요합니다.\n\n# 결론\n\nSwift는 매년 업데이트로 발전하는 쓰레드 안전한 언어가 되고 있습니다. 더욱 명확한 문법을 제공하여 이해하고 유지하기 쉽게되었습니다. 이러한 라이브러리와 같은 특정 도구를 통해 개발을 개선할 수 있습니다. 이 모든 것은 모든 지원 플랫폼에서 사용할 수 있으며 특히 iOS, macOS 및 watchOS와 같은 플랫폼에서 운영 가능합니다.\n","ogImage":{"url":"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png"},"coverImage":"/assets/img/2024-05-27-SwiftConcurrencyUn-tangledup_0.png","tag":["Tech"],"readingTime":6},{"title":"100배 빠르게 - 수십억 개의 임베딩을 위한 RAG 앱 확장하기","description":"","date":"2024-05-27 16:21","slug":"2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings","content":"\n가장 큰 문제 중 하나는 RAG 어플리케이션의 연산 검색 시간입니다. 1조 개의 임베딩 벡터 기록이 있는 벡터 데이터베이스가 있다고 상상해보세요. 사용자 쿼리를 1조 개의 벡터와 일치시키려고 하면 올바른 정보를 검색하는 데 1분 이상이 걸릴 것입니다.\n\n시간을 단축하기 위해서는 사용자 쿼리 임베딩 벡터와 벡터 데이터베이스에 저장된 백만, 십억 또는 심지어 1조 개의 다른 임베딩 벡터 사이의 코사인 유사도를 계산하는 효율적인 방법을 찾아야 합니다.\n\nMIT 라이선스 하에 Chunkdot은 밀집(dense) 및 희소(sparse) 행렬에 대한 멀티 스레드 행렬 곱셈을 제공하기 위해 특별히 설계되었습니다. Numba를 사용하여 계산을 가속화하며 항목 행렬 표현(임베딩)을 세분화하여 대규모 항목에 대한 K개의 가장 유사한 항목을 계산하는 데 적합합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChunkdot GitHub 저장소\n\nHuggingFace에는 Qdrant의 이 데이터셋과 같이 백만 개 이상의 엔트리의 임베딩 벡터를 제공하는 다양한 데이터셋이 많이 있습니다. Chunkdot 성능을 테스트하는 데 사용할 수 있습니다. 그러나 세부 성능 측정을 위해 우리는 NumPy 라이브러리를 사용하여 여러 차원의 임의의 임베딩 벡터를 생성할 것입니다.\n\nChunkdot의 접근 방식과 코사인 유사도의 의사 코드를 비교할 것이며, 크기와 차원을 증가시킴으로써 성능이 어떻게 영향을 받는지 관찰할 것입니다. 이 작업에는 일관성을 보장하기 위해 Kaggle (GPU 없음) 노트북을 사용할 것입니다.\n\n본 블로그의 모든 코드는 제 GitHub 저장소에서 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 목차\n\n- 준비 단계 설정\n- 의사 코드 알고리즘 코딩\n- Chunkdot 알고리즘 코딩\n- 계산 시간 함수 코딩\n- 10k 벡터 임베딩에 대한 테스트\n- 100k 벡터 임베딩에 대한 테스트\n- 1 백만 벡터 임베딩에 대한 테스트\n- 확장성 영향 시각화\n- Chunkdot의 특징\n- 다음에 할 일\n\n# 준비 단계 설정\n\nChunkdot을 설치하려면 다른 라이브러리와 마찬가지인 유사한 설치 과정이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# chunkdot 설치하기\n\n```bash\npip install chunkdot\n```\n\n무엇이든 실행하기 전에 먼저 Kaggle 환경에서 사용 가능한 메모리를 확인해야 합니다.\n\n# 사용 가능한 메모리 확인하기\n\n```bash\n!free -h\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChunkdot 에게 사용 가능한 메모리를 확인하는 것은 매우 중요합니다. 벡터 데이터베이스 크기가 증가할수록 계산 메모리도 증가합니다. 사용 가능한 메모리를 초과하지 않도록 하려면 하드웨어의 남은 메모리를 모니터링하는 것이 중요합니다. 제 경우에는 버퍼/캐시를 제외하고 25GB의 여유 공간이 있습니다.\n\n필요한 라이브러리를 가져오겠습니다.\n\n```js\n# 행렬을 생성하기 위한 라이브러리\nimport numpy as np\n\n# chunkdot에서 코사인 유사도 모듈을 가져옵니다.\nfrom chunkdot import cosine_similarity_top_k\n\n# 계산 시간을 측정하기 위한 라이브러리\nimport timeit\n```\n\n# 코딩 의사 코드 알고리즘\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 데이터베이스나 로컬에 저장된 수백만 벡터들과 사용자 쿼리 벡터 간의 코사인 유사도를 계산하는 의사 코드 알고리즘을 만들어 볼게요.\n\n```js\ndef cosine_pseudocode(query_v, doc_v, num_indices):\n    \"\"\"\n    Embedding 벡터와 쿼리 벡터 간의 가장 높은 코사인 유사도 값을 가진 인덱스를 반환합니다.\n\n    매개변수:\n        query_v (numpy.ndarray): 쿼리 벡터.\n        doc_v (list of numpy.ndarray): Embedding 벡터의 목록.\n        num_indices (int): 반환할 상위 인덱스 개수.\n\n    반환값:\n        list of int: 가장 높은 코사인 유사도 값을 가진 인덱스들.\n    \"\"\"\n    cosine_similarities = []  # 코사인 유사도를 저장할 빈 리스트를 초기화합니다.\n\n    query_norm = np.linalg.norm(query_v)  # 쿼리 벡터의 노름을 계산합니다.\n\n    # 리스트에 있는 각 문서의 임베딩 벡터에 대해 반복합니다.\n    for vec in doc_v:\n        dot_product = np.dot(vec, query_v.T)  # 임베딩 벡터와 쿼리 벡터 간의 내적을 계산합니다.\n        embedding_norm = np.linalg.norm(vec)  # 임베딩 벡터의 노름을 계산합니다.\n        cosine_similarity = dot_product / (embedding_norm * query_norm)  # 코사인 유사도 계산\n        cosine_similarities.append(cosine_similarity)  # 코사인 유사도를 리스트에 추가합니다.\n\n    cosine_similarities = np.array(cosine_similarities)  # 리스트를 넘파이 배열로 변환합니다.\n\n    # 배열을 내림차순으로 정렬합니다.\n    sorted_array = sorted(range(len(cosine_similarities)), key=lambda i: cosine_similarities[i], reverse=True)\n\n    # 상위 num_indices 값을 가져옵니다.\n    top_indices = sorted_array[:num_indices]\n\n    # 가장 높은 코사인 유사도 값을 가진 인덱스를 반환합니다.\n    return top_indices\n```\n\n이 코사인 유사도 함수는 NumPy를 제외한 모든 라이브러리와 독립적으로 작동하며 세 가지 입력을 받습니다:\n\n- query_v는 사용자 쿼리의 임베딩 벡터입니다.\n- doc_v는 어딘가에 저장된 문서들의 임베딩 벡터들입니다.\n- num_indices는 유사한 상위 k결과로부터 문서의 인덱스 번호입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 코딩 Chunkdot 알고리즘\n\n의사코드 알고리즘을 코딩했으니, 다음 단계는 Chunkdot 코사인 유사도 함수를 코딩하는 것입니다.\n\n```js\ndef cosine_chunkdot(query_v, doc_v, num_indices, max_memory):\n    \"\"\"\n    청크닷 라이브러리를 사용하여 코사인 유사도를 계산합니다.\n\n    매개변수:\n        query_v (numpy.ndarray): 쿼리 벡터.\n        doc_v (numpy.ndarray): 임베딩 벡터 목록.\n        num_indices (int): 검색할 상위 인덱스 수.\n        max_memory (float): 사용할 최대 메모리.\n\n    반환값:\n        numpy.ndarray: 상위 k 인덱스.\n    \"\"\"\n\n    # 코사인 유사도 계산\n    cosine_array = cosine_similarity_top_k(embeddings=query_v, embeddings_right=doc_v,\n                                         top_k=num_indices, max_memory=max_memory)  # 청크닷을 사용하여 코사인 유사도 계산\n\n    # 상위 값의 인덱스 가져오기\n    top_indices = cosine_array.nonzero()[1]\n\n    # 상위 유사 결과 반환\n    return top_indices\n```\n\n이 Chunkdot 함수는 네 개의 입력을 받습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- query_v은 사용자 쿼리의 임베딩 벡터를 나타냅니다.\n- doc_v는 어딘가에 저장된 문서의 임베딩 벡터들을 나타냅니다.\n- num_indices는 유사한 상위 k개 결과에 대한 문서의 인덱스 번호를 나타냅니다.\n- max_memory는 계산에 사용할 수 있는 사용 가능한 메모리를 바이트 단위로 나타냅니다. 예를 들어, 1E9는 1GB를 의미하며, 10E9는 10GB를 의미합니다.\n\n두 함수를 샘플 데이터셋에서 테스트하여 출력을 관찰해보겠습니다.\n\n```js\ndoc_embeddings = np.random.randn(10, 100) # 10개의 문서 임베딩 (100차원)\n\nuser_query = np.random.rand(1, 100) # 1개의 사용자 쿼리 (100차원)\n\ntop_indices = 1 # 검색할 상위 인덱스 수\n\nmax_memory = 5E9 # 사용할 최대 메모리 (5GB)\n\n# 의사코드를 사용하여 가장 높은 코사인 유사도 값을 갖는 인덱스를 검색\nprint(\"의사코드를 사용한 상위 인덱스:\", cosine_pseudocode(user_query, doc_embeddings, top_indices))\n\n# chunkdot을 사용하여 가장 높은 코사인 유사도 값을 갖는 인덱스를 검색\nprint(\"chunkdot을 사용한 상위 인덱스:\", cosine_chunkdot(user_query, doc_embeddings, top_indices, max_memory))\n```\n\n```js\n### 출력 ###\n의사코드를 사용한 상위 인덱스: [4]\nchunkdot을 사용한 상위 인덱스: [4]\n### 출력 ###\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문서 임베딩에 대한 유사한 항목의 인덱스를 최고의 코사인 유사도를 기반으로 한 항목만 반환한다는 것을 의미하는 top_indices 매개변수를 1로 설정했습니다. 메모리 사용량을 5E9로 설정했는데, 이는 5GB와 동일합니다. 두 함수 모두 동일한 인덱스 4를 반환하여 두 함수를 정확하게 코딩했음을 나타냅니다.\n\n# 코딩 계산 시간 함수\n\n또한 이러한 두 함수에 의해 소요된 계산 시간을 측정할 수 있는 타이밍 함수를 만들어야 합니다.\n\n```js\n# 소요 시간 계산\ndef calculate_execution_time(query_v, doc_v, num_indices, max_memory, times):\n\n    # 의사코드 함수 실행에 걸리는 시간 계산\n    pseudocode_time = round(timeit.timeit(lambda: cosine_pseudocode(query_v, doc_v, num_indices), number=times), 5)\n\n    # chunkdot 함수 실행에 걸리는 시간 계산\n    chunkdot_time = round(timeit.timeit(lambda: cosine_chunkdot(query_v, doc_v, num_indices, max_memory), number=times), 5)\n\n    # 소요 시간 출력\n    print(\"의사코드 함수에 걸리는 시간:\", pseudocode_time, \"초\")\n    print(\"chunkdot 함수에 걸리는 시간:\", chunkdot_time, \"초\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 이미 이 함수로 전달되는 매개변수를 검토했습니다. 여기서 새로운 매개변수는 times입니다. 이 매개변수는 코드를 몇 번 실행할지를 함수에 알려줍니다. 더 큰 규모에서 Chunkdot 성능을 테스트해 봅시다.\n\n# 10,000 벡터 임베딩 테스트\n\n우리는 합리적인 수의 문서 임베딩인 10000개로 시작할 것입니다. 이는 소규모 도메인별 RAG 애플리케이션과 비교 가능합니다. 각 임베딩 벡터의 차원을 1536으로 설정했습니다. 이는 OpenAI 임베딩 모델 텍스트 임베딩-3-small과 동등합니다.\n\n각 접근 방식의 계산 시간을 계산하기 위해 각각 100번 실행하여 효율성을 테스트해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\ndoc_embeddings = np.random.randn(10000, 1536)  # 10K 문서 임베딩 (1536 차원)\n\nuser_query = np.random.rand(1, 1536)  # 사용자 쿼리 (1536 차원)\n\ntop_indices = 1  # 검색할 상위 인덱스 수\n\nmax_memory = 5E9  # 최대 메모리를 5GB로 설정\n\n# 함수 실행에 소요된 시간을 계산합니다.\ncalculate_execution_time(user_query, doc_embeddings, top_indices, max_memory, 100)\n```\n\n10,000개의 문서 임베딩, 1536 차원을 가진 두 알고리즘을 100번 실행한 결과는 다음과 같습니다:\n\n![그래프](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_2.png)\n\nChunkdot은 유사도 비교 코드와 비교해 더 많은 시간이 소요됩니다. 이는 Chunkdot이 먼저 청크를 생성하고 각 청크에서 계산을 수행한 후 병합하기 때문입니다. 따라서 이 소규모 예제에 대해서는 적합한 해결책이 아닐 수 있습니다. 그러나 나중에 더 큰 예제를 다룰 때 Chunkdot의 이점을 확인하게 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 100k 벡터 임베딩 테스트\n\n10천 개의 가상 코드 방식으로는 우리가 이긴다고 하지만, 이제는 문서 임베딩 벡터를 중형 규모의 RAG 응용 프로그램과 유사한 100K 벡터까지 늘려보겠습니다.\n\n각 방법에 대한 계산 시간을 계산해 봅시다. 이번에는 벡터의 수가 매우 많기 때문에 계산을 여러 번 수행할 필요가 없으므로 times 매개변수를 1로 설정하여 코드를 한 번 실행합니다.\n\n```js\ndoc_embeddings = np.random.randn(100000, 1536) # 100K 문서 임베딩 (1536 차원)\n\nuser_query = np.random.rand(1,1536) # 사용자 쿼리 (1536 차원)\n\ntop_indices = 1 # 반환할 상위 인덱스 수\n\nmax_memory = 5E9 # 최대 메모리를 5GB로 설정\n\ntimes = 1 # 함수를 실행할 횟수\n\n# 함수 실행 시간 계산\ncalculate_execution_time(user_query, doc_embeddings, top_indices, max_memory, times)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n100,000개의 문서 임베딩, 차원이 1536인 경우, 두 알고리즘을 한 번씩 실행하여 비교한 결과는 다음과 같습니다:\n\n![Comparison Chart](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_3.png)\n\nChunkdot은 의사코드에 비해 거의 절반의 시간이 소요됩니다. 이제 Chunkdot의 유망한 영향을 확인하고 있습니다.\n\n1백만 벡터 임베딩을 위한 테스트 중입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n백만 개의 임베딩을 다루는 작업 중에, 첫 번째로 확인해야 할 사항은 문서 임베딩 벡터가 얼마나 많은 메모리를 차지하는지입니다.\n\n```js\n# 1 백만 개의 문서 임베딩 (1536 차원)\ndoc_embeddings = np.random.randn(1000000, 1536)\n\n# 사용자 쿼리 (1536 차원)\nuser_query = np.random.rand(1, 1536)\n\n# doc_embeddings와 user_query 임베딩의 메모리 크기 확인\nprint(doc_embeddings.nbytes / (1024 * 1024 * 1024),\n      user_query.nbytes / (1024 * 1024))\n```\n\n![이미지](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_4.png)\n\n저희 문서 임베딩은 대략 12GB를 차지합니다. 남은 공간을 확인해 보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_5.png)\n\n17GB의 사용 가능한 메모리가 있습니다. 어떠한 메모리 오류도 피하기 위해 max_memory 매개변수의 안전한 값을 12GB로 설정할 것입니다. 결과를 확인해 봅시다.\n\n```js\n# 100만 개의 문서 임베딩 (1536 차원)\ndoc_embeddings = np.random.randn(1000000, 1536)\n\n# 사용자 쿼리 (1536 차원)\nuser_query = np.random.rand(1, 1536)\n\ntop_indices = 1 # 가져올 상위 인덱스 수\n\nmax_memory = 12E9 # 최대 메모리 설정 --- 12GB ---\n\ntimes = 1 # 함수를 실행할 횟수\n\n# 함수 실행 시간 계산하기\ncalculate_execution_time(user_query, doc_embeddings, top_indices, max_memory, times)\n```\n\n![image](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChunkDot은 실제로 계산을 효과적으로 줄입니다. 진지한 RAG 앱을 만들려면 적어도 백만 개의 쿼리부터 시작하는 것이 좋습니다. 높은 차원의 임베딩 모델로 작업을하는 경우 4000까지 증가합니다. 이 접근 방식은 훨씬 더 효율적이어질 것입니다.\n\n# 확장성 영향 시각화\n\n문서 임베딩 벡터 수를 증가시키는 영향을 시각화해 보겠습니다. 시작은 10,000부터 매우 큰 수까지입니다.\n\n![이미지](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 세 가지 방법을 그래프로 나타내었고, 문서 임베딩의 수를 늘릴 때 Chunkdot이 모든 방법 중에서 가장 우수하다는 것을 확인했습니다. 이제 임베딩 벡터의 차원이 계산 시간에 어떤 영향을 미치는지 살펴보겠습니다.\n\n![Embedding Vectors Computation Time](/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_8.png)\n\n벡터의 차원을 늘리면서 10만 개의 문서를 사용했고, 문서 수를 늘릴 때 관찰한 현상과 동일한 결과를 얻었습니다.\n\n# Chunkdot의 특징\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nChunkdot에는 진행 표시 막대를 표시할 수 있는 기능이 있어서 얼마만큼의 계산이 남았는지 추적할 수 있습니다.\n\n```js\ndoc_embeddings = np.random.randn(100000, 1536) # 100K document embeddings (1536 dim)\n\nuser_query = np.random.rand(1,1536) # user query (1536 dim)\n\ntop_indices = 100 # 검색할 상위 인덱스 수\n\nmax_memory = 5E9 # 최대 메모리를 5GB로 설정\n\n# 진행 표시 막대와 함께\noutput_array = cosine_similarity_top_k(user_query, doc_embeddings,\n                        top_k=top_indices,\n                        show_progress=True)\n```\n\n![진행 표시 막대](https://miro.medium.com/v2/resize:fit:1400/1*3A2KQ9fDvAA-VfQNKjphJw.gif)\n\nChunkdot의 출력은 희소 행렬이며, 다음을 사용하여 배열로 변환할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 출력 변환\n\noutput_array.toarray()\n\nChunkdot은 문서 임베딩에 대해서만 사용할 수 있습니다. 이는 각 문서 임베딩 요소에 대해 가장 유사한 상위 k개 요소를 반환할 것입니다.\n\n# 총 5개의 문서 임베딩\n\nembeddings = np.random.randn(5, 256)\n\n# 각각의 상위 2개 가장 유사한 항목 인덱스 반환\n\ncosine_similarity_top_k(embeddings, top_k=2).toarray()\n\n### 출력\n\narray([[1.        , 0.        , 0.        , 0.        , 0.09924064],\n       [0.        , 1.        , 0.        , 0.09935381, 0.        ],\n       [0.02358785, 0.        , 1.        , 0.        , 0.        ],\n       [0.        , 0.09935381, 0.        , 1.        , 0.        ],\n       [0.09924064, 0.        , 0.        , 0.        , 1.]]\n\n### 출력\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비슷한 방법으로 top_k 매개변수에 음수 값을 제공하여 가장 다른 항목을 반환할 수도 있습니다.\n\n```js\n# 총 5개의 문서 임베딩\nembeddings = np.random.randn(5, 256)\n\n# 각 항목의 가장 다른 상위 2개 항목 인덱스 반환\n# Top_K = -2\ncosine_similarity_top_k(embeddings, top_k=-2).toarray()\n```\n\n```js\n### 출력 ###\narray([[ 0.        ,  0.        , -0.04357524,  0.        , -0.05118288],\n       [ 0.        ,  0.        ,  0.        ,  0.01619543, -0.01836534],\n       [-0.04357524,  0.        ,  0.        , -0.02466613,  0.        ],\n       [ 0.        ,  0.01619543, -0.02466613,  0.        ,  0.        ],\n       [-0.05118288, -0.01836534,  0.        ,  0.        ,  0.        ]])\n### 출력 ###\n```\n\n당신의 상황이 아닐 수도 있지만, 1만 차원까지의 희소한 임베딩을 처리하는 경우 density 매개변수를 사용하여 계산을 더 효율적으로 줄일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 희소 임베딩 생성을 위해\nfrom scipy import sparse\n\n# 각각 10,000 차원을 가진 100,000개의 문서로 이루어진 희소 매트릭스 생성\n# 밀도를 0.005로 정의\n임베딩 = sparse.rand(100000, 10000, density=0.005)\n\n# 시스템의 모든 메모리 사용\n코사인 유사도 상위 k(embeddings, top_k=50)\n```\n\n# 다음 단계\n\nChunkdot 알고리즘이 어떻게 작동하는지 알고 싶다면, 저자의 멋진 블로그를 확인해보세요. Chunkdot의 가장 큰 장점 중 하나는 CPU 코어에서 작동한다는 것입니다. 앞으로, GPU 지원을 통합할 계획이 있으며, 이는 연산에 소요되는 시간을 크게 줄일 것입니다. 로컬 환경에 충분한 RAM이 없는 경우에는 Kaggle이나 GitHub Codespaces 같은 플랫폼을 활용할 수 있습니다. 이러한 클라우드 CPU 코어와 RAM은 GPU 비용에 비해 매우 저렴합니다. Chunkdot가 어떻게 작동하는지를 잘 설명한 공식 GitHub 저장소와 블로그도 꼭 확인해보세요.\n","ogImage":{"url":"/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_0.png"},"coverImage":"/assets/img/2024-05-27-100xFasterScalingYourRAGAppforBillionsofEmbeddings_0.png","tag":["Tech"],"readingTime":17},{"title":"맵핑 대 이터러블 맵핑 간단히 해석하기","description":"","date":"2024-05-27 16:20","slug":"2024-05-27-MappingsvsIterableMappingsSimplified","content":"\n안녕하세요! 모두들! 저는 모든 것을 간단하게 만들어 설명해드릴게요. 데이터 구조가 어떻게 작동하는지 설명하는 글이 정말 많죠. 하지만 여기서는 조금 더 쉽게 설명할 거에요. 이 글을 끝까지 읽어보시면 제대로 이해하실 거에요. 확실해요💯.\n\n![이미지](/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png)\n\n# 표준 Mapping\n\nMappings이 뭔가요? 하하, 제가 어이가 없네요! Solidity에서의 Mappings은 간단한 전화번호부와 같아요. 사람의 이름을 통해 전화번호를 찾을 수 있지만, 전화번호를 통해 이름을 찾을 수는 없어요. (Mapping이라고 말할 때는 표준 Mapping을 의미합니다 😉) 지금쯤 완전 쉽다고 생각하셨을 거예요. 그래요, 이렇게 말해볼게요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n매핑은 Solidity에서 키-값 데이터 구조입니다. 고유한 키를 기반으로 값을 저장하고 검색할 수 있습니다. 주로 고유한 이더리움 주소와 다양한 값 유형을 연결하는 데 사용되어, 스마트 계약에서 데이터를 관리하는 데 필수적인 도구입니다.\n\n# 매핑의 종류\n\n간단한 매핑:\n\n간단한 매핑의 예제를 살펴봅시다. 이곳에서는 이더리움 주소와 해당 잔액 간의 연결을 만들고 있습니다. 이를 \"잔액(balances)\"이라는 매핑으로 부르겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n매핑 :address =\u003e uint) public balances;\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_1.png\" /\u003e\n\n컨트랙트인 SimpleMapping을 살펴보겠습니다.\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ncontract SimpleMapping {\n    mapping(address =\u003e uint) public balances;\n\n    function setBalance(address _user, uint _balance) public {\n        balances[_user] = _balance;\n    }\n\n    function getBalance(address _user) public view returns (uint) {\n        return balances[_user];\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 배포된 계약의 스크린샷입니다. 'setBalance' 함수를 호출할 때 이더리움 주소와 해당 잔고를 제공했습니다. 'getBalance'에서는 그 이더리움 주소의 잔고를 검색했습니다.\n\n![contract-screenshot](/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_2.png)\n\nSolidity에서 매핑을 선언할 때 주의할 점:\n\n- 사실상 두 값 사이의 연결을 만드는 것입니다.\n- 매핑에서 키를 사용하여 해당 값을 찾을 수 있지만, 역은 찾을 수 없습니다. 즉, 값을 사용하여 키를 찾을 수는 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n중첩 매핑:\n\n이제 중첩 매핑에 대해 알아보겠습니다. 두 개의 이더리움 주소와 불리언 값 사이의 링크를 생성 중입니다. 불리언 값이 true이면, 두 주소는 관련이 있습니다.\n\n```js\nmapping(address =\u003e mapping(address =\u003e bool)) public isRelated;\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_3.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 아래는 'NestedMapping' 계약에 대한 정보입니다.\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ncontract NestedMapping {\n    mapping(address =\u003e mapping(address =\u003e bool)) public isRelated;\n\n    function setRelationship(address _user1, address _user2, bool _isRelated) public {\n        isRelated[_user1][_user2] = _isRelated;\n    }\n\n    function checkRelationship(address _user1, address _user2) public view returns (bool) {\n        return isRelated[_user1][_user2];\n    }\n}\n```\n\n배포된 계약의 스크린샷을 아래에서 확인할 수 있습니다. 'setRelationship' 함수를 사용하여 두 이더리움 주소 및 false 값을 제공하였습니다. 'checkRelationship' 함수에서 해당 중첩 매핑의 부울 값을 검색하였습니다.\n\n![매핑 이미지](/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한 중첩된 매핑의 경우:\n\n- 순서가 중요합니다.\n- \\_user1에 값 설정 후 \\_user2에 값 설정하는 것은 자동으로 \\_user2에 값 설정 후 \\_user1에 값 설정하는 것을 의미하지 않습니다.\n\n# 반복 가능한 매핑\n\n반복 가능한 매핑이란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n반복 가능한 매핑은 모든 이름과 전화번호를 나열할 수 있는 향상된 전화번호부와 같습니다. 이름으로 전화번호를 찾을 수는 있지만 모든 항목을 하나씩 차례대로 확인할 수도 있습니다.\n\n주요 포인트:\n\n- 양방향 상호작용: 키로 값을 찾거나 모든 키를 나열할 수 있습니다.\n- 더 많은 제어: 보다 복잡한 작업을 수행할 수 있습니다. 예를 들어 보고서 생성이나 모든 항목에 대한 작업 수행 등이 가능합니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ncontract IterableMapping {\n\n    mapping(address =\u003e uint) private balances;\n\n    address[] private keys;\n\n    mapping(address =\u003e bool) private isKey;\n\n    function setBalance(address _user, uint _balance) public {\n        if (!isKey[_user]) {\n            keys.push(_user);\n            isKey[_user] = true;\n        }\n        balances[_user] = _balance;\n    }\n\n    function getBalance(address _user) public view returns (uint) {\n        return balances[_user];\n    }\n\n    function getAllKeys() public view returns (address[] memory) {\n        return keys;\n    }\n}\n```\n\n배포된 스마트 계약의 스크린샷이 아래에 있습니다. ‘getAllKeys’ 함수를 호출했습니다. 현재 ‘keys’ 배열에 저장된 모든 키를 반환해야 합니다. 이는 Iterable Mapping을 사용하여 가능한 내용 중 하나에 불과합니다… 모두 나열했습니다.\n\n\u003cimg src=\"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_5.png\" /\u003e\n\n# 왜 Iterable Mappings를 사용해야 하는가?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 모든 것 나열하기: 모든 항목을 보고 싶을 때 반복 가능한 매핑을 사용할 수 있어요. 예를 들어, 모든 토큰 소지자를 나열하는 경우입니다.\n- 복잡한 작업: 모든 항목에 작업을 수행할 수 있도록해주어, 모든 사용자에게 보상을 분배하는 것과 같은 작업을 수행할 수 있어요.\n\n각각을 사용하는 시점:\n\n- 표준 매핑: 간단하고 빠른 조회가 필요하며 모든 항목을 나열할 필요가 없는 경우에 사용하세요. 예를 들어, 사용자의 잔고를 확인하는 경우입니다.\n- 반복 가능한 매핑: 모든 항목을 나열하거나 관리해야 할 때 사용하세요. 예를 들어, 모든 사용자의 잔액을 처리하는 경우입니다.\n\n# 비교 요약\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003ctable\u003e 태그를 Markdown 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해 주세요!\n","ogImage":{"url":"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png"},"coverImage":"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png","tag":["Tech"],"readingTime":8},{"title":"한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요","description":"","date":"2024-05-27 16:18","slug":"2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode","content":"\n![이미지](/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png)\n\n데코레이터를 작성하고 싶지만 구문을 기억하지 못하시나요? 데코레이터는 많은 보일러플레이트 코드가 포함된 꽤 어려운 구문을 갖고 있습니다. 이 기사에서는 데코레이터를 작성하는 더 간단한 방법을 소개합니다. 이 새로운 방법은 훨씬 더 짧고 명확하며 가독성이 뛰어날 것입니다. 함께 코딩해봅시다!\n\n# 데코레이터 작성의 기본 방법\n\n아래 코드는 데코레이터를 생성하는 기본 방법입니다. 데코레이터로 래핑된 함수가 실행되는 시간을 측정합니다. 깊이 파고든 이 기사를 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndef timer(name:str) -\u003e Callable:\ndef decorator(func:Callable) -\u003e Callable:\n@wraps(func)\ndef decorator_implementation(*args, \\*\\*kwargs):\ntry:\nprint(f\"TIMER: {name} start\")\nstrt = time.perf_counter()\nreturn func(*args, \\*\\*kwargs)\nfinally:\nprint(f\"TIMER: {name} finished in {time.perf_counter() - strt}\")\nreturn decorator_implementation\nreturn decorator\n\n이렇게 하면 코드를 다음과 같이 사용할 수 있습니다:\n\n```js\n@timer(name=\"test\")\ndef my_func(name:str, age:int) -\u003e str:\n    return f\"{name} is {age} years old\"\n\nmy_func(name=\"mike\", age=34)\n# TIMER:   test start\n# mike is 34 years old\n# TIMER:   test finished in 5.299999999998532e-06\n```\n\n## 이 접근 방식의 문제점은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 개발자이며 개인적으로 데코레이터를 작성하는 방법을 항상 기억하지 못하고 이전 프로젝트에서 코드를 복사하여 붙여넣어야 합니다. 이는 3개의 중첩된 함수가 포함된 약간 읽기 어려운 구문 때문에 데코레이터를 이해하기 어렵게 만들기 때문이라고 생각합니다. 우리는 이를 어떻게 단순화할 수 있는지 알아보겠습니다.\n\n# 데코레이터를 작성하는 더 쉬운 방법\n\n아래 구현은 이전 섹션의 데코레이터와 정확히 동일한 작업을 하지만 한 가지 함수만 사용합니다. 이는 훨씬 더 읽기 쉽고 @contextmanager 데코레이터를 추가하고 함수를 생성기로 변환하는 것으로 처리됩니다.\n\n```python\n@contextmanager\ndef timer(name:str) -\u003e Generator:\n    try:\n        print(f\"TIMER:   {name} start\")\n        strt = time.perf_counter()\n        yield\n    finally:\n        print(f\"TIMER:   {name} finished in {time.perf_counter() - strt}\")\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모두 같은 방식으로 함수를 사용할 수 있어요:\n\n```js\n@timer(name=\"AS DEC\")\ndef my_func(name:str, age:int) -\u003e str:\n    return f\"{name}은(는) {age}살이야\"\n\n\nmy_func(name=\"마이크\", age=34)\n# TIMER:   AS DEC 시작\n# 마이크은(는) 34살이야\n# TIMER:   AS DEC 5.399999999995686e-06초 내에 완료됨\n```\n\n## 컨텍스트 매니저로서의 기능\n\n개인적으로 새로운 함수가 더 읽기 쉽고 이해하기 쉽다고 생각해요. 몇 가지 간단한 변경이 필요하지만 그만큼 다양한 기능을 제공해요. 함수에 데코레이터를 적용하는 것이 훨씬 쉬워지고 데코레이터 함수(예: 위의 timer)를 데코레이터 및 컨텍스트 매니저로 모두 사용할 수도 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n타이머와 함께(context manager와 함께)\n\n우리는 동일한 데코레이터 함수를 데코레이터 및 context-manager로도 사용할 수 있습니다.\n\n```js\nas ctx라는 이름의 타이머와 함께:\n    fn_with_ctx_decorator(name=\"john\", age=42)\n    print(\"컨텍스트 매니저 내부\")\n\n# 타이머:  as ctx 시작\n# 타이머:  AS DEC 시작\n# john은 42살입니다\n# 타이머:  AS DEC가 3.7000000000023126e-06초에 완료되었습니다\n# 컨텍스트 매니저 내부\n# 타이머:  as ctx가 3.0000000000002247e-05초에 완료되었습니다\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 어떻게 작동합니까?\n\n내부적으로 contextlib은 @contextmanager를 사용하여 우리의 데커레이터 함수를 감싸서 데커레이터와 컨텍스트 매니저 역할을 하는 객체로 만들어줍니다. 이 작업 방식은 꽤 기술적이고 매우 흥미로우며 독립된 기사가 필요합니다. 계속 따라와주세요!\n\n이 기사의 범위에서는 contextlib이 @contextmanager 데코레이터를 사용하여 데커레이터 함수를 데커레이터와 컨텍스트 매니저로 모두 사용할 수 있는 객체로 변환한다는 것만 알면 됩니다.\n\n## 단점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새 데코레이터는 많은 기능을 제공하지만 몇 가지 단점이 있습니다. 그 중 가장 중요한 것은 데코레이터 함수 내에서 실제로 데코레이션하는 함수에 액세스할 수 없다는 점입니다. 또한 해당 함수의 args와 kwargs에 액세스할 수도 없습니다. 이로 인해 이러한 변수를 수정할 수 없지만 제 생각에는 이를 드물게 해야 하는 것입니다.\n\n두 번째 단점은 데코레이터 함수가 제너레이터 함수여야 한다는 점입니다. 이는 해당 함수가 본문에서 어딘가에 yield해야 한다는 의미입니다. 이로 인해 코드를 다시 작성해야 할 수도 있습니다.\n\n# 결론\n\n@contextmanager를 사용하면 데코레이터를 쉽고 가독성있게 작성할 수 있습니다. 많은 쓰기 장치를 처리해주며 심지어 콘텍스트 매니저 역할도 수행합니다. 그러나 이 자동화와 \"하드코딩된 마법\"으로 인해 함수와 인수에 액세스할 수 있는 제어를 일부 상실하게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ncontextlib은 내부에서 작동하는 방식이 상당히 복잡하며 별도의 기사가 필요하므로 관심이 있다면 저를 따라오세요!\n\n이 기사가 제가 희망하는 대로 명확하게 전달되었기를 바라지만, 그렇지 않은 경우 추가 설명이 필요하다면 알려주세요. 그동안 다른 주제들에 대한 제 다른 기사들도 확인해보세요:\n\n- 절대 초보자를 위한 Git: 비디오 게임의 도움으로 Git 이해하기\n- 나만의 Python 패키지 작성 및 게시\n- FastAPI를 사용해 5줄의 코드로 빠르고 자동 문서화되고 유지보수 가능한 쉽게 사용할 수 있는 Python API 만들기\n\n즐거운 코딩 되세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Mike\n\nP.S: 제 하는 일 좋아하시나요? 제 팔로우 해주세요!\n","ogImage":{"url":"/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png"},"coverImage":"/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png","tag":["Tech"],"readingTime":6},{"title":"단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기","description":"","date":"2024-05-27 16:17","slug":"2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness","content":"\n![unit test image](/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png)\n\n저는 전문적인 코딩을 시작한 이후로 단위 테스트를 작성해 왔어요. 그 속에는 특별한 \"영감\"이 있죠. 다른 개발자가 여러분의 코드를 사용해야 한다는 점을 생각하게 만들어요.\n\n그 \"다른 개발자\"가 바로 여러분의 미래 자신이기도 해요.\n\n단위 테스트를 작성할 때마다, 정확성을 검증할 뿐만 아니라 클래스의 작업 편의성도 평가하려고 해요. 좋은 코드를 작성하는 중요한 측면 중 하나는 함께 작업하기 즐거운 코드를 작성하는 것이라고 생각해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 전반적인 시스템의 정확성을 검증하는 것은 단위 테스트가 갖고 있지 않은 특징입니다.\n\n단위 테스트를 작성하는 데 드는 비용은 매우 적습니다. 기대되는 결과를 빠르게 작성, 실행 및 확인할 수 있습니다. 그러나 다른 측면에서도 저렴하다고 할 수 있습니다. 단위 테스트는 실제로 발생할 수 있는 프로덕션에서 발생할 수 있는 버그를 잡는 데는 거의 충분하지 않습니다.\n\n🔔 이와 유사한 기사를 더 보고 싶으시면 여기에서 가입하세요.\n\n매우 제어된 상황에서 고립된 상태로 작동하는 것을 본다는 것은 여러 협업 객체, 다양한 사용 사례 등이 포함된 더 큰 환경에서 작동하는 것을 보는 것과는 전혀 다릅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n의존성을 경멸하는 것은 재앙의 길이 될 수 있습니다. 그리고 내 경험상, 데이터베이스와의 상호 작용을 모의하는 경우에는 특히 그렇습니다.\n\n이 유닛 테스트를 분석해 보세요. 우리는 \"UserManager\"를 통해 사용자를 저장하는 것을 확인하려고 합니다.\n\n```js\n[Fact]\npublic void SaveNewUser()\n{\n   // Arrange\n   var repository = Substitute.For\u003cIUserRepository\u003e();\n\n\n   var user = new User();\n   var sut = new UserManager(repository);\n\n   // Act\n   sut.SaveUser(user);\n\n   // Assert\n   repository.Received(1).SaveUser(Arg.Any\u003cUser\u003e());\n}\n```\n\n이것은 투명하고 화이트박스 테스트입니다. UserManager는 실제 저장을 협력자 \"IUserRepository\"에 위임하고 있으며, \"UserManager\"가 \"SaveUser\" 메서드를 호출하는지 확인합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 아무 것도 테스트하지 않는 종류의 단위 테스트입니다. 아무 것도 확인하지 않으며 확신을 줄 수도 없습니다.\n\n우리는 모든 것이 잘되도록 하려는 중입니다.\n\n이러한 테스트는 무언가를 확실히 해서 빌드 서버에서 코드 품질 단계를 통과시키는 임의의 코드 커버리지 목표를 충족하는 데로 인해 우리를 기분 좋게 만들어 줍니다. 하지만 실제로는 일이 잘 되고 있다는 빈 약속일 뿐입니다.\n\n만약 당신의 코드베이스에 제가 방금 보여준 것과 유사한 테스트가 있다면, 그것은 당신에게 큰 문제가 있을 수 있다는 것을 의미합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 \"사용자\" 테이블이 이렇게 생겼다고 가정해 봅시다.\n\n```js\n-- PostgreSQL\nCREATE TABLE \"Users\" (\n   \"Id\" uuid NOT NULL,\n   \"Name\" text NOT NULL,\n\n   -- 그리고 다른 많은 열들\n\n   CONSTRAINT \"PK_Users\" PRIMARY KEY (\"Id\")\n);\n```\n\n그럼 \"Id\"나 \"Name\"이 없이 만들어진 사용자를 저장하려고 하면 예외가 발생하게 되어, 모든 것이 정상적으로 작동되고 있다고 생각하는 것을 방지할 수 있습니다.\n\n```js\nvar user = new User(); // 저장되지 않아야 함\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 분명히 클래스와 협력자 간의 상호 작용이 매우 적은 간단한 예제입니다. 그러나 단위 테스트에 무작정 의존하는 함정을 보여줍니다.\n\n🔔 이와 유사한 기사를 더 보시려면 여기에서 가입하세요.\n\n프로페셔널 소프트웨어 개발의 여러 해를 거친 후, 무언가를 모킹할 때 항상 그 테스트를 단위 테스트로 유지해야 하는지 아니면 통합 테스트로 승격해야 하는지 신중하게 생각하는 시간을 가집니다.\n\n이제 이 전환된 테스트와 이 통합 테스트를 대조해 보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```csharp\npublic class UserManagerShould(DatabaseFixture fixture) : IClassFixture\u003cDatabaseFixture\u003e\n{\n  [Fact]\n  public async Task SaveNewUser()\n  {\n     // Arrange\n     UserDbContext context = new TestDbContextFactory(fixture.ConnectionString)\n         .CreateDbContext(null!);\n\n     await context.Database.EnsureCreatedAsync();\n     await context.Users.ExecuteDeleteAsync();\n\n     var repository = new EfUserRepository(context);\n\n     var user = new User();\n     var sut = new UserManager(repository);\n\n\n     // Act\n     sut.SaveUser(user);\n\n     // Assert\n     List\u003cUser\u003e result = context.Users\n         .AsNoTracking()\n         .ToList();\n\n     result.Should()\n           .HaveCount(1);\n  }\n}\n```\n\n이 테스트는 우리 시스템이 프로덕션에서 수행할 작업을 정확히 모방합니다. 이 테스트는 픽스처와 PostgreSQL 도커 컨테이너가 하나의 테스트를 위해 실행됩니다.\n\n이제 \"SaveUser(user)\" 메서드를 호출하면 실제 데이터베이스에 삽입이 수행되며, 사용자에게 이름이 없기 때문에 오류가 발생합니다: Npgsql.PostgresException 23502: null value in column \"Name\" of relation \"Users\" violates not-null constraint.\n\n실제로 잘못된 상황에서 오류가 발생하는 이러한 테스트는 사용자를 저장하기 전에 추가적인 확인 절차를 수행해야 함을 알려줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테스트 실패는 우리에게 대응을 촉발시킵니다. 이 경우 UserManager의 SaveUser(user) 메서드에 가드 절을 추가하여 사용자가 유효한 상태에 있는지 확인하십시오.\n\n# 요약하자면...\n\n테스트는 시스템이 작동한다는 확신을 주어야 하며, 단순히 통제된 실험실 조건에서 각 부분이 작동하는 것만으로는 충분하지 않습니다.\n\n🔔 이와 같은 기사를 더 읽고 싶으신가요? 여기에서 등록하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시스템 내 중요한 클래스 상호작용을 모의하는 것은 클래스 간 통신 및 데이터 교환에서 발생하는 통합 문제를 알리지 못하게 할 수 있습니다. 실제 데이터베이스를 사용하는 데 조금 노력을 기울이면 장기적으로 이득을 볼 수 있습니다.\n\n빌드 시간에 통합 문제를 발견하는 것은 운영시간(프로덕션)에 발생하는 쉽게 피할 수 있는 문제를 발견하는 것보다 훨씬 저렴합니다.\n\n# 계속 연락을 유지합시다!\n\n뉴스레터에 등록하여 유사한 기사에 대한 알림을 받고 YouTube 채널인 @Nicklas Millard를 확인해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n린크드인에 연결하지 않는 것을 잊지 마세요.\n","ogImage":{"url":"/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png"},"coverImage":"/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png","tag":["Tech"],"readingTime":7},{"title":"새로운 Kotlin 어노테이션 프로세서 KSP를 사용해보세요","description":"","date":"2024-05-27 16:16","slug":"2024-05-27-KapttoKSP","content":"\n안녕하세요 여러분, 이번 시리즈를 통해 KAPT에서 KSP로 변경하는 것에 대해 이야기할 거예요.\n\nKAPT(코틀린 어노테이션 처리 도구)는 코틀린 코드에서 자바 어노테이션 프로세서를 사용할 수 있게 해줘요. 심지어 해당 프로세서가 코틀린을 명시적으로 지원하지 않더라도요. 이 과정은 코틀린 파일에서 자바 스텁을 생성하여 프로세서가 읽을 수 있게 합니다. 이 스텁 생성은 비용이 많이 드는 작업으로, 빌드 속도에 상당한 영향을 미칩니다.\n\n프로젝트에 KSP를 어떻게 포함시킬까요?\n\n프로젝트 최상위 build.gradle.kts 파일에 KSP 플러그인을 포함하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n플러그인 {\n    id 'com.google.devtools.ksp' version '1.8.10-1.0.9' 적용하지 않음\n}\n```\n\n다음으로, 모듈 레벨의 build.gradle.kts 파일을 활성화해주세요.\n\n```kotlin\n플러그인 {\n    id 'com.google.devtools.ksp'\n}\n```\n\nKAPT 라이브러리를 KSP로 교체해주세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n    kapt 'androidx.room:room-compiler:2.5.0' //제거\n    ksp 'androidx.room:room-compiler:2.5.0'  //추가\n```\n\n이 종속성을 추가한 후에 프로젝트를 동기화하세요.\n\n프로젝트에서 KAPT 플러그인을 제거하세요:\n\n더는 KAPT 요구 사항이 필요하지 않을 때 KAPT 플러그인을 삭제하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nplugins {\n    id 'org.jetbrains.kotlin.kapt'\n}\n\n//프로젝트에서 남은 kapt 플러그인도 제거해야 합니다\n```\n\n# KSP2 베타 버전 출시!\n\nKSP2는 KSP API의 새로운 구현체입니다. KSP 1.x보다 더 빠르고 쉽게 사용할 수 있을 것입니다. 자세한 내용은 KSP2 소개를 참고해주세요.\n\n# 즐거운 코딩하세요 🚀\n","ogImage":{"url":"/assets/img/2024-05-27-KapttoKSP_0.png"},"coverImage":"/assets/img/2024-05-27-KapttoKSP_0.png","tag":["Tech"],"readingTime":2},{"title":"ViewChild를 사용하지 말아요","description":"","date":"2024-05-27 16:16","slug":"2024-05-27-StopusingViewChild","content":"\n네이티브 DOM 요소에 액세스하는 것은 웹 개발에서 기본적인 작업입니다. 그러나 현대적인 프레임워크는 다양한 전략을 활용하여 직접 DOM 액세스의 필요성을 최소화합니다. 예를 들어 Angular는 *ngIf와 같은 디렉티브를 사용하여 요소를 조건부로 추가하거나 제거하고 *ngFor를 사용하여 요소를 반복합니다. 이러한 기술은 직접적인 DOM 조작을 추상화하여 Angular이나 유사한 프레임워크에서 어플리케이션을 개발할 때 덜 걱정해도 되도록 만듭니다.\n\n이러한 추상화에도 불구하고 직접적인 DOM 액세스가 여전히 필요한 시나리오가 있습니다. 구글 맵과 같은 일부 써드파티 라이브러리는 동작을 위해 직접적인 DOM 요소가 필요합니다. 구글 맵은 맵을 초기화하고 표시하기 위해 div 요소가 필요합니다. 일반적으로 개발자는 @ViewChild 데코레이터를 사용하여 div 요소에 액세스하고 그것을 맵 API에 제공하여 초기화합니다.\n\n```js\n/// \u003creference types=\"@types/google.maps\" /\u003e\nimport { AfterViewInit, Component, ElementRef, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-map-component',\n  template: `\u003cdiv class=\"map-container\" #googleMap\u003e\u003c/div\u003e`,\n  styles: ['.map-container {height: 500px;}'],\n})\nexport class MapComponentComponent implements AfterViewInit {\n  @ViewChild('googleMap', { read: ElementRef }) googleMapElement!: ElementRef\u003cHTMLDivElement\u003e;\n  map?: google.maps.Map;\n\n  async ngAfterViewInit() {\n    const { Map } = await google.maps.importLibrary(\"maps\") as google.maps.MapsLibrary;\n    // Pass the nativeElement to google map library\n    this.map = new Map(this.googleMapElement.nativeElement, {\n      center: { lat: -34.397, lng: 150.644 },\n      zoom: 8,\n    });\n  }\n}\n```\n\n이 접근 방식은 작동하지만 세 가지 주요 문제점을 도입합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 템플릿에서 div 요소를 제거하면 코드가 깨져서 맵 기능을 재사용할 수 없게 됩니다.\n- 네이티브 요소에 대한 참조는 ngAfterViewInit 라이프사이클 후크 이후에만 사용할 수 있습니다.\n- SOLID 디자인 원칙 중 단일 책임 원칙을 위반합니다. @ViewChild를 사용하는 컴포넌트는 맵을위한 데이터를 가져오는 것, 초기화하는 것, 설정하고 사용하는 것에 대한 책임이 생깁니다.\n\n더 나은 접근 방식이 있습니다: 속성 지시자 사용.\n\n이전 컴포넌트를 리팩토링하고 맵 속성 지시자를 만들어 봅시다.\n\n```js\n/// \u003creference types=\"@types/google.maps\" /\u003e\nimport { Directive, ElementRef, OnInit } from '@angular/core';\n\n@Directive({\n  selector: 'div[appGoogleMap]'\n})\nexport class GoogleMapDirective implements OnInit {\n  map?: google.maps.Map;\n  constructor(private elementRef: ElementRef\u003cHTMLDivElement\u003e) { }\n\n  async ngOnInit() {\n    const { Map } = await google.maps.importLibrary(\"maps\") as google.maps.MapsLibrary;\n    this.map = new Map(this.elementRef.nativeElement, {\n      center: { lat: -34.397, lng: 150.644 },\n      zoom: 8,\n    });\n  }\n}\n\n// 속성 지시자 사용\n\u003cdiv class=\"map-container\" appGoogleMap\u003e\u003c/div\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 사용 사례를 고려해 보겠습니다: 캔버스 요소에 도형이나 이미지를 그리는 것입니다. 간단한 방법은 @ViewChild를 사용하여 네이티브 요소에서 그리기 컨텍스트를 가져오는 것입니다.\n\n더 나은 대안은 속성 지시자를 사용하고 @Input 속성을 통해 그리기 정보를 전달하는 것입니다.\n\n```js\nimport { Component, ElementRef, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-canvas-component',\n  template: `\u003ccanvas #myCanvas\u003e\u003c/canvas\u003e`,\n})\nexport class CanvasComponentComponent {\n  // 빌드 시 myCanvas를 확인할 수 있는 방법이 없음\n  @ViewChild('myCanvas', { read: ElementRef }) canvasRef!: ElementRef\u003cHTMLCanvasElement\u003e;\n\n  ngAfterViewInit() {\n    const canvas = this.canvasRef.nativeElement;\n    const canvasContext = canvas.getContext('2d');\n    // 캔버스 컨텍스트를 사용하여 그리기\n    canvasContext?.beginPath();\n    canvasContext?.arc(75, 75, 50, 0, 2 * Math.PI);\n    canvasContext?.stroke();\n  }\n}\n\n// Vs\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n  // 이 지시자는 Cavas 요소만 사용할 수 있습니다\n  selector: 'canvas[appCanvas]'\n})\nexport class CanvasDirective {\n  constructor(private elementRef: ElementRef\u003cHTMLCanvasElement\u003e) {\n    this.draw();\n  }\n\n  draw() {\n    const canvas = this.elementRef.nativeElement;\n    const canvasContext = canvas.getContext('2d');\n    // 캔버스 컨텍스트를 사용하여 그리기\n    canvasContext?.beginPath();\n    canvasContext?.arc(75, 75, 50, 0, 2 * Math.PI);\n    canvasContext?.stroke();\n  }\n}\n// 속성 지시자 사용\n\u003ccanvas appCanvas\u003e\u003c/canvas\u003e\n```\n\n좋아 보이죠? 그런데 기다려 보세요, 더 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 첫 두 문제를 해결했지만 속성 지시자는 여전히 여러 책임을 처리하고 있습니다. 더 분해할 수 있을까요? 다음 블로그에서 그것을 더 탐구해보겠습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-StopusingViewChild_0.png"},"coverImage":"/assets/img/2024-05-27-StopusingViewChild_0.png","tag":["Tech"],"readingTime":5},{"title":"APKTOOL을 사용하여 APK를 디컴파일하고 재컴파일하는 방법 초보자 안내","description":"","date":"2024-05-27 16:15","slug":"2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide","content":"\n개인 실험을 위한 앱의 디컴파일 및 다시 컴파일하는 과정을 찾다가 많은 기사와 블로그를 만나게 되었습니다. 그 중 일부는 몇 단계를 놓치거나 다른 도구를 사용했습니다. 그래서 저는 apktool을 사용하여 앱을 디컴파일하고 다시 컴파일하는 방법에 대한 기사를 쓰기로 생각했습니다. 제가 수집한 모든 정보를 통합하고 샘플 표현과 함께 제시하겠습니다.\n\n![이미지](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_0.png)\n\n## 기본 사항\n\n- Apktool: 안드로이드 APK 파일에 대한 역공학 도구입니다.\n- Keytool: 디컴파일된 APK에 서명하기 위한 새 키스토어 파일을 생성하는 데 사용됩니다.\n- Apksigner: APK에 서명하는 데 사용됩니다.\n- Zipalign: 디컴파일된 파일들을 정렬하는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추가 도구\nJD-GUI: Java 디컴파일러\ndex2jar: 안드로이드 .dex 및 java .class 파일과 작업하는 도구\n\n## 전제 조건\n\nMac과 Linux에서 APK를 쉽게 디컴파일할 수 있습니다. Windows의 경우 일부 조정이 필요하지만, 아직 시도해보지 않았습니다. 디컴파일을 시작하려면 시스템에 JDK와 Android SDK를 설치해야 합니다.\n\nMac에서 Brew를 사용하여 Apktool 유틸리티를 설치하는 것은 매우 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nbrew install apktool\n```\n\n이 링크에서 자세한 설치 가이드를 찾을 수 있어요\n\n## 실험\n\n화면에 \"Original App\"이라는 텍스트를 표시하는 앱의 프로가드가 활성화된 — 서명된 APK가 있어요\n우리 실험의 목표는\n\n- 이 APK를 디컴파일하기\n- 배경색과 텍스트 색상 변경하기\n- 텍스트 \"Original App\"을 \"Recompiled App\"으로 바꾸기\n- 성공적으로 재컴파일하고 앱에 서명하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_1.png\" /\u003e\n\n## 연구실로 들어가봅시다\n\n단계 1: 디컴파일\n\nApkMirror.com 또는 다른 사이트에서 어떤 앱의 APK를 다운로드할 수 있습니다. 여기서는 샘플 앱 \"experiment_app.apk\"의 서명된 APK를 사용하겠습니다.\n먼저, 이 APK를 디컴파일해야 합니다. apktool을 사용하여 APK를 디컴파일하는 다음 명령을 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\napktool d [apk 위치] -o [디컴파일된 파일이 저장될 출력 폴더 위치]\n```\n\n![APKTOOL 사용하여 APK 디컴파일 및 재컴파일 시작 가이드](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_2.png)\n\n위 명령어를 실행한 후, apktool이 내 문서 디렉토리에 \"experimentapp_decompiled\"라는 새 폴더를 생성했습니다.\n\n![APKTOOL 사용하여 APK 디컴파일 및 재컴파일 시작 가이드](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 APK 파일에서 리소스 파일을 디컴파일하고 싶지 않다면, 대신 이 명령을 사용하세요\n\n```js\napktool d -r -s [apk 위치]  -o [디컴파일된 파일을 저장할 출력 폴더 위치]\n```\n\nStage 2 : 파일 수정\n\n저는 디컴파일된 파일 폴더에서 strings.xml과 colours.xml을 찾았어요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nmage](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_4.png)\n\nAndroid Studio에서는 이 리소스 파일을 창으로 드래그하거나 XML 편집기를 사용하여 열 수 있습니다.\n배경색을 빨간색으로, 텍스트 색상을 노란색으로 변경했습니다. 그런 다음, 텍스트를 \"재컴파일된 앱\"으로 변경했습니다.\n\nStage 3: 디컴파일된 리소스를 APK로 재컴파일하기\n\n변경 사항을 적용한 후, 다음 명령을 사용하여 디컴파일된 파일을 APK로 재컴파일할 예정입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\napktool b [디컴파일된 파일의 루트 폴더 위치]\n```\n\n![Decompile and Recompile APK using APKTOOL Beginner's Guide](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_5.png)\n\n이제 Apktool은 파일들을 컴파일하고 APK를 생성합니다. 디컴파일된 파일을 저장한 루트 폴더와 동일한 위치의 새 폴더인 \"dist\" 안에 저장될 것입니다.\n\n아하.. 알겠네요..\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_6.png)\n\nStage 4: Zipalign the apk for the optimal loading\n\nZipalign is a zip archive alignment tool that helps ensure that all uncompressed files in the archive are aligned relative to the start of the file. Zipalign tool can be found in the “Build Tools” folder within the Android SDK path.\n\n![image](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_7.png)\n\n`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPK를 zip align하려면 다음 명령을 실행하세요:\n\n```js\nzipalign -v 4 [재컴파일 된 apk] [zip align된 apk를 저장할 위치 및 apk 이름 및 확장자]\n```\n\n![이미지](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_8.png)\n\n단계 5: zip align된 APK에 서명하기 위한 새 키스토어 파일 생성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 명령어를 사용하여 keytool을 사용하여 키스토어 파일을 생성했어요. 이 명령을 사용하면 키스토어의 암호와 상세 정보를 입력하라는 프롬프트가 나타날 거에요.\n\n```js\nkeytool -genkey -v -keystore [키스토어 이름] -alias alias_name -keyalg RSA -keysize 2048 -validity 10000\n```\n\n\u003cimg src=\"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_9.png\" /\u003e\n\n단계 6: apksigner를 사용하여 앱에 서명하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nApksigner 도구는 Android SDK 빌드 도구의 24.0.3 버전 이상에서 제공되며, APK를 서명하고 해당 APK가 지원하는 Android 플랫폼 버전에서 성공적으로 확인될 것임을 확인할 수 있습니다.\nApk signer는 Android SDK 경로의 \"build tools\" 폴더 안에 ZipAlign과 함께 있습니다.\n\n![image](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_10.png)\n\n아래 명령어를 사용하여 apksigner를 사용하여 APK를 서명하십시오.\n\n```js\napksigner sign --ks [키스토어 이름] --v1-signing-enabled true --v2-signing-enabled true [zip align된 apk 위치]\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_11.png\" /\u003e\n\nStage 7: Verify the signed APK\n\nThe zip-aligned — signed APK can be verified using the same apksigner.\n\n```js\napksigner verify [signed apk location]\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_12.png\" /\u003e\n\n단계 8: 앱 설치\n\nadb 명령어를 사용하거나 수동으로 설치하여 확인된 apk를 설치합니다.\n\n```js\nadb install /Users/matrix/Documents/APK/experimentapp_zipaligned.apk\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![앱의 배경과 텍스트 색상이 변경되었어요](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_13.png)\n\n와우! 앱의 배경과 텍스트 색상이 변경되었어요.\n\n![실험 성공](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_14.png)\n\n실험 성공 .....\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndex2jar [classes.dex 파일 위치 디컴파일 된 폴더]\n\njd-gui [classes-dex2jar.jar 파일 위치]\n","ogImage":{"url":"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_0.png"},"coverImage":"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_0.png","tag":["Tech"],"readingTime":9}],"page":"58","totalPageCount":120,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"58"},"buildId":"JlBEgQDLGRx6DYlBnT8eD","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>