<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/51" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/51" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내" href="/post/2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="루비를 잘 몰라요 더 이상" href="/post/2024-06-19-YouDontKnowRubyAnymore"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="루비를 잘 몰라요 더 이상" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-YouDontKnowRubyAnymore_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="루비를 잘 몰라요 더 이상" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">루비를 잘 몰라요 더 이상</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CodeCademy 2024 학생 및 개발자를 위한 50 할인" href="/post/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CodeCademy 2024 학생 및 개발자를 위한 50 할인" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CodeCademy 2024 학생 및 개발자를 위한 50 할인" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">CodeCademy 2024 학생 및 개발자를 위한 50 할인</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭" href="/post/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="비동기 로깅 자바 앱에 제공되는 속도 향상" href="/post/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="비동기 로깅 자바 앱에 제공되는 속도 향상" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="비동기 로깅 자바 앱에 제공되는 속도 향상" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">비동기 로깅 자바 앱에 제공되는 속도 향상</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바 HashSet 초보자가 꼭 알아야 할 내용" href="/post/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바 HashSet 초보자가 꼭 알아야 할 내용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바 HashSet 초보자가 꼭 알아야 할 내용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바 HashSet 초보자가 꼭 알아야 할 내용</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시니어 자바 소프트웨어 엔지니어가 흔히 받는 인터뷰 질문들" href="/post/2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시니어 자바 소프트웨어 엔지니어가 흔히 받는 인터뷰 질문들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시니어 자바 소프트웨어 엔지니어가 흔히 받는 인터뷰 질문들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">시니어 자바 소프트웨어 엔지니어가 흔히 받는 인터뷰 질문들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바와 파이썬을 사용하여 나만의 ChatGPT와 유사한 챗봇 만들기" href="/post/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바와 파이썬을 사용하여 나만의 ChatGPT와 유사한 챗봇 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바와 파이썬을 사용하여 나만의 ChatGPT와 유사한 챗봇 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바와 파이썬을 사용하여 나만의 ChatGPT와 유사한 챗봇 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="UUID 대 ULID 어떤 것을 사용해야 할까요" href="/post/2024-06-19-UUIDvsULID"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="UUID 대 ULID 어떤 것을 사용해야 할까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-UUIDvsULID_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="UUID 대 ULID 어떤 것을 사용해야 할까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">UUID 대 ULID 어떤 것을 사용해야 할까요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Java Spring Boot 코드 리팩터링 더 깔끔하고 확장 가능한 로직을 위해 If-Else 문 제거하기" href="/post/2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Java Spring Boot 코드 리팩터링 더 깔끔하고 확장 가능한 로직을 위해 If-Else 문 제거하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Java Spring Boot 코드 리팩터링 더 깔끔하고 확장 가능한 로직을 위해 If-Else 문 제거하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Java Spring Boot 코드 리팩터링 더 깔끔하고 확장 가능한 로직을 위해 If-Else 문 제거하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link posts_-active__YVJEi" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"루비 메타프로그래밍의 매력을 발견하다 재미있고 쉬운 안내","description":"","date":"2024-06-19 10:17","slug":"2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide","content":"\n당신이 코드가 스스로 작성되길 바라거나, 실행 중에 자신을 수정, 확장 또는 자가검사할 수 있는 슈퍼파워를 가지기를 꿈꾼 적이 있나요? 새로운 지식을 터득하고 자유롭게 프로그램을 다루는 마술사처럼 프로그램을 제어하는 Ruby 메타프로그래밍이 여기 있다는 걸 알았군요!\n\n무엇이 메타프로그래밍인가요?\n\nRuby에서의 메타프로그래밍은 실행 중에 코드 자체를 수정, 확장 또는 자가검사할 수 있는 능력을 갖추는 것처럼 슈퍼파워를 지니고 있는 것과 같습니다. 이것은 프로그램이 새로운 기능을 터득하고 새로운 속성을 신속하게 알아차릴 수 있는 능력을 부여하는 것과 같습니다.\n\n가볍고 재미있게 진행하기 위해 Ruby 메타프로그래밍의 가장 매혹적인 주문… 즉, 기술들을 알아보도록 하죠. 걱정하지 마세요, 모든 것을 이해할 수 있도록 마법적인 상상력을 이용할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주문 #1: Method_missing\n\n마법사가 된 것처럼 상상해보세요. 누군가 알 수 없는 주문을 요청하면 당신은 그 즉시 마법을 만들어낼 수 있습니다. Ruby에서 method_missing은 당신이 그렇게 할 수 있게 해줍니다!\n\n```ruby\nclass Spellbook\n  def method_missing(name, *args)\n    puts \"#{name} 주문이 #{args.inspect}와 함께 사용되었습니다. 이 주문은 책에 없지만, 만들어볼까요?\"\n    # 여기서 동적으로 메소드를 생성할 수 있습니다.\n  end\nend\n\nwizard = Spellbook.new\nwizard.invisibility(\"10분 동안\") # invisibility 주문이 [\"10분 동안\"]와 함께 사용되었습니다. 이 주문은 책에 없지만, 만들어볼까요!\n```\n\nmethod_missing을 오버라이딩함으로써 정의되지 않은 메소드 호출을 잡아내어 처리하는 방법을 결정할 수 있습니다. 무한한 주문서를 가지고 있는 것과 같은 느낌이죠!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주문 #2: Define_method\n\n새로운 주문을 마음대로 만들고 싶나요? define_method이 당신의 선택된 주문입니다. 이 주문을 사용하면 클래스에 동적으로 메서드를 정의할 수 있습니다.\n\n```js\nclass Wizard\n  define_method(:conjure_fireball) do |size|\n    puts \"크기가 #{size}인 파이어볼을 창조합니다!\"\n  end\nend\n\n간달프 = Wizard.new\n간달프.conjure_fireball(\"큰\") # 크기가 큰 파이어볼을 창조합니다!\n```\n\ndefine_method을 사용하면 실행 시간에 클래스에 메서드를 추가할 수 있어서, 당신의 주문(그리고 코드)를 무한히 유연하게 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주문 #3: Class_eval과 Instance_eval\n\n만약 클래스나 객체의 본질을 조정하고 싶다면 어떻게 해야 할까요? 바로 class_eval과 instance_eval이 등장합니다. 이 둘은 각각 클래스나 인스턴스의 컨텍스트에서 코드를 실행할 수 있게 해줍니다.\n\n```js\nclass Dragon\nend\n\nDragon.class_eval do\n  def breathe_fire\n    puts \"용이 불을 뿜습니다!\"\n  end\nend\n\nsmaug = Dragon.new\nsmaug.breathe_fire # 용이 불을 뿜습니다!\n```\n\nclass_eval을 사용하면 실행 중에 클래스의 메소드를 추가하거나 구조를 변경할 수 있습니다. 마치 결투 중에 주문서를 다시 쓰는 것과 같은 느낌이죠!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실용적인 예제: DSL(Domain Specific Language) 만들기\n\n우리의 주문을 결합하여 마법 생물을 정의하는 간단한 DSL을 만들어 봅시다.\n\n```js\nclass MagicalCreature\n  def self.spell(name, \u0026block)\n    define_method(name, \u0026block)\n  end\nend\n\nclass Unicorn \u003c MagicalCreature\n  spell :sparkle do\n    puts \"The unicorn sparkles!\"\n  end\n\n  spell :fly do\n    puts \"The unicorn takes flight!\"\n  end\nend\n\ntwilight = Unicorn.new\ntwilight.sparkle # The unicorn sparkles!\ntwilight.fly # The unicorn takes flight!\n```\n\n클래스 메소드 내에서 define_method를 사용하여 마법 생물의 능력을 정의하는 간편하고 유연한 방법을 만들 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결론\n\n루비 메타프로그래밍은 마법같은 특별한 능력을 소유하는 것과 같습니다. 이를 이용하면 코드를 더 유연하고 강력하게 만들 수 있지만, 지혜롭게 활용해야 합니다. 강력한 마법과 마찬가지로 무모하게 사용하면 위험할 수 있습니다. 주문(코드)을 명확하고 유지보수 가능하게 작성하고, 항상 마법같은 작품에 설명을 붙이세요.\n\n자, 젊은 코더여, 루비 메타프로그래밍의 마법을 이용하여 코드를 더욱 향상시켜 보세요!\n","ogImage":{"url":"/assets/img/2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide_0.png"},"coverImage":"/assets/img/2024-06-19-UnlockingtheMagicofRubyMetaprogrammingAFunandEasyGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"루비를 잘 몰라요 더 이상","description":"","date":"2024-06-19 10:14","slug":"2024-06-19-YouDontKnowRubyAnymore","content":"\n조심하세요! 시니어 루비 개발자분들께는 마음을 다치게 할 수도 있는 기사입니다.\n\n루비는 모든 현대 프로그래밍 언어처럼 발전하고 있습니다. 커뮤니티는 계속해서 새로운 기능을 소개하고 있지만 모두가 알지 못하는 것이 있습니다. 새로운 기능을 따라가지 않고 채택하지 않는 개발자들은 아마도 루비 3.3 시대에도 루비 1.9.2 코드를 작성하고 있을지도 모릅니다!\n\n루비의 성숙함과 오랜 역사에도 불구하고 사용자들 사이에는 오래된 관행을 고수하려는 경향이 있습니다. 새로운 기능을 받아들이기를 꺼리는 이러한 저항은 유감스럽습니다. 새로운 기능을 도입하는 것이 루비의 관련성을 유지하고 현대 프로그래밍 언어 중 하나로 자리 잡는 데 도움을 준다는 것을 명심해야 합니다.\n\n최근 루비 버전에서 중요한 새로운 기능과 개선 사항들을 소개하겠습니다. 더불어 커뮤니티에서는 아직 충분히 주목받지 못한 오래된 기능들도 소개할 예정입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# RBS (루비 서명)\n\n루비 코드에서 유형 안전성을 보장하려면 방대한 테스트와 문서 작업이 필요했고, 이로 인해 잠재적인 런타임 오류와 생산성 저하가 발생했죠.\n\nRBS (루비 서명)는 루비 3.1과 함께 소개된 새로운 언어로, 루비 코드의 유형과 인터페이스를 설명하는 데 사용됩니다. 이를 통해 정적 유형 확인과 IDE 자동 완성이 가능해져 코드 품질과 개발자 생산성이 향상됩니다.\n\nSorbet 및 유사한 커뮤니티 주도의 대안이 존재하지만, RBS는 Matz에 의해 지지된 점에서 돋보입니다. 별도의 젬으로 패키징되었지만, 프로그래밍 언어 환경에서 유형 확인 트렌드를 받아들이는 공식 방법으로 간주됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# Point.rbs\nclass Point\n  attr_reader x: Integer\n  attr_reader y: Integer\n\n  def initialize: (x: Integer, y: Integer) -\u003e void\nend\n\n# Point.rb\nclass Point\n  attr_reader :x, :y\n\n  def initialize(x, y)\n    @x = x\n    @y = y\n  end\nend\n```\n\nSteep은 루비를 위한 정적 타입 검사 도구로, 타입 안전성을 보장하고 개발 과정에서 오류를 일찍 발견하는 데 도움을 줄 수 있어요.\n\n일반적인 GitHub Actions CI/CD 파이프라인에서는 Steep을 테스트 단계의 일부로 설정할 수 있어요. 이를 통해 루비 코드베이스를 RBS 파일에 대해 분석하고, 타입 오류를 확인하여 개발자에게 피드백을 제공할 수 있어요.\n\n```js\n# .github/workflows/ci.yml\nname: CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Setup Ruby\n        uses: actions/setup-ruby@v1\n        with:\n          ruby-version: '3.3'\n\n      - name: Install dependencies\n        run: bundle install\n\n      - name: Run Steep\n        run: bundle exec steep check\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCI/CD 파이프라인에 Steep를 통합하면 코드 품질을 유지하고 유형 안정성을 강화하여 런타임 오류를 방지할 수 있습니다. 이는 최상의 관행을 촉진하며 Ruby 애플리케이션의 신뢰성을 향상시킵니다.\n\nRBS 도입은 학습과 도구 설정에 상당한 투자가 필요할 수 있습니다. 또한 코드베이스 옆에 유형 주석을 유지하는 데 추가 작업을 도입할 수 있습니다.\n\n# 패턴 매칭\n\n패턴 매칭은 Ruby 2.7에서 가장 기대되는 기능 중 하나였습니다. Ruby 창시자인 매츠는 Ruby를 더 표현력 있게 만들고 현대 프로그래밍 언어 트렌드에 맞추기 위해 패턴 매칭을 포함하고 싶다고 언급했습니다. 커뮤니티는 Ruby 메일링 리스트와 이슈 트래커에서 이에 대해 광범위히 논의했습니다. 해당 기능은 최종 포함되기 전에 여러 번의 반복과 수정을 거쳤습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n패턴 매칭 이전에는 복잡한 데이터 구조를 비구조화하고 일치시키기 위해 다양한 if나 case 문을 사용하여 반복적이고 장황한 코드가 필요했습니다. 이로 인해 코드의 가독성과 유지보수성이 낮아지는 경우가 많았습니다.\n\n루비 2.7부터 도입된 패턴 매칭은 루비 3.0에서 더 발전하여 더 간결하고 표현력 있는 데이터 비구조화와 일치를 가능케 합니다. 이로써 코드가 더 깔끔하고 유지보수가 편해집니다.\n\n예시:\n\n```ruby\ndef company_location_contact_id(company_location_id)\n  query = \u003c\u003c~GRAPHQL\n    query($company_location_id: ID!) {\n      companyLocation(id: $company_location_id) {\n        ...\n      }\n    }\n  GRAPHQL\n\n  response =\n    @client.query(\n      query:,\n      variables: { company_location_id: \"gid://shopify/CompanyLocation/#{company_location_id}\" }\n    ).body\n\n  case response.deep_symbolize_keys\n  in errors: [{ message: error_message }]\n    Rollbar.error(\"#{error_message} for\", company_location_id:)\n  in data: { companyLocation: nil }\n    Rollbar.error(\"Company location not found\", company_location_id:)\n  in data: { companyLocation: { roleAssignments: { edges: [{ node: { companyContact: { id: contact_id } } }] } } }\n    contact_id\n  end\nend\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n패턴 매칭을 사용하지 않으면, 코드는 일반적으로 중첩 조건문이나 응답 데이터의 수동 구문 분석으로 인한 오류를 유발할 수 있습니다. 같은 기능을 패턴 매칭 없이 어떻게 구현할 수 있는지 살펴봅시다:\n\n```js\ndef 회사_위치_연락처_ID(회사_위치_ID)\n  쿼리 = \u003c\u003c~GRAPHQL\n    query($company_location_id: ID!) {\n      companyLocation(id: $company_location_id) {\n        ...\n      }\n    }\n  GRAPHQL\n\n  응답 = @client.query(\n    query: 쿼리,\n    variables: { company_location_id: \"gid://shopify/CompanyLocation/#{회사_위치_ID}\" }\n  ).body\n\n  데이터 = 응답.deep_symbolize_keys\n\n  if 데이터.key?(:errors) \u0026\u0026 데이터[:errors].is_a?(Array) \u0026\u0026 데이터[:errors].first.key?(:message)\n    오류_메시지 = 데이터[:errors].first[:message]\n    Rollbar.error(\"#{오류_메시지} for\", company_location_id: 회사_위치_ID)\n  elsif 데이터.key?(:data) \u0026\u0026 데이터[:data].is_a?(Hash) \u0026\u0026 데이터[:data][:companyLocation].nil?\n    Rollbar.error(\"회사 위치를 찾을 수 없음\", company_location_id: 회사_위치_ID)\n  elsif 데이터.key?(:data) \u0026\u0026 데이터[:data].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].is_a?(Array) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].first.is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].first[:node].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].first[:node][:companyContact].is_a?(Hash) \u0026\u0026\n        데이터[:data][:companyLocation][:roleAssignments][:edges].first[:node][:companyContact].key?(:id)\n    데이터[:data][:companyLocation][:roleAssignments][:edges].first[:node][:companyContact][:id]\n  end\nend\n```\n\n패턴 매칭을 사용하지 않으면 코드가 상당히 장황하고 오류 발생 가능성이 높아집니다. 각 조건을 주의 깊게 확인하고 중첩해야 하므로 가독성 문제와 버그 발생 위험이 커집니다. 패턴 매칭을 통해 복잡한 데이터 구조를 해체하고 일치시키는 간결하고 가독성 있는 방법을 제공함으로써 이러한 프로세스를 간편화할 수 있습니다.\n\n그러나 패턴 매칭이 과도하게 사용되거나 부적절하게 사용된 경우 복잡성을 증가시킬 수도 있습니다. 또한 개발자가 새로운 구문과 패턴을 익히고 채택 속도가 처음에는 느려질 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 원 라인 패턴 매칭:\n\n해시나 배열의 구조 해체는 종종 여러 줄의 코드가 필요하여 간단한 할당이 다소 장황하고 복잡해지는 경우가 있습니다.\n\n루비 2.7에서 소개된 원 라인 패턴 매칭은 구조 해체를 한 줄로 처리하여 코드를 보다 간결하고 가독성 있게 만들어줍니다.\n\n```js\ndata = { user: { name: \"Alice\", details: { age: 25, city: \"Paris\" } } }\ndata =\u003e { user: { name:, details: { age:, city: } } }\nputs \"Name: #{name}, Age: #{age}, City: #{city}\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 줄 구문은 복잡한 패턴에 대해 가독성이 떨어질 수 있고, 개발자들은 새로운 구문을 완전히 활용하기 위해 익숙해져야 합니다.\n\n**오른쪽 할당:**\n\n이전 기능과 유사하게, `=` 연산자는 해체 및 패턴 매칭 없이 변수를 할당하는 방식으로 사용될 수 있으며, 코드의 흐름 방향과 더 자연스럽게 느낄 수 있는 다른 순서로 변수를 할당하는 방식입니다.\n\n루비 3.0에서 소개된 오른쪽 할당은 더 읽기 쉽고 간결한 방식으로 바로 할당을 수행할 수 있도록 구문을 간단화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nread_data() =\u003e user_data =\u003e { user: { name:, details: { age:, city: } }\nsave!(user_data)\nputs \"Name: #{name}, City: #{city}\"\n```\n\n이 구문은 일부 개발자들에게 익숙하지 않고 혼란스러울 수 있습니다. 또한 복잡한 표현식에서 과도하게 사용하면 코드를 덜 읽기 쉽게 만들 수 있습니다.\n\n# 개선 사항\n\n핵심 클래스를 전역적으로 수정하는 것은 예상치 못한 부작용과 충돌을 야기할 수 있으며, 특히 대규모 코드베이스나 공유 라이브러리에서는 특히 그렇습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루비 2.0에서 소개된 Refinements는 코어 클래스에 범위 지정 수정을 할 수 있는 방법을 제공합니다. 이를 통해 변경 사항을 특정 컨텍스트로 제한하여 부작용의 위험을 줄일 수 있습니다.\n\n```js\nmodule ArrayExtensions\n  refine Array do\n    def to_hash\n      Hash[*self.flatten]\n    end\n  end\nend\n\nclass Converter\n  using ArrayExtensions\n\n  def self.convert(array)\n    array.to_hash\n  end\nend\n\nputs Converter.convert([[:key1, \"value1\"], [:key2, \"value2\"]])\n```\n\n이것은 비교적 오래된 (그러나 소중한) 기능으로, 너무 적은 코드베이스에서 사용된 것을 본 적이 있습니다. 단점이 있지만, 우리가 그것을 인식하고 있을 때 강력한 도구로 작용합니다.\n\nRefinement를 사용할 때 중요한 함정 중 하나는, 코드가 실행되는 컨텍스트에서 Refinement가 활성화되어 있지 않을 때 예기치 못한 동작이 발생할 수 있다는 것입니다. Refinement는 특정 렉시컬 스코프 내의 코드에만 영향을 미치기 때문에, Refinement에 의존하는 코드는 실행되는 위치에 따라 다르게 동작할 수 있습니다. 이는 일관성이 떨어지고, 코드가 재사용되거나 다양한 컨텍스트에서 실행될 경우 진단하기 어려운 버그를 유발할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그냥 알아두세요.\n\n# Enumerator::Lazy\n\n대량 컬렉션에 대해 연산을 체인화하는 것은 중간 배열이 생성되어 메모리와 처리 시간을 소모하여 비효율적일 수 있습니다.\n\n루비 2.0에서 소개된 지연(Leazy) 열거자는 중간 배열을 만들지 않고 효율적인 연산 체인을 가능케 합니다. 이는 대량 컬렉션에 대해 더 나은 성능과 낮은 메모리 사용량을 가져옵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nlazy_numbers = (1..Float::INFINITY).lazy\nresult = lazy_numbers.select { |n| n % 2 == 0 }\n.map { |n| n \\* n }\n.take(10)\n.to_a\n\nputs result.inspect\n\n단점: 지연 열거자는 연산이 체인의 끝까지 연기되기 때문에 디버깅이 더 어려울 수 있습니다. 또한, 모든 열거자 메서드가 지연 열거자에서 사용 가능한 것은 아닙니다.\n\n# Enumerator::Chain\n\n여러 열거 가능한 항목을 연결하는 경우 연결이 필요했으며 표현력이 낮아 종종 가독성이 떨어지는 코드로 이어졌습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루비 2.6에 소개된 Enumerator::Chain은 열거자를 체인으로 묶는 깔끔하고 표현력 있는 방법을 제공하여 가독성과 유지보수성을 향상시킵니다.\n\n```js\nevens = (2..10).step(2)\nodds = (1..9).step(2)\ncombined = evens.each.chain(odds.each)\n\nputs combined.to_a.inspect\n```\n\n단점: 체이닝을 간단하게 만들지만, 개발자가 배워야 할 다른 개념을 소개할 수 있습니다. 복잡한 체이닝 시나리오에서 과도하게 사용될 경우 데이터의 원천을 가리거나 불분명하게 만들 수도 있습니다.\n\n# Module#prepend\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 바꾸는 것이 조금 더 간단하게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 끝이 없는 메서드 정의\n\n단순한 메서드를 정의하는 데 여러 줄의 코드가 필요했었습니다. 메서드 본문이 하나의 표현식인 경우에도 말이죠. “;”를 사용하여 한 줄 메서드 정의를 작성하는 방법은 있었지만, 그렇게 하면 보기 좋지 않았습니다.\n\n```js\ndef power(base, exponent); base**exponent ; end\n```\n\nRuby 3.0에서 소개된 끝이 없는 메서드 정의는 단일 표현식을 반환하는 메서드에 대해 간결한 구문을 제공하여, 보일러플레이트를 줄이고 가독성을 향상시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nclass Calculator\n  def add(a, b) = a + b\n  def multiply(a, b) = a * b\n  def power(base, exponent) = base**exponent\nend\n\ncalc = Calculator.new\nputs calc.add(2, 3)       # 결과: 5\nputs calc.multiply(4, 5)  # 결과: 20\nputs calc.power(2, 3)     # 결과: 8\n```\n\n새로운 구문은 일부 개발자에게는 익숙하지 않을 수 있어 혼란스러울 수 있습니다. 또한, 더 복잡한 메소드에 과도하게 사용될 경우 가독성이 떨어질 수도 있습니다.\n\n# `it` 매개변수\n\n블록 변수를 명시적으로 사용하는 것은, 특히 map과 같이 단일 매개변수가 필요한 Enumerable 메소드들에 대한 간단한 작업에 대해 최대한 설명하기 위한 경우, 반복적이고 간결하지 않은 코드를 작성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRuby 3.0에서 소개된 it 매개변수는 기본 블록 매개변수를 제공하여 블록 구문을 간략화하며 단순한 작업에 대해 코드를 더 간결하고 가독성 있게 만들어줍니다.\n\n```js\n[\"apple\", \"banana\", \"cherry\"].map { it.upcase.reverse }\n```\n\nRuby 2.7에서는 번호 매개변수(\\_1, \\_2 등)가 실험적 기능으로 도입되어 블록 구문을 간소화하고 인수를 자동으로 참조함으로써 목표를 달성했습니다. 그러나 커뮤니티 내에서 읽기 어려움과 혼란 가능성에 대한 우려가 제기되었고, 이는 기본 it 매개변수 주변의 토론과 유사합니다. Rubocop은 매개변수 \\_1 이외의 번호 매개변수 사용을 방지하도록 설정을 기본값으로 하며, 이는 it를 사용하는 것과 정확히 동일하지만 더 좋은 이름을 가지고 있습니다.\n\n단점: it의 암시적 성격은 코드를 더 복잡한 작업에 대해 읽기 어렵게 만들 수 있습니다. 또한 개발자가 배워야 할 새로운 규칙을 도입합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# String#casecmp?\n\n대소문자를 구별하지 않는 문자열 비교를 위해서는 복잡한 코드를 작성해야 했는데, 그것은 종종 여러 메서드 호출이나 정규 표현식을 포함하여 가독성을 떨어뜨리곤 했습니다.\n\nRuby 2.4에서 소개된 String#casecmp?는 대소문자를 구분하지 않는 비교를 위한 간편한 메서드를 제공하여 코드를 더 간결하고 표현력 있게 만들어줍니다.\n\n```ruby\nstrings = [\"Hello\", \"world\", \"HELLO\"]\nmatches = strings.select { |s| s.casecmp?(\"hello\") }\nputs matches.inspect # =\u003e [\"Hello\", \"HELLO\"]\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Object#yield_self 그리고 then\n\n객체에 대한 연산을 연쇄적으로 사용할 때 중간 변수 없이는 가독성이 떨어질 수 있어 더 장황하고 부자연스러운 코드가 될 수 있습니다. 호출이 중첩되어 있을 때 코드 읽기 방향도 자연스럽지 않게 느껴질 수 있습니다.\n\n루비 2.5에서 소개된 Object#yield_self와 Ruby 3.0에서 소개된 then 별칭을 사용하면 더 깔끔한 연산 체이닝이 가능해져 코드 가독성과 유연성이 향상됩니다.\n\n```js\nresult = \"hello\"\n         .yield_self { |str| str.upcase }\n         .then { |str| str + \" WORLD\" }\n\nputs result  # Output: \"HELLO WORLD\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**단점:** 이러한 방법은 쉽게 오용되거나 과도하게 사용될 수 있어서, 체인이 너무 길거나 복잡해지면 코드가 덜 가독성이 될 수 있습니다.\n\n# 끝없는 범위:\n\n상한 또는 하한이 없는 범위를 정의하는 데는 Float::INFINITY 또는 다른 해결책이 필요했는데, 이는 번거로울 수 있고 직관적이지 않을 수 있습니다.\n\nRuby 2.6에서 소개된 끝없는 범위는 한쪽에 제한이 없이 범위를 정의할 수 있게 해주어 코드를 보다 간결하고 표현력있게 만들어줍니다. 특히 무한한 시퀀스나 무한 범위에 대해서 특히 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nalphabet = ('a'..'z')\nnumbers = (1..)\npositive_even_numbers = (2..).step(2)\n```\n\nActiveRecord을 사용하면 강력한 단축키가 될 수 있습니다:\n\n```js\n@posts =\n  Post.where(some_value: ..min_value).order(:id).paginate(page: params[:page])\n  # where('some_value \u003c ?', min_value)와 동일합니다\n```\n\n무한 범위는 조심히 사용하지 않으면 예상치 못한 동작으로 이어질 수 있습니다. 특히 범위가 무한대로 반복되는 경우에는 특별히 주의해야 합니다. 지나치게 또는 부적절하게 사용할 경우 가독성이 떨어질 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데이터 클래스:\n\n간단한 데이터 구조를 만들 때는 종종 속성 액세서와 초기화를 위한 보일러플레이트 코드를 작성해야 했습니다.\n\n루비 3.0에서 소개된 데이터 클래스는 속성을 가진 클래스를 정의하는 간결한 구문을 제공하여 보일러플레이트를 줄이고 코드 가독성을 향상시킵니다.\n\n```js\nclass Coordinates \u003c Data\n  attribute x: Float\n  attribute y: Float\nend\n\npoint = Coordinates.new(x: 10, y: 20)\nputs point.x # 출력: 10\nputs point.y # 출력: 20\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 클래스는 주로 간단한 데이터 구조를 위해 사용되며 복잡한 클래스 계층구조나 행위 중심 클래스에는 적합하지 않을 수 있습니다. 과도하게 사용할 경우 더 이상 캡슐화되지 않은 코드로 이어질 수도 있습니다.\n\n루비에서 Data와 Struct의 차이는 사용 목적과 기본 동작을 중심으로 하고 있습니다.\n\nStruct는 루비의 내장 클래스로, 이름이 지정된 속성을 가진 가벼운 데이터 구조를 생성할 수 있게 해줍니다. 클래스 전체를 명시적으로 정의하지 않고도 간단한 클래스를 정의하는 편리한 방법을 제공합니다. Struct를 생성할 때는 그 속성을 한 줄로 정의하고, 루비가 각 속성에 대한 접근자 메서드를 자동으로 생성합니다. Struct는 데이터 구조를 정의하는 간단한 구문을 제공하지만, 일반적인 클래스에서 사용 가능한 일부 고급 기능과 사용자 정의 옵션은 제공하지 않습니다.\n\n한편 Data는 루비 3.0에서 Ractor 실험적 API의 일부로 도입된 새로운 기능입니다. 이는 엄격한 속성 타입을 갖는 변경할 수 없는 데이터 클래스를 정의하는 데 특별히 설계되었습니다. Struct가 변경 가능한 속성을 가진 변경 가능한 클래스를 생성하는 데 반해, Data 클래스는 기본적으로 변경할 수 없으며, 인스턴스화 이후에는 속성을 수정할 수 없습니다. 또한 Data 클래스는 속성에 대한 엄격한 타입 지정을 강제하므로 지정된 유형의 값만이 속성에 할당될 수 있습니다. 이러한 변경 불가능성과 엄격한 타입 지정으로 인해 Data 클래스는 데이터 전송 객체(DTO), 데이터 페이로드 표현 및 변경 불가능성 및 유형 안전성이 중요한 시나리오를 모델링하는 데 적합합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n루비는 읽기 쉽고 효율적이며 표현성이 향상된 많은 강력한 기능을 갖추고 진화했습니다. 이러한 새로운 기능을 활용함으로써 현대적이고 이디오매틱한 루비 코드를 작성할 수 있습니다. 여전히 루비 1.9 스타일 코드를 작성 중이라면, 최신 루비 표준을 반영하고 따라가기 위해 이러한 새로운 기능을 탐험하고 받아들이는 것이 시간입니다.\n","ogImage":{"url":"/assets/img/2024-06-19-YouDontKnowRubyAnymore_0.png"},"coverImage":"/assets/img/2024-06-19-YouDontKnowRubyAnymore_0.png","tag":["Tech"],"readingTime":18},{"title":"CodeCademy 2024 학생 및 개발자를 위한 50 할인","description":"","date":"2024-06-19 10:12","slug":"2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024","content":"\n## CodeCademy은 오늘 유료 요금제에 50% 할인을 제공합니다. 할인을 받으려면 코드 AISUMMER를 사용하십시오\n\n![이미지](/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_0.png)\n\n안녕하세요 여러분, 여러분과 공유하고 싶은 흥미로운 뉴스가 있어요. 코딩 및 웹 개발을 배우는 데 가장 인기 있는 웹 사이트 중 하나인 CodeCademy가 지금 유료 요금제에 50% 할인을 제공하고 있습니다.\n\n이제 프로 또는 프로 학생 요금제 1년 구독을 50% 할인된 가격에 잠그는 데 프로모션 코드 AISUMMER을 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCodeCademy가 무엇인지 모르신다면 제 이야기를 들어보세요. 어떻게 CodeCademy를 만나고 나서 개발자들을 위한 많은 핵심 기술을 배우는 데 사용했는지 알려드릴게요.\n\n나는 7년 전에 CodeCademy를 처음 알게 되었어요. 당시 나는 자바스크립트에 대해 배울 무료 강의를 찾아보던 중이었죠. 사실, 전 자바스크립트를 활용한 프론트엔드가 작성된 풀스택 프로젝트를 작업 중이었는데, 코드를 읽기 위해 빠르게 배우고 싶었어요.\n\n그런 다음 그들의 '자바스크립트 입문' 코스를 알게 되었어요. 이 무료 코스는 200만 명 이상의 개발자들에 의해 수강되었답니다. 강의 구성 방식이 마음에 들었어요. 브라우저에서 코드를 작성하고 빠른 피드백을 볼 수 있다는 점이죠.\n\n수업은 작고 매우 매력적이었어요. 이는 코드에서 80% 사용되는 20%의 개념을 빠르게 배울 수 있도록 도와주었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 이후로 CodeCademy Pro Plan을 사용하고 있어요. 뭘 배우든지, 되새기든지 지루할 때는 항상 CodeCademy로 갑니다. 이제 동일한 요금제를 50% 할인된 가격에 구매할 수 있어요. 할인 코드는 AISUMMER를 사용하세요.\n\n링크는 여기 있어요 — [CodeCademy Pro Plan](https://www.example.com)\n\n![CodeCademy 50% 할인](/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_1.png)\n\n유료 요금제를 구입하면, 수요가 높은 기술을 배울 수 있는 최고의 CodeCademy 강좌를 확인할 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 파이썬 3 배우기\n- 자바 배우기\n- SQL 배우기\n- 블록체인 및 암호화폐 소개 [무료 강좌]\n- Go 배우기\n- 무료 SQL 배우기\n- D3.js 배우기\n- PHP 배우기\n- 판다스를 사용한 데이터 분석 배우기\n- Git 배우기\n- HTML 배우기\n- C++ 배우기\n- CSS 배우기\n- C# 배우기\n- 코딩하는 방법 배우기\n- React 배우기\n- Redux 배우기\n- React Native 배우기\n- R 언어 배우기\n- PHP 배우기\n- Ruby 배우기\n- Swift 배우기\n- 명령줄 사용법 배우기\n\n여기서 CodeCademy 개발자들을 위한 훌륭한 혜택 내용이었습니다. CodeCademy에 가입하여 필수 기술을 빠르게 익힐 수 있는 훌륭한 기회입니다. HTML, CSS 또는 JavaScript와 같은 프론트엔드 기술 또는 Python, Java, Ruby와 같은 백엔드 기술을 배우고 싶다면, 지금 CodeCademy에 가입하여 프로그래밍 및 개발 여행을 50% 할인된 가격으로 시작하세요.\n\n행운을 빕니다! 그리고 즐거운 학습 되세요!\n\nJavin\n","ogImage":{"url":"/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_0.png"},"coverImage":"/assets/img/2024-06-19-CodeCademy50DiscountforStudentsandDevelopers2024_0.png","tag":["Tech"],"readingTime":3},{"title":"Spring Boot 성능 튜닝 애플리케이션 최적화를 위한 팁과 트릭","description":"","date":"2024-06-19 10:11","slug":"2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication","content":"\nSpring Boot은 사용의 용이성과 빠른 개발 능력으로 유명하지만, 애플리케이션이 커짐에 따라 성능 문제가 발생할 수 있습니다. Spring Boot 애플리케이션의 기능을 향상시키면 응답 속도가 향상되고 리소스를 효율적으로 사용하며 전반적으로 강력한 프로그램이 될 수 있습니다. 이 블로그 글에서는 캐싱, 프로파일링 및 효과적인 데이터베이스 연결에 중점을 두고 Spring Boot 앱의 속도를 최적화하기 위한 중요한 지침과 전략을 살펴볼 것입니다.\n\n![Spring Boot Performance Tuning Tips and Tricks for Optimizing Your Application](/assets/img/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication_0.png)\n\n- Spring Boot Actuator 사용하기:\n\n최적화를 시작하기 전에 병목 현상이 어디에 있는지 이해해야 합니다. 프로파일링 도구를 사용하여 애플리케이션의 성능 문제를 식별할 수 있습니다.\nSpring Boot Actuator가 제공하는 운영 준비 기능을 활용하여 애플리케이션을 모니터링하고 제어할 수 있습니다. 이 기능은 어플리케이션이 얼마나 잘 수행되고 있는지에 대한 정보를 제공할 수 있는 여러 엔드포인트를 갖추고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n    \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\n아래는 application.properties 파일에서 필요한 엔드포인트를 활성화하는 방법입니다:\n\nmanagement.endpoints.web.exposure.include=health,info,metrics,threaddump,env\n\n성능 메트릭\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nActuator의 /metrics 엔드포인트를 이용하면 애플리케이션의 메모리 사용량, 가비지 수집 및 스레드 활동과 같은 메트릭을 수집할 수 있습니다. 이를 통해 최적화가 필요한 영역을 파악하는 데 도움이 됩니다.\n\n2. 캐싱:\n\n캐싱을 사용하면 데이터로드를 줄이고 응답 시간을 단축할 수 있습니다. Spring은 최소한의 설치로 훌륭한 지원을 제공합니다.\n\n```java\n@SpringBootApplication\n@EnableCaching\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSpring Boot은 EhCache, Hazelcast, 그리고 Redis를 포함한 여러 캐시 제공자를 지원합니다. 예를 들어, EhCache를 사용하려면 다음 종속성을 추가하십시오:\n\n```js\n\u003cdependency\u003e\n    \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e\n    \u003cartifactId\u003espring-boot-starter-cache\u003c/artifactId\u003e\n\u003c/dependency\u003e\n\u003cdependency\u003e\n    \u003cgroupId\u003enet.sf.ehcache\u003c/groupId\u003e\n    \u003cartifactId\u003eehcache\u003c/artifactId\u003e\n\u003c/dependency\u003e\n```\n\n캐싱 어노테이션을 사용하여 캐싱 동작을 지정할 수 있습니다:\n\n- @Cacheable: 메소드 결과를 캐싱할 수 있음을 나타냅니다.\n- @CachePut: 메소드 결과로 캐시를 업데이트합니다.\n- @CacheEvict: 캐시에서 항목을 제거합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n```java\n@Cacheable(\"books\")\npublic Book findBookById(Long id) {\n    return bookRepository.findById(id).orElse(null);\n}\n```\n\n3. 좋은 데이터베이스 상호작용\n   데이터베이스 상호작용은 종종 응용프로그램의 병목 현상이 될 수 있습니다. 데이터베이스 성능을 최적화하기 위한 몇 가지 팁을 소개합니다. 아래는 HikariCP를 사용한 예시 설정입니다:\n\n쿼리 최적화\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n색인 만들기: 데이터베이스 테이블이 올바르게 색인화되었는지 확인하세요.\n\n- 일괄 처리: 대량 삽입 및 업데이트에는 일괄 처리를 사용하세요.\n- 지연 로딩: 엔티티 관계에 대해 지연 로딩을 활용하여 불필요한 데이터 로딩을 피하세요.\n\nJPA와 Hibernate 팁\n\n- 검색 유형: 컬렉션에 대해 FetchType.LAZY를 사용하여 불필요한 데이터로딩을 피하세요.\n- 두 번째 레벨 캐시: Hibernate의 두 번째 레벨 캐시를 활성화하여 데이터베이스 조회를 줄이세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nQuery Optimization: JPQL이나 네이티브 쿼리를 사용하여 최적화된 쿼리를 작성하세요.\n\n## 지연 로딩의 예시\n\n```js\n@Entity\npublic class Author {\n    @OneToMany(fetch = FetchType.LAZY, mappedBy = \"author\")\n    private Set\u003cBook\u003e books;\n}\n```\n\n## 데이터베이스 연결 풀링\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터베이스 연결을 효율적으로 활용하기 위해 연결 풀을 구성하세요:\n\n```js\nspring.datasource.hikari.maximum-pool-size=15\nspring.datasource.hikari.minimum-idle=5\nspring.datasource.hikari.idle-timeout=30000\nspring.datasource.hikari.connection-timeout=20000\nspring.datasource.hikari.max-lifetime=1800000\n```\n\n## 모니터링 및 분석\n\n데이터베이스 성능을 모니터링하고 느린 쿼리 또는 연결을 식별하기 위해 /metrics 및 /trace와 같은 액추에이터 엔드포인트를 사용하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSpring Boot 애플리케이션의 성능을 최적화하려면 프로파일링, 캐싱 및 효율적인 데이터베이스 상호작용의 조합이 필요합니다. 애플리케이션의 성능 특성을 이해하고 이러한 모베스트 프랙티스를 적용하여 높은 성능과 확장 가능성을 갖춘 애플리케이션을 개발할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication_0.png"},"coverImage":"/assets/img/2024-06-19-SpringBootPerformanceTuningTipsandTricksforOptimizingYourApplication_0.png","tag":["Tech"],"readingTime":6},{"title":"비동기 로깅 자바 앱에 제공되는 속도 향상","description":"","date":"2024-06-19 10:10","slug":"2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps","content":"\n\u003cimg src=\"/assets/img/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps_0.png\" /\u003e\n\n소프트웨어 개발의 급속한 영역에서 밀리초가 문제가 되며 시스템 응답성이 품질 요건인 곳에서 전통적인 동기식(sync) 로깅에서 비동기식(async) 로깅으로의 여정은 게임 체인저로 입증되었습니다. 경험 많은 개발자로써, 특히 고도의 환경에서 성능을 최적화하는 중요성을 알고 계실 것입니다. 본격적인 투자 은행 응용 프로그램을 작업해왔을 때, 최적의 응답 시간을 달성하는 것에 대한 과제를 직면했습니다. 그 경계를 넘어 올 수 있는 것 같았던 것 — 400 TPS. 감사 작업은 중요했지만, 전통적인 로깅은 속도를 늦추는 앵커였습니다. 그런 다음, 우리는 대담한 결정을 내렸습니다: 비동기식 로깅. 그리고 말씀드리지만, 그것은 저희가 필요했다는 것을 전혀 모르고 있는 게임 체인저였습니다.\n\n우리가 어떻게 성취했는지 궁금하신가요? 준비됐나요? 이 블로그는 즐거운 비동기식 로깅의 세계로 다가갑니다. 저는 개발 이야기의 중요한 순간에 대해 더욱 자세히 살펴볼 것이며, 비동기식 로깅으로의 전환과 전략적인 응용 프로그램 및 인프라 조정이 예상을 충족시키는데 그친 것이 아닌 더 초과했던 순간에 대해 알아볼 것입니다.\n\n간단한 Java 응용 프로그램을 만들어 비동기식 로깅의 영향을 시연해보겠습니다. 저는 log4j-api.2.17.1, log4-core.2.17.1 및 lmax disruptor.4.0.0 같은 종속성을 가진 JDK 17을 사용할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 코드는 GitHub에서 사용할 수 있습니다.\n\n주 Java 클래스는 아래와 같이 보일 것입니다. 두 가지 메서드인 syncConsoleLogging()과 asyncLo4j2Log()를 포함하고 있습니다. syncConsoleLogging() 메서드는 메시지를 동기적으로 Log4j2를 사용하여 콘솔에 로깅하며, asyncLo4j2Log() 메서드는 메시지를 비동기적으로 로깅합니다. 이 예제는 비동기 로깅이 성능을 향상시킬 수 있는 방법을 이해하는 데 도움이 됩니다, 특히 로깅 작업이 많은 시나리오에서.\n\n아래 log4j2.xml 스니펫은 두 개의 appender인 RandomAccessFile과 Console을 정의합니다. RandomAccessFile appender는 특정 패턴 레이아웃을 사용하여 \"target\" 디렉토리의 \"async.log\" 파일에 메시지를 로깅하며, Console appender는 다른 패턴 레이아웃으로 시스템 콘솔에 메시지를 로깅합니다. 파일 appender는 성능을 향상시키기 위해 일괄로 flush되도록 설정되어 있습니다. 추가로 루트 로거는 \"info\" 레벨의 메시지를 파일 appender에 로깅하도록 구성되어 있고, \"syncLogger\"라는 별도의 로거가 콘솔 appender에 메시지를 로깅하도록 정의되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n        \u003c!-- Async Loggers will auto-flush in batches, so switch off immediateFlush. --\u003e\n        \u003cRandomAccessFile name=\"RandomAccessFile\" fileName=\"target/async.log\" immediateFlush=\"false\" append=\"false\"\u003e\n            \u003cPatternLayout\u003e\n                \u003cPattern\u003e%d %p %c{1.} [%t] %m %ex%n\u003c/Pattern\u003e\n            \u003c/PatternLayout\u003e\n        \u003c/RandomAccessFile\u003e\n\n        \u003cConsole name=\"Console\" target=\"SYSTEM_OUT\"\u003e\n            \u003cPatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/\u003e\n        \u003c/Console\u003e\n\n위 코드를 실행하면 Async 로깅의 영향을 확인할 수 있습니다. 제 개인 노트북에서 실행 후 아래 출력을 확인했습니다. 이 시나리오에서 Async 로깅이 동기 로깅보다 약 72.98% 빠름을 보여줍니다.\n\n=== 처리 시간 요약 ===\n동기 로깅 시간 2184 ms\nAsync 로깅 시간 590 ms\n\n## Async 로깅의 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바 애플리케이션에 대한 비동기 로깅은 성능 및 응답성 향상부터 높은 로깅 양을 처리하고 확장성을 향상시키는 장점을 제공합니다.\n\n성능 향상: 애플리케이션의 주 스레드는 로깅 I/O가 완료될 때까지 기다리지 않으므로 응답성이 빨라집니다.\n\n응답성: 로깅이 사용자 상호작용이나 다른 중요한 작업을 차단하지 않습니다.\n\n확장성: 로깅 인프라는 더 많은 로그를 수용하도록 순조롭게 확장되어 애플리케이션의 핵심 기능에 영향을 주지 않습니다. 로깅을 주 애플리케이션 스레드로부터 분리함으로써 비동기 로깅은 수평 확장을 가능케 합니다. Disruptor 풀에 더 많은 워커 스레드를 추가함으로써 로깅 성능을 확장하여 더 높은 로그 양을 처리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자원 사용량 줄이기: 주 스레드의 컨텍스트 전환 오버헤드와 메모리 소비를 최소화하세요.\n\n고장 허용성 향상: 메인 스레드로부터 로깅을 분리하여 애플리케이션 충돌을 방지하세요. 디스크 공간이 가득 찼을 때 애플리케이션이 멈추거나 정지된 적이 있나요?\n\n## 고려 사항:\n\n- 복잡성: 비동기 로깅은 동기 로깅보다 더 많은 설정과 이해를 요구할 수 있습니다.\n- 오류 처리: 잠재적인 로깅 오류와 큐 오버플로우를 처리하는 강력한 전략을 구현하세요.\n- 로그 메시지의 순서: 비동기 로깅은 특히 여러 스레드가 동시에 로깅할 때 로그 메시지의 순서가 뒤죽박죽이 될 수 있습니다. 로거는 로그 메시지의 순서를 보존하려 노력하지만 로깅의 비동기적인 특성으로 인해 결정론적이지 않은 동작을 가져올 수 있습니다.\n- 디버깅 및 문제 해결: 비동기 로깅 문제를 디버깅하는 것은 도전적일 수 있습니다. 특히 레이스 컨디션, 데드락 또는 예상치 못한 로깅 동작과 관련된 경우에는 신중한 분석과 테스트가 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n축하해요! 이제 비동기 로깅을 이해하고 활용할 지식으로 무장했어요. 앞으로 가서 느린 시스템을 뒤로 한 채 빠르고 반응성 있는 어플리케이션을 만들어보세요!\n\n이 블로그는 비동기 로깅의 매력적인 세계를 탐험하며, 로깅을 주 애플리케이션에서 분리함으로써 가치 있는 리소스를 확보하는 방법을 보여줬어요. 비동기 로깅이 전통적인 동기 로깅과 비교했을 때 성능을 놀라운 72% 향상시킨 실제 자바 예제를 살펴봤어요. 네 맞아요, 더 빠른 로깅, 더 행복한 사용자, 그리고 더 적은 스트레스를 받을 거예요! 하지만 어떤 도구든 그것의 한계가 있죠. 비동기 로깅은 복잡성을 추가하며 신중한 구성이 필요하다는 것을 기억하세요.\n","ogImage":{"url":"/assets/img/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps_0.png"},"coverImage":"/assets/img/2024-06-19-AsyncLoggingTheSpeedBoostYourJavaApps_0.png","tag":["Tech"],"readingTime":5},{"title":"자바 HashSet 초보자가 꼭 알아야 할 내용","description":"","date":"2024-06-19 10:08","slug":"2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow","content":"\n\u003cimg src=\"/assets/img/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow_0.png\" /\u003e\n\n# 소개\n\nJava HashSet은 Java에서 가장 일반적으로 사용되는 데이터 구조 중 하나입니다. 고유한 요소를 저장하고 효율적인 조회를 수행하는 간단하면서 강력한 방법을 제공합니다. 이 기사에서는 HashSet이 무엇인지, 어떻게 사용하는지, 일반적인 작업 및 사용 사례에 대해 탐구할 것입니다. 이 기사는 이미 HashSet에 익숙한 사람들에게도 좋은 리프레셔 역할을 할 것입니다.\n\n# HashSet이란 무엇인가?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHashSet은 Java Collections Framework의 일부이며 Set 인터페이스를 구현합니다. 이는 해시 테이블 (실제로는 HashMap 인스턴스)에 기반하며 중복 요소를 허용하지 않습니다. HashSet의 주요 특징은 다음과 같습니다:\n\n- 중복 요소 없음: HashSet은 중복을 자동으로 처리합니다. 집합에 이미 존재하는 요소를 추가하려고 시도하면 무시됩니다.\n- 순서 없음: HashSet의 요소는 특정 순서로 저장되지 않습니다. 요소가 추가되고 제거됨에 따라 순서가 변경될 수 있습니다.\n- 효율적: HashSet은 해시 함수가 요소를 적절하게 버킷에 분산시키는 경우 추가, 제거, 포함 여부, 크기 등의 기본 작업에 대해 상수 시간 성능을 제공합니다.\n\n## HashSet는 어떻게 동작합니까?\n\nHashSet은 해싱을 사용하여 요소를 저장하고 검색합니다. HashSet에 요소를 추가할 때 다음 단계가 발생합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 해시 코드 계산: 객체의 hashCode 메서드를 호출하여 해시 코드를 계산합니다. 이 해시 코드는 객체의 메모리 주소를 간단히 나타내는 정수 값입니다.\n- 해시 코드 모듈로 연산: 그런 다음 해시 코드를 해시 테이블의 버킷(슬롯) 수로 나누고 나머지를 사용하여 요소를 저장할 버킷의 인덱스로 사용합니다. 이를 통해 해시 코드가 사용 가능한 버킷의 범위 내에 매핑되도록 합니다.\n- 충돌 처리: 두 요소가 동일한 해시 코드를 가지는 경우(충돌), 이들은 같은 버킷에 저장되지만 해당 버킷 내에서 목록 또는 트리 구조로 연결됩니다.\n- 요소 저장: 결정된 버킷에 요소가 저장되고 해당 요소에 대한 참조가 유지됩니다.\n\ncontains 또는 remove와 같은 작업을 수행할 때 요소의 해시 코드가 계산되고 동일한 프로세스를 사용하여 적절한 버킷이 찾아지며 해당 버킷에서 요소가 발견되거나 제거됩니다.\n\n## 왜 HashSet을 사용해야 하는가?\n\nHashSet은 다양한 시나리오에 적합하게 만드는 여러 장점을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 중복 제거: HashSet은 각 요소가 고유하다고 자동으로 보장합니다. 이는 중복이 허용되지 않는 항목의 컬렉션을 저장해야 하는 경우 유용합니다. 예를 들어, 고유한 사용자 이름이나 제품 ID 목록 등.\n- 효율적인 조회: HashSet은 추가, 삭제, 요소 존재 여부 확인과 같은 기본 작업에 대해 상수 시간 성능을 제공합니다. 이로 인해 캐싱 메커니즘이나 멤버십 테스팅과 같이 빠른 조회가 중요한 사용 사례에 이상적입니다.\n- 메모리 효율성: HashSet은 해시 테이블로 지원되기 때문에 다른 자료구조인 트리나 연결 리스트와 비교했을 때 특히 요소 수가 많을 때 더 메모리 효율적일 수 있습니다.\n- 집합 연산: HashSet은 합집합, 교집합, 차집합과 같은 수학적 집합 연산을 수행하는 데 사용할 수 있습니다. 이러한 연산은 데이터 필터링, 컬렉션 간의 공통 요소 찾기, 특정 항목을 집합에서 제외하는 등의 시나리오에서 유용합니다.\n\n## HashSet 생성\n\nJava에서 HashSet을 생성하는 것은 간단합니다. 다음은 간단한 예제입니다:\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetExample {\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n\n        // HashSet에 요소 추가\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n\n        // HashSet 출력\n        System.out.println(\"HashSet: \" + set);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제에서는 문자열의 HashSet을 만들고 세 가지 요소를 추가합니다. System.out.println 문은 세트의 요소를 출력합니다. 요소의 순서가 보장되지 않는 점을 유의하세요.\n\n## HashSet의 내부 작동\n\n내부 작동에 대해 더 알아보려면 다음 사항을 고려해보세요:\n\n- 해시 함수: 객체의 hashCode 메서드가 중요합니다. 잘 설계된 해시 함수는 요소를 균일하게 버킷에 분산시켜 충돌 가능성을 줄이고 성능을 유지합니다.\n- 버킷 구조: HashSet의 각 버킷은 실제로 연결된 리스트나 균형 잡힌 트리(대규모 집합의 경우)입니다. 여러 요소가 동일한 버킷으로 해싱되면 이 리스트/트리에 저장됩니다.\n- 로드 팩터: 로드 팩터는 해시 테이블의 용량이 자동으로 증가되기 전에 얼마나 가득 찰 수 있는지를 측정하는 지수입니다. 기본 로드 팩터 0.75는 시간과 공간 비용 사이의 적절한 균형을 유지합니다.\n- 다시 해싱: 요소 수가 로드 팩터와 현재 용량의 곱을 초과하면 해시 테이블이 리사이징되고(일반적으로 크기가 두 배로 늘어남) 요소가 새 버킷에 다시 해싱됩니다. 이를 통해 HashSet이 성능 특성을 유지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 내부 메커니즘을 이해함으로써, 자바의 HashSets의 효율성과 유연성을 더 잘 이해할 수 있습니다.\n\n# HashSets에서의 기본 작업\n\n## 요소 추가 및 제거\n\nHashSet에 요소를 추가하는 방법은 add 메서드를 사용하는 것입니다. 이미 HashSet에 요소가 있는 경우 다시 추가되지 않습니다. 요소를 제거하는 방법은 remove 메서드를 사용하여 수행할 수 있습니다. 이 작업을 보여주는 예제는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetOperations {\n    public static void main(String[] args) {\n        // Creating a HashSet\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n\n        // Adding elements to the HashSet\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n        set.add(\"Avocado\"); // Duplicate element, won't be added\n\n        System.out.println(\"HashSet after adding elements: \" + set);\n\n        // Removing an element\n        set.remove(\"Peach\");\n\n        System.out.println(\"HashSet after removing Peach: \" + set);\n    }\n}\n```\n\n이 예제에서는 문자열 HashSet을 만들고 중복되는 \"Avocado\"를 포함한 네 가지 요소를 추가합니다. 중복 요소는 무시됩니다. 그런 다음 세트에서 \"Peach\"를 제거합니다.\n\n## 요소 확인\n\nHashSet이 특정 요소를 포함하는지 확인하려면 contains 메서드를 사용할 수 있습니다. 이 메서드는 요소가 있으면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetContains {\n    public static void main(String[] args) {\n        // Creating a HashSet\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n\n        // Checking for elements\n        boolean containsAvocado = set.contains(\"Avocado\");\n        boolean containsGrape = set.contains(\"Grape\");\n\n        System.out.println(\"Contains Avocado: \" + containsAvocado);\n        System.out.println(\"Contains Grape: \" + containsGrape);\n    }\n}\n```\n\n이 예제에서는 HashSet에 \"Avocado\"와 \"Grape\" 요소가 포함되어 있는지 확인합니다. 출력 결과에 따르면 \"Avocado\"가 존재하지만 \"Grape\"는 존재하지 않습니다.\n\n## 요소 반복\n\nfor-each 루프나 반복자(iterator)를 사용하여 HashSet의 요소를 반복할 수 있습니다. HashSet은 요소의 특정 순서를 유지하지 않기 때문에 반복 순서는 보장되지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFor-Each Loop을 사용하는 방법\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetIteration{\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n\n        // For-Each 루프 사용\n        System.out.println(\"For-Each 루프 사용:\");\n        for(String fruit : set) {\n            System.out.println(fruit);\n        }\n    }\n}\n```\n\nIterator 사용하는 방법\n\n```java\nimport java.util.HashSet;\nimport java.util.Iterator;\n\npublic class HashSetIterator {\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n\n        // Iterator 사용\n        System.out.println(\"Iterator 사용:\");\n        Iterator\u003cString\u003e iterator = set.iterator();\n        while(iterator.hasNext()) {\n            System.out.println(iterator.next());\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제에서는 for-each 루프와 반복자가 모두 HashSet의 요소를 순회하는 데 사용됩니다. 요소들은 콘솔에 출력되지만 순회 순서는 지정되지 않습니다.\n\n## HashSet의 크기\n\nHashSet에있는 요소 수를 얻으려면 size 메서드를 사용하세요. 이 메서드는 현재 집합에 있는 요소 수를 나타내는 정수를 반환합니다.\n\n```js\nimport java.util.HashSet;\n\npublic class HashSetSize {\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n\n        // HashSet의 크기 가져오기\n        int size = set.size();\n\n        System.out.println(\"HashSet의 크기: \" + size);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예에서는 size 메서드를 사용하여 HashSet의 요소 수를 결정하고 그 값을 콘솔에 출력합니다.\n\n## HashSet 지우기\n\nHashSet에서 모든 요소를 제거하려면 clear 메서드를 사용할 수 있습니다. 이 메서드는 모든 요소를 제거하여 집합을 효과적으로 비웁니다.\n\n```js\nimport java.util.HashSet;\n\npublic class HashSetClear {\n    public static void main(String[] args) {\n        // HashSet 생성\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        set.add(\"Avocado\");\n        set.add(\"Peach\");\n        set.add(\"Cherry\");\n\n        // HashSet 지우기\n        set.clear();\n\n        System.out.println(\"HashSet 지우기 후: \" + set);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예시에서 clear 메서드는 모든 요소를 제거하여 빈 세트를 만듭니다.\n\n## HashSet이 비어 있는지 확인하기\n\nHashSet이 비어 있는지 확인하려면 isEmpty 메서드를 사용하십시오. 이 메서드는 세트가 요소를 포함하지 않으면 true를 반환하고 그렇지 않으면 false를 반환합니다.\n\n```java\nimport java.util.HashSet;\n\npublic class HashSetIsEmpty {\n    public static void main(String[] args) {\n        // HashSet 만들기\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n\n        // HashSet이 비어 있는지 확인\n        boolean isEmpty = set.isEmpty();\n\n        System.out.println(\"HashSet이 비어 있는가? \" + isEmpty);\n\n        // 요소 추가 후 다시 확인\n        set.add(\"Avocado\");\n        isEmpty = set.isEmpty();\n\n        System.out.println(\"요소를 추가한 후 HashSet이 비어 있는가? \" + isEmpty);\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 예제에서는 HashSet에 요소를 추가하기 전후에 비어 있는지 확인합니다. 출력 결과는 집합의 상태 변화를 반영합니다.\n\n# 고급 사용법 및 팁\n\n## HashSet에 사용자 지정 객체\n\nHashSet은 사용자 지정 객체를 저장할 수 있지만, 이러한 객체에서 equals 및 hashCode 메소드를 올바르게 재정의하는 것이 중요합니다. 이렇게 하면 HashSet이 두 객체가 동일한지 올바르게 판별하고 해싱을 효과적으로 처리할 수 있습니다. 다음은 사용자 지정 Person 클래스 예제입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nimport java.util.HashSet;\nimport java.util.Objects;\n\nclass Person {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Person person = (Person) o;\n        return age == person.age \u0026\u0026 Objects.equals(name, person.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n\n    @Override\n    public String toString() {\n        return name + \" (\" + age + \")\";\n    }\n}\n\npublic class HashSetCustomObjects {\n    public static void main(String[] args) {\n        HashSet\u003cPerson\u003e set = new HashSet\u003c\u003e();\n        set.add(new Person(\"Alice\", 30));\n        set.add(new Person(\"Bob\", 25));\n        set.add(new Person(\"Alice\", 30)); // Duplicate, won't be added\n\n        System.out.println(\"HashSet: \" + set);\n    }\n}\n```\n\n이 예제에서 Person 클래스는 equals 및 hashCode 메서드를 재정의하여 이름과 나이가 같은 두 Person 객체를 동일하게 처리할 수 있도록합니다. HashSet은 이러한 메서드를 사용하여 요소를 올바르게 관리합니다.\n\n## 성능 고려사항\n\nHashSet은 기본 연산에 대해 상수 시간 성능을 제공하지만 여러 요인이 효율에 영향을 미칠 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 해시 함수: 좋은 해시 함수는 성능에 중요합니다. 요소를 균일하게 버킷에 분산시켜 충돌을 최소화해야 합니다. 제대로 구현되지 않은 hashCode 메서드는 많은 충돌을 일으켜 성능을 저하시킬 수 있습니다.\n- 초기 용량 및 로드 요소: HashSet의 초기 용량과 로드 요소(기본값은 0.75)는 리해싱이 발생하는 시점을 결정합니다. 리해싱은 해시 테이블을 크기를 조정하고 요소를 재분배하는 비용이 많이 드는 작업을 포함합니다. 예상 요소 수에 기반하여 이러한 매개변수를 조정하면 성능을 최적화할 수 있습니다.\n- 충돌 처리: 충돌이 발생하면 요소가 동일한 버킷 내에 연결 목록이나 균형 잡힌 트리에 저장됩니다. 빈번한 충돌은 성능을 떨어뜨릴 수 있으므로 해시 코드의 좋은 분포를 보장하는 것이 중요합니다.\n\n## 일반적인 사용 사례\n\nHashSets는 다양한 시나리오에서 다양하게 사용할 수 있습니다:\n\n- 중복 제거: HashSets는 목록에서 중복 요소를 필터링하는 데 이상적입니다. 예를 들어 더 큰 컬렉션에서 고유한 사용자 이름 목록을 얻기 위해 HashSet를 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class RemoveDuplicates {\n    public static void main(String[] args) {\n        List\u003cString\u003e usernames = new ArrayList\u003c\u003e();\n        usernames.add(\"Alice\");\n        usernames.add(\"Bob\");\n        usernames.add(\"Alice\"); // 중복\n\n        HashSet\u003cString\u003e uniqueUsernames = new HashSet\u003c\u003e(usernames);\n\n        System.out.println(\"고유한 사용자명: \" + uniqueUsernames);\n    }\n}\n```\n\n- 멤버십 테스팅: HashSet은 요소가 집합의 일부인지 확인하는 효율적인 방법을 제공합니다. 사용자가 특정 역할을 가지고 있는지 확인하거나 재고에 제품이 있는지 확인하는 등의 시나리오에서 유용합니다.\n\n```java\nimport java.util.HashSet;\n\npublic class MembershipTesting {\n    public static void main(String[] args) {\n        HashSet\u003cString\u003e roles = new HashSet\u003c\u003e();\n        roles.add(\"Admin\");\n        roles.add(\"User\");\n        roles.add(\"Guest\");\n\n        String roleToCheck = \"Admin\";\n        if (roles.contains(roleToCheck)) {\n            System.out.println(roleToCheck + \" 역할이 있습니다.\");\n        } else {\n            System.out.println(roleToCheck + \" 역할이 없습니다.\");\n        }\n    }\n}\n```\n\n- 집합 연산: HashSet은 합집합, 교집합, 차집합과 같은 수학적 집합 연산을 수행할 수 있습니다. 이러한 연산은 데이터 필터링, 컬렉션 간 공통 요소 찾기, 특정 항목을 세트에서 제외하는 등의 시나리오에서 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nimport java.util.HashSet;\n\npublic class SetOperations {\n    public static void main(String[] args) {\n        HashSet\u003cString\u003e set1 = new HashSet\u003c\u003e();\n        set1.add(\"Avocado\");\n        set1.add(\"Peach\");\n        set1.add(\"Cherry\");\n\n        HashSet\u003cString\u003e set2 = new HashSet\u003c\u003e();\n        set2.add(\"Peach\");\n        set2.add(\"Dragonfruit\");\n        set2.add(\"Elderberry\");\n\n        // Union\n        HashSet\u003cString\u003e union = new HashSet\u003c\u003e(set1);\n        union.addAll(set2);\n        System.out.println(\"Union: \" + union);\n\n        // Intersection\n        HashSet\u003cString\u003e intersection = new HashSet\u003c\u003e(set1);\n        intersection.retainAll(set2);\n        System.out.println(\"Intersection: \" + intersection);\n\n        // Difference\n        HashSet\u003cString\u003e difference = new HashSet\u003c\u003e(set1);\n        difference.removeAll(set2);\n        System.out.println(\"Difference: \" + difference);\n    }\n}\n```\n\n위 예제들에서는 HashSet을 사용하여 중복 제거, 멤버십 테스트 수행, 그리고 합집합, 교집합, 차집합과 같은 집합 연산을 수행하는 방법을 보여줍니다.\n\n# 결론\n\nJava의 HashSet은 고유한 요소의 컬렉션을 관리하는 멋진 도구입니다. 요소 추가, 제거, 확인을 위한 효율적인 작업을 제공하여 성능과 고유성이 중요한 시나리오에 이상적입니다. HashSet의 기본 사항, 고급 사용법 및 주요 사용 사례를 이해함으로써 이 유연한 데이터 구조를 사용하여 더 효과적이고 효율적인 Java 프로그램을 작성할 수 있습니다. 중복 필터링, 집합 연산 수행, 사용자 정의 객체 관리와 같은 작업을 수행할 때 HashSet은 컬렉션 요구 사항에 대한 강력한 솔루션을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Java HashSet 문서\n- Java 컬렉션 프레임워크\n\n읽어 주셔서 감사합니다! 만약 이 안내서가 도움이 되셨다면, 하이라이팅, 좋아요, 댓글 작성, Twitter/X를 통해 연락 주시면 정말 감사하겠습니다. 이는 매우 고마우며 이와 같은 콘텐츠를 무료로 제공할 수 있도록 도와줍니다!\n","ogImage":{"url":"/assets/img/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow_0.png"},"coverImage":"/assets/img/2024-06-19-JavaHashSetWhatBeginnersNeedtoKnow_0.png","tag":["Tech"],"readingTime":17},{"title":"시니어 자바 소프트웨어 엔지니어가 흔히 받는 인터뷰 질문들","description":"","date":"2024-06-19 10:07","slug":"2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions","content":"\n![image](/assets/img/2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions_0.png)\n\n2019년부터 영국에서 살고 일해오고 있어요. 2008년부터 Java 개발을 하고 있어서, 이 자리에서는 시니어 포지션에 지원할 때 자주 등장하는 질문들을 공유할 거예요. 최근에는 한 회사의 리소그에 참여하면서, 이 기사가 발행된 2024년 6월 5일을 기준으로 지난 2개월 반이 좀 더 지났습니다. 이 기간 동안 Java 언어를 사용하는 시니어 개발자 역할에 대한 다양한 인터뷰를 진행했어요.\n\n이 자리에서 자주 등장하는 질문들과 간결하고 직접적인 답변을 공유할 거에요. 설명을 그냥 대충 넘기지 말고, 면접관에게 더 명확하게 설명하기 위해 답변을 더 깊게 파고들어야 하는 답변들도 있어요. 그 말인 즉, 여기 수록된 답변은 직접적인 대답을 위한 제안일 뿐이에요.\n\n물론, 다른 질문들도 받았지만, 가장 자주 나오는 것들을 여기에 정리해 두는 것이죠. 새로운 반복들을 발견할 때마다 다른 질문과 이에 대한 직접적인 답변들도 추가할 거에요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 객체 지향 프로그래밍이란 무엇인가요?\n\n객체 지향 프로그래밍(OOP)은 프로그램 내의 객체를 생각하면서 코드를 구성하는 방법입니다. 이러한 객체들은 실제 세계의 엔티티를 나타내며 데이터와 동작을 함께 캡슐화하는 데 사용됩니다. OOP의 원칙에는 캡슐화, 상속, 다형성 및 추상화가 포함되어 있으며, 이는 모듈식이고 재사용 가능한 코드를 생성하는 데 도움이 됩니다.\n\n# 의존성 주입이란 무엇인가요?\n\n의존성 주입(DI)은 소프트웨어 공학에서의 디자인 패턴으로, 구성 요소의 의존성이 구성 요소 자체 내에서 생성되는 대신 외부에서 주입되는 방식입니다. 이는 구성 요소가 자체 의존성을 만드는 대신 외부 소스로부터 제공받는 것을 의미합니다. DI의 주요 장점에는 모듈성 증가, 테스트 용이성 및 관심사의 분리가 포함됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 의존성 주입의 장점은 무엇인가요?\n\n- 컴포넌트 간 결합도를 낮춥니다.\n- 코드의 유지보수와 테스트 용이성을 향상시킵니다.\n- 더 깨끗한 코드와 디자인을 장려합니다.\n\n# 의존성 주입을 구현하는 가장 흔한 방법은 무엇인가요?\n\n- 생성자 주입: 의존성은 클래스 생성자를 통해 제공됩니다.\n- 세터 주입: 의존성은 세터 메서드를 통해 제공됩니다.\n- 메서드 주입: 의존성은 메서드를 통해 제공됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데드락이란 무엇인가요?\n\n데드락은 둘 이상의 프로세스가 상대가 자원을 해제할 때까지 대기하면서 진행할 수 없는 상황을 의미합니다. 이는 순환 대기 상태를 만들어 내어 정지 상태에 빠지게 됩니다.\n\n# 데드락을 피하는 방법은 무엇인가요?\n\n- 은행원 알고리즘: 프로세스가 사용할 최대 자원을 선언하고, 요청한 자원이 사용 가능한 자원보다 작을 경우 실행이 허용됩니다.\n- 세마포어: 상호 배제를 보장하여 임계 구역에 하나의 프로세스만 들어가도록 합니다.\n- 상호 배제: 이 조건은 최소한 하나의 자원이 공유할 수 없는 모드로 보유되어야 한다는 것을 의미합니다. 프린터나 테이프 드라이브와 같은 일부 자원은 본질적으로 공유할 수 없기 때문에 이 조건을 제거하는 것이 항상 가능하지는 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 장애 허용이란 무엇인가요?\n\n장애 허용은 시스템이 일부 구성 요소가 실패해도 올바르게 작동을 계속할 수 있는 능력을 말합니다. 이는 시스템의 신뢰성과 가용성을 유지하여 장애를 우아하게 처리합니다.\n\n# 서킷 브레이커란 무엇인가요?\n\n서킷 브레이커는 전기가 너무 많이 흐를 경우 자동으로 전기를 차단하여 전기 화재를 예방하고 가전제품을 보호하는 안전 스위치와 같은 역할을 합니다. 소프트웨어에서는 서킷 브레이커 패턴이 서비스의 장애를 막아 시스템이 회복할 수 있도록 요청 흐름을 중지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# SQL 대 NoSQL\n\n## SQL을 사용해야 하는 경우:\n\n- 구조화된 데이터: 데이터가 명확한 구조와 관계를 가지고 있을 때\n- 복잡한 트랜잭션: ACID 트랜잭션이 필요하여 데이터 무결성을 보장해야 할 때\n\n## NoSQL을 사용해야 하는 경우:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 수평 확장성: 확장성이 중요할 때 NoSQL은 더 유연합니다.\n- 반구조화/구조화되지 않은 데이터: 관계형 모델에 잘 맞지 않는 JSON이나 XML과 같은 데이터에 적합합니다.\n\n## 인증과 권한 부여의 차이는 무엇인가요?\n\n- 인증(Authentication): 사용자의 신원을 확인하는 것으로, 일반적으로 비밀번호, 생체 인식 또는 보안 토큰과 같은 자격 증명을 통해 이루어집니다.\n- 권한 부여(Authorization): 인증된 사용자가 특정 리소스에 액세스하거나 특정 작업을 수행할 권한이 있는지 결정하는 것입니다.\n\n## REST란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nREST (Representational State Transfer)은 HTTP 프로토콜을 사용하여 분산 시스템 간 통신하는 시스템 디자인입니다.\n\n# 추상 클래스와 인터페이스의 차이점은 무엇인가요?\n\n- 추상 클래스: 인스턴스화 할 수 없는 부분적으로 정의된 클래스입니다. 추상 및 구체적인 메서드뿐만 아니라 인스턴스 변수를 가질 수 있습니다.\n- 인터페이스: 메서드 시그니처와 상수 필드만 포함하는 완전히 추상화된 구조입니다.\n\n# Java에서 equals()와 hashCode() 메서드의 차이점은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- equals(): 두 개의 객체가 논리적으로 동일한지를 결정합니다.\n- hashCode(): 객체에 대한 해시 값을 제공합니다. HashMap 및 HashSet과 같은 해시 기반 컬렉션에서 올바른 동작을 보장하려면 두 메서드를 함께 오버라이드해야 합니다.\n\n## ArrayList와 LinkedList의 차이점은 무엇인가요?\n\n- ArrayList: 빠른 임의 접근을 제공하는 배열 기반 구현이지만 삽입/제거 속도가 느립니다.\n- LinkedList: 어느 위치에서든 빠른 삽입/제거를 제공하는 노드 기반 구현이지만 임의 접근 속도가 느립니다.\n\n## Checked와 Unchecked 예외의 차이점은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 확인된 예외: 컴파일 시간에 확인되며 명시적으로 처리하거나 선언이 필요합니다.\n- 확인되지 않은 예외(런타임 예외): 실행 중에 발생하며 명시적 처리 없이 프로그램이 컴파일됩니다.\n\n# 자바에서 동시성을 다루는 방법은?\n\n자바에서 동시성은 쓰레드 클래스 또는 Runnable 인터페이스를 사용하여 다중 스레딩을 통해 처리하고, 동기화 메커니즘인 동기화 블록, volatile 변수 또는 java.util.concurrent 패키지의 클래스를 사용하여 공유 리소스에 대한 액세스를 제어할 수 있습니다.\n\n# 운영 중 버그를 모니터링하는 방법은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 로깅: Log4J를 사용합니다.\n- 로그 관리: Logstash 또는 Datadog와 같은 도구를 사용합니다.\n- 애플리케이션 상태 확인: Spring Actuator를 예로 사용합니다.\n- Kubernetes: 라이브니스 및 레디니스 프로브 사용합니다.\n\n# 자바에서 가비지 컬렉터는 어떻게 작동합니까?\n\n가비지 컬렉터는 더 이상 사용되지 않는 객체를 식별하고 할당 해제하여 메모리를 자동으로 관리하여 메모리를 해제하고 메모리 누수를 방지합니다.\n\n# 코드 품질을 유지하는 방법은 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 코드 리뷰: 코드를 정기적으로 검토하여 명확하고 이해하기 쉽도록 유지합니다. 변수 이름, 주석, 코드 구조 등을 확인하는 것이 포함됩니다.\n- 자동화 테스팅: 단위 및 통합 테스트를 사용하여 코드가 예상대로 작동하고 변경 사항을 적용할 때 회귀가 발생하는 것을 방지합니다.\n- 리팩터링: 코드를 정기적으로 리팩터링하여 외부 동작을 변경하지 않고 구조와 가독성을 개선합니다.\n- 코딩 표준: 일관된 코딩 표준을 준수하여 코드를 읽고 유지하기 쉽도록 합니다.\n- 문서화: 코드를 문서화하여 다른 개발자가 쉽게 이해하고 사용하는 방법을 설명합니다.\n- IDE 플러그인 및 도구: SonarLint, CheckStyle 등의 플러그인 및 도구를 사용하여 보다 간결하고 깔끔한 코드를 작성합니다.\n\n# SOLID 원칙에 대해 간단히 설명해 줄 수 있나요?\n\n- SRP(Single Responsibility Principle): 클래스는 변경되어야 하는 이유가 단 하나여야 합니다.\n- OCP(Open/Closed Principle): 소프트웨어 엔티티는 확장 가능한 상태여야 하지만 수정할 수 없는 상태여야 합니다.\n- LSP(Liskov Substitution Principle): 슈퍼 클래스의 객체는 서브 클래스의 객체로 대체 가능해야 하며 이로 인해 프로그램의 정확성에 영향을 미치지 않아야 합니다.\n- ISP(Interface Segregation Principle): 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 합니다.\n- DIP(Dependency Inversion Principle): 고수준 모듈은 저수준 모듈에 의존하면 안 되며 두 모듈 모두 추상화에 의존해야 합니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사는 저자의 경험을 반영하여 시니어 자바 소프트웨어 엔지니어를 위한 일반적인 인터뷰 질문을 포괄적으로 제공합니다. 객체 지향 프로그래밍, 의존성 주입, 동시성 및 SOLID 원칙과 같은 중요한 주제를 다루며, 지원자가 효과적으로 준비할 수 있도록 간결하고 직접적인 답변을 제공합니다. 또한, 오류 허용성, SQL 대 NoSQL, 코드 품질 유지 방법과 같은 실제 관련 문제들을 다룹니다. 이러한 통찰을 공유함으로써, 이 기사는 시니어 자바 개발자들이 인터뷰에서 뛰어나고 자신의 경력을 발전시킬 수 있는 지식을 갖추도록 목표로 합니다.\n\n기억해 주세요, 이 기사는 정기적으로 보고된 추가 질문들이 발생할 때마다 업데이트되어야 한다는 아이디어를 가지고 있습니다.\n\n앞으로의 인터뷰에서 행운을 빕니다 ;)\n","ogImage":{"url":"/assets/img/2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions_0.png","tag":["Tech"],"readingTime":9},{"title":"자바와 파이썬을 사용하여 나만의 ChatGPT와 유사한 챗봇 만들기","description":"","date":"2024-06-19 10:02","slug":"2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython","content":"\n## 처음부터 사용자 정의 LLM 추론 인프라 만들기\n\n![image](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_0.png)\n\n## 소개\n\n최근 몇 년간, 대형 언어 모델 (LLMs)이 기계와 상호 작용하는 방식을 혁신적으로 변화시키는 핵심 기술로 등장했습니다. OpenAI의 GPT 시리즈 (예: GPT-3.5 또는 GPT-4)로 표현되는 이러한 모델은 입력 텍스트 시퀀스를 가져와 일관된, 맥락에 부합하고 인간처럼 들리는 텍스트를 생성할 수 있습니다. 따라서 이러한 응용 프로그램은 고객 서비스, 콘텐츠 작성, 언어 번역 또는 코드 생성과 같은 다양한 분야에 걸쳐 다양합니다. 그러나 이러한 능력의 핵심에는 자연어 이해 과정을 개선하기 위한 어텐션 메커니즘, 규모에 걸쳐 기본 모델을 제공하기 위한 전이 학습, 데이터 증강, 또는 심지어 인간 피드백에서 강화 학습으로 이어지는 고급 기계 학습/통계 기술이 포함되어 있습니다. 이러한 시스템이 교육 과정을 확장하고 추론을 통해 지속적으로 성능을 개선할 수 있도록합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인공지능의 하위 집합으로, 머신러닝은 데이터셋을 처리하여 패턴을 식별하고 데이터의 본질을 정확하게 나타내는 모델을 개발하는데 책임이 있습니다. 이 접근 방식은 가치 있는 지식을 생성하고 콘텐츠 생성, 대량 언어 모델을 주도하는 생성적 AI 분야를 포함한 다양한 작업을 가능하게 합니다. 이 분야가 자연어뿐만 아니라 생성 가능성이 있는 모든 종류의 콘텐츠에 집중하는 것을 강조할 필요가 있습니다. 오디오에서 소리, 목소리 또는 음악을 생성할 수 있는 모델부터, OpenAI의 SORA와 같은 최신 모델을 통해 비디오, 이미지에서도 텍스트 시퀀스로부터의 편집과 스타일 전환이 가능합니다. 이후의 데이터 형식은 특히 가치가 있습니다. 다중모달 통합과 이미지/텍스트 임베딩 기술을 이용하여 자연어를 통해 지식 표현의 잠재력을 효과적으로 보여줄 수 있습니다.\n\n그러나 이러한 종류의 작업을 수행하기 위해 모델을 만들고 유지하는 것은, 특히 대규모로 할 때 매우 어려운 작업입니다. 주요 이유 중 하나는 데이터이며, 데이터는 잘 작동하는 모델에 주요 기여를 합니다. 즉, 기능적으로 최적의 아키텍처와 고품질 데이터로 모델을 훈련하면 가치 있는 결과를 얻을 수 있습니다. 그러나 제공된 데이터가 부족하면 모델이 오도하는 결과물을 생성합니다. 따라서 데이터셋을 만들 때 특정 모델 아키텍처에 적합한 양의 데이터를 포함해야 합니다. 이 요구사항은 데이터 처리와 품질 검증을 복잡하게 만들며, 자동화나 스크래핑으로 데이터를 수집하는 경우 고려해야 할 잠재적인 법적, 개인정보 보호 문제도 있습니다.\n\n다른 이유는 하드웨어에 있습니다. 현재 많은 사용자로부터 대량의 데이터를 동시에 처리해야 하는 최신 배포 모델은 크기가 크며 추론 작업을 수행하고 고객에게 품질 높은 서비스를 제공하는 데 상당한 컴퓨팅 리소스가 필요합니다. 이는 경제적인 면에서도 막대한 비용으로 반영됩니다. 한편, 신뢰할 수 있는 서비스를 제공하기 위해 적절한 하드웨어로 서버와 데이터 센터를 구축해야하며, GPU, TPU, DPU 및 성능을 최대화하기 위해 신중히 선택된 구성 요소를 고려할 때 매우 비싸다는 점을 고려해야 합니다. 또한, 유지보수에는 잠재적 문제를 해결하고 필요할 때 시스템을 업그레이드할 수 있는 자격있는 인력이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 종류의 모델 및 대규모 배포에 대한 여러 다른 문제가 있습니다. 모두 모아보면, ChatGPT와 같은 시장의 선도적인 서비스에 맞물릴만큼 견고한 지원 인프라를 갖추어 시스템을 구축하는 것은 어렵습니다. 그럼에도 불구하고 공개 도메인의 다양한 오픈 소스 콘텐츠 및 기술 덕분에 참조 서비스에 상당히 수용 가능하고 합리적인 근사치를 달성할 수 있습니다. 또한, 그 중 일부에서 제시한 고도의 진전을 고려하면 사용하는 데 매우 간편하며, 추상화, 모듈성, 통합 용이성 및 개발 프로세스를 강화하는 기타 가치 있는 특성으로 인해 혜택을 얻을 수 있습니다.\n\n따라서 이 기사의 목적은 ChatGPT와 유사한 서비스를 지원하기 위한 컴퓨팅 시스템을 설계, 구현 및 배포하는 방법을 보여주는 것입니다. 최종 결과물은 기대되는 서비스 능력을 갖추지 못할 수 있지만, 높은 품질의 종속성과 개발 도구를 사용하고 좋은 아키텍처 설계를 통해 사용자의 요구에 따라 원하는 컴퓨팅 파워까지 쉽게 확장 가능하도록 보장합니다. 즉, 시스템은 아마 한 대만 포함하여 매우 제한된 리소스로 실행되는, 해당 리소스에 맞춘 처리량을 제공하거나 적절한 하드웨어를 갖춘 더 큰 컴퓨터 네트워크에서 확장 서비스를 제공할 수 있게 준비될 것입니다.\n\n# 아키텍처\n\n최초의 시스템 기능은 클라이언트가 텍스트 쿼리를 제출하고, 이를 LLM 모델에서 처리한 다음 소스 클라이언트로 반환하는 것입니다. 모든 구현 세부사항(컴포넌트 간 통신 프로토콜, 관련된 데이터 구조 등)은 일부러 생략되었다는 점을 유념하시기 바랍니다. 그러나 이제 목표 달성을 명확히 하였으므로 문제 해결에 있어 점차적으로 세부사항을 증가시키는 분해를 시작할 수 있습니다. 이를 기능 분해라고도 하는데, 검색 및 반환 쿼리를 받는 블랙박스 시스템(추상화)부터 시작하여 클라이언트가 시스템과 상호작용하는 방법 및 이러한 상호작용을 가능케 하는 기술들을 체계적으로 정의할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_1.png)\n\n먼저, 클라이언트가 무엇으로 구성되는지, 특히 사용자가 시스템과 상호 작용하기 위해 필요한 도구나 인터페이스가 무엇인지를 결정해야 합니다. 위에서 설명한 것처럼, 시스템이 현재 완전히 구현되어 작동 중인 기능적인 단위로 가정하고 클라이언트 및 클라이언트-시스템 연결에 중점을 두도록 합니다. 클라이언트의 경우 인터페이스는 다목적으로 설계된 웹 사이트를 통해 이용할 수 있으며 주로 데스크톱 장치를 대상으로 합니다. 모바일 앱도 개발되어 동일한 시스템 서비스를 사용하고 특정 인터페이스를 통합할 수 있지만, 추상적인 관점에서 모든 종류의 클라이언트를 하나로 통합하는 것이 바람직합니다. 즉, 웹 클라이언트입니다.\n\n그 후, 클라이언트와 시스템을 연결하여 정보 교환(예: 쿼리)이 발생할 수 있도록 해야 합니다. 이 단계에서 웹 클라이언트는 JavaScript와 같은 특정 기술에 의존하며, 이에 따른 모든 통신적인 함의가 있음을 유의해야 합니다. 다른 유형의 플랫폼의 경우, 해당 기술은 아마도 변경될 것이고, 예를 들어 모바일 클라이언트에서는 Java로, IoT 장치에서는 C/C++로 변경될 수 있으며, 호환성 요구 사항으로 시스템이 그에 맞게 적응해야 할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n커뮤니케이션을 확립하는 한 가지 방법은 소켓 및 유사한 도구를 사용하여 하위 수준에서 광범위한 프로토콜 제어를 허용하는 것입니다. 그러나 이 옵션은 모든 클라이언트 기술과의 호환성 제약조건을 충족해야 한다는 상기된 접속 제약사항을 고려해야 하며, 시스템은 모든 가능한 클라이언트 유형에서 쿼리를 수집할 수 있어야 합니다. 또한 광범위한 제어를 가지는 것은 코드 줄 수가 상당히 증가하고 유지 관리 및 확장성이 복잡해지므로 더 길고 잠재적으로 훨씬 더 복잡한 개발이 필요합니다.\n\n위에서 볼 수 있듯이, 가장 최적의 대안은 클라이언트와 계산을 담당하는 시스템 부분 간의 중개 역할을 하는 응용 프로그램 프로그래밍 인터페이스(API)를 구축하는 것입니다. API를 사용하는 주요 이점은 모든 내부 연결 처리(예: 소켓 열기 및 닫기, 스레드 풀링, 데이터 직렬화와 같은 중요한 세부 사항)가 API가 구축된 프레임워크에 의해 수행된다는 것입니다. 이렇게 함으로써 클라이언트는 단지 쿼리를 서버로 보내고 API가 실행되는 곳에서 응답을 기다리기만 하면 되며, 이 모든 것은 이 API 요청을 관리하는 의존성을 실현할 수 있습니다. 이전 점에서 파생된 또 다른 혜택은 API 엔드포인트를 수정함으로써 서비스 확장을 쉽게할 수 있다는 것입니다. 예를 들어, 시스템에 새 모델이나 다른 기능을 추가하려면 새 엔드포인트를 추가하고 구현하기만 하면 되며, 통신 프로토콜 자체나 클라이언트가 시스템과 상호 작용하는 방식을 변경할 필요가 없습니다.\n\n## 컴퓨팅 서비스\n\n클라이언트가 시스템과 우아하게 통신하는 메커니즘을 설정한 후, 들어오는 쿼리를 처리하고 해당 클라이언트에 합리적인 시간 안에 반환하는 방법을 다루어야 합니다. 그러나 먼저, 시스템에 쿼리가 도착하면 관련 추론 파이프라인이 메모리에 로드된 LLM이 장착된 기계로 재지정되어 그 파이프라인을 통해 쿼리를 횡단하여 나중에 반환될 결과 텍스트(LMM 답변)를 얻어야 합니다. 그 결과, 추론 프로세스는 여러 기계 사이에 분산되어 쿼리 해결에 사용될 수 없습니다. 이를 고려하여 추론 프로세스를 지원할 인프라를 디자인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 이미지에서 컴퓨팅 서비스는 단일 단위로 표현되었습니다. 이번에는 기계를 연결한 것으로 생각하면서 소켓을 사용하여 API 서버와 연결된 단일 채널을 통해 모든 API 쿼리를 해당 기계로 리디렉션할 수 있습니다. 시스템 부하를 한 곳에 집중시켜 모든 API 쿼리를 해당 기계로 집중할 수 있습니다. 상상해 보면, 이는 몇 명의 사람만 사용하는 홈 시스템에는 좋은 선택일 것입니다. 그러나 이 경우에는 접근하기 위한 방법을 확장 가능하게 만들어야 합니다. 따라서 컴퓨팅 자원이 증가함에 따라 최대한 많은 사용자에게 서비스를 제공할 수 있도록 해야 합니다. 그러나 먼저 이전에 언급한 계산 자원을 단위로 분할해야 합니다. 이렇게 하면 상호 연결 상태를 전반적으로 파악할 수 있으며 구조나 구성 방식을 변경하여 프로젝트 처리량을 최적화할 수 있습니다.\n\n이제 이후 편의상 노드라고 부르겠지만, 계산 단위는 (모두가 처리되지는 않는) 요청을 받아 권한이 있는 물리적 기계로 통합될 것입니다. 또한 노드를 (아마 줄어든) 기계 양으로 가상화할 수 있어서 지역적으로 병렬성을 도입하여 노드 당 총 처리량을 증가시킬 수 있습니다. 사용된 하드웨어에 대해서는 서비스의 목적 및 목표에 따라 많이 달라질 것입니다. 그러나 이 경우에는 표준 CPU, 모델 로딩 또는 쿼리 전달 시 문제가 발생하지 않도록 대량의 RAM, 그리고 몇몇 경우에는 TPUs를 포함할 수 있는 GPU와 같은 전용 프로세서를 가정할 것입니다.\n\n이제, API 서버에 연결되어 여러 노드를 연결하는 네트워크를 설정할 수 있습니다. 이를 통해 네트워크 전체적으로 시스템의 모든 자원을 최적으로 활용할 수 있도록 쿼리를 분산시킬 수 있습니다. 위에서 모든 노드가 트리 모양으로 구조적으로 연결되어 있는 것을 알 수 있습니다. 루트는 API 쿼리를 수집하고 이에 따라 전달하는 역할을 담당합니다. 어떻게 서로 연결할지에 대한 결정은 정확한 시스템 목적에 상당히 의존합니다. 이 경우에는 분배 기본원의 간단함을 위해 트리가 선택되었습니다. 예를 들어, API와 노드 간의 쿼리 전달을 최대화하려면 API에서 여러 트리의 루트로 연결이 되어야 하거나 원한다면 다른 다른 데이터 구조를 사용해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로 루트 노드에 도착한 쿼리가 어떻게 전달되고 처리되는지 정의해야 합니다. 이전과 마찬가지로 사용 가능한 동등하게 유효한 대안이 많이 있습니다. 그러나 우리가 따를 알고리즘은 시스템 노드를 연결하기 위해 트리 구조가 선택되었는지 이해하는 데도 도움이 될 것입니다.\n\n![image](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_4.png)\n\n쿼리는 하나의 노드에서 해결해야 하기 때문에 분산 알고리즘의 목표는 시스템 내에서 대기 중인 노드를 찾아서 입력 쿼리를 할당하여 해결하는 것입니다. 위에서 볼 수 있듯이, 자연 순서(1부터 시작)로 번호 매겨진 쿼리들의 순서를 고려한다면, 각 숫자는 해당 쿼리를 해결하기 위해 할당된 노드에 연결된 가장자리에 해당합니다. 이 구체적인 예제에서 번호를 이해하기 위해서는 노드에 도착하는 쿼리가 무한 시간이 소요되는 것으로 가정할 수 있으며, 따라서 각 노드가 점차 바쁠 수 있도록 보장함으로써 알고리즘의 휴리스틱을 이해하는 데 도움이 됩니다.\n\n요약하면, 루트 노드는 해결 처리를 수행하지 않도록 하고, 모든 용량을 API로 요청을 전달하는 데 사용할 것입니다. 다른 모든 노드에 대해서는 상위 계층 노드로부터 쿼리를 받은 경우, 첫 번째 단계는 이전 쿼리에 대해 계산을 수행하고 있는지 확인하는 것입니다. 비어 있는 경우 쿼리를 해결하고, 그렇지 않은 경우에는 라운드 로빈으로 하위 노드 중 하나에게 전달합니다. 라운드 로빈 방식으로, 각 쿼리는 다른 하위 노드로 리디렉션되어 전체 하위 목록을 순환 버퍼처럼 통과합니다. 이것은 노드의 지역 부하를 균등하게 아래쪽으로 분산시킬 수 있음을 의미하며, 각 노드의 리소스를 효과적으로 활용하고 더 많은 하위 노드를 추가하여 시스템을 확장할 수 있는 능력을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내, 시스템이 현재 많은 사용자에게 서비스를 제공하고 있고, 리프 노드에 쿼리가 도착할 때 해당 노드가 바쁠 경우 해당 쿼리를 다시 보낼 후손이 없습니다. 따라서 모든 노드는 쿼리 대기 메커니즘이 있어야 하며, 이러한 상황에서 기다릴 수 있도록 대기하고, 대기 중인 쿼리 간의 일괄 작업을 적용하여 LLM 추론을 가속화할 수 있습니다. 또한 쿼리가 완료되면 시스템을 과부하시키지 않기 위해 쿼리를 트리 상단에 도달할 때까지 상위로 전달하는 대신, 직접 루트로 보내고 나서 API와 클라이언트에 도달하게 됩니다. 모든 노드를 API에 연결하거나 다른 대안을 구현할 수 있지만, 코드를 가능한 간단하게 유지하고 시스템을 최대한 성능 좋게 유지하기 위해 모든 것을 루트로 보냅니다.\n\n# 웹 클라이언트\n\n시스템 아키텍처를 정의하고 작업을 수행하는 방식을 설명한 후, 솔루션과 상호 작용할 때 사용자가 필요로 할 웹 클라이언트를 구축할 수 있습니다.\n\n예상했듯이, 웹 클라이언트는 기본 HTML, CSS 및 JavaScript로 구현되며, 모든 것이 편리하게 .html 파일 하나에 내장됩니다. 이 파일은 클라이언트가 응용 프로그램 시작 중에 대응하는 요청을 만들 때마다 API에 의해 제공되며, 즉 클라이언트가 브라우저로 들어가고 API가 진입점을 호스팅한 주소를 입력하는 경우 브라우저에 렌더될 .html 파일을 반환할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그런 다음 사용자가 시스템에 텍스트 쿼리를 보내고 싶어할 때, JavaScript가 내부적으로 해당 세부사항(데이터 유형, 엔드포인트 또는 CSRF 보안 토큰 등)을 포함한 HTTP 요청을 API로 제출합니다. 이 프로세스 내에서 AJAX를 사용함으로써, API가 요청한 값에 대한 반환 시 구동되는 원시 기능을 정의하는 것이 매우 간단해집니다. 결과를 화면에 표시하는 역할을 맡고 있습니다. 게다가, 보내진 메시지가 직접적으로 쓰인 텍스트나 반환된 텍스트가 아니라, 타임스탬프와 같은 다른 중요 파라미터를 포함하는 JSON으로 랩핑되어 있음을 언급할 가치가 있습니다. 이는 일부 시스템 구성 요소의 동기화를 관리하기 위해 필요에 따라 즉석으로 추가 필드를 추가할 수 있는 가능성을 제공합니다.\n\n# Django API\n\n웹 클라이언트가 준비되면, 필요한 서비스를 제공할 API를 구현할 수 있습니다.\n\nAPI를 구축하기 위한 여러 기술이 있지만, 이 프로젝트에서는 특히 Django를 이용하여 파이썬을 통해 전용 서버에서 사용하겠습니다. 이 결정은 이 프레임워크가 제공하는 다른 파이썬 종속성과의 높은 확장성 및 통합 용이성에 동기를 받았습니다. 또한, 보안 또는 기본 관리 패널과 같은 유용한 속성을 추가로 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_5.png)\n\n웹 클라이언트를 구성할 엔드포인트 중 하나는 기본 URL인 '/'로 표시되는 것입니다. 따라서 사용자가 위에 표시된 것과 같은 기본 HTTP 요청을 통해 서버에 액세스하면 API는 인터페이스를 표시하고 LLM 서비스로 요청을 시작하는 데 필요한 HTML 코드를 반환할 것입니다.\n\n![이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_6.png)\n\n동시에 사용자가 인터페이스에 액세스한 후 클라이언트의 요청을 지원해야 할 것입니다. 이러한 요청은 특별한 방법으로 관리되어야 하므로 쿼리 데이터가 해당 JSON 형식으로 전송될 'arranca'라는 자체 엔드포인트가 있을 것이며, API는 노드 트리를 사용하여 처리한 후 해결된 쿼리를 반환할 것입니다. 이 엔드포인트에서 서버는 계층 구조의 루트 노드와 사전에 설정된 소켓 채널을 사용하여 쿼리를 전달하고, 동기화 메커니즘을 통해 해당 응답을 기다릴 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드와 관련하여 urls.py 파일에서는 URL과 엔드포인트 간의 관계를 저장하여, 기본 빈 URL이 템플릿 폴더에서 .html을 읽어서 다시 보내거나, /arranca URL이 쿼리를 해결하는 기능을 실행하도록 해당 기능에 할당됩니다. 또한, views 함수가 실행되어 주 서버 스레드를 시작합니다. 한편 settings.py에서 변경해야 할 것은 DEBUG 매개변수를 False로 변경하고 서버에 연결할 수 있는 호스트의 필요한 권한을 입력하는 것뿐입니다.\n\n마지막으로, views.py 스크립트가 있는데, 거기에는 모든 API 기능이 구현되어 있습니다. 먼저, 수신 및 처리 기능을 담당하는 주 스레드가 있습니다(루트 노드로부터 수신된 연결 처리). 이 연결은 초기에 시스템 전체 수명 동안 계속 유지됩니다. 그러나 중단되어 다시 설정해야 하는 경우를 대비하여 무한 루프 내에 배치되어 있습니다. 둘째로, index() 함수로 기본 엔드포인트가 구현되어 있으며, 이 함수는 GET 요청을 수행하는 경우 .html 콘텐츠를 클라이언트로 반환합니다. 추가적으로, 응용 프로그램에서 사용자가 제출하는 쿼리는 /arranca 엔드포인트를 통해 API로 전송되며, 동일한 이름의 함수로 구현됩니다. 거기서 입력 쿼리가 루트 노드로 전달되어 응답을 받을 때까지 차단되고 클라이언트로 반환됩니다.\n\n이러한 차단은 각 쿼리가 고유 식별자를 갖도록하고, arranca() 함수에 의해 JSON 메시지의 필드로 삽입되는 request_id라는 이름의 필드에서 수행되는 동기화 메커니즘을 통해 달성됩니다. 본질적으로 쿼리 도착 순서와 일치하는 자연수인 request_id가 됩니다. 따라서 루트 노드가 API로 해결된 쿼리를 보낼 때, 어떤 차단된 실행이 쿼리를 생성했는지 알 수 있어, 나머지를 차단 해제하고 반환하며 다시 차단할 수 있습니다.\n\n# Java Compute Nodes\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI가 작동 중이므로 Java에서 노드 시스템을 구현하기로 결정했습니다. 이 언어를 선택한 주요 이유는 노드 간 통신을 가능하게 하는 기술에 의해 동기부여 받았기 때문입니다. 이 수준에서 가장 간단한 통신 의미론을 얻기 위해 소켓과 수동 직렬화된 메시지를 사용하지 않고, 다른 플랫폼에서는 Python의 Pyro4와 같은 해결책들이 제공되지만 그것들보다 다소 복잡할 수도 있는 RMI로 대체할 것입니다.\n\n원격 메서드 호출(RMI)은 분산 시스템을 생성할 수 있도록 하는 통신 패러다임으로, 별도의 기계에 호스팅된 원격 객체로 구성된 분산 시스템을 가능하게 합니다. 서로 원격 참조를 얻고 서비스 인터페이스 내에서 원격 메서드를 호출할 수 있습니다. 따라서 Java의 높은 추상화 정도로 인해, 노드 간 쿼리 전송은 송신 노드가 참조하는 객체로의 원격 호출을 이용하여 구현될 것이며, 이전에 Python에서 수동으로 처리한 API 연결 프로세스가 자동으로 처리될 것입니다.\n\n우선, 각 노드에 대해 원격 호출 가능한 메서드를 결정하는 원격 인터페이스를 정의해야 합니다. 데버깅 목적으로 관련 정보를 반환하는 메서드(log() 또는 getIP())와 다른 노드의 원격 참조를 얻고 상위 노드로 또는 하위 노드로 등록하는 책임이 있는 메서드가 있습니다. 이 노드에 대해 고유한 이름이라고 가정할 수 있는 이름을 사용합니다. 또한, 다른 노드로부터 들어오는 쿼리를 수신하기 위한 두 가지 다른 원시형(primitives)이 있으며(API에서 해결된 쿼리를 보내기 위한 sendMessagePython() 및 루트 노드에서만 실행되는 함수)이 있습니다.\n\n인터페이스로부터 노드 클래스 내에 해당 작업을 구현할 수 있으며, 시스템을 시작시킬 때마다 이 클래스를 인스턴스화하고 노드 트리에 새 기계를 추가하기로 결정할 수 있습니다. 노드 클래스에 포함된 주요 기능 중 하나는 다른 노드의 원격 참조를 얻는 getRemoteNode() 메서드이며, 이를 위해 이름 레지스트리에 액세스하고 lookup() 원시를 실행하여 등록된 경우 인터페이스 형식으로 원격 참조를 반환하거나 그렇지 않은 경우 null을 반환합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원격 참조를 가져오는 것은 트리를 구성하는 데 필수적입니다. 특히 부모 노드를 자손에 연결하거나 해결된 쿼리를 보내기 위해 루트에 대한 참조를 얻는 다른 메서드들에게 필요합니다. 그 중 하나는 connectParent()입니다. 자손 노드가 부모 노드와 연결해야 할 때 호출됩니다. 먼저 getRemoteNode()를 사용하여 부모 노드를 검색하고, 참조를 얻은 후에는 각 노드 인스턴스에 대한 로컬 변수에 할당합니다. 그런 다음 connectChild()를 호출하여 호출된 원격 노드를 자손 목록에 추가합니다. 부모 노드가 존재하지 않는 경우에는 null 객체에 대한 함수를 호출하려고 시도하면 예외가 발생합니다.\n\n다음으로, API로부터 쿼리를 수신하는 방법인 receiveMessagePython() 및 다른 노드로부터 receiveMessage() 메서드는 시스템의 올바른 작동에 방해가 될 수 있는 경쟁 조건을 피하기 위해 synchronized 절로 보호됩니다. 이러한 메서드들은 또한 쿼리 분배 휴리스틱을 구현하는데 책임이 있습니다. 이것은 수신된 쿼리를 보낼 대응 노드를 결정하기 위해 로컬 변수를 사용합니다.\n\n마지막으로, 노드 클래스에는 consultLLM() 메서드 내에서 쿼리 해결을 관리하기 위해 사용되는 스레드 풀이 있습니다. 이렇게 하면 해당 호출이 Java 코드 내에서 즉시 종료되어 필요한 계산을 실행할 스레드를 할당하고 프로그램에 제어를 반환하여 추가 쿼리를 받을 수 있게 됩니다. 이는 또한 노드가 어떤 계산을 수행 중인지 여부를 감지하는 데 유용합니다. 또한, 노드 클래스 내부의 다른 스레드 사용은 프로그램을 유지하는 역할인 connectServer() 메서드에서 루트 노드를 API와 쿼리 교환하기 위해 연결하는 역할을 합니다.\n\nUtilities 클래스에서는 노드 이름을 기반으로 원격 노드에 대한 참조를 등록하고 조회하는 LDAP 사용 컨텍스트를 생성하는 메서드만 있습니다. 이 메서드는 노드 클래스에 직접 배치할 수 있지만 이와 유사한 메서드가 더 필요한 경우를 대비하여 Utilities 클래스에 남겨서 디자인 패턴의 이점을 살리도록 하였습니다.\n\n노드 인스턴스의 생성 및 관리는 각각 수동으로 수행되며, 이는 Launcher 클래스에서 구현됩니다. 지정된 LDAP 서버에 등록된 특정 이름이 있는 노드가 시작될 때 명령 줄 인터페이스를 사용하여 해당 노드를 지시합니다. 일부 명령에는 다음이 포함됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 로그: 노드 상태를 알기 위해서 유용한 정보를 출력합니다.\n- 부모: 노드를 이름으로 지정된 부모에 연결합니다.\n- 레지스트리: LDAP 디렉토리에 조직 단위 ou=Nodes 아래에 현재 등록된 모든 노드를 나열합니다. 레지스트리 서버를 모니터링하거나 새로운 노드를 만드는 데 유용할 수 있습니다.\n- 서버: 노드를 주소와 포트 번호로 지정된 서버에 연결합니다. 주로 서버는 Python API가 되겠지만, 다른 기능을 제공할 수도 있습니다.\n\n# LDAP 서버\n\n노드는 원격 객체이므로 이름에서 다른 노드로의 원격 참조를 얻을 수 있도록 허용하는 레지스트리에 액세스해야 합니다. Java에서는 머신에 레지스트리 서비스를 초기화하는 rmiregistry를 사용하는 솔루션이 제공됩니다. 그러나 다른 호스트에서 rebind()와 같은 보안 보호 작업을 실행할 때, 새로운 노드가 레지스트리를 포함한 다른 기계에 등록되지 않도록 보안 예외가 발생합니다. 이러한 이유로, 이 프로젝트는 단순함에 더해 Java 레지스트리가 제공하는 것보다 LDAP (Lightweight Directory Access Protocol)를 사용하여 Apache 서버를 레지스트리로 사용할 것입니다. 이 프로토콜은 디렉토리 시스템에 Name-Remote_Node 쌍의 저장을 관리할 수 있게 해 주며 다른 추가 기능을 통해 레지스트리 서비스를 크게 개선할 수 있습니다.\n\nLDAP를 사용하는 장점은 먼저 운영 복잡성에서부터 시작됩니다. 처음 보았을 때는 정반대로 보일 수 있겠지만, 실제로는 시스템을 다양한 보안 및 구성 요구 사항에 맞게 더 높은 수준의 세부 정보로 조정할 수 있는 것이 가능하게 만들어줍니다. 한편으로, 제공하는 인증 및 보안 기능은 호스트가 LDAP 서버에 의해 식별될 때 새로운 노드를 등록하는 등 보호된 작업을 수행할 수 있도록 합니다. 예를 들어 서버에 액세스하고 작업을 수행할 수 있는 컨텍스트 객체를 만들 때, 생성자의 HashMap에 인증 데이터를 추가할 수 있는 옵션이 있습니다. 컨텍스트를 만들었다면, 데이터가 서버가 기대하는 것과 일치함을 의미하며, 그렇지 않다면 연결이 인증되지 않은(“악의적인”) 호스트에 의해 이루어지고 있다고 가정할 수 있습니다. 이를 통해 시스템 노드만 서버 정보를 조작할 수 있도록 보장합니다. 다른 한편으로 LDAP는 노드 등록을 훨씬 더 효율적으로 중앙 집중식으로 처리하고 더 고급 상호 운용성을 제공하며 케르베로스와 같은 추가 서비스를 쉽게 통합할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서버가 노드 레지스트리로 작동할 수 있도록하려면 특정 구성을 적용해야 합니다. 먼저, 프로젝트가 실제 (그리고 잠재적으로 악의적인) 사용자가 있는 환경에 배포되지 않을 것이기 때문에 모든 인증 옵션은 생략되어 간단하고 깔끔하게 유지됩니다. 다음으로, Distinguished Name을 정의하여 노드 이름을 해당 원격 객체와 연결할 수 있도록해야 합니다. 이 경우, 동일한 이름을 가진 여러 노드의 등록을 방지한다고 가정할 때, 우리는 노드 이름을 cn=(Common Name)과 같은 속성에 저장하기만 하면 됩니다. 이때 지정된 조직 단위 내에서 ou=Nodes와 같은 형식의 식별 이름이 됩니다: cn=Node_Name,ou=Nodes\n\n![이미지](\" /assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_7.png\")\n\n새로운 노드가 생성될 때마다, 노드는 서버에 등록되며 그 distinguished name과 노드 인스턴스가 새로운 디렉토리 항목 형식으로 사용됩니다. 마찬가지로, 노드를 삭제하거나 레지스트리에서 해당 원격 참조 값을 가져오려면 distinguished name을 사용해야 합니다. 이 레지스트리에 대한 이러한 작업을 수행하려면 LDAP 서버에 연결을 열어두어야 합니다. 그러나 노드가 Java로 작성되었기 때문에 연결 프로세스 전체를 추상화하고 작업 호출에만 집중할 수 있는 서비스를 사용할 수 있습니다. 노드에서 사용할 서비스는 DirContext 인터페이스에 의해 일반적으로 정의됩니다. 따라서 서버에 액세스하고 일부 관리를 수행하는 프로세스는 InitialDirContext와 같은 인터페이스를 구현하는 객체를 생성하는 것만으로 충분하며, 이를 위해 서버를 식별하는 데 필요한 적절한 매개변수를 할당해야 합니다. 이때 ldap://IP:port/ 형식의 URL, 사용할 프로토콜을 식별하는 것을 포함하는데 심지어 이 프로젝트에서 사용하지 않을 인증 매개변수도 있습니다.\n\n## 조회, 바인드 및 언바인드\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n간단하게 말씀드리자면 런처는 개별 컨텍스트 개체를 갖고, 각 노드도 개별 컨텍스트를 갖게 됩니다. 이렇게 하면 런처가 항목을 생성하고 삭제할 수 있고, 각 노드는 노드 이름으로부터 원격 참조를 얻기 위한 조회 작업을 수행할 수 있습니다. 삭제 작업은 가장 간단합니다. 해당 노드에 해당하는 서버 항목의 식별 이름만 필요합니다. 항목이 존재한다면 삭제되고 unbind() 호출이 성공적으로 종료됩니다. 그렇지 않으면 예외가 발생합니다. 한편, 조회 및 등록 작업은 RFC-2713을 준수해야 합니다. 서버에 노드를 추가하는 경우, bind() 원시 함수를 사용합니다. 이 함수는 노드가 호스팅될 항목의 식별 이름과 해당 원격 개체를 전달받습니다. 그러나 bind 함수는 노드 개체 자체나 인터페이스를 바로 받지 않습니다. 왜냐하면 해당 객체가 직렬화될 수 없으며 bind()가 인터페이스 \"인스턴스\"를 직접 얻을 수 없기 때문입니다. 이 문제를 우회하기 위해 상기 RFC는 해당 노드 인스턴스가 MarshalledObject에 의해 마스킹되어야 한다고 합니다. 결과적으로 bind는 서버 내에서 등록할 노드로 구성된 MarshalledObject를 받아서 원래 노드 인스턴스가 아닌 노드가 수행됩니다.\n\n마지막으로, 조회 작업은 컨텍스트를 통해 lookup() 원시 함수를 사용하여 수행됩니다. 이전에 이름과 노드가 등록되지 않았거나 프로세스 중에 예기치 않은 오류가 발생하는 경우 예외가 발생합니다. 반대로 작업이 성공하면 조회된 쿼리의 식별 이름과 관련된 MarshalledObject가 반환됩니다. 그러나 lookup()에서 반환된 원격 참조는 레지스트리에 저장된 MarshalledObject 래퍼에 포함되어 있습니다. 따라서 MarshalledObject의 get() 작업을 사용하여 사용 가능한 원격 참조를 얻어야 합니다. 또한 이 기능을 사용하여 bind()를 실행하기 전에 동일한 이름을 갖는 다른 노드의 등록을 방지할 수 있으므로, lookup()을 사용하여 해당 식별 이름이 있는지 확인할 수 있습니다.\n\n# LLM 추론\n\n각 노드의 추론 프로세스에 관한 추론 프로세스에 대한 내용에 대해, 노드 트리에는 LLMProcess 클래스가 있으며 이는 Python에서 구현된 프로세스를 인스턴스화하는 역할을 맡습니다. 쿼리가 해결되기 전에 Python에서 LLM 및 그 추론 파이프라인을 쉽게 관리할 수 있기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 LLMProcess가 생성될 때, Java와 Python 프로세스 간 통신을 위해 머신에서 사용 가능한 포트를 찾아야 합니다. 간편하게 데이터 교환은 소켓을 사용하여 수행되며, ServerSocket을 열고 닫아 사용 가능한 포트를 찾은 후에는 llm.py 프로세스가 포트 번호를 매개변수로 전달받아 실행됩니다. 이 프로세스의 주요 기능은 destroyProcess()로 시스템이 중지될 때 프로세스를 종료하고 sendQuery()로 llm.py에 쿼리를 전송하고 각 쿼리마다 새 연결을 사용하여 응답을 대기하는 것입니다.\n\nllm.py 내부에는 Java 프로세스로부터 수신 대기하는 무한 루프가 있습니다. 이러한 연결이 확립되면 ThreadPoolExecutor() 스레드를 통해 handle_connection() 함수에 의해 처리되며, 채널로부터 입력 데이터를 읽고 JSON 형식으로 해석하여 \"text\" 필드를 추론 파이프라인으로 전달합니다. 데이터가 반환되면 Java 프로세스로 다시 전송되며, 함수가 반환되고 해당 스레드도 해제됩니다.\n\n## 모델 성능\n\n스크립트에서 확인할 수 있듯이, 파이프라인 인스턴스를 통해 호스팅된 노드에서 실행될 LLM 모델을 선택할 수 있습니다. 이를 통해 Huggingface 웹사이트에 업로드된 모든 모델에 액세스할 수 있으며, 코드 생성 모델, 채팅, 일반 응답 생성 등과 같이 매우 다양한 옵션을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 우리는 약 117백만 개의 매개변수와 약 500MB의 무게를 가진 gpt2 모델을 사용합니다. 이 모델은 가장 가벼우면서 통합하기 가장 쉬운 옵션이죠. 이 모델은 매우 작기 때문에 답변이 상당히 기본적입니다. 입력된 텍스트에 가장 가까운 예측과 매칭되는 쿼리 해결이라고 할 때 아래 텍스트의 예측이 곧 입력된 것과 일치하는 것을 주목해주세요. 예를 들어:\n\ngpt2-large 또는 gpt2-xl과 같은 다른 버전의 gpt2도 있습니다. 모든 것이 Huggingface에서 제공되며 가장 강력한 XL 형식은 15억 개의 매개변수와 6GB의 무게를 가지고 있습니다. 이를 실행하려면 상당히 더 많은 강력한 하드웨어가 필요하며, 일관된 응답을 생성합니다.\n\nOpenAI GPT 시리즈 외에도 다양한 다른 사용 가능한 모델을 선택할 수 있습니다. 그러나 대부분의 경우 스크립트에 삽입할 인증 토큰이 필요합니다. 최근에는 공간 점유 및 쿼리를 전체 추론 파이프라인을 통해 실행하는 데 필요한 시간을 최적화한 현대화된 모델들이 출시되었습니다. Llama3도 이 중 하나로, 8B 매개변수의 작은 버전과 70B의 대형 버전을 제공합니다.\n\n그러나 시스템에 모델을 선택할 때는 매개변수의 개수만을 기준으로 삼으면 안 됩니다. 모델의 아키텍처가 모델이 적용할 수 있는 지식의 양을 결정하기 때문이죠. 따라서 작은 모델은 대형 모델과 매우 유사한 성능을 발휘할 수 있습니다. 즉, 매우 유사한 언어 이해 능력을 갖춘 답변을 생성하는 동시에 이를 생성하는 데 필요한 컴퓨팅 자원을 최적화할 수 있죠. Huggingface 자체에서 제공되는 벤치마크 또는 LLM의 위에서 언급한 매개변수를 측정하는 전문 테스트를 사용할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 테스트 결과와 특정 하드웨어에서 응답하는 데 걸리는 평균 시간은 모델을 선택하는 데 꽤 완벽한 지표입니다. 그러나 항상 기억해야 할 점은 LLM은 실행 중인 칩 메모리에 맞아야 합니다. 따라서 우리가 llm.py 스크립트에서 CUDA를 사용한 GPU 추론을 사용하는 경우, 그래픽 메모리는 모델 크기보다 커야 합니다. 그렇지 않으면 계산을 여러 대의 GPU 또는 하나 이상의 기기에서 복잡성을 달성하고자 하는 데 따라 동등하게 분산해야 합니다.\n\n## Kotlin Mobile Client\n\n마무리하기 전에 새로운 유형의 클라이언트가 시스템에 포함될 수 있는 방법을 살펴볼 수 있습니다. 이로써 지금까지 구축한 모든 것이 제공하는 확장성을 증명할 수 있습니다. 물론 이 프로젝트는 분산 시스템을 시도한 것이므로, 일반적인 ChatGPT 앱이 Android 및 iOS와 호환되는 것과 마찬가지로 모바일 기기와도 호환될 것으로 예상됩니다. 우리의 경우에는 네이티브 Android용 앱을 개발할 수 있지만, 훨씬 더 나은 옵션은 시스템을 다중 플랫폼 jetpack compose 프로젝트로 적응하는 것일 것입니다. 이 옵션은 장래의 업데이트 가능성으로 남아 있습니다.\n\n초기 아이디어는 모바일 클라이언트를 API에 연결하고 웹과 같은 요청을 하며 HttpURLConnection과 같은 종속성을 사용하는 것입니다. 코드 구현은 어렵지 않으며 공식 페이지에서 제공하는 안드로이드 문서도 이러한 목적에 유용합니다. 그러나 일반 TCP 안드로이드 소켓을 사용하여 사용자 정의 코틀린 중간 구성 요소로 API의 기능을 에뮬레이트할 수도 있습니다. 소켓은 상대적으로 사용하기 쉽고, 모든 것이 올바르게 작동하도록 노력을 기울이며 코드에 대한 꽤 많은 제어 수준을 제공합니다. 규제 API의 부재를 해결하기 위해 이동 클라이언트와 자바 노드 트리 사이에 코틀린 노드를 배치하여 근원 노드와 웹 클라이언트 및 API가 분리되는 한 이동 클라이언트와만 연결을 관리할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인터페이스 측면에서, 저희가 모방하는 애플리케이션인 ChatGPT는 매우 깔끔하고 현대적인 느낌을 가지고 있습니다. HTTP 버전은 이미 완성되었으므로 안드로이드 스튜디오 편집기에서 가능한 한 가깝게 복사해 보겠습니다.\n\n![ChatGPT 이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_8.png)\n\n소켓을 사용할 때, 사용자가 문제를 해결할 서버의 올바른 IP 주소와 포트에 연결되어 있는지 확인해야 합니다. 애플리케이션을 열 때마다 새로운 초기 인터페이스가 나타나도록하여 이를 달성할 수 있습니다. 간단한 버튼, IP 주소를 입력할 수 있는 텍스트 뷰, 사용자에게 발생한 일들을 실시간으로 알려주는 작은 텍스트 레이블이 있는 뷰로 구성될 것입니다. 위 이미지에서 확인할 수 있습니다.\n\n그런 다음, 새로운 메시지가 하단에 나타나고 이전 메시지가 위로 이동하는 실제 채팅과 비슷한 인터페이스를 가져야 합니다. 이를 위해 화면의 약 80%를 차지할 RecyclerView를 삽입할 수 있습니다. 사전 정의된 메시지 뷰를 동적으로 추가해 실제로 메시지가 사용자인지 시스템인지에 따라 변경될 수 있도록 계획하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내, Android 연결의 문제는 주 스레드에서 네트워크 관련 작업을 수행할 수 없다는 것이며, 그렇게 하면 NetworkOnMainThreadException이 발생할 수 있다는 것입니다. 동시에, 주 스레드가 아닌 곳에서 구성 요소를 관리할 수 없다면, CalledFromWrongThreadException이 발생할 것입니다. 이 문제를 해결하는 방법은 연결 뷰를 주 스레드로 이동시키고, 주 목적은 코루틴을 잘 활용하여 네트워크 관련 작업을 수행할 수 있도록 하는 것입니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_9.png\" /\u003e\n\n이제 시스템을 실행하고 텍스트 쿼리를 입력하면, 몇 초 후에 답변이 나타날 것입니다. 이는 ChatGPT와 같은 대규모 애플리케이션에서와 같이 작동합니다.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기능적인 시스템을 갖고 있더라도, 구현된 기술에 따라 중요한 개선이 가능합니다. 소프트웨어와 하드웨어 모두 그렇죠. 그러나 가용 자원에 따라 크게 변동될 수 있는 소수의 사용자에게 꽤 괜찮은 서비스를 제공할 수 있습니다. 마지막으로, ChatGPT와 같은 실제 시스템의 성능을 달성하는 것은 복잡합니다. 모델 크기와 그를 지원하는 하드웨어가 비실렉한 특히 비용이 많이 듭니다. 이 글에서 보여준 시스템은 소규모 또는 중간 해결책에 매우 적합하게 확장 가능하지만 대규모 해결책을 달성하기 위해서는 훨씬 더 복잡한 기술이 필요할 뿐만 아니라 이 시스템의 구조 중 일부를 활용하는 것이 필요할 수도 있습니다.\n\n# 감사의 글\n\nKotlin 모바일 클라이언트 섹션에서의 협업에 감사드립니다. deivih84님, RMI 및 분산 시스템 구현에 참여해 주신 carolinaherasc님 그리고 시스템 관리 구성 요소 개발에 참여해 주신 hugodiezrubio님께 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_0.png"},"coverImage":"/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_0.png","tag":["Tech"],"readingTime":25},{"title":"UUID 대 ULID 어떤 것을 사용해야 할까요","description":"","date":"2024-06-19 10:00","slug":"2024-06-19-UUIDvsULID","content":"\n먼저 UUID와 ULID는 무엇인가요?\n\nUUID (Universally Unique Identifier):\n\n- UUID는 컴퓨터 시스템에서 정보를 고유하게 식별하는 데 사용되는 128비트 숫자입니다.\n- 이들은 RFC 4122 표준에서 정의되어 있으며 여러 가지 버전의 UUID를 설명합니다.\n- UUID는 소프트웨어 개발, 데이터베이스 및 고유 식별자가 필요한 다른 응용 프로그램에서 널리 사용됩니다.\n- UUID의 주요 장점은 고유성, 분산 생성 및 플랫폼 독립성입니다.\n- 그러나 UUID는 본질적으로 날짜 순서로 정렬할 수 없기 때문에 특정 사용 사례에서는 단점일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nULID (Universally Unique Lexicographically Sortable Identifier):\n\n- ULID는 렉시코그래픽적으로 정렬 가능한 128비트 식별자입니다.\n- 이 식별자는 UUID의 대안으로 2016년에 도입되었으며 정렬 가능한 고유 식별자를 제공하는 것을 목표로 합니다.\n- ULID는 타임스탬프(48비트)와 랜덤 부분(80비트)으로 구성되어 고유성과 시간순 정렬을 모두 가능하게 합니다.\n- ULID의 타임스탬프 부분은 유닉스 에포크 이후의 밀리초 수를 기반으로 하므로 시간에 따라 정렬 가능합니다.\n- ULID는 UUID와 크기 및 구조적으로 호환되지만 정렬 가능한 추가 혜택을 제공합니다.\n- 시간 순서가 중요한 경우에 유의미할 수 있는데, 예를 들어 시계열 데이터 또는 이벤트 로깅 시나리오에서 활용될 수 있습니다.\n\nUUIDs (자바에서의 Guid)는 데이터베이스에서 고유 식별자로 널리 사용됩니다. UUID는 무작위적이어서 분산 시스템에서 인기가 있습니다.\n\n하지만 UUID에는 몇 가지 단점이 있습니다:\n\n1. UUID는 데이터베이스 삽입 속도를 늦춥니다. 각 삽입은 클러스터화된 인덱스 인 B+ 트리를 업데이트해야 합니다. UUID가 무작위인 점 때문에 이 작업은 트리를 균형잡기 위한 비용이 많이 드는 작업입니다.\n\n2. 더 높은 저장 비용. UUID는 128비트이며 이를 문자열 형식으로 인간이 읽을 수 있는 형태로 저장하는 경우 더 길어집니다.\n\n그래서, ULID에 대해 소개하겠습니다.\n\nULID는 UUID의 단점을 해결하려고 합니다. 또한 128비트이므로 UUID와 호환됩니다. 그러나 UUID와 달리, ULID는 정렬 가능합니다. ULID의 처음 40비트는 타임스탬프를 나타내어 ULID가 단조로운 증가를 보입니다.\n\n어떤 식별자를 선택할지 결정할 때는 애플리케이션의 특정 요구 사항에 따라 UUID와 ULID 중에서 선택하게 됩니다. UUID는 더 널리 채택되고 더 많은 지원을 받지만, ULID는 시간순서대로 정렬할 수 있는 이점을 제공합니다. 여러분의 기사에서는 두 식별자 간의 트레이드오프, 특히 한 쪽이 다른 쪽보다 선호되는 사용 사례를 탐구할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# UUID 및 ULID의 Java 예제:\n\nUUID 예제:\n\n```java\nimport java.util.UUID;\n\npublic class UUIDExample {\n    public static void main(String[] args) {\n        // 새 UUID 생성\n        UUID uuid = UUID.randomUUID();\n        System.out.println(\"UUID: \" + uuid.toString());\n\n        // 문자열에서 UUID 파싱\n        String uuidString = \"123e4567-e89b-12d3-a456-426655440000\";\n        UUID parsedUuid = UUID.fromString(uuidString);\n        System.out.println(\"파싱된 UUID: \" + parsedUuid);\n\n        // 두 UUID 비교\n        if (uuid.equals(parsedUuid)) {\n            System.out.println(\"두 UUID가 동일합니다.\");\n        } else {\n            System.out.println(\"두 UUID가 동일하지 않습니다.\");\n        }\n    }\n}\n```\n\nULID 예제:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.github.brianrubin.ulid.ULID;\n\npublic class ULIDExample {\n    public static void main(String[] args) {\n        // 새 ULID 생성\n        ULID ulid = ULID.randomULID();\n        System.out.println(\"ULID: \" + ulid.toString());\n\n        // 문자열에서 ULID 파싱\n        String ulidString = \"01GKKH6DAT6DS3B7MVTX3ABD2F\";\n        ULID parsedUlid = ULID.fromString(ulidString);\n        System.out.println(\"파싱된 ULID: \" + parsedUlid);\n\n        // 두 ULID 비교\n        if (ulid.equals(parsedUlid)) {\n            System.out.println(\"ULID가 동일합니다.\");\n        } else {\n            System.out.println(\"ULID가 다릅니다.\");\n        }\n\n        // ULID를 JSON 객체로 변환\n        ObjectMapper mapper = new ObjectMapper();\n        ObjectNode jsonNode = mapper.createObjectNode();\n        jsonNode.put(\"id\", ulid.toString());\n        System.out.println(\"ULID를 JSON으로: \" + jsonNode.toString());\n    }\n}\n```\n\nUUID 예제에서는 새 UUID 생성, 문자열에서 UUID 파싱, 두 UUID 비교하는 방법을 보여줍니다.\n\nULID 예제에서는 com.github.brianrubin.ulid.ULID 라이브러리를 사용하여 ULID를 다루는 방법을 보여줍니다. 새 ULID 생성, 문자열에서 ULID 파싱, 두 ULID 비교, ULID를 JSON 객체로 변환하는 방법을 보여줍니다.\n\n두 방식의 주요 차이점은 ULID가 식별 정보를 사전순으로 정렬할 수 있도록 설계되었으며 UUID와는 다르게 타임스탬프 구성 요소를 포함한다는 점입니다. 특정 응용 프로그램에서 유용할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-UUIDvsULID_0.png"},"coverImage":"/assets/img/2024-06-19-UUIDvsULID_0.png","tag":["Tech"],"readingTime":5},{"title":"Java Spring Boot 코드 리팩터링 더 깔끔하고 확장 가능한 로직을 위해 If-Else 문 제거하기","description":"","date":"2024-06-19 09:59","slug":"2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic","content":"\nif-else 문은 널리 사용되지만 과용하면 복잡하고 유지보수가 어려운 코드를 작성하게 될 수 있습니다. 이 기사에서는 Java Spring Boot 프로젝트에서 if-else 구조의 사용을 줄이는 다양한 전략을 탐색하며 코드를 모듈화하고 유지보수 가능하며 가독성 있게 만드는 데 초점을 맞춥니다.\n\n![image](/assets/img/2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic_0.png)\n\n## if-else 문 줄이는 전략\n\n- 전략 패턴\n- Enum 사용\n- 다형성\n- 람다 표현식 및 함수형 인터페이스\n- 명령 패턴\n- 가드 절(recipes)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 전략에 대해 예제와 함께 자세히 파헤쳐 봅시다.\n\n### 1. 전략 패턴\n\n전략 패턴은 알고리즘의 집합을 정의하고, 각각을 캡슐화하며, 서로 교환할 수 있게 만드는 패턴입니다. 이 패턴은 특정 작업을 수행하는 여러 방법이 있는 경우 유용합니다.\n\n### 예제: 결제 처리 시스템\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저 PaymentStrategy 인터페이스를 정의합니다:\n\n```java\npublic interface PaymentStrategy {\n    void pay(double amount);\n}\n```\n\n다음으로 다양한 결제 전략을 구현합니다:\n\n```java\n@Component\npublic class CreditCardPayment implements PaymentStrategy {\n    @Override\n    public void pay(double amount) {\n        // 신용카드 결제 처리 로직\n        System.out.println(\"신용카드를 사용하여 \" + amount + \" 결제되었습니다.\");\n    }\n}\n\n@Component\npublic class PaypalPayment implements PaymentStrategy {\n    @Override\n    public void pay(double amount) {\n        // PayPal 결제 처리 로직\n        System.out.println(\"PayPal을 사용하여 \" + amount + \" 결제되었습니다.\");\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n| 구분 | 설명    |\n| ---- | ------- |\n| 1    | 첫 번째 |\n| 2    | 두 번째 |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 주문 상태 관리\n\n다양한 동작을 가진 OrderStatus enum을 정의합니다:\n\n```js\npublic enum OrderStatus {\n    NEW {\n        @Override\n        public void handle() {\n            System.out.println(\"신규 주문 처리 중.\");\n        }\n    },\n    SHIPPED {\n        @Override\n        public void handle() {\n            System.out.println(\"주문 발송됨.\");\n        }\n    },\n    DELIVERED {\n        @Override\n        public void handle() {\n            System.out.println(\"주문 배송 완료됨.\");\n        }\n    };\n\n    public abstract void handle();\n}\n```\n\n이 enum을 서비스에서 사용하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n@Service\npublic class OrderService {\n    public void processOrder(OrderStatus status) {\n        status.handle();\n    }\n}\n```\n\n## 3. Polymorphism\n\n다형성은 객체를 실제 클래스가 아닌 부모 클래스의 인스턴스로 취급할 수 있게 합니다. 이를 통해 부모 클래스의 참조를 통해 파생 클래스의 재정의된 메소드를 호출할 수 있습니다.\n\n## Example: Notification System\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\n// `Notification` 인터페이스와 그 구현 클래스 정의:\n\npublic interface Notification {\n    void send(String message);\n}\n\npublic class EmailNotification implements Notification {\n    @Override\n    public void send(String message) {\n        // 이메일 전송 로직\n        System.out.println(\"이메일 전송 중: \" + message);\n    }\n}\n\npublic class SmsNotification implements Notification {\n    @Override\n    public void send(String message) {\n        // SMS 전송 로직\n        System.out.println(\"SMS 전송 중: \" + message);\n    }\n}\n\n// 다형성을 사용하는 서비스 생성:\n\n@Service\npublic class NotificationService {\n    private final List\u003cNotification\u003e notifications;\n\n    public NotificationService(List\u003cNotification\u003e notifications) {\n        this.notifications = notifications;\n    }\n\n    public void notifyAll(String message) {\n        for (Notification notification : notifications) {\n            notification.send(message);\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4. 람다 표현식과 함수형 인터페이스\n\n람다 표현식은 코드를 간단하게 만들어 줄 수 있어, 특히 작고 단일 메서드 인터페이스를 다룰 때 유용합니다.\n\n## 예시: 할인 서비스\n\n람다 표현식을 사용하는 할인 서비스를 정의하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class DiscountService {\n    private Map\u003cString, Function\u003cDouble, Double\u003e\u003e discountStrategies = new HashMap\u003c\u003e();\n\n    public DiscountService() {\n        discountStrategies.put(\"SUMMER_SALE\", price -\u003e price * 0.9);\n        discountStrategies.put(\"WINTER_SALE\", price -\u003e price * 0.8);\n    }\n\n    public double applyDiscount(String discountCode, double price) {\n        return discountStrategies.getOrDefault(discountCode, Function.identity()).apply(price);\n    }\n}\n```\n\n## 5. Command Pattern\n\nThe Command Pattern encapsulates a request as an object, thereby allowing you to parameterize clients with queues, requests, and operations.\n\n## Example: File Operations\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Command 인터페이스와 구체적인 명령어를 정의한 코드입니다:\n\n```js\npublic interface Command {\n    void execute();\n}\n\npublic class OpenFileCommand implements Command {\n    private FileSystemReceiver fileSystem;\n\n    public OpenFileCommand(FileSystemReceiver fs) {\n        this.fileSystem = fs;\n    }\n\n    @Override\n    public void execute() {\n        this.fileSystem.openFile();\n    }\n}\n\npublic class CloseFileCommand implements Command {\n    private FileSystemReceiver fileSystem;\n\n    public CloseFileCommand(FileSystemReceiver fs) {\n        this.fileSystem = fs;\n    }\n\n    @Override\n    public void execute() {\n        this.fileSystem.closeFile();\n    }\n}\n```\n\n아래는 FileSystemReceiver와 Invoker를 정의한 코드입니다:\n\n```js\npublic interface FileSystemReceiver {\n    void openFile();\n    void closeFile();\n}\n\npublic class UnixFileSystemReceiver implements FileSystemReceiver {\n    @Override\n    public void openFile() {\n        System.out.println(\"Unix 운영체제에서 파일을 엽니다.\");\n    }\n\n    @Override\n    public void closeFile() {\n        System.out.println(\"Unix 운영체제에서 파일을 닫습니다.\");\n    }\n}\n\npublic class FileInvoker {\n    private Command command;\n\n    public FileInvoker(Command cmd) {\n        this.command = cmd;\n    }\n\n    public void execute() {\n        this.command.execute();\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6. 가드 구문\n\n가드 구문은 조건을 조기에 처리하여 중첩 구조를 줄여 코드를 더 읽기 쉽게 만드는 방법을 제공합니다.\n\n## 예시: 사용자 유효성 검사\n\n사용자 입력을 유효성 검사하기 위해 if-else 문을 중첩하는 대신, 가드 구문을 사용하여 잘못된 경우를 미리 처리하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```java\npublic class UserService {\n    public void registerUser(User user) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"User cannot be null\");\n        }\n        if (user.getName() == null || user.getName().isEmpty()) {\n            throw new IllegalArgumentException(\"User name cannot be empty\");\n        }\n        if (user.getEmail() == null || user.getEmail().isEmpty()) {\n            throw new IllegalArgumentException(\"User email cannot be empty\");\n        }\n        // Proceed with registration\n        System.out.println(\"Registering user: \" + user.getName());\n    }\n}\n```\n\n이 접근 방식을 통해 잘못된 조건을 조기에 처리하고 주요 로직을 보다 깔끔하고 이해하기 쉽게 유지할 수 있습니다.\n\n# 결론\n\n이러한 전략을 적용함으로써 Java Spring Boot 프로젝트에서 if-else 문의 사용을 크게 줄일 수 있습니다. 이는 코드를 더 읽기 쉽게 만들 뿐만 아니라 유지보수성과 확장성을 향상시킵니다. 이러한 패턴과 관행을 받아들여 더 깨끗하고 효율적인 코드를 작성해 보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고 자료\n\n- Gamma, E., Helm, R., Johnson, R., \u0026 Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.\n- Bloch, J. (2018). Effective Java. Addison-Wesley.\n- Fowler, M. (2019). Refactoring: Improving the Design of Existing Code. Addison-Wesley.\n- Freeman, E., \u0026 Robson, E. (2020). Head First Design Patterns: Building Extensible and Maintainable Object-Oriented Software. O’Reilly Media.\n- Beck, K. (2003). Test Driven Development: By Example. Addison-Wesley.\n\n코딩을 즐기세요! 👨‍💻👩‍💻\n","ogImage":{"url":"/assets/img/2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic_0.png"},"coverImage":"/assets/img/2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic_0.png","tag":["Tech"],"readingTime":10}],"page":"51","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"51"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>