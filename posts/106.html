<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/106" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/106" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_buildManifest.js" defer=""></script><script src="/_next/static/wOkGEDZCvEs3S_XaNsdwr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="응용 프로그램 아키텍처 데이터 레이어" href="/post/2024-05-18-AppArchitectureDatalayer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="응용 프로그램 아키텍처 데이터 레이어" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-AppArchitectureDatalayer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="응용 프로그램 아키텍처 데이터 레이어" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">응용 프로그램 아키텍처 데이터 레이어</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="제트팩 코파 서체에서 Window Insets 이해하기" href="/post/2024-05-18-UnderstandingWindowInsetsinJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="제트팩 코파 서체에서 Window Insets 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="제트팩 코파 서체에서 Window Insets 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">제트팩 코파 서체에서 Window Insets 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법" href="/post/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트" href="/post/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로" href="/post/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl"> 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">19<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드" href="/post/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS Lake Formation에서 데이터 필터를 사용하여 Terraform을 통해 여러 계정 간 액세스 활성화하기" href="/post/2024-05-18-EnablingCross-AccountAccessforAWSLakeFormationwithDataFiltersUsingTerraform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS Lake Formation에서 데이터 필터를 사용하여 Terraform을 통해 여러 계정 간 액세스 활성화하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-EnablingCross-AccountAccessforAWSLakeFormationwithDataFiltersUsingTerraform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS Lake Formation에서 데이터 필터를 사용하여 Terraform을 통해 여러 계정 간 액세스 활성화하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS Lake Formation에서 데이터 필터를 사용하여 Terraform을 통해 여러 계정 간 액세스 활성화하기</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GKE  Gemma  Ollama 유연한 LLM 배포를 위한 파워 트리오 " href="/post/2024-05-18-GKEGemmaOllamaThePowerTrioforFlexibleLLMDeployment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GKE  Gemma  Ollama 유연한 LLM 배포를 위한 파워 트리오 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-GKEGemmaOllamaThePowerTrioforFlexibleLLMDeployment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GKE  Gemma  Ollama 유연한 LLM 배포를 위한 파워 트리오 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">GKE  Gemma  Ollama 유연한 LLM 배포를 위한 파워 트리오 </strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="롱혼 - K8s를 위한 분산형 블록 스토리지" href="/post/2024-05-18-LonghornDistributedBlockStorageforK8s"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="롱혼 - K8s를 위한 분산형 블록 스토리지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-LonghornDistributedBlockStorageforK8s_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="롱혼 - K8s를 위한 분산형 블록 스토리지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">롱혼 - K8s를 위한 분산형 블록 스토리지</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ArgoCD ApplicationSet은 v29 버전에서 더 실용적입니다" href="/post/2024-05-18-ArgoCdApplicationSetismorepracticalinversionv29"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ArgoCD ApplicationSet은 v29 버전에서 더 실용적입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-18-ArgoCdApplicationSetismorepracticalinversionv29_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ArgoCD ApplicationSet은 v29 버전에서 더 실용적입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">ArgoCD ApplicationSet은 v29 버전에서 더 실용적입니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 18, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link posts_-active__YVJEi" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a><a class="link" href="/posts/114">114</a><a class="link" href="/posts/115">115</a><a class="link" href="/posts/116">116</a><a class="link" href="/posts/117">117</a><a class="link" href="/posts/118">118</a><a class="link" href="/posts/119">119</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"응용 프로그램 아키텍처 데이터 레이어","description":"","date":"2024-05-18 17:09","slug":"2024-05-18-AppArchitectureDatalayer","content":"\n![AppArchitectureDatalayer_0](/assets/img/2024-05-18-AppArchitectureDatalayer_0.png)\n\n이전 글에서는 도메인 레이어를 안정적이고 플랫폼 독립적인 레이어로 다루었습니다. 오늘은 데이터 레이어의 목적을 다루겠습니다. 함께 알아봅시다.\n\n![AppArchitectureDatalayer_1](/assets/img/2024-05-18-AppArchitectureDatalayer_1.png)\n\n데이터 레이어는 앱의 나머지 부분에 데이터를 노출하는 역할을 합니다. 다양한 데이터 소스를 관리하고 그들 사이의 충돌을 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 저장소\n\n데이터 레이어는 Repository로 이루어져 있습니다. 이전 챕터에서 언급했듯이 도메인 레이어에 대해:\n\n데이터 레이어는 도메인 레이어의 저장소를 구현한 것입니다. Repository 클래스는 앱에서 처리하는 각기 다른 유형의 데이터를 나타내어야 합니다. 예를 들어:\n\n## 네이밍 규칙\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레포지토리 클래스는 담당하는 데이터를 따라 이름이 지어집니다.\n\n데이터 유형 + DataRepository와 같은 형식을 따릅니다.\n\n예를 들어 TicketRepository 인터페이스가 있으면 충돌을 피하기 위해 구현체는 TicketDataRepository로 지정됩니다.\n\n## 데이터 소스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레포지토리는 다양한 데이터 소스를 관리합니다 (예: 로컬, 메모리, 네트워크). 이 작업을 담당하는 구성 요소는 DataSource입니다. 이는 데이터베이스, 네트워크, ShearedPreference, WorkManager 및 파일과 같은 데이터 소스와 레포지토리 사이의 추상화입니다.\n\n- 데이터 소스는 한 번에 하나의 데이터 소스와만 작업해야 합니다.\n- 데이터 소스는 데이터 레이어를 위해 비공개이어야 하며 레포지토리를 통해서만 접근해야 합니다.\n\n## 네이밍 규칙\n\n데이터 소스 클래스는 그들이 책임지는 데이터와 사용하는 소스를 기반으로 명명됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 유형 + 소스 유형 + DataSource.\n\n데이터 유형으로는 Remote 또는 Local을 사용하여 구현이 변경될 수 있으므로 더 일반적으로 설정하세요 (예: FaresLocalDataSource 또는 FaresRemoteDataSource). 소스가 중요한 경우를 위해 소스 유형을 사용하여 더 구체적으로 설명하세요 (예: FaresNetworkDataSource 또는 FaresFileDataSource).\n\n구현 세부 정보를 기반으로한 이름을 피하세요. 예를 들어, UserSQLiteDataSource와 같이 구현 세부 정보에 기반한 이름을 사용하지 마세요. 해당 데이터 소스를 사용하는 리포지토리는 데이터가 어떻게 저장되는지 알 필요가 없습니다. 이 규칙을 따르면 데이터 소스의 구현을 변경(예: SQLite에서 DataStore로 마이그레이션)하더라도 해당 소스를 호출하는 계층에 영향을 주지 않습니다.\n\nUserApi 인터페이스는 네트워크 API 클라이언트의 구현을 숨깁니다. Retrofit 또는 GraphQL이 인터페이스를 지원하는데 차이가 없습니다. 인터페이스에 의존함으로써 앱에서 API 구현을 교체할 수 있습니다. 또한 이러한 방식은 유연성을 제공하며 의존성을 쉽게 교체할 수 있도록 합니다. 예를 들어, 테스트에서 가짜 데이터 소스 구현을 주입할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 원본은 오류 발생 시 예외 처리를 하는 좋은 위치입니다. 애플리케이션에 데이터 원본과 관련된 예외를 노출시키지 말고 대신 애플리케이션이 처리할 수 있는 예외로 매핑해야 합니다.\n\n이전에 언급했던 대로, 리포지토리는 데이터 소스와 동시성을 관리하는 데 더 중점을 둔 것입니다.\n\n위의 예시에서 보듯이, 우리는 로컬 캐시를 관리하고 로컬 및 원격 데이터 소스의 우선순위를 설정하는 전략을 구현했습니다. 리포지토리는 상태를 가질 수 있으며 예를 들어 Mutex를 사용하여 다른 스레드에서 변경 가능한 변수에 대한 읽기 및 쓰기 액세스를 관리할 수 있습니다. 따라서 리포지토리의 수명주기에 대해 고려해야 합니다.\n\n## 수명주기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가능하다면 리포지토리를 무상태로 만들 것을 권장합니다. 동시에 싱글톤으로 유지하여(instance-duplication of data sources와 같은 버그를 피하기 위해 DI를 통해 관리) 안정성을 높일 수 있습니다. DataSource도 마찬가지로 싱글톤으로 만들고 캐시는 리포지토리에서 관리하는 것을 권장합니다.\n\n## 동시성\n\n리포지토리는 어떤 CoroutineDispatcher에서 작업을 실행할지 결정해야 하는 곳입니다. 서로 다른 유형의 작업을 서로 다른 디스패처(또는 쓰레드 풀)에서 실행하는 것이 좋은 실천입니다. IO 작업을 수행하는 경우 Dispatcher.IO를 사용하는 것이 좋습니다. 테스트하기 쉽도록 클래스 생성자를 통해 디스패처를 전달해야 합니다.\n\n# 모델\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 레이어에는 도메인 레이어에서 모델을 반영하는 데이터 모델이 있지만 표현이 다를 수 있습니다. 별도의 데이터 모델을 사용하면 전송 프로토콜에 맞게 사용자 정의할 수 있는 유연성을 제공합니다. 예를 들어, 서버와 클라이언트 간의 통신에 JSON 형식을 사용하고 일부 필드는 JSON 프로토콜에 더 적합한 다른 유형을 가질 수 있습니다. 도메인 모델을 DTO로 매핑하는 로직 및 그 반대는 Repository 클래스에 배치되어야 합니다.\n\n- 데이터 레이어는 도메인 모델만 노출하고 입력으로 사용해야 합니다.\n- 데이터 모델은 Parcelable 및 Serializable와 같은 플랫폼별 직렬화 방식을 구현할 수 있습니다.\n- 사전에 모델 클래스가 정의된 경우, 한 팀의 구성원이 기능의 다른 레이어에 개별적으로 작업할 수 있습니다.\n- 이 레이어에서 노출된 데이터는 변경할 수 없어야 합니다.\n\n## 명명 규칙\n\n모델 클래스는 책임을 지는 데이터 유형의 이름으로 지어집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터 유형 + DTO.\n\n예를 들어: RyderDTO, FareDTO.\n\n# 패키지 규칙\n\n```js\ndata/\n├─ local/\n│ ├─ dto/\n│ │ ├─ FareDTO\n│ │ ├─ RyderDTO\n│ ├─ FaresLocalDataSource\n│ ├─ FaresRemoteDataSource\n├─ network/\n│ ├─ api/\n│ │ ├─ UserNetworkApi // UserApi 인터페이스의 Retrofit 구현\n│ ├─ dto/\n│ │ ├─ UserDTO\n│ ├─ UserRemoteDataSource // UserApi 인터페이스 포함\n├─ repository/\n│ ├─ FaresDataRepository\n│ ├─ RydersDataRepository\n│ ├─ TicketsDataRepository\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리\n\n데이터 레이어는 도메인 레이어에 정의된 리포지토리 구현을 중심으로 구축되었습니다. 이는 데이터의 다양한 소스를 관리하고 사용하는 방법에 대한 전략을 관리하는 역할을 합니다.\n\n다음 앱 아키텍처 주제에 대해서는 계속해서 확인해보세요. 그동안 레이어 간 데이터 매핑 방법에 대해 읽어볼 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-AppArchitectureDatalayer_0.png"},"coverImage":"/assets/img/2024-05-18-AppArchitectureDatalayer_0.png","tag":["Tech"],"readingTime":6},{"title":"제트팩 코파 서체에서 Window Insets 이해하기","description":"","date":"2024-05-18 17:07","slug":"2024-05-18-UnderstandingWindowInsetsinJetpackCompose","content":"\n![Image](/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png)\n\n# 인셋이란 무엇인가요?\n\n인셋은 상태 바, 네비게이션 바, 디스플레이 컷아웃(노치 또는 핀홀로 자주 불림), IME 키보드와 같은 시스템 UI 요소로 인해 화면에서 완전히 사용할 수 없는 영역을 가리킵니다.\n\n기본적으로, 우리 앱의 UI는 상태 바와 네비게이션 바와 같은 시스템 UI 내에 레이아웃되도록 제한됩니다. 이는 시스템 UI 요소가 앱의 콘텐츠를 가리지 않도록 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그렇다면 왜 우리가 모습들에 대해 걱정해야 할까요?\n\n현대 스마트폰이 엣지 투 엣지 화면과 다양한 화면 비율을 맞이하면서, 인셋(insets) 관리가 중요도를 더욱 높이고 있습니다.\n\n본질적으로, 우리는 시스템 제어를 받는 인셋 패러다임에서 개발자들이 엣지 투 엣지 디스플레이를 활성화하거나 시스템 UI 요소 뒤로 그림을 그리며 인셋 관리를 직접 제어하는 방식으로 전환 중입니다!\n\n# 시작하는 방법은?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 초기 설정\n\n우리 앱이 콘텐츠를 그릴 영역을 완전히 제어하도록 설정해야 합니다. 이 설정을 하지 않으면 앱이 시스템 UI 뒤에 검정색이나 단색을 그리거나 소프트웨어 키보드와 동기화되지 않을 수 있습니다.\n\n- Activity onCreate에서 enableEdgeToEdge 함수를 호출합니다.\n\n이 호출은 우리 앱에 시스템 UI 뒤에 표시하도록 요청합니다. 그런 다음 앱은 해당 간격이 UI를 조정하는 데 어떻게 사용되는지를 제어합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n\n    enableEdgeToEdge()\n\n    setContent {\n        // 앱 내용을 여기에 추가합니다\n    }\n}\n```\n\n- Activity AndroidManifest.xml에서 android:windowSoftInputMode=\"adjustResize\"를 설정하세요.\n\n이 설정을 추가하면 앱이 소프트웨어 IME의 크기를 받아들일 수 있으며, 이를 사용하여 IME가 앱에서 나타나고 사라질 때 내용을 적절하게 패딩 및 정렬할 수 있습니다.\n\n```xml\n\u003cactivity\n  android:name=\".ui.MainActivity\"\n  android:label=\"@string/app_name\"\n  android:windowSoftInputMode=\"adjustResize\"\n  android:theme=\"@style/Theme.MyApplication\"\n  android:exported=\"true\"\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 앱이 현재 어떻게 보이는지 아래 코드를 통해 살펴봅시다:\n\n```js\nsetContent {\n    Box(\n        modifier = Modifier\n             .fillMaxSize()\n             .background(color = Color.DarkGray)\n       )\n}\n```\n\n![이미지](/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_1.png)\n\n컬러로 채워진 Box가 화면 전체를 채우고 시스템 바(상단 상태 바 및 하단 네비게이션 바) 뒤에 그려짐을 확인할 수 있습니다. 이것은 우리의 코드가 이제 시스템 UI 뒤에 그리는 능력을 갖추고 있고 이러한 영역을 스스로 제어할 수 있다는 것을 의미합니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 여백 제어하기\n\n시스템 UI 뒤에 표시되고 모든 여백을 수동으로 처리하는 상태인 경우, Compose API를 사용하여 앱의 상호 작용 가능한 콘텐츠가 시스템 UI와 겹치지 않도록 할 수 있습니다.\n\n이러한 API는 또한 앱의 레이아웃을 여백 변경과 동기화시킵니다.\n\n조정할 수 있는 Composable 레이아웃을 조정하기 위해 Inset 유형을 사용하는 주요 방법은 패딩 수정자와 여백 크기 수정자가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n패딩 수정자\n\n창 인셋을 패딩으로 적용하는 방법은 Modifier.windowInsetsPadding(windowInsets: WindowInsets)를 사용할 수 있습니다. 이는 Modifier.padding와 매우 유사하게 작동합니다.\n\nWindowInsets.systemBars, WindowInsets.statusBars, WindowInsets.navigationBars 등과 같은 몇 가지 내장된 창 인셋이 있습니다. 이를 사용하여 원하는 패딩을 제공할 수 있습니다.\n\n예를 들어 이전 코드에서 상태 바와 네비게이션 바를 제외하고 회색 상자를 그리고 싶다면, 다음과 같이 할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nsetContent {\n    Box(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(color = Color.LightGray)\n            .windowInsetsPadding(WindowInsets.systemBars)\n    ) {\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.DarkGray)\n        )\n    }\n}\n```\n\nModifier windowInsetsPadding(WindowInsets.systemBars)은 상단 상태 표시줄과 하단 네비게이션 바에 패딩을 추가하며, 이들은 이해를 돕기 위해 LightGray로 칠해졌습니다. 이로써 우리 앱은 다음과 같이 보일 것입니다:\n\n![이미지](/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_2.png)\n\n우리는 또한 windowInsetsPadding(WindowInsets.statusBars) 또는 windowInsetsPadding(WindowInsets.navigationBars)를 사용하여 이러한 Insets를 별도로 제어할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가장 일반적인 종류의 Insets에 대한 많은 내장 메소드도 있습니다. 예를 들어:\n\n- safeDrawingPadding(), windowInsetsPadding(WindowInsets.safeDrawing)에 해당하는 메소드\n- safeContentPadding(), windowInsetsPadding(WindowInsets.safeContent)에 해당하는 메소드\n- safeGesturesPadding(), windowInsetsPadding(WindowInsets.safeGestures)에 해당하는 메소드\n\nInset 크기 조정기\n\n이러한 조정기는 컴포넌트의 크기를 insets의 정확한 크기로 설정하는 데 도움을 줍니다. Spacer 크기를 설정하는 데 유용합니다.Inset 크기를 차지하면서 화면을 만들 때 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, Inset 크기 수정자를 사용하여 상태 표시줄과 내비게이션 바에 패딩을 제공하도록 마지막 코드를 다음과 같이 작성할 수 있습니다. 이렇게 하면 동일한 결과가 생성됩니다.\n\njs\nsetContent {\nColumn {\nSpacer(\nmodifier = Modifier\n.fillMaxWidth()\n.background(color = Color.LightGray)\n.windowInsetsTopHeight(WindowInsets.statusBars)\n)\nBox(\nmodifier = Modifier\n.fillMaxSize()\n.background(color = Color.DarkGray)\n.weight(1f)\n)\nSpacer(\nmodifier = Modifier\n.fillMaxWidth()\n.background(color = Color.LightGray)\n.windowInsetsBottomHeight(WindowInsets.navigationBars)\n)\n}\n}\n\n이전과 같이 DarkGrey Box에 Insets 패딩을 추가하는 대신, 상태 표시줄과 내비게이션 바의 정확한 크기를 차지하는 LightGray Spacer를 추가했습니다.\n\n## 키보드 IME와 함께 구성 요소 패딩 크기 조정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n가끔 키보드 IME가 열려 있는지 닫혀 있는지에 따라 UI 컴포넌트에 동적 패딩을 적용하고 싶을 때가 있습니다. 좋은 사용 사례는 목록 맨 아래에 입력 필드를 추가하는 경우입니다.\n\n다음과 같은 코드를 고려해보세요:\n\n```js\nsetContent {\n    Column(\n        modifier = Modifier.fillMaxSize().systemBarsPadding()\n    ) {\n        LazyColumn(\n            modifier = Modifier.weight(1f),\n            reverseLayout = true\n        ) {\n            items(100) { index -\u003e\n                Text(text = \"Item $index\", modifier = Modifier.padding(16.dp).fillMaxWidth())\n            }\n        }\n\n        var textFieldValue by remember { mutableStateOf(TextFieldValue()) }\n\n        TextField(\n            modifier = Modifier.fillMaxWidth(),\n            value = textFieldValue,\n            onValueChange = { textFieldValue = it },\n            placeholder = {\n                Text(text = \"Type something here\")\n            }\n        )\n    }\n}\n```\n\n만약 TextField의 패딩을 처리하지 않는다면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Keyboard Opening](https://miro.medium.com/v2/resize:fit:600/1*8HIx9O4S3Lk3mpUJRqI21g.gif)\n\n키보드가 열릴 때 텍스트 필드가 화면 하단에 고정되어 있어서 사용자 경험이 그리 좋지 않음을 볼 수 있습니다.\n\n텍스트 필드 패딩을 조정한 후:\n\n위의 텍스트 필드에는 단순히 `imePadding()` 수정자를 추가하면 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 코드는 다음과 같이 보입니다:\n\n```js\n// 이전 코드와 동일\n\nTextField(\n    modifier = Modifier.fillMaxWidth().imePadding(), // IME 패딩 추가\n    value = textFieldValue,\n    onValueChange = { textFieldValue = it },\n    placeholder = {\n        Text(text = \"여기에 무언가를 입력하세요\")\n    }\n)\n```\n\n이제 TextField 패딩이 변경되며 또한 IME의 상태 변화와 함께 애니메이션되어 입력 필드가 키보드와 함께 이동하는 효과를 만듭니다:\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:600/1*IQIdBM5ovhwMcHmJ0qCOZQ.gif\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 스크롤할 때 키보드 IME를 애니메이션화하자:\n\n스크롤 컨테이너에 추가하는 실험적 API 수정자 imeNestedScroll()가 있습니다. 이 수정자를 스크롤 컨테이너에 추가하면 컨테이너의 맨 아랫부분으로 스크롤할 때 키보드가 애니메이션으로 열립니다.\n\n위 코드를 수정해서 LazyColumn에 이 수정자를 추가하면 다음과 같습니다:\n\n```js\n// 위 코드와 같음\n\nLazyColumn(\n    modifier = Modifier.weight(1f).imeNestedScroll(), // 수정자 추가\n    reverseLayout = true\n) {\n\n// 이전과 같은 코드\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 경험을 제공할 예정입니다:\n\n![image](https://miro.medium.com/v2/resize:fit:600/1*dciSCS0k29yCh1Z4lAM85A.gif)\n\n# 패딩 소비\n\n이제 이 시점에서 우리 마음 속에 몇 가지 질문이 떠오를 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 내부 삽입 패딩 수정자(예: safeDrawingPadding())를 고려할 때, Composable 계층 구조에서 이를 한 번만 적용해야 할까요? 한 번 이상 적용하면 어떻게 되나요? 부모에 적용한 다음에 하위 자식에 다시 적용하면 패딩이 두 번 추가될까요?\n\n내장된 삽입 패딩 수정자는 자동으로 적용된 인셋의 일부를 패딩으로 사용합니다. 구성 트리를 깊게 들어가면, 중첩된 삽입 패딩 수정자와 자식 Composable에 적용된 인셋 크기 조절 수정자는 외부 수정자에 의해 이미 소비(또는 적용 또는 고려)된 인셋의 일부를 알고 있어 해당 인셋을 다시 적용하지 않고 건너뛰어 중복 공간을 피합니다.\n\n이를 이해하기 위해 예시를 살펴봅시다:\n\n```js\nsetContent {\n    var textFieldValue by remember { mutableStateOf(TextFieldValue()) }\n    LazyColumn(\n        Modifier.windowInsetsPadding(WindowInsets.statusBars).imePadding()\n    ) {\n        items(count = 30) {\n            Text(\n                modifier = Modifier.fillMaxWidth().padding(16.dp),\n                text = \"Item $it\"\n            )\n        }\n        item {\n            TextField(\n                modifier = Modifier.fillMaxWidth().height(56.dp),\n                value = textFieldValue,\n                onValueChange = { textFieldValue = it },\n                placeholder = { Text(text = \"Type something here\") }\n            )\n        }\n        item {\n            Spacer(\n                Modifier.windowInsetsBottomHeight(\n                    WindowInsets.systemBars\n                )\n            )\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 코드는 LazyColumn에 긴 항목 목록을 표시합니다. 목록의 맨 아래에는 사용자 입력을 위한 TextField가 있고, 끝에는 창 간격 크기 수정자를 사용하여 하단 시스템 내비게이션 바에 공간을 제공하는 Spacer가 있습니다. 또한 LazyColumn에 imePadding이 적용되어 있습니다.\n\n여기서 키보드가 닫힌 경우 IME의 높이가 없어 imePadding() 수정자가 패딩을 적용하지 않습니다. 따라서 인셋이 사용되지 않고, 이 때 Spacer의 높이는 하단 시스템 바의 크기가 됩니다. 키보드가 열리면 IME 인셋이 IME의 크기에 맞도록 애니메이션화되며 imePadding() 수정자가 LazyColumn에 하단 패딩을 적용하기 시작합니다. 결과적으로 해당 인셋량도 \"소비\"하기 시작합니다.\n\n이제 이 시점에서 imePadding() 수정자에 의해 하단 시스템 바의 일부 여백이 이미 적용되어 Spacer의 높이가 감소하기 시작합니다. 어느 시점에서는 IME 패딩 크기가 하단 시스템 바의 크기를 초과하여 Spacer의 높이가 제로가 됩니다. 키보드가 닫히면 동일한 메커니즘이 반대로 발생합니다.\n\n이 동작은 모든 windowInsetsPadding 수정자 간의 통신을 통해 달성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드가 작동하는 방식을 확인해보세요:\n\n![Code](https://miro.medium.com/v2/resize:fit:600/1*8ZLXFWRuKcZXvPtRmjxPJQ.gif)\n\n또 다른 예시를 살펴보겠습니다:\n\n이 예시에서는 Modifier.consumedWindowInsets(insets: WindowInsets)를 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 수정자는 Modifier.windowInsetsPadding과 같은 방식으로 패딩을 소비하기 위해 사용됩니다. 그러나 소비된 인셋을 패딩으로 적용하지 않습니다.\n\n다른 수정자인 Modifier.consumedWindowInsets(paddingValues: PaddingValues)은 임의의 PaddingValues를 소비합니다.\n\n인셋 패딩 수정자가 아닌 일반 Modifier.padding 또는 고정 높이 간격과 같은 다른 메커니즘으로 패딩 또는 간격을 제공할 때 자식에게 알리는 데 유용합니다.\n\n다음 코드를 참고하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nsetContent {\n    Scaffold { innerPadding -\u003e\n        // innerPadding에는 사용하고 적용할 인셋 정보가 포함되어 있습니다\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.LightGray)\n                .padding(innerPadding)\n        ) {\n            Box(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .background(color = Color.Red)\n                    .windowInsetsPadding(WindowInsets.safeDrawing)\n            ) {\n                Box(\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .background(color = Color.DarkGray)\n                )\n            }\n        }\n    }\n}\n```\n\n이 코드의 결과는 다음과 같이 보일 것입니다:\n\n\u003cimg src=\"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_3.png\" /\u003e\n\n우리는 이 결과물에 문제가 있는 것을 볼 수 있습니다. Scaffold 람다에서 얻은 innerPadding을 바깥 Box에 패딩으로 적용했지만, 내부 Box의 windowInsetsPadding(WindowInsets.safeDrawing)은 중복 패딩(빨간색으로 나타남)을 생성합니다. 즉, 어떤 이유로 인해 여기에서 인셋 소비가 발생하지 않았다는 의미입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기본적으로 Scaffold는 우리가 사용하고 활용할 수 있는 insets를 매개변수 paddingValues로 제공합니다. Scaffold는 콘텐츠에 insets를 적용하지 않으며, 이 책임은 우리에게 있습니다.\n\n따라서 우리가 이중 패딩을 피하고 싶다면, consumeWindowInsets(innerPadding) 수정자를 사용하여 패딩을 직접 소비해야 합니다.\n\n다음은 업데이트된 코드를 고려해보세요:\n\n```js\nsetContent {\n    Scaffold { innerPadding -\u003e\n        // innerPadding은 사용하고 적용할 인셋 정보를 포함합니다\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.LightGray)\n                .padding(innerPadding)\n                // 이 인셋을 소비하여, 아래 계층에서 safeDrawing을 사용할 때 다시 적용되지 않도록 합니다\n                .consumeWindowInsets(innerPadding)\n        ) {\n              // 나머지 코드\n          }\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 내용을 한국어로 다음과 같이 번역하면 됩니다:\n\n이렇게 작성하면 됩니다:\n\n\u003cimg src=\"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_4.png\" /\u003e\n\n그러므로 innerPadding이 outer Box에 의해 소비되면 inner Box의 windowInsetsPadding(WindowInsets.safeDrawing)에 중복 패딩이 적용되지 않습니다.\n\n이로써 이 기사는 마칩니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 글을 통해 많은 개발자들이 Insets의 필요성에 대해 이해하고, 효과적으로 활용하는 방법을 배울 것이라 확신합니다.\n\n모든 예시는 다음 저장소에서 확인할 수 있습니다: [https://github.com/pushpalroy/ComposeInsetsPlayground](https://github.com/pushpalroy/ComposeInsetsPlayground)\n\n팔로우 하기: @pushpalroy\n","ogImage":{"url":"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png","tag":["Tech"],"readingTime":17},{"title":"AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법","description":"","date":"2024-05-18 17:04","slug":"2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay","content":"\n![LLM](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png)\n\nLLM 어플리케이션은 OpenAI와 같은 타사 호스팅 LLM을 사용하도록 개발되었을 때 MLOps 오버헤드가 필요하지 않습니다. 이러한 컨테이너화된 LLM 파워드 앱 또는 마이크로서비스는 DevOps 관행을 따르며 배포할 수 있습니다. 본 문서에서는 우리의 LLM 앱을 AWS와 같은 클라우드 제공업체에 자동으로 배포하는 방법을 탐색해보겠습니다. LlamaIndex는 커뮤니티를 위한 준비된 RAGs 챗봇을 보유하고 있습니다. 우리는 샘플 앱으로 RAGs를 사용하겠습니다.\n\n# IaC Self-Service\n\nIaC는 Infrastructure as Code의 줄임말로 인프라 프로비저닝을 자동화하여 구성이 일관성 있고 반복 가능하게 보장합니다. IaC를 실행할 수 있는 여러 도구들이 있습니다. 본 문서에서는 Terraform을 중점으로 다룰 것인데, Terraform은 클라우드에 중립적인 특성을 가지고 있기 때문입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIaC self-service의 주요 목적은 개발자들이 더 많은 액세스, 제어 및 소유권을 통해 파이프라인에 대한 생산성을 향상시키는 데 도움을 주는 것입니다.\n\n관심 있으신 분들을 위해, 약 1년 전에 DevOps self-service 모델에 관한 5부작 시리즈를 작성했습니다. DevOps self-service 모델에 관련된 모든 측면에 대해 자세히 다루었습니다.\n\n# 고수준 배포 다이어그램\n\nAWS에 컨테이너화된 응용 프로그램을 배포하는 다양한 옵션이 있습니다. ECS Fargate는 몇 가지 좋은 이유로 눈에 띕니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 컨테이너용 서버리스 컴퓨팅, 서버 관리 없이 가능\n- 확장성과 확장성 증가\n- 배포 간소화\n\n먼저 RAGs 앱을 위한 고수준 배포 다이어그램을 작성합니다.\n\n![image](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_1.png)\n\nAWS에 RAGs를 배포하려면 파이프라인이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 파이프라인 개요\n\n먼저, 내가 만든 3-2-1 규칙을 기반으로 한 자가 서비스 파이프라인 아키텍처를 탐색해보겠습니다:\n\n- 3가지 유형의 소스 코드: Terraform 코드, 앱 소스 코드 및 GitHub Actions 워크플로 코드.\n- 2가지 유형의 파이프라인: 인프라 파이프라인 및 애플리케이션 파이프라인.\n- 1개의 파이프라인 통합 글루: GitHub Secrets 생성 자동화.\n\n![image](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자, 한번 자세히 살펴봅시다.\n\n# 인프라 파이프라인\n\n저희는 인프라 파이프라인에서 terraform init, terraform plan, terraform apply 등 테라폼의 핵심 기능을 사용합니다. 아래 다이어그램을 참조해주세요. 2023년 8월 테라폼의 라이센스 변경에도 불구하고, 테라폼의 핵심 기능은 여전히 오픈 소스로 유지됩니다.\n\nterraform init 이전에 몇 가지 단계를 추가합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 워크플로우 보안을 위한 Harden Runner\n- 클라우드 비용 관리를 위한 Infracost\n- 린트를 위한 TFLint\n- 정적 IaC 코드 분석을 위한 Checkov\n\n이러한 도구에 대한 자세한 내용은 파이프라인 보안 및 가드레일에 관한 제 논문을 확인해주세요.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_3.png)\n\n우리는 Terraform에서 IaC 코드를 처음부터 작성해야 할까요? 아닙니다. 잘 알려진 오픈 소스 Terraform 재사용 가능한 모듈인 terraform-aws-modules를 활용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Terraform AWS 모듈\n\nterraform-aws-modules은 AWS에서 리소스를 관리하기 위해 명시적으로 설계된 사전 제작, 재사용 가능한 오픈 소스 Terraform 모듈의 다양한 모음입니다. Anton Babenko가 이끄는 terraform-aws-modules는 지금까지 57개의 모듈을 보유하고 있습니다! 이러한 모듈은 AWS에서 인프라 프로비저닝을 간소화하고 자동화하며, 모범 사례를 표준화하고, 인프라 코드를 작성하는 데 덜 신경 쓰고 빠른 배포를 달성할 수 있도록 돕습니다.\n\nGCP의 경우 terraform-google-modules, Azure의 경우 Azure-Verified-Modules가 있습니다.\n\n자신만의 재사용 가능한 모듈을 작성할 수도 있지만, 이 오픈 소스 재사용 가능한 모듈은 커뮤니티에서 지원하고 테스트됩니다. 인프라 파이프라인 개발을 빠르게 시작하는 데 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 RAGs 앱을 위해, 새 AWS 계정에 배포할 예정이며, terraform-aws-modules에서 다음 모듈들을 최소한으로 선택할 것입니다. \"최소한\" 이라고 말한 이유는 프로젝트 요구에 따라 추가로 리소스를 이 스택에 추가할 수 있습니다. 예를 들어 인증/인가 등을 위한 리소스 등이 있습니다. 그러나 이 POC 데모 앱에서는 자가 서비스 모델을 보여주고 오픈소스 IaC 재사용 가능 모듈을 소개하기 위해 최소 요구 사항을 준수할 것입니다. 두 가지 재료를 숙지하면 프로젝트 요구에 따라 추가 리소스를 프로비저닝하기 위해 재사용 가능 모듈을 선택하실 수 있습니다.\n\n![링크](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_4.png)\n\n- terraform-aws-vpc: 새 VPC, 공용/개인 서브넷, 인터넷 게이트웨이, NAT 게이트웨이, 경로 테이블 등을 프로비저닝하는 네트워킹 모듈입니다.\n- terraform-aws-s3-bucket: ALB 로그용 S3 버킷.\n- terraform-aws-alb: ECS 클러스터용 응용 프로그램 로드 밸런서 (ALB).\n- terraform-aws-ecs: RAGs를 배포할 ECS 클러스터에 대한 Elastic Container Service (ECS) Fargate 인스턴스.\n- terraform-aws-ecr: 앱용 도커 이미지를 저장하는 Elastic Container Registry (ECR).\n\n## 구현 전 요구 사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- AWS에서 OpenID Connect (OIDC) 구성: 우리는 GitHub Actions 워크플로를 사용하여 인프라 프로비저닝을 위한 Terraform 모듈을 시작할 것입니다. OIDC는 AWS 자격 증명을 GitHub 측에 저장하지 않고 GitHub Actions 워크플로가 AWS에 액세스할 수 있도록 합니다. GitHub에는 AWS에서 OIDC를 구성하는 방법에 대한 자세한 지침이 있습니다. 이 단계는 한 번만 AWS 계정당 수행하면 됩니다.\n- Terraform 원격 상태 관리: 인프라 상태는 Terraform 작업의 중요한 부분이며, 실제 세계 리소스를 구성에 매핑하고 메타데이터를 추적하여 대규모 인프라에서 성능을 향상시킵니다. Terraform 원격 상태를 사용하면 사용자가 인프라 상태를 원격 데이터 저장소에 저장하여 중앙 집중화, 보안, 일관성 및 기타 이점을 얻을 수 있습니다. 이 단계도 한 번만 AWS 계정당 수행하면 됩니다. 나는 원격 상태 관리를 위해 S3 버킷과 상태 잠금을 위한 DynamoDB를 통해 처리하는 Terraform 재사용 가능한 모듈을 개발했습니다. 소스 코드는 내 GitHub 리포지토리에 있습니다. 시작하려면 내 샘플 워크플로와 유사한 GitHub Actions 워크플로를 사용할 수 있습니다. GitHub Actions를 익숙하지 않은 경우 \"Application Pipelines\" 섹션을 참조하세요.\n\n## 단계 1: GitHub 환경 생성\n\nGitHub 환경은 시크릿/변수를 세 가지 레벨에서 저장할 수 있어서 파이프라인에서 인프라 프로비저닝 또는 애플리케이션 CI/CD 중에 시크릿/변수를 전달하여 파이프라인 작업을 돕는 중요한 역할을 합니다.\n\n우리의 RAGs 앱을 위해 dev라는 GitHub 환경을 만들고 애플리케이션 파이프라인을 위한 ROLE_TO_ASSUME과 인프라 파이프라인을 위한 TERRAFORM_ROLE_TO_ASSUME 두 환경 변수를 생성해보겠습니다. 이 때 값은 이미 상위 섹션의 사전 준비 지침을 따라 IAM 역할을 만들었다고 가정하고 각각의 IAM 역할 ARN으로 지정해주세요. 여기서 두 가지 다른 역할을 사용하는 이유는 서로 다른 권한을 할당할 수 있기 때문입니다. 참고로, \"Settings\" 탭을 보려면 레포지토리에서 관리자 권한이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_5.png\" /\u003e\n\n동일한 \"설정\" 탭 아래에서 우리는 저장소 수준에서 몇 가지 비밀을 생성합니다. 이는 동일한 앱에 대해 다른 환경에 적용할 수 있음을 의미합니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_6.png\" /\u003e\n\n- NPM_TOKEN: 이 토큰이 필요한 이유는 애플리케이션이 Terraform 재사용 모듈을 호출할 때 이러한 자격 증명을 전달하지 않기 때문입니다. Terraform 재사용 모듈을 호출하는 앱이 Terraform 재사용 모듈이 있는 저장소에 연결하려면 저장소 범위의 토큰이 필요합니다. 특히 저장소가 개인 저장소인 경우 이것은 매우 중요합니다.\n- PIPELINE_TOKEN: 이 토큰은 Terraform이 GitHub 제공자를 호출하여 ECS_CLUSTER, ECS_SERVICE 등과 같은 GitHub 시크릿/변수를 자동으로 생성하게 하는 데 필요합니다. Terraform이 프비저단할 리소스를 기반으GitHub 시크릿/변수 생성의 자동화는 인프라 파이프라인을 애플리케이션 파이프라인과 통합하여 인프라 제공과 애플리케이션의 CI/CD 사이를 완벽하게 이어줍니다. 이 토큰은 저장소 및 read:public_key 스코프를 가져야 합니다.\n- OPENAI_KEY: 여기에는 OpenAI API 키를 저장합니다. 여기에 비밀로 저장되면 소스 코드에 노출되지 않습니다. CI 파이프라인에 이 비밀을 검색하여 전달하는 방법은 \"애플리케이션 파이프라인\" 섹션에서 자세히 살펴볼 것입니다.\n- INFRACOST_API_KEY: Infracost의 API 키입니다. 이는 클라우드 비용 관리를 자동화하는 인프라 비용 관리 도구로 사용될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 2: 인프라 파이프라인 코드 추가\n\n마지막으로, 우리의 인프라 파이프라인 코드를 리포지토리에 추가해 봅시다. 아래 파일/폴더와 관련된 인프라 파이프라인을 확인해보세요. 샘플 코드는 내 리포지토리에서 확인할 수 있습니다. 이렇게 구성된 우리의 Terraform 코드가 왜 이런 구조를 갖는지에 대해 자세히 알아보려면 Terraform 프로젝트 구조에 대한 내 기사를 참고하세요.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_7.png)\n\nmain.tf 파일은 Terraform 재사용 가능 모듈을 위한 주요 래퍼입니다. 귀하의 스택에 따라 이 파일에서 한 개 이상의 재사용 가능 모듈을 호출할 수 있습니다. 우리의 RAGs 앱의 경우, 우리는 인프라를 프로비저닝하기 위해 terraform-aws-modules 섹션에서 언급된 다섯 개의 재사용 가능 모듈을 호출합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nterraform-aws-modules의 각 재사용 가능한 모듈에 대해 해당 모듈의 사용 패턴에 대한 예제 코드를 참조하십시오. 사용 사례에 따라 단순 또는 완전한 예제 중 하나를 선택하여 해당 재사용 가능한 모듈을 main.tf의 기반이로 사용할 수 있습니다.\n\n그런 다음, 샘플 예제 코드를 매개변수화하여 특정 환경의 terraform.tfvars 파일 아래 .env 폴더로 변수를 외부화합니다. 예를 들어, 프로덕션 환경의 CPU/메모리 값은 개발 환경에서 사용되는 값과 다를 가능성이 높습니다. 따라서 CPU/메모리는 매개변수화하기에 좋은 후보입니다.\n\n아래와 같이 ECS 프로비저닝을 위한 샘플 Terraform 코드의 주요 요소 몇 가지를 살펴보겠습니다.\n\n- Line 174는 우리가 재사용 가능한 모듈 terraform-aws-ecs를 호출하는 곳입니다.\n- Line 177 이후는 클러스터 이름과 같은 변수를 재사용 가능한 모듈로 전달하는 곳입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_8.png\" /\u003e\n\n귀하의 사용 사례에 따라, 비슷한 AWS 스택을 공유하는 많은 애플리케이션이 있다면 main.tf의 대부분 로직을 중앙 집중형 재사용 가능한 모듈 리포지토리로 이동하여 원래 terraform-aws-modules 위에 또 다른 추상화 레이어를 구현할 수 있습니다. 이 접근 방식은 IaC 코드의 추가 재사용성을 허용하여 호출자 리포지토리가 매개변수화를 위한 최소한의 IaC 코드를 갖도록 합니다. 제가 작성한 Terraform 프로젝트 구조에 대한 기사에서는 이와 같은 중앙 리포지토리가 조직 내에서 재사용 가능한 모듈을 보유하는 구현 방법을 자세히 설명하고 있습니다. 확인해보세요.\n\n## 단계 3: 인프라 파이프라인을 위한 GitHub Actions 워크플로우 추가\n\n테라폼 프로비저닝을 위한 재사용 가능한 GitHub Actions 워크플로우를 만들었습니다. 워크플로우 보안, 클라우드 비용 관리, IaC 린팅, 스캔 및 마지막으로 terraform init, plan, apply와 같은 단계를 포함하고 있습니다. 이는 샘플 워크플로우로, 귀하의 요구에 맞게 수정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 RAGs 리포지토리에서 .github/workflows 디렉토리 아래에 terraform-aws.yml을 추가했습니다. 이 워크플로우의 주요 로직은 아래 빨간색으로 강조된 부분입니다:\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_9.png)\n\n- permissions: GitHub Actions 워크플로우가 OIDC를 사용하여 AWS에 인증할 수 있도록 id-token: write를 명시하는 것이 중요합니다.\n- uses: 이 줄은 재사용 가능한 워크플로우를 호출하며, 동일한 로직을 다른 워크플로우 또는 다른 리포지토리로부터 중복으로 작성하는 것을 방지합니다.\n- secrets: inherit: 이 줄은 환경/리포지토리/조직 수준에서 구성된 secrets/변수를 다른 리포지토리의 재사용 가능한 워크플로우로 전달할 수 있게 합니다.\n\n## 단계 4: 인프라스트럭처 파이프라인 시작\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금, 모든 일이 순조롭게 진행 중이에요. RAGs 저장소에서 \"Terraform AWS 프로비저닝\" 워크플로를 트리거하여 인프라 파이프라인을 시작해 봅시다.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_10.png)\n\n이 워크플로는 저희 개발 환경에서 AWS 자원을 프로비저닝할 거에요. 완료되면 Terraform Apply 단계에서 나오는 결과를 주의 깊게 확인해 주세요. 아래 스크린샷을 참고해 주세요. 나중에 RAGs 앱을 실행할 때 alb_dns 값을 사용할 거에요. 이 값을 메모해 두세요.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS에 로그인하여 VPC 리소스 맵을 확인해 보세요. 아래 스크린샷을 참조하세요. 네트워킹 (VPC, 서브넷, 라우팅 테이블 등)가 성공적으로 프로비저닝되었습니다. 또한 새로운 ECS 클러스터, ECR, ALB가 준비되었는지 확인하세요.\n\n![AWS 스크린샷](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_12.png)\n\n# 애플리케이션 파이프라인 (CI/CD)\n\n이제 AWS에서 앱을 배포할 수 있는 인프라가 준비되었습니다. 새로 구성된 ECS 클러스터로 앱을 빌드하고 배포하는 것으로 넘어갑시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 다이어그램은 CI (Continuous Integration) 파이프라인의 주요 단계를 나열한 것입니다.\n\n![CI Pipeline](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_13.png)\n\n그리고 우리의 샘플 CD (Continuous Deployment) 파이프라인은 다음과 같습니다:\n\n![CD Pipeline](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_14.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 단계 1: 앱을 컨테이너화하세요 (컨테이너화되어 있지 않은 경우)\n\n먼저 RAGs 리포지토리에 Dockerfile을 추가하여 코드를 Docker 이미지로 빌드하고 AWS의 새로 프로비저닝된 ECR에 푸시해야 합니다. 아래 예시 Dockerfile 스니펫을 참조해 주세요.\n\n```js\nFROM python:3.9-slim\n\nWORKDIR /app\nCOPY requirements.txt requirements.txt\nCOPY . .\n\nRUN pip install -r requirements.txt\n\nEXPOSE 8501\nCMD [\"streamlit\", \"run\", \"1_🏠_Home.py\"]\n```\n\n## 단계 2: CI/CD를 위한 GitHub Actions 워크플로우 추가\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발 목적으로 CI/CD를 하나의 단일 워크플로에 통합할 수 있습니다. 그러나 실제로는 특히 고급 환경에서는 이미지 불변성을 보장하기 위해 CI/CD를 두 개의 다른 워크플로로 분리하는 것이 좋습니다. GitHub Actions 워크플로 오케스트레이션에 대해 더 자세히 확인하려면 제 GitHub Actions 워크플로 조정에 대한 글을 참조하세요.\n\nCI 및 CD를 처리하는 두 가지 재사용 가능한 GitHub Actions 워크플로를 만들었습니다:\n\n- python-build-image.yml: Python 앱을 위한 도커 이미지를 빌드합니다.\n- deploy-to-ecs.yml: 도커 이미지를 AWS ECS Fargate에 배포합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 이미지 빌드 워크플로우에서의 단계로, 워크플로우는 인프라 파이프라인의 단계 1에서 정의된 GitHub 리포지토리 시크릿을 통해 OpenAI API 키를 검색한 후, 해당 키를 .streamlit 디렉토리 아래의 secrets.toml 파일에 작성합니다. 시크릿 처리를 CI 파이프라인에 위임함으로써 API 키와 같은 시크릿을 관리할 때 걱정 없이 사용할 수 있습니다. API 키와 같은 시크릿을 소스 코드에 절대로 푸쉬하면 안 됩니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_15.png\" /\u003e\n\n## 단계 3: CI/CD 파이프라인 시작\n\n코드 푸시 또는 PR 생성/병합에 의해 CI/CD 파이프라인이 자동으로 트리거되는 것이 좋습니다. GitHub Actions의 주요 장점 중 하나는 GitHub 레포지토리와 원활하게 통합되어 있기 때문에 이와 같이 작동합니다. 워크플로우에서 샘플 트리거는 다음과 같이 정의할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\non:\npush:\nbranches: - main\npull_request:\n\n이제 애플리케이션 파이프라인을 시작할 시간입니다. 도커 이미지를 빌드하고 ECS에 배포하기 위해 수동으로 실행하거나 코드를 푸시/PR합니다. 아래에 성공적인 CI/CD 워크플로우 실행을 확인하세요.\n\n![CI/CD Workflow](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_16.png)\n\n## 단계 4: RAGs 앱 시작하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 RAGs 앱을 시작할 시간이에요. 이제 AWS ECS Fargate에 성공적으로 배포되었어요. 이전에 Terraform Apply 단계에서 인프라 파이프라인의 출력을 기억하시나요? 그 URL을 입력하여 RAGs 앱을 시작해보세요. 잘 작동할 거예요!\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_17.png)\n\n# 제거 및 정리\n\n마지막으로, AWS 리소스를 제거하고 정리해야 해요. 우리의 Terraform GitHub Actions 워크플로 파일에는 제거를 위한 대체 플로우가 구축되어 있어요. 제거 워크플로우는 앱의 제거 브랜치를 생성하고 해당 브랜치를 선택하여 Terraform 워크플로우를 트리거함으로써만 실행될 수 있어요. 이와 같은 활동을 위해 별도의 제거 브랜치를 만드는 이유는 사용자가 제거 작업을 실수로 트리거하지 않도록 보호하는 추가적인 안전 장치를 제공하기 위함이에요. 아래 스크린샷을 보고 Terraform AWS 프로비저닝 워크플로우를 트리거하여 AWS 리소스를 제거해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_18.png\" /\u003e\n\n# 주요 end-to-end 구현 포인트\n\n저희의 파이프라인의 주요 end-to-end 구현 포인트를 GitHub 저장소, GitHub Actions 워크플로우 및 Terraform 코드에서 살펴봅시다. 다음 다이어그램은 코드부터 구성, 통합 지점까지의 end-to-end 흐름을 강조합니다.\n\n\u003cimg src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_19.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n본 기사에서는 DevOps 셀프 서비스 모델을 사용하여 LlamaIndex의 RAGs 챗봇을 AWS ECS fargate에 배포하는 방법을 탐색했습니다. MLOps를 필요로 하지 않는 LLM 기반 앱의 경우, DevOps 셀프 서비스 모델을 사용하여 AWS와 같은 클라우드 제공업체에 배포하는 데 탁월하게 작동합니다.\n\n이 셀프 서비스 모델이 제공하는 파이프라인 프레임워크와 terraform-aws-modules와 같은 다양한 오픈 소스 IaC 재사용 모듈을 결합하면 프로젝트 요구 사항에 따라 재사용 가능한 모듈을 혼합하여 파이프라인에 대한 더 많은 액세스, 제어 및 소유권을 확보하여 생산성을 높일 수 있습니다.\n\n본 기사가 도움이 되었기를 바랍니다. 이 프레임워크의 완전한 소스 코드는 제 GitHub 저장소에 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- https://github.com/wenqiglantz/reusable-workflows-modules\n- https://github.com/wenqiglantz/rags\n\n코딩을 즐기세요!\n\n## 참고 자료:\n\n- terraform-aws-modules GitHub 저장소\n- 아마존 웹 서비스에서 OpenID Connect 구성\n- 개발 운영자동화(Self-Service)로 향하는 길: 5부작 시리즈\n- 개발 운영자동화(Self-Service) 중심의 파이프라인 통합\n- 개발 운영자동화(Self-Service) 중심의 파이프라인 보안 및 가드레일\n- 개발 운영자동화(Self-Service) 중심의 GitHub Actions 워크플로 오케스트레이션\n- 개발 운영자동화(Self-Service) 중심의 Terraform 프로젝트 구조\n- 개발 운영자동화(Self-Service) 파이프라인 아키텍처와 3-2-1 규칙\n- Infracost + Terraform + GitHub Actions = 클라우드 비용 관리 자동화\n","ogImage":{"url":"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png"},"coverImage":"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png","tag":["Tech"],"readingTime":19},{"title":"테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트","description":"","date":"2024-05-18 17:01","slug":"2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet","content":"\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png)\n\n# 목차\n\n- 목차\n- Terraform CLI 및 명령어 치트 시트\n  - 초기화:\n  - 구성 관리:\n  - 인프라 관리:\n  - 상태 관리:\n  - 워크스페이스:\n  - 로그:\n  - 로그 레벨 활성화 및 제어:\n  - 로그 파일 지정:\n  - 셸 명령으로 로그 캡처:\n  - 다른 유용한 명령어:\n  - 추가 팁:\n- 결론\n- 나에 대해\n- 참고 문헌\n\n# Terraform CLI 및 명령어 치트 시트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테라폼 명령어는 인프라를 자동으로 프로비저닝하고 관리합니다. 이를 통해 수동으로 구성 작업을 줄이고 시간을 절약하며 오류를 줄일 수 있습니다.\n\n테라폼은 인프라를 코드로 관리하기 위한 다양한 명령어를 제공합니다.\n\n아래는 자주 사용되는 명령어에 대한 빠른 참조 가이드입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 초기화:\n\n- terraform init: 플러그인을 다운로드하고 백엔드 구성을 수행하여 작업 디렉토리를 초기화합니다.\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_2.png)\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 구성 관리:\n\n- terraform fmt: Terraform 구성 파일을 가독성 있게 형식화합니다.\n- terraform validate: Terraform 구성 구문을 유효성 검사합니다.\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_4.png)\n\n## 인프라 관리:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- terraform plan: 인프라 변경에 대한 자세한 실행 계획을 생성합니다.\n- terraform apply: 계획된 인프라 변경을 계획에 따라 적용합니다.\n- terraform apply -auto-approve: 확인 프롬프트 없이 계획을 적용합니다 (주의하여 사용해주세요!).\n- terraform destroy: Terraform 구성에 따라 기존 인프라를 파괴합니다.\n- terraform destroy -auto-approve: 확인 없이 인프라를 파괴합니다 (주의하여 사용해주세요!).\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_5.png)\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_6.png)\n\n## 상태 관리:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- terraform state list: Terraform이 관리하는 모든 리소스를 상태 파일에서 나열합니다.\n- terraform state show: 상태 파일에서 특정 리소스의 세부 정보를 표시합니다.\n- terraform state rm: 리소스를 Terraform 상태에서 제거하지만 공급자에서 파괴하지는 않습니다.\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_7.png)\n\n더 많은 정보는 여기에서 확인할 수 있습니다:\n\n## Workspaces:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- terraform workspace new: 새 워크스페이스를 만듭니다.\n- terraform workspace select: 기존 워크스페이스를 선택합니다.\n- terraform workspace list: 사용 가능한 모든 워크스페이스를 나열합니다.\n\n## 로그:\n\n테라폼 자체에는 전통적인 방식으로 로그를 볼 수 있는 내장 명령어가 없습니다. 그러나 환경 변수를 사용하여 테라폼의 로깅 동작을 제어할 수 있습니다. 다음은 테라폼 로그를 관리하는 방법입니다:\n\n## 로그 레벨 활성화 및 제어하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 테라폼은 TF_LOG 환경 변수를 사용하여 로그의 상세 수준을 제어합니다. 이를 다음 수준 중 하나로 설정할 수 있습니다:\n- ERROR: 오직 오류만 기록합니다 (기본값)\n- WARN: 경고 및 오류를 기록합니다\n- INFO: 정보 메시지, 경고 및 오류를 기록합니다\n- DEBUG: 자세한 디버그 정보를 기록합니다\n- TRACE: 가장 상세한 추적 정보를 기록합니다 (불안정한 형식)\n- 예시 (디버그 로그를 활성화):\n\n```js\nexport TF_LOG=\"DEBUG\"\nterraform plan\n```\n\n## 로그 파일 지정하기:\n\n- TF_LOG_PATH 환경 변수를 사용하여 테라폼이 로그를 작성할 특정 파일을 정의합니다.\n- 예시 (로그를 “terraform.log”에 작성):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nexport TF_LOG_PATH=\"terraform.log\"\nterraform apply\n```\n\n## 셸 명령어로 로그 캡처하기:\n\n- 테라폼 명령어를 셸 기능과 결합하여 로그를 캡처하고 형식화할 수 있습니다:\n- 예시 (디버그 로그와 함께 플랜 출력 캡처):\n\n```js\nterraform plan -no-color 2\u003e\u00261 | tee plan.log\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_8.png)\n\n- 설명:\n  - no-color: 색이 없는 출력을 사용하여 해석을 쉽게 할 수 있습니다.\n  - 2\u003e\u00261: 표준 출력(stdout)과 표준 오류(stderr)를 다음 명령어로 리디렉션합니다.\n  - tee plan.log: \"plan.log\"이라는 파일을 생성하고 캡처한 출력을 해당 파일에 기록합니다.\n\n## 기타 유용한 명령어:\n\n- terraform get: Terraform 모듈을 다운로드하고 설치합니다. (프로젝트 내의 모듈에 대해서)\n- terraform providers: 구성된 제공자에 관한 정보를 표시합니다.\n- terraform output: Terraform 구성에서 출력 값들을 표시합니다.\n- terraform version: Terraform 버전 정보를 표시합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 추가 팁:\n\n- 자세한 도움말을 얻으려면 모든 명령어에 -help 플래그를 사용하세요 (예: terraform init -help).\n- 모든 명령어와 옵션에 대한 포괄적인 정보를 위해 공식 Terraform 문서를 참조하세요 https://developer.hashicorp.com/terraform/cli/commands.\n\n# 결론\n\nTerraform CLI를 숙달하고 중요한 명령어와 구성을 이해하면 인프라를 코드로 효율적으로 관리하고, 배포를 간소화하며, 확장 가능하고 재현 가능한 환경을 유지할 수 있습니다. 이는 인프라의 신뢰성과 민첩성을 향상시킬 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n감사합니다! 🙌🏻 구독하지 않고 CLAP 👏을 누르지 말고 잊지 마세요! 다음 기사에서 만나요.🤘\n\n# 저에 대해\n\n“안녕하세요! Joel O’Wembo입니다. AWS 인증 클라우드 아키텍트이자 백엔드 개발자이자 AWS 커뮤니티 빌더입니다. 저는 필리핀에 거주하고 있습니다 🇵🇭 클라우드 아키텍처, 데브옵스, 그리고 고가용성(HA) 원칙에 대한 깊은 이해력을 바탕으로 강력한 전문성을 제공합니다. 제 지식을 활용하여 고가용성을 갖춘 견고하고 확장 가능한 클라우드 응용프로그램을 효율적인 기업 배포를 위해 오픈 소스 도구를 사용하여 만듭니다.”\n\n저자(Joel O. Wembo)에 대한 더 많은 정보는 방문하십시오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n링크:\n\n- Linkedin: [https://www.linkedin.com/in/joelotepawembo/](https://www.linkedin.com/in/joelotepawembo/)\n- 웹사이트: [https://joelwembo.com](https://joelwembo.com)\n- 트위터: [https://twitter.com/joelwembo1](https://twitter.com/joelwembo1)\n- GitHub: [https://github.com/joelwembo](https://github.com/joelwembo)\n- 포트폴리오: [joelwembo.github.io](joelwembo.github.io)\n- Patreon: [https://www.patreon.com/joelwembo](https://www.patreon.com/joelwembo)\n\n# 참고 문헌\n","ogImage":{"url":"/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png"},"coverImage":"/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png","tag":["Tech"],"readingTime":8},{"title":" 테라폼을 사용하여 쿠버네티스에서 MERN 앱을 위한 엔드투엔드 CICD 파이프라인 구축하기, GitHub Actions와 Ansible으로","description":"","date":"2024-05-18 16:59","slug":"2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible","content":"\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png\" /\u003e\n\n쿠버네티스에서 MERN 웹 애플리케이션을 위한 완벽한 CI/CD 파이프라인을 알아보고 테라폼을 GitHub Actions와 통합하여 인프라 프로비저닝 및 관리를 자동화합니다. AWS EC2 구성, Kubernetes (K3s) 설치 및 EC2에 풀 스택 MERN 프로젝트를 배포하는 데 Ansible을 사용합니다.\n\n# 🛠️사전 요구 사항\n\n- 필요한 권한을 갖춘 AWS 계정\n- 전체 스택 응용 프로그램(MERN)을 컨테이너화\n- HCP Terraform, GitHub 및 Docker Hub 계정\n- AWS 클라우드의 기본 지식\n- DNS 편집 권한이 있는 도메인\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사는 조금 길어요. 그래서 마지막 단계로 따라와서 테라폼을 사용해 쿠버네티스에 MERN 앱용 엔드투엔드 CI/CD 파이프라인을 구축하는 방법을 배우시면 좋겠네요. GitHub Actions와 Ansible을 활용해요.\n\n이 프로젝트는 고급 수준의 프로젝트에요. 그래서 AWS, 테라폼, 앤서블, MERN 프로젝트, GitHub Actions의 기본 개념이 명확하다고 가정할게요. 기본 수준은 말하지 않아요. 그냥 프로젝트를 통합하고 구현했어요.\n\n이 기사는 세 가지 섹션으로 구성되어 있어요:\n\n섹션 1: GitHub Actions를 사용해 테라폼을 활용해 AWS 인프라 배포를 자동화하기.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nSection 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible을 사용하여 MERN 앱 배포하기.\n\nSection 3: GitHub Actions를 사용한 Kubernetes (K3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구성.\n\n그럼, 지금 가보자, 만약 이 글에 대한 질문이 있거나 도움이 필요하면 언제든지 연락해 주세요.\n\n# 📘Section 1: GitHub Actions를 이용하여 Terraform을 사용하여 AWS 인프라 자동화하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우선 GitHub에서 Terraform을 사용하여 AWS 인프라를 생성하기 위해 GitHub 액션을 이용해 git 저장소(terraform)를 복제하세요.\n\n단계 1: 로컬 머신에서 저장소를 복제합니다.\n\n```js\ngit clone https://github.com/bjnandi/terraform-ci-cd-aws.git\n```\n\n복제 후에는 VS Code 편집기의 Dev Container에서 해당 저장소를 엽니다. Dev Container를 사용하면 주요 머신으로부터 환경(Terraform)을 격리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단계 2: HCP Terraform Cloud 설정하기\n우리가 생성할 GitHub Action은 HCP Terraform Cloud에 연결하여 구성을 계획하고 적용할 것입니다. 액션 워크플로우를 설정하기 전에, HCP Terraform Cloud에 로그인하고 조직 내에서 워크스페이스를 생성한 다음 AWS 자격 증명을 HCP Terraform 워크스페이스에 추가해야 합니다. 다음 단계를 따라주세요:\n\n조직 `워크스페이스` 변수\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_1.png)\n\n단계 3: API 토큰 생성하기\nHCP Terraform 사용자 API 토큰을 생성하세요. 이를 위해 HCP Terraform 사용자 설정의 토큰 페이지로 이동하세요. API 토큰 생성을 클릭한 다음 \"Generate token\"을 클릭하여 GitHub Actions 토큰을 설명란에 입력하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_2.png)\n\n**단계 4:** GitHub Secrets에 GitHub 저장소에 API 토큰을 설정합니다.\n자세한 내용은 GitHub Secrets에서 확인하실 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.\n\nGitHub `저장소 이름` 설정 `시크릿과 변수` 작업 `저장소 시크릿` 새 저장소 시크릿 :\n\nTF_API_TOKEN: HCP Terraform 사용자 설정에서 생성된 API 토큰입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_3.png\" /\u003e\n\n5단계: VS Code 편집기로 돌아가서 \"tf-infa-test\"라는 이름의 새 브랜치를 만듭니다.\n\n```js\ngit checkout -b 'tf-infa-test'\n```\n\n그런 다음 \"env/dev\" 디렉토리의 main.tf 파일을 엽니다. HCP Terraform에서 생성된 HCP Terraform 조직 및 워크스페이스 이름으로 \"organization\"과 \"workspaces\"를 설정한 다음 파일을 저장하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n  cloud {\n    organization = \"YOUR-ORGANIZATION-HERE\"\n\n    workspaces {\n      name = \"YOUR-WORKS-SPACE\"\n    }\n  }\n```\n\n그런 다음 \".github/workflows/\" 디렉토리에서 두 개의 워크플로 파일 (terraform-plan.yml 및 terraform-plan.yml)을 엽니다.\n\n- terraform-plan.yml\n- terraform-plan.yml\n\n“TF_CLOUD_ORGANIZATION” 및 “TF_WORKSPACE”를 HCP Terraform 조직 및 워크스페이스의 이름으로 업데이트하고 파일을 저장하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6단계: 저희의 테라폼 파일 구조는 루트 작업 디렉토리가 \"env/dev\"인 블루프린트 모델입니다. 그래서 HCP 테라폼 클라우드에서 테라폼 작업 디렉토리에 \"env/dev\"를 추가했습니다.\n\n이를 위해 테라폼 클라우드로 이동하십시오:\n\nOrganizations `Workspaces` Workspace Name `Setting` Terraform Working Directory\n\n```js\nenv / dev;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 코드를 추가하세요.\n\n![image](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_4.png)\n\n마지막으로 \"Save settings\"를 클릭하세요.\n\n이제 GitHub Actions를 사용하여 인프라 프로비저닝을 준비했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**단계 7: 풀 리퀘스트 생성하기**\n이제 VS Code 편집기로 돌아가서 데모 테스트용 코드를 약간 수정한 후, 해당 코드를 GitHub \"tf-infa-test\" 브랜치에 커밋하고 푸시하세요. 그런 다음 GitHub에서 이 브랜치에 대한 풀 리퀘스트를 생성하세요.\n\n풀 리퀘스트를 생성한 후 GitHub 워크플로우(테라폼 플랜)를 실행하여 테라폼 플랜을 확인하세요.\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_5.png)\n\n**단계 8: 풀 리퀘스트 검토 및 병합**\n\"Terraform plan\"에 만족한다면, 'main' 브랜치에 '병합' 코드로 풀 리퀘스트를 닫은 다음 인프라 구축을 위해 워크플로우(테라폼 애플라이)를 실행하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Step 9](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_6.png)\n\n9단계: 프로비전된 EC2 인스턴스 확인\n\n모든 리소스가 생성되었습니다.\n\n![Step 9](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 📘 섹션 2: EC2 구성, Kubernetes (K3s) 설치 및 Ansible를 사용하여 MERN 앱 배포\n\n인프라 프로비저닝이 완료되면 GitHub의 두 번째 git 저장소 (Ansible)로 이동하여 AWS EC2를 구성하고 Kubernetes (K3s)를 설치하고 Ansible를 사용하여 MERN 앱을 배포합니다.\n\n단계 1: 로컬 머신에서 저장소를 복제합니다.\n\n```js\ngit clone https://github.com/bjnandi/ansible-k3s-nginx-lb.git\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n깃 저장소를 복제한 후, VS Code의 Dev Container에서 열어보세요. Dev Container는 환경(Ansible)을 메인 머신과 격리시킵니다.\n\n단계 2: SSH 키를 위해 \".ssh\" 폴더에 \"linux.pem\" 파일을 만드세요.\n\n```bash\nnano ~/.ssh/linux.pem\n```\n\n여기에 \"pem\" 파일 코드를 붙여넣고 파일을 저장하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep 3: \"linux.pem\" 파일의 권한을 설정하세요\n\n```js\nchmod 400 ~/.ssh/linux.pem\n```\n\nStep 4: 이제 디렉토리의 권한을 설정하세요. Dev Container는 모든 사용자에 대해 기본 권한으로 디렉토리를 마운트합니다.\n\n```js\nchmod 755 /workspaces/ansible-k3s-nginx-lb\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단계 5: 이제 우리의 AWS EC2 IP 주소로 IP 주소를 업데이트하세요.\n\n- “hosts” 파일에서:\n\n- bastion (공용 IP)\n- k3s_nodes, additional_agent_nodes 및 nginx_lb (사설 IP)\n- nginx_lb(사설 IP)\n- ProxyCommand용 (공용 IP)\n\n```js\n[bastion]\nbastion ansible_host=34.195.33.137\n[bastion:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\n\n[k3s_nodes]\nmaster ansible_host=10.0.1.222\n[k3s_nodes:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\nansible_ssh_common_args='-o ProxyCommand=\"ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\n\n[additional_agent_nodes]\nworker1 ansible_host=10.0.2.244\nworker2 ansible_host=10.0.1.236\n[additional_agent_nodes:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\nansible_ssh_common_args='-o ProxyCommand=\" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\n\n[nginx_lb]\nnginx_lb ansible_host=10.0.5.187\n[nginx_lb:vars]\nansible_user=ubuntu\nansible_ssh_private_key_file=~/.ssh/linux.pem\nansible_ssh_common_args='-o ProxyCommand=\" ssh -o StrictHostKeyChecking=no -i ~/.ssh/linux.pem -W %h:%p -q ubuntu@34.195.33.137\"'\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. \"nginx.conf\" 파일에서:\n\n- 업스트림 클라이언트 및 API 서버\n\n```js\n   upstream client {\n        server 10.0.1.222:30001; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.2.244:30001; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.1.236:30001; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n    }\n\n    upstream apiserver {\n        server 10.0.1.222:30005;  # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.2.244:30005; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n        server 10.0.1.236:30005; # 귀하의 EC2 인스턴스 사설 IP로 교체하세요\n    }\n```\n\n3. 이제 \"project_vars\" 파일에서:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmaster_ip: 10.0.1.222\n```\n\n단계 6: Ansible 구성이 실행 준비 완료되었습니다\n\n- Makefile을 사용하여 모든 구성을 한 주석에서 실행하려면:\n\n```js\nmake run_ansible\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 하나씩 실행하려면:\n\n```js\n ansible-playbook -i hosts k3s_install.yaml\n\n ansible-playbook -i hosts k3s_mern_deploy.yaml\n\n ansible-playbook -i hosts config_nginx_lb.yaml\n\n ansible-playbook -i hosts config_bastion.yaml\n```\n\n이제, 모든 EC2를 구성하고 Kubernetes(k3s)를 설치한 다음 Kubernetes(k3s)에 MERN 앱을 배포합니다.\n\n단계 7: 이제 도메인 DNS 설정으로 이동하여 \"A\" 레코드를 업데이트합니다. 저희 도메인은 Squarespace에서 제공합니다. 그래서, Squarespace DNS 설정에서 이 도메인 DNS를 업데이트했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 앱에 대해 EC2 인스턴스(개발 로드밸런서)의 공개 IP로 두 개의 사용자 정의 \"A\" 레코드를 추가했어요.\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_8.png)\n\n단계 8: 이제 도메인을 사용하여 앱을 보여줄 차례에요.\n\n이 도메인(http://bjtechlife.com)에서 우리 앱을 봤어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 Docker Hub repository 이미지가 있거나 수동으로 이미지를 빌드하여 Docker Hub에 푸시했다면, 먼저 출력에서 앱 UI를 확인할 수 있습니다. 그렇지 않은 경우 (섹션 3)를 완료한 다음 출력에서 앱 UI를 확인할 수 있습니다.\n\n![](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_9.png)\n\n# 📘세션 3: Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인 구축하기 (GitHub Actions 사용)\n\nEC2 구성, (k3s) 설치 및 앱 배포를 완료하고, AWS EC2 인스턴스에서 GitHub Actions를 사용하여 Kubernetes (k3s)에서 MERN 앱을 위한 CI/CD 파이프라인을 만들기 위해 GitHub의 세 번째 git 저장소(MERN 프로젝트)로 이동하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스텝 1: 로컬 머신에서 저장소를 복제하세요\n\n```js\ngit clone https://github.com/bjnandi/ci-cd-pipeline-MERN-k3s.git\n```\n\n복제한 후, VS Code 에디터에서 열어주세요.\n\n\".github/workflows/\" 디렉토리에 두 개의 워크플로우 파일 (docker-ci 및 k3s-cd)이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- docker-ci.yml\n- k3s-cd.yml\n\n첫 번째 워크플로우 \"docker-ci.yml\" 파일은 이미지를 빌드하여 Docker Hub에 푸시하고, 다른 워크플로우 \"k3s-cd.yml\" 파일은 Kubernetes(k3s)에서 이미지를 업데이트합니다.\n\n단계 2: 이제 GitHub Secrets를 사용하여 시크릿을 채워넣어야합니다. GitHub 리포지토리에 추가할 수 있습니다. 자세한 정보는 GitHub Secrets에서 확인할 수 있습니다. 이제 시크릿과 변수로 이동하여 값을 설정합니다.\n\nGithub `Repo Name` 설정 `Secrets and variables` 작업 `Repository Secrets` 새 리포지토리 시크릿 :\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEC2_HOST: 배스천 호스트 EC2 인스턴스의 공개 IP 주소는 대략 이와 같을 것입니다. \"34.195.33.137\".\n\nMASTER_NODE: k8s-instance-master EC2 인스턴스의 사설 IP 주소는 대략 이와 같을 것입니다. \"10.0.1.222\".\n\nEC2_USERNAME: EC2 인스턴스의 사용자 이름은 일반적으로 \"ubuntu\"입니다.\n\nSSH_PRIVATE_KEY: 인스턴스에 로그인하는 데 사용할 “.pem” 파일입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDOCKER_USERNAME: 이것은 도커 허브 계정 프로필로 이동하면 확인할 수 있는 도커 허브의 \"사용자 이름\"입니다. 도커 이미지를 도커 허브에 푸시하는 데 사용됩니다.\n\nDOCKER_PASSWORD: 이것은 도커 허브 계정의 \"비밀번호\"입니다.\n\n![이미지](/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_10.png)\n\n단계 3: \"VS Code Editor\"로 돌아가서 데모 테스트를 위해 코드나 UI 파일을 편집하거나 작은 변경 사항을 수행한 후, 현재 파일에서 앱의 CI/CD 테스트를 위해 GitHub의 \"main\" 브랜치에 코드를 커밋하고 푸시하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고객님, `src` 폴더의 `components` 폴더 안에 있는 `Navbar.js` 파일을 수정해야 합니다.\n\n\"CRUD\" 텍스트를 \"CRUD test\"로 변경한 다음, 변경사항을 커밋하고 메인 브랜치에 푸시하세요.\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_11.png\" /\u003e\n\n빌드, 푸시, 그리고 배포하는 데 시간이 걸릴 수 있습니다. 나중에 앱 UI(http://bjtechlife.com)에 변경 사항이 표시되고 데이터를 삽입하는 것과 같이 제대로 작동하는 것을 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_12.png\" /\u003e\n\n와우! 😎🚀 여기에는 우리가 코드에서 변경한 \"CRUD 테스트\"가 나와 있네요.\n\n저희 앱 UI에서 서로 다른 변경을 계속해서 적용하면 변경 사항을 볼 수 있어요.\n\n결과적으로, GitHub Actions를 사용하여 Kubernetes(k3s)에서 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 완료했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🌟축하합니다!!🌟, 저희가 GitHub Actions 및 Ansible을 사용하여 Kubernetes에서 Terraform을 활용하여 MERN 앱을 위한 End-to-End CI/CD 파이프라인을 성공적으로 구축했습니다.\n\n✨이제 AWS에서 리소스를 제거할 시간입니다. 그러므로, Terraform 저장소 VS Code 편집기 터미널(/workspaces/terraform-ci-cd-aws/env/dev)로 돌아가서 다음을 실행해주세요:\n\n```js\nterraform login\nterraform init\nterraform destroy -auto-approve\n```\n\n이렇게 함으로써 저와 함께 오래 집중해 주셔서 감사합니다. 앞으로 또 다른 주제로 포스팅하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# K8s #쿠버네티스 #k3s #테라폼 #앤서블 #MERN #풀스택 #도커 #웹애플리케이션 #컨테이너화 #데브옵스 #컨테이너화된앱 #EC2 #MERN스택 #도커화된웹앱 #MERN앱 #도커컨테이너 #CI/CD 파이프라인 #GitHub 액션 #제로다운타임 #CI/CD #자동화 #배포 #기술팁\n\n만일 쿠버네티스에서 테라폼을 사용하여 GitHub 액션 및 앤서블을 이용해 MERN 앱을 위한 엔드 투 엔드 CI/CD 파이프라인을 구축하는 데 문제가 발생한다면 언제든지 저에게 연락해 주세요. 최선을 다해 도와드리겠습니다. 감사합니다.\n\n# 평문으로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 작가를 응원하고 팔로우를 눌러주세요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼도 방문해보세요: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지쳤나요? Differ를 시도해보세요\n- 더 많은 콘텐츠는 PlainEnglish.io에서 확인하세요\n","ogImage":{"url":"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png"},"coverImage":"/assets/img/2024-05-18-BuildanEnd-to-EndCICDPipelineforaMERNAppinKuberneteswithTerraformusingGitHubActionsAnsible_0.png","tag":["Tech"],"readingTime":19},{"title":"풀루미 대 테라폼 내 IaC 도구를 선택하는 완전 가이드","description":"","date":"2024-05-18 16:55","slug":"2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool","content":"\n![Pulumi vs Terraform](/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png)\n\n클라우드 네이티브 시대에는 인프라스트럭처 코드 (IaC)가 클라우드 인프라 관리의 표준이 되었습니다. Terraform은 거의 10년 동안 존재해왔고 경쟁사들이 출현하기 전까지 몇 년 동안 유일한 클라우드-비지니스 옵션이었습니다. 하지만 현재는 AWS CDK, CDK for Terraform과 상대적으로 새로운 Pulumi와 같이 다양한 선택지가 있습니다.\n\n하지만 더 많은 선택지가 있다는 것은 우리의 삶을 쉽게 만들어주지는 않습니다. 의사 결정 프로세스는 복잡할 수 있으며 모든 옵션을 조사하는 데 몇 일 또는 몇 주가 소요될 수 있습니다. 그러나 빠르게 변화하는 클라우드 네이티브/데브옵스 시대에는 그것만 하는 여유가 없는 사람들도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n걱정하지 마세요: 이 블로그에서는 Pulumi 대 Terraform을 깊이 파헤치고 (AWS CDK/CDK for Terraform의 메커니즘에도 약간 언급할 것입니다) 비교 차트, 의사 결정 트리, 팁 및 FAQ가 포함될 것입니다 (요약: 마지막 두 섹션으로 건너뛰세요) 작업에 적합한 올바른 도구를 선택하는 데 도움을 더할 것입니다.\n\n그럼, 더 이상 미루지 말고 지금 시작해 봅시다.\n\n# 1 Terraform\n\nIaC 도구에 대해 이야기하고 있으므로 Terraform을 무시할 수 없습니다. 가장 오래된 도구 중 하나입니다. 네, AWS CloudFormation과 같이 더 오랜 역사를 가진 클라우드별 솔루션이 있지만 클라우드에 독립적이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서, Pulumi에 대해 언급하기 전에 먼저 Terraform을 살펴보겠습니다.\n\n## 1.1 Terraform의 간단한 역사\n\n2014년 HashiCorp에 의해 처음으로 출시된 Terraform은 2016년과 2017년에 많은 관심을 얻기 시작했는데, 이 기간 동안 거의 모든 데브옵스 엔지니어들이 열정적으로 사용하거나 적어도 그에 대해 이야기했습니다.\n\n비록 2021년에 v1.0이라는 공식 버전이 출시되었지만, 특히 2017년부터 2019년 사이의 v0.11 및 v0.12와 같은 이전 버전들은 이미 다양한 비즈니스 분야의 기업들에 의해 크게 받아들여지고 개발 환경 뿐만 아니라 프로덕션 환경에서도 널리 사용되고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 모든 역사는 Terraform을 신뢰할 수 있다는 것을 의미합니다. 오랜 기간 실제 제품 환경에서 테스트되었으며, 그와 같이 입증된 성적표가 있는 Terraform으로는 다른 대안들을 시도할 시간이 없거나 귀찮아도 잘못 갈 수 없습니다.\n\n## 1.2 Terraform의 내부 작업 원리\n\nTerraform을 더 잘 이해하기 위해 (그리고 사실은 모든 IaC 도구에 대해), 다음으로는 Terraform이 어떻게 작동하는지 살펴봅시다: 코어-플러그인 아키텍처.\n\n간단히 말해, 코어는 상태 머신입니다. 현재 인프라 상태를 선언적 코드로 정의된 원하는 상태와 비교하여, 인프라를 선언 적으로 정의된 상태로 가져 오기 위해 해당 변경/작업을 수행 할 수 있도록 계획하게 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 변경 또는 작업은 플러그인(또는 프로바이더라고도 불리며, 이 문맥에서는 같은 것을 가리키는 다른 용어일 뿐입니다)에 의해 수행됩니다. 코어는 특정 상태에서 무엇을 해야 하는지 플러그인과 소통합니다.\n\n요약하면, 코어는 상태를 관리하고 플러그인은 작업을 수행합니다: 이것이 모든 IaC 도구가 동작하는 기본적인 방식입니다. 상태를 관리해야 하며, 클라우드 인프라를 운영하는 데 필요한 작업을 수행해야 합니다.\n\n테라폼에 대해 언급할 가치가 있는 몇 가지 추가 정보는 대부분의 플러그인이 Golang으로 구현된다는 점입니다 (물론 테라폼의 코어-플러그인 프레임워크를 통해 다른 프로그래밍 언어로 작성된 플러그인을 사용할 수 있게 됩니다). 따라서 실제 CRUD 작업을 수행하기 위해 플러그인은 클라우드 Go SDK가 필요합니다.\n\n이 세부 정보가 약간 복잡해 보인다면 걱정하지 마세요. 우리는 테라폼 사용자이니까 (개발자/기여자가 아니라), 플러그인 구현에 대해 고민할 필요가 없습니다. 또한 우리는 Go 코드를 작성하는 게 아니라 HCL만 작성합니다. 우리는 HCL로 인프라를 정의하는데, 실제로 테라폼은 이를 구현하기 위해 Go 플러그인을 호출하도록 어떤 변환을 수행하고, 이 플러그인은 다시 클라우드 Go SDK를 사용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1.3 Terraform HCL\n\n테라폼에서 인프라를 정의하는 것은 간단합니다. 구성 언어로 HCL (HashiCorp Configuration Language)을 사용하여 인프라를 정의합니다.\n\nAWS에서 S3 버킷을 생성하는 HCL 예제를 살펴보겠습니다:\n\n```js\nresource \"aws_s3_bucket\" \"example\" {\n  bucket = \"my-tf-test-bucket\"\n\n  tags = {\n    Name        = \"My bucket\"\n    Environment = \"Dev\"\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 구문을 아시는 분이라면 위 문법은 너무 낯설지 않을 것입니다. HCL은 블록과 속성이라는 두 가지 개념을 중심으로 구축된 것이 분명하며, 위 예시에서:\n\n- 전체 리소스 ...은 리소스를 정의하는 블록으로, 첫 번째 키워드가 나타냅니다.\n- aws_s3_bucket은 리소스의 유형입니다. AWS 공급자 문서를 참조하여 모든 지원되는 AWS 리소스 목록을 얻을 수 있습니다.\n- 예시 부분은 리소스의 이름입니다.\n- 블록 내에서 키-값 쌍은 해당 리소스의 속성 또는 인수입니다. 다시 한번, 공급자의 문서를 참조하여 지원되는 인수가 무엇인지, 필수적인지 등을 알아내야 합니다.\n\nHCL에 대한 학습 곡선이 존재하지만, 다른 프로그래밍 언어를 배우는 것만큼 가파르지는 않습니다. 왜냐하면 HCL은 실제 프로그래밍 언어가 아니라 구성 목적으로 사용되기 때문입니다. 이것은 당신의 철학적 성향에 따라 장단점이 될 수 있습니다:\n\n- 한편으로, HCL이 실제 프로그래밍 언어가 아니라 단순한 구성 언어이기 때문에 많은 이점이 있습니다: 기본적으로 키-값 쌍으로, 매우 사람이 읽기 편하고 쉽습니다.\n- 다른 한편으로, 단순성 때문에 반복문이나 분기와 같이 복잡한 작업을 쉽게 수행할 수 없습니다(특별한 구문을 사용하여 이를 구현할 수 있지만, 이는 파이썬과 같은 실제 프로그래밍 언어에서 `for ...` 또는 `if/else`를 작성하는 것만큼 간단하지는 않습니다).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서 IaC 도구로서, Terraform은 다소 중간 정도의 학습 곡선과 제한 사항을 갖고 있습니다 (HCL 때문에 두 가지로 인해: 이를 배워야 하며, 이를 사용하여 인프라를 정의해야 합니다). 이러한 상황을 개선하기 위해 많은 다른 IaC 도구들이 등장했습니다. 계속해서 읽어보세요.\n\n# 2 Pulumi\n\n이전 섹션에서 언급했듯이, Terraform은 완벽하지 않습니다. 이 문제를 해결하기 위해 많은 도구들이 등장했는데, Pulumi는 그 중 가장 최근의 시도 중 하나입니다.\n\nPulumi가 무엇인가요? 간단히 말해, 이것은 Terraform과 마찬가지로 IaC 도구입니다. 그러나 Terraform이 특정 구문 (HCL)을 사용하는 반면, Pulumi는 거의 모든 프로그래밍 언어를 사용하여 인프라를 정의할 수 있게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그렇다고 하면 너무나 부정확하고 크게 과장된 발언일 것입니다만, 단 하나의 문장으로 Pulumi가 무엇인지 알고 싶은 초보자를 위해 말하자면: Pulumi는 Python/Go/Java/Node.js 등에서 Terraform과 같은 기능을 하는 것이라고 말할 수 있습니다.\n\n## 2.1 Pulumi의 간단한 역사\n\nPulumi는 2018년에 처음 오픈소스로 공개되었으며, 이는 그리 새로운 것으로 보이지는 않지만, 현재 버전인 v3는 이전 버전과 비교했을 때 몇 가지 중요한 변경 사항을 갖고 있습니다. 2021년에 릴리스되었으며, 그 이후로 이전에 비해 많은 사람들이 Pulumi를 주목하기 시작했습니다. (믿지 못한다면 Google Trend에 물어보세요.)\n\n오늘날에는 Terraform과 비교했을 때, Google 검색에서 Pulumi에 대한 관심은 훨씬 적습니다. Pulumi의 블로그에 따르면, 2023년에는 고객 수가 2,000명 미만이었는데, 이는 Terraform보다 수십 배 적은 수치입니다. (인터넷의 여러 데이터 소스로부터 도출된 정보에 따르면)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래서, 이것은 새로운 기술이고 널리 수용되지 않았습니다. 그럼에도 불구하고, Pulumi를 선택하는 이유는 무엇일까요? 그 이유는 바로 Pulumi의 가장 강력한 기능인 다국어 지원 때문입니다.\n\n## 2.2 Pulumi: 다국어 지원\n\nTerraform을 선택하면 HCL을 작성해야 합니다. 많은 사람들에게 이것은 부담일 수 있습니다.\n\n예를 들어, Go로 주로 프로그램을 작성하고 가끔 클라우드 인프라를 관리하는 백엔드 엔지니어들은 왜 Go로 인프라를 정의할 수 있는데 HCL을 배워야 할까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프론트엔드/풀스택 엔지니어들이 JavaScript/TypeScript로 주로 쓰는 경우도 동일합니다. 이미 사용 중인 기술에 HCL을 더하는 것은 부담이 될 뿐만 아니라 기술 스택의 복잡성을 증가시킵니다. 기술 스택에 관해서는 대개 더 작을수록 더 나은 경우가 많습니다.\n\nPulumi에서는 다음 언어로 인프라를 정의할 수 있습니다:\n\n- TypeScript (Node.js)\n- Python\n- C#, VB, F# (.NET)\n- Go\n- Java\n- YAML\n\n예를 들어, 이전 섹션에서 언급된 것과 정확히 동일한 AWS S3 버킷을 Pulumi와 Python을 사용하여 생성하려면 간단히 다음과 같이 작성하면 됩니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport pulumi\nimport pulumi_aws as aws\n\nbucket = aws.s3.Bucket(\"bucket\",\n    acl=\"private\",\n    tags={\n        \"Environment\": \"Dev\",\n        \"Name\": \"My bucket\",\n    })\n```\n\n아니면 파이썬이 어울리지 않는다면 TypeScript로 작성해 보고 싶을 수도 있어요:\n\n```js\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst bucket = new aws.s3.Bucket(\"bucket\", {\n  acl: \"private\",\n  tags: {\n    Environment: \"Dev\",\n    Name: \"My bucket\",\n  },\n});\n```\n\n재미있게 사용해보세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2.3 Pulumi의 내부 구조\n\n요약하자면, Pulumi는 Terraform과 마찬가지로 상기된 코어 플러그인 아키텍처를 가지고 작동합니다.\n\nTerraform과 마찬가지로 Pulumi도 내부적으로 클라우드 SDK 및 라이브러리를 사용합니다. Pulumi는 플러그인 자체가 여러 언어로 구현되어 있기 때문에 여러 언어를 지원합니다. 예를 들어, 여기서 Pulumi의 AWS 프로바이더를 살펴보면 다양한 언어로의 여러 구현체를 볼 수 있습니다. 이로 인해 파이썬으로 인프라를 정의할 때는 pulumi_aws를 aws로 가져오고, TypeScript로 한다면 Node.js용으로 완전히 다른 패키지인 “@pulumi/aws”를 사용합니다.\n\nAWS Cloud Development Kit (AWS CDK) 및 Terraform용 CDK (CDKTF)와 같이 많은 언어로 인프라 코드를 정의할 수 있는 다른 옵션이 있음을 언급할 가치가 있습니다. 그러나 기본적으로 AWS CDK와 CDKTF는 다른 방법으로 다중 언어 지원을 구현합니다: AWS CDK와 CDKTF는 JavaScript 클래스와 자연스럽게 상호 작용할 수 있도록 어떤 언어의 코드든 JavaScript 클래스와 상호 작용할 수 있게 하는 라이브러리 jsii에 의존합니다. 따라서 AWS CDK (CDKTF도 마찬가지)는 TypeScript 코드를 다양한 언어로 변환하여 다중 언어를 지원하는 데 jsii를 사용하지만, Pulumi는 그저 여러 언어로 작성된 프로바이더만을 가지고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 3 Pulumi vs. Terraform: 주요 유사점과 차이점\n\n## 3.1 Pulumi와 Terraform의 주요 유사점\n\n가장 큰 유사점은 작동 방식인 코어 플러그인 아키텍처입니다.\n\n먼저, 코어입니다. 혹은 다른 말로 표현하면, 실제로는 상태입니다. 둘 다 현재 인프라 및 코드로 정의된 내용을 기반으로 상태를 유지하기 위해 코어를 사용하여 계산할 수 있도록 하여 인프라를 정의된 상태로 가져오기 위한 작업 계획을 생성할 수 있습니다. 그리고 둘 다 상태를 로컬, S3 버킷, 또는 클라우드/SaaS 솔루션에 저장할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 번째로는 플러그인입니다. 이전에도 언급했듯이, 두 툴 모두 상태를 관리하고 변경을 수행하기 위해 핵심 플러그인 아키텍처를 사용합니다.\n\n## 3.2 Pulumi와 Terraform의 주요 차이점\n\n가장 큰 차이는 물론, 멀티 언어 지원입니다.\n\nTerraform은 HCL을 사용하는데, 이것은 완전한 프로그래밍 언어가 아니라 구성 언어에 불과합니다. 그러므로 본질적으로 다른 프로그래밍 언어만큼 많은 작업을 수행할 수 없습니다. 하지만 이전에 언급했듯이, 이것은 당신에게 좋은 점일 수 있는데, 읽기 쉽고 단순한 게 더 나을 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPulumi는 다양한 언어를 지원하며 이겪엔 가장 중요한 차이점 중 하나입니다. 어떤 이유로든 Python/Go/Java 또는 기타 주요 프로그래밍 언어로 인프라를 정의해야 하는 경우, Terraform와 Pulumi 사이에는 경쟁이 없습니다.\n\n언급할 가치가 있는 또 다른 차이점은 Pulumi를 사용하여 인프라 코드의 테스트 가능성입니다. Pulumi를 사용하면 프로그래밍 언어와 함께 제공되는 단위 테스트 및 기능 테스트와 도구의 이점을 누릴 수 있습니다. Terraform에서는 주로 통합 테스트로 수행할 수 있는 테스트 방법이 제한됩니다.\n\n물론 Terraform과 Pulumi 사이에는 다수의 세부적인 기능 차이가 있습니다 (놀랍게도 Pulumi 공식 문서에서는 한 둘보다 훨씬 많은 차이점을 찾을 수 있습니다). 그러나 어느 것도 실질적인 결정 요인이 되지는 않습니다. 예를 들어, 오픈 소스 라이선스나 상태의 기본 구성이 어디에 있는지는 아마도 귀하의 목록 상단에 있는 것이 아닐 것입니다.\n\n# Pulumi에 관한 4가지 오해\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 여러분이 이 블로그를 읽고 계시다면, 이겢이 Pulumi 대 Terraform에 관한 첫 번째 기사가 아닐 것입니다; 아마도 여러분은 상당한 조사를 하고 각각의 장단점을 많이 읽은 것 같습니다.\n\n하지만, 다른 많은 기사들에서 Pulumi에 대해 Terraform과 비교했을 때 가장 흔히 언급되는 몇 가지 단점은 사실 오해이며 더는 사실이 아닙니다. 저는 그것들을 다루어서 Pulumi에 대한 공정하고 정확한 견해를 얻을 수 있도록 하고자 합니다. 그것은 중요하기 때문에 별도의 장으로 다루어져야 한다고 생각합니다.\n\n## 4.1 오해 1: Pulumi 문서 부족\n\n이젠 사실이 아닙니다(시작했을 때는 그랬을지도 모릅니다).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPulumi는 설치 방법부터 시작하는 방법까지 매우 상세하고 단계별 설명서를 제공합니다. 더 깊이 알고 싶다면, Pulumi의 핵심 개념에 대한 훌륭한 섹션이 있습니다. 게다가 Pulumi에는 다수의 클라우드 제공업체에 대한 상세한 설명서와 예제가 있습니다.\n\n플러그인/제공자에 대해 특정 제공자(예: AWS) 또는 PagerDuty Pulumi 제공자와 같이 덜 인기 있는 제공자를 검색하고, Terraform의 문서와 비교해 보면 \"Pulumi 문서가 부족하다\"는 결론에 도달하지 않을 것입니다. 왜냐하면 사실이 아니기 때문이죠.\n\n## 4.2 오해 2: Pulumi 커뮤니티가 작다.\n\n이제 더 이상 사실이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n풀루미의 공식 블로그에 따르면, 이 회사는 2000명의 고객과 15만 명의 최종 사용자를 보유하고 있습니다. GitHub에 따르면, 주요 저장소 pulumi/pulumi만으로도 18.8k개 이상의 스타를 받았으며, 1.9k개의 이슈와 184개의 오픈된 풀 리퀘스트가 있습니다.\n\n어떤 지표를 보더라도, 커뮤니티 규모를 측정하는 기준에 상관없이 풀루미의 커뮤니티는 분명히 거대합니다. 테라폼보다는 작을 수 있지만, 절대적으로 말해 그 커뮤니티는 작다고 할 수 없습니다.\n\n## 4.3 오해 3: Pulumi는 모든 환경에 적합하지 않다\n\n다시 한 번, 이는 사실이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n많은 사람들이 Pulumi가 더 최근에 나왔기 때문에 모든 분야에 적용되지 않는다고 결론 지을 것으로 생각할 수 있지만, 실제로는 그렇지 않습니다.\n\n프로그래밍 언어에 대해 이야기할 때, Pulumi는 사실 대부분의 주요 언어를 지원합니다.\n\n플러그인 및 프로바이더에 대해 이야기할 때, 새로운 도구가 존재 기간이 짧다는 이유로 플러그인이 적을 것으로 생각할 수 있지만, 현실은 그렇지 않습니다. Pulumi는 모든 주요 퍼블릭 클라우드 프로바이더를 지원합니다. 게다가, 클라우드 이외의 인프라(예: 특정 소프트웨어에서 팀 및 사용자 관리)를 관리할 때도 Terraform과 비슷한 범위를 갖추고 있습니다.\n\n예를 들어, 대기업에서 GitHub, PagerDuty, DataDog, Sentry 등을 관리하는 여러 개의 데브옵스 도구가 있을 수 있습니다. 아마도 이러한 도구들의 사용자/팀/권한을 IaC로 관리하고 싶을 수도 있습니다. 이 경우, 이 도구들의 플러그인을 검색하면 Pulumi가 모두 갖추고 있다는 놀라운 사실을 알게 될 것입니다. 이러한 플러그인은 널리 사용되지 않는 클라우드 관련 플러그인이더라도 Terraform과 마찬가지로 모두 지원합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n말씀하신 대로, Pulumi/Terraform을 객관적으로 평가하고, \"문서가 부족하다\" 또는 \"커뮤니티가 작다\"는 어딘가에서 읽은 이유만으로 Pulumi를 부정적으로 평가하지 말고, 심지어 \"최신 버전은 보편성이 낮다\"고 생각하지 말아주셨으면 좋겠습니다.\n\n## 5. Pulumi 대 Terraform: 실제로 살펴보기\n\n이전 절에서는 Terraform과 Pulumi의 구문과 사용법을 설명하기 위해 코드 조각들을 제공했지만, 이들은 실세계에서 의미 있는 것을 나타내기에는 너무 간단하고 \"Hello World\" 수준이었습니다. 실세계에서는 일반적으로 사물이 기하급수적으로 커지기 때문에 코드를 간단하고 가독성 있게 유지하고 동시에 확장 가능하게 유지하는 것이 어렵습니다.\n\n다음으로, Pulumi 대 Terraform을 살펴보고 이들이 이러한 실제 문제에 대처하는 방식을 비교해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 5.1 Pulumi 대비 Terraform: 코드 구조, 가독성 및 확장성\n\nTerraform에서는 모듈을 정의하고 재사용하여 최대 코드 재사용성을 달성할 수 있습니다. 전형적인 단일식 Terraform 저장소는 다음과 같이 보일 수 있습니다:\n\n```js\n.\n├── dev\n│   ├── config.tf\n│   ├── main.tf\n│   ├── output.tf\n│   └── variables.tf\n├── modules\n│   ├── module_a\n│   └── module_b\n└── prod\n    ├── config.tf\n    ├── main.tf\n    ├── output.tf\n    └── variables.tf\n```\n\n단일 저장소에는 강점이 있습니다. 매우 사람이 읽기 쉽고 설명 없이 쉽게 이해할 수 있습니다. 그리고 Terraform의 특성 상, 디렉토리 구조가 두 단계 또는 최대 세 단계로 설정될 수 있어 한눈에 쉽게 파악하고 관리하기 쉽습니다. 또한, 또 다른 환경을 만드는 것은 기존 저장소에 \"test\"라는 폴더를 추가하는 것만큼 복잡하지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 깔끔한 코드 기반을 기준으로 프로젝트가 커질 때 여러 가지 개선 방법이 있습니다. 인프라의 다른 부분들을 서로 다른 저장소로 분리하거나 모듈들을 다른 저장소 하나 또는 몇 개로 이동하거나 서로 다른 환경을 다른 저장소로 이동할 수 있습니다. 모든 선택 사항은 유연하며 모두 새로운 저장소를 만들어 깔끔하고 이해하기 쉬운 디렉토리 구조를 유지합니다.\n\nPulumi를 사용하면 상황이 약간 복잡해질 수 있습니다. 전형적인 단일체 Pulumi 프로젝트는 다음과 같이 보일 수 있습니다:\n\n```js\n.\n├── Pulumi.dev.yml\n├── Pulumi.prod.yml\n├── Pulumi.yml\n├── api-gateway\n│   ├── index.ts\n│   └── micro-service-01\n│       └── index.ts\n├── database\n│   └── table-01.ts\n├── index.ts\n├── package-lock.json\n├── package.json\n├── sns\n│   └── topics.ts\n└── queues.ts\n├── pkg\n│   └──application\n│     └── app.go\n└── .etc\n```\n\nTerraform과 마찬가지로 일반적인 내용을 패키지로 만들어 프론트엔드 또는 백엔드 프로젝트에서 작업한 것과 같이 처리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로젝트가 커질수록, 프로젝트를 별도로 관리되는 더 작은 프로젝트로 분할하는 마이크로-스택스 접근 방식을 사용할 수 있습니다. 그리고 각 프로젝트는 위에서 설명한 것과 같을 수 있습니다.\n\n그러나 프로젝트가 커지면 디렉토리 구조가 더 복잡해지고 많은 디렉토리와 수준이 더 많아져 혼란스러울 수 있습니다. Java나 혹은 지금까지 경험했던 실제 프로젝트를 상상해보세요. 그 프로젝트 전체를 빠르게 이해하기 쉬운가요? 아니요, 많은 폴더와 디렉토리 수준이 많아서 무엇이 무엇인지 심지어 어디서 시작해야 하는지도 모를 정도입니다.\n\nPulumi의 가장 강력한 장점은 다국어 지원이지만, 큰 힘은 큰 책임을 수반합니다. 코드를 이해하고 유지 관리하기 쉽게 구성하는 것이 중요하며, 이는 사용하는 도구에 상관 없이 사실입니다.\n\n## 5.2 Pulumi 대 Terraform: 통합\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대부분의 경우, IaC가 단순히 IaC를 수행하고 끝나는 것이 아닙니다. 인프라 부분은 CI/CD 파이프라인과 같은 다른 요소들과 통합되어야 합니다. 다행히, Terraform과 Pulumi는 변경 사항을 배포하는 데 하나의 명령만 필요하므로 이들은 통합하기에 이상적입니다. 그러나 차이점도 있습니다.\n\n경우에 따라 IaC 파이프라인이 시작되기 전에 뭔가를 수행하고 싶을 수 있습니다.\n\n예를 들어, 사용자, 팀, 멤버십, 권한을 관리하기 위해 IaC를 사용하고 싶다고 가정해 봅시다. 새로운 사용자를 추가할 때, 코드베이스를 열어서 복사하여 수정하고 커밋하는 것은 번거로울 수 있습니다. 사용자 목록을 어딘가에 저장해두고, 그 파일을 검색하여 일부 템플릿 도구를 사용하여 IaC 코드를 자동으로 생성할 수 있습니다.\n\n이 경우, Terraform의 경우 추가 도구(예: 일부 Python 스크립트)에 의존해야 할 수도 있습니다. 파일을 다운로드하고 구문 분석하고 템플릿을 사용하여 생성된 IaC 파일을 커밋한 다음 IaC 파이프라인을 실행하기 전에 모든 작업을 수행해야 할 수 있습니다. Pulumi의 경우, 모든 것을 한 번에 처리할 수 있어서 훨씬 간단할 수 있습니다. 사용할 수 있는 프로그래밍 언어를 사용하여 파일을 다운로드/구문 분석하고, 동일한 언어를 사용하여 for 루프를 통해 간단히 작업을 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다른 경우에는 IaC가 끝난 후에 무언가를 수행하고 싶을 수 있습니다. 예를 들어, IaC 부분의 출력에 사용하려는 로드 밸런서 URL이 포함되어 있을 수 있습니다. Terraform의 경우 다시 다른 스크립트를 실행해야 할 수도 있지만, Pulumi를 사용하면 IaC 코드 이후에도 그대로 진행하여 이를 수행할 수 있습니다.\n\n간략히 말하면, Terraform과 스크립트를 통합하는 데 어려움을 겪는 경우에는 Pulumi를 사용해 보는 것이 좋을 것입니다.\n\n## 5.3 Pulumi 대 Terraform: 보안\n\n보안은 항상 코드에 중요한 주제이며, 인프라 코드 역시 코드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코드 보안을 위한 가장 기본적인 원칙은 아마도 코드에 비밀을 평문으로 저장하지 않는 것입니다. 이 부분에서 Terraform과 Pulumi는 모두 잘 작동합니다. Terraform은 다양한 시크릿 매니저와 통합될 수 있으며, Pulumi에서는 시크릿 매니저에서 한 줄의 코드로 읽는 것도 쉽습니다. 예를 들어, Terraform에서 시크릿을 관리하는 블로그가 있습니다.\n\n코드 보안에 대해 더 말씀드릴 수 있습니다: Terraform으로 HCL을 작성하면 구성 코드가 생성, 읽기, 업데이트 및 삭제 리소스에 대한 API 호출로 변환됩니다. 물론, Terraform 코어와 플러그인 자체에도 보안 문제와 CVE가 발생할 수 있지만, 다른 IaC 옵션에 대해서도 동일하게 말할 수 있습니다. Pulumi의 경우, IaC 코드를 여러 언어로 작성하고 훨씬 더 많은 작업을 수행할 수 있기 때문에 공격 표면이 증가할 수 있습니다. 이는 Pulumi의 단점으로 보일 수 있지만, 다행히도 인프라 코드를 스캔하는 데 사용되는 최선의 방법과 도구 (SAST 및 DAST와 같은)가 있어서 보안을 강화할 수 있습니다.\n\nTerraform 및 IaC 보안에 관심이 있다면, Terraform을 사용한 IaC 보안에 대한 블로그와 Terraform의 몇 가지 모베스트 프랙티스에 관한 블로그를 읽어보세요 (걱정하지 마세요, 이전에 읽은 것과는 달라요).\n\n코드 보안을 떠나서, IaC 도구는 인프라를 관리하고 중요한 정보가 실제로 상태에 저장되기 때문에 상태의 보안도 중요합니다. Terraform과 Pulumi는 민감한 정보를 상태에 평문으로 출력되지 않도록 암호화할 수 있습니다. 그리고 두 도구 모두 암호화된 상태를 저장하기 위한 다양한 백엔드를 지원합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션을 마무리하기 위한 몇 가지 권장 사항:\n\n- IaC 툴을 사용하여 민감한 데이터를 관리하는 경우(데이터베이스 비밀번호, 사용자 비밀번호 또는 개인 키와 같은), 상태 자체를 민감한 데이터로 처리해야 합니다. 즉:\n- 상태를 원격으로 저장하면 더 나은 보안을 제공할 수 있으며 상태에 로컬 디스크를 사용하지 않도록합니다.\n- 쉽히 상태 데이터를 암호화할 수 있는 백엔드를 사용하세요.\n\n# 6 Summary: Choosing Your IaC Tool\n\n## 6.1 Comparison Table\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 작업을 쉽게 하기 위해 두 가지 주요 기능을 빠르게 비교할 수 있는 다음 표를 보겠습니다:\n\n![Comparison Table](/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_1.png)\n\n## 6.2 IaC 도구 선택\n\n더 재미있게 하기 위해, 다음 플로 차트를 만들어 여러분이 적합한 도구를 선택하는 데 도움이 되도록 하겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 6.3 작업에 적합한 도구 선택하기\n\n재미있는 이야기는 떠나고, 작업에 적합한 도구를 선택하는 몇 가지 팁을 제공해 드리겠습니다:\n\n- 여전히 앱 코드를 작성하는 것이 본업이고 인프라 코드를 관리하는 것이 부분적인 업무라면, Pulumi가 더 나은 선택이 될 수도 있습니다.\n- 만약 Terraform에 경험이 있고 불만족스럽다면, 의문없이 Pulumi를 시도해 보세요. Terraform으로는 할 수 있는 중요한 일을 Pulumi로 할 수 없는 것은 없습니다.\n- 모든 것을 지배할 도구를 선택할 필요는 없습니다. Pulumi 대 Terraform은 싸움이 아니며, 어떤 것이 더 나은지, 무엇이 틀린지를 결정해야 하는 것도 아닙니다. 사실 둘 다 사용할 수 있습니다. 프로젝트가 확장될수록 단일 인프라 저장소를 관리하는 것은 어려워지며, 마이크로서비스 스타일의 인프라 프로젝트를 가지고 있다면, 각 부분에 맞는 올바른 도구를 사용하여 최선의 선택을 할 수 있습니다. 올바른 도구를 선택하면 특정 작업을 더 쉽게 처리할 수 있습니다.\n- 직접 체험해 보세요. 블로그와 기사를 읽어도 괜찮지만, 결과적으로 두 도구를 짧게 체험하면 마음이 원하는 것을 알 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 자주 묻는 질문\n\n## Q: Terraform은 오래된 기술인가요?\n\n네, 그렇습니다.\n\n네, Terraform은 많은 해동안 사용되어 왔습니다. 그러나 약간의 한계도 갖고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나, HCL을 사용해야 한다는 점을 제외하고는, Terraform은 거의 모든 것을 다 다루며, 그것들을 잘 처리합니다.\n\nTerraform은 다른 프로그래밍 언어로 인프라를 정의할 수 있는 CDKTF를 지원한다는 점을 언급할 가치가 있습니다.\n\n## 질문: Pulumi가 Terraform보다 나은가요?\n\n예와 아니요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네, 다른 프로그래밍 언어를 선택하여 인프라를 정의할 수도 있습니다.\n\n하지만, 완전한 프로그래밍 언어로 큰 프로젝트를 개발하면 간단한 구성 언어보다 이해하기 어렵고 읽기 어려울 수 있습니다.\n\n각 도구는 강점을 가지고 있으며 누가 더 좋은지는 말할 수 없습니다.\n\n## Q: Pulumi가 Terraform이 할 수 있는 모든 것을 할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네.\n\n음, 그렇게 말해도 될 것 같아요. 두 도구 모두 각자의 독특한 점과 기능을 갖고 있지만, IaC에 관한 기본적인 기능은 두 도구 모두 갖추고 있어요. 만약 Pulumi를 선택하고 나중에 Terraform이 훌륭히 수행하는 몇 가지 마법 같은 기능을 Pulumi가 수행하지 못한다고 알게 되더라도, 불편한 상황에 처할 일은 없을 거에요.\n\n## 질문: Pulumi의 단점은 무엇인가요?\n\n정말 없어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n잘하는 것은 그것이 하는 일을 아주 잘하고, 사용하는 프로그래밍 언어를 선택하여 할 수 있어요. 게다가 문서와 커뮤니티 모두 좋아요.\n\nPulumi를 조금 더 세밀하게 살펴보자면, Python, Go 또는 JavaScript로 만든 큰 코드베이스를 관리하기가 HCL 구성 파일 저장소보다 어려울 수 있어요. 하지만 이는 Pulumi가 이 난관을 가져온 것이 아니라 프로그래밍 부분 때문이에요. 게다가 HCL을 사용한다고 해서 코드베이스가 자동으로 더 읽기 쉬워지거나 관리가 쉬워지는 것은 아니에요: 분명히 엉망으로 만들 수 있어요. 결국, 깔끔한 코드를 작성하고 유지하는 것은 프로그래머들의 몫이에요.\n","ogImage":{"url":"/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png"},"coverImage":"/assets/img/2024-05-18-PulumiVSTerraformTheDefinitiveGuidetoChoosingYourIaCTool_0.png","tag":["Tech"],"readingTime":25},{"title":"AWS Lake Formation에서 데이터 필터를 사용하여 Terraform을 통해 여러 계정 간 액세스 활성화하기","description":"","date":"2024-05-18 16:54","slug":"2024-05-18-EnablingCross-AccountAccessforAWSLakeFormationwithDataFiltersUsingTerraform","content":"\n# 소개\n\n이전 블로그에서는 AWS Lake Formation과 Terraform을 사용하여 다른 계정 간 데이터 공유를 활성화하는 방법을 탐험했습니다. 이번 포스트에서는 데이터 필터를 사용하여 해당 설정을 더욱 향상시키는 방법에 대해 더 깊이 파고들어보겠습니다. Lake Formation 데이터 필터링을 통해 열 수준, 행 수준 및 셀 수준 보안을 구현할 수 있습니다. 이 블로그에서는 특히 셀 수준 보안을 구현하여 데이터 접근 제어를 미세 조정하는 데 중점을 둘 것입니다.\n\n![이미지](/assets/img/2024-05-18-EnablingCross-AccountAccessforAWSLakeFormationwithDataFiltersUsingTerraform_0.png)\n\n## 데이터 필터 수준\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 열 수준\n\n열 수준 필터링을 사용하여 데이터 카탈로그 테이블에 대한 권한을 부여하면 사용자가 액세스 권한이 있는 특정 열 및 중첩 열만 볼 수 있습니다. 이를 통해 중첩된 열의 부분 하위 구조에 액세스 권한을 부여하는 보안 정책을 정의할 수 있습니다.\n\n- 행 수준\n\n행 수준 필터링을 사용하여 데이터 카탈로그 테이블에 대한 권한을 부여하면 사용자가 액세스 권한이 있는 데이터의 특정 행만 볼 수 있습니다. 필터링은 하나 이상의 열 값에 기반하며, 중첩 열 구조도 행 필터 식에 포함할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 셀 수준\n\n셀 수준 보안은 행 및 열 필터링을 결합하여 매우 유연한 권한 모델을 제공합니다.\n\n# 소스 계정에 데이터 필터 만들기\n\n이미 이전 블로그에서 자세히 설명한 Source Account에서 Lake Formation 설정을 완료했다고 가정하면, 이제 데이터 필터를 만드는 작업을 진행할 수 있습니다. IIoT 측정을 사용한 예제를 사용해보겠습니다. 여러 사이트에 퍼져있는 장비가 있고 특정 IAM 역할에 특정 사이트 및 열 액세스를 부여해야 하는 경우를 가정해보겠습니다. 이를 Terraform을 사용하여 어떻게 구현할지 알아보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 예시에서:\n\n- 로컬 구성 정의: filter_config 변수는 액세스가 필요한 사이트, 열 및 IAM 역할을 나열합니다.\n- AWS 계정 ID 검색: aws_caller_identity 데이터 원본은 현재 AWS 계정 ID를 가져옵니다.\n- 데이터 셀 필터 생성: aws_lakeformation_data_cells_filter 자원은 filter_config를 반복하여 각 IAM 역할에 필요한 필터를 생성합니다.\n\n이 설정을 통해 특정 IAM 역할이 정의된 사이트 및 열에만 액세스할 수 있도록 하여 보안과 데이터 관리를 강화할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 대상 계정과 공유 카탈로그\n\n이제 데이터 필터를 생성했으니, 카탈로그를 공유하는 동안 활용해봅시다. 아래 코드 스니펫에서는 데이터베이스와 테이블을 대상 계정과 공유할 것입니다. 테이블을 공유할 때는 이전 단계에서 생성한 데이터 필터를 함께 포함할 것입니다.\n\n![이미지](/assets/img/2024-05-18-EnablingCross-AccountAccessforAWSLakeFormationwithDataFiltersUsingTerraform_2.png)\n\n이 스니펫에서는:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터베이스 권한 공유: aws_lakeformation_permissions 리소스는 IIoTDataLake 데이터베이스를 대상 계정과 공유하여 DESCRIBE 권한을 부여합니다.\n- 테이블 권한 공유: 비슷하게, 해당 리소스는 측정 테이블을 대상 계정과 공유하며 SELECT 권한을 부여합니다. 이전에 생성한 데이터 필터도 포함되어 대상 계정이 정의된 기준에 따라 필터링된 데이터에만 액세스할 수 있도록 보장합니다.\n\n이 설정을 통해 카탈로그에서 대상 계정과 특정 데이터를 안전하게 공유하여 규정 준수 및 데이터 무결성을 보장할 수 있습니다.\n\n# 대상 계정에서 액세스용 리소스 링크 생성\n\n대상 계정에 카탈로그와 테이블을 데이터 필터와 함께 공유한 후, 공유된 카탈로그 데이터에 액세스하기 위해 대상 계정으로 이동하여 리소스 링크를 설정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](/assets/img/2024-05-18-EnablingCross-AccountAccessforAWSLakeFormationwithDataFiltersUsingTerraform_3.png)\n\nIn this setup:\n\n- **Retrieve Source Account ID:** The `aws_caller_identity` data source fetches the AWS account ID of the source account.\n- **Create Resource Link:** The `aws_glue_catalog_database` resource establishes a database resource link named `IIoTDataLake-Target` in the target account. It links to the `IIoTDataLake` database in the source account, enabling access to the shared catalog data.\n\nBy creating this resource link, you enable seamless access to the shared data catalog from the target account, facilitating data utilization and analysis across accounts while maintaining security and compliance measures.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# IAM 역할에 권한 부여\n\n이제 우리가 리소스 링크를 생성했으니, 리소스 링크 및 공유 카탈로그에 액세스를 부여할 수 있습니다. 이 단계 이후에 IAM 역할은 소스 계정에서 공유된 필터링된 데이터에 액세스할 수 있게 될 것입니다.\n\n![Image](/assets/img/2024-05-18-EnablingCross-AccountAccessforAWSLakeFormationwithDataFiltersUsingTerraform_4.png)\n\n이 구성에서:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터베이스 권한 부여: aws_lakeformation_permissions 리소스는 IIoTDataLake-Target 데이터베이스의 IAM 역할에 DESCRIBE 권한을 부여합니다. 이를 통해 역할은 데이터베이스 구조와 메타데이터를 설명할 수 있습니다.\n- 테이블 권한 부여: 마찬가지로, 해당 리소스는 공유 카탈로그의 measurements 테이블에 대한 SELECT 권한을 IAM 역할에 부여합니다. 이를 통해 역할은 테이블에서 데이터를 선택하고 읽을 수 있습니다.\n\n이러한 권한이 부여된 상태에서 IAM 역할은 이제 소스 계정에서 공유된 필터링된 데이터에 액세스할 수 있어 타겟 계정 내에서 매끄러운 데이터 분석과 활용이 가능해졌습니다.\n\n# 결론\n\n이 블로그에서는 AWS Lake Formation과 Terraform을 사용하여 계정간 데이터 공유의 복잡성에 대해 살펴보았습니다. 데이터 필터를 구현하고 리소스 링크를 설정함으로써, 공유 데이터에 안전한 액세스를 보장하면서 권한을 세밀하게 제어할 수 있었습니다. 이러한 간소화된 접근 방식은 계정간 협업적인 데이터 분석을 용이하게하며, 팀이 효과적으로 통찰력을 얻을 수 있도록 도와주면서 데이터 보안 및 규정 준수 기준을 유지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고 자료\n\n데이터 필터링 및 셀 레벨 보안 - AWS Lake Formation (amazon.com)\n","ogImage":{"url":"/assets/img/2024-05-18-EnablingCross-AccountAccessforAWSLakeFormationwithDataFiltersUsingTerraform_0.png"},"coverImage":"/assets/img/2024-05-18-EnablingCross-AccountAccessforAWSLakeFormationwithDataFiltersUsingTerraform_0.png","tag":["Tech"],"readingTime":7},{"title":"GKE  Gemma  Ollama 유연한 LLM 배포를 위한 파워 트리오 ","description":"","date":"2024-05-18 16:52","slug":"2024-05-18-GKEGemmaOllamaThePowerTrioforFlexibleLLMDeployment","content":"\n오늘은 구글 젬마를 중점으로 다양한 LLM 배포의 복잡성을 탐색하겠습니다. 선택한 플랫폼은 Ollama 프레임워크로부터 가치 있는 지원을 받는 GKE일 것입니다. 이 이정표를 달성하기 위한 여정은 Open WebUI에 의해 용이하게 이끌어질 것입니다. 이는 원래 OpenAI ChatGPT 프롬프트 인터페이스와 놀라운 유사성을 가지고 있어 사용자 경험을 원활하고 직관적으로 만들어줍니다.\n\n세부적인 내용에 대해 들어가기 전에, 가장 중요한 부분에 대해 이야기해 봅시다. 왜 먼저 이 방향으로 나아가는 것일까요? 제게는 이 이유가 명백하게 보이며, 여러 가지 강력한 요소로 요약될 수 있습니다:\n\n- 비용 효율성: 공개 클라우드 인프라에서 LLM을 운영할 경우, 특히 예산 제약으로 집중적인 작은 조직이나 연구 기관에게 더 경제적인 솔루션을 제공할 수 있습니다. 그러나 Vertex AI Studio 및 OpenAI Developer Platform과 같은 플랫폼이 이미 경제적이고 완전히 플래시된 관리 서비스를 제공한다는 조건부 혜택을 강조하는 것이 중요합니다. 또한 Vertex AI는 모델의 수명 주기와 가시성을 관리할 것입니다. 이를 염두에 두세요.\n- 맞춤화와 유연성: Ollama는 맞춤화, 유연성 및 오픈 소스 원칙을 핵심으로 만들어졌습니다. 클라우드 제공 업체의 모델 레지스트리를 통해 사용 가능한 포괄적인 모델 옵션에도 불구하고, 원하는 특정 모델이 즉시 사용 가능하지 않은 시나리오가 발생할 수 있습니다. 이때 Ollama가 해결책을 제공합니다.\n- 환경 간 이식성: Ollama의 디자인은 클라우드 및 플랫폼에 중립적이며, Docker를 수용하는 모든 공개 또는 개인 플랫폼에 배포할 자유를 제공합니다. 이는 Vertex AI 및 SageMaker와 같은 강력한 솔루션과 대조적입니다. 이 솔루션들은 그들 각자의 클라우드 환경과 결합되어 있습니다. Docker와 Kubernetes가 시장 전체를 섭렵한 이유가 있습니다. 이것은 x86에 대해서도 마찬가지입니다.\n- 개인 정보 보호 및 데이터 제어: 완전히 오픈 소스 모델인 LLaVA 및 젬마 같은 것을 활용하려는 사람들을 위해 완전히 개인적인 프레임워크 내에서 데이터 개인 정보 보호와 배포 환경에 대한 완전한 제어를 보장할 수 있는 최적의 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## GKE 플랫폼\n\n이 실험에서 나의 GKE 플랫폼 설정은 효율성과 성능을 우선시했습니다:\n\n- GKE 1.27 (정기 채널): 호환성 및 최신 구글 쿠버네티스 엔진 기능에 대한 액세스를 보장합니다.\n- Container-Optimized OS: 보다 빠른 워크로드 배포를 위해 노드 시작 시간을 줄입니다 (이전 글에서 자세히 읽을 수 있습니다).\n- g2-standard-4 노드 풀 (NVIDIA L4 GPU): GPU 및 CPU 리소스의 강력한 조합으로, 머신 러닝 작업에 이상적입니다. 벤치마크 결과가 장점을 보여줄 것입니다.\n- 관리되는 NVIDIA GPU 드라이버: GKE에 드라이버를 직접 통합하여 설정 프로세스를 간소화하며, 클러스터가 준비되면 즉시 사용할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNVIDIA의 L4 GPU는 원시 사양과 결과에서 강력한 처리 능력을 발휘하며, 계산 집중적인 ML 작업에 대한 강력한 처리 능력을 제공합니다:\n\n- 7680 Shader Processors, 240 TMUs, 80 ROPs, 60 RT cores, 240 Tensor Cores.\n- 24GB GDDR6 메모리, 300GB/s 대역폭.\n- 485 teraFLOPs (FP8 처리량).\n\nG2 Machine Series는 Intel Cascade Lake 기반의 플랫폼으로, GPU를 보완하고 그것에 충분한 처리를 제공하기 위한 탁월한 솔루션을 제공합니다.\n\nG2는 Spot VM을 지원합니다: 중지를 허용할 수 있는 ML 작업에 대해 대규모 비용 절감(약 67% 할인)을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 올라마 및 오픈 웹UI 배포하기 (이전 올라마 웹UI)\n\nK8s 생태계의 성숙함으로 인해 배포 프로세스가 간소화되었으며, 이제는 주로 helm install 및 kubectl apply 명령을 실행하는 문제입니다. 올라마의 경우, 배포는 GitHub에서 제공되는 커뮤니티 주도의 Helm Chart를 활용하며, 설정을 안내하는 표준 values.yaml 파일이 제공됩니다:\n\n```js\nollama:\n  gpu:\n    enabled: true\n    type: 'nvidia'\n    number: 1\n  models:\n    - gemma:7b\n    - llava:13b\n    - llama2:7b\npersistentVolume:\n  enabled: true\n  size: 100Gi\n  storageClass: \"premium-rwo\"\n```\n\n한편, Open WebUI를 배포하는 경우에는 공식 차트와 커뮤니티에서 제공하는 Kustomize 템플릿을 사용하여 이 구현에 더 적합한 접근방식을 제공합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nOpen WebUI은 Ollama 배포를 위한 매니페스트를 제공하지만, 저는 Helm Chart의 기능 풍부함을 선호했습니다. 배포 후에는 GCP 로드 밸런서의 IP 주소와 포트 8080으로 이동하여 Open WebUI 로그인 화면에 액세스할 수 있어야합니다.\n\n![이미지](/assets/img/2024-05-18-GKEGemmaOllamaThePowerTrioforFlexibleLLMDeployment_1.png)\n\nollama 네임스페이스에서 간단한 확인 작업을 수행하면 모든 시스템이 운영 중인지 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-GKEGemmaOllamaThePowerTrioforFlexibleLLMDeployment_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 번 경험해보자! 왜 하늘은 파란색일까요?\n\n![이미지](https://miro.medium.com/v2/resize:fit:1388/1*0CM7W3rKWJbuMEGsAGkC5Q.gif)\n\n이것은 실시간 영상입니다 — NVIDIA L4의 Gemma 7B가 빠른 속도로 결과를 제공합니다! 직접 시도해 보고 싶나요? Ollama에서 모델을 배포하는 것은 아주 간단합니다. 단순히 ollama run gemma:7b를 사용하면 됩니다.\n\n## GPU 대 CPU — 속도의 문제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 플랫폼이 준비되어 있는데, 난 좋은 벤치마크 세션을 참여할 수 없다는 걸 알고 있지 😉. 다른 모델들에 걸쳐 두 종류의 벤치마크를 실행했어:\n\n- 고전적인 왜 하늘은 파랗게 보일까? 질문: Gemma 2B 및 7B, 그리고 LLaMA v1.6 7B와 13B에게 질문을 했지. 멀티모달과 유니모달 LLM을 테스트해 봐야 하거든!\n- 사진 속에 뭔가 있니? LLaMA v1.6 7B와 13B를 대상으로: 여기서 이미지 분석에 초점을 맞췄어.\n\n걱정 마, 내가 완전한 LLM 격렬한 대결을 벌일 생각은 없어 — 그건 전혀 다른 문제고, 내 이해 범위를 넘어서지. 내 목표는 다른 머신 유형이 속도와 반응성에 미치는 영향을 추적하는 거였어.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGPU 가속없이는 추론 성능이 주로 원시 CPU 성능과 메모리 대역폭에 의존했습니다. 당연히, 저는 CPU나 메모리 제한 없이 Ollama를 배포했고, CPU 활용률을 확인했습니다. 그러나 추론 작업은 종종 메모리 대역폭 가용성과 메모리 아키텍처에 의해 병목 현상을 겪을 수 있습니다.\n\n첫 번째 그래프는 몇 가지 주요 지표를 보여줍니다:\n\n- 총 소요 시간: 모델이 입력을 처리하고 응답을 생성하는 데 걸리는 시간입니다.\n- 응답 토큰/초: 모델이 출력을 생산하는 속도를 측정한 지표입니다.\n- 월간 비용: 선택한 구성을 한 달 동안 실행하는 데의 재정적 영향을 보여줍니다.\n\n![그래프 이미지](/assets/img/2024-05-18-GKEGemmaOllamaThePowerTrioforFlexibleLLMDeployment_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기에는 많은 것이 풀어야 할 문제가 있지만, 경고로 시작하고 싶습니다: 여러분이 지금 볼 성능 숫자는 특정 시나리오에 대한 것으로만 나타나는 것에 주목하세요. LLM의 세계는 매우 넓고 빠르기 때문에, 현재 이 그림조차 며칠 안에 완전히 관련이 없어질 수도 있습니다. 약간 다른 시나리오에서도 그렇습니다.\n\nGPU 우세성:\n\n- GPU는 CPU보다 대폭으로 낮은 대기 시간을 제공합니다(초당 더 많은 토큰). 심지어 $12,000/월에 180개의 전용 CPU 코어도 경쟁할 수 없습니다.\n- NVIDIA L4는 이전 T4보다 15% 더 빠른 속도를 제공하지만, 비용은 78% 증가했습니다. 지속 사용 할인이 반영되었습니다.\n- A100은 번개처럼 빠르지만, L4보다 약 세 배 더 빠르며, 높은 가격과 교육에 중점을 둔 점 때문에 대부분의 추론 작업에는 지나친 것으로 보입니다. 그럼에도 불구하고 3.6초 미만에 답변하는 데 성공했습니다 🤯.\n\nCPU 고민:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 작은 CPU는 명백히 느리고 놀랍도록 비싸다.\n- 비용이 비슷한 CPU들도 (c3-highcpu-22 / c3d-highcpu-16) 처리량 면에서 L4 및 T4보다 뒤처진다.\n- 가장 큰 CPU들 (c3-standard-176 / c3d-standard-360)은 그들의 엄청난 비용에 비해 성능이 나쁘다.\n- C3는 나쁘게 확장되는데, 이것은 ollama/llama.cpp, 내 설정 또는 C3 인스턴스와 그들의 vNUMA 토폴로지 부족과 관련된 잠재적인 문제일 수 있다. 하지만, 가격 때문에 그것은 의미가 없어진다.\n\n이제 이미지 인식 프롬프트를 살펴보자. 이번에 선택한 모델은 13B 파라미터를 가진 LLaVA v1.6이다.\n\n![이미지](/assets/img/2024-05-18-GKEGemmaOllamaThePowerTrioforFlexibleLLMDeployment_5.png)\n\nGPU의 성능 우위는 여기서도 유효하며, CPU는 이 도메인에서 단순히 경쟁할 수 없음을 보여준다. 흥미로운 점은 c3-standard-176이 마침내 c3-highcpu-22를 능가했는데, 이것은 C3나 내 설정에 버그가 있음을 의심하는 것을 해소시켰다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n전통에 따라 모든 결과는 다음 Google 시트에서 공개적으로 이용 가능합니다:\n\nOllama에 대해 몇 가지 포인트를 논의하기 전에, 이 환경에서 사용된 정확한 SHA와 태그를 공유하고 싶습니다. AI 세계가 빠르게 변화하고 있어, 제 작업을 재현하려는 누군가는 길을 나가면 얼마든지 다른 환경을 발견할 수 있습니다:\n\n- ollama v0.1.29;\n- Gemma 2B SHA b50d6c999e59\n- Gemma 7B SHA 430ed3535049\n- LLaVA v1.6 7B SHA 8dd30f6b0cb1\n- LLaVA v1.6 13B SHA 0d0eb4d7f485\n\n그리고 벤치마크가 실행된 방식에 대해:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ncurl http://localhost:8080/api/generate -d \\\n'{\n  \"model\": \"gemma:7b\",\n  \"prompt\": \"Why is the sky blue?\",\n  \"stream\": false,\n  \"options\": {\"seed\": 100}\n}'\n```\n\n```js\ncurl http://localhost:8080/api/generate -d \\\n'{\n  \"model\": \"llava:13b\",\n  \"prompt\":\"What is in this picture?\",\n  \"images\": [\"iVBORw0KGgoAAAANSUhEUgAAAG0AAABmCAYAAADBPx+VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAA3VSURBVHgB7Z27r0zdG8fX743i1bi1ikMoFMQloXRpKFFIqI7LH4BEQ+NWIkjQuSWCRIEoULk0gsK1kCBI0IhrQVT7tz/7zZo888yz1r7MnDl7z5xvsjkzs2fP3uu71nNfa7lkAsm7d++Sffv2JbNmzUqcc8m0adOSzZs3Z+/XES4ZckAWJEGWPiCxjsQNLWmQsWjRIpMseaxcuTKpG/7HP27I8P79e7dq1ars/yL4/v27S0ejqwv+cUOGEGGpKHR37tzJCEpHV9tnT58+dXXCJDdECBE2Ojrqjh071hpNECjx4cMH...\n```\n\n결과를 기록하는 동안 사용된 설정은 다음과 같습니다:\n\n- Ollama API와의 직접 통신\n- 스트리밍 비활성화\n- 모든 프롬프트에 동일한 시드값 사용함.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 올라마의 현재 한계: 더 깊게 파헤쳐보기\n\n올라마 프로젝트가 빠르게 발전 중임을 기억하는 것이 중요하지만, 전문 사용자가 알아야 할 중요한 제한 사항을 조사하는 것이 유용합니다:\n\n- 저장소 병목 현상: registry.ollama.ai에 갇히면 혁신과 실험을 억눌게 됩니다. 도커가 Quay.io를 넘어서지 않았다면 어땠을까 상상해보세요! 해결책이 있을 수 있지만, 다양한 모델 소스에 대한 네이티브 솔루션이 큰 발전을 이룰 것이며, 커뮤니티에서 이미 제안을 했습니다.\n- 병렬성을 통한 기회의 놓침: 올라마의 순차적 요청 처리가 현실 성능을 제한합니다. 사용자가 괴롭힘을 겪는 높은 트래픽 시나리오를 상상해보세요. 좋은 소식은 병렬 디코딩이 llama.cpp에 합병되었으며 v0.1.30 주기 중에 풀 리퀘스트된 것입니다. 이 문제 #358을 주시해야 합니다.\n- AVX512의 실망과 새로운 선택지: AVX512 최적화가 기대한 성능 향상을 제공하지 못하는 것은 실망스럽습니다. 실제로 더 좋게 만들려는 시도를 해봤지만 현실을 직면하게 되었습니다: AVX512는 별로다, AVX2보다 느리다 😭 (물론 코어 클록은 절반 이상), 그리고 \"AVX512가 고통스러운 죽음을 맞기를 희망합니다\". Intel AMX는 더 밝은 전망을 제시합니다. 경쟁력 있는 가격, 초기 벤치마크 결과, 특정 작업 부하에서 GPU를 앞서갈 수 있는 잠재력 등이 흥미로운 대안으로 나타납니다. 이 주제에 대해, The Next Platform의 AI 추론이 주로 CPU에서 이루어질 이유에 대한 깊은 의견을 강력히 권장합니다.\n\n## 주요 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nGKE에서 Ollama와 함께 LLM을 배포하는 것은 맞춤화, 유연성, 잠재적인 비용 절감 및 LLM 솔루션 내에서의 개인 정보 보호를 우선시하는 사용자들에게 매력적인 옵션을 제공합니다. 이 접근 방식은 상업 플랫폼에서 사용할 수 없는 모델을 활용할 수 있게 해주며 배포 환경에 대한 완전한 제어권을 제공합니다. 중요한 점은 GPU 가속이 최적의 LLM 성능을 위해 필수적이며, 강력한 CPU 기반 인스턴스조차 크게 앞서갑니다. 그러나 Ollama의 현재 제약 사항, 예를 들어 레지스트리 의존성 및 순차적 요청 처리와 같은 것에 주의를 기울이는 것이 중요합니다. 이러한 제약 사항은 Ollama가 계속 성장함에 따라 해결될 가능성이 크며, 그 가능성을 더욱 높일 것입니다.\n\n즐거운 시간 보내셨길 바라며, 저에게 궁금한 점이 있으시면 언제든지 댓글을 남겨주세요.\n","ogImage":{"url":"/assets/img/2024-05-18-GKEGemmaOllamaThePowerTrioforFlexibleLLMDeployment_0.png"},"coverImage":"/assets/img/2024-05-18-GKEGemmaOllamaThePowerTrioforFlexibleLLMDeployment_0.png","tag":["Tech"],"readingTime":11},{"title":"롱혼 - K8s를 위한 분산형 블록 스토리지","description":"","date":"2024-05-18 16:50","slug":"2024-05-18-LonghornDistributedBlockStorageforK8s","content":"\n![Longhorn](/assets/img/2024-05-18-LonghornDistributedBlockStorageforK8s_0.png)\n\n# Longhorn이란 무엇인가요?\n\n## K8s 클러스터에서 영구 저장소가 필요한 이유는 무엇인가요?\n\n컨테이너화된 응용 프로그램에서 데이터는 일반적으로 컨테이너 자체와는 별도로 저장되는 저장 시스템에 저장됩니다. 이는 컨테이너를 쉽게 파기하거나 대체할 수 있게 하면서도 중요한 데이터를 손실하지 않도록 합니다. 영구 데이터를 저장한다는 것은 데이터가 컨테이너가 중지, 다시 시작되거나 삭제되어도 손실되지 않도록 데이터를 저장하는 방식을 의미합니다. 이를 위해 클라우드 네이티브 분산 블록 저장 시스템과 같은 영구 저장소 솔루션을 사용하여 데이터를 저장함으로써 컨테이너가 필요할 때 데이터에 액세스할 수 있도록 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터는 애플리케이션 데이터, 구성 파일, 사용자 데이터, 데이터베이스 및 시간이 지날수록 유지하고 액세스해야하는 다른 유형의 데이터일 수 있습니다.\n\n# Longhorn 작동 방식은?\n\nLonghorn에는 세 가지 주요 구성 요소가 있습니다:\n\n- Longhorn Manager\n- Longhorn Engine\n- Longhorn UI\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 롱혼 매니저\n\n롱혼 매니저 Pod는 롱혼 클러스터의 각 노드에서 Kubernetes 데몬세트로 실행됩니다. Kubernetes 클러스터에서 볼륨을 생성하고 관리하며 UI 또는 Kubernetes를 위한 볼륨 플러그인의 API 호출을 처리합니다.\n\n롱혼 매니저는 Kubernetes API 서버와 통신하여 새로운 롱혼 볼륨 CRD를 생성합니다. 그런 다음 롱혼 매니저는 API 서버 응답을 모니터링하고 Kubernetes API 서버가 새 롱혼 볼륨 CRD를 생성한 것을 감지하면 새 볼륨을 생성합니다.\n\n## 롱혼 엔진\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n롱혼 매니저가 볼륨을 생성하도록 요청받으면, 그 볼륨이 연결된 노드에 롱혼 엔진 인스턴스를 생성하고, 각 복제가 배치될 노드에 각각 복제를 생성합니다. 복제는 최대 가용성을 보장하기 위해 별도의 호스트에 배치되어야 합니다.\n\n롱혼은 롱혼 클러스터의 각 노드에 볼륨마다 별도의 엔진을 생성합니다.\n\n엔진은 롱혼 볼륨의 I/O 작업을 처리하는 구성 요소입니다. 볼륨이 생성되면 롱혼은 해당 볼륨이 실행되는 각 노드에 별도의 엔진을 생성합니다. 이렇게 하면 볼륨 데이터가 해당 볼륨이 실행 중인 노드에 로컬로 저장되도록 보장합니다.\n\n만약 볼륨을 위한 롱혼 엔진을 호스팅하는 노드가 충돌하거나 다른 이유로 이용 불가능 상태가 되면, 롱혼은 해당 장애를 감지하고 자동으로 다른 이용 가능한 노드에 엔진을 재배치합니다. 이 프로세스를 자동 노드 복구라고 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n엔진은 Pod나 배포(Deployment)와 같은 Kubernetes 객체가 아닙니다. 대신에, 그것은 호스트 운영 체제에서 이진 실행 파일로 실행되는 Longhorn에 특화된 프로세스입니다.\n\n아래 그림은 Longhorn이 작동하는 방식을 보여줍니다:\n\n![Longhorn Architecture](/assets/img/2024-05-18-LonghornDistributedBlockStorageforK8s_1.png)\n\n- Longhorn 볼륨은 세 개의 인스턴스가 있습니다.\n- 각 볼륨에는 Longhorn 엔진이라 불리는 전용 컨트롤러가 있으며 Linux 프로세스로 실행됩니다.\n- 각 Longhorn 볼륨에는 두 개의 복제본이 있고, 각각의 복제본은 Linux 프로세스입니다.\n- 그림에서 화살표는 볼륨, 컨트롤러 인스턴스, 복제본 인스턴스 및 디스크 간의 읽기/쓰기 데이터 흐름을 나타냅니다.\n- 볼륨마다 별도의 Longhorn 엔진을 생성하여, 하나의 컨트롤러가 실패하더라도 다른 볼륨의 기능에는 영향을 미치지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 롱혼 UI\n\n롱혼 UI는 롱혼 매니저에 의해 쿠버네티스 배포로 배포되며, 기본적으로 하나의 레플리카로 실행되므로 단일 노드에서 팟으로 실행됩니다.\n\n롱혼 UI는 롱혼 API를 통해 롱혼 매니저와 상호 작용합니다. 롱혼 UI를 통해 스냅샷, 백업, 노드 및 디스크를 관리할 수 있습니다.\n\n또한, 롱혼 UI에 의해 클러스터 워커 노드의 공간 사용량이 수집되고 시각화됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 그림은 Longhorn UI에서 보는 그림을 보여줍니다:\n\n![Longhorn UI view](/assets/img/2024-05-18-LonghornDistributedBlockStorageforK8s_2.png)\n\n이제 이 그림에서 각 용어의 의미를 자세히 알아보겠습니다:\n\n- Schedulable: Longhorn 볼륨 스케줄링에 사용할 수 있는 실제 공간입니다.\n- Reserved: 다른 애플리케이션과 시스템을 위해 예약된 공간입니다.\n- Used: Longhorn, 시스템 및 다른 애플리케이션에서 사용된 실제 공간입니다.\n- Disabled: Longhorn 볼륨을 스케줄링할 수 없는 디스크/노드의 총 공간입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Longhorn 설치 (전제 조건 및 요구 사항)\n\n## 노드 수\n\nLonghorn은 Kubernetes 클러스터에 최소한 하나의 노드로 설치할 수 있지만, 데이터 중복 및 고가용성을 위해 적어도 세 개의 노드가 권장됩니다.\n\n## K8s 클러스터의 각 노드는 다음 요구 사항을 충족해야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Kubernetes와 호환되는 컨테이너 런타임(Docker v1.13+, containerd v1.3.7)이 필요합니다.\n- Kubernetes 버전은 `v1.21` 이상이어야 합니다.\n- open-iscsi가 설치되어 있어야 하며, 모든 노드에서 iscsid 데몬이 실행 중이어야 합니다.\n\n- RWX 지원을 위해 각 노드에 NFSv4 클라이언트가 설치되어 있어야 합니다.\n\n- 호스트 파일 시스템이 데이터를 저장하기 위한 파일 extents 기능을 지원해야 합니다. 현재 지원하는 파일 시스템은 ext4 및 XFS입니다.\n\n- 다음 Linux 명령 줄 유틸리티가 설치되어 있어야 합니다: bash, curl, findmnt, grep, awk, blkid, lsblk\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 마운트 전파를 활성화해야 합니다.\n\n- 롱혼 워크로드는 롱혼이 올바르게 배포 및 운영되기 위해 루트 사용자로 실행할 수 있어야 합니다.\n\n# 권장 최소 하드웨어\n\n- 3 노드\n- 노드 당 4 vCPU\n- 노드 당 4 GiB\n- 스토리지를 위한 노드에는 SSD/NVMe 또는 유사한 성능 블록 장치(추천)\n- 스토리지를 위한 노드에는 HDD/스핀 디스크 또는 유사한 성능 블록 장치(확인됨)\n- 볼륨 당 최대 500/250 IOPS(1 MiB I/O)\n- 볼륨 당 최대 500/250 처리량(MiB/s)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 운영 체제\n\n- Ubuntu: 버전 (20.04, 22.04)\n- SLES: 버전 (15 SP4)\n- SLE Micro: 버전 (5.3)\n- CentOS: 버전 (8.4)\n- RHEL: 버전 (8.6)\n- Oracle Linux: 버전 (8.6)\n- Rocky Linux: 버전 (8.6)\n\n# Longhorn 기능, 제한 및 단점\n\n## 기능\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 고가용성: Longhorn은 클러스터 내 여러 노드에 볼륨을 복제하여 데이터의 고가용성을 제공하기 위해 설계되었습니다.\n- 스냅샷 및 백업: Longhorn은 복제본이 다운됐을 때마다 (시스템) 스냅샷을 자동으로 찍고 다른 노드에서 다시 복구 시작합니다.\n- 재해 복구: Longhorn은 재해로부터 회복하기 위해 볼륨을 다시 구축하고 백업 데이터를 복원하는 기능을 제공합니다.\n- 복제: Longhorn은 서로 다른 클러스터 간에 볼륨을 복제하여 여러 위치에 걸쳐 재해 복구 솔루션을 만들 수 있도록합니다.\n- 동적 할당: Longhorn은 Kubernetes에서 볼륨의 동적 할당을 지원하여 Kubernetes API를 사용하여 볼륨을 생성하고 관리할 수 있게 합니다.\n- 볼륨 확장: Longhorn은 볼륨의 온라인 확장을 지원하여 볼륨 크기를 증가시키고 다운타임 없이 볼륨을 확장할 수 있습니다.\n- 모니터링 및 메트릭: Longhorn은 볼륨의 상태 및 성능에 대한 상세한 메트릭 및 모니터링 정보를 제공하여 스토리지 인프라의 문제 해결 및 최적화를 쉽게 할 수 있습니다.\n- 웹 기반 UI: Longhorn은 웹 기반 사용자 인터페이스를 제공하여 볼륨 및 스토리지 인프라를 손쉽게 관리하고 모니터링할 수 있습니다.\n\n## 제한 사항 및 단점\n\n- 버전 간 업그레이드는 복잡한 과정입니다.\n- Longhorn은 높은 버전에서 낮은 버전으로의 다운그레이드를 지원하지 않습니다.\n- Longhorn 블록 스토리지 속도는 로컬 디스크 스토리지 속도보다 약간 느립니다.\n\n# Longhorn 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n롱혼은 Helm, kubectl 및 Rancher Apps \u0026 Marketplace로 설치할 수 있어요.\n\n롱혼은 100% 오픈 소스 소프트웨어에요. 프로젝트 소스 코드는 여러 저장소에 분산돼 있어요:\n\n- Longhorn Engine — 코어 컨트롤러/레플리카 로직.\n- Longhorn Instance Manager — 컨트롤러/레플리카 인스턴스 라이프사이클 관리.\n- Longhorn Share Manager — NFS 프로비저너로 롱혼 볼륨을 ReadWriteMany 볼륨으로 노출시켜요.\n- Backing Image Manager — 백킹 이미지 파일 라이프사이클 관리.\n- Longhorn Manager — 롱혼 오케스트레이션, Kubernetes용 CSI(Container Storage Interface) 드라이버를 포함하고 있어요.\n- Longhorn UI — 대시보드.\n\n## Helm으로 설치하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요구 사항\n\n- 작업 스테이션에는 Helm v2.0+가 설치되어 있어야 합니다.\n\nLonghorn 헬름 차트를 여기에서 확인할 수 있습니다.\n\n헬름 차트의 내용:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n템플릿: 쿠버네티스 매니페스트를 포함하고 있는 폴더로, 차트에 의해 생성되는 리소스를 정의합니다.\n\nvalues.yaml: 차트에서 사용되는 구성 매개변수의 기본 값을 정의하는 파일입니다.\n\nChart.yaml: 차트에 관한 메타데이터를 포함하고 있는 파일로, 이름, 버전, 설명, 유지보수자 등을 포함합니다.\n\n설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLonghorn 차트 저장소를 추가해보세요:\n\n```js\n$ helm repo add longhorn https://charts.longhorn.io\n```\n\n차트 저장소에서 로컬 Longhorn 차트 정보를 업데이트해보세요:\n\n```js\n$ helm repo update\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLonghorn 차트 설치:\n\nHelm 2를 이용해 다음 명령어를 실행하면 longhorn-system 네임스페이스를 생성하고 Longhorn 차트를 함께 설치합니다:\n\n```js\n$ helm install longhorn longhorn/longhorn --namespace longhorn-system\n```\n\nHelm 3를 이용해 다음 명령어를 실행하면 먼저 longhorn-system 네임스페이스를 생성하고 Longhorn 차트를 설치합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```bash\n$ kubectl create namespace longhorn-system\n$ helm install longhorn longhorn/longhorn --namespace longhorn-system\n```\n\n설치가 성공적으로 완료되었는지 확인하려면 설치 후 실행 중인 파드를 확인하여 다음 명령을 실행하면 Longhorn 파드를 볼 수 있어요:\n\n```bash\n$ kubectl get pods --namespace longhorn-system\n```\n\n# Longhorn 볼륨 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep_1: 롱혼 StorageClass 생성하기\n\n다음은 storageclass.yaml이 어떻게 생겼는지입니다:\n\n```yaml\napiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: longhorn\nprovisioner: driver.longhorn.io\nallowVolumeExpansion: true\n```\n\n```bash\n$ kubectl apply -f storageclass.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep_2: Longhorn StorageClass를 참조하는 PersistentVolumeClaim (PVC)를 만듭니다.\n\n다음은 longhorn-pvc.yaml 파일의 내용입니다.\n\n```yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: longhorn-vol-pvc\nspec:\n  storageClassName: longhorn\n  accessModes:\n    - ReadWriteMany\n  resources:\n    requests:\n      storage: 1Gi\n```\n\n```bash\n$ kubectl apply -f longhorn-pvc.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep 3: Longhorn 볼륨을 사용하는 Pod 생성하기\n\n아래는 pod-with-longhorn.yaml 파일의 내용입니다:\n\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: longhorn-test\nspec:\n  containers:\n    - name: longhorn-test-container\n      image: busybox\n      command: [\"/bin/sh\"]\n      args:\n        [\n          \"-c\",\n          \"while true; do echo $(date) \u003e\u003e /mnt/data/date.txt; sleep 1; done\",\n        ]\n      volumeMounts:\n        - mountPath: /mnt/data\n          name: longhorn-vol\n  volumes:\n    - name: longhorn-vol\n      persistentVolumeClaim:\n        claimName: longhorn-vol-pvc\n```\n\n이후, longhorn-test 라는 이름의 Pod가 시작되며, Longhorn StorageClass를 참조하는 longhorn-vol-pvc라는 PersistentVolumeClaim도 생성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n영구 볼륨 클레임이 Pod에 볼륨으로 마운트됩니다.\n\n# 제거\n\nHelm 2를 사용하여 Longhorn을 제거하려면:\n\n```js\n# 삭제 확인을 위해 Longhorn 설정을 패치합니다\n$ kubectl -n longhorn-system patch -p '{\"value\": \"true\"}' --type=merge lhs deleting-confirmation-flag\n\n# Longhorn을 제거합니다\n$ helm delete longhorn --purge\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHelm 3으로 Longhorn을 제거하는 방법은 다음과 같습니다:\n\n```js\n# 삭제 확인을 위해 Longhorn 설정을 패치\nkubectl -n longhorn-system patch -p '{\"value\": \"true\"}' --type=merge lhs deleting-confirmation-flag\n\n# Longhorn 제거\nhelm uninstall longhorn -n longhorn-system\n\n# Longhorn 네임스페이스 삭제\nkubectl delete namespace longhorn-system\n```\n\n# 결론\n\n요약하자면, Longhorn은 Kubernetes에서 영속적인 저장소를 생성하고 관리하기 위한 솔루션이다. 관리자, 컨트롤러, 레플리카 인스턴스 등의 컴포넌트를 특징으로 하는 아키텍처는 데이터의 내구성과 고가용성을 보장한다. Longhorn의 주요 기능으로는 분산 블록 저장소, 스냅샷, 백업, 볼륨 복제가 있어 상태를 유지해야 하는 응용프로그램을 실행하는 데 이상적이다. Helm 2 또는 3을 사용한 쉬운 설치로, Longhorn은 저장소 프로비저닝과 구성을 단순화하여 Kubernetes 환경에서 개발자와 시스템 관리자에게 가치 있는 도구가 된다.\n","ogImage":{"url":"/assets/img/2024-05-18-LonghornDistributedBlockStorageforK8s_0.png"},"coverImage":"/assets/img/2024-05-18-LonghornDistributedBlockStorageforK8s_0.png","tag":["Tech"],"readingTime":14},{"title":"ArgoCD ApplicationSet은 v29 버전에서 더 실용적입니다","description":"","date":"2024-05-18 16:49","slug":"2024-05-18-ArgoCdApplicationSetismorepracticalinversionv29","content":"\n대부분의 ArgoCD 프로젝트를 따르는 여러분은 이미 이를 알고 있을 것입니다. ArgoCD v2.9에서는 특정 기능이 릴리스의 일부가 되었는데, 이에 대해 이 게시물에서 공유하고 싶습니다.\n\n![ArgoCD v2.9](/assets/img/2024-05-18-ArgoCdApplicationSetismorepracticalinversionv29_0.png)\n\n# 언급한 기능은 무엇이며 왜 이것이 ApplicationSet을 더 실용적으로 만드는가요?\n\nApplicationSet을 사용하여 Application을 생성하는 경우 생성된 Application의 자동 동기화를 비활성화할 수 없다는 것을 이미 알아차리신 분들이 많으실 겁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 문제에 대한 자세한 내용은 다음 링크에서 확인할 수 있습니다: https://github.com/argoproj/argo-cd/issues/9101\n\n문제에 대한 요약은 다음과 같습니다.\n\n예를 들어, 제 경우에는 특정한 ApplicationSet이 모든 Kubernetes 클러스터에 대해 특정 Application을 생성하도록 설정되어 있습니다.\n\n클러스터 유지 관리자로서 어느 날, 한 클러스터에서 발생한 문제에 대해 알림을 받았는데, 그 문제가 ApplicationSet을 통해 설치된 응용프로그램과 관련이 있는 것으로 보였습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 클러스터에서 매개변수를 동적으로 변경하여 문제를 완화해야 했습니다. 애플리케이션의 자동 동기화를 비활성화하여 일부 작업을 수행할 수 있도록 시도했지만, ApplicationSet 컨트롤러는 항상 자동 동기화 상태로 되돌리기 때문에 문제가 발생했습니다.\n\n이것은 \"버그\"라기보다는 존경받는 GitOps 원칙을 시행하며 모든 변경 사항은 특정 애플리케이션의 값들을 수동으로 재정의하는 대신 코드를 통해 수행되어야 한다는 동작입니다.\n\n하지만, 제게는 실용적이지 않았습니다. 특히, 새벽 4시에 빠르게 문제를 해결해야 하는 SRE로서 실시간 제품 시스템을 모니터링해야 하는 경우에는 더욱 그렇습니다.\n\n이 제한은 이 특정 사용 사례에만 해당하는 것이 아닙니다. Github의 이슈에서 설명했듯이, 대부분의 개발 작업 흐름도 생성된 애플리케이션에 일부 값을 재정의해야 하는데, 그 또한 불가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 어떤 기능으로 이 문제를 해결할 수 있을까요?\n\nArgoCD v2.9에서는 애플리케이션세트(ApplicationSet)에서 생성된 애플리케이션의 자동 동기화를 일시적으로 끌 수 있도록 허용합니다.\n\n우리가 해야 할 일은 이 구성 조각을 애플리케이션세트에만 추가하는 것뿐입니다.\n\n![ArgoCD Application Set Configuration](/assets/img/2024-05-18-ArgoCdApplicationSetismorepracticalinversionv29_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n응용 프로그램 설정 컨트롤러에서 변경 내용이 롤백되지 않고 응용 프로그램의 자동 동기화를 중지할 수 있습니다.\n\n![이미지](/assets/img/2024-05-18-ArgoCdApplicationSetismorepracticalinversionv29_2.png)\n\n사실, 이 변경의 일부로 필요에 맞게 syncPolicy에 국한되지 않는 여러 매개변수 간의 차이를 무시할 수 있습니다. 주의할 점은 우리가 재정의하려는 필드가 목록인 경우에는 여전히 일부 제한 사항이 있습니다. 그러나 필요할 때 자동 동기화를 비활성화할 수 있게 되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-ArgoCdApplicationSetismorepracticalinversionv29_0.png"},"coverImage":"/assets/img/2024-05-18-ArgoCdApplicationSetismorepracticalinversionv29_0.png","tag":["Tech"],"readingTime":3}],"page":"106","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":19,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"106"},"buildId":"wOkGEDZCvEs3S_XaNsdwr","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>