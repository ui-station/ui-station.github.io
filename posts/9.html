<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/9" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/9" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="가장 이상한 잊혀진 레고 게임" href="/post/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가장 이상한 잊혀진 레고 게임" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가장 이상한 잊혀진 레고 게임" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">가장 이상한 잊혀진 레고 게임</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착" href="/post/2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="편안한 게임 장르, 이제 과포화 상태일까" href="/post/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="편안한 게임 장르, 이제 과포화 상태일까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="편안한 게임 장르, 이제 과포화 상태일까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">편안한 게임 장르, 이제 과포화 상태일까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24" href="/post/2024-06-23-Leashtofollowplayerdevblog24"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Leashtofollowplayerdevblog24_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="현대 웹 API 이해하기 Part 1 RESTful API 사용법" href="/post/2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="현대 웹 API 이해하기 Part 1 RESTful API 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="현대 웹 API 이해하기 Part 1 RESTful API 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">현대 웹 API 이해하기 Part 1 RESTful API 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="건축 알아야 할 필수 요약 정보" href="/post/2024-06-23-ArchitectureThecheatsheet"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="건축 알아야 할 필수 요약 정보" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ArchitectureThecheatsheet_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="건축 알아야 할 필수 요약 정보" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">건축 알아야 할 필수 요약 정보</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="트위터가 4000억 이벤트를 처리하는 방법을 개선한 비결" href="/post/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="트위터가 4000억 이벤트를 처리하는 방법을 개선한 비결" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="트위터가 4000억 이벤트를 처리하는 방법을 개선한 비결" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">트위터가 4000억 이벤트를 처리하는 방법을 개선한 비결</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Docker 최신 개발 및 배포를 위한 필수 무기 " href="/post/2024-06-23-DockerAGoodto-HaveArsenalforModernDevelopmentandDeployment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker 최신 개발 및 배포를 위한 필수 무기 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-DockerAGoodto-HaveArsenalforModernDevelopmentandDeployment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker 최신 개발 및 배포를 위한 필수 무기 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Docker 최신 개발 및 배포를 위한 필수 무기 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NET 8에서 헬스 체크 구현하는 방법" href="/post/2024-06-23-ImplementingHealthChecksinNET8"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NET 8에서 헬스 체크 구현하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ImplementingHealthChecksinNET8_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NET 8에서 헬스 체크 구현하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">NET 8에서 헬스 체크 구현하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">15<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="회사 회의가 너무 많나요 회의 지옥에서 벗어나는 방법" href="/post/2024-06-23-TooManyMeetingsatWorkHeresHowToStoptheMeetingMadness"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="회사 회의가 너무 많나요 회의 지옥에서 벗어나는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TooManyMeetingsatWorkHeresHowToStoptheMeetingMadness_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="회사 회의가 너무 많나요 회의 지옥에서 벗어나는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">회사 회의가 너무 많나요 회의 지옥에서 벗어나는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link posts_-active__YVJEi" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"가장 이상한 잊혀진 레고 게임","description":"","date":"2024-06-23 22:13","slug":"2024-06-23-TheCoolestForgottenLegoGameIsSoWeird","content":"\n![이미지](/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_0.png)\n\n레고 게임 시리즈는 방대하며 현재 많은 회사와 스튜디오에서 개발 중입니다. 하지만 여전히 Traveler's Tales 또는 TT Games와 가장 연관이 있는 것으로 여겨집니다. 그들은 수년 동안 엄청난 수의 게임을 출시했는데, 그 대부분은 기본적인 협동 액션 어드벤처 게임으로, 선형 레벨 진행을 통해 물체를 치고 간단한 퍼즐을 해결하는 게임이었습니다.\n\n2018년쯤에 그런 내용의 콘텐츠 시리즈가 끝나고, 2022년에 TT Games는 새로운 엔진 플랫폼과 거대한 오픈 월드 게임인 레고 스타 워즈: 더 스카이워커 사가를 출시하며 시리즈를 재시작했습니다. 이 게임은 상업적으로 성공을 거두었으며, 현재 시장에서 잘 팔리는 일반적인 게임들과 더 잘부합되도록 시리즈를 융합한 작품입니다.\n\n그 성공적인 공식적인 액션 게임의 연속과 거대한 오픈 월드 스타 워즈 모험 사이에, 2019년에는 레고 무비 2 비디오게임이 출시되었습니다. 표면상 이것은 영화를 인용한 레벨을 통해 단순히 놀 수 있는 게임으로 보일 수 있지만, 실제로는 Minecraft와 90년대 후반 슈퍼 마리오 64의 성공 이후에 출시된 3D 플랫포머 게임과 이상하게 결합된 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTT Games는 Lego Worlds로 한 번 더 Minecraft를 모방해보기도 했습니다. 그것은 유명한 블록 건설 게임을 뻔뻔스럽게 복제한 것으로, 건설 도구와 생태 지대뿐만 아니라 일부 경쾌한 플랫포밍도 제공했습니다. 그것은 직접 영감받은 것보다 훨씬 더 나은 점은 없었지만, 특히 친구와 함께 할 때는 어떤 즐거움이 있는 것이었습니다.\n\n레고 무비2 비디오게임은 레고 월드 프레임워크 위에 구축되었습니다. 이것은 이야기 중심의 액션 게임이지만, 모든 레벨은 해당 보다 자유로운 엔진 내에서 구축되었습니다. 게임 플레이는 대부분의 이전 레고 게임이 제공했던 표준적인 \"모든 것을 치고 문을 열기\" 경험이 아닙니다. 오히려, 이 중심은 World의 빌드 도구를 사용하여 여러 가지 영리한 용도를 가진 정말 이상한 물건을 창조하는 환경 퍼즐 해결을 중심으로 합니다. 구축할 수 있는 것들은 환경을 폭파해 벽돌을 수집해야하지만, 전투 중심이 훨씬 적고 플레이어 창의력과 숙련된 플랫포밍에 훨씬 더 의존합니다.\n\n이것은 시리즈가 되돌아 보았을 때 신선한 일반적인 액션 사가가 아니라 어떤 것일지 상상할 때 거이 그렇습니다. 그리고 이것이 흥미로운 부분입니다.\n\n![image](/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n레고 게임 열차에서 떨어진 적이 있어요. 무비 2가 나올 때였죠. 그때까지 몇 년 동안 하나도 끝내지 못했는데, 출시 시 구매하고 완료하는 습관이 있었어요. 그런데 농담 같은 이 게임을 너무 많이 했어요. PS4에서 끝내고, 원래 2019년에 너무 긴 리뷰를 썼기 때문에 스위치에서도 상당히 많이 했어요. 아닌가? 14분을 읽을 것을 알렉스, 뭔가 장난하나? 예전 나는 이 이상한 영화 타이인 게임에 대해 왜 이렇게 많은 이야기를 했을까요? 그 후에도 계속해서 게임을 했어요. 스위치 버전을 끝냈어요. 세 번째로 엑스박스에서도 했어요.\n\n그리고, 이 기사 제목의 영감을 받아 완전히 그것을 잊어버렸어요.\n\n2020년 말에 새로운 콘솔 출시의 열기에 휩쓸렸어요. 2022년에 열창적인 오픈 월드 스타워즈 스타일로 레고 시리즈가 부활했을 때 정말 즐겼어요. 영화 2와 같은 작은 규모의 창의적인 레고 게임을 더 원했던 내가 얼마나 괴로웠는지 잊어버렸죠. 그 영화가 가진 문제점을 많이 해결했고, 창조적인 에너지가 여전히 TT Games 제작 공장 안에 끓어오르고 있음을 보여주는 재미있고 가볍고 유쾌한 것입니다. 다시 돌아가봤을 때에도 여전히 즐겁습니다. \"최고\" 게임은 아니지만요. 하지만 노력하는 걸 잘 보여주고, 마인크래프트 클론으로 설계된 엔진에서 감탄할 만한 플랫포머를 만들 수 있다는 게 대단하죠. 3D 플랫포머 초기에는 누구나 슈퍼 마리오 64를 본받으려고 했고, 결과적으로 더 다채로운 세계로 이어지는 문을 여는 데용 둥둥 뛰어다니고 둥둥 모으는 장난기 많은 이야기들이 있었죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"The Lego Movie 2\" 게임은 옛날 타이틀과 매우 흡사하다는 것을 말하면서도 칭찬의 뜻을 가지고 있다. 찾을 수 있는 것들이 땅 곳곳에 흩어져 있고, 점프나 건설 시스템 중 하나에 대해 충분한 기술이 필요하므로 찾아내기 충분합니다. 지도는 숨겨진 벽돌을 수퍼 마리오 오디세이의 심오한 달들처럼 끝없이 사냥할 필요가 없도록 힌트를 제공하지만, 도전 과제는 여전히 단순하게 느껴지지만 충분히 만족스럽게 느껴지도록 잘 만들어졌습니다. 오늘 아침에 내 기억을 되살리기 위해 게임의 첫 번째 행성을 완전히 플레이했고, 이제 이 게임을 네 번째로 끝내고 싶습니다.\n\n음향 디자인도 언급할 만합니다. 강렬하고 다이내믹하며 놀라운 서라운드 채널 모멘트로 가득합니다. 게임은 대형 예산 액션 게임에 잘 어울리는 효과 작업과 피드백을 제공하며, 순전히 귀여운 가족용 플랫포머에 적합한 것으로 너무 과하게 믹싱되어 있습니다. 비슷한 목소리 캐스트는 매 line을 열정적으로 전달하는 데 훌륭한 일을 합니다. 음악은 포함된 영화 트랙의 수준에 미치지 못하지만, 그 영화 트랙은 너무 재미있고 압도적이라 복제하기가 매우 어렵습니다.\n\n90년대 추억의 플랫폼 게임을 떠올리게 하는 것 외에도 이 게임은 2019년 게임 산업을 외치는 이상한 디자인 요소를 가지고 있습니다: 무작위로 선택된 전리품 상자 언락. 세트를 넘어서 크고자하는 스티커, 건축물, 구조물에 대한 액세스 권한을 얻을 수 있지만 대부분의 이 내용은 무작위로 배치된 전리품 상자 시스템을 통해 언락됩니다. 이것은 Destiny의 스타일로 매우 복잡하고 계층적입니다. 당신은 상자에서 리플릭스라고 불리는 색상 구슬을 얻고 때로는 적에서 얻어내서 그것들을 상점에서 현금화시키기 위해 두 번째 과정을 거쳐 무엇을 포함하고 있는지 확인해야 합니다.\n\n이것은 오늘날에는 조금 의심스럽고 시대에 뒤떨어진 느낌이 들지만, 적어도 이 아이템들을 실제 돈으로 사는 방법을 구현하지 않았습니다. 전리품은 무작위 요소가 있어 무슨 종류의 것을 얻게 될지 알 수 없기 때문에 일정 수준의 재생 가능성을 더해준다고 생각하지만, Lego Worlds 엔진 디자인의 유령과 같이 이 영화 게임을 의미있게 향상시키지는 않는다고 확실합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스카이워커 사가의 불가피하고 명백한 성공으로 TT Game의 운명이 봉인된 것 같아요. 이제 그들은 영원히 오픈 월드 게임을 만들게 될 거에요. 소니 제작, Studio Gobo 개발의 레고 호라이즌 게임은 재미있어 보이지만, 예전 TT Games가 대량으로 내놓던 공식적인 것과 더 비슷해 보여요. 레고 무비 2는 독특하고 멋진 변화를 보여줍니다. 필요한 창의력의 숨통 고르기, 그리고 그저 부숴버리는 것이 아닌 무언가를 만드는 주요 레고 비디오 게임을 만들려는 진정한 시도인 것 같아요.\n\n![이미지](/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_2.png)\n\n이런 게임을 10개 더 즐거워했을 텐데, 그런 상상된 내용의 미래는 이제 매우 불가능해 보이네요. 레고 무비 2는 원작을 그저 복제하는 것 이상의 멋진 시도를 해본 그 드물고도 귀한 영화 기반 게임 중 하나에요. 지쳐가던 긴 시리즈 게임을 새롭게 살리려 한 것이 주목할 만해요. 안전한 IP 세트와 함께 작업하는 희귀한 창의적 위험인데도 마켓에서 조용히 사라졌어요. 메타크리틱 페이지에는 좋지 않은 숫자들이 즐비해 있고, 영화도 이전 시리즈만큼 잘되지 않았기 때문에 여러 사람들에게 목표적인 실패를 가져온 것 같아요. 최근 과도하게 짧고 비싼 마이크로트랜잭션으로 넘치는 레고 2K 드라이브가 이를 능가했다는 점이 화나네요.\n\n가족용 게임이 반드시 나쁜 게임일 필요는 없어요. 그들은 다를 수 있고 흥미로울 수 있으며, 다른 게임들과 같은 주의를 받고 비평적 사고를 받을 가치가 있어요. 수백만 명의 사람들이 이러한 프랜차이즈에 노출되고 있어요. 그것들은 신중하고 좋아야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\"The Lego Movie 2\" 게임이 시간이 흘러도 더욱 좋게 기억될 것을 바랍니다. 하지만 아마 이것은 헛된 개인적인 성찰인 것 같아요. 더 큰 프랜차이즈는 이제 다른 \"더 큰\" 게임들을 흉내내고 있지만, 새로운 하지만 안전한 시도들은 여러 스튜디오로부터 나오고 있어요. 혹시 몇 년 후에 이 흥미로운 곳에 다시 도달할 수 있는 게 있는지 - 그것 역시 다르다는 이유로 제쳐지는 걸 겪게 될지도 몰라요.\n\n위 제목들과 관련된 어떤 사람에게서도 글을 쓰라는 요청이나 대가를 받지 않았어요.\n","ogImage":{"url":"/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_0.png"},"coverImage":"/assets/img/2024-06-23-TheCoolestForgottenLegoGameIsSoWeird_0.png","tag":["Tech"],"readingTime":6},{"title":"플레이스테이션 포털 원격 플레이어 대규모 시스템 소프트웨어 업데이트 내일 도착","description":"","date":"2024-06-23 22:12","slug":"2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow","content":"\n## 내일의 시스템 소프트웨어 업데이트로 플레이스테이션 포털 리모트 플레이어 기능이 업그레이드됩니다\n\n좋아하는 플레이스테이션 게임을 새로운 방식으로 경험할 준비가 되셨나요? 기대해 주세요, 오랫동안 기다려온 플레이스테이션 포털 리모트 플레이어가 드디어 출시됩니다! 내일 출시되는 이 멋진 기기는 와이파이 범위 내에서 어디에서나 플레이스테이션5 게임을 스트리밍할 수 있게 되어 게임하는 방식을 혁신할 것을 약속합니다.\n\n하지만 이것만이 아닙니다. 이 획기적인 출시와 함께 게이머 경험을 향상시키기 위해 설계된 기능과 개선 사항이 가득한 주요 시스템 소프트웨어 업데이트가 함께 제공됩니다. 소니에 따르면:\n\n궁금하시죠? 새로운 멋진 기능을 발견하고 그것이 어떻게 게임 라이프스타일을 변화시킬 수 있는지 계속 읽어보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플레이스테이션 포털 리모트 플레이어는 당신이 좋아하는 게임과 소통하는 방식을 혁신할 준비가 되어 있습니다. 8인치 LCD 화면을 특징으로 하는 이 혁신적인 장치는 PS5 타이틀을 매끄럽게 1080p 해상도에서 60fps로 플레이할 수 있도록 해줍니다. 집 안 어디서든 게임 컬렉션을 손쉽게 불러오고 사랑하는 플레이스테이션 시리즈의 몰입적인 세계로 뛰어들어 보세요.\n\n하지만 그게 다가 아닙니다. 리모트 플레이어는 호평받는 듀얼센스 무선 컨트롤러에서 발견되는 첨단 기술을 활용합니다. 이는 적응형 트리거와 햅틱 피드백을 경험하게 해줘서 모든 행동이 더 다이나믹하고 현실적으로 느껴집니다. 게임 속에 직접 들어간 것만큼 실감 나죠.\n\n가장 흥미로운 점은 무엇일까요? 플레이스테이션 포털 리모트 플레이어는 매력적인 $199.00의 가격으로 이용할 수 있으며, 무료 반품 혜택까지 제공합니다. 거실의 한계를 벗어나 게임 여행을 확장시킬 수 있는 게임 체인저인 이 제품을 확인해보세요.\n\n당신의 게이밍 경험을 향상시킬 준비가 되었나요? 이 업데이트는 곧 출시될 예정이니, 내일부터 플레이스테이션 게임의 새로운 세계에 뛰어들 준비를 해보세요!\n","ogImage":{"url":"/assets/img/2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow_0.png"},"coverImage":"/assets/img/2024-06-23-BigSystemSoftwareUpdateforPlayStationPortalRemotePlayerArrivesTomorrow_0.png","tag":["Tech"],"readingTime":2},{"title":"편안한 게임 장르, 이제 과포화 상태일까","description":"","date":"2024-06-23 22:11","slug":"2024-06-23-CouldtheCozyGameGenrebegaspOversaturated","content":"\n저번에 소개한 Cozy Games에 관한 제 마지막 글 이후로 (얼마 지나지 않은) 새해에는 해당 장르에 더 많은 관심이 집중되고 있음을 알게 되었습니다. 2024년에는 YouTube 동영상과 글로 20개 이상의 새로운 cozy game 게임이 출시되는 것을 볼 수 있는데, cozy game 장르가 너무 일찍 포화되고 있는 것은 아닌가하는 의문이 듭니다.\n\n작년에는 이미 Dreamlight Valley, Fae Farm, Palia, Coral Island과 같은 농장 게임이 많이 출시되었으며, 저는 지난 글에서 게임이 더 많아질수록 더 넓은 영향을 줄 것이라고 주장했지만, 현재 시장은 해당 장르를 잠재적인 수익원으로 보고 있는 것으로 보입니다.\n\n## Cozy Games의 증가\n\nThe Sims, Animal Crossing 시리즈, Story of Seasons 프랜차이즈 등을 통해 언제나 편안한 게임의 개념이 존재해 왔지만, \"cozy games\"라는 용어는 지난 2년간 큰 관심을 받아 지난 크리스마스에 정점을 찍었습니다. 빠른 Google 트렌드 검색 결과는 2020년 이후로 용어의 인기가 증가하고 있음을 보여주고 있으며, 최근 Animal Crossing 출시로 인해 이러한 트렌드가 증가한 것으로 보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_0.png\" /\u003e\n\n높은 수요에는 큰 공급이 따른다. 이전의 첫인격 슈팅 게임과 배틀 로얄 게임이 유행했던 것처럼, 현기증난 것도 온 가족을 따라 숨은 팬데믹을 따라오는 안락함을 찾는 이들의 급증을 포착한 회사들은 가능한 빨리 유행을 타기로 결정했습니다. 디즈니의 드림라이트 밸리와 아발란치의 호그와트 레거시가 훌륭한 예시입니다.\n\n안타깝게도, 안락 게임을 대량 생산하려는 러시는 종종 저질 제품으로 이어졌습니다, 바로 패스트 패션의 아이디어와 닮은. 알렉시아 달린은 자신의 글 \"안락한 게임의 패스트 패션화\"에서 다음과 같이 설명합니다:\n\n그래서 우리가 이미 존재하는 안락 게임 풀에 이미 과잉인 것으로 보이는 똑같은 농장 기능, 동일한 도구 및 동일한 제어를 통합한 또 다른 게임을 만나면, 우리는 새로운 장르와 기존과 이미 많은 겹치는 메타포에 보입니다. 해당 장르는 현재 너무 혼잡한 것으로 보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 새로운 장르 흐름\n\n많은 아늑한 게임에서 농업이 주요하게 다뤄지긴 하지만, 이것은 필수적인 요소는 아닙니다. 이 장르는 그것이 일으키는 느낌으로 정의되며, 그 매커니즘만으로만이 아닙니다. 따라서 많은 개발자들이 이 장르가 곧 자신의 라벨을 벗어나게 될 수도 있다고 언급했습니다.\n\n예를 들어, 몬트리올에 본사를 둔 Alblune의 공동 창업자인 루시 레스큐이어(Lucie Lescuyer)는 최근 발매된 The Spirit and the Mouse를 통해 \"사람들은 지금 게임이 다르다는 것을 이해할 수 있도록 라벨이 필요합니다... 폭력적이지 않습니다. 그러나 몇 년 안에 라벨이 사라질 수도 있습니다. 모두에게 그러한 유형의 게임들을 즐기는 것이 보편화될 것이기 때문입니다.\"\n\n그렇다, 특히 농업 매커니즘의 유입이 2023년에 급증했지만, 게임들은 더욱더 \"아늑함\"을 느끼게 하는 다양한 주제나 매커니즘을 탐구하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_1.png)\n\n몇몇 아늑한 게임들은 더 많은 탐험 메커니즘(리틀 캣, 빅 시티)이나 티니 글레이드와 메멘토와 같은 장식 게임들이 인지도를 높이고 있습니다.\n\n저는 아늑한 게임에서 이야기 요소가 없어서는 안 된다고 믿습니다. 이야기에 열정을 가지고 있으며 전투 메커니즘 없이도 이야기를 전달할 수 있는 완벽한 매체로 게임이 있다고 봅니다. 따라서, 아늑한 장르 내의 개발자들은 여전히 우리에게 기대 이상의 농장 경험을 제공하는 새로운 게임을 혁신하고 있다고 생각합니다.\n\n## 걱정 마세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아늑한 게임 장르가 포화 상태에 이르렀을까요? 어쩌면 그럴 수도 있어요. 회사들이 트렌드를 잡아들고, Stardew Valley의 성공을 모방하려고 노력하고 있기는 한 것 같아요. 그러나 또한 우리에게 안락한 느낌을 줄 수 있는 매체를 통해 자신들의 이야기를 전하고 싶어하는 개발자들도 있다고 믿어요.\n\n어떤 다른 장르와 마찬가지로 조금의 선별이 필요할지도 모르겠지만, 아늑한 게임들은 여전히 더 넓은 관객들을 유치하고 있습니다. 이 장르에 사람들이 적극적으로 찾고 있는 것을 알게 된 게임 스튜디오에 충분히 관심을 둔 사람들이 있어서 우리는 감사해해야 합니다. 더 많은 관심. 더 많은 게임. 더 많은 편안함. 왜 안 될까요?\n\n읽어 주셔서 감사합니다! 만약 제 글이 마음에 드셨다면, 다른 기사들도 중계로 확인해 보세요. 여기서도 제 소셜 미디어를 확인할 수 있어요.\n","ogImage":{"url":"/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_0.png"},"coverImage":"/assets/img/2024-06-23-CouldtheCozyGameGenrebegaspOversaturated_0.png","tag":["Tech"],"readingTime":4},{"title":"플레이어를 따라오는 리쉬 구현 방법  개발 블로그 24","description":"","date":"2024-06-23 22:10","slug":"2024-06-23-Leashtofollowplayerdevblog24","content":"\n게임에 새로운 도구가 추가되었습니다 - 리드입니다. 이 도구는 동물을 \"플레이어를 따르도록\" 또는 \"따르지 않도록\" 전환하는 데 사용됩니다.\n\n저는 이 전환을 어떻게 구현할지 오랜 시간 고민했고 처음에는 리드를 사용하고 싶지 않았습니다. 그러나 마침내 모든 옵션 중에서 리드가 가장 논리적이고 직관적인 것으로 결론이 났습니다. 실제로 동물은 리드에 묶여 있는 것이 아니며, 플레이어에 물리적으로 묶여 있지 않고 먹이를 먹으러 다닐 수 있습니다. 오히려 \"나를 따라와\" 또는 \"나를 따르지 말아라\"라는 표시와 비슷합니다. 현실적으로 들리지 않을 수 있지만, 게임 속에서는 (적어도 저에게는) 일반적인 게임 논리처럼 느껴집니다.\n\n동물 위로 마우스를 가져가면 이제 \"따르는 중\" 또는 \"따르지 않는 중\"이라고 표시됩니다. 나중에는 이를 텍스트 없이 표시하고 싶지만, 아직 최적의 방법을 고려 중입니다 (동물의 외관을 변경할까요? 영구적인 라벨을 추가할까요? 캐릭터에 연결하는 선을 그릴까요? 동물 주변에 어떤 효과? 따르는 동물들의 초상화를 어딘가에 그릴까요?).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-06-23-Leashtofollowplayerdevblog24_1](/assets/img/2024-06-23-Leashtofollowplayerdevblog24_1.png)\n\nI also drew animations for the kittens to eat and sleep, so now they eat and sleep nicely.\n\n![2024-06-23-Leashtofollowplayerdevblog24_2](/assets/img/2024-06-23-Leashtofollowplayerdevblog24_2.png)\n\nI slightly adjusted the logic for how an animal recognizes that it’s near food or a bed. If the cat’s rectangle and the bed’s rectangle overlap, then the cat is at the target. Previously, an overlap was counted if they intersected by even one pixel. Now there are three types:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 적어도 한 픽셀 이상 겹침\n- 중간으로 겹침\n- 완전히 겹침\n\n고양이는 이제 침대 위에 완전히 올라가서 눕고 자야 해요.\n\n![고양이](https://miro.medium.com/v2/resize:fit:1400/1*GcFnFoDejJB1cV4l-uP2cg.gif)\n\n그리고 고양이는 음식 위에 반이라도 올라가서 먹어야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*NGkoOBqXnR9MaUpWq6e40g.gif)\n\n현재, 새끼 고양이는 플레이어가 먹는 것과 같은 음식을 먹을 수 있고 배부름도 100%가 됩니다. 하지만 미래에는 그들만의 음식이 생기고, 그 음식은 다른 배고픔 영향을 가질 것입니다.\n","ogImage":{"url":"/assets/img/2024-06-23-Leashtofollowplayerdevblog24_0.png"},"coverImage":"/assets/img/2024-06-23-Leashtofollowplayerdevblog24_0.png","tag":["Tech"],"readingTime":3},{"title":"현대 웹 API 이해하기 Part 1 RESTful API 사용법","description":"","date":"2024-06-23 22:09","slug":"2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs","content":"\n# 소개\n\nAPIs (Application Programming Interface)는 현대 웹 개발의 필수 요소가 되었습니다. 이를 통해 클라이언트와 서버를 분리하여 클라이언트가 UI/UX에 집중할 수 있도록 하며, 복잡한 비즈니스 로직을 이해하지 않고도 백엔드와 상호작용할 수 있게 합니다.\n\n다양한 종류의 웹 API 중에서 RESTful, GraphQL 및 gRPC가 가장 두드러지는데요. 이 블로그에서는 RESTful API에 대해 자세히 살펴보면서 원칙, 이점 및 실용적인 사용법을 탐구해 보겠습니다.\n\n# RESTful API란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nREST은 Representational State Transfer의 약자입니다. 이 용어는 2000년 Roy Fielding의 박사 학위 논문에서 처음 소개되었습니다. REST는 API를 구축하기 위한 도구나 기술이 아니라 웹 자원 사이의 일관된 인터페이스를 설계하기 위한 제약 조건과 원칙의 집합입니다.\n\n# RESTful API 설계의 주요 원칙\n\n## 자원 중심 디자인\n\nRESTful API에서 모든 것이 자원으로 간주되며 URI (Uniform Resource Identifier)로 식별될 수 있습니다. 자원은 컬렉션 또는 개별 항목이 될 수 있습니다. 예를 들어:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- collections: /customers\n- item: /customers/1\n\n리소스 간에도 연관 관계가 있습니다.\n\n- 연결된 컬렉션: /customers/1/orders\n- 연결된 항목: /customers/1/orders/2\n\n리소스는 단순히 데이터베이스의 테이블이 아닙니다. 대신 API를 통해 주소 지정 및 조작할 수 있는 데이터 모음을 나타냅니다. 응용 프로그램이 도메인 주도 설계(DDD)를 사용하는 경우, 도메인(또는 집계)을 리소스의 경계를 정의하는 주요 고려 사항으로 삼는 것이 좋습니다. 이 접근 방식은 비즈니스 도메인과 논리적으로 일치하고 유지 관리하기 쉬운 API를 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n또한, 프론트엔드 요구 사항을 충족하기 위해 API 설계를 최적화하는 것이 중요합니다. 이는 API 성능을 개선하고 전반적인 사용자 경험을 향상시킬 수 있습니다.\n\n## HTTP 표준\n\nRESTful API는 표준 HTTP 메소드를 활용하여 CRUD(Create, Read, Update, Delete) 작업을 수행합니다.\n\n- POST: 새로운 리소스 생성\n- GET: 단일 또는 여러 리소스 검색\n- PUT: 단일 또는 여러 리소스 업데이트\n- DELETE: 단일 또는 여러 리소스 삭제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이러한 API들은 주로 HTTP/1.1에 의존하며, 이는 클라이언트와 서버 간의 각 상호작용이 하나의 요청과 응답 쌍으로 이루어진 텍스트 기반 통신 프로토콜입니다. RESTful API는 일반적으로 JSON 형식으로 데이터를 교환합니다. 또한 미디어 유형을 활용하여 데이터 형식을 지정합니다.\n\n- Content-Type: 리소스의 미디어 유형을 나타냅니다 (예: application/json, application/problem+json)\n- Accept: 클라이언트가 허용할 미디어 유형을 지정합니다 (예: application/json)\n\n## 상태 없음(Statelessness)\n\nRESTful API에서 요청은 상태를 유지하지 않아야 합니다. 각 요청에는 처리에 필요한 모든 정보가 포함되어 있어 백엔드가 각 요청을 독립적으로 처리할 수 있게 합니다. 이는 요청이 순차적이지 않아도 되고, 병렬로 여러 서버가 요청을 처리할 수 있도록 합니다. HTTP가 본질적으로 상태를 유지하지 않기 때문에 RESTful API가 HTTP 프로토콜에 적합하게 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 장점\n\n## 간편성\n\nRESTful API는 복잡한 리소스를 다룰 때라도 쉽게 이해하고 구현할 수 있습니다. 표준 HTTP 메서드와 명확한 URL 구조의 사용은 개발자가 신속하게 대상 리소스를 확인하고 수행 중인 작업을 이해할 수 있도록 도와줍니다.\n\n## 널리 사용되며 신뢰성이 검증됨\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRESTful API는 산업 전반에 널리 채택되어, 다양한 성공 사례와 모범 사례가 있습니다. 라우팅, 데이터 직렬화, API 테스트와 같은 일반적 작업을 위한 준비된 솔루션도 많이 있습니다.\n\n## 확장성\n\n상태가 없는 특성 때문에 RESTful API는 쉽게 확장할 수 있습니다. 웹 애플리케이션은 여러 웹 서버에 요청을 분산하여 많은 수의 요청을 수용할 수 있습니다. 따라서 RESTful API는 클라우드 환경과 분산 시스템에 잘 어울립니다.\n\n# 더불어\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## API 스키마\n\nRESTful API는 데이터 교환을 위해 JSON을 일반적으로 사용하며 유연한 스키마를 제공합니다. 그러나 이 유연성은 때로는 프론트엔드와 백엔드 간 불일치로 이어질 수 있습니다. 예를 들어 프론트엔드 엔지니어가 응답의 일부로 문서화된 속성이 실제 백엔드 응답에서 누락된 문제에 직면할 수 있습니다.\n\n이러한 문제를 완화하기 위해 API 주도 설계는 백엔드 및 프론트엜드 구성 요소를 구현하기 전에 API 스키마를 먼저 정의하는 것을 권장합니다. OpenAPI와 같은 도구는 이러한 프로세스를 용이하게하기 위해 HTTP API를 설명하는 공식 표준을 제공하여 개발자가 API 스키마를 명확하게 지정하고 API 모델 및 클라이언트를 자동으로 생성할 수 있도록 지원합니다. 이를 통해 양쪽 모두가 미리 정의된 계약에 맞추어 효율적으로 개발하고 일치하게 할 수 있습니다.\n\n## 버전 관리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n웹 API를 개발할 때는 항상 역호환성을 보장하는 것이 중요합니다. 이러한 호환성을 유지할 수 없을 때는 API 버전 관리가 필요합니다. 호환되지 않는 변경 사항이 발생할 때마다 버전 번호가 증가합니다.\n\nRESTful API는 URL 버전 관리, 쿼리 문자열 버전 관리 및 HTTP 헤더 버전 관리와 같은 다양한 버전 관리 방법을 지원합니다. URL 버전 관리의 예로는 api.example.com/v1/customers가 있습니다.\n\n# 학습 자료\n\n웹에서 찾은 가장 좋은 RESTful API 학습 자료 중 하나입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 링크를 확인해보세요: [Azure API 디자인에 대한 최상의 모범 사례](https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design). 여기에 유용한 정보가 많이 있을 거예요! 😊\n","ogImage":{"url":"/assets/img/2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs_0.png"},"coverImage":"/assets/img/2024-06-23-UnderstandingModernWebAPIsPart1RESTfulAPIs_0.png","tag":["Tech"],"readingTime":6},{"title":"건축 알아야 할 필수 요약 정보","description":"","date":"2024-06-23 22:08","slug":"2024-06-23-ArchitectureThecheatsheet","content":"\n![Architecture Patterns](/assets/img/2024-06-23-ArchitectureThecheatsheet_0.png)\n\n이 논문은 다양한 소프트웨어 아키텍처 패턴, 모델, 철학 및 전략에 대한 간결한 요약을 제공하여 이러한 패턴의 독특한 특성, 응용 및 소프트웨어 디자인에 미치는 영향에 대한 통찰을 제공합니다. 이러한 패턴은 현대 소프트웨어 공학에서 주요 접근 방식과 전략을 대표하며 각각 특정 요구 사항과 도전에 대응합니다. 이 패턴은 특정 필요에 가장 적합한 접근 방법을 선택하는 아키텍트와 개발자를 지원하는 것을 목표로 합니다.\n\n소프트웨어 아키텍처 패턴은 소프트웨어 개발 중복잡한 아키텍처적 도전에 대응하기 위해 사용되는 기본 지침입니다. 이는 반복되는 문제에 대한 구조화된 솔루션을 제공하여 효율성, 확장성 및 유지보수 가능성을 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Backend For Frontend (BFF)\n\n개별 프런트엔드 애플리케이션의 요구 사항에 맞춘 특정 백엔드 서비스를 생성하여 통신 및 데이터 전달을 최적화하는 것을 포함합니다.\n\n주요 포커스: 특정 프런트엔드 애플리케이션에 맞춘 백엔드 서비스 생성.\n\n장점: 통신 및 데이터 전달을 최적화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n## Trade-offs\n\n- 중복 로직 발생 가능\n- 추가 유지보수 필요\n\n## 발행/구독 패턴\n\n주요 내용: 메시징 시스템에서 생성자와 소비자 간의 결합도 낮춤.\n\n장점: 확장성 향상 및 시스템 유연성 제고, 비동기 통신 지원.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 트레이드오프: 메시지 관리 복잡성 증가, 브로커 신뢰에 의존.\n\n## 사이드카 패턴\n\n주요 응용 프로그램 기능을 향상하거나 확장하는 데 중점을 둡니다.\n\n혜택: 기능을 격리하고 모듈화하며, 유지 보수가 쉬워집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 Markdown 형식으로 변경해보세요.\n\n| Trade-offs              | Can increase system complexity, additional resource consumption. |\n| ----------------------- | ---------------------------------------------------------------- |\n| **Data-Driven Testing** |                                                                  |\n| **Focus**               | Enhancing testing processes by using data-driven methodologies.  |\n| **Benefits**            | Increases test coverage, improves efficiency.                    |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n타협: 철저한 데이터 관리가 필요하며, 데이터 관련 오류가 발생할 수 있습니다.\n\n## 회로 차단기\n\n분산 시스템의 실패를 고상하게 처리하고, 고장이 전파되지 않도록 막아주는 방법을 제공합니다. 전기 회로 차단기처럼 작동하여, 서비스 고장 시 요청의 흐름을 중지시켜 회복을 허용합니다.\n\n주요 기능: 분산 시스템에서 고장 처리.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혜택: 서비스들이 복구할 시간을 확보하여 연쇄 실패를 방지합니다.\n\n희생 요소: 잘못된 경계 값을 피하기 위해 신중한 임계값 설정이 필요합니다.\n\n## API 게이트웨이\n\n클라이언트로부터 요청을 관리하고 라우팅하는 중간 계층 역할을 하는데, 통합된 인터페이스, 보안 및 기타 횡단 관심사를 제공하여 다양한 서비스로 요청을 라우팅합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n읽기 및 쓰기 작업을 구별하여 별도의 모델로 최적화하여 성능과 확장성을 향상시킵니다, 특히 복잡하고 고수요 환경에서 특히 유용합니다.\n\n핵심: 읽기 및 쓰기 작업을 분리합니다.\n\n혜택: 성능과 확장성을 최적화합니다.\n\n타협: 복잡성을 더하며, 최종 일관성 문제를 발생시킬 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 아웃박스 패턴\n\n분산 시스템에서 신뢰할 수 있는 메시지 전달을 보장하는 도구로, 특히 마이크로서비스 아키텍처에서 메시지를 전달하기 전에 일시적으로 저장합니다.\n\n주요 포인트: 분산 시스템에서 신뢰할 수 있는 메시지 전달을 보장합니다.\n\n이점: 전송 실패 중에 데이터 유실을 방지합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTrade-offs: 구현 복잡성 추가, 지연 가능성이 발생할 수 있습니다.\n\n## 멀티 테넌시\n\nKeycloak를 사용하여 인증을 수행하고, Angular와 Springboot를 각각 프론트엔드 및 백엔드 개발에 사용하여 멀티 테넌트 시스템을 구현하는 방법에 대해 논의합니다.\n\n중점: 특정 기술을 사용하여 멀티 테넌트 시스템을 구현하는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n혜택: SaaS 애플리케이션에서 효율적인 인증 관리.\n\n희생해야 할 점: 복잡한 설정, 여러 기술 통합이 필요함.\n\n## 아키텍처 안티 패턴\n\n소프트웨어 아키텍처에 대한 일반적인 함정과 ‘안티 패턴’을 강조하여 건강하고 효율적인 소프트웨어 시스템을 유지하기 위해 피해야 할 내용에 대한 통찰을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 아키텍처 도구\n\n이 섹션에서는 아키텍처 실무를 향상시키기 위해 사용되는 모델, 철학 및 전략에 대해 설명합니다. 이들은 패턴으로 간주되지 않지만 여전히 훌륭한 시스템을 구축하는 데 매우 유용합니다.\n\n## C4 모델\n\n소프트웨어 아키텍처의 포괄적인 시각화를 제공하는 데 초점을 맞추며, Context, Containers, Components 및 Code 네 가지 수준으로 분해합니다. 서로 다른 추상화 수준에서 소프트웨어 구조를 이해하고 소통하는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n중점: 소프트웨어 아키텍처 시각화 - 네 가지 수준을 통해\n\n혜택: 소프트웨어 구조의 이해와 커뮤니케이션 강화\n\nTrade-offs: 작은 시스템에는 너무 복잡할 수 있음\n\n## Domain-Driven Design (DDD)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n소프트웨어 디자인을 도메인 복잡성에 밀접하게 맞추며, 모델 주도 접근 방식을 사용합니다. 기술 및 도메인 전문가 간의 협업을 강조하여 공통 언어와 공유된 이해를 만들어냅니다.\n\n중점: 소프트웨어 디자인을 도메인 복잡성에 맞추기\n\n장점: 협업을 용이하게 하고 공통 언어를 만들어냄\n\n불리한 점: 도메인에 대한 심층적인 이해가 필요하며, 복잡할 수 있음\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Strangler Pattern\n\n레거시 시스템의 일부를 점진적으로 대체하여 새로운 기술로의 원활한 이행 및 업데이트를 가능하게 하는 것을 목표로 합니다.\n\n주요 내용: 레거시 시스템의 점진적인 대체\n\n혜택: 기존 기능을 중단하지 않고 점진적 업데이트가 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTrade-offs: 느리고 자원을 많이 소비할 수 있습니다.\n\n저는 디지털 회사의 CTO이자 건축 부서장입니다. 기술 전략의 개발, 솔루션 설계 및 R\u0026D 프로젝트를 주도적으로 진행하고 있습니다.\n\n읽어주셔서 감사합니다! 이 기사가 마음에 드셨다면, 👏을 눌러주시고 다른 사람들이 이를 발견할 수 있도록 도와주세요. 아래 댓글 섹션에 의견을 공유해주세요.\n\n# Scub Lab\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나기 전에:\n\n- 작가에게 박수를 보내고 팔로우해주세요! 👏\n- lab.scub.net에서 더 많은 콘텐츠를 찾아보세요! 🚀\n- 무료 주간 뉴스레터에 가입해주세요. 🗞️\n- 트위터(X), 링크드인, 그리고 우리의 웹사이트에서 우리를 팔로우해주세요.\n","ogImage":{"url":"/assets/img/2024-06-23-ArchitectureThecheatsheet_0.png"},"coverImage":"/assets/img/2024-06-23-ArchitectureThecheatsheet_0.png","tag":["Tech"],"readingTime":9},{"title":"트위터가 4000억 이벤트를 처리하는 방법을 개선한 비결","description":"","date":"2024-06-23 22:06","slug":"2024-06-23-HowTwitterimprovedtheprocessingof400billionevents","content":"\n# 소개\n\nTwitter는 약 400억 건의 이벤트를 실시간으로 처리하고 매일 페타바이트의 데이터를 생성합니다. Twitter는 분산 데이터베이스, Kafka, Twitter 이벤트 버스 등과 같은 다양한 이벤트 소스에서 데이터를 소비합니다. 여기에서 블로그의 구현을 찾을 수도 있습니다.\n\n![이미지](/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_0.png)\n\n이 블로그에서는 다음을 이해하려고 노력할 것입니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 트위터가 이벤트를 처리하는 방식 및 이 방식에 대한 문제점은 무엇이 있었나요?\n- 어떤 비즈니스와 고객 영향으로 인해 트위터가 새 아키텍처로 전환하게 되었나요?\n- 새 아키텍처\n- 이전 및 새로운 아키텍처의 성능 비교\n\n트위터는 다음과 같은 내부 도구 세트를 보유하고 있습니다.\n\n- Scalding은 트위터가 배치 처리에 사용하는 도구입니다.\n- Heron은 트위터의 스트리밍 엔진입니다.\n- TimeSeriesAggregator(TSAR)는 배치 및 실시간 처리에 사용됩니다.\n\n이벤트 시스템이 어떻게 발전했는지 자세히 파헤치기 전에, 네 개의 내부 도구에 대해 간략히 알아보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Scalding\n\n스콜딩(Scalding)은 하둡 맵리듀스 작업을 쉽게 지정할 수 있도록 도와주는 스칼라 라이브러리입니다. 스콜딩은 하둡의 하위 세부 사항을 추상화하는 자바 라이브러리인 카스케이딩(Cascading) 위에 구축되어 있습니다. 스콜딩은 Pig와 비교할 수 있지만, 스칼라와 강하게 통합되어 있어 스칼라의 장점을 하둡 맵리듀스 작업에 가져다줍니다.\n\n2. Heron\n\n아파치 헤론(Heron)은 트위터의 자체 스트리밍 엔진으로, 페타바이트에 이르는 대량의 데이터를 처리하고, 개발자 생산성을 향상시키고, 디버깅을 단순화해야 하는 시스템의 필요성으로 개발되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n헤론에서 스트리밍 애플리케이션을 위한 구조를 토폴로지라고 합니다. 토폴로지는 데이터-컴퓨팅 요소를 나타내는 노드와 해당 요소 간에 흐르는 데이터 스트림을 나타내는 엣지로 이루어진 방향성 비순환 그래프입니다.\n\n노드에는 2 종류가 있습니다:\n\n- 스파우트: 데이터 원본에 연결되어 데이터를 스트림에 삽입합니다.\n- 볼트: 수신된 데이터를 처리하고 데이터를 방출합니다.\n\n![그림](/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n더 많은 정보를 보시려면 여기를 참고해주세요: [https://blog.x.com/engineering/en_us/a/2015/flying-faster-with-twitter-heron](https://blog.x.com/engineering/en_us/a/2015/flying-faster-with-twitter-heron)\n\n3. TimeSeriesAggregator\n\n![Image](/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_2.png)\n\nTwitter의 데이터 엔지니어링 팀은 매일 일괄 및 실시간으로 수조 건의 이벤트를 처리하는 과제에 직면했습니다. TSAR는 프레임워크 기반의 강력하고 확장 가능한 실시간 이벤트 시간대 시계열 집계 도구로, tweet과의 상호 작용을 집계하며 장치, 참여 유형 등 다양한 차원을 따라 분할하여 주로 참여 모니터링을 위해 구축되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n트위터에서 어떻게 일이 처리되었는지 대략적으로 살펴보겠습니다. 트위터의 모든 기능은 전 세계에 10만 개 이상의 인스턴스로 퍼져 있는 마이크로서비스에 의해 지원됩니다. 이들은 이벤트를 생성하고, 이를 이벤트 집계 레이어로 보내는 역할을 합니다. 이 이벤트 집계 레이어는 메타에서 제공하는 오픈 소스 프로젝트를 기반으로 구축되었으며, 이벤트를 그룹화하고 집계 작업을 실행하며 데이터를 HDFS에 저장하는 역할을 합니다. 그런 다음 이러한 이벤트를 처리하고 형식을 변환하여 데이터를 다시 압축하여 잘 생성된 데이터 세트를 만들어냅니다.\n\n![이미지](/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_3.png)\n\n# 이전 아키텍처\n\n![이미지](/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n트위터의 구형 아키텍처는 람다 아키텍처를 기반으로 하고 있었어요. 이는 배치 레이어, 스피드 레이어 및 서빙 레이어로 구성되어 있어요. 배치 컴포넌트는 클라이언트가 생성한 로그이며, 이벤트 처리 후 하둡 분산 파일 시스템(HDFS)에 저장돼요. 트위터는 여러 스케일링 파이프라인을 구축하여 가공되지 않은 로그를 전처리하고 오프라인 소스로 Summingbird 플랫폼에 넣었어요. 실시간 컴포넌트 소스는 스피드 레이어의 일부인 Kafka 토픽들이에요.\n\n데이터가 처리되면 배치 데이터는 맨해튼 분산 시스템에 저장되며, 실시간 데이터는 트위터의 자체 분산 캐시인 Nighthawk에 저장돼요. TSAR 시스템(예: TSAR 쿼리 서비스)은 캐시와 데이터베이스 둘 다 쿼리하는 서빙 레이어의 일부가 돼요.\n\n트위터는 세 개의 다른 데이터 센터에 실시간 파이프라인과 쿼리 서비스를 가졌어요. 배치 컴퓨팅 비용을 줄이기 위해, 트위터는 한 데이터 센터에서 배치 파이프라인을 실행하고 데이터를 다른 두 데이터 센터로 복제해요.\n\n실시간 데이터를 캐시에 저장했을까요? 데이터베이스에 저장하는 것보다 더 좋은 이유가 떠오르시나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 오래된 아키텍처의 도전 과제\n\n이 아키텍처가 실시간 이벤트의 경우 어떤 도전 과제를 가질 수 있는지 이해해 봅시다.\n\n![이미지](/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_5.png)\n\n예를 통해 이해해 봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대규모 이벤트가 발생하면 FIFA 월드컵과 같은 큰 이벤트가 발생할 수 있습니다. 트윗 소스는 트윗 토폴로지로 많은 이벤트를 보낼 것입니다. 그러나 파싱 트윗 볼트가 이벤트를 적시에 처리하지 못해 토폴로지 내에서 백프레셔가 발생합니다. 시스템이 장기간 백프레셔 상태에 놓이면 헤론 볼트가 스파우트 라그를 축적할 수 있어 시스템의 지연 시간이 늘어날 수 있습니다. 트위터는 이러한 경우에 토폴로지 랙이 줄어드는 데 매우 오랜 시간이 걸린다고 관찰했습니다.\n\n팀이 사용한 운영 솔루션은 헤론 컨테이너를 다시 시작하여 데이터 스트림 처리를 다시 시작하는 것이었습니다. 이로 인해 이행 중에 이벤트 손실이 발생할 수 있으며, 이는 캐시의 집계된 카운트에 부정확성을 초래할 수 있습니다.\n\n이제 배치 이벤트 예제를 이해해 봅시다. 트위터는 PB 규모의 데이터를 처리하는 몇 가지 무거운 계산 파이프라인을 운영하고 맨해튼 데이터베이스에서 데이터를 시간별로 동기화합니다. 이제 시스템 동기화 작업이 1시간 이상 소요되고 다음 작업이 시작되기로 예정된 경우를 상상해 보십시오. 이는 시스템에 백프레셔가 증가하여 데이터 손실을 초래할 수 있는 상황으로 이어질 수 있습니다.\n\nTSAR 쿼리 서비스는 맨해튼과 캐시 서비스를 통합하여 클라이언트에 데이터를 제공합니다. 실시간 데이터 손실 가능성으로 인해 TSAR 서비스는 고객들에게 부정확한 메트릭을 제공할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고객과 비즈니스에 미치는 영향을 이해하는 것을 시도해 봅시다:\n\n- 트위터 광고 서비스는 트위터의 주요 수익 모델 중 하나이며, 그 성능이 영향을 받으면 그들의 비즈니스 모델에 직접적인 영향을 끼칩니다.\n- 트위터는 인상과 관련 지표에 대한 정보를 검색할 수 있는 다양한 데이터 제품 서비스를 제공하며, 이러한 서비스는 부정확한 데이터로 인해 영향을 받을 수 있습니다.\n- 이 경우에 또다른 문제는 이벤트 생성부터 사용 가능할 때까지 배치 처리 작업으로 인해 몇 시간이 걸릴 수 있다는 점입니다. 이는 클라이언트가 수행해야 할 데이터 분석이나 기타 작업이 최신 데이터를 사용할 수 없게됨을 의미합니다. 몇 시간의 시차가 발생할 수 있습니다.\n\n이제 이는 사용자가 이벤트를 생성하고 사용자가 생성하는 이벤트에 기반한 사용자의 타임라인을 업데이트하려거나 트위터 시스템과 상호 작용하는 방식에 따라 사용자에 대한 행동 분석을 수행하려면 클라이언트가 배치 작업이 완료될 때까지 기다려야함을 의미합니다.\n\n# 새로운 아키텍처\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_6](/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_6.png)\n\nTwitter의 새로운 아키텍처는 Twitter 데이터 센터 서비스와 Google Cloud 플랫폼 양쪽에 구축되었습니다. Twitter는 카파 주제를 퍼브 서브 주제로 변환하는 이벤트 처리 파이프 라인을 구축했으며, 이는 Google Cloud로 전송되었습니다. Google Cloud에서 실시간 집계를 수행하고 데이터를 BigTable에 싱크하는 스트리밍 데이터 플로우 작업이 수행되었습니다.\n\n![2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_7](/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_7.png)\n\n서빙 레이어에는 Twitter가 Twitter 데이터 센터에 프런트 엔드와 Bigtable 및 BigQuery에 백엔드가 있는 LDC 쿼리 서비스를 사용합니다. 전체 시스템은 초당 수백만 건의 이벤트를 스트리밍할 수 있으며 지연 시간이 ~10밀리초까지 낮을 수 있습니다. 높은 트래픽 시 확장이 쉽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 새로운 아키텍처는 일괄 파이프라인을 구축하는 비용을 절약해 줄 뿐만 아니라, 실시간 파이프라인에서는 트위터가 더 높은 집계 정확도와 안정적인 낮은 대기 시간을 달성할 수 있습니다. 또한, 그들은 여러 데이터 센터에서 다른 실시간 이벤트 집계를 유지할 필요가 없습니다.\n\n# 성능 비교\n\n![이미지](/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_8.png)\n\n새 아키텍처는 구 방식인 Heron 토폴로지와 비교하여 낮은 대기 시간을 제공하며 더 높은 처리량을 제공합니다. 또한, 새 아키텍처는 지연된 이벤트 계산을 처리하고 실시간 집계 중에 이벤트 손실이 없습니다. 또한, 새 아키텍처에는 일괄 구성 요소가 없어 구 방식에 있던 그것보다 설계를 단순화하고 컴퓨팅 비용을 줄입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\nTSAR로 구축된 이전 아키텍처를 트위터 데이터 센터와 구글 클라우드 플랫폼의 하이브리드 아키텍처로 이전함으로써 트위터는 수십억 이벤트를 실시간으로 처리하고 엔지니어들에게 낮은 대기 시간, 높은 정확성, 안정성, 아키텍처의 단순성 및 운영 비용 감소를 달성할 수 있었습니다.\n\nLinkedin: [Mayank Sharma의 Linkedin 프로필](https://www.linkedin.com/in/mayank-sharma-2002bb10b/)\n\n저와 모의 시스템 디자인 인터뷰 일정을 잡으려면 : [Meetapro에서 예약하기](https://www.meetapro.com/provider/listing/160769)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n나의 웹사이트: imayanks.com\n\n참고 자료:\n","ogImage":{"url":"/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_0.png"},"coverImage":"/assets/img/2024-06-23-HowTwitterimprovedtheprocessingof400billionevents_0.png","tag":["Tech"],"readingTime":10},{"title":"Docker 최신 개발 및 배포를 위한 필수 무기 ","description":"","date":"2024-06-23 22:03","slug":"2024-06-23-DockerAGoodto-HaveArsenalforModernDevelopmentandDeployment","content":"\n![Docker](/assets/img/2024-06-23-DockerAGoodto-HaveArsenalforModernDevelopmentandDeployment_0.png)\n\n소프트웨어 개발의 변화무쌍한 풍경에서 Docker는 빌드, 배포 및 애플리케이션 실행 프로세스를 최적화하는 필수 도구로 떠오르고 있습니다. 개발자, 시스템 관리자 또는 DevOps 팀의 일원이든 상관없이, Docker는 생산성과 효율성을 크게 향상시킬 수 있는 수많은 이점을 제공합니다.\n\n# Docker란?\n\nDocker는 가벼우며 휴대용 컨테이너 내에 애플리케이션을 자동으로 배포하는 오픈 소스 플랫폼입니다. 컨테이너에는 라이브러리, 시스템 도구, 코드 및 런타임과 같이 애플리케이션이 실행하는 데 필요한 모든 것이 포함되어 있습니다. 이를 통해 애플리케이션이 환경에 관계없이 일관되게 작동함이 보장됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도커를 사용하는 이유\n\n## 1. 이식성\n\n도커 컨테이너는 응용 프로그램과 해당 의존성을 캡슐화하여 다양한 환경에서 일관되게 실행되도록 보장합니다. 이는 전통적인 \"내 컴퓨터에서는 작동하는데\" 문제를 제거하고 배포 프로세스를 간단화합니다.\n\n## 2. 격리\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n각 도커 컨테이너는 자체 자원과 환경 변수를 사용하여 독립적으로 실행됩니다. 이를 통해 응용 프로그램끼리 간섭하지 않고 더 안전하고 안정적인 환경을 유지할 수 있습니다.\n\n## 3. 효율성\n\n컨테이너는 호스트 OS 커널을 공유하기 때문에 가벼워요. 이는 별도의 운영 체제가 필요한 가상 머신과는 다릅니다. 결과적으로 시스템 리소스를 더 효율적으로 사용할 수 있으며 부하가 낮아집니다.\n\n## 4. 확장성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커는 여러 컨테이너 인스턴스를 생성하여 애플리케이션을 수평 확장하는 것을 쉽게 할 수 있습니다. 이는 로드 밸런싱 및 고가용성 설정에 특히 유용합니다.\n\n## 5. 간소화된 개발 워크플로우\n\n도커는 개발, 테스트 및 프로덕션 환경을 일관되게 제공하여 개발 워크플로우를 간소화합니다. 이는 개발 주기를 가속화시키고 환경별 문제를 해결하는 데 필요한 시간을 줄입니다.\n\n# 도커 명령어 알아두면 유용합니다\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1. 도커 버전\n\n도커 이해하기 — 버전:\n\n도커 --version 명령어는 도커 설치를 확인하는 데 중요한 간단한 도구입니다. 실행하면 시스템에 설치된 현재 도커 버전을 반환합니다. 이 명령어는 특히 트러블슈팅 및 도커 컨테이너 및 이미지와의 호환성을 보장하는 데 유용합니다. 특정 기능이나 버그 수정은 새로운 릴리스에서만 사용할 수 있습니다. 도커 버전을 추적함으로써 업그레이드에 대한 정보를 얻고 종속성을 효과적으로 관리할 수 있습니다.\n\n## 2. 도커 이미지\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDocker 이미지 관리하기:\n\n`docker images` 명령어는 로컬 머신에 저장된 모든 Docker 이미지를 나열합니다. 각 이미지는 Docker 컨테이너를 생성하는 데 사용되는 템플릿으로, 모든 필요한 이진 파일, 라이브러리 및 종속성을 캡슐화합니다. 이 명령은 저장소 이름, 태그, 이미지 ID, 생성 날짜 및 크기와 같은 필수 정보를 표시합니다. 이미지를 효율적으로 관리하고, 더 이상 필요하지 않은 이미지를 식별하고 공간을 확보하는 데 도움이 됩니다. 예를 들어, 다양한 이미지에서 여러 컨테이너를 실행한 후, 낡은 이미지를 신속하게 식별하고 제거하여 깨끗하고 최적화된 Docker 환경을 유지할 수 있습니다.\n\n## 3. docker run\n\n`docker run`으로 컨테이너 실행하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 run 명령어는 도커 작업의 중심부로 지정된 이미지에서 새 컨테이너를 생성하고 시작하는 데 사용됩니다. 다양한 옵션을 사용하여 컨테이너의 런타임 동작을 조정할 수 있습니다. 이 옵션에는 대화식 터미널 세션 (-it), 백그라운드 실행 (-d), 포트 매핑 (-p) 등이 있습니다. 예를 들어 docker run -it ubuntu는 Ubuntu 컨테이너에서 대화식 터미널을 시작합니다. 이 명령어의 유연성을 통해 리소스 제한, 환경 변수, 볼륨 마운트 등을 구성하여 애플리케이션을 격리된 환경에서 신속하게 배포하고 확장할 수 있습니다.\n\n## 4. docker ps\n\ndocker ps를 사용하여 컨테이너 모니터링하기:\n\ndocker ps 명령어는 현재 실행 중인 컨테이너의 스냅샷을 제공하며 컨테이너 ID, 이미지 이름, 실행된 명령, 생성 시간, 상태, 포트 및 이름과 같은 중요 정보를 표시합니다. 기본적으로 활성 컨테이너만 나열하지만 docker ps -a를 사용하면 중지된 컨테이너를 포함한 모든 컨테이너를 표시합니다. 이 명령어는 컨테이너 상태 모니터링, 문제 식별 및 컨테이너 수명주기 관리에 필수적입니다. 예를 들어, 예상대로 작동하지 않는 컨테이너를 신속하게 식별하고 문제를 해결하는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 5. 도커 중지\n\n도커 중지로 컨테이너를 안전하게 중지하자:\n\n도커 중지 명령어는 실행 중인 컨테이너를 안전하게 중지하는 데 사용됩니다. 이 명령은 SIGTERM 신호를 보내어 컨테이너가 현재 작업을 완료하고 깨끗하게 종료되도록 합니다. 컨테이너가 지정된 시간 내에 중지되지 않으면 SIGKILL 신호를 보내어 강제로 중지시킵니다. 이 명령은 데이터 무결성을 유지하고 애플리케이션이 리소스를 해제하고 정리 작업을 수행한 다음 종료할 수 있도록 하는 데 중요합니다. 예를 들어 데이터베이스 컨테이너를 안전하게 중지하면 모든 보류 중인 트랜잭션이 올바르게 커밋됨을 보장할 수 있습니다.\n\n## 6. 도커 시작\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndocker start를 사용하여 컨테이너 시작하기: docker start 명령어는 이전에 중지된 컨테이너를 시작하는 데 사용됩니다. 새로운 컨테이너를 만들고 시작하는 docker run과 달리, docker start는 기존의 컨테이너를 다시 시작하여 이전 상태와 구성을 보존합니다. 유지보수나 업데이트 후 빠르게 작업을 재개해야 할 때 컨테이너를 다시 구성할 필요 없이 사용할 수 있어 특히 유용합니다. 예를 들어, 웹 서버 컨테이너를 중지하여 구성을 업데이트한 후, docker start `container_id`를 사용하여 신속하게 온라인으로 다시 만들 수 있습니다.\n\n## 7. docker rm\n\ndocker rm을 사용하여 컨테이너 삭제하기: docker rm 명령어는 하나 이상의 중지된 컨테이너를 삭제하는 데 사용됩니다. 이를 통해 사용하지 않는 컨테이너를 제거하여 Docker 환경을 깨끗이 유지하고 디스크 공간을 확보할 수 있습니다. 이 명령어로 실행 중인 컨테이너는 삭제할 수 없다는 점에 유의해야 합니다. 먼저 docker stop을 사용하여 중지해야 합니다. 예를 들어, 컨테이너에서 개발 빌드를 시험한 후 해당 컨테이너를 중지한 경우, docker rm `container_id`를 사용하여 혼란을 방지하고 리소스를 회수할 수 있습니다.\n\n## 8. docker rmi\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 이미지 관리하기: 도커 rmi 명령어는 로컬 저장소에서 하나 이상의 도커 이미지를 삭제하는 데 사용됩니다. 이는 디스크 공간을 관리하고 오래된 이미지를 삭제하는 데 중요합니다. 도커 rmi `이미지_아이디`를 실행하면, 도커는 해당 이미지를 사용 중인 컨테이너가 없는 경우 이미지를 삭제합니다. 예를 들어, 애플리케이션을 업그레이드하고 새 이미지를 만든 후 이전 이미지를 삭제하여 혼란을 방지하고 저장 공간을 절약할 수 있습니다. 이 명령어는 조직화되고 효율적인 도커 환경을 유지하는 데 도움이 됩니다.\n\n## 9. 도커 exec\n\n도커 exec를 사용하여 컨테이너 내에서 명령어 실행하기: 도커 exec 명령어를 사용하면 이미 실행 중인 컨테이너 내에서 명령어를 실행할 수 있습니다. 이는 디버깅, 조사 또는 컨테이너의 상태를 중지하지 않고 수정하는 데 유용합니다. 예를 들어, docker exec -it `컨테이너_아이디` bash를 실행하면 컨테이너 내에서 대화형 터미널을 열어 파일 시스템을 탐색하거나 패키지를 설치하고 로그를 확인할 수 있습니다. 이 명령어는 컨테이너와 상호작용하고 필요한 유지 관리 작업을 동적으로 수행하는 강력한 방법을 제공합니다.\n\n## 10. 도커 logs\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 로그 검색하기: 도커 로그 명령은 특정 컨테이너의 로그를 가져와서 동작을 파악하고 디버깅하는 데 도움을 줍니다. 기본적으로 이 명령어는 컨테이너의 표준 출력(stdout)과 표준 에러(stderr) 스트림을 보여줍니다. -f와 같은 옵션을 사용하여 로그를 실시간으로 추적하거나 --tail을 사용하여 마지막 몇 줄을 볼 수 있습니다. 예를 들어, docker logs -f `container_id` 명령은 웹 서버 로그를 실시간으로 모니터링할 수 있어 문제를 진단하고 컨테이너가 정상적으로 작동하는지 확인하는 데 도움이 됩니다.\n\n## 11. docker build\n\n도커 빌드로 이미지 생성하기: 도커 빌드 명령은 Dockerfile과 컨텍스트로부터 도커 이미지를 생성합니다. 컨텍스트는 지정된 경로나 URL에 있는 파일 세트입니다. 이 명령은 Dockerfile을 읽고 각 명령을 처리하여 새 이미지를 생성합니다. 예를 들어, docker build -t myapp:latest . 명령은 현재 디렉토리에 있는 Dockerfile에서 myapp:latest로 태그된 이미지를 빌드합니다. 이 명령은 일관된, 재현 가능한 환경을 만들고 응용 프로그램과 그 종속성을 캡슐화하는 데 중요합니다.\n\n## 12. docker tag\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 태그를 사용하여 이미지에 태그 지정하기: 도커 tag 명령어는 기존 이미지에 새로운 태그를 생성하여 같은 이미지를 다른 이름이나 버전으로 참조할 수 있게 합니다. 이미지 버전을 관리하고 저장소 구성을 용이하게 하는 데 유용합니다. 예를 들어, myapp:latest 이미지를 myrepo/myapp:1.0으로 태그 지정하려면 docker tag myapp:latest myrepo/myapp:1.0을 입력하면 됩니다. 이렇게 하면 myapp:latest 이미지를 myrepo/myapp:1.0으로 태그하여 원격 저장소에 푸시하거나 동일 이미지의 다른 버전을 구별하는 데 도움이 됩니다. 올바른 태그 지정은 명확한 버전 관리 시스템을 유지하고 CI/CD 파이프라인을 간소화하는 데 도움이 됩니다.\n\n## 13. 도커 푸시\n\n도커 푸시를 사용하여 레지스트리에 이미지 푸시하기: 도커 push 명령어는 로컬에 태그 지정된 이미지를 도커 허브나 비공개 레지스트리와 같은 도커 레지스트리에 업로드합니다. 이를 통해 이미지를 다른 사용자와 공유하거나 다른 기기에 배포할 수 있게 됩니다. 예를 들어, docker push myrepo/myapp:1.0를 입력하면 myapp:1.0 이미지를 Docker Hub의 myrepo 저장소로 푸시할 수 있습니다. 도커 push를 사용하면 응용 프로그램 이미지를 다양한 환경에 분산 배포하여 배포의 일관성과 신뢰성을 보장할 수 있습니다.\n\n## 14. 도커 inspect\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 객체 검사하기: 도커 인스펙트를 통해 도커 객체를 검사할 수 있습니다. docker inspect 명령어는 컨테이너, 이미지, 볼륨 및 네트워크와 같은 도커 객체에 대한 상세 정보를 제공합니다. 이 명령은 설정, 상태 및 자원 사용량을 포함한 JSON 형식의 데이터를 반환합니다. 예를 들어, docker inspect `container_id` 명령을 실행하면 특정 컨테이너에 대한 포괄적인 세부 정보를 얻을 수 있어 문제 해결 및 구성 확인에 도움이 됩니다. 이 명령은 도커 환경을 깊이 이해하고 모든 것이 예상대로 구성되어 있는지 확인하는 데 매우 유용합니다.\n\n## 15. docker network ls\n\n도커 네트워크 목록 보기: docker network ls 명령을 사용하면 시스템에 있는 모든 도커 네트워크, 즉 브릿지, 호스트 및 오버레이 네트워크를 표시합니다. 이를 통해 네트워크 구성을 관리하고 문제를 해결하여 컨테이너가 의도한 대로 통신할 수 있도록 할 수 있습니다. 예를 들어, docker network ls를 실행하면 이름, ID, 드라이버 및 범위를 포함한 네트워크 목록이 표시됩니다. 네트워크를 이해하고 관리하는 것은 다중 컨테이너 애플리케이션을 설정하고 안전하고 격리된 통신 채널을 보장하는 데 중요합니다.\n\n## 16. docker volume ls\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 볼륨 ls를 사용하여 볼륨 관리: 도커 볼륨 ls 명령어는 시스템의 모든 도커 볼륨을 나열합니다. 볼륨은 영속적인 저장을 위해 사용되며, 컨테이너가 제거된 후에도 데이터를 지속할 수 있습니다. 이 명령어는 볼륨을 식별하고 관리하여 데이터가 올바르게 저장되며 컨테이너 간에 공유될 수 있도록 돕습니다. 예를 들어, 도커 볼륨 ls를 실행하면 모든 볼륨을 표시하여 사용되지 않는 볼륨을 찾고 정리할 수 있어 저장소 관리를 최적화할 수 있습니다.\n\n## 17. 도커 커밋\n\n도커 커밋을 사용하여 컨테이너에서 이미지 생성: 도커 커밋 명령어는 기존 컨테이너의 변경 사항에서 새 이미지를 생성합니다. 이는 컨테이너의 상태를 이미지로 저장하여 다시 사용하거나 공유하는 데 유용합니다. 예를 들어, 업데이트나 새 구성이 있는 실행 중인 컨테이너가 있다면 docker commit `container_id` mynewimage를 실행하여 해당 변경 사항을 반영한 새 이미지를 생성할 수 있습니다. 이 명령어는 미래 배포를 위해 컨테이너의 상태를 캡처하거나 개발 및 테스트 중 베이스라인 이미지를 생성하는 데 유용합니다.\n\n## 18. 도커 업데이트\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 업데이트 명령어는 실행 중인 컨테이너의 리소스 및 구성을 동적으로 조정하는 강력한 도구입니다. 이 도구를 사용하면 컨테이너를 중지시키지 않고도 성능을 최적화하고 리소스 할당을 관리하며 컨테이너화된 애플리케이션의 안정성을 향상시킬 수 있습니다. CPU 및 메모리 제한과 같은 매개변수를 실시간으로 수정함으로써 도커 업데이트를 통해 변화하는 요구 사항과 워크로드에 효과적으로 대응할 수 있으며, 컨테이너가 원활하고 효과적으로 작동할 수 있도록 필요한 리소스를 확보할 수 있습니다.\n\n```js\ndocker update — memory 512m \u003ccontainer_id\u003e\n```\n\n## 19. 도커 시스템 프룬\n\n도커 시스템 프룬 명령어는 사용되지 않는 컨테이너, 네트워크, 이미지(둘 다 둔각하거나 참조되지 않는 이미지), 그리고 선택적으로 볼륨을 모두 제거하여 깨끗하고 효율적인 도커 환경을 유지하는 데 필수적인 도구입니다. 이러한 사용되지 않는 객체들은 시간이 지남에 따라 상당한 디스크 공간과 리소스를 소비할 수 있으며, 이는 혼잡하고 효율적이지 못한 설정으로 이어질 수 있습니다. 도커 시스템 프룬을 실행하여 빠르게 공간을 확보하고 도커 환경을 최적화함으로써 가벼우면서도 효율적으로 유지할 수 있습니다. 이 명령어는 특히 사용하지 않는 구성 요소를 수동으로 찾아내고 삭제하지 않고도 시스템을 원할하게 유지하고자 하는 개발자와 시스템 관리자들에게 매우 가치 있는 도구입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 20. docker save\n\n도커 save 명령어는 도커 이미지를 tar 아카이브 파일로 내보내는 데 사용됩니다. 이미지 백업 및 배포를 관리하는 중요한 도구로 작용합니다. 도커 이미지를 tar 파일로 저장함으로써 사용자는 다른 환경 간의 이동을 보장하고 오프라인 전송을 용이하게 할 수 있습니다. 해당 명령어를 사용하면 개발, 테스트 및 프로덕션 환경 간에 이미지를 이동하거나 Docker 레지스트리에 직접 액세스 할 수 없는 협업자들과 이미지를 공유하는 작업이 단순화됩니다. docker save는 전체적으로 도커 이미지 관리에서 유연성과 신뢰성을 향상시키며 효율적인 워크플로와 백업 전략을 지원합니다.\n\n```js\ndocker save -o myapp.tar myapp:latest\n```\n\n## 21. docker load\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 로드 명령어는 Docker 이미지를 tar 아카이브 파일에서 Docker 환경으로 가져오는 데 사용됩니다. 이 명령어는 다양한 시스템 및 환경 간에 Docker 이미지를 배포하고 관리하는 데 필수적입니다. docker save로 생성된 tar 파일에서 이미지를 로드함으로써 사용자들은 빠르게 백업을 복원하거나 인터넷에 직접 액세스할 필요 없이 이미지를 오프라인으로 공유하거나 애플리케이션을 배포할 수 있습니다. 이는 개발, 테스트 및 운영 환경 간에 Docker 이미지를 전송하는 프로세스를 간소화하여 신속한 배포와 운영의 연속성을 보장합니다. 전반적으로, 도커 로드는 이미지 이식성을 유지하고 효율적인 도커 워크플로우를 용이하게 하는 데 중요한 역할을 합니다.\n\n```js\n도커 로드 \u003c myapp.tar\n```\n\n## 22. docker restart\n\n도커 재시작 명령어는 하나 이상의 실행 중인 도커 컨테이너를 정상적으로 재시작하는 데 사용됩니다. 이를 통해 컨테이너를 완전히 중지하지 않고 새로고침할 수 있어서 기본 애플리케이션의 구성 변경이나 업데이트에 유용합니다. 도커 재시작을 사용하면 컨테이너가 상태와 구성을 유지하면서 변경 사항을 원활하게 통합할 수 있습니다. 이 명령어는 다운타임과 중단을 최소화하여 운영 환경에서 도커화된 애플리케이션의 가용성과 성능을 유지하는 데 필수적인 도구입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 다시 시작하기: `docker restart abc123`\n\n## 23. 도커 스탯\n\n도커 스탯 명령어는 실행 중인 도커 컨테이너의 자원 사용량에 대한 실시간 정보를 제공합니다. 도커 스탯을 실행하여 CPU 사용량, 메모리 소비량, 네트워크 I/O, 그리고 각 컨테이너의 블록 I/O와 같은 주요 메트릭을 모니터링할 수 있습니다. 이 명령어는 도커 환경에서 성능 모니터링, 용량 계획, 그리고 문제 해결을 위한 중요한 도구입니다. 지속적으로 업데이트되는 데이터 스트림을 표시하여 사용자가 리소스 병목 현상을 식별하고 컨테이너 구성을 최적화하며 효율적인 자원 할당을 보장할 수 있습니다. 총론적으로, 도커 스탯은 도커화된 애플리케이션의 자원 활용을 실시간으로 확인함으로써 애플리케이션의 건강과 안정성을 유지하는 데 중요한 도구입니다.\n\n도커 스탯:\n\nCONTAINER ID   NAME         CPU %     MEM USAGE / LIMIT    MEM %     NET I/O       BLOCK I/O   PIDS\na8d65c28c29f   webapp       0.50%     32MiB / 1GiB         3.20%     280kB / 12kB  0B / 0B     2\neb5a6e74b99d   database     1.20%     256MiB / 2GiB        12.80%    1.2MB / 45kB  0B / 0B     5\nf6e49f3d2a1e   cache        0.10%     64MiB / 1GiB         6.40%     800kB / 2MB   0B / 0B     1\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 24. 도커 킬\n\n도커 킬 명령어는 실행 중인 도커 컨테이너를 강제로 종료시켜주는 것으로, SIGKILL 신호를 보내어 컨테이너 내의 모든 프로세스를 즉시 중지시킵니다. 도커 스톱과 달리 우아한 종료(SIGTERM 후 필요한 경우 SIGKILL)를 시작하지 않고, 클린업이나 종료 절차를 우회합니다. 이는 무응답이거나 문제가 있는 컨테이너를 빠르고 갑작스럽게 중지하는 방법으로, 즉각적인 종료가 필요한 상황에서 주로 사용됩니다. 예를 들어 문제 해결 중이거나 정상적인 중지 방법이 작동하지 않을 때 사용됩니다.\n\n## 25. 도커 탑\n\n도커 탑 명령어는 Linux의 top 명령어가 작동하는 방식과 유사하게, 도커 컨테이너 내에서 실행 중인 프로세스를 간결하게 보여줍니다. 프로세스는 해당하는 프로세스 ID(PID), 사용자, 누적 CPU 시간 및 실행 중인 명령어와 함께 나열됩니다. 이 명령어는 도커 컨테이너 내에서의 실시간 모니터링과 문제 해결에 유용하며, 운영자 및 개발자는 빠르게 활성 프로세스를 식별하고 자원 활용률을 분석하며 성능 문제를 진단할 수 있습니다. 컨테이너 내부 동작에 대한 중요한 가시성을 제공하여 도커화된 애플리케이션을 효율적으로 관리하고 최적화하는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 상단 \u003c컨테이너 ID\u003e\n\n도커 상단 my-nginx\n\nPID    USER     TIME        COMMAND\n1      root     0:00        nginx: master process nginx -g daemon off;\n7      nginx    0:00        nginx: worker process\n\n## 26. 도커 cp\n\n도커 cp 명령어는 도커 컨테이너와 로컬 파일 시스템 간에 파일이나 디렉토리를 복사하는 데 사용됩니다. 이 명령어는 호스트 머신과 실행 중인 컨테이너 간, 또는 컨테이너 자체 간에 데이터 전송을 용이하게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예시:\n\n도커 컨테이너에서 ID가 abc123인 파일인 example.txt를 호스트 머신의 현재 디렉토리로 복사하려면 다음을 사용합니다:\n\ndocker cp abc123:/path/to/example.txt ./example.txt\n\n반대로 로컬 파일 시스템에서 도커 컨테이너로 파일을 복사하려면 다음을 사용합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndocker cp ./localfile.txt abc123:/path/inside/container/\n\n요약하면, 도커 명령어는 현대적인 컨테이너화된 애플리케이션 개발 및 배포에 필수적인 포괄적인 도구 세트를 형성합니다. 이미지를 생성하는 docker build와 컨테이너를 시작하는 docker run과 같은 기본적인 명령어부터 축적 및 확장과 같은 차원에서의 응용 프로그램을 관리하는 프로세스를 간소화하는 Docker는 여러 환경에서 응용 프로그램을 관리하고 확장하는 과정을 단순화합니다. docker-compose는 다중 서비스를 쉽게 정의하고 관리할 수 있는 오케스트레이션 능력을 향상시킵니다. docker stats를 통해 컨테이너 성능 모니터링이 용이하고, 문제 해결과 디버깅은 docker logs와 docker exec를 통해 용이해집니다. docker cp를 사용하면 컨테이너와 호스트 시스템 간에 원활한 파일 전송이 가능하며, 효율적인 데이터 관리를 지원합니다. 종합적으로, Docker 명령어는 개발자와 운영팀이 효율적으로 응용 프로그램을 구축, 배포 및 유지 관리할 수 있도록 돕습니다. 소프트웨어 개발 수명주기에서의 민첩성과 신뢰성을 유지합니다.\n```\n","ogImage":{"url":"/assets/img/2024-06-23-DockerAGoodto-HaveArsenalforModernDevelopmentandDeployment_0.png"},"coverImage":"/assets/img/2024-06-23-DockerAGoodto-HaveArsenalforModernDevelopmentandDeployment_0.png","tag":["Tech"],"readingTime":17},{"title":"NET 8에서 헬스 체크 구현하는 방법","description":"","date":"2024-06-23 22:01","slug":"2024-06-23-ImplementingHealthChecksinNET8","content":"\n\u003cimg src=\"/assets/img/2024-06-23-ImplementingHealthChecksinNET8_0.png\" /\u003e\n\nHealth checks are critical for monitoring the status of your applications and services. They offer a fast and automated method to ensure that your application's dependencies and components are functioning correctly.\n\nThis article will delve into how to implement health checks in a .NET 8 web application.\n\n## Why Health Checks in ASP.NET Applications?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n헬스 체크는 애플리케이션 내에서 문제점을 사전에 식별할 수 있게 도와주어 사용자에 영향을 미치기 전에 그 문제를 해결할 수 있는 기회를 주는 중요한 도구입니다. 정기적으로 애플리케이션 구성 요소들의 건강 상태를 확인하는 것은 더욱 신뢰성이 높고 견고한 시스템을 유지할 수 있도록 도와줍니다.\n\nASP.NET 애플리케이션을 개발할 때, 이는 종종 데이터베이스, 파일 시스템, API 등과 같은 다양한 하위 시스템에 의존합니다. 가장 흔한 시나리오 중 하나는 데이터베이스에 대한 의존성입니다. 사실 거의 모든 애플리케이션은 데이터베이스와의 원활한 상호 작용을 필요로 하며 이는 핵심 시스템 구성 요소로 작용합니다. 그러나 기존의 애플리케이션 개발은 종종 이 부분을 간과하고 데이터베이스와의 연결이 끊어지는 경우 잠재적인 고장을 야기할 수 있습니다.\n\n예를 들어 애플리케이션이 데이터베이스에 의존하는 상황을 생각해봅시다. 다양한 이유로 데이터베이스에 대한 연결이 끊겨버리면 애플리케이션이 작동하지 않을 가능성이 높습니다. 이 상황은 헬스 체크가 왜 유용한지의 기본적인 예시이지만, 그들의 개발의 전체적인 범위를 충분히 이해하기에는 부족합니다. 따라서,\n\n## 데이터베이스 예제를 깊게 들어가 ASP.NET 헬스 체크가 어떻게 더 큰 규모에서 중요한지 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 데이터베이스 연결을 설정하기 전에 데이터베이스의 가용성을 확인할 수 있다면 어떨까요?\n  — — 애플리케이션의 중요한 하위 시스템의 상태와 가용성을 사전에 확인할 수 있는 기능을 갖고 있다면 어떨까요? 데이터베이스 연결이 끊겨 갑작스럽게 애플리케이션 오류가 발생하는 대신, 가용성을 선행적으로 확인할 수 있다면 좋지 않을까요?\n- 데이터베이스 가용성 시나리오를 우아하게 처리할 수 있는 애플리케이션이 있다면 어떨까요?\n  — — 데이터베이스에 접속할 수 없는 상황에서 사용자 친화적인 메시지를 표시하는 기능을 애플리케이션이 갖고 있다면 어떨까요? 사용자들을 혼란스럽게 만드는 암호화된 오류 메시지가 아닌 중요 구성 요소의 가용성을 원활하게 전달할 수 있다면 사용자 경험이 향상되지 않을까요?\n- 가용하지 않을 때 대비해 대체 데이터베이스로 원활하게 전환할 수 있다면 어떨까요?\n  — — 주 데이터베이스가 가용하지 않을 경우 대비하여 대체 데이터베이스로 순조롭게 전환할 수 있는 유연성을 고려해보세요. 이는 애플리케이션의 연속성을 유지할 뿐만 아니라 사용자들이 최소한의 중단이 발생하도록 보장합니다.\n- 상태 확인에 따라 대체 환경으로 스위치할 로드 밸런서를 지시할 수 있다면 어떨까요?\n  — — 애플리케이션의 상태를 로드 밸런서에게 전달할 수 있는 능력을 상상해보세요. 데이터베이스가 없거나 다른 심각한 문제로 인해 애플리케이션이 건강하지 않다고 판단되면 로드 밸런서는 지능적으로 트래픽을 대체 환경으로 리디렉션하여 지속적인 서비스 가용성을 보장합니다.\n\nASP.NET Health Checks를 통해 다음을 수행할 수 있습니다:\n\n- 시스템의 건강 상태와 가용성을 평가합니다.\n- 다른 시스템에 애플리케이션의 건강 상태를 알리기 위한 엔드포인트를 생성합니다.\n- 다른 시스템의 건강 확인 엔드포인트를 사용합니다.\n\n이러한 건강 확인 기능은 느슨하게 연결된 애플리케이션이 종속되어 있는 시스템의 건강을 알아야 하는 마이크로서비스 환경을 위해 특별히 디자인되었습니다. 그러나 다양한 하위 시스템과 인프라에 의존하는 단일 애플리케이션에서도 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# .Net 8에서 건강 점검을 구현하는 방법\n\n.NET 8에서 건강 점검 구성 방법을 두 가지로 보여드리겠습니다.\n\n# 섹션 1: 기본 건강 점검 설정\n\n이 섹션은 응용 프로그램의 건강 점검을 위한 기초를 구축하는 데 목적이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNuGet 패키지 설치 필요\n다음 NuGet 패키지가 설치되어 있는지 확인하세요:\n\n1. Microsoft.Extensions.Diagnostics.HealthChecks\n\nHealth Checks 서비스 추가\nProgram.cs에 필요한 헬스 체크 서비스를 DI 컨테이너에 추가하세요:\nProgram.cs\n\n```js\nbuilder.Services.AddHealthChecks();\n\n//HealthCheck Middleware\napp.MapHealthChecks(\"/api/health\");\n```\n\n이것들을 .NET 8 웹 API에 추가한 후, 애플리케이션을 성공적으로 실행하세요. 브라우저를 사용해 다음 엔드포인트로 이동하세요:\nhttps://localhost:44333/swagger/feedbackservice/index.html\n웹 API의 상태를 확인하려면 다음으로 이동하세요:\nhttps://localhost:44333/api/health\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n엔드포인트를 호출한 뒤에 웹 API가 \"Healthy\"임을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-ImplementingHealthChecksinNET8_1.png)\n\n이 엔드포인트를 호출하면 웹 API가 \"Healthy\"로 표시되는 것을 확인해야 합니다. 현재 단계에서는 애플리케이션의 전체적인 건강을 보장하기 위해 기본 건강 점검이 설정되어 있지만 부속 시스템에 대한 구체적인 건강 점검은 아직 구현되지 않았음을 알립니다.\n\n# 섹션 2: 건강 점검으로 구현\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고객님을 위한 개인화된 건강 체크를 통한 첨단 모니터링\n이 섹션에서는 .NET 8 웹 API의 중요 구성 요소를 모니터링하는 데 맞춤형 건강 체크를 구현하는 구체적인 예시를 살펴보겠습니다. 이러한 체크는 기본 설정을 뛰어넘어 응용 프로그램의 건강 상태에 대한 보다 상세하고 통찰력 있는 관점을 제공합니다.\n\n필요한 NuGet 패키지\n다음 NuGet 패키지가 설치되어 있는지 확인하세요:\n\n1. Microsoft.Extensions.Diagnostics.HealthChecks\n2. AspNetCore.HealthChecks.SqlServer\n3. AspNetCore.HealthChecks.UI\n4. AspNetCore.HealthChecks.UI.Client\n5. AspNetCore.HealthChecks.UI.InMemory.Storage\n6. AspNetCore.HealthChecks.Uris\n\n참고: 별도의 HealthCheck.cs 파일을 만들고 모든 건강 체크 구성을 구현했습니다.\n\n## a. 데이터베이스 건강 체크\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터베이스 헬스 체크는 애플리케이션의 웰빙을 모니터링하는 중요한 측면입니다. 특히 데이터 저장 및 검색을 위해 데이터베이스를 사용하는 경우에는 더욱 중요합니다. 이 헬스 체크는 데이터베이스가 연결 가능하고 쿼리에 응답할 수 있는지 확인합니다.\n\nHealthCheck.cs\n\n```csharp\npublic static void ConfigureHealthChecks(this IServiceCollection services, IConfiguration configuration)\n{\n    services.AddHealthChecks()\n        .AddSqlServer(configuration[\"ConnectionStrings:DefaultConnection\"], healthQuery: \"select 1\", name: \"SQL Server\", failureStatus: HealthStatus.Unhealthy, tags: new[] { \"Feedback\", \"Database\" });\n\n    //services.AddHealthChecksUI();\n    services.AddHealthChecksUI(opt =\u003e\n    {\n        opt.SetEvaluationTimeInSeconds(10); //체크 간 시간(초)\n        opt.MaximumHistoryEntriesPerEndpoint(60); //체크 히스토리 최대\n        opt.SetApiMaxActiveRequests(1); //API 요청 동시성\n        opt.AddHealthCheckEndpoint(\"피드백 API\", \"/api/health\"); //헬스 체크 API 맵핑\n\n    })\n        .AddInMemoryStorage();\n}\n```\n\n`configuration[\"ConnectionStrings:DefaultConnection\"]`은 구성에서 연결 문자열을 검색하여 데이터베이스 연결 구성을 유연하게 설정할 수 있습니다.\n`failureStatus: HealthStatus.Unhealthy`는 헬스 체크 실패 시 전체 헬스 상태를 건강하지 않음으로 표시해야 함을 나타냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로그램.cs에서 ConfigureHealthChecks()를 구성하세요.\n\n```js\n// Health Check 구성\nbuilder.Services.ConfigureHealthChecks(builder.Configuration);\n\n// Health Check 미들웨어\napp.MapHealthChecks(\"/api/health\", new HealthCheckOptions()\n{\n    Predicate = _ =\u003e true,\n    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse\n});\napp.UseHealthChecksUI(delegate (Options options)\n{\n    options.UIPath = \"/healthcheck-ui\";\n    options.AddCustomStylesheet(\"./HealthCheck/Custom.css\");\n});\n```\n\n결과:\nEndpoint: /api/health\n\n\u003cimg src=\"/assets/img/2024-06-23-ImplementingHealthChecksinNET8_2.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n엔드포인트: /healthcheck-ui\n\n![health-check-screenshot](/assets/img/2024-06-23-ImplementingHealthChecksinNET8_3.png)\n\n## b. 원격 엔드포인트의 건강 상태 확인\n\n다음으로, 원격 엔드포인트 및 메모리의 건강 상태를 확인하는 작업을 구현할 것입니다.\nRemoteHealthCheck.cs\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```csharp\nusing Microsoft.Extensions.Diagnostics.HealthChecks;\nusing System;\nusing System.Net.Http;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace FeedbackService.Api\n{\n    public class RemoteHealthCheck : IHealthCheck\n    {\n        private readonly IHttpClientFactory _httpClientFactory;\n        public RemoteHealthCheck(IHttpClientFactory httpClientFactory)\n        {\n            _httpClientFactory = httpClientFactory;\n        }\n        public async Task\u003cHealthCheckResult\u003e CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = new CancellationToken())\n        {\n            using (var httpClient = _httpClientFactory.CreateClient())\n            {\n                var response = await httpClient.GetAsync(\"https://api.ipify.org\");\n                if (response.IsSuccessStatusCode)\n                {\n                    return HealthCheckResult.Healthy($\"Remote endpoint is healthy.\");\n                }\n\n                return HealthCheckResult.Unhealthy(\"Remote endpoint is unhealthy\");\n            }\n        }\n    }\n}\n```\n\n이 health check은 HTTP 요청을 통해 원격 엔드포인트(예: API)의 상태를 모니터링합니다.\n\n## b. 메모리 헬스 체크\n\n마지막으로 API 서비스의 메모리 상태를 모니터링하는 health check을 구현해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMemoryHealthCheck.cs\n\n```js\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Diagnostics.HealthChecks;\nusing Microsoft.Extensions.Options;\n\nnamespace FeedbackService.Api.HealthCheck\n{\n    public class MemoryHealthCheck : IHealthCheck\n    {\n        private readonly IOptionsMonitor\u003cMemoryCheckOptions\u003e _options;\n\n        public MemoryHealthCheck(IOptionsMonitor\u003cMemoryCheckOptions\u003e options)\n        {\n            _options = options;\n        }\n\n        public string Name =\u003e \"memory_check\";\n\n        public Task\u003cHealthCheckResult\u003e CheckHealthAsync(\n            HealthCheckContext context,\n            CancellationToken cancellationToken = default(CancellationToken))\n        {\n            var options = _options.Get(context.Registration.Name);\n\n            // Include GC information in the reported diagnostics.\n            var allocated = GC.GetTotalMemory(forceFullCollection: false);\n            var data = new Dictionary\u003cstring, object\u003e()\n        {\n            { \"AllocatedBytes\", allocated },\n            { \"Gen0Collections\", GC.CollectionCount(0) },\n            { \"Gen1Collections\", GC.CollectionCount(1) },\n            { \"Gen2Collections\", GC.CollectionCount(2) },\n        };\n            var status = (allocated \u003c options.Threshold) ? HealthStatus.Healthy : HealthStatus.Unhealthy;\n\n            return Task.FromResult(new HealthCheckResult(\n                status,\n                description: \"Reports degraded status if allocated bytes \" +\n                    $\"\u003e= {options.Threshold} bytes.\",\n                exception: null,\n                data: data));\n        }\n    }\n    public class MemoryCheckOptions\n    {\n        public string Memorystatus { get; set; }\n        //public int Threshold { get; set; }\n        // Failure threshold (in bytes)\n        public long Threshold { get; set; } = 1024L * 1024L * 1024L;\n    }\n}\n```\n\n이 Health Check은 Feedback Service의 메모리 상태를 할당된 바이트를 기반으로 평가합니다.\n\n이제 HealthCheck.cs 내부에서 RemoteHealthCheck.cs와 MemoryHealthCheck.cs를 구성합시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHealthCheck.cs\n\n```js\npublic static void ConfigureHealthChecks(this IServiceCollection services, IConfiguration configuration)\n{\n    services.AddHealthChecks()\n        .AddSqlServer(configuration[\"ConnectionStrings:Feedback\"], healthQuery: \"select 1\", name: \"SQL 서버\", failureStatus: HealthStatus.Unhealthy, tags: new[] { \"Feedback\", \"Database\" })\n        .AddCheck\u003cRemoteHealthCheck\u003e(\"원격 엔드포인트 헬스체크\", failureStatus: HealthStatus.Unhealthy)\n        .AddCheck\u003cMemoryHealthCheck\u003e($\"피드백 서비스 메모리 체크\", failureStatus: HealthStatus.Unhealthy, tags: new[] { \"피드백 서비스\" })\n        .AddUrlGroup(new Uri(\"https://localhost:44333/api/v1/heartbeats/ping\"), name: \"기본 URL\", failureStatus: HealthStatus.Unhealthy);\n\n    //services.AddHealthChecksUI();\n    services.AddHealthChecksUI(opt =\u003e\n    {\n        opt.SetEvaluationTimeInSeconds(10); // 각 체크 사이의 시간(초)\n        opt.MaximumHistoryEntriesPerEndpoint(60); // 체크 이력 최대 갯수\n        opt.SetApiMaxActiveRequests(1); // API 요청 동시성\n        opt.AddHealthCheckEndpoint(\"피드백 API\", \"/api/health\"); // 헬스체크 API 매핑\n\n    })\n        .AddInMemoryStorage();\n}\n```\n\n**출력:**\nEndpoint: /api/health\n\n![ImplementingHealthChecksin.NET8.4](/assets/img/2024-06-23-ImplementingHealthChecksinNET8_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEndpoint: /healthcheck-ui\n\n![Health Check](https://assets/img/2024-06-23-ImplementingHealthChecksinNET8_5.png)\n\n여기 있습니다! 웹 API 내에서 몇 가지 헬스 체크를 성공적으로 구현했습니다. 이러한 체크를 통해 응용 프로그램이 모니터링되고 웰빙이 보장되도록 할 수 있습니다. .NET 8의 헬스 체크의 힘으로 견고하고 견고한 응용 프로그램을 계속하여 만들어보세요! 😍\n\n![Resilient Applications](https://miro.medium.com/v2/resize:fit:996/1*ECmfhzVd4avHlD_B1-gocg.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n.NET 8 애플리케이션에 건강 점검을 구현하는 것은 탄탄하고 안정적인 시스템을 구축하기 위한 중요한 단계입니다. 내장 및 사용자 정의 건강 점검을 통해 응용 프로그램과 해당 종속성의 상태를 모니터링하여 더 원할한 사용자 경험을 제공할 수 있습니다.\n\n본 문서에서는 응용 프로그램에 건강 점검을 추가하는 기본 사항을 다루었으며, 고유한 요구에 맞춰 점검을 자세히 사용자 정의할 수 있습니다. 응용 프로그램을 계속 개발하는 과정에서 시스템 건강의 다양한 측면을 커버하기 위해 추가적인 점검 항목을 추가하는 것을 고려해 보세요. 정기적인 검토 및 업데이트를 통해 건강 점검을 유지하면 강력하고 반응 빠른 응용 프로그램을 유지할 수 있습니다.\n\n더 자세한 정보와 고급 구성에 대해서는 AspNetCore.Diagnostics.HealthChecks 저장소를 참조하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저자: Jeslur Rahman 😍\n","ogImage":{"url":"/assets/img/2024-06-23-ImplementingHealthChecksinNET8_0.png"},"coverImage":"/assets/img/2024-06-23-ImplementingHealthChecksinNET8_0.png","tag":["Tech"],"readingTime":15},{"title":"회사 회의가 너무 많나요 회의 지옥에서 벗어나는 방법","description":"","date":"2024-06-23 21:59","slug":"2024-06-23-TooManyMeetingsatWorkHeresHowToStoptheMeetingMadness","content":"\n![텍스트](/assets/img/2024-06-23-TooManyMeetingsatWorkHeresHowToStoptheMeetingMadness_0.png)\n\n회의가 너무 많았어요. 그 달에 그 세 단어를 너무 많이 말했습니다. 때로는 제 스스로에게 피가 없는 노골적인 말로. 때로는 일의 현재 상태에 대한 과잉한, 자기중심적인 불만으로 자기 불쌍해 하는 형태로.\n\n제가 빠져든 구덩이에서 벗어나 깨어 나기 위해 큰 소리로 외칠 대신, 그것을 인생의 한 부분으로 받아들였어요: \"이게 정상인 거고, 뭘 많이 할 수 없어.\" 어쨋든, 의도적으로 매니저로서 참여한 것이고, 회의가 많아보였어요.\n\n몇 달이 지나고, 상황은 더 나빠졌어요. 제 역할 범위가 늘어나고, 팀 규모도 거의 두 배로 늘어나고, 회의 수도 늘어났어요. 제 시간을 완전히 잃었어요. 하루 종일 한 날갯짓하는 듯한 류의 압단이었고, 한 회의에서 다음 회의로 움직이기만 하며, 지쳐, 헷갈리며, 불평만 하게 되었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 조직과 팀을 사랑했지만 내 일에 대해서는 자신이 없었어요. 너무 많은 회의가 쉽게 탈출구가 되고, 내 시간과 주의를 요구하는 일을 피하는 핑계가 되어버렸거든 — 미래를 위한 계획 수립, 팀을 위한 더 나은 기회 발굴, 내 학습에 투자하기 등에요.\n\n하루가 끝날 때면, 내가 진정한 가치를 더했는지 의심이 들었어요. 맞아, 일에서 많은 멋진 프로젝트를 이끌고 있었지만, 충분하지 않다고 느꼈어요. 일에서 효과적이지 못한 느낌은 저를 소진시켰어요.\n\n\"회의가 너무 많다\"나 \"이것이 매니저의 삶이다\"란 핑계에 너무 오래 매달려왔어요. 진실해지는 시간이 왔어요. 내 삶을 엄격하게 살펴보고 상황의 현실을 직시하고 싶어했어요. 뻔뻔한 것을 넘어설 의지가 있었고 일에 이성을 가해보고 싶었어요.\n\n그 과정은 간단한 목표로 시작됐어요: 내 시간을 다시 통제하고 가치를 더하는 일을 하려는 것이었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론, 회의에 소요되는 시간을 최적화하는 것이 이 목표를 달성하는 데 큰 요소였어요. 그것부터 시작했죠. 내 디폴트 모드로 돌아가는 것을 피하기 위해 작은 변화부터 시작하기로 결정했습니다.\n\n매주 나는 내 캘린더를 살펴보고 이러한 질문을 스스로에게 던졌어요:\n\n- 이 회의에 어떻게 가치를 더할까요?\n- 이 회의에서 무엇을 배울 수 있을까요?\n- 내 자리를 대신할 수 있는 사람이 있는가요?\n- 이 회의에 참석하지 않으면 어떻게 될까요?\n\n이러한 간단한 질문들은 내 캘린더의 모든 회의에 참석하는 내 디폴트 모드 대신 회의에 대한 인식을 일깨워주었어요. 아직 많은 회의에 참석했지만 일정을 통제할 수 있는 느낌은 나에게 에너지를 불어넣어 이 프로세스를 다음 단계로 이끌었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 모두를 위해 단계별 프로세스를 만들어 시간을 더 잘 관리할 수 있는 방법을 찾았습니다. 그 방법은 회의를 시간 채우는 용도로 사용하는 것을 그만두고 가치를 창출하는 방향으로 바꾸는 것입니다.\n\n# \"직장에서 회의가 너무 많다\" 증후군을 극복하는 방법\n\n만약 \"아이젠하워 긴급/중요 매트릭스\"에 대해 알지 못한다면, 먼저 이 프레임워크에 대한 기본적인 이해를 확립하는 것을 제안합니다. 이 프레임워크는 아래에서 제시된 전략을 실행할 때 매우 유용하게 활용됩니다.\n\n## 단계1: 중요한 작업을 위한 시간 블록 사전 설정 (미팅 없는 활동)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n중요한 작업들은 당신과 당신의 조직에 장기적 가치를 창출합니다. 이들은 당신의 팀과 조직을 다음 수준으로 이끌어 줄 고려 활동들이며, 고완력 활동입니다.\n\n매니저이자 리더로서, 당신의 역할 중 큰 부분은 당신 팀의 미래를 고민하고, 그 미래가 어떻게 전개될지 계획하며, 이를 실현하기 위해 조치를 취하는 것입니다. 팀 내 다른 사람들은 이 일을 대신할 수 없습니다.\n\n매주 당신의 달력에 시간을 할애해 이러한 활동들을 위한 시간을 확보하세요. 이러한 활동들을 위한 시간을 미리 예약함으로써, 긴급한 일에 빠져 중요한 활동을 늦추는 상황을 피할 수 있습니다. 또한 이는 당신이 집중적으로 주의를 요하는 작업을 우선시하고, 회의 시간을 줄이도록 돕습니다.\n\n## 단계 2: 필수 회의 일정 잡기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 1단계와 비슷하지만 여기서는 회의 시간을 사전에 블록하는 단계입니다. 네, 회의 수를 줄이려고 노력 중이라는 것을 알고 있지만, 반드시 회의해야 하고 동시에 가치 있는 회의를 식별하는 것이 그 목표 중 하나입니다. 어떤 회의에 대해 확신이 없다면 이 단계에서 일단 미뤄두세요.\n\n모든 회의가 시간 낭비는 아닙니다. 당신이 매니저나 리더라면 1:1 미팅, 스킵-레벨 미팅, 이해 관계자 업데이트 및 직원 미팅과 같은 회의는 꽤 가치가 있습니다.\n\n이를 미리 예약함으로써 당신과 팀이 중요한 회의보다는 거의 모든 회의를 우선시할 수 있습니다. 그러나 이 활동을 할 때 유의하세요. 가장 중요한 회의만 우선시하는 것은 처음에 매우 어려울 수 있습니다. 당신의 캘린더에 모든 것을 집어넣는 상황을 피하기 위해 3단계의 전략을 사용하세요.\n\n## 단계 3: 위임하고 자율을 부여\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n회의에 참여하기에 가장 적합한 사람은 당신 뿐이고 누구도 당신 자리를 대신할 수 없다고 믿는 것이 쉽습니다. 이것은 부분적으로 옳고 전체적으로 잘못된 사고입니다.\n\n네, 다른 사람들이 당신 자리를 대신할 수 없습니다. 하지만 스스로 물어야 할 질문은 다른 사람이 당신 대신에 있을 수 있는지가 아니라 다음과 같습니다:\n\n- 회의에서 충분한 일을 할 수 있는 사람은 누구인가요?\n- 더 많은 책임을 맡길 수 있는 사람은 누구인가요?\n- 그런 결정을 내릴 준비가 된 사람은 누구인가요?\n\n만약 당신이 팀 내에서 아무도 당신 자리를 대신할 수 없다고 생각한다면, 그것은 당신이 팀원들을 능력을 키우고 촉진시키지 않고 있다는 강력한 신호입니다. 당신은 팀 내의 의사 결정 병목이 되어 팀을 우수함을 향해 이끄는 대신 겨우 평범함으로 밀어붙이고 있습니다. 직원들을 능력 있게 하는 것은 상당 부분의 시간을 확보하고 직원들이 매니저들에게 신뢰받았다는 기쁨을 느낄 수 있게 하며 건강한 작업 환경을 조성합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n효율적인 위임은 당신의 업무의 중요한 부분이며, 회의를 위임하는 것도 그 중요한 부분입니다. 어떤 회의를 위임할 수 있는지 확인하거나 팀 내에서 스킬을 키워서 당신의 팀원들이 당신의 일부 회의를 대체할 준비가 되도록 하는 방법에 대해 고려해보세요.\n\n이러한 회의에 참석하지 않고 팀과 동기화하기 위해 업데이트를 이용하면 당신이 직접 회의에 참석했을 때 투자했을 것보다 훨씬 짧은 시간 동안 더 많은 일을 달성할 수 있습니다.\n\n## 단계 4: 정리하고 제거하기\n\n마지막으로, 하지 말아야 할 일을 위임하려는 것은 위임할 가치가 없는 일입니다. 회사의 미션과 목표에 부합하지 않거나 당신과 당신의 팀에 가치를 더하지 않는 회의에 대해 '아니오'라고 말할 수 있는 능력을 키워보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n몇 가지 회의는 자기 존중감과 중요성을 느끼게 해 주어서 쉽게 포기하기 어려울 수 있어요. 그런 회의는 자아 존중감을 높여주는 것 같아요. 이 결정에 갇힌 것 같다고 느낄 때, 단순히 자신에게 물어보세요: 어떤 것을 더 원하시나요? 시간이나 가치없는 자아 존중감?\n\n그런 회의들은 당신의 시간을 낭비하는 가치가 없어요. 당신이 그런 회의를 없애는 쪽이 훨씬 더 낫고, 당신이 시간과 에너지를 장기적으로 중요한 일에 투자할 때 팀 전체가 훨씬 더 좋아 질 거예요.\n\n# 회의 시간 효율적으로 관리하는 다른 전략들\n\n위의 전략을 적용함으로써 회의 시간을 상당히 줄일 수 있어요. 하지만 아직 끝났지 않아요. 귀중한 시간을 되찾기 위해 더 많은 일을 할 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1. 회의 빈도와 시간을 최적화하라\n\n진짜로 매주 팀원 개개인과 일대일 회의가 필요한가요? 만약 매주가 아니라 2주에 한 번이라면 어떨까요? 매주 회의가 2주에 한 번 회의보다 제공하는 가치는 무엇일까요? 2주에 한 번 회의가 매달 회의보다 제공하는 가치는 무엇일까요?\n\n매주, 2주에 한 번, 그리고 매달 진행되는 모든 회의를 살펴보세요. 왜 현재 빈도로 회의가 필요한 걸까요? 주간 회의 중 2주에 한 번 회의로 변경할 수 있는 회의나, 2주에 한 번 회의를 월별로 바꿀 수 있는 회의를 식별하세요. 팀원들로부터 도움을 받고 이해관계자들에게 질문하세요. 둘 다 이해할 수 있는 합의점을 찾으세요.\n\n회의 시간을 최적화하는 것은 회의에 소비되는 시간을 아끼는 훌륭한 전략입니다. 회의를 관찰하고, 유용한 토론에 얼마나 많은 시간을 소비하는지, 할당된 시간을 그냥 채우는 데 얼마나 많은 시간이 소요되는지 이해하려고 노력하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파킨슨의 법칙에 따르면, 작업은 완료 기간에 할당된 시간만큼 확장됩니다. 이 법칙은 회의에도 적용됩니다.\n\n## 2. 회의 스택 및 결합하기\n\n의존성 때문에 여러 회의를 결합하는 것이 유용할 수 있습니다. 이들을 결합하는 것은 그만의 가치가 있을 뿐만 아니라 시간도 덜 소요됩니다. 어떤 회의를 결합할 가치가 있는지 식별하는 데 시간을 투자해보세요.\n\n또 다른 유용한 전략은 유사한 회의를 연달아서 진행하는 것입니다. 이렇게 하면 회의에 쓰는 총 시간은 줄일 수 없지만 컨텍스트 전환에 소비되는 시간을 줄일 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예를 들어, 20분짜리 1:1 미팅을 하나만 하는 대신 연이어 두 번 하는 것이 유익할 수 있습니다. 첫 번째 1:1 미팅을 통해 뇌 리듬을 맞춘 다음에 두 번째 미팅이 훨씬 쉬워질 것입니다.\n\n스태킹을 접근 방식으로 사용하기 시작하면 미팅이 자동으로 최적화되어, 이 미팅의 시간을 줄이는 전략 #1을 적용해야 합니다.\n\n## 3. 월간 및 분기별 검토\n\n피드백 루프를 활용한 자기 반성은 시간이 흐름에 따라 향상될 수 있는 강력한 실천 방법입니다. 너무 많은 미팅으로 인해 상황이 하루나 한 달 안에 개선되지 않습니다. 나쁜 습관에 빠지지 않도록 당신을 지켜줄 좋은 습관을 꾸준히 실천해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 연습을 한 번에 완료할 수 없어요. 아직 끝나지 않았어요. 미래의 목표에 맞춰 행동을 조정하려면 이 연습을 계속 해야 해요. 지난 한 달 간의 캘린더를 살펴보고 다음과 같은 질문을 해보세요:\n\n- 내 시간을 대부분 어디에 사용했나요?\n- 그 모임 중 얼마나 유용한가요?\n- 나중에 실수였다고 생각되는 모임에 참석한 이유는 무엇인가요?\n- 모임에 소비한 시간을 줄이기 위해 더 할 수 있는 일은 무엇인가요?\n- 모임에 소비한 시간을 줄이기 위해 줄일 수 있는 게 무엇인가요?\n\n이 연습을 꾸준히 하면 업무를 하면서 정신을 차리고 주변 사람들에게 가치를 더할 수 있을 거예요. 다음에 \"모임이 너무 많다\"고 느낄 때, 잠시 멈춰서 그 말이 스며들게 하고 즉시 이곳에 개요된 전략을 반복할 시간을 캘린더에 예약하세요. 행운을 빕니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- \"너무 많은 회의를 한다고 느껴진다면, 그것이 당신의 직무의 일부인 것으로 가정하지 마세요. 아마도 당신과 당신의 팀에 가치를 더하지 않는 회의에 참석하고 있을 수 있습니다.\n- 회의에 쓰는 시간을 포함하여 시간을 더 잘 관리해야 합니다. 다른 사람들은 당신 대신 이를 처리할 수 없습니다.\n- 먼저, 매주 당신의 팀의 미래 계획과 같은 필수 활동을 위해 캘린더에 회의 없는 시간을 미리 차지하세요. 이 시간을 미리 차지함으로써, 회의에 시간을 적게 사용하고 일하는 동안 작업을 하며 당신과 당신의 조직을 나아가게 할 수 있습니다.\n- 다음 단계는 당신의 팀에게 절대적으로 중요한 회의, 예를 들어 1:1 미팅, 이해관계자 업데이트, 스태프 회의 등을 위한 공간을 만드는 것입니다. 이를 미리 일정에 잡아두면, 사소한 회의를 위한 여유 공간을 줄일 수 있습니다.\n- 팀원들에게 할당 가능한 회의를 확인하세요. 팀원들이 자체적으로 결정을 내리도록 함으로써, 회의에 소요되는 시간을 줄이고 행복하고 건강한 근무 환경을 조성할 수 있습니다.\n- 마지막으로, 당신의 캘린더를 정리하고 하면 안 되는 회의를 제거하세요. 이런 회의는 자아 존중감을 높일 수 있지만, 당신과 팀이 목표를 향해 나아가는 데 아무 도움이 되지 않을 수 있습니다.\n- 이러한 전략을 숙달한 후에는, 회의 빈도와 기간을 최적화하고, 회의를 합치거나 조합하며, 매달과 매 분기에 당신의 진전 상황을 검토하는 습관을 만드는 등 더 많은 시간을 확보할 수 있습니다. 자가성찰은 과거로부터 배우고 미래를 위해 더 나은 계획을 세우는 강력한 기술입니다.\n- 더 많은 이야기를 듣기 위해 여기와 LinkedIn에서 저를 따르세요. 이 이야기는 원문이 https://www.techtello.com에 게재되었습니다.\"\n","ogImage":{"url":"/assets/img/2024-06-23-TooManyMeetingsatWorkHeresHowToStoptheMeetingMadness_0.png"},"coverImage":"/assets/img/2024-06-23-TooManyMeetingsatWorkHeresHowToStoptheMeetingMadness_0.png","tag":["Tech"],"readingTime":10}],"page":"9","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"9"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>