<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/5" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/5" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_buildManifest.js" defer=""></script><script src="/_next/static/YUMR4jSyk_WlOHHc7UfOk/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="AWS에서 ECS  EC2 오토스케일링 인프라 구축하는 방법" href="/post/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS에서 ECS  EC2 오토스케일링 인프라 구축하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS에서 ECS  EC2 오토스케일링 인프라 구축하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS에서 ECS  EC2 오토스케일링 인프라 구축하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">23<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Postgres RDS가 빅데이터 솔루션 구현에 적합하지 않은 이유 우리가 겪은 문제 및 해결방안 포함" href="/post/2024-06-23-WhyPostgresRDSdidntworkforusandwhyitwontworkforyouifyoureimplementingabigdatasolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Postgres RDS가 빅데이터 솔루션 구현에 적합하지 않은 이유 우리가 겪은 문제 및 해결방안 포함" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-WhyPostgresRDSdidntworkforusandwhyitwontworkforyouifyoureimplementingabigdatasolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Postgres RDS가 빅데이터 솔루션 구현에 적합하지 않은 이유 우리가 겪은 문제 및 해결방안 포함" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Postgres RDS가 빅데이터 솔루션 구현에 적합하지 않은 이유 우리가 겪은 문제 및 해결방안 포함</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="조직 수준에서 AWS Lambda 오류 모니터링 시스템 구축하는 방법" href="/post/2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="조직 수준에서 AWS Lambda 오류 모니터링 시스템 구축하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="조직 수준에서 AWS Lambda 오류 모니터링 시스템 구축하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">조직 수준에서 AWS Lambda 오류 모니터링 시스템 구축하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS 멀티 계정 전략 I AWS Organizations, OUs, 그리고 계정 활용 방법" href="/post/2024-06-23-AWSMulti-AccountStrategyIAWSOrganizationsOUsandAccounts"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS 멀티 계정 전략 I AWS Organizations, OUs, 그리고 계정 활용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AWSMulti-AccountStrategyIAWSOrganizationsOUsandAccounts_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS 멀티 계정 전략 I AWS Organizations, OUs, 그리고 계정 활용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS 멀티 계정 전략 I AWS Organizations, OUs, 그리고 계정 활용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS 서버리스 간편 이해 Application Composer로 그리기" href="/post/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS 서버리스 간편 이해 Application Composer로 그리기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS 서버리스 간편 이해 Application Composer로 그리기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS 서버리스 간편 이해 Application Composer로 그리기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Telegram 봇 백엔드로 AWS Lambda 사용 하는 방법" href="/post/2024-06-23-UsingAWSLambdaasTelegrambotbackend"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Telegram 봇 백엔드로 AWS Lambda 사용 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Telegram 봇 백엔드로 AWS Lambda 사용 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Telegram 봇 백엔드로 AWS Lambda 사용 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Terraform으로 AWS 자원을 올바르게 태깅하는 방법" href="/post/2024-06-23-TaggingAWSresourcestherightwayusingTerraform"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Terraform으로 AWS 자원을 올바르게 태깅하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TaggingAWSresourcestherightwayusingTerraform_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Terraform으로 AWS 자원을 올바르게 태깅하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Terraform으로 AWS 자원을 올바르게 태깅하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024" href="/post/2024-06-23-ServerlessEventBridgePipes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="DynamoDB에서 Merkle Tree로 데이터 일관성 강화하는 방법" href="/post/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="DynamoDB에서 Merkle Tree로 데이터 일관성 강화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="DynamoDB에서 Merkle Tree로 데이터 일관성 강화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">DynamoDB에서 Merkle Tree로 데이터 일관성 강화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로 플레이어 네모, 스트리트 파이터 6에서 M 바이슨 주캐릭터로 선택" href="/post/2024-06-23-ProPlayerNemotoMakeMBisonHisMaininStreetFighter6"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로 플레이어 네모, 스트리트 파이터 6에서 M 바이슨 주캐릭터로 선택" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ProPlayerNemotoMakeMBisonHisMaininStreetFighter6_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로 플레이어 네모, 스트리트 파이터 6에서 M 바이슨 주캐릭터로 선택" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">프로 플레이어 네모, 스트리트 파이터 6에서 M 바이슨 주캐릭터로 선택</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link posts_-active__YVJEi" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"AWS에서 ECS  EC2 오토스케일링 인프라 구축하는 방법","description":"","date":"2024-06-23 22:40","slug":"2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS","content":"\n# 소개:\n\n대규모로 백엔드 응용 프로그램을 배포하는 것은 일관된 성능 및 가용성을 보장하기 위해 중요합니다.\n\nAWS에서 Docker 컨테이너를 배포하는 여러 방법이 있습니다. 예를 들어, EC2 인스턴스, AWS Lambda, Fargate를 사용한 ECS 및 EC2를 이용한 ECS 등이 있습니다. 이 블로그에서는 ECS와 EC2를 사용하여 자동 확장 인프라를 설정하는 방법을 안내합니다. 우리의 요구에 맞는 최적의 선택인 이유를 알아보고 AWS UI를 사용하여 인프라를 구축하며, 다음 블로그에서는 Terraform을 사용하여 관리할 것입니다. 예시로, 백엔드 응용 프로그램으로 Rick Roll Docker 이미지를 사용할 예정입니다. 😎\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 블로그 개요:\n\n- 컨테이너를 배포하는 다양한 방법\n- ECS + EC2를 선택하는 이유?\n- 다이어그램을 활용한 인프라 구조\n- 플로우 설명\n- AWS Management Console을 사용한 인프라 구축\n\n# 요구 사항:\n\n- AWS 계정: 활성화된 AWS 계정이 필요합니다.\n- AWS 서비스에 대한 기본 지식: EC2, IAM 역할, VPC, 서브넷, 보안 그룹 및 로드 밸런서에 대한 이해가 필요합니다.\n- Docker에 대한 익숙함: Docker 및 컨테이너화 개념에 대한 경험이 필요합니다.\n- 인프라 구축 경험: AWS 또는 다른 클라우드 제공업체에서 인프라를 구축한 경험이 유용합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 컨테이너 배포의 다양한 방법:\n\n도커 컨테이너를 배포하는 방법은 다양한 AWS 서비스를 통해 가능합니다. 각각의 장단점이 있습니다:\n\n- CI/CD 자동화를 활용한 EC2 머신에서 컨테이너 실행: 전체적인 제어가 가능하지만 더 많은 설정과 유지보수가 필요하며 자동으로 확장되지 않습니다. 컨테이너 오케스트레이션 서비스를 사용하는 것이 더 나을 수 있습니다.\n\n2. AWS App Runner:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 장점: 최소 구성으로 간편한 배포, 자동 스케일링.\n- 단점:\n  — 최대 4 vCPU, 12 GB RAM.\n  — 요청 횟수에 기반한 스케일링으로 CPU 또는 RAM이 아닌 요청 횟수에 따라 스케일링되어 부하를 잘못 추정했을 경우 금액 낭비나 성능 문제 발생 가능성.\n  — 서비스 생성 후 구성 변경 불가; 구성 변경을 위해 삭제 및 재생성 필요.\n  — 서비스 생성 후 구성 변경 불가; 구성 변경을 위해 삭제 및 재생성 필요.\n- 왜 부적합한가: 제한된 자원과 스케일링 메커니즘은 일관된 트래픽을 가진 진행 중인 프로젝트에 적합하지 않습니다.\n\n3. AWS Lambda: 짧은 작업에 적합하지만 콜드 스타트 문제와 메모리 및 실행 시간 제약이 있습니다.\n\n4. ECS: 강력한 컨테이너 조작, 자동화 관리 및 스케일링을 제공하여 CI/CD, AWS App Runner 또는 AWS Lambda와 비교했을 때 EC2보다 유연성과 제어 능력을 제공합니다.\n\n## 왜 ECS + EC2를 선택해야 하나요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 여러 이유로 ECS + EC2를 선택했습니다:\n\n- 컨테이너 오케스트레이션: ECS는 강력한 컨테이너 오케스트레이션 기능을 제공합니다.\n- 확장성: 높은 사용량에 따라 자동으로 스케일링할 수 있는 능력.\n- 일관된 트래픽: 안정적인 트래픽을 갖는 B2B 애플리케이션에 적합하며, AWS의 권장을 따르고 있습니다.\n- Cold Starts 회피: AWS 람다나 Fargate와 같은 서버리스 옵션과 달리, EC2의 ECS는 Cold Start 지연 문제가 없습니다.\n- 미래 지향성: ECS + EC2는 GPU 워크로드 및 높은 RAM 사용을 처리할 수 있으며, 람다, 앱 러너 또는 심지어 ECS + Fargate와 같은 서비스가 지원할 수 없습니다. 이는 애플리케이션 요구사항이 계속 발전하는 경우에도 주요 재설계 없이 대응할 수 있는 미래 지향적인 솔루션이 됩니다.\n- 제어 및 유연성: 인스턴스 유형, 스케일링 정책 및 다른 구성에 대한 완전한 제어로, 복잡한 재설계 없이 인프라를 발전시킬 수 있습니다.\n- 장기 비용 절감: Fargate는 EC2 인스턴스 관리를 추상화하지만, 안정적인 트래픽을 처리할 때 EC2 인스턴스를 직접 사용하는 것이 장기적으로 더 비용 효율적일 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_1.png\" /\u003e\n\n무서워하지 마세요. 깊게 들이마셔… 깊게 내쉬세요. 그래, 그렇습니다. 여전히 여기 있네요? 멋져요. 이해를 돕기 위해 이해해야 할 네 가지 주요 구성 요소가 있습니다: Route 53 부분, ECS 부분, 로드 밸런서 부분 및 자동 스케일링 부분입니다. 이는 이전에 이미 본 것의 상세한 버전일 뿐입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 녹색 항목은 우리 인프라에서 정의해야 하는 자원입니다. 모든 빨간색 항목은 해당 자원의 부산물입니다. 그렇기 때문에 인프라를 코드로 관리한다면, 녹색으로 표시된 모든 것을 Terraform 자원으로 정의해야 합니다.\n\n# 인프라 작동 방식:\n\n인프라스트럭처에서 ECS + EC2 자동 확장 기능이 작동하는 방법\n\n먼저 자원의 기본적인 정의부터 시작해봅시다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Route 53 호스티드 존: 특정 도메인의 DNS 레코드를 관리합니다.\n- Route 53 레코드: 귀하의 애플리케이션으로 트래픽을 라우팅하는 DNS 레코드입니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_2.png)\n\n- 로드 밸런서: 여러 대상 (EC2 인스턴스) 사이에 들어오는 애플리케이션 트래픽을 분산시킵니다.\n- 리스너: 클라이언트에서 로드 밸런서로의 연결을 위한 프로토콜과 포트를 정의합니다.\n- 대상 그룹: 트래픽을 라우팅할 대상 (EC2 인스턴스)의 논리적 그룹화입니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ECS 클러스터: 작업 및 서비스의 논리적 그룹화입니다.\n- ECS 서비스: ECS 클러스터 내의 작업을 배포하고 확장하는 서비스입니다.\n- 작업 정의: Docker 컨테이너가 어떻게 시작되어야 하는지를 지정합니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_4.png)\n\n- ECS Capacity Provider: ECS 클러스터 내에서 작업을 실행하기 위한 인프라를 관리합니다.\n- Auto Scaling 그룹: EC2 인스턴스 그룹을 관리하고 수요에 따라 자동으로 조정합니다.\n- 시작 템플릿: EC2 인스턴스를 시작하기 위한 구성 세부정보를 제공합니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 앱 자동 스케일링 정책: CPU 사용률과 같은 메트릭에 기반한 스케일링 정책을 정의합니다.\n- 앱 자동 스케일링 대상: 어떤 ECS 서비스를 스케일할지 지정합니다.\n\n# 플로우 설명:\n\n- Route 53을 이용한 DNS 구성:\n  도메인을 위한 Route 53 호스트된 존이 있으며, lb-prod.domain.com과 같은 DNS 레코드를 생성합니다. 이 레코드는 사용자 트래픽을 로드 밸런서로 보냅니다.\n- 로드 밸런서를 통한 트래픽 관리:\n\n- 로드 밸런서는 사용자로부터 트래픽을 수신합니다. EC2 인스턴스가 실행 중인 작업에 직접 트래픽을 보낼 수 없으므로 트래픽을 대상 그룹으로 전달합니다.\n- 로드 밸런서의 리스너는 트래픽 전달에 사용할 프로토콜과 포트를 정의합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 대상 그룹 및 ECS 서비스 통합:\n\n- 대상 그룹은 EC2 인스턴스에서 실행 중인 작업을 대상으로 하는 ECS 서비스에 연결됩니다.\n- ECS 서비스는 ECS 클러스터에서 작업을 관리하여 예상대로 실행되도록 합니다.\n\n4. 작업 정의 및 ECS 클러스터:\n\n- 작업 정의는 Docker 컨테이너의 세부 정보를 지정합니다. ECS 서비스는 이 정의를 사용하여 작업을 생성합니다.\n- 이러한 작업은 ECS 클러스터 내에서 실행되며, 이는 작업과 서비스의 논리적 그룹화입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n5. EC2 인스턴스에서 작업 실행:\n\n- 작업을 실행하기 위해 EC2 인스턴스에서 제공되는 인프라가 필요합니다.\n- 자동 확장 그룹은 런치 템플릿을 사용하여 EC2 인스턴스를 자동으로 시작하고 관리합니다.\n\n6. ECS Capacity Provider:\n\n- ECS 용량 제공자는 작업 실행에 필요한 인프라를 관리합니다. EC2 인스턴스가 작업 실행에 사용할 수 있는지를 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. 자동 스케일링 정책:\n\n- 앱의 자동 스케일링 정책은 CPU 사용률 임계값을 50%로 정의합니다. 평균 CPU 사용률이 이 임계값을 초과하면 ECS 용량 공급자를 사용하는 ECS 서비스가 확장되어 실행 중인 작업 수가 증가합니다.\n- 자동 스케일링 그룹은 수요에 맞게 EC2 인스턴스 수를 조정합니다.\n\n8. 앱 자동 스케일링 대상:\n\n- 자동 스케일링 대상은 스케일링 정책이 올바른 ECS 서비스에 연결되어 있는지 확인합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n9. ECS 클러스터 용량 공급자:\n\n- 이 구성 요소는 여러 ECS 용량 공급자를 추적하고 ECS 클러스터와 연결합니다. 서비스에 특정 용량 공급자가 연결되지 않은 경우 기본 전략을 적용합니다.\n\n## 요약하면 다음과 같은 흐름이 됩니다\n\n- 사용자 트래픽은 Route 53 하위 도메인 레코드를 통해 로드 밸런서로 이동됩니다.\n- 로드 밸런서는 트래픽을 대상 그룹으로 전달하여 ECS 서비스에서 관리하는 작업으로 경로 지정합니다.\n- 작업은 ECS 용량 공급자와 오토스케일링 그룹에서 관리하는 EC2 인스턴스에서 실행됩니다.\n- 오토스케일링 정책은 수요에 따라 인프라가 확장되어 최적의 성능을 유지하게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# AWS UI를 사용하여 인프라 구축하기\n\n일단 루트 53 부분은 선택 사항이며 인프라 재구성 시 로드 밸런서의 동일한 DNS가 필요한 경우에만 사용될 예정이니 지금은 건너 뛰도록 하겠습니다. 이 부분은 terraform을 통해 관리할 때 다시 설정하는 것으로 할 거에요.\n\n## 우리가 구축할 내용 개요:\n\n- 먼저 ECS 클러스터를 구축합니다\n- EC2 인스턴스를 선택할 겁니다\n- 이들을 위해 새로운 auto-scaling 그룹을 생성합니다\n- 런치 템플릿 정의\n  — 원하는 용량 정의\n  — 인스턴스 유형\n  — AMI\n  — 스토리지\n  — 사용할 키페어\n  — 서브넷\n  — 보안 그룹\n- 태스크 정의를 생성합니다\n- EC2를 런치 타입으로 설정\n- OS\n- CPU, RAM 요구 사항\n- 태스크 실행 롤\n- 사용할 이미지로 최소한 하나의 컨테이너를 정의합니다\n- 볼륨 추가\n- 컨테이너 포트 설정\n- 이제 ECS 서비스를 생성합니다\n- Capacity provider 전략\n- 태스크 패밀리\n- 원하는 태스크\n- 로드 밸런싱 (로드 밸런서 생성)\n  — 응용 프로그램 로드 밸런서\n  — 타겟 그룹\n  — 서비스 자동 확장 정책\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 단계:\n\n우선 AWS 계정에 로그인하신 후, ECS를 검색하고 열어주세요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_6.png)\n\n이제 ECS 클러스터 생성부터 시작해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- \"Create Cluster\"을 클릭하세요. 이름을 지어주세요; 저는 \"rick-roll-prod-cluster\"로 부를 거에요. 자원의 이름 짓는 규칙으로 kebab-case를 사용할 거예요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_7.png)\n\n2. \"Infrastructure\" 섹션으로 스크롤 내려가보세요. EC2 또는 Fargate 중 하나를 선택할 수 있습니다; 이전에 논의했던대로 EC2 런치 타입을 선택할 거예요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_8.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 저희는 EC2 인스턴스의 생성 및 종료를 관리할 자동 스케일링 그룹을 생성할 예정입니다.\n\n- 새로운 EC2 인스턴스를 생성하기 위해서는 ASG가 사용할 런치 템플릿을 지정해야 합니다:\n  - AMI: 이를 유지합시다.\n  - 인스턴스 유형: t2.micro로 진행합시다.\n  - EC2 인스턴스 역할: 새 역할을 생성할 것입니다.\n  - 원하는 수용 능력: 최소값을 0으로 설정하고 최대값을 4로 설정해주세요. 이는 ASG가 유지하는 ECS 클러스터의 인스턴스 수에 대한 제한입니다.\n  - SSH 키: 선택적으로 이 인스턴스에 로그인하기 위한 SSH 키를 생성하거나 무시해주세요.\n  - 볼륨: 기본값인 30으로 설정해주세요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_9.png)\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_10.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 이제 VPC 및 서브넷은 기본 설정으로 남겨두세요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_11.png)\n\n5. 새 보안 그룹을 만들고 어디에서나 HTTP 액세스를 허용하는 인바운드 규칙을 추가하세요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_12.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6. 모니터링을 활성화하고 원하는 경우 태그를 추가할 수 있습니다. 이제 클러스터를 생성하세요.\n\n![Cluster Image](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_13.png)\n\n- 시간이 걸릴 수 있지만, ASG, EC2 런치 템플릿 및 보안 그룹이 포함된 ECS 클러스터를 성공적으로 만들었습니다.\n\n태스크 정의 생성:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 태스크는 컨테이너 주변의 래퍼와 같습니다. 태스크 정의를 만들고, 그에 따라 우리의 컨테이너가 실행됩니다. 왼쪽에 있는 \"태스크 정의\"를 클릭하고, \"새 태스크 정의 생성\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_14.png)\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_15.png)\n\n2. 이름을 지정하고 EC2에서 실행하려는 것을 명시합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_16.png)\n\n3. 이제 작업 크기를 결정해야 합니다. 작업 크기는 작업(컨테이너)에 필요한 CPU 및 메모리 양을 결정합니다.\n\n- CPU를 1 vCPU로, Memory를 0.5 GB로 설정합니다. 둘 다 EC2 하드웨어(t2.micro) 한도 내에 있습니다.\n- OS 및 Network 모드는 기본 설정으로 유지합니다.\n- Task 역할을 `ecsTaskExecutionRole`로 설정합니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_17.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n4. 작업에서 실행할 적어도 하나의 컨테이너를 지정해야 합니다.\n\n- 컨테이너에 이름을 지정하세요.\n- 이미지로는 Docker Hub에서 사용 가능한 Rick Roll 이미지를 사용할 것입니다.\n- Rick Roll이 실행될 포트인 80으로 설정하세요.\n\n```js\nkale5/rickroll:vclatest\n```\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_18.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n5. 건강 상태 확인: 저희 컨테이너의 건강 상태를 모니터링하기 위해 건강 상태 확인을 설정해야 합니다. ECS 서비스는 서버가 작동 중인지 계속 확인하기 위해 이 엔드포인트를 반복해서 핑합니다. 우리 경우에는 root 엔드포인트로 curl을 수행하는 건강 상태 확인을 생성할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_19.png)\n\n6. 원하는 경우 작업 정의에 태그를 추가할 수 있습니다. 이제 \"만들기\"를 클릭하면 작업이 생성됩니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_20.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이제 ECS 클러스터와 작업 정의를 갖고 있으니 클러스터에서 작업을 시작할 수 있습니다. 그러나 작업을 자동으로 관리하고 확장하기 위해 ECS 서비스를 생성할 것입니다.\n\nECS 서비스 생성:\n\n- 이제 ECS 클러스터를 열고 “Service” 섹션을 클릭한 다음 “Create”를 클릭하세요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_21.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 컴퓨팅 옵션의 경우, 기본 설정을 사용하겠습니다. 클러스터 용량 공급자와 ECS 용량 공급자가 이미 생성되어 있습니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_22.png)\n\n3. 애플리케이션 유형은 기본값인 Service로 남겨두세요.\n\n4. 작업 정의의 경우, 이전에 정의한 작업 패밀리를 선택하세요. 가장 최신의 수정본이 자동으로 가져와집니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_23.png\" /\u003e\n\n5. 서비스에 이름을 지정해주세요. \"원하는 작업\" 섹션에서는 ECS 서비스가 ECS 클러스터에서 실행 중인 작업을 얼마나 유지할지 정의합니다. 2로 설정하면 언제나 최소 2개의 작업이 실행 중임을 보장합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_24.png\" /\u003e\n\n6. 이제 로드 밸런서를 만들고 해당 로드 밸런서를 ECS 서비스에 연결하여 ECS에 부하를 분산합니다. \"로드 밸런싱 - 선택 사항\"을 선택하여 시작하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_25.png\" /\u003e\n\n- 자세히 보기에서 로드 밸런서 유형을 ALB로 선택하세요. 컨테이너에서는 \"rick-roll-vc-image 80:80\"를 선택하세요. 새로운 로드 밸런서를 만들고 이름을 붙여주세요.\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_26.png\" /\u003e\n\n7. 아래로 스크롤하세요. 이제 새로운 리스너와 타겟 그룹을 만듭니다. 리스너는 로드 밸런서에서 타겟 그룹으로 트래픽을 보내고, 해당 타겟 그룹은 실행 중인 ECS 태스크를 대상으로합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_27.png\" /\u003e\n\n8. 이제 모든 로드 밸런서 관련 구성이 완료되었습니다. 더 아래로 스크롤하세요. 부하에 따라 확장 및 축소하려면 서비스에 대한 자동 확장 정책을 정의해야 합니다.\n\n- \"서비스 자동 확장\" 드롭다운 메뉴를 엽니다.\n- \"서비스 자동 확장 사용\" 확인란을 선택합니다.\n- 서비스가 실행되기를 원하는 최소 및 최대 작업 수를 정의합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_28.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 자동 스케일링 정책의 정책 이름을 정의하세요. 서비스 메트릭에서는 임계값으로 평균 CPU 사용률을 사용할 것입니다. 서비스가 작업을 확장하거나 축소하는 데 사용할 수 있는 다른 메트릭을 선택할 수도 있습니다.\n- 타겟 값을 50%로 설정하면, 언제든지 평균 CPU 사용률이 이 숫자를 넘어가면 시스템을 확장하고, 그 밑으로 내려가면 축소할 것입니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_29.png)\n\n9. 다른 것들은 그대로 두고 고유한 태그를 부착한 후 “생성”을 클릭하여 서비스를 만드세요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_30.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 생성 프로세스가 완료될 때까지 몇 분 정도 소요될 예정이니, 조금만 기다려 주세요.\n\n# 인프라 테스트 중:\n\n- AWS 관리 콘솔에서 \"부하 분산기\"를 검색하고 클릭합니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_31.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n2. 이제 새로 생성한 Application Load Balancer (ALB)을 찾아서 열어보세요.\n\n![ALB image](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_32.png)\n\n- DNS 레코드를 복사하고 새 탭에서 열어보세요. 이것이 우리 앱의 URL입니다 (Application Load Balancer의 DNS 레코드).\n\n![DNS record image](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_33.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 503 에러가 발생할 수 있습니다. 이는 로드 밸런서가 작동 중이지만 ECS 작업으로 트래픽이 수신되지 않음을 의미합니다. 이는 서비스가 아직 생성 중이거나 작업이 아직 시작되지 않았을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_34.png)\n\n3. 리스너, 서비스, 대상 그룹 및 작업을 확인하세요. 일부 리소스가 아직 완전히 생성되지 않은 경우가 있습니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_35.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 일정 시간이 지나면 모든 리소스가 완전히 생성되어 ​​건강한 작업이 실행되는 것을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_36.png)\n\n- 이제 로드 밸런서 DNS가 열린 탭을 새로고침해주세요.\n\n![이미지](/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_37.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 와! 우리 인프라가 작동 중이야! 🎉\n\n# 결론 및 다음 단계\n\n우리 인프라가 마침내 가동 중임을 확인할 수 있어요. 고량의 트래픽을 보내면 EC2 인스턴스에서 실행 중인 작업을 자동으로 확장하여 수요를 충족시킬 거에요.\n\n이 정도까지 오다니 축하해요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_38.png\" /\u003e\n\n다음 블로그에서는 이 인프라를 테라폼을 사용하여 코드로 변환하는 방법을 보여드리겠습니다. 이를 통해 인프라의 쉬운 사용자 정의, 수정 및 여러 버전을 제공할 수 있습니다. 현재는 여러분의 여정에 튼튼한 출발점이 될 것입니다. 테라폼을 다룬 다음 파트에 관심이 있다면 댓글을 남겨주세요. 계속해서 지켜봐 주시고 즐거운 코딩 되세요!\n\n저와 연결을 원하시나요? 여기가 제 LinkedIn입니다.\n\n# 감사의 글\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nYogendra Manawat ( SDE Intern @AiCaller.io ) : 리뷰 및 플로우를 완벽하게 만드는 데 도움을 주었습니다.\n\nChirag Panjwani ( SDE @ Genesis Technologies ): 가치 있는 피드백을 제공해 주셨습니다.\n\nSiddharth Singh Patel : 개선을 위한 제안 및 선행 조건 추가와 같은 아이디어에 대해 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoBuildanECSEC2Auto-ScalingInfrastructureonAWS_0.png","tag":["Tech"],"readingTime":23},{"title":"Postgres RDS가 빅데이터 솔루션 구현에 적합하지 않은 이유 우리가 겪은 문제 및 해결방안 포함","description":"","date":"2024-06-23 22:37","slug":"2024-06-23-WhyPostgresRDSdidntworkforusandwhyitwontworkforyouifyoureimplementingabigdatasolution","content":"\n# 배경\n\n우리는 마케팅 효과를 통계적으로 측정하는 스타트업을 만들고 있었습니다. 이를 위해 온라인 사용자 행동에 대한 많은 데이터를 수집해야 했습니다. 모든 클릭, 모든 입력 필드, 모든 액션을 모으는 작업이 필요했습니다. 데이터는 포스트그레스에 저장되었고, 최종 사용자들은 UI를 통해 상기 (때로는 매우 큰) 데이터 집합을 분석하는 대시보드 및 보고서를 실행했습니다. 여러 테넌트를 지원하는 멀티 테넌트 SAAS 애플리케이션을 구축하고 있기 때문에 데이터는 수백 개의 테넌트별로 수집되고 저장되었습니다. 이 시스템은 확장 가능하고 성능이 좋아야 했습니다. 우리는 AWS RDS 관리형 포스트그레SQL로 시작했습니다.\n\n![이미지](/assets/img/2024-06-23-WhyPostgresRDSdidntworkforusandwhyitwontworkforyouifyoureimplementingabigdatasolution_0.png)\n\n# EBS와 관련된 큰 문제: 처리량 투명성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEBS의 처리량을 정확하게 측정하는 것은 거의 불가능합니다. AWS가 제공하는 지표는 지연 시간과 IOPS입니다. 이 둘 다 처리량을 측정하는 방법은 제공하지 않습니다. 디스크에 10GB의 크기를 가지는 시간 순서 테이블(예: 2000만 개 행)을 저장하고 테이블을 스캔하려고 할 때(어떤 이유로든 - 예를 들어 순차 스캔이 필요한 경우) 디스크에서 데이터를 스캔하는 데 얼마나 오랜 시간이 걸릴지 이해하려면 처리량을 정확히 측정해야 합니다.\n\n# 폭발과 제한된 IOPS - 사태의 시작\n\n위의 쿼리와 같은 작업들은 IO 크레딧을 빨리 소진시킵니다. 우리는 더 많은 IOPS를 원하기 때문에 어떻게 해야 할까요? 당연히 스토리지 볼륨을 늘려서 작은 볼륨으로부터 얻을 수 있는 3000 IOPS보다 높은 10000 IOPS 기본선을 얻을 수 있도록 합니다. 하지만 백업 비용이 증가하게 되고, 전체 볼륨을 지불하게 되므로 비용이 증가합니다. 비용은 증가하는데 성능이 거의 개선되지 않는다 - 이러한 상황은 더 악화됩니다.\n\n우리는 또한 캐싱을 위해 더 많은 메모리를 얻기 위해 인스턴스 크기를 계속해서 늘렸습니다. 모든 것을 메모리에 맞게 만들면 DB를 빠르게 만드는 것이 쉽습니다. 불행히도 PG v10에서 제공되는 더 큰 병렬 처리는 IO 제한 때문에 실제로 많은 혜택을 가져다주지 않았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n쓰루풋을 측정하는 데 문제가 있는 내용은 여기에서 자세히 설명되어 있습니다:\n\n[https://www.datadoghq.com/blog/aws-ebs-latency-and-iops-the-surprising-truth/](https://www.datadoghq.com/blog/aws-ebs-latency-and-iops-the-surprising-truth/)\n\n# Aurora\n\n그래서 우리는 Aurora로 마이그레이션했습니다. 표준 PostgreSQL 대비 5~7배의 성능 향상을 약속받을 수 있다는 것은 놓칠 수 없는 이점입니다. 그러나 이러한 성능 메트릭은 pgbench를 기반으로 하고 있습니다 (PostgreSQL의 경우). 대규모 데이터 집합 및 데이터 마이닝 작업에 대한 성능 지표로는 적합하지 않지만 수많은 병렬 클라이언트와 함께 트랜잭션의 속도(또는 지연 시간)를 측정하고 싶은 OLTP 시스템이 있다면 이러한 결과는 훌륭합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n비용이 줄어들었는데 오히려 올라갔어요.\n\n이 글에서는 IOPS 및 요금 청구 가능한 IOPS에 관한 내용이 있습니다. https://forums.aws.amazon.com/message.jspa?messageID=835303#835303\n\n다시 한 번 가장 큰 답답함은 처리량의 정확한 측정을 얻는 데 있었습니다. 단순히 tack_io_timing을 사용하여 스캔된 데이터 양을 시간으로 나눈 것을 보면, 대규모 데이터셋에 대한 성능이 SSD 속도처럼이 아니라 자기 디스크와 유사하다는 것을 알 수 있습니다.\n\n부담스럽게 느껴지는 것 중 하나는 지원과의 끝없는 시간입니다. 지원 직원은 항상 매우 지식이 풍부하고 도움이 되려는 자세였지만, 항상 쿼리 조정이나 DB 조정에 차질이 생겼습니다. 다시 말해서 처리량에 관한 문제로 돌아왔죠. \"귀하의 작업 부하에 고려해 보기에는 이 서비스를 선택하는 것이 좋지 않다.\"는 말을 듣고 싶어했지만, 결국 우리 스스로 그것을 해결해야 했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 해결책: 직접 만들어보세요\n\n저희에게는 해결책이 꽤 간단했습니다. 관리형 데이터베이스 서비스를 사용하지 말고 EC2에서 직접 인프라를 구축했어요.\n\n저희는 상대적으로 저사양의 EC2 인스턴스(저희는 RDS에서 4XL을 실행 중이었습니다) xl과 2xl을 사용했어요.\n\n중요한 점은 마스터와 스탠바이 레플리카 간의 READ 및 WRITE 워크로드를 분리하는 것이었고, 이를 위해 WAL-G(https://github.com/wal-g/wal-g)를 사용하여 최신 상태를 유지하는 것이었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWRITE 노드는 데이터를 처리하기만 하므로 EBS가 충분했지만 ZFS를 사용하여 EBS 처리량을 2배로 늘릴 수 있었습니다.\n\nREAD 노드의 경우 일시적인 NVMe 드라이브와 다시 한 번 ZFS를 사용하여 성능을 향상시켰습니다.\n\n결과가 자연스럽게 이야기해줍니다:\n\n비용이 $11K에서 $2100으로 감소했습니다(9월에 예상되는 첫 번째 RDS 부담이 없는 완전한 한 달을 기준으로).\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아주 길고 끝이 나지 않을 쿼리도 몇 시간이 걸리거나 완전히 시간초과될 정도로 실행되던 것이 몇 초만에 완료되었어요.\n\n유닉스 인스턴스에서 명령 줄 도구(zpool iostat)를 사용하여 실제 처리량을 측정할 수 있습니다.\n\n# 결론\n\n인스턴스를 시작하고 백업과 복구에 대해 걱정하지 않고 한 번 클릭하면 편리할 수 있지만, 이는 저희의 경우에는 비용과 성능 측면에서 비용이 발생합니다. TB 또는 GB 데이터를 처리하는 데 실제 속도가 필요하다면 베어 메탈을 사용하십시오. 베어 메탈을 사용할 수 없다면 NVMe 드라이브가 장착된 EC2를 사용하는 것이 다음으로 좋은 방법입니다. NVMe 드라이브가 장착된 인스턴스를 사용하여 AWS에서 자체 Postgres 클러스터를 시작하는 방법에 대한 조리법을 제공하는 부분 두 번째를 읽어보세요.\n","ogImage":{"url":"/assets/img/2024-06-23-WhyPostgresRDSdidntworkforusandwhyitwontworkforyouifyoureimplementingabigdatasolution_0.png"},"coverImage":"/assets/img/2024-06-23-WhyPostgresRDSdidntworkforusandwhyitwontworkforyouifyoureimplementingabigdatasolution_0.png","tag":["Tech"],"readingTime":5},{"title":"조직 수준에서 AWS Lambda 오류 모니터링 시스템 구축하는 방법","description":"","date":"2024-06-23 22:36","slug":"2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem","content":"\nAWS Lambda, Amazon Web Services (AWS)의 일부입니다. 이것은 응용 프로그램이 구축되고 배포되는 방식을 변경합니다. 쉬운 확장성, 비용 절감 및 간편한 관리와 같은 많은 장점을 제공합니다. Lambda를 사용하면 서버 관리 걱정 없이 코드 작성에 집중할 수 있습니다.\n\n## 문제 설명\n\n조직적 환경에서 Lambda 함수의 활용은 종종 광범위합니다. 예를 들어 여러 리전 및 계정에 걸쳐 여러 사용자 정의 구성 규칙을 배포하는 것은 상당수의 Lambda 함수를 초래할 수 있습니다. 우리의 경우, 15개 영역에 300개 이상의 계정에 걸쳐 배포된 50개 이상의 사용자 정의 구성 규칙이 있습니다. 이 규모에서는 이러한 함수에서 오류를 감지하는 것이 중요한 도전이 됩니다. 일반적으로 각 계정 내의 개인이 이를 인지하고 보고하는 데 의존하기 때문입니다. 이를 해결하기 위해 우리는 시스템에서 발생할 수 있는 오류를 사전에 감지하고 알림을 보내는 자동화된 시스템을 개발했습니다.\n\n## 솔루션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전에 설명한 상황을 해결하기 위한 한 가지 솔루션은 CloudWatch의 Log 그룹 수준 구독 필터라는 기능을 활용하는 것입니다. 이러한 필터를 사용하면 사용자가 CloudWatch Logs에서 로그 이벤트의 실시간 스트림에 액세스하고 해당 이벤트를 Amazon Kinesis 스트림, Amazon Data Firehose 스트림 또는 AWS Lambda와 같은 다른 서비스로 라우팅하여 사용자 지정 처리, 분석 또는 다른 시스템과의 통합을 수행할 수 있습니다. 수신 서비스로 전송된 로그 이벤트는 base64로 인코딩되어 gzip 형식으로 압축됩니다.\n\n![이미지](/assets/img/2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem_0.png)\n\n명확성을 높이기 위해 이 기사를 회원 계정과 마스터 계정 두 가지 구분된 섹션으로 나눠보겠습니다:\n\n## 회원 계정\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리의 상황에서는 로그 이벤트를 AWS Lambda 함수 (회원 람다로 지칭)로 라우팅할 것입니다. 이 Lambda 함수는 이벤트를 압축 해제하고 계정 ID, 로그 그룹, 지역 및 오류 메시지와 같은 필수 정보를 추출할 것입니다. 이 정보는 회원 람다에 의해 마스터 계정 내에 위치한 SQS 큐로 배치되며 교차 계정 액세스 역할을 통해 지원됩니다.\n\nLambda 함수를 위해 관련 로그 그룹을 모니터링하려면 로그 그룹에 구독 필터를 첨부해야 합니다.\n\n![image](/assets/img/2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem_1.png)\n\n이는 대상 Lambda 역할 ARN을 지정하고 적절한 로그 형식을 선택하고 필터 패턴을 정의하는 것을 포함합니다 (사용 사례에 따라 옵션이 다를 수 있습니다). 이 경우 로그 형식으로 'other'를 선택했습니다. 필터 패턴은 임의의 로그 이벤트에서 'ERROR' 단어의 발생을 감지하도록 구성되어 있습니다 (필터 패턴을 요구 사항에 따라 맞춤화할 수 있으며 참조할 수 있는 이 링크를 참조하세요). 감지되면 지정된 Lambda 함수 (회원 람다)가 트리거됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지정된 필터 패턴을 구독 필터에 감지하면 Member 람다가 트리거됩니다. 그 후 람다는 이벤트를 이전에 설명한 대로 처리하며, 오류 메시지를 짧은 오류 메시지(액세스 거부 또는 지원하지 않는 작업과 같은 주요 오류 키워드가 포함된)와 긴 오류 메시지(전체 오류 메시지 포함) 두 가지 유형으로 분류합니다. 마지막으로 처리된 데이터를 중앙 SQS 큐로 전송합니다.\n\n## 마스터 계정\n\n마스터 람다는 중앙 SQS 큐에서 10분마다 트리거되도록 예약되어 있으며, 계정 ID, 로그 그룹 이름, 지역, 짧은 오류 메시지 및 긴 오류 메시지를 중요 정보로 추출합니다. 이 데이터는 이후에 DynamoDB 테이블에 저장되며, 로그 그룹 이름이 파티션 키이고 짧은 오류 메시지가 정렬 키로 사용됩니다. 또한 \"발생 횟수\"라는 속성을 1로 설정하여 동일한 오류의 발생 횟수를 나타내며, \"해결 상태\"라는 속성(오류의 상태를 지정)은 \"발생\"으로 설정됩니다.\n\n큐에서 동일한 오류 메시지를 찾았을 때, 마스터 람다는 먼저 해당 레코드에 대해 오류가 이미 테이블에 있는지 확인합니다. 만약 있다면 해당 레코드의 발생 횟수가 1씩 증가됩니다. 그러나 테이블에서 오류를 찾을 수 없다면, 해당 오류에 대한 새 레코드가 생성됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDynamoDB 테이블에 로그된 오류가 있으므로 발생 빈도에 기반한 알림 시스템을 구현할 수 있습니다. 이 시스템을 통해 오류는 심각도 수준으로 분류됩니다. 예를 들어, 발생 횟수가 10 미만이면 낮은 심각도로 분류되고, 10에서 20회 사이에 발생하면 높은 심각도로 간주되며, 20에서 30회 사이에 발생하면 중요한 심각도로 전환됩니다. 중요한 임계값에 도달하면 즉시 지정된 부서나 개발자에게 경고가 전송됩니다. 이 알림 메커니즘은 SES 템플릿화된 이메일을 사용하여 구현됩니다.\n\n![이미지](/assets/img/2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem_2.png)\n\n또한 하루에 한 번씩 알림 시스템을 구축할 수 있습니다. 알림 Lambda 함수가 지정된 간격으로 매일 트리거되도록 예약됩니다. 이 함수는 \"발생\" 해상도 상태로 표시된 DynamoDB 테이블의 오류를 검색합니다. 그런 다음, 이러한 오류를 CSV 파일로 컴파일하고 시스템에서 발생한 오류를 나타내는 SES 이메일을 전송합니다. 처리된 오류에 대한 해상도 상태를 \"통보됨\"으로 업데이트합니다.\n\n## 모니터링 시스템에 참여하는 중요한 람다의 신뢰성 보장하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마스터 람다, 멤버 람다 및 알림 람다와 같은 함수들은 매우 중요합니다. 이러한 함수들은 오류 없이 작동해야하며, 오류가 발생할 경우 빠른 조치를 취하기 위해 즉시 알림이 발송되어야 합니다. 이를 위해 이러한 람다 함수들의 코드를 try-catch 블록으로 캡슐화합니다. catch 블록에서 잡힌 오류의 경우, 개발자들에게 즉시 알림을 보냄으로써 신속한 조치를 취할 수 있도록 합니다. 이런 선제적인 접근은 모니터링 시스템의 신뢰성과 견고성을 향상시킵니다.\n\n## 비용 예산 산정\n\n![링크](/assets/img/2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem_3.png)\n\n## 최선의 실천 방안\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 코드 작성시 로거 사용하기:\n\n- 파이썬을 사용하는 경우, 코드에 로거를 통합하여 문제를 효과적으로 추적하고 디버깅하세요. 로거는 Lambda 함수의 성능 및 동작을 모니터링하고 가치 있는 통찰력을 제공합니다.\n\n2. 구독 필터를 추가하세요:\n\n- 람다 함수를 배포할 때 CloudFormation 템플릿에서 생성된 로그 그룹에 구독 필터를 추가하세요. 이 설정은 로그 이벤트의 실시간 모니터링 및 필터링을 가능케 하며, 오류를 빠르게 감지하고 대응할 수 있도록 지원합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 필터 가능하지 않은 오류 걸러내기:\n\n- 해결할 수 없는 오류를 식별하고 Member 람다를 통해 SQS 대기열로 진입하는 것을 방지하세요. 이러한 오류를 미리 걸러내면 소음을 줄이고 실행 가능한 문제에 집중하여 시스템이 효율적이고 효과적으로 유지될 수 있습니다.\n\n참고:\n\n최근 업데이트에서 AWS가 계정 수준 구독 필터를 발표했습니다. 이 새로운 기능은 단일 계정 수준 구독 필터를 사용하여 Amazon CloudWatch Logs로 흡수되는 실시간 로그 이벤트를 Amazon Kinesis Data Stream, Amazon Kinesis Data Firehose 또는 AWS Lambda로 전달하거나 사용자 지정 처리, 분석 또는 다른 목적지로 전달할 수 있게 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n고객들은 현재 각 로그 그룹마다 구독 필터를 설정해야 합니다. 하지만 계정 수준의 구독 필터를 사용하면, 전체 계정을 위한 단일 구독 필터 정책을 설정함으로써 여러 개 또는 모든 로그 그룹에 인입된 로그를 외부로 전달할 수 있습니다. 이는 시간을 절약하고 관리 부담을 줄여줍니다.\n\n이 방법의 단점은 SelectionCriteria에서 모니터링에서 제외할 로그 그룹만 지정할 수 있다는 것입니다. 조직 설정에서 제외하고 싶은 로그 그룹이 많을 수 있습니다. 그 결과, 제외된 로그 그룹 목록이 계속 늘어날 것이며, 새로운 로그 그룹을 제외해야 할 때마다 자주 업데이트가 필요할 것입니다. 그래서 현재는 이 방법을 택하지 않는 이유입니다.\n\n아래 CloudFormation 코드를 참조하세요.\n\n![CloudFormation Code](/assets/img/2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n블로그를 읽어주셔서 감사합니다. 더 많은 유익한 콘텐츠를 받고 싶다면 저를 Medium과 LinkedIn에서 팔로우해주세요.\n","ogImage":{"url":"/assets/img/2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem_0.png"},"coverImage":"/assets/img/2024-06-23-OrganizationlevelAWSLambdaerrormonitoringsystem_0.png","tag":["Tech"],"readingTime":7},{"title":"AWS 멀티 계정 전략 I AWS Organizations, OUs, 그리고 계정 활용 방법","description":"","date":"2024-06-23 22:34","slug":"2024-06-23-AWSMulti-AccountStrategyIAWSOrganizationsOUsandAccounts","content":"\n생산 시작 조직 및 고급 조직을 위한 권장되는 다중 계정 패턴 두 가지\n\n제품 엔지니어로서 항상 AWS 조직, OU 및 계정 솔루션을 마스터하는 데 어려움을 겪었습니다. 회사의 전체 AWS 환경을 종합적으로 파악할 수 없기 때문에 매일 적어도 하나의 AWS 계정에서 작업하더라도 문제입니다.\n\n엔지니어의 관점에서 개발 목적으로 단일 계정은 충분합니다. 그렇다면 왜 다중 계정 전략이 필요할까요?\n\n# 다중 계정 전략의 필요성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n질문에 대답하기 위해서는 CTO의 관점으로 바꿔봐야 해요:\n\n우리 회사에는 서로 다른 비즈니스 단위 또는 제품 팀이 각자 독특한 프로세스를 가지고 있어요. 비즈니스 목적과 소유권에 따라 작업량을 관리하는 OU가 중요해요.\n\n또한, 서로 다른 비즈니스 부문은 클라우드 지출을 별도로 보고, 제어, 예측 및 예산 편성해야 할 수도 있어요. AWS 계정은 계정 수준에서 통합 비용 보고를 지원해, 이러한 금융 분할을 용이하게 해 줘요.\n\nCTO로서, 보안 및 운영 정책도 고려해야 해요. 작업량은 종종 별도의 보안 요구 사항이 필요해, 별도의 제어 정책이 필요할 수 있어요. 예를 들어, 비생산 및 생산 환경은 일반적으로 서로 다른 보안 및 운영 정책이 필요해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여러 계정을 사용하여 비생산 및 생산 환경을 분리함으로써 각 환경의 리소스와 데이터가 다른 환경과 격리되어 안정성과 운영 관리가 강화됩니다.\n\n뿐만 아니라, 멀티 계정 전략은 한 환경에서 발생하는 불상사의 영향을 제한하여 다른 환경을 보호합니다. 이는 다양한 IT 운영 모델을 지원하며 기관장과 운영 전략을 조직 내 다른 부분에 맞게 구성할 수 있도록 합니다.\n\n따라서 저희 회사는 멀티 계정 전략을 통해 재무를 효율적으로 관리하고 보안을 강화하며 위험을 완화하며 다양한 운영 요구를 지원받습니다.\n\n이제 AWS에서 저희의 영향력을 확대하기 위해 멀티 계정 디자인 패턴을 탐색해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 서비스\n\n- AWS 계정: AWS 리소스와 해당 리소스에 액세스할 수 있는 ID를 포함하는 표준 AWS 계정입니다.\n- AWS 조직: 통합된 관리를 위해 AWS 계정을 통합하는 데 생성된 엔터티입니다.\n- 루트: 조직 내 모든 계정의 상위 컨테이너입니다. 여기에 적용된 정책은 모든 OU와 회원 계정에 영향을 미칩니다.\n- AWS 조직 단위 (OU): 루트 내의 계정을 포함하는 컨테이너입니다. OU에 부착된 정책은 모든 하위 OU와 계정에 영향을 줍니다.\n\n# 솔루션\n\n## 프로덕션 스타터 조직\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 패턴은 주요 초점이 생산 환경에서 업무를 지원하는 데 있는 최소한의 시작 환경을 나타냅니다.\n\n![이미지](/assets/img/2024-06-23-AWSMulti-AccountStrategyIAWSOrganizationsOUsandAccounts_0.png)\n\n## Root\n\n모든 조직 단위(OU) 및 계정의 상위 컨테이너입니다. 여기에 적용된 관리 정책은 모든 OU 및 계정, 관리 계정을 포함하여 영향을 미칩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 보안 조직 단위\n\n보안 조직 단위는 AWS 환경에 보안 기능을 제공하는 계정, 작업 부하, 및 리소스를 포함하는 중요한 조직 단위입니다. 이 조직 단위는 일반적으로 보안 팀의 다양한 대표자로 구성된 중앙 집중화된 클라우드 플랫폼 또는 클라우드 엔지니어링 팀에 의해 관리됩니다.\n\n\"보안 조직 단위\" 내에 \"로그 아카이브 계정\"과 \"보안 도구 계정\"을 생성하는 것이 권장됩니다.\n\n- 로그 아카이브 계정: 조직의 모든 계정에서 로그 데이터를 통합하는 중요한 역할을 합니다. 감사, 구성 규정 준수, 운영 로그를 위한 중앙화된 저장 공간을 제공합니다. AWS API 접근 로그(AWS 클라우드트레일), 리소스 변경 로그(AWS Config) 및 기타 보안 관련 로그를 통합하는 것이 권장됩니다. 또한 계정 간 VPC 피어링을 사용하는 경우 VPC 플로우 로그 데이터를 통합할 수 있습니다.\n- 보안 도구 (감사) 계정: AWS 보안 도구 및 콘솔에 대한 중앙집중식 위임된 관리자 액세스를 제공합니다. 보안 도구 계정은 조직의 모든 계정에 걸쳐 조사 목적의 뷰 전용 액세스를 제공합니다. AWS 보안 허브, Amazon GuardDuty, Amazon Macie, AWS AppConfig, AWS Firewall Manager, Amazon Detective, Amazon Inspector 및 IAM 액세스 분석기를 포함한 AWS 보안 서비스를 집중화하는 집계 지점 역할을 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 워크로드 OU\n\n비즈니스별 워크로드를 포함하며, 생산 및 비생산 환경을 모두 포함합니다. 우리 조직은 현재 프로덕션 스타터 단계에 있으므로, 이 패턴에서는 주로 프로덕션 환경의 워크로드를 지원하는 데 초점을 맞춥니다.\n\n## 고급 조직\n\n이 고급 조직 패턴은 일반 보안 서비스를 위한 보안 도구 환경, 더 격리된 워크로드 및 인프라 및 배포 환경 지원을 포함합니다. 추가 내용은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-AWSMulti-AccountStrategyIAWSOrganizationsOUsandAccounts_1.png\" /\u003e\n\n## Workloads OU\n\n이 더 발전된 패턴에서는 프로덕션 워크로드 환경과 데이터를 프로덕션 계정에서 분리하여 스테이징 및 개발을 위한 별도의 OUs를 제공합니다.\n\n## Infrastructure OU\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n인프라스트럭처 OU는 조직 내에서 공유되거나 사용되는 인프라 자원을 보유한 AWS 계정을 보유하며 중앙 집중식 운영 및 모니터링을 포함한 계정 관리를 담당합니다. 이 OU는 인프라 및 운영 팀이 소유하고 관리합니다.\n\n- Identity Account: 기타 관리 및 작업 활동과 격리된 중앙 집중식 신원 연동을 위한 계정입니다. 해당 계정은 계정에 대한 액세스 및 통합 애플리케이션에 대한 권한을 관리합니다.\n- Network Account: AWS 조직 내에서 네트워킹을 위한 중앙 허브입니다. 계정 간 및 온프레미스, 인터넷 트래픽 간의 트래픽을 관리합니다. 네트워크 관리자는 네트워크 트래픽에 대한 보안 조치를 구축 및 관리합니다. VPC를 관리하고 계정 간에 자원을 공유합니다.\n- Monitoring Account: AWS 계정 간의 리소스, 애플리케이션, 로그 데이터 및 성능을 모니터링합니다. CloudWatch, Amazon Managed Service for Prometheus, Amazon Managed Grafana, Amazon OpenSearch 등의 도구를 활용합니다.\n- Shared Services Account: AWS 계정 간에 공유되는 중앙 IT 서비스 및 자원을 호스팅하고 관리합니다. Shared Services 계정의 주요 목적은 유사한 공유 서비스를 통합하여 관리, 인터페이스 및 사용할 수 있는 단일 액세스 포인트를 제공하는 것입니다. 예를 들어, EC2 Image Builder를 AWS Resource Access Manager (AWS RAM)와 통합하여 특정 자원을 아무 AWS 계정이나 AWS 조직을 통해 공유할 수 있습니다.\n\n## 배포 OU\n\n배포 OU에는 워크로드를 빌드, 유효성 검사, 프로모션 및 릴리스하는 데 지원되는 리소스와 워크로드가 포함됩니다. AWS에서 지속적 통합/지속적 전달 (CI/CD) 능력을 배포하고 관리할 때, 배포 OU 내의 프로덕션 배포 계정 집합을 사용하여 CI/CD 관리 능력을 보유하는 것이 권장됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고 자료\n\n- AWS 조직용어 및 개념\n- 여러 계정을 사용하여 AWS 환경 구성하기\n","ogImage":{"url":"/assets/img/2024-06-23-AWSMulti-AccountStrategyIAWSOrganizationsOUsandAccounts_0.png"},"coverImage":"/assets/img/2024-06-23-AWSMulti-AccountStrategyIAWSOrganizationsOUsandAccounts_0.png","tag":["Tech"],"readingTime":7},{"title":"AWS 서버리스 간편 이해 Application Composer로 그리기","description":"","date":"2024-06-23 22:32","slug":"2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer","content":"\n![Image 1](/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_0.png)\n\n서버리스 개발자로서, 우리는 기본 코드로 서비스를 개발하며, 최근에는 코드로 인프라를 작성하지만 대부분은 AWS 리소스를 생성하기 위해 코드나 구성을 작성한다는 것을 의미합니다. 그 동안 우리가 잘못하고 있었을까요? AWS에서 서버리스 서비스를 더 나은 방식으로 구축할 수 있는 간단하고 더 좋은 방법이 있을까요?\n\n이 게시물에서는 AWS Application Composer를 사용하여 인프라 다이어그램을 그리면서 서버리스 서비스를 구축하는 방법에 대해 알아볼 수 있습니다. 저는 사용 방법, 장점 및 현재 제한 사항, 그리고 제 희망 목록을 공유하겠습니다.\n\n![Image 2](/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 블로그 포스트는 \"Ran The Builder\" 웹사이트에서 최초로 게시되었습니다.\n\n# IaC와 DevOps는 어렵습니다\n\n리소스 구성 파일이나 AWS CDK, SAM 또는 Terraform 코드를 작성하는 것은 어렵습니다. 도구를 배워야 하고, 문서를 검토하고, 해당 도구의 모베스트 프랙티스를 배워야 하며 (여기에서 내 CDK 모베스트 프랙티스 포스트를 읽어보세요), 코드 또는 구성을 작성해야 합니다.\n\n과거에는 개발자들이 Helm 차트와 같은 리소스를 빌드하는 구성 파일을 작성하는 것을 피했었습니다 (K8S의 생각에 오글거리곤 합니다), 이는 개발자들 사이에서 이러한 도구들의 채택 속도를 늦추었습니다. 그러나 서버리스와 같은 기술들과 함께 사용되는 최신 도구들인 AWS CDK, SAM과 코드로부터의 인프라스트럭처의 최근 트렌드와 같은 기술들이 등장함에 따라 개발자들은 DevOps 마인드를 수용하고 인프라 소스 코드를 작성하는 데 보다 개방적으로 대해요. 그렇지만 여전히 어려운 일입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n오늘은 새로 발견한 옵션 하나를 소개하고 싶어요 — 코드 없이도 자료 다이어그램을 그려서 리소스를 구축하는 방법입니다.\n\n# 인프라 구축을 그려볼까요?!\n\n네, 인프라 다이어그램을 그리는 거죠. 우리 모두 이런 작업을 할 때가 있죠.\n\n저는 아키텍트로서 서비스 동작을 설명하고 서비스 도메인이 어떻게 연결되는지를 나타내는 고수준 설계를 그리곤 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n개발자들은 내 고수준 디자인을 가져와서 서비스의 실제 AWS 서버리스 리소스를 설명하는 저수준 디자인으로 바꿉니다. 우리는 Lucidchart나 Draw.io 같은 다이어그램 도구를 사용해요.\n\n서비스 인프라 다이어그램은 새로운 기능을 설명하거나 새 팀원에게 서비스를 소개하거나 서비스가 어떻게 작동하는지 명확히 이해하는 데 좋은 도구에요.\n\n하지만, 인프라 다이어그램에도 문제가 있죠.\n\n## 다이어그램은 (거의) 항상 동기화되어 있지 않아요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n시간이 지남에 따라 기능이 추가되고 버그가 수정됩니다. 개발자들은 원래 디자인을 변경하며, 일부 디자인 요소는 우선 순위 때문에 제외되고 발전되지 않습니다. 꼼꼼히 작성하고 자랑스러워했던 원래 인프라 다이어그램을 기억하고 계십니까? 지금 실제 서비스 인프라와 동기화되어 있지 않으며 빠르게 가치를 잃고 있습니다.\n\n이 문제를 해결하기 위해 항상 코드 또는 인프라 구성 파일(AWS CDK, 제 경우)로 돌아갑니다. 코드는 거짓말을 하지 않지만 코드를 살펴보는 데는 시간과 기술이 필요합니다.\n\n최적의 해결책은 서비스 인프라 다이어그램을 서비스 코드와 동기화하는 것입니다. 다이어그램을 항상 업데이트해야 한다는 것을 기억하는 것은 정말 골치 아픕니다. 아무도 그렇게 하지 않습니다.\n\n다행히도 AWS는 이를 자동으로 수행하고 동시에 서비스 인프라를 구축하는 것을 더 직관적이고 재미있게 만들 수 있는 방법을 고안했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그들은 AWS 응용 프로그램 컴포저를 구축함으로써 그를 성취했어요. 이 도구를 사용하면 인프라 다이어그램을 그리고 이를 AWS SAM 또는 CloudFormation 템플릿으로 변환할 수 있어요.\n\n# AWS 응용 프로그램 컴포저\n\n몇 년 전인 2021년에, AWS는 이 문제를 해결하려고 시도한 스타트업인 \"Stackery\"를 인수했어요. 2022년 12월로 빨리 가면, AWS 응용 프로그램 컴포저가 탄생했어요.\n\n그것은 지난 2023년 3월에 GA(일반 사용 가능)로 출시되었어요. AWS re:invent 2023에서, 저의 주목을 끈 거대한 발표가 있었어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n콘솔에서 작업하고 다이어그램을 그리느라 애쓰지 않아도 됩니다. 이제 Visual Studio IDE에서 편안하게 Application Composer를 사용할 수 있어요.\n\n사용자 경험과 개발 흐름을 살펴보겠습니다.\n\n## 사용자 경험\n\n빈 프로젝트를 시작하거나 기존 프로젝트를 불러올 수 있어요. 저는 AWS Lambda Handler 쿡북 템플릿 프로젝트를 불러와서 어떻게 작동하는지 확인해 보기로 했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스 다이어그램을 제공합니다 (무엇이 웃긴 게, 인프라와 동기화가 안 맞고 CloudWatch 알람 및 대시보드가 빠져 있어요):\n\n![Service Diagram](/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_2.png)\n\n이제 기존 프로젝트 CloudFormation 템플릿으로 다이어그램을 생성해 보겠습니다. Mac에서는 'CMD + SHIFT + P'를 클릭하여 프로젝트의 CloudFormation/SAM 템플릿을 선택하세요:\n\n- AWS 툴킷 확장 프로그램을 설치했는지 확인해주세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Diagram 3](/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_3.png)\n\n화면에 보이는 첫 번째 출력물은 많은 리소스 및 그들 사이의 연결을 포함한 다이어그램입니다. 각 리소스는 AWS 아이콘, 리소스 이름 및 현재 구성이 표시됩니다.\n\n매우 유용한 기능 중 하나는 리소스를 그룹 또는 논리적 도메인 아래로 그룹화할 수 있다는 것입니다. 나는 리소스를 CDK 구조체로 나눠놨지만 이 분할이 CloudFormation에 반영되지 않았습니다. 모든 것을 정리하는 데 2분이 걸렸고 이 아름다운 다이어그램을 얻었습니다:\n\n![Diagram 4](/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nCRUD API 그룹(API GW, 람다 함수, 두 개의 DynamoDB 테이블), CloudWatch 리소스, 그리고 AppConfig 그룹이 있습니다. 그리고 이 리소스들 사이의 모든 연결도 있습니다.\n\n처음 인상: 감명받았어요! 이 것은 매우 가독성이 좋고 다이어그램 불일치 문제를 해결합니다. 다이어그램이 일치하지 않는 문제가 기억나시나요? 여기서 한 변경사항은 SAM 또는 CloudFormation 템플릿으로 자동으로 번역되어 써집니다. 심지어 그룹까지! CloudFormation에 멋진 새로운 'ApplicationComposer' 속성이 추가되었어요.\n\n새로운 서버리스 리소스를 추가하고 구성하는 것이 얼마나 쉬운지 확인해봅시다.\n\n## 서버리스 리소스 추가하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n새로운 CloudFormation 리소스를 추가하려고 해요. 리소스 검색이 빠르고 훌륭해요; 1000개 이상의 리소스를 추가할 수 있어요. 람다 함수를 선택해보죠. 간편하게 사용할 수 있는 메뉴가 나오는데, 필수 필드와 드롭다운 목록이 모두 제공돼요:\n\n![Lambda Function](/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_5.png)\n\n일반적으로 같은 것을 위해 많은 CDK 코드를 작성하는데, 여기서는 UI에서 처리할 수 있어요.\n\n다른 리소스를 추가해보려고 해요, AppConfig 배포를요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_6.png\" /\u003e\n\n여기서 경험이 조금 더 나아질 수 있어요. 자원 구성 패널에는 미리 정의된 드롭다운 목록이 없어요. 저는 CloudFormation 구성 코드를 작성해야 해요. 일반적이지 않은 많은 자원들은 람다 함수의 것과 같은 드롭다운 목록이 아닌 설정 상자가 있어요. 모든 구성을 입력하는 구성 상자가 있어요. 이 부분은 채우기 어렵고 이해하기 어려울 수 있어요. 그러나 공식 자원 문서로의 링크와 샘플 구성 예제를 제안해주는 AI 버튼이 있어서 좋아요.\n\n전반적으로, 보다 일반적인 서버리스 자원을 사용한다면 훌륭해요. 시간이 지나면 더 많은 자원들이 VIP 대우를 받을 거예요. 모든 정직함을 다해서 말하자면, CDK가 많은 새로운 서비스에 대해 L2 구성 추상화를 제공하지 않는 것과 비교할 수 있어요.\n\n## 자원 연결\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한 리소스에서 다른 리소스로 선을 그어서 연결할 수 있어요. 예를 들어 API 게이트웨이를 람다 함수에 연결하고, 특정 함수를 경로의 대상으로 설정할 수 있어요. 굉장히 쉽죠. 하지만 일부 리소스만 지원돼요. SQS 큐를 SNS 주제에 연결하려고 했는데, 아직 지원되지 않는다는 팝업 툴팁이 나왔어요. 지원되면 경험도 매우 간편할 거예요.\n\n![](/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_7.png)\n\n# 제한사항\n\n그래서 이미 두 가지 제한사항을 이야기했어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 리소스 구성 - 드롭다운 기능이 부족하여 이상적인 사용자 경험은 아니지만 작동할 수 있습니다.\n- 일부 연결해야 하는 리소스를 선으로 연결하는 것이 불가능합니다.\n\n하지만 논의해야 할 다른 제한 사항이 있습니다.\n\n저는 대규모 서비스의 CloudFormation 템플릿에서 Application Composer를 사용했을 때 리소스 한도 경고 메시지를 받았습니다. 이 문제는 해결될 것입니다. 그러나 현재는 제한 사항입니다.\n\n얻은 다이어그램이 매우 크며 정렬하고 그룹화하는 데 많은 시간이 걸릴 것입니다. 또 다른 제한 사항은 CDK 지원의 부재입니다. 네, 알고 있어요. 적합한 L2 CDK 구조를 생성하는 것이 매우 어려운 일이지만 꿈은 꿀 수 있어요...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n상기 모든 사항에도 불구하고, 해당 서비스는 밝은 미래를 가지고 있으며, 이러한 제한 사항이 해결되면 내 일상 도구의 일부가 될 것입니다.\n\n## 사용해야 하는 이유\n\nIaC 작성보다 경험이 더 좋습니까? 더 직관적이거나 심지어 재미있습니까? 네, 100%입니다; 모든 리소스가 지원되고 사용자 정의 드롭다운 선택 기능이 있을 때 특히 쉽습니다.\n\nCDK를 대체할 것인가요? 전체 CDK 지원이 있다면 아니요,하지만 문서 작성을 위한 인프라 다이어그램 작성과 같은 사용 사례가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 누구를 위한 것일까요? 이는 저수준 디자인을 그리고 작은 ~ 중간 규모 서비스의 정확한 인프라 다이어그램 표현을 원하는 사람들, 빠르게 프로토타입을 구축하고 싶은 사람들, 물론 기본적인 CloudFormation 또는 SAM을 사용하는 사람들에게 적합합니다. 자원을 구축하는 데 사용하지 않더라도 인프라 다이어그램을 그리는 데 사용하는 것은 의미가 있습니다. 최근에 AWS Lambda Handler Cookbook 문서에 애플리케이션 컴포저 리소스 이미지를 추가했는데, 간단히 생성할 수 있고 서비스 설명이 더 간단해졌기 때문입니다.\n\n저는 이 서비스와 그 앞날에 흥분하고 있습니다. 이에는 발전할 여지가 많고 성장할 곳도 많이 있습니다. 사용자 경험을 개선하면 안 쓰기 힘들어질 것이며, 팀이 올바른 방향으로 나아가고 있습니다.\n\n마지막으로, App Composer 팀 중 누군가가 이것을 읽고 계신다면, 제 소망과 이 서비스에 대한 비전은 아래에 있습니다.\n\n# 애플리케이션 컴포저 소망목록\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 이 위시리스트 중 일부만 구현할 수 있다면, Application Composer는 뛰어날 것입니다:\n\n- 채팅에서 기반 구성: 우리가 IDE 내에 있는 AI 유틸리티(Amazon Q 및 CodeWhisperer)를 사용하여 아이콘을 연결하고 다이어그램 리소스를 정의해야 할 이유가 없는데요? AI 비서에게 디자인할 것을 알리고 인프라 다이어그램을 그리고 구성하도록 하고 싶습니다.\n- 자동 리소스 그룹화 — 같은 리소스 유형의 일부 유형을 그룹화합니다 — CW 대시보드, AppConfig 리소스 등등.\n- 고수준 디자인 다이어그램 옵션 — \"병합(Merge)\" 옵션을 만들어 개체를 추상화한 도메인 그룹에 병합하는 옵션을 만들어보세요. 그리고 IDE에서 중첩 스택을 별도의 다이어그램으로 시각화합시다.\n- 제약 사항 해결: L2 CDK 지원 및 상세 구성 옵션을 가진 더 많은 리소스 지원 추가.\n- Github/Jenkins 플러그인을 통한 변경 사항 시각화 — PR을 검토할 때, 인프라 구성이나 추가/제거된 리소스가 시각적으로 무엇인지 이해하고 싶습니다. 이미 'CDK notifier'와 같은 부분적인 도구들이 그런 역할을 하는데요.\n- 요소 복사-붙여넣기 — 어떤 이유에서인지 이 작업이 작동하지 않았습니다. 버그일 수도 있지만, 유사한 리소스를 빠르게 추가할 수 있으면 좋겠습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_0.png"},"coverImage":"/assets/img/2024-06-23-SimplifyingAWSServerlessDrawwithApplicationComposer_0.png","tag":["Tech"],"readingTime":11},{"title":"Telegram 봇 백엔드로 AWS Lambda 사용 하는 방법","description":"","date":"2024-06-23 22:31","slug":"2024-06-23-UsingAWSLambdaasTelegrambotbackend","content":"\nIdea부터 구현까지: 빠르고 유연하며 서버리스하고 비용 효율적인 상호 작용을 위해 AWS Lambda를 사용하여 Telegram Bot을 만들고 구성하는 방법.\n\n![이미지](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_0.png)\n\n텔레그램 봇은 두 가지 모드로 작동할 수 있습니다:\n\n- Pull 모드 — 이 모드에서는 봇이 지속적으로 실행되어 Telegram을 폴링하여 새 업데이트가 있는지 확인합니다. 새 메시지가 있으면 해당 메시지에 따라 작동합니다.\n- Webhook 모드 — 이 모드에서는 Telegram이 새 메시지가 있는 경우 지정된 URL로 HTTP 요청을 보냅니다. 그런 다음 봇은 이러한 수신 요처르 처리합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n풀 모드에서는 텔레그램을 주기적으로 폴링하는 코드가 계속 실행되어야 합니다. 이 방법은 수신 연결을 다룰 필요가 없어 안전합니다. 하지만 코드를 어딘가에 호스팅해야하는 번거로움이 있습니다.\n\n웹훅 모드에서는 비슷한 호스팅 문제가 발생합니다. 텔레그램이 요청을 보낼 수 있는 리소스가 필요합니다.\n\n왜 우리가 웹훅 API를 AWS에 호스팅하지 않을까요? 서버리스 인프라는 이러한 유형의 솔루션에 완벽히 적합합니다. 다음은 이를 설정하는 간단한 방법입니다:\n\n![사진](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 작업을 구현하려면 다음 단계를 수행해야 합니다:\n\n- 텔레그램 봇을 등록합니다.\n- 텔레그램에 의해 호출될 람다 함수를 만들고 이 함수를 REST API를 통해 \"world\"에 공개합니다.\n- HTTP API URL을 웹훅으로 등록하여 텔레그램이 람다를 호출할 수 있도록 합니다.\n- 텔레그램 HTTP API를 통해 텔레그램 요청에 응답하는 방법을 배웁니다.\n\n시작해봅시다!\n\n봇 등록하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n온라인에서 이 작업을 수행하는 방법에 대한 많은 지침이 있습니다. 간단히 말해서, @BotFather에 연락하고 /newbot 명령을 사용하여 새 봇을 만들 수 있습니다. 등록 결과로 우리 봇을 식별할 수 있는 Bot Token(특정 코드)을 받게 됩니다.\n\n람다 함수 생성하기\n추가 작업을 위해서는 AWS 계정에 액세스할 수 있어야 합니다. 아직 계정이 없다면 여기에서 계정을 만들 수 있습니다.\n\nAWS 콘솔에서 Lambda 섹션으로 이동하여 새 함수를 만듭니다. 예를 들어, 우리는 Python을 사용할 것입니다. 하지만 편리한 다른 언어로 Python을 대체할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 새 함수를 생성할 때 파이썬 블루프린트를 선택하고 함수 이름을 지정하세요:\n\n![이미지](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n함수를 만든 후, 코드를 다음과 같이 변경할 것입니다:\n\n```js\nimport json\n\ndef lambda_handler(event, context):\n    print(\"*** Received event\")\n    print(json.dumps(event))\n\n    return \"Ok\"  # Echo back the first key value\n```\n\n![Lambda Function](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_5.png)\n\n이 단계에서 람다 함수의 자리 표시자가 준비되었습니다. 그러므로 API를 생성하는 작업을 진행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 람다를 위한 HTTP API 만들기\n\nAPI를 생성하려면 API Gateway 섹션으로 이동하고 새 HTTP API를 만드세요.\n\n![image1](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_6.png)\n\n![image2](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI를 생성할 때 람다 함수와의 통합을 정의하고 API 이름을 지정하세요:\n\n![이미지](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_8.png)\n\n다음 페이지에서는 리소스 경로를 변경할 것입니다.\n\n![이미지](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_9.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI를 생성한 후 브라우저에서 접근 가능한지 확인해보세요. API URL은 \"단계\" 섹션에서 찾을 수 있습니다(거기서 URL을 복사하세요).\n\n![API URL screenshot](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_10.png)\n\n링크를 열어보세요. Invoke URL에 /webhook 경로를 추가하는 것을 잊지 마세요.\n\n![Invoke URL screenshot](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n브라우저에서 올바르지 않은 JSON 응답에 대한 오류가 표시되지만 괜찮아요. 가장 중요한 것은 \"Ok\" 응답을 받았다는 것을 확인했다는 점이에요. 이는 람다 함수의 전반적인 인프라가 작동 준비가 되어 있다는 것을 의미해요.\n\n이제 우리는 람다 함수 자체를 수정하여 텔레그램 요청을 처리할 수 있도록 할 수 있어요.\n\n# 람다 함수 튜닝\n\n텔레그램 요청 형식은 문서에서 찾을 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n람다 함수로 전달되는 메시지는 다음과 유사할 것입니다:\n\n```js\n{\n  \"update_id\": 10000,\n  \"message\": {\n    \"date\": 1441645532,\n    \"chat\": {\n      \"last_name\": \"Test Lastname\",\n      \"id\": 1111111,\n      \"first_name\": \"Test\",\n      \"username\": \"Test\"\n    },\n    \"message_id\": 1365,\n    \"from\": {\n      \"last_name\": \"Test Lastname\",\n      \"id\": 1111111,\n      \"first_name\": \"Test\",\n      \"username\": \"Test\"\n    },\n    \"text\": \"/start\"\n  }\n}\n```\n\n이 단계에서 다음 필드가 중요합니다:\n\n- $.message.chat.id - 이것은 텔레그램 사용자가 우리 봇에게 무언가를 쓴 채팅 ID입니다.\n- $.message.from.username - 이것은 메시지를 보낸 사용자의 텔레그램 사용자 이름입니다.\n- $.message.text - 이것은 사용자 메시지의 텍스트입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 람다 작업에서 이러한 필드를 로그로 기록해 보겠습니다. 이를 위해 다음과 같이 함수 코드를 다음과 같이 교체할 것입니다:\n\n```js\nimport json\n\ndef lambda_handler(event, context):\n    print(\"*** 이벤트 수신됨\")\n    print(json.dumps(event))\n\n    chat_id = event['message']['chat']['id']\n    user_name = event['message']['from']['username']\n    message_text = event['message']['text']\n\n    print(f\"*** 채팅 ID: {chat_id}\")\n    print(f\"*** 사용자 이름: {user_name}\")\n    print(f\"*** 메시지 본문: {message_text}\")\n\n    return \"Ok\"  # 첫 번째 키 값을 다시 에코합니다\n```\n\n또한 테스트를 위해 람다 함수에 전달되는 새 테스트 이벤트를 생성할 것입니다. 람다 함수는 HTTP API와 통합되어 있으므로 다음과 유사한 메시지를 수신하게 될 것입니다:\n\n```js\n{\n  \"version\": \"2.0\",\n  \"routeKey\": \"ANY /webhook\",\n  \"rawPath\": \"/webhook\",\n  \"rawQueryString\": \"\",\n  \"headers\": {\n    \"accept\": \"*/*\",\n    \"accept-encoding\": \"gzip, deflate, br\",\n    \"content-length\": \"394\",\n    \"content-type\": \"application/json\",\n    \"host\": \"ng79a68gph.execute-api.eu-central-1.amazonaws.com\",\n    \"postman-token\": \"cbdf81be-3707-4383-b5b4-0d6fc71940e6\",\n    \"user-agent\": \"PostmanRuntime/7.39.0\",\n    \"x-amzn-trace-id\": \"Root=1-6676d931-3d6752cf6f055cd810e8f4e2\",\n    \"x-forwarded-for\": \"185.244.156.97\",\n    \"x-forwarded-port\": \"443\",\n    \"x-forwarded-proto\": \"https\"\n  },\n  \"requestContext\": {\n    \"accountId\": \"126459111222\",\n    \"apiId\": \"ng79a68gph\",\n    \"domainName\": \"ng79a68gph.execute-api.eu-central-1.amazonaws.com\",\n    \"domainPrefix\": \"ng79a68gph\",\n    \"http\": {\n      \"method\": \"POST\",\n      \"path\": \"/webhook\",\n      \"protocol\": \"HTTP/1.1\",\n      \"sourceIp\": \"185.244.156.97\",\n      \"userAgent\": \"PostmanRuntime/7.39.0\"\n    },\n\n    ... 중략 ...\n\n  },\n  \"body\": \"{\\r\\n  \\\"update_id\\\": 10000,\\r\\n  \\\"message\\\": {\\r\\n    \\\"date\\\": 1441645532,\\r\\n    \\\"chat\\\": {\\r\\n      \\\"last_name\\\": \\\"Test Lastname\\\",\\r\\n      \\\"id\\\": 1111111,\\r\\n      \\\"first_name\\\": \\\"Test\\\",\\r\\n      \\\"username\\\": \\\"Test\\\"\\r\\n    },\\r\\n    \\\"message_id\\\": 1365,\\r\\n    \\\"from\\\": {\\r\\n      \\\"last_name\\\": \\\"Test Lastname\\\",\\r\\n      \\\"id\\\": 1111111,\\r\\n      \\\"first_name\\\": \\\"Test\\\",\\r\\n      \\\"username\\\": \\\"Test\\\"\\r\\n    },\\r\\n    \\\"text\\\": \\\"/start\\\"\\r\\n  }\\r\\n}\",\n  \"isBase64Encoded\": false\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 메시지를 테스트 예제로 설정해보고 얻는 결과를 확인해봅시다:\n\n![Image 1](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_12.png)\n\n![Image 2](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_13.png)\n\n좋아요! 메시지에서 필요한 필드를 성공적으로 읽었습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희 함수는 지금부터 텔레그램에서 메시지를 수신할 수 있습니다. 다음으로 응답하는 방법을 알아보아야 합니다. 이를 위해 우리는 텔레그램 API의 sendMessage 메서드를 사용할 것입니다.\n\n지정된 chat_id로 답장 메시지를 보내는 람다 함수에 메소드를 추가해봅시다. 함수 코드를 다시 업데이트하세요. 반드시 \"your-bot-token\"을 @BotFather에서 받은 텔레그램 봇의 토큰으로 대체하는 것을 잊지 마세요.\n\n```js\nimport json\nimport urllib3\n\nBOT_TOKEN=\"your-bot-token\"\n\n\ndef sendReply(chat_id, message):\n    reply = {\n        \"chat_id\": chat_id,\n        \"text\": message\n    }\n\n    http = urllib3.PoolManager()\n    url = f\"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage\"\n    encoded_data = json.dumps(reply).encode('utf-8')\n    http.request('POST', url, body=encoded_data, headers={'Content-Type': 'application/json'})\n\n    print(f\"*** Reply : {encoded_data}\")\n\n\ndef lambda_handler(event, context):\n    body = json.loads(event['body'])\n\n    print(\"*** Received event\")\n\n    chat_id = body['message']['chat']['id']\n    user_name = body['message']['from']['username']\n    message_text = body['message']['text']\n\n    print(f\"*** chat id: {chat_id}\")\n    print(f\"*** user name: {user_name}\")\n    print(f\"*** message text: {message_text}\")\n    print(json.dumps(body))\n\n    reply_message = f\"Reply to {message_text}\"\n\n    sendReply(chat_id, reply_message)\n\n    return {\n        'statusCode': 200,\n        'body': json.dumps('Message processed successfully')\n    }\n```\n\n그 결과, 우리 함수는 텔레그램에서 어떤 것이라도 답장할 수 있어야 합니다. 응답은 사용자의 메시지 뒤에 \"Reply to\" 문자열이어야 합니다. 이 동작은 나중에 변경해야 할 것이지만, 지금은 전체 웹훅 봇 인프라를 구축하는 데 충분합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n텔레그램 봇을 텔레그램에 연결해 봅시다.\n\n텔레그램에 연결하기\n\n텔레그램에 연결하려면 다음 주소로 요청을 보내야 합니다:\n\n```js\nhttps://api.telegram.org/bot{bot_token}/setWebhook?url={webhook_endpoint}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 사용할 수 있습니다:\n\n- 'bot_token'은 이미 사용한 봇 토큰입니다.\n- 'webhook_endpoint'은 우리 API의 URL입니다.\n\n웹훅 URL을 설정한 후의 응답:\n\n```js\n{\n    \"ok\": true,\n    \"result\": true,\n    \"description\": \"웹훅이 설정되었습니다\"\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n연결을 확인하려면 다음과 같이 요청을 할 수 있어요:\n\n```js\nhttps://api.telegram.org/bot{bot_token}/getWebhookInfo\n```\n\n응답은 아래와 비슷하게 보일 거에요:\n\n```js\n{\n    \"ok\": true,\n    \"result\": {\n        \"url\": \"{webhook_endpoint}\",\n        \"has_custom_certificate\": false,\n        \"pending_update_count\": 0,\n        \"max_connections\": 40,\n        \"ip_address\": \"...\"\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 봇에 메시지를 전송해 보도록 해요:\n\n![image](/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_14.png)\n\n잘 동작하네요!\n\nLambda 함수의 작동 로그를 CloudWatch에서 확인할 수 있어요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 AWS Lambda를 Telegram 봇의 백엔드로 사용하는 방법에 대한 이미지입니다.\n\n또한 Lambda 함수가 예상대로 작동하지 않거나 Telegram에서 응답이 없는 경우 디버깅 도구로 매우 유용한 CloudWatch를 사용할 수 있습니다. CloudWatch에서 메시지는 약간의 지연(1~3분)이 발생한다는 점을 참고해 주세요.\n","ogImage":{"url":"/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_0.png"},"coverImage":"/assets/img/2024-06-23-UsingAWSLambdaasTelegrambotbackend_0.png","tag":["Tech"],"readingTime":14},{"title":"Terraform으로 AWS 자원을 올바르게 태깅하는 방법","description":"","date":"2024-06-23 22:28","slug":"2024-06-23-TaggingAWSresourcestherightwayusingTerraform","content":"\n![Tagging AWS resources the right way using Terraform](/assets/img/2024-06-23-TaggingAWSresourcestherightwayusingTerraform_0.png)\n\n# 🔖 소개:\n\nAWS 리소스를 조직화하고 비용을 추적하는 것은 특히 인프라가 확장됨에 따라 어려울 수 있습니다.\n\n리소스에 태그를 붙이는 것은 간단하지만 효과적으로 수행하려면 최선의 방법을 따라야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 블로그 포스트에서는 인프라스트럭처 코드(IaC) 도구 Terraform을 사용하여 AWS 리소스에 태그를 달는 방법을 안내해 드리겠습니다.\n\n# AWS 리소스에 태그 붙이기 소개:\n\nAWS 리소스에 태그를 붙이는 것은 조직화되고 비용 효율적인 클라우드 인프라를 유지하는 데 중요합니다.\n\n태그는 환경, 애플리케이션, 팀 등과 같은 기준에 따라 리소스를 분류하고 관리하는 키-값 쌍입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일관된 태깅은 리소스 조직, 비용 할당, 자동화, 보안 및 라이프사이클 관리와 같은 혜택을 제공합니다.\n\nTerraform에서는 프로비저닝하는 동안 리소스에 태그를 달 수 있습니다. 예를 들어, 환경 및 팀 태그와 함께 S3 버킷에 태그를 달기 위해 다음과 같이 할 수 있습니다:\n\n```js\nresource \"aws_s3_bucket\" \"example\" {\n  bucket = \"my-bucket\"\n  tags = {\n    Environment = \"Production\"\n    Team = \"DevOps\"\n  }\n}\n```\n\n또한 모든 리소스에 적용되는 공급자 수준의 기본 태그를 정의할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n공급자 \"aws\" {\n  default_tags {\n    tags = {\n      Environment = \"Production\"\n      ManagedBy = \"Terraform\"\n    }\n  }\n}\n```\n\n# 리소스 레벨에서 기본 태그 재정의하기:\n\ndefault_tags 블록을 사용하여 공급자 수준에서 기본 태그를 정의하면 모든 리소스에 자동으로 일반적인 태그가 적용되어 일관성을 유지하고 수동 작업을 줄일 수 있습니다.\n\n기본 태그의 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 일관성: 모든 리소스에 일관된 태그가 적용되도록 보장합니다.\n- 수동 작업 최소화: 리소스 간 반복되는 태그 정의를 피합니다.\n\n예를 들어 AWS 프로바이더에서 기본 태그를 설정하는 방법:\n\n```js\nprovider \"aws\" {\n  default_tags {\n    tags = {\n      Environment = \"Production\"\n      ManagedBy   = \"Terraform\"\n    }\n  }\n}\n```\n\n기본 태그를 재정의하거나 추가 태그를 추가하는 방법은 리소스 레벨에서 태그 인수를 지정하여 수행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 인수는 제공자 수준에서 정의된 기본 태그보다 우선합니다.\n\n```js\nresource \"aws_s3_bucket\" \"example\" {\n  bucket = \"my-bucket\"\n\n  # 기본 환경 태그를 재정의하고 목적 태그 추가하기\n  tags = {\n    Environment = \"Staging\"\n    Purpose     = \"Data Processing\"\n  }\n}\n```\n\n이 예제에서는 환경 태그가 Staging 값으로 재정의되고, 목적 태그가 특히 해당 S3 버킷 리소스에 추가됩니다.\n\nManagedBy 기본 태그는 여전히 적용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자원 수준 태그 사용 사례\n\n- 환경별 태그 (dev, staging, prod 등)\n- 애플리케이션/프로젝트별 태그\n- 자원별 메타데이터 태그 (예: 목적, 소유자, 만료일)\n- 데이터 민감성에 따른 규정 준수 또는 규제 태그\n- 특정 자원에 대한 비용 할당 태그\n\n자원 수준에서 태그 재정의를 허용함으로써 기본 태그의 이점을 유지하면서 각 자원의 특정 요구 사항에 따라 태그를 유연하게 사용할 수 있습니다.\n\n# 유연한 태깅을 위한 변수와 함수 사용:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테라폼을 사용하면 태그를 변수로 정의하고 merge()와 같은 함수를 사용하여 다른 태그와 결합하여 재사용성과 유연성을 높일 수 있습니다.\n\n변수로 태그를 정의하기:\n\n```js\nvariable \"default_tags\" {\n  default = {\n    Environment = \"Production\"\n    ManagedBy   = \"Terraform\"\n  }\n}\n```\n\nmerge() 함수를 사용하여 태그를 결합하는 방법:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nresource \"aws_instance\" \"example\" {\n  ami           = \"ami-0c94855ba95c71c99\"\n  instance_type = \"t2.micro\"\n\n  tags = merge(\n    var.default_tags,\n    {\n      Name    = \"ExampleInstance\"\n      Project = \"MyApp\"\n    }\n  )\n}\n```\n\nmerge() 함수는 default_tags 변수와 추가적인 리소스별 태그를 결합하여 모든 네 가지 태그가 EC2 인스턴스에 적용되도록 합니다.\n\n# 특별한 경우 처리:\n\n일부 AWS 리소스는 특정한 태깅 구성이 필요하거나 태그 적용 방법에 제한이 있는 경우가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n태깅 자동 스케일링 그룹:\n\n자동 스케일링 그룹 ASG 및 시작 템플릿 LT를 올바르게 태그 지정하는 것이 까다로울 수 있습니다.\n\n올바른 구성이 없으면 ASG 및 LT에 의해 시작된 EC2 인스턴스 및 연결된 저장소 볼륨에는 기본 태그가 첨부되지 않을 수 있습니다.\n\nASG는 propagate_at_launch 태그 구성이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n리소스 \"aws_autoscaling_group\" \"example\" {\n  # ...\n  tag {\n    key                 = \"Environment\"\n    value               = \"Production\"\n    propagate_at_launch = true\n  }\n}\n```\n\n런치 템플릿 태깅:\n\n런치 템플릿은 tag_specifications 구성을 필요로 합니다:\n\n```js\n리소스 \"aws_launch_template\" \"example\" {\n  # ...\n\n tag_specifications {\n    resource_type = \"instance\"\n    tags = {\n      Environment = \"Production\"\n      ManagedBy   = \"Terraform\"\n    }\n  }\n  tag_specifications {\n    resource_type = \"volume\"\n    tags = {\n      Persistence = \"Permanent\"\n    }\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nEBS 볼륨 태그 설정하기:\n\n테라폼을 사용하여 Elastic Compute (EC2) 인스턴스를 생성할 때, EC2에 연결된 Elastic Block Store (EBS) 볼륨은 자동으로 태그가 되지 않습니다. 태그되지 않은 EBS 볼륨은 관리가 어렵습니다.\n\n연결된 EBS 스토리지 볼륨에 EC2 기본 태그를 할당하려면 aws_instance의 volume_tags를 사용하세요.\n\n```js\nresource \"aws_instance\" \"example\" {\n  # ...\n\n volume_tags = {\n    Name        = \"DataVolume\"\n    Persistence = \"Permanent\"\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기타 특수 사례:\n\n일부 리소스는 AMI, NAT 게이트웨이 또는 VPC 엔드포인트와 같이 특정 태그 지정 요구 사항이나 제한 사항이 있을 수 있습니다.\n\n다양한 리소스 유형에 대한 태그 구성에 대한 최신 지침은 항상 Terraform 제공 업체 문서를 참조하십시오.\n\n# 흔한 실수 피하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일관되지 않은 태그 명명 규칙:\n\nappid, app_role 및 AppPurpose과 같은 일관되지 않은 태그 키를 사용하면 태그를 사용하고 관리하기 어려워집니다.\n\n```js\nresource \"aws_s3_bucket\" \"example\" {\n  bucket = \"my-bucket\"\n  tags = {\n    appid     = \"myapp\"\n    app_role  = \"data-processing\"\n    AppPurpose = \"logs\"\n  }\n}\n```\n\n대신, 태그 키 명명을 명확히 정의하고 그 규칙을 준수하도록 유도하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모든 AWS 리소스를 태그하지 않는 경우, EBS 볼륨과 같은 보조 또는 보완 리소스를 포함해서 태그하지 않는 것은 완전한 시각성과 비용 추적을 할 수 없게 됩니다.\n\n```js\nresource \"aws_instance\" \"example\" {\n  ami           = \"ami-0c94855ba95c71c99\"\n  instance_type = \"t2.micro\"\n  tags = {\n    Environment = \"Production\"\n  }\n}\n```\n\n동일한 기본 및 리소스 태그 문제:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndefault_tags 및 리소스 tags에 동일한 tag 키 및 값이 있는 경우, Terraform에서 오류가 발생하여 태그를 중복으로 지우거나 우회 방법을 사용해야 합니다.\n\n```js\nprovider \"aws\" {\n  default_tags {\n    tags = {\n      Name = \"Example\"\n    }\n  }\n}\n\nresource \"aws_vpc\" \"example\" {\n  tags = {\n    Name = \"Example\" # 오류: 태그가 동일함\n    }\n}\n```\n\n부분적인 태그 일치를 위한 영구 차이:\n\ndefault_tags 및 리소스 tags가 일부 일치하고 다른 태그가 있는 경우, Terraform은 일치하는 태그를 업데이트하려고 계획할 때마다 영구적인 차이를 표시하여 우회 방법이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprovider \"aws\" {\n  default_tags {\n    tags = {\n      Match1 = \"A\"\n      Match2 = \"B\"\n      NoMatch = \"X\"\n    }\n  }\n}\n\nresource \"aws_vpc\" \"example\" {\n  tags = {\n    Match1 = \"A\" # Perpetual diff trying\n    Match2 = \"B\" # to update these\n    NoMatch = \"Y\"\n  }\n}\n```\n\n인프라스트럭처 드리프트와 태그 손실:\n\n외부에서 Terraform 이외의 방법을 사용하여 리소스를 수정할 때 인프라스트럭처 드리프트로 인해 태그가 손실됩니다. IaC를 일관되게 사용하면이 문제를 완화할 수 있습니다.\n\n# Best Practices and Tips:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n명확한 태깅 전략과 명명 규칙을 수립해야 합니다:\n\n인프라 전반에 걸쳐 사용할 일관된 태그 키와 명명 규칙을 정의하세요.\n\n```js\nvariable \"tag_names\" {\n  default = {\n    environment = \"환경\"\n    application = \"응용 프로그램\"\n    team        = \"팀\"\n    costcenter  = \"비용 센터\"\n  }\n}\n```\n\n리소스를 프로비저닝할 때 (나중에가 아니라) 태그를 추가하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n리소스를 프로비저닝하는 과정에서 태그를 적용하세요. 이렇게 하면 시작부터 일관된 태깅이 가능합니다.\n\n```js\nresource \"aws_s3_bucket\" \"example\" {\n  bucket = \"my-bucket\"\n  tags = {\n    (var.tag_names.environment) = \"Production\"\n    (var.tag_names.application) = \"MyApp\"\n  }\n}\n```\n\n태그를 정기적으로 검토하고 감사하세요:\n\n주기적으로 리소스 태그를 검토하고 감사하여 태깅 전략을 준수하며 누락된 태그 또는 잘못된 태그를 식별합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로비저닝 중에 가능한 경우 태그 자동 적용을 자동화하세요:\n\n테라폼의 default_tags, 변수, 및 기능과 같은 기능을 활용하여 프로비저닝 중에 태그를 자동으로 적용하여 수동 노력을 줄이고 일관성을 유지하세요.\n\n# AWS 리소스 그룹 및 태그 편집기:\n\n모든 리전에 있는 모든 AWS 리소스에서 team=`platform engineering` 태그가 있는 리소스를 찾아볼 수 있다면 어떨까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAWS 리소스 그룹 및 태그 편집기는 여러 AWS 리소스 및 지역에 걸쳐 태그를 효과적으로 관리할 수 있는 강력한 도구입니다.\n\n리소스 그룹:\n\n리소스 그룹은 공유된 태그를 기반으로 AWS 리소스 모음을 구성하고 관리할 수 있는 중앙화된 방법을 제공합니다. 리소스 그룹을 사용하면 다음과 같은 작업을 수행할 수 있습니다:\n\n- 특정 태그(예: team=`platform engineering`)가 적용된 지역 전체의 리소스를 찾을 수 있습니다.\n- 태그가 누락되었거나 잘못된 태그 값이 있는 리소스를 식별할 수 있습니다.\n- 리소스 그룹 멤버십에 따라 인스턴스 시작/중지 또는 구성 적용과 같은 작업을 자동화할 수 있습니다.\n- 그룹 내에서 리소스 상태, 비용 및 구성에 대한 종합적인 정보를 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n태그 편집기:\n\n태그 편집기는 지원되는 AWS 서비스 및 지역 전체에 걸쳐 대량 태깅 작업을 가능하게 하는 리소스 그룹의 구성 요소입니다. 태그 편집기를 사용하면 다음을 수행할 수 있습니다:\n\n- 리소스 유형 및 기존 태그에 기반한 리소스 검색을 통해 \"팀=`플랫폼 엔지니어링`인 모든 EC2 인스턴스 찾기\"와 같은 쿼리를 실행할 수 있습니다.\n- 여러 리소스에 대해 태그를 추가, 수정 또는 제거하여 태깅 노력을 효율화할 수 있습니다.\n- 변경 사항을 적용하기 전에 미리 보기를 통해 정확성을 확인하고 의도하지 않은 수정을 피할 수 있습니다.\n- 태그 기반의 액세스 제어 정책을 사용하여 태그 값에 기반한 리소스 액세스를 관리할 수 있습니다.\n\n# 🔚 결론:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마크다운 형식으로 테이블 태그를 써야 해요.\n\nAWS 설정이 조직적이고 비용 효율적으로 이루어지려면, Terraform의 태깅 도구를 사용하는 방법과 일반적인 실수를 피하는 법을 꼭 숙지해야 해요.\n\n읽어주셔서 감사해요! AWS 리소스에 태깅하는 방법에 대해 무언가 배웠으면 좋겠네요!\n\n다음에 또 만나요 🇵🇸 🎉\n\n\u003cimg src=\"/assets/img/2024-06-23-TaggingAWSresourcestherightwayusingTerraform_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n읽어 주셔서 감사합니다!! 🙌🏻😁📃 다음 블로그에서 만나요.🤘🇵🇸\n\n🚀 끝까지 함께해 줘서 감사합니다. 이 블로그에 대한 질문/피드백이 있으시면 언제든지 연락해 주세요:\n\n♻️ 🇵🇸LinkedIn: https://www.linkedin.com/in/rajhi-saif/\n\n♻️🇵🇸 Twitter: https://twitter.com/rajhisaifeddine\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제공해주셔서 감사합니다 ✌🏻\n\n# 🔰 계속해서 학습해요!! 지식을 나눠요 !! 🔰\n\n# 참고 문헌:\n","ogImage":{"url":"/assets/img/2024-06-23-TaggingAWSresourcestherightwayusingTerraform_0.png"},"coverImage":"/assets/img/2024-06-23-TaggingAWSresourcestherightwayusingTerraform_0.png","tag":["Tech"],"readingTime":14},{"title":"서버리스 EventBridge Pipes로 이벤트 처리하는 방법 최신 2024","description":"","date":"2024-06-23 22:26","slug":"2024-06-23-ServerlessEventBridgePipes","content":"\n\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png\" /\u003e\n\n## 안내\n\n✔️ Amazon EventBridge Pipes 및 그들이 무엇인지에 대해 논의합니다.\n✔️ Python 및 AWS CDK를 사용한 예제를 통해 안내합니다.\n\n# 소개 👋🏽\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 기사에서는 AWS CDK와 Python을 사용하여 구축된 허구의 치과 앱을 만들어가면서 Amazon EventBridge Pipes에 대해 다뤄볼 것입니다.\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_1.png)\n\n'LJ 치과 의사' 앱은 사람들이 가장 가까운 치과 의사와 예약을 잡을 수 있는 기능을 제공합니다.\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그들이 이미 방문한 적이 있는 경우에는 이메일, SMS 또는 통신 없음을 보내기 전에 선호하는 연락 방법을 확인합니다. 이 모두는 Amazon EventBridge Pipes를 사용하여 처리됩니다.\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_3.png)\n\n이 기사의 전체 코드 예제는 여기에서 확인할 수 있습니다:\n\n# 우리가 무엇을 만들고 있나요? 🛠️\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n환자들이 온라인으로 진료 예약을 할 수 있도록 다음 아키텍처를 사용할 예정입니다:\n\n![아키텍처](/assets/img/2024-06-23-ServerlessEventBridgePipes_4.png)\n\n환자들이 다음을 사용하여 진료를 예약할 수 있습니다:\n\n- Amazon API Gateway REST API를 사용하여 온라인으로 진료 예약을 합니다.\n- Lambda 함수가 진료 상세 내용을 DynamoDB 테이블에 기록합니다.\n- 우리는 DynamoDB 스트림을 사용하여 테이블의 변경 사항을 감지하고 레코드가 생성되었을 경우에만 필터링하여 Amazon EventBridge Pipes를 통해 해당 스트림을 소스로 사용합니다.\n- 일치하는 레코드가 연락처 선호도 테이블에 있는지 확인하는 Lambda 함수를 호출하여 스트림 레코드에 선호도를 추가합니다.\n- 마지막으로, Amazon EventBridge Pipes의 대상은 SQS로 설정되어 진료를 처리하기 위해 준비된 예약을 저장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n👇 더 진전하기 전에 — 향후 블로그 게시물과 서버리스 뉴스를 만나보기 위해 LinkedIn에 연락해 주세요 https://www.linkedin.com/in/lee-james-gilmore/\n\n![ServerlessEventBridgePipes_5](/assets/img/2024-06-23-ServerlessEventBridgePipes_5.png)\n\n# Amazon EventBridge Pipes란 무엇인가요?\n\nAmazon EventBridge Pipes는 옵션 변환, 필터 및 풍부한 단계를 통해 이벤트 생성자와 소비자 간의 포인트 투 포인트 통합을 생성하는 데 도움을 줍니다. EventBridge Pipes를 사용하면 이벤트 중심 애플리케이션을 구축할 때 필요한 통합 코드 양을 줄이고 유지할 수 있습니다. 아래 다이어그램은 우리 예시를 위해 이를 보여줍니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 다이어그램에서 알 수 있듯이 다음이 있습니다:\n\n- 소스로 DynamoDB 스트림을 사용합니다.\n- 새로 삽입된 레코드만 받도록 추가 필터링을 수행합니다(예: 삭제 또는 업데이트 제외).\n- 별도의 데이터베이스에서 연락처 정보를 읽는 enrichment Lambda 함수를 통해 스트림에서 약속 데이터를 추가 정보로 향상시킵니다.\n- 최종적으로 약속 레코드를 더 처리하기 위해 SQS 대기열로 설정된 대상이 있습니다.\n\n참고로 아래에 표시된 다양한 서비스와 구성을 사용할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-ServerlessEventBridgePipes_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 주요 코드 설명하기 👨‍💻\n\n이제 몇 가지 주요 코드에 대해 이야기해봅시다.\n\n아래에서 볼 수 있는대로 CDK 애플리케이션을 상태(Stateful) 및 상태 없음(Stateless) 리소스(스택)로 분리하기 시작합니다:\n\n```js\n#!/usr/bin/env python3\nimport os\n\nimport aws_cdk as cdk\nfrom stateful.stateful import DentistsStatefulStack\nfrom stateless.stateless import DentistsStatelessStack\n\napp = cdk.App()\n\n# 앱을 상태(Stateful) 및 상태 없음(Stateless) 리소스로 분리합니다\nDentistsStatefulStack(app, \"DentistsStatefulStack\")\nDentistsStatelessStack(app, \"DentistsStatelessStack\")\n\napp.synth()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStateful 스택을 먼저 살펴 보면, 두 개의 DynamoDB 테이블을 설정했음을 알 수 있습니다. 하나는 약속을, 다른 하나는 선호하는 연락처 세부 정보를 저장하는 테이블입니다:\n\n```js\nfrom aws_cdk import CfnOutput, RemovalPolicy, Stack\nfrom aws_cdk import aws_dynamodb as dynamodb\nfrom constructs import Construct\n\nclass DentistsStatefulStack(Stack):\n\n    def __init__(self, scope: Construct, construct_id: str, **kwargs) -\u003e None:\n        super().__init__(scope, construct_id, **kwargs)\n\n        # 약속을 저장하는 DynamoDB 테이블 추가 및 스트림 활성화\n        table = dynamodb.Table(\n            self, 'DentistTable',\n            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,\n            table_name='DentistTable',\n            stream=dynamodb.StreamViewType.NEW_IMAGE,\n            removal_policy=RemovalPolicy.DESTROY,\n            partition_key=dynamodb.Attribute(\n                name='id',\n                type=dynamodb.AttributeType.STRING\n            )\n        )\n\n        # 이메일 주소를 기반으로 하는 연락 선호도 DynamoDB 테이블 추가\n        contact_table = dynamodb.Table(\n            self, 'DentistContactsTable',\n            billing_mode=dynamodb.BillingMode.PAY_PER_REQUEST,\n            table_name='DentistContactsTable',\n            removal_policy=RemovalPolicy.DESTROY,\n            partition_key=dynamodb.Attribute(\n                name='id',\n                type=dynamodb.AttributeType.STRING\n            )\n        )\n\n        # 테이블 이름을 위한 스택 출력 추가\n        CfnOutput(\n            self, 'DentistDynamoDBTableName',\n            value=table.table_name,\n            description='DynamoDB 테이블 이름',\n            export_name='DentistDynamoDBTableName'\n        )\n\n        # 연락처 테이블 이름을 위한 스택 출력 추가\n        CfnOutput(\n            self, 'DentistContactDynamoDBTableName',\n            value=contact_table.table_name,\n            description='연락 선호도 DynamoDB 테이블 이름',\n            export_name='DentistContactDynamoDBTableName'\n        )\n\n        # 약속 테이블의 테이블 스트림 ARN을 위한 스택 출력 추가\n        CfnOutput(\n            self, 'DentistDynamoDBTableStreamArn',\n            value=table.table_stream_arn,\n            description='DynamoDB 테이블 스트림 ARN',\n            export_name='DentistDynamoDBTableStreamArn'\n        )\n```\n\n이제 Stateful 리소스가 설정됐으므로, Stateless 스택에서 먼저 약속을 생성하는 람다 함수를 생성합니다:\n\n```js\n# 약속을 생성하는 람다 함수 생성\ncreate_appointment_lambda = aws_lambda.Function(\n    self, 'CreateAppointment',\n    runtime=aws_lambda.Runtime.PYTHON_3_12,\n    handler='create_appointment.handler',\n    code=aws_lambda.Code.from_asset(os.path.join(DIRNAME, 'src')),\n    function_name='CreateAppointment',\n    environment={\n        'dynamodb_table': dynamodb_table_name,\n    },\n)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLambda 함수에 추가적으로 두 번째 Lambda 함수를 추가합니다. 이 함수는 DynamoDB 스트림이 제공하는 데이터를 풍부하게 하는 데 사용될 것입니다:\n\n```js\n# 연락처 세부 정보를 검색하는 람다 함수 생성\nget_contact_details = aws_lambda.Function(\n    self, 'GetContactDetails',\n    runtime=aws_lambda.Runtime.PYTHON_3_12,\n    handler='get_contact_details.handler',\n    code=aws_lambda.Code.from_asset(os.path.join(DIRNAME, 'src')),\n    function_name='GetContactDetails',\n    environment={\n        'contacts_dynamodb_table': contacts_dynamodb_table_name,\n    },\n)\n```\n\n다음으로, 우리의 파이프 대상이 될 Amazon SQS 대기열을 추가합니다:\n\n```js\n# AppointmentsQueue로 메시지를 보낼 SQS 대기열 생성\nsqs_queue = sqs.Queue(\n    self, 'AppointmentsQueue',\n    queue_name='AppointmentsQueue',\n    removal_policy=RemovalPolicy.DESTROY\n)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 Amazon EventBridge 파이프 자체에 대한 IAM 정책을 만들어서 원본, 보강 및 대상 자원과 연결할 수 있도록합니다.\n\n```js\n# 파이프 원본(다이나모DB 스트림)용 파이프 정책과 역할 생성\npipe_source_policy = iam.PolicyStatement(\n    actions=[\n        'dynamodb:DescribeStream',\n        'dynamodb:GetRecords',\n        'dynamodb:GetShardIterator',\n        'dynamodb:ListStreams'\n    ],\n    resources=[stream_arn],\n    effect=iam.Effect.ALLOW\n)\n\n# 파이프 대상(SQS)으로 메시지를 게시하는 것을 허용하는 대상 정책 작성\npipe_target_policy = iam.PolicyStatement(\n    actions=['sqs:SendMessage'],\n    resources=[sqs_queue.queue_arn],\n    effect=iam.Effect.ALLOW\n)\n\n# 파이프가 람다 기능을 호출할 수 있도록 하는 보강 정책 생성\npipe_enrichment_policy = iam.PolicyStatement(\n    actions=['lambda:InvokeFunction'],\n    resources=[get_contact_details.function_arn],\n    effect=iam.Effect.ALLOW\n)\n\n# 파이프 역할 생성\npipe_role = iam.Role(self, 'PipeRole',\n    assumed_by=iam.ServicePrincipal('pipes.amazonaws.com'),\n)\n\n# 역할에 세 가지 정책 추가\npipe_role.add_to_policy(pipe_source_policy)\npipe_role.add_to_policy(pipe_target_policy)\npipe_role.add_to_policy(pipe_enrichment_policy)\n```\n\n이제 다음과 같은 코드를 사용하여 파이프를 생성할 수 있습니다:\n\n```js\n# 다이나모DB의 새 항목에 대한 필터가 있는 이벤트브릿지 파이프 생성\npipe = pipes.CfnPipe(self, 'Pipe',\n    role_arn=pipe_role.role_arn,\n    source=stream_arn,\n    log_configuration=pipes.CfnPipe.PipeLogConfigurationProperty(\n        cloudwatch_logs_log_destination=pipes.CfnPipe.CloudwatchLogsLogDestinationProperty(\n            log_group_arn=log_group.log_group_arn\n        ),\n        level='INFO',\n    ),\n    name='DentistPipe',\n    source_parameters=pipes.CfnPipe.PipeSourceParametersProperty(\n        dynamo_db_stream_parameters=pipes.CfnPipe.PipeSourceDynamoDBStreamParametersProperty(\n            starting_position='LATEST',\n        ),\n        filter_criteria=pipes.CfnPipe.FilterCriteriaProperty(\n            filters=[pipes.CfnPipe.FilterProperty(\n                pattern=json.dumps({'eventName': [{ 'prefix': 'INSERT' }])\n            )]\n        ),\n    ),\n    enrichment=get_contact_details.function_arn,\n    target=sqs_queue.queue_arn,\n)\npipe.apply_removal_policy(RemovalPolicy.DESTROY)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현재 인프라가 모두 설정되어 있지만 'create_appointment.py' 파일을 시작으로 Lambda 함수 코드를 간단히 살펴보겠습니다.\n\n```js\nimport json\nimport os\nimport uuid\nfrom http import HTTPStatus\n\nimport boto3\nfrom boto3.dynamodb.types import TypeSerializer\n\ndynamodb_table = os.getenv('dynamodb_table')\ndynamodb_client = boto3.client('dynamodb')\nserializer = TypeSerializer()\n\ndef handler(event, context):\n    try:\n        # 이벤트에서 요청 데이터를 구문 분석하고 본문을 가져옵니다.\n        request_data = json.loads(event['body'])\n\n        # uuidv4를 사용하여 새로운 약속 ID를 추가합니다.\n        request_data['id'] = str(uuid.uuid4())\n\n        # 페이로드를 dynamodb 형식으로 직렬화합니다.\n        appointment_data = {k: serializer.serialize(v) for k, v in request_data.items()}\n\n        # 항목을 dynamodb 테이블에 추가합니다.\n        dynamodb_client.put_item(TableName=dynamodb_table, Item=appointment_data)\n\n        body = {\n            'message': request_data,\n            'statusCode': HTTPStatus.CREATED,\n        }\n\n        # 응답을 올바른 형식으로 API Gateway로 전송합니다.\n        response = {\n            'statusCode': HTTPStatus.CREATED,\n            'body': json.dumps(body, indent=2),\n            'headers': {\n                'content-type': 'application/json',\n            },\n        }\n\n    except Exception as e:\n        response = {\n            'statusCode': HTTPStatus.INTERNAL_SERVER_ERROR.value,\n            'body': f'Exception={e}',\n        }\n\n    return response\n```\n\n위 코드에서 볼 수 있듯, API Gateway 이벤트에서 약속을 가져와 새로운 고유 ID(uuid)를 추가하고 레코드를 약속 테이블에 기록하는 기본 함수를 생성합니다.\n\n테이블에 레코드가 추가되면 스트림이 호출되어 모든 레코드 변경에 대해 파이프가 변경 사항을 소스로 가져올 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 다음으로, 파이프의 일부로 호출되는 Enrichment 람다 함수를 살펴보겠습니다:\n\n위 코드에서 볼 수 있듯이, 스트림 레코드에서 email_address 속성을 가져와 우리가 선호하는 연락처 DynamoDB 테이블에서 조회합니다. 레코드가 존재하면, 선호하는 방법을 가져와 약속 레코드에 추가합니다. 일치하는 레코드가 없으면, preferredMethod를 'none'으로 추가합니다.\n\n엔드 투 엔드로 테스트하려면, 애플리케이션을 배포하고 Contacts DynamoDb 테이블에 다음 항목을 추가하면 preferredMethod를 추가할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```json\n{\n  \"id\": \"john.doe@example.com\",\n  \"preferredMethod\": \"email\"\n}\n```\n\n만약 레코드가 존재하지 않는다면 이전에 언급한 대로 'none'으로 기본 설정됩니다.\n\n# 결론\n\nAmazon EventBridge 파이프를 사용하는 실제 예시로 서버리스 솔루션에서의 사용법을 보여드려 유용하게 찾으셨기를 희망합니다. 파이프를 사용하면 이전에 사용해야 했던 람다 접착 코드를 제거할 수 있고 소스에서 데이터를 추출하여 해당 데이터를 타깃으로 전달하는 훌륭한 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리 👋🏽\n\n이 글을 즐겁게 보았으면 공유하고 피드백을 남겨주세요!\n\n비슷한 콘텐츠를 더 보시려면 제 YouTube 채널을 구독해주세요!\n\n\u003cimg src=\"/assets/img/2024-06-23-ServerlessEventBridgePipes_7.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n당신과 어느 하나라도 다음에서도 연결하고 싶어요:\n\n- [LinkedIn](https://www.linkedin.com/in/lee-james-gilmore/)\n- [Twitter](https://twitter.com/LeeJamesGilmore)\n\n포스트를 즐겼다면 추가로 포스트/시리즈를 보기 위해 내 프로필 Lee James Gilmore를 팔로우해주세요. 그리고 인사를 건네고 싶다면 절대 잊지 말고 연락해주세요 👋\n\n좋았다면 포스트 하단에 있는 '박수' 기능을 사용해주세요! (한 번 이상 박수를 칠 수 있어요!!)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 제 소개\n\n안녕하세요, 저는 영국에 거주하고 있는 AWS 커뮤니티 빌더이자 블로거인 Lee입니다. AWS 인증 클라우드 아키텍트이며 City Electrical Factors (UK) 및 City Electric Supply (US)에서 글로벌 기술 및 아키텍처 책임자로 일하고 있습니다. 지난 6년간 주로 AWS에서 풀스택 JavaScript를 사용해 왔습니다.\n\n저는 서버리스를 지지하는 사람으로, AWS, 혁신, 소프트웨어 아키텍처, 기술에 대한 애정이 있습니다.\n\n**_ 제공된 정보는 제 개인적인 견해이며 해당 정보 사용에 대한 책임을 지지 않습니다. _**\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 내용도 참고하시면 좋을 것 같아요:\n","ogImage":{"url":"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png"},"coverImage":"/assets/img/2024-06-23-ServerlessEventBridgePipes_0.png","tag":["Tech"],"readingTime":16},{"title":"DynamoDB에서 Merkle Tree로 데이터 일관성 강화하는 방법","description":"","date":"2024-06-23 22:25","slug":"2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB","content":"\n![Merkle Trees](/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_0.png)\n\nAWS의 완전 관리형 NoSQL 데이터베이스 서비스인 DynamoDB는 고가용성과 내구성을 위해 설계되었습니다. 이 신뢰성을 보장하는 주요 기능 중 하나는 데이터를 여러 노드에 복제하여 저장하는 내결함성 방식입니다. 그렇다면 DynamoDB는 데이터 복제 및 일관성 문제를 어떻게 관리할까요? 그것이 Merkle Trees가 등장하는 이유입니다.\n\n# 문제 이해\n\nDynamoDB에 데이터를 저장할 때 데이터는 내결함성을 보장하기 위해 여러 노드에 복제됩니다. 그러나 이 복제는 데이터가 한 노드에서 다른 노드로 복사되어야 할 때 특히 도전적입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Image 1](/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_1.png)\n\n# 데이터 복사 및 일관성\n\n예를 들어, 이전 노드에서 새로 추가된 노드로 데이터 범위를 복사해야 한다고 상상해보세요.\n\n![Image 2](/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_3.png)\n\n이 과정은 간단해 보이지만, 이전 노드의 데이터가 지속적으로 업데이트됩니다. 이러한 동시 업데이트는 불일치를 일으켜 도착 노드에 오래된 데이터가 남게 됩니다.\n\n![이미지](/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_4.png)\n\n이를 처리하기 위해 데이터 범위가 여러 번 복사됩니다. 소스와 대상 노드 간에 변경이 없을 때 데이터가 일관성이 있다고 선언됩니다. 그러나 이 프로세스는 서비스 중단을 최소화하기 위해 가능한 빨리 이루어져야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도전 과제\n\n- 데이터 일관성 보장: 계속되는 업데이트에도 이전 노드에서 새 노드로 모든 값의 정확한 사본이 필요합니다.\n- 복사 반복 최소화: 프로세스를 가속화하기 위해 일관성 달성에 필요한 반복 횟수를 줄여야 합니다.\n\n# Merkle Trees 소개\n\nMerkle Trees는 복제 중 데이터 일관성 문제에 대한 효율적인 해결책을 제공합니다. 이렇게 해요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Merkle Trees 동작 방식\n\nMerkle Tree는 각 리프 노드가 데이터 블록의 해시를 포함하고, 각 비리프 노드가 자식 노드의 해시를 포함하는 트리 데이터 구조입니다. 이 구조를 통해 데이터 무결성의 효율적이고 안전한 확인이 가능해집니다.\n\n![이미지](/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_5.png)\n\n# DynamoDB에서 Merkle Trees의 이점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 효율적인 데이터 비교: Merkle Trees는 데이터 노드의 차이에 기반하여 루트 해시의 변경을 감지할 수 있습니다. Merkle 해시를 비교함으로써 DynamoDB는 불일치를 빠르게 식별할 수 있습니다.\n- 시간 복잡도 감소: Merkle Tree를 통해 일치하지 않는 데이터를 찾는 것은 각 노드를 확인하는 선형 시간 복잡도인 O(n)에 비해 로그 시간 복잡도인 O(log(n))를 갖습니다. 이로써 프로세스가 크게 빨라집니다.\n\n그렇다면 실제로 어떻게 사용되는 걸까요?\n\n![이미지](/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_6.png)\n\n새 노드로 데이터를 복사할 때, 문제는 복사 프로세스 중에 변경이 발생할 수 있다는 점에 있습니다. Merkle Trees를 통해 DynamoDB는 이러한 불일치를 효율적으로 식별하고 해결할 수 있습니다. 소스 노드와 대상 노드의 Merkle 해시를 비교함으로써 DynamoDB는 차이점을 정확히 파악하고 필요한 데이터 블록만 업데이트할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 방법은 데이터 이관 프로세스를 가속화시키고 대상 노드가 신속하게 일관된 상태에 도달하도록 보장하기 위해 필요한 복사 반복 횟수를 최소화합니다.\n\n# 결론\n\nMerkle Trees는 DynamoDB에서 데이터 복제 및 일관성의 도전에 대한 엔레지와 효율적인 해결책을 제공합니다. Merkle Trees의 고유한 특성을 활용함으로써 DynamoDB는 노드 간의 데이터 불일치를 신속하게 식별하고 해결함으로써 이관 및 업데이트 중에도 데이터가 일관적이고 사용 가능하도록 보장합니다.\n\nDynamoDB에서 Merkle Trees를 사용하는 주요 장점은 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 효율적인 데이터 비교: 데이터 노드간의 차이를 기반으로 루트 해시의 변경을 감지하는 기능은 불일치를 신속하게 식별할 수 있습니다.\n- 시간 복잡도 감소: Merkle Tree를 탐색하는 데 로그 시간 복잡도를 가지고 있어 DynamoDB는 선형 방법보다 빠르게 불일치를 찾아 해결할 수 있습니다.\n- 복사 이터레이션 최소화: 데이터 일관성을 달성하는 데 필요한 반복 횟수를 줄여 전체 데이터 이동 프로세스를 가속화합니다.\n\n요약하면, Merkle Trees는 성능에 미치는 영향을 최소화하면서 데이터 무결성을 보장하여 DynamoDB의 내결함 아키텍처를 향상시킵니다. 이를 통해 DynamoDB는 모든 규모의 애플리케이션에 대한 견고하고 확장 가능한 데이터 저장 솔루션을 제공하며 높은 가용성과 신뢰성을 유지합니다.\n\nMerkle Trees를 이해하고 구현함으로써 데이터 복제를 효율적이고 효과적으로 실현하여 시스템이 탄력적으로 유지되고 데이터가 일관성 있게 유지되도록 할 수 있습니다.\n\n이 기사가 유익했다면 박수를 치고 네트워크와 공유해 주세요. 아래에 의견과 질문을 자유롭게 남기고, DynamoDB와 Merkle Trees에 대한 대화를 이어나가 주세요!\n","ogImage":{"url":"/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_0.png"},"coverImage":"/assets/img/2024-06-23-HowMerkleTreesEnhanceDataConsistencyinDynamoDB_0.png","tag":["Tech"],"readingTime":5},{"title":"프로 플레이어 네모, 스트리트 파이터 6에서 M 바이슨 주캐릭터로 선택","description":"","date":"2024-06-23 22:23","slug":"2024-06-23-ProPlayerNemotoMakeMBisonHisMaininStreetFighter6","content":"\n## STREET FIGHTER 6\n\n거리 싸움 팬분들께 꼭 들려줘야 할 멋진 소식이 있습니다! 잘 알려진 프로 플레이어 네모가 기대되는 Street Fighter 6에서 JP를 대체하여 잘 알려진 악당 M. 바이슨의 주요 캐릭터로 나설 것을 선언했습니다. 이 결정은 현지 사람들 사이에서 호기심과 기대를 일으켰어요.\n\nJP에서 M. 바이슨으로의 전환은 여러 가지 중요한 이유로 이루어졌어요:\n\n- 다른 움직임과 전략: M. 바이슨은 JP와는 다른 방식으로 게임을 플레이해요.\n- 높은 영향력 - 그는 강한 풍모와 움직임으로 유명해요.\n- 팬 상호작용 - 사람들은 이미 네모의 결정에 대해 논의하고 추측하고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n경쟁적인 스트리트 파이터 시네의 영향에 대한 추가 토론을 기대해주세요!\n\n잘 모르시는 분들을 위해, 네모의 주 파트너는 스트리트 파이터 V에서 민첩하고 기민한 JP입니다. 그러나 M. 바이슨의 재등장에 열광하고 있습니다. 수많은 게임에서 M. 바이슨은 일본에서 베가로 불리기도 하는데, 이는 스트리트 파이터 프랜차이즈에서 두렵고 사랑받는 인물로 왔다갔다하는 것을 의미합니다.\n\n그렇다면, 스트리트 파이터 6에서의 바이슨 데뷔가 왜 흥미로운 것일까요? 먼저, 개발자들이 사이코 마인, 헤드 프레스, 쉐도우 라이즈 등 새로운 능력을 추가했는데, 이는 게임에 흥미와 전략을 불어넣을 것으로 예상됩니다. 이러한 변화로 인해 바이슨은 다양한 기동을 가능하게 하며 플레이 유연성을 키울 수 있어, 초보자와 전문가 모두에게 훌륭한 옵션이 될 것입니다.\n\n게다가, 바이슨은 스트리트 파이터 6에서 상당한 변화를 겪었습니다. 머리카락이 길고 흰색이며, 유명한 의상의 상단을 제거했습니다. 이제 그의 눈은 사이코 파워의 어둠스러운 빛으로 빛납니다. 새로운 모습은 그가 얼마나 변화했는지를 보여주는 동시에 사이코 파워가 얼마나 강력한지를 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUDON 스트리트 파이터 만화와 Street Fighter II Champion Edition과 같은 이전 비디오 게임에 미치는 바이슨의 중요한 영향을 높이 평가합니다. 모든 나이대의 팬들은 이 유명한 악당으로써 마주치거나 대적한 경험 때문에 이 부활에 공감할 수 있습니다. 그는 최근 Street Fighter 6 캐릭터를 위한 사용자 투표에서 2위를 차지하여 지속적으로 인기를 누리고 있음을 보여주었으며, 팬들이 그를 출시하기를 갈망하고 있음을 보여줍니다.\n\n네모의 메인 캐릭터 전환 결정은 프로 플레이어로서 바이슨의 잠재력을 상당히 보여줍니다. 네모는 다재다능하고 전략적인 플레이 스타일로 유명하며, 따라서 그의 바이슨을 지지하는 결정은 캐릭터의 타고난 재능이 시사되었을 수 있습니다. 이 전환은 다른 플레이어가 자신의 캐릭터를 선택하고 플레이하는 방식을 변경할 수 있으며, 현재의 메타게임을 변화시킬 수 있습니다.\n\n6월 26일이 다가오면서 흥미가 증폭됩니다. 플레이어가 스트리트 파이터 6를 즐길지, 승리하기 위해 하는지에 상관없이, 바이슨의 등장은 새로운 도전과 감동적인 만남을 제공할 것입니다.\n\n## 요약\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n프로 게이머 네모가 세계관 테마 게임 6인 '스트리트 파이터 6'에서 M. 바이슨이 처음으로 데뷔할 때 JP의 자리를 대체할 것이라 선언했습니다. 스트리트 파이터 커뮤니티는 이 소식을 듣게 되어 환영할 것입니다. 네모의 플레이 스타일은 이 조정으로 인해 극적으로 변화했으며, 팬들과 적들 모두 기쁘고 궁금해합니다. 네모의 잘 전략적으로 대처하고 다양한 상황에 적응하는 능력은 그를 수년간 강적으로 만들어왔습니다. M. 바이슨을 채택한 네모의 결정은 앞으로의 대회가 어떻게 진행될지에 대한 규칙을 수정했습니다.\n\n네모의 팬들은 이 변경이 국제 대회에서 그의 성적에 어떻게 영향을 미칠지 관심을 가지고 있습니다. 새로운 캐릭터를 마스터하기로 한 네모의 헌신은 그가 게임의 정상에 남고자 하는 열망을 보여줍니다. 스트리트 파이터 시리즈에 완전히 새로운 사람이거나 네모의 팬으로서 오래된 사람이든, 이 변경은 격투를 더욱 흥미롭게 만들어주고 새로운 방법을 가르쳐줄 것입니다.\n\n게임 세계에서 이루어지는 모든 주요 변화와 마찬가지로, 네모의 M. 바이슨으로의 전환은 시간이 지나면서 나타나게 될 것입니다. 스트리트 파이터 6을 다른 플레이어와 대결하는 것이 더욱 흥미진진해졌다는 사실을 부인할 수 없습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-ProPlayerNemotoMakeMBisonHisMaininStreetFighter6_0.png"},"coverImage":"/assets/img/2024-06-23-ProPlayerNemotoMakeMBisonHisMaininStreetFighter6_0.png","tag":["Tech"],"readingTime":3}],"page":"5","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"5"},"buildId":"YUMR4jSyk_WlOHHc7UfOk","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>