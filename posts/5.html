<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/5" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/5" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_buildManifest.js" defer=""></script><script src="/_next/static/T_Nz0g9U1yttYMSEma95P/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까" href="/post/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법" href="/post/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드 UI 레이어 속성 완전 정복  Part 2" href="/post/2024-06-23-CrashCourseontheAndroidUILayerPart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 UI 레이어 속성 완전 정복  Part 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 UI 레이어 속성 완전 정복  Part 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 UI 레이어 속성 완전 정복  Part 2</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기초부터 배우는 Kotlin 코루틴 사용법" href="/post/2024-06-23-KotlinCoroutinesFundamentals"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기초부터 배우는 Kotlin 코루틴 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기초부터 배우는 Kotlin 코루틴 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">기초부터 배우는 Kotlin 코루틴 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시스템 설계를 처음부터 배우기 레슨 1" href="/post/2024-06-23-StartingfromScratchSystemDesignLesson1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시스템 설계를 처음부터 배우기 레슨 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-StartingfromScratchSystemDesignLesson1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시스템 설계를 처음부터 배우기 레슨 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">시스템 설계를 처음부터 배우기 레슨 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법" href="/post/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">35<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법" href="/post/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">27<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="도커 핵심 개념 완벽 정리" href="/post/2024-06-23-DockerFundamentals"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="도커 핵심 개념 완벽 정리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-DockerFundamentals_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="도커 핵심 개념 완벽 정리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">도커 핵심 개념 완벽 정리</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Kubernetes에서 서비스 및 네트워킹 이해하는 방법" href="/post/2024-06-23-ServicesandNetworkinginKubernetes"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kubernetes에서 서비스 및 네트워킹 이해하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kubernetes에서 서비스 및 네트워킹 이해하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Kubernetes에서 서비스 및 네트워킹 이해하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드" href="/post/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">28<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link posts_-active__YVJEi" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까","description":"","date":"2024-06-23 23:25","slug":"2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini","content":"\n![Beeper](/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png)\n\n내가 미쳤다고 생각할지도 모르는 전환 속에, 나는 Apple이 Beeper가 iMessage를 Android로 가져오려는 시도를 차단한 것이 완전히 옳았다고 믿습니다. iMessage가 Android에서 작동하는 것이 나쁠 것이라고 하는 게 아니라, Beeper가 운영 방식이 내 책에서는 그리 괜찮았기 때문입니다.\n\nBeeper의 블로그는 \"안드로이드 및 iPhone 고객들은 고화질 이미지/비디오, 암호화, 이모티콘, 타이핑 상태, 읽은 표시 및 모든 최신 채팅 기능과 함께 채팅할 수 있기를 간절히 원한다\"고 주장합니다.\n\niMessage는 이러한 기능을 제공합니다. 다만, Android 폰에는 그렇지 않습니다. Beeper의 해결책은 무엇인가요? iMessage를 Android로 가져오는 것입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문제는 실행 방식에 있습니다.\n\niMessage는 Apple 기기인 iPhone, iPad, Mac 및 Apple Watch와 함께 사용하도록 만들어졌습니다. Android나 Android 기기와 함께 사용하거나 이용할 수 있도록 만들어지지 않았습니다.\n\n그리고 iMessage를 작동시키려면 Beeper가 시스템을 속여야 합니다.\n\n# Beeper Mini란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBeeper Mini는 안드로이드 앱으로, Apple의 iMessage 프로토콜을 역공학으로 메시지를 보내어 어떤 안드로이드 폰이라도 iMessage를 사용할 수 있도록 설계되었습니다.\n\nBeeper는 기기에서 암호화 키를 생성하고 공개 키를 Apple에 업로드합니다. 그러나 iMessage가 있는 iPhone에서와 같이 Apple 푸시 알림 서비스를 사용하는 대신, Beeper는 Apple의 서버와 상호작용하고 새 메시지 알림을 사용자에게 통지하는 Beeper Push Notification(BPN) 서비스를 개발했습니다.\n\n여기서 주목할 점은, 이것이 iMessage의 단순한 모방이 아니라는 것입니다. Beeper의 시스템은 권한 없이 실제로 Apple 서버를 사용하도록 설계되었습니다.\n\nBeeper는 Android로 iMessage를 가져오려는 첫 번째 시도가 아닙니다. Nothing Chats는 성공적으로 - 잠시 동안 - Nothing 폰에서 iMessage를 작동시켜마지만 중단되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정말로, Beeper는 똑똑한 시스템입니다. 그리고 그것은 작동하는 것처럼 보입니다. 하지만 그것이 옳다고는 할 수 없습니다.\n\n# 애플에 의한 종료\n\nBeeper Mini가 처음 출시된 후 얼마 지나지 않아 애플에 의해 종료되었습니다. 애플은 Beeper가 애플의 재산을 오용했다는 우려를 제기하면서 이를 타당하게 꼽았습니다.\n\n분명히, Beeper가 iMessage를 사용하는 방식을 기준으로 볼 때, 이것이 iMessage의 규정 위반인 것처럼 보이지는 않습니다. 그것은 좋은 소식입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만, 애플 시스템을 오용하는 것은 아닙니다.\n\n일부 사람들은 애플이 Beeper Mini를 폐쇄한 주된 또는 유일한 동기가 iMessage의 독점성을 보존하는 것인지 주장해왔습니다. 애플은 진정으로 보안에 관심이 없고 안드로이드 사용자를 제외하기만을 원한다고 말하는 사람들도 있습니다.\n\n이것이 사실인지 아닌지 논쟁할 수 있습니다. 하지만 실제로 그렇다 하더라도, 애플이 자사 시스템과 지적 재산을 보호할 권리는 없을까요?\n\n네, 정답은 네입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서의 문제는 두 가지입니다:\n\n- Beeper가 아이폰 간의 메시지를 주고받는 것으로 시스템을 속이기 위해 직접 Apple 서버에 연락하고 있습니다.\n- Beeper는 \"네이티브 iMessage 앱과 Apple 서버 간에 전송되는 트래픽을 분석하고 동일한 요청을 보내고 동일한 응답을 이해하는 자체 앱을 개발했다\"고 주장합니다. 다시 말하면, 그들은 Apple의 지적 재산을 역공학으로 분석했습니다.\n\nBeeper가 종료된 지 얼마 후에 약간의 수정을 거쳐 다시 온라인으로 돌아왔습니다.\n\n현재 상황은 좋은 점과 나쁜 점이 혼재되어 있습니다 -- 어떤 사람에게는 작동되는 반면 다른 사람에게는 작동되지 않을 수 있습니다. 내 추측으로는, Apple이 비공식적으로 모두 종료하게 될 것으로 생각됩니다. 그리고 Beeper가 다시 돌아온다 하더라도, 그들이 앞으로 하게 될 일은 그냥 야생의 고양이와 마우스 장난일 것으로 예상합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# “Apple just wants to keep iMessage exclusive.”\n\n애플을 비판하는 사람들은 Beeper를 종료하기로 한 애플의 결정이 그 서비스 및 사용자의 보안을 위해서가 아닌 사악하게 행동했다고 주장합니다. 그들은 애플이 iMessage의 독점성을 보전하고 안드로이드 사용자를 생태계 밖으로 배제하기 위해 행동했다고 주장합니다.\n\n일단 그게 사실이라고 가정해 봅시다. 가정해 봅시다.\n\n그게 잘못된 건가요? 그게 문제가 될까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n회사가 자신의 재산에 대해 원하는 대로 할 권리가 없습니까? Apple이 iPhone 사용자를 위한 독점 기능으로 자사의 재산 인 iMessage을 유지할 권리가 없습니까? 물론, 그 권리가 있습니다.\n\n그러나 여기에는 더 많은 것이 작용할 수 있다고 말할 수도 있습니다.\n\nBeeper는 제3자 응용 프로그램을 통해 Apple 서버로 메시지를 보내고, 이 응용 프로그램 자체가 역공학이 된 iMessage 프로토콜을 사용하여 작동합니다.\n\n모든 면에서 그것은 걱정스럽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알았어요! 테이블 태그를 마크다운 형식으로 변경할게요.\n\n| 번호 | 제품   | 가격 |\n| ---- | ------ | ---- |\n| 1    | 사과   | $1   |\n| 2    | 바나나 | $2   |\n| 3    | 체리   | $3   |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플은 아직도 다른 애플 기기가 아닌 기기들과 통신하기 위해 SMS를 사용하고 있다는 사실이 맞아요. 그렇죠. 그리고 이것이 바뀌어야 한다는 사실도 맞아요 (그리고 곧 바뀔 예정이에요).\n\n하지만 이게 변명이 될까요?\n\n애플 시스템을 일부러 남용하는 것을 옹호할 이유가 될까요?\n\n아마 그렇지 않아요. 그렇지 않다고 생각해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사실 안드로이드 및 iPhone 사용자들은 SMS를 사용하지 않고도 함께 채팅할 수 있는 방법이 있습니다.\n\n메신저, WhatsApp, Signal 등을 통해 누군가에게 메시지를 보내려면 상대방도 해당 앱의 사용자여야 하지만, 그런 건 어렵지 않죠.\n\n안드로이드 및 iOS 사용자들이 iMessage 사용자들이 오늘날 즐기는 많은 채팅 기능을 곧 누리게 될 때를 기대합니다.\n\n애플의 시스템을 잘못 사용하는 것은 좋은 해결책이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# \"애플이 보안에 중요시한다면, 왜 아직도 SMS를 사용하나요?\"\n\n확실히 상대적으로 보안 수준이 낮은 SMS에서 전진할 수 있다면 좋을텐데, 다행히 Apple은 곧 SMS를 버리고 RCS를 선호하게 될 것입니다.\n\n하지만 여러 번 읽어본 바에 의하면, Apple이 Beeper를 차단한 것은 사실상 iMessage 독점성을 보호하기 위한 조치일 뿐이며, 여전히 SMS를 사용한다는 점 때문에 보안에 중점을 두지 않고 있다는 주장을 볼 수 있습니다.\n\n다시 말해, 정말로 보안과 개인 정보 보호를 중요시한다면, 먼저 SMS를 대체할 것에 집중해야 한다는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 그게 어떻게 작동하는지 아시나요? 이건 빨간 물고기라고 할만한 거예요.\n\n우리는 집 침입을 변론할 때 창문 잠금에 실패한 집 주인을 꺼내들어 가장하지 않아요. 창문을 잠그지 않아서 잘못했나요? 네. 그럼 침입은 여전히 잘못인가요? 네.\n\n두 가지가 모두 맞아요. 둘 다 나쁘지만, 사실이에요.\n\n# 여기서 객관적으로 생각해 보기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 사람들이 나를 애플 열광자로 생각할 수 있다는 걸 방지하기 위해 먼저 말하지만, 전 그렇지 않아요. 쿠퍼티노에서 보여준 소비자에게 해로운 여러 가지 결정들에 대해 공개적으로 비판했어요. 그 중 일부는 다른 것보다 더 화나게 만들기도 했죠.\n\n나는 소비자들에게 해로운 것으로 생각되는 결정들을 눈치 없이 비판하는 데 전혀 문제가 없고 때로는 절대적으로 악의적이라고 생각되는 결정들도 있어요. 오랫동안 나의 글을 따라온 사람들은 그것을 알 것이에요.\n\n그러나 한 발 물러나서 명확한 머리로 생각해보면 분명해요: 여기서 나쁜 사람은 애플이 아니에요.\n\nBeeper는 애플의 프로토콜을 역공학적으로 재구성하여 복사했고 (이것이 첫 번째 문제입니다), 이를 사용하여 애플의 서버와 통신하며 사실상 사용자를 대신해 애플 기기인 척 했어요. (여기가 두 번째 문제입니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n너아 둘 다 괜찮은 게 아니야.\n\n일단, Beeper가 하려고 했던 것이 나쁜 것은 아니야. iMessage는 훌륭하고, 안드로이드 사용자가 공식적으로 사용할 수 있으면 좋겠어. 하지만 지금까지 그런 일은 일어나지 않았어.\n\n아무도 채팅에서 \"초록색 버블\"이 되어서 부끄러워하거나 나쁜 기분을 가져야 하는 일은 없어야 해 — 네, 그렇게 되는 경우도 있지. 나는 그것이나 그런 행동을 옹호하고 있지 않아.\n\n하지만 애플의 지적 재산권을 역공학하고 애플 시스템을 속이기 위해 사용하는 것은 해결책이 될 수 없어 — 비록 그 취지가 좋다고 해도.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 어떻게 변경해야 할까요?\n\n전체적으로 iPhone을 사용하고 iMessage를 즐겨 사용하는 것을 알려드리고 싶어요. 그래서 이 서비스를 좋아합니다. 이 서비스를 통해 일상적인 모든 문자 메시지 교류에 사용할 수 있다면 좋을텐데, 몇 가지 좋은 기능을 제공하기 때문이에요. 예를 들어, 누군가가 내 메시지를 확인했거나 응답을 입력 중이거나 하는 것을 볼 수 있어요. 이런 기능들은 당연하게 여기고 사용하고 있습니다.\n\n하지만 이런 기능들이 2023년에 모두에게 제공되지 않는다는 것은 안타깝네요. 그래서 Android 사용자들도 이런 기능을 사용할 수 있도록 만들어지면 좋겠어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현대화된 문자 메시징이 필요한 시대입니다: RCS. 그 불충분한 기능을 가진 SMS는 마치 1990년대의 것처럼 느껴집니다. 아마 그래서 iMessage가 많은 사람들에게 매력적으로 느껴지는 이유일지도 모르겠네요?\n\n제가 여기서 확실히 말씀드리고 싶은 것은, 저는 애플의 구식한 문자 메시징 방식을 결코 옹호하는 것이 아닙니다. 그들은 이제야 현대화되어야 했다고 생각해요.\n\n하지만, 그래도 Beeper의 행동을 변명할 수는 없어요.\n","ogImage":{"url":"/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png"},"coverImage":"/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png","tag":["Tech"],"readingTime":10},{"title":"Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법","description":"","date":"2024-06-23 23:23","slug":"2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell","content":"\n소프트웨어 개발의 빠르게 변화하는 세계에서는 효율성과 속도가 프로젝트의 성공을 좌우합니다. 저희 터크셀의 데브옵스 팀은 백엔드, 프론트엔드 및 모바일 플랫폼을 아우르는 다양한 프로젝트의 조율을 맡고 있습니다. 각 프로젝트마다 기술적으로 복잡하고 도전적인 부분이 있지만, 이들을 모두 연결짓는 공통 요소는 신속한 빌드 프로세스의 필요성입니다.\n\n![이미지](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png)\n\n그러나 기존의 설정은 큰 어려움을 겪고 있었습니다. 빌드 시간이 길어지면서 배달 일정과 개발자 생산성에 영향을 미치고 있었습니다.\n\n이 문제로 저희는 Gradle의 빌드 캐시 노드 기능을 탐구하고 최종적으로 구현하게 되었습니다. 이 게시물에서는 우리가 이 기능을 OpenShift에 구현한 여정, 직면한 어려움, 창조한 해결책 및 달성한 결과에 대해 나눌 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 빌드 환경에 대한 배경\n\n터키셀의 디지털 서비스에서는 Bip, TV+, Fizy, Lifebox 등과 같은 다양한 안드로이드 프로젝트 포트폴리오를 관리합니다. 각 프로젝트는 고유한 종속성과 빌드 프로세스를 갖고 있어 복잡성과 빌드 시간을 증가시키는 요소로 작용합니다.\n\n저희 파이프라인은 기존에는 Jenkins를 사용하고 있으며 빌드 에이전트로 openshift 포드를 활용하고 있습니다. Jenkinsfile과 포드 템플릿 YAML로 프로세스를 관리합니다. 그러나 이 컨테이너화된 환경에서는 각 빌드가 청소된 상태에서 시작되므로 빌드 사이에 아티팩트가 유지되지 않습니다.\n\n# 해결책 탐색\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 지역 캐시\n\n우선, Maven 프로젝트에서 사용하는 지역 캐싱 솔루션을 구현할 수 있다고 생각했습니다. OpenShift의 Persistent Volume Claims (PVCs)를 사용하여 빌드 아티팩트 및 종속성을 저장하여 다운로드 시간과 빌드 소요 시간을 줄이는 목표를 가졌습니다. 구조는 단순히 pvc를 로컬 디스크로 사용하고 해당 경로를 지역 캐시로 지정하는 것입니다.\n\n```js\ngradle ${GRADLE_OPTIONS} --build-cache --project-cache-dir=${PVC_PATH}/gradle/android/ ${GRADLE_TASKS}\n```\n\nGradle과 함께 사용할 때 이 접근 방식에는 치명적인 결함이 있었습니다. 종속성과 빌드 스크립트를 효율적으로 처리하지만 캐시를 사용할 때 잠금 메커니즘이 발생합니다. 이 잠금 메커니즘은 동시 빌드가 캐시를 손상시키는 것을 방지하지만 동시에 한 번에 하나의 빌드만 캐시를 사용할 수 있음을 의미합니다. 이는 고도로 동시성 환경에서 효과를 크게 감소시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 빌드 캐시 노드\n\n철저한 조사와 고려 끝에, 중앙 캐시로 Gradle의 빌드 캐시 노드를 설정하기로 결정했습니다. Openshift에서 구축하는 것이 가장 좋다고 결정했습니다. 다음 단계는 배포를 설계하고 구현하여 우리의 OpenShift 환경과 호환되도록 견고하게 만드는 것이었습니다. PVC, 배포, 서비스 및 라우트를 적용한 뒤, 우리의 노드가 가동되었습니다.\n\n# 기술적 구현\n\n## 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희는 전용 PVC를 사용한 배포를 구현했어요.\n\nPVC Yaml:\n\n```js\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: gradle-remote-cache-pvc\nspec:\n  accessModes:\n    - ReadWriteMany\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: ocs-external-storagecluster-cephfs\n  volumeMode: Filesystem\n```\n\n배포 Yaml:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: gradle-remote-cache\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: gradle-remote-cache\n  template:\n    metadata:\n      labels:\n        app: gradle-remote-cache\n    spec:\n      volumes:\n        - name: gradle-remote-cache-pvc\n          persistentVolumeClaim:\n            claimName: gradle-remote-cache-pvc\n      containers:\n        - name: build-cache-node\n          args: [\"start\"]\n          image: gradle/build-cache-node:18.1\n          ports:\n            - containerPort: 5071\n              protocol: TCP\n          resources: {}\n          volumeMounts:\n            - name: gradle-remote-cache-pvc\n              mountPath: /data\n          imagePullPolicy: IfNotPresent\n      restartPolicy: Always\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 25%\n      maxSurge: 25%\n```\n\n회사 전체에서 사용할 수 있도록 하려면 서비스와 라우트를 통해 열어야 합니다.\n\n서비스 Yaml:\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: gradle-remote-cache\nspec:\n  selector:\n    app: gradle-remote-cache\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 5071\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루트 Yaml:\n\n```yaml\nkind: Route\napiVersion: route.openshift.io/v1\nmetadata:\n  name: gradle-remote-cache\nspec:\n  host: \u003c캐시 라우트 URL\u003e\n  to:\n    kind: Service\n    name: gradle-remote-cache\n    weight: 100\n  port:\n    targetPort: 5071\n  tls:\n    termination: edge\n  wildcardPolicy: None\n```\n\n설치 후, 콘솔 로그에 제공된 자격 증명을 사용하여 앱에 로그인합니다. 푸시 권한이 있는 사용자를 만들어 CI/CD 프로세스에서 사용합니다. 또한 개발자들이 로컬 빌드에서 리드 권한만으로 원격 캐시를 사용할 수 있도록 허용합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 사용법\n\n먼저 settings.gradle에 원격 캐시 구성을 추가해야 합니다.\n\n```js\nboolean isJenkins = System.getenv().containsKey(\"IS_JENKINS\")\n\nbuildCache {\n    if (isJenkins){\n        remote(HttpBuildCache) {\n            url = '\u003c캐시 경로 URL\u003e/cache/'\n            push = true\n            credentials {\n                username = System.getenv(\"GRADLE_REMOTE_CACHE_USERNAME\")\n                password = System.getenv(\"GRADLE_REMOTE_CACHE_PASSWORD\")\n            }\n        }\n    }\n}\n```\n\n빌드 명령에서 캐싱을 활성화해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngradle ${GRADLE_OPTIONS} --build-cache ${GRADLE_TASKS}\n```\n\n# 초기 결과 및 분석\n\n## 결과\n\n모든 프로젝트를 구현한 후 캐시 크기와 빌드 시간을 관찰했습니다. 초기에는 50GB 공간을 볼륨으로 설정했습니다. 마지막으로 50GB를 초과하여 크기를 200GB까지 늘렸습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Gradle Remote Cache for Multi-Project Environment at Turkcell](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_2.png)\n\n성공 결과 시간이 각 프로젝트마다 다릅니다. 일부는 34분에서 11분으로 단축되었습니다.\n\n![Gradle Remote Cache for Multi-Project Environment at Turkcell](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_3.png)\n\n![Gradle Remote Cache for Multi-Project Environment at Turkcell](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 프로젝트에서는 시간이 감소하지 않았습니다.\n\n![Image 1](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_5.png)\n\n![Image 2](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_6.png)\n\n빌드 캐시 노드는 많은 프로젝트의 빌드 시간을 크게 개선했지만 일부 프로젝트에는 개선되지 않았습니다. 이 솔루션의 전체 잠재력은 계속된 개선과 각 프로젝트의 고유한 특성에 대한 더 깊은 이해를 통해 실현될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다음 단계\n\nGradle 빌드 캐시 노드가 이제 구현되어 일부 프로젝트 빌드 시간을 상당히 개선하는 결과를 보여주고 있으므로, 다음 단계는 개발자들에 이를 인계하는 것입니다.\n\n초기 결과와 원격 캐시의 효율성을 향상시키는 방법에 대한 제안을 개발 팀에 공유했습니다.\n\n이 도구가 제공하는 장점을 완전히 활용하기 위해서는 시스템을 설정하는 데 그치지 말고, 개발자들이 시스템을 지속적으로 최적화하고 사용하는 것이 필요합니다. 캐싱 메커니즘의 효과적인 사용, 캐시 가능한 작업의 적절한 식별, 의존성 관리, 캐시 히트율을 높이기 위한 필요한 조정은 개발자들이 적극적으로 실시함으로써 이루어질 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n마무리하며, Gradle의 빌드 캐시 노드를 OpenShift에 구현하는 여정은 도전적이고 보람찼습니다. 우리는 많은 프로젝트의 빌드 시간을 크게 줄여 제공 일정의 효율성을 높이고 개발자 생산성을 향상시키는 데 성공했습니다.\n\n하지만, 이로 끝이 아닙니다. 우리는 이 솔루션의 잠재력을 완전히 이용하기 위해 개발자들이 시스템의 사용법을 지속적으로 최적화해야 한다는 점을 인식합니다. 이는 캐시할 수 있는 작업 식별, 의존성 관리, 및 캐시 히트율을 높이기 위해 필요한 조치를 취하는 것을 포함합니다.\n\n# 참고문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://docs.gradle.com/build-cache-node/\n\nhttps://docs.gradle.org/current/userguide/build_cache.html\n\nhttps://medium.com/@cesarmcferreira/using-gradle-build-cache-server-73d7680baf2a\n","ogImage":{"url":"/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png"},"coverImage":"/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png","tag":["Tech"],"readingTime":10},{"title":"안드로이드 UI 레이어 속성 완전 정복  Part 2","description":"","date":"2024-06-23 23:20","slug":"2024-06-23-CrashCourseontheAndroidUILayerPart2","content":"\n## 상태 보유자 및 상태 저장\n\n이 블로그 포스트 시리즈는 Android 개발자 안내를 UI 레이어에 대해 요약하는 것을 목표로 합니다. 우리는 이에 관련된 모든 엔티티들을 탐색하고, 각 부분이 하는 역할을 이해하며, 최선의 실천법을 논의할 것입니다.\n\n첫 번째 부분에서는 UI와 UI 상태에 대해 다루었습니다. 이미 UI 레이어에 존재하는 다양한 엔티티와 UI 및 UI 상태를 효과적으로 생각하는 방법을 알고 있어야합니다.\n\n이제 Part 2로 넘어가 보겠습니다! 상태 보유자 및 Android에서 UI 상태를 어디에 저장하고 상태를 어디에 끌어올려야하는지와 같은 기타 UI 레이어 관련 주제들을 다룰 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 비디오 형식으로 이 콘텐츠를 보시는 것을 선호하신다면, 2023년 Droidcon 런던에서 제가 진행한 강연을 확인해보세요:\n\n## 상태 보유자\n\n상태 보유자는 로직을 처리하거나 UI 상태를 노출함으로써 UI를 간소화합니다. 이 섹션에서는 어떻게 상태 보유자를 구현하는지와 고려해야 할 구현 세부 사항을 살펴볼 것입니다.\n\n구현 세부 사항을 결정하기 위해 먼저 안드로이드 앱에서 일반적으로 발견되는 로직 유형을 식별해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 논리 유형\n\n이미 비즈니스 논리가 애플리케이션 데이터가 생성, 저장 및 수정되는 방법을 지정하는 제품 요구 사항을 구현하는 것을 의미한다는 것을 이야기했습니다. UI 레이어에 비즈니스 논리가 있는 경우, 이 논리를 화면 수준에서 관리하는 것이 좋습니다. 이후에 더 자세히 살펴보겠습니다.\n\n또 다른 유형의 논리는 UI 논리입니다. UI 논리는 화면 상태 변경을 어떻게 표시할지를 결정합니다. 비즈니스 논리가 데이터를 처리하는 방법을 지시하는 반면, UI 논리는 시각적으로 어떻게 표시할지를 결정합니다. UI 논리는 UI 구성에 의존합니다.\n\n예를 들어, 전형적인 앱에서 세부 화면을 표시하는 것은 휴대폰에서 실행 중일 때 탐색을 포함할 수 있습니다. 그러나 태블릿에서 실행 중일 때는 다른 요소를 옆에 표시하는 것을 의미할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png\" /\u003e\n\n다른 유형의 로직은 구성 변경에 다르게 반응합니다:\n\n- UI 로직은 구성 변경에 영향을 받는 경우 다시 실행해야 합니다.\n- 비즈니스 로직은 일반적으로 구성 변경 후에 계속되어야 합니다.\n\n예를 들어, 화면 크기 구성 변경 후에 하단 바 또는 네비게이션 레일을 표시할지 여부를 결정하는 UI 로직은 다시 실행하거나 재평가되어야 합니다. 반면, 특정 관심사를 따르거나 업데이트를 새로 고칠 때 사용자가 기기를 회전하거나 펼친다고 해서 비즈니스 로직을 취소하거나 다시 시작해서는 안 됩니다. 그러한 중단은 사용자 경험을 제공하지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 어떤 로직을 처리해야 할까요?\n\nUI 레이어에서 비즈니스 로직은 화면 수준에 가깝게 처리해야 합니다. 대부분의 비즈니스 로직은 데이터 레이어에서 처리됩니다. 따라서, 화면에 가까이 유지함으로써 로직을 올바르게 범위 지정하는 것이 쉬워지고, 저수준 UI 컴포넌트가 비즈니스 로직과 긴밀하게 결합되는 것을 방지할 수 있습니다.\n\n비즈니스 로직은 일반적으로 androidX.ViewModel에서 확장된 화면 수준 상태 홀더가 처리해야 합니다.\n\nUI 로직에 관련된 것은 비교적 간단한 경우, UI 자체에서 관리하는 것이 가능합니다. 그러나 UI가 더 복잡해지면 해당 UI 로직의 복잡성을 일반 클래스 상태 홀더로 위임하는 것이 좋은 아이디어입니다. 이 경우, 상태 홀더는 androidX.ViewModel에서 확장되지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 섹션에서 이것에 대해 더 자세히 살펴볼거에요! 이제 상태의 다양한 유형과 로직이 서로 어떻게 관련되는지 살펴봅시다:\n\n![image](/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_1.png)\n\n전형적인 화면에서 발생하는 일에 대한 요약으로, 데이터 레이어는 애플리케이션 데이터를 전체 계층에 노출시킵니다. 그런 다음 ViewModel은 그 데이터에 비즈니스 로직을 적용하여 화면 UI 상태를 생성합니다. UI 자체 또는 일반 상태 홀더 클래스는 화면 UI 상태를 관찰하여 UI 요소나 해당 상태를 수정합니다.\n\n# 비즈니스 로직 처리하기 — androidX.ViewModel\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 androidX.ViewModel 또는 Architecture Components ViewModel 클래스를 화면 수준 상태 보유자로의 구현 세부사항으로 상세하게 논의해 왔습니다.\n\n아래 코드 조각에서 우리는 주요 기능을 관찰할 수 있습니다: 1) 화면 UI 상태 노출 및 2) 비즈니스 로직 처리.\n\n```js\n@HiltViewModel\nclass InterestsViewModel @Inject constructor(\n  private val userDataRepository: UserDataRepository,\n  authorsRepository: AuthorsRepository,\n  topicsRepository: TopicsRepository\n) : ViewModel() {\n\n  val uiState: StateFlow\u003cInterestsUiState\u003e = ...\n\n  fun followTopic(followedTopicId: String, followed: Boolean) {\n    viewModelScope.launch {\n      userDataRepository.toggleFollowedTopicId(followedTopicId, followed)\n    }\n  }\n\n  ...\n}\n```\n\n그런데 왜 이러한 기능이 ViewModel에 적합한 것일까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## androidX.ViewModel의 장점\n\n가장 큰 장점은 ViewModel이 구성 변경을 견뎌내며 화면 자체보다 더 오랜 수명을 제공한다는 것입니다. ViewModel은 Activity, Fragment, Navigation 그래프 또는 Navigation 그래프의 대상에 대해 범위를 설정할 수 있습니다. 구성 변경이 발생할 때 시스템은 ViewModel의 동일한 인스턴스를 제공합니다.\n\n구성 변경을 견뎌내는 것은 androidX.ViewModel을 화면 UI 상태를 노출하고 비즈니스 로직을 처리하기에 완벽한 위치로 만듭니다. 화면 UI 상태는 구성 변경 전후에도 캐시되어 즉시 사용할 수 있습니다. 그리고 비즈니스 로직은 ViewModel-범위 CoroutineScope(예: viewModelScope로 시작된 경우)로 시작된 경우 계속 실행됩니다.\n\n또 다른 이점은 다른 Jetpack 라이브러리와의 완벽한 통합에 있습니다. 특히 Jetpack Navigation과의 통합이 원활합니다. Navigation은 대상이 백 스택의 일부인 경우 메모리에 ViewModel의 동일한 인스턴스를 유지합니다. 이를 통해 백 스택의 대상 간에 왕복할 수 있으며 데이터가 즉시 화면에 사용 가능하게 하여 해당 대상으로 다시 이동할 때마다 데이터를 다시로드할 필요가 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n젯팩 네비게이션은 목적지가 백 스택의 일부가 아닐 때 ViewModel의 인스턴스를 자동으로 파괴합니다. 이로 인해 이전 사용자 데이터가 화면에 표시되지 않고 이전 목적지로 안전하게 이동할 수 있습니다.\n\n다른 젯팩 통합에는 Hilt도 포함됩니다. @HiltViewModel 주석을 사용하면 도메인이나 데이터 레이어의 종속성이 있는 ViewModel을 손쉽게 얻을 수 있습니다.\n\n## androidX.ViewModel 모범 사례\n\nViewModel의 스코프는 화면 수준 상태 보유자의 구현 세부 정보로 이 유형을 적합하게 만듭니다. 그러나 이 권한을 남용해서는 안 됩니다. 이 클래스를 사용할 때 명심해야 할 몇 가지 모범 사례가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 화면 레벨에서 사용하세요. 재사용 가능한 UI 요소의 복잡성을 처리하기 위해 ViewModel을 사용하지 마세요. 동일한 ViewModel 스코프 내에서 동일한 UI 요소는 동일한 ViewModel의 인스턴스를 받게 되는데, 대부분의 경우 이는 바람직하지 않습니다.\n- ViewModel을 충분히 일반화하여 모든 UI 형식을 수용할 수 있도록 해주세요. ViewModel은 자신을 사용하는 UI가 무엇인지 인식하면 안 됩니다. ViewModel의 API 표면(공개된 Screen UI 상태 및 노출된 함수)은 UI별 세부 사항을 포함하는 대신 처리하는 응용 프로그램 데이터를 나타내야 합니다. 예를 들어, 데이터를 로딩 중임을 나타낼 때, 화면 UI 상태에는 showLoadingSpinner 대신 isLoading이라는 필드가 포함될 수 있습니다. UI가 데이터 로딩을 사용자에게 통지하는 방법은 UI에만 관련이 있습니다.\n- Lifecycle 관련 API에 대한 참조를 유지하지 마세요. ViewModel은 UI보다 오랜 수명을 가지고 있으며 Context나 Resources 객체에 대한 참조를 유지하면 메모리 누수로 이어질 수 있습니다.\n- ViewModel을 전달하지 마세요. 언급된 모든 점을 고려하면 ViewModel 클래스를 화면 수준에 가능한 가깝게 유지하세요. 그렇지 않으면 저수준 구성 요소에 실제로 필요한 상태와 로직보다 더 많은 액세스 권한을 암묵적으로 부여할 수 있습니다.\n\n## androidX.ViewModel 주의사항\n\nViewModel 영역은 모든 면에서 완벽하지 않습니다. 특히 ViewModel의 viewModelScope에 대한 몇 가지 고려할 사항이 있습니다:\n\n- viewModelScope를 사용하여 시작된 작업은 ViewModel이 메모리에 있는 동안 계속 실행됩니다. 이는 좋은 점이지만 작업이 긴 시간 동안 실행될 경우 문제가 발생할 수도 있습니다. 10초 이상 소요될 수 있는 장기 실행 작업의 경우 WorkManager와 같은 다른 대안을 고려해야 합니다. 배경 작업에 대한 자세한 내용은 문서를 참조하세요.\n- viewModelScope에 의해 트리거된 작업을 단위 테스트하기 위해서는 테스트 환경에서 추가 설정이 필요합니다. 테스트에서 MainDispatcher를 교체해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## AndroidX의 ViewModel 사용\n\n이 섹션은 항상 ViewModel을 사용해야 한다는 것을 의미합니까? 네, 화면 수준의 상태 보유자로의 구현을 말하면 그렇습니다. 하지만 이점이 앱에 적용된다면 사용해야 합니다.\n\n구성 변경에 관심이 있다면 (그래야 합니다!) 그리고/또는 다른 Jetpack 라이브러리를 사용 중이라면 이를 사용하는 것이 좋을 수 있습니다. 그러나 사용하지 않기로 결정하더라도, 화면 수준에서 비즈니스 로직 복잡성을 다루는 간단한 화면 수준 상태 보유자 클래스를 도입하는 것을 고려해보세요.\n\n# UI 로직 처리 — 간단한 상태 보유자 클래스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI가 점점 복잡해지면 상태 보유 클래스를 도입해야 합니다. 기준은 당신과 팀에 달렸습니다. UI를 간소화해야 할 필요성을 느끼는 때입니다.\n\n다가오는 코드 스니펫에서 UI에 대한 상태 보유자를 생성할 필요가 없습니다. 사용자가 UI와 상호 작용할 때 변경되는 확장된 부울 값만 포함되어 있습니다.\n\n```js\n@Composable\nfun \u003cT\u003e NiaDropdownMenuButton(items: List\u003cT\u003e, ...) {\n  var expanded by remember { mutableStateOf(false) }\n\n  Box(modifier = modifier) {\n    NiaOutlinedButton(\n      onClick = { expanded = true },\n      ...\n    )\n    NiaDropdownMenu(\n      expanded = expanded,\n      onDismissRequest = { expanded = false },\n      ...\n    )\n}\n```\n\nUI에 더 많은 상태가 필요하고 관련 로직이 더 복잡해지면 상태 보유자를 도입하세요. Compose 라이브러리가 일부 구성 요소에 대해 수행하는 것과 정확히 동일합니다. 다음 코드 스니펫은 다양한 Drawer 구성 구성 요소의 상태 보유자에 속합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin {.line-numbers}\n@Stable\nclass DrawerState(\n  initialValue: DrawerValue,\n  confirmStateChange: (DrawerValue) -\u003e Boolean = { true }\n) {\n  internal val swipeableState = SwipeableState(...)\n\n  val currentValue: DrawerValue\n    get() { return swipeableState.currentValue }\n\n  val isOpen: Boolean\n    get() = currentValue == DrawerValue.Open\n\n  suspend fun open() = animateTo(DrawerValue.Open, AnimationSpec)\n\n  suspend fun animateTo(targetValue: DrawerValue, anim: AnimationSpec\u003cFloat\u003e) {\n    swipeableState.animateTo(targetValue, anim)\n  }\n}\n```\n\n여기 몇 가지 주요 포인트가 있어요:\n\n- 이 클래스는 Drawer의 현재 값을 나타내는 것처럼 상태를 유지합니다.\n- 상태 홀더들은 합성 가능합니다. DrawerState는 내부적으로 다른 상태 홀더인 SwipeableState에 의존합니다.\n- UI 로직을 관리하며, 서랍을 여는 동작 및 특정 값으로 애니메이션 하는 등의 작업을 포함합니다.\n\nCompose가 이러한 상태 홀더를 제공하는 것처럼, 당신의 프로젝트에서도 UI를 단순화하기 위해 비슷한 패턴을 구현할 수 있어요. 다음 코드 스니펫은 NiaApp 구성 요소 함수의 상태 홀더인 NiaAppState에 속합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Stable\nclass NiaAppState(\n  val navController: NavHostController,\n  val windowSizeClass: WindowSizeClass\n) {\n  val currentDestination: NavDestination?\n    @Composable get() = navController\n      .currentBackStackEntryAsState().value?.destination\n\n  val shouldShowBottomBar: Boolean\n    get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n      windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n\n  fun navigate(...) { ... }\n\n  fun onBackClick() { ... }\n}\n```\n\n비슷한 방식으로,이 클래스는 currentDestination 및 하단 바를 표시해야 하는지 여부와 같은 UI 상태를 노출하고, 네비게이션 및 백 버튼 클릭 이벤트 처리와 같은 UI 논리를 관리합니다.\n\n## 일반적인 상태 보유 클래스의 최상의 관행\n\n재사용 가능한 UI 구성 요소를 위한 상태 보유자를 만드는 것이 좋습니다. 이는 UI의 재사용성을 향상시키고 외부 제어를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반 상태 보유 클래스는 수명주기 관련 API의 참조를 보유할 수 있습니다. 이 인스턴스들은 UI 수명주기를 따릅니다. UI가 구성 변경을 겪을 때마다 상태 보유 클래스의 새 인스턴스가 생성됩니다. 따라서 Context나 Resources에 대한 참조를 보유해도 메모리 누수가 발생하지 않습니다. Jetpack Compose에서 이러한 상태 보유 클래스는 Composition에도 스코프가 지정됩니다.\n\n일반 클래스가 비즈니스 로직이 필요한 경우, 해당 기능을 클래스에 주입하는 것이 좋은 실천 방법입니다. 이 기능을 주입하는 쪽은 UI 범위를 벗어나도록 보장할 수 있습니다.\n\n## 대규모 ViewModels 다루기\n\nViewModel이 여러 큰 UI 요소들의 비즈니스 로직 복잡성을 처리하고 있는 경우, 이는 크고 관리하기 어렵고 추론하기 어려울 수 있습니다. ViewModel을 어떻게 간소화할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도메인 레이어를 소개합니다. ViewModel의 비즼스 로직 복잡성을 다양한 리포지토리와 상호 작용을 처리하는 유즈 케이스에 위임합니다. 그러나 이 접근 방식은 여전히 ViewModel이 의존해야 하는 상당한 수의 유즈 케이스 목록을 일으킬 수 있습니다.\n- UI의 다양한 요소에 대해 여러 상태 홀더를 만들어 그 이점을 모두 누릴 수 있도록 ViewModel에 이를 넣어두세요. ViewModel은 핵심적으로 구성 변경을 견디는 상태 전달 메커니즘이 됩니다.\n- #2 대신, 재사용할 수 없는 UI 요소의 복잡성을 관리하기 위해 여러 개의 ViewModel을 만드는 것을 고려해 볼 수 있습니다. 이러한 방식은 허용되지만, ViewModel은 메모리가 제한되지 않는 상태로 작동하며, 여러 ViewModel을 가지면 그 크기와 메모리 풋프린트를 모니터링하기 어려워질 수 있음을 염두에 두세요.\n\n# 상태를 어디에 둘 것인가\n\n상태를 읽거나 쓰는 가장 낮은 공통 조상에 둘 것을 권장합니다.\n\n요약하면: UI에서 상태가 전혀 없을 수 있고, UI 자체에 상태가 있을 수도 있고, UI를 단순화하기 위해 상태 홀더에 상태가 있을 수도 있고, 다른 구성 요소 호출자나 조상이 상태를 제어할 수 있도록 UI 트리 상단에 상태를 올릴 수도 있고, 비즈니스 로직에서 필요한 경우 ViewModel에 상태를 올릴 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIf the state is required by business logic, whether for reading or writing, it should be hoisted in the screen-level state holder. If not, it should be placed in the appropriate node of the UI tree.\n\nLet’s take a look at the UI hierarchy of a typical Chat app and discuss why certain state is placed where it is:\n\n![UI Hierarchy](/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_2.png)\n\n- The screen UI state should be placed in the ViewModel (#5) because the ViewModel applies business logic to create it.\n- The LazyList is part of the ConversationScreen and not the MessagesList because the screen has additional functionality that require that state, such as scrolling to the most recent messages when the user sends a new message in UserInput.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 주제에 대해 더 알아보려면 Alejandra Stamato가 하는 State hoisting in Compose 이야기를 확인해보세요.\n\n# UI 상태 저장하기\n\n이 블로그 포스트에서는 androidx.ViewModel API를 사용하여 구성 변경 사항에 걸쳐 상태를 유지하는 수단으로 탐색했습니다. 그러나 안드로이드는 상태를 더 효과적으로 보호하는 추가 대안을 제공합니다.\n\nSavedState API를 사용하면 구성 변경과 시스템에서 시작된 프로세스 종료를 통해 상태가 지속될 수 있습니다. 시스템은 이 데이터를 Bundle에 저장하며, 저장을 위해 데이터를 parcel화해야 합니다. 전형적으로 사용자 입력이나 탐색에 따라 달라지는 일시적 UI 상태를 저장할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래도, 위에서 언급한 것뿐만 아니라 예상치 못한 앱 종료(예: 사용자가 앱을 강제로 종료)에도 살아남기 위해 지속적인 저장소를 사용할 수 있습니다. 이것은 디스크 공간 제한을 고려해야 하며 일반적으로 응용 프로그램 데이터를 저장하는 데 사용됩니다.\n\n![Crash Course on the Android UI Layer Part 2_3](/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_3.png)\n\n이 주제에 대한 자세한 내용은 Android에서 UI 상태 저장하기 토크를 확인하세요.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI 계층에 대한 이 간단한 소개를 읽은 후에는 이 계층 내에서 발생하는 프로세스와 상태 및 로직을 효과적으로 관리하는 데 필요한 도구에 대한 일반적인 이해를 가지고 있을 것입니다.\n\n안드로이드는 앱을 다양한 UI 구성 및 기기에 반응적으로 만들도록 설계되어 있어, 일부 개발자들이 원하는 것보다 약간 복잡한 API 결정 트리들을 만듭니다. 그러나 동시에 예상대로 앱이 동작하도록 하는 도구를 제공해주어 훌륭한 사용자 경험을 전달할 수 있게 해줍니다.\n\n이 내용을 즐기셨기를 바랍니다! 의견을 공유하거나 질문을 하고 싶으시다면 댓글 섹션에서 자유롭게 남겨주세요! 감사합니다 😊\n\n만약 비디오 형식으로 내용을 소화하고 싶다면, 2023년 드로이드콘 런던에서 발표한 제 이야기를 확인해보세요!\n","ogImage":{"url":"/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png"},"coverImage":"/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png","tag":["Tech"],"readingTime":16},{"title":"기초부터 배우는 Kotlin 코루틴 사용법","description":"","date":"2024-06-23 23:18","slug":"2024-06-23-KotlinCoroutinesFundamentals","content":"\n코루틴은 이미 오랫동안 존재하고 있고 여러 다양한 기사들이 그 주변에 존재합니다. 그러나 그것에는 깊은 학습 곡선이 존재하여 Coroutines의 기본 원리를 실제로 이해하는 데 꽤 많은 시간이 걸렸습니다. 그래서 내가 이해한 바에 따라 몇 가지 배운 점을 공유하고 싶다고 생각했습니다.\n\n# 코루틴이란 무엇인가?\n\n코루틴은 협력하는 함수를 의미합니다. 비동기 작업을 처리하는 더 효율적이고 읽기 쉬운 방법을 제공합니다. 쓰레드와 유사하다는 점에서, 일련의 코드 블록을 실행하는데 사용되며 나머지 코드와 동시에 작동합니다. 그러나 코루틴은 특정 쓰레드에 묶이지 않습니다. 한 쓰레드에서 실행을 일시 중단할 수 있고 다른 쓰레드에서 다시 실행할 수 있습니다. 코루틴은 코틀린 1.3 버전에서 출시되었습니다.\n\n# 코루틴의 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 코루틴은 가볍습니다 - 지원하는 ​​일시 정지로 인해 한 쓰레드에서 많은 코루틴을 실행할 수 있습니다. 여기서 일시 정지란 몇 가지 명령을 실행한 다음 해당 코루틴을 실행 중간에 중지하고 원하는 때 이어서 실행할 수 있다는 것을 의미합니다. 일시 정지는 많은 동시 작업을 지원하면서도 차단보다 메모리를 절약합니다.\n- 코루틴은 메모리 누수가 적습니다 - 코루틴은 구조화된 동시성 원칙을 따르며, 각 코루틴은 특정 컨텍스트 내에서 특정한 수명을 갖고 시작되어야 합니다. 구조화된 동시성은 코루틴의 수명이 특정 범위에 묶여 범위 자체가 완료되기 전에 범위 내에서 시작된 모든 코루틴이 완료되도록 하는 방식입니다. 이는 코루틴 누출을 방지하고 리소스 관리를 단순화하는 데 도움이 됩니다.\n- Android에서 코루틴은 Main 안전성을 제공합니다 - 코루틴은 메인 스레드를 블로킹하고 응용 프로그램이 응답하지 않게 만들 수 있는 긴 시간 소요 작업을 관리하는 데 도움이 됩니다. Main 안전성을 통해 어느 suspend 함수도 메인 스레드에서 호출할 수 있도록 할 수 있습니다.\n- 코루틴은 내장된 취소 지원을 제공합니다 - 코루틴의 가장 중요한 메커니즘 중 하나는 취소입니다. Android에서 거의 모든 코루틴이 어떤 뷰와 관련이 있으며 이 뷰가 파괴되면 해당 코루틴은 필요하지 않으므로 취소되어야 합니다. 이는 개발자들에게 많은 노력이 필요했던 중요한 기능이지만, 코루틴은 간단하고 안전한 취소 메커니즘을 제공합니다.\n- 코루틴은 협력적으로 멀티태스킹됩니다 - 이는 코루틴이 협력적으로 실행할 일련의 명령을 실행하고 운영 체제가 코루틴에 의해 수행되는 작업이나 프로세스의 스케줄링을 제어하지 않음을 의미합니다. 대신, 프로그램과 해당 코루틴을 실행하는 플랫폼에 의존합니다. 따라서 코루틴은 다른 쓰레드가 실행되도록 제어를 양보하여 스케줄러에 다시 제어를 위임할 수 있습니다. 운영 체제의 스케줄러는 이러한 쓰레드들이 작업을 수행할 수 있도록 책임을 집니다. 필요한 경우 일시 중단하여 같은 리소스를 다른 쓰레드가 사용할 수도 있습니다.\n\n# 코루틴의 키워드\n\n코루틴에 대해 학습할 때 마주치게 될 몇 가지 일반적인 키워드입니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 중지 함수\n- Coroutine Scope (Dispatchers, Job 포함)\n- Coroutine 빌더\n- Coroutine Context\n\n## `중지` 함수\n\n중지 함수는 일시 중지되고 나중에 계속할 수 있는 함수입니다. 중지 함수는 해당 함수가 중지될 수 있다는 것을 나타내며, 비차단 작업이 완료될 때까지 기다리는 동안 다른 코루틴이 실행될 수 있습니다. 중지 함수가 실행되는 동안 해당 코루틴은 실행되던 스레드를 해제하고 다른 코루틴이 그 스레드에 액세스할 수 있도록 합니다(코루틴은 협력적이기 때문입니다).\n\n중지 함수의 구문은 일반 함수의 구문과 동일하지만 `suspend` 키워드가 추가됩니다. 중지 함수는 코루틴이나 다른 중지 함수에서만 호출할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nsuspend fun doSomething(): Int {\n    delay(1000L) // 여기서 유용한 작업을 수행하는 것처럼 가정합니다\n    return 13\n}\n```\n\n## 코루틴 스코프\n\n코루틴 스코프는 코루틴의 수명 주기/수명을 정의합니다. 일련의 코루틴 및 해당 컨텍스트의 수명을 제어하는 역할을 합니다. CoroutineScope는 생성된 모든 코루틴을 추적합니다. 따라서 스코프를 취소하면 생성된 모든 코루틴이 취소됩니다. 부모 코루틴 내에서 자식 코루틴이 시작될 때 부모 스코프를 상속합니다(별도로 지정하지 않은 경우) 따라서 부모 코루틴이 중지되면 자식 코루틴도 중지됩니다.\n\nAndroid에서는 코루틴에는 세 가지 기본 스코프가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 글로벌 범위: GlobalScope는 전체 애플리케이션 수명 동안 지속되는 미리 정의된 코루틴 범위입니다. 편리할 수 있지만 일반적으로 구조화된 동시성을 보장하기 위해 사용자 정의 코루틴 범위를 사용하는 것이 권장됩니다.\n\n```kotlin\nGlobalScope.launch {\n        val config = fetchConfigFromServer() // 네트워크 요청\n        updateConfiguration(config)\n    }\n```\n\n- LifeCycle 범위: LifecycleOwner(프래그먼트 액티비티)의 수명에 바인딩됩니다. 프래그먼트 액티비티가 파괴되면 이 범위의 코루틴도 취소됩니다. LifecycleScope를 사용하면 특별한 실행 조건을 사용할 수도 있습니다:\n\n* launchWhenCreated는 라이프사이클이 최소한 생성 상태에 있을 때 코루틴을 시작하고 파괴 상태에 있을 경우 일시 중단합니다.\n* launchWhenStarted는 라이프사이클이 최소한 시작 상태에 있을 때 코루틴을 시작하고 중지 상태에 있을 경우 일시 중단합니다.\n* launchWhenResumed는 라이프사이클이 최소한 재개 상태에 있을 때 코루틴을 시작하고 일시 중단합니다.\n\n```kotlin\nlifecycleScope.launchWhenResumed {\n  println(\"로딩 중..\")\n  delay(3000)\n  println(\"작업 완료\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ViewModel Scope: ViewModel의 수명에 바인딩됩니다. ViewModel이 해제되면이 범위 내의 코루틴도 취소됩니다.\n\n```js\nviewModelScope.launch {\n  println(\"로딩 중..\")\n  delay(3000)\n  println(\"작업이 완료되었습니다\")\n}\n```\n\n## 코루틴 빌더\n\n코루틴 빌더는 새로운 코루틴을 초기화하거나 생성하기 위한 함수입니다. 코루틴의 실행을 시작하고 제어하는 편리한 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `launch`: 새로운 coroutine을 동시에 시작합니다. 예를 들어, 현재 스레드를 차단하지 않고 시작됩니다. 해당 작업이 취소될 때 자동으로 취소되며 결과 작업이 취소될 때 결과를 반환하지 않습니다. `launch`의 반환 유형은 `Job`입니다. 따라서 해당 작업과 상호 작용하여 coroutine의 라이프사이클을 제어할 수 있습니다. `job.cancel()`을 호출하여 쉽게 취소할 수 있습니다. `launch`는 ViewModel에서 비-suspending 코드에서 suspending 코드로 연결을 생성하는 데 자주 사용됩니다.\n\n```js\nlaunch {\n    delay(1000L)\n    println(\"Hello World!\")\n}\n```\n\n- `runBlocking`: 새로운 coroutine을 실행하고 현재 스레드를 해당 완료까지 차단합니다. 다시 말해, 해당 coroutine에서 실행되는 스레드는 주어진 기간 동안 해당 괄호 내의 모든 코드 블록이 실행을 완료할 때까지 차단됩니다.\n\n```js\nfun main() = runBlocking { // this: CoroutineScope\n    doWorld()\n}\n\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"Hello Kotlin!\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- async: 컨테이너{launch} 함수처럼, 새로운 코루틴을 시작하는 데 사용되며, 차이점은 Job 대신 deferred를 반환한다는 것입니다. deferred는 결과를 나중에 전달할 것을 약속하는 비차단(future)인데, 결과 deferred가 취소되면 실행 중인 코루틴도 취소됩니다. async 빌더를 사용하면 반환된 값을 얻으려면 `await`를 호출하면 됩니다.\n\n```kotlin\nfun main() = runBlocking\u003cUnit\u003e {\n\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n\n}\n```\n\n- delay: 특정 시간 동안 함수를 중단하고 그 후에 다시 시작하는 용도로 사용되는 중단 함수입니다. 백그라운드 스레드를 차단하지 않고 다른 코루틴들이 실행되고 백그라운드 스레드를 사용할 수 있도록 합니다.\n\n```kotlin\nlaunch {\n    delay(2000L)\n    println(\"World 2\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- withContext: 현재 코루틴 내에서 코루틴 컨텍스트를 전환하는 데 사용되는 지연 함수입니다. 현재 코루틴을 일시 중단하고 지정된 컨텍스트로 전환한 후 새 컨텍스트에서 실행을 계속합니다. 일반적으로 해당 함수를 사용하여 코루틴이 실행될 디스패처를 전환합니다. withContext를 사용하면 콜백을 도입하지 않고 코드가 어느 스레드에서 실행될지 제어할 수 있기 때문에 데이터베이스에서 읽기나 네트워크 요청과 같은 매우 작은 함수에 적용할 수 있습니다.\n\n```kotlin\nfun main() = runBlocking {\n    val data = withContext(Dispatchers.IO) {\n        fetchData()\n    }\n    println(\"Response = $data\")\n}\n\nsuspend fun fetchData(): String {\n    return \"Hello world!\"\n}\n```\n\n## 코루틴 컨텍스트\n\n코루틴 컨텍스트는 코루틴의 동작과 특성을 정의하는 요소들의 세트입니다. 디스패처, 작업, 예외 처리기 및 코루틴 이름과 같은 요소를 포함합니다. 이 컨텍스트는 코루틴이 어떻게 어디에서 실행될지 결정하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n디스패처\n\n코루틴 디스패처는 코루틴이 실행될 스레드를 결정하는 역할을 합니다. 디스패처에는 4가지 유형이 있습니다:\n\n- 메인 디스패처(Main Dispatchers) — 메인 디스패처는 코루틴을 메인 스레드에서 실행합니다. 메인 디스패처는 대부분의 UI 작업을 수행합니다.\n- IO 디스패처(IO Dispatchers) — IO 디스패처는 IO 스레드에서 코루틴을 시작합니다. 이 디스패처는 필요할 때 생성되는 스레드 풀을 사용합니다. 파일 읽기 또는 쓰기, 데이터베이스 쿼리 수행, 네트워크 요청 등 실행 스레드를 차단할 수 있는 I/O 작업에 적합합니다.\n- 기본 디스패처(Default Dispatchers) — 다른 디스패처가 명시적으로 지정되지 않은 경우 사용되는 기본 디스패처입니다. 공유 백그라운드 스레드 풀을 활용합니다. CPU 자원이 필요한 계산 집약적인 코루틴에 적합한 선택지입니다.\n- 비제한 디스패처(Unconfined Dispatcher) — 코루틴이 어떤 스레드에서도 실행되도록 허용합니다. 각 resume마다 다른 스레드에서 실행될 수 있습니다. 특정 스레드에 한정된 CPU 사용이나 공유 데이터 업데이트가 필요 없는 코루틴에 적합합니다.\n\n```js\nfun main() = runBlocking {\n    launch { // 부모의 콘텍스트인 메인 runBlocking 코루틴\n        println(\"main runBlocking      : 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n    launch(Dispatchers.Unconfined) { // 제한 없음 -- 메인 스레드에서 작동\n        println(\"Unconfined            : 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n    launch(Dispatchers.Default) { // DefaultDispatcher에 디스패치됩니다\n        println(\"Default               : 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // 자체 새로운 스레드를 가져옵니다\n        println(\"newSingleThreadContext: 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코루틴을 실행하려면 Executor.asCoroutineDispatcher() 확장 기능을 사용하여 코루틴 디스패처로 변환하여 쓰레드 풀에서 실행할 수도 있습니다. 프라이빗 쓰레드 풀은 다음을 사용하여 생성할 수 있습니다:\n\n- newSingleThreadContext(): 내장된 yield 지원이 있는 전용 쓰레드를 사용하여 코루틴 실행 환경을 만듭니다. 원시 자원(스레드 자체)을 할당하는 믹서된 API로 조심스럽게 관리가 필요합니다.\n- newFixedThreadPoolContext: 고정 크기의 쓰레드 풀을 사용하여 코루틴 실행 환경을 설정하여, 코루틴의 병렬 실행을 가능하게 하면서 스레드 자원을 주의 깊게 관리합니다.\n\n코루틴 작업\n\n생성된 매 코루틴마다 Job 인스턴스가 반환되는데, 이를 통해 해당 코루틴을 고유하게 식별하고 라이프사이클을 관리할 수 있습니다. Job은 대기열에서의 코루틴을 가리키는 핸들 역할을 합니다. Job은 다음과 같은 상태를 가집니다: New, Active, Completing, Completed, Cancelling, Cancelled. 상태 자체에는 접근할 수 없지만, Job의 속성: isActive, isCancelled 및 isCompleted에 접근할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nval job = launch { // 새로운 코루틴을 시작하고 해당 작업에 대한 참조를 유지합니다\n    delay(1000L)\n    println(\"안녕, 세상아!\")\n}\njob.join() // 자식 코루틴이 완료될 때까지 기다립니다\nprintln(\"완료\")\n```\n\nSupervisorJob — 이것은 자식 코루틴에 대한 감독자 역할을 하는 Job의 구현입니다. 일반 Job과 유일한 차이점은 그 자식들이 서로 독립적으로 실패할 수 있다는 것입니다. 자식의 실패나 취소는 감독자 작업의 실패를 일으키거나 다른 자식에 영향을 주지 않으므로 감독자는 자식의 실패에 대한 고유 정책을 작성할 수 있습니다.\n\n```kotlin\nfun main() = runBlocking {\n    val supervisorJob = SupervisorJob()\n\n    val coroutine1 = launch(supervisorJob) {\n        println(\"코루틴 1\")\n        throw RuntimeException(\"코루틴 1에서 오류 발생\")\n    }\n\n    val coroutine2 = launch(supervisorJob) {\n        println(\"코루틴 2\")\n        delay(500)\n        println(\"코루틴 2 완료\")\n    }\n\n    coroutine1.join()\n    coroutine2.join()\n\n    println(\"부모 코루틴: ${supervisorJob.isActive}\") // 출력: 부모 코루틴: true\n}\n```\n\n## 코루틴 취소\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코루틴에서 취소는 Job을 통해 관리됩니다(Job은 코루틴에 대한 핸들이며 수명주기가 있습니다). 우리는 코루틴을 Job의 .cancel() 함수를 호출하여 취소할 수 있습니다. 여러 개의 코루틴을 시작할 때, 전체 스코프 내에 생성된 모든 자식 코루틴을 취소하기 위해 의존할 수 있습니다.\n\n취소는 CancellationException을 throw하는 것 이상의 것이 아닙니다. 여기서의 중요한 차이점은 코루틴이 CancellationException을 throw하면 정상적으로 취소된 것으로 간주되며, 다른 예외는 실패로 간주됩니다. 코루틴 라이브러리에서 제공되는 일시정지 함수는 취소할 수 있지만, 코드를 작성할 때는 항상 취소와 협력하는 것을 고려해야 합니다.\n\n- 코드를 취소할 수 있게 만드는 한 가지 방법은 현재 Job의 상태를 명시적으로 확인하는 것입니다. CoroutineContext와 CoroutineScope에서 모두 isActive() 확장 함수를 사용할 수 있습니다.\n- 다른 일반적인 취소 확인 방법은 ensureActive()를 호출하는 것입니다. 이것은 Job, CoroutineContext 및 CoroutineScope에 사용할 수 있는 확장 함수입니다.\n\n취소에 대한 자세한 내용은 여기와 여기에서 찾을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친구들이 읽어주셔서 감사합니다! 코루틴에 대해 다뤄본 건 정말 많았지만, 유용한 정보였길 바랍니다. 댓글란에 의견을 남겨주세요.\n\n코딩 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png"},"coverImage":"/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png","tag":["Tech"],"readingTime":13},{"title":"시스템 설계를 처음부터 배우기 레슨 1","description":"","date":"2024-06-23 23:17","slug":"2024-06-23-StartingfromScratchSystemDesignLesson1","content":"\n가장 중요한 것은 모든 시스템 디자인 질문에 대해 마음속에 일반적인 구조를 만들고 그 기본 구조를 토대로 스스로를 발전시키고 향상시켜야 한다는 것을 기억해야 합니다.\n\n다음 설계를 살펴보고 이를 향후 레슨의 기본으로 활용해 봅시다.\n\n너에게 너무나 압도적으로 보일지도 몰라요...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n깊게 숨을 들이펴 보세요, 단계별로 차근차근 진행할 거에요. :)\n\n# BABY STEPS :)\n\n- 먼저 API-Gateway로 요청이 전달되어 시스템의 입구 역할을 합니다.\n- 그런 다음 로드 밸런서에 요청이 전달됩니다. 이는 한 대의 서버가 너무 많은 요청을 받지 않도록 관리하는 역할을 합니다. 요청은 다른 인스턴스로 분산되어 시스템이 올바르게 작동할 수 있도록 보장합니다.\n- 분산 캐시가 사용되어 지연 시간을 줄일 수 있습니다. 항상 백엔드로 호출할 필요는 없습니다.\n- 그리고 쿠버네티스, 도커 및 여러 백엔드 서비스 인스턴스를 사용하는 구조가 나옵니다. 간단히 말해 백엔드 서비스는 비즈니스 요구사항을 충족하며, 쿠버네티스는 모든 인스턴스가 켜져 있을 필요가 없는 경우 자동으로 확장을 관리합니다.\n- 그런 다음 캐시를 사용할 수 있습니다. (여기서 주의해야 할 점: 캐시 무효화, 캐시 제거 정책)\n- 구조적인 데이터는 RDBMS로 이동합니다.\n\n이곳에서 리더-팔로워 아키텍처가 따라지며 (리플리케이션 전략은 높은 읽기 요구량을 처리하고 리더가 다운되었을 때 데이터 손실을 줄이는 데 사용됩니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. 필요한 데이터는 비즈니스 로직이 요구사항을 처리하고 프로세스가 성공했을 때 서비스로 다시 전송됩니다.\n\n7a. 데이터는 또한 ELK, Kibana, Grafana로 전송되어 관측 메트릭 및 로그 추적이 이루어집니다.\n\n8. 9. 10.\n\n사용자는 요청이 완료되었음을 알림받아야 합니다. 이를 위해 알림 메시지가 알림 대기열로 전송되어 사용자가 오프라인 상태라도 메시지가 지속됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예외:\n\n8`a-8`b\n\n연결 문제 또는 기술적 결함으로 요청이 성공적으로 처리되지 않은 경우, 해당 요청(또는 메시지)은 다시 서비스로 전송되어 재처리됩니다.\n\n5`a-5`b\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 비구조화된 데이터를 저장해야 하는 사용 사례에서는 NoSQL 데이터베이스에 데이터를 저장하고 Kibana/Grafana/ELK로 데이터를 보내어 분석 목적이나 로그 추적에 활용합니다.\n\n감사합니다. 저희 사람들을 계속 성장해 주세요!\n","ogImage":{"url":"/assets/img/2024-06-23-StartingfromScratchSystemDesignLesson1_0.png"},"coverImage":"/assets/img/2024-06-23-StartingfromScratchSystemDesignLesson1_0.png","tag":["Tech"],"readingTime":3},{"title":"쿠버네티스 이스티오 앰비언트 메쉬 투어  1부 설정 및 Z터널 사용 방법","description":"","date":"2024-06-23 23:14","slug":"2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel","content":"\n피츠오는 앰비언트 모드로 전환하고 있어요 — 사이드카 없는 모델로 말이죠. 마침내 우리는 CPU와 메모리 소비가 많은 사이드카를 버릴 수 있게 되었어요!\n\n다가오는 장마시즌을 맞아, 저는 피츠오 앰비언트 메시에 간접적으로 참여해보기로 했어요.\n\n이 블로그를 사용하여 여행을 문서화하고, 비슷한 생각을 가진 피츠오 사용자들이 함께 따라올 수 있게 도와볼 거예요 :P.\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제가 나름대로 번역해보겠습니다:\n\n안녕하세요! Part 1에서는 주변 메시 실험을 위해 로컬 클러스터 설정을 완벽하게 진행할 예정입니다. 그런 다음 메시의 ztunnel 구성 요소를 탐험할 것입니다.\n\nPart 2에서는 L4 인증 정책에 대해 이야기하고 waypoint 프록시를 시작하는 방법을 살펴볼 것입니다.\n\n# Ambient란 무엇인가요?\n\nIstio Ambient Mesh는 사이드카 없이 Istio의 새로운 데이터플레인 모드입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반적인 Istio 모드에서는 모든 응용 프로그램 Pod이 envoy 프록시로 주입되었다는 것을 기억하십시오. 그러나 이 새로운 모드에서는 응용 프로그램 Pod이 건드리지 않을 거에요 :) 그리고 그들은 자신의 응용 프로그램 컨테이너만 가지게 될 거에요.\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_1.png)\n\n가장 먼저 떠오르는 큰 장점 중 하나는 인프라 비용이 크게 절감된다는 것입니다. 컴퓨팅 코어 및 메모리 관점에서 얼마나 많은 돈을 절약하고 있는지 상상해보세요 !!\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Ambient Architecture\n\n과거와 현재의 Ambient Architecture를 상상해 보는 시간입니다. 데이터 평면의 트래픽 흐름 경로에서 그들이 어떻게 다른지 살펴봅시다.\n\n## Sidecar 모드\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이것은 전통적인 사이드카 모델이며 각 서비스 팟에는 애플리케이션 컨테이너와 Envoy 사이드카가 결합되어 있습니다. 애플리케이션으로부터 오고 가는 모든 트래픽은 사이드카에 의해 가로채집니다.\n\n## Ambient 모드, ztunnel 사용\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_4.png)\n\n이 새로운 ambient 모드에서 애플리케이션 팟은 사이드카가 없는 독립적인 팟입니다. 그러나 이 경우에는 클러스터의 각 Kubernetes 노드마다 데몬셋 팟이 실행될 것입니다 - 강력한 ztunnel (제로 트러스트 터널). 노드 내 팟간의 모든 트래픽은 ztunnel에 의해 가로채집됩니다. Ztunnel은 각 노드당 L4 프록시입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Ambient mode, with ztunnel + waypoint\n\n![Image](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_5.png)\n\nZtunnel은 L4 프록시가 필요한 워크로드 간 네트워킹에 충분합니다. http 헤더 기반 라우팅, L7 권한 부여와 같은 L7 요구 사항을 충족시키기 위해 waypoint 프록시라는 워크로드를 배포합니다. 이는 애플리케이션당 envoy 팟으로, 동일한 노드 또는 다른 노드에서 실행될 수 있습니다.\n\n이 경우 ztunnel에서 생성된 트래픽은 waypoint 프록시에 도달하고, waypoint는 그것을 목적지 ztunnel로 전달합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러므로, 어플리케이션이 L7 처리를 요구하지 않는 경우 waypoint를 없애고 ztunnel만 사용할 수 있습니다. 이전 방식에서는, 우리가 L4 요구사항만 가지고 있더라도 envoy sidecars를 반드시 사용해야 했습니다.\n\n# 클러스터 설정 깊이에 대한 정보\n\n이상적으로 지원되는 환경에서 사용할 수 있는 유효한 CNI 설정으로 Kind 클러스터를 설정하는 데 많은 조정이 필요했습니다. 현재는 어떤 공개 GKE/AKS/EKS k8s 클러스터에 대한 실험을 할 수 있는 권한이 없습니다.\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러므로 로컬 Kind 클러스터를 홈 설정하겠습니다.\n\n## 시스템 사양\n\n- Mac M1 (Apple-Silicon 아키텍처)를 사용하며 기본 구성으로 진행됩니다.\n\n시스템 아키텍처(Linux/Windows/Apple Intel)를 고려하여 비슷하게 진행할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Rancher Desktop\n\n저희 k8s 클러스터를 위해 도커 런타임이 필요한데, 저는 SUSE의 Rancher Desktop을 사용할 예정입니다 — https://rancherdesktop.io/.\n\n다른 대안으로는 Docker Desktop이 있습니다 — https://www.docker.com/products/docker-desktop/\n\n- Kind\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 Multi-Node K8s 클러스터가 필요하다고 생각해요. 그래서 우리가 사용할 최상의 도구는 Kind를 이용해 클러스터를 부트스트랩하는 거죠. 여기 https://kind.sigs.k8s.io/docs/user/quick-start 에서 보다 자세한 정보를 얻을 수 있어요.\n\n이를 통해 우리는 k8s 노드에 ssh로 접속하고 노드 구성을 실험해볼 수도 있을 거에요.\n\n그리고 블로그에 나온대로 istio-ambient 프로필을 설치한 후에는 Kind 노드에서 문제가 발생할 수 있어요. 여기 https://kind.sigs.k8s.io/docs/user/known-issues/#pod-errors-due-to-too-many-open-files 에서 문제를 해결할 수 있어요. 영향을 받는 노드의 sysctl.conf를 수정한 후에는 istio-system pods가 문제없이 생성될 거에요.\n\n\u003cimg src=\"/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_7.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- CNI(Container Networking Interface)\n\n\"Istio Ambient Mode\"은 Calico, Cilium 등과 같은 CNI와 함께 지원됩니다. Kind 클러스터의 기본 CNI는 \"kindnetd\"이며, 저는 직접 테스트해 본 결과 ztunnel 팟이 실행되지 않았습니다. 그래서 다른 CNI가 필요했습니다.\n\n- Cilium CNI도 Mac M1에서 제대로 로드되지 않았습니다. 즉, cilium 데몬셋 팟이 실행되지 않았습니다.\n- 마침내 Calico CNI로 Kind를 설정하는 방법을 찾았습니다. Kind에서 기본 CNI를 비활성화하고 다음과 같이 진행합니다: [https://docs.tigera.io/calico/latest/getting-started/kubernetes/kind](https://docs.tigera.io/calico/latest/getting-started/kubernetes/kind)\n- 이 설정에서 마지막 단계를 따를 수도 있습니다: [https://alexbrand.dev/post/creating-a-kind-cluster-with-calico-networking/](https://alexbrand.dev/post/creating-a-kind-cluster-with-calico-networking/)\n\n# Istio 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 클러스터 개요\n\n이스티오를 시작하기 전에 클러스터 스펙을 살펴봅시다.\n\n다음은 Kind 클러스터 설정 스크립트입니다.\n\n마스터 노드 1개와 워커 노드 2개가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kg 노드\n이름                    상태     역할           생성 시간    버전\nambient-control-plane   준비     제어 플레인    117분     v1.30.0\nambient-worker          준비     \u003c없음\u003e         116분     v1.30.0\nambient-worker2         준비     \u003c없음\u003e         116분     v1.30.0\n```\n\n또한 Calico CNI 데몬세트가 실행 중인지 확인합니다. 클러스터 CoreDNS도 준비되어 있는지 확인합니다.\n\n```js\n(⎈|kind-ambient:kube-system)➜  ~ kgpo\n이름                                            준비     상태      재시작      생성 시간\ncalico-kube-controllers-564985c589-xmsrp        1/1     실행 중  1 (96분 전)  117분\ncalico-node-796kq                               1/1     실행 중  0             116분\ncalico-node-l6fsg                               1/1     실행 중  0             116분\ncalico-node-zkckp                               1/1     실행 중  0             116분\ncoredns-7db6d8ff4d-h88q6                        1/1     실행 중  0             118분\ncoredns-7db6d8ff4d-rtncd                        1/1     실행 중  0             118분\n```\n\n## Istio Ambient 프로필 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n설치는 간단하게 진행됩니다. 여기에서 찾을 수 있어요: [https://istio.io/v1.20/docs/ops/ambient/getting-started/](https://istio.io/v1.20/docs/ops/ambient/getting-started/)\n\n```js\nsabuj $ istioctl install --set profile=ambient --set \"components.ingressGateways[0].enabled=true\" --set \"components.ingressGateways[0].name=istio-ingressgateway\" --skip-confirmation\n✔ Istio core가 설치되었습니다\n✔ Ztunnel이 설치되었습니다\n✔ Istiod가 설치되었습니다\n✔ CNI가 설치되었습니다\n✔ 인그레스 게이트웨이가 설치되었습니다\n✔ 설치가 완료되었습니다\n이 설치를 주입과 유효성 검사를 위한 기본 설정으로 지정합니다.\n```\n\n- 내가 사용 중인 Istio 버전은 다음과 같아요.\n\n```js\n(⎈|kind-ambient:kube-system)➜  ~ istioctl version\nclient version: 1.15.0\ncontrol plane version: 1.22.1\ndata plane version: 1.22.1 (4 프록시)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Ztunnel은 각 노드에서 실행되는 데몬세트입니다 — 이 경우 3개의 노드가 있습니다. istio-system 네임스페이스에서 ztunnel이 제대로 실행 중인지 확인해 봅시다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kgpo -owide\nNAME                                    READY   STATUS    RESTARTS   AGE    IP               NODE                    NOMINATED NODE   READINESS GATES\nistio-cni-node-7q6z7                    1/1     Running   0          117m   172.18.0.2       ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nistio-cni-node-fg6n4                    1/1     Running   0          117m   172.18.0.4       ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nistio-cni-node-gwvl8                    1/1     Running   0          117m   172.18.0.3       ambient-control-plane   \u003cnone\u003e           \u003cnone\u003e\nistio-ingressgateway-6f48dfb7db-862sm   1/1     Running   0          117m   192.168.184.70   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nistiod-6875bc5c58-n4j7d                 1/1     Running   0          118m   192.168.246.2    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nztunnel-62hp8                           1/1     Running   0          117m   192.168.246.3    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nztunnel-fv5f8                           1/1     Running   0          117m   192.168.184.71   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nztunnel-gs52c                           1/1     Running   0          117m   192.168.208.1    ambient-control-plane   \u003cnone\u003e           \u003cnone\u003e\n\n(⎈|kind-ambient:istio-system)➜  ~ kg ds\nNAME             DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE\nistio-cni-node   3         3         3       3            3           kubernetes.io/os=linux   119m\nztunnel          3         3         3       3            3           kubernetes.io/os=linux   118m\n```\n\n정말로 3개의 파드가 있네요 !\n\n- 비슷하게 Istio-cni는 또 다른 설치된 데몬세트입니다.\n- Istio 제어 평면인 istiod도 실행 중입니다.\n- 우리는 공개 트래픽을 위해 기본 istio ingressgateway도 설치했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 작업량 설정\n\n이 프로젝트의 모든 매니페스트 파일은 여기에서 찾을 수 있습니다: https://github.com/JanaSabuj/istio-ambient-mesh-exploration\n\n## 안건\n\n- 우리는 앰비언트 프로필 없이 앱을 설정하고, 일반 Istio crds를 사용할 것입니다. 그 후에 앱을 호출할 예정입니다. i) 인그레스 ii) 디버그 클라이언트 pod\n- 그 후에, Istio 데이터 평면 모드를 앰비언트로 전환하고, ztunnel pod를 통해 흐르는 트래픽 경로의 변화를 관찰할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 네임스페이스\n\nambient-demo라는 네임스페이스를 만들어 보겠습니다. 이 네임스페이스에서 앱을 호스팅할 예정입니다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ k create ns ambient-demo\n\n(⎈|kind-ambient:istio-system)➜  ~ kg ns\nNAME                 STATUS   AGE\ndefault              Active   132m\nistio-system         Active   125m\nkube-node-lease      Active   132m\nkube-public          Active   132m\nkube-system          Active   132m\nlocal-path-storage   Active   132m\n```\n\n## 애플리케이션\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그럼 배포, 서비스 및 서비스 어카운트 yaml을 사용하여 애플리케이션을 배포합니다.\n\n클러스터에서는 다음과 같이 보입니다.\n\n```bash\n(⎈|kind-ambient:ambient-demo)➜  ~ kg all\nNAME                          READY   STATUS    RESTARTS   AGE\npod/httpbin-6f4dc97cb-5dpz9   1/1     Running   0          3m21s\npod/httpbin-6f4dc97cb-swdlb   1/1     Running   0          3m31s\n\nNAME              TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE\nservice/httpbin   ClusterIP   10.96.157.221   \u003cnone\u003e        80/TCP    143m\n\nNAME                      READY   UP-TO-DATE   AVAILABLE   AGE\ndeployment.apps/httpbin   2/2     2            2           143m\n\nNAME                                 DESIRED   CURRENT   READY   AGE\nreplicaset.apps/httpbin-6f4dc97cb    2         2         2       3m31s\n```\n\n## Istio 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n외부 세계에 노출하기 위해 Istio Gateway 및 Istio VirtualService를 생성하여 Istio Ingress를 통해 액세스할 수 있게 만듭니다.\n\n- 우리는 Istio Ingress 파드에 8081 포트를 통해 게이트웨이를 추가하고 있습니다.\n- 그 다음으로, VirtualService를 통해 ambient-demo 네임스페이스에서 실행되는 httpbin 서비스로 라우팅합니다.\n\n## Istio Ingress를 통한 확인\n\n이제 우리의 응용 프로그램에 액세스할 수 있는지 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kgs\nNAME                   TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)                                      AGE\nistio-ingressgateway   LoadBalancer   10.96.77.172   \u003cpending\u003e     15021:30807/TCP,80:30587/TCP,443:31004/TCP   147m\n```\n\nKind가 인그레스 서비스를 위한 외부 IP를 제공하지 않았기 때문에, 원하는 리스너 8081에서 인그레스 파드를 포트포워딩하여 외부 액세스를 시뮬레이션할 것입니다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kpf istio-ingressgateway-6f48dfb7db-862sm 8081\nForwarding from 127.0.0.1:8081 -\u003e 8081\nForwarding from [::1]:8081 -\u003e 8081\n```\n\n브라우저에서 127.0.0.1:8081을 입력하여 애플리케이션을 확인할 수 있습니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhttp://127.0.0.1:8081/\n\nhttpbin.org\n 0.9.2\n[ Base URL: 127.0.0.1:8081/ ]\n간단한 HTTP 요청 및 응답 서비스입니다.\n\n로컬에서 실행: $ docker run -p 80:80 kennethreitz/httpbin\n\n개발자 - 웹사이트\n개발자에게 이메일 보내기\n```\n\n- 또 다른 확인 방법은 로컬에서 curl을 통해 하는 것입니다. 우리는 요청이 istio-envoy 파드에 의해 처리된 것을 확인합니다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ curl 127.0.0.1:8081 -v\n*   Trying 127.0.0.1:8081...\n* Connected to 127.0.0.1 (127.0.0.1) port 8081\n\u003e GET / HTTP/1.1\n\u003e Host: 127.0.0.1:8081\n\u003e User-Agent: curl/8.6.0\n\u003e Accept: */*\n\u003e\n\u003c HTTP/1.1 200 OK\n\u003c server: istio-envoy\n\u003c date: Sun, 16 Jun 2024 11:52:13 GMT\n\u003c content-type: text/html; charset=utf-8\n\u003c content-length: 9593\n\u003c access-control-allow-origin: *\n\u003c access-control-allow-credentials: true\n\u003c x-envoy-upstream-service-time: 271\n\u003c\n\u003c!DOCTYPE html\u003e\n\u003chtml lang=\"en\"\u003e\n...\n```\n\n## 디버그 클라이언트 파드를 통한 확인\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 메쉬 내부 호출을 테스트해보려고 합니다. 따라서 각 노드마다 클라이언트 팟이 하나씩 있는 것이 좋습니다. 이를 위해 디버거 데몬세트 클라이언트 워크로드를 설정할 수 있습니다 — https://github.com/digitalocean/doks-debug\n\n사용한 수정된 Manifest: https://gist.github.com/JanaSabuj/a4dd2504752b8c2b30d2d2d05320f7ef\n\n저는 이 데몬세트를 우리 ambient-demo 네임스페이스에 배포했습니다.\n\n```js\n(⎈|kind-ambient:ambient-demo)➜  ~ kg ds\nNAME         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE\ndoks-debug   3         3         3       3            3           \u003cnone\u003e          89m\n\n(⎈|kind-ambient:ambient-demo)➜  ~ kgpo -owide\nNAME                      READY   STATUS    RESTARTS   AGE   IP               NODE                    NOMINATED NODE   READINESS GATES\ndoks-debug-j9mm5          1/1     Running   0          90m   192.168.246.5    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\ndoks-debug-rdhgq          1/1     Running   0          90m   192.168.184.73   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\ndoks-debug-v7cld          1/1     Running   0          90m   192.168.208.3    ambient-control-plane   \u003cnone\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테스트해 보기 위해 디버그 팟으로 진입하여 k8s fqdn httpbin.ambient-demo.svc.cluster.local을 curl을 시도해 보았습니다.\n\n200 OK를 반환하고 있습니다.\n\n```js\n(⎈|kind-ambient:ambient-demo)➜  ~ k exec -it doks-debug-j9mm5 -- /bin/bash\n\nroot@doks-debug-j9mm5:~# curl httpbin.ambient-demo.svc.cluster.local -v\n*   Trying 10.96.157.221:80...\n* Connected to httpbin.ambient-demo.svc.cluster.local (10.96.157.221) port 80 (#0)\n\u003e GET / HTTP/1.1\n\u003e Host: httpbin.ambient-demo.svc.cluster.local\n\u003e User-Agent: curl/7.88.1\n\u003e Accept: */*\n\u003e\n\u003c HTTP/1.1 200 OK\n\u003c Server: gunicorn/19.9.0\n\u003c Date: Sun, 16 Jun 2024 12:06:11 GMT\n\u003c Connection: keep-alive\n\u003c Content-Type: text/html; charset=utf-8\n\u003c Content-Length: 9593\n\u003c Access-Control-Allow-Origin: *\n\u003c Access-Control-Allow-Credentials: true\n\u003c\n```\n\n# Ambient Injection\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금까지 앰비언트 모드가 활성화되지 않았습니다. Istio 게이트웨이에서 추가 된 리스너로 인해 요청은 Istio 인그레스 파드에 도착한 다음 VirtualService를 통해 앱 파드로 라우팅됩니다.\n\n매쉬 내부 호출의 경우, 클라이언트와 서버 파드 사이에 직접적인 포드 간 통신이 이루어집니다.\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_8.png)\n\n앰비언트를 주입하는 동안 우리는 또한 다음 로그를 계속 추적할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- istio-cni\n- ztunnel\n\nIstio가 네임스페이스 ambient-demo에 대한 Ambient Dataplane 모드를 활성화하도록 내부적으로 라우트, iptables 등을 설정했는지 확인하려면 아래 명령어를 사용해보세요.\n\n```js\n(⎈|kind-ambient:ambient-demo)➜\n~ kubectl label namespace ambient-demo istio.io/dataplane-mode=ambient\n```\n\n## 관찰된 로그\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- istio-cni\n\n```js\n(⎈|kind-ambient:ambient-demo)➜ ~ stern istio-cni -n istio-system\n\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.243451Z info ambient Namespace ambient-demo is enabled in ambient mesh\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.264500Z info ambient in pod mode - adding pod ambient-demo/httpbin-5bd875fbdd-84vs8 to ztunnel\nistio-cni-node-gwvl8 install-cni 2024-06-16T10:13:59.291505Z info ambient Namespace ambient-demo is enabled in ambient mesh\nistio-cni-node-fg6n4 install-cni 2024-06-16T10:13:59.281587Z info ambient Namespace ambient-demo is enabled in ambient mesh\nistio-cni-node-fg6n4 install-cni 2024-06-16T10:13:59.313668Z info ambient in pod mode - adding pod ambient-demo/httpbin-5bd875fbdd-dp4ct to ztunnel\n\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.264500Z info ambient in pod mode - adding pod ambient-demo/httpbin-5bd875fbdd-84vs8 to ztunnel\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.325907Z info iptables Running iptables-restore with the following input:\nistio-cni-node-7q6z7 install-cni * nat\nistio-cni-node-7q6z7 install-cni -N ISTIO_OUTPUT\nistio-cni-node-7q6z7 install-cni -A OUTPUT -j ISTIO_OUTPUT\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT -d 169.254.7.127 -p tcp -m tcp -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT -p tcp -m mark --mark 0x111/0xfff -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT ! -d 127.0.0.1/32 -o lo -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT ! -d 127.0.0.1/32 -p tcp -m mark ! --mark 0x539/0xfff -j REDIRECT --to-ports 15001\nistio-cni-node-7q6z7 install-cni COMMIT\nistio-cni-node-7q6z7 install-cni * mangle\nistio-cni-node-7q6z7 install-cni -N ISTIO_PRERT\nistio-cni-node-7q6z7 install-cni -N ISTIO_OUTPUT\nistio-cni-node-7q6z7 install-cni -A PREROUTING -j ISTIO_PRERT\nistio-cni-node-7q6z7 install-cni -A OUTPUT -j ISTIO_OUTPUT\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT -m mark --mark 0x539/0xfff -j CONNMARK --set-xmark 0x111/0xfff\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT -s 169.254.7.127 -p tcp -m tcp -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT ! -d 127.0.0.1/32 -p tcp -i lo -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT -p tcp -m tcp --dport 15008 -m mark ! --mark 0x539/0xfff -j TPROXY --on-port 15008 --tproxy-mark 0x111/0xfff\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT -p tcp -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\nistio-cni-node-7q6z7 install-cni -A ISTIO_PRERT ! -d 127.0.0.1/32 -p tcp -m mark ! --mark 0x539/0xfff -j TPROXY --on-port 15006 --tproxy-mark 0x111/0xfff\nistio-cni-node-7q6z7 install-cni -A ISTIO_OUTPUT -m connmark --mark 0x111/0xfff -j CONNMARK --restore-mark --nfmask 0xffffffff --ctmask 0xffffffff\nistio-cni-node-7q6z7 install-cni COMMIT\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.335115Z info Running command (with wait lock): iptables-restore --noflush -v --wait=30\nistio-cni-node-7q6z7 install-cni 2024-06-16T10:13:59.550687Z info ambient About to send added pod: 3ab72f78-8e2b-4e49-bc47-45fa4f90dbf7 to ztunnel: add:{uid:\"3ab72f78-8e2b-4e49-bc47-45fa4f90dbf7\" workload_info:{name:\"httpbin-5bd875fbdd-84vs8\" namespace:\"ambient-demo\" service_account:\"default\" trust_domain:\"cluster.local\"}\n```\n\n많은 로그가 생성되었습니다. 우리는 각 httpbin pod를 ambient-demo 네임스페이스에 추가하여 ztunnel을 통해 ambient 경로에 추가하고 있음을 확인할 수 있습니다.\n\n- ztunnel\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```plaintext\n(⎈|kind-ambient:ambient-demo)➜ ~ stern ztunnel -n istio-system\n\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.559505Z 정보 inpod::statemanager pod WorkloadUid(\"3ab72f78-8e2b-4e49-bc47-45fa4f90dbf7\")가 netns를 수신하고 프록시를 시작합니다.\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.557545Z 정보 inpod::statemanager pod WorkloadUid(\"7f8be6a6-64f2-40e9-8926-6c3a618eb7d9\")가 netns를 수신하고 프록시를 시작합니다.\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.560458Z 정보 proxy::inbound 리스너가 구성되었으며 주소=[::]:15008 구성요소=\"inbound\" 투명=true\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.561604Z 정보 proxy::inbound_passthrough 리스너가 구성되었으며 주소=[::]:15006 구성요소=\"inbound plaintext\" 투명=true\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.561647Z 정보 proxy::outbound 리스너가 구성되었으며 주소=[::]:15001 구성요소=\"outbound\" 투명=true\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.573883Z 정보 proxy::inbound 리스너가 구성되었으며 주소=[::]:15008 구성요소=\"inbound\" 투명=true\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.586596Z 정보 proxy::inbound_passthrough 리스너가 구성되었으며 주소=[::]:15006 구성요소=\"inbound plaintext\" 투명=true\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.586819Z 정보 proxy::outbound 리스너가 구성되었으며 주소=[::]:15001 구성요소=\"outbound\" 투명=true\nztunnel-fv5f8 istio-proxy 2024-06-16T10:13:59.811460Z 정보 xds::client:xds{id=14}가 응답을 수신했습니다. type_url=\"type.googleapis.com/istio.workload.Address\" 크기=2  삭제=0\nztunnel-62hp8 istio-proxy 2024-06-16T10:13:59.816352Z 정보 xds::client:xds{id=14}가 응답을 수신했습니다. type_url=\"type.googleapis.com/istio.workload.Address\" 크기=2  삭제=0\nztunnel-gs52c istio-proxy 2024-06-16T10:13:59.821310Z 정보 xds::client:xds{id=14}가 응답을 수신했습니다. type_url=\"type.googleapis.com/istio.workload.Address\" 크기=2  삭제=0\n```\n\nztunnel이 자체 내부 및 외부 리스너를 설정 중인 것으로 보입니다.\n\n## 트래픽 흐름 - Istio Ingress를 통해\n\n이전과 마찬가지로, istio-ingress pod로 포트 포워딩을 설정하고 localhost를 통해 액세스합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n두 개의 호출을 각각 2개의 httpbin 팟에 대응하도록 인그레스에서 호출을 추출하려고 합니다. 그리고 동시에 동일한 ztunnel 로그를 캡처하려고 합니다.\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ kpf istio-ingressgateway-6f48dfb7db-862sm 8081\nForwarding from 127.0.0.1:8081 -\u003e 8081\n\n$ curl localhost:8081/\n$ curl localhost:8081/\n```\n\n```js\n(⎈|kind-ambient:istio-system)➜  ~ stern ztunnel -n istio-system\n\nztunnel-fv5f8 istio-proxy 2024-06-16T12:26:24.154500Z\ninfo access connection complete src.addr=192.168.184.70:52792\nsrc.workload=istio-ingressgateway-6f48dfb7db-862sm src.namespace=istio-system\nsrc.identity=\"spiffe://cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account\"\ndst.addr=192.168.184.74:80 dst.hbone_addr=192.168.184.74:80\ndst.service=httpbin.ambient-demo.svc.cluster.local\ndst.workload=httpbin-6f4dc97cb-swdlb dst.namespace=ambient-demo\ndst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\"\ndirection=\"inbound\" bytes_sent=51083 bytes_recv=4180 duration=\"2166ms\"\n\nztunnel-62hp8 istio-proxy 2024-06-16T12:28:40.267690Z\ninfo access connection complete src.addr=192.168.184.70:55036\nsrc.workload=istio-ingressgateway-6f48dfb7db-862sm src.namespace=istio-system\nsrc.identity=\"spiffe://cluster.local/ns/istio-system/sa/istio-ingressgateway-service-account\"\ndst.addr=192.168.246.6:80 dst.hbone_addr=192.168.246.6:80\ndst.service=httpbin.ambient-demo.svc.cluster.local\ndst.workload=httpbin-6f4dc97cb-5dpz9 dst.namespace=ambient-demo\ndst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\"\ndirection=\"inbound\" bytes_sent=41251 bytes_recv=2007 duration=\"2331ms\"\n```\n\n인그레스가 주변 데이터 플레인 경로에 떨어지지 않기 때문에 인그레스 팟에서의 호출은 주변 데이터 플레인 경로로 직접 ztunnel 팟으로 이어집니다. 한 번에 하나의 노드로 이동한 후 해당 내부 노드 팟으로 inbound됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 로그 캡처에서 확인한 내용입니다\n\n```js\ndirection = \"inbound\";\n```\n\n- 이는 주변 레이블이 붙은 네임스페이스 파드로의 트래픽이 항상 ztunnel을 통해 이동함을 확인합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\ndst.hbone_addr=192.168.184.74:80\ndst.hbone_addr=192.168.246.6:80\n\nhttpbin-6f4dc97cb-5dpz9 1/1 Running 0 56m 192.168.246.6 ambient-worker2 \u003cnone\u003e \u003cnone\u003e\nhttpbin-6f4dc97cb-swdlb 1/1 Running 0 56m 192.168.184.74 ambient-worker \u003cnone\u003e \u003cnone\u003e\n\n- 이것은 실제 httpbin pod ip에 해당하는 dest pod ip를 캡처합니다.\n\n## 트래픽 흐름 — Mesh 내부를 통해\n\n클라이언트 디버그 pod에 exec하여 httpbin 서비스로의 Mesh 내부 호출을 시도하고 동시에 ztunnel 로그를 캡쳐하여 동일한 동작을 확인해보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n(⎈|kind-ambient:ambient-demo)➜  ~ kgpo -owide\nNAME                      READY   STATUS    RESTARTS   AGE    IP               NODE                    NOMINATED NODE   READINESS GATES\ndoks-debug-j9mm5          1/1     Running   0          122m   192.168.246.5    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\ndoks-debug-rdhgq          1/1     Running   0          122m   192.168.184.73   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\ndoks-debug-v7cld          1/1     Running   0          122m   192.168.208.3    ambient-control-plane   \u003cnone\u003e           \u003cnone\u003e\nhttpbin-6f4dc97cb-5dpz9   1/1     Running   0          56m    192.168.246.6    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nhttpbin-6f4dc97cb-swdlb   1/1     Running   0          56m    192.168.184.74   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\n```\n\n그냥 같은 노드에 있는 클라이언트와 앱 팟들을 연결하기 위해 —\n\n```js\n(⎈|kind-ambient:ambient-demo)➜  ~ kgpo -A -owide | grep \"ambient-worker \"\nambient-demo         doks-debug-rdhgq                                1/1     Running   0               133m    192.168.184.73   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nistio-system         ztunnel-fv5f8                                   1/1     Running   0               3h24m   192.168.184.71   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\nambient-demo         httpbin-6f4dc97cb-swdlb                         1/1     Running   0               68m     192.168.184.74   ambient-worker          \u003cnone\u003e           \u003cnone\u003e\n\n\n(⎈|kind-ambient:ambient-demo)➜  ~ kgpo -A -owide | grep \"ambient-worker2\"\nkube-system          doks-debug-9nlh7                                1/1     Running   0               3h6m    192.168.246.4    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nistio-system         ztunnel-62hp8                                   1/1     Running   0               3h23m   192.168.246.3    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\nambient-demo         httpbin-6f4dc97cb-5dpz9                         1/1     Running   0               67m     192.168.246.6    ambient-worker2         \u003cnone\u003e           \u003cnone\u003e\n```\n\ndebug pod인 doks-debug-rdhgq를 실행하기 위해 ambient-worker 노드에 스케줄된 상태로 들어가보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_10.png\" /\u003e\n\n```js\n테이블 1: 동일 노드 내의 클라이언트 및 서버\n---------\nztunnel-fv5f8 istio-proxy 2024-06-16T12:40:48.707707Z info access connection complete src.addr=192.168.184.73:56463 src.workload=doks-debug-rdhgq src.namespace=ambient-demo src.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/default\" dst.addr=192.168.184.74:80 dst.hbone_addr=192.168.184.74:80 dst.service=httpbin.ambient-demo.svc.cluster.local dst.workload=httpbin-6f4dc97cb-swdlb dst.namespace=ambient-demo dst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\" direction  =\"inbound\" bytes_sent=9832 bytes_recv=84 duration=\"178ms\"\nztunnel-fv5f8 istio-proxy 2024-06-16T12:40:48.708070Z info access connection complete src.addr=192.168.184.73:34190 src.workload=doks-debug-rdhgq src.namespace=ambient-demo src.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/default\" dst.addr=192.168.184.74:15008 dst.hbone_addr=192.168.184.74:80 dst.service=httpbin.ambient-demo.svc.cluster.local dst.workload=httpbin-6f4dc97cb-swdlb dst.namespace=ambient-demo dst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\" direction=\"outbound\" bytes_sent=84 bytes_recv=9832 duration=\"203ms\"\n```\n\n동일 노드 내의 클라이언트와 서버의 경우, 파드에서 ztunnel로 외부 패킷이 들어오면 동일한 ztunnel을 통해 대상 파드로 들어오는 내부 패킷으로 리디렉션됩니다.\n\n따라서, 동일 노드 내의 클라이언트 및 서버에서는 한 ztunnel이 외부 패킷과 내부 패킷을 받습니다. \"bound\"는 동일 노드 내의 응용 프로그램 파드로부터/받는 방향을 지정합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n캡처 2: 클라이언트 및 서버가 다른 노드에 있는 경우\n---------\nztunnel-62hp8 istio-proxy 2024-06-16T12:48:51.792527Z info access connection complete src.addr=192.168.184.73:53265 src.workload=doks-debug-rdhgq src.namespace=ambient-demo src.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/default\" dst.addr=192.168.246.6:80 dst.hbone_addr=192.168.246.6:80 dst.service=httpbin.ambient-demo.svc.cluster.local dst.workload=httpbin-6f4dc97cb-5dpz9 dst.namespace=ambient-demo dst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\" direction=\"inbound\" bytes_sent=9832 bytes_recv=84 duration=\"60ms\"\nztunnel-fv5f8 istio-proxy 2024-06-16T12:48:51.793112Z info access connection complete src.addr=192.168.184.73:60162 src.workload=doks-debug-rdhgq src.namespace=ambient-demo src.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/default\" dst.addr=192.168.246.6:15008 dst.hbone_addr=192.168.246.6:80 dst.service=httpbin.ambient-demo.svc.cluster.local dst.workload=httpbin-6f4dc97cb-5dpz9 dst.namespace=ambient-demo dst.identity=\"spiffe://cluster.local/ns/ambient-demo/sa/httpbin-sa\" direction=\"outbound\" bytes_sent=84 bytes_recv=9832 duration=\"61ms\"\n```\n\n만약 클라이언트와 서버가 다른 노드에 있는 경우, 출발 트래픽은 동일한 노드인 ztunnel에서 외부 트래픽 패킷을 만나고, 그런 다음 목적지 파드의 노드의 ztunnel로 전송되어 들어오는 패킷으로 처리됩니다.\n\n# 결론\n\n이 실험을 통해 Istio Ambient Mesh에서 ztunnel을 통한 패킷 흐름을 시각화할 수 있었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_11.png)\n\n다음 파트에서는 ztunnel을 통해 적용할 수 있는 L4 인증 정책을 탐색할 것입니다.\n\n또한 Ambient에 있는 L7 프록시인 Waypoint Proxy에 대해 탐구할 것입니다.\n\n다른 기술 블로그는 여기에서 확인할 수 있습니다: [링크](https://janasabuj.github.io/posts/)\n","ogImage":{"url":"/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_0.png"},"coverImage":"/assets/img/2024-06-23-TouringtheKubernetesIstioAmbientMeshPart1SetupZTunnel_0.png","tag":["Tech"],"readingTime":35},{"title":"클라우드 제공 로드밸런서 없이 Kong과 Gateway를 사용하여 Kubernetes 서비스에 접근하는 방법","description":"","date":"2024-06-23 23:10","slug":"2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer","content":"\n## 이 기사에서는 쿠버네티스 클러스터 내에서 Kong을 API 게이트웨이로 배포하여 서비스에 관리된 액세스를 제공하는 방법을 살펴봅니다. 이를 클라우드 서비스에서 수행합니다. 이 클라우드 서비스는 쿠버네티스 호환 외부 로드 밸런서 서비스를 제공하지 않습니다. 또한 Ingress 리소스 대신 최신 Kubernetes Gateway를 사용합니다.\n\n저와 이전 기사 중 한 가지 이상을 따르신 분들은 저의 이전 기사들 중 하나를 따라오셨을 것입니다. 저는 신뢰할 수 있고 비용 효율적이지만 제한된 범위의 서비스를 제공하는 호주 클라우드 제공자인 Binary Lane을 사용합니다.\n\n제한된 범위의 서비스만 제공하는 것은 모든 쿠버네티스 작업을 직접해야 하므로, 배우고 솔루션의 작동 방식을 제어할 수 있는 기회를 제공합니다. 또한 어떤 클라우드 공급 업체에도 얽매이지 않을 수 있습니다. 또한 비용 효율적입니다.\n\n이 기사에서는 Kubernetes 클러스터에 Kong API 게이트웨이를 추가하여 서비스에 액세스하는 방법을 살펴봅니다. 할 일이 꽤 많기 때문에 이 기사는 좀 길지만, API 게이트웨이의 역할에 대한 이론 부분을 별도의 기사로 분리했습니다. API 게이트웨이의 역할을 이해하지 못하신다면 먼저 해당 기사를 읽는 것을 권장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKong은 신뢰할 만한 엔터프라이즈급 API 게이트웨이이지만 설정하기가 매우 까다로울 수 있습니다. 이 기사의 끝에서 문제를 디버그하는 방법에 대한 일부 힌트를 제공하겠습니다. 이 기사에서 설계를 조정하는 경우, 이름과 포트를 올바르게 구성했는지 확인하세요.\n\n# 네트워크 디자인\n\nKubernetes 네트워킹은 복잡한 주제이며 여기서 다루기 어렵지만, 고수준에서 네트워크 디자인에 대해 생각해야 합니다.\n\n![네트워크 디자인](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이전 기사를 따라오셨다면, 이제 이진 레인(또는 다른 클라우드 제공업체) 서버에 Kubernetes 클러스터가 설치되어 있어야 합니다. 인터넷에서 접근이 불가능한 가상 사설 클라우드 (VPC) 개인 서브넷에 세 개의 노드가 설치되어 있을 것입니다. 이러한 노드들은 인터넷을 통해 접속이 가능한 전용 VPN을 통해서만 연결됩니다(위에는 표시되지 않음). 인터넷 및 VPC 인터페이스를 모두 가지고 있는 게이트웨이 서버가 있어서, 인터넷에서 클러스터로 들어오는 접속(inress)과 클러스터에서 인터넷으로 나가는 접속(egress)을 제공합니다.\n\n기본 네트워크 토폴로지가 이제 갖추어 졌습니다. 이제 우리는 서비스가 외부 세계에 제공하는 API를 관리할 수 있기를 원합니다. 이 작업은 Kong Gateway API를 통해 수행됩니다.\n\n# 인터넷에서 연결 설정하기 (인그레스)\n\nAWS, 구글 클라우드 또는 Azure와 같은 풀 서비스 제공업체를 사용하면, LoadBalancer 유형의 Kubernetes 서비스를 사용하여 인터넷 연결이 자동으로 생성되는 방식으로 Kubernetes를 설정할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n바이너리 레인에는 로드 밸런서 서비스가 있지만 쿠버네티스를 통해 관리할 수는 없으므로 로드 밸런서를 직접 생성하고 구성하거나 고유한 인그레스 포인트를 만들어야 합니다. 특정 클라우드 제공 업체의 기능에 구속되지 않기 위해, 저는 개인적으로 내 gw 서버에서 NGINX 역방향 프록시를 실행하여 고유한 인그레스 포인트를 만드는 것을 선호합니다.\n\n이 아키텍처에서 gw 서버에서 실행되는 NGINX는 두 가지 기능을 수행합니다:\n\n- 유효한 요청을 모두 쿠버네티스 클러스터로 라우팅하여 Kong이 처리\n- 쿠버네티스 노드 간 요청을 로드 밸런싱\n\nKong이 NodePort 서비스로 노출될 것이므로 클러스터의 모든 노드에서 액세스할 수 있습니다. 이를 통해 NGINX가 노드 간 요청을 로드 밸런싱할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스 자체가 사용 가능한 파드 전체에 무작위로 로드 밸런싱을 수행하므로 NGINX에 의한 로드 밸런싱이 노드 장애나 과부하 상황을 견딜 목적으로만 사용된다는 것을 유의한 점입니다. 서비스 로드 밸런싱에 대해 더 읽어보실 수 있습니다.\n\n본 솔루션에서 NGINX를 수동으로 구성된, 대체될 수 있는 외부 로드 밸런서로 간주하실 수 있습니다.\n\n# 쿠버네티스 서비스\n\n쿠버네티스 서비스는 하나 이상의 파드가 제공하는 서비스에 대한 액세스를 허용합니다. 이를 통해 파드가 종료되고 재예약되더라도 특정 노드에서 요청이 발생하더라도 서비스가 계속하여 요구에 따른 대로 요청을 라우팅하는 단일 접점으로 유지됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_1.png)\n\n서비스를 사용함으로써 요청을 보낼 수 있는 단일하고 안정적인 IP 주소가 제공됩니다. 서비스는 사용 가능한 Pod들 사이에서 부하 분산 기능을 제공합니다. Kubernetes는 또한 클러스터의 DNS에 서비스에 대한 참조를 추가함으로써 서비스가 이름으로 액세스될 수 있게 합니다. 여러 가지 다른 변형이 등록됩니다:\n\n```js\n\u003c서비스 이름\u003e.\u003c네임스페이스\u003e.svc.local\n\u003c서비스 이름\u003e.\u003c네임스페이스\u003e.svc\n\u003c서비스 이름\u003e.\u003c네임스페이스\u003e\n\u003c서비스 이름\u003e\n```\n\n# API 게이트웨이\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNGINX 게이트웨이와 쿠버네티스 서비스는 서비스에 대한 외부 인터페이스를 제공하는 데 도움이 되지만 기능이 제한적이며 수동으로 설정해야 합니다.\n\nAPI 게이트웨이는 이 문제를 해결하는 클러스터 구성 요소입니다. 이 게이트웨이는 솔루션의 일부로 구성되며 서비스 앞에 위치하여 여기서 설명하는 추가 기능을 제공합니다.\n\n![image](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_2.png)\n\nAPI 게이트웨이는 클러스터의 일부로 있기 때문에 클러스터 내 리소스의 변경에 따라 자동으로 구성될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Kong API Gateway\n\n다양한 API 게이트웨이 기술이 있지만, 이 글에서는 무료 오픈 소스 솔루션인 Kong을 선택했습니다. 유료 엔터프라이즈 설치도 가능합니다. 여기에서 Kong에 대한 포괄적인 공식 문서를 찾을 수 있습니다.\n\nKong은 쿠버네티스 커뮤니티와 적극적으로 협력하여 클러스터 내에서 게이트웨이에 대한 새로운 표준을 정의하고 있습니다. 이로 인해 게이트웨이 자체와 혼동되어서는 안 되는 새로운 쿠버네티스 리소스 유형인 게이트웨이 API가 만들어졌습니다.\n\n이것이 Kong이 어떻게 작동하는지 대략적으로 설명했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_3.png)\n\n클러스터 외부의 모든 클라이언트로부터 들어오는 트래픽이 Kong에 도달합니다. Kong은 구성 내의 규칙에 따라 요청을 처리하고 클러스터 내외의 적절한 서비스로 요청을 전달합니다.\n\nKong은 Kubernetes 리소스 매니페스트에서 정적으로 또는 데이터베이스에서 구성을 가져올 수 있습니다 (DB-less 설치). Kong은 이제 DB-less 설치를 새로운 설치에 사용할 것을 권장하며, 이를 따를 것입니다.\n\nKong은 성숙한 플러그인 기능을 갖추고 있습니다. 이를 통해 제3자가 Kong의 플러그인으로 기능 확장을 개발할 수 있습니다. 플러그인은 트래픽 흐름에 위치하여 속도 제한 및 인증과 같은 작업에 도움을 줄 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마지막으로 Kong을 관리하기 위해 플러그인, 구성 등을 관리할 수 있도록 Management UI를 제공합니다. Management UI는 Admin API를 통해 Kong과 상호 작용합니다.\n\nKong에 대해 상세한 문서를 살펴보면 여기서 다룰 수 있는 내용보다 더 많음을 알 수 있습니다. 그래서 제가 다루는 내용은 기본 사항에만 초점을 맞추겠습니다.\n\n## DB-less 설치\n\nDB-less 설치가 어떻게 작동하는지 이해하는 것이 중요하다고 생 생각합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 구성에서 Kong은 두 가지 구성요소를 설치합니다:\n\n- Kong Ingress Controller (KIC)\n- Kong Gateway\n\n게이트웨이는 프록시를 통해 모든 사용자 트래픽의 경로 지정을 처리합니다. Kong Ingress Controller (KIC)는 Kubernetes 리소스 정의 (예: HTTPRoute)에서 구성을 가져와서 프록시가 이해하는 규칙으로 변환하고 실시간으로 프록시에 규칙을 업로드합니다. 이러한 방식으로 Kubernetes 구성의 변경 사항이 자동으로 프록시에 적용됩니다.\n\nKIC는 내부 Kubernetes API를 사용하여 Kubernetes 클러스터에 대한 정보를 얻습니다. 이 API는 클러스터를 관리하는 데 사용되는 것으로, kubectl을 사용할 때 실제로는 Kubernetes API와 상호 작용합니다. 이 API를 통해 Kong 및 kubectl과 같은 애플리케이션은 클러스터에 대한 정보를 찾거나 변경할 수 있습니다. KIC는 이 API를 통해 백업 데이터베이스가 필요 없이 클러스터 리소스 파일과 Gateway를 동기화할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 테스트할 서비스\n\nKong 배포에 들어가기 전에 Kong을 통해 접근할 수 있는 서비스를 가지고 있어야 합니다. 어차피 API Gateway에 API가 없다면 그리 유용하지 않을 것이니까요!\n\n가장 간단한 방법은 NGINX를 웹 서버로 배포하고 정적 콘텐츠로 구성하는 것입니다. Kubernetes에서 이 작업을 한 적이 없다면 다른 기사 하나에서 그 방법을 읽어볼 수 있습니다.\n\n2개의 서비스를 생성하는 것을 제안합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 안녕하세요 world 1: 2개의 레플리카\n- 안녕하세요 world 2: 1개의 레플리카\n\n이들은 클러스터 내 파드에서 ClusterIP 서비스를 통해 접근할 수 있어야 합니다. 이러한 서비스를 설정하는 내 기사에서는 브라우저에서 서비스를 확인할 수 있도록 NodePort 서비스를 생성합니다. 이를 수행할 경우 내부 클러스터 IP 및 포트를 사용해야 합니다. 서비스 유형에 대한 자세한 내용은 다른 기사에서 확인할 수 있습니다.\n\n두 서비스가 올바르게 실행되고 Hello World HTML을 제공할 수 있는지 확인하세요.\n\n내가 여기서 설명하는 예제에서, 내 두 서비스는 다음과 같이 위치해 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- http://`node IP 주소`:30082 — 'Hello World 1 !!'라고 응답합니다.\n- http://`node IP 주소`:30082 — 'Hello World 2 !!'라고 응답합니다.\n\n어느 경로도 필요하지 않으며 경로를 추가하면 (예: http://`node IP 주소`:30082/world1) 404 오류가 발생합니다. 이 사실을 인식하지 못하면 나중에 문제가 될 수 있으므로 주의해야 합니다.\n\n이제 서비스가 실행 중이므로 Kong을 통해 액세스해 보겠습니다.\n\n# 쿠버네티스 게이트웨이 자원 생성하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nDB 미사용 모드에서는 Kong API 게이트웨이를 구성할 때 Kubernetes Ingress 또는 HTTPRoute 리소스를 생성합니다. 이러한 리소스를 클러스터에 적용하면 Kong이 프록시 구성 요소 내에서 라우팅 규칙을 정의하는 데 사용됩니다. 이를 통해 들어오는 트래픽이 서비스로 전달됩니다.\n\nIngress 리소스는 작동하지만 기능이 제한적입니다. Kubernetes 커뮤니티와 함께 Kong에서 개발한 새 Gateway 리소스를 사용하면 API를 더 정교하게 관리할 수 있습니다.\n\n우리는 Kong과 함께 Gateway 리소스를 사용할 것입니다. 이를 위해 먼저 GatewayClass 및 Gateway 리소스를 지원하는 새로운 Custom Resource Definitions (CRD)를 클러스터에 적용해야 합니다. 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 이 작업을 수행할 수 있습니다. 저의 경우에는 제 k8s-master 서버에서 이를 실행합니다.\n\n```js\nkubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n본 문서에서는 사용하지 않을 실험적 기능 몇 가지를 소개해드리겠습니다만, 참고용으로 여기에 추가해두었습니다.\n\n```js\nkubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/experimental-install.yaml\n```\n\n이제 Kubernetes를 위해 GatewayClass 및 Gateway 두 리소스를 정의할 수 있습니다. 이들이 무엇을 하는 지에 대해 설명했으니, 이를 다시 반복하지는 않겠습니다. 간결함을 위해 해당 내용은 여기서 생략합니다.\n\n## GatewayClass\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKong 기술을 클러스터에 소개하는 GatewayClass를 정의할 것입니다. 다음 파일을 생성해주세요:\n\nkong-gw-class.yml\n\n```yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: GatewayClass\nmetadata:\n  name: kong-class\n  annotations:\n    konghq.com/gatewayclass-unmanaged: \"true\"\nspec:\n  controllerName: konghq.com/kic-gateway-controller\n```\n\n이 파일에 대해 몇 가지 주의할 사항이 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이것은 클러스터 수준 리소스이기 때문에 네임스페이스가 없습니다.\n- 주석은 솔루션별 옵션을 정의하며 Kong의 경우 konghq로 시작합니다.\n- konghq.com/gatewayclass-unmanaged 주석은 'true'(문자열)로 설정되어 있습니다. 왜냐하면 Kong이 오퍼레이터를 통해 자동으로 설정되는 것이 아니라 수동으로 설정되고 있기 때문입니다.(다른 옵션도 있으니 여기를 참조하세요)\n- 인그레스 컨트롤러는 Kong 인그레스 컨트롤러(konghq.com/kic-gateway-controller)이며 contollerName 필드에서 구성됩니다.\n\n이제 다음과 같이 클래스를 생성하세요:\n\n```js\nkubectl apply -f kong-gw-class.yml\n```\n\n이제 이 클래스를 사용하는 게이트웨이를 생성할 수 있습니다. 동일한 GatewayClass를 참조하는 여러 Gateway 인스턴스를 생성할 수 있다는 점을 유의하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 게이트웨이\n\n수동으로 설치된 Kong 게이트웨이의 경우 (우리가 생성중인 것과 같이), 다음 파일을 만들어야 합니다:\n\nkong-gw-gateway.yml\n\n```yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: kong-gateway\n  namespace: kong\nspec:\n  gatewayClassName: kong-class\n  listeners:\n    - name: world-selector\n      hostname: worlds.com\n      port: 80\n      protocol: HTTP\n      allowedRoutes:\n        namespaces:\n          from: All\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파일에서 유의해야 할 몇 가지 사항이 또 있습니다:\n\n- 나중에 참조할 수 있는 이름이 있습니다 (kong-gateway)\n- GatewayClass는 위에서 생성한 GatewayClass의 이름을 의미합니다\n- 이 Gateway는 이 API Gateway의 진입점인 하나의 리스너만 정의합니다\n- 리스너에는 URL 호환성이 있는 고유한 이름이 지정됩니다\n- 리스너는 포트 80에 바인드됩니다\n- 호스트명은 일치 필드로 사용되며 옵션입니다\n- 이 리스너에 연결할 서비스(allowedRoutes)를 제어할 수 있으며 해당 서비스들은 네임스페이스를 통해 연결됩니다 - 동일한 네임스페이스를 기본으로 사용하여 다른 네임스페이스로 연결하기 위해 모든 네임스페이스로 변경됩니다\n- Gateway 사양은 게이트웨이가 HTTP를 통해 단일 포트(80)에서 수신하는 것을 예상합니다.\n\nGateways는 네임스페이스에 특정하며 API Gateway를 설치하기 전에 생성해야 합니다:\n\n```js\nkubectl create namespace kong\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음 명령을 사용하여 리소스를 만드세요:\n\n```js\nkubectl apply -f kong-gw-gateway.yml\n```\n\n이제 GatewayClass 및 Gateway 리소스가 정의되었으므로, 애플리케이션 자체를 설치하여 이 두 리소스의 구현을 형성할 수 있습니다.\n\n# Kong 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금은 Helm 차트를 사용하여 Kong을 설치할 것입니다. 만약 Helm이 없다면, Helm을 설치하는 방법은 여기에서 찾을 수 있습니다.\n\n## Kong CRDs\n\nKong을 설치하기 전에 Kong Custom Resource Definitions (CRDs)를 설치해야 합니다. 이 작업은 클러스터에서 kubectl을 실행하는 위치에서 다음 명령을 실행하여 수행할 수 있습니다. 제 경우에는 k8s-master 서버에서 이 작업을 수행하고 있습니다.\n\n```js\nkubectl apply -k https://github.com/Kong/kubernetes-ingress-controller/config/crd\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Kong Application\n\nKong을 Kubernetes 클러스터에 설치할 때, 두 가지 구성 요소가 설치됩니다:\n\n- Kong 인그레스 컨트롤러 (KIC) — 쿠버네티스 리소스 정의를 Kong 게이트웨이 구성으로 변환합니다.\n- Kong 게이트웨이 — Kong 인그레스 컨트롤러 (KIC)에 의해 삽입된 구성을 기반으로 서비스로의 라우팅을 담당합니다.\n\n먼저, 로컬 헬름에 Kong 저장소를 추가하십시오:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhelm repo add kong https://charts.konghq.com\nhelm repo update\n```\n\n만약 다음 명령어로 Helm 차트를 검색하면:\n\n```js\nhelm search repo kong\n```\n\n두 개의 항목을 찾을 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n이름           차트 버전  앱 버전  설명\nkong/kong    2.33.3    3.5       클라우드 네이티브 인그레스 및 API 관리\nkong/ingress 0.10.2    3.4       콩 인그레스 컨트롤러 및 콩 게이트웨이 배포\n```\n\nDB 레스 구성을 사용할 것이므로 kong/ingress를 사용할 것입니다. 설치하기 전에 몇 가지 값을 재정의해야 합니다. 다음 파일을 만들어주세요:\n\nkong-values.yml\n\n```js\n#controller:\n#  ingressController:\n#    env:\n#      LOG_LEVEL: trace\n#      dump_config: true\n\ngateway:\n  admin:\n    http:\n      enabled: true\n  proxy:\n    type: NodePort\n    http:\n      enabled: true\n      nodePort: 32001\n    tls:\n      enabled: false\n#  ingressController:\n#    env:\n#      LOG_LEVEL: trace\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKIC 및 Kong Gateway를 부모 Helm 차트를 통해 설치하고 있기 때문에 이 두 애플리케이션의 구성은 각각 컨트롤러 및 게이트웨이 레이블 아래에 있습니다. 컨트롤러는 단순히 알림으로 남겨두었습니다.\n\n또한, 주석 처리된 여러 줄을 볼 수 있습니다. 이것들은 Pod 로그를 통해 무엇이 발생하는지 디버그하고 싶을 때 유용합니다.\n\nBinary Lane은 Kubernetes가 구성할 수 있는 로드 밸런서를 제공하지 않기 때문에 프록시 구성을 재정의하고 있습니다. Kubernetes에게 LoadBalancer 서비스 대신 NodePort 서비스를 설정하도록 지시하고 있습니다. 게이트웨이를 클러스터의 모든 노드에서 사용할 수 있도록 포트 32001에 노출하고 있습니다.\n\n이전에 kong 네임스페이스를 생성했으므로 이제 Kong을 설치할 준비가 되었습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhelm install kong kong/ingress -f kong-values.yml -n kong\n```\n\n이제 설치가 예상대로 작동하는지 확인할 수 있습니다. 준비되는 데 1-2분 정도 걸릴 수 있습니다:\n\n```js\nkubectl get all -n kong\n```\n\n다음과 같은 결과를 얻어야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### NAME READY STATUS RESTARTS AGE\n\n- pod/kong-controller-68cddcbcb7-z46lh 1/1 Running 0 45s\n- pod/kong-gateway-687c5b78db-5qvgd 1/1 Running 0 45s\n\n### NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\n\n- service/kong-controller-validation-webhook ClusterIP 10.110.172.40 \u003cnone\u003e 443/TCP 46s\n- service/kong-gateway-admin ClusterIP None \u003cnone\u003e 8444/TCP 46s\n- service/kong-gateway-manager NodePort 10.100.254.169 \u003cnone\u003e 8002:30698/TCP,8445:30393/TCP 46s\n- service/kong-gateway-proxy NodePort 10.96.24.196 \u003cnone\u003e 80:32001/TCP 46s\n\n### NAME READY UP-TO-DATE AVAILABLE AGE\n\n- deployment.apps/kong-controller 1/1 1 1 45s\n- deployment.apps/kong-gateway 1/1 1 1 45s\n\n### NAME DESIRED CURRENT READY AGE\n\n- replicaset.apps/kong-controller-68cddcbcb7 1 1 1 45s\n- replicaset.apps/kong-gateway-687c5b78db 1 1 1 45s\n\nManagement UI 서비스가 NodePort를 통해 노출됩니다. 이는 관리 API를 볼 수 있는 것을 기대하고 작동하지 않을 것입니다. DB-less 설치를 하고 있기 때문에, 관리 UI의 유일한 사용은 설정을 확인하는 것뿐입니다.\n\n클러스터 내 노드에서 프록시 주소를 curl로 테스트할 수 있습니다:\n\n```js\ncurl localhost:32001\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n요청한 표는 Markdown 형식으로 변경해야 합니다.\n\n```json\n{\n  \"message\": \"해당 값으로 일치하는 경로가 없습니다.\",\n  \"request_id\": \"7fc9db053e3029105581890e81effe12\"\n}\n```\n\n요청 ID는 해당 거래에 고유하며 curl 명령을 다시 실행하면 다른 값을 볼 수 있습니다. 이는 Kong에서 추가되어 시스템을 통해 요청을 추적할 수 있게 합니다. 멋지죠?\n\n이제 새 API 게이트웨이를 구성하여 이전에 생성한 테스트 서비스로 요청을 라우트할 준비가 되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 라우트 추가하기\n\n게이트웨이 리소스에 라우트를 추가하려면 HTTPRoute 리소스를 사용합니다. 다른 수준의 라우팅을 위한 다른 리소스 유형도 있습니다. 이제 worlds.com/world1을 hello-world-1-svc에, worlds.com/world2를 hello-world-2-svc에 연결하기 위해 이러한 리소스 중 하나를 생성할 것입니다.\n\n저는 하나의 HTTPRoute 리소스를 설명하겠고, 다른 하나는 여러분에게 만들어 달라고 요청할 것입니다. 리소스 파일을 생성해주세요:\n\nhello-world-1-route.yml\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: example-1\n  annotations:\n    konghq.com/strip-path: \"true\"\nspec:\n  parentRefs:\n    - name: kong-gateway\n      namespace: kong\n  hostnames:\n    - worlds.com\n  rules:\n    - matches:\n        - path:\n            type: PathPrefix\n            value: /world1\n      backendRefs:\n        - name: hello-world-1-svc\n          port: 80\n          kind: Service\n```\n\n이 파일에서는 'true'로 설정된 Kong 특정 주석인 konghq.com/strip-path를 추가했습니다. 이는 수신된 일치하는 경로를 요청에서 southbound 서비스로 줄일 것입니다. 다른 줄에는 다음이 포함되어 있습니다:\n\n- 사용할 게이트웨이의 정의(ParentRefs에서)는 이름과 네임스페이스로 참조됩니다.\n- 게이트웨이에서 적절한 수신기에 일치시킬 호스트명에 대한 선택적 참조\n- 이 경로에 대해 들어오는 요청과 일치시키는 규칙\n- 요청을 이 일치에 대해 경로지정할 서비스를 정의하는 backendRefs(서비스의 내부 DNS 이름이름이며 포트는 서비스에 대한 매핑되지 않은 클러스터 IP 포트임을 주의하세요)\n\n이 경로에서 일치는 /world1의 접두사이며, 그 후 서비스로 전달되기 전에 제거됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제 다음 라우트를 만듭니다:\n\n```js\nkubectl apply -f hello-world-1-route.yml\n```\n\nNodePort 서비스를 사용하여 게이트웨이를 만들었습니다. 이제 서비스를 테스트할 수 있습니다. NodePort 서비스는 클러스터의 모든 노드에서 사용할 수 있습니다. 보통 저는 k8s-master 노드를 사용하지만 다른 노드도 사용할 수 있습니다. 다음 명령어로 테스트할 수 있습니다:\n\n```js\ncurl -H \"Host: worlds.com\" \u003ck8s-master IP 주소\u003e:32001/world2\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n원하는 요청 라우팅을 위해 Host 헤더로 호스트명을 worlds.com으로 설정했습니다. 테스트 서비스 응답이 돌아오는 것을 확인할 수 있어야 합니다.\n\n이제 두 번째 HTTPRoute 리소스를 추가하여 두 번째 서비스의 요청을 관리할 수 있습니다.\n\n이제 클러스터 노드에서 서비스에 액세스할 수 있으므로 최종 단계 진행할 수 있습니다 - gw 서버 구성.\n\n# 인그레스 지점 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 AWS, Azure, 또는 Google Cloud에서 작업 중이었다면, Gateway 서비스를 LoadBalancer로 유지하고 자동으로 인그레스 포인트가 생성되도록 할 수 있었을 텐데 Binary Lane에서 작업 중이므로 직접 만들어야 합니다.\n\n제 글을 따라오셨다면 알겠지만, 저희는 클러스터로부터 인터넷으로의 인그레스 포인트로 작용하는 gw 서버가 있다는 것을 알고 계실 것입니다. 이 서버는 간단하게 NGINX를 사용하여 구성되어 있습니다.\n\n우리는 이것을 모든 요청을 라운드 로빈 로드 밸런서를 사용하여 클러스터 내 모든 노드로 경로를 설정하도록 구성할 것입니다.\n\ngw 서버에 로그인하고 root 사용자로 다음 파일을 업데이트하십시오 (``에 자신의 값으로 필드를 교체하는 것을 잊지 마세요):\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 worlds.conf 파일의 내용입니다.\n\n```js\nupstream k8s_cluster {\n  server \u003ck8s-master\u003e:32001;\n  server \u003ck8s-node1\u003e:32001;\n  server \u003ck8s-node2\u003e:32001;\n}\n\nserver {\n    listen 80;\n    listen [::]:80;\n\n    server_name worlds.com;\n\n    location / {\n        proxy_pass http://k8s_cluster;\n        include proxy_params;\n    }\n}\n```\n\n일반적으로 프록시 매개변수는 별도의 파일에 설정됩니다:\n\n`/etc/nginx/proxy_params`\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nproxy_set_header Host $http_host;\nproxy_set_header X-Real-IP $remote_addr;\nproxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header X-Forwarded-Proto $scheme;\n```\n\n이렇게 하면 Host 헤더 및 기타 세부 정보가 전달되어 라우팅이 효율적으로 작동할 수 있습니다.\n\n이제 사이트를 활성화하고 구성을 테스트한 다음 NGINX를 재시작하십시오:\n\n```js\nln -s /etc/nginx/sites-available/worlds.conf /etc/nginx/sites-enabled/\nnginx -t\nsystemctl restart nginx\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음과 같이 테스트할 수 있습니다 ( ' '필드를 귀하의 값으로 대체하세요):\n\n```js\ncurl -H \"Host: worlds.com\" \u003cgw 서버 공인 IP 주소\u003e/world1\n```\n\n서버로부터 응답을 받아야 합니다.\n\n축하합니다! 이제 콩(Kong)을 설치하고 서비스에 연결하도록 구성하는 데 성공했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Kong 디버깅\n\n만약 Kong에서 문제가 발생하면 디버깅하는 것이 어려울 수 있어요. 제가 Kong 설치 과정에서 발견한 몇 가지 지침을 공유해드릴게요:\n\n- GatewayClass, Gateway, 그리고 controller/gateway 포드에 kubectl describe를 사용해서 결과물을 주의깊게 살펴보세요. 이런 방법을 이용해 해결책을 찾을 때까지 곤란한 상황에 직면한 적이 있어요.\n- controller와 gateway 로그를 다음과 같이 확인해보세요:\n\n```js\nkubectl logs \u003cpod name\u003e -n kong\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- kong-values.yml 파일을 사용하여 로깅 레벨을 높이세요 (이전에 보여준 라인의 주석을 제거하세요)\n- NodePort 주소를 얻기 위해 kubectl get svc -n kong를 사용하여 관리 UI에 접속하세요 — HTTP 포트를 사용하고 Admin API를 포트 포워딩하세요 (서비스를 외부로 바인딩하기 위해 --address 옵션을 추가하세요):\n\n```js\nkubectl port--forward \u003c게이트웨이 파드 이름\u003e 8001:8001 --address \u003ck8s-마스터 IP 주소\u003e\n```\n\n- 포트 8001을 포워딩한 이후, Postman와 같은 REST API 도구를 사용하여 Admin UI에 접속하세요\n- 접속할 수 있는 디버그 포트가 있습니다:\n\n```js\nkubectl port-forward -n kong \u003c컨트롤러 파드 이름\u003e  10256:10256 --address \u003ck8s-마스터 IP 주소\u003e\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n이 글은 API Gateway인 Kong을 설치하기 위해 필요한 모든 단계를 함께 수행해야 하기 때문에 길었습니다.\n\n이 글에서 우리는:\n\n- 네트워크 토폴로지를 검토했습니다.\n- 서비스가 서비스에 접근하는 데 도움이 되는 방법을 살펐습니다.\n- Kong이 Kubernetes와 어떻게 작동하는지 살펐습니다.\n- 사용할 테스트 서비스를 생성했습니다.\n- GatewayClass 및 Gateway 리소스를 설치하고 구성했습니다.\n- Kong을 설치하고 구성했습니다.\n- 자체 외부 로드 밸런서를 구성했습니다.\n- API Gateway 설치 문제를 해결하는 방법을 고려했습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n마침내 저희는 Kong API 게이트웨이를 통해 인터넷에서 저희의 테스트 서비스에 접속할 수 있었습니다.\n\n이 기사가 흥미롭게 여겨진다면 박수를 부탁드립니다. 이는 미래에 어떤 기사를 쓸지 판단하는 데 도움이 됩니다. 의견이 있으시면 댓글에 남겨주시기 바랍니다.\n","ogImage":{"url":"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png"},"coverImage":"/assets/img/2024-06-23-UsingKongtoaccessKubernetesservicesusingaGatewayresourcewithnocloudprovidedLoadBalancer_0.png","tag":["Tech"],"readingTime":27},{"title":"도커 핵심 개념 완벽 정리","description":"","date":"2024-06-23 23:08","slug":"2024-06-23-DockerFundamentals","content":"\n도커는 개발자가 컨테이너에서 애플리케이션을 빌드, 배포 및 실행할 수 있도록 하는 플랫폼입니다. 컨테이너는 가벼우며 이식 가능하고 효율적이어서 현대적인 애플리케이션 개발과 배포에 인기가 많습니다.\n\nbuymeacoffee ☕ 👈 해당 링크를 클릭해 주세요\n\n## 컨테이너 \u0026 가상 머신(VM)\n\n컨테이너와 가상 머신(VM)은 모두 애플리케이션에 대한 격리된 환경을 제공하지만, 그들은 크게 다릅니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- VMs: 전체 하드웨어 및 운영 체제를 가상화합니다. 무겁고 더 많은 자원을 사용합니다.\n- Containers: 운영 체제를 가상화하고 호스트 머신과 커널을 공유하지만 애플리케이션 프로세스를 격리합니다. 가벼우며 적은 자원을 사용합니다.\n\n## 전통적인 배포와의 도전 과제\n\n전통적인 배포 방법은 종종 다음과 같은 도전 과제에 직면합니다:\n\n- 의존성 충돌: 다른 애플리케이션이 서로 다른 라이브러리나 의존성 버전을 필요로 하여 충돌을 일으킬 수 있습니다.\n- 환경 일관성: 구성의 차이로 인해 응용 프로그램이 다양한 환경에서 다르게 동작할 수 있습니다.\n- 확장성: 여러 서버에 걸쳐 응용 프로그램을 확장하는 것은 복잡하고 자원을 많이 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n컨테이너화는 애플리케이션과 그 종속성을 컨테이너에 캡슐화하여 일관성과 이식성을 환경 전반에 걸쳐 보장함으로써 이러한 도전 과제에 대응합니다.\n\n도커 아키텍처 이해하기\n\n도커는 클라이언트-서버 아키텍처를 따르며, 주요 구성 요소는 도커 클라이언트, 도커 데몬 및 도커 레지스트리입니다.\n\n![이미지](/assets/img/2024-06-23-DockerFundamentals_0.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커는 여러 주요 구성 요소를 사용하는 클라이언트-서버 아키텍처를 활용합니다:\n\n- 도커 클라이언트: 도커와 상호 작용하는 데 사용하는 명령줄 인터페이스(CLI) 도구입니다. 컨테이너를 빌드, 실행 및 관리할 수 있습니다. 이것은 도커를 원격으로 제어하는 것으로 생각할 수 있습니다.\n- 도커 엔진 (데몬): 이 소프트웨어는 시스템에서 실행되며 컨테이너의 빌드, 실행 및 배포를 관리합니다. 도커 클라이언트로부터 명령을 수신하고 그에 대해 행동에 옮깁니다.\n- 도커 호스트: 도커가 설치된 물리적인 머신(또는 가상 머신)입니다. 도커 컨테이너를 실행하는 데 필요한 리소스 및 환경을 제공합니다.\n\n도커 오브젝트 (이미지 및 컨테이너):\n\n- 도커 이미지: 도커 컨테이너를 만드는 데 필요한 지침이 포함된 청사진입니다. 어플리케이션을 실행하는 데 필요한 환경(운영 체제, 라이브러리, 응용 프로그램 코드)을 정의합니다. 이것은 어플리케이션 환경을 만드는 레시피로 상상할 수 있습니다.\n- 도커 컨테이너: 도커 이미지의 실행 중인 인스턴스입니다. 가벼우며 다른 컨테이너로부터 격리됩니다. 기본 호스트 시스템의 커널을 공유합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 플로우:\n\n일반적으로 도커 작업 흐름은 다음 단계로 진행됩니다:\n\n![도커 이미지 생성](/assets/img/2024-06-23-DockerFundamentals_1.png)\n\n- 빌드: 도커 파일로부터 도커 이미지를 생성합니다.\n- 푸시: 이미지를 중간 레지스트리나 도커 허브에 업로드합니다.\n- 풀: 레지스트리에서 이미지를 다운로드합니다.\n- 실행: 이미지로부터 컨테이너를 배포합니다.\n- 공유 (선택 사항): 이미지를 레지스트리(예: 도커 허브)에 푸시하여 다른 사람들과 공유할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도커 명령어:\n\n도커 명령어를 사용하면 도커 컨테이너를 쉽게 생성, 실행, 중지, 제거하고 관리할 수 있습니다. 이러한 명령어는 응용 프로그램을 컨테이너 환경에서 배포하고 관리하는 프로세스를 자동화하고 간소화하는 데 도움이 될 수 있습니다.\n\n![도커 기초 사항 이미지](/assets/img/2024-06-23-DockerFundamentals_2.png)\n\n가장 일반적으로 사용되는 도커 명령어를 살펴보면 도커 컨테이너를 효과적으로 관리하는 데 도움이 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `docker run` – 새로운 이미지로부터 Docker 컨테이너를 시작하는 데 사용됩니다.\n- `docker ps` – 실행 중인 모든 Docker 컨테이너를 나열하는 데 사용됩니다.\n- `docker stop` – 실행 중인 컨테이너를 중지하는 데 사용됩니다.\n- `docker rm` – Docker 컨테이너를 제거하는 데 사용됩니다.\n- `docker images` – 현재 시스템에 있는 모든 Docker 이미지를 나열하는 데 사용됩니다.\n- `docker pull` – 레지스트리에서 Docker 이미지를 다운로드하는 데 사용됩니다.\n- `docker exec` – 실행 중인 컨테이너에서 명령을 실행하는 데 사용됩니다.\n- `docker-compose` – 여러 컨테이너로 구성된 Docker 애플리케이션을 관리하는 데 사용됩니다.\n\n# Docker 설치\n\nDocker를 설치하는 과정은 운영 체제에 따라 약간 다를 수 있습니다. 아래는 일반적인 플랫폼에 Docker를 설치하는 일반적인 단계입니다:\n\n# 1. Windows에 Docker 설치하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. Docker 웹사이트에서 Docker Desktop for Windows 설치 프로그램을 다운로드하고 실행해주세요 🐬.\n\n2. 설치를 완료하기 위해 화면 안내에 따라 진행해주세요. Docker Desktop은 Docker Engine을 포함한 필요한 구성 요소를 시스템에 설치합니다.\n\n3. 설치가 완료되면 Docker Desktop은 시스템 트레이에 나타나며 Docker 명령어는 명령 프롬프트(또는) PowerShell에서 실행할 수 있습니다.\n\n# 2. Linux(Ubuntu/Debian)에 Docker 설치하기:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n터미널을 열고 아래 명령을 하나씩 실행해주세요:\n\n```bash\n# 패키지 인덱스 업데이트\n\n# 필요한 종속성 설치\n\n# Docker GPG 키 추가\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도커 저장소 추가\n\n# 패키지 인덱스 다시 업데이트\n\n# 도커 설치\n\n# 도커 서비스 시작\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 도커 명령을 sudo 없이 실행하려면 사용자를 'docker' 그룹에 추가하세요.\n\n## macOS에 도커 설치하기:\n\n1. 도커 웹사이트에서 도커 데스크톱 for Mac 설치 프로그램을 다운로드 🐬 받아 더블 클릭하여 설치를 시작합니다.\n\n2. 설치를 완료하기 위해 Docker.app 파일을 Applications 폴더로 드래그 앤 드롭하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n3. 응용 프로그램 폴더에서 Docker Desktop을 실행하면 배경에서 실행됩니다.\n\n# 4. Docker 설치 확인:\n\nDocker를 설치한 후 터미널이나 명령 프롬프트에서 다음 명령을 실행하여 설치를 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-DockerFundamentals_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 Docker가 정상적으로 설치되었다면, 버전 번호가 표시됩니다.\n\n![Docker version](/assets/img/2024-06-23-DockerFundamentals_4.png)\n\n## 첫 번째 Docker 컨테이너 실행하기\n\nNginx 이미지 다운로드: 터미널(또는) 명령 프롬프트에서 다음 명령을 사용하여 Docker 허브에서 공식 Nginx 이미지를 다운로드하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Docker Fundamentals](/assets/img/2024-06-23-DockerFundamentals_5.png)\n\nRun Nginx Container\nNow, run the Nginx container using the `docker run` command:\n\n- `-d`: Detached mode. The container will run in the background.\n- `-p 80:80`: Publishes port 80 from the container to port 80 on the host machine. This allows you to access the web server on your browser.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- **name**: `my_web_app` - 컨테이너에 사용자 정의 이름(\"my_web_app\")을 할당하여 쉽게 식별할 수 있도록 합니다.\n\n- **nginx**: 실행할 이미지의 이름(이 경우에는 공식 Nginx 이미지).\n\n웹 서버가 성공적으로 실행 중인 것을 나타내는 기본 Nginx 랜딩 페이지를 볼 수 있어야 합니다.\n\n![Nginx Landing Page](/assets/img/2024-06-23-DockerFundamentals_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로컬 이미지 목록\n\n현재 실행 중인 컨테이너를 나열하려면:\n\n![DockerFundamentals_7](/assets/img/2024-06-23-DockerFundamentals_7.png)\n\n컨테이너를 중지하려면 다음 명령어를 사용할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 컨테이너를 제거하고 싶다면 다음을 사용할 수 있어요:\n\nDocker와 Nginx를 사용하여 간단한 웹 애플리케이션을 성공적으로 만들었어요. 이미지를 제거한 후에도요.\n\n# 결론\n\nDocker를 사용한 컨테이너화는 응용 프로그램을 패키지화, 배포, 관리하는 강력하고 효율적인 방법을 제공해요. Docker의 기능과 도구를 활용하여 개발자들은 개발 프로세스를 간소화하고 응용 프로그램의 일관성을 보장하며 확장성과 이식성을 향상시킬 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 블로그를 읽어 주셔서 감사합니다 🙏.\n","ogImage":{"url":"/assets/img/2024-06-23-DockerFundamentals_0.png"},"coverImage":"/assets/img/2024-06-23-DockerFundamentals_0.png","tag":["Tech"],"readingTime":10},{"title":"Kubernetes에서 서비스 및 네트워킹 이해하는 방법","description":"","date":"2024-06-23 23:06","slug":"2024-06-23-ServicesandNetworkinginKubernetes","content":"\n## 쿠버네티스 기본 개념 — 파트 (3.a)\n\n# 소개\n\n쿠버네티스는 조직이 컨테이너화된 애플리케이션을 배포, 확장 및 관리하는 방식을 혁신적으로 변화시켰습니다. 이 오케스트레이션 플랫폼의 핵심에는 컨테이너 간의 원활한 통신과 연결을 보장하는 복잡한 서비스 및 네트워킹 구성 요소들이 있습니다. 이 문서에서는 쿠버네티스 서비스와 네트워킹의 세계에 대해 깊이 있게 다루며 핵심 개념, 서비스 유형 및 이들이 컨테이너화된 애플리케이션의 전반적인 효율성에 어떻게 기여하는지 살펴보겠습니다.\n\n## 튜토리얼 흐름:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_0.png\" /\u003e\n\n서비스에 대해 이야기한 후 인그레스 컨트롤러를 자세히 살펴볼 예정입니다.\n\n# K8s의 서비스\n\n## 쿠버네티스 서비스란?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nKubernetes에서 서비스는 포드의 논리적 집합과 해당 포드에 액세스하는 정책을 정의하는 추상화입니다. 서비스를 통해 응용 프로그램의 서로 다른 부분 간의 통신 및 발견이 가능해지며, 확장 가능하고 견고한 아키텍처를 제공할 수 있습니다.\n\n## Kubernetes에서 주요 서비스 유형은 무엇인가요?\n\n- NodePort 서비스: 각 노드의 IP에 정적 포트에서 서비스를 노출합니다. 이 포트를 통해 해당 포트의 어느 노드에서든 서비스에 외부 액세스할 수 있습니다.\n- ClusterIP 서비스: 기본 서비스 유형입니다. 클러스터 내부 IP에서 서비스를 노출합니다. 클러스터 내의 포드는 이 IP를 사용하여 서비스에 도달할 수 있습니다.\n- LoadBalancer 서비스: 클라우드 제공 업체의 로드 밸런서를 사용하여 서비스를 외부에 노출합니다. 로드 밸런싱이 필요한 외부 액세스가 필요한 응용 프로그램에 적합합니다.\n\n## NodePort 서비스란 무엇이며 예시를 들어 설명해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNodePort은 클러스터의 각 노드에서 특정 포트로 서비스를 노출하는 서비스 유형입니다.\n\n이를 통해 클러스터 외부에서 해당 서비스에 외부 액세스가 가능해집니다.\n\nNodePort는 클러스터 내부에서 실행 중인 웹 응용 프로그램에 액세스하는 것과 같이 서비스를 외부 세계에 노출하는 데 일반적으로 사용됩니다.\n\nNodePort 서비스에 대한 주요 포인트:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 외부 액세스: NodePort는 각 노드의 포트를 서비스의 포트에 매핑하여 서비스를 외부에서 액세스할 수 있게 합니다.\n- 클러스터 IP: NodePort 서비스에는 클러스터 내에서 ClusterIP를 통해 내부적으로 액세스할 수 있는 기능도 있습니다.\n- 포트 매핑: NodePort 서비스를 생성하면 Kubernetes가 각 노드에 미리 정의된 범위(기본값은 30000~32767)에서 포트를 자동으로 할당합니다. 이 포트가 NodePort입니다.\n- 로드 밸런싱: NodePort는 정교한 로드 밸런싱을 제공하지는 않지만, 클러스터 내의 모든 노드에 도달하여 서비스에 외부 액세스할 수 있게 합니다.\n\n![서비스 및 네트워킹 in Kubernetes](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_1.png)\n\n![서비스 및 네트워킹 in Kubernetes](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_2.png)\n\n이 예제의 구성 요소를 자세히 살펴보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- metadata: 서비스의 이름을 지정합니다.\n- spec.selector: 서비스가 대상이 될 파드를 결정하는 셀렉터를 정의합니다. 이 경우에는 app: my-app 라벨이 있는 파드를 대상으로 합니다.\n- spec.ports: 포트 구성을 지정합니다. 이 예에서는 서비스가 포트 80에서 수신하고 포트 8080으로 트래픽을 전달합니다.\n- spec.type: NodePort: 이것이 NodePort 서비스임을 나타냅니다.\n- kubectl apply -f demoNodeport.yaml 명령을 사용하여 이 YAML 구성을 적용하면, Kubernetes가 teva-nodeport-service 라는 이름의 NodePort 서비스를 생성합니다.\n\n하나의 노드에 여러 개의 파드가 있는 경우\n\n![서비스 및 쿠버네티스 네트워킹](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_3.png)\n\n여러 노드에 파드가 있는 경우\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_4.png)\n\ncurl http://192.169.1.4:30008 또는 curl http://192.169.1.6:30008 또는 curl http://192.169.1.9:30008\n\n## ClusterIP 서비스란 무엇이며 예시를 들어 설명해주세요?\n\nClusterIP 서비스는 내부 IP 주소를 노출하고 클러스터 내에서만 접근할 수 있도록 만드는 종류의 서비스입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이는 클러스터 외부에서 해당 서비스에 접근할 수 없음을 의미합니다.\n\nClusterIP 서비스는 주로 클러스터 내의 다른 구성 요소 또는 마이크로서비스 간 통신에 사용됩니다.\n\nClusterIP 서비스에 대한 주요 포인트:\n\n- 내부 IP 주소: ClusterIP 서비스는 쿠버네티스 클러스터 내에서만 접근할 수 있는 내부 IP 주소가 할당됩니다.\n- Pod 선택기: 선별기를 기반으로 한 일련의 파드와 연관되어 있습니다. 서비스는 지정된 레이블 선택기와 일치하는 파드로 트래픽을 전달합니다.\n- 로드 밸런싱: ClusterIP 서비스는 해당 서비스와 관련된 파드 간의 기본적인 로드 밸런싱을 제공합니다. 들어오는 트래픽은 선택된 파드 사이에 분산됩니다.\n- 클러스터 내 통신: 이러한 서비스는 같은 쿠버네티스 클러스터 내에서 실행되는 응용 프로그램 또는 마이크로서비스의 서로 다른 부분 간 통신에 적합합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 변경하영 표시한 것입니다.\n\n![ClusterIP implementation](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_5.png)\n\nExample Sample ClusterIP implementation.\n\n![ClusterIP YAML example](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_6.png)\n\nThis YAML defines a ClusterIP service named “backend-service” that selects pods labeled with “app: backend.”\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스는 포트 8080에서 수신하고 해당 포트 8080으로 팟으로 트래픽을 전달합니다.\n\n![Image 1](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_7.png)\n\n![Image 2](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_8.png)\n\n이 예시의 구성 요소를 살펴보겠습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- metadata: 서비스의 이름을 지정합니다.\n- spec.selector: 서비스가 대상이 되는 팟을 결정하는 셀렉터를 정의합니다. 이 경우, app: frontend 라벨을 가진 팟을 대상으로 합니다.\n- spec.ports: 포트 구성을 지정합니다. 이 예에서는 서비스가 포트 80에서 수신하고 포트 8080으로 트래픽을 전달합니다.\n- spec.type: ClusterIP: 이것이 ClusterIP 서비스임을 나타냅니다.\n- kubectl apply -f `filename`.yaml을 사용하여이 YAML 구성을 적용하면 Kubernetes가 example-clusterip-service라는 ClusterIP 서비스를 생성합니다.\n- 이 서비스는 클러스터 내에서 ClusterIP 주소를 사용하여 접근할 수 있습니다.\n- 동일한 Kubernetes 클러스터 내의 다른 팟들은 이 서비스와 통신하기 위해 ClusterIP 및 포트를 사용할 수 있습니다 (예: example-frontend-service: 80).\n\n## 로드 밸런서 서비스란 무엇이며 예시를 들어 설명하세요?\n\nKubernetes(K8s)에서 로드 밸런서는 서비스를 외부 세계에 노출시키고 외부 로드 밸런서를 자동으로 프로비저닝하는 유형의 서비스입니다.\n\n이 로드 밸런서는 들어오는 네트워크 트래픽을 여러 노드에 분산하여 응용 프로그램의 고가용성과 신뢰성을 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n로드밸런서 서비스에 대한 주요 포인트:\n\n- 외부 액세스: 로드밸런서 서비스는 클라우드 제공 업체의 로드 밸런서를 프로비저닝하여 서비스를 외부에서 접근 가능하게 만듭니다. 외부 로드 밸런서에는 일반적으로 공개 IP 주소가 있으며 귀하의 응용 프로그램을 실행하는 노드로 트래픽을 분배할 수 있습니다.\n- 자동 프로비저닝: 로드밸런서 서비스를 만들면 Kubernetes가 클라우드 제공 업체와 통신하여 자동으로 로드 밸런서를 프로비저닝합니다. 이 프로세스의 구체적인 내용은 클라우드 제공 업체에 따라 다릅니다.\n- NodePort 및 ClusterIP: 로드밸런서 서비스에는 NodePort 및 ClusterIP도 있습니다. NodePort는 클러스터 외부에서 서비스에 액세스할 수 있게 하며, ClusterIP는 클러스터 내에서 내부 액세스를 허용합니다.\n- 자동 스케일링: 외부 로드 밸런서는 여러 노드에 트래픽을 분산하여 확장성과 내결함성을 제공하기 위해 수평으로 확장할 수 있습니다.\n\n![로드밸런서 서비스 이미지](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_9.png)\n\n이 예에서는 세 개의 백엔드 팟 복제본을 만드는 간단한 배포(backend-deployment)를 정의합니다. 이 팟은 선택기 일치를 위해 app: backend로 레이블이 지정됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_10.png)\n\n백엔드 서비스는 백엔드 팟과 연관된 로드 밸런서 서비스입니다. 포트 80을 노출하고 트래픽을 포트 8080에서 팟으로 전달합니다.\n\n이제 배포 및 서비스를 생성하기 위해 YAML 파일 두 개를 적용하세요:\n\n![이미지](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n서비스에 액세스하는 방법: 로드 밸런서 서비스가 프로비저닝되면 외부 IP 주소를 사용하여 서비스에 외부에서 액세스할 수 있습니다.\n\n클라우드 제공업체에 따라 IP 주소가 할당되는 데 시간이 걸릴 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_12.png)\n\n\"EXTERNAL-IP\" 필드를 찾아 할당된 후에 서비스에 액세스할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![이미지](/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_13.png)\n\n# 인그레스 네트워킹\n","ogImage":{"url":"/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_0.png"},"coverImage":"/assets/img/2024-06-23-ServicesandNetworkinginKubernetes_0.png","tag":["Tech"],"readingTime":10},{"title":"데이터 엔지니어링을 위한 Kubernetes 처음부터 끝까지 완벽 가이드","description":"","date":"2024-06-23 23:03","slug":"2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide","content":"\n최근 몇 년간 데이터 엔지니어링이 크게 발전하였는데, Kubernetes가 이 분야에서 중요한 기술로 부상하였습니다. Kubernetes는 확장 가능하고 효율적인 애플리케이션 배포를 포함한 데이터 파이프라인 및 워크플로우의 효율적인 구축과 관리를 지원하는 오픈 소스 컨테이너 오케스트레이션 플랫폼입니다. 이 글에서는 Docker에서 Kubernetes 설정, kubectl로 클러스터 관리, Kubernetes 대시보드 배포, 그리고 Helm 차트를 사용해 Apache Airflow를 실행하는 방법에 대해 알아보겠습니다.\n\n![KubernetesforDataEngineeringAnEnd-to-EndGuide_0](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_0.png)\n\n# Kubernetes란 무엇인가요?\n\nKubernetes는 K8s로 약칭되며, 애플리케이션 컨테이너를 자동으로 배포, 확장 및 운영하기 위해 설계된 오픈 소스 플랫폼입니다. 원래 구글에서 개발되었으며 현재는 Cloud Native Computing Foundation에서 유지보수하고 있습니다. Kubernetes는 견고한 기능과 광범위한 커뮤니티 지원으로 컨테이너 오케스트레이션의 표준으로 자리매깁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쿠버네티스의 핵심 개념\n\n쿠버네티스를 이해하기 위해 그 핵심 개념을 살펴보겠습니다:\n\n- 컨테이너: 쿠버네티스는 컨테이너화를 기반으로 구축되어 있습니다. 컨테이너는 응용 프로그램을 모든 종속성과 실행 환경과 함께 패키징합니다. 이는 다양한 개발, 테스트 및 프로덕션 환경에서 일관성을 유지합니다.\n- 파드: 쿠버네티스에서 가장 작은 배포 가능한 단위입니다. 파드는 하나 이상의 컨테이너를 포함할 수 있으며, 이 컨테이너들은 저장소, 네트워크 및 실행 방법에 대한 사양을 공유합니다. 파드는 순간적이고 임시적입니다.\n- 노드: 쿠버네티스에서의 워커 머신으로서, 물리적 또는 가상 머신이 될 수 있습니다. 각 노드는 파드를 실행하고, 마스터 노드에 의해 관리됩니다. 노드에는 파드를 실행하기 위한 필요한 서비스가 포함되어 있으며, 컨트롤 플레인에 의해 관리됩니다.\n- 컨트롤 플레인: 쿠버네티스 노드를 제어하는 프로세스들의 모음입니다. 모든 작업 할당은 여기에서 시작됩니다. 컨트롤 플레인의 구성 요소들은 클러스터에 대한 전역 결정(예: 스케줄링)을 내리고, 클러스터 이벤트(예: 배포의 레플리카 필드가 충족되지 않았을 때 새로운 파드 시작)를 감지하고 대응합니다.\n- 서비스: 쿠버네티스 서비스는 논리적인 일련의 파드와 그에 대한 액세스 정책을 정의하는 추상화 계층입니다. 이는 일부 파드에 네트워크 액세스를 제공하는 데 자주 사용됩니다.\n- 배포: 파드 및 레플리카셋에 대한 선언적 업데이트를 관리하는 고수준 개념입니다. 배포는 파드에 대한 템플릿을 사용하고 파드 수, 롤링 업데이트 전략 및 원하는 상태에 대한 제어 매개변수를 확장합니다.\n\n만일 전체 비디오에 관심이 있으시다면, [여기](#)를 클릭해서 보실 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 데이터 엔지니어링에서 Kubernetes 이해하기\n\n실제 측면에 들어가기 전에, 데이터 엔지니어링에서 Kubernetes가 왜 게임 체인저인지 이해하는 것이 중요합니다:\n\n- 확장성: Kubernetes는 수요에 따라 데이터 처리 워크로드를 자동으로 확장할 수 있습니다.\n- 내구성: 실패를 효과적으로 관리하여 데이터 파이프라인의 높은 가용성을 보장합니다.\n- 자원 최적화: Kubernetes는 기본 리소스의 사용을 최적화하여 비용을 절감합니다.\n- 이식성과 일관성: 서로 다른 배포 플랫폼에서도 일관된 환경을 제공합니다.\n\n# 연결 기술은 어떨까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리 Kubernetes 클러스터를 관리하고 제어하며 데이터 엔지니어링 프로세스를 용이하게 하기 위해 Kubernetes와 함께 사용될 다른 기술들에 대해 이야기해보려고 해요. 이 기술들은 Docker, Kubectl, Helm 등을 포함합니다.\n\n## Docker\n\nDocker는 컨테이너 내에서 애플리케이션을 개발, 배포 및 실행하는 플랫폼입니다. 컨테이너화는 애플리케이션을 해당 애플리케이션만을 위한 자체 운영 환경과 함께 컨테이너에 묶는 완전한 가상화의 가벼운 대안입니다.\n\n- 컨테이너: 애플리케이션의 코드, 구성 및 종속성을 하나의 객체로 패키징하는 표준 방법을 제공합니다.\n- 이미지: 코드, 런타임, 라이브러리, 환경 변수 및 구성 파일 등 애플리케이션을 실행하는 데 필요한 모든 것이 포함된 실행 가능한 패키지입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쿠버네티스 클러스터 관리\n\n쿠버네티스 클러스터를 관리하는 것은 각각이 클러스터의 라이프사이클 및 운영에 특정 목적을 제공하는 다양한 도구와 기술을 포함합니다. 저는 쿠버네티스 클러스터를 제어하고 관리하는 데 널리 사용되는 세 가지 주요 기술을 강조하기로 결정했습니다.\n\n## 1. kubectl\n\n- 목적: kubectl은 쿠버네티스 API와 상호 작용하는 명령줄 도구입니다. 이는 쿠버네티스 클러스터를 관리하는 주요 인터페이스입니다.\n- 기능: 애플리케이션을 배포하고 클러스터 리소스를 검사하고 관리하며 로그를 보고 팟에서 명령을 실행하는 등의 기능을 제공합니다.\n- 사용법: kubectl 명령은 간단합니다. 예를 들어, kubectl get pods는 현재 네임스페이스의 모든 팟을 나열하거나 kubectl apply -f deployment.yaml은 파일에서 구성을 적용하는 것과 같은 명령입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. 미니큐브\n\n- 목적: 미니큐브는 쿠버네티스를 로컬에서 실행할 수 있게 해주는 도구입니다. 로컬 머신에서 단일 노드 쿠버네티스 클러스터를 생성합니다.\n- 사용 사례: 개발 및 테스트 목적으로 이상적입니다. 개발자들이 자신의 머신에서 쿠버네티스 환경에서 애플리케이션을 테스트할 수 있도록 합니다.\n- 특징: DNS, 노드 포트, 구성 맵 및 시크릿, 대시보드, 컨테이너 런타임 등 다양한 쿠버네티스 기능을 지원합니다.\n\n## 3. 쿠버엠톰\n\n- 목적: 쿠버엠톰은 쿠버네티스 클러스터를 생성하고 관리하기 위해 kubeadm init 및 kubeadm join을 제공하는 도구입니다.\n- 기능: 쿠버네티스 클러스터의 부트스트래핑, 제어 플레인 설정, 토큰 관리, kubeadm 설정 등을 처리합니다.\n- 사용법: 일반 클러스터 설정 과정을 간소화하여, 쿠버네티스에 처음 입문하는 사람들도 접근하기 쉽게 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 문서에서는 kubectl을 사용할 것입니다. 귀하의 운영 체제 및 버전을 선택하여 기기에 설치할 수 있습니다.\n\n만약 minikube 또는 kubeadm을 사용하여 Kubernetes 클러스터를 관리하고 싶다면, 각각 여기와 여기의 빠른 시작 가이드를 따를 수 있습니다.\n\n설치가 완료된 후에는 다음을 실행하여 설치를 확인할 수 있습니다.\n\n```js\nkubectl version\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제 경우에는 kubectl 버전 1.29.1을 실행 중입니다. 당신이 프로세스를 실행하는 시기에 따라 더 높을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_1.png)\n\n# Docker에서 Kubernetes 설정하기\n\nDocker에서 Kubernetes를 설정하는 것은 Docker가 컨테이너화된 애플리케이션을 실행하는 로컬 Kubernetes 클러스터를 생성하는 과정을 포함합니다. 이 설정은 개발 및 테스트 목적으로 특히 유용합니다. Docker에서 Kubernetes를 설정하는 단계별 가이드는 다음과 같습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 준비 사항\n\n- 도커: 시스템에 도커가 설치되어 있는지 확인해주세요. Windows 및 Mac용 도커 데스크톱은 쿠버네티스 지원이 기본 내장되어 있습니다.\n- 하드웨어 요구 사항: 여러 컨테이너를 실행하기 위한 충분한 CPU, 메모리 및 저장 공간이 필요합니다.\n\n# 설정 단계\n\n## 1. 도커 데스크톱 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다운로드 및 설치: 공식 Docker 웹사이트에서 Docker Desktop을 다운로드하세요. 제공된 지침을 따라 컴퓨터에 설치해주세요.\n- Kubernetes 활성화: Docker Desktop에는 로컬 컴퓨터에서 실행되는 독립형 Kubernetes 서버가 포함되어 있습니다. 이를 활성화하기 전에 초기 기본 구성에서 리소스를 약간 늘려주어야 합니다.\n\n![이미지](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_2.png)\n\nDocker Desktop에서 Kubernetes 활성화 방법:\n\n- Docker Desktop 설정을 엽니다.\n- Kubernetes 섹션을 찾습니다.\n- “Kubernetes 활성화”란에 체크합니다.\n- 변경사항을 저장하려면 “적용 및 다시 시작”을 클릭합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 변경하겠습니다.\n\n![이미지](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_3.png)\n\n## 2. 설치 확인\n\n- 도커 확인: 터미널이나 명령 프롬프트를 열고 docker --version을 실행하여 도커가 올바르게 설치되었는지 확인합니다.\n\n## 3. 쿠버네티스 컨텍스트 구성\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 쿠버네티스는 서로 다른 클러스터에 액세스하기 위해 컨텍스트를 사용합니다. 도커 데스크탑은 docker-desktop이라는 컨텍스트를 설정합니다.\n- 이 컨텍스트로 전환하려면 kubectl config use-context docker-desktop을 사용하십시오.\n\n# PC에 헬름 차트 설치하는 방법\n\n## macOS용:\n\n- Homebrew: Homebrew를 설치한 경우, 간단히 다음을 실행할 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nbrew install helm\n```\n\n## Windows 사용자분들을 위해:\n\n- Chocolatey를 사용하는 경우, 다음 명령어를 실행하여 Helm을 설치할 수 있습니다:\n\n```js\nchoco install kubernetes-helm\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 리눅스용:\n\n- 스크립트: Helm은 리눅스 사용자를 위한 자동화된 스크립트를 제공합니다. 다음을 실행하세요:\n\n```js\ncurl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n```\n\n만약 다른 버전의 운영 체제, 패키지 관리자를 원하시거나 소스에서 직접 빌드하고 싶다면 공식 가이드의 지침을 따를 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n헬름이 컴퓨터에 설치되면 다음을 실행하여 설치를 확인할 수 있습니다:\n\n```js\nhelm version\n```\n\n아래 스크린샷과 유사한 내용이 표시됩니다. 저의 경우에는 헬름 3.14.0을 실행하고 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Kubernetes 대시보드 배포하기\n\nKubernetes 대시보드는 Kubernetes 클러스터를 관리하는 사용자 친화적인 웹 기반 인터페이스를 제공합니다. 클러스터 리소스와 애플리케이션을 보고 관리할 수 있으며 기본적인 문제 해결 기능도 제공합니다. Kubernetes 대시보드를 배포하는 방법은 다음과 같습니다:\n\n## 단계 1: 대시보드 배포하기\n\n- 배포 명령 실행: Kubernetes 대시보드를 배포하려면 kubectl을 사용하여 yaml 구성을 배포하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl apply -f https://raw.githubusercontent.com/airscholar/Kubernetes-For-DataEngineering/main/k8s/recommended-dashboard.yaml\n```\n\n이 명령은 Kubernetes 대시보드의 GitHub 저장소에서 권장 배포 구성을 다운로드하고 적용합니다. 보게 될 내용은 다음과 같아야 합니다.\n\n# 단계 2: 대시보드에 액세스하기\n\n- 프록시 시작: Kubernetes 대시보드는 프록시 서버를 통해 액세스됩니다. 다음 몤령을 사용하여 프록시를 시작합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl proxy\n```\n\n이 명령어를 실행하면 대시보드를 로컬 머신에서 URL을 통해 접속할 수 있습니다.\n\n![image](/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_5.png)\n\n2. URL에 접속하세요: 웹 브라우저를 열고 다음 URL로 이동하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nhttp://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/\n```\n\n이 URL은 Kubernetes 대시보드 인터페이스로 이동합니다.\n\n# 단계 3: 대시보드 인증하기\n\n- Bearer 토큰 받기: 대시보드에 로그인하려면 Bearer 토큰을 생성해야 합니다. 다음 단계를 따라 서비스 계정을 생성하고 토큰을 받을 수 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다음 내용으로 dashboard-adminuser.yaml이라는 파일을 생성하세요:\n\n```yaml\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: admin-user\n  namespace: kubernetes-dashboard\n```\n\n- 다음 내용으로 dashboard-clusterrole.yaml이라는 파일을 생성하세요:\n\n```yaml\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  name: admin-user\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n  - kind: ServiceAccount\n    name: admin-user\n    namespace: kubernetes-dashboard\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 그리고 마지막으로 아래 내용을 가진 dashboard-secret.yaml 파일을 생성해주세요.\n\n```js\napiVersion: v1\nkind: Secret\nmetadata:\n  name: admin-user\n  namespace: kubernetes-dashboard\n  annotations:\n    kubernetes.io/service-account.name: \"admin-user\"\ntype: kubernetes.io/service-account-token\n```\n\n이 구성을 적용하려면 다음 명령을 실행해야합니다.\n\n```js\nkubectl apply -f dashboard-adminuser.yaml\nkubectl apply -f dashboard-clusterrole.yaml\nkubectl apply -f dashboard-secret.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 대시보드에 액세스할 때 사용할 토큰을 생성하는 방법입니다:\n\n```js\nkubectl get secret admin-user -n kubernetes-dashboard -o jsonpath={\".data.token\"} | base64 -d\n```\n\n만약 CLI를 사용하는 것을 선호한다면, 대신에 다음 명령어를 실행할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- kube-system 네임스페이스에 서비스 계정을 생성해 주세요:\n\n```js\nkubectl create serviceaccount admin-user -n kubernetes-dashboard\n```\n\n- 서비스 계정을 클러스터 관리자 역할에 바인딩해 주세요:\n\n```js\nkubectl create clusterrolebinding admin-user --clusterrole=cluster-admin --serviceaccount=kubernetes-dashboard:admin-user\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다음 명령을 사용하여 비밀을 가져오세요:\n\n```js\nkubectl get secret $(kubectl get serviceaccount admin-user -n kubernetes-dashboard -o jsonpath=\"{.secrets[0].name}\") -n kubernetes-dashboard -o jsonpath=\"{.data.token}\" | base64 --decode\n```\n\n그런 다음 대시보드에 로그인하려면 토큰을 사용하세요:\n\n## 단계 4: 대시보드 사용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 대시보드 탐색하기: 로그인하면 배포, 서비스 및 팟과 같은 Kubernetes 자원을 보거나 관리할 수 있습니다.\n- 자원 생성 및 수정: 대시보드 UI를 통해 직접 새로운 자원을 생성하거나 기존 자원을 수정할 수 있습니다.\n- 클러스터 및 애플리케이션 성능 모니터링: 대시보드를 통해 클러스터 전체 및 CPU 및 메모리 사용량을 포함한 개요를 제공합니다.\n\n모든 소셜 미디어 플랫폼에서 팔로우를 눌러주시고 지지를 보여주기 위해 박수를 보내고 댓글을 달아주세요.\n\n- Github: airscholar\n- Twitter: @YusufOGaniyu\n- LinkedIn: Yusuf Ganiyu\n- Youtube: CodeWithYu\n\n이제 Kubernetes 대시보드를 성공적으로 배포했으므로, 차례로 Kubernetes 클러스터에 Apache Airflow를 배포할 준비를 해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 쿠버네티스 클러스터에 Apache Airflow 배포하기\n\n쿠버네티스 클러스터에 Apache Airflow를 배포하는 것은 강력한 스케줄링 및 워크플로우 관리 기능을 확장 가능한 환경에서 활용하는 훌륭한 방법입니다. Apache Airflow를 쿠버네티스에 배포하는 가장 효율적인 방법은 Helm을 사용하는 것입니다. Helm은 쿠버네티스 응용 프로그램의 설치 및 관리를 간소화하는 패키지 매니저입니다. 이제 함께 Apache Airflow를 쿠버네티스에 배포하는 과정을 살펴보겠습니다.\n\n## 요구 사항\n\n다음 요구 사항은 문제 없이 진행하기 위해 필요합니다. 이전 부분을 건너 뛰었다면, 계속 진행하기 전에 모든 것이 잘 작동하는지 다시 확인하는 것이 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 실행 중인 Kubernetes 클러스터가 필요합니다.\n- 로컬 머신에 Helm이 설치되어 있어야 합니다 (필요한 경우 Helm 설치 방법은 이전 지침을 참조하십시오).\n- Kubernetes 클러스터와 통신할 수 있도록 kubectl이 구성되어 있어야 합니다.\n\n## 단계 1: Airflow Helm Chart 저장소 추가\n\n먼저, Apache Airflow 공식 Helm 차트 저장소를 Helm 설치에 추가해야 합니다:\n\n```sh\nhelm repo add apache-airflow https://airflow.apache.org\nhelm repo update\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 명령어는 Airflow 리포지토리를 추가하고 로컬 Helm 차트 리포지토리 인덱스를 업데이트합니다.\n\n# 단계 2: Apache Airflow 설치\n\n다음 명령어로 Apache Airflow를 Helm 차트를 사용하여 설치할 수 있습니다:\n\n```js\nhelm install airflow apache-airflow/airflow --namespace airflow --create-namespace --debug\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- airflow은 릴리스 이름으로, 원하는대로 변경할 수 있습니다.\n- --namespace airflow는 Airflow를 설치할 Kubernetes 네임스페이스를 지정합니다. 네임스페이스가 존재하지 않는 경우, --create-namespace를 사용하여 생성하고 --debug를 사용하면 배포 단계를 볼 수 있습니다.\n\n이 명령은 웹 서버, 스케줄러 등 필요한 모든 구성 요소와 함께 Airflow를 배포합니다. 디버그 플래그가 있으면 Apache Airflow 릴리스를 배포하는 데 사용된 세부 정보, 구성 및 해당 값들을 볼 수 있습니다.\n\n배포 중에는 대기 중인 작업 및 해당 상태를 쿠버네티스 클러스터에서 볼 수 있습니다. 프로세스가 완료되면 작업은 대기열에서 제거되어 더 이상 보이지 않게 됩니다.\n\n재미있게도 Apache Airflow 릴리스는 완료되었지만 보통 localhost:8080으로 접근해도 여전히 접속할 수 없습니다. 이를 가능하게 하고 Apache Airflow 파드에 대한 연결을 처리하려면 아래 명령을 실행한 다음 UI에서 Apache Airflow 배포에 액세스해야 합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nkubectl port-forward svc/airflow-webserver 8080:8080 --namespace airflow\n```\n\n또한, 쿠버네티스 클러스터에서 Airflow 배포의 건강 상태를 확인하고 모니터링하는 것이 중요합니다. 모든 것이 잘 되고 준비되어 있는지 확인하기 위해 위의 네임스페이스를 airflow로 변경해주시면 워크로드 세부 정보를 볼 수 있습니다.\n\n이제 관리자 사용자 이름과 관리자 비밀번호로 Airflow UI에 액세스할 수 있습니다.\n\n화면 상단에 동적 웹서버 비밀 키에 관한 경고가 있는 경우 정적 웹서버 비밀 키를 사용하는 것이 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 동적 키 대신 정적 키 사용하는 이유\n\n개발 환경에서는 동적 웹 서버 비밀 키를 사용해도 상관없지만, 제품 환경에서는 정적 웹 서버 비밀 키를 사용하는 것이 강력히 권장됩니다. 그 이유는 다음과 같습니다:\n\n- 응용 프로그램 인스턴스 간의 일관성: 특히 쿠버네티스로 관리되는 제품 환경에서는 응용 프로그램이 여러 인스턴스로 확장될 수 있습니다. 각 인스턴스가 자체 동적 비밀 키를 생성하는 경우 세션, 쿠키 또는 기타 암호화된 데이터 처리에 일관성이 무너질 수 있습니다. 정적 키는 응용 프로그램의 모든 인스턴스가 데이터를 일관적으로 읽고 쓸 수 있도록 보장합니다.\n- 다시 시작 시 지속성: 웹 서버가 다시 시작될 때 새로운 동적 비밀 키를 생성하면 이전 키로 암호화된 모든 세션 및 쿠키가 무효화됩니다. 이는 갑자기 로그아웃되거나 세션 데이터를 잃어버린 사용자에게 혼란을 줄 수 있습니다. 정적 키는 다시 시작할 때 동일하게 유지되어 세션의 연속성을 유지합니다.\n- 보안 최상의 사례: 역설적으로 보일 수 있지만, 안전하게 저장된 정적 비밀 키를 사용하는 것이 동적으로 생성하는 것보다 보안상 더 안전할 수 있습니다. 완전히 무작위이고 안전한 키를 생성하는 것은 쉽지 않습니다. 잘못 생성된 동적 키가 선정된 정적 키보다 덜 안전할 수 있습니다.\n- 구성 관리: 정적 키는 안전한 구성 관리 관행을 통해 관리할 수 있습니다. 이는 HashiCorp Vault, AWS Secrets Manager 또는 Kubernetes Secrets와 같은 비밀 관리 시스템에 키를 저장하는 것을 포함합니다. 이렇게 하면 키가 코드나 안전하지 않은 구성에서 노출되지 않고 액세스를 엄격하게 제어할 수 있습니다.\n- 감사 및 규정 준수: 많은 규정 준수 환경에서는 비밀 키에 대한 감사 및 액세스 제어가 필요합니다. 정적 키를 사용하면 이러한 제어를 구현하고 누가 액세스 권한을 가지고 있는지 추적하는 것이 더 쉬워집니다.\n\n이를 해결하기 위해, Apache Airflow 릴리스에 웹 서버 비밀 키를 포함하여 재구성하겠습니다. 이를 위해 원하는 구성을 덮어쓸 values.yaml 파일을 생성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n키를 생성하는 다양한 방법이 있지만 가장 인기 있는 두 가지 방법을 강조하겠습니다:\n\n- 파이썬 암호화 라이브러리를 사용하여 키를 생성하는 간단한 코드를 작성할 수 있습니다.\n\n- 먼저, cryptography 라이브러리가 설치되어 있는지 확인하십시오:\n\n```js\npip install cryptography\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 그럼 당신의 Python 환경에서 다음 한 줄을 사용할 수 있어요:\n\n```js\npython -c \"from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())\"\n```\n\n2. airflow 페르네 키 사용:\n\n```js\n echo Fernet Key: $(kubectl get secret --namespace airflow\n airflow-fernet-key -o jsonpath=\"{.data.fernet-key}\" | base64 --decode)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한번 생성되면 다음과 같이 보일 것입니다. 이 값들로 values.yaml 파일을 업데이트할 수 있어요.\n\n```js\nfernetKey: aERBZE5MN3E0TjRjU2xzQWxCdTNIUks0WGFTZThoWXc=\nwebserverSecretKey: aERBZE5MN3E0TjRjU2xzQWxCdTNIUks0WGFTZThoWXc=\n```\n\n그런 다음 helm 차트 배포를 다시 업데이트하세요:\n\n```js\nhelm upgrade --install airflow apache-airflow/airflow --namespace airflow --create-namespace -f values.yaml\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI에서 변경 사항을 미리보기하면 경고 메시지가 사라진 것을 확인할 수 있습니다.\n\n# 쿠버네티스에서 Airflow의 DAG 연결\n\n쿠버네티스에 Apache Airflow를 성공적으로 배포한 후에 해야 할 다음 단계는 DAG를 해당 Airflow에 연결하는 것입니다.\n\n우리의 경우, GitHub 저장소에서 DAG를 Airflow에 연결하게 됩니다. 거기에 Airflow DAG 코드를 작성하고 커밋한 후에 해당 커밋으로부터 URL을 얻어 Kubernetes와 동기화할 것입니다. 아래에 제시된 대로 진행됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHere is the translation into Korean:\n\n```python\nfrom airflow import DAG\nfrom airflow.operators.bash_operator import BashOperator\nfrom datetime import datetime, timedelta\n\ndefault_args = {\n    'owner': 'datamasterylab.com',\n    'start_date': datetime(2024, 1, 25),\n    'catchup': False\n}\n\ndag = DAG(\n    'hello_world',\n    default_args=default_args,\n    schedule_interval=timedelta(days=1)\n)\n\nt1 = BashOperator(\n    task_id='hello_world',\n    bash_command='echo \"Hello World\"',\n    dag=dag\n)\n\nt2 = BashOperator(\n    task_id='hello_dml',\n    bash_command='echo \"Hello Data Mastery Lab\"',\n    dag=dag\n)\n\nt1 \u003e\u003e t2\n\n```\n\n```python\nfrom datetime import datetime, timedelta\n\nfrom airflow import DAG\nfrom airflow.operators.python_operator import PythonOperator\n\n\ndef get_data(**kwargs):\n    import requests\n    import pandas as pd\n\n    url = 'https://raw.githubusercontent.com/airscholar/ApacheFlink-SalesAnalytics/main/output/new-output.csv'\n    response = requests.get(url)\n\n    if response.status_code == 200:\n        df = pd.read_csv(url, header=None, names=['Category', 'Price', 'Quantity'])\n\n        # 데이터프레임을 JSON 문자열로 변환하여 xcom으로 전달\n        json_data = df.to_json(orient='records')\n\n        kwargs['ti'].xcom_push(key='data', value=json_data)\n    else:\n        raise Exception(f'데이터를 가져오는 데 실패했습니다. HTTP 상태 코드: {response.status_code}')\n\n\ndef preview_data(**kwargs):\n    import pandas as pd\n    import json\n\n    output_data = kwargs['ti'].xcom_pull(key='data', task_ids='get_data')\n    print(output_data)\n    if output_data:\n        output_data = json.loads(output_data)\n    else:\n        raise ValueError('XCom으로부터 데이터를 받지 못했습니다.')\n\n    # JSON 데이터에서 데이터프레임 생성\n    df = pd.DataFrame(output_data)\n\n    # 총 판매량 계산\n    df['Total'] = df['Price'] * df['Quantity']\n\n    df = df.groupby('Category', as_index=False).agg({'Quantity': 'sum', 'Total': 'sum'})\n\n    # 총 판매량을 기준으로 정렬\n    df = df.sort_values(by='Total', ascending=False)\n\n    print(df[['Category', 'Total']].head(20))\n\n\ndefault_args = {\n    'owner': 'datamasterylab.com',\n    'start_date': datetime(2024, 1, 25),\n    'catchup': False\n}\n\ndag = DAG(\n    'fetch_and_preview',\n    default_args=default_args,\n    schedule_interval=timedelta(days=1)\n)\n\nget_data_from_url = PythonOperator(\n    task_id='get_data',\n    python_callable=get_data,\n    dag=dag\n)\n\npreview_data_from_url = PythonOperator(\n    task_id='preview_data',\n    python_callable=preview_data,\n    dag=dag\n)\n\nget_data_from_url \u003e\u003e preview_data_from_url\n\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위에서 commited된 저장소는 다음과 같습니다:\n\n```js\nhttps://github.com/airscholar/Kubernetes-For-DataEngineering.git\n```\n\n이제 우리의 values.yaml 파일로 돌아가서 저장소와 동기화할 값을 업데이트해봅시다.\n\n```js\nfernetKey: aERBZE5MN3E0TjRjU2xzQWxCdTNIUks0WGFTZThoWXc=\nwebserverSecretKey: aERBZE5MN3E0TjRjU2xzQWxCdTNIUks0WGFTZThoWXc=\n\ndags:\n  gitSync:\n    enabled: true\n    repo: https://github.com/airscholar/Kubernetes-For-DataEngineering.git\n    branch: main\n    rev: HEAD\n    depth: 1\n    maxFailures: 0\n    subPath: \"dags\"\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하루 마무리로 우리는 구성을 다시 적용하고 helm 차트로 릴리스를 업데이트할 거에요!\n\n```js\nhelm upgrade --install airflow apache-airflow/airflow --namespace airflow --create-namespace -f values.yaml\n```\n\nUI에서 그 모습을 확인해보죠.\n\n마지막으로, 이 DAG들을 트리거하고 해당 로그에서 출력을 확인해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 이제 마무리입니다!\n\n아래 주제 중에 관심이 있는 분은:\n\n- Python\n- 데이터 엔지니어링\n- 데이터 분석\n- 데이터 과학\n- SQL\n- 클라우드 플랫폼 (AWS/GCP/Azure)\n- 머신러닝\n- 인공지능\n\n제 모든 플랫폼을 좋아요와 팔로우 해주세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Github: airscholar\n- Twitter: @YusufOGaniyu\n- LinkedIn: Yusuf Ganiyu\n- Youtube: CodeWithYu\n- Medium: Yusuf Ganiyu\n\n나는 LinkedIn, X, Medium 및 YouTube에서 매일 콘텐츠를 공유합니다.\n\ndatamasterylab.com에서 더 많은 코스를 확인하실 수 있습니다.\n\n# 자료들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n깃허브 풀 코드\n\n유튜브 비디오\n\n엔드 투 엔드 데이터 엔지니어링 재생 목록\n\n# 스택데믹\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 축소 버튼을 클릭해 주시고 작가를 팔로우해 주세요! 👏\n- X사의 팔로우 | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해 보세요: In Plain English | CoFeed | Venture\n","ogImage":{"url":"/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_0.png"},"coverImage":"/assets/img/2024-06-23-KubernetesforDataEngineeringAnEnd-to-EndGuide_0.png","tag":["Tech"],"readingTime":28}],"page":"5","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"5"},"buildId":"T_Nz0g9U1yttYMSEma95P","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>