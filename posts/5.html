<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/5" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/5" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Interceptor를 사용한 Nestjs 사용자 정의 API 응답 방법" href="/post/2024-06-30-NestjsCustomAPIResponsewithInterceptor"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Interceptor를 사용한 Nestjs 사용자 정의 API 응답 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-NestjsCustomAPIResponsewithInterceptor_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Interceptor를 사용한 Nestjs 사용자 정의 API 응답 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Interceptor를 사용한 Nestjs 사용자 정의 API 응답 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자바스크립트 vs 타입스크립트 프론트엔드 기술 대전" href="/post/2024-06-30-JavascriptvsTypescriptTheBattleofFrontendTechnologies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자바스크립트 vs 타입스크립트 프론트엔드 기술 대전" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-JavascriptvsTypescriptTheBattleofFrontendTechnologies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자바스크립트 vs 타입스크립트 프론트엔드 기술 대전" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">자바스크립트 vs 타입스크립트 프론트엔드 기술 대전</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular-React 하이브리드 기법 두 기술의 장점 모음" href="/post/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular-React 하이브리드 기법 두 기술의 장점 모음" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular-React 하이브리드 기법 두 기술의 장점 모음" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Angular-React 하이브리드 기법 두 기술의 장점 모음</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 이란 대통령 선거 결정적 순간" href="/post/2024-06-30-IranianPresidentialElection2024ADefiningMoment"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 이란 대통령 선거 결정적 순간" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-IranianPresidentialElection2024ADefiningMoment_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 이란 대통령 선거 결정적 순간" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년 이란 대통령 선거 결정적 순간</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Flutter가 React Native를 대체할 것인가" href="/post/2024-06-30-IsFluttergoingtoreplaceReactNative"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Flutter가 React Native를 대체할 것인가" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-IsFluttergoingtoreplaceReactNative_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Flutter가 React Native를 대체할 것인가" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Flutter가 React Native를 대체할 것인가</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 반드시 알아야 할 React UI 라이브러리" href="/post/2024-06-30-Must-KnowReactUILibrariesin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 반드시 알아야 할 React UI 라이브러리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 반드시 알아야 할 React UI 라이브러리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년 반드시 알아야 할 React UI 라이브러리</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Vite와 Create React App CRA 최신 비교 결정적인 한판 승부" href="/post/2024-06-30-VitevsCreateReactAppCRAAShowdown"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Vite와 Create React App CRA 최신 비교 결정적인 한판 승부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-VitevsCreateReactAppCRAAShowdown_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Vite와 Create React App CRA 최신 비교 결정적인 한판 승부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Vite와 Create React App CRA 최신 비교 결정적인 한판 승부</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시간 시리즈 확률 예측을 위한 Conformal Predictions 방법 완벽 가이드" href="/post/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시간 시리즈 확률 예측을 위한 Conformal Predictions 방법 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시간 시리즈 확률 예측을 위한 Conformal Predictions 방법 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">시간 시리즈 확률 예측을 위한 Conformal Predictions 방법 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Docker를 사용하여 GPU에서 Ollama를 로컬로 실행하는 방법" href="/post/2024-06-30-HowtorunOllamalocallyonGPUwithDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker를 사용하여 GPU에서 Ollama를 로컬로 실행하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-HowtorunOllamalocallyonGPUwithDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker를 사용하여 GPU에서 Ollama를 로컬로 실행하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Docker를 사용하여 GPU에서 Ollama를 로컬로 실행하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리" href="/post/2024-06-30-BestPythonLibrariesforCybersecurityin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-30-BestPythonLibrariesforCybersecurityin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리</strong><div class="PostList_meta__VCFLX"><span class="date">18 hours ago</span><span class="PostList_reading_time__6CBMQ">20<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link posts_-active__YVJEi" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Interceptor를 사용한 Nestjs 사용자 정의 API 응답 방법","description":"","date":"2024-06-30 22:30","slug":"2024-06-30-NestjsCustomAPIResponsewithInterceptor","content":"\n\n\u003cimg src=\"/assets/img/2024-06-30-NestjsCustomAPIResponsewithInterceptor_0.png\" /\u003e\n\n이전 미디엄 스토리(Nest.js 구조화된 API 응답)에서는 새로운 유형을 정의하고 class-validator 및 다국어 패키지와 호환성을 보장하여 API 응답 구조를 사용자 정의하는 방법을 탐색했습니다. 이 글에서는 인터셉터를 사용하여 사용자 지정 API 응답을 정의하는 방법에 대해 다룰 것입니다.\n\n# 인터셉터란?\n\n\u003cimg src=\"/assets/img/2024-06-30-NestjsCustomAPIResponsewithInterceptor_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nNestJS에서 interceptor는 컨트롤러에 도달하기 전에 요청을 변환하거나 클라이언트로 전송되기 전에 응답을 변환할 수 있는 미들웨어입니다. 이것은 로깅, 실행 시간 측정, 데이터 변환, 예외 처리, 인증 및 권한 관리에 사용됩니다. Interceptors는 응용 프로그램에 교차하는 관심사를 추가하는 유연한 방법을 제공합니다.\n\n# 커스텀 API 응답\n\nInterceptor를 사용하면 요청을 감싸고 처리되기 전후에 수정할 수 있습니다. 이 연습에서는 API 응답에 `timestamp`, `path`, `version` 등과 같은 추가 필드를 추가할 것입니다.\n\n# API 응답을 처리하기 위한 Interceptor 정의\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI 응답을 사용자 정의하는 인터셉터를 정의하는 방법을 안내해 드릴게요:\n\n1. 필요한 모듈과 데코레이터 가져오기:\n먼저 NestJS와 RxJS에서 필요한 모듈과 데코레이터를 가져오세요.\n\n```js\nimport { Injectable, NestInterceptor, ExecutionContext, CallHandler, HttpException } from '@nestjs/common';\nimport { Observable, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n```\n\n2. CustomResponseInterceptor 클래스 생성:\nCustomResponseInterceptor 클래스를 정의하고 NestInterceptor 인터페이스를 구현하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```typescript\n@Injectable()\nexport class CustomResponseInterceptor implements NestInterceptor {\n\n3. **`intercept` 메서드 구현**:\n`intercept` 메서드 내에서 요청과 응답 객체에 액세스합니다. 응답에서 상태 코드를 가져옵니다.\n\nintercept(context: ExecutionContext, next: CallHandler): Observable\u003cany\u003e {\n  const request = context.switchToHttp().getRequest();\n  const response = context.switchToHttp().getResponse();\n  const statusCode = response.statusCode;\n}\n\n4. 응답 및 오류 처리:\nRxJS를 사용하여 next.handle()의 결과를 처리합니다. 데이터를 사용자 정의 응답 형식으로 변환합니다. 사용자 지정 오류 응답을 생성하여 오류를 처리합니다.\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nreturn next.handle().pipe(\n   map(data =\u003e ({\n     statusCode,\n     message: statusCode \u003e= 400 ? 'Error' : 'Success',\n     error: statusCode \u003e= 400 ? response.message : null,\n     timestamp: Date.now(),\n     version: 'v2',\n     path: request.url,\n     data,\n   })),\n   catchError(err =\u003e {\n     const statusCode = err instanceof HttpException ? err.getStatus() : 500;\n     const errorResponse = {\n       statusCode,\n       message: err.message || 'Internal server error',\n       error: err.name || 'Error',\n       timestamp: Date.now(),\n       version: 'v2',\n       path: request.url,\n       data: {},\n     };\n     return throwError(() =\u003e new HttpException(errorResponse, statusCode));\n   })\n);\n}\n```\n\n# 전역적으로 인터셉터 적용하기\n\n이 인터셉터를 전역적으로 적용하려면 `main.ts` 파일에 추가하실 수 있습니다:\n\n1. 필요한 모듈과 인터셉터 가져오기:\n`@nestjs/core`에서 `NestFactory`를 가져오고 `CustomResponseInterceptor` 클래스를 가져옵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\nimport { CustomResponseInterceptor } from './common/interceptors/custom-response.interceptor';\n```\n\n2. NestJS 애플리케이션 생성:\nNestJS 애플리케이션을 생성하고 전역 인터셉터를 사용합니다.\n\n```js\nasync function bootstrap() {\n const app = await NestFactory.create(AppModule);\n app.useGlobalInterceptors(new CustomResponseInterceptor());\n await app.listen(3000);\n}\nbootstrap();\n```\n\n이 설정을 통해 NestJS 애플리케이션의 모든 API 응답이 인터셉터에서 정의된 사용자 정의 형식을 따르게 됩니다. 이러한 방식으로 응답을 구조화함으로써, 클라이언트가 사용할 일관되고 명확한 API 응답 형식을 제공할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-NestjsCustomAPIResponsewithInterceptor_0.png"},"coverImage":"/assets/img/2024-06-30-NestjsCustomAPIResponsewithInterceptor_0.png","tag":["Tech"],"readingTime":5},{"title":"자바스크립트 vs 타입스크립트 프론트엔드 기술 대전","description":"","date":"2024-06-30 22:28","slug":"2024-06-30-JavascriptvsTypescriptTheBattleofFrontendTechnologies","content":"\n\n이 두 가지 훌륭한 프런트엔드 기술 비교...\n\n![JavaScript vs TypeScript](/assets/img/2024-06-30-JavascriptvsTypescriptTheBattleofFrontendTechnologies_0.png)\n\n소개\n\n어떻게 동작하는지 항상 신기해하던 것들 중 하나인데, 프런트엔드 기술과 개발에 대해 배우기 시작하자 놀라움을 금치 못했습니다. 웹 사이트와 애플리케이션이 처음부터 거의 끝까지 어떻게 만들어지는지를 보게 되었어요. 이러한 웹 사이트와 애플리케이션은 정교하고 상호작용적이며 거의 화려하게 보이는데, 그들이 그 지점에 도달하기 전에는 그저 '본질적인 구조'일 뿐이었다는 걸 알면서도 여전히 놀랍습니다. 우리는 프런트엔드 기술을 살펴보고 그 중 두 가지 기술을 이해를 돕기 위해 대조해볼 것입니다. 그에 앞서:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n필요 사항\n\n다음 개념에 대한 지식이 있어야합니다:\n\n프런트엔드 기술이란 무엇인가요?\n\n프런트엔드 기술은 웹 애플리케이션이나 웹 사이트의 사용자 인터페이스(UI) 및 사용자 경험(UX)을 만드는 데 사용되는 도구, 프레임워크, 라이브러리 및 언어입니다. 이는 사용자가 웹 브라우저에서 직접 상호 작용하는 모든 것을 포함하며 레이아웃, 디자인, 그래픽, 텍스트 및 상호 작용 요소를 포함합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다양한 프론트엔드 기술들과 간단한 설명을 소개해 드립니다:\n\n## 언어\n\n- HTML (Hyper Text Markup Language): 웹의 가장 기본적인 구성 요소입니다. 웹 콘텐츠의 의미와 구조를 정의하는 마크업 언어입니다.\n- CSS (Cascading Style Sheets): 웹 페이지의 표현과 레이아웃을 설명하는 데 사용됩니다. 화면, 종이, 음성 또는 다른 미디어에서 요소나 콘텐츠가 어떻게 렌더링되어야 하는지 설명합니다.\n- JavaScript: 웹 응용 프로그램이나 웹 사이트에 상호 작용성을 추가하는 데 사용되는 프로그래밍 언어입니다.\n- TypeScript: JavaScript의 확장 문법으로, 언어에 정적 타이핑을 추가해 코드 품질과 유지보수성을 향상시킵니다.\n\n## 프레임워크와 라이브러리\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- React: 페이스북이 유지보수하는 사용자 인터페이스 구축을 위한 JavaScript 라이브러리입니다.\n- Angular: 구글이 유지보수하는 HTML 및 TypeScript를 사용하여 단일 페이지 클라이언트 애플리케이션을 구축하기 위한 플랫폼 및 프레임워크입니다.\n- Vue.js: 진보적인 JavaScript 프레임워크로 사용자 인터페이스 및 단일 페이지 애플리케이션을 구축하는 데 사용됩니다.\n- Svelte: 컴포넌트를 높은 효율의 명령적 코드로 컴파일하는 현대적인 JavaScript 프레임워크입니다.\n- Ember.js: 라우팅부터 상태 관리까지 모든 것을 제공하여 야심찬 웹 애플리케이션을 만드는 프레임워크입니다.\n- Backbone.js: 모델, 뷰, 컬렉션 및 라우터를 포함하여 웹 애플리케이션에 필요한 최소한의 구조를 제공하는 가벼운 JavaScript 라이브러리입니다.\n\n## CSS 전처리기 및 프레임워크\n\n- Sass (Syntactically Awesome Stylesheets): 변수, 중첩 규칙, 믹스인 등을 사용하여 스타일시트를 잘 구성하고 유지하기 쉽게 만드는 CSS 전처리기입니다.\n- Less: 변수, 믹스인, 함수 등과 같은 동적 동작을 추가하여 CSS를 확장하는 다른 CSS 전처리기입니다.\n- Bootstrap: 반응형 및 모바일 우선 웹 프로젝트를 만들기 위한 CSS 및 JavaScript 도구 모음을 제공하는 인기 있는 CSS 프레임워크입니다.\n- Tailwind CSS: 사용자 정의 인터페이스를 신속하게 구축하기 위한 유틸리티 중심의 CSS 프레임워크입니다.\n- Bulma: Flexbox를 기반으로 한 현대적인 CSS 프레임워크입니다.\n\n## 빌드 도구 및 모듈 번들러\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 웹팩(Webpack): 모듈 의존성을 가진 모듈을 가져와 해당 모듈을 나타내는 정적 자산을 생성하는 모듈 번들러입니다.\n- 걸프(Gulp): 미니파이, 컴파일 및 테스트와 같은 작업을 자동화하기 위해 Node.js 스트림을 사용하는 작업 실행기입니다.\n- 그런트(Grunt): 미니파이, 컴파일 및 린팅과 같은 반복적 작업을 자동화하는 JavaScript 작업 실행기입니다.\n- 파셀(Parcel): 빠르고 구성이 필요없는 웹 어플리케이션 번들러입니다.\n\n### 패키지 관리자\n\n- npm (Node Package Manager): Node.js의 기본 패키지 관리자로, JavaScript 패키지를 설치하고 관리하는 데 사용됩니다.\n- Yarn: 프로젝트 종속성을 관리하는 데 사용되는 프로젝트 관리자로 사용되는 패키지 관리자입니다.\n\n### 버전 관리\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Git: 소프트웨어 개발 중 소스 코드의 변경 사항을 추적하는 분산 버전 관리 시스템입니다.\n- GitHub: Git을 사용하여 버전 관리를 제공하고 개발자들을 위한 협업 환경을 제공하는 웹 기반 플랫폼입니다.\n\n## 테스트 도구\n\n- Jest: 단순성에 중점을 둔 즐거운 JavaScript 테스트 프레임워크입니다.\n- Mocha: Node.js에서 실행되는 JavaScript 테스트 프레임워크로 브라우저 지원, 비동기 테스팅 등을 제공합니다.\n- Chai: Node.js 및 브라우저용 BDD/TDD 어서션 라이브러리입니다.\n- Cypress: 최신 웹을 위해 만들어진 차세대 프론트 엔드 테스트 도구입니다.\n- Selenium: 웹 응용 프로그램을 테스트하는 휴대용 프레임워크입니다.\n\n## 코드 편집기 및 IDEs\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Visual Studio Code: Microsoft에서 개발한 무료 오픈소스 코드 편집기입니다.\n- Sublime Text: 코드, 마크업 및 산문을 위한 정교한 텍스트 편집기입니다.\n- Atom: GitHub에서 개발된 21세기용 텍스트 편집기입니다.\n- WebStorm: JetBrains에서 개발한 현대 JavaScript 개발용 강력한 IDE입니다.\n\n이러한 프론트엔드 기술을 이해하고 숙달하면 강력하고 상호작용이 가능하며 시각적으로 매력적인 웹 애플리케이션을 구축할 수 있는 능력이 크게 향상될 수 있습니다. 초보자로서는 항상 기본인 HTML, CSS 및 JavaScript부터 시작한 후 고급 프레임워크 및 도구로 넘어가는 것이 좋습니다. 더 나아가서, 우리는 Javascript와 Typescript의 차이에 대해 살펴볼 것입니다.\n\nJavascript 대 Typescript: 초보자를 위한 안내서\n\nJavaScript (JS) 및 TypeScript (TS)는 모두 프론트엔드 개발에 필수적인 기술입니다. 그들의 유사점과 차이를 이해하는 것은 강력하고 상호작용이 가능하며 시각적으로 매력적인 웹 애플리케이션 및 사이트를 구축하는 데 중요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바스크립트는 웹 개발에서 널리 사용되는 프로그래밍 언어로, 웹 브라우저 내에서 상호 작용하는 요소를 생성하는 데 사용됩니다. DOM을 조작하거나 이벤트를 처리하거나 애니메이션을 만들거나 서버로 비동기 요청(AJAX)을 보내는 데 사용됩니다. 자바스크립트는 동적으로 타입 지정되는 언어로, 변수 타입이 실행 시간에 결정됩니다. 이는 큰 유연성을 제공하지만 디버깅하기 어려운 오류를 발생시킬 수 있습니다. 예를 들어:\n\n```js\nlet message = \"Hello, world!\";\nconsole.log(message);\n```\n\n장점:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 보급성/모든 곳에서 활용 가능: JavaScript는 모든 최신 웹 브라우저에서 지원됩니다. 모든 최신 웹 브라우저에서 사용할 수 있습니다.\n- 커뮤니티: JavaScript는 많은 라이브러리와 프레임워크(예: React, Angular, Vue)를 갖춘 큰 커뮤니티를 보유하고 있습니다.\n- 다양성: JavaScript는 클라이언트 측 및 서버 측(Node.js) 프로그래밍에 모두 사용될 수 있습니다.\n\n단점:\n\n- 에러 발생 가능성: JavaScript는 동적으로 타입이 지정됩니다. 동적 타입 지정은 런타임 오류로 이어질 수 있습니다.\n- 복잡성: 프로젝트 규모가 커질수록, 적절한 구조와 훈련 없이 JavaScript 코드를 유지하는 것은 복잡해질 수 있습니다.\n\nTypescript이란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTypeScript은 JavaScript의 상위 집합으로 정적 유형 및 다른 기능을 추가합니다. 이것은 대규모 응용 프로그램을 개발하기 위해 설계되었으며 JavaScript로 변환됩니다. TypeScript는 정적 유형을 소개하여 개발자가 런타임이 아닌 컴파일 시간에 오류를 찾을 수 있게 합니다. 예를 들어:\n\n```js\nlet message: string = \"Hello, world!\";\nconsole.log(message);\n```\n\n장점:\n\n- 유형 안전성: 개발 중에 유형 관련 오류를 찾아 런타임 오류를 줄입니다.\n- 가독성: 유형 주석을 사용하여 코드의 가독성과 유지 관리성을 향상시킵니다.\n- 도구: 자동 완성, 리팩터링 및 탐색을 포함한 현대 IDE에 대한 더 나은 지원.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단점:\n\n- 학습 곡선: JavaScript에서 온 경우 새로운 개념을 배워야 합니다.\n- 컴파일: JavaScript로 컴파일해야 하므로 추가로 빌드 과정이 필요합니다.\n\n자바스크립트와 타입스크립트의 차이는 무엇인가요?\n\n## 타이핑\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJavaScript은 동적으로 타입이 지정되어 있어 변수의 데이터 타입이 실행 시간 중에 결정된다는 것을 의미합니다. 이 유연성은 때로 예상하지 못한 오류로 이어질 수 있습니다. 반면에 TypeScript은 정적으로 타입이 지정되어 있어 변수의 데이터 타입이 컴파일 시간에 결정되므로 TypeScript 코드는 더 안전하며 오류에 취약하지 않습니다. TypeScript는 때로 명시적인 타입 정의가 필요하거나 타입 추론을 사용합니다.\n\n```js\nlet count = \"5\"; // JavaScript-이 코드는 값을 숫자로 기대하지만 문자열로 전달됩니다. 하지만 JavaScript는 이를 문제없이 처리합니다. 올바른 코드입니다.\n```\n\n```js\nlet count: number = \"5\"; // TypeScript-타입이 숫자인데 문자열이 전달되어 오류가 발생합니다.\n```\n\n## 오류 확인과 처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJavaScript은 동적으로 타입이 지정되는 언어로 런타임 시에만 오류를 감지하여 디버깅이 어려울 수 있는 런타임 오류로 이어질 수 있습니다. TypeScript는 정적으로 타입이 지정되는 언어로 컴파일 시간에 오류를 잡아내므로 개발 주기 초기에 문제를 식별하고 해결하기 쉽습니다.\n\n## 컴파일\n\nJavaScript 코드는 사전 컴파일이 필요 없이 웹 브라우저나 Node.js에서 직접 실행됩니다. 반면에 TypeScript 코드는 실행되기 전에 JavaScript로 컴파일되어야 하며, 이로써 개발 프로세스에 추가 단계가 추가되지만 코드 신뢰성과 오류 확인이 강화됩니다.\n\nTooling\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n자바스크립트는 강력하지만 현대 개발에 필요한 모든 도구를 기본적으로 제공하지는 않습니다. 개발자들은 도구를 만들어 개발 프로세스를 개선해 왔습니다. TypeScript는 자동 완성, 더 나은 도구, 타입 확인 및 안전성, 향상된 코드 등 향상된 도구 기능을 제공합니다.\n\n개발 경험\n\n자바스크립트는 엄격한 규칙이 적어 빠르게 작성할 수 있으며 빠른 프로토타입 제작에 적합합니다. 반면 TypeScript는 초기에 더 많은 시간이 걸릴 수 있지만, 특히 대규모 애플리케이션의 경우 더 견고하고 유지보수가 쉬운 코드를 만들어줍니다.\n\n## 사용 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nJavaScript은 빠른 프로토타이핑에 좋습니다. 즉, 아이디어를 빨리 테스트하고 작은 애플리케이션을 만들어야 할 때 유용합니다. 간단하고 유연한 구조 덕분에 소형부터 중형 프로젝트에 잘 어울립니다. 반면에 TypeScript는 대규모 프로젝트에 사용됩니다. TypeScript는 유지 관리 및 가독성이 중요한 대규모 코드베이스에서 사용됩니다. 또한 팀 프로젝트나 팀에서 작업할 때 일관된 코드 품질을 보장하고 타입 관련 버그를 방지하는 데 사용됩니다. Angular와 같은 현대적인 프레임워크들이 TypeScript를 사용하며, 사용하면 개발 경험을 향상시킬 수 있습니다.\n\n![이미지](/assets/img/2024-06-30-JavascriptvsTypescriptTheBattleofFrontendTechnologies_1.png)\n\n## HNG와의 나의 여정...\n\nHNG에서는 React가 프레임워크(프론트엔드 기술)로 널리 사용됩니다. React는 빠르고 상호작용 가능한 사용자 인터페이스를 구축하는 데 사용되는 JavaScript 프레임워크로, 효율적이고 유연합니다. React를 다른 기술과 프레임워크와 통합할 수 있는 능력 덕분에 단순한 웹 애플리케이션부터 복잡한 애플리케이션까지 다양한 영역에 적응할 수 있습니다. Facebook에서 2011년에 처음 개발되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## HNG이란 무엇인가요?\n\nHNG는 소프트웨어 개발 분야에서 젊은 이들을 교육하는 글로벌 인턴십 프로그램입니다. 참가자들은 실제 프로젝트를 맡아 작업하고 산업 전문가들에게 멘토링을 받습니다.\n\n## HNG 인턴십 프로그램은 어떻게 작동하나요?\n\nHNG와의 첫 경험이며 저는 도전할 기회가 주어져 기쁩니다. 동시에 흥분되고 두려운 기회이기도 합니다. React에 대해 조금은 낯설지만 몇 가지 프로젝트를 완료했습니다. React의 약간의 지식을 활용해 HNG의 성장에 작은 기여를 할 것이고 동시에 React 스킬을 향상시킬 계획입니다. 팀의 일원이 되고 활발히 참여하며 다른 이들과 협력하고 기존 지식과 기술을 향상시키는 등 많은 것들을 기대하고 있습니다. HNG 인턴십이 어떻게 작동하는지 자세히 알아보려면 HNG 인턴십과 HNG Hire를 방문해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n요약하자면, 대부분의 경우 선택을 해야 하는 상황이 많이 발생합니다. Angular와 Vue, Visual Studio Code와 Sublime Text, 그리고 JavaScript와 TypeScript 등 선택해야 할 대상들이 많습니다. 제가 다음으로 이야기하려는 것이 여러분의 궁금증 중 하나를 해결해줄 것이라고 기대합니다. JavaScript와 TypeScript는 둘 다 웹 개발에서 자리를 가지고 있습니다. JavaScript는 간결하고 유연한 특성으로 인해 작은 프로젝트와 빠른 프로토타이핑에 이상적입니다. 한편 TypeScript는 정적 타이핑과 향상된 도구를 통해 대규모이고 복잡한 프로젝트 및 팀 환경에 더 적합합니다. 초보자로서 JavaScript로 시작하면 견고한 기반을 다질 수 있고, TypeScript를 배우면 더욱 신뢰성 있고 유지보수가 쉬운 코드 작성으로 자연스럽게 발전할 수 있습니다. 이 답변이 여러분의 질문에 해답이 되길 바라며, JavaScript와 TypeScript 모두를 활용해 보시겠습니까?","ogImage":{"url":"/assets/img/2024-06-30-JavascriptvsTypescriptTheBattleofFrontendTechnologies_0.png"},"coverImage":"/assets/img/2024-06-30-JavascriptvsTypescriptTheBattleofFrontendTechnologies_0.png","tag":["Tech"],"readingTime":12},{"title":"Angular-React 하이브리드 기법 두 기술의 장점 모음","description":"","date":"2024-06-30 22:27","slug":"2024-06-30-BestofBothWorldsAngular-ReactHybridPractices","content":"\n\n![이미지](/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png) \n\n지금까지 프론트엔드 개발자들 사이에서 Angular가 React보다 더 나은지 아니면 그 반대인지에 대한 논쟁이 있었습니다. React 개발자로서 몇 년 동안 내가 옳은 쪽에 있다고 확신하고 있던 중에, 상황이 나를 Angular를 배우도록 강요했죠. 처음에는 정말 어색했고 그 개념들을 비판하기 시작했지만, 몇 주간의 학습 후에 드디어 그것에 익숙해졌습니다. 시간이 지나고 더 많은 지식을 쌓으면서 확신 있는 Angular 개발자가 되었고, 이제 \"어떤 프레임워크가 더 나은가\"라는 질문에 답할 수 있을 것 같지만, 더 깊이 배우면 배울수록 이 두 독특한 도구를 비교하는 것이 더 어려워집니다. 그러나 이 글의 목적은 이들을 비교하는 것이 아니라 한 프레임워크에서 채택한 실천법을 다른 프레임워크로 재사용하는 경험을 공유하는 것입니다.\n\n# HTML 템플릿\n\nReact의 컴포넌트는 JSX와 함께 논리가 섞여있어서 매우 엉망이 될 수 있다는 일반적인 불만이 있습니다. 컴포넌트가 커지면, 코드를 읽으려는 누군가에게 덜 이해하기 쉬워집니다. 이것은 Angular 지지자들이 논쟁에서 사용하는 주장 중 하나입니다. 정확한가요? 음, 부분적으로 맞습니다. React는 Angular와 달리 특정한 범위와 규칙을 부과하지 않고 원하는 대로 코드를 작성할 수 있게 해줍니다. 때로는 React의 이 자유가 엉망으로 이어질 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n구글 프레임워크를 몇 년 동안 사용한 후에 그 방식에 적응되었고 심지어 그 방식에 대한 동정심까지 키웠어요. 그래서 생각했죠: ‘왜 리액트에서도 똑같은 작업을 할 수 없을까?’ 답은 간단해요: ‘할 수 있어요.’ 이를 실현하기 위해선 우리의 리액트 컴포넌트를 두 개의 파일로 분리하는 규칙을 따르면 돼요. 템플릿과 로직을 각각의 파일에 위치시켜야 해요. 아래의 예시처럼 말이죠.”\n\n```js\n// MyComponent.jsx\n\nimport { useState } from \"react\"\nimport { MyComponentTemplate } from \"./my.component.template\";\n\nexport const MyComponent = () =\u003e {\n    const [count, setCount] = useState(0);\n\n    const decrement = () =\u003e {\n        setCount(count - 1);\n    }\n\n    const increment = () =\u003e {\n        setCount(count + 1);\n    }\n\n    return \u003cMyComponentTemplate increment={increment} decrement={decrement} count={count}\u003e\u003c/MyComponentTemplate\u003e\n}\n```\n\n```js\n// MyComponent.template.jsx\n\nexport const MyComponentTemplate = ({amount, increment, decrement}) =\u003e {\n    return \u003c\u003e\n        \u003ch1\u003e\n            {amount}\n        \u003c/h1\u003e\n        \u003cbutton onClick={increment}\u003e + \u003c/button\u003e\n        \u003cbutton onClick={decrement}\u003e - \u003c/button\u003e\n    \u003c/\u003e\n}\n```\n\n그리고 여기까지입니다. 어떻게 생각하시나요? :)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 의존성 주입\n\n의존성 주입은 Angular에서 채택된 주요 디자인 패턴 중 하나입니다. 느슨한 결합 및 관심사 분리를 촉진하여 모듈화, 유지 관리성, 테스트 용이성을 향상시킵니다. 서비스는 비즈니스 로직과 UI 구성 요소를 분리하는 훌륭한 방법을 제공합니다. 데이터 가져오기, 상태 관리 또는 기타 작업과 관련된 기능을 캡슐화함으로써 서비스는 구성 요소를 깔끔하고 집중시킵니다. 서비스는 다른 프레임워크에서 잘 작동하지만 React에서는 자연스럽지 않을 수 있습니다. React의 컴포넌트 중심 접근 방식은 종종 개발자가 로직을 직접 처리하도록 유도합니다. 과제는 컴포넌트 간의 간단함과 로직 분리 사이의 적절한 균형을 찾는 데 있습니다. React의 Context API가 해결책을 제공합니다. Context를 생성함으로써 종속성을 명시적으로 props를 통해 전달하지 않고 컴포넌트 트리 전체에서 공유할 수 있습니다.\n\n```js\n// ContextProvider.jsx\nimport { MyService} from '@services/myService';\n\nexport const MyServiceInstance = createContext({});\n\nexport const MyServiceProvider= ({ children }) =\u003e {\n  return \u003cMyServiceInstance.Provider value={new MyService()}\u003e{children}\n         \u003c/MyServiceInstance.Provider\u003e;\n};\n```\n\n```js\n// App.jsx\n\nexport const App = () =\u003e {\n  return (   \n    \u003cMyServiceProvider\u003e\n      // ...내 앱 콘텐츠\n    \u003c/MyServiceProvider\u003e \n  );\n}\n  \n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// MyComponent.jsx\n\nconst MyComponent= () =\u003e { \n  const [data, setData] = useState(null);\n  const myService = useContext(MyServiceInstance);\n  \n  useEffect(() =\u003e {\n    if(myService) getData();\n  }, [myService])\n\n  const getData = () =\u003e {\n    myService.getData().then(res =\u003e setData(res));\n  }\n\n  return \u003cMyComponentTemplate data={data} /\u003e\n}\n```\n\n# 타입스크립트\n\n이게 꽤 명백한 것 같아요. 그러나 저는 종종 타입스크립트를 사용하지 않는 React 프로젝트를 만납니다. 그렇게 되면 Angular 개발자들이 React 앱이 엉망이라고 불평하는 이유가 하나 더 생기게 되는데, 저는 완전히 동의해요. 타입스크립트는 코드를 더 안전하고 이해하기 쉬운 방법을 제공합니다.\n\n# 프로미스 또는 옵저버블?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 질문을 여러 번 받아봤어요. Angular는 React가 프로미스를 사용하는 용도로 사용하는 것과 같은 목적을 위해 옵저버블을 사용하지만, 저는 이 두 도구를 비교하는 대신 둘 다 사용할 수 있다고 생각해요. 둘 다 장단점이 있지만, 각 도구가 만들어진 목적에 맞게 사용하면 개발 시간과 경험을 향상시킬 수 있을 거예요.\n\nReact는 프로미스 기반이라는 사실은 알려진 사실이에요. Angular는 옵저버블 기반이죠. 두 도구를 함께 사용할 때 마주치는 문제 중 하나는 때로는 프로미스를 반드시 사용해야 할 때에도 Angular가 옵저버블을 사용하도록 강요하고, 한 번 호출할 메소드에 불필요한 구독을 생성해야 한다는 것이었어요. 그 말인 즉슨 구독을 해제해야 한다는 것이죠. 이것은 너무 많은 보일러플레이트 코드라고 제 생각에는요. 반면에 React 코드에서는 옵저버블을 자주 사용하지 않는데, 대신에 해결책을 만들어내고, 여러 \"useEffect\" 훅을 사용하다 보면 엉망이 될 수도 있어요. \"useEffect\"는 아주 유용한 도구이지만 때로는 옵저버블이 필요할 수도 있어요. RxJs는 Angular 애플리케이션에서 일반적으로 사용되는 강력한 라이브러리이며, React와도 잘 어울린다고 해요.\n\n```js\n// MyService.ts 조각\nexport class MyService {\n  isReady = new BehaviorSubject\u003cboolean\u003e(false);\n    \n  constructor() {\n    this.connectToSocket();\n  }\n\n  private connectToSocket = () =\u003e {\n    this.socket.connect().subscribe((message) =\u003e {\n      if(message.status === 'READY') {\n        this.isReady.next(true);\n      }\n    })\n  }\n}\n```\n\n```js\n// MyComponent.tsx 조각\n\nconst myService= useContext(MyServiceInstance);  \n\nuseEffect(() =\u003e {\n  const subscription = myService.isReady.subscribe((isReady: boolean) =\u003e {\n    if (isReady) {\n      // ...할 일\n    }\n  });\n\n  return () =\u003e subscription.unsubscribe();\n}, [myService]);\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n소프트웨어 개발은 문제를 다양한 방법으로 해결할 수 있는 풍부한 세계입니다. 어떤 방법을 선택할지는 당신의 몫입니다. 이 글에서는 내게 잘 작용한 방법을 공유했고, 누군가에게 유용할 수도 있다고 생각했습니다. React와 Angular를 비교하는 것은 그리 의미가 없습니다. 둘 다 놀라울 정도로 좋으니까요. 다음에 누군가가 어떤 것이 더 나은지 물어보면, '둘 다!' 라고 대답할 거예요. 여러분은 어떠세요?","ogImage":{"url":"/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png"},"coverImage":"/assets/img/2024-06-30-BestofBothWorldsAngular-ReactHybridPractices_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 이란 대통령 선거 결정적 순간","description":"","date":"2024-06-30 22:26","slug":"2024-06-30-IranianPresidentialElection2024ADefiningMoment","content":"\n\n\n![이미지](/assets/img/2024-06-30-IranianPresidentialElection2024ADefiningMoment_0.png)\n\n2024 년 6 월 예정 된 이란 대통령 선거는 이 나라의 정치적 여정에서 중요한 사건입니다. 대통령 에브라힘 라이시의 임기가 끝나가는 가운데 이란은 경제적 문제, 국제적 압력 및 개혁 요구 사항 사이에서 중요한 선택을 직면하고 있습니다.\n\n다양한 정치 성향을 가진 주요 후보들이 대통령직을 놓고 경쟁하고 있습니다.\n\n개혁주의자들은 더 큰 개방과 서구 및 국제 공간에서의 참여를 촉구하여 핵 합의를 재개하고 경제 제재를 완화하는 것을 목표로 하고 있습니다. 반면에 반대파는 나라의 안보 및 경제 안정이 전통 가치의 유지보다 중요하다고 주장하며 외국의 영향을 저항하고 있습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n대중의 기분은 혼합된 감정 중 하나로, 경제 문제, 인플레이션 및 실업에 대한 엄청난 불만이 있습니다. 특히 현재 선거에서 참여율이 감소하고 있는 것은 정치 체제에 대한 불만이 점점 더 크다는 것을 보여줍니다.\n\n국제 사회는 이번 선거가 지역 안정과 국제 외교에 미치는 영향 때문에 주목하고 있습니다.\n\n결과는 이란의 핵 프로그램, 이웃국가와의 관계, 지역 갈등에 대한 참여와 같은 중요한 주제에 대한 이란의 정책을 결정할 것입니다.\n\n선거일이 다가올수록 후보들은 각종 유권자들의 걱정에 대응하기 위해 캠페인을 강화하고 있습니다. 2024년 선거는 이란에 있어 중요한 전환점이며 미국의 미래 궤적과 국제 무대에서의 위치에 영향을 줄 수 있는 중요한 선거입니다.","ogImage":{"url":"/assets/img/2024-06-30-IranianPresidentialElection2024ADefiningMoment_0.png"},"coverImage":"/assets/img/2024-06-30-IranianPresidentialElection2024ADefiningMoment_0.png","tag":["Tech"],"readingTime":2},{"title":"Flutter가 React Native를 대체할 것인가","description":"","date":"2024-06-30 22:26","slug":"2024-06-30-IsFluttergoingtoreplaceReactNative","content":"\n\n\n![Image](/assets/img/2024-06-30-IsFluttergoingtoreplaceReactNative_0.png)\n\n# Flutter이 React Native을 대체할까요?\n\n## 소개\n\nFlutter와 React Native과 같은 크로스 플랫폼 프레임워크에 의해 휴대폰 앱 개발 환경은 상당히 변화되었습니다. 두 프레임워크는 iOS 및 Android 플랫폼에서 고품질 어플리케이션을 개발하고 개발 프로세스를 간소화하는 능력으로 인해 엄청난 인기를 얻었습니다. 그러나 개발자 커뮤니티에서 가장 중요한 질문은 Flutter가 빠른 발전과 점점 더 많은 사용으로 React Native을 결국 대체할 것인지에 대한 문제입니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 주요 기능 및 이점\n\n![이미지](/assets/img/2024-06-30-IsFluttergoingtoreplaceReactNative_1.png)\n\n## Flutter\n\n- 표현력 있고 유연한 UI: Flutter는 풍부한 사용자 정의 가능한 위젯 세트를 제공하여 매우 상호 작용적이고 시각적으로 매력적인 사용자 인터페이스를 구현할 수 있습니다.\n- 핫 리로드: 응용 프로그램을 다시 시작하지 않고 코드 변경 사항을 실시간으로 볼 수 있어 개발 프로세스를 크게 가속화합니다.\n- 뛰어난 성능: Flutter 앱은 네이티브 코드로 컴파일되어 부드러운 성능과 빠른 실행이 보장됩니다.\n- 단일 코드베이스: iOS 및 Android 모두를 위한 하나의 코드베이스를 작성할 수 있어 개발 시간과 비용을 절감할 수 있습니다.\n- 강력한 커뮤니티 지원: Google의 후원을 받는 Flutter는 강력하고 성장 중인 커뮤니티를 자랑하여 폭넓은 자원과 지원을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-30-IsFluttergoingtoreplaceReactNative_2.png\" /\u003e\n\n## React Native\n\n- 크로스 플랫폼 개발: React Native은 개발자들이 단일 JavaScript 코드베이스를 사용하여 iOS 및 Android용 앱을 개발할 수 있도록 합니다.\n- 핫 리로드: Flutter와 유사하게, React Native은 핫 리로드를 제공하여 개발 속도와 효율성을 향상시킵니다.\n- 재사용 가능한 컴포넌트: 응축된 컴포넌트를 생성하고 애플리케이션 전체에서 재사용할 수 있도록 권장하여 코드 유지 관리성을 촉진합니다.\n- 네이티브 모듈: 앱의 성능에 중요한 부분에 대한 네이티브 모듈에 액세스할 수 있어 최적의 성능을 보장합니다.\n- 거대한 생태계와 커뮤니티: Facebook 및 방대한 개발자 커뮤니티가 지원하며, React Native은 다양한 라이브러리와 도구로 풍부한 생태계를 갖고 있습니다.\n\n## 성능 비교\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플러터는 Dart를 사용하며 네이티브 코드로 미리 컴파일되는 것으로 인해 다양한 시나리오에서 성능 우위를 갖습니다. 플러터에서 사용되는 Skia 그래픽 엔진은 부드러운 애니메이션과 빠른 렌더링을 제공합니다. 리액트 네이티브는 강력한 성능을 제공하지만 자바스크립트와 네이티브 코드 사이의 브릿지를 사용하므로 복잡한 애플리케이션에서 지연이 발생할 수 있습니다. 그러나 리액트 네이티브는 네이티브 모듈을 사용할 수 있는 능력이 성능 문제를 해소하는 데 도움이 됩니다.\n\n# 개발 경험\n\n## 플러터:\n\n포괄적인 문서, 직관적인 개발 도구 및 강력한 IDE 지원으로 유명합니다. 위젯 기반 아키텍처는 UI 디자인 및 사용자 정의를 간단하게 만들어 복잡한 인터페이스를 개발자가 쉽게 생성할 수 있도록 도와줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## React Native:\n\nJavaScript과 React에 친숙한 지식을 활용하여, React Native은 모바일 개발로 전환하는 웹 개발자들에게 부드러운 학습 곡선을 제공합니다. 다양한 라이브러리 생태계와 강력한 커뮤니티 지원을 통해 솔루션을 찾고 써드 파티 플러그인을 통합하는 것이 더욱 용이해집니다.\n\n# 커뮤니티와 생태계\n\n## Flutter:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n플러터 커뮤니티는 구글의 강력한 지원을 받으며 빠르게 성장하고 있어요. 플러터 생태계에 있는 플러그인, 패키지, 도구의 숫자가 늘어나면서 개발과 통합이 더욱 용이해지고 있어요.\n\n## 리액트 네이티브:\n\n시장에 오랜 기간 존재하며, 리액트 네이티브는 성숙한 생태계와 거대하고 활발한 커뮤니티를 자랑하고 있어요. 주요 기업들이 이 프레임워크를 널리 채택함으로써 지속적으로 기여하고 향상시키고 있죠.\n\n## 산업 채택\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n유명 기업들이 사용하는 두 프레임워크는 신뢰성과 다재다능성을 보여줍니다. 구글, 알리바바, BMW 등이 Flutter를 활용하고 있으며, Facebook, Instagram, Tesla 등이 React Native를 통해 어플리케이션을 구동하고 있습니다. 두 프레임워크 중 어떤 것을 선택할지는 주로 특정 프로젝트 요구사항, 팀의 전문성, 장기 유지보수 고려 등에 달렸습니다.\n\n## 결론\n\nFlutter의 빠르게 성장하고 견고한 기능들은 이를 획기적인 크로스 플랫폼 개발 도구로 만들었지만, React Native의 확립된 생태계와 산업에서의 널리 퍼진 채택으로 인해 강력한 경쟁자로 자리 잡았습니다. Flutter가 React Native를 대체할지 여부는 명확하지 않으며, 결국 개발자 커뮤니티의 변화하는 요구사항과 두 프레임워크의 지속적인 혁신에 따라 달라집니다. 현재로서는, Flutter와 React Native 모두 크로스 플랫폼 모바일 개발을 위한 유효하고 가치 있는 옵션이 됩니다.\n\n이 블로그에서는 Flutter와 React Native의 특징, 성능, 커뮤니티 지원, 산업 채택 등을 탐구해 보았습니다. Flutter가 React Native를 대체할지 여부는 아직 알 수 없지만, 두 프레임워크 모두 2024년 이후의 모바일 개발자들에게 상당한 장점을 제공할 것으로 기대됩니다.","ogImage":{"url":"/assets/img/2024-06-30-IsFluttergoingtoreplaceReactNative_0.png"},"coverImage":"/assets/img/2024-06-30-IsFluttergoingtoreplaceReactNative_0.png","tag":["Tech"],"readingTime":5},{"title":"2024년 반드시 알아야 할 React UI 라이브러리","description":"","date":"2024-06-30 22:24","slug":"2024-06-30-Must-KnowReactUILibrariesin2024","content":"\n\n\n![이미지](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_0.png)\n\n# 1. Material UI\n\nMaterial-UI\n\n![이미지](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_1.png)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMaterial-UI는 구글의 Material Design 가이드라인을 따르는 인기 있는 React 컴포넌트 라이브러리로 전해졌던 Material UI입니다. 약 90.8k 개의 GitHub 스타와 매주 290만 번 다운로드되는 NPM을 통해, Material-UI는 다양한 구성 요소, 사용자 정의 가능한 테마 및 강력한 기능을 제공합니다. 간단한 앱 또는 복잡한 대시보드를 구축하고 있다면, Material-UI가 모든 것을 다룰 것입니다.\n\n주요 기능:\n\n- 풍부한 컴포넌트 라이브러리\n- 테마 지원\n- 반응형 디자인\n- 접근성 초점\n\n# 2. Ant Design\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 안트 디자인\n\n![이미지](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_2.png)\n\n안트 디자인은 기업급 응용 프로그램을 만드는 데 널리 사용됩니다. 테이블, 폼, 모달 등 다양한 컴포넌트를 제공합니다. GitHub에서 약 89.4k개의 스타를 받았고 매주 약 110만회의 NPM 다운로드를 기록하며 안정적이고 검증된 안트 디자인입니다.\n\n주요 기능:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- CSS-in-JS 기술\n- 동적 테마\n- 기업 친화적인 컴포넌트\n\n## 3. Shadcn UI\n\nShadcn UI\n\n![이미지](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nShadcn UI는 잘 알려지지 않았지만 주목할 가치가 있어요. Radix UI와 Tailwind CSS를 사용하여 만들어진 이 라이브러리는 아름답게 디자인된 컴포넌트를 제공해요. 매주 NPM 다운로드 수는 알 수 없지만, 49.2k의 GitHub 스타는 점점 인기가 높아지고 있다는 것을 보여줍니다.\n\n주요 기능:\n\n- 다양한 컴포넌트 세트\n- Tailwind CSS 통합\n- 현대적인 디자인\n\n# 4. Aceternity UI\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAceternity UI\n\n![Aceternity UI](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_4.png)\n\nAceternity UI는 상호작용 가능한 React JS 컴포넌트의 보물창고입니다. 왜 이렇게 주목받고 있는지 알아봅시다. Aceternity UI를 무료로 제공해준 @mannupaaji 창조자에게 감사드립니다. UI 게임을 향상시키려는 개발자들에게 뛰어난 자원이 될 것입니다.\n\n- 멋진 효과\n- 매끄러운 통합\n- 무료이자 훌륭함\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 5. NEXT UI\n\nNextUI\n\n![NextUI](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_5.png)\n\nNextUI은 React를 위한 UI 라이브러리로, TailwindCSS의 강력함을 React Aria와 결합하여 접근 가능하고 사용자 정의 가능한 완전한 컴포넌트(로직 및 스타일)를 제공합니다. NextUI는 TailwindCSS를 스타일 엔진으로 사용하기 때문에 NextUI 컴포넌트 내에서 모든 TailwindCSS 클래스를 사용할 수 있으며, 최적의 컴파일된 CSS 크기를 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 멋진 효과\n- 완벽한 통합\n- 무료이며 훌륭합니다\n\n# 6. Radix UI\n\nRadix UI\n\n![이미지](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nRadix UI는 빠른 개발, 쉬운 유지 보수 및 접근성을 위해 최적화된 오픈 소스 컴포넌트 라이브러리입니다. 약 13.5k의 GitHub 스타와 매주 130만 회의 NPM 다운로드를 자랑합니다. 설정이 필요 없어 바로 가져와 사용할 수 있어 개발자들이 빠르게 해당 컴포넌트를 프로젝트에 통합할 수 있습니다.\n\n주요 기능:\n- 사용자 정의 테마\n- 미리 스타일이 적용된 컴포넌트\n- 최소한의 구성\n\n# 7. Headless UI\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nHeadless UI\n\n![Headless UI](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_7.png)\n\nHeadless UI는 웹 개발의 현대적 트렌드입니다. 전통적인 CSS-in-JS 라이브러리와는 달리, 특정 시각적 스타일을 규정하지 않고 UI 구성 요소에 대한 기본 로직과 기능을 제공하는 데 초점을 맞추고 있습니다. 약 23.6k개의 GitHub 스타와 매주 130만 개의 NPM 다운로드로, Headless UI는 UI 생성에 대한 깔끔한 기반을 제공합니다.\n\n- 스타일이 없고 접근성이 좋음\n- 꼼꼼하게 제작된 요소\n- 통합할 준비가 된 컴포넌트\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 8. React Aria\n\nReact Aria\n\n![Image](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_8.png)\n\nReact Aria는 디자인 시스템을 위한 접근성 있는 UI 기본 요소를 제공하는 React Hooks 라이브러리입니다. 내장된 동작, 접근성 및 국제화를 갖춘 40개 이상의 컴포넌트를 포함하고 있습니다. 이러한 컴포넌트는 사용자 정의 스타일링에 적합하며, 화면 판독기 지원, 키보드 제어 및 포커스 처리와 같은 기능을 통해 사용자 경험을 향상시킵니다. 약 11.1천 개의 GitHub 스타와 주간 232천 개의 NPM 다운로드를 갖고 있는 Headless UI는 UI 작성을 위한 깔끔한 기반을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n기능:\n\n- 커스텀 스타일링\n- 특히 기능들이 강력함\n\n# 9. Chakra UI\n\nChakra UI\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Chakra UI](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_9.png)\n\nChakra UI는 개발자 경험과 접근성에 중점을 둡니다. 밝은/어두운 테마를 갖춘 간단하고 모듈식 컴포넌트 라이브러리를 제공합니다. 약 36k개의 GitHub 스타와 주간 457k개의 NPM 다운로드로, Chakra UI는 주목 받고 있습니다.\n\n주요 기능:\n\n- 접근 가능한 컴포넌트\n- 테마 지원\n- 개발자 친화적 API\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 10. 맨타인\n\n맨타인\n\n![이미지](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_10.png)\n\n맨타인은 100개 이상의 사용자 정의 가능한 컴포넌트와 50가지 후크를 갖춘 가벼운 라이브러리입니다. 속도와 개발자 생산성을 강조합니다. 약 23.5k의 GitHub 스타와 매주 25.7k의 NPM 다운로드를 기록하며, 맨타인은 발견할 가치가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n주요 기능:\n\n- 커스터마이즈 가능한 구성 요소\n- 일반적인 사용 사례를 위한 훅\n- 개발자 친화적인 문서\n\n# 11. 리액트 부트스트랩\n\n리액트 부트스트랩\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_11.png)\n\nReact Bootstrap은 Bootstrap JavaScript를 React 컴포넌트로 대체하여 jQuery와 같은 불필요한 종속성을 없애줍니다. 초기의 React 라이브러리 중 하나인 React Bootstrap은 React와 함께 성장하여 신뢰할 만한 선택지로 자리 잡았습니다. 현대 웹 애플리케이션을 구축하기 위한 반응형 및 사용자 정의 가능한 컴포넌트를 제공합니다.\n\n주요 기능:\n\n- 핵심에 Bootstrap 사용\n- 기본적으로 접근성 지원\n- 반응형 및 사용자 정의 가능한 컴포넌트\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 12. Semantic UI\n\nSemantic UI\n\n![Semantic UI](/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_12.png)\n\nSemantic UI React는 인기 있는 Semantic UI 프레임워크를 React로 이식한 것입니다. 이는 시멘틱 클래스 이름을 가진 다양한 컴포넌트를 제공하여 시각적으로 매력적인 인터페이스를 쉽게 만들 수 있습니다. 버튼, 폼 또는 모달이 필요한 경우 Semantic UI React는 포괄적인 컴포넌트 세트를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n키 특징:\n\n- 간결한 HTML\n- 직관적인 JavaScript\n\n이러한 라이브러리를 더 탐구하고, 문서를 읽고, 프로젝트 요구 사항과 일치하는 것을 선택하는 것을 잊지 마세요. 즐거운 코딩하세요! 🚀\n\n# Stackademic 🎓\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n끝까지 읽어주셔서 감사합니다. 마지막으로:\n\n- 작가를 클랩하고 팔로우해주시면 감사하겠습니다! 👏\n- X와 함께 팔로우하기 | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- Stackademic.com에서 더 많은 콘텐츠를 만나보세요.","ogImage":{"url":"/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_0.png"},"coverImage":"/assets/img/2024-06-30-Must-KnowReactUILibrariesin2024_0.png","tag":["Tech"],"readingTime":10},{"title":"Vite와 Create React App CRA 최신 비교 결정적인 한판 승부","description":"","date":"2024-06-30 22:23","slug":"2024-06-30-VitevsCreateReactAppCRAAShowdown","content":"\n\n\u003cimg src=\"/assets/img/2024-06-30-VitevsCreateReactAppCRAAShowdown_0.png\" /\u003e\n\n🚀 Vite: The Speedster\n\n- Build Tool: Vite는 내부 빌드 도구인 esbuild를 사용합니다. 이로 인해 개발 중에 매우 빠른 속도를 제공합니다.\n- 성능: Vite를 번들러 중의 Usain Bolt로 생각해보세요 - 프로젝트가 성장해도 속도를 유지합니다.\n- 모듈 지원: Vite는 네이티브 ES 모듈(ESM)을 완전히 수용하여 미래지향적인 선택입니다.\n- 빌드 명령어: Vite 프로젝트를 빌드하려면 다음을 사용하십시오:\n\n```js\nnpm run build //\nnpx vite build\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 명령 실행: 로컬 개발 서버를 다음과 같이 시작하세요:\n\n```js\nnpm run dev //\nnpx vite\n```\n\n. 로컬호스트: Vite는 여러분의 앱을 다음 주소에서 제공합니다.\n\n```js\nhttp://localhost:5173\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n🎨 React 앱 만들기 (CRA): 확실한 동반자\n\n- 빌드 도구: Create React App은 Webpack에 의존하며 강력하고 널리 사용되는 번들러입니다.\n- 성능: CRA는 신뢰할 수 있는 짝처럼 작동하지만 앱이 커질수록 약간 버틸 수 없을 수도 있습니다.\n- 모듈 지원: CRA는 순수 JavaScript 및 ES 모듈에 제한이 있습니다.\n- 빌드 명령: CRA 프로젝트를 빌드하려면 다음을 사용하십시오:\n\n```js\nnpm run build\n```\n\n- 실행 명령: 로컬 개발 서버를 시작하려면:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nnpm start // npm run start\n```\n\n- Localhost: Vite가 앱을 제공하는 곳\n\n```js\nhttp://localhost3000\n```\n\n🤔 어떤 것을 선택할까요?\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 더 빠른 개발과 성능 향상을 향해 달리고 있다면, Vite는 여러분의 트랙 스타입니다. 하지만 CRA를 무시하지 마세요 — 이는 작업을 완료하는 믿을 수 있는 수행원입니다.\n\n기억하세요, 최적의 선택은 여러분의 특정 프로젝트 요구사항에 따라 다릅니다. 즐거운 번들링되길 바래요! 🚀","ogImage":{"url":"/assets/img/2024-06-30-VitevsCreateReactAppCRAAShowdown_0.png"},"coverImage":"/assets/img/2024-06-30-VitevsCreateReactAppCRAAShowdown_0.png","tag":["Tech"],"readingTime":3},{"title":"시간 시리즈 확률 예측을 위한 Conformal Predictions 방법 완벽 가이드","description":"","date":"2024-06-30 22:21","slug":"2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting","content":"\n\n\u003cimg src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_0.png\" /\u003e\n\n샘플 eBook 챕터(무료): [여기](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\nTeachable.com에서의 eBook: $22.50 [여기](https://drdataman.teachable.com/p/home)\n\nAmazon.com에서의 인쇄판: $65 [여기](https://a.co/d/25FVsMx)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 세계 응용 프로그램 및 계획에는 포인트 추정이 아닌 확률적 예측이 필요합니다. 확률적 예측 또는 예측 불확실성이라고도 하는 확률적 예측은 계획자에게 불확실성의 감을 줄 수 있습니다. 그러나 선형 회귀, 랜덤 예측 또는 그래디언트 부스팅 머신과 같은 전형적인 기계 학습 모델은 가능한 값의 범위가 아닌 평균 추정을 생성하도록 설계되었습니다. 이 책이 관심을 갖는 것은 점 추정에서 예측 구간으로 발전하는 과정이며, 현대의 시계열 모델링 기술이 이에 관심을 가지고 있습니다. 확률적 예측 시리즈에서는 'Monte Carlo Simulation for Time Series Probabilistic Forecasting'에서 Monte Carlo 시뮬레이션 기법 및 'Quantile Regression for Time Series Probabilistic Forecasting'에서 분위 회귀 기법을 소개했습니다. 이 장에서는 다른 인기있는 방법인 Conformal Prediction (CP)을 소개하겠습니다.\n\nCP를 기본적인 예측 맥락에서 설명해 보겠습니다. 우리는 예측 모델의 목표가 조건부 평균에 대해 편향되지 않은 추정을 제공하는 것이라는 것을 알고 있습니다. 예측 값과 실제 값 간의 차이를 오차라고 합니다. 이 오류들은 무엇일까요? 모델이 확실하지 않은 불확실성입니다. 그렇다면 어떻게 불확실성을 양적으로 표현할까요? 이 질문의 답은 질문 자체에 있습니다. 추정 값과 실제 값 사이의 오차는 불확실성을 나타내며, 우리는 이 오류를 분석하여 불확실성을 양적으로 나타낼 수 있습니다. 그런 다음 예측값에 양적으로 측정된 불확실성을 더하거나 뺌으로써 예측 구간을 계산합니다. CP는 새로운 예측에 대한 자신감 수준을 결정하기 위해 이전 데이터를 사용합니다. CP는 새로운 예측이 예측 범위 내에 있을 확률 (예: 95%)을 보장합니다. 특정 모델을 언급하지 않았음에 주목하십시오. 따라서 CP는 모델에 관계없이 작동합니다.\n\nCP의 구성은 다음과 같습니다:\n\n- 오류는 실제 값과 예측 값 사이의 절대값입니다. 예측 값과 실제 값 사이의 오차를 작은 것부터 큰 것까지 나열할 것입니다. 히스토그램을 사용하여 오차 값의 비율을 표시할 것입니다.\n- 대부분의 경우, 예를 들어 95%의 경우, 오류는 임계값 이하일 것입니다. 이 임계값은 예측 오류에 대한 용인 값으로 간주할 수 있습니다. 이 임계값은 예측에서 해당 실제 값까지의 오류가 95%의 경우 임계값 아래에 있을 것이라는 뜻입니다.\n- 따라서 예측값에 허용 오차를 더하거나 빼면 해당 예측에 대한 예측 구간을 얻을 수 있습니다. 이는 우리가 예측한 실제 값이 예측 구간 내에 존재할 확률이 95%라는 것을 의미합니다. 그림 (A)는 일치 예측의 구성을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Conformal Prediction Procedure](/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_1.png)\n\n이 예측 간격을 찾는 프로시저는 Conformal Prediction (CP) 전략입니다. 모델 사양과 기본 데이터 분포에 대한 가정을 하지 않는다는 점에 유의하십시오. CP는 모델에 구애받지 않으며 — 모든 모델링 기법과 함께 작동합니다. Conformal Prediction 기술은 Volodya Vovk, Alexander Gammerman, 그리고 Craig Saunders (1999) [1], 그리고 Harris Papadopoulos, Kostas Proedrou, Volodya Vovk, 그리고 Alex Gammerman (2002) [2]에 의해 제안되었습니다. Conformal Prediction 알고리즘은 다음과 같이 작동합니다:\n\n- 과거 시계열 데이터를 교육, 보정, 테스트 기간으로 분할합니다.\n- 교육 데이터에서 모델을 훈련합니다.\n- 훈련된 모델을 사용하여 보정 데이터에 대한 예측을 생성합니다. 그런 다음 예측 오차의 히스토그램을 개발하고 Figure (A)와 같이 허용 수준을 정의합니다.\n- 미래 점 추정치와 함께 예측 데이터 내의 예측에 허용 간격을 더하고 빼어 예측 간격을 제공합니다.\n\n소프트웨어 요구사항\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예측 구간에 대해 NeuralProphet은 세 가지 옵션을 가질 수 있어요: (i) 분위 회귀(Quantile regression, QR), (ii) 일치 예측(Conformal predictions, CP) 및 (iii) 일치화된 분위 회귀(Conformalized quantile regression, CQR). \"시계열 확률적 예측을 위한 분위수 회귀(Quantile Regression for Time Series Probabilistic Forecasting)\"에서 분위 회귀를 연구했습니다. 이 장에서는 일치 예측을 수행하고, 다음 장 \"시계열 확률적 예측을 위한 일치화된 분위 회귀(Conformalized Quantile Regression for Time Series Probabilistic Forecasting)\"에서는 일치화된 분위 회귀를 할 거에요. NeuralProphet를 설치하려면 표준 설치 pip install NeuralProphet를 따르시면 돼요.\n\n```shell\n!pip install neuralprophet\n```\n\nGoogle Colab을 사용하는 경우, NeuralProphet은 numpy1.23.5를 사용하지 않으면 작동하지 않는다는 점을 염두에 두세요. numpy를 제거하고 numpy1.23.5를 설치해야 해요.\n\n```shell\n# neuralprophet은 numpy1.23.5를 사용하지 않으면 colab에서 작동하지 않습니다: https://github.com/googlecolab/colabtools/issues/3752\n!pip uninstall numpy\n!pip install git+https://github.com/ourownstory/neural_prophet.git numpy==1.23.5\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n데이터\n\n이전 NeuralProphet 챕터를 계속 진행하면서, 이 챕터에서는 Kaggle에서 Bike Share Daily 데이터를 사용할 것입니다. 이전 챕터에서 데이터 단계를 상세히 살펴봤기 때문에, 여기서는 설명 없이 데이터를 바로 로드할 것입니다. 데이터를 이해하려면 이전 챕터 중 하나를 참조할 수 있습니다:\n\n- 챕터 3: 튜토리얼 I: 추세 + 계절성 + 휴일 및 이벤트\n- 챕터 4: 튜토리얼 II: 추세 + 계절성 + 휴일 및 이벤트 + 자기 회귀 (AR) + 지연 회귀 + 미래 회귀\n- 챕터 5: \"시계열 확률 예측을 위한 분위수 회귀\".\n\n```js\n%matplotlib inline\nfrom matplotlib import pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport logging\nimport warnings\nlogging.getLogger('prophet').setLevel(logging.ERROR)\nwarnings.filterwarnings(\"ignore\")\n\n# If you use Google Colab\nfrom google.colab import drive\ndrive.mount('/content/gdrive')\npath = '/content/gdrive/My Drive/data/time_series'\ndata = pd.read_csv(path + '/bike_sharing_daily.csv')\ndata.tail()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![dataset](/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_2.png)\n\n이 데이터셋은 매일의 대여 수요와 온도 또는 풍속과 같은 기타 날씨 정보를 포함한 다변량 데이터셋입니다. 모델링을 위해 매우 간단한 데이터 준비를 진행할 것입니다. NeuralProphet은 열 이름을 \"ds\"와 \"y\"로 요구합니다.\n\n```python\n# 문자열을 datetime64로 변환\ndata[\"ds\"] = pd.to_datetime(data[\"dteday\"])\ndf = data[['ds','cnt']]\ndf.columns = ['ds','y']\n```\n\n이제 모델을 설정하겠습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n모델링\n\n다음과 같이 매우 간단한 NeuralProphet 모델을 사용할 것입니다. 이 모델은 추세 및 계절성 패턴만을 갖고 있습니다. 이전 장에서 언급한 대로 AR, 휴일 및 기타 공변량과 같은 다른 구성 요소를 추가할 수 있습니다.\n\n```js\nfrom neuralprophet import NeuralProphet, set_log_level\ncp_model = NeuralProphet(\n    yearly_seasonality=True,\n    weekly_seasonality=True,\n    daily_seasonality=False,\n)\ncp_model.set_plotting_backend(\"plotly-static\")\n```\n\n이제 데이터를 준비해 봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n학습, 보정 및 테스트 데이터\n\n적합성 예측 또는 적합성 양자 회귀 기술에서 중요한 단계는 훈련 데이터를 훈련 및 보정 데이터로 분할하는 것입니다. 보정 데이터는 허용 통계를 구성하는 데 사용됩니다.\n\n```js\ndf_train, df_test = cp_model.split_df(df, valid_p=0.2)\ndf_train, df_cal = cp_model.split_df(df_train, freq=\"D\", valid_p=1.0 / 11)\n[df_train.shape, df_test.shape, df_cal.shape]\n# [(532, 2), (146, 2), (53, 2)]\n```\n\n세 가지 색으로 데이터 하위 집합을 그립니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_3.png\" /\u003e\n\n모델 구축은 이전 챕터와 동일합니다. 보정 데이터를 모델 검증 세트로 사용합니다.\n\n```js\nmetrics = cp_model.fit(df_train, validation_df=df_cal, progress=\"bar\")\nmetrics.tail()\n```\n\n\u003cimg src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_4.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러면 예측을 하고 예측 간격을 첨부할 준비가 된 것입니다. NeuralProphet은 자동으로 CP를 수행할 수 있지만, 여러분에게 단계를 보여주기 위해 수동으로 진행합니다.\n\n일치 예측\n\n우리는 \"df\" 데이터의 마지막 날짜로부터 50개의 기간을 포함하는 \"미래\" 데이터셋을 만들 것입니다. 이 데이터는 모든 과거 데이터에 대한 모델 예측값을 포함할 것입니다. 또는 n_historic_predictions=40을 지정하면 40개의 과거 데이터 포인트와 그에 대한 예측값만 포함할 것입니다.\n\nNeuralProphet의 CP 옵션은 method=naive입니다. 우리는 `.conformal_prediction()`을 사용하여 일치 예측을 활성화할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n미래 = cp_model.make_future_dataframe(df, periods=50, \n     n_historic_predictions=True)\n\n# 단순 일치 예측을 위한 매개변수\n방법 = \"naive\"\n알파 = 0.05\n\n# 사전 훈련된 모델에서 일치 예측 활성화\ncp_forecast = cp_model.conformal_predict(\n    # df_test, # df_test를 사용할 수도 있습니다. \n    미래,\n    calibration_df=df_cal,\n    alpha=알파,\n    method=방법,\n    show_all_PI=True,\n)\ncp_forecast\n```\n\n결과에는 예측 'yhat1'과 상부 경계 'yhat1 + qhat1'가 포함되어 있습니다. 'qhat1'은 캘리브레이션 데이터에서 유도된 허용 간격입니다.\n\n\u003cimg src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_5.png\" /\u003e\n\n'yhat1'에서 'yhat1+qhat1'을 빼서 'qhat1'을 얻을 수 있습니다. 이 값은 1951.214의 단일 값입니다. 그런 다음 yhat1에서 qhat1을 빼서 하한을 구성할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ncp_forecast['qhat1'] = cp_forecast['yhat1 + qhat1'] - cp_forecast['yhat1'] \ncp_forecast['yhat1 - qhat1'] = cp_forecast['yhat1'] - cp_forecast['qhat1']\ncp_forecast\n```\n\n\u003cimg src=\"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_6.png\" /\u003e\n\n예측값과 예측 구간을 그려봅시다. 모든 기간에 대해 CP가 고정 값임을 알 수 있습니다. 예측값에 더하거나 빼서 상한값과 하한값을 얻습니다.\n\n```js\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(10,6))\n# 각 시리즈를 플롯합니다\nplt.plot(df_train['ds'],df_train['y'], label='학습 데이터')\nplt.plot(df_cal['ds'],df_cal['y'], label='보정 데이터')\nplt.plot(df_test['ds'],df_test['y'], label='테스트 데이터')\n\nplt.plot(cp_forecast['ds'],cp_forecast['yhat1'], label='예측값')\nplt.plot(cp_forecast['ds'],cp_forecast['yhat1 - qhat1'], label='하한값')\nplt.plot(cp_forecast['ds'],cp_forecast['yhat1 + qhat1'], label='상한값')\nplt.legend()\nplt.title('일치 예측')\nplt.xticks(rotation=45, ha='right')\n# 수직 점선 그리기\nplt.axvline(x=df_test['ds'].tail(1), color='r', linestyle='--', linewidth=2) \nplt.show()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Conformal Prediction Example](/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_7.png)\n\n중요한 점은 허용 구간이 보정 데이터의 실제 값에서 유도된다는 것입니다.\n\n결론\n\n본 장에서는 예측 구간을 제공하기 위한 Conformal Prediction 기술을 소개했습니다. 우리는 CP의 구성을 기본 통계 개념에서 배웠습니다. CP는 모델 가정에 의존하지 않고 어떤 모델에도 적용할 수 있는 모델에 중립적입니다. 또한 NeuralProphet에서 CP를 구성하는 코드 예제를 시연했습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부분에서 예측 구간의 길이가 모든 기간에 걸쳐 동일하다는 것을 알아차린 분들도 있을 것입니다. 특정 시나리오에 대해 다양한 예측 구간이 더 나은 의미를 갖을 수 있다고 제안할 수 있습니다. 다음 장에서는 다양한 예측 구간을 허용하는 Conformalized Quantile Regression (CQR)을 연구할 것입니다.\n\n참고문헌\n\n- Volodya Vovk, Alexander Gammerman, and Craig Saunders. Machine-learning applications of algorithmic randomness. In International Conference on Machine Learning, pages 444–453, 1999.\n- Harris Papadopoulos, Kostas Proedrou, Volodya Vovk, and Alex Gammerman. Inductive confidence machines for regression. In European Conference on Machine Learning, pages 345–356. Springer, 2002.\n\n샘플 eBook 장(chapter) (무료): [링크](https://github.com/dataman-git/modern-time-series/blob/main/20240522beauty_TOC.pdf)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 이니빠레이션 프레스(The Innovation Press, LLC) 스탭 분들께 감사드립니다. 아름다운 형식으로 책을 재구성하여 즐거운 독서 경험을 제공해 주셔서 감사합니다. 전 세계 독자들에게 엄두 나지 않는 경영비용 없이 Teachable 플랫폼을 선택했습니다. 신용카드 거래는 Teachable.com이 비밀리에 안전하게 처리합니다.\n\nTeachable.com에서 eBook: $22.50\nhttps://drdataman.teachable.com/p/home\n\nAmazon.com에서 인쇄본: $65 https://a.co/d/25FVsMx\n\n- 인쇄본은 광택 처리된 표지, 컬러 인쇄, 아름다운 Springer 글꼴 및 레이아웃을 채택하여 즐거운 독서를 제공합니다. 7.5 x 9.25인치의 사이즈는 여러분의 책장에 있는 대부분의 책들과 잘 어울립니다.\n- \"이 책은 Kuo의 시계열 분석과 예측 분석, 그리고 이상 탐지에 대한 깊은 이해를 증명합니다. 이 책은 독자들에게 현실 세계의 과제에 대처하는 데 필요한 기술을 제공합니다. 데이터 사이언스로의 직업 전환을 고민하는 사람들에게 특히 가치 있는 책입니다. Kuo는 전통적이고 최신 기술을 자세히 탐구합니다. Kuo는 신경망과 다른 고급 알고리즘에 대한 논의를 통합하여 최신 동향과 발전을 반영합니다. 이를 통해 독자들이 확립된 방법뿐만 아니라 데이터 사이언스 분야의 가장 현재와 혁신적인 기술과 함께 소통할 수 있는 준비가 되도록 합니다. Kuo의 흥미로운 글쓰기 스타일로 인해 책의 명료함과 접근성이 향상되었습니다. 그는 복잡한 수학 및 통계 개념을 신비롭지 않게 다루어 엄격함을 희생하지 않으면서도 쉽게 접근 가능하게 만듭니다.\"\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 모던 시계열 예측: 예측 분석과 이상 탐지\n\n제로 장편: 서문\n\n제1 장: 소개\n\n제2 장: 비즈니스 예측을 위한 선지자\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n### Chapter 3: 튜토리얼 1 - 추세 + 계절성 + 휴일 및 이벤트\n\n### Chapter 4: 튜토리얼 2 - 추세 + 계절성 + 휴일 및 이벤트 + 자기 회귀(AR) + 시차 회귀변수 + 미래 회귀변수\n\n### Chapter 5: 시계열 데이터의 변곡점 탐지\n\n### Chapter 6: 시계열 확률 예측을 위한 몬테카를로 시뮬레이션\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7장: 시계열 확률 예측을 위한 분위 회귀 분석\n\n8장: 시계열 확률 예측을 위한 적응적 예측\n\n9장: 시계열 확률 예측을 위한 적응적 분위 회귀 분석\n\n10장: 자동 ARIMA!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 11장: 시계열 데이터 형식 손쉽게 다루기\n\n# 12장: 다기간 확률 예측을 위한 선형 회귀\n\n# 13장: 트리 기반 시계열 모델을 위한 피처 엔지니어링\n\n# 14장: 다기간 시계열 예측을 위한 두 가지 주요 전략\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 15장: 다기간 시계열 확률 예측을 위한 트리 기반 XGB, LightGBM 및 CatBoost 모델\n\n# 16장: 시계열 모델링 기법의 진화\n\n# 17장: 시계열 확률 예측을 위한 딥러닝 기반 DeepAR\n\n# 18장: 응용 - 주식 가격에 대한 확률 예측\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 19장: RNN에서 Transformer 기반 시계열 모델로\n\n# 20장: 해석 가능한 시계열 예측을 위한 Temporal Fusion Transformer\n\n# 21장: 시계열 예측을 위한 오픈 소스 Lag-Llama 튜토리얼","ogImage":{"url":"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_0.png"},"coverImage":"/assets/img/2024-06-30-ConformalPredictionsforTimeSeriesProbabilisticForecasting_0.png","tag":["Tech"],"readingTime":16},{"title":"Docker를 사용하여 GPU에서 Ollama를 로컬로 실행하는 방법","description":"","date":"2024-06-30 22:20","slug":"2024-06-30-HowtorunOllamalocallyonGPUwithDocker","content":"\n\n대형 언어 모델(LLMs)을 사용해보고 싶지만 토큰, 구독료 또는 API 키를 지불하고 싶지 않으신가요? 자신의 노트북(또는 전용 하드웨어)에서 실행하고 Gen AI의 강력함을 누리고 싶으신가요? 그렇다면 Ollama를 확인해보세요. 이 블로그에서는 다음을 안내해 드리겠습니다.\n\n- 도커를 사용하여 빠르게 노트북(Windows 또는 Mac)에 Ollama를 설치하는 방법\n- Ollama WebUI를 실행하고 Gen AI 플레이그라운드를 즐기는 방법\n- 더 빠른 추론을 위해 노트북의 Nvidia GPU 활용\n- Ollama를 사용하여 Python Streamlit Gen AI 응용프로그램 빌드하는 방법\n\n# 사전 요구 사항\n\n본 안내서를 통해 Ollama를 로컬에서 실행하려면 다음이 필요합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도커 및 도커-컴포즈 또는 도커 데스크톱을 사용해주세요.\n- NVIDIA GPU — GPU를 사용할 경우에는 그래픽 카드를 사용하고, 그렇지 않을 경우 노트북의 CPU를 사용합니다.\n- Python 버전 3이 필요합니다.\n- Ollama를 실행하기 위해 충분한 디스크 공간이 필요합니다. 모델 파일은 적어도 10GB의 여유 공간이 필요하지만, 이것만으로는 충분하지 않습니다. 총 디스크 공간의 20%를 여유롭게 남겨 두어야 합니다. 그렇지 않으면 모델 파일에 충분한 공간이 있더라도 Ollama를 시작할 때 문제가 발생할 수 있습니다.\n- Docker 데스크톱을 구성할 때, Docker에 충분한 양의 CPU 및 메모리를 제공해주세요.\n\n# Ollama 설치 방법\n\nOllama를 로컬에 실행하려면 다음 저장소를 클론하고 아래와 같이 docker-compose를 사용하여 실행해주세요,\n\n```js\ngit clone git@github.com:sujithrpillai/ollama.git\ncd ollama/ollama\ndocker-compose up -d\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 docker-compose.yml 파일을 보면, 로컬 폴더인 models가 /root/.ollama/models로 매핑되어 있는 것을 알 수 있습니다. 이 폴더는 다운로드된 모델을 저장하는 곳입니다. 따라서 컨테이너를 다시 배포해도 모델 파일을 다시 다운로드할 필요가 없습니다.\n\n또한 genai-network라는 도커 브릿지 네트워크를 사용하고 있음을 알 수 있습니다. 이는 컨테이너 간 연결성에 매우 중요합니다. 나중에 GenAI 애플리케이션을 실행할 때 Ollama 컨테이너의 DNS 이름을 프로그램에서 사용할 것입니다.\n\n# 모델 파일 다운로드\n\nOllama는 다양한 LLM 모델을 지원하고 있으며 목록은 계속 늘어나고 있습니다. 현재 제공되는 모델을 확인하려면 여기를 확인하세요: https://ollama.com/library. 모델 파일 크기는 다음을 확인할 수 있습니다: https://github.com/ollama/ollama?tab=readme-ov-file#model-library\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 Gen AI 애플리케이션에 사용할 텍스트 모델 llama3과 임베딩 모델 all-minilm을 불러올 것입니다.\n\n```js\ndocker-compose exec -it ollama bash\nollama pull llama3\nollama pull all-minilm\n```\n\n다운로드가 완료되면 단순히 exit를 입력하여 컨테이너 셸을 빠져나오세요.\n\n노트북의 models 폴더로 이동하면 LLM 모델을 위한 파일 세트가 생성된 것을 확인할 수 있습니다. curl http://localhost:11434 로 애플리케이션이 작동 중인지 확인해보세요. 아래와 같이 Ollama가 실행되고 있는 것을 보여줘야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-30-HowtorunOllamalocallyonGPUwithDocker_0.png\" /\u003e\n\nOllama의 웹 사용자 인터페이스에 액세스하려면 http://localhost:3000 으로 이동하십시오. 처음에는 가짜 이메일 및 비밀번호로 가입해야 합니다. 그런 다음 콘솔에 로그인하십시오. 드롭다운에서 GenAI 모델을 선택하고 다양한 프롬프트로 테스트할 수 있는 플레이그라운드에서 사용할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-30-HowtorunOllamalocallyonGPUwithDocker_1.png\" /\u003e\n\n# 추론을 위한 GPU 사용\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n노트북의 GPU를 사용하여 추론하려면 docker-compose.yml 파일을 약간 수정할 수 있습니다. 도커에서 GPU를 사용하는 자세한 정보는 이 설명서를 참조하세요. 해야 할 일은 docker-compose.yml 파일에서 ollama 서비스를 수정하는 것뿐입니다. 아래와 같이 수정하세요.\n\n```js\n    deploy:\n      resources:\n        reservations:\n          devices:\n            - driver: nvidia\n              count: all\n              capabilities: [gpu]\n```\n\n제가 제공한 docker-compose.yml 파일에서 이러한 줄 (11번째 줄부터 17번째 줄)은 주석 처리되어 있습니다. 활성화하려면 주석 처리를 해제하세요.\n\n컨테이너 내에서 ollama ps 명령을 실행하여 차이를 확인할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMac M1 Pro에서는 GPU가 없습니다:\n\n\n![GPU 이미지](/assets/img/2024-06-30-HowtorunOllamalocallyonGPUwithDocker_2.png)\n\n\nWindows에서 Nvidia GPU를 사용하는 경우:\n\n\n![GPU 이미지](/assets/img/2024-06-30-HowtorunOllamalocallyonGPUwithDocker_3.png)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Gen AI RAG 애플리케이션\n\n간단한 GenAI RAG 애플리케이션을 사용하여 텍스트 모델(llama3)과 임베딩 모델(all-minilm)을 모두 사용하여 애플리케이션을 구축해 봅시다.\n\n이전 단계에서 설정한 Ollama가 LLM 모델을 다운로드하여 실행 중인지 확인하세요. 리포지토리의 앱 폴더로 이동하고 docker-compose up -d 명령을 실행하여 실행하세요.\n\n이렇게 함으로써 RAG를 사용하는 매우 작은 Gen AI 애플리케이션이 실행됩니다. 이 애플리케이션에는 PDF 파일을 업로드할 수 있는 UI 요소가 제공됩니다. 파일을 업로드한 후 애플리케이션은 파일을 텍스트로 변환하고 벡터화하여 In-memory FAISS 벡터 데이터베이스에 저장합니다. 그런 다음 텍스트 입력 UI 요소를 사용하여 LLM에 질문을 하게 됩니다. 질문은 벡터 데이터베이스에서 유사성 검색을 수행하는 데 사용됩니다. 질문, 검색 결과 및 컨텍스트가 LLM에 전달되어 의미 있는 답변을 생성합니다. 그런 다음 UI에 답변이 표시됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테스트 목적으로 이상한 데이터가 들어 있는 샘플 imaginary_world.pdf를 제공했어요. RAG가 정말 작동되는지 확인할 수 있어요.\n\n애플리케이션 코드에서 LLM이 정의되는 방식을 알아볼 수 있어요. 우리는 Langchain을 사용해서 이 작업을 수행했어요 (간단한 표현을 위해 변수들을 제거했기 때문에 아래의 파이썬 파일에 작성된 방식과 차이가 있을 수 있어요.)\n\n```js\nfrom langchain_community.llms import Ollama\nllm = Ollama(base_url= http://ollama:11434, model=llama3)\nfrom langchain_community.embeddings import OllamaEmbeddings\nembeddings = OllamaEmbeddings(base_url= http://ollama:11434, model=all-minilm)\n```\n\n다른 방법으로도 llm을 직접 가져와서 사용하는 방법이 있어요. 아래에 그 방법을 보여드릴게요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfrom ollama import Client\nollama_client = Client(host='http://ollama:11434')\nuser_input = “Your question goes here”\nllm_response = ollama_client.chat(\n     model=llama3, messages=[{'role': 'user','content': user_input,},]\n)\n```\n\n애플리케이션은 http://localhost:5000에서 액세스할 수 있습니다. 아래는 애플리케이션에서의 샘플 응답입니다,\n\n\u003cimg src=\"/assets/img/2024-06-30-HowtorunOllamalocallyonGPUwithDocker_4.png\" /\u003e\n\n다양한 프롬프트로 플레이해보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 참고 자료\n\n이 내용을 작성하는 동안 사용한 참고 자료는 다음과 같습니다.\n\n- Ollama 웹사이트 — https://ollama.com/\n- Ollama Open WebUI — https://github.com/open-webui/open-webui\n- Ollama Github 저장소 — https://github.com/ollama/ollama\n- Streamlit — https://streamlit.io/\n- 도커 데스크톱 GPU 지원 — docs.docker.com/desktop/gpu/\n\n자신만의 환경을 구축하여 Gen AI 프로젝트를 테스트할 수 있는 방법을 간단히 살펴봤을 거예요. 댓글로 의견을 공유해주세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-30-HowtorunOllamalocallyonGPUwithDocker_0.png"},"coverImage":"/assets/img/2024-06-30-HowtorunOllamalocallyonGPUwithDocker_0.png","tag":["Tech"],"readingTime":8},{"title":"2024년에 꼭 알아야 할 최고의 Python 사이버보안 라이브러리","description":"","date":"2024-06-30 22:17","slug":"2024-06-30-BestPythonLibrariesforCybersecurityin2024","content":"\n\n![이미지](/assets/img/2024-06-30-BestPythonLibrariesforCybersecurityin2024_0.png)\n\n안녕하세요! 사이버 보안 분야에서 올바른 도구를 선택하는 것은 침입과 방어 사이의 차이를 만드는 중요한 요소입니다. 사이버 위협이 계속 증가함에 따라 더 많은 보안 전문가들이 파이썬을 선택하는 이유로 압도적으로 많은 87%가 매일 파이썬을 사용한다고 보고하고 있습니다.\n\n파이썬이 사이버 보안 분야에서 인기를 끌게 된 이유는 간결성, 가독성 및 강력한 라이브러리의 거대한 생태계 때문입니다. 최신 스택 오버플로 개발자 설문조사에 따르면, 파이썬은 개발자들이 가장 사랑하는 프로그래밍 언어 중 세 번째로 랭크되며, 개발을 계속하고 싶어하는 개발자들이 59.4%에 달합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 범용적인 채택은 최신 기술과 자원이 지속적으로 유입되는 활기찬 기여자 커뮤니티를 의미합니다.\n\n하지만 파이썬을 차별화하는 진정한 요소는 유연성과 크로스 플랫폼 호환성입니다. 침투 테스트를 수행하거나 네트워크 트래픽을 분석하거나 견고한 암호화 프로토콜을 구현하든, 파이썬은 사이버 보안 요구 사항에 맞춤형 라이브러리를 제공합니다. 2024년에는 위협 환경이 점점 더 복잡해지면서 이러한 라이브러리가 더욱 필수적으로 사용될 것으로 예상됩니다.\n\n본 문서에서는 사이버 보안을 위한 가장 흥미로운 파이썬 라이브러리 중 일부를 살펴보고, 그 기능과 현실 세계 응용 사례를 살펴볼 것입니다.\n\n# Scapy: 최고의 패킷 제작 도구\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네트워크 트래픽을 관찰하고 제어하는 것은 네트워크 보안에서 매우 중요합니다. 여기서 Scapy는 네트워크 보안 전문가에게 꼭 필요한 도구로 빛을 발합니다. Scapy는 독보적인 패킷 조작 능력을 통해 네트워크 패킷을 정교하게 제작, 송수신, 스니핑 및 해체할 수 있도록 제공합니다.\n\nScapy의 중요성은 그 다재다능성과 유연성에 있습니다. 침투 테스트, 침입 탐지 시스템 (IDS) 구축, 네트워크 프로토콜 분석 등 다양한 보안 도전 과제에 대처할 수 있는 도구를 제공하여 여러분에게 강력한 지원을 해줍니다. 스크립트 기능을 활용하여 복잡한 작업을 자동화할 수 있어 소중한 시간과 자원을 절약할 수 있습니다.\n\n활용 사례:\n\n- 침투 테스트: Scapy를 사용하여 취약점을 이용할 수 있는 맞춤형 패킷을 제작하여 네트워크 인프라의 잠재적인 취약점을 식별하고 포괄적인 침투 테스트를 수행할 수 있습니다.\n- 네트워크 분석: 강력한 패킷 해체 기능을 통해 Scapy는 네트워크 트래픽을 심층적으로 분석하여 숨겨진 패턴, 이상 현상 및 잠재적 위협을 발견하는 데 도움을 줍니다.\n- 침입 탐지 시스템: Scapy의 패킷 제작 능력을 활용하여 조직의 특정 요구 사항에 맞춘 맞춤형 침입 탐지 시스템을 생성하여 악의적 활동을 강인하게 탐지할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nScapy를 시작하는 방법: Scapy를 숙달하는 가장 좋은 방법은 실전 실습과 포괄적인 학습 자료를 결합하는 것입니다. 먼저 시스템에 Scapy를 설치하고 공식 문서 및 튜토리얼을 통해 기본 기능에 익숙해지세요. 자신감을 쌓으면 패킷 제작, 해석 및 스니핑과 같은 더 고급 기능을 탐험해보세요.\n\n또한, 경험있는 전문가들과 소통하고 지도를 받으며 프로젝트의 발전에 기여할 수 있는 활발한 Scapy 커뮤니티에 가입하는 것도 고려해보세요.\n\n온라인 포럼에 참여하거나 사이버 보안 컨퍼런스에 참석하며 동료들과 협력하는 것은 학습 곡선을 가속화하고 최신 Scapy 기술과 모범 사례를 파악하는 데 도움이 됩니다.\n\n예시:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nimport scapy.all as scapy\n# ICMP 패킷 생성\n    packet = scapy.IP(dst=\"대상 IP\")/scapy.ICMP()\n    # 패킷 전송하고 응답 캡처\n    response = scapy.sr1(packet)\n    # 응답 분석\n    if response:\n        print(f\"대상 {response.src}이(가) 동작 중이며 응답 중입니다!\")\n    else:\n        print(\"대상이 다운되었거나 응답하지 않습니다.\")\n```\n\n이 예제에서는 Scapy의 패킷 제작 기능을 활용하여 대상 IP 주소로 이동하는 ICMP 패킷을 생성합니다. 그런 다음 패킷을 전송하고 응답을 캡처하여 대상이 동작 중이고 응답하는지 확인할 수 있습니다.\n\nScapy를 숙달하면 강력한 네트워크 보안 도구 세트를 활용할 수 있어 신생 위협에 앞서 나아가 조직의 방어력을 강화할 수 있습니다.\n\nScapy에 대해 더 자세히 알아보려면 Python을 사용한 첫 번째 포트 스캐너 작성에 대한 실용적인 가이드를 따르세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 암호화: 안전한 디자인\n\n디지털 시대에 있어서 데이터는 새로운 통화이며, 간첨자들로부터 보호하는 것이 중요합니다.\n\n파이썬을 위한 Cryptography 라이브러리는 여기에서 빛을 발하며, 암호화 알고리즘의 견고하고 안전한 구현을 제공합니다. 산업의 최고의 규칙을 준수하며 \"기본적으로 암호화\"의 원칙을 따르는 이 라이브러리는 안전한 기본 설정을 사용하여 조직의 민감한 데이터를 잠재적으로 위협할 수 있는 일반적인 함정을 완화합니다.\n\nCryptography 라이브러리의 중요성은 다양한 암호화 및 복호화 메커니즘을 제공하여 사이버 보안 방어 태세를 강화하는 데 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n통신 보안, 데이터 보호 및 인증 프로토콜 구현 등 여러 분야에서 이 라이브러리는 디지털 자산을 보호하는 도구를 제공합니다.\n활용 사례:\n\n- 데이터 암호화: 암호화 라이브러리를 활용하여 비밀번호, 금융 정보, 기밀 문서 등 민감한 데이터를 암호화하여 비인가된 당사자에게는 알아볼 수 없게 만듭니다. 가로채여도 데이터가 안전하고 해독할 수 없도록 보장합니다.\n- 안전한 통신: 강력한 암호화 프로토콜을 구현하여 안전한 통신을 위한 보호를 제공하며, 네트워크를 통해 전송되는 데이터가 도청이나 중간자 공격으로부터 안전하고 비밀스럽게 유지됩니다.\n- 인증 및 키 관리: 안전한 키 생성, 저장 및 관리를 위한 라이브러리 기능을 활용하여 견고한 인증 메커니즘을 구현하고 암호화 작업의 무결성을 보장합니다.\n\n암호학 시작하기: 이 라이브러리를 숙달하기 위해서는 암호학 원리와 모범 사례에 대한 확고한 이해가 필요합니다. 먼저 공식 문서와 자습서를 탐험하여 라이브러리의 기능과 사용법에 대한 종합적인 개요를 제공받으세요. 능숙해지면 키 관리, 안전한 키 교환 프로토콜, 암호화 알고리즘 구현과 같은 고급 주제에 대해 탐구해 보세요.\n\n활기찬 Python 커뮤니티와 사이버 보안 컨퍼런스에 참여하면 현실 세계의 사용 사례와 최신 기술을 경험할 수 있습니다. 또한 암호학과 관련된 오픈 소스 프로젝트에 기여하는 것도 고려해 보세요. 이런 실무 경험은 지식을 확고히 하고 분야에서 선도적인 위치에 자리할 수 있도록 도와줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```python\nfrom cryptography.fernet import Fernet\n# 안전한 키를 생성합니다\nkey = Fernet.generate_key()\n# Fernet 인스턴스를 생성합니다\ncipher = Fernet(key)\n# 메시지를 암호화합니다\nmessage = b\"This is a secret message!\"\nencrypted = cipher.encrypt(message)\n# 메시지를 복호화합니다\ndecrypted = cipher.decrypt(encrypted)\nprint(decrypted.decode())  # 출력: This is a secret message!\n```\n\n이 예시에서는 Cryptography 라이브러리의 Fernet 모듈을 활용하여 메시지를 안전하게 암호화하고 복호화합니다. 안전한 키를 생성하고 Fernet 인스턴스를 만들어 민감한 데이터를 쉽게 암호화하고 복호화하여 기밀성과 무결성을 보장할 수 있습니다.\n\nCryptography 라이브러리를 채택함으로써, 귀하는 조직의 디지털 자산을 보호하고 사이버 보안 방어 체계를 강화하여 신흥 위협에 앞서 나갈 수 있는 강력한 도구를 갖추게 될 것입니다.\n\n암호화에 대해 더 알아보고 싶다면, 저는 \"암호화: 비트코인 거래의 중추 및 프로젝트에 구현하는 방법\"에 관한 기사를 작성했습니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# PyNmap: 네트워크 매핑 및 취약점 스캔\n\nPyNmap: 네트워크 취약성을 발견하고 변화무쌍한 사이버 보안 환경에서 적극적인 자세를 유지하는 것은 중요합니다. PyNmap는 유명한 Nmap 보안 스캐너의 능력을 활용하는 강력한 Python 라이브러리로 보안 전문가들에게 힘을 실어줍니다.\n\nPyNmap를 사용하면 Python 스크립트에 포괄적인 네트워크 매핑, 포트 스캔, 그리고 취약성 평가를 직접 통합할 수 있어서 보안 작업을 간소화하고 네트워크 보안 상태에 대한 소중한 통찰력을 제공합니다.\n\nPyNmap의 진정한 힘은 보안 평가를 자동화하고 확장하여 소중한 시간과 자원을 절약하면서 철저하고 일관된 분석을 보장하는 능력에 있습니다. 규칙적인 감사를 수행하거나 잠재적인 위협을 조사하거나 방어를 강화하는 경우, PyNmap는 떠오르는 취약성에 선행하기 위한 도구를 갖추고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용 사례:\n\n- 네트워크 탐사: PyNmap을 활용하여 네트워크 토폴로지에 대한 포괄적인 이해를 얻어 라이브 호스트, 열린 포트, 그리고 악의적인 사용자의 가능한 진입점을 식별할 수 있습니다.\n- 취약점 스캔: Python 스크립트에 쉽게 취약점 스캔을 통합하여 네트워크 인프라, 응용 프로그램 및 서비스 전반에 걸친 취약점을 식별하고 우선순위를 정할 수 있습니다.\n- 침투 테스트: PyNmap의 강력한 기능을 활용하여 실제 공격을 모의하고 방어 수단을 검증하며 상대방이 악용하기 전에 잠재적인 약점을 찾아낼 수 있습니다.\n\nPyNmap 시작하기: PyNmap 여행을 시작하려면 네트워크 보안 원칙과 Nmap 스캐너 자체에 대한 확고한 이해부터 시작해야 합니다. 먼저 공식 Nmap 문서에 익숙해지고 다양한 스캔 기술과 옵션을 탐험해보세요.\n\nNmap의 기능을 완전히 이해한 후에는 PyNmap 라이브러리의 문서와 자습서를 찾아들어 Nmap 기능을 Python 스크립트에 통합하는 방법을 안내받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사이버 보안 커뮤니티와 소통하고 온라인 포럼에 참여하며 학회에 참석하고 네트워크 보안과 관련된 오픈 소스 프로젝트에 기여함으로써 활기찬 사이버 보안 커뮤니티와 소통하세요. 이런 실무 경험을 통해 지식을 공고히하고 실제 사용 사례와 최상의 사례에 노출될 수 있습니다.\n\n예시:\n\n```python\nimport nmap\n# Nmap 스캐너 인스턴스 생성\nscanner = nmap.PortScanner()\n# 대상 호스트에 대한 TCP 커넥트 스캔 수행\ntarget = \"192.168.1.100\"\nscanner.scan(target, arguments=\"-sT\")\n# 열린 포트와 연결된 서비스 출력\nfor host in scanner.all_hosts():\n    print(f\"Host : {host} ({scanner[host].hostname()})\")\n    for proto in scanner[host].all_protocols():\n        print(f\"Protocol : {proto}\")\n        lport = scanner[host][proto].keys()\n        for port in lport:\n            print(f\"{port}: {scanner[host][proto][port]['name']}\")\n```\n\n이 예시에서는 PyNmap을 사용하여 대상 호스트에 대한 TCP 커넥트 스캔을 수행하여 열린 포트와 연결된 서비스를 확인합니다. Nmap의 능력을 우리의 Python 스크립트에 원활하게 통합함으로써 네트워크 정찰 작업을 자동화하고 확장할 수 있어 잠재적인 취약점을 식별하고 방어를 사전에 강화할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nPyNmap을 활용하면 강력한 네트워크 보안 도구를 활용하여 최신 보안 위협에 앞서 나가고 조직의 디지털 자산을 자신 있게 보호할 수 있습니다.\n\n# Python-Nmap: 네트워크 탐사 및 호스트 발견\n\n사이버 보안에서는 지식이 힘이 되며 네트워크 환경에 대한 포괄적인 가시성을 확보하는 것이 중요합니다. Python-Nmap은 유명한 Nmap 보안 스캐너의 기능을 활용하는 강력한 라이브러리를 제공하여 이 분야에서 빛을 발합니다.\n\n사용자 친화적 인터페이스와 포괄적인 설명서를 통해 Python-Nmap은 네트워크 탐사 및 호스트 발견을 간편하게 만들어줍니다. 보안 운영을 위한 가치 있는 정보를 수집하여 보안 작업을 강화하는 데 도움이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n파이썬-Nmap의 가치는 네트워크 정찰 작업을 간소화하고 자동화하여 소중한 시간과 자원을 절약하며 철저하고 일관된 분석을 보장하는 데 있습니다. 일반적인 네트워크 감사를 수행하거나 침투 테스트를 위한 정보를 수집하거나 방어력을 강화하는 경우, 파이썬-Nmap은 대상 네트워크에 대한 가치 있는 정보를 발견할 수 있는 강력한 도구를 제공합니다.\n\n활용 사례:\n\n- 네트워크 매핑: 파이썬-Nmap을 활용하여 네트워크 토폴로지를 복잡하게 이해하여 살아 있는 호스트, 열린 포트, 악의적인 사용자들에 대한 가능한 입구점을 식별할 수 있습니다.\n- 호스트 발견: 네트워크에서 활성 호스트를 신속하게 발견하여 중요한 시스템 및 서비스에 대한 보안 노력에 중점을 두고 집중할 수 있도록 합니다.\n- 정보 수집: 파이썬-Nmap의 강력한 기능을 활용하여 운영 체제, 소프트웨어 버전 및 잠재적인 취약성을 포함한 대상 호스트에 대한 상세한 정보를 수집하여, 효율적인 의사 결정을 내리고 잠재적인 위험을 선제적으로 줄일 수 있습니다.\n\n파이썬-Nmap 시작하기: 파이썬-Nmap 여행을 시작하려면 네트워크 보안 원칙과 Nmap 스캐너 자체에 대한 견고한 이해를 가져야 합니다. 공식 Nmap 설명서에 친숙해지고 사용 가능한 다양한 스캔 기술과 옵션을 탐색해 보세요. Nmap의 기능을 완전히 이해한 후에는 Python-Nmap 라이브러리의 설명서 및 튜토리얼을 살펴보고, Nmap 기능을 파이썬 스크립트에 통합하는 방법을 안내받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친구 같은 톤으로 말하자면, 온라인 포럼에 참여하거나 컨퍼런스에 참석하며 네트워크 보안과 관련된 오픈소스 프로젝트에 기여함으로써 활기찬 사이버 보안 커뮤니티와 소통할 수 있어요. 이 실전 경험은 여러분의 지식을 강화시켜주며 실제 사용 사례와 최선의 실천 방법에 노출시켜 줄 거예요.\n\n실제 설정:\n\n```python\nimport nmap3\n# Nmap 스캐너 인스턴스 생성\nscanner = nmap3.NmapHostDiscovery()\n# 특정 네트워크에 호스트 검색 스캔 수행\nresults = scanner.nmap_no_portscan(\"192.168.1.0/24\")\n# 발견된 호스트 출력\nfor host in results.keys():\n    print(f\"Host: {host} ({results[host]['hostnames'][0]['name']})\")\n```\n\n이 예시에서는 Python-Nmap을 활용하여 특정 네트워크 범위(192.168.1.0/24)에서 호스트 검색 스캔을 수행합니다. nmap3.NmapHostDiscovery 클래스를 활용하여 네트워크에서 활성 호스트를 쉽게 발견할 수 있으며, 전체 포트 스캔을 수행하지 않고 시간과 자원을 절약할 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n스크립트는 NmapHostDiscovery 클래스의 인스턴스를 생성하고, nmap_no_portscan 메서드를 사용하여 호스트 탐지 스캔을 초기화합니다. 그런 다음 결과가 구문 분석되고 발견된 호스트들은 호스트 이름과 함께 인쇄됩니다.\n\nPython-Nmap을 채택함으로써 네트워크 인텔리전스 도구의 강력한 아카이브를 활용하여 새로운 위협에 한 발 앞서나가며 조직의 디지턈 자산을 자신있게 보호할 수 있습니다.\n\nNmap에 대해 시작하고 학습하려면 이 가이드를 확인해주세요, 시스템에 대한 원격 코드 실행 공격을 수행하는 방법\n\n# Impacket: 네트워크 프로토콜 구현\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네트워크 프로토콜의 이해와 조작은 계속 발전하는 사이버 보안 분야에서 중요합니다. 여기서 Impacket이 빛을 발합니다. Impacket은 네트워크 프로토콜 구현과 이용을 위한 스위스 아미 나이프로서 빛을 발하고 있습니다.\n\nImpacket은 SMB, MSRPC 등 다양한 네트워크 프로토콜에 대한 저수준 프로그래밍 액세스를 통해 보안 전문가들이 침투 테스트, 악용 개발, 심지어 자신들의 요구에 맞게 맞춤형 네트워크 도구를 생성할 수 있도록 지원합니다.\n\nImpacket의 진정한 힘은 다양성과 프로토콜 지원의 심도에 있습니다. 취약점 조사, 개념 증명 악용 개발, 네트워크 트래픽 분석을 하든, Impacket은 당신이 네트워크 프로토콜의 복잡성에 심취할 수 있는 도구를 제공하여 떠오르는 위협에 선제적으로 대응하고 조직의 방어력을 강화할 수 있도록 도와줍니다.\n\n사용 사례:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Penetration Testing: Impacket의 광범위한 프로토콜 지원을 활용하여 포괄적인 침투 테스트를 수행하고 취약점을 발견하여 네트워크 인프라의 보안 상태를 평가해 보세요.\n- Exploit Development: Impacket의 네트워크 프로토콜에 대한 저수준 액세스를 활용하여 공격을 개발하고 테스트하여 잠재적인 취약점을 사전에 식별하고 완화할 수 있습니다.\n- Custom Tool Development: Impacket의 유연성을 활용하여 조직의 특정 필요에 맞는 사용자 정의 네트워크 도구를 개발하고 보안 운영을 간소화하며 전반적인 사이버 보안 역량을 향상시킬 수 있습니다.\n\nImpacket으로 시작하기: Impacket 여행을 시작하려면 네트워크 프로토콜과 그 기본 메커니즘에 대한 탄탄한 이해부터 시작하세요.\n\n먼저 공식 Impacket 문서를 숙지하고 사용 가능한 프로토콜과 모듈을 탐색해보세요. 라이브러리의 능력을 완전히 이해한 후에는 실습과 실제 시나리오로 직접 뛰어들어 이해를 공고히 해보세요.\n\n온라인 포럼에 참여하고 학회에 참석하며 네트워크 보안과 관련된 오픈 소스 프로젝트에 기여함으로써 다이내믹한 사이버 보안 커뮤니티와 교류하세요. 이 실전 경험은 실제 사용 사례, 최선의 실천법 및 네트워크 프로토콜 개발의 첨단 기술을 경험하게 해줄 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 세팅:\n\n```js\nimport impacket.smb3\nfrom impacket.ntlm import compute_lm_hashed, compute_nthash\n# SMB 연결 설정\nsmb = impacket.smb3.SMB3(remote_host=\"대상_호스트\", remote_port=445)\nsmb.login(\"사용자_이름\", \"암호\")\n# 공유 리소스 목록\nshares = smb.listShares()\nfor share in shares:\n    print(share.name)\n# 공유 폴더에 접근\ntid = smb.tree_connect_andx(\"\\\\\\\\대상_호스트\\\\공유_이름\")\nsmb.listPath(\"공유_이름\", \"*\")\n```\n\n이 예시에서는 Impacket을 활용하여 서버 메시지 블록 (SMB) 프로토콜과 상호 작용합니다. SMB는 파일 공유 및 원격 액세스를 위해 널리 사용되는 네트워크 프로토콜입니다. 스크립트는 대상 호스트에 SMB 연결을 설정하고 제공된 자격 증명으로 인증하며 사용 가능한 공유 리소스를 나열하고 특정 공유 폴더에 액세스합니다.\n\nImpacket을 숙달하면 강력한 네트워크 프로토콜 악용 도구 모음을 활용할 수 있어 신뢰성 있는 조직 방어 강화와 신규 위협에 앞장서는 데 도움을 줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nImpacket에 대해 자세히 알아보려면 Beginner’s Guide)에서 Python으로 백신을 빌드하는 방법을 탐색한 이 안내서를 확인해보세요.\n\n# Brypt: 비밀번호 안전성 강화\n\n비밀번호 보호는 사이버 보안에서 무단 액세스에 대한 중요한 방어 라인입니다. Brypt는 안전하게 해싱하고 비밀번호를 확인하는 Python 라이브러리를 제공하여 이 분야에서 빛을 발합니다.\n\nbcrypt, scrypt, 그리고 Argon2와 같은 업계 표준 해싱 알고리즘에 대한 고수준 인터페이스를 제공함으로써 Brypt는 최고의 비밀번호 저장 및 확인 관행을 따르도록 보장하여 데이터 누출 및 무단 액세스의 위험을 줄입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBrypt의 참 가치는 업계 표준 보안 프로토콜을 준수하면서 암호 해시 및 확인을 간소화하고 간결하게하는 능력에 있습니다. 웹 애플리케이션을 개발하든, 내부 시스템을 보호하든, 조직의 인증 메커니즘을 강화하든, Brypt는 민감한 자격 증명을 보호하기 위한 강력하고 사용하기 쉬운 툴킷을 제공하여 여러분을 돕습니다.\n\n활용 사례:\n\n- 웹 애플리케이션 보안: Brypt를 웹 애플리케이션에 통합하여 사용자 암호를 안전하게 해싱하고 저장하여 일반 텍스트 암호 노출의 위험을 최소화하고 전반적인 애플리케이션 보안을 강화합니다.\n- 내부 시스템 보안: Brypt를 활용하여 고강도의 암호 해시 및 확인 메커니즘을 구현하여 내부 시스템 및 서비스를 안전하게 보호하여 무단 접근과 잠재적인 데이터 침해로부터 보호합니다.\n- 인증 메커니즘: Brypt의 능력을 활용하여 조직의 인증 프로토콜을 강화하여 민감한 자격 증명이 안전하게 저장되고 확인되도록하며, 어카운트 침해 위험을 줄입니다.\n\nBrypt로 시작하기:\nBrypt 여행을 시작하는 것은 안전한 비밀번호 보안 모범 사례와 해싱 알고리즘에 대한 탄탄한 이해로부터 시작합니다. 첫걸음은 공식 Brypt 문서를 익히고 다양한 해싱 알고리즘과 옵션을 탐색하는 것입니다. 라이브러리의 능력을 완전히 이해하면 실전 연습과 현실 시나리오에 뛰어들어 이해를 고착시키세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사이버보안 커뮤니티와 소통하기 위해 온라인 포럼에 참여하고 컨퍼런스에 참석하며 비밀번호 보안과 관련된 오픈 소스 프로젝트에 기여하세요. 이 경험을 통해 현실 세계의 사용 사례, 최고의 실천 사례 및 최신 비밀번호 해싱 및 확인 기술에 노출될 것입니다.\n\n실제 설정:\n\n```js\nimport brypt\n# bcrypt를 사용하여 비밀번호를 해싱합니다\n    hashed_password = brypt.hashpw(\"mypassword\", brypt.gensalt())\n    # 해시값과 비밀번호를 비교하여 확인합니다\n    if brypt.checkpw(\"mypassword\", hashed_password):\n        print(\"비밀번호가 유효합니다!\")\n    else:\n        print(\"유효하지 않은 비밀번호!\")\n```\n\n이 예제에서는 bcrypt 알고리즘을 사용하여 안전하게 비밀번호를 해싱하고 제공된 비밀번호를 해시 값과 비교하여 확인하는 Brypt를 활용합니다. 이 스크립트는 Brypt의 간단한 인터페이스를 보여줌으로써 비밀번호 저장 및 확인이 업계의 최고 기준을 준수하도록 보장합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Scapy-HTTPS: 암호화된 네트워크 트래픽 해독하기\n\nScapy는 강력한 패킷 조작 도구이지만 HTTPS 트래픽을 처리하는 기본 지원이 부족합니다. 여기에 Scapy-HTTPS가 등장합니다. Scapy의 기능을 확장하여 암호화된 HTTPS 트래픽을 분석하고 분해할 수 있는 보조 라이브러리입니다. Scapy-HTTPS를 사용하면 HTTPS 패킷을 검사하고 해독할 수 있어 잠재적인 취약점을 발견하고 안전한 네트워크 통신을 모니터링할 수 있습니다.\n\nScapy-HTTPS의 중요성은 암호화된 네트워크 트래픽을 볼 수 있는 능력에 있습니다. 오늘날의 사이버 보안 환경에서 안전한 통신 프로토콜이 흔하기 때문에 이 능력은 매우 중요합니다. Scapy-HTTPS를 활용함으로써 보안 전문가는 잠재적인 위협과 취약점에 대한 소중한 통찰력을 얻을 수 있어 조직의 네트워크 인프라의 무결성과 기밀성을 보장할 수 있습니다.\n\n사용 사례:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 네트워크 트래픽 분석: Scapy-HTTPS를 활용하여 암호화된 HTTPS 트래픽을 분석하고 해독하여 잠재적인 취약점, 이상 현상 및 침해 사례 지표를 발견합니다.\n- 침투 테스트: Scapy-HTTPS를 활용하여 실제 공격을 시뮬레이션하고 조직의 HTTPS 구현의 보안을 테스트하여 취약점을 식별하고 방어 체계를 강화합니다.\n- 사고 대응 및 포렌식: 사고 대응 및 포렌식 조사에서 Scapy-HTTPS를 활용하여 캡처한 HTTPS 트래픽을 해독하여 값진 증거를 수집하고 보안 사고의 근본 원인을 발견합니다.\n\n바이크립트에 대해 더 알아보려면 다음 기사를 확인하세요. '내일을 위한 소프트웨어 보안 강화'\n\nScapy-HTTPS 시작하기:\nScapy-HTTPS 여행을 시작하려면 네트워크 프로토콜, 패킷 분석 및 암호화 메커니즘에 대한 확고한 이해가 필요합니다. 먼저 Scapy 문서를 읽고 패킷 조작 기능을 탐색하여 Scapy에 대한 확고한 이해를 갖춥니다. 그 후 Scapy-HTTPS 문서와 자습서를 탐험하여 HTTPS 트래픽 분석을 Python 스크립트에 통합하는 과정을 안내 받습니다.\n\n온라인 포럼에 참여하거나 컨퍼런스에 참석하고 오픈 소스 네트워크 보안 및 암호화 프로젝트에 기여함으로써 사이버 보안 커뮤니티와 소통하세요. 이러한 실무 경험을 통해 HTTPS 트래픽 분석의 실제 사용 사례, 최선의 방법 및 최신 기술에 노출될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실제 환경 설정:\n\n```python\nfrom scapy_https import SSLStreamReader\n\n# 패킷 캡처 파일을 불러옵니다\npackets = rdpcap(\"capture.pcap\")\n# SSLStreamReader 객체를 인스턴스화합니다\nreader = SSLStreamReader()\n# HTTPS 패킷을 처리합니다\nfor packet in packets:\n    reader.insert(packet)\n    if reader.isDone():\n        print(f\"복호화된 데이터: {reader.get_decrypted_data()}\")\n        reader.reset()\n```\n\n이 예시에서는 Scapy-HTTPS를 사용하여 패킷 캡쳐 파일에서 HTTPS 트래픽을 분석하고 복호화합니다. 이 스크립트는 SSLStreamReader 객체를 인스턴스화하고 각 패킷을 처리하여 HTTPS 데이터를 복호화하고 복호화된 내용을 출력합니다. 이 접근법을 통해 보안 전문가들은 암호화된 네트워크 트래픽을 보고 잠재적인 취약점을 발견하거나 안전한 통신을 모니터링할 수 있습니다.\n\n이 강력한 Python 라이브러리들을 활용하여 조직의 사이버 보안 방어 체계를 강화하고 신규 위협에 대비하며 디지털 자산을 안전하게 보호할 수 있는 포괄적인 도구 상자를 구축하게 될 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n파이썬은 라이브러리의 풍부한 생태계를 통해 강력한 사이버 보안 동맹으로 나타납니다. Scapy의 패킷 조작 능력부터 Cryptography의 견고한 암호화 구현까지, 이러한 최고의 파이썬 도구들은 방어 체계를 강화하고 떠오르는 위협에 앞장서도록 도와줍니다. 파이썬의 사이버 보안 능력을 받아들이고 커뮤니티와 소통하여 귀하의 조직의 디지털 미래를 안전하게 지키세요.","ogImage":{"url":"/assets/img/2024-06-30-BestPythonLibrariesforCybersecurityin2024_0.png"},"coverImage":"/assets/img/2024-06-30-BestPythonLibrariesforCybersecurityin2024_0.png","tag":["Tech"],"readingTime":20}],"page":"5","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"5"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>