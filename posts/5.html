<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/5" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/5" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_buildManifest.js" defer=""></script><script src="/_next/static/o1YmnmSuZvAX2O4TI9r41/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법" href="/post/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법" href="/post/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS Powertools를 사용해 Serverless API 문서화 하는 방법" href="/post/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS Powertools를 사용해 Serverless API 문서화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS Powertools를 사용해 Serverless API 문서화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">AWS Powertools를 사용해 Serverless API 문서화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시" href="/post/2024-06-23-ReflectionsandBasicWebApplicationArchitecture"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="몇 번의 클릭으로 IAM 정책 시각화 하는 방법" href="/post/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="몇 번의 클릭으로 IAM 정책 시각화 하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="몇 번의 클릭으로 IAM 정책 시각화 하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">몇 번의 클릭으로 IAM 정책 시각화 하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라우드 보안 전략을 만드는 궁극적인 가이드" href="/post/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라우드 보안 전략을 만드는 궁극적인 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라우드 보안 전략을 만드는 궁극적인 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">클라우드 보안 전략을 만드는 궁극적인 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기" href="/post/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="유니티 물리 시스템 메쉬 콜라이더 완벽 가이드" href="/post/2024-06-23-UnityPhysicsMeshColliders"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="유니티 물리 시스템 메쉬 콜라이더 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UnityPhysicsMeshColliders_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="유니티 물리 시스템 메쉬 콜라이더 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">유니티 물리 시스템 메쉬 콜라이더 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="초보자를 위한 Linux Debian에서 OpenGL 설정하는 방법" href="/post/2024-06-23-ABeginnersGuidetoSetupOpenGLinLinuxDebian"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="초보자를 위한 Linux Debian에서 OpenGL 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ABeginnersGuidetoSetupOpenGLinLinuxDebian_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="초보자를 위한 Linux Debian에서 OpenGL 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">초보자를 위한 Linux Debian에서 OpenGL 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Sennaar의 노래 꿈을 현실로 만드는 이야기" href="/post/2024-06-23-ChantsofSennaarisaDreamComeTrue"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Sennaar의 노래 꿈을 현실로 만드는 이야기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ChantsofSennaarisaDreamComeTrue_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Sennaar의 노래 꿈을 현실로 만드는 이야기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Sennaar의 노래 꿈을 현실로 만드는 이야기</strong><div class="PostList_meta__VCFLX"><span class="date">12 hours ago</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link posts_-active__YVJEi" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Terraform과 PEM 키를 사용하여 EC2 인스턴스 및 SSH 접근 설정 방법","description":"","date":"2024-06-23 00:22","slug":"2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey","content":"\n\n이 안내서는 PEM 키를 사용하여 SSH 액세스가 설정된 Terraform을 사용하여 EC2 인스턴스를 생성하는 데 도움이 될 것입니다.\n\n## 아키텍처 개요\n\n설치에는 다음이 포함됩니다:\n\n- 서브넷과 인터넷 게이트웨이가 있는 VPC.\n- EC2 인스턴스.\n- SSH 액세스용 보안 그룹.\n- 라우팅 테이블.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AWS 자격 증명 구성\n\nAWS CLI 설치: AWS CLI를 아직 설치하지 않았다면 여기에서 다운로드하여 설치할 수 있습니다.\n\nAWS CLI 구성: 아래 명령을 실행하여 AWS 자격 증명을 구성하세요. 이를 통해 Terraform이 사용할 필요한 구성 파일을 설정합니다.\n\n```js\naws configure\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 자격 증명을 입력해주세요:\n\n```js\nAWS Access Key ID [None]: \u003c당신의 AWS 액세스 키 ID\u003e\nAWS Secret Access Key [None]: \u003c당신의 AWS Secret 액세스 키\u003e\nDefault region name [None]: us-west-2\nDefault output format [None]: json\n```\n\n설정 확인: 설정을 완료한 후에는 다음 명령어를 실행하여 설정을 확인하세요:\n\n```js\naws sts get-caller-identity\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 명령은 IAM 사용자에 대한 세부 정보가 포함된 JSON 응답을 반환해야 합니다.\n\n# 디렉토리 구조 설정하기\n\n터미널을 열고 다음과 같이 메인 디렉토리를 생성하세요:\n\n```shell\nmkdir terraform_project\ncd terraform_project\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모듈을 위한 하위 디렉토리를 생성해주세요:\n\n```bash\nmkdir ec2_setup\ncd ec2_setup\n```\n\n필요한 Terraform 파일을 생성해주세요:\n\n```bash\ntouch main.tf variables.tf vpc.tf subnet.tf security_group.tf ec2.tf internet_gateway.tf route_table.tf key_pair.tf\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일이 생성되었는지 확인하기 위해 파일 목록을 나열해보세요:\n\n```js\nls\n```\n\n## 구성 시작\n\n## 1. 제공자 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmain.tf 파일에서 공급업체를 설정하십시오:\n\n```js\nterraform {\n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~\u003e 5.18\"\n    }\n  }\n}\n\nprovider \"aws\" {\n  region = \"us-west-2\"\n}\n```\n\n## 2. 입력 변수 정의\n\nvariables.tf 파일에서 변수를 정의하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nvariable \"ssh_key_name\" {\n  description = \"SSH 키 쌍의 이름\"\n  type        = string\n}\n\nvariable \"ec2_instance_type\" {\n  description = \"EC2 인스턴스의 유형\"\n  type        = string\n}\n\nvariable \"ec2_instance_tag\" {\n  description = \"EC2 인스턴스를 위한 태그\"\n  type        = string\n}\n\nvariable \"instance_count\" {\n  description = \"생성할 인스턴스 수\"\n  type        = number\n}\n\nvariable \"private_key_file\" {\n  description = \"개인 키 파일의 이름\"\n  type        = string\n}\n\nvariable \"vpc_cidr_block\" {\n  description = \"VPC의 CIDR 블록\"\n  type        = string\n}\n\nvariable \"subnet_az\" {\n  description = \"서브넷의 가용 영역\"\n  type        = string\n}\r\n```\n\n# 3. VPC 생성\n\nvpc.tf 파일에 VPC 리소스를 정의하세요:\n\n```js\r\nresource \"aws_vpc\" \"my_vpc\" {\n  cidr_block           = var.vpc_cidr_block\n  enable_dns_support   = true\n  enable_dns_hostnames = true\n  tags = {\n    Name = \"my_vpc\"\n  }\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 서브넷 정의하기\n\nsubnet.tf 파일에서 다음과 같이 서브넷을 정의하세요:\n\n```js\nresource \"aws_subnet\" \"my_subnet\" {\n  cidr_block        = cidrsubnet(aws_vpc.my_vpc.cidr_block, 3, 1)\n  vpc_id            = aws_vpc.my_vpc.id\n  availability_zone = var.subnet_az\n}\n```\n\n# 5. 인터넷 게이트웨이 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ninternet_gateway.tf 파일에서 인터넷 게이트웨이를 정의하세요:\n\n```js\nresource \"aws_internet_gateway\" \"my_igw\" {\n  vpc_id = aws_vpc.my_vpc.id\n}\n```\n\n# 6. 보안 그룹 생성하기\n\nsecurity_group.tf 파일에서 보안 그룹을 정의하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nresource \"aws_security_group\" \"ssh_access\" {\n  name   = \"ssh_access\"\n  vpc_id = aws_vpc.my_vpc.id\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \"tcp\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = -1\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n}\n```\n\n# 7. EC2 인스턴스 시작하기\n\nec2.tf에서 다음과 같이 EC2 인스턴스를 정의하세요:\n\n```js\ndata \"aws_ami\" \"latest_ubuntu\" {\n  most_recent = true\n\n  filter {\n    name   = \"name\"\n    values = [\"ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*\"]\n  }\n\n  filter {\n    name   = \"virtualization-type\"\n    values = [\"hvm\"]\n  }\n\n  owners = [\"\u003cYour AWS Account ID\u003e\"]\n}\n\nresource \"aws_instance\" \"my_ec2_instance\" {\n  count                       = var.instance_count\n  ami                         = data.aws_ami.latest_ubuntu.id\n  instance_type               = var.ec2_instance_type\n  key_name                    = var.ssh_key_name\n  security_groups             = [aws_security_group.ssh_access.id]\n  associate_public_ip_address = true\n  subnet_id                   = aws_subnet.my_subnet.id\n\n  tags = {\n    Name = var.ec2_instance_tag\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 8. 라우트 테이블 생성\n\nroute_table.tf 파일에서 라우트 테이블 및 연관을 정의하세요:\n\n```js\nresource \"aws_route_table\" \"my_route_table\" {\n  vpc_id = aws_vpc.my_vpc.id\n\n  route {\n    cidr_block = \"0.0.0.0/0\"\n    gateway_id = aws_internet_gateway.my_igw.id\n  }\n}\nresource \"aws_route_table_association\" \"my_route_table_assoc\" {\n  subnet_id      = aws_subnet.my_subnet.id\n  route_table_id = aws_route_table.my_route_table.id\n}\n```\n\n# 9. 키페어 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nkey_pair.tf 파일에서 키페어를 정의하고 개인 키를 저장하세요:\n\n```js\nresource \"tls_private_key\" \"my_rsa_key\" {\n  algorithm = \"RSA\"\n  rsa_bits  = 4096\n}\n\nresource \"aws_key_pair\" \"my_key_pair\" {\n  key_name   = var.ssh_key_name\n  public_key = tls_private_key.my_rsa_key.public_key_openssh\n}\n\nresource \"local_file\" \"my_private_key\" {\n  content  = tls_private_key.my_rsa_key.private_key_pem\n  filename = var.private_key_file\n}\n```\n\n# 구성 배포\n\nTerraform 구성을 초기화하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n테이블 태그를 Markdown 형식으로 변경하세요.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nterraform apply -var 'ssh_key_name=my_ssh_key' -var 'ec2_instance_type=t2.micro' -var 'ec2_instance_tag=[\"TestInstance\"]' -var 'instance_count=1' -var 'private_key_file=my_private_key.pem' -var 'vpc_cidr_block=10.0.0.0/16' -var 'subnet_az=us-west-2a'\n```\n\nAWS에서 리소스를 확인해보세요:\n\n![이미지1](/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_0.png)\n\n![이미지2](/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경한 것입니다.\n\n\n![이미지1](/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_2.png)\n\n![이미지2](/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_3.png)\n\nPEM 키를 사용하여 인스턴스로 SSH 연결:\n\n```js\nssh -i my_private_key.pem ubuntu@\u003cpublic-ip\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_4.png\" /\u003e\n\n# 결론\n\n테라폼을 사용하여 SSH 액세스가 가능한 EC2 인스턴스를 성공적으로 생성했습니다. 이 구성은 모듈식이므로 향후 프로젝트에 맞게 쉽게 적응시킬 수 있습니다. 완전한 모듈은 GitHub에서 찾을 수 있습니다.\n\n행복한 Terraforming!","ogImage":{"url":"/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_0.png"},"coverImage":"/assets/img/2024-06-23-SettingUpanEC2InstanceUsingTerraformandSSHAccesswithPEMKey_0.png","tag":["Tech"],"readingTime":7},{"title":"기술된 규칙을 기반으로 한글 제목을 다음과 같이 바꿀 수 있습니다꼭 사용해야 할 숨겨진 기능 - Advanced AWS Lambda 활용법","description":"","date":"2024-06-23 00:20","slug":"2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse","content":"\n\n# 소개\n\n클라우드 또는 데브옵스 엔지니어로 일해본 적이 있다면, 아마도 이전에 AWS Lambda 함수를 한 번 이상 만들어 본 적이 있을 것입니다. 아마도 주로 Python이나 NodeJS와 같은 네이티브 지원 런타임에서 이 함수를 개발했으며, 그 목적은 간단한 프로세스를 실행하거나 AWS Cognito나 API Gateway와 같은 다른 AWS 서비스와 통합하여 신원 확인을 수행하는 것이었을 것입니다. 이 구현 과정에서 런타임 선택, 코드 업로드, 환경 변수 설정 및 사용, 그리고 기본 실행 권한이 있는 역할을 첨부하는 등의 기본 AWS Lambda 작업에 익숙해졌을 것입니다.\n\n하지만 쉘 또는 Go 스크립트와 같은 네이티브 지원되지 않는 런타임으로 작성된 코드가 있다면 어떨까요? 첫 번째 충동은 그 코드를 Python으로 번역하려고 하는 것일 것입니다. 또는 더 좋은 방법으로는 GenAI에게 번역을 요청하는 것일 것입니다. 이 방법은 코드가 간단하고 짧은 함수일 경우에는 잘 작동할 수 있습니다. 또는 회사의 보안 및 기밀 정책이 제3자인 GenAI에게 코드를 전송하는 것을 허용한다면 더욱 좋을 것입니다. 그러나 대부분의 경우, 엄격한 규정과 요구사항을 가진 대기업에서 일하는 경우에는 이를 할 수 없을 것입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:480/1*HLkvF3q4nyCWnwjiUiH5qA.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물에서는 Docker 및 AWS Lambda 개념에 대한 기본적인 이해만 있으면 함수 실행에 필요한 사용자 정의 런타임을 제공하는 Docker 이미지를 쉽고 간단히 만드는 방법을 설명하겠습니다.\n\n# AWS Lambda의 내부 구조\n\n사용자 지정 런타임을 구성하는 방법에 대해 자세히 알아보기 전에 AWS Lambda가 서버리스 모드에서 함수를 실행하는 마법같은 방법을 이해해 보겠습니다.\n\n![AWS Lambda 내부 구조](/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS Lambda 서버리스 실행은 세 가지 구성 요소 덕분에 가능해집니다:\n\n- Lambda Service: 프로비저닝, 스케일링, 모니터링 및 로깅을 처리합니다. 코드를 배포하고 함수를 호출하는 것을 포함한 함수 실행의 수명주기를 관리합니다.\n- Execution Runtime: 코드가 실행되는 환경입니다. AWS Lambda는 Node.js, Python, Java 등 다양한 런타임을 지원하며, 다른 프로그래밍 언어나 특정 런타임 버전을 위한 사용자 정의 런타임 사용도 허용합니다.\n- Runtime API: 이 인터페이스는 Lambda 서비스와 실행 런타임 사이에 위치합니다. AWS Lambda 인프라와 함수 실행 환경 간의 통신에 사용됩니다.\n\n![Advanced AWS Lambda](/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_1.png)\n\n주로 런타임과 함수 코드로 구성된 파란색 사각형에 초점을 맞출 것입니다. 우리 Lambda 함수가 작동하도록 수정해야 하는 부분입니다. 일반적으로 지원되는 AWS Lambda 런타임은 런타임 API를 지속적으로 폴링하여 새 이벤트를 수신하고, 함수 핸들러를 로드하고, 이벤트를 수신하면 실행하여 결과를 런타임 API로 다시 보내며, 이를 통해 클라이언트(이 경우 Lambda 서비스)에 결과를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS는 우리에게 OS전용 런타임이라고 불리는 것을 제공합니다. 이는 언어 지원을 제공하며, 실행 스크립트를 실행하는 데 필요한 환경 변수 및 인증서와 같은 추가 설정을 제공하고, Lambda 서비스와 상호 작용하기 위한 모든 필요한 API를 구성합니다 [1]. 모든 것을 할 일은 작은 스크립트를 추가하고, 코드와 번들로 만든 후, AWS OS 전용 런타임을 기반으로 새로운 도커 이미지를 빌드하고, 이 이미지를 ECR에 업로드한 후, 마지막으로 AWS Lambda의 이미지로 사용하는 것뿐입니다. 쉽고 간단해요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:500/1*Fs-d5kxj5Aa3LL0Jm0MF-Q.gif)\n\n# 사용자 정의 런타임 구현\n\n이 섹션에서는 AWS Lambda 사용자 정의 런타임을 위한 도커 이미지를 빌드하는 데 필요한 스크립트와 코드를 제공하겠습니다. 준비가 되셨나요? 코드 정글로의 여행에 깊이 파고 들어가기 전에 커피를 가져오세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:600/1*-AMtT2H3qw0N26uRiqTVwQ.gif)\n\n```js\n#!/bin/sh\n\nset -euo pipefail\n\n# export\n# Initialization - load function handler\nsource $LAMBDA_TASK_ROOT/\"$(echo $HANDLER | cut -d. -f1).sh\"\n\n# Processing\nwhile true\ndo\n  HEADERS=\"$(mktemp)\"\n  # Get an event. The HTTP request will block until one is received\n  EVENT_DATA=$(curl -sS -LD \"$HEADERS\" \"http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/next\")\n\n  # Extract request ID by scraping response headers received above\n  REQUEST_ID=$(grep -Fi Lambda-Runtime-Aws-Request-Id \"$HEADERS\" | tr -d '[:space:]' | cut -d: -f2)\n\n  # Run the handler function from the script\n  RESPONSE=$($(echo \"$HANDLER\" | cut -d. -f2) \"$EVENT_DATA\")\n\n  # Send the response\n  curl \"http://${AWS_LAMBDA_RUNTIME_API}/2018-06-01/runtime/invocation/$REQUEST_ID/response\"  -d \"$RESPONSE\"\ndone\n```\n\nThe first line \"set -euo pipefail\" is to configure the shell to handle errors robustly and to exit immediately if any command within the script fails.\n\nThis script starts by loading the function handler through the source command.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 다음, invocation/next API를 호출하여 Runtime API에서 새 이벤트를 조사하기 위한 루프가 시작됩니다.\n\n그런 다음 Lambda 호출을 식별하는 데 도움이 되는 요청 ID를 추출합니다.\n\n그런 다음 Lambda 서비스로부터 수신한 페이로드 데이터로 주요 셸 스크립트를 실행합니다.\n\n마지막으로, invocation/$Request_ID/response를 호출하여 Runtime API로 응답을 보냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nFROM public.ecr.aws/lambda/provided:al2023\n\nENV HANDLER=\"function.handler\"\n\nCOPY ./bootstrap  ${LAMBDA_TASK_ROOT}/bootstrap\nCOPY ./function.sh  ${LAMBDA_TASK_ROOT}/function.sh\n\nRUN chmod +x ${LAMBDA_TASK_ROOT}/bootstrap\nRUN chmod +x ${LAMBDA_TASK_ROOT}/function.sh\n\nENTRYPOINT [\"/var/task/bootstrap\"]\n```\n\n이 Dockerfile은 AWS public Lambda 이미지 `lambda/provided:al2023`를 기반으로 하는 Docker 이미지를 생성합니다 [3]. 이 이미지는 언어 지원과 스크립트 실행에 필요한 환경 변수 및 인증서와 같은 추가 설정을 제공합니다.\n\n우리는 환경 변수를 우리 셸 스크립트의 핸들러로 설정했습니다. 이는 `스크립트 이름`.`함수 이름` 형식으로 되어야 합니다.\n\n이후 이전 부트스트랩 스크립트와 우리의 셸 스크립트를 $LAMBDA_TASK_ROOT로 복사합니다 (Lambda 런타임 환경 변수로 정의된, 함수 코드 디렉토리 `/var/task`를 참조하는 Lambda 환경 변수) [4]\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 스크립트를 실행할 수 있도록 만들고, 마지막으로 실행 시점을 기다리는 새 이벤트를 기다리는 부트스트랩 스크립트로 설정합니다.\n\n```js\nfunction handler () {\n  EVENT_DATA=$1\n  echo \"$EVENT_DATA\" 1\u003e\u00262;\n  RESPONSE=\"Echoing request: '$EVENT_DATA'\"\n\n  echo $RESPONSE\n}\n```\n\n이것은 이벤트 데이터를 인수로 받아 출력하는 샘플 셸 스크립트입니다.\n\n```js\nruntime-tutorial\n├ bootstrap\n├ Dockerfile\n└ function.sh\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 직접 테스트해보세요\n\n지금까지 따라오셨다면, 축하드립니다. 여러분은 이제 AWS 람다 함수에 대한 가장 복잡한 컨셉 중 하나를 이해하셨습니다. 우리 모두가 알다시피, 지식을 확고히 하는 가장 좋은 방법은 실습하는 것이죠!\n\n![image](https://miro.medium.com/v2/resize:fit:480/1*3JqMenMdO5NIFvKGb0Tylg.gif)\n\n그래서 저는 이전 스크립트를 포함하고 사용자 정의 런타임 람다를 생성하고 자체적으로 그 인보케이션을 테스트할 필요한 AWS 리소스를 생성하는 Terraform 모듈을 만들었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Lambda 함수와 해당 사용자 지정 런타임을 배포하고 탐색하려면 작성하고 실행해야 하는 Terraform 스크립트입니다:\n\n```js\ndata \"aws_caller_identity\" \"current\" {}\n\ndata \"aws_region\" \"current\" {}\n\nlocals {\n  current_account_number = data.aws_caller_identity.current.account_id\n  region = data.aws_region.current.name\n}\n\nmodule \"custom-lambda\" {\n  source = \"github.com/Ilyassxx99/lambda-custom-runtime.git\"\n  custom_bash_function_name = \"custom-bash-function\"\n  custom_bash_ecr_repository_name = \"custom-lambda\"\n  current_account_number = local.current_account_number\n  docker_image_custom_bash_uri = \"custom-lambda:latest\"\n  lambda_image_custom_bash_version    = \"3.12.2\"\n  lambda_image_arch              = \"amd64\"\n  region = local.region\n  tags = {\n    Terraform-module = \"custom-bash-runtime\"\n  }\n}\n```\n\n# 결론\n\n제 블로그 시리즈 '고급 AWS Lambda'의 첫 번째 글에서는 Lambda 런타임을 사용자 지정하여 작성한 스크립트에 사용한 어떤 프로그래밍 언어든 지원할 수 있는 방법을 살펴보았습니다. 이것은 Go나 Rust와 같은 AOT 컴파일된 언어로 작업할 때 스크립트의 실행 성능이 중요할 때 매우 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그가 유용했기를 바라요. 피드백이나 이 블로그 주제에 대한 질문 또는 앞으로 논의하고 싶은 다른 기술 주제에 대해 궁금한 점이 있으면 제 LinkedIn(https://www.linkedin.com/in/ifezouaniilyass/)에서 연락해 주세요.\n\n소중한 시간 내어 주셔서 감사합니다. 다음 블로그에서 만나요. 건배!\n\n![Image](https://miro.medium.com/v2/resize:fit:720/1*WIjcsTL49wdYazQX2VS95Q.gif)\n\n## 노트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- AWS는 Docker 이미지 대신 직접 zip을 가져올 수 있는 OS-only provided.al2023 런타임을 지원합니다. 이 문서에서는 코드에 다른 종속성을 포함해야 하는 경우를 다루기 위해 Docker 이미지를 사용하기로 선택했습니다. Docker 이미지 내에서 패키지/모듈을 직접 더 쉽게 설치하고 패키징할 수 있습니다.\n- Go 또는 Rust와 같이 AOT 컴파일된 언어의 경우, AWS는 런타임을 구현하는 라이브러리를 제공하며 해당 기능을 사용하여 메인 프로세스를 랩핑할 수 있습니다. 이 문서에서는 셸 스크립트를 배포하려고 한다고 가정할 때, 런타임 API 호출과 프로세스 실행을 수행하는 스크립트를 작성해야 합니다.\n\n## 참고:\n\n[1] https://docs.aws.amazon.com/lambda/latest/dg/runtimes-provided.html\n\n[2] https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[3] [Amazon Linux 2023 Runtime for AWS Lambda 소개](https://aws.amazon.com/fr/blogs/compute/introducing-the-amazon-linux-2023-runtime-for-aws-lambda/)\n\n[4] [AWS Lambda 환경 변수 구성](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime)\n\n[5] [Lambda 런타임 API](https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html)","ogImage":{"url":"/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_0.png"},"coverImage":"/assets/img/2024-06-23-AdvancedAWSLambdaAnObscureFeatureYouMustAbsolutelyUse_0.png","tag":["Tech"],"readingTime":8},{"title":"AWS Powertools를 사용해 Serverless API 문서화 하는 방법","description":"","date":"2024-06-23 00:18","slug":"2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS","content":"\n\n\n![서버리스 API 문서화](/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_0.png)\n\n높은 품질의 API 문서는 특히 람다 함수가 API를 제공하는 서버리스 아키텍처에서 고객 만족도를 향상시킵니다. 이러한 API를 문서화하는 것은 언제나 깃털로 소설을 쓰는 것 같았습니다. 그러나 이제는 AWS용 Powertools가 OpenAPI 문서화 유틸리티를 출시하면서 그렇지 않게 됐습니다.\n\n이 게시물에서는 Python 람다 함수 기반 API에 대한 OpenAPI 문서를 생성하는 방법을 소개합니다. AWS 람다 및 Pydantic용 Powertools를 활용합니다.\n\n다음 게시물에서는 이 프로세스를 자동화하고 서비스 CI/CD 파이프라인에 추가하여 제작 게이트 및 문서 게시를 생산물에 추가하는 방법을 논의할 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_1.png\" /\u003e\n\n이 블로그 글은 원래 \"Ran The Builder\" 웹사이트에 게시되었습니다.\n\n# API 문서 작성의 필요성\n\nAPI 변경이 필요한 기능을 설계할 때, 나는 그것들을 문서화합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 API 우선 접근 방식을 채택하는 것이 중요하다고 강하게 믿습니다. AWS 서버리스 영웅인 Allen Helton은 API 우선 접근 방식의 가치에 대해 훌륭한 글을 썼습니다. 이 방식은 내부 또는 외부 API 사용자가 새로운 API를 발행할 때까지 차단되지 않고 자사의 API와 통합을 개발하고 계획할 수 있도록 합니다. API 문서를 보내고 그들이 작업할 수 있게 해 주는 것입니다.\n\nAPI 문서는 시스템의 제공되는 것을 언제나 상세히 이해하는 데도 도움이 됩니다. 미래의 통합, 새로운 기능 개발, 그리고 신규 팀원을 온보딩하는 데 훌륭합니다.\n\n## OpenAPI — 표준의 왕\n\nOpenAPI가 API를 설명하는 표준 형식으로 자리잡고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nREST API와 관련된 내용을 설명하는 간단한 JSON 또는 YML 형식의 파일이에요!\n\n- 이용 가능한 엔드포인트\n- 각 엔드포인트에 대한 작업\n- 각 작업의 입력 및 출력 매개변수\n- 인증 방법\n- 태그 또는 그룹별로 엔드포인트를 구성하고 샘플 요청을 생성할 수 있어요.\n\nSwagger.io는 이 문서 파일을 시각화할 수 있는 도구에요.\n\n더미 서비스를 위한 포맷의 라이브 데모를 확인할 수 있어요! 이런식으로 보여요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```Markdown\n![](/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_2.png)\n\n이제 API를 문서화하는 방법을 이해했으니 람다 함수를 백엔드로 사용하는 서버리스 API에이 프로세스를 적용하는 방법에 대해 이야기해 보겠습니다.\n\n# API 문서 생성\n\n여러 가지 API 문서 생성 방법을 살펴보겠습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 의견으로는 Python 기반 API 문서를 생성하는 가장 좋은 방법은 서비스 코드에서 생성하는 것입니다. Pydantic을 사용하여 입력 및 응답 스키마를 정의하고, 이 스키마를 OpenAPI 형식으로 내보내는 옵션이 내재되어 있어서 제 입장에서는 큰 장점입니다. 따라서 우리가 선택하는 모든 솔루션에 이 도구와 통합해야 합니다.\n\n첫 번째 옵션은 API Gateway에서 기본으로 제공됩니다.\n\nAPI Gateway에는 멋진 기능이 있습니다. 배포한 후 콘솔이나 여기에 설명된대로 API를 통해 OpenAPI 문서를 내보낼 수 있습니다. 그러나 Pydantic을 지원하지 않고, 세부 사항 스키마 (입력 또는 출력) 중 많은 것들이 쉽게 구성되지 않습니다. JSON 스키마를 직접 정의하고 요청 검증을 활성화해야 합니다. 마지막으로, 핸들러 코드가 아닌 인프라 코드로부터 생성되므로 좋지만 완벽하지는 않습니다.\n\n좋은 기능이지만, 더 많은 것이 필요합니다. 다른 방법을 검토해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 옵션은 FastAPI와 같은 프레임워크에서 나옵니다.\n\n대부분의 이러한 Python 프레임워크 및 도구들은 FastAPI, Flask-RESTPlus/Flask-RESTx, Django REST Framework, Connexion과 같이 설계되어 있어 웹 응용 프로그램 및 API를 구축하고 소켓을 통해 수신되는 HTTP 요청을 수신할 수 있습니다.\n\nFastAPI에 초점을 맞춰 봅시다.\n\nFastAPI는 Pydantic 스키마를 지원하여 페이로드를 설명하고 코드에서 직접 OpenAPI 문서를 생성할 수 있습니다. 이 접근 방식은 문서 작성 프로세스를 간소화하고 코드와 동기화를 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 Lambda에서 웹 서버를 실행하기 때문에 이미 Lambda 서비스가 대신 수신되는 HTTP 요청을 수신하기 위해 소켓을 여는 방식으로 작동합니다. 이것은 서버 기반 프레임워크이며, 콜드 스타트, Lambda ZIP 파일 크기 및 지연 시간에 부정적인 영향을 미칩니다. 가능은 하지만, 필요한가 싶진 않습니다.\n\n내 의견으로는, 핸들러 코드로부터 생성된 OpenAPI 문서를 제공하는 네이티브 서버리스 프레임워크가 필요합니다. 빠르고 Lambda의 호출 모델과 일치하며, 이에 따라 자체적으로 소켓을 열어서는 안 됩니다.\n\n어떻게 그것을 실현할 수 있는지 살펴봅시다.\n\n# 서버리스 OpenAPI 문서\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 목표는 API Gateway와 Lambda 함수로 구성된 서버리스 API에 대한 OpenAPI 문서를 생성하는 것입니다. HTTP 입력 페이로드 스키마와 모든 가능한 HTTP 응답(상태 코드 및 JSON 페이로드)를 정의할 것입니다. 우리는 Pydantic을 사용하여 모든 스키마를 정의할 것입니다.\n\nOpenAPI 문서는 새로운 API 엔드포인트인 '/swagger' 아래에서 제공될 것입니다.\n\n다음 블로그 포스트에서는 문서 내보내기 및 이 전체 프로세스를 자동화하는 방법에 대해 논의할 것입니다.\n\n이제 목표를 이해했으니 코드를 작성해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Powertools EventHandler 소개\n\n우리는 AWS Lambda용 Powertools 라이브러리를 사용합니다. Powertools for Lambda는 서버리스 운영을 위한 관측 가능성, 로깅, 아이덤포턴시, 입력 유효성 검사 및 기타 여러 가지 기능을 제공하는 라이브러리입니다.\n\nPowertools의 이벤트 핸들러 유틸리티를 사용할 것입니다.\n\n이벤트 핸들러 유틸리티는 API Gateway REST/HTTP API, ALB 및 Lambda Function URL에 대한 보일러플레이트를 줄이기 위한 가벼운 루팅을 제공합니다. 이 유틸리티는 마이크로 함수(한 개 또는 몇 개의 라우트) 및 모놀리식 함수(모든 라우트)와 함께 작동합니다. 가장 흥미로운 점은 OpenAPI와 Pydantic 스키마를 사용한 요청/응답의 데이터 유효성 검사 기능을 제공한다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오픈API 문서는 비교적 새로운 기능입니다. 이는 API Gateway에서 '/swagger' 엔드포인트를 제공하여 OpenAPI 문서를 출력합니다.\n\n실제 서비스에서 이벤트 핸들러 및 데이터 유효성 검사를 구현해 봅시다.\n\nAWS 람다 쿡북 템플릿 프로젝트를 사용하여 OpenAPI 문서를 지원하도록 추가할 것입니다. 쿡북은 서버리스를 시작하는 데 세 번의 클릭만으로 모든 최상의 실전 서버리스 서비스가 요구하는 모든 최상의 실전 서버리스 서비스가 요구하는 모범 사례와 유틸리티를 포함한 템플릿 프로젝트입니다.\n\n인프라 구성부터 시작해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## OpenAPI 엔드포인트 인프라\n\n공식 문서에 SAM 코드 샘플이 있지만, 저는 AWS CDK를 사용합니다.\n\n아래는 CDK REST API 구성에 추가할 함수입니다.\n\n이 함수를 사용하여 GET ‘/swagger’ HTTP 호출에 응답하고 OpenAPI 문서를 생성하는 람다 핸들러를 선택해야 합니다. 우리는 이벤트 핸들러 유틸리티를 사용하는 람다 함수를 연결해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n/swagger, /swagger.css, /swagger.js 세 개의 'GET' 엔드포인트를 해당 기능과 매핑해야 합니다. \n\n5번 라인에서는 새로운 엔드포인트를 추가할 REST API 게이트웨이 개체를 이 함수에 전달하며, 이 엔드포인트를 처리할 람다 함수 클래스를 받습니다.\n\n7번부터 14번 라인까지, 세 개의 엔드포인트를 추가하고 HTTP GET 명령을 사용하여 람다 함수를 연결합니다.\n\n전체 코드는 여기에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 이벤트 핸들러 코드\n\n이제 모든 인프라가 구성되었으니 이벤트 핸들러 코드를 추가하고 API 문서화를 시작해 봅시다.\n\n3번 줄에서는 이벤트 핸들러 API 게이트웨이 리졸버를 생성하고 입력 이벤트와 출력 응답 유효성 검사(Pydantic 사용)를 얻기 위해 유효성을 활성화합니다.\n\n4번 줄에서는 '/swagger' 엔드포인트를 통해 OpenApi 생성을 활성화하고 생성된 문서에 제목을 전달합니다. 문서에 따르면 완전한 OpenAPI 정의를 얻으려면 검증을 활성화해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 전체 코드를 찾을 수 있어요.\n\n## 람다 핸들러 코드\n\n람다 핸들러 코드를 작성하고 문서화해봅시다.\n\n새로운 고객 주문을 생성하는 HTTP POST '/api/orders' 엔드포인트에 대해 문서화하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에는 많은 내용이 있지만, 꽤 간단해요. 우리는 가능한 한 많은 OpenAPI 정보를 추가할 거예요. 특정 API, 설명, JSON HTTP 본문의 입력 스키마, 그리고 모든 가능한 HTTP 응답 스키마를 Pydantic으로 설명할 거예요.\n\n8번째 줄에서, 우리는 이전 파일에서 초기화한 이벤트 핸들러를 가져와요.\n\n13번째 줄에서, 우리는 앱 정의를 시작해요. 먼저, 이 API를 HTTP POST로 표시해요.\n\n14번째 줄에서, 우리는 API를 '/API/orders/' 경로에 응답할 수 있도록 설정해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n15번 라인에서는 OpenAPI 문서에 표시될 API 설명을 설정합니다. \n\n18~31번 라인에서는 모든 API 응답을 정의합니다.\n\n19~22번 라인에서는 HTTP 200 OK 응답을 정의합니다. 이렇게하면 모든 HTTP 응답 정의를 제어할 수 있습니다. 이 응답을 정의하지 않으면 이벤트 핸들러가 자동으로 422 및 200 응답을 생성하고 501 응답을 자동으로 생성하지는 않음을 유의하세요. 422는 입력 유효성 검사 기능에서 내장된 응답이며, 200 응답은 35번 라인에서 정의한 'CreateOrderOutput' Pydantic 스키마를 사용하여 구축됩니다.\n\n23~26번 라인에서는 HTTP 코드 422를 사용하여 HTTP 입력 유효성 검사 응답을 정의합니다. 'InvalidApiRequest' Pydantic 스키마를 사용하여 설명했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n27–30 줄에서 우리는 HTTP 501에 대해 동일한 작업을 수행합니다.\n\n32 줄에서는 이 API를 'CRUD'라는 그룹의 일부로 태그합니다. 여러 개의 API가 있는 경우 태그를 사용하면 하나의 긴 목록이 아닌 여러 하위 목록에서 API를 제시하는 것이 더 쉬워집니다.\n\n39 줄에서는 핸들러의 엔트리 함수를 정의합니다. 리졸버는 HTTP 경로와 명령에 따라 올바른 이벤트 핸들러 하위 함수를 호출합니다. 여기서 더 자세히 알아볼 수 있습니다. 우리 경우에는 모든 호출이 13–36 줄에서 정의한 함수로 라우팅됩니다.\n\n34–35 줄에서 핸들러가 예상하는 입력을 정의하기 위해 타입 힌트를 사용합니다. 데이터 유효성 검사를 활성화했기 때문에 36 줄에 도달하면 파이다닉 오브젝트가 파싱되고 직렬화되어 일반 이벤트가 아닌 딕셔너리 형식으로 손에 넣게 됩니다. 제가 Annotated와 body typing 클래스를 사용하여 이벤트 핸들러가 본문 페이로드에 'CreateOrderInput' 클래스가 필요하며 JSON 딕셔너리이며 문자열이 아님을 알려주었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI 요청과 응답은 모두 그들을 정의하는 Pydantic 스키마를 가지고 있습니다. Pydantic 스키마 정의는 여기와 여기에서 찾을 수 있습니다.\n\n전체 핸들러 코드는 여기에서 찾아볼 수 있습니다.\n\n저는 아키텍처 레이어 컨셉에 따라 이 핸들러와 로직을 작성했는데, 이 내용은 AWS re:Invent 2023 세션에서도 다뤘어요. 자세한 내용은 여기를 클릭해 더 알아보세요.\n\n# OpenAPI Endpoint in Action\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 남은 일은 코드를 배포하고 스웨거 엔드포인트에 액세스하는 것뿐입니다.\n\n다음과 같은 모습일 것입니다:\n\n테이블 태그를 Markdown 형식으로 변경해보세요. \n\n스키마를 클릭하면 Pydantic 정의 출력이 제대로 된 OpenAPI 스키마로 표시되는 것을 확인할 수 있습니다. 설명, 제한 사항 및 유형이 포함됩니다.\n\n여기에서 실시간 버전의 스웨거를 확인할 수도 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://tzmt8vspl4.execute-api.us-east-1.amazonaws.com/prod/swagger\n\n# 제한 사항\n\n이 새로운 유틸리티에 꽤 감명받았어요. 그러나 몇 가지 제한 사항이 있습니다.\n\n이는 해결 가능하지만 Powertools 팀이나 커뮤니티로부터의 개발이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, OpenAPI 명세의 전체가 생성되지는 않습니다. 그럼에도 불구하고 저장소에 여전히 열려 있는 문제들이 있으며, 커뮤니티의 도움을 요청하고 있기 때문에 시도해보고 싶다면 의미 있는 첫 번째 기여가 될 수 있습니다!\n\n이제 더 중요한 문제로 넘어가겠습니다.\n\n작성 시점에서 여러 마이크로 함수를 사용하면 OpenAPI 생성이 지원되지 않습니다. 단일 람다만 지원됩니다. 제가 제안한 해결책으로 GitHub 이슈를 만들었으며, 이 문제에 대한 긍정적인 피드백을 주시면 사물을 움직이는 데 도움이 될 것입니다.\n\n# 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물에서는 AWS용 Powertools가 핸들러 코드에서 OpenAPI 문서를 생성하는 데 어떻게 도움을 줄 수 있는지 알아보았습니다. 이는 개발자가 코드와 해당 설명 문서를 소유하고, 무엇보다도 두 가지를 항상 동기화하는 방법에 대한 지원을 제공합니다.\n\n다음 글에서 제가 이 접근 방식을 어떻게 더 발전시킬 수 있는지, 상당히 중요한 것을 추가하여 코드와 API 설명 문서 사이의 소중한 동기화를 보호할 수 있는 방법에 대해 논의할 예정입니다. 함께 해주세요!","ogImage":{"url":"/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_0.png"},"coverImage":"/assets/img/2024-06-23-ServerlessAPIDocumentationwithPowertoolsforAWS_0.png","tag":["Tech"],"readingTime":8},{"title":"기본 웹 애플리케이션 아키텍처와 회고 핵심 개념 및 예시","description":"","date":"2024-06-23 00:17","slug":"2024-06-23-ReflectionsandBasicWebApplicationArchitecture","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_0.png\" /\u003e\n\n둘째 주가 끝나고, GitHub와 버전 관리에 대해 많이 배웠어요!\n\n이번 주에 저는 GitHub에서 저장소를 만들고, 커맨드 라인 인터페이스(CLI)를 사용하여 컴퓨터에 복제했어요. 또한 CLI로 커밋하고 README 파일을 GitHub에 푸시하고, 새로운 브랜치를 만들고, 파일을 업데이트하고, 풀 리퀘스트를 메인 브랜치에 병합하는 등 많은 작업을 할 수 있다는 것을 발견했어요. 게다가, 컴퓨터에 아마존 웹 서비스(AWS) CLI를 설치하고 연습했어요.\n\n이번 주에 웹 애플리케이션 아키텍처의 기본을 배우고, 배운 내용을 강화하기 위해 간단한 설정을 디자인하는 데 많은 시간을 보냈어요. AWS와 어떻게 관련이 있는지 알아볼까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 웹 애플리케이션 아키텍처\n\n그렇다면, 먼저 웹 애플리케이션 아키텍처는 무엇일까요?\n\n웹 애플리케이션 아키텍처는 웹 사이트가 어떻게 구성되어 작동하는지를 나타냅니다. 세 가지 주요 구성 요소가 있습니다: 프론트엔드, 백엔드 및 데이터베이스 (아래에 만든 다이어그램 참조). 프론트엔드는 당신이 보고 클릭하는 것들인데, HTML, CSS 및 JavaScript로 만들어진 버튼이나 사진과 같은 것들입니다. 백엔드는 웹 사이트의 뇌와 같습니다. 모든 로직과 처리를 처리하며 Python이나 JavaScript와 같은 언어를 사용합니다. 데이터베이스는 모든 정보가 저장되는 곳으로, 큰 디지털 파일 캐비닛처럼 작동합니다. 이러한 부분들은 웹을 통해 서로 대화하여 웹 사이트를 사용할 때 모든 것이 원활히 작동하도록 합니다. 아래는 모든 게 어떻게 작동하는지에 대한 이미지입니다.\n\n![웹 애플리케이션 아키텍처 다이어그램](/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 용어 설명\n\n위 다이어그램에 포함된 내용을 더 잘 설명하기 위한 어휘 목록입니다.\n\n최종 사용자: 제품이나 서비스를 사용하는 사람입니다. 이 경우에는 웹 애플리케이션과 상호 작용하는 사람으로, 휴대폰이나 태블릿과 같은 모바일 기기를 통해 웹 애플리케이션과 상호 작용하는 사람을 의미합니다.\n\n프론트엔드: 웹사이트나 앱의 일부로, 사용자가 보고 상호 작용하는 부분을 말합니다. 화면에 나타나는 모든 것인 버튼, 그림, 텍스트, 메뉴 등을 포함합니다. HTML, CSS, JavaScript와 같은 도구를 사용하여 멋지게 보이고 매끈하게 작동하도록 만들어집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도메인 이름 시스템(Domain Name System)은 전화번호부와 비슷해요. www.amazon.com 같은 웹사이트를 방문하려고 할 때 브라우저에 입력하면 DNS가 빠르게 웹사이트가 저장된 위치(IP 주소)를 찾아내고 컴퓨터에게 어떻게 찾아갈 지 알려줘요. 이렇게 하면 복잡한 주소를 알 필요 없이 원하는 웹사이트에 방문할 수 있어요. AWS Route 53은 AWS가 제공하는 DNS 서비스에요.\n\n백엔드는 모든 데이터와 정보가 저장되고 처리되는 곳이에요. 웹사이트에서 버튼을 클릭하여 메시지를 보내거나 물건을 구매하는 등의 작업을 할 때 백엔드가 그 요청을 처리해줘요.\n\n로드 밸런서는 웹사이트와 앱의 교통 관리자와 같아요. 많은 사람들이 동시에 웹사이트를 방문하려고 할 때, 로드 밸런서는 모든 요청을 처리하는 데 도움을 줘요. 각 서버에 일을 고르게 분배하여 한 대의 서버가 과부하되지 않게 해요. 그래서 웹사이트는 모든 사용자에게 빠르고 반응성 있는 상태를 유지할 수 있어요. AWS에서 로드 밸런서를 \"Elastic Load Balancer\"(ELB)라고 부르고 있어요.\n\n서버는 인터넷을 통해 다른 컴퓨터와 정보를 저장하고 공유하는 강력한 컴퓨터에요. 폰에서 웹사이트나 앱을 사용할 때 실제로 세계 어딘가의 서버에 연결하게 될 거예요. 이 서버는 온라인에서 보거나 상호작용하는 모든 사진, 비디오, 텍스트 등을 저장해요. 인터넷 상의 모든 것이 원할하고 빠르게 작동할 수 있도록 노력하며, 좋아하는 웹사이트와 앱에 언제든지 접속할 수 있도록 해줘요. AWS는 클라이언트가 활용할 수 있도록 전 세계의 큰 데이터 센터에 EC2 서버를 구축해 두고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스: 웹 애플리케이션 데이터베이스는 사용자 이름, 비밀번호, 사진 등 웹 사이트가 기억해야 하는 모든 중요한 정보를 보관하는 디지털 컨테이너와 같습니다. 웹 사이트에 가입하거나 댓글을 게시할 때 이 정보는 데이터베이스에 저장되어, 웹 사이트가 다음 방문 때에도 해당 정보를 기억할 수 있습니다. 데이터베이스는 웹 사이트의 모든 것이 원할하게 작동하고 정보가 안전하고 조직적으로 유지되도록 보장합니다. AWS RDS(관계형 데이터베이스 서비스)가 이러한 예시 중 하나입니다.\n\n# 반성\n\n2주차에는 일부 어려움이 있었지만 그때마다 능력이 더 향상된 것 같아요. 이 어려움들은 웹 개발 도구와 관행의 기본 원리에 대한 탐구의 여정으로 이끌어주었어요. GitHub를 이용해 저장소 생성, 복제, 명령 줄 인터페이스를 통한 버전 관리를 익혔고, AWS CLI를 탐험하며 앞으로의 프로젝트에서 귀중한 경험을 쌓을 수 있었어요.\n\n이번 주 중요한 부분 중 하나는 웹 애플리케이션 아키텍처를 이해하는 데 헌신했습니다. 웹 사이트가 원활하게 작동하도록 보장하는 설계도와 같다는 것을 배웠어요. 이는 세 가지 핵심 부분으로 구성되어 있어요: 사용자가 버튼과 시각적 요소와 상호작용하는 프론트엔드, 로직 처리와 배경에서의 처리를 담당하는 백엔드, 모든 웹 사이트 정보를 안전하게 저장하는 데이터베이스가 있어요. 이러한 구성 요소는 협력하여 통일된 사용자 경험을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미래를 기대하며, 웹 애플리케이션 아키텍처의 복잡성에 더 깊이 파고들기를 기대하고 있어요. 다음 주에는 이러한 기본 개념이 AWS 서비스와 어떻게 통합되어 내 이해력과 기술 세트를 더욱 향상시키는지 살펴볼 거에요. 클라우드 엔지니어링의 매혹적인 세계에 대한 더 많은 통찰력을 기대해 주세요!\n\n지금은 여기까지입니다!\n\nBlaize","ogImage":{"url":"/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_0.png"},"coverImage":"/assets/img/2024-06-23-ReflectionsandBasicWebApplicationArchitecture_0.png","tag":["Tech"],"readingTime":4},{"title":"몇 번의 클릭으로 IAM 정책 시각화 하는 방법","description":"","date":"2024-06-23 00:16","slug":"2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks","content":"\n\n우리 모두가 IAM 정책이 AWS 리소스를 보호하는 데 매우 중요하다는 것을 알고 있습니다. 그러나 IAM 정책을 시각화해 본 적이 있나요? 아니라면, 이 게시물이 도움이 될 것입니다. 이 게시물에서는 IAM 정책을 몇 번의 클릭만으로 시각화하는 방법을 살펴보겠습니다.\n\n# IAM 정책을 시각화하는 이유\n\n간단한 IAM 정책이 다중 명령문을 가진 시나리오를 고려해 봅시다. 각 명령문에는 여러 작업, 리소스 및 조건이 있습니다.\n\n예시:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n      \"Version\": \"2012-10-17\",\n      \"Statement\": [\n          {\n              \"Effect\": \"Allow\",\n              \"Action\": [\n                  \"s3:GetObject\",\n                  \"s3:PutObject\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          },\n          {\n              \"Effect\": \"Deny\",\n              \"Action\": [\n                  \"s3:*\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringNotEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          }\n      ]\n  }\n```\n\n이제 정책을 이해하려면 정책을 읽고 이해해야 합니다. 하지만, 여러 문과 조건이 포함된 복잡한 정책이 있는 경우는 어떨까요?\n\n예시:\n\n```js\n{\n      \"Version\": \"2012-10-17\",\n      \"Statement\": [\n          {\n              \"Effect\": \"Allow\",\n              \"Action\": [\n                  \"s3:GetObject\",\n                  \"s3:PutObject\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          },\n          {\n              \"Effect\": \"Deny\",\n              \"Action\": [\n                  \"s3:*\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringNotEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          },\n          {\n              \"Effect\": \"Allow\",\n              \"Action\": [\n                  \"s3:GetObject\",\n                  \"s3:PutObject\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          },\n          {\n              \"Effect\": \"Deny\",\n              \"Action\": [\n                  \"s3:*\"\n              ],\n              \"Resource\": \"arn:aws:s3:::my-bucket/*\",\n              \"Condition\": {\n                  \"StringNotEquals\": {\n                      \"s3:x-amz-acl\": \"public-read\"\n                  }\n              }\n          }\n      ]\n  }\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정책을 읽는 것만으로는 정책을 이해하기가 매우 어려울 것입니다. 여기에 IAM 정책 시각화가 등장합니다. IAM 정책을 시각화하여 쉽게 이해하고 필요한 경우 변경할 수 있습니다.\n\n# IAM 정책 시각화 방법\n\n- 이 사이트로 이동하십시오. 이 사이트는 Amazon의 보안 엔지니어인 BOUR Abdelhadi가 만들었습니다.\n\n![IAM Policies Visualization](/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. IAM 정책을 텍스트 영역에 붙여넣으세요. 이제 IAM 정책의 시각적 표현을 \"정책 시각화\" 섹션에서 볼 수 있습니다. 정책을 쉽게 이해하고 필요한 경우 변경할 수 있습니다.\n\n![IAM Policy Visualization 1](/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_1.png)\n\n![IAM Policy Visualization 2](/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_2.png)\n\n3. 조금 아래로 스크롤하면 \"이 정책이 하는 일은?\"을 평문으로 볼 수 있습니다. 이를 통해 정책을 간단하게 이해할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_3.png\" /\u003e\n\n여기까지입니다. 몇 번의 클릭으로 IAM 정책을 성공적으로 시각화했습니다.\n\nIAM 정책을 시각화해야 하는 이유에 대해 더 알아보세요: [여기를 클릭하세요](링크)\n\n사이트 제작자: BOUR Abdelhadi\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLinkedIn에서 연결해요: LinkedIn 프로필\n\n실전 프로젝트 살펴보기 (제 저장소가 도움이 된다면 GitHub에서 저를 팔로우하시는 것을 잊지 마세요): 내 GitHub 계정","ogImage":{"url":"/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_0.png"},"coverImage":"/assets/img/2024-06-23-VisualizeyourIAMPoliciesinJustaFewClicks_0.png","tag":["Tech"],"readingTime":4},{"title":"클라우드 보안 전략을 만드는 궁극적인 가이드","description":"","date":"2024-06-23 00:14","slug":"2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy","content":"\n\n\n![Cloud Security](/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_0.png)\n\n클라우드 보안은 처음에는 쉽지 않습니다.\n\n저는 지난 20년간 이 산업에서 일한 경험이 있으며, 그 중 마지막 5년은 클라우드에 전념했습니다.\n\n클라우드 보안 여정에서 가장 어려운 단계 중 하나는 클라우드 환경을 보호하기 위한 로드맵을 만드는 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난 몇 년 동안 클라우드 및 디지털 채택이 급증했으며, 적절한 로드맵이 없는 사이버 보안 팀은 후속 문제에 직면할 수 있습니다.\n\nCIO들과 CISO들이 앉아서 자신들의 클라우드 워크로드를 안전하게 보호하기 위한 최상의 접근 방식을 논의할 때, 상당한 양의 자료에 물들게 될 것입니다. 그것은 상당히 짜증날 수 있습니다!\n\n다양한 클라우드 구현 경험을 바탕으로, 나는 성공적인 클라우드 보안 구현을 위한 주요 성공 요소가 무엇인지 요약해 보기로 했습니다.\n\n로드맵을 세 가지 기본 단계로 나누었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기초\n- 실행\n- 최적화\n\n참고: 제 경험을 바탕으로 가능한 한 상세하게 작성하려고 노력했지만, 대부분의 회사에 적용하기에 너무 상세해서 실용적이지 않게 만드는 것은 피했습니다.\n\n# 단계 1: 기초 다지기\n\n클라우드 보안 프로젝트가 실패하는 가장 일반적인 이유 중 하나는 CISO가 단순히 온프레미스 모델을 클라우드에 그대로 복사하려는 것 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구름의 이해 부족은 매우 강력한 원천 기능이 무시되는 결과를 초래할 수 있습니다. 그러므로 여정을 시작하기 전에 적절한 기초를 마련하는 것이 매우 중요합니다.\n\n다음은 몇 가지 중요한 기본 요소들입니다.\n\n## A. 규정 환경 이해\n\n클라우드 보안 여정을 시작하기 전에, 특정 지리에 대한 규정을 알아야 하는 것이 결정적인 첫 번째 단계입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n올바르게 처리하지 않으면 권한이 없는 데이터를 이동할 수 있으며 엄격한 규정 위반으로 엄격한 벌금을 부과 받을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_1.png)\n\n특정 국가는 자국 데이터를 자국 이외로 이동할 수 없도록하며 규정 미준수에 대해 엄중한 벌금을 부과합니다.\n\n유익한 점은 대부분의 규정이 보안에 대한 최상의 실천 방법과 겹치기 때문에 적절한 프레임워크를 먼저 마련하면 나중에 작업량이 현저히 줄어듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHIPAA, PCI DSS 또는 SOC 2와 관련하여, 귀하의 법률 부서와 적절한 부문의 dos 및 don`ts를 완전히 숙지하기 위해 상호 협력하는 것이 중요합니다.\n\n매년 종일 감사를 하는 데 지치는 사이버 보안 팀에게 한 가지 놀라운 소식은 대부분의 클라우드 제공업체가 그들을 위해 많은 일을 처리한다는 것입니다.\n\nAWS, Azure 및 Google은 모두 매년 수백 개의 로컬 및 글로벌 인증을 실행하는 여러 제3자 프로그램을 보유하고 있으며, 이러한 인증은 수수료 없이 요청할 수 있습니다.\n\nAWS artifact는 AWS에 대한 수백 개의 보고서에 액세스할 수 있는 예시 중 하나입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_2.png\" /\u003e\n\n## B. 공유 책임 모델 이해\n\n공유 책임 모델은 클라우드에서 무언가를 구현하기 전에 미리 알아둬야 할 가장 중요한 것 중 하나입니다.\n\n클라우드에서 보안은 고객과 클라우드 제공업체가 함께 작업하여 환경을 안전하게 유지해야 하는 공유 책임이 되므로 이를 미리 알아두는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기반이 거의 다 마무리되었지만, 데이터와 애플리케이션에 대한 통제를 시행하여 귀하의 영역이 규정 준수를 하고 있는지 확인해야 합니다. \n\nAWS는 구름의 보안을 책임지고, 귀하는 구름 안에서의 보안을 담당합니다.\n\n![이미지](/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_3.png)\n\n이것은 사용하는 모델에 따라 달라질 수 있습니다 (완전히 관리되는 모델, IaaS 또는 플랫폼 등). 클라우드 제공업체는 귀하가 선택한 모델에 따라 일을 더 맡기거나 적게 맡을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_4.png\" /\u003e\n\n## C. 팀을 병렬적으로 강화하세요\n\nCISO이고 클라우드 보안 여정을 시작하는 경우, 팀 내에서 클라우드 기술을 구축하는 것이 중요한 기본 단계입니다.\n\n외부 컨설턴트에만 의존하지 마세요. 그들은 프로젝트가 끝나면 대개 떠나가고 내부 팀은 매일 운영을 맡게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n팀원들은 투자가 이루어지고 있기 때문에 이를 신뢰의 표시로 인식할 것입니다.\n\n# 단계 2: 클라우드 보안\n\n이제 클라우드에 대한 견고한 기본 지식과 규제 승인(희망적으로!)이 확보되었으니, 클라우드 환경을 안전하게 유지하는 방법을 살펴볼 차례입니다.\n\n말씀드린대로, 온프렘에서 사용 중인 도구 세트를 그대로 복사하려고 하지 마세요. 항상 네이티브 클라우드 서비스를 먼저 사용하려고 노력해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 단계는 팀에서 가장 많은 노력과 스트레스를 유발할 수 있는 단계 중 하나입니다.\n\n이 단계에서 가장 중요한 두 가지는 벤치마킹과 클라우드 보안 모델을 만드는 것입니다.\n\n## A. 벤치마킹\n\n클라우드에서 보안 상태를 즉시 파악하는 가장 좋고 빠른 방법은 보안 모베스트 프랙티스에 대한 벤치마킹을 활성화하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n좋은 소식은, 구글, Azure 및 AWS와 같은 공급 업체가 이미 사전 구성된 벤치마크를 제공하여 환경을 측정할 수 있습니다.\n\n첫 날부터 CIS 벤치마크를 활성화하여 클라우드 내에서 쉽고 빠른 보안 성과를 얻는다면, CISO를 기쁘게 만들 수 있는 좋은 방법일 것입니다.\n\n아래는 각 메이저 프로바이더에 대한 도구입니다:\n- AWS Security Hub\n- Azure Security Center (Microsoft Defender로 변경됨)\n- Google 규정 준수 센터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 외에도, 예산이 있는 경우에는 가시성을 얻을 수 있는 제3자 도구가 있습니다.\n\n참고: 1일차의 높음 / 중간 수의 갯수에 대해 걱정하지 마세요. 모든 환경에 정상입니다. 하지만 아무것도 놓치지 않도록 위험 추적이 프로세스로 구현되어 있는지 확인해 주세요.\n\n## B. 클라우드 보안 모델 구축하기\n\n벤치마크가 활성화되었다면, 이제는 환경을 위한 고수준 보안 프레임워크를 구현하는 시기입니다. 아래는 중점을 두어야 하는 주요 영역입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 신원 제어: 클라우드에서의 신원은 방화벽입니다. 그래서 이를 우선으로 생각해야 합니다. 그냥 MFA를 활성화하고 끝내지 마세요. 대신 신원을 위한 적절한 보안 생태계를 구축해야 합니다. 단일 사인온 시스템과 연결하여 클라우드에서 별도의 신원 집합을 관리할 필요가 없도록 하는 것이 가장 좋은 방법입니다.\n\n- 암호화: 암호화 제어는 클라우드로 들어가는 PCI, PII와 같은 민감한 데이터를 어떤 규정에 맞춰야 하는지에 따라 다를 것입니다. 데이터가 정지 상태에 있을 때와 전송 중에 대한 암호화 제어를 알아두세요. AWS 및 다른 클라우드 제공업체는 암호화 키를 다루는 뛰어난 관리 서비스를 제공하며, 이를 통해 내부에서 HSM을 관리하는 번거로움을 줄일 수 있습니다.\n\n- 로깅 및 경보: 클라우드에서 로깅 및 경보를 지나치게 하는 것은 매우 쉽습니다. 경보를 너무 적게 만들면 중요한 데이터를 놓치게 될 수 있고, 너무 많이 만들면 대응팀을 분주하게 만들어 경보 피로를 야기할 수 있습니다. 좋은 점은 이미 벤치마킹을 활성화했다면, 이러한 항목 중 많은 것을 경보로 변환하고 해당 사항을 추가하기만 하면 됩니다.\n\n- 작업 부하 보호: 클라우드 워크로드를 실행할 때 VM, 컨테이너 및 클러스터를 보호하고 안전하게 유지해야 합니다. VM은 안전한 이미지에서 시작해야 합니다. 컨테이너 이미지는 시작하기 전에 검사돼야 하며, 실행 시 보호는 전반적으로 제공되어야 합니다. 클라우드를 위한 최소 요구 사항으로 만드세요.\n\n- 위협 인텔리전스: 클라우드에서 가장 멋진 점 중 하나는 클라우드 제공업체 덕분에 얼마나 많은 위협 인텔리전스에 접근할 수 있는지입니다. Azure, Google 및 AWS는 고객이 혜택을 받는 위협 인텔리전스 기술에 수십억을 투자하고 있습니다. 이 데이터는 클라우드 서비스에 공급되어 공격의 조기 탐지를 가능케 합니다. 서비스는 초기에 활성화하여 첫날부터 학습을 시작하고 사전에 조치를 취할 수 있는 기준 값을 생성할 수 있도록 하세요.\n\n# 단계 3: 클라우드 최적화\n\n이 단계는 클라우드 제어에 대한 자신감을 키워나갈 때이며, 더 전략적인 작업에 집중할 수 있는 시기입니다. 이 단계에서 살펴볼 몇 가지 주요 영역은 아래와 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 알림을 자동으로 해결하도록 설정하여 보안 팀이 더 생산적으로 작업에 집중할 수 있도록 합니다.\n- 기존 알림 논리를 세부 조정하면 무엇이 작동하고 무엇이 그렇지 않은지 알 수 있습니다.\n- 이전 단계에서 부여된 클라우드 권한을 정리합니다. 지금쯤 누가 어떤 권한이 필요한지 알 수 있고 그에 맞게 조정할 수 있습니다.\n- Slack과 같은 협업 도구를 통해 도구 세트를 확장하면 보안 프로세스의 효율성을 크게 높일 수 있으며, 이메일 문화에서 벗어날 수 있습니다.\n\n## A. 리스크 검토\n\n첫 날부터 리스크 추적기를 유지해야했지만, 이제는 리스크 데이터베이스를 신중히 살펴보고 무엇을 유지할지와 관리부서가 수용해야 하는 것을 결정해야 합니다. 실용적으로 생각하고 완벽한 100% 완료된 리스크 추적기를 얻을 수 없음을 깨닫는 것이 중요합니다.\n\n수정할 수 있는 것은 추적하고, 수정할 수 있는 것은 닫아야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것은 주요 단계를 마무리하고 성공적인 클라우드 보안 여정으로 나아가게 도와줍니다.\n\n더 많은 세부 정보를 원하시면, 아래에서 만든 비디오를 확인해보세요.\n\n![이미지](/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_5.png)\n\n타이머 이즈랄은 핀테크 산업에서 사이버 보안 및 IT 리스크 관리 분야에서 20년 이상의 국제적 경험을 보유한 다중 수상 경력을 지닌 정보 보안 리더입니다. 타이머에게는 링크드인이나 그의 유튜브 채널 \"클라우드 보안 가이\"에서 연락할 수 있으며, 거기에서는 클라우드 보안, 인공지능 및 일반적인 사이버 보안 진로에 관한 조언을 정기적으로 게시하고 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_0.png"},"coverImage":"/assets/img/2024-06-23-TheUltimateGuideToCreatingACloudSecurityStrategy_0.png","tag":["Tech"],"readingTime":6},{"title":"클라우드 배포에서 CDK와 Terraform의 강력한 기능 활용하기","description":"","date":"2024-06-23 00:13","slug":"2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments","content":"\n\n![2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments](/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_0.png)\n\n# 소개\n\n클라우드로 애플리케이션을 배포하는 것은 현대 소프트웨어 개발의 중요한 부분이 되었습니다. AWS는 클라우드 배포를 용이하게 하는 서비스로 CloudFormation을 제공하며 AWS Cloud Development Kit(CDK) 같은 도구를 제공합니다. 동시에 Terraform은 다중 클라우드 제공 업체로 더 빠른 배포를 가능케 하는 인프라스트럭처의 코드(IaC)에 강력한 솔루션이 되었습니다. 이 글에서는 AWS CDK와 Terraform을 함께 사용하는 이점을 살펴보고 TypeScript에서 CDK를 사용하여 REST API를 생성하는 실용적인 예제를 살펴보겠습니다.\n\n# Terraform과 CDK란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테라폼과 CDK는 인프라를 코드로 정의하는 데 도움을 주는 주요 도구들입니다. 각 솔루션에는 각각의 장단점이 있습니다. 좀 더 자세히 알아보도록 하죠.\n\n## 테라폼\n\n테라폼은 HashiCorp에서 만든 도구로, HCL (HashiCorp Configuration Language)이라는 고수준 구성 언어를 사용하여 인프라를 정의할 수 있게 해줍니다. 테라폼은 클라우드에 독립적이며 AWS, Azure, Google Cloud Platform을 포함한 다양한 클라우드 제공 업체 간의 인프라를 관리할 수 있습니다. 또한 AWS의 경우 CloudFormation과 비교했을 때 빠른 배포를 가능하게 합니다.\n\n## AWS CDK\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS Cloud Development Kit (CDK)은 클라우드 인프라를 코드로 정의하고 AWS CloudFormation을 통해 프로비저닝하는 오픈 소스 소프트웨어 개발 프레임워크입니다. CDK는 TypeScript를 포함한 익숙한 프로그래밍 언어를 사용하여 애플리케이션을 모델링합니다. CDK는 코드를 사용하여 인프라를 생성하기 위해 일반적인 CloudFormation 템플릿을 생성합니다. 이 추상화로 인해 CDK를 사용하여 몇 줄의 코드로 매우 긴 CloudFormation 템플릿을 생성할 수 있습니다. 이는 개발자가 즐겨 사용하는 프로그래밍 언어로 편리하게 인프라 코드를 구현하고 유지할 수 있도록 도와줍니다.\n\n# Terraform과 CDK를 함께 사용하는 이점\n\n두 도구를 함께 사용하면 양쪽의 이점을 누릴 수 있습니다. Terraform은 HCL을 사용하지만 개발자에게는 불편할 수 있습니다. CDK는 몇 줄의 코드로 인프라를 구현하기 위한 고수준 재사용 가능한 CDK 구조를 제공함으로써 이를 해결합니다. 또한 매우 익숙한 프로그래밍 언어를 사용하기 때문에 개발자에게 친숙합니다.\n\n반면, CDK는 CloudFormation을 내부적으로 사용하며 이는 일반적으로 Terraform보다 느릴 수 있습니다. 그러나 CDK와 Terraform을 함께 사용할 때 Terraform을 사용하여 클라우드 배포를 수행하기 때문에 훨씬 빠른 클라우드 배포를 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 설정\n\nCDK를 사용하여 Typescript를 언어로 사용하여 Terraform 프로젝트를 설정해 봅시다. CDK를 Terraform에 사용하기 위한 몇 가지 선행 조건을 설정해야 합니다.\n\n- Terraform CLI\n- NodeJS\n- TypeScript\n- CDKTF CLI\n\n설정이 완료되면 프로젝트를 시작할 수 있습니다. 먼저, 초기 코드를 설정할 폴더를 만들어 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 CLI 명령어를 사용하여 프로젝트를 초기화할 수 있어요. 이 프로젝트에서는 TypeScript를 사용할 거에요.\n\n프로젝트를 초기화하고 나면, main.ts 파일을 업데이트하여 필요한 인프라를 정의할 수 있어요. main.ts 파일 안에 CDK 앱과 스택이 생성되어 있어요. 스택 내의 리소스를 필요에 맞게 업데이트하여 배포할 수 있어요. API Gateway 및 Lambda 함수를 사용하여 간단한 hello world REST API를 구축해보죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# REST API 구축\n\n어떤 AWS 리소스도 추가하기 전에, AWS를 클라우드 제공업체로 사용할 것이므로 Terraform에서 AWS 프로바이더를 구성해야 합니다. 또한, \n\nTerraform 백엔드를 저장하고 배포 상태를 추적하기 위해 S3 버킷을 사용할 수 있습니다.\n\n아래와 같이 필요한 CDK 생성물 (AwsProvider, S3Backend)과 같은 매개변수를 추가하여 간단히 구성할 수 있습니다.\n\n여기서 우리는 배포에 필요한 AWS 계정 ID와 지역을 제공함으로써 AWS 프로바이더를 구성했습니다. 마찬가지로, S3 백엔드를 구성하려면 버킷 이름과 다른 구성을 제공했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 람다 함수를 실행할 IAM 역할을 생성하고, 기본 람다 실행 역할의 권한을 포함시킵니다.\n\n이제 람다 함수를 생성할 시간입니다. src 폴더 내 index.ts 파일에 람다 함수 코드를 추가해 보겠습니다. 우리는 간단한 hello-world 애플리케이션을 구축하고 있으므로, 람다 함수는 간단한 hello-world 응답을 반환합니다.\n\n람다 함수 핸들러 구현을 추가한 후, 해당 핸들러를 참조하고 람다 함수 리소스를 생성하기 위해 CDK 구현을 추가할 수 있습니다.\n\n위 정의에 따라 함수 코드를 보관할 S3 버킷을 생성하고, 람다 함수를 만듭니다. 앞서 정의한 역할은 함수의 실행 역할로 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n람다 함수가 준비되면 이제 API Gateway REST API를 생성하고 람다 함수와 통합할 수 있습니다.\n\n여기서는 API Gateway를 위한 구성을 정의하고, /hello 경로를 위한 리소스 및 해당 /hello GET 엔드포인트에 대한 GET 메서드를 정의하고 있습니다. 마지막으로, 우리는 앞에서 만든 람다 함수와 프록시 통합으로 통합했습니다.\n\n모든 것이 올바르게 통합되었으므로 API Gateway에 스테이지를 생성하고 아래와 같이 배포를 생성할 수 있습니다.\n\n우리는 설정에서 만들고자 하는 스테이지 이름과 API를 제공했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 필요한 모든 리소스를 생성했습니다. 하지만 해야 할 일이 아직 하나 더 있어요. API Gateway 서비스가 제공된 람다 함수를 호출할 수 있도록 보장해야 합니다. 이를 위해 람다 함수 내에서 해당 작업을 허용하는 리소스 기반 정책을 생성하고 첨부해야 해요. LambdaPermission 구성을 사용하여 아래와 같이 쉽게 할 수 있어요.\n\n이 구성 요소는 람다 함수에 필요한 권한을 추가하여 앞서 생성한 API에 의해 호출될 수 있도록 해줘요. 이렇게 하면 구현이 완료됩니다.\n\n이제 모든 것이 배포할 준비가 됐어요. 인프라를 프로비저닝하기 위해 Terraform이 AWS에 액세스할 수 있도록 AWS 자격 증명을 올바르게 구성했는지 확인하세요. 먼저 코드를 빌드하고 아래 명령을 사용하여 배포할 수 있어요.\n\n![image](/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 명령을 실행하면 CDK for Terraform이 누락된 패키지가 있는 경우 설치되고 배포가 시작됩니다. 배포가 완료되면 생성된 리소스를 확인하고 API를 사용해 볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_4.png)\n\n게다가, 우리는 Terraform이 CloudFormation보다 배포를 훨씬 빠르게 실행한다는 것을 알 수 있습니다. 이는 무척 유리한 점입니다.\n\n만들어 둔 리소스를 삭제하려면 cdktf destroy 명령을 실행할 수 있습니다. 이렇게 하면 프로젝트에서 생성된 모든 리소스가 적절히 정리됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nAWS CDK를 Terraform과 함께 사용하면 클라우드 인프라를 효과적으로 관리하는 여러 가지 이점이 있습니다. CDK는 AWS와 깊게 통합되어 있으며 TypeScript와 같은 익숙한 프로그래밍 언어를 지원하여 AWS 리소스를 정의하는 것을 직관적이고 유지보수하기 쉽게 만듭니다. Terraform의 클라우드에 중립적인 기능은 여러 클라우드 제공업체에 걸쳐 원활한 관리를 가능하게 하여 CDK를 보완합니다. 이 조합은 유연성, 사용 편의성 및 모듈성을 제공하여 전체 인프라 관리 워크플로우를 향상시킵니다. 이 두 도구를 활용하면 배포 프로세스를 최적화하고 효율성을 향상시키며 더 견고하고 다양한 인프라 관리 솔루션을 구축할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_0.png"},"coverImage":"/assets/img/2024-06-23-UnleashingthePowerofCDKandTerraforminCloudDeployments_0.png","tag":["Tech"],"readingTime":5},{"title":"유니티 물리 시스템 메쉬 콜라이더 완벽 가이드","description":"","date":"2024-06-23 00:11","slug":"2024-06-23-UnityPhysicsMeshColliders","content":"\n\n너는 Unity를 사용하면서 메시 콜라이더를 본 적이 있을 거야. 하지만 정확히 뭘까?\n\n메시 콜라이더는 Unity가 해당 객체의 메시를 사용해 생성하는 콜라이더야. 예를 들어:\n\n![이미지](/assets/img/2024-06-23-UnityPhysicsMeshColliders_0.png)\n\n이 바럴이야. 메시 콜라이더 컴포넌트를 추가하면, 객체를 정확히 표현하는 콜라이더가 생성돼. 지금까지 다룬 다른 객체들처럼, 이 객체가 그냥 바닥으로 떨어지도록 원한다면.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게임을 실행하면 오류가 발생합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-UnityPhysicsMeshColliders_1.png\" /\u003e\n\n이 오류는 비볼록 메시 콜라이더에 키네마틱이 아닌 리짏바디가 연결된 경우 지원되지 않는다고 합니다. 키네마틱 리짏바디는 물리 엔진에서 무시되어 정체되고 물리 엔진에 영향을 받지 않아야 합니다.\n\n하지만 이것의 장점은 무엇일까요? 리짏바디를 isKinematic으로 설정하고 이 객체를 사용하여 씬의 다른 리짏바디에 영향을 줄 수 있습니다. 예를들어,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![sphere](https://miro.medium.com/v2/resize:fit:1400/1*Q7N3AFYNvo9bzu-BxBVkjw.gif)\n\nAs you can see, the sphere is affected by the shape of this barrel. If I use a non-convex mesh collider, the detail in the collider is slightly reduced, but it is still better than a capsule collider.\n\n![collider](/assets/img/2024-06-23-UnityPhysicsMeshColliders_2.png)\n\nUsing the non-convex option also gives you a visual of the collider Unity generates.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 테이블 태그를 Markdown 형식으로 변경해 주세요.\n\n\n| Header One | Header Two |\n|------------|------------|\n| Row 1 Col 1 | Row 1 Col 2 |\n| Row 2 Col 1 | Row 2 Col 2 |\n","ogImage":{"url":"/assets/img/2024-06-23-UnityPhysicsMeshColliders_0.png"},"coverImage":"/assets/img/2024-06-23-UnityPhysicsMeshColliders_0.png","tag":["Tech"],"readingTime":2},{"title":"초보자를 위한 Linux Debian에서 OpenGL 설정하는 방법","description":"","date":"2024-06-23 00:10","slug":"2024-06-23-ABeginnersGuidetoSetupOpenGLinLinuxDebian","content":"\n\n## OpenGL 설치를 위한 우분투에서의 단계별 가이드: 필요한 라이브러리인 GLFW 및 GLAD 설치와 함께.\n\n![이미지](/assets/img/2024-06-23-ABeginnersGuidetoSetupOpenGLinLinuxDebian_0.png)\n\n리눅스에서 OpenGL을 시작하려고 하지만 설정하는 데 충분한 자료를 찾지 못했나요? 걱정 마세요, 제가 도와드릴게요!\n이 문서에서는 VS Code를 사용하지 않고 우분투 및 다른 데비안 기반 리눅스 배포판에서 OpenGL 환경을 설정하는 간단한 지침을 제공할 것입니다. 우리는 또한 필수 라이브러리인 GLFW 및 GLAD를 설치할 것입니다.\n\nOpenGL 사용 방법에 대한 튜토리얼은 매우 기초부터 이해하기 쉬운 예제를 사용하여 가르치는 이 웹사이트를 추천합니다. 비디오 튜토리얼을 선호하는 경우 이를 확인하는 것이 좋습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 소개\n\nOpenGL은 크로스 플랫폼 및 크로스 언어 API로, 2D 및 3D 벡터 그래픽을 렌더링하는 데 사용할 수 있는 많은 함수 집합을 제공합니다. 이 API는 일반적으로 GPU와 상호 작용하여 하드웨어 가속 렌더링을 달성하는 데 사용됩니다.\n\n그러나 OpenGL 자체는 API가 아니라 단지 명세입니다. 각 함수의 결과물이 정확히 무엇이어야 하는지 및 어떻게 작동해야 하는지에 대한 설명일 뿐입니다. 제조업체가 명세를 따라 드라이버 내에 이미 구현했기 때문에 OpenGL을 별도로 \"설치\"하는 것은 없습니다. 그러나 운영 체제에 상호 작용하여 구현에 액세스하고 창 시스템 및 OpenGL 컨텍스트를 설정하는 ​​데 도움이 되는 라이브러리를 설치해야 합니다.\n\n# OpenGL 설정: 종속성 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n필요한 라이브러리를 설치하기 전에 몇 가지 종속성을 먼저 설치해야 합니다. 터미널을 열고 다음 명령어를 실행해주세요:\n\n```js\nsudo apt-get update\nsudo apt-get install cmake pkg-config\nsudo apt-get install mesa-utils libglu1-mesa-dev freeglut3-dev mesa-common-dev\nsudo apt-get install libglew-dev libglfw3-dev libglm-dev\nsudo apt-get install libao-dev libmpg123-dev\n```\n\n# OpenGL 설정: GLFW 라이브러리\n\n아름다운 그래픽을 생성하기 전에 OpenGL 컨텍스트를 초기화하고 그리기 위한 응용 프로그램 창을 생성해야 합니다. 이 작업을 위해 인기 있는 C 라이브러리인 GLFW(Graphics Library Framework)를 사용할 것입니다. 이 라이브러리는 조이스틱, 키보드 및 마우스로부터의 입력을 처리하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 명령어를 실행하면 시스템에 GLFW를 설치할 수 있어요:\n\n```js\ncd /usr/local/lib/\ngit clone https://github.com/glfw/glfw.git\ncd glfw\ncmake .\nmake\nsudo make install\n```\n\n# OpenGL 설치: GLAD 라이브러리\n\n알다시피, OpenGL은 귀하의 그래픽 카드가 지원하는 드라이버 내부에 구현된 사양에 불과해요. OpenGL 드라이버의 버전이 다양하기 때문에 대부분의 함수의 위치를 컴파일 시에 알 수 없으며 실행 시에 조회해야 해요. 함수의 위치를 찾아 해당 함수를 함수 포인터로 로드하는 것은 번거로운 과정일 수 있어요. 다행히도 이런 불편함을 덜어줄 수 있는 라이브러리가 있어요: GLAD.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGLAD (Multi-language Loader Generator)은 웹 서비스를 이용하여 사용자가 OpenGL 버전을 정의하고 해당 버전에 따라 모든 관련 OpenGL 함수를 로드할 수 있도록 하는 오픈 소스 라이브러리입니다.\n\n이 라이브러리를 설치하려면 다음 단계를 수행하십시오:\n\n- GLAD 웹 서비스로 이동합니다.\n- 언어를 C++로 설정하고 OpenGL 사양을 선택합니다.\n- API 섹션에서 최소 3.3 버전의 gl 버전을 선택하고 프로필을 Core로 설정하고 로더 생성 옵션이 선택되었는지 확인합니다.\n- 확장을 무시하고 Generate를 클릭하여 결과 라이브러리 파일을 생성합니다.\n- 지금쯤에 GLAD는 glad.zip이라는 두 폴더(include 및 src)를 포함하고 있는 zip 파일을 제공해야 합니다.\n- include 폴더 안의 폴더들(glad 및 KHR)을 include 디렉토리로 복사합니다: cp -R include/* /usr/include/\n- 이제 src 폴더 안의 glad.c 파일을 현재 작업 디렉토리로 복사합니다.\n\n# 첫 번째 OpenGL 프로그램 실행하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 필요한 라이브러리를 설치하는 작업이 완료되었습니다.\n모든 것이 올바르게 설치되었는지 확인해보는 시간입니다. \"Hello Triangle\"을 사용하여 삼각형을 렌더링하는 간단한 프로그램입니다. 여기서 코드를 복사하여 hello_triangle.cpp이라는 파일에 저장할 수 있습니다.\n\n우리의 코드를 컴파일하고 실행 파일 a.out을 생성해 봅시다:\n\n\ng++ hello_triangle.cpp glad.c -ldl -lglfw\n\n./a.out을 실행하여 프로그램이 작동하는지 확인해보세요. 아래와 같은 결과가 표시되어야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-23-ABeginnersGuidetoSetupOpenGLinLinuxDebian_1.png\" /\u003e\n\nOpenGL 설정이 완료되었습니다. 간단하고 성공적이었기를 바랍니다. 방금 복사한 소스 코드에 대해 더 알고 싶다면 이 글을 읽어보세요!\n\n질문이나 어디에 꼬였는지에 대한 문제가 있다면 자유롭게 댓글을 달아주세요. 최선을 다해 도와드리겠습니다!\n그리고 이 정보가 도움이 되었다면 박수를 치고 친구들과 공유해주세요!\n\n그럼 이만 준비되었습니다. 다음에 또 만나요! :))\n","ogImage":{"url":"/assets/img/2024-06-23-ABeginnersGuidetoSetupOpenGLinLinuxDebian_0.png"},"coverImage":"/assets/img/2024-06-23-ABeginnersGuidetoSetupOpenGLinLinuxDebian_0.png","tag":["Tech"],"readingTime":4},{"title":"Sennaar의 노래 꿈을 현실로 만드는 이야기","description":"","date":"2024-06-23 00:09","slug":"2024-06-23-ChantsofSennaarisaDreamComeTrue","content":"\n\n## 게임 | 언어\n\n나는 이 게임을 직접 체험하는 대신 게임 플레이 영상을 간단히 시청하고 싶었지만, 비디오를 2분밖에 못 보고 내가 이 게임을 반드시 스스로 구매해야 한다고 결정했다.\n\n언어학, 퍼즐, 그리고 아름다운 그래픽이 결합된 게임인가요? 나는 가입할게요! 나는 이 게임을 일주일 동안 완주했다. 10-7 직장과 앞뒤로 3시간씩 이동하는 것을 고려하면 꽤 빠르게 완료한 것이겠죠. 그만큼 게임을 좋아한다고 말할 수 있겠죠.\n\n# Chants of Sennaar란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSennaar의 노래는 바벨 탑에서 영감을 받은 퍼즐 게임입니다. 다양한 레벨을 통해 여행하면서 사람들이 사용하는 로고그래픽 언어를 해독하면서 노트북의 도움을 받게 됩니다. 플레이어가 모든 그래페임의 의미를 정확히 식별하면 언어가 학습된 것으로 간주되며, 전체 번역이 텍스트 위에 세계에서 표시됩니다.\n\n서로 다른 레벨은 각자의 문법 구조와 언어 특성을 가진 다른 언어를 가지고 있습니다. 다음 레벨로 진행하려면 언어를 배워야하며, 이를 통해 언어 장벽을 최종적으로 극복해야 합니다.\n\n## 시각적 단서\n\n이 게임을 플레이하는 것은 저의 영어 학습 초기 경험을 떠올리게 합니다. 대부분의 전문가들은 70-90%의 의사 소통이 비언어적이라고 믿고 있습니다. 언어를 이해하는 능력을 없애면 우리는 사람들이 무엇을 말하고 있는지를 몸짓으로 추론하기만 남게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n숨바꼭질 시나리오가 나에게 와 닿았다. 게임 디자이너들이 보편적으로 이해되는 어린이 게임을 활용해 플레이어들이 언어를 해독하는 데 이끌어 주었기 때문이다. 벽화에 있는 심볼의 의미를 즉시 이해하지 못할 수도 있지만, 몇 라운드의 숨바꼭질 끝에 어린이가 무엇을 의도했는지 이해할 수 있다. 이는 우리가 언어를 일상 상호작용을 통해 배우는 방법을 뛰어난 방법으로 보여주는 사례이다.\n\n게다가, 이 게임은 전체 게임 중에 우리를 유아로 다룰 필요를 느끼지 않는다. 반면에 디자이너들은 우리로 하여금 레벨의 모든 코너와 구석 구석을 탐험하도록 허용하며, 시각적인 단서를 꽉 채워 두었다. 그들은 우리를 서두르지도 않는다. 우리로 하여금 추측하고 오류를 범하게 하며, 그들의 힌트를 신뢰한다. 글리프가 서로에 맞물리는 방식(소잡소리)에 어떻게 어떤 단어가 실체화의 기둥 내에 있는 식물 상징인지 알게 되었을 때의 유레카 순간은 더욱 아름다웠다. 이 깨달음은 몇 가지 더 글리프를 해결할 수 있게 하여, 첫 번째 언어를 순식간에 완성할 수 있도록 도와주었다.\n\n《Chants of Sennaar》는 현실에서 어떻게 언어를 배우는지를 밀접히 흉내내며 시각적으로 놀라운 게임으로 계발되었다. 우리는 모두 시행착오와 비언어적 의사소통을 통해 조금씩 언어를 배우고, 언어 여정에서 다음 단계로 나아가기 위해 계속 퍼즐을 풀고 있다. 이러한 언어 습득 프로세스의 게이미피케이션을 보았을 때 나의 언어학적 심장은 큰 기쁨을 느끼게 했다.\n\n# 플레이어 관점에서\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론, 게임 세계에 완전히 몰두하면서 탐험할 유연성에 감사했지만, 게임 중간에 다음 퍼즐을 어떻게 해결해야 할지 확신하지 못한 순간이 있었습니다. 손에 모든 정보가 있더라도 어디로 가야 하는지 모른 채로 멈춰있을 때는 답답할 수 있습니다.\n\n예를 들어, 첫 번째 레벨에서 정원의 저장소에 접근하는 방법이 명확하지 않았고, 교회에서 퍼즐을 해결한 후에는 길을 잃은 채로 남아 있었습니다. 방의 미로도 도움이 되지 않았으며, 탐험할 부분이 많다는 것에는 기쁘지만, 게임이 그 부분에서 조금 더 안내를 해주었으면 하는 바램이 있습니다.\n\n또한, 게임의 중심이 언어 해독에 있었기 때문에, 각 레벨마다 다섯 가지 언어를 해결하도록 요청하는 대신 언어와 더 많은 시간을 보낼 수 있었으면 좋았겠다고 생각했습니다. 일부 언어는 연결되어 있지만, 언어 해독에 집중하기 쉬워서 이야기 속에서 어디에 있는지 잊기 쉽습니다.\n\n그렇다고 해서, 아마도 그게 게임이 우리에게 원래 원하던 것이었을지도 모릅니다; 탑을 올라가면서 언어의 세계에 잃혀 있는 것이죠. 언어학 전공자로서 언어와 게임 플레이를 결합하는 꿈이 이뤄진 것을 본인이 굉장히 느꼈고, 그것은 '찬츠 오브 세나르'의 훌륭한 실행 덕분이라고 말씀드리고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저의 게임 리뷰 중 하나를 읽어 주셔서 감사합니다! 제 글을 즐겁게 읽으셨다면 다른 기사들도 미디엄에서 확인해보세요. 여기서도 제 소셜 미디어 계정을 확인하실 수 있어요!","ogImage":{"url":"/assets/img/2024-06-23-ChantsofSennaarisaDreamComeTrue_0.png"},"coverImage":"/assets/img/2024-06-23-ChantsofSennaarisaDreamComeTrue_0.png","tag":["Tech"],"readingTime":3}],"page":"5","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"5"},"buildId":"o1YmnmSuZvAX2O4TI9r41","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>