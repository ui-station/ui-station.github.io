<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/2" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/2" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-a9851699c2b6bcaf.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_buildManifest.js" defer=""></script><script src="/_next/static/bb_yO9GbCvdfc_n71SfUf/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Kotlin Flows 기본 개념 이해하기" href="/post/2024-06-23-KotlinFlowsFundamentals"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kotlin Flows 기본 개념 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-KotlinFlowsFundamentals_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kotlin Flows 기본 개념 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Kotlin Flows 기본 개념 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ" href="/post/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법" href="/post/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">30<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Callback 대신 Coroutine 사용하는 방법" href="/post/2024-06-23-HowtouseaCoroutineinsteadofCallback"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Callback 대신 Coroutine 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtouseaCoroutineinsteadofCallback_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Callback 대신 Coroutine 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Callback 대신 Coroutine 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="WhatsApp 앱을 삭제하면 일어나는 일 정확히" href="/post/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="WhatsApp 앱을 삭제하면 일어나는 일 정확히" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="WhatsApp 앱을 삭제하면 일어나는 일 정확히" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">WhatsApp 앱을 삭제하면 일어나는 일 정확히</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까" href="/post/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법" href="/post/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안드로이드 UI 레이어 속성 완전 정복  Part 2" href="/post/2024-06-23-CrashCourseontheAndroidUILayerPart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드 UI 레이어 속성 완전 정복  Part 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드 UI 레이어 속성 완전 정복  Part 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">안드로이드 UI 레이어 속성 완전 정복  Part 2</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">16<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="기초부터 배우는 Kotlin 코루틴 사용법" href="/post/2024-06-23-KotlinCoroutinesFundamentals"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="기초부터 배우는 Kotlin 코루틴 사용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="기초부터 배우는 Kotlin 코루틴 사용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">기초부터 배우는 Kotlin 코루틴 사용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시스템 설계를 처음부터 배우기 레슨 1" href="/post/2024-06-23-StartingfromScratchSystemDesignLesson1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시스템 설계를 처음부터 배우기 레슨 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-StartingfromScratchSystemDesignLesson1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시스템 설계를 처음부터 배우기 레슨 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">시스템 설계를 처음부터 배우기 레슨 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link posts_-active__YVJEi" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Kotlin Flows 기본 개념 이해하기","description":"","date":"2024-06-23 23:34","slug":"2024-06-23-KotlinFlowsFundamentals","content":"\n지난 주에는 Kotlin 코루틴에 대해 더 알아보았어요. 이전 글에서는 CoroutineContext, CoroutineScope, Coroutine Builder 등 코루틴의 기초 중 일부에 초점을 맞췄죠. 약속대로, 지금은 그에 대한 후속 글로 Flows에 대해 다루려고 해요.\n\n# Flows가 뭔가요?\n\n비동기로 계산할 수 있는 데이터의 스트림을 Flow라고 합니다. Flow는 LiveData와 RxJava 스트림과 같이 옵저버 패턴을 구현할 수 있게 해줍니다. 옵저버 패턴은 상태 변경이 일어날 때 해당 상태를 관찰하는 객체(소스)와 그 상태 변경을 자동으로 알리는 의존 객체들(수집자)으로 이루어진 소프트웨어 디자인 패턴입니다. Flow는 일시 중지 함수를 사용하여 값을 비동기적으로 생성하고 소비합니다.\n\nFlow를 생성하려면 먼저 프로듀서를 만들어야 해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nval randomFlow: Flow\u003cInt\u003e = flow {\nrepeat(10) { it -\u003e\nemit(it+1) // flow에 대한 요청 결과를 내보낸다\ndelay(1000) // 코루틴을 1초 동안 일시 중단한다\n}\n}\n\nFlow를 수집하려면 먼저 Flow가 내부적으로 코루틴에서 작동하기 때문에, Coroutine을 시작해야 합니다. collect 연산자는 emit된 값들을 수집하는 데 사용됩니다.\n\n```kotlin\nlifecycleScope.launch {\n    viewModel.uiStateFlow.collect { it -\u003e\n        binding.uiText.text = it.toString()\n    }\n}\n```\n\nFlow에는 두 가지 서로 다른 유형이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Cold Flow — 값을 수집하기 시작할 때까지 값을 생성하지 않습니다. 오직 하나의 구독자만 가질 수 있으며 데이터를 저장하지 않습니다.\n\n```js\n// Regular Flow 예시\nval coldFlow = flow {\n     emit(0)\n     emit(1)\n     emit(2)\n}\n\nlaunch { // 처음으로 collect를 호출\n    coldFlow.collect { value -\u003e\n        println(\"cold flow collector 1이 받은 값: $value\")\n    }\n\n    delay(2500)\n\n  // 두 번째로 collect를 호출\n  coldFlow.collect { value -\u003e\n        println(\"cold flow collector 2이 받은 값: $value\")\n    }\n}\n\n// 결과\n// 두 수집자는 처음부터 모든 값을 받게 됩니다.\n// 두 수집자에 대해 해당 Flow는 처음부터 시작합니다.\nflow collector 1이 받은 값: [0, 1, 2]\nflow collector 1이 받은 값: [0, 1, 2]\n```\n\n- Hot Flow — 아무도 수집하지 않아도 값을 생성합니다. 여러 구독자를 가질 수 있으며 데이터를 저장할 수 있습니다.\n\n```js\n// SharedFlow 예시\nval sharedFlow = MutableSharedFlow\u003cInt\u003e()\n\nsharedFlow.emit(0)\nsharedFlow.emit(1)\nsharedFlow.emit(2)\nsharedFlow.emit(3)\nsharedFlow.emit(4)\n\nlaunch {\n    sharedFlow.collect { value -\u003e\n        println(\"SharedFlow 수집자 1이 받은 값: $value\")\n    }\n\n    delay(2500)\n\n  // 두 번째로 collect를 호출\n  sharedFlow.collect { value -\u003e\n        println(\"SharedFlow 수집자 2이 받은 값: $value\")\n    }\n}\n\n// 결과\n// 수집자는 수집을 시작한 곳부터 값을 받습니다.\n// 여기서 1번째 수집자는 모든 값을 받게 됩니다. 하지만 2번째 수집자는\n// 2500밀리초 후에 수집을 시작했기 때문에 그 이후에 방출된 값만을 받습니다.\nSharedFlow 수집자 1이 받은 값: [0, 1, 2, 3, 4]\nSharedFlow 수집자 2이 받은 값: [2, 3, 4]\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 cold flow라도 stateIn() 및 shareIn() 연산자를 사용하여 각각 뜨거운 flow로 변환할 수 있습니다.\n\n## SharedFlow 및 StateFlow\n\n- StateFlow — StateFlow는 한 번에 하나의 값을 보유하는 상태를 나타내는 뜨거운 flow입니다. 또한 conflated flow이며, 새 값이 발행될 때 가장 최근 값이 보존되고 즉시 새 수집기에 발행됩니다. 상태에 대한 단일 진실 원천을 유지하고 모든 수집기를 자동으로 최신 상태로 업데이트해야 할 때 유용합니다. 항상 초기 값이 있으며 최신으로 발행된 값만 저장합니다.\n\n```js\nclass HomeViewModel : ViewModel() {\n\n    private val _textStateFlow = MutableStateFlow(\"Hello World\")\n    val stateFlow =_textStateFlow.asStateFlow()\n\n    fun triggerStateFlow(){\n        _textStateFlow.value=\"State flow\"\n    }\n}\n\n// Activity/Fragment에서 StateFlow 수집\nclass HomeFragment : Fragment() {\n    private val viewModel: HomeViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\nlifecycleScope.launchWhenStarted {\n\n  // Flow를 트리거하고 값 수집 시작\n\n  // collectLatest()는 Kotlin의 Flow API의 고차 함수로\n  // Flow로부터 발행된 값을 수집하고 최신 값에 대해 변환할 수 있는 함수입니다.\n  // 모든 발행된 값들을 수집하는 collect()와 유사하지만,\n  // collectLatest는 최신으로 발행된 값만 처리하고\n  // 아직 처리되지 않은 이전 값들을 무시합니다.\n    viewModel.stateFlow.collectLatest {\n          binding.stateFlowButton.text = it\n    }\n  }\n}\n\n// Compose에서 StateFlow 수집\n@Compose\nfun HomeScreen() {\n // Compose는 flow에서 값을 수집하고 사용할 최신 값을 제공하는\n // collectAsStateWithLifecycle 함수를 제공합니다.\n // 새로운 flow 값이 발행되면 업데이트된 값을 얻고,\n // 재구성을 통해 값의 상태를 업데이트합니다.\n // LifeCycle.State.Started를 기본값으로 사용하여 수집을 시작합니다.\n // 지정된 상태의 라이프사이클에 있을 때 값 수집을 시작하고,\n // 해당 상태 아래로 떨어질 때 멈춥니다.\n  val someFlow by viewModel.flow.collectAsStateWithLifecycle()\n\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- SharedFlow — SharedFlow는 여러 개의 수집기(collector)를 가질 수 있는 HotFlow입니다. 수집기들과 독립적으로 값을 방출할 수 있으며, 다수의 수집기들이 동일한 flow에서 값을 수집할 수 있습니다. 하나의 값을 여러 수집기에 브로드캐스팅하거나 동일한 데이터 스트림에 대해 여러 구독자를 가질 때 유용합니다. 초기값이 없으며, 새롭게 추가된 수집기들을 위해 이전에 방출된 값을 일정 수만큼 저장할 replay 캐시를 구성할 수 있습니다.\n\n```js\nclass HomeViewModel : ViewModel() {\n    private val _events = MutableSharedFlow\u003cEvent\u003e() // 비공개 mutable shared flow\n    val events = _events.asSharedFlow() // 외부에 노출된 읽기 전용 shared flow\n\n    suspend fun produceEvent(event: Event) {\n        _events.emit(event) // 모든 구독자가 받을 때까지 실행이 중단됩니다\n    }\n}\n\n// Activity/Fragment에서 StateFlow 수집\nclass HomeFragment : Fragment() {\n    private val viewModel: HomeViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        lifecycleScope.launchWhenStarted {\n\n            // 플로우를 트리거하고 값을 수신하기 시작합니다\n\n            // collectLatest()는 Kotlin의 Flow API에서 제공되는 고차 함수로,\n            // Flow에서 방출된 값을 수집하고 최신 값에 대해 변환을 수행할 수 있습니다.\n            // collect()와 유사하게 모든 방출된 값을 수집하는데 사용되지만,\n            // collectLatest는 최신 값만 처리하고 아직 처리되지 않은 이전 값들을 무시합니다.\n            viewModel.events.collectLatest {\n                binding.eventFlowButton.text = it\n            }\n        }\n    }\n}\n\n// Compose에서 StateFlow 수집\n@Compose\nfun HomeScreen() {\n    // Compose는 collectAsStateWithLifecycle 함수를 제공하며,\n    // 플로우에서 값을 수집하고 필요한 최신 값을 제공합니다.\n    // 새로운 플로우 값이 방출되면 업데이트된 값을 얻고,\n    // 값의 상태를 업데이트하기 위해 다시 조합(composition)이 발생합니다.\n    // 기본적으로 LifeCycle.State.Started를 사용하여 수집을 시작하고,\n    // 지정된 상태에 있을 때 값을 수집하며, 해당 상태보다 낮아지면 중지합니다.\n    val someFlow by viewModel.events.collectAsStateWithLifecycle()\n}\n```\n\n# 플로우에서 예외 처리\n\nKotlin Flow는 예외와 오류를 처리하기 위한 여러 메커니즘을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- try-catch 블록 — 예외를 처리하는 기본적인 방법 중 하나는 흐름 내에서 try-catch 블록을 사용하는 것입니다.\n\n```js\nflow {\n    try {\n        emit(productsService.fetchProducts())\n    } catch (e: Exception) {\n        emitError(e)\n    }\n}\n```\n\n- catch 연산자 — Flow의 catch 연산자를 사용하면 예외를 한 곳에서 오류 처리 논리를 캡슐화하여 처리할 수 있습니다.\n\n```js\nflow {\n    emit(productsService.fetchProducts())\n}.catch { e -\u003e\n    emitError(e)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- onCompletion Operator — Flow가 성공적으로 또는 예외로 완료되고 난 후 코드를 실행할 때 사용됩니다.\n\n```js\nflow {\n    emit(productsService.fetchProducts())\n}.onCompletion { cause -\u003e\n    if (cause != null) {\n        emitError(cause)\n    }\n}\n```\n\n- 사용자 정의 오류 처리 — Android의 복잡한 시나리오에서는 애플리케이션에 적합한 방식으로 오류를 처리하기 위해 사용자 정의 연산자나 확장 함수를 만들 수 있습니다.\n\n```js\nfun \u003cT\u003e Flow\u003cT\u003e.sampleErrorHandler(): Flow\u003cResult\u003cT\u003e\u003e = transform { value -\u003e\n    try {\n        emit(Result.Success(value))\n    } catch (e: Exception) {\n        emit(Result.Error(e))\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Flows vs LiveData\n\n- LiveData는 라이프사이클을 인식하므로 옵저버의 라이프사이클을 자동으로 관리하여 옵저버가 활성 상태인 경우에만 업데이트가 전달됩니다. 반면에 Flow는 기본적으로 라이프사이클을 인식하지 않습니다. Compose에서는 collectLatest() 또는 collectAsStateWithLifecycle() 함수를 사용하여 Flow로부터 결과를 수집할 수 있습니다.\n- Flow는 더 많은 유연성을 제공하며 더 복잡한 비동기 데이터 작업에 적합하며, LiveData는 일반적으로 간단한 UI 업데이트에 사용됩니다.\n- Flow는 백프레셔(backpressure)를 내장 지원하여 데이터 방출 및 처리 속도를 제어할 수 있지만, LiveData는 백프레셔 처리를 지원하지 않습니다.\n- Flow는 순차적 및 구조화된 처리를위한 다양한 연산자를 제공하며, LiveData는 옵저버에게 최신 데이터를 제공하는 데 중점을 둡니다.\n\n읽어 주셔서 감사합니다! 이 기사가 유익하고 즐거우셨기를 바랍니다. 의견은 댓글 섹션에 남겨 주세요.\n\n좋은 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-06-23-KotlinFlowsFundamentals_0.png"},"coverImage":"/assets/img/2024-06-23-KotlinFlowsFundamentals_0.png","tag":["Tech"],"readingTime":9},{"title":"샤오미 휴대폰 배터리 과소비 해결 방법  자주 묻는 질문 FAQ","description":"","date":"2024-06-23 23:32","slug":"2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ","content":"\n샤오미 폰의 가장 중요한 장점 중 하나로 높은 배터리 용량이 손꼽히죠. 그러나 가끔씩은 샤오미 폰의 배터리 소모가 예상보다 빠르게 느껴질 수도 있어요. 안드로이드 시스템이 샤오미 폰의 빠른 배터리 소모의 주요 원인일 수 있답니다.\n\n이 글에서는 핸드폰의 배터리 소모 원인을 식별하고 샤오미 폰의 빠른 배터리 소모를 고치는 방법을 설명할 거에요. 또한 샤오미 폰의 배터리 수명을 연장하는 방법에 대해서도 다뤄볼 거예요.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_0.png)\n\n## 샤오미 어플리케이션의 배터리 사용량을 확인해보세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n첫 번째 단계에서는 Xiaomi 폰에서 배터리가 빨리 소모되는 원인 앱을 확인해야 합니다.\n\n- Xiaomi 폰 설정으로 이동합니다.\n- 앱 목록과 배터리 사용량을 확인하려면 아래로 스크롤합니다.\n- 어떤 앱이 과도한 배터리 소모를 일으키는 경우 해당 앱의 백그라운드 활동이나 배터리 사용량을 제한할 수 있습니다. 해당 앱을 삭제하고 대신 웹 버전을 사용할 수도 있습니다.\n\n# 배터리 빠른 소모의 주된 원인인 msa 비활성화\n\n만약 Android 시스템이 배터리를 빠르게 소모하는 경우 msa를 비활성화해야 합니다. Msa는 MIUI 시스템 광고를 의미하는 MIUI 시스템 광고(MIUI System Ads)의 약자입니다. msa를 비활성화하면 더 이상 많은 MIUI 시스템 광고를 볼 수 없습니다. 이 앱이 필요하지 않으며 비활성화해도 Xiaomi 폰에 해가 되지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설정으로 이동하세요.\n- \"비밀번호 및 보안\" 섹션으로 이동하세요.\n- \"인가 및 취소\"를 탭하세요.\n- 이제 새 페이지에서 msa를 비활성화할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_1.png)\n\n# 보안 앱 업데이트 제거 방법\n\n- 기기의 설정으로 이동하세요. 앱 섹션으로 이동하세요.\n- 앱 관리 페이지를 열고 화면 상단의 세 개의 점이 모인 아이콘을 탭하세요.\n- 이제 \"모든 앱 표시\" 옵션을 선택하고 새 목록에서 보안 앱을 찾으세요.\n- 앱을 찾으면 업데이트를 제거하려면 \"업데이트 제거\"를 선택하세요. 앞으로 이 앱을 업데이트하지 않고 배터리 소모 문제를 피하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Google Play 서비스 데이터 지우기\n\n매달 다음 단계를 반복하세요:\n\n- 핸드폰 설정으로 이동하세요. 앱 섹션으로 이동하여 \"앱 관리\"를 탭합니다.\n- Google Play 서비스를 찾아 클릭합니다.\n- 화면 하단에 있는 \"데이터 지우기\" 옵션을 선택하세요.\n\n# 앱 권한 확인하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설정으로 이동하세요.\n- \"개인 정보\"로 이동한 다음 \"권한 관리자\"로 이동하세요.\n- 새 페이지에서 핸드폰의 다양한 앱의 권한을 변경할 수 있습니다. 예를 들어, 구글 맵과 같이 필수 앱 이외의 앱들이 위치 정보에 접근하는 것을 허용하지 않을 수 있습니다.\n\n# 기본 Xiaomi 앱 비활성화\n\n다운로드와 같은 기본 시스템 앱을 비활성화하려면 Google Play의 MIUI 앱에 대한 숨겨진 설정을 설치하세요. 이 앱에서 \"애플리케이션 관리\"를 탭하여 MIUI의 숨겨진 설정 페이지를 열 수 있습니다. 이 페이지에서 사용하지 않는 Xiaomi 앱을 비활성화하거나 제거할 수 있습니다. 기본 앱을 제거해도 핸드폰에 해를 끼치지 않지만, 다이얼러 및 MIUI 프레임워크와 같이 핸드폰 성능과 관련된 앱을 비활성화하면 안됩니다.\n\n# Wi-Fi 스캐닝 및 블루투스 스캐닝 끄기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n샤오미 폰의 위치 설정으로 이동해주세요. 이 설정을 찾을 수 없는 경우, 제어 센터를 아래로 스와이프하여 위치 아이콘을 길게 누르세요. 그런 다음, 위치 서비스로 이동하여 Wi-Fi 스캔 및 블루투스 스캔을 해제하세요.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_2.png)\n\n# 샤오미 폰의 급속 배터리 배출을 방지하는 조치\n\n샤오미 폰은 우수한 성능과 저렴한 가격으로 유명하지만, 다른 스마트폰과 마찬가지로 배터리 소모 문제가 발생할 수 있습니다. 샤오미 폰을 계속 충전해야 하는 번거로움을 느끼신다면, 배터리 수명을 연장하는 여러 가지 방법이 있습니다. (이 부분의 절반은 AI의 도움으로 작성되었습니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 다크 모드 활성화: 샤오미 핸드폰에서 다크 모드나 어두운 테마를 활성화하면 배터리 수명을 보존하는 데 도움이 됩니다. 밝은 모드보다 조명이 적게 필요하기 때문에 다크 모드가 더 적은 전력을 사용합니다.\n- 항상 켜진 디스플레이 끄기: 항상 켜진 디스플레이는 폰을 잠그고 있을 때도 중요한 정보를 화면에 표시해주는 유용한 기능이지만, 이 기능은 많은 배터리 소모를 일으킬 수 있습니다. 끄면 배터리 수명이 향상될 수 있습니다.\n- 핫스팟 끄기: 핸드폰을 핫스팟으로 사용하는 것은 편리할 수 있지만 배터리를 빨리 소모시킬 수 있습니다. 핫스팟 기능을 사용하지 않는 경우에는 꺼두는 것이 좋습니다.\n- 샤오미 위치 끄기: 이 기능을 사용하지 않는 경우도 끄기.\n- 햅틱 피드백 끄기: 화면을 터치할 때 진동이나 햅틱 피드백도 많은 배터리 소모를 일으킬 수 있습니다. 이 기능을 끄면 배터리 수명이 늘어날 수 있습니다.\n- Mi 계정 로그아웃: Mi 서비스나 앱을 사용하지 않는 경우, Mi 계정에서 로그아웃하세요. 이렇게 하면 배터리를 소모할 수 있는 백그라운드 프로세스를 줄일 수 있습니다.\n- Google Play 스토어에서 앱 업데이트: Google Play에서 앱을 업데이트하면 버그를 수정하고 성능을 개선할 수 있어 배터리 소모도 줄일 수 있습니다.\n- 안드로이드 운영 체제 업데이트: 안드로이드 OS를 최신 상태로 유지하면 핸드폰 성능과 배터리 수명을 향상시킬 수 있습니다. 최신 업데이트가 나오면 반드시 설치하세요.\n- 불필요한 앱 삭제: 사용하지 않는 앱이 백그라운드에서 실행되어 배터리를 소모할 수 있습니다. 이러한 앱들을 삭제하면 핸드폰 배터리 수명을 향상시킬 수 있습니다.\n- 배터리 절약 모드 사용하기.\n- 핸드폰을 80%까지만 충전하기: 핸드폰을 80%까지만 충전하고 플러그를 뽑으면 배터리 수명이 향상될 수 있습니다. 배터리가 30% 이하로 내려가면 다시 80%까지 충전하는 것이 좋습니다.\n- 충전 중에 핸드폰 사용 피하기: 핸드폰을 충전하면서 사용하면 발열되어 배터리에 손상을 줄 수 있습니다. 충전 중에 핸드폰 사용을 피하고 케이스를 제거하는 것이 좋습니다.\n- 샤오미 핸드폰 배터리 교정하기.\n- 공식 충전기 사용하기: 가짜 충전기는 샤오미 배터리에 심각한 손상을 줄 수 있습니다. 다른 휴대폰의 충전기나 다른 샤오미 핸드폰의 충전기를 사용하지 말아주세요.\n- 마지막에 핸드폰을 끄고 다시 켜기.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_3.png)\n\n# 샤오미 핸드폰 공장 초기화\n\n이전 방법을 시도해도 샤오미 핸드폰의 빠른 배터리 소모 문제를 해결할 수 없다면 공장 설정으로 복원할 수 있습니다. 이를 하기 전에 데이터(사진, 비디오, 노트, 메시지, 연락처 등)를 백업해두는 것이 좋습니다. 공장 초기화를 하면 모든 데이터가 지워지니 유의하세요. 아래 단계를 따라하세요:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Xiaomi 핸드폰의 설정으로 이동하세요.\n- \"휴대폰 정보\"를 클릭하세요.\n- 먼저 \"백업 및 재설정\"을 선택한 다음 \"공장 데이터 초기화\"를 선택하세요.\n- 새 페이지의 지시에 따라 진행하세요.\n\n![이미지](/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_4.png)\n\n# 결론\n\n가끔 안드로이드 시스템이 Xiaomi 핸드폰의 배터리를 빠르게 소모시킬 수 있습니다. 문제를 식별하고 MSA를 비활성화하고 초기화를 수행하여 배터리 소모 속도를 줄일 수 있으며, 핸드폰을 충전한 후 좀 더 긴 사용 시간을 즐길 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 전화가 배터리가 빈다고 비어 있지 않을 때도 자주 꺼지는 등의 문제가 발생하면, 배터리 소모 문제 외에도 전화를 조사해볼 전문 기술자와 상의하는 것이 좋습니다.\n\n어떤 조언이 빠른 배터리 소모 문제를 해결하는 데 도움이 되었나요? 여러분의 경험을 공유하고 다른 사람들을 도울 수 있는 코멘트를 남겨주세요. 저는 여러 주제에 대한 전문 지식을 가진 콘텐츠 작가입니다. 저와 같은 전문가를 찾고 있다면 망설이지 마시고 LinkedIn에서 메시지를 보내주세요.\n\n# 샤오미 폰에서 발생하는 빠른 배터리 소모 문제에 대한 자주 묻는 질문\n\n샤오미 폰에서 발생하는 빠른 배터리 소모 문제와 관련하여 자주 묻는 질문이 다른 샤오미 폰 사용자와 동일할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## Xiaomi 폰의 배터리가 왜 빨리 소모되나요?\n\nXiaomi 폰의 배터리가 빨리 소모되는 이유 중 하나로, 인스타그램이나 트위터와 같은 소셜 미디어 네트워크, 스파이웨어 VPN, 백그라운드 실행 앱, 그리고 Wi-Fi 및 위치 서비스의 과도한 사용이 있습니다. 배터리 설정 항목에서 배터리가 빨리 소모되는 이유를 확인할 수 있습니다.\n\n## 시스템 업데이트 후 Xiaomi 폰의 배터리가 빨리 소모되는 것이 정상인가요?\n\n시스템 업데이트로 인해 설정이 변경되고 새로운 기능이 추가될 수 있기 때문에 Xiaomi 폰 업데이트 후 배터리가 빨리 소모되는 것은 정상적인 일입니다. 이 문제는 몇 일 후에 해결될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 제 직접새본 Ziaomi 핸드폰 배터리 바꿀 수 있을까요?\n\nXiaomi 핸드폰의 배터리는 집에서 스스로 교체하지 않는 것이 좋습니다. 이렇게 하면 핸드폰에 손상을 줄 수 있습니다. Xiaomi 핸드폰인 Redmi와 Poco의 배터리 교체 작업은 전문 기술자에게 맡기는 것이 좋습니다.\n\n## 배터리 절약 모드 사용이 Xiaomi 핸드폰 성능에 영향을 미칩니까?\n\n배터리 절약 모드를 사용하여 배터리 수명을 연장하면 Xiaomi 핸드폰의 성능에 일부 영향을 줄 수도 있습니다. 그러나 대부분의 경우에는 그 영향이 크지 않습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 배터리 절약 앱을 사용하면 Xiaomi 핸드폰에 손해가 갈까요?\n\n일부 배터리 절약 앱은 Xiaomi 핸드폰의 빠른 배터리 소모를 해결할 수 있지만, 다른 것들은 Xiaomi 배터리의 건강에 해를 줄 수도 있습니다. Google Play Store와 같은 신뢰할 만한 소스에서 유명한 앱을 사용하는 것을 권장합니다.\n\n## 다크 모드를 사용하면 Xiaomi 핸드폰의 빠른 배터리 소모를 막을 수 있을까요?\n\n전문가들은 이 질문에 대해 서로 다른 의견을 가지고 있습니다. 어둡게 설정된 색상은 더 적은 전원을 필요로 하기 때문에 일부 사람들은 다크 모드가 Xiaomi 핸드폰의 배터리 수명을 연장하는 데 도움이 될 수 있다고 합니다. 다른 사람들은 Xiaomi 핸드폰의 다크 모드에서 절전되는 양은 사용자 설정과 사용 패턴에 따라 다를 수 있다고 믿습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 제 Xiaomi 핸드폰 배터리를 교정하는 방법은 무엇인가요?\n\nXiaomi 핸드폰의 배터리를 교정할 필요는 없습니다. 핸드폰 소프트웨어가 배터리를 자동으로 교정할 수 있게 설계되어 있습니다. 그러나 배터리를 처음부터 완전히 충전하고 완전히 소진시킨 후 다시 완전히 충전하는 방법을 시도해 볼 수 있습니다.\n\n## Xiaomi 핸드폰 배터리는 얼마나 가용 시간이 있는가요?\n\nXiaomi 핸드폰의 배터리 수명은 모델, 사용 방식 및 설정에 따라 다를 수 있습니다. 그러나 대부분의 Xiaomi 핸드폰은 약 3000-5000mAh의 배터리 용량을 가지고 있으며, 중간 정도의 사용량으로 하루 동안 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 샤오미 폰에서 빠른 충전기를 사용하면 배터리 수명에 영향을 미치나요?\n\n빠른 충전기를 사용하는 것이 샤오미 폰의 배터리 수명에 반드시 영향을 미치지는 않습니다. 샤오미 폰은 빠른 충전을 지원하도록 설계되어 있으며, 충전 속도는 배터리에 손상을 예방하기 위해 최적화되어 있습니다. 그러나 폰과 호환되지 않는 서드파티 충전기나 케이블을 사용하는 경우 배터리에 손상을 줄 수 있습니다.\n\n## 샤오미 폰 홈 화면에 위젯을 많이 사용하면 배터리 소모와 관련이 있나요?\n\n네, 샤오미 폰 홈 화면에 위젯을 많이 사용하는 것은 배터리를 소모할 수 있습니다. 위젯은 CPU와 RAM과 같은 리소스를 사용하여 정보를 업데이트하고 표시하기 때문에 배터리를 빨리 소모시킬 수 있습니다. 배터리 소모를 해결하려면 필수적인 위젯만 사용하고 홈 화면에서 사용하지 않는 위젯을 제거하는 것이 좋습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 FAQ의 내용은 AI의 도움을 받아 작성되었습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoFixRapidBatteryDrainonXiaomiPhonesFAQ_0.png","tag":["Tech"],"readingTime":11},{"title":"Jetpack Compose로 박스 안팎에서 애니메이션 만드는 방법","description":"","date":"2024-06-23 23:29","slug":"2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose","content":"\n## 안드로이드에서 조합을 활용한 창의적인 애니메이션 구축\n\n![이미지](/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png)\n\n# 소개\n\n애니메이션은 사용자 인터페이스를 생생하고 매력적으로 만드는 힘을 지니고 있습니다. 안드로이드에서는 Jetpack Compose를 활용하여 이 힘을 직접 경험할 수 있습니다. 이러한 고급 도구를 제공함으로써 동적인 UI를 만들 수 있는 Jetpack Compose의 애니메이션에 대해 이 글에서는 기본을 넘어 더 깊게 알아보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 플루이드하고 물리학적인 움직임을 만드는 것부터 복잡한 코레오그래피 시퀀스를 만들어 인터페이스에 서사적인 품질을 더하는 기술 범위를 다룰 것입니다. 여러분이 기술을 미세하게 조정하거나 가능한 영역에 대해 궁금해하는 경우, 이 여정은 앱을 매끄럽게 작동하는 것뿐만 아니라 모든 상호작용에서 사용자를 즐겁게 만드는 실용적인 통찰력을 제공할 것입니다.\n\n자세히 알아보고 이러한 애니메이션들이 UI 디자인 접근 방식을 변화시키고 사용자에게 더 직관적이고 반응성 있으며 즐거운 경험을 제공하는 방법을 발견해 봅시다.\n\n# 섹션 1 — Jetpack Compose에서 사용자 정의 애니메이션 핸들러\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*C1_mzDHNHOfSZkIiULgRzw.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 사용자 지정 애니메이션으로 동적 상호작용 수용하기\n\n이 섹션에서는 Jetpack Compose에서 고급 사용자 지정 애니메이션 핸들러의 사용에 대해 탐구하여 동적이고 대화식 UI 요소를 만드는 방법을 살펴봅니다. 우리의 초점은 사용자 상호작용이 의미 있는 방식으로 애니메이션에 영향을 미치는 실제 예제에 있습니다.\n\n## 예제 - 대화식 게임 캐릭터 이동\n\n게임 캐릭터(얼굴 아이콘으로 표시되는)가 사용자가 드래그할 수 있는 제어 지점에 의해 결정된 경로를 따라가는 예제로 이 개념을 설명하겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun GameCharacterMovement() {\n    val startPosition = Offset(100f, 100f)\n    val endPosition = Offset(250f, 400f)\n    val controlPoint = remember { mutableStateOf(Offset(200f, 300f)) }\n    val position = remember { Animatable(startPosition, Offset.VectorConverter) }\n\n    LaunchedEffect(controlPoint.value) {\n        position.animateTo(\n            targetValue = endPosition,\n            animationSpec = keyframes {\n                durationMillis = 5000\n                controlPoint.value at 2500 // 가운데 지점은 드래그 가능한 컨트롤포인트로 제어됩니다\n            }\n        )\n    }\n\n    val onControlPointChange: (offset: Offset) -\u003e Unit = {\n        controlPoint.value = it\n    }\n\n    Box(modifier = Modifier.fillMaxSize()) {\n\n        Icon(\n            Icons.Filled.Face, contentDescription = \"로컬라이즈된 설명\", modifier = Modifier\n                .size(50.dp)\n                .offset(x = position.value.x.dp, y = position.value.y.dp)\n        )\n\n        DraggableControlPoint(controlPoint.value, onControlPointChange)\n    }\n}\n```\n\n## 설명\n\n- GameCharacterMovement 함수는 게임 캐릭터를 나타내는 아이콘을 애니메이션화합니다. 애니메이션 경로는 사용자 상호 작용에 의해 설정 및 업데이트되는 controlPoint으로 제어됩니다.\n- Animatable은 startPosition에서 endPosition으로 아이콘의 위치를 부드럽게 전환하기 위해 사용됩니다.\n- LaunchedEffect는 controlPoint 값의 변경 사항을 감지하고, 제어 지점이 이동할 때마다 애니메이션을 다시 트리거합니다.\n- animationSpec은 애니메이션의 지속 시간, 지연 및 이징을 정의하는 구성이며, 애니메이션된 값이 시간에 따라 어떻게 변하는지 결정합니다.\n- keyframes를 통해 애니메이션의 중간 지점을 제어 지점에서 최종 위치까지 정의할 수 있습니다. 중요한 역할을 하는 복잡한, 조정된 애니메이션을 만드는 데 특히 유용합니다.\n- keyframes 블록은 키프레임의 시퀀스로 애니메이션을 정의합니다. 2500 밀리초(절반 지점)에서 캐릭터가 제어 지점에 도달한 후 최종 위치로 이동합니다.\n\n```kotlin\n@Composable\nfun DraggableControlPoint(controlPoint: Offset, onControlPointChange: (Offset) -\u003e Unit) {\n    var localPosition by remember { mutableStateOf(controlPoint) }\n    Box(\n        modifier = Modifier\n            .offset {\n                IntOffset(\n                    x = localPosition.x.roundToInt() - 15,\n                    y = localPosition.y.roundToInt() - 15\n                )\n            }\n            .size(30.dp)\n            .background(Color.Red, shape = CircleShape)\n            .pointerInput(Unit) {\n                detectDragGestures(onDragEnd = {\n                    onControlPointChange(localPosition)\n                }) { _, dragAmount -\u003e\n                    // 화면 범위에 맞춰 조정\n                    val newX = (localPosition.x + dragAmount.x).coerceIn(0f, 600f)\n                    val newY = (localPosition.y + dragAmount.y).coerceIn(0f, 600f)\n                    localPosition = Offset(newX, newY)\n                }\n            }\n    )\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설명\n\n- DraggableControlPoint는 사용자가 제어 지점의 위치를 인터랙티브하게 변경할 수 있게 하는 컴포저블입니다.\n- 제어 지점을 드래그하면 localPosition이 업데이트되고, 이후 드래그 제스처가 완료될 때 (onDragEnd) 이를 GameCharacterMovement에 반영합니다. 이 상호 작용은 애니메이션된 아이콘의 경로를 변경합니다.\n\n## 실제 사용 사례\n\n- 상호 작용적인 교육 앱: 교육 앱에서는 애니메이션을 통해 학습을 더 매료적으로 만들 수 있습니다. 예를 들어, 천문학 앱에서 행성을 따라 원거리를 끌어서 다양한 별자리를 볼 수 있습니다.\n- 상호 작용적인 이야기 전달과 게임: 디지털 이야기 전달이나 게임 앱에서 사용자가 드래그 가능한 요소를 통해 이야기나 게임 환경에 영향을 미칠 수 있도록 하는 것은 더 몰입적인 경험을 만들어냅니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 섹션 2 — Jetpack Compose에서 복잡한 애니메이션 조정하기\n\n## 조화로운 효과를 위한 여러 요소의 동기화\n\n이 섹션에서는 Jetpack Compose에서 복잡한 애니메이션을 조율하는 기술에 대해 다룹니다. 여러 요소가 매끄럽게 상호작용하는 동기화된 애니메이션을 만드는 데 초점을 맞춰 전체 사용자 경험을 향상시킵니다.\n\n## A) 연쇄 반응 애니메이션 — 도미노 효과\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![domino effect](https://miro.medium.com/v2/resize:fit:1400/1*iNeJJU3ixcdcZnQFHHSWYw.gif)\n\nUI에서 도미노 효과를 만드는 방법은 하나의 애니메이션이 완료되면 다음 애니메이션을 시작하도록 설정하는 일련의 애니메이션을 만들어내면 됩니다.\n\n```kotlin\n@Composable\nfun DominoEffect() {\n    val animatedValues = List(6) { remember { Animatable(0f) } }\n\n    LaunchedEffect(Unit) {\n        animatedValues.forEachIndexed { index, animate -\u003e\n            animate.animateTo(\n                targetValue = 1f,\n                animationSpec = tween(durationMillis = 1000, delayMillis = index * 100)\n            )\n        }\n    }\n\n    Box (modifier = Modifier.fillMaxSize()){\n      animatedValues.forEachIndexed { index, value -\u003e\n        Box(\n            modifier = Modifier\n                .size(50.dp)\n                .offset(x = ((index+1) * 50).dp, y = ((index+1) * 30).dp)\n                .background(getRandomColor(index).copy(alpha = value.value))\n        )\n      }\n    }\n}\n\nfun getRandomColor(seed: Int): Color {\n    val random = Random(seed = seed).nextInt(256)\n    return Color(random, random, random)\n}\n```\n\n## 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- animatedValues는 상자의 불투명도를 제어하는 Animatable 값 목록입니다.\n- LaunchedEffect는 이러한 값들에 대한 일련의 애니메이션을 트리거하여 각 상자가 이전 상자 뒤에 나타나는 비슷한 도미노가 넘어지는 효과를 만듭니다.\n- getRandomColor 함수는 각 상자에 대해 무작위 회색을 생성하여 시퀀스의 각 구성 요소에 고유한 시각적 요소를 추가합니다.\n- 상자들은 화면 대각선상에 배치되어 도미노 효과를 더욱 부각시킵니다.\n\n## B) 대화식 스크롤 가능한 타임라인\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*Kk-V0g5pEqy83NajRy_6lA.gif)\n\n이 타임라인에서 사용자가 타임라인을 스크롤하면 각 요소가 서서히 나타나고 위치로 이동합니다. 스크롤 가능한 목록에는 LazyColumn을 사용하고 애니메이션에는 Animatable을 사용할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun InteractiveTimeline(timelineItems: List\u003cString\u003e) {\n    val scrollState = rememberLazyListState()\n\n    LazyColumn(state = scrollState) {\n        itemsIndexed(timelineItems) { index, item -\u003e\n            val animatableAlpha = remember { Animatable(0f) }\n            val isVisible = remember {\n                derivedStateOf {\n                    scrollState.firstVisibleItemIndex \u003c= index\n                }\n            }\n\n            LaunchedEffect(isVisible.value) {\n                if (isVisible.value) {\n                    animatableAlpha.animateTo(\n                        1f, animationSpec = tween(durationMillis = 1000)\n                    )\n                }\n            }\n\n            TimelineItem(\n                text = item,\n                alpha = animatableAlpha.value,\n            )\n        }\n    }\n}\n\n@Composable\nfun TimelineItem(text: String, alpha: Float) {\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(Color.DarkGray.copy(alpha = alpha))\n            .padding(16.dp),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        Text(\n            text = text,\n            color = Color.White,\n            modifier = Modifier.fillMaxWidth(),\n            textAlign = TextAlign.Center,\n            fontSize = 18.sp,\n            fontWeight = FontWeight.SemiBold\n        )\n    }\n}\n```\n\n## 설명\n\n- animatableAlpha은 각 타임라인 아이템의 투명도 (투명도)를 제어하며, 초기에 0 (완전히 투명)로 설정됩니다.\n- isVisible 상태는 현재 스크롤 위치에서 파생되어 항목이 표시될지 여부를 결정합니다.\n- 사용자가 스크롤하면 LaunchedEffect가 뷰포트에 들어오는 항목에 대한 페이드인 애니메이션을 트리거합니다.\n\n## 사용 사례\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 상호작용형 타임라인은 사용자에게 시각적으로 매력적인 방식으로 일련의 이벤트나 단계를 제시하고 싶은 응용 프로그램에 이상적입니다. 애니메이션은 항목이 나타날 때 주목을 끌어 사용자 참여도를 높입니다.\n\n# 섹션 3 — 젯팩 콤포즈에서 현실감 있는 물리 기반 애니메이션\n\n![애니메이션 이미지](https://miro.medium.com/v2/resize:fit:1400/1*lZ_rpGorcFzewpUJN6WPAQ.gif)\n\n## UI 다이내믹스 향상을 위한 물리학 활용하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 물리학 원리를 Jetpack Compose와 통합하여 UI에 현실성과 상호 작용성을 더하는 방법을 살펴보겠습니다. 탄탄한 드래그 상호 작용 예시에 초점을 맞출 것입니다.\n\n## 드래그 시 탄탄한 효과\n\n이 예시에서는 아이콘에 탄탄한 드래그 상호 작용을 보여줍니다. 수직으로 드래그할 때 아이콘이 늘어나고 탄탄한 효과로 튕기며, 스프링이나 고무줄의 행동을 모방합니다.\n\n```js\n@Composable\nfun ElasticDraggableBox() {\n    var animatableOffset by remember { mutableStateOf(Animatable(0f)) }\n\n    Box(modifier = Modifier.fillMaxSize().background(Color(0xFFFFA732)), contentAlignment = Alignment.Center) {\n        Box(\n            modifier = Modifier\n                .offset(y = animatableOffset.value.dp)\n                .draggable(\n                    orientation = Orientation.Vertical,\n                    state = rememberDraggableState { delta -\u003e\n                        animatableOffset = Animatable(animatableOffset.value + delta)\n                    },\n                    onDragStopped = {\n                        animatableOffset.animateTo(0f, animationSpec = spring())\n                    }\n                )\n                .size(350.dp),\n            contentAlignment = Alignment.Center\n        ) {\n            Icon(\n                Icons.Filled.Favorite,\n                contentDescription = \"heart\",\n                modifier = Modifier.size(animatableOffset.value.dp + 150.dp),\n                tint = Color.Red\n            )\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설명\n\n- 드래그할 수 있는 modifier를 사용하여 아이콘을 포함하는 Box Composable을 만듭니다.\n- animatableOffset은 드래깅으로 인한 아이콘의 수직 오프셋을 추적합니다.\n- 드래그하는 동안 아이콘의 크기가 드래그 양에 따라 변경되어 스트레칭 효과를 만듭니다.\n- 드래그가 멈추면 (onDragStopped), animatableOffset을 스프링 애니메이션을 사용하여 0f로 다시 애니메이션화하여 아이콘이 원래 크기와 위치로 되돌아가도록 합니다.\n\n# 섹션 4 — 제스처 기반 애니메이션(Jetpack Compose에서)\n\n## 사용자 경험을 향상시키는 반응형 제스처들\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 섹션에서는 사용자 동작으로 제어되는 애니메이션을 생성하는 데 Jetpack Compose를 사용하는 방법을 살펴봅니다. 두 가지 예제에 중점을 두겠습니다 - 멀티터치로 변환 가능한 이미지 및 제스처로 제어되는 오디오 파형입니다.\n\n## A) 멀티 터치로 변환 가능한 이미지\n\n이 예제에서는 사용자가 핀치, 줌 및 회전과 같은 멀티터치 제스처를 사용하여 상호 작용할 수 있는 이미지 뷰를 생성합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*34WxcBivTWhiCY6KVSVelQ.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Composable\nfun TransformableImage(imageId: Int = R.drawable.android) {\n    var scale by remember { mutableStateOf(1f) }\n    var rotation by remember { mutableStateOf(0f) }\n    var offset by remember { mutableStateOf(Offset.Zero) }\n\n    Box(modifier = Modifier.fillMaxSize().background(Color.DarkGray), contentAlignment = Alignment.Center) {\n        Image(\n            painter = painterResource(id = imageId),\n            contentDescription = \"Transformable image\",\n            contentScale = ContentScale.Crop,\n            modifier = Modifier\n                .size(300.dp)\n                .graphicsLayer(\n                    scaleX = scale,\n                    scaleY = scale,\n                    rotationZ = rotation,\n                    translationX = offset.x,\n                    translationY = offset.y\n                )\n                .pointerInput(Unit) {\n                    detectTransformGestures { _, pan, zoom, rotate -\u003e\n                        scale *= zoom\n                        rotation += rotate\n                        offset += pan\n                    }\n                }\n        )\n    }\n}\n```\n\n## 설명\n\n- 이미지 컴포저블은 scale, rotation, translation과 같은 변환을 적용하기 위해 graphicsLayer로 수정되었습니다.\n- detectTransformGestures가 사용되는 pointerInput은 멀티 터치 제스처를 처리하고, scale, rotation, offset을 해당 값을 따라 업데이트합니다.\n\n## B) 제스처 컨트롤 웨이브폼\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사용자 제스처(스와이프 및 핀치)에 따라 와브폼 시각화가 모양을 바꿉니다. 이를 통해 진폭 및 주파수와 같은 요소를 제어할 수 있습니다.\n\n![waveform visualization](https://miro.medium.com/v2/resize:fit:1400/1*qKzb1XpUrSGKdCL-OxhtLw.gif)\n\n```js\n@Composable\nfun GestureControlledWaveform() {\n    var amplitude by remember { mutableStateOf(100f) }\n    var frequency by remember { mutableStateOf(1f) }\n\n    Canvas(modifier = Modifier\n        .fillMaxSize()\n        .pointerInput(Unit) {\n            detectDragGestures { _, dragAmount -\u003e\n                amplitude += dragAmount.y\n                frequency += dragAmount.x / 500f\n                // 드래그에 기반한 주파수 조정\n            }\n        }\n        .background(\n            Brush.verticalGradient(\n                colors = listOf(Color(0xFF003366), Color.White, Color(0xFF66B2FF))\n            )\n        )) {\n        val width = size.width\n        val height = size.height\n        val path = Path()\n\n        val halfHeight = height / 2\n        val waveLength = width / frequency\n\n        path.moveTo(0f, halfHeight)\n\n        for (x in 0 until width.toInt()) {\n            val theta = (2.0 * Math.PI * x / waveLength).toFloat()\n            val y = halfHeight + amplitude * sin(theta.toDouble()).toFloat()\n            path.lineTo(x.toFloat(), y)\n        }\n\n        val gradient = Brush.horizontalGradient(\n            colors = listOf(Color.Blue, Color.Cyan, Color.Magenta)\n        )\n\n        drawPath(\n            path = path,\n            brush = gradient\n        )\n    }\n}\n```\n\n## 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 진폭과 주파수는 각각 웨이브폼의 진폭과 주파수를 제어하는 상태 변수입니다.\n- Canvas composable은 웨이브폼을 그리는데 사용됩니다. Canvas 내부의 그리기 로직은 사인 함수에 기반하여 각 X 위치에 대한 Y 위치를 계산하여 파동 효과를 만듭니다.\n- detectDragGestures 수정자는 사용자의 드래그 제스처에 기반하여 진폭과 주파수를 업데이트하는데 사용됩니다. 가로 드래그는 주파수를 조절하고, 세로 드래그는 진폭을 조절합니다.\n- 사용자가 화면을 가로지르면, 웨이브폼의 형태가 그에 따라 변경되어 상호 작용하는 경험을 제공합니다.\n\n## 참고\n\n- 이것은 기본 구현입니다. 보다 현실적인 오디오 웨이브폼을 만들려면 실제 오디오 데이터를 통합해야 합니다.\n- 제스처에 대한 웨이브폼의 반응은 드래그하는 동안 진폭과 주파수가 어떻게 수정되는지 조정하여 미세 조정할 수 있습니다.\n\n이 예제는 Compose에서 기본 대화형 웨이브폼을 만드는 방법을 보여주며, 더 복잡한 사용 사례에 확장하거나 수정하여 더 복잡한 제스처를 처리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 섹션 5 — Jetpack Compose에서 상태 주도 애니메이션 패턴\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*nkfhmC6JjQnshL3y_izhKg.gif)\n\n## 데이터 및 상태 변경에 따른 UI 애니메이션\n\n이 섹션은 데이터 또는 UI 상태 변경으로 구동되는 애니메이션을 생성하는 데 초점을 맞추어 앱의 상호 작용성과 반응성을 향상시킵니다. 우리는 데이터 그래프를 애니메이션화하고 다중 상태 UI에서 상태 전이를 구현하는 두 가지 구체적인 예시를 살펴볼 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## A) 데이터 기반 그래프 애니메이션\n\n이 예시는 데이터 세트의 변화에 반응하여 그래프의 경로가 애니메이션되는 라인 그래프를 보여줍니다.\n\n```js\n@Composable\nfun AnimatedGraphExample() {\n    var dataPoints by remember { mutableStateOf(generateRandomDataPoints(5)) }\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(Color.DarkGray)\n    ) {\n        AnimatedLineGraph(dataPoints = dataPoints)\n\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Button(\n            onClick = {\n                dataPoints = generateRandomDataPoints(5)\n            },\n            modifier = Modifier.align(Alignment.CenterHorizontally),\n            colors = ButtonDefaults.buttonColors(containerColor = Color.Green)\n        ) {\n            Text(\n                \"데이터 업데이트\",\n                fontWeight = FontWeight.Bold,\n                color = Color.DarkGray,\n                fontSize = 18.sp\n            )\n        }\n    }\n}\n\n@Composable\nfun AnimatedLineGraph(dataPoints: List\u003cFloat\u003e) {\n    val animatableDataPoints = remember { dataPoints.map { Animatable(it) } }\n    val path = remember { Path() }\n\n    LaunchedEffect(dataPoints) {\n        animatableDataPoints.forEachIndexed { index, animatable -\u003e\n            animatable.animateTo(dataPoints[index], animationSpec = TweenSpec(durationMillis = 500))\n        }\n    }\n\n    Canvas(\n        modifier = Modifier\n            .fillMaxWidth()\n            .height(400.dp)\n    ) {\n        path.reset()\n        animatableDataPoints.forEachIndexed { index, animatable -\u003e\n            val x = (size.width / (dataPoints.size - 1)) * index\n            val y = size.height - (animatable.value * size.height)\n            if (index == 0) path.moveTo(x, y) else path.lineTo(x, y)\n        }\n        drawPath(path, Color.Green, style = Stroke(5f))\n    }\n}\n\nfun generateRandomDataPoints(size: Int): List\u003cFloat\u003e {\n    return List(size) { Random.nextFloat() }\n}\n```\n\n## 설명\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- AnimatedGraphExample composable은 라인 그래프의 데이터 포인트를 업데이트할 수 있는 환경을 생성합니다.\n- 그래프는 Canvas 내에서 그려지며 drawPath 메서드는 animatableDataPoints에서 애니메이션 값을 사용합니다.\n- 그래프의 각 데이터 포인트에 대해 캔버스 상에서 해당 x (수평) 및 y (수직) 위치를 계산해야 합니다.\n- x 계산 — x 위치는 데이터 포인트의 인덱스와 캔버스의 총 너비에 기반하여 계산됩니다. 데이터 포인트를 캔버스 너비를 따라 균일하게 분산합니다.\n\n```js\nval x = (size.width / (dataPoints.size - 1)) * index\n```\n\n- y 계산 — y 위치는 데이터 포인트의 값 (animatable.value) 및 캔버스의 높이에 기반하여 계산됩니다.\n\n```js\nval y = size.height - (animatable.value * size.height)\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 경로는 첫 번째 데이터 포인트에서 시작하여 lineTo를 사용하여 각 후속 포인트로 선을 그려 그래프 선을 생성합니다.\n- 경로는 데이터 포인트의 애니메이션 값에 기반하여 그려지며, 데이터가 변경될 때 애니메이션 효과를 만듭니다.\n\n## B) 다중 상태 UI에서 상태 전환\n\n다중 상태 UI에서 상태 전환을 구현하는 방법은 Animatable을 사용하여 다른 UI 상태 간에 애니메이션을 적용하는 것입니다.\n\n```js\nenum class UIState { StateA, StateB, StateC }\n\n@Composable\nfun StateTransitionUI() {\n    var currentState by remember { mutableStateOf(UIState.StateA) }\n\n    Box(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(getBackgroundColorForState(currentState)),\n        contentAlignment = Alignment.Center\n    ) {\n        AnimatedContent(currentState = currentState)\n\n        Button(\n            onClick = { currentState = getNextState(currentState) },\n            modifier = Modifier.align(Alignment.BottomCenter)\n        ) {\n            Text(\"다음 상태\")\n        }\n    }\n}\n\n@Composable\nfun AnimatedContent(currentState: UIState) {\n    AnimatedVisibility(\n        visible = currentState == UIState.StateA,\n        enter = fadeIn(animationSpec = tween(durationMillis = 2000)) + expandVertically(),\n        exit = fadeOut(animationSpec = tween(durationMillis = 2000)) + shrinkVertically()\n    ) {\n        Text(\"현재 상태는 ${currentState.name} 입니다\", fontSize = 32.sp)\n    }\n\n    // B와 C에 대한 유사한 블록\n\n}\n\nfun getBackgroundColorForState(state: UIState): Color {\n    return when (state) {\n        UIState.StateA -\u003e Color.Red\n        UIState.StateB -\u003e Color.Green\n        UIState.StateC -\u003e Color.Blue\n    }\n}\n\nfun getNextState(currentState: UIState): UIState {\n    return when (currentState) {\n        UIState.StateA -\u003e UIState.StateB\n        UIState.StateB -\u003e UIState.StateC\n        UIState.StateC -\u003e UIState.StateA\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 설명\n\n- 이 예시에서 AnimatedVisibility는 각 상태의 콘텐츠가 나타나고 사라질 때 애니메이션 효과를 적용하는 데 사용됩니다. 이는 상태가 변경될 때 부드러운 전환 효과를 추가합니다.\n- 각 상태(StateA, StateB, StateC)마다 해당 콘텐츠의 가시성을 페이드 및 확장/축소 애니메이션으로 제어하는 AnimatedVisibility 블록이 있습니다.\n- AnimatedVisibility의 enter 및 exit 매개변수는 콘텐츠가 표시되거나 숨겨질 때의 애니메이션을 정의합니다.\n\n# 섹션 6 — Compose에서 모양 변환\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*q82EIocVzR8XBMuG_14mdg.gif)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n도형 간 변환 애니메이션은 이러한 도형의 속성을 보간하는 것을 포함합니다.\n\n```js\n@Composable\nfun ShapeMorphingAnimation() {\n    val animationProgress = remember { Animatable(0f) }\n\n    LaunchedEffect(Unit) {\n        animationProgress.animateTo(\n            targetValue = 1f,\n            animationSpec = infiniteRepeatable(\n                animation = tween(2000, easing = LinearOutSlowInEasing),\n                repeatMode = RepeatMode.Reverse\n            )\n        )\n    }\n\n    Canvas(modifier = Modifier.padding(40.dp).fillMaxSize()) {\n        val sizeValue = size.width.coerceAtMost(size.height) / 2\n        val squareRect = Rect(center = center, sizeValue)\n\n        val morphedPath = interpolateShapes(progress = animationProgress.value, squareRect = squareRect)\n        drawPath(morphedPath, color = Color.Blue, style = Fill)\n    }\n}\n\nfun interpolateShapes(progress: Float, squareRect: Rect): Path {\n    val path = Path()\n\n    val cornerRadius = CornerRadius(\n        x = lerp(start = squareRect.width / 2, stop = 0f, fraction = progress),\n        y = lerp(start = squareRect.height / 2, stop = 0f, fraction = progress)\n    )\n\n    path.addRoundRect(\n        roundRect = RoundRect(rect = squareRect, cornerRadius = cornerRadius)\n    )\n\n    return path\n}\n\nfun lerp(start: Float, stop: Float, fraction: Float): Float {\n    return (1 - fraction) * start + fraction * stop\n}\n```\n\n## 설명\n\n- ShapeMorphingAnimation은 animationProgress 값을 0과 1 사이로 토글하는 무한 애니메이션을 설정합니다.\n- Canvas 콤포저블을 사용하여 도형을 그립니다. 여기서 캔버스 크기에 기반하여 정사각형의 크기(squareRect)를 정의합니다.\n- interpolateShapes는 현재 애니메이션 진행도와 정사각형 사각형을 가져와 원과 정사각형 사이를 보간합니다. 변형되는 모양을 나타내는 둥근 직사각형의 cornerRadius를 서서히 조절하기 위해 lerp(선형 보간)를 사용합니다.\n- 진행도가 0일 때 cornerRadius는 직사각형의 반만큼이므로 도형은 원이 됩니다. 진행도가 1일 때 cornerRadius는 0이 되어 도형이 정사각형이 됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 실제 사용 사례\n\n- 로딩 및 진행 상태 표시기 — 모프 형태는 더 매력적인 로딩 또는 진행 상태 표시기를 만드는 데 사용될 수 있습니다. 진행 상태나 로딩 상태를 나타내는 더욱 시각적으로 흥미로운 방법을 제공합니다.\n- UI 내 아이콘 전환 — 모프 아이콘은 사용자 작업에 대한 시각적 피드백을 제공하는 데 사용할 수 있습니다. 예를 들어, 클릭할 때 플레이 버튼이 일시 중지 버튼으로 변하는 경우 또는 햄버거 메뉴 아이콘이 뒤로 이동하는 화살표로 변하는 경우 등.\n- 데이터 시각화 — 복잡한 데이터 시각화에서 모프는 사용자가 시간에 따른 변경 또는 범주 간의 변화를 따라가고 이해하기 쉽도록 돕는 데 도움이 될 수 있습니다.\n\n# 눈 오는 소리 좀?\n\n간단한 입자 시스템을 사용하여 눈이 내리는 효과를 만들어보겠습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n테이블 태그를 마크다운 형식으로 변경합니다.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*E26GhhxDZLGTpE8gMvJoHw.gif\" /\u003e\n\n```js\ndata class Snowflake(\n    var x: Float,\n    var y: Float,\n    var radius: Float,\n    var speed: Float\n)\n\n@Composable\nfun SnowfallEffect() {\n    val snowflakes = remember { List(100) { generateRandomSnowflake() } }\n    val infiniteTransition = rememberInfiniteTransition(label = \"\")\n\n    val offsetY by infiniteTransition.animateFloat(\n        initialValue = 0f,\n        targetValue = 1000f,\n        animationSpec = infiniteRepeatable(\n            animation = tween(durationMillis = 5000, easing = LinearEasing),\n            repeatMode = RepeatMode.Restart\n        ), label = \"\"\n    )\n\n    Canvas(modifier = Modifier.fillMaxSize().background(Color.Black)) {\n        snowflakes.forEach { snowflake -\u003e\n            drawSnowflake(snowflake, offsetY % size.height)\n        }\n    }\n}\n\nfun generateRandomSnowflake(): Snowflake {\n    return Snowflake(\n        x = Random.nextFloat(),\n        y = Random.nextFloat() * 1000f,\n        radius = Random.nextFloat() * 2f + 2f, // Snowflake size\n        speed = Random.nextFloat() * 1.2f + 1f  // Falling speed\n    )\n}\n\nfun DrawScope.drawSnowflake(snowflake: Snowflake, offsetY: Float) {\n    val newY = (snowflake.y + offsetY * snowflake.speed) % size.height\n    drawCircle(Color.White, radius = snowflake.radius, center = Offset(snowflake.x * size.width, newY))\n}\n```\n\n## 설명\n\n- SnowfallEffect는 여러 개의 눈송이(Snowflake 객체)를 가진 입자 시스템을 설정합니다.\n- 각 Snowflake는 위치 (x, y), 반지름 (크기), 속도와 같은 속성을 갖습니다.\n- rememberInfiniteTransition 및 animateFloat은 눈이 내리는 것을 시뮬레이션하기 위한 연속적인 수직 이동 효과를 생성하는 데 사용됩니다.\n- Canvas composable은 각 눈송이를 그리는 데 사용됩니다. drawSnowflake 함수는 속도와 애니메이션된 offsetY에 기반하여 각 눈송이의 새 위치를 계산합니다.\n- 눈송이들은 아래로 떨어진 후 다시 위로 나타나며, 반복되는 눈내림 효과를 만듭니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n제트팩 구성에서 애니메이션을 탐색하면서 마무리하는 시점에서, 애니메이션이 시각적 장식 이상의 중요한 도구라는 것이 분명해졌습니다. 애니메이션은 매력적이고 직관적이며 즐거운 사용자 경험을 만드는 데 중요한 도구입니다.\n\n## 상호 작용 포용\n\n게임 캐릭터의 동적인 움직임부터 인터랙티브 타임라인까지, 우리는 애니메이션이 사용자 상호작용을 더 매력적이고 유익하게 만들 수 있는 방법을 알아보았습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 현실적인 경험 구현하기\n\n눈 내리는 효과와 형태 변화는 이 도구상자가 디지털 영역에 현실감과 유동성을 표현하는 능력을 보여줍니다. 이러한 애니메이션들은 사용자와 공감을 형성하는 몰입형 경험을 만들어줍니다.\n\n## 복잡함을 간단하게 만들기\n\n여러 요소를 조정하거나 상태 전환을 애니메이션화하는 경우, 이것이 할 수 있는 간단함이 돋보입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 마무리 인사\n\n만약 읽은 것이 마음에 들었다면, 소중한 피드백이나 감사의 말을 자유롭게 남겨주세요. 저는 항상 개발자 친구들과 함께 배우고 협력하며 성장하고자 노력하고 있습니다.\n\n질문이 있으시다면 언제든지 메시지를 보내주세요!\n\n더 많은 기사를 보시려면 저의 Medium 프로필을 팔로우해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nLinkedIn과 트위터에서 저와 연결해주세요. 협업 기회가 있을지도 몰라요.\n\n애니메이션 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-23-AnimatingInsideandOutsidetheBoxwithJetpackCompose_0.png","tag":["Tech"],"readingTime":30},{"title":"Callback 대신 Coroutine 사용하는 방법","description":"","date":"2024-06-23 23:28","slug":"2024-06-23-HowtouseaCoroutineinsteadofCallback","content":"\n콜백을 코루틴으로 대체하는 것은 비동기 작업을 처리하기 위해 콜백을 사용하는 코드를 코루틴 기반 코드로 변환하는 것을 의미합니다. 이렇게하면 코드가 더 읽기 쉽고 유지 관리하기 쉬워집니다. Kotlin에서 코루틴은 복잡한 콜백 체인 없이 비동기 작업을 처리할 수 있습니다.\n\n아래는 콜백 기반 접근 방식을 코루틴으로 대체하는 방법입니다:\n\n콜백 수신을 위한 인터페이스:\n\n```js\ninterface Callback\u003cT\u003e {\n    fun onSuccess(response: T)\n    fun onFailure(e: Throwable)\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n추상화 계층 추가를 위한 서비스 인터페이스:\n\n```kotlin\ninterface FruitService {\n    fun fetchFruits(callback: Callback\u003cList\u003cString\u003e\u003e)\n}\n```\n\n과일 목록을 가져오는 데이터 소스:\n\n```kotlin\nclass FruitsDataSource : FruitService {\n    override fun fetchFruits(callback: Callback\u003cList\u003cString\u003e\u003e) {\n        Thread {\n            try {\n                Thread.sleep(1000) // API 호출을 시뮬레이션하기 위한 지연\n                callback.onSuccess(fruits)\n            } catch (e: Exception) {\n                callback.onFailure(e)\n            }\n        }.apply {\n            start()\n            join()\n        }\n    }\n\n    private companion object {\n        val fruits = listOf(\n            \"사과\",\n            \"망고\",\n            \"체리\",\n            \"바나나\",\n            \"레몬\",\n            \"수박\",\n            \"달콤한 라임\",\n            \"오렌지\",\n            \"키위\"\n        )\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAPI 호출을 하는 저장소:\n\n```js\nclass FruitsRepository(\n    fruitService: FruitService\n) {\n\n    private var _service: FruitService = fruitService\n\n    fun fetchFruits(callback: Callback\u003cList\u003cString\u003e\u003e) {\n        _service.fetchFruits(callback)\n    }\n}\n```\n\n# 1. Callback 접근 방식 이해\n\n일반적인 콜백 기반 함수부터 시작해봅시다. 비동기 작업을 하는 과일 데이터를 가져오는 작업이 있으며 결과를 반환하기 위해 콜백을 사용한다고 가정해봅시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nfun fetchFruitsLegacyWay(repository: FruitsRepository) {\n    repository.fetchFruits(object : Callback\u003cList\u003cString\u003e\u003e {\n        override fun onSuccess(response: List\u003cString\u003e) {\n            println(\"fetchFruitsLegacyWay: onSuccess: $response \")\n        }\n\n        override fun onFailure(e: Throwable) {\n            println(\"fetchFruitsLegacyWay: onFailure: ${e.message} \")\n        }\n    })\n}\n```\n\nCallback을 사용하여 API 호출하는 방법:\n\n```kotlin\nfun main() {\n    val repository = FruitsRepository(LegacyDataSource())\n    fetchFruitsLegacyWay(repository)\n}\n```\n\n# 2. 코루틴으로 변환하기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이를 코루틴 기반 접근 방식으로 변환하려면 다음 단계를 따르세요:\n\n- 서스펜드 함수 생성: 콜백 함수를 서스펜드 함수로 변경합니다.\n- 코루틴 빌더 사용: launch 또는 async를 사용하여 코루틴 스코프 내에서 서스펜드 함수를 호출합니다.\n- 예외 처리: 콜백 오류 메서드 대신 코루틴 내에서 try-catch를 사용하여 예외를 처리합니다.\n\n## 단계별 변환\n\n서스펜드 함수 정의: 콜백을 제거하고 함수를 서스펜드로 변경하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 내용을 추가하여 Service Interface를 업데이트하세요:\n\n```kotlin\nsuspend fun fetchFruits(): List\u003cString\u003e // 새로운 중단 함수\n```\n\n아래 코드를 추가하여 FruitsDataSource를 업데이트하세요:\n\n```kotlin\n// 과일 목록을 가져오는 중단 함수\noverride suspend fun fetchFruits(): List\u003cString\u003e {\n    delay(1000) // API 호출을 모방하기 위한 지연\n    return fruits\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래의 코드를 추가하여 FruitsRepository를 업데이트해주세요:\n\n```kotlin\noverride suspend fun fetchFruits(): List\u003cString\u003e  {\n    return _service.fetchFruits()\n}\n```\n\n사용하는 Suspend Function 호출하기: launch 또는 async와 같은 코루틴 빌더를 사용하여 suspend function을 호출합니다.\n\n## launch를 사용한 예시''\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nprivate suspend fun fetchFruitsUsingCoroutine(repository: FruitsRepository) {\n    try {\n        println(\"fetchFruitsUsingCoroutine 성공:${repository.fetchFruits()}\")\n    } catch (ex: Exception) {\n        println(\"fetchFruitsUsingCoroutine 실패:${ex.message}\")\n    }\n}\n```\n\n```js\nfun main() = runBlocking {\n    // IO 컨텍스트에서 코루틴 실행\n    launch(Dispatchers.IO) {\n        try {\n            val repository = FruitsRepository(LegacyDataSource())\n            fetchFruitsUsingCoroutine(repository)\n            println(result) // Output: 서버로부터의 과일 목록\n        } catch (e: Exception) {\n            e.printStackTrace()\n        }\n    }\n}\n```\n\n# 3. Async/Await를 사용한 여러 작업 처리\n\n만약 여러 비동기 태스크를 수행해야 한다면, 코루틴은 동시 실행을 위해 async를, 결과를 기다리기 위해 await를 사용하여 더 우아하게 처리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 코루틴을 이용한 여러 작업\n\n```js\nfun main() = runBlocking {\n  val repository = FruitsRepository(LegacyDataSource())\n\n  val fruits1 = async { repository.fetchFruits() } //API 호출 1\n  val data1 = fruits1.await()\n  println(\"Data1: $data1\") // 출력: 서버에서 과일 목록\n\n  val fruits2 = async { repository.fetchFruits() } // API 호출 2\n  val data2 = fruits2.await()\n  println(\"Data2: $data2\") // 출력: 서버에서 과일 목록\n}\n```\n\n# 4. 기존 코드 통합\n\n기존 콜백을 사용하는 레거시 시스템과 통합할 때, suspendCoroutine 또는 suspendCancellableCoroutine을 사용하여 콜백 기반 코드를 코루틴으로 래핑할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 예시: 코루틴을 이용한 콜백 감싸기\n\n```kotlin\nprivate suspend fun fetchFruitsUsingCoroutines(repository: FruitsRepository) {\n  suspendCoroutine { continuation -\u003e\n      repository.fetchFruits(object : Callback\u003cList\u003cString\u003e\u003e {\n          override fun onSuccess(response: List\u003cString\u003e) {\n              continuation.resume(response)\n          }\n\n          override fun onFailure(e: Throwable) {\n              continuation.resumeWithException(e)\n          }\n      })\n  }.let {\n      println(\"fetchFruitsUsingCoroutines: Response: $it\")\n  }\n}\n```\n\n# 5. 코루틴 사용의 장점\n\n- 가독성: 코루틴을 사용하면 동기 코드처럼 보이고 동작하는 비동기 코드를 간편하게 작성할 수 있습니다.\n- 확장성: 코루틴은 가벼우며 많은 수의 동시 작업을 효율적으로 처리할 수 있습니다.\n- 구조화된 병행성: 비동기 작업의 라이프사이클을 보다 효과적으로 관리할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n콜백을 코루틴으로 변환하면 코드를 현대화하여 유지 및 확장하기 쉬워집니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtouseaCoroutineinsteadofCallback_0.png"},"coverImage":"/assets/img/2024-06-23-HowtouseaCoroutineinsteadofCallback_0.png","tag":["Tech"],"readingTime":8},{"title":"WhatsApp 앱을 삭제하면 일어나는 일 정확히","description":"","date":"2024-06-23 23:26","slug":"2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly","content":"\nWhatsApp 앱을 스마트폰에서 삭제하면 어떻게 될까요? 필요한 모든 정보가 여기 있습니다.\n\n![WhatsApp](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_0.png)\n\n안녕하세요, WhatsApp 애찬러 여러분! WhatsApp을 삭제하면 어떻게 될지 생각해 보신 적이 있나요? 너무 많은 알림을 받아 지친다거나 소셜 미디어에서 쉬고 싶어서 삭제를 고려 중이시라면 어쨌든, WhatsApp을 삭제하면 어떤 일이 일어나는지 그리고 이것이 좋은 생각인지 탐구해보려고 합니다.\n\n# WhatsApp을 삭제하면 어떤 일이 벌어질까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n휴대폰에서 WhatsApp을 삭제하기로 결정했군요. 그럼 이제 어떻게 해야 할까요? 먼저 홈 화면에서 앱 아이콘이 사라진 것에 놀라실 것입니다.\n\n걱정 마세요. 채팅 기록과 미디어 파일은 기기에 저장되어 있어, 나중에 앱을 재설치하기로 결정하면 이를 검색할 수 있습니다. 그러나 WhatsApp 계정을 삭제하기 전에 앱을 삭제한다면, 채팅 기록과 미디어 파일은 영원히 손실됩니다. 그러니 그 '삭제' 버튼을 누르기 전에 잘 생각해 보세요!\n\n![WhatsApp 삭제 vs. 삭제](https://miro.medium.com/v2/resize:fit:1000/0*mx-YpBjt4SgHRRd_.gif)\n\n# WhatsApp 삭제 vs. 삭제\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n먼저, WhatsApp 계정을 삭제하는 것과 삭제하는 것의 차이점을 명확히 해보겠습니다. WhatsApp 계정을 삭제하면 더 이상 아무도 당신의 WhatsApp 프로필이나 상태 메시지를 볼 수 없으며, 당신에게 메시지를 보낼 수도 없습니다.\n\n하지만 여전히 스마트폰에 WhatsApp 앱이 남아 있게 됩니다.\n\nWhatsApp 계정을 사용하여 받은 모든 미디어 파일, 오디오, 이미지 및 비디오는 그대로 남게 됩니다.\n\n그러나 앱을 삭제(삭제)만 한다면, 여전히 당신의 프로필 사진과 WhatsApp 상태 메시지가 모든 연락처에게 표시되고, 메시지를 보낼 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![image](https://miro.medium.com/v2/resize:fit:700/0*H3kj8ruicOo_ZvVG.gif)\n\n앱을 삭제하면 기기에서 완전히 제거되며, 백업을 하지 않은 경우에는 채팅 기록이 함께 삭제됩니다. 따라서 삭제 버튼을 누르기 전에 신중하게 생각해보세요. 모든 부끄러운 채팅 메시지를 잃고 싶지 않으시죠!\n\nWhatsApp 앱을 삭제하면 먼저 해당 애플리케이션이 기기에서 제거됩니다. 그러나 WhatsApp을 통해 받은 미디어 파일은 여전히 기기에 남아 있습니다. 이를 모바일 갤러리에서 확인할 수 있습니다.\n\nWhatsApp 폴더에 접근하여 파일 관리자를 통해 WhatsApp 백업 파일을 찾을 수 있습니다. 따라서 앱을 다시 설치할 때 앱 내에서 빠르게 백업 복원을 시작하고 모든 채팅 및 대화를 다시 받을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 왓츠앱 앱을 삭제한 후 채팅 메시지는 어떻게 됩니까?\n\n왓츠앱을 백업하지 않고 삭제하면 채팅 메시지가 영원히 사라집니다. 따라서 앱을 삭제하기 전에 데이터를 백업하는 것이 중요합니다.\n\n게다가, 데이터를 백업하는 것은 매우 쉽습니다 — 왓츠앱 설정으로 이동하여 “채팅”을 클릭한 다음 “채팅 백업”을 선택하세요. 왓츠앱을 삭제하기 전에 꼭 이 작업을 해 주세요! 이렇게 하면 나중에 왓츠앱을 다시 설치하면 채팅 메시지를 복구할 수 있습니다.\n\n# 그룹 대화는 어떻게 됩니까?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아, 사랑받는 그룹 채팅. WhatsApp을 삭제하거나 제거하면 그룹 채팅이 어떻게 될까요? 그룹 대화에 참여 중인 경우 앱을 삭제하거나 제거해도 그룹에서 제거되지는 않지만 백업을 수행하지 않았다면 채팅 내용이 삭제됩니다.\n\n하지만 걱정하지 마세요. WhatsApp 백업을 가지고 있다면 채팅 내용을 되찾을 수 있습니다.\n\n# WhatsApp 연락처에는 여전히 나를 볼 수 있나요?\n\n네, 연락처는 여전히 내 연락처를 저장한 사람에게는 보이게 됩니다. 게다가 WhatsApp 프로필과 WhatsApp 소개글은 여전히 그들에게 보이게 됩니다. 그러나 WhatsApp은 6개월 동안 접근되지 않은 계정을 자동으로 삭제하는 정책을 가지고 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 마크다운 형식으로 표 태그(table tag)를 변경해주세요.\n\n![이미지](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_1.png)\n\nWhatsApp을 삭제하기로 결정했다면, 6개월 이내에 앱을 재설치하면 계정이 그대로 유지됩니다. 하지만 6개월 동안 앱을 삭제한 채 유지한다면, WhatsApp은 자동으로 계정을 삭제합니다.\n\n# WhatsApp 삭제 여부 확인하는 방법\n\n만약 누군가가 WhatsApp을 삭제했는지 궁금하다면, 몇 가지 지표를 주목하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n얼굴책 앱을 제거한 사람에게 특별한 알람이 없습니다. 그러나 텍스트를 보내면 메시지가 전달되지 않았다는 것을 알 수 있습니다.\n\n아래 스크린샷을 보면 언인스톨한 WhatsApp 어카운트가 어떻게 보이는지 확인할 수 있습니다.\n\n프로필을 선택하면 유료 프로필 사진과 소개가 여전히 보이는 것을 알 수 있습니다.\n\n![WhatsApp 어플 제거 시 모습](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# WhatsApp을 삭제하는 경우의 잠재적 인과:\n\nWhatsApp을 삭제하면 고려하지 못했을 일부 결과가 발생할 수 있습니다. 예를 들어 WhatsApp은 비즈니스 목적으로 일반적으로 사용됩니다. 앱을 삭제하면 고객이나 동료로부터 중요한 메시지를 놓칠 수 있습니다. 게다가 WhatsApp을 사용하는 친구나 가족이 있다면 중요한 업데이트나 초대장을 놓칠 수도 있습니다.\n\n하지만 걱정하지 마세요. WhatsApp 대신 사용할 수 있는 Telegram 또는 Signal과 같은 대안 메시징 앱이 있습니다. 또는 시크릿 텍스트 앱을 사용할 수도 있습니다.\n\n# WhatsApp 삭제 이유\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWhatsApp을 제거하기로 결정한 이유는 여러 가지가 있을 수 있어요. 개인 정보 보호에 대해 걱정되고 소셜 미디어 사용을 제한하고 싶은 경우도 있을 것이고, 너무 많은 알림을 받아 지쳤을 수도 있어요.\n당신의 이유가 무엇이든, 중요한 건 당신의 개인적인 필요와 선호에 따라 결정해야 한다는 것을 기억하는 것이 중요해요.\n\n![WhatsApp Uninstall](https://miro.medium.com/v2/resize:fit:702/0*ag0UkOO8ba1z6xrG.gif)\n\n# WhatsApp 제거에 대한 제 경험\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n왜 WhatsApp를 제거하면 어떤 일이 벌어질지 궁금한가요? 진정한 WhatsApp 사용자로서, 제가 직접 실험을 해보고 결과를 공유해봤어요.\n\n우선, 폰에서 WhatsApp을 삭제했어요. 그 폰에는 소중한 대화와 그룹 채팅이 있었는데요.\n\n만약 WhatsApp을 삭제하면, 다른 사람들이 여전히 연락처 정보를 볼 수 있습니다. 그들이 여전히 당신의 전화번호를 연락처에 저장해 놓았다면, 당신의 프로필을 볼 수 있고 WhatsApp 소개글을 확인할 수 있어요.\n\n# 다시 앱을 설치할 때\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nWhatsApp을 재설치하여 대화 및 백업이 어떻게 되는지 확인하고 앱이 없는 상태에서 받은 새 메시지가 있는지 확인해 보았어요.\n\n![이미지](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_3.png)\n\n놀랍게도, 해당 WhatsApp 계정으로 여전히 메시지를 보낼 수 있었어요. 메시지가 전송되었지만 전달된 것은 아닌 틱으로 표시되었어요.\n\n# 백업 없이 WhatsApp을 재설치한 후 발생한 일들:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 휴대전화 번호를 입력하고 OTP를 받은 후, WhatsApp은 내 이름을 입력하고 모두 허용하기만 하면 앱에 재접속하라고 요청했어요. 그런데, 세 명의 연락처가 나에게 메시지를 보냈지만, 그 메시지들은 처음부터 목록에 없었다는 것을 깨달았어요.\n\n![그림](/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_4.png)\n\nWhatsApp은 최근 그룹에 가입했다는 메시지를 표시해요. WhatsApp을 백업하지 않고 삭제한 후 재설치하면 이전에 가입한 모든 그룹을 여전히 볼 수 있어요.\n\n또한, 여러분이 앱을 사용하지 않을 때 누군가가 메시지를 보낸 경우, 그 메시지들은 \"메시지 대기 중\"으로 표시돼요. 재설치 후 몇 분 후에는 그 메시지들이 표시되지만, 15일 또는 28일 이상된 이미지를 받았다면 다운로드할 수 없을 거예요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n실험 결과, WhatsApp을 삭제해도 프로필과 대화를 완전히 삭제되지 않을 수 있다는 것을 보여줬어요. 그러나 삭제하기 전에 백업을 하지 않으면 몇 가지 메시지와 이미지를 놓칠 수 있습니다.\n\n그래서, 다음에 WhatsApp을 삭제하려면 삭제 전에 백업을 하는 것이 좋아요!\n\n# 결론\n\n그래서, WhatsApp을 삭제해야 할까요? 개인적인 선호도와 필요에 따라 다릅니다. 개인 정보 보호에 대해 걱정되거나 소셜 미디어에서 잠시 쉬어야 할 때 WhatsApp을 삭제하는 것이 좋은 아이디어일 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그러나 업무나 친구, 가족과의 소통에 WhatsApp을 의존하고 있다면, 앱을 삭제하기 전에 한 번 더 신중히 생각해야 할 것입니다.\n\n최종 결정은 여러분에 달려 있지만, WhatsApp을 삭제한다면 대체 메시징 앱이 있음을 기억해야 합니다.\n\n요약하면, WhatsApp을 삭제하는 것은 즉각적인 영향과 아직 고려하지 못한 잠재적인 결과를 초래할 수 있습니다.\n\n그러므로 개인적인 필요와 선호 사항을 고려해 최선의 결정을 내리는 데 시간을 들이세요! 결정을 내리기 전에 장단점을 따져보고, WhatsApp을 삭제하기로 결정할 경우 대체 메시징 앱이 있음을 잊지 마세요.\n","ogImage":{"url":"/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_0.png"},"coverImage":"/assets/img/2024-06-23-ThisHappenWhenyouuninstallWhatsAppAppexactly_0.png","tag":["Tech"],"readingTime":9},{"title":"애플이 Beeper Mini를 중단한 것은 100 옳았다 - 이유는 무엇일까","description":"","date":"2024-06-23 23:25","slug":"2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini","content":"\n![Beeper](/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png)\n\n내가 미쳤다고 생각할지도 모르는 전환 속에, 나는 Apple이 Beeper가 iMessage를 Android로 가져오려는 시도를 차단한 것이 완전히 옳았다고 믿습니다. iMessage가 Android에서 작동하는 것이 나쁠 것이라고 하는 게 아니라, Beeper가 운영 방식이 내 책에서는 그리 괜찮았기 때문입니다.\n\nBeeper의 블로그는 \"안드로이드 및 iPhone 고객들은 고화질 이미지/비디오, 암호화, 이모티콘, 타이핑 상태, 읽은 표시 및 모든 최신 채팅 기능과 함께 채팅할 수 있기를 간절히 원한다\"고 주장합니다.\n\niMessage는 이러한 기능을 제공합니다. 다만, Android 폰에는 그렇지 않습니다. Beeper의 해결책은 무엇인가요? iMessage를 Android로 가져오는 것입니다!\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n문제는 실행 방식에 있습니다.\n\niMessage는 Apple 기기인 iPhone, iPad, Mac 및 Apple Watch와 함께 사용하도록 만들어졌습니다. Android나 Android 기기와 함께 사용하거나 이용할 수 있도록 만들어지지 않았습니다.\n\n그리고 iMessage를 작동시키려면 Beeper가 시스템을 속여야 합니다.\n\n# Beeper Mini란 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nBeeper Mini는 안드로이드 앱으로, Apple의 iMessage 프로토콜을 역공학으로 메시지를 보내어 어떤 안드로이드 폰이라도 iMessage를 사용할 수 있도록 설계되었습니다.\n\nBeeper는 기기에서 암호화 키를 생성하고 공개 키를 Apple에 업로드합니다. 그러나 iMessage가 있는 iPhone에서와 같이 Apple 푸시 알림 서비스를 사용하는 대신, Beeper는 Apple의 서버와 상호작용하고 새 메시지 알림을 사용자에게 통지하는 Beeper Push Notification(BPN) 서비스를 개발했습니다.\n\n여기서 주목할 점은, 이것이 iMessage의 단순한 모방이 아니라는 것입니다. Beeper의 시스템은 권한 없이 실제로 Apple 서버를 사용하도록 설계되었습니다.\n\nBeeper는 Android로 iMessage를 가져오려는 첫 번째 시도가 아닙니다. Nothing Chats는 성공적으로 - 잠시 동안 - Nothing 폰에서 iMessage를 작동시켜마지만 중단되었습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n정말로, Beeper는 똑똑한 시스템입니다. 그리고 그것은 작동하는 것처럼 보입니다. 하지만 그것이 옳다고는 할 수 없습니다.\n\n# 애플에 의한 종료\n\nBeeper Mini가 처음 출시된 후 얼마 지나지 않아 애플에 의해 종료되었습니다. 애플은 Beeper가 애플의 재산을 오용했다는 우려를 제기하면서 이를 타당하게 꼽았습니다.\n\n분명히, Beeper가 iMessage를 사용하는 방식을 기준으로 볼 때, 이것이 iMessage의 규정 위반인 것처럼 보이지는 않습니다. 그것은 좋은 소식입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만, 애플 시스템을 오용하는 것은 아닙니다.\n\n일부 사람들은 애플이 Beeper Mini를 폐쇄한 주된 또는 유일한 동기가 iMessage의 독점성을 보존하는 것인지 주장해왔습니다. 애플은 진정으로 보안에 관심이 없고 안드로이드 사용자를 제외하기만을 원한다고 말하는 사람들도 있습니다.\n\n이것이 사실인지 아닌지 논쟁할 수 있습니다. 하지만 실제로 그렇다 하더라도, 애플이 자사 시스템과 지적 재산을 보호할 권리는 없을까요?\n\n네, 정답은 네입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n여기서의 문제는 두 가지입니다:\n\n- Beeper가 아이폰 간의 메시지를 주고받는 것으로 시스템을 속이기 위해 직접 Apple 서버에 연락하고 있습니다.\n- Beeper는 \"네이티브 iMessage 앱과 Apple 서버 간에 전송되는 트래픽을 분석하고 동일한 요청을 보내고 동일한 응답을 이해하는 자체 앱을 개발했다\"고 주장합니다. 다시 말하면, 그들은 Apple의 지적 재산을 역공학으로 분석했습니다.\n\nBeeper가 종료된 지 얼마 후에 약간의 수정을 거쳐 다시 온라인으로 돌아왔습니다.\n\n현재 상황은 좋은 점과 나쁜 점이 혼재되어 있습니다 -- 어떤 사람에게는 작동되는 반면 다른 사람에게는 작동되지 않을 수 있습니다. 내 추측으로는, Apple이 비공식적으로 모두 종료하게 될 것으로 생각됩니다. 그리고 Beeper가 다시 돌아온다 하더라도, 그들이 앞으로 하게 될 일은 그냥 야생의 고양이와 마우스 장난일 것으로 예상합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# “Apple just wants to keep iMessage exclusive.”\n\n애플을 비판하는 사람들은 Beeper를 종료하기로 한 애플의 결정이 그 서비스 및 사용자의 보안을 위해서가 아닌 사악하게 행동했다고 주장합니다. 그들은 애플이 iMessage의 독점성을 보전하고 안드로이드 사용자를 생태계 밖으로 배제하기 위해 행동했다고 주장합니다.\n\n일단 그게 사실이라고 가정해 봅시다. 가정해 봅시다.\n\n그게 잘못된 건가요? 그게 문제가 될까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n회사가 자신의 재산에 대해 원하는 대로 할 권리가 없습니까? Apple이 iPhone 사용자를 위한 독점 기능으로 자사의 재산 인 iMessage을 유지할 권리가 없습니까? 물론, 그 권리가 있습니다.\n\n그러나 여기에는 더 많은 것이 작용할 수 있다고 말할 수도 있습니다.\n\nBeeper는 제3자 응용 프로그램을 통해 Apple 서버로 메시지를 보내고, 이 응용 프로그램 자체가 역공학이 된 iMessage 프로토콜을 사용하여 작동합니다.\n\n모든 면에서 그것은 걱정스럽습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알았어요! 테이블 태그를 마크다운 형식으로 변경할게요.\n\n| 번호 | 제품   | 가격 |\n| ---- | ------ | ---- |\n| 1    | 사과   | $1   |\n| 2    | 바나나 | $2   |\n| 3    | 체리   | $3   |\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n애플은 아직도 다른 애플 기기가 아닌 기기들과 통신하기 위해 SMS를 사용하고 있다는 사실이 맞아요. 그렇죠. 그리고 이것이 바뀌어야 한다는 사실도 맞아요 (그리고 곧 바뀔 예정이에요).\n\n하지만 이게 변명이 될까요?\n\n애플 시스템을 일부러 남용하는 것을 옹호할 이유가 될까요?\n\n아마 그렇지 않아요. 그렇지 않다고 생각해요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n사실 안드로이드 및 iPhone 사용자들은 SMS를 사용하지 않고도 함께 채팅할 수 있는 방법이 있습니다.\n\n메신저, WhatsApp, Signal 등을 통해 누군가에게 메시지를 보내려면 상대방도 해당 앱의 사용자여야 하지만, 그런 건 어렵지 않죠.\n\n안드로이드 및 iOS 사용자들이 iMessage 사용자들이 오늘날 즐기는 많은 채팅 기능을 곧 누리게 될 때를 기대합니다.\n\n애플의 시스템을 잘못 사용하는 것은 좋은 해결책이 아닙니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# \"애플이 보안에 중요시한다면, 왜 아직도 SMS를 사용하나요?\"\n\n확실히 상대적으로 보안 수준이 낮은 SMS에서 전진할 수 있다면 좋을텐데, 다행히 Apple은 곧 SMS를 버리고 RCS를 선호하게 될 것입니다.\n\n하지만 여러 번 읽어본 바에 의하면, Apple이 Beeper를 차단한 것은 사실상 iMessage 독점성을 보호하기 위한 조치일 뿐이며, 여전히 SMS를 사용한다는 점 때문에 보안에 중점을 두지 않고 있다는 주장을 볼 수 있습니다.\n\n다시 말해, 정말로 보안과 개인 정보 보호를 중요시한다면, 먼저 SMS를 대체할 것에 집중해야 한다는 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n하지만 그게 어떻게 작동하는지 아시나요? 이건 빨간 물고기라고 할만한 거예요.\n\n우리는 집 침입을 변론할 때 창문 잠금에 실패한 집 주인을 꺼내들어 가장하지 않아요. 창문을 잠그지 않아서 잘못했나요? 네. 그럼 침입은 여전히 잘못인가요? 네.\n\n두 가지가 모두 맞아요. 둘 다 나쁘지만, 사실이에요.\n\n# 여기서 객관적으로 생각해 보기\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n어떤 사람들이 나를 애플 열광자로 생각할 수 있다는 걸 방지하기 위해 먼저 말하지만, 전 그렇지 않아요. 쿠퍼티노에서 보여준 소비자에게 해로운 여러 가지 결정들에 대해 공개적으로 비판했어요. 그 중 일부는 다른 것보다 더 화나게 만들기도 했죠.\n\n나는 소비자들에게 해로운 것으로 생각되는 결정들을 눈치 없이 비판하는 데 전혀 문제가 없고 때로는 절대적으로 악의적이라고 생각되는 결정들도 있어요. 오랫동안 나의 글을 따라온 사람들은 그것을 알 것이에요.\n\n그러나 한 발 물러나서 명확한 머리로 생각해보면 분명해요: 여기서 나쁜 사람은 애플이 아니에요.\n\nBeeper는 애플의 프로토콜을 역공학적으로 재구성하여 복사했고 (이것이 첫 번째 문제입니다), 이를 사용하여 애플의 서버와 통신하며 사실상 사용자를 대신해 애플 기기인 척 했어요. (여기가 두 번째 문제입니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n너아 둘 다 괜찮은 게 아니야.\n\n일단, Beeper가 하려고 했던 것이 나쁜 것은 아니야. iMessage는 훌륭하고, 안드로이드 사용자가 공식적으로 사용할 수 있으면 좋겠어. 하지만 지금까지 그런 일은 일어나지 않았어.\n\n아무도 채팅에서 \"초록색 버블\"이 되어서 부끄러워하거나 나쁜 기분을 가져야 하는 일은 없어야 해 — 네, 그렇게 되는 경우도 있지. 나는 그것이나 그런 행동을 옹호하고 있지 않아.\n\n하지만 애플의 지적 재산권을 역공학하고 애플 시스템을 속이기 위해 사용하는 것은 해결책이 될 수 없어 — 비록 그 취지가 좋다고 해도.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 어떻게 변경해야 할까요?\n\n전체적으로 iPhone을 사용하고 iMessage를 즐겨 사용하는 것을 알려드리고 싶어요. 그래서 이 서비스를 좋아합니다. 이 서비스를 통해 일상적인 모든 문자 메시지 교류에 사용할 수 있다면 좋을텐데, 몇 가지 좋은 기능을 제공하기 때문이에요. 예를 들어, 누군가가 내 메시지를 확인했거나 응답을 입력 중이거나 하는 것을 볼 수 있어요. 이런 기능들은 당연하게 여기고 사용하고 있습니다.\n\n하지만 이런 기능들이 2023년에 모두에게 제공되지 않는다는 것은 안타깝네요. 그래서 Android 사용자들도 이런 기능을 사용할 수 있도록 만들어지면 좋겠어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n현대화된 문자 메시징이 필요한 시대입니다: RCS. 그 불충분한 기능을 가진 SMS는 마치 1990년대의 것처럼 느껴집니다. 아마 그래서 iMessage가 많은 사람들에게 매력적으로 느껴지는 이유일지도 모르겠네요?\n\n제가 여기서 확실히 말씀드리고 싶은 것은, 저는 애플의 구식한 문자 메시징 방식을 결코 옹호하는 것이 아닙니다. 그들은 이제야 현대화되어야 했다고 생각해요.\n\n하지만, 그래도 Beeper의 행동을 변명할 수는 없어요.\n","ogImage":{"url":"/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png"},"coverImage":"/assets/img/2024-06-23-AppleWas100RIGHTtoShutDownBeeperMini_0.png","tag":["Tech"],"readingTime":10},{"title":"Turkcell 다중 프로젝트 환경에서 Gradle 원격 캐시 사용법","description":"","date":"2024-06-23 23:23","slug":"2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell","content":"\n소프트웨어 개발의 빠르게 변화하는 세계에서는 효율성과 속도가 프로젝트의 성공을 좌우합니다. 저희 터크셀의 데브옵스 팀은 백엔드, 프론트엔드 및 모바일 플랫폼을 아우르는 다양한 프로젝트의 조율을 맡고 있습니다. 각 프로젝트마다 기술적으로 복잡하고 도전적인 부분이 있지만, 이들을 모두 연결짓는 공통 요소는 신속한 빌드 프로세스의 필요성입니다.\n\n![이미지](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png)\n\n그러나 기존의 설정은 큰 어려움을 겪고 있었습니다. 빌드 시간이 길어지면서 배달 일정과 개발자 생산성에 영향을 미치고 있었습니다.\n\n이 문제로 저희는 Gradle의 빌드 캐시 노드 기능을 탐구하고 최종적으로 구현하게 되었습니다. 이 게시물에서는 우리가 이 기능을 OpenShift에 구현한 여정, 직면한 어려움, 창조한 해결책 및 달성한 결과에 대해 나눌 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 빌드 환경에 대한 배경\n\n터키셀의 디지털 서비스에서는 Bip, TV+, Fizy, Lifebox 등과 같은 다양한 안드로이드 프로젝트 포트폴리오를 관리합니다. 각 프로젝트는 고유한 종속성과 빌드 프로세스를 갖고 있어 복잡성과 빌드 시간을 증가시키는 요소로 작용합니다.\n\n저희 파이프라인은 기존에는 Jenkins를 사용하고 있으며 빌드 에이전트로 openshift 포드를 활용하고 있습니다. Jenkinsfile과 포드 템플릿 YAML로 프로세스를 관리합니다. 그러나 이 컨테이너화된 환경에서는 각 빌드가 청소된 상태에서 시작되므로 빌드 사이에 아티팩트가 유지되지 않습니다.\n\n# 해결책 탐색\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 지역 캐시\n\n우선, Maven 프로젝트에서 사용하는 지역 캐싱 솔루션을 구현할 수 있다고 생각했습니다. OpenShift의 Persistent Volume Claims (PVCs)를 사용하여 빌드 아티팩트 및 종속성을 저장하여 다운로드 시간과 빌드 소요 시간을 줄이는 목표를 가졌습니다. 구조는 단순히 pvc를 로컬 디스크로 사용하고 해당 경로를 지역 캐시로 지정하는 것입니다.\n\n```js\ngradle ${GRADLE_OPTIONS} --build-cache --project-cache-dir=${PVC_PATH}/gradle/android/ ${GRADLE_TASKS}\n```\n\nGradle과 함께 사용할 때 이 접근 방식에는 치명적인 결함이 있었습니다. 종속성과 빌드 스크립트를 효율적으로 처리하지만 캐시를 사용할 때 잠금 메커니즘이 발생합니다. 이 잠금 메커니즘은 동시 빌드가 캐시를 손상시키는 것을 방지하지만 동시에 한 번에 하나의 빌드만 캐시를 사용할 수 있음을 의미합니다. 이는 고도로 동시성 환경에서 효과를 크게 감소시킵니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 빌드 캐시 노드\n\n철저한 조사와 고려 끝에, 중앙 캐시로 Gradle의 빌드 캐시 노드를 설정하기로 결정했습니다. Openshift에서 구축하는 것이 가장 좋다고 결정했습니다. 다음 단계는 배포를 설계하고 구현하여 우리의 OpenShift 환경과 호환되도록 견고하게 만드는 것이었습니다. PVC, 배포, 서비스 및 라우트를 적용한 뒤, 우리의 노드가 가동되었습니다.\n\n# 기술적 구현\n\n## 설치\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저희는 전용 PVC를 사용한 배포를 구현했어요.\n\nPVC Yaml:\n\n```js\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: gradle-remote-cache-pvc\nspec:\n  accessModes:\n    - ReadWriteMany\n  resources:\n    requests:\n      storage: 50Gi\n  storageClassName: ocs-external-storagecluster-cephfs\n  volumeMode: Filesystem\n```\n\n배포 Yaml:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```yaml\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: gradle-remote-cache\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: gradle-remote-cache\n  template:\n    metadata:\n      labels:\n        app: gradle-remote-cache\n    spec:\n      volumes:\n        - name: gradle-remote-cache-pvc\n          persistentVolumeClaim:\n            claimName: gradle-remote-cache-pvc\n      containers:\n        - name: build-cache-node\n          args: [\"start\"]\n          image: gradle/build-cache-node:18.1\n          ports:\n            - containerPort: 5071\n              protocol: TCP\n          resources: {}\n          volumeMounts:\n            - name: gradle-remote-cache-pvc\n              mountPath: /data\n          imagePullPolicy: IfNotPresent\n      restartPolicy: Always\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 25%\n      maxSurge: 25%\n```\n\n회사 전체에서 사용할 수 있도록 하려면 서비스와 라우트를 통해 열어야 합니다.\n\n서비스 Yaml:\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: gradle-remote-cache\nspec:\n  selector:\n    app: gradle-remote-cache\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 5071\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n루트 Yaml:\n\n```yaml\nkind: Route\napiVersion: route.openshift.io/v1\nmetadata:\n  name: gradle-remote-cache\nspec:\n  host: \u003c캐시 라우트 URL\u003e\n  to:\n    kind: Service\n    name: gradle-remote-cache\n    weight: 100\n  port:\n    targetPort: 5071\n  tls:\n    termination: edge\n  wildcardPolicy: None\n```\n\n설치 후, 콘솔 로그에 제공된 자격 증명을 사용하여 앱에 로그인합니다. 푸시 권한이 있는 사용자를 만들어 CI/CD 프로세스에서 사용합니다. 또한 개발자들이 로컬 빌드에서 리드 권한만으로 원격 캐시를 사용할 수 있도록 허용합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_1.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 사용법\n\n먼저 settings.gradle에 원격 캐시 구성을 추가해야 합니다.\n\n```js\nboolean isJenkins = System.getenv().containsKey(\"IS_JENKINS\")\n\nbuildCache {\n    if (isJenkins){\n        remote(HttpBuildCache) {\n            url = '\u003c캐시 경로 URL\u003e/cache/'\n            push = true\n            credentials {\n                username = System.getenv(\"GRADLE_REMOTE_CACHE_USERNAME\")\n                password = System.getenv(\"GRADLE_REMOTE_CACHE_PASSWORD\")\n            }\n        }\n    }\n}\n```\n\n빌드 명령에서 캐싱을 활성화해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ngradle ${GRADLE_OPTIONS} --build-cache ${GRADLE_TASKS}\n```\n\n# 초기 결과 및 분석\n\n## 결과\n\n모든 프로젝트를 구현한 후 캐시 크기와 빌드 시간을 관찰했습니다. 초기에는 50GB 공간을 볼륨으로 설정했습니다. 마지막으로 50GB를 초과하여 크기를 200GB까지 늘렸습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n![Gradle Remote Cache for Multi-Project Environment at Turkcell](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_2.png)\n\n성공 결과 시간이 각 프로젝트마다 다릅니다. 일부는 34분에서 11분으로 단축되었습니다.\n\n![Gradle Remote Cache for Multi-Project Environment at Turkcell](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_3.png)\n\n![Gradle Remote Cache for Multi-Project Environment at Turkcell](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일부 프로젝트에서는 시간이 감소하지 않았습니다.\n\n![Image 1](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_5.png)\n\n![Image 2](/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_6.png)\n\n빌드 캐시 노드는 많은 프로젝트의 빌드 시간을 크게 개선했지만 일부 프로젝트에는 개선되지 않았습니다. 이 솔루션의 전체 잠재력은 계속된 개선과 각 프로젝트의 고유한 특성에 대한 더 깊은 이해를 통해 실현될 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 다음 단계\n\nGradle 빌드 캐시 노드가 이제 구현되어 일부 프로젝트 빌드 시간을 상당히 개선하는 결과를 보여주고 있으므로, 다음 단계는 개발자들에 이를 인계하는 것입니다.\n\n초기 결과와 원격 캐시의 효율성을 향상시키는 방법에 대한 제안을 개발 팀에 공유했습니다.\n\n이 도구가 제공하는 장점을 완전히 활용하기 위해서는 시스템을 설정하는 데 그치지 말고, 개발자들이 시스템을 지속적으로 최적화하고 사용하는 것이 필요합니다. 캐싱 메커니즘의 효과적인 사용, 캐시 가능한 작업의 적절한 식별, 의존성 관리, 캐시 히트율을 높이기 위한 필요한 조정은 개발자들이 적극적으로 실시함으로써 이루어질 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n마무리하며, Gradle의 빌드 캐시 노드를 OpenShift에 구현하는 여정은 도전적이고 보람찼습니다. 우리는 많은 프로젝트의 빌드 시간을 크게 줄여 제공 일정의 효율성을 높이고 개발자 생산성을 향상시키는 데 성공했습니다.\n\n하지만, 이로 끝이 아닙니다. 우리는 이 솔루션의 잠재력을 완전히 이용하기 위해 개발자들이 시스템의 사용법을 지속적으로 최적화해야 한다는 점을 인식합니다. 이는 캐시할 수 있는 작업 식별, 의존성 관리, 및 캐시 히트율을 높이기 위해 필요한 조치를 취하는 것을 포함합니다.\n\n# 참고문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nhttps://docs.gradle.com/build-cache-node/\n\nhttps://docs.gradle.org/current/userguide/build_cache.html\n\nhttps://medium.com/@cesarmcferreira/using-gradle-build-cache-server-73d7680baf2a\n","ogImage":{"url":"/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png"},"coverImage":"/assets/img/2024-06-23-GradleRemoteCacheforMulti-ProjectEnvironmentatTurkcell_0.png","tag":["Tech"],"readingTime":10},{"title":"안드로이드 UI 레이어 속성 완전 정복  Part 2","description":"","date":"2024-06-23 23:20","slug":"2024-06-23-CrashCourseontheAndroidUILayerPart2","content":"\n## 상태 보유자 및 상태 저장\n\n이 블로그 포스트 시리즈는 Android 개발자 안내를 UI 레이어에 대해 요약하는 것을 목표로 합니다. 우리는 이에 관련된 모든 엔티티들을 탐색하고, 각 부분이 하는 역할을 이해하며, 최선의 실천법을 논의할 것입니다.\n\n첫 번째 부분에서는 UI와 UI 상태에 대해 다루었습니다. 이미 UI 레이어에 존재하는 다양한 엔티티와 UI 및 UI 상태를 효과적으로 생각하는 방법을 알고 있어야합니다.\n\n이제 Part 2로 넘어가 보겠습니다! 상태 보유자 및 Android에서 UI 상태를 어디에 저장하고 상태를 어디에 끌어올려야하는지와 같은 기타 UI 레이어 관련 주제들을 다룰 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 비디오 형식으로 이 콘텐츠를 보시는 것을 선호하신다면, 2023년 Droidcon 런던에서 제가 진행한 강연을 확인해보세요:\n\n## 상태 보유자\n\n상태 보유자는 로직을 처리하거나 UI 상태를 노출함으로써 UI를 간소화합니다. 이 섹션에서는 어떻게 상태 보유자를 구현하는지와 고려해야 할 구현 세부 사항을 살펴볼 것입니다.\n\n구현 세부 사항을 결정하기 위해 먼저 안드로이드 앱에서 일반적으로 발견되는 로직 유형을 식별해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 논리 유형\n\n이미 비즈니스 논리가 애플리케이션 데이터가 생성, 저장 및 수정되는 방법을 지정하는 제품 요구 사항을 구현하는 것을 의미한다는 것을 이야기했습니다. UI 레이어에 비즈니스 논리가 있는 경우, 이 논리를 화면 수준에서 관리하는 것이 좋습니다. 이후에 더 자세히 살펴보겠습니다.\n\n또 다른 유형의 논리는 UI 논리입니다. UI 논리는 화면 상태 변경을 어떻게 표시할지를 결정합니다. 비즈니스 논리가 데이터를 처리하는 방법을 지시하는 반면, UI 논리는 시각적으로 어떻게 표시할지를 결정합니다. UI 논리는 UI 구성에 의존합니다.\n\n예를 들어, 전형적인 앱에서 세부 화면을 표시하는 것은 휴대폰에서 실행 중일 때 탐색을 포함할 수 있습니다. 그러나 태블릿에서 실행 중일 때는 다른 요소를 옆에 표시하는 것을 의미할 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png\" /\u003e\n\n다른 유형의 로직은 구성 변경에 다르게 반응합니다:\n\n- UI 로직은 구성 변경에 영향을 받는 경우 다시 실행해야 합니다.\n- 비즈니스 로직은 일반적으로 구성 변경 후에 계속되어야 합니다.\n\n예를 들어, 화면 크기 구성 변경 후에 하단 바 또는 네비게이션 레일을 표시할지 여부를 결정하는 UI 로직은 다시 실행하거나 재평가되어야 합니다. 반면, 특정 관심사를 따르거나 업데이트를 새로 고칠 때 사용자가 기기를 회전하거나 펼친다고 해서 비즈니스 로직을 취소하거나 다시 시작해서는 안 됩니다. 그러한 중단은 사용자 경험을 제공하지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 어떤 로직을 처리해야 할까요?\n\nUI 레이어에서 비즈니스 로직은 화면 수준에 가깝게 처리해야 합니다. 대부분의 비즈니스 로직은 데이터 레이어에서 처리됩니다. 따라서, 화면에 가까이 유지함으로써 로직을 올바르게 범위 지정하는 것이 쉬워지고, 저수준 UI 컴포넌트가 비즈니스 로직과 긴밀하게 결합되는 것을 방지할 수 있습니다.\n\n비즈니스 로직은 일반적으로 androidX.ViewModel에서 확장된 화면 수준 상태 홀더가 처리해야 합니다.\n\nUI 로직에 관련된 것은 비교적 간단한 경우, UI 자체에서 관리하는 것이 가능합니다. 그러나 UI가 더 복잡해지면 해당 UI 로직의 복잡성을 일반 클래스 상태 홀더로 위임하는 것이 좋은 아이디어입니다. 이 경우, 상태 홀더는 androidX.ViewModel에서 확장되지 않을 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 섹션에서 이것에 대해 더 자세히 살펴볼거에요! 이제 상태의 다양한 유형과 로직이 서로 어떻게 관련되는지 살펴봅시다:\n\n![image](/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_1.png)\n\n전형적인 화면에서 발생하는 일에 대한 요약으로, 데이터 레이어는 애플리케이션 데이터를 전체 계층에 노출시킵니다. 그런 다음 ViewModel은 그 데이터에 비즈니스 로직을 적용하여 화면 UI 상태를 생성합니다. UI 자체 또는 일반 상태 홀더 클래스는 화면 UI 상태를 관찰하여 UI 요소나 해당 상태를 수정합니다.\n\n# 비즈니스 로직 처리하기 — androidX.ViewModel\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리는 androidX.ViewModel 또는 Architecture Components ViewModel 클래스를 화면 수준 상태 보유자로의 구현 세부사항으로 상세하게 논의해 왔습니다.\n\n아래 코드 조각에서 우리는 주요 기능을 관찰할 수 있습니다: 1) 화면 UI 상태 노출 및 2) 비즈니스 로직 처리.\n\n```js\n@HiltViewModel\nclass InterestsViewModel @Inject constructor(\n  private val userDataRepository: UserDataRepository,\n  authorsRepository: AuthorsRepository,\n  topicsRepository: TopicsRepository\n) : ViewModel() {\n\n  val uiState: StateFlow\u003cInterestsUiState\u003e = ...\n\n  fun followTopic(followedTopicId: String, followed: Boolean) {\n    viewModelScope.launch {\n      userDataRepository.toggleFollowedTopicId(followedTopicId, followed)\n    }\n  }\n\n  ...\n}\n```\n\n그런데 왜 이러한 기능이 ViewModel에 적합한 것일까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## androidX.ViewModel의 장점\n\n가장 큰 장점은 ViewModel이 구성 변경을 견뎌내며 화면 자체보다 더 오랜 수명을 제공한다는 것입니다. ViewModel은 Activity, Fragment, Navigation 그래프 또는 Navigation 그래프의 대상에 대해 범위를 설정할 수 있습니다. 구성 변경이 발생할 때 시스템은 ViewModel의 동일한 인스턴스를 제공합니다.\n\n구성 변경을 견뎌내는 것은 androidX.ViewModel을 화면 UI 상태를 노출하고 비즈니스 로직을 처리하기에 완벽한 위치로 만듭니다. 화면 UI 상태는 구성 변경 전후에도 캐시되어 즉시 사용할 수 있습니다. 그리고 비즈니스 로직은 ViewModel-범위 CoroutineScope(예: viewModelScope로 시작된 경우)로 시작된 경우 계속 실행됩니다.\n\n또 다른 이점은 다른 Jetpack 라이브러리와의 완벽한 통합에 있습니다. 특히 Jetpack Navigation과의 통합이 원활합니다. Navigation은 대상이 백 스택의 일부인 경우 메모리에 ViewModel의 동일한 인스턴스를 유지합니다. 이를 통해 백 스택의 대상 간에 왕복할 수 있으며 데이터가 즉시 화면에 사용 가능하게 하여 해당 대상으로 다시 이동할 때마다 데이터를 다시로드할 필요가 없습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n젯팩 네비게이션은 목적지가 백 스택의 일부가 아닐 때 ViewModel의 인스턴스를 자동으로 파괴합니다. 이로 인해 이전 사용자 데이터가 화면에 표시되지 않고 이전 목적지로 안전하게 이동할 수 있습니다.\n\n다른 젯팩 통합에는 Hilt도 포함됩니다. @HiltViewModel 주석을 사용하면 도메인이나 데이터 레이어의 종속성이 있는 ViewModel을 손쉽게 얻을 수 있습니다.\n\n## androidX.ViewModel 모범 사례\n\nViewModel의 스코프는 화면 수준 상태 보유자의 구현 세부 정보로 이 유형을 적합하게 만듭니다. 그러나 이 권한을 남용해서는 안 됩니다. 이 클래스를 사용할 때 명심해야 할 몇 가지 모범 사례가 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 화면 레벨에서 사용하세요. 재사용 가능한 UI 요소의 복잡성을 처리하기 위해 ViewModel을 사용하지 마세요. 동일한 ViewModel 스코프 내에서 동일한 UI 요소는 동일한 ViewModel의 인스턴스를 받게 되는데, 대부분의 경우 이는 바람직하지 않습니다.\n- ViewModel을 충분히 일반화하여 모든 UI 형식을 수용할 수 있도록 해주세요. ViewModel은 자신을 사용하는 UI가 무엇인지 인식하면 안 됩니다. ViewModel의 API 표면(공개된 Screen UI 상태 및 노출된 함수)은 UI별 세부 사항을 포함하는 대신 처리하는 응용 프로그램 데이터를 나타내야 합니다. 예를 들어, 데이터를 로딩 중임을 나타낼 때, 화면 UI 상태에는 showLoadingSpinner 대신 isLoading이라는 필드가 포함될 수 있습니다. UI가 데이터 로딩을 사용자에게 통지하는 방법은 UI에만 관련이 있습니다.\n- Lifecycle 관련 API에 대한 참조를 유지하지 마세요. ViewModel은 UI보다 오랜 수명을 가지고 있으며 Context나 Resources 객체에 대한 참조를 유지하면 메모리 누수로 이어질 수 있습니다.\n- ViewModel을 전달하지 마세요. 언급된 모든 점을 고려하면 ViewModel 클래스를 화면 수준에 가능한 가깝게 유지하세요. 그렇지 않으면 저수준 구성 요소에 실제로 필요한 상태와 로직보다 더 많은 액세스 권한을 암묵적으로 부여할 수 있습니다.\n\n## androidX.ViewModel 주의사항\n\nViewModel 영역은 모든 면에서 완벽하지 않습니다. 특히 ViewModel의 viewModelScope에 대한 몇 가지 고려할 사항이 있습니다:\n\n- viewModelScope를 사용하여 시작된 작업은 ViewModel이 메모리에 있는 동안 계속 실행됩니다. 이는 좋은 점이지만 작업이 긴 시간 동안 실행될 경우 문제가 발생할 수도 있습니다. 10초 이상 소요될 수 있는 장기 실행 작업의 경우 WorkManager와 같은 다른 대안을 고려해야 합니다. 배경 작업에 대한 자세한 내용은 문서를 참조하세요.\n- viewModelScope에 의해 트리거된 작업을 단위 테스트하기 위해서는 테스트 환경에서 추가 설정이 필요합니다. 테스트에서 MainDispatcher를 교체해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## AndroidX의 ViewModel 사용\n\n이 섹션은 항상 ViewModel을 사용해야 한다는 것을 의미합니까? 네, 화면 수준의 상태 보유자로의 구현을 말하면 그렇습니다. 하지만 이점이 앱에 적용된다면 사용해야 합니다.\n\n구성 변경에 관심이 있다면 (그래야 합니다!) 그리고/또는 다른 Jetpack 라이브러리를 사용 중이라면 이를 사용하는 것이 좋을 수 있습니다. 그러나 사용하지 않기로 결정하더라도, 화면 수준에서 비즈니스 로직 복잡성을 다루는 간단한 화면 수준 상태 보유자 클래스를 도입하는 것을 고려해보세요.\n\n# UI 로직 처리 — 간단한 상태 보유자 클래스\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI가 점점 복잡해지면 상태 보유 클래스를 도입해야 합니다. 기준은 당신과 팀에 달렸습니다. UI를 간소화해야 할 필요성을 느끼는 때입니다.\n\n다가오는 코드 스니펫에서 UI에 대한 상태 보유자를 생성할 필요가 없습니다. 사용자가 UI와 상호 작용할 때 변경되는 확장된 부울 값만 포함되어 있습니다.\n\n```js\n@Composable\nfun \u003cT\u003e NiaDropdownMenuButton(items: List\u003cT\u003e, ...) {\n  var expanded by remember { mutableStateOf(false) }\n\n  Box(modifier = modifier) {\n    NiaOutlinedButton(\n      onClick = { expanded = true },\n      ...\n    )\n    NiaDropdownMenu(\n      expanded = expanded,\n      onDismissRequest = { expanded = false },\n      ...\n    )\n}\n```\n\nUI에 더 많은 상태가 필요하고 관련 로직이 더 복잡해지면 상태 보유자를 도입하세요. Compose 라이브러리가 일부 구성 요소에 대해 수행하는 것과 정확히 동일합니다. 다음 코드 스니펫은 다양한 Drawer 구성 구성 요소의 상태 보유자에 속합니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin {.line-numbers}\n@Stable\nclass DrawerState(\n  initialValue: DrawerValue,\n  confirmStateChange: (DrawerValue) -\u003e Boolean = { true }\n) {\n  internal val swipeableState = SwipeableState(...)\n\n  val currentValue: DrawerValue\n    get() { return swipeableState.currentValue }\n\n  val isOpen: Boolean\n    get() = currentValue == DrawerValue.Open\n\n  suspend fun open() = animateTo(DrawerValue.Open, AnimationSpec)\n\n  suspend fun animateTo(targetValue: DrawerValue, anim: AnimationSpec\u003cFloat\u003e) {\n    swipeableState.animateTo(targetValue, anim)\n  }\n}\n```\n\n여기 몇 가지 주요 포인트가 있어요:\n\n- 이 클래스는 Drawer의 현재 값을 나타내는 것처럼 상태를 유지합니다.\n- 상태 홀더들은 합성 가능합니다. DrawerState는 내부적으로 다른 상태 홀더인 SwipeableState에 의존합니다.\n- UI 로직을 관리하며, 서랍을 여는 동작 및 특정 값으로 애니메이션 하는 등의 작업을 포함합니다.\n\nCompose가 이러한 상태 홀더를 제공하는 것처럼, 당신의 프로젝트에서도 UI를 단순화하기 위해 비슷한 패턴을 구현할 수 있어요. 다음 코드 스니펫은 NiaApp 구성 요소 함수의 상태 홀더인 NiaAppState에 속합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\n@Stable\nclass NiaAppState(\n  val navController: NavHostController,\n  val windowSizeClass: WindowSizeClass\n) {\n  val currentDestination: NavDestination?\n    @Composable get() = navController\n      .currentBackStackEntryAsState().value?.destination\n\n  val shouldShowBottomBar: Boolean\n    get() = windowSizeClass.widthSizeClass == WindowWidthSizeClass.Compact ||\n      windowSizeClass.heightSizeClass == WindowHeightSizeClass.Compact\n\n  fun navigate(...) { ... }\n\n  fun onBackClick() { ... }\n}\n```\n\n비슷한 방식으로,이 클래스는 currentDestination 및 하단 바를 표시해야 하는지 여부와 같은 UI 상태를 노출하고, 네비게이션 및 백 버튼 클릭 이벤트 처리와 같은 UI 논리를 관리합니다.\n\n## 일반적인 상태 보유 클래스의 최상의 관행\n\n재사용 가능한 UI 구성 요소를 위한 상태 보유자를 만드는 것이 좋습니다. 이는 UI의 재사용성을 향상시키고 외부 제어를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일반 상태 보유 클래스는 수명주기 관련 API의 참조를 보유할 수 있습니다. 이 인스턴스들은 UI 수명주기를 따릅니다. UI가 구성 변경을 겪을 때마다 상태 보유 클래스의 새 인스턴스가 생성됩니다. 따라서 Context나 Resources에 대한 참조를 보유해도 메모리 누수가 발생하지 않습니다. Jetpack Compose에서 이러한 상태 보유 클래스는 Composition에도 스코프가 지정됩니다.\n\n일반 클래스가 비즈니스 로직이 필요한 경우, 해당 기능을 클래스에 주입하는 것이 좋은 실천 방법입니다. 이 기능을 주입하는 쪽은 UI 범위를 벗어나도록 보장할 수 있습니다.\n\n## 대규모 ViewModels 다루기\n\nViewModel이 여러 큰 UI 요소들의 비즈니스 로직 복잡성을 처리하고 있는 경우, 이는 크고 관리하기 어렵고 추론하기 어려울 수 있습니다. ViewModel을 어떻게 간소화할 수 있을까요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 도메인 레이어를 소개합니다. ViewModel의 비즼스 로직 복잡성을 다양한 리포지토리와 상호 작용을 처리하는 유즈 케이스에 위임합니다. 그러나 이 접근 방식은 여전히 ViewModel이 의존해야 하는 상당한 수의 유즈 케이스 목록을 일으킬 수 있습니다.\n- UI의 다양한 요소에 대해 여러 상태 홀더를 만들어 그 이점을 모두 누릴 수 있도록 ViewModel에 이를 넣어두세요. ViewModel은 핵심적으로 구성 변경을 견디는 상태 전달 메커니즘이 됩니다.\n- #2 대신, 재사용할 수 없는 UI 요소의 복잡성을 관리하기 위해 여러 개의 ViewModel을 만드는 것을 고려해 볼 수 있습니다. 이러한 방식은 허용되지만, ViewModel은 메모리가 제한되지 않는 상태로 작동하며, 여러 ViewModel을 가지면 그 크기와 메모리 풋프린트를 모니터링하기 어려워질 수 있음을 염두에 두세요.\n\n# 상태를 어디에 둘 것인가\n\n상태를 읽거나 쓰는 가장 낮은 공통 조상에 둘 것을 권장합니다.\n\n요약하면: UI에서 상태가 전혀 없을 수 있고, UI 자체에 상태가 있을 수도 있고, UI를 단순화하기 위해 상태 홀더에 상태가 있을 수도 있고, 다른 구성 요소 호출자나 조상이 상태를 제어할 수 있도록 UI 트리 상단에 상태를 올릴 수도 있고, 비즈니스 로직에서 필요한 경우 ViewModel에 상태를 올릴 수도 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIf the state is required by business logic, whether for reading or writing, it should be hoisted in the screen-level state holder. If not, it should be placed in the appropriate node of the UI tree.\n\nLet’s take a look at the UI hierarchy of a typical Chat app and discuss why certain state is placed where it is:\n\n![UI Hierarchy](/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_2.png)\n\n- The screen UI state should be placed in the ViewModel (#5) because the ViewModel applies business logic to create it.\n- The LazyList is part of the ConversationScreen and not the MessagesList because the screen has additional functionality that require that state, such as scrolling to the most recent messages when the user sends a new message in UserInput.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 주제에 대해 더 알아보려면 Alejandra Stamato가 하는 State hoisting in Compose 이야기를 확인해보세요.\n\n# UI 상태 저장하기\n\n이 블로그 포스트에서는 androidx.ViewModel API를 사용하여 구성 변경 사항에 걸쳐 상태를 유지하는 수단으로 탐색했습니다. 그러나 안드로이드는 상태를 더 효과적으로 보호하는 추가 대안을 제공합니다.\n\nSavedState API를 사용하면 구성 변경과 시스템에서 시작된 프로세스 종료를 통해 상태가 지속될 수 있습니다. 시스템은 이 데이터를 Bundle에 저장하며, 저장을 위해 데이터를 parcel화해야 합니다. 전형적으로 사용자 입력이나 탐색에 따라 달라지는 일시적 UI 상태를 저장할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그래도, 위에서 언급한 것뿐만 아니라 예상치 못한 앱 종료(예: 사용자가 앱을 강제로 종료)에도 살아남기 위해 지속적인 저장소를 사용할 수 있습니다. 이것은 디스크 공간 제한을 고려해야 하며 일반적으로 응용 프로그램 데이터를 저장하는 데 사용됩니다.\n\n![Crash Course on the Android UI Layer Part 2_3](/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_3.png)\n\n이 주제에 대한 자세한 내용은 Android에서 UI 상태 저장하기 토크를 확인하세요.\n\n# 결론\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nUI 계층에 대한 이 간단한 소개를 읽은 후에는 이 계층 내에서 발생하는 프로세스와 상태 및 로직을 효과적으로 관리하는 데 필요한 도구에 대한 일반적인 이해를 가지고 있을 것입니다.\n\n안드로이드는 앱을 다양한 UI 구성 및 기기에 반응적으로 만들도록 설계되어 있어, 일부 개발자들이 원하는 것보다 약간 복잡한 API 결정 트리들을 만듭니다. 그러나 동시에 예상대로 앱이 동작하도록 하는 도구를 제공해주어 훌륭한 사용자 경험을 전달할 수 있게 해줍니다.\n\n이 내용을 즐기셨기를 바랍니다! 의견을 공유하거나 질문을 하고 싶으시다면 댓글 섹션에서 자유롭게 남겨주세요! 감사합니다 😊\n\n만약 비디오 형식으로 내용을 소화하고 싶다면, 2023년 드로이드콘 런던에서 발표한 제 이야기를 확인해보세요!\n","ogImage":{"url":"/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png"},"coverImage":"/assets/img/2024-06-23-CrashCourseontheAndroidUILayerPart2_0.png","tag":["Tech"],"readingTime":16},{"title":"기초부터 배우는 Kotlin 코루틴 사용법","description":"","date":"2024-06-23 23:18","slug":"2024-06-23-KotlinCoroutinesFundamentals","content":"\n코루틴은 이미 오랫동안 존재하고 있고 여러 다양한 기사들이 그 주변에 존재합니다. 그러나 그것에는 깊은 학습 곡선이 존재하여 Coroutines의 기본 원리를 실제로 이해하는 데 꽤 많은 시간이 걸렸습니다. 그래서 내가 이해한 바에 따라 몇 가지 배운 점을 공유하고 싶다고 생각했습니다.\n\n# 코루틴이란 무엇인가?\n\n코루틴은 협력하는 함수를 의미합니다. 비동기 작업을 처리하는 더 효율적이고 읽기 쉬운 방법을 제공합니다. 쓰레드와 유사하다는 점에서, 일련의 코드 블록을 실행하는데 사용되며 나머지 코드와 동시에 작동합니다. 그러나 코루틴은 특정 쓰레드에 묶이지 않습니다. 한 쓰레드에서 실행을 일시 중단할 수 있고 다른 쓰레드에서 다시 실행할 수 있습니다. 코루틴은 코틀린 1.3 버전에서 출시되었습니다.\n\n# 코루틴의 장점\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 코루틴은 가볍습니다 - 지원하는 ​​일시 정지로 인해 한 쓰레드에서 많은 코루틴을 실행할 수 있습니다. 여기서 일시 정지란 몇 가지 명령을 실행한 다음 해당 코루틴을 실행 중간에 중지하고 원하는 때 이어서 실행할 수 있다는 것을 의미합니다. 일시 정지는 많은 동시 작업을 지원하면서도 차단보다 메모리를 절약합니다.\n- 코루틴은 메모리 누수가 적습니다 - 코루틴은 구조화된 동시성 원칙을 따르며, 각 코루틴은 특정 컨텍스트 내에서 특정한 수명을 갖고 시작되어야 합니다. 구조화된 동시성은 코루틴의 수명이 특정 범위에 묶여 범위 자체가 완료되기 전에 범위 내에서 시작된 모든 코루틴이 완료되도록 하는 방식입니다. 이는 코루틴 누출을 방지하고 리소스 관리를 단순화하는 데 도움이 됩니다.\n- Android에서 코루틴은 Main 안전성을 제공합니다 - 코루틴은 메인 스레드를 블로킹하고 응용 프로그램이 응답하지 않게 만들 수 있는 긴 시간 소요 작업을 관리하는 데 도움이 됩니다. Main 안전성을 통해 어느 suspend 함수도 메인 스레드에서 호출할 수 있도록 할 수 있습니다.\n- 코루틴은 내장된 취소 지원을 제공합니다 - 코루틴의 가장 중요한 메커니즘 중 하나는 취소입니다. Android에서 거의 모든 코루틴이 어떤 뷰와 관련이 있으며 이 뷰가 파괴되면 해당 코루틴은 필요하지 않으므로 취소되어야 합니다. 이는 개발자들에게 많은 노력이 필요했던 중요한 기능이지만, 코루틴은 간단하고 안전한 취소 메커니즘을 제공합니다.\n- 코루틴은 협력적으로 멀티태스킹됩니다 - 이는 코루틴이 협력적으로 실행할 일련의 명령을 실행하고 운영 체제가 코루틴에 의해 수행되는 작업이나 프로세스의 스케줄링을 제어하지 않음을 의미합니다. 대신, 프로그램과 해당 코루틴을 실행하는 플랫폼에 의존합니다. 따라서 코루틴은 다른 쓰레드가 실행되도록 제어를 양보하여 스케줄러에 다시 제어를 위임할 수 있습니다. 운영 체제의 스케줄러는 이러한 쓰레드들이 작업을 수행할 수 있도록 책임을 집니다. 필요한 경우 일시 중단하여 같은 리소스를 다른 쓰레드가 사용할 수도 있습니다.\n\n# 코루틴의 키워드\n\n코루틴에 대해 학습할 때 마주치게 될 몇 가지 일반적인 키워드입니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png\" /\u003e\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 중지 함수\n- Coroutine Scope (Dispatchers, Job 포함)\n- Coroutine 빌더\n- Coroutine Context\n\n## `중지` 함수\n\n중지 함수는 일시 중지되고 나중에 계속할 수 있는 함수입니다. 중지 함수는 해당 함수가 중지될 수 있다는 것을 나타내며, 비차단 작업이 완료될 때까지 기다리는 동안 다른 코루틴이 실행될 수 있습니다. 중지 함수가 실행되는 동안 해당 코루틴은 실행되던 스레드를 해제하고 다른 코루틴이 그 스레드에 액세스할 수 있도록 합니다(코루틴은 협력적이기 때문입니다).\n\n중지 함수의 구문은 일반 함수의 구문과 동일하지만 `suspend` 키워드가 추가됩니다. 중지 함수는 코루틴이나 다른 중지 함수에서만 호출할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nsuspend fun doSomething(): Int {\n    delay(1000L) // 여기서 유용한 작업을 수행하는 것처럼 가정합니다\n    return 13\n}\n```\n\n## 코루틴 스코프\n\n코루틴 스코프는 코루틴의 수명 주기/수명을 정의합니다. 일련의 코루틴 및 해당 컨텍스트의 수명을 제어하는 역할을 합니다. CoroutineScope는 생성된 모든 코루틴을 추적합니다. 따라서 스코프를 취소하면 생성된 모든 코루틴이 취소됩니다. 부모 코루틴 내에서 자식 코루틴이 시작될 때 부모 스코프를 상속합니다(별도로 지정하지 않은 경우) 따라서 부모 코루틴이 중지되면 자식 코루틴도 중지됩니다.\n\nAndroid에서는 코루틴에는 세 가지 기본 스코프가 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 글로벌 범위: GlobalScope는 전체 애플리케이션 수명 동안 지속되는 미리 정의된 코루틴 범위입니다. 편리할 수 있지만 일반적으로 구조화된 동시성을 보장하기 위해 사용자 정의 코루틴 범위를 사용하는 것이 권장됩니다.\n\n```kotlin\nGlobalScope.launch {\n        val config = fetchConfigFromServer() // 네트워크 요청\n        updateConfiguration(config)\n    }\n```\n\n- LifeCycle 범위: LifecycleOwner(프래그먼트 액티비티)의 수명에 바인딩됩니다. 프래그먼트 액티비티가 파괴되면 이 범위의 코루틴도 취소됩니다. LifecycleScope를 사용하면 특별한 실행 조건을 사용할 수도 있습니다:\n\n* launchWhenCreated는 라이프사이클이 최소한 생성 상태에 있을 때 코루틴을 시작하고 파괴 상태에 있을 경우 일시 중단합니다.\n* launchWhenStarted는 라이프사이클이 최소한 시작 상태에 있을 때 코루틴을 시작하고 중지 상태에 있을 경우 일시 중단합니다.\n* launchWhenResumed는 라이프사이클이 최소한 재개 상태에 있을 때 코루틴을 시작하고 일시 중단합니다.\n\n```kotlin\nlifecycleScope.launchWhenResumed {\n  println(\"로딩 중..\")\n  delay(3000)\n  println(\"작업 완료\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- ViewModel Scope: ViewModel의 수명에 바인딩됩니다. ViewModel이 해제되면이 범위 내의 코루틴도 취소됩니다.\n\n```js\nviewModelScope.launch {\n  println(\"로딩 중..\")\n  delay(3000)\n  println(\"작업이 완료되었습니다\")\n}\n```\n\n## 코루틴 빌더\n\n코루틴 빌더는 새로운 코루틴을 초기화하거나 생성하기 위한 함수입니다. 코루틴의 실행을 시작하고 제어하는 편리한 방법을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- `launch`: 새로운 coroutine을 동시에 시작합니다. 예를 들어, 현재 스레드를 차단하지 않고 시작됩니다. 해당 작업이 취소될 때 자동으로 취소되며 결과 작업이 취소될 때 결과를 반환하지 않습니다. `launch`의 반환 유형은 `Job`입니다. 따라서 해당 작업과 상호 작용하여 coroutine의 라이프사이클을 제어할 수 있습니다. `job.cancel()`을 호출하여 쉽게 취소할 수 있습니다. `launch`는 ViewModel에서 비-suspending 코드에서 suspending 코드로 연결을 생성하는 데 자주 사용됩니다.\n\n```js\nlaunch {\n    delay(1000L)\n    println(\"Hello World!\")\n}\n```\n\n- `runBlocking`: 새로운 coroutine을 실행하고 현재 스레드를 해당 완료까지 차단합니다. 다시 말해, 해당 coroutine에서 실행되는 스레드는 주어진 기간 동안 해당 괄호 내의 모든 코드 블록이 실행을 완료할 때까지 차단됩니다.\n\n```js\nfun main() = runBlocking { // this: CoroutineScope\n    doWorld()\n}\n\nsuspend fun doWorld() {\n    delay(1000L)\n    println(\"Hello Kotlin!\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- async: 컨테이너{launch} 함수처럼, 새로운 코루틴을 시작하는 데 사용되며, 차이점은 Job 대신 deferred를 반환한다는 것입니다. deferred는 결과를 나중에 전달할 것을 약속하는 비차단(future)인데, 결과 deferred가 취소되면 실행 중인 코루틴도 취소됩니다. async 빌더를 사용하면 반환된 값을 얻으려면 `await`를 호출하면 됩니다.\n\n```kotlin\nfun main() = runBlocking\u003cUnit\u003e {\n\n    val time = measureTimeMillis {\n        val one = async { doSomethingUsefulOne() }\n        val two = async { doSomethingUsefulTwo() }\n        println(\"The answer is ${one.await() + two.await()}\")\n    }\n    println(\"Completed in $time ms\")\n\n}\n```\n\n- delay: 특정 시간 동안 함수를 중단하고 그 후에 다시 시작하는 용도로 사용되는 중단 함수입니다. 백그라운드 스레드를 차단하지 않고 다른 코루틴들이 실행되고 백그라운드 스레드를 사용할 수 있도록 합니다.\n\n```kotlin\nlaunch {\n    delay(2000L)\n    println(\"World 2\")\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- withContext: 현재 코루틴 내에서 코루틴 컨텍스트를 전환하는 데 사용되는 지연 함수입니다. 현재 코루틴을 일시 중단하고 지정된 컨텍스트로 전환한 후 새 컨텍스트에서 실행을 계속합니다. 일반적으로 해당 함수를 사용하여 코루틴이 실행될 디스패처를 전환합니다. withContext를 사용하면 콜백을 도입하지 않고 코드가 어느 스레드에서 실행될지 제어할 수 있기 때문에 데이터베이스에서 읽기나 네트워크 요청과 같은 매우 작은 함수에 적용할 수 있습니다.\n\n```kotlin\nfun main() = runBlocking {\n    val data = withContext(Dispatchers.IO) {\n        fetchData()\n    }\n    println(\"Response = $data\")\n}\n\nsuspend fun fetchData(): String {\n    return \"Hello world!\"\n}\n```\n\n## 코루틴 컨텍스트\n\n코루틴 컨텍스트는 코루틴의 동작과 특성을 정의하는 요소들의 세트입니다. 디스패처, 작업, 예외 처리기 및 코루틴 이름과 같은 요소를 포함합니다. 이 컨텍스트는 코루틴이 어떻게 어디에서 실행될지 결정하는 데 사용됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n디스패처\n\n코루틴 디스패처는 코루틴이 실행될 스레드를 결정하는 역할을 합니다. 디스패처에는 4가지 유형이 있습니다:\n\n- 메인 디스패처(Main Dispatchers) — 메인 디스패처는 코루틴을 메인 스레드에서 실행합니다. 메인 디스패처는 대부분의 UI 작업을 수행합니다.\n- IO 디스패처(IO Dispatchers) — IO 디스패처는 IO 스레드에서 코루틴을 시작합니다. 이 디스패처는 필요할 때 생성되는 스레드 풀을 사용합니다. 파일 읽기 또는 쓰기, 데이터베이스 쿼리 수행, 네트워크 요청 등 실행 스레드를 차단할 수 있는 I/O 작업에 적합합니다.\n- 기본 디스패처(Default Dispatchers) — 다른 디스패처가 명시적으로 지정되지 않은 경우 사용되는 기본 디스패처입니다. 공유 백그라운드 스레드 풀을 활용합니다. CPU 자원이 필요한 계산 집약적인 코루틴에 적합한 선택지입니다.\n- 비제한 디스패처(Unconfined Dispatcher) — 코루틴이 어떤 스레드에서도 실행되도록 허용합니다. 각 resume마다 다른 스레드에서 실행될 수 있습니다. 특정 스레드에 한정된 CPU 사용이나 공유 데이터 업데이트가 필요 없는 코루틴에 적합합니다.\n\n```js\nfun main() = runBlocking {\n    launch { // 부모의 콘텍스트인 메인 runBlocking 코루틴\n        println(\"main runBlocking      : 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n    launch(Dispatchers.Unconfined) { // 제한 없음 -- 메인 스레드에서 작동\n        println(\"Unconfined            : 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n    launch(Dispatchers.Default) { // DefaultDispatcher에 디스패치됩니다\n        println(\"Default               : 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n    launch(newSingleThreadContext(\"MyOwnThread\")) { // 자체 새로운 스레드를 가져옵니다\n        println(\"newSingleThreadContext: 현재 스레드 ${Thread.currentThread().name}에서 작업 중\")\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코루틴을 실행하려면 Executor.asCoroutineDispatcher() 확장 기능을 사용하여 코루틴 디스패처로 변환하여 쓰레드 풀에서 실행할 수도 있습니다. 프라이빗 쓰레드 풀은 다음을 사용하여 생성할 수 있습니다:\n\n- newSingleThreadContext(): 내장된 yield 지원이 있는 전용 쓰레드를 사용하여 코루틴 실행 환경을 만듭니다. 원시 자원(스레드 자체)을 할당하는 믹서된 API로 조심스럽게 관리가 필요합니다.\n- newFixedThreadPoolContext: 고정 크기의 쓰레드 풀을 사용하여 코루틴 실행 환경을 설정하여, 코루틴의 병렬 실행을 가능하게 하면서 스레드 자원을 주의 깊게 관리합니다.\n\n코루틴 작업\n\n생성된 매 코루틴마다 Job 인스턴스가 반환되는데, 이를 통해 해당 코루틴을 고유하게 식별하고 라이프사이클을 관리할 수 있습니다. Job은 대기열에서의 코루틴을 가리키는 핸들 역할을 합니다. Job은 다음과 같은 상태를 가집니다: New, Active, Completing, Completed, Cancelling, Cancelled. 상태 자체에는 접근할 수 없지만, Job의 속성: isActive, isCancelled 및 isCompleted에 접근할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```kotlin\nval job = launch { // 새로운 코루틴을 시작하고 해당 작업에 대한 참조를 유지합니다\n    delay(1000L)\n    println(\"안녕, 세상아!\")\n}\njob.join() // 자식 코루틴이 완료될 때까지 기다립니다\nprintln(\"완료\")\n```\n\nSupervisorJob — 이것은 자식 코루틴에 대한 감독자 역할을 하는 Job의 구현입니다. 일반 Job과 유일한 차이점은 그 자식들이 서로 독립적으로 실패할 수 있다는 것입니다. 자식의 실패나 취소는 감독자 작업의 실패를 일으키거나 다른 자식에 영향을 주지 않으므로 감독자는 자식의 실패에 대한 고유 정책을 작성할 수 있습니다.\n\n```kotlin\nfun main() = runBlocking {\n    val supervisorJob = SupervisorJob()\n\n    val coroutine1 = launch(supervisorJob) {\n        println(\"코루틴 1\")\n        throw RuntimeException(\"코루틴 1에서 오류 발생\")\n    }\n\n    val coroutine2 = launch(supervisorJob) {\n        println(\"코루틴 2\")\n        delay(500)\n        println(\"코루틴 2 완료\")\n    }\n\n    coroutine1.join()\n    coroutine2.join()\n\n    println(\"부모 코루틴: ${supervisorJob.isActive}\") // 출력: 부모 코루틴: true\n}\n```\n\n## 코루틴 취소\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n코루틴에서 취소는 Job을 통해 관리됩니다(Job은 코루틴에 대한 핸들이며 수명주기가 있습니다). 우리는 코루틴을 Job의 .cancel() 함수를 호출하여 취소할 수 있습니다. 여러 개의 코루틴을 시작할 때, 전체 스코프 내에 생성된 모든 자식 코루틴을 취소하기 위해 의존할 수 있습니다.\n\n취소는 CancellationException을 throw하는 것 이상의 것이 아닙니다. 여기서의 중요한 차이점은 코루틴이 CancellationException을 throw하면 정상적으로 취소된 것으로 간주되며, 다른 예외는 실패로 간주됩니다. 코루틴 라이브러리에서 제공되는 일시정지 함수는 취소할 수 있지만, 코드를 작성할 때는 항상 취소와 협력하는 것을 고려해야 합니다.\n\n- 코드를 취소할 수 있게 만드는 한 가지 방법은 현재 Job의 상태를 명시적으로 확인하는 것입니다. CoroutineContext와 CoroutineScope에서 모두 isActive() 확장 함수를 사용할 수 있습니다.\n- 다른 일반적인 취소 확인 방법은 ensureActive()를 호출하는 것입니다. 이것은 Job, CoroutineContext 및 CoroutineScope에 사용할 수 있는 확장 함수입니다.\n\n취소에 대한 자세한 내용은 여기와 여기에서 찾을 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n친구들이 읽어주셔서 감사합니다! 코루틴에 대해 다뤄본 건 정말 많았지만, 유용한 정보였길 바랍니다. 댓글란에 의견을 남겨주세요.\n\n코딩 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png"},"coverImage":"/assets/img/2024-06-23-KotlinCoroutinesFundamentals_0.png","tag":["Tech"],"readingTime":13},{"title":"시스템 설계를 처음부터 배우기 레슨 1","description":"","date":"2024-06-23 23:17","slug":"2024-06-23-StartingfromScratchSystemDesignLesson1","content":"\n가장 중요한 것은 모든 시스템 디자인 질문에 대해 마음속에 일반적인 구조를 만들고 그 기본 구조를 토대로 스스로를 발전시키고 향상시켜야 한다는 것을 기억해야 합니다.\n\n다음 설계를 살펴보고 이를 향후 레슨의 기본으로 활용해 봅시다.\n\n너에게 너무나 압도적으로 보일지도 몰라요...\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n깊게 숨을 들이펴 보세요, 단계별로 차근차근 진행할 거에요. :)\n\n# BABY STEPS :)\n\n- 먼저 API-Gateway로 요청이 전달되어 시스템의 입구 역할을 합니다.\n- 그런 다음 로드 밸런서에 요청이 전달됩니다. 이는 한 대의 서버가 너무 많은 요청을 받지 않도록 관리하는 역할을 합니다. 요청은 다른 인스턴스로 분산되어 시스템이 올바르게 작동할 수 있도록 보장합니다.\n- 분산 캐시가 사용되어 지연 시간을 줄일 수 있습니다. 항상 백엔드로 호출할 필요는 없습니다.\n- 그리고 쿠버네티스, 도커 및 여러 백엔드 서비스 인스턴스를 사용하는 구조가 나옵니다. 간단히 말해 백엔드 서비스는 비즈니스 요구사항을 충족하며, 쿠버네티스는 모든 인스턴스가 켜져 있을 필요가 없는 경우 자동으로 확장을 관리합니다.\n- 그런 다음 캐시를 사용할 수 있습니다. (여기서 주의해야 할 점: 캐시 무효화, 캐시 제거 정책)\n- 구조적인 데이터는 RDBMS로 이동합니다.\n\n이곳에서 리더-팔로워 아키텍처가 따라지며 (리플리케이션 전략은 높은 읽기 요구량을 처리하고 리더가 다운되었을 때 데이터 손실을 줄이는 데 사용됩니다.)\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n7. 필요한 데이터는 비즈니스 로직이 요구사항을 처리하고 프로세스가 성공했을 때 서비스로 다시 전송됩니다.\n\n7a. 데이터는 또한 ELK, Kibana, Grafana로 전송되어 관측 메트릭 및 로그 추적이 이루어집니다.\n\n8. 9. 10.\n\n사용자는 요청이 완료되었음을 알림받아야 합니다. 이를 위해 알림 메시지가 알림 대기열로 전송되어 사용자가 오프라인 상태라도 메시지가 지속됩니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n예외:\n\n8`a-8`b\n\n연결 문제 또는 기술적 결함으로 요청이 성공적으로 처리되지 않은 경우, 해당 요청(또는 메시지)은 다시 서비스로 전송되어 재처리됩니다.\n\n5`a-5`b\n\n\u003c!-- ui-station 사각형 --\u003e\n\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n우리가 비구조화된 데이터를 저장해야 하는 사용 사례에서는 NoSQL 데이터베이스에 데이터를 저장하고 Kibana/Grafana/ELK로 데이터를 보내어 분석 목적이나 로그 추적에 활용합니다.\n\n감사합니다. 저희 사람들을 계속 성장해 주세요!\n","ogImage":{"url":"/assets/img/2024-06-23-StartingfromScratchSystemDesignLesson1_0.png"},"coverImage":"/assets/img/2024-06-23-StartingfromScratchSystemDesignLesson1_0.png","tag":["Tech"],"readingTime":3}],"page":"2","totalPageCount":110,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"2"},"buildId":"bb_yO9GbCvdfc_n71SfUf","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>