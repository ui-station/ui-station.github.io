<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ui-station</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://ui-station.github.io///posts/2" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ui-station" data-gatsby-head="true"/><meta property="og:title" content="ui-station" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://ui-station.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://ui-station.github.io///posts/2" data-gatsby-head="true"/><meta name="twitter:title" content="ui-station" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | ui-station" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-BHFR6GTH9P"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-BHFR6GTH9P');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-8ce515d2b46d0f43.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_buildManifest.js" defer=""></script><script src="/_next/static/GsgRekSb--BvxYwv9FPn6/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">UI STATION</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="TypeScript에서 Named Parameters 사용하는 방법" href="/post/2024-07-01-NamedParametersinTypeScript"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TypeScript에서 Named Parameters 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-NamedParametersinTypeScript_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TypeScript에서 Named Parameters 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">TypeScript에서 Named Parameters 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="코드 품질 향상 Sonar-Scanner와 danger 통합 방법 " href="/post/2024-07-01-EnhanceCodeQualitySonar-ScanneranddangerIntegrationDemystified"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="코드 품질 향상 Sonar-Scanner와 danger 통합 방법 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-EnhanceCodeQualitySonar-ScanneranddangerIntegrationDemystified_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="코드 품질 향상 Sonar-Scanner와 danger 통합 방법 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">코드 품질 향상 Sonar-Scanner와 danger 통합 방법 </strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Angular 17의 컴포넌트 스타일 정리 방법" href="/post/2024-07-01-MythicalAngularComponentstylescleanupinAngular17"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Angular 17의 컴포넌트 스타일 정리 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Angular 17의 컴포넌트 스타일 정리 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Angular 17의 컴포넌트 스타일 정리 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="불가능한 모퉁이 현실로 구현할 수 없는 건축 디자인 아이디어들" href="/post/2024-07-01-UnreachableCorner"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="불가능한 모퉁이 현실로 구현할 수 없는 건축 디자인 아이디어들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-UnreachableCorner_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="불가능한 모퉁이 현실로 구현할 수 없는 건축 디자인 아이디어들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">불가능한 모퉁이 현실로 구현할 수 없는 건축 디자인 아이디어들</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="React JS, NET Core, Docker를 사용해 제품 애플리케이션 구축 및 컨테이너화하는 방법" href="/post/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="React JS, NET Core, Docker를 사용해 제품 애플리케이션 구축 및 컨테이너화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="React JS, NET Core, Docker를 사용해 제품 애플리케이션 구축 및 컨테이너화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">React JS, NET Core, Docker를 사용해 제품 애플리케이션 구축 및 컨테이너화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">26<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Docker로 ReactJS 애플리케이션 컨테이너화하는 방법" href="/post/2024-07-01-ContainerizationofReactJSApplicationusingDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker로 ReactJS 애플리케이션 컨테이너화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker로 ReactJS 애플리케이션 컨테이너화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Docker로 ReactJS 애플리케이션 컨테이너화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법" href="/post/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년 React Native 마스터하기 전문가 통찰을 통해 기술 스택을 완벽하게 이해하는 종합 가이드" href="/post/2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년 React Native 마스터하기 전문가 통찰을 통해 기술 스택을 완벽하게 이해하는 종합 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년 React Native 마스터하기 전문가 통찰을 통해 기술 스택을 완벽하게 이해하는 종합 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년 React Native 마스터하기 전문가 통찰을 통해 기술 스택을 완벽하게 이해하는 종합 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="2024년에 수강할 수 있는 최고의 프론트엔드 마스터 강좌 TOP 5" href="/post/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="2024년에 수강할 수 있는 최고의 프론트엔드 마스터 강좌 TOP 5" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="2024년에 수강할 수 있는 최고의 프론트엔드 마스터 강좌 TOP 5" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">2024년에 수강할 수 있는 최고의 프론트엔드 마스터 강좌 TOP 5</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법" href="/post/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">UI STATION</span></div><strong class="PostList_title__loLkl">Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jul 1, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link posts_-active__YVJEi" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"TypeScript에서 Named Parameters 사용하는 방법","description":"","date":"2024-07-01 16:22","slug":"2024-07-01-NamedParametersinTypeScript","content":"\n\n## TypeScript에서 이름이 지정된 매개변수를 정의하는 최선의 방법은 무엇인가요?\n\n이름이 지정된 매개변수로도 알려져 있습니다. 이 글에서는 TypeScript에서 이름이 지정된 매개변수를 정의하는 좋은 방법에 대해 설명하겠습니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-NamedParametersinTypeScript_0.png\" /\u003e\n\n## 약간의 배경 정보\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n특정 기능에 대한 매개변수로 사용되는 객체를 만드는 것을 명명된 매개변수 또는 명명된 인수라고 합니다.\n\n일반적으로 매개변수는 함수 매개변수를 의미하고, 인수는 매개변수에 전달되는 값을 의미합니다. 그러나 저는 두 용어를 서로 바꿔 사용할 것입니다.\n\n명명된 인수는 C#, Kotlin, Swift 등 많은 언어의 기본 기능이지만 Javascript/Typescript에는 해당되지 않습니다. 이것은 오랜 시간 동안 제안되어 왔으며 babel에 플러그인이 있습니다.\n\nJavascript/Typescript에서 명명된 인수를 사용하는 방법은 객체를 정의하는 것입니다. 이것은 관행(회피책)입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이름이 지정된 매개변수 객체는 프로젝트에서 신경 써야 할 \"실제\" 유형 또는 인터페이스가 아닙니다. 그냥 함수의 매개변수에 존재하는 이름이 지정된 인수의 관습으로 살아 있습니다.\n\n제가 그렇게 말하는 이유는 이 객체를 이름이 지정된 매개변수로 생각하면 프로젝트에서의 위치가 더 명확해지기 때문입니다.\n\n여기 C#에서의 이름이 지정된 인수 (이는 TS에서 영감을 받은 언어입니다):\n\n```js\nvoid PrintOrderDetails(\n    string sellerName,\n    int orderNum,\n    string productName\n) {\n// ...\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그리고 이를 어떻게 호출할 수 있는지:\n\n```js\nPrintOrderDetails(\n    orderNum: 31,\n    productName: \"Red Mug\",\n    sellerName: \"Gift Shop\"\n);\n```\n\n이것이 TypeScript에서 지원되면 어떻게 작성할지에 대한 예시입니다.\n\n인자의 순서가 중요하지 않다는 점을 주목해주세요. 이것이 명명된 인자의 강점입니다. 인자를 어떤 순서로든 전달할 수 있고 코드를 읽기 쉽게 만들어줍니다 (어떤 값이 어디로 전달되는지 알 수 있음).\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# TypeScript에서의 최상의 실천 방법은 무엇인가요?\n\n배경 컨텍스트를 고려하면, 다음이 최상의 실천 방법입니다:\n\n```js\nfunction printOrderDetails(options: {\n    sellerName: string,\n    orderNum: number,\n    productName: string\n}): void {\n// ...\n}\n\nprintOrderDetails({\n    orderNum: 31,\n    productName: \"Red Mug\",\n    sellerName: \"Gift Shop\"\n});\n```\n\n이것은 네이티브 네임드 인수와 매우 유사합니다. 이 객체에 대해 타입이나 인터페이스를 만들지 않습니다. 왜냐하면 중요한 인터페이스나 타입이 아니기 때문입니다. 이것은 그냥 네임드 인수입니다. 함수를 호출할 때 다른 목적에 사용되지 않으며 우리가 신경 쓰지 않습니다. 즉, 이것은 필요하지 않으며 오히려 번거로울 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst options = {\n    orderNum: 31,\n    productName: \"Red Mug\",\n    sellerName: \"Gift Shop\"\n};\n\nPrintOrderDetails(options);\r\n```\n\n우리는 FunctionOptions를 선언하지 않습니다. 왜냐하면 해당 내용을 내보내지 않거나 정의하지 않기 때문입니다. 우리는 신경 쓰지 않습니다.\n\n## 함수 시그니처에서 파괴 할당을 어떻게 생각하시나요?\n\n이것은 별개의 주제입니다. 그리고 실천법은 팀마다 다를 수 있습니다. 예를 들어, React 프로젝트에서는 함수 시그니처에서 파괴 할당하는 것이 일반적이며, 내가 본 대부분의 프로젝트에서 이것이 표준이라고 볼 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 제안은 팀에 가장 적합한 것을 확인하는 것이 좋습니다. 무엇이 더 읽기 쉬운지 확인해보세요. 저는 함수 시그니처를 해체하지 않는 것을 선호하지만, 리액트 프로젝트를 제외하고는 다른 팀원들이 다른 견해를 가질 수도 있습니다.\n\n그래서 합의와 일관성이 중요합니다.\n\n```js\nexport function promiseExperience(options: {\n    experienceName,\n    experienceConfig,\n    experienceDiv,\n    siteId,\n    traversal\n}): Promise\u003cBuildComponent\u003e {\n    const {\n        experienceName,\n        experienceConfig,\n        experienceDiv,\n        siteId,\n        traversal\n    } = options;\n// ...\n}\n```\n\n합의는 객체에 대한 타입을 만드는 것을 의미할 수도 있습니다:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\ntype PromiseExperienceParams = {\n    experienceName: string;\n    experienceConfig: TodoAny;\n    experienceDiv: HTMLDivElement;\n    siteId: string;\n    traversal: Traversal;\n};\n\nexport function promiseExperience(options: PromiseExperienceParams): Promise\u003cBuildComponent\u003e {\n    const {\n        experienceName,\n        experienceConfig,\n        experienceDiv,\n        siteId,\n        traversal\n    } = options;\n// ...\n}\n```\n\n하지만 타입을 생성할 때는 내보내지 말고, 함수의 인자로 사용하고 함수의 매개변수로 사용하지 마세요.\n\n# 일관성\n\n모든 프로젝트에서 일관성이 중요합니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n일관성이 코드를 읽기 쉽게 만듭니다. 이것이 표준이 됩니다. 프로젝트가 함수 시그니처로 분해된다면, 그것을 따르지 않으면 불일치할 것이고, 그 반대도 마찬가지입니다. 표준적인 방법에서 벗어나는 것은 피하고 싶지 않나요?\n\n이것이 여러분과 팀이 성공하는 데 도움이 되기를 바랍니다.","ogImage":{"url":"/assets/img/2024-07-01-NamedParametersinTypeScript_0.png"},"coverImage":"/assets/img/2024-07-01-NamedParametersinTypeScript_0.png","tag":["Tech"],"readingTime":6},{"title":"코드 품질 향상 Sonar-Scanner와 danger 통합 방법 ","description":"","date":"2024-07-01 16:21","slug":"2024-07-01-EnhanceCodeQualitySonar-ScanneranddangerIntegrationDemystified","content":"\n\n이전 게시물 중 하나에서는 npm 피어 종속성 충돌을 해결하는 방법에 대해 이야기했습니다 [1]. 이번에는 코드 문제에 대한 자세한 보고서를 생성하는 방법에 대해 이야기하려고 합니다. 특히 SonarQube를 통합하고 자동화된 코드 리뷰를 위해 danger를 활용하는 방법에 대해 논의하겠습니다.\n\n## 1. Sonar-Scanner\n\nSonarQube Scanner (sonar-scanner)는 여러 프로그래밍 언어에 걸쳐 코드 품질 및 보안을 분석하는 도구입니다. Jenkins와 Maven과 같은 CI/CD 도구와 원활하게 통합되어 코드 문제에 대한 자세한 보고서를 제공하고 유지 관리성을 향상시키며 최상의 코딩 관행을 준수하는 것을 보장합니다.\n\n다음은 sonar-scanner를 사용하는 예시입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nsonar-scanner\n      -Dsonar.projectKey=$sonarQubeProjectKey\n      -Dsonar.login=$sonarQubeToken\n      -Dsonar.sourceEncoding=UTF-8\n      -Dsonar.sources=$npmSonarQubeSources\n      -Dsonar.tests=$npmSonarQubeTests\n      -Dsonar.exclusions=$npmSonarQubeExclusions\n      -Dsonar.test.inclusions=$npmSonarQubeTestInclusions\n      -Dsonar.typescript.lcov.reportPaths=$npmSonarQubeLcovReportPath\n      -Dcom.itestra.cloneview.enabled=false\n```\n\n![Enhance Code Quality](/assets/img/2024-07-01-EnhanceCodeQualitySonar-ScanneranddangerIntegrationDemystified_0.png)\n\n## 1.1 Nx 프로젝트 설정하기\n\nNx를 사용할 때는 다음 값들로 플레이스홀더를 채울 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// configuration with nx\nnpmSonarQubeSources = 'apps,libs'\nnpmSonarQubeTests = 'apps,libs'\nnpmSonarQubeExclusions = '**/node_modules/**,**/*-api/**,**/test-setup.ts'\nnpmSonarQubeTestInclusions = '**/*.spec.ts'\nnpmSonarQubeLcovReportPath = 'coverage/lcov.info'\n```\n\n여러 라이브러리 및/또는 애플리케이션이 구성되어 있으므로 커버리지 보고서를 단일 파일로 병합해야 합니다. 이 집계된 결과는 SonarQube로 전송할 수 있습니다.\n\n다음 코드[2]를 사용하여 이를 달성할 수 있습니다. 그러나 최신 glob 버전과 호환되기 위해 일부 수정이 필요합니다. 다음 코드 조각은 이를 어떻게 수정해야 하는지 보여줍니다.\n\n```js\nconst { glob } = require('glob');\nconst fs = require('fs');\nconst path = require('path');\n\nconst getLcovFiles = function (src) {\n    return new Promise((resolve) =\u003e {\n        glob(`${src}/**/lcov.info`)\n            .then((result) =\u003e resolve(result))\n            .catch(() =\u003e resolve([]));\n    });\n};\n\n(async function () {\n    const files = await getLcovFiles('coverage');\n    const mergedReport = files.reduce((mergedReport, currFile) =\u003e (mergedReport += fs.readFileSync(currFile)), '');\n\n    await fs.writeFile(path.resolve('./coverage/lcov.info'), mergedReport, (err) =\u003e {\n        if (err) throw err;\n        console.log('파일이 저장되었습니다!');\n    });\n})();\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 스크립트를 사용하려면 해야 할 일은 glob를 의존성으로 추가하는 것 뿐입니다.\n\n```js\nnpm install glob --save\n```\n\n## 1.2. 기타 유형의 프로젝트 설정\n\nNx 없이도 다음 값을 사용하여 자리 표시자를 채울 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\n// nxnpmSonarQubeSources = 'src'이라는 설정 없이\r\nnpmSonarQubeTests = 'src'\r\nnpmSonarQubeExclusions = '**/node_modules/**,**/*-api/**'\r\nnpmSonarQubeTestInclusions = '**/*.spec.ts'\r\nnpmSonarQubeLcovReportPath = 'coverage/lcov.info'\r\n```\r\n\r\n## 1.3 Jest 설정\r\n\r\njest를 사용할 때 (karma 대신) jest와 함께 nx를 사용하면, coverageReports 옵션을 lcov로 설정하여 쉽게 커버리지 보고서를 생성할 수 있습니다.\r\n\r\n```js\r\n// package.json 내의 스크립트\r\n\r\n\"coverage:merge\": \"node merge-coverage.js\",\r\n\"test\": \"nx run-many --all --target=test --code-coverage --coverageReporters=lcov --parallel=2 --runInBand \u0026\u0026 npm run coverage:merge\",\r\n\"test:ci\": \"npm run test\"\r\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 사용할 수 있는 jest.config의 예시입니다.\n\n```js\nexport default {\n    displayName: 'common',\n    preset: '../../../jest.preset.js',\n    setupFilesAfterEnv: ['\u003crootDir\u003e/src/test-setup.ts'],\n    coverageDirectory: '../../../coverage/libs/common',\n    transform: {\n        '^.+\\\\.(ts|mjs|js|html)$': [\n            'jest-preset-angular',\n            {\n                tsconfig: '\u003crootDir\u003e/tsconfig.spec.json',\n                stringifyContentPathRegex: '\\\\.(html|svg)$',\n            },\n        ],\n    },\n    transformIgnorePatterns: ['node_modules/(?!.*\\\\.mjs$|@datorama/akita)'],\n    snapshotSerializers: [\n        'jest-preset-angular/build/serializers/no-ng-attributes',\n        'jest-preset-angular/build/serializers/ng-snapshot',\n        'jest-preset-angular/build/serializers/html-comment',\n    ],\n    moduleNameMapper: {\n        '^lodash-es$': 'lodash',\n    },\n};\n```\n\n## 1.4 Karma 설정\n\n그러나 jest 대신 karma를 사용할 경우, 각 karma.conf 파일에 lcovonly를 리포터로 포함해야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nmodule.exports = () =\u003e {\n    return {\n        basePath: '',\n        frameworks: ['jasmine', '@angular-devkit/build-angular'],\n        plugins: [\n            require('karma-jasmine'),\n            require('karma-chrome-launcher'),\n            require('karma-jasmine-html-reporter'),\n            require('karma-coverage-istanbul-reporter'),\n            require('@angular-devkit/build-angular/plugins/karma'),\n        ],\n        client: {\n            clearContext: false, // 브라우저에서 Jasmine Spec Runner 출력을 보이게 유지\n        },\n        jasmineHtmlReporter: {\n            suppressAll: true, // 중복된 추적을 제거\n        },\n        coverageIstanbulReporter: {\n            dir: require('path').join(__dirname, '../../../coverage/common″'),\n            reports: ['html', 'lcovonly'],\n            fixWebpackSourcePaths: true,\n        },\n        reporters: ['progress', 'kjhtml', 'coverage-istanbul'],\n        ...\n}\n```\n\n그리고 코드 커버리지 옵션이 package.json에 설정되어야 합니다.\n\n```js\n\"test\": \"ng test\",\n\"test:ci\": \"npm run test -- --watch false --code-coverage=true\",\n```\n\n## 2. Danger\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nTypeScript 프로젝트에서는 danger 의존성을 사용하여 eslint 규칙을 확인하여 코드 리뷰를 자동화합니다. 이는 pull request 에서 linting 문제를 자동으로 식별하여 코드 품질을 유지하는 데 도움이 됩니다. danger 를 통합하려면 Dangerfile 을 설정하여 규칙과 검사를 정의하고 일관된 코딩 표준을 유지하며 리뷰 프로세스를 간소화해야 합니다.\n\n다음은 Dangerfile 을 구성할 수 있는 예시입니다.\n\n```js\nimport {danger, fail, schedule, warn} from 'danger';\nimport {istanbulCoverage} from 'danger-plugin-istanbul-coverage';\nimport {ESLint} from 'eslint';\n\n// 코드 커버리지 확인\nschedule(istanbulCoverage({\n    entrySortMethod: 'least-coverage',\n    numberOfEntries: 30,\n    coveragePath: {path: './coverage/lcov.info', type: 'lcov'},\n    reportFileSet: 'createdOrModified',\n    reportMode: 'warn',\n    threshold: {\n        statements: 80,\n        branches: 80,\n        functions: 80,\n        lines: 80\n    }\n}));\n\nconst enum EslintSeverity {\n    WARNING = 1,\n    ERROR = 2\n}\n\n// ESLint 규칙 검사\nschedule(async () =\u003e {\n    try {\n        const filesToLint = danger.git.created_files.concat(danger.git.modified_files);\n        const eslint = new ESLint({});\n\n        const results = await eslint.lintFiles(filesToLint);\n\n        results.forEach(({filePath, messages}) =\u003e {\n            messages.forEach(message =\u003e {\n                if (message.fatal) {\n                    warn(`Fatal error linting ${filePath} with eslint.`);\n                    return;\n                }\n\n                // 무시된 파일 건너뛰기\n                if (message.severity === EslintSeverity.WARNING \u0026\u0026 (message.message || '').startsWith('File ignored')) {\n                    return;\n                }\n\n                const fn = reporterFor(message.severity);\n\n                fn(`${filePath} line ${message.line} – ${message.message} (${message.ruleId})`);\n            });\n        });\n    } catch (error) {\n        console.error(error);\n    }\n});\n\nfunction reporterFor(severity: number): (message: string) =\u003e void {\n    switch (severity) {\n        case EslintSeverity.WARNING:\n            return warn;\n        case EslintSeverity.ERROR:\n            return fail;\n        default:\n            return () =\u003e { /* 아무것도 수행하지 않음 */\n            };\n    }\n}\n```\n\ndanger 및 코드 커버리지 도구를 사용하려면 danger 및 danger-plugin-istanbul-coverage가 모두 의존성으로 추가되어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// 일부 구버전\n\"danger\": \"10.5.3\",\n\"danger-plugin-istanbul-coverage\": \"^1.6.2\",\n```\n\n그리고 다음 스크립트를 package.json에 추가할 수 있습니다.\n\n```js\n\"danger:ci\": \"danger ci\",\n\"danger:local\": \"danger local\"\n```\n\nGitlab과 함께 danger를 통합하려면 다음 스크립트를 CI/CD 파이프라인에 사용할 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```bash\nexport DANGER_GITLAB_HOST=${dangerGitlabHost}\nexport DANGER_GITLAB_API_BASE_URL=${dangerGitlabApiBaseUrl}\n                        \ngit branch temp_${BRANCH_NAME}\ngit checkout -b ${dangerBaseBranch}\ngit checkout temp_${BRANCH_NAME}\nnpm run danger:local -- --base ${dangerBaseBranch}\n\nexport NODE_TLS_REJECT_UNAUTHORIZED=0\nnpm run danger:ci\nexport NODE_TLS_REJECT_UNAUTHORIZED=1\n```\n\n## 마무리\n\n저는 SonarScanner를 Nx 및 다양한 유형의 프로젝트에 구성하는 방법과 Jest와 Karma를 사용하여 테스팅하는 방법의 차이점을 강조했습니다. 각 도구의 구체적인 구성 및 모범 사례를 예를 통해 설명하여 개발자들이 테스트 및 코드 품질 전략에 대해 정보를 얻고 결정하는 데 도움이 되기를 바라며 이 비교를 제공했습니다.\n\n게다가, danger의 사용법을 보여주고 이를 CI/CD 파이프라인에 통합하는 방법을 설명했습니다. danger는 eslint 규칙을 강제로 적용하여 코드 리뷰를 자동화하고 일관된 코딩 표준을 유지하며 리뷰 프로세스를 간소화하기 위해 PR에서 이슈를 플래그 처리함으로써 개발자들을 도와줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 링크\n\n[1] \u003chttps://medium.com/@robert.maiersilldorff/resolving-npm-peer-dependency-conflicts-70d67f4ca7dc\u003e  \n\n[2] \u003chttps://yonatankra.com/how-to-create-a-workspace-coverage-report-in-nrwl-nx-monorepo/\u003e  ","ogImage":{"url":"/assets/img/2024-07-01-EnhanceCodeQualitySonar-ScanneranddangerIntegrationDemystified_0.png"},"coverImage":"/assets/img/2024-07-01-EnhanceCodeQualitySonar-ScanneranddangerIntegrationDemystified_0.png","tag":["Tech"],"readingTime":11},{"title":"Angular 17의 컴포넌트 스타일 정리 방법","description":"","date":"2024-07-01 16:20","slug":"2024-07-01-MythicalAngularComponentstylescleanupinAngular17","content":"\n\n안녕하세요!\n\n최신 릴리스 노트에 언급되지 않은 흥미로운 동작을 발견했습니다. 이 기사에서는 이것이 무엇인지 보여드리고, 왜 그것이 꽤 흥미로운 변화라고 생각하는지 알려드리겠습니다.\n\n# 스타일 정리 문제\n\nAngular가 동적으로 생성된 구성 요소를 제거한 후에도 스타일을 제거하지 않는 문제를 발견했습니다. 즉, 동적 구성 요소를 생성하면 (심지어 DOM에 연결할 필요도 없이), Angular가 스타일을 추가한 후 구성 요소가 제거될 때 스타일을 제거하지 않는다는 것이죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n검사하고 테스트하는 것은 매우 쉽습니다.\n\n# 테스트\n\n항상 모든 코드는 내 GitHub에서 제공됩니다. experiment-styles-cleanup 저장소를 찾아보세요.\n\n저는 응용 프로그램에 스타일을 추가하는 것 외에 아무 것도 하지 않는 간단한 구성 요소로 테스트를 시작합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\r\nimport {Component, ViewEncapsulation} from '@angular/core';\n\n@Component({\n  selector: 'app-dynamic',\n  template: '',\n  encapsulation: ViewEncapsulation.None,\n  styles: [`\n    .test {\n      background: red;\n      color: white;\n      border: 4px dashed black;\n      font-weight: bold;\n    }\n  `]\n})\nexport class DynamicComponent {\n}\r\n```\n\n여기서 볼 수 있듯이, 꽤 간단합니다. 템플릿도 로직도 없고, 스타일만 있습니다. 중요한 점은 ViewEncapsulation.None으로 캡슐화를 설정했기 때문에 이 스타일을 컴포넌트 외부에 적용할 수 있다는 것입니다.\n\n다음으로, 루트 AppComponent를 수정해보겠습니다.\n\n```js\r\nimport {Component, ComponentFactoryResolver, inject, Injector, OnDestroy} from '@angular/core';\nimport {DynamicComponent} from \"./dynamic.component\";\n\n@Component({\n  selector: 'app-root',\n  template: `\n    \u003cdiv class=\"test\"\u003e\n      이 상자가 빨간색일 때 스타일이 적용됩니다\n    \u003c/div\u003e\n\n    \u003cbutton (click)=\"createComponent()\"\u003e눌러보세요!\u003c/button\u003e\n  `\n})\nexport class AppComponent {\n  private readonly componentFactoryResolver = inject(ComponentFactoryResolver);\n  private readonly injector = inject(Injector);\n\n  createComponent(): void {\n    const factory = this.componentFactoryResolver.resolveComponentFactory(DynamicComponent);\n    const componentRef = factory.create(this.injector);\n\n    setTimeout(() =\u003e componentRef.destroy(), 5000);\n  }\n}\r\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nAppComponent에서 두 가지가 있습니다.\n\n첫 번째는 test 클래스가 있는 div입니다. Angular이 DynamicComponent에서 스타일을 추가할 때 스타일이 적용됩니다. 그래서 캡슐화를 ViewEncapsulation.None으로 설정했습니다.\n\n두 번째로는 버튼이 있습니다. 클릭하면 ComponentFactoryResolver를 사용하여 동적으로 DynamicComponent를 생성한 후 5초 후에 제거합니다. setTimeout에 메모리 누수가 있음을 알고 있지만 이것은 테스트일 뿐이니 괜찮아요?\n\n전체 테스트는 간단합니다. 버튼을 클릭하면 div에 스타일이 적용되어야 합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![한국어](/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png)\n\n5초간 기다리고, 두 가지 가능한 종료가 있습니다:\n\n- div에 스타일이 있는 경우 - 해당 컴포넌트의 스타일이 제거되지 않았음을 의미합니다\n- div에 스타일이 없는 경우 - Angular가 컴포넌트 제거 후 정리를 수행 중임을 의미합니다\n\n# Angular 15 \u0026 16\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아마도 예상했겠지만, Angular 15와 16에서는 컴포넌트와 함께 스타일이 제거되지 않습니다. experiment-styles-cleanup 저장소의 코드를 사용하여 직접 해볼 수 있어요. 주요 브랜치와 v16 브랜치를 사용해 보세요.\n\n![이미지](/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_1.png)\n\n참고: 시간이 부족하다면 권장합니다. GitHub Pages를 통해 배포한 코드를 확인할 수 있어요. 다음은 링크입니다:\n\n- [v15 링크](galczo5.github.io/experiment-styles-cleanup/v15)\n- [v16 링크](galczo5.github.io/experiment-styles-cleanup/v16)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 앵귤러 17\n\n앵귤러 17로 업그레이드한 후에 동작이 변경되었습니다. 이제 스타일은 컴포넌트와 함께 제거됩니다.\n\n내 저장소의 v17 브랜치를 확인하거나 galczo5.github.io/experiment-styles-cleanup/v17 애플리케이션을 사용해보세요.\n\n![이미지](/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# Non-dynamic 컴포넌트와의 작업 방식은 어떤가요?\n\n가끔 이러한 경우는 특이한 경우라고 생각할 수 있고, 우리가 많은 동적 컴포넌트를 만들지 않기 때문에 중요하지 않을 수도 있어요.\n\n일반 ngIf 문장으로 어떻게 작동하는지 확인해봅시다.\n\n이를 확인하려면 AppComponent의 코드에 필요한 변경 사항을 적용해야 했어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```javascript\nimport {Component, ComponentFactoryResolver, inject, Injector, OnDestroy} from '@angular/core';\nimport {DynamicComponent} from \"./dynamic.component\";\n\n@Component({\n  selector: 'app-root',\n  template: `\n    \u003cdiv class=\"test\"\u003e\n      이 상자가 빨간색이 될 때 적용되는 스타일\n    \u003c/div\u003e\n\n    \u003capp-dynamic *ngIf=\"visible\"/\u003e\n\n    \u003cbutton (click)=\"createComponent()\"\u003e클릭!\u003c/button\u003e\n  `\n})\nexport class AppComponent {\n  visible = false;\n\n  createComponent(): void {\n    this.visible = true;\n    setTimeout(() =\u003e this.visible = false, 5000);\n  }\n}\n```\n\n결과는 예상대로입니다.\n\nAngular 15 및 16 — 스타일이 제거되지 않음\n\n- 브랜치 v15-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v15-ngIf/\n- 브랜치 v16-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v16-ngIf/ \n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 다음과 같이 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n\nAngular 17 — 컴포넌트가 파괴된 후에 스타일이 제거됩니다\n\n- Branch 17-ngIf 및 galczo5.github.io/experiment-styles-cleanup/v17-ngIf/\n\n그래서, 동적으로 생성된 컴포넌트와 정확히 똑같이 동작합니다. 추가로 제거되지 않은 스타일이 브라우저에 얼마나 무겁게 작용하는지는 확신할 수 없지만, 스타일이 적을수록 처리하기 쉬울 것으로 예상됩니다. 아마 다음에는 측정해 볼 것입니다.\n\n# 캡슐화된 스타일에 대해 어떤가요?\n\n\n도움이 되었기를 바랍니다. 추가 설명이 필요하시면 언제든지 물어보세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n내 모든 테스트에서는 ViewEncapsulation.None을 사용하여 어떻게 작동하는지 시각적으로 보여주었어. 기본으로 에뮬레이션된 캡슐화로 작동하는 지 확인하기 위해 컴포넌트 제거 후 DOM을 확인하기 위해 개발 도구를 사용했어. 문서의 `head` 부분에서 무슨 일이 일어나고 있는지 관찰해봐.\n\n나에게 결과는 다음과 같았어:\n\n- Angular 15 \u0026 16 — 스타일이 제거되지 않아\n- Angular 17 — 스타일이 제거되어\n\n기본 캡슐화에서도 동일하게 작동해.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 요약\n\n솔직히 말해서, 컴포넌트를 파괴할 때 Angular가 기본적으로 스타일을 제거하지 않는다는 사실을 깨달을 때 약간 놀랐습니다. 몇 달 전에 물었더라면 Angular가 스타일을 제거한다고 베팅했을 것입니다.\n\n제 생각으로는 Angular 17에서 도입된 변경 사항이 모든 개발자에게 더 직관적일 것으로 확신합니다.\n\n요약하면, 제 테스트에 따르면 Angular 17 이전에 동적 컴포넌트든 ngIf를 사용하여 조건적으로 추가된 컴포넌트든 모든 컴포넌트가 파괴된 후에 추가된 모든 스타일이 제거되지 않았습니다. Angular 17은 이 동작을 변경하여 이제 컴포넌트 이후 불필요한 스타일이 정리됩니다.","ogImage":{"url":"/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png"},"coverImage":"/assets/img/2024-07-01-MythicalAngularComponentstylescleanupinAngular17_0.png","tag":["Tech"],"readingTime":8},{"title":"불가능한 모퉁이 현실로 구현할 수 없는 건축 디자인 아이디어들","description":"","date":"2024-07-01 16:19","slug":"2024-07-01-UnreachableCorner","content":"\n\n\n![이미지](/assets/img/2024-07-01-UnreachableCorner_0.png)\n\n어느 날 아침, 그 코너의 수업실로 걸어가지 않게 되었어요.\n\n아마도 만다의 인스탁스 카메라는 또 다른 사람의 얼굴과 독특한 포즈를 찍고 있을 거에요.\n\n그리고 저는 Ed Sheeran의 \"Castle On The Hill\"을 들으며 눈을 크게 떴어요.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n해당 복도 끝은 더 이상 평소와 같이 시끄럽지 않을 거에요. 급식소를 따라 외래 이름들이 더 이상 우리가 방문했을 때와 같지 않을 지도 몰라요. 인도미 토리 카라를 맛보면서 대기 목록에 있는 공포 영화들을 기다리는 것도 다를 거에요.\n\n마침내 그 책상들은 Le Minerale 병들로부터 깔끔해졌는데, 누가 소유주인지 잊고 버린 것이 안 보이더군요.\n\nOontz Manda 스피커는 더 이상 \"Take A Chance With Me\" 노래를 함께 노래할 수 없게 재생하지 않을 거에요.\n\nHiroko의 아이패드 게임을 더 많이 할지도 모르고, 누가 자주 빌릴지 줄어들지도 모르겠지요. 우리는 아니겠죠?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n알야가 우리 테이블을 더 이상 방문하지 않고 교과서를 고의로 떠났기 때문에 그녀가 투정을 해도 하지 않습니다.\n\n그런 다음 누구에게 톰을 펼치면 안 될까요? 당연히 네이샤에게인데, 그녀만이 톰을 울릴 수 있거든요.\n\n모든 것은 각자의 길을 가고 있어요. 아마 이 글만큼 시끄럽지 않을 거예요. 이렇게 과장되지 않을 거예요.\n\n오. 그 모든 것은 이미 운명에 따르는 거예요. 그렇게 하는 게 최선이죠. 그리고 다시 만나면 각자의 최고 버전으로 만나요. 평소처럼 줄 서서 사진을 찍고 각자의 알마마터 재킷을 입고 머리를 숙여 포즈를 취하죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n희망하는 바로, 당신들의 라면에 들어간 계란은 항상 반숙하길 바래, 사랑하는 사람들아!","ogImage":{"url":"/assets/img/2024-07-01-UnreachableCorner_0.png"},"coverImage":"/assets/img/2024-07-01-UnreachableCorner_0.png","tag":["Tech"],"readingTime":2},{"title":"React JS, NET Core, Docker를 사용해 제품 애플리케이션 구축 및 컨테이너화하는 방법","description":"","date":"2024-07-01 16:17","slug":"2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker","content":"\n\n\n![이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_0.png)\n\n# 소개\n\n본 글에서는 .NET Core Web API를 사용하여 샘플 제품 애플리케이션의 백엔드를 만들고 React JS를 사용하여 웹 폼을 생성하는 방법을 살펴볼 것입니다. 또한 도커를 활용해 동일한 애플리케이션을 컨테이너화할 것입니다.\n\n# 안내\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 샘플 제품 애플리케이션: 백엔드 (.NET Core Web API)\r\n- 샘플 제품 애플리케이션: 프론트엔드 (React JS)\r\n- 애플리케이션을 위한 Docker 파일\r\n- 애플리케이션을 컨테이너화하기\r\n\r\n## 필수 사항\r\n\r\n- Visual Studio 2022\r\n- Docker Desktop\r\n- NPM\r\n- .NET Core SDK\r\n- React JS\r\n\r\n# 샘플 제품 애플리케이션: 백엔드 (.NET Core Web API)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n1. 새로운 제품 관리 .NET Core 웹 API를 생성해주세요.\n\n2. 데이터베이스 마이그레이션 및 SQL Server와의 연결을 위해 사용한 다음 NuGet 패키지를 설치해주세요.\n\n[이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_1.png)\n\n3. 엔티티 폴더 안에 제품 클래스를 추가해주세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n```js\nnamespace ProductManagementAPI.Entities\n{\n    public class Product\n    {\n        public int Id { get; set; }\n        public string Name { get; set; }\n        public decimal Price { get; set; }\n    }\n}\n```\n\nStep 4. Create an AppDbContext class inside the data folder with a SQL Server connection and a DB set property.\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Data\n{\n    public class AppDbContext : DbContext\n    {\n        public DbSet\u003cProduct\u003e Products { get; set; }\n\n        protected readonly IConfiguration Configuration;\n\n        public AppDbContext(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n        protected override void OnConfiguring(DbContextOptionsBuilder options)\n        {\n            options.UseSqlServer(Configuration.GetConnectionString(\"DefaultConnection\"));\n            options.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);\n        }\n    }\n}\n```\n\nStep 5. Add a product repository inside the repositories folder.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nIProductRepository\n\n```js\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public interface IProductRepository\n    {\n        void AddProduct(Product product);\n        void DeleteProduct(int id);\n        List\u003cProduct\u003e GetAllProducts();\n        Product GetProductById(int id);\n        void UpdateProduct(Product product);\n    }\n}\n```\n\nProductRepository\n\n```js\nusing Microsoft.EntityFrameworkCore;\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Entities;\n\nnamespace ProductManagementAPI.Repositories\n{\n    public class ProductRepository : IProductRepository\n    {\n        private readonly AppDbContext _context;\n\n        public ProductRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public List\u003cProduct\u003e GetAllProducts()\n        {\n            return _context.Products.ToList();\n        }\n\n        public Product GetProductById(int id)\n        {\n            return _context.Products.FirstOrDefault(p =\u003e p.Id == id);\n        }\n\n        public void AddProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n\n            _context.Products.Add(product);\n            _context.SaveChanges();\n        }\n\n        public void UpdateProduct(Product product)\n        {\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n\n            _context.Entry(product).State = EntityState.Modified;\n            _context.SaveChanges();\n        }\n\n        public void DeleteProduct(int id)\n        {\n            var product = _context.Products.Find(id);\n            if (product == null)\n            {\n                throw new ArgumentNullException(nameof(product));\n            }\n\n            _context.Products.Remove(product);\n            _context.SaveChanges();\n        }\n    }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n6단계. 다양한 작업을 수행하는 데 사용되는 다른 액션 메서드를 사용하여 새 제품 컨트롤러를 생성합니다. 이후 같은 것을 호출하는 프런트엔드 애플리케이션을 사용하여 여러 작업을 수행합니다.\n\n```js\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing ProductManagementAPI.Entities;\nusing ProductManagementAPI.Repositories;\n\nnamespace ProductManagementAPI.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class ProductController : ControllerBase\n    {\n        private readonly IProductRepository _productRepository;\n\n        public ProductController(IProductRepository productRepository)\n        {\n            _productRepository = productRepository;\n        }\n\n        [HttpGet]\n        public IActionResult GetAllProducts()\n        {\n            var products = _productRepository.GetAllProducts();\n            return Ok(products);\n        }\n\n        [HttpGet(\"{id}\")]\n        public IActionResult GetProductById(int id)\n        {\n            var product = _productRepository.GetProductById(id);\n            if (product == null)\n            {\n                return NotFound();\n            }\n            return Ok(product);\n        }\n\n        [HttpPost]\n        public IActionResult AddProduct([FromBody] Product product)\n        {\n            if (product == null)\n            {\n                return BadRequest();\n            }\n\n            _productRepository.AddProduct(product);\n            return CreatedAtAction(nameof(GetProductById), new { id = product.Id }, product);\n        }\n\n        [HttpPut(\"{id}\")]\n        public IActionResult UpdateProduct(int id, [FromBody] Product product)\n        {\n            if (product == null || id != product.Id)\n            {\n                return BadRequest();\n            }\n\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n\n            _productRepository.UpdateProduct(product);\n            return NoContent();\n        }\n\n        [HttpDelete(\"{id}\")]\n        public IActionResult DeleteProduct(int id)\n        {\n            var existingProduct = _productRepository.GetProductById(id);\n            if (existingProduct == null)\n            {\n                return NotFound();\n            }\n\n            _productRepository.DeleteProduct(id);\n            return NoContent();\n        }\n    }\n}\n```\n\n7단계. 앱 설정 파일을 열고 데이터베이스 연결 문자열을 추가합니다.\n\n```js\n{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\",\n  \"ConnectionStrings\": {\n    \"DefaultConnection\": \"Data Source=DESKTOP-8RL8JOG;Initial Catalog=ReactNetCoreCrudDb;User Id=sa;Password=database@1;\"\n  }\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**단계 8.** 서비스 컨테이너 내에서 서비스를 등록하고 미들웨어를 구성하세요.\n\n```js\nusing ProductManagementAPI.Data;\nusing ProductManagementAPI.Repositories;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// 컨테이너에 서비스 추가.\nbuilder.Services.AddScoped\u003cIProductRepository, ProductRepository\u003e();\nbuilder.Services.AddDbContext\u003cAppDbContext\u003e();\nbuilder.Services.AddCors(options =\u003e {\n    options.AddPolicy(\"CORSPolicy\", builder =\u003e builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());\n});\n\n\nbuilder.Services.AddControllers();\n// Swagger/OpenAPI를 구성하는 방법에 대해 자세히 알아보려면 https://aka.ms/aspnetcore/swashbuckle을 방문하십시오.\nbuilder.Services.AddEndpointsApiExplorer();\nbuilder.Services.AddSwaggerGen();\n\nvar app = builder.Build();\n\n// HTTP 요청 파이프라인을 구성하세요.\napp.UseCors(\"CORSPolicy\");\n\nif (app.Environment.IsDevelopment())\n{\n    app.UseSwagger();\n    app.UseSwaggerUI();\n}\n\napp.UseHttpsRedirection();\n\napp.UseAuthorization();\n\napp.MapControllers();\n\napp.Run();\n```\n\n**단계 9.** 다음 엔티티 프레임워크 데이터베이스 마이그레이션 명령을 실행하여 데이터베이스 및 테이블을 생성하세요.\n\n```js\nadd-migration “v1”\n\nupdate-database\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n10단계. 마지막으로 애플리케이션을 실행하고 Swagger UI를 사용하여 다양한 API 엔드포인트를 실행합니다.\n\n![image](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_2.png)\n\n# 샘플 제품 애플리케이션: 프론트엔드 (React JS)\n\nReact JS를 사용하여 클라이언트 애플리케이션을 만들고 위의 API 엔드포인트를 사용하여 소비합시다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n**단계 1.** 다음 명령을 사용하여 새로운 React JS 애플리케이션을 생성하세요:\n\n```js\nnpx create-react-app react-netcore-crud-app\n```\n\n**단계 2.** 프로젝트 디렉토리로 이동하세요:\n\n```js\ncd react-netcore-crud-app\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단계 3. 백엔드 API를 소비하고 호출하기 위해 Axios를 설치하고 설계 목적으로 부트스트랩을 설치하세요.\n\n```js\nnpm install axios\n```\n\n```js\nnpm install bootstrap\n```\n\n단계 4. 다음 컴포넌트 및 서비스를 추가하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제품 목록 컴포넌트입니다.\n\n```js\n// src/components/ProductList/ProductList.js\nimport React, { useState, useEffect } from 'react';\nimport ProductListItem from './ProductListItem';\nimport productService from '../../services/productService';\n\nconst ProductList = () =\u003e {\n    const [products, setProducts] = useState([]);\n\n    useEffect(() =\u003e {\n        fetchProducts();\n    }, []);\n\n    const fetchProducts = async () =\u003e {\n        try {\n            const productsData = await productService.getAllProducts();\n            setProducts(productsData);\n        } catch (error) {\n            console.error('제품을 불러오는 중 오류가 발생했습니다:', error);\n        }\n    };\n\n    const handleDelete = async (id) =\u003e {\n        try {\n            await productService.deleteProduct(id);\n            fetchProducts(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 삭제 중 오류가 발생했습니다:', error);\n        }\n    };\n\n    const handleEdit = () =\u003e {\n        fetchProducts(); // 편집 후 제품 목록 새로고침\n    };\n\n    return (\n        \u003cdiv className=\"container\"\u003e\n            \u003ch2 className=\"my-4\"\u003e제품 목록\u003c/h2\u003e\n            \u003cul className=\"list-group\"\u003e\n                {products.map(product =\u003e (\n                    \u003cProductListItem key={product.id} product={product} onDelete={() =\u003e handleDelete(product.id)} onEdit={handleEdit} /\u003e\n                ))}\n            \u003c/ul\u003e\n        \u003c/div\u003e\n    );\n};\n\nexport default ProductList;\n```\n\n제품 목록 아이템 컴포넌트입니다.\n\n```js\n// src/components/ProductList/ProductListItem.js\nimport React, { useState } from 'react';\nimport productService from '../../services/productService';\n\nconst ProductListItem = ({ product, onDelete, onEdit }) =\u003e {\n    const [isEditing, setIsEditing] = useState(false);\n    const [editedName, setEditedName] = useState(product.name);\n    const [editedPrice, setEditedPrice] = useState(product.price);\n\n    const handleEdit = async () =\u003e {\n        setIsEditing(true);\n    };\n\n    const handleSave = async () =\u003e {\n        const editedProduct = { ...product, name: editedName, price: parseFloat(editedPrice) };\n        try {\n            await productService.updateProduct(product.id, editedProduct);\n            setIsEditing(false);\n            onEdit(); // 제품 목록 새로고침\n        } catch (error) {\n            console.error('제품 업데이트 중 오류가 발생했습니다:', error);\n        }\n    };\n\n    const handleCancel = () =\u003e {\n        setIsEditing(false);\n        // 수정된 값 초기화\n        setEditedName(product.name);\n        setEditedPrice(product.price);\n    };\n\n    return (\n        \u003cli className=\"list-group-item\"\u003e\n            {isEditing ? (\n                \u003cdiv className=\"row\"\u003e\n                    \u003cdiv className=\"col\"\u003e\n                        \u003cinput type=\"text\" className=\"form-control\" value={editedName} onChange={e =\u003e setEditedName(e.target.value)} required /\u003e\n                    \u003c/div\u003e\n                    \u003cdiv className=\"col\"\u003e\n                        \u003cinput type=\"number\" className=\"form-control\" value={editedPrice} onChange={e =\u003e setEditedPrice(e.target.value)} required /\u003e\n                    \u003c/div\u003e\n                    \u003cdiv className=\"col-auto\"\u003e\n                        \u003cbutton className=\"btn btn-success me-2\" onClick={handleSave}\u003e저장\u003c/button\u003e\n                        \u003cbutton className=\"btn btn-secondary\" onClick={handleCancel}\u003e취소\u003c/button\u003e\n                    \u003c/div\u003e\n                \u003c/div\u003e\n            ) : (\n                \u003cdiv className=\"d-flex justify-content-between align-items-center\"\u003e\n                    \u003cspan\u003e{product.name} - ${product.price}\u003c/span\u003e\n                    \u003cdiv\u003e\n                        \u003cbutton className=\"btn btn-danger me-2\" onClick={onDelete}\u003e삭제\u003c/button\u003e\n                        \u003cbutton className=\"btn btn-primary\" onClick={handleEdit}\u003e편집\u003c/button\u003e\n                    \u003c/div\u003e\n                \u003c/div\u003e\n            )}\n        \u003c/li\u003e\n    );\n};\n\nexport default ProductListItem;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n제품 서비스.\n\n```js\n// src/services/productService.js\nimport axios from 'axios';\n\nconst baseURL = 'https://localhost:7202/api/Product';\n\nconst productService = {\n    getAllProducts: async () =\u003e {\n        const response = await axios.get(baseURL);\n        return response.data;\n    },\n    addProduct: async (product) =\u003e {\n        const response = await axios.post(baseURL, product);\n        return response.data;\n    },\n    deleteProduct: async (id) =\u003e {\n        const response = await axios.delete(`${baseURL}/${id}`);\n        return response.data;\n    },\n    updateProduct: async (id, product) =\u003e {\n        const response = await axios.put(`${baseURL}/${id}`, product);\n        return response.data;\n    }\n};\n\nexport default productService;\n```\n\n앱 컴포넌트.\n\n```js\n// src/App.js\nimport React, { useState } from 'react';\nimport ProductList from './components/ProductList/ProductList';\nimport ProductForm from './components/ProductForm/ProductForm';\n\nfunction App() {\n    const [refresh, setRefresh] = useState(false);\n\n    const handleProductAdded = () =\u003e {\n        setRefresh(!refresh); // 다시 렌더링을 트리거 할 수 있도록 새로 고침 상태를 토글\n    };\n\n    return (\n        \u003cdiv\u003e\n            \u003cProductList key={refresh} /\u003e\n            \u003cProductForm onProductAdded={handleProductAdded} /\u003e\n        \u003c/div\u003e\n    );\n}\n\nexport default App;\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 명령을 사용하여 애플리케이션을 실행하고 동일한 도움으로 다양한 CRUD 작업을 수행하세요.\n\n![애플리케이션 실행](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_3.png)\n\n# 애플리케이션을 위한 Docker 파일\n\n- 백앤드 애플리케이션을 위한 Docker 파일 (.NET Core)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n# 공식 .NET Core SDK를 부모 이미지로 사용합니다.\nFROM mcr.microsoft.com/dotnet/sdk:6.0 AS build\n\nWORKDIR /app\n\n# 프로젝트 파일을 복사하고 종속성을 복원합니다 (프로젝트 이름에 .csproj를 사용합니다).\nCOPY *.csproj ./\n\nRUN dotnet restore\n\n# 나머지 응용 프로그램 코드를 복사합니다.\nCOPY . .\n\n# 응용 프로그램을 게시합니다.\nRUN dotnet publish -c Release -o out\n\n# 런타임 이미지를 빌드합니다.\nFROM mcr.microsoft.com/dotnet/aspnet:6.0 AS runtime\n\nWORKDIR /app\nCOPY --from=build /app/out ./\n\n# 응용 프로그램이 실행될 포트를 노출합니다.\nEXPOSE 80\n\n# 응용 프로그램을 시작합니다.\nENTRYPOINT [\"dotnet\", \"ProductManagementAPI.dll\"]\n```\n\n- 1–2번 라인: 공식 .NET Core SDK 이미지 (mcr.microsoft.com/dotnet/sdk:6.0)를 기본 이미지로 사용합니다.\n- 4번 라인: 작업 디렉터리를 /app으로 설정합니다.\n- 6–7번 라인: 프로젝트 파일(*.csproj)을 컨테이너로 복사합니다.\n- 9번 라인: dotnet restore를 실행하여 프로젝트 파일에서 지정된 종속성을 복원합니다.\n- 11–12번 라인: 나머지 응용 프로그램 코드를 컨테이너로 복사합니다.\n- 14–15번 라인: 응용 프로그램을 릴리스 구성으로 게시합니다 (dotnet publish -c Release -o out) out 디렉터리로 출력합니다.\n- 17–18번 라인: 공식 .NET Core ASP.NET 런타임 이미지 (mcr.microsoft.com/dotnet/aspnet:6.0)를 기본 이미지로 사용합니다.\n- 20–21번 라인: 작업 디렉터리를 /app으로 설정하고 빌드 단계의 게시된 출력(from /app/out)을 런타임 단계의 /app 디렉터리로 복사합니다.\n- 23–24번 라인: 외부에서 응용 프로그램에 액세스할 수 있도록 포트 80을 노출합니다.\n- 26–27번 라인: 응용 프로그램을 시작하는 엔트리 포인트 명령어로 dotnet ProductManagementAPI.dll을 지정합니다.\n\n2. 프론트엔드 애플리케이션 (React JS)을 위한 Docker 파일\n\n```js\n# 공식 Node.js 기본 이미지 사용\nFROM node:18\n\n# 작업 디렉터리 설정\nWORKDIR /app\n\n# package.json 및 package-lock.json 파일 복사\nCOPY package*.json ./\n\n# 종속성 설치\nRUN npm install\n\n# 나머지 애플리케이션 코드 복사\nCOPY . .\n\n# React 앱 빌드\nARG REACT_APP_API_URL\nENV REACT_APP_API_URL=$REACT_APP_API_URL\nRUN npm run build\n\n# serve를 전역적으로 설치하여 빌드 폴더를 제공합니다\nRUN npm install -g serve\n\n# 앱이 실행되는 포트 노출\nEXPOSE 3000\n\n# React 앱 시작\nCMD [\"serve\", \"-s\", \"build\"]\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 1–2번째 줄: Node.js 버전 18을 사용하는 기본 이미지를 지정합니다.\n- 4–5번째 줄: 이후 명령에 대한 작업 디렉토리로 /app를 설정합니다.\n- 7–8번째 줄: package.json 및 package-lock.json을 로컬 머신에서 Docker 이미지로 복사합니다.\n- 10–11번째 줄: package.json에 나열된 모든 종속성을 설치하기 위해 npm install을 실행합니다.\n- 13–14번째 줄: 나머지 애플리케이션 코드를 Docker 이미지로 복사합니다.\n- 16–19번째 줄: ARG 명령은 빌드 시간 변수 REACT_APP_API_URL을 정의합니다. ENV 명령은 빌드 시간 변수의 값인 REACT_APP_API_URL 환경 변수를 설정합니다. 또한 RUN npm run build는 React 애플리케이션을 빌드합니다.\n- 21–22번째 줄: serve 패키지를 전역으로 설치하여 빌드된 React 애플리케이션을 제공합니다.\n- 24–25번째 줄: 애플리케이션이 실행될 포트인 3000을 노출합니다.\n- 27–28번째 줄: 명령은 serve를 사용하여 빌드 폴더를 제공함으로써 React 애플리케이션을 시작합니다.\n\n프런트엔드 애플리케이션에 대해 React 프로젝트 루트에 .env 파일을 생성합니다. 이 파일에는 환경 변수가 포함되어 있으며, Docker 이미지를 실행하거나 백엔드 API URL을 전달하는 데 사용할 수 있습니다.\n\n```js\nREACT_APP_API_URL=http://your-backend-url.com\n```\n\n다음으로, 제품 서비스에서 백엔드 하드코딩된 URL을 수정하십시오.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n// src/services/productService.js\nimport axios from 'axios';\n\nconst baseURL = process.env.REACT_APP_API_URL;\n\nconst productService = {\n    getAllProducts: async () =\u003e {\n        const response = await axios.get(baseURL);\n        return response.data;\n    },\n    addProduct: async (product) =\u003e {\n        const response = await axios.post(baseURL, product);\n        return response.data;\n    },\n    deleteProduct: async (id) =\u003e {\n        const response = await axios.delete(`${baseURL}/${id}`);\n        return response.data;\n    },\n    updateProduct: async (id, product) =\u003e {\n        const response = await axios.put(`${baseURL}/${id}`, product);\n        return response.data;\n    }\n};\n\nexport default productService;\n```\n\n## 프론트엔드 및 백엔드 어플리케이션을 컨테이너화하기\n\n단계 1.\n\n도커 이미지 빌드하기\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 빌드 명령어를 사용하여 productbackendapp:latest 이미지를 빌드하세요.\n```\n\n![이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_4.png)\n\n```js\n도커 빌드 명령어를 사용하여 REACT_APP_API_URL이 http://localhost:8085/api/Product인 productfrontendapp 이미지를 빌드하세요.\n```\n\n![이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_5.png)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nStep 2.\n\n필요한 매개변수를 전달한 후 이미지를 실행합니다. 필요한 매개변수는 env와 arguments입니다.\n\n```js\ndocker run -p 8085:80 -e \"ConnectionStrings__DefaultConnection=Data Source=192.168.100.194,1433;Initial Catalog=ReactNetCoreCrudDb;User Id=sa;Password=database@1;\" productbackendapp:latest\n```\n\n![이미지](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_6.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![Image 7](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_7.png)\n\n![Image 8](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_8.png)\n\n![Image 9](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_9.png)\n\n![Image 10](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_10.png)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\n도커 실행 -p 3000:3000 productfrontendapp\n```\n\n![이미지1](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_11.png)\n\n![이미지2](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_12.png)\n\n![이미지3](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_13.png)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 샘플 애플리케이션 스크린샷\n\n![screenshot1](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_14.png)\n\n![screenshot2](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_15.png)\n\n![screenshot3](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_16.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지 1](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_17.png)\n\n![이미지 2](/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_18.png)\n\n# GitHub\n\nhttps://github.com/Jaydeep-007/React_NETCore_CRUD-Docker\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이 기사에서는 .NET Core 및 SQL Server를 사용하여 제품 관리 백엔드 애플리케이션을 만들었습니다. 이 애플리케이션은 CRUD 작업을 수행하는 데 필요한 다양한 API 엔드포인트를 사용합니다. 나중에 React JS를 사용하여 프론트엔드 애플리케이션을 만들고, Axios를 활용하여 백엔드 애플리케이션을 소비하였습니다. 또한, 두 애플리케이션을 Docker를 사용하여 컨테이너화하였습니다.","ogImage":{"url":"/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_0.png"},"coverImage":"/assets/img/2024-07-01-BuildandContainerizeProductApplicationusingReactJSNETCoreandDocker_0.png","tag":["Tech"],"readingTime":26},{"title":"Docker로 ReactJS 애플리케이션 컨테이너화하는 방법","description":"","date":"2024-07-01 16:15","slug":"2024-07-01-ContainerizationofReactJSApplicationusingDocker","content":"\n\n\u003cimg src=\"/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_0.png\" /\u003e\n\n안녕하세요\n\n이 글에서는 샘플 React JS 애플리케이션을 생성하고 Docker를 활용하여 컨테이너화하는 방법을 배워보겠습니다.\n\n일정\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- React JS 애플리케이션 샘플\n- Docker 파일 생성\n- 애플리케이션 컨테이너화\n\n필수 요구사항\n\n- NPM\n- React JS\n- Docker Engine\n\nReact JS 애플리케이션 샘플\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n단계 1:\n\n아래 명령어를 사용하여 새 React JS 애플리케이션을 만듭니다.\n\n참고: 머신에 NPM 및 React JS가 이미 설치되어 있는지 확인하세요.\n\n\nnpx create-react-app reactjs-app-docker\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_1.png)\n\n단계 2:\n\n애플리케이션 디렉토리로 이동하여 애플리케이션을 실행합니다.\n\nnpm start\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Markdown 형식으로 변경된 테이블입니다.\n\n\n![이미지 1](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_2.png)\n\n![이미지 2](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_3.png)\n\nDocker 파일 생성\n\n```js\n# 공식 Node.js 베이스 이미지 사용\nFROM node:18\n\n# 작업 디렉토리 설정\nWORKDIR /app\n\n# package.json 및 package-lock.json 파일 복사\nCOPY package*.json ./\n\n# 종속 항목 설치\nRUN npm install\n\n# 나머지 애플리케이션 코드 복사\nCOPY . .\n\n# React 앱 빌드\nRUN npm run build\n\n# 빌드 폴더를 제공하는 serve를 전역으로 설치\nRUN npm install -g serve\n\n# 앱이 실행되는 포트 노출\nEXPOSE 3000\n\n# React 앱 시작\nCMD [\"serve\", \"-s\", \"build\"]\n```\n\n\n안내해 주셔서 감사합니다. 기타 요청이 있으시면 언제든지 말씀해주세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래는 Docker 파일의 각 단계를 설명합니다:\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_4.png)\n\n이 줄은 Docker 이미지의 기본 이미지를 지정합니다. 우리는 Node.js의 공식 이미지를 버전 18으로 사용합니다. 이 이미지에는 Node.js 애플리케이션을 실행하는 데 필요한 모든 것이 포함되어 있습니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위 줄은 Docker 컨테이너 내의 작업 디렉토리를 /app으로 설정합니다. 이후의 모든 명령은 /app 디렉토리에서 실행됩니다. 이는 컨테이너 내에서 파일 시스템을 조직화하는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_6.png)\n\n호스트 머신에서 package.json 및 package-lock.json을 Docker 컨테이너의 현재 작업 앱 디렉토리로 복사합니다. 이 파일들은 애플리케이션의 의존성을 설치하는 데 필요합니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_7.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 단계는 package.json에 정의된 종속성을 설치하기 위해 npm install을 실행합니다. 이 단계를 통해 모든 필요한 Node.js 패키지가 컨테이너에 설치됩니다.\n\n![image](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_8.png)\n\n다음으로, 호스트 머신의 현재 디렉토리에서 Docker 컨테이너의 현재 작업 디렉토리로 모든 파일과 디렉토리를 복사합니다. 이는 소스 코드와 애플리케이션을 빌드하고 실행하는 데 필요한 모든 파일을 포함합니다.\n\n![image](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_9.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 명령은 React 애플리케이션을 프로덕션을 위해 빌드하는 npm run build를 실행합니다. 빌드 프로세스는 React 코드를 컴파일합니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_10.png)\n\nDocker 컨테이너 내부에 serve 패키지를 글로벌로 설치합니다. serve는 빌드된 React 애플리케이션을 제공하는 데 사용할 간단한 정적 파일 서버입니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_11.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 줄은 Docker에게 컨테이너가 실행 중일 때 포트 3000에서 수신 대기함을 알려줍니다. 이 포트는 React 애플리케이션이 제공될 포트입니다.\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_12.png)\n\n다음으로, 컨테이너가 시작될 때 실행할 명령을 지정합니다. 여기서 serve -s build는 serve 정적 파일 서버를 시작하고 React 빌드 프로세스에서 컴파일된 정적 파일이 포함된 build 디렉토리의 내용을 제공합니다.\n\n애플리케이션의 컨테이너화\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n안녕하세요! 위 아래로 팔을 펴고 팔다리를 흔들어보세요. 근육들을 풀어주는 운동이죠! 함께 힘내봐요! 🏋🏻‍♂️🚀\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래와 같이 Markdown 형식으로 변경하면 됩니다.\n\n\n![Containerization of ReactJS Application using Docker](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_13.png)\n\nStep 2:\n\nRun the docker image.\n\ndocker run -p 3000:3000 reactjs-app-docker\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_14.png)\n\n![이미지](/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_15.png)\n\nGithub:\n\nhttps://github.com/Jaydeep-007/reactjs-app-docker\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n결론\n\n이 글에서는 샘플 React JS 애플리케이션을 만들었습니다. 이후 Docker 파일을 생성하고 각 단계와 목적을 이해했습니다. 마지막으로 Docker 명령어를 사용하여 Docker 이미지 파일을 빌드하고 컨테이너화했습니다.","ogImage":{"url":"/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_0.png"},"coverImage":"/assets/img/2024-07-01-ContainerizationofReactJSApplicationusingDocker_0.png","tag":["Tech"],"readingTime":8},{"title":"Socketio를 사용한 실시간 채팅 최고의 구현 방법 Socket 실시간 DB 활용법","description":"","date":"2024-07-01 16:14","slug":"2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb","content":"\n\n\n\u003cimg src=\"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png\" /\u003e\n\n현재, 현대 통신 기술에서 실시간 채팅 애플리케이션은 필수품이 되었습니다. React 또는 React Native에서 채팅 앱을 개발하는 경우, 올바른 기술 스택 선택이 중요합니다. 많은 개발자들이 WebSockets 또는 Firebase와 같은 실시간 데이터베이스를 사용해야 하는 딜레마에 직면합니다. 또한, 소켓 연결 중단 처리 및 데이터 신뢰성 확보는 흔한 도전 과제입니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_1.png\" /\u003e\n\n본 블로그 포스트에서는 실시간 채팅 기능을 관리하는 최상의 방법에 대해 살펴보고, 소켓 연결 중단 및 데이터 손실과 관련된 문제를 극복하는 데 중점을 둘 것입니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# WebSockets 대 실시간 데이터베이스: 적합한 도구 선택하기\n\n기술적인 세부 사항에 대해 깊이 이해하기 전에 WebSockets와 실시간 데이터베이스 간의 차이점을 이해하는 것이 중요합니다.\n\n## WebSockets\n\n장점:\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 낮은 대기 시간: 웹소켓은 지속적인 연결을 제공하여 낮은 대기 시간으로 양방향 통신이 가능합니다.\n- 효율성: 빈번한 업데이트에 이상적이며, 웹소켓을 사용하면 반복된 HTTP 요청의 오버헤드가 줄어듭니다.\n- 유연성: 사용자 정의 프로토콜과 데이터 형식을 지원하여 더 많은 제어가 가능합니다.\n\n단점:\n- 복잡성: 웹소켓 서버를 설정하고 관리하는 것이 어려울 수 있습니다.\n- 확장성: 많은 연결을 다루려면 견고한 인프라가 필요합니다.\n\n## 실시간 데이터베이스 (파이어베이스)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n장점:\n\n- 사용의 편의성: Firebase는 실시간 데이터 동기화를 위한 직관적인 API를 제공합니다.\n- 확장성: Firebase에서 관리되므로 확장하기 쉽습니다.\n- 내장된 기능: 인증, 분석 및 오프라인 지원이 포함되어 있습니다.\n\n단점:\n\n- 대기 시간: WebSockets보다 약간 높은 대기 시간이 발생할 수 있습니다.\n- 비용: 앱이 확장될수록 사용량 기반 요금 체계가 비싸질 수 있습니다.\n- 제어 능력 감소: Firebase는 세부 정보를 추상화하여 사용자 정의를 제한합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 소켓 연결 문제 극복하기\n\n특히 모바일 환경에서 소켓 연결은 네트워크 불안정 또는 기기 상태로 인해 끊길 수 있습니다. 안정적인 통신과 데이터 무결성을 보장하기 위한 전략들이 있습니다.\n\n## 1. 자동 재연결\n\n연결이 끊겼을 때 소켓을 자동으로 다시 연결하는 로직을 구현하세요. Socket.IO와 같은 라이브러리는 재연결을 위한 내장 지원 기능을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nconst socket = io('https://yourserver.com', {\n  reconnection: true,\n  reconnectionAttempts: Infinity,\n  reconnectionDelay: 1000,\n  reconnectionDelayMax: 5000,\n  timeout: 20000,\n});\n```\n\n## 2. 메시지 확인\n\n메시지가 수신되었는지 확인하려면 확인을 사용하십시오. 확인되지 않은 경우 메시지를 재전송하십시오.\n\n```js\nsocket.emit('message', message, (response) =\u003e {\n  if (response.status !== 'ok') {\n    // 메시지 재전송 시도\n  }\n});\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3. 메시지 대기열\n\n연결이 끊어지면 메시지를 대기열에 저장하고 다시 연결되면 다시 전송합니다.\n\n```js\nlet messageQueue = [];\n\nsocket.on('connect', () =\u003e {\n  while (messageQueue.length \u003e 0) {\n    const message = messageQueue.shift();\n    socket.emit('message', message);\n  }\n});\n\nfunction sendMessage(message) {\n  if (socket.connected) {\n    socket.emit('message', message);\n  } else {\n    messageQueue.push(message);\n  }\n}\n```\n\n## 4. 네트워크 변경 처리\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n네트워크 변경사항을 청취하여 효율적으로 재연결을 처리하세요.\n\n```js\nwindow.addEventListener('online', () =\u003e {\n  if (!socket.connected) {\n    socket.connect();\n  }\n});\nwindow.addEventListener('offline', () =\u003e {\n  socket.disconnect();\n});\n```\n\n## 5. 지속적인 저장\n\n로컬 저장소나 데이터베이스와 같은 지속적인 저장소를 사용하여 메시지를 임시로 저장하세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n```js\nfunction saveMessageToLocal(message) {\n  const messages = JSON.parse(localStorage.getItem('messages')) || [];\n  messages.push(message);\n  localStorage.setItem('messages', JSON.stringify(messages));\n}\n\nfunction loadMessagesFromLocal() {\n  return JSON.parse(localStorage.getItem('messages')) || [];\n}\n\nfunction clearLocalMessages() {\n  localStorage.removeItem('messages');\n}\n\nfunction sendMessage(message) {\n  if (socket.connected) {\n    socket.emit('message', message, (response) =\u003e {\n      if (response.status === 'ok') {\n        // Message sent successfully\n      } else {\n        saveMessageToLocal(message);\n      }\n    });\n  } else {\n    saveMessageToLocal(message);\n  }\n}\n\nsocket.on('connect', () =\u003e {\n  const messages = loadMessagesFromLocal();\n  messages.forEach((message) =\u003e {\n    socket.emit('message', message);\n  });\n  clearLocalMessages();\n});\n```\n\n## 6. Heartbeat/Ping Mechanism\n\n연결이 끊어진 경우를 감지하고 다시 연결하기 위한 하트비트 메커니즘을 구현합니다.\n\n```js\nsetInterval(() =\u003e {\n  if (socket.connected) {\n    socket.emit('ping');\n  }\n}, 5000);\n\nsocket.on('pong', () =\u003e {\n  // 연결 유지 중\n});\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 결론\n\n이러한 전략을 구현하면 대화 응용 프로그램의 신뢰성을 크게 향상시킬 수 있습니다. 자동 재연결, 메시지 확인, 메시지 대기열, 네트워크 변경 처리, 영구 저장, 그리고 하트비트 메커니즘을 활용하여 견고하고 원활한 사용자 경험을 보장할 수 있습니다.\n\n블로그 게시물의 어떤 부분이든 스타일이나 응용 프로그램에 대한 구체적인 세부 정보와 더 잘 맞도록 조정하는 데 자유롭게 변경하십시오.\n\n# 즐거운 코딩","ogImage":{"url":"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png"},"coverImage":"/assets/img/2024-07-01-ChatUsingSocketioWithBestpracticesSocketReal-Timedb_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 React Native 마스터하기 전문가 통찰을 통해 기술 스택을 완벽하게 이해하는 종합 가이드","description":"","date":"2024-07-01 16:12","slug":"2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights","content":"\n\n이미지 태그를 Markdown 형식으로 변경해보세요.\n\n\n![Mastering React Native in 2024](/assets/img/2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights_0.png)\n\n# 1. 파워 언어: TypeScript\n\n왜 TypeScript를 사용해야 할까요?\n\n- 정적 타입: TypeScript는 코드 품질을 향상시키고 개발 중 잠재적인 오류를 찾아냅니다.\n- 향상된 도구: 더 좋은 IDE 지원과 코드 탐색을 즐기세요.\n- 확장성: TypeScript는 보다 구조화되고 확장 가능한 코드베이스를 제공합니다.\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 2. CLI 유연성: Expo Eject 옵션과 함께 React Native CLI\n\nReact Native CLI를 선택하는 이유는?\n\n- 완벽한 사용자 정의: React Native CLI는 완벽한 사용자 정의와 네이티브 모듈 호환성을 제공합니다.\n- Eject 옵션: 빠른 개발을 위해 Expo로 시작하고 더 많은 제어를 위해 React Native CLI로 이동하세요.\n\n# 3. 매끄러운 라우팅: React Navigation\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nReact Navigation을 사용하는 이유는 무엇인가요?\n\n- 크로스 플랫폼 호환성: React Navigation은 강력한 크로스 플랫폼 지원으로 널리 채택되었습니다.\n- 사용자 정의: 다양한 앱 구조에 대한 유연하고 사용자 정의 가능한 네비게이션 솔루션을 제공합니다.\n\n# 4. UI 우수성: Tailwind를 Native Wind와 함께 사용하는 이유는 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 유틸리티 우선 접근: Tailwind의 유틸리티 우선 접근은 UI 개발을 간소화합니다.\n- Native Wind 통합: Native Wind는 Tailwind의 강력함을 React Native로 가져와 네이티브 미학과 유연성을 결합합니다.\n\n# 5. 상태 관리 조화: Zustand\n\nZustand을 선택하는 이유는?\n\n- 간결함: Zustand는 상태 관리에 더 간단하고 직관적인 방법을 제공합니다.\n- 보일러플레이트 없음: Redux와 같은 큰 솔루션과 관련된 보일러플레이트 코드 없이 상태 관리를 즐기세요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 6. 데이터 손쉽게 가져오기: GraphQL과 함께 React Query\n\nReact Query와 GraphQL을 함께 사용하는 이유는 무엇일까요?\n\n- 효율성: React Query는 데이터 가져오기와 캐싱을 단순화합니다.\n- GraphQL의 장점: 최적화된 API 상호작용을 위해 GraphQL의 혜택을 누릴 수 있습니다.\n\n# 7. 데이터 저장이 쉬운 MMKV\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nMMKV는 React Native를 위한 성능 우수한 키-값 저장 솔루션이에요. 속도를 희생하지 않고 효율적인 데이터 지속성을 누리세요.\n\n# 8. 애니메이션 마법: React Native Reanimated\n\nReact Native Reanimated를 사용하는 이유는 무엇인가요?\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 부드러운 애니메이션: React Native Reanimated을 사용하면 원활하고 매혹적인 애니메이션을 만들 수 있습니다.\n- 네이티브 성능: 네이티브 성능을 활용하여 사용자 경험을 원활하게 만들 수 있습니다.\n\n# 9. 디버깅의 즐거움: Flipper와 Reactotron\n\nFlipper와 Reactotron을 선택하는 이유는?\n\n- 시각적 디버깅: Flipper는 React Native 앱을 디버깅하는데 시각적 인터페이스를 제공합니다.\n- 실시간 정보: Reactotron은 실시간 로깅, 네트워킹 등을 제공하여 개발을 간소화합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n# 10. 오류 보고의 탁월함: 센트리\n\n왜 센트리를 사용해야 하나요?\n\n- 포괄적인 오류 추적: 센트리는 포괄적인 오류 추적을 통해 문제를 식별하고 해결하는 데 도움을 줍니다.\n- 플랫폼 간 지원: 센트리의 플랫폼 간 호환성을 활용하여 통합된 오류 보고 솔루션을 얻을 수 있습니다.\n\n# 11. 효율적인 개발을 위한 크로스 플랫폼 전략: 엑스포\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n왜 Expo를 선택해야 할까요?\n\n- 빠른 개발: Expo는 간소화된 워크플로우로 개발을 가속화합니다.\n- 관리 환경: 사용 편의성을 위해 관리 환경을 즐길 수 있습니다.\n\n요약하면, 2024년에 React Native 기술 스택을 탐색하는 것은 매회 전략적인 결정을 내려야 합니다. 강력한 타입 지원을 위해 TypeScript를 채택하고, 유연성을 위해 적절한 CLI를 선택하며, 프로젝트 요구 사항과 일치하는 상태 관리 및 UI 라이브러리를 선택하고, 효율적인 데이터 가져오기 및 저장 솔루션을 활용하여 혁신을 촉진하고 개발을 가속화하는 기술 스택을 만들 수 있습니다. React Native 개발의 흥미진진한 여정을 기대해 주세요!\n\n# 스텔라 컴포넌트 통합: 이 젬들로 앱을 한 단계 높이세요\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이제, 앱의 기능성과 사용자 인터페이스를 향상시킬 수 있는 훌륭한 React Native 구성 요소를 소개하겠습니다:\n\n## 1. Bouncy CheckBox\n\n- 설명: 바운시 애니메이션이 있는 매력적인 체크박스 컴포넌트.\n- 주요 기능:\n  - 상호작용이 가능하고 시각적으로 매력적인 체크박스.\n  - 사용자 참여를 위한 부드러운 애니메이션.\n\n## 2. Bottom Sheet\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- **설명:** 화면 하단에서 슬라이드 업되는 다재다능한 패널입니다.\n- **주요 기능:**\n  - 메뉴, 모달 또는 추가 콘텐츠에 적합합니다.\n  - 부드러운 전환 효과 및 사용자 정의 가능한 모양입니다.\n\n# 3. React Native Gifted Chat\n\n- **설명:** 매우 사용자 정의가 가능한 채팅 UI 라이브러리입니다.\n- **주요 기능:**\n  - 다양한 채팅 구성 요소가 있습니다.\n  - 이미지, 위치 공유 등을 지원합니다.\n  - 사용자 정의가 가능하며 통합하기 쉽습니다.\n\n# 4. Victory-Native\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설명: 인기 있는 Victory 라이브러리를 기반으로 한 React Native용 차트 라이브러리입니다.\n- 주요 기능:\n- 다양한 차트 유형 지원 (선 그래프, 막대 그래프, 파이 차트 등).\n- 매우 사용자 정의 및 상호 작용형 차트.\n\n# 5. React-Native-Toast-Message\n\n- 설명: 토스트 메시지를 표시하는 간단한 방법입니다.\n- 주요 기능:\n- 가볍고 사용하기 쉽습니다.\n- 다양한 구성으로 사용자 정의할 수 있는 토스트 메시지.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설명: 플레이스홀더 로딩 애니메이션을 생성하는 구성 요소입니다.\n- 주요 기능:\n    - 콘텐츠를 위한 스켈레톤 로딩 애니메이션 제공\n    - 다양한 UI 요소에 맞춤 설정 가능\n\n## 7. React-Native-Pager-View\n\n- 설명: 크로스 플랫폼 뷰 페이저 컴포넌트입니다.\n- 주요 기능:\n    - iOS 및 안드로이드 모두 지원\n    - 부드러운 스와이핑 및 사용자 정의 가능한 전환 효과\n\n## 8. React-Native-Calendars\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설명: 사용자 정의 및 확장 가능한 달력 구성 요소입니다.\n- 핵심 기능:\n- 다양한 달력 보기 지원 (월, 주, 일).\n- 사용자 정의 가능한 외관 및 이벤트 통합.\n\n## 9. @shopify/flash-list\n\n- 설명: React Native용 고성능 목록 구성 요소입니다.\n- 핵심 기능:\n- 대량 데이터 세트에 효율적인 렌더링.\n- 무한 스크롤 및 동적 로딩 지원.\n\n## 10. 이미지 캐싱을 위한 React-Native-Fast-Image\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 설명: React Native를 위한 성능 최적화된 이미지 캐싱 컴포넌트.\n- 주요 기능:\n  - 개선된 성능을 위해 이미지를 효율적으로 캐싱합니다.\n  - React Native 애플리케이션과의 심리스한 통합을 제공합니다.\n\n이러한 컴포넌트들은 상호작용적이고 시각적으로 매력적인 React Native 애플리케이션을 구축하기 위한 다양한 기능을 제공합니다. 프로젝트 요구 사항에 따라 이러한 컴포넌트들을 통합하여 사용자 경험을 향상시키고 개발을 최적화할 수 있습니다.\n\n강력한 도구들과 즐거운 컴포넌트들로 풍부한 React Native 개발 여정을 기대해 주세요!\n\n👏 스토리에 박수를 보내고 작가를 팔로우하세요!\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- 저자의 통찰력 있는 콘텐츠에 감사드립니다.\n- Abhishek Kumar를 팔로우하세요.\n- 📰 Abhishek Kumar 도서관에서 더 알아보기\n- 🔔 소셜 미디어를 통해 연락을 유지하세요.\n- Level Up Coding을 트위터에서 팔로우하고 링크드인에서 소통하여 최신 토론과 콘텐츠를 확인하세요.\n\n# Stackademic\n\n끝까지 읽어주셔서 감사합니다. 떠나시기 전에:\n\n- 작가에게 박수를 보내고 팔로우를 고려해 주세요! 👏\n- Twitter(X)와 리눅스, 유튜브에서 팔로우하세요.\n- Stackademic.com 방문하여 전 세계의 무료 프로그래밍 교육을 민주화하는 방법에 대해 더 알아보세요.","ogImage":{"url":"/assets/img/2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights_0.png"},"coverImage":"/assets/img/2024-07-01-MasteringReactNativein2024AComprehensiveGuidetoNavigatetheTechStackwithExpertInsights_0.png","tag":["Tech"],"readingTime":9},{"title":"2024년에 수강할 수 있는 최고의 프론트엔드 마스터 강좌 TOP 5","description":"","date":"2024-07-01 16:11","slug":"2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024","content":"\n\n## 2024년에 수강할 Frontend Masters의 내가 좋아하는 웹 개발 과정\n\n![이미지](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_0.png)\n\n안녕하세요 여러분, 웹 개발 분야의 빠르고 끊임없이 진화하는 환경에서 계속적인 학습은 유익할 뿐만 아니라 필수적입니다. 현재보다 앞서가기 위해서는 기술 스킬을 지속적으로 향상시키고, 새로운 기술을 이해하고, 현대 웹 애플리케이션을 구동하는 도구를 숙달하는 노력이 필요합니다.\n\n2024년에 전문성과 경력 전망을 높이고 싶은 개발자들을 위해, Frontend Masters는 가장 포괄적이고 매력적인 과정 중 일부를 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\nFrontend Master는 초보자부터 숙련된 개발자를 위한 고품질, 심층적인 코스로 유명한 최고의 온라인 학습 플랫폼으로 자리매김했습니다.\n\n웹 개발 기초를 이해하고 복잡한 알고리즘을 파헤치거나 React 같은 강력한 프론트엔드 라이브러리를 숙달하려면, Frontend Master에는 여러분의 Bed를 충족시키는 코스가 마련되어 있습니다.\n\n본 기사에서는 2024년에 고려해볼 만한 상위 5개 Frontend Master 코스를 살펴보겠습니다. 이 코스들은 관련성, 종합성 및 전달하는 실용적인 기술에 기반하여 선정되었습니다.\n\n알고리즘과 JavaScript 숙달부터 React에서 능숙해지고 풀스택을 이해하기까지, 이러한 코스들은 경쟁적인 웹 개발 세계에서 두각을 나타내기 위해 필요한 지식과 실무 경험을 제공할 것입니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n한번 깊게 파보고 이 각각의 강좌가 여러분의 학습 목표와 직업 목표를 어떻게 달성할 수 있는지 알아보세요.\n\n그런데, 만약 여러분이 서둘러야 한다면, 지금 Frontend Masters에 가입해보세요. 그들의 고품질 강좌를 시청한 뒤 나중에 저에게 감사할 거예요.\n\n# 웹 개발자를 위한 Frontend Masters의 최고 강좌 5선\n\n여기 Frontend Masters에서 웹 개발자들이 JavaScript와 React와 같은 필수 웹 개발 스킬을 배울 수 있는 최고의 강좌 목록이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 1. 당신이 필요로 할 마지막 알고리즘 강의\n\n알고리즘은 효율적인 프로그래밍의 근간이며, 그것들을 숙달하면 문제 해결 능력이 크게 향상됩니다. \"당신이 필요로 할 마지막 알고리즘 강의\"는 기본적인 정렬과 탐색부터 동적 프로그래밍과 그래프 알고리즘과 같은 고급 주제까지 모두 다루며 알고리즘에 대한 깊은 이해를 제공하도록 설계되었습니다.\n\n## 주요 강점:\n\n- 포괄적인 커리큘럼: 이 강의는 다양한 알고리즘을 다루어 어떤 코딩 과제에도 대처할 수 있도록 충분히 장착되도록 보장합니다.\n- 실습 중심 학습: 다양한 코딩 연습과 실제 문제를 통해 알고리즘을 구현하는 실용적인 경험을 얻을 수 있습니다.\n- 전문가의 지도: 경력 있는 전문가들이 가르치며 교재에서 찾을 수 없는 통찰과 조언을 제공합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 등록해야 하는 이유:\n\n알고리즘을 마스터하면 코딩 효율성을 향상시킬 뿐만 아니라 기술 면접과 경쟁적인 프로그래밍에 대비할 수 있습니다. 이 강좌는 알고리즘에 튼튼한 기반을 제공하여 개발자들에게 불가능한 기술을 갖추게 해줍니다.\n\n이 강좌에 등록하려면 [여기](#)를 클릭하세요 — 이 강좌가 최후의 알고리즘 강좌가 될 겁니다.\n\n![이미지](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_1.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 2. JavaScript: 처음부터 전문가까지\n\n자바스크립트는 웹의 공용어이며, 프런트엔드 개발자에게 필수적인 능력입니다. \"JavaScript: 처음부터 전문가까지\"는 자바스크립트의 기초부터 고급 개념까지 다루는 포괄적인 강좌로, 당신을 숙련된 자바스크립트 개발자로 만들어줍니다.\n\n## 주요 내용:\n\n- 초급에서 고급까지: 강좌는 자바스크립트의 기초부터 시작하여 클로저, 프로토타입, 비동기 프로그래밍과 같은 고급 주제를 순차적으로 다룹니다.\n- 프로젝트 중심의 학습: 학습을 강화하고 여러분의 기술을 증명할 수 있는 현실 세계 프로젝트를 개발합니다.\n- 최신 자바스크립트: 강좌에는 ES6+ 문법과 기능을 비롯한 최신 자바스크립트 기능이 포함되어 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 등록해야 하는 이유:\n\n자바스크립트는 현대 웹 개발의 핵심입니다. 이 과정은 자바스크립트에 대해 철저한 기초를 제공하여 동적이고 인터랙티브한 웹 애플리케이션을 개발할 준비를 완벽하게 합니다.\n\n이 수업에 가입할 수 있는 링크는 여기에 있습니다 — JavaScript: 초보부터 전문가까지\n\n![Frontend Master Courses in 2024](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_2.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 3. 완전한 리액트 입문, v8\n\n리액트는 사용자 인터페이스를 구축하는 데 가장 인기 있는 라이브러리 중 하나가 되었습니다. \"완전한 리액트 입문, v8\"은 리액트를 배우는 데 가장 확실한 코스로, JSX, 상태, 속성, 라이프사이클 메서드와 같은 기본부터 후크, 컨텍스트, 그리고 성능 최적화와 같은 고급 개념까지 모두 다룹니다.\n\n## 주요 포인트:\n\n- 철저한 리액트 개념: 이 코스는 JSX, 상태, 속성, 라이프사이클 메서드 등 리액트의 핵심 개념을 다룹니다.\n- 현대적인 리액트 실천 방법: 후크와 컨텍스트 API와 같은 최신 리액트 기능에 대해 배우면서, 산업 실무에서 최신 동향을 따를 수 있습니다.\n- 실전 프로젝트: 여러 프로젝트를 개발하면서, 리액트 애플리케이션을 만드는 경험을 통해 실무 역량을 키울 수 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 등록해야 하는 이유:\n\nReact는 동적 웹 애플리케이션을 구축하는 강력한 도구입니다. 이 코스는 복잡하고 성능이 우수한 React 애플리케이션을 만들기 위해 필요한 기술을 갖추게 해주며, 어떤 개발팀에도 가치 있는 자산이 될 것입니다.\n\n이 코스에 가입하려면 다음 링크를 클릭하세요 — Complete Intro to React, v8\n\n![React Course Image](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_3.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 4. 풀 스택 for 프론트 엔드 엔지니어, v3\n\n전체 스택을 이해하는 것은 견고하고 확장 가능한 웹 애플리케이션을 구축하고 싶어하는 프론트 엔드 엔지니어들에게 중요합니다. \"프론트 엔드 엔지니어를 위한 풀 스택, v3\"는 프론트 엔드와 백엔드 개발 사이의 간극을 좁히며 둘에 대한 포괄적인 이해를 제공합니다.\n\n## 주요 내용:\n\n- 포괄적인 커버리지: 이 강좌는 React와 같은 프론트 엔드 기술뿐만 아니라 Node.js, Express, 데이터베이스 등 백엔드 기술도 다룹니다.\n- 실제 응용 프로그램: 프론트 엔드와 백엔드 구성 요소를 통합하는 실용적인 경험을 쌓을 수 있도록 풀 스택 애플리케이션을 구축합니다.\n- 배포 및 데브옵스: 애플리케이션을 배포하고 본딩 환경에서 관리하는 방법을 배웁니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 등록해야 하는 이유:\n\n풀 스택 지식은 디자인부터 배포까지 개발 프로세스 전반에 이해하고 기여할 수 있게 해줍니다. 이 과정은 완전한 웹 응용 프로그램을 구축하고 유지 관리하는 기술을 제공하여 개발자로서의 다재다능성을 향상시킵니다.\n\n다음은 이 수업에 참여하는 링크입니다 - 풀 스택을 위한 프론트엔드 엔지니어링, v3\n\n![course image](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_4.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 5. 완전한 웹 개발 입문, v3\n\n웹 개발에 새로 오신 분들을 위해 \"완전한 웹 개발 입문, v3\"은 해당 분야에 대한 포괄적인 소개를 제공합니다. 이 과정은 HTML 및 CSS부터 JavaScript 및 그 이상까지 모던 웹 애플리케이션을 구축하는 데 필요한 기본 기술과 개념을 다룹니다.\n\n## 주요 포인트:\n\n- 기초 기술: 웹 개발의 핵심 기술인 HTML, CSS 및 JavaScript의 기초를 배웁니다.\n- 대화식 학습: 이 과정은 상호 작용하는 코딩 연습과 프로젝트를 포함하여 학습을 강화합니다.\n- 모던 웹 개발: 반응형 디자인 및 Git을 활용한 버전 관리를 포함한 현대적인 웹 개발 방법 및 도구에 입문합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 등록해야 하는 이유:\n\n이 강좌는 초보자에게 이상적인 웹 개발의 견고한 기반을 제공합니다. 강좌를 마치면 자신만의 웹 애플리케이션을 구축하고 더 고급 주제에서 계속 학습할 수 있는 기술을 습득할 수 있습니다.\n\n이 강좌에 가입하려면 다음 링크를 참조하세요 - Complete Intro to Web Development, v3\n\n![Link to the course](/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_5.png)\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n## 결론\n\n2024년 웹 개발을 배우는 데 도움이 되는 5가지 최고의 Frontend Masters 강좌에 대해 알아보았습니다. 교육과 기술에 투자하는 것은 웹 개발 분야에서 경력을 나아가는 가장 좋은 방법 중 하나입니다.\n\n2024년을 위한 이 상위 5개 FrontMaster 강좌는 이론적 지식과 실용적 경험을 조화롭게 제공하여 현대 웹 개발의 도전에 잘 대비할 수 있도록 도와줍니다.\n\n알고리즘에 능숙해지거나 JavaScript를 숙달하거나 React에 몰입하거나 풀 스택을 이해하거나 웹 개발을 시작하기 위한 준비를 하고 싶다면, 이러한 강좌로 모두 가능합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n지금 등록하고 발전하는 여정을 함께 나아가요!","ogImage":{"url":"/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_0.png"},"coverImage":"/assets/img/2024-07-01-Top5FrontendMasterCoursesYouCanTakein2024_0.png","tag":["Tech"],"readingTime":9},{"title":"Claude 35와 Python으로 ReAct AI 에이전트 만드는 방법","description":"","date":"2024-07-01 16:09","slug":"2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython","content":"\n\n리즌+액트(ReAct) 에이전트들은 사고의 연쇄를 결합하고 외부 도구에 접근하며 해결책으로 나아가는 능력을 활용하여 복잡한 추론 작업을 수행할 수 있습니다.\n\n에이전트의 중요한 구성 요소는 시스템 프롬프트로, 에이전트의 전반적인 행동을 정의합니다(곧 예시를 볼 것입니다).\n\n처리 과정은 문제의 해결책을 요청하는 사용자 프롬프트로 시작됩니다. 시스템 프롬프트에 따라 에이전트는 문제에 대해 사고하고 해결에 도움이 되는 외부 도구를 적절하게 선택합니다.\n\n에이전트가 도구를 호출하고 응답을 받은 후, 더 많은 처리가 필요한지 판단합니다. 필요하다면 다시 도움을 요청할 수 있습니다. 에이전트는 문제를 해결하고 사용자에게 결과를 반환할 때까지 추론과 조치(도구 호출)를 반복합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n아래 다이어그램에서 과정이 설명되어 있습니다.\n\n\u003cimg src=\"/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png\" /\u003e\n\nReAct 에이전트의 작동 방식을 설명하는 가장 쉬운 방법은 간단한 사례 연구로 설명하는 것입니다. 아래는 간단한 산술 문제를 해결하는 에이전트의 예시 응답입니다.\n\n우리는 \"20 * 15은 무엇인가요?\" 라는 질문으로 시작해서, 그에 대한 응답으로 에이전트가 '소리내어 생각'하기 시작합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n에이전트의 응답 앞에는 '사고' 레이블이 있는데, 이는 에이전트가 어떻게 해야 하는지 고민합니다. 이 경우, 문제를 해결하기 위해 'calculate' 동작을 사용하기로 결정했습니다('calculate'는 에이전트에 제공된 도구입니다).\n\n다음 응답은 '동작' 레이블로 시작되며, 에이전트가 'calculate' 도구를 사용하여 답변을 검색하는 것을 볼 수 있습니다. 이 후에는 '관찰'이 나오는데, 이는 도구에서의 응답입니다.\n\n마지막 '답변'은 에이전트가 초기 질문과 'calculate' 도구의 출력으로부터 응답을 작성한 결과입니다.\n\n보통 이곳에서 특별하게 벌어지는 일은 없어 보이지만, 에이전트가 우리가 제공한 도구를 사용하고 있다는 점에서 조금은 특별한 점이 있습니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것이 ReAct 에이전트의 기본입니다: 에이전트는 이성을 사용하여 행동합니다.\n\n## 반복\n\n더 흥미로워지는 부분은 에이전트가 결론에 도달하지 못했다고 판단하고 다른 이성/행동 시퀀스를 거쳐야 한다는 경우입니다. 에이전트는 유효한 결론에 도달할 때까지 추론/행동 시퀀스를 반복할 수 있습니다.\n\n위의 예시는 사소하지만 기본적인 이벤트 시퀀스를 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n좀 더 복잡한 쿼리를 시도해보면 실제 반복을 볼 수 있어요.\n\n저는 다음과 같은 질문을 에이전트에게 했어요: \"농구 팀의 선수 수를 라크로스 팀의 선수 수로 곱하면 얼마가 되나요?\".\n\n이 질문에 대한 답변을 하기 위해 에이전트는 각 스포츠의 선수 수를 찾아 곱해야 해요. 곱셈을 위해 calculate 도구를 사용할 수 있지만, 농구와 라크로스에 대해 알아내기 위해서는 다른 도구가 필요해요 — 위키피디아죠. 위키피디아 도구를 사용하면 에이전트가 어떤 것이든 검색하고 결과를 얻을 수 있어요.\n\n아래에서 에이전트가 만족스러운 답변을 도출하기 전에 생각-행동-관찰 순서를 세 번 거치는 방법을 볼 수 있어요.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n만약 결과를 자세히 읽으시면 에이전트가 결과를 생성하기 전에 이유를 생각하고 도구를 상담하는 방법을 볼 수 있고, 그러면서 지식을 쌓아 가게 됩니다.\n\n# 매우 적은 양의 코드\n\nReAct 에이전트를 구현하는 데 필요한 코드는 놀랍게도 매우 적습니다. 이는 대부분의 작업이 프롬프트에서 수행되기 때문입니다.\n\n그러니까 먼저 그것을 살펴보죠.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n프롬프트는 문제에 어떻게 접근해야 하는지에 대해 설명하며, 이전에 본 과정의 레이블이 지정된 부분을 반복합니다.\n\n그런 다음 계산 및 위키피디아라는 작업이 설명되고, 예제 세션이 이어집니다.\n\n이 프롬프트는 간단한 예제이며 명확히 시연용으로만 사용됩니다. 프롬프트 설명은 도구의 사용이 하드코딩되어 있으며, 실제 제품 시스템에서는 프로그래밍 방식으로 이를 확장할 수 있어야 합니다. (곧 확인할 것이지만, calculate는 Python 함수 eval()을 사용하여 구현됩니다. 이는 코드 삽입 공격에 매우 취약한 부분이므로 매우 위험한 방법입니다.)\n\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n이 시점에서 Simon Willison의 작업을 인정해야 할 필요가 있습니다. 이 코드의 많은 부분은 Simon Willison의 작품에 기반합니다 — LLMs를 위한 ReAct 패턴의 간단한 Python 구현 참조 | Simon Willison의 TILs — 해당 코드는 Apache 2 라이선스가 있습니다.\n\n이 코드와 프롬프트의 기본 구조는 Simon의 것이지만, 저는 Anthropic의 Claude 3.5 Sonnet LLM을 사용하도록 수정하고 코드와 프롬프트를 간소화했습니다.\n\n## Claude 3.5\n\nClaude Sonnet 3.5은 Anthropic의 최근 릴리스로, 릴리스 발표에서 \"Claude 3.5 Sonnet은 인텔리전스에 대한 산업 기준을 높여 다양한 평가에서 경쟁 모델과 Claude 3 Opus보다 우월하며, 중급 모델인 Claude 3 Sonnet의 속도와 비용을 가지고 있습니다.\" 라고 설명합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그것을 맥락에 맞춰 설명하자면, Anthrop have는 저렴하고 빠른 하이쿠 모델부터 똑똑하지만 더 비싼 오퍼스까지 세 가지 버전의 Claude LLM을 보유하고 있습니다. 소넷은 그 중간 모델로서 이 글을 작성하는 시점에 버전 3.5 릴리스가 있습니다.\n\n나는 어느 때부터 Claude를 살펴보고 싶어했었는데, 이런 좋은 기회였습니다.\n\n코드는 필요한 라이브러리를 불러오는 부분으로 시작됩니다:\n\n```js\nimport anthropic\nimport re\nimport httpx\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n그 답변은 많지 않네요. LLM을 위한 추론, 정규 표현식 및 Wikipedia에 액세스할 수 있는 HTTP 라이브러리가 필요하겠네요.\n\n이 코드를 실행하려면 물론 Anthropic 계정이 필요하고 사용 요금이 부과될 거에요. 하지만 가격은 꽤 저렴하답니다: 클로드 3.5 소네는 이전 버전보다 더 강력해지면서 더 저렴해진 것 같아요 — 제가 여기서 코드를 여러 번 실행해 봤는데 수십 센트 정도만 청구받았어요.\n\n이 코드는 먼저 클라이언트를 만든 후 챗봇을 구현할 파이썬 클래스를 정의하는 방식으로 시작합니다. 오픈AI와는 달리, Claude는 시스템 프롬프트를 사용자나 어시스턴트의 것과 분리하여 ChatBot을 인스턴스화할 때 초기화합니다. `__call__` 함수는 사용자 메시지를 저장하고 챗봇의 응답을 처리하고 에이전트를 실행하는 `execute`를 호출하는 역할을 합니다.\n\n```python\nclient = anthropic.Anthropic(api_key=\"여기에 API 키를 입력하세요\")\n\nclass ChatBot:\n    def __init__(self, system=\"\"):\n        self.system = system\n        self.messages = []\n\n    def __call__(self, message):\n        self.messages.append({\"role\": \"user\", \"content\": message})\n        result = self.execute()\n        self.messages.append({\"role\": \"assistant\", \"content\": result})\n        return message\n\n    def execute(self):\n        message = client.messages.create(\n            model=\"claude-3-5-sonnet-20240620\",\n            max_tokens=1000,\n            temperature=0,\n            system=self.system,\n            messages=self.messages\n        )\n        return message.content\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음 단계는 챗봇의 인스턴스를 사용하는 query() 함수를 정의하는 것입니다. query 함수는 작업이 더 이상 없을 때까지 루프를 실행합니다(또는 최대 반복 횟수에 도달할 때까지). 이 함수는 작업을 감지하고 작업의 이름을 정규식을 사용하여 추출합니다. 작업이 호출된 후 더 이상 작업이 없는 경우, 챗봇 메시지가 반환됩니다.\n\n```js\naction_re = re.compile('^Action: (\\w+): (.*)$')\n\ndef query(question, max_turns=5):\n    i = 0\n    bot = ChatBot(prompt)\n    next_prompt = question\n    while i \u003c max_turns:\n        i += 1\n        result = bot(next_prompt)\n        print(result)\n        actions = [action_re.match(a) for a in result.split('\\n') if action_re.match(a)]\n        if actions:\n            # 실행할 작업이 있습니다\n            action, action_input = actions[0].groups()\n            if action not in known_actions:\n                raise Exception(\"Unknown action: {}: {}\".format(action, action_input))\n            print(\" -- running {} {}\".format(action, action_input))\n            observation = known_actions[action](action_input)\n            print(\"Observation:\", observation)\n            next_prompt = \"Observation: {}\".format(observation)\n        else:\n            return bot.messages\n```\n\n이제 wikipedia 및 eval과 같은 작업 함수(도구)를 정의하고 해당 함수에 대한 참조를 사전에 저장해야 합니다.\n\n```js\ndef wikipedia(q):\n    return httpx.get(\"https://en.wikipedia.org/w/api.php\", params={\n        \"action\": \"query\",\n        \"list\": \"search\",\n        \"srsearch\": q,\n        \"format\": \"json\"\n    }).json()[\"query\"][\"search\"][0][\"snippet\"]\n\ndef calculate(what):\n    return eval(what)\n\nknown_actions = {\n    \"wikipedia\": wikipedia,\n    \"calculate\": calculate\n}\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n다음은 봇이 생성한 마지막 메시지를 출력하는 유틸리티 함수입니다.\n\n```js\ndef get_last_message():\n    for m in bot.messages[-1]['content'][0].text.split('\\n'):\n        print(m)\n```\n\n그리고 그 모든 것이 끝나면 에이전트를 사용할 수 있습니다.\n\n```js\nquery(\"What is 20 * 15\")\nget_last_message()\n```\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n위의 코드는 기사 맨 위에 본 매우 첫 번째 예제에 결과를 초래하며 아래의 코드는 ReAct 에이전트가 다양한 조치를 순환하여 유효한 결론에 도달하는 방식의 또 다른 예제를 보여줍니다.\n\n에이전트가 도구에 대한 호출을 순환해야 하는 또 다른 예제가 여기 있습니다. 이 경우, 에이전트는 위키피디아만 사용하지만 답변을 도출하기 위해 응담을 지능적으로 분석해야 합니다.\n\n```js\nquery(\"스페인에서 사용되는 언어 중 프랑스에서도 사용되는 언어는 무엇인가\")\nget_last_message()\n```\n\n위의 응답은 에이전트가 적절한 답변을 도출하기 위해 거치는 합리적인 과정을 보여줍니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n저는 또한 에이전트가 잘 다루는 것으로 보이는 좀 더 복잡한 질문도 시도해 보았습니다 (다운로드 가능한 코드에 더 많은 예제를 볼 수 있습니다).\n\n## 결론\n\n여기 제시된 코드는 ReAct 에이전트가 작동하는 방식을 보여줍니다. 이 코드는 견고하지 않으며 제품용으로 적합하지 않습니다. 하지만 이제 ReAct 에이전트의 원리에 대해 어느 정도 이해하고 구현할 수 있다는 것을 바라겠습니다.\n\n더 복잡한 예제로 코드를 시도해보고, 아마도 더 많은 도구를 추가해 보세요. 여러분의 실험에 대해 알고 싶어합니다.\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n물론, Langchain과 Llamaindex를 사용한 더 간단한 해결책도 있습니다(예:). 나는 아마도 미래에 이를 다룰 것 같습니다. 그러나 이들의 추상화된 구현은 에이전트의 내부 작업을 숨기는데, 저는 이 글과 Simon의 코드가 이를 명확히 만들었다고 기대합니다.\n\n모든 코드와 예제는 내 [Github 레포지토리](GitHub — alanjones2/claudeapps)에서 확인할 수 있습니다 — 자유롭게 다운로드하십시오.\n\n더 많은 기사를 보려면, 여기 Medium에서 나를 팔로우하시거나, 가끔씩 소식지를 구독해 주세요. 이전 기사들은 내 웹페이지에 나와 있습니다.\n\n# 노트와 참고 문헌\n\n\u003c!-- ui-station 사각형 --\u003e\n\u003cins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n(adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n- Shunyu Yao 등, ReAct: 언어 모델에서 추론과 행동을 시너지적으로 결합하기, The Eleventh International Conference on Learning Representations (ICLR), 2023. (https://arxiv.org/pdf/2210.03629에서 검색, 2024년 6월 27일에 접속)\n- Simon Willison의 블로그는 여기에 있습니다.\n- 모든 이미지와 삽화는 별도로 표시되지 않는 한 저자 본인이 만들었습니다.\n\n본 기사의 버전이 여기에 게시되어 있습니다.","ogImage":{"url":"/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png"},"coverImage":"/assets/img/2024-07-01-HowtoBuildaReActAIAgentwithClaude35andPython_0.png","tag":["Tech"],"readingTime":12}],"page":"2","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"2"},"buildId":"GsgRekSb--BvxYwv9FPn6","isFallback":false,"gsp":true,"scriptLoader":[{"async":true,"src":"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4877378276818686","strategy":"lazyOnload","crossOrigin":"anonymous"}]}</script></body></html>