{"pageProps":{"post":{"title":"2024 최신 Flutter에서 Bloc 사용법 효율적인 상태 관리 가이드","description":"","date":"2024-06-22 23:16","slug":"2024-06-22-Flutter-Bloc","content":"\n\n![Bloc](/assets/img/2024-06-22-Flutter-Bloc_0.png)\n\n## Bloc이란?\n\nBloc은 '비즈니스 로직 구성 요소'의 약자로, Google에서 권장하는 패턴 중 하나입니다. 이 패턴은 비즈니스 로직을 UI로부터 분리할 수 있도록 도와줍니다. 또한 응용 프로그램에서 책임을 분리하여 쉽게 테스트 가능한 코드를 작성할 수 있는 패턴입니다. Google에서 권장하는 다른 패턴은 여기에서 확인할 수 있습니다.\n\nBloc은 세 가지 구조로 구성됩니다. 이들은 이벤트 클래스, 상태 클래스 및 Bloc 클래스입니다. 이제 이들을 좀 더 자세히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n![img](/assets/img/2024-06-22-Flutter-Bloc_1.png)\n\n1. 이벤트:\n이벤트는 응용 프로그램에서 수행하려는 작업을 나타냅니다. 연락처 응용 프로그램을 고려해보세요. 이 경우, 이벤트는 GetUsers, UpdateUser, DeleteUser 등이 될 것입니다. 이 이벤트에 대한 추상 클래스가 있으며, 다른 이벤트들은 이 추상 클래스를 상속받아 사용합니다.\n\n응용 프로그램에서 수행하려는 작업에 따라 직접 이벤트를 만들어야 합니다.\n\n2. 상태:\n상태는 응용 프로그램에서 발생할 수 있는 상황을 나타냅니다. 어떤 상황에서 무엇을 해야 할지를 결정하는 데 사용됩니다. 연락처 앱의 경우 UsersInitial, UsersLoading, UsersLoaded 및 UsersError 등이 있을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3. 블록:\nBloc 클래스를 중간 클래스로 생각할 수 있습니다. 이 클래스는 이벤트와 상태를 연결합니다. 이벤트가 트리거되면, 어떤 함수가 호출될지와 어떤 상태로 애플리케이션이 전환될지는 블록 클래스에서 결정됩니다.\n\n## 블록 사용\n\n저는 Bloc을 사용하여 프로젝트를 개발했습니다. 이 프로젝트에는 화면이 있습니다. 이 화면에서는 The Last Airbender에서 캐릭터를 무작위로 가져올 수 있습니다. 저는 Clean Architecture로 프로젝트를 개발했지만, 이 이야기에서는 블록의 사용법만 설명합니다. Clean Architecture에 대한 자세한 내용은 여기에서 읽을 수 있습니다. 프로젝트 개발 중에는 The Last Airbender API를 사용했습니다.\n\n## 예제 채우기\n\n<div class=\"content-ad\"></div>\n\n먼저 코어, 구성 및 기능 폴더를 생성했습니다. 그런 다음 fetch characters의 기능을 위해 features 폴더 내에 characters 폴더를 만들었습니다. 마지막으로 characters 폴더 내에 데이터, 도메인 및 프리젠테이션 폴더를 생성했습니다.\n기능 폴더에 bloc 폴더를 만들었습니다. 이는 Bloc이 애플리케이션의 비즈니스 로직에 사용되기 때문입니다.\n\nBloc의 세 부분인 이벤트, 상태 및 bloc 파일을 추가했습니다.\n\n![2024-06-22-Flutter-Bloc_2.png](/assets/img/2024-06-22-Flutter-Bloc_2.png)\n\n## 코드 예시\n\n<div class=\"content-ad\"></div>\n\n먼저, 제가 CharactersInitial, CharactersLoading, CharactersError 및 CharactersLoaded 상태를 결정했고 CharactersState를 추상 클래스로 만들었습니다. 그런 다음 다른 상태에 CharactersState에서 상속을 제공했습니다.\n\n```js\npart of 'characters_bloc.dart';\n\nabstract class CharactersState {}\n\nclass CharactersInitial extends CharactersState {}\n\nclass CharactersLoading extends CharactersState {}\n\nclass CharactersLoaded extends CharactersState {\n  CharacterEntity character;\n  CharactersLoaded({required this.character});\n}\n\nclass CharactersError extends CharactersState {\n  String? errorMessage;\n  CharactersError(this.errorMessage);\n}\n```\n\n둘째로, 이벤트를 위한 추상 클래스를 만들었습니다. 이 어플리케이션에서는 캐릭터만 가져올 것이기 때문에 GetCharacter 이벤트만 생성했습니다. 그리고 CharactersEvent 클래스에서 GetCharacters 클래스로 상속을 제공했습니다.\n\n```js\npart of 'characters_bloc.dart';\n\nabstract class CharactersEvent {}\n\nclass GetCharacters extends CharactersEvent {}\n```\n\n<div class=\"content-ad\"></div>\n\nBloc으로부터 CharactersBloc으로 상속을 받았고, 클래스의 생성자 메서드에 이벤트를 추가했습니다. 그런 다음 데이터를 가져오기 위해 getCharacters 함수를 만들었습니다. 이 함수에서 API 결과에 따라 상황을 트리거했습니다.\n\n```js\npart 'characters_event.dart';\npart 'characters_state.dart';\n\nclass CharactersBloc extends Bloc<CharactersEvent,CharactersState> {\n   final GetCharacterUseCase _getCharactersUseCase;\n   CharactersBloc(this._getCharactersUseCase) : super(CharactersInitial()){\n     on<GetCharacters>(getCharacters);\n   }\n\n\n   Future<void> getCharacters(GetCharacters event, Emitter<CharactersState> emit) async {\n     emit(CharactersLoading());\n     final dataState = await _getCharactersUseCase.call(null);\n     if(dataState is DataSuccess){\n       emit(CharactersLoaded(character: dataState.data!));\n     } else if(dataState is DataFailed){\n       emit(CharactersError(dataState.exception!.message));\n     }\n   }\n}\n```\n\n마지막으로 CharactersPage를 작성했습니다. 상태를 감시하기 위해 BlocBuilder를 사용했습니다. 이것은 상태가 변경되었을 때 관련 함수를 반환할 수 있기 때문입니다.\n\n```js\n_buildBloc() {\n    return BlocBuilder(\n      bloc: _bloc,\n      builder: (BuildContext context, state) {\n        if(state is CharactersLoading){\n          return _showLoadingAnimation();\n        } else if(state is CharactersLoaded){\n          return _buildCharactersList(state);\n        } else if(state is CharactersError){\n          return _buildErrorView(state);\n        } else {\n          return _buildInitialView();\n        }\n      },\n    );\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n화면이 로드되면 GetCharacters 이벤트를 트리거합니다.\n\n```dart\n@override\nvoid initState() {\n  super.initState();\n  _bloc.add(GetCharacters());\n}\n```\n\n자세히 살펴보고 싶다면 GitHub 링크를 여기에서 찾을 수 있어요.\n\n😊 읽어 주셔서 감사합니다 😊","ogImage":{"url":"/assets/img/2024-06-22-Flutter-Bloc_0.png"},"coverImage":"/assets/img/2024-06-22-Flutter-Bloc_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-22-Flutter-Bloc_0.png\" alt=\"Bloc\"></p>\n<h2>Bloc이란?</h2>\n<p>Bloc은 '비즈니스 로직 구성 요소'의 약자로, Google에서 권장하는 패턴 중 하나입니다. 이 패턴은 비즈니스 로직을 UI로부터 분리할 수 있도록 도와줍니다. 또한 응용 프로그램에서 책임을 분리하여 쉽게 테스트 가능한 코드를 작성할 수 있는 패턴입니다. Google에서 권장하는 다른 패턴은 여기에서 확인할 수 있습니다.</p>\n<p>Bloc은 세 가지 구조로 구성됩니다. 이들은 이벤트 클래스, 상태 클래스 및 Bloc 클래스입니다. 이제 이들을 좀 더 자세히 살펴보겠습니다.</p>\n<p><img src=\"/assets/img/2024-06-22-Flutter-Bloc_1.png\" alt=\"img\"></p>\n<ol>\n<li>이벤트:\n이벤트는 응용 프로그램에서 수행하려는 작업을 나타냅니다. 연락처 응용 프로그램을 고려해보세요. 이 경우, 이벤트는 GetUsers, UpdateUser, DeleteUser 등이 될 것입니다. 이 이벤트에 대한 추상 클래스가 있으며, 다른 이벤트들은 이 추상 클래스를 상속받아 사용합니다.</li>\n</ol>\n<p>응용 프로그램에서 수행하려는 작업에 따라 직접 이벤트를 만들어야 합니다.</p>\n<ol start=\"2\">\n<li>상태:\n상태는 응용 프로그램에서 발생할 수 있는 상황을 나타냅니다. 어떤 상황에서 무엇을 해야 할지를 결정하는 데 사용됩니다. 연락처 앱의 경우 UsersInitial, UsersLoading, UsersLoaded 및 UsersError 등이 있을 수 있습니다.</li>\n</ol>\n<ol start=\"3\">\n<li>블록:\nBloc 클래스를 중간 클래스로 생각할 수 있습니다. 이 클래스는 이벤트와 상태를 연결합니다. 이벤트가 트리거되면, 어떤 함수가 호출될지와 어떤 상태로 애플리케이션이 전환될지는 블록 클래스에서 결정됩니다.</li>\n</ol>\n<h2>블록 사용</h2>\n<p>저는 Bloc을 사용하여 프로젝트를 개발했습니다. 이 프로젝트에는 화면이 있습니다. 이 화면에서는 The Last Airbender에서 캐릭터를 무작위로 가져올 수 있습니다. 저는 Clean Architecture로 프로젝트를 개발했지만, 이 이야기에서는 블록의 사용법만 설명합니다. Clean Architecture에 대한 자세한 내용은 여기에서 읽을 수 있습니다. 프로젝트 개발 중에는 The Last Airbender API를 사용했습니다.</p>\n<h2>예제 채우기</h2>\n<p>먼저 코어, 구성 및 기능 폴더를 생성했습니다. 그런 다음 fetch characters의 기능을 위해 features 폴더 내에 characters 폴더를 만들었습니다. 마지막으로 characters 폴더 내에 데이터, 도메인 및 프리젠테이션 폴더를 생성했습니다.\n기능 폴더에 bloc 폴더를 만들었습니다. 이는 Bloc이 애플리케이션의 비즈니스 로직에 사용되기 때문입니다.</p>\n<p>Bloc의 세 부분인 이벤트, 상태 및 bloc 파일을 추가했습니다.</p>\n<p><img src=\"/assets/img/2024-06-22-Flutter-Bloc_2.png\" alt=\"2024-06-22-Flutter-Bloc_2.png\"></p>\n<h2>코드 예시</h2>\n<p>먼저, 제가 CharactersInitial, CharactersLoading, CharactersError 및 CharactersLoaded 상태를 결정했고 CharactersState를 추상 클래스로 만들었습니다. 그런 다음 다른 상태에 CharactersState에서 상속을 제공했습니다.</p>\n<pre><code class=\"hljs language-js\">part <span class=\"hljs-keyword\">of</span> <span class=\"hljs-string\">'characters_bloc.dart'</span>;\n\nabstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CharactersState</span> {}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CharactersInitial</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">CharactersState</span> {}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CharactersLoading</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">CharactersState</span> {}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CharactersLoaded</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">CharactersState</span> {\n  <span class=\"hljs-title class_\">CharacterEntity</span> character;\n  <span class=\"hljs-title class_\">CharactersLoaded</span>({required <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">character</span>});\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CharactersError</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">CharactersState</span> {\n  <span class=\"hljs-title class_\">String</span>? errorMessage;\n  <span class=\"hljs-title class_\">CharactersError</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">errorMessage</span>);\n}\n</code></pre>\n<p>둘째로, 이벤트를 위한 추상 클래스를 만들었습니다. 이 어플리케이션에서는 캐릭터만 가져올 것이기 때문에 GetCharacter 이벤트만 생성했습니다. 그리고 CharactersEvent 클래스에서 GetCharacters 클래스로 상속을 제공했습니다.</p>\n<pre><code class=\"hljs language-js\">part <span class=\"hljs-keyword\">of</span> <span class=\"hljs-string\">'characters_bloc.dart'</span>;\n\nabstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CharactersEvent</span> {}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GetCharacters</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">CharactersEvent</span> {}\n</code></pre>\n<p>Bloc으로부터 CharactersBloc으로 상속을 받았고, 클래스의 생성자 메서드에 이벤트를 추가했습니다. 그런 다음 데이터를 가져오기 위해 getCharacters 함수를 만들었습니다. 이 함수에서 API 결과에 따라 상황을 트리거했습니다.</p>\n<pre><code class=\"hljs language-js\">part <span class=\"hljs-string\">'characters_event.dart'</span>;\npart <span class=\"hljs-string\">'characters_state.dart'</span>;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CharactersBloc</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Bloc</span>&#x3C;<span class=\"hljs-title class_\">CharactersEvent</span>,<span class=\"hljs-title class_\">CharactersState</span>> {\n   final <span class=\"hljs-title class_\">GetCharacterUseCase</span> _getCharactersUseCase;\n   <span class=\"hljs-title class_\">CharactersBloc</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_getCharactersUseCase</span>) : <span class=\"hljs-title function_\">super</span>(<span class=\"hljs-params\">CharactersInitial()</span>){\n     on&#x3C;<span class=\"hljs-title class_\">GetCharacters</span>>(getCharacters);\n   }\n\n\n   <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-keyword\">void</span>> <span class=\"hljs-title function_\">getCharacters</span>(<span class=\"hljs-title class_\">GetCharacters</span> event, <span class=\"hljs-title class_\">Emitter</span>&#x3C;<span class=\"hljs-title class_\">CharactersState</span>> emit) <span class=\"hljs-keyword\">async</span> {\n     <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-title class_\">CharactersLoading</span>());\n     final dataState = <span class=\"hljs-keyword\">await</span> _getCharactersUseCase.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-literal\">null</span>);\n     <span class=\"hljs-keyword\">if</span>(dataState is <span class=\"hljs-title class_\">DataSuccess</span>){\n       <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-title class_\">CharactersLoaded</span>(<span class=\"hljs-attr\">character</span>: dataState.<span class=\"hljs-property\">data</span>!));\n     } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(dataState is <span class=\"hljs-title class_\">DataFailed</span>){\n       <span class=\"hljs-title function_\">emit</span>(<span class=\"hljs-title class_\">CharactersError</span>(dataState.<span class=\"hljs-property\">exception</span>!.<span class=\"hljs-property\">message</span>));\n     }\n   }\n}\n</code></pre>\n<p>마지막으로 CharactersPage를 작성했습니다. 상태를 감시하기 위해 BlocBuilder를 사용했습니다. 이것은 상태가 변경되었을 때 관련 함수를 반환할 수 있기 때문입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">_buildBloc</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">BlocBuilder</span>(\n      <span class=\"hljs-attr\">bloc</span>: _bloc,\n      <span class=\"hljs-attr\">builder</span>: (<span class=\"hljs-title class_\">BuildContext</span> context, state) {\n        <span class=\"hljs-keyword\">if</span>(state is <span class=\"hljs-title class_\">CharactersLoading</span>){\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_showLoadingAnimation</span>();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(state is <span class=\"hljs-title class_\">CharactersLoaded</span>){\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_buildCharactersList</span>(state);\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(state is <span class=\"hljs-title class_\">CharactersError</span>){\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_buildErrorView</span>(state);\n        } <span class=\"hljs-keyword\">else</span> {\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">_buildInitialView</span>();\n        }\n      },\n    );\n  }\n</code></pre>\n<p>화면이 로드되면 GetCharacters 이벤트를 트리거합니다.</p>\n<pre><code class=\"hljs language-dart\"><span class=\"hljs-meta\">@override</span>\n<span class=\"hljs-keyword\">void</span> initState() {\n  <span class=\"hljs-keyword\">super</span>.initState();\n  _bloc.add(GetCharacters());\n}\n</code></pre>\n<p>자세히 살펴보고 싶다면 GitHub 링크를 여기에서 찾을 수 있어요.</p>\n<p>😊 읽어 주셔서 감사합니다 😊</p>\n</body>\n</html>\n"},"__N_SSG":true}