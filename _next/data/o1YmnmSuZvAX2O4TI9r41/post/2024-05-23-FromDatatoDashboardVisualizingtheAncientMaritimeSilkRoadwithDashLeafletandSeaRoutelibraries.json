{"pageProps":{"post":{"title":"데이터부터 대시보드까지 Dash Leaflet 및 SeaRoute 라이브러리를 사용해 고대 해상 실크로드 시각화하기","description":"","date":"2024-05-23 15:29","slug":"2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries","content":"\n\n![img](/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_0.png)\n\n저의 박사학위 중 어려운 부분 중 하나는 선박의 해양 노선을 보여주는 대화형 지도 시각화물을 만드는 것이었습니다. 출발지와 도착지 항구 사이의 선박 노선은 육 지역을 건너가지 않고 오직 바다 상에서의 경로여야 했습니다. 이중 seemingly straightforward 였던 작업이 파이썬에서 처음부터 구현하려고 시도할 때 상당히 어려움이 있었습니다 🤷‍♀️. 유사한 작업을 수행할 수 있는 상용 솔루션이 Marine Traffic과 같이 있지만, 저는 오랜 시간 동안 찾을 수 없는 오픈 소스 대안을 찾고 있었습니다. 마침내 2022년 말에 SeaRoute 라이브러리가 Python을 위해 출시되었고(이전에는 Java만 지원되고 있었음), 그로 인해 제 삶이 훨씬 수월해졌습니다. 이 기사에서는 Dash 앱을 위한 대화형 지도 시각화물을 만드는 과정을 안내하겠습니다. Dash Leaflet 및 SeaRoute Python 라이브러리를 사용하여 해상 경로를 표시할 수 있도록 할 것입니다.\n\n# Dash, Dash Leaflet, SeaRoute에 대해 어떻게 생각하시나요?\n\nDash는 React.js를 기반으로 만들어진 강력한 Python 프레임워크로, Python의 모든 계산 능력을 통합하고 있습니다. Dash가 무엇이며 무엇을 할 수 있는지, 어떻게 첫 번째 Dash 앱을 만들고 실행할 수 있는지에 대한 간단한 소개는 이전에 작성한 포스트를 참조해 보세요. Dash에 새로 오신 분이라면, 먼저 이것을 읽어보는 것을 추천합니다...\n\n<div class=\"content-ad\"></div>\n\n이 게시물에서는 고대 해상 실크로드 경로를 예시로 사용하여 Dash Leaflet 라이브러리와 SeaRoute 라이브러리의 사용을 소개하겠습니다.\n\nDash Leaflet은 상호작용하는 Leaflet 스타일 지도를 Dash 앱에 통합할 수 있는 포꺠 갑을 제공하는 넓은 범위의 지도 시각화 Python 라이브러리입니다. Dash 생태계 내에서 Leaflet.js의 래퍼로, 마커, 다각형, 팝업, 레이어 등과 같은 다양한 기능을 갖춘 지도를 만들고 사용자 정의할 수 있는 구성 요소를 제공합니다.\n\nSeaRoute는 해상에서 점 간 경로를 계산하는 Python 라이브러리로, 예를 들어 휴스턴과 로테르담 항구 사이의 경로를 계산할 수 있습니다. Python에서 이를 처음부터 계산하려면 해양 지역을 나타내는 해양 형상 파일(예: 해상 국경)을 얻고 지도상에 그린 후 출발점과 도착점 사이의 땅정 경로를 계산하여 해당 해양 지역만 횡단하도록 제약을 설정해야 합니다. 이는 넉넉히 말해 매우 복잡한 작업인데, 각 나라마다 자체 데이터를 다른 형식과 소스로 제공하는 등, 통일되고 표준적인 데이터 소스가 아직 존재하지 않기 때문입니다. 시각화만을 위해 이러한 작업을 해야 한다는 것이 좀 과한 것 같죠. 그렇다면 아름다운 지도 시각화가 필요한 여성은 이번 생애에서 어떻게 해결해야 할까요😠? 다행히 2022년 말에 SeaRoute 라이브러리가 출시되며 시같에 경로를 쉽게 계산하여 시같화할 수 있는 문제를 해결했습니다. 아래 지도에서도 확인할 수 있습니다😇.\n\n따라서 이 게시물의 나머지 부분에서는:\n\n<div class=\"content-ad\"></div>\n\n- SeaRoute를 사용하여 바다 상의 두 지점 사이의 경로 좌표를 계산하세요.\n- Dash Leaflet을 사용하여 지도상에 경로를 시각화하세요.\n- 모든 것을 Dash 앱으로 묶어보세요.\n\n일단 시작해봐요! 🤸‍♀️️\n\n# 해상 실크로드에 대해서 어떻게 생각하세요?\n\n<div class=\"content-ad\"></div>\n\n해양 실크로드는 고대 시대에 아시아, 아프리카 및 유럽 대륙 간 다양한 문명을 연결한 중요한 해상 무역로였습니다. 이것은 더 넓고 잘 알려진 실크로드 네트워크의 연장선으로, 육지 및 해상 노선을 포함하며 동서양 간 무역, 문화 교류 및 아이디어 및 기술의 전파를 용이하게 했습니다.\n\n중국의 한나라 시대(기원전 206년 ~ 서기 220년)에 시작된 해양 실크로드는 통(618~907년)과 송(960~1279년) 시대에 절정에 이르렀습니다. 남중국해와 인도양을 건너는 중국 선원들은 동남아시아, 인도, 아라비아 반도, 동아프리카 등지의 상인들과 실크, 도자기, 차 등과 같은 상품을 거래했습니다. 그에 대한 보답으로 중국은 향신료, 귀금속, 보석, 이국적인 상품을 수입함으로써 문화와 경제를 발전시켰습니다. 해양 실크로드의 쇠퇴는 14세기경 즈음에 시작되어 해상 무역로가 변화하고 새로운 무역 경로가 나타남에 따라 17세기에는 전통적인 실크로드와 해양 실크로드의 경로가 대부분 사라지며 유럽의 지배력으로 새로운 세계 무역로들이 등장했습니다.\n\n해양 실크로드를 따라가는 몇 가지 대표적인 경로 (이후 이 게시물의 나머지 부분에서 지도로 시각화할 예정)는 다음과 같습니다:\n\n- Quanzhou ` Malacca ` Calicut ` Aden ` Alexandria\n- Guangzhou ` Manila ` Brunei ` Surabaya ` Jakarta ` Singapore\n- Hangzhou ` Ningbo ` Nagasaki ` Busan ` Hakata ` Osaka\n- Guangzhou ` Hanoi ` Da Nang ` Singapore ` Colombo ` Muscat\n- Xiamen ` Taiwan ` Okinawa ` Yokohama ` Kobe ` Nagasaki ` Busan\n\n<div class=\"content-ad\"></div>\n\n해양로 라이브러리는 여러 가지 흥미로운 계산을 제공합니다. 예를 들어, 루트의 길이나 주어진 속도로 여행하는 데 걸리는 시간을 계산할 수 있습니다. 이번 포스트에서는 중국 존크(해양 실크로드 시대에 널리 사용된 선박 종류)가 평균 5 노트의 속도로 항해했다고 가정해 봅시다.\n\n![image](/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_1.png)\n\n# 대시 앱 구축\n\n## 환경 설정\n\n<div class=\"content-ad\"></div>\n\n먼저 모든 것에 앞서, 필요한 라이브러리가 설치되어 있는지 확인해야 합니다. 이러한 라이브러리는 Dash, Dash-Leaflet 및 SeaRoute이며, pip를 사용하여 쉽게 설치할 수 있습니다:\n\n```js\npip install dash dash-leaflet searoute\n```\n\n그런 다음, 다음과 같이 가져올 수 있습니다:\n\n```js\nimport dash\nfrom dash import dcc, html\nimport dash_leaflet as dl\nfrom dash.dependencies import Input, Output\nfrom searoute import SeaRoute\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로, 간단히 Dash 앱의 빈 인스턴스를 초기화할 수 있습니다:\n\n```js\napp = dash.Dash(__name__)\n```\n\n일반적으로, Dash 앱은 두 가지 주요 구성 요소로 구성됩니다: 레이아웃(layout)과 콜백(callbacks). 레이아웃 구성 요소는 앱의 시각적 및 구조적 부분을 정의하며, 콜백 구성 요소는 앱의 상호 작용을 설명합니다. 그러나 앱의 레이아웃에 더 들어가기 전에 요구되는 데이터가 사용 가능한지 확인해야 합니다.\n\n## 데이터 가져오기\n\n<div class=\"content-ad\"></div>\n\n먼저, 해상 실크로드의 일부 지표적인 항구 및 해당 좌표, 간단한 설명을 담은 표를 작성했어요. 항구 좌표는 추정치이며 OpenStreetMap에서 가져온 것이며, 오픈 데이터베이스 라이선스(ODbL)를 따라 사용되었습니다.\n\n<img src=\"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_2.png\" />\n\n```js\nimport pandas as pd\n\n# 항구, 좌표 및 설명을 포함하는 표 작성\nports_data = {\n    '항구': ['아덴', '알렉산드리아', '브루나이', '부산', '칼리컷',\n            '콜롬보', '다낭', '광저우', '하카타', '항저우',\n             '하노이', '자카르타', '고베', '말라카', '마닐라',\n             '무스카트', '나가사키', '닝보', '오키나와', '오사카',\n             '전주', '싱가포르', '수라바야', '대만', '시안멘', '요코하마'],\n    '국가': ['예멘', '이집트', '브루나이', '대한민국', '인도',\n                '스리랑카', '베트남', '중국', '일본', '중국',\n                '베트남', '인도네시아', '일본', '말레이시아', '필리핀',\n                '오만', '일본', '중국', '일본', '일본',\n                '중국', '싱가폴', '인도네시아', '대만', '중국', '일본'],\n    '위도': [12.799, 31.2001, 4.5353, 35.1796, 11.2588,\n                 6.9271, 16.0544, 23.1291, 33.5904, 30.2741,\n                 21.0285, -6.2088, 34.6901, 2.1896, 14.5995,\n                 23.6102, 32.7467, 29.8683, 26.2041, 34.6937,\n                 24.8798, 1.3521, -7.2575, 23.6978, 24.4798, 35.4437],\n    '경도': [45.0289, 29.9187, 114.7277, 129.0756, 75.7804,\n                  79.8612, 108.2022, 113.2644, 130.4017, 120.1551,\n                  105.8542, 106.8456, 135.1955, 102.2501, 120.9842,\n                  58.5922, 129.8734, 121.544, 127.6476, 135.5023,\n                  118.5876, 103.8198, 112.7521, 120.9605, 118.0894, 139.638],\n    '설명': ['붉은해 상거래 경로의 중요한 중심지', '지중해 주요 항구, 유럽과의 연결', '향균판매의 주요 중지점, 이슬람 영향', '실크로드에 대한 한국의 관문', '번성한 무역 중심지, 향신료 무역의 중심',\n                    '인도양 무역로의 주요 항구', '잠바 왕조 시기 중요한 항구', '고대 중국 무역 항구, 산동이라 불림', '실크로드 무역에 중요한 일본의 항구', '대운하의 끝, 실크 생산 중심지',\n                    '베트남의 수도, 고대 무역 도시', '인도네시아의 수도, 자바의 주요 항구', '중요한 일본의 항구, 교토로 향하는 관문', '전략적인 해협, 무역의 십자로', '아시아에서 스페인 무역의 중심지',\n                    '중요한 아라비아 해상 무역 기지', '세계로 향하는 일본의 관문, 네덜란드 무역의 중심', '주요 해상 항구, 중국 무역에 필수', '동아시아 무역로의 중요한 경유지', '일본의 주요항구, 역사적 무역 중심지',\n                    '중국의 주요 항구, 주요 무역 중심지', '전략적인 해협, 주요 무역 기지', '자바의 중요한 항구, 인도네시아 무역에 중요', '해상 무역용 섬 중간지점', '중국의 역사적 항구, 후난으로가는 관문', '외국무역에 개방된 주요 일본의 항구']\n}\n\nports = pd.DataFrame(ports_data)\n```\n\n그 위에, 지도에서 시각화하고 싶은 일부 지표적인 경로(항구 순서)를 정의하고 그것을 DataFrame에 저장합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nroute_1 = ['Quanzhou','Malacca','Calicut','Aden','Alexandria']\r\nroute_2 = ['Guangzhou','Manila','Brunei','Surabaya','Jakarta','Singapore']\r\nroute_3 = ['Hangzhou','Ningbo','Nagasaki','Busan','Hakata','Osaka']\r\nroute_4 = ['Guangzhou','Hanoi','Da Nang','Singapore','Colombo','Muscat']\r\nroute_5 = ['Xiamen','Taiwan','Okinawa','Yokohama','Kobe','Nagasaki','Busan']\r\n\r\nroutes = pd.DataFrame({\r\n    'Route': ['route_1', 'route_2', 'route_3', 'route_4', 'route_5'],\r\n    'Port_Sequence': [route_1, route_2, route_3, route_4, route_5]\r\n})\r\n```\r\n\r\n## 경로 계산\r\n\r\n필요한 계산을 수행하기 위해 일반적인 route_var 변수를 가정하고, 이 경로에 포함된 각 항구의 이름과 좌표를 DataFrame으로 구조화합니다. 보다 구체적으로, 이 코드는 주어진 경로의 각 항구를 반복하고 그들의 좌표 및 설명을 검색합니다.\r\n\r\n```js\r\nroute_rows = [] \r\n\r\nfor port in route_var: # 경로에 있는 항구를 반복하면서\r\n  port_name = port\r\n  lat = ports.loc[ports['Port'] == port, 'Latitude'].iloc[0]\r\n  lon = ports.loc[ports['Port'] == port, 'Longitude'].iloc[0]\r\n  row = {'Port': port_name, 'lat': lat, 'lon': lon}\r\n  route_rows.append(row)\r\n\r\nroute_df = pd.concat([pd.DataFrame(row, index=[0]) for row in route_rows], ignore_index=True)\r\n```\n\n<div class=\"content-ad\"></div>\n\n지도 시각화를 시작하려면 Dash-Leaflet 라이브러리의 dl.Marker(), dl.Tooltip 및 dl.LayerGroup() 구성 요소를 사용하여 포트를 마커로 시각화하기 위한 지도 객체를 쉽게 생성할 수 있습니다.\n\n```js\n    # 계산된 포트 마커에서 지도 객체 생성\n    markers = []\n    for i in range(len(route_df)):\n        # 각 포트 마커에 대한 툴팁 생성\n        tooltip = route_df.loc[i, 'Port'] + ', ' + ports.loc[ports['Port'] == route_df.loc[i, 'Port'], 'Description'].iloc[0]\n        markers.append(  # 마커 계산\n            dl.Marker(\n                position=(route_df.loc[i, 'lat'], route_df.loc[i, 'lon']),\n                children=[dl.Tooltip(tooltip)]\n            )\n        )\n    cluster = dl.LayerGroup(children=markers)\n```\n\n이 방법을 사용하면 선택한 경로의 각 포트에 대해 dl.Marker()를 사용하여 마커를 생성하고 dl.Tooltip()을 사용하여 툴팁을 만듭니다. 그런 다음 dl.LayerGroup()를 사용하여 이러한 마커를 단일 레이어 그룹으로 그룹화합니다. LayerGroup() 구성 요소는 여러 지도 요소(마커 등)를 단일 레이어로 그룹화하는 데 사용됩니다. 이를 통해 이러한 요소를 함께 관리하고 제어할 수 있습니다. 예를 들어, 사용자가 한 번의 동작으로 모든 마커를 표시하거나 숨길 수 있으며, 마커를 하나씩 선택하는 대신 모두 선택할 수 있습니다.\n\n바다에서의 경로 계산으로 넘어가면, 아래와 같이 SeaRoute 라이브러리를 사용하여 이를 달성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\n# 바다에서 경로 계산하기\nmarkers_line = []\nlength = 0\nduration_hours = 0\nfor i in range(0, len(route_df) - 1):\n    origin = [route_df.loc[i, 'lon'], route_df.loc[i, 'lat']]\n    destination = [route_df.loc[i+1, 'lon'], route_df.loc[i+1, 'lat']]\n    searoutes_coords = sr.searoute(origin, destination, append_orig_dest=True, speed_knot=2)\n    searoutes_coords_transposed = [[coord[1], coord[0]] for coord in searoutes_coords['geometry']['coordinates']]\n    markers_line += searoutes_coords_transposed\n   \n    length += searoutes_coords['properties']['length']\n    duration_hours += searoutes_coords['properties']['duration_hours']\nduration_days = duration_hours / 24\r\n```\n\n이전에 언급했듯이 SeaRoute 라이브러리를 사용하면 경로 거리와 항해 시간을 계산하는 것과 같은 추가 속성을 계산할 수 있습니다. 여기에서 속도가 sr.searoute() 함수에서 speed_knot = 5로 정의된 것을 확인하세요.\n\nSeaRoute로 맵 좌표를 계산한 후 dl.Polyline() 구성 요소를 사용하여 맵에 시각화할 수 있습니다. 또한 dl.PolylineDecorator() 구성 요소를 사용하여 선 방향을 나타내는 화살표를 추가할 수 있습니다. patterns 변수에서 간단한 화살표를 직접 정의합니다.\n\n```js\r\n# 계산된 바다 경로용 맵 객체 생성\nline = dl.Polyline(\n    positions=markers_line,\n    smoothFactor=1.0,\n    color='ForestGreen',\n    weight=1,\n    lineCap='round',\n    lineJoin='round'\n)\npatterns = [dict(offset='5%', repeat='30px', endOffset='10%', arrowHead=dict(pixelSize=8, polygon=False, pathOptions=dict(stroke=True, color='ForestGreen', weight=1, opacity=10, smoothFactor=1)))]\ndline = dl.PolylineDecorator(children=line, patterns=patterns)\r\n```\n\n<div class=\"content-ad\"></div>\n\n또한, 각 선택된 노선마다 지도의 중심과 영역을 다시 계산하는 것이 적절하다고 생각했습니다. 이렇게 하면 사용자가 선택한 각 노선마다 지도가 다시 초점을 맞춰서, 마커와 선이 적절하게 표시됩니다.\n\n```js\n# 경계 계산\nmin_lat = min(lat for lat, lon in markers_line) - 2\nmax_lat = max(lat for lat, lon in markers_line) + 2\nmin_lon = min(lon for lat, lon in markers_line) - 2\nmax_lon = max(lon for lat, lon in markers_line) + 2\nbounds = [[min_lat, min_lon], [max_lat, max_lon]]\n\n# 중심 계산\nx, y = zip(*markers_line)\ncentroid = [sum(x) / len(x), sum(y) / len(y)]\r\n```\n\n마지막으로, 이러한 요소들을 하나의 함수로 묶어 보겠습니다.\n\n```js\n# 노선 포트의 해상 경로 지도 마커 및 경로 계산 함수 정의\ndef get_route_line(route_var):\n    \n    route_rows = [] \n    for port in route_var: # 노선 내 포트를 반복\n        port_name = port\n        lat = ports.loc[ports['Port'] == port, 'Latitude'].iloc[0]\n        lon = ports.loc[ports['Port'] == port, 'Longitude'].iloc[0]\n        row = {'Port': port_name, 'lat': lat, 'lon': lon}\n        route_rows.append(row)\n   \n    route_df = pd.concat([pd.DataFrame(row, index=[0]) for row in route_rows], ignore_index=True)\n   \n    # 계산된 포트 마커에서 맵 개체 생성\n    markers = []\n    for i in range(len(route_df)):\n        # 각 포트 마커에 대한 툴팁 생성\n        tooltip = route_df.loc[i, 'Port'] + ', ' + ports.loc[ports['Port'] == route_df.loc[i, 'Port'], 'Description'].iloc[0]\n        markers.append(  # 마커 계산\n            dl.Marker(\n                position=(route_df.loc[i, 'lat'], route_df.loc[i, 'lon']),\n                children=[dl.Tooltip(tooltip)]\n            )\n        )\n    cluster = dl.LayerGroup(children=markers)\n   \n    # 해상 경로 계산\n    markers_line = []\n    length = 0\n    duration_hours = 0\n    for i in range(0, len(route_df) - 1):\n        origin = [route_df.loc[i, 'lon'], route_df.loc[i, 'lat']]\n        destination = [route_df.loc[i+1, 'lon'], route_df.loc[i+1, 'lat']]\n        searoutes_coords = sr.searoute(origin, destination, append_orig_dest=True, speed_knot=2)\n        searoutes_coords_transposed = [[coord[1], coord[0]] for coord in searoutes_coords['geometry']['coordinates']]\n        markers_line += searoutes_coords_transposed\n       \n        length += searoutes_coords['properties']['length']\n        duration_hours += searoutes_coords['properties']['duration_hours']\n    duration_days = duration_hours / 24\n\n    # 계산된 해상 경로를 위한 맵 개체 생성\n    line = dl.Polyline(\n        positions=markers_line,\n        smoothFactor=1.0,\n        color='ForestGreen',\n        weight=1,\n        lineCap='round',\n        lineJoin='round'\n    )\n    patterns = [dict(offset='5%', repeat='30px', endOffset='10%', arrowHead=dict(pixelSize=8, polygon=False, pathOptions=dict(stroke=True, color='ForestGreen', weight=1, opacity=10, smoothFactor=1)))]\n    dline = dl.PolylineDecorator(children=line, patterns=patterns)\n    \n    # 경계 계산\n    min_lat = min(lat for lat, lon in markers_line) - 2\n    max_lat = max(lat for lat, lon in markers_line) + 2\n    min_lon = min(lon for lat, lon in markers_line) - 2\n    max_lon = max(lon for lat, lon in markers_line) + 2\n    bounds = [[min_lat, min_lon], [max_lat, max_lon]]\n    \n    # 중심 계산\n    x, y = zip(*markers_line)\n    centroid = [sum(x) / len(x), sum(y) / len(y)]\n\n    return cluster, dline, centroid, bounds, duration_days\r\n```\n\n따라서, 모든 계산은 두 개의 함수로 처리됩니다: \n\n\n<div class=\"content-ad\"></div>\n\n## 레이아웃 생성\n\nget_route_line() 함수를 정의한 후, 이제 앱의 레이아웃 컴포넌트를 구성할 차례입니다. 아래 이미지와 유사한 레이아웃을 만들려고 합니다:\n\n![이미지](/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_3.png)\n\n구체적으로는 다음 사항을 통합하고 싶습니다:\n\n<div class=\"content-ad\"></div>\n\n- 루트 선택 컨테이너는 루트를 선택할 수있는 드롭다운 메뉴와 선택한 루트, 가정된 선박 속도, 그리고 예상 항해 기간과 같은 각 루트에 대한 정보를 표시합니다.\n- 선택한 루트의 항구 및 해당 해상 경로를 표시하는 지도 시각화가 있습니다.\n\n드롭다운 패널은 다음과 같이 정의할 수 있습니다:\n\n```js\n# 드롭다운 및 루트 정보를 위한 왼쪽 패널\n    html.Div([\n        html.H1('고대 해상 실크로드'),\n        html.Div([\n            dcc.Dropdown(\n                id='route_dropdown',\n                options=[{'label': route, 'value': route} for route in routes['Route']],\n                placeholder='루트 선택'\n            )\n        ], style={'display': 'block', 'height': '30%', 'justify-content': 'center', 'color': 'gray'}),\n        html.Div(id='route_info', style={'height': '100%'})\n    ], style={'display': 'inline-block', 'height': '100%', 'width': '15%', 'background-color': '#17408B', 'color': 'white', 'padding': '2%', 'position': 'relative'}),\n```\n\n더 구체적으로, 드롭다운 메뉴는 이전에 정의한 routes DataFrame에 의해 채워집니다. 또한, 루트 정보 패널은 초기에 비어 있고 드롭다운 메뉴에서 루트를 선택하면 콜백을 통해 채워질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n지도 시각화에 관한 내용은 다음과 같이 정의할 수 있습니다:\n\n```js\n# 지도 우측 패널\n    html.Div([\n        dl.Map(children=dl.LayersControl(\n            [\n                dl.BaseLayer(dl.TileLayer(url='https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'), id='map_base', checked=True, name='기본 맵')\n            ] +\n            [\n                dl.Overlay(children=[], id='route_lines', checked=True, name='경로 방향'),\n                dl.Overlay(children=[], id='route_markers', checked=True, name='항구')\n            ]\n        ), id='routess_map', zoom=3)\n    ], style={'display': 'inline-block', 'height': '100%', 'width': '85%', 'background-color': 'white', 'box-sizing': 'border-box'})\n]\n```\n\ndl.Map() 구성 요소가 dl.BaseLayer() 구성 요소를 통해 선택한 기본 지도를 포함하고 있음에 주목하세요. 또한 dl.Overlay()로 정의된 다른 지도 객체도 포함됩니다. 여기서도 dl.Overlay()는 초기에 비어 있으며, 이전에 정의한 get_route_line() 함수를 사용하여 드롭다운 메뉴에서 경로를 선택하면 내용이 채워집니다.\n\n마지막으로 드롭다운 메뉴와 지도 컨테이너를 모두 부모 컨테이너에 포함시켜 앱의 레이아웃 구성 요소로 할당할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n# Dash 앱 초기화\napp = Dash(__name__)\n\n# 레이아웃 정의\napp.layout = html.Div([\n    # 드롭다운 및 경로 정보용 왼쪽 패널\n    html.Div([\n        html.H1('고대 해상 실크로드'),\n        html.Div([\n            dcc.Dropdown(\n                id='route_dropdown',\n                options=[{'label': route, 'value': route} for route in routes['Route']],\n                placeholder='경로를 선택하세요'\n            )\n        ], style={'display': 'block', 'height': '30%', 'justify-content': 'center', 'color': 'gray'}),\n        html.Div(id='route_info', style={'height': '100%'})\n    ], style={'display': 'inline-block', 'height': '100%', 'width': '15%', 'background-color': '#17408B', 'color': 'white', 'padding': '2%', 'position': 'relative'}),\n    \n    # 지도용 오른쪽 패널\n    html.Div([\n        dl.Map(children=dl.LayersControl(\n            [\n                dl.BaseLayer(dl.TileLayer(url='https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'), id='map_base', checked=True, name='기본 지도')\n            ] +\n            [\n                dl.Overlay(children=[], id='route_lines', checked=True, name='경로 방향'),\n                dl.Overlay(children=[], id='route_markers', checked=True, name='항구')\n            ]\n        ), id='events_map', zoom=3)\n    ], style={'display': 'inline-block', 'height': '100%', 'width': '85%', 'background-color': 'white', 'box-sizing': 'border-box'})\n], style={'display': 'flex', 'height': '100vh', 'width': '100vw', 'position': 'fixed', 'margin': '-8px', 'justify-content': 'center', 'boxSizing': 'border-box'})\n```\n\n## 콜백 설정\n\nDash 앱의 레이아웃을 설정했으니, 다음 단계는 앱의 상호작용성을 정의하는 것입니다. 드롭다운 메뉴에서 경로를 선택하면 지도에 해당 마커 및 라인이 나타나며, 해당 경로 정보도 표시됩니다. 다음과 같이 하나의 콜백 함수로 이를 구현할 수 있습니다:\n\n```js\n@app.callback(\n    Output('route_markers', 'children'),\n    Output('route_lines', 'children'), \n    Output('routes_map', 'center'), \n    Output('routes_map', 'bounds'),\n    Output('route_info', 'children'),\n    Input('route_dropdown', 'value')\n)\ndef update_map_lines(selected_route):\n    if selected_route is None:\n        bounds = [[-50, -80], [50, 80]]\n        centroid = [0, 0]\n        return [], [], centroid, bounds, []\n    else:\n        route_var = routes.loc[routes['Route'] == selected_route, 'Port_Sequence'].iloc[0]\n        cluster, dline, centroid, bounds, duration_days, length = get_route_line(route_var)\n        \n        route_name = selected_route.replace('_', ' ').title()\n        route_info = [\n            html.P([html.B(\"경로: \"), route_name]),\n            html.P([html.B(\"거리: \"), f\"{length:.0f} km\"]),\n            html.P([html.B(\"속도: \"), \"2 knots\"]),\n            html.P([html.B(\"소요 시간: \"), f\"{duration_days:.0f} days\"]),           \n        ]\n        \n        return cluster, [dline], centroid, bounds, route_info\n```\n\n<div class=\"content-ad\"></div>\n\n이 콜백은 이전에 만들었던 get_route_line() 함수를 사용하여 마커와 라인 지도 객체를 생성하고, 맵의 중심과 경계를 다시 계산하며 표시할 경로 정보를 계산합니다.\n\n## 앱 테스트\n\n레이아웃과 콜백 구성 요소를 정의한 후에, 우리의 앱은 준비가 되어 있고 다음 코드를 작성하여 실행할 수 있습니다:\n\n```js\r\nif __name__ == '__main__':\n    app.run_server(debug=True)\r\n```\n\n<div class=\"content-ad\"></div>\n\n그러면 전체 앱 파일을 실행할 수 있습니다. 모든 것이 올바르게 완료되었다면 이와 유사한 결과가 나올 것입니다:\n\n![image](/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_4.png)\n\n✨그리고 와라✨\n\nDash 앱은 로컬호스트 서버에서 실행되며 표시된 URL을 통해 웹 브라우저에서 액세스할 수 있습니다. 이렇게 하면 앱의 완전히 작동하는 인스턴스를 볼 수 있고 디버깅할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 내 생각 속으로\n\n데이터 분석과 시각화에서 Dash와 같은 사용자 정의 보고 도구가 유연성과 사용 편의성으로 인해 인기를 얻고 있습니다. Power BI나 Tableau와 같은 셀프 서비스 도구와 달리 미리 구축된 시각화 옵션을 많이 제공하는 Dash는 보고서 디자인과 기능에 대해 완전한 제어를 제공합니다. 이를 통해 특정 사용자 요구 사항을 충족하기 위해 완전히 사용자 정의된 보고서와 시각화를 작성할 수 있습니다.\n\n예를 들어, 이 게시물에서 보이는 지도 시각화는 사용자 지정 데이터 시각화 도구를 사용하지 않으면 상당히 어렵거나 불가능할 수 있습니다. 우리는 Tableau와 같은 도구를 사용한다면 루트 좌표를 따로 계산하고 저장한 다음 지도 위에 시각화해야 합니다. 심지어 방향성 있는 선을 생성하는 것조차 꽤 번거로울 것입니다. 이러한 수준의 사용자 정의는 데이터 전문가들에게 Dash가 점점 선호되는 이유를 강조합니다.\n\n✨읽어 주셔서 감사합니다!✨\n\n<div class=\"content-ad\"></div>\n\n이 게시물을 즐겼나요? 함께 친구가 되어요!\n\n💌 저와 함께 Medium이나 LinkedIn에서 만나요!\n\n💼 Upwork에서 저와 함께 일해보세요!","ogImage":{"url":"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_0.png"},"coverImage":"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_0.png","tag":["Tech"],"readingTime":20},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_0.png\" alt=\"img\"></p>\n<p>저의 박사학위 중 어려운 부분 중 하나는 선박의 해양 노선을 보여주는 대화형 지도 시각화물을 만드는 것이었습니다. 출발지와 도착지 항구 사이의 선박 노선은 육 지역을 건너가지 않고 오직 바다 상에서의 경로여야 했습니다. 이중 seemingly straightforward 였던 작업이 파이썬에서 처음부터 구현하려고 시도할 때 상당히 어려움이 있었습니다 🤷‍♀️. 유사한 작업을 수행할 수 있는 상용 솔루션이 Marine Traffic과 같이 있지만, 저는 오랜 시간 동안 찾을 수 없는 오픈 소스 대안을 찾고 있었습니다. 마침내 2022년 말에 SeaRoute 라이브러리가 Python을 위해 출시되었고(이전에는 Java만 지원되고 있었음), 그로 인해 제 삶이 훨씬 수월해졌습니다. 이 기사에서는 Dash 앱을 위한 대화형 지도 시각화물을 만드는 과정을 안내하겠습니다. Dash Leaflet 및 SeaRoute Python 라이브러리를 사용하여 해상 경로를 표시할 수 있도록 할 것입니다.</p>\n<h1>Dash, Dash Leaflet, SeaRoute에 대해 어떻게 생각하시나요?</h1>\n<p>Dash는 React.js를 기반으로 만들어진 강력한 Python 프레임워크로, Python의 모든 계산 능력을 통합하고 있습니다. Dash가 무엇이며 무엇을 할 수 있는지, 어떻게 첫 번째 Dash 앱을 만들고 실행할 수 있는지에 대한 간단한 소개는 이전에 작성한 포스트를 참조해 보세요. Dash에 새로 오신 분이라면, 먼저 이것을 읽어보는 것을 추천합니다...</p>\n<p>이 게시물에서는 고대 해상 실크로드 경로를 예시로 사용하여 Dash Leaflet 라이브러리와 SeaRoute 라이브러리의 사용을 소개하겠습니다.</p>\n<p>Dash Leaflet은 상호작용하는 Leaflet 스타일 지도를 Dash 앱에 통합할 수 있는 포꺠 갑을 제공하는 넓은 범위의 지도 시각화 Python 라이브러리입니다. Dash 생태계 내에서 Leaflet.js의 래퍼로, 마커, 다각형, 팝업, 레이어 등과 같은 다양한 기능을 갖춘 지도를 만들고 사용자 정의할 수 있는 구성 요소를 제공합니다.</p>\n<p>SeaRoute는 해상에서 점 간 경로를 계산하는 Python 라이브러리로, 예를 들어 휴스턴과 로테르담 항구 사이의 경로를 계산할 수 있습니다. Python에서 이를 처음부터 계산하려면 해양 지역을 나타내는 해양 형상 파일(예: 해상 국경)을 얻고 지도상에 그린 후 출발점과 도착점 사이의 땅정 경로를 계산하여 해당 해양 지역만 횡단하도록 제약을 설정해야 합니다. 이는 넉넉히 말해 매우 복잡한 작업인데, 각 나라마다 자체 데이터를 다른 형식과 소스로 제공하는 등, 통일되고 표준적인 데이터 소스가 아직 존재하지 않기 때문입니다. 시각화만을 위해 이러한 작업을 해야 한다는 것이 좀 과한 것 같죠. 그렇다면 아름다운 지도 시각화가 필요한 여성은 이번 생애에서 어떻게 해결해야 할까요😠? 다행히 2022년 말에 SeaRoute 라이브러리가 출시되며 시같에 경로를 쉽게 계산하여 시같화할 수 있는 문제를 해결했습니다. 아래 지도에서도 확인할 수 있습니다😇.</p>\n<p>따라서 이 게시물의 나머지 부분에서는:</p>\n<ul>\n<li>SeaRoute를 사용하여 바다 상의 두 지점 사이의 경로 좌표를 계산하세요.</li>\n<li>Dash Leaflet을 사용하여 지도상에 경로를 시각화하세요.</li>\n<li>모든 것을 Dash 앱으로 묶어보세요.</li>\n</ul>\n<p>일단 시작해봐요! 🤸‍♀️️</p>\n<h1>해상 실크로드에 대해서 어떻게 생각하세요?</h1>\n<p>해양 실크로드는 고대 시대에 아시아, 아프리카 및 유럽 대륙 간 다양한 문명을 연결한 중요한 해상 무역로였습니다. 이것은 더 넓고 잘 알려진 실크로드 네트워크의 연장선으로, 육지 및 해상 노선을 포함하며 동서양 간 무역, 문화 교류 및 아이디어 및 기술의 전파를 용이하게 했습니다.</p>\n<p>중국의 한나라 시대(기원전 206년 ~ 서기 220년)에 시작된 해양 실크로드는 통(618<del>907년)과 송(960</del>1279년) 시대에 절정에 이르렀습니다. 남중국해와 인도양을 건너는 중국 선원들은 동남아시아, 인도, 아라비아 반도, 동아프리카 등지의 상인들과 실크, 도자기, 차 등과 같은 상품을 거래했습니다. 그에 대한 보답으로 중국은 향신료, 귀금속, 보석, 이국적인 상품을 수입함으로써 문화와 경제를 발전시켰습니다. 해양 실크로드의 쇠퇴는 14세기경 즈음에 시작되어 해상 무역로가 변화하고 새로운 무역 경로가 나타남에 따라 17세기에는 전통적인 실크로드와 해양 실크로드의 경로가 대부분 사라지며 유럽의 지배력으로 새로운 세계 무역로들이 등장했습니다.</p>\n<p>해양 실크로드를 따라가는 몇 가지 대표적인 경로 (이후 이 게시물의 나머지 부분에서 지도로 시각화할 예정)는 다음과 같습니다:</p>\n<ul>\n<li>Quanzhou <code>Malacca</code> Calicut <code>Aden</code> Alexandria</li>\n<li>Guangzhou <code>Manila</code> Brunei <code>Surabaya</code> Jakarta ` Singapore</li>\n<li>Hangzhou <code>Ningbo</code> Nagasaki <code>Busan</code> Hakata ` Osaka</li>\n<li>Guangzhou <code>Hanoi</code> Da Nang <code>Singapore</code> Colombo ` Muscat</li>\n<li>Xiamen <code>Taiwan</code> Okinawa <code>Yokohama</code> Kobe <code>Nagasaki</code> Busan</li>\n</ul>\n<p>해양로 라이브러리는 여러 가지 흥미로운 계산을 제공합니다. 예를 들어, 루트의 길이나 주어진 속도로 여행하는 데 걸리는 시간을 계산할 수 있습니다. 이번 포스트에서는 중국 존크(해양 실크로드 시대에 널리 사용된 선박 종류)가 평균 5 노트의 속도로 항해했다고 가정해 봅시다.</p>\n<p><img src=\"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_1.png\" alt=\"image\"></p>\n<h1>대시 앱 구축</h1>\n<h2>환경 설정</h2>\n<p>먼저 모든 것에 앞서, 필요한 라이브러리가 설치되어 있는지 확인해야 합니다. 이러한 라이브러리는 Dash, Dash-Leaflet 및 SeaRoute이며, pip를 사용하여 쉽게 설치할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">pip install dash dash-leaflet searoute\n</code></pre>\n<p>그런 다음, 다음과 같이 가져올 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> dash\n<span class=\"hljs-keyword\">from</span> dash <span class=\"hljs-keyword\">import</span> dcc, html\n<span class=\"hljs-keyword\">import</span> dash_leaflet <span class=\"hljs-keyword\">as</span> dl\n<span class=\"hljs-keyword\">from</span> dash.<span class=\"hljs-property\">dependencies</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Input</span>, <span class=\"hljs-title class_\">Output</span>\n<span class=\"hljs-keyword\">from</span> searoute <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">SeaRoute</span>\n</code></pre>\n<p>다음으로, 간단히 Dash 앱의 빈 인스턴스를 초기화할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">app = dash.<span class=\"hljs-title class_\">Dash</span>(__name__)\n</code></pre>\n<p>일반적으로, Dash 앱은 두 가지 주요 구성 요소로 구성됩니다: 레이아웃(layout)과 콜백(callbacks). 레이아웃 구성 요소는 앱의 시각적 및 구조적 부분을 정의하며, 콜백 구성 요소는 앱의 상호 작용을 설명합니다. 그러나 앱의 레이아웃에 더 들어가기 전에 요구되는 데이터가 사용 가능한지 확인해야 합니다.</p>\n<h2>데이터 가져오기</h2>\n<p>먼저, 해상 실크로드의 일부 지표적인 항구 및 해당 좌표, 간단한 설명을 담은 표를 작성했어요. 항구 좌표는 추정치이며 OpenStreetMap에서 가져온 것이며, 오픈 데이터베이스 라이선스(ODbL)를 따라 사용되었습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n\n# 항구, 좌표 및 설명을 포함하는 표 작성\nports_data = {\n    <span class=\"hljs-string\">'항구'</span>: [<span class=\"hljs-string\">'아덴'</span>, <span class=\"hljs-string\">'알렉산드리아'</span>, <span class=\"hljs-string\">'브루나이'</span>, <span class=\"hljs-string\">'부산'</span>, <span class=\"hljs-string\">'칼리컷'</span>,\n            <span class=\"hljs-string\">'콜롬보'</span>, <span class=\"hljs-string\">'다낭'</span>, <span class=\"hljs-string\">'광저우'</span>, <span class=\"hljs-string\">'하카타'</span>, <span class=\"hljs-string\">'항저우'</span>,\n             <span class=\"hljs-string\">'하노이'</span>, <span class=\"hljs-string\">'자카르타'</span>, <span class=\"hljs-string\">'고베'</span>, <span class=\"hljs-string\">'말라카'</span>, <span class=\"hljs-string\">'마닐라'</span>,\n             <span class=\"hljs-string\">'무스카트'</span>, <span class=\"hljs-string\">'나가사키'</span>, <span class=\"hljs-string\">'닝보'</span>, <span class=\"hljs-string\">'오키나와'</span>, <span class=\"hljs-string\">'오사카'</span>,\n             <span class=\"hljs-string\">'전주'</span>, <span class=\"hljs-string\">'싱가포르'</span>, <span class=\"hljs-string\">'수라바야'</span>, <span class=\"hljs-string\">'대만'</span>, <span class=\"hljs-string\">'시안멘'</span>, <span class=\"hljs-string\">'요코하마'</span>],\n    <span class=\"hljs-string\">'국가'</span>: [<span class=\"hljs-string\">'예멘'</span>, <span class=\"hljs-string\">'이집트'</span>, <span class=\"hljs-string\">'브루나이'</span>, <span class=\"hljs-string\">'대한민국'</span>, <span class=\"hljs-string\">'인도'</span>,\n                <span class=\"hljs-string\">'스리랑카'</span>, <span class=\"hljs-string\">'베트남'</span>, <span class=\"hljs-string\">'중국'</span>, <span class=\"hljs-string\">'일본'</span>, <span class=\"hljs-string\">'중국'</span>,\n                <span class=\"hljs-string\">'베트남'</span>, <span class=\"hljs-string\">'인도네시아'</span>, <span class=\"hljs-string\">'일본'</span>, <span class=\"hljs-string\">'말레이시아'</span>, <span class=\"hljs-string\">'필리핀'</span>,\n                <span class=\"hljs-string\">'오만'</span>, <span class=\"hljs-string\">'일본'</span>, <span class=\"hljs-string\">'중국'</span>, <span class=\"hljs-string\">'일본'</span>, <span class=\"hljs-string\">'일본'</span>,\n                <span class=\"hljs-string\">'중국'</span>, <span class=\"hljs-string\">'싱가폴'</span>, <span class=\"hljs-string\">'인도네시아'</span>, <span class=\"hljs-string\">'대만'</span>, <span class=\"hljs-string\">'중국'</span>, <span class=\"hljs-string\">'일본'</span>],\n    <span class=\"hljs-string\">'위도'</span>: [<span class=\"hljs-number\">12.799</span>, <span class=\"hljs-number\">31.2001</span>, <span class=\"hljs-number\">4.5353</span>, <span class=\"hljs-number\">35.1796</span>, <span class=\"hljs-number\">11.2588</span>,\n                 <span class=\"hljs-number\">6.9271</span>, <span class=\"hljs-number\">16.0544</span>, <span class=\"hljs-number\">23.1291</span>, <span class=\"hljs-number\">33.5904</span>, <span class=\"hljs-number\">30.2741</span>,\n                 <span class=\"hljs-number\">21.0285</span>, -<span class=\"hljs-number\">6.2088</span>, <span class=\"hljs-number\">34.6901</span>, <span class=\"hljs-number\">2.1896</span>, <span class=\"hljs-number\">14.5995</span>,\n                 <span class=\"hljs-number\">23.6102</span>, <span class=\"hljs-number\">32.7467</span>, <span class=\"hljs-number\">29.8683</span>, <span class=\"hljs-number\">26.2041</span>, <span class=\"hljs-number\">34.6937</span>,\n                 <span class=\"hljs-number\">24.8798</span>, <span class=\"hljs-number\">1.3521</span>, -<span class=\"hljs-number\">7.2575</span>, <span class=\"hljs-number\">23.6978</span>, <span class=\"hljs-number\">24.4798</span>, <span class=\"hljs-number\">35.4437</span>],\n    <span class=\"hljs-string\">'경도'</span>: [<span class=\"hljs-number\">45.0289</span>, <span class=\"hljs-number\">29.9187</span>, <span class=\"hljs-number\">114.7277</span>, <span class=\"hljs-number\">129.0756</span>, <span class=\"hljs-number\">75.7804</span>,\n                  <span class=\"hljs-number\">79.8612</span>, <span class=\"hljs-number\">108.2022</span>, <span class=\"hljs-number\">113.2644</span>, <span class=\"hljs-number\">130.4017</span>, <span class=\"hljs-number\">120.1551</span>,\n                  <span class=\"hljs-number\">105.8542</span>, <span class=\"hljs-number\">106.8456</span>, <span class=\"hljs-number\">135.1955</span>, <span class=\"hljs-number\">102.2501</span>, <span class=\"hljs-number\">120.9842</span>,\n                  <span class=\"hljs-number\">58.5922</span>, <span class=\"hljs-number\">129.8734</span>, <span class=\"hljs-number\">121.544</span>, <span class=\"hljs-number\">127.6476</span>, <span class=\"hljs-number\">135.5023</span>,\n                  <span class=\"hljs-number\">118.5876</span>, <span class=\"hljs-number\">103.8198</span>, <span class=\"hljs-number\">112.7521</span>, <span class=\"hljs-number\">120.9605</span>, <span class=\"hljs-number\">118.0894</span>, <span class=\"hljs-number\">139.638</span>],\n    <span class=\"hljs-string\">'설명'</span>: [<span class=\"hljs-string\">'붉은해 상거래 경로의 중요한 중심지'</span>, <span class=\"hljs-string\">'지중해 주요 항구, 유럽과의 연결'</span>, <span class=\"hljs-string\">'향균판매의 주요 중지점, 이슬람 영향'</span>, <span class=\"hljs-string\">'실크로드에 대한 한국의 관문'</span>, <span class=\"hljs-string\">'번성한 무역 중심지, 향신료 무역의 중심'</span>,\n                    <span class=\"hljs-string\">'인도양 무역로의 주요 항구'</span>, <span class=\"hljs-string\">'잠바 왕조 시기 중요한 항구'</span>, <span class=\"hljs-string\">'고대 중국 무역 항구, 산동이라 불림'</span>, <span class=\"hljs-string\">'실크로드 무역에 중요한 일본의 항구'</span>, <span class=\"hljs-string\">'대운하의 끝, 실크 생산 중심지'</span>,\n                    <span class=\"hljs-string\">'베트남의 수도, 고대 무역 도시'</span>, <span class=\"hljs-string\">'인도네시아의 수도, 자바의 주요 항구'</span>, <span class=\"hljs-string\">'중요한 일본의 항구, 교토로 향하는 관문'</span>, <span class=\"hljs-string\">'전략적인 해협, 무역의 십자로'</span>, <span class=\"hljs-string\">'아시아에서 스페인 무역의 중심지'</span>,\n                    <span class=\"hljs-string\">'중요한 아라비아 해상 무역 기지'</span>, <span class=\"hljs-string\">'세계로 향하는 일본의 관문, 네덜란드 무역의 중심'</span>, <span class=\"hljs-string\">'주요 해상 항구, 중국 무역에 필수'</span>, <span class=\"hljs-string\">'동아시아 무역로의 중요한 경유지'</span>, <span class=\"hljs-string\">'일본의 주요항구, 역사적 무역 중심지'</span>,\n                    <span class=\"hljs-string\">'중국의 주요 항구, 주요 무역 중심지'</span>, <span class=\"hljs-string\">'전략적인 해협, 주요 무역 기지'</span>, <span class=\"hljs-string\">'자바의 중요한 항구, 인도네시아 무역에 중요'</span>, <span class=\"hljs-string\">'해상 무역용 섬 중간지점'</span>, <span class=\"hljs-string\">'중국의 역사적 항구, 후난으로가는 관문'</span>, <span class=\"hljs-string\">'외국무역에 개방된 주요 일본의 항구'</span>]\n}\n\nports = pd.<span class=\"hljs-title class_\">DataFrame</span>(ports_data)\n</code></pre>\n<p>그 위에, 지도에서 시각화하고 싶은 일부 지표적인 경로(항구 순서)를 정의하고 그것을 DataFrame에 저장합니다:</p>\n<pre><code class=\"hljs language-js\">route_1 = [<span class=\"hljs-string\">'Quanzhou'</span>,<span class=\"hljs-string\">'Malacca'</span>,<span class=\"hljs-string\">'Calicut'</span>,<span class=\"hljs-string\">'Aden'</span>,<span class=\"hljs-string\">'Alexandria'</span>]\r\nroute_2 = [<span class=\"hljs-string\">'Guangzhou'</span>,<span class=\"hljs-string\">'Manila'</span>,<span class=\"hljs-string\">'Brunei'</span>,<span class=\"hljs-string\">'Surabaya'</span>,<span class=\"hljs-string\">'Jakarta'</span>,<span class=\"hljs-string\">'Singapore'</span>]\r\nroute_3 = [<span class=\"hljs-string\">'Hangzhou'</span>,<span class=\"hljs-string\">'Ningbo'</span>,<span class=\"hljs-string\">'Nagasaki'</span>,<span class=\"hljs-string\">'Busan'</span>,<span class=\"hljs-string\">'Hakata'</span>,<span class=\"hljs-string\">'Osaka'</span>]\r\nroute_4 = [<span class=\"hljs-string\">'Guangzhou'</span>,<span class=\"hljs-string\">'Hanoi'</span>,<span class=\"hljs-string\">'Da Nang'</span>,<span class=\"hljs-string\">'Singapore'</span>,<span class=\"hljs-string\">'Colombo'</span>,<span class=\"hljs-string\">'Muscat'</span>]\r\nroute_5 = [<span class=\"hljs-string\">'Xiamen'</span>,<span class=\"hljs-string\">'Taiwan'</span>,<span class=\"hljs-string\">'Okinawa'</span>,<span class=\"hljs-string\">'Yokohama'</span>,<span class=\"hljs-string\">'Kobe'</span>,<span class=\"hljs-string\">'Nagasaki'</span>,<span class=\"hljs-string\">'Busan'</span>]\r\n\r\nroutes = pd.<span class=\"hljs-title class_\">DataFrame</span>({\r\n    <span class=\"hljs-string\">'Route'</span>: [<span class=\"hljs-string\">'route_1'</span>, <span class=\"hljs-string\">'route_2'</span>, <span class=\"hljs-string\">'route_3'</span>, <span class=\"hljs-string\">'route_4'</span>, <span class=\"hljs-string\">'route_5'</span>],\r\n    <span class=\"hljs-string\">'Port_Sequence'</span>: [route_1, route_2, route_3, route_4, route_5]\r\n})\n</code></pre>\n<h2>경로 계산</h2>\n<p>필요한 계산을 수행하기 위해 일반적인 route_var 변수를 가정하고, 이 경로에 포함된 각 항구의 이름과 좌표를 DataFrame으로 구조화합니다. 보다 구체적으로, 이 코드는 주어진 경로의 각 항구를 반복하고 그들의 좌표 및 설명을 검색합니다.</p>\n<pre><code class=\"hljs language-js\">route_rows = [] \r\n\r\n<span class=\"hljs-keyword\">for</span> port <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">route_var</span>: # 경로에 있는 항구를 반복하면서\r\n  port_name = port\r\n  lat = ports.<span class=\"hljs-property\">loc</span>[ports[<span class=\"hljs-string\">'Port'</span>] == port, <span class=\"hljs-string\">'Latitude'</span>].<span class=\"hljs-property\">iloc</span>[<span class=\"hljs-number\">0</span>]\r\n  lon = ports.<span class=\"hljs-property\">loc</span>[ports[<span class=\"hljs-string\">'Port'</span>] == port, <span class=\"hljs-string\">'Longitude'</span>].<span class=\"hljs-property\">iloc</span>[<span class=\"hljs-number\">0</span>]\r\n  row = {<span class=\"hljs-string\">'Port'</span>: port_name, <span class=\"hljs-string\">'lat'</span>: lat, <span class=\"hljs-string\">'lon'</span>: lon}\r\n  route_rows.<span class=\"hljs-title function_\">append</span>(row)\r\n\r\nroute_df = pd.<span class=\"hljs-title function_\">concat</span>([pd.<span class=\"hljs-title class_\">DataFrame</span>(row, index=[<span class=\"hljs-number\">0</span>]) <span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> route_rows], ignore_index=<span class=\"hljs-title class_\">True</span>)\n</code></pre>\n<p>지도 시각화를 시작하려면 Dash-Leaflet 라이브러리의 dl.Marker(), dl.Tooltip 및 dl.LayerGroup() 구성 요소를 사용하여 포트를 마커로 시각화하기 위한 지도 객체를 쉽게 생성할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">    # 계산된 포트 마커에서 지도 객체 생성\n    markers = []\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">len</span>(route_df)):\n        # 각 포트 마커에 대한 툴팁 생성\n        tooltip = route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'Port'</span>] + <span class=\"hljs-string\">', '</span> + ports.<span class=\"hljs-property\">loc</span>[ports[<span class=\"hljs-string\">'Port'</span>] == route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'Port'</span>], <span class=\"hljs-string\">'Description'</span>].<span class=\"hljs-property\">iloc</span>[<span class=\"hljs-number\">0</span>]\n        markers.<span class=\"hljs-title function_\">append</span>(  # 마커 계산\n            dl.<span class=\"hljs-title class_\">Marker</span>(\n                position=(route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'lat'</span>], route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'lon'</span>]),\n                children=[dl.<span class=\"hljs-title class_\">Tooltip</span>(tooltip)]\n            )\n        )\n    cluster = dl.<span class=\"hljs-title class_\">LayerGroup</span>(children=markers)\n</code></pre>\n<p>이 방법을 사용하면 선택한 경로의 각 포트에 대해 dl.Marker()를 사용하여 마커를 생성하고 dl.Tooltip()을 사용하여 툴팁을 만듭니다. 그런 다음 dl.LayerGroup()를 사용하여 이러한 마커를 단일 레이어 그룹으로 그룹화합니다. LayerGroup() 구성 요소는 여러 지도 요소(마커 등)를 단일 레이어로 그룹화하는 데 사용됩니다. 이를 통해 이러한 요소를 함께 관리하고 제어할 수 있습니다. 예를 들어, 사용자가 한 번의 동작으로 모든 마커를 표시하거나 숨길 수 있으며, 마커를 하나씩 선택하는 대신 모두 선택할 수 있습니다.</p>\n<p>바다에서의 경로 계산으로 넘어가면, 아래와 같이 SeaRoute 라이브러리를 사용하여 이를 달성할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"># 바다에서 경로 계산하기\nmarkers_line = []\nlength = <span class=\"hljs-number\">0</span>\nduration_hours = <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_\">len</span>(route_df) - <span class=\"hljs-number\">1</span>):\n    origin = [route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'lon'</span>], route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'lat'</span>]]\n    destination = [route_df.<span class=\"hljs-property\">loc</span>[i+<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'lon'</span>], route_df.<span class=\"hljs-property\">loc</span>[i+<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'lat'</span>]]\n    searoutes_coords = sr.<span class=\"hljs-title function_\">searoute</span>(origin, destination, append_orig_dest=<span class=\"hljs-title class_\">True</span>, speed_knot=<span class=\"hljs-number\">2</span>)\n    searoutes_coords_transposed = [[coord[<span class=\"hljs-number\">1</span>], coord[<span class=\"hljs-number\">0</span>]] <span class=\"hljs-keyword\">for</span> coord <span class=\"hljs-keyword\">in</span> searoutes_coords[<span class=\"hljs-string\">'geometry'</span>][<span class=\"hljs-string\">'coordinates'</span>]]\n    markers_line += searoutes_coords_transposed\n   \n    length += searoutes_coords[<span class=\"hljs-string\">'properties'</span>][<span class=\"hljs-string\">'length'</span>]\n    duration_hours += searoutes_coords[<span class=\"hljs-string\">'properties'</span>][<span class=\"hljs-string\">'duration_hours'</span>]\nduration_days = duration_hours / <span class=\"hljs-number\">24</span>\n</code></pre>\n<p>이전에 언급했듯이 SeaRoute 라이브러리를 사용하면 경로 거리와 항해 시간을 계산하는 것과 같은 추가 속성을 계산할 수 있습니다. 여기에서 속도가 sr.searoute() 함수에서 speed_knot = 5로 정의된 것을 확인하세요.</p>\n<p>SeaRoute로 맵 좌표를 계산한 후 dl.Polyline() 구성 요소를 사용하여 맵에 시각화할 수 있습니다. 또한 dl.PolylineDecorator() 구성 요소를 사용하여 선 방향을 나타내는 화살표를 추가할 수 있습니다. patterns 변수에서 간단한 화살표를 직접 정의합니다.</p>\n<pre><code class=\"hljs language-js\"># 계산된 바다 경로용 맵 객체 생성\nline = dl.<span class=\"hljs-title class_\">Polyline</span>(\n    positions=markers_line,\n    smoothFactor=<span class=\"hljs-number\">1.0</span>,\n    color=<span class=\"hljs-string\">'ForestGreen'</span>,\n    weight=<span class=\"hljs-number\">1</span>,\n    lineCap=<span class=\"hljs-string\">'round'</span>,\n    lineJoin=<span class=\"hljs-string\">'round'</span>\n)\npatterns = [<span class=\"hljs-title function_\">dict</span>(offset=<span class=\"hljs-string\">'5%'</span>, repeat=<span class=\"hljs-string\">'30px'</span>, endOffset=<span class=\"hljs-string\">'10%'</span>, arrowHead=<span class=\"hljs-title function_\">dict</span>(pixelSize=<span class=\"hljs-number\">8</span>, polygon=<span class=\"hljs-title class_\">False</span>, pathOptions=<span class=\"hljs-title function_\">dict</span>(stroke=<span class=\"hljs-title class_\">True</span>, color=<span class=\"hljs-string\">'ForestGreen'</span>, weight=<span class=\"hljs-number\">1</span>, opacity=<span class=\"hljs-number\">10</span>, smoothFactor=<span class=\"hljs-number\">1</span>)))]\ndline = dl.<span class=\"hljs-title class_\">PolylineDecorator</span>(children=line, patterns=patterns)\n</code></pre>\n<p>또한, 각 선택된 노선마다 지도의 중심과 영역을 다시 계산하는 것이 적절하다고 생각했습니다. 이렇게 하면 사용자가 선택한 각 노선마다 지도가 다시 초점을 맞춰서, 마커와 선이 적절하게 표시됩니다.</p>\n<pre><code class=\"hljs language-js\"># 경계 계산\nmin_lat = <span class=\"hljs-title function_\">min</span>(lat <span class=\"hljs-keyword\">for</span> lat, lon <span class=\"hljs-keyword\">in</span> markers_line) - <span class=\"hljs-number\">2</span>\nmax_lat = <span class=\"hljs-title function_\">max</span>(lat <span class=\"hljs-keyword\">for</span> lat, lon <span class=\"hljs-keyword\">in</span> markers_line) + <span class=\"hljs-number\">2</span>\nmin_lon = <span class=\"hljs-title function_\">min</span>(lon <span class=\"hljs-keyword\">for</span> lat, lon <span class=\"hljs-keyword\">in</span> markers_line) - <span class=\"hljs-number\">2</span>\nmax_lon = <span class=\"hljs-title function_\">max</span>(lon <span class=\"hljs-keyword\">for</span> lat, lon <span class=\"hljs-keyword\">in</span> markers_line) + <span class=\"hljs-number\">2</span>\nbounds = [[min_lat, min_lon], [max_lat, max_lon]]\n\n# 중심 계산\nx, y = <span class=\"hljs-title function_\">zip</span>(*markers_line)\ncentroid = [<span class=\"hljs-title function_\">sum</span>(x) / <span class=\"hljs-title function_\">len</span>(x), <span class=\"hljs-title function_\">sum</span>(y) / <span class=\"hljs-title function_\">len</span>(y)]\n</code></pre>\n<p>마지막으로, 이러한 요소들을 하나의 함수로 묶어 보겠습니다.</p>\n<pre><code class=\"hljs language-js\"># 노선 포트의 해상 경로 지도 마커 및 경로 계산 함수 정의\ndef <span class=\"hljs-title function_\">get_route_line</span>(route_var):\n    \n    route_rows = [] \n    <span class=\"hljs-keyword\">for</span> port <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">route_var</span>: # 노선 내 포트를 반복\n        port_name = port\n        lat = ports.<span class=\"hljs-property\">loc</span>[ports[<span class=\"hljs-string\">'Port'</span>] == port, <span class=\"hljs-string\">'Latitude'</span>].<span class=\"hljs-property\">iloc</span>[<span class=\"hljs-number\">0</span>]\n        lon = ports.<span class=\"hljs-property\">loc</span>[ports[<span class=\"hljs-string\">'Port'</span>] == port, <span class=\"hljs-string\">'Longitude'</span>].<span class=\"hljs-property\">iloc</span>[<span class=\"hljs-number\">0</span>]\n        row = {<span class=\"hljs-string\">'Port'</span>: port_name, <span class=\"hljs-string\">'lat'</span>: lat, <span class=\"hljs-string\">'lon'</span>: lon}\n        route_rows.<span class=\"hljs-title function_\">append</span>(row)\n   \n    route_df = pd.<span class=\"hljs-title function_\">concat</span>([pd.<span class=\"hljs-title class_\">DataFrame</span>(row, index=[<span class=\"hljs-number\">0</span>]) <span class=\"hljs-keyword\">for</span> row <span class=\"hljs-keyword\">in</span> route_rows], ignore_index=<span class=\"hljs-title class_\">True</span>)\n   \n    # 계산된 포트 마커에서 맵 개체 생성\n    markers = []\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">len</span>(route_df)):\n        # 각 포트 마커에 대한 툴팁 생성\n        tooltip = route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'Port'</span>] + <span class=\"hljs-string\">', '</span> + ports.<span class=\"hljs-property\">loc</span>[ports[<span class=\"hljs-string\">'Port'</span>] == route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'Port'</span>], <span class=\"hljs-string\">'Description'</span>].<span class=\"hljs-property\">iloc</span>[<span class=\"hljs-number\">0</span>]\n        markers.<span class=\"hljs-title function_\">append</span>(  # 마커 계산\n            dl.<span class=\"hljs-title class_\">Marker</span>(\n                position=(route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'lat'</span>], route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'lon'</span>]),\n                children=[dl.<span class=\"hljs-title class_\">Tooltip</span>(tooltip)]\n            )\n        )\n    cluster = dl.<span class=\"hljs-title class_\">LayerGroup</span>(children=markers)\n   \n    # 해상 경로 계산\n    markers_line = []\n    length = <span class=\"hljs-number\">0</span>\n    duration_hours = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_\">len</span>(route_df) - <span class=\"hljs-number\">1</span>):\n        origin = [route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'lon'</span>], route_df.<span class=\"hljs-property\">loc</span>[i, <span class=\"hljs-string\">'lat'</span>]]\n        destination = [route_df.<span class=\"hljs-property\">loc</span>[i+<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'lon'</span>], route_df.<span class=\"hljs-property\">loc</span>[i+<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'lat'</span>]]\n        searoutes_coords = sr.<span class=\"hljs-title function_\">searoute</span>(origin, destination, append_orig_dest=<span class=\"hljs-title class_\">True</span>, speed_knot=<span class=\"hljs-number\">2</span>)\n        searoutes_coords_transposed = [[coord[<span class=\"hljs-number\">1</span>], coord[<span class=\"hljs-number\">0</span>]] <span class=\"hljs-keyword\">for</span> coord <span class=\"hljs-keyword\">in</span> searoutes_coords[<span class=\"hljs-string\">'geometry'</span>][<span class=\"hljs-string\">'coordinates'</span>]]\n        markers_line += searoutes_coords_transposed\n       \n        length += searoutes_coords[<span class=\"hljs-string\">'properties'</span>][<span class=\"hljs-string\">'length'</span>]\n        duration_hours += searoutes_coords[<span class=\"hljs-string\">'properties'</span>][<span class=\"hljs-string\">'duration_hours'</span>]\n    duration_days = duration_hours / <span class=\"hljs-number\">24</span>\n\n    # 계산된 해상 경로를 위한 맵 개체 생성\n    line = dl.<span class=\"hljs-title class_\">Polyline</span>(\n        positions=markers_line,\n        smoothFactor=<span class=\"hljs-number\">1.0</span>,\n        color=<span class=\"hljs-string\">'ForestGreen'</span>,\n        weight=<span class=\"hljs-number\">1</span>,\n        lineCap=<span class=\"hljs-string\">'round'</span>,\n        lineJoin=<span class=\"hljs-string\">'round'</span>\n    )\n    patterns = [<span class=\"hljs-title function_\">dict</span>(offset=<span class=\"hljs-string\">'5%'</span>, repeat=<span class=\"hljs-string\">'30px'</span>, endOffset=<span class=\"hljs-string\">'10%'</span>, arrowHead=<span class=\"hljs-title function_\">dict</span>(pixelSize=<span class=\"hljs-number\">8</span>, polygon=<span class=\"hljs-title class_\">False</span>, pathOptions=<span class=\"hljs-title function_\">dict</span>(stroke=<span class=\"hljs-title class_\">True</span>, color=<span class=\"hljs-string\">'ForestGreen'</span>, weight=<span class=\"hljs-number\">1</span>, opacity=<span class=\"hljs-number\">10</span>, smoothFactor=<span class=\"hljs-number\">1</span>)))]\n    dline = dl.<span class=\"hljs-title class_\">PolylineDecorator</span>(children=line, patterns=patterns)\n    \n    # 경계 계산\n    min_lat = <span class=\"hljs-title function_\">min</span>(lat <span class=\"hljs-keyword\">for</span> lat, lon <span class=\"hljs-keyword\">in</span> markers_line) - <span class=\"hljs-number\">2</span>\n    max_lat = <span class=\"hljs-title function_\">max</span>(lat <span class=\"hljs-keyword\">for</span> lat, lon <span class=\"hljs-keyword\">in</span> markers_line) + <span class=\"hljs-number\">2</span>\n    min_lon = <span class=\"hljs-title function_\">min</span>(lon <span class=\"hljs-keyword\">for</span> lat, lon <span class=\"hljs-keyword\">in</span> markers_line) - <span class=\"hljs-number\">2</span>\n    max_lon = <span class=\"hljs-title function_\">max</span>(lon <span class=\"hljs-keyword\">for</span> lat, lon <span class=\"hljs-keyword\">in</span> markers_line) + <span class=\"hljs-number\">2</span>\n    bounds = [[min_lat, min_lon], [max_lat, max_lon]]\n    \n    # 중심 계산\n    x, y = <span class=\"hljs-title function_\">zip</span>(*markers_line)\n    centroid = [<span class=\"hljs-title function_\">sum</span>(x) / <span class=\"hljs-title function_\">len</span>(x), <span class=\"hljs-title function_\">sum</span>(y) / <span class=\"hljs-title function_\">len</span>(y)]\n\n    <span class=\"hljs-keyword\">return</span> cluster, dline, centroid, bounds, duration_days\n</code></pre>\n<p>따라서, 모든 계산은 두 개의 함수로 처리됩니다:</p>\n<h2>레이아웃 생성</h2>\n<p>get_route_line() 함수를 정의한 후, 이제 앱의 레이아웃 컴포넌트를 구성할 차례입니다. 아래 이미지와 유사한 레이아웃을 만들려고 합니다:</p>\n<p><img src=\"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_3.png\" alt=\"이미지\"></p>\n<p>구체적으로는 다음 사항을 통합하고 싶습니다:</p>\n<ul>\n<li>루트 선택 컨테이너는 루트를 선택할 수있는 드롭다운 메뉴와 선택한 루트, 가정된 선박 속도, 그리고 예상 항해 기간과 같은 각 루트에 대한 정보를 표시합니다.</li>\n<li>선택한 루트의 항구 및 해당 해상 경로를 표시하는 지도 시각화가 있습니다.</li>\n</ul>\n<p>드롭다운 패널은 다음과 같이 정의할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"># 드롭다운 및 루트 정보를 위한 왼쪽 패널\n    html.<span class=\"hljs-title class_\">Div</span>([\n        html.<span class=\"hljs-title function_\">H1</span>(<span class=\"hljs-string\">'고대 해상 실크로드'</span>),\n        html.<span class=\"hljs-title class_\">Div</span>([\n            dcc.<span class=\"hljs-title class_\">Dropdown</span>(\n                id=<span class=\"hljs-string\">'route_dropdown'</span>,\n                options=[{<span class=\"hljs-string\">'label'</span>: route, <span class=\"hljs-string\">'value'</span>: route} <span class=\"hljs-keyword\">for</span> route <span class=\"hljs-keyword\">in</span> routes[<span class=\"hljs-string\">'Route'</span>]],\n                placeholder=<span class=\"hljs-string\">'루트 선택'</span>\n            )\n        ], style={<span class=\"hljs-string\">'display'</span>: <span class=\"hljs-string\">'block'</span>, <span class=\"hljs-string\">'height'</span>: <span class=\"hljs-string\">'30%'</span>, <span class=\"hljs-string\">'justify-content'</span>: <span class=\"hljs-string\">'center'</span>, <span class=\"hljs-string\">'color'</span>: <span class=\"hljs-string\">'gray'</span>}),\n        html.<span class=\"hljs-title class_\">Div</span>(id=<span class=\"hljs-string\">'route_info'</span>, style={<span class=\"hljs-string\">'height'</span>: <span class=\"hljs-string\">'100%'</span>})\n    ], style={<span class=\"hljs-string\">'display'</span>: <span class=\"hljs-string\">'inline-block'</span>, <span class=\"hljs-string\">'height'</span>: <span class=\"hljs-string\">'100%'</span>, <span class=\"hljs-string\">'width'</span>: <span class=\"hljs-string\">'15%'</span>, <span class=\"hljs-string\">'background-color'</span>: <span class=\"hljs-string\">'#17408B'</span>, <span class=\"hljs-string\">'color'</span>: <span class=\"hljs-string\">'white'</span>, <span class=\"hljs-string\">'padding'</span>: <span class=\"hljs-string\">'2%'</span>, <span class=\"hljs-string\">'position'</span>: <span class=\"hljs-string\">'relative'</span>}),\n</code></pre>\n<p>더 구체적으로, 드롭다운 메뉴는 이전에 정의한 routes DataFrame에 의해 채워집니다. 또한, 루트 정보 패널은 초기에 비어 있고 드롭다운 메뉴에서 루트를 선택하면 콜백을 통해 채워질 것입니다.</p>\n<p>지도 시각화에 관한 내용은 다음과 같이 정의할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"># 지도 우측 패널\n    html.<span class=\"hljs-title class_\">Div</span>([\n        dl.<span class=\"hljs-title class_\">Map</span>(children=dl.<span class=\"hljs-title class_\">LayersControl</span>(\n            [\n                dl.<span class=\"hljs-title class_\">BaseLayer</span>(dl.<span class=\"hljs-title class_\">TileLayer</span>(url=<span class=\"hljs-string\">'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'</span>), id=<span class=\"hljs-string\">'map_base'</span>, checked=<span class=\"hljs-title class_\">True</span>, name=<span class=\"hljs-string\">'기본 맵'</span>)\n            ] +\n            [\n                dl.<span class=\"hljs-title class_\">Overlay</span>(children=[], id=<span class=\"hljs-string\">'route_lines'</span>, checked=<span class=\"hljs-title class_\">True</span>, name=<span class=\"hljs-string\">'경로 방향'</span>),\n                dl.<span class=\"hljs-title class_\">Overlay</span>(children=[], id=<span class=\"hljs-string\">'route_markers'</span>, checked=<span class=\"hljs-title class_\">True</span>, name=<span class=\"hljs-string\">'항구'</span>)\n            ]\n        ), id=<span class=\"hljs-string\">'routess_map'</span>, zoom=<span class=\"hljs-number\">3</span>)\n    ], style={<span class=\"hljs-string\">'display'</span>: <span class=\"hljs-string\">'inline-block'</span>, <span class=\"hljs-string\">'height'</span>: <span class=\"hljs-string\">'100%'</span>, <span class=\"hljs-string\">'width'</span>: <span class=\"hljs-string\">'85%'</span>, <span class=\"hljs-string\">'background-color'</span>: <span class=\"hljs-string\">'white'</span>, <span class=\"hljs-string\">'box-sizing'</span>: <span class=\"hljs-string\">'border-box'</span>})\n]\n</code></pre>\n<p>dl.Map() 구성 요소가 dl.BaseLayer() 구성 요소를 통해 선택한 기본 지도를 포함하고 있음에 주목하세요. 또한 dl.Overlay()로 정의된 다른 지도 객체도 포함됩니다. 여기서도 dl.Overlay()는 초기에 비어 있으며, 이전에 정의한 get_route_line() 함수를 사용하여 드롭다운 메뉴에서 경로를 선택하면 내용이 채워집니다.</p>\n<p>마지막으로 드롭다운 메뉴와 지도 컨테이너를 모두 부모 컨테이너에 포함시켜 앱의 레이아웃 구성 요소로 할당할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">Dash</span> 앱 초기화\napp = <span class=\"hljs-title class_\">Dash</span>(__name__)\n\n# 레이아웃 정의\napp.<span class=\"hljs-property\">layout</span> = html.<span class=\"hljs-title class_\">Div</span>([\n    # 드롭다운 및 경로 정보용 왼쪽 패널\n    html.<span class=\"hljs-title class_\">Div</span>([\n        html.<span class=\"hljs-title function_\">H1</span>(<span class=\"hljs-string\">'고대 해상 실크로드'</span>),\n        html.<span class=\"hljs-title class_\">Div</span>([\n            dcc.<span class=\"hljs-title class_\">Dropdown</span>(\n                id=<span class=\"hljs-string\">'route_dropdown'</span>,\n                options=[{<span class=\"hljs-string\">'label'</span>: route, <span class=\"hljs-string\">'value'</span>: route} <span class=\"hljs-keyword\">for</span> route <span class=\"hljs-keyword\">in</span> routes[<span class=\"hljs-string\">'Route'</span>]],\n                placeholder=<span class=\"hljs-string\">'경로를 선택하세요'</span>\n            )\n        ], style={<span class=\"hljs-string\">'display'</span>: <span class=\"hljs-string\">'block'</span>, <span class=\"hljs-string\">'height'</span>: <span class=\"hljs-string\">'30%'</span>, <span class=\"hljs-string\">'justify-content'</span>: <span class=\"hljs-string\">'center'</span>, <span class=\"hljs-string\">'color'</span>: <span class=\"hljs-string\">'gray'</span>}),\n        html.<span class=\"hljs-title class_\">Div</span>(id=<span class=\"hljs-string\">'route_info'</span>, style={<span class=\"hljs-string\">'height'</span>: <span class=\"hljs-string\">'100%'</span>})\n    ], style={<span class=\"hljs-string\">'display'</span>: <span class=\"hljs-string\">'inline-block'</span>, <span class=\"hljs-string\">'height'</span>: <span class=\"hljs-string\">'100%'</span>, <span class=\"hljs-string\">'width'</span>: <span class=\"hljs-string\">'15%'</span>, <span class=\"hljs-string\">'background-color'</span>: <span class=\"hljs-string\">'#17408B'</span>, <span class=\"hljs-string\">'color'</span>: <span class=\"hljs-string\">'white'</span>, <span class=\"hljs-string\">'padding'</span>: <span class=\"hljs-string\">'2%'</span>, <span class=\"hljs-string\">'position'</span>: <span class=\"hljs-string\">'relative'</span>}),\n    \n    # 지도용 오른쪽 패널\n    html.<span class=\"hljs-title class_\">Div</span>([\n        dl.<span class=\"hljs-title class_\">Map</span>(children=dl.<span class=\"hljs-title class_\">LayersControl</span>(\n            [\n                dl.<span class=\"hljs-title class_\">BaseLayer</span>(dl.<span class=\"hljs-title class_\">TileLayer</span>(url=<span class=\"hljs-string\">'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'</span>), id=<span class=\"hljs-string\">'map_base'</span>, checked=<span class=\"hljs-title class_\">True</span>, name=<span class=\"hljs-string\">'기본 지도'</span>)\n            ] +\n            [\n                dl.<span class=\"hljs-title class_\">Overlay</span>(children=[], id=<span class=\"hljs-string\">'route_lines'</span>, checked=<span class=\"hljs-title class_\">True</span>, name=<span class=\"hljs-string\">'경로 방향'</span>),\n                dl.<span class=\"hljs-title class_\">Overlay</span>(children=[], id=<span class=\"hljs-string\">'route_markers'</span>, checked=<span class=\"hljs-title class_\">True</span>, name=<span class=\"hljs-string\">'항구'</span>)\n            ]\n        ), id=<span class=\"hljs-string\">'events_map'</span>, zoom=<span class=\"hljs-number\">3</span>)\n    ], style={<span class=\"hljs-string\">'display'</span>: <span class=\"hljs-string\">'inline-block'</span>, <span class=\"hljs-string\">'height'</span>: <span class=\"hljs-string\">'100%'</span>, <span class=\"hljs-string\">'width'</span>: <span class=\"hljs-string\">'85%'</span>, <span class=\"hljs-string\">'background-color'</span>: <span class=\"hljs-string\">'white'</span>, <span class=\"hljs-string\">'box-sizing'</span>: <span class=\"hljs-string\">'border-box'</span>})\n], style={<span class=\"hljs-string\">'display'</span>: <span class=\"hljs-string\">'flex'</span>, <span class=\"hljs-string\">'height'</span>: <span class=\"hljs-string\">'100vh'</span>, <span class=\"hljs-string\">'width'</span>: <span class=\"hljs-string\">'100vw'</span>, <span class=\"hljs-string\">'position'</span>: <span class=\"hljs-string\">'fixed'</span>, <span class=\"hljs-string\">'margin'</span>: <span class=\"hljs-string\">'-8px'</span>, <span class=\"hljs-string\">'justify-content'</span>: <span class=\"hljs-string\">'center'</span>, <span class=\"hljs-string\">'boxSizing'</span>: <span class=\"hljs-string\">'border-box'</span>})\n</code></pre>\n<h2>콜백 설정</h2>\n<p>Dash 앱의 레이아웃을 설정했으니, 다음 단계는 앱의 상호작용성을 정의하는 것입니다. 드롭다운 메뉴에서 경로를 선택하면 지도에 해당 마커 및 라인이 나타나며, 해당 경로 정보도 표시됩니다. 다음과 같이 하나의 콜백 함수로 이를 구현할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">@app.<span class=\"hljs-title function_\">callback</span>(\n    <span class=\"hljs-title class_\">Output</span>(<span class=\"hljs-string\">'route_markers'</span>, <span class=\"hljs-string\">'children'</span>),\n    <span class=\"hljs-title class_\">Output</span>(<span class=\"hljs-string\">'route_lines'</span>, <span class=\"hljs-string\">'children'</span>), \n    <span class=\"hljs-title class_\">Output</span>(<span class=\"hljs-string\">'routes_map'</span>, <span class=\"hljs-string\">'center'</span>), \n    <span class=\"hljs-title class_\">Output</span>(<span class=\"hljs-string\">'routes_map'</span>, <span class=\"hljs-string\">'bounds'</span>),\n    <span class=\"hljs-title class_\">Output</span>(<span class=\"hljs-string\">'route_info'</span>, <span class=\"hljs-string\">'children'</span>),\n    <span class=\"hljs-title class_\">Input</span>(<span class=\"hljs-string\">'route_dropdown'</span>, <span class=\"hljs-string\">'value'</span>)\n)\ndef <span class=\"hljs-title function_\">update_map_lines</span>(selected_route):\n    <span class=\"hljs-keyword\">if</span> selected_route is <span class=\"hljs-title class_\">None</span>:\n        bounds = [[-<span class=\"hljs-number\">50</span>, -<span class=\"hljs-number\">80</span>], [<span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">80</span>]]\n        centroid = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>]\n        <span class=\"hljs-keyword\">return</span> [], [], centroid, bounds, []\n    <span class=\"hljs-attr\">else</span>:\n        route_var = routes.<span class=\"hljs-property\">loc</span>[routes[<span class=\"hljs-string\">'Route'</span>] == selected_route, <span class=\"hljs-string\">'Port_Sequence'</span>].<span class=\"hljs-property\">iloc</span>[<span class=\"hljs-number\">0</span>]\n        cluster, dline, centroid, bounds, duration_days, length = <span class=\"hljs-title function_\">get_route_line</span>(route_var)\n        \n        route_name = selected_route.<span class=\"hljs-title function_\">replace</span>(<span class=\"hljs-string\">'_'</span>, <span class=\"hljs-string\">' '</span>).<span class=\"hljs-title function_\">title</span>()\n        route_info = [\n            html.<span class=\"hljs-title function_\">P</span>([html.<span class=\"hljs-title function_\">B</span>(<span class=\"hljs-string\">\"경로: \"</span>), route_name]),\n            html.<span class=\"hljs-title function_\">P</span>([html.<span class=\"hljs-title function_\">B</span>(<span class=\"hljs-string\">\"거리: \"</span>), f<span class=\"hljs-string\">\"{length:.0f} km\"</span>]),\n            html.<span class=\"hljs-title function_\">P</span>([html.<span class=\"hljs-title function_\">B</span>(<span class=\"hljs-string\">\"속도: \"</span>), <span class=\"hljs-string\">\"2 knots\"</span>]),\n            html.<span class=\"hljs-title function_\">P</span>([html.<span class=\"hljs-title function_\">B</span>(<span class=\"hljs-string\">\"소요 시간: \"</span>), f<span class=\"hljs-string\">\"{duration_days:.0f} days\"</span>]),           \n        ]\n        \n        <span class=\"hljs-keyword\">return</span> cluster, [dline], centroid, bounds, route_info\n</code></pre>\n<p>이 콜백은 이전에 만들었던 get_route_line() 함수를 사용하여 마커와 라인 지도 객체를 생성하고, 맵의 중심과 경계를 다시 계산하며 표시할 경로 정보를 계산합니다.</p>\n<h2>앱 테스트</h2>\n<p>레이아웃과 콜백 구성 요소를 정의한 후에, 우리의 앱은 준비가 되어 있고 다음 코드를 작성하여 실행할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    app.<span class=\"hljs-title function_\">run_server</span>(debug=<span class=\"hljs-title class_\">True</span>)\n</code></pre>\n<p>그러면 전체 앱 파일을 실행할 수 있습니다. 모든 것이 올바르게 완료되었다면 이와 유사한 결과가 나올 것입니다:</p>\n<p><img src=\"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_4.png\" alt=\"image\"></p>\n<p>✨그리고 와라✨</p>\n<p>Dash 앱은 로컬호스트 서버에서 실행되며 표시된 URL을 통해 웹 브라우저에서 액세스할 수 있습니다. 이렇게 하면 앱의 완전히 작동하는 인스턴스를 볼 수 있고 디버깅할 수 있습니다.</p>\n<h1>내 생각 속으로</h1>\n<p>데이터 분석과 시각화에서 Dash와 같은 사용자 정의 보고 도구가 유연성과 사용 편의성으로 인해 인기를 얻고 있습니다. Power BI나 Tableau와 같은 셀프 서비스 도구와 달리 미리 구축된 시각화 옵션을 많이 제공하는 Dash는 보고서 디자인과 기능에 대해 완전한 제어를 제공합니다. 이를 통해 특정 사용자 요구 사항을 충족하기 위해 완전히 사용자 정의된 보고서와 시각화를 작성할 수 있습니다.</p>\n<p>예를 들어, 이 게시물에서 보이는 지도 시각화는 사용자 지정 데이터 시각화 도구를 사용하지 않으면 상당히 어렵거나 불가능할 수 있습니다. 우리는 Tableau와 같은 도구를 사용한다면 루트 좌표를 따로 계산하고 저장한 다음 지도 위에 시각화해야 합니다. 심지어 방향성 있는 선을 생성하는 것조차 꽤 번거로울 것입니다. 이러한 수준의 사용자 정의는 데이터 전문가들에게 Dash가 점점 선호되는 이유를 강조합니다.</p>\n<p>✨읽어 주셔서 감사합니다!✨</p>\n<p>이 게시물을 즐겼나요? 함께 친구가 되어요!</p>\n<p>💌 저와 함께 Medium이나 LinkedIn에서 만나요!</p>\n<p>💼 Upwork에서 저와 함께 일해보세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}