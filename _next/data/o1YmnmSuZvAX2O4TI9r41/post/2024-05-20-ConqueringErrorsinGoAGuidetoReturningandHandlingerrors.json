{"pageProps":{"post":{"title":"고 오류 정복하기 오류 반환과 처리에 관한 안내","description":"","date":"2024-05-20 16:27","slug":"2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors","content":"\n\n## Go 오류 처리 마스터하기 위한 초보자 가이드\n\n![이미지](/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png)\n\n# 레벨 1: if err != nil\n\n이것은 오류를 반환하는 가장 간단한 방법입니다. 대부분의 사람들은 이 패턴에 익숙합니다. 오류를 반환할 수 있는 함수를 호출하고, 오류가 nil인지 확인하고, nil이 아니면 오류를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n```Go\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc doSomething() (float64, error) {\n result, err := mayReturnError();\n if err != nil {\n  return 0, err\n }\n return result, nil\n}\n```\n\n## 이 방식의 문제점\n\n이 방식이 가장 간단하고 사실상 가장 많이 사용되는 방법이지만 중대한 문제점이 있습니다: 컨텍스트 부족. 깊은 호출 스택이 있는 경우 어떤 함수가 오류를 발생시켰는지 알 수 없습니다.\n\nA() 함수가 B()를 호출하고, B()가 C()를 호출하고, C()가 다음과 같은 오류를 반환하는 호출 스택을 상상해보십시오:\n\n<div class=\"content-ad\"></div>\n\n```js\npackage main\n\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc A(x int) (int, error) {\n result, err := B(x)\n if err != nil {\n  return 0, err\n }\n return result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n result, err := C(x)\n if err != nil {\n  return 0, err\n }\n return result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n if x < 0 {\n  return 0, errors.New(\"negative value not allowed\")\n }\n return x * x, nil\n}\n\nfunc main() {\n // Call function A with invalid input\n result, err := A(-2)\n if err == nil {\n  fmt.Println(\"결과:\", result)\n } else {\n  fmt.Println(\"에러:\", err)\n }\n}\n```\n\n만약 이 프로그램을 실행하면 다음과 같이 출력됩니다.\n\n```js\n에러: negative value not allowed\n```\n\n우리는 호출 스택에서 이 오류가 어디에서 발생했는지에 대한 컨텍스트가 없습니다. 특정 오류 문자열을 찾아 해당 오류가 어디에서 발생했는지를 알아내기 위해 프로그램을 코드 편집기에서 열어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 레벨 2: 에러 감싸기\n\n에러에 대한 컨텍스트를 추가하기 위해 fmt.Errorf를 사용하여 에러를 감싸줍니다.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc A(x int) (int, error) {\n\tresult, err := B(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"A: %w\", err)\n\t}\n\treturn result * 3, nil\n}\n\nfunc B(x int) (int, error) {\n\tresult, err := C(x)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"B: %w\", err)\n\t}\n\treturn result + 2, nil\n}\n\nfunc C(x int) (int, error) {\n\tif x < 0 {\n\t\treturn 0, fmt.Errorf(\"C: %w\", errors.New(\"음수 값은 허용되지 않습니다\"))\n\t}\n\treturn x * x, nil\n}\n\nfunc main() {\n\t// 잘못된 입력으로 함수 A를 호출합니다.\n\tresult, err := A(-2)\n\tif err == nil {\n\t\tfmt.Println(\"결과:\", result)\n\t} else {\n\t\tfmt.Println(\"에러:\", err)\n\t}\n}\n```\n\n이 프로그램을 실행하면 아래와 같은 출력을 얻게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n오류: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n이제 우리는 콜 스택을 이해했습니다.\n\n하지만 여전히 문제가 있습니다.\n\n## 이 방법의 문제\n\n<div class=\"content-ad\"></div>\n\n에러가 발생한 위치를 알게 되었지만 여전히 어떤 부분이 잘못되었는지는 알 수 없습니다.\n\n# Level 3: 세부적인 에러\n\n에러가 충분히 설명이 되지 않았습니다. 이것을 보다 복잡한 예제로 보여주기 위해 다음과 같이 조금 더 복잡한 예제가 필요합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps:%w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 오류가 반환되면 어떤 작업이 실패했는지 명확하지 않습니다. StepOne인지 StepTwo인지 알 수 없습니다. 동일한 오류인 Error: DoSomething: DoSomethingElseWithTwoSteps: UnderlyingError가 발생합니다.\n\n그 문제를 해결하려면 발생한 구체적인 문제에 대한 문맥을 추가해야 합니다.\n\n```js\nimport (\n \"errors\"\n \"fmt\"\n)\n\nfunc DoSomething() (int, error) {\n result, err := DoSomethingElseWithTwoSteps()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomething: %w\", err)\n }\n return result * 3, nil\n}\n\nfunc DoSomethingElseWithTwoSteps() (int, error) {\n stepOne, err := StepOne()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepOne: %w\", err)\n }\n\n stepTwo, err := StepTwo()\n if err != nil {\n  return 0, fmt.Errorf(\"DoSomethingElseWithTwoSteps: StepTwo: %w\", err)\n }\n\n return stepOne + StepTwo, nil\n}\n```\n\n이제 StepOne이 실패하면 Error: DoSomething: DoSomethingElseWithTwoSteps: StepOne failed: UnderlyingError를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n## 이 방법의 문제점\n\n이 오류는 이제 함수 이름을 사용하여 호출 스택을 표현합니다. 그러나 오류의 본질을 표현하지는 않습니다. 오류는 이야기를 전달해야 합니다.\n\n좋은 예는 HTTP 상태 코드입니다. 404를 받으면 원하는 리소스가 존재하지 않음을 알 수 있습니다.\n\n# 레벨 4: 오류 표식\n\n<div class=\"content-ad\"></div>\n\n에러 센티널은 재사용할 수 있는 미리 정의된 오류 상수입니다.\n\n함수가 실패할 수 있는 원인은 다양할 수 있지만, 일반적으로 4가지 카테고리로 나눌 수 있습니다. \"찾을 수 없음\" 오류, \"이미 존재함\" 오류, \"실패한 전제조건\" 오류, 그리고 \"내부 오류\"입니다. 이는 gRPC 상태 코드에서 영감을 받았습니다. 각 카테고리를 한 문장으로 설명해 드릴게요. \n\n\"찾을 수 없음\" 오류: 호출자가 원하는 리소스가 존재하지 않습니다. 예시: 삭제된 게시물.\n\n\"이미 존재함\" 오류: 호출자가 생성하려는 리소스가 이미 존재합니다. 예시: 같은 이름을 가진 조직.\n\n<div class=\"content-ad\"></div>\n\n실패한 전제조건 오류: 작업 요청자가 실행하려는 작업이 실행 조건을 충족하지 않거나 나쁜 상태에 있습니다. 예시: 잔액이 0원인 계좌에서 출금을 시도하는 경우.\n\n내부 오류: 이러한 카테고리에 속하지 않는 다른 오류로 내부 오류가 발생한 경우입니다.\n\n이러한 종류의 오류만 가지고 있어도 충분하지 않습니다. 호출자에게 어떤 종류의 오류인지 알려주어야 합니다. 이를 위해 오류 센티널 및 errors.Is를 사용합니다.\n\n사용자가 지갑 잔액을 조회하고 업데이트할 수 있는 REST API가 있다고 상상해보세요. 데이터베이스에서 지갑을 조회할 때 오류 센티널을 활용하는 방법을 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\n// 이것들은 에러를 표현하는 상수들입니다.\nvar (\n  WalletDoesNotExistErr = errors.New(\"지갑이 존재하지 않습니다\") // 발견되지 않은 에러 타입\n  CouldNotGetWalletErr = errors.New(\"지갑을 가져올 수 없습니다\") // 내부 에러 타입\n)\n\nfunc getWalletFromDB(id int) (int, error) {\n // 더미 구현: 데이터베이스에서 지갑을 검색하는 시뮬레이션\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return 0, fmt.Errorf(\"%w: Wallet(id:%s)가 존재하지 않습니다: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return 0, fmt.Errorf(\"%w: 데이터베이스에서 Wallet(id:%s)를 가져올 수 없습니다: %w\", CouldNotGetWalletErr, id, err)\n  }\n }\n\n return *balance, nil\n}\n```\n\n이제 이제 REST 핸들러에서 다음과 같이 할 수 있는 것을 보여줍니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```\n\n다른 예제를 살펴보겠습니다. 사용자가 잔액을 업데이트하고자 하는 경우를 보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nimport (\n \"fmt\"\n \"net/http\"\n \"errors\"\n)\n\nvar (\n  WalletDoesNotExistErr = errors.New(\"Wallet does not exist\") // Not Found Error Type\n  CouldNotDebitWalletErr = errors.New(\"Could not debit Wallet\") // Internal Error Type\n  InsufficientWalletBalanceErr = errors.New(\"Insufficient balance in Wallet\") // Failed Precondition Error Type\n)\n\nfunc debitWalletInDB(id int, amount int) error {\n // Dummy implementation: simulate retrieving a wallet from a database\n balance, err := db.get(id)\n\n if err != nil {\n  if balance == nil {\n    return fmt.Errorf(\"%w: Wallet(id:%s) does not exist: %w\", WalletDoesNotExistErr, id, err)\n  } else {\n    return fmt.Errorf(\"%w: could not get Wallet(id:%s) from db: %w\", CouldNotDebitWalletErr, id, err)\n  }\n }\n\n if *balance <= 0 {\n   return 0, fmt.Errorf(\"%w: Wallet(id:%s) balance is 0\", InsufficientWalletBalanceErr, id)\n }\n\n updatedBalance := *balance - amount\n \n // Dummy implementation: simulate updating a wallet in a database\n err := db.update(id, updatedBalance)\n\n if err != nil {\n   return fmt.Errorf(\"%w: could not update Wallet(id:%s) in db: %w\", CouldNotDebitWalletErr, id, err)\n }\n\n return nil\n}\n```\n\n## Using sentinels for better error messages\n\nYou might have noticed that I have a particular way of formatting errors. I prefer structuring an error message in one of two ways:\n\n- `fmt.Errorf(\"%w: description: %w\", Sentinel, err)` or\n- `fmt.Errorf(\"%w: description\", Sentinel)`\n\n<div class=\"content-ad\"></div>\n\n이것은 오류가 발생한 이유와 근본적인 원인을 알려주는 이야기를 만듭니다.\n\n이것은 중요합니다. 왜냐하면 위 예제에서 보는 바와 같이 동일한 유형의 오류가 두 가지 다른 근본적인 이슈로 인해 발생할 수 있기 때문입니다. 따라서 설명이 우리가 정확히 무엇이 잘못되었는지와 그 이유를 정확히 찾게 도와줍니다.\n\n# 보너스: 에러를 기록하는 곳\n\n당신이 발견한 모든 오류를 기록해서는 안 된다는 것에 놀랄지도 모릅니다. 왜냐하면 로그가 아래와 같이 보이기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n에러: C: 음수 값은 허용되지 않습니다\n에러: B: C: 음수 값은 허용되지 않습니다\n에러: A: B: C: 음수 값은 허용되지 않습니다\n```\n\n에러를 기록하는 곳은 반드시 \"처리\"할 수 있는 경우에만 해야 합니다. 여기서 처리란 호출자가 에러를 받아서 무언가 처리하고 계속 실행할 수 있도록 하는 것을 의미합니다.\n\n전형적인 예시는 다시 말해 REST 핸들러일 것입니다. REST 핸들러가 에러를 받으면 해당 에러의 타입을 살펴보고, 적절한 상태 코드로 응답을 보내고 에러 전파를 중단할 수 있습니다.\n\n```js\nfunc getWalletBalance() {\n wallet, err := getWalletFromDB(id)\n\n if err != nil {\n  fmt.Printf(\"%w\", err) // 여기에서는 오직 에러를 로깅합니다\n }\n\n if errors.Is(err, WalletDoesNotExistErr) {\n  // 404 반환\n } else if errors.Is(err, CouldNotGetWalletErr) {\n  // 500 반환\n }\n}\n```","ogImage":{"url":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png"},"coverImage":"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>Go 오류 처리 마스터하기 위한 초보자 가이드</h2>\n<p><img src=\"/assets/img/2024-05-20-ConqueringErrorsinGoAGuidetoReturningandHandlingerrors_0.png\" alt=\"이미지\"></p>\n<h1>레벨 1: if err != nil</h1>\n<p>이것은 오류를 반환하는 가장 간단한 방법입니다. 대부분의 사람들은 이 패턴에 익숙합니다. 오류를 반환할 수 있는 함수를 호출하고, 오류가 nil인지 확인하고, nil이 아니면 오류를 반환합니다.</p>\n<pre><code class=\"hljs language-Go\"><span class=\"hljs-keyword\">import</span> (\n <span class=\"hljs-string\">\"errors\"</span>\n <span class=\"hljs-string\">\"fmt\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doSomething</span><span class=\"hljs-params\">()</span></span> (<span class=\"hljs-type\">float64</span>, <span class=\"hljs-type\">error</span>) {\n result, err := mayReturnError();\n <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, err\n }\n <span class=\"hljs-keyword\">return</span> result, <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<h2>이 방식의 문제점</h2>\n<p>이 방식이 가장 간단하고 사실상 가장 많이 사용되는 방법이지만 중대한 문제점이 있습니다: 컨텍스트 부족. 깊은 호출 스택이 있는 경우 어떤 함수가 오류를 발생시켰는지 알 수 없습니다.</p>\n<p>A() 함수가 B()를 호출하고, B()가 C()를 호출하고, C()가 다음과 같은 오류를 반환하는 호출 스택을 상상해보십시오:</p>\n<pre><code class=\"hljs language-js\">package main\n\n<span class=\"hljs-keyword\">import</span> (\n <span class=\"hljs-string\">\"errors\"</span>\n <span class=\"hljs-string\">\"fmt\"</span>\n)\n\nfunc <span class=\"hljs-title function_\">A</span>(x int) (int, error) {\n result, err := <span class=\"hljs-title function_\">B</span>(x)\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, err\n }\n <span class=\"hljs-keyword\">return</span> result * <span class=\"hljs-number\">3</span>, nil\n}\n\nfunc <span class=\"hljs-title function_\">B</span>(x int) (int, error) {\n result, err := <span class=\"hljs-title function_\">C</span>(x)\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, err\n }\n <span class=\"hljs-keyword\">return</span> result + <span class=\"hljs-number\">2</span>, nil\n}\n\nfunc <span class=\"hljs-title function_\">C</span>(x int) (int, error) {\n <span class=\"hljs-keyword\">if</span> x &#x3C; <span class=\"hljs-number\">0</span> {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"negative value not allowed\"</span>)\n }\n <span class=\"hljs-keyword\">return</span> x * x, nil\n}\n\nfunc <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n <span class=\"hljs-comment\">// Call function A with invalid input</span>\n result, err := <span class=\"hljs-title function_\">A</span>(-<span class=\"hljs-number\">2</span>)\n <span class=\"hljs-keyword\">if</span> err == nil {\n  fmt.<span class=\"hljs-title class_\">Println</span>(<span class=\"hljs-string\">\"결과:\"</span>, result)\n } <span class=\"hljs-keyword\">else</span> {\n  fmt.<span class=\"hljs-title class_\">Println</span>(<span class=\"hljs-string\">\"에러:\"</span>, err)\n }\n}\n</code></pre>\n<p>만약 이 프로그램을 실행하면 다음과 같이 출력됩니다.</p>\n<pre><code class=\"hljs language-js\">에러: negative value not allowed\n</code></pre>\n<p>우리는 호출 스택에서 이 오류가 어디에서 발생했는지에 대한 컨텍스트가 없습니다. 특정 오류 문자열을 찾아 해당 오류가 어디에서 발생했는지를 알아내기 위해 프로그램을 코드 편집기에서 열어야 합니다.</p>\n<h1>레벨 2: 에러 감싸기</h1>\n<p>에러에 대한 컨텍스트를 추가하기 위해 fmt.Errorf를 사용하여 에러를 감싸줍니다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">package</span> main\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">\"errors\"</span>\n\t<span class=\"hljs-string\">\"fmt\"</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">A</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">int</span>)</span></span> (<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">error</span>) {\n\tresult, err := B(x)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.Errorf(<span class=\"hljs-string\">\"A: %w\"</span>, err)\n\t}\n\t<span class=\"hljs-keyword\">return</span> result * <span class=\"hljs-number\">3</span>, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">B</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">int</span>)</span></span> (<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">error</span>) {\n\tresult, err := C(x)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.Errorf(<span class=\"hljs-string\">\"B: %w\"</span>, err)\n\t}\n\t<span class=\"hljs-keyword\">return</span> result + <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">C</span><span class=\"hljs-params\">(x <span class=\"hljs-type\">int</span>)</span></span> (<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">error</span>) {\n\t<span class=\"hljs-keyword\">if</span> x &#x3C; <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.Errorf(<span class=\"hljs-string\">\"C: %w\"</span>, errors.New(<span class=\"hljs-string\">\"음수 값은 허용되지 않습니다\"</span>))\n\t}\n\t<span class=\"hljs-keyword\">return</span> x * x, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\t<span class=\"hljs-comment\">// 잘못된 입력으로 함수 A를 호출합니다.</span>\n\tresult, err := A(<span class=\"hljs-number\">-2</span>)\n\t<span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> {\n\t\tfmt.Println(<span class=\"hljs-string\">\"결과:\"</span>, result)\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\tfmt.Println(<span class=\"hljs-string\">\"에러:\"</span>, err)\n\t}\n}\n</code></pre>\n<p>이 프로그램을 실행하면 아래와 같은 출력을 얻게 됩니다.</p>\n<pre><code class=\"hljs language-js\">오류: <span class=\"hljs-attr\">A</span>: <span class=\"hljs-attr\">B</span>: <span class=\"hljs-attr\">C</span>: 음수 값은 허용되지 않습니다\n</code></pre>\n<p>이제 우리는 콜 스택을 이해했습니다.</p>\n<p>하지만 여전히 문제가 있습니다.</p>\n<h2>이 방법의 문제</h2>\n<p>에러가 발생한 위치를 알게 되었지만 여전히 어떤 부분이 잘못되었는지는 알 수 없습니다.</p>\n<h1>Level 3: 세부적인 에러</h1>\n<p>에러가 충분히 설명이 되지 않았습니다. 이것을 보다 복잡한 예제로 보여주기 위해 다음과 같이 조금 더 복잡한 예제가 필요합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> (\n <span class=\"hljs-string\">\"errors\"</span>\n <span class=\"hljs-string\">\"fmt\"</span>\n)\n\nfunc <span class=\"hljs-title class_\">DoSomething</span>() (int, error) {\n result, err := <span class=\"hljs-title class_\">DoSomethingElseWithTwoSteps</span>()\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"DoSomething: %w\"</span>, err)\n }\n <span class=\"hljs-keyword\">return</span> result * <span class=\"hljs-number\">3</span>, nil\n}\n\nfunc <span class=\"hljs-title class_\">DoSomethingElseWithTwoSteps</span>() (int, error) {\n stepOne, err := <span class=\"hljs-title class_\">StepOne</span>()\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"DoSomethingElseWithTwoSteps:%w\"</span>, err)\n }\n\n stepTwo, err := <span class=\"hljs-title class_\">StepTwo</span>()\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"DoSomethingElseWithTwoSteps: %w\"</span>, err)\n }\n\n <span class=\"hljs-keyword\">return</span> stepOne + <span class=\"hljs-title class_\">StepTwo</span>, nil\n}\n</code></pre>\n<p>이 예시에서 오류가 반환되면 어떤 작업이 실패했는지 명확하지 않습니다. StepOne인지 StepTwo인지 알 수 없습니다. 동일한 오류인 Error: DoSomething: DoSomethingElseWithTwoSteps: UnderlyingError가 발생합니다.</p>\n<p>그 문제를 해결하려면 발생한 구체적인 문제에 대한 문맥을 추가해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> (\n <span class=\"hljs-string\">\"errors\"</span>\n <span class=\"hljs-string\">\"fmt\"</span>\n)\n\nfunc <span class=\"hljs-title class_\">DoSomething</span>() (int, error) {\n result, err := <span class=\"hljs-title class_\">DoSomethingElseWithTwoSteps</span>()\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"DoSomething: %w\"</span>, err)\n }\n <span class=\"hljs-keyword\">return</span> result * <span class=\"hljs-number\">3</span>, nil\n}\n\nfunc <span class=\"hljs-title class_\">DoSomethingElseWithTwoSteps</span>() (int, error) {\n stepOne, err := <span class=\"hljs-title class_\">StepOne</span>()\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"DoSomethingElseWithTwoSteps: StepOne: %w\"</span>, err)\n }\n\n stepTwo, err := <span class=\"hljs-title class_\">StepTwo</span>()\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"DoSomethingElseWithTwoSteps: StepTwo: %w\"</span>, err)\n }\n\n <span class=\"hljs-keyword\">return</span> stepOne + <span class=\"hljs-title class_\">StepTwo</span>, nil\n}\n</code></pre>\n<p>이제 StepOne이 실패하면 Error: DoSomething: DoSomethingElseWithTwoSteps: StepOne failed: UnderlyingError를 반환합니다.</p>\n<h2>이 방법의 문제점</h2>\n<p>이 오류는 이제 함수 이름을 사용하여 호출 스택을 표현합니다. 그러나 오류의 본질을 표현하지는 않습니다. 오류는 이야기를 전달해야 합니다.</p>\n<p>좋은 예는 HTTP 상태 코드입니다. 404를 받으면 원하는 리소스가 존재하지 않음을 알 수 있습니다.</p>\n<h1>레벨 4: 오류 표식</h1>\n<p>에러 센티널은 재사용할 수 있는 미리 정의된 오류 상수입니다.</p>\n<p>함수가 실패할 수 있는 원인은 다양할 수 있지만, 일반적으로 4가지 카테고리로 나눌 수 있습니다. \"찾을 수 없음\" 오류, \"이미 존재함\" 오류, \"실패한 전제조건\" 오류, 그리고 \"내부 오류\"입니다. 이는 gRPC 상태 코드에서 영감을 받았습니다. 각 카테고리를 한 문장으로 설명해 드릴게요.</p>\n<p>\"찾을 수 없음\" 오류: 호출자가 원하는 리소스가 존재하지 않습니다. 예시: 삭제된 게시물.</p>\n<p>\"이미 존재함\" 오류: 호출자가 생성하려는 리소스가 이미 존재합니다. 예시: 같은 이름을 가진 조직.</p>\n<p>실패한 전제조건 오류: 작업 요청자가 실행하려는 작업이 실행 조건을 충족하지 않거나 나쁜 상태에 있습니다. 예시: 잔액이 0원인 계좌에서 출금을 시도하는 경우.</p>\n<p>내부 오류: 이러한 카테고리에 속하지 않는 다른 오류로 내부 오류가 발생한 경우입니다.</p>\n<p>이러한 종류의 오류만 가지고 있어도 충분하지 않습니다. 호출자에게 어떤 종류의 오류인지 알려주어야 합니다. 이를 위해 오류 센티널 및 errors.Is를 사용합니다.</p>\n<p>사용자가 지갑 잔액을 조회하고 업데이트할 수 있는 REST API가 있다고 상상해보세요. 데이터베이스에서 지갑을 조회할 때 오류 센티널을 활용하는 방법을 살펴봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> (\n <span class=\"hljs-string\">\"fmt\"</span>\n <span class=\"hljs-string\">\"net/http\"</span>\n <span class=\"hljs-string\">\"errors\"</span>\n)\n\n<span class=\"hljs-comment\">// 이것들은 에러를 표현하는 상수들입니다.</span>\n<span class=\"hljs-keyword\">var</span> (\n  <span class=\"hljs-title class_\">WalletDoesNotExistErr</span> = errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"지갑이 존재하지 않습니다\"</span>) <span class=\"hljs-comment\">// 발견되지 않은 에러 타입</span>\n  <span class=\"hljs-title class_\">CouldNotGetWalletErr</span> = errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"지갑을 가져올 수 없습니다\"</span>) <span class=\"hljs-comment\">// 내부 에러 타입</span>\n)\n\nfunc <span class=\"hljs-title function_\">getWalletFromDB</span>(id int) (int, error) {\n <span class=\"hljs-comment\">// 더미 구현: 데이터베이스에서 지갑을 검색하는 시뮬레이션</span>\n balance, err := db.<span class=\"hljs-title function_\">get</span>(id)\n\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">if</span> balance == nil {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"%w: Wallet(id:%s)가 존재하지 않습니다: %w\"</span>, <span class=\"hljs-title class_\">WalletDoesNotExistErr</span>, id, err)\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"%w: 데이터베이스에서 Wallet(id:%s)를 가져올 수 없습니다: %w\"</span>, <span class=\"hljs-title class_\">CouldNotGetWalletErr</span>, id, err)\n  }\n }\n\n <span class=\"hljs-keyword\">return</span> *balance, nil\n}\n</code></pre>\n<p>이제 이제 REST 핸들러에서 다음과 같이 할 수 있는 것을 보여줍니다.</p>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">getWalletBalance</span>(<span class=\"hljs-params\"></span>) {\n wallet, err := <span class=\"hljs-title function_\">getWalletFromDB</span>(id)\n\n <span class=\"hljs-keyword\">if</span> errors.<span class=\"hljs-title class_\">Is</span>(err, <span class=\"hljs-title class_\">WalletDoesNotExistErr</span>) {\n  <span class=\"hljs-comment\">// 404 반환</span>\n } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> errors.<span class=\"hljs-title class_\">Is</span>(err, <span class=\"hljs-title class_\">CouldNotGetWalletErr</span>) {\n  <span class=\"hljs-comment\">// 500 반환</span>\n }\n}\n</code></pre>\n<p>다른 예제를 살펴보겠습니다. 사용자가 잔액을 업데이트하고자 하는 경우를 보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> (\n <span class=\"hljs-string\">\"fmt\"</span>\n <span class=\"hljs-string\">\"net/http\"</span>\n <span class=\"hljs-string\">\"errors\"</span>\n)\n\n<span class=\"hljs-keyword\">var</span> (\n  <span class=\"hljs-title class_\">WalletDoesNotExistErr</span> = errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"Wallet does not exist\"</span>) <span class=\"hljs-comment\">// Not Found Error Type</span>\n  <span class=\"hljs-title class_\">CouldNotDebitWalletErr</span> = errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"Could not debit Wallet\"</span>) <span class=\"hljs-comment\">// Internal Error Type</span>\n  <span class=\"hljs-title class_\">InsufficientWalletBalanceErr</span> = errors.<span class=\"hljs-title class_\">New</span>(<span class=\"hljs-string\">\"Insufficient balance in Wallet\"</span>) <span class=\"hljs-comment\">// Failed Precondition Error Type</span>\n)\n\nfunc <span class=\"hljs-title function_\">debitWalletInDB</span>(id int, amount int) error {\n <span class=\"hljs-comment\">// Dummy implementation: simulate retrieving a wallet from a database</span>\n balance, err := db.<span class=\"hljs-title function_\">get</span>(id)\n\n <span class=\"hljs-keyword\">if</span> err != nil {\n  <span class=\"hljs-keyword\">if</span> balance == nil {\n    <span class=\"hljs-keyword\">return</span> fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"%w: Wallet(id:%s) does not exist: %w\"</span>, <span class=\"hljs-title class_\">WalletDoesNotExistErr</span>, id, err)\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"%w: could not get Wallet(id:%s) from db: %w\"</span>, <span class=\"hljs-title class_\">CouldNotDebitWalletErr</span>, id, err)\n  }\n }\n\n <span class=\"hljs-keyword\">if</span> *balance &#x3C;= <span class=\"hljs-number\">0</span> {\n   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"%w: Wallet(id:%s) balance is 0\"</span>, <span class=\"hljs-title class_\">InsufficientWalletBalanceErr</span>, id)\n }\n\n updatedBalance := *balance - amount\n \n <span class=\"hljs-comment\">// Dummy implementation: simulate updating a wallet in a database</span>\n err := db.<span class=\"hljs-title function_\">update</span>(id, updatedBalance)\n\n <span class=\"hljs-keyword\">if</span> err != nil {\n   <span class=\"hljs-keyword\">return</span> fmt.<span class=\"hljs-title class_\">Errorf</span>(<span class=\"hljs-string\">\"%w: could not update Wallet(id:%s) in db: %w\"</span>, <span class=\"hljs-title class_\">CouldNotDebitWalletErr</span>, id, err)\n }\n\n <span class=\"hljs-keyword\">return</span> nil\n}\n</code></pre>\n<h2>Using sentinels for better error messages</h2>\n<p>You might have noticed that I have a particular way of formatting errors. I prefer structuring an error message in one of two ways:</p>\n<ul>\n<li><code>fmt.Errorf(\"%w: description: %w\", Sentinel, err)</code> or</li>\n<li><code>fmt.Errorf(\"%w: description\", Sentinel)</code></li>\n</ul>\n<p>이것은 오류가 발생한 이유와 근본적인 원인을 알려주는 이야기를 만듭니다.</p>\n<p>이것은 중요합니다. 왜냐하면 위 예제에서 보는 바와 같이 동일한 유형의 오류가 두 가지 다른 근본적인 이슈로 인해 발생할 수 있기 때문입니다. 따라서 설명이 우리가 정확히 무엇이 잘못되었는지와 그 이유를 정확히 찾게 도와줍니다.</p>\n<h1>보너스: 에러를 기록하는 곳</h1>\n<p>당신이 발견한 모든 오류를 기록해서는 안 된다는 것에 놀랄지도 모릅니다. 왜냐하면 로그가 아래와 같이 보이기 때문입니다.</p>\n<pre><code class=\"hljs language-js\">에러: <span class=\"hljs-attr\">C</span>: 음수 값은 허용되지 않습니다\n에러: <span class=\"hljs-attr\">B</span>: <span class=\"hljs-attr\">C</span>: 음수 값은 허용되지 않습니다\n에러: <span class=\"hljs-attr\">A</span>: <span class=\"hljs-attr\">B</span>: <span class=\"hljs-attr\">C</span>: 음수 값은 허용되지 않습니다\n</code></pre>\n<p>에러를 기록하는 곳은 반드시 \"처리\"할 수 있는 경우에만 해야 합니다. 여기서 처리란 호출자가 에러를 받아서 무언가 처리하고 계속 실행할 수 있도록 하는 것을 의미합니다.</p>\n<p>전형적인 예시는 다시 말해 REST 핸들러일 것입니다. REST 핸들러가 에러를 받으면 해당 에러의 타입을 살펴보고, 적절한 상태 코드로 응답을 보내고 에러 전파를 중단할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">getWalletBalance</span>(<span class=\"hljs-params\"></span>) {\n wallet, err := <span class=\"hljs-title function_\">getWalletFromDB</span>(id)\n\n <span class=\"hljs-keyword\">if</span> err != nil {\n  fmt.<span class=\"hljs-title class_\">Printf</span>(<span class=\"hljs-string\">\"%w\"</span>, err) <span class=\"hljs-comment\">// 여기에서는 오직 에러를 로깅합니다</span>\n }\n\n <span class=\"hljs-keyword\">if</span> errors.<span class=\"hljs-title class_\">Is</span>(err, <span class=\"hljs-title class_\">WalletDoesNotExistErr</span>) {\n  <span class=\"hljs-comment\">// 404 반환</span>\n } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> errors.<span class=\"hljs-title class_\">Is</span>(err, <span class=\"hljs-title class_\">CouldNotGetWalletErr</span>) {\n  <span class=\"hljs-comment\">// 500 반환</span>\n }\n}\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}