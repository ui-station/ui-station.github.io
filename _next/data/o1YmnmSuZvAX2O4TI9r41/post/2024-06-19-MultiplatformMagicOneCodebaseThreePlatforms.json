{"pageProps":{"post":{"title":"마법같은 멀티플랫폼 하나의 코드베이스로 세 플랫폼 이용하기","description":"","date":"2024-06-19 14:10","slug":"2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms","content":"\n\n\n![이미지](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png)\n\nCompose Multiplatform은 개발자에게 뛰어난 가능성의 세계를 열어주어 안드로이드와 iOS용 네이티브 모습을 하나의 코드베이스로 구축할 수 있게 합니다. 이러한 앱에 인증을 통합하는 것은 어렵게 느껴질 수 있지만, 이 기사에서는 Firebase REST API 인증을 Compose Multiplatform과 통합하는 단계와 혜택을 탐색할 것입니다.\n\n# 왜 Firebase REST API를 사용하는가?\n\n우리는 Android, iOS 및 Web 플랫폼용 다양한 Firebase SDK가 있음을 알고 있지만 Compose Multiplatform용 안정적인 SDK는 없습니다. 또한, 다양한 Compose Multiplatform 예제에서 사용 사례를 보여주기 위해 REST API를 사용하는 것을 보았습니다. 따라서 하나의 코드베이스를 사용하고 여러 플랫폼을 대상으로 하기 위해 Firebase REST API를 인증에 사용하는 것을 선호했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 준비물:\n\n- Compose Multiplatform 플러그인이 설치된 Android Studio 또는 IntelliJ IDEA.\n- iOS 앱을 실행하기 위한 Xcode.\n- Firebase 프로젝트.\n- 프로젝트에서 Firebase Authentication이 활성화되어 있어야 합니다.\n\n# 단계 1: Compose Multiplatform 프로젝트 생성\n\nCompose Multiplatform 프로젝트를 생성하려면 Kotlin Multiplatform Wizard를 사용할 수 있습니다. 이는 우리가 타깃팅하는 플랫폼을 선택할 수 있게 해줍니다. 이 프로젝트에서는 Android, iOS 및 데스크톱 플랫폼을 선택할 것입니다. 플랫폼을 선택하고 나면 프로젝트를 다운로드하여 선호하는 IDE에서 열 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_1.png)\n\n# 단계 2: 인증을 위한 UI 생성\n\n이 프로젝트에서는 Email/Password 인증만 대상으로 하고 시작하므로 composeApp/src/commonMain/kotlin/authentication/AuthenticationView.kt 파일에서는 로그인 및 회원가입 뷰를 포함한 UI가 제공됩니다.\n\n![image](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 단계 3: Firebase 프로젝트 구성하기.\n\nFirebase 프로젝트를 구성하면 프로젝트 설정을 방문하여 Firebase REST API와 함께 사용할 API Key를 얻을 수 있습니다. 이를 사용하여 사용자를 인증할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_3.png)\n\n# 단계 4: 프로젝트에서 Ktor 구성하기.\n\n<div class=\"content-ad\"></div>\n\nKotlin의 Ktor 프레임워크는 강력하고 유연한 HTTP 클라이언트를 제공하여 외부 API와의 상호 작용을 원활하게 만들어줍니다. 구현에 앞서 필요한 종속성이 포함된 Kotlin 프로젝트를 설정했는지 확인해보세요. Ktor의 클라이언트 라이브러리를 포함하여 프로젝트에 Ktor 클라이언트를 추가할 수 있습니다. 이를 위해 libs.versions.toml 파일 내 gradle 폴더에 다음 종속성을 포함하면 됩니다.\n\n\n[versions]\n...\nkotlin = \"1.9.21\"\nkotlinx-coroutines = \"1.7.3\"\nktor = \"2.3.6\"\n\n[libraries]\n....\nktor-serialization-kotlinx-json = { module = \"io.ktor:ktor-serialization-kotlinx-json\", version.ref = \"ktor\" }\nktor-client-core = { module = \"io.ktor:ktor-client-core\", version.ref = \"ktor\" }\nktor-client-darwin = { module = \"io.ktor:ktor-client-darwin\", version.ref = \"ktor\" }\nktor-client-okhttp = { module = \"io.ktor:ktor-client-okhttp\", version.ref = \"ktor\" }\nktor-client-content-negotiation = { module = \"io.ktor:ktor-client-content-negotiation\", version.ref = \"ktor\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nandroidLibrary = { id = \"com.android.library\", version.ref = \"agp\" }\njetbrainsCompose = { id = \"org.jetbrains.compose\", version.ref = \"compose-plugin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nkotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }\n\n\nlibs.versions.toml 파일 내의 라이브러리를 추가했으면, build.gradle.kts 파일의 composeApp 내부에 종속성을 추가하고 프로젝트를 동기화해주면 됩니다:\n\n\nandroidMain.dependencies {\n    ...\n    implementation(libs.ktor.client.okhttp)\n}\ncommonMain.dependencies {\n    ...\n    implementation(libs.ktor.client.core)\n    implementation(libs.ktor.client.content.negotiation)\n    implementation(libs.ktor.serialization.kotlinx.json)\n}\ndesktopMain.dependencies {\n    ..\n    implementation(libs.ktor.client.okhttp)\n}\n\n\n<div class=\"content-ad\"></div>\n\n# 단계 5: Firebase REST API 호출하기\n\nKtor 라이브러리가 추가되고 프로젝트가 동기화된 후, Ktor 함수를 사용하여 Firebase REST API를 호출할 수 있습니다. 그 전에 HttpClient를 초기화하여 API 요청을 만들 수 있어야 합니다. 그래서, AuthenticationViewModel.kt 파일을 생성하여 모든 백엔드 작업을 처리하고 아래 코드를 추가합니다.\n\n```js\nprivate val httpClient = HttpClient() {\n    install(ContentNegotiation) {\n        json()\n    }\n}\n```\n\n## 사용자 생성 정복하기:\n\n<div class=\"content-ad\"></div>\n\n이제 새로운 사용자를 생성해 봅시다! https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=$'API_KEY' 엔드포인트로 Ktor 클라이언트 호출을 만들어 보겠습니다. 사용자 데이터(이메일 및 비밀번호)를 코틀린 직렬화를 사용하여 JSON 형식으로 직렬화해야 합니다. 데이터와 함께 POST 요청을 보내고 Firebase 응답을 기다리세요. 사용자가 성공적으로 생성되면 응답을 구문 분석하여 사용자 ID 및 기타 관련 정보를 추출하세요.\nAuthenticationViewModel.kt에 추가된 signUp() 메서드의 아래 코드 스니펫을 확인해보세요.\n\n```js\nfun signUp(\n        email: String,\n        password: String,\n        confirmPassword: String,\n        onCompletion: onCompletion\n    ) {\n        if (password == confirmPassword) {\n            viewModelScope.launch {\n                val responseBody = httpClient\n                    .post(\"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${API_KEY}\") {\n                        header(\"Content-Type\", \"application/json\")\n                        parameter(\"email\", email)\n                        parameter(\"password\", password)\n                        parameter(\"returnSecureToken\", true)\n                    }\n                if (responseBody.status.value in 200..299) {\n                    val response = Json { ignoreUnknownKeys = true }\n                        .decodeFromString<AuthResponse>(responseBody.bodyAsText())\n                    onCompletion.onSuccess(response.idToken)\n                } else {\n                    onCompletion.onError(Exception(responseBody.bodyAsText()))\n                }\n            }\n        } else {\n            onCompletion.onError(Exception(\"Password doesn't match\"))\n        }\n    }\n```\n\n## 로그인 퀘스트:\n\n이제 로그인에 도전해 봅시다! 사용자 생성과 유사하게, https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=$'API_KEY' 엔드포인트로의 Ktor 클라이언트 호출을 구성해보세요. 다시 한번 사용자 자격 증명(이메일 및 비밀번호)을 직렬화하고 POST 요청을 보내세요. 응답을 구문 분석하여 ID 토큰을 얻어 사용자 신원을 확인하고 보호된 리소스에 액세스하는 데 필수적인 요소를 확보하세요.\nAuthenticationViewModel.kt에 추가된 login() 메서드의 아래 코드 스니펫을 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nfun login(\n    email: String,\n    password: String,\n    onCompletion: onCompletion\n) {\n    viewModelScope.launch {\n        val responseBody = httpClient\n            .post(\"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${API_KEY}\") {\n                header(\"Content-Type\", \"application/json\")\n                parameter(\"email\", email)\n                parameter(\"password\", password)\n                parameter(\"returnSecureToken\", true)\n            }\n        if (responseBody.status.value in 200..299) {\n            val response = Json { ignoreUnknownKeys = true }\n                .decodeFromString(responseBody.bodyAsText())\n            storeUserDetails(response)\n            onCompletion.onSuccess(response.idToken)\n        } else {\n            onCompletion.onError(Exception(responseBody.bodyAsText()))\n        }\n    }\n}\n```\n\n# 단계 6: 캐시 지원을 위해 SQLDelight 추가.\n\nSQLDelight는 플랫폼에 중립적인 SQL 쿼리를 작성하기 위한 강력한 코틀린 라이브러리로, 캐싱과 결합하여 앱의 효율성을 높이는 동적 이중체를 형성합니다. 여기서는 login 및 signUp API 호출의 응답에서 얻은 refreshToken을 저장할 것입니다. 따라서 사용자가 앱을 다시 열 때 인증을 요청하지 않을 것입니다.\n\n## SQLDelight 종속성 설정\n\n\n<div class=\"content-ad\"></div>\n\n먼저 gradle 폴더 내 libs.versions.toml 파일에 필요한 SQLDelight 종속성 및 플러그인을 추가해야 합니다.\n\n```js\n[versions]\n...\n...\nsqlDelight = \"2.0.1\"\n\n[libraries]\n...\n...\nsqldelight-androidDriver = { module = \"app.cash.sqldelight:android-driver\", version.ref = \"sqlDelight\" }\nsqldelight-jvmDriver = { module = \"app.cash.sqldelight:sqlite-driver\", version.ref = \"sqlDelight\" }\nsqldelight-nativeDriver = { module = \"app.cash.sqldelight:native-driver\", version.ref = \"sqlDelight\" }\nsqldelight-coroutines = { module = \"app.cash.sqldelight:coroutines-extensions\", version.ref = \"sqlDelight\" }\nsqldelight-primitiveAdapters = { module = \"app.cash.sqldelight:coroutines-extensions\", version.ref = \"sqlDelight\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nandroidLibrary = { id = \"com.android.library\", version.ref = \"agp\" }\njetbrainsCompose = { id = \"org.jetbrains.compose\", version.ref = \"compose-plugin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nkotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }\nsqlDelight = { id = \"app.cash.sqldelight\", version.ref = \"sqlDelight\" }\n```\n\n다음 단계는 프로젝트 수준의 build.gradle.kts 파일에 플러그인을 추가하는 것입니다.\n\n```js\nplugins {\n    // this is necessary to avoid the plugins to be loaded multiple times\n    // in each subproject's classloader\n    alias(libs.plugins.androidApplication) apply false\n    alias(libs.plugins.androidLibrary) apply false\n    alias(libs.plugins.jetbrainsCompose) apply false\n    alias(libs.plugins.kotlinMultiplatform) apply false\n    //SQLDelight Plugin\n    alias(libs.plugins.sqlDelight) apply false\n}\n```\n\n<div class=\"content-ad\"></div>\n\n마지막 단계로는 composeApp build.gradle.kts 파일에서 SQLDelight를 구성해야 합니다. 여기서는 필요한 플랫폼에 따라 종속성을 추가하고 SQLDelight 데이터베이스의 이름을 추가할 것입니다. 매개변수가 포함된 데이터베이스 목록을 포함하는 sqlDelight 블록을 맨 끝에 볼 수 있을 것입니다.\n\n```js\nimport org.jetbrains.compose.ExperimentalComposeLibrary\nimport org.jetbrains.compose.desktop.application.dsl.TargetFormat\n\nplugins {\n    alias(libs.plugins.kotlinMultiplatform)\n    alias(libs.plugins.androidApplication)\n    alias(libs.plugins.jetbrainsCompose)\n    alias(libs.plugins.kotlinxSerialization)\n    alias(libs.plugins.sqlDelight)\n}\n\nkotlin {\n\n    androidTarget {\n        compilations.all {\n            kotlinOptions {\n                jvmTarget = \"1.8\"\n            }\n        }\n    }\n\n    \n    jvm(\"desktop\")\n    \n    listOf(\n        iosX64(),\n        iosArm64(),\n        iosSimulatorArm64()\n    ).forEach { iosTarget ->\n        iosTarget.binaries.framework {\n            baseName = \"ComposeApp\"\n            // This should be set to false to run on iOS\n            isStatic = false\n            // Add it to avoid sqllite3 issues in iOS\n            linkerOpts.add(\"-lsqlite3\")\n        }\n    }\n    \n    sourceSets {\n        val desktopMain by getting\n\n        androidMain.dependencies {\n            implementation(libs.compose.ui.tooling.preview)\n            implementation(libs.androidx.activity.compose)\n            implementation(libs.ktor.client.okhttp)\n            //SqlDelight for Android\n            implementation(libs.sqldelight.androidDriver)\n        }\n        commonMain.dependencies {\n            implementation(compose.runtime)\n            implementation(compose.foundation)\n            implementation(compose.material)\n            implementation(compose.ui)\n            @OptIn(ExperimentalComposeLibrary::class)\n            implementation(compose.components.resources)\n            //Ktor\n            implementation(libs.ktor.client.core)\n            implementation(libs.ktor.client.content.negotiation)\n            implementation(libs.ktor.serialization.kotlinx.json)\n            //Moko MVVM\n            implementation(libs.moko.mvvm.core)\n            implementation(libs.moko.mvvm.compose)\n            //Kamel\n            implementation(libs.kamel)\n            // Navigator\n            implementation(libs.voyager.navigator)\n            //SqlDelight for common\n            implementation(libs.sqldelight.coroutines)\n            implementation(libs.sqldelight.primitiveAdapters)\n        }\n        desktopMain.dependencies {\n            implementation(compose.desktop.currentOs)\n            implementation(libs.kotlinx.coroutines.swing)\n            implementation(libs.ktor.client.okhttp)\n            //SqlDelight for jvm\n            implementation(libs.sqldelight.jvmDriver)\n        }\n        iosMain.dependencies {\n            //SqlDelight for iOS\n            implementation(libs.sqldelight.nativeDriver)\n        }\n    }\n}\n\nsqldelight {\n    databases {\n        //Note: Name of your Database and .sq file should be same\n        create(\"Database\") {\n            packageName.set(\"com.dwarshb.firebaseauthentication\")\n        }\n    }\n    // Add this line to avoid library linking issues\n    linkSqlite = true\n}\n\nandroid {\n    ...\n}\n\ncompose.desktop {\n    ...\n}\n```\n\n## 쿼리용 Database.sq 파일 만들기\n\n다음 단계는 모든 필요한 SQL 쿼리를 포함하는 .sq 파일을 작성하는 것입니다. 기본적으로 SQLDelight 플러그인은 sqldelight 폴더 내의 패키지 폴더에서 .sq를 읽습니다. 해당 폴더는 직접 commainMain 폴더 내에 있을 것입니다.\nDatabase.sq 파일이 위치하는 폴더 구조 스크린샷은 아래에서 확인하실 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_4.png\" />\n\n다음 코드를 Database.sq 파일에 추가하세요. 이 파일은 createTable, insertUser, removeAllUsers, getAllUsers 등의 쿼리를 포함합니다.\n\n프로젝트를 컴파일하면 생성된 Kotlin 코드가 composeApp/build/generated/sqldelight 디렉토리에 저장됩니다. 또는 터미널에서 ./gradlew generateSqlDelightInterface 명령어를 사용하여 sqldelight 코틀린 코드를 생성할 수도 있습니다.\n\n## 데이터베이스 드라이버 생성\n\n\n<div class=\"content-ad\"></div>\n\nSQLDelight은 SQLite 드라이버의 여러 플랫폼별 구현을 제공하므로 각 플랫폼에 대해 별도로 생성해야 합니다. 이를 기대 선언과 실제 선언을 사용하여 수행할 수 있습니다.\n\ncomposeApp/src/commonMain/kotlin에서 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 만드세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\n\nexpect class DriverFactory {\n    fun createDriver(): SqlDriver\n}\n```\n\n이제 각 대상 플랫폼에 대해 이를 구현해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n안드로이드에서는 AndroidSqliteDriver 클래스가 SQLite 드라이버를 구현합니다.\n그래서 composeApp/src/androidMain/kotlin에서 패키지를 만들어 그 안에 DriverFactory.kt 클래스를 생성해주세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport android.content.Context\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.android.AndroidSqliteDriver\n\nactual class DriverFactory(var appContext: Context) {\n\n    actual fun createDriver(): SqlDriver {\n        return AndroidSqliteDriver(Database.Schema, appContext, \"firebase.db\")\n    }\n}\n```\n\n이제 Android에서 작동하도록 하기 위해 composeApp/src/androidMain/kotlin에 있는 MainActivity.kt 파일에서 해당 인스턴스를 생성해야 합니다.\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        //Android용 DriverFactory의 인스턴스 생성\n        val driverFactory = DriverFactory(this)\n        setContent {\n            App(driverFactory.createDriver())\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\niOS에서 SQLite 드라이버 구현은 NativeSqliteDriver 클래스입니다.\n그래서 composeApp/src/iosMain/kotlin에 패키지를 만들고 내부에 DriverFactory.kt 클래스를 만들어 주세요.\n\n```kotlin\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.native.NativeSqliteDriver\n\nactual class DriverFactory {\n    actual fun createDriver(): SqlDriver {\n        return NativeSqliteDriver(Database.Schema, \"firebase.db\")\n    }\n}\n```\n\n이제 MainViewController.kt 파일을 만들어서 iOS에서 작업할 수 있도록 인스턴스를 만들어주세요. 이 파일은 composeApp/src/iosMain/kotlin에 있습니다.\n\n```kotlin\nimport androidx.compose.ui.window.ComposeUIViewController\nimport com.dwarshb.firebaseauthentication.DriverFactory\n\nfun MainViewController() = ComposeUIViewController {\n    val driverFactory = DriverFactory()\n    App(driverFactory.createDriver())\n}\n```\n\n<div class=\"content-ad\"></div>\n\n데스크톱 환경에서는 SQLite 드라이버 구현이 JdbcSqliteDriver 클래스입니다.\n그래서 composeApp/src/desktopMain/kotlin에 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 생성해주세요.\n\n```js\npackage com.dwarshb.firebaseauthentication\n\nimport app.cash.sqldelight.db.SqlDriver\nimport app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver\nimport java.io.File\n\nactual class DriverFactory {\n    actual fun createDriver(): SqlDriver {\n        val databasePath = File(System.getProperty(\"java.io.tmpdir\"), \"firebase.db\")\n        val driver: SqlDriver = JdbcSqliteDriver(url = \"jdbc:sqlite:${databasePath.absolutePath}\")\n        Database.Schema.create(driver)\n        return driver\n    }\n}\n```\n\n이제 데스크톱에서 작동하도록 composeApp/src/desktopMain/kotlin의 main.kt 파일에 인스턴스를 생성해야 합니다.\n\n```js\nimport androidx.compose.ui.window.Window\nimport androidx.compose.ui.window.application\nimport com.dwarshb.firebaseauthentication.DriverFactory\n\nfun main() = application {\n    Window(onCloseRequest = ::exitApplication, title = \"FirebaseAuthentication\") {\n        val driverFactory = DriverFactory()\n        App(driverFactory.createDriver())\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_5.png\" />\n\n모든 플랫폼에서 DriverFactory를 구성하고 위 단계를 모두 따라왔다면, App() 함수를 수정하고 SqlDriver를 매개변수로 추가해야 합니다. 각 플랫폼에서 SqlDriver의 인스턴스를 가져올 수 있는 유일한 방법이기 때문입니다. 그래서 composeApp/src/commanMain/kotlin/App.kt 안에 다음과 같이 작성하세요.\n\n```js\n@Composable\nfun App(sqlDriver: SqlDriver) {\n    val authenticationViewModel = AuthenticationViewModel(sqlDriver)\n    \n    MaterialTheme {\n      ...   \n    }\n}\n```\n\n# 단계 7: SQLDelight 쿼리 구성하기\n\n<div class=\"content-ad\"></div>\n\n이 단계에서는 Firebase Authentication API에서 받은 토큰을 저장하여 사용자 세션을 유지하기 위해 insertUser 쿼리를 사용할 예정입니다. 또한 로컬 데이터베이스에 저장된 토큰을 얻기 위해 selectAllUser 쿼리를 사용할 것입니다. AuthenticationViewModel.kt 내에서 먼저 데이터베이스를 초기화할 것입니다.\n\n```js\n    var databaseQuery : DatabaseQueries\n\n    val database = Database(sqlDriver)\n    databaseQuery = database.databaseQueries\n```\n\n이제 API에서 받은 응답을 저장할 storeUserDetails() 메서드를 만들 것입니다. 이 메서드는 로컬 데이터베이스에 정보를 저장하는 데 insertUser 쿼리를 사용합니다. AuthenticationViewModel.kt 파일의 login()이나 signUp() 메서드 내에 이 메서드를 추가할 수 있습니다.\n\n```js\ninternal fun storeUserDetails(response: AuthResponse) {\n        databaseQuery.insertUser(\n            response.idToken, response.email, response.refreshToken,\n            response.email\n        )\n    }\n```\n\n<div class=\"content-ad\"></div>\n\n세션 유지를 위해 시스템에 이미 토큰이 로컬 데이터베이스에 있는지 확인해야 합니다. 그래서 우리는 selectAllUsers 쿼리를 사용하여 로컬 데이터베이스에 저장된 토큰을 확인하는 checkSession()을 생성할 것입니다.\n\n```kotlin\ninternal fun checkSession(onCompletion: onCompletion) {\n    for(user in databaseQuery.selectAllUsers().executeAsList()) {\n        if (user != null) {\n            onCompletion.onSuccess(user.refreshToken.toString())\n        } else {\n            onCompletion.onError(Exception(\"세션을 찾을 수 없습니다\"))\n        }\n    }\n}\n```\n\n우리는 checkSession() 메서드를 사용하여 결과에 따라 UI를 업데이트할 수 있습니다. 예를 들어, 토큰이 있는 경우 onSuccess 내에서 앱을 MainScreen으로 이동시키고, 그렇지 않은 경우 AuthenticationView 화면이 표시됩니다.\n\n# 데모\n\n<div class=\"content-ad\"></div>\n\n아래의 Github 링크에서 전체 코드를 확인해보세요.\n\n# 참조 링크:\n\n- https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ktor-sqldelight.html#build-an-sdk\n- https://firebase.google.com/docs/reference/rest/auth#section-api-usage","ogImage":{"url":"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png"},"coverImage":"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png","tag":["Tech"],"readingTime":18},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_0.png\" alt=\"이미지\"></p>\n<p>Compose Multiplatform은 개발자에게 뛰어난 가능성의 세계를 열어주어 안드로이드와 iOS용 네이티브 모습을 하나의 코드베이스로 구축할 수 있게 합니다. 이러한 앱에 인증을 통합하는 것은 어렵게 느껴질 수 있지만, 이 기사에서는 Firebase REST API 인증을 Compose Multiplatform과 통합하는 단계와 혜택을 탐색할 것입니다.</p>\n<h1>왜 Firebase REST API를 사용하는가?</h1>\n<p>우리는 Android, iOS 및 Web 플랫폼용 다양한 Firebase SDK가 있음을 알고 있지만 Compose Multiplatform용 안정적인 SDK는 없습니다. 또한, 다양한 Compose Multiplatform 예제에서 사용 사례를 보여주기 위해 REST API를 사용하는 것을 보았습니다. 따라서 하나의 코드베이스를 사용하고 여러 플랫폼을 대상으로 하기 위해 Firebase REST API를 인증에 사용하는 것을 선호했습니다.</p>\n<h1>준비물:</h1>\n<ul>\n<li>Compose Multiplatform 플러그인이 설치된 Android Studio 또는 IntelliJ IDEA.</li>\n<li>iOS 앱을 실행하기 위한 Xcode.</li>\n<li>Firebase 프로젝트.</li>\n<li>프로젝트에서 Firebase Authentication이 활성화되어 있어야 합니다.</li>\n</ul>\n<h1>단계 1: Compose Multiplatform 프로젝트 생성</h1>\n<p>Compose Multiplatform 프로젝트를 생성하려면 Kotlin Multiplatform Wizard를 사용할 수 있습니다. 이는 우리가 타깃팅하는 플랫폼을 선택할 수 있게 해줍니다. 이 프로젝트에서는 Android, iOS 및 데스크톱 플랫폼을 선택할 것입니다. 플랫폼을 선택하고 나면 프로젝트를 다운로드하여 선호하는 IDE에서 열 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_1.png\" alt=\"image\"></p>\n<h1>단계 2: 인증을 위한 UI 생성</h1>\n<p>이 프로젝트에서는 Email/Password 인증만 대상으로 하고 시작하므로 composeApp/src/commonMain/kotlin/authentication/AuthenticationView.kt 파일에서는 로그인 및 회원가입 뷰를 포함한 UI가 제공됩니다.</p>\n<p><img src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_2.png\" alt=\"image\"></p>\n<h1>단계 3: Firebase 프로젝트 구성하기.</h1>\n<p>Firebase 프로젝트를 구성하면 프로젝트 설정을 방문하여 Firebase REST API와 함께 사용할 API Key를 얻을 수 있습니다. 이를 사용하여 사용자를 인증할 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-06-19-MultiplatformMagicOneCodebaseThreePlatforms_3.png\" alt=\"이미지\"></p>\n<h1>단계 4: 프로젝트에서 Ktor 구성하기.</h1>\n<p>Kotlin의 Ktor 프레임워크는 강력하고 유연한 HTTP 클라이언트를 제공하여 외부 API와의 상호 작용을 원활하게 만들어줍니다. 구현에 앞서 필요한 종속성이 포함된 Kotlin 프로젝트를 설정했는지 확인해보세요. Ktor의 클라이언트 라이브러리를 포함하여 프로젝트에 Ktor 클라이언트를 추가할 수 있습니다. 이를 위해 libs.versions.toml 파일 내 gradle 폴더에 다음 종속성을 포함하면 됩니다.</p>\n<p>[versions]\n...\nkotlin = \"1.9.21\"\nkotlinx-coroutines = \"1.7.3\"\nktor = \"2.3.6\"</p>\n<p>[libraries]\n....\nktor-serialization-kotlinx-json = { module = \"io.ktor:ktor-serialization-kotlinx-json\", version.ref = \"ktor\" }\nktor-client-core = { module = \"io.ktor:ktor-client-core\", version.ref = \"ktor\" }\nktor-client-darwin = { module = \"io.ktor:ktor-client-darwin\", version.ref = \"ktor\" }\nktor-client-okhttp = { module = \"io.ktor:ktor-client-okhttp\", version.ref = \"ktor\" }\nktor-client-content-negotiation = { module = \"io.ktor:ktor-client-content-negotiation\", version.ref = \"ktor\" }</p>\n<p>[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nandroidLibrary = { id = \"com.android.library\", version.ref = \"agp\" }\njetbrainsCompose = { id = \"org.jetbrains.compose\", version.ref = \"compose-plugin\" }\nkotlinMultiplatform = { id = \"org.jetbrains.kotlin.multiplatform\", version.ref = \"kotlin\" }\nkotlinxSerialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }</p>\n<p>libs.versions.toml 파일 내의 라이브러리를 추가했으면, build.gradle.kts 파일의 composeApp 내부에 종속성을 추가하고 프로젝트를 동기화해주면 됩니다:</p>\n<p>androidMain.dependencies {\n...\nimplementation(libs.ktor.client.okhttp)\n}\ncommonMain.dependencies {\n...\nimplementation(libs.ktor.client.core)\nimplementation(libs.ktor.client.content.negotiation)\nimplementation(libs.ktor.serialization.kotlinx.json)\n}\ndesktopMain.dependencies {\n..\nimplementation(libs.ktor.client.okhttp)\n}</p>\n<h1>단계 5: Firebase REST API 호출하기</h1>\n<p>Ktor 라이브러리가 추가되고 프로젝트가 동기화된 후, Ktor 함수를 사용하여 Firebase REST API를 호출할 수 있습니다. 그 전에 HttpClient를 초기화하여 API 요청을 만들 수 있어야 합니다. 그래서, AuthenticationViewModel.kt 파일을 생성하여 모든 백엔드 작업을 처리하고 아래 코드를 추가합니다.</p>\n<pre><code class=\"hljs language-js\">private val httpClient = <span class=\"hljs-title class_\">HttpClient</span>() {\n    <span class=\"hljs-title function_\">install</span>(<span class=\"hljs-params\">ContentNegotiation</span>) {\n        <span class=\"hljs-title function_\">json</span>()\n    }\n}\n</code></pre>\n<h2>사용자 생성 정복하기:</h2>\n<p>이제 새로운 사용자를 생성해 봅시다! <a href=\"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=$&#x27;API_KEY\" rel=\"nofollow\" target=\"_blank\">https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=$'API_KEY</a>' 엔드포인트로 Ktor 클라이언트 호출을 만들어 보겠습니다. 사용자 데이터(이메일 및 비밀번호)를 코틀린 직렬화를 사용하여 JSON 형식으로 직렬화해야 합니다. 데이터와 함께 POST 요청을 보내고 Firebase 응답을 기다리세요. 사용자가 성공적으로 생성되면 응답을 구문 분석하여 사용자 ID 및 기타 관련 정보를 추출하세요.\nAuthenticationViewModel.kt에 추가된 signUp() 메서드의 아래 코드 스니펫을 확인해보세요.</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title function_\">signUp</span>(<span class=\"hljs-params\">\n        email: <span class=\"hljs-built_in\">String</span>,\n        password: <span class=\"hljs-built_in\">String</span>,\n        confirmPassword: <span class=\"hljs-built_in\">String</span>,\n        onCompletion: onCompletion\n    </span>) {\n        <span class=\"hljs-keyword\">if</span> (password == confirmPassword) {\n            viewModelScope.<span class=\"hljs-property\">launch</span> {\n                val responseBody = httpClient\n                    .<span class=\"hljs-title function_\">post</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${API_KEY}\"</span></span>) {\n                        <span class=\"hljs-title function_\">header</span>(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>)\n                        <span class=\"hljs-title function_\">parameter</span>(<span class=\"hljs-string\">\"email\"</span>, email)\n                        <span class=\"hljs-title function_\">parameter</span>(<span class=\"hljs-string\">\"password\"</span>, password)\n                        <span class=\"hljs-title function_\">parameter</span>(<span class=\"hljs-string\">\"returnSecureToken\"</span>, <span class=\"hljs-literal\">true</span>)\n                    }\n                <span class=\"hljs-keyword\">if</span> (responseBody.<span class=\"hljs-property\">status</span>.<span class=\"hljs-property\">value</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">200.</span><span class=\"hljs-number\">.299</span>) {\n                    val response = <span class=\"hljs-title class_\">Json</span> { ignoreUnknownKeys = <span class=\"hljs-literal\">true</span> }\n                        .<span class=\"hljs-property\">decodeFromString</span>&#x3C;<span class=\"hljs-title class_\">AuthResponse</span>>(responseBody.<span class=\"hljs-title function_\">bodyAsText</span>())\n                    onCompletion.<span class=\"hljs-title function_\">onSuccess</span>(response.<span class=\"hljs-property\">idToken</span>)\n                } <span class=\"hljs-keyword\">else</span> {\n                    onCompletion.<span class=\"hljs-title function_\">onError</span>(<span class=\"hljs-title class_\">Exception</span>(responseBody.<span class=\"hljs-title function_\">bodyAsText</span>()))\n                }\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            onCompletion.<span class=\"hljs-title function_\">onError</span>(<span class=\"hljs-title class_\">Exception</span>(<span class=\"hljs-string\">\"Password doesn't match\"</span>))\n        }\n    }\n</code></pre>\n<h2>로그인 퀘스트:</h2>\n<p>이제 로그인에 도전해 봅시다! 사용자 생성과 유사하게, <a href=\"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=$&#x27;API_KEY\" rel=\"nofollow\" target=\"_blank\">https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=$'API_KEY</a>' 엔드포인트로의 Ktor 클라이언트 호출을 구성해보세요. 다시 한번 사용자 자격 증명(이메일 및 비밀번호)을 직렬화하고 POST 요청을 보내세요. 응답을 구문 분석하여 ID 토큰을 얻어 사용자 신원을 확인하고 보호된 리소스에 액세스하는 데 필수적인 요소를 확보하세요.\nAuthenticationViewModel.kt에 추가된 login() 메서드의 아래 코드 스니펫을 확인해보세요.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">login</span><span class=\"hljs-params\">(\n    email: <span class=\"hljs-type\">String</span>,\n    password: <span class=\"hljs-type\">String</span>,\n    onCompletion: <span class=\"hljs-type\">onCompletion</span>\n)</span></span> {\n    viewModelScope.launch {\n        <span class=\"hljs-keyword\">val</span> responseBody = httpClient\n            .post(<span class=\"hljs-string\">\"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=<span class=\"hljs-subst\">${API_KEY}</span>\"</span>) {\n                header(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"application/json\"</span>)\n                parameter(<span class=\"hljs-string\">\"email\"</span>, email)\n                parameter(<span class=\"hljs-string\">\"password\"</span>, password)\n                parameter(<span class=\"hljs-string\">\"returnSecureToken\"</span>, <span class=\"hljs-literal\">true</span>)\n            }\n        <span class=\"hljs-keyword\">if</span> (responseBody.status.value <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">200.</span><span class=\"hljs-number\">.299</span>) {\n            <span class=\"hljs-keyword\">val</span> response = Json { ignoreUnknownKeys = <span class=\"hljs-literal\">true</span> }\n                .decodeFromString(responseBody.bodyAsText())\n            storeUserDetails(response)\n            onCompletion.onSuccess(response.idToken)\n        } <span class=\"hljs-keyword\">else</span> {\n            onCompletion.onError(Exception(responseBody.bodyAsText()))\n        }\n    }\n}\n</code></pre>\n<h1>단계 6: 캐시 지원을 위해 SQLDelight 추가.</h1>\n<p>SQLDelight는 플랫폼에 중립적인 SQL 쿼리를 작성하기 위한 강력한 코틀린 라이브러리로, 캐싱과 결합하여 앱의 효율성을 높이는 동적 이중체를 형성합니다. 여기서는 login 및 signUp API 호출의 응답에서 얻은 refreshToken을 저장할 것입니다. 따라서 사용자가 앱을 다시 열 때 인증을 요청하지 않을 것입니다.</p>\n<h2>SQLDelight 종속성 설정</h2>\n<p>먼저 gradle 폴더 내 libs.versions.toml 파일에 필요한 SQLDelight 종속성 및 플러그인을 추가해야 합니다.</p>\n<pre><code class=\"hljs language-js\">[versions]\n...\n...\nsqlDelight = <span class=\"hljs-string\">\"2.0.1\"</span>\n\n[libraries]\n...\n...\nsqldelight-androidDriver = { <span class=\"hljs-variable language_\">module</span> = <span class=\"hljs-string\">\"app.cash.sqldelight:android-driver\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"sqlDelight\"</span> }\nsqldelight-jvmDriver = { <span class=\"hljs-variable language_\">module</span> = <span class=\"hljs-string\">\"app.cash.sqldelight:sqlite-driver\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"sqlDelight\"</span> }\nsqldelight-nativeDriver = { <span class=\"hljs-variable language_\">module</span> = <span class=\"hljs-string\">\"app.cash.sqldelight:native-driver\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"sqlDelight\"</span> }\nsqldelight-coroutines = { <span class=\"hljs-variable language_\">module</span> = <span class=\"hljs-string\">\"app.cash.sqldelight:coroutines-extensions\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"sqlDelight\"</span> }\nsqldelight-primitiveAdapters = { <span class=\"hljs-variable language_\">module</span> = <span class=\"hljs-string\">\"app.cash.sqldelight:coroutines-extensions\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"sqlDelight\"</span> }\n\n[plugins]\nandroidApplication = { id = <span class=\"hljs-string\">\"com.android.application\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"agp\"</span> }\nandroidLibrary = { id = <span class=\"hljs-string\">\"com.android.library\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"agp\"</span> }\njetbrainsCompose = { id = <span class=\"hljs-string\">\"org.jetbrains.compose\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"compose-plugin\"</span> }\nkotlinMultiplatform = { id = <span class=\"hljs-string\">\"org.jetbrains.kotlin.multiplatform\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"kotlin\"</span> }\nkotlinxSerialization = { id = <span class=\"hljs-string\">\"org.jetbrains.kotlin.plugin.serialization\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"kotlin\"</span> }\nsqlDelight = { id = <span class=\"hljs-string\">\"app.cash.sqldelight\"</span>, version.<span class=\"hljs-property\">ref</span> = <span class=\"hljs-string\">\"sqlDelight\"</span> }\n</code></pre>\n<p>다음 단계는 프로젝트 수준의 build.gradle.kts 파일에 플러그인을 추가하는 것입니다.</p>\n<pre><code class=\"hljs language-js\">plugins {\n    <span class=\"hljs-comment\">// this is necessary to avoid the plugins to be loaded multiple times</span>\n    <span class=\"hljs-comment\">// in each subproject's classloader</span>\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">androidApplication</span>) apply <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">androidLibrary</span>) apply <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">jetbrainsCompose</span>) apply <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">kotlinMultiplatform</span>) apply <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-comment\">//SQLDelight Plugin</span>\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">sqlDelight</span>) apply <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>마지막 단계로는 composeApp build.gradle.kts 파일에서 SQLDelight를 구성해야 합니다. 여기서는 필요한 플랫폼에 따라 종속성을 추가하고 SQLDelight 데이터베이스의 이름을 추가할 것입니다. 매개변수가 포함된 데이터베이스 목록을 포함하는 sqlDelight 블록을 맨 끝에 볼 수 있을 것입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">jetbrains</span>.<span class=\"hljs-property\">compose</span>.<span class=\"hljs-property\">ExperimentalComposeLibrary</span>\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">jetbrains</span>.<span class=\"hljs-property\">compose</span>.<span class=\"hljs-property\">desktop</span>.<span class=\"hljs-property\">application</span>.<span class=\"hljs-property\">dsl</span>.<span class=\"hljs-property\">TargetFormat</span>\n\nplugins {\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">kotlinMultiplatform</span>)\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">androidApplication</span>)\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">jetbrainsCompose</span>)\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">kotlinxSerialization</span>)\n    <span class=\"hljs-title function_\">alias</span>(libs.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-property\">sqlDelight</span>)\n}\n\nkotlin {\n\n    androidTarget {\n        compilations.<span class=\"hljs-property\">all</span> {\n            kotlinOptions {\n                jvmTarget = <span class=\"hljs-string\">\"1.8\"</span>\n            }\n        }\n    }\n\n    \n    <span class=\"hljs-title function_\">jvm</span>(<span class=\"hljs-string\">\"desktop\"</span>)\n    \n    <span class=\"hljs-title function_\">listOf</span>(\n        <span class=\"hljs-title function_\">iosX64</span>(),\n        <span class=\"hljs-title function_\">iosArm64</span>(),\n        <span class=\"hljs-title function_\">iosSimulatorArm64</span>()\n    ).<span class=\"hljs-property\">forEach</span> { iosTarget ->\n        iosTarget.<span class=\"hljs-property\">binaries</span>.<span class=\"hljs-property\">framework</span> {\n            baseName = <span class=\"hljs-string\">\"ComposeApp\"</span>\n            <span class=\"hljs-comment\">// This should be set to false to run on iOS</span>\n            isStatic = <span class=\"hljs-literal\">false</span>\n            <span class=\"hljs-comment\">// Add it to avoid sqllite3 issues in iOS</span>\n            linkerOpts.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">\"-lsqlite3\"</span>)\n        }\n    }\n    \n    sourceSets {\n        val desktopMain by getting\n\n        androidMain.<span class=\"hljs-property\">dependencies</span> {\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">compose</span>.<span class=\"hljs-property\">ui</span>.<span class=\"hljs-property\">tooling</span>.<span class=\"hljs-property\">preview</span>)\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">androidx</span>.<span class=\"hljs-property\">activity</span>.<span class=\"hljs-property\">compose</span>)\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">ktor</span>.<span class=\"hljs-property\">client</span>.<span class=\"hljs-property\">okhttp</span>)\n            <span class=\"hljs-comment\">//SqlDelight for Android</span>\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">sqldelight</span>.<span class=\"hljs-property\">androidDriver</span>)\n        }\n        commonMain.<span class=\"hljs-property\">dependencies</span> {\n            <span class=\"hljs-title function_\">implementation</span>(compose.<span class=\"hljs-property\">runtime</span>)\n            <span class=\"hljs-title function_\">implementation</span>(compose.<span class=\"hljs-property\">foundation</span>)\n            <span class=\"hljs-title function_\">implementation</span>(compose.<span class=\"hljs-property\">material</span>)\n            <span class=\"hljs-title function_\">implementation</span>(compose.<span class=\"hljs-property\">ui</span>)\n            @<span class=\"hljs-title class_\">OptIn</span>(<span class=\"hljs-title class_\">ExperimentalComposeLibrary</span>::<span class=\"hljs-keyword\">class</span>)\n            <span class=\"hljs-title function_\">implementation</span>(compose.<span class=\"hljs-property\">components</span>.<span class=\"hljs-property\">resources</span>)\n            <span class=\"hljs-comment\">//Ktor</span>\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">ktor</span>.<span class=\"hljs-property\">client</span>.<span class=\"hljs-property\">core</span>)\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">ktor</span>.<span class=\"hljs-property\">client</span>.<span class=\"hljs-property\">content</span>.<span class=\"hljs-property\">negotiation</span>)\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">ktor</span>.<span class=\"hljs-property\">serialization</span>.<span class=\"hljs-property\">kotlinx</span>.<span class=\"hljs-property\">json</span>)\n            <span class=\"hljs-comment\">//Moko MVVM</span>\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">moko</span>.<span class=\"hljs-property\">mvvm</span>.<span class=\"hljs-property\">core</span>)\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">moko</span>.<span class=\"hljs-property\">mvvm</span>.<span class=\"hljs-property\">compose</span>)\n            <span class=\"hljs-comment\">//Kamel</span>\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">kamel</span>)\n            <span class=\"hljs-comment\">// Navigator</span>\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">voyager</span>.<span class=\"hljs-property\">navigator</span>)\n            <span class=\"hljs-comment\">//SqlDelight for common</span>\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">sqldelight</span>.<span class=\"hljs-property\">coroutines</span>)\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">sqldelight</span>.<span class=\"hljs-property\">primitiveAdapters</span>)\n        }\n        desktopMain.<span class=\"hljs-property\">dependencies</span> {\n            <span class=\"hljs-title function_\">implementation</span>(compose.<span class=\"hljs-property\">desktop</span>.<span class=\"hljs-property\">currentOs</span>)\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">kotlinx</span>.<span class=\"hljs-property\">coroutines</span>.<span class=\"hljs-property\">swing</span>)\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">ktor</span>.<span class=\"hljs-property\">client</span>.<span class=\"hljs-property\">okhttp</span>)\n            <span class=\"hljs-comment\">//SqlDelight for jvm</span>\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">sqldelight</span>.<span class=\"hljs-property\">jvmDriver</span>)\n        }\n        iosMain.<span class=\"hljs-property\">dependencies</span> {\n            <span class=\"hljs-comment\">//SqlDelight for iOS</span>\n            <span class=\"hljs-title function_\">implementation</span>(libs.<span class=\"hljs-property\">sqldelight</span>.<span class=\"hljs-property\">nativeDriver</span>)\n        }\n    }\n}\n\nsqldelight {\n    databases {\n        <span class=\"hljs-comment\">//Note: Name of your Database and .sq file should be same</span>\n        <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"Database\"</span></span>) {\n            packageName.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">\"com.dwarshb.firebaseauthentication\"</span>)\n        }\n    }\n    <span class=\"hljs-comment\">// Add this line to avoid library linking issues</span>\n    linkSqlite = <span class=\"hljs-literal\">true</span>\n}\n\nandroid {\n    ...\n}\n\ncompose.<span class=\"hljs-property\">desktop</span> {\n    ...\n}\n</code></pre>\n<h2>쿼리용 Database.sq 파일 만들기</h2>\n<p>다음 단계는 모든 필요한 SQL 쿼리를 포함하는 .sq 파일을 작성하는 것입니다. 기본적으로 SQLDelight 플러그인은 sqldelight 폴더 내의 패키지 폴더에서 .sq를 읽습니다. 해당 폴더는 직접 commainMain 폴더 내에 있을 것입니다.\nDatabase.sq 파일이 위치하는 폴더 구조 스크린샷은 아래에서 확인하실 수 있습니다.</p>\n<p>다음 코드를 Database.sq 파일에 추가하세요. 이 파일은 createTable, insertUser, removeAllUsers, getAllUsers 등의 쿼리를 포함합니다.</p>\n<p>프로젝트를 컴파일하면 생성된 Kotlin 코드가 composeApp/build/generated/sqldelight 디렉토리에 저장됩니다. 또는 터미널에서 ./gradlew generateSqlDelightInterface 명령어를 사용하여 sqldelight 코틀린 코드를 생성할 수도 있습니다.</p>\n<h2>데이터베이스 드라이버 생성</h2>\n<p>SQLDelight은 SQLite 드라이버의 여러 플랫폼별 구현을 제공하므로 각 플랫폼에 대해 별도로 생성해야 합니다. 이를 기대 선언과 실제 선언을 사용하여 수행할 수 있습니다.</p>\n<p>composeApp/src/commonMain/kotlin에서 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 만드세요.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">package</span> com.dwarshb.firebaseauthentication\n\n<span class=\"hljs-keyword\">import</span> app.cash.sqldelight.db.SqlDriver\n\n<span class=\"hljs-keyword\">expect</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DriverFactory</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">createDriver</span><span class=\"hljs-params\">()</span></span>: SqlDriver\n}\n</code></pre>\n<p>이제 각 대상 플랫폼에 대해 이를 구현해야 합니다.</p>\n<p>안드로이드에서는 AndroidSqliteDriver 클래스가 SQLite 드라이버를 구현합니다.\n그래서 composeApp/src/androidMain/kotlin에서 패키지를 만들어 그 안에 DriverFactory.kt 클래스를 생성해주세요.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">package</span> com.dwarshb.firebaseauthentication\n\n<span class=\"hljs-keyword\">import</span> android.content.Context\n<span class=\"hljs-keyword\">import</span> app.cash.sqldelight.db.SqlDriver\n<span class=\"hljs-keyword\">import</span> app.cash.sqldelight.driver.android.AndroidSqliteDriver\n\n<span class=\"hljs-keyword\">actual</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DriverFactory</span>(<span class=\"hljs-keyword\">var</span> appContext: Context) {\n\n    <span class=\"hljs-keyword\">actual</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">createDriver</span><span class=\"hljs-params\">()</span></span>: SqlDriver {\n        <span class=\"hljs-keyword\">return</span> AndroidSqliteDriver(Database.Schema, appContext, <span class=\"hljs-string\">\"firebase.db\"</span>)\n    }\n}\n</code></pre>\n<p>이제 Android에서 작동하도록 하기 위해 composeApp/src/androidMain/kotlin에 있는 MainActivity.kt 파일에서 해당 인스턴스를 생성해야 합니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MainActivity</span> : <span class=\"hljs-type\">ComponentActivity</span>() {\n    <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(savedInstanceState: <span class=\"hljs-type\">Bundle</span>?)</span></span> {\n        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState)\n        <span class=\"hljs-comment\">//Android용 DriverFactory의 인스턴스 생성</span>\n        <span class=\"hljs-keyword\">val</span> driverFactory = DriverFactory(<span class=\"hljs-keyword\">this</span>)\n        setContent {\n            App(driverFactory.createDriver())\n        }\n    }\n}\n</code></pre>\n<p>iOS에서 SQLite 드라이버 구현은 NativeSqliteDriver 클래스입니다.\n그래서 composeApp/src/iosMain/kotlin에 패키지를 만들고 내부에 DriverFactory.kt 클래스를 만들어 주세요.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">package</span> com.dwarshb.firebaseauthentication\n\n<span class=\"hljs-keyword\">import</span> app.cash.sqldelight.db.SqlDriver\n<span class=\"hljs-keyword\">import</span> app.cash.sqldelight.driver.native.NativeSqliteDriver\n\n<span class=\"hljs-keyword\">actual</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DriverFactory</span> {\n    <span class=\"hljs-keyword\">actual</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">createDriver</span><span class=\"hljs-params\">()</span></span>: SqlDriver {\n        <span class=\"hljs-keyword\">return</span> NativeSqliteDriver(Database.Schema, <span class=\"hljs-string\">\"firebase.db\"</span>)\n    }\n}\n</code></pre>\n<p>이제 MainViewController.kt 파일을 만들어서 iOS에서 작업할 수 있도록 인스턴스를 만들어주세요. 이 파일은 composeApp/src/iosMain/kotlin에 있습니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">import</span> androidx.compose.ui.window.ComposeUIViewController\n<span class=\"hljs-keyword\">import</span> com.dwarshb.firebaseauthentication.DriverFactory\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">MainViewController</span><span class=\"hljs-params\">()</span></span> = ComposeUIViewController {\n    <span class=\"hljs-keyword\">val</span> driverFactory = DriverFactory()\n    App(driverFactory.createDriver())\n}\n</code></pre>\n<p>데스크톱 환경에서는 SQLite 드라이버 구현이 JdbcSqliteDriver 클래스입니다.\n그래서 composeApp/src/desktopMain/kotlin에 패키지를 만들고 그 안에 DriverFactory.kt 클래스를 생성해주세요.</p>\n<pre><code class=\"hljs language-js\">package com.<span class=\"hljs-property\">dwarshb</span>.<span class=\"hljs-property\">firebaseauthentication</span>\n\n<span class=\"hljs-keyword\">import</span> app.<span class=\"hljs-property\">cash</span>.<span class=\"hljs-property\">sqldelight</span>.<span class=\"hljs-property\">db</span>.<span class=\"hljs-property\">SqlDriver</span>\n<span class=\"hljs-keyword\">import</span> app.<span class=\"hljs-property\">cash</span>.<span class=\"hljs-property\">sqldelight</span>.<span class=\"hljs-property\">driver</span>.<span class=\"hljs-property\">jdbc</span>.<span class=\"hljs-property\">sqlite</span>.<span class=\"hljs-property\">JdbcSqliteDriver</span>\n<span class=\"hljs-keyword\">import</span> java.<span class=\"hljs-property\">io</span>.<span class=\"hljs-property\">File</span>\n\nactual <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DriverFactory</span> {\n    actual fun <span class=\"hljs-title function_\">createDriver</span>(): <span class=\"hljs-title class_\">SqlDriver</span> {\n        val databasePath = <span class=\"hljs-title class_\">File</span>(<span class=\"hljs-title class_\">System</span>.<span class=\"hljs-title function_\">getProperty</span>(<span class=\"hljs-string\">\"java.io.tmpdir\"</span>), <span class=\"hljs-string\">\"firebase.db\"</span>)\n        val <span class=\"hljs-attr\">driver</span>: <span class=\"hljs-title class_\">SqlDriver</span> = <span class=\"hljs-title class_\">JdbcSqliteDriver</span>(url = <span class=\"hljs-string\">\"jdbc:sqlite:${databasePath.absolutePath}\"</span>)\n        <span class=\"hljs-title class_\">Database</span>.<span class=\"hljs-property\">Schema</span>.<span class=\"hljs-title function_\">create</span>(driver)\n        <span class=\"hljs-keyword\">return</span> driver\n    }\n}\n</code></pre>\n<p>이제 데스크톱에서 작동하도록 composeApp/src/desktopMain/kotlin의 main.kt 파일에 인스턴스를 생성해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> androidx.<span class=\"hljs-property\">compose</span>.<span class=\"hljs-property\">ui</span>.<span class=\"hljs-property\">window</span>.<span class=\"hljs-property\">Window</span>\n<span class=\"hljs-keyword\">import</span> androidx.<span class=\"hljs-property\">compose</span>.<span class=\"hljs-property\">ui</span>.<span class=\"hljs-property\">window</span>.<span class=\"hljs-property\">application</span>\n<span class=\"hljs-keyword\">import</span> com.<span class=\"hljs-property\">dwarshb</span>.<span class=\"hljs-property\">firebaseauthentication</span>.<span class=\"hljs-property\">DriverFactory</span>\n\nfun <span class=\"hljs-title function_\">main</span>() = application {\n    <span class=\"hljs-title class_\">Window</span>(onCloseRequest = ::exitApplication, title = <span class=\"hljs-string\">\"FirebaseAuthentication\"</span>) {\n        val driverFactory = <span class=\"hljs-title class_\">DriverFactory</span>()\n        <span class=\"hljs-title class_\">App</span>(driverFactory.<span class=\"hljs-title function_\">createDriver</span>())\n    }\n}\n</code></pre>\n<p>모든 플랫폼에서 DriverFactory를 구성하고 위 단계를 모두 따라왔다면, App() 함수를 수정하고 SqlDriver를 매개변수로 추가해야 합니다. 각 플랫폼에서 SqlDriver의 인스턴스를 가져올 수 있는 유일한 방법이기 때문입니다. 그래서 composeApp/src/commanMain/kotlin/App.kt 안에 다음과 같이 작성하세요.</p>\n<pre><code class=\"hljs language-js\">@<span class=\"hljs-title class_\">Composable</span>\nfun <span class=\"hljs-title class_\">App</span>(<span class=\"hljs-attr\">sqlDriver</span>: <span class=\"hljs-title class_\">SqlDriver</span>) {\n    val authenticationViewModel = <span class=\"hljs-title class_\">AuthenticationViewModel</span>(sqlDriver)\n    \n    <span class=\"hljs-title class_\">MaterialTheme</span> {\n      ...   \n    }\n}\n</code></pre>\n<h1>단계 7: SQLDelight 쿼리 구성하기</h1>\n<p>이 단계에서는 Firebase Authentication API에서 받은 토큰을 저장하여 사용자 세션을 유지하기 위해 insertUser 쿼리를 사용할 예정입니다. 또한 로컬 데이터베이스에 저장된 토큰을 얻기 위해 selectAllUser 쿼리를 사용할 것입니다. AuthenticationViewModel.kt 내에서 먼저 데이터베이스를 초기화할 것입니다.</p>\n<pre><code class=\"hljs language-js\">    <span class=\"hljs-keyword\">var</span> databaseQuery : <span class=\"hljs-title class_\">DatabaseQueries</span>\n\n    val database = <span class=\"hljs-title class_\">Database</span>(sqlDriver)\n    databaseQuery = database.<span class=\"hljs-property\">databaseQueries</span>\n</code></pre>\n<p>이제 API에서 받은 응답을 저장할 storeUserDetails() 메서드를 만들 것입니다. 이 메서드는 로컬 데이터베이스에 정보를 저장하는 데 insertUser 쿼리를 사용합니다. AuthenticationViewModel.kt 파일의 login()이나 signUp() 메서드 내에 이 메서드를 추가할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">internal fun <span class=\"hljs-title function_\">storeUserDetails</span>(<span class=\"hljs-params\">response: AuthResponse</span>) {\n        databaseQuery.<span class=\"hljs-title function_\">insertUser</span>(\n            response.<span class=\"hljs-property\">idToken</span>, response.<span class=\"hljs-property\">email</span>, response.<span class=\"hljs-property\">refreshToken</span>,\n            response.<span class=\"hljs-property\">email</span>\n        )\n    }\n</code></pre>\n<p>세션 유지를 위해 시스템에 이미 토큰이 로컬 데이터베이스에 있는지 확인해야 합니다. 그래서 우리는 selectAllUsers 쿼리를 사용하여 로컬 데이터베이스에 저장된 토큰을 확인하는 checkSession()을 생성할 것입니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">internal</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">checkSession</span><span class=\"hljs-params\">(onCompletion: <span class=\"hljs-type\">onCompletion</span>)</span></span> {\n    <span class=\"hljs-keyword\">for</span>(user <span class=\"hljs-keyword\">in</span> databaseQuery.selectAllUsers().executeAsList()) {\n        <span class=\"hljs-keyword\">if</span> (user != <span class=\"hljs-literal\">null</span>) {\n            onCompletion.onSuccess(user.refreshToken.toString())\n        } <span class=\"hljs-keyword\">else</span> {\n            onCompletion.onError(Exception(<span class=\"hljs-string\">\"세션을 찾을 수 없습니다\"</span>))\n        }\n    }\n}\n</code></pre>\n<p>우리는 checkSession() 메서드를 사용하여 결과에 따라 UI를 업데이트할 수 있습니다. 예를 들어, 토큰이 있는 경우 onSuccess 내에서 앱을 MainScreen으로 이동시키고, 그렇지 않은 경우 AuthenticationView 화면이 표시됩니다.</p>\n<h1>데모</h1>\n<p>아래의 Github 링크에서 전체 코드를 확인해보세요.</p>\n<h1>참조 링크:</h1>\n<ul>\n<li><a href=\"https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ktor-sqldelight.html#build-an-sdk\" rel=\"nofollow\" target=\"_blank\">https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-ktor-sqldelight.html#build-an-sdk</a></li>\n<li><a href=\"https://firebase.google.com/docs/reference/rest/auth#section-api-usage\" rel=\"nofollow\" target=\"_blank\">https://firebase.google.com/docs/reference/rest/auth#section-api-usage</a></li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}