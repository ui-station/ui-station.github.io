{"pageProps":{"post":{"title":"프로젝트 8  Kubernetes에서 삼계층 애플리케이션 배포 하는 방법","description":"","date":"2024-06-23 00:57","slug":"2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes","content":"\n\n우리 시리즈의 8번째 프로젝트입니다. 계속 따라오세요!\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*ZBUzOwaMkbfPD3iZXxVH1g.gif)\n\n## 3Tier란 무엇인가요?\n\n사실은 시스템을 3부분으로 나누는 것을 말해요.\n\n<div class=\"content-ad\"></div>\n\n- 표현 계층 (티어 1):\n\n    - 웹 사이트를 열 때 보는 것이 바로 표현 계층입니다. 기본적으로 이 계층은 사용자가 직접 상호 작용하는 계층입니다.\n\n- 논리 계층 (티어 2):\n\n    - 이 계층을 뒷단의 두뇌로 상상해보세요. 사용자 인터페이스를 통해 제공하는 정보를 받아 시스템의 규칙에 따라 처리합니다. 예를 들어 쇼핑 웹 사이트의 경우, 이 계층은 물품의 총 가격을 계산하거나 할인을 적용하며 모든 제품이 재고에 있는지 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n3. 데이터 레이어 (티어 3):\n\n- 데이터가 저장되고 검색되는 곳입니다. 시스템의 메모리와 같습니다.\n- 데이터는 데이터베이스, 파일 또는 다른 데이터 저장 시스템에 저장될 수 있습니다.\n- 데이터 레이어는 시스템이 필요로 하는 정보를 관리하고 저장하는 역할을 합니다.\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_0.png)\n\n# 완료 단계 →\n\n<div class=\"content-ad\"></div>\n\n# Phase 1 \nEC2 인스턴스, IAM 사용자 및 EC2의 기본 도구 설정하기\n\n# Phase 2 \n프론트엔드 및 백엔드 이미지 빌드하기\n\n# Phase 3 \n쿠버네티스\n\n# Phase 4 \n애플리케이션 로드 밸런서 및 인그레스 설정하기\n\n<div class=\"content-ad\"></div>\n\nPhase 5 → 모든 것 파괴하기\n\n# Phase 1 → 기본 EC2, IAM 사용자 및 EC2에 기본 도구 설정\n\n## 단계 1. IAM 사용자 생성\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_1.png)\n\n<div class=\"content-ad\"></div>\n\n1. 'iam'을 클릭하세요.\n\n2. 사용자를 클릭하고 사용자 생성을 클릭하세요\n\n   ![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_2.png)\n\n3. 사용자에게 이름을 지정하고 관리 콘솔에 사용자 액세스 제공에 체크하고 IAM 사용자 옵션을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_3.png)\n\n5. 사용자의 암호를 선택하십시오 → 다음을 클릭하세요.\n\n6. IAM 사용자에 정책을 직접 첨부 → 다음을 클릭하세요.\n\n참고 → 현재는 관리자 액세스를 제공하겠지만 작업 공간에 정책을 첨부할 때 신중하시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_4.png)\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_5.png)\n\n사용자를 검토하고 만들기\n\n7. '사용자 만들기'를 클릭하세요\n\n<div class=\"content-ad\"></div>\n\n\n![Project Screenshot 6](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_6.png)\n\n8. If the password file is autogenerated, download it. Otherwise, you can choose whether to download it or not.\n\n![Project Screenshot 7](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_7.png)\n\n9. Click on your IAM user → Security Credentials.\n\n\n<div class=\"content-ad\"></div>\n\n![Project Screenshot 8](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_8.png)\n\n10. 스크롤하여 키에 액세스하고 액세스 키를 생성합니다.\n\n![Project Screenshot 9](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_9.png)\n\n11. 옵션 목록에서 aws cli를 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_10.png\" />\n\n12. 다음을 클릭하고 사용자 이름과 암호의 CSV 파일을 다운로드하세요\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_11.png\" />\n\n## 단계 2. 모든 작업을 수행하는 기본 EC2를 시작합니다 →\n\n<div class=\"content-ad\"></div>\n\n- AWS 콘솔을 열고 EC2로 이동한 다음 EC2 시작을 클릭하세요\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_12.png)\n\n2. 연결을 클릭하고 다음 명령을 실행하세요\n\n```bash\nsudo su\napt update\nmkdir 3-tier\ncd 3-tier\n```\n\n<div class=\"content-ad\"></div>\n\n3. 깃허브에서 코드를 가져오려면 git clone을 사용하세요\n\n```js\ngit clone https://github.com/Aakibgithuber/Three-tier-Application-Deployment-.git\n```\n\n4. ls를 실행하여 레포지토리 안에 무엇이 있는지 확인하세요\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_13.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 단계 3 → aws cli, 도커, kubectl 및 eksctl 설정\n\n## 1. aws cli 구성\n\nAWS CLI (Amazon Web Services Command Line Interface)는 명령어를 사용하여 AWS 서비스와 상호 작용할 수 있는 도구입니다.\n\n- 아래 명령어를 실행하여 aws cli를 설치합니다\n\n<div class=\"content-ad\"></div>\n\n1. 먼저 다음 명령어로 AWS CLI를 설치해 주세요.\n\n\nsnap install aws-cli --classic\n\n\n2. 이제 AWS를 구성해야 합니다. 아래 명령어를 사용해 구성해 주세요.\n\n\naws configure\n\n\n3. 접근 키와 비밀 키를 요청할 것입니다. 이제 앞서 다운로드한 CSV 파일을 열어서 액세스 키와 비밀 키를 복사해 주세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_14.png\" />\n\n4. 모든 것을 그대로 유지하고 Enter 키를 누르세요.\n\n지금까지 AWS CLI를 설정하셨습니다. 이제 Docker를 설정하세요.\n\n## 2. Docker 설정\n\n<div class=\"content-ad\"></div>\n\n- 다음 명령어를 실행해주세요\n\n```js\napt install docker.io\nusermod -aG docker $USER # 사용자 이름으로 변경해주세요. 예: 'ubuntu'\nnewgrp docker\nsudo chmod 777 /var/run/docker.sock\nwhich docker\n```\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_15.png)\n\n## 3. kubectl 설정하기\n\n<div class=\"content-ad\"></div>\n\n이것은 Kubernetes 클러스터를 관리하고 상호 작용하는 데 사용되는 명령 줄 도구입니다.\n\n- kubectl을 설치하려면 다음 명령을 실행하십시오.\n\n```js\nsnap install kubectl --classic\n```\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_16.png)\n\n<div class=\"content-ad\"></div>\n\n## 4. eksctl 설정\n\n이것은 Amazon EKS (Elastic Kubernetes Service) 클러스터를 관리하는 데 사용되는 명령줄 도구입니다.\n\n- eksctl 도구를 설치하려면 다음 명령을 실행하십시오\n\n```js\ncurl --silent --location \"https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz\" | tar xz -C /tmp\nsudo mv /tmp/eksctl /usr/local/bin\neksctl version\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_17.png\" />\n\n# Phase 2 → 프론트엔드 및 백엔드 이미지 구축\n\n## 단계 1 → Elastic Container Registry (ECR) 설정\n\n도커 이미지를 저장하는 도커허브와 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n- AWS 콘솔로 이동해서 ECR을 검색해주세요.\n- 프론트엔드를 위한 저장소를 만들고 가시성 설정을 \"퍼블릭\"으로 설정해주세요.\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_18.png)\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_19.png)\n\n3. 백엔드 저장소 설정\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_20.png)\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_21.png)\n\n## 단계 2 → 프론트엔드 설정\n\n- 터미널에서 프론트엔드 디렉토리로 이동하고 ls 명령어를 실행하세요\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_22.png)\n\n2. Amazon ECR 저장소로 이동하고 푸시 명령 보기를 클릭합니다\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_23.png)\n\n3. 위 명령을 하나씩 실행하여 프론트엔드 이미지를 빌드하고 ECR 저장소에 푸시합니다\n\n\n<div class=\"content-ad\"></div>\n\n```js\naws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/l0l7e4u1\ndocker build -t 3-tier-frontend .\ndocker tag 3-tier-frontend:latest public.ecr.aws/l0l7e4u1/3-tier-frontend:latest\ndocker push public.ecr.aws/l0l7e4u1/3-tier-frontend:latest\n```\n\n![Project Image 24](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_24.png)\n\n![Project Image 25](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_25.png)\n\n4. 이미지에서 컨테이너를 실행해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n도커 이미지 목록에서 이미지 이름을 복사하세요.\n도커 실행 -d -p 3000:3000 3-tier-frontend:latest\n```\n\n![이미지1](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_26.png)\n\n프론트엔드가 설정되었고 애플리케이션이 실행 중입니다. 애플리케이션을 확인하려면 브라우저에서 해당 주소로 이동하세요 →public-ip:3000\n\n![이미지2](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_27.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 단계 3 → 백엔드 설정\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_28.png)\n\n- 이제 백엔드 디렉토리로 이동하여 백엔드를 설정하세요.\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_29.png)\n\n<div class=\"content-ad\"></div>\n\n2. ECR 리포지토리로 이동하여 백엔드 리포지토리의 푸시 명령을 보기 위해 클릭하세요\n\n![백엔드 리포지토리 푸시 명령](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_30.png)\n\n3. 위 명령을 단계별로 터미널에서 실행해주세요\n\n```js\naws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws/l0l7e4u1\ndocker build -t 3-tier-backend .\ndocker tag 3-tier-backend:latest public.ecr.aws/l0l7e4u1/3-tier-backend:latest\ndocker push public.ecr.aws/l0l7e4u1/3-tier-backend:latest\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_31.png)\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_32.png)\n\n이제 백엔드 이미지가 성공적으로 빌드되었고, 우리가 탄력적인 쿠버네티스 서비스를 생성할 때 사용한 Elastic Container Registry에 푸시되었습니다.\n\n# Phase 3 Kubernetes\n\n\n<div class=\"content-ad\"></div>\n\n- 배포란 무엇인가요?\n\n- 공장을 상상해보세요: 배포는 여러분의 소프트웨어 응용 프로그램의 사본을 생성하고 관리하는 공장으로 생각해보세요.\n- 여러 복제본: 공장이 여러 개의 동일한 항목을 생성할 수 있는 것처럼, Kubernetes의 배포는 응용 프로그램의 여러 사본(복제본)을 생성하고 다룰 수 있습니다.\n- 간편한 업데이트: 응용 프로그램을 변경하거나 업데이트하려면, 배포 시스템이 그것을 원활하게 처리할 수 있습니다. 마치 공장에서 부품을 교체하면서 생산을 멈추지 않는 것처럼요.\n\n2. 서비스란 무엇인가요?\n\n- 수신 데스크를 상상해보세요: Kubernetes의 서비스를 건물의 수신 데스크처럼 생각해보세요.\n- 중앙 연락처: 서비스는 응용 프로그램을 위한 중앙 연락처를 제공합니다. 직접 각 응용 프로그램을 찾는 대신 시스템의 다른 부분들이 서비스와 대화하고, 서비스가 올바른 응용 프로그램을 찾는 방법을 알고 있습니다.\n- 안정적인 주소: 수신 데스크에 일정한 주소가 있는 것처럼, 서비스에도 시스템의 다른 부분들이 응용 프로그램과 통신하기 위해 사용할 수 있는 안정적인 주소가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3. Namespace란 무엇인가요?\n\n- 이것은 쿠버네티스 내에서 당신이 어플리케이션을 조직하고 실행할 수 있는 레이블이 붙은 섹션과 같습니다. 각 네임스페이스는 당신의 어플리케이션이 서로 방해하지 않고 자신의 일을 할 수 있는 울타리 치여진 영역과 같습니다.\n- 좀 더 간단하게 말하면, 쿠버네티스에서의 네임스페이스는 다른 프로젝트나 어플리케이션을 분리하고 조직화하며, 쿠버네티스 클러스터의 분주한 환경에서 쉽게 관리할 수 있도록 하는 방법입니다.\n\n## Step 1 → EKS 클러스터 설정하고 네임스페이스 생성하기\n\n- 다음 명령어를 실행하여 EKS 클러스터를 설정하세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\neksctl create cluster --name three-tier-cluster --region us-east-1 --node-type t2.medium --nodes-min 2 --nodes-max 2\naws eks update-kubeconfig --region us-east-1 --name three-tier-cluster\nkubectl get nodes\n```\n\n2. 클러스터를 생성하는 데 15~20분이 소요됩니다.\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_33.png)\n\n3. AWS 콘솔에서 AWS CloudFormation을 검색하여 EKS 클러스터 생성 중 발생하는 이벤트를 확인하세요.\n\n\n<div class=\"content-ad\"></div>\n\n아래 명령어를 사용하여 Namesapce를 생성하세요.\n\n```shell\nkubectl create namespace workshop\nkubectl config set-context --current --namespace workshop\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_36.png\" />\n\n## 단계 2→ 프론트엔드를 위한 배포 및 서비스 생성하기\n\n- k8s_manifests 디렉토리로 이동하면 프론트엔드를 위한 배포 및 서비스 파일을 찾을 수 있습니다.\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_37.png\" />\n\n<div class=\"content-ad\"></div>\n\n2. frontend-deployment.yaml 파일을 편집해야 합니다.\n\n3. 바꿔야 할 것은 이미지 이름입니다.\n\n![image](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_38.png)\n\n4. 따라서 ECR 레포지토리로 이동하여 프론트엔드 레포지토리를 선택한 후 \"View public listing\"을 클릭하여 이미지 이름을 복사하고 frontend-deployment.yaml 파일에 붙여넣으세요.\n\n<div class=\"content-ad\"></div>\n\n이제 다음 명령어를 실행하여 프론트엔드용 배포 및 서비스를 생성하세요.\n\n```js\nkubectl apply -f frontend-deployment.yaml\nkubectl apply -f frontend-service.yaml\n```\n\n## 단계 3→ 백엔드용 배포 및 서비스 생성\n\n- 동일한 폴더에 백엔드 배포 및 서비스인 backend-deployment.yaml 및 backend-service.yaml 파일이 있습니다.\n- backend-deployment.yaml 파일을 편집해야 합니다.\n- 변경해야 할 것은 이미지 이름뿐입니다.\n- 따라서 ECR 저장소로 이동하여 백엔드 저장소를 선택한 다음, \"View Public Listing\"을 클릭하여 이미지 이름을 복사한 후 backend-deployment.yaml 파일 안에 붙여넣으세요.\n\n<div class=\"content-ad\"></div>\n\n이제 다음 명령을 실행하여 배포 및 백엔드 서비스를 생성하십시오.\n\n```js\nkubectl apply -f backend-deployment.yaml\nkubectl apply -f backend-service.yaml\nkubectl get pods -n workshop\n```\n\n이제 우리의 2계층이 준비되었습니다. 즉, 프론트엔드와 백엔드가 설정되었습니다. 이제 세 번째 계층을 설정해 봅시다.\n\n## 단계 4 → 데이터베이스 계층 설정\n\n<div class=\"content-ad\"></div>\n\n- 배포, 서비스 및 시크릿 매니페스트를 저장하는 몽고 폴더를 찾아주세요.\n\n2. 아래 명령어를 실행하여 데이터베이스 티어를 설정하세요.\n\n```js\nkubectl apply -f .\nkubectl get all\n```\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_39.png)\n\n<div class=\"content-ad\"></div>\n\n이제 모든 세 티어가 준비되었습니다. 하지만 이들을 어떻게 액세스할까요? 클러스터로 외부 트래픽을 전송하기 위해 애플리케이션 로드 밸런서를 생성해야 하고, 내부의 3개 티어 사이를 연결하기 위해 인그레스를 만들어야 합니다.\n\n# 단계 4 → 애플리케이션 로드 밸런서와 인그레스 설정\n\n외부 트래픽을 클러스터로 전송하기 위해 애플리케이션 로드 밸런서를 생성하고, 내부의 3개 티어 사이를 연결할 인그레스를 만들어야 합니다.\n\n## 단계 1 → AWS 로드 밸런서 설정; 설치 및 EKS 클러스터에 연결\n\n<div class=\"content-ad\"></div>\n\n1. 아래 명령은 ALB의 IAM 정책을 가져옵니다.\n\n```js\ncurl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.5.4/docs/install/iam_policy.json\n```\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_40.png)\n\n2. 이 명령어는 첫 번째 명령어에서 설정한 `iam_policy.json` 파일을 사용하여 AWS 계정에서 IAM 정책을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\naws iam create-policy --policy-name AWSLoadBalancerControllerIAMPolicy --policy-document file://iam_policy.json\n```\n\n![Image](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_41.png)\n\n3. 이 명령은 로드 밸런서 정책을 EKS 클러스터에 적용하여 정책에 따라 EKS 클러스터가 로드 밸런서와 함께 작동하도록 합니다.\n\n```js\neksctl utils associate-iam-oidc-provider --region=us-east-1 --cluster=three-tier-cluster --approve\n```\n\n<div class=\"content-ad\"></div>\n\n아래 명령어는 클러스터에 서비스 계정을 생성하고 추가하여 클러스터가 로드 밸런서 서비스와 작업할 수 있도록합니다.\n\n아래 명령어에서 AWS 계정 번호를 꼭 변경해야 합니다. 그렇지 않으면 작동하지 않습니다.\n\n```js\neksctl create iamserviceaccount --cluster=three-tier-cluster --namespace=kube-system --name=aws-load-balancer-controller --role-name AmazonEKSLoadBalancerControllerRole --attach-policy-arn=arn:aws:iam::767397866747:policy/AWSLoadBalancerControllerIAMPolicy --approve --region=us-east-1\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_43.png\" />\n\n## 모든 정책이 첨부되었습니다. 로드 밸런서를 배포해 봅시다.\n\n5. 이를 위해 helm을 설치해야 합니다. Helm은 쿠버네티스를 사용할 때 소프트웨어를 쉽게 운반하고 관리하는 데 도움이 되는 특별한 도구입니다. 쿠버네티스는 애플리케이션을 실행하기 위한 큰 놀이터와 같습니다.\n\n```js\nsudo snap install helm --classic\n```\n\n<div class=\"content-ad\"></div>\n\n6. 이제 로드 밸런서를 위해 eks 리포지토리에서 미리 작성된 특정 manifest 파일을 추가해야 해요. helm을 사용하여 다음 명령을 실행해주세요.\n\n```js\nhelm repo add eks https://aws.github.io/eks-charts\n```\n\n7. helm을 사용하여 eks 리포지토리를 업데이트해주세요.\n\n```js\nhelm repo update eks\n```\n\n<div class=\"content-ad\"></div>\n\n8. EKS 클러스터에 로드 밸런서 컨트롤러를 설치해주세요\n\n```js\nhelm install aws-load-balancer-controller eks/aws-load-balancer-controller -n kube-system --set clusterName=my-cluster --set serviceAccount.create=false --set serviceAccount.name=aws-load-balancer-controller\nkubectl get deployment -n kube-system aws-load-balancer-controller\n```\n\n![Image](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_44.png)\n\n이제 로드 밸런서가 작동되니 내부 라우팅을 위해 인그레스를 설정합시다.\n\n<div class=\"content-ad\"></div>\n\n## Step 2 → 내부 라우팅을 위한 Ingress 설정\n\n![이미지](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_45.png)\n\n- full_stack_lb.yaml 파일을 찾습니다\n\n```js\nkubectl apply -f full_stack_lb.yaml\nkubectl get ing -n workshop\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_46.png\" />\n\n2. 웹 브라우저로 이동하여 위의 DNS 주소를 붙여넣으세요\n\n<img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_47.png\" />\n\n축하합니다!! 여러분의 애플리케이션이 로드 밸런서 인그레스를 통해 접근 가능합니다\n\n<div class=\"content-ad\"></div>\n\n# 5 단계 → 모두 삭제하기\n\n- 현재 폴더에서 다음을 실행하세요\n\n```js\nkubectl delete -f .\n```\n\n2. 데이터베이스 계층을 삭제하려면 몽고 폴더로 이동하세요\n\n<div class=\"content-ad\"></div>\n\n```yaml\r\nkubectl delete -f .\r\n```\r\n\r\n3. 클러스터 및 클라우드 형성 스택을 삭제하세요.\r\n\r\n```yaml\r\neksctl delete cluster --name three-tier-cluster --region us-east-1\r\naws cloudformation delete-stack --stack-name eksctl-three-tier-cluster-cluster\r\n```\r\n\r\n4. AWS의 클라우드 형성 콘솔에서 모든 변경 사항을 확인할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n![Project Screenshot](/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_48.png)\n\n## 지금 모든 것이 삭제되었으니 AWS 요금을 줄여줘서 고마워\n\n## 오늘은 여기까지 프로젝트가 완료되었어요. 만약 여기까지 오셨다면 박수를 치세요. 그리고 LinkedIn에서 저를 팔로우해주세요.\n\n\n<div class=\"content-ad\"></div>\n\n제 깃허브 계정을 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_0.png"},"coverImage":"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>우리 시리즈의 8번째 프로젝트입니다. 계속 따라오세요!</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*ZBUzOwaMkbfPD3iZXxVH1g.gif\" alt=\"Image\"></p>\n<h2>3Tier란 무엇인가요?</h2>\n<p>사실은 시스템을 3부분으로 나누는 것을 말해요.</p>\n<ul>\n<li>\n<p>표현 계층 (티어 1):</p>\n<ul>\n<li>웹 사이트를 열 때 보는 것이 바로 표현 계층입니다. 기본적으로 이 계층은 사용자가 직접 상호 작용하는 계층입니다.</li>\n</ul>\n</li>\n<li>\n<p>논리 계층 (티어 2):</p>\n<ul>\n<li>이 계층을 뒷단의 두뇌로 상상해보세요. 사용자 인터페이스를 통해 제공하는 정보를 받아 시스템의 규칙에 따라 처리합니다. 예를 들어 쇼핑 웹 사이트의 경우, 이 계층은 물품의 총 가격을 계산하거나 할인을 적용하며 모든 제품이 재고에 있는지 확인합니다.</li>\n</ul>\n</li>\n</ul>\n<ol start=\"3\">\n<li>데이터 레이어 (티어 3):</li>\n</ol>\n<ul>\n<li>데이터가 저장되고 검색되는 곳입니다. 시스템의 메모리와 같습니다.</li>\n<li>데이터는 데이터베이스, 파일 또는 다른 데이터 저장 시스템에 저장될 수 있습니다.</li>\n<li>데이터 레이어는 시스템이 필요로 하는 정보를 관리하고 저장하는 역할을 합니다.</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_0.png\" alt=\"이미지\"></p>\n<h1>완료 단계 →</h1>\n<h1>Phase 1</h1>\n<p>EC2 인스턴스, IAM 사용자 및 EC2의 기본 도구 설정하기</p>\n<h1>Phase 2</h1>\n<p>프론트엔드 및 백엔드 이미지 빌드하기</p>\n<h1>Phase 3</h1>\n<p>쿠버네티스</p>\n<h1>Phase 4</h1>\n<p>애플리케이션 로드 밸런서 및 인그레스 설정하기</p>\n<p>Phase 5 → 모든 것 파괴하기</p>\n<h1>Phase 1 → 기본 EC2, IAM 사용자 및 EC2에 기본 도구 설정</h1>\n<h2>단계 1. IAM 사용자 생성</h2>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_1.png\" alt=\"이미지\"></p>\n<ol>\n<li>\n<p>'iam'을 클릭하세요.</p>\n</li>\n<li>\n<p>사용자를 클릭하고 사용자 생성을 클릭하세요</p>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_2.png\" alt=\"이미지\"></p>\n</li>\n<li>\n<p>사용자에게 이름을 지정하고 관리 콘솔에 사용자 액세스 제공에 체크하고 IAM 사용자 옵션을 선택하세요.</p>\n</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_3.png\" alt=\"image\"></p>\n<ol start=\"5\">\n<li>\n<p>사용자의 암호를 선택하십시오 → 다음을 클릭하세요.</p>\n</li>\n<li>\n<p>IAM 사용자에 정책을 직접 첨부 → 다음을 클릭하세요.</p>\n</li>\n</ol>\n<p>참고 → 현재는 관리자 액세스를 제공하겠지만 작업 공간에 정책을 첨부할 때 신중하시기 바랍니다.</p>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_4.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_5.png\" alt=\"이미지\"></p>\n<p>사용자를 검토하고 만들기</p>\n<ol start=\"7\">\n<li>'사용자 만들기'를 클릭하세요</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_6.png\" alt=\"Project Screenshot 6\"></p>\n<ol start=\"8\">\n<li>If the password file is autogenerated, download it. Otherwise, you can choose whether to download it or not.</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_7.png\" alt=\"Project Screenshot 7\"></p>\n<ol start=\"9\">\n<li>Click on your IAM user → Security Credentials.</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_8.png\" alt=\"Project Screenshot 8\"></p>\n<ol start=\"10\">\n<li>스크롤하여 키에 액세스하고 액세스 키를 생성합니다.</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_9.png\" alt=\"Project Screenshot 9\"></p>\n<ol start=\"11\">\n<li>옵션 목록에서 aws cli를 선택하세요.</li>\n</ol>\n<ol start=\"12\">\n<li>다음을 클릭하고 사용자 이름과 암호의 CSV 파일을 다운로드하세요</li>\n</ol>\n<h2>단계 2. 모든 작업을 수행하는 기본 EC2를 시작합니다 →</h2>\n<ul>\n<li>AWS 콘솔을 열고 EC2로 이동한 다음 EC2 시작을 클릭하세요</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_12.png\" alt=\"이미지\"></p>\n<ol start=\"2\">\n<li>연결을 클릭하고 다음 명령을 실행하세요</li>\n</ol>\n<pre><code class=\"hljs language-bash\">sudo su\napt update\n<span class=\"hljs-built_in\">mkdir</span> 3-tier\n<span class=\"hljs-built_in\">cd</span> 3-tier\n</code></pre>\n<ol start=\"3\">\n<li>깃허브에서 코드를 가져오려면 git clone을 사용하세요</li>\n</ol>\n<pre><code class=\"hljs language-js\">git clone <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//github.com/Aakibgithuber/Three-tier-Application-Deployment-.git</span>\n</code></pre>\n<ol start=\"4\">\n<li>ls를 실행하여 레포지토리 안에 무엇이 있는지 확인하세요</li>\n</ol>\n<h1>단계 3 → aws cli, 도커, kubectl 및 eksctl 설정</h1>\n<h2>1. aws cli 구성</h2>\n<p>AWS CLI (Amazon Web Services Command Line Interface)는 명령어를 사용하여 AWS 서비스와 상호 작용할 수 있는 도구입니다.</p>\n<ul>\n<li>아래 명령어를 실행하여 aws cli를 설치합니다</li>\n</ul>\n<ol>\n<li>먼저 다음 명령어로 AWS CLI를 설치해 주세요.</li>\n</ol>\n<p>snap install aws-cli --classic</p>\n<ol start=\"2\">\n<li>이제 AWS를 구성해야 합니다. 아래 명령어를 사용해 구성해 주세요.</li>\n</ol>\n<p>aws configure</p>\n<ol start=\"3\">\n<li>접근 키와 비밀 키를 요청할 것입니다. 이제 앞서 다운로드한 CSV 파일을 열어서 액세스 키와 비밀 키를 복사해 주세요.</li>\n</ol>\n<ol start=\"4\">\n<li>모든 것을 그대로 유지하고 Enter 키를 누르세요.</li>\n</ol>\n<p>지금까지 AWS CLI를 설정하셨습니다. 이제 Docker를 설정하세요.</p>\n<h2>2. Docker 설정</h2>\n<ul>\n<li>다음 명령어를 실행해주세요</li>\n</ul>\n<pre><code class=\"hljs language-js\">apt install docker.<span class=\"hljs-property\">io</span>\nusermod -aG docker $USER # 사용자 이름으로 변경해주세요. 예: <span class=\"hljs-string\">'ubuntu'</span>\nnewgrp docker\nsudo chmod <span class=\"hljs-number\">777</span> /<span class=\"hljs-keyword\">var</span>/run/docker.<span class=\"hljs-property\">sock</span>\nwhich docker\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_15.png\" alt=\"이미지\"></p>\n<h2>3. kubectl 설정하기</h2>\n<p>이것은 Kubernetes 클러스터를 관리하고 상호 작용하는 데 사용되는 명령 줄 도구입니다.</p>\n<ul>\n<li>kubectl을 설치하려면 다음 명령을 실행하십시오.</li>\n</ul>\n<pre><code class=\"hljs language-js\">snap install kubectl --classic\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_16.png\" alt=\"이미지\"></p>\n<h2>4. eksctl 설정</h2>\n<p>이것은 Amazon EKS (Elastic Kubernetes Service) 클러스터를 관리하는 데 사용되는 명령줄 도구입니다.</p>\n<ul>\n<li>eksctl 도구를 설치하려면 다음 명령을 실행하십시오</li>\n</ul>\n<pre><code class=\"hljs language-js\">curl --silent --location <span class=\"hljs-string\">\"https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz\"</span> | tar xz -C /tmp\nsudo mv /tmp/eksctl /usr/local/bin\neksctl version\n</code></pre>\n<h1>Phase 2 → 프론트엔드 및 백엔드 이미지 구축</h1>\n<h2>단계 1 → Elastic Container Registry (ECR) 설정</h2>\n<p>도커 이미지를 저장하는 도커허브와 유사합니다.</p>\n<ul>\n<li>AWS 콘솔로 이동해서 ECR을 검색해주세요.</li>\n<li>프론트엔드를 위한 저장소를 만들고 가시성 설정을 \"퍼블릭\"으로 설정해주세요.</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_18.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_19.png\" alt=\"이미지\"></p>\n<ol start=\"3\">\n<li>백엔드 저장소 설정</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_20.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_21.png\" alt=\"이미지\"></p>\n<h2>단계 2 → 프론트엔드 설정</h2>\n<ul>\n<li>터미널에서 프론트엔드 디렉토리로 이동하고 ls 명령어를 실행하세요</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_22.png\" alt=\"이미지\"></p>\n<ol start=\"2\">\n<li>Amazon ECR 저장소로 이동하고 푸시 명령 보기를 클릭합니다</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_23.png\" alt=\"이미지\"></p>\n<ol start=\"3\">\n<li>위 명령을 하나씩 실행하여 프론트엔드 이미지를 빌드하고 ECR 저장소에 푸시합니다</li>\n</ol>\n<pre><code class=\"hljs language-js\">aws ecr-public get-login-password --region us-east-<span class=\"hljs-number\">1</span> | docker login --username <span class=\"hljs-variable constant_\">AWS</span> --password-stdin public.<span class=\"hljs-property\">ecr</span>.<span class=\"hljs-property\">aws</span>/l0l7e4u1\ndocker build -t <span class=\"hljs-number\">3</span>-tier-frontend .\ndocker tag <span class=\"hljs-number\">3</span>-tier-<span class=\"hljs-attr\">frontend</span>:latest public.<span class=\"hljs-property\">ecr</span>.<span class=\"hljs-property\">aws</span>/l0l7e4u1/<span class=\"hljs-number\">3</span>-tier-<span class=\"hljs-attr\">frontend</span>:latest\ndocker push public.<span class=\"hljs-property\">ecr</span>.<span class=\"hljs-property\">aws</span>/l0l7e4u1/<span class=\"hljs-number\">3</span>-tier-<span class=\"hljs-attr\">frontend</span>:latest\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_24.png\" alt=\"Project Image 24\"></p>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_25.png\" alt=\"Project Image 25\"></p>\n<ol start=\"4\">\n<li>이미지에서 컨테이너를 실행해 보겠습니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\">도커 이미지 목록에서 이미지 이름을 복사하세요.\n도커 실행 -d -p <span class=\"hljs-number\">3000</span>:<span class=\"hljs-number\">3000</span> <span class=\"hljs-number\">3</span>-tier-<span class=\"hljs-attr\">frontend</span>:latest\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_26.png\" alt=\"이미지1\"></p>\n<p>프론트엔드가 설정되었고 애플리케이션이 실행 중입니다. 애플리케이션을 확인하려면 브라우저에서 해당 주소로 이동하세요 →public-ip:3000</p>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_27.png\" alt=\"이미지2\"></p>\n<h2>단계 3 → 백엔드 설정</h2>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_28.png\" alt=\"이미지\"></p>\n<ul>\n<li>이제 백엔드 디렉토리로 이동하여 백엔드를 설정하세요.</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_29.png\" alt=\"이미지\"></p>\n<ol start=\"2\">\n<li>ECR 리포지토리로 이동하여 백엔드 리포지토리의 푸시 명령을 보기 위해 클릭하세요</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_30.png\" alt=\"백엔드 리포지토리 푸시 명령\"></p>\n<ol start=\"3\">\n<li>위 명령을 단계별로 터미널에서 실행해주세요</li>\n</ol>\n<pre><code class=\"hljs language-js\">aws ecr-public get-login-password --region us-east-<span class=\"hljs-number\">1</span> | docker login --username <span class=\"hljs-variable constant_\">AWS</span> --password-stdin public.<span class=\"hljs-property\">ecr</span>.<span class=\"hljs-property\">aws</span>/l0l7e4u1\ndocker build -t <span class=\"hljs-number\">3</span>-tier-backend .\ndocker tag <span class=\"hljs-number\">3</span>-tier-<span class=\"hljs-attr\">backend</span>:latest public.<span class=\"hljs-property\">ecr</span>.<span class=\"hljs-property\">aws</span>/l0l7e4u1/<span class=\"hljs-number\">3</span>-tier-<span class=\"hljs-attr\">backend</span>:latest\ndocker push public.<span class=\"hljs-property\">ecr</span>.<span class=\"hljs-property\">aws</span>/l0l7e4u1/<span class=\"hljs-number\">3</span>-tier-<span class=\"hljs-attr\">backend</span>:latest\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_31.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_32.png\" alt=\"이미지\"></p>\n<p>이제 백엔드 이미지가 성공적으로 빌드되었고, 우리가 탄력적인 쿠버네티스 서비스를 생성할 때 사용한 Elastic Container Registry에 푸시되었습니다.</p>\n<h1>Phase 3 Kubernetes</h1>\n<ul>\n<li>\n<p>배포란 무엇인가요?</p>\n</li>\n<li>\n<p>공장을 상상해보세요: 배포는 여러분의 소프트웨어 응용 프로그램의 사본을 생성하고 관리하는 공장으로 생각해보세요.</p>\n</li>\n<li>\n<p>여러 복제본: 공장이 여러 개의 동일한 항목을 생성할 수 있는 것처럼, Kubernetes의 배포는 응용 프로그램의 여러 사본(복제본)을 생성하고 다룰 수 있습니다.</p>\n</li>\n<li>\n<p>간편한 업데이트: 응용 프로그램을 변경하거나 업데이트하려면, 배포 시스템이 그것을 원활하게 처리할 수 있습니다. 마치 공장에서 부품을 교체하면서 생산을 멈추지 않는 것처럼요.</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>서비스란 무엇인가요?</li>\n</ol>\n<ul>\n<li>수신 데스크를 상상해보세요: Kubernetes의 서비스를 건물의 수신 데스크처럼 생각해보세요.</li>\n<li>중앙 연락처: 서비스는 응용 프로그램을 위한 중앙 연락처를 제공합니다. 직접 각 응용 프로그램을 찾는 대신 시스템의 다른 부분들이 서비스와 대화하고, 서비스가 올바른 응용 프로그램을 찾는 방법을 알고 있습니다.</li>\n<li>안정적인 주소: 수신 데스크에 일정한 주소가 있는 것처럼, 서비스에도 시스템의 다른 부분들이 응용 프로그램과 통신하기 위해 사용할 수 있는 안정적인 주소가 있습니다.</li>\n</ul>\n<ol start=\"3\">\n<li>Namespace란 무엇인가요?</li>\n</ol>\n<ul>\n<li>이것은 쿠버네티스 내에서 당신이 어플리케이션을 조직하고 실행할 수 있는 레이블이 붙은 섹션과 같습니다. 각 네임스페이스는 당신의 어플리케이션이 서로 방해하지 않고 자신의 일을 할 수 있는 울타리 치여진 영역과 같습니다.</li>\n<li>좀 더 간단하게 말하면, 쿠버네티스에서의 네임스페이스는 다른 프로젝트나 어플리케이션을 분리하고 조직화하며, 쿠버네티스 클러스터의 분주한 환경에서 쉽게 관리할 수 있도록 하는 방법입니다.</li>\n</ul>\n<h2>Step 1 → EKS 클러스터 설정하고 네임스페이스 생성하기</h2>\n<ul>\n<li>다음 명령어를 실행하여 EKS 클러스터를 설정하세요.</li>\n</ul>\n<pre><code class=\"hljs language-js\">eksctl create cluster --name three-tier-cluster --region us-east-<span class=\"hljs-number\">1</span> --node-type t2.<span class=\"hljs-property\">medium</span> --nodes-min <span class=\"hljs-number\">2</span> --nodes-max <span class=\"hljs-number\">2</span>\naws eks update-kubeconfig --region us-east-<span class=\"hljs-number\">1</span> --name three-tier-cluster\nkubectl get nodes\n</code></pre>\n<ol start=\"2\">\n<li>클러스터를 생성하는 데 15~20분이 소요됩니다.</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_33.png\" alt=\"이미지\"></p>\n<ol start=\"3\">\n<li>AWS 콘솔에서 AWS CloudFormation을 검색하여 EKS 클러스터 생성 중 발생하는 이벤트를 확인하세요.</li>\n</ol>\n<p>아래 명령어를 사용하여 Namesapce를 생성하세요.</p>\n<pre><code class=\"hljs language-shell\">kubectl create namespace workshop\nkubectl config set-context --current --namespace workshop\n</code></pre>\n<h2>단계 2→ 프론트엔드를 위한 배포 및 서비스 생성하기</h2>\n<ul>\n<li>k8s_manifests 디렉토리로 이동하면 프론트엔드를 위한 배포 및 서비스 파일을 찾을 수 있습니다.</li>\n</ul>\n<ol start=\"2\">\n<li>\n<p>frontend-deployment.yaml 파일을 편집해야 합니다.</p>\n</li>\n<li>\n<p>바꿔야 할 것은 이미지 이름입니다.</p>\n</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_38.png\" alt=\"image\"></p>\n<ol start=\"4\">\n<li>따라서 ECR 레포지토리로 이동하여 프론트엔드 레포지토리를 선택한 후 \"View public listing\"을 클릭하여 이미지 이름을 복사하고 frontend-deployment.yaml 파일에 붙여넣으세요.</li>\n</ol>\n<p>이제 다음 명령어를 실행하여 프론트엔드용 배포 및 서비스를 생성하세요.</p>\n<pre><code class=\"hljs language-js\">kubectl apply -f frontend-deployment.<span class=\"hljs-property\">yaml</span>\nkubectl apply -f frontend-service.<span class=\"hljs-property\">yaml</span>\n</code></pre>\n<h2>단계 3→ 백엔드용 배포 및 서비스 생성</h2>\n<ul>\n<li>동일한 폴더에 백엔드 배포 및 서비스인 backend-deployment.yaml 및 backend-service.yaml 파일이 있습니다.</li>\n<li>backend-deployment.yaml 파일을 편집해야 합니다.</li>\n<li>변경해야 할 것은 이미지 이름뿐입니다.</li>\n<li>따라서 ECR 저장소로 이동하여 백엔드 저장소를 선택한 다음, \"View Public Listing\"을 클릭하여 이미지 이름을 복사한 후 backend-deployment.yaml 파일 안에 붙여넣으세요.</li>\n</ul>\n<p>이제 다음 명령을 실행하여 배포 및 백엔드 서비스를 생성하십시오.</p>\n<pre><code class=\"hljs language-js\">kubectl apply -f backend-deployment.<span class=\"hljs-property\">yaml</span>\nkubectl apply -f backend-service.<span class=\"hljs-property\">yaml</span>\nkubectl get pods -n workshop\n</code></pre>\n<p>이제 우리의 2계층이 준비되었습니다. 즉, 프론트엔드와 백엔드가 설정되었습니다. 이제 세 번째 계층을 설정해 봅시다.</p>\n<h2>단계 4 → 데이터베이스 계층 설정</h2>\n<ul>\n<li>배포, 서비스 및 시크릿 매니페스트를 저장하는 몽고 폴더를 찾아주세요.</li>\n</ul>\n<ol start=\"2\">\n<li>아래 명령어를 실행하여 데이터베이스 티어를 설정하세요.</li>\n</ol>\n<pre><code class=\"hljs language-js\">kubectl apply -f .\nkubectl get all\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_39.png\" alt=\"이미지\"></p>\n<p>이제 모든 세 티어가 준비되었습니다. 하지만 이들을 어떻게 액세스할까요? 클러스터로 외부 트래픽을 전송하기 위해 애플리케이션 로드 밸런서를 생성해야 하고, 내부의 3개 티어 사이를 연결하기 위해 인그레스를 만들어야 합니다.</p>\n<h1>단계 4 → 애플리케이션 로드 밸런서와 인그레스 설정</h1>\n<p>외부 트래픽을 클러스터로 전송하기 위해 애플리케이션 로드 밸런서를 생성하고, 내부의 3개 티어 사이를 연결할 인그레스를 만들어야 합니다.</p>\n<h2>단계 1 → AWS 로드 밸런서 설정; 설치 및 EKS 클러스터에 연결</h2>\n<ol>\n<li>아래 명령은 ALB의 IAM 정책을 가져옵니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\">curl -O <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/v2.5.4/docs/install/iam_policy.json</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_40.png\" alt=\"이미지\"></p>\n<ol start=\"2\">\n<li>이 명령어는 첫 번째 명령어에서 설정한 <code>iam_policy.json</code> 파일을 사용하여 AWS 계정에서 IAM 정책을 생성합니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\">aws iam create-policy --policy-name <span class=\"hljs-title class_\">AWSLoadBalancerControllerIAMPolicy</span> --policy-<span class=\"hljs-variable language_\">document</span> <span class=\"hljs-attr\">file</span>:<span class=\"hljs-comment\">//iam_policy.json</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_41.png\" alt=\"Image\"></p>\n<ol start=\"3\">\n<li>이 명령은 로드 밸런서 정책을 EKS 클러스터에 적용하여 정책에 따라 EKS 클러스터가 로드 밸런서와 함께 작동하도록 합니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\">eksctl utils associate-iam-oidc-provider --region=us-east-<span class=\"hljs-number\">1</span> --cluster=three-tier-cluster --approve\n</code></pre>\n<p>아래 명령어는 클러스터에 서비스 계정을 생성하고 추가하여 클러스터가 로드 밸런서 서비스와 작업할 수 있도록합니다.</p>\n<p>아래 명령어에서 AWS 계정 번호를 꼭 변경해야 합니다. 그렇지 않으면 작동하지 않습니다.</p>\n<pre><code class=\"hljs language-js\">eksctl create iamserviceaccount --cluster=three-tier-cluster --namespace=kube-system --name=aws-load-balancer-controller --role-name <span class=\"hljs-title class_\">AmazonEKSLoadBalancerControllerRole</span> --attach-policy-arn=<span class=\"hljs-attr\">arn</span>:<span class=\"hljs-attr\">aws</span>:<span class=\"hljs-attr\">iam</span>::<span class=\"hljs-number\">767397866747</span>:policy/<span class=\"hljs-title class_\">AWSLoadBalancerControllerIAMPolicy</span> --approve --region=us-east-<span class=\"hljs-number\">1</span>\n</code></pre>\n<h2>모든 정책이 첨부되었습니다. 로드 밸런서를 배포해 봅시다.</h2>\n<ol start=\"5\">\n<li>이를 위해 helm을 설치해야 합니다. Helm은 쿠버네티스를 사용할 때 소프트웨어를 쉽게 운반하고 관리하는 데 도움이 되는 특별한 도구입니다. 쿠버네티스는 애플리케이션을 실행하기 위한 큰 놀이터와 같습니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\">sudo snap install helm --classic\n</code></pre>\n<ol start=\"6\">\n<li>이제 로드 밸런서를 위해 eks 리포지토리에서 미리 작성된 특정 manifest 파일을 추가해야 해요. helm을 사용하여 다음 명령을 실행해주세요.</li>\n</ol>\n<pre><code class=\"hljs language-js\">helm repo add eks <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//aws.github.io/eks-charts</span>\n</code></pre>\n<ol start=\"7\">\n<li>helm을 사용하여 eks 리포지토리를 업데이트해주세요.</li>\n</ol>\n<pre><code class=\"hljs language-js\">helm repo update eks\n</code></pre>\n<ol start=\"8\">\n<li>EKS 클러스터에 로드 밸런서 컨트롤러를 설치해주세요</li>\n</ol>\n<pre><code class=\"hljs language-js\">helm install aws-load-balancer-controller eks/aws-load-balancer-controller -n kube-system --set clusterName=my-cluster --set serviceAccount.<span class=\"hljs-property\">create</span>=<span class=\"hljs-literal\">false</span> --set serviceAccount.<span class=\"hljs-property\">name</span>=aws-load-balancer-controller\nkubectl get deployment -n kube-system aws-load-balancer-controller\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_44.png\" alt=\"Image\"></p>\n<p>이제 로드 밸런서가 작동되니 내부 라우팅을 위해 인그레스를 설정합시다.</p>\n<h2>Step 2 → 내부 라우팅을 위한 Ingress 설정</h2>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_45.png\" alt=\"이미지\"></p>\n<ul>\n<li>full_stack_lb.yaml 파일을 찾습니다</li>\n</ul>\n<pre><code class=\"hljs language-js\">kubectl apply -f full_stack_lb.<span class=\"hljs-property\">yaml</span>\nkubectl get ing -n workshop\n</code></pre>\n<ol start=\"2\">\n<li>웹 브라우저로 이동하여 위의 DNS 주소를 붙여넣으세요</li>\n</ol>\n<p>축하합니다!! 여러분의 애플리케이션이 로드 밸런서 인그레스를 통해 접근 가능합니다</p>\n<h1>5 단계 → 모두 삭제하기</h1>\n<ul>\n<li>현재 폴더에서 다음을 실행하세요</li>\n</ul>\n<pre><code class=\"hljs language-js\">kubectl <span class=\"hljs-keyword\">delete</span> -f .\n</code></pre>\n<ol start=\"2\">\n<li>데이터베이스 계층을 삭제하려면 몽고 폴더로 이동하세요</li>\n</ol>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-string\">kubectl</span> <span class=\"hljs-string\">delete</span> <span class=\"hljs-string\">-f</span> <span class=\"hljs-string\">.</span>\n</code></pre>\n<ol start=\"3\">\n<li>클러스터 및 클라우드 형성 스택을 삭제하세요.</li>\n</ol>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-string\">eksctl</span> <span class=\"hljs-string\">delete</span> <span class=\"hljs-string\">cluster</span> <span class=\"hljs-string\">--name</span> <span class=\"hljs-string\">three-tier-cluster</span> <span class=\"hljs-string\">--region</span> <span class=\"hljs-string\">us-east-1</span>\r\n<span class=\"hljs-string\">aws</span> <span class=\"hljs-string\">cloudformation</span> <span class=\"hljs-string\">delete-stack</span> <span class=\"hljs-string\">--stack-name</span> <span class=\"hljs-string\">eksctl-three-tier-cluster-cluster</span>\n</code></pre>\n<ol start=\"4\">\n<li>AWS의 클라우드 형성 콘솔에서 모든 변경 사항을 확인할 수 있어요.</li>\n</ol>\n<p><img src=\"/assets/img/2024-06-23-Project8ThreetierapplicationdeploymentonKubernetes_48.png\" alt=\"Project Screenshot\"></p>\n<h2>지금 모든 것이 삭제되었으니 AWS 요금을 줄여줘서 고마워</h2>\n<h2>오늘은 여기까지 프로젝트가 완료되었어요. 만약 여기까지 오셨다면 박수를 치세요. 그리고 LinkedIn에서 저를 팔로우해주세요.</h2>\n<p>제 깃허브 계정을 팔로우해주세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}