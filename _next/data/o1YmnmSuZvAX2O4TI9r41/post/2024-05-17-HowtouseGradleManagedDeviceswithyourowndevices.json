{"pageProps":{"post":{"title":"자신의 디바이스와 함께 Gradle 관리 디바이스를 사용하는 방법","description":"","date":"2024-05-17 17:48","slug":"2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices","content":"\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_0.png\" />\n\n요즘 Google은 안드로이드 Gradle 플러그인을 위한 새로운 기능, Firebase Test Lab for Gradle Managed Devices를 소개했어요. 이 기능은 Gradle Managed Devices API를 사용하여 테스트를 Gradle이 실행되는 동일한 기계가 아니라 Firebase Test Lab(유료 기능) 내에서 원격 가상 또는 물리 장치에서 시작합니다. 이 기사에서는 해당 기능과 Firebase Test Lab과 같은 방식으로 테스트를 원격으로 시작하기 위해 자체 디바이스 팜을 사용하는 방법, 그리고 여러 장치 간에 실행을 병렬화하는 방법에 대해 다룰 거예요.\n\n# Gradle Managed Devices\n\n처음에는 Gradle Managed Devices가 안드로이드 Gradle 플러그인에게 에뮬레이터의 생성, 시작 및 종료 과정을 위임하는 목적으로 출시되었습니다.\n\n<div class=\"content-ad\"></div>\n\n\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"pixel2api30\", com.android.build.api.dsl.ManagedVirtualDevice) {\n                    device = \"Pixel 2\"\n                    apiLevel = 30\n                    systemImageSource = \"aosp\"\n                }\n            }\n        }\n    }\n}\n\n\n위의 구성을 사용하면 pixel2api30Check 작업을 통해 UI 테스트를 실행할 수 있으며, 기기를 연결하거나 에뮬레이터를 실행할 필요가 없습니다. 이 테스트 실행 환경은 다양한 기계에서 동일합니다.\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_1.png\" />\n\n# Firebase Test Lab\n\n\n<div class=\"content-ad\"></div>\n\n파이어베이스 테스트 랩을 통한 Gradle Managed Devices는 Android Dev Summit 2022에서 최근 소개된 새로운 기능입니다. 이제 Gradle에서 바로 테스트 랩에서 UI 테스트를 실행할 수 있어서 명령줄 도구나 웹 UI를 사용할 필요가 없어졌어요.\n\n```js\nplugins {\n    id 'com.google.firebase.testlab'\n}\n\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"pixel2api30\", com.google.firebase.testlab.gradle.ManagedDevice) {\n                    device = \"Pixel2\"\n                    apiLevel = 30\n                }\n            }\n        }\n    }\n}\n```\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_2.png\" />\n\n우리 자신의 장치로도 같은 작업을 할 수 있을까요? 함께 알아봐요.\n\n<div class=\"content-ad\"></div>\n\n# 커스텀 디바이스 구현\n\n여러분이 아시다시피, 저희는 com.android.build.api.dsl.ManagedVirtualDevice 또는 com.google.firebase.testlab.gradle.ManagedDevice를 사용하고 있는데, 이 둘 모두 com.android.build.api.dsl.Device 인터페이스를 구현하고 있습니다. 그래서 우리가 직접 커스텀한 디바이스를 구현하려고 하면 어떻게 될까요?\n\n필요한 Gradle 코드, 플러그인 등을 모두 추가할 새 모듈을 만들어봅시다. buildSrc 폴더를 사용하거나 새로운 included build를 생성하여 할 수 있습니다. 여기서는 새로운 Gradle 플러그인을 생성하는 과정에 대해서는 다루지 않겠지만, 관련 정보는 공식 문서나 저의 다른 글에서 찾아볼 수 있습니다.\n\n새로 생성한 Gradle 플러그인 모듈에서 MyDevice를 선언하고 해당 디바이스를 애플리케이션 모듈의 build.gradle에서 사용해보세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n인터페이스 MyDevice : Device\n```\n\n```js\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"myDevice\", MyDevice) {}\n            }\n        }\n    }\n}\n```\n\n프로젝트를 동기화하려고 하면 다음 예외가 발생합니다: 이 컨테이너에서 MyDevice를 생성할 수 없습니다. 이것은 android.testOptions.managedDevices.devices 컨테이너가 MyDevice를 인스턴스화할 방법을 모르기 때문입니다. 왜냐하면 MyDevice가 인터페이스이기 때문입니다.\n\n그렇다면 Android Gradle 플러그인은 이 문제를 어떻게 관리할까요? com.android.build.api.dsl.ManagedVirtualDevice를 검색하면 다음 코드를 찾을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ndslServices.polymorphicDomainObjectContainer(Device::class.java).apply {\n    registerBinding(\n        com.android.build.api.dsl.ManagedVirtualDevice::class.java,\n        com.android.build.gradle.internal.dsl.ManagedVirtualDevice::class.java\n    )\n}\n```\n\nregisterBinding을 사용하면 플러그인은 컨테이너에 com.android.build.api.dsl.ManagedVirtualDevice 유형의 어떤 것을 추가하려고 시도하는 API 클라이언트가 있을 때 내부 클래스 com.android.build.gradle.internal.dsl.ManagedVirtualDevice를 사용하도록 지시하는 것입니다. 컨테이너는 ManagedVirtualDevice 클래스의 인스턴스를 생성하고 해당 인스턴스를 register 메소드의 람다에 제공할 것입니다.\n\n동일한 작업을 하기 위해 MyDevice를 구현하는 추상 클래스와 사용자 지정 Gradle 플러그인이 필요하며 해당 플러그인을 프로젝트에 적용해야 합니다.\n\n```js\ninternal abstract class MyDeviceImpl(\n    private val name: String,\n): MyDevice {\n    override fun getName(): String = name\n}\n\nclass MyDevicePlugin : Plugin<Project> {\n    override fun apply(target: Project) {\n        target.plugins.withType(AndroidBasePlugin::class.java) {\n            target.extensions.configure(CommonExtension::class.java) {\n                it.testOptions.managedDevices.devices.registerBinding(\n                    MyDevice::class.java,\n                    MyDeviceImpl::class.java,\n                )\n            }\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nplugins {\n    id `my-device-plugin`\n}\n\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"myDevice\", MyDevice) {}\n            }\n        }\n    }\n}\n```\n\n그래서 다시 동기화를 시도하여 다른 예외를 확인해 봅시다:\n\n```js\nCaused by: java.lang.IllegalStateException: 지원되지 않는 관리형 장치 유형: \n class com.bumble.devicefarm.plugin.device.farm.DeviceFarmImpl_Decorated\n at com.android.build.gradle.internal.TaskManager.createTestDevicesForVariant(TaskManager.kt:1905)\n```\n\n스택 추적을 따라가보면, gradle.properties에 android.experimental.testOptions.managedDevices.customDevice=true를 추가해야 하며 MyDevice는 ManagedDeviceTestRunnerFactory를 구현해야 한다는 것을 알 수 있습니다. 따라서 더 자세히 조사해 보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n내부 추상 클래스 MyDeviceImpl(\n  private val name: String\n) : MyDevice, ManagedDeviceTestRunnerFactory {\n\n  override fun getName(): String = name\n\n  override fun createTestRunner(\n    project: Project,\n    workerExecutor: WorkerExecutor,\n    useOrchestrator: Boolean,\n    enableEmulatorDisplay: Boolean\n  ): ManagedDeviceTestRunner =\n    MyDeviceTestRunner()\n\n}\n```\n\n팩토리 자체에는 중요한 값이 없습니다. 반환되는 클래스 ManagedDeviceTestRunner이 더 흥미로운 부분입니다.\n\n```kotlin\ninterface ManagedDeviceTestRunner {\n\n  // 모든 테스트 케이스가 통과되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.\n  fun runTests(\n    managedDevice: Device,\n    runId: String,\n    outputDirectory: File,\n    coverageOutputDirectory: File,\n    additionalTestOutputDir: File?,\n    projectPath: String,\n    variantName: String,\n    testData: StaticTestData,\n    additionalInstallOptions: List<String>,\n    helperApks: Set<File>,\n    logger: Logger\n  ): Boolean\n\n}\n```\n\nrunTests 메서드는 각 Gradle 모듈에 대해 호출되며, 테스트를 실행하는 데 사용할 수 있는 많은 데이터가 포함되어 있습니다. 여기서 testData를 사용하여 APK를 가져와 설치하고, 계장을 통해 테스트를 실행할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# Instrumentation\n\n안녕하세요! 안드로이드 스튜디오에서 테스트를 실행하는 방법은 대부분 우리가 잘 알고 있습니다. 테스트 이름 근처의 실행 버튼을 클릭하거나 Gradle을 통해 connectedAndroidTest를 실행하는 방법이 있죠. 이제 이러한 도구 없이도 어떻게 테스트를 실행할 수 있는지 알아봅시다.\n\n이 두 가지 접근 방법은 디바이스에서 am instrument 명령을 사용합니다. 이 명령은 ADB를 통해 실행됩니다. 더 자세한 내용은 공식 문서를 참고해보세요.\n\n```js\nadb shell am instrument -w <test_package_name>/<runner_class>\n```\n\n<div class=\"content-ad\"></div>\n\n테스트를 실행하려면 runTests 메서드에서 동일한 작업을 해야 합니다. ADB 작업을 수행하기 위해 mobile.dev의 dadb 라이브러리를 사용할 것입니다. 이 라이브러리를 사용하면 ADB 실행 파일을 이용하지 않고 ADB 프로토콜을 통해 디바이스에 직접 연결할 수 있습니다. 이렇게 하면 작업 속도가 향상되며 편리하게 사용할 수 있습니다. 관련 블로그 포스트에서 이에 대해 자세히 읽을 수 있습니다.\n\nrunTests 메서드 내에서 Dadb를 사용하여 로컬 에뮬레이터에 연결하고 APK를 설치하고 테스트를 실행해보겠습니다.\n\n```kotlin\noverride fun runTests(...): Boolean {\n    // 로컬 에뮬레이터에 연결\n    Dadb.create(\"localhost\", 5555).use { dadb ->\n        // 애플리케이션 APK 설치\n        val apks = testData.testedApkFinder.invoke(DadbDeviceConfigProvider(dadb))\n        // 라이브러리 모듈인 경우 비워둡니다.\n        if (apks.isNotEmpty()) {\n            // 앱 번들을 지원하기 위해 여러 개의 APK 설치 사용\n            dadb.installMultiple(apks)\n        }\n        // 계기 APK 설치\n        dadb.install(testData.testApk)\n\n        // 테스트 실행\n        dadb.shell(\"am instrument -w ${testData.applicationId}/${testData.instrumentationRunner}\")\n    }\n    return true\n}\n```\n\nrunTests 메서드와 StaticTestData 클래스에는 많은 매개변수가 있습니다. 단순화를 위해 모든 것이 작동하는 데 필요한 최소한의 세트만 사용할 것입니다. 다음과 같은 것을 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- testData.testedApkFinder는 필요한 애플리케이션 APK를 가져오기 위해 사용됩니다. 라이브러리 모듈의 경우 빈 목록을 반환합니다. App Bundle에서 적절한 APK 목록을 제공하기 위해 DeviceConfigProvider를 받습니다.\n- testData.testApk은 androidTest 폴더에서 코드를 포함하는 instrumentation APK입니다.\n- testData.applicationId는 instrument 명령으로 실행해야 하는 애플리케이션 ID입니다.\n- testData.instrumentationRunner는 build.gradle 파일에서 지정한 androidx.test.runner.AndroidJUnitRunner와 같은 테스트 러너입니다.\n\n일단 사용자 정의 DeviceConfigProvider의 구현은 건너뜁니다. 이는 dadb.shell(\"getptop name\").output과 같은 다수의 속성에 대해 locale, 화면 밀도, 언어, 지역 및 ABI를 가져오도록 단순히 호출할 뿐입니다. 프로젝트 저장소에서 구현 세부 정보를 확인할 수 있습니다.\n\n지금까지 다음 구조를 구현했습니다:\n\n![image](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_3.png)\n\n<div class=\"content-ad\"></div>\n\n# 결과 가져오기\n\nrunTests 메서드는 모든 테스트가 통과되면 true를 반환해야 하지만, 지금은 항상 true를 반환합니다. 계기 결과를 얻기 위해 조금 더 파고들어야 합니다.\n\n기본적으로 명령줄에서 am instrument를 실행하려고 하면 실패 사항과 최종 결과만을 볼 수 있습니다. 더 많은 정보를 표시하려면 -r 및 -m 두 가지 플래그가 있습니다. 첫 번째는 결과를 텍스트 스트림으로 반환하고, 두 번째는 프로토콜 버퍼 스트림으로 반환합니다(API `= 26에서만 지원됨). 간단히 하기 위해 지금은 두 번째를 사용하겠습니다.\n\nAndroid Gradle 플러그인은 RemoteAndroidTestRunner.StatusReporterMode.PROTO_STD 열거형을 사용하여 am instrument에서 원시 데이터를 수용할 수 있는 IInstrumentationResultParser 인스턴스를 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nval mode = RemoteAndroidTestRunner.StatusReporterMode.PROTO_STD\nval parser = mode.createInstrumentationResultParser(runId, emptyList())\n\nDadb.create(host, port).use { dadb ->\n    ...\n    dadb\n        .openShell(\"am instrument -w ${mode.amInstrumentCommandArg} $arguments ${testData.applicationId}/${testData.instrumentationRunner}\")\n        .use { stream ->\n            while (true) {\n                val packet: AdbShellPacket = stream.read()\n                if (packet is AdbShellPacket.Exit) break\n                parser.addOutput(packet.payload, 0, packet.payload.size)\n            }\n            parser.flush()\n        }\n    ...\n}\n```\n\n이번에는 shell 메서드 대신 openShell 메서드를 사용합니다. 이 메서드는 Protocol Buffers 스트림인 원시 데이터 스트림에 액세스할 수 있도록 해줍니다. 이 데이터는 IInstrumentationResultParser로 전달됩니다.\n\n# HTML 및 XML 보고서 및 암시적인 예상\n\nIInstrumentationResultParser는 테스트와 상태에 대해 청취자들에게 알립니다. emptyList()를 전달했을 것을 알 수 있습니다. 어떤 파서를 사용해야 할지 고려해보겠습니다. 몇 가지 사전 제작된 구현이 있지만, Android Gradle 플러그인이 ManagedVirtualDevice를 실행할 때 사용하는 com.android.build.gradle.internal.testing.CustomTestRunListener를 사용해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nval xmlWriterListener = CustomTestRunListener(\n    name,\n    projectPath,\n    variantName,\n    LoggerWrapper(logger),\n)\nxmlWriterListener.setReportDir(outputDirectory)\nxmlWriterListener.setHostName(\"localhost:5555\")\n...\nval parser = mode.createInstrumentationResultParser(runId, listOf(xmlWriterListener))\n...\nreturn !xmlWriterListener.runResult.hasFailedTests()\n```\n\nCustomTestRunListener은 XmlTestRunListener를 확장하고 Android Gradle 플러그인, TeamCity 또는 여러분께 사용될 수 있는 테스트의 XML 보고서를 작성할 것입니다.\n\n만약 CustomTestRunListener로 보고서를 생성하지 않고 myDeviceDebugAndroidTest를 실행하려고 하면, com.android.build.gradle.internal.tasks.ManagedDeviceInstrumentationTestResultAggregationTask에서 예외로 실패할 것입니다. 적어도 TEST-로 시작하는 하나의 XML 보고서를 생성할 것으로 예상합니다. 그리고 CustomTestRunListener야말로 이를 강요합니다. 이 작업은 XML과 HTML 보고서를 생성할 것이며, 아래 스크린샷에서 확인할 수 있습니다:\n\n![스크린샷](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_4.png)\n  \n\n<div class=\"content-ad\"></div>\n\n이제 CustomTestRunListener를 사용하여 runTests 메서드에서 적절한 값을 반환할 수 있습니다. hasFailedTests 메서드에 액세스할 수 있기 때문입니다.\n\n# 원격 실행\n\nDadb.create를 사용할 때 localhost뿐만 아니라 모든 IP 주소를 전달할 수도 있습니다. 이는 코드를 사용하여 원격 에뮬레이터나 장치에서 테스트를 실행할 수 있다는 것을 의미합니다. 이를 위해 MyDevice를 설정 가능하게 만들 수 있습니다.\n\n```js\ninterface MyDevice : Device {\n\n    @get:Input\n    val host: Property<String>\n\n    @get:Input\n    val port: Property<Int>\n\n}\n\ninternal abstract class MyDeviceImpl(\n    private val name: String,\n) : RemoteDevice, ManagedDeviceTestRunnerFactory {\n\n    init {\n        // 기본 매개변수\n        host.convention(\"localhost\")\n        port.convention(5555)\n    }\n\n    ...\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nregister(\"remoteDevice\", MyDevice) {\n    it.host = \"192.168.3.4\"\n    it.port = 43617\n}\n```\n\n그런 다음 `Dadb.create(managedDevice.host.get(), managedDevice.port.get())`를 사용하세요.\n\n![이미지](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_5.png)\n\n주의 깊게 읽는 독자는 이미 코드 없이 이를 수행할 수 있다는 것을 올바르게 알아차릴 수 있을 것입니다. 원격 장치를 adb 장치 목록에 표시하려면 adb connect IP:PORT를 호출하기만 하면 된다는 것이 충분하며, Android Studio 드롭다운 메뉴 안에서도 바로 확인할 수 있습니다. Gradle Managed Devices로 할 수 없는 테스트 디버깅을 할 수도 있습니다. 그러나 이러한 점을 수행할 수 있다는 것은 다음 단계에 중요한 요소입니다.\n\n<div class=\"content-ad\"></div>\n\n# 병렬 실행\n\n기본적으로 테스트를 실행할 때 한 번에 한 장치에서만 실행됩니다. 여러 장치나 에뮬레이터에서 테스트를 병렬로 실행할 수 있는 기능이 있다면 좋을텐데요. 좋은 소식은 그런 방법을 찾았다는 것입니다.\n\nAndroidJUnitRunner은 테스트를 샤드(shard)로 분할하여 하나의 샤드를 실행하는 기능을 지원합니다. 예를 들어, am instrument -w -e numShards 2 -e shardIndex 0는 두 개의 테스트 중 첫 번째 테스트를 실행하고, -e shardIndex 1은 두 개의 테스트 중 두 번째 테스트를 실행합니다.\n\n하지만 이를 실제로 활용하려고 하면 다음과 같은 내용이 나타날 것입니다 (출처):\n\n<div class=\"content-ad\"></div>\n\n```js\n#!/usr/bin/env bash\n./gradlew assembleAndroidTest\npids=\nenv ANDROID_SERIAL=emulator-5554 ./gradlew \\\n    connectedAndroidTest \\\n    -Pandroid.testInstrumentationRunnerArguments.numShards=2 \\\n    -Pandroid.testInstrumentationRunnerArguments.shardIndex=0 \\\n    -PtestReportsDir=build/testReports/shard0 \\\n    -PtestResultsDir=build/testResults/shard0 \\\n    &\npids+=\" $!\"\nenv ANDROID_SERIAL=emulator-5556 ./gradlew \\\n    connectedAndroidTest \\\n    -Pandroid.testInstrumentationRunnerArguments.numShards=2 \\\n    -Pandroid.testInstrumentationRunnerArguments.shardIndex=1 \\\n    -PtestReportsDir=build/testReports/shard1 \\\n    -PtestResultsDir=build/testResults/shard1 \\\n    &\npids+=\" $!\"\nwait $pids || { echo \"there were errors\" >&2; exit 1; }\nexit 0\n```\n\n이 방법은 ‘편리’에서는 거리가 먼 방법이며, 많은 매개변수를 사용하여 두 connectedAndroidTest 작업을 병렬로 실행하고 결과를 수동으로 병합한 후 TeamCity와 같은 곳에 보고해야 합니다.\n\nGradle Managed Devices는 android.experimental.androidTest.numManagedDeviceShards=`number_of_shards`와 같은 옵션을 통해 테스트 샤딩을 지원하지만, ManagedVirtualDevice에서만 작동합니다. 우리의 경우에는 자체적으로 관리하는 장치들과 함께 샤딩을 사용하고 싶습니다.\n\nGradle Managed Devices에서는 Device 추상화를 사용합니다. 이 추상화는 전체로 표현되는 여러 장치를 구현할 수 있습니다. 새로운 장치 유형을 소개하고 장치로 등록합시다.\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n인터페이스 MultipleDevices : Device {\n\n    @get:Input\n    val devices: ListProperty<String>\n\n}\n```\n\n```kotlin\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                register(\"multipleDevices\", com.example.MultipleDevices) {\n                    it.devices.add(\"localhost:5555\")\n                    it.devices.add(\"localhost:5557\")\n                }\n            }\n        }\n    }\n}\n```\n\nADB와 관련된 모든 것은 AdbRunner 클래스로 추출되었고 새 매개변수 ShardInfo(index, total)가 추가되었습니다. ShardInfo의 매개변수는 dadb.openShell(“am instrument”) 실행에 그대로 추가됩니다.\n\n이제 테스트를 병렬로 실행하도록 ManagedDeviceTestRunner를 구현해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```kotlin\noverride fun runTests(...): Boolean {\n\n    val devices = managedDevice.devices.get().map {\n        // \"host:port\"를 Pair<String, Int>로 분리\n        val split = it.split(':')\n        split[0] to split[1].toInt()\n    }\n\n    val threadPool = Executors.newCachedThreadPool()\n\n    val futures = devices.mapIndexed { index, (host, port) ->\n        threadPool.submit(Callable {\n            val runner = AdbRunner(\n                host = host,\n                port = port,\n                shardInfo = AdbRunner.ShardInfo(\n                    index = index,\n                    total = devices.size,\n                ),\n            )\n            val result = runner.run(\n                // 각 디바이스에 대해 고유한 이름을 사용하여 독립적인 XML 보고서를 생성해야 합니다.\n                name = \"${managedDevice.name}-${host}-${port}\",\n                runId = runId,\n                outputDirectory = outputDirectory,\n                projectPath = projectPath,\n                variantName = variantName,\n                testData = testData,\n                logger = logger,\n            )\n            result\n        })\n    }\n\n    val success = futures.all { it.get() }\n\n    threadPool.shutdown()\n\n    return success\n}\n```\n\n주의해야 할 사항:\n\n- ThreadPool을 사용하고 있는데, 이는 Gradle에서 좋지 않은 방법입니다. 대신 WorkerExecutor를 사용해야 합니다. ManagedDeviceTestRunnerFactory의 매개변수에서 사용 가능한 WorkerExecutor 인스턴스를 얻을 수 있습니다. 현재 사용하지 않는 이유는 StaticTestData가 직렬화되지 않아 별도의 직렬화 가능한 데이터 홀더로 속성을 복사하여 WorkerExecutor에 전달하고 싶지 않기 때문입니다.\n- 이름은 각 shard에 대해 고유해야 합니다. CustomTestRunListener에 이름을 전달하여 파일 이름에 이름이 포함된 XML 보고서가 생성됩니다. 모든 XML 보고서는 나중에 모아져 병합되므로 어떤 테스트가 어떤 디바이스에서 실행되었는지 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_6.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n샤딩은 매우 중요하며 많은 UI 테스트 케이스에서 도움이 됩니다. 샘플 레파지토리에서는 라이브러리와 어플리케이션 모듈을 준비했는데, 두 모듈 모두 100개의 UI 테스트가 있습니다. 한 모듈에서 테스트를 실행하는 데 약 1분 10초가 걸립니다. 그러므로 두 모듈을 함께 실행하는 데는 약 2분 33초가 소요됩니다. 같은 테스트 스위트를 MultipleDevices에서 실행하면 약 1분 31초만에 완료됩니다. — 필요한 시간의 거의 절반입니다.\n\n```js\n  에뮬레이터 수  시간      \n ----------- ----------- \n  1           2분 33초     \n  2           1분 31초     \n  3           43초        \n```\n\n<img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_7.png\" />\n\n# 병렬 원격 실행\n\n<div class=\"content-ad\"></div>\n\n비록 이렇게 급격한 개선이 있었지만, 하나의 문제에서는 자유로울 수 없습니다: 로컬에서 에뮬레이터를 실행해야 하기 때문에, 개발자 노트북의 자원을 많이 소비합니다.\n\n이 문제를 해결하기 위해 수십 개의 에뮬레이터를 호스팅할 서버를 만들어 HTTP API를 다음과 같이 가지게 만들어보죠:\n\n```js\nGET /lease?devices=%number%\n\n200 OK\n[\n    {\n        host: \"10.10.0.3\",\n        port: 5555,\n        release_key: \"ab34fd2d158f9\"\n    },\n    ...\n]\n\nPOST /release\n[ \"ab34fd2d158f9\", ... ]\n\n200 OK\n```\n\n해당 서버는 우리만 사용할 수 있는 단말기나 에뮬레이터의 집합을 반환하며, 해당 API 호출로 이들을 해제할 때까지만 사용할 수 있습니다. 이를 \"장치 브로커\"라고 부르도록 합시다.\n\n<div class=\"content-ad\"></div>\n\n디바이스 브로커는 개발자뿐만 아니라 CI(지속적인 통합)에도 혜택을 줍니다. 일반적인 CI 흐름은 앱을 빌드하고 에뮬레이터에서 테스트를 실행하는 것입니다. 이 두 단계는 CPU 및 메모리를 많이 사용하는 작업이므로 이러한 작업을 병렬로 수행할 수도 있습니다. 에뮬레이터를 다른 서버로 외부위탁함으로써 빌드 서버는 앱을 빌드하고 테스트 결과를 확인하는 데에 자원을 공유하는 대신 집중할 수 있게 됩니다.\n\nGradle 쪽의 구현은 상당히 간단하며 MultipleDevices와 유사한 모양입니다.\n\n```js\ninterface DeviceFarm : Device {\n\n    @get:Input\n    val shards: Property<Int>\n\n}\n\nclass DeviceBroker {\n\n    fun lease(amount: Int): Collection<Device> {\n        TODO(\"디바이스를 얻기 위한 네트워크 요청을 만듭니다. 이용 가능한 디바이스가 없는 경우 대기해야 합니다.\")\n    }\n\n    fun release(devices: Collection<Device>) {\n        TODO(\"다른 사용자를 위해 디바이스를 해제하기 위한 네트워크 요청을 만듭니다.\")\n    }\n\n    class Device(\n        val host: String,\n        val port: Int,\n        val releaseToken: String,\n    )\n\n}\n\ninternal class DeviceFarmTestRunner : ManagedDeviceTestRunner {\n\n    override fun runTests(...): Boolean {\n        val broker = DeviceBroker()\n        val devices = broker.lease(managedDevice.shards.get())\n\n        devices.forEachIndexed { shardIndex, device ->\n            ...\n        }\n\n        broker.release(devices)\n\n        return success\n    }\n\n}\n```\n\n![이미지](/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_8.png)\n\n<div class=\"content-ad\"></div>\n\n# 결과\n\n우리는 Gradle Managed Devices와 통합하기 위한 사용자 정의 장치를 구현하는 방법에 대해 조사했습니다. 장치는 우리가 원하는 것으로 뒷받침될 수 있는 추상화입니다: 단일 장치 또는 에뮬레이터, 로컬 또는 Firebase Test Lab과 같은 웹 서비스에 원격으로 호스팅되거나 브로커 서비스가 있는 사용자 정의 장치 팜 등이 될 수 있습니다. 단일 장치의 경우에는 ADB를 통해 직접 adb connect를 사용하여 연결할 수 있으므로 실질적인 혜택이 없습니다(디버거를 연결하는 기능과 같은 기능을 손실하지 않으면서). 그러나 여러 원격 장치에 뒷받침된 장치를 구현함으로써 개발자의 노트북 및 CI 빌드 서버의 계산 리소스를 할당할 수 있습니다. 또한 샤딩 기능을 사용하여 테스트 실행을 병렬화하고, 2대의 장치를 사용할 경우 테스트 실행 속도를 2배 높일 수 있습니다.\n\n코드는 저장소에서 사용할 수 있지만, 이것은 개념 증명으로 의도된 대로 프로덕션에서 사용되는 것이 아님을 명심하십시오. 코드는 조직에서 이 접근 방식을 도입하는 데 큰 도움이 될 수 있습니다. 구현 세부사항은 귀하의 인프라에 크게 의존합니다. 마지막으로 코드 자체는 오류에 강건하지 않으며 더 신뢰할 수 있는 방식으로 다시 작성해야 합니다.\n\n질문이 있으시면 아래의 코멘트 섹션에서 자유롭게 물어봐 주세요.","ogImage":{"url":"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_0.png"},"coverImage":"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_0.png","tag":["Tech"],"readingTime":19},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>요즘 Google은 안드로이드 Gradle 플러그인을 위한 새로운 기능, Firebase Test Lab for Gradle Managed Devices를 소개했어요. 이 기능은 Gradle Managed Devices API를 사용하여 테스트를 Gradle이 실행되는 동일한 기계가 아니라 Firebase Test Lab(유료 기능) 내에서 원격 가상 또는 물리 장치에서 시작합니다. 이 기사에서는 해당 기능과 Firebase Test Lab과 같은 방식으로 테스트를 원격으로 시작하기 위해 자체 디바이스 팜을 사용하는 방법, 그리고 여러 장치 간에 실행을 병렬화하는 방법에 대해 다룰 거예요.</p>\n<h1>Gradle Managed Devices</h1>\n<p>처음에는 Gradle Managed Devices가 안드로이드 Gradle 플러그인에게 에뮬레이터의 생성, 시작 및 종료 과정을 위임하는 목적으로 출시되었습니다.</p>\n<p>android {\ntestOptions {\nmanagedDevices {\ndevices {\nregister(\"pixel2api30\", com.android.build.api.dsl.ManagedVirtualDevice) {\ndevice = \"Pixel 2\"\napiLevel = 30\nsystemImageSource = \"aosp\"\n}\n}\n}\n}\n}</p>\n<p>위의 구성을 사용하면 pixel2api30Check 작업을 통해 UI 테스트를 실행할 수 있으며, 기기를 연결하거나 에뮬레이터를 실행할 필요가 없습니다. 이 테스트 실행 환경은 다양한 기계에서 동일합니다.</p>\n<h1>Firebase Test Lab</h1>\n<p>파이어베이스 테스트 랩을 통한 Gradle Managed Devices는 Android Dev Summit 2022에서 최근 소개된 새로운 기능입니다. 이제 Gradle에서 바로 테스트 랩에서 UI 테스트를 실행할 수 있어서 명령줄 도구나 웹 UI를 사용할 필요가 없어졌어요.</p>\n<pre><code class=\"hljs language-js\">plugins {\n    id <span class=\"hljs-string\">'com.google.firebase.testlab'</span>\n}\n\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                <span class=\"hljs-title function_\">register</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"pixel2api30\"</span>, com.google.firebase.testlab.gradle.ManagedDevice</span>) {\n                    device = <span class=\"hljs-string\">\"Pixel2\"</span>\n                    apiLevel = <span class=\"hljs-number\">30</span>\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>우리 자신의 장치로도 같은 작업을 할 수 있을까요? 함께 알아봐요.</p>\n<h1>커스텀 디바이스 구현</h1>\n<p>여러분이 아시다시피, 저희는 com.android.build.api.dsl.ManagedVirtualDevice 또는 com.google.firebase.testlab.gradle.ManagedDevice를 사용하고 있는데, 이 둘 모두 com.android.build.api.dsl.Device 인터페이스를 구현하고 있습니다. 그래서 우리가 직접 커스텀한 디바이스를 구현하려고 하면 어떻게 될까요?</p>\n<p>필요한 Gradle 코드, 플러그인 등을 모두 추가할 새 모듈을 만들어봅시다. buildSrc 폴더를 사용하거나 새로운 included build를 생성하여 할 수 있습니다. 여기서는 새로운 Gradle 플러그인을 생성하는 과정에 대해서는 다루지 않겠지만, 관련 정보는 공식 문서나 저의 다른 글에서 찾아볼 수 있습니다.</p>\n<p>새로 생성한 Gradle 플러그인 모듈에서 MyDevice를 선언하고 해당 디바이스를 애플리케이션 모듈의 build.gradle에서 사용해보세요.</p>\n<pre><code class=\"hljs language-js\">인터페이스 <span class=\"hljs-title class_\">MyDevice</span> : <span class=\"hljs-title class_\">Device</span>\n</code></pre>\n<pre><code class=\"hljs language-js\">android {\n    testOptions {\n        managedDevices {\n            devices {\n                <span class=\"hljs-title function_\">register</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"myDevice\"</span>, MyDevice</span>) {}\n            }\n        }\n    }\n}\n</code></pre>\n<p>프로젝트를 동기화하려고 하면 다음 예외가 발생합니다: 이 컨테이너에서 MyDevice를 생성할 수 없습니다. 이것은 android.testOptions.managedDevices.devices 컨테이너가 MyDevice를 인스턴스화할 방법을 모르기 때문입니다. 왜냐하면 MyDevice가 인터페이스이기 때문입니다.</p>\n<p>그렇다면 Android Gradle 플러그인은 이 문제를 어떻게 관리할까요? com.android.build.api.dsl.ManagedVirtualDevice를 검색하면 다음 코드를 찾을 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">dslServices.<span class=\"hljs-title function_\">polymorphicDomainObjectContainer</span>(<span class=\"hljs-title class_\">Device</span>::<span class=\"hljs-keyword\">class</span>.<span class=\"hljs-property\">java</span>).<span class=\"hljs-property\">apply</span> {\n    <span class=\"hljs-title function_\">registerBinding</span>(\n        com.<span class=\"hljs-property\">android</span>.<span class=\"hljs-property\">build</span>.<span class=\"hljs-property\">api</span>.<span class=\"hljs-property\">dsl</span>.<span class=\"hljs-property\">ManagedVirtualDevice</span>::<span class=\"hljs-keyword\">class</span>.<span class=\"hljs-property\">java</span>,\n        com.<span class=\"hljs-property\">android</span>.<span class=\"hljs-property\">build</span>.<span class=\"hljs-property\">gradle</span>.<span class=\"hljs-property\">internal</span>.<span class=\"hljs-property\">dsl</span>.<span class=\"hljs-property\">ManagedVirtualDevice</span>::<span class=\"hljs-keyword\">class</span>.<span class=\"hljs-property\">java</span>\n    )\n}\n</code></pre>\n<p>registerBinding을 사용하면 플러그인은 컨테이너에 com.android.build.api.dsl.ManagedVirtualDevice 유형의 어떤 것을 추가하려고 시도하는 API 클라이언트가 있을 때 내부 클래스 com.android.build.gradle.internal.dsl.ManagedVirtualDevice를 사용하도록 지시하는 것입니다. 컨테이너는 ManagedVirtualDevice 클래스의 인스턴스를 생성하고 해당 인스턴스를 register 메소드의 람다에 제공할 것입니다.</p>\n<p>동일한 작업을 하기 위해 MyDevice를 구현하는 추상 클래스와 사용자 지정 Gradle 플러그인이 필요하며 해당 플러그인을 프로젝트에 적용해야 합니다.</p>\n<pre><code class=\"hljs language-js\">internal abstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyDeviceImpl</span>(\n    private val <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span>,\n): <span class=\"hljs-title class_\">MyDevice</span> {\n    override fun <span class=\"hljs-title function_\">getName</span>(): <span class=\"hljs-title class_\">String</span> = name\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyDevicePlugin</span> : <span class=\"hljs-title class_\">Plugin</span>&#x3C;<span class=\"hljs-title class_\">Project</span>> {\n    override fun <span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-params\">target: Project</span>) {\n        target.<span class=\"hljs-property\">plugins</span>.<span class=\"hljs-title function_\">withType</span>(<span class=\"hljs-params\">AndroidBasePlugin::<span class=\"hljs-keyword\">class</span>.java</span>) {\n            target.<span class=\"hljs-property\">extensions</span>.<span class=\"hljs-title function_\">configure</span>(<span class=\"hljs-params\">CommonExtension::<span class=\"hljs-keyword\">class</span>.java</span>) {\n                it.<span class=\"hljs-property\">testOptions</span>.<span class=\"hljs-property\">managedDevices</span>.<span class=\"hljs-property\">devices</span>.<span class=\"hljs-title function_\">registerBinding</span>(\n                    <span class=\"hljs-title class_\">MyDevice</span>::<span class=\"hljs-keyword\">class</span>.<span class=\"hljs-property\">java</span>,\n                    <span class=\"hljs-title class_\">MyDeviceImpl</span>::<span class=\"hljs-keyword\">class</span>.<span class=\"hljs-property\">java</span>,\n                )\n            }\n        }\n    }\n}\n</code></pre>\n<pre><code class=\"hljs language-js\">plugins {\n    id <span class=\"hljs-string\">`my-device-plugin`</span>\n}\n\nandroid {\n    testOptions {\n        managedDevices {\n            devices {\n                <span class=\"hljs-title function_\">register</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"myDevice\"</span>, MyDevice</span>) {}\n            }\n        }\n    }\n}\n</code></pre>\n<p>그래서 다시 동기화를 시도하여 다른 예외를 확인해 봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Caused</span> <span class=\"hljs-attr\">by</span>: java.<span class=\"hljs-property\">lang</span>.<span class=\"hljs-property\">IllegalStateException</span>: 지원되지 않는 관리형 장치 유형: \n <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">com</span>.<span class=\"hljs-property\">bumble</span>.<span class=\"hljs-property\">devicefarm</span>.<span class=\"hljs-property\">plugin</span>.<span class=\"hljs-property\">device</span>.<span class=\"hljs-property\">farm</span>.<span class=\"hljs-property\">DeviceFarmImpl_Decorated</span>\n at com.<span class=\"hljs-property\">android</span>.<span class=\"hljs-property\">build</span>.<span class=\"hljs-property\">gradle</span>.<span class=\"hljs-property\">internal</span>.<span class=\"hljs-property\">TaskManager</span>.<span class=\"hljs-title function_\">createTestDevicesForVariant</span>(<span class=\"hljs-title class_\">TaskManager</span>.<span class=\"hljs-property\">kt</span>:<span class=\"hljs-number\">1905</span>)\n</code></pre>\n<p>스택 추적을 따라가보면, gradle.properties에 android.experimental.testOptions.managedDevices.customDevice=true를 추가해야 하며 MyDevice는 ManagedDeviceTestRunnerFactory를 구현해야 한다는 것을 알 수 있습니다. 따라서 더 자세히 조사해 보겠습니다.</p>\n<pre><code class=\"hljs language-kotlin\">내부 추상 클래스 MyDeviceImpl(\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">val</span> name: String\n) : MyDevice, ManagedDeviceTestRunnerFactory {\n\n  <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getName</span><span class=\"hljs-params\">()</span></span>: String = name\n\n  <span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">createTestRunner</span><span class=\"hljs-params\">(\n    project: <span class=\"hljs-type\">Project</span>,\n    workerExecutor: <span class=\"hljs-type\">WorkerExecutor</span>,\n    useOrchestrator: <span class=\"hljs-type\">Boolean</span>,\n    enableEmulatorDisplay: <span class=\"hljs-type\">Boolean</span>\n  )</span></span>: ManagedDeviceTestRunner =\n    MyDeviceTestRunner()\n\n}\n</code></pre>\n<p>팩토리 자체에는 중요한 값이 없습니다. 반환되는 클래스 ManagedDeviceTestRunner이 더 흥미로운 부분입니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">ManagedDeviceTestRunner</span> {\n\n  <span class=\"hljs-comment\">// 모든 테스트 케이스가 통과되면 true를 반환합니다. 그렇지 않으면 false를 반환합니다.</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">runTests</span><span class=\"hljs-params\">(\n    managedDevice: <span class=\"hljs-type\">Device</span>,\n    runId: <span class=\"hljs-type\">String</span>,\n    outputDirectory: <span class=\"hljs-type\">File</span>,\n    coverageOutputDirectory: <span class=\"hljs-type\">File</span>,\n    additionalTestOutputDir: <span class=\"hljs-type\">File</span>?,\n    projectPath: <span class=\"hljs-type\">String</span>,\n    variantName: <span class=\"hljs-type\">String</span>,\n    testData: <span class=\"hljs-type\">StaticTestData</span>,\n    additionalInstallOptions: <span class=\"hljs-type\">List</span>&#x3C;<span class=\"hljs-type\">String</span>>,\n    helperApks: <span class=\"hljs-type\">Set</span>&#x3C;<span class=\"hljs-type\">File</span>>,\n    logger: <span class=\"hljs-type\">Logger</span>\n  )</span></span>: <span class=\"hljs-built_in\">Boolean</span>\n\n}\n</code></pre>\n<p>runTests 메서드는 각 Gradle 모듈에 대해 호출되며, 테스트를 실행하는 데 사용할 수 있는 많은 데이터가 포함되어 있습니다. 여기서 testData를 사용하여 APK를 가져와 설치하고, 계장을 통해 테스트를 실행할 수 있습니다.</p>\n<h1>Instrumentation</h1>\n<p>안녕하세요! 안드로이드 스튜디오에서 테스트를 실행하는 방법은 대부분 우리가 잘 알고 있습니다. 테스트 이름 근처의 실행 버튼을 클릭하거나 Gradle을 통해 connectedAndroidTest를 실행하는 방법이 있죠. 이제 이러한 도구 없이도 어떻게 테스트를 실행할 수 있는지 알아봅시다.</p>\n<p>이 두 가지 접근 방법은 디바이스에서 am instrument 명령을 사용합니다. 이 명령은 ADB를 통해 실행됩니다. 더 자세한 내용은 공식 문서를 참고해보세요.</p>\n<pre><code class=\"hljs language-js\">adb shell am instrument -w &#x3C;test_package_name>/&#x3C;runner_class>\n</code></pre>\n<p>테스트를 실행하려면 runTests 메서드에서 동일한 작업을 해야 합니다. ADB 작업을 수행하기 위해 mobile.dev의 dadb 라이브러리를 사용할 것입니다. 이 라이브러리를 사용하면 ADB 실행 파일을 이용하지 않고 ADB 프로토콜을 통해 디바이스에 직접 연결할 수 있습니다. 이렇게 하면 작업 속도가 향상되며 편리하게 사용할 수 있습니다. 관련 블로그 포스트에서 이에 대해 자세히 읽을 수 있습니다.</p>\n<p>runTests 메서드 내에서 Dadb를 사용하여 로컬 에뮬레이터에 연결하고 APK를 설치하고 테스트를 실행해보겠습니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">runTests</span><span class=\"hljs-params\">(...)</span></span>: <span class=\"hljs-built_in\">Boolean</span> {\n    <span class=\"hljs-comment\">// 로컬 에뮬레이터에 연결</span>\n    Dadb.create(<span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-number\">5555</span>).use { dadb ->\n        <span class=\"hljs-comment\">// 애플리케이션 APK 설치</span>\n        <span class=\"hljs-keyword\">val</span> apks = testData.testedApkFinder.invoke(DadbDeviceConfigProvider(dadb))\n        <span class=\"hljs-comment\">// 라이브러리 모듈인 경우 비워둡니다.</span>\n        <span class=\"hljs-keyword\">if</span> (apks.isNotEmpty()) {\n            <span class=\"hljs-comment\">// 앱 번들을 지원하기 위해 여러 개의 APK 설치 사용</span>\n            dadb.installMultiple(apks)\n        }\n        <span class=\"hljs-comment\">// 계기 APK 설치</span>\n        dadb.install(testData.testApk)\n\n        <span class=\"hljs-comment\">// 테스트 실행</span>\n        dadb.shell(<span class=\"hljs-string\">\"am instrument -w <span class=\"hljs-subst\">${testData.applicationId}</span>/<span class=\"hljs-subst\">${testData.instrumentationRunner}</span>\"</span>)\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n</code></pre>\n<p>runTests 메서드와 StaticTestData 클래스에는 많은 매개변수가 있습니다. 단순화를 위해 모든 것이 작동하는 데 필요한 최소한의 세트만 사용할 것입니다. 다음과 같은 것을 사용할 것입니다:</p>\n<ul>\n<li>testData.testedApkFinder는 필요한 애플리케이션 APK를 가져오기 위해 사용됩니다. 라이브러리 모듈의 경우 빈 목록을 반환합니다. App Bundle에서 적절한 APK 목록을 제공하기 위해 DeviceConfigProvider를 받습니다.</li>\n<li>testData.testApk은 androidTest 폴더에서 코드를 포함하는 instrumentation APK입니다.</li>\n<li>testData.applicationId는 instrument 명령으로 실행해야 하는 애플리케이션 ID입니다.</li>\n<li>testData.instrumentationRunner는 build.gradle 파일에서 지정한 androidx.test.runner.AndroidJUnitRunner와 같은 테스트 러너입니다.</li>\n</ul>\n<p>일단 사용자 정의 DeviceConfigProvider의 구현은 건너뜁니다. 이는 dadb.shell(\"getptop name\").output과 같은 다수의 속성에 대해 locale, 화면 밀도, 언어, 지역 및 ABI를 가져오도록 단순히 호출할 뿐입니다. 프로젝트 저장소에서 구현 세부 정보를 확인할 수 있습니다.</p>\n<p>지금까지 다음 구조를 구현했습니다:</p>\n<p><img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_3.png\" alt=\"image\"></p>\n<h1>결과 가져오기</h1>\n<p>runTests 메서드는 모든 테스트가 통과되면 true를 반환해야 하지만, 지금은 항상 true를 반환합니다. 계기 결과를 얻기 위해 조금 더 파고들어야 합니다.</p>\n<p>기본적으로 명령줄에서 am instrument를 실행하려고 하면 실패 사항과 최종 결과만을 볼 수 있습니다. 더 많은 정보를 표시하려면 -r 및 -m 두 가지 플래그가 있습니다. 첫 번째는 결과를 텍스트 스트림으로 반환하고, 두 번째는 프로토콜 버퍼 스트림으로 반환합니다(API `= 26에서만 지원됨). 간단히 하기 위해 지금은 두 번째를 사용하겠습니다.</p>\n<p>Android Gradle 플러그인은 RemoteAndroidTestRunner.StatusReporterMode.PROTO_STD 열거형을 사용하여 am instrument에서 원시 데이터를 수용할 수 있는 IInstrumentationResultParser 인스턴스를 만듭니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">val</span> mode = RemoteAndroidTestRunner.StatusReporterMode.PROTO_STD\n<span class=\"hljs-keyword\">val</span> parser = mode.createInstrumentationResultParser(runId, emptyList())\n\nDadb.create(host, port).use { dadb ->\n    ...\n    dadb\n        .openShell(<span class=\"hljs-string\">\"am instrument -w <span class=\"hljs-subst\">${mode.amInstrumentCommandArg}</span> <span class=\"hljs-variable\">$arguments</span> <span class=\"hljs-subst\">${testData.applicationId}</span>/<span class=\"hljs-subst\">${testData.instrumentationRunner}</span>\"</span>)\n        .use { stream ->\n            <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {\n                <span class=\"hljs-keyword\">val</span> packet: AdbShellPacket = stream.read()\n                <span class=\"hljs-keyword\">if</span> (packet <span class=\"hljs-keyword\">is</span> AdbShellPacket.Exit) <span class=\"hljs-keyword\">break</span>\n                parser.addOutput(packet.payload, <span class=\"hljs-number\">0</span>, packet.payload.size)\n            }\n            parser.flush()\n        }\n    ...\n}\n</code></pre>\n<p>이번에는 shell 메서드 대신 openShell 메서드를 사용합니다. 이 메서드는 Protocol Buffers 스트림인 원시 데이터 스트림에 액세스할 수 있도록 해줍니다. 이 데이터는 IInstrumentationResultParser로 전달됩니다.</p>\n<h1>HTML 및 XML 보고서 및 암시적인 예상</h1>\n<p>IInstrumentationResultParser는 테스트와 상태에 대해 청취자들에게 알립니다. emptyList()를 전달했을 것을 알 수 있습니다. 어떤 파서를 사용해야 할지 고려해보겠습니다. 몇 가지 사전 제작된 구현이 있지만, Android Gradle 플러그인이 ManagedVirtualDevice를 실행할 때 사용하는 com.android.build.gradle.internal.testing.CustomTestRunListener를 사용해야 합니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">val</span> xmlWriterListener = CustomTestRunListener(\n    name,\n    projectPath,\n    variantName,\n    LoggerWrapper(logger),\n)\nxmlWriterListener.setReportDir(outputDirectory)\nxmlWriterListener.setHostName(<span class=\"hljs-string\">\"localhost:5555\"</span>)\n...\n<span class=\"hljs-keyword\">val</span> parser = mode.createInstrumentationResultParser(runId, listOf(xmlWriterListener))\n...\n<span class=\"hljs-keyword\">return</span> !xmlWriterListener.runResult.hasFailedTests()\n</code></pre>\n<p>CustomTestRunListener은 XmlTestRunListener를 확장하고 Android Gradle 플러그인, TeamCity 또는 여러분께 사용될 수 있는 테스트의 XML 보고서를 작성할 것입니다.</p>\n<p>만약 CustomTestRunListener로 보고서를 생성하지 않고 myDeviceDebugAndroidTest를 실행하려고 하면, com.android.build.gradle.internal.tasks.ManagedDeviceInstrumentationTestResultAggregationTask에서 예외로 실패할 것입니다. 적어도 TEST-로 시작하는 하나의 XML 보고서를 생성할 것으로 예상합니다. 그리고 CustomTestRunListener야말로 이를 강요합니다. 이 작업은 XML과 HTML 보고서를 생성할 것이며, 아래 스크린샷에서 확인할 수 있습니다:</p>\n<p><img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_4.png\" alt=\"스크린샷\"></p>\n<p>이제 CustomTestRunListener를 사용하여 runTests 메서드에서 적절한 값을 반환할 수 있습니다. hasFailedTests 메서드에 액세스할 수 있기 때문입니다.</p>\n<h1>원격 실행</h1>\n<p>Dadb.create를 사용할 때 localhost뿐만 아니라 모든 IP 주소를 전달할 수도 있습니다. 이는 코드를 사용하여 원격 에뮬레이터나 장치에서 테스트를 실행할 수 있다는 것을 의미합니다. 이를 위해 MyDevice를 설정 가능하게 만들 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">MyDevice</span> : <span class=\"hljs-title class_\">Device</span> {\n\n    @<span class=\"hljs-attr\">get</span>:<span class=\"hljs-title class_\">Input</span>\n    val <span class=\"hljs-attr\">host</span>: <span class=\"hljs-title class_\">Property</span>&#x3C;<span class=\"hljs-title class_\">String</span>>\n\n    @<span class=\"hljs-attr\">get</span>:<span class=\"hljs-title class_\">Input</span>\n    val <span class=\"hljs-attr\">port</span>: <span class=\"hljs-title class_\">Property</span>&#x3C;<span class=\"hljs-title class_\">Int</span>>\n\n}\n\ninternal abstract <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyDeviceImpl</span>(\n    private val <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span>,\n) : <span class=\"hljs-title class_\">RemoteDevice</span>, <span class=\"hljs-title class_\">ManagedDeviceTestRunnerFactory</span> {\n\n    init {\n        <span class=\"hljs-comment\">// 기본 매개변수</span>\n        host.<span class=\"hljs-title function_\">convention</span>(<span class=\"hljs-string\">\"localhost\"</span>)\n        port.<span class=\"hljs-title function_\">convention</span>(<span class=\"hljs-number\">5555</span>)\n    }\n\n    ...\n}\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">register</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"remoteDevice\"</span>, MyDevice</span>) {\n    it.<span class=\"hljs-property\">host</span> = <span class=\"hljs-string\">\"192.168.3.4\"</span>\n    it.<span class=\"hljs-property\">port</span> = <span class=\"hljs-number\">43617</span>\n}\n</code></pre>\n<p>그런 다음 <code>Dadb.create(managedDevice.host.get(), managedDevice.port.get())</code>를 사용하세요.</p>\n<p><img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_5.png\" alt=\"이미지\"></p>\n<p>주의 깊게 읽는 독자는 이미 코드 없이 이를 수행할 수 있다는 것을 올바르게 알아차릴 수 있을 것입니다. 원격 장치를 adb 장치 목록에 표시하려면 adb connect IP:PORT를 호출하기만 하면 된다는 것이 충분하며, Android Studio 드롭다운 메뉴 안에서도 바로 확인할 수 있습니다. Gradle Managed Devices로 할 수 없는 테스트 디버깅을 할 수도 있습니다. 그러나 이러한 점을 수행할 수 있다는 것은 다음 단계에 중요한 요소입니다.</p>\n<h1>병렬 실행</h1>\n<p>기본적으로 테스트를 실행할 때 한 번에 한 장치에서만 실행됩니다. 여러 장치나 에뮬레이터에서 테스트를 병렬로 실행할 수 있는 기능이 있다면 좋을텐데요. 좋은 소식은 그런 방법을 찾았다는 것입니다.</p>\n<p>AndroidJUnitRunner은 테스트를 샤드(shard)로 분할하여 하나의 샤드를 실행하는 기능을 지원합니다. 예를 들어, am instrument -w -e numShards 2 -e shardIndex 0는 두 개의 테스트 중 첫 번째 테스트를 실행하고, -e shardIndex 1은 두 개의 테스트 중 두 번째 테스트를 실행합니다.</p>\n<p>하지만 이를 실제로 활용하려고 하면 다음과 같은 내용이 나타날 것입니다 (출처):</p>\n<pre><code class=\"hljs language-js\">#!<span class=\"hljs-regexp\">/usr/</span>bin/env bash\n./gradlew assembleAndroidTest\npids=\nenv <span class=\"hljs-variable constant_\">ANDROID_SERIAL</span>=emulator-<span class=\"hljs-number\">5554</span> ./gradlew \\\n    connectedAndroidTest \\\n    -<span class=\"hljs-title class_\">Pandroid</span>.<span class=\"hljs-property\">testInstrumentationRunnerArguments</span>.<span class=\"hljs-property\">numShards</span>=<span class=\"hljs-number\">2</span> \\\n    -<span class=\"hljs-title class_\">Pandroid</span>.<span class=\"hljs-property\">testInstrumentationRunnerArguments</span>.<span class=\"hljs-property\">shardIndex</span>=<span class=\"hljs-number\">0</span> \\\n    -<span class=\"hljs-title class_\">PtestReportsDir</span>=build/testReports/shard0 \\\n    -<span class=\"hljs-title class_\">PtestResultsDir</span>=build/testResults/shard0 \\\n    &#x26;\npids+=<span class=\"hljs-string\">\" $!\"</span>\nenv <span class=\"hljs-variable constant_\">ANDROID_SERIAL</span>=emulator-<span class=\"hljs-number\">5556</span> ./gradlew \\\n    connectedAndroidTest \\\n    -<span class=\"hljs-title class_\">Pandroid</span>.<span class=\"hljs-property\">testInstrumentationRunnerArguments</span>.<span class=\"hljs-property\">numShards</span>=<span class=\"hljs-number\">2</span> \\\n    -<span class=\"hljs-title class_\">Pandroid</span>.<span class=\"hljs-property\">testInstrumentationRunnerArguments</span>.<span class=\"hljs-property\">shardIndex</span>=<span class=\"hljs-number\">1</span> \\\n    -<span class=\"hljs-title class_\">PtestReportsDir</span>=build/testReports/shard1 \\\n    -<span class=\"hljs-title class_\">PtestResultsDir</span>=build/testResults/shard1 \\\n    &#x26;\npids+=<span class=\"hljs-string\">\" $!\"</span>\nwait $pids || { echo <span class=\"hljs-string\">\"there were errors\"</span> >&#x26;<span class=\"hljs-number\">2</span>; exit <span class=\"hljs-number\">1</span>; }\nexit <span class=\"hljs-number\">0</span>\n</code></pre>\n<p>이 방법은 ‘편리’에서는 거리가 먼 방법이며, 많은 매개변수를 사용하여 두 connectedAndroidTest 작업을 병렬로 실행하고 결과를 수동으로 병합한 후 TeamCity와 같은 곳에 보고해야 합니다.</p>\n<p>Gradle Managed Devices는 android.experimental.androidTest.numManagedDeviceShards=<code>number_of_shards</code>와 같은 옵션을 통해 테스트 샤딩을 지원하지만, ManagedVirtualDevice에서만 작동합니다. 우리의 경우에는 자체적으로 관리하는 장치들과 함께 샤딩을 사용하고 싶습니다.</p>\n<p>Gradle Managed Devices에서는 Device 추상화를 사용합니다. 이 추상화는 전체로 표현되는 여러 장치를 구현할 수 있습니다. 새로운 장치 유형을 소개하고 장치로 등록합시다.</p>\n<pre><code class=\"hljs language-kotlin\">인터페이스 MultipleDevices : Device {\n\n    <span class=\"hljs-meta\">@get:Input</span>\n    <span class=\"hljs-keyword\">val</span> devices: ListProperty&#x3C;String>\n\n}\n</code></pre>\n<pre><code class=\"hljs language-kotlin\">android {\n    testOptions {\n        managedDevices {\n            devices {\n                register(<span class=\"hljs-string\">\"multipleDevices\"</span>, com.example.MultipleDevices) {\n                    it.devices.add(<span class=\"hljs-string\">\"localhost:5555\"</span>)\n                    it.devices.add(<span class=\"hljs-string\">\"localhost:5557\"</span>)\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p>ADB와 관련된 모든 것은 AdbRunner 클래스로 추출되었고 새 매개변수 ShardInfo(index, total)가 추가되었습니다. ShardInfo의 매개변수는 dadb.openShell(“am instrument”) 실행에 그대로 추가됩니다.</p>\n<p>이제 테스트를 병렬로 실행하도록 ManagedDeviceTestRunner를 구현해야 합니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">override</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">runTests</span><span class=\"hljs-params\">(...)</span></span>: <span class=\"hljs-built_in\">Boolean</span> {\n\n    <span class=\"hljs-keyword\">val</span> devices = managedDevice.devices.<span class=\"hljs-keyword\">get</span>().map {\n        <span class=\"hljs-comment\">// \"host:port\"를 Pair&#x3C;String, Int>로 분리</span>\n        <span class=\"hljs-keyword\">val</span> split = it.split(<span class=\"hljs-string\">':'</span>)\n        split[<span class=\"hljs-number\">0</span>] to split[<span class=\"hljs-number\">1</span>].toInt()\n    }\n\n    <span class=\"hljs-keyword\">val</span> threadPool = Executors.newCachedThreadPool()\n\n    <span class=\"hljs-keyword\">val</span> futures = devices.mapIndexed { index, (host, port) ->\n        threadPool.submit(Callable {\n            <span class=\"hljs-keyword\">val</span> runner = AdbRunner(\n                host = host,\n                port = port,\n                shardInfo = AdbRunner.ShardInfo(\n                    index = index,\n                    total = devices.size,\n                ),\n            )\n            <span class=\"hljs-keyword\">val</span> result = runner.run(\n                <span class=\"hljs-comment\">// 각 디바이스에 대해 고유한 이름을 사용하여 독립적인 XML 보고서를 생성해야 합니다.</span>\n                name = <span class=\"hljs-string\">\"<span class=\"hljs-subst\">${managedDevice.name}</span>-<span class=\"hljs-subst\">${host}</span>-<span class=\"hljs-subst\">${port}</span>\"</span>,\n                runId = runId,\n                outputDirectory = outputDirectory,\n                projectPath = projectPath,\n                variantName = variantName,\n                testData = testData,\n                logger = logger,\n            )\n            result\n        })\n    }\n\n    <span class=\"hljs-keyword\">val</span> success = futures.all { it.<span class=\"hljs-keyword\">get</span>() }\n\n    threadPool.shutdown()\n\n    <span class=\"hljs-keyword\">return</span> success\n}\n</code></pre>\n<p>주의해야 할 사항:</p>\n<ul>\n<li>ThreadPool을 사용하고 있는데, 이는 Gradle에서 좋지 않은 방법입니다. 대신 WorkerExecutor를 사용해야 합니다. ManagedDeviceTestRunnerFactory의 매개변수에서 사용 가능한 WorkerExecutor 인스턴스를 얻을 수 있습니다. 현재 사용하지 않는 이유는 StaticTestData가 직렬화되지 않아 별도의 직렬화 가능한 데이터 홀더로 속성을 복사하여 WorkerExecutor에 전달하고 싶지 않기 때문입니다.</li>\n<li>이름은 각 shard에 대해 고유해야 합니다. CustomTestRunListener에 이름을 전달하여 파일 이름에 이름이 포함된 XML 보고서가 생성됩니다. 모든 XML 보고서는 나중에 모아져 병합되므로 어떤 테스트가 어떤 디바이스에서 실행되었는지 확인할 수 있습니다.</li>\n</ul>\n<p>샤딩은 매우 중요하며 많은 UI 테스트 케이스에서 도움이 됩니다. 샘플 레파지토리에서는 라이브러리와 어플리케이션 모듈을 준비했는데, 두 모듈 모두 100개의 UI 테스트가 있습니다. 한 모듈에서 테스트를 실행하는 데 약 1분 10초가 걸립니다. 그러므로 두 모듈을 함께 실행하는 데는 약 2분 33초가 소요됩니다. 같은 테스트 스위트를 MultipleDevices에서 실행하면 약 1분 31초만에 완료됩니다. — 필요한 시간의 거의 절반입니다.</p>\n<pre><code class=\"hljs language-js\">  에뮬레이터 수  시간      \n ----------- ----------- \n  <span class=\"hljs-number\">1</span>           <span class=\"hljs-number\">2</span>분 <span class=\"hljs-number\">33</span>초     \n  <span class=\"hljs-number\">2</span>           <span class=\"hljs-number\">1</span>분 <span class=\"hljs-number\">31</span>초     \n  <span class=\"hljs-number\">3</span>           <span class=\"hljs-number\">43</span>초        \n</code></pre>\n<h1>병렬 원격 실행</h1>\n<p>비록 이렇게 급격한 개선이 있었지만, 하나의 문제에서는 자유로울 수 없습니다: 로컬에서 에뮬레이터를 실행해야 하기 때문에, 개발자 노트북의 자원을 많이 소비합니다.</p>\n<p>이 문제를 해결하기 위해 수십 개의 에뮬레이터를 호스팅할 서버를 만들어 HTTP API를 다음과 같이 가지게 만들어보죠:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">GET</span> /lease?devices=%number%\n\n<span class=\"hljs-number\">200</span> <span class=\"hljs-variable constant_\">OK</span>\n[\n    {\n        <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">\"10.10.0.3\"</span>,\n        <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">5555</span>,\n        <span class=\"hljs-attr\">release_key</span>: <span class=\"hljs-string\">\"ab34fd2d158f9\"</span>\n    },\n    ...\n]\n\n<span class=\"hljs-variable constant_\">POST</span> /release\n[ <span class=\"hljs-string\">\"ab34fd2d158f9\"</span>, ... ]\n\n<span class=\"hljs-number\">200</span> <span class=\"hljs-variable constant_\">OK</span>\n</code></pre>\n<p>해당 서버는 우리만 사용할 수 있는 단말기나 에뮬레이터의 집합을 반환하며, 해당 API 호출로 이들을 해제할 때까지만 사용할 수 있습니다. 이를 \"장치 브로커\"라고 부르도록 합시다.</p>\n<p>디바이스 브로커는 개발자뿐만 아니라 CI(지속적인 통합)에도 혜택을 줍니다. 일반적인 CI 흐름은 앱을 빌드하고 에뮬레이터에서 테스트를 실행하는 것입니다. 이 두 단계는 CPU 및 메모리를 많이 사용하는 작업이므로 이러한 작업을 병렬로 수행할 수도 있습니다. 에뮬레이터를 다른 서버로 외부위탁함으로써 빌드 서버는 앱을 빌드하고 테스트 결과를 확인하는 데에 자원을 공유하는 대신 집중할 수 있게 됩니다.</p>\n<p>Gradle 쪽의 구현은 상당히 간단하며 MultipleDevices와 유사한 모양입니다.</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">DeviceFarm</span> : <span class=\"hljs-title class_\">Device</span> {\n\n    @<span class=\"hljs-attr\">get</span>:<span class=\"hljs-title class_\">Input</span>\n    val <span class=\"hljs-attr\">shards</span>: <span class=\"hljs-title class_\">Property</span>&#x3C;<span class=\"hljs-title class_\">Int</span>>\n\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceBroker</span> {\n\n    fun <span class=\"hljs-title function_\">lease</span>(<span class=\"hljs-attr\">amount</span>: <span class=\"hljs-title class_\">Int</span>): <span class=\"hljs-title class_\">Collection</span>&#x3C;<span class=\"hljs-title class_\">Device</span>> {\n        <span class=\"hljs-title function_\">TODO</span>(<span class=\"hljs-string\">\"디바이스를 얻기 위한 네트워크 요청을 만듭니다. 이용 가능한 디바이스가 없는 경우 대기해야 합니다.\"</span>)\n    }\n\n    fun <span class=\"hljs-title function_\">release</span>(<span class=\"hljs-params\">devices: Collection&#x3C;Device></span>) {\n        <span class=\"hljs-title function_\">TODO</span>(<span class=\"hljs-string\">\"다른 사용자를 위해 디바이스를 해제하기 위한 네트워크 요청을 만듭니다.\"</span>)\n    }\n\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Device</span>(\n        val <span class=\"hljs-attr\">host</span>: <span class=\"hljs-title class_\">String</span>,\n        val <span class=\"hljs-attr\">port</span>: <span class=\"hljs-title class_\">Int</span>,\n        val <span class=\"hljs-attr\">releaseToken</span>: <span class=\"hljs-title class_\">String</span>,\n    )\n\n}\n\ninternal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceFarmTestRunner</span> : <span class=\"hljs-title class_\">ManagedDeviceTestRunner</span> {\n\n    override fun <span class=\"hljs-title function_\">runTests</span>(...): <span class=\"hljs-title class_\">Boolean</span> {\n        val broker = <span class=\"hljs-title class_\">DeviceBroker</span>()\n        val devices = broker.<span class=\"hljs-title function_\">lease</span>(managedDevice.<span class=\"hljs-property\">shards</span>.<span class=\"hljs-title function_\">get</span>())\n\n        devices.<span class=\"hljs-property\">forEachIndexed</span> { shardIndex, device ->\n            ...\n        }\n\n        broker.<span class=\"hljs-title function_\">release</span>(devices)\n\n        <span class=\"hljs-keyword\">return</span> success\n    }\n\n}\n</code></pre>\n<p><img src=\"/assets/img/2024-05-17-HowtouseGradleManagedDeviceswithyourowndevices_8.png\" alt=\"이미지\"></p>\n<h1>결과</h1>\n<p>우리는 Gradle Managed Devices와 통합하기 위한 사용자 정의 장치를 구현하는 방법에 대해 조사했습니다. 장치는 우리가 원하는 것으로 뒷받침될 수 있는 추상화입니다: 단일 장치 또는 에뮬레이터, 로컬 또는 Firebase Test Lab과 같은 웹 서비스에 원격으로 호스팅되거나 브로커 서비스가 있는 사용자 정의 장치 팜 등이 될 수 있습니다. 단일 장치의 경우에는 ADB를 통해 직접 adb connect를 사용하여 연결할 수 있으므로 실질적인 혜택이 없습니다(디버거를 연결하는 기능과 같은 기능을 손실하지 않으면서). 그러나 여러 원격 장치에 뒷받침된 장치를 구현함으로써 개발자의 노트북 및 CI 빌드 서버의 계산 리소스를 할당할 수 있습니다. 또한 샤딩 기능을 사용하여 테스트 실행을 병렬화하고, 2대의 장치를 사용할 경우 테스트 실행 속도를 2배 높일 수 있습니다.</p>\n<p>코드는 저장소에서 사용할 수 있지만, 이것은 개념 증명으로 의도된 대로 프로덕션에서 사용되는 것이 아님을 명심하십시오. 코드는 조직에서 이 접근 방식을 도입하는 데 큰 도움이 될 수 있습니다. 구현 세부사항은 귀하의 인프라에 크게 의존합니다. 마지막으로 코드 자체는 오류에 강건하지 않으며 더 신뢰할 수 있는 방식으로 다시 작성해야 합니다.</p>\n<p>질문이 있으시면 아래의 코멘트 섹션에서 자유롭게 물어봐 주세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}