{"pageProps":{"post":{"title":"2단계 인증 앱이 012345를 받았을 때 알려주는 기능","description":"","date":"2024-05-23 14:53","slug":"2024-05-23-The2FAappthattellsyouwhenyouget012345","content":"\n이른 시기 2010년대에 성장한 모든 회복된 엣지로드와 같이 나는 4chan과 같은 이미지 보드의 전성기를 약간 그리워합니다. 그들은 나치들이 모든 것을 망쳐 버리기 전에 야생 서부 초기 인터넷의 마지막 요새였어요.\n\n클래식한 밈 중 하나는 GET이었는데, 당신이 랜덤으로 생성된 게시물 ID가 흥미로운 숫자 시퀀스를 포함할 것으로 정확히 예상했을 때 자부심을 느끼게 됩니다.\n\n![그림](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png)\n\n요즘에는 이제 모든 보통 사람들이 성장하고 직장을 찾은 지금, 옛날의 마법에 제일 가까이 올 수 있는 것은 이중 인증 코드뿐입니다.\n\n<div class=\"content-ad\"></div>\n\n당신이 알고 있으면 좋아요.\n\n은행, 이메일 또는 클라우드 서비스에 다시 인증해야 하는 번거로움. 787000 또는 123450 같이 정말 좋은 숫자를 받았을 때의 작은 기쁨.\n\n영감을 받았어요.\n\n이 MFA 코드들은 매 30초마다 갱신되는 공통 알고리즘을 사용해요. 우리가 6자리 인증 코드에서 가능한 더블, 트리플, 쿼드, 퀸텀플, 섹스텀플 중에 매우 일부만을 경험하고 있어요.\n\n<div class=\"content-ad\"></div>\n\n내 독립 프로젝트들처럼, 내 주변에 하나의 명확한 비전이 있었으며 그 주위에 구축할 수 있었습니다:\n\n내가 뭘 해야 하는지 알았어요.\n\n### 컨셉 증명\n\n이게 작동하는지 알아야 하는 움직이는 부품은 많이 필요하지 않아요.\n\n<div class=\"content-ad\"></div>\n\n- 2FA 비밀 키를 입력해주세요.\n- 로컬에서 6자리 2FA 코드를 생성합니다.\n- 쿼드/퀸트/섹스트가 생성될 때 푸시 알림을 보냅니다.\n\n## 최소 기능 제품\n\n만약 멋진 2FA 번호가 생성될 때 알림을 받는 개념이 유지된다면, 몇 가지 주요 기능을 갖춘 실제 앱으로 발전시킬 수 있습니다:\n\n- 카메라로 2FA 비밀을 캡처합니다.\n- 여러 2FA 코드를 저장합니다.\n- 더 많은 숫자 패턴을 구현합니다.\n- 사용자가 알고 싶은 패턴을 선택할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n내가 뭔가를 알고 있었다는 걸 알았어: 내가 이걸 설명한 사람들의 90%는 나를 멍청이로 생각했어. 나머지 10%는 순수한 창의성만을 보았어.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_1.png)\n\n# Proof of Concept 구축\n\n## TOTP\n\n<div class=\"content-ad\"></div>\n\nTOTP 또는 시간 기반 일회용 비밀번호는 놀랍도록 간단한 개념입니다. 이는 두 가지 입력을 사용하는 인증 프로세스입니다:\n\n- 인증 서비스 및 자신의 장치에 저장된 비밀 키\n- 현재 시간 또는 더 정확히 말하면 유닉스 시간 이후 경과한 30초 간격의 수\n\n이 알고리즘은 두 입력을 결정론적으로 해시하여 여러분이 알고 사랑하는 6자리 코드를 생성합니다. 이 해싱 알고리즘은 Apple의 CryptoKit에서 찾을 수 있는 매우 흔한 것입니다. Apple 포럼의 우리 친구들 덕분에 여기 TOTP 알고리즘의 전체 영광이 있습니다.\n\n```js\n// CodeGenerator.swift\n\nprivate let secret = Data(base64Encoded: \"AAAAAAAAAAAAAAAAAAAAAAAAAAA\")!\n\nfunc otpCode(date: Date = Date()) -> String {\n    let digits = 6\n    let period = TimeInterval(30)\n    let counter = UInt64(date.timeIntervalSince1970 / period)\n    let counterBytes = (0..<8).reversed().map { UInt8(counter >> (8 * $0) & 0xff) }\n    let hash = HMAC<Insecure.SHA1>.authenticationCode(for: counterBytes, using: SymmetricKey(data: secret))\n    let offset = Int(hash.suffix(1)[0] & 0x0f)\n    let hash32 = hash\n        .dropFirst(offset)\n        .prefix(4)\n        .reduce(0, { ($0 << 8) | UInt32($1) })\n    let hash31 = hash32 & 0x7FFF_FFFF\n    let pad = String(repeating: \"0\", count: digits)\n    return String((pad + String(hash31)).suffix(digits))\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 텍스트를 친근한 분위기로 한국어로 번역하면 다음과 같습니다.\n\n\"작업이 올바르게 진행되었는지 확인하기 위해, 구글 계정에 2단계 인증을 설정하고 해당 앱에서 비밀을 알고리즘을 사용하여 표시했어요.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_2.png)\n\n그리고, 마법처럼 (약간 번거로운 base32에서 base64로의 변환 후에), 구글이 내 2단계 인증을 승인했어요!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_3.png)\"\n\n<div class=\"content-ad\"></div>\n\n이제 2단계 인증의 기본적인 부분이 작동 중이니, 컨셉 증명 퍼즐의 마지막 조각인 알림 생성을 구현할 수 있습니다.\n\n## 앱 제한 사항\n\n저희의 주요 제한 사항은 모바일 장치에 있습니다.\n\n실제로 2단계 인증 생성과 같은 백그라운드 프로세스를 영원히 실행할 수 없으며, 반드시 사용자 비밀을 백엔드 푸시 서버에 저장할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n그러므로 이 개념이 작동하도록하려면 약간 교묘해야합니다: 앞으로 2FA 코드를 미리 계산하고, 그들이 실제로 출현하는 시간에 전달을 예약해야합니다.\n\n또한, iOS에서 동시에 64개의 푸시를 예약할 수 있으므로, 다음을 고려해야합니다:\n\n- 사용자에게 앱을 다시 입력하도록 요청하는 알림 하나 또는 두 개를 저장합니다.\n- 알림을 터치하여 사용자가 앱을 열도록 유도하여 2FA 코드를 재계산하도록합니다.\n\n이제 POC가 작동하는 방법을 알았으니, 빌드를 시작합시다.\n\n<div class=\"content-ad\"></div>\n\n## 첫 번째 GETs 찾기\n\n우리의 보잘것없는 2FA 코드를 향상시켜 봅시다.\n\n우리는 많은 코드를 미리 계산한 후, 각 코드가 GET인지를 확인하는 레귤러 표현식을 구현할 계획입니다.\n\n제 아주 간단한 SwiftUI 뷰는 UICollectionView를 백업으로 사용하여 성능이 훌륭하도록 보장하기 위해 이러한 코드를 편리하게 표시할 수 있습니다 (ScrollView의 기본 VStack은 10,000개의 항목 이전에 멀쩡히 오작동하기 시작할 것입니다!).\n\n<div class=\"content-ad\"></div>\n\n```swift\n// ContentView.swift\n\nstruct ContentView: View {\n\n    var body: some View {\n        List {\n            ForEach(makeOTPs(), id: \\.self) {\n                Text($0)\n                    .font(.custom(\"Courier\", size: 20))\n                    .font(.title)\n                    .kerning(4)\n            }\n            .frame(maxWidth: .infinity)\n        }\n    }\n\n    func makeOTPs() -> [String] {\n        (0..<10_000).map {\n            otpCode(increment: $0)\n        }\n    }\n}\n```\n\n잘 진행되고 있어요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_4.png)\n\n이제, 세 자리 숫자가 연속으로 나타나는 TOTP(예: 120333)를 확인하는 간단한 정규 표현식 평가기를 추가할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n```swift\nextension String {\n    func checkThoseTrips() -> Bool {\n        (try? /(\\d)\\1\\1/.firstMatch(in: self)) != nil\n    }\n}\n```\n\nText 뷰에 fontWeight 수정자를 추가하여 스크롤할 때 이 GET을 쉽게 감지할 수 있습니다.\n\n```swift\nText($0)\n    .fontWeight($0.checkThoseTrips() ? .heavy : .light)\n```\n\n에쟈! 그 여행을 확인하세요!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_5.png\" />\n\n우리는 심지어 우리의 정규 표현식을 신성한 네 숫자를 감지하기 위해 기본 수정할 수도 있어요 — 이건 독자들에게 연습문제로 남길게요.\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_6.png\" />\n\n## 전혀 소용없지만 재미있는 관찰\n\n<div class=\"content-ad\"></div>\n\n우리의 부주의한 ForEach 구현으로 인해 다음 경고 메시지가 발생했습니다:\n\n```js\nForEach<Array<String>, String, Text>: the ID 312678 occurs multiple\ntimes within the collection, this will give undefined results!\n```\n\n실제로 이 경고를 수십 번 받았습니다!\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_7.png\" />\n\n<div class=\"content-ad\"></div>\n\n우리가 10,000개의 OTP를 생성했기 때문에, 여러 개가 일치할 가능성이 매우 높습니다. 이는 생일 문제와 같은 원리이며, 가능한 일치 쌍의 수는 백만 이상이 됩니다.\n\n## 희귀한 GET 생성하기\n\n이제 몇 가지 흥미로운 코드를 계산해 보겠습니다.\n\n여기서 중요한 점은 미리 계산하여 미래를 예측하는 것입니다: TOTP는 비밀과 날짜 입력의 결정적 해시이기 때문에, 우리는 미래의 오랜 일련의 날짜를 입력하여 특정 시간에 어떤 OTP 코드를 볼 수 있는지 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n각 코드와 날짜를 반환하도록 OTP 생성 방식을 조정해보겠습니다:\n\n```js\n// TOTP.swift\n\nstruct OTP {\n    let date: Date\n    let code: String\n}\n\nfunc otpCode(date: Date = Date(), increment: Int = 0) -> OTP {\n    let digits = 6\n    let period = TimeInterval(30)\n    let adjustedDate = date.addingTimeInterval(period * Double(increment))\n    let counter = UInt64(adjustedDate.timeIntervalSince1970 / period)\n    let counterBytes = (0..<8).reversed().map { UInt8(counter >> (8 * $0) & 0xff) }\n    let hash = HMAC<Insecure.SHA1>.authenticationCode(for: counterBytes, using: SymmetricKey(data: secret))\n    let offset = Int(hash.suffix(1)[0] & 0x0f)\n    let hash32 = hash\n        .dropFirst(offset)\n        .prefix(4)\n        .reduce(0, { ($0 << 8) | UInt32($1) })\n    let hash31 = hash32 & 0x7FFF_FFFF\n    let pad = String(repeating: \"0\", count: digits)\n    let code = String((pad + String(hash31)).suffix(digits))\n    return OTP(date: adjustedDate, code: code)\n}\n```\n\n이를 테스트하기 위해 다수의 코드를 생성하고, GETs: quints (5개의 중복번호)를 검색해 보겠습니다.\n\n```js\nfunc interestingCodes() -> [OTP] {\n    (0..<1_000_000)\n        .map { otpCode(increment: $0) }\n        .filter { $0.code.checkThoseQuints() }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n내 M1이 해싱 함수를 실행하는 동안 몇 번의 숫자 계산 후, 약 30초 동안 진행된 결과물은 몇몇 굉장히 확인 가능한 GET들로 이어졌어요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_8.png)\n\n## 우리의 알림 일정 설정하기\n\n좋은 숫자를 볼 수 있어서 재미있긴 하지만, 만약 실제로 GETs를 실생활에서 진짜 인증을 위해 사용할 수 없다면, 이 앱 개념은 그냥 무작위 번호 생성기와 다를게 없죠.\n\n<div class=\"content-ad\"></div>\n\n이제 흥미로운 숫자가 도착하는 시점을 알게 되었으니, 번호를 실시간으로 받을 수 있도록 푸시 알림을 대기열에 넣고 있어요:\n\n```js\n// NotificationScheduler.swift\n\nprivate func createNotification(for otp: OTP) {\n    let center = UNUserNotificationCenter.current()\n    let content = UNMutableNotificationContent()\n    content.title = \"Quads GET!!\"\n    content.body = otp.code\n    content.sound = UNNotificationSound.default\n    let components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second], from: otp.date)\n    let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    center.add(request) { (error) in\n        // ...\n    }\n}\n```\n\n이 알림은 우리 뷰에서 사용하는 흥미로운 코드를 생성한 직후 예약되어 있어요. 그리고 잠시 후, 한꺼번에 2개의 멋진 푸시 알림을 받았답니다!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_9.png)\n\n<div class=\"content-ad\"></div>\n\n이 통지가 실제로 나타나는 번호와 일치한다는 것을 확인하니, 더욱 흥미로워졌어요!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_10.png)\n\n아래 앱은 무작위 번호 생성기를 넘어서, 이 코드가 실제로 내 Google 계정에 로그인하는 데 도움이 된단 걸 알게 되었어요.\n\n## 흥미로움\n\n<div class=\"content-ad\"></div>\n\n다양한 종류의 흥미로운 숫자를 결정하려면 흥미로움의 개념을 소개해야 합니다. 이는 반복되는 숫자, 연속하는 숫자, 수학적으로 흥미로운 숫자(예: 파이 또는 e), 회문을 포함할 수 있습니다.\n\n이러한 종류의 흥미로운 숫자는 ... 우리가 생성하는 각 OTP에 대해 선택적으로 만들어진 열거형 케이스로 열거될 수 있습니다.\n\n```js\n// 흥미로움.swift\n\n열거형 흥미로움 {\n\n    케이스 섹스텀\n    케이스 퀸츠\n    케이스 쿼드\n\n    이니셜라이저(code: String) {\n        if code.checkThoseSexts() {\n            self = .sexts\n        // ...\n\n    변수 타이틀: String {\n        switch self {\n        case .sexts: return \"Sextuples GET!!!\"\n        // ...\n\n    함수 본문(code: String) -> String {\n        switch self {\n        case .sexts: return \"체크해 보세요 섹스텀: \\(code)\"\n        // ...\n```\n\n<div class=\"content-ad\"></div>\n\n각 checkThose 메소드는 다른 정규식을 래핑하며, 우리는 가장 중요한 순서대로 실행합니다. 예를 들어, 섹스튜플은 쿼드보다 100배 더 드물다.\n\n오랜만에 리팩터를 해서 우리는 개념 증명을 만들었습니다. 요약해보겠습니다:\n\n- 앱은 (하드코딩된) 2FA 보안 키를 입력할 수 있게 해줍니다.\n- 앱은 로컬에서 매 30초마다 6자리 2FA 코드를 생성합니다.\n- 앱은 쿼드, 퀸트, 섹스가 생성될 때 푸시 알림을 예약합니다.\n\n몇 일 동안 앱을 사용해보려고 쉬는 시간을 가질 것입니다. 내 손에 멋진 앱을 만들 수 있을 것 같다고 예상하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 최소 기능 제품 구축\n\n얼마 되지 않아, 몇 일 동안 제 아이디어의 핵심을 담은 앱, 즉 우선 증명 개념 버전을 사용해왔어요. 그리고 정말 좋아해요. 처음으로 여섯 번째 메시지를 받을 때까지 기다릴 수가 없네요.\n\n이제는 뼈대에 고기를 붙여 완전히 다듬어진 2FA 앱을 구축할 때입니다. 이전에 설명한 대로, 실제로 4가지 주요 새로운 기능만 추가하면 됩니다:\n\n- 2FA QR 코드를 스캔하여 안전하게 키체인에 저장하기\n- 사용자 인터페이스에서 여러 2FA 계정을 표시하고 관리하기\n- 사용자가 중요하게 여기는 번호 설정하기\n- 더 많은 종류의 재미있는 기능 구현하기\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 기능적이 아닌 요구 사항: 매우 느린 코드 생성을 최적화하는 작업을 해야 합니다. 배치 처리 또는 로컬 지속성을 활용할 수도 있을 것 같아요.\n\n## 인간 인터페이스 가이드라인\n\n디자인에 대해 별다른 특별한 것을 할 계획은 없어요. 표준 애플 List 뷰 구성 요소를 사용하여 HIG를 따를 것이에요.\n\nUX는 멋지고 간단하게 유지합시다: 주로 푸시 알림에 기능이 집중되어 있으며 매우 완벽해요. 이 말은 QR 스캐너와 설정을 툴바 버튼 뒤에 숨기고, 모달 플로우가 표시되도록 하는 것을 의미해요.\n\n<div class=\"content-ad\"></div>\n\n\n![Scanning 2FA Secrets](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_11.png)\n\n## Scanning 2FA Secrets\n\nA couple of open-source libraries will save me a ton of time on cookie-cutter tasks. CodeScanner to supply simple SwiftUI QR code scanning, and KeychainAccess to easily store these 2FA account secrets in the keychain.\n\n![Scanning 2FA Secrets](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_12.png)\n\n\n<div class=\"content-ad\"></div>\n\n해당 스캐너 라이브러리는 카메라 접근을 사용하여 QR 코드를 쉽게 구문 분석할 수 있는 URL로 변환합니다. 아래와 같은 형식으로 변환됩니다:\n\n```js\notpauth://totp/Google%3Atest%40gmail.com?secret=bv7exx7sltbcqffec1qyxscueydwsu5h&issuer=Google\n```\n\n이제 앱에 우리의 계정을 쉽게 추가할 수 있게 되었어요!\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_13.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 선호하는 숫자 선택하기\n\nSwiftUI @AppStorage를 사용하여 List 및 몇 가지 Toggles와 함께 사용하면 쉽게 사용자 설정 화면을 구축할 수 있습니다.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_14.png)\n\n나는 onDisappear에서 부모 뷰에게 다시 숫자 처리를 시작하고 알림을 다시 예약하라고 알리기 위해 클로저를 사용했습니다. 이것은 토글이 변경될 때마다 비싼 계산을 실행하는 대신 모든 것을 일괄 처리하는 가장 간단한 방법이었습니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\n// CodeView.swift\n\nvar body: some View {\n    // ...\n    .sheet(isPresented: $showSettings) {\n        SettingsView(onDisappear: {\n            viewModel.recomputeNotifications()\n        })\n    }\n}\n```\n\n## Belated Customer Research\n\n안녕하세요, 저는 독립 개발자에요. 프로젝트 빌드 과정 중간에 이것을 할 수 있어요!\n\n몇 가지 다른 2FA 앱을 다운로드해서 아이디어를 베낄 만한 것이 있는지 살펴보기로 결정했어요. 사실, 꽤 혼잡하고 경쟁력 있는 앱 시장을 기대했는데, 이 중 일부는 정말 형편없었어요.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변환:\n\n\n![이미지1](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_15.png)\n\n정말이지, 그 중 50% 이상이 매우 공격적인 페이월을 설정해 놓고 사용하기 전에 이겼다... 무료 옵션이 완전히 제공되는 상황일 때 말이죠.\n\n이 페이월이 넘쳐난다 해도, 좋은 아이디어를 빌려올 수 있었던 몇 가지를 기록해 두었어요.\n\n![이미지2](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_16.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 여러 개의 2FA 계정\n\n여러 개의 계정을 가진 사람들에겐 이것이 매우 중요하죠. 계정이 많으면 더 많은 GET 기회가 생기기도 하거든요!\n\n내 키체인 코드를 업데이트했어요. 이제 여러 개의 QR 코드를 스캔할 수 있게 되었고, 계정 데이터(비밀 정보를 포함한)도 저장하게 되었어요. 이제 나의 다양한 계정으로 로그인하는 데 완벽하게 작동했어요!\n\n![QR 코드 이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_17.png)\n\n<div class=\"content-ad\"></div>\n\n저는 적절한 내장 목록 기능을 구현하여 이제 우리가 더 이상 필요하지 않은 코드를 삭제할 수 있습니다.\n\n경쟁사 분석을 하면서, 구글 인증 프로그램이 예전 아이폰에 추가한 2단계 인증 코드를 몇 년 전부터 계속 보관하고 있는 것을 발견했어요!\n\n그때 제 데이터 계층에서 두 가지 실수를 발견했습니다.\n\n- iCloud와 동기화하지 않았던 점\n- 키패인 밖에 계정을 지속하려고 한 점\n\n<div class=\"content-ad\"></div>\n\n먼저, iCloud에 대한 키체인을 동기화하면 계정이 다른 모든 Apple 기기에 나타납니다. Keychain Access 라이브러리를 사용하면 쉽게 할 수 있어요:\n\n```js\n// KeychainManager.swift\n\nself.keychain = Keychain().synchronizable(true);\n```\n\n둘째, 저는 반짝이는 물건 증후군으로 고생했어요: SwiftData를 영속성 레이어로 사용하기 위해 서두르다 보니 Keychain만을 비밀로 사용하고 나머지 계정 메타데이터는 새로운 프레임워크를 통해 영속화하고 있었어요.\n\n이것은 다른 장치에서 나의 계정을 가져올 수 없었다는 것을 의미해요 — 비밀만으로는 쓸모가 없어요!\n\n<div class=\"content-ad\"></div>\n\n그래서 전 Account 객체 전체를 키체인에 저장해야 한다는 것을 깨달았어요.\n\n새로운 접근 방식은 QR 코드 URL을 키체인에 그대로 저장하는 것입니다. 이제 Account 객체 자체는 일시적입니다; 앱을 로드할 때마다 URL에서 다시 계산됩니다.\n\n이렇게 하면 로드할 때마다 Accounts가 로그인한 모든 iDevice에 나타날 수 있습니다! 이 일시적인 방식은 두 마리의 새끼를 한 방에 잡는 멋진 방법입니다. 이제 필요할 때 키체인에서 Accounts를 가져올 때 사용합니다:\n\n```swift\n// AccountManager.swift\n\nfunc fetchAccounts() throws -> [Account] {\n    try KeychainManager.shared.fetchAll()\n        .compactMap { createAccount(from: $0) }\n}\n\nprivate func createAccount(from urlString: String) -> Account? {\n    guard let url = URL(string: urlString),\n          let account = SecretURLParser.shared.account2FA(from: url) else {\n        return nil\n    }\n    return account\n}\n```\n\n<div class=\"content-ad\"></div>\n\n일반 코딩 작업을 많이 하여 UI를 개선하고 코드를 잘 리팩토링하는 작업을 했어요. 그런데 개발 과정에서 흥미로운 것들도 몇 가지 있었답니다.\n\n## 계정 아이콘 찾기\n\n이건 꽤 좋은 기능이에요. 하지만 최고의 오픈 소스 앱이 똑같은 일을 하길래, 적어도 그것만큼 좋아야 한다고 느꼈어요.\n\n다행히도, 웹 사이트에서 FavIcon을 검색하고 여러 해상도로 다운로드할 수 있는 Google API가 있답니다.\n\n<div class=\"content-ad\"></div>\n\n웹사이트를 어떻게 디자인하면 좋을지 고민 중이군요. QR 코드의 발행자 속성을 사용하여 .com 도메인을 시도하는 방법으로 좋은 결과를 얻었다고 하셨군요.\n\n```swift\nstruct FavIcon {\n\n    let url: URL\n\n    init(issuer: String) {\n        let domain = \"\\(issuer).com\"\n        let url = URL(string: \"https://www.google.com/s2/favicons?sz=128&domain=\\(domain)\")!\n        self.url = url\n    }\n}\n```\n\n아이콘의 빠른 로딩을 위해 CachedAsyncImage 라이브러리를 사용한 거군요. 이렇게 하면 성능이 더 빨라질 거에요.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_18.png)\n\n<div class=\"content-ad\"></div>\n\n배경 제거를 처리하고 아이콘을 좀 더 돋보이게 만들기 위해 Metal 셰이더를 추가했어요.\n\n여기 SwiftUI View 확장 부분이에요:\n\n```js\n//  View+ColorEffect.swift\n\nimport SwiftUI\n\nextension View {\n\n    func eraseBackground(backgroundColor: Color = Color(uiColor: UIColor.secondarySystemBackground)) -> some View {\n        modifier(EraseBackgroundShader(backgroundColor: backgroundColor))\n    }\n}\n\nstruct EraseBackgroundShader: ViewModifier {\n\n    let backgroundColor: Color\n\n    func body(content: Content) -> some View {\n        content\n            .colorEffect(ShaderLibrary.eraseBackground(\n                .color(backgroundColor)\n            ))\n    }\n}\n```\n\n그리고 물론 MSL 셰이더 코드도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```cpp\n#include <metal_stdlib>\n#include <SwiftUI/SwiftUI_Metal.h>\nusing namespace metal;\n\n[[ stitchable ]]\nhalf4 eraseBackground(\n    float2 position,\n    half4 color,\n    half4 backgroundColor\n) {\n\n    if (color.r >= 0.95 && color.g >= 0.95 && color.b >= 0.95) {\n        return backgroundColor;\n    }\n\n    return color;\n}\n```\n\n여기에 그들이 어떻게 보이는지 있어요. 그들은 나쁘지 않지만 놀라운 것은 아니에요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_19.png)\n\n난 지나치게 엔지니어링을 시작했어. 이것에 핀을 꽂아 놓고 나중에 다시 생각해 봐요.\n\n\n\n<div class=\"content-ad\"></div>\n\n## UI 디자인 개선\n\n기본 2단계 인증 앱으로서 이미 꽤 잘 작동하고 있습니다.\n\n대부분의 사람들을 앞선 존재가 되기 위해서는, 극도로 공격적인 유료 벽을 두지 않으면 되는구나 ($4.99 매주? 정말?!)\n\n일부 기본 소프트웨어 개발 작업을 통해 타이밍, 기본 UI 및 데이터 저장 작업을 수행한 후, 이제는 정말로 아주 잘 작동하고 있습니다. - 기본 SwiftUI 구성 요소를 사용하는 것은 작업이 \"그냥 작동\"되도록하는 빛나는 방법입니다*.\n\n<div class=\"content-ad\"></div>\n\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*TUkFn9ejk93WczTL02Jlrg.gif)\n\n저는 경쟁사 조사를 통해 찾은 tap-to-copy와 같은 편의 기능 몇 가지를 구현했어요.\n\n@ScaledMetric와 ViewThatFits 같은 접근성 도구를 활용하여 시각적 요구에 관계없이 앱이 원할하게 작동하도록 했어요. Apple의 기본 SwiftUI 구성 요소와 색상에 밀접하게 따라가면서 무료로 라이트 모드도 구현되었어요.\n\n```js\n// AccountView.swift\n\n@ScaledMetric(relativeTo: .largeTitle) private var iconSize: CGFloat = 36\n\nprivate var icon: some View {\n    CachedAsyncImage(url: FavIcon(issuer: account.issuer).url, content: {\n        $0\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n\n    }, placeholder: {\n        Text(String(account.issuer.first?.uppercased() ?? account.name.first?.uppercased() ?? \"\"))\n            .font(.largeTitle)\n            .monospaced()\n    })\n    .frame(width: iconSize, height: iconSize, alignment: .center)\n}\n\nprivate var code: some View {\n    ViewThatFits {\n        HStack(alignment: .center, spacing: 16) {\n            codeText\n        }\n        VStack(alignment: .leading, spacing: 4) {\n            codeText\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_20.png\" />\n\n## 앱을 더 흥미롭게 만들기\n\n진정한 핵심 가치 제안을 개선하기 위해 흥미로운 옵션을 더 많이 구현했습니다:\n\n- 000000과 같은 섹스투플렛 및 쿼드투플렛\n- 012345와 같은 순서대로 계속되는 수열\n- 300000처럼 백만단위의 수\n- 000001과 같은 일의 자리, 000010과 같은 십의 자리\n- 원주율 파이(314159)와 같은 수학 상수\n- 플랑크 상수(6.6x10⁻³⁴)와 같은 물리 상수\n- 012210과 같은 회문\n- 121212와 123123과 같은 반복된 이차, 삼차 수열\n\n<div class=\"content-ad\"></div>\n\n다음은 Markdown 형식으로 표 태그를 변경한 코드입니다.\n\n```js\nfunc checkThatCounting() -> Bool {\n    let characters = Array(self)\n    for i in 1..<characters.count {\n        if let prevDigit = Int(String(characters[i - 1])),\n           let currentDigit = Int(String(characters[i])),\n           currentDigit != prevDigit + 1 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc checkThatPalindrome() -> Bool {\n    self == String(self.reversed())\n}\n\nfunc checkThoseRepeatedThrees() -> Bool {\n    self.prefix(3) == self.suffix(3)\n}\n\nfunc checkThoseHunderedThousands() -> Bool {\n    suffix(5) == \"00000\"\n}\n```\n\n## 확률 이론\n\n이제 설정 UI를 업데이트하여 흔함, 드물음, 초 희귀함으로 정렬하거나 반복, 상수, 순서 또는 라운드 숫자와 같은 유형으로 정렬할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n`<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_21.png\" />`\n\n각 희귀 수준의 확률을 어떻게 계산하나요?\n\n012345와 같은 완벽한 숫자 시퀀스의 경우, 1백만 개의 가능한 번호 조합 중 6가지만 가능합니다 (567890까지).\n\n30초에 1백만 개의 조합을 곱하고 가능한 시퀀스인 6으로 나누면, 각 계정당 평균적으로 완벽한 카운팅 시퀀스가 발생할 수 있다는 것은 약 5백만 초마다 발생할 수 있다는 것을 의미합니다 — 평균적으로 58일마다 한 번씩입니다.\n\n<div class=\"content-ad\"></div>\n\n이 정도라니, 정말 희귀한 것이죠.\n\n하지만 123321과 같은 회문 수는 만들 수 있는 3자리 수가 1000개에 달합니다. 이는 평균적으로 매일 0.34번씩 볼 수 있다는 뜻이에요! 훨씬 더 흔하죠.\n\n중간에는 141414와 같이 반복되는 숫자들이 있습니다. 이런 경우 가능한 숫자는 00부터 99까지의 100개인데요, 그래서 이들은 평균적으로 3.5일에 한 번씩 발생합니다. 그래서, 정말 희귀하지만, 극도로 희귀하지는 않은 편이에요.\n\n이 중 일부인 쿼드와 같은 일련 번호들은 조금 더 많은 계산이 필요한데, 그래서 수천만 개의 OTP(일회용 비밀번호)를 생성하고 각 흥미로운 종류별로 발생 빈도를 세어 상대적 빈도를 감을 수 있게 했어요.\n\n<div class=\"content-ad\"></div>\n\n## 성능 향상\n\n앱은 모든 일반적인 흥미로운 코드를 활성화한 상태에서만 아주 빠르게 64개의 흥미로운 2FA 코드를 처리할 수 있지만, 초희귀한 GET만 원할 때는 처리 시간이 오래 걸립니다.\n\n수백만 개의 잠재적인 OTP를 처리하는 동안, 유효한 흥미로운 코드를 발견하자마자 알림을 반환하고 예약하는 것이 필요합니다.\n\n오래된 친구인 Combine 프레임워크는 깔끔한 해결책을 제공해줍니다!\n\n<div class=\"content-ad\"></div>\n\n```swift\n// CodeGenerator.swift\n\nvar codeSubject = PassthroughSubject<OTP, Never>()\n\nfunc generateCodes(accounts: [Account]) {\n    // ...\n    codeSubject.send(otp)\n}\n```\n\n또한 사용자가 중간에 설정을 변경하는 경우를 대비하여 작업을 취소하고 다시 시작할 수 있도록 일부 작업을 사용했습니다. 작업을 분리함으로써 암호 해독 및 문자열 분석 작업을 UI 스레드에서 유지하지 않을 수 있습니다.\n\n```swift\n// CodeViewModel.swift\n\nprivate var otpComputationTask: Task<Void, Never>?\nprivate var notificationSchedulingTask: Task<Void, Never>?\n\nfunc recomputeNotifications() {\n    handleNotificationScheduling()\n    handleOTPComputation()\n}\n\nprivate func handleNotificationScheduling() {\n    notificationSchedulingTask?.cancel()\n    notificationSchedulingTask = Task.detached(priority: .high) {\n        guard await NotificationScheduler.shared.isAuthorized() else { return }\n        NotificationScheduler.shared.cancelNotifications()\n        for await (code, count) in CodeGenerator.shared.codeSubject.values {\n            try? await NotificationScheduler.shared.scheduleNotification(for: code)\n        }\n    }\n}\n\nprivate func handleOTPComputation() {\n    let accounts = accounts\n    otpComputationTask?.cancel()\n    otpComputationTask = Task.detached(priority: .high) {\n        guard await NotificationScheduler.shared.isAuthorized() else { return }\n        CodeGenerator.shared.generateCodes(accounts: accounts)\n    }\n}\n```\n\n이제 일정이 시퀀스대로 아니라 하나의 큰 덩어리로 나오지 않고 꽤 부드럽게 작동합니다!\n\n\n\n<div class=\"content-ad\"></div>\n\n\n\nScheduled repeatedTwos: 292929 @ 2024-02-25 23:33:30 +0000\nScheduled repeatedTwos: 878787 @ 2024-02-26 06:03:30 +0000\nScheduled quints: 666660 @ 2024-02-26 10:54:00 +0000\nScheduled quints: 255555 @ 2024-02-26 21:11:00 +0000\nScheduled repeatedTwos: 606060 @ 2024-02-26 23:27:00 +0000\nScheduled sexts: 666666 @ 2024-04-16 23:22:00 +0000\nScheduled boltzmannConstant: 141023 @ 2024-04-19 02:05:00 +0000\nScheduled counting: 012345 @ 2024-04-20 04:51:30 +0000\nScheduled planksConstant: 661034 @ 2024-04-20 05:38:00\n\n\n\n## 앱 아이콘\n\n이 거래 그냥 사라지고 싶었어요. 앱 아이콘에 진짜로 체크하려면 이제 목멸에 달렸거든요. 정말 완벽해요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_22.png)\n\n\n<div class=\"content-ad\"></div>\n\n하지만 제 친구가 Lionsgate Films의 친구들이 조금 소송을 제기할 수도 있다고 지적했습니다.\n\n하지만 난 그걸 가져야 했어!\n\n어쨌든 희망이 있다면:\n\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_23.png)\n\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n그냥 개인정보를 꼭 보호하세요!\n\n<div class=\"content-ad\"></div>\n\n달리(DALL-E)는 정말 손등을 그리는 걸 좋아하지 않았어요. 저는 노력해 봤지만요.\n\n# 마지막 손질\n\n그 개념은 증명되었어요. 어플이 잘 작동하고 있어요! Check 'em의 즐거움을 세상에 보여주기 전에 약간의 마무리와 작은 기능을 추가할 시간이에요.\n\n첫 릴리스를 만들기 전에 V1에서 구현할 수 있는 새로운 기능과 버그 수정 사항들을 목록으로 만들었어요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 높은 우선순위 -\n// TODO: - 주문 추가 - 저장된 URL에 쿼리 항목으로 정렬 추가\n// TODO: - 새로 고침 시 햅틱 진동\n// TODO: - 푸시 알림 요청은 설정 화면에 진입했을 때에만\n// TODO: - 알림 활성화를 위한 설정 링크 추가\n// TODO: - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시 - 이미 있는 경우 계정에 스캔을 추가하지 않음\n// TODO: - 설정 화면을 열 때 처리 작업 취소\n// TODO: - 푸시 알림 딥 링크 - GET이 여전히 존재할 때 앱 리뷰 프롬프트로 이동\n// TODO: - 매우 드문 GET가 전송되지 않는 것 같음?? 시뮬레이터에서 로컬로 발생하지 않지만 quints는 괜찮음 - 큐에 들어가는 것처럼 보임\n// TODO: - 버그 - 두 번째 로드에서 진행 상황 보기가 나타나지 않음\n// TODO: - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시 - 이미 있는 경우 계정에 스캔을 추가하지 않음\n// TODO: - 버그 - 2개의 동시 계산이 있을 때 백분율이 계속 변동하는 버그 발생\n// TODO: - QR 및 설정에 TipKit 추가\n\n// 낮은 우선순위 -\n// TODO: - 상태 복원을 위해 @SceneStorage 사용 - 키패인 작업을 기다리지 않아도 되도록\n// TODO: - 한 단계 또는 뒤로 이동\n// TODO: - 딥 링크를 사용하여 \"컬렉션\" 화면 생성 - 보관된 항목으로 본 GET 수집 (키패인의 사전으로)\n```\n\n당연히, 제게 제품 관리자가 없기 때문에 최저 우선 순위의 작업을 즉시 시작했습니다: 딥 링크로 컬렉션을 구축하는 것 - 내 드문 GET가 헛되이 낭비되는 것을 원하지 않아요!\n\n## 컬렉션\n\n이 부분은 원본 개념 증명에서 식별한 문제에 도움이 됩니다: 사용자들이 알림과 상호 작용하도록 유도하여 앱에 재진입하도록 해야합니다.\n\n<div class=\"content-ad\"></div>\n\n컬렉션 뷰를 만드는 것은 조금 까다로울 수 있어요. 왜냐하면 몇 가지 부분을 고려해야 되거든요:\n\n- 사용자가 알림을 탭하고 앱으로 딥 링크 할 수 있게 합니다.\n- 탭한 코드의 흥미로운 부분을 안전하게 저장합니다.\n- 이것들을 컬렉션 화면에 렌더링합니다.\n\n알림에 딥 링크를 추가하는 것은 꽤 간단했어요.\n\n```js\n// Notifications.swift\n\n// ...\ncontent.userInfo = [\"deepLink\": \"checkem://\\(otp.code)\"]\n```\n\n<div class=\"content-ad\"></div>\n\n그러나 약간 거슬리지만, 알림을 처리하기 위해 AppDelegate를 만들어야 했어요 — SwiftUI는 아직 완전히 자체적으로 이를 다루지 못합니다.\n\n```swift\n// AppDelegate.swift\n\nfunc userNotificationCenter(_ center: UNUserNotificationCenter,\n                            didReceive response: UNNotificationResponse,\n                            withCompletionHandler completionHandler: @escaping () -> Void) {\n\n    let userInfo = response.notification.request.content.userInfo\n\n    if let deepLinkString = userInfo[\"deepLink\"] as? String,\n       let deepLinkURL = URL(string: deepLinkString) {\n        guard let code = deepLinkURL.code else { return }\n        try? CollectionManager.shared.save(code: code)\n    }\n\n    completionHandler()\n}\n```\n\n마지막으로, Keychain에 저장된 코드들의 긴 쉼표로 구분된 목록을 게으르게 추가했어요.\n\n```swift\n// KeychainManager.swift\n\nfunc storeCollectionItem(code: String) throws {\n    var collection = try keychain.get(Constants.collectionKey) ?? \"\"\n    if !collection.isEmpty {\n        collection.append(\",\")\n    }\n    collection.append(code)\n    try keychain.set(collection, key: Constants.collectionKey)\n}\n```\n\n<div class=\"content-ad\"></div>\n\n빠르게 출시하기 위한 욕망의 결과인 것이지, 신중하게 고려된 엔지니어링 결정의 결과는 아닙니다. 사용자가 Keychain 항목 당 4kB의 소프트 제한에 가까워지는 경우 후회할 수 있는 결정이었습니다(하드 제한은 대략 16MB 이므로 괜찮을 것 같아요!).\n\n이 작업은 빠르게 성과를 거두었는데, 컬렉션 화면은 빠르게 내 소중한 GET들로 가득 차기 시작했어요!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_27.png)\n\n원래는 사용자가 알림을 탭할 때까지 컬렉션을 숨겼었는데, 사용자가 '모두 수집하기'에 도전하도록 하는 것이 더 매력적이라고 깨달았어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_28.png\" />\n\n## 진동\n\niOS 17 sensoryFeedback API를 사용하면 매우 섬세한 진동을 재생할 수 있습니다. 사실 너무 섬세해서 저는 마음에 들지 않았어요. 그래서 Carbn에서 진동 엔진을 뽑아내어 여기에 재사용했어요.\n\n기존 새로고침 코드에 정말 가혹한 부작용을 추가했어요:\n\n<div class=\"content-ad\"></div>\n\n```swift\n// CodeView.swift\n\n.onReceive(timer) { _ in\n    let didChange = viewModel.refresh()\n    if didChange {\n        HapticEngine.shared.play(haptic: .refresh)\n    }\n}\n```\n\n집에서는 시도하지 마세요, 친구들!\n\n## 이미지 로딩 버그\n\nCachedAsyncImage 라이브러리에서 FavIcons가 존재하지 않음에도 불구하고 열심히 로딩되는 버그가 있습니다. 이로 인해 희미한 지구 모양이 나타납니다... 하지만 이대로 릴리스할 것 같습니다.\n\n<div class=\"content-ad\"></div>\n\n대부분의 경우 90% 정도는 잘 작동하며, 제가 개발한 Third-party SwiftUI 라이브러리 중 하나를 바꾸는 대신 배포하는 게 더 좋을 것 같아요.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_29.png)\n\n## 중복 버그\n\n배포 전에 나머지 버그들 중 일부는 더 주의 깊게 살펴보았지만, 이 문제는 특히 나쁩니다. 누군가가 QR 코드를 두 번 스캔하면 동일한 계정의 이상한 중복이 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// TODO: - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시하도록 해주세요 - 이미 있는 경우 계정에 스캔을 추가하지 마세요\n```\n\n시간을 절약할 수 있는 라이브러리를 뜯어내고 교체하는 대신, 이 버그는 한 줄의 코드 수정으로 해결되었습니다.\n\n```js\n// CodeViewModel.swift\n\nfunc create(account: Account, url: URL) throws {\n    guard !accounts.contains(where: { $0.name == account.name }) else { return }\n    // ...\n}\n```\n\n2FA 계정을 이름을 기준으로 하는 키체인이기 때문에, 이 수정은 매우 합리적입니다.\n\n<div class=\"content-ad\"></div>\n\n## 코드가 로드되지 않음\n\n코드가 대기열에 들어가지 않는 다른 문제를 발견했어요.\n\n```js\n// TODO: - 초희귀한 GET가 전송되지 않나요?? 에뮬레이터에서 로컬에서 발생시키질 못하겠는데 퀸트는 잘 됩니다 - 들어가야 할 것 같아요\n```\n\n알고 보니 @AppStorage가 실제로 작동하는 방식을 잘못 이해했던 것 같아요 — 기본값은 실제로 사용자 기본 설정에 저장하는 대신 UI에만 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\n// SettingsView.swift\n\n@AppStorage(\"sexts\") private var sexts: Bool = true\n```\n\n첫 번째 앱 로드 시 UserDefaults를 채우는 함수가 이 문제를 해결했습니다.\n\n```swift\n// CheckEmApp.swift\n\n@main\nstruct CheckEmApp: App {\n\n    init() {\n        initializeDefaultsIfRequired()\n    }\n\n    // ...\n\n    func initializeDefaultsIfRequired() {\n        guard UserDefaults.standard.object(forKey: \"sexts\") == nil else { return }\n        CodeGenerator.shared.initializeDefaults()\n    }\n```\n\n## TipKit\n\n\n<div class=\"content-ad\"></div>\n\n새로운 iOS 17 TipKit를 사용하여 조금 더 개선했어요. 사용자가 앱을 처음 로드할 때 무엇을 해야 하는지 간단히 이해할 수 있게 도와주는 기능이 추가되었답니다.\n\n![app screenshot](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_30.png)\n\n이 새로운 API로 구현하는 것이 의외로 간단했어요.\n\n```js\n// CodeView.swift\n\n@ViewBuilder\nprivate var tips: some View {\n    TipView(QRTip()).tipImageSize(CGSize(width: tipImageSize, height: tipImageSize))\n    TipView(SettingsTip()).tipImageSize(CGSize(width: tipImageSize, height: tipImageSize))\n    TipView(CollectionTip()).tipImageSize(CGSize(width: tipImageSize, height: tipImageSize))\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 상점 상품 목록\n\n출시할 준비가 끝났다고 생각해요.\n\n![상품 목록](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_31.png)\n\nAppScreens를 통해 상점 상품 목록을 설정 중이에요. 저희의 캣츠가 등장하는 Check 'em의 진정한 힘을 보여주는 두 번째 스크린샷을 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n---\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_32.png)\n\n진짜요?\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_33.png)\n\n알겠어요, 제가 세계에서 가장 자유주의자적인 사람은 아니지만, 시장을 1% 증가시키기 위해 여러 가지 번거로움을 겪는 건 싫어요. 좀 더 나은 방법이 있지 않을까요!\n\n<div class=\"content-ad\"></div>\n\n(내 프랑스 독자 여러분 죄송해요)\n\n간단히 말해서, 우리는 앱 스토어 커넥트에 설정을 완료했고 버튼을 누르기 ready해요!\n\n## 결론\n\n저의 여정을 따라 읽어주셔서 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트는 정말 재미있었어요! 패턴을 찾는 것을 좋아하는 내 내재적인 IT 열정을 만졌을 뿐만 아니라, 멋진 처리, 스레딩, 최적화 문제를 다루어 볼 수 있었어요!\n\n다음 단계로, v1.1 릴리스에 대한 성능에 완전히 초점을 맞춘 상태입니다. 이제 OTP(일회용 암호)를 더 빠르게 처리하고 빠르게 불러올 거예요!\n\n이 앱을 좋아하시면, 보고 싶은 숫자에 대한 의견을 주세요! 마지막으로, Android 버전을 원하는 분들이 계신다면, 제 소스 코드를 공유해드리고 함께 개발할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png"},"coverImage":"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png","tag":["Tech"],"readingTime":28},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>이른 시기 2010년대에 성장한 모든 회복된 엣지로드와 같이 나는 4chan과 같은 이미지 보드의 전성기를 약간 그리워합니다. 그들은 나치들이 모든 것을 망쳐 버리기 전에 야생 서부 초기 인터넷의 마지막 요새였어요.</p>\n<p>클래식한 밈 중 하나는 GET이었는데, 당신이 랜덤으로 생성된 게시물 ID가 흥미로운 숫자 시퀀스를 포함할 것으로 정확히 예상했을 때 자부심을 느끼게 됩니다.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png\" alt=\"그림\"></p>\n<p>요즘에는 이제 모든 보통 사람들이 성장하고 직장을 찾은 지금, 옛날의 마법에 제일 가까이 올 수 있는 것은 이중 인증 코드뿐입니다.</p>\n<p>당신이 알고 있으면 좋아요.</p>\n<p>은행, 이메일 또는 클라우드 서비스에 다시 인증해야 하는 번거로움. 787000 또는 123450 같이 정말 좋은 숫자를 받았을 때의 작은 기쁨.</p>\n<p>영감을 받았어요.</p>\n<p>이 MFA 코드들은 매 30초마다 갱신되는 공통 알고리즘을 사용해요. 우리가 6자리 인증 코드에서 가능한 더블, 트리플, 쿼드, 퀸텀플, 섹스텀플 중에 매우 일부만을 경험하고 있어요.</p>\n<p>내 독립 프로젝트들처럼, 내 주변에 하나의 명확한 비전이 있었으며 그 주위에 구축할 수 있었습니다:</p>\n<p>내가 뭘 해야 하는지 알았어요.</p>\n<h3>컨셉 증명</h3>\n<p>이게 작동하는지 알아야 하는 움직이는 부품은 많이 필요하지 않아요.</p>\n<ul>\n<li>2FA 비밀 키를 입력해주세요.</li>\n<li>로컬에서 6자리 2FA 코드를 생성합니다.</li>\n<li>쿼드/퀸트/섹스트가 생성될 때 푸시 알림을 보냅니다.</li>\n</ul>\n<h2>최소 기능 제품</h2>\n<p>만약 멋진 2FA 번호가 생성될 때 알림을 받는 개념이 유지된다면, 몇 가지 주요 기능을 갖춘 실제 앱으로 발전시킬 수 있습니다:</p>\n<ul>\n<li>카메라로 2FA 비밀을 캡처합니다.</li>\n<li>여러 2FA 코드를 저장합니다.</li>\n<li>더 많은 숫자 패턴을 구현합니다.</li>\n<li>사용자가 알고 싶은 패턴을 선택할 수 있도록 합니다.</li>\n</ul>\n<p>내가 뭔가를 알고 있었다는 걸 알았어: 내가 이걸 설명한 사람들의 90%는 나를 멍청이로 생각했어. 나머지 10%는 순수한 창의성만을 보았어.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_1.png\" alt=\"이미지\"></p>\n<h1>Proof of Concept 구축</h1>\n<h2>TOTP</h2>\n<p>TOTP 또는 시간 기반 일회용 비밀번호는 놀랍도록 간단한 개념입니다. 이는 두 가지 입력을 사용하는 인증 프로세스입니다:</p>\n<ul>\n<li>인증 서비스 및 자신의 장치에 저장된 비밀 키</li>\n<li>현재 시간 또는 더 정확히 말하면 유닉스 시간 이후 경과한 30초 간격의 수</li>\n</ul>\n<p>이 알고리즘은 두 입력을 결정론적으로 해시하여 여러분이 알고 사랑하는 6자리 코드를 생성합니다. 이 해싱 알고리즘은 Apple의 CryptoKit에서 찾을 수 있는 매우 흔한 것입니다. Apple 포럼의 우리 친구들 덕분에 여기 TOTP 알고리즘의 전체 영광이 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// CodeGenerator.swift</span>\n\nprivate <span class=\"hljs-keyword\">let</span> secret = <span class=\"hljs-title class_\">Data</span>(<span class=\"hljs-attr\">base64Encoded</span>: <span class=\"hljs-string\">\"AAAAAAAAAAAAAAAAAAAAAAAAAAA\"</span>)!\n\nfunc <span class=\"hljs-title function_\">otpCode</span>(<span class=\"hljs-attr\">date</span>: <span class=\"hljs-title class_\">Date</span> = <span class=\"hljs-title class_\">Date</span>()) -> <span class=\"hljs-title class_\">String</span> {\n    <span class=\"hljs-keyword\">let</span> digits = <span class=\"hljs-number\">6</span>\n    <span class=\"hljs-keyword\">let</span> period = <span class=\"hljs-title class_\">TimeInterval</span>(<span class=\"hljs-number\">30</span>)\n    <span class=\"hljs-keyword\">let</span> counter = <span class=\"hljs-title class_\">UInt64</span>(date.<span class=\"hljs-property\">timeIntervalSince1970</span> / period)\n    <span class=\"hljs-keyword\">let</span> counterBytes = (<span class=\"hljs-number\">0.</span>.&#x3C;<span class=\"hljs-number\">8</span>).<span class=\"hljs-title function_\">reversed</span>().<span class=\"hljs-property\">map</span> { <span class=\"hljs-title class_\">UInt8</span>(counter >> (<span class=\"hljs-number\">8</span> * $0) &#x26; <span class=\"hljs-number\">0xff</span>) }\n    <span class=\"hljs-keyword\">let</span> hash = <span class=\"hljs-variable constant_\">HMAC</span>&#x3C;<span class=\"hljs-title class_\">Insecure</span>.<span class=\"hljs-property\">SHA1</span>>.<span class=\"hljs-title function_\">authenticationCode</span>(<span class=\"hljs-attr\">for</span>: counterBytes, <span class=\"hljs-attr\">using</span>: <span class=\"hljs-title class_\">SymmetricKey</span>(<span class=\"hljs-attr\">data</span>: secret))\n    <span class=\"hljs-keyword\">let</span> offset = <span class=\"hljs-title class_\">Int</span>(hash.<span class=\"hljs-title function_\">suffix</span>(<span class=\"hljs-number\">1</span>)[<span class=\"hljs-number\">0</span>] &#x26; <span class=\"hljs-number\">0x0f</span>)\n    <span class=\"hljs-keyword\">let</span> hash32 = hash\n        .<span class=\"hljs-title function_\">dropFirst</span>(offset)\n        .<span class=\"hljs-title function_\">prefix</span>(<span class=\"hljs-number\">4</span>)\n        .<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-number\">0</span>, { ($0 &#x3C;&#x3C; <span class=\"hljs-number\">8</span>) | <span class=\"hljs-title class_\">UInt32</span>($1) })\n    <span class=\"hljs-keyword\">let</span> hash31 = hash32 &#x26; <span class=\"hljs-number\">0x7FFF_FFFF</span>\n    <span class=\"hljs-keyword\">let</span> pad = <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-attr\">repeating</span>: <span class=\"hljs-string\">\"0\"</span>, <span class=\"hljs-attr\">count</span>: digits)\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">String</span>((pad + <span class=\"hljs-title class_\">String</span>(hash31)).<span class=\"hljs-title function_\">suffix</span>(digits))\n}\n</code></pre>\n<p>위의 텍스트를 친근한 분위기로 한국어로 번역하면 다음과 같습니다.</p>\n<p>\"작업이 올바르게 진행되었는지 확인하기 위해, 구글 계정에 2단계 인증을 설정하고 해당 앱에서 비밀을 알고리즘을 사용하여 표시했어요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_2.png\" alt=\"이미지\"></p>\n<p>그리고, 마법처럼 (약간 번거로운 base32에서 base64로의 변환 후에), 구글이 내 2단계 인증을 승인했어요!</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_3.png\" alt=\"이미지\">\"</p>\n<p>이제 2단계 인증의 기본적인 부분이 작동 중이니, 컨셉 증명 퍼즐의 마지막 조각인 알림 생성을 구현할 수 있습니다.</p>\n<h2>앱 제한 사항</h2>\n<p>저희의 주요 제한 사항은 모바일 장치에 있습니다.</p>\n<p>실제로 2단계 인증 생성과 같은 백그라운드 프로세스를 영원히 실행할 수 없으며, 반드시 사용자 비밀을 백엔드 푸시 서버에 저장할 수 없습니다.</p>\n<p>그러므로 이 개념이 작동하도록하려면 약간 교묘해야합니다: 앞으로 2FA 코드를 미리 계산하고, 그들이 실제로 출현하는 시간에 전달을 예약해야합니다.</p>\n<p>또한, iOS에서 동시에 64개의 푸시를 예약할 수 있으므로, 다음을 고려해야합니다:</p>\n<ul>\n<li>사용자에게 앱을 다시 입력하도록 요청하는 알림 하나 또는 두 개를 저장합니다.</li>\n<li>알림을 터치하여 사용자가 앱을 열도록 유도하여 2FA 코드를 재계산하도록합니다.</li>\n</ul>\n<p>이제 POC가 작동하는 방법을 알았으니, 빌드를 시작합시다.</p>\n<h2>첫 번째 GETs 찾기</h2>\n<p>우리의 보잘것없는 2FA 코드를 향상시켜 봅시다.</p>\n<p>우리는 많은 코드를 미리 계산한 후, 각 코드가 GET인지를 확인하는 레귤러 표현식을 구현할 계획입니다.</p>\n<p>제 아주 간단한 SwiftUI 뷰는 UICollectionView를 백업으로 사용하여 성능이 훌륭하도록 보장하기 위해 이러한 코드를 편리하게 표시할 수 있습니다 (ScrollView의 기본 VStack은 10,000개의 항목 이전에 멀쩡히 오작동하기 시작할 것입니다!).</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// ContentView.swift</span>\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ContentView</span>: <span class=\"hljs-title class_\">View</span> {\n\n    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        <span class=\"hljs-type\">List</span> {\n            <span class=\"hljs-type\">ForEach</span>(makeOTPs(), id: \\.<span class=\"hljs-keyword\">self</span>) {\n                <span class=\"hljs-type\">Text</span>(<span class=\"hljs-variable\">$0</span>)\n                    .font(.custom(<span class=\"hljs-string\">\"Courier\"</span>, size: <span class=\"hljs-number\">20</span>))\n                    .font(.title)\n                    .kerning(<span class=\"hljs-number\">4</span>)\n            }\n            .frame(maxWidth: .infinity)\n        }\n    }\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">makeOTPs</span>() -> [<span class=\"hljs-type\">String</span>] {\n        (<span class=\"hljs-number\">0</span><span class=\"hljs-operator\">..&#x3C;</span><span class=\"hljs-number\">10_000</span>).map {\n            otpCode(increment: <span class=\"hljs-variable\">$0</span>)\n        }\n    }\n}\n</code></pre>\n<p>잘 진행되고 있어요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_4.png\" alt=\"image\"></p>\n<p>이제, 세 자리 숫자가 연속으로 나타나는 TOTP(예: 120333)를 확인하는 간단한 정규 표현식 평가기를 추가할 수 있어요.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">String</span> {\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">checkThoseTrips</span>() -> <span class=\"hljs-type\">Bool</span> {\n        (<span class=\"hljs-keyword\">try?</span> <span class=\"hljs-operator\">/</span>(\\d)\\<span class=\"hljs-number\">1</span>\\<span class=\"hljs-number\">1</span><span class=\"hljs-operator\">/</span>.firstMatch(in: <span class=\"hljs-keyword\">self</span>)) <span class=\"hljs-operator\">!=</span> <span class=\"hljs-literal\">nil</span>\n    }\n}\n</code></pre>\n<p>Text 뷰에 fontWeight 수정자를 추가하여 스크롤할 때 이 GET을 쉽게 감지할 수 있습니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-type\">Text</span>(<span class=\"hljs-variable\">$0</span>)\n    .fontWeight(<span class=\"hljs-variable\">$0</span>.checkThoseTrips() <span class=\"hljs-operator\">?</span> .heavy : .light)\n</code></pre>\n<p>에쟈! 그 여행을 확인하세요!</p>\n<p>우리는 심지어 우리의 정규 표현식을 신성한 네 숫자를 감지하기 위해 기본 수정할 수도 있어요 — 이건 독자들에게 연습문제로 남길게요.</p>\n<h2>전혀 소용없지만 재미있는 관찰</h2>\n<p>우리의 부주의한 ForEach 구현으로 인해 다음 경고 메시지가 발생했습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">ForEach</span>&#x3C;<span class=\"hljs-title class_\">Array</span>&#x3C;<span class=\"hljs-title class_\">String</span>>, <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-title class_\">Text</span>>: the <span class=\"hljs-variable constant_\">ID</span> <span class=\"hljs-number\">312678</span> occurs multiple\ntimes within the collection, <span class=\"hljs-variable language_\">this</span> will give <span class=\"hljs-literal\">undefined</span> results!\n</code></pre>\n<p>실제로 이 경고를 수십 번 받았습니다!</p>\n<p>우리가 10,000개의 OTP를 생성했기 때문에, 여러 개가 일치할 가능성이 매우 높습니다. 이는 생일 문제와 같은 원리이며, 가능한 일치 쌍의 수는 백만 이상이 됩니다.</p>\n<h2>희귀한 GET 생성하기</h2>\n<p>이제 몇 가지 흥미로운 코드를 계산해 보겠습니다.</p>\n<p>여기서 중요한 점은 미리 계산하여 미래를 예측하는 것입니다: TOTP는 비밀과 날짜 입력의 결정적 해시이기 때문에, 우리는 미래의 오랜 일련의 날짜를 입력하여 특정 시간에 어떤 OTP 코드를 볼 수 있는지 확인할 수 있습니다.</p>\n<p>각 코드와 날짜를 반환하도록 OTP 생성 방식을 조정해보겠습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// TOTP.swift</span>\n\nstruct <span class=\"hljs-variable constant_\">OTP</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">date</span>: <span class=\"hljs-title class_\">Date</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">code</span>: <span class=\"hljs-title class_\">String</span>\n}\n\nfunc <span class=\"hljs-title function_\">otpCode</span>(<span class=\"hljs-attr\">date</span>: <span class=\"hljs-title class_\">Date</span> = <span class=\"hljs-title class_\">Date</span>(), <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-title class_\">Int</span> = <span class=\"hljs-number\">0</span>) -> <span class=\"hljs-variable constant_\">OTP</span> {\n    <span class=\"hljs-keyword\">let</span> digits = <span class=\"hljs-number\">6</span>\n    <span class=\"hljs-keyword\">let</span> period = <span class=\"hljs-title class_\">TimeInterval</span>(<span class=\"hljs-number\">30</span>)\n    <span class=\"hljs-keyword\">let</span> adjustedDate = date.<span class=\"hljs-title function_\">addingTimeInterval</span>(period * <span class=\"hljs-title class_\">Double</span>(increment))\n    <span class=\"hljs-keyword\">let</span> counter = <span class=\"hljs-title class_\">UInt64</span>(adjustedDate.<span class=\"hljs-property\">timeIntervalSince1970</span> / period)\n    <span class=\"hljs-keyword\">let</span> counterBytes = (<span class=\"hljs-number\">0.</span>.&#x3C;<span class=\"hljs-number\">8</span>).<span class=\"hljs-title function_\">reversed</span>().<span class=\"hljs-property\">map</span> { <span class=\"hljs-title class_\">UInt8</span>(counter >> (<span class=\"hljs-number\">8</span> * $0) &#x26; <span class=\"hljs-number\">0xff</span>) }\n    <span class=\"hljs-keyword\">let</span> hash = <span class=\"hljs-variable constant_\">HMAC</span>&#x3C;<span class=\"hljs-title class_\">Insecure</span>.<span class=\"hljs-property\">SHA1</span>>.<span class=\"hljs-title function_\">authenticationCode</span>(<span class=\"hljs-attr\">for</span>: counterBytes, <span class=\"hljs-attr\">using</span>: <span class=\"hljs-title class_\">SymmetricKey</span>(<span class=\"hljs-attr\">data</span>: secret))\n    <span class=\"hljs-keyword\">let</span> offset = <span class=\"hljs-title class_\">Int</span>(hash.<span class=\"hljs-title function_\">suffix</span>(<span class=\"hljs-number\">1</span>)[<span class=\"hljs-number\">0</span>] &#x26; <span class=\"hljs-number\">0x0f</span>)\n    <span class=\"hljs-keyword\">let</span> hash32 = hash\n        .<span class=\"hljs-title function_\">dropFirst</span>(offset)\n        .<span class=\"hljs-title function_\">prefix</span>(<span class=\"hljs-number\">4</span>)\n        .<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-number\">0</span>, { ($0 &#x3C;&#x3C; <span class=\"hljs-number\">8</span>) | <span class=\"hljs-title class_\">UInt32</span>($1) })\n    <span class=\"hljs-keyword\">let</span> hash31 = hash32 &#x26; <span class=\"hljs-number\">0x7FFF_FFFF</span>\n    <span class=\"hljs-keyword\">let</span> pad = <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-attr\">repeating</span>: <span class=\"hljs-string\">\"0\"</span>, <span class=\"hljs-attr\">count</span>: digits)\n    <span class=\"hljs-keyword\">let</span> code = <span class=\"hljs-title class_\">String</span>((pad + <span class=\"hljs-title class_\">String</span>(hash31)).<span class=\"hljs-title function_\">suffix</span>(digits))\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">OTP</span>(<span class=\"hljs-attr\">date</span>: adjustedDate, <span class=\"hljs-attr\">code</span>: code)\n}\n</code></pre>\n<p>이를 테스트하기 위해 다수의 코드를 생성하고, GETs: quints (5개의 중복번호)를 검색해 보겠습니다.</p>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">interestingCodes</span>() -> [<span class=\"hljs-variable constant_\">OTP</span>] {\n    (<span class=\"hljs-number\">0.</span>.&#x3C;<span class=\"hljs-number\">1_000_000</span>)\n        .<span class=\"hljs-property\">map</span> { <span class=\"hljs-title function_\">otpCode</span>(<span class=\"hljs-attr\">increment</span>: $0) }\n        .<span class=\"hljs-property\">filter</span> { $0.<span class=\"hljs-property\">code</span>.<span class=\"hljs-title function_\">checkThoseQuints</span>() }\n}\n</code></pre>\n<p>내 M1이 해싱 함수를 실행하는 동안 몇 번의 숫자 계산 후, 약 30초 동안 진행된 결과물은 몇몇 굉장히 확인 가능한 GET들로 이어졌어요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_8.png\" alt=\"image\"></p>\n<h2>우리의 알림 일정 설정하기</h2>\n<p>좋은 숫자를 볼 수 있어서 재미있긴 하지만, 만약 실제로 GETs를 실생활에서 진짜 인증을 위해 사용할 수 없다면, 이 앱 개념은 그냥 무작위 번호 생성기와 다를게 없죠.</p>\n<p>이제 흥미로운 숫자가 도착하는 시점을 알게 되었으니, 번호를 실시간으로 받을 수 있도록 푸시 알림을 대기열에 넣고 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// NotificationScheduler.swift</span>\n\nprivate func <span class=\"hljs-title function_\">createNotification</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">for</span> otp: OTP</span>) {\n    <span class=\"hljs-keyword\">let</span> center = <span class=\"hljs-title class_\">UNUserNotificationCenter</span>.<span class=\"hljs-title function_\">current</span>()\n    <span class=\"hljs-keyword\">let</span> content = <span class=\"hljs-title class_\">UNMutableNotificationContent</span>()\n    content.<span class=\"hljs-property\">title</span> = <span class=\"hljs-string\">\"Quads GET!!\"</span>\n    content.<span class=\"hljs-property\">body</span> = otp.<span class=\"hljs-property\">code</span>\n    content.<span class=\"hljs-property\">sound</span> = <span class=\"hljs-title class_\">UNNotificationSound</span>.<span class=\"hljs-property\">default</span>\n    <span class=\"hljs-keyword\">let</span> components = <span class=\"hljs-title class_\">Calendar</span>.<span class=\"hljs-property\">current</span>.<span class=\"hljs-title function_\">dateComponents</span>([.<span class=\"hljs-property\">year</span>, .<span class=\"hljs-property\">month</span>, .<span class=\"hljs-property\">day</span>, .<span class=\"hljs-property\">hour</span>, .<span class=\"hljs-property\">minute</span>, .<span class=\"hljs-property\">second</span>], <span class=\"hljs-attr\">from</span>: otp.<span class=\"hljs-property\">date</span>)\n    <span class=\"hljs-keyword\">let</span> trigger = <span class=\"hljs-title class_\">UNCalendarNotificationTrigger</span>(<span class=\"hljs-attr\">dateMatching</span>: components, <span class=\"hljs-attr\">repeats</span>: <span class=\"hljs-literal\">false</span>)\n    <span class=\"hljs-keyword\">let</span> request = <span class=\"hljs-title class_\">UNNotificationRequest</span>(<span class=\"hljs-attr\">identifier</span>: <span class=\"hljs-title function_\">UUID</span>().<span class=\"hljs-property\">uuidString</span>, <span class=\"hljs-attr\">content</span>: content, <span class=\"hljs-attr\">trigger</span>: trigger)\n    center.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">request</span>) { (error) <span class=\"hljs-keyword\">in</span>\n        <span class=\"hljs-comment\">// ...</span>\n    }\n}\n</code></pre>\n<p>이 알림은 우리 뷰에서 사용하는 흥미로운 코드를 생성한 직후 예약되어 있어요. 그리고 잠시 후, 한꺼번에 2개의 멋진 푸시 알림을 받았답니다!</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_9.png\" alt=\"이미지\"></p>\n<p>이 통지가 실제로 나타나는 번호와 일치한다는 것을 확인하니, 더욱 흥미로워졌어요!</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_10.png\" alt=\"이미지\"></p>\n<p>아래 앱은 무작위 번호 생성기를 넘어서, 이 코드가 실제로 내 Google 계정에 로그인하는 데 도움이 된단 걸 알게 되었어요.</p>\n<h2>흥미로움</h2>\n<p>다양한 종류의 흥미로운 숫자를 결정하려면 흥미로움의 개념을 소개해야 합니다. 이는 반복되는 숫자, 연속하는 숫자, 수학적으로 흥미로운 숫자(예: 파이 또는 e), 회문을 포함할 수 있습니다.</p>\n<p>이러한 종류의 흥미로운 숫자는 ... 우리가 생성하는 각 OTP에 대해 선택적으로 만들어진 열거형 케이스로 열거될 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 흥미로움.swift</span>\n\n열거형 흥미로움 {\n\n    케이스 섹스텀\n    케이스 퀸츠\n    케이스 쿼드\n\n    이니셜라이저(<span class=\"hljs-attr\">code</span>: <span class=\"hljs-title class_\">String</span>) {\n        <span class=\"hljs-keyword\">if</span> code.<span class=\"hljs-title function_\">checkThoseSexts</span>(<span class=\"hljs-params\"></span>) {\n            self = .<span class=\"hljs-property\">sexts</span>\n        <span class=\"hljs-comment\">// ...</span>\n\n    변수 타이틀: <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-keyword\">switch</span> self {\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">sexts</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Sextuples GET!!!\"</span>\n        <span class=\"hljs-comment\">// ...</span>\n\n    함수 본문(<span class=\"hljs-attr\">code</span>: <span class=\"hljs-title class_\">String</span>) -> <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-keyword\">switch</span> self {\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">sexts</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"체크해 보세요 섹스텀: \\(code)\"</span>\n        <span class=\"hljs-comment\">// ...</span>\n</code></pre>\n<p>각 checkThose 메소드는 다른 정규식을 래핑하며, 우리는 가장 중요한 순서대로 실행합니다. 예를 들어, 섹스튜플은 쿼드보다 100배 더 드물다.</p>\n<p>오랜만에 리팩터를 해서 우리는 개념 증명을 만들었습니다. 요약해보겠습니다:</p>\n<ul>\n<li>앱은 (하드코딩된) 2FA 보안 키를 입력할 수 있게 해줍니다.</li>\n<li>앱은 로컬에서 매 30초마다 6자리 2FA 코드를 생성합니다.</li>\n<li>앱은 쿼드, 퀸트, 섹스가 생성될 때 푸시 알림을 예약합니다.</li>\n</ul>\n<p>몇 일 동안 앱을 사용해보려고 쉬는 시간을 가질 것입니다. 내 손에 멋진 앱을 만들 수 있을 것 같다고 예상하고 있습니다.</p>\n<h1>최소 기능 제품 구축</h1>\n<p>얼마 되지 않아, 몇 일 동안 제 아이디어의 핵심을 담은 앱, 즉 우선 증명 개념 버전을 사용해왔어요. 그리고 정말 좋아해요. 처음으로 여섯 번째 메시지를 받을 때까지 기다릴 수가 없네요.</p>\n<p>이제는 뼈대에 고기를 붙여 완전히 다듬어진 2FA 앱을 구축할 때입니다. 이전에 설명한 대로, 실제로 4가지 주요 새로운 기능만 추가하면 됩니다:</p>\n<ul>\n<li>2FA QR 코드를 스캔하여 안전하게 키체인에 저장하기</li>\n<li>사용자 인터페이스에서 여러 2FA 계정을 표시하고 관리하기</li>\n<li>사용자가 중요하게 여기는 번호 설정하기</li>\n<li>더 많은 종류의 재미있는 기능 구현하기</li>\n</ul>\n<p>마지막으로, 기능적이 아닌 요구 사항: 매우 느린 코드 생성을 최적화하는 작업을 해야 합니다. 배치 처리 또는 로컬 지속성을 활용할 수도 있을 것 같아요.</p>\n<h2>인간 인터페이스 가이드라인</h2>\n<p>디자인에 대해 별다른 특별한 것을 할 계획은 없어요. 표준 애플 List 뷰 구성 요소를 사용하여 HIG를 따를 것이에요.</p>\n<p>UX는 멋지고 간단하게 유지합시다: 주로 푸시 알림에 기능이 집중되어 있으며 매우 완벽해요. 이 말은 QR 스캐너와 설정을 툴바 버튼 뒤에 숨기고, 모달 플로우가 표시되도록 하는 것을 의미해요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_11.png\" alt=\"Scanning 2FA Secrets\"></p>\n<h2>Scanning 2FA Secrets</h2>\n<p>A couple of open-source libraries will save me a ton of time on cookie-cutter tasks. CodeScanner to supply simple SwiftUI QR code scanning, and KeychainAccess to easily store these 2FA account secrets in the keychain.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_12.png\" alt=\"Scanning 2FA Secrets\"></p>\n<p>해당 스캐너 라이브러리는 카메라 접근을 사용하여 QR 코드를 쉽게 구문 분석할 수 있는 URL로 변환합니다. 아래와 같은 형식으로 변환됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">otpauth</span>:<span class=\"hljs-comment\">//totp/Google%3Atest%40gmail.com?secret=bv7exx7sltbcqffec1qyxscueydwsu5h&#x26;issuer=Google</span>\n</code></pre>\n<p>이제 앱에 우리의 계정을 쉽게 추가할 수 있게 되었어요!</p>\n<h2>선호하는 숫자 선택하기</h2>\n<p>SwiftUI @AppStorage를 사용하여 List 및 몇 가지 Toggles와 함께 사용하면 쉽게 사용자 설정 화면을 구축할 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_14.png\" alt=\"image\"></p>\n<p>나는 onDisappear에서 부모 뷰에게 다시 숫자 처리를 시작하고 알림을 다시 예약하라고 알리기 위해 클로저를 사용했습니다. 이것은 토글이 변경될 때마다 비싼 계산을 실행하는 대신 모든 것을 일괄 처리하는 가장 간단한 방법이었습니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// CodeView.swift</span>\n\n<span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n    <span class=\"hljs-comment\">// ...</span>\n    .sheet(isPresented: <span class=\"hljs-variable\">$showSettings</span>) {\n        <span class=\"hljs-type\">SettingsView</span>(onDisappear: {\n            viewModel.recomputeNotifications()\n        })\n    }\n}\n</code></pre>\n<h2>Belated Customer Research</h2>\n<p>안녕하세요, 저는 독립 개발자에요. 프로젝트 빌드 과정 중간에 이것을 할 수 있어요!</p>\n<p>몇 가지 다른 2FA 앱을 다운로드해서 아이디어를 베낄 만한 것이 있는지 살펴보기로 결정했어요. 사실, 꽤 혼잡하고 경쟁력 있는 앱 시장을 기대했는데, 이 중 일부는 정말 형편없었어요.</p>\n<p>아래는 Markdown 형식으로 변환:</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_15.png\" alt=\"이미지1\"></p>\n<p>정말이지, 그 중 50% 이상이 매우 공격적인 페이월을 설정해 놓고 사용하기 전에 이겼다... 무료 옵션이 완전히 제공되는 상황일 때 말이죠.</p>\n<p>이 페이월이 넘쳐난다 해도, 좋은 아이디어를 빌려올 수 있었던 몇 가지를 기록해 두었어요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_16.png\" alt=\"이미지2\"></p>\n<h2>여러 개의 2FA 계정</h2>\n<p>여러 개의 계정을 가진 사람들에겐 이것이 매우 중요하죠. 계정이 많으면 더 많은 GET 기회가 생기기도 하거든요!</p>\n<p>내 키체인 코드를 업데이트했어요. 이제 여러 개의 QR 코드를 스캔할 수 있게 되었고, 계정 데이터(비밀 정보를 포함한)도 저장하게 되었어요. 이제 나의 다양한 계정으로 로그인하는 데 완벽하게 작동했어요!</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_17.png\" alt=\"QR 코드 이미지\"></p>\n<p>저는 적절한 내장 목록 기능을 구현하여 이제 우리가 더 이상 필요하지 않은 코드를 삭제할 수 있습니다.</p>\n<p>경쟁사 분석을 하면서, 구글 인증 프로그램이 예전 아이폰에 추가한 2단계 인증 코드를 몇 년 전부터 계속 보관하고 있는 것을 발견했어요!</p>\n<p>그때 제 데이터 계층에서 두 가지 실수를 발견했습니다.</p>\n<ul>\n<li>iCloud와 동기화하지 않았던 점</li>\n<li>키패인 밖에 계정을 지속하려고 한 점</li>\n</ul>\n<p>먼저, iCloud에 대한 키체인을 동기화하면 계정이 다른 모든 Apple 기기에 나타납니다. Keychain Access 라이브러리를 사용하면 쉽게 할 수 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// KeychainManager.swift</span>\n\nself.<span class=\"hljs-property\">keychain</span> = <span class=\"hljs-title class_\">Keychain</span>().<span class=\"hljs-title function_\">synchronizable</span>(<span class=\"hljs-literal\">true</span>);\n</code></pre>\n<p>둘째, 저는 반짝이는 물건 증후군으로 고생했어요: SwiftData를 영속성 레이어로 사용하기 위해 서두르다 보니 Keychain만을 비밀로 사용하고 나머지 계정 메타데이터는 새로운 프레임워크를 통해 영속화하고 있었어요.</p>\n<p>이것은 다른 장치에서 나의 계정을 가져올 수 없었다는 것을 의미해요 — 비밀만으로는 쓸모가 없어요!</p>\n<p>그래서 전 Account 객체 전체를 키체인에 저장해야 한다는 것을 깨달았어요.</p>\n<p>새로운 접근 방식은 QR 코드 URL을 키체인에 그대로 저장하는 것입니다. 이제 Account 객체 자체는 일시적입니다; 앱을 로드할 때마다 URL에서 다시 계산됩니다.</p>\n<p>이렇게 하면 로드할 때마다 Accounts가 로그인한 모든 iDevice에 나타날 수 있습니다! 이 일시적인 방식은 두 마리의 새끼를 한 방에 잡는 멋진 방법입니다. 이제 필요할 때 키체인에서 Accounts를 가져올 때 사용합니다:</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// AccountManager.swift</span>\n\n<span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">fetchAccounts</span>() <span class=\"hljs-keyword\">throws</span> -> [<span class=\"hljs-type\">Account</span>] {\n    <span class=\"hljs-keyword\">try</span> <span class=\"hljs-type\">KeychainManager</span>.shared.fetchAll()\n        .compactMap { createAccount(from: <span class=\"hljs-variable\">$0</span>) }\n}\n\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">createAccount</span>(<span class=\"hljs-params\">from</span> <span class=\"hljs-params\">urlString</span>: <span class=\"hljs-type\">String</span>) -> <span class=\"hljs-type\">Account</span>? {\n    <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> url <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">URL</span>(string: urlString),\n          <span class=\"hljs-keyword\">let</span> account <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">SecretURLParser</span>.shared.account2FA(from: url) <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n    }\n    <span class=\"hljs-keyword\">return</span> account\n}\n</code></pre>\n<p>일반 코딩 작업을 많이 하여 UI를 개선하고 코드를 잘 리팩토링하는 작업을 했어요. 그런데 개발 과정에서 흥미로운 것들도 몇 가지 있었답니다.</p>\n<h2>계정 아이콘 찾기</h2>\n<p>이건 꽤 좋은 기능이에요. 하지만 최고의 오픈 소스 앱이 똑같은 일을 하길래, 적어도 그것만큼 좋아야 한다고 느꼈어요.</p>\n<p>다행히도, 웹 사이트에서 FavIcon을 검색하고 여러 해상도로 다운로드할 수 있는 Google API가 있답니다.</p>\n<p>웹사이트를 어떻게 디자인하면 좋을지 고민 중이군요. QR 코드의 발행자 속성을 사용하여 .com 도메인을 시도하는 방법으로 좋은 결과를 얻었다고 하셨군요.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">FavIcon</span> {\n\n    <span class=\"hljs-keyword\">let</span> url: <span class=\"hljs-type\">URL</span>\n\n    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">issuer</span>: <span class=\"hljs-type\">String</span>) {\n        <span class=\"hljs-keyword\">let</span> domain <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">\"<span class=\"hljs-subst\">\\(issuer)</span>.com\"</span>\n        <span class=\"hljs-keyword\">let</span> url <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">\"https://www.google.com/s2/favicons?sz=128&#x26;domain=<span class=\"hljs-subst\">\\(domain)</span>\"</span>)<span class=\"hljs-operator\">!</span>\n        <span class=\"hljs-keyword\">self</span>.url <span class=\"hljs-operator\">=</span> url\n    }\n}\n</code></pre>\n<p>아이콘의 빠른 로딩을 위해 CachedAsyncImage 라이브러리를 사용한 거군요. 이렇게 하면 성능이 더 빨라질 거에요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_18.png\" alt=\"이미지\"></p>\n<p>배경 제거를 처리하고 아이콘을 좀 더 돋보이게 만들기 위해 Metal 셰이더를 추가했어요.</p>\n<p>여기 SwiftUI View 확장 부분이에요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//  View+ColorEffect.swift</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">SwiftUI</span>\n\nextension <span class=\"hljs-title class_\">View</span> {\n\n    func <span class=\"hljs-title function_\">eraseBackground</span>(<span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-title class_\">Color</span> = <span class=\"hljs-title class_\">Color</span>(<span class=\"hljs-attr\">uiColor</span>: <span class=\"hljs-title class_\">UIColor</span>.<span class=\"hljs-property\">secondarySystemBackground</span>)) -> some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title function_\">modifier</span>(<span class=\"hljs-title class_\">EraseBackgroundShader</span>(<span class=\"hljs-attr\">backgroundColor</span>: backgroundColor))\n    }\n}\n\nstruct <span class=\"hljs-title class_\">EraseBackgroundShader</span>: <span class=\"hljs-title class_\">ViewModifier</span> {\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">backgroundColor</span>: <span class=\"hljs-title class_\">Color</span>\n\n    func <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-attr\">content</span>: <span class=\"hljs-title class_\">Content</span>) -> some <span class=\"hljs-title class_\">View</span> {\n        content\n            .<span class=\"hljs-title function_\">colorEffect</span>(<span class=\"hljs-title class_\">ShaderLibrary</span>.<span class=\"hljs-title function_\">eraseBackground</span>(\n                .<span class=\"hljs-title function_\">color</span>(backgroundColor)\n            ))\n    }\n}\n</code></pre>\n<p>그리고 물론 MSL 셰이더 코드도 있습니다.</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;metal_stdlib></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;SwiftUI/SwiftUI_Metal.h></span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> metal;\n\n[[ stitchable ]]\n<span class=\"hljs-function\">half4 <span class=\"hljs-title\">eraseBackground</span><span class=\"hljs-params\">(\n    float2 position,\n    half4 color,\n    half4 backgroundColor\n)</span> </span>{\n\n    <span class=\"hljs-keyword\">if</span> (color.r >= <span class=\"hljs-number\">0.95</span> &#x26;&#x26; color.g >= <span class=\"hljs-number\">0.95</span> &#x26;&#x26; color.b >= <span class=\"hljs-number\">0.95</span>) {\n        <span class=\"hljs-keyword\">return</span> backgroundColor;\n    }\n\n    <span class=\"hljs-keyword\">return</span> color;\n}\n</code></pre>\n<p>여기에 그들이 어떻게 보이는지 있어요. 그들은 나쁘지 않지만 놀라운 것은 아니에요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_19.png\" alt=\"image\"></p>\n<p>난 지나치게 엔지니어링을 시작했어. 이것에 핀을 꽂아 놓고 나중에 다시 생각해 봐요.</p>\n<h2>UI 디자인 개선</h2>\n<p>기본 2단계 인증 앱으로서 이미 꽤 잘 작동하고 있습니다.</p>\n<p>대부분의 사람들을 앞선 존재가 되기 위해서는, 극도로 공격적인 유료 벽을 두지 않으면 되는구나 ($4.99 매주? 정말?!)</p>\n<p>일부 기본 소프트웨어 개발 작업을 통해 타이밍, 기본 UI 및 데이터 저장 작업을 수행한 후, 이제는 정말로 아주 잘 작동하고 있습니다. - 기본 SwiftUI 구성 요소를 사용하는 것은 작업이 \"그냥 작동\"되도록하는 빛나는 방법입니다*.</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/1*TUkFn9ejk93WczTL02Jlrg.gif\" alt=\"Image\"></p>\n<p>저는 경쟁사 조사를 통해 찾은 tap-to-copy와 같은 편의 기능 몇 가지를 구현했어요.</p>\n<p>@ScaledMetric와 ViewThatFits 같은 접근성 도구를 활용하여 시각적 요구에 관계없이 앱이 원할하게 작동하도록 했어요. Apple의 기본 SwiftUI 구성 요소와 색상에 밀접하게 따라가면서 무료로 라이트 모드도 구현되었어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// AccountView.swift</span>\n\n@<span class=\"hljs-title class_\">ScaledMetric</span>(<span class=\"hljs-attr\">relativeTo</span>: .<span class=\"hljs-property\">largeTitle</span>) private <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">iconSize</span>: <span class=\"hljs-title class_\">CGFloat</span> = <span class=\"hljs-number\">36</span>\n\nprivate <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">icon</span>: some <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-title class_\">CachedAsyncImage</span>(<span class=\"hljs-attr\">url</span>: <span class=\"hljs-title class_\">FavIcon</span>(<span class=\"hljs-attr\">issuer</span>: account.<span class=\"hljs-property\">issuer</span>).<span class=\"hljs-property\">url</span>, <span class=\"hljs-attr\">content</span>: {\n        $0\n            .<span class=\"hljs-title function_\">resizable</span>()\n            .<span class=\"hljs-title function_\">aspectRatio</span>(<span class=\"hljs-attr\">contentMode</span>: .<span class=\"hljs-property\">fit</span>)\n\n    }, <span class=\"hljs-attr\">placeholder</span>: {\n        <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-title class_\">String</span>(account.<span class=\"hljs-property\">issuer</span>.<span class=\"hljs-property\">first</span>?.<span class=\"hljs-title function_\">uppercased</span>() ?? account.<span class=\"hljs-property\">name</span>.<span class=\"hljs-property\">first</span>?.<span class=\"hljs-title function_\">uppercased</span>() ?? <span class=\"hljs-string\">\"\"</span>))\n            .<span class=\"hljs-title function_\">font</span>(.<span class=\"hljs-property\">largeTitle</span>)\n            .<span class=\"hljs-title function_\">monospaced</span>()\n    })\n    .<span class=\"hljs-title function_\">frame</span>(<span class=\"hljs-attr\">width</span>: iconSize, <span class=\"hljs-attr\">height</span>: iconSize, <span class=\"hljs-attr\">alignment</span>: .<span class=\"hljs-property\">center</span>)\n}\n\nprivate <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">code</span>: some <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-title class_\">ViewThatFits</span> {\n        <span class=\"hljs-title class_\">HStack</span>(<span class=\"hljs-attr\">alignment</span>: .<span class=\"hljs-property\">center</span>, <span class=\"hljs-attr\">spacing</span>: <span class=\"hljs-number\">16</span>) {\n            codeText\n        }\n        <span class=\"hljs-title class_\">VStack</span>(<span class=\"hljs-attr\">alignment</span>: .<span class=\"hljs-property\">leading</span>, <span class=\"hljs-attr\">spacing</span>: <span class=\"hljs-number\">4</span>) {\n            codeText\n        }\n    }\n}\n</code></pre>\n<h2>앱을 더 흥미롭게 만들기</h2>\n<p>진정한 핵심 가치 제안을 개선하기 위해 흥미로운 옵션을 더 많이 구현했습니다:</p>\n<ul>\n<li>000000과 같은 섹스투플렛 및 쿼드투플렛</li>\n<li>012345와 같은 순서대로 계속되는 수열</li>\n<li>300000처럼 백만단위의 수</li>\n<li>000001과 같은 일의 자리, 000010과 같은 십의 자리</li>\n<li>원주율 파이(314159)와 같은 수학 상수</li>\n<li>플랑크 상수(6.6x10⁻³⁴)와 같은 물리 상수</li>\n<li>012210과 같은 회문</li>\n<li>121212와 123123과 같은 반복된 이차, 삼차 수열</li>\n</ul>\n<p>다음은 Markdown 형식으로 표 태그를 변경한 코드입니다.</p>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">checkThatCounting</span>() -> <span class=\"hljs-title class_\">Bool</span> {\n    <span class=\"hljs-keyword\">let</span> characters = <span class=\"hljs-title class_\">Array</span>(self)\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1.</span>.&#x3C;characters.<span class=\"hljs-property\">count</span> {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> prevDigit = <span class=\"hljs-title class_\">Int</span>(<span class=\"hljs-title class_\">String</span>(characters[i - <span class=\"hljs-number\">1</span>])),\n           <span class=\"hljs-keyword\">let</span> currentDigit = <span class=\"hljs-title class_\">Int</span>(<span class=\"hljs-title class_\">String</span>(characters[i])),\n           currentDigit != prevDigit + <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n\nfunc <span class=\"hljs-title function_\">checkThatPalindrome</span>() -> <span class=\"hljs-title class_\">Bool</span> {\n    self == <span class=\"hljs-title class_\">String</span>(self.<span class=\"hljs-title function_\">reversed</span>())\n}\n\nfunc <span class=\"hljs-title function_\">checkThoseRepeatedThrees</span>() -> <span class=\"hljs-title class_\">Bool</span> {\n    self.<span class=\"hljs-title function_\">prefix</span>(<span class=\"hljs-number\">3</span>) == self.<span class=\"hljs-title function_\">suffix</span>(<span class=\"hljs-number\">3</span>)\n}\n\nfunc <span class=\"hljs-title function_\">checkThoseHunderedThousands</span>() -> <span class=\"hljs-title class_\">Bool</span> {\n    <span class=\"hljs-title function_\">suffix</span>(<span class=\"hljs-number\">5</span>) == <span class=\"hljs-string\">\"00000\"</span>\n}\n</code></pre>\n<h2>확률 이론</h2>\n<p>이제 설정 UI를 업데이트하여 흔함, 드물음, 초 희귀함으로 정렬하거나 반복, 상수, 순서 또는 라운드 숫자와 같은 유형으로 정렬할 수 있습니다.</p>\n<p><code>&#x3C;img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_21.png\" /></code></p>\n<p>각 희귀 수준의 확률을 어떻게 계산하나요?</p>\n<p>012345와 같은 완벽한 숫자 시퀀스의 경우, 1백만 개의 가능한 번호 조합 중 6가지만 가능합니다 (567890까지).</p>\n<p>30초에 1백만 개의 조합을 곱하고 가능한 시퀀스인 6으로 나누면, 각 계정당 평균적으로 완벽한 카운팅 시퀀스가 발생할 수 있다는 것은 약 5백만 초마다 발생할 수 있다는 것을 의미합니다 — 평균적으로 58일마다 한 번씩입니다.</p>\n<p>이 정도라니, 정말 희귀한 것이죠.</p>\n<p>하지만 123321과 같은 회문 수는 만들 수 있는 3자리 수가 1000개에 달합니다. 이는 평균적으로 매일 0.34번씩 볼 수 있다는 뜻이에요! 훨씬 더 흔하죠.</p>\n<p>중간에는 141414와 같이 반복되는 숫자들이 있습니다. 이런 경우 가능한 숫자는 00부터 99까지의 100개인데요, 그래서 이들은 평균적으로 3.5일에 한 번씩 발생합니다. 그래서, 정말 희귀하지만, 극도로 희귀하지는 않은 편이에요.</p>\n<p>이 중 일부인 쿼드와 같은 일련 번호들은 조금 더 많은 계산이 필요한데, 그래서 수천만 개의 OTP(일회용 비밀번호)를 생성하고 각 흥미로운 종류별로 발생 빈도를 세어 상대적 빈도를 감을 수 있게 했어요.</p>\n<h2>성능 향상</h2>\n<p>앱은 모든 일반적인 흥미로운 코드를 활성화한 상태에서만 아주 빠르게 64개의 흥미로운 2FA 코드를 처리할 수 있지만, 초희귀한 GET만 원할 때는 처리 시간이 오래 걸립니다.</p>\n<p>수백만 개의 잠재적인 OTP를 처리하는 동안, 유효한 흥미로운 코드를 발견하자마자 알림을 반환하고 예약하는 것이 필요합니다.</p>\n<p>오래된 친구인 Combine 프레임워크는 깔끔한 해결책을 제공해줍니다!</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// CodeGenerator.swift</span>\n\n<span class=\"hljs-keyword\">var</span> codeSubject <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">PassthroughSubject</span>&#x3C;<span class=\"hljs-type\">OTP</span>, <span class=\"hljs-type\">Never</span>>()\n\n<span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">generateCodes</span>(<span class=\"hljs-params\">accounts</span>: [<span class=\"hljs-type\">Account</span>]) {\n    <span class=\"hljs-comment\">// ...</span>\n    codeSubject.send(otp)\n}\n</code></pre>\n<p>또한 사용자가 중간에 설정을 변경하는 경우를 대비하여 작업을 취소하고 다시 시작할 수 있도록 일부 작업을 사용했습니다. 작업을 분리함으로써 암호 해독 및 문자열 분석 작업을 UI 스레드에서 유지하지 않을 수 있습니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// CodeViewModel.swift</span>\n\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> otpComputationTask: <span class=\"hljs-type\">Task</span>&#x3C;<span class=\"hljs-type\">Void</span>, <span class=\"hljs-type\">Never</span>>?\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> notificationSchedulingTask: <span class=\"hljs-type\">Task</span>&#x3C;<span class=\"hljs-type\">Void</span>, <span class=\"hljs-type\">Never</span>>?\n\n<span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">recomputeNotifications</span>() {\n    handleNotificationScheduling()\n    handleOTPComputation()\n}\n\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">handleNotificationScheduling</span>() {\n    notificationSchedulingTask<span class=\"hljs-operator\">?</span>.cancel()\n    notificationSchedulingTask <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Task</span>.detached(priority: .high) {\n        <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-type\">NotificationScheduler</span>.shared.isAuthorized() <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> }\n        <span class=\"hljs-type\">NotificationScheduler</span>.shared.cancelNotifications()\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">await</span> (code, count) <span class=\"hljs-keyword\">in</span> <span class=\"hljs-type\">CodeGenerator</span>.shared.codeSubject.values {\n            <span class=\"hljs-keyword\">try?</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-type\">NotificationScheduler</span>.shared.scheduleNotification(for: code)\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">handleOTPComputation</span>() {\n    <span class=\"hljs-keyword\">let</span> accounts <span class=\"hljs-operator\">=</span> accounts\n    otpComputationTask<span class=\"hljs-operator\">?</span>.cancel()\n    otpComputationTask <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">Task</span>.detached(priority: .high) {\n        <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-type\">NotificationScheduler</span>.shared.isAuthorized() <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> }\n        <span class=\"hljs-type\">CodeGenerator</span>.shared.generateCodes(accounts: accounts)\n    }\n}\n</code></pre>\n<p>이제 일정이 시퀀스대로 아니라 하나의 큰 덩어리로 나오지 않고 꽤 부드럽게 작동합니다!</p>\n<p>Scheduled repeatedTwos: 292929 @ 2024-02-25 23:33:30 +0000\nScheduled repeatedTwos: 878787 @ 2024-02-26 06:03:30 +0000\nScheduled quints: 666660 @ 2024-02-26 10:54:00 +0000\nScheduled quints: 255555 @ 2024-02-26 21:11:00 +0000\nScheduled repeatedTwos: 606060 @ 2024-02-26 23:27:00 +0000\nScheduled sexts: 666666 @ 2024-04-16 23:22:00 +0000\nScheduled boltzmannConstant: 141023 @ 2024-04-19 02:05:00 +0000\nScheduled counting: 012345 @ 2024-04-20 04:51:30 +0000\nScheduled planksConstant: 661034 @ 2024-04-20 05:38:00</p>\n<h2>앱 아이콘</h2>\n<p>이 거래 그냥 사라지고 싶었어요. 앱 아이콘에 진짜로 체크하려면 이제 목멸에 달렸거든요. 정말 완벽해요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_22.png\" alt=\"image\"></p>\n<p>하지만 제 친구가 Lionsgate Films의 친구들이 조금 소송을 제기할 수도 있다고 지적했습니다.</p>\n<p>하지만 난 그걸 가져야 했어!</p>\n<p>어쨌든 희망이 있다면:</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_23.png\" alt=\"이미지\"></p>\n<p>테이블 태그를 마크다운 형식으로 변경하세요.</p>\n<p>그냥 개인정보를 꼭 보호하세요!</p>\n<p>달리(DALL-E)는 정말 손등을 그리는 걸 좋아하지 않았어요. 저는 노력해 봤지만요.</p>\n<h1>마지막 손질</h1>\n<p>그 개념은 증명되었어요. 어플이 잘 작동하고 있어요! Check 'em의 즐거움을 세상에 보여주기 전에 약간의 마무리와 작은 기능을 추가할 시간이에요.</p>\n<p>첫 릴리스를 만들기 전에 V1에서 구현할 수 있는 새로운 기능과 버그 수정 사항들을 목록으로 만들었어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 높은 우선순위 -</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 주문 추가 - 저장된 URL에 쿼리 항목으로 정렬 추가</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 새로 고침 시 햅틱 진동</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 푸시 알림 요청은 설정 화면에 진입했을 때에만</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 알림 활성화를 위한 설정 링크 추가</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시 - 이미 있는 경우 계정에 스캔을 추가하지 않음</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 설정 화면을 열 때 처리 작업 취소</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 푸시 알림 딥 링크 - GET이 여전히 존재할 때 앱 리뷰 프롬프트로 이동</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 매우 드문 GET가 전송되지 않는 것 같음?? 시뮬레이터에서 로컬로 발생하지 않지만 quints는 괜찮음 - 큐에 들어가는 것처럼 보임</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 버그 - 두 번째 로드에서 진행 상황 보기가 나타나지 않음</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시 - 이미 있는 경우 계정에 스캔을 추가하지 않음</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 버그 - 2개의 동시 계산이 있을 때 백분율이 계속 변동하는 버그 발생</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - QR 및 설정에 TipKit 추가</span>\n\n<span class=\"hljs-comment\">// 낮은 우선순위 -</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 상태 복원을 위해 @SceneStorage 사용 - 키패인 작업을 기다리지 않아도 되도록</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 한 단계 또는 뒤로 이동</span>\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 딥 링크를 사용하여 \"컬렉션\" 화면 생성 - 보관된 항목으로 본 GET 수집 (키패인의 사전으로)</span>\n</code></pre>\n<p>당연히, 제게 제품 관리자가 없기 때문에 최저 우선 순위의 작업을 즉시 시작했습니다: 딥 링크로 컬렉션을 구축하는 것 - 내 드문 GET가 헛되이 낭비되는 것을 원하지 않아요!</p>\n<h2>컬렉션</h2>\n<p>이 부분은 원본 개념 증명에서 식별한 문제에 도움이 됩니다: 사용자들이 알림과 상호 작용하도록 유도하여 앱에 재진입하도록 해야합니다.</p>\n<p>컬렉션 뷰를 만드는 것은 조금 까다로울 수 있어요. 왜냐하면 몇 가지 부분을 고려해야 되거든요:</p>\n<ul>\n<li>사용자가 알림을 탭하고 앱으로 딥 링크 할 수 있게 합니다.</li>\n<li>탭한 코드의 흥미로운 부분을 안전하게 저장합니다.</li>\n<li>이것들을 컬렉션 화면에 렌더링합니다.</li>\n</ul>\n<p>알림에 딥 링크를 추가하는 것은 꽤 간단했어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Notifications.swift</span>\n\n<span class=\"hljs-comment\">// ...</span>\ncontent.<span class=\"hljs-property\">userInfo</span> = [<span class=\"hljs-string\">\"deepLink\"</span>: <span class=\"hljs-string\">\"checkem://\\(otp.code)\"</span>]\n</code></pre>\n<p>그러나 약간 거슬리지만, 알림을 처리하기 위해 AppDelegate를 만들어야 했어요 — SwiftUI는 아직 완전히 자체적으로 이를 다루지 못합니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// AppDelegate.swift</span>\n\n<span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">userNotificationCenter</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">center</span>: <span class=\"hljs-type\">UNUserNotificationCenter</span>,\n                            <span class=\"hljs-params\">didReceive</span> <span class=\"hljs-params\">response</span>: <span class=\"hljs-type\">UNNotificationResponse</span>,\n                            <span class=\"hljs-params\">withCompletionHandler</span> <span class=\"hljs-params\">completionHandler</span>: <span class=\"hljs-keyword\">@escaping</span> () -> <span class=\"hljs-type\">Void</span>) {\n\n    <span class=\"hljs-keyword\">let</span> userInfo <span class=\"hljs-operator\">=</span> response.notification.request.content.userInfo\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> deepLinkString <span class=\"hljs-operator\">=</span> userInfo[<span class=\"hljs-string\">\"deepLink\"</span>] <span class=\"hljs-keyword\">as?</span> <span class=\"hljs-type\">String</span>,\n       <span class=\"hljs-keyword\">let</span> deepLinkURL <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">URL</span>(string: deepLinkString) {\n        <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> code <span class=\"hljs-operator\">=</span> deepLinkURL.code <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> }\n        <span class=\"hljs-keyword\">try?</span> <span class=\"hljs-type\">CollectionManager</span>.shared.save(code: code)\n    }\n\n    completionHandler()\n}\n</code></pre>\n<p>마지막으로, Keychain에 저장된 코드들의 긴 쉼표로 구분된 목록을 게으르게 추가했어요.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// KeychainManager.swift</span>\n\n<span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">storeCollectionItem</span>(<span class=\"hljs-params\">code</span>: <span class=\"hljs-type\">String</span>) <span class=\"hljs-keyword\">throws</span> {\n    <span class=\"hljs-keyword\">var</span> collection <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">try</span> keychain.get(<span class=\"hljs-type\">Constants</span>.collectionKey) <span class=\"hljs-operator\">??</span> <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-operator\">!</span>collection.isEmpty {\n        collection.append(<span class=\"hljs-string\">\",\"</span>)\n    }\n    collection.append(code)\n    <span class=\"hljs-keyword\">try</span> keychain.set(collection, key: <span class=\"hljs-type\">Constants</span>.collectionKey)\n}\n</code></pre>\n<p>빠르게 출시하기 위한 욕망의 결과인 것이지, 신중하게 고려된 엔지니어링 결정의 결과는 아닙니다. 사용자가 Keychain 항목 당 4kB의 소프트 제한에 가까워지는 경우 후회할 수 있는 결정이었습니다(하드 제한은 대략 16MB 이므로 괜찮을 것 같아요!).</p>\n<p>이 작업은 빠르게 성과를 거두었는데, 컬렉션 화면은 빠르게 내 소중한 GET들로 가득 차기 시작했어요!</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_27.png\" alt=\"이미지\"></p>\n<p>원래는 사용자가 알림을 탭할 때까지 컬렉션을 숨겼었는데, 사용자가 '모두 수집하기'에 도전하도록 하는 것이 더 매력적이라고 깨달았어요.</p>\n<h2>진동</h2>\n<p>iOS 17 sensoryFeedback API를 사용하면 매우 섬세한 진동을 재생할 수 있습니다. 사실 너무 섬세해서 저는 마음에 들지 않았어요. 그래서 Carbn에서 진동 엔진을 뽑아내어 여기에 재사용했어요.</p>\n<p>기존 새로고침 코드에 정말 가혹한 부작용을 추가했어요:</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// CodeView.swift</span>\n\n.onReceive(timer) { <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-keyword\">let</span> didChange <span class=\"hljs-operator\">=</span> viewModel.refresh()\n    <span class=\"hljs-keyword\">if</span> didChange {\n        <span class=\"hljs-type\">HapticEngine</span>.shared.play(haptic: .refresh)\n    }\n}\n</code></pre>\n<p>집에서는 시도하지 마세요, 친구들!</p>\n<h2>이미지 로딩 버그</h2>\n<p>CachedAsyncImage 라이브러리에서 FavIcons가 존재하지 않음에도 불구하고 열심히 로딩되는 버그가 있습니다. 이로 인해 희미한 지구 모양이 나타납니다... 하지만 이대로 릴리스할 것 같습니다.</p>\n<p>대부분의 경우 90% 정도는 잘 작동하며, 제가 개발한 Third-party SwiftUI 라이브러리 중 하나를 바꾸는 대신 배포하는 게 더 좋을 것 같아요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_29.png\" alt=\"이미지\"></p>\n<h2>중복 버그</h2>\n<p>배포 전에 나머지 버그들 중 일부는 더 주의 깊게 살펴보았지만, 이 문제는 특히 나쁩니다. 누군가가 QR 코드를 두 번 스캔하면 동일한 계정의 이상한 중복이 발생할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시하도록 해주세요 - 이미 있는 경우 계정에 스캔을 추가하지 마세요</span>\n</code></pre>\n<p>시간을 절약할 수 있는 라이브러리를 뜯어내고 교체하는 대신, 이 버그는 한 줄의 코드 수정으로 해결되었습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// CodeViewModel.swift</span>\n\nfunc <span class=\"hljs-title function_\">create</span>(<span class=\"hljs-attr\">account</span>: <span class=\"hljs-title class_\">Account</span>, <span class=\"hljs-attr\">url</span>: <span class=\"hljs-variable constant_\">URL</span>) throws {\n    guard !accounts.<span class=\"hljs-title function_\">contains</span>(<span class=\"hljs-attr\">where</span>: { $0.<span class=\"hljs-property\">name</span> == account.<span class=\"hljs-property\">name</span> }) <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> }\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>2FA 계정을 이름을 기준으로 하는 키체인이기 때문에, 이 수정은 매우 합리적입니다.</p>\n<h2>코드가 로드되지 않음</h2>\n<p>코드가 대기열에 들어가지 않는 다른 문제를 발견했어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> - 초희귀한 GET가 전송되지 않나요?? 에뮬레이터에서 로컬에서 발생시키질 못하겠는데 퀸트는 잘 됩니다 - 들어가야 할 것 같아요</span>\n</code></pre>\n<p>알고 보니 @AppStorage가 실제로 작동하는 방식을 잘못 이해했던 것 같아요 — 기본값은 실제로 사용자 기본 설정에 저장하는 대신 UI에만 적용됩니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// SettingsView.swift</span>\n\n<span class=\"hljs-meta\">@AppStorage</span>(<span class=\"hljs-string\">\"sexts\"</span>) <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">var</span> sexts: <span class=\"hljs-type\">Bool</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>\n</code></pre>\n<p>첫 번째 앱 로드 시 UserDefaults를 채우는 함수가 이 문제를 해결했습니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// CheckEmApp.swift</span>\n\n<span class=\"hljs-keyword\">@main</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CheckEmApp</span>: <span class=\"hljs-title class_\">App</span> {\n\n    <span class=\"hljs-keyword\">init</span>() {\n        initializeDefaultsIfRequired()\n    }\n\n    <span class=\"hljs-comment\">// ...</span>\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">initializeDefaultsIfRequired</span>() {\n        <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-type\">UserDefaults</span>.standard.object(forKey: <span class=\"hljs-string\">\"sexts\"</span>) <span class=\"hljs-operator\">==</span> <span class=\"hljs-literal\">nil</span> <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> }\n        <span class=\"hljs-type\">CodeGenerator</span>.shared.initializeDefaults()\n    }\n</code></pre>\n<h2>TipKit</h2>\n<p>새로운 iOS 17 TipKit를 사용하여 조금 더 개선했어요. 사용자가 앱을 처음 로드할 때 무엇을 해야 하는지 간단히 이해할 수 있게 도와주는 기능이 추가되었답니다.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_30.png\" alt=\"app screenshot\"></p>\n<p>이 새로운 API로 구현하는 것이 의외로 간단했어요.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// CodeView.swift</span>\n\n@<span class=\"hljs-title class_\">ViewBuilder</span>\nprivate <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">tips</span>: some <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-title class_\">TipView</span>(<span class=\"hljs-title class_\">QRTip</span>()).<span class=\"hljs-title function_\">tipImageSize</span>(<span class=\"hljs-title class_\">CGSize</span>(<span class=\"hljs-attr\">width</span>: tipImageSize, <span class=\"hljs-attr\">height</span>: tipImageSize))\n    <span class=\"hljs-title class_\">TipView</span>(<span class=\"hljs-title class_\">SettingsTip</span>()).<span class=\"hljs-title function_\">tipImageSize</span>(<span class=\"hljs-title class_\">CGSize</span>(<span class=\"hljs-attr\">width</span>: tipImageSize, <span class=\"hljs-attr\">height</span>: tipImageSize))\n    <span class=\"hljs-title class_\">TipView</span>(<span class=\"hljs-title class_\">CollectionTip</span>()).<span class=\"hljs-title function_\">tipImageSize</span>(<span class=\"hljs-title class_\">CGSize</span>(<span class=\"hljs-attr\">width</span>: tipImageSize, <span class=\"hljs-attr\">height</span>: tipImageSize))\n}\n</code></pre>\n<h2>상점 상품 목록</h2>\n<p>출시할 준비가 끝났다고 생각해요.</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_31.png\" alt=\"상품 목록\"></p>\n<p>AppScreens를 통해 상점 상품 목록을 설정 중이에요. 저희의 캣츠가 등장하는 Check 'em의 진정한 힘을 보여주는 두 번째 스크린샷을 확인해보세요.</p>\n<hr>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_32.png\" alt=\"이미지\"></p>\n<p>진짜요?</p>\n<p><img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_33.png\" alt=\"이미지\"></p>\n<p>알겠어요, 제가 세계에서 가장 자유주의자적인 사람은 아니지만, 시장을 1% 증가시키기 위해 여러 가지 번거로움을 겪는 건 싫어요. 좀 더 나은 방법이 있지 않을까요!</p>\n<p>(내 프랑스 독자 여러분 죄송해요)</p>\n<p>간단히 말해서, 우리는 앱 스토어 커넥트에 설정을 완료했고 버튼을 누르기 ready해요!</p>\n<h2>결론</h2>\n<p>저의 여정을 따라 읽어주셔서 감사합니다!</p>\n<p>이 프로젝트는 정말 재미있었어요! 패턴을 찾는 것을 좋아하는 내 내재적인 IT 열정을 만졌을 뿐만 아니라, 멋진 처리, 스레딩, 최적화 문제를 다루어 볼 수 있었어요!</p>\n<p>다음 단계로, v1.1 릴리스에 대한 성능에 완전히 초점을 맞춘 상태입니다. 이제 OTP(일회용 암호)를 더 빠르게 처리하고 빠르게 불러올 거예요!</p>\n<p>이 앱을 좋아하시면, 보고 싶은 숫자에 대한 의견을 주세요! 마지막으로, Android 버전을 원하는 분들이 계신다면, 제 소스 코드를 공유해드리고 함께 개발할 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}