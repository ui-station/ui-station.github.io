{"pageProps":{"post":{"title":"SwfitUI 네비게이션 - 코디네이터 패턴 2부 -  경고 ","description":"","date":"2024-05-20 16:08","slug":"2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert","content":"\n\n<img src=\"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png\" />\n\n만약 Part 1을 아직 읽지 않았다면 여기에서 찾아볼 수 있어요. 이 글은 이전 글의 연장선입니다.\n\nPart 1에서는 네비게이션 라우팅 로직을 coordinators로 격리시켰습니다. 이를 통해 앱을 위한 확장 가능하고 모듈식 네비게이션 설정을 만들었습니다. 하지만 이것은 기본에 불과해요. SwiftUI에서는 navigationPath로 push하는 것 이외에도 더 많은 종류의 네비게이션이 있어요. 이 중 하나는 \"네비게이션\"으로 팝업 알람을 표시하는 것이죠.\n\n오늘은 이 주제에 대해 이야기할 거에요.\n\n<div class=\"content-ad\"></div>\n\nSwiftUI에서는 다양한 수정자(modifier)를 제공하여 Alert를 표시할 수 있습니다. 일반적으로 이러한 Alert 수정자는 뷰(View)에 설정되며, ViewModel/View에는 Alert를 표시할지 여부를 결정하는 데 사용되는 Binding`Bool`이 있습니다. 이 논리는 저에게는 좀 더 화면에 적합하게 표현되도록 조정되어야 한다고 생각합니다. 그렇다면 그에 대비할 방법을 찾아봅시다.\n\nAlert에는 다양한 기능이 있을 수 있습니다. 타이틀, 메시지, 한 개 또는 두 개 이상의 버튼(primaryAction, cancelAction)이 포함될 수 있으며, 이러한 버튼은 .destructive 역할을 갖는 등 다양한 역할을 할 수 있습니다. 이는 시스템이 설계된 방식의 일부이며 그것이 예상대로 작동할 것으로 예상됩니다. 그래서 모든 이러한 경우의 Alert를 표시하는 데 필요한 정보를 제공하기 위한 프로토콜을 생성해 봅시다.\n\n```js\nimport SwiftUI\n\nprotocol AlertDisplayable { \n    var title: String { get }\n    var message: String? { get }\n    var buttons: [AlertButton] { get }\n}\n\nstruct AlertButton {\n    let title: String\n    let role: ButtonRole?\n    let action: () -> Void\n\n    private init(title: String, role: ButtonRole?, action: @escaping () -> Void) {\n        self.title = title\n        self.role = role\n        self.action = action\n    }\n    \n    static func actionButton(title: String, action: @escaping () -> Void) -> Self {\n        AlertButton(title: title, role: nil, action: action)\n    }\n\n    static func cancelButton(title: String, action: @escaping () -> Void) -> Self {\n        AlertButton(title: title, role: .cancel, action: action)\n    }\n\n    static func destructiveButton(title: String, action: @escaping () -> Void) -> Self {\n        AlertButton(title: title, role: .destructive, action: action)\n    }\n}\n```\n\n이제 part 1에서 생성한 NavigationController에 다음을 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\n@Observable final class NavigationController {\n    var navigationPath = NavigationPath()\n    var alertPath = AlertPath()\n\n    func presentAlert<T>(_ alert: T) where T: AlertDisplayable {\n        alertPath.setAlert(alert)\n    }\n}\n```\n\n일관성을 유지하기 위해 ****Path 규칙을 따르고 있지만 원하는 대로 이름을 지정할 수 있습니다.\n\n```swift\nimport SwiftUI\n\nstruct AlertPath {\n\n    var alert: AlertDisplayable?\n\n    mutating func setAlert<T>(_ alert: T) where T: AlertDisplayable {\n        self.alert = alert\n    }\n}\n```\n\n또한 설정한 후 경고를 처리하는 CoordinatedView를 업데이트해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nstruct CoordinatedView<C: Coordinator>: View {\n    private let coordinator: C\n\n    init(_ coordinator: C) {\n        self.coordinator = coordinator\n    }\n\n    var body: some View {\n        @Bindable var navigationController = coordinator.navigationController\n        NavigationStack(path: $navigationController.navigationPath) {\n            coordinator.rootView\n        }\n        .alert(for: $navigationController.alertPath) // <-- Here we add a new viewModifier\n    }\n}\n```\n\n이 alert modifier는 alertPath의 바인딩을 받아 설정된 알림이 있을 경우 알림을 표시하는 사용자 정의 ViewModifier입니다.\n\n```swift\nextension View {\n    func alert(for alertPath: Binding<AlertPath>) -> some View {\n        self.modifier(AlertModifier(alertPath: alertPath))\n    }\n}\n\nstruct AlertModifier: ViewModifier {\n\n    @Binding var alertPath: AlertPath\n\n    init(alertPath: Binding<AlertPath>) {\n        self._alertPath = alertPath\n    }\n\n    func body(content: Content) -> some View {\n        content\n            .alert(\n                alertPath.alert?.title ?? \"\",\n                isPresented: Binding(get: { alertPath.alert != nil }, set: { _ in alertPath.alert = nil }),\n                actions: {\n                    if let buttons = alertPath.alert?.buttons {\n                        ForEach(buttons) { button in\n                            Button(button.title, role: button.role, action: button.action)\n                        }\n                    }\n\n                }, message: {\n                    if let message = alertPath.alert?.message {\n                        Text(message)\n                    }\n                })\n    }\n}\n```\n\n- 알림의 제목은 title 속성에서 가져옵니다.\n- alertPath의 존재 여부에 따라 수동으로 getter 및 setter를 설정한 Binding`Bool`를 전달합니다. 따라서 alert가 존재하는 경우 알림을 표시합니다. 그리고 알림이 닫힐 때 alert를 nil로 설정합니다.\n- 사용 가능한 각 버튼에 대해 제공된 title, role 및 action으로 SwiftUI Button을 만듭니다. 버튼을 하나도 보내지 않으면 시스템이 단일 'OK' 버튼 알림으로 기본 설정됩니다.\n- 필요에 따라 알림 아래에 제목 아래에 알림에 대한 일부 설명 정보가 포함될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n한 번 시도해 보고 실제로 잘 작동하는지 확인해 봅시다. 알림 유형을 생성해 보겠습니다.\n\n```js\n// 비슷한 알림을 그룹화하거나 케이스별 알림을 만들고 싶다면 emum을 생성할 수 있습니다.\nenum SomeAlert: AlertDisplayable {\n    case alert(buttons: [AlertButton]) // <-- 액션을 주입합니다\n    case alertWithTitleAndMessage(buttons: [AlertButton])\n\n    var title: String {\n        switch self {\n        case .alert:                        return \"제목만 있는 알림\"\n        case .alertWithTitleAndMessage:     return \"제목과 메시지가 있는 알림\"\n        }\n    }\n\n    var message: String? {\n        switch self {\n        case .alert:                    return nil\n        case .alertWithTitleAndMessage: return \"이것은 메시지입니다\"\n        }\n    }\n\n    var buttons: [AlertButton] {\n        switch self {\n        case .alert(let buttons),\n             .alertWithTitleAndMessage(let buttons):    return buttons\n        }\n    }\n}\n\n// 또는\n// 알림을 따로 모델로 사용하고 싶다면 하드코딩된 값들을 가진 구조체를 만들 수 있습니다.\nstruct SomeSpecificAlertType: AlertDisplayable {\n    var title: String = \"특정 알림 제목\"\n    var message: String? = \"특정 메시지\"\n    var buttons: [AlertButton]\n\n    init(onAction: () -> Void, onCancel: () -> Void) { // <- 액션을 주입하고 해당 액션을 처리합니다\n      self.buttons = [\n          .actionButton(title: \"두 번째 작업\", action: onAction),\n          .cancelButton(title: \"취소\", action: onCancel)\n      ]\n    }\n}\n```\n\n알 수 있듯이, enum 케이스별로 Alert 유형을 생성하고 비슷한 알림 유형을 하나의 개체로 그룹화할 수 있습니다. 예를 들어, 모든 권한 알림을 한 곳에 유지하고 싶다면, 개별 알림 구조체/객체로 만들거나 선택은 여러분의 몫입니다. 중요한 점은 처음에 생성한 AlertDisplayable 프로토콜을 준수하는지입니다. 이제 모바일 앱에서 구현이 어떻게 보일지 살펴보겠습니다.\n\n```js\nstruct FirstView: View {\n    let viewModel: FirstViewModel\n\n    var body: some View {\n        VStack {\n            Text(\"첫 번째 화면\")\n            Button(\"알림 표시\") {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n@Observable class FirstViewModel {\n    let coordinator: FirstCoordinator\n\n    init(coordinator: FirstCoordinator) {\n        self.coordinator = coordinator\n    }\n\n    func didTapButton() {\n        coordinator.presentAlert(\n                SomeAlert.alert(buttons: [\n                    .actionButton(title: \"주요 작업\") {\n                        print(\"작업 버튼 누름\") // <- 버튼 클릭 시 호출되는 클로저 \n                    },\n                    .cancelButton(title: \"취소\") {\n                        print(\"취소 버튼 누름\") // <- 버튼 클릭 시 호출되는 클로저 \n                    }\n                ]))\n    }\n}\n\n@Observable final class FirstCoordinator: Coordinator {\n    typealias Route = FirstCoordinatorRoute\n\n    let navigationController: NavigationController\n\n    @MainActor @ViewBuilder var rootView: some View {\n        FirstView(FirstViewModel(self)).navigationDestination(for: Route.self, destination: coordinate(_:))\n    }\n\n    func presentAlert<T>(_ alert: T) where T: AlertDisplayable {\n        navigationController.presentAlert(alert)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이는 viewModel에서 프로그래밍 방식으로 알림을 표시할 수 있게 해주며, 사용자가 버튼을 클릭할 때 viewModel이 선택적으로 콜백을 처리할 수 있게 합니다. 이 경우 뷰 자체 \"FirstView\"는 무엇이 일어나는지 전혀 모릅니다. 알고 있는 것은 didTapButton뿐입니다.\n\n![image](/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_1.png)\n\n부분 2에 대한 내용은 여기까지입니다.\n\n이 내용이 유용하다고 생각되면 좋겠습니다. 피드백이나 개선 제안이 있으면 알려주세요. 이 글이 유익했다면 공유해 주세요!\n\n<div class=\"content-ad\"></div>\n\n좋은 하루 보내세요!","ogImage":{"url":"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png"},"coverImage":"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>만약 Part 1을 아직 읽지 않았다면 여기에서 찾아볼 수 있어요. 이 글은 이전 글의 연장선입니다.</p>\n<p>Part 1에서는 네비게이션 라우팅 로직을 coordinators로 격리시켰습니다. 이를 통해 앱을 위한 확장 가능하고 모듈식 네비게이션 설정을 만들었습니다. 하지만 이것은 기본에 불과해요. SwiftUI에서는 navigationPath로 push하는 것 이외에도 더 많은 종류의 네비게이션이 있어요. 이 중 하나는 \"네비게이션\"으로 팝업 알람을 표시하는 것이죠.</p>\n<p>오늘은 이 주제에 대해 이야기할 거에요.</p>\n<p>SwiftUI에서는 다양한 수정자(modifier)를 제공하여 Alert를 표시할 수 있습니다. 일반적으로 이러한 Alert 수정자는 뷰(View)에 설정되며, ViewModel/View에는 Alert를 표시할지 여부를 결정하는 데 사용되는 Binding<code>Bool</code>이 있습니다. 이 논리는 저에게는 좀 더 화면에 적합하게 표현되도록 조정되어야 한다고 생각합니다. 그렇다면 그에 대비할 방법을 찾아봅시다.</p>\n<p>Alert에는 다양한 기능이 있을 수 있습니다. 타이틀, 메시지, 한 개 또는 두 개 이상의 버튼(primaryAction, cancelAction)이 포함될 수 있으며, 이러한 버튼은 .destructive 역할을 갖는 등 다양한 역할을 할 수 있습니다. 이는 시스템이 설계된 방식의 일부이며 그것이 예상대로 작동할 것으로 예상됩니다. 그래서 모든 이러한 경우의 Alert를 표시하는 데 필요한 정보를 제공하기 위한 프로토콜을 생성해 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">SwiftUI</span>\n\nprotocol <span class=\"hljs-title class_\">AlertDisplayable</span> { \n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span> { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">message</span>: <span class=\"hljs-title class_\">String</span>? { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">buttons</span>: [<span class=\"hljs-title class_\">AlertButton</span>] { get }\n}\n\nstruct <span class=\"hljs-title class_\">AlertButton</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">role</span>: <span class=\"hljs-title class_\">ButtonRole</span>?\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">action</span>: () -> <span class=\"hljs-title class_\">Void</span>\n\n    private <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">title: <span class=\"hljs-built_in\">String</span>, role: ButtonRole?, action: @escaping () -> Void</span>) {\n        self.<span class=\"hljs-property\">title</span> = title\n        self.<span class=\"hljs-property\">role</span> = role\n        self.<span class=\"hljs-property\">action</span> = action\n    }\n    \n    <span class=\"hljs-keyword\">static</span> func <span class=\"hljs-title function_\">actionButton</span>(<span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">action</span>: @escaping () -> <span class=\"hljs-title class_\">Void</span>) -> <span class=\"hljs-title class_\">Self</span> {\n        <span class=\"hljs-title class_\">AlertButton</span>(<span class=\"hljs-attr\">title</span>: title, <span class=\"hljs-attr\">role</span>: nil, <span class=\"hljs-attr\">action</span>: action)\n    }\n\n    <span class=\"hljs-keyword\">static</span> func <span class=\"hljs-title function_\">cancelButton</span>(<span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">action</span>: @escaping () -> <span class=\"hljs-title class_\">Void</span>) -> <span class=\"hljs-title class_\">Self</span> {\n        <span class=\"hljs-title class_\">AlertButton</span>(<span class=\"hljs-attr\">title</span>: title, <span class=\"hljs-attr\">role</span>: .<span class=\"hljs-property\">cancel</span>, <span class=\"hljs-attr\">action</span>: action)\n    }\n\n    <span class=\"hljs-keyword\">static</span> func <span class=\"hljs-title function_\">destructiveButton</span>(<span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">action</span>: @escaping () -> <span class=\"hljs-title class_\">Void</span>) -> <span class=\"hljs-title class_\">Self</span> {\n        <span class=\"hljs-title class_\">AlertButton</span>(<span class=\"hljs-attr\">title</span>: title, <span class=\"hljs-attr\">role</span>: .<span class=\"hljs-property\">destructive</span>, <span class=\"hljs-attr\">action</span>: action)\n    }\n}\n</code></pre>\n<p>이제 part 1에서 생성한 NavigationController에 다음을 추가할 수 있습니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-meta\">@Observable</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NavigationController</span> {\n    <span class=\"hljs-keyword\">var</span> navigationPath <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">NavigationPath</span>()\n    <span class=\"hljs-keyword\">var</span> alertPath <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">AlertPath</span>()\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">presentAlert</span>&#x3C;<span class=\"hljs-type\">T</span>>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">alert</span>: <span class=\"hljs-type\">T</span>) <span class=\"hljs-keyword\">where</span> <span class=\"hljs-type\">T</span>: <span class=\"hljs-type\">AlertDisplayable</span> {\n        alertPath.setAlert(alert)\n    }\n}\n</code></pre>\n<p>일관성을 유지하기 위해 ****Path 규칙을 따르고 있지만 원하는 대로 이름을 지정할 수 있습니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> SwiftUI\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">AlertPath</span> {\n\n    <span class=\"hljs-keyword\">var</span> alert: <span class=\"hljs-type\">AlertDisplayable</span>?\n\n    <span class=\"hljs-keyword\">mutating</span> <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">setAlert</span>&#x3C;<span class=\"hljs-type\">T</span>>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">alert</span>: <span class=\"hljs-type\">T</span>) <span class=\"hljs-keyword\">where</span> <span class=\"hljs-type\">T</span>: <span class=\"hljs-type\">AlertDisplayable</span> {\n        <span class=\"hljs-keyword\">self</span>.alert <span class=\"hljs-operator\">=</span> alert\n    }\n}\n</code></pre>\n<p>또한 설정한 후 경고를 처리하는 CoordinatedView를 업데이트해야 합니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">CoordinatedView</span>&#x3C;<span class=\"hljs-title class_\">C</span>: <span class=\"hljs-title class_\">Coordinator</span>>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">let</span> coordinator: <span class=\"hljs-type\">C</span>\n\n    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-keyword\">_</span> <span class=\"hljs-params\">coordinator</span>: <span class=\"hljs-type\">C</span>) {\n        <span class=\"hljs-keyword\">self</span>.coordinator <span class=\"hljs-operator\">=</span> coordinator\n    }\n\n    <span class=\"hljs-keyword\">var</span> body: <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        <span class=\"hljs-meta\">@Bindable</span> <span class=\"hljs-keyword\">var</span> navigationController <span class=\"hljs-operator\">=</span> coordinator.navigationController\n        <span class=\"hljs-type\">NavigationStack</span>(path: <span class=\"hljs-variable\">$navigationController</span>.navigationPath) {\n            coordinator.rootView\n        }\n        .alert(for: <span class=\"hljs-variable\">$navigationController</span>.alertPath) <span class=\"hljs-comment\">// &#x3C;-- Here we add a new viewModifier</span>\n    }\n}\n</code></pre>\n<p>이 alert modifier는 alertPath의 바인딩을 받아 설정된 알림이 있을 경우 알림을 표시하는 사용자 정의 ViewModifier입니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-params\">for</span> <span class=\"hljs-params\">alertPath</span>: <span class=\"hljs-type\">Binding</span>&#x3C;<span class=\"hljs-type\">AlertPath</span>>) -> <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        <span class=\"hljs-keyword\">self</span>.modifier(<span class=\"hljs-type\">AlertModifier</span>(alertPath: alertPath))\n    }\n}\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">AlertModifier</span>: <span class=\"hljs-title class_\">ViewModifier</span> {\n\n    <span class=\"hljs-meta\">@Binding</span> <span class=\"hljs-keyword\">var</span> alertPath: <span class=\"hljs-type\">AlertPath</span>\n\n    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">alertPath</span>: <span class=\"hljs-type\">Binding</span>&#x3C;<span class=\"hljs-type\">AlertPath</span>>) {\n        <span class=\"hljs-keyword\">self</span>._alertPath <span class=\"hljs-operator\">=</span> alertPath\n    }\n\n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">body</span>(<span class=\"hljs-params\">content</span>: <span class=\"hljs-type\">Content</span>) -> <span class=\"hljs-keyword\">some</span> <span class=\"hljs-type\">View</span> {\n        content\n            .alert(\n                alertPath.alert<span class=\"hljs-operator\">?</span>.title <span class=\"hljs-operator\">??</span> <span class=\"hljs-string\">\"\"</span>,\n                isPresented: <span class=\"hljs-type\">Binding</span>(get: { alertPath.alert <span class=\"hljs-operator\">!=</span> <span class=\"hljs-literal\">nil</span> }, set: { <span class=\"hljs-keyword\">_</span> <span class=\"hljs-keyword\">in</span> alertPath.alert <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">nil</span> }),\n                actions: {\n                    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> buttons <span class=\"hljs-operator\">=</span> alertPath.alert<span class=\"hljs-operator\">?</span>.buttons {\n                        <span class=\"hljs-type\">ForEach</span>(buttons) { button <span class=\"hljs-keyword\">in</span>\n                            <span class=\"hljs-type\">Button</span>(button.title, role: button.role, action: button.action)\n                        }\n                    }\n\n                }, message: {\n                    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> message <span class=\"hljs-operator\">=</span> alertPath.alert<span class=\"hljs-operator\">?</span>.message {\n                        <span class=\"hljs-type\">Text</span>(message)\n                    }\n                })\n    }\n}\n</code></pre>\n<ul>\n<li>알림의 제목은 title 속성에서 가져옵니다.</li>\n<li>alertPath의 존재 여부에 따라 수동으로 getter 및 setter를 설정한 Binding<code>Bool</code>를 전달합니다. 따라서 alert가 존재하는 경우 알림을 표시합니다. 그리고 알림이 닫힐 때 alert를 nil로 설정합니다.</li>\n<li>사용 가능한 각 버튼에 대해 제공된 title, role 및 action으로 SwiftUI Button을 만듭니다. 버튼을 하나도 보내지 않으면 시스템이 단일 'OK' 버튼 알림으로 기본 설정됩니다.</li>\n<li>필요에 따라 알림 아래에 제목 아래에 알림에 대한 일부 설명 정보가 포함될 수 있습니다.</li>\n</ul>\n<p>한 번 시도해 보고 실제로 잘 작동하는지 확인해 봅시다. 알림 유형을 생성해 보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 비슷한 알림을 그룹화하거나 케이스별 알림을 만들고 싶다면 emum을 생성할 수 있습니다.</span>\nenum <span class=\"hljs-title class_\">SomeAlert</span>: <span class=\"hljs-title class_\">AlertDisplayable</span> {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-attr\">buttons</span>: [<span class=\"hljs-title class_\">AlertButton</span>]) <span class=\"hljs-comment\">// &#x3C;-- 액션을 주입합니다</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">alertWithTitleAndMessage</span>(<span class=\"hljs-attr\">buttons</span>: [<span class=\"hljs-title class_\">AlertButton</span>])\n\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-keyword\">switch</span> self {\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">alert</span>:                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"제목만 있는 알림\"</span>\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">alertWithTitleAndMessage</span>:     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"제목과 메시지가 있는 알림\"</span>\n        }\n    }\n\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">message</span>: <span class=\"hljs-title class_\">String</span>? {\n        <span class=\"hljs-keyword\">switch</span> self {\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">alert</span>:                    <span class=\"hljs-keyword\">return</span> nil\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">alertWithTitleAndMessage</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"이것은 메시지입니다\"</span>\n        }\n    }\n\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">buttons</span>: [<span class=\"hljs-title class_\">AlertButton</span>] {\n        <span class=\"hljs-keyword\">switch</span> self {\n        <span class=\"hljs-keyword\">case</span> .<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-keyword\">let</span> buttons),\n             .<span class=\"hljs-title function_\">alertWithTitleAndMessage</span>(<span class=\"hljs-keyword\">let</span> buttons):    <span class=\"hljs-keyword\">return</span> buttons\n        }\n    }\n}\n\n<span class=\"hljs-comment\">// 또는</span>\n<span class=\"hljs-comment\">// 알림을 따로 모델로 사용하고 싶다면 하드코딩된 값들을 가진 구조체를 만들 수 있습니다.</span>\nstruct <span class=\"hljs-title class_\">SomeSpecificAlertType</span>: <span class=\"hljs-title class_\">AlertDisplayable</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">title</span>: <span class=\"hljs-title class_\">String</span> = <span class=\"hljs-string\">\"특정 알림 제목\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">message</span>: <span class=\"hljs-title class_\">String</span>? = <span class=\"hljs-string\">\"특정 메시지\"</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">buttons</span>: [<span class=\"hljs-title class_\">AlertButton</span>]\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">onAction: () -> Void, onCancel: () -> Void</span>) { <span class=\"hljs-comment\">// &#x3C;- 액션을 주입하고 해당 액션을 처리합니다</span>\n      self.<span class=\"hljs-property\">buttons</span> = [\n          .<span class=\"hljs-title function_\">actionButton</span>(<span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"두 번째 작업\"</span>, <span class=\"hljs-attr\">action</span>: onAction),\n          .<span class=\"hljs-title function_\">cancelButton</span>(<span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">\"취소\"</span>, <span class=\"hljs-attr\">action</span>: onCancel)\n      ]\n    }\n}\n</code></pre>\n<p>알 수 있듯이, enum 케이스별로 Alert 유형을 생성하고 비슷한 알림 유형을 하나의 개체로 그룹화할 수 있습니다. 예를 들어, 모든 권한 알림을 한 곳에 유지하고 싶다면, 개별 알림 구조체/객체로 만들거나 선택은 여러분의 몫입니다. 중요한 점은 처음에 생성한 AlertDisplayable 프로토콜을 준수하는지입니다. 이제 모바일 앱에서 구현이 어떻게 보일지 살펴보겠습니다.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">FirstView</span>: <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">viewModel</span>: <span class=\"hljs-title class_\">FirstViewModel</span>\n\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">VStack</span> {\n            <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"첫 번째 화면\"</span>)\n            <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"알림 표시\"</span>) {\n                viewModel.<span class=\"hljs-title function_\">didTapButton</span>()\n            }\n        }\n    }\n}\n\n@<span class=\"hljs-title class_\">Observable</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FirstViewModel</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">coordinator</span>: <span class=\"hljs-title class_\">FirstCoordinator</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">coordinator: FirstCoordinator</span>) {\n        self.<span class=\"hljs-property\">coordinator</span> = coordinator\n    }\n\n    func <span class=\"hljs-title function_\">didTapButton</span>(<span class=\"hljs-params\"></span>) {\n        coordinator.<span class=\"hljs-title function_\">presentAlert</span>(\n                <span class=\"hljs-title class_\">SomeAlert</span>.<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-attr\">buttons</span>: [\n                    .<span class=\"hljs-title function_\">actionButton</span>(<span class=\"hljs-params\">title: <span class=\"hljs-string\">\"주요 작업\"</span></span>) {\n                        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"작업 버튼 누름\"</span>) <span class=\"hljs-comment\">// &#x3C;- 버튼 클릭 시 호출되는 클로저 </span>\n                    },\n                    .<span class=\"hljs-title function_\">cancelButton</span>(<span class=\"hljs-params\">title: <span class=\"hljs-string\">\"취소\"</span></span>) {\n                        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"취소 버튼 누름\"</span>) <span class=\"hljs-comment\">// &#x3C;- 버튼 클릭 시 호출되는 클로저 </span>\n                    }\n                ]))\n    }\n}\n\n@<span class=\"hljs-title class_\">Observable</span> final <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FirstCoordinator</span>: <span class=\"hljs-title class_\">Coordinator</span> {\n    typealias <span class=\"hljs-title class_\">Route</span> = <span class=\"hljs-title class_\">FirstCoordinatorRoute</span>\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">navigationController</span>: <span class=\"hljs-title class_\">NavigationController</span>\n\n    @<span class=\"hljs-title class_\">MainActor</span> @<span class=\"hljs-title class_\">ViewBuilder</span> <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">rootView</span>: some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-title class_\">FirstView</span>(<span class=\"hljs-title class_\">FirstViewModel</span>(self)).<span class=\"hljs-title function_\">navigationDestination</span>(<span class=\"hljs-attr\">for</span>: <span class=\"hljs-title class_\">Route</span>.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">destination</span>: <span class=\"hljs-title function_\">coordinate</span>(<span class=\"hljs-attr\">_</span>:))\n    }\n\n    func presentAlert&#x3C;T>(_ <span class=\"hljs-attr\">alert</span>: T) where <span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">AlertDisplayable</span> {\n        navigationController.<span class=\"hljs-title function_\">presentAlert</span>(alert)\n    }\n}\n</code></pre>\n<p>이는 viewModel에서 프로그래밍 방식으로 알림을 표시할 수 있게 해주며, 사용자가 버튼을 클릭할 때 viewModel이 선택적으로 콜백을 처리할 수 있게 합니다. 이 경우 뷰 자체 \"FirstView\"는 무엇이 일어나는지 전혀 모릅니다. 알고 있는 것은 didTapButton뿐입니다.</p>\n<p><img src=\"/assets/img/2024-05-20-SwiftUINavigationThecoordinatorpatternpart2Alert_1.png\" alt=\"image\"></p>\n<p>부분 2에 대한 내용은 여기까지입니다.</p>\n<p>이 내용이 유용하다고 생각되면 좋겠습니다. 피드백이나 개선 제안이 있으면 알려주세요. 이 글이 유익했다면 공유해 주세요!</p>\n<p>좋은 하루 보내세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}