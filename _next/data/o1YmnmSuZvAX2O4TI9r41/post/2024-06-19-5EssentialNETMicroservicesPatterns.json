{"pageProps":{"post":{"title":"5가지 필수 NET 마이크로서비스 패턴","description":"","date":"2024-06-19 11:29","slug":"2024-06-19-5EssentialNETMicroservicesPatterns","content":"\n\n\n![2024-06-19-5EssentialNETMicroservicesPatterns_0](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_0.png)\n\n소프트웨어 개발의 끊임없는 세계에서, 마이크로서비스 아키텍처는 특히 .NET의 광범위한 영역에서 인기 있는 선택지가 되었습니다. .NET은 확장 및 적응이 가능한 능력으로 대규모의 데이터 및 트래픽을 처리할 수 있는 이상적인 플랫폼입니다. \n\n이 기사에서는 마이크로서비스 아키텍처를 숙달하고자 하는 .NET 개발자들을 위한 다섯 가지 필수 패턴을 탐구할 것입니다. 우리는 실용적인 예제와 실행 가능한 조언을 제공하여 마이크로서비스의 우수성을 달성하는 여정에서 당신을 돕겠습니다.\n\n## 1. 게이트웨이 집계 패턴\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_1.png)\n\n마이크로서비스 아키텍처에서는 클라이언트 응용 프로그램이 상호 작용해야 할 여러 서비스가 있는 것이 일반적입니다. 각 개별 서비스와 직접 상호 작용하는 대신 API 게이트웨이를 사용하는 것이 더 좋습니다. 이 방법은 클라이언트 코드를 간소화하고 백엔드 서비스에 액세스하기 위한 단일 진입점을 생성합니다.\n\n```js\n// Ocelot API Gateway 사용 예제\npublic async Task<AggregatedResult> AggregateData()\n{\n    var userTask = _userService.GetUser();\n    var ordersTask = _orderService.GetOrdersForUser();\n    \n    await Task.WhenAll(userTask, ordersTask);\n    \n    var user = await userTask;\n    var orders = await ordersTask;\n\n    return new AggregatedResult\n    {\n        User = user,\n        Orders = orders\n    };\n}\n```\n\n## 2. 회로 차단기 패턴\n\n\n<div class=\"content-ad\"></div>\n\n\n![Circuit Breaker](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_2.png)\n\n서킷 브레이커를 구현하면 네트워크 또는 서비스 장애가 다른 서비스로 전파되는 것을 방지할 수 있습니다. 서비스 장애가 발생하면 서킷 브레이커가 이를 감지하고 그 서비스로의 후속 호출을 일정 기간 동안 자동으로 차단합니다.\n\n```js\n// Polly 라이브러리 사용 예제\nvar circuitBreakerPolicy = Policy\n    .Handle<Exception>()\n    .CircuitBreaker(2, TimeSpan.FromMinutes(1));\n\nawait circuitBreakerPolicy.ExecuteAsync(async () =>\n{\n    await PerformServiceCall();\n});\n```\n\n## 3. 서비스 디스커버리 패턴\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_3.png)\n\n마이크로서비스 아키텍처를 확장할수록 다양한 서비스 엔드포인트를 추적하기가 더 어려워집니다. 이 문제를 해결하기 위해 서비스 디스커버리를 구현할 수 있습니다. 이를 통해 서비스가 동적으로 서로를 찾을 수 있습니다.\n\n```js\nusing System;\nusing System.Threading.Tasks;\nusing Consul;\nusing Microsoft.Extensions.DependencyInjection;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var serviceProvider = new ServiceCollection()\n            .AddSingleton<IConsulClient, ConsulClient>(p => new ConsulClient(consulConfig =>\n            {\n                // Assuming Consul is running on localhost\n                consulConfig.Address = new Uri(\"http://localhost:8500\");\n            }))\n            .AddSingleton<IConsulService, ConsulService>()\n            .BuildServiceProvider();\n\n        var consulService = serviceProvider.GetService<IConsulService>();\n        consulService.RegisterService().Wait();\n        consulService.DiscoverServices().Wait();\n    }\n}\n\npublic interface IConsulService\n{\n    Task RegisterService();\n    Task DiscoverServices();\n}\n\npublic class ConsulService : IConsulService\n{\n    private readonly IConsulClient _consulClient;\n\n    public ConsulService(IConsulClient consulClient)\n    {\n        _consulClient = consulClient;\n    }\n\n    public async Task RegisterService()\n    {\n        var registration = new AgentServiceRegistration()\n        {\n            ID = Guid.NewGuid().ToString(),\n            Name = \"MyService\",\n            Address = \"localhost\",\n            Port = 5000,\n        };\n\n        await _consulClient.Agent.ServiceRegister(registration);\n        Console.WriteLine(\"Consul에 서비스 등록됨\");\n    }\n\n    public async Task DiscoverServices()\n    {\n        var services = await _consulClient.Agent.Services();\n        foreach (var service in services.Response.Values)\n        {\n            Console.WriteLine($\"발견된 서비스: {service.Service}\");\n        }\n    }\n}\n```\n\n## 4. 이벤트 소싱 패턴\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_4.png\" />\n\n이벤트 소싱은 응용 프로그램 엔티티의 상태 변경을 이벤트 시리즈로 저장하는 패턴입니다. 이 접근 방식은 특히 마이크로서비스 아키텍처에서 유용하며 시스템에 대한 모든 변경 사항의 감사 가능한 레코드를 제공하여 디버깅 및 문제 해결에 도움이 됩니다. 게다가 이벤트 소싱은 응용 프로그램의 다른 구성 요소 간 데이터 일관성을 보장하는 데 도움이 될 수 있습니다.\n\n```js\n// EventStore를 사용한 이벤트 소싱 예시\npublic async Task SaveEvents(Guid entityId, IEnumerable<Event> events, long expectedVersion)\n{\n    var eventData = events.Select(e => new EventData(\n        Guid.NewGuid(),\n        e.GetType().Name,\n        true,\n        Serialize(e),\n        null));\n\n    var streamName = $\"Entity-{entityId}\";\n    await _eventStoreConnection.AppendToStreamAsync(streamName, expectedVersion, eventData);\n}\n```\n\n## 5. CQRS 패턴\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_5.png)\n\nCommand Query Responsibility Segregation (CQRS)는 시스템의 읽기 및 쓰기 작업을 분리하는 디자인 패턴입니다. 이 접근 방식은 마이크로서비스에 적합하며 복잡한 데이터 모델을 관리하고 시스템을 더 효과적으로 확장하는 데 도움이 됩니다.\n\n새로운 사용자 추가를 위한 명령\n\n```js\n// Commands/AddUserCommand.cs\npublic class AddUserCommand\n{\n    public string Name { get; }\n\n    public AddUserCommand(string name)\n    {\n        Name = name;\n    }\n}\n\n// Handlers/AddUserCommandHandler.cs\npublic class AddUserCommandHandler : ICommandHandler<AddUserCommand>\n{\n    public void Handle(AddUserCommand command)\n    {\n        // Logic to add the user to the database\n        Console.WriteLine($\"User {command.Name} added\");\n    }\n}\n``` \n\n\n<div class=\"content-ad\"></div>\n\nID로 사용자를 가져오는 쿼리\n\n```js\n// Queries/GetUserQuery.cs\npublic class GetUserQuery\n{\n    public int UserId { get; }\n\n    public GetUserQuery(int userId)\n    {\n        UserId = userId;\n    }\n}\n\n// Handlers/GetUserQueryHandler.cs\npublic class GetUserQueryHandler : IQueryHandler<GetUserQuery, User>\n{\n    public User Handle(GetUserQuery query)\n    {\n        // 데이터베이스에서 사용자를 가져오는 로직\n        return new User { Id = query.UserId, Name = \"John Doe\" };\n    }\n}\n```\n\n핸들러를 위한 인터페이스\n\n```js\n// Commands/ICommandHandler.cs\npublic interface ICommandHandler<TCommand>\n{\n    void Handle(TCommand command);\n}\n\n// Queries/IQueryHandler.cs\npublic interface IQueryHandler<TQuery, TResult>\n{\n    TResult Handle(TQuery query);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 다섯 가지 방식을 따라가면 .NET 마이크로서비스를 숙달하기에 한 발짝 더 다가갈 것입니다. 이것들을 구성 요소로 활용하고 프로젝트에 맞게 사용자 정의하여 사용하세요. 당신의 마이크로서비스는 번성할 것입니다. 코딩을 즐기세요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*UmnFETy8f6kvj1TV.gif)\n\n👏 만약 이 콘텐츠가 도움이 된다면, 버튼을 누른 채로 여러 번 클랩(clap)할 수 있습니다. 또한, 여러분의 생각과 제안을 댓글로 남겨 주시면 더 많은 토론을 할 수 있습니다.\n\n읽어 주셔서 감사합니다...","ogImage":{"url":"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_0.png"},"coverImage":"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_0.png\" alt=\"2024-06-19-5EssentialNETMicroservicesPatterns_0\"></p>\n<p>소프트웨어 개발의 끊임없는 세계에서, 마이크로서비스 아키텍처는 특히 .NET의 광범위한 영역에서 인기 있는 선택지가 되었습니다. .NET은 확장 및 적응이 가능한 능력으로 대규모의 데이터 및 트래픽을 처리할 수 있는 이상적인 플랫폼입니다.</p>\n<p>이 기사에서는 마이크로서비스 아키텍처를 숙달하고자 하는 .NET 개발자들을 위한 다섯 가지 필수 패턴을 탐구할 것입니다. 우리는 실용적인 예제와 실행 가능한 조언을 제공하여 마이크로서비스의 우수성을 달성하는 여정에서 당신을 돕겠습니다.</p>\n<h2>1. 게이트웨이 집계 패턴</h2>\n<p><img src=\"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_1.png\" alt=\"image\"></p>\n<p>마이크로서비스 아키텍처에서는 클라이언트 응용 프로그램이 상호 작용해야 할 여러 서비스가 있는 것이 일반적입니다. 각 개별 서비스와 직접 상호 작용하는 대신 API 게이트웨이를 사용하는 것이 더 좋습니다. 이 방법은 클라이언트 코드를 간소화하고 백엔드 서비스에 액세스하기 위한 단일 진입점을 생성합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Ocelot API Gateway 사용 예제</span>\npublic <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title class_\">Task</span>&#x3C;<span class=\"hljs-title class_\">AggregatedResult</span>> <span class=\"hljs-title class_\">AggregateData</span>()\n{\n    <span class=\"hljs-keyword\">var</span> userTask = _userService.<span class=\"hljs-title class_\">GetUser</span>();\n    <span class=\"hljs-keyword\">var</span> ordersTask = _orderService.<span class=\"hljs-title class_\">GetOrdersForUser</span>();\n    \n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">Task</span>.<span class=\"hljs-title class_\">WhenAll</span>(userTask, ordersTask);\n    \n    <span class=\"hljs-keyword\">var</span> user = <span class=\"hljs-keyword\">await</span> userTask;\n    <span class=\"hljs-keyword\">var</span> orders = <span class=\"hljs-keyword\">await</span> ordersTask;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AggregatedResult</span>\n    {\n        <span class=\"hljs-title class_\">User</span> = user,\n        <span class=\"hljs-title class_\">Orders</span> = orders\n    };\n}\n</code></pre>\n<h2>2. 회로 차단기 패턴</h2>\n<p><img src=\"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_2.png\" alt=\"Circuit Breaker\"></p>\n<p>서킷 브레이커를 구현하면 네트워크 또는 서비스 장애가 다른 서비스로 전파되는 것을 방지할 수 있습니다. 서비스 장애가 발생하면 서킷 브레이커가 이를 감지하고 그 서비스로의 후속 호출을 일정 기간 동안 자동으로 차단합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Polly 라이브러리 사용 예제</span>\n<span class=\"hljs-keyword\">var</span> circuitBreakerPolicy = <span class=\"hljs-title class_\">Policy</span>\n    .<span class=\"hljs-property\">Handle</span>&#x3C;<span class=\"hljs-title class_\">Exception</span>>()\n    .<span class=\"hljs-title class_\">CircuitBreaker</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">TimeSpan</span>.<span class=\"hljs-title class_\">FromMinutes</span>(<span class=\"hljs-number\">1</span>));\n\n<span class=\"hljs-keyword\">await</span> circuitBreakerPolicy.<span class=\"hljs-title class_\">ExecuteAsync</span>(<span class=\"hljs-keyword\">async</span> () =>\n{\n    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title class_\">PerformServiceCall</span>();\n});\n</code></pre>\n<h2>3. 서비스 디스커버리 패턴</h2>\n<p><img src=\"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_3.png\" alt=\"Image\"></p>\n<p>마이크로서비스 아키텍처를 확장할수록 다양한 서비스 엔드포인트를 추적하기가 더 어려워집니다. 이 문제를 해결하기 위해 서비스 디스커버리를 구현할 수 있습니다. 이를 통해 서비스가 동적으로 서로를 찾을 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">using <span class=\"hljs-title class_\">System</span>;\nusing <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">Threading</span>.<span class=\"hljs-property\">Tasks</span>;\nusing <span class=\"hljs-title class_\">Consul</span>;\nusing <span class=\"hljs-title class_\">Microsoft</span>.<span class=\"hljs-property\">Extensions</span>.<span class=\"hljs-property\">DependencyInjection</span>;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Program</span>\n{\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title class_\">Main</span>(string[] args)\n    {\n        <span class=\"hljs-keyword\">var</span> serviceProvider = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ServiceCollection</span>()\n            .<span class=\"hljs-property\">AddSingleton</span>&#x3C;<span class=\"hljs-title class_\">IConsulClient</span>, <span class=\"hljs-title class_\">ConsulClient</span>>(<span class=\"hljs-function\"><span class=\"hljs-params\">p</span> =></span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConsulClient</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">consulConfig</span> =></span>\n            {\n                <span class=\"hljs-comment\">// Assuming Consul is running on localhost</span>\n                consulConfig.<span class=\"hljs-property\">Address</span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Uri</span>(<span class=\"hljs-string\">\"http://localhost:8500\"</span>);\n            }))\n            .<span class=\"hljs-property\">AddSingleton</span>&#x3C;<span class=\"hljs-title class_\">IConsulService</span>, <span class=\"hljs-title class_\">ConsulService</span>>()\n            .<span class=\"hljs-title class_\">BuildServiceProvider</span>();\n\n        <span class=\"hljs-keyword\">var</span> consulService = serviceProvider.<span class=\"hljs-property\">GetService</span>&#x3C;<span class=\"hljs-title class_\">IConsulService</span>>();\n        consulService.<span class=\"hljs-title class_\">RegisterService</span>().<span class=\"hljs-title class_\">Wait</span>();\n        consulService.<span class=\"hljs-title class_\">DiscoverServices</span>().<span class=\"hljs-title class_\">Wait</span>();\n    }\n}\n\npublic interface <span class=\"hljs-title class_\">IConsulService</span>\n{\n    <span class=\"hljs-title class_\">Task</span> <span class=\"hljs-title class_\">RegisterService</span>();\n    <span class=\"hljs-title class_\">Task</span> <span class=\"hljs-title class_\">DiscoverServices</span>();\n}\n\npublic <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConsulService</span> : <span class=\"hljs-title class_\">IConsulService</span>\n{\n    private readonly <span class=\"hljs-title class_\">IConsulClient</span> _consulClient;\n\n    public <span class=\"hljs-title class_\">ConsulService</span>(<span class=\"hljs-title class_\">IConsulClient</span> consulClient)\n    {\n        _consulClient = consulClient;\n    }\n\n    public <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title class_\">Task</span> <span class=\"hljs-title class_\">RegisterService</span>()\n    {\n        <span class=\"hljs-keyword\">var</span> registration = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AgentServiceRegistration</span>()\n        {\n            <span class=\"hljs-variable constant_\">ID</span> = <span class=\"hljs-title class_\">Guid</span>.<span class=\"hljs-title class_\">NewGuid</span>().<span class=\"hljs-title class_\">ToString</span>(),\n            <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"MyService\"</span>,\n            <span class=\"hljs-title class_\">Address</span> = <span class=\"hljs-string\">\"localhost\"</span>,\n            <span class=\"hljs-title class_\">Port</span> = <span class=\"hljs-number\">5000</span>,\n        };\n\n        <span class=\"hljs-keyword\">await</span> _consulClient.<span class=\"hljs-property\">Agent</span>.<span class=\"hljs-title class_\">ServiceRegister</span>(registration);\n        <span class=\"hljs-title class_\">Console</span>.<span class=\"hljs-title class_\">WriteLine</span>(<span class=\"hljs-string\">\"Consul에 서비스 등록됨\"</span>);\n    }\n\n    public <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title class_\">Task</span> <span class=\"hljs-title class_\">DiscoverServices</span>()\n    {\n        <span class=\"hljs-keyword\">var</span> services = <span class=\"hljs-keyword\">await</span> _consulClient.<span class=\"hljs-property\">Agent</span>.<span class=\"hljs-title class_\">Services</span>();\n        foreach (<span class=\"hljs-keyword\">var</span> service <span class=\"hljs-keyword\">in</span> services.<span class=\"hljs-property\">Response</span>.<span class=\"hljs-property\">Values</span>)\n        {\n            <span class=\"hljs-title class_\">Console</span>.<span class=\"hljs-title class_\">WriteLine</span>($<span class=\"hljs-string\">\"발견된 서비스: {service.Service}\"</span>);\n        }\n    }\n}\n</code></pre>\n<h2>4. 이벤트 소싱 패턴</h2>\n<p>이벤트 소싱은 응용 프로그램 엔티티의 상태 변경을 이벤트 시리즈로 저장하는 패턴입니다. 이 접근 방식은 특히 마이크로서비스 아키텍처에서 유용하며 시스템에 대한 모든 변경 사항의 감사 가능한 레코드를 제공하여 디버깅 및 문제 해결에 도움이 됩니다. 게다가 이벤트 소싱은 응용 프로그램의 다른 구성 요소 간 데이터 일관성을 보장하는 데 도움이 될 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// EventStore를 사용한 이벤트 소싱 예시</span>\npublic <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title class_\">Task</span> <span class=\"hljs-title class_\">SaveEvents</span>(<span class=\"hljs-title class_\">Guid</span> entityId, <span class=\"hljs-title class_\">IEnumerable</span>&#x3C;<span class=\"hljs-title class_\">Event</span>> events, long expectedVersion)\n{\n    <span class=\"hljs-keyword\">var</span> eventData = events.<span class=\"hljs-title class_\">Select</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =></span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">EventData</span>(\n        <span class=\"hljs-title class_\">Guid</span>.<span class=\"hljs-title class_\">NewGuid</span>(),\n        e.<span class=\"hljs-title class_\">GetType</span>().<span class=\"hljs-property\">Name</span>,\n        <span class=\"hljs-literal\">true</span>,\n        <span class=\"hljs-title class_\">Serialize</span>(e),\n        <span class=\"hljs-literal\">null</span>));\n\n    <span class=\"hljs-keyword\">var</span> streamName = $<span class=\"hljs-string\">\"Entity-{entityId}\"</span>;\n    <span class=\"hljs-keyword\">await</span> _eventStoreConnection.<span class=\"hljs-title class_\">AppendToStreamAsync</span>(streamName, expectedVersion, eventData);\n}\n</code></pre>\n<h2>5. CQRS 패턴</h2>\n<p><img src=\"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_5.png\" alt=\"image\"></p>\n<p>Command Query Responsibility Segregation (CQRS)는 시스템의 읽기 및 쓰기 작업을 분리하는 디자인 패턴입니다. 이 접근 방식은 마이크로서비스에 적합하며 복잡한 데이터 모델을 관리하고 시스템을 더 효과적으로 확장하는 데 도움이 됩니다.</p>\n<p>새로운 사용자 추가를 위한 명령</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Commands/AddUserCommand.cs</span>\npublic <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AddUserCommand</span>\n{\n    public string <span class=\"hljs-title class_\">Name</span> { get; }\n\n    public <span class=\"hljs-title class_\">AddUserCommand</span>(string name)\n    {\n        <span class=\"hljs-title class_\">Name</span> = name;\n    }\n}\n\n<span class=\"hljs-comment\">// Handlers/AddUserCommandHandler.cs</span>\npublic <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AddUserCommandHandler</span> : <span class=\"hljs-title class_\">ICommandHandler</span>&#x3C;<span class=\"hljs-title class_\">AddUserCommand</span>>\n{\n    public <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title class_\">Handle</span>(<span class=\"hljs-title class_\">AddUserCommand</span> command)\n    {\n        <span class=\"hljs-comment\">// Logic to add the user to the database</span>\n        <span class=\"hljs-title class_\">Console</span>.<span class=\"hljs-title class_\">WriteLine</span>($<span class=\"hljs-string\">\"User {command.Name} added\"</span>);\n    }\n}\n</code></pre>\n<p>ID로 사용자를 가져오는 쿼리</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Queries/GetUserQuery.cs</span>\npublic <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GetUserQuery</span>\n{\n    public int <span class=\"hljs-title class_\">UserId</span> { get; }\n\n    public <span class=\"hljs-title class_\">GetUserQuery</span>(int userId)\n    {\n        <span class=\"hljs-title class_\">UserId</span> = userId;\n    }\n}\n\n<span class=\"hljs-comment\">// Handlers/GetUserQueryHandler.cs</span>\npublic <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GetUserQueryHandler</span> : <span class=\"hljs-title class_\">IQueryHandler</span>&#x3C;<span class=\"hljs-title class_\">GetUserQuery</span>, <span class=\"hljs-title class_\">User</span>>\n{\n    public <span class=\"hljs-title class_\">User</span> <span class=\"hljs-title class_\">Handle</span>(<span class=\"hljs-title class_\">GetUserQuery</span> query)\n    {\n        <span class=\"hljs-comment\">// 데이터베이스에서 사용자를 가져오는 로직</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span> { <span class=\"hljs-title class_\">Id</span> = query.<span class=\"hljs-property\">UserId</span>, <span class=\"hljs-title class_\">Name</span> = <span class=\"hljs-string\">\"John Doe\"</span> };\n    }\n}\n</code></pre>\n<p>핸들러를 위한 인터페이스</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Commands/ICommandHandler.cs</span>\npublic interface <span class=\"hljs-title class_\">ICommandHandler</span>&#x3C;<span class=\"hljs-title class_\">TCommand</span>>\n{\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title class_\">Handle</span>(<span class=\"hljs-title class_\">TCommand</span> command);\n}\n\n<span class=\"hljs-comment\">// Queries/IQueryHandler.cs</span>\npublic interface <span class=\"hljs-title class_\">IQueryHandler</span>&#x3C;<span class=\"hljs-title class_\">TQuery</span>, <span class=\"hljs-title class_\">TResult</span>>\n{\n    <span class=\"hljs-title class_\">TResult</span> <span class=\"hljs-title class_\">Handle</span>(<span class=\"hljs-title class_\">TQuery</span> query);\n}\n</code></pre>\n<p>이 다섯 가지 방식을 따라가면 .NET 마이크로서비스를 숙달하기에 한 발짝 더 다가갈 것입니다. 이것들을 구성 요소로 활용하고 프로젝트에 맞게 사용자 정의하여 사용하세요. 당신의 마이크로서비스는 번성할 것입니다. 코딩을 즐기세요!</p>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1400/0*UmnFETy8f6kvj1TV.gif\" alt=\"이미지\"></p>\n<p>👏 만약 이 콘텐츠가 도움이 된다면, 버튼을 누른 채로 여러 번 클랩(clap)할 수 있습니다. 또한, 여러분의 생각과 제안을 댓글로 남겨 주시면 더 많은 토론을 할 수 있습니다.</p>\n<p>읽어 주셔서 감사합니다...</p>\n</body>\n</html>\n"},"__N_SSG":true}