{"pageProps":{"post":{"title":"Android Kotlin 개발자를 위한 Swift 참고 자료","description":"","date":"2024-05-23 14:45","slug":"2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers","content":"\n안녕하세요! 안드로이드 개발자들은 대부분 Kotlin으로 작업합니다. 그러나 iOS에서 어떤 기능이 구현되는 방법을 참조할 때 Swift를 읽고 이해하는 것도 도움이 될 수 있습니다. 또한 Kotlin Multiplatform을 탐색하는 경우에도 유용합니다.\n\niOS 개발자도 Android 코드를 살펴볼 때 이와 같은 원리가 적용됩니다. Kotlin을 읽고 이해하는 방법을 알면 보다 쉬워집니다.\n\n우리는 iOS 코드를 살펴볼 때 볼 수 있는 몇 가지 일반적인 Swift 패턴에 대해 다루고, 이해하려고 노력하고 Kotlin에서의 구현과 비교해 볼 것입니다.\n\n<img src=\"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 1. 기본 사항\n\n## 변수\n\nSwift에서 변수와 상수는 각각 var 및 let 키워드를 사용하여 정의됩니다. 세미콜론을 사용하여 유형 주석을 제공할 수 있지만 필수는 아닙니다.\n\n```js\n// Swift\nlet animDurationMillis: Int = 500\nvar clickCount = 0\n\n// Kotlin\nval animDurationMillis: Int = 500\nvar clickCount = 0\n```\n\n<div class=\"content-ad\"></div>\n\n현재 시점에서 두 언어의 유일한 차이점은 읽기 전용 변수를 정의하는 let 대 val 키워드입니다.\n\n## 옵셔널 / 널 가능성\n\n옵셔널이나 널 가능한 유형의 경우, 두 언어 모두 같은 ? 문자를 사용하지만, 값이 없는 상태에 대해서는 nil 대 null이 유일한 차이점입니다.\n\n```swift\n// Swift\nvar foundItem: String? = nil\n\n// Kotlin\nvar foundItem: String? = null\n```\n\n<div class=\"content-ad\"></div>\n\nnil 상태를 처리하는 여러 가지 방법이 있습니다:\n\n- 값 확인을 위해 if 표현식을 사용하는 방법 (이 내용은 뒤에서 다룹니다),\n- 옵셔널 바인딩을 사용하는 방법 (이 내용은 뒤에서 다룹니다),\n- 대체/기본값을 제공하는 방법,\n- 강제 언래핑을 하는 방법.\n\n마지막 두 가지 접근법의 예시가 여기 있습니다. 코틀린이 거의 동일한 방식을 제공한다는 것을 알 수 있습니다. 문법에 약간의 차이가 있습니다 (?? vs ?: 및 ! vs !!).\n\n```js\n// Swift\n//  - 대체/기본값\nlet actualFoundItem = foundItem ?? \"empty\"\n//  - 강제 언래핑\nlet actualFoundItem = foundItem!\n\n// Kotlin\n//  - 대체/기본값\nval actualFoundItem = foundItem ?: \"empty\"\n//  - 강제 언래핑\nval actualFoundItem2 = foundItem!!\n```\n\n<div class=\"content-ad\"></div>\n\n## 제어 흐름\n\nif 문은 Kotlin과 거의 동일한데, Swift에서는 괄호를 생략할 수 있다는 작은 차이가 있습니다.\n\n```js\n// Swift\nif foundItem != nil {\n  // 무언가를 수행\n}\n\n// Kotlin\nif (foundItem != null) {\n  // 무언가를 수행\n}\n```\n\n두 언어 모두 else if/else 분기에 대해 동일한 구문을 사용하며, 두 언어 모두 표현식으로 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 스위프트\nlet description = if delta <= 10 {\n  \"low\"\n} else if delta >= 50 {\n  \"high\"\n} else {\n  \"medium\"\n}\n\n// 코틀린\nval description = if (delta <= 10) {\n    \"low\"\n} else if (delta >= 50) {\n    \"high\"\n} else {\n    \"medium\"\n}\n```\n\n## Functions\n\nSwift에서 함수는 func 키워드로 선언되며, 함수 이름, 입력 매개변수 및 반환 유형이 이어집니다.\n\n```js\nfunc addTwoNumbers(a: Int, b: Int) -> Int {\n    return a + b\n}\n```\n\n<div class=\"content-ad\"></div>\n\n코틀린에서는 fun 키워드와 :을 사용하여 반환 유형을 정의합니다. -` 대신에 Markdown 형식으로 표를 변경해주세요.\n\n```kotlin\nfun addTwoNumbers(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n# 2. 구조체 및 클래스\n\nSwift는 데이터 모델링 관점에서 비슷한 구조체와 클래스를 지원합니다. 둘 다 속성과 함수를 정의할 수 있지만, 클래스는 참조에 의해 전달되고 구조체는 값에 의해 전달됩니다.\n\n<div class=\"content-ad\"></div>\n\n기본적으로 구조체를 사용하는 것이 권장됩니다. 상속, Objective-C 호환성 등 추가 기능이 필요할 때는 클래스를 사용하세요.\n\n```js\nstruct VehicleStructure {\n    var maxSpeed = 0\n\n    func printInfo() {\n        print(\"최대 속도 \\(maxSpeed)\")\n    }\n}\n\nclass VehicleClass {\n    var maxSpeed = 0\n\n    func printInfo() {\n        print(\"최대 속도 \\(maxSpeed)\")\n    }\n}\n```\n\n인스턴스를 생성하려면 구조체나 클래스 이름 뒤에 빈 괄호를 사용합니다.\n\n구조체는 기본적으로 변경 불가능하므로 속성의 값 변경이 필요한 경우 let 대신 var로 선언해야 합니다. 멤버 속성의 값을 설정하기 위해 자동으로 생성된 이니셜라이저를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 변경 가능한 구조체 인스턴스 생성\nvar car = VehicleStructure()\ncar.maxSpeed = 250\ncar.printInfo()\n\n// 변경 불가능한 구조체 인스턴스 생성\nlet carSimple = VehicleStructure(maxSpeed: 200)\ncarSimple.printInfo()\n\n// 클래스 인스턴스 생성\nlet bike = VehicleClass()\nbike.maxSpeed = 50\nbike.printInfo()\n```\n\n## Kotlin\n\nKotlin에서의 주요 구성 요소는 클래스입니다. 그 선언과 사용법은 Swift와 거의 동일합니다.\n\n```js\nclass Vehicle {\n    var maxSpeed = 0\n\n    fun printInfo(){\n        println(\"최대 속도는 $maxSpeed입니다.\")\n    }\n}\n\n// 클래스 인스턴스 생성\nval vehicle = Vehicle()\nvehicle.maxSpeed = 250\nvehicle.printInfo()\n```\n\n<div class=\"content-ad\"></div>\n\nKotlin은 클래스 생성 시 모든 클래스 속성에 값을 제공해야하는 클래스 생성자도 지원합니다.\n\n```kotlin\nclass Vehicle(var maxSpeed: Int) {\n\n    fun printInfo(){\n        println(\"최대 속도는 $maxSpeed 입니다.\")\n    }\n}\n\nval vehicle = Vehicle(250)\n```\n\nKotlin은 추상 클래스, 데이터 클래스, 인터페이스 및 실드 클래스 및 인터페이스와 같은 다른 관련 구조를 지원합니다. 더 많은 내용은 https://kotlinlang.org/docs/classes.html에서 확인할 수 있습니다.\n\n# 3. Optional Binding\n\n\n<div class=\"content-ad\"></div>\n\n## if let 사용법\n\nSwift 코드베이스에서 자주 볼 수 있는 패턴 중 하나는 다음과 같습니다:\n\n```js\nlet fetchedUserId: String? = \"Optional id of the fetched user\"\nif let userId = fetchedUserId {\n    // userId를 선택적인(non-optional) 상수로 사용할 수 있습니다.\n    print(userId)\n} else {\n    // fetchedUserId가 nil/null인 경우\n    throw Error(\"Missing user id\")\n}\n\n// fetchedUserId와 userId를 if 문 바깥에서 사용할 수 있습니다.\n// 그러나 둘 다 여전히 옵셔널이므로 unwrapping이 필요합니다.\n```\n\n이를 선택적 바인딩(optional binding)이라고 합니다.\n\n<div class=\"content-ad\"></div>\n\n- 선택적으로 검색된 fetchedUserId 변수가 nil이 아닌 값으로 존재하는지 확인합니다.\n- true이면 새로운 선택 불가능한 상수인 userId에 값을 할당합니다.\n- 새로운 상수 userId는 코드 블록 내에서 참조할 수 있습니다.\n- fetchedUserId가 nil이라면 else 블록을 실행합니다.\n\n기존 변수 이름을 사용하여 더욱 간단하게 코드를 작성할 수 있습니다:\n\n```js\nlet fetchedUserId: String? = \"검색된 사용자의 선택 사항 ID\"\nif let fetchedUserId {\n    // fetchedUserId를 선택 불가능한 상수로 사용할 수 있습니다.\n    print(fetchedUserId)\n}\n```\n\n두 경우 모두 fetchedUserId와 userId 상수를 if 문 바깥에서 사용할 수 있지만, 두 상수 모두 여전히 선택적으로 간주되기 때문에 추가로 언래핑이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n코틀린\n코틀린에는 이에 해당하는 특수한 패턴이 없습니다. 하나의 옵션은 if/else 문을 사용하는 것입니다. 그러나 이는 로컬 변수에 대해서만 작동하며 전역 변수에는 작동하지 않습니다. 전역 변수를 지원하려면 먼저 값을 새로운 로컬 변수/상수에 할당해야 합니다.\n\n```js\n// 글로벌 클래스 속성\nvar fetchedUserId: String? = \"피치된 사용자의 선택 가능한 ID\"\n\nval userId = fetchedUserId\nif (userId != null) {\n  // userId는 선택 사항 없이 사용할 수 있습니다\n} else {\n  throw Exception(\"사용자 ID가 누락되었습니다\")\n}\n\n// userId는 선택 사항 없이 어디서든 사용할 수 있습니다\n```\n\n위의 경우에는 if 문 이후에도 userId 상수를 선택 사항 없이 참조할 수 있으며, 이는 옵셔널 바인딩 패턴을 사용한 스위프트에서는 지원되지 않습니다.\n\n대안적인 해결책은 `.let`과 같은 스코프 함수를 사용하는 것입니다. 함수 내부의 코드는 fetchedUserId가 null이 아닌 경우에만 실행됩니다. 이 코드 블록 이후에 fetchedUserId에 대한 참조는 여전히 변수가 선택 사항으로 간주되므로 널 안전성이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nfetchedUserId?.let { userId ->\n  // userId가 옵셔널이 아닌 것으로 사용할 수 있습니다\n} ?: throw Exception(\"사용자 ID가 누락되었습니다\")\n```\n\n## 보호자\n\n또 다른 일반적인 패턴은 가드문입니다. 이는 if let 패턴과 유사합니다. 주로 함수 내에서 조기에 종료할 때 사용됩니다. 다른 점은 else 블록이 필수적이라는 것입니다.\n\n```swift\nfunc checkUsernameValid(username: String?) -> Bool {\n    guard let username else {\n        // username이 nil이므로 평가할 수 없습니다\n        return false\n    }\n    // username을 옵셔널이 아닌 것으로 사용할 수 있습니다\n    return username.count > 3\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 코드에서 함수는 선택적으로 변수 username을 받습니다. 그런 다음 guard문을 사용하여 username이 값이 있는지 확인합니다. 값이 없는 경우 함수를 종료합니다. 값이 있는 경우 나머지 함수에서는 username을 선택사항이 아닌 것처럼 사용할 수 있습니다.\n\nKotlin\nKotlin에서는 몇 가지 다른 방법으로 이를 작성할 수 있습니다. 두 가지 제안을 보여드리겠습니다:\n\n```js\nfun checkUsernameValid(username: String?): Boolean {\n    if (username.isNullOrEmpty()){\n        return false\n    }\n    return username.length > 3\n}\n\n// 또는\n\nfun checkUsernameValid(username: String?): Boolean {\n    val actualUsername = username ?: return false\n    return actualUsername.length > 3\n}\n```\n\n# 4. Enums\n\n<div class=\"content-ad\"></div>\n\nSwift에서는 enum 키워드를 사용하여 열거형을 정의합니다. 값은 case 키워드를 사용하고 그 뒤에 열거형 케이스의 이름을 작성합니다. 열거형 케이스의 이름은 소문자로 작성하는 것이 권장되며 단수형으로 작성하는 것이 좋습니다. 각 케이스를 새로운 줄에 작성해야 합니다. 여러 케이스를 한 줄에 작성할 때는 쉼표로 구분합니다.\n\n```js\nenum Direction {\n    case left\n    case up\n    case right\n    case down\n}\n\n// 또는\n\nenum Direction {\n    case left, up, right, down\n}\n```\n\nenum 케이스를 사용하려면 유형(Direction)과 사용하려는 케이스를 참조합니다. 나중에 유형을 생략하고 더 짧은 점 구문을 사용하여 케이스를 직접 참조할 수 있습니다.\n\n```js\nvar selectedDirection = Direction.up\nselectedDirection = .right\n```\n\n<div class=\"content-ad\"></div>\n\n열거형 값 확인을 위해 switch 문을 사용할 수 있습니다. Xcode는 switch 문의 모든 분기를 자동으로 작성합니다. 열거형에 대한 switch 문이 전체적이어야 하기 때문입니다.\n\n```js\nswitch(selectedDirection){\ncase .left:\n    goLeft()\ncase .up:\n    goForward()\ncase .right:\n    goRight()\ncase .down:\n    goBackward()\n}\n```\n\nSwift 열거형은 연관 값도 지원합니다. 즉, 각 열거형 케이스마다 다른 수의 값 유형을 가질 수 있습니다. 이는 Kotlin의 sealed class와 유사한 강력한 도메인 모델링 도구 역할을 합니다.\n\n더 알아보기: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations\n\n<div class=\"content-ad\"></div>\n\n## 코틀린\n\n코틀린에서는 enum 클래스 키워드를 사용하여 Enum을 정의합니다. 값은 쉼표로 구분하여 정의합니다. Enum 값 이름은 일반적으로 대문자로 작성하는 것이 관례이지만, 프로젝트의 스타일에 따라 다를 수 있습니다.\n\n```js\nenum class Direction {\n    LEFT, UP, RIGHT, DOWN\n}\n```\n\nEnum을 사용할 때는 클래스 이름과 사용하려는 값으로 참조합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nvar selectedDirection = Direction.UP;\n```\n\n우리는 값 확인을 위해 when 문을 사용할 수 있습니다. 가능한 모든 열거형 값을 포함해야합니다.\n\n```js\nwhen(selectedDirection){\n    Direction.LEFT -> goLeft()\n    Direction.UP -> goForward()\n    Direction.RIGHT -> goRight()\n    Direction.DOWN -> goBackward()\n}\n```\n\nKotlin 열거형 클래스는 각 열거형 값이 값을 제공해야하는 추가 속성을 정의하는 것을 지원합니다. 그러나 Swift의 관련 값과 달리 속성은 클래스 수준에 있으며 값 레벨이 아니므로 각 값에 대해 동일한 형식이어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Kotlin 공식 문서 링크입니다: https://kotlinlang.org/docs/enum-classes.html\n\n# 5. 사전 / 맵\n\nSwift의 딕셔너리와 Kotlin의 맵 사이의 구문은 매우 다르지만 비슷한 기본 개념을 사용합니다.\n\n## Kotlin\n\n<div class=\"content-ad\"></div>\n\n딕셔너리는 키와 값을 동일한 유형으로 연결해주는 Swift의 데이터 구조입니다. 키-값 쌍은 순서가 없이 저장됩니다. 각 키는 연결된 값을 액세스하기 위한 기준값을 나타냅니다.\n\n딕셔너리를 선언하려면 키-값 쌍을 [Key: Value] 형식으로 대괄호 안에 쉼표로 구분하여 정의합니다. 최소 하나의 키-값 쌍을 정의하면 형식 선언을 생략할 수 있어 컴파일러가 유형을 결정할 수 있습니다.\n\n```js\nvar httpErrorCodes: [Int: String] = [404: \"Not found\", 401: \"Unauthorized\"]\n```\n\n키를 사용하여 딕셔너리에서 값을 읽기 위해 서브스크립트 구문(dictionary[key])을 사용할 수 있습니다. 딕셔너리에 키가 없으면 nil을 반환합니다. ?? 연산자를 사용하여 기본값을 제공할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunc getHttpErrorCodeMessage(code: Int) -> String {\n    let errorCodeMessage = httpErrorCodes[code] ?? \"Unknown\"\n    return \"Http error code \\(errorCodeMessage)\"\n}\n```\n\n딕셔너리에 새로운 값을 쓰려면 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍을 컬렉션에 추가합니다. 키가 이미 존재하면 값을 업데이트합니다.\n\n```js\n// 새로운 키:값 쌍 추가\nhttpErrorCodes[500] = \"Internal Server Error\";\n\n// 기존 키의 값 업데이트\nhttpErrorCodes[401] = \"Requires authentication\";\n```\n\n가변 또는 불변(읽기 전용) 딕셔너리를 사용하는지는 할당에 달려있습니다. let을 사용하면 선언한 후에만 읽을 수 있는 딕셔너리를 정의합니다. 쓰기를 지원하려면 var로 선언해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n자세히 읽기: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Dictionaries\n\n## Kotlin\n\n맵은 고유한 키와 값의 쌍을 보유하고 각 키에 해당하는 값을 효율적으로 가져오는 컬렉션입니다.\n\nKotlin에서 불변(읽기 전용) 맵을 선언하려면 Map`KeyType, ValueType` 유형을 사용하고 mapOf(varargs pairs: Pair`KeyType, ValueType`) 표준 라이브러리 함수를 사용하여 초기화합니다. 적어도 하나의 키-값 쌍을 제공하면 명시적인 변수 유형 선언을 생략할 수 있습니다. 컴파일러가 유형을 결정할 수 있기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n값을 선언할 때 Pair(key, value) 클래스를 직접 사용하거나 객체를 만들어주는 to 인픽스 함수를 사용할 수 있습니다.\n\n```kotlin\nval httpErrorCodes: Map<Int, String> = mapOf(\n    404 to \"찾을 수 없음\",\n    Pair(401, \"권한이 없음\"),\n)\n```\n\n키를 사용하여 맵에서 값을 읽을 때 대괄호 표기법(map[key])을 사용할 수 있습니다. 키가 맵에 존재하지 않으면 null이 반환됩니다. ?: 연산자를 사용하여 기본값을 제공할 수 있습니다.\n\n```kotlin\nfun getHttpErrorCodeMessage(code: Int): String {\n    val errorCodeMessage = httpErrorCodes[code] ?: \"알 수 없음\"\n    return \"Http 오류 코드: $errorCodeMessage\"\n}\n```\n\n<div class=\"content-ad\"></div>\n\n맵에 새로운 값을 작성하려면 MutableMap KeyType, ValueType 형식과 mutableMapOf() 팩토리 함수를 사용하여 가변 맵을 선언해야 합니다. 그런 다음 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍이 컬렉션에 추가됩니다. 키가 이미 존재하면 해당 값을 업데이트합니다.\n\n```js\n// 새 키:값 쌍 추가\nhttpErrorCodes[500] = \"내부 서버 오류\";\n\n// 기존 키에 대한 값 업데이트\nhttpErrorCodes[401] = \"인증이 필요함\";\n```\n\n더 읽어보기: https://www.baeldung.com/kotlin/maps\n\n# 6. 확장\n\n<div class=\"content-ad\"></div>\n\n확장(extension)은 기존 클래스나 구조체에 새로운 기능을 추가하는 방법입니다. 때로는 코드에 액세스할 수 없는 것들에 대해서도 확장을 적용할 수 있습니다.\n\nSwift에서는 extension 키워드를 사용하여 확장을 정의할 수 있습니다. 확장은 다른 클래스나 구조체 외부의 최상위 레벨에서 선언되어야 합니다.\n\n```js\nextension String {\n    func doubled() -> String {\n        return self + self\n    }\n}\n```\n\n위 예제에서는 String 타입에 doubled() 확장 함수를 정의했습니다. 이제 이 함수를 문자열의 인스턴스에서 호출할 수 있으며 마치 원래 정의에 포함된 것처럼 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nlet originalStr = \"Swift\";\nlet doubledStr = originalStr.doubled();\nprint(doubledStr); // prints \"SwiftSwift\"\n```\n\n## Kotlin\n\nKotlin은 동일한 방식으로 작동하는 확장 함수를 사용하며 기존 클래스에 새 기능을 추가할 수 있습니다. 우리는 확장하려는 클래스 이름과 함께 점과 함수 이름이 이어지는 최상위 함수로 정의합니다.\n\n```js\nfun String.doubled(): String {\n    return this + this\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이제 이 함수를 사용하여 원래 정의의 일부인 문자열 인스턴스에서 호출할 수 있습니다.\n\n```js\nval originalStr = \"Kotlin\"\nval doubledStr = originalStr.doubled()\nprintln(doubledStr) // \"KotlinKotlin\" 출력\n```\n\n# 7. 프로토콜\n\nSwift에서 프로토콜은 클래스, 구조체 또는 열거형이 해당 요구 사항의 실제 구현을 제공함으로써 채택할 수 있는 속성, 메서드 및 기타 요구 사항의 집합입니다.\n\n<div class=\"content-ad\"></div>\n\n프로토콜을 정의할 때는 프로토콜 키워드 뒤에 프로토콜 이름을 붙이면 됩니다. 이는 구조체나 클래스 선언과 유사합니다. 프로토콜 내부에서는 get할 수 있는(' get ') 또는 get과 set이 모두 가능한(' get set ') 속성을 정의할 수 있습니다.\n\n```js\nprotocol RequestError {\n    var errorCode: Int { get }\n    var isRecoverable: Bool { get set }\n}\n\nprotocol PrintableError {\n    func buildErrorMessage() -> String\n}\n```\n\n위 예시에서는 RequestError라는 프로토콜을 정의했는데, 이 프로토콜에는 errorCode라는 get할 수 있는 속성과 isRecoverable이라는 set이 가능한 속성이 포함되어 있습니다. 또한, adopter가 구현해야 하는 buildErrorMessage() 함수를 포함하는 PrintableError라는 프로토콜도 정의했습니다.\n\n프로토콜을 채택하기 위해서는 클래스나 구조체를 정의하고 이름 뒤에 : ProtocolName을 추가해야 합니다. 여러 프로토콜을 선언하려면 쉼표를 사용하면 됩니다. 그런 다음 클래스나 구조체의 본문에서 프로토콜로부터 요구되는 내용을 정의해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass ServerHttpError: RequestError, PrintableError {\n    var errorCode: Int = 500\n    var isRecoverable: Bool = false\n\n    func buildErrorMessage() -> String {\n        return \"Server side http error with error code \\(errorCode)\"\n    }\n}\n\nstruct ConnectionError: RequestError, PrintableError {\n    var errorCode: Int\n    var isRecoverable: Bool\n\n    func buildErrorMessage() -> String {\n        return \"Local connection error\"\n    }\n}\n```\n\n우리는 RequestError와 PrintableError 프로토콜을 채택하는 ServerHttpError 클래스를 정의했고, 두 속성의 기본값과 함수의 구현을 정의했습니다. 또한 두 속성을 선언하고 함수의 구현을 제공하는 ConnectionError 구조체를 가지고 있습니다.\n\n이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고 이들을 RequestError 또는 PrintableError 유형으로 전달할 수 있습니다. RequestError 유형을 수락하는 onRequestError() 함수에서 error가 PrintableError 프로토콜을 준수하는지 확인하여 오류 메시지를 구성합니다.\n\n```js\nfunc onRequestError(error: RequestError) {\n    if let printableError = error as? PrintableError {\n        print(printableError.buildErrorMessage())\n    }\n    print(\"Is recoverable: \\(error.isRecoverable)\")\n}\n\nlet firstError = ServerHttpError()\nfirstError.errorCode = 503\nfirstError.isRecoverable = false\n\nlet secondError = ConnectionError(errorCode: 404, isRecoverable: true)\n\n// \"Server side http error with error code 503. Is recoverable: false\"\nonRequestError(error: firstError)\n// \"Local connection error. Is recoverable: true\"\nonRequestError(error: secondError)\n```\n\n<div class=\"content-ad\"></div>\n\n이것은 프로토콜을 사용하는 간단한 예시입니다. Swift의 프로토콜은 상속, 합성, 연관 타입, 제네릭 등과 같이 더 고급적인 사용 사례를 지원합니다. 더 많은 내용은 https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols에서 확인할 수 있어요.\n\n## Kotlin\n\n위의 예시는 인터페이스, 추상 클래스, sealed 클래스 등을 사용하여 Kotlin으로 여러 방법으로 작성할 수 있습니다. 그러나 Swift의 프로토콜을 가장 가깝게 표현하는 것은 아마도 인터페이스일 것입니다. 이는 속성과 함수를 정의하며, 상속, 구성, 그리고 제네릭을 지원합니다.\n\n인터페이스를 정의할 때는 interface 키워드를 사용하고 이름을 이어서 작성합니다. 본문에서는 속성과 함수를 정의합니다. 읽기 전용 속성은 val 키워드를 사용하여 정의하고, 읽기/쓰기 속성은 var 키워드를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n이 인터페이스를 구현하도록 클래스에 지정하는 방법은, 클래스 이름 뒤에 InterfaceName을 사용합니다. 여러 인터페이스를 구현하려면 쉼표를 사용합니다. 그런 다음 모든 속성과 함수를 override 키워드와 함께 정의해야 합니다.\n\n```js\ninterface RequestError {\n    val errorCode: Int\n    var isRecoverable: Boolean\n}\n\ninterface PrintableError {\n    fun buildErrorMessage(): String\n}\n\nclass ServerHttpError(\n    override val errorCode: Int,\n    override var isRecoverable: Boolean\n) : RequestError, PrintableError {\n    override fun buildErrorMessage(): String {\n        return \"Server side http error with error code $errorCode\"\n    }\n}\n\nclass ConnectionError : RequestError, PrintableError {\n    override val errorCode: Int\n        get() = 404\n    override var isRecoverable: Boolean = true\n\n    override fun buildErrorMessage(): String {\n        return \"Local connection error\"\n    }\n}\n```\n\n이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고, 함수에 RequestError 유형으로 전달할 수 있습니다.\n\n```js\nfun onRequestError(error: RequestError) {\n    if (error is PrintableError) {\n        println(error.buildErrorMessage())\n    }\n    println(\"$errorMessage. Is recoverable: ${error.isRecoverable}\")\n}\n\nval firstError = ServerHttpError(errorCode = 503, isRecoverable = false)\nval secondError = ConnectionError()\n// \"Server side http error with error code 503. Is recoverable: false\"\nonRequestError(firstError)\n// \"Local connection error. Is recoverable: true\"\nonRequestError(secondError)\n```\n\n<div class=\"content-ad\"></div>\n\n\nRead more at https://kotlinlang.org/docs/interfaces.html\n\n# 결론\n\n일반적인 Swift 패턴을 이해하고 Kotlin에서 어떻게 번역되는지 알면 코드가 하는 일을 더 잘 이해할 수 있습니다. 이웃 플랫폼에서 어떤 기능이 구현되었는지 보거나 코드 검토를 수행하거나 기술 사양/제안서를 검토하거나 작업을 Kotlin Multiplatform으로 수행하는 여러 방법이 있습니다.\n\nSwift 언어의 기본적인 내용과 Kotlin과 비교하는 방법을 살펴보았습니다. 또한, 선택적 바인딩, 딕셔너리, 익스텐션, 구조 및 프로토콜과 같은 전형적인 iOS 프로젝트에서 발견할 수 있는 일반적인 패턴에 대해서도 다루었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 문이 도움이 되었다면 댓글로 알려주세요! Swift 코드를 읽거나 검토하거나 작성하는 경험에 대해 공유하는 것을 장려합니다.\n\n참고 자료:\n\n- https://kotlinlang.org/docs/home.html\n- https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics\n\nAndrej Rolih 님의 검토와 피드백에 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png"},"coverImage":"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png","tag":["Tech"],"readingTime":17},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>안녕하세요! 안드로이드 개발자들은 대부분 Kotlin으로 작업합니다. 그러나 iOS에서 어떤 기능이 구현되는 방법을 참조할 때 Swift를 읽고 이해하는 것도 도움이 될 수 있습니다. 또한 Kotlin Multiplatform을 탐색하는 경우에도 유용합니다.</p>\n<p>iOS 개발자도 Android 코드를 살펴볼 때 이와 같은 원리가 적용됩니다. Kotlin을 읽고 이해하는 방법을 알면 보다 쉬워집니다.</p>\n<p>우리는 iOS 코드를 살펴볼 때 볼 수 있는 몇 가지 일반적인 Swift 패턴에 대해 다루고, 이해하려고 노력하고 Kotlin에서의 구현과 비교해 볼 것입니다.</p>\n<h1>1. 기본 사항</h1>\n<h2>변수</h2>\n<p>Swift에서 변수와 상수는 각각 var 및 let 키워드를 사용하여 정의됩니다. 세미콜론을 사용하여 유형 주석을 제공할 수 있지만 필수는 아닙니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Swift</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">animDurationMillis</span>: <span class=\"hljs-title class_\">Int</span> = <span class=\"hljs-number\">500</span>\n<span class=\"hljs-keyword\">var</span> clickCount = <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-comment\">// Kotlin</span>\nval <span class=\"hljs-attr\">animDurationMillis</span>: <span class=\"hljs-title class_\">Int</span> = <span class=\"hljs-number\">500</span>\n<span class=\"hljs-keyword\">var</span> clickCount = <span class=\"hljs-number\">0</span>\n</code></pre>\n<p>현재 시점에서 두 언어의 유일한 차이점은 읽기 전용 변수를 정의하는 let 대 val 키워드입니다.</p>\n<h2>옵셔널 / 널 가능성</h2>\n<p>옵셔널이나 널 가능한 유형의 경우, 두 언어 모두 같은 ? 문자를 사용하지만, 값이 없는 상태에 대해서는 nil 대 null이 유일한 차이점입니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// Swift</span>\n<span class=\"hljs-keyword\">var</span> foundItem: <span class=\"hljs-type\">String</span>? <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">nil</span>\n\n<span class=\"hljs-comment\">// Kotlin</span>\n<span class=\"hljs-keyword\">var</span> foundItem: <span class=\"hljs-type\">String</span>? <span class=\"hljs-operator\">=</span> null\n</code></pre>\n<p>nil 상태를 처리하는 여러 가지 방법이 있습니다:</p>\n<ul>\n<li>값 확인을 위해 if 표현식을 사용하는 방법 (이 내용은 뒤에서 다룹니다),</li>\n<li>옵셔널 바인딩을 사용하는 방법 (이 내용은 뒤에서 다룹니다),</li>\n<li>대체/기본값을 제공하는 방법,</li>\n<li>강제 언래핑을 하는 방법.</li>\n</ul>\n<p>마지막 두 가지 접근법의 예시가 여기 있습니다. 코틀린이 거의 동일한 방식을 제공한다는 것을 알 수 있습니다. 문법에 약간의 차이가 있습니다 (?? vs ?: 및 ! vs !!).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Swift</span>\n<span class=\"hljs-comment\">//  - 대체/기본값</span>\n<span class=\"hljs-keyword\">let</span> actualFoundItem = foundItem ?? <span class=\"hljs-string\">\"empty\"</span>\n<span class=\"hljs-comment\">//  - 강제 언래핑</span>\n<span class=\"hljs-keyword\">let</span> actualFoundItem = foundItem!\n\n<span class=\"hljs-comment\">// Kotlin</span>\n<span class=\"hljs-comment\">//  - 대체/기본값</span>\nval actualFoundItem = foundItem ?: <span class=\"hljs-string\">\"empty\"</span>\n<span class=\"hljs-comment\">//  - 강제 언래핑</span>\nval actualFoundItem2 = foundItem!!\n</code></pre>\n<h2>제어 흐름</h2>\n<p>if 문은 Kotlin과 거의 동일한데, Swift에서는 괄호를 생략할 수 있다는 작은 차이가 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// Swift</span>\n<span class=\"hljs-keyword\">if</span> foundItem != nil {\n  <span class=\"hljs-comment\">// 무언가를 수행</span>\n}\n\n<span class=\"hljs-comment\">// Kotlin</span>\n<span class=\"hljs-keyword\">if</span> (foundItem != <span class=\"hljs-literal\">null</span>) {\n  <span class=\"hljs-comment\">// 무언가를 수행</span>\n}\n</code></pre>\n<p>두 언어 모두 else if/else 분기에 대해 동일한 구문을 사용하며, 두 언어 모두 표현식으로 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 스위프트</span>\n<span class=\"hljs-keyword\">let</span> description = <span class=\"hljs-keyword\">if</span> delta &#x3C;= <span class=\"hljs-number\">10</span> {\n  <span class=\"hljs-string\">\"low\"</span>\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> delta >= <span class=\"hljs-number\">50</span> {\n  <span class=\"hljs-string\">\"high\"</span>\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-string\">\"medium\"</span>\n}\n\n<span class=\"hljs-comment\">// 코틀린</span>\nval description = <span class=\"hljs-keyword\">if</span> (delta &#x3C;= <span class=\"hljs-number\">10</span>) {\n    <span class=\"hljs-string\">\"low\"</span>\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (delta >= <span class=\"hljs-number\">50</span>) {\n    <span class=\"hljs-string\">\"high\"</span>\n} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-string\">\"medium\"</span>\n}\n</code></pre>\n<h2>Functions</h2>\n<p>Swift에서 함수는 func 키워드로 선언되며, 함수 이름, 입력 매개변수 및 반환 유형이 이어집니다.</p>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">addTwoNumbers</span>(<span class=\"hljs-attr\">a</span>: <span class=\"hljs-title class_\">Int</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-title class_\">Int</span>) -> <span class=\"hljs-title class_\">Int</span> {\n    <span class=\"hljs-keyword\">return</span> a + b\n}\n</code></pre>\n<p>코틀린에서는 fun 키워드와 :을 사용하여 반환 유형을 정의합니다. -` 대신에 Markdown 형식으로 표를 변경해주세요.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">addTwoNumbers</span><span class=\"hljs-params\">(a: <span class=\"hljs-type\">Int</span>, b: <span class=\"hljs-type\">Int</span>)</span></span>: <span class=\"hljs-built_in\">Int</span> {\n    <span class=\"hljs-keyword\">return</span> a + b\n}\n</code></pre>\n<h1>2. 구조체 및 클래스</h1>\n<p>Swift는 데이터 모델링 관점에서 비슷한 구조체와 클래스를 지원합니다. 둘 다 속성과 함수를 정의할 수 있지만, 클래스는 참조에 의해 전달되고 구조체는 값에 의해 전달됩니다.</p>\n<p>기본적으로 구조체를 사용하는 것이 권장됩니다. 상속, Objective-C 호환성 등 추가 기능이 필요할 때는 클래스를 사용하세요.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">VehicleStructure</span> {\n    <span class=\"hljs-keyword\">var</span> maxSpeed = <span class=\"hljs-number\">0</span>\n\n    func <span class=\"hljs-title function_\">printInfo</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"최대 속도 \\(maxSpeed)\"</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">VehicleClass</span> {\n    <span class=\"hljs-keyword\">var</span> maxSpeed = <span class=\"hljs-number\">0</span>\n\n    func <span class=\"hljs-title function_\">printInfo</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"최대 속도 \\(maxSpeed)\"</span>)\n    }\n}\n</code></pre>\n<p>인스턴스를 생성하려면 구조체나 클래스 이름 뒤에 빈 괄호를 사용합니다.</p>\n<p>구조체는 기본적으로 변경 불가능하므로 속성의 값 변경이 필요한 경우 let 대신 var로 선언해야 합니다. 멤버 속성의 값을 설정하기 위해 자동으로 생성된 이니셜라이저를 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 변경 가능한 구조체 인스턴스 생성</span>\n<span class=\"hljs-keyword\">var</span> car = <span class=\"hljs-title class_\">VehicleStructure</span>()\ncar.<span class=\"hljs-property\">maxSpeed</span> = <span class=\"hljs-number\">250</span>\ncar.<span class=\"hljs-title function_\">printInfo</span>()\n\n<span class=\"hljs-comment\">// 변경 불가능한 구조체 인스턴스 생성</span>\n<span class=\"hljs-keyword\">let</span> carSimple = <span class=\"hljs-title class_\">VehicleStructure</span>(<span class=\"hljs-attr\">maxSpeed</span>: <span class=\"hljs-number\">200</span>)\ncarSimple.<span class=\"hljs-title function_\">printInfo</span>()\n\n<span class=\"hljs-comment\">// 클래스 인스턴스 생성</span>\n<span class=\"hljs-keyword\">let</span> bike = <span class=\"hljs-title class_\">VehicleClass</span>()\nbike.<span class=\"hljs-property\">maxSpeed</span> = <span class=\"hljs-number\">50</span>\nbike.<span class=\"hljs-title function_\">printInfo</span>()\n</code></pre>\n<h2>Kotlin</h2>\n<p>Kotlin에서의 주요 구성 요소는 클래스입니다. 그 선언과 사용법은 Swift와 거의 동일합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vehicle</span> {\n    <span class=\"hljs-keyword\">var</span> maxSpeed = <span class=\"hljs-number\">0</span>\n\n    fun <span class=\"hljs-title function_\">printInfo</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"최대 속도는 $maxSpeed입니다.\"</span>)\n    }\n}\n\n<span class=\"hljs-comment\">// 클래스 인스턴스 생성</span>\nval vehicle = <span class=\"hljs-title class_\">Vehicle</span>()\nvehicle.<span class=\"hljs-property\">maxSpeed</span> = <span class=\"hljs-number\">250</span>\nvehicle.<span class=\"hljs-title function_\">printInfo</span>()\n</code></pre>\n<p>Kotlin은 클래스 생성 시 모든 클래스 속성에 값을 제공해야하는 클래스 생성자도 지원합니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vehicle</span>(<span class=\"hljs-keyword\">var</span> maxSpeed: <span class=\"hljs-built_in\">Int</span>) {\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">printInfo</span><span class=\"hljs-params\">()</span></span>{\n        println(<span class=\"hljs-string\">\"최대 속도는 <span class=\"hljs-variable\">$maxSpeed</span> 입니다.\"</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">val</span> vehicle = Vehicle(<span class=\"hljs-number\">250</span>)\n</code></pre>\n<p>Kotlin은 추상 클래스, 데이터 클래스, 인터페이스 및 실드 클래스 및 인터페이스와 같은 다른 관련 구조를 지원합니다. 더 많은 내용은 <a href=\"https://kotlinlang.org/docs/classes.html%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\">https://kotlinlang.org/docs/classes.html에서</a> 확인할 수 있습니다.</p>\n<h1>3. Optional Binding</h1>\n<h2>if let 사용법</h2>\n<p>Swift 코드베이스에서 자주 볼 수 있는 패턴 중 하나는 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">fetchedUserId</span>: <span class=\"hljs-title class_\">String</span>? = <span class=\"hljs-string\">\"Optional id of the fetched user\"</span>\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> userId = fetchedUserId {\n    <span class=\"hljs-comment\">// userId를 선택적인(non-optional) 상수로 사용할 수 있습니다.</span>\n    <span class=\"hljs-title function_\">print</span>(userId)\n} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// fetchedUserId가 nil/null인 경우</span>\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">\"Missing user id\"</span>)\n}\n\n<span class=\"hljs-comment\">// fetchedUserId와 userId를 if 문 바깥에서 사용할 수 있습니다.</span>\n<span class=\"hljs-comment\">// 그러나 둘 다 여전히 옵셔널이므로 unwrapping이 필요합니다.</span>\n</code></pre>\n<p>이를 선택적 바인딩(optional binding)이라고 합니다.</p>\n<ul>\n<li>선택적으로 검색된 fetchedUserId 변수가 nil이 아닌 값으로 존재하는지 확인합니다.</li>\n<li>true이면 새로운 선택 불가능한 상수인 userId에 값을 할당합니다.</li>\n<li>새로운 상수 userId는 코드 블록 내에서 참조할 수 있습니다.</li>\n<li>fetchedUserId가 nil이라면 else 블록을 실행합니다.</li>\n</ul>\n<p>기존 변수 이름을 사용하여 더욱 간단하게 코드를 작성할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">fetchedUserId</span>: <span class=\"hljs-title class_\">String</span>? = <span class=\"hljs-string\">\"검색된 사용자의 선택 사항 ID\"</span>\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> fetchedUserId {\n    <span class=\"hljs-comment\">// fetchedUserId를 선택 불가능한 상수로 사용할 수 있습니다.</span>\n    <span class=\"hljs-title function_\">print</span>(fetchedUserId)\n}\n</code></pre>\n<p>두 경우 모두 fetchedUserId와 userId 상수를 if 문 바깥에서 사용할 수 있지만, 두 상수 모두 여전히 선택적으로 간주되기 때문에 추가로 언래핑이 필요합니다.</p>\n<p>코틀린\n코틀린에는 이에 해당하는 특수한 패턴이 없습니다. 하나의 옵션은 if/else 문을 사용하는 것입니다. 그러나 이는 로컬 변수에 대해서만 작동하며 전역 변수에는 작동하지 않습니다. 전역 변수를 지원하려면 먼저 값을 새로운 로컬 변수/상수에 할당해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 글로벌 클래스 속성</span>\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">fetchedUserId</span>: <span class=\"hljs-title class_\">String</span>? = <span class=\"hljs-string\">\"피치된 사용자의 선택 가능한 ID\"</span>\n\nval userId = fetchedUserId\n<span class=\"hljs-keyword\">if</span> (userId != <span class=\"hljs-literal\">null</span>) {\n  <span class=\"hljs-comment\">// userId는 선택 사항 없이 사용할 수 있습니다</span>\n} <span class=\"hljs-keyword\">else</span> {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">Exception</span>(<span class=\"hljs-string\">\"사용자 ID가 누락되었습니다\"</span>)\n}\n\n<span class=\"hljs-comment\">// userId는 선택 사항 없이 어디서든 사용할 수 있습니다</span>\n</code></pre>\n<p>위의 경우에는 if 문 이후에도 userId 상수를 선택 사항 없이 참조할 수 있으며, 이는 옵셔널 바인딩 패턴을 사용한 스위프트에서는 지원되지 않습니다.</p>\n<p>대안적인 해결책은 <code>.let</code>과 같은 스코프 함수를 사용하는 것입니다. 함수 내부의 코드는 fetchedUserId가 null이 아닌 경우에만 실행됩니다. 이 코드 블록 이후에 fetchedUserId에 대한 참조는 여전히 변수가 선택 사항으로 간주되므로 널 안전성이 필요합니다.</p>\n<pre><code class=\"hljs language-kotlin\">fetchedUserId?.let { userId ->\n  <span class=\"hljs-comment\">// userId가 옵셔널이 아닌 것으로 사용할 수 있습니다</span>\n} ?: <span class=\"hljs-keyword\">throw</span> Exception(<span class=\"hljs-string\">\"사용자 ID가 누락되었습니다\"</span>)\n</code></pre>\n<h2>보호자</h2>\n<p>또 다른 일반적인 패턴은 가드문입니다. 이는 if let 패턴과 유사합니다. 주로 함수 내에서 조기에 종료할 때 사용됩니다. 다른 점은 else 블록이 필수적이라는 것입니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">checkUsernameValid</span>(<span class=\"hljs-params\">username</span>: <span class=\"hljs-type\">String</span>?) -> <span class=\"hljs-type\">Bool</span> {\n    <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> username <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-comment\">// username이 nil이므로 평가할 수 없습니다</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n    <span class=\"hljs-comment\">// username을 옵셔널이 아닌 것으로 사용할 수 있습니다</span>\n    <span class=\"hljs-keyword\">return</span> username.count <span class=\"hljs-operator\">></span> <span class=\"hljs-number\">3</span>\n}\n</code></pre>\n<p>위의 코드에서 함수는 선택적으로 변수 username을 받습니다. 그런 다음 guard문을 사용하여 username이 값이 있는지 확인합니다. 값이 없는 경우 함수를 종료합니다. 값이 있는 경우 나머지 함수에서는 username을 선택사항이 아닌 것처럼 사용할 수 있습니다.</p>\n<p>Kotlin\nKotlin에서는 몇 가지 다른 방법으로 이를 작성할 수 있습니다. 두 가지 제안을 보여드리겠습니다:</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title function_\">checkUsernameValid</span>(<span class=\"hljs-attr\">username</span>: <span class=\"hljs-title class_\">String</span>?): <span class=\"hljs-title class_\">Boolean</span> {\n    <span class=\"hljs-keyword\">if</span> (username.<span class=\"hljs-title function_\">isNullOrEmpty</span>()){\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    }\n    <span class=\"hljs-keyword\">return</span> username.<span class=\"hljs-property\">length</span> > <span class=\"hljs-number\">3</span>\n}\n\n<span class=\"hljs-comment\">// 또는</span>\n\nfun <span class=\"hljs-title function_\">checkUsernameValid</span>(<span class=\"hljs-attr\">username</span>: <span class=\"hljs-title class_\">String</span>?): <span class=\"hljs-title class_\">Boolean</span> {\n    val actualUsername = username ?: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n    <span class=\"hljs-keyword\">return</span> actualUsername.<span class=\"hljs-property\">length</span> > <span class=\"hljs-number\">3</span>\n}\n</code></pre>\n<h1>4. Enums</h1>\n<p>Swift에서는 enum 키워드를 사용하여 열거형을 정의합니다. 값은 case 키워드를 사용하고 그 뒤에 열거형 케이스의 이름을 작성합니다. 열거형 케이스의 이름은 소문자로 작성하는 것이 권장되며 단수형으로 작성하는 것이 좋습니다. 각 케이스를 새로운 줄에 작성해야 합니다. 여러 케이스를 한 줄에 작성할 때는 쉼표로 구분합니다.</p>\n<pre><code class=\"hljs language-js\">enum <span class=\"hljs-title class_\">Direction</span> {\n    <span class=\"hljs-keyword\">case</span> left\n    <span class=\"hljs-keyword\">case</span> up\n    <span class=\"hljs-keyword\">case</span> right\n    <span class=\"hljs-keyword\">case</span> down\n}\n\n<span class=\"hljs-comment\">// 또는</span>\n\nenum <span class=\"hljs-title class_\">Direction</span> {\n    <span class=\"hljs-keyword\">case</span> left, up, right, down\n}\n</code></pre>\n<p>enum 케이스를 사용하려면 유형(Direction)과 사용하려는 케이스를 참조합니다. 나중에 유형을 생략하고 더 짧은 점 구문을 사용하여 케이스를 직접 참조할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> selectedDirection = <span class=\"hljs-title class_\">Direction</span>.<span class=\"hljs-property\">up</span>\nselectedDirection = .<span class=\"hljs-property\">right</span>\n</code></pre>\n<p>열거형 값 확인을 위해 switch 문을 사용할 수 있습니다. Xcode는 switch 문의 모든 분기를 자동으로 작성합니다. 열거형에 대한 switch 문이 전체적이어야 하기 때문입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">switch</span>(selectedDirection){\n<span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">left</span>:\n    <span class=\"hljs-title function_\">goLeft</span>()\n<span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">up</span>:\n    <span class=\"hljs-title function_\">goForward</span>()\n<span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">right</span>:\n    <span class=\"hljs-title function_\">goRight</span>()\n<span class=\"hljs-keyword\">case</span> .<span class=\"hljs-property\">down</span>:\n    <span class=\"hljs-title function_\">goBackward</span>()\n}\n</code></pre>\n<p>Swift 열거형은 연관 값도 지원합니다. 즉, 각 열거형 케이스마다 다른 수의 값 유형을 가질 수 있습니다. 이는 Kotlin의 sealed class와 유사한 강력한 도메인 모델링 도구 역할을 합니다.</p>\n<p>더 알아보기: <a href=\"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations\" rel=\"nofollow\" target=\"_blank\">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations</a></p>\n<h2>코틀린</h2>\n<p>코틀린에서는 enum 클래스 키워드를 사용하여 Enum을 정의합니다. 값은 쉼표로 구분하여 정의합니다. Enum 값 이름은 일반적으로 대문자로 작성하는 것이 관례이지만, 프로젝트의 스타일에 따라 다를 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">enum <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Direction</span> {\n    <span class=\"hljs-variable constant_\">LEFT</span>, <span class=\"hljs-variable constant_\">UP</span>, <span class=\"hljs-variable constant_\">RIGHT</span>, <span class=\"hljs-variable constant_\">DOWN</span>\n}\n</code></pre>\n<p>Enum을 사용할 때는 클래스 이름과 사용하려는 값으로 참조합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> selectedDirection = <span class=\"hljs-title class_\">Direction</span>.<span class=\"hljs-property\">UP</span>;\n</code></pre>\n<p>우리는 값 확인을 위해 when 문을 사용할 수 있습니다. 가능한 모든 열거형 값을 포함해야합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">when</span>(<span class=\"hljs-params\">selectedDirection</span>){\n    <span class=\"hljs-title class_\">Direction</span>.<span class=\"hljs-property\">LEFT</span> -> <span class=\"hljs-title function_\">goLeft</span>()\n    <span class=\"hljs-title class_\">Direction</span>.<span class=\"hljs-property\">UP</span> -> <span class=\"hljs-title function_\">goForward</span>()\n    <span class=\"hljs-title class_\">Direction</span>.<span class=\"hljs-property\">RIGHT</span> -> <span class=\"hljs-title function_\">goRight</span>()\n    <span class=\"hljs-title class_\">Direction</span>.<span class=\"hljs-property\">DOWN</span> -> <span class=\"hljs-title function_\">goBackward</span>()\n}\n</code></pre>\n<p>Kotlin 열거형 클래스는 각 열거형 값이 값을 제공해야하는 추가 속성을 정의하는 것을 지원합니다. 그러나 Swift의 관련 값과 달리 속성은 클래스 수준에 있으며 값 레벨이 아니므로 각 값에 대해 동일한 형식이어야 합니다.</p>\n<p>아래는 Kotlin 공식 문서 링크입니다: <a href=\"https://kotlinlang.org/docs/enum-classes.html\" rel=\"nofollow\" target=\"_blank\">https://kotlinlang.org/docs/enum-classes.html</a></p>\n<h1>5. 사전 / 맵</h1>\n<p>Swift의 딕셔너리와 Kotlin의 맵 사이의 구문은 매우 다르지만 비슷한 기본 개념을 사용합니다.</p>\n<h2>Kotlin</h2>\n<p>딕셔너리는 키와 값을 동일한 유형으로 연결해주는 Swift의 데이터 구조입니다. 키-값 쌍은 순서가 없이 저장됩니다. 각 키는 연결된 값을 액세스하기 위한 기준값을 나타냅니다.</p>\n<p>딕셔너리를 선언하려면 키-값 쌍을 [Key: Value] 형식으로 대괄호 안에 쉼표로 구분하여 정의합니다. 최소 하나의 키-값 쌍을 정의하면 형식 선언을 생략할 수 있어 컴파일러가 유형을 결정할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">httpErrorCodes</span>: [<span class=\"hljs-title class_\">Int</span>: <span class=\"hljs-title class_\">String</span>] = [<span class=\"hljs-number\">404</span>: <span class=\"hljs-string\">\"Not found\"</span>, <span class=\"hljs-number\">401</span>: <span class=\"hljs-string\">\"Unauthorized\"</span>]\n</code></pre>\n<p>키를 사용하여 딕셔너리에서 값을 읽기 위해 서브스크립트 구문(dictionary[key])을 사용할 수 있습니다. 딕셔너리에 키가 없으면 nil을 반환합니다. ?? 연산자를 사용하여 기본값을 제공할 수도 있습니다.</p>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">getHttpErrorCodeMessage</span>(<span class=\"hljs-attr\">code</span>: <span class=\"hljs-title class_\">Int</span>) -> <span class=\"hljs-title class_\">String</span> {\n    <span class=\"hljs-keyword\">let</span> errorCodeMessage = httpErrorCodes[code] ?? <span class=\"hljs-string\">\"Unknown\"</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Http error code \\(errorCodeMessage)\"</span>\n}\n</code></pre>\n<p>딕셔너리에 새로운 값을 쓰려면 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍을 컬렉션에 추가합니다. 키가 이미 존재하면 값을 업데이트합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 새로운 키:값 쌍 추가</span>\nhttpErrorCodes[<span class=\"hljs-number\">500</span>] = <span class=\"hljs-string\">\"Internal Server Error\"</span>;\n\n<span class=\"hljs-comment\">// 기존 키의 값 업데이트</span>\nhttpErrorCodes[<span class=\"hljs-number\">401</span>] = <span class=\"hljs-string\">\"Requires authentication\"</span>;\n</code></pre>\n<p>가변 또는 불변(읽기 전용) 딕셔너리를 사용하는지는 할당에 달려있습니다. let을 사용하면 선언한 후에만 읽을 수 있는 딕셔너리를 정의합니다. 쓰기를 지원하려면 var로 선언해야 합니다.</p>\n<p>자세히 읽기: <a href=\"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Dictionaries\" rel=\"nofollow\" target=\"_blank\">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Dictionaries</a></p>\n<h2>Kotlin</h2>\n<p>맵은 고유한 키와 값의 쌍을 보유하고 각 키에 해당하는 값을 효율적으로 가져오는 컬렉션입니다.</p>\n<p>Kotlin에서 불변(읽기 전용) 맵을 선언하려면 Map<code>KeyType, ValueType</code> 유형을 사용하고 mapOf(varargs pairs: Pair<code>KeyType, ValueType</code>) 표준 라이브러리 함수를 사용하여 초기화합니다. 적어도 하나의 키-값 쌍을 제공하면 명시적인 변수 유형 선언을 생략할 수 있습니다. 컴파일러가 유형을 결정할 수 있기 때문입니다.</p>\n<p>값을 선언할 때 Pair(key, value) 클래스를 직접 사용하거나 객체를 만들어주는 to 인픽스 함수를 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-keyword\">val</span> httpErrorCodes: Map&#x3C;<span class=\"hljs-built_in\">Int</span>, String> = mapOf(\n    <span class=\"hljs-number\">404</span> to <span class=\"hljs-string\">\"찾을 수 없음\"</span>,\n    Pair(<span class=\"hljs-number\">401</span>, <span class=\"hljs-string\">\"권한이 없음\"</span>),\n)\n</code></pre>\n<p>키를 사용하여 맵에서 값을 읽을 때 대괄호 표기법(map[key])을 사용할 수 있습니다. 키가 맵에 존재하지 않으면 null이 반환됩니다. ?: 연산자를 사용하여 기본값을 제공할 수 있습니다.</p>\n<pre><code class=\"hljs language-kotlin\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">fun</span> <span class=\"hljs-title\">getHttpErrorCodeMessage</span><span class=\"hljs-params\">(code: <span class=\"hljs-type\">Int</span>)</span></span>: String {\n    <span class=\"hljs-keyword\">val</span> errorCodeMessage = httpErrorCodes[code] ?: <span class=\"hljs-string\">\"알 수 없음\"</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Http 오류 코드: <span class=\"hljs-variable\">$errorCodeMessage</span>\"</span>\n}\n</code></pre>\n<p>맵에 새로운 값을 작성하려면 MutableMap KeyType, ValueType 형식과 mutableMapOf() 팩토리 함수를 사용하여 가변 맵을 선언해야 합니다. 그런 다음 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍이 컬렉션에 추가됩니다. 키가 이미 존재하면 해당 값을 업데이트합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 새 키:값 쌍 추가</span>\nhttpErrorCodes[<span class=\"hljs-number\">500</span>] = <span class=\"hljs-string\">\"내부 서버 오류\"</span>;\n\n<span class=\"hljs-comment\">// 기존 키에 대한 값 업데이트</span>\nhttpErrorCodes[<span class=\"hljs-number\">401</span>] = <span class=\"hljs-string\">\"인증이 필요함\"</span>;\n</code></pre>\n<p>더 읽어보기: <a href=\"https://www.baeldung.com/kotlin/maps\" rel=\"nofollow\" target=\"_blank\">https://www.baeldung.com/kotlin/maps</a></p>\n<h1>6. 확장</h1>\n<p>확장(extension)은 기존 클래스나 구조체에 새로운 기능을 추가하는 방법입니다. 때로는 코드에 액세스할 수 없는 것들에 대해서도 확장을 적용할 수 있습니다.</p>\n<p>Swift에서는 extension 키워드를 사용하여 확장을 정의할 수 있습니다. 확장은 다른 클래스나 구조체 외부의 최상위 레벨에서 선언되어야 합니다.</p>\n<pre><code class=\"hljs language-js\">extension <span class=\"hljs-title class_\">String</span> {\n    func <span class=\"hljs-title function_\">doubled</span>() -> <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-keyword\">return</span> self + self\n    }\n}\n</code></pre>\n<p>위 예제에서는 String 타입에 doubled() 확장 함수를 정의했습니다. 이제 이 함수를 문자열의 인스턴스에서 호출할 수 있으며 마치 원래 정의에 포함된 것처럼 사용할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> originalStr = <span class=\"hljs-string\">\"Swift\"</span>;\n<span class=\"hljs-keyword\">let</span> doubledStr = originalStr.<span class=\"hljs-title function_\">doubled</span>();\n<span class=\"hljs-title function_\">print</span>(doubledStr); <span class=\"hljs-comment\">// prints \"SwiftSwift\"</span>\n</code></pre>\n<h2>Kotlin</h2>\n<p>Kotlin은 동일한 방식으로 작동하는 확장 함수를 사용하며 기존 클래스에 새 기능을 추가할 수 있습니다. 우리는 확장하려는 클래스 이름과 함께 점과 함수 이름이 이어지는 최상위 함수로 정의합니다.</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title class_\">String</span>.<span class=\"hljs-title function_\">doubled</span>(): <span class=\"hljs-title class_\">String</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span> + <span class=\"hljs-variable language_\">this</span>\n}\n</code></pre>\n<p>이제 이 함수를 사용하여 원래 정의의 일부인 문자열 인스턴스에서 호출할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">val originalStr = <span class=\"hljs-string\">\"Kotlin\"</span>\nval doubledStr = originalStr.<span class=\"hljs-title function_\">doubled</span>()\n<span class=\"hljs-title function_\">println</span>(doubledStr) <span class=\"hljs-comment\">// \"KotlinKotlin\" 출력</span>\n</code></pre>\n<h1>7. 프로토콜</h1>\n<p>Swift에서 프로토콜은 클래스, 구조체 또는 열거형이 해당 요구 사항의 실제 구현을 제공함으로써 채택할 수 있는 속성, 메서드 및 기타 요구 사항의 집합입니다.</p>\n<p>프로토콜을 정의할 때는 프로토콜 키워드 뒤에 프로토콜 이름을 붙이면 됩니다. 이는 구조체나 클래스 선언과 유사합니다. 프로토콜 내부에서는 get할 수 있는(' get ') 또는 get과 set이 모두 가능한(' get set ') 속성을 정의할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">protocol <span class=\"hljs-title class_\">RequestError</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-title class_\">Int</span> { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isRecoverable</span>: <span class=\"hljs-title class_\">Bool</span> { get set }\n}\n\nprotocol <span class=\"hljs-title class_\">PrintableError</span> {\n    func <span class=\"hljs-title function_\">buildErrorMessage</span>() -> <span class=\"hljs-title class_\">String</span>\n}\n</code></pre>\n<p>위 예시에서는 RequestError라는 프로토콜을 정의했는데, 이 프로토콜에는 errorCode라는 get할 수 있는 속성과 isRecoverable이라는 set이 가능한 속성이 포함되어 있습니다. 또한, adopter가 구현해야 하는 buildErrorMessage() 함수를 포함하는 PrintableError라는 프로토콜도 정의했습니다.</p>\n<p>프로토콜을 채택하기 위해서는 클래스나 구조체를 정의하고 이름 뒤에 : ProtocolName을 추가해야 합니다. 여러 프로토콜을 선언하려면 쉼표를 사용하면 됩니다. 그런 다음 클래스나 구조체의 본문에서 프로토콜로부터 요구되는 내용을 정의해야 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServerHttpError</span>: <span class=\"hljs-title class_\">RequestError</span>, <span class=\"hljs-title class_\">PrintableError</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-title class_\">Int</span> = <span class=\"hljs-number\">500</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isRecoverable</span>: <span class=\"hljs-title class_\">Bool</span> = <span class=\"hljs-literal\">false</span>\n\n    func <span class=\"hljs-title function_\">buildErrorMessage</span>() -> <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Server side http error with error code \\(errorCode)\"</span>\n    }\n}\n\nstruct <span class=\"hljs-title class_\">ConnectionError</span>: <span class=\"hljs-title class_\">RequestError</span>, <span class=\"hljs-title class_\">PrintableError</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-title class_\">Int</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isRecoverable</span>: <span class=\"hljs-title class_\">Bool</span>\n\n    func <span class=\"hljs-title function_\">buildErrorMessage</span>() -> <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Local connection error\"</span>\n    }\n}\n</code></pre>\n<p>우리는 RequestError와 PrintableError 프로토콜을 채택하는 ServerHttpError 클래스를 정의했고, 두 속성의 기본값과 함수의 구현을 정의했습니다. 또한 두 속성을 선언하고 함수의 구현을 제공하는 ConnectionError 구조체를 가지고 있습니다.</p>\n<p>이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고 이들을 RequestError 또는 PrintableError 유형으로 전달할 수 있습니다. RequestError 유형을 수락하는 onRequestError() 함수에서 error가 PrintableError 프로토콜을 준수하는지 확인하여 오류 메시지를 구성합니다.</p>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">onRequestError</span>(<span class=\"hljs-params\">error: RequestError</span>) {\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> printableError = error <span class=\"hljs-keyword\">as</span>? <span class=\"hljs-title class_\">PrintableError</span> {\n        <span class=\"hljs-title function_\">print</span>(printableError.<span class=\"hljs-title function_\">buildErrorMessage</span>())\n    }\n    <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Is recoverable: \\(error.isRecoverable)\"</span>)\n}\n\n<span class=\"hljs-keyword\">let</span> firstError = <span class=\"hljs-title class_\">ServerHttpError</span>()\nfirstError.<span class=\"hljs-property\">errorCode</span> = <span class=\"hljs-number\">503</span>\nfirstError.<span class=\"hljs-property\">isRecoverable</span> = <span class=\"hljs-literal\">false</span>\n\n<span class=\"hljs-keyword\">let</span> secondError = <span class=\"hljs-title class_\">ConnectionError</span>(<span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-number\">404</span>, <span class=\"hljs-attr\">isRecoverable</span>: <span class=\"hljs-literal\">true</span>)\n\n<span class=\"hljs-comment\">// \"Server side http error with error code 503. Is recoverable: false\"</span>\n<span class=\"hljs-title function_\">onRequestError</span>(<span class=\"hljs-attr\">error</span>: firstError)\n<span class=\"hljs-comment\">// \"Local connection error. Is recoverable: true\"</span>\n<span class=\"hljs-title function_\">onRequestError</span>(<span class=\"hljs-attr\">error</span>: secondError)\n</code></pre>\n<p>이것은 프로토콜을 사용하는 간단한 예시입니다. Swift의 프로토콜은 상속, 합성, 연관 타입, 제네릭 등과 같이 더 고급적인 사용 사례를 지원합니다. 더 많은 내용은 <a href=\"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols에서</a> 확인할 수 있어요.</p>\n<h2>Kotlin</h2>\n<p>위의 예시는 인터페이스, 추상 클래스, sealed 클래스 등을 사용하여 Kotlin으로 여러 방법으로 작성할 수 있습니다. 그러나 Swift의 프로토콜을 가장 가깝게 표현하는 것은 아마도 인터페이스일 것입니다. 이는 속성과 함수를 정의하며, 상속, 구성, 그리고 제네릭을 지원합니다.</p>\n<p>인터페이스를 정의할 때는 interface 키워드를 사용하고 이름을 이어서 작성합니다. 본문에서는 속성과 함수를 정의합니다. 읽기 전용 속성은 val 키워드를 사용하여 정의하고, 읽기/쓰기 속성은 var 키워드를 사용합니다.</p>\n<p>이 인터페이스를 구현하도록 클래스에 지정하는 방법은, 클래스 이름 뒤에 InterfaceName을 사용합니다. 여러 인터페이스를 구현하려면 쉼표를 사용합니다. 그런 다음 모든 속성과 함수를 override 키워드와 함께 정의해야 합니다.</p>\n<pre><code class=\"hljs language-js\">interface <span class=\"hljs-title class_\">RequestError</span> {\n    val <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-title class_\">Int</span>\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isRecoverable</span>: <span class=\"hljs-title class_\">Boolean</span>\n}\n\ninterface <span class=\"hljs-title class_\">PrintableError</span> {\n    fun <span class=\"hljs-title function_\">buildErrorMessage</span>(): <span class=\"hljs-title class_\">String</span>\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ServerHttpError</span>(\n    override val <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-title class_\">Int</span>,\n    override <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isRecoverable</span>: <span class=\"hljs-title class_\">Boolean</span>\n) : <span class=\"hljs-title class_\">RequestError</span>, <span class=\"hljs-title class_\">PrintableError</span> {\n    override fun <span class=\"hljs-title function_\">buildErrorMessage</span>(): <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Server side http error with error code $errorCode\"</span>\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConnectionError</span> : <span class=\"hljs-title class_\">RequestError</span>, <span class=\"hljs-title class_\">PrintableError</span> {\n    override val <span class=\"hljs-attr\">errorCode</span>: <span class=\"hljs-title class_\">Int</span>\n        <span class=\"hljs-title function_\">get</span>() = <span class=\"hljs-number\">404</span>\n    override <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">isRecoverable</span>: <span class=\"hljs-title class_\">Boolean</span> = <span class=\"hljs-literal\">true</span>\n\n    override fun <span class=\"hljs-title function_\">buildErrorMessage</span>(): <span class=\"hljs-title class_\">String</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Local connection error\"</span>\n    }\n}\n</code></pre>\n<p>이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고, 함수에 RequestError 유형으로 전달할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">fun <span class=\"hljs-title function_\">onRequestError</span>(<span class=\"hljs-params\">error: RequestError</span>) {\n    <span class=\"hljs-keyword\">if</span> (error is <span class=\"hljs-title class_\">PrintableError</span>) {\n        <span class=\"hljs-title function_\">println</span>(error.<span class=\"hljs-title function_\">buildErrorMessage</span>())\n    }\n    <span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">\"$errorMessage. Is recoverable: ${error.isRecoverable}\"</span>)\n}\n\nval firstError = <span class=\"hljs-title class_\">ServerHttpError</span>(errorCode = <span class=\"hljs-number\">503</span>, isRecoverable = <span class=\"hljs-literal\">false</span>)\nval secondError = <span class=\"hljs-title class_\">ConnectionError</span>()\n<span class=\"hljs-comment\">// \"Server side http error with error code 503. Is recoverable: false\"</span>\n<span class=\"hljs-title function_\">onRequestError</span>(firstError)\n<span class=\"hljs-comment\">// \"Local connection error. Is recoverable: true\"</span>\n<span class=\"hljs-title function_\">onRequestError</span>(secondError)\n</code></pre>\n<p>Read more at <a href=\"https://kotlinlang.org/docs/interfaces.html\" rel=\"nofollow\" target=\"_blank\">https://kotlinlang.org/docs/interfaces.html</a></p>\n<h1>결론</h1>\n<p>일반적인 Swift 패턴을 이해하고 Kotlin에서 어떻게 번역되는지 알면 코드가 하는 일을 더 잘 이해할 수 있습니다. 이웃 플랫폼에서 어떤 기능이 구현되었는지 보거나 코드 검토를 수행하거나 기술 사양/제안서를 검토하거나 작업을 Kotlin Multiplatform으로 수행하는 여러 방법이 있습니다.</p>\n<p>Swift 언어의 기본적인 내용과 Kotlin과 비교하는 방법을 살펴보았습니다. 또한, 선택적 바인딩, 딕셔너리, 익스텐션, 구조 및 프로토콜과 같은 전형적인 iOS 프로젝트에서 발견할 수 있는 일반적인 패턴에 대해서도 다루었습니다.</p>\n<p>이 문이 도움이 되었다면 댓글로 알려주세요! Swift 코드를 읽거나 검토하거나 작성하는 경험에 대해 공유하는 것을 장려합니다.</p>\n<p>참고 자료:</p>\n<ul>\n<li><a href=\"https://kotlinlang.org/docs/home.html\" rel=\"nofollow\" target=\"_blank\">https://kotlinlang.org/docs/home.html</a></li>\n<li><a href=\"https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics\" rel=\"nofollow\" target=\"_blank\">https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics</a></li>\n</ul>\n<p>Andrej Rolih 님의 검토와 피드백에 감사드립니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}