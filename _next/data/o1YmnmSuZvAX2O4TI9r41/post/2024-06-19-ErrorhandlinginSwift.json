{"pageProps":{"post":{"title":"Swift에서의 오류 처리","description":"","date":"2024-06-19 11:08","slug":"2024-06-19-ErrorhandlinginSwift","content":"\n\n## 사용자에게 경고하기 위해 do-catch 문과 사용자 정의 오류를 던지는 방법 (코드 예제와 함께)\n\n에러 처리는 모든 앱의 기본적인 부분입니다.\n\n사용자가 수행하는 모든 조치가 성공하는 것은 아닙니다. 일부는 실패할 것이며, 우리의 앱은 사용자에게 일어난 일을 쉽게 알려주고 문제를 피하기 위해 무엇을 시도할 수 있는지 알려줘야 합니다.\n\n간단한 throw 및 do-catch 문을 사용하여 간단한 에러 처리를 어떻게 달성할 수 있는지 보여드릴게요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-에러핸들링인Swif_0.png\" />\n\n## 에러 정의 및 던지기\n\n에러를 표현하려면 Error 프로토콜을 준수하는 타입을 사용해야 합니다. 이는 아무런 제약이 없는 빈 프로토콜이며, 우리가 가장 잘 적합한 타입으로 에러를 정의할 수 있다는 것을 의미합니다.\n\n일반적으로 enum이 시작하기에 가장 좋은 방법입니다. 네트워크 에러를 처리하고 싶다고 가정해보면, 아래 enum을 정의할 수 있습니다👇\n\n<div class=\"content-ad\"></div>\n\n```js\n열거형 NetworkError: 오류 {\n    case unexpected\n    case invalidURL(_ url: URL)\n    case apiError(statusCode: Int)\n}\n```\n\n백엔드 API로 요청을 수행할 때 오류가 발생하면 NetworkError를 던질 수 있습니다.\n\n```js\n열거형 ApiMethod {...}\n구조체 ApiRequest {...}\n\nfunc createRequest(from url: String, method: ApiMethod) throws -> ApiRequest {\n  guard let URL = URL(string: url) else {\n    throw NetworkError.invalidURL(url)\n  }\n  ...\n}\n```\n\n## 오류 처리\n\n<div class=\"content-ad\"></div>\n\n우리는 사용자 정의 오류를 갖고 있고, 이를 throw하고 있습니다. 하지만, 이를 어떻게 잡을 수 있을까요?\n\n다른 많은 언어와 마찬가지로, Swift에는 do-catch 문이 있습니다. 만약 do 절 내에서 오류가 throw되면, 실행은 catch 절로 전달되고 오류는 로컬 상수 error에 저장됩니다.\n\n```js\ndo {\n  let result = try createRequest(from: \"//myapi.com/\", method: .GET)\n} catch {\n  print(error)\n  // 적절한 처리를 수행\n}\n```\n\n가끔씩 우리는 잡은 오류 형식(또는 오류 값)에 따라 특정 작업을 트리거하길 원합니다. 이를 패턴을 사용하여 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ndo {\n  let result = try makeRequest(to: \"//myapi.com/\", method: .GET)\n} catch NetworkError.invalidUrl(let url) {\n  // ...\n} catch {\n  print(error)\n  // \n}\n```\n\n## 에러 전파하기\n\n던져진 함수는 함수 내에서 발생한 에러를 호출자의 범위로 전파할 수 있습니다.\n\n```js\nstruct User: Decodable {\n    let name: String\n    let age: Int\n}\n\nfunc decodeJSON<T: Decodable>(_ jsonString: String) throws -> T {\n    let jsonData = Data(jsonString.utf8)\n    let decodedObject = try JSONDecoder().decode(T.self, from: jsonData)\n    return decodedObject\n}\n\nfunc getUserFromJSON(_ jsonString: String) -> User? {\n    do {\n        let user: User = try decodeJSON(jsonString)\n        return user\n    } catch {\n        print(error)\n        return nil\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## try? & try!\n\n가끔은 던지는 함수로 발생한 오류에 대해 신경 쓰지 않을 수 있습니다. 이런 상황에서는 do-catch 문을 사용하지 않고 try? 지시어를 사용할 수 있습니다.\n\ntry?를 사용하면 호출하는 함수가 옵셔널이 됩니다. 즉, 반환 값을 가진 함수를 호출하는 경우 값은 nil이 됩니다.\n\n```js\nlet request = try? createRequest(from: \"malformedurl\", method: .GET)\n// request = nil\n```\n\n<div class=\"content-ad\"></div>\n\n한편, 때때로 특정한 던지기 함수가 런타임에서 실패하지 않을 것을 확신할 수 있습니다. 이런 경우에는 try!를 사용할 수 있습니다. 그리고 try?와 마찬가지로 do-catch 클로저를 사용할 필요가 없습니다.\n\n```js\nlet request = try! createRequest(from: \"https://myapi.com/\", method: .GET)\n```\n\n## 비동기 코드\n\n에러를 던지는 것은 비동기 코드와 잘 작동합니다. 함수 선언에서 throws 키워드 앞에 async 키워드를 넣어주어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n비동기 함수를 호출할 때는 try await (키워드 순서 스와이프)를 사용합니다.\n\n```js\nfunc performRequest(with request: ApiRequest) async throws -> ApiResult {...}\n\n// ----------------\n\ndo {\n  let request = try makeRequest(to: \"https://myapi.com/users\", method: .GET)\n  let apiRestul = try await performRequest(with: request)\n} catch NetworkError.invalidUrl(let url) {\n  // ...\n} catch {\n  print(error)\n  // \n}\n```\n\n# 사용자에게 알림\n\n에러 구조를 구축했으니, 이제 사용자들에게 무엇이 잘못되었는지 알려줄 필요가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"https://miro.medium.com/v2/resize:fit:592/1*cfrDQghry5EPpPhMSFFDaA.gif\" />\n\n각각의 오류에 대한 설명 은 오류가 처음에 발생한 이유입니다.\n사용자가 사용자를 피할 수 있는 가능한 조치입니다.\n\n우리는 Error enum에 해당 정보를 변수로 추가할 수 있습니다. 그러나 이미 모든 이 정보를 그룹화하기 위한 프로토콜이 있습니다: LocalizedError. 우리의 사용 사례에서 우리는 failureReason 및 recoverySuggestion 변수 만 구현하면 됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n```swift\nenum OrderError: LocalizedError {\n  case unexpected\n  case outOfCoffee(coffee: Coffee)\n  case minimumNotMet(currentPrice: Float)\n  \n  var failureReason: String? {\n    switch self {\n    case .unexpected:\n      return \"주문 처리 중 문제가 발생했습니다.\"\n    case .outOfCoffee(let coffee):\n      return \"\\(coffee.name)가 다 떨어졌어요.\"\n    case .minimumNotMet:\n      return \"앱에서 주문하려면 최소 $10 이상 사용해야 합니다.\"\n    }\n  }\n  \n  var recoverySuggestion: String? {\n    switch self {\n    case .unexpected:\n      return \"몇 분 후에 다시 시도해주세요.\"\n    case .outOfCoffee:\n      return \"다른 종류의 커피로 변경해보세요.\"\n    case .minimumNotMet(let currentPrice):\n      return \"주문에 $\\(10-currentPrice) 더 추가해주세요.\"\n    }\n  }\n}\n```\n\n여기에서 작업이 완료됩니다. 그러나 앱에 통합된 로깅 솔루션이 있다면, 오류 구조를 확장하여 추가 정보를 추가할 수 있습니다.\n\n```swift\nimport Foundation\nimport HKLogger\n\nstruct AppError: Error {\n  let type: LocalizedError\n  var userMessage: String {\n    return \"\\(type.failureReason ?? ErrorConstants.defaultError) \\n\\n \\(type.recoverySuggestion ?? ErrorConstants.defaultAction)\"\n  }\n  // 필요한 만큼 많은 속성을 추가\n  \n  init(type: LocalizedError, debugInfo: String? = nil) {\n      self.type = type\n      guard let debugInfo else { return }\n      HKLogger.shared.error(message: debugInfo)\n  }\n}\n```\n\n이렇게 함으로써 로깅 오류 로직을 한 곳에 중앙 집중화할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n마침내 사용자 정의 AppError를 사용하여 경고를 표시하는 간단한 View 확장을 만들 수 있습니다.\n\n```js\nextension View {\n    func alert(isPresented: Binding<Bool>, withError error: AppError?) -> some View {\n        return alert(\n            \"Ups! :(\",\n            isPresented: isPresented,\n            actions: {\n                Button(\"Ok\") {}\n            }, message: {\n                Text(error?.userMessage ?? \"\")\n            }\n        )\n    }\n}\n\n// ---------------------------------------------------\n\nstruct OrderConfirmationView: View {\n  @StateObject private var viewModel = ConfirmationViewModel()\n\n  var body: some View {\n    VStack(alignment: .leading) {\n      // ...\n      Button(\"주문하기\") {\n        viewModel.tryToPlaceOrder(order)\n      }\n    }\n    .alert(isPresented: $viewModel.showError, withError: viewModel.appError)\n  }\n}\n\n// ---------------------------------------------------\n\n@Observable\nfinal class ConfirmationViewModel: ObservableObject {\n    var appError: AppError?\n    var showError = false\n    \n    func tryToPlaceOrder(_ order: Order) {\n        do {\n            try OrdersManager.shared.add(order)\n        } catch let error as AppError {\n            showError = true\n            appError = error\n        } catch {\n            appError = AppError(type: OrderError.unexpected)\n        }\n    }\n}\n\n// ---------------------------------------------------\n\nfinal class OrdersManager {\n  // ...\n  func add(_ order: Order) throws {\n    if order.price >= 10 {\n      orders.append(order)\n    } else {\n      throw AppError(type: OrderError.minimumNotMet(currentPrice: order.price))\n    }\n  }\n}\n```\n\n질문이 있으신가요? 언제든지 메시지를 남겨주세요! 🙂\n\n- 🤓 iOS 개발 팁과 통찰력에 관한 콘텐츠를 X에서 함께 확인해보세요.\n- 🚀 모든 예제 프로젝트를 공유하는 내 GitHub를 확인해보세요 (이것도 포함됩니다 😉)","ogImage":{"url":"/assets/img/2024-06-19-ErrorhandlinginSwift_0.png"},"coverImage":"/assets/img/2024-06-19-ErrorhandlinginSwift_0.png","tag":["Tech"],"readingTime":7},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>사용자에게 경고하기 위해 do-catch 문과 사용자 정의 오류를 던지는 방법 (코드 예제와 함께)</h2>\n<p>에러 처리는 모든 앱의 기본적인 부분입니다.</p>\n<p>사용자가 수행하는 모든 조치가 성공하는 것은 아닙니다. 일부는 실패할 것이며, 우리의 앱은 사용자에게 일어난 일을 쉽게 알려주고 문제를 피하기 위해 무엇을 시도할 수 있는지 알려줘야 합니다.</p>\n<p>간단한 throw 및 do-catch 문을 사용하여 간단한 에러 처리를 어떻게 달성할 수 있는지 보여드릴게요.</p>\n<h2>에러 정의 및 던지기</h2>\n<p>에러를 표현하려면 Error 프로토콜을 준수하는 타입을 사용해야 합니다. 이는 아무런 제약이 없는 빈 프로토콜이며, 우리가 가장 잘 적합한 타입으로 에러를 정의할 수 있다는 것을 의미합니다.</p>\n<p>일반적으로 enum이 시작하기에 가장 좋은 방법입니다. 네트워크 에러를 처리하고 싶다고 가정해보면, 아래 enum을 정의할 수 있습니다👇</p>\n<pre><code class=\"hljs language-js\">열거형 <span class=\"hljs-title class_\">NetworkError</span>: 오류 {\n    <span class=\"hljs-keyword\">case</span> unexpected\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">invalidURL</span>(_ <span class=\"hljs-attr\">url</span>: <span class=\"hljs-variable constant_\">URL</span>)\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-title function_\">apiError</span>(<span class=\"hljs-attr\">statusCode</span>: <span class=\"hljs-title class_\">Int</span>)\n}\n</code></pre>\n<p>백엔드 API로 요청을 수행할 때 오류가 발생하면 NetworkError를 던질 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">열거형 <span class=\"hljs-title class_\">ApiMethod</span> {...}\n구조체 <span class=\"hljs-title class_\">ApiRequest</span> {...}\n\nfunc <span class=\"hljs-title function_\">createRequest</span>(<span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">url</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">method</span>: <span class=\"hljs-title class_\">ApiMethod</span>) throws -> <span class=\"hljs-title class_\">ApiRequest</span> {\n  guard <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable constant_\">URL</span> = <span class=\"hljs-title function_\">URL</span>(<span class=\"hljs-attr\">string</span>: url) <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-title function_\">invalidURL</span>(url)\n  }\n  ...\n}\n</code></pre>\n<h2>오류 처리</h2>\n<p>우리는 사용자 정의 오류를 갖고 있고, 이를 throw하고 있습니다. 하지만, 이를 어떻게 잡을 수 있을까요?</p>\n<p>다른 많은 언어와 마찬가지로, Swift에는 do-catch 문이 있습니다. 만약 do 절 내에서 오류가 throw되면, 실행은 catch 절로 전달되고 오류는 로컬 상수 error에 저장됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">do</span> {\n  <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title function_\">createRequest</span>(<span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">\"//myapi.com/\"</span>, <span class=\"hljs-attr\">method</span>: .<span class=\"hljs-property\">GET</span>)\n} <span class=\"hljs-keyword\">catch</span> {\n  <span class=\"hljs-title function_\">print</span>(error)\n  <span class=\"hljs-comment\">// 적절한 처리를 수행</span>\n}\n</code></pre>\n<p>가끔씩 우리는 잡은 오류 형식(또는 오류 값)에 따라 특정 작업을 트리거하길 원합니다. 이를 패턴을 사용하여 수행할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">do</span> {\n  <span class=\"hljs-keyword\">let</span> result = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title function_\">makeRequest</span>(<span class=\"hljs-attr\">to</span>: <span class=\"hljs-string\">\"//myapi.com/\"</span>, <span class=\"hljs-attr\">method</span>: .<span class=\"hljs-property\">GET</span>)\n} <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-title function_\">invalidUrl</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">let</span> url</span>) {\n  <span class=\"hljs-comment\">// ...</span>\n} <span class=\"hljs-keyword\">catch</span> {\n  <span class=\"hljs-title function_\">print</span>(error)\n  <span class=\"hljs-comment\">// </span>\n}\n</code></pre>\n<h2>에러 전파하기</h2>\n<p>던져진 함수는 함수 내에서 발생한 에러를 호출자의 범위로 전파할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">struct <span class=\"hljs-title class_\">User</span>: <span class=\"hljs-title class_\">Decodable</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">name</span>: <span class=\"hljs-title class_\">String</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">age</span>: <span class=\"hljs-title class_\">Int</span>\n}\n\nfunc decodeJSON&#x3C;<span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Decodable</span>>(_ <span class=\"hljs-attr\">jsonString</span>: <span class=\"hljs-title class_\">String</span>) throws -> T {\n    <span class=\"hljs-keyword\">let</span> jsonData = <span class=\"hljs-title class_\">Data</span>(jsonString.<span class=\"hljs-property\">utf8</span>)\n    <span class=\"hljs-keyword\">let</span> decodedObject = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">JSON</span>Decoder().<span class=\"hljs-title function_\">decode</span>(T.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">from</span>: jsonData)\n    <span class=\"hljs-keyword\">return</span> decodedObject\n}\n\nfunc <span class=\"hljs-title function_\">getUserFromJSON</span>(_ <span class=\"hljs-attr\">jsonString</span>: <span class=\"hljs-title class_\">String</span>) -> <span class=\"hljs-title class_\">User</span>? {\n    <span class=\"hljs-keyword\">do</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">user</span>: <span class=\"hljs-title class_\">User</span> = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title function_\">decodeJSON</span>(jsonString)\n        <span class=\"hljs-keyword\">return</span> user\n    } <span class=\"hljs-keyword\">catch</span> {\n        <span class=\"hljs-title function_\">print</span>(error)\n        <span class=\"hljs-keyword\">return</span> nil\n    }\n}\n</code></pre>\n<h2>try? &#x26; try!</h2>\n<p>가끔은 던지는 함수로 발생한 오류에 대해 신경 쓰지 않을 수 있습니다. 이런 상황에서는 do-catch 문을 사용하지 않고 try? 지시어를 사용할 수 있습니다.</p>\n<p>try?를 사용하면 호출하는 함수가 옵셔널이 됩니다. 즉, 반환 값을 가진 함수를 호출하는 경우 값은 nil이 됩니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> request = <span class=\"hljs-keyword\">try</span>? <span class=\"hljs-title function_\">createRequest</span>(<span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">\"malformedurl\"</span>, <span class=\"hljs-attr\">method</span>: .<span class=\"hljs-property\">GET</span>)\n<span class=\"hljs-comment\">// request = nil</span>\n</code></pre>\n<p>한편, 때때로 특정한 던지기 함수가 런타임에서 실패하지 않을 것을 확신할 수 있습니다. 이런 경우에는 try!를 사용할 수 있습니다. 그리고 try?와 마찬가지로 do-catch 클로저를 사용할 필요가 없습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> request = <span class=\"hljs-keyword\">try</span>! <span class=\"hljs-title function_\">createRequest</span>(<span class=\"hljs-attr\">from</span>: <span class=\"hljs-string\">\"https://myapi.com/\"</span>, <span class=\"hljs-attr\">method</span>: .<span class=\"hljs-property\">GET</span>)\n</code></pre>\n<h2>비동기 코드</h2>\n<p>에러를 던지는 것은 비동기 코드와 잘 작동합니다. 함수 선언에서 throws 키워드 앞에 async 키워드를 넣어주어야 합니다.</p>\n<p>비동기 함수를 호출할 때는 try await (키워드 순서 스와이프)를 사용합니다.</p>\n<pre><code class=\"hljs language-js\">func <span class=\"hljs-title function_\">performRequest</span>(<span class=\"hljs-keyword\">with</span> <span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">ApiRequest</span>) <span class=\"hljs-keyword\">async</span> throws -> <span class=\"hljs-title class_\">ApiResult</span> {...}\n\n<span class=\"hljs-comment\">// ----------------</span>\n\n<span class=\"hljs-keyword\">do</span> {\n  <span class=\"hljs-keyword\">let</span> request = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title function_\">makeRequest</span>(<span class=\"hljs-attr\">to</span>: <span class=\"hljs-string\">\"https://myapi.com/users\"</span>, <span class=\"hljs-attr\">method</span>: .<span class=\"hljs-property\">GET</span>)\n  <span class=\"hljs-keyword\">let</span> apiRestul = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">performRequest</span>(<span class=\"hljs-attr\">with</span>: request)\n} <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-title function_\">invalidUrl</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">let</span> url</span>) {\n  <span class=\"hljs-comment\">// ...</span>\n} <span class=\"hljs-keyword\">catch</span> {\n  <span class=\"hljs-title function_\">print</span>(error)\n  <span class=\"hljs-comment\">// </span>\n}\n</code></pre>\n<h1>사용자에게 알림</h1>\n<p>에러 구조를 구축했으니, 이제 사용자들에게 무엇이 잘못되었는지 알려줄 필요가 있습니다.</p>\n<p>각각의 오류에 대한 설명 은 오류가 처음에 발생한 이유입니다.\n사용자가 사용자를 피할 수 있는 가능한 조치입니다.</p>\n<p>우리는 Error enum에 해당 정보를 변수로 추가할 수 있습니다. 그러나 이미 모든 이 정보를 그룹화하기 위한 프로토콜이 있습니다: LocalizedError. 우리의 사용 사례에서 우리는 failureReason 및 recoverySuggestion 변수 만 구현하면 됩니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">OrderError</span>: <span class=\"hljs-title class_\">LocalizedError</span> {\n  <span class=\"hljs-keyword\">case</span> unexpected\n  <span class=\"hljs-keyword\">case</span> outOfCoffee(coffee: <span class=\"hljs-type\">Coffee</span>)\n  <span class=\"hljs-keyword\">case</span> minimumNotMet(currentPrice: <span class=\"hljs-type\">Float</span>)\n  \n  <span class=\"hljs-keyword\">var</span> failureReason: <span class=\"hljs-type\">String</span>? {\n    <span class=\"hljs-keyword\">switch</span> <span class=\"hljs-keyword\">self</span> {\n    <span class=\"hljs-keyword\">case</span> .unexpected:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"주문 처리 중 문제가 발생했습니다.\"</span>\n    <span class=\"hljs-keyword\">case</span> .outOfCoffee(<span class=\"hljs-keyword\">let</span> coffee):\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"<span class=\"hljs-subst\">\\(coffee.name)</span>가 다 떨어졌어요.\"</span>\n    <span class=\"hljs-keyword\">case</span> .minimumNotMet:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"앱에서 주문하려면 최소 $10 이상 사용해야 합니다.\"</span>\n    }\n  }\n  \n  <span class=\"hljs-keyword\">var</span> recoverySuggestion: <span class=\"hljs-type\">String</span>? {\n    <span class=\"hljs-keyword\">switch</span> <span class=\"hljs-keyword\">self</span> {\n    <span class=\"hljs-keyword\">case</span> .unexpected:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"몇 분 후에 다시 시도해주세요.\"</span>\n    <span class=\"hljs-keyword\">case</span> .outOfCoffee:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"다른 종류의 커피로 변경해보세요.\"</span>\n    <span class=\"hljs-keyword\">case</span> .minimumNotMet(<span class=\"hljs-keyword\">let</span> currentPrice):\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"주문에 $<span class=\"hljs-subst\">\\(<span class=\"hljs-number\">10</span><span class=\"hljs-operator\">-</span>currentPrice)</span> 더 추가해주세요.\"</span>\n    }\n  }\n}\n</code></pre>\n<p>여기에서 작업이 완료됩니다. 그러나 앱에 통합된 로깅 솔루션이 있다면, 오류 구조를 확장하여 추가 정보를 추가할 수 있습니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> Foundation\n<span class=\"hljs-keyword\">import</span> HKLogger\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">AppError</span>: <span class=\"hljs-title class_\">Error</span> {\n  <span class=\"hljs-keyword\">let</span> type: <span class=\"hljs-type\">LocalizedError</span>\n  <span class=\"hljs-keyword\">var</span> userMessage: <span class=\"hljs-type\">String</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"<span class=\"hljs-subst\">\\(type.failureReason <span class=\"hljs-operator\">??</span> ErrorConstants.defaultError)</span> <span class=\"hljs-subst\">\\n</span><span class=\"hljs-subst\">\\n</span> <span class=\"hljs-subst\">\\(type.recoverySuggestion <span class=\"hljs-operator\">??</span> ErrorConstants.defaultAction)</span>\"</span>\n  }\n  <span class=\"hljs-comment\">// 필요한 만큼 많은 속성을 추가</span>\n  \n  <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">type</span>: <span class=\"hljs-type\">LocalizedError</span>, <span class=\"hljs-params\">debugInfo</span>: <span class=\"hljs-type\">String</span>? <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">nil</span>) {\n      <span class=\"hljs-keyword\">self</span>.type <span class=\"hljs-operator\">=</span> type\n      <span class=\"hljs-keyword\">guard</span> <span class=\"hljs-keyword\">let</span> debugInfo <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-keyword\">return</span> }\n      <span class=\"hljs-type\">HKLogger</span>.shared.error(message: debugInfo)\n  }\n}\n</code></pre>\n<p>이렇게 함으로써 로깅 오류 로직을 한 곳에 중앙 집중화할 수 있습니다.</p>\n<p>마침내 사용자 정의 AppError를 사용하여 경고를 표시하는 간단한 View 확장을 만들 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">extension <span class=\"hljs-title class_\">View</span> {\n    func <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-attr\">isPresented</span>: <span class=\"hljs-title class_\">Binding</span>&#x3C;<span class=\"hljs-title class_\">Bool</span>>, withError <span class=\"hljs-attr\">error</span>: <span class=\"hljs-title class_\">AppError</span>?) -> some <span class=\"hljs-title class_\">View</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">alert</span>(\n            <span class=\"hljs-string\">\"Ups! :(\"</span>,\n            <span class=\"hljs-attr\">isPresented</span>: isPresented,\n            <span class=\"hljs-attr\">actions</span>: {\n                <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"Ok\"</span>) {}\n            }, <span class=\"hljs-attr\">message</span>: {\n                <span class=\"hljs-title class_\">Text</span>(error?.<span class=\"hljs-property\">userMessage</span> ?? <span class=\"hljs-string\">\"\"</span>)\n            }\n        )\n    }\n}\n\n<span class=\"hljs-comment\">// ---------------------------------------------------</span>\n\nstruct <span class=\"hljs-title class_\">OrderConfirmationView</span>: <span class=\"hljs-title class_\">View</span> {\n  @<span class=\"hljs-title class_\">StateObject</span> private <span class=\"hljs-keyword\">var</span> viewModel = <span class=\"hljs-title class_\">ConfirmationViewModel</span>()\n\n  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">body</span>: some <span class=\"hljs-title class_\">View</span> {\n    <span class=\"hljs-title class_\">VStack</span>(<span class=\"hljs-attr\">alignment</span>: .<span class=\"hljs-property\">leading</span>) {\n      <span class=\"hljs-comment\">// ...</span>\n      <span class=\"hljs-title class_\">Button</span>(<span class=\"hljs-string\">\"주문하기\"</span>) {\n        viewModel.<span class=\"hljs-title function_\">tryToPlaceOrder</span>(order)\n      }\n    }\n    .<span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-attr\">isPresented</span>: $viewModel.<span class=\"hljs-property\">showError</span>, <span class=\"hljs-attr\">withError</span>: viewModel.<span class=\"hljs-property\">appError</span>)\n  }\n}\n\n<span class=\"hljs-comment\">// ---------------------------------------------------</span>\n\n@<span class=\"hljs-title class_\">Observable</span>\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConfirmationViewModel</span>: <span class=\"hljs-title class_\">ObservableObject</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">appError</span>: <span class=\"hljs-title class_\">AppError</span>?\n    <span class=\"hljs-keyword\">var</span> showError = <span class=\"hljs-literal\">false</span>\n    \n    func <span class=\"hljs-title function_\">tryToPlaceOrder</span>(<span class=\"hljs-params\">_ order: Order</span>) {\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">OrdersManager</span>.<span class=\"hljs-property\">shared</span>.<span class=\"hljs-title function_\">add</span>(order)\n        } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-keyword\">let</span> error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">AppError</span> {\n            showError = <span class=\"hljs-literal\">true</span>\n            appError = error\n        } <span class=\"hljs-keyword\">catch</span> {\n            appError = <span class=\"hljs-title class_\">AppError</span>(<span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">OrderError</span>.<span class=\"hljs-property\">unexpected</span>)\n        }\n    }\n}\n\n<span class=\"hljs-comment\">// ---------------------------------------------------</span>\n\nfinal <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrdersManager</span> {\n  <span class=\"hljs-comment\">// ...</span>\n  func <span class=\"hljs-title function_\">add</span>(_ <span class=\"hljs-attr\">order</span>: <span class=\"hljs-title class_\">Order</span>) throws {\n    <span class=\"hljs-keyword\">if</span> order.<span class=\"hljs-property\">price</span> >= <span class=\"hljs-number\">10</span> {\n      orders.<span class=\"hljs-title function_\">append</span>(order)\n    } <span class=\"hljs-keyword\">else</span> {\n      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">AppError</span>(<span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">OrderError</span>.<span class=\"hljs-title function_\">minimumNotMet</span>(<span class=\"hljs-attr\">currentPrice</span>: order.<span class=\"hljs-property\">price</span>))\n    }\n  }\n}\n</code></pre>\n<p>질문이 있으신가요? 언제든지 메시지를 남겨주세요! 🙂</p>\n<ul>\n<li>🤓 iOS 개발 팁과 통찰력에 관한 콘텐츠를 X에서 함께 확인해보세요.</li>\n<li>🚀 모든 예제 프로젝트를 공유하는 내 GitHub를 확인해보세요 (이것도 포함됩니다 😉)</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}