{"pageProps":{"post":{"title":"가장 많이 묻는 질문 - SOLID 원칙 JAVA","description":"","date":"2024-06-19 21:55","slug":"2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA","content":"\n\n\n![SOLID Principles in JAVA](/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png)\n\n- **S — Single Responsibility Principle (SRP)**\n  - Each unit of code should have only one responsibility.\n  - A unit can be a class, module, function, or component.\n  - Keeps code modular and reduces tight coupling.\n  - Example: A class that handles user authentication should not also manage database connections.\n\n\n<div class=\"content-ad\"></div>\n\n# O — Open/Closed Principle (OCP)\n\n- 코드 단위는 확장을 허용하고 수정을 제한해야 합니다.\n\n- 기존 코드를 수정하는 대신 새 코드를 추가하여 기능 확장.\n\n- React 프론트엔드와 같이 구성 요소 기반 시스템에서 유용합니다.\n예: 로깅 시스템에 새 로그 핸들러를 생성하여 기능을 추가하는 것이 기존 핸들러를 변경하는 것보다 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n# L — 리스코프 치환 원칙 (LSP)\n\n- 서브클래스는 기본 클래스로 대체 가능해야 합니다.\n- 기본 클래스의 기능은 모든 서브클래스에서 사용할 수 있어야 합니다.\n\n- 만약 서브클래스가 기본 클래스의 기능을 사용할 수 없다면, 그것은 기본 클래스에 있어서는 안 됩니다.\n예: `새` 클래스에 `참새`와 `펭귄` 서브클래스가 있는 경우, 만약 `새`에 `날다` 메소드가 있다면, `펭귄`은 날지 못하기 때문에 상속받으면 안 됩니다.\n\n# I — 인터페이스 분리 원칙 (ISP)\n\n<div class=\"content-ad\"></div>\n\n- 몇 개의 일반 목적이 아닌 구체적인 인터페이스를 제공해주세요.\n\n- 클라이언트는 사용하지 않는 메소드에 의존하면 안 됩니다.\n예시: `Vehicle` 인터페이스를 `Drivable`과 `Flyable`로 분리하여 자동차 클래스가 `Flyable`을 구현할 필요가 없도록합니다.\n\n# D — 의존성 역전 원칙 (DIP)\n\n- 구체적인 클래스가 아닌 추상화에 의존해주세요.\n\n<div class=\"content-ad\"></div>\n\n- 시스템의 부분 간 의존성을 분리시키기 위해 추상화를 사용하세요.\n\n- 인터페이스나 추상화를 사용하여 코드 유닠 사이에 직접 호출을 피하세요.\n예: 특정 'FileLogger' 클래스 대신 로깅을 위해 'ILogger' 인터페이스를 사용하세요.","ogImage":{"url":"/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png"},"coverImage":"/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png","tag":["Tech"],"readingTime":2},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-MostAskedQuestion-SOLIDPrinciplesJAVA_0.png\" alt=\"SOLID Principles in JAVA\"></p>\n<ul>\n<li><strong>S — Single Responsibility Principle (SRP)</strong>\n<ul>\n<li>Each unit of code should have only one responsibility.</li>\n<li>A unit can be a class, module, function, or component.</li>\n<li>Keeps code modular and reduces tight coupling.</li>\n<li>Example: A class that handles user authentication should not also manage database connections.</li>\n</ul>\n</li>\n</ul>\n<h1>O — Open/Closed Principle (OCP)</h1>\n<ul>\n<li>\n<p>코드 단위는 확장을 허용하고 수정을 제한해야 합니다.</p>\n</li>\n<li>\n<p>기존 코드를 수정하는 대신 새 코드를 추가하여 기능 확장.</p>\n</li>\n<li>\n<p>React 프론트엔드와 같이 구성 요소 기반 시스템에서 유용합니다.\n예: 로깅 시스템에 새 로그 핸들러를 생성하여 기능을 추가하는 것이 기존 핸들러를 변경하는 것보다 좋습니다.</p>\n</li>\n</ul>\n<h1>L — 리스코프 치환 원칙 (LSP)</h1>\n<ul>\n<li>\n<p>서브클래스는 기본 클래스로 대체 가능해야 합니다.</p>\n</li>\n<li>\n<p>기본 클래스의 기능은 모든 서브클래스에서 사용할 수 있어야 합니다.</p>\n</li>\n<li>\n<p>만약 서브클래스가 기본 클래스의 기능을 사용할 수 없다면, 그것은 기본 클래스에 있어서는 안 됩니다.\n예: <code>새</code> 클래스에 <code>참새</code>와 <code>펭귄</code> 서브클래스가 있는 경우, 만약 <code>새</code>에 <code>날다</code> 메소드가 있다면, <code>펭귄</code>은 날지 못하기 때문에 상속받으면 안 됩니다.</p>\n</li>\n</ul>\n<h1>I — 인터페이스 분리 원칙 (ISP)</h1>\n<ul>\n<li>\n<p>몇 개의 일반 목적이 아닌 구체적인 인터페이스를 제공해주세요.</p>\n</li>\n<li>\n<p>클라이언트는 사용하지 않는 메소드에 의존하면 안 됩니다.\n예시: <code>Vehicle</code> 인터페이스를 <code>Drivable</code>과 <code>Flyable</code>로 분리하여 자동차 클래스가 <code>Flyable</code>을 구현할 필요가 없도록합니다.</p>\n</li>\n</ul>\n<h1>D — 의존성 역전 원칙 (DIP)</h1>\n<ul>\n<li>구체적인 클래스가 아닌 추상화에 의존해주세요.</li>\n</ul>\n<ul>\n<li>\n<p>시스템의 부분 간 의존성을 분리시키기 위해 추상화를 사용하세요.</p>\n</li>\n<li>\n<p>인터페이스나 추상화를 사용하여 코드 유닠 사이에 직접 호출을 피하세요.\n예: 특정 'FileLogger' 클래스 대신 로깅을 위해 'ILogger' 인터페이스를 사용하세요.</p>\n</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}