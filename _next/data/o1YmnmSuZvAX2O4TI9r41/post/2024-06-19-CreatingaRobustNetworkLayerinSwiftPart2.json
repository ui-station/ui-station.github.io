{"pageProps":{"post":{"title":"Swift로 강력한 네트워크 레이어 만들기 파트 2","description":"","date":"2024-06-19 10:54","slug":"2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2","content":"\n\n<img src=\"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png\" />\n\n현대 iOS 개발에서는 API 호출 및 데이터 검색을 효율적이고 안전하게 처리하는 데 잘 구조화된 네트워크 레이어가 필수적입니다. 본 후속 기사에서는 SOLID 원칙을 준수하고 클래스 기반에서 구조체 기반으로 전환하여 네트워크 레이어를 개선하고 리팩터링한 내용을 안내해 드릴 것입니다. 이를 통해 코드베이스를 더 잘 유지보수할 수 있고 확장 가능하도록 보장할 것입니다.\n\n# 개요\n\n저희가 업그레이드한 네트워크 레이어에는 다음 구성요소가 포함되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- NetworkError: 다양한 네트워크 오류를 처리하기 위한 포괄적인 열거형입니다.\n- NetworkRequest: 네트워크 요청을 위한 필수 속성 및 메서드를 정의하는 프로토콜입니다.\n- HTTPResponseHandler: HTTP 응답을 처리하고 디코딩하는 프로토콜입니다.\n- NetworkEngine: 네트워크 요청 수행, 로깅 및 응답 처리를 담당하는 구조체입니다.\n\n이러한 구성 요소를 예제 API 호출과 함께 사용하는 방법을 보여드리겠습니다.\n\n# 단계 1: 네트워크 오류 정의\n\n먼저 NetworkError 열거형을 정의하여 다양한 네트워크 관련 오류를 깔끔하고 조직적으로 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport Foundation\n\nenum NetworkError: Error {\n    case badURL\n    case requestFailed(Error)\n    case invalidResponse\n    case dataNotFound\n    case decodingFailed(Error)\n    case encodingFailed(Error)\n    case notFound\n    case timeout\n    case internalServerError\n    case unknownError(statusCode: Int)\n}\n\nstruct DecodingError: Error {\n    let message: String\n}\n```\n\n해설:\n\n- NetworkError: 이 열거형은 네트워크 작업 중 발생할 수 있는 다양한 유형의 오류를 캡슐화합니다. 각 case는 특정 오류 시나리오를 나타냅니다:\n  - badURL: URL이 잘못되었음을 나타냅니다.\n  - requestFailed: 요청을 만드는 데 실패한 것을 나타내며 내장된 오류를 캡슐화합니다.\n  - invalidResponse: 응답이 유효하지 않음을 나타냅니다.\n  - dataNotFound: 응답에서 데이터를 찾을 수 없음을 신호합니다.\n  - decodingFailed: 응답 데이터를 해독하는 데 실패한 것을 나타내며 해독 오류를 캡슐화합니다.\n  - encodingFailed: 요청 매개변수를 인코딩하는 데 실패한 것을 나타내며 인코딩 오류를 캡슐화합니다.\n  - notFound: 요청한 리소스를 찾을 수 없음을 나타냅니다 (HTTP 404).\n  - timeout: 타임아웃 오류를 나타냅니다.\n  - internalServerError: 서버 오류임을 나타냅니다 (HTTP 500).\n  - unknownError: 다른 HTTP 상태 코드 오류를 나타내며 상태 코드를 캡슐화합니다.\n\nDecodingError: 해독 중 추가 오류 정보를 제공하기 위한 사용자 정의 오류 구조체입니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: NetworkRequest 프로토콜 생성하기\n\nNetworkRequest 프로토콜은 URL, HTTP 메소드, 헤더, 매개변수 및 타임아웃 간 필수적인 속성을 정의합니다.\n\n```js\nimport Foundation\n\nenum HTTPMethod: String {\n    case get = \"GET\"\n    case post = \"POST\"\n    case put = \"PUT\"\n    case delete = \"DELETE\"\n}\n\nenum HTTPHeader: String {\n    case contentType = \"Content-Type\"\n    case authorization = \"Authorization\"\n}\n\nenum ContentType: String {\n    case json = \"application/json\"\n    case xml = \"application/xml\"\n    case formUrlEncoded = \"application/x-www-form-urlencoded\"\n}\n\nprotocol NetworkRequest {\n    var url: URL? { get }\n    var method: HTTPMethod { get }\n    var headers: [HTTPHeader: String]? { get }\n    var parameters: Encodable? { get }\n    var timeoutInterval: TimeInterval { get }\n}\n\nextension NetworkRequest {\n    var timeoutInterval: TimeInterval {\n        return 30\n    }\n\n    func urlRequest() throws -> URLRequest {\n        guard let url = url else {\n            throw NetworkError.badURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = method.rawValue\n        \n        if let headers = headers {\n            for (key, value) in headers {\n                request.setValue(value, forHTTPHeaderField: key.rawValue)\n            }\n        }\n        \n        if let parameters = parameters {\n            if method == .get {\n                var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false)\n                let parameterData = try JSONEncoder().encode(parameters)\n                let parameterDictionary = try JSONSerialization.jsonObject(with: parameterData, options: []) as? [String: Any]\n                urlComponents?.queryItems = parameterDictionary?.map { URLQueryItem(name: $0.key, value: \"\\($0.value)\") }\n                request.url = urlComponents?.url\n            } else {\n                do {\n                    let jsonData = try JSONEncoder().encode(parameters)\n                    request.httpBody = jsonData\n                } catch {\n                    throw NetworkError.encodingFailed(error)\n                }\n            }\n        }\n        \n        return request\n    }\n}\n```\n\n설명:\n\n<div class=\"content-ad\"></div>\n\n- HTTPMethod: 우리가 사용할 HTTP 메소드(GET, POST, PUT, DELETE)를 나타내는 enum입니다.\n- HTTPHeader: 일반적인 HTTP 헤더를 위한 enum입니다.\n- ContentType: HTTP 헤더에서 사용되는 일반적인 콘텐츠 유형을 위한 enum입니다.\n- NetworkRequest: 네트워크 요청에 필요한 속성을 정의하는 프로토콜입니다.\n  - url: 요청을 위한 URL입니다.\n  - method: 요청을 위한 HTTP 메소드입니다.\n  - headers: 요청에 대한 선택적 헤더입니다.\n  - parameters: 인코딩 가능한 형식을 준수하는 요청에 대한 선택적 매개변수입니다.\n  - timeoutInterval: 요청의 타임아웃 간격입니다.\n- 프로토콜 확장은 timeoutInterval의 기본 구현과 속성에서 URLRequest를 만들기 위한 urlRequest() 메소드를 제공합니다.\n  - 만약 메소드가 GET이면, 매개변수는 URL에 쿼리 아이템으로 추가됩니다.\n  - 다른 메소드의 경우, 매개변수는 JSON으로 인코딩되어 요청 바디에 추가됩니다.\n  - 헤더는 요청에 추가됩니다.\n\n# 단계 3: HTTPResponseHandler 구현하기\n\nHTTPResponseHandler 프로토콜은 HTTP 응답을 처리하고 디코딩하기 위한 메소드를 정의합니다.\n\n```js\nimport Foundation\n\npublic protocol HTTPResponseHandler {\n    func handleStatusCode(response: URLResponse?) throws\n    func decode<T: Decodable>(data: Data, to type: T.Type) throws -> T\n    func extractETag(from response: URLResponse?) -> String?\n}\n\nextension HTTPResponseHandler {\n    public func decode<T: Decodable>(data: Data, to type: T.Type) throws -> T {\n        do {\n            let decodedObject = try JSONDecoder().decode(T.self, from: data)\n            return decodedObject\n        } catch let decodingError {\n            throw NetworkError.decodingFailed(decodingError)\n        }\n    }\n\n    public func handleStatusCode(response: URLResponse?) throws {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n        \n        switch httpResponse.statusCode {\n        case 200...299:\n            return\n        case 404:\n            throw NetworkError.notFound\n        case 500:\n            throw NetworkError.internalServerError\n        default:\n            throw NetworkError.unknownError(statusCode: httpResponse.statusCode)\n        }\n    }\n\n    public func extractETag(from response: URLResponse?) -> String? {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            return nil\n        }\n        return httpResponse.allHeaderFields[\"ETag\"] as? String\n    }\n}\n\npublic struct DefaultHTTPResponseHandler: HTTPResponseHandler {\n    public init() {}\n}\n```\n\n<div class=\"content-ad\"></div>\n\n설명:\n\n- HTTPResponseHandler: HTTP 응답을 처리하고 해독하는 메서드를 정의하는 프로토콜입니다.\n  - handleStatusCode(response:): HTTP 상태 코드를 확인하고 적절한 오류를 throw합니다.\n  - decode(data:to:): Decodable을 준수하는 특정 타입으로 데이터를 디코딩합니다.\n  - extractETag(from:): 응답 헤더에서 ETag을 추출합니다.\n\n이 확장(extension)은 다음을 제공합니다:\n\n- decode(data:to:)은 데이터를 디코딩하기 위해 JSONDecoder를 사용하고 실패할 경우 NetworkError.decodingFailed를 throw합니다.\n- handleStatusCode(response:)은 HTTP 상태 코드를 확인하고 공통 오류(404, 500)에 대해 특정 NetworkError 케이스를 throw하며, 다른 상태 코드에 대해서는 알 수 없는 오류를 throw합니다.\n- extractETag(from:)은 응답 헤더에서 ETag을 가져옵니다.\n- DefaultHTTPResponseHandler: HTTPResponseHandler의 구체적인 구현체입니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 4: NetworkEngine 구현\n\nNetworkEngine 구조체는 네트워크 요청을 수행하고 응답을 처리하는 역할을 담당합니다.\n\n```js\nimport Foundation\n\nstruct NetworkRequestContext<T: Decodable> {\n    let request: NetworkRequest\n    let type: T.Type\n    let completion: (Result<T, NetworkError>) -> Void\n    let requestInvokeTime: Date\n}\n\nprotocol NetworkEngineAdapter {\n    func invokeEngine<T: Decodable>(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void)\n}\n\npublic struct NetworkEngine {\n    private let urlSession: URLSession\n    private let logger: Logger\n    private let responseHandler: HTTPResponseHandler\n\n    public init(urlSession: URLSession = .shared,\n                logger: Logger = DefaultLogger(),\n                responseHandler: HTTPResponseHandler = DefaultHTTPResponseHandler()) {\n        self.urlSession = urlSession\n        self.logger = logger\n        self.responseHandler = responseHandler\n    }\n}\n\nextension NetworkEngine: NetworkEngineAdapter {\n    func invokeEngine<T>(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void) where T: Decodable {\n        let requestInvokeTime = Date()\n        let context = NetworkRequestContext(request: request, type: type, completion: completion, requestInvokeTime: requestInvokeTime)\n        fetch(context)\n    }\n\n    private func fetch<T>(_ context: NetworkRequestContext<T>) where T: Decodable {\n        do {\n            var urlRequest = try context.request.urlRequest()\n            urlRequest.timeoutInterval = context.request.timeoutInterval\n\n            urlSession.dataTask(with: urlRequest) { data, response, error in\n                let requestFinishTime = Date()\n                let duration = requestFinishTime.timeIntervalSince(context.requestInvokeTime)\n                \n                logger.logMetrics(startTime: context.requestInvokeTime, endTime: requestFinishTime, duration: duration, request: urlRequest)\n                \n                if let error = error {\n                    context.completion(.failure(.requestFailed(error)))\n                    return\n                }\n                \n                guard let data = data else {\n                    context.completion(.failure(.dataNotFound))\n                    return\n                }\n                \n                do {\n                    try responseHandler.handleStatusCode(response: response)\n                    let decodedObject = try responseHandler.decode(data: data, to: context.type)\n                    context.completion(.success(decodedObject))\n                } catch let error as NetworkError {\n                    context.completion(.failure(error))\n                } catch {\n                    context.completion(.failure(.unknownError(statusCode: (response as? HTTPURLResponse)?.statusCode ?? -1)))\n                }\n            }.resume()\n        } catch {\n            context.completion(.failure(.requestFailed(error)))\n        }\n    }\n}\n```\n\n설명:\n\n<div class=\"content-ad\"></div>\n\n- NetworkRequestContext: 네트워크 요청의 컨텍스트를 캡슐화하는 구조체로, 요청 자체, 디코딩할 유형, 완료 핸들러, 그리고 요청이 호출된 시간을 포함합니다.\n- NetworkEngineAdapter: 네트워크 엔진을 요청과 함께 호출하고, 디코딩할 유형을 지정하며 완료 핸들러를 제공하는 메소드를 정의하는 프로토콜입니다.\n- NetworkEngine: 네트워크 작업을 수행하는 주요 구조체입니다:\n    - urlSession: 요청을 만드는 데 사용되는 URLSession 인스턴스입니다.\n    - logger: 메트릭 및 오류를 기록하기 위한 로거입니다.\n    - responseHandler: 응답 처리를 위한 HTTPResponseHandler의 인스턴스입니다.\n    - init: NetworkEngine을 urlSession, logger 및 responseHandler에 대한 옵션 매개변수로 초기화합니다.\n- invokeEngine 메소드는 NetworkRequestContext를 생성하고 fetch 메소드를 호출합니다.\n\nfetch 메소드:\n\n- NetworkRequest로부터 URLRequest를 만들려고 시도합니다.\n- 타임아웃 간격을 설정합니다.\n- urlSession.dataTask를 사용하여 네트워크 요청을 수행합니다.\n- 요청에 대한 메트릭을 기록합니다.\n- 오류, 누락된 데이터 및 상태 코드를 처리합니다.\n- 데이터를 디코딩하고 결과와 함께 완료 핸들러를 호출합니다.\n\n# 단계 5: 네트워크 레이어 사용하기\n\n<div class=\"content-ad\"></div>\n\n이 예시는 iOS에서 NetworkEngine을 사용하는 방법을 보여줍니다.\n\n## 네트워크 요청 정의하기\n\n먼저, NetworkRequest 프로토콜을 준수하는 PostService enum을 정의합니다. 이 enum은 네트워크 요청의 세부 사항을 캡슐화합니다.\n\n```swift\nimport Foundation\n\nenum PostService {\n    case fetchPosts\n}\n\nextension PostService: NetworkRequest {\n    var url: URL? {\n        switch self {\n        case .fetchPosts:\n            return URL(string: \"https://2e84f9d6-0dcb-4b93-9238-8b272604b4c1.mock.pstmn.io/v1/posts\")\n        }\n    }\n    \n    var method: HTTPMethod {\n        switch self {\n        case .fetchPosts:\n            return .get\n        }\n    }\n    \n    var headers: [HTTPHeader : String]? {\n        return [.contentType: ContentType.json.rawValue]\n    }\n    \n    var parameters: (any Encodable)? {\n        switch self {\n        case .fetchPosts:\n            return nil\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 PostService는 URL, HTTP 메서드, 헤더 및 요청에 대한 매개변수를 정의하는 단일 case fetchPosts를 갖습니다. 필요에 따라 더 추가할 수 있어요.\n\n## Repository 생성\n\n다음으로, NetworkEngine를 사용하여 요청을 실행할 repository 클래스를 만듭니다. 이 repository는 게시물을 가져오는 작업을 처리할 거에요:\n\n[연결](/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_1.png)\n\n<div class=\"content-ad\"></div>\n\n```swift\nprotocol PostsListRepositoryProtocol {\n  func fetchPostsList<T: Decodable>(with request: NetworkRequest, responseType: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void)\n}\n\nfinal class DefaultPostsListRepository: PostsListRepositoryProtocol {\n    private let engine: NetworkEngine\n    \n    init(engine: NetworkEngine = NetworkEngine()) {\n        self.engine = engine\n    }\n    \n    func fetchPostsList<T>(with request: NetworkRequest, responseType: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void) where T : Decodable {\n        engine.invokeEngine(request, decodeTo: responseType, completion: completion)\n    }\n}\n```\n\n이 저장소에서 fetchPostsList 메서드는 NetworkRequest와 응답을 디코딩할 responseType을 사용합니다. NetworkEngine을 사용하여 요청을 실행하고 결과를 전달하기 위해 완료 핸들러를 호출합니다. 이 저장소를 직접 ViewModel이나 보기 UseCase에 사용할 수 있습니다.\n\n# 결론\n\n이 코드베이스의 네트워크 레이어 디자인은 모듈화, 확장 가능성, 견고한 오류 처리, 테스트 용이성 및 성능 모니터링을 강조하여 확장 가능한 애플리케이션에 적합합니다. 이러한 특성들은 유지 보수성과 신뢰성을 저해하지 않고 앱이 기능과 복잡성을 향상시킬 수 있음을 보장합니다.\n\n\n<div class=\"content-ad\"></div>\n\n더 많은 통찰과 업데이트를 원하시면 LinkedIn에서 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png","tag":["Tech"],"readingTime":13},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>현대 iOS 개발에서는 API 호출 및 데이터 검색을 효율적이고 안전하게 처리하는 데 잘 구조화된 네트워크 레이어가 필수적입니다. 본 후속 기사에서는 SOLID 원칙을 준수하고 클래스 기반에서 구조체 기반으로 전환하여 네트워크 레이어를 개선하고 리팩터링한 내용을 안내해 드릴 것입니다. 이를 통해 코드베이스를 더 잘 유지보수할 수 있고 확장 가능하도록 보장할 것입니다.</p>\n<h1>개요</h1>\n<p>저희가 업그레이드한 네트워크 레이어에는 다음 구성요소가 포함되어 있습니다:</p>\n<ul>\n<li>NetworkError: 다양한 네트워크 오류를 처리하기 위한 포괄적인 열거형입니다.</li>\n<li>NetworkRequest: 네트워크 요청을 위한 필수 속성 및 메서드를 정의하는 프로토콜입니다.</li>\n<li>HTTPResponseHandler: HTTP 응답을 처리하고 디코딩하는 프로토콜입니다.</li>\n<li>NetworkEngine: 네트워크 요청 수행, 로깅 및 응답 처리를 담당하는 구조체입니다.</li>\n</ul>\n<p>이러한 구성 요소를 예제 API 호출과 함께 사용하는 방법을 보여드리겠습니다.</p>\n<h1>단계 1: 네트워크 오류 정의</h1>\n<p>먼저 NetworkError 열거형을 정의하여 다양한 네트워크 관련 오류를 깔끔하고 조직적으로 처리합니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> Foundation\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">NetworkError</span>: <span class=\"hljs-title class_\">Error</span> {\n    <span class=\"hljs-keyword\">case</span> badURL\n    <span class=\"hljs-keyword\">case</span> requestFailed(<span class=\"hljs-type\">Error</span>)\n    <span class=\"hljs-keyword\">case</span> invalidResponse\n    <span class=\"hljs-keyword\">case</span> dataNotFound\n    <span class=\"hljs-keyword\">case</span> decodingFailed(<span class=\"hljs-type\">Error</span>)\n    <span class=\"hljs-keyword\">case</span> encodingFailed(<span class=\"hljs-type\">Error</span>)\n    <span class=\"hljs-keyword\">case</span> notFound\n    <span class=\"hljs-keyword\">case</span> timeout\n    <span class=\"hljs-keyword\">case</span> internalServerError\n    <span class=\"hljs-keyword\">case</span> unknownError(statusCode: <span class=\"hljs-type\">Int</span>)\n}\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DecodingError</span>: <span class=\"hljs-title class_\">Error</span> {\n    <span class=\"hljs-keyword\">let</span> message: <span class=\"hljs-type\">String</span>\n}\n</code></pre>\n<p>해설:</p>\n<ul>\n<li>NetworkError: 이 열거형은 네트워크 작업 중 발생할 수 있는 다양한 유형의 오류를 캡슐화합니다. 각 case는 특정 오류 시나리오를 나타냅니다:\n<ul>\n<li>badURL: URL이 잘못되었음을 나타냅니다.</li>\n<li>requestFailed: 요청을 만드는 데 실패한 것을 나타내며 내장된 오류를 캡슐화합니다.</li>\n<li>invalidResponse: 응답이 유효하지 않음을 나타냅니다.</li>\n<li>dataNotFound: 응답에서 데이터를 찾을 수 없음을 신호합니다.</li>\n<li>decodingFailed: 응답 데이터를 해독하는 데 실패한 것을 나타내며 해독 오류를 캡슐화합니다.</li>\n<li>encodingFailed: 요청 매개변수를 인코딩하는 데 실패한 것을 나타내며 인코딩 오류를 캡슐화합니다.</li>\n<li>notFound: 요청한 리소스를 찾을 수 없음을 나타냅니다 (HTTP 404).</li>\n<li>timeout: 타임아웃 오류를 나타냅니다.</li>\n<li>internalServerError: 서버 오류임을 나타냅니다 (HTTP 500).</li>\n<li>unknownError: 다른 HTTP 상태 코드 오류를 나타내며 상태 코드를 캡슐화합니다.</li>\n</ul>\n</li>\n</ul>\n<p>DecodingError: 해독 중 추가 오류 정보를 제공하기 위한 사용자 정의 오류 구조체입니다.</p>\n<h1>단계 2: NetworkRequest 프로토콜 생성하기</h1>\n<p>NetworkRequest 프로토콜은 URL, HTTP 메소드, 헤더, 매개변수 및 타임아웃 간 필수적인 속성을 정의합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nenum <span class=\"hljs-title class_\">HTTPMethod</span>: <span class=\"hljs-title class_\">String</span> {\n    <span class=\"hljs-keyword\">case</span> get = <span class=\"hljs-string\">\"GET\"</span>\n    <span class=\"hljs-keyword\">case</span> post = <span class=\"hljs-string\">\"POST\"</span>\n    <span class=\"hljs-keyword\">case</span> put = <span class=\"hljs-string\">\"PUT\"</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-keyword\">delete</span> = <span class=\"hljs-string\">\"DELETE\"</span>\n}\n\nenum <span class=\"hljs-title class_\">HTTPHeader</span>: <span class=\"hljs-title class_\">String</span> {\n    <span class=\"hljs-keyword\">case</span> contentType = <span class=\"hljs-string\">\"Content-Type\"</span>\n    <span class=\"hljs-keyword\">case</span> authorization = <span class=\"hljs-string\">\"Authorization\"</span>\n}\n\nenum <span class=\"hljs-title class_\">ContentType</span>: <span class=\"hljs-title class_\">String</span> {\n    <span class=\"hljs-keyword\">case</span> json = <span class=\"hljs-string\">\"application/json\"</span>\n    <span class=\"hljs-keyword\">case</span> xml = <span class=\"hljs-string\">\"application/xml\"</span>\n    <span class=\"hljs-keyword\">case</span> formUrlEncoded = <span class=\"hljs-string\">\"application/x-www-form-urlencoded\"</span>\n}\n\nprotocol <span class=\"hljs-title class_\">NetworkRequest</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">url</span>: <span class=\"hljs-variable constant_\">URL</span>? { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">method</span>: <span class=\"hljs-title class_\">HTTPMethod</span> { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">headers</span>: [<span class=\"hljs-title class_\">HTTPHeader</span>: <span class=\"hljs-title class_\">String</span>]? { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">parameters</span>: <span class=\"hljs-title class_\">Encodable</span>? { get }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">timeoutInterval</span>: <span class=\"hljs-title class_\">TimeInterval</span> { get }\n}\n\nextension <span class=\"hljs-title class_\">NetworkRequest</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">timeoutInterval</span>: <span class=\"hljs-title class_\">TimeInterval</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">30</span>\n    }\n\n    func <span class=\"hljs-title function_\">urlRequest</span>() throws -> <span class=\"hljs-title class_\">URLRequest</span> {\n        guard <span class=\"hljs-keyword\">let</span> url = url <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-property\">badURL</span>\n        }\n        \n        <span class=\"hljs-keyword\">var</span> request = <span class=\"hljs-title class_\">URLRequest</span>(<span class=\"hljs-attr\">url</span>: url)\n        request.<span class=\"hljs-property\">httpMethod</span> = method.<span class=\"hljs-property\">rawValue</span>\n        \n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> headers = headers {\n            <span class=\"hljs-keyword\">for</span> (key, value) <span class=\"hljs-keyword\">in</span> headers {\n                request.<span class=\"hljs-title function_\">setValue</span>(value, <span class=\"hljs-attr\">forHTTPHeaderField</span>: key.<span class=\"hljs-property\">rawValue</span>)\n            }\n        }\n        \n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> parameters = parameters {\n            <span class=\"hljs-keyword\">if</span> method == .<span class=\"hljs-property\">get</span> {\n                <span class=\"hljs-keyword\">var</span> urlComponents = <span class=\"hljs-title class_\">URLComponents</span>(<span class=\"hljs-attr\">url</span>: url, <span class=\"hljs-attr\">resolvingAgainstBaseURL</span>: <span class=\"hljs-literal\">false</span>)\n                <span class=\"hljs-keyword\">let</span> parameterData = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">JSON</span>Encoder().<span class=\"hljs-title function_\">encode</span>(parameters)\n                <span class=\"hljs-keyword\">let</span> parameterDictionary = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">JSON</span>Serialization.<span class=\"hljs-title function_\">jsonObject</span>(<span class=\"hljs-attr\">with</span>: parameterData, <span class=\"hljs-attr\">options</span>: []) <span class=\"hljs-keyword\">as</span>? [<span class=\"hljs-title class_\">String</span>: <span class=\"hljs-title class_\">Any</span>]\n                urlComponents?.<span class=\"hljs-property\">queryItems</span> = parameterDictionary?.<span class=\"hljs-property\">map</span> { <span class=\"hljs-title class_\">URLQueryItem</span>(<span class=\"hljs-attr\">name</span>: $0.<span class=\"hljs-property\">key</span>, <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">\"\\($0.value)\"</span>) }\n                request.<span class=\"hljs-property\">url</span> = urlComponents?.<span class=\"hljs-property\">url</span>\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">do</span> {\n                    <span class=\"hljs-keyword\">let</span> jsonData = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">JSON</span>Encoder().<span class=\"hljs-title function_\">encode</span>(parameters)\n                    request.<span class=\"hljs-property\">httpBody</span> = jsonData\n                } <span class=\"hljs-keyword\">catch</span> {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-title function_\">encodingFailed</span>(error)\n                }\n            }\n        }\n        \n        <span class=\"hljs-keyword\">return</span> request\n    }\n}\n</code></pre>\n<p>설명:</p>\n<ul>\n<li>HTTPMethod: 우리가 사용할 HTTP 메소드(GET, POST, PUT, DELETE)를 나타내는 enum입니다.</li>\n<li>HTTPHeader: 일반적인 HTTP 헤더를 위한 enum입니다.</li>\n<li>ContentType: HTTP 헤더에서 사용되는 일반적인 콘텐츠 유형을 위한 enum입니다.</li>\n<li>NetworkRequest: 네트워크 요청에 필요한 속성을 정의하는 프로토콜입니다.\n<ul>\n<li>url: 요청을 위한 URL입니다.</li>\n<li>method: 요청을 위한 HTTP 메소드입니다.</li>\n<li>headers: 요청에 대한 선택적 헤더입니다.</li>\n<li>parameters: 인코딩 가능한 형식을 준수하는 요청에 대한 선택적 매개변수입니다.</li>\n<li>timeoutInterval: 요청의 타임아웃 간격입니다.</li>\n</ul>\n</li>\n<li>프로토콜 확장은 timeoutInterval의 기본 구현과 속성에서 URLRequest를 만들기 위한 urlRequest() 메소드를 제공합니다.\n<ul>\n<li>만약 메소드가 GET이면, 매개변수는 URL에 쿼리 아이템으로 추가됩니다.</li>\n<li>다른 메소드의 경우, 매개변수는 JSON으로 인코딩되어 요청 바디에 추가됩니다.</li>\n<li>헤더는 요청에 추가됩니다.</li>\n</ul>\n</li>\n</ul>\n<h1>단계 3: HTTPResponseHandler 구현하기</h1>\n<p>HTTPResponseHandler 프로토콜은 HTTP 응답을 처리하고 디코딩하기 위한 메소드를 정의합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\npublic protocol <span class=\"hljs-title class_\">HTTPResponseHandler</span> {\n    func <span class=\"hljs-title function_\">handleStatusCode</span>(<span class=\"hljs-attr\">response</span>: <span class=\"hljs-title class_\">URLResponse</span>?) throws\n    func decode&#x3C;<span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Decodable</span>>(<span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">Data</span>, to <span class=\"hljs-attr\">type</span>: T.<span class=\"hljs-property\">Type</span>) throws -> T\n    func <span class=\"hljs-title function_\">extractETag</span>(<span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">response</span>: <span class=\"hljs-title class_\">URLResponse</span>?) -> <span class=\"hljs-title class_\">String</span>?\n}\n\nextension <span class=\"hljs-title class_\">HTTPResponseHandler</span> {\n    public func decode&#x3C;<span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Decodable</span>>(<span class=\"hljs-attr\">data</span>: <span class=\"hljs-title class_\">Data</span>, to <span class=\"hljs-attr\">type</span>: T.<span class=\"hljs-property\">Type</span>) throws -> T {\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-keyword\">let</span> decodedObject = <span class=\"hljs-keyword\">try</span> <span class=\"hljs-title class_\">JSON</span>Decoder().<span class=\"hljs-title function_\">decode</span>(T.<span class=\"hljs-property\">self</span>, <span class=\"hljs-attr\">from</span>: data)\n            <span class=\"hljs-keyword\">return</span> decodedObject\n        } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-keyword\">let</span> decodingError {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-title function_\">decodingFailed</span>(decodingError)\n        }\n    }\n\n    public func <span class=\"hljs-title function_\">handleStatusCode</span>(<span class=\"hljs-attr\">response</span>: <span class=\"hljs-title class_\">URLResponse</span>?) throws {\n        guard <span class=\"hljs-keyword\">let</span> httpResponse = response <span class=\"hljs-keyword\">as</span>? <span class=\"hljs-title class_\">HTTPURLResponse</span> <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-property\">invalidResponse</span>\n        }\n        \n        <span class=\"hljs-keyword\">switch</span> httpResponse.<span class=\"hljs-property\">statusCode</span> {\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">200.</span>.<span class=\"hljs-number\">.299</span>:\n            <span class=\"hljs-keyword\">return</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">404</span>:\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-property\">notFound</span>\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">500</span>:\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-property\">internalServerError</span>\n        <span class=\"hljs-attr\">default</span>:\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-title class_\">NetworkError</span>.<span class=\"hljs-title function_\">unknownError</span>(<span class=\"hljs-attr\">statusCode</span>: httpResponse.<span class=\"hljs-property\">statusCode</span>)\n        }\n    }\n\n    public func <span class=\"hljs-title function_\">extractETag</span>(<span class=\"hljs-keyword\">from</span> <span class=\"hljs-attr\">response</span>: <span class=\"hljs-title class_\">URLResponse</span>?) -> <span class=\"hljs-title class_\">String</span>? {\n        guard <span class=\"hljs-keyword\">let</span> httpResponse = response <span class=\"hljs-keyword\">as</span>? <span class=\"hljs-title class_\">HTTPURLResponse</span> <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> nil\n        }\n        <span class=\"hljs-keyword\">return</span> httpResponse.<span class=\"hljs-property\">allHeaderFields</span>[<span class=\"hljs-string\">\"ETag\"</span>] <span class=\"hljs-keyword\">as</span>? <span class=\"hljs-title class_\">String</span>\n    }\n}\n\npublic struct <span class=\"hljs-title class_\">DefaultHTTPResponseHandler</span>: <span class=\"hljs-title class_\">HTTPResponseHandler</span> {\n    public <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\"></span>) {}\n}\n</code></pre>\n<p>설명:</p>\n<ul>\n<li>HTTPResponseHandler: HTTP 응답을 처리하고 해독하는 메서드를 정의하는 프로토콜입니다.\n<ul>\n<li>handleStatusCode(response:): HTTP 상태 코드를 확인하고 적절한 오류를 throw합니다.</li>\n<li>decode(data:to:): Decodable을 준수하는 특정 타입으로 데이터를 디코딩합니다.</li>\n<li>extractETag(from:): 응답 헤더에서 ETag을 추출합니다.</li>\n</ul>\n</li>\n</ul>\n<p>이 확장(extension)은 다음을 제공합니다:</p>\n<ul>\n<li>decode(data:to:)은 데이터를 디코딩하기 위해 JSONDecoder를 사용하고 실패할 경우 NetworkError.decodingFailed를 throw합니다.</li>\n<li>handleStatusCode(response:)은 HTTP 상태 코드를 확인하고 공통 오류(404, 500)에 대해 특정 NetworkError 케이스를 throw하며, 다른 상태 코드에 대해서는 알 수 없는 오류를 throw합니다.</li>\n<li>extractETag(from:)은 응답 헤더에서 ETag을 가져옵니다.</li>\n<li>DefaultHTTPResponseHandler: HTTPResponseHandler의 구체적인 구현체입니다.</li>\n</ul>\n<h1>단계 4: NetworkEngine 구현</h1>\n<p>NetworkEngine 구조체는 네트워크 요청을 수행하고 응답을 처리하는 역할을 담당합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Foundation</span>\n\nstruct <span class=\"hljs-title class_\">NetworkRequestContext</span>&#x3C;<span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Decodable</span>> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">NetworkRequest</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">type</span>: T.<span class=\"hljs-property\">Type</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">completion</span>: (<span class=\"hljs-title class_\">Result</span>&#x3C;T, <span class=\"hljs-title class_\">NetworkError</span>>) -> <span class=\"hljs-title class_\">Void</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">requestInvokeTime</span>: <span class=\"hljs-title class_\">Date</span>\n}\n\nprotocol <span class=\"hljs-title class_\">NetworkEngineAdapter</span> {\n    func invokeEngine&#x3C;<span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Decodable</span>>(_ <span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">NetworkRequest</span>, decodeTo <span class=\"hljs-attr\">type</span>: T.<span class=\"hljs-property\">Type</span>, <span class=\"hljs-attr\">completion</span>: @escaping (<span class=\"hljs-title class_\">Result</span>&#x3C;T, <span class=\"hljs-title class_\">NetworkError</span>>) -> <span class=\"hljs-title class_\">Void</span>)\n}\n\npublic struct <span class=\"hljs-title class_\">NetworkEngine</span> {\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">urlSession</span>: <span class=\"hljs-title class_\">URLSession</span>\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">logger</span>: <span class=\"hljs-title class_\">Logger</span>\n    private <span class=\"hljs-keyword\">let</span> <span class=\"hljs-attr\">responseHandler</span>: <span class=\"hljs-title class_\">HTTPResponseHandler</span>\n\n    public <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">urlSession: URLSession = .shared,\n                logger: Logger = DefaultLogger(),\n                responseHandler: HTTPResponseHandler = DefaultHTTPResponseHandler()</span>) {\n        self.<span class=\"hljs-property\">urlSession</span> = urlSession\n        self.<span class=\"hljs-property\">logger</span> = logger\n        self.<span class=\"hljs-property\">responseHandler</span> = responseHandler\n    }\n}\n\nextension <span class=\"hljs-title class_\">NetworkEngine</span>: <span class=\"hljs-title class_\">NetworkEngineAdapter</span> {\n    func invokeEngine&#x3C;T>(_ <span class=\"hljs-attr\">request</span>: <span class=\"hljs-title class_\">NetworkRequest</span>, decodeTo <span class=\"hljs-attr\">type</span>: T.<span class=\"hljs-property\">Type</span>, <span class=\"hljs-attr\">completion</span>: @escaping (<span class=\"hljs-title class_\">Result</span>&#x3C;T, <span class=\"hljs-title class_\">NetworkError</span>>) -> <span class=\"hljs-title class_\">Void</span>) where <span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Decodable</span> {\n        <span class=\"hljs-keyword\">let</span> requestInvokeTime = <span class=\"hljs-title class_\">Date</span>()\n        <span class=\"hljs-keyword\">let</span> context = <span class=\"hljs-title class_\">NetworkRequestContext</span>(<span class=\"hljs-attr\">request</span>: request, <span class=\"hljs-attr\">type</span>: type, <span class=\"hljs-attr\">completion</span>: completion, <span class=\"hljs-attr\">requestInvokeTime</span>: requestInvokeTime)\n        <span class=\"hljs-title function_\">fetch</span>(context)\n    }\n\n    private func fetch&#x3C;T>(_ <span class=\"hljs-attr\">context</span>: <span class=\"hljs-title class_\">NetworkRequestContext</span>&#x3C;T>) where <span class=\"hljs-attr\">T</span>: <span class=\"hljs-title class_\">Decodable</span> {\n        <span class=\"hljs-keyword\">do</span> {\n            <span class=\"hljs-keyword\">var</span> urlRequest = <span class=\"hljs-keyword\">try</span> context.<span class=\"hljs-property\">request</span>.<span class=\"hljs-title function_\">urlRequest</span>()\n            urlRequest.<span class=\"hljs-property\">timeoutInterval</span> = context.<span class=\"hljs-property\">request</span>.<span class=\"hljs-property\">timeoutInterval</span>\n\n            urlSession.<span class=\"hljs-title function_\">dataTask</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">with</span>: urlRequest</span>) { data, response, error <span class=\"hljs-keyword\">in</span>\n                <span class=\"hljs-keyword\">let</span> requestFinishTime = <span class=\"hljs-title class_\">Date</span>()\n                <span class=\"hljs-keyword\">let</span> duration = requestFinishTime.<span class=\"hljs-title function_\">timeIntervalSince</span>(context.<span class=\"hljs-property\">requestInvokeTime</span>)\n                \n                logger.<span class=\"hljs-title function_\">logMetrics</span>(<span class=\"hljs-attr\">startTime</span>: context.<span class=\"hljs-property\">requestInvokeTime</span>, <span class=\"hljs-attr\">endTime</span>: requestFinishTime, <span class=\"hljs-attr\">duration</span>: duration, <span class=\"hljs-attr\">request</span>: urlRequest)\n                \n                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> error = error {\n                    context.<span class=\"hljs-title function_\">completion</span>(.<span class=\"hljs-title function_\">failure</span>(.<span class=\"hljs-title function_\">requestFailed</span>(error)))\n                    <span class=\"hljs-keyword\">return</span>\n                }\n                \n                guard <span class=\"hljs-keyword\">let</span> data = data <span class=\"hljs-keyword\">else</span> {\n                    context.<span class=\"hljs-title function_\">completion</span>(.<span class=\"hljs-title function_\">failure</span>(.<span class=\"hljs-property\">dataNotFound</span>))\n                    <span class=\"hljs-keyword\">return</span>\n                }\n                \n                <span class=\"hljs-keyword\">do</span> {\n                    <span class=\"hljs-keyword\">try</span> responseHandler.<span class=\"hljs-title function_\">handleStatusCode</span>(<span class=\"hljs-attr\">response</span>: response)\n                    <span class=\"hljs-keyword\">let</span> decodedObject = <span class=\"hljs-keyword\">try</span> responseHandler.<span class=\"hljs-title function_\">decode</span>(<span class=\"hljs-attr\">data</span>: data, <span class=\"hljs-attr\">to</span>: context.<span class=\"hljs-property\">type</span>)\n                    context.<span class=\"hljs-title function_\">completion</span>(.<span class=\"hljs-title function_\">success</span>(decodedObject))\n                } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-keyword\">let</span> error <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">NetworkError</span> {\n                    context.<span class=\"hljs-title function_\">completion</span>(.<span class=\"hljs-title function_\">failure</span>(error))\n                } <span class=\"hljs-keyword\">catch</span> {\n                    context.<span class=\"hljs-title function_\">completion</span>(.<span class=\"hljs-title function_\">failure</span>(.<span class=\"hljs-title function_\">unknownError</span>(<span class=\"hljs-attr\">statusCode</span>: (response <span class=\"hljs-keyword\">as</span>? <span class=\"hljs-title class_\">HTTPURLResponse</span>)?.<span class=\"hljs-property\">statusCode</span> ?? -<span class=\"hljs-number\">1</span>)))\n                }\n            }.<span class=\"hljs-title function_\">resume</span>()\n        } <span class=\"hljs-keyword\">catch</span> {\n            context.<span class=\"hljs-title function_\">completion</span>(.<span class=\"hljs-title function_\">failure</span>(.<span class=\"hljs-title function_\">requestFailed</span>(error)))\n        }\n    }\n}\n</code></pre>\n<p>설명:</p>\n<ul>\n<li>NetworkRequestContext: 네트워크 요청의 컨텍스트를 캡슐화하는 구조체로, 요청 자체, 디코딩할 유형, 완료 핸들러, 그리고 요청이 호출된 시간을 포함합니다.</li>\n<li>NetworkEngineAdapter: 네트워크 엔진을 요청과 함께 호출하고, 디코딩할 유형을 지정하며 완료 핸들러를 제공하는 메소드를 정의하는 프로토콜입니다.</li>\n<li>NetworkEngine: 네트워크 작업을 수행하는 주요 구조체입니다:\n<ul>\n<li>urlSession: 요청을 만드는 데 사용되는 URLSession 인스턴스입니다.</li>\n<li>logger: 메트릭 및 오류를 기록하기 위한 로거입니다.</li>\n<li>responseHandler: 응답 처리를 위한 HTTPResponseHandler의 인스턴스입니다.</li>\n<li>init: NetworkEngine을 urlSession, logger 및 responseHandler에 대한 옵션 매개변수로 초기화합니다.</li>\n</ul>\n</li>\n<li>invokeEngine 메소드는 NetworkRequestContext를 생성하고 fetch 메소드를 호출합니다.</li>\n</ul>\n<p>fetch 메소드:</p>\n<ul>\n<li>NetworkRequest로부터 URLRequest를 만들려고 시도합니다.</li>\n<li>타임아웃 간격을 설정합니다.</li>\n<li>urlSession.dataTask를 사용하여 네트워크 요청을 수행합니다.</li>\n<li>요청에 대한 메트릭을 기록합니다.</li>\n<li>오류, 누락된 데이터 및 상태 코드를 처리합니다.</li>\n<li>데이터를 디코딩하고 결과와 함께 완료 핸들러를 호출합니다.</li>\n</ul>\n<h1>단계 5: 네트워크 레이어 사용하기</h1>\n<p>이 예시는 iOS에서 NetworkEngine을 사용하는 방법을 보여줍니다.</p>\n<h2>네트워크 요청 정의하기</h2>\n<p>먼저, NetworkRequest 프로토콜을 준수하는 PostService enum을 정의합니다. 이 enum은 네트워크 요청의 세부 사항을 캡슐화합니다.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">import</span> Foundation\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">PostService</span> {\n    <span class=\"hljs-keyword\">case</span> fetchPosts\n}\n\n<span class=\"hljs-keyword\">extension</span> <span class=\"hljs-title class_\">PostService</span>: <span class=\"hljs-title class_\">NetworkRequest</span> {\n    <span class=\"hljs-keyword\">var</span> url: <span class=\"hljs-type\">URL</span>? {\n        <span class=\"hljs-keyword\">switch</span> <span class=\"hljs-keyword\">self</span> {\n        <span class=\"hljs-keyword\">case</span> .fetchPosts:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">URL</span>(string: <span class=\"hljs-string\">\"https://2e84f9d6-0dcb-4b93-9238-8b272604b4c1.mock.pstmn.io/v1/posts\"</span>)\n        }\n    }\n    \n    <span class=\"hljs-keyword\">var</span> method: <span class=\"hljs-type\">HTTPMethod</span> {\n        <span class=\"hljs-keyword\">switch</span> <span class=\"hljs-keyword\">self</span> {\n        <span class=\"hljs-keyword\">case</span> .fetchPosts:\n            <span class=\"hljs-keyword\">return</span> .get\n        }\n    }\n    \n    <span class=\"hljs-keyword\">var</span> headers: [<span class=\"hljs-type\">HTTPHeader</span> : <span class=\"hljs-type\">String</span>]<span class=\"hljs-operator\">?</span> {\n        <span class=\"hljs-keyword\">return</span> [.contentType: <span class=\"hljs-type\">ContentType</span>.json.rawValue]\n    }\n    \n    <span class=\"hljs-keyword\">var</span> parameters: (<span class=\"hljs-keyword\">any</span> <span class=\"hljs-type\">Encodable</span>)<span class=\"hljs-operator\">?</span> {\n        <span class=\"hljs-keyword\">switch</span> <span class=\"hljs-keyword\">self</span> {\n        <span class=\"hljs-keyword\">case</span> .fetchPosts:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n        }\n    }\n}\n</code></pre>\n<p>여기서 PostService는 URL, HTTP 메서드, 헤더 및 요청에 대한 매개변수를 정의하는 단일 case fetchPosts를 갖습니다. 필요에 따라 더 추가할 수 있어요.</p>\n<h2>Repository 생성</h2>\n<p>다음으로, NetworkEngine를 사용하여 요청을 실행할 repository 클래스를 만듭니다. 이 repository는 게시물을 가져오는 작업을 처리할 거에요:</p>\n<p><a href=\"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_1.png\">연결</a></p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">protocol</span> <span class=\"hljs-title class_\">PostsListRepositoryProtocol</span> {\n  <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">fetchPostsList</span>&#x3C;<span class=\"hljs-type\">T</span>: <span class=\"hljs-type\">Decodable</span>>(<span class=\"hljs-params\">with</span> <span class=\"hljs-params\">request</span>: <span class=\"hljs-type\">NetworkRequest</span>, <span class=\"hljs-params\">responseType</span>: <span class=\"hljs-type\">T</span>.<span class=\"hljs-keyword\">Type</span>, <span class=\"hljs-params\">completion</span>: <span class=\"hljs-keyword\">@escaping</span> (<span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-type\">T</span>, <span class=\"hljs-type\">NetworkError</span>>) -> <span class=\"hljs-type\">Void</span>)\n}\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DefaultPostsListRepository</span>: <span class=\"hljs-title class_\">PostsListRepositoryProtocol</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">let</span> engine: <span class=\"hljs-type\">NetworkEngine</span>\n    \n    <span class=\"hljs-keyword\">init</span>(<span class=\"hljs-params\">engine</span>: <span class=\"hljs-type\">NetworkEngine</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-type\">NetworkEngine</span>()) {\n        <span class=\"hljs-keyword\">self</span>.engine <span class=\"hljs-operator\">=</span> engine\n    }\n    \n    <span class=\"hljs-keyword\">func</span> <span class=\"hljs-title function_\">fetchPostsList</span>&#x3C;<span class=\"hljs-type\">T</span>>(<span class=\"hljs-params\">with</span> <span class=\"hljs-params\">request</span>: <span class=\"hljs-type\">NetworkRequest</span>, <span class=\"hljs-params\">responseType</span>: <span class=\"hljs-type\">T</span>.<span class=\"hljs-keyword\">Type</span>, <span class=\"hljs-params\">completion</span>: <span class=\"hljs-keyword\">@escaping</span> (<span class=\"hljs-type\">Result</span>&#x3C;<span class=\"hljs-type\">T</span>, <span class=\"hljs-type\">NetworkError</span>>) -> <span class=\"hljs-type\">Void</span>) <span class=\"hljs-keyword\">where</span> <span class=\"hljs-type\">T</span> : <span class=\"hljs-type\">Decodable</span> {\n        engine.invokeEngine(request, decodeTo: responseType, completion: completion)\n    }\n}\n</code></pre>\n<p>이 저장소에서 fetchPostsList 메서드는 NetworkRequest와 응답을 디코딩할 responseType을 사용합니다. NetworkEngine을 사용하여 요청을 실행하고 결과를 전달하기 위해 완료 핸들러를 호출합니다. 이 저장소를 직접 ViewModel이나 보기 UseCase에 사용할 수 있습니다.</p>\n<h1>결론</h1>\n<p>이 코드베이스의 네트워크 레이어 디자인은 모듈화, 확장 가능성, 견고한 오류 처리, 테스트 용이성 및 성능 모니터링을 강조하여 확장 가능한 애플리케이션에 적합합니다. 이러한 특성들은 유지 보수성과 신뢰성을 저해하지 않고 앱이 기능과 복잡성을 향상시킬 수 있음을 보장합니다.</p>\n<p>더 많은 통찰과 업데이트를 원하시면 LinkedIn에서 저를 팔로우해주세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}