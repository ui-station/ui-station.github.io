{"pageProps":{"posts":[{"title":"시니어 자바 소프트웨어 엔지니어가 흔히 받는 인터뷰 질문들","description":"","date":"2024-06-19 10:07","slug":"2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions","content":"\n\n![image](/assets/img/2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions_0.png)\n\n2019년부터 영국에서 살고 일해오고 있어요. 2008년부터 Java 개발을 하고 있어서, 이 자리에서는 시니어 포지션에 지원할 때 자주 등장하는 질문들을 공유할 거예요. 최근에는 한 회사의 리소그에 참여하면서, 이 기사가 발행된 2024년 6월 5일을 기준으로 지난 2개월 반이 좀 더 지났습니다. 이 기간 동안 Java 언어를 사용하는 시니어 개발자 역할에 대한 다양한 인터뷰를 진행했어요.\n\n이 자리에서 자주 등장하는 질문들과 간결하고 직접적인 답변을 공유할 거에요. 설명을 그냥 대충 넘기지 말고, 면접관에게 더 명확하게 설명하기 위해 답변을 더 깊게 파고들어야 하는 답변들도 있어요. 그 말인 즉, 여기 수록된 답변은 직접적인 대답을 위한 제안일 뿐이에요.\n\n물론, 다른 질문들도 받았지만, 가장 자주 나오는 것들을 여기에 정리해 두는 것이죠. 새로운 반복들을 발견할 때마다 다른 질문과 이에 대한 직접적인 답변들도 추가할 거에요.\n\n<div class=\"content-ad\"></div>\n\n# 객체 지향 프로그래밍이란 무엇인가요?\n\n객체 지향 프로그래밍(OOP)은 프로그램 내의 객체를 생각하면서 코드를 구성하는 방법입니다. 이러한 객체들은 실제 세계의 엔티티를 나타내며 데이터와 동작을 함께 캡슐화하는 데 사용됩니다. OOP의 원칙에는 캡슐화, 상속, 다형성 및 추상화가 포함되어 있으며, 이는 모듈식이고 재사용 가능한 코드를 생성하는 데 도움이 됩니다.\n\n# 의존성 주입이란 무엇인가요?\n\n의존성 주입(DI)은 소프트웨어 공학에서의 디자인 패턴으로, 구성 요소의 의존성이 구성 요소 자체 내에서 생성되는 대신 외부에서 주입되는 방식입니다. 이는 구성 요소가 자체 의존성을 만드는 대신 외부 소스로부터 제공받는 것을 의미합니다. DI의 주요 장점에는 모듈성 증가, 테스트 용이성 및 관심사의 분리가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 의존성 주입의 장점은 무엇인가요?\n\n- 컴포넌트 간 결합도를 낮춥니다.\n- 코드의 유지보수와 테스트 용이성을 향상시킵니다.\n- 더 깨끗한 코드와 디자인을 장려합니다.\n\n# 의존성 주입을 구현하는 가장 흔한 방법은 무엇인가요?\n\n- 생성자 주입: 의존성은 클래스 생성자를 통해 제공됩니다.\n- 세터 주입: 의존성은 세터 메서드를 통해 제공됩니다.\n- 메서드 주입: 의존성은 메서드를 통해 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 데드락이란 무엇인가요?\n\n데드락은 둘 이상의 프로세스가 상대가 자원을 해제할 때까지 대기하면서 진행할 수 없는 상황을 의미합니다. 이는 순환 대기 상태를 만들어 내어 정지 상태에 빠지게 됩니다.\n\n# 데드락을 피하는 방법은 무엇인가요?\n\n- 은행원 알고리즘: 프로세스가 사용할 최대 자원을 선언하고, 요청한 자원이 사용 가능한 자원보다 작을 경우 실행이 허용됩니다.\n- 세마포어: 상호 배제를 보장하여 임계 구역에 하나의 프로세스만 들어가도록 합니다.\n- 상호 배제: 이 조건은 최소한 하나의 자원이 공유할 수 없는 모드로 보유되어야 한다는 것을 의미합니다. 프린터나 테이프 드라이브와 같은 일부 자원은 본질적으로 공유할 수 없기 때문에 이 조건을 제거하는 것이 항상 가능하지는 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# 장애 허용이란 무엇인가요?\n\n장애 허용은 시스템이 일부 구성 요소가 실패해도 올바르게 작동을 계속할 수 있는 능력을 말합니다. 이는 시스템의 신뢰성과 가용성을 유지하여 장애를 우아하게 처리합니다.\n\n# 서킷 브레이커란 무엇인가요?\n\n서킷 브레이커는 전기가 너무 많이 흐를 경우 자동으로 전기를 차단하여 전기 화재를 예방하고 가전제품을 보호하는 안전 스위치와 같은 역할을 합니다. 소프트웨어에서는 서킷 브레이커 패턴이 서비스의 장애를 막아 시스템이 회복할 수 있도록 요청 흐름을 중지합니다.\n\n<div class=\"content-ad\"></div>\n\n# SQL 대 NoSQL\n\n## SQL을 사용해야 하는 경우:\n\n- 구조화된 데이터: 데이터가 명확한 구조와 관계를 가지고 있을 때\n- 복잡한 트랜잭션: ACID 트랜잭션이 필요하여 데이터 무결성을 보장해야 할 때\n\n## NoSQL을 사용해야 하는 경우:\n\n<div class=\"content-ad\"></div>\n\n- 수평 확장성: 확장성이 중요할 때 NoSQL은 더 유연합니다.\n- 반구조화/구조화되지 않은 데이터: 관계형 모델에 잘 맞지 않는 JSON이나 XML과 같은 데이터에 적합합니다.\n\n## 인증과 권한 부여의 차이는 무엇인가요?\n\n- 인증(Authentication): 사용자의 신원을 확인하는 것으로, 일반적으로 비밀번호, 생체 인식 또는 보안 토큰과 같은 자격 증명을 통해 이루어집니다.\n- 권한 부여(Authorization): 인증된 사용자가 특정 리소스에 액세스하거나 특정 작업을 수행할 권한이 있는지 결정하는 것입니다.\n\n## REST란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nREST (Representational State Transfer)은 HTTP 프로토콜을 사용하여 분산 시스템 간 통신하는 시스템 디자인입니다.\n\n# 추상 클래스와 인터페이스의 차이점은 무엇인가요?\n\n- 추상 클래스: 인스턴스화 할 수 없는 부분적으로 정의된 클래스입니다. 추상 및 구체적인 메서드뿐만 아니라 인스턴스 변수를 가질 수 있습니다.\n- 인터페이스: 메서드 시그니처와 상수 필드만 포함하는 완전히 추상화된 구조입니다.\n\n# Java에서 equals()와 hashCode() 메서드의 차이점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- equals(): 두 개의 객체가 논리적으로 동일한지를 결정합니다.\n- hashCode(): 객체에 대한 해시 값을 제공합니다. HashMap 및 HashSet과 같은 해시 기반 컬렉션에서 올바른 동작을 보장하려면 두 메서드를 함께 오버라이드해야 합니다.\n\n## ArrayList와 LinkedList의 차이점은 무엇인가요?\n\n- ArrayList: 빠른 임의 접근을 제공하는 배열 기반 구현이지만 삽입/제거 속도가 느립니다.\n- LinkedList: 어느 위치에서든 빠른 삽입/제거를 제공하는 노드 기반 구현이지만 임의 접근 속도가 느립니다.\n\n## Checked와 Unchecked 예외의 차이점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 확인된 예외: 컴파일 시간에 확인되며 명시적으로 처리하거나 선언이 필요합니다.\n- 확인되지 않은 예외(런타임 예외): 실행 중에 발생하며 명시적 처리 없이 프로그램이 컴파일됩니다.\n\n# 자바에서 동시성을 다루는 방법은?\n\n자바에서 동시성은 쓰레드 클래스 또는 Runnable 인터페이스를 사용하여 다중 스레딩을 통해 처리하고, 동기화 메커니즘인 동기화 블록, volatile 변수 또는 java.util.concurrent 패키지의 클래스를 사용하여 공유 리소스에 대한 액세스를 제어할 수 있습니다.\n\n# 운영 중 버그를 모니터링하는 방법은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 로깅: Log4J를 사용합니다.\n- 로그 관리: Logstash 또는 Datadog와 같은 도구를 사용합니다.\n- 애플리케이션 상태 확인: Spring Actuator를 예로 사용합니다.\n- Kubernetes: 라이브니스 및 레디니스 프로브 사용합니다.\n\n# 자바에서 가비지 컬렉터는 어떻게 작동합니까?\n\n가비지 컬렉터는 더 이상 사용되지 않는 객체를 식별하고 할당 해제하여 메모리를 자동으로 관리하여 메모리를 해제하고 메모리 누수를 방지합니다.\n\n# 코드 품질을 유지하는 방법은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 코드 리뷰: 코드를 정기적으로 검토하여 명확하고 이해하기 쉽도록 유지합니다. 변수 이름, 주석, 코드 구조 등을 확인하는 것이 포함됩니다.\n- 자동화 테스팅: 단위 및 통합 테스트를 사용하여 코드가 예상대로 작동하고 변경 사항을 적용할 때 회귀가 발생하는 것을 방지합니다.\n- 리팩터링: 코드를 정기적으로 리팩터링하여 외부 동작을 변경하지 않고 구조와 가독성을 개선합니다.\n- 코딩 표준: 일관된 코딩 표준을 준수하여 코드를 읽고 유지하기 쉽도록 합니다.\n- 문서화: 코드를 문서화하여 다른 개발자가 쉽게 이해하고 사용하는 방법을 설명합니다.\n- IDE 플러그인 및 도구: SonarLint, CheckStyle 등의 플러그인 및 도구를 사용하여 보다 간결하고 깔끔한 코드를 작성합니다.\n\n# SOLID 원칙에 대해 간단히 설명해 줄 수 있나요?\n\n- SRP(Single Responsibility Principle): 클래스는 변경되어야 하는 이유가 단 하나여야 합니다.\n- OCP(Open/Closed Principle): 소프트웨어 엔티티는 확장 가능한 상태여야 하지만 수정할 수 없는 상태여야 합니다.\n- LSP(Liskov Substitution Principle): 슈퍼 클래스의 객체는 서브 클래스의 객체로 대체 가능해야 하며 이로 인해 프로그램의 정확성에 영향을 미치지 않아야 합니다.\n- ISP(Interface Segregation Principle): 클라이언트는 사용하지 않는 인터페이스에 의존하지 않아야 합니다.\n- DIP(Dependency Inversion Principle): 고수준 모듈은 저수준 모듈에 의존하면 안 되며 두 모듈 모두 추상화에 의존해야 합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n이 기사는 저자의 경험을 반영하여 시니어 자바 소프트웨어 엔지니어를 위한 일반적인 인터뷰 질문을 포괄적으로 제공합니다. 객체 지향 프로그래밍, 의존성 주입, 동시성 및 SOLID 원칙과 같은 중요한 주제를 다루며, 지원자가 효과적으로 준비할 수 있도록 간결하고 직접적인 답변을 제공합니다. 또한, 오류 허용성, SQL 대 NoSQL, 코드 품질 유지 방법과 같은 실제 관련 문제들을 다룹니다. 이러한 통찰을 공유함으로써, 이 기사는 시니어 자바 개발자들이 인터뷰에서 뛰어나고 자신의 경력을 발전시킬 수 있는 지식을 갖추도록 목표로 합니다.\n\n기억해 주세요, 이 기사는 정기적으로 보고된 추가 질문들이 발생할 때마다 업데이트되어야 한다는 아이디어를 가지고 있습니다.\n\n앞으로의 인터뷰에서 행운을 빕니다 ;)","ogImage":{"url":"/assets/img/2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-06-19-SeniorJavaSoftwareEngineerCommonInterviewQuestions_0.png","tag":["Tech"],"readingTime":6},{"title":"자바와 파이썬을 사용하여 나만의 ChatGPT와 유사한 챗봇 만들기","description":"","date":"2024-06-19 10:02","slug":"2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython","content":"\n\n## 처음부터 사용자 정의 LLM 추론 인프라 만들기\n\n![image](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_0.png)\n\n## 소개\n\n최근 몇 년간, 대형 언어 모델 (LLMs)이 기계와 상호 작용하는 방식을 혁신적으로 변화시키는 핵심 기술로 등장했습니다. OpenAI의 GPT 시리즈 (예: GPT-3.5 또는 GPT-4)로 표현되는 이러한 모델은 입력 텍스트 시퀀스를 가져와 일관된, 맥락에 부합하고 인간처럼 들리는 텍스트를 생성할 수 있습니다. 따라서 이러한 응용 프로그램은 고객 서비스, 콘텐츠 작성, 언어 번역 또는 코드 생성과 같은 다양한 분야에 걸쳐 다양합니다. 그러나 이러한 능력의 핵심에는 자연어 이해 과정을 개선하기 위한 어텐션 메커니즘, 규모에 걸쳐 기본 모델을 제공하기 위한 전이 학습, 데이터 증강, 또는 심지어 인간 피드백에서 강화 학습으로 이어지는 고급 기계 학습/통계 기술이 포함되어 있습니다. 이러한 시스템이 교육 과정을 확장하고 추론을 통해 지속적으로 성능을 개선할 수 있도록합니다.\n\n<div class=\"content-ad\"></div>\n\n인공지능의 하위 집합으로, 머신러닝은 데이터셋을 처리하여 패턴을 식별하고 데이터의 본질을 정확하게 나타내는 모델을 개발하는데 책임이 있습니다. 이 접근 방식은 가치 있는 지식을 생성하고 콘텐츠 생성, 대량 언어 모델을 주도하는 생성적 AI 분야를 포함한 다양한 작업을 가능하게 합니다. 이 분야가 자연어뿐만 아니라 생성 가능성이 있는 모든 종류의 콘텐츠에 집중하는 것을 강조할 필요가 있습니다. 오디오에서 소리, 목소리 또는 음악을 생성할 수 있는 모델부터, OpenAI의 SORA와 같은 최신 모델을 통해 비디오, 이미지에서도 텍스트 시퀀스로부터의 편집과 스타일 전환이 가능합니다. 이후의 데이터 형식은 특히 가치가 있습니다. 다중모달 통합과 이미지/텍스트 임베딩 기술을 이용하여 자연어를 통해 지식 표현의 잠재력을 효과적으로 보여줄 수 있습니다.\n\n그러나 이러한 종류의 작업을 수행하기 위해 모델을 만들고 유지하는 것은, 특히 대규모로 할 때 매우 어려운 작업입니다. 주요 이유 중 하나는 데이터이며, 데이터는 잘 작동하는 모델에 주요 기여를 합니다. 즉, 기능적으로 최적의 아키텍처와 고품질 데이터로 모델을 훈련하면 가치 있는 결과를 얻을 수 있습니다. 그러나 제공된 데이터가 부족하면 모델이 오도하는 결과물을 생성합니다. 따라서 데이터셋을 만들 때 특정 모델 아키텍처에 적합한 양의 데이터를 포함해야 합니다. 이 요구사항은 데이터 처리와 품질 검증을 복잡하게 만들며, 자동화나 스크래핑으로 데이터를 수집하는 경우 고려해야 할 잠재적인 법적, 개인정보 보호 문제도 있습니다.\n\n다른 이유는 하드웨어에 있습니다. 현재 많은 사용자로부터 대량의 데이터를 동시에 처리해야 하는 최신 배포 모델은 크기가 크며 추론 작업을 수행하고 고객에게 품질 높은 서비스를 제공하는 데 상당한 컴퓨팅 리소스가 필요합니다. 이는 경제적인 면에서도 막대한 비용으로 반영됩니다. 한편, 신뢰할 수 있는 서비스를 제공하기 위해 적절한 하드웨어로 서버와 데이터 센터를 구축해야하며, GPU, TPU, DPU 및 성능을 최대화하기 위해 신중히 선택된 구성 요소를 고려할 때 매우 비싸다는 점을 고려해야 합니다. 또한, 유지보수에는 잠재적 문제를 해결하고 필요할 때 시스템을 업그레이드할 수 있는 자격있는 인력이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 종류의 모델 및 대규모 배포에 대한 여러 다른 문제가 있습니다. 모두 모아보면, ChatGPT와 같은 시장의 선도적인 서비스에 맞물릴만큼 견고한 지원 인프라를 갖추어 시스템을 구축하는 것은 어렵습니다. 그럼에도 불구하고 공개 도메인의 다양한 오픈 소스 콘텐츠 및 기술 덕분에 참조 서비스에 상당히 수용 가능하고 합리적인 근사치를 달성할 수 있습니다. 또한, 그 중 일부에서 제시한 고도의 진전을 고려하면 사용하는 데 매우 간편하며, 추상화, 모듈성, 통합 용이성 및 개발 프로세스를 강화하는 기타 가치 있는 특성으로 인해 혜택을 얻을 수 있습니다.\n\n따라서 이 기사의 목적은 ChatGPT와 유사한 서비스를 지원하기 위한 컴퓨팅 시스템을 설계, 구현 및 배포하는 방법을 보여주는 것입니다. 최종 결과물은 기대되는 서비스 능력을 갖추지 못할 수 있지만, 높은 품질의 종속성과 개발 도구를 사용하고 좋은 아키텍처 설계를 통해 사용자의 요구에 따라 원하는 컴퓨팅 파워까지 쉽게 확장 가능하도록 보장합니다. 즉, 시스템은 아마 한 대만 포함하여 매우 제한된 리소스로 실행되는, 해당 리소스에 맞춘 처리량을 제공하거나 적절한 하드웨어를 갖춘 더 큰 컴퓨터 네트워크에서 확장 서비스를 제공할 수 있게 준비될 것입니다.\n\n# 아키텍처\n\n최초의 시스템 기능은 클라이언트가 텍스트 쿼리를 제출하고, 이를 LLM 모델에서 처리한 다음 소스 클라이언트로 반환하는 것입니다. 모든 구현 세부사항(컴포넌트 간 통신 프로토콜, 관련된 데이터 구조 등)은 일부러 생략되었다는 점을 유념하시기 바랍니다. 그러나 이제 목표 달성을 명확히 하였으므로 문제 해결에 있어 점차적으로 세부사항을 증가시키는 분해를 시작할 수 있습니다. 이를 기능 분해라고도 하는데, 검색 및 반환 쿼리를 받는 블랙박스 시스템(추상화)부터 시작하여 클라이언트가 시스템과 상호작용하는 방법 및 이러한 상호작용을 가능케 하는 기술들을 체계적으로 정의할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_1.png)\n\n먼저, 클라이언트가 무엇으로 구성되는지, 특히 사용자가 시스템과 상호 작용하기 위해 필요한 도구나 인터페이스가 무엇인지를 결정해야 합니다. 위에서 설명한 것처럼, 시스템이 현재 완전히 구현되어 작동 중인 기능적인 단위로 가정하고 클라이언트 및 클라이언트-시스템 연결에 중점을 두도록 합니다. 클라이언트의 경우 인터페이스는 다목적으로 설계된 웹 사이트를 통해 이용할 수 있으며 주로 데스크톱 장치를 대상으로 합니다. 모바일 앱도 개발되어 동일한 시스템 서비스를 사용하고 특정 인터페이스를 통합할 수 있지만, 추상적인 관점에서 모든 종류의 클라이언트를 하나로 통합하는 것이 바람직합니다. 즉, 웹 클라이언트입니다.\n\n그 후, 클라이언트와 시스템을 연결하여 정보 교환(예: 쿼리)이 발생할 수 있도록 해야 합니다. 이 단계에서 웹 클라이언트는 JavaScript와 같은 특정 기술에 의존하며, 이에 따른 모든 통신적인 함의가 있음을 유의해야 합니다. 다른 유형의 플랫폼의 경우, 해당 기술은 아마도 변경될 것이고, 예를 들어 모바일 클라이언트에서는 Java로, IoT 장치에서는 C/C++로 변경될 수 있으며, 호환성 요구 사항으로 시스템이 그에 맞게 적응해야 할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n커뮤니케이션을 확립하는 한 가지 방법은 소켓 및 유사한 도구를 사용하여 하위 수준에서 광범위한 프로토콜 제어를 허용하는 것입니다. 그러나 이 옵션은 모든 클라이언트 기술과의 호환성 제약조건을 충족해야 한다는 상기된 접속 제약사항을 고려해야 하며, 시스템은 모든 가능한 클라이언트 유형에서 쿼리를 수집할 수 있어야 합니다. 또한 광범위한 제어를 가지는 것은 코드 줄 수가 상당히 증가하고 유지 관리 및 확장성이 복잡해지므로 더 길고 잠재적으로 훨씬 더 복잡한 개발이 필요합니다.\n\n위에서 볼 수 있듯이, 가장 최적의 대안은 클라이언트와 계산을 담당하는 시스템 부분 간의 중개 역할을 하는 응용 프로그램 프로그래밍 인터페이스(API)를 구축하는 것입니다. API를 사용하는 주요 이점은 모든 내부 연결 처리(예: 소켓 열기 및 닫기, 스레드 풀링, 데이터 직렬화와 같은 중요한 세부 사항)가 API가 구축된 프레임워크에 의해 수행된다는 것입니다. 이렇게 함으로써 클라이언트는 단지 쿼리를 서버로 보내고 API가 실행되는 곳에서 응답을 기다리기만 하면 되며, 이 모든 것은 이 API 요청을 관리하는 의존성을 실현할 수 있습니다. 이전 점에서 파생된 또 다른 혜택은 API 엔드포인트를 수정함으로써 서비스 확장을 쉽게할 수 있다는 것입니다. 예를 들어, 시스템에 새 모델이나 다른 기능을 추가하려면 새 엔드포인트를 추가하고 구현하기만 하면 되며, 통신 프로토콜 자체나 클라이언트가 시스템과 상호 작용하는 방식을 변경할 필요가 없습니다.\n\n## 컴퓨팅 서비스\n\n클라이언트가 시스템과 우아하게 통신하는 메커니즘을 설정한 후, 들어오는 쿼리를 처리하고 해당 클라이언트에 합리적인 시간 안에 반환하는 방법을 다루어야 합니다. 그러나 먼저, 시스템에 쿼리가 도착하면 관련 추론 파이프라인이 메모리에 로드된 LLM이 장착된 기계로 재지정되어 그 파이프라인을 통해 쿼리를 횡단하여 나중에 반환될 결과 텍스트(LMM 답변)를 얻어야 합니다. 그 결과, 추론 프로세스는 여러 기계 사이에 분산되어 쿼리 해결에 사용될 수 없습니다. 이를 고려하여 추론 프로세스를 지원할 인프라를 디자인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이전 이미지에서 컴퓨팅 서비스는 단일 단위로 표현되었습니다. 이번에는 기계를 연결한 것으로 생각하면서 소켓을 사용하여 API 서버와 연결된 단일 채널을 통해 모든 API 쿼리를 해당 기계로 리디렉션할 수 있습니다. 시스템 부하를 한 곳에 집중시켜 모든 API 쿼리를 해당 기계로 집중할 수 있습니다. 상상해 보면, 이는 몇 명의 사람만 사용하는 홈 시스템에는 좋은 선택일 것입니다. 그러나 이 경우에는 접근하기 위한 방법을 확장 가능하게 만들어야 합니다. 따라서 컴퓨팅 자원이 증가함에 따라 최대한 많은 사용자에게 서비스를 제공할 수 있도록 해야 합니다. 그러나 먼저 이전에 언급한 계산 자원을 단위로 분할해야 합니다. 이렇게 하면 상호 연결 상태를 전반적으로 파악할 수 있으며 구조나 구성 방식을 변경하여 프로젝트 처리량을 최적화할 수 있습니다.\n\n이제 이후 편의상 노드라고 부르겠지만, 계산 단위는 (모두가 처리되지는 않는) 요청을 받아 권한이 있는 물리적 기계로 통합될 것입니다. 또한 노드를 (아마 줄어든) 기계 양으로 가상화할 수 있어서 지역적으로 병렬성을 도입하여 노드 당 총 처리량을 증가시킬 수 있습니다. 사용된 하드웨어에 대해서는 서비스의 목적 및 목표에 따라 많이 달라질 것입니다. 그러나 이 경우에는 표준 CPU, 모델 로딩 또는 쿼리 전달 시 문제가 발생하지 않도록 대량의 RAM, 그리고 몇몇 경우에는 TPUs를 포함할 수 있는 GPU와 같은 전용 프로세서를 가정할 것입니다.\n\n이제, API 서버에 연결되어 여러 노드를 연결하는 네트워크를 설정할 수 있습니다. 이를 통해 네트워크 전체적으로 시스템의 모든 자원을 최적으로 활용할 수 있도록 쿼리를 분산시킬 수 있습니다. 위에서 모든 노드가 트리 모양으로 구조적으로 연결되어 있는 것을 알 수 있습니다. 루트는 API 쿼리를 수집하고 이에 따라 전달하는 역할을 담당합니다. 어떻게 서로 연결할지에 대한 결정은 정확한 시스템 목적에 상당히 의존합니다. 이 경우에는 분배 기본원의 간단함을 위해 트리가 선택되었습니다. 예를 들어, API와 노드 간의 쿼리 전달을 최대화하려면 API에서 여러 트리의 루트로 연결이 되어야 하거나 원한다면 다른 다른 데이터 구조를 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n마지막으로 루트 노드에 도착한 쿼리가 어떻게 전달되고 처리되는지 정의해야 합니다. 이전과 마찬가지로 사용 가능한 동등하게 유효한 대안이 많이 있습니다. 그러나 우리가 따를 알고리즘은 시스템 노드를 연결하기 위해 트리 구조가 선택되었는지 이해하는 데도 도움이 될 것입니다.\n\n![image](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_4.png)\n\n쿼리는 하나의 노드에서 해결해야 하기 때문에 분산 알고리즘의 목표는 시스템 내에서 대기 중인 노드를 찾아서 입력 쿼리를 할당하여 해결하는 것입니다. 위에서 볼 수 있듯이, 자연 순서(1부터 시작)로 번호 매겨진 쿼리들의 순서를 고려한다면, 각 숫자는 해당 쿼리를 해결하기 위해 할당된 노드에 연결된 가장자리에 해당합니다. 이 구체적인 예제에서 번호를 이해하기 위해서는 노드에 도착하는 쿼리가 무한 시간이 소요되는 것으로 가정할 수 있으며, 따라서 각 노드가 점차 바쁠 수 있도록 보장함으로써 알고리즘의 휴리스틱을 이해하는 데 도움이 됩니다.\n\n요약하면, 루트 노드는 해결 처리를 수행하지 않도록 하고, 모든 용량을 API로 요청을 전달하는 데 사용할 것입니다. 다른 모든 노드에 대해서는 상위 계층 노드로부터 쿼리를 받은 경우, 첫 번째 단계는 이전 쿼리에 대해 계산을 수행하고 있는지 확인하는 것입니다. 비어 있는 경우 쿼리를 해결하고, 그렇지 않은 경우에는 라운드 로빈으로 하위 노드 중 하나에게 전달합니다. 라운드 로빈 방식으로, 각 쿼리는 다른 하위 노드로 리디렉션되어 전체 하위 목록을 순환 버퍼처럼 통과합니다. 이것은 노드의 지역 부하를 균등하게 아래쪽으로 분산시킬 수 있음을 의미하며, 각 노드의 리소스를 효과적으로 활용하고 더 많은 하위 노드를 추가하여 시스템을 확장할 수 있는 능력을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n마침내, 시스템이 현재 많은 사용자에게 서비스를 제공하고 있고, 리프 노드에 쿼리가 도착할 때 해당 노드가 바쁠 경우 해당 쿼리를 다시 보낼 후손이 없습니다. 따라서 모든 노드는 쿼리 대기 메커니즘이 있어야 하며, 이러한 상황에서 기다릴 수 있도록 대기하고, 대기 중인 쿼리 간의 일괄 작업을 적용하여 LLM 추론을 가속화할 수 있습니다. 또한 쿼리가 완료되면 시스템을 과부하시키지 않기 위해 쿼리를 트리 상단에 도달할 때까지 상위로 전달하는 대신, 직접 루트로 보내고 나서 API와 클라이언트에 도달하게 됩니다. 모든 노드를 API에 연결하거나 다른 대안을 구현할 수 있지만, 코드를 가능한 간단하게 유지하고 시스템을 최대한 성능 좋게 유지하기 위해 모든 것을 루트로 보냅니다.\n\n# 웹 클라이언트\n\n시스템 아키텍처를 정의하고 작업을 수행하는 방식을 설명한 후, 솔루션과 상호 작용할 때 사용자가 필요로 할 웹 클라이언트를 구축할 수 있습니다.\n\n예상했듯이, 웹 클라이언트는 기본 HTML, CSS 및 JavaScript로 구현되며, 모든 것이 편리하게 .html 파일 하나에 내장됩니다. 이 파일은 클라이언트가 응용 프로그램 시작 중에 대응하는 요청을 만들 때마다 API에 의해 제공되며, 즉 클라이언트가 브라우저로 들어가고 API가 진입점을 호스팅한 주소를 입력하는 경우 브라우저에 렌더될 .html 파일을 반환할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그런 다음 사용자가 시스템에 텍스트 쿼리를 보내고 싶어할 때, JavaScript가 내부적으로 해당 세부사항(데이터 유형, 엔드포인트 또는 CSRF 보안 토큰 등)을 포함한 HTTP 요청을 API로 제출합니다. 이 프로세스 내에서 AJAX를 사용함으로써, API가 요청한 값에 대한 반환 시 구동되는 원시 기능을 정의하는 것이 매우 간단해집니다. 결과를 화면에 표시하는 역할을 맡고 있습니다. 게다가, 보내진 메시지가 직접적으로 쓰인 텍스트나 반환된 텍스트가 아니라, 타임스탬프와 같은 다른 중요 파라미터를 포함하는 JSON으로 랩핑되어 있음을 언급할 가치가 있습니다. 이는 일부 시스템 구성 요소의 동기화를 관리하기 위해 필요에 따라 즉석으로 추가 필드를 추가할 수 있는 가능성을 제공합니다.\n\n# Django API\n\n웹 클라이언트가 준비되면, 필요한 서비스를 제공할 API를 구현할 수 있습니다.\n\nAPI를 구축하기 위한 여러 기술이 있지만, 이 프로젝트에서는 특히 Django를 이용하여 파이썬을 통해 전용 서버에서 사용하겠습니다. 이 결정은 이 프레임워크가 제공하는 다른 파이썬 종속성과의 높은 확장성 및 통합 용이성에 동기를 받았습니다. 또한, 보안 또는 기본 관리 패널과 같은 유용한 속성을 추가로 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_5.png)\n\n웹 클라이언트를 구성할 엔드포인트 중 하나는 기본 URL인 '/'로 표시되는 것입니다. 따라서 사용자가 위에 표시된 것과 같은 기본 HTTP 요청을 통해 서버에 액세스하면 API는 인터페이스를 표시하고 LLM 서비스로 요청을 시작하는 데 필요한 HTML 코드를 반환할 것입니다.\n\n![이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_6.png)\n\n동시에 사용자가 인터페이스에 액세스한 후 클라이언트의 요청을 지원해야 할 것입니다. 이러한 요청은 특별한 방법으로 관리되어야 하므로 쿼리 데이터가 해당 JSON 형식으로 전송될 'arranca'라는 자체 엔드포인트가 있을 것이며, API는 노드 트리를 사용하여 처리한 후 해결된 쿼리를 반환할 것입니다. 이 엔드포인트에서 서버는 계층 구조의 루트 노드와 사전에 설정된 소켓 채널을 사용하여 쿼리를 전달하고, 동기화 메커니즘을 통해 해당 응답을 기다릴 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n위의 코드와 관련하여 urls.py 파일에서는 URL과 엔드포인트 간의 관계를 저장하여, 기본 빈 URL이 템플릿 폴더에서 .html을 읽어서 다시 보내거나, /arranca URL이 쿼리를 해결하는 기능을 실행하도록 해당 기능에 할당됩니다. 또한, views 함수가 실행되어 주 서버 스레드를 시작합니다. 한편 settings.py에서 변경해야 할 것은 DEBUG 매개변수를 False로 변경하고 서버에 연결할 수 있는 호스트의 필요한 권한을 입력하는 것뿐입니다.\n\n마지막으로, views.py 스크립트가 있는데, 거기에는 모든 API 기능이 구현되어 있습니다. 먼저, 수신 및 처리 기능을 담당하는 주 스레드가 있습니다(루트 노드로부터 수신된 연결 처리). 이 연결은 초기에 시스템 전체 수명 동안 계속 유지됩니다. 그러나 중단되어 다시 설정해야 하는 경우를 대비하여 무한 루프 내에 배치되어 있습니다. 둘째로, index() 함수로 기본 엔드포인트가 구현되어 있으며, 이 함수는 GET 요청을 수행하는 경우 .html 콘텐츠를 클라이언트로 반환합니다. 추가적으로, 응용 프로그램에서 사용자가 제출하는 쿼리는 /arranca 엔드포인트를 통해 API로 전송되며, 동일한 이름의 함수로 구현됩니다. 거기서 입력 쿼리가 루트 노드로 전달되어 응답을 받을 때까지 차단되고 클라이언트로 반환됩니다. \n\n이러한 차단은 각 쿼리가 고유 식별자를 갖도록하고, arranca() 함수에 의해 JSON 메시지의 필드로 삽입되는 request_id라는 이름의 필드에서 수행되는 동기화 메커니즘을 통해 달성됩니다. 본질적으로 쿼리 도착 순서와 일치하는 자연수인 request_id가 됩니다. 따라서 루트 노드가 API로 해결된 쿼리를 보낼 때, 어떤 차단된 실행이 쿼리를 생성했는지 알 수 있어, 나머지를 차단 해제하고 반환하며 다시 차단할 수 있습니다.\n\n# Java Compute Nodes\n\n<div class=\"content-ad\"></div>\n\nAPI가 작동 중이므로 Java에서 노드 시스템을 구현하기로 결정했습니다. 이 언어를 선택한 주요 이유는 노드 간 통신을 가능하게 하는 기술에 의해 동기부여 받았기 때문입니다. 이 수준에서 가장 간단한 통신 의미론을 얻기 위해 소켓과 수동 직렬화된 메시지를 사용하지 않고, 다른 플랫폼에서는 Python의 Pyro4와 같은 해결책들이 제공되지만 그것들보다 다소 복잡할 수도 있는 RMI로 대체할 것입니다.\n\n원격 메서드 호출(RMI)은 분산 시스템을 생성할 수 있도록 하는 통신 패러다임으로, 별도의 기계에 호스팅된 원격 객체로 구성된 분산 시스템을 가능하게 합니다. 서로 원격 참조를 얻고 서비스 인터페이스 내에서 원격 메서드를 호출할 수 있습니다. 따라서 Java의 높은 추상화 정도로 인해, 노드 간 쿼리 전송은 송신 노드가 참조하는 객체로의 원격 호출을 이용하여 구현될 것이며, 이전에 Python에서 수동으로 처리한 API 연결 프로세스가 자동으로 처리될 것입니다.\n\n우선, 각 노드에 대해 원격 호출 가능한 메서드를 결정하는 원격 인터페이스를 정의해야 합니다. 데버깅 목적으로 관련 정보를 반환하는 메서드(log() 또는 getIP())와 다른 노드의 원격 참조를 얻고 상위 노드로 또는 하위 노드로 등록하는 책임이 있는 메서드가 있습니다. 이 노드에 대해 고유한 이름이라고 가정할 수 있는 이름을 사용합니다. 또한, 다른 노드로부터 들어오는 쿼리를 수신하기 위한 두 가지 다른 원시형(primitives)이 있으며(API에서 해결된 쿼리를 보내기 위한 sendMessagePython() 및 루트 노드에서만 실행되는 함수)이 있습니다.\n\n인터페이스로부터 노드 클래스 내에 해당 작업을 구현할 수 있으며, 시스템을 시작시킬 때마다 이 클래스를 인스턴스화하고 노드 트리에 새 기계를 추가하기로 결정할 수 있습니다. 노드 클래스에 포함된 주요 기능 중 하나는 다른 노드의 원격 참조를 얻는 getRemoteNode() 메서드이며, 이를 위해 이름 레지스트리에 액세스하고 lookup() 원시를 실행하여 등록된 경우 인터페이스 형식으로 원격 참조를 반환하거나 그렇지 않은 경우 null을 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n원격 참조를 가져오는 것은 트리를 구성하는 데 필수적입니다. 특히 부모 노드를 자손에 연결하거나 해결된 쿼리를 보내기 위해 루트에 대한 참조를 얻는 다른 메서드들에게 필요합니다. 그 중 하나는 connectParent()입니다. 자손 노드가 부모 노드와 연결해야 할 때 호출됩니다. 먼저 getRemoteNode()를 사용하여 부모 노드를 검색하고, 참조를 얻은 후에는 각 노드 인스턴스에 대한 로컬 변수에 할당합니다. 그런 다음 connectChild()를 호출하여 호출된 원격 노드를 자손 목록에 추가합니다. 부모 노드가 존재하지 않는 경우에는 null 객체에 대한 함수를 호출하려고 시도하면 예외가 발생합니다. \n\n다음으로, API로부터 쿼리를 수신하는 방법인 receiveMessagePython() 및 다른 노드로부터 receiveMessage() 메서드는 시스템의 올바른 작동에 방해가 될 수 있는 경쟁 조건을 피하기 위해 synchronized 절로 보호됩니다. 이러한 메서드들은 또한 쿼리 분배 휴리스틱을 구현하는데 책임이 있습니다. 이것은 수신된 쿼리를 보낼 대응 노드를 결정하기 위해 로컬 변수를 사용합니다.\n\n마지막으로, 노드 클래스에는 consultLLM() 메서드 내에서 쿼리 해결을 관리하기 위해 사용되는 스레드 풀이 있습니다. 이렇게 하면 해당 호출이 Java 코드 내에서 즉시 종료되어 필요한 계산을 실행할 스레드를 할당하고 프로그램에 제어를 반환하여 추가 쿼리를 받을 수 있게 됩니다. 이는 또한 노드가 어떤 계산을 수행 중인지 여부를 감지하는 데 유용합니다. 또한, 노드 클래스 내부의 다른 스레드 사용은 프로그램을 유지하는 역할인 connectServer() 메서드에서 루트 노드를 API와 쿼리 교환하기 위해 연결하는 역할을 합니다.\n\nUtilities 클래스에서는 노드 이름을 기반으로 원격 노드에 대한 참조를 등록하고 조회하는 LDAP 사용 컨텍스트를 생성하는 메서드만 있습니다. 이 메서드는 노드 클래스에 직접 배치할 수 있지만 이와 유사한 메서드가 더 필요한 경우를 대비하여 Utilities 클래스에 남겨서 디자인 패턴의 이점을 살리도록 하였습니다.\n\n노드 인스턴스의 생성 및 관리는 각각 수동으로 수행되며, 이는 Launcher 클래스에서 구현됩니다. 지정된 LDAP 서버에 등록된 특정 이름이 있는 노드가 시작될 때 명령 줄 인터페이스를 사용하여 해당 노드를 지시합니다. 일부 명령에는 다음이 포함됩니다:\n\n<div class=\"content-ad\"></div>\n\n- 로그: 노드 상태를 알기 위해서 유용한 정보를 출력합니다.\n- 부모: 노드를 이름으로 지정된 부모에 연결합니다.\n- 레지스트리: LDAP 디렉토리에 조직 단위 ou=Nodes 아래에 현재 등록된 모든 노드를 나열합니다. 레지스트리 서버를 모니터링하거나 새로운 노드를 만드는 데 유용할 수 있습니다.\n- 서버: 노드를 주소와 포트 번호로 지정된 서버에 연결합니다. 주로 서버는 Python API가 되겠지만, 다른 기능을 제공할 수도 있습니다.\n\n# LDAP 서버\n\n노드는 원격 객체이므로 이름에서 다른 노드로의 원격 참조를 얻을 수 있도록 허용하는 레지스트리에 액세스해야 합니다. Java에서는 머신에 레지스트리 서비스를 초기화하는 rmiregistry를 사용하는 솔루션이 제공됩니다. 그러나 다른 호스트에서 rebind()와 같은 보안 보호 작업을 실행할 때, 새로운 노드가 레지스트리를 포함한 다른 기계에 등록되지 않도록 보안 예외가 발생합니다. 이러한 이유로, 이 프로젝트는 단순함에 더해 Java 레지스트리가 제공하는 것보다 LDAP (Lightweight Directory Access Protocol)를 사용하여 Apache 서버를 레지스트리로 사용할 것입니다. 이 프로토콜은 디렉토리 시스템에 Name-Remote_Node 쌍의 저장을 관리할 수 있게 해 주며 다른 추가 기능을 통해 레지스트리 서비스를 크게 개선할 수 있습니다.\n\nLDAP를 사용하는 장점은 먼저 운영 복잡성에서부터 시작됩니다. 처음 보았을 때는 정반대로 보일 수 있겠지만, 실제로는 시스템을 다양한 보안 및 구성 요구 사항에 맞게 더 높은 수준의 세부 정보로 조정할 수 있는 것이 가능하게 만들어줍니다. 한편으로, 제공하는 인증 및 보안 기능은 호스트가 LDAP 서버에 의해 식별될 때 새로운 노드를 등록하는 등 보호된 작업을 수행할 수 있도록 합니다. 예를 들어 서버에 액세스하고 작업을 수행할 수 있는 컨텍스트 객체를 만들 때, 생성자의 HashMap에 인증 데이터를 추가할 수 있는 옵션이 있습니다. 컨텍스트를 만들었다면, 데이터가 서버가 기대하는 것과 일치함을 의미하며, 그렇지 않다면 연결이 인증되지 않은(“악의적인”) 호스트에 의해 이루어지고 있다고 가정할 수 있습니다. 이를 통해 시스템 노드만 서버 정보를 조작할 수 있도록 보장합니다. 다른 한편으로 LDAP는 노드 등록을 훨씬 더 효율적으로 중앙 집중식으로 처리하고 더 고급 상호 운용성을 제공하며 케르베로스와 같은 추가 서비스를 쉽게 통합할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n서버가 노드 레지스트리로 작동할 수 있도록하려면 특정 구성을 적용해야 합니다. 먼저, 프로젝트가 실제 (그리고 잠재적으로 악의적인) 사용자가 있는 환경에 배포되지 않을 것이기 때문에 모든 인증 옵션은 생략되어 간단하고 깔끔하게 유지됩니다. 다음으로, Distinguished Name을 정의하여 노드 이름을 해당 원격 객체와 연결할 수 있도록해야 합니다. 이 경우, 동일한 이름을 가진 여러 노드의 등록을 방지한다고 가정할 때, 우리는 노드 이름을 cn=(Common Name)과 같은 속성에 저장하기만 하면 됩니다. 이때 지정된 조직 단위 내에서 ou=Nodes와 같은 형식의 식별 이름이 됩니다: cn=Node_Name,ou=Nodes\n\n![이미지](\" /assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_7.png\")\n\n새로운 노드가 생성될 때마다, 노드는 서버에 등록되며 그 distinguished name과 노드 인스턴스가 새로운 디렉토리 항목 형식으로 사용됩니다. 마찬가지로, 노드를 삭제하거나 레지스트리에서 해당 원격 참조 값을 가져오려면 distinguished name을 사용해야 합니다. 이 레지스트리에 대한 이러한 작업을 수행하려면 LDAP 서버에 연결을 열어두어야 합니다. 그러나 노드가 Java로 작성되었기 때문에 연결 프로세스 전체를 추상화하고 작업 호출에만 집중할 수 있는 서비스를 사용할 수 있습니다. 노드에서 사용할 서비스는 DirContext 인터페이스에 의해 일반적으로 정의됩니다. 따라서 서버에 액세스하고 일부 관리를 수행하는 프로세스는 InitialDirContext와 같은 인터페이스를 구현하는 객체를 생성하는 것만으로 충분하며, 이를 위해 서버를 식별하는 데 필요한 적절한 매개변수를 할당해야 합니다. 이때 ldap://IP:port/ 형식의 URL, 사용할 프로토콜을 식별하는 것을 포함하는데 심지어 이 프로젝트에서 사용하지 않을 인증 매개변수도 있습니다.\n\n## 조회, 바인드 및 언바인드\n\n<div class=\"content-ad\"></div>\n\n간단하게 말씀드리자면 런처는 개별 컨텍스트 개체를 갖고, 각 노드도 개별 컨텍스트를 갖게 됩니다. 이렇게 하면 런처가 항목을 생성하고 삭제할 수 있고, 각 노드는 노드 이름으로부터 원격 참조를 얻기 위한 조회 작업을 수행할 수 있습니다. 삭제 작업은 가장 간단합니다. 해당 노드에 해당하는 서버 항목의 식별 이름만 필요합니다. 항목이 존재한다면 삭제되고 unbind() 호출이 성공적으로 종료됩니다. 그렇지 않으면 예외가 발생합니다. 한편, 조회 및 등록 작업은 RFC-2713을 준수해야 합니다. 서버에 노드를 추가하는 경우, bind() 원시 함수를 사용합니다. 이 함수는 노드가 호스팅될 항목의 식별 이름과 해당 원격 개체를 전달받습니다. 그러나 bind 함수는 노드 개체 자체나 인터페이스를 바로 받지 않습니다. 왜냐하면 해당 객체가 직렬화될 수 없으며 bind()가 인터페이스 \"인스턴스\"를 직접 얻을 수 없기 때문입니다. 이 문제를 우회하기 위해 상기 RFC는 해당 노드 인스턴스가 MarshalledObject에 의해 마스킹되어야 한다고 합니다. 결과적으로 bind는 서버 내에서 등록할 노드로 구성된 MarshalledObject를 받아서 원래 노드 인스턴스가 아닌 노드가 수행됩니다.\n\n마지막으로, 조회 작업은 컨텍스트를 통해 lookup() 원시 함수를 사용하여 수행됩니다. 이전에 이름과 노드가 등록되지 않았거나 프로세스 중에 예기치 않은 오류가 발생하는 경우 예외가 발생합니다. 반대로 작업이 성공하면 조회된 쿼리의 식별 이름과 관련된 MarshalledObject가 반환됩니다. 그러나 lookup()에서 반환된 원격 참조는 레지스트리에 저장된 MarshalledObject 래퍼에 포함되어 있습니다. 따라서 MarshalledObject의 get() 작업을 사용하여 사용 가능한 원격 참조를 얻어야 합니다. 또한 이 기능을 사용하여 bind()를 실행하기 전에 동일한 이름을 갖는 다른 노드의 등록을 방지할 수 있으므로, lookup()을 사용하여 해당 식별 이름이 있는지 확인할 수 있습니다.\n\n# LLM 추론\n\n각 노드의 추론 프로세스에 관한 추론 프로세스에 대한 내용에 대해, 노드 트리에는 LLMProcess 클래스가 있으며 이는 Python에서 구현된 프로세스를 인스턴스화하는 역할을 맡습니다. 쿼리가 해결되기 전에 Python에서 LLM 및 그 추론 파이프라인을 쉽게 관리할 수 있기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 LLMProcess가 생성될 때, Java와 Python 프로세스 간 통신을 위해 머신에서 사용 가능한 포트를 찾아야 합니다. 간편하게 데이터 교환은 소켓을 사용하여 수행되며, ServerSocket을 열고 닫아 사용 가능한 포트를 찾은 후에는 llm.py 프로세스가 포트 번호를 매개변수로 전달받아 실행됩니다. 이 프로세스의 주요 기능은 destroyProcess()로 시스템이 중지될 때 프로세스를 종료하고 sendQuery()로 llm.py에 쿼리를 전송하고 각 쿼리마다 새 연결을 사용하여 응답을 대기하는 것입니다.\n\nllm.py 내부에는 Java 프로세스로부터 수신 대기하는 무한 루프가 있습니다. 이러한 연결이 확립되면 ThreadPoolExecutor() 스레드를 통해 handle_connection() 함수에 의해 처리되며, 채널로부터 입력 데이터를 읽고 JSON 형식으로 해석하여 \"text\" 필드를 추론 파이프라인으로 전달합니다. 데이터가 반환되면 Java 프로세스로 다시 전송되며, 함수가 반환되고 해당 스레드도 해제됩니다.\n\n## 모델 성능\n\n스크립트에서 확인할 수 있듯이, 파이프라인 인스턴스를 통해 호스팅된 노드에서 실행될 LLM 모델을 선택할 수 있습니다. 이를 통해 Huggingface 웹사이트에 업로드된 모든 모델에 액세스할 수 있으며, 코드 생성 모델, 채팅, 일반 응답 생성 등과 같이 매우 다양한 옵션을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n기본적으로 우리는 약 117백만 개의 매개변수와 약 500MB의 무게를 가진 gpt2 모델을 사용합니다. 이 모델은 가장 가벼우면서 통합하기 가장 쉬운 옵션이죠. 이 모델은 매우 작기 때문에 답변이 상당히 기본적입니다. 입력된 텍스트에 가장 가까운 예측과 매칭되는 쿼리 해결이라고 할 때 아래 텍스트의 예측이 곧 입력된 것과 일치하는 것을 주목해주세요. 예를 들어:\n\ngpt2-large 또는 gpt2-xl과 같은 다른 버전의 gpt2도 있습니다. 모든 것이 Huggingface에서 제공되며 가장 강력한 XL 형식은 15억 개의 매개변수와 6GB의 무게를 가지고 있습니다. 이를 실행하려면 상당히 더 많은 강력한 하드웨어가 필요하며, 일관된 응답을 생성합니다. \n\nOpenAI GPT 시리즈 외에도 다양한 다른 사용 가능한 모델을 선택할 수 있습니다. 그러나 대부분의 경우 스크립트에 삽입할 인증 토큰이 필요합니다. 최근에는 공간 점유 및 쿼리를 전체 추론 파이프라인을 통해 실행하는 데 필요한 시간을 최적화한 현대화된 모델들이 출시되었습니다. Llama3도 이 중 하나로, 8B 매개변수의 작은 버전과 70B의 대형 버전을 제공합니다.\n\n그러나 시스템에 모델을 선택할 때는 매개변수의 개수만을 기준으로 삼으면 안 됩니다. 모델의 아키텍처가 모델이 적용할 수 있는 지식의 양을 결정하기 때문이죠. 따라서 작은 모델은 대형 모델과 매우 유사한 성능을 발휘할 수 있습니다. 즉, 매우 유사한 언어 이해 능력을 갖춘 답변을 생성하는 동시에 이를 생성하는 데 필요한 컴퓨팅 자원을 최적화할 수 있죠. Huggingface 자체에서 제공되는 벤치마크 또는 LLM의 위에서 언급한 매개변수를 측정하는 전문 테스트를 사용할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위의 테스트 결과와 특정 하드웨어에서 응답하는 데 걸리는 평균 시간은 모델을 선택하는 데 꽤 완벽한 지표입니다. 그러나 항상 기억해야 할 점은 LLM은 실행 중인 칩 메모리에 맞아야 합니다. 따라서 우리가 llm.py 스크립트에서 CUDA를 사용한 GPU 추론을 사용하는 경우, 그래픽 메모리는 모델 크기보다 커야 합니다. 그렇지 않으면 계산을 여러 대의 GPU 또는 하나 이상의 기기에서 복잡성을 달성하고자 하는 데 따라 동등하게 분산해야 합니다.\n\n## Kotlin Mobile Client\n\n마무리하기 전에 새로운 유형의 클라이언트가 시스템에 포함될 수 있는 방법을 살펴볼 수 있습니다. 이로써 지금까지 구축한 모든 것이 제공하는 확장성을 증명할 수 있습니다. 물론 이 프로젝트는 분산 시스템을 시도한 것이므로, 일반적인 ChatGPT 앱이 Android 및 iOS와 호환되는 것과 마찬가지로 모바일 기기와도 호환될 것으로 예상됩니다. 우리의 경우에는 네이티브 Android용 앱을 개발할 수 있지만, 훨씬 더 나은 옵션은 시스템을 다중 플랫폼 jetpack compose 프로젝트로 적응하는 것일 것입니다. 이 옵션은 장래의 업데이트 가능성으로 남아 있습니다.\n\n초기 아이디어는 모바일 클라이언트를 API에 연결하고 웹과 같은 요청을 하며 HttpURLConnection과 같은 종속성을 사용하는 것입니다. 코드 구현은 어렵지 않으며 공식 페이지에서 제공하는 안드로이드 문서도 이러한 목적에 유용합니다. 그러나 일반 TCP 안드로이드 소켓을 사용하여 사용자 정의 코틀린 중간 구성 요소로 API의 기능을 에뮬레이트할 수도 있습니다. 소켓은 상대적으로 사용하기 쉽고, 모든 것이 올바르게 작동하도록 노력을 기울이며 코드에 대한 꽤 많은 제어 수준을 제공합니다. 규제 API의 부재를 해결하기 위해 이동 클라이언트와 자바 노드 트리 사이에 코틀린 노드를 배치하여 근원 노드와 웹 클라이언트 및 API가 분리되는 한 이동 클라이언트와만 연결을 관리할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n인터페이스 측면에서, 저희가 모방하는 애플리케이션인 ChatGPT는 매우 깔끔하고 현대적인 느낌을 가지고 있습니다. HTTP 버전은 이미 완성되었으므로 안드로이드 스튜디오 편집기에서 가능한 한 가깝게 복사해 보겠습니다.\n\n![ChatGPT 이미지](/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_8.png)\n\n소켓을 사용할 때, 사용자가 문제를 해결할 서버의 올바른 IP 주소와 포트에 연결되어 있는지 확인해야 합니다. 애플리케이션을 열 때마다 새로운 초기 인터페이스가 나타나도록하여 이를 달성할 수 있습니다. 간단한 버튼, IP 주소를 입력할 수 있는 텍스트 뷰, 사용자에게 발생한 일들을 실시간으로 알려주는 작은 텍스트 레이블이 있는 뷰로 구성될 것입니다. 위 이미지에서 확인할 수 있습니다.\n\n그런 다음, 새로운 메시지가 하단에 나타나고 이전 메시지가 위로 이동하는 실제 채팅과 비슷한 인터페이스를 가져야 합니다. 이를 위해 화면의 약 80%를 차지할 RecyclerView를 삽입할 수 있습니다. 사전 정의된 메시지 뷰를 동적으로 추가해 실제로 메시지가 사용자인지 시스템인지에 따라 변경될 수 있도록 계획하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n마침내, Android 연결의 문제는 주 스레드에서 네트워크 관련 작업을 수행할 수 없다는 것이며, 그렇게 하면 NetworkOnMainThreadException이 발생할 수 있다는 것입니다. 동시에, 주 스레드가 아닌 곳에서 구성 요소를 관리할 수 없다면, CalledFromWrongThreadException이 발생할 것입니다. 이 문제를 해결하는 방법은 연결 뷰를 주 스레드로 이동시키고, 주 목적은 코루틴을 잘 활용하여 네트워크 관련 작업을 수행할 수 있도록 하는 것입니다.\n\n<img src=\"/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_9.png\" />\n\n이제 시스템을 실행하고 텍스트 쿼리를 입력하면, 몇 초 후에 답변이 나타날 것입니다. 이는 ChatGPT와 같은 대규모 애플리케이션에서와 같이 작동합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n기능적인 시스템을 갖고 있더라도, 구현된 기술에 따라 중요한 개선이 가능합니다. 소프트웨어와 하드웨어 모두 그렇죠. 그러나 가용 자원에 따라 크게 변동될 수 있는 소수의 사용자에게 꽤 괜찮은 서비스를 제공할 수 있습니다. 마지막으로, ChatGPT와 같은 실제 시스템의 성능을 달성하는 것은 복잡합니다. 모델 크기와 그를 지원하는 하드웨어가 비실렉한 특히 비용이 많이 듭니다. 이 글에서 보여준 시스템은 소규모 또는 중간 해결책에 매우 적합하게 확장 가능하지만 대규모 해결책을 달성하기 위해서는 훨씬 더 복잡한 기술이 필요할 뿐만 아니라 이 시스템의 구조 중 일부를 활용하는 것이 필요할 수도 있습니다.\n\n# 감사의 글\n\nKotlin 모바일 클라이언트 섹션에서의 협업에 감사드립니다. deivih84님, RMI 및 분산 시스템 구현에 참여해 주신 carolinaherasc님 그리고 시스템 관리 구성 요소 개발에 참여해 주신 hugodiezrubio님께 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_0.png"},"coverImage":"/assets/img/2024-06-19-BuildYourOwnChatGPT-likeChatbotwithJavaandPython_0.png","tag":["Tech"],"readingTime":20},{"title":"UUID 대 ULID 어떤 것을 사용해야 할까요","description":"","date":"2024-06-19 10:00","slug":"2024-06-19-UUIDvsULID","content":"\n\n먼저 UUID와 ULID는 무엇인가요?\n\nUUID (Universally Unique Identifier):\n\n- UUID는 컴퓨터 시스템에서 정보를 고유하게 식별하는 데 사용되는 128비트 숫자입니다.\n- 이들은 RFC 4122 표준에서 정의되어 있으며 여러 가지 버전의 UUID를 설명합니다.\n- UUID는 소프트웨어 개발, 데이터베이스 및 고유 식별자가 필요한 다른 응용 프로그램에서 널리 사용됩니다.\n- UUID의 주요 장점은 고유성, 분산 생성 및 플랫폼 독립성입니다.\n- 그러나 UUID는 본질적으로 날짜 순서로 정렬할 수 없기 때문에 특정 사용 사례에서는 단점일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nULID (Universally Unique Lexicographically Sortable Identifier):\n\n- ULID는 렉시코그래픽적으로 정렬 가능한 128비트 식별자입니다.\n- 이 식별자는 UUID의 대안으로 2016년에 도입되었으며 정렬 가능한 고유 식별자를 제공하는 것을 목표로 합니다.\n- ULID는 타임스탬프(48비트)와 랜덤 부분(80비트)으로 구성되어 고유성과 시간순 정렬을 모두 가능하게 합니다.\n- ULID의 타임스탬프 부분은 유닉스 에포크 이후의 밀리초 수를 기반으로 하므로 시간에 따라 정렬 가능합니다.\n- ULID는 UUID와 크기 및 구조적으로 호환되지만 정렬 가능한 추가 혜택을 제공합니다.\n- 시간 순서가 중요한 경우에 유의미할 수 있는데, 예를 들어 시계열 데이터 또는 이벤트 로깅 시나리오에서 활용될 수 있습니다.\n\nUUIDs (자바에서의 Guid)는 데이터베이스에서 고유 식별자로 널리 사용됩니다. UUID는 무작위적이어서 분산 시스템에서 인기가 있습니다.\n\n하지만 UUID에는 몇 가지 단점이 있습니다:\n\n1. UUID는 데이터베이스 삽입 속도를 늦춥니다. 각 삽입은 클러스터화된 인덱스 인 B+ 트리를 업데이트해야 합니다. UUID가 무작위인 점 때문에 이 작업은 트리를 균형잡기 위한 비용이 많이 드는 작업입니다.\n\n2. 더 높은 저장 비용. UUID는 128비트이며 이를 문자열 형식으로 인간이 읽을 수 있는 형태로 저장하는 경우 더 길어집니다.\n\n그래서, ULID에 대해 소개하겠습니다.\n\nULID는 UUID의 단점을 해결하려고 합니다. 또한 128비트이므로 UUID와 호환됩니다. 그러나 UUID와 달리, ULID는 정렬 가능합니다. ULID의 처음 40비트는 타임스탬프를 나타내어 ULID가 단조로운 증가를 보입니다.\n\n어떤 식별자를 선택할지 결정할 때는 애플리케이션의 특정 요구 사항에 따라 UUID와 ULID 중에서 선택하게 됩니다. UUID는 더 널리 채택되고 더 많은 지원을 받지만, ULID는 시간순서대로 정렬할 수 있는 이점을 제공합니다. 여러분의 기사에서는 두 식별자 간의 트레이드오프, 특히 한 쪽이 다른 쪽보다 선호되는 사용 사례를 탐구할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# UUID 및 ULID의 Java 예제:\n\nUUID 예제:\n\n```java\nimport java.util.UUID;\n\npublic class UUIDExample {\n    public static void main(String[] args) {\n        // 새 UUID 생성\n        UUID uuid = UUID.randomUUID();\n        System.out.println(\"UUID: \" + uuid.toString());\n\n        // 문자열에서 UUID 파싱\n        String uuidString = \"123e4567-e89b-12d3-a456-426655440000\";\n        UUID parsedUuid = UUID.fromString(uuidString);\n        System.out.println(\"파싱된 UUID: \" + parsedUuid);\n\n        // 두 UUID 비교\n        if (uuid.equals(parsedUuid)) {\n            System.out.println(\"두 UUID가 동일합니다.\");\n        } else {\n            System.out.println(\"두 UUID가 동일하지 않습니다.\");\n        }\n    }\n}\n```\n\nULID 예제:\n\n<div class=\"content-ad\"></div>\n\n```java\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.github.brianrubin.ulid.ULID;\n\npublic class ULIDExample {\n    public static void main(String[] args) {\n        // 새 ULID 생성\n        ULID ulid = ULID.randomULID();\n        System.out.println(\"ULID: \" + ulid.toString());\n\n        // 문자열에서 ULID 파싱\n        String ulidString = \"01GKKH6DAT6DS3B7MVTX3ABD2F\";\n        ULID parsedUlid = ULID.fromString(ulidString);\n        System.out.println(\"파싱된 ULID: \" + parsedUlid);\n\n        // 두 ULID 비교\n        if (ulid.equals(parsedUlid)) {\n            System.out.println(\"ULID가 동일합니다.\");\n        } else {\n            System.out.println(\"ULID가 다릅니다.\");\n        }\n\n        // ULID를 JSON 객체로 변환\n        ObjectMapper mapper = new ObjectMapper();\n        ObjectNode jsonNode = mapper.createObjectNode();\n        jsonNode.put(\"id\", ulid.toString());\n        System.out.println(\"ULID를 JSON으로: \" + jsonNode.toString());\n    }\n}\n```\n\nUUID 예제에서는 새 UUID 생성, 문자열에서 UUID 파싱, 두 UUID 비교하는 방법을 보여줍니다.\n\nULID 예제에서는 com.github.brianrubin.ulid.ULID 라이브러리를 사용하여 ULID를 다루는 방법을 보여줍니다. 새 ULID 생성, 문자열에서 ULID 파싱, 두 ULID 비교, ULID를 JSON 객체로 변환하는 방법을 보여줍니다.\n\n두 방식의 주요 차이점은 ULID가 식별 정보를 사전순으로 정렬할 수 있도록 설계되었으며 UUID와는 다르게 타임스탬프 구성 요소를 포함한다는 점입니다. 특정 응용 프로그램에서 유용할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-UUIDvsULID_0.png"},"coverImage":"/assets/img/2024-06-19-UUIDvsULID_0.png","tag":["Tech"],"readingTime":4},{"title":"Java Spring Boot 코드 리팩터링 더 깔끔하고 확장 가능한 로직을 위해 If-Else 문 제거하기","description":"","date":"2024-06-19 09:59","slug":"2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic","content":"\n\nif-else 문은 널리 사용되지만 과용하면 복잡하고 유지보수가 어려운 코드를 작성하게 될 수 있습니다. 이 기사에서는 Java Spring Boot 프로젝트에서 if-else 구조의 사용을 줄이는 다양한 전략을 탐색하며 코드를 모듈화하고 유지보수 가능하며 가독성 있게 만드는 데 초점을 맞춥니다.\n\n![image](/assets/img/2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic_0.png)\n\n## if-else 문 줄이는 전략\n\n- 전략 패턴\n- Enum 사용\n- 다형성\n- 람다 표현식 및 함수형 인터페이스\n- 명령 패턴\n- 가드 절(recipes)\n\n<div class=\"content-ad\"></div>\n\n각 전략에 대해 예제와 함께 자세히 파헤쳐 봅시다.\n\n### 1. 전략 패턴\n\n전략 패턴은 알고리즘의 집합을 정의하고, 각각을 캡슐화하며, 서로 교환할 수 있게 만드는 패턴입니다. 이 패턴은 특정 작업을 수행하는 여러 방법이 있는 경우 유용합니다.\n\n### 예제: 결제 처리 시스템\n\n<div class=\"content-ad\"></div>\n\n먼저 PaymentStrategy 인터페이스를 정의합니다:\n\n```java\npublic interface PaymentStrategy {\n    void pay(double amount);\n}\n```\n\n다음으로 다양한 결제 전략을 구현합니다:\n\n```java\n@Component\npublic class CreditCardPayment implements PaymentStrategy {\n    @Override\n    public void pay(double amount) {\n        // 신용카드 결제 처리 로직\n        System.out.println(\"신용카드를 사용하여 \" + amount + \" 결제되었습니다.\");\n    }\n}\n\n@Component\npublic class PaypalPayment implements PaymentStrategy {\n    @Override\n    public void pay(double amount) {\n        // PayPal 결제 처리 로직\n        System.out.println(\"PayPal을 사용하여 \" + amount + \" 결제되었습니다.\");\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경하십시오.\n\n\n| 구분 | 설명 |\n|---|---|\n| 1 | 첫 번째 |\n| 2 | 두 번째 |\n\n\n<div class=\"content-ad\"></div>\n\n## 예시: 주문 상태 관리\n\n다양한 동작을 가진 OrderStatus enum을 정의합니다:\n\n```js\npublic enum OrderStatus {\n    NEW {\n        @Override\n        public void handle() {\n            System.out.println(\"신규 주문 처리 중.\");\n        }\n    },\n    SHIPPED {\n        @Override\n        public void handle() {\n            System.out.println(\"주문 발송됨.\");\n        }\n    },\n    DELIVERED {\n        @Override\n        public void handle() {\n            System.out.println(\"주문 배송 완료됨.\");\n        }\n    };\n\n    public abstract void handle();\n}\n```\n\n이 enum을 서비스에서 사용하세요:\n\n<div class=\"content-ad\"></div>\n\n```java\n@Service\npublic class OrderService {\n    public void processOrder(OrderStatus status) {\n        status.handle();\n    }\n}\n```\n\n## 3. Polymorphism\n\n다형성은 객체를 실제 클래스가 아닌 부모 클래스의 인스턴스로 취급할 수 있게 합니다. 이를 통해 부모 클래스의 참조를 통해 파생 클래스의 재정의된 메소드를 호출할 수 있습니다.\n\n## Example: Notification System\n\n\n<div class=\"content-ad\"></div>\n\n```java\n// `Notification` 인터페이스와 그 구현 클래스 정의:\n\npublic interface Notification {\n    void send(String message);\n}\n\npublic class EmailNotification implements Notification {\n    @Override\n    public void send(String message) {\n        // 이메일 전송 로직\n        System.out.println(\"이메일 전송 중: \" + message);\n    }\n}\n\npublic class SmsNotification implements Notification {\n    @Override\n    public void send(String message) {\n        // SMS 전송 로직\n        System.out.println(\"SMS 전송 중: \" + message);\n    }\n}\n\n// 다형성을 사용하는 서비스 생성:\n\n@Service\npublic class NotificationService {\n    private final List<Notification> notifications;\n\n    public NotificationService(List<Notification> notifications) {\n        this.notifications = notifications;\n    }\n\n    public void notifyAll(String message) {\n        for (Notification notification : notifications) {\n            notification.send(message);\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 4. 람다 표현식과 함수형 인터페이스\n\n람다 표현식은 코드를 간단하게 만들어 줄 수 있어, 특히 작고 단일 메서드 인터페이스를 다룰 때 유용합니다.\n\n## 예시: 할인 서비스\n\n람다 표현식을 사용하는 할인 서비스를 정의하세요:\n\n<div class=\"content-ad\"></div>\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\npublic class DiscountService {\n    private Map<String, Function<Double, Double>> discountStrategies = new HashMap<>();\n\n    public DiscountService() {\n        discountStrategies.put(\"SUMMER_SALE\", price -> price * 0.9);\n        discountStrategies.put(\"WINTER_SALE\", price -> price * 0.8);\n    }\n\n    public double applyDiscount(String discountCode, double price) {\n        return discountStrategies.getOrDefault(discountCode, Function.identity()).apply(price);\n    }\n}\n```\n\n## 5. Command Pattern\n\nThe Command Pattern encapsulates a request as an object, thereby allowing you to parameterize clients with queues, requests, and operations.\n\n## Example: File Operations\n\n<div class=\"content-ad\"></div>\n\n아래는 Command 인터페이스와 구체적인 명령어를 정의한 코드입니다:\n\n```js\npublic interface Command {\n    void execute();\n}\n\npublic class OpenFileCommand implements Command {\n    private FileSystemReceiver fileSystem;\n\n    public OpenFileCommand(FileSystemReceiver fs) {\n        this.fileSystem = fs;\n    }\n\n    @Override\n    public void execute() {\n        this.fileSystem.openFile();\n    }\n}\n\npublic class CloseFileCommand implements Command {\n    private FileSystemReceiver fileSystem;\n\n    public CloseFileCommand(FileSystemReceiver fs) {\n        this.fileSystem = fs;\n    }\n\n    @Override\n    public void execute() {\n        this.fileSystem.closeFile();\n    }\n}\n```\n\n아래는 FileSystemReceiver와 Invoker를 정의한 코드입니다:\n\n```js\npublic interface FileSystemReceiver {\n    void openFile();\n    void closeFile();\n}\n\npublic class UnixFileSystemReceiver implements FileSystemReceiver {\n    @Override\n    public void openFile() {\n        System.out.println(\"Unix 운영체제에서 파일을 엽니다.\");\n    }\n\n    @Override\n    public void closeFile() {\n        System.out.println(\"Unix 운영체제에서 파일을 닫습니다.\");\n    }\n}\n\npublic class FileInvoker {\n    private Command command;\n\n    public FileInvoker(Command cmd) {\n        this.command = cmd;\n    }\n\n    public void execute() {\n        this.command.execute();\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 6. 가드 구문\n\n가드 구문은 조건을 조기에 처리하여 중첩 구조를 줄여 코드를 더 읽기 쉽게 만드는 방법을 제공합니다.\n\n## 예시: 사용자 유효성 검사\n\n사용자 입력을 유효성 검사하기 위해 if-else 문을 중첩하는 대신, 가드 구문을 사용하여 잘못된 경우를 미리 처리하세요.\n\n<div class=\"content-ad\"></div>\n\n```java\npublic class UserService {\n    public void registerUser(User user) {\n        if (user == null) {\n            throw new IllegalArgumentException(\"User cannot be null\");\n        }\n        if (user.getName() == null || user.getName().isEmpty()) {\n            throw new IllegalArgumentException(\"User name cannot be empty\");\n        }\n        if (user.getEmail() == null || user.getEmail().isEmpty()) {\n            throw new IllegalArgumentException(\"User email cannot be empty\");\n        }\n        // Proceed with registration\n        System.out.println(\"Registering user: \" + user.getName());\n    }\n}\n```\n\n이 접근 방식을 통해 잘못된 조건을 조기에 처리하고 주요 로직을 보다 깔끔하고 이해하기 쉽게 유지할 수 있습니다.\n\n# 결론\n\n이러한 전략을 적용함으로써 Java Spring Boot 프로젝트에서 if-else 문의 사용을 크게 줄일 수 있습니다. 이는 코드를 더 읽기 쉽게 만들 뿐만 아니라 유지보수성과 확장성을 향상시킵니다. 이러한 패턴과 관행을 받아들여 더 깨끗하고 효율적인 코드를 작성해 보세요.\n\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료\n\n- Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley.\n- Bloch, J. (2018). Effective Java. Addison-Wesley.\n- Fowler, M. (2019). Refactoring: Improving the Design of Existing Code. Addison-Wesley.\n- Freeman, E., & Robson, E. (2020). Head First Design Patterns: Building Extensible and Maintainable Object-Oriented Software. O’Reilly Media.\n- Beck, K. (2003). Test Driven Development: By Example. Addison-Wesley.\n\n코딩을 즐기세요! 👨‍💻👩‍💻","ogImage":{"url":"/assets/img/2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic_0.png"},"coverImage":"/assets/img/2024-06-19-RefactoringJavaSpringBootCodeEliminatingIf-ElseStatementsforCleanerExtensibleLogic_0.png","tag":["Tech"],"readingTime":7},{"title":"자바 스트림을 기본형 컬렉션으로 수집하는 방법","description":"","date":"2024-06-19 09:58","slug":"2024-06-19-HowtocollectaJavaStreamintoaprimitiveCollection","content":"\n\n자바 스트림에 원시 컬렉션 브릿지를 사용하여 박싱을 피해보세요.\n\n![이미지](/assets/img/2024-06-19-HowtocollectaJavaStreamintoaprimitiveCollection_0.png)\n\n# 박싱 (Boxing)하는 건 그만두세요\n\n자바의 박싱된 컬렉션 유형은 Set`Integer`나 List`Double`과 같은 유형으로, 컬렉션에있는 int나 double과 같은 원시 값들을 Integer나 Double과 같은 박싱된 래퍼에 저장해야 하는 유형입니다. 자바의 박싱된 래퍼와 컬렉션 유형이 메모리를 조용히 소모하고 시간을 낭비하며 에너지를 소비합니다. 단일 박싱된 컬렉션의 비용은 일반적으로 무시할 정도입니다. 불행히도, 박싱된 컬렉션이 조용히 수백만 개의 자바 힙을 오염시켜, 아무것도 모르는 한 두 마리의 북극곰의 빙을 녹일 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Java Stream with Primitive Collections](/assets/img/2024-06-19-HowtocollectaJavaStreamintoaprimitiveCollection_1.png)\n\n이전에 블로그에서 Java에서 박싱이 왜 나쁜지, Java 개발자로서 애플리케이션 및 라이브러리에서 메모리 및 성능 효율성을 개선하는 옵션에 대해 언급했습니다. 저의 박싱이 왜 나쁜지에 대해 이해하고 싶다면 아래의 블로그를 읽어보세요.\n\n그렇다면 Java Stream의 훌륭한 세계와 Java의 효율적인 기본 컬렉션의 간극을 어떻게 좁힐 수 있을까요?\n\n우리는 박싱한 상태로 있지 않고 몇 가지 해결책을 살펴보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# Java 기본형 스트림\n\n자바는 세 가지 기본 유형(IntStream, LongStream, DoubleStream)에 대한 Stream 지원을 제공합니다. 우리는 mapToInt, mapToLong, mapToDouble을 사용하여 오브젝트 스트림을 이러한 기본 유형 중 하나인 스트림 유형으로 변환할 수 있습니다. 기본 스트림을 컬렉션으로 변환하려면 제한된 옵션이 있습니다.\n\n기본적으로 가장 많이 사용되는 옵션은 기본 스트림을 List<Integer>와 같은 상자화된 컬렉션으로 다시 수집하는 것입니다. 이것이 바로 우리가 피하려고 하는 것입니다.\n\n다른 옵션으로 기본 스트림을 기본 배열로 변환하는 것이 있습니다. 아쉽게도, 자바의 배열은 유용한 동작이 없습니다. 길이를 알려줄 뿐이며 요소에 대한 가변 액세스 권한을 제공하여 루프를 돌거나 변경할 수 있습니다. int[], long[], double[] 배열을 Arrays.stream() 메서드를 사용하여 다시 기본적인 스트림으로 감쌀 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 해결책은 int, long, double 유형에만 작동합니다. boolean, byte, char, short, float 유형은 어떻게 해야 할까요? Java 스트림을 기본 Collection 유형으로 매핑하는 솔루션이 모든 여덟 가지 Java 기본 유형을 지원할 수 있는 방법이 있습니까?\n\n네, 있습니다.\n\n# collect! 메서드 호출하기\n\nJava 개발자들은 10년 동안 Java Stream을 사용해 왔으며 대부분은 기본 Stream과 Collector를 함께 사용할 수 없음에 직면해 왔을 것입니다. Java에는 기본 Collection 유형이 없기 때문에 기본 Collection Collector가 필요하지 않았습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 우리가 Java Stream을 매핑하고 기본 Collection을 수집하려면, Eclipse Collections 또는 기타 기본 Collection 라이브러리에 의존해야 합니다. 이를 통해 여덟 가지 Java 기본 유형에 대한 기본 Collection에 액세스할 수 있습니다. 이 의존성을 추가하기 전에 무엇을 얻을 수 있는지 알아봅시다.\n\n## 옵션 1: Three Musketeer collect 호출\n\n![image](/assets/img/2024-06-19-HowtocollectaJavaStreamintoaprimitiveCollection_2.png)\n\nIntStream, LongStream, DoubleStream에 Three Musketeer 버전의 collect가 있습니다. 기본 collect 메서드의 Three Musketeers 이름은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 공급자\n- Obj(Int/Long/Double)Consumer\n- BiConsumer\n\n이 세 가지 함수형 인터페이스는 기본 스트림에 대한 collect 메서드를 대체하는 역할을 하는데, 이 collect 메서드는 기본형 Collector를 사용할 것이다. 세 명의 무사 collect 버전은 Eclipse Collections에서 기본형 컬렉션을 만드는 데 사용될 수 있는데, 다음 예시에서 확인할 수 있다.\n\n## IntStream을 IntList로 변환\n\n```js\n@Test\npublic void intStreamToIntList()\n{\n    IntStream intStream =\n            IntStream.of(1, 2, 3, 4, 5);\n\n    // 세 명의 무사 collect\n    IntList ints =\n            intStream.collect(\n                    IntLists.mutable::empty,   // 공급자\n                    MutableIntList::add,       // ObjIntConsumer\n                    MutableIntList::addAll);   // BiConsumer\n\n    IntList expected =\n            IntLists.mutable.of(1, 2, 3, 4, 5);\n    Assertions.assertEquals(expected, ints);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## LongStream을 LongSet으로 수집하기\n\n```java\n@Test\npublic void longStreamToLongSet()\n{\n    LongStream longStream = \n            LongStream.rangeClosed(1, 5);\n\n    // Three Musketeer collect\n    LongSet longs =\n            longStream.collect(\n                    LongSets.mutable::empty,   // 공급자\n                    MutableLongSet::add,       // ObjIntConsumer\n                    MutableLongSet::addAll);   // BiConsumer;\n\n    LongSet expected =\n            LongSets.mutable.of(1L, 2L, 3L, 4L, 5L);\n    Assertions.assertEquals(expected, longs);\n}\n```\n\n이 방법은 DoubleStream에서도 작동하며, Eclipse Collections에는 Three Musketeer collect를 사용할 수 있는 기본 List, Set, Bag이 있습니다.\n\n그렇다면 Java Stream에서 다른 다섯 가지 기본 유형을 어떻게 수집할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n## 옵션 2: 객체 스트림과 함께 기본 Collector 사용하기\n\n![이미지](/assets/img/2024-06-19-HowtocollectaJavaStreamintoaprimitiveCollection_3.png)\n\n맞아요. Java에는 기본 컬렉션 Collectors가 없습니다. 왜냐하면 Java에는 기본 컬렉션이 없기 때문입니다. 그러나 Eclipse Collections에는 기본 Collector 인스턴스가 있습니다. Java Stream과 기본 컬렉션 사이의 다리를 구축하는 데 도움이 되는 Collectors2란 유틸리티 클래스가 있습니다. Collectors2를 사용하여 어떻게 Object Stream을 모든 여덟 가지 기본 Java 유형(boolean, byte, char, short, int, float, long, double)에 대한 형식(Set, List, Bag)의 기본 컬렉션으로 변환할 수 있는지 살펴보겠습니다.\n\n어떤 객체 유형의 Stream부터 시작하여 해당 Stream을 모든 여덟 가지 기본 유형에 대한 여러 기본 컬렉션으로 어떻게 변환할 수 있는지 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n## Stream`String`을 BooleanBag으로 수집\n\n이 예제는 String 스트림을 BooleanBag으로 변환한 후 true와 false의 발생 횟수를 세는 방법을 보여줍니다.\n\n```js\n@Test\npublic void streamToBooleanBag()\n{\n    Stream<String> stream =\n            Stream.of(\"true\", \"false\", \"true\", \"false\", \"true\");\n\n    BooleanBag booleans = stream.collect(\n            Collectors2.collectBoolean(\n                    Boolean::parseBoolean,\n                   BooleanBags.mutable::empty));\n\n    Assertions.assertEquals(3, booleans.occurrencesOf(true));\n    Assertions.assertEquals(2, booleans.occurrencesOf(false));\n}\n```\n\n## Stream`String`을 ByteList로 수집\n\n<div class=\"content-ad\"></div>\n\n이 예제는 String Stream을 ByteList로 변환합니다.\n\n```js\n@Test\npublic void streamToByteList()\n{\n    Stream<String> stream = Stream.of(\"1\", \"2\", \"3\", \"4\", \"5\");\n\n    ByteList bytes = stream.collect(\n            Collectors2.collectByte(\n                    Byte::parseByte, \n                    ByteLists.mutable::empty));\n\n    ByteList expected = ByteLists.mutable.with(\n            (byte) 1,\n            (byte) 2,\n            (byte) 3,\n            (byte) 4,\n            (byte) 5);\n    Assertions.assertEquals(expected, bytes);\n}\n```\n\n## Stream`Character`을 CharSet로 변환\n\n이 예제는 Character 인스턴스의 Stream을 CharSet으로 변환합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n@Test\npublic void streamToCharSet()\n{\n    Stream<Character> stream =\n            Stream.of('a', 'b', 'c', 'd', 'e');\n\n    CharSet characters = stream.collect(\n            Collectors2.collectChar(\n                    Character::charValue,\n                    CharSets.mutable::empty));\n\n    CharSet expected =\n            CharSets.mutable.with('a', 'b', 'c', 'd', 'e');\n    Assertions.assertEquals(expected, characters);\n}\n```\n\n## Stream`Sh` collect to ShortBag\n\n이 예제를 위해 Sh라는 Java 레코드를 만들었습니다... Sh는 Short보다 짧았어요. Sh는 int에서 캐스팅된 short 값을 보유합니다. Short처럼 Java에는 short를 나타내는 짧은 short 리터럴이 없으므로 int 리터럴을 short로 캐스트해야 합니다. Sh 레코드를 사용하면 한 곳에서 캐스팅할 수 있었어요.\n\n```js\n@Test\npublic void streamToShortBag()\n{\n    record Sh(short value)\n    {\n        public Sh(int intValue)\n        {\n            this((short) intValue);\n        }\n    };\n    Stream<Sh> stream =\n            Stream.of(new Sh(1), new Sh(2), new Sh(3), new Sh(4), new Sh(5));\n\n    ShortBag shorts = stream.collect(\n            Collectors2.collectShort(\n                    Sh::value,\n                    ShortBags.mutable::empty));\n\n    ShortBag expected =\n            ShortBags.mutable.with(\n                    (short) 1,\n                    (short) 2,\n                    (short) 3,\n                    (short) 4,\n                    (short) 5);\n    Assertions.assertEquals(expected, shorts);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## Stream`BigInteger`을 IntList로 수집하기\n\nBigInteger에 대해 네 가지 싱글톤 값이 있다는 것은 이 예제 테스트를 작성할 때까지 알지 못했습니다. 이제 우리 모두 알게 되었네요.\n\n```js\n @Test\npublic void streamToIntList()\n{\n    Stream<BigInteger> stream =\n            Stream.of(\n                    BigInteger.ZERO,\n                    BigInteger.ONE,\n                    BigInteger.TWO,\n                    BigInteger.TEN);\n\n    IntList ints = stream.collect(\n            Collectors2.collectInt(\n                    BigInteger::intValueExact,\n                    IntLists.mutable::empty));\n\n    IntList expected =\n            IntLists.mutable.with(0, 1, 2, 10);\n    Assertions.assertEquals(expected, ints);\n}\n```\n\n## Stream`BigDecimal`을 FloatSet으로 수집하기\n\n<div class=\"content-ad\"></div>\n\n이 예시는 BigDecimal의 스트림을 FloatSet으로 변환합니다.\n\n```js\n@Test\npublic void streamToFloatSet()\n{\n    Stream<BigDecimal> stream =\n            Stream.of(\n                    BigDecimal.ZERO,\n                    BigDecimal.ONE,\n                    BigDecimal.TWO,\n                    BigDecimal.TEN);\n\n    FloatSet floats = stream.collect(\n            Collectors2.collectFloat(\n                    BigDecimal::floatValue,\n                    FloatSets.mutable::empty));\n\n    FloatSet expected =\n            FloatSets.mutable.with(0.0f, 1.0f, 2.0f, 10.0f);\n    Assertions.assertEquals(expected, floats);\n}\n```\n\n## Stream의 LocalDate를 LongBag으로 변환\n\n이 예시는 LocalDate의 스트림을 LongBag으로 변환하여 LocalDate 인스턴스를 epochDay로 변환한 것을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n```java\n/**\n * LongBag으로의 스트림 처리\n */\n@Test\npublic void streamToLongBag()\n{\n    LocalDate now = LocalDate.of(2024, Month.MAY, 31);\n    Stream<LocalDate> stream =\n            Stream.of(\n                    now,\n                    now.plusDays(1L),\n                    now.plusDays(2L),\n                    now.plusDays(3L));\n\n    LongBag longs = stream.collect(\n            Collectors2.collectLong(\n                    LocalDate::toEpochDay,\n                    LongBags.mutable::empty));\n\n    LongBag expected =\n            LongBags.mutable.with(19874L, 19875L, 19876L, 19877L);\n    Assertions.assertEquals(expected, longs);\n}\n\n## Stream`BigDecimal`을 DoubleList로 변환\n\n이 예제는 BigDecimal 스트림을 DoubleList로 변환합니다.\n\n/**\n * DoubleList로의 스트림 처리\n */\n@Test\npublic void streamToDoubleList()\n{\n    Stream<BigDecimal> stream =\n            Stream.of(\n                    BigDecimal.ZERO,\n                    BigDecimal.ONE,\n                    BigDecimal.TWO,\n                    BigDecimal.TEN);\n\n    DoubleList doubles = stream.collect(\n            Collectors2.collectDouble(\n                    BigDecimal::doubleValue,\n                    DoubleLists.mutable::empty));\n\n    DoubleList expected =\n            DoubleLists.mutable.with(0.0d, 1.0d, 2.0d, 10.0d);\n    Assertions.assertEquals(expected, doubles);\n}\n\n<div class=\"content-ad\"></div>\n\n# 효율성은 여전히 우리의 문제입니다\n\n저는 자바를 좋아하고, Project Valhalla가 미래 버전에서 완전히 구현되기를 기다리지 않을 수 없어요. 간결한 람다 표현식을 위해 10년을 기다렸고, 이제 Project Valhalla를 위해 10년을 기다리고 있어요. 지난 20년간 금융 서비스 분야에서 일한 경험상 자바 언어와 표준 라이브러리가 발전하여 나를 마주한 문제들을 해결하기 위해 기다릴 시간이 없었어요. 저와 동료들이 한 작업은 대부분 메모리 문제나 성능 압력에 의해 이뤄졌어요. 우리가 한 일을 모두가 HashSet`Integer`의 모든 인스턴스를 제거하여 행성을 구원하는 위대한 자선 사업의 일환으로 주장하지는 않을 거예요. 하지만 가끔은 세상의 모든 HashSet`Integer` 인스턴스를 제거하는 것을 꿈꾸곤 해요. :)\n\n좋은 소식은 Valhalla를 기다릴 필요가 없다는 것이에요. 오늘날 자바에서 원시 타입 컬렉션을 필요로 하거나 전체적인 컴퓨팅 풋 프린트를 줄이기 위해 효율적인 코딩 스타일을 채택하고자 할 때 기다릴 필요가 없어요. 우리가 원할 때 더 효율적인 자바 코드를 작성하도록 도와주는 솔루션이 있어요. 이러한 솔루션 중 일부는 20년 동안 개발되어 왔어요. 새로운 유형이나 메서드를 배우고 제3자 라이브러리에 의존성을 추가하는 것에는 비용이 들어요. 혜택이 없다면 이의 의존성 비용을 지는 것에 의미가 없어요. 그러나 우리가 새로운 HashSet`Integer`를 입력할 때마다 생각해야 해요. 우리 애플리케이션에서 이 코드를 입력하거나 보면 꼭 북극곰에 대해 생각하고 싶어요.\n\nValhalla가 도착했을 때, 우리 모두가 그것을 배우고 적용해 애플리케이션에서 새로운 효율성을 활용하여 모두가 함께 풋프린트를 줄이고 애플리케이션 성능을 향상시킬 수 있었으면 좋겠어요. 효율성은 우리의 문제입니다. 오늘날 사용 가능한 솔루션을 채택하든, Project Valhalla를 기다리든, 효율적인 컬렉션 코드를 작성하는 문제는 우리의 문제입니다. 혹시 Valhalla가 어떠한 효율성을 도입하여 우리가 어떠한 노력도 하지 않아도 메모리 및 성능 절약을 마법같이 제공할 수 있다면 그건 물론 환영받을 일이겠지요!\n\n<div class=\"content-ad\"></div>\n\n읽어 주셔서 감사합니다! 새롭고 유용한 정보를 배우셨길 바랍니다!\n\n저는 Eclipse Collections OSS 프로젝트의 창조자이자 기여자입니다. Eclipse Collections는 Eclipse Foundation에서 관리되고 있습니다. Eclipse Collections는 기여를 환영합니다.","ogImage":{"url":"/assets/img/2024-06-19-HowtocollectaJavaStreamintoaprimitiveCollection_0.png"},"coverImage":"/assets/img/2024-06-19-HowtocollectaJavaStreamintoaprimitiveCollection_0.png","tag":["Tech"],"readingTime":12},{"title":"Spring Boot Spring Boot가 동시에 처리할 수 있는 요청의 양은 얼마나 될까요","description":"","date":"2024-06-19 09:57","slug":"2024-06-19-SpringBootHowManyRequestsCanSpringBootHandleSimultaneously","content":"\n\n![이미지](/assets/img/2024-06-19-SpringBootHowManyRequestsCanSpringBootHandleSimultaneously_0.png)\n\nSpring Boot은 Java 개발에서 중요한 프레임워크로, 개발자에게 효율적이고 사용자 친화적인 도구를 제공합니다. 따라서 관련 인터뷰 질문들도 중요합니다.\n\n오늘은 전통적인 인터뷰 질문을 살펴보겠습니다: Spring Boot가 동시에 처리할 수 있는 요청은 얼마인가요?\n\n정확히 말하면, Spring Boot가 동시에 처리할 수 있는 요청의 수는 Spring Boot 프레임워크 자체에 의해 결정되는 것이 아닙니다. 그 대신 중첩된 웹 컨테이너에 달려 있습니다 (웹 컨테이너의 동작이 Spring Boot의 동작을 결정하기 때문에 이 두 질문의 답을 같은 것으로 간주할 수 있습니다).\n\n<div class=\"content-ad\"></div>\n\n# 1. 세 가지 주요 웹 컨테이너\n\n현재 시장에는 세 가지 주요 웹 컨테이너가 있습니다: Tomcat, Undertow 및 Jetty.\n\n이 중에서 Tomcat은 Spring Boot 프레임워크의 기본 웹 컨테이너입니다.\n\n그들의 차이점은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n## 1.1 Tomcat\n\n톰캣은 아파치 소프트웨어 재단의 오픈소스 프로젝트이며 가장 널리 사용되는 서블릿 컨테이너 중 하나입니다. Java 서블릿 및 JavaServer Pages (JSP) 사양을 완전히 구현합니다.\n\n톰캣은 서블릿 컨테이너뿐만 아니라 경량 응용 프로그램 서버이기도 하지만 다른 경량 서버에 비해 약간 더 무겁다고 여겨집니다.\n\n톰캣은 SSL, 연결 풀링 등 다양한 기업 수준의 기능을 지원하여 대규모 복잡한 기업 응용 프로그램을 실행하기에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n그 안정성과 성숙성은 기업 수준의 응용 프로그램을 통해 증명되었습니다. 이를 통해 많은 기업들이 선호하는 웹 컨테이너가 되었습니다.\n\n## 1.2 Undertow\n\nUndertow은 레드햇에서 개발된 유연하고 고성능의 웹 서버 및 리버스 프록시 서버입니다.\n\nWildFly 응용 프로그램 서버의 기본 웹 컨테이너입니다. Undertow는 낮은 메모리 사용량과 높은 동시성을 위해 설계되었으며, RESTful API 서비스와 같은 대량의 짧은 연결을 처리하는 데 뛰어납니다.\n\n<div class=\"content-ad\"></div>\n\n언더토우는 Servlet 3.1, WebSocket 및 non-blocking IO (NIO)를 지원하며 HTTP/2 프로토콜을 지원하는 현대적인 서버 중 하나입니다.\n\n그 설계 철학은 모듈화되고 임베디드할 수 있는 솔루션을 제공하여 기존 시스템에 쉽게 통합할 수 있고 마이크로서비스 아키텍처에 적합합니다.\n\n## 1.3 젯티\n\n젯티는 Eclipse Foundation이 유지보수하는 오픈 소스 경량 웹 서버 및 Servlet 컨테이너입니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 표의 Markdown 형식입니다.\n\n지티는 임베딩 기능과 높은 설정 가능성으로 유명하며, 개발 단계, 테스트 환경 또는 가벼운 애플리케이션과 같이 빠른 시작과 경량 배포가 필요한 시나리오에서 자주 사용됩니다.\n\n지티는 서블릿 사양, 웹소켓을 지원하며 NIO를 기반으로 하여 큰 동시 접속을 처리하는 데 우수한 성능을 발휘합니다.\n\n지티는 설계에서 유연성과 확장성을 강조하며, 특정 요구 사항을 충족하기 위해 API를 통해 쉽게 사용자 정의할 수 있어 클라우드 환경, 지속적 통합 및 데브옵스에서 인기를 얻고 있습니다.\n\n![이미지](/assets/img/2024-06-19-SpringBootHowManyRequestsCanSpringBootHandleSimultaneously_1.png)\n\n<div class=\"content-ad\"></div>\n\n# 2. 최대 연결 수 및 최대 대기 수\n\nSpring Boot 프레임워크의 기본 웹 컨테이너 인 Tomcat을 예로 들어, 동시에 처리할 수 있는 요청 수는 spring-configuration-metadata.json 파일에 구성되어 있습니다. 이 파일에서 'server.tomcat.max-connections' (Tomcat의 최대 연결 수)를 검색하면 아래와 같은 결과가 나옵니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-SpringBootHowManyRequestsCanSpringBootHandleSimultaneously_3.png)\n\n이것은 기본적으로 Tomcat이 최대 8192개의 연결을 허용한다는 것을 의미합니다 (8192 = 8 * 1024).\n\n여기서 한 가지 생각할 수 있습니다. '기본적으로 Spring Boot는 8192개의 요청을 동시에 처리할 수 있다.' 라고 생각할 수 있지만, 이는 잘못된 생각입니다. 왜 일까요?\n\nTomcat은 최대 8192개의 연결을 허용할 수 있지만, Tomcat은 또한 최대 대기 숫자를 가지고 있습니다. 이것은 8192에 도달하면 요청의 연결을 저장할 수 있는 대기 큐가 있는 것을 의미합니다.\n\n\n<div class=\"content-ad\"></div>\n\n그래요, Spring Boot가 동시에 처리할 수 있는 연결 수는 Tomcat의 최대 연결 수와 Tomcat의 최대 대기 수와 같습니다.\n\n그렇다면 최대 대기 수는 얼마인가요?\n\n그럼, 'server.tomcat.accept-count' (Tomcat의 최대 대기 수)를 spring-configuration-metadata.json 파일에서 계속 찾아보겠습니다. 검색 결과는 아래에 표시됩니다:\n\n![이미지](/assets/img/2024-06-19-SpringBootHowManyRequestsCanSpringBootHandleSimultaneously_4.png)\n\n<div class=\"content-ad\"></div>\n\n그 말은 기본적으로 Tomcat의 최대 대기 수가 100임을 의미합니다.\n\n## 3. 동시 요청 처리\n\n따라서 우리는 다음을 결론 지었습니다: 기본적으로 Spring Boot가 동시에 처리할 수 있는 요청 수 = 최대 연결 수(8192) + 최대 대기 수(100), 즉 8292입니다.\n\n물론, 이 두 값은 아래 구성에서 보여지는 Spring Boot 구성 파일에서 수정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```yaml\nserver:\n  tomcat:\n    max-connections: 2000 # 최대 연결 수\n    accept-count: 200 # 최대 대기 번호\n```\n\n# 4. 추가 지식: 웹 컨테이너 설정하기\n\nSpring Boot 프레임워크에서 웹 컨테이너를 Jetty 또는 Undertow로 설정하는 방법은 무엇인가요? 함께 살펴보겠습니다.\n\n# 4.1 컨테이너를 Jetty로 설정하기\n\n<div class=\"content-ad\"></div>\n\nSpring Boot 프레임워크의 웹 컨테이너를 Jetty로 설정하려면, 다음과 같이 pom.xml 파일을 수정하면 됩니다:\n\n```js\n<dependencies>\n    <!-- Spring Boot Starter Web를 사용하지만 Tomcat은 제외합니다 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <!-- Tomcat 제외 설정 -->\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <!-- Jetty starter 종속성 추가 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jetty</artifactId>\n    </dependency>\n</dependencies>\n```\n\n다시 말해, 기본 Tomcat을 제외하고 Jetty 종속성을 추가하면 됩니다.\n\n# 4.2 Undertow 컨테이너로 설정하기\n\n<div class=\"content-ad\"></div>\n\nSpring Boot 프레임워크의 웹 컨테이너를 Undertow로 설정하려면 Jetty 구현 방법과 비슷합니다. 아래에 표시된대로 pom.xml 파일을 수정하면 됩니다:\n\n```js\n<dependencies>\n    <!-- Spring Boot Starter Web을 사용하되 Tomcat은 제외 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <exclusions>\n            <exclusion>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </exclusion>\n        </exclusions>\n    </dependency>\n    <!-- Undertow 스타터 의존성 추가 -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-undertow</artifactId>\n    </dependency>\n</dependencies>\n```","ogImage":{"url":"/assets/img/2024-06-19-SpringBootHowManyRequestsCanSpringBootHandleSimultaneously_0.png"},"coverImage":"/assets/img/2024-06-19-SpringBootHowManyRequestsCanSpringBootHandleSimultaneously_0.png","tag":["Tech"],"readingTime":6},{"title":"iOS 174는 예상 이상으로 매우 큽니다 - 놀라운 25가지 기능을 소개합니다","description":"","date":"2024-05-27 18:04","slug":"2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures","content":"\n애플이 이렇게 슬퍼한 적이 없었어요.\n\n조석잃는 악몽 속에서도 어느 측면에서의 독점이 이토록 가혹하게 도전받을 줄은 애플도 상상조차 못했을 거예요.\n\niOS 17.4를 소개합니다. 개발자와 경쟁 업체들에게는 좋은 날이고, 애플에게는 안 좋은 날이랍니다.\n\niOS에 대한 상당히 중요한 (그리고 매우 필요한) 업데이트이지만, 일부 변경 사항은 애플이 즐거워하기 위해 한 게 아니라는 것을 알아두세요. 오히려 EU의 강제법률과 조치들을 준수하기 위한 것으로, 이는 바로 애플의 EU 기술에 대한 통제에 직접적인 타격을 입고 있어요.\n\n<div class=\"content-ad\"></div>\n\n그러나 Apple은 이점을 위해 뭔가를 했습니다. 현재, EU가 요구하는 기능은 EU 기반 아이폰에만 적용되며, 이는 전체 수익의 7%를 차지합니다. 대단한 아이디어네요.\n\n그래서 Apple은 세계의 다른 나라에서도 독점 노래를 부를 수 있습니다. 그리고 사람들은 그 맥락에서 멜로디를 즐겨 들을 지 여부와는 상관없이 그것을 듣는 다른 선택지가 없습니다.\n\n# 본문 내용\n\n유럽 특화 변화\n1 — 사이드로딩 활성화됨!\n2 — 기본 브라우저 변경을 위한 메시지 표시\n3 — 타사 브라우저 엔진 지원\n일반적인 변화\n새로운 메시지 변화\n4 — 16가지 새로운 이모티콘\n5 — 비즈니스용 메시지\n6 — Siri가 다양한 언어로 메시지를 읽을 수 있도록\n새로운 설정 변화\n7 — 도난 단말 보호에 대한 중요한 변경\n8 — 타사 앱을 위한 '접촉 및 NFC' 접근 권한\n9 — 새로운 지역 식별자\n새로운 사파리 변화\n10 — 넓은 탭 바\n11 — 웹 페이지에서 '모든 애니메이션 재생'\n새로운 팟캐스트 변화\n12 — 실시간 대본과 함께 팟캐스트 팔로우\n13 — 정보 보기를 위해 에피소드 이름 탭하기\n새로운 시계 변화\n14 — 새로운 시계 위젯\n15 — 스톱워치에 실시간 활동 기능 추가\n새로운 지갑 변화\n16 — Apple Card를 위한 가상 카드 번호 획득\n17 — 지갑 연결 향상\n새로운 CarPlay 변화 공개\n18 — 차를 끌 때 CarPlay가 작별인사\n19 — 새로운 CarPlay 앱 및 아이콘\n새로운 백엔드 변화\n20 — 게임 스트리밍이 이제 가능해짐\n21 — 케이블용 펌웨어 업데이트!?\n일관성을 위한 변화\n22 — 개선된 iCloud 아이콘\n23 — 책, 음악 및 팟캐스트를 위한 홈 섹션\n24 — Podcasts의 '현재 재생 중' 바가 Apple Music을 모방함\n새로운 기타 변화\n25 — HomePod 및 Apple TV로 SharePlay Music 공유\n26 — 앱 스토어에서 구매 기록\n27 — 독일어에서 Siri 호출 시 ‘Hey’ 삭제\n\n<div class=\"content-ad\"></div>\n\n# — EU-SPECIFIC CHANGES —\n\n# #1. Sideloading is active!\n\niOS에서 사이드 로딩이 시작되었습니다!\n— 이게 기술 역사상 가장 대단한 소식 중 하나 아닐까요?\n\n이 기능은 기존 앱 스토어 외 다른 원본에서 앱을 설치할 수 있는 기능입니다(대체 앱 마켓이라고도 함) — 예를 들어 Play Store, Amazon Appstore, 그리고 Setapp과 같은 곳에서 (iOS로 이동할지 여부는 확실하지 않지만, 감을 잡기 위해서 들어주었습니다).\n\n<div class=\"content-ad\"></div>\n\n(App Marketplace ≈ 다른 iOS 앱을 설치할 수 있는 iOS 앱)\n\n![iOS 174 매우 예상보다 더 크고 놀랍다는 25가지 멋진 기능 이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_0.png)\n\n이것은 애플의 본래 App Store 이외에 iPhone에서 여러 앱 스토어를 동시에 사용할 수 있는 것을 의미합니다.\n\n가장 좋은 점은 다른 앱 스토어를 기본 앱 스토어로 설정할 수 있다는 것입니다 — 기본 브라우저를 변경하는 것만큼 쉽게요.\n\n<div class=\"content-ad\"></div>\n\n그러나 애플은 개인 정보보호와 보안 서약에 따라 대체 앱 스토어에서 설치된 앱에 대한 악성 코드를 경고하고, 이에 해당하는 경우 해당 앱을 열지 못하도록 막을 것입니다.\n\n또한 부모님들이 자녀들이 대체 앱 스토어에서 앱을 설치할 수 있는지를 결정할 수 있는 새로운 'Screen Time' 설정이 있습니다.\n\n##2. 기본 브라우저 변경 프롬프트\n\n이것을 주목한 적이 있나요?\n기본 브라우저가 Safari인 경우, 설정 ⚙️ ` 같이 Safari가 아닌 브라우저를 활성화한 경우, 기본 브라우저를 변경할 수 있는 섹션이 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 이것은 브라우저인 사파리의 설정에서는 표시되지 않습니다. 이것도 브라우저인데 이상하네요...\n\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_1.png\" />\n\n\n하지만 기본 브라우저를 크롬, 파이어폭스 또는 사파리가 아닌 다른 브라우저로 변경하면 사파리 설정에서도 이 부분이 마법처럼 나타납니다.\n\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_2.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n애플이 여러분이 Safari를 기본 브라우저로 유지하기를 원하는 정도입니다.\n\n하지만 안타깝게도 (애플에게는) EU의 지시에 따라, 이제 iOS 17.4로 업데이트된 후 Safari를 처음 열 때 사용자에게 기본 브라우저를 선택할 수 있는 옵션을 제공하는 프롬프트를 표시해야 합니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_3.png)\n\n표시되는 브라우저는 국가마다 다르며 각 사용자마다 무작위로 지정됩니다.\n\n<div class=\"content-ad\"></div>\n\n아이폰에 설치되어 있지 않아도 브라우저가 나타납니다. 브라우저를 기본 브라우저로 설정하려면 다운로드해야 합니다.\n\n# #3. 제 3자 브라우저 엔진 지원\n\n애플은 또한 제 3자 브라우저가 자체 브라우저 엔진을 사용할 수 있도록 허용합니다.\n\n```js\n브라우저 엔진이란?\n\n기본 HTML 문서를 아름다운 페이지로 변환하는 모든 브라우저의 핵심 구성 요소입니다.\n모든 브라우저는 속도와 추가 기능을 위해 자체 엔진을 개선할 수 있습니다.\n```\n\n<div class=\"content-ad\"></div>\n\nApple는 처음부터 iOS에서 여러 브라우저를 허용해 왔지만 엔진은 한 가지뿐이었습니다 - Webkit (Apple 고유). 다른 곳에서 Blink와 Gecko를 사용하는 Chrome과 Firefox조차도 iOS에서는 WebKit에 맞춰야 했습니다.\n\n이로 인해 타사 브라우저들이 많은 기능과 개선 사항을 가져오는 자유가 제한되었습니다.\n\n하지만 이제는 Apple이 iOS에서 WebKit 이외의 브라우저 엔진에 대해 관대해지고 있어서 EU 사용자들은 자신이 선호하는 브라우저에 더 많은 기능을 기대할 수 있습니다.\n\nApple은 iOS에서 엔진을 실행하기 전에 철저한 검사를 실시할 것이지만, 가장 인기 있는 엔진들이 대부분 허용될 것이라 확신합니다.\n\n<div class=\"content-ad\"></div>\n\n# — 일반적인 변경사항 —\n\n# • 새로운 메시지 변경사항\n\n## #4. 16개의 새 이모지\n\n새롭게 도입된 이모지 15.1 표준을 준수하는 애플의 16개의 새로운 이모지입니다. 이러한 것이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_4.png)\n\n- 처음 두 줄에 있는 이모티콘들은 완전히 새로운 개념입니다.\n- 세 번째 줄에 있는 이모티콘들은 이전에 사용자가 왼쪽을 향하고 있던 이모티콘들의 새롭게 디자인된 버전입니다.\n- 네 번째 줄에 있는 이모티콘들은 👨‍👩‍👧‍👦와 같은 가족 이모티콘의 대체품입니다.\n\n모든 새로운 이모티콘들과 그 설명을 기사 끝에 복사해 두었습니다.\n\n## #5. 비즈니스 메시지\n\n<div class=\"content-ad\"></div>\n\n설정 ⚙️ ` 메시지 💬`에서 '비즈니스 및 개인 정보에 대한 메시지'라는 하이퍼링크가 있었어요.\n\n이제는 '비즈니스용 메시지'로 대체되었는데, 아직은 비어 있지만 나중에는 메시지를 보낸 비즈니스 및 해당 옵션을 담을 수 있을 것입니다.\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_5.png\" />\n\n## #6. Siri can read out messages in different languages\n\n<div class=\"content-ad\"></div>\n\n요즘 Siri가 메시지를 보내기 전에 확인을 요청하는 단계를 건너뛸 수 있다는 걸 알고 계셨나요?\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_6.png)\n\n설정 ⚙️ ` Siri 및 검색`에서 ‘메시지 자동 전송’을 켜면 됩니다. 그러면 더 이상 매번 확인 부분을 보지 않아도 됩니다. 멋지죠!\n\n하지만 iOS 17.4에서는 해당 부분이 ‘Siri로 메시지 보내기’로 대체되었는데, 메시지 자동으로 전송하는 것 외에도 Siri가 메시지를 읽을 때 사용할 몇 가지 언어를 선택할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 테이블 태그를 변경했습니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_7.png)\n\n만약 국제적인 친구들이 여러 언어로 메시지를 주고받는다면 이것이 최선의 방법입니다. 여기에 설정하는 언어는 Siri의 주요 언어에 영향을 미치지 않습니다.\n\n# • 새로운 설정 변경\n\n## #7. 도난 방지 기능의 중요한 변경\n\n<div class=\"content-ad\"></div>\n\niOS 17.3의 \"The Stolen Device Protection\" 기능은 사용자의 개인 정보 보호와 보안을 위한 iOS의 훌륭한 새로운 추가입니다.\n\n이는 생체 인증 확인과 중요한 시스템 설정을 변경하려고 할 때 1시간의 지연을 설정합니다. 자세한 정보는 이 기사에서 확인하세요 →\n\n그러나 가정 또는 직장과 같이 익숙한 장소에 있는 경우에는 지연이 강제로 적용되지 않습니다. 익숙한 장소가 아니라면 이 둘 다 해야 합니다.\n\n하지만 iOS 17.4에서 Apple은 iPhone이 위치와 관계없이 1시간의 지연을 강제로 적용할 수 있는 유용한 기능을 가져왔습니다. (설정에서 조정하세요 ⚙️ `Face ID & Passcode 🙂` Stolen Device Protection)\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_8.png)\n\n- Selecting 'Always' always implements a 1-hour delay.\n- Selecting 'Away from Familiar Locations' verifies the location before implementing the delay. If it is a familiar location, you can quickly access your critical settings after a Face ID check.\n\n## #8. Access to 'Contactless & NFC' for 3rd party apps\n\nThere is a new section called 'Contactless & NFC' in Settings ⚙️ Privacy & Security ✋.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_9.png)\n\nInside, it's empty for now — but it says:\n\nSo Apple’s allowing 3rd party apps to use iPhone's built-in NFC payments feature (for tap-to-pay or cardless POS machine payments).\n\nAnd in the EU, Apple allows users to select a 3rd-party contactless payment app as default — instead of Wallet. Cool, right?\n\n\n<div class=\"content-ad\"></div>\n\n## #9. 새로운 지역 식별자\n\n새로운 것이 나타났어요! 설정 ⚙️ `일반` ⚙️ 에서 닉네임으로 IDENTIFIABLE_REGION이라고 불리는 것이 있어요. 이 기능은 애플이 식별한 국가로 당신의 지역(나라)을 보여줍니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_10.png)\n\n지금은 이에 대한 정보가 없지만, 애플이 EU에 있는지 여부를 식별하여 EU 특정 기능에 액세스할 수 있도록 하는 방법일 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n자신이 EU에 있다고 청구 주소를 변경하거나 Apple ID 지역을 변경하거나 VPN을 사용하여 속이는 것은 불가능합니다. Apple은 이를 확인하기 위해 알 수 없는 강력한 방법을 사용하고 있습니다.\n\n## 새로운 Safari 변화\n\n### 10. 탭 바가 넓어졌어요\n\nSafari에서 탭 바를 사용하는 경우 (상단이 아닌 하단에 탭이 표시되는 경우), 이제 다소 넓어졌다는 차이를 발견할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_11.png)\n\nI didn’t like it, but maybe it takes some time to get used to it.\n\n## #11. ‘Play All Animations’ in a webpage\n\n![Image 2](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_12.png)\n\n\n<div class=\"content-ad\"></div>\n\n새로운 ‘모든 애니메이션 재생’ 옵션을 Safari에서 사용하면 한 번에 웹페이지의 모든 GIF 애니메이션을 재생할 수 있어요.\n\n# • 새로운 팟캐스트 변화\n\n## #12. 라이브 트랜스크립트와 함께 팟캐스트 따르기\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_13.png)\n\n<div class=\"content-ad\"></div>\n\n팟캐스트를 좋아하는 사용자들이 영원히 사랑할 멋진 기능이에요.\n\n팟캐스트의 Apple Music 가사 버전과 같은 기능입니다. 이제 팟캐스트를 자막과 함께 따라 들을 수 있어요. 이를 보려면 왼쪽 하단의 자막 아이콘을 클릭하면 됩니다.\n\n그리고 더 좋은 점은, 자막에서 단어나 구절을 검색할 수 있다는 거예요. 가장 좋아하는 부분으로 건너뛰고 싶을 때 매우 유용하죠.\n\n## 13번. 에피소드 이름을 눌러 정보보기\n\n<div class=\"content-ad\"></div>\n\n이 기능이 정말 멋져요. — 이제 에피소드 이름을 탭하여 해당 정보 페이지로 이동할 수 있어요.\n\nApple이 아래에 표시된 것처럼 프롬프트를 통해 제안할 거에요.\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_14.png)\n\n# • 새로운 시계 변경\n\n<div class=\"content-ad\"></div>\n\n## #14. 새 시계 위젯\n\n저희가 새로운 시계 위젯을 받았어요 — 'City Digital'이라고 이름 지었습니다:\n\n![City Digital](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_15.png)\n\n이 위젯은 다른 모든 City 위젯들이 보여주는 정보를 보여줍니다 — 그러나 정사각형 모양이고 디지털 시간을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n## #15. 스톱워치에 라이브 활동 추가\n\n알람 및 타이머는 이미 오랜 시간 동안 라이브 활동이 있어서 클록 앱을 여는 것 없이 제어하기 쉽게 되었습니다.\n\n이제 iOS 17.4에서 스톱워치도 그런 기능이 추가되었습니다. 다음은 어떻게 보이는지에 대한 설명입니다:\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_16.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 새로운 지갑 변경 사항\n\n## #16. Apple Card를 위한 가상 카드 번호 가져오기\n\nApple Cash Card는 Apple Wallet에 좋은 추가입니다.\n\n아마도 당신이 친구나 가족으로부터 돈을 송금하고 받는 가장 간단한 방법일 것입니다. 또한 Apple Pay를 허용하는 상점에서 다른 선불 카드와 같이 사용할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 Apple Pay를 받아들이지 않고 대신 카드 세부정보를 요청하는 상점/웹사이트는 어떻게 해야 하나요?\n\n걱정하지 마세요. iOS 17.4에서는 기존 가상 Apple Cash 카드를 위한 카드 번호, 만료일 및 보안 코드 세트를 생성할 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_17.png)\n\n가장 좋은 점은,\n\n<div class=\"content-ad\"></div>\n\n- 카드 정보가 유출됐다고 의심된다면 언제든지 새로운 정보 세트를 생성할 수 있어요 — 이전 정보는 더 이상 사용할 수 없게 됩니다.\n- 업데이트된 카드 정보는 자동으로 Safari 자동완성에 저장돼요.\n- 보안 코드는 정기적으로 변경돼 안전을 보장해요.\n\n## #17. 지갑 연결 향상\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_18.png)\n\n이것은 설정 ⚙️ `개인정보 및 보안 ✋` 분석 및 개선의 새로운 분석 옵션입니다.\n\n<div class=\"content-ad\"></div>\n\n만약 켜 놓으면, 계정 정보를 익명으로 Apple과 공유하여 연결된 계정 경험을 향상시킵니다.\n\n하지만 항상 제안하듯이, 분석을 끄면 배터리를 절약할 수 있어요.\n\n# • 새로운 CarPlay 변화 공개됐어요\n\nApple이 WWDC22에서 차세대 CarPlay를 미리 살펴보여주었고, 우리에게 2023년 말에 도착할 것을 기대하라고 말해주었어요. 그러나 우리가 기다리던 2023년이 이미 지났군요!\n\n<div class=\"content-ad\"></div>\n\n애플이 CarPlay 웹페이지를 업데이트하여 \"첫 번째 모델은 2024년 도착 예정\"이라고 말했습니다. 그리고 𝕏의 Aaron(@aaronp613)은 iOS 17.4 코드에서 새로운 아이콘과 애니메이션 중 일부를 찾아내었습니다.\n\n## #18. 차를 껐을 때 CarPlay이 작별 인사를 합니다\n\n차를 끌 때, iPhone이나 Mac이 부팅될 때 처럼 작별 인사 애니메이션을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_19.png)\n\n<div class=\"content-ad\"></div>\n\n## #19. 새로운 CarPlay 앱 및 아이콘들\n\nAaron은 CarPlay 2.0에서 새로운 아이콘들을 발견했습니다. 𝕏에서 그의 전체 쓰레드를 확인해보세요:\n\n또한, MacRumors가 강조한 바에 따르면, 차세대 CarPlay에 추가될 여덟 가지 새로운 앱들이 있습니다:\n\n- Auto Settings: 페어링된 아이폰을 관리하고 차량 설정을 변경할 수 있습니다.\n- Car Camera: 차량의 후방 카메라 영상을 표시합니다.\n- Charge (전기차용): 배터리 잔량, 충전 상태, 완전히 충전될 때까지 남은 시간 등을 표시합니다.\n- Climate: 차량의 기후 제어를 조절할 수 있습니다 — AC 온도, 팬 속도, 시트 및 핸들 가열 등.\n- Closures: 문이 실수로 열려있는 경우 알림하고 차량의 경고 심볼을 표시합니다.\n- Media: FM 및 AM 라디오를 재생할 수 있으며, SiriusXM도 지원합니다. 그러나 SiriusXM이 위성을 통해 되는지 인터넷 제한이 되는지에 대해서는 확실하지 않습니다.\n- Tyre Pressure: 각 타이어의 공기압을 표시하고 고 또는 낮은 압력 및 펑크된 타이어 알림을 제공합니다.\n- Trips: 여행에 대한 평균 속도, 연료 또는 에너지 효율성, 소요 시간 및 이동 거리 등의 정보를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n많은 인기 차 제조업체가 이미 자사의 자동차에 CarPlay 2.0을 도입하기로 약속한 상태입니다.\n\n- 새로운 백엔드 변경\n\n<div class=\"content-ad\"></div>\n\n## #20. 게임 스트리밍이 이제 가능합니다\n\n애플은 최근 개발자 기사에서 게임 스트리밍에 대해 이야기합니다. 다음과 같이 씁니다:\n\n```js\n게임 스트리밍이란 무엇인가요?\n게임을 원격 클라우드 서버에서 실행하고 게임의 비디오와 사운드를 사용자의 기기로 직접 전송하는 온라인 게임의 한 유형입니다.\n이를 통해 사용자는 강력한 네트워크 연결만 있다면 저전력 기기에서도 고사양 게임을 쉽게 플레이할 수 있습니다.\n```\n\n지금까지 iOS에서 게임 스트리밍은 브라우저를 통해 웹앱을 통해서만 이용할 수 있었는데, 이는 게임을 경험하기에 편안하거나 몰입할 수 있는 방법이 아니었습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만이 변경으로 Xbox Cloud Gaming과 Nvidia GeForce NOW와 같은 서비스가 독립 앱으로 앱 스토어에 진입할 수 있게됩니다. 게이머들에게는 좋은 소식이에요.\n\n## #21. 케이블의 펌웨어 업데이트!?\n\nAaron이 보도한 바에 따르면, iOS 17.4의 코드에는 다음과 같은 케이블의 펌웨어 업데이트 지원이 추가되었다고 합니다:\n\n- USB-C 커넥터가 장착된 이어팟\n- USB-C에서 3.5mm 헤드폰 잭 어댑터\n\n<div class=\"content-ad\"></div>\n\n이건 놀랍군요! 제 예상을 뛰어넘는 애플의 행보네요. 이번 펌웨어 업데이트로 플로피 와이어까지 지원한다니요.\n\n각 업데이트마다 케이블의 음질과 데이터 전송의 향상을 기대해봐도 좋을 것 같아요.\n\n# • 일관성을 위한 변경사항\n\n## #22. 프로필링 아이콘 재구성\n\n<div class=\"content-ad\"></div>\n\nFiles 앱의 iCloud 아이콘이 업데이트되었어요.\n\n![Files App](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_20.png)\n\n이제 그 아이콘은 투명해져, 맥 아이콘과 닮았어요. 이건 좋은 일이에요 — 이렇게 하면 모든 Apple OS에서 일관성을 유지할 수 있어요.\n\n## #23. 책, 음악, & 팟캐스트를 위한 홈 섹션\n\n<div class=\"content-ad\"></div>\n\n애플이 모든 주요 섹션인 Books, Music 및 Podcasts 앱의 이름을 '홈'으로 변경하였습니다. 이는 간결함과 일관성을 가져다 줍니다.\n\n예를 들어:\n\n- Books: Read Now → Home\n- Music & Podcasts: Listen Now → Home\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_21.png)\n\n<div class=\"content-ad\"></div>\n\n## #24. 팟캐스트의 '재생 중' 바가 Apple Music을 모방합니다.\n\n또한, 팟캐스트 앱의 '재생 중' 바(하단에 위치)가 이제 Apple Music의 것과 비슷해졌습니다. 한 번 확인해보세요:\n\n이전에는:\n\n![이전 이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_22.png)\n\n<div class=\"content-ad\"></div>\n\n이제는:\n\n<img src=\"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_23.png\" />\n\n# • 새로운 기타 변경 사항\n\n## #25. HomePod 및 Apple TV와 함께 SharePlay Music\n\n<div class=\"content-ad\"></div>\n\n당신은 이미 아시다시피 —\niOS 17부터는 친구나 가족과 함께 차 안에서 SharePlay 음악을 공유할 수 있습니다. 허가를 받은 사람은 Apple Music 구독이 활성화되어 있지 않아도 재생을 제어할 수 있습니다.\n\n이제 HomePod와 Apple TV에도 도착했습니다. 참가자를 추가하려면,\n\n- HomePod를 사용 중이라면, iPhone에서 아래에 있는 SharePlay 아이콘을 탭하여 참가자로 참여할 수 있는 QR 코드를 받으실 수 있습니다.\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_24.png)\n\n<div class=\"content-ad\"></div>\n\n- Apple TV를 tvOS 17.4 업데이트와 함께 사용 중이라면, QR 코드를 Apple TV 화면에 바로 표시할 수 있어요.\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_25.png)\n\n## #26. 앱 스토어의 구매 내역\n\n앱 스토어에서 이제 ‘구매 내역’이라는 새로운 섹션에서 모든 구매 내역을 전체로 확인할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n위의 이미지를 확인하려면 앱 스토어를 열고 프로필을 클릭한 후, ‘구매 기록’을 클릭하세요.\n\n![image](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_26.png)\n\n구매한 앱 및 게임(유료), 구독, 그리고 인앱 구매가 모두 포함돼 있습니다.\n\n또한 ‘구매한 항목’ 섹션이 이제 ‘앱’으로 이름이 변경됐습니다. 위의 이미지를 보세요. 그것이 첫 번째입니다.\n\n<div class=\"content-ad\"></div>\n\n## #27. 독일어로 Siri를 부를 때 \"Hey\" 제외하기\n\n이전에 Siri를 깨우기 위해 \"Hey Siri\"라고 말해야 했습니다. 그러나 iOS 17부터는 그것을 \"Siri\"로 간략화할 수 있는 옵션이 제공되었습니다.\n\n![이미지](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_27.png)\n\n그러나 아직 모든 언어와 호환되지는 않습니다. iOS 17.4에서는 독일어가 호환 언어로 포함되었습니다.\n\n<div class=\"content-ad\"></div>\n\n아니오, iOS 17이 멋지지 않나요?\n\niOS 17의 280여 가지 이상의 새로운 기능: 컴필레이션 (항상 업데이트됨):\n\n마침내,\n\n새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면 (제가 그렇듯), Setapp에 가입해보세요. 매달 $9.99에 놀라운 앱 240여 개의 선별된 컬렉션에 액세스할 수 있습니다. 개별 구매 시 수백 달러가 드는 앱들이군요.\n\n<div class=\"content-ad\"></div>\n\n- 지금부터 여러분의 Setapp 여정을 시작할 때 제 제휴 링크를 사용해보세요! (30일 무료 이용 가능합니다)\n- 여기에서 Setapp에서 제가 추천하는 70가지 이상의 최고의 macOS 앱 목록을 무료로 받아보세요.\n\n새 이야기를 게시할 때마다 알림을 받고 싶으신 450명 이상의 다른 분들과 함께하세요!\n\n# 부록: 새로운 이모지 목록\n\n![2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_28.png](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_28.png)\n\n<div class=\"content-ad\"></div>\n\n## 처음 두 줄의 이모지\n\n- 🙂↕️ — 세로로 머리 흔들기\n- 🙂↔️ — 가로로 머리 흔들기\n- ⛓️💥 — 깨진 사슬\n- 🍄🟫 — 갈색 버섯\n- 🍋🟩 — 라임\n- 🐦🔥 — 피닉스\n\n## 세 번째 줄의 이모지\n\n- 🚶➡️ — 오른쪽을 향한 걷는 사람\n- 🏃➡️ — 오른쪽을 향한 뛰는 사람\n- 🧎➡️ — 오른쪽을 향한 무릎 꿇은 사람\n- 🧑🦯➡️ — 오른쪽을 향한 백색 이동 보조 도구를 사용하는 사람\n- 🧑🦽➡️ — 오른쪽을 향한 수동 휠체어 이용자\n- 🧑🦼➡️ — 오른쪽을 향한 전동 휠체어 이용자\n\n<div class=\"content-ad\"></div>\n\n비슷한 여러 피부색과 성별을 나타내는 이모지가 더 있어요. Emojipedia에서 모두 확인해보세요.\n\n## 가족 이모지\n\n![Family emojis](/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_29.png)\n\n이 네 개의 이모지는 가족 이모지 세트를 대체해요.\n\n<div class=\"content-ad\"></div>\n\n다음은 사용할 수 있는 이모지 대체 목록입니다:\n\n- 🧑‍🧑‍🧒‍🧒 — 가족: 어른, 어른, 아이, 아이\n- 👨‍👨‍👧‍👦 — 두 아빠와 딸, 아들이 있는 가족\n- 👩‍👩‍👧‍👦 — 두 엄마와 딸, 아들이 있는 가족\n- 👨‍👩‍👧‍👦 — 엄마, 아빠, 딸, 아들이 있는 가족\n- 👨‍👨‍👦‍👦 — 두 아빠와 둘째와 막내 아들이 있는 가족\n- 👨‍👨‍👧‍👧 — 두 아빠와 둘째와 막내 딸이 있는 가족\n- 👩‍👩‍👦‍👦 — 두 엄마와 둘째와 막내 아들이 있는 가족\n- 👩‍👩‍👧‍👧 — 두 엄마와 둘째와 막내 딸이 있는 가족\n- 👨‍👩‍👦‍👦 — 엄마, 아빠, 둘째와 막내 아들이 있는 가족\n- 👨‍👩‍👧‍👧 — 엄마, 아빠, 둘째와 막내 딸이 있는 가족\n\n다음은 두 번째로 사용할 수 있는 이모지 목록입니다:\n\n- 👨‍👨‍👦 — 두 아빠와 아들이 있는 가족\n- 👨‍👨‍👧 — 두 아빠와 딸이 있는 가족\n- 👨‍👩‍👦 — 엄마, 아빠, 아들이 있는 가족\n- 👨‍👩‍👧 — 엄마, 아빠, 딸이 있는 가족\n- 👪 — 두 부모님과 아이가 있는 가족\n- 👩‍👩‍👦 — 두 엄마와 아들이 있는 가족\n- 👩‍👩‍👧 — 두 엄마와 딸이 있는 가족\n\n<div class=\"content-ad\"></div>\n\n세 번째 이모지가 바뀝니다:\n\n- 👩‍👦‍👦 — 어머니와 두 아들이 있는 가족\n- 👩‍👧‍👦 — 어머니, 딸, 아들이 있는 가족\n- 👩‍👧‍👧 — 어머니와 두 딸이 있는 가족\n- 👨‍👦‍👦 — 아버지와 두 아들이 있는 가족\n- 👨‍👧‍👦 — 아버지, 딸, 아들이 있는 가족\n- 👨‍👧‍👧 — 아버지와 두 딸이 있는 가족\n\n네 번째 이모지가 바뀝니다:\n\n- 👨‍👦 — 아버지와 아들이 있는 가족\n- 👨‍👧 — 아버지와 딸이 있는 가족\n- 👩‍👦 — 어머니와 아들이 있는 가족\n- 👩‍👧 — 어머니와 딸이 있는 가족\n","ogImage":{"url":"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_0.png"},"coverImage":"/assets/img/2024-05-27-iOS174IsWayBiggerThanWeveExpected25AmazingFeatures_0.png","tag":["Tech"],"readingTime":17},{"title":"Swft Data로 SwiftUI 어플리케이션 개발하기","description":"","date":"2024-05-27 18:02","slug":"2024-05-27-BuildingSwiftUIApplicationswithSwiftData","content":"\n\n![Image](/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_0.png)\n\n# Swift UI는 Swift Data를 시작하는 가장 쉬운 방법입니다\n\n- Swift UI와의 완벽한 통합\n- 간편한 구성\n- 데이터 자동 가져오기 및 뷰 업데이트\n\n# Swift Data 소개\n\n\n<div class=\"content-ad\"></div>\n\n표를 마크다운 형식으로 변경해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Model\nclass Category {\n\n  @Attribute(.unique) var name: String\n  var imageName: String\n\n  init(name: String,\n       imageName: String = \"rupeesign.circle\",\n       type: CategoryType) {\n    self.name = name\n    self.imageName = imageName\n  }\n\n}\n```\n\n## Using the model macro\n\nModifies all stored properties\n\n@Model\n\n\n\n<div class=\"content-ad\"></div>\n\n- 강력한 새로운 스위프트 매크로\n- 코드로 스키마 정의하기\n- 모델 유형에 스위프트 데이터 기능 추가하기\n\n속성을 어떻게 추론할지 제어합니다.\n\n@Attributes\n\n- 속성에서 추론된 속성\n- 기본 값 유형 지원\n- 구조체, 열거형, Codable 및 값 유형의 컬렉션과 같은 복잡한 값 유형의 지원\n\n<div class=\"content-ad\"></div>\n\n@관계\n\n- 관계는 참조 유형에서 유추됩니다.\n- 다른 모델 유형\n- 모델 유형의 컬렉션\n\n@Transient로 속성 제외\n\n더 많은 정보: Swift Data로 스키마 모델링하기 (WWDC 2023)\n\n<div class=\"content-ad\"></div>\n\n# 데이터 작업하기\n\n## 모델 컨테이너\n\n- 영속성 백엔드\n- 구성에 맞게 사용자 지정\n- 스키마 마이그레이션 옵션 제공\n\n```js\n.modelContainer(for: Category.self) { result in\n    // TODO: - 결과 처리\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 모델 컨텍스트\n\n- 업데이트 추적\n- 모델 가져오기\n- 변경 내용 저장\n- 변경 내용 취소\n\n![이미지](/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_1.png)\n\n더 많은 정보: SwiftData에 대한 깊은 탐구 (WWDC 2023)\n\n<div class=\"content-ad\"></div>\n\n# SwiftUI와 통합\n\nSwiftData는 SwiftUI를 염두에 두고 만들어졌으며 함께 사용하는 것이 더 쉽습니다.\n\n뷰 수정자\n\n- 씬 및 뷰 수정자 활용\n- .modelContainer로 데이터 구성\n- SwiftUI 환경 전체에 전파됨\n\n<div class=\"content-ad\"></div>\n\n@Query Property Wrapper\n\n```swift\n@Query var categories: [Category]\nvar body: some View {\n List(categories) { category in\n  NavigationLink(category.name, destination: CategoryView(category))\n }\n}\n```\n\nSwiftData와 SwiftUI가 함께 작동하여 기본 데이터가 변경될 때 뷰에 실시간 업데이트를 제공하며 결과를 수동으로 새로 고침할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n변경 사항 관찰\n\n@Published를 사용할 필요가 없습니다. SwiftUI는 관찰 대상 속성을 자동으로 새로 고칩니다.\n\n추가 정보: SwiftData(WWDC 2023)를 활용하여 앱을 개발해보세요.\n\n# 자동 지속성\n\n<div class=\"content-ad\"></div>\n\nSwiftData는 사용자 모델로 사용자 지정 스키마를 빌드하고 효율적으로 필드를 기반 저장소에 매핑합니다. SwiftData가 관리하는 객체는 필요할 때 데이터베이스에서 가져오고 추가 작업없이 적절한 시점에 자동으로 저장됩니다. 또한 ModelContext API를 사용하여 완전한 제어를 할 수도 있습니다.\n\n# CloudKit 동기화\n\n데이터는 DocumentGroup을 사용하여 파일로 저장하고 iCloud Drive를 통해 동기화하거나 CloudKit을 사용하여 장치간 데이터 동기화를 할 수 있습니다.\n\n# Core Data와 호환 가능\n\n<div class=\"content-ad\"></div>\n\nSwiftData는 Core Data의 검증된 저장 아키텍처를 사용하므로 동일한 기본 저장소를 사용하여 동일한 앱에서 둘 다 사용할 수 있습니다. 준비가 되면 Xcode가 Core Data 모델을 SwiftData와 함께 사용할 클래스로 변환할 수 있습니다.\n\n# 참고:\n","ogImage":{"url":"/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_0.png"},"coverImage":"/assets/img/2024-05-27-BuildingSwiftUIApplicationswithSwiftData_0.png","tag":["Tech"],"readingTime":3},{"title":"iOS에서 Compose Multiplatform을 사용하는 앱 이제 베타 - 2024년 개발자 인사이트","description":"","date":"2024-05-27 18:00","slug":"2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights","content":"\n\nCompose Multiplatform for iOS가 오늘 공식적으로 베타로 승격되었어요, 하지만 기업들이 이미 장기간 생산에 성공적으로 사용하고 있어요! 몇몇 애플리케이션을 살펴보죠. iOS에서 Compose Multiplatform (비공식적으로 CMP로 약칭)를 사용한 경험을 설명해 달라고 여러 개발자들에게 물었더니 다음과 같은 이야기를 들었어요.\n\n이것은 2023년에 Kotlin Multiplatform(KMP)을 사용하는 인기 애플리케이션들을 따르는 다음 단계이며, (포브스와 볼트와 같은) 더 많은 애플리케이션이 가입했지만, 이 게시물에서는 사용자 인터페이스를 공유하는 애플리케이션에 중점을 두었어요.\n\n안드로이드와 iOS 버전 모두의 공개 애플리케이션에 대한 링크가 포함되어 있어요, 그래서 직접 시도해 볼 수 있어요(그리고 혹시 머티리얼 리플을 발견할 수 있을지도 😉).\n\n\n\n<div class=\"content-ad\"></div>\n\n# 인스타박스 (내부 앱)\n\n스웨덴 물류 회사 인스타박스의 개발자들은 수천 명의 사용자가 사용하는 내부 iOS 앱을 SwiftUI로 개발하기 시작했습니다. 그러나 iOS에서 실행되는 Compose 데모를 보고 프로토타입을 만들어 CTO에게 보여줬고, CTO가 좋아해서 계속해서 작업을 진행했습니다. 이미 Kotlin Multiplatform을 사용하여 앱을 구조화했기 때문에 그들은 단 두 주만에 프로토타입을 만들었습니다.\n\n2023년 8월 Talking Kotlin 팟캐스트 에피소드에서 개발자들은 CMP와 함께 작업하는 선택과 프로세스에 대해 설명했습니다. 개발자들은 KMP와 함께 네이티브 API가 간단하게 사용될 수 있고, \"그냥 [공통으로] 파일을 옮길 수 있다\"는 점이 Kotlin Multiplatform의 장점이라고 특히 만족하고 있습니다.\n\n인스타비 개발자 요한네스 스벤손\n\n<div class=\"content-ad\"></div>\n\nKotlinConf 2024에서 \"Compose Multiplatform on mobile at Instabee for over a year\"이라는 주제로 발표가 있을 예정입니다. 녹화가 준비되면 이 기사를 업데이트하겠습니다.\n\n스스로 다시 써야 했던 가장 큰 것은 탐색이었습니다. 그 당시에는 아직 멀티플랫폼이 아니었지만, 주요 개발자인 Johannes는 현재 멀티플랫폼 Compose Navigation을 곧 채택할 것으로 말했습니다. 현재 앱은 일부 커스텀 코드(예: 백 제스처 처리)와 함께 Voyager를 사용하여 탐색 중입니다.\n\n# Markaz (1M+)\n\n![이미지](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_1.png)\n\n<div class=\"content-ad\"></div>\n\n이 앱을 통해 사용자들은 온라인으로 제품을 구매하고 판매할 수 있어요. 비즈니스 로직부터 UI까지 Kotlin 코드를 공유해요. 이 앱은 파키스탄 시장을 대상으로 하고 있기 때문에 모든 국가에서 이용 가능하지 않을 수 있어요. 최근 업데이트에서는 iOS의 백 스와이프 제스처가 추가되었어요. 또한, Compose Multiplatorm에서 기본적으로 제공되는 iOS 룩 앤 필을 통해 네이티브 스크롤링과 같은 기능을 사용할 수 있어요.\n\n마르카즈(Markaz) 개발자 카시프(Me\\nhmood)\n\nApp Store: https://apps.apple.com/pk/app/markaz-resell-and-earn-money/id6470020517 Play Store: https://play.google.com/store/apps/details?id=com.markaz.app\n\n# Wrike (1M+)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_2.png\" />\n\n오늘 KotlinConf에서 발표된 소식입니다: Wrike가 iOS에서 앱의 캘린더 부분에 Compose를 사용하고 있습니다. 리드 개발자는 키노트 비디오에서 다음과 같이 말했습니다 (게시물 맨 아래에 링크가 있습니다):\n\nWrike 기술 담당자 Alex Askerov\n\nApp Store: [여기를 클릭하여 App Store에서 확인하세요](https://apps.apple.com/ms/app/wrike-work-as-one/id890048871)\nPlay Store: [여기를 클릭하여 Play Store에서 확인하세요](https://play.google.com/store/apps/details?id=com.wrike)\n\n<div class=\"content-ad\"></div>\n\n## Campus (100K+)\n\n![Campus app](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_3.png)\n\n캠퍼스 - 수업 일정 (원래 이름: Кампус - Расписание занятий)은 대학생들을 위한 앱으로, 수업 일정을 추적하는 데 사용됩니다. 이 앱은 주로 네이티브이지만 \"과목\" 섹션(앱의 두 번째 탭)에서 Compose Multiplatform을 사용합니다. 개발자는 2023년 중반 CMP를 통합했는데, 이는 알파 상태에 도달한 직후입니다.\n\nIceRock (캠퍼스 개발자)의 CTO인 Aleksey Mikhailov\n\n<div class=\"content-ad\"></div>\n\n앱 스토어: [https://apps.apple.com/ru/app/кампус-расписание-занятий/id1534975833](https://apps.apple.com/ru/app/кампус-расписание-занятий/id1534975833)  \n플레이 스토어: [https://play.google.com/store/apps/details?id=ru.dewish.campus](https://play.google.com/store/apps/details?id=ru.dewish.campus)\n\n# Ashampoo Photo Organizer (예정)\n\n![이미지](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_4.png)\n\nAshampoo Photos의 iOS 첫 버전은 SwiftUI로 작성되었습니다. Compose Multiplatform이 사용 가능해지자 개발자는 개발 방향을 변경했습니다. 현재 작성 중인 이 포스트에서 새 버전은 Compose UI로 구축되어 테스트 중이며 아직 사용할 수 없습니다. 그러나 Compose Multiplatform이 모바일 플랫폼뿐만 아니라 Windows(그리고 곧 MacOS)에서도 실행되므로 소프트웨어를 [여기](https://www.ashampoo.com/photo-organizer)에서 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아샴푸 개발자 Stefan Oltmann님\n\n앱스토어: 곧 공개 예정\n플레이 스토어: https://play.google.com/store/apps/details?id=com.ashampoo.photos\n\n# 오픈 소스: KotlinConf (5천 명 이상), Twine RSS Reader (1만 명 이상) 및 FindTravelNow\n\n이 목록의 마지막 세 개의 앱은 오픈 소스입니다! 정확히 어떻게 구축되었는지 궁금하다면 꼭 확인해보세요. 먼저 공식 KotlinConf 앱부터 차례로 살펴보겠습니다!\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_5.png)\n\nKotlinConf  \nApp Store: [link](https://apps.apple.com/us/app/kotlinconf/id1299196584)  \nPlay Store: [link](https://play.google.com/store/apps/details?id=com.jetbrains.kotlinconf)  \nSource code: [link](https://github.com/JetBrains/kotlinconf-app)\n\nThen Twine, which is an RSS reader with 10K+ downloads:\n\n![image](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_6.png)\n\n<div class=\"content-ad\"></div>\n\nTwine — RSS 리더\n앱 스토어: [링크](https://apps.apple.com/us/app/twine-rss-reader/id6465694958)\n플레이 스토어: [링크](https://play.google.com/store/apps/details?id=dev.sasikanth.rss.reader)\n소스 코드: [링크](https://github.com/msasikanth/twine)\n\n그리고 마지막으로, FindTravelNow은 전 세계에서 저렴한 항공권을 찾기 위한 \"메타서치 여행 애플리케이션\"입니다:\n\n![이미지](/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_7.png)\n\nFindTravelNow\n앱 스토어: [링크](https://apps.apple.com/gr/app/findtravelnow/id6471192930)\n플레이 스토어: [링크]https://play.google.com/store/apps/details?id=com.travelapp.findtravelnow)\n소스 코드: [링크](https://github.com/mirzemehdi/FindTravelNow-KMM)\n\n<div class=\"content-ad\"></div>\n\n# 마무리\n\n이 라운드업이 크로스 플랫폼 개발로 나아가고 싶어하는 분들에게 영감을 주기를 바랍니다. 일반적으로 Kotlin Multiplatform처럼, 만약 시도해보고 중단하려고 한다면 멀티플랫폼 부분을 더 나아가지 않기로 결정해도 항상 작동하는 현대적인 Android 앱을 가지고 계실 것입니다.\n\n시작하는 방법에 대한 더 많은 정보를 얻으려면 JetBrains 사이트를 확인해보세요: https://www.jetbrains.com/lp/compose-multiplatform/ 그리고 오늘의 KotlinConf 키노트에서 Compose iOS 베타 발표를 확인해보세요.\n\n이 기사의 핵심 개발자 및 커뮤니티에 유용한 정보를 제공해 준 분들에게 특별히 감사드립니다 🚀.\n","ogImage":{"url":"/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_0.png"},"coverImage":"/assets/img/2024-05-27-AppsusingComposeMultiplatformoniOSnowbetain2024developerinsights_0.png","tag":["Tech"],"readingTime":6},{"title":"배터리 사가, 아이폰15 프로 맥스","description":"","date":"2024-05-27 17:58","slug":"2024-05-27-ThebatterysagatheiPhone15ProMax","content":"\n\n![2024-05-27-ThebatterysagatheiPhone15ProMax_0.png](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_0.png)\n\n# 또 다른 하루 또 다른 이야기\n\n나와 내 iPhone 15 Pro Max에게는 이상한 한 주가 지났어요.\n\n나에게는 이번 주에 두 번 모험했습니다! 나 자신을 은둔자로 묘사하려는 것이 아닌데, 본성상 나는 외로운 사람이라서 이 콘텐츠 창작 일은 나에게 완벽해요. 스스로 쓰고 편집하는 데 많은 시간을 보낼 수 있지만, 그로 인해 자리에 머무르는 습관을 낳아요. 올해 스튜디오에서 너무 멀리 나가지 않았다는 것을 깨달았기 때문에, 이번 주에는 그것을 바꾸고 살짝 변화를 주기로 결정했어요.\n\n\n<div class=\"content-ad\"></div>\n\n일자별 계획은 콘텐츠 중심으로 구성되어 있었고, 주로 iPhone 15 Pro Max에 많이 의존했습니다. 정기적으로 저를 읽는다면 삼성 S24 울트라를 구매할 생각이 있었음을 아실 것입니다. 그 제품에 흥미를 느꼈지만, 무엇보다도 콘텐츠가 필요했기 때문에 그 제품을 더욱 탐내게 되었습니다!\n\n하지만 그때에 깨달았죠. 제게 가장 소중한 것, 즉 내가 가장 즐기는 것에 집중하라는 것을요 - 바로 내 iPhone 15 Pro Max에요.\n\n작년 안드로이드를 살펴보고 사용한 후, 그것이 나에게 충분하지 않다는 것을 알았어요. 나는 결코 아이폰 사용자이며, 이번에 사용 중인 아이폰은 내가 사용하고 소유한 제품 중 최고의 제품이라고 생각해요. 늘 이 제품을 적극 지지해 왔죠. 그래서 거의 6개월이 지난 이번 주에는 이 제품과 함께 몇 마일을 달려보기로 결정했어요.\n\n이번 주 초에는 윈저, 이튼, 배터시를 방문했고, 오늘은... 오늘은 저는 런던의 웨스트 엔드에서 막 돌아왔습니다. 수도시 거리를 돌아다니며 보낸 멋진 날이었고, 애플 대리점 두 곳 - 애플 리젠트 스트리트와 애플 나이츠브리지 두 곳도 방문한 날이었답니다.\n\n<div class=\"content-ad\"></div>\n\n![iPhone 15 Pro Max](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_1.png)\n\n# 아이폰 15 Pro Max - 프로일까요?\n\n오늘의 여행은 배터리 수명에 집중하기로 한 것이었습니다.\n\n이번 주 초에 우연히 배터리가 주인공이 되었습니다. 그 날은 그저 멋진 비디오와 사진 몇 장을 찍기 위해 나갔는데 — 제가 한 것 같다고 생각합니다. 그러나 집에서 8시간을 벗어나서 폰을 그 의도대로 사용한 결과, 결국 집에 왔을 때 배터리가 거의 다 닳아 있었습니다. 저는 20%만 남았죠.\n\n<div class=\"content-ad\"></div>\n\nPro Max모델은 iPhone 중에서 가장 큰 배터리를 가지고 있어서 Pro라 불리며, 프로 작업을 수행할 수 있다는 의미입니다.\n\n지난 주에 운이 없었을 수도 있겠다 싶었는데, 오늘은 다시 확인해보기로 했습니다. 그때 그때일까요, 아니면 이것이 정상인가요? iPhone 15 Pro Max에서 기대해도 되는 성능인가요?\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_2.png)\n\n# 계속해서 이어짐\n\n<div class=\"content-ad\"></div>\n\n저번 여행 이야기를 쓴 후 누군가가 전력 소비 데이터를 살펴보라고 제안해주었어요! 정말 좋은 조언이었어요 — 감사합니다!\n\n가장 많은 전력을 사용한 것은 카메라 (당연한 일이겠지만!)으로 25%였고, 사진은 20%를 차지했어요 (찍은 사진을 확인하고 보는 동안이겠죠) 그리고 이상하게도 홈 & 잠금 화면이 14%를 차지했어요. 아마 정말 어리석은 말을 하는 것 같지만... 잠금 화면이 전원을 그래서 소모하는 건 어떻게 된 일일까요 — 아마 항상 켜진 디스플레이 기능을 켜 둔 것 때문이겠죠...\n\n저는 오전 11시 이전에 99%의 배터리로 집을 떠났어요 — 오늘은 분명 더 나은 결과를 얻을 수 있을 거예요...\n\n<div class=\"content-ad\"></div>\n\n# 너무 가까워\n\n나는 항상 내가 살고 있는 곳과 런던이 얼마나 가까운지를 잊곤 해요.\n\n모터웨이를 한 시간 운전해서 가니, 가장 흥겹고 활기찬 도시 중 하나에 도착했어요.\n\n차에서 내려서 iPhone으로 사진을 찍기 시작했어요. Mac의 사진 앱을 보니 오늘은 200장 가까운 사진과 영상을 찍은 것 같아요. 어디를 바라보아도 또 다른 사진 촬영 기회가 있었어요.\n\n<div class=\"content-ad\"></div>\n\n\n![The Battery Saga - the iPhone 15 Pro Max](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_4.png)\n\n# 일에 착수하기\n\n주요 광각 24mm 렌즈의 모든 초점 거리를 시험해보기로 했다. 일주일 전에 이를 조사하기 시작했지만, 런던의 모든 명소를 둘러보면서 정말 카메라를 즐길 수 있을 것이라고 생각했다.\n\n아래에 유명한 피카딜리 서커스 광고판의 몇 장의 사진이 있다. 첫 번째 사진은 1배 확대 24mm로 촬영한 것이고, 두 번째 사진은 5배 확대 120mm로 촬영한 것이다. 이미지를 200%로 확대해도 매우 많은 선명함이 유지되며, 점이 놀랍게 날카로운 것을 알 수 있다.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_5.png)\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_6.png)\n\n집을 나온 지 4시간이 조금 넘었는데 배터리 상태가 54%로 괜찮았어요. 하지만 이번 주에 배우게 된 것으로 보아 이 부분이 중요한 전환점인 것 같아요. 약 50% 정도까지 괜찮아 보이다가 부터 뚝 떨어지기 시작합니다. 오늘 하루 배터리 상태를 맹수처럼 살펴봐야겠어요.\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_7.png)\n\n<div class=\"content-ad\"></div>\n\n이번 주까지는 5배 줌 기능을 많이 사용하지 않았어요. 일상생활에서는 별로 필요 없는데, 오늘 같은 날에는 정말 그 밋밋함에서 벗어나야 할 때입니다. 첫 번째 1배 24mm 샷으로 내가 얼마나 떨어져 있었는지 조금 감을 잡을 수 있어요. RAF 폭격기 기억비의 뾰족한 봉우리를 5배 줌으로 얼마나 잘 찾아냈는지 볼 수 있죠. 인상적네요.\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_8.png)\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_9.png)\n\n이번 주 런던에서 시험해보지 못한 것 중 하나는 120mm 렌즈의 디지털 줌 기능이었어요. 기억하세요, 저는 5배 줌 초심자라구요!\n\n<div class=\"content-ad\"></div>\n\n![2024-05-27-ThebatterysagatheiPhone15ProMax_10.png](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_10.png)\n\n![2024-05-27-ThebatterysagatheiPhone15ProMax_11.png](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_11.png)\n\n여기서 문제가 시작됩니다.\n\n사과 로고 주변에는 120mm에서도 조리개 ƒ2.8/80 ISO, 셔터 속도 1/100으로 심하게 고스트링이 나타납니다. 하지만 400mm까지 확대하면 (ƒ2.8/ 50 ISO) 사용할 수 없을 정도로 심해집니다 — 이때의 셔터 속도는 이제 1/148이었습니다.\n\n<div class=\"content-ad\"></div>\n\n제가 다른 이야기에서 언급했지만, iPhone의 배경에서 행해지는 기기 내 계산 보정을 살펴볼 때 메타데이터에 흥미로워하곤 합니다. 사진을 촬영할 때마다 올바른 설정을 계산해 주는데, 이것에 대해 우리는 한 번도 생각해보지 않았습니다. 그 결과는 대체로 훌륭합니다. 메인 24mm 카메라의 세 개의 초점 거리는 특히 인상적합니다.\n\n오늘은 드디어 롱 노출 설정과 함께 놀아보는 것을 기억했어요. 이에 대해 많은 통제권이 없어 보이지만, 얻게 되는 것이 전부입니다. 하지만 이것으로 재미있는 시간을 가질 수 있을 것 같아요. 아, 그리고 루프 비디오로 변환할 수도 있어서 정말 멋진 효과를 줄 수 있어요...\n\n![이미지](/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_12.png)\n\n# 최종 생각\n\n<div class=\"content-ad\"></div>\n\niPhone 15 Pro Max를 정말 탐험하기 시작한 시간을 가졌어서 기뻐요. S24 Ultra를 사서 빠르고 싸게 클릭만 하는 것이 아니라 이미 가지고 있는 것에 더 투자해봤어요.\n\n활동적으로 즐거운 경험이었어요 — 밖으로 나가서 즐기는 것 뿐만 아니라 창작자로서의 자아를 발견하는 것도요. 이번 주까지는 대중 앞에서 녹화하는 걸 싫어했는데, 이제는 그것이 직업의 일부인 것 같다는 생각이 들어요.\n\n또한 iPhone에 대해 더 깊이 알아가는 것 또한 즐거웠어요. 6개월 동안 주머니 안에 넣어두었는데, 이제야 시작해서 무엇이 가능한지 알아가기 시작한 것 같아요. 어떻게 이런 것들에 대해 몰랐을까요?\n\n하지만...그 모든 좋은 점들에도 아직은 오래 지속되는 걱정이 있어요. 지난 주에 두 번이나 Pro Max를 이용해 보았는데, 두 번 모두 거의 하루를 버텨내지 못했네요. 그 50% 문제가 실재하는 것 같아요. 약 2시간 만에 54%에서 17%로 떨어지는 것을 볼 수 있어요. 그리고 그 동안 중 일부 시간 동안 iPhone은 차 안에 있어서 음악을 스트리밍 할 뿐이었어요.\n\n<div class=\"content-ad\"></div>\n\n그래도 배터리 문제는 한쪽에 두고 — 이제 내 15 Pro Max에서 정말 많은 것을 얻고 있는 느낌을 받고 있고, 정말 즐기고 있어요.\n\n200개가 넘는 생산성 앱을 한 곳에서 쉽게 확인해 보고 싶다면 SetApp을 확인해보세요. 정말 멋지답니다 — 매월 한 번의 요금으로 Bartender, CleanShot X, Paste, iStat Menus, BetterTouchTool과 같이 멋진 앱을 고를 수 있어요. 한 번 시도해보고 30일 무료 사용해 보고 싶다면 제 제휴 링크를 클릭해서 살펴보세요. 어떤 앱이 제일 마음에 드는지 알려주세요.\n\n2024년 2월 18일에 https://talkingtechandaudio.com에서 최초 게시된 글입니다.\n","ogImage":{"url":"/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_0.png"},"coverImage":"/assets/img/2024-05-27-ThebatterysagatheiPhone15ProMax_0.png","tag":["Tech"],"readingTime":6}],"page":"30","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}