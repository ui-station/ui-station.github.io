{"pageProps":{"posts":[{"title":"인스타그램 아키텍처를 활용한 시스템 디자인 이해하기 ","description":"","date":"2024-06-19 11:33","slug":"2024-06-19-UnderstandingSystemDesignusingInstagramsArchitecture","content":"\n\n시스템 디자인은 소프트웨어 엔지니어에게 중요한 기술이에요, 특히 직무 면접 중에요. 이는 중요한 개념을 이해하고 실전 상황에서 제한 사항과 함께 활용할 수 있는 능력을 시험해요. 시스템 디자인을 마스터하려면 서로 다른 구성 요소와 그들이 어떻게 작동하여 확장 가능하고 신뢰성 있고 유지보수가 쉬운 시스템을 구축하는지 이해해야 해요. 이 안내서는 시스템 디자인의 중요성을 설명하고 시스템 아키텍처의 세부적인 분석을 제공할 거에요: Instagram! 🚀\n\n![시스템디자인](/assets/img/2024-06-19-UnderstandingSystemDesignusingInstagramsArchitecture_0.png)\n\n## 시스템 디자인이란? 💡\n\n시스템 디자인은 시스템이 어떻게 작동할지 계획하는 것이에요. 전반적인 구조, 개별 부분, 상호 작용 방식, 사용하는 데이터를 결정하는 것을 포함해요. 이 과정은 시스템 내 모든 요소가 특정 기능, 성능, 확장성 및 신뢰성을 충족하기 위해 잘 작동하는지 확인해요. 이는 고수준 아키텍처적 결정(큰 그림)뿐만 아니라 전체 시스템이 원활하게 실행되도록 상세한 저수준 구성 요소를 포함해요.\n\n<div class=\"content-ad\"></div>\n\n## 시스템 설계가 왜 중요한가요?\n\n시스템 설계는 수백만 명의 사용자를 처리하면서도 원활하게 작동하고 신뢰할 수 있는 앱을 만드는 데 필수적입니다. 중요한 결정을 내려 구조, 기술 스택 및 설계 방법에 대해 고민해야 합니다. 시스템 설계 인터뷰는 이러한 선택 사항을 얼마나 잘 분석하고 효율적이고 확장 가능하며 신뢰할 수 있는 시스템을 만들 수 있는지를 테스트합니다.\n\n## 정복해야 할 주요 개념:\n\n시스템 설계를 다루기 전에 이러한 기본 개념을 숙지하는 것이 중요합니다:\n\n<div class=\"content-ad\"></div>\n\n- 도메인 이름 시스템 (DNS): 글로벌 접근성을 위해 도메인 이름을 IP 주소로 변환합니다.\n- 로드 밸런서: 다수의 서버로 들어오는 네트워크 트래픽을 분산하여 높은 가용성과 성능을 보장합니다.\n- API 게이트웨이: 다양한 마이크로서비스들을 위한 통합된 입구를 제공하여 통신과 관리를 간편하게 합니다.\n- CDN (콘텐츠 전송 네트워크): 사용자에게 더 가까운 곳에 콘텐츠를 캐싱함으로써 전 세계적으로 미디어 콘텐츠를 낮은 지연 시간으로 제공합니다.\n- 포워드 프록시 vs 리버스 프록시: 보안과 성능을 위해 클라이언트와 서버 사이 (포워드) 또는 서버와 클라이언트 사이 (리버스)에서 요청을 관리합니다.\n- 캐싱: 자주 액세스되는 데이터를 저장하여 지연 시간을 줄이고 성능을 향상시킵니다.\n- 데이터 파티셔닝: 대량의 데이터를 효율적으로 처리하기 위해 데이터 세트를 여러 기기에 분할합니다.\n- 데이터베이스 복제: 여러 서버 간에 데이터를 복제하여 가용성과 내고장 허용성을 보장합니다.\n- 분산 메시징 시스템: 실시간 데이터 처리를 위해 분산된 응용 프로그램 간 통신을 지원합니다.\n- 마이크로서비스: 독립적으로 개발, 배포 및 확장할 수 있는 작은 서비스로 구성된 아키텍처 스타일입니다.\n- 데이터베이스: 구조화된(SQL) 또는 비구조화된(NoSQL) 방식으로 데이터를 저장하여 다양한 유형의 데이터를 처리하는 확장성과 유연성을 제공합니다.\n- 데이터베이스 색인화: 빠른 데이터 검색을 가능케 하여 쿼리 성능을 향상시킵니다.\n- 분산 파일 시스템: 확장성과 신뢰성을 위해 네트워크의 여러 노드에 걸쳐 저장소를 관리합니다.\n- 알림 시스템: 사용자나 다른 시스템에 이벤트를 알리기 위해 경보 또는 메시지를 전송합니다.\n- 전체 텍스트 검색: 대량의 텍스트 데이터에 대한 효율적인 검색 기능을 제공합니다.\n- 하트비트: 서비스나 노드의 생존 여부를 점검하여 실행 중이고 이용 가능한지 확인합니다.\n\n## 시스템 디자인 인터뷰에서 뛰어나기 위한 전략 💯\n\n1. 요구 사항 이해 및 명확화:\n— 기능 요구 사항: 시스템이 수행해야 하는 주요 기능을 파악합니다. 인스타그램의 경우 사진 업로드, 게시물 좋아요 및 댓글 작성, 다른 사용자 팔로우, 사용자 정의 피드 생성 등을 의미합니다. \n— 비기능 요구 사항: 확장성, 신뢰성, 가용성, 성능, 일관성, 보안, 유지 관리를 포함합니다.\n\n2. 부하 및 트래픽 예상: 시스템을 사용할 사용자 수, 정보를 추가하거나 가져올 때의 속도, 모든 데이터를 저장하는 데 필요한 공간, 필요한 인터넷 용량 등을 파악합니다. 이 정보는 예상 활동량을 관리할 수 있는 시스템을 디자인하는 데 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n3. 데이터 흐름과 아키텍처 설계: 시스템이 어떻게 작동하는지 보여주는 다이어그램을 만드세요. 중요한 부분을 강조하고 서로 어떻게 작동하는지 알려주세요. 이렇게 하면 설계를 더 명확하게 설명할 수 있습니다.\n\n4. 적절한 기술 선택: 필요한 것과 일치하는 데이터베이스, 캐싱 시스템, 부하 분산 장치 및 기타 기술을 선택하세요.\n\n5. 트레이드오프 논의: 설계 결정에서 한 트레이드오프를 설명하세요. 시스템이 얼마나 일관적인지 대비 가능한지, 대답 속도와 한 번에 처리할 수 있는 작업 양을 균형있게 고려하고, 복잡성 대비 사용하기 쉽고 이해하기 쉬운 정도에 대해 이야기해주세요.\n\n6. 반복 및 최적화: 고수준 설계로 시작하여 단계별로 개선하세요. 피드백과 추가 요구사항에 따라 최적화하세요.\n\n<div class=\"content-ad\"></div>\n\n# Instagram 시스템 디자인\n\n이제 Instagram의 아키텍처에 대해 자세히 살펴보겠습니다:\n\n![이미지](/assets/img/2024-06-19-UnderstandingSystemDesignusingInstagramsArchitecture_1.png)\n\n## 기능 요구 사항:\n\n<div class=\"content-ad\"></div>\n\n- 포스트 서비스: 사용자가 포스트를 업로드하고 가져올 수 있습니다.\n- 좋아요/댓글 서비스: 포스트의 좋아요와 댓글을 관리합니다.\n- 팔로우 서비스: 팔로우 및 언팔로우 작업을 처리하고 팔로워 데이터를 검색합니다.\n- 피드 생성 서비스: 사용자에게 맞춤형 피드를 생성합니다.\n- 메시징 서비스: 사용자가 직접 메시지를 보내고 받을 수 있습니다.\n- 알림 서비스: 사용자가 좋아요, 댓글, 팔로우 및 직접 메시지에 대한 알림을 받습니다.\n- 검색 서비스: 사용자가 다른 사용자, 해시태그 및 위치를 검색할 수 있습니다.\n\n## 비기능 요구사항:\n\n- 확장성: 시스템은 수백만 명의 사용자를 지원하고 그들의 상호 작용을 처리해야 합니다.\n- 신뢰성: 고가용성 및 내결함성이 필수적입니다.\n- 가용성: 시스템은 높은 업타임(99.9% 이상)을 가져야 합니다.\n- 성능: 포스팅, 포스트 가져오기 및 피드 생성에 대한 빠른 응답 시간을 보장해야 합니다.\n- 일관성: 좋아요, 댓글, 팔로우 및 포스트 간 데이터 일관성을 보장해야 합니다.\n- 보안: 시스템은 사용자 데이터와 개인 정보를 보호해야 합니다.\n\n## 추정:\n\n\n<div class=\"content-ad\"></div>\n\n- 사용자 기반: 매일 활동하는 5억 명의 사용자를 가정합니다.\n- 초당 게시물: 초당 5,000개의 게시물을 추정합니다.\n- 초당 좋아요/댓글: 초당 50,000개의 좋아요와 댓글을 추정합니다.\n- 팔로워 검색: 초당 10,000개의 팔로워 검색 요청을 추정합니다.\n- 피드 요청: 초당 50,000개의 피드 요청을 가정합니다.\n- 초당 검색 쿼리: 초당 20,000개의 검색 쿼리를 추정합니다.\n- 초당 메시지: 초당 15,000개의 메시지를 발송하는 것을 추정합니다.\n\n## 아키텍처 구성 요소:\n\n1. 사용자: 사용자들은 기기를 통해 응용 프로그램과 상호 작용합니다. 사용자들은 응용 프로그램을 통해 게시, 좋아요, 댓글 및 팔로우와 같은 작업을 수행합니다.\n\n2. 부하 분산기: 단일 서버가 병목현상을 일으키는 것을 방지하기 위해 들어오는 요청을 여러 서버로 분산합니다.\n\n<div class=\"content-ad\"></div>\n\n3. API Gateway: 모든 클라이언트 요청의 입구 역할을 합니다. 인증, 요청 속도 제한 및 적절한 서비스로 요청을 라우팅합니다.\n\n4. 인증 및 요청 속도 제한: 인증된 사용자만 서비스에 액세스할 수 있도록 보장하고, 요청의 수를 제한하여 남용을 방지합니다.\n\n5. 앱 서버 (읽기): 대량의 읽기 작업을 처리하기에 최적화되어 있습니다. 게시물, 댓글, 좋아요, 팔로워, 피드 생성, 검색 쿼리 및 메시지 검색을 위한 요청을 라우팅합니다.\n\n6. 앱 서버 (쓰기): 대량의 쓰기 작업을 처리하기에 최적화되어 있습니다. 게시물 작성, 좋아요 및 댓글 추가, 사용자 팔로우/언팔로우, 메시지 전송, 사용자 데이터 업데이트를 위한 요청을 라우팅합니다.\n\n<div class=\"content-ad\"></div>\n\n7. Redis: 자주 액세스되는 데이터를 저장하는 캐싱 계층으로 작용하여 데이터베이스 부하를 줄이고 응답 시간을 향상시킵니다.\n\n8. 데이터베이스: 사용자 정보, 게시물, 좋아요, 댓글 및 팔로우 데이터를 포함한 모든 영구 데이터를 저장합니다. 데이터베이스는 높은 읽기 및 쓰기 처리량을 지원해야 합니다. (각 서비스의 특정 요구 사항에 따라 더 효율적인 처리를 위해 별도의 데이터베이스를 만들 수 있습니다)\n\n9. Blob Storage: 이미지와 비디오와 같은 대형 이진 객체을 저장합니다. 이미지 및 비디오를 효율적으로 저장하고 배포하여 빠르고 안정적인 미디어 콘텐츠 액세스를 보장합니다.\n\n10. CDN (콘텐츠 전송 네트워크): 이미지 및 비디오를 전 세계적으로 배포하여 전 세계 사용자에 대한 빠른 액세스와 지연 시간을 줄입니다.\n\n<div class=\"content-ad\"></div>\n\n11. 포스트 서비스: 게시물의 생성 및 검색을 관리합니다. 포스트 데이터를 데이터베이스 및 블롭 저장소에 작성하고, 피드 생성 서비스를 업데이트합니다.\n\n12. 좋아요/댓글 서비스: 게시물에 대한 좋아요 및 댓글을 처리합니다. 데이터베이스를 업데이트하고, 피드 생성 서비스에 피드를 새로 고침하도록 알립니다.\n\n13. 팔로우 서비스: 팔로우 및 언팔로우 작업을 관리합니다. 데이터베이스와 피드 생성 서비스에서 팔로우 데이터를 업데이트합니다.\n\n14. 피드 생성 서비스: 사용자의 팔로우 데이터와 상호 작용을 기반으로 개인화된 피드를 생성하고 제공합니다. Redis 및 데이터베이스에서 데이터를 읽어 효율적으로 피드를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n15. 알림 서비스: 새로운 팔로워, 좋아요 및 댓글과 같은 사용자 활동에 대한 실시간 알림을 전송합니다.\n\n16. 검색 서비스: 게시물, 사용자 및 해시태그에 대한 사용자 검색 쿼리를 처리합니다. 자주 액세스되는 데이터에는 Redis를 활용하고, 드물게 발생하는 쿼리에 대해서는 데이터베이스를 사용합니다. 검색 결과가 최신이며 정확하도록 관리합니다.\n\n17. 메시징 서비스: 사용자 간 실시간 메시징을 가능하게 합니다. 메시지 저장을 위해 전용 데이터베이스를 사용하고, 즉각적인 전달과 알림을 보장하기 위해 실시간 메시징 인프라를 활용합니다.\n\n이러한 구성 요소 및 상호 작용을 이해하면 대규모 응용 프로그램을 위한 견고하고 확장 가능하며 효율적인 시스템을 설계할 수 있습니다. 이러한 아키텍처를 통해 인스타그램은 수백만 명의 사용자를 처리하고 콘텐츠에 빠르고 안정적으로 액세스할 수 있으며 높은 가용성과 성능을 유지할 수 있습니다. 각 구성 요소는 내결함성이 있으며 독립적으로 확장 가능하며 특정 작업 처리에 효율적으로 설계되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n시스템 디자인 면접을 성공적으로 통과하기 위해서는 구조적인 원리에 대한 탄탅한 이해, 복잡한 요구사항을 분해하는 능력, 그리고 합리적인 디자인 결정을 내릴 수 있는 기술이 필요합니다. 체계적인 접근 방식을 따르고 현실 세계의 예시를 활용함으로써, 확장 가능하고 효율적인 시스템을 디자인할 수 있는 능력을 보여줄 수 있습니다. 연습이 중요하니, 다양한 디자인 문제에 도전하여 스킬을 향상시키세요.\n\nP.S: 학습 과정 동안 메모를 계속 쌓아왔어요. 본 글이 시스템 디자인에 대해 더 잘 이해하는 데 도움이 되길 바랍니다. 직접 시스템을 디자인하는 과정을 즐기세요! :D","ogImage":{"url":"/assets/img/2024-06-19-UnderstandingSystemDesignusingInstagramsArchitecture_0.png"},"coverImage":"/assets/img/2024-06-19-UnderstandingSystemDesignusingInstagramsArchitecture_0.png","tag":["Tech"],"readingTime":7},{"title":"구조화된 복제 JavaScript에서 객체를 깊은 복사하는 가장 쉬운 방법","description":"","date":"2024-06-19 11:33","slug":"2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript","content":"\n\n깊은 복사는 데이터를 전달하거나 저장하기 위한 정기적인 프로그래밍 작업입니다.\n\n- Shallow copy: 객체의 첫 번째 수준만 복사합니다.\n- Deep copy: 객체의 모든 수준을 복사합니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 이 시간 동안 완벽한 객체 깊은 복사를 위한 내장 방법이 없었고, 신경 써야 했어요.\n\n우리는 항상 서드파티 라이브러리를 의존하여 깊은 복사와 순환 참조를 유지해야 했어요.\n\n지금은 새로운 structuredClone()을 통해 모든 객체를 깊은 복사할 수 있는 쉽고 효율적인 방법이 생겼어요.\n\n![image](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_2.png)\n\n<div class=\"content-ad\"></div>\n\n쉽게 순환 참조를 복제하고 있어요:\n\n![이미지](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_3.png)\n\nJSON stringify/parse 트릭으로는 할 수 없었던 작업이예요:\n\n![이미지](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_4.png)\n\n<div class=\"content-ad\"></div>\n\n깊게 들어가 보세요:\n\n![image](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_5.png)\n\n## 알아야 할 제한 사항\n\nstructuredClone()은 매우 강력하지만 알아야 할 중요한 약점이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n# 함수나 메소드를 복제할 수 없어요\n\n![이미지](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_6.png)\n\n사용하는 특별한 알고리즘 덕분이에요.\n\n![이미지](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_7.png)\n\n<div class=\"content-ad\"></div>\n\n# DOM 요소를 클론할 수 없어요\n\n![이미지1](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_8.png)\n\n![이미지2](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_9.png)\n\n![이미지3](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_10.png)\n\n<div class=\"content-ad\"></div>\n\n# RegExp의 lastIndex 속성을 보존하지 않음\n\n말 그대로, 누가 정규식을 복제하겠어요. 하지만 하나 주목할 점은:\n\n![이미지](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_11.png)\n\n# 다른 제한 사항\n\n<div class=\"content-ad\"></div>\n\n함수를 사용할 때 예기치 않은 동작을 피하기 위해 그것들을 인지하는 것이 중요합니다.\n\n## 일부 복제하고 이동하기\n\n이것은 좀 더 복잡한 것입니다.\n\n원본에서 클론으로 내부 객체를 복사하는 대신 이동시킵니다.\n\n<div class=\"content-ad\"></div>\n\n해석 결과에 더 이상 수정할 내용이 없습니다. 해당 내용은 다음과 같습니다:\n\n\n![image](/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_12.png)\n\nstructuredClone()는 JavaScript 개발자의 도구상자에 속한 귀중한 요소로, 객체 복제를 이전보다 쉽게 만들어줍니다.\n","ogImage":{"url":"/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_0.png"},"coverImage":"/assets/img/2024-06-19-structuredCloneTheeasiestwaytodeepcopyobjectsinJavaScript_0.png","tag":["Tech"],"readingTime":3},{"title":"애자일 방법론의 실패률이 268 높다고요","description":"","date":"2024-06-19 11:31","slug":"2024-06-19-268HigherFailureRatesforAgileRight","content":"\n\n이 기사의 동기는 다음 글에서 비롯되었습니다:\n\n솔직히 말하면, 전체 내용을 읽을 수밖에 없어서 그랬어요. 주요 이유는 결론이 나를 깜짝 놀라게 한 것입니다. 제 고유의 편견도 상당한 역할을 했다고 인정해야 합니다. 제 경험과 이전 지식이 그 반대를 시사했을 때 놀랐습니다. 그러나 반복적으로 난관을 겪는 기업들이 애자일을 도입하려 들고 있는 것을 관찰했고, 부분적 도입이 전혀 없는 것보다 나쁠 수 있다는 것을 알게 되었습니다. 그렇다면, 이 기사는 어떠한 새로운 통찰을 제공할까요?\n\n# 영향 공학\n\n먼저 알아야 할 사실은, 이 기사가 사실상 책 'Impact Engineering'의 홍보 자료라는 것입니다. 이것은 주황색 깃발이 될 수 있지만, 이는 내용을 자동으로 차단하지는 않습니다. 이 책이 홍보하는 방법론 개발 과정에서 준아데 알리가 중요한 발견을 했을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 실제로, 이전에 본 적이 있어서 일부로 관심을 끌었던 것이 있었습니다:\n\n이것은 몇 년 동안의 나의 관찰과 일치합니다. 많은 조직이 Agile를 채택하려고 시도했지만 중도에 멈추는 것을 보았습니다. 이상적인 계획과 절대적인 통제에 대한 폭포수 습관을 버리는 마지막 단계가 불가능한 꿈인 것처럼 보이고, 동시에 Agile는 뛰어난 유연성과 기본기를 갖춘 높은 성과 팀을 필요로 합니다.\n\n그렇다면 우리는 높은 성과를 낼 수 있는 사람이 아닌 사람이 있음을 받아들여야 할까요? 모두가 리오넬 메시나 마이클 조던이 아니라고 말하듯이, 맞나요? 그렇다면, Agile가 초월적인 팀에게만 효과적인, 모두를 위해 적합하지 않은 원치 않는 꿈이라는 결론이 가능한가요?\n\n# 메트릭\n\n<div class=\"content-ad\"></div>\n\n'영향 엔지니어링'이 어떻게 작동하는지에 대한 명확한 설명이 없지만, 지표들은 주로 집중해야 할 방향을 제시하는 것으로 보입니다:\n\n- 명확한 요구 사항: 개발 전에 명확하게 정의된 요구 사항을 가진 프로젝트는 성공할 가능성이 더 높습니다.\n- 심리적 안전감: 소프트웨어 엔지니어가 문제를 빠르게 논의하고 해결할 수 있는 안전한 환경에서는 성공률이 더 높습니다.\n- 현실 세계적 중요성: 현실의 문제를 기반으로 하는 프로젝트는 더 성공할 가능성이 높습니다.\n- 문서화: 개발이 시작되기 전에 완전한 명세 또는 요구 사항 문서를 갖는 것도 성공 가능성을 높입니다.\n- 지연된 변경 사항 없음: 개발 프로세스 후반에 중요한 변경 사항을 피하는 것은 성공률을 약간 향상시킵니다.\n\n따라서, 애자일 방법론이 성공할 수 있는 영역과 그렇지 않을 수 있는 영역이 존재한다는 점을 알 수 있습니다. 심리적 안전감 관련하여 애자일이 이를 100% 지원한다는 것은 명확하지만, 메트릭에서 이를 반영하면 애자일을 시도하는 회사들이 이 측면에서 실패하고 있는 것으로 보입니다. 반면, 선호를 표현하더라도 다른 세 가지 애자일 가치 - ‘체계적인 문서보다 실행 중인 소프트웨어', ‘계약 협상보다 고객 협력', '계획 따르기보다 변화에 대응하기’ -은 부담스럽고 재검토가 필요할 수 있습니다.\n\n# 실패\n\n<div class=\"content-ad\"></div>\n\n모든 지표는 실패 비율을 측정하며, 이곳에 핵심 질문이 있습니다: 실패가 어떻게 정의되는가?\n\n전체 기사를 찾아보았지만 명확한 정의를 찾을 수 없었습니다.\n\n실패 비율이 어떻게 정의되는지 이해하는 데 제일 가까운 것은 책 저자의 인용구를 기사의 결과 차트와 교차 참조한 것이었습니다. 인용구는 \"Agile 관행을 채택한 프로젝트 중 65%가 제때 전달되지 못하면서, Agile의 붐 주의에 대해 의문을 제기할 시간이다.\"라고 말합니다. 결과 차트에는 \"Agile 요구 사항 엔지니어링(개발이 명확한 요구 사항 전에 시작됨, 완전한 명세서 없음, 개발 후반부에 중요한 변경 발생)\"의 \"실패 비율\"인 65%가 나와 있습니다. 따라서, 실패는 \"납기 미달\"로 정의된다고 결론을 내리는 것이 맞다고 생각합니다.\n\n이에 대해 몇 가지 의문이 듭니다. 이 연구에서 새로운 정보에 적응하지 못하는 것을 실패로 간주합니다. 이게 어떤 뜻인가요? 제품을 전달하기 전에 모든 것을 예측할 수 있다고 가정하는 건가요? 모든 것을 자세히 예측하는 비용이 초기 프로토타입을 만들고 테스트하는 비용보다 낮다고 가정하는 건가요? 그렇다면 시장 조사는 대안들보다 더 저렴하고 정확한가요?\n\n<div class=\"content-ad\"></div>\n\n위 내용을 보면 저자가 새로운 사실이 발견될 때 적응하지 못하는 능력을 긍정적인 특성으로 측정하는 것인지 궁금해집니다. 또는 저자의 비유를 따라, 금연 실패를 측정하는 것일까요? — 금연을 하지 못하기 때문에, 이 사실을 인정하고 최고의 흡연자가 되기 위해 최선을 다해야 합니다.\n\n# 숫자들\n\n해당 연구의 또 다른 주황색 신호는 참가자 수가 비교적 적다는 것입니다. 구체적으로, \"마지막으로 성공한 프로젝트를 경험한 481명의 소프트웨어 엔지니어와 마지막으로 실패한 프로젝트를 경험한 119명\"으로 기사에 따르면 정확히 600명의 참가자가 있습니다. 산업 다변화 정도, 모든 프로젝트가 특정 유형인지, 그리고 질문들이 어떻게 로딩되었는지가 명확하지 않습니다. 게다가 이 분배를 살펴본다면 대부분의 엔지니어가 성공적이었지만 대부분의 Agile 프로젝트가 실패했다고 보고했습니다. 따라서 산업에서 Agile이 상당한 비중을 차지하고 있음에도 불구하고, 그들은 관련 통계적 표현과 함께 데이터 수집을 보장하지 않았습니다. 따라서 정확히 600명의 소프트웨어 엔지니어 참가는 상당히 존경받을만하지만 대표적이라고 말할 수는 없습니다.\n\n비교적 다른 결과를 보여주며 훨씬 튼튼한 기초를 갖춘 두 가지 다른 연구가 있습니다. 그 중 하나는 훌륭한 방법론을 갖추고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n가장 잘 알려진 보고서 중 하나는 Standish Group의 CHAOS 보고서입니다. 이 보고서는 1만 건 이상의 소프트웨어 프로젝트(프로젝트, 소프트웨어 엔지니어가 아닌)를 기반으로 하며, 작은 프로젝트에서 애자일이 50% 이상의 성공률을 보여줍니다. 사실, 자세히 보면 프로젝트의 크기가 가장 중요한 요소임을 알 수 있습니다. 프로젝트가 클수록 실패 가능성이 높아집니다. 따라서, 애자일이 프로젝트를 작은 단위로 나누어 서로 연계되는 작은 결과물을 만드는 아이디어는 훨씬 더 나은 결과를 제공합니다. CHAOS 보고서 2015를 참조하세요.\n\n가장 주목할 만한 것은 물론 \"가속화\"라는 책에서 세부적으로 설명되어 있는 DORA 지표입니다. Nicole Forsgren이 쓴 이 책은 2014년부터 매년 수행되고 있으며, 매년 약 3만명의 참가자로부터 정보를 수집합니다. 이전 지표들과 달리, 프로젝트의 성공 또는 실패를 논의하는 대신 네 가지 실질적인 목표 지표를 설정합니다. 제공하는 결론 중 하나는 애자일 중 하나인 지속적인 전달이 최상의 결과를 제공한다는 것입니다. 보고서와 방법론은 여기서 확인하세요.\n\n# 습관\n\n\"충격 공학\" 저자의 방식으로, 기사를 시작할 때 우리는 습관을 바꿀 수 없다는 접근을 제안합니다. 이는 체중 감량이나 흡연을 그만두는 것이 어렵듯이, 폭포수 방법론을 따르는 본능을 버리는 것도 똑같이 어렵다는 것을 시사하는 것 같습니다. 이 경우에는 제안된 폭포수 개념을 다시 검토하는 것이 합리적입니다. 우리는 현실적이어야 하며, 변화할 의지가 없거나 의지가 부족하다면, 그것을 받아들이고 우리 자신에게 적응하는 것이 더 나을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 다른 접근 방식이 있습니다.\n\n환경을 변경하세요.\n\n이 아이디어는 DORA 지표의 결과와 일치합니다. 사람을 바꾸려는 대신 환경을 바꿀 수 있습니다. 사람들은 환경에 적응합니다. 예를 들어, 금연령령은 환경을 바꿔서 흡연자들이 더 적게 피우거나 전혀 그만두도록 적응해야 했습니다. 침대옆 탁자에 책을 두는 등 작은 행동은 읽는 습관을 되찾도록 도와줄 수 있습니다. 이것은 소프트웨어 개발에도 적용할 수 있습니다. 우리는 습관을 바꾸기 위해 환경을 조정할 수 있는데, 경쟁력이 떨어지는 방법론에 안주할 필요는 없습니다.\n\n환경을 변경하고 그 효과에 대해 거의 1년 전에 다른 이야기에서 썼습니다.\n\n<div class=\"content-ad\"></div>\n\n감사합니다. 보통 소프트웨어 엔지니어링을 이해하고 적용하는 방법에 대해 생각하면서 이야기를 쓰는 것을 좋아해요. 무엇을 개선할 수 있는지 고민하게 만들기도 해요. 만약 기사가 마음에 드셨다면 박수를 치거나 댓글을 남겨주세요. 더 많은 통찰과 토론을 위해 제 매체에서 가장 성공적인 이야기들을 둘러보세요.","ogImage":{"url":"/assets/img/2024-06-19-268HigherFailureRatesforAgileRight_0.png"},"coverImage":"/assets/img/2024-06-19-268HigherFailureRatesforAgileRight_0.png","tag":["Tech"],"readingTime":5},{"title":"왜 나는 직장에서 PR 리뷰를 그만뒀는지","description":"","date":"2024-06-19 11:30","slug":"2024-06-19-WhyIStoppedReviewingPRsatWork","content":"\n\n\n![Image](/assets/img/2024-06-19-WhyIStoppedReviewingPRsatWork_0.png)\n\nThe Secret Developer is a seasoned software developer who loves helping colleagues move their tickets to the right.\n\nSo how have they suddenly had a moment of clarity where they realize their efforts need to stop for the good of themselves and the team.\n\n# The Situation\n\n\n<div class=\"content-ad\"></div>\n\n회사에서 일하는 것은 주로 기능을 출시하고 작업을 완료하기 위해 함께 일하는 것을 의미합니다.\n\n안타깝게도, 제 현재 역할에서는 시니어 개발자만 pull 요청을 검토하는 것 같습니다. 우리의 계약 업체 중 한 명에게 이에 대해 질문했더니 다음과 같이 말했습니다.\n\n하루에 (최대) 한 개의 PR을 검토할 의향이 있는 또 다른 개발자를 알고 있습니다. 때로는 우리의 코딩 파이프라인이 멈추어 버립니다.\n\n다른 회사에서 일했을 때는, PR을 검토하면 상대방이 당신의 PR을 검토하는 상호적인 관계가 있었지만, 제 현재 회사에는 이러한 관행이 없습니다.\n\n<div class=\"content-ad\"></div>\n\n좀 더 화가 나게 만든 상황이 또 있어서 조금 초조스러워요. 그것은 특정 PR에 관한 것이에요.\n\n## 그 PR\n\n한 번쯤, 이 대답에 있는 끔찍한 PR은 제 작품이 아니라 동료의 솜씨에 의한 것이에요.\n\n<div class=\"content-ad\"></div>\n\n여기에 어떻게 되었는지 개요가 있어요.\n\n내 동료가 12개 정도의 클래스 이름을 바꿔야 했어요. 그들은 IDE에서 리팩터링 명령을 사용해서 이름을 빠르고 쉽게 변경했어요 — 멋진 선택이에요. 이름 변경에 대한 모든 인스턴스를 확인하는 것을 잊어서 일관성이 없는 부분이 몇 군데 있었어요.\n\n그래도 괜찮아요. 완벽한 사람은 아니기 때문에요. 저도 많은 실수를 범해요 (대개 요구 사항을 제대로 읽지 않는 것) 그래서 남들이 실수를 하는 걸 보면 보통 안심이 돼요.\n\n하지만, 다음에 벌어진 일은 참견할 수 없다고 생각했어요.\n\n<div class=\"content-ad\"></div>\n\n## 이후 발생한 일\n\n그들은 나를 그냥 무시했어. 사실, 그렇게 한 것이 공정하지 않다. 왜냐하면 그들은 내 PR에 관한 코멘트에 대해 무언가를 했거든.\n\n내가 한 코멘트 아래에 \"다음 PR\"이라고 써 놓았어. 회사의 문화가 '건의사항으로 승인됨'을 사용하는 것이기 때문에, 그들은 그저 내 코멘트를 해결하고 변경 사항을 병합했어.\n\n글쎄, 곧 그들은 그 변경 사항이 다른 변경 사항의 집합으로 포함된 또 다른 PR을 제출했어. 변화가 서로 얽혀 있어서 한 PR에서 검토하기 어려웠어. Slack에서 메시지가 왔어. \"검토할 PR이 준비되었습니다.\"\n\n<div class=\"content-ad\"></div>\n\n## 결과\n\n나는 이것이 단순한 사건이 아니라는 것을 알았어요. 이건 행동의 일관된 양상이고, 나에게만 해당하는 것이 아니에요.\n\n하지만 내 정신 건강이 저하된다는 것을 느끼고 있어요. 내 의견이 들어주지 않고 존중받지 못하는 느낌이에요.\n\n물론 빠르게 기능을 출시하고 업무를 해결하고 싶다는 것은 이해해요. 하지만 작업을 검토하는 것은 내 몫으로 남아 있고, 문제를 해결하려면 내가 작업을 다시 검토해야 하는 상황이 계속되고 있어요. 모든 맥락을 기억하고 필요한 것을 이해해야 하는 부담이 생기고 있어요.\n\n<div class=\"content-ad\"></div>\n\n이 상황에서 내게 최선인 것을 알고 있나요? 저는 정말 필요하거나 누군가 나에게 그렇게 요구할 때 제외하고 PR을 검토하지 않을 거에요.\n\n한편, 저는 새 직장을 찾을 거에요. 누군가는 나를 그리워하지 않을 것 같아요.\n\n# 이런 상황에서 당신은 어떻게 해야 할까요?\n\n알아요, 아마 당신은 제가 그렇게 까다롭고 사교적이지 않을 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n또 다른 팀들 중에는 (저와 함께 할 수 있을까요, 제발?) 제안을 승인하지 않는 팀도 있답니다.\n\n하지만 여러분이 팀 내에서 자신의 의견이 충분히 들어지지 않는 상황을 겪을 수도 있을 거예요.\n\n이런 문제를 피하거나 이와 같은 문제를 대처하는 방법에 대해 몇 가지 팁을 알려드릴게요.\n\n## 명확하게 의사소통하기\n\n<div class=\"content-ad\"></div>\n\nPR에 발견된 문제에 대해 명확한 커뮤니케이션을 유지해주세요. 감정을 감춘 비약적인 발언을 피하고, 직접적이고 건설적인 의견을 표현해주세요.\n\n## 경계 확인\n\n조직 내에서 PR 관행에 대한 경계가 무엇인지 물어보세요. 코드에 제안 사항이 어떻게 구현될 수 있는지에 대한 대화를 시작해보세요.\n\n## 경계 설정\n\n<div class=\"content-ad\"></div>\n\nPR 실천에 허용되는 명확한 기준을 설정하세요. 필요하다면 꾸준히 제안을 무시하는 PR을 검토하지 않기로 거절하세요.\n\n## 궁극적으로\n\n존중받을 가치가 있습니다. 그렇지 않다면, 여러분이 향하고 있는 목표를 이루기 위해 올바른 위치에 있는지 생각해보는 것이 중요할 수도 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n제가 개발자이기 때문에, 테이블 태그를 마크다운 형식으로 변경하도록 하겠습니다.\n\n\n\n# About The Author\n\n\n\n<div class=\"content-ad\"></div>\n\n프로 개발자 \"The Secret Developer\"는 Twitter에서 @TheSDeveloper로 찾을 수 있으며, 정기적으로 Medium.com을 통해 기사를 발표합니다.\n\nThe Secret Developer은 한 가지 불행한 직원이며, 아마도 유해한 존재일 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-WhyIStoppedReviewingPRsatWork_0.png"},"coverImage":"/assets/img/2024-06-19-WhyIStoppedReviewingPRsatWork_0.png","tag":["Tech"],"readingTime":3},{"title":"5가지 필수 NET 마이크로서비스 패턴","description":"","date":"2024-06-19 11:29","slug":"2024-06-19-5EssentialNETMicroservicesPatterns","content":"\n\n\n![2024-06-19-5EssentialNETMicroservicesPatterns_0](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_0.png)\n\n소프트웨어 개발의 끊임없는 세계에서, 마이크로서비스 아키텍처는 특히 .NET의 광범위한 영역에서 인기 있는 선택지가 되었습니다. .NET은 확장 및 적응이 가능한 능력으로 대규모의 데이터 및 트래픽을 처리할 수 있는 이상적인 플랫폼입니다. \n\n이 기사에서는 마이크로서비스 아키텍처를 숙달하고자 하는 .NET 개발자들을 위한 다섯 가지 필수 패턴을 탐구할 것입니다. 우리는 실용적인 예제와 실행 가능한 조언을 제공하여 마이크로서비스의 우수성을 달성하는 여정에서 당신을 돕겠습니다.\n\n## 1. 게이트웨이 집계 패턴\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_1.png)\n\n마이크로서비스 아키텍처에서는 클라이언트 응용 프로그램이 상호 작용해야 할 여러 서비스가 있는 것이 일반적입니다. 각 개별 서비스와 직접 상호 작용하는 대신 API 게이트웨이를 사용하는 것이 더 좋습니다. 이 방법은 클라이언트 코드를 간소화하고 백엔드 서비스에 액세스하기 위한 단일 진입점을 생성합니다.\n\n```js\n// Ocelot API Gateway 사용 예제\npublic async Task<AggregatedResult> AggregateData()\n{\n    var userTask = _userService.GetUser();\n    var ordersTask = _orderService.GetOrdersForUser();\n    \n    await Task.WhenAll(userTask, ordersTask);\n    \n    var user = await userTask;\n    var orders = await ordersTask;\n\n    return new AggregatedResult\n    {\n        User = user,\n        Orders = orders\n    };\n}\n```\n\n## 2. 회로 차단기 패턴\n\n\n<div class=\"content-ad\"></div>\n\n\n![Circuit Breaker](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_2.png)\n\n서킷 브레이커를 구현하면 네트워크 또는 서비스 장애가 다른 서비스로 전파되는 것을 방지할 수 있습니다. 서비스 장애가 발생하면 서킷 브레이커가 이를 감지하고 그 서비스로의 후속 호출을 일정 기간 동안 자동으로 차단합니다.\n\n```js\n// Polly 라이브러리 사용 예제\nvar circuitBreakerPolicy = Policy\n    .Handle<Exception>()\n    .CircuitBreaker(2, TimeSpan.FromMinutes(1));\n\nawait circuitBreakerPolicy.ExecuteAsync(async () =>\n{\n    await PerformServiceCall();\n});\n```\n\n## 3. 서비스 디스커버리 패턴\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_3.png)\n\n마이크로서비스 아키텍처를 확장할수록 다양한 서비스 엔드포인트를 추적하기가 더 어려워집니다. 이 문제를 해결하기 위해 서비스 디스커버리를 구현할 수 있습니다. 이를 통해 서비스가 동적으로 서로를 찾을 수 있습니다.\n\n```js\nusing System;\nusing System.Threading.Tasks;\nusing Consul;\nusing Microsoft.Extensions.DependencyInjection;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var serviceProvider = new ServiceCollection()\n            .AddSingleton<IConsulClient, ConsulClient>(p => new ConsulClient(consulConfig =>\n            {\n                // Assuming Consul is running on localhost\n                consulConfig.Address = new Uri(\"http://localhost:8500\");\n            }))\n            .AddSingleton<IConsulService, ConsulService>()\n            .BuildServiceProvider();\n\n        var consulService = serviceProvider.GetService<IConsulService>();\n        consulService.RegisterService().Wait();\n        consulService.DiscoverServices().Wait();\n    }\n}\n\npublic interface IConsulService\n{\n    Task RegisterService();\n    Task DiscoverServices();\n}\n\npublic class ConsulService : IConsulService\n{\n    private readonly IConsulClient _consulClient;\n\n    public ConsulService(IConsulClient consulClient)\n    {\n        _consulClient = consulClient;\n    }\n\n    public async Task RegisterService()\n    {\n        var registration = new AgentServiceRegistration()\n        {\n            ID = Guid.NewGuid().ToString(),\n            Name = \"MyService\",\n            Address = \"localhost\",\n            Port = 5000,\n        };\n\n        await _consulClient.Agent.ServiceRegister(registration);\n        Console.WriteLine(\"Consul에 서비스 등록됨\");\n    }\n\n    public async Task DiscoverServices()\n    {\n        var services = await _consulClient.Agent.Services();\n        foreach (var service in services.Response.Values)\n        {\n            Console.WriteLine($\"발견된 서비스: {service.Service}\");\n        }\n    }\n}\n```\n\n## 4. 이벤트 소싱 패턴\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_4.png\" />\n\n이벤트 소싱은 응용 프로그램 엔티티의 상태 변경을 이벤트 시리즈로 저장하는 패턴입니다. 이 접근 방식은 특히 마이크로서비스 아키텍처에서 유용하며 시스템에 대한 모든 변경 사항의 감사 가능한 레코드를 제공하여 디버깅 및 문제 해결에 도움이 됩니다. 게다가 이벤트 소싱은 응용 프로그램의 다른 구성 요소 간 데이터 일관성을 보장하는 데 도움이 될 수 있습니다.\n\n```js\n// EventStore를 사용한 이벤트 소싱 예시\npublic async Task SaveEvents(Guid entityId, IEnumerable<Event> events, long expectedVersion)\n{\n    var eventData = events.Select(e => new EventData(\n        Guid.NewGuid(),\n        e.GetType().Name,\n        true,\n        Serialize(e),\n        null));\n\n    var streamName = $\"Entity-{entityId}\";\n    await _eventStoreConnection.AppendToStreamAsync(streamName, expectedVersion, eventData);\n}\n```\n\n## 5. CQRS 패턴\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_5.png)\n\nCommand Query Responsibility Segregation (CQRS)는 시스템의 읽기 및 쓰기 작업을 분리하는 디자인 패턴입니다. 이 접근 방식은 마이크로서비스에 적합하며 복잡한 데이터 모델을 관리하고 시스템을 더 효과적으로 확장하는 데 도움이 됩니다.\n\n새로운 사용자 추가를 위한 명령\n\n```js\n// Commands/AddUserCommand.cs\npublic class AddUserCommand\n{\n    public string Name { get; }\n\n    public AddUserCommand(string name)\n    {\n        Name = name;\n    }\n}\n\n// Handlers/AddUserCommandHandler.cs\npublic class AddUserCommandHandler : ICommandHandler<AddUserCommand>\n{\n    public void Handle(AddUserCommand command)\n    {\n        // Logic to add the user to the database\n        Console.WriteLine($\"User {command.Name} added\");\n    }\n}\n``` \n\n\n<div class=\"content-ad\"></div>\n\nID로 사용자를 가져오는 쿼리\n\n```js\n// Queries/GetUserQuery.cs\npublic class GetUserQuery\n{\n    public int UserId { get; }\n\n    public GetUserQuery(int userId)\n    {\n        UserId = userId;\n    }\n}\n\n// Handlers/GetUserQueryHandler.cs\npublic class GetUserQueryHandler : IQueryHandler<GetUserQuery, User>\n{\n    public User Handle(GetUserQuery query)\n    {\n        // 데이터베이스에서 사용자를 가져오는 로직\n        return new User { Id = query.UserId, Name = \"John Doe\" };\n    }\n}\n```\n\n핸들러를 위한 인터페이스\n\n```js\n// Commands/ICommandHandler.cs\npublic interface ICommandHandler<TCommand>\n{\n    void Handle(TCommand command);\n}\n\n// Queries/IQueryHandler.cs\npublic interface IQueryHandler<TQuery, TResult>\n{\n    TResult Handle(TQuery query);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 다섯 가지 방식을 따라가면 .NET 마이크로서비스를 숙달하기에 한 발짝 더 다가갈 것입니다. 이것들을 구성 요소로 활용하고 프로젝트에 맞게 사용자 정의하여 사용하세요. 당신의 마이크로서비스는 번성할 것입니다. 코딩을 즐기세요!\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*UmnFETy8f6kvj1TV.gif)\n\n👏 만약 이 콘텐츠가 도움이 된다면, 버튼을 누른 채로 여러 번 클랩(clap)할 수 있습니다. 또한, 여러분의 생각과 제안을 댓글로 남겨 주시면 더 많은 토론을 할 수 있습니다.\n\n읽어 주셔서 감사합니다...","ogImage":{"url":"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_0.png"},"coverImage":"/assets/img/2024-06-19-5EssentialNETMicroservicesPatterns_0.png","tag":["Tech"],"readingTime":7},{"title":"사용자분들은 누구인가요","description":"","date":"2024-06-19 11:27","slug":"2024-06-19-WhoAreYourUsers","content":"\n\n\n![이미지](/assets/img/2024-06-19-WhoAreYourUsers_0.png)\n\n소프트웨어 시스템의 \"사용자\"에 대해 이야기할 때, 모든 사용자가 유사한 특성과 요구사항을 가진 거대한 그룹에 속해 있다고 생각하는 경우가 종종 있습니다. 하지만 실제로는 규모가 있는 대부분의 제품은 서로 다른 기대와 목표를 가진 여러 사용자들에게 매력을 느끼게 됩니다. \"사용자\"를 단수로 생각하는 대신, 제품의 다양한 사용자 클래스와 그들의 요구사항 및 제약을 식별하는 데 시간을 투자하는 것이 좋습니다.\n\n# 사용자 분류\n\n이해관계자란 프로젝트에 적극적으로 참여하거나 프로젝트에 영향을 받는 개인 또는 그룹 또는 프로젝트의 방향을 결정할 수 있는 개인 또는 그룹을 말합니다. 그림 1에서 볼 수 있듯이 사용자 클래스는 제품의 사용자들의 하위 집합이며, 해당 사용자들은 제품의 고객들의 하위 집합이며, 이들은 이해관계자들의 하위 집합입니다. 각 사용자 클래스는 자체 요구사항과 제약 사항이 있을 것이며, 클래스 간에 일부 중복이 있을 수도 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![WhoAreYourUsers](/assets/img/2024-06-19-WhoAreYourUsers_1.png)\n\n제품을 사용하는 사용자들은 다양한 방법 중 몇 가지로 다를 수 있습니다. 이러한 차이를 기반으로 사용자들을 몇 가지 명백한 사용자 클래스로 그룹화할 수 있습니다:\n\n- 시스템과 직접적으로 상호작용할지 간접적으로 상호작용할지\n- 제품에서 수행하는 작업\n- 사용하는 제품 기능\n- 액세스 권한 또는 보안 수준 (일반 사용자, 게스트 사용자 또는 관리자와 같은)\n- 사용 빈도\n- 애플리케이션 도메인 경험 및 컴퓨터 시스템 전문성\n- 사용하는 플랫폼이나 장치 (PC, 태블릿, 스마트폰 또는 특수 장치)\n\n물리적 위치나 근무하는 비즈니스의 종류에 따라 사용자들을 클래스로 그룹화하는 것이 논리적으로 보일 수 있습니다. 은행 소프트웨어를 만드는 회사는 초기에 대형 상업 은행, 소규모 상업 은행, 저축 및 대부조합에서 근무하는지에 따라 사용자를 구분했습니다. 그러나 이러한 구별은 서로 다른 시장 세그먼트를 나타내는 것이 아니라 다른 사용자 클래스를 나타냅니다.\n\n\n<div class=\"content-ad\"></div>\n\n더 나은 그룹화 기법은 다양한 사용자들이 수행할 작업 (사용 사례, 사용자 이야기 또는 프로세스 흐름으로 표현)을 고려하는 것입니다. 이러한 활동을 수행하는 개인들은 모든 금융 기관에서 유사한 기능적 요구를 갖게 될 것입니다. 모든 이러한 기관은 창구원, 대출 신청서를 처리하는 사람, 비즈니스 은행원, 지점 매니저 등을 고용합니다. 이것이 더 의미 있는 사용자 분류 체계입니다.\n\n일부 사용자 분류는 제품 성공에 다른 분류보다 더 중요할 수 있습니다. 선호되는 사용자 분류는 프로젝트의 비즈니스 목표를 달성하는 데 가장 밀접하게 연관된 만족도가 가장 높은 분류입니다. 다른 사용자 분류 간 요구사항 간 충돌을 해결하거나 우선 순위 결정을 내릴 때, 선호되는 사용자 분류가 우선적으로 처리됩니다.\n\n비선호되는 사용자 분류는 법적, 보안 또는 안전상의 이유로 제품을 사용해서는 안 됩니다. 비선호되는 사용자가 허용되지 않은 작업을 하는 것을 어렵게 만들기 위한 기능을 구현할 수 있습니다. 예를 들어 액세스 보안 메커니즘, 사용자 권한 수준, 악성 코드 방지 기능 (비인간 사용자를 위한 것) 및 사용 로깅이 있습니다. 네 번의 실패 로그인 시도 후 사용자 계정을 잠그는 것은 “사용자를 가장하는 사용자 위조자”라는 비선호되는 사용자 분류로부터의 액세스로부터 보호해 주지만 망각쟁이의 정당한 사용자들을 귀찮게 할 위험이 따릅니다.\n\n또 다른 사용자 분류를 무시하기로 결정할 수 있습니다. 그들은 제품을 사용할지라도 특별히 그들에게 맞게 디자인하지 않습니다. 선호되지 않고, 무시되지 않은 사용자 그룹은 제품 요구 사항에 영향을 미치는 데 있어 동등한 중요성을 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n간접 사용자 클래스를 간과하지 마세요. 그들은 당신의 응용 프로그램을 직접 사용하지 않을 수 있지만, 다른 응용 프로그램을 통해 데이터나 서비스에 접근하거나 보고서를 받아들일 수 있습니다. 한 번 제거된 당신의 고객도 여전히 당신의 고객이에요.\n\n다양한 사용자 클래스는 사용자 인터페이스 디자인 선택에 영향을 미칠 수 있는 사용성과 같은 다른 품질 기대치를 가질 수 있어요. 새로운이나 가끔 사용자는 시스템이 얼마나 쉽게 배울 수 있는지에 대해 관심이 있어요. 이러한 사용자들은 메뉴, 깔끔한 화면 표시, 마법사 및 도움말 화면을 좋아해요. 사용자들이 경험을 쌓으면 효율성에 더 관심을 가지게 됩니다. 그들은 이제 키보드 바로 가기, 사용자 정의 옵션, 툴바 및 스크립팅 기능을 중요시해요.\n\n사용자 클래스가 반드시 사람이어야 하는 것은 아니에요. 인간 사용자를 대신하여 서비스를 수행하는 소프트웨어 에이전트, 예를 들어 봇과 같은 소프트웨어 에이전트도 사용자 클래스가 될 수 있어요. 소프트웨어 에이전트는 상품 및 서비스에 관한 정보를 스캔하거나 맞춤형 뉴스 피드를 구성하거나 수신 이메일을 처리하거나 물리적 시스템 및 네트워크를 문제나 침입으로부터 모니터링하거나 데이터 마이닝을 수행할 수 있어요. 당신의 제품으로부터 출력을 받는 다른 시스템도 사용자 클래스로 간주될 수 있어요.\n\n직접 및 간접 사용자 클래스 외에도 추가 요구 사항과 제약 조건을 제시할 수 있는 다양한 이해 관계자들을 고려하세요. 예를 들어, 개발 팀 구성원이 그들이 구축 중인 제품의 최종 사용자가 아니더라도, 효율성, 수정 가능성, 이식성 및 재사용성과 같은 내부 품질 속성에 관한 의견을 가질 것입니다.\n\n<div class=\"content-ad\"></div>\n\n한 회사는 제품 설치마다 많은 비용이 필요하다는 문제점을 발견했습니다. 그들은 제품의 맞춤화 아키텍처를 개발하는 등 요구 사항에 중점을 둘 \"설치자\" 사용자 클래스를 고안했습니다. 이해관계자를 식별할 때 명백한 최종 사용자 이상을 고려해보세요.\n\n# 사용자 클래스 식별하기\n\n제품의 다양한 사용자 클래스를 조기에 분류하여 각 중요 커뮤니티의 적합한 대표자와 소통할 수 있습니다. 먼저, 프로젝트 후원자에게 시스템을 사용할 것으로 기대하는 사람에 대해 묻습니다. 그런 다음 가능한 많은 사용자 클래스를 떠올려봅니다. 이 단계에서 수십 개의 사용자 클래스가 있다면 신경 쓰지 마세요. 나중에 축소하고 분류할 것입니다. 제공된 솔루션이 사용자의 요구 사항을 충족시키지 않아 문제가 생기는 일을 방지하기 위해 사용자 클래스를 누락하지 않는 것이 중요합니다.\n\n다음으로, 유사한 요구 사항을 가진 그룹을 찾아 합칠 수도 있거나 여러 하위 클래스가 있는 주요 사용자 클래스로 취급할 수 있습니다. 약 65개 기업 고객을 위해 특화된 제품을 개발한 한 회사는 처음에 각 고객 회사를 고유한 요구 사항을 가진 별개의 사용자로 간주했습니다. 그들의 고객을 단순히 여섯 개의 사용자 클래스로 그룹화함으로써 요구 사항 도전에 간단하게 해결할 수 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n다양한 요구 분석 모델은 사용자 클래스를 식별하는 데 도움을 줄 수 있습니다. 컨텍스트 다이어그램에서 시스템 외부에 표시된 외부 엔터티는 사용자 클래스의 후보입니다. 기업 조직도는 잠재적 사용자와 다른 이해관계자를 발견하는 데 도움이 될 수 있습니다. 가상의 제약회사를 위한 일부 조직도가 있는 도표 2를 보여드립니다. 시스템의 대부분의 잠재적 사용자는 그러한 조직도 어딘가에 있을 확률이 높습니다. 이해관계자 및 사용자 분석을 수행하는 동안 조직도를 조사하여 다음을 찾아보세요:\n\n- 비즈니스 프로세스에 참여하는 부서.\n- 비즈니스 프로세스에 영향을 받는 부서.\n- 직접 또는 간접 사용자를 찾을 수 있는 부서 또는 역할 이름.\n- 여러 부서를 거쳐 사용자 클래스.\n- 회사 외부의 외부 이해관계자와 상호 작용할 수 있는 부서.\n\n조직도 분석을 통해 중요한 사용자 클래스를 놓치지 않을 확률이 줄어듭니다. 잠재적 사용자 대표를 발견할 수 있는 장소와 핵심 요구사항 결정자를 확인해 줍니다. 단일 부서 내에 다양한 요구를 가진 여러 사용자 클래스를 발견할 수도 있습니다. 반대로, 여러 부서에서 동일한 사용자 클래스를 인식하는 것은 요구 사항 수집을 단순화할 수 있습니다. 또한, 각 부서의 사용자가 관점에 따라 제공할 수있는 정보 유형을 생각해 보세요.\n\n<div class=\"content-ad\"></div>\n\n요구 사항 명세서, 도구 또는 계획에 사용자 클래스 및 특성 및 책임을 문서화하십시오. 각 사용자 클래스에 대한 모든 관련 정보를 포함하십시오. (예: 크기 및 선호되는 클래스). 이는 향후 변경 요청을 우선 순위로 지정하고 영향 평가를 수행하는 팀을 도울 것입니다. 거래량을 추정함으로써 테스터가 제품의 사용 프로필을 개발하고 검증 활동을 계획하는 데 도움이 됩니다.\n\n표 1은 화학 물질 추적 정보 시스템의 샘플 사용자 클래스 문서 일부를 나타냅니다. 여러 응용 프로그램에서 반복되는 사용자 클래스의 재사용 가능 카탈로그를 작성하는 것을 고려하십시오.\n\n저는 실제 화학 물질 추적 시스템 프로젝트에서 비즈니스 분석 노력을 주도했습니다. 화학가 사용자 클래스는 우리의 이해 관계자 그룹 중에서 가장 큰 그룹이었습니다. 모든 화학가들은 시스템에 대한 많은 요구 사항을 공통으로 가지고 있지만, 우리는 몇 가지 전문 요구 사항을 갖고 있는 화학가 하위 그룹이 있음을 깨달았습니다. 우리는 이러한 하위 그룹의 화학가 사용자 대표팀을 구성하여 전체 화학가 사용자 클래스에 대한 요구 사항을 잘 끌어내기 위해 노력했습니다.\n\n<div class=\"content-ad\"></div>\n\n사용자 클래스 분석은 시간이 소요되지만, 가능한 많은 이해관계자를 만족시키며 성공적인 제품 개발 노력을 위한 기초를 마련하는 중요한 단계입니다.\n\n이 글은 Karl Wiegers와 Joy Beatty의 『Software Requirements, 3rd Edition』에서 적용된 것입니다. Karl은 Process Impact의 주요 컨설턴트입니다. 또한 Candase Hokanson과 함께 쓴 『Software Requirements Essentials』, 『Software Development Pearls』, 『The Thoughtless Design of Everyday Things』 및 『Successful Business Analysis Consulting』을 포함한 여러 책의 저자입니다.","ogImage":{"url":"/assets/img/2024-06-19-WhoAreYourUsers_0.png"},"coverImage":"/assets/img/2024-06-19-WhoAreYourUsers_0.png","tag":["Tech"],"readingTime":6},{"title":"리액트 코드가 몬스터가 되지 않도록  2024년 핵심 위생 관행","description":"","date":"2024-06-19 11:25","slug":"2024-06-19-ReactDontLetYourCodeBecomeaMonsterEssentialHygienePracticesin2024","content":"\n\n\n리액트를 처음 사용해본 지 오랜 시간이 지났어요. 제가 jQuery, Knockout, Angular 등의 경험을 토대로 이 라이브러리가 혁명적이라는 것을 빨리 깨달았죠.\n\n20개 이상의 중간 및 대형 프로젝트를 완료한 지금, 2024년 6월부터 시작하는 새로운 프로젝트에 대한 이상적인 도구와 관행에 대한 생각을 공유하고 싶어요.\n\n[노트 1]\n이 스택에서는 Next.js와 같은 전체 프레임워크를 사용하지 않는 것을 선호한다고 가정해요.\n\n자세히 알아보도록 할까요?\n\n<div class=\"content-ad\"></div>\n\n## 시작점\n\n- **Vite**: 놀랍도록 빠른 HMR과 고도로 최적화된 프로덕션 번들을 제공합니다. React와 TypeScript 템플릿을 선택할 수 있는 훌륭한 부트스트랩 유틸리티가 있어서 모든 것이 그대로 작동합니다.\n- **TypeScript**: 2024년에는 모두 TypeScript를 사용할 거라고 기대합니다. 이 연구에서는 Microsoft가 정적 유형 시스템이 성숙한 실제 코드 베이스의 15%의 공개적인 버그를 방지할 수 있었을 것이라고 밝혀졌습니다. 또한, Airbnb 엔지니어는 이 컨퍼런스에서 TypeScript로 38%의 버그를 방지할 수 있었을 것이라고 말했습니다 (사후 분석에 따르면).\n\n## 디자인을 아름답게 만들기\n\n여기에는 많은 대안이 있습니다. 저는 Tailwind를 사용하여 자체 UI 컴포넌트를 만드는 것을 선호합니다. 특정 컴포넌트를 위해 몇 가지 라이브러리의 도움을 받습니다. 이 방법은 예를 들어 Material-UI를 사용하는 것보다 훨씬 작은 번들 크기를 갖는다는 것을 발견했습니다. 또한, 세부 사항을 통제할 수 있습니다. 단점은 UI 컴포넌트를 테스트하는 데 더 많은 시간이 걸릴 수 있지만, 다른 큰 라이브러리를 배우는 필요성을 피할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- Tailwind CSS: 원래 쉬운, 깔끔하고 가장 좋은 문서 중 하나를 가진 원자적 CSS 클래스입니다.\n- HeadlessUI: 더 복잡한 UI에 대해선 몇 가지 스타일이 없는 구성 요소를 사용하는 것을 선호합니다. Tailwind 크리에이터들이 만든 아름답고 아주 잘 테스트된 라이브러리입니다. 사용한 멋진 구성 요소로는 Dialogs, Transitions, Combobox 및 Dropdown Menu가 있습니다.\n- 선택 사항: Classnames: 조건에 따라 CSS 클래스를 결합하는 작은 라이브러리입니다.\n- 선택 사항: Storybook: UI 구성 요소를 격리하고 테스트하기 위해 사용하며 설치 중이라면 설명이 필요 없을 것입니다.\n\n## 행동을 위한 라이브러리\n\n선택은 어렵지만, 커뮤니티의 많은 부분에서 받아들여지고 오랫동안 사용된 라이브러리를 선택하겠습니다.\n\n- Forms: react-hook-form은 여기서 명백한 리더입니다. 중첩된 구성 요소에서 입력을 추적하고 프롭드릴링을 피하기 위한 FormContext 기능이 정말 마음에 듭니다.\n- Routing: react-router (아마도 react-router-dom만 설치하면 될 것입니다). 설명이 필요 없을 정도로 좋은 것입니다.\n- API Queries: react-query는 다시 시도, 캐시 및 조건부 쿼리(“enabled” 파라미터 사용)와 같은 매우 멋진 기능이 많습니다. 잘 활용하면 응답을 처리하기 위해 useFetch 훅(React 문서에서 비권장)이 필요하지 않을 것입니다. 여기 TKDodo의 블로그에 특별 언급을 드리며, 실용적인 일반적인 사례를 설명하고 있습니다(지금은 유지자입니다).\n- 상태 관리: Zustand가 Redux보다 우수하다고 설명하는 것을 보여주세요:\n\n<div class=\"content-ad\"></div>\n\n저에게는 충분해요. 오랫동안 Redux는 괜찮았어요. 말 그대로, Redux가 없었다면 이러한 새로운 도구들도 존재하지 않았을 거에요. 그렇지만 지금은 더 나은 개발자 경험을 제공하는 도구들로 같은 가능성을 가질 수 있어요.\n\n## 테스트\n\n- 단위 테스트: 위대한 Kent Dodds가 만든 react-testing-library은 사용자가 상호작용하는 방식과 동일하게 컴포넌트를 렌더링하고 테스트할 수 있어요.\n- 테스트 러너: Vitest은 Jest와 완벽하게 호환되지만 훨씬 더 빨라요. Vite 프로젝트와 아주 잘 맞아요.\n- E2E 테스트: Playwright는 Cypress보다 빠르답니다. 자체 크로미엄 버전을 만들어 브라우저 테스트를 초고속으로 최적화했어요. 어떤 것이 더 나은 UI나 문서를 가지고 있는지 결정하기 어려워요. 이러한 e2e 테스트는 매우 안정적이라고 생각해요. Playwright는 또한 API 요청을위한 모의 전략을 제공해요.\n\n## 코드 품질 도구\n\n<div class=\"content-ad\"></div>\n\n- ESLint/Prettier: 이 도구들이 정말 유용하다는 것을 발견했습니다. 좋고 명확한 린트 도구가 없는 언어로 전환할 때 그들이 그리워집니다. 코드를 더 멋지게 표시하는 것을 넘어, 수많은 오류를 방지할 수 있습니다. 저에게는 필수입니다.\n- 선택 사항: Husky: 커밋마다 일부 린팅을 실행하는 것이 멋집니다\n- 선택 사항: Commitlint: 메시지 규칙\n\n## 코드 품질 관행\n\n- React 오류 및 경고를 신속하게 인식하고 고치세요: 그들을 무시하면 앱이 언젠가는 충돌합니다. 빨리 수정하는 것이 좋으므로 콘솔에서 무슨 일이 일어나는지 주의하세요. 또한 해결책을 Google에서만 찾지 말고 학습 기회를 활용하세요.\n- 컴포넌트를 작게 유지하세요: React는 코드를 컴포넌트화하는 것을 가능하게 하는 프레임워크입니다. 이를 활용하세요! 제 경험상 이상적인 컴포넌트 크기는 200줄 미만입니다. 300줄인 컴포넌트는 특별한 경우에만 허용됩니다. 그 이상은 큰 컴포넌트로 간주됩니다.\n큰 컴포넌트는 읽기, 리팩터링, 테스트하기 어렵습니다. 컴포넌트 크기가 그 크기를 초과하면, 두 개 이상의 컴포넌트로 리팩터링하고 사용자 정의 훅을 사용하세요.\n- 지속적 통합(CI)을 설정하여 푸시할 때마다 테스트를 실행하세요\n- 트렁크 기반 개발을 구현하고 브랜치 지옥을 피하세요\n\n## 개발자 경험\n\n<div class=\"content-ad\"></div>\n\n- 절대 경로 임포트: 우리는 \"../../../utils\" 대신에 \"@utils\"를 쓰는 것이 더 좋다고 인정합시다.\n- kebab-case 파일 이름: 만약 당신이나 여러분의 팀원 중 일부가 다른 OS에서 작업한다면, 문제가 발생할 수 있습니다. 맥은 대소문자를 무시하지만, 윈도우와 리눅스는 그렇지 않기 때문입니다.\n\n![이미지](/assets/img/2024-06-19-ReactDontLetYourCodeBecomeaMonsterEssentialHygienePracticesin2024_0.png)\n\n- npm, pnpm, bun, 그리고 yarn에 대해: 각각이 좋은 대안이 될 수 있습니다. 그러나, pnpm과 bun이 호환성 문제를 겪을 수 있다는 것을 발견했고, 반면에 yarn이 npm보다 속도가 빠른 경우가 많습니다. 그래서 나는 yarn을 선택할 것입니다.\n- VS Code & 스니펫: 많은 코드 에디터를 사용해봤지만, 단언컨대 승자는 VS Code입니다. 모든 OS와 매우 호환성이 뛰어나며, 아주 아주 빠릅니다. 멋진 UI를 가졌으며, 커스터마이징 기능이 훌륭합니다. 오토세이브 시 어떤 작업을 수행할지 구성하는 것이 정말 대단합니다. 나는 린팅 및 임포트 정리를 선호합니다. 스니펫에 대해, 나는 TypeScript React 컴포넌트를 만들기 위한 사용자 정의 스니펫과 Custom Hooks를 위한 다른 하나를 가지고 있습니다.\n가장 좋아하는 확장 프로그램 중 일부는 ESLint, Prettier, Tailwind CSS, GitLens, Vitest, React Refactor, Error Lens입니다.\n- 스크럼: 아마도, 다음 스토리는 스크럼에 관한 것일 것입니다. 제가 몇 년 경험 중 본 좋고 나쁜 실천법에 대해 이야기하고 싶습니다. 그러나 대부분의 프로젝트에서 동작하는 몇 가지 방법에 대해 말씀드릴 것입니다:\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n이 React 스택은 개발자 행복과 빠른 앱, 그리고 깔끔함을 중요시합니다. Vite는 빠르고 TypeScript는 코드를 견고하게 유지하며, Tailwind CSS는 쉽게 스타일을 입힐 수 있고, Zustand는 어플리케이션 상태를 예측할 수 있는 방법을 제공합니다. 하지만 당신이 선택하는 개발 방법이 정말 중요합니다. 이것들이 성공적인 프로젝트와 평범한 프로젝트를 구분짓는 요소가 될 것입니다.\n그리고 기억하세요, 이것들은 일부 제안일 뿐입니다! 최고의 도구는 당신이 무엇을 구축하느냐에 따라 다릅니다. 그래서 자신을 가장 멋지게 느끼게 하는 것을 선택하세요.\n\n내가 알아야할 다른 라이브러리나 방법을 사용하고 있나요?\n\n당신의 의견을 듣고 있어요.\n\n더 알고 싶으세요? 도와줄 필요가 있으세요? 문의해주세요!\nwww.quadiontech.com","ogImage":{"url":"/assets/img/2024-06-19-ReactDontLetYourCodeBecomeaMonsterEssentialHygienePracticesin2024_0.png"},"coverImage":"/assets/img/2024-06-19-ReactDontLetYourCodeBecomeaMonsterEssentialHygienePracticesin2024_0.png","tag":["Tech"],"readingTime":5},{"title":"4가지 방법으로 플러터에서 널 체크  연산자를 피하는 방법","description":"","date":"2024-06-19 11:24","slug":"2024-06-19-4WaystoAvoidTheNullCheckOperatorOnFlutter","content":"\n\n\n![4 Ways to Avoid the Null Check Operator on Flutter](/assets/img/2024-06-19-4WaystoAvoidTheNullCheckOperatorOnFlutter_0.png)\n\n널 체크 연산자는 컴파일러에게, 널일 수 있는 변수가 실제로 널이 아님을 알려주는 연산자입니다. 이것은 변수 뒤에 느낌표를 붙여서 수행됩니다. 예를 들어, 아래 코드는 (!) 없이 실행시 오류를 발생시킵니다:\n\n```js\nString getString() {\n  final String? nullableString = null;\n\n  return nullableString!;\n}\n```\n\n이는 기본적으로 \"믿어봐, 안전해!\"라고 컴파일러에 말하며, 코드의 오류를 평가하는 린터가(위의 예제에서는 널이 아닌 함수에서 널이 가능한 문자열을 반환하는 부분) 오류를 발생시키는 것을 방지합니다.\n\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-4WaystoAvoidTheNullCheckOperatorOnFlutter_1.png)\n\n문제에서 쉽게 벗어나는 방법입니다. 기본적으로 널 병합 연산자가 하는 일은 연산의 왼쪽 부분을 확인합니다. 만약 왼쪽 부분이 널이 아니라면 그 값을 사용하고, 그렇지 않다면 대신 오른쪽 부분을 사용합니다. 반환 값인 nullableString ?? “”은 다음과 같이 해석할 수 있습니다:\n\n```js\nif(nullableString != null) {\n  return nullableString;\n}\nelse {\n  return \"\";\n}\n```\n\n## 전략 2: 선택적 체이닝 (?.)과 널 병합 (??) 사용하기\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-4WaystoAvoidTheNullCheckOperatorOnFlutter_2.png)\n\n옵셔널 체이닝 연산자는 오브젝트가 널일 수 있는 상황에서 유용합니다. nullableString?.contains(\"haha\") ?? false 코드는 다음과 같이 해석할 수 있습니다:\n\n```js\nbool value = false;\nif(nullableString != null) {\n  value = nullableString.contains(\"haha\");\n}\n```\n\n또한 이 연산자를 사용하여 조건부로 작업을 호출할 수도 있습니다. 예를 들어 API에서 가져온 널 가능한 데이터 페쳐가 있다면 다음과 같이 호출할 수 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\ndataFetcher?.getData();\n```\n\n대신에:\n\n```js\ndataFetcher != null ? dataFetcher.getData() : undefined;\n```\n\n## 전략 3: 삼항 연산자(?) 사용하기\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-4WaystoAvoidTheNullCheckOperatorOnFlutter_3.png\" />\n\n만약 삼항 연산자에 대해 익숙하지 않다면, 다음과 같이 사용됩니다\n\n```js\ncondition ? valueIfTrue : valueIfFalse\n```\n\n기본적으로 우리는 사용할 값을 결정하기 위해 미리 조건을 평가합니다. 그러나 긴 메소드에 대해 삼항 연산자를 사용하면 코드가 지저분해 보일 수 있으니 조심하세요, 예를 들어:\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-4WaystoAvoidTheNullCheckOperatorOnFlutter_4.png)\n\n그래서 제 시니어로부터 받은 피드백을 기반으로, 긴 삼항 연산 대신 간단한 if-else 문을 사용하는 것이 더 나은 것 같아요. 그들의 규칙은 한 줄이라면 삼항 연산을 사용하는 것이라고 합니다. 저도 그것에 동의합니다.\n\n## 전략 4: 배열에 조건 스프레딩(…?) 사용하기 \n\n![image](/assets/img/2024-06-19-4WaystoAvoidTheNullCheckOperatorOnFlutter_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n오늘 이것을 배웠어요. 기본적으로, 우리는 조건부로 목록을 퍼뜨릴 수 있어요. 퍼뜨리기는 한 목록의 모든 값을 다른 목록으로 복사하는 거예요. 이건 배열을 결합하는 데 유용합니다. 위의 코드가 제안한 대로, 조합하는 데 유용한 방법이죠. 만약 배열이 널일 경우 문제가 생길 수 있는데, 그 때는 느낌표(!)를 사용하지 않으면 퍼뜨릴 수 없을 것 같아요. 다행히도 우리에게 조건부 퍼뜨리기는 있어요. 배열이 널이면 아무것도 전달되지 않아요.\n\n코드 [...?item1, ...?item2]은 다음과 같습니다:\n```js\nfinal list = [];\nlist.add(item1);\nlist.add(item2);\n``` \n\n또는, 멋있게 하고 싶다면:\n\n<div class=\"content-ad\"></div>\n\n```js\n[]..add(item1)..add(item2);\n```\n\n이상입니다. 읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-19-4WaystoAvoidTheNullCheckOperatorOnFlutter_0.png"},"coverImage":"/assets/img/2024-06-19-4WaystoAvoidTheNullCheckOperatorOnFlutter_0.png","tag":["Tech"],"readingTime":3},{"title":"뷰모델이 데이터를 구성 변경만 유지하는 이유에 대해 궁금했던 적이 있나요","description":"","date":"2024-06-19 11:23","slug":"2024-06-19-EverwonderwhyViewModelretaindataonlyforconfigurationchanges","content":"\n\n`<img src=\"/assets/img/2024-06-19-EverwonderwhyViewModelretaindataonlyforconfigurationchanges_0.png\" />`\n\nViewModel이 데이터를 구성 변경으로 유지하지만 활동을 다시 인스턴스화하려고 할 때는 그렇지 않은 이유는 무엇인가요? 공식 문서에 따르면.\n\n`<img src=\"/assets/img/2024-06-19-EverwonderwhyViewModelretaindataonlyforconfigurationchanges_1.png\" />`\n\n여기가 라이프사이클 소유자인 MainActivity입니다.\n\n<div class=\"content-ad\"></div>\n\n회전 또는 구성 변경 전:\n\n![이미지1](/assets/img/2024-06-19-EverwonderwhyViewModelretaindataonlyforconfigurationchanges_2.png)\n\n회전 또는 구성 변경 후:\n\n![이미지2](/assets/img/2024-06-19-EverwonderwhyViewModelretaindataonlyforconfigurationchanges_3.png)\n\n<div class=\"content-ad\"></div>\n\n여기서 활동(소유자)의 인스턴스와 라이프사이클이 회전 후에 변경되는 것을 명확히 볼 수 있습니다.\n\n한편, 같은 활동의 새 인스턴스를 수동으로 생성하여 이 시나리오를 다시 만들어 보려고 했을 때 뷰 모델은 데이터를 유지하지 않습니다.\n\n데이터를 보존하려면 ViewModel이 결정하는 매개변수가 무엇인가요? 그리고 ViewModel은 설정 변경에만 데이터를 유지하고 동일한 활동의 새 인스턴스와 같은 것으로는 새 인스턴스가 아닐 때 데이터를 보존하는 이유가 무엇인가요?\n\nViewModel 코드를 살펴보면 ComponentActivity 생성자 내부의 활동/프래그먼트 수명주기에 대한 Observer가 설정되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-EverwonderwhyViewModelretaindataonlyforconfigurationchanges_4.png)\n\nComponentActivity는 Fragment 및 AppCompactActivity의 상위 클래스입니다. 라이프사이클 콜백이 발생할 때마다 트리거되며 onDestroy() 콜백이 발생하고 구성 변경이 아닌 경우에만 ViewModelStore를 지우게 됩니다.\n\n각 활동/프래그먼트마다 ViewModel 인스턴스를 유지하는 것은 실제로 해결되는 사용 사례가 없는 상태에서 더 많은 메모리를 차지하는 것이 맞다고 생각됩니다. 구성 변경 이상으로 동일한 ViewModel 인스턴스를 사용하고 싶은 사용 사례를 생각해 볼 수 있나요?\n\n![이미지](/assets/img/2024-06-19-EverwonderwhyViewModelretaindataonlyforconfigurationchanges_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n위의 코드를 살펴보면 판단 기준인 isChangingConfigurations()를 알 수 있어요.\n\n글을 읽어주셔서 감사합니다. 무언가를 배우셨다면 추천 부탁드려요. 👏","ogImage":{"url":"/assets/img/2024-06-19-EverwonderwhyViewModelretaindataonlyforconfigurationchanges_0.png"},"coverImage":"/assets/img/2024-06-19-EverwonderwhyViewModelretaindataonlyforconfigurationchanges_0.png","tag":["Tech"],"readingTime":2},{"title":"찰스 프록시 개발자 안내서","description":"","date":"2024-06-19 11:21","slug":"2024-06-19-CharlesProxyDevelopersGuide","content":"\n\n\n![CharlesProxyDevelopersGuide_0](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_0.png)\n\n## 목표\n\n만약 개발자가 반드시 가지고 있거나 배워야 할 필수 개발자 도구를 추천해야 한다면, Charles는 그 중 하나일 것입니다. 특히 모바일 개발자에게는 꼭 필요한 도구로, 당신의 툴킷에 넣어둘 수 있습니다. 저는 개발 경력이 매우 늦은 시점에 이 제품의 진정한 힘을 깨달았습니다. 이전에는 HTTP 네트워크 모니터링 도구로 사용했지만, 분명히 그 이상입니다.\n네, 저는 이 제품을 구매하는 데 전적으로 찬성합니다. 이를 만들어 준 Karl von Randow에게 너무 감사드려야 합니다. 이 최고의 가이드를 만들어 줘서✌️\n\n## 일정\n\n\n<div class=\"content-ad\"></div>\n\n- Charles 설정하기\n- HTTP 트래픽 모니터링\n- 응답 가짜 만들기\n- 중단점 설정\n- 다시 작성\n- 대역폭 제한\n- 반복\n- Charles 문제 해결\n\n## 설정\n\n- 공식 웹사이트에서 Charles 설치 및 녹화 시작 - 상단 빨간 버튼.\n- 그다음 해야 할 일은 맥과 기기(아이폰 또는 안드로이드)에 인증서를 설치하는 것입니다.\n\n🐞 참고: 여기서는 제 핸드폰을 아이폰으로 고려하지만, 안드로이드는 거의 동일한 단계를 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n맥에서 인증서 설치하기 —\n\n찰스 ` 도움말 ` SSL 프록시 ` 인증서 설치 로 이동\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_1.png)\n\n그리고 — '찰스 루트 인증서 저장'을 클릭합니다. *.cer 파일이 나옵니다. 해당 파일을 더블 클릭하여 키체인에 넣어주시면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_2.png)\n\n이제 iPhone에서 인증서를 설치할 시간입니다—\n\n- Charles의 `Help` 메뉴로 이동해 로컬 IP를 확인하고 이 IP를 기억해주세요 😅\n- iPhone을 꺼내어 설정을 열고, Mac이 연결된 동일한 Wi-Fi 네트워크에 연결하세요 — 설정 ` Wi-Fi ` 연결된 Wi-Fi의 (i)를 탭합니다 ` 프록시 구성 ` 수동 선택\n- 서버: 단계-1에서 얻은 동일한 IP 주소\n포트: 8888\n인증: 비활성화\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n- 이후 Mac에서 장치가 프록시되고 있음을 허용하는 경고를 받게 됩니다. 장치를 모니터링할 수 있도록 허용을 선택해 주세요. 그렇지 않을 경우, 장치가 모니터링되지 않습니다.\n- 같은 네트워크에 연결한 후,\n  1. Safari를 열고 - https://chls.pro/ssl 에 접속합니다 (iPhone이 Charles로 프록시될 때 인증서를 설치했는지 확인하세요 ⚠️).\n  2. \"이 웹사이트는 구성 프로필을 다운로드하려고 시도합니다. 이를 허용하시겠습니까?\"와 같은 팝업이 표시됩니다. 일시적으로 허용해주세요. 그런 다음, \"프로필 다운로드됨\" 메시지가 표시됩니다 ✅\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_4.png)\n\n4. 설정으로 이동하여 `일반` - `VPN 및 장치 관리` - `다운로드한 프로필` 에 Charles Proxy Custom Root Certificate가 나타납니다. 해당 인증서를 탭하여 설치해주세요.\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_5.png)\n\n<div class=\"content-ad\"></div>\n\n5. 이제 설치가 성공적으로 완료되었음을 확인할 수 있으며 — 설정 프로필 아래에 있습니다.\n\n6. 마지막 단계가 남았습니다. 설정으로 돌아가기 ` 일반 ` 정보 ` 인증서 신뢰 설정 ` Charles Root Custom Certificate를 켜기(기본적으로 끔)\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_6.png)\n\n7. 마지막으로, Charles 설정이 완료되었습니다 🚀\n\n<div class=\"content-ad\"></div>\n\n## HTTP 트래픽 모니터링\n\n만약 Charles가 설치되어 있다면, 당신은 당신의 디바이스의 네트워크 트래픽을 볼 수 있습니다. 여기서 나는 사파리에서 https://jsonplaceholder.typicode.com/users를 열려고 시도했고, 그러면 트래픽을 트리 형태로 볼 수 있습니다.\n\n한편, Charles 트리에서 https://jsonplaceholder.typicode.com을 마우스 오른쪽 버튼으로 클릭하고 이 호스트 이름에 대한 SSL Proxying을 활성화합니다.\n참고: 이 단계를 수행하지 않으면 귀하의 트래픽 데이터를 읽을 수 없으며, 암호화된 형태로 남게 될 것입니다 — HTTPS SSH/TLS가 문제입니다 ⚠️\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_7.png)\n\n<div class=\"content-ad\"></div>\n\n보시다시피, 개요 탭에는 호스트 이름, DNS 주소, HTTP 응답 코드, HTTP 메소드, 프로토콜 이름 등 메타데이터가 있습니다. 이 메타데이터는 메트릭 계산에 필요한 응답 시간, 지연 시간, 핸드셰이크 타임스탬프 등이 포함되어 있습니다.\n\n다음으로 Request 탭은 요청된 HTTP 데이터를 보여줍니다. 이 요청은 GET 요청이므로 본문은 헤더 및 HTTP 매개변수만 볼 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-CharlesProxyDevelopersGuide_8.png\" />\n\n그리고 Response 탭에는 HTTP 응답 정보가 포함되어 있습니다. 여기에는 헤더, HTTP 본문 및 Raw HTTP 데이터(관심이 있다면)가 포함됩니다. 개인적으로 JSON 텍스트만 필요합니다. 왜냐하면 여기서 HTTP 본문이 예쁘게 출력되기 때문이죠.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-CharlesProxyDevelopersGuide_9.png\" />\n\n## 목 태그\n\n화면보다 마크다운 양식이 더 깔끔하네요.요게 표 형식이니까 마크다운 테이블로 바꿔볼게요.\n\n| 사진 | 설명 |\n|---|---|\n| <img src=\"/assets/img/2024-06-19-CharlesProxyDevelopersGuide_9.png\" /> | 모의 응답 |\n| <img src=\"image_url_here\" /> | 모의 응답 설명 |\t\n\n모의 응답을 하려면 두 가지 방법을 알아야 해요. 요는 로컬 방식과 원격 방식이에요.모바일 앱 개발자인너 니정에서 사용자의 JSON 데이터를 가져오는 중이야 그 데이터는 GET API– (https://jsonplaceholder.typicode.com/users/1) 로부터 가져오는 데이터야. 그런데 이상한 일이 발생할 때를 대비해서 값을 임의로 설정하고 싶어.\n\n<div class=\"content-ad\"></div>\n\n긍정적인 예상되는 응답:\n\n```js\n{\n  \"id\": 1,\n  \"name\": \"Leanne Graham\",\n  \"username\": \"Bret\",\n  \"email\": \"Sincere@april.biz\",\n  \"address\": {\n    \"street\": \"Kulas Light\",\n    \"suite\": \"Apt. 556\",\n    \"city\": \"Gwenborough\",\n    \"zipcode\": \"92998-3874\",\n    \"geo\": {\n      \"lat\": \"-37.3159\",\n      \"lng\": \"81.1496\"\n    }\n  },\n  \"phone\": \"1-770-736-8031 x56442\",\n  \"website\": \"hildegard.org\",\n  \"company\": {\n    \"name\": \"Romaguera-Crona\",\n    \"catchPhrase\": \"Multi-layered client-server neural-net\",\n    \"bs\": \"harness real-time e-markets\"\n  }\n}\n```\n\n이제 이름이 null이고, 주소가 비어 있는 응답을 원한다면 (만약 그런 응답이 클라이언트에 전달되어도 응용프로그램이 정상 작동하는지 확인하기 위해서),\n다음과 같은 JSON을 만들었습니다 —\n\n```js\n{\n  \"id\": 1,\n  \"name\": null,\n  \"username\": \"Bret\",\n  \"email\": \"Sincere@april.biz\",\n  \"address\": {},\n  \"phone\": \"1-770-736-8031 x56442\",\n  \"website\": \"hildegard.org\",\n  \"company\": {\n    \"name\": \"Romaguera-Crona\",\n    \"catchPhrase\": \"Multi-layered client-server neural-net\",\n    \"bs\": \"harness real-time e-markets\"\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n찰스는 당신이 https://jsonplaceholder.typicode.com/users/1의 응답을 모의할 수 있게 해줍니다. \n\n찰스의 `도구` 메뉴에서 `맵 로컬 (Map Local)`을 선택하고, 맵 로컬을 활성화한 후 추가하세요.\n\n또한, 모의하는 동안 *.json 파일 경로를 선택해야 합니다. 이 파일은 진실의 근원이 될 것입니다. 저는 mock_response.json을 만들었습니다. 이 JSON 파일은 서버의 JSON 응답을 덮어쓸 것입니다.\n\n<img src=\"/assets/img/2024년-06월-19일-찰스프록시개발가이드_10.png\" />\n\n<div class=\"content-ad\"></div>\n\n\n![Charles Proxy Developers Guide 11](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_11.png)\n\n이제 https://jsonplaceholder.typicode.com/users/1를 요청하면 실제 서버가 제공하는 대신 모의 JSON 응답을 받게 됩니다. 이것을 보여드릴게요 —\n\n![Charles Proxy Developers Guide 12](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_12.png)\n\n📕 노트: 매우 특이한 API 응답을 재현하고 싶을 때에는 이 Map Local을 사용하여 클라이언트에 제공할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n여기에 대체제가 또 하나 있어요 — Map Remote이라고 해요. 이름에서 알 수 있듯이 API 경로를 다른 API 경로로 라우팅합니다.\n예를 들어, /posts/1을 /users/1 API로 리디렉션하고 싶다고 가정해봅시다. 사용자가 https://jsonplaceholder.typicode.com/posts/1를 요청하려고 할 때, 해당 요청은 https://jsonplaceholder.typicode.com/users/1로 리디렉션됩니다. 제가 일상생활에서 별로 사용하지는 않았지만, 이제 비슷한 상황이 닥치면 어떻게 해야 하는지 알게 되었죠.\n\n찰스 ` Tools ` Map Remote ` Enable ` Add\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_13.png)\n\n## 중단점\n\n<div class=\"content-ad\"></div>\n\n브레이크포인트는 HTTP 요청 또는 응답을 변경하는 데 도움이 되는 도구입니다. 변경이란 헤더, 본문 등을 자유롭게 수정하는 것을 말합니다.\n\n브레이크포인트를 활성화하려면 다음 단계를 따라야 합니다.\n\n1. Charles > Proxy > Breakpoint Settings > Enable Breakpoint > Add\n\n![image](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_14.png)\n\n<div class=\"content-ad\"></div>\n\n여기, 모든 요청과 응답에 대해 jsonplaceholder.typicode.com에 대한 중단점을 추가했습니다. 이것은 마치 인터셉터처럼 작동합니다. HTTP 요청을 만들 때마다 Charles는 HTTP 요청을 변경할 수 있는 요청을 중지할 것입니다.\n\n![Charles Proxy](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_15.png)\n\n여기서는 현재 요청을 변경하지 않을 것이므로 실행을 선택할 것입니다. 곧 다른 중단점 창이 나타날 것이고 여기서 JSON의 사용자 이름을 abhishekRavi로 변경하고 실행을 누를 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_16.png)\n\n네, 이제 마법을 볼 수 있어요. 클라이언트는 값이 abhishekRavi인 사용자로 서버가 될 거예요.\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_17.png)\n\n📕 노트북: HTTP 요청/응답을 수정하기 위해 중단점을 사용할 수 있어요. 헤더, 상태 코드, JSON 본문 또는 아무 것이나 수정할 수 있어요. 자유롭게 할 수 있는 거예요.\n\n<div class=\"content-ad\"></div>\n\n## 다시 쓰기\n\n다시 쓰기는 '브레이크포인트'의 개선된 버전입니다. 다시 쓰기는 미리 정의된 브레이크포인트입니다. 특정 API 엔드포인트의 규칙을 설정할 수 있습니다.\n\nCharles ` 도구 ` 다시 쓰기 ` 활성화 ` 추가 ` 위치 및 작업 생성\n\n<img src=\"/assets/img/2024-06-19-CharlesProxyDevelopersGuide_18.png\" />\n\n<div class=\"content-ad\"></div>\n\n여기, JSONPlaceholder 규칙을 생성했고 원격 위치 또는 API 경로를 언급했어요. 그리고 Body에는 'title'을 't00tle'로 바꾸라고 요청했어요.\n\n헤더 및 Body에서도 동일한 작업을 할 수 있어요. 정규식을 설정할 수 있어요(만약 당신이 신이 가장 좋아하는 아이라면서 정규식을 작성하는 방법을 알고있다면요 😄).\n여기서 HTTP 상태 코드를 200에서 400으로 변경하는 규칙을 설정해봤어요.\n\n📕 노트: 일부 작업을 반복하려면 해당 작업을 위한 규칙을 작성할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n## Throttling\n\n앱 개발자에게 매우 유용한 기능 중 하나입니다. 예를 들어 API의 응답 시간과 대역폭을 테스트하고 앱의 동작을 확인하고 싶을 때 활용할 수 있습니다. 즉, Charles Throttler를 구성하여 응답 시간과 대역폭을 조절할 수 있습니다.\n먼저 Throttler 설정을 구성한 다음 Throttler를 실행하십시오. 저는 항상 56Kbps 모뎀 프리셋을 선택합니다.\n\n찰스 ` Proxy ` Throttler 시작\n\n![image](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_20.png)\n\n<div class=\"content-ad\"></div>\n\n## 반복\n\n안녕하세요! 가끔 실패하는 API가 있어서 해당 API의 부하를 테스트해 보고 싶다면 Charles에는 \"Repeat\"라는 기능이 있습니다. 이 기능을 사용하면 API를 동시에 n번 호출할 수 있어요.\n\nAPI 엔드포인트를 우클릭하고 \"Repeat Advance\"를 선택해보세요 —\n\n![Repeat Advance](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_21.png)\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_22.png)\n\nAlso, you can configure your repeat settings — \n\nSetting Iteration to 100 and Concurrency to 3 means you will send 100 HTTP API requests in batches of 3 requests each time.\n\n📕 Notebook: I mostly use this to perform load tests on the API to check if it responds with 2xx status codes.\n\n\n<div class=\"content-ad\"></div>\n\n## 문제 해결하기\n\n- 찰스 웹사이트로 이동할 때 SSL 인증서를 설치할 수 없음\n\n먼저 iPhone과 Mac이 동일한 Wi-Fi 네트워크에 연결되어 있는지 확인하고 iPhone에서 수동 프록시를 구성했는지 확인해야 합니다. 이 문서의 설정 섹션을 참고하세요.\n둘째, 여전히 프로필을 다운로드할 기회가 없다면 Mac 설정에서 IP 주소를 바꿔야 합니다. `Network Preference` → `Advance` → `TCP/IP` → `Renew DHCP Lease`.\n\n2. 응답이 항상 암호화되어 출력됩니다.\n\n<div class=\"content-ad\"></div>\n\n먼저, 호스트 이름에 대해 SSL 프록시 설정이 활성화되어 있는지 확인해보세요. 트리에서 호스트 이름을 오른쪽 클릭하여 'Enable SSL Proxying' (아직 활성화되지 않은 경우) 또는 'Disable SSL Proxy' (이미 활성화된 경우)로 확인할 수 있습니다. 또는 개요에서 확인할 수도 있어요 —\n\n![이미지](/assets/img/2024-06-19-CharlesProxyDevelopersGuide_23.png)\n\n둘째, 전화 설정에서 '일반' ` VPN 및 장치 관리 'Charles 프로파일 선택' 프로파일 제거를 통해 인증서를 삭제하고 다시 설치할 수 있어요. 그렇죠, 새로 시작해보세요.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n찰스(Charles)는 클라이언트와 서버 사이에 위치하여 HTTP 트래픽을 모니터링하는 프록시 응용 프로그램입니다. 요청과 응답을 필요에 따라 조작할 수 있습니다. 우리가 위에서 논의한 것보다 더 많은 기능이 있습니다. 찰스의 대안으로 Proxyman을 시도해 볼 수도 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-CharlesProxyDevelopersGuide_0.png"},"coverImage":"/assets/img/2024-06-19-CharlesProxyDevelopersGuide_0.png","tag":["Tech"],"readingTime":10}],"page":"24","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}