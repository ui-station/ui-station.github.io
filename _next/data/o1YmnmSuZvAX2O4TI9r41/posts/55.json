{"pageProps":{"posts":[{"title":"자바 함수형 인터페이스를 사용하여 의존성을 역전하는 방법","description":"","date":"2024-05-23 12:43","slug":"2024-05-23-How-toUseJavaFunctionalInterfacestoInvertDependencies","content":"\n\n자바 프로젝트 내에서 의존성을 역전시키기 위해 자바 함수형 인터페이스를 사용해 본 적이 있나요? 이 기사에서는 Supplier, Consumer 및 Function 세 가지 주요 인터페이스를 활용하여 이를 수행하는 방법을 살펴볼 것입니다.\n\n![이미지](/assets/img/2024-05-23-How-toUseJavaFunctionalInterfacestoInvertDependencies_0.png)\n\n## Supplier\n\nSupplier 인터페이스는 입력 매개변수가 필요하지 않은 객체를 제공해야 할 때 사용됩니다. 다음은 Supplier 인터페이스입니다:\n\n<div class=\"content-ad\"></div>\n\n```java\r\npublic interface Supplier<T> {\n   T get();\n}\n```\n\n이 인터페이스를 활용하는 필요성을 더 잘 이해하기 위해 코드 몇 줄을 확인해 봅시다.\n\n```java\npublic class Logger {\n   public void log(String message) {\n      if (isLogEnabled()) {\n         write(message);\n      }\n   }\n}\n\n// Logger 클래스 사용 예시\npublic class Controller {\n   @Inject Logger logger;\n\n   public void execute() {\n      logger.log(generateLogMessage());\n   }\n}\n```\n\n위 코드에서는 로깅이 활성화되어 있을 때 로그 메시지를 작성하는 Logger 클래스가 있습니다. Controller 클래스는 generateLogMessage 메서드의 결과를 전달하여 로거를 호출합니다. 지금까지는 모든 것이 잘 보입니다. 그러나 만약 generateLogMessage 메서드가 많은 처리를 필요로 하거나 상당한 리소스를 소비하며 로깅이 비활성화된 경우를 상상해보세요. 이러한 경우 유용한 리소스가 낭비되며 생성된 로그 메시지가 활용되지 않을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 문제의 해결책은 Logger 클래스에 Supplier를 전달하여 요청 시 메시지를 반환하고, 로거가 로그가 활성화된 경우에만 메서드를 호출하도록 하는 것입니다. 아래와 같이 구현할 수 있습니다:\n\n```js\npublic class Logger{\n   public void log(Supplier<String> messageSupplier){\n      if(isLogEnabled()){\n        write(messageSupplier.get());\n      }\n   }\n}\n\n// Logger 클래스 사용 예제\npublic class Controller{\n   @Inject Logger logger;\n\n   public void execute(){\n      logger.log(() -> generateLogMessage());\n   }\n}\n```\n\n이제 generateLogMessage 메서드는 Supplier의 get 메서드가 호출될 때에만 실행되며, 로그가 비활성화된 경우 자원을 절약할 수 있습니다. 또한 Supplier를 사용한 이러한 솔루션은 로깅을 위한 매우 복잡한 로직을 구현할 유연성을 제공하며 필요할 때에만 호출됨을 보장합니다.\n\n# 기능\n\n<div class=\"content-ad\"></div>\n\nFunction 인터페이스를 사용하면 매개변수를 받아 결과를 생성하는 함수를 정의할 수 있습니다. 아래는 Function 인터페이스입니다 (일부 기본 메서드는 생략됨):\n\n```js\npublic interface Function<T, R>{\n   R apply(T t);\n}\n```\n\nFunction 인터페이스를 탐색하기 시작하려면, 판매 주문에서 품목의 가격을 계산하는 책임을 지는 클래스를 살펴보겠습니다. 이 클래스는 제품, 수량 및 할인 (0에서 100까지 범위)과 같은 입력을 가져옵니다:\n\n```js\npublic class PriceCalculator{\n   public BigDecimal calculatePrice(Product product, \n                                    Integer quantity,\n                                    BigDecimal discount){\n     var grossPrice = product.getUnitPrice()\n                             .multiply(BigDecimal.valueOf(quantity));\n     var discountAmount = grossPrice.multiply(discount)\n                                    .divide(BigDecimal.valueOf(100));\n     return grossPrice.minus(discountAmount);\n   }\n}\n\n// 사용 예시\nvar result = priceCalculator(product, 10, BigDecimal.value(10));\n```\n\n<div class=\"content-ad\"></div>\n\n이 클래스는 초기에 총 가격을 계산하고 할인을 적용한 후 총 가격에서 빼는 작업을 합니다. 이제 새로운 요구 사항을 고려해봅시다: 가격에 통화 변환을 수행해야 합니다.\n\n하나의 접근 방식은 이 클래스에 직접 통화 변환 로직을 추가하는 것일 수 있지만, 이는 버그를 도입할 수 있습니다. 더 견고한 해결책은 통화 변환을 처리하는 함수 매개변수를 추가하는 것입니다.\n\n```js\npublic class PriceCalculator{\n   public BigDecimal calculatePrice(\n                        Product product, \n                        Integer quantity, \n                        BigDecimal discount, \n                        Function<BigDecimal,BigDecimal> converterFunction){\n     var grossPrice = product.getUnitPrice()\n                             .multiply(BigDecimal.valueOf(quantity));\n     var discountAmount = grossPrice.multiply(discount)\n                                    .divide(BigDecimal.valueOf(100));\n     var netPrice = grossPrice.minus(discountAmount);\n     return converterFunction.apply(netPrice);\n   }\n}\n\n// Usage example\nvar result = priceCalculator(product, \n                             10, \n                             BigDecimal.value(10),\n                             netPrice -> netPrice.multiply(CURRENCY_RATE));\n```\n\n새로운 요구 사항의 추가로 인해 최소한의 영향을 받았고, 의존성을 성공적으로 역전시켰습니다. PriceCalculator 클래스는 더 이상 통화 변환을 처리할 필요가 없으며, 대신 제공된 함수를 호출하고 최종 결과를 반환합니다. 이 설계를 통해 PriceCalculator 클래스를 수정하지 않고도 어떤 통화로든 변환할 수 있게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n가격 계산기 클래스를 변경하지 않고 이 요구 사항을 해결하는 다양한 방법이 있습니다. PriceCalculator를 호출하는 퍼사드로 작동하는 또 다른 클래스를 만들어 화폐 변환을 수행할 수 있습니다. 일반적으로 어떤 솔루션을 따를지는 프로젝트 결정입니다.\n\n# 소비자\n\nConsumer 인터페이스를 통해 매개변수를 받아 특정 작업을 수행하고 값을 반환하지 않는 함수를 정의할 수 있습니다. 다음은 Consumer 인터페이스입니다 (일부 기본 메서드는 생략됨):\n\n```js\npublic interface Consumer<T> {\n    void accept(T t);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n소비자 인터페이스의 예제를 살펴보기 위해 이 클래스를 살펴봅시다. 여기에는 엔티티에 일부 정보를 설정한 후 데이터베이스에 저장하는 작업이 포함되어 있습니다:\n\n```java\npublic class EntitySaver{\n   public void create(Entity entity){\n      entity.setCreationDate(new Date());\n      database.insert(entity);\n   }\n}\n\n// 사용 예시\nentitySaver.create(entity);\n```\n\n이제 엔티티가 생성될 때 다른 클래스에 알림을 보내어야 하는 경우를 가정해 봅시다. 그러나 create 메서드 인터페이스를 수정할 수 없는 경우, 소비자 인터페이스를 사용하여 발행-구독 패턴을 구현할 수 있습니다. 다음은 이를 어떻게 달성할 수 있는지에 대한 예시입니다:\n\n```java\npublic class EntitySaver{\n   private List<Consumer<Entity>> consumerList = new ArrayList<>();\n\n   public void register(Consumer<Entity> consumer){\n      consumerList.add(consumer);\n   }\n\n   public void create(Entity entity){\n      entity.setCreationDate(new Date());\n      database.insert(entity);\n      consumerList.forEach(consumer -> consumer.accept(entity));\n   }\n}\n\n// 사용 예시\nentitySaver.register(entity -> log.info(entity));\nentitySaver.register(entity -> mailerService.notifyUser(entity));\nentitySaver.create(entity);\n```\n\n<div class=\"content-ad\"></div>\n\n이 발행-구독 패턴의 구현에서는 Consumer 인터페이스를 활용합니다. EntitySaver 클래스는 이제 Consumer 리스트를 유지하고 등록 메서드를 포함하여 소비자를이 목록에 추가합니다. create 메서드의 인터페이스는 변경되지 않았지만, 만들어진 엔티티를 '소비'하기위한 한 줄의 코드를 도입했습니다.\n\n# 결론\n\nJava 기능 인터페이스는 많은 년 전에 소개되었으며, Java에서 개발을하던 방식에 큰 영향을 미쳤습니다. 우리는 이를 람다 함수로 사용할 수 있지만 의존성을 뒤집고 코드를 더 깔끔하게 만드는 데 사용할 수도 있습니다.","ogImage":{"url":"/assets/img/2024-05-23-How-toUseJavaFunctionalInterfacestoInvertDependencies_0.png"},"coverImage":"/assets/img/2024-05-23-How-toUseJavaFunctionalInterfacestoInvertDependencies_0.png","tag":["Tech"],"readingTime":6},{"title":"제 1장 반응형 프로그래밍 소개","description":"","date":"2024-05-23 12:42","slug":"2024-05-23-Chapter1IntroductiontoReactiveProgramming","content":"\n\n![Chapter 1 Introduction to Reactive Programming](/assets/img/2024-05-23-Chapter1IntroductiontoReactiveProgramming_0.png)\n\nIn the fast-paced world of software development, building applications that are not only responsive but also scalable is crucial. Traditional programming paradigms often struggle to keep up with the demands of modern applications, where users expect real-time responsiveness and seamless user experiences. Introducing reactive programming, a paradigm shift that promises to revolutionize the way we build software.\n\n## Understanding Reactive Programming\n\nReactive programming is not just a buzzword; it’s a fundamental shift in how we approach software development. At its core, reactive programming is about building asynchronous, event-driven, and non-blocking applications. But what exactly does that mean?\n\n\n<div class=\"content-ad\"></div>\n\n아래에서 설명을 해보겠습니다:\n\n## 비동기적이고 논블로킹\n\n전통적인 프로그래밍에서 작업은 순차적으로 실행되어 이전 작업이 완료될 때까지 기다립니다. 이러한 방식은 병목 현상과 성능 저하를 야기할 수 있으며, 특히 높은 동시성을 필요로 하는 애플리케이션에서 문제가 될 수 있습니다.\n\n한편, 반응형 프로그래밍은 작업을 비동기적으로 실행할 수 있도록 해주어 이전 작업이 완료될 때까지 기다릴 필요가 없다는 의미입니다. 이러한 비동기적인 특성은 쓰레드를 차단하지 않고 대량의 동시 요청을 처리할 수 있게 해주어 자원 활용 및 성능을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 이벤트 주도 아키텍처\n\n반응형 시스템에서 구성 요소는 이벤트를 발생시키고 반응함으로써 통신합니다. 이벤트는 사용자 입력부터 데이터 변경 또는 시스템 알림까지 무엇이든 될 수 있습니다. 이 이벤트 주도 아키텍처를 통해 느슨하게 결합되고 매우 확장 가능한 시스템이 가능하며, 구성 요소는 실시간으로 변경에 반응할 수 있습니다.\n\n## 반응형 애플리케이션\n\n반응형 프로그래밍의 주요 목표 중 하나는 사용자 상호작용 및 외부 이벤트에 반응하는 애플리케이션을 구축하는 것입니다. 비동기적으로 작업을 처리하고 신속하게 이벤트에 반응함으로써, 반응형 애플리케이션은 심한 부하 하에서도 원활하고 상호작용적인 사용자 경험을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 반응형 스트림\n\n반응형 프로그래밍은 종종 비동기적으로 처리되며 반응적으로 처리되는 데이터 항목의 시퀀스인 반응형 스트림 개념에 의존합니다. 반응형 스트림은 백프레셔(backpressure)를 처리하기 위한 메커니즘을 제공하며, 소비자가 생산자로부터 데이터를 소비하는 속도를 제어하여 과부하와 리소스 고갈을 방지합니다.\n\n# 반응형 프로그래밍의 장점\n\n이제 반응형 프로그래밍의 기본 개념을 이해했으므로, 이에 대한 주요 이점을 몇 가지 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n- 확장성: 반응형 프로그래밍은 비동기적이고 이벤트 주도적인 특성 덕분에 응용 프로그램이 손쉽게 확장될 수 있습니다.\n- 반응성: 반응형 응용 프로그램은 실시간 피드백과 원할한 경험을 제공하여 사용자에게 높은 반응성을 제공합니다.\n- 탄력성: 비동기적이며 논블로킹 I/O를 채택함으로써, 반응형 응용 프로그램은 장애에 대해 견고하고 에러를 우아하게 처리할 수 있습니다.\n\n# 반응형 프로그래밍의 단점\n\n모든 해결책에는 고유의 도전 과제가 있고, 반응형 프로그래밍 또한 예외는 아닙니다. 이와 함께 따르는 주요한 단점들을 살펴보겠습니다:\n\n- 학습 곡선: 비동기적 프로그래밍 개념을 배우는 것은 강압적 프로그래밍에 익숙한 개발자에게 놀라울 수 있습니다. 비동기적 및 논블로킹 성질을 반응형 시스템에서 파악하는 데 시간과 노력이 필요합니다.\n- 복잡성: 반응형 프로그래밍을 구현하면 코드베이스에 복잡성을 도입할 수 있습니다. 개발자는 비동기식 연산을 이해하고 반응형 스트림을 효과적으로 관리해야 합니다.\n- 디버깅 과제: 비동기적이고 이벤트 주도적인 코드를 디버깅하는 것은 동기화된 코드와 비교해 고유의 도전 과제를 제기합니다. 데이터 흐름을 추적하고 동시성 문제를 진단하기 위해 전문 기술이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nReactive 프로그래밍은 단순히 흘러가는 유행이 아니라 소프트웨어를 구축하는 방식에서 패러다임 변화이며, 오랫동안 유지될 것으로 예상됩니다. 이것이 가지고 있는 도전에도 불구하고, reactive 프로그래밍의 장점은 특히 오늘날 매우 동시성이 높은 응용프로그램 환경에서 그 단점을 능가하는 경우가 많습니다. 비동기적이고 이벤트 주도적인 아키텍처를 채택함으로써, 개발자들은 그 어느 때보다도 더 민첩하고 확장 가능하며 견고한 응용프로그램을 만들 수 있습니다.\n\n이 블로그 포스트에서는 reactive 프로그래밍의 한 부분에 불과합니다. Reactive 스트림부터 고급 오류 처리 전략까지 더 탐구해야 할 부분이 많이 남아 있습니다. 하지만 이 소개가 reactive 프로그래밍에 대해 더 탐구하고 싶게 만들었으면 좋겠습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-Chapter1IntroductiontoReactiveProgramming_0.png"},"coverImage":"/assets/img/2024-05-23-Chapter1IntroductiontoReactiveProgramming_0.png","tag":["Tech"],"readingTime":3},{"title":"자바에서 엔티티를 DTO로 매핑하고 그 반대로하기","description":"","date":"2024-05-23 12:41","slug":"2024-05-23-MappingEntitiestoDTOsandviceversainJava","content":"\n\n![Mapping entities to DTOs in Java](/assets/img/2024-05-23-MappingEntitiestoDTOsandviceversainJava_0.png)\n\nIn Java, entities and DTOs are two different types of classes often used together. Entities are used to represent data in the database, while DTOs are used to represent data that is sent to or received from a client.\n\nTo map data from an entity to a DTO, you need to define a mapping between the attributes of the two classes. This can be done manually or automatically.\n\n## Manual mapping\n\n\n<div class=\"content-ad\"></div>\n\n수동 매핑은 엔티티를 DTO로 매핑하는 가장 간단한 방법입니다. 이 접근 방식에서는 엔티티의 속성에서 DTO의 속성으로 값을 복사하는 코드를 작성합니다.\n\n예를 들어, 다음 코드는 Customer 엔티티의 속성을 CustomerDTO의 속성에 매핑합니다:\n\n```js\npublic CustomerDto toDto(Customer customer) {\n  CustomerDto dto = new CustomerDto();\n  dto.setName(customer.getName());\n  dto.setCpf(customer.getCpf());\n  dto.setDateOfBirth(customer.getDateOfBirth());\n  return dto;\n}\n```\n\n이 방법은 간단하고 유연하지만, 특히 복잡한 엔티티나 많은 매핑이 있는 경우에는 반복적이고 오류가 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 자동 매핑\n\n자동 매핑은 엔티티를 DTO로 매핑하는 더 효율적이고 신뢰할 수 있는 방법입니다. 이 방법을 사용하면 프레임워크나 라이브러리를 사용하여 매핑 코드를 자동으로 생성합니다.\n\n자동 매핑을 위한 인기 있는 라이브러리 중 하나는 MapStruct입니다. MapStruct(https://mapstruct.org/)는 도메인별 언어(Domain-Specific Language, DSL)를 사용하여 매핑 규칙을 정의합니다.\n\n예를 들어, 다음 코드는 Customer 엔티티의 속성을 CustomerDTO의 속성에 매핑하는 매핑 규칙을 정의합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n@Mapper\npublic interface CustomerMapper {\n\n  CustomerDto toDto(Customer customer);\n\n}\n```\n\n위 코드는 Customer 엔티티를 입력으로 받아 CustomerDTO를 출력으로 반환하는 toDto() 메서드를 정의합니다. MapStruct는 이 두 클래스의 속성 간 매핑을 결정하기 위해 메서드의 이름을 사용합니다.\n\nMapStruct는 DTO에서 엔티티로 값들을 매핑하는 데에도 사용할 수 있습니다. 예를 들어, 다음 코드는 CustomerDTO의 속성들을 Customer의 속성들과 매핑하기 위한 매핑 규칙을 정의합니다:\n\n```js\n@Mapper\npublic interface CustomerMapper {\n\n  Customer fromDto(CustomerDto dto);\n\n}\n```\n\n<div class=\"content-ad\"></div>\n\nModelMapper라고 하는 강력한 라이브러리도 있어요. 이 라이브러리는 객체 매핑 프로세스를 간단하게 해주며 매핑 동작을 사용자 정의하는 데 많은 유연성을 제공해요.\n\nJava 프로젝트에서 ModelMapper를 사용하려면 프로젝트에 ModelMapper 라이브러리를 추가해야 해요. 만약 Maven을 사용 중이라면 다음 종속성을 프로젝트의 pom.xml 파일에 추가하세요:\n\n```js\n<dependency>\n  <groupId>org.modelmapper</groupId>\n  <artifactId>modelmapper</artifactId>\n  <version>2.4.2</version>\n</dependency>\n```\n\n만약 Gradle을 사용 중이라면 build.gradle 파일에 다음을 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n\nimplementation 'org.modelmapper:modelmapper:2.4.2'\n\n\n프로젝트에 ModelMapper 라이브러리를 추가한 후, 서로 다른 구조를 갖는 두 개의 객체 간에 매핑을 시작할 수 있습니다.\n\n예를 들어, 서로 다른 구조를 갖는 두 개의 객체가 있고, 이들 사이의 데이터를 매핑하려고 한다고 가정해봅시다. 아래는 예시입니다:\n\n```java\npublic class User {\n    private String name;\n    private int age;\n\n    // 생성자, 게터, 세터 메서드\n}\n\npublic class UserDTO {\n    private String fullName;\n    private int userAge;\n\n    // 생성자, 게터, 세터 메서드\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        User user = new User(\"John\", 30);\n        ModelMapper modelMapper = new ModelMapper();\n        UserDTO userDTO = modelMapper.map(user, UserDTO.class);\n        System.out.println(userDTO.getFullName()); // 출력: John\n        System.out.println(userDTO.getUserAge()); // 출력: 30\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예에서는 User 및 UserDTO라는 두 개의 다른 구조를 갖는 두 개의 객체가 있습니다. User 객체에는 이름(name)과 나이(age) 필드가 있고, UserDTO 객체에는 풀 네임(fullName)과 사용자 나이(userAge) 필드가 있습니다. User 객체를 UserDTO로 매핑하기 위해 ModelMapper 인스턴스를 사용합니다. map() 메서드는 소스 객체와 대상 객체 클래스 두 가지 인수를 사용합니다.\n\nmain 메서드를 실행하면 출력으로 John과 30이 나오는데, 이는 매핑이 성공적으로 수행되었음을 나타냅니다.\n\nModelMapper를 사용하고 사용자화하는 방법에 대한 자세한 안내를 원하시면 다음 기사를 참고하십시오: [링크](http://bit.ly/4b4b5sz)\n\n# 따라서, 어떤 접근 방식을 선택해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n엔티티를 DTO로 매핑하는 가장 좋은 방법은 여러 요소에 따라 다릅니다. 일반적으로, 간단한 클래스나 매핑이 적은 경우 수동 매핑이 좋은 선택이 됩니다. 복잡한 클래스나 많은 매핑이 필요한 경우 자동 매핑이 좋은 선택입니다.\n\n다음은 접근 방식을 선택할 때 고려해야 할 사항입니다:\n\n- 관련된 클래스의 복잡성: 많은 속성을 가진 복잡한 클래스는 수동 매핑이 반복적이고 오류를 발생하기 쉽게 만들 수 있습니다. 이러한 클래스에 대해 자동 매핑이 좋은 선택일 수 있습니다.\n- 필요한 매핑의 양: 많은 매핑이 필요한 클래스는 수동 매핑을 유지하기 어렵게 만들 수 있습니다. 이러한 클래스에 대해 자동 매핑이 좋은 선택일 수 있습니다.\n- 사용자 정의 필요성: 수동 매핑을 통해 필요에 맞게 매핑을 사용자 정의할 수 있습니다. 자동 매핑은 더 제한적일 수 있습니다.\n\n최종적으로, 엔티티를 DTO로 매핑하는 가장 좋은 방법은 애플리케이션의 특정 요구사항을 충족시키는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n## 추가 고려 사항\n\n위에서 언급된 요소들 외에도, 엔티티들을 DTO에 매핑할 때 고려해야 할 몇 가지 사항이 있습니다:\n\n- 데이터 유형: 두 클래스의 속성들의 데이터 유형이 호환되는지 확인하세요.\n- Null 값: Null 값을 어떻게 처리할지 고려해보세요.\n- 컬렉션: 두 클래스 중 하나가 속성의 컬렉션을 포함하고 있다면, 컬렉션 내 각 요소에 대한 매핑을 정의해야 합니다.\n\n이러한 사항들을 따르면, 매핑 코드가 정확하고 효율적임을 보장할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\nMapStruct와 ModelMapper는 Java 프로젝트에서 엔티티를 DTO로 매핑하거나 그 반대로 하는 데 편리하고 효율적인 솔루션을 제공합니다. 이러한 라이브러리를 도입함으로써 개발자는 보일러플레이트 코드를 크게 줄이고 코드 유지 보수성을 향상시키며 타입 안정성을 보장할 수 있습니다. MapStruct 또는 ModelMapper를 프로젝트에 통합하면 매핑 프로세스를 간소화하여 견고하고 확장 가능한 애플리케이션을 구축하는 데 집중할 수 있습니다.\n\n즐거운 코딩 ;)\n\n아래 기사들도 참고해보세요\n","ogImage":{"url":"/assets/img/2024-05-23-MappingEntitiestoDTOsandviceversainJava_0.png"},"coverImage":"/assets/img/2024-05-23-MappingEntitiestoDTOsandviceversainJava_0.png","tag":["Tech"],"readingTime":5},{"title":"자바 스레드 로컬Thread Locals은 어떻게 동작하나요","description":"","date":"2024-05-23 12:39","slug":"2024-05-23-HowdoJavaThreadLocalswork","content":"\n\n<img src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png\" />\n\n자바에서 쓰레드 로컬(Thread Locals)은 전체 쓰레드 범위를 가지는 변수입니다. 이 말은 쓰레드 어디서든지 이러한 변수를 설정하고, 동일한 쓰레드에서는 어디서든지 액세스할 수 있다는 것을 의미합니다. 한 쓰레드에서 설정된 값은 다른 쓰레드에서 접근할 수 없습니다.\n\n자바 ThreadLocal 클래스에는 두 가지 유형이 있음을 알아야 합니다 — ThreadLocal 및 InheritableThreadLocal. 두 클래스 간의 차이를 살펴봅시다.\n\n# ThreadLocal 클래스\n\n<div class=\"content-ad\"></div>\n\n아래는 쓰레드 로컬 변수가 선언된 예시입니다. user 변수는 User 타입(Class 또는 Interface)의 변수를 보유하는 ThreadLocal 변수입니다. 여기서 user 변수가 public 및 static으로 선언되어 어디서든 코드 내에서 접근할 수 있도록 설정되었습니다.\n\n```js\n// Declare a Thread Local Variable user\npublic static final ThreadLocal<User> user \n                     = new ThreadLocal<>();\n```\n\n아래는 쓰레드를 위해 user를 설정하고 가져오는 방법입니다. 예시에서는 'bob'으로 설정된 User 객체에 user 변수를 설정하고, 동일한 쓰레드 내에서 get() 메소드를 호출하면 User 'bob'이 검색됩니다.\n\n```js\n// Sets the calling thread’s value for user\nuser.set(new User(\"bob\"));\n\n// Gets the calling thread’s value for user\nUser requestUser = user.get();\n```\n\n<div class=\"content-ad\"></div>\n\n사용자 변수가 코드베이스 전체에서 접근 가능하더라도 set(..) 메서드는 전달된 User 객체가 \"호출\" 스레드와 연관되도록 합니다. get() 메서드는 또한 \"호출\" 스레드와 연관된 User 객체를 검색하며, 다른 스레드에서 get() 메서드를 호출하더라도 bob이 아니라 다른 사용자(또는 null)를 검색하지 않습니다. 각 Java 스레드는 해당 스레드에 설정된 모든 스레드 로컬을 포함하는 ThreadLocal Map과 연결됩니다.\n\n만약 아무것도 설정되지 않은 경우 get() 메서드를 호출하면 어떻게 될까요? 이 메서드는 단순히 null을 반환합니다.\n\n그러나 람다 공급자로 초기 User 객체를 반환하는 Thread Local 객체를 생성할 수 있습니다. 아래 예제는 'anonymous'라는 User를 반환하는 공급자를 보여줍니다. 따라서 값이 설정되지 않은 ThreadLocal에 get() 메서드를 호출하면 이전에 값을 설정하지 않았을 때 공급자의 get() 메서드가 호출되며 사용자의 초기 값으로 설정됩니다.\n\n```js\n// 공급자와 함께 Thread Local 변수 user를 선언\npublic static ThreadLocal<User> user \n          = ThreadLocal.withInitial(\n                () -> new User(\"anonymous\"))\n\n// 'Anonymous'를 반환\nUser requestUser = user.get();\n```\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 remove() 메서드를 호출하여 이전에 설정된 값을 제거할 수도 있습니다.\n\n```js\n// 호출 스레드의 사용자 값 제거\nuser.remove();\n```\n\n이 방법은 기본적으로 스레드와 관련된 User 객체를 제거합니다. 더 중요한 것은 이 작업으로 다른 스레드에는 영향을 미치지 않는다는 점입니다.\n\n스레드 로컬을 다이어그램 형식으로 시각화한다면(저는 이것을 좋아합니다), 다음과 같이 보일 것입니다. 두 스레드의 사용자 변수가 서로 다른 User 객체를 가리키는 것을 알 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_1.png\" />\n\n# ThreadLocal 및 자식 스레드\n\n이전 섹션까지의 논의는 주로 한 개의 Java 스레드와 관련되어 있었습니다. 만약 Java 스레드가 새로운 자식 스레드를 시작한다면 어떻게 될까요? 자식 스레드가 부모에서 정의된 Thread Local 변수에 자동으로 액세스할 수 있을까요?\n\n답은 \"아니요\"입니다! 자식 스레드는 부모의 Thread Local에 액세스할 수 없으며 이에 대한 매우 좋은 이유가 있습니다. 만약 액세스 가능하다면, Thread Local 변수에 저장된 객체는 스레드 안전하게 작성되어야 할 것이며 이렇게 되면 여러 스레드가 동일한 사용자 객체에 액세스할 수 있을 것입니다. 이는 Java 엔지니어들에 의한 좋은 기본 디자인 결정입니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 때로는 그런 액세스가 유용할 때가 있습니다. 많은 사용자가 애플리케이션에 액세스하는 웹 애플리케이션과 같은 시나리오를 상상해보십시오. 요청 처리 중 사용자와 연결된 단일 Java 스레드가 있으며, 이 스레드의 Thread Local 객체에 사용자 객체가 저장되어 있다고 상상할 수 있습니다(이는 많은 응용 프로그램 서버 및 Spring Boot와 같은 프레임워크에서 수행됩니다). 그러나 생성된 자식 스레드도이 사용자 정보에 액세스하길 원할 수 있습니다.\n\n이 시나리오에 대해 Java는 InheritableThreadLocal이라는 다른 클래스를 제공합니다.\n\n# InheritableThreadLocal 클래스\n\n이 클래스를 사용하는 구문은 사실상 ThreadLocal 클래스와 거의 동일합니다. 아래 예제에서는 InheritableThreadLocal 클래스에 대한 해당 메서드를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n```java\n// 상속 가능한 쓰레드 로컬 변수 user를 선언합니다\npublic static final InheritableThreadLocal<User> user = new InheritableThreadLocal<>();\n\n// 호출 중인 쓰레드의 user 값을 설정합니다\nuser.set(new User(\"bob\"));\n\n// 호출 중인 쓰레드의 user 값을 가져옵니다\nUser requestUser = user.get();\n\n// 호출 중인 쓰레드의 user 값을 제거합니다\nuser.remove();\n```\n\n쓰레드 로컬 맵과 마찬가지로, 모든 쓰레드에는 상속 가능한 쓰레드 로컬 변수를 위한 맵이 있습니다. 여기서 큰 차이점은 자식 쓰레드가 생성될 때, 자식의 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된다는 것입니다. 따라서, 상속 가능한 쓰레드 로컬 변수는 자식 쓰레드에서도 접근할 수 있습니다.\n\n만약 상속 가능한 쓰레드 로컬 변수를 다이어그램 형태로 시각화한다면, 다음과 같이 보일 것입니다. 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된 것을 볼 수 있습니다.\n\n<img src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_2.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n# 함정에 유의하세요!\n\n위 다이어그램에서 명확히 볼 수 있듯이, 상속 가능한 쓰레드 로컬 변수의 장점은 단점이 될 수도 있습니다. 기본적으로, 자식 쓰레드가 생성될 때 상속 가능한 쓰레드 로컬 맵도 복제됩니다. 그러나 부모와 자식 쓰레드에서 동일한 \"User\" 객체를 가리킨다는 것을 알 수 있습니다.\n\n이것은 User 객체가 여러 쓰레드에서 접근될 수 있고 스레드 안전하게 작성되어야 한다는 것을 의미합니다. 다시 말하면 - 단순한 ThreadLocal 클래스와 관련된 스레드 안전성이 InheritableThreadLocal 클래스를 사용할 때는 손실됩니다. 이것은 여러분의 디자인에 완벽히 적합할 수 있습니다 - 이에 문제는 없습니다.\n\n그러나 더 안전한 접근 방식이 있을 수 있습니다. InheritableThreadLocal을 생성할 때 다음과 같이 childValue(..) 메서드를 지정할 수 있습니다. 사실, 아래 예시에서는 초기값과 child 값도 지정합니다.\n\n<div class=\"content-ad\"></div>\n\n```java\npublic static final InheritableThreadLocal<User> user \n                   = new InheritableThreadLocal<>() {\n\n   @Override\n   protected User initialValue() { \n      return new User(\"anonymous\"); \n   }\n\n   @Override\n   protected User childValue(User parentValue) { \n      return new User(parentValue.getId()); \n   }\n};\n```\n\n위 변경 사항을 통해 상속 가능한 스레드 로컬 맵이 복제될 때 자식에 연관된 값은 childValue(..) 메소드를 사용하여 부모 값이 전달되어 설정됩니다. 상속 가능한 스레드 로컬마다 새로운 객체가 생성되므로, User 객체가 부모 및 자식 스레드 간에 공유되지 않습니다. 이 변경으로 스레드 안전성으로 돌아가지만 User 객체에는 읽기 전용으로 액세스할 수 있게됩니다(사실상 복사본을 생성함).\n\n다시 말하지만, 다이어그램 형식으로 상속 가능한 스레드 로컬을 시각화하면, 이와 같이 보일 것입니다. 이제 부모와 자식 스레드의 사용자가 서로 다른 User 객체를 가리키는 것을 명확히 알 수 있습니다.\n\n![Java Thread Locals 동작 방식](/assets/img/2024-05-23-HowdoJavaThreadLocalswork_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n자바 스레드 지역 변수에 대한 좋은 이해를 얻을 수 있기를 바랍니다. \n\n이 게시물이 도움이 되었다면 지원을 표시하기 위해 클로버 아이콘 👏을 몇 번 클릭해 주세요. 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png"},"coverImage":"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png","tag":["Tech"],"readingTime":6},{"title":"자바 애플리케이션에서 JMX와 프로메테우스로 메트릭 수집하기","description":"","date":"2024-05-23 12:38","slug":"2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication","content":"\n저희 응용 프로그램의 내부 작업, 성능 특성 및 비즈니스 지표를 이해하는 것은 사용자 경험과 비즈니스 상태를 구분짓고, 비즈니스가 어떻게 진행되고 있는지를 나타낼 수 있습니다. 높은 CPU 또는 메모리 사용량, 느린 응답 시간 또는 높은 지연과 같은 성능 문제는 비효율성이나 자원 경합을 지적할 수 있습니다.\n\n하지만 이러한 수치가 사용자에게 영향을 주기 전에 어떻게 감지, 추적 및 관찰할 수 있을까요?\n\n# 소개\n\n우리는 지표를 수집하고 분석함으로써 응용 프로그램의 상태, 동작 및 건강 상태에 대한 통찰력을 얻을 수 있습니다. JMX 및 프로메테우스와 같은 도구를 활용하여 간단한 방식으로 자바 응용 프로그램 지표에 대한 심도있는 가시성을 제공하는 강력한 모니터링 인프라를 구축할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 다음을 배울 것입니다:\n\n- MBeans를 사용한 JMX 계측의 기본 사항.\n- jconsole을 사용하여 JMX에 노출된 메트릭을 시각화하는 방법.\n- Prometheus가 무엇이며 JMX와 통합하여 대시보드에 메트릭을 노출하는 방법.\n- Java Prometheus 에이전트를 구성하고 Prometheus 서버를 실행하는 방법.\n- Prometheus를 사용하여 시계열 데이터를 시각화하는 방법.\n\n![이미지](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png)\n\n# JMX란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nJMX (Java Management Extensions)은 애플리케이션, 시스템 객체, 장치 및 서비스 중심 네트워크를 관리하고 모니터링하는 도구를 제공하는 네이티브 Java 기술입니다. 이러한 자원들은 MBeans(또는 관리되는 빈)이라고 불리는 객체로 나타낼 수 있습니다.\n\n작동 방식은 다음과 같습니다: 하나 이상의 MBeans가 리소스에 의해 계측(instrumented)되며, MBeans는 표준(관리 인터페이스가 메서드 이름으로 설명됨) 또는 동적(런타임에 관리 인터페이스를 노출하여 최대 유연성을 제공) 중 하나일 수 있습니다. 그런 다음 MBeans는 MBean 서버로 알려진 코어-관리되는 객체 서버에 등록되어 레지스트리 역할을 하는데, 각 MBean은 ObjectName에 의해 식별된 MBeanServer 내에서 고유한 식별자를 갖습니다.\n\n이것들은 JMX의 기본 사항이지만 이 기사를 따라갈 정도로 충분합니다. 자세히 살펴보고 싶다면, 오라클의 \"Getting Started with Java Management Extensions (JMX): Developing Management and Monitoring Solutions\"라는 오래되었지만 상당히 유용한 기술 포스트를 읽어보시기를 권장합니다.\n\n## Mbeans 구현하기\n\n<div class=\"content-ad\"></div>\n\nJMX에 메트릭을 노출하는 MBean 규칙은 다음과 같습니다:\n\n- MBean 접미사를 가진 인터페이스를 정의합니다.\n- 이 인터페이스를 클래스에서 구현합니다.\n- 구현을 Platform MBean 서버에 ObjectName을 사용하여 등록합니다.\n\n세 가지 작업(step 1)이 있는 간단한 DemoJmxMBean 인터페이스를 정의해봅시다:\n\n```js\npublic interface DemoJmxMBean {\n    void increaseVolume();\n    void decreaseVolume();\n    int getVolume();\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로 이 인터페이스를 구현해야 합니다 (단계 2). 다음과 같이 DemoJmx 클래스에서 작업해 봅시다:\n\n```js\npublic class DemoJmx implements DemoJmxMBean {\n    private int volume = 0;\n    @Override\n    public void increaseVolume() {\n        volume++;\n    }\n    @Override\n    public void decreaseVolume() {\n        volume--;\n    }\n    @Override\n    public int getVolume() {\n        return volume;\n    }\n...\n```\n\n이후, MBean 서버를 초기화하고 사용자 정의 MBean (DemoJmx)의 인스턴스를 생성한 다음, main 메소드 내에서 고유한 ObjectName을 사용하여 MBean 서버에 등록해야 합니다 (단계 3). 이 설정을 통해 JMX를 통해 DemoJmx 인스턴스를 관리하고 모니터링할 수 있게 됩니다. 이 경우, 볼륨을 관리하고 수집할 수 있습니다.\n\n```js\n// 모든 MBean을 위한 레지스트리인 플랫폼 MBeanServer를 검색합니다\nMBeanServer mbs = ManagementFactory.getPlatformMBeanServer();\n// MBean 구현의 인스턴스를 생성합니다\nDemoJmx demoService = new DemoJmx();\nObjectName name;\ntry {\n    // 특정 네이밍 패턴을 사용하여 새 ObjectName 인스턴스를 생성합니다\n    name = new ObjectName(\"com.example.DemoJmx:type=DemoJmxMBean,name=DemoJmxMetrics\");\n    // ObjectName을 사용하여 MBean 인스턴스 (demoService)를 MBeanServer에 등록합니다\n    // 이렇게 하면 JMX를 통해 MBean을 관리하고 모니터링할 수 있습니다\n    mbs.registerMBean(demoService, name);\n```\n\n<div class=\"content-ad\"></div>\n\n시간을 절약하기 위해 전체 코드는 제 Github에서 확인할 수 있어요. 원하는 IDE를 선택하고 이 기사를 따라해보세요.\n\n## 노출된 MBean 시각화\n\n한 번 MBean이 등록되면, 우리는 JMX 클라이언트(예: JConsole)를 사용하여 메트릭에 액세스할 수 있어요. 이 클라이언트는 JVM에 연결되어 등록된 MBeans를 탐색하고 상호 작용할 수 있게 해줍니다 (그림 1).\n\n<img src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n만약 나처럼 JConsole을 사용 중이라면 MBeans 탭으로 이동하면 DemoJmxMetrics라는 우리의 MBeans가 있을 것입니다 (그림 2).\n\n![DemoJmxMetrics](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_2.png)\n\nJConsole UI에 노출된 volume 속성을 확인할 수 있습니다. 그러나 이는 해당 속성의 현재 상태입니다. 만약 우리가 이 속성의 볼륨을 시계열 그래프를 통해 보고 싶다면 어떻게 할까요? 이 임무를 위해 우리는 다른 도구 — Prometheus가 필요합니다. 다음에 소개됩니다.\n\n# Prometheus란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n프로메테우스는 신뢰성과 확장성을 위해 설계된 오픈 소스 시스템 모니터링 및 경고 도구입니다. 특히 동적 클라우드 환경, 컨테이너화된 응용프로그램 및 마이크로서비스 아키텍처의 모니터링에 적합합니다. 프로메테우스는 Cloud Native Computing Foundation (CNCF)의 일부입니다. 이 어떻게 우리를 도울까요?\n\n프로메테우스는 JMX 메트릭을 수집하고 http 엔드포인트를 통해 노출시킵니다. 이 작업을 위해 일반적으로 프로메테우스 JMX 내보내기 도구를 사용합니다. 이 도구는 JMX 메트릭과 프로메테우스 사이의 다리 역할을 하며, 프로메테우스가 다른 메트릭 엔드포인트와 마찬가지로 JMX 메트릭을 수집할 수 있도록 합니다.\n\n이제 프로메테우스가 무엇이며 JMX 속성(또는 메트릭)을 내보내기하는 데 사용할 수 있는 것을 알았으니, 다시 손을 더럽히기 시작해봅시다.\n\n## 프로메테우스 JMX 내보내기로 JMX 메트릭 노출하기\n\n<div class=\"content-ad\"></div>\n\n단순해요. 먼저 GitHub 릴리스 페이지에서 최신 jmx_prometheus_javaagent-`버전`.jar 파일을 다운로드하세요.\n\n그런 다음 config.yaml(다른 이름일 수도 있음)이라는 설정 파일을 생성하여 JMX Exporter를 구성하세요. 이 파일은 수집할 JMX 메트릭과 Prometheus 메트릭으로의 매핑을 정의할 것입니다.\n\n다음은 promiscuous(넓은 범위) 설정 파일 예시입니다 (수집하려는 항목만 남기도록 필터링할 수 있습니다):\n\n```js\nrules:\n- pattern: \".*\"\n```\n\n<div class=\"content-ad\"></div>\n\n프로메테우스에 메트릭 유형을 지정하려면 config.yaml에서해야 합니다. 이것은 JMX 익스포터 설명서에 설명되어 있습니다.\n\n다음으로, IntelliJ를 사용 중이라면 Figure 3처럼 Java 애플리케이션의 시작 매개변수로 JMX 익스포터를 Java 에이전트로 추가해야 합니다.\n\n![Figure 3](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_3.png)\n\n위와 동일합니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\njava -javaagent:./../jmx_prometheus_javaagent-0.20.0.jar=8080:./../config.yaml -classpath mbeans-example/target/classes com.example.DemoJmx\n```\n\n이전에 다운로드한 파일의 경로(jmx_prometheus_javaagent-`버전`.jar 및 config.yaml)를 사용함을 기억해주세요.\n\n이제 우리는 프로메테우스 에이전트가 게시한 메트릭에 /metrics 엔드포인트(http://localhost:8080/metrics)를 통해 액세스할 수 있어야 합니다. 도표 4에서 볼 수 있듯이, 자세히 살펴보면 DemoJmxMetrics 객체와 속성 volume을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n이제 데이터가 캡처되는 것을 확인했지만, 이는 확실히 시각화하기에 최적의 방법은 아닙니다. 다음에는 이에 대해 처리해 봅시다.\n\n## 그래프를 통한 데이터 시각화\n\n먼저, JMX 익스포터에서 메트릭을 수집하기 위해 프로메테우스 설정 파일 (prometheus.yml)을 가져옵니다. 그림 5는 이 시점까지의 디렉토리 구조를 보여줌으로써 우리가 길을 잃지 않도록 도와줍니다.\n\n![Figure 5](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_5.png)\n\n<div class=\"content-ad\"></div>\n\n그럼, 새로운 작업을 추가하여 prometheus.yml 구성 파일을 업데이트합니다:\n\n```js\n- job_name: 'jmx-exporter'\n  static_configs:\n    - targets: ['<당신의 IP 주소>:8080']\n```\n\n`your IP address`는 우리의 Java 어플리케이션이 실행 중인 네트워크 인터페이스의 IP로 대체되어야 합니다.\n\n마지막으로, prometheus.yml 파일을 위한 볼륨을 만들어 컨테이너 이미지를 사용하여 Prometheus 서버를 실행합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\ndocker run \\\n    -p 9090:9090 \\\n    -v ./prometheus.yml:/etc/prometheus/prometheus.yml \\\n    prom/prometheus\n```\n\n모든 것이 잘 되면 콘솔에 다음 메시지가 표시될 것입니다: \"서버는 웹 요청을 받을 준비가 되었습니다.\"\n\n그런 다음, Prometheus 서버 UI 엔드포인트인 http://localhost:9090 으로 이동합니다 (그림 6). 우리의 애플리케이션에서 메트릭이 스크랩되고 있는지 확인하기 위해 상태 메뉴로 이동한 다음 타겟을 선택합니다.\n\n![이미지](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n볼륨 측정치의 변화를 시각화하기 위해 JConsole 인터페이스를 사용하여 볼륨을 증가하거나 감소시킬 수 있습니다 (그림 7).\n\n![Figure 7](/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_7.png)\n\nincreaseVolume() 또는 decreaseVolume()을 클릭한 후에는 볼륨 속성이 그에 맞게 변경되며 이러한 값은 Prometheus에 업데이트될 것입니다.\n\n그래프를 시각화하기 위해 Graph 메뉴로 이동하여 원하는 메트릭을 검색할 수 있습니다. 그림 8에서는 볼륨이라는 데모용으로 생성한 메트릭을 찾고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_8.png\" />\n\n마지막이에요! 프로메테우스 서버가 응용 프로그램을 스크래핑하는 시간 주기를 구성할 수 있고, 다른 여러 옵션들을 파라미터화할 수도 있지만 이 부분은 당신의 요구에 따라 결정됩니다. 학습 목적으로는 충분할 것입니다.\n\n# 최종 고려 사항\n\n이 기사에서는 MBean 규약을 따르는 방법을 배웠습니다. 또한, 시계열 방식으로 이러한 메트릭을 시각화하기 위해 프로메테우스 서버를 설정했습니다. 프로메테우스가 노출하는 데이터를 시각화하기 위해 Grafana와 같은 다른 도구를 사용할 수 있음에 유의하십시오. Grafana는 대시보드를 생성, 탐색 및 공유하는 데 풍부한 기능 세트를 제공하는 도구입니다.\n\n<div class=\"content-ad\"></div>\n\n기타 유의할 점은 Kafka, RabbitMQ, ActiveMQ 등을 포함한 많은 인기있는 Java 기반 라이브러리들이 기본적으로 JMX(metrics)를 제공한다는 것입니다. 이러한 메트릭들은 여기에서 배운 방법과 마찬가지로 노출될 수 있습니다. 따라서 이러한 MBeans를 활용하여 사용 가능한 메트릭을 찾고 응용 프로그램에서 간편하게 모니터링할 수 있습니다.\n\n마지막으로, 응용 프로그램 내에서 비즈니스 메트릭을 생성하고 수집하는 데도 이 같은 패턴을 적용할 수 있다는 점을 강조해야 합니다. 이 접근 방식은 제품 팀과 다른 이해관계자들을 위한 매우 관련성 높은 대시보드를 만들어주어 가치 있는 통찰력을 제공하고 정보에 근거한 의사 결정을 도울 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png"},"coverImage":"/assets/img/2024-05-23-CollectingMetricswithJMXandPrometheusinaJavaApplication_0.png","tag":["Tech"],"readingTime":8},{"title":"당신의 차가 당신을 감시하고 보험 회사에 폭로합니다","description":"","date":"2024-05-20 21:37","slug":"2024-05-20-Yourcarspiesonyouandratsyououttoinsurancecompanies","content":"\n\n## 제품에 대한 비용을 지불하더라도, 여전히 당신이 제품입니다.\n\n![이미지](/assets/img/2024-05-20-Yourcarspiesonyouandratsyououttoinsurancecompanies_0.png)\n\n## 제 새로운 베스트셀러 소설 The Bezzle!으로 투어 중입니다! 내일 샌프란시스코에서 만나요 (3월 13일), 그리고 토론토 (3월 22일), 뉴욕, 애나하임 등에서도 만날 수 있어요!\n\n![이미지](/assets/img/2024-05-20-Yourcarspiesonyouandratsyououttoinsurancecompanies_1.png)\n\n<div class=\"content-ad\"></div>\n\n또 한 가지 특징적으로 탁월한 Kashmir Hill의 뉴욕 타임스 기사에서 현대 생활에 대한 또 다른 엄청난 사실을 밝히고 있습니다: 여러분의 자동차가 주행에 대한 세부 데이터를 비밀리에 기록하고 데이터 브로커에 판매하며, 이들은 보험사에 판매하여 보험료를 내려고 핑계로 사용합니다.\n\n거의 모든 자동차 제조사가 이를 하고 있습니다: 현대, 닛산, 포드, 크라이슬러 등등:\n\n[자세한 내용을 보려면 여기를 클릭해주세요](https://www.nytimes.com/2024/03/11/technology/carmakers-driver-tracking-insurance.html)\n\n[https://www.repairerdrivennews.com/2020/09/09/ford-state-farm-ford-metromile-honda-verisk-among-insurer-oem-telematics-connections/](https://www.repairerdrivennews.com/2020/09/09/ford-state-farm-ford-metromile-honda-verisk-among-insurer-oem-telematics-connections/)\n\n<div class=\"content-ad\"></div>\n\n차를 소유하든 임대하든 상관없이 이 사실은 변함없습니다. 또한 이는 보험사가 보험료 할인을 위해 제안한 \"블랙박스\"와는 별개입니다. 다시 말해, 보험사의 감시 기반 할인 제안을 거부하더라도, 그들은 보험료를 지불하지 않고 시장에서 귀속되어 있는 데이터를 구매할 수 있는 수단을 가지고 있습니다.\n\n항상 제가 싫어하는 격언이 있습니다. \"제품 값을 지불하지 않으면, 당신이 제품입니다\"라는 말인데, 그 이유는 이것이 고객을 대우하는 보상 프로그램으로 설정하여, 일등석 승객이 이륙 전에 받는 작은 램킨 따뜻한 견과류와 같이 차이점을 보도록 하는 것입니다. 기업은 고객이 지불할 때 당신을 잘 대하지 않습니다. 기업은 당신을 나쁘게 대하기에 대한 결과를 두려워할 때 당신을 잘 대합니다.\n\n애플을 예로 들어보죠. 이 회사는 IOS 사용자에게 상업 감시로부터 1탭으로 탈퇴할 수 있는 기회를 제공하고, 96% 이상의 사용자가 탈퇴했습니다. 나머지 4%는 혼란스러운 사용자이거나 Facebook에 급여를 받은 사용자일 것입니다. 애플 – 그리고 그 추종자들의 군단 – 는 이를 통해 세상의 불행은 광고 지원 제품을 사용하여 아무런 대가를 지불하지 않을 것으로 기대하는 인색한 \"소비자\"들 때문이라고 주장합니다.\n\n하지만 여기가 중요한 부분입니다. 모든 경쟁사에게 자사의 고객을 감시하는 것을 막은 후, 애플은 그 고객을 비밀리에 감시하기 시작했습니다! 애플은 경쟁사들이 자사의 아이폰 사용자를 감시하지 못하도록 차단한 이후에도 그 고객을 비밀리에 감시하고 데이터를 사용하여 광고를 위해 고객을 타겟팅합니다.\n\n<div class=\"content-ad\"></div>\n\nhttps://pluralistic.net/2022/11/14/luxury-surveillance/#liar-liar\n\n제품을 구매하고 있어도 여전히 제품은 당신입니다 - 회사가 당신을 제품으로 취급해도 괜찮다고 생각한다면요. Apple은 완전히 당신을 제품으로 취급해도 문제가 없습니다. 왜냐하면 Apple은 Apple과 다른 회사들이 당신을 제품으로 취급하는 것을 막았던 역사적 제약이 없기 때문입니다.\n\n저의 맥루한 강연에서 설명한 것처럼, 기술 기업들은 네 가지 힘에 의해 제약을 받을 수 있습니다:\n\nI. 경쟁\n\n<div class=\"content-ad\"></div>\n\nII. 규제\n\nIII. 자가 도움\n\nIV. 노동\n\n[https://pluralistic.net/2024/01/30/go-nuts-meine-kerle/#ich-bin-ein-bratapfel](https://pluralistic.net/2024/01/30/go-nuts-meine-kerle/#ich-bin-ein-bratapfel)\n\n<div class=\"content-ad\"></div>\n\n회사들이 실제 경쟁사를 갖고 있을 때 — 산업이 수십 개나 수백 개의 거의 동등한 기업으로 구성될 때 — 그들은 고객들이 다른 경쟁사로 옮겨갈 수 있다는 걱정을 해야 합니다. 40년간의 항공점 소홀은 기업들이 악의적인 합병과 가격 정책을 통해 우위를 확립하는 데 성공했음을 의미하며, 이는 오늘날의 비혈액인 하브스부르크 자본주의를 낳았습니다. 애플과 구글은 모바일 독점체제이고, 구글은 검색 독점체제 등이 있습니다. 기술뿐만 아니라 모든 산업이 이와 같이 보입니다.\n\n경쟁을 없애면 고객들이 대안을 잃는 것 뿐만 아니라 기업들에게 권한을 부여하기도 합니다. 집중된 산업의 회사들은 \"낭비되는 경쟁\"으로부터 해방되며 상당한 이익을 추출할 수 있습니다. 애플과 구글이 모두 앱 매출 및 거래에 대한 동일한 30% 앱 수수료에 \"경쟁적으로\" 도달하는 방식을 생각해보세요. 이 비율은 (비양분적이고 가격 폭리를 부리는) 신용카드 산업이 추출하는 거래 수수료보다 1,000% 이상 높습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 카르텔의 권력은 그들의 전쟁 물자의 크기를 넘어서 있습니다. 카르텔의 진정한 권력의 원천은 소수의 기업이 공통된 로비 활동 위치에 도달하고 고수할 수 있는 쉬움에 있습니다. 여기에서 \"규제 캡처\"가 등장합니다: 모바일듀오플리가 그들의 규제기관을 잡는 것이 더 쉽기 때문에 두 기업은 그들의 앱 세금 수십억을 어떻게 쓸지 합의하는 데 쉬움이 있습니다:\n\n[소스](https://pluralistic.net/2022/06/05/regulatory-capture/)\n\n애플 - 그리고 구글, 페이스북, 그리고 당신의 자동차 회사도 - 당신의 개인정보를 침해할 수 있는 이유는 그들이 규제로 제한받지 않기 때문입니다. 마찬가지로 우버는 운전자의 노동 권리를 침해하고 아마존은 소비자 권리를 침해할 수 있습니다. 기술 카르텔은 그들의 규제 기관을 캡처하고 그들에게 법이 앱을 통해 어길 때는 적용되지 않는다고 확신시켰습니다:\n\n[소스](https://pluralistic.net/2023/04/18/cursed-are-the-sausagemakers/#how-the-parties-get-to-yes)\n\n<div class=\"content-ad\"></div>\n\n다시 말해, Apple은 당신을 감시할 수 있는 이유는 당신을 감시할 수 있기 때문에 허용되기 때문이다. 미국의 마지막 소비자 개인 정보 보호 법은 1988년에 제정되었고, 비디오 대여점 직원이 당신의 VHS 대여 기록을 유출하는 것을 금지합니다. 레이건 시절 이후로 소비자 개인 정보 보호에 대해 미국 의회는 아무런 조치를 취하지 않았습니다:\n\nhttps://www.eff.org/tags/video-privacy-protection-act\n\n그러나 기술은 일부 특별한 안전 방지 장치 유지 특성을 가지고 있습니다. 이러한 특성 중에서 가장 중요한 것은 상호 운용성입니다: 컴퓨터가 어떤 프로그램이든 실행할 수 있는 범용 디지털 기계임을 의미합니다. HP는 서드파티 잉크를 거부하는 프린터를 디자인하고 자체 색 가수분에서 갤런당 10,000달러를 청구할 수 있지만, 다른 사람이 당신의 프린터를 임의의 잉크 카트리지를 허용하도록 만들어주는 프로그램을 작성할 수 있습니다:\n\nhttps://www.eff.org/deeplinks/2020/11/ink-stained-wretches-battle-soul-digital-freedom-taking-place-inside-your-printer\n\n<div class=\"content-ad\"></div>\n\n기술 회사들은 제품을 엉망으로 만들 생각을 한다면 언제나 경쟁사가 나타나서 언제든 그들과 고객 사이에 클매지화 도구를 제공하고 그것을 들어마신다는 것을 염두에 두어야 했습니다. 만약 광고를 20%나 더 거슬리게 만들어서 순익이 2% 증가한다는 기대 속에서 하는 경우, 40%의 사용자가 광고를 차단하는 방법을 구글링할 수도 있다는 가능성을 고려해야 합니다. 광고를 차단하는 사용자의 수익은 현재 수준의 100%에 머물러 있지 않습니다 - 영원히 0으로 떨어지게 됩니다(어떤 사용자도 결코 \"어떻게 광고 차단을 중지하나요?\" 라고 구글링할 리가 없습니다).\n\n대부분의 웹 사용자들은 광고 차단기를 실행하고 있습니다: \n\nhttps://doc.searls.com/2023/11/11/how-is-the-worlds-biggest-boycott-doing/\n\n웹 운영자들은 제안을 했습니다(\"무제한 감시와 방해 없는 침입 대신 무료 웹사이트를 제공하겠다\") 그리고 사용자들은 대안을 제안했습니다(\"그건 괜찮은데요?\"):\n\n<div class=\"content-ad\"></div>\n\nhttps://www.eff.org/deeplinks/2019/07/adblocking-how-about-nah\n\n여기 요점이에요: 앱을 역공학하거나 다른 지식 재산권으로 보호된 기술을 분석하는 것은 법적으로 미끄러운 땅입니다. 앱을 디컴파일하는 것만으로도 DMCA의 섹션 1201을 위반하여 5년의 징역형과 50만 달러의 벌금에 처할 수 있습니다. 하지만 DMCA 뿐만 아니라 현대 제품은 경쟁사가 제품을 보완, 재구성 또는 적응하는 것을 막기 위해 IP 법을 적용할 수 있는 하이테크 함정으로 둘러싸여 있습니다. 기업이 \"IP를 보유했다\"고 말할 때는 그들이 고객, 비평가 및 경쟁사를 통제하기 위해 국가의 권력을 발동할 수 있도록 법적 사안을 처리했다는 뜻입니다:\n\nhttps://locusmag.com/2020/09/cory-doctorow-ip/\n\n\"앱\"은 광고 차단기를 추가하는 것을 범죄로 만들기 충분한 IP로 된 웹 페이지에 불과해요. 이것이 Jay Freeman이 \"비즈니스 모델에 대한 고의적인 경멸죄\"라고 부르는 것이며, 어디에나 있습니다. 기업들이 사용자들이 제품을 개선하는 자체적인 조치를 취할 것을 걱정할 필요가 없을 때, 그들은 제품에서 가치를 고객으로부터 자신들로 옮기는 충동을 피하는 제한에서 해방됩니다.\n\n<div class=\"content-ad\"></div>\n\n애플의 존재는 상호 운용성(interoperability) 덕분입니다. 애플은 마이크로소프트 오피스 파일 형식을 복제하여 Pages, Numbers 및 Keynote용으로 사용한 능력 덕분에 2000년대 초 기업을 살렸습니다. 그 이후로 애플은 다른 사람들이 애플에게 했던 것처럼 애플에게 행하지 않도록 자신의 존재를 바쳤습니다.\n\n규제 캡쳐는 양날의 칼입니다: 이것은 강력한 기업들이 법을 무시하기에 방해가 되지만, 그들이 노동자, 고객, 공급업체 또는 다른 이해관계자들의 이익을 토대로 기업을 납득시키기 위해 법률을 동원할 수 있는 능력에 관한 것입니다.\n\n기술 기업에 대한 최종적인 역사적 제약은 그들의 노동자들이었습니다. 기술 산업의 노동 조합 밀도는 매우 낮았지만, 개별 기술 노동자들은 그들의 희소성으로 인해 많은 협상력을 갖추었습니다. 이것이 왜 그들의 상사들이 고급 카페테리아, 화려한 체육관 및 무료 마사지로 가득 찬 기발한 캠퍼스를 제공했는지 설명합니다. 이것은 기술 기업이 기술 노동자들을 달래기 위해 그들에게 세계를 디지털 미래로 이끄는 임무의 파트너라고 납득시킨 것입니다.\n\n<div class=\"content-ad\"></div>\n\nhttps://pluralistic.net/2023/09/10/the-proletarianization-of-tech-workers/\n\n테크 보스들에게는 이런 전략이 잘 통했지만, 심각한 실패를 했습니다. 한편으로는, Fobazi Ettarh의 \"직업적 경외심\" 정신을 발동시켜, 그들은 그렇지 않았던 강력한 노동자들로 하여금 \"극단적으로 열정적\" 하도록 동의하게 했습니다:\n\nhttps://www.inthelibrarywiththeleadpipe.org/2018/vocational-awe/\n\n다른 한편으로는, 귀하의 노동자들에게 미션에 대한 감동을 일으킨다면, 단점은 그들이 미션을 느낀다는 것입니다. 즉, 테크 업무자에게 어떤 것을 가치 있게 만드라고 요구할 때, 그들은 어머니의 장례를 놓치고 쏟아부은 것을 하게 하고 싶다면, 그들은 심각한 도덕적 상처를 경험하게 되고 거부할 것이며, 해당 노동자의 교섭력은 그들이 그것을 고수하게 할 수 있다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n값을 지불하지 않았기 때문이 아니라, 제품을 판매하기 위해 사생활 정보를 수집하고 누구든지 원하는 사람에게 판매하는 선택을 했습니다. 제품을 위해 지불하지 않았으니 당신이 제품이 되는 것이 아니라, 그들이 그렇게 할 수 있기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n차량에는 엉망으로 설치된 칩들이 있습니다. 자동차 제조사들이 자동차 디자인에 넣은 수십 개의 칩들은 더 나은 제품을 전달하는 데 부수적으로 관련이 있습니다. 이러한 칩들의 주요 용도는 자체 고객들의 무차별한 악용에 방해가 되는 수정 및 수리를 차단하는 법적 규제 (\"IP\")에 접근하는 것입니다:\n\n[Pluralistic 링크](https://pluralistic.net/2023/07/24/rent-to-pwn/#kitt-is-a-demon)\n\n자동차 소프트웨어의 엔지니어링을 뒤집고 수정하는 것이 범죄로 간주된다는 사실은 각종 엉망스러운 사기행위로 가득 차게 합니다. 매사추세츠의 자동차 제조업체들에게 '수리권 확보' 의무를 부과하기 위해 투표를 진행했던 때가 있었는데 기억하시나요? 수리권을 실현하기 위해 법적 개입이 필요한 유일한 이유는 대형 자동차 업체들이 진단 메시지를 암호화함으로써 제3자의 자동차 진단을 범죄화할 수 있음을 깨달았기 때문입니다. 왜냐하면 메시지의 복호화는 DMCA를 위반하기 때문이죠:\n\n[EFF 링크](https://www.eff.org/deeplinks/2013/11/drm-cars-will-drive-consumers-crazy)\n\n<div class=\"content-ad\"></div>\n\n'Big Car'가 VIN 잠금을 해제했는데, 엔진 부품 및 부속품용 DRM은 제삼자 스페어 파츠의 생산 및 설치를 범죄화시킬 수 있습니다:\n\nhttps://pluralistic.net/2022/05/08/about-those-kill-switched-ukrainian-tractors/\n\n자동차를 법적으로 수정할 수 없다는 사실은 자동차 제조업체가 자신들이 최저금리 대출을 판매하는 동안 무관리 은행으로 돌아갈 수 있다는 점을 의미합니다. 최저금리 자동차 대출 - 1조 달러 이상의 가치가 있는 물건! - 은 빌린 사람들의 차량이 렌더마이 중앙에서 원격으로 제어될 수 있음을 절대적으로 요구합니다. 한 번 납부를 잃어버리면 차량의 스테레오가 자동으로 켜지고 최대 볼륨으로 위협 메시지를 송출합니다. 그것을 끌 수 없습니다. 차량을 카운티 선을 넘어 운전하지 않겠다고 하는 임대 계약을 위반하면 차량이 기본 기능을 중지시킵니다. 이러한 소프트웨어 중 하나를 변경하려고 하면 DMCA의 1201조에 따라 범죄를 저지를 것입니다:\n\nhttps://pluralistic.net/2021/04/02/innovation-unlocks-markets/#digital-arm-breakers\n\n<div class=\"content-ad\"></div>\n\n테슬라는 당연히 가장 고급스러운 안티-기능을 가지고 있습니다. BMW가 좌석 난방기를 렌트하려고 하거나, 메르세데스가 엑셀러레이터 페달에 매월 구독 서비스를 판매하려고 한 것보다 훨씬 오래전에 만든 것들이죠. 테슬라는 악마에 쫓기는 악몽 같은 자동차였습니다. 테슬라의 할부금을 놓치면 자동차가 기동을 중지하고 잠겨서 회수인이 오기 전까지는 잠금 상태가 유지됩니다. 그 후 자동차는 경적을 울리고 주차 공간에서 빠져나옵니다. 자동차의 배터리를 완전히 충전하거나 기본으로 제공된 기능을 사용하기 위해 \"구입\"하면, 그것들을 소유한 것이 아닙니다. 자동차가 소유주를 바꿔야 하는 경우, 이러한 기능들은 회수되어 중고 시장에서 차량의 다음 소유자가 이러한 기능을 다시 구매해야 해서 중고 가격이 낮아지게 됩니다: \n\nhttps://pluralistic.net/2023/07/28/edison-not-tesla/#demon-haunted-world\n\n또한 이 모든 DRM으로 제작업체는 제거할 수 없는 스파이웨어를 설치할 수 있습니다. 실제로 R2R 전략이 80% 승리를 향해 나아가는 동안 벽벽에 무서운 광고가 속출하여 자동차가 당신에 대해 수집하는 정보가 매우 많다는 점을 공개하였습니다. 서드파티가 이 정보에 접근하는 것으로 인해 당신의 살인 사건이 발생할 수 있다고 밝혔는데, 정말로요! \n\nhttps://pluralistic.net/2020/09/03/rip-david-graeber/#rolling-surveillance-platforms\n\n<div class=\"content-ad\"></div>\n\n그래서 당신의 자동차가 당신을 스파이하는 거죠. 그것이 가능하기 때문입니다. 그것을 만든 회사가 시장, 법률, 기술 또는 자체 직원의 윤리에 제약이 없기 때문입니다.\n\n제 enshittification 가설에 대한 일반적인 비판 중 하나는 이것이 \"종교적으로 합리적이고 정상적이다\"라는 것입니다. 왜냐하면 \"인터넷이 우리에게 놀라운 제품을 제공해주고, 우리에게 기쁨과 행복을 주며 하루 종일 걸쳐 사용하는데 아무것도 요구하지 않아야 한다\"고 믿기 시작했기 때문입니다:\n\n[https://freakonomics.com/podcast/how-to-have-great-conversations/](https://freakonomics.com/podcast/how-to-have-great-conversations/)\n\n이 비판이 놓치는 점은 기업이 우리로부터 어떤 가치를 가져다가 그들에게 이전시키려고 하는 협상을 하는 것이 아니라는 것입니다. Enshittification은 기업이 제품과 서비스가 우리가 의존하는 방식을 단순히 변경하도록 법률과 기술, 시장 권력을 이용하여 협상없이 모든 그 가치를 쥐면 발생합니다.\n\n<div class=\"content-ad\"></div>\n\n경쟁업체, 규제당국, 탈옥, 또는 근로자들이 제품을 역겹게 만들겠다며 거부하는 것을 두려워하지 않아도 되는 회사는 시장 협상을 할 필요가 없습니다. 그냥 가져갈 수 있죠. 다스 베이더 MBA에서 가르치는 첫 번째 수업입니다: \"거래를 변경하겠다. 나는 더 변경하지 않기를 기도하라\":\n\n[Pluralistic](https://pluralistic.net/2023/10/26/hit-with-a-brick/#graceful-failure)\n\n자동차가 당신을 스파이하는 것은 당신의 믿음 때문이 아닙니다. 자동차회사가 \"당신이 하루 종일 보내며 기쁨과 행복을 제공해야 하며, 그에 대한 보상을 요구해서는 안 된다\"라고 생각하는 것도 아닙니다. 제품에 값을 지불하지 않았기 때문에 이제 당신이 제품이 되었기 때문이 아닙니다. 이것은 그들이 그렇게 할 수 있기 때문입니다.\n\n이 스파이 활동의 결과는 보험료 인상에 그치지 않습니다. 자동차 텔레메트리는 우리의 데이터를 수집하고 판매하는 믿을 수 없을 만큼 트릭을 부리는 데이터 브로커 산업이 사용하는 퍼널의 꼭대기에 위치합니다. 이 회사들은 당신이 낙태 클리닉을 방문한 사실을 마케터, 현상금 사냥꾼, 광고주 또는 보복적인 가족 구성원들에게 판매하는 것과 같이 행합니다.\n\n<div class=\"content-ad\"></div>\n\nhttps://pluralistic.net/2022/05/07/safegraph-spies-and-lies/#theres-no-i-in-uterus\n\n수십 년간의 친독점 정책으로 인해 광범위한 규제 캡처가 발생했습니다. 기업 카르텔은 우리로부터 추출한 독점 수익을 사용하여 규제 불이행을 지불하고, 이로써 더 많은 이익을 채취할 수 있습니다.\n\n그러나 개인 정보 보호에 관해서는 그 경기가 어떤 종식을 맞게 될 것입니다. 개인 정보 보호 규정의 부재는 많은 문제의 근본에 있어서, 개인 정보 보호 운동이 끊임없이 자신을 지지하는 선택유권을 가지게 되는 것입니다.\n\nEFF에서는 이를 \"개인 정보 우선\"이라고 부릅니다. 취약한 사람들을 음모 이론으로 겨누는 사기꾼, 정신적 건강을 해치는 미디어로 대상을 향하는 십대들, 외국 정부에 의해 감시당하는 미국인들, 혹은 경찰이 시위자들을 소탕하기 위해 상업 감시 데이터를 이용하는 등, 이 모든 해를 원동력으로 하는 데이터 유출의 수도꼭지를 닫을 수 있는 상당한 개인 정보 보호 입법을 제정하면:\n\n<div class=\"content-ad\"></div>\n\n[https://www.eff.org/wp/privacy-first-better-way-address-online-harms](https://www.eff.org/wp/privacy-first-better-way-address-online-harms)\n\n전통적인 경제학은 시장에 대한 생각 없이 권력에 대해 생각하기 때문에 실패합니다. 독점은 시장 권력 이상으로 이어지며, 규제 기반역습, 노동자들에 대한 권력, 그리고 IP 법을 통해 경쟁을 범죄화합니다. 우리의 문제가 단지 돈을 충분히 쓰지 않거나 잘못된 제품을 사는 데서 비롯된다는 이야기는 기업들이 우리 삶에 행사하는 권력을 일부러 무시한다면 의미가 있습니다. 독점에서 벗어나려고 소비한다는 생각은 좋지만, 독점에서 투표해서 벗어난다는 것보다 훨씬 쉽기 때문에, 지갑으로 투표하는 것이 언제나 이기려는 시장을 통제하는 군사들에게서 이길 것입니다:\n\n[https://pluralistic.net/2024/03/05/the-map-is-not-the-territory/#apor-locksmith](https://pluralistic.net/2024/03/05-the-map-is-not-the-territory/#apor-locksmith)\n\n![Image](/assets/img/2024-05-20-Yourcarspiesonyouandratsyououttoinsurancecompanies_2.png)\n\n<div class=\"content-ad\"></div>\n\n## 험블 코리 닥터로 번들로 18권의 DRM 없는 전자책을 자유롭게 선택할 가격을 정해주세요. 또한, Electronic Frontier Foundation을 지원할 수 있습니다.\n\n만약 이 게시물의 에세이 형식 버전이 필요하다면, 아래 링크를 통해 저의 추적 불가능하고 광고 없는 블로그인 pluralistic.net에서 읽거나 공유해보세요:\n\n[https://pluralistic.net/2024/03/12/market-failure/#car-wars](https://pluralistic.net/2024/03/12/market-failure/#car-wars)\n\n![Cryteria (modified)](https://commons.wikimedia.org/wiki/File:HAL9000.svg)\n\n<div class=\"content-ad\"></div>\n\nCC BY 3.0\nhttps://creativecommons.org/licenses/by/3.0/deed.en","ogImage":{"url":"/assets/img/2024-05-20-Yourcarspiesonyouandratsyououttoinsurancecompanies_0.png"},"coverImage":"/assets/img/2024-05-20-Yourcarspiesonyouandratsyououttoinsurancecompanies_0.png","tag":["Tech"],"readingTime":12},{"title":"자신의 PC에서 대규모 언어 모델 실행하기 개인 정보 보호 및 그 이상","description":"","date":"2024-05-20 21:36","slug":"2024-05-20-RunningLargeLanguageModelsonyourPCprivacyandbeyond","content":"\n\n![Running LLM on Your PC: Privacy and Beyond](/assets/img/2024-05-20-RunningLargeLanguageModelsonyourPCprivacyandbeyond_0.png)\n\n이 첫 번째 기사를 통해, 인터넷 연결 없이 PC에 로컬로 내 LLM을 설치하고 설정하고 실행하는 여정을 문서화할 일련의 기사를 시작합니다.\n\n내 PC에서 이 프로젝트를 구축하고 개인적으로 사용하기로 결정한 이유는 이 기사에서 확인할 수 있습니다.\n\nChat-GPT 3.5와 비슷하거나 심지어 동일한 기능을 가지려고 합니다. 이것은 이루기 어렵게 들릴 수 있지만, 기술은 매일 발전하고 있으며, 적절한 하드웨어, 소프트웨어 및 LLM의 조합을 통해 가능할 것으로 생각합니다. 이 과정에서 취하는 단계, 최적화 및 조정, 실수와 성공, 사용하는 소스, 그리고 향후 하드웨어 업그레이드에 대해 공유할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 여정이 끝날 때 모든 기사들은 사용자 안내서로 요약될 것이며, 저는 이를 무료로 발행하여 누구나 이 경험에서 혜택을 받고 직접 시도해볼 수 있도록 할 것입니다. 물론 이 과정에서 모든 의견, 제안 및 지침은 환영합니다.\n\n이 여정이 시작되기 전에, 로컬 및 프라이빗 LLM을 위한 기반이 될 하드웨어와 소프트웨어인 나의 출발점을 공유할 것입니다.\n\n나의 초기 컴퓨터 구성은 다음과 같습니다:\n\n- CPU: AMD Ryzen 9 7950X3D, 16코어 @ 4.20 GHz\n- RAM: Corsair VENGEANCE DDR5, 64GB (2 X 32 GB)\n- HDD: 삼성 990 EVO NVMe™ M.2 SSD (1 TB 각 2개)\n- 비디오: Nvidia GeForce RTX 4070, 12GB (평택 에디션)\n\n<div class=\"content-ad\"></div>\n\n이 설정의 소프트웨어 구성 요소는 다음과 같습니다:\n\n- Windows 11 Pro, ver. 23H2 (주 OS)\n- Ubuntu 22.04 (Windows PowerShell 콘솔에 설치 및 실행됨)\n- Ollama (LLM을 위해)\n- Docker (컨테이너용)\n- Python 3.11 (데이터 세트 및 일부 라이브러리 및 구성 요소 용)\n- Visual Studio Code (필요할 때 코딩을 위해)\n\nWindows PowerShell 콘솔에 Ubuntu를 설치해야 합니다. Windows에서 \"시작\" 메뉴를 열고 \"실행\"을 입력하고 새 창에서 \"PowerShell\"을 입력한 후 Enter 키를 누르십시오. 콘솔에서 다음 명령을 입력하십시오:\n\n```js\nwsl --install\n```\n\n<div class=\"content-ad\"></div>\n\n설치 프로세스를 시작하고, 완료되면 Linux용 사용자 이름과 비밀번호를 입력하라는 메시지가 표시됩니다. 성공적으로 설치되면 다음과 같은 화면을 볼 수 있습니다:\n\n![이미지](/assets/img/2024-05-20-RunningLargeLanguageModelsonyourPCprivacyandbeyond_1.png)\n\n설치가 끝나면 Ubuntu 배포판을 업데이트하고 업그레이드하는 것과 같은 좋은 실천 동작들을 수행해야 합니다. 다음 명령어를 사용하여 이를 실행할 수 있습니다(사용자 이름과 비밀번호가 요청될 것입니다):\n\n```bash\nsudo apt update\nsudo apt upgrade -y\n```\n\n<div class=\"content-ad\"></div>\n\n이제 여러 추가 패키지가 설치됩니다. 그리고 이로써 귀하의 로컬 PC에 Ubuntu를 설치하는 작업이 완료되었습니다.\n\n다음은 Ollama입니다. 이를 통해 LLMs를 설치하고 실행할 수 있습니다.\n\n참고: Ollama를 설치하기 전에 이미 Linux 환경에 있는지 확인하세요. Ubuntu를 시작하려면 다음 명령을 입력하십시오:\n\n```js\nwsl -d Ubuntu\n```\n\n<div class=\"content-ad\"></div>\n\n설치는 콘솔에서 다시 실행되며 다음 명령어로 실행할 수 있습니다:\n\n```js\ncurl -fsSL https://ollama.com/install.sh | sh\n```\n\n성공적으로 설치되면 이 화면이 표시되어야 합니다. 여기서 중요한 점은 프로세스가 완료된 후 비디오 카드가 인식되어야 한다는 것입니다 (빨간색으로 표시됨). \n\n<img src=\"/assets/img/2024-05-20-RunningLargeLanguageModelsonyourPCprivacyandbeyond_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n비디오 카드는 NVIDIA에서 제공하는 것이 좋습니다. 큰 언어 모델 작업에 있어서 결정적인 부분입니다. 머신에 설치된(또는 적합한) 카드가 없는 경우 모델은 CPU 전력을 사용하게 되어 작업이 훨씬 느리고 정확도가 떨어지게 됩니다.\n\nOllama를 설치한 후에는 하나 이상의 대형 언어 모델(LLM)을 설치해야 합니다. 저는 llama2:13b를 선택하여 Meta에서 제공하는 130억 파라미터 모델을 설치했습니다. 이 모델은 제 개인 GPT에서 사용하고 제 데이터로 훈련시킬 모델입니다. 모델 크기는 7.4GB이므로 제 12GB (RTX 4070 FE) 비디오 카드에 적합합니다.\n\n![Running Large Language Models on your PC: Privacy and Beyond](/assets/img/2024-05-20-RunningLargeLanguageModelsonyourPCprivacyandbeyond_3.png)\n\n설치는 콘솔과 리눅스 환경에서 다시 진행됩니다. 아래 명령어로 실행할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n오레카 풀라마 2:13b\n\n모델을 다운로드하고 하드 드라이브에 저장하는 프로세스가 시작됩니다. 프로세스를 시작하기 전에 충분한 여유 공간이 있는지 확인하세요. 공간이 부족한 경우,  llama:7b와 같은 더 작은 모델을 다운로드할 수도 있습니다. 이는 동일한 명령으로 수행할 수 있습니다: \"llama:13b\"를 \"llama:7b\"로 교체하면 됩니다. 7b 모델은 4.7GB이며, llama:13b 대신 사용할 수 있습니다.\n\n성공적인 설치 후 다음 화면을 볼 수 있어야 합니다:\n\n![image](/assets/img/2024-05-20-RunningLargeLanguageModelsonyourPCprivacyandbeyond_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n모델이 이미 하드 드라이브에 있으면 상호 작용을 시작할 수 있습니다. 다음 명령어로 콘솔에서 수행할 수 있어요:\n\n```js\nollama run llama:13b\n```\n\nEnter 키를 누르면 다음 메시지가 표시됩니다:\n\n 메시지를 전송하세요 (도움말을 보려면 /?)\n\n<div class=\"content-ad\"></div>\n\n이제 모델이 준비되어 입력을 받을 준비가 되었습니다. 리눅스 환경에서 모델을 실험하고 탐색하여 기능을 느끼고 전파를 연습할 수 있습니다. 상호 작용은 다음과 같아야 합니다:\n\n![image](/assets/img/2024-05-20-RunningLargeLanguageModelsonyourPCprivacyandbeyond_5.png)\n\n이제 1단계인 리눅스 및 LLM 설치를 마치며 마무리합니다. 이제 인터넷 연결 없이도 로컬 PC에서 LLM을 실행하고 사용할 수 있습니다.\n\n다음 글에서는 컨테이너를 위해 Docker를 설치하고 모델을 위한 웹 인터페이스를 설치하고 모델을 훈련 및 최적화하는 데 도움이 되는 기타 Python 라이브러리와 도구를 검토할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n다음에 또 봐요!\n\nStan","ogImage":{"url":"/assets/img/2024-05-20-RunningLargeLanguageModelsonyourPCprivacyandbeyond_0.png"},"coverImage":"/assets/img/2024-05-20-RunningLargeLanguageModelsonyourPCprivacyandbeyond_0.png","tag":["Tech"],"readingTime":4},{"title":"GA4 BigQuery 원시 데이터 이해하기 컨센트 모드 활성화된 상태","description":"","date":"2024-05-20 21:34","slug":"2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated","content":"\n\nGA4 동의 모드가 BigQuery에 미치는 영향은 때로는 평가하기 어려울 수 있습니다. 반면 “쿠키 없는 핑”을 통해 수집된 데이터는 설계상 매우 복잡하여 결합하거나 분석하기 어렵습니다.\n\n일부 또는 전체적으로 무시해야 할까요? 받아들여야 할까요? 아니면 모든 것을 파괴하러 가야 할까요? 이 문제를 해결하는 데 도움을 드리고, 두뇌가 녹아내리는 것을 방지하기 위한 잠재적인 솔루션을 제안해 드리겠습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:960/1*Bq0dEk71wL82uIknalortw.gif)\n\n# 왜 이것에 대해 이렇게 많은 소란이 있는 걸까요?\n\n<div class=\"content-ad\"></div>\n\n개인 정보 보호 규정이 적용되는 국가에서 활동하고 계신 경우, 데이터 수집 전에 사용자의 동의를 요청하는 것이 법적으로 의무화됩니다. GA4는 이러한 데이터 손실에 강하게 영향을 받습니다. 그래서 그들은 \"쿠키 없는 핑\"을 소개했습니다. 이제 사용자들이 동의를 제공하지 않더라도 당신은 그들의 데이터를 수집할 수 있습니다. 사용자가 동의를 제공하지 않는 경우, 익명 이벤트를 수집하여 GA4가 웹사이트 활동의 현실을 모형화하는 데 도움을 줄 수 있습니다. 이로 인한 데이터에 대한 영향 몇 가지를 살펴보겠습니다:\n\n# 사용자 의사 ID가 없음\n\n▶ 해당 이벤트에는 \"user_pseudo_id\"가 없을 것입니다. 일반적으로 쿠키를 기반으로 사용자를 계산하는 데 사용하는 것입니다. 만약 사용자 ID가 있다면, 수집하지 않도록 규칙을 마련해야 할 것입니다. 이 부분은 귀하의 법률팀이 결정하도록 하겠습니다.\n\n![이미지](/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 세션 ID가 없음\n\n▶ 해당 이벤트에는 ga_session_id 매개변수가 포함되어 있지 않습니다. 참 좋죠?\n\n![이미지](/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_1.png)\n\n# 신뢰할 수 없는 session_start 및 first_visit\n\n<div class=\"content-ad\"></div>\n\n▶ 각 페이지 다시로드는 새로운 first_visit 및 session_start를 발생시킵니다. 이는 해당 이벤트로 새 사용자 또는 세션을 계산할 수 없음을 의미합니다.\n\n![이미지](/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_2.png)\n\n# 싱글 페이지 앱의 경우\n\n▶ ... Singe Page Apps의 경우, 기술적으로 페이지 컨텍스트가 페이지를 변경할 때 다시로드되지 않습니다. 그러나 사람들이 수동으로 페이지를 새로 고치거나 \"새 탭\" 내부 링크를 통해 이동하는 경우 다시로드될 수 있습니다. TLDR: 여전히 신뢰하기 어렵고, \"비슷하지만 다름\"입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_3.png)\n\n# 방문 지표를 비교할 때 무슨 일이 벌어질까요?\n\n같은 기간 동안 두 시스템에서 사용하는 간단한 쿼리를 아래에서 확인할 수 있습니다. 사용자 ID를 수집하지 않는 속성에 대해 GA4는 세션, 사용자 및 신규 사용자를 추정하며, 분명히 원시 데이터만 사용하지 않습니다.\n\n![이미지](/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n아래처럼 해드릴게요:\n\n\n<img src=\"/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_5.png\" />\n\nGA4이 이벤트에 기반한 메트릭(new_users 및 세션)을 계산할 때, 상황이 약간 복잡해집니다. 이벤트 수를 알고 있는데도 불구하고 실제 데이터가 아니라는 것을 인지합니다. 데이터베이스의 고유 사용자 키에 기반한 메트릭인 경우, 데이터가 부족하다는 점을 감안해 그 수치를 팽창시킵니다.\n\n# 특정 이벤트를 비교하면 무슨 일이 벌어질까요?\n\n\n<div class=\"content-ad\"></div>\n\n\n# 문제 해결 방법은 무엇인가요?\n\n빅쿼리(BigQuery)에서 이벤트와 방문 메트릭을 조심스럽게 사용하는 벙법\n첫 번째 황금 규칙은 아마도 빅쿼리에서 사용자와 세션을 생각하는 것을 그만두는 것입니다. 그렇지만 한번 그렇게 생각한다면 조심해야 하고 절대 숫자가 아닌 추세만 보도록 해야 합니다. 하지만 추세조차도 조심해서 봐야 하는데, 쿠키 동의율의 변화가 추세에 영향을 줄 수 있기 때문입니다. 예를 들어, 배너에서 팝업으로 전환하면 동의율이 확실히 높아져서 더 많은 방문자가 표시될 수 있습니다.\n\n보고서에서 동의하지 않은 사람들 제외하기\n두 번째 가능성은 이벤트 수집에 동의하는 사람들만 분석하는 것입니다. 이 것은 구현하기 가장 쉬운 해결책입니다(\"where user_pseudo_id is not null\"을 사용하면 됨). 그러나 동의율이 대중 중에 통계적으로 동일하지 않다는 점을 이해해 주세요. 연구에 따르면 브랜드/웹사이트를 이미 알고 있는 사람들의 경우 동의율이 더 높아진다는 것을 보여주며 새로운 편향을 고려해야 합니다. 게다가 최종 사용자들이 \"GA4 인터페이스와 동일한 숫자를 얻는 것\"에 대해 걱정한다면(해석해서는 안 되지만, 믿어줘요 모두에게 쉽게 이해되지 않는 것입니다), 이 기술만으로는 작동하지 않을 것입니다.\n\n일부 메트릭을 위해 API 사용하기\n사용자 흐름 분석이나 대부분의 전자상거래 보고서에는 원시 데이터를 계속 사용하고, 트래픽 획득과 같은 보고서를 추출하기 위해 API를 사용합니다. 이것은 대개 수치가 거의 (아래 참조) 인터페이스와 일치한다는 것으로 사업 사용자들에게 많은 신뢰감을 줍니다. Airbyte나 Meltano과 같은 도구들은 매우 쉽게 이 작업을 수행하지만 유지할 파이프라인을 추가해야 합니다... 누가 새로운 파이프라인을 유지하는 것을 좋아할까요?\n\n<div class=\"content-ad\"></div>\n\n또한 API(및 인터페이스)에는 매우 기뻐할만한 단점이 하나 있습니다. 마음이 편안해지도록 알려드리기 전에: 보고서의 모든 라인 값의 합계가 보고서가 표시하는 총합보다 항상 높습니다. 네, 이것은 끔찍한 문제입니다.\n\n![이미지](/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_7.png)\n\n더 알고 싶다면 저에게 연락해주세요. 결국 이에 대해 기사를 작성할 예정입니다.\n\nBigQuery에서 GA4 모델 복제\n당신의 솔루션 중 가장 흥미로우면서 복잡한 부분입니다. 그들이 하는 것을 왜 당신도 할 수 없을까요? 데이터도 있으니 그렇게 복잡하지 않을 것입니다, 맞죠?\n\n<div class=\"content-ad\"></div>\n\n저도 아직 시도해보지 않았어요, 하지만 그렇다고 둘려쌓인 일을 두려워하거나 그만큼 열망하지도 않아요. 이미 이야기를 알고 있어요: 합리적인 시간 내에 흥미로운 첫 결과물을 얻으면 흥분되고 자신감을 얻게 되면서 거의 사용할 수 있을 거라고 느끼지만, 실제로 제품으로 출시하기 위한 마지막 20%의 노력은 사실 프로젝트 시간의 80%에 해당한다는 것을 알아요. 악마는 세부 사항에 있다는 거죠.\n\n![이미지](/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_8.png)\n\n또 하나: 모델에서 Google이 내 소유 데이터만 사용하는지 정말로 알 수 없어요. 그들은 지구상의 대다수 웹사이트 데이터에 접근할 수 있어요. 아마 그들은 자신의 모델을 훈련시키는 데 사용했을지도 몰라요? 그건 블랙박스죠.\n\n요즘 LinkedIn 게시물에서 POC(Concept of Proof)를 본 적이 있는데, 기초 통계 계산을 사용하여 그런 지표를 모델링한다는 내용이었어요. 예를 들어, 동의 데이터의 각 세션과 사용자에 대한 이벤트 수를 가져와서 비동의 데이터의 지표를 추론해요. 통계적으로 허용되려면, 동의한 방문자와 동의하지 않은 방문자가 같은 행동을 한다는 것을 확인해야 해요. 이미 논의한 바 있는데, 연구에 따르면 그들은 다르다는 걸 보여줬어요. 그래서 그 가치가 무엇인지 알기 어려워요 ¯\\_(ツ)_/¯\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n![이미지](/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_9.png)\n\n이 문제에 대해 완벽한 해결책이 없다는 것은 실망스러울 수 있지만, 이 글은 해당 주제에 대한 제 경험에 대해 좋은 개요를 제공해줍니다.\n\n본문에서 강조한 해결책들은 상황과 팀의 성숙도에 따라 모두 함께 사용하는 것이 좋습니다. 다시 한 번 강조하지만, 너무 깊게 생각하지 마세요. 웹 분석뿐입니다. 데이터를 그대로 받아들이고, 이 지식을 비즈니스 사용자와 공유하며, 분석을 진행할 때 편향을 고려하면 훨씬 더 효율적일 것입니다.","ogImage":{"url":"/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_0.png"},"coverImage":"/assets/img/2024-05-20-UnderstandtheGA4BigQueryrawdatawithconsentmodeactivated_0.png","tag":["Tech"],"readingTime":5},{"title":"틱톡의 개인정보 처리 방침 당신의 디지턈 일기에 몰래 엿보기","description":"","date":"2024-05-20 21:30","slug":"2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary","content":"\n\n최근 몇 년간 소셜 미디어는 디지털 호기심에서 수십억 명의 사람들에게 일상의 중심이 된 기초 요소로 발전해 왔습니다. Facebook, Instagram, X (이전 트위터), TikTok과 같은 플랫폼들은 의사 소통, 엔터테인먼트, 교육 (가끔), 심지어 비즈니스를 위한 주요 채널들로 성장했습니다. 이 인기 폭발적인 상승은 플랫폼이 작동하는 방식을 이해하는 것의 중요성을 보여줍니다. 특히 이용 약관과 개인정보 보호 정책에 관련하여 이해하는 것이 중요합니다.\n\n이해하는 것이 왜 중요한지 궁금하신가요? 먼저, 이용 약관은 사용자로서 당신에게 기대되는 것과 플랫폼에서 기대할 수 있는 것을 개요로 제시합니다. 더 중요한 것은 개인정보 보호 정책이 당신의 개인 정보가 어떻게 수집되고 사용되며 보호되는지를 알려줍니다. 개인 정보 보호, 보안, 데이터 누출 및 남용에 대한 우려가 커짐에 따라, 이러한 정책의 내부 사항을 알고 있다면 온라인에서 공유할 정보 및 그 정보가 사용될 수 있는 방식에 대한 균형 잡힌 결정을 내릴 수 있습니다.\n\n예를 들어, 개인 정보 보호 정책을 통해 소셜 미디어 플랫폼이 당신의 정보를 제3자에게 판매하거나 광고를 타겟하여 사용하는지, 또는 브라우징 습관에 대한 정보를 수집하는지 등을 확인할 수 있습니다. 이러한 세부 사항을 알고 있다면 프로필 설정을 조정하거나 게시물을 더 신중하게 선택하거나 어떤 플랫폼을 사용할 가치가 있는지를 결정하는 데 도움이 될 수 있습니다.\n\n대규모 사용자 기반과 영향력을 감안할 때, TikTok의 개인 정보 보호 정책을 사례 연구로 살펴보기로 결정했습니다. 우리의 목표는 데이터 수집 관행부터 동의 및 데이터 공유 정책까지 사용자들이 알아야 할 통찰을 발굴하고 강조하는 것입니다. 제 목표는 독자들이 플랫폼에서 안전하고 자신감 있게 활동할 수 있는 지식을 제공하는 데 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_0.png)\n\n# 전채\n\n이것은 틱톡의 개인 정보 보호 정책입니다 (최종 업데이트 2024년 1월 24일) - 틱톡이 여러분이 해당 앱, 웹사이트, 소프트웨어 또는 틱톡과 연결된 어떤 서비스를 사용할 때 어떻게 여러분의 개인 정보를 처리하는지 설명하는 규정서입니다. 사용하는 기기에 상관없이 적용됩니다.\n\n## 이 정책은 누구에게 적용되나요?\n\n<div class=\"content-ad\"></div>\n\n이 정책은 TikTok을 사용하는 누구에게나 13세 이상을 대상으로 합니다. 13세 미만인 경우에는 어린이 개인정보 보호 정책이 따로 있습니다.\n\n## TikTok은 우리에 대해 어떤 정보를 수집할까요?\n\nTikTok은 다음과 같은 정보를 수집할 수 있습니다:\n\n- 제공하는 정보. 이는 앱 또는 웹사이트에 입력한 모든 것을 포함합니다. 예를 들어 이름, 이메일 또는 게시물 등이 있습니다.\n- 다른 사람으로부터 수집한 정보. 가끔, TikTok은 다른 사용자나 제3자 서비스와 같은 다른 곳에서 여러분에 대한 정보를 얻을 수 있습니다.\n- 자동으로 수집된 정보. TikTok은 여러분이 수동으로 입력하지 않아도 앱의 사용 방식이나 위치와 같은 여러분에 대한 일부 정보를 자동으로 수집할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 당신이 제공한 정보\n\n틱톡 가입하려고 하는 거야? 준비해; 그렇다면 다음 정보를 공유할 수도 있어:\n\n- 기본 정보. 무심결에 시작되지만 — 이름, 나이, 사용자 이름, 비밀번호 — 예상한 것들이야. 하지만 그 후로, 이메일, 전화번호, 소셜 미디어 계정 정보를 요구할 거야. 아, 그리고 프로필 사진도 요구할 거야. 디지털 사람들 속에서 어떻게 당신을 알아볼까요?\n- 당신의 창작물. 자발적인 춤 비디오나 고양이의 캔디드 샷? 틱톡은 이것들을 모두 저장할 거야. 그리고 언제, 어디서, 그리고 어떤 필터들을 사용했는지 모조리 기억할 거야. 틱톡 사용자가 아니지만 친구의 비디오에 나왔다면? 놀랍지만, 당신도 콜렉션의 일부로 간주돼.\n- 채팅 내역. 보낸 모든 메시지? 틱톡은 이것들을 전달하는 것뿐만 아니라, 마을 소문처럼 정보들을 상세히 저장할 거야.\n- 클립보드 확인. 매운 미미나 민감한 비밀번호를 복사했냐고? 만약 틱톡을 사용 중이라면, 그것도 엿볼 수 있어.\n- 쇼핑 스토커. 틱톡 상품을 사게 됐을 때? 영수증은 그들이 갖고 있어, 말 그대로. 당신의 신용 카드 정보부터 집 주소까지, 모두 기록되어 있어.\n- 연락처 조사. 연락처를 통해 친구를 찾기로 했다고요? 틱톡은 그들만의 전화번호부처럼 당신의 전화 정보를 조사하며, 이름, 전화번호, 소셜 프로필 등 모두 훔칠 거야.\n- 본인 확인. 계정을 확인해야 한다면? 신분증을 선보일 시간이야.\n- 설문 조사. 설문이나 대회에 참여하게 되면, 그저 이기기 위한 기회뿐만 아니라 개인 정보를 더 많이 제공해야 해요. 당신의 성별, 나이부터 취미까지, 틱톡은 당신에 대한 프로필을 상세히 작성할 거야. 이것이 당신의 이력서보다도 상세할지도 몰라.\n\n틱톡에서 한 번의 탭, 입력, 셀카도 당신에 대해 수집하는 방대한 정보의 한 부분이 되어. 그들은 모든 것을 당신의 경험을 개선하기 위한 것이라고 약속하지만, 정말로 개인화된 것과 침입적인 것의 경계는 어디에 있는지 궁금해질 수밖에 없어. 틱톡의 데이터 제국의 광대한 체계 속에서, 우리는 사용자인가 혹은 사용되는 쪽일까?\n\n<div class=\"content-ad\"></div>\n\n![2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_1.png](/assets/img/2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_1.png)\n\n# 다른 소스로부터의 정보\n\n틱톡은 당신이 자발적으로 그들의 앱에 놓친 것만으로 만족하지 않습니다; 그들은 당신에 대한 데이터를 어디에서든 끌어모읍니다. 마치 당신의 디지턈 DNA를 한 줄씩 조립하는 것처럼, 그리고 그들이 그렇게 하는 방법은 다음과 같습니다:\n\n- 사이드 도어를 통해. 소셜 미디어 및 다른 로그인. 편한 로그인 옵션으로 Facebook, Google 또는 Instagram을 선택했나요? 축하합니다, 당신은 방금 틱톡에 당신의 공개 프로필, 이메일 및 연락처에 대한 황금열쇠를 건넸습니다. 안전하게 보관되어 있는 것으로 여겼던 조각 정보조차 이제는 틱톡에 공개되었습니다. 갑작스럽게 당신의 별개의 온라인 생활이 더 이상 분리되어 보이지 않네요.\n- 첩자들. 광고업자들과 협력사들. 그들은 틱톡에 정보를 푸널링하는 파트너 네트워크를 보유하고 있습니다. 다른 사이트에서 클릭한 스니커즈 광고? 틱톡은 앎니다. 앱에서 한 밤의 쇼핑 열풍이 있었나요? 틱톡은 영수증을 보유하고 있습니다. 마치 당신이 한 디지턈 움직임을 카탈로그로 만들어 돌아오는 그림자가 있는 것처럼서입니다.\n- 가족관계. 계열회사들. 틱톡의 거대한 회사 그룹이 당신에 대해 알고 있다면, 그 데이터는 틱톡이 알고 있을 것입니다. 관련 앱이나 서비스를 사용했나요? 그 데이터는 틱톡으로 이동할 수 있어서 그 서버에서 당신의 프로필을 더 확실하게 만들 것입니다.\n- 입소문. 다른 사람들로부터의 정보. 비디오에서 언급된 적이 있거나 누군가가 당신의 연락처 정보를 틱톡과 공유한 적이 있나요? 그것은 허락을 받지 않아도 당신의 프로필에 추가되는 또 다른 퍼즐 조각입니다.\n- 정찰단. 외부 소스들. 틱톡의 촉수는 더 나아가서 공공 기록, 전문가 그룹 및 어디에서 어디까지든 데이터를 끌어모읍니다. 당신의 개인정보 설정이 얼마나 엄격하든 상관없습니다; 있다면, 틱톡이 그것을 캐내다가 있을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n모든 이는 TikTok이 그들의 플랫폼에서 하는 일만을 주시하는 것이 아니라, 당신의 디지털 생활을 전반적으로 보고 있다는 것을 의미합니다. 맞춤형 콘텐츠와 광고는 멋진 트릭처럼 보일 수 있지만, 이들은 당신의 개인 정보를 희생하게 만들어 자세한 프로필로 이어지며, 디지턈 라인업에서 당신을 대신할 수도 있을 만큼 세밀합니다. TikTok은 이 모든 것이 더 나은 사용자 경험을 위한 것이라고 확신시켜 주지만, 우리가 언제 이렇게 철저하게 알려지기로 동의했는지 궁금할 때가 있습니다.\n\n![이미지](/assets/img/2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_2.png)\n\n# 놀라운 자동 수집 정보\n\nTikTok은 넓은 데이터 수집 네트워크 덕분에 우리를 우리 자신보다 더 잘 알고 있는 것 같습니다. 앱은 이 모든 것이 경험을 맞춤화하는 데 도움이 된다고 주장하지만, 그들이 빨아들이는 데이터 양을 생각해보면 화면을 멈춰있게 만듭니다. TikTok이 가지고 있는 디지털 도시에 대한 파일을 하나씩 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## 미션: 스파이로 로그인\n\n- IP 주소. 인터넷에서 기기의 홈 주소와 같은 작은 숫자? TikTok은 당신이 온라인에서 어디에 머무르는지 알아내기 위해 이를 사용합니다.\n- 지리 위치 데이터. 정확한 GPS 좌표를 가지고 있지 않을 수도 있지만, 인터넷 연결 덕분에 당신이 어디에 있는지에 대해 꽤 잘 알고 있습니다.\n- 고유 장치 식별자. TikTok은 장치가 가지고 있는 고유 ID로 당신의 전화를 식별할 수 있습니다. 네, 그들은 당신의 전화를 거의 당신만큼 잘 알고 있습니다.\n- 디지털 발자취. 당신이 앱에서 하는 모든 검색, 방문하는 모든 페이지 - 모두 목록에 올려져 있으며 분석할 준비가 되어 있습니다.\n- 쿠키. 이 디지털 쓰레기들은 당신의 로그인 세부정보를 기억뿐만 아니라 플랫폼에서 하는 모든 움직임을 기억합니다.\n\n## 현미경 아래에서\n\n- TikTok에서의 활동. 어떤 비디오가 당신을 웃게 만드는지, 공유할 만큼 좋아하는 비디오, 심지어 업로드를 결정하는 콘텐츠 - 모두 TikTok 매트릭스의 데이터 점입니다.\n- 기기 정보. iPhone 소유자인지 아니면 Android 사용자인지, TikTok은 메모를 하며 성능을 맞춤화하여 당신을 못 놓을 만큽 유도합니다.\n\n<div class=\"content-ad\"></div>\n\n## 무서운 세부사항\n\n- 밤늦게 스크롤하고 타이핑하는 습관. TikTok은 당신의 휴대폰 배터리나 탭 및 스와이프 방식에 따라 당신이 잠자리에 들려고 할 때를 알아낼 수 있습니다. 그리고 네, 그들은 당신이 키보드에 실제로 입력하는 내용까지 알고 있습니다 (!)...\n- 위치, 위치, 위치. 모든 다크룸을 추적하지는 않는다고 말하지만 여전히 당신이 어디에 있는지에 맞는 콘텐츠 및 광고를 제공합니다.\n- 게시물 들여다보기. 비디오의 배경부터 음성까지, TikTok은 모든 것을 분석하고 있으며 생체 인식 데이터까지 수집할 수도 있습니다. 동의하든 말든, 조금 지나친 것 같습니다.\n\n## 디지털 탐정 작업\n\n- 메타데이터 마이닝. TikTok은 단순히 당신이 올린 것뿐만 아니라 각 콘텐츠의 어디, 언제, 어떻게를 파헤칩니다.\n- 크로스 디바이스 추적. 핸드폰에서 태블릿, 노트북으로 이동하면서? TikTok은 여러 기기를 통틀어 당신의 활동을 연결하여 디지털 생활의 상세한 초상을 그려냅니다.\n\n<div class=\"content-ad\"></div>\n\n그게 무슨 뜻이죠? TikTok은 당신에 대한 도신자가 모아놓은 것만큼의 정보를 가지고 있을 수도 있어요. 당신의 늦은 밤 미미 세션부터 주말 여행을 담은 포스트까지, TikTok은 모든 것을 갖고 있어요. 약속은 더 개인화된 피드인 반면, 교환은 빅 브라더조차 놀라워할 정도의 감시 수준입니다. 디지털 스컬이 제게된 시대에서 TikTok은 아마, 우리가 너무 많은 것을 공유하는지에 대한 뚜렷한 알리미입니다.\n\n<img src=\"/assets/img/2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_3.png\" />\n\n# 이 모든 데이터로 TikTok은 무엇을 할까요?\n\n그렇다면, TikTok이 우리로부터 수집한 모든 정보를 정말로 어떻게 사용할까요? 그들은 이 모든 것을 우리의 TikTok 경험을 최대한 원활하게 만드는 데 사용한다고 말해요 - 앱을 버그 없이 유지하고, 고객 지원을 제공하고, 심지어 우리의 취향에 맞게 피드에 나타나는 내용을 맞춤화합니다. 듣기에는 멋지게 들리지만, 궁금한 이웃처럼 당신이 어떤 테이크아웃을 좋아하는지 추적하고 매일 무엇을 먹을지 결정하는 것과 조금 비슷해요.\n\n<div class=\"content-ad\"></div>\n\n우리 데이터를 사용하여 우리가 관심을 가질 만한 동영상을 보여주겠다고 주장합니다. 우리가 지역에서 트렌드인 것이나 이전에 시청한 것을 기반으로 추천해준다고 하네요. 우리가 좋아하는 컨텐츠를 보는 것도 멋지지만, 더 오래 화면에 묶여 있도록 하는 똑똑한 방법이기도 해요. 그리고 이 통찰력을 자기들만 가지고 있지 않고, 광고주들과 공유하고 있다고 합니다. 그래서 당신이 생각하던 스케이트보드 광고를 보게 되면 누구에게 감사를 표해야 할 지 아실 거예요.\n\nTikTok의 소셜 측면은 우리 데이터를 수집하는 이유 중 하나입니다. 관심사를 기반으로 친구와 크리에이터를 추천해주어 편리한데, 우리의 모든 행동을 추적해 온 것 같은 느낌을 줄 수도 있죠.\n\n앱과 상호작용하는 방식을 분석하여 더 나은 제안을 하고 우리의 나이나 관심사 같은 개인적인 것들까지 추측한다고 하네요. 자신을 더 잘 안다고 생각하는 친구가 있는데, 그게 바로 항상 지켜보고 있는 앱이란 점이죠.\n\nTikTok을 안전하게 유지하고 일부 기능을 위해 우리 신원을 확인하는 것은 존경스럽습니다. 그래도 안전을 위해서라면 얼마나 많은 감시에 동의하고 있는지 궁금해지지 않을 수 없네요.\n\n<div class=\"content-ad\"></div>\n\n그런 다음 의사 소통이 있습니다. TikTok으로부터 업데이트 또는 콘테스트에 대한 소식을 듣는 것은 펜팔로부터 편지를 받는 것 같은 느낌을 줄 수 있습니다. 다만, 이 경우에는 귀하의 개인 정보에 지나치게 관심이 많은 펜팔입니다.\n\n마지막으로, 그들은 위치 기반 서비스를 위해 우리의 데이터를 사용하고 기술을 개선하는 방법에 대해 언급합니다. 이는 기본적으로 우리의 모든 행동을 추적하고 예측하는 능력을 섬세하게 조정하고 있다는 것을 의미합니다. 그들은 심지어 우리의 모든 데이터를 섞어서 우리가 누구인지에 대한 더 완전한 그림을 얻으려고 합니다. 우리는 거대한 실험의 일부인 것처럼 느껴지며 실험 대상이자 제품이기도 합니다.\n\n요약하면, TikTok은 모든 이 데이터 수집을 우리의 이익을 위한 서비스 및 기능으로 제시하지만, 조금은 회의적일 수 없습니다. 결국, 무료 앱의 세계에서 제품에 대한 지불을 하지 않으면, 아마 그 제품인 것이기 때문입니다.\n\n![이미지](/assets/img/2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_4.png)\n\n<div class=\"content-ad\"></div>\n\n# 틱톡이 내 정보를 공유하는 방법\n\n틱톡은 신뢰를 중시하고 있다고 주장하며 개인 정보를 팔거나 관련 법률에 위배되지 않는 의심스러운 광고 목적으로 전달하지 않는다고 합니다. 하지만 우리의 정보가 실제로 언제 어떻게 전파될 수 있는지 알아보도록 해볼까요?\n\n- 서비스 제공업체 및 비즈니스 파트너. 틱톡은 결제 처리, 콘테스트 정리, 광고 보내기, 앱 유지 등과 같은 이유로 여러 회사에 우리의 데이터를 제공합니다. 모든 것이 원활하게 작동하도록 하는 것이라고 말하지만, 이러한 \"운영\"에 우리 정보가 얼마나 필요한지 의심해 볼 가치가 있습니다.\n- 기업 패밀리. 글로벌 기업의 일원으로, 틱톡은 앱을 지원하기 위해 우리의 세부 정보를 자사 기업 그룹 내에서 공유합니다. 관련 회사 네트워크에서 우리 데이터가 오가는 것을 상상하게 되면 이 내부적인 공유 파티의 범위에 대해 궁금해집니다.\n- 대규모 기업 이동. 틱톡이 매각, 통합 또는 브랜드 변경이 발생하면, 우리의 데이터도 거래의 일부가 됩니다. 이를 기업 세계에서의 필수 사항으로 제시하지만, 우리 정보가 협상 탁상에 토큰으로 사용될 수 있다는 생각은 약간 불안합니다.\n- 법적 사유. 틱톡은 법률이 요구하거나 자신의 이익을 보호하기 위해 당국에게 정보를 제공해야 할 수 있습니다. 법률을 준수하는 것은 하나지만, \"이익 보호\"와 \"보안\"이라는 넓은 용어는 다양한 정당화의 여지를 남겨 두고 있습니다.\n- 당신의 승인 하에. 우리가 승인을 한다면 정보도 공유할 것입니다. 이는 합리적으로 들리지만, 세부 사항과 우리가 모르게 동의할 수 있는 방법을 고려하면 조금 더 살펴볼 필요가 있습니다.\n- 제3자와의 협력. 틱톡의 다른 플랫폼과의 파트너십은 가입 및 콘텐츠 공유를 편리하게 하기 위해 우리의 정보를 공유합니다. 편의를 위해 제공되었다고 하지만, 우리의 틱톡 행동이 다른 서비스에 전파되는 것이 조금 침범적일 수 있습니다.\n- 공개 공유. 틱톡의 공개 게시물에 발을 담그면 우리의 정보는 누구에게나 공개됩니다. 틱톡은 여기에서의 책임을 회피하며, 공유하기 전에 재고할 것을 우리에게 상기시킵니다. 이는 맞지만, 그들은 플랫폼을 용이하게 제공하면서도 책임은 완전히 우리에게 떠넘기고 있습니다.\n- 틱톡 쇼핑. 틱톡을 통해 무언가를 구매하면 구매한 세부 정보가 판매자 및 거래에 관여하는 기타 사람들과 공유됩니다. 이는 쇼핑 과정의 일부로 제시되었지만, 구매 후에 우리 정보가 어떻게 사용되는지에 대한 투명성은 여전히 불분명합니다.\n\n틱톡의 정보 공유 방식은 정보의 양 뿐 아니라, 함께 공유하는 기업 네트워크의 방대함으로 인해 눈길을 끕니다. 이들은 이를 원할한 서비스 제공의 일환으로 소개하지만, 운영에 대한 필수성과 우리의 개인정보 보호권 사이의 섬세한 균형에 있어서 의심이 듭니다. 신뢰와 안전 보장의 말로 포장되어 있더라도, 우리의 데이터가 어디로 가고 어떻게 사용되는지 항상 주의해야 함을 상기시켜줍니다.\n\n<div class=\"content-ad\"></div>\n\n![TikTok Privacy Policy](/assets/img/2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_5.png)\n\n# 네, 권리와 선택권이 있어요\n\n잘했어요, 지금 틱톡의 개인정보 권리에 대한 이야기를 알아보려고 해봐요. 그들은 당신에게 아주 관대하게 당신에 대한 정보를 보거나 수정하거나 심지어 삭제할 수 있다고 말합니다. 단순히 그들의 지정된 웹페이지를 통해 연락하거나, 올드스쿨하게 느낀다면 그들의 실제 주소로 요청을 보내세요. 프로필을 업데이트하거나 틱톡 데이터를 확인하고 싶나요? 앱 설정으로 이동하세요. 또한 계정을 비활성화하거나 삭제할 수 있는 옵션이 있어요, 아마도 당신에게 통제를 주는 것과 관련이 있겠죠.\n\n당신의 개인정보에 대한 우려를 처리할 수 있는 공인 대리인이 있나요? 그들의 적법성을 증명하기 위해 막다른 상황을 겪을 준비를 해야 할 거에요. 틱톡은 이 특별한 대리인이 당신을 대신하여 보낸 증거인으로 보유권 또는 일부 견고한 서면증거를 보기를 원합니다.\n\n<div class=\"content-ad\"></div>\n\n그들은 매우 민감한 정보(예: 금융 상세정보 또는 운전 면허 번호)를 수집한다고 우리를 달래려고 노력합니다. 이 정보는 물건을 판매하거나 신분을 확인하는 등 필수적인 용도로만 사용된다고 말이에요. 이렇게 안심시켜 주는 게 어떨까요?\n\n## 그리고 당신의 선택은?\n\n트래킹을 제한하기 위해 쿠키를 피하려고 생각 중이신가요? TikTok은 브라우저 설정을 조정하는 것을 제안하지만, 주의하세요. 각기 다른 기기와 브라우저에 대해 설정을 별도로 조정해야 한다는 점을 명심하세요. 타겟팅 광고를 거부하고 싶다면? 편리한 링크를 제공하지만, 광고주들에게 웹 사이트 주위를 따라다니지 않도록 예의 바로 말하는 것과 비슷합니다.\n\n또한 기기 설정을 조정하여 TikTok이 수집하는 정보 중 일부를 제한할 수도 있습니다. 따분한 광고 ID를 제한해 보세요. 마케팅 이메일에 싫증이 나신다면? \"구독 취소\" 옵션을 선택할 수 있는 디지털 탈출구가 항상 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위치 추적에 관해서 TikTok은 \"걱정하지 마세요, 미국 사용자들로부터 GPS 데이터 수집을 중단했습니다.\"라고 말합니다. 그러나 이전 버전의 앱을 사용 중이라면 GPS 데이터를 수집한 적이 있을 수 있으니, 기기에서 해당 권한을 비활성화해야 합니다.\n\n또한 브라우저의 \"추적 금지\" 신호가 모든 것을 해결해줄 것이라고 기대하면 안 됩니다. TikTok은 이 신호를 무시하고 있다는 입장입니다.\n\n요컨대, 여러분의 개인 정보를 관리할 수 있는 다양한 옵션이 제공되지만, 그 곁에는 회의론적인 분위기가 감싸고 있습니다. 권리와 선택권이 있다는 것은 좋지만, 그것들을 탐색하는 것은 이어폰 선을 풀어내는 것처럼 지루하고 조금 짜증나는 일입니다. 모든 데이터 수집이 진행되는 가운데, 이러한 권리를 행사하는 것이 바다를 작은 숟가락으로 비우려는 것과 같은 일인지 궁금해집니다.\n\n![이미지](/assets/img/2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_6.png)\n\n<div class=\"content-ad\"></div>\n\n# 왜 이런 것들이 걱정되는 이유?\n\n여기에 이유가 있어요:\n\n- 개인정보? TikTok 세계에 참여하면 디지털 생활 열쇠를 건네주는 셈입니다. 즐겨 찾는 카페에서의 셀카나 위치 태그는 팔로워뿐만 아니라 자상하지 못한 사람들에겐 잠재적인 금물일 수 있어요. '개인적' 정보가 사기 도시와 개인정보 침해빌을 들려다니는 세계투어를 떠날 순 없잖아요.\n- 공유는 사랑이 아닐 수 있어요. TikTok의 정보 공유 정책은 극성 댄스 챌린지보다 더 많은 정보를 전달할 수 있어요. 당신의 취향, 비호감, 밤늦은 간식 욕망도 광고주 및 누구나 당신이 계속 스크롤링하고 소비하는 온라인 세상을 맞추기 위한 자신만의 침입 구실이 될 수 있어요. 마치 눈에도 보이지 않는데 감시 당하고 있는 기분이 들지 않나요?\n- \"안전\"은 그저 말 뿐이에요. TikTok은 당신의 데이터를 보안보다 한 금고처럼 지킨다고 약속하지만, 디지털 세계에서 \"뚫리지 않는\" 보안은 실재보다는 신화에 가까워요. 데이터 유출이나 해킹 가능성은 게시물, 좋아요, 공유에 위협이 되는 칼로 드라마클레스처럼 매달려 있어요.\n- 제어? 운이 좋아라. TikTok에 게시하는 것은 디지털 바다로 병을 띄우는 메시지를 보내는 것과 같아요. 그것이 어디에 도착하고 누가 여는지 정확히 알 수 없어요. 그 순간성 스토리나 즉흥적 댓글은 당신이 이동한 뒤에도 예상치 않게 일어날 수 있어요.\n\nTikTok은 재미와 게임으로 보일 수 있지만, 개인정보와 보안 문제는 실제로 중요한 문제예요. 게임의 규칙이나 위험을 완전히 이해하지 않고 게임에 참여하는 것과 같아요. 흥미로워 보일 수 있겠지만, 당신이 예상보다 더 많은 위험에 직면할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 고지사항\n\n본 문서에 제공된 정보는 정보 및 교육 목적으로만 제공되며 법률 자문이나 법률 자문 대체로 사용되지 않으며 법률 자문으로 사용되어서도 안됩니다. 본 문서의 콘텐츠의 정확성과 완성도를 보증하기 위해 노력했지만, 법적 원칙과 규정은 관할권과 구체적 상황에 따라 상당히 다를 수 있음을 감안해야 합니다. 따라서 이 문서는 확정적인 법률 자료로 사용되거나 법률 결정의 근거로 사용되어서는 안됩니다. 독자는 각 개별 사례가 상세하고 개인화된 법적 분석을 필요로 할 수 있으므로 법률 문제나 사항에 대한 자문을 받기 위해 적격한 변호사와 상의하도록 권장됩니다.\n\n이 문서에 제공된 정보만을 의존하고 변호사로부터 전문 자문을 구하지 않으면 예기치 않은 법적 결과나 오해로 이어질 수 있습니다. 이 문서의 저자나 출판사는 발생 가능한 오류나 누락에 대한 책임을 지지 않으며 본 문서의 표시나 사용으로 인한 손실, 부상 또는 손해에 대해 책임을 지지 않을 것입니다. 여기 제공된 정보는 독자와 저자 또는 출판사 간의 변호사-의뢰인 관계를 생성하지 않습니다.","ogImage":{"url":"/assets/img/2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_0.png"},"coverImage":"/assets/img/2024-05-20-TikToksPrivacyPolicySneakyGlanceintoYourDigitalDiary_0.png","tag":["Tech"],"readingTime":13},{"title":"인공지능 얼굴 인식 금지 조치의 해결책 및 경찰에서 불량한 인공지능 제품의 위험 요소","description":"","date":"2024-05-20 21:29","slug":"2024-05-20-WorkaroundofAIFacialRecognitionBansandthePitfallsofDefectiveAIProductsinLawEnforcement","content":"\n\n\n![Workaround of AI Facial Recognition Bans and the Pitfalls of Defective AI Products in Law Enforcement](/assets/img/2024-05-20-WorkaroundofAIFacialRecognitionBansandthePitfallsofDefectiveAIProductsinLawEnforcement_0.png)\n\n지역 경찰이 얼굴 인식 기술 사용을 금지하는 오스틴과 샌프란시스코와 같은 도시들이 이를 시행함에 따라, 수사기관은 경찰 내 피해가 감지되는 기술의 더 큰 문제를 강조하는 회피 방법을 찾고 있습니다. 이 기사에서는 경찰이 이러한 금지 조치를 우회하기 위해 사용하는 방법, Clearview AI와 같은 기술에서 내재된 부정확성 및 COMPAS와 같은 알고리즘 도구의 불투명한 사용 등을 탐구합니다.\n\n\n<div class=\"content-ad\"></div>\n\n페이셜 인식 기술이 금지된 도시들에서는 경찰 사무소가 해당 제한이 없는 인접 지역의 담당자들과 협력했습니다. 이 협력은 일반적으로 용의자 이미지를 식별 목적으로 공유함을 포함하며, 현지 금지 조항을 우회하는 효과를 냅니다. 이러한 실천은 로컬 규정의 효과성 뿐만 아니라 중요한 프라이버시 및 시민 자유 우려를 제기합니다.\n\n출처: 워싱턴 포스트의 경찰 문서 검토\n\nClearview AI의 결함\n\n경찰이 사용하기 위해 검토된 AI 기술 중 Clearview AI는 수십억 장의 인터넷 이미지를 스크래핑하는 방식과 그 얼굴 인식 알고리즘의 부정확성으로 인해 상당한 비판을 받았습니다. 특히 이 소프트웨어는 범죄 기록이 없는 공인 인물과 국회의원을 잘못 식별하여 범죄자로 지목했는데, 이는 그 신뢰성의 심각한 결함과 해로운 잘못된 식별의 가능성을 강조하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n소스: Clearview AI에 대한 공개 기록 및 입법 청문회.\n\nCOMPAS 및 \"블랙박스\" 딜레마\n\n주목할만한 윈콘신 주 대 루미스 사건 등 사법 환경에서 COMPAS 소프트웨어를 사용하는 것은, 수사 기관에 문제가 있는 AI 응용 프로그램의 또 다른 차원을 보여줍니다. 피의자의 재범 가능성을 평가하기 위해 사용되는 COMPAS는 위험 평가에 영향을 미치는 요소에 대해 적은 투명성을 가지고 \"블랙박스\"로 작동하며, 이는 판결 실천에서 공정성과 책임성 문제를 제기합니다.\n\n소스: 윈콘신 주 최고 법원 문서 및 법률 제도에 관한 AI 투명성에 대한 학술 분석.\n\n<div class=\"content-ad\"></div>\n\n윤리 및 개인 정보 보호 문제\n\n법 집행에서 AI 기술을 도입하는 것은 다양한 윤리적 및 개인 정보 보호 문제와 교차합니다. 이에는 얼굴 인식 기술의 인종적 편향, 데이터의 비동의적 수집에 대한 우려, 그리고 적절한 투명성과 감시 없이 이루어지는 감시의 보다 광범위한 영향 등이 포함됩니다.\n\n출처: 학술 연구 및 개인 정보 보호 단체 보고서.\n\nAI 및 법 집행에 대한 디스토피아적 시각\n\n<div class=\"content-ad\"></div>\n\n점점 더 디스토피아 소설의 어둠 같은 상황 속에서, 경찰 조직에서 AI 기술을 도입하는 것은 디지털 시대의 대첩 정보기술 전술로 해석될 수 있는 냉혹한 방향을 향하고 있습니다. 오스틴과 샌프란시스코와 같은 도시들은 얼굴 인식 기술 금지법을 발포했지만, 이웃 지역의 경찰 부서들과의 협력을 활용하는 경찰 부서들에 의해 권모술수로 물리쳐지고 있습니다. 이 전략적 우회는 전체주의 국가에서 기대할 수 있는 모습과 뼈아픈 유사성을 보여주며, 지역 민주주의 결정의 본질을 획기적으로 훼손시키며 공공안전의 입장으로 공정 절차 권리를 침해할 가능성이 있습니다.\n\n게다가, COMPAS와 같은 AI 시스템의 그림자 같은 오퍼레이션은 사법 체계에 오웰리안 통제의 또 다른 층을 더합니다. 이 \"흑색 상자\" 도구들은 개인들의 운명을 결정하지만 그들에게 그 근거를 이해하거나 논의하거나 묻는 권리를 부여하지 않습니다. 알고리즘 판결에서의 투명성과 책임감의 부재는 개인들의 권리를 제거할 뿐만 아니라 정의의 개념 자체에 어두운 그림자를 드리우고 있습니다.\n\n이 길을 더욱 탐험할수록, 정의와 개인의 자유 원칙 자체가 위험에 처합니다. 문제는 새로운 도구들을 범죄와의 전투를 위한 도구로 채택하는 것뿐만이 아니라, 디스토피아 사회로의 첫걸음으로 볼 수 있는 무관심하고 책임감 없는 알고리즘 통치가 대신하고 있는 점입니다. 이 현실 세계 시나리오에서, 기술의 자기 과도한 확장에 사로잡힌 사회는 현재의 현실과 일맥상통합니다 — 기술이 단순한 도구가 아니라 사람의 효율성에 대한 비인간적이고 냉소적인 권위자로 변모합니다. 이것은 단지 범죄에 대항하기 위한 새로운 도구의 채택이 아니라, 개인과 국가 간의 관계의 본질적 재편이며, 이는 사회 구조 자체를 영구적으로 바꿀 수 있는 변화일 수 있습니다. 1984년 아무도?","ogImage":{"url":"/assets/img/2024-05-20-WorkaroundofAIFacialRecognitionBansandthePitfallsofDefectiveAIProductsinLawEnforcement_0.png"},"coverImage":"/assets/img/2024-05-20-WorkaroundofAIFacialRecognitionBansandthePitfallsofDefectiveAIProductsinLawEnforcement_0.png","tag":["Tech"],"readingTime":3}],"page":"55","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}