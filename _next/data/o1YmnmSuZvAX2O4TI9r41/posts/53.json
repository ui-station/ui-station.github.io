{"pageProps":{"posts":[{"title":"제이미니 API 사용 전에 읽어보세요","description":"","date":"2024-05-23 13:15","slug":"2024-05-23-ReadthisBeforeUsingGeminiAPI","content":"\n\n## Gemini API를 최대한 활용할 수 있도록 도와주는 개발자 안내서\n\n안녕하세요 👋🏻\n\n앱에 Gemini API를 사용하고 싶으신가요? Gemini AI 매개변수를 효과적으로 활용하는 방법은 무엇인가요? Gemini AI를 사용할 때 주의해야 할 점은 무엇일까요?\n\n![이미지](/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png)\n\n<div class=\"content-ad\"></div>\n\nGemini AI를 처음 사용하시는 분이라면, 이는 텍스트, 이미지 및 오디오 등 다양한 유형의 데이터 입력에서 콘텐츠를 생성할 수 있는 모델로 정의되는 생성적 AI입니다.\n\n## Gemini API를 사용해야 하는 이유\n\n아마도 몇몇 분들은 \"Gemini 앱이 있는데, 왜 Gemini API를 사용해야 하죠?\" 라고 물을지도 모릅니다.\n\nGemini API는 AI 기반 응용 프로그램을 만들고 싶은 분들을 대상으로 하고 있습니다. 게다가 유료 버전에서는 귀하의 프롬프트 및 응답을 제품 개선에 사용하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# 토큰\n\n생성적 AI 모델은 텍스트 데이터를 처리하기 위해 토큰이라는 단위로 분해합니다. 토큰은 문자, 단어 또는 구(phrase)가 될 수 있습니다. 이는 Gemini가 어떻게 단어를 분해하는지에 따라 다릅니다.\n\n# Top-K, Top-P 및 Temperature\n\n## topK\n\n<div class=\"content-ad\"></div>\n\ntopK 매개변수는 모델이 출력 토큰을 선택하는 방식을 변경합니다. 간단히 말해, 가능한 출력 토큰을 K개로 제한합니다.\n\n예시:\n다음 단어를 완성해야 합니다:\nThe quick brown fox jumps over the …\n\n다음 단어의 확률:\n1. squirrel: 0.08\n2. sleeping rabbit: 0.3\n3. lazy dog: 0.9\n4. dog: 0.7\n\n예시에서...\n\n<div class=\"content-ad\"></div>\n\n만약 topK를 1로 설정하면 (탐욕 디코딩), 출력 결과는 가장 높은 확률을 가진 단어만 표시됩니다. 즉, \"게으른 개\"가 됩니다.\n\n만약 topK를 N(N ≥ 1)으로 설정하면, 출력 결과는 가장 높은 확률을 가진 N개의 단어 중 하나가 나오게 됩니다. 예를 들어, \"게으른 개\", \"개\", \"자는 토끼\"가 있을 때, 이 중에서도 topP에 따라 단어가 더 필터링되고, 최종 출력은 온도를 이용하여 선택됩니다.\n\n## topP\n\ntopP 매개변수, 또한 넉클리어 샘플링이라고 불리는 것은 모델이 출력 토큰을 선택하는 방식을 변경합니다. 간단히 말해, 출력 토큰의 확률 합이 topP 값과 동일하거나 그 이상인 경우까지만 토큰을 생성하는 방식입니다. topP 값은 0.0에서 1.0 사이의 범위로 설정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예시: \n다음 단어를 완성해야 합니다:\n수영은 매우…\n\n다음 단어의 확률:\n1. 인기 있는: 0.3\n2. 치유적인: 0.1\n3. 건강한: 0.4\n4. 어려운: 0.2\n\n이때 topP는 0.5로 설정합니다.\n\n가장 높은 확률을 가진 단어는 \"건강한\" (0.4)이지만, 임계 값을 충족하지 못하므로 두 번째로 높은 \"인기 있는\" (0.3)으로 이동합니다. 따라서 출력은 \"건강한\" (0.4)과 \"인기 있는\" (0.3)입니다.\n\n<div class=\"content-ad\"></div>\n\n## 온도\n\n온도는 topP 및 topK가 적용된 이후의 토큰 선택의 무작위성을 제어합니다. 또한 0.0에서 1.0 범위 내에서 온도 값을 설정할 수 있습니다. 우리는 여기서 식을 포함하지 않을 것입니다.\n\n알아두어야 할 것은 높은 온도와 낮은 온도를 언제 사용해야 하는지입니다.\n\n- 낮은 온도 (≤ 0.5)는 더 구체적이거나 덜 창의적인 출력이 필요할 때 적합합니다. 사용 사례 예시로는 요약, 질문 응답, 팩트-체킹, 번역 등이 있습니다.\n- 높은 온도 (≥ 0.5)는 더 창의적인 출력이 필요할 때 적합합니다. 사용 사례 예시로는 이야기 작성, 퀴즈 생성 등이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 가격 책정\n\n가격은 입력 및 출력 토큰에 따라 다르므로 비용을 최적화하기 위해 콘텐츠 생성 전에 입력 및 출력 토큰을 제한할 수 있습니다.\n\n다트(Dart)에서의 예시는 다음과 같습니다:\n\n```js\nFuture<void> main() async {\n  final GenerativeModel model = GenerativeModel(\n    model: 'gemini-1.5-pro-latest',\n    apiKey: 'YOUR_API_KEY',\n    generationConfig: GenerationConfig(\n      responseMimeType: 'application/json',\n      maxOutputTokens: 150,\n    ),\n  );\n\n  final token = await model.countTokens(\n    [Content.text('Hello World')],\n  );\n  print(token.totalTokens);\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# JSON 생성하기\n\n가끔 앱에서 JSON을 생성해야 할 때가 있습니다. 최신 Gemini 1.5 Pro에서는 이미 JSON 출력을 지원합니다.\n\nDart에서 GenerationConfig 내부에 responseMimeType: 'application/json' 속성을 추가할 수 있습니다.\n\nGemini 1.0 Pro를 사용하지 않는 경우에는 프롬프트할 때 출력을 지정할 수 있습니다. ' '예제': '문자열' ' 이런 JSON 구조로 ...를 생성해줘 라고 간단히 요청하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n여기 다트(Dart)에서의 예시가 있어요:\n\n```dart\nvoid main() {\n  final jsonString = jsonEncode({'story': 'string'});\n  final content = await model.generateContent([\n    Content.text(\n      'Generate me a story with this JSON structure: $jsonString',\n    ),\n  ]);\n  print(content.text);\n}\n```\n\n# 시스템 지침\n\n시스템 지침은 사용자가 특정 요구 사항과 사용 사례에 따라 모델의 동작을 조정할 수 있도록 합니다. AI 역할, 언어 스타일 또는 출력을 지정할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n다트 코드 예시를 보여드립니다:\n\n```dart\nvoid main() {\n  final GenerativeModel model = GenerativeModel(\n    model: 'gemini-1.5-pro-latest',\n    apiKey: 'YOUR_API_KEY',\n    systemInstruction: Content.system(\n      '''You are a horror story teller.\n      You will receive a title, then turn it into a short horror story\n      and respond it to the JSON object contains title and story''',\n    ),\n  );\n}\n```\n\n# 보안\n\n클라이언트 측에서 직접 Gemini API를 호출하는 것은 API 키 유출, 서비스 거부(DoS) 공격 등과 같은 위협에 노출될 수 있습니다. 클라이언트 측은 프로토타입에만 사용해야 합니다. 가장 안전한 방법은 서버 측에서 구현하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n모두 끝났어요!\n\n아래에 댓글을 남기시고 망고가 Linkedin에서 우릴 이어도록 합시다!\n\n독해주셔서 감사합니다! 🐈","ogImage":{"url":"/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png"},"coverImage":"/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png","tag":["Tech"],"readingTime":4},{"title":"Swift에서의 고급 오류 처리 Try-Catch를 넘어서","description":"","date":"2024-05-23 13:13","slug":"2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch","content":"\n\n<img src=\"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png\" />\n\n소개\n\n오류 처리는 견고한 응용 프로그램 구축의 중요한 측면입니다. Swift의 try, catch, throw 및 do로 소개된 오류 처리 모델은 오류를 우아하게 처리하는 강력하고 유연한 메커니즘을 제공합니다. 그러나 응용 프로그램이 복잡해지면 오류를 효과적으로 관리하기 위해 더 고급 기술이 필요할 수 있습니다. 이 글에서는 Swift에서 고급 오류 처리 전략인 Result 타입, async/await 오류 전파, 사용자 정의 오류 타입, 견고한 오류 처리 시스템을 만드는 데 가장 좋은 방법 등을 탐색해 보겠습니다.\n\n왜 고급 오류 처리가 중요한가요?\n\n<div class=\"content-ad\"></div>\n\n기본 try-catch를 사용한 기본적인 오류 처리는 많은 시나리오에 효과적이지만, 고급 기술은 다음과 같은 여러 가지 이점을 제공합니다:\n\n- 가독성 향상: 더 명확한 오류 처리 경로는 코드의 가독성과 유지보수성을 향상시킵니다.\n- 더 좋은 제어: 오류 전파 및 복구에 대한 더 많은 제어.\n- 디버깅 향상: 더 구체적인 오류 유형으로 문제를 진단하고 수정하기가 더 쉬워집니다.\n- 비동기 컨텍스트: 비동기 코드에서의 오류를 효과적으로 관리합니다.\n\n결과 유형 사용하기\n\n결과 유형은 성공 또는 실패를 나타내며, 값이나 오류를 캡슐화합니다. 오류 처리에 대해 더 함수형 접근 방식을 제공하며 비동기 작업에서 특히 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n기본 예제 및 결과\n\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed\n}\n\nfunc fetchData(from urlString: String) -> Result<Data, NetworkError> {\n    guard let url = URL(string: urlString) else {\n        return .failure(.invalidURL)\n    }\n\n    do {\n        let data = try Data(contentsOf: url)\n        return .success(data)\n    } catch {\n        return .failure(.requestFailed)\n    }\n}\n\nlet result = fetchData(from: \"https://example.com/data\")\n\nswitch result {\ncase .success(let data):\n    print(\"데이터 수신 성공: \\(data)\")\ncase .failure(let error):\n    print(\"데이터 가져오기 실패: \\(error)\")\n}\n```\n\n이 예제에서 fetchData 함수는 가져온 데이터 또는 오류를 캡슐화하는 Result 타입을 반환합니다.\n\nAsync/Await으로 에러 처리\n\n<div class=\"content-ad\"></div>\n\nSwift의 새로운 동시성 모델은 async/await를 도입하여 비동기 코드를 처리하기 쉬워졌어요. 이 문맥에서 오류를 처리하는 방법을 살펴봅시다.\n\nAsync/Await 예제\n\n```js\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed\n}\n\nfunc fetchData(from urlString: String) async throws -> Data {\n    guard let url = URL(string: urlString) else {\n        throw NetworkError.invalidURL\n    }\n\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n\nfunc processData() async {\n    do {\n        let data = try await fetchData(from: \"https://example.com/data\")\n        print(\"Data fetched: \\(data)\")\n    } catch {\n        print(\"Failed to fetch data: \\(error)\")\n    }\n}\n\nTask {\n    await processData()\n}\n```\n\n이 예제에서 fetchData 함수는 비동기이며 오류를 던질 수 있습니다. 이 오류는 processData 함수 내에서 try-catch를 사용하여 처리됩니다.\n\n<div class=\"content-ad\"></div>\n\n사용자 정의 오류 유형 만들기\n\n사용자 정의 오류 유형은 오류 처리를 더 정확하고 의미 있게 만들어줍니다.\n\n사용자 정의 오류 유형을 이용한 예제\n\n```js\nenum FileError: Error {\n    case fileNotFound\n    case unreadable\n    case encodingFailed\n}\n\nfunc readFile(named fileName: String) throws -> String {\n    guard let filePath = Bundle.main.path(forResource: fileName, ofType: nil) else {\n        throw FileError.fileNotFound\n    }\n\n    guard let data = FileManager.default.contents(atPath: filePath) else {\n        throw FileError.unreadable\n    }\n\n    guard let content = String(data: data, encoding: .utf8) else {\n        throw FileError.encodingFailed\n    }\n\n    return content\n}\n\ndo {\n    let content = try readFile(named: \"example.txt\")\n    print(\"파일 내용: \\(content)\")\n} catch {\n    print(\"파일 읽기 실패: \\(error)\")\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기에서 FileError는 파일 작업과 관련된 특정 오류를 정의합니다. readFile 함수는 이러한 오류 유형을 사용하여 상세한 오류 정보를 제공합니다.\n\n에러 처리를 위한 최상의 모법\n\n- 기술적인 오류 유형 사용: 오류에 대한 의미 있는 컨텍스트를 제공하는 사용자 정의 오류 유형을 정의하세요.\n\n```swift\nenum ValidationError: Error {\n    case invalidEmail\n    case passwordTooShort\n}\n```\n\n<div class=\"content-ad\"></div>\n\n2. 적절한 수준으로 오류 전파하기: 오류를 효과적으로 처리할 수 있는 적절한 수준으로 전파하십시오.\n\n```js\nfunc performOperation() throws {\n    try validateInput()\n    try processData()\n}\n```\n\n3. 우아한 복구: 가능한 경우에는 오류로부터 복구할 수 있는 전략을 구현하여 실패하는 것이 아닌 대처하십시오.\n\n```js\nfunc fetchData() async {\n    do {\n        let data = try await fetchData(from: \"https://example.com\")\n        process(data)\n    } catch {\n        recoverFromError(error)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n4. 중앙 집중식 오류 로깅: 디버깅을 간소화하기 위해 오류를 기록하는 데 중앙 집중식 방법을 사용하세요.\n\n```js\nfunc logError(_ error: Error) {\n    // 모니터링 서비스나 콘솔에 오류 기록\n    print(\"오류: \\(error)\")\n}\n```\n\n5. 사용자 친화적인 오류 메시지: 사용자에게 명확하고 실행 가능한 오류 메시지를 제공하세요.\n\n```js\nfunc displayError(_ error: Error) {\n    let message: String\n    switch error {\n    case is NetworkError:\n        message = \"네트워크 오류가 발생했습니다. 나중에 다시 시도해 주세요.\"\n    default:\n        message = \"예기치 못한 오류가 발생했습니다.\"\n    }\n    showAlert(with: message)\n}\n```\n\n<div class=\"content-ad\"></div>\n\n결론\n\nSwift에서의 고급 오류 처리는 기본적인 try-catch 블록을 넘어서 Result 타입, async/await, 그리고 사용자 정의 오류 타입과 같은 강력한 기능을 활용합니다. 이러한 고급 기술을 채택함으로써 더 견고하고 가독성이 높고 유지보수가 용이한 코드를 작성할 수 있습니다. 효과적인 오류 처리는 응용 프로그램이 오류를 우아하게 처리하여 개발자와 사용자 모두에게 더 나은 경험을 제공할 수 있도록 합니다. 이러한 전략을 받아들여 Swift 개발 기술을 향상시키고 더 견고한 응용 프로그램을 구축하세요. 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png"},"coverImage":"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png","tag":["Tech"],"readingTime":5},{"title":"Swift에서의 유니트 테스트 시작 가이드","description":"","date":"2024-05-23 13:12","slug":"2024-05-23-UnitTestinSwiftAStartingGuide","content":"\n# iOS 프로젝트에 단위 테스트 추가하는 방법과 테스트에 관한 주요 개념 배우기\n\n![image](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_0.png)\n\n버그를 고치는 걸 좋아하시나요?\n\n확실히 싫어하시죠.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 적절한 유닛 테스트 구조를 갖는 것은 미래에 머리 아픈 문제를 피하는 데 도움이 됩니다.\n\n단위 테스트는 당신이 만든 모든 변경 사항 후에 코드가 여전히 예상대로 작동하는지 확인하고, 새 코드를 프로덕션 환경에 배포할 때 더 확신을 갖게 해주며, 전체 코드 품질을 향상시키고, 코드베이스 복잡성을 줄이는 등의 암묵적인 이점이 있습니다.\n\n이제 테스트의 주요 개념과 iOS 프로젝트에 어떻게 추가하는지 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n## 단위 테스트란 무엇인가요?\n\n우리가 함께 이야기할 때, 단위 테스트는 우리 애플리케이션 코드의 작은, 독립적이며 명확한 블록(유닛이라고도 함)이 예상대로 작동하는 지를 확인하는 코드 조각들이라고 말할 수 있어요.\n\n### 테스트 구조\n\n코딩 부분으로 바로 들어가기 전에 이해해야 할 여러 구성 요소가 있어요.\n\n<div class=\"content-ad\"></div>\n\n![UnitTestinSwiftAStartingGuide_1.png](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_1.png)\n\n- 테스트 메소드는 코드 일부를 유효성 검사하는 메소드입니다. 여기서 우리는 테스트를 생성하고 개발합니다. 이러한 메소드는 테스트 결과를 생성하며, 통과하거나 실패할 수 있습니다.\n- 테스트 클래스는 테스트 메소드의 집합입니다. 일반적으로 특정 로직을 테스트하는 데 사용되며, 예를 들어 인증(Authentication)을 그룹화합니다.\n- 테스트 번들에는 테스트 클래스의 집합이 포함되며, 두 가지 테스트 유형 중 하나인 Unit 또는 UI를 나타냅니다.\n- 테스트 계획은 테스트 번들의 집합이며, 여기에는 Unit 및 UI 테스트를 모두 포함할 수 있습니다. 테스트 계획에서는 테스트 실행 시 고려해야 할 구성 목록을 설정합니다.\n\n# 테스트 번들 생성으로 시작\n\n`파일` -> `새로 만들기` -> `타겟`으로 이동하여 Unit Testing Bundle을 검색합니다. 대상에 적절한 이름을 지정하고 일반적으로 앱 이름 뒤에 Tests로 끝납니다.\n\n<div class=\"content-ad\"></div>\n\n테스트 번들을 만들면 기본 구성으로 테스트 계획이 자동으로 생성됩니다.\n\n![Unit Testing in Swift: A Starting Guide](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_2.png)\n\n# 단위 테스트 설정하기\n\n모든 프로그래밍 언어에는 단위 테스트를 실행하기 위한 프레임워크나 라이브러리가 있습니다. iOS 개발 환경에서는 XCTest 프레임워크를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 테스트 번들이 준비되었으니 새로운 테스트 클래스를 추가할 수 있습니다. 네비게이션 패널이나 메뉴(File -> File -> Unit Test Case Class)를 통해 새로 만들어주세요.\n\nOrderManager 클래스 뒤에 있는 로직을 테스트하기를 원하므로, 테스트 클래스의 좋은 이름은 OrderTests가 될 것 같아요.\n\n```js\n// 새 주문 추가\nfunc add(_ order: Order) throws { ... }\n// 마지막 주문을 반복하며 주문 목록에 추가\nfunc repeatLastOrder() { ... }\n```\n\n테스트 클래스 안에 각 함수마다 테스트 메소드를 만들어봅시다.\n\n<div class=\"content-ad\"></div>\n\n앱의 코드에 접근하지 않고 파일 단위로 공유하지 않고 테스트 대상에서 앱의 코드에 액세스하려면 @testable 지시문을 추가하고 앱을 가져와야 합니다.\n\n```swift\nimport XCTest\n@testable import Coffee_Shop_App\n\nfinal class OrderTests: XCTestCase {\n\n    override func setUpWithError() throws {}\n    override func tearDownWithError() throws {}\n\n    func testAddNewOrder() {}\n    func testRepeatLastOrder() {}\n}\n```\n\n<img src=\"/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_3.png\" />\n\n각 테스트가 시작하기 전에 XCTest는 setUpWithError() 함수를 실행합니다. 따라서 여기서 테스트의 초기 상태를 설정해야 합니다. 특정 클래스의 인스턴스 생성, 의존성 주입, 변수 값 구성 등이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n테스트가 끝난 후에는 tearDownWithError()가 호출됩니다. 여기서 우리가 고려하는 모든 것을 정리하기에 좋은 장소입니다.\n\n## 이제 Unit Tests를 작성하기 시작할 준비가 모두 완료되었습니다\n\n먼저, OrdersManager에 액세스해야 합니다.\n\n- 클래스에 속성을 추가합니다.\n- setUpWithError() 메서드에서 인스턴스를 만듭니다.\n- tearDownWithError() 메서드에서 상태를 정리합니다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@testable import Coffee_Shop_App\n\nfinal class OrderTests: XCTestCase {\n  private var ordersManager: OrdersManager!\n\n  override func setUpWithError() throws {\n    ordersManager = OrdersManager.shared\n  }\n\n  override func tearDownWithError() throws {\n    ordersManager.removeAllOrders()\n    ordersManager = nil\n  }\n\n  func testAddNewOrder() {}\n  func testRepeatLastOrder() {}\n}\n```\n\n만약 단위 테스트를 시작한다면, 'Arrange / Act / Assert' 패턴을 사용하는 것이 좋은 초보자를 위한 초기 단계입니다. 이 패턴을 사용하여 테스트를 다음과 같이 분해하시면 됩니다:\n\n- Arrange → 테스트가 사용할 모든 필요한 객체나 데이터를 생성합니다.\n- Act → 테스트하려는 메서드나 함수를 실행합니다.\n- Assert → 얻은 결과를 기대한 결과와 비교합니다.\n\n```kotlin\nfinal class OrderTests: XCTestCase {\n  private var ordersManager: OrdersManager!\n\n  override func setUpWithError() throws {\n    ordersManager = OrdersManager.shared\n  }\n\n  override func tearDownWithError() throws {\n    ordersManager.removeAllOrders()\n    ordersManager = nil\n  }\n\n  func testAddNewOrder() {\n    // 1 - Arrange\n    let orderItems: [OrderItem] = [\n      .init(item: AnyMenuItem(Coffee.flatwhite), size: .regular, quantity: 1),\n      .init(item: AnyMenuItem(Food.chickenSandwich), size: .regular, quantity: 1),\n    ]\n    let order = Order(items: orderItems)\n\n    // 2 - Act\n    try? ordersManager.add(order)\n\n    // 3 - Assert\n    XCTAssertEqual(ordersManager.orders.count, 1)\n  }\n\n  func testRepeatLastOrder() {\n    // 1 - Arrange\n    let orderItems: [OrderItem] = [\n      .init(item: AnyMenuItem(Coffee.flatwhite), size: .regular, quantity: 1),\n      .init(item: AnyMenuItem(Food.chickenSandwich), size: .regular, quantity: 1),\n    ]\n\n    // 2 - Act\n    let order = Order(items: orderItems)\n    try? ordersManager.add(order))\n    ordersManager.repeatLastOrder()\n\n    // 3 - Assert\n    XCTAssertEqual(ordersManager.orders.count, 2)\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# Xcode에서 단위 테스트 직접 실행하기\n\n구성 세트에 포함된 모든 테스트, 테스트 번들에 포함된 모든 테스트, 테스트 클래스에 포함된 모든 테스트, 일부 특정 테스트 메서드의 그룹 또는 한 번에 하나의 테스트 메서드를 실행할 수 있습니다.\n\n테스트를 실행한 후에는 결과가 포함된 테스트 보고서를 받을 수 있습니다. 또한 Test 네비게이터 및 테스트 클래스 내에서 테스트 결과를 직접 확인할 수 있습니다.\n\n![image](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_4.png)\n\n<div class=\"content-ad\"></div>\n\n# 테스트 커버리지\n\n테스트를 실행한 후에 테스트 커버리지 정보를 활성화할 수 있습니다. 시험한 코드 안에서 테스트 된 코드 부분을 볼 수 있습니다.\n\n![unit test](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_5.png)\n\n녹색으로 표시된 부분은 최근 테스트 실행에서 도달한 코드 부분이고, 빨간색으로 표시된 부분은 도달하지 못한 코드 부분입니다. 데모에서 주문 최소 금액을 확인하는 부분이 누락되었습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 이 시나리오를 발견하면, 새로운 유닛 테스트를 추가해서 이를 확인하고 테스트를 다시 실행할 수 있어요.\n\n# 다른 XCTAssert 사용\n\n테스트 결과를 확인할 때 사용할 수 있는 다양한 함수들이 있어요. 몇 가지 예시를 보여드릴게요.\n\n```js\n// 1 - throw 함수가 예외를 발생시키지 않는지 확인\nXCTAssertNoThrow(try ordersManager.add(order))\n\n// 2 - throw 함수가 에러를 발생시키는지 확인\nXCTAssertThrowsError(try ordersManager.add(order)) { error in\n  if let appError = error as? AppError, let errorType = appError.type as? OrderError {\n    XCTAssertEqual(errorType.code, 2)\n  } else {\n    XCTFail(\"잘못된 에러 유형이 트리거됐어요\")\n  }\n}\n\n// 3 - 옵셔널 값이 nil이 아닌지 확인\nlet lastCoffeeDescription = ordersManager.getLastCoffee()\nXCTAssertNotNil(lastCoffeeDescription)\n```\n\n<div class=\"content-ad\"></div>\n\n\n```js\nXCTAssertEqual(ordersManager.orders.count, 1, \"주문이 올바르게 추가되지 않았습니다\")\n```\n\n# 명심해야 할 점\n\n- 버그를 수정하는 것보다 테스트를 작성하는 데 시간을 소비하는 것이 항상 좋습니다.\n- 단위 테스트를 추가하는 것을 추가 작업으로 보지 마세요. 개발 과정의 일부로 테스트를 추가하려고 노력하세요.\n- FIRST 원칙을 기억하세요. 모든 단위 테스트는 빠르고 독립적이며 반복 가능하며 자가 검증 가능하며 적시성을 가져야 합니다.\n- 테스트가 실패하면 조심해야 합니다. 테스트를 적응시키려고 할 수 있습니다. 그러나 이는 일부 경우에는 올바를 수 있지만 (테스트가 잘못 작성된 경우) 대게 테스트하려는 논리가 잘못된 것입니다.\n- 100%의 테스트 커버리지를 추구하지 마세요. 100%의 커버리지가 있더라도 10가지 가능한 시나리오 중 1개에 대한 테스트만 있는 경우가 있습니다. 대신 품질 높은 테스트를 작성하는 데 중점을 두세요.\n- 테스트를 사용하여 전체적인 코드 품질을 높일 수 있는 작은 코드 리팩터링을 찾을 수 있는 기회로 활용하세요.\n\n\n\n<div class=\"content-ad\"></div>\n\n질문이 있으시면 언제든지 메시지 보내주세요! 🙂\n\n- 🤓 iOS 개발 팁 및 통찰력이 담긴 규칙적인 콘텐츠를 보려면 X에 들러주세요.\n- 🚀 제 GitHub에서 제 예제 프로젝트를 모두 공유하고 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_0.png"},"coverImage":"/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover","description":"","date":"2024-05-23 13:10","slug":"2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover","content":"\n\n![이미지](/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png)\n\n이 글은 이전 글들을 이어서 작성되었으며, 그 위에 쌓아 올릴 것입니다.\nSwiftUI 네비게이션 파트 1 — 푸시 네비게이션\nSwiftUI 네비게이션 파트 2 — 알림\n\n이 글에서는 Sheets 및 FullscreenCovers을 동시에 다룰 것이며, 이들은 동일한 방식으로 구현됩니다.\n\n시작해 봅시다! 이전 글들에서는 결정적 목적지로 조정하기 위해 Routes를 사용했습니다. 그러나 SwiftUI는 어떻게 이루어지는 걸까요?\n뷰 계층 구조의 루트에 있는 NavigationStack에 대한 네비게이션 경로에 대한 바인딩이 있습니다. Apple의 문서 예제를 살펴보겠습니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\nNavigationStack(path: $presentedParks) {\n    List(parks) { park in\n        NavigationLink(park.name, value: park)\n    }\n    .navigationDestination(for: Park.self) { park in\n        ParkDetails(park: park)\n    }\n}\n```\n\n우리는 NavigationStack 라는 뷰가 있습니다. 이 뷰를 통해 일부 데이터 유형의 바인딩을 통해 .navigationDestination이라는 뷰 수정자에서 제공된 뷰로 이동할 수 있습니다 🤔 어떻게 보면 흥미로운 것 같네요.\n\n그럼 이 뷰 수정자가 무엇인지 궁금하죠? 프레임워크 문서에서 더 자세히 살펴봐 봅시다.\n\n```js\n/// 스택에 한 개 이상의 네비게이션 대상 수정자를 추가할 수 있습니다.\n/// 여러 데이터 유형을 표시해야 하는 경우 스택에 네비게이션 대상 수정자를 여러 개 추가할 수 있습니다.\n///\n/// \"List\" 또는 \"LazyVStack\"과 같은 \"lazy\" 컨테이너 내부에 네비게이션 대상 수정자를 넣지 마세요.\n/// 이러한 컨테이너는 화면에 렌더링할 때 필요한 경우에만 자식 뷰를 생성합니다.\n/// 항상 네비게이션 대상 수정자를 이러한 컨테이너 외부에 추가하여 네비게이션 스택이 대상을 항상 볼 수 있도록 하세요.\n///\n/// - Parameters:\n///   - data: 이 대상이 일치하는 데이터의 유형입니다.\n///   - destination: 스택의 네비게이션 상태에 유형 'data'의 값을 포함하고 있을 때 표시할 뷰를 정의하는 뷰 빌더입니다.\n///     클로저는 데이터 값을 나타내는 하나의 인수를 사용합니다.\npublic func navigationDestination<D, C>(for data: D.Type, @ViewBuilder destination: @escaping (D) -> C) -> some View where D : Hashable, C : View\n```\n\n<div class=\"content-ad\"></div>\n\n뭐 이건 Data.Type을 받아들이는 ViewModifier인데, 그런 다음에 destination이라고 불리는 클로저가 주입되는데, 이 클로저는 hashable해야 할 that Data.Type의 인스턴스를 주입하고 구체적인 View를 반환해야 해요...... 그렇죠. 😵\n\n또 다른 것은 .navigationDestination(\\_:)이 NavigationStack 내부의 View에 적용되어야 하며, NavigationStack의 범위 외부에 적용할 수 없다는 것을 주의해야 해요. 🤔\n\n뷰 계층 구조를 통해 데이터를 상위 뷰로 전파하는 유사한 시그니처를 가진 다른 것이 있어요. 이것이 바로 데이터를 뷰의 부모에게 전달하는 데 사용되는 PreferenceKeys입니다!\n\nPreferenceKeys를 사용하여 .navigationDestination(\\_:)이 NavigationStack에 하는 것처럼 내비게이션 목적지를 전달할 수 있을까요?\n우리는 곧 알게 될 거예요!\n\n<div class=\"content-ad\"></div>\n\n시트 및 풀스크린 커버의 ViewModifier를 검사해 봅시다.\n\n```js\n    public func sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View\n\n    public func fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View\n```\n\n이들은 서로 거의 동일하며 navigationDestination(\\_:)과도 매우 유사합니다. 주요 차이점은 나타낼 아이템에 대한 바인딩이 Hashable 대신 Identifiable을 준수해야 하며 전달할 수 있는 선택적인 onDismiss 클로저가 있는 것입니다.\n\nRoutes도 Identifiable을 준수하도록 만들어 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable { // <-- Identifiable\n    var id: String { String(describing: self) }\n\n    case detailView\n    case secondDetailView(String)\n}\n```\n\n이제 루트를 처리하는 ViewModifier를 만들어야 합니다. navigationDestination(_:)가 어떻게 작동하는지 더 잘 이해하려고 했고, navigationDestination(_:)와 동일하게 목적지를 뷰 계층 구조로 전달할 수 있는 방법을 재현해 볼 수 있을지 생각했습니다.\n\n내가 알기로는 뷰 계층 구조로 데이터를 전송하는 유일한 방법은 PreferenceKeys이니까 그것부터 시작하겠습니다.\n그러나 몇 가지 기준이 있습니다. 어떤 경로에 대해서도 작동하고 다른 경로에 대한 모든 목적지를 해결할 수 있어야합니다. 이 기준으로 인해 타입 지워를 사용해야 합니다. 다음과 같이 PreferenceKeys를 생성해 봅시다.\n\n```js\nstruct SheetFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -> [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } } // reduce all into one value (dictionary)\n}\n\nstruct CoverFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -> [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } }\n}\n\nextension View {\n    public func sheetDestination<D,C>(for data: D.Type, @ViewBuilder sheet: @escaping (D) -> C) -> some View where D: Identifiable & Hashable, C : View  {\n        preference(key: SheetFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, sheet)]) // <- Here we set the key to the data type's description! and pass our view factory\n    }\n\n    public func coverDestination<D,C>(for data: D.Type, @ViewBuilder cover: @escaping (D) -> C) -> some View where D: Identifiable & Hashable, C : View  {\n        preference(key: CoverFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, cover)])\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n네비게이션 목적지()가 sheetDestination()와 coverDestination() 선호 키 모두 호출자의 모든 값을 하나의 [String: NavigationViewFactory] 사전으로 줄입니다.\n\n기본적으로 여러 Coordinator가 있는 경우 각각이 자체 경로 유형을 위해 sheetDestination() 선호 키를 사용합니다. 이것은 PreferenceKeys에서 보내진 모든 값들을 하나의 사전으로 병합/줄이고, 문자열 키를 사용하여 작업하는 데이터 유형에 대한 식별자로 사용할 수 있습니다. 따라서 뷰 계층 구조를 통해 전달된 대응하는 예상 값에 접근할 수 있습니다. 이 값은 해당 목적지를 반환하는 데 도움이 됩니다.\n\n여기에는 데이터 유형을 설명하는 ID와 AnyView를 반환하는 타입 지워진 NavigationViewFactory가 있습니다.\nAnyView는 SwiftUI에서 제공되는 타입 지워진 뷰 래퍼로 성능에 부담이 있으므로 절약해서 사용해야 합니다. 그러나 한 번에 하나의 시트나 커버만 표시할 수 있기 때문에 수용할만한 것으로 보입니다.\n\n<div class=\"content-ad\"></div>\n\nNavigationController로 다시 가서 코드를 추가해 봅시다.\n\n```js\n@Observable final class NavigationController {\n    var navigationPath = NavigationPath()\n    var alertPath = AlertPath()\n    var sheetPath: SheetPath = .init() // <- SheetPath를 생성해 봅시다\n    var coverPath: CoverPath = .init() // <- CoverPath를 생성해 봅시다\n\n    func presentSheet<T>(_ route: T, onDismiss: (() -> Void)? = nil)  where T: Codable & Identifiable & Hashable  {\n        sheetPath.setSheet(route, onDismiss: onDismiss)\n    }\n\n    func presentCover<T>(_ route: T, onDismiss: (() -> Void)? = nil)  where T: Codable & Identifiable & Hashable  {\n        coverPath.setCover(route, onDismiss: onDismiss)\n    }\n}\n\n// Sheet\nstruct SheetPath: Identifiable {\n    var id: String { sheet?.id ?? UUID().uuidString } // <- 현재 sheet의 id를 사용합니다.\n    var sheet: SheetContainer?\n\n    mutating func setSheet<T>(_ sheet: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.sheet = SheetContainer(sheet, onDismiss: onDismiss)\n    }\n}\n\nstruct SheetContainer: Identifiable {\n    let id: String\n    let sheet: Any\n    let onDismiss: (() -> Void)?\n\n    init<T>(_ sheet: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.id = String(describing: T.self)\n        self.sheet = sheet\n        self.onDismiss = onDismiss\n    }\n}\n\n// Fullscreen Cover\nstruct CoverPath: Identifiable {\n    var id: String { cover?.id ?? UUID().uuidString }\n    var cover: CoverContainer?\n\n    mutating func setCover<T>(_ cover: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.cover = CoverContainer(cover, onDismiss: onDismiss)\n    }\n}\n\nstruct CoverContainer: Identifiable {\n    let id: String\n    let cover: Any\n    let onDismiss: (() -> Void)?\n\n    init<T>(_ cover: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.id = String(describing: T.self)\n        self.cover = cover\n        self.onDismiss = onDismiss\n    }\n}\n```\n\n이 두 가지 구현 사항은 기본적으로 동일하며 같은 컨테이너, 경로, 함수 뷰 수정자 등을 사용하고 열거형 PresentationMode를 추가하여 sheet와 cover를 구분할 수 있는 case를 추가할 수 있습니다. 그러나 일관성을 유지하기 위해 이 예제에서는 이들을 분리해 두었습니다. 또한 SwiftUI가 이후에 여러 개의 sheet/cover를 지원한다면 별도로 처리하고자 할 수도 있습니다. 선택은 당신에게 맡깁니다. 지금까지 어떤 것들을 얻었나요?\n\n- NavigationController에는 이제 sheet 및 fullScreenCover에 대한 경로가 있습니다.\n- 우리는 데이터 작업의 구체적인 유형을 지우기 위해 타입 이레이저를 사용하지만, 우리가 수용할 수 있는 유형으로만 컨테이너를 초기화할 수 있도록 하여, 지워진 타입 값은 일종의 Identifiable, Hashable 및 Codable 유형이 되도록 보장합니다.\n- 또한, 해당 데이터 유형의 설명을 Identifiable 준수를위한 식별자로 저장하여 우리의 뷰 팩토리 콜백 딕셔너리에서 구분할 수 있도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n여전히 함께 계신다니 너무 기쁘네요! 이제 모든 것을 함께 연결해보려 합니다.\n\n이제 시트를 표시하는 ViewModifier를 만들어야 합니다.\n\n```js\nextension View {\n    func sheet(for sheetPath: Binding<SheetPath>) -> some View {\n        modifier(SheetModifier(sheetPath: sheetPath))\n    }\n\n    func cover(for data: Binding<CoverPath>, onDismiss: (() -> Void)? = nil) -> some View {\n        modifier(CoverModifier(data: data))\n    }\n}\n\nstruct SheetModifier: ViewModifier {\n    @Binding var sheetPath: SheetPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -> Void)?\n\n    init(sheetPath: Binding<SheetPath>) {\n        self._sheetPath = sheetPath\n        self.onDismiss = sheetPath.wrappedValue.sheet?.onDismiss\n    }\n\n    func body(content: Content) -> some View {\n        content\n            .onPreferenceChange(SheetFactoryKey.self) { factories = $0 }\n            .sheet(item: _sheetPath.sheet, onDismiss: sheetPath.sheet?.onDismiss, content: { factories[sheetPath.id]?.factory($0.sheet) })\n    }\n}\n\nstruct CoverModifier: ViewModifier {\n    @Binding var data: CoverPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -> Void)?\n\n    init(data: Binding<CoverPath>) {\n        self._data = data\n        self.onDismiss = data.wrappedValue.cover?.onDismiss\n    }\n\n    func body(content: Content) -> some View {\n        content\n            .onPreferenceChange(CoverFactoryKey.self) { factories = $0 }\n            .fullScreenCover(item: _data.cover, onDismiss: data.cover?.onDismiss, content: { factories[data.id]?.factory($0.cover) })\n    }\n}\n```\n\n이게 뭐하는 거야? 모든 .sheetDestination()를 사용하는 코디네이터는 경로에 해당하는 코디네이션 함수를 뷰 계층 구조에 전달합니다. 그리고 sheetPath에 값을 설정하면 동일한 데이터 유형에 대한 viewFactory를 추출하고 데이터 인스턴스를 주입하여 메서드를 호출하여 대상을 반환할 것입니다. 모두 어떻게 함께 작동하는지 예제를 살펴봅시다.\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable {\n    var id: String { String(describing: self) }\n    ... 이전 경로들\n\n    case sheet // 선택 사항으로 연결된 값 전달 가능\n    case cover\n}\n\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor var rootView: some View {\n        let viewModel = FirstViewModel(self)\n        FirstView(viewModel)\n            .navigationDestination(for: Route.self, destination: coordinate(_:))\n            .sheetDestination(for: Route.self, sheet: coordinate(_:))\n            .coverDestination(for: Route.self, cover: coordinate(_:))\n    }\n\n    func presentSheet(onDismiss: (() -> Void)? = nil) {\n        navigationController.presentSheet(Route.sheet, onDismiss: onDismiss)\n    }\n\n    func presentCover(onDismiss: (() -> Void)? = nil) {\n        navigationController.presentCover(Route.cover, onDismiss: onDismiss)\n    }\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -> some View {\n        switch route {\n            ... 이전 경로들\n\n            case .sheet: SomeBranchedView()\n            case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n와, 정말 깔끔하네요!\nrootView 계산 속성 내에서 PreferenceKeys를 설정하여 모든 정보가 코디네이터의 Route.Types를 해결하는 데 필요한 정보를 코디네이트(coordinates) 함수로 보냅니다. 이 함수는 특정 코디네이터가 좌표를 맡은 모든 뷰를 생성합니다. 🤔 꽤 괜찮죠.\n\n```js\nstruct CoordinatedView<C: Coordinator>: View {\n    private let coordinator: C\n\n    init(_ coordinator: C) {\n        self.coordinator = coordinator\n    }\n\n    var body: some View {\n        @Bindable var navigationController = coordinator.navigationController\n        NavigationStack(path: $navigationController.navigationPath) {\n            coordinator.rootView\n        }\n        .sheet(for: $navigationController.sheetPath)\n        .cover(for: $navigationController.coverPath)\n        .alert(for: $navigationController.alertPath)\n    }\n}\n```\n\n마지막으로 루트 CoordinatedView에 sheet 또는 cover를 적용하는 방법에 대해 다음과 같이 살펴보겠습니다. 이것도 꽤 깔끔하네요 😉\n\n그러니까 이 경우를 위해 우리의 view와 viewModel을 검사해봅시다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nstruct FirstView: View {\n    let viewModel: FirstViewModel\n\n    var body: some View {\n        VStack {\n            Text(\"First View\")\n            Button(\"상세 화면으로 이동\") {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n@Observable class FirstViewModel {\n\n    private let coordinator: FirstTabCoordinator\n\n    init(coordinator: FirstTabCoordinator) {\n        self.coordinator = coordinator\n    }\n\n    func didTapButton() {\n        coordinator.presentSheet {\n          // closure called onDismiss\n        }\n    }\n}\n```\n\n우리의 뷰는 didTapButton 이외에 무슨 일이 벌어지고 있는지 알 수 없습니다.\n\nℹ️ 또한 다른 필요한 수식어(modifier)들이 coordinate() 함수에서 반환되기 전에 뷰에 적용될 수 있습니다.\n\n예를 들어, 시트에 presentationDetents를 적용하려면. 그리고 뷰 내부에서 심지어 그것에 대해 알 필요조차 없을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -> some View {\n        switch route {\n         ... 이전 루트\n\n        case .sheet: SomeBranchedView().presentationDetents([.medium, .large]) // 시트를 반으로 크기 조정하고 드래그 액션 등을 허용합니다.\n        case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n지금은 여기까지입니다.\n\n이 글에서 어떤 통찰을 얻으셨다면 좋겠네요. 피드백이나 개선 제안이 있다면 알려주세요. 이 글이 가치 있다고 느끼신다면 공유해주세요!\n\n즐거운 코딩하세요!\n\n\n\n\n","ogImage":{"url":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png"},"coverImage":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png","tag":["Tech"],"readingTime":13},{"title":"마스터링 디스패치 큐Dispatch Queues in Swift 이해, 구현, 그리고 제한들","description":"","date":"2024-05-23 13:09","slug":"2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations","content":"\n\n![Image](/assets/img/2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations_0.png)\n\n디스패치 큐는 Apple의 Grand Central Dispatch (GCD)의 일부로 2009년 소개되었으며, 스레드의 대안으로 작업을 비동기적으로 수행할 수 있게 합니다. 우리는 그들의 기능과 작업 큐, 스레드와 비교한 차이를 탐색해보겠습니다.\n\n## 기본 사용법\n\n디스패치 큐를 하나의 작업 라인으로 생각해보세요. 이렇게 생성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```swift\nlet queue = DispatchQueue(label: \"my.queue\")\n```\n\n이제, 해당 큐에서 어떤 작업을 실행하고 싶다면 다음과 같이 작업을 추가하면 됩니다:\n\n```swift\nqueue.async {\n    print(\"여기서 일부 작업을 수행 중입니다!\")\n}\n```\n\n# 디스패치 큐 유형\n\n<div class=\"content-ad\"></div>\n\n## 시리얼 큐\n\n기본적으로 디스패치 큐를 생성할 때 특성을 지정하지 않으면 시리얼 큐를 얻게 됩니다. 시리얼 큐에 대기열에 있는 작업들은 한 번에 하나씩 순차적으로 실행되며, 마치 한 줄로 움직이는 자동차와 같습니다. 예를 들어:\n\n```js\nlet serialQueue = DispatchQueue(label: \"my.serial.queue\")\nserialQueue.async {\n print(\"작업 1\")\n}\nserialQueue.async {\n print(\"작업 2\")\n}\n```\n\n## 병렬 큐\n\n<div class=\"content-ad\"></div>\n\n한편, 동시 큐는 작업들이 동시에 실행되도록 허용합니다. 이는 여러 차로로 이어진 고속도로와 같이 작동하여 차(작업)들이 나란히 이동할 수 있도록 합니다. 이와 같이 동시 큐를 만들 수 있습니다:\n\n```js\nlet concurrentQueue = DispatchQueue(label: \"my.concurrent.queue\", attributes: .concurrent)\nconcurrentQueue.async {\n print(\"동시 작업 1\")\n}\nconcurrentQueue.async {\n print(\"동시 작업 2\")\n}\n```\n\n## 지연된 실행\n\nDispatch 큐는 작업의 지연된 실행을 가능하게 합니다. 특정 시간 이후에 작업을 시작할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```swift\nlet delayedQueue = DispatchQueue(label: \"delayed.queue\")\ndelayedQueue.asyncAfter(deadline: .now() + 1) {\n    print(\"1초 후에 시작하는 작업입니다!\")\n}\n```\n\n## 작업 우선순위\n\nGCD(Grand Central Dispatch) 큐는 작업 우선순위를 설정할 수 있도록 해줍니다. 이는 다른 작업들과 얼마나 빨리 실행되어야 하는지를 결정합니다:\n\n```swift\nlet highPriorityQueue = DispatchQueue(\n    label: \"high.priority.queue\",\n    qos: .userInitiated\n)\nlet highPriorityTask = DispatchWorkItem {\n    print(\"이것은 높은 우선순위 작업입니다!\")\n}\nhighPriorityQueue.async(execute: highPriorityTask)\n```\n\n<div class=\"content-ad\"></div>\n\n## 작업 취소\n\n필요할 경우 작업을 취소할 수 있지만, 반드시 스레드와 작업 큐와 같이 작업 내에서 취소 여부를 확인하는 것이 중요합니다.\n\n```js\nvar task: DispatchWorkItem!\ntask = DispatchWorkItem {\n guard !task.isCancelled else {\n print(\"작업이 취소되었습니다.\")\n return\n }\n // 일부 작업 수행\n}\nqueue.async(execute: task)\n// 일정 시간 후 취소하려면\nDispatchQueue.global().asyncAfter(deadline: .now() + 3) {\n task.cancel()\n}\n```\n\n## 데이터 공유\n\n<div class=\"content-ad\"></div>\n\n디스패치 큐는 큐에 사용자 정의 데이터를 연결하는 DispatchSpecificKey를 제공하여 동일한 컨텍스트에서 실행되는 작업들 간에 데이터 공유를 허용합니다.\n\n```swift\nlet id = UUID()\nlet specificKey = DispatchSpecificKey<UUID>()\nqueue.setSpecific(key: specificKey, value: id)\nif let retrievedId = DispatchQueue.getSpecific(key: specificKey) {\n print(\"Found the ID: \\(retrievedId)\")\n}\n```\n\n물론! 이제 우리는 디스패치 큐에서 타겟팅 개념을 코드 예제와 함께 살펴보면서 큐 간에 어떻게 데이터가 흐르는지 이해해보겠습니다.\n\n# 큐 타겟팅과 디테일 이해하기\n\n<div class=\"content-ad\"></div>\n\n## 특정 사항 설정 및 액세스\n\n동일한 대기열에서 실행되는 작업 내에서 대기열을 만들고 특정 사항(사용자 지정 데이터)을 설정하고 해당 특정 사항에 액세스하는 방법을 고려해보세요:\n\n```js\nlet queue1 = DispatchQueue(label: \"queue1\")\nlet idKey = DispatchSpecificKey<Int>()\nlet dateKey = DispatchSpecificKey<Date>()\nqueue1.setSpecific(key: idKey, value: 42)\nqueue1.setSpecific(key: dateKey, value: Date())\nqueue1.async {\n print(\"queue1\", \"id\", DispatchQueue.getSpecific(key: idKey))\n print(\"queue1\", \"date\", DispatchQueue.getSpecific(key: dateKey))\n}\n```\n\n## 새로운 대기열에서 특정 사항을 잃는 경우\n\n<div class=\"content-ad\"></div>\n\n기존 큐 내에서 새 큐를 생성하더라도 자동으로 세부사항을 상속받지 않습니다:\n\n```js\nqueue1.async {\n let queue2 = DispatchQueue(label: \"queue2\")\n queue2.setSpecific(key: idKey, value: 1729)\n queue2.async {\n print(\"queue2\", \"id\", DispatchQueue.getSpecific(key: idKey))\n print(\"queue2\", \"date\", DispatchQueue.getSpecific(key: dateKey))\n }\n}\n```\n\n## 특정 사항 상속을 위한 큐 지정\n\n지정은 새 큐에서 특정 정보 손실 문제를 해결합니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nlet queue2 = DispatchQueue(label: \"queue2\", target: queue1)\nqueue2.setSpecific(key: idKey, value: 1729)\nqueue2.async {\n print(\"queue2\", \"id\", DispatchQueue.getSpecific(key: idKey))\n print(\"queue2\", \"date\", DispatchQueue.getSpecific(key: dateKey))\n}\n```\n\n## 지정된 대상 대기열을 사용하여 병렬 작업 실행하기\n\n두 개의 독립적인 작업, 데이터베이스 쿼리와 네트워크 요청이 있다고 가정하고 이를 병렬로 실행하려고 합니다:\n\n```js\nfunc response(for request: URLRequest, queue: DispatchQueue) -> HTTPURLResponse {\n let group = DispatchGroup()\n let databaseQueue = DispatchQueue(label: \"database-request\", target: queue)\n databaseQueue.async(group: group) {\n makeDatabaseQuery()\n }\n let networkQueue = DispatchQueue(label: \"network-request\", target: queue)\n networkQueue.async(group: group) {\n makeNetworkRequest()\n }\n group.wait()\n return .init()\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 특정 사항 상속 유지\n\n새 대기열이 특정 사항을 상속받도록하려면 부모 대기열을 인수로 전달하십시오:\n\n```js\nresponse(for: .init(url: .init(string: \"https://www.testurl.com\")!), queue: queue)\n```\n\n## 대기열 생성 최적화\n\n<div class=\"content-ad\"></div>\n\n한개의 동시 서버 대기열을 만들고 새 대기열을 이 속성을 상속하도록 타깃팅하여 최적화하세요:\n\n```js\nlet serverQueue = DispatchQueue(label: \"server\", attributes: .concurrent)\n// 각 요청에 대해\nlet queue = DispatchQueue(label: \"request-\\(requestId)\", attributes: .concurrent, target: serverQueue)\nqueue.setSpecific(key: requestIdKey, value: requestId)\nqueue.async {\n    response(for: .init(url: .init(string: \"https://www.testurl.com\")!)\n}\n```\n\n# 제약 사항:\n\nSwift의 디스패치 대기열은 스레드와 작업 대기열의 강점을 결합하여 비동기 작업, 우선순위 관리, 취소 및 특정 데이터 저장을 제공합니다. 그러나 아직도 주의를 요하는 일부 도전이 존재합니다.\n\n<div class=\"content-ad\"></div>\n\n- 특정 상속을 위한 큐 전달\n\n현재 새 큐 내에서 특정 사항을 상속하려면 부모 큐를 명시적으로 전달해야 하며, 암시적 데이터 흐름의 목적이 무력화됩니다:\n\n```js\nresponse(for: .init(url: .init(string: \"https://www.testurl.com\")!), queue: requestQueue)\n```\n\n이 접근 방식은 계층별로 데이터를 전달하지 않고 실행 컨텍스트 전체에서 매끄럽게 데이터를 공유하는 목표에 모순됩니다.\n\n<div class=\"content-ad\"></div>\n\n2. 취소 및 스레드 관리 상속\n디스패치 큐 사이에 구체적인 사항을 상속할 수는 있지만, 하나의 작업 항목의 취소는 자식 작업 항목으로 전파되지 않습니다. 제대로 처리되지 않을 경우에는 여전히 스레드가 증가할 수 있으며, 이는 잠재적으로 리소스 문제로 이어질 수 있습니다.\n\n3. 큐 굶주림과 강렬한 작업\n단일 작업 단위를 위해 많은 큐를 생성하거나 CPU 집약적 작업을 단일 큐에서 실행하는 것은 스레드 굶주림으로 이어질 수 있습니다. 디스패치 큐는 작업 항목간 협력을 위한 도구가 부족하여 CPU 이용률을 공정하게 제어하는 데 어려움을 겪습니다.\n\n4. 협력적인 동시 코드 부재\nGCD는 강력하지만, 협력적인 동시 코드를 작성하기 위한 기능이 부족합니다. 작업 항목은 휴식 시간에 다른 리소스를 활용할 수 있게 허용하지 않으면 CPU 시간을 경쟁하게 됩니다.\n\n5. 데이터 레이스 완화\nGCD는 데이터 레이스를 방지하기 위한 바리어 같은 동기화 도구를 제공하나, 명시적 처리가 필요하며 전통적인 NSLock 같은 잠금과 비교해 속도가 느릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Summary\n\n요약하자면, GCD는 강력한 병렬 처리 도구를 제공하지만, 암시적 데이터 흐름, 취소 상속, CPU 자원 관리, 협력적 병렬 코드 및 효과적인 데이터 경쟁 처리와 같은 문제를 해결하는 것은 여전히 개선이 필요한 부분입니다. GCD 도구는 도움이 되지만 병렬 처리 모델에 깊게 통합되지는 않아, 이러한 세밀한 문제들을 효과적으로 처리하는 책임은 개발자에게 있습니다.\n\n다음 단계: Swift에서 병렬 처리를 마스터하고 싶나요? 다음 챕터인 '병렬 처리 마스터링: Task'을 살펴보세요.\n\n# Series Navigation\n\n<div class=\"content-ad\"></div>\n\n- 제1부: 스위프트에서 쓰레드 탐구\n- 제2부: 스위프트의 Operation Queues 탐구: 한계와 함께 쓰레딩 향상\n- 제3부: 스위프트에서 Dispatch Queues 숙달하기: 이해, 구현 및 한계\n- 제4부: 병행성 마스터링: Task\n- 제5부: 스위프트 병행성: @Sendable 및 Actors로 데이터 보호하기","ogImage":{"url":"/assets/img/2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations_0.png"},"coverImage":"/assets/img/2024-05-23-MasteringDispatchQueuesinSwiftUnderstandingImplementationandLimitations_0.png","tag":["Tech"],"readingTime":7},{"title":"사용자 정의 Segmented Control  SwiftUI","description":"","date":"2024-05-23 13:08","slug":"2024-05-23-CustomSegmentedControlSwiftUI","content":"\n이 기사에서는 SwiftUI 프레임워크 내에서 사용자 정의 디자인을 적용한 Segmented Control 예제를 찾을 수 있습니다. 이 방법은 애플리케이션에 특별히 디자인된 Segmented Control을 사용자화합니다.\n\n![Custom Segmented Control Example](/assets/img/2024-05-23-CustomSegmentedControlSwiftUI_0.png)\n\n# Segmented Controls\n\n애플 사전적 정의에 따르면 Segmented Control은 두 개 이상의 세그먼트로 구성된 일련의 요소로, 각각 버튼의 역할을 합니다. Segmented Control 내에서 모든 세그먼트는 일반적으로 동일한 너비를 갖고 있습니다. 버튼과 같이 세그먼트에는 텍스트나 이미지가 포함될 수 있습니다. 세그먼트 아래에 텍스트 레이블을 가질 수도 있습니다(또는 제어 전체 아래에). Segmented Control은 단일 선택 또는 다중 선택을 제공할 수 있습니다. (1).\n\n<div class=\"content-ad\"></div>\n\nSwiftUI 라이브러리에서는 Segmented, UIKit 프레임워크에서는 UISegmentedControl라고 해요.\n\n# 사용자 정의 세그먼트 컨트롤\n\n앱의 테마에 맞게 디자인하려면 아래 방법을 따라주세요.\n\n이번에는 두 개의 요소로 구성된 세그먼트 컨트롤을 디자인하겠습니다. 이를 위해 0과 1로 구성된 enum 타입으로 관리할 거에요.\n\n<div class=\"content-ad\"></div>\n\n```js\n// 0 : 카메라\n// 1 : 사진 라이브러리\n```\n\n아래는 디자인 출력입니다. 그에 따라 개발되었습니다. ⬇️\n\n<img src=\"/assets/img/2024-05-23-CustomSegmentedControlSwiftUI_1.png\" />\n\n```js\nimport Foundation\nimport SwiftUI\n\nstruct CustomSegmentedControl: View {\n    @Binding var preselectedIndex: Int\n    var options: [String]\n    // 이 색상은 테마 라이브러리에서 가져온 것입니다\n    let color = ThemeManager.shared.currentTheme.currentPallet.secondary\n\n    var body: some View {\n        HStack(spacing: 0) {\n            ForEach(options.indices, id:\\.self) { index in\n                ZStack {\n                    Rectangle()\n                        .fill(color.opacity(0.2))\n\n                    Rectangle()\n                        .fill(color)\n                        .cornerRadius(20)\n                        .padding(2)\n                        .opacity(preselectedIndex == index ? 1 : 0.01)\n                        .onTapGesture {\n                            withAnimation(.interactiveSpring()) {\n                                preselectedIndex = index\n                            }\n                        }\n                }\n                .overlay(\n                    Text(options[index])\n                )\n            }\n        }\n        .frame(height: 50)\n        .cornerRadius(20)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nCustom Segmented Control 클래스는 두 개의 매개변수를 사용합니다. 첫 번째 매개변수는 현재 선택된 아이템을 나타내고, 두 번째 매개변수는 아이템 배열 문자열로 사용됩니다. 이 배열은 상수로 정의할 수 있습니다.\n\n중요한 점은 첫 번째 매개변수가 @Binding으로 표시되어야 한다는 것입니다.\n\n이 매개변수는 @state로 유지하고 sourcetype과 함께 뷰로 전송됩니다.\n\n제스처와 함께 작동하는 작은 애니메이션이 있는 코드가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\nVStack{\n     CustomSegmentedControl(preselectedIndex: $selectedSegmentSourceType,\n        options: [Localization.value(\"photos.title\"), Localization.value(\"camera.title\")])\n}\n```\n\n또한, 컨트롤에서 변경한 값은 뷰에서 sourcetype 변수와 함께 만들어집니다.\n\n이 변수를 통해 선택 상태를 읽을 수 있습니다.\n\n다음 글에서 이 세그먼트 컨트롤과 피커를 함께 사용할 예정이에요. ❤️‍🔥\n\n\n<div class=\"content-ad\"></div>\n\n# 자료들\n","ogImage":{"url":"/assets/img/2024-05-23-CustomSegmentedControlSwiftUI_0.png"},"coverImage":"/assets/img/2024-05-23-CustomSegmentedControlSwiftUI_0.png","tag":["Tech"],"readingTime":3},{"title":"기술 및 미디어 부문의 침체로 비윤리적인 기업들이 어떻게 이용하고 있는지 알아보기","description":"","date":"2024-05-23 13:07","slug":"2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors","content":"\n\n<img src=\"/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png\" />\n\n와이어드 기사인 \"테크 취업 면접이 어미잡아\"는 내 학생들이 얼마나 오랫동안 말해왔던 불쾌한 추세를 확인했어요. 몇몇 부도덕한 회사들이 취업 면접을 무료로 가치 있는 작업을 제공하도록 변형시키고 있어요.\n\n일주일 전, 한 MBA 학생이 사회 네트워크를 위한 콘텐츠를 몇 일 동안 생성하는 것을 포함한 선발 프로세스에 대한 경험을 나누었어요. 많은 전문 경험을 가진 사람들이 이런 작업을 하는 것을 요구하는 것은 \"그동안과 고생이 되었어요\"의 수준까지 이를 강요하는 것과 다를 바 없어요.\n\n기술과 미디어 기업이 대규모 인력 감축을 하고 있는 시기에, 일부 부도덕한 회사들이 개발자들에게, 예를 들어, \"데스크톱 어플리케이션을 처음부터 만들고, 백엔드 시스템 모형에 연결하고, 모든 단계를 철저히 문서화하라\" 또는 \"현재 어플리케이션에 대한 새로운 기능을 개발하고 문서화하라\"를 요구하고 있어요. 이 프로젝트들은 때로는 몇 일이 걸릴 수 있고, 후보자들은 보상받지 않은 채로 작업을 하게 되며, 제출 후 회사는 단순히 개발자에게 \"선발 프로세스에 실패했다\"고 말한 후 그 작업을 계속 사용할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n이러한 채용 관행은 단순히 후보자들로 하여금 회사를 위해 무료로 일하도록 유도하는 방법에 불과합니다. 어떤 사람이 얼마나 그 일에 관심이 있더라도 받아들일 필요가 없으며, 이러한 관행은 거부되고 공개되어야 합니다. 윤리적이고 부도덕한 회사들에 대해 매우 주의해야 합니다. 시장 상황을 악용하여 자격있는 노동력을 착취하고 무료 노동을 얻을 수 있는 회사들입니다. 이러한 방식으로 일 하는 회사와의 전문적인 관계에서는 아무런 긍정적인 결과를 기대할 수 없습니다.","ogImage":{"url":"/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png"},"coverImage":"/assets/img/2024-05-23-Howunscrupulouscompaniesaretakingadvantageofthedownturninthetechandmediasectors_0.png","tag":["Tech"],"readingTime":1},{"title":"Salesforce 마케팅 클라우드에 WhatsApp 통합하기 단계별 가이드","description":"","date":"2024-05-23 13:06","slug":"2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide","content":"\n\n<img src=\"/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png\" />\n\n즉각적인 메시징 시대에 있어 WhatsApp와 Salesforce Marketing Cloud (SFMC)를 통합하면 고객과의 참여를 크게 향상시키고 커뮤니케이션을 간소화할 수 있습니다. 이 통합을 통해 기업은 WhatsApp의 대규모 사용자 기반과 실시간 커뮤니케이션 기능을 마케팅 자동화 워크플로 내에서 직접 활용할 수 있습니다. Salesforce Marketing Cloud에 WhatsApp를 통합하는 방법에 대한 포괄적인 안내서입니다.\n\n# 단계 1: 사전 요구 사항 이해\n\n• Salesforce Marketing Cloud 계정: 필요한 설정을 구성할 관리자 액세스 권한이 있는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n• WhatsApp 비즈니스 계정: 공식 WhatsApp 비즈니스 솔루션 제공업체(BSP)를 통해 승인된 WhatsApp 비즈니스 계정이 필요합니다. \n\n• Twilio 계정: Twilio는 WhatsApp를 SFMC와 통합할 수 있게 해주는 인기있는 BSP입니다. 활성화된 Twilio 계정과 API 자격 증명을 보유하고 있는지 확인해주세요.\n\n# 단계 2: WhatsApp용 Twilio 설정하기\n\n1. Twilio 가입: Twilio에서 계정을 생성하고 Twilio Console로 이동하세요.\n\n<div class=\"content-ad\"></div>\n\n2. WhatsApp Business 신청: Twilio를 통해 WhatsApp 비즈니스 프로필을 제출하고 승인을 받으세요. 이 과정에는 비즈니스 정보 제공과 전화번호 인증이 포함됩니다.\n\n3. API 자격 증명 획득: 승인된 후 Twilio 계정 SID, Auth Token 및 WhatsApp 활성화된 전화번호를 받으세요.\n\n# 단계 3: Salesforce Marketing Cloud 구성\n\n1. Salesforce Marketing Cloud에 로그인: 관리자 자격 증명을 사용하여 SFMC 대시보드에 액세스하세요.\n\n<div class=\"content-ad\"></div>\n\n2. Mobile Studio로 이동하려면: SFMC 인터페이스에서 Mobile Studio로 이동합니다.\n\n3. WhatsApp 채널 만들기:\n\n- '관리'로 이동하고 '계정 설정'을 선택합니다.\n\n- '채널'을 클릭하고 'WhatsApp'을 선택합니다.\n\n<div class=\"content-ad\"></div>\n\n• 필요한 정보를 입력하세요. Twilio 계정 SID, 인증 토큰 및 WhatsApp 번호를 포함해야 합니다.\n\n4. 연락처 데이터 설정: SFMC의 연락처 데이터에는 전화번호가 WhatsApp 통신용으로 형식화되어 있어야 합니다. 이는 일반적으로 전화번호 앞에 0이나 특수 문자가 없는 국제 형식을 사용하는 것을 의미합니다.\n\n# 단계 4: WhatsApp 메시지 작성\n\n1. 메시지 템플릿 생성: WhatsApp은 비즈니스에서 시작된 대화에 대해 사전 승인된 메시지 템플릿이 필요합니다. Twilio에서 이러한 템플릿을 생성하고 승인을 요청하세요.\n\n<div class=\"content-ad\"></div>\n\n2. SFMC로 템플릿 가져오기: 승인되면 Salesforce Marketing Cloud에 이러한 템플릿을 가져옵니다.\n\n# 단계 5: SFMC에서 WhatsApp 캠페인 만들기\n\n1. Journey Builder: SFMC의 Journey Builder를 사용하여 WhatsApp을 커뮤니케이션 채널로 포함한 고객 여정을 만듭니다.\n\n- 고객 여정 워크플로에 'WhatsApp 전송' 활동을 끌어다 놓습니다.\n\n<div class=\"content-ad\"></div>\n\n• 미리 승인된 템플릿을 선택하고 연락처 데이터를 매핑하여 메시지를 개인화하세요.\n\n2. 자동화 스튜디오: 고객이 취한 특정 이벤트 또는 조치에 따라 WhatsApp 메시지를 트리거하는 자동화를 설정하세요.\n\n# 단계 6: 테스트 및 배포\n\n1. 통합 테스트: 라이브로 이동하기 전에 메시지가 올바르게 보내지고 수신되는지 확인하기 위해 철저한 테스트를 수행하세요.\n\n<div class=\"content-ad\"></div>\n\n2. 모니터링 및 최적화: 배포 후에는 SFMC의 분석 도구를 통해 WhatsApp 캠페인의 성능을 모니터링하고 최적화하세요. 참여 지표와 피드백에 기반하여 최적화하세요.\n\n시나리오: 소매 회사가 Salesforce Marketing Cloud 내에서 마케팅 및 서비스 업무에 WhatsApp을 통합하여 고객 지원 및 참여를 개선하고자 합니다.\n\n# 목표:\n\n1. WhatsApp을 통해 실시간 고객 지원 제공하기.\n\n<div class=\"content-ad\"></div>\n\n**솔루션:**\n\n- 실시간 지원: 고객은 지원 문제를 위해 WhatsApp을 통해 채팅을 시작할 수 있습니다. SFMC와의 통합을 통해 고객 서비스 담당자가 고객 데이터 및 상호 작용 기록에 액세스하여 신속하고 맞춤형 지원을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n• 프로모션 및 업데이트: 주문 확인, 배송 알림 및 개인 맞춤 프로모션 제공을 위해 자동화된 WhatsApp 메시지를 보낼 수 있어 고객들이 항상 정보를 받고 참여할 수 있도록 합니다.\n\n# 구현 단계별 순서:\n\n## 1. WhatsApp을 위한 Twilio 설정:\n\n## 2. SFMC 구성:\n\n<div class=\"content-ad\"></div>\n\n## 3. 메시지 템플릿 만들기:\n\n## 4. 고객 여정 구축:\n\n## • 환영 메시지:\n\n## • 주문 확인:\n\n<div class=\"content-ad\"></div>\n\n## • 배송 알림:\n\n## • 프로모션 제안:\n\n• SFMC의 분석 도구를 사용하여 WhatsApp 캠페인의 성능을 추적하세요.\n\n• 오픈률, 응답률 및 고객 피드백을 모니터링하세요.\n\n<div class=\"content-ad\"></div>\n\n• 데이터 통찰을 기반으로 메시지와 워크플로우를 지속적으로 최적화하세요.\n\n## • 맞춤화:\n\n고객 데이터를 활용하여 WhatsApp 메시지를 맞춤화하여 참여도와 응답률을 향상시킵니다.\n\n## • 준수:\n\n<div class=\"content-ad\"></div>\n\nWhatsApp의 비즈니스 정책과 GDPR와 같은 데이터 보호 규정을 준수해주세요.\n\n## • 세분화:\n\n대상을 분할하여 타겟팅된 및 관련성 있는 메시지를 보내어 캠페인의 효과를 향상시켜주세요.\n\nFollow Me:\n\n<div class=\"content-ad\"></div>\n\n루치카 산돌카 (함께成長합시다) 🫱🏻‍🫲🏽\n\n또는\n\n매일 Salesforce 업데이트를 받기 위해 WhatsApp 커뮤니티에 참여해주세요.\n\n참여하기 위해 스캔: 📲\n\n<div class=\"content-ad\"></div>\n\n`/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_1.png`를 사용하려면 이미지 태그를 Markdown 형식으로 변경하면 됩니다.","ogImage":{"url":"/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-05-23-IntegratingWhatsAppintoSalesforceMarketingCloudAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"프로그래머를 위한 11가지 어첈없이 간단한 수동 소득 아이디어","description":"","date":"2024-05-23 13:05","slug":"2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers","content":"\n<img src=\"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png\" />\n\n프로그래머들은 창의적인 인간들이에요; 우리는 생각하고 혁신하고 만들어 냅니다.\n\n프로그래머가 되는 것도 중요하지만, 기업가적 사고를 갖춘 프로그래머가 되는 것은 또 다른 문제죠...\n\n그리고 지금 이 시점에서 이 기사를 읽고 계시다면, 여러분이 자신의 재정을 늘리기 위한 능력을 갖췄다고 믿어요.\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 프로그래머를 위한 11가지 수동 소득 아이디어를 공유하겠습니다.\n\n별 거짓말 없이, 이것은 인터넷의 무작위 쓰레기가 아닌 다음과 같은 내용에 대한 심층적인 탐구입니다:\n\n- 프로그래머로써 시도해본 것 중 실제로 성공한 사례,\n- 현재 탐색 중인 새로운 긍정적인 통찰,\n- 동료들의 성공적인 사업 모험과 내부 기술 커뮤니티에서의 경험,\n- 제대로 하고 있는 프로그래머들과의 몇 가지 개인 인터뷰.\n\n바로 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 수동 소득 뒤의 진실\n\n수동 소득은 추가적인 노력이 없거나 최소한의 노력으로 주기적으로 돈을 발생시킬 때 이를 지칭합니다.\n\n가장 중요한 노력은 설정할 때 들이는 노력일 것입니다.\n\n사실은;\n\n<div class=\"content-ad\"></div>\n\n본질적으로 수동 소득은 당신이 직접 시간을 돈으로 교환할 필요가 없는 소득원입니다.\n\n수동 소득 사업의 3가지 핵심 특징이 있습니다:\n\n- 막대한 시간 또는 자본의 초기 투자.\n- 적극적인 작업 없이 완전히 설정된 후 소득 생성\n- 운영 유지에 필요한 최소의 노력.\n\n보통 알려진 수동 소득 아이디어와 아직 탐험되지 않은 수동 소득 아이디어에 대해 이야기해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n프로그래머들을 위한 수익 창출 아이디어\n\n## 1. 블로깅\n\n프로그래머들이 수 pass 된소득을 발생시키는 가장 접근하기 쉬운 방법 중 하나는 블로깅이나 기술 콘텐츠 작성을 통해 이루어집니다.\n\n숙련된 프로그래머로서, 당신이 알려줄 수 있는 것들이 많습니다. 특히 새로운 개발자들에게 더 많은 것을 가르쳐줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n당신의 사고 패턴이나 프로세스/워크플로, 혹은 언어 전문 지식일 수 있습니다.\n\n개인 블로그를 시작하거나 Medium에 글을 쓰실 수도 있습니다.\n\n## 어떤 게 더 좋아요?\n\n저는 기술 블로그를 운영하고 있으며 Medium에도 글을 쓰고 있어요.\n\n<div class=\"content-ad\"></div>\n\n완전히 새로운 글쓰기에 입문하신 분이라면 Medium을 선택해보세요. 초보자에게 가장 적합한 글쓰기 플랫폼이에요.\n\n하지만 글을 쓰면서 돈을 벌 수 있는 방법은 무엇일까요? 처음 시작할 때 나도 궁금했던 문제였어요.\n\n여기서 간단히 알아보도록 할게요:\n\n- Medium 파트너 프로그램: Medium은 글을 쓰고 유료로 공개된 글에 게시하는 작가들에게 돈을 지급해요. Medium이 유료 사용자들로부터 수익을 올릴 때(프리미엄 글을 읽을 수 있는 사람들) 이익을 작가들과 분할해요.\n- 자체 호스팅된 블로그: 개인 블로그가 있다면 Ezoic, Mediavine 또는 Adthrive와 같은 품질 있는 광고 네트워크에 가입하여 수익을 창출할 수 있어요.\n- 제휴 마케팅과 후원: Medium/자체 호스팅 중 어느 플랫폼을 선택하든, 제휴 마케팅이나 후원을 통해 수익을 창출할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n두 달 전에, 블로그에서 한 제품으로 제휴 마케팅으로 120달러 이상을 벌었어요.\n\n![이미지](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_1.png)\n\n## 2. 온라인 강의\n\n자신이 잘하는 분야에 대한 강좌를 만들어보세요.\n\n<div class=\"content-ad\"></div>\n\n많은 사람들이 서면 자료 대신 비디오 강의를 선호합니다.\n\n최근 보고서에 따르면 2021년에만 Coursera에 2000만 명 이상의 신규 학습자가 등록했다고 합니다.\n\n일부 인기 있는 강의 플랫폼은 다음과 같습니다:\n\n- Udemy\n- Skillshare\n- Teachable\n\n<div class=\"content-ad\"></div>\n\n# 3. 유튜브 채널을 시작해보세요\n\n유튜브는 정보의 보고일 뿐만 아니라 Google 뒤를 이으며 두 번째로 큰 검색 엔진입니다.\n\n그러나 많은 사람들은 유튜브 채널을 시작하는 것을 힘든 작업으로만 생각하며, 특별한 사람들이나 대기업만이 할 수 있는 것으로 여기곤 합니다.\n\n하지만 이는 사실이 아닙니다. 저렴한 비디오 녹화 장비도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래 텍스트를 참고해주세요.\n\n\n![이미지](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_2.png)\n\n다음으로 생각해볼 문제는:\n\n## 채널을 만들면 어떤 주제로 이야기할까요?\n\n이 모두는 당신의 전문 분야에 따라 다릅니다.\n\n\n<div class=\"content-ad\"></div>\n\n개발 스택이나 기술 면접에서 성공하기 위한 도움이 되는 비디오 가이드, 소프트웨어 엔지니어링, 웹/앱 개발 등과 관련된 것들이 있을 수 있어요.\n\n채널을 시작하기 전에 FreeCodeCamp와 같은 큰 브랜드일 필요는 없어요.\n\n## 4. 디지털 제품 판매\n\n대부분 이북, 치트 시트 및 일반 정보 제품을 가리킵니다.\n\n<div class=\"content-ad\"></div>\n\n작년에는 29달러에 데브옵스 전자책을 판매하는 개발자와 인터뷰를 했어요. 그 책은 초보자를 위한 가이드처럼 보이는데, 그의 판매 대부분은 트위터 청중에서 나옵니다. 한 달에 약 1300달러를 벌어요.\n\nGumroad와 같은 플랫폼은 디지털 제품을 판매하고 수동 소득을 얻기 위한 마켓플레이스를 제공해요.\n\n# 5. 웹사이트 테마 및 템플릿 판매:\n\n프로그래머들에게 이는 매우 수익성 높은 수동 소득 사업임이 입증되었어요.\n\n<div class=\"content-ad\"></div>\n\n다음 웹 사이트 테마, 템플릿 및 플러그인을 판매할 수 있어요:\n\n- 테마 포레스트\n- 사이트 포인트\n- 템플릿 몬스터\n- 모조 마켓플레이스\n- 크리에이티브 마켓\n- 테마스냅\n- 코데스터\n\n![이미지](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_3.png)\n\n일반 판매 플랫폼 외에도 특정 CMS 마켓플레이스로도 직접 판매할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 다음과 같은 것들을 판매할 수 있어요:\n\n- Shopify 마켓플레이스에서 전자 상거래 테마\n- Ghost 마켓플레이스에서 Ghost 웹사이트 테마\n- WordPress.org에서 WordPress 웹사이트 테마\n\n# 6. 코드, 스크립트 및 플러그인 판매\n\nCMS 테마 이외에도, Code Canyon과 같은 웹사이트에서 직접 프로그래밍 코드, 스크립트 및 플러그인을 판매할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n부트스트랩, 자바스크립트, PHP, HTML5, 모바일/안드로이드 앱 템플릿 및 기타 코드 및 스크립트를 판매할 수 있습니다.\n\n여기에 Ladela가 디자인한 예약 및 일정 관리 소프트웨어 시스템 플러그인이 있어요.\n\nCode Canyon에서 $89에 판매 중이에요.\n\n이 기사를 작성하는 시점에서 52,525번의 판매로 총 $4,000,000 이상의 매출을 기록했어요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_4.png)\n\n# 7. API 개발\n\n소프트웨어 응용 프로그램이 증가함에 따라 API 서비스에 대한 수요가 증가하고 있습니다.\n\n실제 문제를 해결하거나 개발자에게 가치 있는 서비스를 제공하는 API (Application Programming Interfaces)를 개발하고 활용하세요.\n\n\n<div class=\"content-ad\"></div>\n\n접근을 유료로 제공하거나 계층별 요금제를 제공함으로써, 개발자가 API 서비스를 구독하는 동안 수동 소득을 얻을 수 있습니다.\n\n# 8. 크롬 확장 프로그램 만들기\n\n네, 맞아요. 크롬 확장 프로그램을 만들어 돈을 벌 수 있습니다.\n\n기술 기업가인 김 댕은 그녀의 크롬 확장 프로그램인 Group Convert로 100만 달러 이상을 벌었습니다.\n\n<div class=\"content-ad\"></div>\n\n4,000 회 이상의 설치를 보유하고 있으며 매월 $10에서 $17까지의 가격대를 가지고 있어요.\n\n김의 기능 확장은 Facebook 그룹 소유자가 그룹에 들어올 때 Facebook 사용자로부터 이메일을 수집하는 데 도움을 줘요.\n\n이 수동 소득 아이디어는 들리는 대로 쉽지 않지만 할만해요.\n\n# 9. 봇 생성\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_5.png\" />\n\n봇은 고객 서비스부터 소셜 미디어 관리까지 다양한 플랫폼에서 작업을 자동화하는 데 중요한 역할을 합니다.\n\n특정 사용 사례나 산업을 대상으로 하는 봇을 개발할 수 있습니다. 예를 들어 고객 지원용 챗봇이나 금융 시장용 거래 봇 등이 있습니다.\n\n한 번 배포되고 운영 중이면 구독 요금제나 사용량 기반 가격 책정을 통해 패시브 수입을 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 10. iOS 및 Android 애플리케이션 출시\n\n안드로이드 앱 개발자를 위해 특별히 디자인된 이 수동 수입 사업은 모바일 앱 개발자들을 대상으로 합니다.\n\n많은 앱들이 매일 Play 스토어와 App Store에서 출시되지만, 높은 경쟁으로 인해 소수만이 성공을 거두고 있습니다.\n\nSteven Benson은 혁신적인 경로 계획 앱인 Badger Maps를 설립했습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_6.png)\n\nWorking with a small team, he was able to quickly scale revenue to $6M ARR within a couple of years. I shared insights from an interview with him in a separate Medium article.\n\n# 11. Creating a SaaS or Micro SaaS\n\nThe last on the list and also what I'll consider the holy grail of passive income generation for programmers as it can lead to very high returns when done right.\n\n\n<div class=\"content-ad\"></div>\n\n인기 있는 SaaS 제품의 예시는 다음과 같습니다:\n\n- 프로젝트 관리를 위한 ClickUp.\n- 실시간 채팅을 위한 Zendesk.\n- 랜딩 페이지 제작을 위한 Leadpages.\n- 마케팅 보고서를 위한 Whatagraph.\n- 자동 PDF 생성을 위한 JotForm PDF 편집기.\n- 파일 및 문서 관리를 위한 Bit.ai.\n- 링크 관리를 위한 Bitly.\n- 일페이지 웹사이트 구축을 위한 Carrd.\n\n일주일 전에 여기에서 두 친구가 SaaS 비즈니스를 55,000 달러의 월 평균 반복 수익으로 확장한 방법에 대한 기사를 게시했어. 한번 확인해봐.\n\nSaaS 비즈니스를 구독 기반 가격으로 제공함으로써, 지속적인 반복 수익을 창출하고 지속 가능한 수 pass받는 소득원을 구축할 수 있어.\n\n<div class=\"content-ad\"></div>\n\n## 주의:\n\n무엇을 도와드릴까요?\n\n- 제 뉴스레터 가입하기 (글 작가 창업가를 위한 프리미어 뉴스레터).\n- 제 미디엄 계정 팔로우하기 (가치 있는 정보를 얻을 수 있습니다).\n","ogImage":{"url":"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png"},"coverImage":"/assets/img/2024-05-23-11StupidSimplePassiveIncomeIdeasforProgrammers_0.png","tag":["Tech"],"readingTime":7},{"title":"자바 개발자로 성장하기 위한 자료와 로드맵","description":"","date":"2024-05-23 13:03","slug":"2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper","content":"\n\n## DSA, 데이터베이스, 시스템 설계, 객체지향 프로그래밍, 자바, 테스팅, 그리고 더 많은 것들…\n\n![2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0](/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png)\n\n안녕하세요, 독자 여러분! 저는 인도 마이크로소프트에서 5년의 산업 경험을 가진 소프트웨어 엔지니어 II입니다.\n\nLinkedIn, Medium, 그리고 친구들로부터 제가 발전하기 위해 사용한 자원에 관한 메시지를 많이 받았어요. 기다리셨던 대로요! 이제 내가 항상 활용하는 자원들을 여러분과 공유하려고 합니다.\n\n<div class=\"content-ad\"></div>\n\n저는 현재 마이크로소프트에서 근무하기 전 주로 Java에 대한 배경을 가지고 있었습니다. 이 영역에서 자원과 고급 기술을 공유하는 데 초점을 맞출 것입니다. 하지만 다른 분야에서도 일반적인 자원 및 IT 산업에서 업그레이드하는 로드맵을 참고할 수 있습니다.\n\n## 참고 — 블로그 안내\n\n- 이 블로그에는 제가 배운 것과 경험한 것이 담겨 있습니다. 모든 것에 동의하지 않을 수도 있습니다. 각 개발자에게는 다른 여정이 있습니다.\n- 이 분야에서 전진하기 위한 순차적 기술과 이정표, 필수 기술 및 전문가 팁을 강조하는 로드맵을 공유할 것입니다. 또한 인터뷰에서 가장 많이 물어보는 주제들을 언급할 것입니다.\n- 또한 내 프로젝트에서 거의 학습하고 공식 튜토리얼을 참조하지 않은 많은 도구들을 실제로 사용한 리소스를 공유할 것입니다.\n- 섹션 사이에 관련된 Medium 블로그를 공유할 것입니다.\n- 자세히 읽어보시고 빠뜨리지 않도록 마지막까지 읽어주시기 바랍니다.\n\n질문이 있으면 언제든지 물어보시거나 LinkedIn에서 DM을 보내주시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n# 로드맵과 자원\n\n## 1. 기초 지식\n\n## Java 핵심:\n\nJava와 여러분이 주력으로 하는 언어에서 전문가가 되도록 노력하세요. 여러분이 뛰어난 분야를 가지는 것은 유익합니다.\n\n<div class=\"content-ad\"></div>\n\n개발자님 안녕하세요!\n\n다양한 회사에서 일반적인 인터뷰를 실시하기 때문에 언어는 영구적으로 변경될 수 있어요. 특히 제품 중심 회사들이 그렇죠.\n\n저는 자바 개발자로 시작했지만 스칼라, 파이썬으로도 일해봤고 이제는 C++과 C#으로 작업 중이에요.\n\n제 자료: Java Tutorial | Learn Java Programming — javatpoint\n\n## 객체 지향 프로그래밍 (OOPs):\n\n<div class=\"content-ad\"></div>\n\n각 개념의 중요성을 이해하고 문제를 실질적으로 해결하는 방법을 배웁시다.\n\n내 자료: 자바 OOPs 개념 — Javatpoint\n\n## 데이터 구조와 알고리즘 (DSA):\n\n문제 해결을 위한 필수 데이터 구조와 알고리즘을 마스터하는 것이 중요합니다. 제품 중심 기업에서의 면접을 성공적으로 통과하는 데 필수적입니다.\n\n<div class=\"content-ad\"></div>\n\n요즘에는 서비스 기반 조직들도 클라이언트의 요구에 따라 DSA 질문을 하기도 합니다.\n\nDSA는 논리 개발과 알고리즘 구축에도 유용합니다. 예를 들어, 저는 은행 분야 프로젝트에서 슬라이딩 윈도우 기법을 활용한 적이 있습니다.\n\n나의 자료:\n\n- Scott Barrett의 \"Java 자료 구조 및 알고리즘 + LEETCODE 연습\" (Udemy)\n- Tim Buchalka, Goran Lochert의 \"자바를 사용한 자료 구조 및 알고리즘 심층 탐구\" (Udemy)\n- LeetCode (매일 연습)\n\n<div class=\"content-ad\"></div>\n\n## 2. 중급 스킬\n\n## 멀티스레딩, 동시성, 병렬성:\n\n많은 영역에서 중요하고 널리 사용되며, 회사들은 인터뷰 중 이러한 영역에 대한 능숙함을 기대하기도 합니다.\n\n저는 내 인터뷰 중 대략 60% 정도에서 이러한 주제에 관한 질문을 받았습니다.\n\n<div class=\"content-ad\"></div>\n\n내 자료:\n\n- Java 멀티스레딩, 병행성 및 성능 최적화 — Michael Pogrebinsky (Udemy)\n- Peter Lee의 글: 자바에서의 병행성과 병렬성 | Peter Lee | Medium\n- Multiprogramming vs Multiprocessing vs Multitasking vs Multithreading — Javatpoint\n- G. Abhisek의 글: 병행성, 병렬성, 스레드, 프로세스, 비동기 및 동기 — 관련되어 있나요? 🤔 | G. Abhisek | Swift India | Medium\n\n## 기본 원리, 프레임워크 및 데이터베이스:\n\nSpring Framework: 자바 개발자로서 계속 발전하려면, 의존성 주입, 제어의 역전, 그리고 관점 지향 프로그래밍과 같은 중요한 Spring Framework 개념을 탐구하고 Spring Core, Spring Data, Spring MVC 및 기타 관련 Spring 개념을 다루는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n나의 자원: Spring 튜토리얼 | Baeldung\n\nMySQL: 이것은 중요하며 프로젝트와 인터뷰에서 관계형 데이터베이스, SQL 쿼리 및 데이터베이스 설계 작업에 능숙해지기 위해 항상 필요할 것입니다. \n\nHibernate: 처음에는 ORM(Object-Relational Mapping)에 대해 알아야 하고 Hibernate를 사용하여 데이터베이스와 상호 작용하는 방법을 알아야 했습니다.\n\n소프트웨어 디자인 원칙: 경험 많은 개발자로서 반드시 갖춰야 할 기술은 최적화된 시스템을 설계하는 것이므로 면접이나 지식 습득 시 빠뜨리지 마세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n소프트웨어 디자인 원리:\n\n- 디자인 원칙 - 상속보다는 조합을 선호합니다 | LinkedIn\n- 소프트웨어 디자인 원리 | 추상화, 확장성, 응집도 (workat.tech)\n- 예제로 배우는 자바에서의 상속보다는 조합 선호하기 - GeeksforGeeks\n- 의존성 주입에 대한 빠른 소개: 무엇인지 및 언제 사용해야 하는지 (freecodecamp.org)\n- 소프트웨어 디자인 원리 (기본) | DRY, YAGNI, KISS 등 (workat.tech)\n\n## 3. 고급 기술\n\n## 스프링 부트:\n\n<div class=\"content-ad\"></div>\n\n스프링 부트는 스프링 플랫폼에 추가된 기능으로, 설정보다는 규약에 중점을 둔다.\n\n스프링 부트를 사용하여 서비스 및 웹 애플리케이션을 구축하는 방법에 대해 알아보세요.\n\n내 자료: Spring Boot 배우기 | Baeldung\n\n## 마이크로서비스 아키텍처:\n\n<div class=\"content-ad\"></div>\n\n제 3부에서 언급했지만, 요즘 개발자 인터뷰에서 가장 많이 묻는 주제 중 하나에요.\n\n마이크로서비스의 원리를 이해하고, 설계하고, 구현하고, 배포하는 방법을 알아보세요.\n\n## Apache Kafka/RabbitMQ:\n\n이것들은 개발자에게 추가로 좋은 기술들이에요. 널리 사용되며 개발자의 실용적인 지식을 향상시킬 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n스케일러블하고 분산 시스템을 구축하기 위한 메시지 브로커에 대해 알아보세요.\n\n가장 중요한 것은 모든 것을 왜 필요로 하는지 알아야 합니다 (왜 처음부터 그들이 필요한지).\n\n내 자료: Apache Kafka 튜토리얼 시리즈 힌디어 버전 - YouTube\n\n## AWS:\n\n<div class=\"content-ad\"></div>\n\nAWS 및 AWS, Azure, GCP 등과 같은 모든 클라우드 서비스는 중요합니다. 매일 다른 취직 공고에서 이에 관한 언급을 찾을 수 있을 거에요.\n\n회사들은 시니어 개발자들이 클라우드 플랫폼 서비스에 대해 실무 경험이 있어야 한다고 기대하며, 최소한 입문자 수준에서도 공통적인 서비스에 대한 경험이 필요합니다.\n\n이미 이러한 프로젝트 경험이 있나요? 와! 없다면, 오늘부터 시작해 볼까요? 직접 POC(Concept of Proof)를 해보세요.\n\n호스팅, 저장 및 컴퓨팅을 위한 클라우드 서비스를 탐색해보세요. 여기서 배운 것의 \"무엇\"과 \"왜\"도 알아야 합니다.\n\n<div class=\"content-ad\"></div>\n\n내 자료: [NEW] Ultimate AWS Certified Cloud Practitioner CLF-C02 — by Stephane Maarek (Udemy)\n\n## 4. 전문분야\n\n## REST API:\n\nRESTful API를 설계하고 구현하는 방법을 배워보세요. 마이크로서비스에서 RESTful API가 널리 사용되고 개발자들로부터 기대되므로 이를 숙지하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n## 통합 테스팅 및 유닛 테스팅:\n\n분산 시스템에서 컴포넌트 간의 통합 테스팅 및 독립적인 컴포넌트의 유닛 테스팅하는 중요성과 방법에 대해 이해합니다.\n\nJUnit, Mockito, Cucumber, 그리고 Chai(node.js)와 같은 도구들이 유명합니다.\n\n유닛 테스트는 온라인 평가 및 머신 코딩 인터뷰 라운드의 일부가 되기도 합니다.\n\n<div class=\"content-ad\"></div>\n\n그 외에도, 이러한 것들은 개발자가 코드에서 채택해야 하는 매우 유익한 관행들입니다.\n\n## 시스템 설계:\n\n여기서 고수준 설계 (HLDs)와 저수준 설계 (LLDs) 같은 용어가 나옵니다.\n\nSSEs에서는 HLDs가 깊게 다뤄지며, LLDs는 상위 수준에서 기대됩니다. 기본 LLDs도 SSEs로부터 요청될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그래서, 확장 가능하고 신뢰할 수 있는 시스템을 설계하는 기술을 숙달해보세요. 어떤 구성 요소를 사용할지, 왜 사용하는지, 그리고 어떻게 사용할지를 알아야 합니다.\n\n시스템 설계는 가장 많은 반문이 있는 면접 라운드입니다. 따라서 시스템 설계 질문에 대한 각 구성 요소의 요구 사항을 매우 잘 이해해야 합니다.\n\n나의 자료:\n\n- 시스템 설계 튜토리얼 — GeekforGeeks\n- 초보자를 위한 시스템 설계 — YouTube\n\n<div class=\"content-ad\"></div>\n\n## 5. 도구 및 기술\n\nGit, Maven, Gradle: 개발자들이 알아야 하는 기본적인 도구로 버전 관리, 의존성 관리 및 빌드 자동화 도구가 포함됩니다.\n\nDocker, Kubernetes: 애플리케이션을 배포하고 관리하기 위한 컨테이너화 및 오케스트레이션을 탐색해보세요.\n\nJenkins, JIRA: Agile 개발을 위한 CI/CD 파이프라인과 프로젝트 관리 도구에 대해 이해해보세요.\n\n<div class=\"content-ad\"></div>\n\n## 6. 전문 기술\n\n- 커뮤니케이션: 팀원 및 이해관계자들과 효율적인 협업을 위해 커뮤니케이션 기술 향상하기.\n\n- 리더십과 팀 관리: 프로젝트를 성공적으로 완료하기 위해 팀을 리드하고 관리하는 방법 익히기. 시니어 개발자로서 중요한 기술이에요.\n\n- 애자일 방법론: 요즘은 거의 80% 이상의 회사가 인터뷰 후보자가 스크럼이나 칸반 등 애자일 원칙 및 방법론, 그리고 JIRA, Confluence, SDLC와 같은 도구에 대해 이해하거나 경험이 있기를 기대해요.\n\n<div class=\"content-ad\"></div>\n\n## 요약\n\n저는 수준별로 모든 것을 나열했습니다.\n\nDSA와 함께 '||'가 있으면 DSA가 다른 모든 수준과 병렬로 처리될 수 있음을 나타내며 (이상적으로는 절대 중지하면 안 됨).\n\n2024년 현재 Java 개발자에게 필요한 최고의 기술은 DSA, 시스템 디자인, Java, 마이크로서비스, Spring Boot, AWS/Azure와 같은 클라우드 플랫폼, Apache Kafka/RabbitMQ와 같은 메시지 브로커, MySQL과 같은 데이터베이스, 그리고 Redis와 같은 캐싱 메커니즘이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n경험 많은 직원들에게 기대되는 기본적인 기술은 Git, CI/CD 파이프라인에 대한 이해, 그리고 자동화 도구 구축입니다.\n\n오늘날 인터뷰에서는 'Docker'와 'Kubernetes'와 같은 용어가 특히 강조됩니다.\n\nGitHub Actions, Telemetry, Spinnaker, Datadog, New Relic 등의 APM 도구는 추가 요건으로 고려됩니다.\n\n지금까지 만난 가장 중요한 기술들이며 이러한 분야에서 뛰어나거나 이를 뛰어넘는다면 다수의 개발자들 사이에서 돋보이게 되어 어려운 인터뷰에 성공하거나 MAANGs와 같은 주요 기술 회사에서 취업할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n현재 학습하거나 복습하고 있는 개념이 있나요? 저는 레벨 5에 있어서 Docker와 Kubernetes를 배우고 있어요.\n\n또한, 아래 블로그들도 확인해보세요:\n\n질문이 있으면 답글로 물어보시거나 LinkedIn에서 메시지를 보내주세요. 또한, 다음에 다루고 싶은 다른 주제가 있다면 제안해주세요.","ogImage":{"url":"/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png"},"coverImage":"/assets/img/2024-05-23-ResourcesandRoadmaptoUpgradeasaJavaDeveloper_0.png","tag":["Tech"],"readingTime":7}],"page":"53","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}