{"pageProps":{"posts":[{"title":"루비로 API를 구축하는 강력한 프레임워크, Grape","description":"","date":"2024-06-22 22:31","slug":"2024-06-22-GrapeAPowerfulFrameworkforBuildingAPIsinRuby","content":"\n\n웹 애플리케이션 또는 API를 개발하는 경우, 아마도 루비 프로그래밍 언어의 강력한 프레임워크인 Grape에 대해 들어보셨을 것입니다. Grape는 개발자에게 API를 빠르고 편리하게 생성하는 도구를 제공하며, 개발자 커뮤니티에서 인기를 얻고 있습니다.\n\n![Grape](/assets/img/2024-06-22-GrapeAPowerfulFrameworkforBuildingAPIsinRuby_0.png)\n\n```ruby\nmodule V1\n  # 기본 API 클래스\n  class Api < Grape::API\n    version 'v1', using: :path\n\n    mount Budget\n    mount Backend\n  end\nend\n```\n\nGrape는 간결하고 가벼운 프레임워크로, 간단한 것부터 복잡한 API를 생성하기에 적합합니다. 루비 프레임워크 Sinatra 위에 구축되어 있어, 이미 Sinatra에 익숙한 개발자들에게 매력적입니다. Grape의 주요 특징은 간단하고 직관적인 구조에 있습니다. 라우트, 리소스 및 API 매개변수를 정의하기 위한 선언적 DSL(Domain-Specific Languages) 세트를 개발자에게 제공하여 효율적이고 유연한 API를 빠르고 쉽게 생성할 수 있도록 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\nGrape의 주요 장점 중 하나는 그 명확성입니다. 그것은 경로를 정의하는 간단하고 이해하기 쉬운 방법을 제공하며 GET, POST, PUT 및 DELETE와 같은 모든 종류의 HTTP 요청을 처리합니다. 또한, Grape는 JSON 및 XML과 같은 다양한 데이터 형식에 대한 내장 지원을 갖추고 있어 RESTful API를 만드는 데 이상적인 선택지입니다.\n\n```javascript\nrequire 'grape-swagger'\n\n# Root API class\nclass RootApi < Grape::API\n  format :json\n  prefix :api\n\n  helpers do\n    def permitted_params\n      @permitted_params ||= declared(params, include: false)\n    end\n  end\n\n  mount ::V1::Api\n\n  add_swagger_documentation \\\n    host: ENV.fetch('SWAGGER_HOST'),\n    doc_version: '0.0.1',\n    base_path: '',\n    mount_path: '/v1/docs',\n    add_base_path: true,\n    add_version: true,\n    info: {\n      title: 'Grape API',\n      contact_url: 'https://localhost:3000'\n    },\n    array_use_braces: true\nend\n```\n\n더불어, Grape는 강력한 데이터 유효성 검사 기능을 갖고 있습니다. Grape를 사용하면 쉽게 요청 매개변수를 선언하고 유효성을 검사할 수 있어 데이터 무결성을 보장하고 API의 보안성을 높일 수 있습니다. 또한 데이터 직렬화 및 표현을 단순화하는 Grape::Entity와 같은 확장을 사용할 수도 있습니다.\n\n하지만 그것만이 아닙니다! Grape는 API의 기능을 설정하고 확장하는 다양한 옵션을 제공합니다. 인증 및 권한 부여 메커니즘, 확장 가능한 플러그인, 요청 필터 등을 지원하며 훨씬 더 많은 기능까지 제공합니다. 또한 ActiveRecord 및 Grape-Swagger와 같은 유용한 gem들과 통합하여 더 많은 유연성과 편의성을 얻을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n요약하자면, Grape은 루비로 API를 구축하기 위한 강력하고 유연한 프레임워크입니다. 간단한 구문, 사용 편의성 및 다양한 기능적 기능을 갖추고 있습니다. 웹 애플리케이션을 위한 API를 만들어야 한다면, Grape은 개발에서 효율성과 유연성을 달성하기 위한 훌륭한 선택입니다.","ogImage":{"url":"/assets/img/2024-06-22-GrapeAPowerfulFrameworkforBuildingAPIsinRuby_0.png"},"coverImage":"/assets/img/2024-06-22-GrapeAPowerfulFrameworkforBuildingAPIsinRuby_0.png","tag":["Tech"],"readingTime":2},{"title":"Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법","description":"","date":"2024-06-22 22:29","slug":"2024-06-22-HowITuningPumaforRubyonRailsatKubernetes","content":"\n\n## 쿠버네티스에 맞게 Puma 튜닝하기\n\nPuma는 Ruby on Rails용 인기 있는 웹 서버 패키지이며, Puma 구성을 잘 튜닝하면 서비스 효율성이 더욱 향상됩니다.\n\nPuma 젬: [https://rubygems.org/gems/puma](https://rubygems.org/gems/puma)\n\n![이미지](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 왜 리팩토링 해야 하나요?\n\n가장 중요한 이유는 도커에서 쿠버네티스 아키텍처로 마이그레이션할 때, Puma 구성을 새 아키텍처에 맞게 업데이트해야 할 수도 있다는 것입니다. 따라서, 저는 많은 기사와 소스 저장소를 재조사하여 이를 다시 작성하는 데 도움을 받았어요.\n\n# Puma 구성 튜닝을 하기 전, 확인해야 할 사항\n\n- 처음에는 가장 중요한 서비스를 사용하지 마세요. 그 대신 부수적인 서비스를 사용하세요. \n예를 들어, 먼저 테스트할 때 회원 OAuth 서비스를 사용하지 마세요. 이 예에서, 저는 테스트용으로 메일 센터를 사용했어요. (대부분의 요청이 내부 호출이며, 요청이 실패하면 다시 시도합니다.)\n- 서비스의 온라인 상태를 확인하기 위해 모니터링 서비스 중 하나가 반드시 필요해요. 저는 서비스와 쿠버네티스 상태를 확인하기 위해 Datadog를 사용하고 있어요.\n- 각 구성 설정과 단계별 튜닝을 위해 왜 그리고 어떻게 하는지 알아야 해요.\n\n<div class=\"content-ad\"></div>\n\n# Puma 구성 리팩터링\n\n## 우리의 초기 Puma 구성\n\n첫 번째 구성은 다음과 같습니다.\n\n```js\n#!/usr/bin/env puma\n\nenvironment ENV.fetch(\"RAILS_ENV\") { \"development\" }\n\nif ENV['RAILS_ENV'].nil? || ENV['RAILS_ENV'] == 'development'\n  threads_count = ENV.fetch(\"RAILS_MAX_THREADS\") { 5 }\n  threads threads_count, threads_count\n\n  port ENV.fetch(\"PORT\") { 3000 }\n\n  plugin :tmp_restart\nelse\n  directory './'\n  rackup \"./config.ru\"\n\n  pidfile \"./tmp/pids/puma.pid\"\n  state_path \"./tmp/pids/puma.state\"\n\n  threads 0,16\n\n  port ENV.fetch(\"PORT\") { 3000 }\n\n  workers 2\n\n  prune_bundler\n\n  on_restart do\n    puts 'Refreshing Gemfile'\n    ENV[\"BUNDLE_GEMFILE\"] = \"./Gemfile\"\n  end\nend\n```\n\n<div class=\"content-ad\"></div>\n\n## 리팩터링 키포인트 1: 스레드 용량 감소\n\n일부 참조 링크를 조사했는데, 먼저 그것들을 확인해보세요.\n\n- [문서] 쿠버네티스에 적합한 Puma 튜닝 방법\n- 최대 효율을 위한 Puma, Unicorn 및 Passenger 구성\n- Pod 당 워커 및 기타 구성 문제\n\n마지막 문제 토론에 따르면, 너무 많은 스레드를 사용하는 것은 더 많은 요청을 수용하기에 적합하지 않으며, 리소스가 Global VM 락에 직면할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n우리 설정에서는 각 워커에 너무 많은 스레드를 설정했어요. 그래서 이것이 제 첫 번째 반응 대상이 됐어요.\n\nPuma 문서의 기사에 따르면, 쿠버네티스 팟 * Puma 워커 * 스레드가 최종 총 용량이라는 걸 알 수 있어요.\n\n이전에 우리의 용량은 64였어요. 2 (팟) * 2 (워커) * 16 (최대 스레드)인거죠. 큰 감소가 심각한 문제를 일으킬 것을 두려워해서, 처음에는 스레드를 8로 순차적으로 감소시켰고, 마지막에 5로 줄였어요 (총 용량은 20이 될 거예요).\n\n```js\n# puma.rb\n# Puma에게 1에서 5 범위 내에서 스레드를 자동 조정하도록 설정합니다.\n# 각 스레드가 더 많은 CPU / 메모리 리소스를 갖으므로 16에서 5로 줄였어요.\nthreads 0, 5\n```\n\n<div class=\"content-ad\"></div>\n\n## Refactor Key 2: CPU 코어의 수를 신뢰성 있게 감지할 수 있어야 합니다.\n\n초기 설정에서는 이전 도커 인프라에서 각 서비스가 사용할 수 있는 2개의 vCPU를 가지고 있기 때문에, 종업원을 두 명으로 설정했습니다.\n\n첫 번째 시도에서, 새로운 Rails 버전의 Puma 구성 설정을 참조하여 CPU를 감지하였습니다.\n\n```js\n# Specifies that the worker count should equal the number of processors in production.\nif ENV[\"RAILS_ENV\"] == \"production\"\n  worker_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\n  workers worker_count if worker_count > 1\nend\n```\n\n<div class=\"content-ad\"></div>\n\n루비 메소드를 사용하여 CPU 프로세서 카운트를 감지하는 것은 좋은 아이디어에요. \"물리 프로세서 수\" 또는 \"OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서\"를 기준으로 결정할 수 있어요.\n\n```js\n# Module: Concurrent\n\nrequire \"concurrent-ruby\"\n\n# 현재 시스템의 물리 프로세서 코어 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\nConcurrent.physical_processor_count\n\n# OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\nConcurrent.processor_count\n```\n\n만약 Kubernetes 베이스 클러스터 노드에 CPU가 4개 있고, 서비스를 1000(µs) CPU 리소스로 제한한다면, Coucurrnet 메소드를 사용하면 항상 4를 반환할 거에요 (호스트 수준 리소스가 보이기 때문에 팟 수준 리소스가 아니에요).\n\n그래서 Puma가 Kubernetes 설정을 직접 읽을 수 있도록 해야 해요. 다음과 같이 시도해 봤어요:\n\n<div class=\"content-ad\"></div>\n\n\n# K8S CPU 제한을 설정하는 방법을 확인하세요.\n## cpu.cfs_quota_us는 그룹이 해당 창기간 동안 사용할 수 있는 최대 CPU 시간(마이크로초 단위)을 지정합니다.\n## cpu.cfs_period_us는 CPU 액세스를 위한 시간 창문의 길이(마이크로초 단위)를 나타냅니다.\n\n## quota가 -1이면 CPU 자원 사용에 대한 제한이 없는 것을 의미합니다.\n\n\"concurrent-ruby\"을 요구합니다.\nquota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\nperiod_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\nquota = File.read(quota_file).strip.to_i\nperiod = File.read(period_file).strip.to_i\n\nif quota != -1\n  processors_count = (quota.to_f / period.to_f).ceil\nelse\n  processors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\nend\n\n\nCPU 자원이 제한되지 않는 경우에는 서비스가 노드의 CPU 최대 범위를 사용할 수 있으므로 물리적 프로세서 개수를 기반으로 설계되었습니다. 제한이 있는 경우 계산하세요!\n\n## 리팩터링 핵심 3: 항상 서비스에 시간 제한을 설정하세요.\n\nSidekiq 작성자인 마이크의 글을 예전에 읽었는데도 기억이 싱싱합니다. 모든 네트워크 요청에는 타임아웃을 설정해야 한다는 교훈을 주었습니다.\n\n<div class=\"content-ad\"></div>\n\n제가 참고한 GitHub은 puma 타임아웃 설정을 위해 the-ultimate-guide-to-ruby-timeouts입니다. 매우 유용합니다.\n\n![이미지](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_1.png)\n\n## 리팩터링 핵심 4: 에러 처리 설정하기.\n\nPuma에는 기본 에러 처리 구성이 내장되어 있습니다. 또한 오류를 캡처하는 Sentry 시스템도 있으므로 에러가 발생할 때 Sentry 캡처를 추가하는 것이 좋아 보입니다!\n\n<div class=\"content-ad\"></div>\n\n```js\r\n# 참조: https://github.com/puma/puma?tab=readme-ov-file#error-handling\n\nlowlevel_error_handler do |e|\n  Sentry.capture_exception(e)\n  [500, {}, [\"오류가 발생했습니다\"]]\nend\r\n```\n\n## 최종 Puma 설정\n\n```js\r\n# 이 구성 파일은 Puma에 의해 평가될 것입니다. 여기에서 호출되는 최상위 메서드들은\n# Puma의 구성 DSL의 일부입니다. DSL에서 제공하는 메서드에 대한 자세한 정보는 https://puma.io/puma/Puma/DSL.html에서 확인하세요.\n\n# Puma는 설정 가능한 일정 수의 프로세스(작업자)를 시작하고 각 프로세스는 내부 스레드 풀에서 스레드로 각 요청을 처리합니다.\n#\n# 각 작업자당 이상적인 스레드 수는 응용 프로그램이 IO 작업을 기다리는 시간과\n# 처리량을 지연 시간보다 우선시할지에 따라 다릅니다.\n#\n# 일반적으로 스레드 수를 늘리면 특정 프로세스가 처리할 수 있는 트래픽 양(처리량)이 늘어납니다.\n# 그러나 CRuby의 Global VM Lock (GVL)로 인해 반응 시간(지연 시간)이 악화될 수 있고\n# 수응용 프로그램의 경우 감소하기 때문에 이 형벌이 선뜻 좋은 결정이라고 할 수 없습니다.\n#\n# 평균적인 Rails 응용 프로그램에 대한 처리량과 지연 시간 사이의 괜찮은 절충으로 간주되는 3개의 스레드로 설정됩니다.\n#\n# 연결 풀이나 다른 리소스 풀을 사용하는 모든 라이브러리는\n# 스레드 수와 동일하거나 그 이상의 연결을 제공하도록 구성되어야 합니다.\n# 이에는 `database.yml`의 Active Record의 `pool` 매개변수가 포함됩니다.\ndefault_threads_count = ENV.fetch(\"RAILS_MAX_THREADS\") { 3 }\nthreads default_threads_count, default_threads_count\n\n# 프로덕션 및 준비 단계에서 작업자 수를 프로세서 수와 동일하게 설정\nif rails_env == \"production\" || rails_env == \"preparing\"\n  # 프로세스 당 1개 이상의 스레드를 실행중인 경우 작업자 수\n  # 기본적으로 프로세서(컴퓨터 코어)의 수와 동일하게 설정해야합니다.\n  #\n  # 이것은 신뢰할 수 없te, CPU 코어의 수를 신뢰할 수없습니다.\n  # `WEB_CONCURRENCY` 환경 변수를 프로세서 수와 일치하도록 설정하는지 확인하세요.\n  require \"concurrent-ruby\"\n\n  # config 파일로부터 K8S CPU 한정 메모리 확인\n  ## cpu.cfs_quota_us는 그 그룹이 그 창에서 사용할 수 있는 최대 CPU 시간(밀리 초 단위)을 지정합니다.\n  ## cpu.cfs_period_us는 CPU 액세스 시간 창의 길이를 지정합니다.\n  quota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\n  period_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\n  quota = File.read(quota_file).strip.to_i\n  period = File.read(period_file).strip.to_i\n\n  if quota != -1\n    processors_count = (quota.to_f / period.to_f).ceil\n  else\n    processors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\n  end\n\n  # 작업자 및 스레드 설정\n  if processors_count > 1\n    workers processors_count\n    threads 0, 5\n\n    on_worker_boot do\n      ActiveRecord::Base.establish_connection if defined?(ActiveRecord)\n    end\n  else\n    preload_app!\n  end\n\n  worker_timeout 15\n  worker_shutdown_timeout 8\nend\n\n# Puma가 요청을 수신하기 위해 청취하는 `포트`를 지정; 기본값은 3000입니다.\nport ENV.fetch(\"PORT\") { 3000 }\n\n# Puma가 실행할 `환경`을 지정합니다.\nenvironment rails_env\n\n# `bin/rails restart` 명령으로 Puma를 다시 시작할 수 있도록 허용\nplugin :tmp_restart\npidfile ENV[\"PIDFILE\"] if ENV[\"PIDFILE\"]\n\nif rails_env == \"development\"\n  # 디버거에 의해 일시 중단되었을 때 Puma에 의해 작업자가 종료되지 않도록 매우 넉넉한 `worker_timeout`를 지정합니다.\n  worker_timeout 3600\nend\n\n# 응용 프로그램의 범위를 벗어난 오류가 발생하면 Puma가 500 및 간단한 텍스트 오류 메시지와 함께 응답\nlowlevel_error_handler do |e|\n  Sentry.capture_exception(e)\n  [500, {}, [\"오류가 발생했습니다\"]]\nend\r\n```\n\n이전에 언급하지 않았던 몇 가지 작은 변경 사항이 있지만 참고하실 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- **on_worker_boot** 메소드를 사용해보세요.\n작업자가 부팅될 때 항상 ActiveRecord가 데이터베이스에 연결되어 있는지 확인하세요 (필요하다면 Redis를 추가할 수도 있습니다).\n\n- 여러 작업자를 사용하는 경우 **preload_app!**는 기본적으로 켜져 있습니다.\nRails에서는 새로운 Puma 템플릿이 작업자 수가 1인 경우에도 preload_app를 사용합니다.\nhttps://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\n\n# 모든 것을 모니터링하세요\n\n만든 변경사항은 항상 모니터링되어야 함을 기억하세요.\n\n새로운 환경 설정을 프로덕션에 배포할 때 문제가 없어야 합니다. (물론, 우리는 준비된 환경이 있고 서비스가 작동하는지 확인하기 위해 몇 가지 스트레스 테스트를 수행하였지만, 요청량은 프로덕션 환경과 비교할 수 없을 정도로 상이합니다.)\n\n<div class=\"content-ad\"></div>\n\n요청 용량을 64에서 20으로 줄인 후에도 서비스는 잘 작동했어요. CPU 및 메모리 사용량이 크게 개선되지는 않았지만, 스레드 용량을 더 적합한 상황으로 줄여 GVL을 피하려고 성공적으로 조정했습니다.\n\n![그림 1](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_2.png)\n\n![그림 2](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_3.png)\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n- 멀티스레드인 경우, Puma 워커 당 1개의 CPU를 할당하세요.\n참고: https://github.com/puma/puma/issues/2645#issuecomment-867629826\n- 대부분의 Puma는 워커 당 약 512MB ~ 1GB의 메모리를 사용하며, 마스터 프로세스에 대략 1GB를 사용합니다.\n참고: https://github.com/puma/puma/issues/2645#issuecomment-867629826\n- 대부분의 Puma는 각 쓰레드 당 약 300MB ~ 500MB의 메모리를 사용합니다.\n이는 웹 서비스의 유형과 기능에 따라 다를 수 있으며, Ruby 3 및 Rails 6 응용 프로그램을 실험하면서 각 프로세스가 약 200MB ~ 400MB 정도 사용한다는 기사를 참조했습니다.\n참고: https://www.speedshop.co/2017/10/12/appserver.html\n- 각 Puma 워커를 3 ~ 5개의 쓰레드로 설정하는 것이 일반 목적에 가장 적합합니다.\n참고 1: https://github.com/rails/rails/issues/50450\n참고 2: https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration\n- 자원에 따라 구성이 동적으로 조정되도록 하세요.\n- 웹 서비스에 대한 시간 초과 및 오류 처리 메커니즘을 항상 설정하세요.\n참고 1: https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\n참고 2: https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts\n- 생산 환경에 배포하기 전에 중요하지 않은 서비스부터 사용하고, 배포 전에 더 많은 테스트를 수행하세요.\n- 생산 환경에 배포할 때 모니터링 서비스를 사용하여 모든 변경 사항을 처리하고 기록하는 데 도움을 받으세요.\n\n# 참고 자료\n\n- https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server\n- https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma\n- https://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues\n- https://github.com/puma/puma?tab=readme-ov-file#clustered-mode\n- https://github.com/puma/puma?tab=readme-ov-file#error-handling\n- https://github.com/puma/puma/issues/2645\n- https://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb\n- https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\n- https://github.com/rails/rails/issues/50450\n- https://puma.io/puma/Puma/DSL.html\n- https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method\n- https://www.speedshop.co/2017/10/12/appserver.html\n- https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/","ogImage":{"url":"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png"},"coverImage":"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png","tag":["Tech"],"readingTime":11},{"title":"Ruby on Rails로 OCR 시스템 구축하는 방법","description":"","date":"2024-06-22 22:27","slug":"2024-06-22-HowIbuiltanOCRSystemwithRails","content":"\n\n친구와의 대화 중에 이 아이디어가 떠올랐어요. 친구가 문서를 스캔하고 분석해야 할 일이 많다는데, 시간을 내기가 어려워한다는 걸 언급했더라구요. 그 일이 어려운 작업으로 들리고, 스트레스를 받고 있다는 걸 알 수 있었어요. 그래서 \"어쩌면 해결책을 찾을 수도 있겠네요\" 라고 말했죠. 그 순간, Ruby와 RTesseract를 사용하여 작은 스크립트를 만들기로 결심했어요. 이 스크립트는 그의 문서 스캔을 도와주는 것뿐만 아니라 이미지에서 텍스트를 추출하기 위한 OCR 작업도 수행했답니다. 이 작업은 상당히 유용했고, 다른 사람들도 이 아이디어의 더 강력한 버전에서 혜택을 받을 수 있을 거라 생각했어요. 그래서 이렇게 Rails 어플리케이션이 탄생했죠.\n\n![OCR 시스템을 Rails로 어떻게 만들었는지](/assets/img/2024-06-22-HowIbuiltanOCRSystemwithRails_0.png)\n\n# 사용할 도구\n\n## 이 프로젝트에서 사용할 도구는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 루비 온 레일즈: 난 올드 스쿨이라서.\n- Active Storage: 빠르니까.\n- Tailwind CSS: 요즘 누가 안 하는가?\n- Tesseract OCR: 마술사처럼 사진을 단어로 바꿔주지.\n- RTesseract: 우리 앱과 친구되게 만들어 주는 루비 젬이야.\n\n# 단계 1: 재료 준비하기\n\n먼저 레일즈 앱이 필요해. 하나 만들기 위해 다음 명령어를 실행해봐\n\n```js\nrails new ocr\ncd ocr\nrails active_storage:install\nrails db:migrate\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로, Tailwind가 필요합니다.\n\n```js\nbundle add tailwindcss-rails\nrails tailwindcss:install\n```\n\n이걸로 대부분의 작업이 끝날 거예요. 더 자세히 알고 싶다면, Tailwind의 문서를 살펴보세요.\n\n# 단계 2: 모델 생성하기\n\n<div class=\"content-ad\"></div>\n\n모델을 생성하여 파일 첨부 기능이 포함된 모델을 만들어봅시다. 예시를 위해 Document 모델을 생성해보겠습니다:\n원하시는 다른 열을 포함시킬 수 있습니다. 저는 제목 열만을 포함하겠습니다.\n\n```js\nrails generate model Document title:string\nrails db:migrate\n```\n\n# 단계 3: 모델 업데이트\n\n파일 첨부를 다루기 위해 Active Storage를 사용할 것입니다. 이를 통해 모델에 파일을 쉽게 첨부할 수 있습니다. Document 모델을 수정하여 파일 첨부를 포함하도록 해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 단계별로 설명해 드리겠습니다:\n\n- 모델 생성: 이미 제목 속성이 있는 문서 모델을 생성했습니다.\n- Active Storage 관계 추가: 문서 모델을 업데이트하여 하나의 첨부 파일이 있다는 것을 나타냅니다. 이는 Active Storage가 제공하는 has_one_attached 메서드를 사용하여 수행됩니다.\n- 모델 정의: app/models/document.rb에 있는 문서 모델 파일을 열고 다음 코드를 추가하세요:\n\n```ruby\nclass Document < ApplicationRecord\n  has_one_attached :file\nend\n```\n\n- has_one_attached :file: 이 코드는 Rails에게 각 문서 인스턴스가 첨부 파일을 하나 가질 수 있다고 알려줍니다. Active Storage가 첨부를 우리 대신 관리하며, 메타데이터는 데이터베이스에, 실제 파일은 구성된 저장 서비스(로컬 디스크, Amazon S3 등)에 저장됩니다.\n\n<div class=\"content-ad\"></div>\n\n우리 모델에 has_one_attached :file를 추가함으로써, 이제 생성할 컴포넌트가 또 하나 생겼습니다: 컨트롤러.\n\n# 단계 4: 컨트롤러 생성\n\n이제 모델을 설정했으니, 문서를 관리하고 파일 업로드를 처리하는 컨트롤러를 생성할 때입니다.\n\n```js\nrails generate controller Documents\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로, 문서를 업로드하고 표시하는 데 필요한 작업을 정의하겠습니다. app/controllers/documents_controller.rb에 위치한 DocumentsController 파일을 열어 다음 코드로 업데이트하세요:\n\n```js\nclass DocumentsController < ApplicationController\n  def new\n    @document = Document.new\n  end\n\n  def create\n    @document = Document.new(document_params)\n    if @document.save\n      redirect_to @document, notice: '문서가 성공적으로 업로드되었습니다.'\n    else\n      render :new\n    end\n  end\n\n  def show\n    @document = Document.find(params[:id])\n  end\n\n  private\n\n  def document_params\n    params.require(:document).permit(:title, :file)\n  end\nend\n```\n\n- new 액션: 이 액션은 새 Document 객체를 초기화합니다. 이것은 당신의 걸작을 위한 빈 캔버스를 설정하는 것과 같습니다. 여기서 미래의 OCR을 위해 파일을 업로드할 것입니다.\n- create 액션: 이 액션은 새 문서를 생성하는 작업을 처리합니다. 폼 (제목 및 파일)에서 매개변수를 가져와 새 Document 객체를 만들고 저장을 시도합니다. 저장에 성공하면 문서의 표시 페이지로 이동하여 성공 메시지가 표시됩니다. 실패한 경우 새 문서 양식을 다시 렌더링하여 실수를 수정할 수 있습니다. 이 액션에서 또한 파일 업로드를 처리합니다.\n- show 액션: 이 액션은 ID로 문서를 찾아서 표시합니다. 여기에서 마법이 일어날 것이지만, 현재는 파일을 표시만 합니다.\n\n# 단계 5: 뷰 생성\n\n<div class=\"content-ad\"></div>\n\n다음으로 뷰를 생성할 차례에요.\n\n아래 내용을 app/views/documents/new.html.erb에 추가해주세요:\n\n```js\n<!-- app/views/documents/new.html.erb -->\n<div class=\"min-h-screen bg-gray-100 flex items-center justify-center\">\n  <div class=\"bg-white p-8 rounded-lg shadow-md w-full max-w-md\">\n    <h2 class=\"text-2xl font-bold mb-6 text-center\">새 문서 업로드</h2>\n    \n    <%= form_with model: @document, local: true, class: \"space-y-6\" do |form| %>\n      <% if @document.errors.any? %>\n        <div class=\"bg-red-100 text-red-700 p-4 rounded-lg\">\n          <h3 class=\"font-bold\">제출 과정에 오류가 있습니다:</h3>\n          <ul class=\"list-disc list-inside\">\n            <% @document.errors.full_messages.each do |message| %>\n              <li><%= message %></li>\n            <% end %>\n          </ul>\n        </div>\n      <% end %>\n\n      <div class=\"space-y-2\">\n        <%= form.label :title, class: \"block font-medium text-gray-700\" %>\n        <%= form.text_field :title, class: \"block w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500\" %>\n      </div>\n\n      <div class=\"space-y-2\">\n        <%= form.label :file, class: \"block font-medium text-gray-700\" %>\n        <%= form.file_field :file, class: \"block w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500\" %>\n      </div>\n\n      <div>\n        <%= form.submit \"문서 업로드\", class: \"w-full bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500\" %>\n      </div>\n    <% end %>\n  </div>\n</div>\r\n```\n\n그리고 app/views/documents/show.html.erb에 다음 내용을 추가해주세요.\n\n<div class=\"content-ad\"></div>\n\n\n<p>\n  <strong>Title:</strong>\n  <%= @document.title %>\n</p>\n\n<p>\n  <strong>File:</strong>\n  <%= link_to @document.file.filename.to_s, rails_blob_path(@document.file, disposition: \"attachment\") %>\n</p>\r\n\n\n# Step 6: 라우트 추가\n\n이 부분은 Rails가 대부분 처리하기 때문에 작은 단계입니다. config/routes.rb에 다음을 추가해보세요:\n\n```ruby\nRails.application.routes.draw do\n  resources :documents, only: [:new, :create, :show]\nend\r\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 7: 스토리지 서비스 구성하기\n\n기본적으로 Active Storage는 파일을 저장하기위해 로컬 디스크를 사용합니다. config/storage.yml에서 Amazon S3, Google Cloud Storage 및 Microsoft Azure Blob Storage와 같은 다른 스토리지 서비스를 구성할 수 있습니다.\n\nActive Storage를 사용하면 구성 파일을 업데이트하여 이러한 스토리지 서비스 간에 쉽게 전환할 수 있습니다. 이 유연성을 통해 필요에 가장 적합한 스토리지 솔루션을 선택하고 애플리케이션이 성장함에 따라 확장할 수 있습니다.\n\n여기 우리 앱에서 사용할 구성입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n지금 이 작업을 해보세요. 터미널에 가서 앱을 시작해보세요.\n\n./bin/dev\n\n다음과 같은 내용이 나와야 합니다: \n```\n\n<div class=\"content-ad\"></div>\n\n<table> 태그를 Markdown 형식으로 변경하십시오.\n\n<div class=\"content-ad\"></div>\n\n당신의 Gemfile에 Gem을 추가해보세요.\n\n```js\ngem 'rtesseract'\n```\n\n# 단계 9: OCR 메소드 구현하기\n\n문서 모델에 OCR을 수행하는 메소드를 만들어보세요. 아래와 같이 할 수 있어요!\n\n<div class=\"content-ad\"></div>\n\n```rb\nclass Document < ApplicationRecord\n  has_one_attached :file\n\n  def perform_ocr\n    return unless file.attached?\n\n    file_path = ActiveStorage::Blob.service.send(:path_for, file.key)\n    image = RTesseract.new(file_path)\n    image.to_s\n  end\nend\n```\n\n# 단계 10: 컨트롤러 업데이트하여 OCR 사용\n\nOCR 수행을 위한 액션을 포함하도록 DocumentsController를 수정합니다:\n\n```rb\nclass DocumentsController < ApplicationController\n  def new\n    @document = Document.new\n  end\n\n  def create\n    @document = Document.new(document_params)\n    if @document.save\n      redirect_to @document, notice: '문서가 성공적으로 업로드되었습니다.'\n    else\n      render :new\n    end\n  end\n\n  def show\n    @document = Document.find(params[:id])\n    @ocr_text = @document.perform_ocr\n  end\n\n  private\n\n  def document_params\n    params.require(:document).permit(:title, :file)\n  end\nend\n```  \n\n<div class=\"content-ad\"></div>\n\n# 단계 11: OCR 텍스트 표시를 위한 뷰 업데이트\n\nshow.html.erb 뷰를 수정하여 OCR 텍스트를 표시합니다:\n\n```js\n<p>\n  <strong>제목:</strong>\n  <%= @document.title %>\n</p>\n\n<p>\n  <strong>파일:</strong>\n  <%= link_to @document.file.filename.to_s, rails_blob_path(@document.file, disposition: \"attachment\") %>\n</p>\n\n<% if @ocr_text.present? %>\n  <p>\n    <strong>OCR 텍스트:</strong>\n    <pre><%= @ocr_text %></pre>\n  </p>\n<% end %>\n```\n\n# 단계 12: Tesseract가 설치되었는지 확인하기\n\n<div class=\"content-ad\"></div>\n\n시스템에 Tesseract OCR이 설치되어 있는지 확인해주세요. 다음 명령어를 사용하여 운영 체제에 맞게 설치할 수 있습니다:\n\n```js\nmacOS:\nbrew install tesseract\n\nUbuntu:\nsudo apt-get install tesseract-ocr\n```\n\n앱을 실행한 후에는 다음과 같은 결과가 나타납니다:\n\n![OCR 결과](/assets/img/2024-06-22-HowIbuiltanOCRSystemwithRails_2.png)\n\n<div class=\"content-ad\"></div>\n\n텍스트에는 개선할 여지가 많이 있어요. 댓글로 의겢나 생각을 알려주세요.\n\n또한, 제 Github에서 전체 소스 코드를 확인하세요: https://github.com/luizcg/ocr","ogImage":{"url":"/assets/img/2024-06-22-HowIbuiltanOCRSystemwithRails_0.png"},"coverImage":"/assets/img/2024-06-22-HowIbuiltanOCRSystemwithRails_0.png","tag":["Tech"],"readingTime":8},{"title":"Rails 크론 잡 - Rails에서 작업 스케줄링 하는 방법","description":"","date":"2024-06-22 22:26","slug":"2024-06-22-RailsCronJobsTaskSchedulingInRails","content":"\n\n![image](/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png)\n\n언젠가 자동으로 작업을 예약해야 하는 상황에 처했던 적이 있나요? 매일 이메일을 보내거나 외부 API와 정기적으로 데이터를 동기화하는 것과 같은 작업들이 될 수 있습니다. 여기서 Cron 작업이 유용하게 사용됩니다. 이를 통해 이러한 작업들을 쉽게 자동화할 수 있습니다. 이 블로그에서는 예약된 작업을 실행하는 데 사용되는 Unix/Linux 시스템에 통합된 기본 소프트웨어인 Cron을 소개할 것입니다. 또한 Ruby Whenever Gem을 사용하여 특히 Rails 애플리케이션에서 Cron 작업을 쉽게 배포하는 빠른 가이드도 제공할 예정입니다.\n\n# Cron 작업이란?\n\nWhenever Gem을 사용한 Rails에서 Cron 작업을 사용하는 방법에 대해 설명하기 전에, cron 작업이 무엇인지 간단히 설명해 드리겠습니다. (이 주제에 대해 자세한 기사를 곧 쓸 것입니다)\n\n<div class=\"content-ad\"></div>\n\n간단히 말해서, Cron은 특정 시간에 반복적으로 작업을 예약하고 실행할 수 있게 해주는 명령줄 도구입니다. 이러한 작업들을 'cron jobs'라고 합니다. Cron은 Linux/Unix 시스템에 내장되어 있기 때문에 추가적인 종속성을 설치할 필요가 없습니다. 일반적으로 cron jobs는 'crontab'이라는 파일에 작성됩니다. 'crontab'은 Cron Table의 약자입니다. crontab 작업/cron job의 구문은 다섯 개의 숫자로 구성되어 있으며 각각은 작업을 실행해야 하는 시간을 나타내며 그 뒤에 실행할 스크립트가 따릅니다. 구문은 다음과 같아야 합니다:\n\n```js\n# ┌───────────── 분 (0 - 59)\n# │ ┌───────────── 시간 (0 - 23)\n# │ │ ┌───────────── 일 (1 - 31)\n# │ │ │ ┌───────────── 월 (1 - 12)\n# │ │ │ │ ┌───────────── 요일 (0 - 6) (일요일부터 토요일까지;\n# │ │ │ │ │ 7는 일요일일 수도 있음)\n# │ │ │ │ │\n# │ │ │ │ │\n# * * * * * 실행할 명령어\n```\n\n아래 다이어그램은 구문을 잘 설명하고 있습니다:\n\n<img src=\"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n레일즈 작업을 예약하는 데는 crontab을 사용할 수 있지만, 낡고 복잡하게 느껴질 수 있습니다. 이 프로세스는 다음 명령어를 사용하는 것을 포함합니다:\n\n```js\n0 * * * * 'cd path/to/project && bundle exec some_task'\n```\n\n# Whenever 젬\n\n이제 레일즈에서 cron 작업을 다루는 더 나은 방법에 대해 설명해 드리겠습니다. 전통적이고 다소 난잡한 crontab을 다루는 대신, 일정을 잡는 것이 훨씬 간편하고 우아한 루비 젬이 있습니다. 이 용도로 가장 많이 사용되는 젬은 Whenever입니다.\n\n<div class=\"content-ad\"></div>\n\n'Whenever'은 크론 작업을 설정하는 과정을 간소화하는 젬입니다. 크론탭을 수동으로 편집하는 대신 Whenever을 사용하여 루비 코드로 크론 작업을 작성할 수 있습니다. 이 젬은 크론탭을 자동으로 업데이트해줍니다.\n\n# Whenever 젬 설정하기\n\n이제 어플리케이션에 해당 젬을 설정하고 사용해봅시다. 먼저 젬을 설치해야 합니다. 아래와 같이 Gemfile에 젬을 포함시키고 bundle install을 실행하세요.\n\n```js\ngem 'whenever', require: false\n```\n\n<div class=\"content-ad\"></div>\n\n이제 젬을 초기화하기 위해 아래 명령을 실행해보세요.\n\n```js\nbundle exec .wheneverize\n```\n\n`.wheneverize` 명령을 실행하면 config 디렉토리, 구체적으로는 config/schedule.rb에 schedule.rb라는 이름의 파일이 생성됩니다. 이 파일은 작업 실행 시간을 정의하고 실행할 Rake 작업을 지정하는 역할을 합니다.\n\n이제 젬을 설정한 후 작업을 실제로 예약해 보겠습니다. 이를 위해서 Rake 작업을 만들어 시작하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n레일즈 g task batch send_messages\n```\n\n레일즈의 rake 태스크를 생성했다면, 해당 태스크 파일은 lib/tasks/sample.rb에 있을 거에요. 이제 이곳에 이메일을 보내는 기능을 추가해 보겠습니다.\n\n```js\n# lib/tasks/send_messages.rake\n\nnamespace :messages do\n  desc \"사용자에게 메시지 보내기\"\n  task send: :environment do\n    User.all.each do |user|\n      MessageMailer.send_message(user.email).deliver_now\n      puts \"#{user.email}님에게 메시지를 보냈습니다.\"\n    end\n  end\nend\n```\n\nRake 태스크에 로직을 추가했다면, schedular.rb 파일에 등록해 보세요. 여기서는 예시로 1분 간격으로 설정하겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n매 분마다\n    rake 'messages:send'\nend\n```\n\n그런 다음 crontab을 업데이트하고 해당 작업을 추가할 것입니다. 아래 명령을 실행하여 작업을 추가하실 수 있습니다.\n\n```js\nwhenever --update-crontab\n```\n\nCron Job을 성공적으로 설정했습니다. 특정 시간에 실행되도록 예약되었습니다. 또한 whenever --clear-crontab 명령을 사용하여 crontab을 지울 수 있고, crontab을 보려면 crontab -l을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Sidekiq-Cron Gem\n\nSidekiq-cron은 작업 처리 라이브러리인 Sidekiq의 애드온입니다. Sidekiq-cron을 사용하면 특정 시간이나 간격에 작업을 예약할 수 있습니다. Sidekiq-cron은 Sidekiq에서 제공하는 공식 젬이 아님을 유의해야 합니다.\n\nSidekiq에서 작업을 예약하는 것은 일반적으로 엔터프라이즈 수준의 기능으로 간주되어 유료 라이선스가 필요할 수 있습니다. 그러나 엔터프라이즈 버전에 돈을 쓰고 싶지 않다면 Sidekiq-cron은 여러분에게 적합한 대안입니다.\n\n간단히 말하면, Sidekiq-cron은 공식 엔터프라이즈 버전을 지불하지 않고도 Sidekiq 내에서 작업을 예약할 수 있게 해주는 도구입니다. 비슷한 예약 기능을 제공하여 작업이 언제와 얼마나 자주 실행되어야 하는지 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Sidekiq-Cron Gem 설정하기\n\n이제 우리의 애플리케이션에 Sidekiq-Cron 젬을 설정해 봅시다. 먼저 젬을 설치해야 합니다. Gemfile에 아래와 같이 젬을 추가하고 bundle install을 실행해주세요.\n\n```js\ngem 'sidekiq-cron'\n```\n\n그런 다음 config/ 디렉토리에 schedule.yml 파일을 생성하세요. Whenever 젬의 경우처럼 파일을 초기화하는 기능은 제공되지 않지만, 다행히 Sidekiq-Cron은 파일을 초기화하는 기능을 제공하지 않습니다. 또한 config/initializers 디렉토리에 sidekiq.rb라는 이름의 파일을 생성하여 아래 내용을 추가해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\r\nschedule_file = \"config/schedule.yml\"\nif File.exist?(schedule_file) && Sidekiq.server?\n   Sidekiq::Cron::Job.load_from_hash YAML.load_file(schedule_file)\nend\r\n```\n\n우리의 초기 설정이 완료되었습니다. 이제 실제 작업을 생성할 차례입니다. 터미널로 이동하여 다음 명령을 입력하세요.\n\n```js\r\nrails generate job send_bulk_emails\r\n```\n\n그리고 이 코드에 일부 기능을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n참고: 레일즈 백그라운드 작업/워커를 설정, 생성 및 사용하는 방법에 대한 자세한 튜토리얼이 필요하시다면 이 기사를 참조해주세요.\n\n```js\nclass SendBulkEmailJob < ApplicationJob\n  queue_as :default\n\ndef perform(emails)\n    begin\n      BulkEmailService.send_emails(emails)\n    rescue StandardError => e\n      Rails.logger.error \"Error sending bulk emails: #{e.message}\"\n      raise e\n    end\n  end\nend\n```\n\n작업을 만든 후, 터미널에 sidekiq을 입력하여 실행하고 다음과 같이 스케줄러 파일에 작업을 추가하세요:\n\n```js\nemail_job:\n   cron: \"*/5 * * * *\"\n   class: \"SendBulkEmailJob\"\n```\n\n<div class=\"content-ad\"></div>\n\n워커를 실행하려면 터미널에서 새 탭을 열어주세요. 앱이 활성화된 상태에서도 워커가 계속 실행되어야 하는 점을 주의해 주세요. 레일즈 서버를 시작하거나 기타 작업을 실행해야 하는 경우 다른 탭으로 전환해야 합니다.\n\n모두입니다! 첫 번째 Sidekiq-cron 작업을 생성한 것을 축하드립니다!\n\n# 결론\n\n요약하면, 크론 작업은 Unix/Linux 시스템에서 반복적인 작업을 자동화하는 데 필수적입니다. Whenever 젬은 루비 코드로 작성하고 크론 작업을 예약하는 레일즈 애플리케이션에서 간단하게 사용할 수 있도록 하며 crontab을 자동으로 업데이트합니다. Sidekiq-Cron은 Sidekiq에서 작업을 예약하는 데 유용한 젬입니다. 두 젬은 크론 작업을 관리하고 실행하는 과정을 간소화하여 애플리케이션의 자동화와 효율성을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n앞으로의 기사에서는 Rails가 어떻게 작동하는지에 대해 더 알아볼 것입니다. 그러니 계속해서 주의 깊게 지켜보고 배우세요!","ogImage":{"url":"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png"},"coverImage":"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png","tag":["Tech"],"readingTime":6},{"title":"Ruby on Rails에서 Rake Task와 Cron Job 비교 어느 것을 선택해야 할까","description":"","date":"2024-06-22 22:24","slug":"2024-06-22-RakeTaskvsCronJobinRubyonRails","content":"\n\n루비 온 레일즈로 작업을 하고 계신다면, 레이크 태스크와 크론 작업에 대해 들어보신 적이 있을 것입니다. 두 도구는 작업을 자동화하는 데 도움을 주지만, 다른 방식으로 사용됩니다. 이를 언제 어떻게 사용해야 하는지 이해하면 많은 시간을 절약하고 애플리케이션을 더 효율적으로 만들 수 있습니다. 이 글에서는 레이크 태스크와 크론 작업이 무엇인지, 어떻게 다른지, 언제 사용해야 하는지, 그리고 어떻게 사용해야 하는지 알아보겠습니다.\n\n# 레이크 태스크란 무엇인가요?\n\n레이크 태스크는 루비 온 레일즈에서 반복적인 작업을 자동화하는 데 도움을 주는 도구입니다. Rake는 \"루비 메이크\"를 의미합니다. 데이터 이동, 데이터 가져오기 또는 오래된 데이터 정리와 같은 작업을 수행할 수 있는 태스크를 생성할 수 있습니다. 레이크 태스크는 간단한 루비 코드를 사용하여 루비 온 레일즈 앱의 lib/tasks 폴더에 작성합니다. 이러한 태스크는 단순한 명령에서 데이터베이스 상호 작용을 포함한 복잡한 작업까지 모두 가능합니다.\n\n## 레이크 태스크를 사용하는 이유?\n\n<div class=\"content-ad\"></div>\n\nRake 작업은 Rails 애플리케이션과 완벽하게 통합되어 있어 매우 유용합니다. 이는 Rake 작업 내에서 모델, 라이브러리 및 설정을 쉽게 액세스할 수 있다는 것을 의미합니다. 예를 들어, 데이터베이스에서 모든 사용자 레코드를 업데이트해야 하는 경우, 모델 클래스를 사용하여 업데이트를 수행하는 Rake 작업을 작성할 수 있습니다.\n\n## Rake 작업 예시\n\n다음은 Rake 작업의 간단한 예시입니다:\n\n```js\n# lib/tasks/example.rake\nnamespace :example do\n  desc \"This is a sample Rake task\"\n  task :say_hello do\n    puts \"Hello from Rake task!\"\n  end\nend\n```\n\n<div class=\"content-ad\"></div>\n\n이 작업을 실행하려면 터미널에 다음 명령을 입력하세요:\n\n```js\nrake example:say_hello\n```\n\n이 명령은 \"Rake 작업에서 안녕하세요!\"를 터미널에 출력합니다. 이 예제는 간단하지만, Rake 작업은 여러 단계와 Rails 애플리케이션과 상호 작용을 포함한 더 강력하고 복잡할 수 있습니다.\n\n## Rake 작업의 일반적인 사용법\n\n<div class=\"content-ad\"></div>\n\n- 데이터베이스 마이그레이션: 데이터를 한 구조에서 다른 구조로 자동 이동하는 프로세스를 자동화합니다.\n- 데이터 씨딩: 초기 데이터나 테스트 데이터로 데이터베이스를 채웁니다.\n- 유지 관리 작업: 캐시를 지우거나 기록을 업데이트하거나 이전 데이터를 정리합니다.\n- 사용자 지정 스크립트: 애플리케이션의 요구에 특화된 작업을 수행합니다.\n\n# 크론 작업이란 무엇인가요?\n\n크론 작업은 Unix 기반 도구로, 특정 간격으로 작업을 실행할 수 있게 해줍니다. 크론 작업은 crontab이라는 파일에서 정의되며 일정과 실행할 명령을 지정합니다. 크론 작업은 정기적으로 발생해야 하는 작업(백업 생성, 시스템 상태 확인, 주기적 유지 보수 수행)에 적합합니다.\n\n## 왜 크론 작업을 사용해야 하나요?\n\n<div class=\"content-ad\"></div>\n\n크론 작업은 수동 개입 없이 정기적으로 실행해야 하는 작업을 자동화할 수 있어 강력합니다. 매일, 매주 또는 규칙적인 간격으로 발생해야 하는 작업에 이상적입니다. 예를 들어, 매일 자정에 보고서를 생성하는 스크립트가 있을 수 있습니다.\n\n## 크론 작업 예시\n\n다음은 매일 자정에 스크립트를 실행하는 크론 작업의 간단한 예시입니다:\n\n```js\n0 0 * * * /path/to/your/script.sh\n```\n\n<div class=\"content-ad\"></div>\n\n이 예제에서 0 0 * * *은 일정 시간을 지정하는 것(매일 자정)이고, /path/to/your/script.sh는 실행할 명령입니다. 이 명령은 간단한 셸 스크립트에서부터 레일즈 애플리케이션과 상호작용하는 복잡한 명령까지 어떤 것이든 될 수 있습니다.\n\n## 크론 구문 분석\n\n크론 구문은 공백으로 구분된 다섯 가지 필드로 구성되어 있습니다:\n\n\n* * * * * command_to_run\n- - - - -\n| | | | |\n| | | | +---- 주의 요일 (0-7) (일요일은 0과 7 둘 다)\n| | | +------ 월 (1-12)\n| | +-------- 월의 일 (1-31)\n| +---------- 시간 (0-23)\n+------------ 분 (0-59)\n\n\n<div class=\"content-ad\"></div>\n\n위의 예시 0 0 * * *를 살펴보겠습니다:\n\n- 분 (0): 이 필드는 작업이 실행되어야 하는 시간의 분을 나타냅니다. 여기서 0은 시간의 0분에 작업이 실행됨을 의미합니다.\n- 시간 (0): 이 필드는 24시간 형식의 하루의 시간을 나타냅니다. 여기서 0은 자정(00:00)에 작업이 실행됨을 의미합니다.\n- 월의 날짜 (*): 이 필드의 별표 *는 작업이 매월 매일 실행됨을 의미합니다.\n- 월 (*): 이 필드의 별표 *는 작업이 매월 실행됨을 의미합니다.\n- 주의 날짜 (*): 이 필드의 별표 *는 작업이 매주 매일 실행됨을 의미합니다.\n\n따라서, 0 0 * * *은 다음과 같습니다:\n\n- 분: 0 (시간의 시작)\n- 시간: 0 (자정)\n- 월의 날짜: 매일\n- 월: 매월\n- 주의 날짜: 매주 매일\n\n<div class=\"content-ad\"></div>\n\n다시 말해, 이 일정은 매일 자정(00:00)에 명령을 실행한다는 뜻입니다.\n\n## Cron 작업의 일반적인 사용\n\n- 백업: 데이터베이스나 중요 파일을 정기적으로 백업합니다.\n- 모니터링: 시스템 상태를 확인하거나 애플리케이션에 건강 점검을 수행합니다.\n- 유지 보수: 로그를 회전하거나 임시 파일을 정리하거나 기타 정리 작업을 수행합니다.\n- 자동 보고서: 일정한 간격으로 보고서를 생성하고 전송합니다.\n\n# Rake 작업과 Cron 작업의 차이점\n\n<div class=\"content-ad\"></div>\n\n양쪽 Rake 작업과 Cron 작업은 작업을 자동화할 수 있지만, 다른 방식으로 작동하며 서로 다른 유형의 작업에 적합합니다.\n\n## 실행 위치\n\n- Rake 작업: Rails 앱 내에서 실행됩니다. 앱의 모델, 라이브러리 및 설정을 쉽게 활용할 수 있습니다. 이는 Rake 작업이 애플리케이션의 코드와 데이터와 밀접하게 상호 작용해야 하는 작업에 이상적이라는 것을 의미합니다.\n- Cron 작업: 시스템 수준에서 실행됩니다. Rails 앱이 실행되지 않아도 됩니다. 대신 앱을 사용하는 스크립트를 호출할 수 있습니다. Cron 작업은 애플리케이션과 독립적으로 실행되어야 하는 작업에 적합하며, 시스템 유지보수 또는 주기적 데이터 처리와 같은 용도에 적합합니다.\n\n## 실행 방식\n\n<div class=\"content-ad\"></div>\n\n- Rake 작업: 수동으로 실행하거나 자동으로 실행하도록 설정해야 합니다. 이렇게 하면 작업이 언제, 어떻게 실행되는지 정확하게 제어할 수 있지만, 자동으로 실행되도록 설정하는 데 더 많은 작업이 필요합니다.\n- Cron 작업: crontab에서 설정한 시간에 자동으로 실행됩니다. Cron 작업은 수동 개입 없이 정기적으로 실행해야 하는 작업에 적합합니다.\n\n## 사용하기 편리한 정도\n\n- Rake 작업: Ruby를 사용하기 때문에 Rails 개발자에게 쉽습니다. 이미 Rails에 익숙한 경우 Rake 작업을 작성하고 실행하는 것이 간단합니다.\n- Cron 작업: Cron의 시간 구문을 배우고 시스템에 설정해야 합니다. Cron 작업은 강력하지만 Unix 시스템과 Cron 구문에 익숙하지 않은 경우 설정하기 어려울 수 있습니다.\n\n# 언제 Rake 작업을 사용해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n- 일회성 데이터 변경: 한 번에 데이터를 이동하거나 변경해야 하는 경우 Rake 작업을 사용하세요. 예를 들어, 데이터베이스의 모든 사용자 레코드를 업데이트해야 하는 경우 Rake 작업은 효율적으로 수행할 수 있습니다.\n- 사용자 지정 유지 보수 작업: 레일 모델에 액세스해야 하는 작업에 사용하세요. Rake 작업은 레일 앱 내에서 실행되기 때문에 앱의 데이터와 로직과 손쉽게 상호 작용할 수 있습니다.\n- 개발 및 테스트: 개발 중에 작업을 자동화하는 데 유용합니다. 예를 들어, 샘플 데이터 추가 또는 데이터베이스 재설정과 같은 작업을 수행할 수 있습니다. 이렇게 하면 시간을 절약하고 개발 환경 간의 일관성을 보장할 수 있습니다.\n\n# 크론 작업을 사용하는 시점\n\n- 정기 유지 보수: 백업이나 로그 정리와 같이 정기적으로 실행해야 하는 작업에 크론 작업을 사용하세요. 크론 작업은 스케줄에 따라 자동으로 실행되기 때문에 일관되게 발생해야 하는 작업에 적합합니다.\n- 시스템 수준 작업: 레일 앱 외부의 작업에 사용하세요. 시스템 업데이트와 같은 작업에 크론 작업을 사용할 수 있습니다. 크론 작업은 어떤 명령이든 실행할 수 있기 때문에 시스템 관리 작업에 다재다능합니다.\n- 백그라운드 처리: 주기적으로 데이터를 처리하는 백그라운드 작업에 적합합니다. 예를 들어, 큐잉된 이메일 처리 또는 주기적으로 검색 인덱스를 업데이트하는 데 크론 작업을 사용할 수 있습니다.\n\n# Rake 작업과 크론 작업을 결합하기\n\n<div class=\"content-ad\"></div>\n\n가끔은 Rake 작업과 Cron 작업을 함께 사용하는 것이 가장 좋을 때가 있어요. 예를 들어, Rails 앱에서 복잡한 작업을 처리하는 Rake 작업을 만든 다음 그 작업을 정기적으로 실행하도록 Cron 작업을 설정할 수 있어요.\n\n## 예시: Cron과 함께 Rake 작업 예약하기\n\nRake 작업 만들기\n\n```js\n# lib/tasks/cleanup.rake\nnamespace :db do\n  desc \"Cleanup old records\"\n  task :cleanup => :environment do\n    OldRecord.cleanup\n    puts \"Old records cleaned up\"\n  end\nend\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 db:cleanup 작업은 데이터베이스에서 이전 레코드를 정리합니다.\n\n크론으로 레이크 작업 예약\n\n크롬탭 파일을 crontab -e로 열고 다음을 추가하세요:\n\n```js\n0 3 * * * cd /path/to/your/app && bundle exec rake db:cleanup RAILS_ENV=production\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령은 매일 새벽 3시에 db:cleanup 작업을 설정합니다. cd /path/to/your/app 부분은 명령이 올바른 디렉토리에서 실행되도록 하고, bundle exec rake db:cleanup RAILS_ENV=production은 Rake 작업을 프로덕션 환경에서 실행합니다.\n\n# 결론\n\nRake 작업과 Cron 작업은 Ruby on Rails에서 작업을 자동화하는 유용한 도구입니다. Rake 작업은 일회성 및 Rails 특정 작업에 가장 적합하며, Cron 작업은 정기적 및 시스템 수준 작업에 가장 적합합니다. 두 가지를 함께 사용하여 Rails 애플리케이션을 효과적으로 자동화하고 모든 것을 원활히 유지할 수 있습니다.\n\n이 도구들을 이해하고 언제 사용해야 하는지 알면 Rails 애플리케이션을 더 효율적으로 관리할 수 있습니다. 일회성 데이터 이관을 수행하거나 정기적인 백업을 실행하거나 복잡한 작업을 자동화하더라도 Rake 작업과 Cron 작업을 사용하면 삶이 더 쉬워지고 애플리케이션이 더 견고해집니다.","ogImage":{"url":"/assets/img/2024-06-22-RakeTaskvsCronJobinRubyonRails_0.png"},"coverImage":"/assets/img/2024-06-22-RakeTaskvsCronJobinRubyonRails_0.png","tag":["Tech"],"readingTime":6},{"title":"2024년에 루비Ruby를 배울 가치가 있을까 루비 프로그래밍 언어와 그 프레임워크 완전 정복","description":"","date":"2024-06-22 22:23","slug":"2024-06-22-IsRubystillworthlearningin2024FullCoverageOfRubyProgrammingLanguageItsFrameworks","content":"\n\n\n![이미지](/assets/img/2024-06-22-IsRubystillworthlearningin2024FullCoverageOfRubyProgrammingLanguageItsFrameworks_0.png)\n\n# 소개:\n\n루비는 과대평가된 언어로, 기능이 약한 프레임워크와 비실용적인 사용법을 갖추고 있어 2024년에 학습할 가치가 없다고 이야기합니다. 하지만, 잠깐만요, 이게 정말 사실일까요?\n\n\n<div class=\"content-ad\"></div>\n\n당연히 아니에요! 루비에 대해 확실하게 이해하고, 루비가 값어치가 있고 시간과 노력을 들여 가치가 있는 기술 중 하나인 이유를 알아보세요!!\n\n# 루비의 개요 :\n\n먼저, 루비 언어에 대한 개요를 알아봅시다…\n\n# 프로그래밍 언어로서의 루비란?\n\n<div class=\"content-ad\"></div>\n\n루비는 간단함, 유연성, 그리고 생산성으로 유명한 동적 객체지향 프로그래밍 언어입니다. 1990년대 중반 일본의 유키히로 \"마츠\" 마츠모토에 의해 만들어졌습니다. 루비는 펄, 스몰토크, 에펠, 에이다, 그리고 리스프 등 여러 언어에서 영감을 받았습니다.\n\n## 주요 특징 및 특성:\n\n### 동적 타이핑:\n\n루비는 동적 타입 언어로, 변수의 타입을 선언할 필요가 없습니다. 해석기가 런타임에 타입을 결정합니다.\n\n<div class=\"content-ad\"></div>\n\n## 객체 지향:\n루비에서는 모든 것이 객체입니다. 심지어 클래스도 클래스 객체의 객체입니다. 이는 클래스, 상속 및 다형성과 같은 OOP 원칙을 지원한다는 것을 의미합니다.\n\n## 깔끔하고 우아한 구문:\n루비는 깨끗하고 직관적인 구문을 자랑하며 이로 인해 코드를 읽고 작성하기가 쉽습니다.\n\n<div class=\"content-ad\"></div>\n\n## 가비지 컬렉션:\n\n자동으로 메모리를 관리하기 때문에 메모리 할당 및 해제를 수동으로 관리할 필요가 없습니다.\n\n## 풍부한 표준 라이브러리:\n\n파일 입출력, 네트워킹 및 데이터 구조와 같은 작업에 대한 다양한 모듈과 클래스를 제공하는 포괄적인 표준 라이브러리가 함께 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 동적 코드 실행:\n\n루비를 사용하면 런타임에서 코드를 동적으로 실행할 수 있어서 메타프로그래밍과 같은 기능이 가능해집니다.\n\n## 메타프로그래밍:\n\n루비의 유연성을 통해 강력한 메타프로그래밍 기술을 사용할 수 있습니다. 이는 코드가 자체 구조나 동작을 수정할 수 있는 코드를 작성할 수 있다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n## 믹스인:\n\n믹스인을 지원합니다. 기존 상속을 사용하지 않고 클래스 간에 행동을 공유하는 방법입니다.\n\n## 커뮤니티 및 생태계:\n\n개발자들의 활발하고 역동적인 커뮤니티가 있습니다. RubyGems 패키지 관리자를 통해 사용할 수 있는 다양하고 풍부한 라이브러리와 젬(패키지) 생태계도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 크로스 플랫폼:\n\n루비는 크로스 플랫폼 언어로, 한 운영 체제에서 코드를 작성하고 다른 운영 체제에서 중요한 수정 없이 실행할 수 있습니다!\n\n![루비 이미지](/assets/img/2024-06-22-IsRubystillworthlearningin2024FullCoverageOfRubyProgrammingLanguageItsFrameworks_1.png)\n\n# 루비로 무엇을 개발할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n루비는 다양한 개발과 소프트웨어 빌딩 측면에 참여하도록 허용하는 견고한 언어입니다. 다음은 그 개발 분야 중 몇 가지입니다 :\n\n웹 애플리케이션:\n\n강력한 프레임워크 루비 온 레일스(Ruby on Rails)를 통해 가능하며, 이는 가장 인기 있는 웹 애플리케이션 프레임워크 중 하나로, 빠른 속도와 개발의 용이함으로 알려져 있습니다. 에어비앤비, GitHub, 피버(Fiverr) 및 샵이(Shopify)와 같은 회사에서 사용됩니다.\n\n명령줄 도구:\n\n<div class=\"content-ad\"></div>\n\n루비는 명령줄 애플리케이션을 만드는 데 뛰어나요. 간결하고 가독성이 좋은 구문으로 유명해요. 스크립팅이나 자동화와 같은 작업에 좋은 선택이죠.\n\n**스크립팅:**\n\n강력한 스크립팅 언어이기도 한데요, 이는 작업 자동화, 데이터 처리, 시스템 관리를 위한 스크립트를 작성하는 데 좋다는 뜻이에요.\n\n**데스크톱 애플리케이션:**\n\n<div class=\"content-ad\"></div>\n\n그것은 Shoes 또는 GTK와 같은 GUI 라이브러리와 함께 사용되어 데스크톱 애플리케이션을 개발하는 데 사용할 수 있습니다.\n\n웹 서버:\n\nRuby는 웹 서버를 만들기 위한 기능을 내장하고 있습니다. WEBrick과 같은 라이브러리를 사용하거나 특정한 요구 사항에 맞는 사용자 정의 서버를 개발할 수 있습니다.\n\n게임 개발:\n\n<div class=\"content-ad\"></div>\n\n게임 개발에 대한 C++ 또는 Python과 같은 언어들만큼 흔하지는 않지만, Ruby는 Gosu와 같은 라이브러리와 함께 간단한 게임을 개발하는 데 사용될 수 있어요.\n\n데이터 분석 및 시각화:\n\n데이터 처리 및 시각화에 사용됩니다. NArray와 SciRuby와 같은 라이브러리는 과학 계산을 위한 도구를 제공합니다.\n\n프로토타입 및 빠른 개발:\n\n<div class=\"content-ad\"></div>\n\n루비의 간결한 구문과 강력한 기능을 통해 프로토타입을 만들거나 애플리케이션을 신속하게 개발하기에 훌륭합니다.\n\n네트워크 프로그래밍:\n네트워크 프로토콜을 위한 라이브러리를 제공하여 네트워크 클라이언트 및 서버를 생성하는 작업에 적합합니다.\n\n시스템 도구:\n\n<div class=\"content-ad\"></div>\n\n루비는 파일 처리, 프로세스 관리 및 시스템 모니터링과 같은 작업을 위한 시스템 도구를 만드는 데 사용할 수 있습니다.\n\n텍스트 처리 및 구문 분석:\n\n루비의 정규식(Regular Expression) 지원과 문자열 조작 능력을 통해 텍스트 처리 작업에 좋은 선택입니다.\n\n미들웨어 및 API:\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 루비는 시스템의 다른 부분을 연결하는 미들웨어 구성 요소 및 API를 개발하는 데 사용할 수 있어요!\n\n# 루비의 단점은!?\n\n지금까지 루비의 특성, 기능 및 장점에 대해 살펴보았으니, 이제 조금 더 얘기해 볼까요?\n\n성능:\n\n<div class=\"content-ad\"></div>\n\n낮은 수준의 언어인 C++이나 Go와 비교하면, Ruby는 실행 속도 측면에서 더 느릴 수 있습니다. 이는 성능이 중요한 응용 프로그램에서 고려할 사항일 수 있습니다.\n\n동시성과 병렬 처리:\n\nRuby의 표준 구현인 MRI(Mat)은 동시성과 병렬 처리를 처리하는데 제한이 있습니다. JRuby나 Rubinius와 같은 대안 구현이 있지만, 이 영역에서는 여전히 동시성을 염두에 두고 설계된 언어만큼 강력하지 않습니다.\n\n메모리 사용:\n\n<div class=\"content-ad\"></div>\n\n루비는 메모리를 많이 사용하는 경향이 있어서 엄격한 메모리 제약이나 대규모 응용프로그램에는 적합하지 않을 수 있습니다.\n\n![Ruby Image](/assets/img/2024-06-22-IsRubystillworthlearningin2024FullCoverageOfRubyProgrammingLanguageItsFrameworks_2.png)\n\nGlobal Interpreter Lock (GIL):\n\nMRI의 GIL은 멀티코어 프로세서의 완전한 활용능력을 제한할 수 있어서, 높은 동시성 응용프로그램에서 성능에 영향을 줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n복잡한 어플리케이션의 학습 곡선:\n\n루비는 우아하고 가독성이 좋은 문법으로 유명하지만, 복잡한 어플리케이션은 고급 루비 기능과 디자인 패턴에 대한 심도 있는 이해를 요구할 수 있어 학습 곡선이 가파를 수 있습니다.\n\n라이브러리와 도구의 이용 가능성:\n\n루비의 생태계는 견고하지만, 파이썬이나 자바스크립트와 같은 언어만큼 넓은 범위를 가지고 있지 않을 수 있습니다. 특히 특정 영역이나 전문 분야에서는 더욱 그렇습니다.\n\n<div class=\"content-ad\"></div>\n\n모바일 개발 지원이 제한됩니다:\n\n루비는 모바일 앱 개발에 일반적으로 사용되지 않기 때문에, 프로젝트에 모바일 애플리케이션이 포함되어 있다면, 다른 언어나 프레임워크를 고려해야 할 수도 있습니다.\n\n배포 및 호스팅:\n\n루비 애플리케이션은 여러 플랫폼에 배포될 수 있지만, 루비 환경을 설정하는 것은 더 표준화된 배포 절차를 갖춘 언어와 비교해 더 많은 구성이 요구될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n커뮤니티 및 지원:\n\n루비 커뮤니티는 활발하고 열정적이지만 다른 언어 커뮤니티보다 크기가 작을 수 있어서, 자원, 튜토리얼 또는 지원의 가용성에 영향을 줄 수 있습니다.\n\n특정 도메인에서의 인기 부족:\n\n과학 계산이나 시스템 프로그래밍과 같은 특정 전문 분야에서는 전문 라이브러리나 도구의 부족으로 루비가 최선의 선택이 되지 않을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 루비의 프레임워크 :\n\n루비 온 레일즈 (Rails):\n\n웹 애플리케이션 프레임워크로, Rails는 가장 잘 알려져 있고 널리 사용되는 웹 응용 프로그램 프레임워크 중 하나입니다. 설정보다는 관례를 강조합니다. 이는 개발자들이 웹 애플리케이션을 빠르게 구축할 수 있도록 기본 관례 세트를 제공하는 것을 의미합니다.\n\n![이미지](/assets/img/2024-06-22-IsRubystillworthlearningin2024FullCoverageOfRubyProgrammingLanguageItsFrameworks_3.png)\n\n<div class=\"content-ad\"></div>\n\n실할 것: \n\n실할 것은 웹 애플리케이션용 Micro-framework이며, 작고 미니멀한 웹 프레임워크로 작은 웹 애플리케이션과 API를 만드는 데 이상적입니다. 이는 응용 프로그램을 빠르게 시작할 수 있을 정도로 충분한 구조를 제공합니다.\n\n하나미 (이전 로터스):\n\n청결한 아키텍처와 객체 지향 설계를 장려하는 현대적인 풀 스택 웹 애플리케이션 프레임워크입니다. 개발자가 개별 구성 요소를 독립적으로 사용할 수 있도록 모듈식으로 설계되었습니다.\n\n<div class=\"content-ad\"></div>\n\n## 기타 Ruby 마이크로/프레임워크 :\n\nCamping:\n\n사용법: 웹 애플리케이션을 위한 마이크로 프레임워크.\n\n설명: 극도로 가벼운 웹 프레임워크로, 단순함과 최소주의에 초점을 맞추었습니다. 소규모 애플리케이션과 프로토타입에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\n파드리노:\n\n사용법: 웹 애플리케이션 프레임워크 (Sinatra 기반으로 구축됨).\n\n설명: 시나트라를 확장하여 추가 기능과 규칙을 제공하여 웹 애플리케이션을 구축하기 위한 보다 포괄적인 프레임워크를 제공합니다.\n\n큐바:\n\n<div class=\"content-ad\"></div>\n\n사용법: 웹 애플리케이션을 위한 마이크로 프레임워크.\n\n설명: \"하나의 일을 잘하라\"는 철학을 따르는 작고 유연한 프레임워크입니다. API 및 소규모 웹 애플리케이션을 구축하는 데 적합합니다.\n\nNancy:\n\n사용법: 웹 애플리케이션을 위한 마이크로 프레임워크.\n\n<div class=\"content-ad\"></div>\n\n설명: Nancy는 Sinatra에서 영감을 받은 경량 프레임워크로, 깨끗하고 직관적인 방식으로 작은 웹 애플리케이션 및 API를 구축하는 데 사용됩니다.\n\nGrape:\n\n사용법: API를 구축하기 위한 마이크로 프레임워크입니다.\n\n설명: 이 프레임워크는 RESTful API를 생성하기 위해 특별히 설계되었습니다. 강력한 API 엔드포인트를 구축할 때의 간소함과 사용 편의성으로 유명합니다.\n\n<div class=\"content-ad\"></div>\n\nRoda:\n\n사용 용도: 웹 애플리케이션 프레임워크.\n\n설명: 다재다능하고 성능을 중시하는 웹 프레임워크입니다. 개발자가 필요한 컴포넌트만 사용할 수 있도록 유연하게 설계되었습니다.\n\nTrailblazer:\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n**사용법:** 웹 애플리케이션을 구축하기 위한 아키텍처입니다.\n\n**설명:** 웹 애플리케이션의 구조에 대한 지침과 규칙을 제공하는 아키텍처적인 프레임워크입니다. 코드를 깔끔하고 모듈화되며 잘 구성된 형태로 유지하도록 권장합니다.\n\n# 루비는 높은 급여를 받는 기술 중 하나입니다 :\n\n2023년 스택 오버플로우 설문 조사 보고서에 따르면, 루비는 2023년에 가장 높은 급여를 받는 기술 중 5위에 랭크되었습니다. 최근 급등하고 있는 다른 기술들인 Go, TypeScript, C#, C++ 등을 능가하였습니다.\n\n<div class=\"content-ad\"></div>\n\n재정적으로 루비는 좋은 선택지이지만, 기술의 수요, 경쟁률, 그리고 기술 커뮤니티와 같은 다른 요인들을 고려하는 것이 중요하다. 이러한 요소들은 학습 여정을 더 쉽게 만들어 줄 수도 있고, 더 어렵게 만들 수도 있다.\n\n![이미지](/assets/img/2024-06-22-IsRubystillworthlearningin2024FullCoverageOfRubyProgrammingLanguageItsFrameworks_4.png)\n\n# 선택권이 있다면 다시 루비를 배우기 시작할까?\n\n루비와 함께한 여정은 짧았지만, 현재는 루비 온 레일즈 프레임워크를 공부 중이다. 흥미로운 것 같아서 즐기고 있지만, 마지막까지 계속할 프레임워크인지 확신할 수는 없다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 루비는 이해하기 쉽고 사용자 친화적인 언어입니다. 게다가 그 프레임워크 ROR은 지금까지 재미있고 즐겁게 작업할 수 있는 것 같습니다. 그러나 지금까지 마주한 문제는 프레임워크 자체, 루비 언어 또는 개발에서 사용되는 젬에 관한 다양한 주제에 대한 좋은 학습 자료의 부족입니다!\n\n그래서 결론적으로, 자원의 부족을 제외하고는 지금까지 언어나 프레임워크와 관련된 주요 문제에는 직면하지 않았기 때문에 다시 루비를 시도해 보겠다는 생각입니다.\n\n# 결론:\n\n총론적으로, 루비는 동적이고 다재다능한 프로그래밍 언어로, 단숨하고 유연하며 생산적이라는 것으로 유명합니다. 깔끔하고 우아한 문법부터 동적 코드 실행 및 메타프로그래밍 지원까지, 루비는 다양한 도메인의 개발자들에게 매력적인 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n거기에 더해 언어의 응용 프로그램이 다양한 스펙트럼에 걸쳐있는 점을 감안하면, Ruby로 웹 개발을 할 수 있는 강력한 Ruby on Rails 프레임워크부터 스크립팅, 명령줄 도구, 데스크톱 애플리케이션, 게임 개발, 데이터 분석 등이 있다고 알려드립니다. 하지만, 모든 기술과 마찬가지로 Ruby에도 도전에 직면할 수 있는 과제가 있음을 인정하는 것이 중요합니다.","ogImage":{"url":"/assets/img/2024-06-22-IsRubystillworthlearningin2024FullCoverageOfRubyProgrammingLanguageItsFrameworks_0.png"},"coverImage":"/assets/img/2024-06-22-IsRubystillworthlearningin2024FullCoverageOfRubyProgrammingLanguageItsFrameworks_0.png","tag":["Tech"],"readingTime":8},{"title":"Rails 성능 향상을 위한 7가지 옵션","description":"","date":"2024-06-22 22:21","slug":"2024-06-22-OptionsforbetterperformanceinRails","content":"\n\n# 소개: 동기부여\n\n소프트웨어 엔지니어링에서 효율성은 빠른 실행만이 아니라 리소스를 최대화하고 사용자 경험을 향상하는 해결책을 개발하는 것을 의미합니다. 우아함으로 유명한 Ruby에서는 메소드의 선택이 성능에 깊은 영향을 미칠 수 있습니다. 이 글은 일반적인 Ruby 및 Rails 메소드를 비교하여 메모리와 실행 시간 측면에서 어떤 것이 비교적 더 나은 성능을 제공하는지 살펴봅니다.\n\n![이미지](/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png)\n\n# exists? vs present? vs any?:\n\n<div class=\"content-ad\"></div>\n\nActiveRecord에서 present? 또는 any?과 같은 메서드를 사용하면 레코드를 메모리로 로드하여 일치하는 레코드가 있는지 확인할 수 있습니다. 이는 특히 대규모 데이터셋의 경우 비효율적일 수 있습니다.\n\n```js\nUser.where(email: 'example@gmail.com').present?\nUser.where(email: 'example@gmail.com').any?\n```\n\nexists?의 효율성: exists? 메서드는 데이터를로드하지 않고 레코드의 존재 여부 만을 확인하도록 최적화되어 있어 훨씬 더 빠릅니다.\n\n```js\nUser.where(email: 'example@gmail.com').exists?\n```\n\n<div class=\"content-ad\"></div>\n\n# update_all 대 update\n\n업데이트의 오버헤드: 개별 레코드에 대해 업데이트 메서드를 사용하면 여러 개의 데이터베이스 쿼리가 발생합니다.\n\n```js\nusers.each { |user| user.update(active: true) }\n```\n\nupdate_all의 효율성: update_all 메서드는 조건과 일치하는 모든 레코드를 업데이트하는 데 단일 쿼리를 수행하여 성능을 크게 향상시킵니다. 단, 여기에 주의해야 할 점은 해당 열이 인덱싱되어 있는지 확인하기 위해 신중히 WHERE 절을 사용하여 넓은 범위를 설정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nUser.where(active: false).update_all(active: true)\n```\n\n# includes vs joins vs preload\n\n## Eager Loading Associations\n\n- N+1 쿼리 문제: 조인을 사용하면 각 관련 레코드가 개별적으로 쿼리될 수 있는 N+1 쿼리 문제가 발생할 수 있습니다.\n- User.joins(:posts)는 여기서 posts 테이블을 로드하지 않습니다. 포스트를 가진 사용자만을로드합니다. 포스트는 .each를 수행하고 사용자의 포스트를 가져올 때 로드됩니다. 데이터베이스에 다시 쿼리를 실행하게 됩니다. 이것이 고전적인 n +1 쿼리 문제입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 비효율적\nUser.joins(:posts).each { |user| user.posts.each { |post| puts post.title } }\n```\n\ninclude의 효율성: include 메서드는 관련 레코드를 최소한의 쿼리로 가져오는 것을 목적으로한다. include는 데이터를 가져오기 위해 preload와 eager_load 두 가지 방법을 사용합니다. preload는 기본 테이블과 연관 테이블을 가져오기 위해 두 개의 쿼리가 시작됩니다. eager_load는 왼쪽 조인을 사용하여 기본 및 보조 테이블 모두를 하나의 쿼리로 가져옵니다.\n\n```js\n# 효율적\nUser.includes(:posts).each { |user| user.posts.each { |post| puts post.title } }\n```\n\n# count vs size vs length\n\n\n<div class=\"content-ad\"></div>\n\n## 레코드 개수 세기\n\n- 길이의 오버헤드: 길이를 사용하는 것은 모든 레코드를 메모리로 로드하기 때문에 비효율적일 수 있습니다.\n\n```js\n# 비효율적\nUser.all.length\n```\n\n카운트의 효율성: count 메서드는 SELECT COUNT(*) 쿼리를 수행하여 대규모 데이터셋에 효율적입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nUser.count\n```\n\n# find vs find_each:\n\n수천 개의 레코드를 처리할 때, find를 사용하면 처리를 시작하기 전에 모든 레코드를 로드해야하기 때문에 지나칠 정도로 비효율적입니다. 한 번에 10,000개의 레코드를 처리하는 경우 find를 사용할 때 약 500ms가 소요되고 많은 메모리가 사용되어 효율성이 떨어지는 것을 명확히 나타냅니다.\n\n```js\nUser.find(1..10000).each do |user|\n  # 일부 처리 작업\nend\n```\n\n<div class=\"content-ad\"></div>\n\n# find_each\n\n`find_each`은 내가 배고플 때 삼키는 만큼만 씹겠다고 하는 것과 비슷해요.\n\n```ruby\nUser.find_each(batch_size: 1000) do |user|\n  # 어떤 처리\nend\n```\n\n- 메모리 사용량: 감소\n\n<div class=\"content-ad\"></div>\n\n# select vs pluck\n\n# Using select\n\n이 문은 사용자 테이블에서 특정 열 (id, name, email)을 선택하고 ActiveRecord 객체로로드합니다. 그런 다음 each 블록이 이러한 객체를 반복 처리합니다. 특히 그 객체 각각에서 무언가를 확인하려는 경우에 유용합니다.\n\n```js\nUser.select(:id, :name, :email).each { |user| ... }\n```\n\n<div class=\"content-ad\"></div>\n\n# pluck 사용하기\n\n이 문은 데이터베이스에서 지정된 열만 직접 검색합니다. 반환값은 값 배열(또는 다수의 열을 pluck하는 경우 값 배열의 배열)이며, Active Record 객체가 아닙니다. 이는 메모리에 덜 영향을 미칩니다. 다만, 결과는 active record 테이블에 대해 아무것도 모르는 값 배열일 뿐입니다.\n\n```js\nUser.pluck(:id, :name, :email)\n```\n\n# where vs find_by:\n\n<div class=\"content-ad\"></div>\n\n## where를 사용하기\n\nwhere는 Rails에서 강력한 쿼리 메서드로, 여러 레코드를 반환할 수 있습니다. 여러 결과를 처리해야 하는 애플리케이션 로직에서 이상적입니다. where로 여러 레코드를 가져 올 때, where 절에 전달된 필드가 인덱싱되어 있지 않은 경우 전체 테이블 스캔을 수행합니다. 인덱스를 사용하면 검색 범위가 제한되어 index scan을 수행합니다. 일부 상황에서는 이 메서드를 사용해야 할 수도 있지만, 최종적으로 .first를 수행한다면 이상적인 방법이 아닙니다.\n\n```js\nUser.where(name: 'John').first\n```\n\nfind_by 사용하기\n\n<div class=\"content-ad\"></div>\n\n특정 기준과 일치하는 첫 번째 레코드만 필요할 때는 find_by를 사용하는 것이 더 빠릅니다. 일치하는 항목을 찾자마자 쿼리가 중단되어 시간과 자원을 절약합니다. 필터 열이 인덱싱되어 있는 경우 런타임이 더 향상됩니다.\n\n```js\nUser.find_by(name: 'John')\n```\n\n# delete_all vs destroy_all\n\n# delete_all\n\n<div class=\"content-ad\"></div>\n\ndelete_all은 데이터베이스에 직접 레코드를 로드하지 않고 빠른 삭제를 위한 메서드입니다. 빠르지만 콜백을 건너뜁니다. 빠르지만 결정적이며 콜백이 없습니다. 콜백을 실행하지 않으면 외래 키 참조가 있는 레코드에서 오류가 발생할 수 있습니다.\n\n```js\nUser.where(active: false).delete_all\n```\n\ndestroy_all\n\n콜백을 실행하면서 레코드를 삭제하려면 destroy_all이 필요합니다. 데이터 무결성을 유지하지만 성능에 비용이 발생합니다. 더 많은 시간이 소요되지만 체계적이며 필요한 콜백을 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nUser.where(active: false).destroy_all\n```\n\n이 글이 도움이 되었으면 좋겠어요.\n\n즐거운 코딩하세요!","ogImage":{"url":"/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png"},"coverImage":"/assets/img/2024-06-22-OptionsforbetterperformanceinRails_0.png","tag":["Tech"],"readingTime":5},{"title":"RootBeer 루트 감지 우회 방법  irsyadsec","description":"","date":"2024-06-22 22:20","slug":"2024-06-22-RootBeerRootDetectionBypassirsyadsec","content":"\n\n\n![RootBeer](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_0.png)\n\n몇 달 전에 어떤 애플리케이션의 침투 테스트를 진행했는데, 해당 애플리케이션이 루팅된 기기를 감지하기 위해 사용되는 RootBeer 라이브러리로 보호되어 있음을 발견했습니다. 이 기사에서는 RootBeer 라이브러리를 우회하는 방법을 보여드리겠습니다. 이때 사용할 것은 샘플 RootBeer 애플리케이션입니다.\n\n시작하기 전에, 이미 Frida Server 및 ADB 사용에 익숙하다고 가정합니다.\n\n# RootBeer 라이브러리 우회 단계별 안내\n\n\n<div class=\"content-ad\"></div>\n\n## 1. 환경 설정\n\n아래 도구들이 설치되어 있는지 확인해주세요:\n\n- ADB (Android Debug Bridge): 안드로이드 장치와 통신하는 데 사용됩니다.\n- Frida Server: 개발자, 역공학자 및 보안 연구자를 위한 동적 인스트루먼테이션 툴킷입니다.\n- 에뮬레이터: 이 경우, ldplayer를 사용하고 있습니다.\n\n## 2. 장치 준비\n\n<div class=\"content-ad\"></div>\n\nFrida 릴리스 페이지에서 기기 아키텍처에 맞는 적절한 Frida Server 이진 파일을 다운로드하세요.\n\n에뮬레이터에 연결하세요\n\n```js\nadb devices -l\n```\n\n<img src=\"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n```js\nadb root\n```\n\n<img src=\"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_2.png\" />\n\nADB를 사용하여 바이너리를 장치로 푸시합니다:\n\n```js\nadb push frida-server-16.0.10-android-x86_64 /data/local/tmp\n```\n\n<div class=\"content-ad\"></div>\n\n파일에 대한 권한을 주십시오.\n\n```js\nadb shell\ncd /data/local/tmp\nchmod +x frida-server-16.0.10-android-x86_64\n```\n\n![이미지](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_3.png)\n\n프리다 서버를 시작하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n./frida-server-16.0.10-android-x86_64 -D\n```\n\n![Root Detection Bypass](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_4.png)\n\n## 3. 루트 우회\n\n여기서는 GitHub에서 이미 사용 가능한 exploit 파일을 사용하여 가장 빠른 방법을 사용할 것입니다. Pich4ya의 exploit을 사용하고 있으며, 해당 사이트에서 다운로드할 수 있습니다. 그에게 큰 박수를 보내요👏👏👏👏\n\n<div class=\"content-ad\"></div>\n\n이미지 태그를 Markdown 형식으로 변경하세요.\n\n![이미지](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_5.png)\n\n파일을 다운로드한 후 저장한 폴더로 이동하여 명령 프롬프트를 엽니다.\n\n애플리케이션 패키지 이름을 찾습니다.\n\n```js\nfrida-ps -Uai\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_6.png\" />\n\nRootbeer 샘플 애플리케이션을 사용 중이기 때문에 패키지 이름은 com.scottyab.rootbeer.sample 입니다.\n\n그 다음에 다음 명령어를 실행하세요\n\n```js\nfrida -l root.js -U -f com.example.app --pause\n```\n\n<div class=\"content-ad\"></div>\n\n엔터를 누른 후 다시 타이핑하세요\n\n```js\n%이력서\n```\n\n![이미지](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_7.png)\n\n그리고 Voilaaaa 당신의 apk가 이미 우회됐어야 합니다\n\n<div class=\"content-ad\"></div>\n\n<표>를 마크다운 형식으로 변경해보세요.\n\n그리고 와! APK가 바이패스되어야 합니다.\n\n![이미지](/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_8.png)\n\n이렇게 도움이 되는 기사들을 더 보시고 싶으세요? 귀하의 지원이 저에게 가치 있는 콘텐츠를 만들 수 있게 합니다. 더 많은 무료 프롬프트를 만들기 위해 커피 한 잔 사주시겠어요? 귀하의 기부에 감사드립니다! ❤️❤️❤️","ogImage":{"url":"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_0.png"},"coverImage":"/assets/img/2024-06-22-RootBeerRootDetectionBypassirsyadsec_0.png","tag":["Tech"],"readingTime":3},{"title":"Spring Boot로 API 게이트웨이 구현하는 방법","description":"","date":"2024-06-22 22:18","slug":"2024-06-22-APIgatewayinSpringboot","content":"\n\n![API Gateway](/assets/img/2024-06-22-APIgatewayinSpringboot_0.png)\n\nAPI는 응용 프로그램 간에 일반적인 통신 방식입니다. 마이크로서비스 아키텍처의 경우 여러 서비스가 있으며 클라이언트는 이러한 서비스를 호출하기 위해 모든 하위 응용 프로그램의 호스트 이름을 알아야 합니다.\n\n이 통신을 간소화하기 위해 클라이언트와 서버 사이에 모든 API 요청을 관리하는 컴포넌트인 API 게이트웨이를 선호합니다. 또한 다음과 같은 다른 기능을 가질 수 있습니다:\n\n- 보안 — 인증, 권한 부여\r\n- 라우팅 — 라우팅, 요청/응답 조작, 회로 차단기\r\n- 관찰성 — 지표 집계, 로깅, 추적화\n\n<div class=\"content-ad\"></div>\n\nAPI 게이트웨이의 아키텍처적 이점:\n\n- 복잡성 감소\n- 정책의 중앙 집중화된 제어\n- 단순화된 문제 해결\n\nAPI 게이트웨이에는 Spring Cloud Gateway, Zuul API Gateway, APIGee, EAG (Enterprise API Gateway)와 같은 다양한 구현 유형이 있습니다.\n\n본 문서에서는 Spring Cloud API 게이트웨이를 구현하는 방법, 들어오는 요청 필터링, 요청/응답 조작, 인증 처리에 대해 살펴볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n아래에서 전체 에코시스템을 시각화할 수 있습니다:\n\n![에코시스템 다이어그램](/assets/img/2024-06-22-APIgatewayinSpringboot_1.png)\n\n위 다이어그램에서 총 5개의 서비스가 있습니다.\n\n- 서비스 레지스트리 — 각 프로젝트 내의 각 마이크로서비스 인스턴스의 가용 상태를 추적하는 응용 프로그램입니다.\n- API 게이트웨이 — 들어오는 요청을 수신하고 인증(활성화되어 있다면)을 수행하고 실제 마이크로서비스로 요청을 전달합니다. 응답을 받으면 소비자에게 반환합니다.\n- 인증 서버 — 인증을 처리하는 응용 프로그램입니다.\n- 첫 번째와 두 번째 마이크로서비스 — 서로 다른 기능을 갖는 두 개의 일반 내부 응용 프로그램입니다.\n\n<div class=\"content-ad\"></div>\n\n모든 애플리케이션은 시작 시 서비스 레지스트리에 등록됩니다. API 요청을 받으면 다음과 같은 단계가 발생합니다:\n\n- 소비자가 API 게이트웨이를 통해 애플리케이션을 호출합니다.\n- API 게이트웨이는 수신 URL이 인증이 필요한지 확인합니다. 필요하다면 인증 서버를 호출하여 유효성을 검사합니다.\n- 유효한 토큰이라면 필터를 적용한 후 해당 애플리케이션으로 요청을 전달합니다.\n- 유효하지 않은 토큰일 경우 소비자에게 권한이 없음을 응답합니다.\n- 내부 마이크로서비스에서 응답을 받으면 필터를 적용한 후 해당 소비자에게 반환합니다.\n\n게이트웨이에서의 필터는 로깅, 요청/응답 세부 사항 조작/사용자 정의와 같은 작업이 포함될 수 있습니다.\n\nService registry\n\n<div class=\"content-ad\"></div>\n\n유레카 서버로 작동하는 애플리케이션이에요. pom.xml에 다음 종속성이 있어야 해요.\n\n```js\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n그리고 메인 클래스에 `@EnableEurekaServer` 어노테이션이 있어야 해요.\n\n기본적으로 유레카 서버는 자신을 디스커버리에 등록하는데, 이를 비활성화하기 위해 application.properties에 아래 속성을 포함해야 해요.\n\n<div class=\"content-ad\"></div>\n\n```js\neureka.client.registerWithEureka = false\neureka.client.fetchRegistry = false\n```\n\n다른 애플리케이션을 Eureka 클라이언트로 만들려면 pom.xml에 아래 종속성을 포함하세요:\n\n```js\n  <dependency>\n   <groupId>org.springframework.cloud</groupId>\n   <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n  </dependency>\n```\n\n그리고, application.properties 파일에 Eureka 서버 URL을 제공해주세요:\n\n<div class=\"content-ad\"></div>\n\n\neureka.client.serviceUrl.defaultZone= <eureka-서버-가동-호스트-및-포트>\n\nAPI 게이트웨이:\n\nSpring Cloud API 게이트웨이에는 pom.xml에 아래 종속성이 필요합니다.\n\n```xml\n<dependencies>\n  <dependency>\n   <groupId>org.springframework.cloud</groupId>\n   <artifactId>spring-cloud-starter-gateway</artifactId>\n  </dependency>\n</dependencies>\n <dependencyManagement>\n  <dependencies>\n   <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-dependencies</artifactId>\n    <version>${spring-cloud.version}</version>\n    <type>pom</type>\n    <scope>import</scope>\n   </dependency>\n  </dependencies>\n </dependencyManagement>\n```\n\n<div class=\"content-ad\"></div>\n\napplication.yml 파일에서 모든 내부 마이크로서비스 이름, 경로 및 uri 세부 정보를 다음과 같이 제공해주세요:\n\n```js\nspring:\n  application:\n    name: gateway-service\n  cloud:\n    gateway:\n      routes:\n        - id: first\n          predicates:\n            - Path=/first/\n          uri: localhost:8081\n        - id: second\n          predicates:\n            - Path=/second/\n          uri: localhost:8082\n        - id: auth-server\n          predicates:\n            - Path=/login/\n          uri: localhost:8088\n```\n\n그리고 Gateway가 제공하는 모든 라우트를 제공하기 위해 RouteLocator 유형의 빈이 필요합니다. 요청/응답을 처리하려면 필요에 따라 필터를 포함할 수 있습니다:\n\n```js\n@Bean\npublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n    return builder.routes()\n            .route(\"first-microservice\", r -> r.path(\"/first\")\n                    .and().method(\"POST\")\n                    .and().readBody(Student.class, s -> true).filters(f -> f.filters(requestFilter, authFilter))\n                    .uri(\"http://localhost:8081\"))\n            .route(\"first-microservice\", r -> r.path(\"/first\")\n                    .and().method(\"GET\").filters(f-> f.filters(authFilter))\n                    .uri(\"http://localhost:8081\"))\n            .route(\"second-microservice\", r -> r.path(\"/second\")\n                    .and().method(\"POST\")\n                    .and().readBody(Company.class, s -> true).filters(f -> f.filters(requestFilter, authFilter))\n                    .uri(\"http://localhost:8082\"))\n            .route(\"second-microservice\", r -> r.path(\"/second\")\n                    .and().method(\"GET\").filters(f-> f.filters(authFilter))\n                    .uri(\"http://localhost:8082\"))\n            .route(\"auth-server\", r -> r.path(\"/login\")\n                    .uri(\"http://localhost:8088\"))\n            .build();\n}\n```\n\n<div class=\"content-ad\"></div>\n\n필터:\n\nA. 요청 본문을 로깅하려면:\n\n본문을 읽기 위해 ResourceLocator 빈에서 readBody()를 true로 설정해야 합니다. 이렇게 하면 ServerWebExchange 객체가 요청 본문을 \"cachedRequestBodyObject\" 속성에 캐시합니다.\n\n```js\npackage com.example.springcloudgatewayoverview.filter;\n\nimport com.example.springcloudgatewayoverview.model.Company;\nimport com.example.springcloudgatewayoverview.model.Student;\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n@Component\npublic class RequestFilter implements GatewayFilter {\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        Object body = exchange.getAttribute(\"cachedRequestBodyObject\");\n        System.out.println(\"in request filter\");\n        if(body instanceof Student) {\n            System.out.println(\"body:\" + (Student) body);\n        }\n        else if(body instanceof Company) {\n            System.out.println(\"body:\" + (Company) body);\n        }\n        return chain.filter(exchange);\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nB. 응답 본문을 로깅하려면:\n\n```js\npackage com.example.springcloudgatewayoverview.filter;\n\nimport com.example.springcloudgatewayoverview.model.Company;\nimport com.example.springcloudgatewayoverview.model.Student;\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.reactivestreams.Publisher;\nimport org.springframework.core.io.buffer.DataBuffer;\nimport org.springframework.core.io.buffer.DataBufferFactory;\nimport org.springframework.core.io.buffer.DefaultDataBuffer;\nimport org.springframework.core.io.buffer.DefaultDataBufferFactory;\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.http.server.reactive.ServerHttpResponse;\nimport org.springframework.http.server.reactive.ServerHttpResponseDecorator;\nimport org.springframework.web.server.ServerWebExchange;\nimport org.springframework.web.server.WebFilter;\nimport org.springframework.web.server.WebFilterChain;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\n\npublic class PostGlobalFilter implements WebFilter {\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {\n        String path = exchange.getRequest().getPath().toString();\n        ServerHttpResponse response = exchange.getResponse();\n        ServerHttpRequest request = exchange.getRequest();\n        DataBufferFactory dataBufferFactory = response.bufferFactory();\n        ServerHttpResponseDecorator decoratedResponse = getDecoratedResponse(path, response, request, dataBufferFactory);\n        return chain.filter(exchange.mutate().response(decoratedResponse).build());\n    }\n\n    private ServerHttpResponseDecorator getDecoratedResponse(String path, ServerHttpResponse response, ServerHttpRequest request, DataBufferFactory dataBufferFactory) {\n        return new ServerHttpResponseDecorator(response) {\n\n            @Override\n            public Mono<Void> writeWith(final Publisher<? extends DataBuffer> body) {\n\n                if (body instanceof Flux) {\n\n                    Flux<? extends DataBuffer> fluxBody = (Flux<? extends DataBuffer>) body;\n\n                    return super.writeWith(fluxBody.buffer().map(dataBuffers -> {\n\n                        DefaultDataBuffer joinedBuffers = new DefaultDataBufferFactory().join(dataBuffers);\n                        byte[] content = new byte[joinedBuffers.readableByteCount()];\n                        joinedBuffers.read(content);\n                        String responseBody = new String(content, StandardCharsets.UTF_8);//응답 수정 및 수정된 응답 반환\n                        System.out.println(\"requestId: \"+request.getId()+\", method: \"+request.getMethodValue()+\", req url: \"+request.getURI()+\", response body :\"+ responseBody);\n                        try {\n                            if(request.getURI().getPath().equals(\"/first\") && request.getMethodValue().equals(\"GET\")) {\n                                List<Student> student = new ObjectMapper().readValue(responseBody, List.class);\n                                System.out.println(\"student:\" + student);\n                            }\n                            else if(request.getURI().getPath().equals(\"/second\") && request.getMethodValue().equals(\"GET\")) {\n                                List<Company> companies = new ObjectMapper().readValue(responseBody, List.class);\n                                System.out.println(\"companies:\" + companies);\n                            }\n                        } catch (JsonProcessingException e) {\n                            throw new RuntimeException(e);\n                        }\n                        return dataBufferFactory.wrap(responseBody.getBytes());\n                    })).onErrorResume(err -> {\n\n                        System.out.println(\"error while decorating Response: {}\"+err.getMessage());\n                        return Mono.empty();\n                    });\n\n                }\n                return super.writeWith(body);\n            }\n        };\n    }\n\n}\n```\n\nC. API 호출 전에 인증하기:\n\n다음과 같이 인증 필터를 생성하십시오:\n\n<div class=\"content-ad\"></div>\n\n```java\npackage com.example.springcloudgatewayoverview.filter;\n\nimport com.example.springcloudgatewayoverview.util.AuthUtil;\nimport com.example.springcloudgatewayoverview.util.JWTUtil;\nimport com.example.springcloudgatewayoverview.validator.RouteValidator;\nimport io.jsonwebtoken.Claims;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.cloud.gateway.filter.GatewayFilter;\nimport org.springframework.cloud.gateway.filter.GatewayFilterChain;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.http.server.reactive.ServerHttpResponse;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.server.ServerWebExchange;\nimport reactor.core.publisher.Mono;\n\n@Component\n@RefreshScope\npublic class AuthFilter implements GatewayFilter {\n\n    @Autowired\n    RouteValidator routeValidator;\n\n    @Autowired\n    private JWTUtil jwtUtil;\n\n    @Autowired\n    private AuthUtil authUtil;\n\n    @Value(\"${authentication.enabled}\")\n    private boolean authEnabled;\n\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        if(!authEnabled) {\n            System.out.println(\"Authentication is disabled. To enable it, make \\\"authentication.enabled\\\" property as true\");\n            return chain.filter(exchange);\n        }\n        String token =\"\";\n        ServerHttpRequest request = exchange.getRequest();\n\n        if(routeValidator.isSecured.test(request)) {\n            System.out.println(\"validating authentication token\");\n            if(this.isCredsMissing(request)) {\n                System.out.println(\"in error\");\n                return this.onError(exchange,\"Credentials missing\",HttpStatus.UNAUTHORIZED);\n            }\n            if (request.getHeaders().containsKey(\"userName\") && request.getHeaders().containsKey(\"role\")) {\n                token = authUtil.getToken(request.getHeaders().get(\"userName\").toString(), request.getHeaders().get(\"role\").toString());\n            }\n            else {\n                token = request.getHeaders().get(\"Authorization\").toString().split(\" \")[1];\n            }\n\n            if(jwtUtil.isInvalid(token)) {\n                return this.onError(exchange,\"Auth header invalid\",HttpStatus.UNAUTHORIZED);\n            }\n            else {\n                System.out.println(\"Authentication is successful\");\n            }\n\n            this.populateRequestWithHeaders(exchange,token);\n        }\n        return chain.filter(exchange);\n    }\n\n    private Mono<Void> onError(ServerWebExchange exchange, String err, HttpStatus httpStatus) {\n        ServerHttpResponse response = exchange.getResponse();\n        response.setStatusCode(httpStatus);\n        return response.setComplete();\n    }\n\n    private String getAuthHeader(ServerHttpRequest request) {\n        return  request.getHeaders().getOrEmpty(\"Authorization\").get(0);\n    }\n\n\n    private boolean isCredsMissing(ServerHttpRequest request) {\n        return !(request.getHeaders().containsKey(\"userName\") && request.getHeaders().containsKey(\"role\")) && !request.getHeaders().containsKey(\"Authorization\");\n    }\n\n    private void populateRequestWithHeaders(ServerWebExchange exchange, String token) {\n        Claims claims = jwtUtil.getALlClaims(token);\n        exchange.getRequest()\n                .mutate()\n                .header(\"id\",String.valueOf(claims.get(\"id\")))\n                .header(\"role\", String.valueOf(claims.get(\"role\")))\n                .build();\n    }\n}\n```\n\nEndpoints 중 일부는 토큰 없이 호출을 허용해야 합니다. (예: 로그인 URL, 헬스 체크 URL 등). 이러한 엔드포인트들을 아래 목록에 추가할 것입니다:\n\n```java\npackage com.example.springcloudgatewayoverview.validator;\n\nimport org.springframework.http.server.reactive.ServerHttpRequest;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\nimport java.util.function.Predicate;\n\n@Component\npublic class RouteValidator {\n    public static final List<String> unprotectedURLs = List.of(\"/login\");\n\n    public Predicate<ServerHttpRequest> isSecured = request -> unprotectedURLs.stream().noneMatch(uri -> request.getURI().getPath().contains(uri));\n}\n```\n\nJWTUtil:\n```java\n```\n\n<div class=\"content-ad\"></div>\n\n```java\npackage com.example.springcloudgatewayoverview.util;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Date;\n\n@Component\npublic class JWTUtil {\n\n    @Value(\"${jwt.secret}\")\n    private String secret;\n\n    public Claims getAllClaims(String token) {\n        return Jwts.parserBuilder().setSigningKey(secret).build().parseClaimsJws(token).getBody();\n    }\n\n    private boolean isTokenExpired(String token) {\n        return this.getAllClaims(token).getExpiration().before(new Date());\n    }\n\n    public boolean isInvalid(String token) {\n        return this.isTokenExpired(token);\n    }\n\n}\n```\n\nAuthentication server:\n\n이 서비스는 내부 마이크로서비스에 액세스하기 위한 토큰을 제공합니다.\n\n실행:\n\n\n<div class=\"content-ad\"></div>\n\nOnce all applications are running, you can access the service registry by entering http://localhost:8761 in your browser. Here, you can find information about all the currently running services:\n\n![Service Registry](/assets/img/2024-06-22-APIgatewayinSpringboot_2.png)\n\nThe API Gateway is running on localhost at port 8080. You can access the endpoints of the First or Second microservice from http://localhost:8080.\n\n![API Gateway Endpoints](/assets/img/2024-06-22-APIgatewayinSpringboot_3.png)\n\n<div class=\"content-ad\"></div>\n\nAPIGateway 콘솔의 요청/응답 로그:\n\n![2024-06-22-APIgatewayinSpringboot_4](/assets/img/2024-06-22-APIgatewayinSpringboot_4.png)\n\n인증이 포함된 샘플 요청:\n\n![2024-06-22-APIgatewayinSpringboot_5](/assets/img/2024-06-22-APIgatewayinSpringboot_5.png)\n\n<div class=\"content-ad\"></div>\n\n서비스의 모든 코드 기반은 여기에서 사용 가능합니다.\n\n읽어 주셔서 감사합니다. 즐거운 탐험하세요!!!","ogImage":{"url":"/assets/img/2024-06-22-APIgatewayinSpringboot_0.png"},"coverImage":"/assets/img/2024-06-22-APIgatewayinSpringboot_0.png","tag":["Tech"],"readingTime":17},{"title":"Spring AOP 이해하기 요청과 응답을 로깅하는 애너테이션 만드는 방법","description":"","date":"2024-06-22 22:17","slug":"2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses","content":"\n\n자바 개발자들의 강력한 무기 중 하나는 Aspect-Oriented Programming (AOP)입니다. Spring Boot와 원활하게 통합되면 게임 체인저가 될 수 있습니다. 이 글에서는 Spring Boot AOP를 이해하기 위해 Annotation을 구축하여 재사용할 수 있는데, 어떤 요청 매핑에도 로깅을 위해 요청, 응답 및 상태를 기록할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses_0.png)\n\n# AOP란 무엇인가요?\n\nAspect-Oriented Programming (AOP)은 개발자가 로깅, 오류 처리 및 보안과 같은 교차 관심 사항을 비즈니스 로직과 분리하여 모듈화할 수 있는 프로그래밍 패러다임입니다. AOP에서 이러한 관심 사항인 Aspect는 독립적으로 정의되고 특정 지점에서 코드에 엮이며 코드 중복을 줄이고 유지보수성을 향상시킵니다. 이 접근 방식은 코드 조직화를 개선하고 소프트웨어 개발에서 관심의 분리를 장려합니다.\n\n<div class=\"content-ad\"></div>\n\n# AOP 개념\n\n구현에 들어가기 전에 알아야 할 몇 가지 개념이 있습니다.\n\n## 측면(Aspect)\n\n로그인 또는 보안과 같은 교차 관심사를 캡슐화하는 모듈입니다. 측면은 코드에서 어떻게 하는지와 어디에서 하는지를 정의합니다. Spring AOP에서는 @Aspect 주석이 달린 일반 클래스를 사용하여 측면을 구현합니다.\n\n<div class=\"content-ad\"></div>\n\n## 조인 포인트\n\n프로그램 실행 중 발생하는 특정 지점을 말합니다. 메소드 호출, 객체 인스턴스화 또는 예외 처리와 같은 것을 포함합니다. Aspect는 특정 조인 포인트를 대상으로 행동을 적용하기 위해 지정합니다. Spring AOP에서 조인 포인트는 항상 메소드 실행을 나타냅니다.\n\n## 어드바이스\n\n특정 조인 포인트에서 Aspect가 취하는 조치를 말합니다. \"before\", \"after\" 등과 같은 다양한 유형의 어드바이스가 있습니다. Spring AOP에서 어드바이스는 조인 포인트 주변의 인터셉터 체인을 유지하며 작동합니다.\n\n<div class=\"content-ad\"></div>\n\n다양한 종류의 조언이 있습니다:\n\n- 이전 조언 (Before Advice): 조인 포인트 이전에 실행되며, 주요 로직을 실행하기 전에 동작이나 유효성 검사를 수행할 수 있는 기회를 제공합니다.\n- 반환 후 조언 (After returning Advice): 조인 포인트의 정상 실행이 완료된 후에 실행됩니다. 메서드가 성공적으로 완료될 때 수행할 동작에 유용합니다.\n- 던지기 후 조언 (After throwing Advice): 조인 포인트에서 예외가 발생하면 실행됩니다. 예외 처리 또는 로깅에 사용됩니다.\n- 이후 조언 (After Advice): 조인 포인트의 결과(정상 또는 예외)와 관계없이 실행됩니다. 정리 또는 마무리 작업에 사용됩니다.\n- 주변 조언 (Around Advice): 모든 조언 중에서 가장 강력한 기능을 가지고 있습니다. 조인 포인트를 포함하여 조인 포인트의 실행에 대한 완전한 제어를 제공합니다. 메서드의 동작을 수정하거나 완전히 대체할 수 있습니다.\n\n## 포인트컷\n\n조언이 적용해야 하는 조인 포인트를 나타내는 집합입니다. 조언은 포인트컷 표현식과 연관되어 있으며, 포인트컷과 일치하는 모든 조인 포인트에서 실행됩니다. 스프링은 기본적으로 AspectJ 포인트컷 표현식 언어를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n## 소개\n\n기존 클래스에 새로운 방법이나 필드를 도입하여, 측면(Aspect)이 클래스의 소스 코드를 수정하지 않고 기능을 추가할 수 있도록 합니다. Spring AOP를 사용하면 어떤 조언 대상 객체에 대해 새로운 인터페이스를 추가할 수 있습니다.\n\n## 엮기(Weaving)\n\n측면(Aspect)을 주요 응용 프로그램 코드와 통합하는 과정을 말합니다. 컴파일 시간, 로드 시간 또는 실행 시간에 발생할 수 있습니다. Spring AOP는 실행 시간에 엮기(Weaving)를 수행합니다.\n\n<div class=\"content-ad\"></div>\n\n## 대상 객체\n\n애스펙트에 의해 조언을 받는 객체입니다. Spring AOP는 런타임 위빙만 지원하기 때문에 이 객체는 항상 프록시된 객체가 될 것입니다.\n\n## AOP 프록시\n\nAspect contracts를 구현하기 위해 AOP 프레임워크에 의해 생성된 객체입니다. Spring에서 AOP 프록시는 JDK 다이내믹 프록시 또는 CGLIB 프록시가 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 사용자 정의 어노테이션\n\n이 글에서는 사용자 정의 어노테이션에 대해 이해해야 합니다. 기본 사항을 알아보겠습니다.\n\nSpring Boot에서 사용자 정의 어노테이션을 사용하면 코드에 자체 마커나 메타데이터를 정의할 수 있습니다. 주요 개념을 살펴보겠습니다.\n\n- 어노테이션 선언: 어노테이션을 선언하려면 @interface를 사용합니다.\n- 대상(Target): 어노테이션이 사용될 위치를 지정합니다. 예: @Target(ElementType.METHOD)은 메서드에만 사용할 수 있도록 제한합니다. 클래스에 사용하려면 TYPE을, 필드에 사용하려면 FIELD를 사용할 수 있습니다.\n- 보존(Retention): 어노테이션 정보가 유지되는 시점을 정의합니다. 예: @Retention(RetentionPolicy.RUNTIME)은 실행 시점에 사용 가능하게 합니다.\n- 속성(Attributes): 어노테이션 내에서 속성을 정의합니다. 예: String value() default “기본 값”;\n\n<div class=\"content-ad\"></div>\n\n# 구현\n\n이제 구현을 진행해 봅시다.\n\n## 의존성\n\n먼저, spring AOP를 종속성으로 추가하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n<!-- Spring AOP -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n</dependency>\n```\n\n## 사용자 정의 어노테이션\n\n그런 다음 사용자 정의 어노테이션을 생성할 것입니다.\n\n```js\npackage com.example.demo.annotations;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * @author Pratiyush Prakash\n * \n * 이 어노테이션은 요청과 응답을 로깅하는 데 사용됩니다.\n * \n * METHOD에만 적용되며,\n * 런타임에서 사용 가능합니다.\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface LogRequestResponse {\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 양상\n\n이제 Aspect를 생성할 수 있습니다. 여기서는 Annotation에 대한 Pointcut을 생성하고 메서드의 요청과 응답을 로깅하기 위한 어드바이스를 생성할 것입니다.\n\n```js\npackage com.example.demo.aspects;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.AfterReturning;\nimport org.aspectj.lang.annotation.Aspect;\nimportorg.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.stereotype.Component;\n\n/**\n * @author Pratiyush Prakash\n * \n * 이 Aspect는 LogRequestResponse 어노테이션을 적용한 모든 요청과 응답을 로깅하는 모듈입니다.\n */\n@Aspect\n@Component\npublic class RequestResponseLoggingAspect {\n    \n    // LogRequestResponse 어노테이션에 대한 Pointcut 정의\n    @Pointcut(\"@annotation(com.example.demo.annotations.LogRequestResponse)\")\n    public void logAnnotationPointcut() {\n    }\n\n    // Before 어드바이스\n    @Before(\"logAnnotationPointcut()\")\n    public void logBefore(JoinPoint joinPoint) {\n        System.out.println(\"Before \" + joinPoint.getSignature().getName());\n    }\n\n\n    // 일반적인 After 어드바이스\n    @AfterReturning(pointcut = \"logAnnotationPointcut()\", returning = \"result\")\n    public void logAfterReturning(JoinPoint joinPoint, Object result) {\n        // 응답을 로깅합니다.\n        System.out.println(\"After \" + joinPoint.getSignature().getName() +  \"메서드가 반환한 값 \" + result);\n\n        // 응답 상태를 로깅합니다.\n        if (result instanceof ResponseEntity) {\n            ResponseEntity<Object> response = (ResponseEntity<Object>) result;\n            System.out.println(\"응답 상태: \" + response.getStatusCode());\n        }\n    }\n\n}\n```\n\n## 어플리케이션\n\n<div class=\"content-ad\"></div>\n\n이제 테스트하고 싶은 엔드포인트에 주석을 추가할 수 있습니다.\n\n```js\npackage com.example.demo.web;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport com.example.demo.annotations.LogRequestResponse;\n\n/**\n * @Author Pratiyush Prakash\n * \n * 여기에 모든 엔드포인트가 위치합니다\n */\n@RestController\n@RequestMapping(\"/api/v1\")\npublic class DemoController {\n\n    /**\n     * 이것은 샘플 보안된 API 호출입니다\n     * @return 문자열\n     */\n    @LogRequestResponse\n    @GetMapping(value = \"/secured/hello-world\")\n    public String securedCall() {\n        return \"hello world secured!!\";\n    }\n\n    /**\n     * 이것은 샘플 비보안 API 호출입니다\n     * @return 문자열\n     */\n    @LogRequestResponse\n    @GetMapping(value = \"/hello-world\")\n    public String unsecuredCall() {\n        return \"hello world!!\";\n    }\n\n    /**\n     * 이것은 객체를 반환하는 샘플 GET 호출입니다\n     * @return 이름과 나이의 맵\n     */\n    @LogRequestResponse\n    @GetMapping(value = \"/demo-object\")\n    public Map<String, Integer> demoObjectMap() {\n        Map<String, Integer> map = new HashMap<>();\n        map.put(\"Pratiyush\", 29);\n        return map;\n    }\n\n    /**\n     * 다른 응답 상태를 테스트하기 위한 샘플 GET 호출입니다\n     * @return ResponseEntity\n     */\n    @LogRequestResponse\n    @GetMapping(value = \"/demo-response-entity\")\n    public ResponseEntity<String> demoResponseEntity(@RequestParam Integer code) {\n        switch (code) {\n            case 200:\n                return new ResponseEntity<String>(\"Hello world!!\", HttpStatus.ACCEPTED);\n            case 400:\n                return new ResponseEntity<>(HttpStatus.NOT_FOUND);\n            default:\n                return new ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\n        }\n    }\n    \n}\n```\n\n여기까지 코드 작업이 완료되었습니다.\n\n## 데모\n\n<div class=\"content-ad\"></div>\n\n이제 우리의 구현이 제대로 작동하는지 확인할 수 있습니다. 애플리케이션을 빌드하고 실행할 수 있습니다. Swagger UI를 열어 엔드포인트를 호출할 수도 있습니다. 그리고 로그에서 요청과 응답을 확인할 수 있는지 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses_1.png)\n\n요약하자면, Aspect는 프로젝트를 모듈화하고 로깅, 보안, 오류 처리와 같은 공통 관심을 분리해야 하는 경우에 매우 유용합니다. 이 글에서는 로깅 사용 사례를 다뤘습니다. 여러분의 프로젝트에서 이와 같은 시나리오가 있는 경우 한번 시도해 보세요.\n\n# 참고문헌\n\n<div class=\"content-ad\"></div>\n\n- [Spring Framework AOP](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/aop.html)\n- [Demystifying Proxy in Spring](https://medium.com/dev-genius/demystifying-proxy-in-spring-3ab536046b11)\n- You can access my code [here](https://github.com/iepratiyush/spring-demo)","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingSpringAOPCreatingAnnotationforLoggingRequestsandResponses_0.png","tag":["Tech"],"readingTime":9}],"page":"12","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}