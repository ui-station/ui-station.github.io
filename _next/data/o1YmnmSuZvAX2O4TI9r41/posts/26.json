{"pageProps":{"posts":[{"title":"iOS 앱을 위한 현대적 아키텍처","description":"","date":"2024-06-19 11:02","slug":"2024-06-19-ModernArchitectureforiOSapps","content":"\n\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_0.png)\n\n많은 iOS 개발 측면 중 앱의 아키텍처는 가장 중요하고 흥미로운 주제 중 하나입니다. 아키텍처는 규칙 세트가 아닌 시스템의 속성으로, 앱이 작동하는 방식 뿐만 아니라 성장과 평가 방식을 정의합니다. 이는 앱의 모든 부분에 영향을 미치며 개발 프로세스와 최종 제품의 품질에도 직접적인 영향을 미칩니다.\n\n거대한 코드베이스와 강하게 결합된 구성 요소가 보편적이던 시절은 지나갔습니다. 이제 모바일 우선 접근 방식이 이긴 상황이고, 오늘날 모바일 응용 프로그램은 진지하고 매우 경쟁력있는 비즈니스입니다. 결과적으로 고객의 높은 요구 사항을 충족하기 위해 더 모듈화되고 테스트 가능하며 견고한 코드베이스를 만들기 위해 정교한 아키텍처 패턴을 활용합니다.\n\n본문에서는 좋은 아키텍처가 어떻게 보여야 하는지와 그 이유, 도래하는 혜택 및 최대한 활용하기 위해 현대 기술 스택을 활용하여 어떻게 구축해야 하는지에 대한 경험을 공유하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 고지사항\n\n- 제가 언급한 방법이 유일한 올바른 방법이라고 주장하지는 않습니다. 소프트웨어 개발에서는 문제를 해결할 수 있는 다양한 방법이 일반적으로 있으므로, 다른 해결책이 잘 작동하고 만족스러운 경우에는 괜찮습니다.\n- 이 방법은 팀 또는 여러 팀의 개발자들이 개발한 상대적으로 큰 앱에 가장 적합합니다.\n- 이 글은 iOS 개발을 중점적으로 다루지만, 처음 봤을 때 안드로이드 개발에도 큰 노력 없이 도입될 수 있을 것으로 보입니다.\n\n# 좋은 아키텍처란 무엇인가요?\n\n실제 앱에 적합한 좋은 아키텍처를 정의해 봅시다. 이에 대해 약간 다른 의견이 많이 있지만, 일반적으로 다음 요구 사항에 초점을 맞춥니다:\n\n<div class=\"content-ad\"></div>\n\n- 쉽게 읽고 이해하기 쉽습니다.\n- 재사용, 확장 및 확장하기 쉽습니다.\n- 테스트하고 테스트가 저렴합니다.\n- 쉽게 디버그하고 수정하며 유지 관리하기 쉽습니다.\n- 새로운 개발자를 온보딩하기 쉽습니다.\n\n많이들 '쉽다'라고 하는데, 해결책은 최소한의 부가 코드를 가지고 끝내야 하며, 엔지니어링은 너무 많이 하지 않아야 쉽다고 할 수 있습니다. 동시에 개발 프로세스에서 매우 효율적이어야 합니다. 또 한 가지 중요한 특징을 더할 거면, 그것은 놈, 구조는 부적절하게 사용되는 것에 저항할 정도로 충분히 강력해야 합니다. 예를 들어, MVC는 잘못 사용하기 매우 쉬우며, 그것이 바로 우리가 \"Massive ViewController\"라고 하는 반패턴을 갖게 된 이유입니다 (대신에 \"Model-View-Controller\"). 좋은 아키텍처는 스스로를 보호하고 기반이 되는 원칙을 지켜야 합니다.\n\n반면에, 아키텍처는 다소 융통성 있으면서 지나치게 과도하지 않아야 합니다. 소프트웨어 개발은 순수한 수학 추상화가 아니며, 앱은 실제 사람들이 개발합니다 (실수를 할 수 있음), 그리고 실제 사람들이 (아키텍처에 대해 전혀 신경쓰지 않을 수도 있는) 실제 하드웨어에서 앱을 사용합니다 (이에는 제한이 있을 수 있음), 종종 3rd party 프레임워크를 사용하며 (이것들은 때로는 우리의 제어 하에 있지 않을 수도 있음). 앱을 외부 환경과 조건에 쉽게 적응시키는 것이 상대적으로 쉬워야 합니다. 다시 말해, 좋은 아키텍처는 가능한 한 간단해야 하고, 필요한 만큼 복잡해야 합니다.\n\n# 아키텍처에 대해 더 자세히 알아보기\n\n<div class=\"content-ad\"></div>\n\n아키텍처는 일종의 타협안이며, 결과가 따라온다는 것을 명심해야 해요. MVC, MVP, MVVM과 같은 이러한 아키텍처 패턴들은 매우 간단하고 짧은 학습 후에 쉽게 사용을 시작할 수 있어요. 하지만 이러한 간단함의 반대편은 이러한 패턴들이 보통 코드베이스의 분리 방법을 설명하기 때문에 실제로 해석과 구현이 상당히 다르다는 사실이에요. 결과적으로 각 팀은 레이어 사이의 분리를 유지하기 위해 자체 규칙을 가지고 있으며, 이러한 규칙은 일반적으로 쉽게(실제로는 아마도) 어기기 쉽다는 것이죠. 이러한 패턴의 전형적인 문제는 거대한 비즈니스 로직 레이어인데, 이는 레이어 간의 명확한 경계가 없으면 의존성 주입 없이도 서비스 레이어 및 다른 엔티티를 직접 사용하는 경향이 있어서 제대로 테스트하기 어렵다는 점이에요.\n\nRIBs와 VIPER와 같은 고급 아키텍처 패턴도 있지만, 둘 다 기술적으로 낡았으며 UIKit과 함께 작동하도록 개발되었으므로 SwiftUI와는 잘 작동하지 않아요. 게다가 VIPER는 혜택이 그리 크지 않으면서도 많은 보일러플레이트 코드를 가지고 있어요. RIBs는 여전히 UIKit만을 사용하고 SwiftUI를 사용할 계획이 없다면 좋은 아키텍처일 수 있지만, 실제로는 어렵다고 보여요 — SwiftUI로만 구현할 수 있는 일부 새로운 iOS 기능들이 있을 수 있다는 점이죠.\n\n구성 가능 아키텍처(TCA)는 아마 SwiftUI와 함께 작동할 수 있도록 구상된 유일한 아키텍처일 거예요. 주요 단점은 애플리케이션 전체에 하나의 Scope를 사용하는 것이 권장된다는 것이어서, 앱의 한 부분을 다른 부분과 분리하기 어려운 점이 있어요. 이는 앱이 MVP 이상이거나 여러 개발자 팀에 의해 개발되는 경우에 중요하답니다. 또한, 몇몇 곳에서 TCA의 구현은 상당히 범위가 크게 보일 수 있고(많은 사용자 정의 내장 도구)과 오버 엔지니어링(보일러플레이트 코드)에 대한 우려도 있어요. 또한, 많은 사람들이 가파른 학습 곡선과 성능 문제에 대해 언급하고 있어요. 그렇지만 SwiftUI를 사용해야 하고 어떤 종류의 아키텍처가 필요한지 감이 오지 않는다면, TCA가 좋은 시작점이 될 수 있어요.\n\n## 현대 소프트웨어는 팀워크입니다.\n\n<div class=\"content-ad\"></div>\n\n현대의 대부분의 경쟁력 있는 모바일 앱은 단독으로 개발되는 것이 아니라, 경우에 따라 수십 개의 팀에 의해 개발됩니다. 물론 시장에는 많은 독립 개발자들이 있지만, 대부분의 경우 비즈니스 앱과는 조금 다릅니다.\n\n팀워크는 앱이 병렬 개발을 허용하고 쉽게 수행해야 한다는 것을 뜻합니다. 또한, 각 앱의 부분은 많은 개발자에 의해 개발되어야 합니다. 이는 아키텍처가 코드의 각 특정 부분이 어디에 위치해야 하며 어떻게 구현되어야 하는지에 대한 엄격한 규칙이 있어야 한다는 것을 의미합니다. 또한, 아키텍처는 일관성 있는 높은 수준을 가져야 합니다. 그렇지 않으면 한 개발자가 다른 개발자의 작업을 이어 나가지 못할 것입니다. 이 모든 것을 고려하면 아키텍처는 탁월한 수준의 테스트 가능성을 제공해야 합니다. 집중적인 개발의 경우, 아키텍처는 인식 및 이해 부담을 증가시키지 않으면서 수평적 확장성의 좋은 수준을 제공해야 합니다.\n\n## 두 수준의 아키텍처\n\n보통 사람들은 이에 대해 많이 이야기하지 않지만, 잘 구조화된 모듈화 수준이 높은 앱은 두 수준의 아키텍처를 갖고 있습니다. 첫 번째 수준은 건물 블록과 같은 것으로, MVC, MVP, MVVM 등과 같은 하나의 특정 화면 또는 해당 일부 (복잡한 화면의 경우)를 구축하는 책임이 있는 아키텍처입니다. 두 번째 수준은 모든 건물 블록을 조합하고 이를 위해 모든 필요한 종속성을 제공하며 앱의 다양한 부분 간의 라우팅을 포함하는 아키텍처를 담당합니다.\n\n<div class=\"content-ad\"></div>\n\n중간 규모 이상의 모바일 앱을 위해서는 좋은 앱 아키텍처에 대한 위에서 언급한 모든 요구 사항을 충족시키기 위해 두 가지 아키텍처가 필요합니다. 예를 들어, 이 두 번째 아키텍처 없이는 앱의 각 부분에 대해 명확하고 강력한 경계를 설정하는 것이 불가능하며, 가로 확장성, 테스트 가능성, 디버깅 및 유지 관리와 같은 것들을 달성하는 것이 극도로 어려울 것입니다. 이 역할을 수행하기에 가장 적합한 후보 중 하나는 \"Composition Root\" 패턴입니다. 이에 대해 이 글에서 나중에 자세히 설명하겠습니다.\n\n# Elm 아키텍처\n\nElm 아키텍처는 웹 개발에서 잘 알려져 있지만, 모바일 개발을 포함한 다른 영역에 대해 거의 고려되지 않습니다. 명백히 웹을 위해 개발된 아키텍처를 모바일 개발에 그대로 사용하는 것은 불가능합니다. 그러나 최고의 아이디어를 가져와서 이를 모바일 특이사항에 맞게 확장하고 동작하는 프로토타입을 구현하는 것은 가능합니다.\n\n## Elm 아키텍처란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n어떤 Elm 프로그램도 항상 다음과 같은 요소로 구분됩니다:\n\n- 앱의 현재 상태를 유지하는 Model\n- Model을 사용자 인터페이스(UI)로 변환하는 View\n- UI에서 발생하는 이벤트인 Message\n- Message를 기반으로 새로운 Model을 생성하는 Update\n\n![Elm Program Structure](/assets/img/2024-06-19-ModernArchitectureforiOSapps_1.png)\n\n이를 기반으로, 몇 가지 매우 중요한 결과가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 모델은 주로 모바일 개발에서 State로 명명되며, 앱의 현재 상태나 현재 화면 등을 나타내는 데 필요한 모든 것을 유지하는 단일한 진실의 원천입니다.\n- 뷰는 모바일 개발에서는 뷰 빌더라고하는 순수한 함수인 뷰로, 상태를 입력으로 받고 사용자 인터페이스를 출력으로 하는 기능입니다.\n- 메시지 또는 이벤트는 사용자(또는 앱의 다른 부분)이 보낼 수 있는 한정된 집합이며, 여기서 키워드는 한정된 것이므로 예측할 수 없는 것이 오는 것은 불가능합니다.\n- 업데이트 함수 또는 리듀서는 현재 상태와 새 이벤트를 입력으로 받고 새 상태를 출력으로 하는 순수한 함수입니다. 이는 상태가 변경될 수 있는 유일한 장소입니다.\n\n실제로 앱의 모든 부분은 고립되어 있지 않고 다른 부분들과 협력하여 작동하며 몇 가지 종속성이 있습니다. 이 모든 것은 일종의 환경입니다. 또한 각 이벤트는 상태를 변경할 수 있는 몇 가지 부작용을 일으킬 수 있습니다. 사실, 새로운 상태는 현재 상태에 이벤트의 부작용을 적용한 결과물입니다. 그리고 사용자 인터페이스로부터 이벤트를 받아오기 위한 일종의 추상화, 즉 사용자 이벤트를 생성할 환경인 \"UI 피드백\"이 필요합니다.\n\n![image](/assets/img/2024-06-19-ModernArchitectureforiOSapps_2.png)\n\n예를 들어 사용자가 Pull-to-Refresh 제스처를 수행하면 \"사용자가 업데이트 요청함\" 이벤트가 리듀서 함수로 전달됩니다. 리듀서는 첫 번째 부작용 \"로딩이 시작됨\"을 생성하고 새 데이터를 가져 오기 위해 네트워크 API 호출을 수행합니다. 그런 다음 API 호출이 완료되면 리듀서는 두 번째 부작용 \"로딩이 중지됨\"을 생성합니다. 세 번째 부작용은 API 호출의 결과에 따라 다르며, 성공하는 경우 리듀서는 \"새로운 데이터가 도착함\" 효과를 생성하고, 그렇지 않으면 \"오류가 발생함\" 효과가 됩니다. 각 효과는 현재 상태에 적용되며 각 상태의 변경 후, 뷰 빌더가 사용자를 위해 업데이트된 실제 UI를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_3.png)\n\n지금까지 우리가 가지고 있는 내용을 정리해 봅시다:\n\n- State — 진실의 단일 출처\n- Event — Reducer에 대한 외부(일반적으로 사용자 입력 또는 “앱이 비활성 상태가 되었음”과 같은 시스템 이벤트) 액션\n- Effect — 내부 액션, State를 변경하는 이유\n- Environment — 이벤트를 이펙트로 변환하는 데 도움이 되는 모든 필수 의존성\n- UI-피드백 — 이벤트를 생성하는 함수\n- Reducer — Event를 Environment와 현재 State에 의해 Effect로 변환하는 \"이벤트 핸들러\"와 현재 State에 사이드 이펙트를 적용하여 새로운 State를 생성하는 \"이펙트 핸들러\" 두 가지 순수 함수를 포함하는 유한 상태 머신\n\n처음에는 조금 복잡해 보일 수 있지만, 실제로 사용하는 데 매우 쉽습니다. 특정 엔티티의 한정된 세트가 있고 각각이 특정 작업에만 책임 있기 때문입니다. 일방향 흐름이기 때문에 이를 따르고 무슨 일이 일어나고 있는지 이해하는 것이 쉽습니다. 대부분의 로직은 순수 함수이며, 진실의 단일 출처이며, 비즈니스 및 프리젠테이션 로직이 확실히 분리되어 있습니다. 이 모든 것을 고려할 때, 이 접근 방식은 정말 높은 수준의 테스트 가능성을 가지고 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 구현\n\niOS를 위한 Elm 아키텍처의 공식적인 구현은 없지만 적어도 두 가지 매우 좋은 시도가 있습니다:\n\n- RxFeedback: 기술적으로 오래되었으며 이벤트/이펙트를 분리하지 않고 SwiftUI 지원이 없습니다.\n- The Composable Architecture (TCA): 하나의 scope를 사용하며 앱의 다른 부분 간에 명확한 경계가 없으며 이벤트/이펙트를 분리하지 않습니다.\n\n왜 이벤트/이펙트를 분리해야 하는 이유일까요? — 비즈니스 로직의 보호를 위해서입니다. 시스템에 이 분리가 없다면 시스템은 외부에서 내부 이펙트로 확장될 수 있는 공개 이벤트를 가로채고 로직을 망가뜨릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n왜 명확한 경계가 중요한가요? — 앱을 작은 독립적인 조각으로 분할하는 가능성은 중요합니다. 전체 코드베이스를 개별 패키지와 타겟으로 분리하면 적은 결합도와 각 부분의 제한된 범위가 유지되어 테스트 가능성, 디버깅 용이성 및 유지 관리에 필수적인 좋은 수준을 유지할 수 있습니다.\n\n## 기술 스택\n\n기술적 측면에서 iOS 개발은 멈춰있지 않고 지속적으로 발전하고 있으며, 최근 몇 년 동안을 돌아보면 다음 몇 단계를 구분할 수 있습니다:\n\n- UIKit + GCD (iOS 9–12): iOS 개발의 기술 스택은 주로 Grand Central Dispatch (GCD) 및 Operation Queue와 함께 작동하는 UIKit으로 구성되어 있었으며 (일부는 스토리보드를 사용했지만, 보다 고급화된 개발자들은 UI를 프로그래밍적으로 구현했습니다).\r\n- UIKit + RxSwift (iOS 10–13): 반응형 프로그래밍의 등장: MVVM과 UI 바인딩은 제게는 새로운 것이 아니었습니다. 이전에 Microsoft Windows Phone에서 사용해본 적이 있었는데, 대부분의 모바일 개발자들에게는 마음을 바꾸는 혁명같은 것이었습니다.\r\n- UIKit + Combine (iOS 13–16): Apple이 마침내 원시적인 반응형 프레임워크인 Combine을 제시했는데, RxSwift와 같은 일부 영역에서는 그만큼 강력하지 않지만, 일상적인 루틴에 충분히 좋으며 여전히 대부분의 앱에서 활발히 사용되고 있습니다.\r\n- SwiftUI + Async/Await (iOS 15+): 네이티브 SwiftUI를 사용한 선언적 UI의 새 시대의 시작으로 처음에는 충분히 안정적이지 않았지만, 매 iOS 릴리스마다 점점 더 안정되고 매력적으로 변화했습니다. Async/Await는 여러 해 동안 많이 원하던 언어 기능이 드디어 출시되었으며 구현이 훌륭하고 강력합니다. 여전히 개선 중이지만, 확실히 제작용으로 완성되었으며 적어도 다음 몇 년 동안 기술 표준이 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션이 잘 관리되고 리팩터링이 필요한 부분을 계속 수행하는 경우, 이러한 단계들은 서로 점진적으로 전환됩니다. 만약 앱이 iOS 16의 최소 배포 버전을 갖고 있지만 여전히 RxSwift를 적극적으로 사용 중이라면, 무언가 잘못되었을 가능성이 높으며 앱의 기술적 측면에 충분한 주의를 기울이지 않고 있는 것일 수도 있습니다.\n\n오늘날, 인기 있는 많은 앱이 iOS 13 이하 버전을 지원하지 않기 때문에, 우리는 GCD를 사용한 쓰레드 수동 관리에 대해 이미 잊어도 좋을 것입니다(일부 필요한 드문한 경우를 제외하고) RxSwift 및 ReactiveX와 같은 경쟁자들에 대해서도 마찬가지입니다. 현재의 주류는 UIKit + Combine이지만, 내일의 주류는 SwiftUI + Async/Await입니다.\n\n## 소스 코드\n\n우리는 다 알다싶이 - \"말은 싸다. 코드를 보여줘.\"라는 말처럼; Elm 아이디어를 기반으로 하고 SOLID와 Clean Architecture 원칙을 염두에 두어 오늘날 가장 인기있는 기술 스택인 Combine + UIKit으로 Elm 아키텍처를 내 비전대로 구현했습니다. 이 구현은 여기에서 찾아볼 수 있습니다: https://github.com/angryscorp/TEA-Combine.\n\n<div class=\"content-ad\"></div>\n\n이 구현을 쉽게 평가할 수 있지만 몇 가지 순간을 강조하고 싶습니다.\n\n모든 개체는 구조체 및 열거형이며, 비즈니스 로직 레이어에 클래스가 없습니다. 이는 잠재적인 상속 문제 없이 더 나은 성능을 의미합니다.\n\n```js\npublic struct SceneEnvironment {\n    let getRandomNumber: () -> AnyPublisher<Int, Never>\n    let selectSomething: () -> AnyPublisher<Int?, Never>\n}\n\npublic struct SceneState: Equatable {\n    var something: Int? = nil\n    var currentValue = 0\n    var counter = 0\n}\n\npublic enum SceneEvent {\n    case userDidRequestIncrease\n    case userDidRequestDecrease\n    case userDidRequestSomething\n}\n\npublic enum SceneEffect {\n    case resultDidReceive(Int)\n    case somethingDidReceive(Int?)\n}\n```\n\n어셈블리 함수는 부작용이 없는 순수 함수로, 현재 장면이 의존하는 모든 것을 쉽게 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\npublic struct MainScene {\n    \n    public static func create(\n        setRootVC: (UIViewController) -> Void,\n        selectSomething: @escaping (UIViewController) -> AnyPublisher<Int?, Never>\n    ) {\n        let vc = ViewController()\n                \n        let env = SceneEnvironment(\n            getRandomNumber: { Just(Int.random(in: 1...9)).eraseToAnyPublisher() },\n            selectSomething: { selectSomething(vc) }\n        )\n        \n        TEA.start(\n            initialState: SceneState(),\n            environment: env,\n            feedback: vc.bind,\n            transform: SceneReducer.transform,\n            apply: SceneReducer.apply\n        ).store(in: &vc.subscriptions)\n\n        setRootVC(vc)\n    }\n}\n```\n\nReducer의 함수들도 순수하며, Event와 Effect가 단순히 열거형이기 때문에 이곳에서 switch 연산자를 효과적으로 사용할 수 있고, Event나 Effect에 대한 변경사항이 눈에 띄게 놓치지 않도록 합니다 (소스 코드가 컴파일 중지됩니다).\n\n```js\npublic enum SceneReducer {\n    \n    public static func transform(\n        state: SceneState,\n        event: SceneEvent,\n        env: SceneEnvironment\n    ) -> AnyPublisher<SceneEffect, Never> {\n        switch event {\n        case .userDidRequestDecrease:\n            return env.getRandomNumber()\n                .map { SceneEffect.resultDidReceive(-$0) }\n                .eraseToAnyPublisher()\n            \n        case .userDidRequestIncrease:\n            return env.getRandomNumber()\n                .map { SceneEffect.resultDidReceive($0) }\n                .eraseToAnyPublisher()\n            \n        case .userDidRequestSomething:\n            return env.selectSomething()\n                .map(SceneEffect.somethingDidReceive)\n                .eraseToAnyPublisher()\n        }\n    }\n\n    public static func apply(\n        state: SceneState,\n        effect: SceneEffect\n    ) -> SceneState {\n        switch effect {\n        case let .resultDidReceive(value):\n            return .init(\n                something: state.something,\n                currentValue: state.currentValue + value,\n                counter: state.counter + 1\n            )\n            \n        case let .somethingDidReceive(value):\n            return .init(\n                something: value,\n                currentValue: state.currentValue,\n                counter: state.counter\n            )\n        }\n    }\n}\n```\n\n사용자 인터페이스와 비즈니스 로직을 연결하는 모든 것은 딱 한 가지 함수 뿐이며, 따라서 UI 부분을 다른 것으로 쉽게 대체할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\nfunc bind(state: AnyPublisher<SceneState, Never>) -> AnyPublisher<SceneEvent, Never> {\n        state\n            .receive(on: DispatchQueue.main)\n            .sink(receiveValue: { [unowned self] state in\n                self.somethingLabel.text = \"Something: \" + (state.something.map {\"\\($0)\"} ?? \"nil\")\n                self.counterLabel.text = \"Counter: \\(state.counter)\"\n                self.currentValueLabel.text = \"Current value: \\(state.currentValue)\"\n                \n            })\n            .store(in: &subscriptions)\n        \n        return eventSubject.eraseToAnyPublisher()\n    }\n\n\n환경은 모든 종속성 및 라우팅을 포함하며, 장면 관점에서 봤을 때, 서비스 종속성과 다른 화면에서 값을 가져오는 것 사이에 기본적인 차이가 없습니다. 두 종속성 모두 순수 함수로 표현할 수 있습니다.\n\n\npublic struct SceneEnvironment {\n    let getRandomNumber: () -> AnyPublisher<Int, Never>\n    let selectSomething: () -> AnyPublisher<Int?, Never>\n}\n\n\n## 추가 개발\n\n\n<div class=\"content-ad\"></div>\n\n하지만 시간은 멈추지 않고 Combine에서 Async/Await와 SwiftUI로 이동할 시간입니다. 여기 Elm 아이디어가 여기서도 잘 작동하는 증거입니다: https://github.com/angryscorp/TEA-AsyncAwait.\n\n모든 것이 비슷하게 보이고 이미 익숙한데, 반응형 접근 방식이 새로운 Swift Modern Concurrency로 대체되어 더 간결하고 명확해졌습니다.\n\n```swift\npublic enum ExampleReducer {\n    \n    public static func transform(\n        state: ExampleState,\n        event: ExampleEvent,\n        env: ExampleEnvironment\n    ) async -> ExampleEffect {\n        switch event {\n        case .increase:\n            let newValue = await env.increment(state.currentValue)\n            return .newValue(newValue)\n        case .decrease:\n            let newValue = await env.decrement(state.currentValue)\n            return .newValue(newValue)\n        }\n    }\n    \n    public static func apply(\n        state: inout ExampleState,\n        effect: ExampleEffect\n    ) async -> ExampleState {\n        switch effect {\n        case .newValue(let newValue):\n            state.currentValue = newValue\n            return state\n        }\n    }\n}\n```\n\n모든 이점이 동일합니다:\n\n<div class=\"content-ad\"></div>\n\n- 리듀서를 위한 순수 함수\n- 비즈니스 로직이 없는 뷰\n- 상태는 단일 진실의 원천\n- 이벤트와 효과는 그냥 열거형\n- 적절한 종속성 주입\n- 비즈니스 로직과 UI가 확연히 분리됨\n- 응용 프로그램의 각 부분에 대한 명확한 경계\n- 모든 것이 쉽게 테스트, 디버깅 및 유지 관리될 수 있음\n- 강력하고 따르기 쉬운 구조\n\n이러한 구현 방식들은 iOS 개발에도 뛰어난 성과를 보여주는 Elm 아키텍처가 잘 작동함을 예시로 제시한 것입니다. 물론 그대로 사용할 수 있지만, 이것을 초안으로 삼아 개선하거나 이 원칙을 기반으로 자체 솔루션을 구현하는 등 다양하게 활용할 수 있습니다.\n\n# 테스트\n\n이미 테스트 가능성에 대한 언급을 조금 했었지만, 이번에 한 번 더 테스트의 중요성을 강조하고 싶습니다. 모바일 개발에서 일반적인 문제 중 하나는 테스트 작성이 인기 없다는 것입니다. 실제로 그 이유는 대부분 응용 프로그램 아키텍처가 안 좋기 때문입니다. 안 좋은 아키텍처는 기능을 테스트하기 어렵게 만듭니다. 테스트하기 어렵다는 것은 제대로 테스트하기 위해 많은 시간이 소요된다는 것을 의미합니다. 많은 시간이 든다는 것은 매우 비용이 소요된다는 것입니다. 매우 비용이 소요된다는 것은 비즈니스적인 측면에서 볼 때 이미 모든 게 올바르게 작동하고 있다고 보기 때문에 구현되지 않을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_4.png)\n\n그래서 이것의 주요 결과는 테스트 작성이 저렴해야 합니다. 이상적으로는 테스트를 몇 줄의 코드로 구현할 수 있어야 합니다. Elm 아키텍처를 사용하면 가능합니다. 예를 들어 비즈니스 로직을 테스트하는 방법을 보여드릴게요.\n\n일반적인 Elm 아키텍처 단위 테스트는 다음과 같습니다 - 말 그대로 세 줄의 코드입니다:\n\n- 어떤 이벤트가 발생했는가\n- 초기 상태\n- 기대되는 상태\n\n<div class=\"content-ad\"></div>\n\n```js\n    func test_userDidRequestIncrease() {\n        test(\n            event: .userDidRequestIncrease,\n            initialState: .init(currentValue: 2, counter: 2),\n            expectedState: .init(currentValue: 7, counter: 3)\n        )\n    }\n```\n\n그게 다에요. 다양한 Event와 State 조합을 테스트함으로써 모든 비즈니스 로직을 테스트하고 모든 것이 올바르게 작동하는지 확인할 수 있어요. 또한 한 가지 모범 사례를 포함하여 더 포괄적인 테스트를 위해 Effect 체인을 테스트할 수 있어요.\n\n```js\n    func test_userDidRequestDoubleIncreaseAndDecrease() {\n        test(\n            events: [.userDidRequestIncrease, .userDidRequestIncrease, .userDidRequestDecrease],\n            initialState: .init(currentValue: 23, counter: 2),\n            expectedState: .init(currentValue: 28, counter: 5)\n        )\n    }\n```\n\nThe full implementation of XCTestCase for the Elm architecture can be found here.\n\n<div class=\"content-ad\"></div>\n\n단위 테스트 외에도 스냅샷 테스트가 존재합니다. 많은 이점이 있음에도 불구하고, 스냅샷 테스트는 모바일 개발에서 매우 인기가 없으며, 그 이유는 보통 비슷합니다. 스냅샷 테스트를 구현하려면 뷰를 초기화해야 하는데, 이는 품질이 낮거나 적절한 의존성 주입 메커니즘이 없는 경우 쉽지 않을 수 있습니다.\n\n그러나 Elm을 사용하면 매우 쉽습니다. 강력한 레이어 분할 덕분에 뷰는 매우 간단하며 기본적으로 상태에만 의존합니다 (상태는 종종 초기값 또는 기본값을 갖습니다). 따라서 스냅샷 테스트를 만들려면 몇 줄의 코드를 작성해야 하며, 단위 테스트와 마찬가지로 간단합니다.\n\n스냅샷 테스트는 두 가지 이유로 매우 유용하고 중요합니다:\n\n- UI 레이어를 재발을 보호하므로 어떠한 변경과 리팩터링도 두렵지 않고 수행할 수 있습니다.\n- 테스트의 필요성을 염두에 두고 뷰를 올바른 방식으로 구현하도록 개발자들에게 유도하므로 유지보수와 시스템 디버깅 수준을 향상시킵니다.\n\n<div class=\"content-ad\"></div>\n\n# 구성 루트\n\n엘름 아키텍처는 장면 수준에서(장면이 보통 하나의 화면을 의미함) 발생하는 문제를 완벽하게 해결하지만, 이 외에도 앱에 다른 문제가 있을 수 있으며, 그 중 두 가지가 가장 중요합니다:\n\n- 적절한 종속성 주입이 없음\n- 모듈화가 되어 있지 않음\n\n적절한 종속성 주입의 부재는 다음과 같은 결과로 이어집니다:\n\n<div class=\"content-ad\"></div>\n\n- 장면 내에서 종속성 해결(Service-Locator 반패턴)\n- 주입 없이 종속성을 직접 사용하여 장면 테스트가 불가능해지는 문제\n\n모듈화 부족(앱이 모놀리스이며 모듈로 분리되지 않은 것을 의미)은 다음과 같은 문제로 이어집니다:\n\n- 유지보수 및 디버깅이 어려워지는 단일 전역 범위\n- 작은 변경이 앱의 매우 다른 부분에 영향을 미칠 수 있으며, 강력한 회귀 테스트 없이는 눈에 띄지 않을 수 있음\n\n모든 이러한 문제는 \"구성 루트\" 패턴을 통해 성공적으로 해결하고 전체 코드 베이스를 독립적인 모듈(스위프트 패키지 매니저(SPM) 용어에서 패키지 및 타겟)로 분할함으로써 해결할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nComposition Root은 모듈이 결합되는 애플리케이션의 고유 위치입니다.\n\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_5.png)\n\n실제 응용 프로그램에서 \"Composition Root\" 패턴이 어떻게 보이는지 더 잘 이해하기 위해 이를 보여드릴게요.\n\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_6.png)\n\n<div class=\"content-ad\"></div>\n\n모든 구성 요소는 별도의 타겟으로 Swift Package에 있으며, 이상적으로 관련된 몇 가지 구성 요소/타겟(예: \"온보딩\" 플로우와 같이 함께하는 사용자 흐름)은 별도의 Swift 패키지에 위치해 있습니다.\n\n여기에 \"구성 루트(Composition Root)\" 구현의 간단한 예제를 찾을 수 있습니다.\n\n구성 루트와 모듈화는 다음과 같은 탁월한 장점을 가지고 있습니다:\n\n- 앱의 독립적인 부분이 서로 다른 모듈에 위치\n- 모듈간 명확하고 강력한 경계\n- 한 모듈의 변경이 다른 모듈에 영향을 미칠 수 없음\n- 가볍고 최적화하기 쉬운 실행 레이어\n- 전체 앱 및 그 어떤 부분에 대한 안정성, 유지보수 및 디버깅이 크게 향상됨\n- 모든 종속성이 안전하게 해결되었음을 정적 컴파일 시 보장\n- 의도하지 않은 모듈 간 사용 또는 간섭 제외\n- 앱의 모든 레이어 및 부분 간의 낮은 결합도\n- 변경되지 않은 모듈을 캐싱하여 컴파일 프로세스가 빨라짐\n\n<div class=\"content-ad\"></div>\n\n# 걱정하는 것을 그치고, 삶을 시작하는 방법\n\n혹시 이 모든 것이 흥미롭긴 하지만, 여러분의 앱의 현재 상태에서 실제로 시도해보기에는 너무 멀게 느껴진다면, 그것은 오산이다. 앱의 상태에 따라 Elm 아이디어와 Clear Architecture 원칙으로의 여정이 더 오래 또는 더 짧을 수 있지만, 확실히 가능하며 가능한 한 빨리 해야 할 것입니다.\n\n이를 위해 특별한 리팩터링 작업이 필요하지는 않습니다. 단지 Core 패키지를 만들고 Domain 타겟(비어있어도 괜찮습니다)을 생성한 뒤, 일상적인 기능 작업의 일부로 점진적으로 채워 넣기 시작하면 됩니다. 새로운 멋진 기능을 구현하려면 새로운 Swift 패키지를 만들어 이 패키지에 모든 코드를 작성하면 됩니다(한 화면씩 한 타겟). 이 기능을 위해 새로운 Domain 엔티티가 필요하다면 FeatureDomain 타겟을 만들고 해당 엔티티를 넣으면 됩니다. 몇 개의 화면에서 로직을 재사용해야 한다면 새로운 UseCase 타겟을 만들고 해당 로직을 옮기면 됩니다. Composition Root을 시도할 준비가 되면 한 번에 앱 전체를 다시 쓸 필요는 없습니다. 적절한 진입점을 찾아서 진입점 이후의 모든 것이 자동으로 모듈성과 Composition Root의 장점을 얻을 수 있습니다.\n\n다시 강조하고 싶은 것은, 앱을 개선하기 위해 특별한 작업이 필요하지 않으며, 일상적인 루틴의 일부로 이를 수행하면 된다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그 모든 것은 이론적인 접근이나 환상에 그치는 것이 아닙니다. 몇 차례 시도해 본 경험을 통해 알려주겠습니다. 많은 문제와 안티패턴이 존재하는 레거시 앱을 성공적으로 최고 수준의 견고하고 효율적인 솔루션으로 변환했습니다.\n\n# 결론\n\nElm 아키텍처와 Composition Root 패턴 뒤에 있는 아이디어는 새로운 것이 아니지만, 모바일 개발에서 지나치게 소홀히 다루는 것을 알 수 있습니다. 이 기사는 이러한 원칙이 어떻게 실무에 적용될 수 있는지에 대한 이해의 공백을 채우기 위한 지식과 경험을 공유하기 위한 것입니다. 저는 이러한 접근 방식을 일상적인 업무에 사용하며, 제 팀뿐만 아니라 저 자신도 매우 만족하고 있습니다.\n\n실제 제작 개발에서 검증된 작동하는 구현을 제공했지만, 항상 솔루션과 아이디어를 특정 상황과 기술 스택에 맞게 맞추는 것이 더 좋습니다. 이를 강화시키기 위해 발전시킬 수 있는 초안으로도 고려할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n제가 권장하고 장려하는 바에 따라 아키텍처 주제에 조금 더 깊이 파고들어보시고 이 글에서 제안하는 아이디어를 귀하의 프로젝트에서 시도해보세요. 그것이 잘 작동하고 귀하의 앱을 다음 수준으로 끌어 올릴 수 있다는 것을 직접 확인하면서, 없을 때 어떻게 살아온 지 의심스러울 정도일 겁니다.","ogImage":{"url":"/assets/img/2024-06-19-ModernArchitectureforiOSapps_0.png"},"coverImage":"/assets/img/2024-06-19-ModernArchitectureforiOSapps_0.png","tag":["Tech"],"readingTime":19},{"title":"맥OS Sequoia의 새로운 기능들","description":"","date":"2024-06-19 11:00","slug":"2024-06-19-WhatsNewinmacOSSequoia","content":"\n\n맥OS 15 세쿼이아의 흥미진진한 혁신에 빠져 보세요! WWDC 2024에서 공개됐어요!\n\n![맥OS 세쿼이아](https://miro.medium.com/v2/resize:fit:1400/1*WWqe1h7PVj4W71TS8J2IzA.gif)\n\nWWDC 2024에서 뽐낸 주목할만한 발표 중 하나는 macOS 세쿼이아였는데요, 맥 사용자들에게 원활하고 강력한 경험을 제공할 것을 약속하고 있어요. 생산성, 창의성, 연결성에 초점을 맞춘 macOS 세쿼이아는 Apple 생태계를 향상시키는 새로운 기능을 소개했어요.\n\n정교한 사용자 인터페이스부터 혁신적인 성능 향상까지, 함께 WWDC 2024에서 발표된 흥미로운 내용을 살펴보아요.\n\n<div class=\"content-ad\"></div>\n\n# macOS 15을 지원하는 기기들:\n\n- MacBook Pro (2018년 이후 모델)\n- MacBook Air (2018년 이후 모델)\n- Mac Pro (2019년 이후 모델)\n- Mac Studio (2022년 이후 모델)\n- Mac Mini (2018년 이후 모델)\n- iMac Pro (2017년 이후 모델)\n- iMac (2019년 이후 모델)\n\n# 내부에서 찾을 수 있는 것들:\n\n- iPhone 미러링\n- 창 배치\n- 비디오 콜\n- Safari\n- 비밀번호 앱\n- Mac 게임\n- macOS Sequoia에서의 추가 기능\n\n<div class=\"content-ad\"></div>\n\n# 아이폰 미러링\n\nmacOS Sequoia에서는 아이폰 미러링을 통한 연속성의 중요한 기능이 소개되었습니다. 이로써 맥이 잠겨 있을 때에도 아이폰에 완전히 액세스할 수 있습니다.\n\n미러링을 통해 사용자는 아이폰의 모든 앱을 실행하고 사용할 수 있습니다. 맥의 키보드, 마우스 및 트랙패드를 사용하여 아이폰과 상호 작용할 수도 있습니다. 아이폰의 오디오는 맥을 통해 재생됩니다.\n\n미러링을 하면 아이폰과 맥 간에 파일을 드래그하여 이동할 수 있습니다. 아이폰의 알림은 맥의 알림과 함께 표시되므로 사용자는 아이폰이 없을 때에도 확인하고 상호 작용할 수 있습니다. 알림을 탭하면 해당 앱이 미러링 모드에서 열립니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_0.png)\n\n# 창 타일링\n\n사용자는 창을 화면 가장자리로 끌어다 놓아 데스크탑에 배치하는 창 타일링 제안을 받을 수 있습니다. 키보드 및 메뉴 단축키를 사용하여 창을 정리하여 사용자가 조직적으로 유지할 수 있습니다.\n\n![image](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_1.png)\n\n<div class=\"content-ad\"></div>\n\n# 비디오 콘퍼런싱\n\n프레젠터 미리보기를 통해 사용자들은 공유하기 전에 공유할 내용을 볼 수 있으며, FaceTime 및 Zoom 앱과 함께 작동합니다. 사용자는 비디오 콘퍼런싱 중에 최상의 모습을 유지하기 위해 배경 사진을 설정할 수도 있습니다.\n\n![image](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_2.png)\n\n# Safari\n\n<div class=\"content-ad\"></div>\n\n- Safari는 이제 페이지 강조 기능을 제공하여 방향, 요약 또는 사람, 음악, 영화 및 TV 프로그램에 대해 자세히 알아보기 위한 빠른 링크와 같은 유용한 정보를 제공합니다.\n- 웹 페이지에서 비디오를 발견하면 사용자가 Picture in Picture를 포함한 완전한 재생 제어 기능을 제공하는 동시에 중심에 배치됩니다.\n- 재설계된 리더(Reader)는 혼잡하지 않고 독서 경험을 제공합니다. Safari는 개인 브라우징을 특징으로하며, 히스토리 보호와 웹 사이트가 브라우징하는 동안 사용자를 추적하는 것을 방지합니다.\n\n기타 Safari 기능으로는\n\n- 프로필\n- 번역\n- 확장 기능\n- 탭 그룹\n- 패스키\n- 개인 릴레이\n\n# 비밀번호 앱\n\n<div class=\"content-ad\"></div>\n\nmacOS Sequoia의 Passwords 앱을 사용하면 모든 암호에 쉽게 액세스할 수 있어요. iCloud 동기화를 통해 암호를 모든 Apple 기기 간에 동기화할 수 있어요.\n\n![2024-06-19-WhatsNewinmacOSSequoia_3.png](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_3.png)\n\n# 맥에서 게임하기\n\n## 1. 새로운 게임 타이틀\n\n<div class=\"content-ad\"></div>\n\n맥에서 기다리고 있던 Ubisoft의 Assassin's Creed Shadows가 11월 15일에 출시될 예정입니다.\n\n다른 맥용 게임 소개\n\n- Prince of Persia: The Lost Crown\n- RESIDENT EVIL 7 biohazard\n- RESIDENT EVIL 2\n- World of Warcraft: The War Within\n- Frostpunk 2\n- Palworld\n- Sniper Elite 4\n- RoboCop: Rogue City\n\n![이미지](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 2. 몰입형 게임 경험\n\n에어팟 프로(2세대)에서 개인화된 공간 오디오로 인해 레이턴시가 줄어들어 더 반응이 좋아졌습니다. 게임 모드 개선으로 더 부드러운 프레임률을 제공합니다.\n\n## 3. 게임 포팅 툴킷 2\n\n개발자들은 게임 포팅 툴킷 2의 개선 사항을 활용하여 이제 Apple 기기로 쉽게 게임을 가져올 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Mac용 Apple Intelligence\n\n강력한 생성 모델을 활용한 개인용 지능 시스템으로, 개인 맥락을 이해하고 사용자에게 미치는 유용하고 관련성 높은 기능과 콘텐츠를 제공하며 개인정보 보호를 핵심가치로 삼습니다.\n\nApple 실리콘의 힘을 빌려, Apple Intelligence는 언어와 이미지를 생성하고 개인 맥락을 활용하여 모든 앱에서 작업을 가속화하여 사용자의 일상 업무를 더욱 효율적으로 처리할 수 있습니다.\n\n## 1. 언어 생성\n\n<div class=\"content-ad\"></div>\n\n- 기능 재작성은 친근하거나 전문적이거나 간결하다는 다른 톤으로 텍스트를 조정할 수 있습니다.\n- 교정은 문법, 어휘 선택, 문장 구조를 확인하며, 사용자가 검토하거나 수락할 편집 제안을 할 수 있습니다.\n- 사용자는 독자의 시간을 절약하기 위해 텍스트를 글머리 기호, 목록 또는 간결한 단락으로 요약할 수 있습니다.\n- Mail 앱의 중요 메시지는 가장 긴급한 이메일(이벤트나 탑승권과 같은)을 보여주는 인박스 상단에 새 섹션을 추가합니다. Mail 앱은 또한 사용자가 전체 이메일을 열어 읽을 필요 없이 이메일 요약을 표시합니다.\n- 스마트 답장은 이메일의 질문을 분석하고 식별하여 빠른 응답을 위한 제안을 제공하며, 모든 것이 답변되도록 보장합니다.\n\n\n<img src=\"/assets/img/2024-06-19-WhatsNewinmacOSSequoia_5.png\" />\n\n\n### 2. 이미지 만들기\n\n\n<img src=\"/assets/img/2024-06-19-WhatsNewinmacOSSequoia_6.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n## 3. 시리\n\n# macOS Sequoia의 추가 기능\n\n- 메시지에는 새로운 텍스트 효과, 이모티콘, 스티커 Tapbacks가 포함되어 있습니다. 사용자는 메시지를 나중에 보낼 수도 있습니다.\n- Apple Maps는 이제 모든 63개 국립 공원의 하이킹 코스를 보여줍니다. 사용자는 길이, 고도 및 루트 유형으로 필터링하여 오프라인 액세스를 위해 저장할 수 있습니다.\n- 캘린더에는 레마인더에서 이벤트와 작업을 표시하여 사용자가 하루 내내 레마인더에 대해 조치를 취할 수 있습니다.\n- 메모는 이제 등식의 자동 해결을 지원하여 사용자가 등식을 입력하기만 하면 숫자를 빠르게 계산할 수 있습니다. 메모의 새로운 오디오 전사 기능은 사용자가 Apple Intelligence를 활용하여 대본을 만들고 요약하는 데 도움을 줍니다.\n\n# 마무리 생각\n\n<div class=\"content-ad\"></div>\n\n맥OS Sequoia는 혁신적인 기능과 원활한 Apple 생태계 전체에서의 통합을 통해 맥 경험을 새로운 차원으로 끌어올립니다. 이 업데이트는 모든 사용자를 위한 생산성, 창의성 및 연결성을 재정의합니다.","ogImage":{"url":"/assets/img/2024-06-19-WhatsNewinmacOSSequoia_0.png"},"coverImage":"/assets/img/2024-06-19-WhatsNewinmacOSSequoia_0.png","tag":["Tech"],"readingTime":5},{"title":"SwiftUI에서 FocusState를 마스터하기 고급 기능을 활용한 동적 폼 관리","description":"","date":"2024-06-19 10:59","slug":"2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures","content":"\n\n<img src=\"/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png\" />\n\n사용자의 포커스를 효과적으로 관리하는 것은 모든 애플리케이션에서 매끈하고 직관적인 사용자 경험을 만들기 위해 중요합니다. SwiftUI는 FocusState라는 강력한 기능을 제공하는데, 이를 사용하면 개발자가 폼 입력 및 기타 대화형 요소의 포커스 상태를 동적으로 관리할 수 있습니다. 이 블로그 포스트에서는 FocusState를 사용하여 사용자 상호작용에 따라 포커스를 조정하는 사용자 지정 입력 폼을 만드는 방법을 살펴보겠습니다. 또한 조건부 포커스, 키보드 관리 및 사용자 정의 포커스 처리와 같은 고급 기능을 포함하고 있습니다.\n\n## FocusState 이해하기\n\nFocusState는 SwiftUI에서 도입된 프로퍼티 래퍼로, 텍스트 필드와 같은 뷰의 포커스 상태를 관리하는 데 도움을 주는 역할을 합니다. FocusState를 사용하면 어떤 입력 필드에 포커스를 맞출지를 프로그래밍적으로 제어할 수 있어 사용자 경험을 더 부드럽게 만들 수 있습니다, 특히 폼에서의 경우에 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n## 커스텀 입력 폼 만들기\n\n사용자 입력에 따라 동적으로 포커스가 변경되는 여러 텍스트 필드가 있는 포괄적인 양식을 만들어 봅시다. 조건부 포커스, 키보드 해제 및 사용자 정의 포커스 로직과 같은 고급 기능을 통합할 것입니다.\n\n## 구현 단계별\n\n1. 양식 필드와 포커스 상태 정의하기\n\n<div class=\"content-ad\"></div>\n\n먼저, 다양한 폼 필드를 나타내는 열거형을 정의합니다. 그런 다음, 폼 상태와 포커스 상태를 나타내는 구조체를 생성합니다.\n\n```js\nimport SwiftUI\n\nenum FormField: Hashable {\n    case firstName\n    case lastName\n    case email\n    case password\n    case confirmPassword\n}\n\nstruct FormState {\n    var firstName: String = \"\"\n    var lastName: String = \"\"\n    var email: String = \"\"\n    var password: String = \"\"\n    var confirmPassword: String = \"\"\n}\n```\n\n2. 폼 뷰 생성하기:\n\n이제, 폼 필드를 포함하는 뷰를 생성해보겠습니다. @FocusState 프로퍼티 래퍼를 사용하여 포커스 상태를 관리하고 더 많은 고급 기능을 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nstruct CustomFormView: View {\n    @State private var formState = FormState()\n    @FocusState private var focusedField: FormField?\n\n    var body: some View {\n        VStack {\n            Form {\n                TextField(\"이름\", text: $formState.firstName)\n                    .focused($focusedField, equals: .firstName)\n                    .onSubmit {\n                        focusedField = .lastName\n                    }\n                    .submitLabel(.next)\n\n                TextField(\"성\", text: $formState.lastName)\n                    .focused($focusedField, equals: .lastName)\n                    .onSubmit {\n                        focusedField = .email\n                    }\n                    .submitLabel(.next)\n\n                TextField(\"이메일\", text: $formState.email)\n                    .focused($focusedField, equals: .email)\n                    .keyboardType(.emailAddress)\n                    .onSubmit {\n                        focusedField = .password\n                    }\n                    .submitLabel(.next)\n\n                SecureField(\"비밀번호\", text: $formState.password)\n                    .focused($focusedField, equals: .password)\n                    .onSubmit {\n                        focusedField = .confirmPassword\n                    }\n                    .submitLabel(.next)\n\n                SecureField(\"비밀번호 확인\", text: $formState.confirmPassword)\n                    .focused($focusedField, equals: .confirmPassword)\n                    .onSubmit {\n                        validateForm()\n                    }\n                    .submitLabel(.done)\n            }\n            .padding()\n\n            Button(\"제출\") {\n                validateForm()\n            }\n            .padding()\n            .buttonStyle(.borderedProminent)\n        }\n        .onTapGesture {\n            // 필드 외부를 탭하면 키보드 닫기\n            focusedField = nil\n        }\n        .toolbar {\n            ToolbarItemGroup(placement: .keyboard) {\n                Spacer()\n                Button(\"완료\") {\n                    focusedField = nil\n                }\n            }\n        }\n    }\n\n    private func validateForm() {\n        // 여기서 폼 유효성 검사 및 제출 로직 수행\n        guard !formState.firstName.isEmpty,\n              !formState.lastName.isEmpty,\n              isValidEmail(formState.email),\n              formState.password == formState.confirmPassword else {\n            // 오류 메시지 표시 또는 유효성 검사 실패 처리\n            return\n        }\n\n        // 폼 제출 처리\n        print(\"폼이 제출되었습니다: \\(formState)\")\n        focusedField = nil\n    }\n\n    private func isValidEmail(_ email: String) -> Bool {\n        // 기본적인 이메일 유효성 검사 로직\n        let emailRegEx = \"[A-Z0-9a-z._%+-]+@[A-Z0-9a-z.-]+\\\\.[A-Za-z]{2,64}\"\n        let emailPred = NSPredicate(format: \"SELF MATCHES %@\", emailRegEx)\n        return emailPred.evaluate(with: email)\n    }\n}\n```\n\n3. Form View 미리보기:\n\n마지막으로 SwiftUI 미리보기에서 Form View를 미리볼 수 있습니다.\n\n```swift\n#Preview {\n  CustomFormView()\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## Explanation\n\n- **포커스 관리:** 각 TextField 및 SecureField는 `.focused($focusedField, equals: .formField)` 수정자를 사용하여 특정 포커스 상태와 연결됩니다. 이를 통해 사용자가 하나의 필드를 제출할 때 다음 필드로 포커스가 전환됩니다.\n\n- **동적 포커스 조정:** `onSubmit` 수정자는 반환 키 작업을 처리하는 데 사용됩니다. 사용자가 현재 필드를 제출하면 포커스가 다음 필드로 변경됩니다.\n\n- **사용자 지정 키보드 툴바:** 키보드에 사용자 정의 툴바가 추가되어 \"완료\" 버튼을 탭함으로써 키보드를 해제할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n• 양식 제출 및 유효성 검사: validateForm 함수는 양식 제출과 유효성 검사를 처리합니다. 비어있는 필드, 유효한 이메일 형식 및 일치하는 비밀번호를 확인한 후에야 양식 제출이 진행됩니다.\n\n• 키보드 해제: onTapGesture 수정자는 사용자가 입력 필드 외부를 탭할 때 키보드를 해제하는 데 사용됩니다.\n\n## 결론\n\nSwiftUI에서 FocusState를 사용하면 입력 필드의 포커스 상태를 관리하여 동적이고 사용자 친화적인 양식을 만들 수 있습니다. 조건부 포커스, 키보드 관리 및 사용자 정의 유효성 검사와 같은 고급 기능을 통합함으로써 SwiftUI 애플리케이션에서 사용자 경험을 향상시키고 더 견고한 양식을 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n원하는 경우 원시 모바일 개발에 대해 더 알아보려면 여기에서 다른 기사들을 확인해보세요: [https://medium.com/@wesleymatlock](https://medium.com/@wesleymatlock)\n\n코딩을 즐기세요! 🚀","ogImage":{"url":"/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png","tag":["Tech"],"readingTime":6},{"title":"MVVM 아키텍처로 SwiftUI 앱 구축하기 실전 안내","description":"","date":"2024-06-19 10:58","slug":"2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide","content":"\n\n이 튜토리얼에서는 MVVM(Model-View-ViewModel) 아키텍처를 사용하여 간단한 SwiftUI 애플리케이션을 만드는 방법을 안내합니다. 데이터 처리 및 네트워킹을 위해 Combine 프레임워크를 활용할 것입니다. 이 예제에서는 REST API에서 데이터를 가져오고 게시하는 방법을 보여줍니다.\n\n# 개요\n\n다음과 같은 간단한 앱을 만들 것입니다:\n\n- 서버에서 게시물 목록을 가져오기.\n- SwiftUI 뷰에서 게시물을 표시하기.\n- 새 게시물을 생성하기.\n\n<div class=\"content-ad\"></div>\n\n# 프로젝트 설정\n\n먼저 Xcode에서 새로운 SwiftUI 프로젝트를 생성하세요. 그런 다음, 더 나은 구성을 위해 다음과 같은 폴더를 설정합니다:\n\n- Models\n- ViewModels\n- Views\n- Services\n\n# Models\n\n<div class=\"content-ad\"></div>\n\n\"Post\" 모델을 시작해봅시다. 이 모델은 Identifiable과 Codable을 준수합니다.\n\n```swift\n// Models/Post.swift\n\nimport Foundation\n\nstruct Post: Identifiable, Codable {\n    let id: Int\n    let title: String\n    let body: String\n}\n```\n\n# 서비스\n\n네트워크 요청을 처리하기 위한 서비스 레이어가 필요합니다. ApiService와 ApiEndpoints를 만들 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n// Services/ApiEndpoints.swift\n\nimport Foundation\n\nclass ApiEndpoints {\n    static let baseURL = \"https://jsonplaceholder.typicode.com\"\n    \n    static var posts: String { return \"\\(baseURL)/posts\" }\n    static func post(id: Int) -> String { return \"\\(baseURL)/posts/\\(id)\" }\n}\n\n\n\n// Services/ApiService.swift\n\nimport Foundation\nimport Combine\n\nclass ApiService {\n    static let shared = ApiService()\n    private init() {}\n    \n    private func makeRequest<T: Decodable>(url: String, method: String, body: Data? = nil) -> AnyPublisher<T, Error> {\n        guard let url = URL(string: url) else {\n            fatalError(\"Invalid URL\")\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = method\n        if let body = body {\n            request.httpBody = body\n            request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        }\n        \n        return URLSession.shared.dataTaskPublisher(for: request)\n            .tryMap { output in\n                guard let response = output.response as? HTTPURLResponse,\n                      response.statusCode >= 200 && response.statusCode < 300 else {\n                    throw URLError(.badServerResponse)\n                }\n                return output.data\n            }\n            .decode(type: T.self, decoder: JSONDecoder())\n            .eraseToAnyPublisher()\n    }\n    \n    func get<T: Decodable>(url: String) -> AnyPublisher<T, Error> {\n        return makeRequest(url: url, method: \"GET\")\n    }\n    \n    func post<T: Decodable, U: Encodable>(url: String, body: U) -> AnyPublisher<T, Error> {\n        guard let bodyData = try? JSONEncoder().encode(body) else {\n            fatalError(\"Invalid body data\")\n        }\n        return makeRequest(url: url, method: \"POST\", body: bodyData)\n    }\n    \n    func delete<T: Decodable>(url: String) -> AnyPublisher<T, Error> {\n        return makeRequest(url: url, method: \"DELETE\")\n    }\n}\n\n\n# ViewModels\n\n이제, PostViewModel을 만들어서 게시물을 가져오고 만들어봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n```swift\n// ViewModels/PostViewModel.swift\n\nimport Foundation\nimport Combine\n\nclass PostViewModel: ObservableObject {\n    @Published var posts: [Post] = []\n    @Published var isLoading = false\n    @Published var errorMessage: String? = nil\n    \n    private var cancellables = Set<AnyCancellable>()\n    private let apiService = ApiService.shared\n    \n    func fetchPosts() {\n        self.isLoading = true\n        self.errorMessage = nil\n        \n        apiService.get(url: ApiEndpoints.posts)\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { [weak self] completion in\n                self?.isLoading = false\n                switch completion {\n                case .failure(let error):\n                    self?.errorMessage = error.localizedDescription\n                case .finished:\n                    break\n                }\n            }, receiveValue: { [weak self] posts in\n                self?.posts = posts\n            })\n            .store(in: &cancellables)\n    }\n    \n    func createPost() {\n        let newPost = Post(id: 101, title: \"New Post\", body: \"This is a new post.\")\n        \n        apiService.post(url: ApiEndpoints.posts, body: newPost)\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { completion in\n                switch completion {\n                case .failure(let error):\n                    print(\"Error: \\(error.localizedDescription)\")\n                case .finished:\n                    print(\"Post created successfully\")\n                }\n            }, receiveValue: { (post: Post) in\n                print(\"Created post: \\(post)\")\n            })\n            .store(in: &cancellables)\n    }\n}\n```\n\n# Views\n\n마지막으로, SwiftUI 뷰를 생성하여 게시물을 표시하고 사용자 상호작용을 처리합니다.\n\n```swift\n// Views/PostListView.swift\n\nimport SwiftUI\n\nstruct PostListView: View {\n    @StateObject private var viewModel = PostViewModel()\n    \n    var body: some View {\n        NavigationView {\n            VStack {\n                if viewModel.isLoading {\n                    ProgressView(\"로딩 중...\")\n                } else if let errorMessage = viewModel.errorMessage {\n                    Text(\"오류: \\(errorMessage)\")\n                } else {\n                    List(viewModel.posts) { post in\n                        VStack(alignment: .leading) {\n                            Text(post.title)\n                                .font(.headline)\n                            Text(post.body)\n                                .font(.subheadline)\n                        }\n                    }\n                }\n            }\n            .navigationTitle(\"게시물\")\n            .onAppear {\n                viewModel.fetchPosts()\n            }\n            .toolbar {\n                Button(action: {\n                    viewModel.createPost()\n                }) {\n                    Image(systemName: \"plus\")\n                }\n            }\n        }\n    }\n}\n\nstruct PostListView_Previews: PreviewProvider {\n    static var previews: some View {\n        PostListView()\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 모두 함께 적용하기\n\n모두가 동작하는 것을 보려면 PostListView를 App 구조체의 진입점으로 설정하세요.\n\n```js\n// demoApp.swift\n\nimport SwiftUI\n\n@main\nstruct demoApp: App {\n    var body: some Scene {\n        WindowGroup {\n            PostListView()\n        }\n    }\n}\n```\n\n이 튜토리얼에서는 SwiftUI 애플리케이션에서 간단한 MVVM 아키텍처를 구현했습니다. 이 구조는 관심사를 분리하여 코드를 보다 깨끗하고 유지보수하기 쉽게 만들어주며, Combine과 같은 Swift의 강력한 기능을 활용하여 비동기 데이터 스트림 처리에도 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 안내를 따르면 SwiftUI 프로젝트에서 MVVM을 설정하고 사용하는 방법에 대해 잘 이해할 수 있을 것입니다. 코딩을 즐기세요!","ogImage":{"url":"/assets/img/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"Linker command failed with exit code 1 오류 해결하기","description":"","date":"2024-06-19 10:58","slug":"2024-06-19-FixingLinkercommandfailedwithexitcode1","content":"\n\n<img src=\"/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png\" />\n\niOS 개발 중 에러를 만나면 “Linker command failed with exit code 1”과 같은 알 수 없는 메시지가 표시되면 특히 답답할 수 있습니다. 그러나 걱정하지 마세요! 이 블로그 포스트에서는 이 오류를 해결하고 iOS 프로젝트를 다시 가동할 수 있는 몇 가지 간단한 단계를 안내해 드릴 거에요.\n\n이 오류가 의미하는 바:\n\n“Linker command failed with exit code 1” 오류는 주로 Xcode가 프로젝트 파일을 함께 연결할 수 없을 때 발생합니다. Xcode가 파일을 읽는 데 어려움을 겪는 경우는 파일을 삭제했지만 제대로 삭제되지 않은 복사본이나 종속성이 제대로 읽을 수 없는 경우입니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 이 오류를 해결하는 데 따를 수 있는 몇 가지 단계입니다: \n\n- 팟 다시 설치\n\n   1. 먼저 맥에서 터미널을 엽니다.\n   2. 아래 명령어를 따릅니다:\n      \n      cd 당신의_프로젝트_경로\n      pod deintegrate\n      pod update\n      \n\n만약 문제가 계속되면 다음을 시도해보세요:\n\n<div class=\"content-ad\"></div>\n\n- pod deintegrate\n- pod clean\n- rm Podfile\n- pod init\n- pod install\n\n2. Go to your Project navigator - Target - Build settings - Set BUILD ACTIVE ARCHITECTURE ONLY to NO \n3. Add archicture arm64 and x86_64 in Project navigator - Target - Build settings - EXCLUDED ARCHECTURES\n\n4. Reinstall swift packages\n\n- Remove swift packages and add them again in your project. Don’t remove all the packages at once, start by removing and immediately adding the package that you installed last.\n- Reinstall one package and build your project. If the error still persists, remove another package and reinstall it. Keep doing it with all the packages you have in your project.\n- Don’t forget to press cmd+shift+k to clean build folder before building the project.\n- Also, clean derived data from your project and run Reset package content in your project\n\n<div class=\"content-ad\"></div>\n\n결론:\n그런 걸로 끝났어요! 이 간단한 단계를 따라하면 iOS 프로젝트에서 \"Linker command failed with exit code 1\" 오류를 해결할 수 있을 겁니다. 기억하세요, 에러 해결은 iOS 개발의 필수적인 부분이에요. 조금의 인내와 적절한 도구가 있다면 모든 어려움을 극복할 수 있습니다.\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png"},"coverImage":"/assets/img/2024-06-19-FixingLinkercommandfailedwithexitcode1_0.png","tag":["Tech"],"readingTime":2},{"title":"iOS에서 Swift를 사용하여 견고한 네트워크 계층 구축하기","description":"","date":"2024-06-19 10:56","slug":"2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift","content":"\n\n\n![이미지](/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png)\n\n현대 iOS 개발에서 API 호출 및 데이터 검색을 효율적이고 안전하게 처리하기 위해 잘 구조화된 네트워크 레이어를 갖는 것이 중요합니다. 이 기사에서는 제공된 코드를 기반으로 Swift로 견고한 네트워크 레이어를 만드는 방법을 안내합니다.\n\n# 개요\n\n우리의 네트워크 레이어는 여러 중요한 구성 요소로 구성됩니다:\n\n\n<div class=\"content-ad\"></div>\n\n- NetworkError: 다양한 종류의 네트워크 오류를 처리하기 위한 포괄적 인템.\n- NetworkRequest: 네트워크 요청에 필요한 속성과 메소드를 정의하는 프로토콜.\n- NetworkManager: 네트워크 요청 수행, 응답 해석 및 파일 다운로드 처리를 담당하는 싱글톤 클래스입니다.\n\n또한 이러한 구성 요소를 예시 API 호출 및 파일 다운로드와 함께 사용하는 방법을 보여줄 것입니다.\n\n# 단계 1: 네트워크 오류 정의하기\n\n다양한 네트워크 관련 오류를 깨끗하고 조직된 방식으로 처리하는 데 도움이 되는 NetworkError 열거형을 정의하는 것부터 시작해보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport Foundation\n\nenum NetworkError: Error {\n    case badURL\n    case requestFailed(Error)\n    case invalidResponse\n    case dataNotFound\n    case decodingFailed(Error)\n    case encodingFailed(Error)\n    case notFound\n    case internalServerError\n    case unknownError(statusCode: Int)\n}\n\nstruct DecodingError: Error {\n    let message: String\n}\n```\n\n설명:\n\nNetworkError Enum: 이 Enum은 발생할 수 있는 가능한 네트워크 관련 오류를 나열하여 오류 처리를 더 쉽게 할 수 있게 합니다.\n\n- badURL: 유효하지 않은 URL을 나타냄.\n- requestFailed: 네트워크 요청 실패를 나타내며 원래 오류를 저장함.\n- invalidResponse: 받은 응답이 유효하지 않음을 나타냄.\n- dataNotFound: 응답에서 기대하는 데이터를 찾을 수 없음을 나타냄.\n- decodingFailed: 응답 데이터를 기대하는 타입으로 디코딩하는 데 실패함을 나타냄.\n- encodingFailed: 요청 매개변수 인코딩 실패를 나타냄.\n- notFound: 404 오류를 나타냄.\n- internalServerError: 500 오류를 나타냄.\n- unknownError: 연결된 상태 코드와 함께 알 수 없는 오류를 나타냄.\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n네트워크 요청 프로토콜: 모든 네트워크 요청이 따라야 하는 구조를 정의합니다.\n\n- url: 엔드포인트 URL입니다.\n- method: HTTP 메서드(GET, POST 등)입니다.\n- headers: 요청에 필요한 헤더입니다.\n- parameters: 인코딩 가능 프로토콜을 준수하는 요청 매개변수입니다.\n\nHTTPMethod Enum: 요청에 사용되는 다양한 HTTP 메서드를 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\nHTTPHeader Enum: 일반적인 HTTP 헤더 필드를 나타냅니다.\n\nContentType Enum: HTTP 헤더의 일반적인 콘텐츠 유형을 나타냅니다.\n\n# 단계 3: URLRequest 생성을 위해 NetworkRequest 확장\n\nNetworkRequest 프로토콜을 확장하여 URLRequest 객체를 생성하는 메서드를 포함시킵니다. 이 확장은 HTTP 헤더 및 매개변수 설정을 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nextension NetworkRequest {\n    func urlRequest() throws -> URLRequest {\n        guard let url = url else {\n            throw NetworkError.badURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = method.rawValue\n        \n        if let headers = headers {\n            for (key, value) in headers {\n                request.setValue(value, forHTTPHeaderField: key.rawValue)\n            }\n        }\n        \n        if let parameters = parameters {\n            if method == .get {\n                var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false)\n                let parameterData = try JSONEncoder().encode(parameters)\n                let parameterDictionary = try JSONSerialization.jsonObject(with: parameterData, options: []) as? [String: Any]\n                urlComponents?.queryItems = parameterDictionary?.map { URLQueryItem(name: $0.key, value: \"\\($0.value)\") }\n                request.url = urlComponents?.url\n            } else {\n                do {\n                    let jsonData = try JSONEncoder().encode(parameters)\n                    request.httpBody = jsonData\n                } catch {\n                    throw NetworkError.encodingFailed(error)\n                }\n            }\n        }\n        \n        return request\n    }\n}\n```\n\n해설:\n\nURLRequest 생성 메소드: NetworkRequest를 URLRequest 객체로 변환합니다.\n\n- 유효한 URL을 확인하고, 그렇지 않으면 badURL 오류를 발생시킵니다.\n- HTTP 메소드 설정합니다.\n- 제공된 헤더를 설정합니다.\n- 매개변수를 인코딩하고 설정합니다:\n\t- GET 요청의 경우, 매개변수를 쿼리 항목으로 추가합니다.\n\t- 다른 메소드의 경우, 매개변수를 JSON으로 인코딩하고 요청 본문으로 설정합니다.\n- 인코딩에 실패하면 encodingFailed 오류를 발생시킵니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 4: NetworkManager 구현\n\nNetworkManager는 네트워크 요청을 수행하고 응답을 처리하는 싱글톤 클래스입니다. 이 클래스는 역 호환성을 위해 async/await 및 completion handlers를 모두 지원합니다.\n\n# Async/Await 구현\n\n```js\nimport Foundation\nimport UIKit\n\nclass NetworkManager {\n    static let shared = NetworkManager()\n    private let urlSession = URLSession.shared\n    \n    private init() {}\n    \n    func perform<T: Decodable>(_ request: NetworkRequest, decodeTo type: T.Type) async throws -> T {\n        if #available(iOS 15.0, *) {\n            let urlRequest = try request.urlRequest()\n            let (data, response) = try await urlSession.data(for: urlRequest)\n            try processResponse(response: response)\n            return try decodeData(data: data, type: T.self)\n        } else {\n            return try await withCheckedThrowingContinuation { continuation in\n                perform(request, decodeTo: type) { result in\n                    switch result {\n                    case .success(let data):\n                        continuation.resume(returning: data)\n                    case .failure(let error):\n                        continuation.resume(throwing: error)\n                    }\n                }\n            }\n        }\n    }\n    \n    private func decodeData<T: Decodable>(data: Data, type: T.Type) throws -> T {\n        do {\n            let decodedObject = try JSONDecoder().decode(T.self, from: data)\n            return decodedObject\n        } catch let decodingError {\n            throw NetworkError.decodingFailed(decodingError)\n        }\n    }\n    \n    private func processResponse(response: URLResponse?) throws {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n        \n        switch httpResponse.statusCode {\n        case 200...299:\n            return\n        case 404:\n            throw NetworkError.notFound\n        case 500:\n            throw NetworkError.internalServerError\n        default:\n            throw NetworkError.unknownError(statusCode: httpResponse.statusCode)\n        }\n    }\n    \n    func downloadFile(from url: URL) async throws -> URL {\n        if #available(iOS 15.0, *) {\n            let (localURL, response) = try await urlSession.download(from: url)\n            try processResponse(response: response)\n            return localURL\n        } else {\n            return try await withCheckedThrowingContinuation { continuation in\n                downloadFile(from: url) { result in\n                    switch result {\n                    case .success(let localURL):\n                        continuation.resume(returning: localURL)\n                    case .failure(let error):\n                        continuation.resume(throwing: error)\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n설명:\n\nNetworkManager Singleton: 네트워크 요청을 수행하기 위한 단일 인스턴스를 제공합니다.\n\n- shared: 싱글톤 인스턴스입니다.\n- urlSession: 네트워크 작업을 위한 공유 URLSession 인스턴스입니다.\n- init(): 여러 인스턴스 생성을 방지하기 위한 비공개 이니셜라이저입니다.\n\nperform 메서드:\n\n<div class=\"content-ad\"></div>\n\n- iOS 15.0 이상인 경우:\n  - NetworkRequest에서 URLRequest를 생성합니다.\n  - 요청을 비동기적으로 처리합니다.\n  - 응답을 처리합니다.\n  - 응답 데이터를 지정된 유형으로 디코딩합니다.\n- 이전 iOS 버전의 경우:\n  - 완료 핸들러를 사용하여 요청을 처리하는 데 continuation을 사용합니다.\n\ndecodeData 메서드: 데이터를 지정된 유형으로 디코딩하고 디코딩에 실패하면 decodingFailed 오류를 throw합니다.\n\nprocessResponse 메서드: HTTP 응답을 유효성 검사하고 상태 코드에 따라 적절한 오류를 throw합니다.\n\ndownloadFile 메서드: 지정된 URL에서 파일을 다운로드하며 역호환성을 위해 async/await 및 완료 핸들러를 모두 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n# 완료 핸들러 구현\n\n오래된 iOS 버전을 위해 완료 핸들러를 사용하여 네트워크 요청을 구현합니다.\n\n```swift\nextension NetworkManager {\n    private func perform<T: Decodable>(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void) {\n        do {\n            let urlRequest = try request.urlRequest()\n            urlSession.dataTask(with: urlRequest) { data, response, error in\n                if let error = error {\n                    completion(.failure(.requestFailed(error)))\n                    return\n                }\n                \n                guard let data = data else {\n                    completion(.failure(.dataNotFound))\n                    return\n                }\n                \n                do {\n                    try self.processResponse(response: response)\n                    let decodedObject = try self.decodeData(data: data, type: T.self)\n                    completion(.success(decodedObject))\n                } catch {\n                    completion(.failure(error as? NetworkError ?? .invalidResponse))\n                }\n            }.resume()\n        } catch {\n            completion(.failure(error as? NetworkError ?? .invalidResponse))\n        }\n    }\n    \n    private func downloadFile(from url: URL, completion: @escaping (Result<URL, NetworkError>) -> Void) {\n        urlSession.downloadTask(with: url) { localURL, response, error in\n            if let error = error {\n                completion(.failure(.requestFailed(error)))\n                return\n            }\n            \n            guard let localURL = localURL else {\n                completion(.failure(.dataNotFound))\n                return\n            }\n            \n            do {\n                try self.processResponse(response: response)\n                completion(.success(localURL))\n            } catch {\n                completion(.failure(error as? NetworkError ?? .invalidResponse))\n            }\n        }.resume()\n    }\n}\n```\n\n설명:\n\n<div class=\"content-ad\"></div>\n\n완료 핸들러를 사용하여 perform 메소드:\n\n- URLRequest를 생성하고 URLSession.dataTask를 사용하여 요청을 수행합니다.\n- 오류를 처리하고 응답 유효성을 확인합니다.\n- 응답 데이터를 디코딩하고 결과로 완료 핸들러를 호출합니다.\n\n완료 핸들러를 사용하여 downloadFile 메소드:\n\n- URLSession.downloadTask를 사용하여 파일을 다운로드합니다.\n- 오류를 처리하고 응답 유효성을 확인합니다.\n- 다운로드된 파일의 로컬 URL로 완료 핸들러를 호출합니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 5: 이미지 다운로드 및 캐싱\n\n이미지 다운로드를 처리하고 선택적으로 캐싱하는 NetworkManager를 확장합니다.\n\n```js\nextension NetworkManager {\n    func downloadImage(from url: URL, cacheEnabled: Bool = true) async -> Result<UIImage, NetworkError> {\n        do {\n            if cacheEnabled, let cachedImage = try getCachedImage(for: url) {\n                return .success(cachedImage)\n            }\n            \n            let localURL = try await NetworkManager.shared.downloadFile(from: url)\n            let imageData = try Data(contentsOf: localURL)\n            if let image = UIImage(data: imageData) {\n                if cacheEnabled {\n                    cacheImage(imageData, for: url)\n                }\n                return .success(image)\n            } else {\n                return .failure(.decodingFailed(DecodingError(message: \"Failed to decode image data\")))\n            }\n        } catch {\n            return .failure(error as? NetworkError ?? .invalidResponse)\n        }\n    }\n    \n    private func cacheImage(_ imageData: Data, for url: URL) {\n        let cachedResponse = CachedURLResponse(response: HTTPURLResponse(url: url, statusCode: 200, httpVersion: nil, headerFields: nil)!, data: imageData)\n        URLCache.shared.storeCachedResponse(cachedResponse, for: URLRequest(url: url))\n        checkAndClearCache()\n    }\n    \n    private func checkAndClearCache() {\n        let cacheSize = URLCache.shared.currentDiskUsage\n        let cacheLimit: Int = 100 * 1024 * 1024 // 100 MB\n        if cacheSize > cacheLimit {\n            URLCache.shared.removeAllCachedResponses()\n        }\n    }\n    \n    private func getCachedImage(for url: URL) throws -> UIImage? {\n        if let cachedResponse = URLCache.shared.cachedResponse(for: URLRequest(url: url)),\n           let image = UIImage(data: cachedResponse.data) {\n            return image\n        }\n        return nil\n    }\n}\n```\n\n설명:\n\n<div class=\"content-ad\"></div>\n\n다음은 친절한 톤으로 번역한 내용입니다.\n\n\ndownloadImage 메서드: URL에서 이미지를 다운로드하며 선택적으로 캐싱합니다.\n\n- 캐싱이 활성화된 경우 먼저 캐시를 확인합니다.\n- async/await 또는 이전 iOS 버전을 위한 완료 핸들러를 사용하여 다운로드를 수행합니다.\n- 응답을 처리하고 이미지 데이터를 디코딩합니다.\n- 캐싱이 활성화된 경우 이미지를 캐시에 저장합니다.\n\ncacheImage 메서드: 이미지를 캐시에 저장합니다.\n\nloadImageFromCache 메서드: 캐시에서 이미지를 로드합니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 예시 사용법\n\n# API 호출 요청\n\n```js\nstruct ExampleAPIRequest: NetworkRequest {\n    var url: URL? {\n        return URL(string: \"https://api.example.com/data\")\n    }\n    var method: HTTPMethod {\n        return .get\n    }\n    var headers: [HTTPHeader: String]? {\n        return [.contentType: ContentType.json.rawValue]\n    }\n    var parameters: Encodable? {\n        return ExampleParameters(param1: \"value1\", param2: \"value2\")\n    }\n}\n\nstruct ExampleParameters: Encodable {\n    let param1: String\n    let param2: String\n}\n\nstruct ExampleData: Decodable {\n    let id: Int\n    let name: String\n}\n\nfunc fetchExampleData() async {\n    let request = ExampleAPIRequest()\n    \n    if #available(iOS 15.0, *) {\n        do {\n            let data: ExampleData = try await NetworkManager.shared.perform(request, decodeTo: ExampleData.self)\n            print(\"데이터 가져오기 성공: \\(data)\")\n        } catch {\n            print(\"데이터 가져오기 실패: \\(error)\")\n        }\n    } else {\n        NetworkManager.shared.perform(request, decodeTo: ExampleData.self) { result in\n            switch result {\n            case .success(let data):\n                print(\"데이터 가져오기 성공: \\(data)\")\n            case .failure(let error):\n                print(\"데이터 가져오기 실패: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n설명:\n\n<div class=\"content-ad\"></div>\n\n`ExampleAPIRequest Struct`: 네트워크 요청을 나타내며 `NetworkRequest` 프로토콜을 준수하는 구조체입니다.\n\n- URL, HTTP 메서드, 헤더 및 매개변수를 지정합니다.\n\n`ExampleParameters Struct`: `Encodable`을 준수하는 요청 매개변수를 나타내는 구조체입니다.\n\n`ExampleData Struct`: `Decodable`을 준수하는 응답 데이터를 나타내는 구조체입니다.\n\n<div class=\"content-ad\"></div>\n\n`table` 태그를 Markdown 형식으로 변경해주세요.\n\n\nfetchExampleData 함수: async/await를 활용하여 요청을 수행하고 응답을 처리하는 방법을 보여줍니다.\n\n# 이미지 다운로드\n\n```js\nimport SwiftUI\n\nstruct HomeView: View {\n    @State private var image: UIImage? = nil\n    \n    var body: some View {\n        VStack {\n            if let image = image {\n                Image(uiImage: image)\n                    .resizable()\n                    .aspectRatio(contentMode: .fit)\n                    .frame(width: 200, height: 200)\n            } else {\n                ProgressView()\n            }\n        }\n        .onAppear {\n            let imageURL = URL(string: \"https://picsum.photos/200/200\")!\n            Task {\n                let result = await NetworkManager.shared.downloadImage(from: imageURL, cacheEnabled: false)\n                switch result {\n                case .success(let success):\n                    self.image = success\n                case .failure(_):\n                    self.image = nil\n                }\n            }\n        }\n    }\n}\n\nstruct HomeView_Previews: PreviewProvider {\n    static var previews: some View {\n        HomeView()\n    }\n}\n```\n\n설명:\n\n\n<div class=\"content-ad\"></div>\n\nHomeView Struct는 URL에서 다운로드된 이미지를 표시하는 SwiftUI 뷰입니다.\n\n- 이미지 상태를 관리하기 위해 @State를 사용합니다.\n- 이미지를 로드하는 동안 ProgressView를 표시합니다.\n- appear될 때 async/await를 사용하여 이미지를 다운로드합니다.\n- 다운로드 결과를 처리합니다.\n\n# 파일 다운로드\n\n```js\nimport Foundation\n\nfunc downloadExampleFile() async {\n    let fileURL = URL(string: \"https://example.com/file.zip\")!\n    \n    if #available(iOS 15.0, *) {\n        do {\n            let localURL = try await NetworkManager.shared.downloadFile(from: fileURL)\n            print(\"다운로드한 파일 경로: \\(localURL)\")\n        } catch {\n            print(\"파일 다운로드 실패: \\(error)\")\n        }\n    } else {\n        NetworkManager.shared.downloadFile(from: fileURL) { result in\n            switch result {\n            case .success(let localURL):\n                print(\"다운로드한 파일 경로: \\(localURL)\")\n            case .failure(let error):\n                print(\"파일 다운로드 실패: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n설명:\n\ndownloadExampleFile 함수: async/await를 사용하여 파일을 다운로드하는 방법을 보여줍니다.\n\n- 이전 iOS 버전을 위한 async/await 및 완료 핸들러를 모두 지원합니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n이러한 네트워크 계층이 구현되면 iOS 애플리케이션이 API 요청을 처리하고 응답을 처리하며 파일 다운로드를 관리하는 데 더 잘 준비될 것입니다. 이 구조화된 접근 방식은 코드베이스를 더 깔끔하게 만들 뿐만 아니라 유지 보수가 용이하고 확장성이 뛰어난 장점을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaRobustNetworkLayeriniOSUsingSwift_0.png","tag":["Tech"],"readingTime":16},{"title":"Swift로 강력한 네트워크 레이어 만들기 파트 2","description":"","date":"2024-06-19 10:54","slug":"2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2","content":"\n\n<img src=\"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png\" />\n\n현대 iOS 개발에서는 API 호출 및 데이터 검색을 효율적이고 안전하게 처리하는 데 잘 구조화된 네트워크 레이어가 필수적입니다. 본 후속 기사에서는 SOLID 원칙을 준수하고 클래스 기반에서 구조체 기반으로 전환하여 네트워크 레이어를 개선하고 리팩터링한 내용을 안내해 드릴 것입니다. 이를 통해 코드베이스를 더 잘 유지보수할 수 있고 확장 가능하도록 보장할 것입니다.\n\n# 개요\n\n저희가 업그레이드한 네트워크 레이어에는 다음 구성요소가 포함되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- NetworkError: 다양한 네트워크 오류를 처리하기 위한 포괄적인 열거형입니다.\n- NetworkRequest: 네트워크 요청을 위한 필수 속성 및 메서드를 정의하는 프로토콜입니다.\n- HTTPResponseHandler: HTTP 응답을 처리하고 디코딩하는 프로토콜입니다.\n- NetworkEngine: 네트워크 요청 수행, 로깅 및 응답 처리를 담당하는 구조체입니다.\n\n이러한 구성 요소를 예제 API 호출과 함께 사용하는 방법을 보여드리겠습니다.\n\n# 단계 1: 네트워크 오류 정의\n\n먼저 NetworkError 열거형을 정의하여 다양한 네트워크 관련 오류를 깔끔하고 조직적으로 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport Foundation\n\nenum NetworkError: Error {\n    case badURL\n    case requestFailed(Error)\n    case invalidResponse\n    case dataNotFound\n    case decodingFailed(Error)\n    case encodingFailed(Error)\n    case notFound\n    case timeout\n    case internalServerError\n    case unknownError(statusCode: Int)\n}\n\nstruct DecodingError: Error {\n    let message: String\n}\n```\n\n해설:\n\n- NetworkError: 이 열거형은 네트워크 작업 중 발생할 수 있는 다양한 유형의 오류를 캡슐화합니다. 각 case는 특정 오류 시나리오를 나타냅니다:\n  - badURL: URL이 잘못되었음을 나타냅니다.\n  - requestFailed: 요청을 만드는 데 실패한 것을 나타내며 내장된 오류를 캡슐화합니다.\n  - invalidResponse: 응답이 유효하지 않음을 나타냅니다.\n  - dataNotFound: 응답에서 데이터를 찾을 수 없음을 신호합니다.\n  - decodingFailed: 응답 데이터를 해독하는 데 실패한 것을 나타내며 해독 오류를 캡슐화합니다.\n  - encodingFailed: 요청 매개변수를 인코딩하는 데 실패한 것을 나타내며 인코딩 오류를 캡슐화합니다.\n  - notFound: 요청한 리소스를 찾을 수 없음을 나타냅니다 (HTTP 404).\n  - timeout: 타임아웃 오류를 나타냅니다.\n  - internalServerError: 서버 오류임을 나타냅니다 (HTTP 500).\n  - unknownError: 다른 HTTP 상태 코드 오류를 나타내며 상태 코드를 캡슐화합니다.\n\nDecodingError: 해독 중 추가 오류 정보를 제공하기 위한 사용자 정의 오류 구조체입니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: NetworkRequest 프로토콜 생성하기\n\nNetworkRequest 프로토콜은 URL, HTTP 메소드, 헤더, 매개변수 및 타임아웃 간 필수적인 속성을 정의합니다.\n\n```js\nimport Foundation\n\nenum HTTPMethod: String {\n    case get = \"GET\"\n    case post = \"POST\"\n    case put = \"PUT\"\n    case delete = \"DELETE\"\n}\n\nenum HTTPHeader: String {\n    case contentType = \"Content-Type\"\n    case authorization = \"Authorization\"\n}\n\nenum ContentType: String {\n    case json = \"application/json\"\n    case xml = \"application/xml\"\n    case formUrlEncoded = \"application/x-www-form-urlencoded\"\n}\n\nprotocol NetworkRequest {\n    var url: URL? { get }\n    var method: HTTPMethod { get }\n    var headers: [HTTPHeader: String]? { get }\n    var parameters: Encodable? { get }\n    var timeoutInterval: TimeInterval { get }\n}\n\nextension NetworkRequest {\n    var timeoutInterval: TimeInterval {\n        return 30\n    }\n\n    func urlRequest() throws -> URLRequest {\n        guard let url = url else {\n            throw NetworkError.badURL\n        }\n        \n        var request = URLRequest(url: url)\n        request.httpMethod = method.rawValue\n        \n        if let headers = headers {\n            for (key, value) in headers {\n                request.setValue(value, forHTTPHeaderField: key.rawValue)\n            }\n        }\n        \n        if let parameters = parameters {\n            if method == .get {\n                var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false)\n                let parameterData = try JSONEncoder().encode(parameters)\n                let parameterDictionary = try JSONSerialization.jsonObject(with: parameterData, options: []) as? [String: Any]\n                urlComponents?.queryItems = parameterDictionary?.map { URLQueryItem(name: $0.key, value: \"\\($0.value)\") }\n                request.url = urlComponents?.url\n            } else {\n                do {\n                    let jsonData = try JSONEncoder().encode(parameters)\n                    request.httpBody = jsonData\n                } catch {\n                    throw NetworkError.encodingFailed(error)\n                }\n            }\n        }\n        \n        return request\n    }\n}\n```\n\n설명:\n\n<div class=\"content-ad\"></div>\n\n- HTTPMethod: 우리가 사용할 HTTP 메소드(GET, POST, PUT, DELETE)를 나타내는 enum입니다.\n- HTTPHeader: 일반적인 HTTP 헤더를 위한 enum입니다.\n- ContentType: HTTP 헤더에서 사용되는 일반적인 콘텐츠 유형을 위한 enum입니다.\n- NetworkRequest: 네트워크 요청에 필요한 속성을 정의하는 프로토콜입니다.\n  - url: 요청을 위한 URL입니다.\n  - method: 요청을 위한 HTTP 메소드입니다.\n  - headers: 요청에 대한 선택적 헤더입니다.\n  - parameters: 인코딩 가능한 형식을 준수하는 요청에 대한 선택적 매개변수입니다.\n  - timeoutInterval: 요청의 타임아웃 간격입니다.\n- 프로토콜 확장은 timeoutInterval의 기본 구현과 속성에서 URLRequest를 만들기 위한 urlRequest() 메소드를 제공합니다.\n  - 만약 메소드가 GET이면, 매개변수는 URL에 쿼리 아이템으로 추가됩니다.\n  - 다른 메소드의 경우, 매개변수는 JSON으로 인코딩되어 요청 바디에 추가됩니다.\n  - 헤더는 요청에 추가됩니다.\n\n# 단계 3: HTTPResponseHandler 구현하기\n\nHTTPResponseHandler 프로토콜은 HTTP 응답을 처리하고 디코딩하기 위한 메소드를 정의합니다.\n\n```js\nimport Foundation\n\npublic protocol HTTPResponseHandler {\n    func handleStatusCode(response: URLResponse?) throws\n    func decode<T: Decodable>(data: Data, to type: T.Type) throws -> T\n    func extractETag(from response: URLResponse?) -> String?\n}\n\nextension HTTPResponseHandler {\n    public func decode<T: Decodable>(data: Data, to type: T.Type) throws -> T {\n        do {\n            let decodedObject = try JSONDecoder().decode(T.self, from: data)\n            return decodedObject\n        } catch let decodingError {\n            throw NetworkError.decodingFailed(decodingError)\n        }\n    }\n\n    public func handleStatusCode(response: URLResponse?) throws {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            throw NetworkError.invalidResponse\n        }\n        \n        switch httpResponse.statusCode {\n        case 200...299:\n            return\n        case 404:\n            throw NetworkError.notFound\n        case 500:\n            throw NetworkError.internalServerError\n        default:\n            throw NetworkError.unknownError(statusCode: httpResponse.statusCode)\n        }\n    }\n\n    public func extractETag(from response: URLResponse?) -> String? {\n        guard let httpResponse = response as? HTTPURLResponse else {\n            return nil\n        }\n        return httpResponse.allHeaderFields[\"ETag\"] as? String\n    }\n}\n\npublic struct DefaultHTTPResponseHandler: HTTPResponseHandler {\n    public init() {}\n}\n```\n\n<div class=\"content-ad\"></div>\n\n설명:\n\n- HTTPResponseHandler: HTTP 응답을 처리하고 해독하는 메서드를 정의하는 프로토콜입니다.\n  - handleStatusCode(response:): HTTP 상태 코드를 확인하고 적절한 오류를 throw합니다.\n  - decode(data:to:): Decodable을 준수하는 특정 타입으로 데이터를 디코딩합니다.\n  - extractETag(from:): 응답 헤더에서 ETag을 추출합니다.\n\n이 확장(extension)은 다음을 제공합니다:\n\n- decode(data:to:)은 데이터를 디코딩하기 위해 JSONDecoder를 사용하고 실패할 경우 NetworkError.decodingFailed를 throw합니다.\n- handleStatusCode(response:)은 HTTP 상태 코드를 확인하고 공통 오류(404, 500)에 대해 특정 NetworkError 케이스를 throw하며, 다른 상태 코드에 대해서는 알 수 없는 오류를 throw합니다.\n- extractETag(from:)은 응답 헤더에서 ETag을 가져옵니다.\n- DefaultHTTPResponseHandler: HTTPResponseHandler의 구체적인 구현체입니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 4: NetworkEngine 구현\n\nNetworkEngine 구조체는 네트워크 요청을 수행하고 응답을 처리하는 역할을 담당합니다.\n\n```js\nimport Foundation\n\nstruct NetworkRequestContext<T: Decodable> {\n    let request: NetworkRequest\n    let type: T.Type\n    let completion: (Result<T, NetworkError>) -> Void\n    let requestInvokeTime: Date\n}\n\nprotocol NetworkEngineAdapter {\n    func invokeEngine<T: Decodable>(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void)\n}\n\npublic struct NetworkEngine {\n    private let urlSession: URLSession\n    private let logger: Logger\n    private let responseHandler: HTTPResponseHandler\n\n    public init(urlSession: URLSession = .shared,\n                logger: Logger = DefaultLogger(),\n                responseHandler: HTTPResponseHandler = DefaultHTTPResponseHandler()) {\n        self.urlSession = urlSession\n        self.logger = logger\n        self.responseHandler = responseHandler\n    }\n}\n\nextension NetworkEngine: NetworkEngineAdapter {\n    func invokeEngine<T>(_ request: NetworkRequest, decodeTo type: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void) where T: Decodable {\n        let requestInvokeTime = Date()\n        let context = NetworkRequestContext(request: request, type: type, completion: completion, requestInvokeTime: requestInvokeTime)\n        fetch(context)\n    }\n\n    private func fetch<T>(_ context: NetworkRequestContext<T>) where T: Decodable {\n        do {\n            var urlRequest = try context.request.urlRequest()\n            urlRequest.timeoutInterval = context.request.timeoutInterval\n\n            urlSession.dataTask(with: urlRequest) { data, response, error in\n                let requestFinishTime = Date()\n                let duration = requestFinishTime.timeIntervalSince(context.requestInvokeTime)\n                \n                logger.logMetrics(startTime: context.requestInvokeTime, endTime: requestFinishTime, duration: duration, request: urlRequest)\n                \n                if let error = error {\n                    context.completion(.failure(.requestFailed(error)))\n                    return\n                }\n                \n                guard let data = data else {\n                    context.completion(.failure(.dataNotFound))\n                    return\n                }\n                \n                do {\n                    try responseHandler.handleStatusCode(response: response)\n                    let decodedObject = try responseHandler.decode(data: data, to: context.type)\n                    context.completion(.success(decodedObject))\n                } catch let error as NetworkError {\n                    context.completion(.failure(error))\n                } catch {\n                    context.completion(.failure(.unknownError(statusCode: (response as? HTTPURLResponse)?.statusCode ?? -1)))\n                }\n            }.resume()\n        } catch {\n            context.completion(.failure(.requestFailed(error)))\n        }\n    }\n}\n```\n\n설명:\n\n<div class=\"content-ad\"></div>\n\n- NetworkRequestContext: 네트워크 요청의 컨텍스트를 캡슐화하는 구조체로, 요청 자체, 디코딩할 유형, 완료 핸들러, 그리고 요청이 호출된 시간을 포함합니다.\n- NetworkEngineAdapter: 네트워크 엔진을 요청과 함께 호출하고, 디코딩할 유형을 지정하며 완료 핸들러를 제공하는 메소드를 정의하는 프로토콜입니다.\n- NetworkEngine: 네트워크 작업을 수행하는 주요 구조체입니다:\n    - urlSession: 요청을 만드는 데 사용되는 URLSession 인스턴스입니다.\n    - logger: 메트릭 및 오류를 기록하기 위한 로거입니다.\n    - responseHandler: 응답 처리를 위한 HTTPResponseHandler의 인스턴스입니다.\n    - init: NetworkEngine을 urlSession, logger 및 responseHandler에 대한 옵션 매개변수로 초기화합니다.\n- invokeEngine 메소드는 NetworkRequestContext를 생성하고 fetch 메소드를 호출합니다.\n\nfetch 메소드:\n\n- NetworkRequest로부터 URLRequest를 만들려고 시도합니다.\n- 타임아웃 간격을 설정합니다.\n- urlSession.dataTask를 사용하여 네트워크 요청을 수행합니다.\n- 요청에 대한 메트릭을 기록합니다.\n- 오류, 누락된 데이터 및 상태 코드를 처리합니다.\n- 데이터를 디코딩하고 결과와 함께 완료 핸들러를 호출합니다.\n\n# 단계 5: 네트워크 레이어 사용하기\n\n<div class=\"content-ad\"></div>\n\n이 예시는 iOS에서 NetworkEngine을 사용하는 방법을 보여줍니다.\n\n## 네트워크 요청 정의하기\n\n먼저, NetworkRequest 프로토콜을 준수하는 PostService enum을 정의합니다. 이 enum은 네트워크 요청의 세부 사항을 캡슐화합니다.\n\n```swift\nimport Foundation\n\nenum PostService {\n    case fetchPosts\n}\n\nextension PostService: NetworkRequest {\n    var url: URL? {\n        switch self {\n        case .fetchPosts:\n            return URL(string: \"https://2e84f9d6-0dcb-4b93-9238-8b272604b4c1.mock.pstmn.io/v1/posts\")\n        }\n    }\n    \n    var method: HTTPMethod {\n        switch self {\n        case .fetchPosts:\n            return .get\n        }\n    }\n    \n    var headers: [HTTPHeader : String]? {\n        return [.contentType: ContentType.json.rawValue]\n    }\n    \n    var parameters: (any Encodable)? {\n        switch self {\n        case .fetchPosts:\n            return nil\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 PostService는 URL, HTTP 메서드, 헤더 및 요청에 대한 매개변수를 정의하는 단일 case fetchPosts를 갖습니다. 필요에 따라 더 추가할 수 있어요.\n\n## Repository 생성\n\n다음으로, NetworkEngine를 사용하여 요청을 실행할 repository 클래스를 만듭니다. 이 repository는 게시물을 가져오는 작업을 처리할 거에요:\n\n[연결](/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_1.png)\n\n<div class=\"content-ad\"></div>\n\n```swift\nprotocol PostsListRepositoryProtocol {\n  func fetchPostsList<T: Decodable>(with request: NetworkRequest, responseType: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void)\n}\n\nfinal class DefaultPostsListRepository: PostsListRepositoryProtocol {\n    private let engine: NetworkEngine\n    \n    init(engine: NetworkEngine = NetworkEngine()) {\n        self.engine = engine\n    }\n    \n    func fetchPostsList<T>(with request: NetworkRequest, responseType: T.Type, completion: @escaping (Result<T, NetworkError>) -> Void) where T : Decodable {\n        engine.invokeEngine(request, decodeTo: responseType, completion: completion)\n    }\n}\n```\n\n이 저장소에서 fetchPostsList 메서드는 NetworkRequest와 응답을 디코딩할 responseType을 사용합니다. NetworkEngine을 사용하여 요청을 실행하고 결과를 전달하기 위해 완료 핸들러를 호출합니다. 이 저장소를 직접 ViewModel이나 보기 UseCase에 사용할 수 있습니다.\n\n# 결론\n\n이 코드베이스의 네트워크 레이어 디자인은 모듈화, 확장 가능성, 견고한 오류 처리, 테스트 용이성 및 성능 모니터링을 강조하여 확장 가능한 애플리케이션에 적합합니다. 이러한 특성들은 유지 보수성과 신뢰성을 저해하지 않고 앱이 기능과 복잡성을 향상시킬 수 있음을 보장합니다.\n\n\n<div class=\"content-ad\"></div>\n\n더 많은 통찰과 업데이트를 원하시면 LinkedIn에서 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingaRobustNetworkLayerinSwiftPart2_0.png","tag":["Tech"],"readingTime":13},{"title":"파이썬에서 typingTYPE_CHECKING이 30초 안에 설명하기","description":"","date":"2024-06-19 10:53","slug":"2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds","content":"\n\n<img src=\"/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png\" />\n\n근무 중인 Python 코드베이스에서 이러한 코드 조각을 본 적이 있을 수 있습니다. 이 코드가 무슨 일을 하는지 궁금했던 적이 있다면, 오늘은 여기 있어서 설명해 드리겠습니다.\n\n# typing.TYPE_CHECKING은 그냥 False입니다\n\n```python\nfrom typing import TYPE_CHECKING\n\nprint(TYPE_CHECKING)\n\n# False\n```\n\n<div class=\"content-ad\"></div>\n\n일반적인 경우에는 TYPE_CHECKING 변수가 그냥 False로 설정되어 있습니다. 하지만 이 경우에 왜 사용하는 걸까요?\n\ntyping.TYPE_CHECKING은 정적 타입 체크(myppy 등)를 할 때 True로 설정된다고 가정됩니다.\n\n그러나 코드를 보통 실행할 때는 단순히 False입니다. 그러면 왜 이걸 사용하는 걸까요?\n\n# 경우 1 — 개 대 인간\n\n<div class=\"content-ad\"></div>\n\n여기에는 서로 가져오는 dog.py와 human.py가 있습니다.\n\n```python\n# dog.py\n\nfrom human import Human\n\nclass Dog:\n    def get_human() -> Human:\n      ...\n```\n\n```python\n# human.py\n\nfrom dog import Dog\n\nclass Human:\n    def get_dog() -> Dog:\n        ...\n```\n\n여기서 서로를 가져오는 순환 포함이 있다는 것을 주의하세요:\n\n<div class=\"content-ad\"></div>\n\n- dog.py에서 human.py를 가져오고\n- human.py에서는 dog.py를 가져옵니다\n\n그래서 dog.py나 human.py 또는 dog.py나 human.py를 가져오는 다른 Python 스크립트 중 하나를 실행하면 순환 임포트 오류가 발생합니다:\n\n```js\nImportError: cannot import name 'Human' from \npartially initialized module 'human' \n(most likely due to a circular import) \n```\n\n# Case 2 — Dog VS Human, but with TYPE_CHECKING\n\n<div class=\"content-ad\"></div>\n\nDog와 Human만 유형 주석에 필요하기 때문에 `-` Human과 `-` Dog와 같이 전체 클래스를 가져올 필요는 실제로 없습니다. 원형 가져오기 문제를 피하기 위해 다음 구문을 사용할 수 있습니다.\n\n```js\n# dog.py\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n  from human import Human\n\nclass Dog:\n    def get_human() -> \"Human\":\n      ...\n```\n\n```js\n# human.py\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n  from dog import Dog\n\nclass Human:\n    def get_dog() -> \"Dog\":\n        ...\n```\n\n여기에서 이전 코드에 몇 가지 변경 사항을 가했습니다.\n\n<div class=\"content-ad\"></div>\n\n- `typing`에서 `TYPE_CHECKING`을 import하는 부분을 추가했어요.\n- `TYPE_CHECKING` 조건문 아래에서 import 문들을 옮겼어요.\n- Dog와 Human 타입 어노테이션 주변에 따옴표를 추가했어요.\n\n그리고 코드를 실행해보면, 이제는 순환 import 문제가 없어졌어요.\n\n# 왜 순환 import 문제가 사라졌을까요?\n\n```js\ndef get_human() -> Human:\n```\n\n<div class=\"content-ad\"></div>\n\n위의 예제는 다음과 같이 변경되었습니다:\n\n```python\ndef get_human() -> \"Human\":\n```\n\n따라서 Python은 더 이상 human.py에서 실제 Human 클래스를 가져오려고 시도하지 않습니다 (이는 순환 임포트 문제를 발생시킵니다).\n\n# 그렇다면 TYPE_CHECKING이 왜 필요한가요?\n\n<div class=\"content-ad\"></div>\n\n큰 파이썬 프로젝트에서는 어쩌면 언젠가는 mypy와 같은 정적 타입 체커를 사용할 것입니다.\n\n정적 타입 체커를 실행할 때 typing.TYPE_CHECKING 변수를 True로 설정하고 실제로 클래스를 가져옵니다. (걱정 마세요 - 정적 타입 체커는 순환 Import 문제를 다른 방식으로 처리할 수 있습니다)\n\n하지만 코드를 보통 실행하고 정적 타입 체커를 다룰 필요가 없을 때는 실제 클래스를 가져올 필요가 없습니다.\n\n요컨대, TYPE_CHECKING이 추가된 이유는:\n\n<div class=\"content-ad\"></div>\n\n- 순환 가져오기 문제가 발생하지 않습니다 \n- 해당 스크립트를 실행할 때 정적 유형 검사를 여전히 제대로 수행할 수 있습니다 (원래 유형 주석을 제거할 필요가 없음)\n\n# 결론\n\n확실하고 이해하기 쉬웠기를 바랍니다.\n\n# 만약 제작자로서 저를 지원하고 싶다면\n\n<div class=\"content-ad\"></div>\n\n- 이 이야기에 대해 50번 박수를 쳐주세요\n- 생각을 말씀해 주시는 댓글을 남겨주세요\n- 이야기 중 가장 좋아하는 부분을 강조해주세요\n\n감사합니다! 이 작은 행동들이 큰 도움이 되고, 정말 감사드립니다!\n\nYouTube: https://www.youtube.com/@zlliu246\n\nLinkedIn: https://www.linkedin.com/in/zlliu/\n\n<div class=\"content-ad\"></div>\n\n제 Ebooks: [https://zlliu.co/ebooks](https://zlliu.co/ebooks)","ogImage":{"url":"/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png"},"coverImage":"/assets/img/2024-06-19-typingTYPE_CHECKINGinPythonExplainedin30Seconds_0.png","tag":["Tech"],"readingTime":3},{"title":"이 12개의 YouTube 채널로 12가지를 배워보세요","description":"","date":"2024-06-19 10:52","slug":"2024-06-19-Learn12ThingswithThese12YouTubeChannels","content":"\n\n<img src=\"/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png\" />\n\n새로운 것을 배우고 성장하고 싶으세요? 좋은 소식입니다! 유튜브를 시청하면 그것이 가능합니다! 여러분이 다양한 분야에서 도움을 받을 수 있는 12가지 멋진 채널을 소개합니다.\n\n- FreeCodeCamp: 코딩 배우기\n컴퓨터 프로그램을 만드는 방법을 배우고 싶다면 FreeCodeCamp를 확인해보세요. 초보자를 위한 쉬운 레슨과 전문가를 위한 더 어려운 것도 있습니다.\n- TED: 영감을 얻기\nTED는 다양한 주제에 대해 이야기합니다. 전 세계 사람들이 아이디어와 이야기를 나눕니다. 새로운 것을 배우고 영감을 받는 좋은 방법입니다.\n- Jeff Nippard: 피트니스 팁\n건강하고 강한 모습을 유지하는 것을 좋아한다면 Jeff Nippard가 도움이 될 것입니다. 운동 및 건강한 식습관에 대한 조언과 설명에는 과학적 근거가 포함되어 있습니다.\n- Veritasium: 재미있는 과학\nVeritasium은 과학을 즐겁게 합니다! 멋진 실험을 수행하고 어려운 것을 쉽게 설명합니다. 당신도 곧 과학 전문가가 될 거예요!\n- Charisma on Command: 더 매력적으로\n더 매력적이 되고 싶나요? Charisma on Command가 가르쳐 줍니다. 사람들이 당신을 좋아하게끔 말하고 행동하는 방법을 배우세요.\n- Miles Beckler: 디지털 마케팅 팁\nMiles Beckler은 디지털 마케팅을 이해하는 데 도움이 됩니다. 온라인 비즈니스를 키우고 싶다면, 그의 조언은 매우 유용할 수 있습니다.\n- Ahrefs: SEO 마스터\nAhrefs는 웹사이트를 검색 엔진에 표시하는 팁을 제공합니다. 복잡해 보일 수 있지만, 그들은 쉽게 이해할 수 있게 설명해줍니다.\n- Khan Academy: 모든 것 배우기\nKhan Academy는 다양한 주제에 대한 무료 레슨을 제공합니다. 컴퓨터에 교사가 있는 것처럼 느껴집니다. 모든 연령층에게 좋습니다!\n- Mindvalley: 개인적으로 성장하기\nMindvalley는 자신을 더 나아지게 하는 것에 대한 모든 것입니다. 영적 성장, 생산성 및 기타 도움이 되는 주제에 대해 배웁니다.\n- Athlean-X: 건강하고 강해지기\n건강하고 강해지고 싶다면 Athlean-X가 가야할 곳입니다. Jeff Cavaliere가 운동 및 훈련에 대한 전문적인 조언을 제공합니다.\n- Nerdwriter1: 깊이 생각하기\nNerdwriter1은 예술과 문화에 대해 간단히 이야기합니다. 흥미로운 것을 설명해주는 현명한 친구가 당신에게 흥미로운 것을 설명해줍니다.\n- Vsauce: 재미있는 사실 배우기\nVsauce는 흥미로운 질문에 재미있게 대답합니다. 멋진 사실을 배우며 즐길 수 있습니다.\n\n이 유튜브 채널들은 여러분만의 교사와 멘토가 있는 것과 같습니다. 그러니 편히 앉아서 배우고 성장하는 여정을 시작해보세요!\n\n<div class=\"content-ad\"></div>\n\n이 글을 읽어 주셔서 감사합니다! 🙏😊","ogImage":{"url":"/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png"},"coverImage":"/assets/img/2024-06-19-Learn12ThingswithThese12YouTubeChannels_0.png","tag":["Tech"],"readingTime":2},{"title":"잘 검토할 수 있는 풀 리퀘스트를 만드는 방법","description":"","date":"2024-06-19 10:51","slug":"2024-06-19-HowICreateEasy-to-ReviewPullRequests","content":"\n\n## 생산성 | 프로그래밍 | 혁신\n\n![이미지](/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png)\n\n리뷰하기 쉬운 풀 리퀘스트(Pull Requests)를 작성하면 머지 프로세스가 빨라집니다. 머지 속도를 높이면 비즈니스 진행 속도와 제품 품질 향상 속도가 빨라집니다.\n\n그러므로, 리뷰하기 쉬운 풀 리퀘스트를 만드는 것이 매우 중요하다고 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n## 1. 변경된 파일이 너무 많습니까?\n\n풀 리퀘스트를 생성하기 전 (또는 구현하기 전) 확인해야 할 사항 중 하나는 작업의 세분성입니다. 작업의 세분성이 너무 크면 한 번의 풀 리퀘스트에서 변경된 파일의 수가 증가하여 리뷰어의 작업 부담이 커집니다. 변경된 파일의 수가 10개를 초과하면 해당 기능을 분할할 수 있는지 다시 고려하게 됩니다.\n\n하나의 기능을 모두 한 번에 풀 리퀘스트에 들어가게 하기보다는 작업을 분할하고 개별적으로 릴리스할 수 있는 단위로 풀 리퀘스트를 그룹화하는 것이 리뷰어의 작업 부담을 줄일 수 있습니다. 따라서 작업을 세분화하여 리뷰하기 쉬운 풀 리퀘스트를 생성하는 것이 중요하다고 생각합니다.\n\n## 2. 요약 섹션 강화하기\n\n<div class=\"content-ad\"></div>\n\n가장 중요한 것은 풀 리퀘스트 요약 섹션을 개선하는 것이라고 생각해요. 리뷰에 필요한 모든 정보를 요약 섹션에 모아두는 걸 염두에 두고 있어요.\n\n일부 내용은 디자인 제안서 링크와 같은 것들이 명세를 요약한 계획 문서와 중복되지만, 풀 리퀘스트의 요약 섹션에 요약함으로써 전환을 쉽게하고 리뷰 시간을 줄일 수 있다고 생각해요. 구체적으로는 다음 내용을 포함하고 있어요.\n\n- 기능이 필요한 배경\n- 작업 세부 내용\n- 작동 확인된 항목\n- 구현 영향 범위\n- 구현하는 동안 고민했던 포인트\n- 스크린샷 (디자인 변경이 있는 경우)\n- 다양한 링크\n- 작업 티켓 링크\n- 계획 문서 링크\n- 명세를 논의하는 채팅이 있다면 링크 제공\n- Figma와 같은 디자인 아이디어 링크\n\n또한 팀 내에서 템플릿을 만들고 해당 항목에 따라 만드는 것도 중요하다고 생각해요.\n\n<div class=\"content-ad\"></div>\n\n## 3. 리뷰 요청하기 전 자가 검토\n\n리뷰 요청을 하기 전에 자가 검토를 하는 것이 중요합니다. 요약 섹션이 이해하기 쉬운지, 팀의 코딩 규칙을 위반하는 부분이 있는지, 영향 범위 내의 빠뜨린 부분이 있는지 다시 한번 확인할 것입니다.\n\n자가 검토 항목을 준비하고 이전 리뷰에서 받았던 동일한 코멘트를 받지 않도록 주의하고 있습니다. 리뷰를 요청하기 전에 자가 검토를 실시함으로써 구현 중에 보지 못했던 실수를 알 수 있고 더 나은 구현 방법을 발견할 수 있습니다.\n\n자가 검토를 실시함으로써 리뷰를 요청하기 전 리드 타임은 조금 더 길어지지만 그 결과로 리뷰어의 부담이 줄어들고 리뷰해야 할 영역에 집중할 수 있습니다. 우리는 자가 검토를 중요시합니다.\n\n<div class=\"content-ad\"></div>\n\n내 자기평가 항목 중 일부를 소개하고 싶어요. 이것은 어떤 사람들은 너무 자명해서 확인할 필요가 없다고 생각할 수 있는 항목이라고 생각해요. 그러나 두려움이나 긴장 상태일 때는 이런 중요한 항목도 놓치기 쉬우니, 리뷰를 제출하기 전에 이 항목들을 한 번 확인해요.\n\n## 코드 확인\n\n- 라우팅 추가 부분은 ABC 순서로 정리되어 있나요?\n- 스키마 파일에 추가된 열은 응집력을 고려하여 정렬되었나요?\n- 업데이트나 저장과 같은 레코드 저장 메서드는 save!나 update!와 같은 예외를 일으키는 방식으로 사용되었나요?\n- N + 1 문제가 있나요?\n\n## 코드 이외의 확인할 사항\n\n<div class=\"content-ad\"></div>\n\n- 파일 변경 사항이 너무 많나요? 10개 이상의 파일이 있는 경우 주의하세요.\n- 풀 리퀘스트를 생성할 때 자신을 할당했나요?\n- 중요한 디자인 변경 사항이 포함된 작업의 경우, 스마트폰 또는 PC 화면뿐만 아니라 태블릿 화면에서도 표시를 확인했나요? (화면 캡처도 함께 첨부해야 합니다)\n\n## 개요\n\n이번에는 '리뷰하기 쉬운 풀 리퀘스트를 제출하는 방법'이라는 제목의 기사를 작성했습니다. 작업의 세분화, 요약 및 자가 검토는 특별한 일이 아니며, 모두 당연한 것으로 여겨질 수 있습니다.\n\n그러나 저는 보통의 일을 철저히 하는 것이 중요하다고 믿습니다. 비즈니스 성장 속도를 높이기 위해, 계속해서 리뷰하기 쉬운 풀 리퀘스트를 작성할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 스택아데믹\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 응원하고 팔로우해 주시면 감사하겠습니다! 👏\n- 저희를 팔로우해 주세요! X | LinkedIn | YouTube | Discord\n- 다른 플랫폼에서도 만나보세요: In Plain English | CoFeed | Venture","ogImage":{"url":"/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png"},"coverImage":"/assets/img/2024-06-19-HowICreateEasy-to-ReviewPullRequests_0.png","tag":["Tech"],"readingTime":3}],"page":"26","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}