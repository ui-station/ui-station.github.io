{"pageProps":{"posts":[{"title":"맵핑 대 이터러블 맵핑 간단히 해석하기","description":"","date":"2024-05-27 16:20","slug":"2024-05-27-MappingsvsIterableMappingsSimplified","content":"\n\n안녕하세요! 모두들! 저는 모든 것을 간단하게 만들어 설명해드릴게요. 데이터 구조가 어떻게 작동하는지 설명하는 글이 정말 많죠. 하지만 여기서는 조금 더 쉽게 설명할 거에요. 이 글을 끝까지 읽어보시면 제대로 이해하실 거에요. 확실해요💯.\n\n![이미지](/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png)\n\n# 표준 Mapping\n\nMappings이 뭔가요? 하하, 제가 어이가 없네요! Solidity에서의 Mappings은 간단한 전화번호부와 같아요. 사람의 이름을 통해 전화번호를 찾을 수 있지만, 전화번호를 통해 이름을 찾을 수는 없어요. (Mapping이라고 말할 때는 표준 Mapping을 의미합니다 😉) 지금쯤 완전 쉽다고 생각하셨을 거예요. 그래요, 이렇게 말해볼게요:\n\n<div class=\"content-ad\"></div>\n\n매핑은 Solidity에서 키-값 데이터 구조입니다. 고유한 키를 기반으로 값을 저장하고 검색할 수 있습니다. 주로 고유한 이더리움 주소와 다양한 값 유형을 연결하는 데 사용되어, 스마트 계약에서 데이터를 관리하는 데 필수적인 도구입니다.\n\n# 매핑의 종류\n\n간단한 매핑:\n\n간단한 매핑의 예제를 살펴봅시다. 이곳에서는 이더리움 주소와 해당 잔액 간의 연결을 만들고 있습니다. 이를 \"잔액(balances)\"이라는 매핑으로 부르겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n매핑 :address => uint) public balances;\n```\n\n<img src=\"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_1.png\" />\n\n컨트랙트인 SimpleMapping을 살펴보겠습니다.\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ncontract SimpleMapping {\n    mapping(address => uint) public balances;\n\n    function setBalance(address _user, uint _balance) public {\n        balances[_user] = _balance;\n    }\n\n    function getBalance(address _user) public view returns (uint) {\n        return balances[_user];\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n아래는 배포된 계약의 스크린샷입니다. 'setBalance' 함수를 호출할 때 이더리움 주소와 해당 잔고를 제공했습니다. 'getBalance'에서는 그 이더리움 주소의 잔고를 검색했습니다.\n\n![contract-screenshot](/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_2.png)\n\nSolidity에서 매핑을 선언할 때 주의할 점:\n\n- 사실상 두 값 사이의 연결을 만드는 것입니다.\n- 매핑에서 키를 사용하여 해당 값을 찾을 수 있지만, 역은 찾을 수 없습니다. 즉, 값을 사용하여 키를 찾을 수는 없습니다.\n\n<div class=\"content-ad\"></div>\n\n중첩 매핑:\n\n이제 중첩 매핑에 대해 알아보겠습니다. 두 개의 이더리움 주소와 불리언 값 사이의 링크를 생성 중입니다. 불리언 값이 true이면, 두 주소는 관련이 있습니다.\n\n```js\nmapping(address => mapping(address => bool)) public isRelated;\n```\n\n<img src=\"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_3.png\" />\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 아래는 'NestedMapping' 계약에 대한 정보입니다.\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ncontract NestedMapping {\n    mapping(address => mapping(address => bool)) public isRelated;\n\n    function setRelationship(address _user1, address _user2, bool _isRelated) public {\n        isRelated[_user1][_user2] = _isRelated;\n    }\n\n    function checkRelationship(address _user1, address _user2) public view returns (bool) {\n        return isRelated[_user1][_user2];\n    }\n}\n```\n\n배포된 계약의 스크린샷을 아래에서 확인할 수 있습니다. 'setRelationship' 함수를 사용하여 두 이더리움 주소 및 false 값을 제공하였습니다. 'checkRelationship' 함수에서 해당 중첩 매핑의 부울 값을 검색하였습니다.\n\n![매핑 이미지](/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_4.png)\n\n<div class=\"content-ad\"></div>\n\n또한 중첩된 매핑의 경우:\n\n- 순서가 중요합니다.\n- _user1에 값 설정 후 _user2에 값 설정하는 것은 자동으로 _user2에 값 설정 후 _user1에 값 설정하는 것을 의미하지 않습니다.\n\n# 반복 가능한 매핑\n\n반복 가능한 매핑이란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n반복 가능한 매핑은 모든 이름과 전화번호를 나열할 수 있는 향상된 전화번호부와 같습니다. 이름으로 전화번호를 찾을 수는 있지만 모든 항목을 하나씩 차례대로 확인할 수도 있습니다.\n\n주요 포인트:\n\n- 양방향 상호작용: 키로 값을 찾거나 모든 키를 나열할 수 있습니다.\n- 더 많은 제어: 보다 복잡한 작업을 수행할 수 있습니다. 예를 들어 보고서 생성이나 모든 항목에 대한 작업 수행 등이 가능합니다.\n\n예시:\n\n<div class=\"content-ad\"></div>\n\n```js\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ncontract IterableMapping {\n    \n    mapping(address => uint) private balances;\n    \n    address[] private keys;\n   \n    mapping(address => bool) private isKey;\n    \n    function setBalance(address _user, uint _balance) public {\n        if (!isKey[_user]) {\n            keys.push(_user);\n            isKey[_user] = true;\n        }\n        balances[_user] = _balance;\n    }\n   \n    function getBalance(address _user) public view returns (uint) {\n        return balances[_user];\n    }\n    \n    function getAllKeys() public view returns (address[] memory) {\n        return keys;\n    }\n}\n```\n\n배포된 스마트 계약의 스크린샷이 아래에 있습니다. ‘getAllKeys’ 함수를 호출했습니다. 현재 ‘keys’ 배열에 저장된 모든 키를 반환해야 합니다. 이는 Iterable Mapping을 사용하여 가능한 내용 중 하나에 불과합니다… 모두 나열했습니다.\n\n<img src=\"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_5.png\" />\n\n# 왜 Iterable Mappings를 사용해야 하는가?\n\n<div class=\"content-ad\"></div>\n\n- 모든 것 나열하기: 모든 항목을 보고 싶을 때 반복 가능한 매핑을 사용할 수 있어요. 예를 들어, 모든 토큰 소지자를 나열하는 경우입니다.\n- 복잡한 작업: 모든 항목에 작업을 수행할 수 있도록해주어, 모든 사용자에게 보상을 분배하는 것과 같은 작업을 수행할 수 있어요.\n\n각각을 사용하는 시점:\n\n- 표준 매핑: 간단하고 빠른 조회가 필요하며 모든 항목을 나열할 필요가 없는 경우에 사용하세요. 예를 들어, 사용자의 잔고를 확인하는 경우입니다.\n- 반복 가능한 매핑: 모든 항목을 나열하거나 관리해야 할 때 사용하세요. 예를 들어, 모든 사용자의 잔액을 처리하는 경우입니다.\n\n# 비교 요약\n\n<div class=\"content-ad\"></div>\n\n<table> 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해 주세요!","ogImage":{"url":"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png"},"coverImage":"/assets/img/2024-05-27-MappingsvsIterableMappingsSimplified_0.png","tag":["Tech"],"readingTime":5},{"title":"한 줄의 코드로 Python 함수를 데코레이터로 바꿔보세요","description":"","date":"2024-05-27 16:18","slug":"2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode","content":"\n\n![이미지](/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png)\n\n데코레이터를 작성하고 싶지만 구문을 기억하지 못하시나요? 데코레이터는 많은 보일러플레이트 코드가 포함된 꽤 어려운 구문을 갖고 있습니다. 이 기사에서는 데코레이터를 작성하는 더 간단한 방법을 소개합니다. 이 새로운 방법은 훨씬 더 짧고 명확하며 가독성이 뛰어날 것입니다. 함께 코딩해봅시다!\n\n# 데코레이터 작성의 기본 방법\n\n아래 코드는 데코레이터를 생성하는 기본 방법입니다. 데코레이터로 래핑된 함수가 실행되는 시간을 측정합니다. 깊이 파고든 이 기사를 확인해보세요.\n\n\n<div class=\"content-ad\"></div>\n\n\ndef timer(name:str) -> Callable:\n    def decorator(func:Callable) -> Callable:\n        @wraps(func)\n        def decorator_implementation(*args, **kwargs):\n            try:\n                print(f\"TIMER:   {name} start\")\n                strt = time.perf_counter()\n                return func(*args, **kwargs)\n            finally:\n                print(f\"TIMER:   {name} finished in {time.perf_counter() - strt}\")\n        return decorator_implementation\n    return decorator\n\n\n이렇게 하면 코드를 다음과 같이 사용할 수 있습니다:\n\n```js\n@timer(name=\"test\")\ndef my_func(name:str, age:int) -> str:\n    return f\"{name} is {age} years old\"\n\nmy_func(name=\"mike\", age=34)\n# TIMER:   test start\n# mike is 34 years old\n# TIMER:   test finished in 5.299999999998532e-06\n```\n\n## 이 접근 방식의 문제점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n저는 개발자이며 개인적으로 데코레이터를 작성하는 방법을 항상 기억하지 못하고 이전 프로젝트에서 코드를 복사하여 붙여넣어야 합니다. 이는 3개의 중첩된 함수가 포함된 약간 읽기 어려운 구문 때문에 데코레이터를 이해하기 어렵게 만들기 때문이라고 생각합니다. 우리는 이를 어떻게 단순화할 수 있는지 알아보겠습니다.\n\n# 데코레이터를 작성하는 더 쉬운 방법\n\n아래 구현은 이전 섹션의 데코레이터와 정확히 동일한 작업을 하지만 한 가지 함수만 사용합니다. 이는 훨씬 더 읽기 쉽고 @contextmanager 데코레이터를 추가하고 함수를 생성기로 변환하는 것으로 처리됩니다.\n\n```python\n@contextmanager\ndef timer(name:str) -> Generator:\n    try:\n        print(f\"TIMER:   {name} start\")\n        strt = time.perf_counter()\n        yield\n    finally:\n        print(f\"TIMER:   {name} finished in {time.perf_counter() - strt}\")\n```\n\n<div class=\"content-ad\"></div>\n\n모두 같은 방식으로 함수를 사용할 수 있어요:\n\n```js\n@timer(name=\"AS DEC\")\ndef my_func(name:str, age:int) -> str:\n    return f\"{name}은(는) {age}살이야\"\n\n\nmy_func(name=\"마이크\", age=34)\n# TIMER:   AS DEC 시작\n# 마이크은(는) 34살이야\n# TIMER:   AS DEC 5.399999999995686e-06초 내에 완료됨\n```\n\n## 컨텍스트 매니저로서의 기능\n\n개인적으로 새로운 함수가 더 읽기 쉽고 이해하기 쉽다고 생각해요. 몇 가지 간단한 변경이 필요하지만 그만큼 다양한 기능을 제공해요. 함수에 데코레이터를 적용하는 것이 훨씬 쉬워지고 데코레이터 함수(예: 위의 timer)를 데코레이터 및 컨텍스트 매니저로 모두 사용할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n타이머와 함께(context manager와 함께)\n\n우리는 동일한 데코레이터 함수를 데코레이터 및 context-manager로도 사용할 수 있습니다.\n\n```js\nas ctx라는 이름의 타이머와 함께:\n    fn_with_ctx_decorator(name=\"john\", age=42)\n    print(\"컨텍스트 매니저 내부\")\n\n# 타이머:  as ctx 시작\n# 타이머:  AS DEC 시작\n# john은 42살입니다\n# 타이머:  AS DEC가 3.7000000000023126e-06초에 완료되었습니다\n# 컨텍스트 매니저 내부\n# 타이머:  as ctx가 3.0000000000002247e-05초에 완료되었습니다\n```\n\n\n\n<div class=\"content-ad\"></div>\n\n# 어떻게 작동합니까?\n\n내부적으로 contextlib은 @contextmanager를 사용하여 우리의 데커레이터 함수를 감싸서 데커레이터와 컨텍스트 매니저 역할을 하는 객체로 만들어줍니다. 이 작업 방식은 꽤 기술적이고 매우 흥미로우며 독립된 기사가 필요합니다. 계속 따라와주세요!\n\n이 기사의 범위에서는 contextlib이 @contextmanager 데코레이터를 사용하여 데커레이터 함수를 데커레이터와 컨텍스트 매니저로 모두 사용할 수 있는 객체로 변환한다는 것만 알면 됩니다.\n\n## 단점\n\n<div class=\"content-ad\"></div>\n\n새 데코레이터는 많은 기능을 제공하지만 몇 가지 단점이 있습니다. 그 중 가장 중요한 것은 데코레이터 함수 내에서 실제로 데코레이션하는 함수에 액세스할 수 없다는 점입니다. 또한 해당 함수의 args와 kwargs에 액세스할 수도 없습니다. 이로 인해 이러한 변수를 수정할 수 없지만 제 생각에는 이를 드물게 해야 하는 것입니다.\n\n두 번째 단점은 데코레이터 함수가 제너레이터 함수여야 한다는 점입니다. 이는 해당 함수가 본문에서 어딘가에 yield해야 한다는 의미입니다. 이로 인해 코드를 다시 작성해야 할 수도 있습니다.\n\n# 결론\n\n@contextmanager를 사용하면 데코레이터를 쉽고 가독성있게 작성할 수 있습니다. 많은 쓰기 장치를 처리해주며 심지어 콘텍스트 매니저 역할도 수행합니다. 그러나 이 자동화와 \"하드코딩된 마법\"으로 인해 함수와 인수에 액세스할 수 있는 제어를 일부 상실하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\ncontextlib은 내부에서 작동하는 방식이 상당히 복잡하며 별도의 기사가 필요하므로 관심이 있다면 저를 따라오세요!\n\n이 기사가 제가 희망하는 대로 명확하게 전달되었기를 바라지만, 그렇지 않은 경우 추가 설명이 필요하다면 알려주세요. 그동안 다른 주제들에 대한 제 다른 기사들도 확인해보세요:\n\n- 절대 초보자를 위한 Git: 비디오 게임의 도움으로 Git 이해하기\n- 나만의 Python 패키지 작성 및 게시\n- FastAPI를 사용해 5줄의 코드로 빠르고 자동 문서화되고 유지보수 가능한 쉽게 사용할 수 있는 Python API 만들기\n\n즐거운 코딩 되세요!\n\n<div class=\"content-ad\"></div>\n\n- Mike\n\nP.S: 제 하는 일 좋아하시나요? 제 팔로우 해주세요!\n\n","ogImage":{"url":"/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png"},"coverImage":"/assets/img/2024-05-27-TurnYourPythonFunctionintoaDecoratorwithOneLineofCode_0.png","tag":["Tech"],"readingTime":4},{"title":"단위 테스트보다 통합 테스트를 선호하여 정확성 확인하기","description":"","date":"2024-05-27 16:17","slug":"2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness","content":"\n\n![unit test image](/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png)\n\n저는 전문적인 코딩을 시작한 이후로 단위 테스트를 작성해 왔어요. 그 속에는 특별한 \"영감\"이 있죠. 다른 개발자가 여러분의 코드를 사용해야 한다는 점을 생각하게 만들어요.\n\n그 \"다른 개발자\"가 바로 여러분의 미래 자신이기도 해요.\n\n단위 테스트를 작성할 때마다, 정확성을 검증할 뿐만 아니라 클래스의 작업 편의성도 평가하려고 해요. 좋은 코드를 작성하는 중요한 측면 중 하나는 함께 작업하기 즐거운 코드를 작성하는 것이라고 생각해요.\n\n\n<div class=\"content-ad\"></div>\n\n그러나 전반적인 시스템의 정확성을 검증하는 것은 단위 테스트가 갖고 있지 않은 특징입니다.\n\n단위 테스트를 작성하는 데 드는 비용은 매우 적습니다. 기대되는 결과를 빠르게 작성, 실행 및 확인할 수 있습니다. 그러나 다른 측면에서도 저렴하다고 할 수 있습니다. 단위 테스트는 실제로 발생할 수 있는 프로덕션에서 발생할 수 있는 버그를 잡는 데는 거의 충분하지 않습니다.\n\n🔔 이와 유사한 기사를 더 보고 싶으시면 여기에서 가입하세요.\n\n매우 제어된 상황에서 고립된 상태로 작동하는 것을 본다는 것은 여러 협업 객체, 다양한 사용 사례 등이 포함된 더 큰 환경에서 작동하는 것을 보는 것과는 전혀 다릅니다.\n\n<div class=\"content-ad\"></div>\n\n의존성을 경멸하는 것은 재앙의 길이 될 수 있습니다. 그리고 내 경험상, 데이터베이스와의 상호 작용을 모의하는 경우에는 특히 그렇습니다.\n\n이 유닛 테스트를 분석해 보세요. 우리는 \"UserManager\"를 통해 사용자를 저장하는 것을 확인하려고 합니다.\n\n```js\n[Fact]\npublic void SaveNewUser()\n{\n   // Arrange\n   var repository = Substitute.For<IUserRepository>();\n\n\n   var user = new User();\n   var sut = new UserManager(repository);\n\n   // Act\n   sut.SaveUser(user);\n\n   // Assert\n   repository.Received(1).SaveUser(Arg.Any<User>());\n}\n```\n\n이것은 투명하고 화이트박스 테스트입니다. UserManager는 실제 저장을 협력자 \"IUserRepository\"에 위임하고 있으며, \"UserManager\"가 \"SaveUser\" 메서드를 호출하는지 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n이는 아무 것도 테스트하지 않는 종류의 단위 테스트입니다. 아무 것도 확인하지 않으며 확신을 줄 수도 없습니다.\n\n우리는 모든 것이 잘되도록 하려는 중입니다.\n\n이러한 테스트는 무언가를 확실히 해서 빌드 서버에서 코드 품질 단계를 통과시키는 임의의 코드 커버리지 목표를 충족하는 데로 인해 우리를 기분 좋게 만들어 줍니다. 하지만 실제로는 일이 잘 되고 있다는 빈 약속일 뿐입니다.\n\n만약 당신의 코드베이스에 제가 방금 보여준 것과 유사한 테스트가 있다면, 그것은 당신에게 큰 문제가 있을 수 있다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n위의 \"사용자\" 테이블이 이렇게 생겼다고 가정해 봅시다.\n\n```js\n-- PostgreSQL\nCREATE TABLE \"Users\" (\n   \"Id\" uuid NOT NULL,\n   \"Name\" text NOT NULL,\n\n   -- 그리고 다른 많은 열들\n\n   CONSTRAINT \"PK_Users\" PRIMARY KEY (\"Id\")\n);\n```\n\n그럼 \"Id\"나 \"Name\"이 없이 만들어진 사용자를 저장하려고 하면 예외가 발생하게 되어, 모든 것이 정상적으로 작동되고 있다고 생각하는 것을 방지할 수 있습니다.\n\n```js\nvar user = new User(); // 저장되지 않아야 함\n```\n\n<div class=\"content-ad\"></div>\n\n이것은 분명히 클래스와 협력자 간의 상호 작용이 매우 적은 간단한 예제입니다. 그러나 단위 테스트에 무작정 의존하는 함정을 보여줍니다.\n\n🔔 이와 유사한 기사를 더 보시려면 여기에서 가입하세요.\n\n프로페셔널 소프트웨어 개발의 여러 해를 거친 후, 무언가를 모킹할 때 항상 그 테스트를 단위 테스트로 유지해야 하는지 아니면 통합 테스트로 승격해야 하는지 신중하게 생각하는 시간을 가집니다.\n\n이제 이 전환된 테스트와 이 통합 테스트를 대조해 보세요.\n\n<div class=\"content-ad\"></div>\n\n```csharp\npublic class UserManagerShould(DatabaseFixture fixture) : IClassFixture<DatabaseFixture>\n{\n  [Fact]\n  public async Task SaveNewUser()\n  {\n     // Arrange\n     UserDbContext context = new TestDbContextFactory(fixture.ConnectionString)\n         .CreateDbContext(null!);\n\n     await context.Database.EnsureCreatedAsync();\n     await context.Users.ExecuteDeleteAsync();\n\n     var repository = new EfUserRepository(context);\n\n     var user = new User();\n     var sut = new UserManager(repository);\n\n\n     // Act\n     sut.SaveUser(user);\n\n     // Assert\n     List<User> result = context.Users\n         .AsNoTracking()\n         .ToList();\n\n     result.Should()\n           .HaveCount(1);\n  }\n}\n```\n\n이 테스트는 우리 시스템이 프로덕션에서 수행할 작업을 정확히 모방합니다. 이 테스트는 픽스처와 PostgreSQL 도커 컨테이너가 하나의 테스트를 위해 실행됩니다.\n\n이제 \"SaveUser(user)\" 메서드를 호출하면 실제 데이터베이스에 삽입이 수행되며, 사용자에게 이름이 없기 때문에 오류가 발생합니다: Npgsql.PostgresException 23502: null value in column \"Name\" of relation \"Users\" violates not-null constraint.\n\n실제로 잘못된 상황에서 오류가 발생하는 이러한 테스트는 사용자를 저장하기 전에 추가적인 확인 절차를 수행해야 함을 알려줍니다.\n\n\n\n<div class=\"content-ad\"></div>\n\n테스트 실패는 우리에게 대응을 촉발시킵니다. 이 경우 UserManager의 SaveUser(user) 메서드에 가드 절을 추가하여 사용자가 유효한 상태에 있는지 확인하십시오.\n\n# 요약하자면...\n\n테스트는 시스템이 작동한다는 확신을 주어야 하며, 단순히 통제된 실험실 조건에서 각 부분이 작동하는 것만으로는 충분하지 않습니다.\n\n🔔 이와 같은 기사를 더 읽고 싶으신가요? 여기에서 등록하세요.\n\n<div class=\"content-ad\"></div>\n\n시스템 내 중요한 클래스 상호작용을 모의하는 것은 클래스 간 통신 및 데이터 교환에서 발생하는 통합 문제를 알리지 못하게 할 수 있습니다. 실제 데이터베이스를 사용하는 데 조금 노력을 기울이면 장기적으로 이득을 볼 수 있습니다.\n\n빌드 시간에 통합 문제를 발견하는 것은 운영시간(프로덕션)에 발생하는 쉽게 피할 수 있는 문제를 발견하는 것보다 훨씬 저렴합니다.\n\n# 계속 연락을 유지합시다!\n\n뉴스레터에 등록하여 유사한 기사에 대한 알림을 받고 YouTube 채널인 @Nicklas Millard를 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n린크드인에 연결하지 않는 것을 잊지 마세요.\n\n","ogImage":{"url":"/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png"},"coverImage":"/assets/img/2024-05-27-FavoringIntegrationTestsOverUnitTeststoVerifyCorrectness_0.png","tag":["Tech"],"readingTime":5},{"title":"새로운 Kotlin 어노테이션 프로세서 KSP를 사용해보세요","description":"","date":"2024-05-27 16:16","slug":"2024-05-27-KapttoKSP","content":"\n\n안녕하세요 여러분, 이번 시리즈를 통해 KAPT에서 KSP로 변경하는 것에 대해 이야기할 거예요.\n\nKAPT(코틀린 어노테이션 처리 도구)는 코틀린 코드에서 자바 어노테이션 프로세서를 사용할 수 있게 해줘요. 심지어 해당 프로세서가 코틀린을 명시적으로 지원하지 않더라도요. 이 과정은 코틀린 파일에서 자바 스텁을 생성하여 프로세서가 읽을 수 있게 합니다. 이 스텁 생성은 비용이 많이 드는 작업으로, 빌드 속도에 상당한 영향을 미칩니다.\n\n프로젝트에 KSP를 어떻게 포함시킬까요?\n\n프로젝트 최상위 build.gradle.kts 파일에 KSP 플러그인을 포함하세요.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n플러그인 {\n    id 'com.google.devtools.ksp' version '1.8.10-1.0.9' 적용하지 않음\n}\n```\n\n다음으로, 모듈 레벨의 build.gradle.kts 파일을 활성화해주세요.\n\n```kotlin\n플러그인 {\n    id 'com.google.devtools.ksp'\n}\n```\n\nKAPT 라이브러리를 KSP로 교체해주세요\n\n\n<div class=\"content-ad\"></div>\n\n```js\n    kapt 'androidx.room:room-compiler:2.5.0' //제거\n    ksp 'androidx.room:room-compiler:2.5.0'  //추가\n```\n  \n이 종속성을 추가한 후에 프로젝트를 동기화하세요.\n\n프로젝트에서 KAPT 플러그인을 제거하세요:\n\n더는 KAPT 요구 사항이 필요하지 않을 때 KAPT 플러그인을 삭제하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nplugins {\n    id 'org.jetbrains.kotlin.kapt'\n}\n\n//프로젝트에서 남은 kapt 플러그인도 제거해야 합니다\n```\n\n# KSP2 베타 버전 출시!\n\nKSP2는 KSP API의 새로운 구현체입니다. KSP 1.x보다 더 빠르고 쉽게 사용할 수 있을 것입니다. 자세한 내용은 KSP2 소개를 참고해주세요.\n\n# 즐거운 코딩하세요 🚀\n","ogImage":{"url":"/assets/img/2024-05-27-KapttoKSP_0.png"},"coverImage":"/assets/img/2024-05-27-KapttoKSP_0.png","tag":["Tech"],"readingTime":2},{"title":"ViewChild를 사용하지 말아요","description":"","date":"2024-05-27 16:16","slug":"2024-05-27-StopusingViewChild","content":"\n\n네이티브 DOM 요소에 액세스하는 것은 웹 개발에서 기본적인 작업입니다. 그러나 현대적인 프레임워크는 다양한 전략을 활용하여 직접 DOM 액세스의 필요성을 최소화합니다. 예를 들어 Angular는 *ngIf와 같은 디렉티브를 사용하여 요소를 조건부로 추가하거나 제거하고 *ngFor를 사용하여 요소를 반복합니다. 이러한 기술은 직접적인 DOM 조작을 추상화하여 Angular이나 유사한 프레임워크에서 어플리케이션을 개발할 때 덜 걱정해도 되도록 만듭니다.\n\n이러한 추상화에도 불구하고 직접적인 DOM 액세스가 여전히 필요한 시나리오가 있습니다. 구글 맵과 같은 일부 써드파티 라이브러리는 동작을 위해 직접적인 DOM 요소가 필요합니다. 구글 맵은 맵을 초기화하고 표시하기 위해 div 요소가 필요합니다. 일반적으로 개발자는 @ViewChild 데코레이터를 사용하여 div 요소에 액세스하고 그것을 맵 API에 제공하여 초기화합니다.\n\n```js\n/// <reference types=\"@types/google.maps\" />\nimport { AfterViewInit, Component, ElementRef, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-map-component',\n  template: `<div class=\"map-container\" #googleMap></div>`,\n  styles: ['.map-container {height: 500px;}'],\n})\nexport class MapComponentComponent implements AfterViewInit {\n  @ViewChild('googleMap', { read: ElementRef }) googleMapElement!: ElementRef<HTMLDivElement>;\n  map?: google.maps.Map;\n\n  async ngAfterViewInit() {\n    const { Map } = await google.maps.importLibrary(\"maps\") as google.maps.MapsLibrary;\n    // Pass the nativeElement to google map library\n    this.map = new Map(this.googleMapElement.nativeElement, {\n      center: { lat: -34.397, lng: 150.644 },\n      zoom: 8,\n    });\n  }\n}\n```\n\n이 접근 방식은 작동하지만 세 가지 주요 문제점을 도입합니다:\n\n<div class=\"content-ad\"></div>\n\n- 템플릿에서 div 요소를 제거하면 코드가 깨져서 맵 기능을 재사용할 수 없게 됩니다.\n- 네이티브 요소에 대한 참조는 ngAfterViewInit 라이프사이클 후크 이후에만 사용할 수 있습니다.\n- SOLID 디자인 원칙 중 단일 책임 원칙을 위반합니다. @ViewChild를 사용하는 컴포넌트는 맵을위한 데이터를 가져오는 것, 초기화하는 것, 설정하고 사용하는 것에 대한 책임이 생깁니다.\n\n더 나은 접근 방식이 있습니다: 속성 지시자 사용.\n\n이전 컴포넌트를 리팩토링하고 맵 속성 지시자를 만들어 봅시다.\n\n```js\n/// <reference types=\"@types/google.maps\" />\nimport { Directive, ElementRef, OnInit } from '@angular/core';\n\n@Directive({\n  selector: 'div[appGoogleMap]'\n})\nexport class GoogleMapDirective implements OnInit {\n  map?: google.maps.Map;\n  constructor(private elementRef: ElementRef<HTMLDivElement>) { }\n\n  async ngOnInit() {\n    const { Map } = await google.maps.importLibrary(\"maps\") as google.maps.MapsLibrary;\n    this.map = new Map(this.elementRef.nativeElement, {\n      center: { lat: -34.397, lng: 150.644 },\n      zoom: 8,\n    });\n  }\n}\n\n// 속성 지시자 사용\n<div class=\"map-container\" appGoogleMap></div>\n```\n\n<div class=\"content-ad\"></div>\n\n다른 사용 사례를 고려해 보겠습니다: 캔버스 요소에 도형이나 이미지를 그리는 것입니다. 간단한 방법은 @ViewChild를 사용하여 네이티브 요소에서 그리기 컨텍스트를 가져오는 것입니다.\n\n더 나은 대안은 속성 지시자를 사용하고 @Input 속성을 통해 그리기 정보를 전달하는 것입니다.\n\n```js\nimport { Component, ElementRef, ViewChild } from '@angular/core';\n\n@Component({\n  selector: 'app-canvas-component',\n  template: `<canvas #myCanvas></canvas>`,\n})\nexport class CanvasComponentComponent {\n  // 빌드 시 myCanvas를 확인할 수 있는 방법이 없음\n  @ViewChild('myCanvas', { read: ElementRef }) canvasRef!: ElementRef<HTMLCanvasElement>;\n\n  ngAfterViewInit() {\n    const canvas = this.canvasRef.nativeElement;\n    const canvasContext = canvas.getContext('2d');\n    // 캔버스 컨텍스트를 사용하여 그리기\n    canvasContext?.beginPath();\n    canvasContext?.arc(75, 75, 50, 0, 2 * Math.PI);\n    canvasContext?.stroke();\n  }\n}\n\n// Vs\nimport { Directive, ElementRef } from '@angular/core';\n\n@Directive({\n  // 이 지시자는 Cavas 요소만 사용할 수 있습니다\n  selector: 'canvas[appCanvas]'\n})\nexport class CanvasDirective {\n  constructor(private elementRef: ElementRef<HTMLCanvasElement>) {\n    this.draw();\n  }\n\n  draw() {\n    const canvas = this.elementRef.nativeElement;\n    const canvasContext = canvas.getContext('2d');\n    // 캔버스 컨텍스트를 사용하여 그리기\n    canvasContext?.beginPath();\n    canvasContext?.arc(75, 75, 50, 0, 2 * Math.PI);\n    canvasContext?.stroke();\n  }\n}\n// 속성 지시자 사용\n<canvas appCanvas></canvas>\n```\n\n좋아 보이죠? 그런데 기다려 보세요, 더 있습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 첫 두 문제를 해결했지만 속성 지시자는 여전히 여러 책임을 처리하고 있습니다. 더 분해할 수 있을까요? 다음 블로그에서 그것을 더 탐구해보겠습니다.","ogImage":{"url":"/assets/img/2024-05-27-StopusingViewChild_0.png"},"coverImage":"/assets/img/2024-05-27-StopusingViewChild_0.png","tag":["Tech"],"readingTime":4},{"title":"APKTOOL을 사용하여 APK를 디컴파일하고 재컴파일하는 방법 초보자 안내","description":"","date":"2024-05-27 16:15","slug":"2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide","content":"\n개인 실험을 위한 앱의 디컴파일 및 다시 컴파일하는 과정을 찾다가 많은 기사와 블로그를 만나게 되었습니다. 그 중 일부는 몇 단계를 놓치거나 다른 도구를 사용했습니다. 그래서 저는 apktool을 사용하여 앱을 디컴파일하고 다시 컴파일하는 방법에 대한 기사를 쓰기로 생각했습니다. 제가 수집한 모든 정보를 통합하고 샘플 표현과 함께 제시하겠습니다.\n\n![이미지](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_0.png)\n\n## 기본 사항\n\n- Apktool: 안드로이드 APK 파일에 대한 역공학 도구입니다.\n- Keytool: 디컴파일된 APK에 서명하기 위한 새 키스토어 파일을 생성하는 데 사용됩니다.\n- Apksigner: APK에 서명하는 데 사용됩니다.\n- Zipalign: 디컴파일된 파일들을 정렬하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n추가 도구\nJD-GUI: Java 디컴파일러\ndex2jar: 안드로이드 .dex 및 java .class 파일과 작업하는 도구\n\n## 전제 조건\n\nMac과 Linux에서 APK를 쉽게 디컴파일할 수 있습니다. Windows의 경우 일부 조정이 필요하지만, 아직 시도해보지 않았습니다. 디컴파일을 시작하려면 시스템에 JDK와 Android SDK를 설치해야 합니다.\n\nMac에서 Brew를 사용하여 Apktool 유틸리티를 설치하는 것은 매우 쉽습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nbrew install apktool\n```\n\n이 링크에서 자세한 설치 가이드를 찾을 수 있어요\n\n## 실험\n\n화면에 \"Original App\"이라는 텍스트를 표시하는 앱의 프로가드가 활성화된 — 서명된 APK가 있어요\n우리 실험의 목표는\n\n- 이 APK를 디컴파일하기\n- 배경색과 텍스트 색상 변경하기\n- 텍스트 \"Original App\"을 \"Recompiled App\"으로 바꾸기\n- 성공적으로 재컴파일하고 앱에 서명하기\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_1.png\" />\n\n## 연구실로 들어가봅시다\n\n단계 1: 디컴파일\n\nApkMirror.com 또는 다른 사이트에서 어떤 앱의 APK를 다운로드할 수 있습니다. 여기서는 샘플 앱 \"experiment_app.apk\"의 서명된 APK를 사용하겠습니다.\n먼저, 이 APK를 디컴파일해야 합니다. apktool을 사용하여 APK를 디컴파일하는 다음 명령을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\napktool d [apk 위치] -o [디컴파일된 파일이 저장될 출력 폴더 위치]\n```\n\n![APKTOOL 사용하여 APK 디컴파일 및 재컴파일 시작 가이드](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_2.png)\n\n위 명령어를 실행한 후, apktool이 내 문서 디렉토리에 \"experimentapp_decompiled\"라는 새 폴더를 생성했습니다.\n\n![APKTOOL 사용하여 APK 디컴파일 및 재컴파일 시작 가이드](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_3.png)\n\n<div class=\"content-ad\"></div>\n\n만약 APK 파일에서 리소스 파일을 디컴파일하고 싶지 않다면, 대신 이 명령을 사용하세요\n\n```js\napktool d -r -s [apk 위치]  -o [디컴파일된 파일을 저장할 출력 폴더 위치]\n```\n\nStage 2 : 파일 수정\n\n저는 디컴파일된 파일 폴더에서 strings.xml과 colours.xml을 찾았어요\n\n<div class=\"content-ad\"></div>\n\nmage](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_4.png)\n\nAndroid Studio에서는 이 리소스 파일을 창으로 드래그하거나 XML 편집기를 사용하여 열 수 있습니다.\n배경색을 빨간색으로, 텍스트 색상을 노란색으로 변경했습니다. 그런 다음, 텍스트를 \"재컴파일된 앱\"으로 변경했습니다.\n\nStage 3: 디컴파일된 리소스를 APK로 재컴파일하기\n\n변경 사항을 적용한 후, 다음 명령을 사용하여 디컴파일된 파일을 APK로 재컴파일할 예정입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\napktool b [디컴파일된 파일의 루트 폴더 위치]\n```\n\n![Decompile and Recompile APK using APKTOOL Beginner's Guide](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_5.png)\n\n이제 Apktool은 파일들을 컴파일하고 APK를 생성합니다. 디컴파일된 파일을 저장한 루트 폴더와 동일한 위치의 새 폴더인 \"dist\" 안에 저장될 것입니다.\n\n아하.. 알겠네요..\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_6.png)\n\nStage 4: Zipalign the apk for the optimal loading\n\nZipalign is a zip archive alignment tool that helps ensure that all uncompressed files in the archive are aligned relative to the start of the file. Zipalign tool can be found in the “Build Tools” folder within the Android SDK path.\n\n![image](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_7.png)\n\n`\n\n<div class=\"content-ad\"></div>\n\nAPK를 zip align하려면 다음 명령을 실행하세요:\n\n```js\nzipalign -v 4 [재컴파일 된 apk] [zip align된 apk를 저장할 위치 및 apk 이름 및 확장자]\n```\n\n![이미지](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_8.png)\n\n단계 5: zip align된 APK에 서명하기 위한 새 키스토어 파일 생성\n\n<div class=\"content-ad\"></div>\n\n다음 명령어를 사용하여 keytool을 사용하여 키스토어 파일을 생성했어요. 이 명령을 사용하면 키스토어의 암호와 상세 정보를 입력하라는 프롬프트가 나타날 거에요.\n\n```js\nkeytool -genkey -v -keystore [키스토어 이름] -alias alias_name -keyalg RSA -keysize 2048 -validity 10000\n```\n\n<img src=\"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_9.png\" />\n\n단계 6: apksigner를 사용하여 앱에 서명하세요.\n\n<div class=\"content-ad\"></div>\n\nApksigner 도구는 Android SDK 빌드 도구의 24.0.3 버전 이상에서 제공되며, APK를 서명하고 해당 APK가 지원하는 Android 플랫폼 버전에서 성공적으로 확인될 것임을 확인할 수 있습니다.\nApk signer는 Android SDK 경로의 \"build tools\" 폴더 안에 ZipAlign과 함께 있습니다.\n\n![image](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_10.png)\n\n아래 명령어를 사용하여 apksigner를 사용하여 APK를 서명하십시오.\n\n```js\napksigner sign --ks [키스토어 이름] --v1-signing-enabled true --v2-signing-enabled true [zip align된 apk 위치]\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_11.png\" />\n\nStage 7: Verify the signed APK\n\nThe zip-aligned — signed APK can be verified using the same apksigner.\n\n```js\napksigner verify [signed apk location]\n```\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_12.png\" />\n\n단계 8: 앱 설치\n\nadb 명령어를 사용하거나 수동으로 설치하여 확인된 apk를 설치합니다.\n\n```js\nadb install /Users/matrix/Documents/APK/experimentapp_zipaligned.apk\n```\n\n<div class=\"content-ad\"></div>\n\n\n![앱의 배경과 텍스트 색상이 변경되었어요](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_13.png)\n\n와우! 앱의 배경과 텍스트 색상이 변경되었어요.\n\n![실험 성공](/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_14.png)\n\n실험 성공 .....\n\n\n<div class=\"content-ad\"></div>\n\n\ndex2jar [classes.dex 파일 위치 디컴파일 된 폴더]\n\njd-gui [classes-dex2jar.jar 파일 위치]\n\n","ogImage":{"url":"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_0.png"},"coverImage":"/assets/img/2024-05-27-DecompileandRecompileAPKusingAPKTOOLBeginnersGuide_0.png","tag":["Tech"],"readingTime":6},{"title":"안드로이드 앱을 위한 바로 가기 생성 방법","description":"","date":"2024-05-27 16:13","slug":"2024-05-27-HowtocreateashortcutforanAndroidapp","content":"\n\n![image](/assets/img/2024-05-27-HowtocreateashortcutforanAndroidapp_0.png)\n\n안녕 친구들,\n\n안드로이드 애플리케이션에서 특정 작업이나 동작에 대한 바로 가기를 만드는 방법을 보여드릴 것을 기대합니다.\n\n먼저 의존성을 추가해보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n앱/build.gradle.kts 파일에 아래 종속성을 추가해주세요.\n\n```kotlin\nimplementation (\"androidx.core:core:1.13.1\")\nimplementation (\"androidx.core:core-google-shortcuts:1.1.0\")\n```\n\n그런 다음, 앱/src/main/AndroidManifest.xml 파일로 이동해서 아래의 메타 태그를 `activity` 태그 안에 추가해주세요.\n\n```xml\n<meta-data android:name=\"android.app.shortcuts\"\n           android:resource=\"@xml/shortcuts\"/>\n```\n\n<div class=\"content-ad\"></div>\n\n이제 res/xml 폴더 안에 @xml/shortcuts 파일을 만들어야 해요. 아래 xml 파일에는 앱을 위한 정적 바로 가기가 정의되어 있습니다. 정적 영구 바로 가기를 만들고 싶다면 이 xml 파일에 바로 가기를 추가하면 돼요.\n\n그리고 해당 액티비티로 이동하기 위한 Intent 도 추가해야 해요. targetPackage 이름이 앱의 패키지 이름과 일치하는지 확인해 주세요.\n\n```js\nandroid: targetPackage = \"com.task.master\";\n```\n\n그렇게 하면 안드로이드 OS가 앱을 찾을 수 있어요. 그리고 바로 가기에 고유한 Id를 부여했는지 확인해 주세요.\n\n<div class=\"content-ad\"></div>\n\n\n<shortcuts xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <shortcut\n        android:shortcutId=\"shortcut_1\"\n        android:enabled=\"true\"\n        android:icon=\"@drawable/tm_logo\"\n        android:shortcutShortLabel=\"@string/ShortCutShortLabel_1\"\n        android:shortcutLongLabel=\"@string/ShortCutLongLabel_1\"\n        android:shortcutDisabledMessage=\"@string/ShortCutDisableLabel_1\"\n        >\n\n        <intent\n            android:action=\"android.intent.action.VIEW\"\n            android:targetPackage=\"com.task.master\"\n            android:targetClass=\"com.task.master.presentation.ui.activities.MainActivity\"\n            >\n                <extra\n                    android:name=\"Type\"\n                    android:value=\"Create\"\n                    />\n        </intent>\n        <categories android:name=\"android.shortcut.conversation\"/>\n        <capability-binding android:key=\"action.intent.CREATE_MESSAGE\"/>\n    </shortcut>\n\n    <shortcut\n        android:shortcutId=\"shortcut_2\"\n        android:enabled=\"true\"\n        android:icon=\"@drawable/tm_logo\"\n        android:shortcutShortLabel=\"@string/ShortCutShortLabel_2\"\n        android:shortcutLongLabel=\"@string/ShortCutLongLabel_2\"\n        android:shortcutDisabledMessage=\"@string/ShortCutDisableLabel_2\"\n        >\n\n        <intent\n            android:action=\"android.intent.action.VIEW\"\n            android:targetPackage=\"com.task.master\"\n            android:targetClass=\"com.task.master.presentation.ui.activities.MainActivity\"\n            >\n                <extra\n                    android:name=\"Type\"\n                    android:value=\"View\"\n                    />\n        </intent>\n        <categories android:name=\"android.shortcut.conversation\"/>\n        <capability-binding android:key=\"action.intent.CREATE_MESSAGE\"/>\n    </shortcut>\n\n</shortcuts>\n\n\n안드로이드 앱에 파일 및 코드를 추가한 후 xml/shortcuts.xml에 정의한 바로가기가 표시됩니다.\n\n이제 액티비티에서 동적으로 바로 가기를 추가하는 방법을 보여드리겠습니다. ShortcutInfoCompat을 사용하여 동적으로 바로 가기를 추가할 수 있고 ShortcutManagerCompat을 사용하여 해당 바로 가기를 푸시할 수 있습니다. 아래 코드를 확인하여 동적 바로 가기를 추가하는 방법을 알아보세요.\n\n\n  val context = this.baseContext\n        val shortcut = ShortcutInfoCompat.Builder(context, \"dynamic_Id\")\n            .setShortLabel(\"Dynamic Item\")\n            .setLongLabel(\"Dynamic Item\")\n            .setIcon(IconCompat.createWithResource(context, R.drawable.profile_icon))\n            .setIntent(\n                Intent(context,MainActivity::class.java).apply {\n                    action = Intent.ACTION_VIEW\n                    putExtra(\"Type\", \"\")\n                }\n            )\n            .build()\n        ShortcutManagerCompat.pushDynamicShortcut(context, shortcut)\n\n\n<div class=\"content-ad\"></div>\n\n이번 단계 이후에는 모든 활동에서 바로 가기를 추가할 수 있으며 서버 응답에 따라 응용 프로그램에 바로 가기를 추가할 수도 있습니다.\n\n결론\n\n바로 가기를 사용하여 사용자 상호 작용을 개선하고 사용자가 특정 섹션으로 빠르게 이동할 수 있습니다.\n\n소스 코드는 여기에서 찾을 수 있습니다\n\n<div class=\"content-ad\"></div>\n\n감사합니다\n","ogImage":{"url":"/assets/img/2024-05-27-HowtocreateashortcutforanAndroidapp_0.png"},"coverImage":"/assets/img/2024-05-27-HowtocreateashortcutforanAndroidapp_0.png","tag":["Tech"],"readingTime":4},{"title":"젯팩 컴포즈 부가 효과 자세히 알아보기","description":"","date":"2024-05-27 16:11","slug":"2024-05-27-JetpackComposeSideEffectsinDetails","content":"\n\n![Jetpack Compose](/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png)\n\nJetpack Compose는 Android에서 UI 개발을 훨씬 쉽게 만들었지만, UI 효과를 효율적으로 관리하는 방법을 이해하는 것이 성능 향상에 매우 중요합니다. 본 문서에서는 UI 효과를 효과적으로 관리하는 데 도움이 되는 세 가지 중요한 Composable 함수인 SideEffect, LaunchedEffect 및 DisposableEffect을 살펴보겠습니다.\n\n# 왜 부작용(side-effect)이 필요한가요?\n\nJetpack Compose에서 부작용의 목적은 Composable 함수 외부에서 앱의 상태를 변경하는 UI와 관련 없는 작업을 제어 가능하고 예측 가능한 방식으로 실행할 수 있게 하는 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n부작용은 데이터베이스 업데이트나 네트워크 호출과 같은 작업을 UI 렌더링 로직과 분리하여 코드의 성능과 유지 보수성을 향상시켜야 합니다.\n\n젯팩 컴포즈는 SideEffect, LaunchedEffect, DisposableEffect와 같은 여러 컴포저블 함수를 제공하여 개발자가 사이드 이펙트를 효과적으로 관리할 수 있도록 해줍니다. 이를 통해 UI 렌더링 로직과 분리하고 별도의 코루틴 범위에서 실행함으로써 사이드 이펙트를 처리할 수 있습니다.\n\n젯팩 컴포즈에서 사이드 이펙트를 사용하는 주요 이점은 다음과 같습니다:\n\n- 성능 향상: 비 UI 관련 작업을 컴포저블 함수 외부에서 실행함으로써 UI 렌더링 로직이 반응성이 있고 성능이 좋아집니다.\n- 코드 구성 개선: UI 렌더링 로직에서 비 UI 관련 작업을 분리함으로써 코드베이스가 이해하기 쉬워지고 유지 보수가 용이해집니다.\n- 디버깅 개선: 사이드 이펙트는 로깅 및 분석 작업에 사용될 수 있으며, 이를 통해 개발자가 앱의 동작을 더 잘 이해하고 문제점을 식별할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n요약하면 Jetpack Compose에서의 부작용의 목적은 UI 렌더링 로직에서 UI와 상관없는 작업을 분리함으로써 코드베이스의 성능, 유지 관리 및 디버깅을 개선하는 것입니다.\n\n## SideEffect\n\nSideEffect는 부모 Composable이 recomposed될 때 부작용을 실행할 수 있게 해주는 Composable 함수입니다. 부작용이란 직접적으로 UI에 영향을 주지 않는 작업으로, 로깅, 분석 또는 외부 상태 갱신과 같은 작업을 의미합니다. 이 함수는 Composable의 상태나 props에 의존하지 않는 작업을 실행하는 데 유용합니다.\n\nComposable이 recomposed되면 Composable 함수 내의 모든 코드가 다시 실행되며, 이 과정에서 모든 부작용도 다시 실행됩니다. 그러나 UI는 Composable의 상태나 props에 대한 변경 사항만 반영하여 업데이트됩니다.\n\n<div class=\"content-ad\"></div>\n\n# SideEffect를 사용하는 방법\n\nSideEffect를 사용하려면 Composable 함수 내부에서 호출하고 실행하려는 사이드 이펙트를 포함한 람다를 전달해야 합니다. 다음은 예시입니다:\n\n```js\n@Composable\nfun Counter() {\n    // Count를 위한 상태 변수 정의\n    val count = remember { mutableStateOf(0) }\n\n    // SideEffect를 사용하여 count 변수의 현재 값 로깅\n    SideEffect {\n        // 재구성할 때마다 호출됨\n        log(\"Count is ${count.value}\")\n    }\n\n    Column {\n        Button(onClick = { count.value++ }) {\n            Text(\"Increase Count\")\n        }\n\n        // 상태가 업데이트될 때마다 텍스트가 변경되고 재구성이 트리거됩니다\n        Text(\"Counter ${count.value}\")\n    }\n}\n```\n\n이 예시에서 SideEffect 함수는 Counter 함수가 재구성될 때마다 count 상태 변수의 현재 값이 로깅됩니다. 이는 디버깅 및 Composable 동작 모니터링에 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n현재 Composable 함수가 recomposed될 때만 부작용이 발생합니다. 중첩된 Composable 함수에는 해당되지 않습니다. 즉, 다른 Composable 함수를 호출하는 Composable 함수가 있는 경우, 내부 Composable 함수가 recomposed될 때 외부 Composable 함수의 SideEffect가 트리거되지 않습니다. 이를 이해하기 위해 코드를 다음과 같이 변경해보겠습니다:\n\n```js\n@Composable\nfun Counter() {\n    // count를 위한 상태 변수 정의\n    val count = remember { mutableStateOf(0) }\n\n    // count의 현재 값 로그 남기기 위해 SideEffect 사용\n    SideEffect {\n        // 재구성마다 호출됨\n        log(\"Count is ${count.value}\")\n    }\n\n    Column {\n        Button(onClick = { count.value++ }) {\n            // 버튼이 탭될 때마다 바깥쪽 부작용이 트리거되지 않음\n            // 매번 버튼이 탭될 때마다 Text가 recompose됨\n            Text(\"Increase Count ${count.value}\")\n        }\n    }\n}\n```\n\n위의 코드에서 앱이 처음 시작될 때, Counter Composable 함수가 compose되고 SideEffect가 count의 초기 값으로 console에 로그를 남깁니다. 버튼을 클릭하면 Text Composable이 count의 새 값으로 recompose되지만, 이는 SideEffect를 다시 트리거하지 않습니다.\n\n이제 이 작동 방식을 보기 위해 inner side effect를 추가해봅시다.\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Composable\nfun Counter() {\n    // 카운트를 위한 상태 변수 정의\n    val count = remember { mutableStateOf(0) }\n\n    // SideEffect를 사용하여 count의 현재 값 로깅\n    SideEffect {\n        // 재구성마다 호출\n        log(\"Outer Count is ${count.value}\")\n    }\n\n    Column {\n        Button(onClick = { count.value++ }) {\n            // SideEffect를 사용하여 count의 현재 값 로깅\n            SideEffect {\n                // 재구성마다 호출\n                log(\"Inner Count is ${count.value}\")\n            }\n\n            // 이 재구성은 버튼을 누를 때마다\n            // 외부 SideEffect를 계속해서 트리거하지 않습니다\n            Text(\"Increase Count ${count.value}\")\n        }\n    }\n}\n```\n\n위의 코드를 사용하여 버튼을 클릭하면 출력 결과가 다음과 같이 나타납니다:\n\n```kotlin\nOuter Count is 0\nInner Count is 0\nInner Count is 1\nInner Count is 2\nInner Count is 3\n```\n\n지금 이유를 알 것 같아요 :)\n\n<div class=\"content-ad\"></div>\n\n# LaunchedEffect\n\nLaunchedEffect은 별도의 코루틴 스코프에서 부작용을 실행하는 Composable 함수입니다. 이 함수는 UI 스레드를 차단하지 않고 네트워크 호출 또는 애니메이션과 같은 오랜 시간이 걸리는 작업을 실행하는데 유용합니다.\n\n아래는 LaunchedEffect를 사용하는 예시입니다:\n\n```kt\n@Composable\nfun MyComposable() {\n    val isLoading = remember { mutableStateOf(false) }\n    val data = remember { mutableStateOf(listOf<String>()) }\n\n    // LaunchedEffect를 정의하여 오랜 시간 동안 비동기적으로 작업을 수행합니다\n    // `isLoading.value`가 변경될 때마다 `LaunchedEffect`가 취소되고 다시 시작됩니다\n    LaunchedEffect(isLoading.value) {\n        if (isLoading.value) {\n            // 네트워크에서 데이터를 가져오는 등 오랜 시간 동안 실행해야 할 작업을 수행합니다\n            val newData = fetchData()\n            // 새 데이터로 상태를 업데이트합니다\n            data.value = newData\n            isLoading.value = false\n        }\n    }\n\n    Column {\n        Button(onClick = { isLoading.value = true }) {\n            Text(\"데이터 가져오기\")\n        }\n        if (isLoading.value) {\n            // 로딩 인디케이터를 표시합니다\n            CircularProgressIndicator()\n        } else {\n            // 데이터를 표시합니다\n            LazyColumn {\n                items(data.value.size) { index ->\n                    Text(text = data.value[index])\n                }\n            }\n        }\n    }\n}\n\n// 2초 동안 코루틴을 일시 중단하여 네트워크 호출 시뮬레이션\nprivate suspend fun fetchData(): List<String> {\n    // 네트워크 지연 시간을 시뮬레이션합니다\n    delay(2000)\n    return listOf(\"항목 1\", \"항목 2\", \"항목 3\", \"항목 4\", \"항목 5\",)\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 예시에서 LaunchedEffect 함수는 isLoading 상태 변수가 true로 설정될 때 네트워크 호출을 실행하여 API에서 데이터를 가져옵니다. 이 함수는 별도의 코루틴 스코프에서 실행되므로 작업이 수행되는 동안 UI가 반응할 수 있게 유지됩니다.\n\nLaunchedEffect 함수는 두 개의 매개변수를 사용합니다: key는 isLoading.value로 설정되고 block은 실행할 부작용을 정의하는 람다입니다. 이 경우 block 람다는 fetchData() 함수를 호출하며, 이 함수는 코루틴을 2초 동안 일시 중단하여 네트워크 호출을 시뮬레이트합니다. 데이터를 가져오면 데이터 상태 변수를 업데이트하고 isLoading을 false로 설정하여 로딩 지시자를 숨기고 가져온 데이터를 표시합니다.\n\n## key 매개변수 뒤의 논리는 무엇인가요?\n\nLaunchedEffect에서 key 매개변수는 LaunchedEffect 인스턴스를 식별하고 불필요하게 recompose되지 않도록 방지하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n컴포저가 recomposed될 때, Jetpack Compose는 다시 그려야 하는지 여부를 결정합니다. 만약 Composable의 상태나 프로퍼티가 변경되었거나 Composable이 invalidate를 호출했다면, Jetpack Compose는 Composable을 다시 그릴 것입니다. Composable을 다시 그리는 것은 비용이 많이 드는 작업일 수 있습니다. 특히 Composable에 장기 실행 작업이 포함되어 있거나 매번 recomposed될 때마다 다시 실행할 필요가 없는 부작용이 있는 경우에도 그렇습니다.\n\nLaunchedEffect에 key 매개변수를 제공함으로써, LaunchedEffect 인스턴스를 고유하게 식별하는 값을 지정할 수 있습니다. key 매개변수의 값이 변경되면, Jetpack Compose는 LaunchedEffect 인스턴스를 새로운 인스턴스로 간주하고 부작용을 다시 실행할 것입니다. key 매개변수의 값이 동일하면, Jetpack Compose는 부작용의 실행을 건너뛰고 이전 결과를 재사용하여 불필요한 recomposition을 방지할 것입니다.\n\nLaunchedEffect에 여러 키를 사용할 수도 있습니다:\n\n```js\n// LaunchedEffect에 임의의 UUID를 키로 사용합니다\nval key = remember { UUID.randomUUID().toString() }\n\nLaunchedEffect(key, isLoading.value) {\n  ....\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# DisposableEffect\n\nDisposableEffect은 부모 Composable이 처음으로 렌더링될 때 사이드 이펙트를 실행하고, Composable이 UI 계층구조에서 제거될 때 효과를 삭제하는 Composable 함수입니다. 이 함수는 이벤트 리스너나 애니메이션과 같이 Composable이 더 이상 사용되지 않을 때 정리해야 하는 리소스를 관리하는 데 유용합니다.\n\n다음은 DisposableEffect를 사용하는 예시입니다:\n\n```js\n@Composable\nfun TimerScreen() {\n    val elapsedTime = remember { mutableStateOf(0) }\n\n    DisposableEffect(Unit) {\n        val scope = CoroutineScope(Dispatchers.Default)\n        val job = scope.launch {\n            while (true) {\n                delay(1000)\n                elapsedTime.value += 1\n                log(\"Timer is still working ${elapsedTime.value}\")\n            }\n        }\n\n        onDispose {\n            job.cancel()\n        }\n    }\n\n    Text(\n        text = \"Elapsed Time: ${elapsedTime.value}\",\n        modifier = Modifier.padding(16.dp),\n        fontSize = 24.sp\n    )\n}\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드에서는 DisposableEffect를 사용하여 매 초마다 elapsedTime 상태 값을 증가시키는 코루틴을 실행합니다. 또한 DisposableEffect를 사용하여 Composable이 사용되지 않을 때 코루틴이 취소되고 코루틴에서 사용하는 리소스가 정리되도록 합니다.\n\nDisposableEffect의 정리 함수에서 우리는 job에 저장된 Job 인스턴스의 cancel() 메서드를 사용하여 코루틴을 취소합니다.\n\nonDispose 함수는 Composable이 UI 계층에서 제거될 때 호출되며, Composable에서 사용된 모든 리소스를 정리하는 방법을 제공합니다. 이 경우에는 onDispose를 사용하여 코루틴을 취소하고 코루틴에서 사용하는 모든 리소스가 정리되도록 합니다.\n\n이 DisposableEffect가 작동하는 방법을 확인하려면 다음 코드를 실행하여 결과를 확인해보세요:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Composable\nfun RunTimerScreen() {\n    val isVisible = remember { mutableStateOf(true) }\n\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Bottom\n    ) {\n        Spacer(modifier = Modifier.height(10.dp))\n\n        if (isVisible.value)\n            TimerScreen()\n\n        Button(onClick = { isVisible.value = false }) {\n           Text(\"타이머 숨기기\")\n        }\n    }\n}\n```\n\n새로운 RunTimerScreen Composable을 추가했습니다. 이를 통해 사용자는 TimerScreen의 가시성을 토글할 수 있습니다. 사용자가 \"타이머 숨기기\" 버튼을 클릭하면 TimerScreen Composable이 UI 계층에서 제거되고 코루틴이 취소되고 정리됩니다.\n\nonDispose 함수에서 job.cancel() 호출을 제거하면, TimerScreen Composable이 더 이상 사용되지 않더라도 코루틴이 계속 실행되어 메모리 누수 및 다른 성능 문제를 야기할 수 있습니다.\n\nDisposableEffect와 CoroutineScope를 이렇게 함께 사용함으로써, CoroutineScope에서 시작된 코루틴이 TimerScreen Composable이 더 이상 사용되지 않을 때 취소되고 리소스가 정리되도록 합니다. 이를 통해 메모리 누수 및 다른 성능 문제를 방지하고 앱의 성능과 안정성을 향상시킬 수 있습니다.\n\n\n\n<div class=\"content-ad\"></div>\n\n# 각각 사용하는 시기\n\nDisposableEffect 사용 사례\n\n- 이벤트 리스너 추가 및 제거\n- 애니메이션 시작 및 중지\n- 카메라, 위치 관리자 등과 같은 센서 자원 바인딩 및 언바인딩\n- 데이터베이스 연결 관리\n\nLaunchedEffect 사용 사례\n\n<div class=\"content-ad\"></div>\n\n- 네트워크로부터 데이터 가져오기\n- 이미지 처리 수행\n- 데이터베이스 업데이트\n\nSideEffect의 사용 사례\n\n- 로깅 및 분석\n- 블루투스 장치에 연결 설정, 파일에서 데이터 불러오기 또는 라이브러리 초기화와 같은 일회성 초기화 수행.\n\n한 번 설정할 때 SideEffect를 사용하는 예시:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\n@Composable\nfun MyComposable() {\n    val isInitialized = remember { mutableStateOf(false) }\n\n    SideEffect {\n        if (!isInitialized.value) {\n            // 여기에 일회성 초기화 작업 실행\n            initializeBluetooth()\n            loadDataFromFile()\n            initializeLibrary()\n\n            isInitialized.value = true\n        }\n    }\n\n    // UI 코드 여기에 작성\n}\n```\n\n# 요약\n\nSideEffect, DisposableEffect 및 LaunchedEffect 간의 차이 요약:\n\n- SideEffect는 부모 Composable이 recomposed될 때 실행되며, Composable의 상태나 props에 의존하지 않는 작업을 실행하는 데 유용합니다.\n- DisposableEffect는 부모 Composable이 처음 렌더링될 때 실행되며, Composable이 더 이상 사용되지 않을 때 정리해야하는 리소스를 관리하는 데 유용합니다. 첫 번째 구성 또는 키 변경시 트리거되며, 종료시 onDispose 메서드를 호출합니다.\n- LaunchedEffect는 별도의 코루틴 스코프에서 부작용을 실행하며, UI 스레드를 블로킹하지 않고 긴 작업을 실행하는 데 유용합니다. 첫 번째 구성 또는 키 변경시 트리거됩니다.\n\n\n\n\n","ogImage":{"url":"/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png"},"coverImage":"/assets/img/2024-05-27-JetpackComposeSideEffectsinDetails_0.png","tag":["Tech"],"readingTime":11},{"title":"Jetpack Compose에서 애니메이션 화살표 포인터 만들기","description":"","date":"2024-05-27 16:10","slug":"2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose","content":"\n\n환영합니다 👋\n\n이 기사에서는 Jetpack Compose를 사용하여 멋진 애니메이션 화살표 포인터를 만드는 방법을 탐색하고 앱의 외관을 5분 안에 향상시키는 방법에 대해 알아보겠습니다.\n\n계속 주목하고, 함께 알아보시죠! 🚀\n\n![Animated Arrow Pointer](https://miro.medium.com/v2/resize:fit:1400/1*jP0QAL3blRz6ynJ8IkjCuQ.gif)\n\n<div class=\"content-ad\"></div>\n\n# 함수 정의하기\n\nAnimatedArrowPointer 함수를 선언하고 그 파라미터들을 살펴봅시다.\n\n```js\n@Composable\nfun AnimatedArrowPointer(\n    modifier: Modifier,\n    color: Color,\n    isVisible: Boolean = true,\n    strokeWidth: Dp = 2.dp,\n    pointerSize: Dp = 12.dp,\n    dashLength: Dp? = 4.dp,\n    strokeCap: StrokeCap = StrokeCap.Round,\n    pointerShape: Shape = SimpleArrow,\n    animationSpec: AnimationSpec<Float> = tween(3000)\n)\n```\n\n## ⚒️ 파라미터 설명\n\n<div class=\"content-ad\"></div>\n\n⚡ modifier ➜ 포인터 레이아웃에 적용할 수정자입니다.\n\n⚡ color ➜ 화살표 포인터의 색상입니다.\n\n⚡ isVisible ➜ 화살표 포인터가 표시되는지 여부를 결정합니다.\n\n⚡ strokeWidth ➜ 화살표 포인터의 선 두께입니다.\n\n<div class=\"content-ad\"></div>\n\n⚡ pointerSize ➜ 화살표 포인터의 크기입니다.\n\n⚡ dashLength ➜ 테두리 대시의 길이입니다. null은 실선을 의미합니다.\n\n⚡ strokeCap ➜ 화살표 포인터의 선 끝 스타일입니다.\n\n⚡ pointerShape ➜ 화살표 포인터의 모양입니다.\n\n<div class=\"content-ad\"></div>\n\n⚡ animationSpec ➜ 화살표 애니메이션 동작을 지정합니다.\n\n# 경로\n\n좋아요, 오늘 기사의 주요 내용으로 넘어갑시다.\n\n## ArrowPath\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n<div class=\"content-ad\"></div>\n\n## SimplePointer\n\n다음으로 포인터를 제작해야 합니다. Shape 인터페이스를 구현하는 객체를 정의합시다:\n\n```js\nobject SimpleArrow : Shape {\n    override fun createOutline(\n        size: Size,\n        layoutDirection: LayoutDirection,\n        density: Density\n    ): Outline {\n        val width = size.width\n        val height = size.height\n\n        val path = Path().apply {\n            moveTo(0f, 0f) // 1\n            lineTo(width, height * 0.5f) // 2\n            lineTo(0f, height) // 3\n            lineTo(width * 0.5f, height * 0.5f) // 4\n            close() // line to 1\n        }\n        return Outline.Generic(path)\n    }\n}\n```\n\n이해를 돕기 위해 다음 이미지를 확인해보세요 👇\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_1.png)\n\n# 그리기\n\n이제 함수 구현에 가까워졌어요. 하지만 그 전에, 경로와 포인터 머리를 그리기 위한 두 개의 지원 함수를 정의해야 해요.\n\n## 화살 경로 그리기\n\n\n<div class=\"content-ad\"></div>\n\n경로를 그리는 것은 간단합니다. 지정된 속성을 가진 캔버스에 일반적인 경로를 그리기만 하면 됩니다:\n\n```js\nfun DrawScope.drawPathSegment(\n    path: Path,\n    color: Color,\n    strokeWidth: Dp,\n    strokeCap: StrokeCap,\n    dashLength: Dp? = null\n) {\n    drawPath(\n        path = path,\n        color = color,\n        style = Stroke(\n            width = strokeWidth.toPx(),\n            cap = strokeCap,\n            // dashLength가 지정되어 있다면 대시 스트로크를 그리고,\n            // 그렇지 않으면 실선을 사용합니다.\n            pathEffect = dashLength?.let { dash ->\n                PathEffect.dashPathEffect(\n                    floatArrayOf(dash.toPx(), dash.toPx())\n                )\n            }\n        )\n    )\n}\n```\n\n## 포인터 헤드 그리기\n\n현재 경로 세그먼트의 끝에 동적으로 헤드를 그리려면 PathMeasure의 getPosition 및 getTangent를 활용하여 포인터의 위치와 올바른 방향을 가리키는 각도를 얻을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfun DrawScope.drawPointerHead(\n    pathMeasure: PathMeasure,\n    stopDistance: Float,\n    pointerSize: Dp,\n    color: Color,\n    pointerShape: Shape\n) {\n    // 지정된 거리에서의 점과 접선을 계산합니다.\n    val headPoint = pathMeasure.getPosition(stopDistance)\n    val tangent = pathMeasure.getTangent(stopDistance)\n\n    // 접선을 기반으로 화살표 머리의 회전 각도를 계산합니다.\n    val angle = atan2(tangent.y.toDouble(), tangent.x.toDouble()).toFloat() * 180 / Math.PI.toFloat()\n\n    // 화살표 머리의 크기와 윤곽을 정의합니다.\n    val headSize = Size(pointerSize.toPx(), pointerSize.toPx())\n    val headOutline = pointerShape.createOutline(headSize, layoutDirection, this)\n\n    // 캔버스를 이동하고 회전시켜 화살표 머리의 위치와 방향을 조정합니다.\n    translate(headPoint.x - (headSize.width / 2), headPoint.y - (headSize.height / 2)) {\n        rotate(angle, pivot = headSize.center) {\n            // 화살표 머리 윤곽을 그립니다.\n            drawOutline(headOutline, color = color)\n        }\n    }\n}\n```  \n\n# 구현\n\n마지막으로 모든 것을 합쳐서 애니메이션을 적용합시다.\n\n```js\n@Composable\nfun AnimatedArrowPointer(\n    /* 매개변수... */\n) {\n    // 애니메이션 진행 값을 위한 Animatable 정의\n    val pathCompletion = remember { Animatable(0f) }\n\n    // 가시성 상태 변경에 기반하여 애니메이션 시작\n    LaunchedEffect(isVisible) {\n        if (isVisible) {\n            // 경로 애니메이션\n            pathCompletion.animateTo(1f, animationSpec)\n        } else {\n            // 경로 즉시 숨기기\n            pathCompletion.snapTo(0f)\n        }\n    }\n\n    // Canvas에서 애니메이션된 화살표 그리기\n    Canvas(\n        // 경로 왜곡을 방지하기 위한 적절한 비율 보장\n        modifier.aspectRatio(0.6f)\n    ) {\n        // 캔버스 크기에 따라 화살표 경로 생성\n        val arrowPath = createArrowPath(size.width, size.height)\n\n        // 길이와 세그먼트 정보를 얻기 위해 경로 측정\n        val pathMeasure = PathMeasure().apply {\n            setPath(arrowPath, false)\n        }\n\n        // 현재 애니메이션 진행에 기반한 경로 세그먼트 생성\n        val pathSegment = Path()\n        val stopDistance = pathCompletion.value * pathMeasure.length\n        pathMeasure.getSegment(0f, stopDistance, pathSegment, true)\n\n        // 지정된 속성으로 현재 화살표 경로 세그먼트 그리기\n        drawPathSegment(pathSegment, color, strokeWidth, strokeCap, dashLength)\n\n        // 경로가 일부 그려진 경우, 화살표 머리 그리기\n        if (pathCompletion.value > 0) {\n            drawPointerHead(pathMeasure, stopDistance, pointerSize, color, pointerShape)\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n축하해요 🥳! 우리 성공적으로 만들었어요 👏. 전체 코드 구현을 확인하려면 GitHub Gist에 액세스할 수 있어요 🧑‍💻. 이제 사용 방법을 알아보아요.\n\n## 광고\n\n외국어를 배우고 새로운 어휘로 고민하고 계신가요? 그렇다면, 여러분의 학습을 쉽고 편리하게 해줄 이 어플을 확인하는 걸 강력히 추천해요!\n\n<img src=\"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 사용법\n\n배치에 간단한 변형 수정자를 적용하여 화살표 포인터의 위치를 쉽게 사용자 정의할 수 있습니다. 여기에는 일반적인 시나리오가 있습니다:\n\n## 하단-우측 (기본)\n\n하단-우측 위치는 기본 포인팅 방향입니다:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier.size(140.dp),\n    color = Color.Red\n)\n```\n\n![Arrow Pointer](https://miro.medium.com/v2/resize:fit:576/1*FM6yzByscqrfK0bihhE_6g.gif)\n\n## Top-Right\n\nTo point to the top-right, rotate the layout by -90 degrees:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier\n        .size(140.dp)\n        .rotate(-90f),\n    color = Color.Red\n)\n```\n\n![Animated Arrow Pointer](https://miro.medium.com/v2/resize:fit:900/1*TDE55uvzhAy-XZNn-d8bGg.gif)\n\n## Bottom-Left\n\nBottom-Left를 가리키려면 레이아웃을 x축에서 -1f로 확장하여 수평으로 반사합니다:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier\n        .size(140.dp)\n        .scale(-1f, 1f),\n    color = Color.Red\n)\n```\n\n![Animated arrow pointer](https://miro.medium.com/v2/resize:fit:570/1*NZ608yVkzKu7IVAwAPa8HQ.gif)\n\n## 왼쪽 위\n\n왼쪽 위 방향을 위해, 먼저 레이아웃을 수평으로 반사한 다음, -90도로 회전시킵니다:\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nAnimatedArrowPointer(\n    modifier = Modifier\n        .size(140.dp)\n        .scale(-1f, 1f)\n        .rotate(-90f),\n    color = Color.Red\n)\n```\n\n![Animated Arrow Pointer](https://miro.medium.com/v2/resize:fit:900/1*UaIjzfaG0aaaqpSNmN4Qpw.gif)\n\n좋아할 만한 내용이 있을 것 같아요 👇\n\n이 기사를 읽어 주셔서 감사합니다! ❤️ 즐거우시고 가치 있게 보내셨으면 좋겣습니다. 만약 좋았다면 만세 👏를 눌러서 감사를 표현해 주시고 Kappdev를 팔로우하여 더욱 흥미로운 기사를 읽어보세요 😊\n\n\n<div class=\"content-ad\"></div>\n\n행복한 코딩!\n\n![이미지](/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_3.png)","ogImage":{"url":"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-27-CreatinganAnimatedArrowPointerinJetpackCompose_0.png","tag":["Tech"],"readingTime":8},{"title":"루비에서의 메소드 접근 제한자","description":"","date":"2024-05-27 16:09","slug":"2024-05-27-MethodaccessmodifiersinRuby","content":"\n\n## 루비에서의 메소드 액세스 수정자\n\n루비에서의 메소드 액세스 수정자는 클래스 내부 및 외부에서 메소드의 가시성 및 접근성을 정의하는 중요한 역할을 합니다. 기본 설정으로 메소드는 공개(public)이며, 이는 객체 외부 및 내부에서 모두 호출할 수 있다는 것을 의미합니다.\n\n## 공개 메소드\n\n루비에서는 기본적으로 메소드가 공개(public)로 설정됩니다. 따라서 객체의 내부 및 외부에서 모두 호출할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass Parent\n  def initialize(name)\n    @name = name\n  end\n\n  def public_method\n    @name\n  end\nend\n\nparent = Parent.new('Eric')\np parent.public_method #=> \"Eric\"\n```\n\n## Private Methods\n\nPrivate methods can only be called from within the context of the defining class. They cannot be called with an explicit receiver, not even self.\n\n```js\nclass Parent\n  def initialize(name)\n    @name = name\n  end\n  \n  private\n  \n  def name\n    @name\n  end\nend\n\nclass Child1 < Parent\n  def other_name(child)\n    child.name\n  end\n\n  def call_name\n    name\n  end\nend\n\nclass Child2 < Parent\nend\n\nchild1 = Child1.new('Eric')\nchild2 = Child2.new('John')\np child1.other_name(child2) #=> private method `name' called for #<Child2:…> (NoMethodError)\np child1.call_name #=> \"Eric\"\n```\n\n<div class=\"content-ad\"></div>\n\n## 보호된 메서드\n\n보호된 메서드는 정의된 클래스의 인스턴스 또는 하위 클래스의 인스턴스에서 호출할 수 있지만, 이외의 인스턴스에서는 호출할 수 없습니다.\n\n```js\nclass Parent\n  def initialize(name)\n    @name = name\n  end\n  \n  protected\n\n  def name\n    @name\n  end\nend\n\nclass Child1 < Parent\n  def other_name(child)\n    child.name\n  end\n\n  def call_name\n    name\n  end\nend\n\nclass Child2 < Parent\nend\n\nchild1 = Child1.new('Eric')\nchild2 = Child2.new('John')\np child1.other_name(child2) #=> \"John\"\np child1.name #=> protected method `name' called for #<Child1:…> (NoMethodError)\n```\n\n## 접근 제한자 및 범위\n\n<div class=\"content-ad\"></div>\n\n액세스 한정자는 Ruby에서 범위에 영향을 주지 않습니다; 메서드의 가시성만을 영향을 미칩니다. 외부에서 접근할 수 없는 개인 메서드도 하위 클래스에서는 상속됩니다.\n\n```js\nclass Parent\n  def initialize(name)\n    @name = name\n  end\n  \n  private\n  \n  def name\n    @name\n  end\nend\n\nclass Child < Parent\n  def call_name\n    name\n  end\nend\n\nchild = Child.new('Eric')\np child.call_name #=> \"Eric\"\n```\n\n# 실용적인 고려사항\n\n## 보호된 메서드\n\n<div class=\"content-ad\"></div>\n\n- 보호된 메서드는 Ruby에서 자주 사용되지 않는데, 이는 가시성을 혼동시키고 메서드가 어디에서 어떻게 호출되는지 추적하기 어렵게 만들 수 있기 때문입니다.\n- 이는 미묘한 버그를 도입하고 디버깅을 더 어렵게 만들 수 있습니다.\n\n## 비공개 메서드\n\n- 비공개 메서드는 객체의 내부 작동과 공개 인터페이스 사이의 명확한 분리를 제공합니다.\n- 캡슐화를 촉진하며 코드를 유지 및 디버그하기 쉽게 만듭니다.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n루비의 접근 제어자는 메소드의 가시성을 정의하고 메소드에 접근 및 상호 작용하는 방법을 제어하는 중요한 도구입니다. 이러한 제어자를 이해하고 적절하게 사용하는 것은 깔끔하고 이해하기 쉽고 유지보수 가능한 코드를 유지하는 데 도움이 될 수 있습니다. 코드베이스가 더 복잡해지면 이러한 차이의 중요성이 더욱 명확해질 것입니다.","ogImage":{"url":"/assets/img/2024-05-27-MethodaccessmodifiersinRuby_0.png"},"coverImage":"/assets/img/2024-05-27-MethodaccessmodifiersinRuby_0.png","tag":["Tech"],"readingTime":3}],"page":"36","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}