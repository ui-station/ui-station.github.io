{"pageProps":{"posts":[{"title":"Swift 비동기 처리에서 경합 상태 버그 해결 방법 ","description":"","date":"2024-06-22 23:11","slug":"2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency","content":"\n\n<img src=\"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png\" />\n\niOS 캘린더 스케줄러에는 '기본 캘린더' 기능이 있어요. Apple 캘린더와 같은 외부 캘린더와 통합한 후에, 이 설정은 이벤트를 추가할 때 가장 자주 사용하는 캘린더가 기본적으로 선택되도록 합니다. 이 기능은 사용자가 정의한 '기본 캘린더'를 연결된 캘린더에서 이벤트 스케줄링 시에 에디터의 '캘린더 선택' 섹션에서 자동으로 선택되도록 설정합니다.\n\n<img src=\"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_1.png\" />\n\n# 💡 경합 조건으로 인한 문제 해결하기\n\n<div class=\"content-ad\"></div>\n\n그러나 때로는 다른 닠린더가 선택된 경우도 있었습니다. 항상 그런 것은 아니었고, 대부분의 경우 정상적으로 작동했습니다. 제가 이 문제를 디버그하는 방법을 잘 모르겠었는데, 가끔 발생하는 문제라서 더욱 더 어려웠습니다. 가끔씩 발생하더라도, 이 기능이 제대로 작동하지 않으면 사용자가 잘못된 링크된 달력에 이벤트를 알지 못하게 추가할 수 있어 나중에 불필요한 수정을 유발할 수 있습니다.\n\n최근에 이 문제를 해결할 실마리를 찾았습니다. Xcode 16 베타 버전의 새 기능에 대한 호기심으로 설치한 후 보게 된 경고 메시지 덕분이었습니다. 이 경고는 이전 버전의 Xcode에서는 나타나지 않았고, 스위프트 6의 보다 엄격한 Actor Isolation 규칙으로 인해 발생했습니다. 이 규칙은 동시성 모델을 더 안전하게 만들기 위한 것입니다.\n\n![Image](/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_2.png)\n\n스위프트에서 Actor는 동시성 모델로, 내부 함수와 속성을 동시 액세스로부터 보호합니다. Actors는 수행하는 작업을 직렬화하여 각 작업이 순차적으로 실행되도록 합니다. 이를 통해 경합 조건 및 데이터 경주와 같은 동시성 문제를 방지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n경주 조건은 시스템의 동작이 실행 순서에 따라 달라질 수 있는 다중 스레드 프로그래밍에서 중요한 개념입니다. 다시 말해, 경주 조건은 두 개 이상의 작업이 병렬로 실행되고 결과가 실행 순서나 시간에 따라 변경될 수 있는 경우 발생합니다. 경주 조건이 발생하면 프로그램이 예측할 수 없이 동작하거나 예상치 못한 결과를 내놓을 수 있습니다.\n\n데이터 경주는 두 개 이상의 스레드가 동시에 동일한 메모리 위치에 액세스하고, 그 중 적어도 하나가 쓰기 작업을 수행하는 경우 발생합니다. 이는 메모리 일관성을 파괴하고 예측할 수 없는 프로그램 동작으로 이어질 수 있습니다. Swift의 Actor는 이러한 문제를 방지하기 위해 상태를 안전하게 격리합니다.\n\n제 코드에서는 메인 Actor 콘텍스트에서 Actor로 격리된 ekRepository의 eventStore 속성에 액세스하려고 시도했으며, 이로 인해 Swift 6에서 컴파일 오류가 발생했습니다. 코드의 문제가 요약된 부분은 다음과 같습니다:\n\n```swift\nimport EventKit\n\nactor EKRepository {\n    let eventStore: EKEventStore\n    \n    init() {\n        self.eventStore = EKEventStore()\n    }\n}\n\n@MainActor\nfinal class EKInteractor: ObservableObject {\n    private let ekRepository: EKRepository\n    \n    var eventStore: EKEventStore {\n        /// 🔥 Actor-isolated property 'eventStore' can not be referenced from the main actor;\n        /// 🔥 this is an error in the Swift 6 language mode.\n        ekRepository.eventStore\n    }\n    \n    init(ekRepository: EKRepository) {\n        self.ekRepository = ekRepository\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n저는 이 코드를 처음 작성할 때 'eventStore'가 'EKRepository' 내에서만 액세스되도록 보장하는 것이 목표였습니다. 처음에는 EKInteractor가 속성으로 eventStore를 정의하지 않았습니다. 그러나 EKEventEditViewController와 같은 Apple에서 제공하는 UI에 EKEventStore를 매개변수로 전달해야 하는 상황이 많았습니다. 그 결과, EKInteractor는 eventStore을 노출하기 시작했습니다.\n\n하지만, EKInteractor가 Actor Isolation을 무시하고 ekRepository의 eventStore에 액세스하고 있다면, 이는 경합 조건과 예기치 않은 문제를 초래할 수 있습니다.\n\n이를 해결하기 위해 코드를 리팩토링하여 Actor Isolation을 준수하도록 만들어 경합 조건을 피했습니다. 리팩토링된 코드는 다음과 같습니다:\n\n```swift\nactor EKRepository {\n    /// 💡 'getEventStore()' 메서드를 사용하여 eventStore에 대한 액세스 캡슐화\n    private let eventStore: EKEventStore\n    \n    init() {\n        self.eventStore = EKEventStore()\n    }\n}\n\nextension EKRepository {\n    func getEventStore() -> EKEventStore {\n        return eventStore\n    }\n}\n\n@MainActor\nfinal class EKInteractor: ObservableObject {\n    private let ekRepository: EKRepository\n    \n    private var cachedEventStore: EKEventStore? = nil\n    \n    /// 💡 Actor Isolation을 준수하면서 eventStore에 비동기적으로 액세스하고 캐시합니다.\n    /// 우선 캐시된 eventStore이 있는지 확인하고,\n    /// 그렇지 않으면 EKRepository의 getEventStore 메서드를 비동기적으로 호출하여 eventStore을 가져와 캐시합니다.\n    var eventStore: EKEventStore {\n        get async {\n            if let eventStore = cachedEventStore {\n                return eventStore\n            }\n            \n            let store = await ekRepository.getEventStore()\n            cachedEventStore = store\n            return store\n        }\n    }\n    \n    init(ekRepository: EKRepository) {\n        self.ekRepository = ekRepository\n        \n        /// 💡 시작할 때 eventStore을 비동기적으로 가져와 캐싱하여 이후 액세스 성능을 향상시킵니다.\n        initEventStore(ekRepository: ekRepository)\n    }\n}\n\nextension EKInteractor {\n    private func initEventStore(ekRepository: EKRepository) {\n        /// 💡 [Task] 이 메서드는 eventStore을 비동기적으로 가져와 캐시하지만,\n        /// 이 프로세스가 완료되기 전에 후속 작업이 진행될 수 있습니다.\n        Task {\n            self.cachedEventStore = await ekRepository.getEventStore()\n        }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n또한, 'Default Calendar'를 설정하는 부분에서 레이스 컨디션에 민감한 코드를 발견했어요. 아래 코드에서는 newEKEvent의 캘린더(타입은 EKCalendar)가 Task 블록 내에서 비동기로 설정되어 있습니다. 이 비동기 작업은 getNewEKEvent 함수가 newEKEvent 객체를 반환한 뒤에 실행될 수 있습니다. 이는 반환된 newEKEvent 객체를 다른 곳에서 사용하려고 할 때 캘린더 속성이 아직 설정되지 않을 수 있다는 의미입니다. 이러한 상황은 '실행 순서(execution order)'에 따라 예측할 수 없는 동작을 유발할 수 있으며, 이는 해결하고자 했던 간헐적 버그와 일치합니다.\n\n```js\nprivate func getNewEKEvent(ekInteractor: EKInteractor, selectedDate: Date) -> EKEvent {\n    let newEKEvent = EKEvent(eventStore: ekInteractor.eventStore)\n    \n    // 🔥 문제: 이 Task 블록은 비동기로 실행되므로, 함수가 newEKEvent를 반환한 후에 실행될 수 있습니다.\n    Task {\n        // 🔥 문제: 비동기 작업이 newEKEvent 반환 후에 완료된 경우, 캘린더 속성이 아직 설정되지 않을 수 있습니다.\n        if let defaultEKCalendarToAdd = await ekInteractor.getDefaultEKCalendarToAdd() {\n            newEKEvent.calendar = defaultEKCalendarToAdd\n        }\n    }\n    \n    // 🔥 문제: 함수가 비동기 작업이 완료되기 전에 newEKEvent를 반환하므로, 데이터 레이스와 레이스 컨디션이 발생할 수 있습니다.\n    return newEKEvent\n}\n```\n\n요약하면, 위의 코드는 '레이스 컨디션'의 대상이 될 수 있으며, 비동기 작업이 완료되기 전에 객체가 반환됩니다. 이 문제는 아래에 표시된 대로 코드를 재구성하여 해결할 수 있습니다.\n\n```js\n/// 💡 비동기 작업을 수행할 수 있도록 getNewEKEvent 함수를 async로 선언하여,\n/// 모든 비동기 작업이 완료된 후에만 newEKEvent가 반환되도록 함.\n/// ---> 레이스 컨디션과 데이터 레이스 방지\nprivate func getNewEKEvent(ekInteractor: EKInteractor, selectedDate: Date) async -> EKEvent {\n    /// 💡 eventStore를 비동기로 가져오기 위해 await 사용\n    let newEKEvent = EKEvent(eventStore: await ekInteractor.eventStore)\n    \n    /// 💡 defaultEKCalendarToAdd를 비동기로 가져와 newEKEvent의 캘린더 속성에 설정\n    if let defaultEKCalendarToAdd = await ekInteractor.getDefaultEKCalendarToAdd() {\n        newEKEvent.calendar = defaultEKCalendarToAdd\n    }\n    \n    /// 💡 모든 비동기 작업이 완료된 후에 newEKEvent 반환\n    return newEKEvent\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 문제를 해결하면서 Swift 동시성에 대한 이해가 깊어졌습니다. 안전한 동시 코드 작성의 기초를 확립할 수 있어 기쁩니다. 무엇보다도, Scheduler 앱의 다음 업데이트에서 사용자에게 흠잡을 데 없는 '기본 캘린더' 기능을 제공할 수 있어 기쁩니다.\n\n'Reminders'부터 '기본 캘린더'까지 모든 것을 신속하게 통합하세요.\n다양한 위젯.\nScheduler: iPhone, iPad 및 Mac용 캘린더 앱.\n\n# 참고문헌\n\n<div class=\"content-ad\"></div>\n\n- Swift 프로그래밍 언어 — 동시성:\nhttps://docs.swift.org/swift-book/documentation/the-swift-programming-language/concurrency/\n- Apple 개발자 문서 — Swift 동시성:\nhttps://developer.apple.com/documentation/swift/concurrency\n- Apple 개발자 문서 — EKEventStore:\nhttps://developer.apple.com/documentation/eventkit/ekeventstore\n- 경합 조건 이해와 해결:\nhttps://en.wikipedia.org/wiki/Race_condition\n- Apple 개발자 문서 — Task:\nhttps://developer.apple.com/documentation/swift/task\n\n이러한 자료들은 Swift 동시성, 액터 및 관련 주제에 대해 자세한 정보를 제공하여 경합 조건과 같은 문제를 이해하고 해결하는 데 도움이 됩니다.","ogImage":{"url":"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png"},"coverImage":"/assets/img/2024-06-22-ResolvingaRaceConditionBuginSwiftConcurrency_0.png","tag":["Tech"],"readingTime":7},{"title":"SwiftData로 원격 API에서 데이터 저장하는 방법","description":"","date":"2024-06-22 23:10","slug":"2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI","content":"\n\n앱 사용자에게 오프라인 기능을 제공하고 앱 운영 비용을 줄이는 데 중요한 로컬 데이터 저장은 매우 중요합니다.\n\n[![Image](/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png)](//)\n\n시작하기 전에 몇 초 동안 제 게시물을 팔로우하고 👏 클랩(clap)하여 더 많은 사람들이 이 유용한 내용을 배울 수 있도록 도와주세요.\n\n# API 호출로부터 SwiftData를 사용하여 로컬로 데이터 저장하기\n\n<div class=\"content-ad\"></div>\n\n코드로 넘어가기로 하겠습니다. SwiftData에 익숙하지 않으신 경우, 새로운 내용을 익히시려면 이 기사를 확인해보세요.\n\n우리는 구조체의 이름 뒤에 약어 DTO(Data Transfer Object)를 추가하기로 결정했습니다. DTO는 한 시스템에서 다른 시스템으로 데이터를 전송하는 데 사용됩니다. 우리의 예제에서는 API 응답의 데이터를 JSON에서 SwiftData entity로 전송하려고 합니다. DTO는 JSON 응답을 일시적으로 보유하여 해당 데이터를 파싱하고 Swift 객체로 변환할 수 있게 합니다. 앞으로 몇 개의 코드 블록에서는 해당 Swift 객체를 SwiftData entity로 변환할 것입니다.\n\n```swift\n// PhotoDTO.swift\nimport Foundation\n\nstruct PhotoDTO: Identifiable, Codable {\n    let albumId: Int\n    let id: Int\n    let title: String\n    let url: String\n    let thumbnailUrl: String\n}\n```\n\nSwiftData로 시작하는 기사를 읽으신 경우, 이 내용은 익숙하게 느껴질 것입니다. 클래스에 새로운 코드 조각을 추가했는데, 그것은 편의 이니셜라이저입니다. 이를 통해 DTO를 직접 전달하여 SwiftData entity를 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\n//  PhotoObject.swift\nimport Foundation\nimport SwiftData\n\n@Model\nclass PhotoObject {\n    var albumId: Int\n    @Attribute(.unique) var id: Int\n    var title: String\n    var url: String\n    var thumbnailUrl: String\n    \n    init(albumId: Int, id: Int, title: String, url: String, thumbnailUrl: String) {\n        self.albumId = albumId\n        self.id = id\n        self.title = title\n        self.url = url\n        self.thumbnailUrl = thumbnailUrl\n    }\n    \n    convenience init(item: PhotoDTO) {\n        self.init(\n            albumId: item.albumId,\n            id: item.id,\n            title: item.title,\n            url: item.url,\n            thumbnailUrl: item.thumbnailUrl\n        )\n    }\n}\n```\n\n웹 서비스도 만약 SwiftUI에서 API 호출을 만들고 파싱한 적이 있다면 익숙할 것입니다. 웹 서비스를 살펴보면, 그 기사에서 살짝 수정하여 새로운 기능을 보유한 웹 서비스를 가지고 있다는 것을 알 수 있습니다. updateDataInDatabase를 이용해 API 호출에서 데이터를 파싱할 때마다 데이터를 데이터베이스에 저장할 수 있도록 새 기능을 추가했습니다. updateDataInDatabase 함수는 PhotoDTO를 SwiftData 엔티티로 변환하고 각 레코드를 데이터베이스에 저장하는 메서드입니다. 또한, ID로 찾을 수 없는 경우 새 레코드를 생성할지 또는 기존 레코드를 업데이트할지 결정하기 위해 insert 메서드를 사용하고 있음을 알 수 있습니다.\n\n```swift\n//  WebService.swift\nimport Foundation\nimport SwiftData\n\nenum NetworkError: Error {\n    case badUrl\n    case invalidRequest\n    case badResponse\n    case badStatus\n    case failedToDecodeResponse\n}\n\nclass WebService {\n    @MainActor\n    func updateDataInDatabase(modelContext: ModelContext) async {\n        do {\n            let itemData: [PhotoDTO] = try await fetchData(fromUrl: \"https://jsonplaceholder.typicode.com/albums/1/photos\")\n            for eachItem in itemData {\n                let itemToStore = PhotoObject(item: eachItem)\n                modelContext.insert(itemToStore)\n            }\n        } catch {\n            print(\"Error fetching data\")\n            print(error.localizedDescription)\n        }\n    }\n\n    private func fetchData<T: Codable>(fromUrl: String) async throws -> [T] {\n        guard let downloadedData: [T] = await WebService().downloadData(fromURL: fromUrl) else { return [] }\n\n        return downloadedData\n    }\n    \n    private func downloadData<T: Codable>(fromURL: String) async -> T? {\n        do {\n            guard let url = URL(string: fromURL) else { throw NetworkError.badUrl }\n            let (data, response) = try await URLSession.shared.data(from: url)\n            guard let response = response as? HTTPURLResponse else { throw NetworkError.badResponse }\n            guard response.statusCode >= 200 && response.statusCode < 300 else { throw NetworkError.badStatus }\n            guard let decodedResponse = try? JSONDecoder().decode(T.self, from: data) else { throw NetworkError.failedToDecodeResponse }\n            \n            return decodedResponse\n        } catch NetworkError.badUrl {\n            print(\"There was an error creating the URL\")\n        } catch NetworkError.badResponse {\n            print(\"Did not get a valid response\")\n        } catch NetworkError.badStatus {\n            print(\"Did not get a 2xx status code from the response\")\n        } catch NetworkError.failedToDecodeResponse {\n            print(\"Failed to decode response into the given type\")\n        } catch {\n            print(\"An error occured downloading the data\")\n        }\n        \n        return nil\n    }\n}\n```\n\n뷰 레이어에서는 데이터베이스에서 PhotoObjects를 읽어와 목록으로 표시합니다. 목록 내에서는 AsyncImage 구성 요소를 사용해 API에서 이미지를 표시하고 해당 항목의 ID를 이미지 옆에 표시합니다. 목록의 하단에는 몇 가지 다른 변형을 추가했습니다. overlay 변형은 목록이 비어 있을 때 진행 스피너를 표시합니다. task 변형은 목록이 비어 있으면 API에서 데이터를 자동으로 가져오도록 합니다. 또한, refreshable 변형을 사용해 목록 구성 요소에 pull to refresh를 추가했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\"task\" 및 \"refreshable\" 수정자를 사용하면 사용자가 업데이트된 데이터를 확인하려고 할 때만 API가 호출되도록 보장합니다(API를 실행하는 비용을 줄임). 이는 앱을 런칭할 때마다 API에서 데이터를 가져오는 대신 두 번째로 데이터가 데이터베이스에서 가져와지게 함을 의미합니다.\n\n또한 미리보기가 일반적인 경우보다 코드가 더 많이 보일 수 있습니다. SwiftData에서 데이터를 미리보는 것은 일반적인 뷰에서 데이터를 표시하는 것보다 조금 더 복잡하기 때문입니다. 미리보기에서는 데이터가 임시로 저장되는 새 컨테이너를 만들고(미리보기 장치에 데이터를 영구적으로 저장하지 않기 위함), 그런 다음 객체를 만들어 그 컨테이너에 저장합니다. 미리보기 데이터를 저장하는 별도의 파일을 생성하는 다른 자습서도 볼 수 있지만 이는 작동하며 전혀 문제가 없습니다. 저는 미리보기에 대한 코드를 미리보기 자체에 가까이 유지하고 싶어하여 별도의 파일을 생성하지 않았습니다.\n\n```js\n//  ContentView.swift\nimport SwiftData\nimport SwiftUI\n\nstruct ContentView: View {\n    @Environment(\\.modelContext) var modelContext\n    @Query(sort: \\PhotoObject.id) var photos: [PhotoObject]\n    \n    var body: some View {\n        List(photos) { item in\n            HStack {\n                Text(item.id, format: .number)\n                Spacer()\n                \n                AsyncImage(url: URL(string: item.url)!) { imagePhase in\n                    switch imagePhase {\n                    case .empty:\n                        Image(systemName: \"ellipsis\")\n                    case .success(let returnedImage):\n                        returnedImage\n                            .resizable()\n                            .scaledToFit()\n                    case .failure:\n                        Image(systemName: \"xmark.circle\")\n                            .font(.headline)\n                            .foregroundColor(.red)\n                    @unknown default:\n                        Image(systemName: \"ellipsis\")\n                    }\n                }\n            }\n        }\n        .overlay {\n            if photos.isEmpty {\n                ProgressView()\n            }\n        }\n        .task {\n            if photos.isEmpty {\n                await WebService().updateDataInDatabase(modelContext: modelContext)\n            }\n        }\n        .refreshable {\n            await WebService().updateDataInDatabase(modelContext: modelContext)\n        }\n    }\n}\n\n#Preview {\n    do {\n        let config = ModelConfiguration(isStoredInMemoryOnly: true)\n        let container = try ModelContainer(for: PhotoObject.self, configurations: config)\n        let sampleObject = PhotoObject(\n            albumId: 1,\n            id: 1,\n            title: \"accusamus beatae ad facilis cum similique qui sunt\",\n            url: \"https://via.placeholder.com/600/92c952\",\n            thumbnailUrl: \"https://via.placeholder.com/150/92c952\"\n        )\n        container.mainContext.insert(sampleObject)\n        \n        return ContentView().modelContainer(container)\n    } catch {\n        fatalError(\"Failed to create model container\")\n    }\n}\n```\n\n이 글이 유익하다고 느끼신다면, 제를 팔로우하는 것, 이 글에 👏 반응을 보내는 것, 또는 공유하여 다른 사람이 더 쉽게 찾을 수 있도록 돕는 것도 고려해주세요.\"\n\n<div class=\"content-ad\"></div>\n\n해당 주제에 대해 궁금한 점이 있거나 동일한 작업을 수행하는 다른 방법을 알고 계신다면, 이 게시물에 답글을 달거나 친구에게 공유하여 의견을 얻을 수 있습니다. Native 모바일 개발에 대해 더 배우고 싶다면, 여기에서 작성한 다른 기사들을 확인해보세요: [https://medium.com/@jpmtech](https://medium.com/@jpmtech). Native 모바일 개발로 제작된 앱들을 보고 싶다면, 여기에서 제가 만든 앱들을 확인해보세요: [https://jpmtech.io/apps](https://jpmtech.io/apps). 제 작품을 확인해주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png"},"coverImage":"/assets/img/2024-06-22-UsingSwiftDatatoStoreDatafromaRemoteAPI_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI에서 제스처 완벽하게 활용하는 방법 종합 가이드","description":"","date":"2024-06-22 23:09","slug":"2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide","content":"\n\n앱이라는 힘을 상상해보세요. 각 탭, 스와이프 및 핀치로 UI를 생동감 있게 만들어보세요.\n\n![이미지](/assets/img/2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide_0.png)\n\n직관적인 제스처의 마법은 정적인 인터페이스를 동적이고 매력적인 경험으로 변화시킬 수 있습니다. 사용자들이 사랑하는 경험으로 만들어 주죠. 사용자가 쉽게 줌 인/아웃 및 패닝을 할 수 있는 사진 편집기, 창의성이 모든 드래그로부터 흘러나오는 그림 앱, 반응형 스와이프 제어가 있는 게임을 만드는 중이라면 SwiftUI에서 제스처를 마스터하는 것이 이런 가능성을 해제하는 열쇠입니다.\n\n이 포괄적인 가이드에서 기초부터 고급 기술까지 안내해 드릴 것이며, SwiftUI의 제스처 인식기를 활용하여 매끄럽고 상호작용적인 사용자 경험을 만드는 방법을 공개할 것입니다. 실용적인 예제에 대해 깊이 파헤치고, 현실 세계의 사용 사례를 소개하며, 제스처 충돌을 처리하고 접근성을 보장하는 전문 팁을 제공할 것입니다. 이 여정을 마치면 SwiftUI 프로젝트에서 제스처의 모든 잠재력을 활용할 수 있는 준비가 되어 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\nSwiftUI의 제스처에 대한 소개\n\nSwiftUI에서 제스처는 탭, 스와이프 및 드래그와 같은 사용자 상호 작용을 감지하고 응답하는 데 사용됩니다. SwiftUI에는 기본 제스처 인식기가 제공되어 앱에 이러한 상호 작용을 손쉽게 통합할 수 있습니다.\n\n기본 제스처 인식기\n\nSwiftUI에는 여러 내장 제스처가 포함되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 탭 제스처: 탭 상호작용을 감지합니다.\n- 롱 프레스 제스처: 롱 프레스 상호작용을 감지합니다.\n- 드래그 제스처: 드래깅 상호작용을 감지합니다.\n\n탭 제스처 예제\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct TapGestureView: View {\n    @State private var message = \"어디서나 탭하세요\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.yellow)\n            .onTapGesture {\n                message = \"탭되었습니다!\"\n            }\n    }\n}\n```\n\n이 예제에서 텍스트를 탭하면 메시지가 \"탭되었습니다!\"로 변경됩니다.\n\nLongPressGesture 예제\n\n```swift\nimport SwiftUI\n\nstruct LongPressGestureView: View {\n    @State private var message = \"길게 눌러 변경하세요\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.green)\n            .onLongPressGesture {\n                message = \"길게 눌렀습니다!\"\n            }\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 메시지를 \"길게 눌렀습니다!\"로 변경합니다.\n\n드래그 제스처 예제\n\n```swift\nimport SwiftUI\n\nstruct DragGestureView: View {\n    @State private var offset = CGSize.zero\n\n    var body: some View {\n        Text(\"드래그해 보세요\")\n            .padding()\n            .background(Color.blue)\n            .offset(offset)\n            .gesture(\n                DragGesture()\n                    .onChanged { gesture in\n                        offset = gesture.translation\n                    }\n                    .onEnded { _ in\n                        offset = .zero\n                    }\n            )\n    }\n}\n```\n\n텍스트를 드래그하여 화면 상에서 이동하고 놓을 때 위치가 재설정됩니다.\n\n<div class=\"content-ad\"></div>\n\n2. 고급 제스처 기술\n\n동시 제스처 인식\n\n동시에 여러 제스처를 처리하면 더 다이내믹한 상호작용을 만들 수 있어요.\n\n확대/축소(Pinch-to-Zoom) 및 이동(Pan) 예제\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct PinchAndPanView: View {\n    @State private var scale: CGFloat = 1.0\n    @State private var offset = CGSize.zero\n\n    var body: some View {\n        Image(systemName: \"photo\")\n            .resizable()\n            .scaledToFit()\n            .scaleEffect(scale)\n            .offset(offset)\n            .gesture(\n                SimultaneousGesture(\n                    MagnificationGesture()\n                        .onChanged { value in\n                            scale = value\n                        },\n                    DragGesture()\n                        .onChanged { value in\n                            offset = value.translation\n                        }\n                )\n            )\n    }\n}\n```\n\n이 예제는 사용자가 이미지를 확대 및 축소하고 동시에 이동할 수 있도록 합니다.\n\n사용자 정의 제스처 인식기\n\n사용자 지정 제스처를 만들면 앱에 특정한 독특한 상호작용을 추가할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct CustomGestureView: View {\n    @State private var message = \"오른쪽으로 스와이프하여 나타납니다\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.orange)\n            .gesture(\n                DragGesture(minimumDistance: 50)\n                    .onEnded { value in\n                        if value.translation.width > 50 {\n                            message = \"나타났습니다!\"\n                        }\n                    }\n            )\n    }\n}\n```\n\n이 사용자 정의 제스처에서 오른쪽으로 스와이핑하면 메시지가 나타납니다.\n\n제스처 수정자\n\n여러 제스처 인식기를 연결하면 복잡한 상호 작용을 만들 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n길게 누른 후 스와이프\n\n```js\nimport SwiftUI\n\nstruct LongPressAndSwipeView: View {\n    @State private var message = \"길게 누르고 스와이프하세요\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.purple)\n            .gesture(\n                LongPressGesture(minimumDuration: 1)\n                    .onEnded { _ in\n                        message = \"이제 스와이프하세요\"\n                    }\n                    .simultaneously(\n                        with: DragGesture(minimumDistance: 50)\n                            .onEnded { value in\n                                if value.translation.width > 50 {\n                                    message = \"스와이프했어요!\"\n                                }\n                            }\n                    )\n            )\n    }\n}\n```\n\n이 예제는 메시지를 변경하려면 길게 누른 후에 스와이프해야 합니다.\n\n3. 실용적인 예제 및 사용 사례\n\n<div class=\"content-ad\"></div>\n\n사진 편집 앱: 드래그 제스처로 조정하기\n\n```js\nimport SwiftUI\n\nstruct PhotoEditingView: View {\n    @State private var brightness: Double = 0.0\n\n    var body: some View {\n        VStack {\n            Image(systemName: \"photo\")\n                .resizable()\n                .scaledToFit()\n                .brightness(brightness)\n                .gesture(\n                    DragGesture()\n                        .onChanged { value in\n                            brightness = Double(value.translation.height / 100)\n                        }\n                )\n            Text(\"드래그하여 밝기 조정\")\n        }\n    }\n}\n```\n\n위아래로 드래그하여 이미지의 밝기를 조정할 수 있어요.\n\n그림 그리기 앱: 드래그 제스처로 선 그리기\n\n<div class=\"content-ad\"></div>\n\n```js\nimport SwiftUI\n\nstruct DrawingView: View {\n    @State private var points: [CGPoint] = []\n\n    var body: some View {\n        Canvas { context, size in\n            for point in points {\n                context.fill(Path(ellipseIn: CGRect(origin: point, size: CGSize(width: 5, height: 5))), with: .color(.black))\n            }\n        }\n        .gesture(\n            DragGesture()\n                .onChanged { value in\n                    points.append(value.location)\n                }\n                .onEnded { _ in\n                    // 선택적으로 제스처 종료 처리\n                }\n        )\n    }\n}\n```\n\n이 예제는 사용자가 화면을 드래그하여 선을 그릴 수 있도록 합니다.\n\n게임 앱: 스와이프로 이동\n\n```js\nimport SwiftUI\n\nstruct GamingView: View {\n    @State private var position = CGSize.zero\n\n    var body: some View {\n        Circle()\n            .frame(width: 50, height: 50)\n            .offset(position)\n            .gesture(\n                DragGesture(minimumDistance: 50)\n                    .onEnded { value in\n                        if abs(value.translation.width) > abs(value.translation.height) {\n                            if value.translation.width > 0 {\n                                position.width += 50\n                            } else {\n                                position.width -= 50\n                            }\n                        } else {\n                            if value.translation.height > 0 {\n                                position.height += 50\n                            } else {\n                                position.height -= 50\n                            }\n                        }\n                    }\n            )\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n스와이핑은 스와이프 방향으로 원을 이동시킵니다.\n\n4. 프로 팁 및 고려 사항\n\n제스처 충돌 처리\n\n여러 제스처가 동시에 인식될 수 있는 경우, 제스처를 우선순위를 정하거나 배타적 제스처 인식을 사용하세요.\n\n<div class=\"content-ad\"></div>\n\n```swift\nimport SwiftUI\n\nstruct GestureConflictView: View {\n    @State private var message = \"탭 또는 길게 누르기\"\n\n    var body: some View {\n        Text(message)\n            .padding()\n            .background(Color.gray)\n            .gesture(\n                TapGesture()\n                    .onEnded {\n                        message = \"탭!\"\n                    }\n                    .exclusively(\n                        before: LongPressGesture()\n                            .onEnded { _ in\n                                message = \"길게 눌렀어요!\"\n                            }\n                    )\n            )\n    }\n}\n```\n\n이 예제에서는 탭 제스처가 길게 누르기 제스처보다 우선합니다.\n\n접근성 고려사항\n\n보이스오버와 같은 보조 기술을 사용하는 데 제스처를 사용할 수 있도록 보장하세요. 예를 들어, 버튼이나 다른 UI 요소를 통해 작업을 수행할 수 있는 대안 방법을 제공하세요.\n\n<div class=\"content-ad\"></div>\n\nSwiftUI에서 제스처를 마스터하는 것은 상호작용적이고 매력적인 앱을 만들기 위해 꼭 필요합니다. 다양한 제스처 인식기를 이해하고 구현함으로써 사용자 경험을 향상시키고 동적 상호작용을 만들 수 있습니다. 이러한 예제들을 실험해보고 추가 제스처 인식기와 서드파티 라이브러리를 탐구하여 SwiftUI 프로젝트를 더욱 발전시켜 보세요.","ogImage":{"url":"/assets/img/2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringGesturesinSwiftUIAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":9},{"title":"SwiftUI 앱을 위한 디자인 패턴 선택하기","description":"","date":"2024-06-22 23:06","slug":"2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp","content":"\n\n디자인 패턴은 문제를 해결해야 합니다\n\n![이미지](/assets/img/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp_0.png)\n\n2022년 초, 저는 라커우드에 소재한 소프트웨어 컨설팅 회사인 우드리지 소프트웨어에서 근무하고 있었습니다. 그때 한 고객이 저희에게 수년간 지속될 대규모 기업용 앱을 개발해 달라는 요청을 했습니다. 프로젝트의 범위가 크기 때문에, 저희는 SwiftUI로 완전히 앱을 구축하는 도전을 수용하기로 결정했습니다.\n\n우드리지의 iOS 팀 아키텍트로서, 저는 앱의 아키텍처를 기획하는 업무를 맡았습니다. 이런 방대한 프로젝트에 SwiftUI를 도입하는 것은 잘 정립된 아키텍처적인 모베스트 프랙티스의 부재로 독특한 도전이었습니다. 제가 디자인 패턴을 선택하고 나중에 발명하게 된 여정은 세 단계로 나뉘었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 첫 번째 단계: UIKit 친화적인 디자인 패턴 선택하기\n\nUIKit 개발자로서, 저는 처음에는 UIKit 세계에서 잘 작동하는 아키텍처 패턴을 선택하는 것이 최선일 것이라고 생각했습니다. 그러나 이는 문제가 있었고, 그 이유는 간단한 역사 수업 이후에 가장 잘 설명됩니다.\n\n## iOS 아키텍처 간단 역사\n\n애플이 2008년에 iPhone SDK를 출시했을 때, UIKit 애플리케이션을 구축하기 위한 권장 디자인 패턴은 MVC(Model-View-Controller)였습니다. 이 패턴은 데이터 모델, 뷰 및 이들을 연결하는 컨트롤러(UIKit에서는 뷰와 컨트롤러가 단일 \"뷰 컨트롤러\"로 결합됩니다)를 포함합니다. 기본적인 것을 넘어서 애플리케이션의 복잡도가 증가할수록, 이 패턴은 종종 익숙한 문제인 거대한 뷰 컨트롤러로 이어집니다.\n\n<div class=\"content-ad\"></div>\n\n대형 뷰 컨트롤러가 생긴 이유는 여러 가지가 있습니다. 예를 들어 UIKit 내에서 뷰 구성(큰 뷰를 작은 하위 뷰로 분해하는 것)을 사용하기가 매우 어렵기 때문에 대부분의 개발자들이 포기하고 앱의 전체 화면 당 하나의 뷰 컨트롤러를 만들어 각 뷰 컨트롤러를 불합리하게 늘리고 있습니다. 게다가 대부분의 뷰 컨트롤러가 네트워킹과 같은 공통 기능을 추가하여 부풀게되어 있습니다. 또한 모바일 애플리케이션에서 가장 중요한 측면 중 하나인 상태 관리도 쉽지 않았습니다. 애플리케이션 상태의 저장 및 관리는 대부분 개발자에게 맡겨져 있어 결과적으로 모든 것이 기본적으로 뷰 컨트롤러에 저장되었습니다.\n\n총론적으로 문제는 뷰 컨트롤러가 맡은 책임이 너무 많았던 것입니다. 이 문제를 해결하기 위해 개발자들은 일반적으로 뷰 컨트롤러가 보유하던 관심사를 분리하여 해결하려는 의도로 많은 추가 디자인 패턴을 사용했습니다:\n\n- MVP (Model-View-Presenter): 각 뷰 컨트롤러와 데이터 모델 간의 통신을 처리하는 \"프레젠터\" 구성 요소를 소개합니다.\n- MVVM (Model-View-ViewModel): MVP와 유사하게, 각 뷰 컨트롤러에 데이터 모델과 통신을 원활하게 하는 \"뷰 모델\"이라고 불리는 구성 요소가 포함됩니다. 뷰 모델은 프레젠터와 차이점이 있으며 뷰 상태를 저장하고 그 상태를 직접 관련된 뷰에 바인딩합니다.\n- Coordinator: 코디네이터 구성 요소는 네비게이션 관심사를 뷰 컨트롤러로부터 분리합니다.\n- VIPER (View-Interactor-Presenter-Entity-Router): 아마도 그중에서 가장 복잡한 VIPER는 뷰 컨트롤러가 일반적으로 맡은 각 관심사를 개별 구성 요소로 분리하려고 합니다. 뷰(뷰 컨트롤러)는 UI 표시만 다루며, 프레젠터는 뷰용 데이터를 조작하며, 인터랙터는 비즈니스 로직을 처리하며, 엔티티는 기본 데이터 모델을 표현하며, 라우터는 네비게이션을 다룹니다.\n\n## SwiftUI 도입\n\n<div class=\"content-ad\"></div>\n\n2019년에 Apple은 새로운 UI 프레임워크인 SwiftUI를 소개했습니다. SwiftUI는 UIKit과 매우 다릅니다. UIKit은 명령형인 반면, SwiftUI는 선언적입니다. 개발자가 뷰를 직접 처리하는 대신, UI가 어떻게 보여야 하는지를 지정하고 프레임워크가 나머지를 처리합니다. 개발자가 상태 관리를 직접 처리하는 대신 SwiftUI에는 내장된 상태 관리가 있으며 상태 변경 시 뷰 업데이트를 자동으로 처리합니다. UIKit에서 뷰 구성이 어려운 반면, SwiftUI에서는 기본적인 것입니다.\n\n보시다시피, SwiftUI는 단순히 새로운 UI 프레임워크가 아닙니다. UIKit과 너무 다르기 때문에 우리가 하는 게임을 완전히 바꿉니다. UIKit에서 발생했던 대규모 뷰 컨트롤러 문제가 SwiftUI 세계에 존재하지 않으므로 이 문제를 해결하기 위해 특별히 고안된 디자인 패턴을 사용할 필요가 없음을 의미합니다.\n\n따라서 UIKit 친화적인 디자인 패턴을 선택하는 것이 처음에는 합리적으로 보일지라도, 이러한 패턴이 SwiftUI 세계에서는 존재하지 않는 문제를 해결하려는 것임을 빨리 깨닫게 됩니다. 더구나 VIPER와 같은 몇 가지 패턴은 개발자가 좋은 SwiftUI 코드를 작성하는 것을 방해할 수도 있습니다. VIPER와 같은 패턴은 뷰당 중요한 보일러플레이트를 생성하여 각 뷰가 많은 코드와 복잡성을 추가하기 때문에, 개발자들이 뷰를 더 작은 단위로 나누는 것을 열심히 하지 않게 됩니다. Michael Long이 이에 대해 상세히 쓴 바 있습니다.\n\n결국, 디자인 패턴은 문제를 해결하기 위해 존재해야 하며, 가능한 문제를 만들어서는 안 됩니다. UIKit 친화적 아키텍처는 대규모 뷰 컨트롤러 문제를 해결하기 위해 고안된 것인 반면, 이 문제가 SwiftUI에서는 더 이상 존재하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# 두 번째 단계: 가장 추천되는 SwiftUI 디자인 패턴 선택: MVVM\n\n알겠어요, 지금 UIKit 지식을 적용해도 이 문제를 해결할 수 없을 거에요. 그래서 웹을 철저히 조사해본 결과, 대부분의 사람들이 MVVM을 표준 SwiftUI 디자인 패턴으로 추천하고 있어요.\n\n이전에 언급한 바와 같이, MVVM은 각 뷰가 자체 ViewModel 구성 요소를 갖고, 해당 상태와 비즈니스 로직을 포함하며, ViewModel은 상태를 직접 뷰에 바인딩할 것을 규정하고 있어요. 이는 SwiftUI의 상태 중심 및 바인딩 기반 구조에 매우 적합한 후보로 보이며, ObservableObject(그리고 새 @Observed 매크로)를 사용하여 쉽게 구현할 수 있어요.\n\n이 접근 방식에는 장단점이 있어요. 장점은 MVVM이 비즈니스 로직을 뷰에서 분리하여 이식 가능하고 테스트하기 쉽게 만든다는 것입니다. 그러나 SwiftUI에서 MVVM을 사용하는 단점은 많으며, 내 의견으로는 장점을 상회한다고 생각해요:\n\n<div class=\"content-ad\"></div>\n\n- 개발자들은 ViewModels 내에서 withAnimation, @FocusState, @FetchRequest 등과 같은 SwiftUI 기능을 사용할 수 없습니다. 이겈 view models는 그냥 보통의 클래스이기 때문에 그들은 뷰가 아니며, 따라서 뷰의 기능 세트를 활용할 수 없습니다. 이러한 제한을 피하기 위해 우회 방법을 사용하는 것은 번거로울 수 있습니다.\n- SwiftUI 뷰 간의 데이터 전달은 도전적인 과제가 됩니다. 왜냐하면 이제는 바인딩을 쉽게 사용하거나 뷰 모델 내에서 환경에서 정보에 액세스할 수 없기 때문입니다(@Environment 또는 @EnvironmentObject를 통해).\n- ViewModel에서 하나의 속성을 변경하면 해당 속성이 연관된 전체 뷰가 아닌 이 뷰를 무효화시키는 문제가 발생합니다(이는 iOS 17의 새로운 관찰 시스템으로 해결되었지만, iOS 17 이전의 SwiftUI 버전에는 여전히 언급할 가치가 있습니다).\n- MVVM은 비즈니스 로직과 뷰를 강하게 결합하기 때문에 뷰 구성을 억제할 수 있습니다. 단일 뷰를 여러 개의 뷰로 분해하면 여러 개의 새로운 뷰 모델을 생성하고 그들 사이의 복잡한 데이터 흐름을 조율해야 합니다.\n\n이러한 단점을 고려하면 SwiftUI에 적용할 때 MVVM은 적합한 도구가 아닌 것으로 판단됩니다. 이 패턴은 효과적으로 뷰와 비즈니스 로직을 분리하지만 이 과정에서 개발자와 핵심 SwiftUI 기능 사이에 수많은 장애물이 놓여 있습니다. SwiftUI의 세계에 더 적합한 것을 찾아야 한다고 생각합니다. 이것이 저만의 의견이 아닌 것 같습니다.\n\n# 세 번째 단계: 새로운 시도\n\n그렇다면 이제 어떻게 해야 할까요? SwiftUI와 같이 상대적으로 새로운 프레임워크를 사용하는 것은 최상의 방법이 아직 확립되지 않았다는 것이 멋진 점이자 무서운 점입니다. 다른 사람들이 당신을 위해 길을 밟은 사례를 더 찾아보면, 당신이 하나의 길을 밟는이라는 것을 더 많이 깨닫게 됩니다. 이를 염두에 두고, 우리가 나름대로의 방법을 제시해야 하고, 우리만의 아키텍처 패턴을 처음부터 개발해야 할 것이라는 것을 깨달았습니다.\n\n<div class=\"content-ad\"></div>\n\n한 발 물러서서 생각을 해보면, 결국 소프트웨어 아키텍처의 목적은 무엇인가요? 아무튼 그냥 해야 하는 건가요? 아키텍처 신에게 기쁘기 위해서요?\n\n전 반대의 의견을 가지고 있어요. 제가 생각하는 아키텍처 철학은 그것이 목적을 가져야 한다는 것이에요: 문제를 해결해야 해요. SwiftUI의 본질은 방대한 뷰 컨트롤러를 만들어낸 문제들을 해결했고, 이는 더 일반적인 아키텍처 문제를 해결하는 데 노력을 집중할 수 있다는 것을 의미합니다. 그 결과로 나타나는 아키텍처는 UIKit 중심의 아키텍처보다 더 간단하고 우아할 수 있습니다.\n\n그렇다면, 더 일반적인 아키텍처로 어떤 문제들을 해결하려고 하는 것인가요? 주로 우리는 스파게티 코드를 방지하려고 하며, 코드 구조가 이해하기 쉽고 확장하기 쉬운 구조로 끝나길 원합니다. 일반적으로 유지보수 가능한 코드를 지향합니다. 이 새로운 아키텍처 패턴을 위해 선택한 일반적인 원칙들은 다음과 같아요:\n\n- 관심사 분리 (예: 뷰와 비즈니스 로직 분리)\n- DRY 원칙 준수 — 일반적인 작업들은 자체 유틸리티로 정리되어야 합니다\n- 이 패턴은 SwiftUI를 보완하고 프레임워크와 대립하지 않아야 합니다\n\n<div class=\"content-ad\"></div>\n\n## MVSU (Model-View-Service-Utility)\n\n위 요구 사항을 고려하여, 저는 MVSU라는 디자인 패턴을 고안했습니다. 이 패턴은 MVC, 도메인 주도 디자인, 그리고 Clean architecture에 깊은 뿌리를 두고 있지만, SwiftUI에 특히 잘 어울릴 것으로 생각되는 고유한 특성을 갖고 있습니다. 이 패턴은 4개 그룹의 구성 요소로 이루어져 있습니다:\n\n- **유틸리티**는 특정 작업 하나를 수행하거나 몇 가지 밀접하게 관련된 작업을 수행하는 좁게 중점을 둔 재사용 가능한 도구들입니다. 서비스는 하위 수준의 세부 사항을 걱정하지 않고 기능 수행을 가능케 합니다.\n- **서비스**는 비즈니스 로직 계층입니다. 서비스는 애플리케이션의 특정 도메인에 관련된 기능의 상태를 가지지 않은 그룹입니다. 이를 보면 뷰가 사용하는 API로 생각할 수 있습니다.\n- **모델**은 가장 일반적인 부분이며, 앱 데이터를 캡슐화하는 역할을 합니다. 서비스는 모델과 통신하여 기능을 수행합니다.\n- **뷰**는 대체로 자명하지만 알아둬야 할 몇 가지 규칙이 있습니다. 뷰는 주로 자신의 상태를 처리하며, 주로 유틸리티가 아닌 서비스를 사용하여 기능을 수행합니다. 뷰 구성을 적극적으로 활용하여 각 뷰를 쉽게 이해할 수 있는 구성 요소로 분해하여 유지하고, 그로 인해 각 뷰가 작고 중점적으로 유지됩니다.\n\n![이미지](/assets/img/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp_1.png)\n\n<div class=\"content-ad\"></div>\n\n각 구성 요소 유형에 대해 자세히 설명하겠습니다:\n\n## 유틸리티\n\n일부 앱에서 네트워킹, 알림 표시, 오류 처리 등과 같은 일반 작업은 코드베이스 전체에 흩어지거나 반복될 수 있습니다 (또는 뷰모델과 같은 중재 레이어에 위치할 수도 있습니다). MVSU는 특히 이러한 유형의 반복 작업을 “유틸리티” 접미사를 가진 클래스로 이동해야 한다고 규정합니다 (예: NetworkUtility, SessionUtility, LoggingUtility 등).\n\n단일 책임 원칙을 준수하는 한, 이러한 유틸리티는 매우 집중되어 있어야 합니다. 한 가지 유형의 작업이나 몇 가지 밀접한 관련 작업만 수행해야 합니다. 서비스는 그들의 상위 수준 기능을 수행하기 위해 유틸리티를 활용합니다. 이러한 작업을 유틸리티로 이동함으로써 코드베이스를 DRY(반복하지 마세요) 상태로 유지하고 서비스가 독자적 도메인에만 집중하도록 합니다. 여기서의 규칙은 여러 서비스가 동일한 논리를 수행한다면, 아마도 유틸리티로 이동해야 한다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```swift\nclass NetworkUtility {\n    func perform<ResultType: Decodable>(request: Request<ResultType>) async throws -> ResultType {\n        // ...\n    }\n}\n\nclass LogUtility {\n    func log(type: LogType, description: String) {\n        // ...\n    }\n}\nclass FileUtility {\n    func save(data: Data, toFileUrl fileUrl: URL) throws {\n        // ...\n    }\n    func retrieveData(fromFileUrl fileUrl: URL) throws -> Data {\n        // ...\n    }\n}\n```\n\n## 서비스\n\nMVC, MVP, MVVM, VIPER과 같은 많은 패턴은 뷰별로 비즈니스 로직을 분리합니다 (즉, 각 뷰는 별도의 컨트롤러, 뷰모델 등을 갖습니다). MVSU에서는 비즈니스 로직을 도메인별로 분리합니다. 이는 앱이 사용하는 각 데이터 유형마다 해당하는 서비스를 갖는 것을 의미합니다 (예: 도넛 가게의 경우 도넛 서비스, 주문 서비스, 사용자 서비스 등).\n\n도메인별로 비즈니스 로직을 분리하는 것에는 몇 가지 장점이 있습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 관심사 분리가 더 잘 이루어집니다: 뷰 모델과 같은 중재자는 특정 뷰에 연결되도록 설계되어 있기 때문에 해당 뷰에 대해 많은 정보를 알게 됩니다. 도메인별로 분리하면 서비스가 자신의 도메인에 대해 많은 지식을 갖지만, 뷰에 대해서는 거의 또는 전혀 알지 못합니다. 이것은 다른 뷰 모델과 달리 특정 뷰를 고려하여 설계되지 않았기 때문에 더 이동성이 있습니다.\n- 논리적으로 관련된 코드는 논리적으로 그룹화됩니다. Donut을 생성하고 삭제하는 뷰 각각을 가지는 MVVM 앱의 경우, 관련성이 높은 이 코드도 2개의 다른 뷰모델에 들어가게 되지만, MVSU에서는 해당 코드가 단일 DonutService에 모두 들어가 관련된 코드를 유지하기 쉽게 만듭니다.\n- 기능은 뷰 간에 쉽게 공유할 수 있습니다. 서비스 기능은 한 뷰 이상에서 사용될 수 있기 때문입니다. 이는 MVVM과는 달리 뷰 당 하나의 뷰모델을 가지고 있는 것과 대립적입니다.\n- 도메인별로 분리하면 SwiftUI의 뷰 구성 세계에서 boilerplate가 줄어듭니다. MVVM이나 VIPER와 같은 패턴에서 개발자들은 boilerplate로 인해 하위 뷰를 만들기가 꺼려진다. MVSU에서는 뷰 당 boilerplate가 아닌 도메인 당 boilerplate가 생기기 때문에 하위 뷰로 세분화하는 단점이 없어집니다. 이것은 SwiftUI가 거대한 뷰 컨트롤러 문제를 해결한 주요 이유이므로 아키텍처에서 하위 뷰를 권장해야 합니다.\n\n또한 서비스에 대해 더 알아야 할 점은 상태가 없다는 것입니다 - 상태는 서비스가 아닌 뷰에 저장되어야 합니다. 이에 대한 더 자세한 내용은 Views 섹션에서 설명하겠습니다.\n\n```js\n// 주입 전략은 본인에게 달려 있지만, Factory (https://github.com/hmlongco/Factory)와 같은 라이브러리를 사용할 것을 권장합니다.\n\nimport Factory\n\nclass OrderService {\n    @Injected(\\.networkUtility) private var networkUtility\n    @Injected(\\.logUtility) private var logUtility\n\n    func createOrder(items: [ItemModel]) async throws -> OrderModel {\n        do {\n            let response = try networkUtility.perform(request: .createOrder(items: items))\n            return OrderModel(record: response.order)\n        } catch {\n            logUtility.log(type: .error, description: \"Order error occurred: \\(error.localizedDescription)\")\n            throw RuntimeError(\"주문 생성이 불가능합니다.\")\n        }\n    }\n}\n```\n\n## Views\n\n<div class=\"content-ad\"></div>\n\n언급한 대로, MVSU는 뷰 구성을 권장하여 큰 뷰를 작은 뷰로 나누고, 각 뷰를 가늠있고 좁게 중점을 두어 과거의 방대한 뷰 컨트롤러 문제를 피합니다.\n\nMVSU에서 서비스는 상태를 유지하지 않습니다. 대신 뷰가 모든 필요한 상태를 유지합니다. 이는 몇 가지 이유로 인해 이루어집니다:\n\n- 관심사의 분리: 어떤 면에서는 응용 프로그램 상태는 도메인 문제가 아니라 뷰 문제입니다. 뷰의 관심사를 뷰 내부에 유지함으로써 더 유지보수 용이한 코드를 얻을 수 있습니다.\n- 향상된 가용성과 단순성: 데이터를 뷰 계층 구조를 위아래로 전달하는 것은 뷰 모델과 같은 중간 계층을 처리할 때 혼란스러운 도전이 될 수 있습니다. 대조적으로 @Binding 및 @Environment를 사용하면 매우 간단하고, 이에 따라 가용성을 촉진합니다.\n- SwiftUI 기능의 쉬운 활용: 뷰 내부에 상태를 유지하는 것은 애니메이션과 같은 기능을 쉽게 활용할 수 있게 해줍니다.\n\n```swift\nstruct OrderView: View {\n    @Injected(\\.orderService) private var orderService\n    @Injected(\\.paymentService) private var paymentService\n\n    let availableItems: [ItemModel]\n    @State private var itemsInCart: [ItemModel]\n    @State private var orderAwaitingPayment: OrderModel?\n    @State private var error: Error?\n    \n    var body: some View {\n        VStack {\n            ForEach(availableItems) { availableItem in\n                AddItemToCartButton(availableItem) { item in\n                    itemsInCart.append(item)\n                }\n            }\n\n            Divider()\n\n            // \"AsyncButton\" 뷰를 만드는 것을 강력히 권장합니다: https://www.swiftbysundell.com/articles/building-an-async-swiftui-button/\n            AsyncButton(\"Create Order\") {\n                do {\n                    orderAwaitingPayment = await orderService.createOrder(items: itemsInCart)\n                } catch let orderError {\n                    error = orderError\n                }\n            }\n        }\n        .sheet(item: $orderAwaitingPayment) { order in\n            PaymentInfoView(order: order)\n            PaymentButton() {\n                await paymentService.createPayment(forOrder: order)\n                orderAwaitingPayment = nil\n            }\n        }\n        .errorAlert(error)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n## 모델\n\n이 부분은 패턴 중 가장 독특하지 않은 부분입니다. 모델은 데이터 유형과 필요한 모든 지속성 레이어(예: Core Data, SwiftData, Realm 등)를 포함합니다. MVSU에서 SwiftUI의 기능 세트를 유지하는 것이 중요하므로 뷰는 SwiftUI의 프로퍼티 래퍼(예: @FetchRequest 또는 @Query)를 통해 모델과 직접 통신할 수 있어야 합니다.\n  \n# 결론\n\n내 의견으로는 SwiftUI의 도입은 iOS 개발 영역에서 가장 중요한 변화 중 하나입니다. SwiftUI는 그냥 새로운 UI 프레임워크가 아닙니다. UIKit과는 매우 다르기 때문에 앱을 구축하는 전체 방식에 대해 다시 생각하도록 요구한다고 생각합니다. 아마도 iOS 커뮤니티가 처음부터 아키텍처적 결정을 왜 내리는지에 대해 다시 한번 고민할 때가 되었을지도 모릅니다.\n\n<div class=\"content-ad\"></div>\n\n디자인 패턴을 선택하고 결국 만드는 과정을 거치며 왜 처음부터 일반적인 UIKit 디자인 패턴을 사용했는지 깨달았어요. 제 의견으로는 대부분의 앱에서 달성한 복잡성 수준에 UIKit이 잘 맞지 않아서, 이로 인해 우리는 특별히 설계된 아키텍처 패턴으로 문제를 해결해야 했어요. SwiftUI는 같은 문제가 없어서 그런 해결책이 필요하지 않아요.\n\n이 새로운 환경은 두렵고 흥미로운 만큼 새로운 도전이에요. 이는 불가피하게 UIKit 세계에서 연마해온 지식과 기술 일부가 적용되지 않을 수 있다는 의미예요. 또한, 우리가 나만의 방향을 개척하고, 아마도 더 이상 UIKit 개발의 최악 부분들과 다시는 싸울 필요가 없을지도 모른다는 것을 의미해요. 저는 이 길을 계속 나아가며 알려지지 않은 세계를 탐험하는 것에 흥미를 느끼고 있어요.","ogImage":{"url":"/assets/img/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp_0.png"},"coverImage":"/assets/img/2024-06-22-ChoosingaDesignPatternforyourSwiftUIApp_0.png","tag":["Tech"],"readingTime":12},{"title":"iOS 앱에서 코디네이터 패턴 사용하는 방법","description":"","date":"2024-06-22 23:06","slug":"2024-06-22-CoordinatorPatterniniOSApp","content":"\n\n# 코디네이터란 무엇인가요?\n\niOS 개발에서 코디네이터는 앱의 탐색 흐름을 처리하는 객체입니다. 때로는 \"플로우 컨트롤러\" 또는 \"라우터\"라고도 합니다.\n\n코디네이터는 뷰 컨트롤러가 어떻게 표시되고, 푸시되며 해제되는지, 앱의 다른 섹션 및 뷰가 어떻게 연결되는지에 대한 로직을 처리합니다.\n\n코디네이터는 보통 정의하는 클래스이며, 뷰 컨트롤러를 생성, 표시, 해제할 수 있는 메서드와 함께 정의됩니다. 앱의 흐름이 복잡한 경우에는 다른 코디네이터와 필요한 경우 통신할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# MVVM+C 패턴이란 무엇인가요?\n\n일반적인 iOS 개발(예: MVC 패턴)에서는 일반적으로 네비게이션의 책임이 뷰 컨트롤러에게 주어집니다. 그러나 더 복잡한 플로우(예: 뷰 컨트롤러 간의 강한 결합, 코드 재사용성의 부족 및 테스트 문제 등)에서 많은 문제가 발생할 수 있습니다.\n\nMVVM+C(가끔 \"Coordinator 패턴\"이라고도 부릅니다)은 앱 내에서 책임을 분리하는 것을 촉진하는 디자인 패턴입니다. 특히 네비게이션 및 플로우 제어에 있어서 책임을 분리하도록 권장합니다.\n\n간단히 설명하면, 이 패턴에서 ViewModel은 데이터를 UI 요소에 바인딩하고 데이터가 변경되는 즉시 UI를 변경합니다. ViewController의 책임은 UI에서 발생하는 이벤트를 ViewModel에 알리는 것이므로 ViewModel이 해당 이벤트에 적절히 반응할 수 있습니다. 그리고 Coordinator가 네비게이션 로직을 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n이 패턴에 대한 훌륭한 기사가 있어요. 꼭 읽어보시길 추천합니다!\n\n## 코디네이터를 사용하는 장점은 무엇인가요?\n\n- 관심사 분리 (각 모듈이 단일 책임을 갖습니다)\n- 거대한 ViewControllers와 ViewModels 피하기\n- UI를 가능한 가장 덤하고 재사용 가능하게 유지\n- RX-Swift, Combine과 같은 반응적인 프레임워크와 뛰어난 호환성을 보여줍니다!\n\n## 코드 예시\n\n<div class=\"content-ad\"></div>\n\n여기에는 “MainCoordinator”가 네비게이션 스택에 “ViewController”를 푸시하는 간단한 예제가 있습니다.\n\n“SecondViewController”로 이동하려면 해당하는 코디네이터에서 네비게이션을 처리하는 “goToSecondVC” 메서드를 호출하면 됩니다. 이렇게 하면 뷰 컨트롤러가 자체적으로 네비게이션을 처리할 필요가 없어집니다.\n\n```js\n// 먼저, 코디네이터를 위한 프로토콜을 정의해봅시다\n\nprotocol Coordinator {\n    var childCoordinators: [Coordinator] { get set }\n    var navigationController: UINavigationController { get set }\n    \n    func start()\n}\n\n\n// 그 다음, 코디네이터(MainCoordinator)를 생성해봅시다\n\nclass MainCoordinator: Coordinator {\n    var childCoordinators = [Coordinator]()\n    var navigationController: UINavigationController\n\n    init(navigationController: UINavigationController) {\n        self.navigationController = navigationController\n    }\n\n    func start() {\n        let vc = ViewController.instantiate()\n        vc.coordinator = self\n        navigationController.pushViewController(vc, animated: false)\n    }\n    \n    func goToSecondVC() {\n        let secondVC = SecondViewController.instantiate()\n        secondVC.coordinator = self\n        navigationController.pushViewController(secondVC, animated: true)\n    }\n}\n\n// 마지막으로, \"AppDelegate\"나 \"SceneDelegate\"에서\n// 메인 코디네이터를 인스턴스화하고 시작하는 방법입니다\n\nvar mainCoordinator: MainCoordinator?\n\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    let navController = UINavigationController()\n    mainCoordinator = MainCoordinator(navigationController: navController)\n    mainCoordinator?.start()\n\n    window = UIWindow(frame: UIScreen.main.bounds)\n    window?.rootViewController = navController\n    window?.makeKeyAndVisible()\n    return true\n}\n```\n\n읽어 주셔서 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n\n![Coordinator Pattern in iOS App](/assets/img/2024-06-22-CoordinatorPatterniniOSApp_0.png)\n","ogImage":{"url":"/assets/img/2024-06-22-CoordinatorPatterniniOSApp_0.png"},"coverImage":"/assets/img/2024-06-22-CoordinatorPatterniniOSApp_0.png","tag":["Tech"],"readingTime":3},{"title":"SwiftUI에서 MainActor를 사용하는 방법","description":"","date":"2024-06-22 23:05","slug":"2024-06-22-MainActorSwiftUI","content":"\n\n안녕하세요 여러분, 이 기사에서는 @MainActor를 사용하여 Swift 및 SwiftUI에서 주 스레드에서 작업을 수행하는 방법에 대해 논의할 것입니다.\n\n![이미지](/assets/img/2024-06-22-MainActorSwiftUI_0.png)\n\nSwift에서 @MainActor를 소개하면 동시성 관리에서 중요한 단계가 이루어집니다. 이는 사용자 인터페이스 작업을 안전하고 원활하며 이해하기 쉽게 보장하는 강력하고 직관적인 메커니즘을 제공합니다.\n\nSwift 5.5 이상에서 @MainActor 속성은 async/await 동시성 모델에서 중요한 역할을 합니다. 이 기능은 코드의 특정 부분을 주 스레드에서 실행하도록 자동으로 조정하여 동시성 프로그래밍을 더 접근 가능하고 안전하며 오류 발생 가능성이 적도록 만듭니다. UIKit 및 SwiftUI는 데이터 문제를 예방하고 좋은 사용자 경험을 보장하기 위해 이러한 작업이 주 스레드에서 실행되어야 합니다. UI 관련 작업에 대해 매우 중요하므로 주요하게 고려해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n글로벌 액터의 주요 목표는 주 스레드에 초점을 맞추고 사용자 인터페이스를 업데이트하는 작업을 관리하는 것입니다. MainActor라는 글로벌 액터는 주 스레드를 나타내며 사용자 인터페이스에 빠른 변경이 필요한 상황에서 매우 유용합니다.\n\n주 액터는 Dispatch 라이브러리를 활용하는 시스템에서 기본 동시성 메커니즘으로 작동하며 주 디스패치 대기열(DispatchQueue.main)을 특수 executor로 래핑합니다.\n\n## 주 스레드에서 작업하기\n\n주 스레드는 UI 관련 변경이 반드시 발생해야 하는 특별한 스레드로 간주됩니다. 애플리케이션에서 API 응답을 기다리거나 파일을 압축하거나 파일을 다운로드하는 것과 같은 시간이 많이 소요되는 작업이 있는 경우 이 작업을 별도의 백그라운드 스레드에서 실행한 다음 작업이 완료되면 사용자 인터페이스를 업데이트하기 위해 다시 주 스레드로 돌아가는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\nXcode에서 UI를 업데이트할 때 변수의 값을 변경하는지 확인할 수 없는 경우 오류가 발생합니다. 따라서 주 스레드에서 작업을 관리하는 것이 매우 중요합니다.\n\n![Main Actor in SwiftUI](/assets/img/2024-06-22-MainActorSwiftUI_1.png)\n\n주 스레드에서 작업을 수행하기 위한 전통적인 방법은 DispatchQueue.main.async를 사용하는 것입니다.\n\n```js\nDispatchQueue.main.async {\n  // 여기서 UI 업데이트를 수행할 수 있습니다.\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그러나 Swift 동시성을 사용할 경우, 다른 @MainActor 클로저를 동기화하거나 MainActor.run() 메서드 대신 사용할 수 있습니다. 이를 위해 선호하는 세 가지 다른 방법이 있습니다.\n\n```js\n// (1)\nTask.detached { @MainActor in\n  // 여기서 UI 업데이트를 수행할 수 있습니다.\n}\n\n// (2)\nTask { @MainActor [weak self] in\n  // 여기서 UI 업데이트를 수행할 수 있습니다.\n}\n\n// (3)\nTask {\n  await MainActor.run { [weak self] in\n    // 여기서 UI 업데이트를 수행할 수 있습니다.\n  }\n}\n```\n\n자동으로 주 스레드에서 작업하기\n\n@MainActor의 가장 인상적인 기능은 주로 업무를 수행하기 위해 일반적으로 우리가 추가적인 작업을 수행할 필요 없이 함수나 모든 변수를 주 스레드에서 자동으로 실행할 수 있는 능력입니다. 대부분의 경우 컴파일러가 자동으로 작업을 처리하기 때문에 수동으로 주 스레드에 입력하고 작업을 수행할 필요가 없어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n사실 클래스, 구조체, 함수 또는 변수에 @MainActor 선언을 추가하면 Swift 컴파일러에게 \"이 코드가 메인 스레드에서 실행되도록 해주세요!\" 라고 말하는 것입니다. 이 기능은 특히 UI 업데이트, 이벤트 처리 및 메인 스레드에 의존하는 API와 상호 작용할 때 유용합니다.\n\nMainActor는 특별한 속성으로 볼 수 있으며 프로퍼티 래퍼 유형이나 결과 빌더 유형과 유사합니다. @MainActor를 사용하여 선언이 메인 액터에서 격리되도록 지정할 수 있습니다. 이 경우 일반적인 액터 격리 제약이 적용됩니다: 메인 액터로 정의된 구조체에 대한 액세스는 다른 메인 액터에서 동기화될 수 있으며 그렇지 않으면 비동기적으로 액세스해야 합니다.\n\n```js\n@Observable\nclass LoginViewModel {\n    @MainActor var showButton = false\n\n    @MainActor func showLoginButton() {\n        showButton = true\n    }\n\n    func hideLoginButton() {\n        Task {\n            await MainActor.run {\n                showButton = false\n            }\n        }\n    }\n\n    func printButtonValue() async {\n        print(showButton) // 에러 없음, 'await'으로 표시되지 않음\n        print(await showButton) // 에러 없음\n    }\n}\n```\n\n또는 클래스를 직접 표시할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n@MainActor\nclass NewWeatherViewModel: ObservableObject {\n    @Published var currentTemperature: Double = -5.2\n    @Published var city: String = \"시바스\"\n    @Published var isSnowing: Bool = false\n    @Published var isRaining = false\n}\n```\n\n`@MainActor`으로 선언을 표시하면 컴파일러에게 이 작업이 메인 스레드에서 호출되어야 하며, 다른 코드에서 동시성을 인식하도록 이 작업을 수행하라고 지시합니다. 그러나 많은 코드가 동시성에 대한 인식이 부족하며, @MainActor는 현재 이러한 경우에 아무것도 수행하지 않습니다. 왜냐하면 그렇게 한다면 과도한 경고가 발생할 수 있기 때문입니다. 실제로 안전한 경우에도 심지어 상황적으로 안전하더라도.\n\n오래된 스타일의 완료 처리기 내에서 @MainActor 코드를 호출하고 있다면, 현재 메인 스레드로 명시적으로 반환해야 합니다. 가능하면 완료 처리기를 비동기 함수로 변환하거나 완료 처리기에 @Sendable 또는 @MainActor 주석을 추가하십시오.\n\n## 이 모든 것을 요약하면\n\n<div class=\"content-ad\"></div>\n\n주로 사용자 인터페이스를 업데이트하는 작업과 관련이 있지만, @MainActor의 영향은 iOS 애플리케이션의 기본 아키텍처에도 미치는 것이죠. 이 기능은 더 예측 가능하고 안전한 동시성 모델을 제공하여 보다 견고하고 지속 가능한 코드 작성을 촉진합니다. MainActor를 사용할 때 다음 사항에 주의하는 것이 중요합니다:\n\n- 선택적 사용: 사용자 인터페이스 또는 주 스레드를 활용하는 다른 API와 상호 작용이 필요한 작업에 MainActor를 사용하세요.\n- 성능: 주 스레드 관리를 간소화하고 불필요한 주 스레드 작업을 피하면서 응용 프로그램 성능을 고려하세요.\n- 다른 동시성 도구와 통합: @MainActor를 Swift의 다양한 동시성 기능과 함께 사용하여 포괄적이고 안전한 애플리케이션을 구축하세요. MainActor가 iOS 개발 프로세스에 가져다주는 혁신은 개발자들에게 더 안전하고 깨끗하며 효율적인 코드를 작성할 수 있는 기회를 제공합니다. 이 기능은 동시성이 관리 가능하고 견고한 애플리케이션 아키텍처에 기본적인 Swift 개발의 새 시대를 시작합니다.\n\n이상으로 Main actor에 대해 말씀드렸습니다. 다음 기사가 나올 때까지 즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-22-MainActorSwiftUI_0.png"},"coverImage":"/assets/img/2024-06-22-MainActorSwiftUI_0.png","tag":["Tech"],"readingTime":5},{"title":"단일 책임 원칙SRP에 깊이 파고들기 더 좋은 코드 작성 방법 알아보기","description":"","date":"2024-06-22 23:04","slug":"2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple","content":"\n\n## SRP를 수용하는 것이 어떻게 코딩 방법을 변화시키고 확장 가능한 소프트웨어를 이끌어낼 수 있는지 알아보세요.\n\n![SRP](/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png)\n\n# SOLID 원칙이란 무엇인가요?\n\n모든 직업에는 준수해야 할 표준과 엄격한 규칙이 있으며, 이를 어기는 경우 중요한 결과가 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 건축가가 건물 규정을 준수하여 구조물의 안전과 안정성을 보장해야 하는 방법을 생각해보세요.\n\n이러한 기준들이 왜 만들어졌을까요?\n\n- 많은 사람들이 동일한 과정을 거쳤고 그 경험은 모범 사례에 대한 집단적인 이해를 기여합니다.\n- 표준을 준수하는 것은 실수 가능성을 줄입니다. 전문가들이 따를 수 있는 명확하고 검증된 방법을 제공하여 일관성과 신뢰성을 보장합니다.\n- 표준은 모든 잠재적인 문제 영역에 대한 지식을 포괄합니다. 이러한 문제를 다루고 완화하는 방식으로 정의되어 있습니다.\n\n마찬가지로, 소프트웨어 개발에서,\n\n<div class=\"content-ad\"></div>\n\nSOLID 원칙은 깨끗하고 유지보수가 쉽고 견고한 코드를 작성하기 위한 표준을 제공하기 위해 만들어졌어요.\n\n- 이러한 원칙은 많은 개발자들의 경험과 소프트웨어 설계에서 가장 잘 작동하는 것에 대한 지식을 바탕으로 합니다.\n\nSOLID 원칙을 준수함으로써, 개발자들은 오류를 최소화하고 잠재적인 문제를 해결하며 이해하기 쉽고 확장 및 유지보수가 쉬운 소프트웨어를 만들 수 있어요.\n\n# 단일 책임 원칙(SRP)란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n- 이제 모든 개발자는 \"책임\"을 각자 다르게 해석할 수 있습니다\n- 컴포넌트를 디자인할 때, 한 명의 개발자는 전체 컴포넌트의 생성을 단일 책임으로 간주할 수 있습니다\n- 또 다른 개발자는 뷰 및 네트워크 호출을 별도의 관심사로 처리하도록 더 세분화된 책임 분할을 옹호할 수 있습니다\n\n명확하게 하기 위해, 우리는 종종 SRP를 클래스가 하나의 변경 이유만을 가져야 한다는 개념으로 표현합니다.\n\n간단히 말해서, 클래스가 여러 이유로 수정이 필요한 경우 SRP를 위반합니다.\n\n## 이젠 ProfileVC가 이 원칙을 어기는지 살펴봅시다\n\n<div class=\"content-ad\"></div>\n\n```swift\nclass ProfileVC: UIViewController {\n  override func viewDidLoad() {\n    fetchImageFromAPI()\n  } \n\n  func fetchImageFromAPI() {\n    APIService.callAPI(with: url) { response in \n      handleResponse(response: response)\n    }\n  }\n\n  func handleResponse(response: Result<Data, Error>) {\n    switch response {\n    case .success(let data):\n      processImage(data: data)\n    case .failure(let error):\n      print(\"Failed to fetch data: \\(error)\")\n   }\n  }\n\n  func processImage(data: Data) {\n    // process image\n    displayDataOnUI(data: data)\n  } \n\n  func displayDataOnUI(data: Data) {\n    print(\"Updating UI with data\")\n  }\n\n}\n```\n\n`ProfileVC`는 다음과 같은 책임을 갖습니다:\n- 서비스에서 데이터를 가져오기 [위반]\n- 응답 처리하기 [위반]\n- 이미지 처리하기 [위반]\n- 이미지 표시하기 [유효]\n\n# ProfileVC에 단일 책임 원칙(SPR) 적용해보기\n\n- ImageLoader\n\n\n<div class=\"content-ad\"></div>\n\n\n// ImageLoader는 오직 한 가지 책임만을 가지고 있습니다.\n// 네트워크에서 이미지를 로드하고 전달하는 것입니다.\n\nclass ImageLoader {\n\n  func fetchImageFromAPI(completion: @escaping ResultCompletion) {\n    APIService.callAPI(with: url) { response in \n      completion(response)\n    }\n  }\n\n}\n\n\n- ImageDecoder\n\n\n// ImageDecoder\n// 사실상, base64 이미지를 파싱하거나\n// 유사한 작업을 통해 다음 해당 인스턴스로 전달할 것입니다.\n// 디코딩 로직이 다른 구성 요소에서 수행되어야 함을 보여주기 위한 예시입니다.\n\nclass ImageDecoder {\n  let result: ResultCompletion\n  \n  init(...) {\n    self.result = result\n  }\n  \n  func decodeImage(completion: ...) -> Void)  {\n     switch result {\n      case .success(let data):\n        // 디코딩 처리\n        completion(success(data))\n      case .failure(let error):\n        completion (.failure(error))\n     }\n  }\n\n}\n\n\n- ImageProcessor\n\n\n<div class=\"content-ad\"></div>\n\n```js\n// ImageProcessor  \n\nclass ImageProcessor {\n  let imageData: Data\n  \n  init(...) {\n    self.imageData = imageData\n  }\n  \n  func processData(completion: ...) -> Void)  {\n    // Process image and pass further to the chain \n  }\n\n}\n```\n\n- ProfileVC\n\n```js\n// ProfileVC  \n\nclass ProfileVC: UIViewController {\n\n  var load: (() -> Void)?\n\n  func viewDidLoad() { \n    load()\n  } \n\n  func displayImage(_ data: Data) -> Void)  {\n    profileImage.image = UIImageFromData(data)\n  }\n\n}\n```\n\nProfileVC now only has a display method that will present the changes to the user\n\n<div class=\"content-ad\"></div>\n\n## 이제 조립이 시작됩니다, 실제 작업\n\n여기에 모든 구성 요소가 결합됩니다\n\n```js\n// ProfileComposer  \n// 이것은 이해하기 쉽도록 가장 간단한 조합 형태입니다\n// 권장하는 방법은 디자인 패턴을 사용하는 것입니다. \n\nfinal class ProfileComposer {\n  func makeProfileVC() {\n    let profileVC = ProfileVC()\n\n    profileVC.load = {\n      imageLoader.loadImage() {\n         imageDecoder.decodeImage() {\n            imageProcessor.processImage() { data in\n                profileVC.displayImage(data)\n            }\n         }\n      }\n    }\n\n    // ProfileVC의 탐색 처리\n\n  }\n}\n```\n\n# 이점은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n## 유지 관리성, 재사용성 및 명확성\n\nImageLoader, ImageProcessor 및 ImageResponseHandler와 같은 개별 구성 요소로 기능을 분리하면 유지 관리성이 향상되고 재사용성이 높아지며 명확한 책임을 가지므로 코드 가독성이 향상됩니다.\n\n## 추상화\n\nProfileVC는 특정 데이터 원본과 분리되어 있어 UI 표현에만 집중할 수 있도록 해 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 향상된 테스트 용이성\n\n구성 요소가 격리되면 외부 종속성없이 개별 기능의 심층 테스트 또는 모의적 사용이 가능해집니다.\n\n## 결합도 감소\n\nSRP를 따르면 구성 요소 간 종속성이 최소화되어 의도하지 않은 상호 작용의 위험을 낮추고 시스템의 유연성과 견고함을 향상시킵니다.","ogImage":{"url":"/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png"},"coverImage":"/assets/img/2024-06-22-DiveDeepintotheSingleResponsibilityPrinciple_0.png","tag":["Tech"],"readingTime":5},{"title":"Java 추상 클래스 완벽 이해하기","description":"","date":"2024-06-22 23:03","slug":"2024-06-22-UnderstandingAbstractClassesinJava","content":"\n\n![Understanding Abstract Classes in Java](/assets/img/2024-06-22-UnderstandingAbstractClassesinJava_0.png)\n\n# 소개\n\n대학교에서 5년 전에 자바에서 추상 클래스에 대해 처음 배웠을 때, 그것들이 혼란스러웠습니다. 처음에는 인터페이스와 같은 목적을 제공한다고 생각했습니다. 그러나 코딩 프로젝트를 통해 더 많은 경험을 쌓으면서, 추상 클래스와 인터페이스가 서로 다른 목적을 제공한다는 것을 깨달았습니다. 이 간단한 기사에서는 전형적인 Animal 클래스를 예로 들어 이러한 개념을 설명하겠습니다.\n\n# 자바에서 추상 클래스란 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n자바에서 추상 클래스는 독립적으로 인스턴스화할 수 없으며 하위 클래스로 사용되는 클래스입니다.\n\n추상 메서드를 포함할 수 있으며, 이는 구현이 없이 선언된 메서드를 의미합니다. 추상 클래스에는 구현된 메서드도 포함될 수 있습니다.\n\n# 언제 추상 클래스를 사용해야 할까요?\n\n예를 들어보겠습니다. 두 개의 클래스인 Dog와 Cat을 가정해보세요. 이 두 클래스 모두 makeSound 메서드가 필요한 경우를 상상해보세요.\n\n<div class=\"content-ad\"></div>\n\n```java\npublic class Cat {\n\n    public void makeSound() {\n        System.out.println(\"Meowww\");\n    }\n}\n// make sound method가 Cat, Dog, Elephant와 같은 각 클래스마다 있어야 하는 특정한 메서드이므로, 여기서 추상 클래스가 필요합니다.\n\nAnimal이라는 추상 클래스를 만들 수 있습니다. 클래스를 추상으로 만들기 위해서는 그냥 class 키워드 앞에 abstract 키워드를 추가하면 됩니다. 이 추상 클래스 안에는 추상 메서드를 가질 수 있습니다.\n\n다음은 선언하는 방법입니다.\n```\n\n<div class=\"content-ad\"></div>\n\n```java\npublic abstract class Animal {\n\n   abstract void makeSound();\n}\n```\n\n# 추상 클래스에 대한 주요 포인트\n\n- abstract 키워드: 메소드를 추상으로 선언하려면 abstract 키워드를 사용합니다. 추상 메소드는 본문이 없으며 하위 클래스에서 구현됩니다.\n- 객체 생성 불가: 추상 클래스의 객체를 생성할 수 없습니다. 예를 들어, Animal 객체를 생성하는 것은 의미가 없습니다. 왜냐하면 일반적인 동물의 소리를 정의할 수 없기 때문입니다. 이것이 Animal 클래스가 추상 클래스인 이유입니다. 추상 클래스는 다른 클래스에 의해 확장되도록 의도되어 있습니다.\n- 서브클래스 구현: 추상 클래스 Animal의 서브클래스는 추상 메소드에 대한 구현을 제공해야 합니다. 예를 들어,\n\n```java\npublic class Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Bow Bow\");\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n```java\npublic class Cat extends Animal {\n  @Override\n  public void makeSound() {\n    System.out.println(\"Meowww\");\n  }\n}\n```\n\n이 하위 클래스에서는 makeSound 메서드가 구현되어 강아지와 고양이에 대한 특정 동작을 제공합니다.\n\n# 추상 클래스 vs. 인터페이스\n\n추상 클래스와 인터페이스는 둘 다 추상화를 달성하는 데 사용될 수 있지만, 주요 차이점이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n추상 클래스\n\n- 추상 메서드(구현이 없는)와 구체 메서드(구현이 있는)를 모두 가질 수 있습니다.\n- 서로 다른 클래스들이 일부 기본적인 내용과 기능을 공유할 때 사용됩니다.\n- 예를 들어, Dog 및 Cat 클래스가 일부 공통 메서드나 필드를 공유하는 경우, 해당 공통 메서드나 필드를 포함하는 Animal 추상 클래스를 확장할 수 있습니다.\n- 클래스는 한 번에 하나의 추상 클래스만 확장할 수 있습니다.\n\n인터페이스\n\n- 여러 클래스가 구현할 수 있는 계약 또는 메서드 세트를 정의하는 데 사용됩니다. 이러한 클래스들이 공통의 기본을 공유하지 않더라도 구현할 수 있습니다.\n- 예를 들어, Bird, Plane 및 Superhero와 같은 다른 클래스들이 모두 fly() 메서드를 필요로 하는 경우, 이러한 클래스들이 Flyable 인터페이스를 구현할 수 있습니다.\n- 클래스는 여러 인터페이스를 구현할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n추상 클래스를 언제 그리고 어떻게 사용해야 하는지 이해하면 더 유연하고 유지보수가 쉬운 코드를 작성할 수 있습니다. 추상 클래스는 직접적으로 인스턴스화할 수 없으며, 추상 메서드에 대한 구체적인 구현을 제공하는 서브클래스에 의해 확장되어야 합니다. 공통 기능이 있는 클래스의 경우 추상 클래스를 사용하고, 관련이 없는 클래스 간에 공통 동작을 정의해야 할 때는 인터페이스를 사용하세요.\n\n다음에 만나요! 계속해서 자바 스킬을 향상시키고 발전시키세요!","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingAbstractClassesinJava_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingAbstractClassesinJava_0.png","tag":["Tech"],"readingTime":3},{"title":"이 9가지 질문에 답할 수 있다면 당신은 파이썬 전문가입니다","description":"","date":"2024-06-22 23:01","slug":"2024-06-22-YoureAwesomeAtPythonIfYouCanAnswerThese9Questions","content":"\n\n아래는 링크한 이미지입니다.\n\n9가지 까다로운 파이썬 문제가 있어요. 대부분의 독자들이 적어도 7개 이상의 문제를 벌써 보지 않고 정확하게 대답할 수 없을 거라고 확신해요. 하지만 제가 틀렸다는 것을 증명해 주세요.\n\n범죄는 코드를 실행하거나 다른 자료를 찾는 것을 의미해요.\n\n# 1) 데코레이터 관련 부분\n\n<div class=\"content-ad\"></div>\n\n\ndef add(symbol):\n    def wrapper1(func):\n        def wrapper2(*args, **kwargs):\n            return func(*args, **kwargs) + symbol\n    return wrapper1\n\n@add('!!')\ndef hello(name):\n    return 'hello' + name\n\nprint(hello('tom'))\r\n\n\n위 코드를 실행하면 무엇이 출력됩니까?\n\n- A) hello tom\n- B) hello tom!\n- C) hello tom!!\n- D) `function add.`locals`.wrapper1.`locals`.wrapper2 at 0x1053c1080`\n- E) TypeError: ‘NoneType’ object is not callable\n- F) SyntaxError: iterable argument unpacking follows keyword argument unpacking\n\n# 2) 어떤 마법과 같은 메소드들 \n\n<div class=\"content-ad\"></div>\n\n```python\nclass Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def __getattr__(self, key):\n        return '사과'\n    \n    def __getattribute__(self, key):\n        return '오렌지'\n    \n    def __getitem__(self, key):\n        return '배'\n\ndog = Dog('rocky')\nprint(dog.name)      #??\n```\n\n이것은 무엇을 출력합니까?\n\n- A) `rocky`\n- B) `사과`\n- C) `오렌지`\n- D) `배`\n- E) 구문 오류\n- F) KeyError 오류\n\n# 3) 별의 다발\n\n<div class=\"content-ad\"></div>\n\n```js\nx = [*[1,2]*2*3]\n\nprint(x)\n```\n\nx를 출력하면 무엇이 됩니까?\n\n- A) SyntaxError\n- B) ValueError: too many values to unpack\n- C) [1, 2, 2, 3]\n- D) [[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]\n- E) [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n- F) [[1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]]\n\n# 4) List Comprehension Shenanigans\n\n<div class=\"content-ad\"></div>\n\n\n```js\nout = []\nfor i in [1,2,3]:\n    row = []\n    for j in [4,5,6]:\n        row.append(i+j)\n    out.append(row)\n```\n\n위와 동일한 결과를 얻는 리스트 컴프리헨션은 무엇입니까?\n\n- A) out = [[i+j for j in [4,5,6]] for i in [1,2,3]]\n- B) out = [[i+j for i in [4,5,6]] for j in [1,2,3]]\n- C) out = [i+j for i in [4,5,6] for j in [1,2,3]]\n- D) out = [i+j for j in [1,2,3] for i in [4,5,6]]\n- E) out = [i+j for i,j in zip([1,2,3], [4,5,6])]\n- F) out = [[i,j] for i,j in enumerate(zip(*[1,2,3], *[4,5,6]))]\n\n# 5) Switching Shenanigans\n\n\n<div class=\"content-ad\"></div>\n\n```python\na, b, c, d = 1, 2, 3, 4\na, b, c, d = b, c, d, a\na, b, c, d = b, c, d, a\na, b, c, d = b, c, d, a\na, b, c, d = b, c, d, a\n\nprint(a, b, c, d)\n```\n\n여기서 출력되는 값은?\n\nA) 1 2 3 4\nB) 2 3 4 1\nC) 3 4 1 2\nD) 4 1 2 3\nE) 4 3 2 1\nF) 1 4 3 2\n\n# 6) 람다 함수\n\n\n<div class=\"content-ad\"></div>\n\n어떤 람다 함수가 잘못되었나요?\n\n- A) lambda a, b, c: [*(a, b, c)]\n- B) lambda *a, **b: print(a, b)\n- C) lambda **b, *a: print(a, b)\n- D) lambda a, b: map(int, [a, b])\n- E) 위의 모든 람다 함수\n- F) 위의 람다 함수 중에 없음\n\n# 7) 클래스에서의 속임수\n\n```js\nclass Dog:\n    def __getattr__(self, key):\n        return Dog()\n\n    def __getitem__(self, key):\n        return 0\n    \ndog = Dog()\n``` \n\n<div class=\"content-ad\"></div>\n\n다음 중 어떤 옵션이 오류를 발생시키나요?\n\n- A) dog._.__._.___._.__._______._.___._____.__\n- B) dog.狗.狗.狗.狗.狗.狗.狗.狗.狗.狗.狗\n- C) dog.狗.狗[`apple 3.14159`]\n- D) dog.__123._1234.___654\n- E) dog[dog]\n- F) dog.14_._14.14_._14\n\n```js\nx = -1--2---3----4-----5\nprint(x)\n```\n\n<div class=\"content-ad\"></div>\n\nx를 출력하면 무엇이 발생하나요?\n\n- A) SyntaxError\n- B) OperatorError\n- C) IndentationError\n- D) MemoryError\n- E) -1\n- F) -3\n\n## 9) 비트 조작\n\n```js\nx = 9\nx = ~~~~x << 5 >> 2 << 5 >> 8 | 9 & 9 ^ 16 ^ 16\nprint(x)\n```  \n\n<div class=\"content-ad\"></div>\n\n위의 표를 Markdown 형식으로 변경하면 다음과 같습니다.\n\n---\n**What happens when we print x?**\n\n- A) 0\n- B) -9\n- C) 9\n- D) 25\n- E) ZeroDivisionError\n- F) SyntaxError\n\n---\n# 경고 — 아래에 정답이 있습니다\n\n이를 확인하시기 전에 조금 시간을 내어 스스로 시도해보시고, 가능하면 참고하지 않고 풀어보세요!\n\n<div class=\"content-ad\"></div>\n\n# 1) 장식자 관련\n\n```javascript\ndef add(symbol):\n    def wrapper1(func):\n        def wrapper2(*args, **kwargs):\n            return func(*args, **kwargs) + symbol\n    return wrapper1\n\n@add('!!')\ndef hello(name):\n    return 'hello' + name\n\nprint(hello('tom'))\n```\n\n무엇이 출력됩니까?\n\n- A) hello tom\n- B) hello tom!\n- C) hello tom!!\n- D) `function add.`locals`.wrapper1.`locals`.wrapper2 at 0x1053c1080`\n- E) TypeError: 'NoneType' object is not callable\n- F) SyntaxError: iterable argument unpacking follows keyword argument unpacking\n\n<div class=\"content-ad\"></div>\n\n다음을 출력합니다.\n\n<div class=\"content-ad\"></div>\n\n- A) `rocky`\r\n- B) `apple`\r\n- C) `orange`\r\n- D) `pear`\r\n- E) Syntax 오류 발생\r\n- F) KeyError 발생\n\n- `__getattr__`은 우리가 `dog.key`를 할 때 key가 존재하지 않을 때의 동작을 정의합니다.\n- `__getattribute__`은 우리가 `dog.key`를 할 때 key가 존재 여부에 관계없이 동작을 정의합니다. 이는 `__getattr__`을 덮어씁니다.\n- `__getitem__`은 `dog[key]`를 할 때의 동작을 정의합니다. 이 메서드는 사용되지 않습니다.\n\n# 3) 별의 무리\n\n```js\nx = [*[1,2]*2*3]\n\nprint(x)\n```\n\n<div class=\"content-ad\"></div>\n\n`x`를 출력하면 무엇이 될까요?\n\n- A) SyntaxError\n- B) ValueError: too many values to unpack\n- C) [1, 2, 2, 3]\n- D) [[1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2]]\n- E) [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]\n- F) [[1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]]\n\n```js\nx = [*[1,2]*2*3]\n  = [* ([1,2]*2*3) ]\n  = [* ([1,2,1,2]*3) ]\n  = [* [1,2,1,2,1,2,1,2,1,2,1,2] ]\n  = [1,2,1,2,1,2,1,2,1,2,1,2]\n```\n\n^ 처음 *은 언팩하고, 이후 *는 곱셈합니다.\n\n<div class=\"content-ad\"></div>\n\n# 4) 리스트 내포 흥분\n\n```js\nout = []\nfor i in [1,2,3]:\n    row = []\n    for j in [4,5,6]:\n        row.append(i+j)\n    out.append(row)\n```\n\n위와 동일한 작업을 하는 리스트 내포는 무엇입니까?\n\n- A) out = [[i+j for j in [4,5,6]] for i in [1,2,3]]\n- B) out = [i+j for i,j in [i for i in [[1,2,3],[4,5,6]]]]\n- C) out = [i+j for i in [4,5,6] for j in [1,2,3]]\n- D) out = [i+j for j in [1,2,3] for i in [4,5,6]]\n- E) out = [i+j for i,j in zip([1,2,3], [4,5,6])]\n- F) out = [[i,j] for i,j in enumerate(zip(*[1,2,3], *[4,5,6])]\n\n<div class=\"content-ad\"></div>\n\nB, E 그리고 F는 무의미해요. C와 D는 중첩된 목록을 생성하지 않아요.\n\n# 5) 변환 광기\n\n```js\na, b, c, d = 1, 2, 3, 4\na, b, c, d = b, c, d, a\na, b, c, d = b, c, d, a\na, b, c, d = b, c, d, a\na, b, c, d = b, c, d, a\n\nprint(a, b, c, d)\n```\n\n여기서 무엇이 출력될까요?\n\n<div class=\"content-ad\"></div>\n\n- A) 1 2 3 4\n- B) 2 3 4 1\n- C) 3 4 1 2\n- D) 4 1 2 3\n- E) 4 3 2 1\n- F) 1 4 3 2\n\n```js\na, b, c, d = 1, 2, 3, 4    # a=1 b=2 c=3 d=4\na, b, c, d = b, c, d, a    # a=2 b=3 c=4 d=1\na, b, c, d = b, c, d, a    # a=3 b=4 c=1 d=2\na, b, c, d = b, c, d, a    # a=4 b=1 c=2 d=3\na, b, c, d = b, c, d, a    # a=1 b=2 c=3 d=4\n```\n\n매번 a, b, c, d = b, c, d, a를 실행할 때마다, a, b, c, d의 값이 오른쪽으로 한 칸씩 이동합니다. 그러나 이를 4번 반복하면 1, 2, 3, 4로 다시 돌아옵니다.\n\n# 6) 람다 함수\n\n<div class=\"content-ad\"></div>\n\n어떤 lambda 함수가 잘못되었나요?\n\n- A) lambda a, b, c: [*(a, b, c)]\n- B) lambda *a, **b: print(a, b)\n- C) lambda **b, *a: print(a, b)\n- D) lambda a, b: map(int, [a, b])\n- E) 위의 모든 람다 함수\n- F) 위의 람다 함수 중에 없음\n\n함수를 정의할 때 (람다 함수 포함), 모든 *args는 **kwargs보다 먼저 정의되어야 합니다. C)에서 **b가 *a보다 먼저 정의되어서 틀렸어요.\n\n# 7) Class Shenanigans\n\n<div class=\"content-ad\"></div>\n\n```kotlin\nclass Dog {\n    override fun __getattr__(key: String): Dog {\n        return Dog()\n    }\n\n    override fun __getitem__(key: String): Int {\n        return 0\n    }\n}\n\nval dog = Dog()\n```\n\n다음 중 어떤 옵션이 오류를 발생시킵니까?\n\n- A) dog._.__._.___._.__._______._.___._____.__\n- B) dog.狗.狗.狗.狗.狗.狗.狗.狗.狗.狗.狗\n- C) dog.狗.狗[`apple 3.14159`]\n- D) dog.__123._1234.___654\n- E) dog[dog]\n- F) dog.14_._14.14_._14\n\n- A) __getattr__이 또 다른 Dog 개체를 반환하므로, .__ 등을 사용해도 계속 Dog 개체를 얻게됩니다\n- B) A와 같지만, 중국어 유니코드 문자를 사용하여 유효한 변수 이름을 사용합니다\n- C) A와 동일합니다. 하지만 키 값을 사용하여 dog[key]를 마지막에 사용하므로 0을 얻습니다\n- D) A와 동일합니다. 변수 이름은 __로 시작하고 숫자를 포함할 수 있습니다\n- E) 이것은 단순히 0을 반환합니다\n- F) 변수 이름은 숫자로 시작할 수 없습니다. 따라서 이는 잘못된 것입니다\n\n\n<div class=\"content-ad\"></div>\n\n# 8) -\n\n```js\nx = -1--2---3----4-----5\nprint(x)\n```\n\nWhen we print x, the output will be:\n\n- F) -3\n\n<div class=\"content-ad\"></div>\n\n```js\nx = -5       # x는 -5\nx = --5      # x는 5\nx = ---5     # x는 -5\nx = ----5    # x는 5\nx = -----5   # x는 -5 \n```\n\n^ 숫자 5 앞에 더 많은 -를 추가하면 계속해서 부호가 뒤바뀔 것인데, 음수 음수 5는 5와 같습니다.\n\n```js\nx = -1--2---3----4-----5\n  = -1-(-2)-(--3)-(---4)-(----5)\n  = -1-(-2)-(3)-(-4)-(5)\n  = -1+2-3+4-5\n  = -3\n```\n\n# 9) 비트 연산 광기\n\n<div class=\"content-ad\"></div>\n\n```js\nx = 9\nx = ~~x << 5 >> 2 << 5 >> 8 | 9 & 9 ^ 16 ^ 16\nprint(x)\n```\n\nx를 인쇄할 때 무슨 일이 벌어질까요?\n\n- A) 0\n- B) -9\n- C) 9\n- D) 25\n- E) ZeroDivisionError\n- F) SyntaxError\n\n- x `` 5 `` 2 `` 5 `` 8는 x를 왼쪽으로 5번 이동시키고, 오른쪽으로 2번 이동시키고, 다시 왼쪽으로 5번 이동시키고, 오른쪽으로 8번 이동시킵니다. 이 작업은 x에 아무런 영향을 미치지 않아서 결과적으로 x는 9로 유지됩니다.\n- 9 | 9는 단순히 9를 반환합니다.\n- 9 & 9는 단순히 9를 반환합니다.\n- 9 ^ 16 (XOR 연산자)는 25를 반환합니다.\n- 그러나 우리가 두 번 XOR을 한다면, 9를 다시 돌려받을 것입니다.\n- (9 ^ 16) ^ 16은 다시 한 번 9를 돌려줄 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 중 몇 개를 참으로 대답할 수 있었나요? 법을 어겨 대답하지 않고 성공했다면 멋집니다!\n\n- 모두 정확히 대답했다면 잘 했어요!\n- 적어도 7개 이상을 맞추었다면 여전히 멋져요!\n- 그렇지 않다면 괜찮아요 — 이것이 당신이 파이썬을 잘못 이해했다는 것을 의미하는 것은 아닙니다.\n\n이 문제들을 시도하면서 즐거운 시간 보냈기를 바랍니다!\n\n<div class=\"content-ad\"></div>\n\n# 만약 나를 창작자로 지원하고 싶다면\n\n- 이 이야기에 대해 50번 박수를 치세요\n- 당신의 생각을 나에게 남겨주세요\n- 이야기 중 가장 마음에 드는 부분을 강조해주세요\n\n감사합니다! 이 작은 조치들이 큰 영향을 미치고, 정말 감사드립니다!\n\nYouTube: https://www.youtube.com/@zlliu246\n\n<div class=\"content-ad\"></div>\n\nLinkedIn: [https://www.linkedin.com/in/zlliu/](https://www.linkedin.com/in/zlliu/)","ogImage":{"url":"/assets/img/2024-06-22-YoureAwesomeAtPythonIfYouCanAnswerThese9Questions_0.png"},"coverImage":"/assets/img/2024-06-22-YoureAwesomeAtPythonIfYouCanAnswerThese9Questions_0.png","tag":["Tech"],"readingTime":9},{"title":"프로그래머 되기 위한 단계별 가이드","description":"","date":"2024-06-22 22:59","slug":"2024-06-22-Step-by-StepGuidetoBecomingaProgrammer","content":"\n\n![이미지](/assets/img/2024-06-22-Step-by-StepGuidetoBecomingaProgrammer_0.png)\n\n인식 받기\n\n안녕하세요, 개발자가 되고 싶은 분! 코더가 되는 흥미진진한 여정을 시작하는 방법에 대해 궁금해 해 본 적이 있다면, 당신이 올바른 곳에 왔습니다. 궁금한 고등학생이거나 취업을 변경하려는 분이더라도 프로그래밍 능력을 향상할 수 있는 길은 처음에는 겁을 줄 수 있습니다. 그러나 걱정하지 마세요! 이 기사에서는 단순하고 명확한 \"프로그래머가 되는 단계별 가이드\"를 제시하여 필요한 단계를 소개할 것입니다.\n\n당신의 고민 이해: 의심에 대한 대응\n\n<div class=\"content-ad\"></div>\n\n세부 내용을 살펴보기 전에 일반적인 고민을 해소해 봅시다: \"프로그래밍이 진짜 내 것일까요?\" 코딩을 처음 시작하다 보면 약간 압도되거나 확신이 없는 것은 정상입니다. 숫자에 취약하다고 생각하거나 기술이 너무 복잡해 보일 수도 있죠. 하지만 안심하세요, 프로그래밍은 숫자와 알고리즘에만 의존하는 것이 아니라 문제 해결과 창의력에 더 중점을 둔 영역입니다. 열정과 배우려는 의지가 있는 사람이라면 누구든지 뛰어난 프로그래머가 될 수 있어요.\n\n준비 과정: 시작을 빛내는 단계\n\n상상해보세요: 컴퓨터가 유용한 작업을 수행하도록 하는 첫 번째 코드 줄을 작성한 순간 — 성취감이 밀려옵니다. 이 가이드는 이러한 성공적인 순간을 느낄 수 있도록 도와주기 위한 것입니다. 그러니, 준비된 길을 열어봅시다. 프로그래밍 여행을 시작할 단계를 탐험해 보죠.\n\n단계 1: 기초 다지기\n\n<div class=\"content-ad\"></div>\n\n가장 먼저 기초를 편안하게 익혀보세요. 목표에 맞는 프로그래밍 언어를 선택하세요. 예를 들어, 간단함으로 유명한 Python이나 다양성으로 유명한 JavaScript 중에 선택하세요. 완벽한 선택을 하는 데 집중할 필요는 없어요. 중요한 것은 코딩을 시작하는 것이에요.\n\nPython 책을 찾아볼 수 있는 링크를 클릭해보세요.\n\nJavaScript 책을 찾아볼 수 있는 링크를 클릭해보세요.\n\n단계 2: 경험을 통해 배우세요.\n\n<div class=\"content-ad\"></div>\n\n이론은 좋지만 실습이 완벽을 이룹니다. 코딩 도전에 뛰어들고 간단한 프로젝트를 만들어 보세요. 실수를 두려워하지 마세요 — 그들이 당신의 최고의 선생님들입니다. Codecademy, Coursera, freeCodeCamp과 같은 온라인 플랫폼은 실습을 도와주는 대화형 코스를 제공합니다.\n\n단계 3: 지식 확장\n\n자신감을 얻으면 기술을 넓히세요. 객체지향 프로그래밍 (OOP) 또는 함수형 프로그래밍과 같은 다른 프로그래밍 패러다임을 탐험해보세요. 데이터 구조와 알고리즘을 이해하세요 — 효율적인 코드의 기본 구성 요소입니다.\n\n단계 4: 포트폴리오 구축\n\n<div class=\"content-ad\"></div>\n\nGitHub 리포지토리에 프로젝트와 기여 사항을 담아 포트폴리오를 만들어보세요. 멋있을 필요는 없어요; 여러분의 작업물은 잠재적인 고용주나 클라이언트들에게 많은 메시지를 전달합니다.\n\nGitHub를 능숙하게 사용하고 싶다면 여기를 클릭하세요.\n\n단계 5: 네트워크 구축하고 호기심을 유지하세요.\n\nStack Overflow와 같은 포럼이나 지역 모임과 해커톤에 참여하여 동료 프로그래머들과 연결하세요. 네트워킹은 학습 기회와 경력 전망을 엶니다. 호기심을 갖고 있어요 — 기술은 발전하고, 여러분도 발전해야 해요.\n\n<div class=\"content-ad\"></div>\n\n결론: 코딩 준비 완료\n\n축하합니다! 이제 프로그래머가 되기 위한 단단한 로드맵을 갖게 되었습니다. 여정이 항상 순조롭지는 않을 것이며 도전과 실패를 마주하게 될 겁니다. 하지만 각각의 장애물은 성장할 기회입니다. 과정을 받아들이고 끈질기게 노력해 보세요. 그리고 어느새 실제 세계에 영향을 미치는 코드를 만들고 있을 겁니다. 즐거운 코딩 되세요!\n\n마지막으로\n\n이 가이드가 프로그래머가 되는 길을 해소해 준 것이며 여러분이 첫걸음을 내딛도록 영감을 주었으면 좋겠습니다. 프로그래밍은 단순히 직업이 아니라 창의성, 문제 해결, 끝없는 가능성으로 이어지는 문을 열어줍니다. 그러니 무엇을 기다리고 있나요? 오늘부터 코딩을 시작하고 여러분의 기술이 번창하는 것을 지켜보세요!\n\n<div class=\"content-ad\"></div>\n\n아래 목록을 클릭하면 기본 언어의 책을 쉽게 이해할 수 있습니다. 꼭 필요한 학습 도서입니다:\n\n- HTML (하이퍼텍스트 마크업 언어)\n- CSS (캐스캐이딩 스타일 시트)","ogImage":{"url":"/assets/img/2024-06-22-Step-by-StepGuidetoBecomingaProgrammer_0.png"},"coverImage":"/assets/img/2024-06-22-Step-by-StepGuidetoBecomingaProgrammer_0.png","tag":["Tech"],"readingTime":3}],"page":"9","totalPageCount":98,"totalPageGroupCount":5,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}