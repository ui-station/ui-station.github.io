{"pageProps":{"post":{"title":"스프링 클라우드 게이트웨이  스프링 부트 30  로드 밸런싱","description":"","date":"2024-05-20 15:39","slug":"2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing","content":"\n![Spring Cloud Gateway](/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png)\n\nSpring Cloud Gateway는 Spring Boot 애플리케이션에서 API 게이트웨이를 구축하는 강력하고 유연한 솔루션을 제공합니다. 다양한 기능을 갖춘 Spring Cloud Gateway는 라우팅, 요금 제한, 보안 및 장애 관리를 처리할 수 있습니다.\n\n![Spring Cloud Gateway](/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_1.png)\n\n마이크로서비스 아키텍처 시대에는 견고하고 확장 가능한 시스템 구축이 중요합니다. Spring Boot와 Spring Cloud의 발전으로 개발자들은 이전 Netflix Zuul에 의존하지 않고도 견고한 마이크로서비스 기반 애플리케이션을 생성할 수 있는 강력한 도구를 사용할 수 있습니다. 이 블로그 포스트에서는 Spring Boot 3.0과 함께 Spring Cloud Gateway를 사용하여 현대적인 마이크로서비스 아키텍처를 어떻게 만들 수 있는지 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSpring Boot이 계속 발전함에 따라 더 최신 기술과 모범 사례에 적응하는 것이 중요합니다. Spring Boot 3.0에서는 마이크로서비스를 구축하기 위한 현대적인 솔루션에 중점을 두고 있습니다. Spring WebFlux 기반으로 구축된 강력한 API 게이트웨이인 Spring Cloud Gateway가 그러한 솔루션 중 하나로, 라우팅, 필터링, 로드 밸런싱과 같은 기능을 제공합니다.\n\n게이트웨이를 설명하기 위해 적합한 아키텍처가 필요합니다.\n\n- Eureka 서버: 마이크로서비스를 관리하기 위한 서비스 레지스트리 및 디스커버리 서버입니다. Eureka 서버와 함께 스프링 부트 프로젝트를 생성하세요.\n- Payment MS: 테스트를 위한 사용자 정의 마이크로서비스로, 웹 및 Eureka 클라이언트 종속성 및 설정이 있는 간단한 마이크로서비스입니다.\n- Spring Cloud Gateway: 적절한 마이크로서비스로 요청을 라우팅하는 API 게이트웨이입니다.\n\n아래 종속성을 가진 Spring Boot 애플리케이션을 만들어 보세요. Eureka는 서비스 디스커버리 서버로 사용될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n의존성 테이블을 다음과 같이 변경해보세요:\n\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n\n- @EnableEurekaServer 주석을 사용하여 주 클래스에 Eureka 서버를 활성화하세요.\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class MyEurekaServerApplication {\n```\n\n```java\n public static void main(String[] args) {\n  SpringApplication.run(MyEurekaServerApplication.class, args);\n }\n}\n```\n\n그리고 My application.properties 파일에도 변경을 적용해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```bash\n// application.properties\neureka.client.fetch-registry=false\neureka.client.register-with-eureka=false\nserver.port=8761\nspring.application.name=MY-EUREKA-SERVER\n```\n\n아래 종속성을 사용하여 Spring Boot 어플리케이션을 생성하세요.\n\n```js\n<dependency>\n   <groupId>org.springframework.boot</groupId>\n   <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n   <groupId>org.springframework.cloud</groupId>\n   <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n```js\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-test</artifactId>\n  <scope>test</scope>\n</dependency>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서버 포트를 출력하는 REST API를 작성해보세요. 이것은 테스트 중에 호출된 서비스의 어떤 인스턴스인지 식별하는 데 도움이 될 것입니다 [로드 밸런싱]\n\n```java\n@RestController\n@RequestMapping(\"/payment\")\npublic class PayController {\n```\n\n```java\n@Value(\"${server.port}\")\nprivate String serverPort;\n\n@GetMapping(\"/say\")\npublic String getMethodName() {\n    return new String(\"안녕하세요, Payment MS에서 온 메시지입니다. \"+serverPort);\n}\n```\n\n그리고 Eureka 서버 세부 정보를 추가하고 메인 클래스에 Eureka 클라이언트를 활성화하는 주석을 추가하는 것을 잊지 마세요 (@EnableDiscoveryClient)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class PaymentMsApplication {\n\n public static void main(String[] args) {\n  SpringApplication.run(PaymentMsApplication.class, args);\n }\n}\n```\n\n- 그리고 나의 MS를 위한 어플리케이션 프로퍼티\n\n```java\nspring.application.name=PAYMENT-SERVICE\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\nserver.port=9811 (어플리케이션을 실행하기 전에 다른 포트를 사용 중입니다)\neureka.instance.ip-address=localhost\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<dependency>\n   <groupId>org.springframework.cloud</groupId>\n   <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n\n<!--\nhttps://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-gateway -->\n<dependency>\n   <groupId>org.springframework.cloud</groupId>\n   <artifactId>spring-cloud-starter-gateway</artifactId>\n   <version>4.1.2</version>\n</dependency>\n\n그래서 최신 버전(내 경우 3.2.4v)의 스프링 부트 프로젝트를 만들고 위의 종속성을 추가합니다.\n\n- application.yml 파일에 라우팅 구성을 추가하십시오. `service-name` 프로토콜을 사용하여 API 게이트웨이에 서비스 검색을 지시합니다. 두 개의 payment-service 인스턴스가 있으므로 부하 처리가 필요하고 동적으로 처리해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\nspring:\n  application:\n    name: gateway\n  cloud:\n    gateway:\n      routes:\n        - id: payment-service\n          uri: lb://payment-service\n          predicates:\n            - Path=/payment/**\n```\n\n- API Gateway는 마이크로서비스로도 불리우며 유레카 서버에 등록되어야 합니다. 메인 클래스에 `@EnableDiscoveryClient`를 추가하지 않는 것을 잊지 마세요.\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ApiGtApplication {\n```\n\n```java\n public static void main(String[] args) {\n  SpringApplication.run(ApiGtApplication.class, args);\n }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 지금 테스트해 보세요!\n\n진행 방법:\n\n- 유레카 서버 실행\n- 포트 9810 및 9811에서 결제 서비스 실행\n- API 게이트웨이 서비스 실행\n\n![이미지](/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n브라우저에서 게이트웨이 엔드포인트를 방문해서 확인해보세요 (http://localhost:8080/payment/say)\n\n/payment은 술어 패턴입니다 — 이 패턴이 발생하면 API 게이트웨이는 요청을 지불 서비스로 라우팅하고 지불 서비스에는 컨트롤러 /payment과 GET 메소드 /say가 있습니다. 이것이 실행되어 응답을 게이트웨이로 반환합니다. 유레카는 API 게이트웨이로 인스턴스 정보를 보내기 위한 것이며 내부 통신을 위한 것이 아닙니다.\n\n독자 여러분의 읽어주셔서 감사합니다. 도움이 되었다면 공유하고 좋아요를 눌러주세요.\n","ogImage":{"url":"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png"},"coverImage":"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_0.png\" alt=\"Spring Cloud Gateway\"></p>\n<p>Spring Cloud Gateway는 Spring Boot 애플리케이션에서 API 게이트웨이를 구축하는 강력하고 유연한 솔루션을 제공합니다. 다양한 기능을 갖춘 Spring Cloud Gateway는 라우팅, 요금 제한, 보안 및 장애 관리를 처리할 수 있습니다.</p>\n<p><img src=\"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_1.png\" alt=\"Spring Cloud Gateway\"></p>\n<p>마이크로서비스 아키텍처 시대에는 견고하고 확장 가능한 시스템 구축이 중요합니다. Spring Boot와 Spring Cloud의 발전으로 개발자들은 이전 Netflix Zuul에 의존하지 않고도 견고한 마이크로서비스 기반 애플리케이션을 생성할 수 있는 강력한 도구를 사용할 수 있습니다. 이 블로그 포스트에서는 Spring Boot 3.0과 함께 Spring Cloud Gateway를 사용하여 현대적인 마이크로서비스 아키텍처를 어떻게 만들 수 있는지 살펴보겠습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>Spring Boot이 계속 발전함에 따라 더 최신 기술과 모범 사례에 적응하는 것이 중요합니다. Spring Boot 3.0에서는 마이크로서비스를 구축하기 위한 현대적인 솔루션에 중점을 두고 있습니다. Spring WebFlux 기반으로 구축된 강력한 API 게이트웨이인 Spring Cloud Gateway가 그러한 솔루션 중 하나로, 라우팅, 필터링, 로드 밸런싱과 같은 기능을 제공합니다.</p>\n<p>게이트웨이를 설명하기 위해 적합한 아키텍처가 필요합니다.</p>\n<ul>\n<li>Eureka 서버: 마이크로서비스를 관리하기 위한 서비스 레지스트리 및 디스커버리 서버입니다. Eureka 서버와 함께 스프링 부트 프로젝트를 생성하세요.</li>\n<li>Payment MS: 테스트를 위한 사용자 정의 마이크로서비스로, 웹 및 Eureka 클라이언트 종속성 및 설정이 있는 간단한 마이크로서비스입니다.</li>\n<li>Spring Cloud Gateway: 적절한 마이크로서비스로 요청을 라우팅하는 API 게이트웨이입니다.</li>\n</ul>\n<p>아래 종속성을 가진 Spring Boot 애플리케이션을 만들어 보세요. Eureka는 서비스 디스커버리 서버로 사용될 것입니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>의존성 테이블을 다음과 같이 변경해보세요:</p>\n<dependency>\n    <groupid>org.springframework.cloud</groupid>\n    <artifactid>spring-cloud-starter-netflix-eureka-server</artifactid>\n</dependency>\n<ul>\n<li>@EnableEurekaServer 주석을 사용하여 주 클래스에 Eureka 서버를 활성화하세요.</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@EnableEurekaServer</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyEurekaServerApplication</span> {\n</code></pre>\n<pre><code class=\"hljs language-java\"> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n  SpringApplication.run(MyEurekaServerApplication.class, args);\n }\n}\n</code></pre>\n<p>그리고 My application.properties 파일에도 변경을 적용해주세요.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-bash\">// application.properties\neureka.client.fetch-registry=<span class=\"hljs-literal\">false</span>\neureka.client.register-with-eureka=<span class=\"hljs-literal\">false</span>\nserver.port=8761\nspring.application.name=MY-EUREKA-SERVER\n</code></pre>\n<p>아래 종속성을 사용하여 Spring Boot 어플리케이션을 생성하세요.</p>\n<pre><code class=\"hljs language-js\">&#x3C;dependency>\n   <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">groupId</span>></span>org.springframework.boot<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">groupId</span>></span></span>\n   <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">artifactId</span>></span>spring-boot-starter-web<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">artifactId</span>></span></span>\n&#x3C;/dependency>\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">dependency</span>></span>\n   <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">groupId</span>></span>org.springframework.cloud<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">groupId</span>></span>\n   <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">artifactId</span>></span>spring-cloud-starter-netflix-eureka-client<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">artifactId</span>></span>\n<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">dependency</span>></span></span>\n</code></pre>\n<pre><code class=\"hljs language-js\">&#x3C;dependency>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">groupId</span>></span>org.springframework.boot<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">groupId</span>></span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">artifactId</span>></span>spring-boot-starter-test<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">artifactId</span>></span></span>\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">scope</span>></span>test<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">scope</span>></span></span>\n&#x3C;/dependency>\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>서버 포트를 출력하는 REST API를 작성해보세요. 이것은 테스트 중에 호출된 서비스의 어떤 인스턴스인지 식별하는 데 도움이 될 것입니다 [로드 밸런싱]</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping(\"/payment\")</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PayController</span> {\n</code></pre>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Value(\"${server.port}\")</span>\n<span class=\"hljs-keyword\">private</span> String serverPort;\n\n<span class=\"hljs-meta\">@GetMapping(\"/say\")</span>\n<span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">getMethodName</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(<span class=\"hljs-string\">\"안녕하세요, Payment MS에서 온 메시지입니다. \"</span>+serverPort);\n}\n</code></pre>\n<p>그리고 Eureka 서버 세부 정보를 추가하고 메인 클래스에 Eureka 클라이언트를 활성화하는 주석을 추가하는 것을 잊지 마세요 (@EnableDiscoveryClient)</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@EnableDiscoveryClient</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PaymentMsApplication</span> {\n\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n  SpringApplication.run(PaymentMsApplication.class, args);\n }\n}\n</code></pre>\n<ul>\n<li>그리고 나의 MS를 위한 어플리케이션 프로퍼티</li>\n</ul>\n<pre><code class=\"hljs language-java\">spring.application.name=PAYMENT-SERVICE\neureka.client.service-url.defaultZone=http:<span class=\"hljs-comment\">//localhost:8761/eureka</span>\nserver.port=<span class=\"hljs-number\">9811</span> (어플리케이션을 실행하기 전에 다른 포트를 사용 중입니다)\neureka.instance.ip-address=localhost\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<dependency>\n   <groupid>org.springframework.cloud</groupid>\n   <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n</dependency>\n<!--\nhttps://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-gateway -->\n<dependency>\n   <groupid>org.springframework.cloud</groupid>\n   <artifactid>spring-cloud-starter-gateway</artifactid>\n   <version>4.1.2</version>\n</dependency>\n<p>그래서 최신 버전(내 경우 3.2.4v)의 스프링 부트 프로젝트를 만들고 위의 종속성을 추가합니다.</p>\n<ul>\n<li>application.yml 파일에 라우팅 구성을 추가하십시오. <code>service-name</code> 프로토콜을 사용하여 API 게이트웨이에 서비스 검색을 지시합니다. 두 개의 payment-service 인스턴스가 있으므로 부하 처리가 필요하고 동적으로 처리해야 합니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">application:</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">gateway</span>\n  <span class=\"hljs-attr\">cloud:</span>\n    <span class=\"hljs-attr\">gateway:</span>\n      <span class=\"hljs-attr\">routes:</span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">payment-service</span>\n          <span class=\"hljs-attr\">uri:</span> <span class=\"hljs-string\">lb://payment-service</span>\n          <span class=\"hljs-attr\">predicates:</span>\n            <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Path=/payment/**</span>\n</code></pre>\n<ul>\n<li>API Gateway는 마이크로서비스로도 불리우며 유레카 서버에 등록되어야 합니다. 메인 클래스에 <code>@EnableDiscoveryClient</code>를 추가하지 않는 것을 잊지 마세요.</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@EnableDiscoveryClient</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ApiGtApplication</span> {\n</code></pre>\n<pre><code class=\"hljs language-java\"> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n  SpringApplication.run(ApiGtApplication.class, args);\n }\n}\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>지금 테스트해 보세요!</h1>\n<p>진행 방법:</p>\n<ul>\n<li>유레카 서버 실행</li>\n<li>포트 9810 및 9811에서 결제 서비스 실행</li>\n<li>API 게이트웨이 서비스 실행</li>\n</ul>\n<p><img src=\"/assets/img/2024-05-20-SpringCloudGatewaySpringBoot30Loadbalancing_2.png\" alt=\"이미지\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>브라우저에서 게이트웨이 엔드포인트를 방문해서 확인해보세요 (<a href=\"http://localhost:8080/payment/say\" rel=\"nofollow\" target=\"_blank\">http://localhost:8080/payment/say</a>)</p>\n<p>/payment은 술어 패턴입니다 — 이 패턴이 발생하면 API 게이트웨이는 요청을 지불 서비스로 라우팅하고 지불 서비스에는 컨트롤러 /payment과 GET 메소드 /say가 있습니다. 이것이 실행되어 응답을 게이트웨이로 반환합니다. 유레카는 API 게이트웨이로 인스턴스 정보를 보내기 위한 것이며 내부 통신을 위한 것이 아닙니다.</p>\n<p>독자 여러분의 읽어주셔서 감사합니다. 도움이 되었다면 공유하고 좋아요를 눌러주세요.</p>\n</body>\n</html>\n"},"__N_SSG":true}