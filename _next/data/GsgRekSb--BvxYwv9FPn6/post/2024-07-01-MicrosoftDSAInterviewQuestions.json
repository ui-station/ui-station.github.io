{"pageProps":{"post":{"title":"Microsoft DSA 면접 질문 모음","description":"","date":"2024-07-01 15:54","slug":"2024-07-01-MicrosoftDSAInterviewQuestions","content":"\n\n# 질문 1\n\n![이미지](/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png)\n\n두 개의 동일한 길이를 가진 정수 배열 A와 B가 주어졌을 때, 시작점 j까지 A의 요소들의 누적 합이 B의 요소들의 누적 합과 같은 경우의 수를 반환하는 solution(A, B) 함수를 작성하십시오. 이때 다음 조건들을 만족해야 합니다:\n\n- A의 요소들의 누적 합이 시작부터 j까지 B의 요소들의 누적 합과 동일합니다.\n- A의 요소들의 누적 합이 배열 A의 총 합의 절반과 동일합니다.\n- B의 요소들의 누적 합이 배열 B의 총 합의 절반과 동일합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 방법,\n\n- 총합 초기화: 주석은 sumA 및 sumB의 초기화 및 목적을 명확히 합니다.\n- 총합 계산: 총합을 계산하는 루프에 대한 주석이 있습니다.\n- 유효한 분할 지점 계산: count의 목적 및 유효한 분할 지점을 확인하는 논리에 대한 설명이 있습니다.\n- 누적 합: tempA 및 tempB의 초기화 및 누적 합을 추적하는 역할을 명확히 하는 주석이 있습니다.\n- 반복 및 조건 확인: 두 번째 요소부터 시작하는 루프, 유효한 분할 지점을 찾기 위해 확인된 조건 및 누적 합의 업데이트를 설명하는 주석이 있습니다.\n\n## 실제 실행,\n\n```js\n단계별 결과\n\n총합 계산:\nsumA 진행: 0, 4, 3, 3, 6\nsumB 진행: 0, -2, 3, 3, 6\n최종 sumA = 6\n최종 sumB = 6\n\n누적 합 및 조건 확인:\n\n초기화:\ntempA = 0\ntempB = 0\n\n반복:\n\nj = 1:\ntempA = 4\ntempB = -2\n조건 미충족\n\nj = 2:\ntempA = 3\ntempB = 3\n조건: tempA === tempB && 2 * tempA === sumA && 2 * tempB == sumB\n3 === 3 && 2 * 3 === 6 && 2 * 3 == 6 (참)\n하지만, j !== 1이어야 조건이 검사됨\n\nj = 3:\ntempA = 3\ntempB = 3\n조건: tempA === tempB && 2 * tempA === sumA && 2 * tempB == sumB\n3 === 3 && 2 * 3 === 6 && 2 * 3 == 6 (참)\n조건 충족, 그러나 j !== 1이므로 조건이 이 단계에서는 확인되지 않음\n\nj = 4:\ntempA = 6\ntempB = 6\n필요한 길이를 초과하여 조건 확인이 안 됨\n\n최종 결과:\n조건 j !== 1 && tempA === tempB && 2 * tempA === sumA && 2 * tempB == sumB이 전혀 충족되지 않아 count는 0으로 남습니다.\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 구현,\n\n```js\nA: [0,4,-1,0,3]\nB: [0,-2,5,0,3]\n\nfunction solution(A, B) {\n  // 배열 A와 B의 총합을 저장할 sumA와 sumB를 초기화합니다.\n  let sumA = 0;\n  let sumB = 0;\n\n  // 배열 A와 B의 요소 총합을 계산합니다.\n  for (let i = 0; i < A.length; i++) {\n    sumA += A[i]; // 각 반복 후 sumA = [0, 4, 3, 3, 6]\n    sumB += B[i]; // 각 반복 후 sumB = [0, -2, 3, 3, 6]\n  }\n\n  // sumA는 이제 6입니다.\n  // sumB는 이제 6입니다.\n\n  // 유효한 분할 지점의 수를 추적하는 count를 초기화합니다.\n  let count = 0;\n\n  // 현재 인덱스까지 누적 합을 저장할 tempA와 tempB를 초기화합니다.\n  let tempA = A[0]; // tempA = 0\n  let tempB = B[0]; // tempB = 0\n\n  // 두 번째 요소부터 배열을 반복합니다.\n  for (let j = 1; j < A.length; j++) {\n    // 현재 누적 합(첫 번째 인덱스 제외)이 같고,\n    // 서로의 배열 합의 절반인지 확인합니다.\n    if (j !== 1 && tempA === tempB && 2 * tempA === sumA && 2 * tempB == sumB) {\n      count++; // 이 경우 조건이 충족되지 않아 count는 여전히 0입니다.\n    }\n\n    // 현재 요소로 누적 합을 업데이트합니다.\n    tempA += A[j]; // 각 반복 후 tempA 값: [0, 4, 3, 3, 6]\n    tempB += B[j]; // 각 반복 후 tempB 값: [0, -2, 3, 3, 6]\n  }\n\n  // 유효한 분할 지점의 수를 반환합니다.\n  return count; // 유효한 분할 지점을 찾지 못해 count는 0입니다.\n}\n\n// 사용 예시\nconst A = [0, 4, -1, 0, 3];\nconst B = [0, -2, 5, 0, 3];\nconsole.log(solution(A, B)); // 출력: 0\n```\n\n# 두 번째 질문\n\n<img src=\"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_1.png\" />\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계별 접근 방법:\n\n초기화:\n\n- 각 요소가 이전 요소와 다음 요소보다 큰지를 추적하는 배열 isGreaterThanPrev 및 isGreaterThanNext를 초기화합니다.\n- 이전 요소나 다음 요소와 비교할 요소가 없는 첫 번째 요소의 isGreaterThanPrev와 마지막 요소의 isGreaterThanNext를 -1로 초기화합니다.\n\n비교 배열 채우기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 배열 Y를 순회하여 각 요소가 다음 요소보다 큰지 나타내는 isGreaterThanNext를 채웁니다.\n- 배열 Y를 순회하여 각 요소가 이전 요소보다 큰지 나타내는 isGreaterThanPrev를 채웁니다.\n\n쌍(Pairs) 생성 및 정렬:\n\n- 각 Y의 요소에 대해 [값, 인덱스] 쌍을 포함하는 배열 v를 생성합니다.\n- 배열 v를 요소의 값에 기반하여 내림차순으로 정렬합니다.\n\n변수 초기화:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- cur와 maxLines라는 변수를 초기화하여 현재 라인 수와 관찰된 최대 라인 수를 추적합니다.\n\n정렬된 요소 처리:\n\n- 동일한 값으로 처리할 요소를 처리하기 위해 정렬된 배열 v를 반복합니다.\n- 각 요소에 대해 다음을 계산합니다:\n  - down: 시작 부분에서 이전 요소보다 큰 요소 수 또는 끝 부분에서 다음 요소보다 큰 요소 수.\n  - up: 시작 부분에서 다음 요소보다 크지 않은 요소 수 또는 끝 부분에서 이전 요소보다 크지 않은 요소 수.\n  - peaks: 다음과 이전 요소보다 큰 요소 수.\n  - valleys: 다음과 이전 요소보다 작은 요소 수.\n  - peaks를 추가하고 valleys를 빼고 down/up 값을 통해 현재 라인 수 cur를 조정합니다.\n  - 현재 라인 수가 이전 최대값을 초과하면 최대 라인 수 maxLines를 업데이트합니다.\n\n결과 반환:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 배열에서 각각의 peak(봉우리)와 valley(골짜기) 전환을 나타내는 비중복 라인(줄)의 최대 수인 maxLines를 반환합니다.\n\n## 실행 과정,\n\n```js\n중간 결과와 함께 설명:\n초기화:\n\n이전 요소보다 큰지, 이후 요소보다 큰지를 추적할 isGreaterThanPrev 및 isGreaterThanNext 배열이 생성됩니다.\nisGreaterThanNext = [false, true, true, false, false, true, -1]\nisGreaterThanPrev = [-1, true, false, false, true, true, false]\n쌍 생성 및 정렬:\n\nY의 각 요소에 대해 [값, 인덱스] 쌍 생성합니다.\n정렬 전 v: [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]\n값을 기준으로 v를 내림차순으로 정렬합니다.\n정렬 후 v: [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]\n정렬된 요소 처리:\n\n요소 6 (인덱스 5):\ndown = 1, 이전 요소보다 크고, 끝에 위치하므로\nup = 0, 조건 충족 없음.\ncur = 1, maxLines = 1\n요소 5 (인덱스 4와 6):\n인덱스 4:\ndown = 0, up = 0\n인덱스 6:\ndown = 0, up = 1, 이전 요소보다 크지 않고, 끝에 위치하므로\n봉우리 = 0, 골짜기 = 0\ncur = 1 - 1 = 0, maxLines = 1\n요소 3 (인덱스 1):\ndown = 0, up = 0\n봉우리 = 1, 이전과 이후 요소보다 크기 때문.\ncur = 0 + 1 - 0 = 1, maxLines = 1\n요소 2 (인덱스 0와 2):\n인덱스 0:\ndown = 0, up = 1, 이후 요소보다 크지 않고, 시작에 위치하므로\n인덱스 2:\ndown = 0, up = 0\n봉우리 = 0, 골짜기 = 1, 이전과 이후 요소보다 작기 때문.\ncur = 1 - 1 - 0 = 0, maxLines = 1\n요소 1 (인덱스 3):\ndown = 0, up = 0\n봉우리 = 0, 골짜기 = 0\ncur = 0 + 0 - 0 = 0, maxLines = 1\n최종 결과:\n\n관측된 최대 라인 수는 1이고, 따라서 maxLines = 1입니다.\r\n```\n\n## 구현,\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunction solution(Y) {\n  let n = Y.length;\n\n  // 다음 요소보다 크다는지 이전 요소보다 크다는지 추적하는 배열\n  let isGreaterThanPrev = new Array(n);\n  let isGreaterThanNext = new Array(n);\n  isGreaterThanNext[n - 1] = -1; // 마지막 요소는 다음 요소가 없음\n  isGreaterThanPrev[0] = -1; // 첫 요소는 이전 요소가 없음\n\n  // isGreaterThanNext 배열 작성\n  for (let i = 0; i < n - 1; i++) {\n    isGreaterThanNext[i] = Y[i] > Y[i + 1];\n  }\n\n  // isGreaterThanNext = [false, true, true, false, false, true, -1]\n\n  // isGreaterThanPrev 배열 작성\n  for (let i = 1; i < n; i++) {\n    isGreaterThanPrev[i] = Y[i] > Y[i - 1];\n  }\n\n  // isGreaterThanPrev = [-1, true, false, false, true, true, false]\n\n  // [값, 인덱스] 쌍의 배열 생성\n  let v = [];\n  for (let i = 0; i < n; i++) {\n    v.push([Y[i], i]);\n  }\n\n  // v = [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]\n\n  // 값 기준으로 내림차순 정렬\n  v.sort((a, b) => b[0] - a[0]);\n\n  // v = [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]\n\n  let cur = 0,\n    maxLines = 0;\n  for (let i = 0; i < v.length; i++) {\n    let y = v[i][0];\n\n    let peaks = 0,\n      valleys = 0,\n      down = 0,\n      up = 0;\n\n    // 동일한 값 요소 처리\n    while (i < v.length && v[i][0] === y) {\n      let idx = v[i][1];\n\n      // 아래로 향하는 지점인지 확인\n      if (\n        (idx === 0 && isGreaterThanNext[idx]) ||\n        (idx === n - 1 && isGreaterThanPrev[idx])\n      ) {\n        down++;\n      }\n\n      // 올라가는 골짜기인지 확인\n      if (\n        (idx === 0 && !isGreaterThanNext[idx]) ||\n        (idx === n - 1 && !isGreaterThanPrev[idx])\n      ) {\n        up++;\n      }\n\n      let isNotEnd = idx > 0 && idx < n - 1;\n\n      // 산인지 확인\n      if (isNotEnd && isGreaterThanNext[idx] && isGreaterThanPrev[idx]) {\n        peaks++;\n      } \n      // 계곡인지 확인\n      else if (isNotEnd && !isGreaterThanNext[idx] && !isGreaterThanPrev[idx]) {\n        valleys++;\n      }\n      i++;\n    }\n\n    i--;\n\n    // 현재 라인 수 계산\n    cur = cur + peaks - valleys + down;\n    maxLines = Math.max(maxLines, cur);\n\n    cur = cur + peaks - valleys - up;\n    maxLines = Math.max(maxLines, cur);\n  }\n\n  return maxLines;\n}\n\n// 사용 예시\nconsole.log(solution([2, 3, 2, 1, 5, 6, 5])); // 출력: 2\r\n```\n\n# 읽어 주셔서 감사합니다\n\n- 👏 이야기에 박수를 보내주시고 팔로우 부탁드립니다 👉\n- 📰 자바스크립트, 자료 구조 및 알고리즘, 리액트, 인터뷰 준비 등 다양한 콘텐츠 확인해보세요\n- 🔔 팔로우 링크: LinkedIn!\n\n늘 개선할 점이 있을텐데요. 의견을 자유롭게 공유해주세요. 😊\n","ogImage":{"url":"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png"},"coverImage":"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png","tag":["Tech"],"readingTime":9},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>질문 1</h1>\n<p><img src=\"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_0.png\" alt=\"이미지\"></p>\n<p>두 개의 동일한 길이를 가진 정수 배열 A와 B가 주어졌을 때, 시작점 j까지 A의 요소들의 누적 합이 B의 요소들의 누적 합과 같은 경우의 수를 반환하는 solution(A, B) 함수를 작성하십시오. 이때 다음 조건들을 만족해야 합니다:</p>\n<ul>\n<li>A의 요소들의 누적 합이 시작부터 j까지 B의 요소들의 누적 합과 동일합니다.</li>\n<li>A의 요소들의 누적 합이 배열 A의 총 합의 절반과 동일합니다.</li>\n<li>B의 요소들의 누적 합이 배열 B의 총 합의 절반과 동일합니다.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>방법,</h2>\n<ul>\n<li>총합 초기화: 주석은 sumA 및 sumB의 초기화 및 목적을 명확히 합니다.</li>\n<li>총합 계산: 총합을 계산하는 루프에 대한 주석이 있습니다.</li>\n<li>유효한 분할 지점 계산: count의 목적 및 유효한 분할 지점을 확인하는 논리에 대한 설명이 있습니다.</li>\n<li>누적 합: tempA 및 tempB의 초기화 및 누적 합을 추적하는 역할을 명확히 하는 주석이 있습니다.</li>\n<li>반복 및 조건 확인: 두 번째 요소부터 시작하는 루프, 유효한 분할 지점을 찾기 위해 확인된 조건 및 누적 합의 업데이트를 설명하는 주석이 있습니다.</li>\n</ul>\n<h2>실제 실행,</h2>\n<pre><code class=\"hljs language-js\">단계별 결과\n\n총합 계산:\nsumA 진행: <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>\nsumB 진행: <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>\n최종 sumA = <span class=\"hljs-number\">6</span>\n최종 sumB = <span class=\"hljs-number\">6</span>\n\n누적 합 및 조건 확인:\n\n초기화:\ntempA = <span class=\"hljs-number\">0</span>\ntempB = <span class=\"hljs-number\">0</span>\n\n반복:\n\nj = <span class=\"hljs-number\">1</span>:\ntempA = <span class=\"hljs-number\">4</span>\ntempB = -<span class=\"hljs-number\">2</span>\n조건 미충족\n\nj = <span class=\"hljs-number\">2</span>:\ntempA = <span class=\"hljs-number\">3</span>\ntempB = <span class=\"hljs-number\">3</span>\n조건: tempA === tempB &#x26;&#x26; <span class=\"hljs-number\">2</span> * tempA === sumA &#x26;&#x26; <span class=\"hljs-number\">2</span> * tempB == sumB\n<span class=\"hljs-number\">3</span> === <span class=\"hljs-number\">3</span> &#x26;&#x26; <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">3</span> === <span class=\"hljs-number\">6</span> &#x26;&#x26; <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">6</span> (참)\n하지만, j !== <span class=\"hljs-number\">1</span>이어야 조건이 검사됨\n\nj = <span class=\"hljs-number\">3</span>:\ntempA = <span class=\"hljs-number\">3</span>\ntempB = <span class=\"hljs-number\">3</span>\n조건: tempA === tempB &#x26;&#x26; <span class=\"hljs-number\">2</span> * tempA === sumA &#x26;&#x26; <span class=\"hljs-number\">2</span> * tempB == sumB\n<span class=\"hljs-number\">3</span> === <span class=\"hljs-number\">3</span> &#x26;&#x26; <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">3</span> === <span class=\"hljs-number\">6</span> &#x26;&#x26; <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">6</span> (참)\n조건 충족, 그러나 j !== <span class=\"hljs-number\">1</span>이므로 조건이 이 단계에서는 확인되지 않음\n\nj = <span class=\"hljs-number\">4</span>:\ntempA = <span class=\"hljs-number\">6</span>\ntempB = <span class=\"hljs-number\">6</span>\n필요한 길이를 초과하여 조건 확인이 안 됨\n\n최종 결과:\n조건 j !== <span class=\"hljs-number\">1</span> &#x26;&#x26; tempA === tempB &#x26;&#x26; <span class=\"hljs-number\">2</span> * tempA === sumA &#x26;&#x26; <span class=\"hljs-number\">2</span> * tempB == sumB이 전혀 충족되지 않아 count는 <span class=\"hljs-number\">0</span>으로 남습니다.\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>구현,</h2>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">A</span>: [<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">4</span>,-<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">3</span>]\n<span class=\"hljs-attr\">B</span>: [<span class=\"hljs-number\">0</span>,-<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">3</span>]\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">solution</span>(<span class=\"hljs-params\">A, B</span>) {\n  <span class=\"hljs-comment\">// 배열 A와 B의 총합을 저장할 sumA와 sumB를 초기화합니다.</span>\n  <span class=\"hljs-keyword\">let</span> sumA = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">let</span> sumB = <span class=\"hljs-number\">0</span>;\n\n  <span class=\"hljs-comment\">// 배열 A와 B의 요소 총합을 계산합니다.</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; A.<span class=\"hljs-property\">length</span>; i++) {\n    sumA += A[i]; <span class=\"hljs-comment\">// 각 반복 후 sumA = [0, 4, 3, 3, 6]</span>\n    sumB += B[i]; <span class=\"hljs-comment\">// 각 반복 후 sumB = [0, -2, 3, 3, 6]</span>\n  }\n\n  <span class=\"hljs-comment\">// sumA는 이제 6입니다.</span>\n  <span class=\"hljs-comment\">// sumB는 이제 6입니다.</span>\n\n  <span class=\"hljs-comment\">// 유효한 분할 지점의 수를 추적하는 count를 초기화합니다.</span>\n  <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;\n\n  <span class=\"hljs-comment\">// 현재 인덱스까지 누적 합을 저장할 tempA와 tempB를 초기화합니다.</span>\n  <span class=\"hljs-keyword\">let</span> tempA = A[<span class=\"hljs-number\">0</span>]; <span class=\"hljs-comment\">// tempA = 0</span>\n  <span class=\"hljs-keyword\">let</span> tempB = B[<span class=\"hljs-number\">0</span>]; <span class=\"hljs-comment\">// tempB = 0</span>\n\n  <span class=\"hljs-comment\">// 두 번째 요소부터 배열을 반복합니다.</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">1</span>; j &#x3C; A.<span class=\"hljs-property\">length</span>; j++) {\n    <span class=\"hljs-comment\">// 현재 누적 합(첫 번째 인덱스 제외)이 같고,</span>\n    <span class=\"hljs-comment\">// 서로의 배열 합의 절반인지 확인합니다.</span>\n    <span class=\"hljs-keyword\">if</span> (j !== <span class=\"hljs-number\">1</span> &#x26;&#x26; tempA === tempB &#x26;&#x26; <span class=\"hljs-number\">2</span> * tempA === sumA &#x26;&#x26; <span class=\"hljs-number\">2</span> * tempB == sumB) {\n      count++; <span class=\"hljs-comment\">// 이 경우 조건이 충족되지 않아 count는 여전히 0입니다.</span>\n    }\n\n    <span class=\"hljs-comment\">// 현재 요소로 누적 합을 업데이트합니다.</span>\n    tempA += A[j]; <span class=\"hljs-comment\">// 각 반복 후 tempA 값: [0, 4, 3, 3, 6]</span>\n    tempB += B[j]; <span class=\"hljs-comment\">// 각 반복 후 tempB 값: [0, -2, 3, 3, 6]</span>\n  }\n\n  <span class=\"hljs-comment\">// 유효한 분할 지점의 수를 반환합니다.</span>\n  <span class=\"hljs-keyword\">return</span> count; <span class=\"hljs-comment\">// 유효한 분할 지점을 찾지 못해 count는 0입니다.</span>\n}\n\n<span class=\"hljs-comment\">// 사용 예시</span>\n<span class=\"hljs-keyword\">const</span> A = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-keyword\">const</span> B = [<span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>];\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">solution</span>(A, B)); <span class=\"hljs-comment\">// 출력: 0</span>\n</code></pre>\n<h1>두 번째 질문</h1>\n<img src=\"/assets/img/2024-07-01-MicrosoftDSAInterviewQuestions_1.png\">\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>단계별 접근 방법:</h2>\n<p>초기화:</p>\n<ul>\n<li>각 요소가 이전 요소와 다음 요소보다 큰지를 추적하는 배열 isGreaterThanPrev 및 isGreaterThanNext를 초기화합니다.</li>\n<li>이전 요소나 다음 요소와 비교할 요소가 없는 첫 번째 요소의 isGreaterThanPrev와 마지막 요소의 isGreaterThanNext를 -1로 초기화합니다.</li>\n</ul>\n<p>비교 배열 채우기:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>배열 Y를 순회하여 각 요소가 다음 요소보다 큰지 나타내는 isGreaterThanNext를 채웁니다.</li>\n<li>배열 Y를 순회하여 각 요소가 이전 요소보다 큰지 나타내는 isGreaterThanPrev를 채웁니다.</li>\n</ul>\n<p>쌍(Pairs) 생성 및 정렬:</p>\n<ul>\n<li>각 Y의 요소에 대해 [값, 인덱스] 쌍을 포함하는 배열 v를 생성합니다.</li>\n<li>배열 v를 요소의 값에 기반하여 내림차순으로 정렬합니다.</li>\n</ul>\n<p>변수 초기화:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>cur와 maxLines라는 변수를 초기화하여 현재 라인 수와 관찰된 최대 라인 수를 추적합니다.</li>\n</ul>\n<p>정렬된 요소 처리:</p>\n<ul>\n<li>동일한 값으로 처리할 요소를 처리하기 위해 정렬된 배열 v를 반복합니다.</li>\n<li>각 요소에 대해 다음을 계산합니다:\n<ul>\n<li>down: 시작 부분에서 이전 요소보다 큰 요소 수 또는 끝 부분에서 다음 요소보다 큰 요소 수.</li>\n<li>up: 시작 부분에서 다음 요소보다 크지 않은 요소 수 또는 끝 부분에서 이전 요소보다 크지 않은 요소 수.</li>\n<li>peaks: 다음과 이전 요소보다 큰 요소 수.</li>\n<li>valleys: 다음과 이전 요소보다 작은 요소 수.</li>\n<li>peaks를 추가하고 valleys를 빼고 down/up 값을 통해 현재 라인 수 cur를 조정합니다.</li>\n<li>현재 라인 수가 이전 최대값을 초과하면 최대 라인 수 maxLines를 업데이트합니다.</li>\n</ul>\n</li>\n</ul>\n<p>결과 반환:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>배열에서 각각의 peak(봉우리)와 valley(골짜기) 전환을 나타내는 비중복 라인(줄)의 최대 수인 maxLines를 반환합니다.</li>\n</ul>\n<h2>실행 과정,</h2>\n<pre><code class=\"hljs language-js\">중간 결과와 함께 설명:\n초기화:\n\n이전 요소보다 큰지, 이후 요소보다 큰지를 추적할 isGreaterThanPrev 및 isGreaterThanNext 배열이 생성됩니다.\nisGreaterThanNext = [<span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">true</span>, -<span class=\"hljs-number\">1</span>]\nisGreaterThanPrev = [-<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">false</span>]\n쌍 생성 및 정렬:\n\nY의 각 요소에 대해 [값, 인덱스] 쌍 생성합니다.\n정렬 전 <span class=\"hljs-attr\">v</span>: [[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>], [<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>]]\n값을 기준으로 v를 내림차순으로 정렬합니다.\n정렬 후 <span class=\"hljs-attr\">v</span>: [[<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>], [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>], [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>], [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>]]\n정렬된 요소 처리:\n\n요소 <span class=\"hljs-number\">6</span> (인덱스 <span class=\"hljs-number\">5</span>):\ndown = <span class=\"hljs-number\">1</span>, 이전 요소보다 크고, 끝에 위치하므로\nup = <span class=\"hljs-number\">0</span>, 조건 충족 없음.\ncur = <span class=\"hljs-number\">1</span>, maxLines = <span class=\"hljs-number\">1</span>\n요소 <span class=\"hljs-number\">5</span> (인덱스 <span class=\"hljs-number\">4</span>와 <span class=\"hljs-number\">6</span>):\n인덱스 <span class=\"hljs-number\">4</span>:\ndown = <span class=\"hljs-number\">0</span>, up = <span class=\"hljs-number\">0</span>\n인덱스 <span class=\"hljs-number\">6</span>:\ndown = <span class=\"hljs-number\">0</span>, up = <span class=\"hljs-number\">1</span>, 이전 요소보다 크지 않고, 끝에 위치하므로\n봉우리 = <span class=\"hljs-number\">0</span>, 골짜기 = <span class=\"hljs-number\">0</span>\ncur = <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">1</span> = <span class=\"hljs-number\">0</span>, maxLines = <span class=\"hljs-number\">1</span>\n요소 <span class=\"hljs-number\">3</span> (인덱스 <span class=\"hljs-number\">1</span>):\ndown = <span class=\"hljs-number\">0</span>, up = <span class=\"hljs-number\">0</span>\n봉우리 = <span class=\"hljs-number\">1</span>, 이전과 이후 요소보다 크기 때문.\ncur = <span class=\"hljs-number\">0</span> + <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">0</span> = <span class=\"hljs-number\">1</span>, maxLines = <span class=\"hljs-number\">1</span>\n요소 <span class=\"hljs-number\">2</span> (인덱스 <span class=\"hljs-number\">0</span>와 <span class=\"hljs-number\">2</span>):\n인덱스 <span class=\"hljs-number\">0</span>:\ndown = <span class=\"hljs-number\">0</span>, up = <span class=\"hljs-number\">1</span>, 이후 요소보다 크지 않고, 시작에 위치하므로\n인덱스 <span class=\"hljs-number\">2</span>:\ndown = <span class=\"hljs-number\">0</span>, up = <span class=\"hljs-number\">0</span>\n봉우리 = <span class=\"hljs-number\">0</span>, 골짜기 = <span class=\"hljs-number\">1</span>, 이전과 이후 요소보다 작기 때문.\ncur = <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">1</span> - <span class=\"hljs-number\">0</span> = <span class=\"hljs-number\">0</span>, maxLines = <span class=\"hljs-number\">1</span>\n요소 <span class=\"hljs-number\">1</span> (인덱스 <span class=\"hljs-number\">3</span>):\ndown = <span class=\"hljs-number\">0</span>, up = <span class=\"hljs-number\">0</span>\n봉우리 = <span class=\"hljs-number\">0</span>, 골짜기 = <span class=\"hljs-number\">0</span>\ncur = <span class=\"hljs-number\">0</span> + <span class=\"hljs-number\">0</span> - <span class=\"hljs-number\">0</span> = <span class=\"hljs-number\">0</span>, maxLines = <span class=\"hljs-number\">1</span>\n최종 결과:\n\n관측된 최대 라인 수는 <span class=\"hljs-number\">1</span>이고, 따라서 maxLines = <span class=\"hljs-number\">1</span>입니다.\n</code></pre>\n<h2>구현,</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">solution</span>(<span class=\"hljs-params\">Y</span>) {\n  <span class=\"hljs-keyword\">let</span> n = Y.<span class=\"hljs-property\">length</span>;\n\n  <span class=\"hljs-comment\">// 다음 요소보다 크다는지 이전 요소보다 크다는지 추적하는 배열</span>\n  <span class=\"hljs-keyword\">let</span> isGreaterThanPrev = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(n);\n  <span class=\"hljs-keyword\">let</span> isGreaterThanNext = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>(n);\n  isGreaterThanNext[n - <span class=\"hljs-number\">1</span>] = -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 마지막 요소는 다음 요소가 없음</span>\n  isGreaterThanPrev[<span class=\"hljs-number\">0</span>] = -<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 첫 요소는 이전 요소가 없음</span>\n\n  <span class=\"hljs-comment\">// isGreaterThanNext 배열 작성</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; n - <span class=\"hljs-number\">1</span>; i++) {\n    isGreaterThanNext[i] = Y[i] > Y[i + <span class=\"hljs-number\">1</span>];\n  }\n\n  <span class=\"hljs-comment\">// isGreaterThanNext = [false, true, true, false, false, true, -1]</span>\n\n  <span class=\"hljs-comment\">// isGreaterThanPrev 배열 작성</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">1</span>; i &#x3C; n; i++) {\n    isGreaterThanPrev[i] = Y[i] > Y[i - <span class=\"hljs-number\">1</span>];\n  }\n\n  <span class=\"hljs-comment\">// isGreaterThanPrev = [-1, true, false, false, true, true, false]</span>\n\n  <span class=\"hljs-comment\">// [값, 인덱스] 쌍의 배열 생성</span>\n  <span class=\"hljs-keyword\">let</span> v = [];\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; n; i++) {\n    v.<span class=\"hljs-title function_\">push</span>([Y[i], i]);\n  }\n\n  <span class=\"hljs-comment\">// v = [[2, 0], [3, 1], [2, 2], [1, 3], [5, 4], [6, 5], [5, 6]]</span>\n\n  <span class=\"hljs-comment\">// 값 기준으로 내림차순 정렬</span>\n  v.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =></span> b[<span class=\"hljs-number\">0</span>] - a[<span class=\"hljs-number\">0</span>]);\n\n  <span class=\"hljs-comment\">// v = [[6, 5], [5, 4], [5, 6], [3, 1], [2, 0], [2, 2], [1, 3]]</span>\n\n  <span class=\"hljs-keyword\">let</span> cur = <span class=\"hljs-number\">0</span>,\n    maxLines = <span class=\"hljs-number\">0</span>;\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; v.<span class=\"hljs-property\">length</span>; i++) {\n    <span class=\"hljs-keyword\">let</span> y = v[i][<span class=\"hljs-number\">0</span>];\n\n    <span class=\"hljs-keyword\">let</span> peaks = <span class=\"hljs-number\">0</span>,\n      valleys = <span class=\"hljs-number\">0</span>,\n      down = <span class=\"hljs-number\">0</span>,\n      up = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-comment\">// 동일한 값 요소 처리</span>\n    <span class=\"hljs-keyword\">while</span> (i &#x3C; v.<span class=\"hljs-property\">length</span> &#x26;&#x26; v[i][<span class=\"hljs-number\">0</span>] === y) {\n      <span class=\"hljs-keyword\">let</span> idx = v[i][<span class=\"hljs-number\">1</span>];\n\n      <span class=\"hljs-comment\">// 아래로 향하는 지점인지 확인</span>\n      <span class=\"hljs-keyword\">if</span> (\n        (idx === <span class=\"hljs-number\">0</span> &#x26;&#x26; isGreaterThanNext[idx]) ||\n        (idx === n - <span class=\"hljs-number\">1</span> &#x26;&#x26; isGreaterThanPrev[idx])\n      ) {\n        down++;\n      }\n\n      <span class=\"hljs-comment\">// 올라가는 골짜기인지 확인</span>\n      <span class=\"hljs-keyword\">if</span> (\n        (idx === <span class=\"hljs-number\">0</span> &#x26;&#x26; !isGreaterThanNext[idx]) ||\n        (idx === n - <span class=\"hljs-number\">1</span> &#x26;&#x26; !isGreaterThanPrev[idx])\n      ) {\n        up++;\n      }\n\n      <span class=\"hljs-keyword\">let</span> isNotEnd = idx > <span class=\"hljs-number\">0</span> &#x26;&#x26; idx &#x3C; n - <span class=\"hljs-number\">1</span>;\n\n      <span class=\"hljs-comment\">// 산인지 확인</span>\n      <span class=\"hljs-keyword\">if</span> (isNotEnd &#x26;&#x26; isGreaterThanNext[idx] &#x26;&#x26; isGreaterThanPrev[idx]) {\n        peaks++;\n      } \n      <span class=\"hljs-comment\">// 계곡인지 확인</span>\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isNotEnd &#x26;&#x26; !isGreaterThanNext[idx] &#x26;&#x26; !isGreaterThanPrev[idx]) {\n        valleys++;\n      }\n      i++;\n    }\n\n    i--;\n\n    <span class=\"hljs-comment\">// 현재 라인 수 계산</span>\n    cur = cur + peaks - valleys + down;\n    maxLines = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(maxLines, cur);\n\n    cur = cur + peaks - valleys - up;\n    maxLines = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(maxLines, cur);\n  }\n\n  <span class=\"hljs-keyword\">return</span> maxLines;\n}\n\n<span class=\"hljs-comment\">// 사용 예시</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">solution</span>([<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>])); <span class=\"hljs-comment\">// 출력: 2</span>\n</code></pre>\n<h1>읽어 주셔서 감사합니다</h1>\n<ul>\n<li>👏 이야기에 박수를 보내주시고 팔로우 부탁드립니다 👉</li>\n<li>📰 자바스크립트, 자료 구조 및 알고리즘, 리액트, 인터뷰 준비 등 다양한 콘텐츠 확인해보세요</li>\n<li>🔔 팔로우 링크: LinkedIn!</li>\n</ul>\n<p>늘 개선할 점이 있을텐데요. 의견을 자유롭게 공유해주세요. 😊</p>\n</body>\n</html>\n"},"__N_SSG":true}