{"pageProps":{"posts":[{"title":"2단계 인증 앱이 012345를 받았을 때 알려주는 기능","description":"","date":"2024-05-23 14:53","slug":"2024-05-23-The2FAappthattellsyouwhenyouget012345","content":"\n이른 시기 2010년대에 성장한 모든 회복된 엣지로드와 같이 나는 4chan과 같은 이미지 보드의 전성기를 약간 그리워합니다. 그들은 나치들이 모든 것을 망쳐 버리기 전에 야생 서부 초기 인터넷의 마지막 요새였어요.\n\n클래식한 밈 중 하나는 GET이었는데, 당신이 랜덤으로 생성된 게시물 ID가 흥미로운 숫자 시퀀스를 포함할 것으로 정확히 예상했을 때 자부심을 느끼게 됩니다.\n\n![그림](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png)\n\n요즘에는 이제 모든 보통 사람들이 성장하고 직장을 찾은 지금, 옛날의 마법에 제일 가까이 올 수 있는 것은 이중 인증 코드뿐입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신이 알고 있으면 좋아요.\n\n은행, 이메일 또는 클라우드 서비스에 다시 인증해야 하는 번거로움. 787000 또는 123450 같이 정말 좋은 숫자를 받았을 때의 작은 기쁨.\n\n영감을 받았어요.\n\n이 MFA 코드들은 매 30초마다 갱신되는 공통 알고리즘을 사용해요. 우리가 6자리 인증 코드에서 가능한 더블, 트리플, 쿼드, 퀸텀플, 섹스텀플 중에 매우 일부만을 경험하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 독립 프로젝트들처럼, 내 주변에 하나의 명확한 비전이 있었으며 그 주위에 구축할 수 있었습니다:\n\n내가 뭘 해야 하는지 알았어요.\n\n### 컨셉 증명\n\n이게 작동하는지 알아야 하는 움직이는 부품은 많이 필요하지 않아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 2FA 비밀 키를 입력해주세요.\n- 로컬에서 6자리 2FA 코드를 생성합니다.\n- 쿼드/퀸트/섹스트가 생성될 때 푸시 알림을 보냅니다.\n\n## 최소 기능 제품\n\n만약 멋진 2FA 번호가 생성될 때 알림을 받는 개념이 유지된다면, 몇 가지 주요 기능을 갖춘 실제 앱으로 발전시킬 수 있습니다:\n\n- 카메라로 2FA 비밀을 캡처합니다.\n- 여러 2FA 코드를 저장합니다.\n- 더 많은 숫자 패턴을 구현합니다.\n- 사용자가 알고 싶은 패턴을 선택할 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내가 뭔가를 알고 있었다는 걸 알았어: 내가 이걸 설명한 사람들의 90%는 나를 멍청이로 생각했어. 나머지 10%는 순수한 창의성만을 보았어.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_1.png)\n\n# Proof of Concept 구축\n\n## TOTP\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTOTP 또는 시간 기반 일회용 비밀번호는 놀랍도록 간단한 개념입니다. 이는 두 가지 입력을 사용하는 인증 프로세스입니다:\n\n- 인증 서비스 및 자신의 장치에 저장된 비밀 키\n- 현재 시간 또는 더 정확히 말하면 유닉스 시간 이후 경과한 30초 간격의 수\n\n이 알고리즘은 두 입력을 결정론적으로 해시하여 여러분이 알고 사랑하는 6자리 코드를 생성합니다. 이 해싱 알고리즘은 Apple의 CryptoKit에서 찾을 수 있는 매우 흔한 것입니다. Apple 포럼의 우리 친구들 덕분에 여기 TOTP 알고리즘의 전체 영광이 있습니다.\n\n```js\n// CodeGenerator.swift\n\nprivate let secret = Data(base64Encoded: \"AAAAAAAAAAAAAAAAAAAAAAAAAAA\")!\n\nfunc otpCode(date: Date = Date()) -> String {\n    let digits = 6\n    let period = TimeInterval(30)\n    let counter = UInt64(date.timeIntervalSince1970 / period)\n    let counterBytes = (0..<8).reversed().map { UInt8(counter >> (8 * $0) & 0xff) }\n    let hash = HMAC<Insecure.SHA1>.authenticationCode(for: counterBytes, using: SymmetricKey(data: secret))\n    let offset = Int(hash.suffix(1)[0] & 0x0f)\n    let hash32 = hash\n        .dropFirst(offset)\n        .prefix(4)\n        .reduce(0, { ($0 << 8) | UInt32($1) })\n    let hash31 = hash32 & 0x7FFF_FFFF\n    let pad = String(repeating: \"0\", count: digits)\n    return String((pad + String(hash31)).suffix(digits))\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 텍스트를 친근한 분위기로 한국어로 번역하면 다음과 같습니다.\n\n\"작업이 올바르게 진행되었는지 확인하기 위해, 구글 계정에 2단계 인증을 설정하고 해당 앱에서 비밀을 알고리즘을 사용하여 표시했어요.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_2.png)\n\n그리고, 마법처럼 (약간 번거로운 base32에서 base64로의 변환 후에), 구글이 내 2단계 인증을 승인했어요!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_3.png)\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 2단계 인증의 기본적인 부분이 작동 중이니, 컨셉 증명 퍼즐의 마지막 조각인 알림 생성을 구현할 수 있습니다.\n\n## 앱 제한 사항\n\n저희의 주요 제한 사항은 모바일 장치에 있습니다.\n\n실제로 2단계 인증 생성과 같은 백그라운드 프로세스를 영원히 실행할 수 없으며, 반드시 사용자 비밀을 백엔드 푸시 서버에 저장할 수 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러므로 이 개념이 작동하도록하려면 약간 교묘해야합니다: 앞으로 2FA 코드를 미리 계산하고, 그들이 실제로 출현하는 시간에 전달을 예약해야합니다.\n\n또한, iOS에서 동시에 64개의 푸시를 예약할 수 있으므로, 다음을 고려해야합니다:\n\n- 사용자에게 앱을 다시 입력하도록 요청하는 알림 하나 또는 두 개를 저장합니다.\n- 알림을 터치하여 사용자가 앱을 열도록 유도하여 2FA 코드를 재계산하도록합니다.\n\n이제 POC가 작동하는 방법을 알았으니, 빌드를 시작합시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 첫 번째 GETs 찾기\n\n우리의 보잘것없는 2FA 코드를 향상시켜 봅시다.\n\n우리는 많은 코드를 미리 계산한 후, 각 코드가 GET인지를 확인하는 레귤러 표현식을 구현할 계획입니다.\n\n제 아주 간단한 SwiftUI 뷰는 UICollectionView를 백업으로 사용하여 성능이 훌륭하도록 보장하기 위해 이러한 코드를 편리하게 표시할 수 있습니다 (ScrollView의 기본 VStack은 10,000개의 항목 이전에 멀쩡히 오작동하기 시작할 것입니다!).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// ContentView.swift\n\nstruct ContentView: View {\n\n    var body: some View {\n        List {\n            ForEach(makeOTPs(), id: \\.self) {\n                Text($0)\n                    .font(.custom(\"Courier\", size: 20))\n                    .font(.title)\n                    .kerning(4)\n            }\n            .frame(maxWidth: .infinity)\n        }\n    }\n\n    func makeOTPs() -> [String] {\n        (0..<10_000).map {\n            otpCode(increment: $0)\n        }\n    }\n}\n```\n\n잘 진행되고 있어요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_4.png)\n\n이제, 세 자리 숫자가 연속으로 나타나는 TOTP(예: 120333)를 확인하는 간단한 정규 표현식 평가기를 추가할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nextension String {\n    func checkThoseTrips() -> Bool {\n        (try? /(\\d)\\1\\1/.firstMatch(in: self)) != nil\n    }\n}\n```\n\nText 뷰에 fontWeight 수정자를 추가하여 스크롤할 때 이 GET을 쉽게 감지할 수 있습니다.\n\n```swift\nText($0)\n    .fontWeight($0.checkThoseTrips() ? .heavy : .light)\n```\n\n에쟈! 그 여행을 확인하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_5.png\" />\n\n우리는 심지어 우리의 정규 표현식을 신성한 네 숫자를 감지하기 위해 기본 수정할 수도 있어요 — 이건 독자들에게 연습문제로 남길게요.\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_6.png\" />\n\n## 전혀 소용없지만 재미있는 관찰\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 부주의한 ForEach 구현으로 인해 다음 경고 메시지가 발생했습니다:\n\n```js\nForEach<Array<String>, String, Text>: the ID 312678 occurs multiple\ntimes within the collection, this will give undefined results!\n```\n\n실제로 이 경고를 수십 번 받았습니다!\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_7.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리가 10,000개의 OTP를 생성했기 때문에, 여러 개가 일치할 가능성이 매우 높습니다. 이는 생일 문제와 같은 원리이며, 가능한 일치 쌍의 수는 백만 이상이 됩니다.\n\n## 희귀한 GET 생성하기\n\n이제 몇 가지 흥미로운 코드를 계산해 보겠습니다.\n\n여기서 중요한 점은 미리 계산하여 미래를 예측하는 것입니다: TOTP는 비밀과 날짜 입력의 결정적 해시이기 때문에, 우리는 미래의 오랜 일련의 날짜를 입력하여 특정 시간에 어떤 OTP 코드를 볼 수 있는지 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 코드와 날짜를 반환하도록 OTP 생성 방식을 조정해보겠습니다:\n\n```js\n// TOTP.swift\n\nstruct OTP {\n    let date: Date\n    let code: String\n}\n\nfunc otpCode(date: Date = Date(), increment: Int = 0) -> OTP {\n    let digits = 6\n    let period = TimeInterval(30)\n    let adjustedDate = date.addingTimeInterval(period * Double(increment))\n    let counter = UInt64(adjustedDate.timeIntervalSince1970 / period)\n    let counterBytes = (0..<8).reversed().map { UInt8(counter >> (8 * $0) & 0xff) }\n    let hash = HMAC<Insecure.SHA1>.authenticationCode(for: counterBytes, using: SymmetricKey(data: secret))\n    let offset = Int(hash.suffix(1)[0] & 0x0f)\n    let hash32 = hash\n        .dropFirst(offset)\n        .prefix(4)\n        .reduce(0, { ($0 << 8) | UInt32($1) })\n    let hash31 = hash32 & 0x7FFF_FFFF\n    let pad = String(repeating: \"0\", count: digits)\n    let code = String((pad + String(hash31)).suffix(digits))\n    return OTP(date: adjustedDate, code: code)\n}\n```\n\n이를 테스트하기 위해 다수의 코드를 생성하고, GETs: quints (5개의 중복번호)를 검색해 보겠습니다.\n\n```js\nfunc interestingCodes() -> [OTP] {\n    (0..<1_000_000)\n        .map { otpCode(increment: $0) }\n        .filter { $0.code.checkThoseQuints() }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 M1이 해싱 함수를 실행하는 동안 몇 번의 숫자 계산 후, 약 30초 동안 진행된 결과물은 몇몇 굉장히 확인 가능한 GET들로 이어졌어요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_8.png)\n\n## 우리의 알림 일정 설정하기\n\n좋은 숫자를 볼 수 있어서 재미있긴 하지만, 만약 실제로 GETs를 실생활에서 진짜 인증을 위해 사용할 수 없다면, 이 앱 개념은 그냥 무작위 번호 생성기와 다를게 없죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 흥미로운 숫자가 도착하는 시점을 알게 되었으니, 번호를 실시간으로 받을 수 있도록 푸시 알림을 대기열에 넣고 있어요:\n\n```js\n// NotificationScheduler.swift\n\nprivate func createNotification(for otp: OTP) {\n    let center = UNUserNotificationCenter.current()\n    let content = UNMutableNotificationContent()\n    content.title = \"Quads GET!!\"\n    content.body = otp.code\n    content.sound = UNNotificationSound.default\n    let components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second], from: otp.date)\n    let trigger = UNCalendarNotificationTrigger(dateMatching: components, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    center.add(request) { (error) in\n        // ...\n    }\n}\n```\n\n이 알림은 우리 뷰에서 사용하는 흥미로운 코드를 생성한 직후 예약되어 있어요. 그리고 잠시 후, 한꺼번에 2개의 멋진 푸시 알림을 받았답니다!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_9.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 통지가 실제로 나타나는 번호와 일치한다는 것을 확인하니, 더욱 흥미로워졌어요!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_10.png)\n\n아래 앱은 무작위 번호 생성기를 넘어서, 이 코드가 실제로 내 Google 계정에 로그인하는 데 도움이 된단 걸 알게 되었어요.\n\n## 흥미로움\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다양한 종류의 흥미로운 숫자를 결정하려면 흥미로움의 개념을 소개해야 합니다. 이는 반복되는 숫자, 연속하는 숫자, 수학적으로 흥미로운 숫자(예: 파이 또는 e), 회문을 포함할 수 있습니다.\n\n이러한 종류의 흥미로운 숫자는 ... 우리가 생성하는 각 OTP에 대해 선택적으로 만들어진 열거형 케이스로 열거될 수 있습니다.\n\n```js\n// 흥미로움.swift\n\n열거형 흥미로움 {\n\n    케이스 섹스텀\n    케이스 퀸츠\n    케이스 쿼드\n\n    이니셜라이저(code: String) {\n        if code.checkThoseSexts() {\n            self = .sexts\n        // ...\n\n    변수 타이틀: String {\n        switch self {\n        case .sexts: return \"Sextuples GET!!!\"\n        // ...\n\n    함수 본문(code: String) -> String {\n        switch self {\n        case .sexts: return \"체크해 보세요 섹스텀: \\(code)\"\n        // ...\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 checkThose 메소드는 다른 정규식을 래핑하며, 우리는 가장 중요한 순서대로 실행합니다. 예를 들어, 섹스튜플은 쿼드보다 100배 더 드물다.\n\n오랜만에 리팩터를 해서 우리는 개념 증명을 만들었습니다. 요약해보겠습니다:\n\n- 앱은 (하드코딩된) 2FA 보안 키를 입력할 수 있게 해줍니다.\n- 앱은 로컬에서 매 30초마다 6자리 2FA 코드를 생성합니다.\n- 앱은 쿼드, 퀸트, 섹스가 생성될 때 푸시 알림을 예약합니다.\n\n몇 일 동안 앱을 사용해보려고 쉬는 시간을 가질 것입니다. 내 손에 멋진 앱을 만들 수 있을 것 같다고 예상하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 최소 기능 제품 구축\n\n얼마 되지 않아, 몇 일 동안 제 아이디어의 핵심을 담은 앱, 즉 우선 증명 개념 버전을 사용해왔어요. 그리고 정말 좋아해요. 처음으로 여섯 번째 메시지를 받을 때까지 기다릴 수가 없네요.\n\n이제는 뼈대에 고기를 붙여 완전히 다듬어진 2FA 앱을 구축할 때입니다. 이전에 설명한 대로, 실제로 4가지 주요 새로운 기능만 추가하면 됩니다:\n\n- 2FA QR 코드를 스캔하여 안전하게 키체인에 저장하기\n- 사용자 인터페이스에서 여러 2FA 계정을 표시하고 관리하기\n- 사용자가 중요하게 여기는 번호 설정하기\n- 더 많은 종류의 재미있는 기능 구현하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 기능적이 아닌 요구 사항: 매우 느린 코드 생성을 최적화하는 작업을 해야 합니다. 배치 처리 또는 로컬 지속성을 활용할 수도 있을 것 같아요.\n\n## 인간 인터페이스 가이드라인\n\n디자인에 대해 별다른 특별한 것을 할 계획은 없어요. 표준 애플 List 뷰 구성 요소를 사용하여 HIG를 따를 것이에요.\n\nUX는 멋지고 간단하게 유지합시다: 주로 푸시 알림에 기능이 집중되어 있으며 매우 완벽해요. 이 말은 QR 스캐너와 설정을 툴바 버튼 뒤에 숨기고, 모달 플로우가 표시되도록 하는 것을 의미해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Scanning 2FA Secrets](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_11.png)\n\n## Scanning 2FA Secrets\n\nA couple of open-source libraries will save me a ton of time on cookie-cutter tasks. CodeScanner to supply simple SwiftUI QR code scanning, and KeychainAccess to easily store these 2FA account secrets in the keychain.\n\n![Scanning 2FA Secrets](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_12.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 스캐너 라이브러리는 카메라 접근을 사용하여 QR 코드를 쉽게 구문 분석할 수 있는 URL로 변환합니다. 아래와 같은 형식으로 변환됩니다:\n\n```js\notpauth://totp/Google%3Atest%40gmail.com?secret=bv7exx7sltbcqffec1qyxscueydwsu5h&issuer=Google\n```\n\n이제 앱에 우리의 계정을 쉽게 추가할 수 있게 되었어요!\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_13.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 선호하는 숫자 선택하기\n\nSwiftUI @AppStorage를 사용하여 List 및 몇 가지 Toggles와 함께 사용하면 쉽게 사용자 설정 화면을 구축할 수 있습니다.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_14.png)\n\n나는 onDisappear에서 부모 뷰에게 다시 숫자 처리를 시작하고 알림을 다시 예약하라고 알리기 위해 클로저를 사용했습니다. 이것은 토글이 변경될 때마다 비싼 계산을 실행하는 대신 모든 것을 일괄 처리하는 가장 간단한 방법이었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// CodeView.swift\n\nvar body: some View {\n    // ...\n    .sheet(isPresented: $showSettings) {\n        SettingsView(onDisappear: {\n            viewModel.recomputeNotifications()\n        })\n    }\n}\n```\n\n## Belated Customer Research\n\n안녕하세요, 저는 독립 개발자에요. 프로젝트 빌드 과정 중간에 이것을 할 수 있어요!\n\n몇 가지 다른 2FA 앱을 다운로드해서 아이디어를 베낄 만한 것이 있는지 살펴보기로 결정했어요. 사실, 꽤 혼잡하고 경쟁력 있는 앱 시장을 기대했는데, 이 중 일부는 정말 형편없었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변환:\n\n![이미지1](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_15.png)\n\n정말이지, 그 중 50% 이상이 매우 공격적인 페이월을 설정해 놓고 사용하기 전에 이겼다... 무료 옵션이 완전히 제공되는 상황일 때 말이죠.\n\n이 페이월이 넘쳐난다 해도, 좋은 아이디어를 빌려올 수 있었던 몇 가지를 기록해 두었어요.\n\n![이미지2](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_16.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 여러 개의 2FA 계정\n\n여러 개의 계정을 가진 사람들에겐 이것이 매우 중요하죠. 계정이 많으면 더 많은 GET 기회가 생기기도 하거든요!\n\n내 키체인 코드를 업데이트했어요. 이제 여러 개의 QR 코드를 스캔할 수 있게 되었고, 계정 데이터(비밀 정보를 포함한)도 저장하게 되었어요. 이제 나의 다양한 계정으로 로그인하는 데 완벽하게 작동했어요!\n\n![QR 코드 이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_17.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 적절한 내장 목록 기능을 구현하여 이제 우리가 더 이상 필요하지 않은 코드를 삭제할 수 있습니다.\n\n경쟁사 분석을 하면서, 구글 인증 프로그램이 예전 아이폰에 추가한 2단계 인증 코드를 몇 년 전부터 계속 보관하고 있는 것을 발견했어요!\n\n그때 제 데이터 계층에서 두 가지 실수를 발견했습니다.\n\n- iCloud와 동기화하지 않았던 점\n- 키패인 밖에 계정을 지속하려고 한 점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, iCloud에 대한 키체인을 동기화하면 계정이 다른 모든 Apple 기기에 나타납니다. Keychain Access 라이브러리를 사용하면 쉽게 할 수 있어요:\n\n```js\n// KeychainManager.swift\n\nself.keychain = Keychain().synchronizable(true);\n```\n\n둘째, 저는 반짝이는 물건 증후군으로 고생했어요: SwiftData를 영속성 레이어로 사용하기 위해 서두르다 보니 Keychain만을 비밀로 사용하고 나머지 계정 메타데이터는 새로운 프레임워크를 통해 영속화하고 있었어요.\n\n이것은 다른 장치에서 나의 계정을 가져올 수 없었다는 것을 의미해요 — 비밀만으로는 쓸모가 없어요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 전 Account 객체 전체를 키체인에 저장해야 한다는 것을 깨달았어요.\n\n새로운 접근 방식은 QR 코드 URL을 키체인에 그대로 저장하는 것입니다. 이제 Account 객체 자체는 일시적입니다; 앱을 로드할 때마다 URL에서 다시 계산됩니다.\n\n이렇게 하면 로드할 때마다 Accounts가 로그인한 모든 iDevice에 나타날 수 있습니다! 이 일시적인 방식은 두 마리의 새끼를 한 방에 잡는 멋진 방법입니다. 이제 필요할 때 키체인에서 Accounts를 가져올 때 사용합니다:\n\n```swift\n// AccountManager.swift\n\nfunc fetchAccounts() throws -> [Account] {\n    try KeychainManager.shared.fetchAll()\n        .compactMap { createAccount(from: $0) }\n}\n\nprivate func createAccount(from urlString: String) -> Account? {\n    guard let url = URL(string: urlString),\n          let account = SecretURLParser.shared.account2FA(from: url) else {\n        return nil\n    }\n    return account\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반 코딩 작업을 많이 하여 UI를 개선하고 코드를 잘 리팩토링하는 작업을 했어요. 그런데 개발 과정에서 흥미로운 것들도 몇 가지 있었답니다.\n\n## 계정 아이콘 찾기\n\n이건 꽤 좋은 기능이에요. 하지만 최고의 오픈 소스 앱이 똑같은 일을 하길래, 적어도 그것만큼 좋아야 한다고 느꼈어요.\n\n다행히도, 웹 사이트에서 FavIcon을 검색하고 여러 해상도로 다운로드할 수 있는 Google API가 있답니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹사이트를 어떻게 디자인하면 좋을지 고민 중이군요. QR 코드의 발행자 속성을 사용하여 .com 도메인을 시도하는 방법으로 좋은 결과를 얻었다고 하셨군요.\n\n```swift\nstruct FavIcon {\n\n    let url: URL\n\n    init(issuer: String) {\n        let domain = \"\\(issuer).com\"\n        let url = URL(string: \"https://www.google.com/s2/favicons?sz=128&domain=\\(domain)\")!\n        self.url = url\n    }\n}\n```\n\n아이콘의 빠른 로딩을 위해 CachedAsyncImage 라이브러리를 사용한 거군요. 이렇게 하면 성능이 더 빨라질 거에요.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_18.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n배경 제거를 처리하고 아이콘을 좀 더 돋보이게 만들기 위해 Metal 셰이더를 추가했어요.\n\n여기 SwiftUI View 확장 부분이에요:\n\n```js\n//  View+ColorEffect.swift\n\nimport SwiftUI\n\nextension View {\n\n    func eraseBackground(backgroundColor: Color = Color(uiColor: UIColor.secondarySystemBackground)) -> some View {\n        modifier(EraseBackgroundShader(backgroundColor: backgroundColor))\n    }\n}\n\nstruct EraseBackgroundShader: ViewModifier {\n\n    let backgroundColor: Color\n\n    func body(content: Content) -> some View {\n        content\n            .colorEffect(ShaderLibrary.eraseBackground(\n                .color(backgroundColor)\n            ))\n    }\n}\n```\n\n그리고 물론 MSL 셰이더 코드도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```cpp\n#include <metal_stdlib>\n#include <SwiftUI/SwiftUI_Metal.h>\nusing namespace metal;\n\n[[ stitchable ]]\nhalf4 eraseBackground(\n    float2 position,\n    half4 color,\n    half4 backgroundColor\n) {\n\n    if (color.r >= 0.95 && color.g >= 0.95 && color.b >= 0.95) {\n        return backgroundColor;\n    }\n\n    return color;\n}\n```\n\n여기에 그들이 어떻게 보이는지 있어요. 그들은 나쁘지 않지만 놀라운 것은 아니에요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_19.png)\n\n난 지나치게 엔지니어링을 시작했어. 이것에 핀을 꽂아 놓고 나중에 다시 생각해 봐요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## UI 디자인 개선\n\n기본 2단계 인증 앱으로서 이미 꽤 잘 작동하고 있습니다.\n\n대부분의 사람들을 앞선 존재가 되기 위해서는, 극도로 공격적인 유료 벽을 두지 않으면 되는구나 ($4.99 매주? 정말?!)\n\n일부 기본 소프트웨어 개발 작업을 통해 타이밍, 기본 UI 및 데이터 저장 작업을 수행한 후, 이제는 정말로 아주 잘 작동하고 있습니다. - 기본 SwiftUI 구성 요소를 사용하는 것은 작업이 \"그냥 작동\"되도록하는 빛나는 방법입니다\\*.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*TUkFn9ejk93WczTL02Jlrg.gif)\n\n저는 경쟁사 조사를 통해 찾은 tap-to-copy와 같은 편의 기능 몇 가지를 구현했어요.\n\n@ScaledMetric와 ViewThatFits 같은 접근성 도구를 활용하여 시각적 요구에 관계없이 앱이 원할하게 작동하도록 했어요. Apple의 기본 SwiftUI 구성 요소와 색상에 밀접하게 따라가면서 무료로 라이트 모드도 구현되었어요.\n\n```js\n// AccountView.swift\n\n@ScaledMetric(relativeTo: .largeTitle) private var iconSize: CGFloat = 36\n\nprivate var icon: some View {\n    CachedAsyncImage(url: FavIcon(issuer: account.issuer).url, content: {\n        $0\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n\n    }, placeholder: {\n        Text(String(account.issuer.first?.uppercased() ?? account.name.first?.uppercased() ?? \"\"))\n            .font(.largeTitle)\n            .monospaced()\n    })\n    .frame(width: iconSize, height: iconSize, alignment: .center)\n}\n\nprivate var code: some View {\n    ViewThatFits {\n        HStack(alignment: .center, spacing: 16) {\n            codeText\n        }\n        VStack(alignment: .leading, spacing: 4) {\n            codeText\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_20.png\" />\n\n## 앱을 더 흥미롭게 만들기\n\n진정한 핵심 가치 제안을 개선하기 위해 흥미로운 옵션을 더 많이 구현했습니다:\n\n- 000000과 같은 섹스투플렛 및 쿼드투플렛\n- 012345와 같은 순서대로 계속되는 수열\n- 300000처럼 백만단위의 수\n- 000001과 같은 일의 자리, 000010과 같은 십의 자리\n- 원주율 파이(314159)와 같은 수학 상수\n- 플랑크 상수(6.6x10⁻³⁴)와 같은 물리 상수\n- 012210과 같은 회문\n- 121212와 123123과 같은 반복된 이차, 삼차 수열\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 Markdown 형식으로 표 태그를 변경한 코드입니다.\n\n```js\nfunc checkThatCounting() -> Bool {\n    let characters = Array(self)\n    for i in 1..<characters.count {\n        if let prevDigit = Int(String(characters[i - 1])),\n           let currentDigit = Int(String(characters[i])),\n           currentDigit != prevDigit + 1 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc checkThatPalindrome() -> Bool {\n    self == String(self.reversed())\n}\n\nfunc checkThoseRepeatedThrees() -> Bool {\n    self.prefix(3) == self.suffix(3)\n}\n\nfunc checkThoseHunderedThousands() -> Bool {\n    suffix(5) == \"00000\"\n}\n```\n\n## 확률 이론\n\n이제 설정 UI를 업데이트하여 흔함, 드물음, 초 희귀함으로 정렬하거나 반복, 상수, 순서 또는 라운드 숫자와 같은 유형으로 정렬할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_21.png\" />`\n\n각 희귀 수준의 확률을 어떻게 계산하나요?\n\n012345와 같은 완벽한 숫자 시퀀스의 경우, 1백만 개의 가능한 번호 조합 중 6가지만 가능합니다 (567890까지).\n\n30초에 1백만 개의 조합을 곱하고 가능한 시퀀스인 6으로 나누면, 각 계정당 평균적으로 완벽한 카운팅 시퀀스가 발생할 수 있다는 것은 약 5백만 초마다 발생할 수 있다는 것을 의미합니다 — 평균적으로 58일마다 한 번씩입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 정도라니, 정말 희귀한 것이죠.\n\n하지만 123321과 같은 회문 수는 만들 수 있는 3자리 수가 1000개에 달합니다. 이는 평균적으로 매일 0.34번씩 볼 수 있다는 뜻이에요! 훨씬 더 흔하죠.\n\n중간에는 141414와 같이 반복되는 숫자들이 있습니다. 이런 경우 가능한 숫자는 00부터 99까지의 100개인데요, 그래서 이들은 평균적으로 3.5일에 한 번씩 발생합니다. 그래서, 정말 희귀하지만, 극도로 희귀하지는 않은 편이에요.\n\n이 중 일부인 쿼드와 같은 일련 번호들은 조금 더 많은 계산이 필요한데, 그래서 수천만 개의 OTP(일회용 비밀번호)를 생성하고 각 흥미로운 종류별로 발생 빈도를 세어 상대적 빈도를 감을 수 있게 했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 성능 향상\n\n앱은 모든 일반적인 흥미로운 코드를 활성화한 상태에서만 아주 빠르게 64개의 흥미로운 2FA 코드를 처리할 수 있지만, 초희귀한 GET만 원할 때는 처리 시간이 오래 걸립니다.\n\n수백만 개의 잠재적인 OTP를 처리하는 동안, 유효한 흥미로운 코드를 발견하자마자 알림을 반환하고 예약하는 것이 필요합니다.\n\n오래된 친구인 Combine 프레임워크는 깔끔한 해결책을 제공해줍니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// CodeGenerator.swift\n\nvar codeSubject = PassthroughSubject<OTP, Never>()\n\nfunc generateCodes(accounts: [Account]) {\n    // ...\n    codeSubject.send(otp)\n}\n```\n\n또한 사용자가 중간에 설정을 변경하는 경우를 대비하여 작업을 취소하고 다시 시작할 수 있도록 일부 작업을 사용했습니다. 작업을 분리함으로써 암호 해독 및 문자열 분석 작업을 UI 스레드에서 유지하지 않을 수 있습니다.\n\n```swift\n// CodeViewModel.swift\n\nprivate var otpComputationTask: Task<Void, Never>?\nprivate var notificationSchedulingTask: Task<Void, Never>?\n\nfunc recomputeNotifications() {\n    handleNotificationScheduling()\n    handleOTPComputation()\n}\n\nprivate func handleNotificationScheduling() {\n    notificationSchedulingTask?.cancel()\n    notificationSchedulingTask = Task.detached(priority: .high) {\n        guard await NotificationScheduler.shared.isAuthorized() else { return }\n        NotificationScheduler.shared.cancelNotifications()\n        for await (code, count) in CodeGenerator.shared.codeSubject.values {\n            try? await NotificationScheduler.shared.scheduleNotification(for: code)\n        }\n    }\n}\n\nprivate func handleOTPComputation() {\n    let accounts = accounts\n    otpComputationTask?.cancel()\n    otpComputationTask = Task.detached(priority: .high) {\n        guard await NotificationScheduler.shared.isAuthorized() else { return }\n        CodeGenerator.shared.generateCodes(accounts: accounts)\n    }\n}\n```\n\n이제 일정이 시퀀스대로 아니라 하나의 큰 덩어리로 나오지 않고 꽤 부드럽게 작동합니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nScheduled repeatedTwos: 292929 @ 2024-02-25 23:33:30 +0000\nScheduled repeatedTwos: 878787 @ 2024-02-26 06:03:30 +0000\nScheduled quints: 666660 @ 2024-02-26 10:54:00 +0000\nScheduled quints: 255555 @ 2024-02-26 21:11:00 +0000\nScheduled repeatedTwos: 606060 @ 2024-02-26 23:27:00 +0000\nScheduled sexts: 666666 @ 2024-04-16 23:22:00 +0000\nScheduled boltzmannConstant: 141023 @ 2024-04-19 02:05:00 +0000\nScheduled counting: 012345 @ 2024-04-20 04:51:30 +0000\nScheduled planksConstant: 661034 @ 2024-04-20 05:38:00\n\n## 앱 아이콘\n\n이 거래 그냥 사라지고 싶었어요. 앱 아이콘에 진짜로 체크하려면 이제 목멸에 달렸거든요. 정말 완벽해요.\n\n![image](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_22.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 제 친구가 Lionsgate Films의 친구들이 조금 소송을 제기할 수도 있다고 지적했습니다.\n\n하지만 난 그걸 가져야 했어!\n\n어쨌든 희망이 있다면:\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_23.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그냥 개인정보를 꼭 보호하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n달리(DALL-E)는 정말 손등을 그리는 걸 좋아하지 않았어요. 저는 노력해 봤지만요.\n\n# 마지막 손질\n\n그 개념은 증명되었어요. 어플이 잘 작동하고 있어요! Check 'em의 즐거움을 세상에 보여주기 전에 약간의 마무리와 작은 기능을 추가할 시간이에요.\n\n첫 릴리스를 만들기 전에 V1에서 구현할 수 있는 새로운 기능과 버그 수정 사항들을 목록으로 만들었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 높은 우선순위 -\n// TODO: - 주문 추가 - 저장된 URL에 쿼리 항목으로 정렬 추가\n// TODO: - 새로 고침 시 햅틱 진동\n// TODO: - 푸시 알림 요청은 설정 화면에 진입했을 때에만\n// TODO: - 알림 활성화를 위한 설정 링크 추가\n// TODO: - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시 - 이미 있는 경우 계정에 스캔을 추가하지 않음\n// TODO: - 설정 화면을 열 때 처리 작업 취소\n// TODO: - 푸시 알림 딥 링크 - GET이 여전히 존재할 때 앱 리뷰 프롬프트로 이동\n// TODO: - 매우 드문 GET가 전송되지 않는 것 같음?? 시뮬레이터에서 로컬로 발생하지 않지만 quints는 괜찮음 - 큐에 들어가는 것처럼 보임\n// TODO: - 버그 - 두 번째 로드에서 진행 상황 보기가 나타나지 않음\n// TODO: - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시 - 이미 있는 경우 계정에 스캔을 추가하지 않음\n// TODO: - 버그 - 2개의 동시 계산이 있을 때 백분율이 계속 변동하는 버그 발생\n// TODO: - QR 및 설정에 TipKit 추가\n\n// 낮은 우선순위 -\n// TODO: - 상태 복원을 위해 @SceneStorage 사용 - 키패인 작업을 기다리지 않아도 되도록\n// TODO: - 한 단계 또는 뒤로 이동\n// TODO: - 딥 링크를 사용하여 \"컬렉션\" 화면 생성 - 보관된 항목으로 본 GET 수집 (키패인의 사전으로)\n```\n\n당연히, 제게 제품 관리자가 없기 때문에 최저 우선 순위의 작업을 즉시 시작했습니다: 딥 링크로 컬렉션을 구축하는 것 - 내 드문 GET가 헛되이 낭비되는 것을 원하지 않아요!\n\n## 컬렉션\n\n이 부분은 원본 개념 증명에서 식별한 문제에 도움이 됩니다: 사용자들이 알림과 상호 작용하도록 유도하여 앱에 재진입하도록 해야합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컬렉션 뷰를 만드는 것은 조금 까다로울 수 있어요. 왜냐하면 몇 가지 부분을 고려해야 되거든요:\n\n- 사용자가 알림을 탭하고 앱으로 딥 링크 할 수 있게 합니다.\n- 탭한 코드의 흥미로운 부분을 안전하게 저장합니다.\n- 이것들을 컬렉션 화면에 렌더링합니다.\n\n알림에 딥 링크를 추가하는 것은 꽤 간단했어요.\n\n```js\n// Notifications.swift\n\n// ...\ncontent.userInfo = [\"deepLink\": \"checkem://\\(otp.code)\"]\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 약간 거슬리지만, 알림을 처리하기 위해 AppDelegate를 만들어야 했어요 — SwiftUI는 아직 완전히 자체적으로 이를 다루지 못합니다.\n\n```swift\n// AppDelegate.swift\n\nfunc userNotificationCenter(_ center: UNUserNotificationCenter,\n                            didReceive response: UNNotificationResponse,\n                            withCompletionHandler completionHandler: @escaping () -> Void) {\n\n    let userInfo = response.notification.request.content.userInfo\n\n    if let deepLinkString = userInfo[\"deepLink\"] as? String,\n       let deepLinkURL = URL(string: deepLinkString) {\n        guard let code = deepLinkURL.code else { return }\n        try? CollectionManager.shared.save(code: code)\n    }\n\n    completionHandler()\n}\n```\n\n마지막으로, Keychain에 저장된 코드들의 긴 쉼표로 구분된 목록을 게으르게 추가했어요.\n\n```swift\n// KeychainManager.swift\n\nfunc storeCollectionItem(code: String) throws {\n    var collection = try keychain.get(Constants.collectionKey) ?? \"\"\n    if !collection.isEmpty {\n        collection.append(\",\")\n    }\n    collection.append(code)\n    try keychain.set(collection, key: Constants.collectionKey)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n빠르게 출시하기 위한 욕망의 결과인 것이지, 신중하게 고려된 엔지니어링 결정의 결과는 아닙니다. 사용자가 Keychain 항목 당 4kB의 소프트 제한에 가까워지는 경우 후회할 수 있는 결정이었습니다(하드 제한은 대략 16MB 이므로 괜찮을 것 같아요!).\n\n이 작업은 빠르게 성과를 거두었는데, 컬렉션 화면은 빠르게 내 소중한 GET들로 가득 차기 시작했어요!\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_27.png)\n\n원래는 사용자가 알림을 탭할 때까지 컬렉션을 숨겼었는데, 사용자가 '모두 수집하기'에 도전하도록 하는 것이 더 매력적이라고 깨달았어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_28.png\" />\n\n## 진동\n\niOS 17 sensoryFeedback API를 사용하면 매우 섬세한 진동을 재생할 수 있습니다. 사실 너무 섬세해서 저는 마음에 들지 않았어요. 그래서 Carbn에서 진동 엔진을 뽑아내어 여기에 재사용했어요.\n\n기존 새로고침 코드에 정말 가혹한 부작용을 추가했어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// CodeView.swift\n\n.onReceive(timer) { _ in\n    let didChange = viewModel.refresh()\n    if didChange {\n        HapticEngine.shared.play(haptic: .refresh)\n    }\n}\n```\n\n집에서는 시도하지 마세요, 친구들!\n\n## 이미지 로딩 버그\n\nCachedAsyncImage 라이브러리에서 FavIcons가 존재하지 않음에도 불구하고 열심히 로딩되는 버그가 있습니다. 이로 인해 희미한 지구 모양이 나타납니다... 하지만 이대로 릴리스할 것 같습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대부분의 경우 90% 정도는 잘 작동하며, 제가 개발한 Third-party SwiftUI 라이브러리 중 하나를 바꾸는 대신 배포하는 게 더 좋을 것 같아요.\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_29.png)\n\n## 중복 버그\n\n배포 전에 나머지 버그들 중 일부는 더 주의 깊게 살펴보았지만, 이 문제는 특히 나쁩니다. 누군가가 QR 코드를 두 번 스캔하면 동일한 계정의 이상한 중복이 발생할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// TODO: - 버그 - 뷰 모델 계정에서 스캔된 중복을 무시하도록 해주세요 - 이미 있는 경우 계정에 스캔을 추가하지 마세요\n```\n\n시간을 절약할 수 있는 라이브러리를 뜯어내고 교체하는 대신, 이 버그는 한 줄의 코드 수정으로 해결되었습니다.\n\n```js\n// CodeViewModel.swift\n\nfunc create(account: Account, url: URL) throws {\n    guard !accounts.contains(where: { $0.name == account.name }) else { return }\n    // ...\n}\n```\n\n2FA 계정을 이름을 기준으로 하는 키체인이기 때문에, 이 수정은 매우 합리적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 코드가 로드되지 않음\n\n코드가 대기열에 들어가지 않는 다른 문제를 발견했어요.\n\n```js\n// TODO: - 초희귀한 GET가 전송되지 않나요?? 에뮬레이터에서 로컬에서 발생시키질 못하겠는데 퀸트는 잘 됩니다 - 들어가야 할 것 같아요\n```\n\n알고 보니 @AppStorage가 실제로 작동하는 방식을 잘못 이해했던 것 같아요 — 기본값은 실제로 사용자 기본 설정에 저장하는 대신 UI에만 적용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// SettingsView.swift\n\n@AppStorage(\"sexts\") private var sexts: Bool = true\n```\n\n첫 번째 앱 로드 시 UserDefaults를 채우는 함수가 이 문제를 해결했습니다.\n\n```swift\n// CheckEmApp.swift\n\n@main\nstruct CheckEmApp: App {\n\n    init() {\n        initializeDefaultsIfRequired()\n    }\n\n    // ...\n\n    func initializeDefaultsIfRequired() {\n        guard UserDefaults.standard.object(forKey: \"sexts\") == nil else { return }\n        CodeGenerator.shared.initializeDefaults()\n    }\n```\n\n## TipKit\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 iOS 17 TipKit를 사용하여 조금 더 개선했어요. 사용자가 앱을 처음 로드할 때 무엇을 해야 하는지 간단히 이해할 수 있게 도와주는 기능이 추가되었답니다.\n\n![app screenshot](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_30.png)\n\n이 새로운 API로 구현하는 것이 의외로 간단했어요.\n\n```js\n// CodeView.swift\n\n@ViewBuilder\nprivate var tips: some View {\n    TipView(QRTip()).tipImageSize(CGSize(width: tipImageSize, height: tipImageSize))\n    TipView(SettingsTip()).tipImageSize(CGSize(width: tipImageSize, height: tipImageSize))\n    TipView(CollectionTip()).tipImageSize(CGSize(width: tipImageSize, height: tipImageSize))\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 상점 상품 목록\n\n출시할 준비가 끝났다고 생각해요.\n\n![상품 목록](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_31.png)\n\nAppScreens를 통해 상점 상품 목록을 설정 중이에요. 저희의 캣츠가 등장하는 Check 'em의 진정한 힘을 보여주는 두 번째 스크린샷을 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n---\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_32.png)\n\n진짜요?\n\n![이미지](/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_33.png)\n\n알겠어요, 제가 세계에서 가장 자유주의자적인 사람은 아니지만, 시장을 1% 증가시키기 위해 여러 가지 번거로움을 겪는 건 싫어요. 좀 더 나은 방법이 있지 않을까요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(내 프랑스 독자 여러분 죄송해요)\n\n간단히 말해서, 우리는 앱 스토어 커넥트에 설정을 완료했고 버튼을 누르기 ready해요!\n\n## 결론\n\n저의 여정을 따라 읽어주셔서 감사합니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 프로젝트는 정말 재미있었어요! 패턴을 찾는 것을 좋아하는 내 내재적인 IT 열정을 만졌을 뿐만 아니라, 멋진 처리, 스레딩, 최적화 문제를 다루어 볼 수 있었어요!\n\n다음 단계로, v1.1 릴리스에 대한 성능에 완전히 초점을 맞춘 상태입니다. 이제 OTP(일회용 암호)를 더 빠르게 처리하고 빠르게 불러올 거예요!\n\n이 앱을 좋아하시면, 보고 싶은 숫자에 대한 의견을 주세요! 마지막으로, Android 버전을 원하는 분들이 계신다면, 제 소스 코드를 공유해드리고 함께 개발할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png"},"coverImage":"/assets/img/2024-05-23-The2FAappthattellsyouwhenyouget012345_0.png","tag":["Tech"],"readingTime":44},{"title":"iOS용 Fastlane과 GitHub Actions를 사용하여 CICD 파이프라인 구성하기","description":"","date":"2024-05-23 14:50","slug":"2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions","content":"\n현재 소프트웨어 개발에서 필수적인 실천 방법인 지속적 통합 및 지속적 배포 (CI/CD)는 애플리케이션의 테스트, 빌드, 그리고 배포 과정을 자동화합니다. iOS 개발자들에게는 GitHub Actions와 Fastlane을 활용하여 이러한 방식을 효율적으로 구현할 수 있습니다.\n\nCI/CD 파이프라인은 코드 품질을 유지하고 신속하고 신뢰할 수 있는 소프트웨어 제공을 보장하는 데 중요합니다. CI는 코드 변경 사항을 자동으로 테스트하여 문제를 조기에 감지하는 반면, CD는 코드가 빠르고 안전하게 프로덕션 환경에 배포될 수 있도록 합니다. CI/CD를 도입하면 개발자들이 수동 테스트 및 배포에 소비하는 시간을 크게 줄일 수 있어 코드 작성에 집중할 수 있습니다.\n\niOS 개발에서 GitHub Actions와 Fastlane은 서로 완벽하게 보완적입니다:\n\n- GitHub Actions: GitHub에 직접 통합되어 있는 유연하고 확장 가능한 CI/CD 서비스로, 워크플로우를 자동화할 수 있습니다.\n- Fastlane: iOS 및 Android 앱을 빌드, 테스트 및 릴리스 자동화하는 오픈 소스 플랫폼으로, 복잡한 작업의 설정 및 관리를 간편화합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일련의 테이블 태그를 Markdown 형식으로 변경해보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 개발 프로세스는 새로운 기능을 작업하거나 버그를 수정하는 개발자로부터 시작됩니다. 이 작업은 주요 개발 브랜치에서 파생된 별도 브랜치에서 수행됩니다.\n\n2. 개발자가 풀 리퀘스트(Pull Request)를 생성합니다:\n\n- 개발자가 변경 사항을 완료하면, 그들은 자신의 브랜치를 주요 개발 브랜치에 병합하기 위해 풀 리퀘스트(PR)를 만듭니다.\n\n3. CI가 단위 테스트를 실행합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 풀 리퀘스트를 생성하면 CI (Continuous Integration) 시스템이 자동으로 유닛 테스트를 실행하게 됩니다. 이 단계는 새 코드가 회귀를 발생시키지 않거나 기존 기능을 파괴하지 않았는지를 확인합니다.\n\n팀원들은 코드 변경 사항을 검토합니다:\n\n- CI 시스템이 테스트를 실행하는 동안, 팀원들은 코드 변경 사항을 검토합니다. 코드 품질, 코딩 표준 준수 여부, 그리고 구현의 정확성을 확인합니다.\n\n만약 코드가 팀에서 좋게 보이고 유닛 테스트가 통과하면, 개발자가 풀 리퀘스트를 병합합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 유닛 테스트가 통과하고 코드 리뷰가 만족스러운 경우, 개발자가 풀 리퀘스트를 메인 개발 브랜치에 병합합니다.\n\n6. 풀 리퀘스트가 병합되면 CI가 빌드를 생성하여 TestFlight로 전송합니다:\n\n- 풀 리퀘스트가 병합되면 CI 시스템이 빌드 프로세스를 트리거합니다. 이 빌드는 자동으로 TestFlight로 업로드되며, TestFlight는 iOS 베타 앱을 테스터에게 배포하는 데 사용되는 플랫폼입니다.\n\n이 워크플로우는 새로운 코드 변경사항이 본 브랜치에 통합되기 전에 철저히 테스트되고 리뷰되도록 보장합니다. CI/CD의 사용은 테스트 및 배포 프로세스를 자동화하여 효율성을 향상시키고 프로덕션 환경에 오류를 도입할 가능성을 줄입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 전제 조건\n\nCI/CD 파이프라인을 설정하기 전에 다음 사항을 확인해주세요:\n\n- iOS 프로젝트용 GitHub 저장소\n- Apple 개발자 계정\n- 로컬 머신에 Xcode 설치\n\n# CI/CD 설정 단계별 안내\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. 초기 설정\n\n먼저, 귀하의 저장소를 복제하고 로컬로 이동하세요:\n\n```js\ngit clone https://github.com/yourusername/your-ios-repo.git\ncd your-ios-repo\n```\n\n# 2. Fastlane 설치\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFastlane을 RubyGems를 이용하여 설치해보세요:\n\n```js\nsudo gem install fastlane -NV\n```\n\n다음으로, 프로젝트 디렉토리로 이동하고 Fastlane을 초기화해보세요:\n\n```js\ncd your-ios-repo\nfastlane init\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트용 Fastlane을 설정하는 방법을 따라하세요. 베타 배포와 테스팅을 자동화하는 옵션을 선택하세요.\n\n# 3. Fastlane 설정하기\n\n프로젝트의 fastlane 디렉토리에 Fastlane에 의해 생성된 Fastfile을 열어보세요. 앱을 빌드하고 테스트하는 레인을 정의하세요. 예를 들면:\n\n```js\ndefault_platform(:ios)\n\nplatform :ios do\n  desc \"모든 테스트 실행\"\n  lane :test do\n    scan\n  end\n\n  desc \"베타 배포용 앱 빌드\"\n  lane :beta do\n    build_app\n    upload_to_testflight\n  end\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4. GitHub Actions 설정하기\n\n프로젝트 루트에 .github/workflows 디렉토리를 생성해주세요. 만약 없다면, 새로 만들어주세요. 이 디렉토리 안에 ci.yml이라는 파일을 만들어주세요:\n\n```yaml\nname: CI\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v2\n\n      - name: Set up Ruby\n        uses: actions/setup-ruby@v1\n        with:\n          ruby-version: 2.7\n\n      - name: Install Fastlane\n        run: gem install fastlane\n\n      - name: Install dependencies\n        run: bundle install\n\n      - name: Run tests\n        run: fastlane test\n```\n\n이 설정은 main 브랜치로의 모든 push 및 pull request에서 workflow를 트리거합니다. macOS 환경을 설정하고, Ruby와 Fastlane을 설치한 후 Fastlane 구성에서 정의된 테스트를 실행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 내용을 한국어로 번역하겠습니다.\n\n- on: 이 키는 workflow를 트리거하는 이벤트를 정의합니다.\n- push: 지정된 브랜치에 푸시가 발생할 때마다 workflow가 실행되어야 함을 나타냅니다.\n- branches: 푸시 이벤트를 트리거하는 브랜치를 나열합니다. 여기에서는 주 브랜치로 설정되어 있습니다.\n- pull_request: 지정된 브랜치를 대상으로 하는 pull request에 대해 workflow가 실행되어야 함을 나타냅니다. 다시 말해, 주 브랜치입니다.\n- jobs: workflow를 구성하는 작업을 정의합니다. 이 예시에서는 빌드라는 단일 작업이 있습니다.\n- build: 이것은 작업의 이름입니다.\n- runs-on: 작업을 실행할 기계의 유형을 지정합니다. macos-latest은 GitHub의 호스팅된 러너에서 사용 가능한 macOS의 최신 버전에서 작업이 실행됨을 나타냅니다.\n- steps: 작업을 구성하는 개별 단계를 정의합니다. 각 단계는 단일 작업을 실행합니다.\n- name: 단계를 설명합니다. 가독성을 위해 단계가 무엇을 하는지 식별하는 데 도움이 됩니다.\n- uses: GitHub Actions marketplace에서 사용할 액션을 지정합니다. actions/checkout@v2는 저장소 코드를 확인하여 이후 단계에서 액세스할 수 있게 하는 동작입니다.\n- uses: GitHub Actions marketplace의 다른 동작입니다. actions/setup-ruby@v1은 Ruby 환경을 설정합니다.\n- with: 동작에 대한 추가 매개변수를 지정합니다.\n- ruby-version: 사용할 Ruby 버전을 정의합니다. 여기에서는 2.7입니다.\n- run: 셸 명령을 실행합니다. 이 단계에서는 Fastlane이라는 iOS 및 Android 배포를 자동화하는 도구를 설치하기 위해 gem install fastlane 명령을 실행합니다.\n- run: 이 단계에서는 bundle install을 실행하여 Gemfile에서 지정된 종속성을 설치합니다. 모든 필요한 gem이 설치됨을 보장합니다.\n- run: 이 단계에서는 Fastfile에서 정의된 Fastlane 테스트 라인을 실행합니다. 일반적으로 iOS 프로젝트의 단위 테스트를 실행하는 것을 포함합니다.\n\n이 workflow의 각 단계는 iOS 프로젝트의 CI 프로세스를 자동화하기 위해 설계되었습니다:\n\n- 코드 가져오기: 저장소의 코드를 검색합니다.\n- Ruby 설정: Ruby 환경을 준비합니다.\n- Fastlane 설치: Fastlane 도구를 설치합니다.\n- 종속성 설치: Bundler를 사용하여 필요한 프로젝트 종속성을 설치합니다.\n- 테스트 실행: 코드가 올바르게 작동하는지 확인하기 위해 Fastlane에 정의된 테스트를 실행합니다.\n\n# 5. 보안 관리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱을 배포하려면 API 키 및 인증서와 같은 민감한 정보를 안전하게 저장해야 합니다. GitHub 저장소에서 Settings > Secrets 메뉴로 이동하여 필요한 시크릿을 추가하세요:\n\n- APP_STORE_CONNECT_API_KEY\n- MATCH_PASSWORD\n- FASTLANE_SESSION\n\n자세한 지시 사항은 Fastlane 문서에서 시크릿 및 API 키를 관리하는 방법을 참조하세요.\n\n# 6. 워크플로우 실행하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n깃허브에 변경 사항을 푸시하세요. 이 작업은 ci.yml에서 정의한 워크플로를 트리거합니다. 깃허브 저장소의 Actions 탭에서 워크플로 진행 상황을 확인할 수 있습니다.\n\n# 결론\n\nGitHub Actions와 Fastlane을 사용하여 iOS 개발을 위한 CI/CD 파이프라인을 설정하면 자동화된 테스트, 빌드 및 배포를 제공하여 개발 워크플로를 크게 향상시킬 수 있습니다. 위에서 설명한 단계는 이러한 설정이 신속하게 구현될 수 있음을 보여주며, 코드 품질을 유지하고 릴리스 프로세스를 가속화할 수 있도록 도와줍니다. 이러한 도구를 활용하여 견고하고 효율적인 개발 주기를 보장함으로써 팀이 훌륭한 앱을 만들 수 있도록 돕는 것입니다.\n\n지속적 통합 및 배포가 구현되면 문제를 빨리 파악하고 코드 품질을 보장하며 기능을 더 빠르고 신뢰할 수 있게 사용자에게 제공할 수 있습니다. 이는 현대 소프트웨어 개발의 최상의 관행을 구현하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 축하드려요! 🥳\n\n![이미지](/assets/img/2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions_1.png)\n","ogImage":{"url":"/assets/img/2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions_0.png"},"coverImage":"/assets/img/2024-05-23-ConfiguringCICDPipelinesforiOSwithFastlaneandGitHubActions_0.png","tag":["Tech"],"readingTime":9},{"title":"2024 OWASP 모바일 탑 10 변경 사항에 대한 소식이 뭐길래","description":"","date":"2024-05-23 14:48","slug":"2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes","content":"\n# 소개\n\n먼저, 2024년 새해 복 많이 받으세요 🎉 이미 2월이 되었지만, 올해 첫 게시물이라 조금 늦었다는 점 이해해 주시면 감사하겠습니다.\n\n그 외에도, 좋은 소식은 올해 모바일 보안 분야에서 이미 흥미로운 소식으로 시작되었다는 것입니다. 이 게시물에서는 2024년을 위한 OWASP Mobile Top 10의 변경 사항을 살펴보고, 그것이 보안에 민감한 개발자인 여러분에게 무슨 의미가 있는지 알아보겠습니다!\n\n저의 OWASP Mobile Top 10 강의나 포스트에 이미 익숙한 분들은 당연히 \"OWASP의 정상\" 섹션으로 건너뛰어서 흥미로운 내용을 확인할 수 있습니다. 그러나 OWASP가 무엇이며 최근 변경 사항이 모바일 보안 분야에서 큰 영향을 미친다는 사실에 대해 잘 알지 못하거나 간단히 상기시키고 싶다면, 함께 머물러 주시면 OWASP란 무엇이며 최근 변경 사항이 모바일 보안 분야에서 왜 중요한지에 대해 다시 한 번 요약해 드리겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# OWASP이 뭐죠? 🐝\n\n모바일 보안에 새로 오신 분이나 제 블로그 게시물을 처음 보시는 분, 혹은 한동안 돌아본 적이 없는 분들께 질문드립니다. OWASP와 그들이 하는 훌륭한 작업에 대해 아시지 못할 수 있습니다.\n\n2001년에 설립된 OWASP(Open Worldwide Application Security Project) 재단은 비영리 단체로, 소프트웨어 보안 관행에 대한 교육 자료, 도구, 교육 자원 및 다른 다양한 커뮤니티 기반 서비스를 제공합니다. 우리 분야에서 선두적인 어플리케이션 보안 커뮤니티로 널리 인정받으며 다양한 프로젝트에서 모바일 보안을 다루는 프로젝트를 비롯한 많은 헌신적인 자원봉사자들이 있습니다.\n\nOWASP가 제공하는 안내 중 하나는 'Top 10' 위협 목록입니다. 이 목록은 OWASP가 특정 영역의 보안에 대한 자신의 상위 10위 위협 목록으로, 모든 개발자에게 매우 유용한 자원입니다¹.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 이전에 그들의 지난 안내에 대해 다양한 콘텐츠를 제공했습니다. 더 자세히 알고 싶다면, 제 발표 페이지와 이전 OWASP 관련 블로그를 확인해보세요. 그 곳에는 더 많은 자세한 내용과 관련 링크가 있습니다.\n\n보다 실용적인 학습자라면, 제 OWASP 발표를 위한 동반 앱도 있습니다. 그 앱은 제가 소개한 주제 중 일부를 보여줍니다.\n\n어쨌든, 2024년은 거의 10년 만에 가장 중요한 Mobile Top 10의 수정이 이루어지고 있습니다. 그래서 더 이상 말 할 필요 없이, 무엇이 변했는지 살펴보겠습니다! 👀\n\n# “OWASP의 꼭대기\" ✨\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n긴 협의 기간과 여러 차례의 수정을 거친 끝에, 최근 발표된 OWASP Mobile Top Ten 2024는 2014년 최초 발표 이후 세 번째이자 최신 주요 개정판입니다.\n\n2024년 발표 버전은 2016년 버전을 대체하며, 현재의 모바일 보안 환경을 더 잘 반영하기 위해 네 가지 새로운 위협 범주와 위협의 완전한 재배열을 포함한 명백한 변경 사항을 가져왔습니다.\n\n이 모든 것은 잘 된 일이지만, 실제로 무엇이 변경되었고 이 모든 의미가 무엇을 의미하는지 궁금하십니까? 😅 음, 진짜 Billboard 차트 스타일로 (이나 영국인으로서는 Top of the Pops 스타일로), 각 위협에 대해 순서를 거꾸로하여 번호 10부터 간단히 설명해 보겠습니다!\n\n![이미지](https://miro.medium.com/v2/resize:fit:768/1*9ESds38QHiOyqz_CkOXM7A.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #10: 부적절한 암호화 ⬇️\n\n2016년 5위에서 내려온 부적절한 암호화는 모바일 앱이 현대 암호화 최상의 방법을 채택하지 못해 겪는 위협입니다. 이는 안전하지 않은 알고리즘(SHA-1, MD5 등)을 구현하거나 안전한 데이터 전송(HTTPS)을 사용하지 않거나 심지어 키에 맛있는 소금을 쓰지 않는 것으로 나타납니다 🧂.\n\n암호화를 사용할 때, 특정 필요에 맞는 최상의 방법을 따르도록 하십시오. 예를 들어, AES와 같은 알고리즘을 사용하면서 최소 128비트 블록 크기 또는 최소 2048비트 RSA를 사용하는 것이 좋습니다. 의문이 생길 경우, 전문가에게 질의하거나 Google의 tink 라이브러리와 같은 신뢰할 수 있는 도구를 활용하십시오.\n\n앞으로 제 블로그에서 관련 포스트가 올라올 예정입니다 (희망적으로) 📝.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## #9: 안전하지 않은 데이터 저장 ⬇️\n\n2016년 목록에서 크게 순위가 변동한 항목 중 하나는 안전하지 않은 데이터 저장이었어요. 2위에서 9위로 내려왔네요. 아파요 😣\n\n만약 데이터(네트워크 호출 포함)를 로그에 출력하거나, 비밀번호나 토큰을 저장하거나, 임시 파일을 생성하거나, 또는 SQL 데이터베이스나 Shared Preferences와 같은 표준 저장 기술을 사용하고 있다면, 당신의 앱은 안전하지 않은 데이터 저장에 취약할 수 있습니다.\n\n저는 이전에도 안전하지 않은 데이터 저장에 대해 자세히 다뤘었어요. 그래서 제 글을 꼭 확인하고, 앱의 데이터가 안전하고 안전하게 저장되어 있는지 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n언제나 강조해야 할 점은 가능한 경우 기기에 민감한 데이터를 저장하는 것을 피하는 것이 최선의 실천 방법입니다!\n\n## 8번: 보안 구성 오류 ⬆️\n\n10위에서 상승한 이 ‘보안 구성 오류’라는 새로운 명칭의 ‘Extraneous Functionality’에 대해 이야기해 보겠습니다.\n\n‘RTFM’ 개념을 알고 있다면, 이 위협이 무엇인지 알 수 있을 것입니다. 이는 종종 개발자가 제품 빌드에서 잘못된 설정을 사용하거나 필요하지 않은 상승된 액세스나 권한을 요청하거나 원래는 애플리케이션 내부로 의도된 기능을 노출하는 데 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n문서화는 종종 친구가 될 수 있어요. 읽는 걸 소홀히 하지 마세요. 🥲 커피를 가져다가 실수에 갇히세요!\n\n## #7: 바이너리 보호 미비 ⬆️\n\n크림, 오디오스레이브 또는 아톰 포 피스와 같이 유명한 밴드들처럼, 2016년 8위와 9위(코드 위조 및 역공학)가 합쳐져 7위로 올라왔어요. 😎\n\n바이너리 보호는 앱의 바이너리(즉, 안드로이드의 .apk/.aar 또는 iOS의 .ipa 파일)가 정보를 유출하지 않거나 다시 패키징되지 않도록 하는 데 초점을 맞춥니다. 앱을 제대로 난독화하지 않거나 무결성 검사를 제대로 하지 않으면 공격자가 악성 코드를 주입하여 앱을 역공학하거나 재분배할 수 있는 가능성이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 좋은 친구 Guardsquare과 그들의 훌륭한 도구(예: DexGuard 및 Proguard Playground)를 적극 추천합니다. 이 도구들은 특정 위협으로부터 앱을 안전하게 유지하는 데 도움이 됩니다. 또는 R8 및 Google Play 무결성 API에 대해 더 알아보는 데 투자하는 것도 도움이 될 수 있어요!\n\n## #6: 불충분한 개인정보 보호 기능 🆕\n\n6위로 새롭게 입성한 '불충분한 개인정보 보호 기능'입니다.\n\n당신의 앱이 사용자의 개인 식별 정보(예: 전체 이름, 정확한 위치, 금융 상세 정보, 성향 등)를 다룬다면, 이 정보들이 잘못된 손에 들어가면 해당 사용자를 사칭하거나 괴롭히거나 사기를 저질 수 있는 경우가 발생할 수 있습니다. 이 경우 이것이 해당될 수도 있어요! 🥸\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션이 저장하거나 기록하는 개인 식별 정보(PII)를 로컬에 저장하지 않도록하고 사용자로부터의 정보 최소한만 요청/전송하십시오. 이렇게 하면 저장소나 데이터 전송의 취약점을 통해 PII가 노출될 가능성이 크게 줄어듭니다.\n\n예를 들어, 영화 예매 앱에서 성적 지향이나 정확한 위치가 필요합니까? 아마 아니죠! 대신 코스 위치를 요청하여 인근 영화관을 찾고 사용자가 추천을 받기 위해 추가 개인 정보를 제공할 수 있도록 요청하고, 나중에 그것을 선택적으로 거부할 수 있도록 하는 것이 훨씬 나을 것입니다.\n\n## #5: 통신 불안전 ⬇️\n\n또 다른 이동! 2016년 3위인 '통신 불안전'이 5위로 두 단계 하락했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 전송이나 수신과 관련된 위협을 다루고 있어요. 대부분의 응용프로그램은 인터넷을 통해 이를 수행하지만, 여러분의 앱은 NFC나 블루투스와 같은 다른 통신 방법을 사용할 수도 있어요. 데이터 통신이 있으면, 거기에는 위험이 연결되어 있을 거라고 확신할 수 있어요!\n\n이 문제에 대해 더 자세히 다루지는 않겠어요. 이전에 보안 통신에 대해 블로그를 썼었기 때문에 그 부분도 꼭 확인해보시길 바래요.\n\n## #4: 충분하지 않은 입력/출력 유효성 검사 🆕\n\n4번 항목의 새로운 주제는 사용자 입력 및 출력을 다뤄봅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모바일 앱 및 API가 사용자 입력을 통신하거나 출력할 때 올바로 처리되도록 하는 것이 매우 중요합니다 🛁 그렇지 않으면 SQL 인젝션 또는 교차 사이트 스크립팅 (XSS)과 같은 위협이 발생할 수 있으며 이는 민감한 사용자 데이터를 노출하거나 더 심각한 경우 기기가 위협받을 수 있습니다. 원하는 값 및 형식을 얻고 해당 기준에 충족하지 않는 경우는 버려야 합니다.\n\nWhatsApp에서 유포된 ‘Effective Power’ 또는 ‘Black Spot’ 메시지를 기억하시나요? WhatsApp 메시지에 특별히 디자인된 입력이 출력될 때 발생한 문제였는데, 이는 일종의 ‘서비스 거부’로 설계된 것이었습니다. — 여기서 살균 처리가 문제를 해결했을까요? 아마도 가능합니다!\n\n요약하면, 입출력 조심하면 ‘작은 바비 테이블’이 문제를 일으키지 않아도 안심할 수 있습니다 ⁶.\n\n## #3: 안전하지 않은 인증/인가 ⬆️\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIn the new ranking, insecurities related to authentication and authorization have moved up to the 3rd place, combining aspects from the previous 4th and 6th spots.\n\nTo prevent confusion due to similar names, let's clarify that authentication confirms the user's identity, while authorization verifies if the user has the necessary roles or credentials to access specific resources.\n\nIt's crucial to perform authentication and authorization checks on the server side to prevent vulnerabilities from potential binary modifications or other methods.\n\nWhen interacting with APIs that need authorization, make sure to use revocable tokens linked to the device. This way, users can revoke tokens if their device is lost or stolen. Remember to refresh tokens regularly and ensure your backend team authenticates properly when authorizing access to restricted resources!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시, Insecure Authentication에 대한 자세한 내용은 해당 주제에 대한 이전 블로그를 확인해 보세요 🤠 이어서 Insecure Authorization에 대한 더 많은 정보를 확인할 수 있을 거에요.\n\n## #2: 부적절한 공급망 보안 🆕\n\n제 2위에 새로운 항목이 추가되었는데, 이는 우리 앱을 구축하는 데 사용하는 도구와 프로세스에 초점을 맞추고 있어요.\n\n'공급망 공격'은 사용하는 도구에 대한 공격을 말하며, 감지되지 않고 도구에 취약점, 보안 위협 또는 악의적인 코드를 도입하는 것을 의미해요. 조직 내부에서는 부정직한 직원에 의해, 또는 시스템이나 도구에 특권 액세스를 얻은 악의적인 행위자에 의해 외부에서 이루어질 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 보안을 강화하기 위해 코드 검토 프로세스를 철저히 실시하는 것이 중요합니다. 뿐만 아니라 공급망의 액세스 제어에 대한 정기적인 감사도 수행해야 합니다. 앱의 종속성을 모니터링하고 이들이 정기적으로 검토되도록 하여 보안 취약성을 방지해야 합니다.\n\n이미 확인하지 않았다면, 저는 이전에 공급망 공격과 Gradle 작업 시 어떻게 완화할 수 있는지에 대해 블로그 게시 및 강의를 진행했습니다.\n\n## #1: 부적절한 자격 증명 사용 🆕\n\n대망의 순간입니다 🥁 OWASP에 따르면 모바일 보안의 가장 큰 위협은... 부적절한 자격 증명 사용입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 사용자 자격 증명, API 키부터 그 사이의 모든 것에 적용되는 보안 부적절로 인한 케이스를 포괄하는 범주입니다!\n\n알람이 울리는 2021 보고서에 따르면 추정 200개 애플리케이션 중 1개가 하드코딩된 API 키를 통해 AWS 자격 증명을 유출한 것으로 추정되었습니다 😅 이처럼 API 키 또는 하드코딩된 자격 증명이 노출되면 파괴적인 결과가 초래될 수 있습니다. 이러한 종류의 자격 증명 유출은 이전에 Uber, Verizon, Accenture 등 주요 기업들에게 피해를 입히고, 고객 데이터(포함된 개인 식별 정보 및 결제 정보)가 노출된 데이터 침해를 발생시켰습니다 🙀 일반적으로 로컬에 저장해야 하는 민감한 데이터는 항상 암호화되어야하며, 암호화에 사용되는 키는 하드웨어 보호 키 저장소에 안전하게 저장되어야 합니다.\n\n이 모든 소리들이 겁나게 들리지만, 자신이 부적절한 자격 증명 처리에 걸리지 않는 방법은 꽤 간단합니다. 사용자 자격 증명(비밀번호 등)을 장치에 저장하지 않으며, 제3자 API 키를 정기적으로 교체하고, 언제나 HTTPS를 통해 자격 증명을 안전하게 전송해야 합니다. 간단하죠! 🙌\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리로... 🐝\n\n마지막으로, 2016년과 2024년 목록 사이에 상당한 변화가 있었지만, 보안에 민감한 개발자로서 여러분은 항상 응용 프로그램을 잠재적인 위협에 대해 지속적으로 모니터링해야 합니다. 상위 10개가 변경되었을 수 있지만, 많은 개발자들이 모바일 보안을 제대로 이해하지 못한다는 현실은 여전합니다. 더 많이 배우고 이 지식을 공유함으로써 이를 바꿀 수 있습니다!\n\n이 글에서 하나의 교훈을 얻는다면, 모바일 애플리케이션에 대한 잠재적인 위협에 대해 여러분과 팀원들이 숙지되어 있는지 확인하고 (MASVS와 같은 훌륭한 자원이나 저의 블로그를 읽는 것처럼) AppSweep, MobSF, Snyk, 또는 SonarQube와 같은 도구를 통합하여 코드/바이너리를 이러한 문제에 계속적으로 점검해보시기 바랍니다.\n\n마지막까지 완주하셨네요! 2024년이 멋지고 안전한 한 해 되길 바랍니다 🥰 🔐\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 감사합니다 🌟\n\n언제나 읽어 주셔서 감사합니다! 이 포스트를 재밌게 보셨으면 @Sp4ghettiCode로 피드백을 트윗해 주세요. 반응이나 좋아요, 트윗, 공유, 스타 등도 잊지 말고 해 주세요 🙂\n\n## 더 읽기\n\n- OWASP Top Five Companion App (2016 버전)\n- OWASP Mobile Top Ten 2024\n- Mobile Application Security Verification Standard: MASVS\n- Mobile Application Security Testing Guide: MASTG\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 각주\n\n[1]: 보안 중심의 모바일 개발자이시라면, 업데이트된 MASVS 및 MASTG에 특히 주의를 기울여 모바일 앱의 보안 모델을 적용하고 테스트해야 합니다.\n\n[2]: 염화 나트륨과는 아무 상관이 없습니다. 이 문맥에서의 \"솔트(salt)\"는 동일한 평문이 여러 번 입력되더라도 다른 해시값이 생성되도록 보장하기 위해 평문에 연결된 임의의 데이터를 의미합니다.\n\n[3]: 불편하기는 해도, 2024년 Top 10이 5위에 있을 때 대부분 완성된 \"Insufficient Cryptography\" 글은 최종적으로 10위가 아니라는 것을 알았습니다. (그런데 누가 10부작 블로그 시리즈를 생각해냈을까요!?)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[4]: 제발 제품에서 네트워크 호출을 로깅하는 것을 그만둬주세요. 이미 2024년이에요. 🥲\n\n[5]: 'F'는 정말 옳은 것을 가리키는 것이에요 😅\n\n[6]: https://xkcd.com/327/\n","ogImage":{"url":"/assets/img/2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes_0.png"},"coverImage":"/assets/img/2024-05-23-Whatsthebuzzaboutthe2024OWASPMobileTop10changes_0.png","tag":["Tech"],"readingTime":14},{"title":"CSRF로 인해 계정이 삭제될 수 있습니다","description":"","date":"2024-05-23 14:47","slug":"2024-05-23-CSRFLeadstoDeleteAccount","content":"\n# 안녕하세요!\n\n![이미지](/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png)\n\n# 소개\n\n- 대상: 안드로이드 애플리케이션\n- 날짜: 2024년 5월\n- 요약: Corp 앱에서 CSRF 취약점을 발견했습니다. 이 취약점을 이용하여 사용자 계정을 삭제할 수 있는 Deeplink와 delete-account 엔드포인트 간의 상호작용이 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 복제 단계\n\n- 먼저 AndroidMainfast.xml을 살펴봅니다.\n\n```xml\n        <activity android:theme=\"@style/Theme.Thredup.Splash\" android:name=\"com.example.android.feature.splash.SplashActivity\" android:exported=\"true\" android:launchMode=\"singleTask\" android:screenOrientation=\"behind\" android:configChanges=\"screenSize|orientation\" android:noHistory=\"true\">\n            <intent-filter android:autoVerify=\"true\">\n                <action android:name=\"android.intent.action.VIEW\"/>\n                <category android:name=\"android.intent.category.DEFAULT\"/>\n                <category android:name=\"android.intent.category.BROWSABLE\"/>\n                <data android:host=\"www.example.com\" android:pathPrefix=\"/account\"/>\n                <data android:scheme=\"https\"/>\n                <data android:scheme=\"http\"/>\n            </intent-filter>\n        </activity>\n```\n\n- 'adb'를 사용하여 호출한 후에 /account/라는 Path로 이 Deeplink를 발견했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 지금은 설정에 있어요;\n- 잠시만 android:pathPrefix=/account/는 무슨 의미일까요?\n- android:pathPrefix 속성은 Intent 객체의 경로의 초기 부분에만 일치하는 부분 경로를 지정합니다. 그래서 아마도 /account/ 뒤에 무언가를 찾을 수 있을지도 모릅니다.\n- 설정 이후에 API 호출을 가로챈 후, 비밀번호 변경이나 계정 삭제와 같은 설정 후의 API 엔드포인트를 Deeplink에서 사용해 봅시다.\n\n```js\nadb shell am start -a android.intent.action.VIEW -n com.thredup.android/com.thredup.android.feature.splash.SplashActivity -d \"https://www.example.com/account/change_password\"\n\nadb shell am start -a android.intent.action.VIEW -n com.thredup.android/com.thredup.android.feature.splash.SplashActivity -d \"https://www.example.com/account/delete_password\"\n```\n\n- 지금 CSRF로 만들어 봐요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\n<!DOCTYPE html>\n<html>\n<a href=\"https://www.example.com/account/change_password\">CSRF DEMO</a>\n</html>\n```\n\n# Proof of Concept\n","ogImage":{"url":"/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png"},"coverImage":"/assets/img/2024-05-23-CSRFLeadstoDeleteAccount_0.png","tag":["Tech"],"readingTime":3},{"title":"Android Kotlin 개발자를 위한 Swift 참고 자료","description":"","date":"2024-05-23 14:45","slug":"2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers","content":"\n안녕하세요! 안드로이드 개발자들은 대부분 Kotlin으로 작업합니다. 그러나 iOS에서 어떤 기능이 구현되는 방법을 참조할 때 Swift를 읽고 이해하는 것도 도움이 될 수 있습니다. 또한 Kotlin Multiplatform을 탐색하는 경우에도 유용합니다.\n\niOS 개발자도 Android 코드를 살펴볼 때 이와 같은 원리가 적용됩니다. Kotlin을 읽고 이해하는 방법을 알면 보다 쉬워집니다.\n\n우리는 iOS 코드를 살펴볼 때 볼 수 있는 몇 가지 일반적인 Swift 패턴에 대해 다루고, 이해하려고 노력하고 Kotlin에서의 구현과 비교해 볼 것입니다.\n\n<img src=\"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. 기본 사항\n\n## 변수\n\nSwift에서 변수와 상수는 각각 var 및 let 키워드를 사용하여 정의됩니다. 세미콜론을 사용하여 유형 주석을 제공할 수 있지만 필수는 아닙니다.\n\n```js\n// Swift\nlet animDurationMillis: Int = 500\nvar clickCount = 0\n\n// Kotlin\nval animDurationMillis: Int = 500\nvar clickCount = 0\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 시점에서 두 언어의 유일한 차이점은 읽기 전용 변수를 정의하는 let 대 val 키워드입니다.\n\n## 옵셔널 / 널 가능성\n\n옵셔널이나 널 가능한 유형의 경우, 두 언어 모두 같은 ? 문자를 사용하지만, 값이 없는 상태에 대해서는 nil 대 null이 유일한 차이점입니다.\n\n```swift\n// Swift\nvar foundItem: String? = nil\n\n// Kotlin\nvar foundItem: String? = null\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nnil 상태를 처리하는 여러 가지 방법이 있습니다:\n\n- 값 확인을 위해 if 표현식을 사용하는 방법 (이 내용은 뒤에서 다룹니다),\n- 옵셔널 바인딩을 사용하는 방법 (이 내용은 뒤에서 다룹니다),\n- 대체/기본값을 제공하는 방법,\n- 강제 언래핑을 하는 방법.\n\n마지막 두 가지 접근법의 예시가 여기 있습니다. 코틀린이 거의 동일한 방식을 제공한다는 것을 알 수 있습니다. 문법에 약간의 차이가 있습니다 (?? vs ?: 및 ! vs !!).\n\n```js\n// Swift\n//  - 대체/기본값\nlet actualFoundItem = foundItem ?? \"empty\"\n//  - 강제 언래핑\nlet actualFoundItem = foundItem!\n\n// Kotlin\n//  - 대체/기본값\nval actualFoundItem = foundItem ?: \"empty\"\n//  - 강제 언래핑\nval actualFoundItem2 = foundItem!!\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 제어 흐름\n\nif 문은 Kotlin과 거의 동일한데, Swift에서는 괄호를 생략할 수 있다는 작은 차이가 있습니다.\n\n```js\n// Swift\nif foundItem != nil {\n  // 무언가를 수행\n}\n\n// Kotlin\nif (foundItem != null) {\n  // 무언가를 수행\n}\n```\n\n두 언어 모두 else if/else 분기에 대해 동일한 구문을 사용하며, 두 언어 모두 표현식으로 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 스위프트\nlet description = if delta <= 10 {\n  \"low\"\n} else if delta >= 50 {\n  \"high\"\n} else {\n  \"medium\"\n}\n\n// 코틀린\nval description = if (delta <= 10) {\n    \"low\"\n} else if (delta >= 50) {\n    \"high\"\n} else {\n    \"medium\"\n}\n```\n\n## Functions\n\nSwift에서 함수는 func 키워드로 선언되며, 함수 이름, 입력 매개변수 및 반환 유형이 이어집니다.\n\n```js\nfunc addTwoNumbers(a: Int, b: Int) -> Int {\n    return a + b\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린에서는 fun 키워드와 :을 사용하여 반환 유형을 정의합니다. -` 대신에 Markdown 형식으로 표를 변경해주세요.\n\n```kotlin\nfun addTwoNumbers(a: Int, b: Int): Int {\n    return a + b\n}\n```\n\n# 2. 구조체 및 클래스\n\nSwift는 데이터 모델링 관점에서 비슷한 구조체와 클래스를 지원합니다. 둘 다 속성과 함수를 정의할 수 있지만, 클래스는 참조에 의해 전달되고 구조체는 값에 의해 전달됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본적으로 구조체를 사용하는 것이 권장됩니다. 상속, Objective-C 호환성 등 추가 기능이 필요할 때는 클래스를 사용하세요.\n\n```js\nstruct VehicleStructure {\n    var maxSpeed = 0\n\n    func printInfo() {\n        print(\"최대 속도 \\(maxSpeed)\")\n    }\n}\n\nclass VehicleClass {\n    var maxSpeed = 0\n\n    func printInfo() {\n        print(\"최대 속도 \\(maxSpeed)\")\n    }\n}\n```\n\n인스턴스를 생성하려면 구조체나 클래스 이름 뒤에 빈 괄호를 사용합니다.\n\n구조체는 기본적으로 변경 불가능하므로 속성의 값 변경이 필요한 경우 let 대신 var로 선언해야 합니다. 멤버 속성의 값을 설정하기 위해 자동으로 생성된 이니셜라이저를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 변경 가능한 구조체 인스턴스 생성\nvar car = VehicleStructure()\ncar.maxSpeed = 250\ncar.printInfo()\n\n// 변경 불가능한 구조체 인스턴스 생성\nlet carSimple = VehicleStructure(maxSpeed: 200)\ncarSimple.printInfo()\n\n// 클래스 인스턴스 생성\nlet bike = VehicleClass()\nbike.maxSpeed = 50\nbike.printInfo()\n```\n\n## Kotlin\n\nKotlin에서의 주요 구성 요소는 클래스입니다. 그 선언과 사용법은 Swift와 거의 동일합니다.\n\n```js\nclass Vehicle {\n    var maxSpeed = 0\n\n    fun printInfo(){\n        println(\"최대 속도는 $maxSpeed입니다.\")\n    }\n}\n\n// 클래스 인스턴스 생성\nval vehicle = Vehicle()\nvehicle.maxSpeed = 250\nvehicle.printInfo()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin은 클래스 생성 시 모든 클래스 속성에 값을 제공해야하는 클래스 생성자도 지원합니다.\n\n```kotlin\nclass Vehicle(var maxSpeed: Int) {\n\n    fun printInfo(){\n        println(\"최대 속도는 $maxSpeed 입니다.\")\n    }\n}\n\nval vehicle = Vehicle(250)\n```\n\nKotlin은 추상 클래스, 데이터 클래스, 인터페이스 및 실드 클래스 및 인터페이스와 같은 다른 관련 구조를 지원합니다. 더 많은 내용은 https://kotlinlang.org/docs/classes.html에서 확인할 수 있습니다.\n\n# 3. Optional Binding\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## if let 사용법\n\nSwift 코드베이스에서 자주 볼 수 있는 패턴 중 하나는 다음과 같습니다:\n\n```js\nlet fetchedUserId: String? = \"Optional id of the fetched user\"\nif let userId = fetchedUserId {\n    // userId를 선택적인(non-optional) 상수로 사용할 수 있습니다.\n    print(userId)\n} else {\n    // fetchedUserId가 nil/null인 경우\n    throw Error(\"Missing user id\")\n}\n\n// fetchedUserId와 userId를 if 문 바깥에서 사용할 수 있습니다.\n// 그러나 둘 다 여전히 옵셔널이므로 unwrapping이 필요합니다.\n```\n\n이를 선택적 바인딩(optional binding)이라고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 선택적으로 검색된 fetchedUserId 변수가 nil이 아닌 값으로 존재하는지 확인합니다.\n- true이면 새로운 선택 불가능한 상수인 userId에 값을 할당합니다.\n- 새로운 상수 userId는 코드 블록 내에서 참조할 수 있습니다.\n- fetchedUserId가 nil이라면 else 블록을 실행합니다.\n\n기존 변수 이름을 사용하여 더욱 간단하게 코드를 작성할 수 있습니다:\n\n```js\nlet fetchedUserId: String? = \"검색된 사용자의 선택 사항 ID\"\nif let fetchedUserId {\n    // fetchedUserId를 선택 불가능한 상수로 사용할 수 있습니다.\n    print(fetchedUserId)\n}\n```\n\n두 경우 모두 fetchedUserId와 userId 상수를 if 문 바깥에서 사용할 수 있지만, 두 상수 모두 여전히 선택적으로 간주되기 때문에 추가로 언래핑이 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린\n코틀린에는 이에 해당하는 특수한 패턴이 없습니다. 하나의 옵션은 if/else 문을 사용하는 것입니다. 그러나 이는 로컬 변수에 대해서만 작동하며 전역 변수에는 작동하지 않습니다. 전역 변수를 지원하려면 먼저 값을 새로운 로컬 변수/상수에 할당해야 합니다.\n\n```js\n// 글로벌 클래스 속성\nvar fetchedUserId: String? = \"피치된 사용자의 선택 가능한 ID\"\n\nval userId = fetchedUserId\nif (userId != null) {\n  // userId는 선택 사항 없이 사용할 수 있습니다\n} else {\n  throw Exception(\"사용자 ID가 누락되었습니다\")\n}\n\n// userId는 선택 사항 없이 어디서든 사용할 수 있습니다\n```\n\n위의 경우에는 if 문 이후에도 userId 상수를 선택 사항 없이 참조할 수 있으며, 이는 옵셔널 바인딩 패턴을 사용한 스위프트에서는 지원되지 않습니다.\n\n대안적인 해결책은 `.let`과 같은 스코프 함수를 사용하는 것입니다. 함수 내부의 코드는 fetchedUserId가 null이 아닌 경우에만 실행됩니다. 이 코드 블록 이후에 fetchedUserId에 대한 참조는 여전히 변수가 선택 사항으로 간주되므로 널 안전성이 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfetchedUserId?.let { userId ->\n  // userId가 옵셔널이 아닌 것으로 사용할 수 있습니다\n} ?: throw Exception(\"사용자 ID가 누락되었습니다\")\n```\n\n## 보호자\n\n또 다른 일반적인 패턴은 가드문입니다. 이는 if let 패턴과 유사합니다. 주로 함수 내에서 조기에 종료할 때 사용됩니다. 다른 점은 else 블록이 필수적이라는 것입니다.\n\n```swift\nfunc checkUsernameValid(username: String?) -> Bool {\n    guard let username else {\n        // username이 nil이므로 평가할 수 없습니다\n        return false\n    }\n    // username을 옵셔널이 아닌 것으로 사용할 수 있습니다\n    return username.count > 3\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드에서 함수는 선택적으로 변수 username을 받습니다. 그런 다음 guard문을 사용하여 username이 값이 있는지 확인합니다. 값이 없는 경우 함수를 종료합니다. 값이 있는 경우 나머지 함수에서는 username을 선택사항이 아닌 것처럼 사용할 수 있습니다.\n\nKotlin\nKotlin에서는 몇 가지 다른 방법으로 이를 작성할 수 있습니다. 두 가지 제안을 보여드리겠습니다:\n\n```js\nfun checkUsernameValid(username: String?): Boolean {\n    if (username.isNullOrEmpty()){\n        return false\n    }\n    return username.length > 3\n}\n\n// 또는\n\nfun checkUsernameValid(username: String?): Boolean {\n    val actualUsername = username ?: return false\n    return actualUsername.length > 3\n}\n```\n\n# 4. Enums\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwift에서는 enum 키워드를 사용하여 열거형을 정의합니다. 값은 case 키워드를 사용하고 그 뒤에 열거형 케이스의 이름을 작성합니다. 열거형 케이스의 이름은 소문자로 작성하는 것이 권장되며 단수형으로 작성하는 것이 좋습니다. 각 케이스를 새로운 줄에 작성해야 합니다. 여러 케이스를 한 줄에 작성할 때는 쉼표로 구분합니다.\n\n```js\nenum Direction {\n    case left\n    case up\n    case right\n    case down\n}\n\n// 또는\n\nenum Direction {\n    case left, up, right, down\n}\n```\n\nenum 케이스를 사용하려면 유형(Direction)과 사용하려는 케이스를 참조합니다. 나중에 유형을 생략하고 더 짧은 점 구문을 사용하여 케이스를 직접 참조할 수 있습니다.\n\n```js\nvar selectedDirection = Direction.up\nselectedDirection = .right\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n열거형 값 확인을 위해 switch 문을 사용할 수 있습니다. Xcode는 switch 문의 모든 분기를 자동으로 작성합니다. 열거형에 대한 switch 문이 전체적이어야 하기 때문입니다.\n\n```js\nswitch(selectedDirection){\ncase .left:\n    goLeft()\ncase .up:\n    goForward()\ncase .right:\n    goRight()\ncase .down:\n    goBackward()\n}\n```\n\nSwift 열거형은 연관 값도 지원합니다. 즉, 각 열거형 케이스마다 다른 수의 값 유형을 가질 수 있습니다. 이는 Kotlin의 sealed class와 유사한 강력한 도메인 모델링 도구 역할을 합니다.\n\n더 알아보기: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/enumerations\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 코틀린\n\n코틀린에서는 enum 클래스 키워드를 사용하여 Enum을 정의합니다. 값은 쉼표로 구분하여 정의합니다. Enum 값 이름은 일반적으로 대문자로 작성하는 것이 관례이지만, 프로젝트의 스타일에 따라 다를 수 있습니다.\n\n```js\nenum class Direction {\n    LEFT, UP, RIGHT, DOWN\n}\n```\n\nEnum을 사용할 때는 클래스 이름과 사용하려는 값으로 참조합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar selectedDirection = Direction.UP;\n```\n\n우리는 값 확인을 위해 when 문을 사용할 수 있습니다. 가능한 모든 열거형 값을 포함해야합니다.\n\n```js\nwhen(selectedDirection){\n    Direction.LEFT -> goLeft()\n    Direction.UP -> goForward()\n    Direction.RIGHT -> goRight()\n    Direction.DOWN -> goBackward()\n}\n```\n\nKotlin 열거형 클래스는 각 열거형 값이 값을 제공해야하는 추가 속성을 정의하는 것을 지원합니다. 그러나 Swift의 관련 값과 달리 속성은 클래스 수준에 있으며 값 레벨이 아니므로 각 값에 대해 동일한 형식이어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Kotlin 공식 문서 링크입니다: https://kotlinlang.org/docs/enum-classes.html\n\n# 5. 사전 / 맵\n\nSwift의 딕셔너리와 Kotlin의 맵 사이의 구문은 매우 다르지만 비슷한 기본 개념을 사용합니다.\n\n## Kotlin\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n딕셔너리는 키와 값을 동일한 유형으로 연결해주는 Swift의 데이터 구조입니다. 키-값 쌍은 순서가 없이 저장됩니다. 각 키는 연결된 값을 액세스하기 위한 기준값을 나타냅니다.\n\n딕셔너리를 선언하려면 키-값 쌍을 [Key: Value] 형식으로 대괄호 안에 쉼표로 구분하여 정의합니다. 최소 하나의 키-값 쌍을 정의하면 형식 선언을 생략할 수 있어 컴파일러가 유형을 결정할 수 있습니다.\n\n```js\nvar httpErrorCodes: [Int: String] = [404: \"Not found\", 401: \"Unauthorized\"]\n```\n\n키를 사용하여 딕셔너리에서 값을 읽기 위해 서브스크립트 구문(dictionary[key])을 사용할 수 있습니다. 딕셔너리에 키가 없으면 nil을 반환합니다. ?? 연산자를 사용하여 기본값을 제공할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunc getHttpErrorCodeMessage(code: Int) -> String {\n    let errorCodeMessage = httpErrorCodes[code] ?? \"Unknown\"\n    return \"Http error code \\(errorCodeMessage)\"\n}\n```\n\n딕셔너리에 새로운 값을 쓰려면 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍을 컬렉션에 추가합니다. 키가 이미 존재하면 값을 업데이트합니다.\n\n```js\n// 새로운 키:값 쌍 추가\nhttpErrorCodes[500] = \"Internal Server Error\";\n\n// 기존 키의 값 업데이트\nhttpErrorCodes[401] = \"Requires authentication\";\n```\n\n가변 또는 불변(읽기 전용) 딕셔너리를 사용하는지는 할당에 달려있습니다. let을 사용하면 선언한 후에만 읽을 수 있는 딕셔너리를 정의합니다. 쓰기를 지원하려면 var로 선언해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자세히 읽기: https://docs.swift.org/swift-book/documentation/the-swift-programming-language/collectiontypes#Dictionaries\n\n## Kotlin\n\n맵은 고유한 키와 값의 쌍을 보유하고 각 키에 해당하는 값을 효율적으로 가져오는 컬렉션입니다.\n\nKotlin에서 불변(읽기 전용) 맵을 선언하려면 Map`KeyType, ValueType` 유형을 사용하고 mapOf(varargs pairs: Pair`KeyType, ValueType`) 표준 라이브러리 함수를 사용하여 초기화합니다. 적어도 하나의 키-값 쌍을 제공하면 명시적인 변수 유형 선언을 생략할 수 있습니다. 컴파일러가 유형을 결정할 수 있기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n값을 선언할 때 Pair(key, value) 클래스를 직접 사용하거나 객체를 만들어주는 to 인픽스 함수를 사용할 수 있습니다.\n\n```kotlin\nval httpErrorCodes: Map<Int, String> = mapOf(\n    404 to \"찾을 수 없음\",\n    Pair(401, \"권한이 없음\"),\n)\n```\n\n키를 사용하여 맵에서 값을 읽을 때 대괄호 표기법(map[key])을 사용할 수 있습니다. 키가 맵에 존재하지 않으면 null이 반환됩니다. ?: 연산자를 사용하여 기본값을 제공할 수 있습니다.\n\n```kotlin\nfun getHttpErrorCodeMessage(code: Int): String {\n    val errorCodeMessage = httpErrorCodes[code] ?: \"알 수 없음\"\n    return \"Http 오류 코드: $errorCodeMessage\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n맵에 새로운 값을 작성하려면 MutableMap KeyType, ValueType 형식과 mutableMapOf() 팩토리 함수를 사용하여 가변 맵을 선언해야 합니다. 그런 다음 키에 값을 할당합니다. 키가 존재하지 않으면 새로운 키-값 쌍이 컬렉션에 추가됩니다. 키가 이미 존재하면 해당 값을 업데이트합니다.\n\n```js\n// 새 키:값 쌍 추가\nhttpErrorCodes[500] = \"내부 서버 오류\";\n\n// 기존 키에 대한 값 업데이트\nhttpErrorCodes[401] = \"인증이 필요함\";\n```\n\n더 읽어보기: https://www.baeldung.com/kotlin/maps\n\n# 6. 확장\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n확장(extension)은 기존 클래스나 구조체에 새로운 기능을 추가하는 방법입니다. 때로는 코드에 액세스할 수 없는 것들에 대해서도 확장을 적용할 수 있습니다.\n\nSwift에서는 extension 키워드를 사용하여 확장을 정의할 수 있습니다. 확장은 다른 클래스나 구조체 외부의 최상위 레벨에서 선언되어야 합니다.\n\n```js\nextension String {\n    func doubled() -> String {\n        return self + self\n    }\n}\n```\n\n위 예제에서는 String 타입에 doubled() 확장 함수를 정의했습니다. 이제 이 함수를 문자열의 인스턴스에서 호출할 수 있으며 마치 원래 정의에 포함된 것처럼 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet originalStr = \"Swift\";\nlet doubledStr = originalStr.doubled();\nprint(doubledStr); // prints \"SwiftSwift\"\n```\n\n## Kotlin\n\nKotlin은 동일한 방식으로 작동하는 확장 함수를 사용하며 기존 클래스에 새 기능을 추가할 수 있습니다. 우리는 확장하려는 클래스 이름과 함께 점과 함수 이름이 이어지는 최상위 함수로 정의합니다.\n\n```js\nfun String.doubled(): String {\n    return this + this\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 이 함수를 사용하여 원래 정의의 일부인 문자열 인스턴스에서 호출할 수 있습니다.\n\n```js\nval originalStr = \"Kotlin\"\nval doubledStr = originalStr.doubled()\nprintln(doubledStr) // \"KotlinKotlin\" 출력\n```\n\n# 7. 프로토콜\n\nSwift에서 프로토콜은 클래스, 구조체 또는 열거형이 해당 요구 사항의 실제 구현을 제공함으로써 채택할 수 있는 속성, 메서드 및 기타 요구 사항의 집합입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로토콜을 정의할 때는 프로토콜 키워드 뒤에 프로토콜 이름을 붙이면 됩니다. 이는 구조체나 클래스 선언과 유사합니다. 프로토콜 내부에서는 get할 수 있는(' get ') 또는 get과 set이 모두 가능한(' get set ') 속성을 정의할 수 있습니다.\n\n```js\nprotocol RequestError {\n    var errorCode: Int { get }\n    var isRecoverable: Bool { get set }\n}\n\nprotocol PrintableError {\n    func buildErrorMessage() -> String\n}\n```\n\n위 예시에서는 RequestError라는 프로토콜을 정의했는데, 이 프로토콜에는 errorCode라는 get할 수 있는 속성과 isRecoverable이라는 set이 가능한 속성이 포함되어 있습니다. 또한, adopter가 구현해야 하는 buildErrorMessage() 함수를 포함하는 PrintableError라는 프로토콜도 정의했습니다.\n\n프로토콜을 채택하기 위해서는 클래스나 구조체를 정의하고 이름 뒤에 : ProtocolName을 추가해야 합니다. 여러 프로토콜을 선언하려면 쉼표를 사용하면 됩니다. 그런 다음 클래스나 구조체의 본문에서 프로토콜로부터 요구되는 내용을 정의해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass ServerHttpError: RequestError, PrintableError {\n    var errorCode: Int = 500\n    var isRecoverable: Bool = false\n\n    func buildErrorMessage() -> String {\n        return \"Server side http error with error code \\(errorCode)\"\n    }\n}\n\nstruct ConnectionError: RequestError, PrintableError {\n    var errorCode: Int\n    var isRecoverable: Bool\n\n    func buildErrorMessage() -> String {\n        return \"Local connection error\"\n    }\n}\n```\n\n우리는 RequestError와 PrintableError 프로토콜을 채택하는 ServerHttpError 클래스를 정의했고, 두 속성의 기본값과 함수의 구현을 정의했습니다. 또한 두 속성을 선언하고 함수의 구현을 제공하는 ConnectionError 구조체를 가지고 있습니다.\n\n이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고 이들을 RequestError 또는 PrintableError 유형으로 전달할 수 있습니다. RequestError 유형을 수락하는 onRequestError() 함수에서 error가 PrintableError 프로토콜을 준수하는지 확인하여 오류 메시지를 구성합니다.\n\n```js\nfunc onRequestError(error: RequestError) {\n    if let printableError = error as? PrintableError {\n        print(printableError.buildErrorMessage())\n    }\n    print(\"Is recoverable: \\(error.isRecoverable)\")\n}\n\nlet firstError = ServerHttpError()\nfirstError.errorCode = 503\nfirstError.isRecoverable = false\n\nlet secondError = ConnectionError(errorCode: 404, isRecoverable: true)\n\n// \"Server side http error with error code 503. Is recoverable: false\"\nonRequestError(error: firstError)\n// \"Local connection error. Is recoverable: true\"\nonRequestError(error: secondError)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 프로토콜을 사용하는 간단한 예시입니다. Swift의 프로토콜은 상속, 합성, 연관 타입, 제네릭 등과 같이 더 고급적인 사용 사례를 지원합니다. 더 많은 내용은 https://docs.swift.org/swift-book/documentation/the-swift-programming-language/protocols에서 확인할 수 있어요.\n\n## Kotlin\n\n위의 예시는 인터페이스, 추상 클래스, sealed 클래스 등을 사용하여 Kotlin으로 여러 방법으로 작성할 수 있습니다. 그러나 Swift의 프로토콜을 가장 가깝게 표현하는 것은 아마도 인터페이스일 것입니다. 이는 속성과 함수를 정의하며, 상속, 구성, 그리고 제네릭을 지원합니다.\n\n인터페이스를 정의할 때는 interface 키워드를 사용하고 이름을 이어서 작성합니다. 본문에서는 속성과 함수를 정의합니다. 읽기 전용 속성은 val 키워드를 사용하여 정의하고, 읽기/쓰기 속성은 var 키워드를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 인터페이스를 구현하도록 클래스에 지정하는 방법은, 클래스 이름 뒤에 InterfaceName을 사용합니다. 여러 인터페이스를 구현하려면 쉼표를 사용합니다. 그런 다음 모든 속성과 함수를 override 키워드와 함께 정의해야 합니다.\n\n```js\ninterface RequestError {\n    val errorCode: Int\n    var isRecoverable: Boolean\n}\n\ninterface PrintableError {\n    fun buildErrorMessage(): String\n}\n\nclass ServerHttpError(\n    override val errorCode: Int,\n    override var isRecoverable: Boolean\n) : RequestError, PrintableError {\n    override fun buildErrorMessage(): String {\n        return \"Server side http error with error code $errorCode\"\n    }\n}\n\nclass ConnectionError : RequestError, PrintableError {\n    override val errorCode: Int\n        get() = 404\n    override var isRecoverable: Boolean = true\n\n    override fun buildErrorMessage(): String {\n        return \"Local connection error\"\n    }\n}\n```\n\n이제 ServerHttpError 및 ConnectionError의 인스턴스를 생성하고, 함수에 RequestError 유형으로 전달할 수 있습니다.\n\n```js\nfun onRequestError(error: RequestError) {\n    if (error is PrintableError) {\n        println(error.buildErrorMessage())\n    }\n    println(\"$errorMessage. Is recoverable: ${error.isRecoverable}\")\n}\n\nval firstError = ServerHttpError(errorCode = 503, isRecoverable = false)\nval secondError = ConnectionError()\n// \"Server side http error with error code 503. Is recoverable: false\"\nonRequestError(firstError)\n// \"Local connection error. Is recoverable: true\"\nonRequestError(secondError)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRead more at https://kotlinlang.org/docs/interfaces.html\n\n# 결론\n\n일반적인 Swift 패턴을 이해하고 Kotlin에서 어떻게 번역되는지 알면 코드가 하는 일을 더 잘 이해할 수 있습니다. 이웃 플랫폼에서 어떤 기능이 구현되었는지 보거나 코드 검토를 수행하거나 기술 사양/제안서를 검토하거나 작업을 Kotlin Multiplatform으로 수행하는 여러 방법이 있습니다.\n\nSwift 언어의 기본적인 내용과 Kotlin과 비교하는 방법을 살펴보았습니다. 또한, 선택적 바인딩, 딕셔너리, 익스텐션, 구조 및 프로토콜과 같은 전형적인 iOS 프로젝트에서 발견할 수 있는 일반적인 패턴에 대해서도 다루었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문이 도움이 되었다면 댓글로 알려주세요! Swift 코드를 읽거나 검토하거나 작성하는 경험에 대해 공유하는 것을 장려합니다.\n\n참고 자료:\n\n- https://kotlinlang.org/docs/home.html\n- https://docs.swift.org/swift-book/documentation/the-swift-programming-language/thebasics\n\nAndrej Rolih 님의 검토와 피드백에 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png"},"coverImage":"/assets/img/2024-05-23-SwiftCheatsheetforAndroidKotlinDevelopers_0.png","tag":["Tech"],"readingTime":25},{"title":"깔끔한 아키텍처 사용 사례의 복잡성","description":"","date":"2024-05-23 14:42","slug":"2024-05-23-TheComplexitiesofCleanArchitectureUseCases","content":"\nClean Architecture는 따라야 할 규칙이 있는데, 엄격히 준수한다고 해서 문제가 발생할 수 있습니다. 이 글에서는 정확히 이러한 규칙을 엄격히 준수할 때 발생할 수 있는 몇 가지 문제점, 특히 유스케이스와 단일 책임 원칙 (SRP)에 초점을 맞춰 구체적으로 논의하겠습니다.\n이 글은 Clean Architecture와 해당 용어에 이미 익숙한 사람들을 대상으로 합니다.\n\nClean Architecture의 주요 기반 중 하나는 레이어링입니다. 핵심 아이디어는 소프트웨어를 특정 책임을 갖는 구분된 레이어로 분리하여, 의존성이 하나의 방향으로 흐르도록 하는 것입니다: 외부 레이어에서 내부 레이어로.\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_0.png)\n\nClean Architecture의 규칙 중 하나는 의존성 원칙인데, 이것은 소스 코드 의존성이 내부로만 향한다는 것을 말합니다. 즉, 데이터 레이어에서 뭔가를 얻거나 수행하려면 항상 중간에 프록시 역할을 하는 것을 생성해야 하며, 일반적으로 그것이 유스케이스입니다. 유스케이스는 시스템이 수행해야 하는 단일 재사용 가능한 작업에 대한 비즈니스 로직을 캡슐화합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 줄로 된 UseCase\n\n비즈니스 규칙이 'UI에 데이터를 표시해야 한다'는 규칙 외에는 어떤 비즈니스 규칙도 없더라도, 종속성 규칙을 따르면 데이터 레이어에서 데이터를 가져오는 UseCase를 만들어야 합니다.\n\n```kotlin\nclass GetUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(userConfig: UserConfig): Result<User> {\n   return userRepository.getUser()\n }\n}\n```\n\nGetUserUseCase에는 규칙이 없고 다른 레이어로의 프록시 역할만 수행합니다. 어떻게 하면 추가적인 로직 없이 모든 사용자에 대한 CRUD를 갖을 수 있을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nclass GetUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(userConfig: UserConfig): Result<User> {\n   return userRepository.getUser()\n }\n\n}\n\nclass AddUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(user: User) {\n   return userRepository.addUser(user)\n }\n\n}\n\nclass DeleteUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(user: User) {\n   return userRepository.deleteUser(user)\n }\n\n}\n\nclass UpdateUserUseCase(\n   private val userRepository: UserRepository\n) {\n\n operator fun invoke(user: User) {\n    return userRepository.updateUser(user)\n }\n\n}\n```\n\n한 줄짜리 use case 수는 기하급수적으로 늘어날 수 있습니다. 하나의 데이터 유형에 대해 여러 개의 use case를 생성할 수 있습니다. 실제 세계에서의 상황은 더 나빠질 수도 있습니다. GetAllUsersUseCase, GetOldUserCase 등과 같은 UseCases를 가질 수 있습니다.\n\n이 use cases는 데이터 계층에 대한 프록시 역할을 하는 것 외에 아무것도 하지 않습니다. Clean Architecture의 일부 구현에서는 모델 간의 변환을 수행하는 매퍼도 존재할 수 있으며, 이는 상황을 더 악화시킵니다. 비즈니스 규칙을 행동으로 전환하지 않습니다. 어떤 문제도 해결하지 않고, 단지 Clean Architecture의 규칙을 만족시키기 위해 추가 코드를 작성합니다.\n\n조금 생각해 봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간이 흘러감에 따라 '한 줄짜리 사용 사례'의 기여로 인해 사용 사례의 수가 너무 많아질 수 있습니다. 프로젝트에는 50, 100, 200, 500개 이상의 사용 사례가 쌓일 수 있습니다. 이 많은 수의 사용 사례는 문제를 야기할 수 있습니다.\n\n예를 들어, 새로운 화면을 작업 중이고 이미 애플리케이션에서 사용되는 데이터를 표시해야 한다고 상상해보세요. 이미 작성된 사용 사례, 저장소 등이 해당 데이터 유형과 작업하는데 사용됩니다. 그런데 이 수백 개의 사용 사례 중에서 재사용할 수 있는 것을 찾아야 합니다. 이 작업은 프로젝트 내의 다양한 요소에 따라 쉬울 수도 있고 어려울 수도 있습니다.\n\n명명 규칙이 엄격합니까? 그렇다면 사용 사례의 이름은 \"GetMyDataType\"와 같이 시작할 수 있고 이를 통해 이름으로 검색을 시작할 수 있습니다. 그러나 명명은 어렵고 엄격한 규칙이 있더라도 의도를 정확하게 나타내지 못할 수 있습니다.\n\n다중 저장소 아키텍처를 사용합니까? 이는 각 팀이 자체 저장소를 사용하여 다른 별도 프로젝트에서 작업하고, 이러한 모든 프로젝트가 라이브러리 형식으로 주 애플리케이션에 포함되는 구조를 말합니다. 이러한 경우 필요한 사용 사례가 다른 저장소에 있을 수 있으며 이를 찾고 재사용하는 것이 더 어려울 수 있습니다. 기본적으로 사용 사례를 찾기 위해 다양한 프로젝트를 검색해야 하며, 아마도 사용할 수 없을 것입니다. 사용 사례가 캡슐화되어 있을 수 있기 때문입니다. 만약 캡슐화되어 있지 않더라도 다른 팀이 변경을 가할 경우 코드가 깨질 수 있으므로 캡슐화돼 있어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n[기능 모듈화](https://developer.android.com/topic/modularization)와 관련된 내용입니다. 기능의 코드 변경이 다른 기능 또는 애플리케이션에 영향을 미치지 않아야 합니다. 기능 모듈의 고유성(cohesion)을 높이고 싶다면, 내부(modifier)로 접근 가능하도록 하여 재사용성을 의도적으로 줄일 수 있습니다.\n\n의존성 규칙을 엄격히 준수하며 use case를 작성하는 주요 이유는 다음과 같습니다: \"언제나 use case를 사용하여 코드를 앞으로의 변경으로부터 보호하게 됩니다. 예를 들어, 지불 전송에 추가 단계가 필요한 경우 새로운 use case를 생성하고 해당 repository 기능을 사용하던 모든 ViewModel을 use case로 대체해야 합니다.\" 그러나 실제로는 어떤가요?\n\n예제를 살펴보겠습니다. 은행 앱에서 신용 카드 목록을 제공하는 use case가 있다고 가정해봅시다.\n\n```js\nclass GetCreditCartsUseCase(\n    private val creditCardRepository: CreditCardRepository\n) {\n\n operator fun invoke(): Result<List<CreditCard>> {\n    return creditCardRepository.getCreditCards()\n }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 앱 전체에 이 데이터를 여러 곳에 표시해야 합니다.\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_1.png)\n\n요구 사항이 변경되었을 때 어려움이 생길 수 있는 날이 왔습니다. 변경 사항이 다른 곳에 적용되지 않을까 걱정할 필요 없이 유스케이스를 변경할 수 있습니다. 따라서 한 곳에서만 변경하고, 한 클래스에 대한 새로운 유닛 테스트를 추가하면 됩니다.\n\n하지만 문제가 있습니다: 요구 사항이 한 화면에 대해서만 변경되었습니다. 개요 화면에서는 가장 최근에 획득한 신용카드 하나만 보여주어야 합니다. 이제 기존 유스케이스를 재사용하는 대신 새로운 유스케이스를 만들고 영향을 받는 viewModel을 수정해야 합니다. 제 경험 상, 대부분의 경우 요구 사항과 유스케이스가 이렇게 되는 것입니다. (미래를 예측할 수 있는 경우를 제외하고는, 무엇을, 어디를 재사용할 수 있는지 알 수 없습니다)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_2.png\" />\n\n이제 UseCase의 비즈니스 요구 사항에 대해 생각해 봅시다. 우리는 신용 카드 목록을 가져와 UI에 표시해야 합니다. 사용된 모든 곳에 영향을 미치는 추가 로직이 있을 가능성은 어떤지요? 저는 \"잘 없을 것\"이라고 생각합니다. 현재 작업 중인 앱에 대해 생각해보면 이러한 요구 사항의 본질 때문에 결코 변경될 수 없는 많은 유스케이스를 찾을 수 있다고 확신합니다.\n\n큰 프로젝트에서 발생할 수 있는 또 다른 문제는 생성자 과다 주입입니다:\n\n```js\nclass UserSettingsViewModel(\n   private val getUserUserCase: GetUserUserCase,\n   private val getAllUsersUseCase: GetAllUsersUseCase,\n   private val addUserUseCase: AddUserUseCase,\n   private val deleteUserUseCase: DeleteUserUseCase,\n   private val updateUserUseCase: UpdateUserUseCase,\n   private val getPremiumUsersUseCase: GetPremiumUsersUseCase,\n   private val getFiltersUseCase: GetFiltersUseCase,\n   private val getAppSettingsUseCase: GetAppSettingsUseCase,\n   private val selectUserUseCase: SelectUserUseCase,\n   private val selectFilterUseCase: SelectFilterUseCase,\n   private val updateAppSettingsUseCase: UpdateAppSettingsUseCase\n   //…이하 생략…\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n익숙한 것 같나요? 댓글 달 건 없어요. (하지만, 공정하게 말하자면, 생성자에 10-20-40개 이상의 인수가 허용되는 경우에는 문제가 되지 않아요).\n\n그럼, 이에 대해 어떻게 처리할까요?\n\n데이터 레이어를 직접 사용하세요.\nGoogle에서 권장하는 방법입니다:\nhttps://developer.android.com/topic/architecture/domain-layer#data-access-restriction\n\n\"하지만, 잠재적으로 상당한 단점은 데이터 레이어에 대한 간단한 함수 호출일 때에도 유즈 케이스를 추가해야 하므로, 작은 혜택을 위해 복잡성을 추가할 수 있다는 것입니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋은 방법은 필요한 경우에만 사용 사례를 추가하는 것입니다. UI 레이어가 대부분의 경우 사용 사례를 통해 데이터에 액세스하는 것을 발견하면 데이터에 이렇게만 액세스하는 것이 더 낫다고 할 수 있습니다.\n\n일부 경우에는 의존성 규칙을 위반하고 데이터 레이어를 UI 레이어에서 직접 사용하는 것을 제안하며, 이는 고려할 만한 사항이기도 합니다.\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_3.png)\n\nFacade\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만, 만약 관심사 분리를 유지하고 깔끔한 아키텍처 계층 원칙을 완전히 따르면서 지나치게 한 줄 논리 사용 사례의 함정에 빠지지 않으려면 Facade 패턴을 사용하는 것을 고려해보세요.\n\n```js\nclass UserFacade(\n   private val userRepository: UserRepository,\n   private val userMapper: UserMapper\n) {\n\n fun getUser(userConfig: UserConfig): Result<User> {\n   return userRepository.getUser(userConfig)\n }\n\n fun getAllUsers(): Result<List<User>> {\n   return userRepository.getUsers()\n }\n\n fun getAllPremiumUsers(): Result<List<User>> {\n   return userRepository.getPremiumUsers()\n }\n\n fun addUser(user: User): Result<User> {\n   return userRepository.addUser(user)\n }\n\n fun deleteUser(user: User): Result<User> {\n    return userRepository.deleteUser(user)\n }\n\n fun updateUser(user: User): Result<User> {\n    return userRepository.updateUser(user)\n }\n}\n```\n\nFacade 패턴은 하위 시스템을 더 쉽게 사용할 수 있도록 단일하고 더 연관성 있는 인터페이스로 복잡성을 캡슐화합니다. 코드베이스 전반에 흩어져 있는 여러 한 줄 논리 사용 사례 대신에 Facade는 이러한 작업을 통합합니다. 이렇게 하면 본질적으로 동일한 작업을 수행하는 많은 사용 사례를 가지는 중복성이 줄어듭니다 — 데이터 계층과 상호 작용하는 것과 관련이 있는 사용 사례가 많이 감소합니다.\n\n어떠한 다른 옵션들, 예를 들어 모든 데이터 형식과 재사용할 수 있는 일반 타입의 Facade, 같은 작업이 무엇을 가장 잘 수행하는지 찾아보기 위한 실험이 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단일 책임 원칙\n\n이제 SOLID 원칙 중 SRP에 대해 이야기해보겠습니다. UseCase가 단일 작업이어야 한다는 것을 기억하세요. 그리고 해당 정의에 따라 SRP를 준수해야 합니다.\n\n새 사용자 등록을 담당하는 UseCase가 있습니다:\n\n```js\nclass UserRegistrationUseCase(\n    private val userRepository: UserRepository,\n    private val appThemeRepository: AppThemeRepository,\n    private val emailService: EmailService,\n    private val securityService: SecurityService,\n    private val promotionsService: PromotionsService,\n) {\n\n    operator fun invoke(userDetails: UserDetails): Result<User> {\n        if (securityService.weak(password = userDetails.password)) {\n            return Result.failure(Exception(\"비밀번호가 약합니다\"))\n        }\n\n        val isPromotional = checkPromotionalEligibility(userDetails.email, userDetails.location)\n        val userSettings = UserSettings(\"en-US\", receiveNewsletters = isPromotional)\n        val starterPack = if (isPromotional)\n            promotionsService.getPromotionalStarterPack(userDetails.location)\n        else promotionsService.getDefaultStarterPack(userDetails.location)\n\n        val user = User.fromUserDetails(userDetails, securityService.encryptPassword(userDetails.password), isPromotional, userSettings, starterPack)\n\n        userRepository.save(user)\n        emailService.sendWelcomeEmail(userDetails.email, isPromotional)\n\n        if (isPromotional)\n            appThemeRepository.save(user.id, \"dark\")\n        else appThemeRepository.save(user.id, \"light\")\n\n        promotionsService.schedulePersonalizedFollowUps(user.id, user.email, user.isPromotional)\n        return Result.success(user)\n    }\n\n    private fun checkPromotionalEligibility(email: String, location: String): Boolean {\n        val isEmailEligible = email.endsWith(\"@example.com\")\n        val isLocationEligible = location == \"USA\" // 미국의 프로모션 자격을 가정합니다\n        return isEmailEligible && isLocationEligible\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 UseCase를 살펴보면 SRP를 위반하는 것 같네요. 아마도 맞을 겁니다. 코드가 별도의 UseCase로 추출되고 재사용될 수 있는 부분이 있습니다. 함께 해결해보죠.\n\n```js\nclass UserRegistrationFlowUseCase(\n    private val saveUserUseCase: SaveUserUseCase,\n    private val prepareNewUserUseCase: PrepareNewUserUseCase,\n    private val userFollowUpUseCase: UserFollowUpUseCase,\n    private val sendWelcomeEmailUseCase: SendWelcomeEmailUseCase,\n    private val setAppThemeUseCase: SetAppThemeUseCase,\n) {\n\n  operator fun invoke(userDetails: UserDetails): Result<User> {\n      val userResult = prepareNewUserUseCase.prepareUser(userDetails)\n      if (userResult.isError()) {\n         return userResult\n      }\n      val user = userResult.get()\n\n      saveUserUseCase(user)\n      sendWelcomeEmailUseCase(user)\n      userFollowUpUseCase(user)\n      setAppThemeUseCase(user)\n      return Result.success(user)\n  }\n}\n\nclass PromotionEligibilityUseCase(\n    private val emailPromotionEligibilityUseCase: EmailPromotionEligibilityUseCase,\n) {\n\n  fun checkEligibility(userDetails: UserDetails): Boolean {\n      val isEmailEligible = emailPromotionEligibilityUseCase(userDetails.email)\n      val isLocationEligible = userDetails.location == \"USA\" // Assume promotional eligibility for USA\n      return isEmailEligible && isLocationEligible\n  }\n\n}\n\nclass EmailPromotionEligibilityUseCase {\n\n  operator fun invoke(email: String): Boolean {\n      val emailRegex = \"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,6}$\"\n      return email.endsWith(\"@example.com\") && email.matches(emailRegex.toRegex())\n  }\n}\n\nclass PrepareNewUserUseCase(\n    private val securityService: SecurityService,\n    private val getStarterPackUseCase: GetStarterPackUseCase,\n    private val promotionEligibilityUseCase: PromotionEligibilityUseCase,\n) {\n\n  fun prepareUser(userDetails: UserDetails): Result<User> {\n      if (securityService.weak(password = userDetails.password)) {\n         return Result.failure(Exception(\"Password is weak\"))\n      }\n      val isPromotional = promotionEligibilityUseCase.checkEligibility(userDetails)\n      val userSettings = UserSettings(\"en-US\", receiveNewsletters = isPromotional)\n      val starterPack = getStarterPackUseCase(userDetails.location, isPromotional)\n      val encryptedPassword = securityService.encryptPassword(userDetails.password)\n      return Result.success(User(\n          id = 0,\n          name = userDetails.name,\n          email = userDetails.email,\n          password = encryptedPassword,\n          location = userDetails.location,\n          isPromotional = isPromotional,\n          settings = userSettings,\n          starterPack = starterPack\n        )\n      )\n  }\n}\n\n(이하 계속)\n```\n\n우리는 SRP를 만족하는 새로운 8개 UseCase를 생성했어요. 모두 작고 깔끔하며 쉽게 재사용할 수 있어요. 테스트에 대해서 언급하지는 않았는데, 이 두 경우 모두 모든 것을 쉽게 테스트할 수 있어요.\n\n그러나 이 접근은 엄청난 **맥락적 오버헤드**를 초래합니다. 함수가 많아질수록 일어나게 됩니다. 이 예시에서는 전체 그림을 파악하려면 9개 파일 간을 이동해야 합니다. 한 책의 한 문장이 일어나는 것을 이해하기 위해 해당 문단을 읽은 다음 다음 페이지로 넘어가서 특정 문단을 읽은 다음 다시 원래 페이지로 돌아가서 다음 문장을 읽은 다음 책의 끝까지 가서 다른 문단을 읽는 것을 상상해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_4.png)\n\n기본적으로는 각 use case에서 함수 트리와 그들이 하는 일을 머릿속에 유지해야 합니다. 각 use case에서 무슨 일이 일어나고 있는지 읽고 기억해야 합니다. 함수가 무슨 일을 하는지 읽고 다음으로 진행 — 다시 읽고, 그리고 다음으로 진행 — 다시 읽고, 그리고 다시 처음 use case로 돌아가고, 나머지 남은 모든 함수와 함께 계속합니다. 모든 함수가 서로 다른 파일에 있기 때문에 모두 기억해야 합니다.\n\n![이미지](/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_5.png)\n\n또한 디버깅할 때도 귀찮은 작업인데, 다른 파일의 중단점 사이를 이동해야하고, 디버거의 데이터는 일반적으로 현재 클래스에만 표시됩니다. 코드 리뷰에 있어서도 마찬가지로 도전적입니다. 파일과 함수 사이를 쉽게 이동하는 것이 항상 가능한 것은 아니기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단지 2-3-4개의 유스케이스만으로도 코드가 해독하기 어려워집니다. 예시의 기능은 간단하고 쉽지만, 실제 프로젝트에서는 보통 더 복잡하며, 이름이 항상 명확하거나 대표적이지는 않습니다 (이름 짓기가 어려워요).\n\n첫 번째 방식에서 유스케이스는 작은 디스플레이에서도 맞게 코드가 20-25줄 정도의 함수로 있습니다. 이것을 책처럼 읽을 수 있고, 20초 전에 검토했던 세 함수가 무엇이었는지 과부하가될 필요가 없이 전체 작업을 볼 수 있습니다. 또한, 단순히 한 곳에서 사용되지 않는다면 이 \"재사용성\"은 필요한 것인가요? 재사용성이 명확한 필요가 있는 경우가 오기 전에 작은 더 구체적인 구성 요소로 유스케이스를 분리하는 것은 조기 최적화입니다. 이 접근 방식은 구조를 불필요하게 복잡하게 만들 수 있고, 관리 및 유지보수해야 하는 요소를 더 많이 도입하여 실질적인 이점 없이 만들어 낼 수 있습니다.\n\n문제를 해결하려는 것인지, 아니면 코드를 작성하는 유일한 올바른 방법으로 생각해서 규칙을 엄격하게 따르려는 것인지 고민해봐야 합니다.\n\n이 룰을 엄밀히 준수할 필요가 없는 경우에도 코드를 작업하고 유지하는 것이 훨씬 쉽다고 생각해요 (그런데 이 룰들은 많은 년이 지나도 수정되지 않았죠).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요약\n\n- 의존성 규칙: 이 규칙은 소스 코드 의존성이 내부로만 가리킬 수 있다는 것을 말합니다. 이로 인해 종종 데이터 레이어에 프록시 역할을 하는 사용 사례가 생성됩니다.\n\n- 일줄 사용 사례: Clean Architecture 엄격히 준수하면 다른 레이어로의 프록시 역할만 하는 다수의 일줄 사용 사례가 생성되어 사용 사례 수가 기하급수적으로 증가할 수 있습니다.\n\n- 기하급수적 성장: 사용 사례 수가 급속히 증가함에 따라 코드베이스를 유지하고 탐색하는 것이 어려움을 초래할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 복잡성과 오버헤드: SRP를 엄격히 준수하면 하나의 사용 사례를 많은 작은 사용 사례로 분해하여 시스템의 복잡성과 맥락 상의 오버헤드를 증가시킬 수 있습니다.\n\n- 균형: UseCase를 설계할 때 이론적 순수성과 재사용성을 유지하는 Single Responsibility Principle (SRP)과 작동 오버헤드를 최소화하는 실용적이고 유지보수 가능한 시스템을 만드는 사이의 상충 관계를 고려해주세요.\n\n독서해 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_0.png"},"coverImage":"/assets/img/2024-05-23-TheComplexitiesofCleanArchitectureUseCases_0.png","tag":["Tech"],"readingTime":18},{"title":"스캐니버스가 안드로이드를 지원하게 되었습니다","description":"","date":"2024-05-23 14:41","slug":"2024-05-23-ScaniverseextendssupporttoAndroid","content":"\n## 다양한 플랫폼에서 3D 스캐닝과 가우시안 스플래팅을 경험해보세요\n\n우리는 Scaniverse가 이제 Google Play Store에서 사용 가능하다는 것을 기쁘게 알려드립니다!\n\n2021년 1월에 론칭한 이후, 사용자들이 가장 많이 물어보는 질문 중 하나가 '언제 안드로이드용 Scaniverse가 출시될까요?' 였습니다. 그래서 오늘부터 Scaniverse를 Play Store에서 안드로이드 사용자들을 위해 제공할 수 있게 되어 너무 기쁩니다. 3D 스캐닝 및 크리에이션을 더 많은 사용자들에게 전 세계적으로 제공할 수 있게 되었습니다.\n\n![이미지](/assets/img/2024-05-23-ScaniverseextendssupporttoAndroid_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 3D 창조물을 촬영, 편집 및 공유하세요\n\n안드로이드의 Scaniverse를 통해 iOS 앱의 최상의 기능을 경험할 수 있습니다. 주변 환경을 스캔하고 모델을 자르고 편집하여 창조물을 세계와 공유하거나 내보낼 수 있습니다. 최근 추가된 3D 가우시안 스플래팅 기능도 포함되어 있어, 좋아하는 장소와 물건의 환상적인 사실적인 세부사항을 캡처할 수 있습니다. 또한 Android에서 세계 최초로 3D 기기 내 스플래트 재구성 기능도 소개되어, 속도와 개인 정보 보호를 제로 저장 비용과 함께 제공합니다. 무료, 빠르고 제한이 없습니다.\n\n# 뒷이야기: Scaniverse 이식\n\nScaniverse의 안드로이드 버전을 만드는 것은 도전적이지만 보람 있는 여정이었습니다. 여기에는 어떻게 만들었는지에 대한 소개가 있습니다. 원래의 iOS 앱은 Swift와 네이티브 C++ 코드를 사용하여 만들어졌습니다. 안드로이드에서는 가능한 경우 네이티브 C++ 구성 요소를 재사용하여 플러터 프레임워크를 선택하여 크로스 플랫폼 구현을 만들었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현대 iPhones 중 일부는 LIDAR 센서가 장착된 반면, Android 폰은 그렇지 않아서 포토그램메트리 모드를 통해 3D 재구성할 때 카메라 데이터에만 의존해야 했습니다. 또한 다양한 SoC, CPU 및 GPU를 갖춘 Android 기기 범위에 대한 성능 및 안정성을 최적화하려면 상당한 노력이 필요했습니다. 고사양 Android 기기에서 처리 시간을 30분 이상에서 단 4~5분으로 줄였습니다. 초기 릴리스가 현대 iPhones의 속도에 미치지 못할 수도 있지만, 오늘날 Android 기기에서 훌륭한 성능과 품질을 제공합니다.\n\n자세한 내용은 [FAQ](https://faq.link)를 방문해보세요.\n\n# Android 여정에 참여하세요\n\n![이미지](https://miro.medium.com/v2/resize:fit:600/1*TfpgfZYjKOkVC_6fibRbIA.gif)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드에서의 여정이 이제 막 시작됐습니다. 우리는 iOS 앱과 기능의 동일성을 달성하고, 스캔 품질을 향상시키며, 각 업데이트마다 성능을 향상시키겠다는 다짐을 하고 있습니다. 여러분의 피드백은 저희에게 매우 중요합니다. Scaniverse가 여러분을 어떻게 더 잘 도울 수 있는지 support@scaniverse.com으로 연락주시면 감사하겠습니다.\n\n지금 구글 플레이 스토어에서 Scaniverse를 다운로드하고 멋진 3D 콘텐츠를 만들어보세요. 좋아하는 3D 작품을 @scaniverse를 태그하여 인스타그램에서 공유하거나 해시태그 #scandroid로 X에 공유해주시면 저희가 채널에서 공유해드리겠습니다!\n\nScaniverse 팀 드림\n","ogImage":{"url":"/assets/img/2024-05-23-ScaniverseextendssupporttoAndroid_0.png"},"coverImage":"/assets/img/2024-05-23-ScaniverseextendssupporttoAndroid_0.png","tag":["Tech"],"readingTime":3},{"title":"테라스캔Terrascan이란 무엇인가요","description":"","date":"2024-05-23 14:39","slug":"2024-05-23-WhatisTerrascan","content":"\n이 기사에서는 Terrascan을 살펴볼 것입니다. 이것이 무엇인지, 왜 사용해야 하는지, 어떻게 설치해야 하는지, 그리고 그 기능을 활용하는 방법에 대해 알아볼 것입니다. 우리는 일부 사용 사례 예제를 살펴보고, Terraform, Kubernetes (K8S) 및 Helm 차트를 스캔하는 방법을 보여줄 것입니다. 그리고 사용자 정의 정책을 정의하는 방법을 살펴보고, 마지막으로 Terrascan이 Chekov 및 TFSec와 같은 다른 유사한 제품과 비교되는 방법을 자세히 살펴볼 것입니다.\n\n![What is Terrascan](/assets/img/2024-05-23-WhatisTerrascan_0.png)\n\n## Terrascan이란 무엇인가요?\n\nTerrascan은 인프라를 코드로 정의하는(Infrastructure as Code, IaC)를 위한 오픈 소스 정적 코드 분석 도구입니다. Terrascan 웹사이트 태그라인이 Terrascan을 요약합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기의 핵심 키워드 중 하나는 'before'입니다. Terrascan 도구의 목표는 인프라가 프로비저닝되기 전에 규정 준수나 보안 문제를 알려줌으로써 이를 해결하여 문제를 피하는 것입니다.\n\nTerrascan은 Tenable이 소유하고 있으며, 이 회사는 Cloud Native Computing Foundation (CNCF) 및 Open Source Security Foundation (OpenSSF)의 회원입니다.\n\n## Terrascan의 사용 목적\n\nTerrascan은 개발자와 DevOps 팀이 인프라 코드가 모범 사례, 보안 표준 및 규정 요구 사항을 준수하는지를 보장하는 데 도움을 줍니다. Terrascan은 500개 이상의 미리 설정된 정책을 제공하여 CIS Benchmark와 같은 공통 정책 표준에 대해 IaC를 검사할 수 있습니다. Terrascan을 처음 사용할 때 -p 플래그가 지정되지 않은 경우, Terrascan은 Terrascan 리포지토리에서 최신 정책을 다운로드합니다. terrascan init를 실행하여 로컬 환경을 리포지토리에 게시된 최신 정책으로 업데이트할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Terrascan 특징\n\n- Terrascan은 AWS, Azure, Google Cloud Platform (GCP), K8S, ArgoCD, Atlantis, GitHub, Docker을 포함한 다양한 클라우드 제공업체 및 코드 유형과 함께 사용할 수 있어 교차 클라우드 인프라 배포에 다재다능합니다.\n- Terrascan은 사용자 정의 가능한 사전 정의된 보안 및 규정 준수 규칙 라이브러리를 제공합니다. 이러한 규칙은 암호화, 액세스 제어, 리소스 구성 등 인프라 보안 및 규정 준수의 다양한 측면을 포함합니다. 기본적으로 사용되는 정책을 자세히 보려면 terrascan 정책 문서 페이지를 확인할 수 있습니다.\n- Terrascan은 CI/CD 파이프라인, IDE(통합 개발 환경) 및 다른 개발 및 배포 워크플로에 통합할 수 있습니다. 이를 통해 IaC 코드의 자동 스캔 및 유효성 검사가 개발 프로세스의 일부로 이루어질 수 있습니다.\n- Terrascan은 클라우드 인프라의 지속적인 모니터링에 사용될 수 있습니다. 취약점이나 규정 준수 문제를 발생시킬 수 있는 변질이나 구성 변경을 정기적으로 검사하고 확인할 수 있도록 설정할 수 있습니다.\n- 보고 및 개선: Terrascan은 분석 중 발견된 문제를 강조하는 자세한 보고서를 생성합니다. 또한 이러한 문제를 어떻게 개선할지에 대한 지침을 제공하여 팀이 보안 및 규정 준수 문제를 효과적으로 해결할 수 있도록 도와줍니다.\n\n## Terrascan 설치 방법\n\n- Windows\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인기 있는 Windows 패키지 관리자 Chocolately를 사용하거나 수동으로 다운로드하여 설치할 수 있어요.\n\n```js\nchoco install terrascan\n```\n\n릴리스 페이지에서 Terrascan을 다운로드하세요:\n\nzip 파일에서 파일을 추출하고 Windows 경로에 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 시작 단추를 마우스 오른쪽 버튼으로 클릭합니다.\n- 콘텍스트 메뉴에서 “시스템”을 선택합니다.\n- “고급 시스템 설정”을 클릭합니다.\n- “고급” 탭으로 이동합니다.\n- “환경 변수…”를 클릭합니다.\n- “Path”라는 변수를 클릭하고 “편집…”을 클릭합니다.\n- “새로 만들기”를 클릭합니다.\n- PATH에 포함하려는 Terrascan 파일이 있는 폴더의 경로를 입력하세요.\n\n- MacOS\n\n```js\ncurl -L \"$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E \"https://.+?_Darwin_x86_64.tar.gz\")\" > terrascan.tar.gz\ntar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz\ninstall terrascan /usr/local/bin && rm terrascan\nsudo install terrascan /usr/local/bin\n```\n\n- Linux\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncurl -L \"$(curl -s https://api.github.com/repos/tenable/terrascan/releases/latest | grep -o -E \"https://.+?_Linux_x86_64.tar.gz\")\" > terrascan.tar.gz\ntar -xf terrascan.tar.gz terrascan && rm terrascan.tar.gz\ninstall terrascan /usr/local/bin && rm terrascan\nsudo install terrascan /usr/local/bin\n```\n\n- 도커\n\n도커 허브에서 이미지를 다음과 같이 가져올 수도 있습니다:\n\n```js\n$ docker run --rm tenable/terrascan version\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테라스캔을 설치한 후 설치 여부를 확인하기 위해 명령줄에서 테라스캔을 실행하세요.\n\n![Terrascan](/assets/img/2024-05-23-WhatisTerrascan_1.png)\n\n## IaC 코드를 스캔하는 방법\n\n코드를 스캔하려면 구성 파일이 있는 폴더로 이동한 후 다음 명령을 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nterrascan scan\n```\n\n--c 옵션을 사용하여 스캔할 디렉토리를 지정할 수도 있어요.\n\n## Terrascan 사용 사례 - 예시\n\nTerrascan을 여러 유형의 구성 파일과 함께 사용할 수 있어요. 여기에 몇 가지 예시가 있어요. 이를 통해 쉽게 시작할 수 있을 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예제 1 — Terraform 코드 스캔\n\nAzure를 위한 예제 Terraform 설정 파일이 있습니다. 이 파일은 간단히 리소스 그룹을 생성합니다:\n\nmain.tf\n\n```js\nprovider \"azurerm\" {\n  features {}\n}\n\nresource \"azurerm_resource_group\" \"example\" {\n  name     = \"example-resources\"\n  location = \"East US\"\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파일을 저장한 후 해당 디렉토리로 이동하여 terrascan scan을 실행하십시오. Terrascan이 1개의 정책 위반을 감지하고 리소스 그룹에 리소스 잠금을 활성화해야 한다고 권장함을 볼 수 있어요. 이 문제는 LOW 심각도로 표시돼요.\n\n![Terrascan Screenshot](/assets/img/2024-05-23-WhatisTerrascan_2.png)\n\n## 예제 2 - Helm 차트 스캔\n\nHelm 차트를 사용하여 Terrascan을 테스트하기 위해 demo-chart라는 새 차트를 만들어보겠어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nhelm create demo-chart\n```\n\n이제 values.yaml 파일을 편집하여 Terrascan이 보고할 몇 가지 추가 취약점을 추가해보겠습니다.\n\n<img src=\"/assets/img/2024-05-23-WhatisTerrascan_3.png\" />\n\nvalues.yaml 파일이 있는 디렉토리로 이동한 다음 terrascan scan을 실행하세요. 보고된 위반 정책이 여러 개 표시되어야 합니다. 여기에는 위에 securityContext 라인을 추가하여 발생시킨 HIGH 심각도의 2개의 정책 위반이 포함될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-WhatisTerrascan_4.png\" />\n\n## 예제 3 — 쿠버네티스 매니페스트 스캔하기\n\nK8S 매니페스트를 스캔하는 방법을 테스트하기 위해 간단한 nginx 배포용 파일을 작성해보겠습니다:\n\nnginx.yaml\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n        - name: nginx\n          image: nginx:latest\n          ports:\n            - containerPort: 80\n```\n\nnginx.yaml 파일이 있는 폴더로 이동하여 terrascan scan을 실행해주세요.\n\nTerrascan에서 여러 권장 사항을 보게 될 것인데, 그 중에는 2개의 HIGH 우선 순위 이슈('Minimize Admission of Root Containers' 및 'Containers Should Not Run with AllowPrivilegeEscalation')도 포함되어 있습니다.\n\n<img src=\"/assets/img/2024-05-23-WhatisTerrascan_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예제 4 — Terrascan을 ArgoCD와 통합하기\n\nTerrascan은 인기있는 CI/CD 시스템인 Azure DevOps, GitHub, GitLab 및 Argo와 통합할 수 있습니다. ArgoCD의 경우, Terrascan은 ArgoCD의 리소스 후크를 사용하여 응용 프로그램 사전 동기화 프로세스 중 Argo CD 작업으로 구성될 수 있습니다. 또한 Terrascan의 K8S admission 컨트롤러를 사용하여 사전 동기화 및 컨트롤러 웹훅과 함께 구성된 저장소를 스캔할 수 있습니다.\n\nTerrascan 문서 페이지에서 전체 통합 예시를 찾을 수 있습니다.\n\n## Terrascan 사용자 정의 정책\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTerrascan은 사용자가 Rego 쿼리 언어를 사용하여 쉽게 사용자 정의 정책을 만들 수 있도록 Open Policy Agent (OPA) 엔진을 활용합니다. 각 rego 정책에는 정책에 대한 메타데이터를 정의하는 JSON \"rule\" 파일이 포함되어 있습니다. Terrascan에 포함된 정책은 pkg/policies/opa/rego 디렉토리에 저장됩니다. rule.json 파일은 Rego 파일에서 정의된 사용자 정의 정책을 참조하는 구성 파일로, Terrascan 스캔 중에 어떤 정책이 적용되고 심각성 수준이 어떻게되는지를 제어할 수 있습니다. 사용자 정책 로직 및 규칙은 .rego 파일에 정의되며, rule.json 파일은 해당 정책을 적용하고 구성하는 방법을 지정합니다.\n\n아래 정책 예시는 Azure 리소스가 \"UK South\" 또는 \"UK West\"에만 있어야 한다는 것을 강제합니다. 다른 위치에서 리소스를 찾으면 Terrascan에서 보고됩니다.\n\nazure_region_policy.rego\n\n```js\npackage main\n\nimport input.tfplan as tfplan\n\ndefault allow = false\n\nallowed_regions = [\"UK South\", \"UK West\"]\n\n# 테라폼 계획의 모든 Azure 리소스를 반복합니다.\nazure_resources[resource_name] {\n    resource_name = input.tfplan.resource_changes[_].address\n    input.tfplan.resource_changes[_].type == \"azurerm_resource\"\n}\n\n# 각 Azure 리소스의 지역이 허용되었는지 확인합니다.\nallow {\n    resource_name\n    resource_config := input.tfplan.resource_changes[resource_name].change.after\n    resource_config.location == allowed_region\n    allowed_region = allowed_regions[_]\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 정책을 활성화하려면 rule.json 파일을 사용하여 Terrascan의 동작을 구성하고 스캔 중에 적용해야 할 정책을 지정합니다.\n\nrule.json\n\n```js\n{\n  \"rules\": {\n    \"azure_region_policy\": {\n      \"severity\": \"HIGH\",\n      \"message\": \"'UK South' 또는 'UK West' 지역에 Azure 리소스를 배포해야 합니다.\",\n      \"rules_file\": \"azure_region_policy.rego\"\n    }\n  }\n}\n```\n\n마지막으로 사용자 정책을 사용하여 스캔하려면 스캔하려는 디렉토리로 이동하고 -rules 플래그를 사용하여 json 파일 경로를 지정하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nterrascan scan -rules /path/to/rule.json\n```\n\n또한 Terrascan은 원하는 경우 정책을 준수하지 않으려면 해당 정책을 제외할 수도 있습니다. 예를 들어, 예시 1에서 구성한 Azure 리소스 그룹에 리소스 잠금을 사용하고 싶지 않다면 이 정책을 스캔에서 제외하여 이 문제로 표시되지 않게 할 수 있습니다. 이를 위해 -skip-rules 플래그를 사용하거나 특정 리소스에서 정책을 건너뛰는 파일 내부 기능을 사용합니다.\n\n## Terrascan 대 Checkov\n\n외관상으로 보면, Terrascan과 Checkov는 매우 유사합니다. 둘 다 IaC 보안 및 규정 준수 스캔을 위해 설계된 오픈 소스 정적 코드 분석 도구입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCheckov은 Terraform에 주로 초점을 맞추고 있지만, AWS SAM을 포함한 CloudFormation, Azure Resource Manager (ARM), Serverless framework, Helm 차트, K8S 및 Docker와 같은 여러 유형의 파일을 스캔할 수 있습니다. Checkov는 활발한 기여 및 DevSecOps 커뮤니티에서 강력한 존재감을 보이는 커뮤니티 주도 프로젝트입니다.\n\nCheckov는 Python을 사용하여 구축되었으며, Terrascan은 Go를 사용하며 Rego를 사용하여 사용자 정의 정책을 작성합니다. 사용자 정의 정책을 작성하는 데 Rego를 선호한다면 Terrascan은 좋은 선택입니다.\n\n## Terrascan vs tfsec\n\nTfsec는 또 다른 오픈 소스 정적 코드 분석 도구이며, 고려할 수 있는 주요 옵션 중 하나입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTerrascan과 달리 TFSec는 GO로 작성되었으며 사용자 정의 정책에는 Terrascan에서 사용되는 Rego 대신 YAML 정의를 사용합니다. K8S에 익숙한 사용자는 Rego 학습 대신 YAML을 사용하여 정책을 작성하는 것을 선호할 수 있습니다. 이는 TFSec를 선택하는 이유가 될 수 있습니다. 또한 커뮤니티에서 Checkov 및 Terrascan보다 가장 인기 있는 프로젝트이며 가장 많은 GitHub 스타를 가지고 있습니다.\n\n## 주요 포인트\n\nTerrascan은 IaC 템플릿 및 구성을 스캔하는 데 설계된 매우 유연하고 강력한 오픈 소스 정적 코드 분석 도구입니다. IaC 코드에서 보안 취약점, 준수 위반 및 최상의 실천 방법 문제를 식별하는 데 도움을 줍니다. 다양한 유형의 구성 파일과 함께 사용할 수 있으며 내장 정책을 제공하며 Rego를 사용하여 사용자 정의 정책을 사용할 수도 있습니다. CI/CD 시스템과 자동화 파이프라인에서 사용하는 것이 지원됩니다.\n\n여기에서 Terraform에 관한 다른 기사들도 확인해보세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환호! 🍻\n\n원래 spacelift.io에서 발행되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-WhatisTerrascan_0.png"},"coverImage":"/assets/img/2024-05-23-WhatisTerrascan_0.png","tag":["Tech"],"readingTime":14},{"title":"데브옵스DevOps란 무엇인가요","description":"","date":"2024-05-23 14:37","slug":"2024-05-23-WhatisDevOps","content":"\n## 시스템 엔지니어의 여정과 관점\n\n![이미지](/assets/img/2024-05-23-WhatisDevOps_0.png)\n\n# 소개\n\n데브옵스란 무엇일까요? 그 질문은 특정 IT 분야에 뛰어들기 전에 스스로에게 묻고 진정한 의미를 이해하기 전까지 기억하는 질문이었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 멜버른, 호주에서 열린 VMware 사용자 회의에 참석했던 때를 떠올립니다. 여러 다른 VMware 애호가들과 함께 있었는데, VMware 및 협력사들이 개발 중인 흥미로운 제품들에 대해 더 알아보기 위해 열정적으로 참석했었습니다. 발표를 하는 신사의 이름은 KevOps로 매우 재미있는 이름이었다고 기억해요.\n\n당시 시스템 엔지니어로서, 저는 데브옵스를 다음 단계로 여겼습니다. 상위 수준에서는 저에게 코드와 관련된 부분이라는 것은 알고 있었지만, 그 본질 자체가 이해되지 않아 솔직히 겁이 났어요. 처음으로 데브옵스를 이해할 때, 강력한 개발자여야 하고 높은 수준의 코딩 경험이 필요하다는 것을 이해했어요. 하지만 이것은 제가 잘하지 않았고 이 간극을 메우는 것은 불가능하다고 생각했어요. 하지만 더 깊이 파고들수록 더 많은 것을 발견하게 되었고, 결국은 저 스스로가 오르기 어려운 산처럼 보이던 그 직무까지 수행하고 있는 자신을 발견했습니다.\n\n# 데브옵스의 간략한 역사\n\n데브옵스가 무엇인지 알아가기 전에, 과거로 돌아가서 문제 상황을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2007년 경, 개발 및 운영 팀이 산업 전반에 걸쳐 함께 일하는 방식에 문제가 있습니다. 서로 분리되어 있고 서로의 다음 목표가 일치하지 않는 경우가 많습니다. 개발자들은 운영팀이 서버를 관리해야 하는 많은 경쟁 우선 순위로 인해 배포를 제때에 할 수 없습니다. 이 모델로는 누구도 이길 수 없는 상황입니다.\n\n여기에서 DevOps 용어가 만들어지고, 제가 소개할 때 이 운동이 가속화되기 시작했습니다. 저의 겸손한 의견으로는 IT 산업의 일부 분야를 혁신적으로 변화시키기 위해 필요한 문제 해결을 단호히 요청하는 움직임입니다.\n\n# 그러면, DevOps란 무엇일까요?\n\n우선, DevOps는 한 문장이나 진술로 설명할 수 없습니다. 사실, 이것은 여러 요소나 측면을 갖고 있는 것입니다. 어떤 렌즈를 통해 보느냐에 따라 달라지는 정의가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDevOps를 설명하는 것은 다음과 같을 수 있어요:\n\n- 문화\n- 프레임워크\n- 기술적 방법론\n- 엔지니어 유형\n\n각각의 요소는 관점과 전문성에 따라 정의될 수 있어요. 이는 Agile이나 ITIL과 유사한데, 이러한 주제에 대한 이해는 당신의 역할과 책임에 따라 정말 중요해질 거예요.\n\n집과 같이, DevOps는 강력한 기초 위에 구축되어 구조를 구현하고 마무리를 지어나갈 거예요. 아래 다이어그램은 DevOps가 문화적 수준에서 시작하여 기술을 살아 숨쉬게 만들어가는 과정을 도와줍니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-WhatisDevOps_1.png)\n\n# 데브옵스란 문화\n\n현재 GenAI가 핫한 주제인 가운데, ChatGPT 또는 Gemini와 같은 대형 언어 모델(Large Language Models, LLM)에 대해 익숙할 것입니다. ChatGPT에게 데브옵스란 무엇인지 물어보면 대략 이와 같은 답을 얻을 수 있습니다:\n\n이 정의는 데브옵스의 문화적 측면을 잘 요약한 것입니다. 데브옵스는 개발팀과 운영팀 간의 장벽을 허물고 상호 유익한 관계를 구축하기 위해 함께 뭉치는 것을 목표로 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDevOps가 추구하는 문화 중 일부 맨트는 다음과 같습니다:\n\n- 수동 및 번거로운 작업을 없애겠습니다.\n- 자동화를 촉진하여 효율성과 민첩성을 높이겠습니다.\n- 일관성을 위해 반복 가능한 패턴을 사용하겠습니다.\n- 능력과 숙련도를 향상시키기 위해 협력을 촉진하겠습니다.\n- 우리는 복잡함 대신 단숨함을 향한 태도로 새로운 도전에 대응하고 적응할 것입니다.\n\nDevOps 모델을 준수하는 문화의 예를 살펴보겠습니다.\n\n## DevOps 모델을 준수하지 않는 경우\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n운영팀:\n\n- 소프트웨어 업데이트 설치와 같은 작업은 수동으로 처리됩니다.\n- 반복 작업이 자동화되지 않습니다.\n- 새로운 인프라 요청은 수동으로 처리됩니다.\n- 소유 애플리케이션을 위한 개발자 코드는 수동으로 배포됩니다.\n- 월간 주기 내에 작업을 완료하는 것에 대한 경쟁 우선순위가 있습니다.\n- 작업은 선형적인 프로세스를 따르지 않으며 인간 에러의 영향을 받습니다.\n\n개발팀:\n\n- 운영팀에 크게 의존하므로 소유 애플리케이션 배포에 상당한 지연이 있습니다.\n- 일부 배포를 적시에 테스트할 수 없습니다.\n- 인프라에 대한 이해가 없거나, 있더라도 인프라에 액세스할 수 없습니다.\n- 운영팀으로부터의 번거로운 피드백 루프로 배포 문제를 강조합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nDevOps가 해결하는 것을 정말로 이해하려면 어떤 나쁜 환경이 무엇인지 이해해야 합니다. 난 이상한 걸 말했나? 오늘도 이런 일이 발생하고 있고 DevOps를 도입해도 모든 문제가 해결되는 것은 아닙니다. 그러나 위의 예에서 보면 타임라인과 배달 속도에 많은 도움이 될 것입니다.\n\n## DevOps 모델을 따른다\n\nDevOps 팀:\n\n- 인프라, 코드, 자동화 및 빌드 기술 간의 다양한 기술을 보유하고 있습니다.\n- 문제를 검토하고 자동화를 통해 최선의 해결 방법을 한 번 찾은 후, 향후에도 그 자동화를 의존하여 자가 치유 및 수정합니다.\n- 환경에 도입되는 변경 사항에 대해 패턴 기반 접근 방식을 사용하는 엄격한 프로세스를 따릅니다.\n- 가능한 한 많은 수동 작업을 사용하지 않습니다.\n- 변경 사항이 작고 점진적입니다.\n- 피드백 루프가 강하며 팀원과의 관계를 구축하는 데 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 두 예시를 옆에 놓을 때, 개선 사항이 분명합니다. 이러한 사고 방식에 노출되었을 때, 여러분은 진정으로 데브옵스에서 무엇을 얻을 수 있는지 그 가치를 온전히 이해하게 됩니다.\n\n데브옵스가 전혀 적용되지 않은 예시에서, 주요 키워드는 명확해야 합니다. 데브옵스의 본질은 가능한 만큼 많은 일을 자동화하는 것입니다. 그렇지만 모든 것을 자동화할 수는 없다는 점을 명심해야 합니다. 데브옵스는 여정입니다. 즉, 데브옵스 방법을 사용할 준비가 된 환경과 그렇지 않은 환경 사이에 명확한 구분을 가져야 합니다.\n\n데브옵스로의 전환을 위해 가장 중요한 요소는 문화입니다. 우리는 이를 받아들이고 온전히 수용해야 합니다. 문화가 없으면 우리는 단일한 토대나 공동의 기반을 갖지 못합니다. 데브옵스는 협업에 관한 것이며 개인이 성공하는 것이 아니라 팀이 성공하는 것임을 이해하는 것입니다. 약속을 견고하게 지키는 것이 무엇을 뜻하며, 데브옵스가 무엇을 의미하며 그 방법론이 우리에게 보여줄 수 있는 것에 대해 말하는 속담을 들어보셨을 것입니다.\n\n문화에 동의한 후, 나머지는 바닥 규칙이 마련된 후에 쉽게 자리에 맞게 되는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# DevOps 프레임워크\n\nDevOps를 프레임워크로 살펴볼 때, 우리는 더 많은 업무 방식을 고려합니다. 이는 다음을 포함합니다:\n\n- 팀에게 DevOps가 의미하는 것은 무엇인가요?\n- 이해해야 할 DevOps의 하위 개념은 무엇인가요?\n- 우리 팀의 모든 사람이 성공을 위해 어떻게 설정되었는지 확인하는 방법은 무엇인가요?\n\n이것들은 우리가 스스로 묻는 많은 다른 질문들 중 일부입니다. 이 프레임워크는 우리가 성공을 달성하고 현저한 혜택을 얻으면서 의미 있는 결과물을 제공하는 방식을 정의할 수 있도록 해줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오랜만에 만나서 반가워요!\n\n데브옵스의 각 측면이 전문성을 갖고 있는 내용을 간단히 살펴보겠습니다:\n\n![DevOps Expertise](/assets/img/2024-05-23-WhatisDevOps_2.png)\n\n이것은 데브옵스 프레임워크 내에서 흔히 사용되는 일부 주요 개념을 샘플링한 것입니다. 물론 다른 것도 있지만, 여기서는 주요 개념을 단순히 설명하는 데에 초점을 맞추고 있습니다. 문화로서의 데브옵스 섹션과 마찬가지로 서로 유익한 전문분야를 식별하기 시작할 수 있을 겁니다.\n\n본질적으로, 데브옵스는 이러한 다양한 전문분야를 결합하여 인프라 솔루션 및 애플리케이션을 배포하고 관리하며 유지보수하기 위한 목적을 달성하려는 프레임워크입니다. 이를 이루는 방법은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- SCM(소프트웨어 구성 관리) 및 CI/CD(지속적 통합/지속적 배포) 프로세스를 결합하여 인프라 기반 솔루션을 빌드하고 배포합니다. 보통 이를 GitOps 모델이라고 합니다.\n- 정기적으로 반복되는 수동 작업을 자동화합니다.\n- 수요에 따라 확장할 수 있는 용량이 탄탄하고 오류 허용이 가능한 무상태 아키텍처 개념을 활용합니다.\n- 애플리케이션 변경에 반응하는 이벤트-주도 아키텍처를 생성합니다.\n- 애자일성과 빠른 전달 속도를 향상시키기 위해 잘 알려진 패턴을 재사용합니다.\n\n# 기술적 접근으로서의 DevOps\n\nDevOps의 기술 세부 정보 및 기술 요소로 진입하기 전에, 직접 경험한 현실 시나리오를 한번 살펴보고 싶습니다.\n\n2017년 특정 환경에서, DevOps에서 언급된 것과 유사한 수동 작업을 수행했던 기억이 나네요. DevOps 모델을 따르지 않았던 윈도우 중심의 환경이었고, 가상 환경으로 VMware를 사용했습니다. 서버는 SCCM을 사용하여 수동으로 패치되었습니다. 이 프로세스는 다음과 같았습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 운영팀 구성원이 목록에서 서버를 손에 든다.\n- 관리 액세스를 사용하여 해당 서버에 로그인한다.\n- SCCM 클라이언트를 시작한다.\n- 업데이트를 설치한다.\n- 다시 부팅한다.\n\n특히 해당 방식으로 패치해야 하는 여러 서버가 있는 경우에는 번거로운 프로세스였습니다. 이 모든 것의 귀하의 유일한 상처는? 이것이 월간 행사였다는 사실입니다.\n\n이 예제는 DevOps가 개발 운영 측면에서 존재하기 전의 생활을 보여줍니다. 이는 환경을 유지하고 “불을 켜 있는” 과제 중 하나로써 정기적으로 수행되어야 하는 많은 작업 중 하나이기도 합니다. DevOps가 제공할 수 있는 가치를 실감하게 되면, 정기적으로 수동 작업을 수행하는 것은 시간의 대조적인 투자 수익이 매우 적은 것처럼 느껴집니다.\n\n기술적 접근 방법으로서의 DevOps에 관한 것은, 이제 다양한 작업 및 동작을 수행하는 데 사용되는 실제 도구에 대해 깊게 들어가 시작합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 익숙할지도 모르는 몇 가지 개념과 각각의 응용 프로그램 목록입니다:\n\n![이미지](/assets/img/2024-05-23-WhatisDevOps_3.png)\n\n이것은 그림을 보여주기 위한 목록 샘플만을 제시한 것입니다.\n\n이 도구들의 조합을 사용하여 환경을 운영하면, 플랫폼과 관련된 솔루션(대규모/확장된 환경에서 플랫폼을 지원)이나 특정 응용 프로그램을 구축할 수 있습니다. 이 다이어그램은 이러한 개념과 응용 프로그램을 실제 시나리오에 어떻게 적용할 수 있는지 보여줍니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-23-WhatisDevOps_4.png)\n\n**포인트 1 - 코드는 GitHub에 저장됩니다**\n\n이를 통해 우리는:\n\n- 전체 팀이 사용할 일관된 진실의 원천을 적절히 유지할 수 있습니다.\n- 코드베이스의 버전을 생성하여 개발, 테스트, 프로덕션 등 다양한 환경으로 단계적이고 제어된 배포를 할 수 있습니다.\n- 동료들로부터 제안된 변경 사항을 코드베이스에 도입하려고 하는 경우 동료들의 리뷰 및 승인 프로세스를 거치도록 합니다.\n- 자동 배포를 위해 Buildkite와 통합합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제 2점 — Terraform을 사용한 IaC\n\nTerraform은 AWS에서 자원을 생성/대체/업데이트/삭제(CRUD)하는 데 사용됩니다. Github 및 Buildkite와 함께 Terraform을 사용하여 GitOps 모델을 구현함으로써 배포를 처리할 수 있습니다. 이는 다음을 보장합니다:\n\n- 자원이 일관된 방식으로 배포됩니다.\n- 빌드카이트만을 통해 Terraform을 사용하여 배포를 수행할 수 있도록 하여 이 프로세스에서 벗어나지 않습니다.\n- 코드를 반복적으로 사용하여 매번 처음부터 작업하는 대신 개선만 하여 사용하는 DRY(Don’t Repeat Yourself) 모델을 촉진할 수 있습니다.\n\n제 3점 — CI/CD를 위한 Buildkite 사용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBuildkite는 검증, 계획 및 배포를 수행하는 CI/CD 플랫폼으로 사용됩니다. Buildkite는 일관성을 유지하기 위해 GitHub를 소스로 사용할 것입니다.\n\n4번 항목 — 배포 전 코드 검증 (CI/CD의 CI)\n\n검증 및 계획 파이프라인이 배포 전에 실행되어 우리가 무엇을 기대해야 하는지 알 수 있습니다.\n\n또한 이 단계를 강화하고 개발 환경에서 모의 배포를 수행할 수도 있습니다. 이렇게 하면 예기치 못한 문제가 도드라지며 접근 방식을 재고하고 조정해야 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n점 5 — Pull request 동료 리뷰\n\n충분한 증거가 축적되면 동료에게 우리의 pull request를 검토해 달라고 요청할 수 있으며, 모든 게 제대로 된 경우 병합을 진행할 수 있습니다.\n\n협업이 최고이며, DevOps의 문화 측면에서 언급된 대로 동료의 의견을 듣고 항상 배울 수 있고 조정할 수 있는 방법이 항상 있습니다.\n\n점 6 — Pull request 병합 및 배포 (CI/CD의 CD 부분)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 pull request가 승인되고 병합되면, 자동화가 실행되어 리소스가 배포됩니다.\n\nGitOps 모델을 활용함으로써, 각 단계는 통제되며 비교적 예측 가능한 작업이어야 합니다. 이 모델을 계속 사용하여 환경에 변경 사항을 계속 적용할 수 있습니다.\n\nDevOps는 당신이 가진 도구를 통해 쉽게 삶을 만드는 방법을 찾는 것입니다.\n\n# 엔지니어로서의 DevOps\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 레이어가 편하게 마련된 상태에서, 우리는 DevOps 하우스의 정상인 곳에 위치하게 되었습니다. DevOps 엔지니어들에게는 하위 레이어들이 강력한 기반을 제공하여 우리가 필요한 작업을 수행하고 전체 모델을 완성하는 데 도움이 됩니다.\n\n그러나 다소 상반된 방식으로, DevOps 엔지니어로 레이블이 지어지는 것이 산업 전반에 깔끔하게 부합되지는 않습니다. 예를 들어, 온프레미스 환경에 DevOps 모델을 적용하는 것에는 문제가 없습니다. 많은 개념적 도구들이 온프레미스 동등물을 갖고 있습니다. 또한 그렇지 않더라도 SaaS(Software as a Service) 기반 제공품을 사용하여 온프레미스 환경에서 배포를 수행할 수 있습니다.\n\n이 분야에서는 대부분 DevOps가 공용 클라우드에만 해당한다고 전체적으로 가정되어 왔지만, 그렇지 않습니다. DevOps 모델이 공용 클라우드에 편안하게 적용되지만, 온프레미스 환경에 적용할 수 있는 에지 케이스 시나리오들도 여전히 있습니다. 이것이 이 섹션의 요지로 이어지면서 누군가를 DevOps 엔지니어로 정의하기가 어렵다는 것을 알 수 있습니다.\n\n기술적 접근 방식 섹션에서는 IaC 및 CI/CD와 같은 개념을 다루었습니다. 이러한 개념을 기반으로 하는 도구들은 산업 전반에서 다양한 형태로 나타날 것입니다. 이는 이러한 개념을 기반으로 하는 (어떤 면에서) 도구의 수가 매우 많기 때문입니다. 예를 들어, 회사 A의 DevOps 엔지니어로는 GitHub (SCM), GitHub Actions (CI/CD) 및 Terraform (IaC) 도구를 사용할 수 있지만, 회사 B의 DevOps 엔지니어로는 BitBucket (SCM), Bamboo (CI/CD) 및 CloudFormation (AWS의 IaC)을 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공학 수준의 DevOps는 산업 전반에 걸쳐 일관성이 없다는 것을 설명하고 있습니다. 개인적으로, 몇 가지 환경을 경험해 보았는데, 이러한 환경은 DevOps 모델을 활용하지만 정확히 같은 도구를 사용하는 환경은 없습니다. 유사점이 많지만, 완전히 동일한 것은 아닙니다.\n\n또 다른 좋은 예로는 DevOps 모델을 공개 클라우드 공간에 적용할 때를 들 수 있습니다. 비슷한 개념을 가지고 있지만 사용하는 용어 및 개념 적용 방식에서 다소 차이가 있습니다.\n\n이로 인해 누군가를 DevOps 엔지니어로 규정하는 것이 어렵습니다. 실제로, DevOps 엔지니어 역할을 볼 때, 해당 회사와 해당 환경에 대한 역할일 것입니다. 여러 클라우드 및 여러 다른 기술 스택에 대해 이야기할 때 플랫폼 엔지니어가 관련될 수 있다는 주장도 나올 수 있습니다. 그럼에도 불구하고, DevOps 엔지니어라는 용어는 계속 사용되고, 이와 관련된 일정 수준의 모호성이 예상된다는 가정이 있습니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떠한 에셋을 가져오거나 동적으로 추가할 때 table 태그를 Markdown 형식으로 변경하세요.\n","ogImage":{"url":"/assets/img/2024-05-23-WhatisDevOps_0.png"},"coverImage":"/assets/img/2024-05-23-WhatisDevOps_0.png","tag":["Tech"],"readingTime":14},{"title":"AWS CDK이 Terraform보다 뛰어난가요","description":"","date":"2024-05-23 14:35","slug":"2024-05-23-IsAWSCDKbetterthanTerraform","content":"\n이 기사에서는 클라우드 인프라를 유지하는 데 AWS CDK를 사용하는 장점과 이해를 돕기 위한 코드 스니펫에 대해 설명하겠습니다.\n\n![AWS CDK vs Terraform](/assets/img/2024-05-23-IsAWSCDKbetterthanTerraform_0.png)\n\n저는 AWS 클라우드 엔지니어로 일하고 있으며, AWS 환경 내에서 내 프로젝트의 클라우드 인프라를 관리하는 역할을 맡고 있습니다. 이 역할에서 저는 Terraform과 AWS CDK를 모두 활용해 왔습니다. 제 경험과 인사이트를 바탕으로, 각각의 우세한 점에 대해 제 생각을 공유하겠습니다.\n\n그러나 그에 앞서, IaC를 이해해 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# IaC(Infrastructure as Code)이란 무엇인가요?\n\nIaC 또는 Infrastructure as Code는 클라우드 인프라가 코드를 통해 프로비저닝되고 관리되는 소프트웨어 엔지니어링 방법론입니다. 이는 AWS 콘솔과 같은 수동 프로세스나 대화형 구성 도구를 통해 관리하는 것이 아니라 코드를 통해 인프라를 구축하는 방식을 의미합니다.\n\n간단히 말해, 콘솔을 통해 수동으로 생성하는 대신 인프라를 배포할 코드를 작성하는 것입니다. 이는 산업의 표준적인 실천 방법입니다. 현재 클라우드 인프라에 IaC를 적용하지 않는 조직은 없다고 생각해요.\n\nIaC를 적용하는 주요 이유는 재사용성, 일관성, 자동화 및 확장성입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Terraform과 AWS CDK를 이해해 봅시다.\n\n## Terraform\n\nTerraform은 HashiCorp가 개발한 IaC 도구입니다. Terraform을 사용하면, 인프라 구성은 도메인 특화 언어인 HashiCorp 구성 언어 (HCL)를 사용하여 코드로 정의되어 버전 관리, 협업 및 자동화가 가능해집니다. Terraform은 그런 다양한 자원들의 전체 라이프사이클을 관리하며, 프로비저닝부터 업데이트, 파괴까지 정의된 설정 파일을 기반으로 합니다.\n\nS3 버킷을 생성하는 Terraform 스크립트의 간단한 예제입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# main.tf\n\nprovider \"aws\" {\n  region = \"us-east-1\"  # 원하는 AWS 지역을 설정하세요\n}\n\nresource \"aws_s3_bucket\" \"my_bucket\" {\n  bucket = \"my-unique-bucket-name\"  # 원하는 버킷 이름을 설정하세요 (전역적으로 고유해야 함)\n}\n```\n\n# AWS CDK\n\nAWS CDK(Cloud Development Kit)는 AWS가 개발한 오픈소스 프로젝트로, 클라우드 리소스를 프로비저닝하기 위한 더 높은 수준의 추상화를 제공합니다.\n\nAWS CDK를 사용하면 Typescript, Python, Java, Go 등과 같은 익숙한 프로그래밍 언어를 사용하여 인프라 코드를 작성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS CDK를 사용하여 Typescript로 S3 버킷을 만드는 간단한 예제입니다.\n\n```typescript\nimport * as cdk from \"aws-cdk-lib\";\nimport { Stack, StackProps } from \"aws-cdk-lib\";\nimport * as s3 from \"aws-cdk-lib/aws-s3\";\n\nexport class MyS3BucketStack extends Stack {\n  constructor(scope: cdk.Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    // S3 버킷 생성\n    new s3.Bucket(this, \"MyBucket\", {\n      bucketName: \"my-unique-bucket-name\", // 원하는 버킷 이름으로 변경하세요\n    });\n  }\n}\n\n// 애플리케이션 생성\nconst app = new cdk.App();\nnew MyS3BucketStack(app, \"MyS3BucketStack\");\n```\n\n이제 Terraform 대 AWS CDK 논쟁에 대해 깊게 알아보겠습니다.\n\n# Terraform vs AWS CDK\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그것말고는 실제로 표 스타일이 아니라지만, 저희가 그 내용을 잘 이해할 수 있도록 글의 형식으로 바꿔 드릴게요.\n\n한 가지씩 살펴보며 이 도구들의 차이를 이해해 보겠습니다. 몇 가지 예시를 들어 몇 가지 포인트를 검증하겠습니다. 비교를 더 잘 이해하기 위해 마지막 부분만 주목해주세요.\n\n## 지원\n\nTerraform은 클라우드에 중립적입니다. 즉, AWS, Azure, GCP, Alibaba 등 여러 클라우드 제공업체를 지원합니다.\n\nAWS CDK는 AWS 팀이 특히 AWS 클라우드용으로 만들었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 다양한 클라우드 공급업체에서 작업 중이라면, Terraform이 최상의 선택일 것입니다. 몇몇 클라우드 공급업체는 자체 IaC 도구인 Azure의 Bicep과 같은 것들이 있지만, 아직 채택 초기 단계에 있습니다.\n\n## 언어\n\n이전에 언급했듯이, Terraform은 Hashicorp에서 특별히 만든 HCL(HashiCorp Configuration Language)을 사용합니다. HCL은 JSON과 유사한 구성 언어로, 배우기 쉽습니다.\n\nAWS CDK는 Typescript, Python, Java 등과 같은 일반 목적 프로그래밍 언어를 지원합니다. 따라서 새로운 언어를 배울 필요가 없습니다. 익숙한 프로그래밍 언어를 선택하고 IaC 작성을 시작할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로그래밍 언어는 견고하고 유연합니다. IaC에서 OOPS, 함수형 프로그래밍과 같은 다양한 프로그래밍 패러다임을 사용할 수 있어요. 이는 DSL(Domain Specific language)보다 많은 장점을 가지고 있어요.\n\n## 상태 관리\n\n테라폼은 terraform.tfstate 파일을 사용해 배포된 리소스의 상태를 저장해요. 이 파일은 인프라의 현재 상태와 배포된 리소스 및 구성을 추적합니다. 일반적으로 이 상태 파일은 중앙에 저장되며, 종종 S3 버킷에 저장되어 다양한 팀 간의 협업을 용이하게 합니다.\n\n제 경험 상으로, 테라폼 상태를 관리하는 것이 꽤 복잡할 수 있다는 것을 알았어요. 프로젝트 내에서 상태의 드리프트를 마주치는 것이 일반적이며, 이를 해결하는 데 시간이 많이 소요될 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS CDK는 상태가 없는 방식으로 작동합니다. 상태를 관리하기 위해 Git과 같은 버전 관리 시스템을 신뢰합니다. 배포할 때마다 최신 변경 사항을 가져와서 발생하는 모든 충돌을 해결하고 배포를 진행합니다. 이 방식은 깔끔하며 일관성을 유지합니다.\n\n## 버전 관리\n\n우리는 AWS가 계속해서 서비스를 확장하고 있다는 것에 익숙합니다. Terraform은 실행 파일로서 매번 최신 버전을 다운로드하고 업데이트해야 하므로 인프라 코드 업데이트가 어려운 작업이 됩니다. 우리 조직의 많은 프로젝트들은 여전히 오래된 버전에 의존하여 유지보수에 어려움을 겪고 있습니다.\n\n그에 반해 AWS CDK는 AWS가 직접 유지하고 있기 때문에 의존성을 간단히 관리하여 신속한 업데이트를 제공합니다. 이를 통해 시간이 지남에 따라 부드러운 전환과 더 적은 호환성 문제를 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 연결성\n\n이해하기 위해, 바로 예제로 들어가 봅시다.\n\n예를 들어, S3 버킷에 객체가 생성될 때마다 람다를 트리거해야 하는 시나리오를 생각해 봅시다. 이를 위해 S3 이벤트 알림과 람다를 결합하여 이를 달성할 수 있습니다.\n\n아래 테라폼 코드를 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\nresource \"aws_s3_bucket\" \"my_bucket\" {\n  bucket = \"my-bucket\"\n  acl    = \"private\"\n}\n\nresource \"aws_lambda_function\" \"my_function\" {\n  filename      = \"lambda_function_payload.zip\"\n  function_name = \"my-function\"\n  role          = aws_iam_role.lambda_exec_role.arn\n  handler       = \"index.handler\"\n  runtime       = \"nodejs14.x\"\n}\n\nresource \"aws_lambda_permission\" \"s3_invoke_permission\" {\n  statement_id  = \"AllowExecutionFromS3Bucket\"\n  action        = \"lambda:InvokeFunction\"\n  function_name = aws_lambda_function.my_function.function_name\n  principal     = \"s3.amazonaws.com\"\n  source_arn    = aws_s3_bucket_notification.s3_notification.arn\n}\n\nresource \"aws_s3_bucket_notification\" \"s3_notification\" {\n  bucket = aws_s3_bucket.my_bucket.id\n\n  lambda_function {\n    lambda_function_arn = aws_lambda_function.my_function.arn\n    events              = [\"s3:ObjectCreated:*\"]\n  }\n}\n```\n\nTerraform에서 모든 것을 리소스로 취급하는 개념을 따라갑니다. 먼저 Lambda 및 S3 버킷과 같은 리소스를 정의합니다. 그런 다음 Lambda 함수와 S3 객체 간의 연결을 설정하기 위해 권한을 부여해야 합니다. 이는 aws_lambda_permission 리소스를 사용하여 달성됩니다. 권한이 부여된 후 Lambda 함수와 S3 알림을 연결하는 데 또 다른 리소스인 aws_s3_bucket_notification이 필요합니다.\n\n이제 CDK 코드를 살펴봅시다.\n\n```typescript\nimport { aws_lambda_nodejs as lambda_nodejs } from \"aws-cdk-lib\";\nimport { aws_s3 as s3 } from \"aws-cdk-lib\";\nimport { aws_s3_notifications as s3notifications } from \"aws-cdk-lib\";\nimport { App, Stack, StackProps } from \"aws-cdk-lib\";\nimport { Construct } from \"constructs\";\n\nexport class MyStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    // S3 버킷 생성\n    const bucket = new s3.Bucket(this, \"MyBucket\");\n\n    // Lambda 함수 생성\n    const fn = new lambda_nodejs.NodejsFunction(this, \"MyFunction\", {\n      runtime: lambda_nodejs.Runtime.NODEJS_14_X,\n      handler: \"handler\",\n      entry: \"lambda/index.ts\",\n    });\n\n    // S3 버킷에 대한 이벤트 소스 추가하여 Lambda 함수를 트리거합니다\n    fn.addEventSource(\n      new s3notifications.S3EventSource(bucket, {\n        events: [s3.EventType.OBJECT_CREATED],\n        filters: [{ prefix: \"uploads/\" }], // 필요에 따라 접두사 조정\n      })\n    );\n  }\n}\n\nconst app = new App();\nnew MyStack(app, \"MyStack\");\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드에서는 먼저 S3 버킷을 생성한 다음 람다 함수를 생성합니다. 람다 함수 코드 자체 안에서 S3를 이벤트 소스로 생성할 수 있음을 알 수 있습니다. 이것은 멋지며 프로그래밍의 힘을 보여줍니다.\n\n위의 코드는 모든 것을 Terraform의 리소스 블록을 사용하는 것보다 훨씬 이해하기 쉽습니다.\n\n## 보안\n\nAWS 내에서 보안을 논의할 때 IAM(Identity and Access Management)이 중심에 있습니다. IAM 역할과 정책은 사용자 액세스를 관리하고 서비스 간 안전한 통신을 용이하게 하는 데 사용되는 중요한 구성 요소입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테라폼 코드에서는 aws_lambda_permission 리소스 블록을 사용하여 S3이 람다를 호출할 수 있도록 필요한 권한을 부여했습니다. 그러나 CDK 코드에서는 그런 작업을 하지 않았습니다. CDK가 IAM 권한을 내부적으로 설정하기 때문입니다. CDK는 필요한 권한만 부여하여 더 안전합니다.\n\n다른 예시를 살펴봅시다. 람다 함수가 DynamoDB 테이블에 데이터를 추가하는 경우를 생각해보겠습니다. 인프라 개발자로서 우리는 람다가 어떻게 작동하는지 신경 쓸 필요가 없습니다. 우리는 람다와 DDB 테이블을 생성하고 람다가 DynamoDB에 데이터를 쓸 수 있는 권한을 부여하기만 하면 됩니다.\n\n먼저 CDK 코드를 살펴보겠습니다.\n\n```js\nimport * as cdk from \"aws-cdk-lib\";\nimport { Construct } from \"constructs\";\nimport * as lambda from \"aws-cdk-lib/aws-lambda\";\nimport * as dynamodb from \"aws-cdk-lib/aws-dynamodb\";\n\nexport class MyStack extends cdk.Stack {\n  constructor(scope: Construct, id: string, props?: cdk.StackProps) {\n    super(scope, id, props);\n\n    // DynamoDB 테이블 생성\n    const table = new dynamodb.Table(this, \"MyTable\", {\n      partitionKey: { name: \"id\", type: dynamodb.AttributeType.STRING },\n      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,\n    });\n\n    // 람다 함수 생성\n    const myLambda = new lambda.Function(this, \"MyLambda\", {\n      code: lambda.Code.fromAsset(\"path/to/your/lambda/code\"), // 필요한 경우 경로를 조정\n      handler: \"index.handler\",\n      runtime: lambda.Runtime.NODEJS_14_X,\n    });\n\n    // 람다 함수에 DynamoDB 테이블 쓰기 권한 부여\n    table.grantReadWriteData(myLambda);\n  }\n}\n\nconst app = new cdk.App();\nnew MyStack(app, \"MyStack\");\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마음에 드실 정도로 간결하고 깔끔한 코드입니다. 우리는 ddb 테이블과 람다를 생성했습니다. 그 다음으로는 ddb 테이블의 grantReadWriteData 메서드를 사용하여 해당 람다를 전달했습니다. 이것으로 모든 필요한 IAM 권한을 처리합니다.\n\n이제 Terraform에서 같은 코드를 살펴보겠습니다.\n\n```js\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\nresource \"aws_dynamodb_table\" \"my_table\" {\n  name           = \"MyTable\"\n  billing_mode   = \"PAY_PER_REQUEST\"\n  hash_key       = \"id\"\n\n  attribute {\n    name = \"id\"\n    type = \"S\"\n  }\n}\n\nresource \"aws_iam_role\" \"lambda_execution_role\" {\n  name = \"lambda_execution_role\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = \"sts:AssumeRole\"\n        Effect = \"Allow\"\n        Principal = {\n          Service = \"lambda.amazonaws.com\"\n        }\n      },\n    ]\n  })\n}\n\nresource \"aws_iam_policy\" \"ddb_access_policy\" {\n  name        = \"ddb_access_policy\"\n  description = \"람다가 DynamoDB 테이블에 액세스할 수 있는 정책\"\n\n  policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [\n      {\n        Action = [\n          \"dynamodb:PutItem\",\n          \"dynamodb:UpdateItem\",\n          \"dynamodb:GetItem\",\n          \"dynamodb:Scan\",\n          \"dynamodb:Query\",\n          \"dynamodb:DeleteItem\"\n        ]\n        Effect   = \"Allow\"\n        Resource = aws_dynamodb_table.my_table.arn\n      },\n    ]\n  })\n}\n\nresource \"aws_iam_role_policy_attachment\" \"ddb_access_attachment\" {\n  role       = aws_iam_role.lambda_execution_role.name\n  policy_arn = aws_iam_policy.ddb_access_policy.arn\n}\n\nresource \"aws_lambda_function\" \"my_lambda\" {\n  function_name = \"MyLambdaFunction\"\n\n  filename         = \"이동/전달/패키지.zip의/경로\"\n  source_code_hash = filebase64sha256(\"이동/전달/패키지.zip의/경로\")\n  handler          = \"index.handler\"\n  runtime          = \"nodejs14.x\"\n  role             = aws_iam_role.lambda_execution_role.arn\n}\n```\n\n이 코드가 얼마나 지루한지 보이실 것입니다. 먼저 ddb 테이블을 생성하고, 그런 다음 람다 역할을 만듭니다. 이후 필요한 권한을 지정하는 정책을 만들고 해당 역할에 첨부합니다. 마지막으로 람다를 만들고 이 역할을 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드는 너무 길고 정책 문서에서 수동으로 권한을 지정하고 있습니다. 이렇게 하면 올바른 권한을 지정하지 않으면 액세스 문제가 발생할 수 있습니다.\n\n## 통합\n\nAWS CDK는 AWS SDK와 강력한 통합을 가지고 있습니다. 더 잘 이해하기 위해 람다 함수를 예로 들어봅시다.\n\nAWS 람다가 리눅스를 지원하고 있으며 Amd 및 Arm 기반의 두 가지 CPU 아키텍처만 지원한다는 점을 알고 있습니다. 또한 AWS는 파이썬, Node.js, Go 등 다양한 런타임을 지원합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 만약 람다 함수가 ARM 기반과 파이썬 런타임을 사용하고 개발자가 Windows 기계에서 작업 중이라면, 그는 OS에서 번들을 생성할 수 없을 것입니다. Lambda 런타임과 호환되지 않을 것입니다. 이 문제는 ARM 기반 리눅스 이미지를 사용하여 코드를 빌드하는 파이프라인을 사용하면 해결할 수 있습니다.\n\nCDK에서는 코드를 쉽게 Lambda에 배포할 수 있습니다. AWS CDK는 다른 런타임에 대해 다른 함수를 제공합니다.\n\n```js\n@aws-cdk/aws-lambda-python-alpha » PythonFunction\naws-cdk-lib » aws_lambda_nodejs » NodejsFunction\n@aws-cdk/aws-lambda-go-alpha » GoFunction\n```\n\n패키지를 사용하면 람다 함수의 소스 코드를 가리킬 수 있고 코드를 번들로 만들 필요가 없습니다. 번들링 옵션을 직접 선택할 수 있습니다. Node.js의 경우 esbuild, 다른 런타임의 경우 docker가 좋은 선택지입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nprivate createGetData(): PythonFunction {\n    const fn = new PythonFunction(this, \"GetData\", {\n      entry: join(__dirname, \"..\", \"src\", \"get-data\"),\n      runtime: lambda.Runtime.PYTHON_3_11,\n      bundling: {\n        assetExcludes: [\".venv\"],\n        assetHashType: AssetHashType.SOURCE\n      },\n      timeout: Duration.minutes(2),\n      index: \"lambda_handler.py\",\n      handler: \"lambda_handler\",\n      memorySize: 128\n    });\n    return fn;\n  }\n```\n\n위의 코드에서는 람다 코드 위치를 entry 매개변수에만 지정했습니다. 런타임이 파이썬이기 때문에 lambda_handler.py 및 requirements.txt 두 파일만 필요합니다.\n\n이 작업은 Terraform에서 수행할 수 없습니다.\n\n참고: AWS에서 풀 스택 개발을 수행 중이거나 AWS SDK 및 동시에 AWS 인프라 생성에 작업 중인 경우에 매우 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마지막으로\n\n내 의견으로는, AWS CDK는 논의된 요소를 기반으로 Terraform을 능가한다고 생각합니다. 그러나 이것은 프로젝트와 조직의 특정 요구 사항에 따라 달라질 수 있는 주관적인 의견으로 인식합니다. 고유한 요구 사항과 상황에 기반하여 적합한 인프라스트럭처를 코드로 관리하는 도구(IaC)를 평가하고 선택하는 것이 중요합니다.\n\n# 내 프로젝트\n\n저는 Candletower(www.candletower.com)라는 프로젝트를 만들었습니다. 이 웹사이트는 캔들스틱 패턴 분석을 기반으로 한 주식 시장 분석을 제공합니다. 투자를 하거나 주식 시장에 입문하려는 경우, 이 웹사이트를 꼭 확인해보세요. 광고 없음, 로그인 없음, 완전 무료입니다. 여러분의 생각을 알려주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-23-IsAWSCDKbetterthanTerraform_0.png"},"coverImage":"/assets/img/2024-05-23-IsAWSCDKbetterthanTerraform_0.png","tag":["Tech"],"readingTime":17}],"page":"70","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}