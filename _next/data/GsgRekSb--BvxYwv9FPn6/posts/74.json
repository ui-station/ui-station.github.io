{"pageProps":{"posts":[{"title":"분산 애플리케이션에서 캐싱 마스터하기","description":"","date":"2024-05-23 13:23","slug":"2024-05-23-MasteringCachinginDistributedApplications","content":"\n![마스터링 분산 애플리케이션의 캐싱](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png)\n\n소프트웨어 시스템의 캐싱 구현에서 버그를 만날 때마다 1달러가 있다면... 아마도 Redis Enterprise의 연간 기업 구독 비용을 지불할만큼의 돈이 쌓였을 것입니다.\n\n캐싱은 거의 올바르게 할 수 있지만, 결코 완벽하게 할 수 없는 것처럼 보입니다. 그것에는 좋은 이유가 있습니다. 결국 - 캐싱(또는 캐시 무효화)은 컴퓨터 과학에서 가장 어려운 두 가지 기본 문제 중 하나로 간주됩니다. 다른 하나는 변수의 명명이겠지요.\n\n농담인지 아니든 - 캐싱을 제대로 이해하는 것은 정말 어렵습니다 - 특히 대규모 분산 애플리케이션에서. 결과적으로 팀은 종종 캐싱 전략과 구현을 조정하기 위한 반복과 실험 과정을 거치며 - 마침내, 어느 정도 합리적이고 반최적적인 상태로 이르기를 희망하며.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글에서는 종종 간과되거나 오해되는 캐싱에 대한 몇 가지 측면을 명확하게 하고자 합니다.\n\n이 글을 읽은 후에는 캐싱이 무엇인지, 캐싱의 주요 접근 방식, 주의해야 할 사항 및 다양한 캐싱 기술을 실제 사용 사례에 어떻게 적용하는지에 대해 더 명확한 이해를 가지게 될 것입니다.\n\n그러니 더 이상 미루지 말고....\n\n# 캐싱이란?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n캐싱은 간략히 말해서 데이터를 임시 저장하는 동작으로, 데이터를 원본 저장소(기록 시스템)에서 검색하는 것보다 더 저렴하거나 빠르거나 최적화된 방법으로 검색할 수 있는 임시 매체에 데이터를 저장하는 것을 말합니다.\n\n다른 말로 하면, 다음과 같은 사용 사례를 상상해보세요.\n\n주문 관리 시스템이 재고 시스템에서 제품 정보를 검색해야 하는 상황입니다. 재고 시스템이 그다지 효율적이지 않다고 가정해보겠습니다. 요청이 들어올 때마다 제품 정보를 가져오기 위해 중앙 데이터베이스로 이동해야 합니다. 이 데이터베이스는 느리며 너무 많은 병렬 요청을 처리할 수 없습니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n성능을 향상시키고 재고 데이터베이스에 가해지는 부담을 완화하기 위해 캐싱 레이어를 도입했습니다. 이제 동일한 제품 정보를 저장하는 캐시가 추가되었습니다. 이제 버거운 데이터베이스를 거치지 않고 먼저 캐시에 접근하며, 캐시에 데이터가 있다면 그곳에서 가져옵니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_2.png)\n\n여기서 한 일은 성능을 향상시키고 원본 재고 데이터베이스의 자원 사용을 최적화하기 위해 임시 저장 매체(캐시)를 도입한 것입니다.\n\n# “캐시”란 무엇을 의미할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사람들이 혼동하기 시작하는 지점 중 하나는 캐시의 기술적 성격에 대해입니다.\n\n소프트웨어 개발 분야에 종사하는 대다수의 사람들은 \"캐시\"라는 용어를 들었을 때 매우 구체적인 연상을 갖게 됩니다. 종종 이 용어를 Redis, Memcached 또는 EHCache와 같은 분산 캐시 제품과 연관시킵니다. 때로는 브라우저 캐시, 데이터베이스 캐싱, OS 캐싱 또는 하드웨어 캐싱을 떠올리기도 합니다.\n\n이것이 바로 핵심입니다. 캐시의 개념은 컴퓨터 과학 분야 내의 특정 제품이나 영역으로 제한되지 않습니다. \"캐싱\"은 널리 생각되는 바에 따르면, 우리가 어떤 레코드 시스템으로부터 데이터를 복제하는 임시 매체의 어떤 형태라도 될 수 있습니다. 그렇게 하는 이유는 그 데이터를 임시 매체에 저장하는 것이 한 방이나 다른 방식으로 유리하기 때문입니다.\n\n이는 일반적으로 비용 절감, 성능 향상 또는 원본 저장소보다 더 나은 확장성 때문에 그렇습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전 주문 관리 및 재고 시스템의 예제를 살펴보면 캐싱 레이어는 이론상 여러 가지로 구성될 수 있습니다:\n\n- 분산 캐싱 제품(예: Redis)\n- 자체 데이터베이스를 갖춘 다른 마이크로서비스\n- 실제 재고 관리 시스템 내부의 인메모리 저장소\n\n위의 모든 것은 서로 다른 구현이지만 각각 캐시의 조건을 충족할 것입니다.\n\n간단히 말하면 위에 언급된 모든 것들이 캐시가 될 수 있습니다. 컴퓨터 시스템 스택의 모든 수준과 다양한 디지털 도메인에서 캐싱이 구현될 수 있다는 개념으로, 직접 적용될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 용어정의\n\n계속하기 전에 캐싱 주제 주변의 다양한 용어를 이해하는 것이 중요합니다.\n\n- **시스템 레코드(System of Record):** 데이터가 저장되는 영구 저장소입니다. 대부분 데이터베이스일 가능성이 높습니다. 참 값 시스템(source-of-truth system)이라고도 합니다.\n\n- **캐시 미스(Cache Miss):** 응용프로그램이 캐시를 쿼리하지만 해당 레코드가 캐시에 존재하지 않을 때 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로 고침된 데이터: 캐시에 있는 레코드가 기본 시스템과 얼마나 동기화되어 있는지를 나타냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n캐시 만료: 캐시 레코드를 에백션 프로세스의 일부로 또는 캐시 무효화의 일부로 시간 기반으로 제거하는 것을 의미합니다.\n\n이제 우리 모두가 캐싱 용어에 완전히 익숙해졌으니, 캐시가 구현될 수 있는 몇 가지 장소와 계층에 대해 살펴보겠습니다.\n\n# 캐싱은 어디에 구현되나요?\n\n이미 언급했듯이, 캐싱은 기술 영역 전반에 걸쳐 사용되며, 모든 수준 및 다양한 기술 스택 내에서 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하드웨어 수준에서 캐싱은 CPU 아키텍처의 일부로 사용되며, 예를 들어 레벨 1-3 (L1/L2/L3) 캐시 형식으로 사용됩니다.\n\n운영 체제 커널 수준에서는 페이지 캐시라고 알려진 디스크 캐시 형식이 있습니다. 다른 형태도 있습니다.\n\n웹 기반 시스템에서는 물론 브라우저 캐시와 CDN(Content Delivery Networks)가 있습니다. 이 캐시는 일반적으로 정적 리소스(이미지, 스타일시트 등)를 사용자에게 빠르고 효율적으로 제공하고 대역폭을 줄이는 데 사용됩니다.\n\n다양한 종류의 응용 프로그램 및 미들웨어에도 자체 캐시가 있습니다. 예를 들어, 데이터베이스는 자주 사용되는 쿼리 및 자주 반환되는 결과 집합을 저장하기 위해 캐싱을 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, Redis, EHCache, Memcached, Hazelcast, Infinispan 등과 같은 많은 견고한 소프트웨어 캐싱 제품이 존재합니다. 이 제품들은 분산 애플리케이션 내에서 확장 가능한 분산 캐싱을 가능하게 합니다.\n\n이제 강조할 한 가지는 \"분산\" 캐시 개념이 \"로컬\" 또는 \"지역화된\" 캐시와 대조될 수 있다는 점입니다. 분산 캐시는 네트워크 상에서 여러 기기에 분산된 캐시 형태입니다. 로컬 캐시는 한 기기에만 존재합니다.\n\n이 두 개념 간의 차이를 이해하는 가장 좋은 방법은 클러스터 서버에 배포된 애플리케이션을 상상해보는 것입니다. 다시 말해, 동시에 여러 애플리케이션 인스턴스가 실행되는 것이 큰 규모 애플리케이션 개발자에게 익숙한 상황일 것입니다.\n\n이러한 시스템에 분산 캐시를 도입한다면, 어떤 애플리케이션 인스턴스에서든 해당 캐시에 접근하고 레코드를 수정할 수 있게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 한편으로, 로컬 캐시가 있다면 각 인스턴스마다 자체 캐시가 있을 것입니다. 그 캐시는 대부분 해당 인스턴스의 메모리 내에 위치할 것입니다. 서로 다른 인스턴스들은 다른 인스턴스의 캐시에 접근할 수 없을 것입니다. 그들은 자신들의 캐시에만 접근할 수 있을 것입니다.\n\n이러한 두 가지 접근 방식에는 장단점이 있습니다.\n\n한편으로, 여러 인스턴스가 캐시에 접근하는 경우 - 동기화 문제, 경쟁 조건, 데이터 손상 및 분산 애플리케이션에서 발생하는 기타 도전 과제를 해결해야 할 수도 있습니다. 다른 한편으로, 공유 캐시는 강력한 개념입니다. 왜냐하면 그것으로 가능했던 사용 사례를 처리할 수 있게 해줍니다. 로컬, 더 단순한 캐시로는 불가능했던 것들도 처리할 수 있게 해주기 때문입니다.\n\n예를 들어, 여러 가용 영역 내에서 클라우드 환경에 애플리케이션을 배포할 수 있습니다. 각 가용 영역은 애플리케이션을 실행하는 VM 인스턴스 클러스터를 가질 것입니다. 이러한 클러스터는 아마도 각각 자체 분산 캐시를 가질 것입니다. 분산 캐시의 전제조건 중 하나는 그것에 빠르고 효과적으로 액세스할 수 있어야 한다는 것입니다. 이는 캐시의 인스턴스에 서비스하는 네트워크 근접성(물리적일 필요는 없지만 가상적일 수도 있음)을 가지는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동시에 분산 및 로컬 캐싱에 공통적으로 발생하는 몇 가지 도전 과제가 있습니다.\n\n주요 도전 과제는 데이터 신선도 유지, 최적의 캐시 무효화 및 제거, 그리고 캐시 관리 방식을 특정 사용 사례에 잘 맞추는 것 사이의 꾸준한 균형입니다.\n\n캐시 관리 — 캐싱 패턴은 다음에 다룰 중요한 개념입니다.\n\n소프트웨어 엔지니어링에서의 대부분의 결정과 마찬가지로, 각 접근 방식에는 각자의 절충안(또는 다른 말로 장단점)이 있습니다. 아래에서 각 접근 방식의 장단점을 다룰 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n캐싱은 소프트웨어 엔지니어와 소프트웨어 아키텍트 모두가 이해해야 하는 중요한 개념입니다. 그러나 이것이 유일한 개념이라고는 할 수 없습니다.\n\n내 안내서 — 소프트웨어 아키텍트의 경력을 여는 법, 에서는 시니어 이상의 소프트웨어 엔지니어 및 소프트웨어/솔루션 아키텍트가 숙달해야 할 다른 개념, 기술 및 기술을 설명합니다.\n\n여기에서 확인하세요\n\n![마스터링 분산 애플리케이션에서의 캐싱 이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 로컬 및 분산 캐싱 시스템의 패턴\n\n캐싱 시스템에는 다섯 가지 주요 캐싱 패턴이 있으며, 이들은 캐시가 데이터를 읽고 쓰는 방식 및 기본 시스템과 동기화하는 방식과 관련이 있습니다.\n\n# 캐시 옆에\n\n캐시 옆에 캐싱 전략은 아마도 가장 인기 있는 전략이며 대부분의 소프트웨어 엔지니어가 익숙한 전략입니다. 이 캐싱 접근 방식은 애플리케이션에 캐시 쓰기 및 읽기 제어를 완전히 맡깁니다. 여기서 애플리케이션은 데이터베이스 또는 캐시에서 읽을 때와 쓸 때를 모두 제어합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 그것이 작동하는 방법에 대한 예시입니다.\n\n당신의 애플리케이션이 사용자의 로그인 요청을 받고, 결과적으로 사용자의 우편 주소를 가져오게 된다고 상상해보세요.\n\n- 애플리케이션은 먼저 사용자의 주소가 캐시 내에 존재하는지 확인합니다.\n- 만약 해당 사용자의 주소 항목이 없다면, 애플리케이션은 데이터를 데이터베이스에서 가져옵니다.\n- 그러나 캐시 내에서 정보가 존재한다면, 해당 데이터는 즉시 검색되어 데이터베이스로의 여행을 절약합니다.\n- 새로운 정보를 가져온 후, 애플리케이션은 해당 데이터를 캐시에 기록합니다.\n\n2단계에서, 특정 아이템을 위한 캐시에 항목이 없다면 — 이것은 \"캐시 미스\"로 자주 언급됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_4.png)\n\n## 장점\n\n- 구현이 간단합니다.\n- 제어권은 애플리케이션에 완전히 남습니다.\n- 필요할 때만 캐시된 항목을 가져오므로 (게으른 로딩), 최소한의 메모리를 사용합니다. (이론적으로는)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### Write-Through Caching\n\n- 캐시 미스 발생 시 더 느린 저장소에서 데이터를 가져와야 하므로 지연 시간이 높아집니다. 캐시 미스가 많아지면 성능에 영향을 줄 수 있습니다.\n- 애플리케이션 로직이 더 복잡해집니다 (전반적인 아이디어는 구현하기 쉽지만요).\n\n### 사용 시기\n\n- 캐시가 어떻게 채워지는지에 대한 완전한 제어를 원할 때.\n- 데이터베이스 읽기/쓰기를 관리할 수 있는 캐싱 제품이 없을 때.\n- 캐시에 대한 액세스 패턴이 불규칙할 때.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nWrite-Through 캐싱은 캐시와 기본 영속 데이터 저장소 사이의 일관성을 보장합니다. 다시 말해, 쓰기가 발생할 때 캐시와 데이터베이스 양쪽으로 동시에 전파됩니다.\n\n다음은 예시입니다:\n\n- 재무 애플리케이션이 사용자 계정을 새로운 잔액으로 업데이트하는 요청을 받습니다.\n- 사용자 계정 잔액은 데이터베이스와 캐시 둘 다에 존재합니다.\n- 데이터베이스와 캐시가 동일한 트랜잭션 내에서 새 값으로 업데이트됩니다.\n- 다른 요청이 발생하면, 이번에는 사용자의 잔액을 읽는 요청이 옵니다. 먼저 캐시에서 값을 찾아 사용합니다. 캐시가 가장 최신 값을 가지고 있기 때문에 기본 데이터베이스와 동기화되지 않을까 걱정할 필요가 없습니다.\n\n참고로 3단계는 애플리케이션 로직을 통해 수행할 수 있습니다. 그러나 실제 캐싱 제품에서는 해당 역할을 하게 됩니다. 예를 들어 EHCache나 Infinispan을 사용하는 경우 애플리케이션은 Redis 캐시를 업데이트하고, 다시 데이터베이스를 업데이트할 수 있도록 구성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 코드가 Markdown 형식으로 변경된 것입니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_5.png)\n\n# 장점\n\n- 캐시와 기본 데이터 저장소 사이의 일관성을 보장합니다.\n\n# 단점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 트랜잭션 복잡성은 이제 캐시와 데이터베이스 업데이트 모두를 보장하기 위해 어떤 종류의 2단계 커밋 로직이 필요합니다 (캐시에 의해 제어되지 않는 한)\n- 운영상의 복잡성, 위의 어느 하나가 실패하면 사용자 경험을 세련되게 처리해야 합니다.\n- 쓰기가 더 느려집니다. 왜냐하면 이제 두 군데 (캐시 및 데이터 저장소)를 업데이트해야 하기 때문에 데이터 저장소에 하나만 업데이트할 때보다 더 많은 시간이 걸리게 됩니다.\n\n# 사용 시기\n\nStrong data consistency를 필요로 하고 퇴보된 데이터를 제공할 여유가 없는 애플리케이션에 적합합니다. 데이터가 작성된 직후 즉시 정확하고 최신 상태여야 하는 환경에서 흔히 사용됩니다.\n\n# Write-Around Caching\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 전략은 기본 저장소를 채우지만 캐시 자체는 채우지 않습니다. 다시 말해, 이 쓰기는 캐시를 우회하고 기본 저장소에만 쓰입니다. 이 기술과 Cache-Aside 기술 간에는 일부 중첩이 있습니다.\n\n차이점은 Cache-Aside에서 읽기와 지연로딩에 초점을 맞추는 반면, Write-Around 캐싱에서는 쓰기 성능에 초점을 맞추는 것입니다. 이 기술은 자주 데이터를 쓰지만 드물게 읽을 때 캐시 오염을 피하기 위해 종종 사용됩니다.\n\n<img src=\"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_6.png\" />\n\n# 장점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 캐시 오염이 줄어듭니다. 이는 모든 쓰기 작업에서 캐시가 채워지지 않기 때문입니다.\n\n## 단점\n\n- 일부 레코드가 자주 읽히고 캐시에 사전으로 로드되어 첫 번째 히트 시 데이터베이스로의 전송을 방지해야 하는 경우 성능이 저하됩니다.\n\n## 언제 사용해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 양의 쓰기 작업이 이루어지지만 읽기 작업은 상대적으로 적을 때 자주 사용됩니다.\n\n# Write-Back (Write-Behind) 캐싱\n\n쓰기 작업이 먼저 캐시를 채우고 데이터 저장소에 기록됩니다. 이곳의 핵심은 데이터 저장소에 쓰기가 비동기적으로 발생한다는 점입니다. 그러므로 이러한 경우 두 단계 트랜잭션 커밋이 필요 없어집니다.\n\n쓰기 지연 캐싱 전략은 보통 캐싱 제품에서 처리됩니다. 캐싱 제품이 이러한 메커니즘을 갖고 있다면, 응용 프로그램은 캐시에 쓰기를 하고, 캐싱 제품은 변경 사항을 데이터베이스로 전송하는 책임이 있습니다. 만약 캐시 제품에서 이를 지원하지 않는다면, 응용 프로그램 자체가 데이터베이스로 비동기적인 업데이트를 트리거할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_7.png)\n\n## 장점\n\n- 초기 트랜잭션 내에서 캐시에만 쓰기 작업이 발생하므로 쓰기 속도가 빨라집니다. 데이터베이스는 나중에 업데이트됩니다.\n- 흐름을 캐싱 제품이 처리하면 애플리케이션 로직이 덜 복잡해집니다.\n\n## 단점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 데이터베이스와 캐시가 새로운 변경 사항을 수신하게 될 때까지 둘 사이에 불일치 가능성이 있습니다.\n- 캐시가 최종적으로 데이터베이스를 업데이트하려고 할 때 오류가 발생할 위험이 있습니다. 이 경우 데이터베이스가 가장 최신 데이터를 수신하도록 보장하기 위해 더 복잡한 메커니즘이 필요할 수 있습니다.\n\n# 사용 시기\n\n쓰기 퍼포먼스가 중요하고 데이터베이스의 데이터가 캐시와 잠시 동안 약간 동기화되어 있어도 괜찮을 때 쓰기 지연 캐싱을 사용할 수 있습니다. 높은 쓰기 부하를 처리해야 하지만 일관성 요구사항이 덜 엄격한 애플리케이션에서 적합합니다. 이 방법이 사용될 수 있는 한 예는 캐시된 콘텐츠를 빠르게 업데이트한 다음 레코드 시스템에 동기화하는 CDNs(콘텐츠 전송 네트워크)입니다.\n\n# 읽기 - 스루\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n캐시 생성 방식은 일반적으로 캐시 옆에 두어 캐시 미스 발생 시 데이터베이스로부터 데이터를 가져온후 캐시에 저장하는 것에 유사합니다. 그러나 캐시 생성 방식은 애플리케이션에게 캐시와 데이터베이스를 모두 질의하는 책임을 맡기는 반면, 읽기-스루는 해당 메카니즘을 가지고 있을 경우 해당 제품에게 질의하는 방식입니다.\n\n![이미지](/assets/img/2024-05-23-MasteringCachinginDistributedApplications_8.png)\n\n# 장점\n\n- 간편함 — 모든 로직이 캐싱 애플리케이션에 캡슐화되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단점\n\n- 캐시 미스 발생 시 데이터베이스에서 데이터를 읽을 때 잠재적인 지연이 발생할 수 있습니다. 데이터 업데이트를 위한 복잡한 무효화 메커니즘이 필요합니다.\n\n# 사용 시기\n\n리드-스루 캐싱은 데이터에 접근하는 코드를 간소화하고자 할 때 사용됩니다. 또한, 캐시가 항상 데이터 저장소의 가장 최근 데이터를 포함하도록 보장하고 싶을 때 사용됩니다. 쓰기보다 읽기가 더 자주 발생하는 애플리케이션에 유용합니다. 그러나 여기서 중요한 점은 캐싱 제품이 구성 또는 기본 시스템에서 이러한 읽기를 수행할 수 있는 능력을 가져야 한다는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 캐싱 전략 요약\n\n다섯 가지 캐싱 패턴에 대해 이야기한 내용을 아래에서 요약했습니다.\n\n## 캐시 옆에 캐싱\n\n애플리케이션이 캐시에서 데이터를 찾지 못하고 요청할 때만 요청에 따라 데이터가 캐시로 로드됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 예시: 온디맨드로 제품 세부 정보를 캐싱하는 전자 상거래 웹사이트.\n\n데이터베이스 작업 책임: 응용 프로그램\n\n## 쓰기-스루\n\n일괄 쓰기 작업은 일괄 캐시 및 기본 데이터 저장소에 동시에 작성되어 일관성을 유지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 예시: 거래마다 일관된 계좌 잔액을 유지하기 위한 은행 시스템\n\nDB 작업 책임: 캐싱 제품 또는 애플리케이션\n\n## Write-Behind (Write-Back)\n\n쓰기 작업은 먼저 캐시에 기록되고 나중에 데이터 저장소에 비동기적으로 기록됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 예시: CDN이 먼저 캐시에 콘텐츠를 업데이트하고 나중에 스토리지 시스템에 동기화하는 방식입니다.\n\nDB 작업 책임: 제품 또는 애플리케이션 캐싱\n\n## 라이트-어라운드\n\n쓰기 작업은 캐시를 우회하고 데이터 저장소를 직접 업데이트하여 즉시 필요하지 않은 데이터를 캐싱하는 것을 피합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 예시: 로그 작업에 대한 어디에서 캐싱없이 직접 스토리지로 기록합니다.\n\n데이터베이스 작업 책임: 애플리케이션\n\n## Read-Through\n\n캐시는 읽기를 위한 주요 인터페이스 역할을 합니다. 캐시에 데이터가 없으면 시스템에서 해당 데이터를 가져와 캐시에 저장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n실제 예시: 사용자 프로필 서비스가 캐시 미스 상황에서 사용자 데이터를 가져오고 캐싱하는 경우.\n\nDB 작업 책임: 제품 또는 응용 프로그램 캐싱\n\n## 캐시 무효화\n\n이제 우리는 캐시를 채우는 다양한 방법을 이해했으니, 기록 시스템과 동기화하여 유지하는 방법도 이해해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n캐시 무효화에 관한 두 가지 주요 접근 방식은 시간 기반 방식과 이벤트 기반 방식입니다. 무효화를 위한 시간 기반 접근 방식은 대부분의 캐싱 제품에서 제공되는 TTL(Time-To-Live) 설정으로 제어할 수 있습니다. 이벤트 기반 접근 방식은 응용 프로그램이나 다른 요소가 새 레코드를 캐시로 전송해야 합니다.\n\n데이터 캐시에 대한 중요한 점은 거의 항상 기본 데이터 저장소(시스템 기록)와 어느 정도 동기화되어 있지만 매우 빨리 구식이 된다는 것입니다. 다시 말해 — 구식 상태가 됩니다. 캐시를 가능한 한 시스템 기록과 동기화된 상태로 유지하기 위해 캐시 무효화 전략을 구현해야 합니다.\n\n다시 말해, 캐시 내에서 데이터 \"신선도\"를 보장해야 합니다.\n\n캐시 무효화는 새 레코드가 시스템 기록으로부터 검색되어 캐시로 입력되는 현상을 유발합니다. 따라서 캐시 무효화와 위에서 논의한 캐싱 전략 사이의 관계를 이해하는 것이 매우 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n캐싱 전략은 데이터가 캐시에서 로드되고 검색되는 방식과 관련이 있습니다. 반면에 캐시 무효화는 시스템 레코드와 캐시 간 데이터 일관성과 신선도와 더 관련이 있습니다.\n\n따라서 이 두 가지 개념 사이에는 약간의 중첩이 있으며 일부 캐싱 전략에서는 무효화가 다른 것보다 간단할 수 있습니다. 예를 들어 캐시-쓰기 쓰기 방식의 경우 캐시가 모든 쓰기마다 업데이트되므로 추가 구현이 필요하지 않습니다. 하지만 삭제는 반영되지 않을 수 있기 때문에 명시적으로 이를 다루는 응용 프로그램 논리가 필요할 수 있습니다.\n\n캐싱 엔트리를 무효화하는 두 가지 방법이 있습니다:\n\n## 이벤트-드리븐\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이벤트 기반 접근 방식을 사용하면 응용 프로그램이 기록의 기반 저장소에서 변경이 발생할 때마다 캐시를 알립니다. 레코드가 변경될 때마다 동기적 또는 비동기적으로 캐시에 알림을 트리거합니다.\n\n이 작업은 응용 프로그램을 통해 수행할 수 있으며, 코드가 캐시를 최신 상태로 유지하는 것에 책임이 있습니다. 또는 일부 캐싱 제품에서는 퍼브/섭 기능이 제공될 수 있으며, 캐싱 제품이 이러한 유형의 알림에 가입할 수 있습니다. 그 경우 응용 프로그램에서 할 작업이 덜 할 수 있지만, 여전히 이러한 알림 이벤트를 생성해야 합니다.\n\n## 시간 기반\n\n시간 기반 접근 방식을 사용하면 모든 캐시 레코드에 TTL(임시 소멸 시간)이 지정됩니다. 레코드의 TTL이 만료되면 해당 캐시 레코드가 삭제됩니다. 이것은 일반적으로 캐싱 제품에 의해 제어됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 캐시 축출 전략\n\n캐시 축출은 기존 캐시 레코드를 제거하는 캐시 무효화와 유사합니다. 그러나 캐시 축출은 캐시가 가득 차서 더 이상 레코드를 수용할 수 없는 경우에 필요합니다.\n\n기억하세요, 캐시의 목적은 가장 자주 액세스되는 레코드의 부분 집합을 저장하는 것입니다. 전체 진실의 원본 시스템을 복제하는 것이 아닙니다. 따라서 캐시의 크기는 일반적으로 데이터베이스 / 진실의 원본 / 기록 시스템에 저장된 데이터의 크기보다 훨씬 작을 것입니다.\n\n따라서 레코드를 \"축출\" 또는 다른 말로 삭제할 수 있는 메커니즘이 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n동시에 캐시의 존재 이유를 완전히 무의미하게 만들지 않기 위해 애플리케이션이 제일 필요하지 않을 것으로 생각되는 레코드부터 시작해야 합니다.\n\n최적으로 레코드를 제거하는 방법을 보장하기 위해 사용할 수 있는 몇 가지 퇴직 전략이 있습니다:\n\n## Least Recently Used (LRU)\n\n이 접근 방식을 통해, 얼마 동안 사용되지 않은 레코드를 제거합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 시기: 데이터가 마지막으로 액세스된 후 시간이 경과함에 따라 데이터가 곧 액세스될 가능성이 줄어드는 시나리오에서 효과적입니다. 미래 액세스의 강력한 지표인 액세스 최근성을 고려하는 일반적인 캐싱에 적합합니다.\n\n사용하지 말아야 할 때: 데이터 액세스 패턴이 최근성과 관련이 없는 워크로드에는 이상적이지 않습니다.\n\n## 먼저 들어온 것이 먼저 나간다 (FIFO)\n\n다른 레코드보다 이전에 캐시에 저장된 레코드를 제거합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용할 때: 데이터의 나이가 액세스 빈도나 최근성보다 중요한 캐시에 유용합니다. 예측 가능한 수명을 가진 데이터를 캐싱하는 데 적합합니다.\n\n사용하지 않을 때: 이전 데이터가 여전히 빈번하게 액세스되는 워크로드에는 최적이 아닙니다.\n\n## 최소 사용 빈도 순서 (LFU)\n\n빈번하게 사용되지 않거나 액세스되지 않는 레코드를 삭제합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 시기: 오랜 기간 동안 자주 액세스되는 데이터를 보관해야 하는 상황에 가장 적합합니다. 안정된 액세스 패턴을 갖는 애플리케이션에 적합합니다.\n\n사용하지 말아야 하는 경우: 액세스 패턴이 크게 변할 수 있는 환경에서는 효과가 떨어집니다. 자주 액세스되지 않는 항목들이 캐시를 오염시킬 수 있습니다.\n\n## Time To Live (TTL)\n\n미리 결정된 Time-To-Leave 기간에 따라 퇴거합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 시기: 특정 기간 이후에 만료되거나 변하지 않는 데이터에 이상적입니다.\n\n사용하지 말아야 할 때: 유효성이 시간이 지나면 자연스럽게 종료되지 않고 다른 요인에 따라 캐시에 영원히 남아있어야 하는 데이터에 적합하지 않습니다.\n\n## 무작위 치환\n\n기록을 무작위로 대체합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 시점: 고급 추적 메커니즘의 비용이 혜택을 상쇄하는 상황이거나 액세스 패턴이 예측할 수 없어 다른 제거 전략이 적합하지 않은 경우에 사용할 수 있습니다.\n\n사용하지 않는 시점: 대체로 다른 전략에 비해 대부분 예측 가능한 액세스 패턴이 있는 실제 시나리오에서는 효율이 떨어질 수 있습니다.\n\n# 요약\n\n분산 응용 프로그램에서 캐싱의 중요성과 올바른 캐싱 전략을 선택하는 중요성에 대해 이야기했습니다. 일반적으로 사용되는 여러 전략이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 캐시 오프 (Cache-aside)\n- 쓰기-스루 캐시 (Write-through cache)\n- 읽기-스루 캐시 (Read-through cache)\n- 쓰기 배후 캐시 (Write-behind cache)\n- 쓰기 주변 캐시 (Write Around)\n\n우리는 또한 시간 기반 또는 이벤트 기반 접근 방식을 사용하여 캐시 무효화에 대해 이야기했습니다.\n\n캐시 제거의 중요성과 어떤 전략이 그 일을 수행하는지에 대해 주목했습니다. 이것들은 다음과 같습니다:\n\n- LRU\n- FIFO\n- LFU\n- TTL\n- 임의(Random)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 캐시는 로컬 또는 분산 형태일 수 있습니다. 전자는 단일 기계/응용프로그램 인스턴스에 한정되어 있습니다. 후자는 여러 기계에 걸쳐 확장되며 일반적으로 (필수는 아니지만) 인스턴스 클러스터에 한정되어 있습니다.\n\n많은 혁신이 시장에서 발생하고 있는 캐시 제품과 관련된 기술들과 유행에 대해 몇 가지 명확한 정보를 제공했기를 바랍니다. 왜 캐싱이 중요한지, 그리고 캐싱 기술을 다룰 때 이해해야 하는 모든 다른 용어와 미묘한 점에 대한 직관력을 향상시켜주길 바랍니다.\n\n# 캐싱: 미래\n\n다른 기술들과 마찬가지로 캐싱 제품이 시장에서 엄청난 혁신이 일어나고 있습니다. 일부 주목할만한 하이라이트는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 에지 컴퓨팅과 통합\n\n에지 컴퓨팅이 계속해서 성장함에 따라, 캐싱 전략은 더 분산화되어 데이터를 네트워크 가장자리에 필요한 위치에 더 가까이 이동시킵니다. 이 근접성은 레이턴시, 대역폭 및 데이터 제공 비용을 줄입니다. 이는 IoT 및 모바일 앱과 같은 실시간 응용 프로그램에 매우 중요합니다.\n\n예시: 자율 주행 차량은 에지 컴퓨팅을 사용하여 실시간 데이터를 로컬에서 처리합니다. 지도 및 교통 상황과 같은 핵심 데이터를 에지 노드에서 캐싱하면 중앙 서버를 쿼리하는 레이턴시 없이 신속한 의사결정을 할 수 있습니다.\n\n# AI와 머신 러닝 기반 캐싱\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAI와 머신 러닝은 데이터 사용 패턴을 예측하고 예상된 필요에 따라 미리 데이터를 캐싱함으로써 캐싱 메커니즘을 향상시킬 수 있습니다. 이러한 예방적인 접근 방식은 효율성을 크게 향상시킬 수 있습니다. 특히 데이터 액세스 패턴이 자주 변경되는 동적 환경에서는 더욱 그렇습니다.\n\n예시: 아마존은 머신 러닝을 사용하여 사용자 행동을 예측하고 블랙 프라이데이와 같은 피크 타임에 사용자가 구매할 가능성이 높은 제품을 미리 캐싱합니다. 이는 로드 시간을 줄이면서 사용자 경험을 향상시킵니다.\n\n# 인메모리 데이터 그리드 (IMDG)\n\nIMDG는 분산 시스템 전반에 걸쳐 저지연 복잡한 데이터 액세스를 제공하는 캐싱의 강력한 솔루션이자 빠르게 발전하고 있습니다. IMDG는 데이터를 캐싱뿐만 아니라 캐시 레이어 내에서 다양한 데이터 처리 기능, 실시간 분석 및 의사 결정 기능을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: 고주파 트레이딩 플랫폼은 IMDG를 활용하여 시장 데이터와 거래 주문을 메모리에 캐시합니다. 이를 통해 서브초 단위 거래 결정을 내리는 데 필수적인 빠른 액세스와 처리가 가능해집니다.\n\n안녕하세요, 저는 야코프입니다. CloudWay Digital Inc을 운영하고 있는 소프트웨어 아키텍처 컨설팅 기관인 Developer.Coach에서 소프트웨어 엔지니어와 아키텍트들이 경력을 향상시키는 데 도와드리고 있습니다.\n\n제 Medium 무료 기사 외에도, 소프트웨어 엔지니어링 전문가들의 경력 향상에 도움이 되는 가이드 몇 편을 작성했습니다. 아래 링크를 통해 확인해보세요:\n\n👉 소프트웨어 아키텍트의 경력 잠금 해제\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n👉 소프트웨어 아키텍트 인터뷰 마스터하기\n\n👉 소프트웨어 엔지니어링 경력 잠금 해제: 중급에서 시니어로\n\n원본 게시물: 2024년 5월 17일, https://www.cloudwaydigital.com 에서 게시됨.\n","ogImage":{"url":"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png"},"coverImage":"/assets/img/2024-05-23-MasteringCachinginDistributedApplications_0.png","tag":["Tech"],"readingTime":28},{"title":"AI-강화 주제 탐구로 예술 창작을 재정의하기","description":"","date":"2024-05-23 13:21","slug":"2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration","content":"\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png)\n\n기술의 끊임없는 발전 속에서 AI는 계속해서 한계를 넓히고 가능성을 재정의합니다.\n\nAsycd에서는 스스로에게 이렇게 물었습니다: AI를 활용하여 예술적인 과정을 혁신할 수 있는 방법은 무엇일까요? 이 질문은 TEV1 – 테마틱 익스플로러 V1의 탄생으로 이어졌습니다. 그러나 TEV1의 변화의 힘에 대해 들어가기 전에, 그 탄생 배경과 갖추고 있는 탁월한 기능들을 탐험해보겠습니다.\n\n# 왜 우리가 TEV1을 만들었는가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![TEV1 Image 1](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_1.png)\n\nTEV1의 시작은 예술적 창작 프로세스를 단순화하고 향상시키는 욕망에서 비롯되었습니다. 우리는 작가, 작가 및 크리에이터들이 종종 자신의 비전과 일치하는 주제를 개념화하고 시각물을 생성하는 데 상당한 시간을 소비한다는 것을 인지했습니다. 우리의 목표는 이러한 시간과 노력을 줄이고, 창작자들이 핵심 창작 작업에 더 집중할 수 있는 도구를 디자인하는 것이었습니다.\n\n게다가, 특히 DALL-E 3 및 GPT-4o와 같은 도구를 통한 인공 지능의 발전으로 고품질의 특정 주제 이미지를 생성하는 잠재력이 실행 가능하고 매력적해졌습니다. TEV1은 이러한 잠재력을 활용하기 위한 우리의 대응책으로, 창작자들에게 강력하고 직관적인 도구를 제공하여 세계 어디서나 사용할 수 있도록 합니다.\n\n![TEV1 Image 2](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한 이미지 생성 능력의 발전에 큰 투자 관심을 가지고 있습니다. 이미지 생성 도구를 사용하여 아이디어를 반영적 이미지로 변환하는 능력은 이미 훌륭하지만, 우리가 생각하는 것과 볼 수 있는 것 사이의 간격을 좁히는 것이 중요합니다.\n\n마음에 떠오르는 무작위 아이디어를 화면이나 캔버스, 심지어 의류 디자인으로 구현하는 것이 TEV1의 목적입니다.\n\n# TEV1 작동 원리\n\nTEV1은 최첨단 AI 기술인 DALL-E 3과 이미지 생성 및 콘텍스트 이해, 이미지 프롬프트 향상을 위해 GPT-4o를 사용하여 구축되었습니다. 사용자가 주제를 입력하면 TEV1은 이러한 고급 모델을 사용하여 주제를 분석하고 해당 주제의 본질을 담은 시각적 표현물을 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_3.png)\n\n저희 도구에는 컨텍스트 로딩, 자동 데이터 처리 및 RAG와 같은 복잡한 기능이 포함되어 있어 생성된 이미지가 관련성을 가지고 미학적으로 매력적인 것을 보장합니다. 현재는 관심도 및 성능을 측정하기 위한 샘플 생성에 제한되어 있지만, TEV1은 지속적인 사용자 피드백과 모델 훈련을 통해 발전하도록 설계되었습니다.\n\n## 데이터에서 아트로 — 우리가 새로운 아트워크를 위해 역사적 데이터를 활용하는 방법\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAsycd의 설립 이후로 우리는 예술을 생성하고 텍스트 설명을 만드는 작업을 진행해 왔습니다. 이러한 텍스트 설명은 대부분 내부에서 저장되어 사용되어 왔지만, 앞으로 출시될 웹 애플리케이션을 위한 TEV1 모델 훈련에 사용될 예정입니다.\n\n오늘을 기준으로 이러한 설명 중 일부는 저희 웹사이트에서 접근 가능한 곳에 공개되어 있습니다. 이 데이터를 사용하여 이전과 동일한 프롬프트 기술과 스타일을 활용하여 새로운 작품을 만들고 있습니다. 이 과정에 대해 자세히 다룰 예정이며, 이는 매우 상세한 과정이기 때문입니다.\n\n![이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_5.png)\n\n우리는 이 데이터를 활용하여 이전 작품에 성공적인 프롬프트 기술과 스타일을 사용하여 새로운 작품을 생성합니다. 이를 통해 과거 작업에서 영감을 빨아들이면서도 지속적이고 고품질의 예술을 만들어낼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# TEV1: 예시 및 사용 사례 소개\n\nTEV1은 다양한 시각 디자인 분야에서 사용되며 다양한 매체에 대한 매우 상세한 그래픽을 생성할 수 있습니다.\n\n## 예술적 영감\n\nTEV1의 주요 사용 사례 중 하나는 예술적 영감을 제공하는 것입니다. 예술가들은 '어두운 심리학'부터 '로맨티시즘'까지 다양한 주제를 입력할 수 있으며, TEV1은 이러한 주제와 일치하는 이미지를 생성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_6.png)\n\nTEV1은 짧은 아이디어나 개념을 이야기를 담은 예술작품으로 변화시킬 수 있어요. 빠르게 떠오르는 영감을 활용하기에 안성맞춤이에요. 첨단 프롬프트 공학과 다양한 대형 언어 모델의 다층구조 덕분에, 테마 익스플로러 V1은 이미지뿐만 아니라 주제에 맞는 시각적 일치 작품을 생성해요.\n\n이 종합적인 방법론은 덧없는 생각을 다채롭고 표현력 풍부한 작품으로 변모시켜요. 이 작품들은 소셜 미디어 게시물부터 마케팅 자료 등 다양한 용도로 사용할 수 있어요.\n\n## 그래픽 디자인과 웹 디자인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n취미로 즐기는 분들과 열정적인 창작가들을 위해 TEV1은 개인 프로젝트를 현실로 만들어 주는 견고한 플랫폼을 제공합니다. 개인 블로그를 위한 독특한 시각적 콘텐츠 작성, 소설을 위한 스토리보드 디자인, DIY 프로젝트를 위한 주제별 아트워크 초안 작성 등, TEV1은 창작하는 여러분의 작품에 전문적인 손길을 더해줍니다.\n\n우리는 이 도구를 사용하여 웹사이트의 장식을 완전히 맞춤화했고, 지속적인 개선 노력 덕분에 우리 웹사이트가 이전보다 더 멋지게 변했습니다!\n\n![TEV1 이미지](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_7.png)\n\n웹 디자이너들은 TEV1 이미지 생성기를 활용하여 자신들의 웹사이트에 완벽한 배경 씬을 설정할 수 있는 매료되는 이미지를 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래픽 디자이너들에게 TEV1 세대는 가능성의 보물창고입니다. 그들은 끝없는 패턴, 생동감 넘치는 디자인, 그리고 고유한 구성에 접근하여 창의적인 과정을 시작하거나 프로젝트에 마지막 손짓을 더할 수 있습니다. 이는 올해 초부터 \"VALENHEARTS\" 컬렉션에서 작업한 예술가들에 의해 그렇게 사용되었고, 이 도구의 창의적인 힘을 조금 오박사 단계에서 목격했습니다.\n\n![TEV1](/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_8.png)\n\n## 모든 것을\n\n우리는 이것을 창의적이거나 디자인 중심의 모든 것에 사용할 수 있다고 생각합니다. 우리는 캔버스로 시작했지만, 희망적으로 다른 모든 가능한 사용 사례를 탐색할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 마케팅 및 광고: 캠페인, 소셜 미디어 게시물 및 광고를 위한 독특하고 화려한 시각물을 제작합니다.\n- 게임 개발: 컨셉 아트, 캐릭터 디자인 및 환경 텍스처를 생성합니다.\n- 패션 디자인: 원단을 위한 패턴과 프린트를 개발합니다.\n- 인테리어 디자인: 커스텀 이미지로 방 구성과 장식을 시각화합니다.\n- 교육: 설명적인 다이어그램과 창의적인 이미지로 학습 자료를 향상합니다.\n- 엔터테인먼트: 음악 앨범, 책 표지 및 프로모션 포스터를 위한 아트워크를 제작합니다.\n\n# 곧 만나요!\n\nTEV1을 계속 개발하고 개선하는 동안, 여러분은 여기에서 시도해보시고 피드백을 제공해 주시기 바랍니다. 웹 앱의 예상 출시일은 6월 말이니 조금만 기다려 주시고, 계속 영감을 얻어 주세요!\n\n“항상 할 수 있는 것이 있다” - \"Asycd\"\n","ogImage":{"url":"/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png"},"coverImage":"/assets/img/2024-05-23-TEV1RedefiningArtCreationwithAI-EnhancedThematicExploration_0.png","tag":["Tech"],"readingTime":7},{"title":" 더 나은 제품 디자인을 위해 우리 뇌 네트워크의 비밀 해제하기 ","description":"","date":"2024-05-23 13:20","slug":"2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign","content":"\n요즘에는 인공 신경망에 대해 많은 사람들이 이야기하지만 자신의 신경 체계에 대해 알고있는 사람은 매우 드물어요.\n\n![이미지](/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png)\n\n제품 개발에 관여하는 모든 사람들에게 중요한 것은 사용자가 제품을 인지하는 데 필요한 것을 이해하는 것입니다:\n\n1. 제품에 주목하게 만드는 것 (외생적 주의),\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. Keep a sustained interest (internal attention),\n\n3. Purchase the product with the belief that it will meet your needs.\n\nTherefore, we have three main neural networks:\n\n✅ 1. Default Mode Network - which controls our social reasoning. You might remember how you naturally start thinking about your family, coworkers, or someone who was rude to you in line.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 조상들이 작은 그룹에서 함께 생활하며 형성된 가능성이 높아요. 이것은 그들이 부족한 것들 사이에서 모든 사회적 상호작용을 이해하고 지켜주는 데 도움을 주었고, 한 마디로 말해 전체 네트워크를 형성했어요 — 이것이 뇌의 기본 시스템이에요. 이 기본 시스템은 다른 이들의 반응을 예측할 수 있어요. 수천 년 동안 우리 뇌는 신체적으로 크게 변하지 않았지만, 해야 할 일들의 목록은 크게 증가했어요. 우리는 다양한 문제를 해결하기 위해 같은 DMN을 사용하며, 사람들을 일시적으로 그것에서 떼어내어 해방된 공간에 사실, 추상적인 개념, 숫자, 그래프를 채워 넣어 일을 할 수 있어요.\n\n✅ 2. Salience Network — 이 시스템은 특정 지적 작업에 집중할 수 있는 능력을 제공해요. 들어오는 정보를 처리하고 외부 자극을 평가해요.\n\n✅ 3. Central Executive Network — 또한 들어오는 정보를 처리하고 외부 자극을 평가하고 분석해요.\n\n중요한 점은 이 세 시스템이 서로 경쟁한다는 것이에요🤓.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 작업에 집중할 때 (주의 네트워크) 주변에 덜 주의를 기울이게 되고, 그러면 어쩌다가 누군가와의 불쾌한 대화에 대해 생각하게 되는 경우가 생길 수 있어요 (기본 모드 네트워크가 우세해집니다).\n\n💡 광고에 있어서 외부 주의 (광고 배너와 같은 외부 신호로 인한 주의)가 어떻게 작용하는지 이해하는 것이 중요합니다.\n\n💡 온보딩에 있어서 중요한 것은 관심이 인위적으로 유발될 수 있다는 것을 깨달아야 합니다. 뇌는 어떤 것에 대한 이해의 모형을 형성하기 전에 사실들의 집합을 축적할 수 있는 능력을 갖고 있어요. 처음에는 흥미로워 보이지 않더라도, 사실이 축적되고 성공적인 작업 완료로 강화되는 경우, 흥미가 발전할 수 있어요. 이것이 온보딩의 주요 기능 중 하나에요.\n\nP.S. 다음에는 우리 뇌가 구매 결정을 내리는 방식에 대해 이야기할 거에요 😇.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n","ogImage":{"url":"/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png"},"coverImage":"/assets/img/2024-05-23-UnlockingtheSecretsofOurBrainsNetworksforBetterProductDesign_0.png","tag":["Tech"],"readingTime":3},{"title":"SwiftUI에서 TextField를 전문가처럼 유효성 검사하는 방법","description":"","date":"2024-05-23 13:19","slug":"2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro","content":"\n<img src=\"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png\" />\n\n안녕하세요! 오늘은 여러분께, 널리 확장된 로직을 사용하지 않고 모든 텍스트 필드를 한꺼번에 유효성을 검사하는 방법을 보여드리려고 합니다. 이번에는 텍스트 필드의 유효성을 검사하는 나쁜 방법과 좋은 방법을 구분하는 것을 목표로 하고 있어요.\n\n먼저, 예제를 아주 간단하게 유지할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n세 개의 텍스트 필드와 사용자 입력을 저장하는 비밀번호를 위한 한 개의 보안 필드가 있는 화면이 있다고 가정해봅시다. 이 숫자는 간단히 유지하기 위한 것이며, 실제 상황에서는 10개가 될 수도 있습니다.\n\n```js\nstruct ContentView: View {\n   @State var email : String = \"\"\n   @State var password : String = \"\"\n   @State var name : String = \"\"\n   @State var surname : String = \"\"\n    var body: some View {\n          VStack {\n             TextField(\"이메일\", text: $email)\n             TextField(\"이름\", text: $name)\n             TextField(\"성\", text: $surname)\n             SecureField(\"비밀번호\", text: $password)\n             Spacer().frame(height: 300)\n             Button {\n\n\n             } label: {\n                Text(\"여기를 눌러보세요!\")\n                   .padding(.all)\n                   .background(.red)\n                   .cornerRadius(16)\n             }\n          }\n          .padding()\n       }\n}\n```\n\n이제 나쁜 방식과 좋은 방식을 구분하여 느껴보겠습니다.\n\n#나쁜 방식\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nButton {\n    // 먼저 원하는 방식으로 유효성을 확인합니다.\n    if email.count > 6 && password.count > 12\n            && !name.isEmpty && !surname.isEmpty {\n        // 네트워킹 호출 수행!\n        // 이것은 영원히 계속됩니다.\n        // 읽기가 어렵고 확장 가능하지 않으며 재사용 가능하지 않습니다.\n    } else {\n        // 얼럿 팝업 등을 표시합니다.\n    }\n\n} label: {\n    Text(\"여기를 탭하여 시도해보세요!\")\n        .padding(.all)\n        .background(.red)\n        .cornerRadius(16)\n}\n```\n\n# 좋은 방법\n\n이제 진짜 작업이 시작되었지만, 먼저 이 솔루션을 사용하기 위해 SwiftUI의 일부 주요 기능을 알아야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**PreferenceKey**\n\nPreferenceKey 유형은 자식 뷰에서 부모 뷰로 뷰 트리를 업데이트하는 데이터 흐름을 처리하는 솔루션인데, 어떤 종류의 위임이나 생성자 핸들러를 사용하지 않고도 작업할 수 있습니다. 제가 본 바로는 널리 사용되지 않지만, 정말 복잡하지는 않습니다. 어느 정도로 보면, @EnvironmentObject의 역이라고 할 수 있습니다.\n\nPreferenceKey는 이미 NavigationView의 타이틀이나 TabViews 선택 및 자식의 id 등에 사용되고 있습니다.\n\n우리가 어떻게 사용자 정의 preference key를 정의할 수 있는지 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n구조체 ValidationPreferenceKey : PreferenceKey {\n   static var defaultValue: [Bool] = []\n\n   static func reduce(value: inout [Bool], nextValue: () -> [Bool]) {\n      value += nextValue()\n   }\n}\n```\n\n이것은 사용자 지정 PreferenceKey를 정의하는 구문입니다. 이 특정 프로토콜을 준수하기 위해 두 가지를 구현해야 합니다.\n\n```js\nstatic var defaultValue: [Bool] = []\n```\n\n이 기본 값은 Equatable을 준수하는 한 어떤 것이든 될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nstatic func reduce(value: inout [Bool], nextValue: () -> [Bool]) {\n      value += nextValue()\n   }\n```\n\n우리는 이 줄이 키가 등록된 키의 여러 반복에서 무엇을 해야 하는지를 정의하는 리덕션 함수를 구현해야 합니다.\n\n예를 들어, TabView가 있고 그 안에 여러 개의 하위 뷰가 있고 모두 .id() 수정자를 가지고 있다고 하면, 이 reduce 함수는 모든 id 수정자 값에 사용됩니다.\n\nTextField에서 이를 사용하려면 두 단계가 필요합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1- 뷰 수정자\n\n2- 익스텐션\n\n이제 이를 위해 ViewModifier를 어떻게 구현하는지 보여드릴게요\n\n```js\nstruct ValidationModifier : ViewModifier  {\n   let validation : () -> Bool\n   func body(content: Content) -> some View {\n         content\n            .preference(\n               key: ValidationPreferenceKey.self,\n               value: [validation()]\n            )\n      }\n   }\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 수정자는 그 특정 뷰에 해당하는 키를 등록합니다.\n\n```js\nlet validation: () -> Bool\n```\n\n이 변수는 우리가 유효성 검사에 사용할 로직을 보유할 것입니다.\n\n그리고 이 확장은 이를 일부 특정 유형의 뷰에 대해서만 적용합니다. TextFields 및 SecureFields와 같은 뷰입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nextension TextField {\n   func validate(_ flag: @escaping () -> Bool) -> some View {\n      self\n         .modifier(ValidationModifier(validation: flag))\n   }\n}\n\nextension SecureField {\n   func validate(_ flag: @escaping () -> Bool) -> some View {\n      self\n         .modifier(ValidationModifier(validation: flag))\n   }\n}\n```\n\n여기서 중요한 두 가지 아쉬움이 있습니다. 첫째로, 우리는 TextFields 텍스트를 노출할 수 없습니다. 이것은 이니셜라이저에서만 사용 가능하며 Apple에 의해 노출되지 않습니다.\n\n둘째로, TextField와 SecureField는 View가 아닌 동일한 형식에서 상속되지 않기 때문에 이것을 단일 확장으로 줄일 수 없습니다. 해결 방법이 있다면 알려주세요!\n\n이 modifier를 다른 뷰에서 사용할 수 없도록 유지하려면 동일한 파일에서 modifier와 확장을 정의하고 modifier를 private으로 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막 부분 빼고는 설정이 완료되었어요.\n\n마지막으로, 이 키의 업무를 처리할 뷰를 정의해야 해요.\n\n```js\nstruct TextFormView<Content : View> : View {\n   @State var validationSeeds : [Bool] = []\n   @ViewBuilder var content : (( @escaping () -> Bool)) -> Content\n   var body: some View {\n         content(validate)\n         .onPreferenceChange(ValidationPreferenceKey.self) { value in\n            validationSeeds = value\n         }\n   }\n\n   private func validate() -> Bool {\n      for seed in validationSeeds {\n         if !seed { return false}\n      }\n      return true\n   }\n}\n```\n\n이 컨테이너 뷰는 이 키 타입에서 로직을 실행하고, Vstack 또는 TabView와 같은 뷰를 내부에 가져옵니다. .onPreferenChange 수정자를 본 적 있나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 수정자는 이 키에서 자식 뷰 업데이트를 잡습니다.\n\n그래서\n\n```js\n.preference(\n               key: ValidationPreferenceKey.self,\n               value: [validation()]\n            )\n```\n\n이렇게 업데이트됩니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n.onPreferenceChange(ValidationPreferenceKey.self) { value in\n  validationSeeds = value\n}\n```\n\n각 자식 뷰의 키 값을 캐치해요. [Bool]가 아니라 Bool로 반환했던 것 기억하시죠? 이건 단지 validationSeeds 변수에 할당하기 위한 것이에요. 이 validationSeeds 변수는 .validate() 확장 ValidationPreferenceKey로 수정된 각 자식 뷰를 보유하고 있어요.\n\n이제 모든 필드의 Key 값이 TextFormView에 있으니 이 데이터를 처리하고 무언가를 구축할 수 있어요.\n\n```js\nprivate func validate() -> Bool {\n  for seed in validationSeeds {\n    if !seed { return false }\n  }\n  return true\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 함수는 그냥 제가 생각해 낸 것일 뿐이에요. 필수적이지는 않지만 저는 좋아해요.\n\n```js\n@ViewBuilder var content : ((@escaping () -> Bool)) -> Content\n                        // (validate) -> Content 이게 무슨 뜻인지에요.\n```\n\n우리는 그냥 이 TextFormView 바깥으로 이 validate 함수를 노출시키는 것 뿐이에요.\n\n이제 이것을 우리 뷰에서 사용할 수 있고, 다음과 같이 될 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단한 유효성 검사를 만들었지만, 실제 상황에서는 정규식과 다른 로직을 사용하여 유효성을 검사해야 합니다. 어쩌다 그렇게 했어요.\n\n```swift\nstruct ContentView: View {\n   @State var email : String = \"\"\n   @State var password : String = \"\"\n   @State var name : String = \"\"\n   @State var surname : String = \"\"\n   var body: some View {\n\n       TextFormView  { validate  in // -> 이 부분이 바로 validate 함수에요\n          VStack {\n             TextField(\"Email\", text: $email)\n                .validate {\n                   email.count > 6\n                }\n             TextField(\"Name\", text: $name)\n                .validate {\n                   !name.isEmpty\n                }\n             TextField(\"Surname\", text: $surname)\n                .validate {\n                   !surname.isEmpty\n                }\n             SecureField(\"Password\", text: $password)\n                .validate {\n                   password.count > 10\n                }\n             Spacer().frame(height: 300)\n             Button {\n                if !validate() {\n                   return\n                }\n                // 네트워크 호출을 해주세요\n             } label: {\n                Text(\"Tap here to try!\")\n                   .padding(.all)\n                   .background(.red)\n                   .cornerRadius(16)\n             }\n          }\n       }\n          .padding()\n    }\n\n}\n```\n\n미리 말씀드린 대로 이미지 삽입과 함께, 어떻게 동작하는지 보여주기 위해 validate()을 출력했어요. 모든 필드가 함께 유효성을 검사하는 모습이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기까지 읽어 주셔서 감사합니다.\n\n이것은 시작에 불과하다는 것을 잊지 마세요. 이것을 사용하여 오류 메시지를 반환하거나 어떤 필드가 유효하지 않은지 선택할 수 있습니다. 나중에 이를 사용자 정의할 수도 있을 것 같네요.\n\n어쨌든 나중에 뵙겠습니다! 즐거운 시간 보내세요!\n","ogImage":{"url":"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png"},"coverImage":"/assets/img/2024-05-23-HowtovalidateTextFieldsinSwiftUIlikeaPro_0.png","tag":["Tech"],"readingTime":11},{"title":"크로스 플랫폼 앱 개발 로드맵","description":"","date":"2024-05-23 13:17","slug":"2024-05-23-Cross-PlatformAppDevelopmentRoadmap","content":"\n오늘날의 디지털 시대에서 모바일 앱 개발은 고객과 소통하고 영향을 확대하려는 기업들에게 중요한 요소가 되었습니다.\n\n그러나 모바일 장치와 운영 체제의 다양성이 개발자들에게 어려움을 제공합니다. 이것이 크로스 플랫폼 앱 개발이 필요한 이유입니다.\n\n여기에는 크로스 플랫폼 앱 개발을 잘하기 위한 로드맵이 제시되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 크로스 플랫폼 앱 개발에서의 도전\n\n크로스 플랫폼 개발은 많은 이점을 제공하지만, 고유한 도전 과제들도 함께 따라옵니다.\n\n## 성능 문제\n\n가장 흔한 고민은 크로스 플랫폼 앱의 성능 문제입니다. 개발자들은 코드를 최적화하고 플랫폼별 최적화를 활용하여 원할한 성능을 보장해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 네이티브 기능 제한\n\n크로스 플랫폼 프레임워크는 특정 네이티브 기능 및 기능에 액세스하는 데 제한이 있을 수 있으며, 이로 인해 개발자는 해결책이나 대안적인 솔루션을 찾아야 할 수 있습니다.\n\n## 호환성 문제\n\n다양한 기기, 화면 크기 및 운영 체제 간의 호환성을 보장하는 것은 어려운 작업일 수 있습니다. 철저한 테스트와 최적화가 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 적절한 크로스 플랫폼 프레임워크 선택\n\n크로스 플랫폼 앱 개발 프로젝트의 성공을 위해 적절한 프레임워크 선택이 중요합니다.\n\n## 인기 프레임워크 개요\n\nReact Native, Xamarin, Flutter와 같은 프레임워크는 각각 독특한 기능과 능력을 제공하여 다양한 프로젝트 요구사항 및 개발자 선호도에 부합합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 크로스 플랫폼 모바일 앱 개발을 위해 고려해야 할 사항\n\n성능, 커뮤니티 지원, 학습 곡선 및 기존 기술과의 통합과 같은 고려 사항이 프레임워크 선택 프로세스에 영향을 미쳐야 합니다.\n\n## 준비 및 계획\n\n개발에 들어가기 전에 철저한 준비와 계획이 필요하며, 이는 프로젝트의 성공을 위해 필수적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 앱 요구 사항 정의\n\n앱의 기능, 기능 및 타겟 대상을 명확히 정의하여 개발 노력이 비즈니스 목표와 일치하도록합니다.\n\n## 타겟 대상 및 시장 조사\n\n사용자 선호도, 시장 동향 및 경쟁사를 이해하면 디자인 및 개발 결정에 영향을 미쳐 사용자 기대치를 충족시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 프로젝트 일정 및 중요한 이벤트 설정\n\n명확한 일정과 이벤트 설정은 개발 프로세스를 추적하고 효율적인 프로젝트 관리를 가능하게 합니다.\n\n## 사용자 인터페이스 디자인\n\n잘 디자인된 사용자 인터페이스는 플랫폼 간에 원활한 사용자 경험을 제공하는 데 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 크로스 플랫폼 앱 개발에서 반응형 디자인의 중요성\n\n앱의 레이아웃과 기능을 다양한 화면 크기와 해상도에 맞게 조정하기 위해 반응형 디자인 원칙을 활용하세요.\n\n## 일관된 사용자 경험 생성\n\n모든 플랫폼에서 디자인 요소, 내비게이션 패턴, 브랜딩을 일관되게 유지하여 사용성과 브랜드 인지도를 향상시키세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 개발 단계\n\n기본 작업이 완료되었으므로, 개발자들은 이제 코드를 작성하고 앱을 구현할 수 있습니다.\n\n## 선택한 프레임워크를 사용하여 코드 작성\n\n선택한 프레임워크의 기능과 기능성을 활용하여 앱 로직, 사용자 인터페이스 요소 및 백엔드 통합을 구현하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테스트 및 디버깅\n\n철저한 테스트는 버그를 식별하고 수정하여 앱이 다양한 기기와 플랫폼에서 의도한 대로 작동하도록 하는 데 중요합니다.\n\n## 반복적인 개발 프로세스\n\n반복적인 접근 방식을 채택하여 사용자 피드백을 통합하고 앱의 기능과 디자인을 점진적으로 개선하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 성능 최적화\n\n성능 최적화는 반응성 있고 효율적인 앱 경험을 제공하는 데 중요합니다.\n\n## 앱 성능 향상을 위한 기술\n\n코드 최적화, 캐싱 및 지연 로딩과 같은 전략을 구현하여 앱 반응성을 향상시키고 로딩 시간을 줄일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 일반적인 병목 현상 대응\n\n메모리 누수, 비효율적 알고리즘 및 과도한 리소스 사용과 같은 성능 병목 현상을 식별하고 대응하세요.\n\n## 네이티브 기능 통합\n\n원활한 사용자 경험을 제공하기 위해 개발자는 플랫폼별 기능과 기능을 앱에 통합해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기기별 기능에 액세스하기\n\nGPS, 카메라 및 푸시 알림과 같은 기기 기능에 액세스하려면 플랫폼별 API 및 라이브러리를 활용하세요.\n\n## 플랫폼별 API 구현\n\n네이티브 능력을 활용하기 위해 필요한 곳에서 플랫폼별 코드를 구현하는 모듈식 접근 방식을 채택하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 크로스 플랫폼 앱 개발에서의 테스트 및 품질 보증\n\n품질 보증은 앱이 사용자의 기대를 충족하고 각 플랫폼에서 안정적으로 작동하는 것을 보장하는 데 매우 중요합니다.\n\n## 엄격한 테스트의 중요성\n\n자동화된 테스트 도구와 수동 테스트 기술을 활용하여 버그, 사용성 문제 및 성능 병목 현상을 식별하고 해결하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 사용자 인수 테스트\n\n베타 테스트와 포커스 그룹을 통해 실제 사용자로부터 피드백을 수집하여 개선할 부분을 식별하고 앱의 기능 및 디자인을 개선하세요.\n\n# 배포 전략\n\n개발이 완료되면 앱을 출시 및 배포할 준비가 되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 앱 스토어 제출 프로세스\n\n애플 앱 스토어 및 구글 플레이 스토어와 같은 앱 스토어의 지침과 요구 사항을 따라 앱을 검토 및 승인을 위해 제출하세요.\n\n## 베타 테스트 및 피드백 수집\n\n공식 런칭 전에 초기 사용자로부터 피드백을 수집하고 남은 문제를 해결하기 위해 앱의 베타 버전을 출시하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 지속적 통합 및 배포\n\n빌드, 테스트 및 배포 프로세스를 자동화하는 지속적 통합 및 배포 파이프라인을 구현하여 업데이트 및 패치를 효율적으로 제공합니다.\n\n# 개발 후 지원 및 유지보수\n\n앱 출시로 끝나는 것이 아닙니다. 지속적인 지원 및 유지보수는 장기적인 성공에 필수적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 업데이트 및 패치 관리\n\n새로운 기능, 버그 수정 및 보안 패치를 포함하여 앱을 정기적으로 업데이트하여 사용자들을 즐겁게 유지하고 보호하세요.\n\n## 앱 성능 모니터링\n\n애널리틱스 도구 및 모니터링 플랫폼을 활용하여 앱 성능, 사용자 참여 및 피드백을 추적하여 데이터 기반의 의사 결정을 할 수 있도록하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 사용자 피드백 대응\n\n사용자 피드백을 듣고 사용자의 요구사항과 선호도에 따라 기능 요청과 버그 수정을 우선순위에 따라 설정하여 충성스러운 사용자 커뮤니티를 육성합니다.\n\n# 성공적인 크로스 플랫폼 앱 예시\n\n실제 사례를 통해 크로스 플랫폼 앱 개발이 비즈니스 목표를 달성하고 탁월한 사용자 경험을 제공하는 데 얼마나 효과적인지를 강조합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인기 있는 크로스 플랫폼 앱인 Airbnb, Instagram 및 Uber의 사례 연구를 살펴보면, 그들의 독특한 기능과 개발 과제를 보여줍니다.\n\n# 실제 프로젝트에서 얻은 교훈\n\n크로스 플랫폼 앱 개발을 채택한 개발자 및 기업의 경험에서 통찰을 얻어, 그들의 성공과 실패로부터 배우세요.\n\n# 크로스 플랫폼 앱 개발의 혜택\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 비용 효율성\n\n여러 플랫폼을 위한 단일 코드베이스를 활용하면 개발 비용을 크게 줄일 수 있고 시장 진입 시간을 단축할 수 있습니다.\n\n## 빠른 개발 시간\n\n크로스 플랫폼 프레임워크는 개발 프로세스를 간소화하는 도구와 라이브러리를 제공하여 개발자가 앱을 효율적으로 구축하고 배포할 수 있도록 도와줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 더 넓은 관객층 도달\n\n크로스 플랫폼 접근 방식을 통해 앱은 다양한 기기와 운영 체제에서 보다 넓은 관객층에게 도달할 수 있으며, 잠재적 사용자 베이스를 극대화할 수 있습니다.\n\n# 크로스 플랫폼 앱 개발의 미래 트렌드\n\n기술이 발전함에 따라, 새로운 트렌드와 혁신이 크로스 플랫폼 앱 개발의 미래를 선도하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 부상 중인 기술 및 프레임워크\n\n증강 현실, 머신 러닝, 블록체인과 같은 부상 중인 기술들에 대해 알아두세요. 교차 플랫폼 개발에 대한 그들의 영향도를 고려해보세요.\n\n## 교차 플랫폼 개발의 미래에 대한 예측\n\n전문가들은 도구, 프레임워크, 개발자 생태계의 발전을 주도로 하여 교차 플랫폼 개발 분야에서 지속적인 성장과 혁신이 예측됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱 경험을 다양한 플랫폼에서 향상시키기 준비가 되셨나요? Ropstam Solutions에 연락하여 전문적인 크로스 플랫폼 개발을 경험해보세요. Ropstam의 크로스 플랫폼 개발자들은 iOS, Android 및 기타 플랫폼에서 여러분의 비전을 원활하게 통합합니다. 함께 협력하여 차세대 앱을 만들어보세요! 지금 Ropstam에 연락해보세요.\n\n# 결론\n\n크로스 플랫폼 앱 개발은 여러 플랫폼에서 일관된 사용자 경험을 제공하며 넓은 관중에 접근할 수 있는 비용 효율적이고 효과적인 솔루션을 제공합니다.\n\n계획 수립, 디자인, 개발, 테스트 및 유지보수를 포함한 전략적인 로드맵을 따르면, 개발자들은 사용자와 기업 모두의 요구를 충족시키는 성공적인 크로스 플랫폼 앱을 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자주 묻는 질문들\n\n## 크로스 플랫폼과 네이티브 앱 개발의 차이점은 무엇인가요?\n\n크로스 플랫폼 개발은 코드를 한 번 작성한 후 여러 플랫폼에 배포하는 것을 의미하며, 네이티브 개발은 각 플랫폼별로 별도의 코드베이스를 생성하는 것을 의미합니다.\n\n## 제 프로젝트에 가장 적합한 크로스 플랫폼 프레임워크는 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제일 좋은 프레임워크는 프로젝트 요구사항, 개발자 전문 지식 및 성능 목표 등과 같은 요소에 따라 다릅니다. 결정을 내리기 전에는 각 프레임워크의 기능과 제한 사항을 평가하는 것이 중요합니다.\n\n## 모든 기기에서 교차 플랫폼 앱이 잘 작동되도록 어떻게 할 수 있을까요?\n\n코드 최적화, 캐싱 및 기기별 테스트와 같은 성능 최적화 기술을 활용하면 다양한 기기와 플랫폼에서 앱이 잘 작동하는 것을 보장할 수 있습니다.\n\n## 교차 플랫폼 앱 개발에서 피해야 할 일반적인 함정은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적인 함정으로는 플랫폼별 기능을 무시하거나 성능 고려를 과소평가하는 것, 그리고 사용자 경험과 디자인 일관성을 우선시하지 않는 것이 있습니다.\n\n## 모든 종류의 앱에 크로스 플랫폼 앱 개발이 적합한가요?\n\n크로스 플랫폼 개발은 많은 종류의 앱에 적합하지만, 특정 플랫폼 기능과 깊은 통합이 필요한 고도로 특화되거나 자원 집약적인 애플리케이션에는 최선의 선택이 아닐 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-Cross-PlatformAppDevelopmentRoadmap_0.png"},"coverImage":"/assets/img/2024-05-23-Cross-PlatformAppDevelopmentRoadmap_0.png","tag":["Tech"],"readingTime":13},{"title":"2023년 혁신적인 수익화 전략으로 2억 6천만 달러를 벌어낸 화이트아웃 서바이벌의 성공 비결을 알아보세요","description":"","date":"2024-05-23 13:16","slug":"2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics","content":"\n![LearnHowWhiteoutSurvivalEarned260Millionin2023](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_0.png)\n\n저희 게임 모네타이제이션 리뷰 시리즈 두 번째 에티션이에 오신걸 환영합니다. 만약 ‘Idle Civilization’에 대한 첫 번째 기사를 놓치셨다면 여기서 확인해보세요 - 멋지고 독특한 통찰이 기다리고 있답니다.\n\n새로운 게임을 탐험하는 걸 좋아하는데, ‘Century Games’의 ‘Whiteout Survival’을 발견해서 정말 흥미로웠어요. 이 게임은 얼어붙은 세계에서 생존하는 것뿐만 아니라 지역사회를 구축하고 어려운 선택을 하는 것까지 관련돼 있거든요. 2022년 12월 2일에 출시된 ‘Whiteout Survival’은 엄청난 얼어붙음으로 모든 것이 변화한 세계에 당신을 던져넣어요. 플레이어들은 지구상의 마지막 도시를 이끌며 심한 추위, 위험한 동물, 그리고 다른 위협으로부터 싸워야 해요. 전략과 생존의 조합으로, 이 게임은 거대한 히트를 치며 2023년 현재까지 2억 6천만 달러의 수익을 올렸어요.\n\n‘Whiteout Survival’이 강조하는 점 중 하나는 게임 내 구매 방식이에요. 무료로 플레이할 수 있지만, 게임은 실제 돈을 쓰는 똑똑한 방법을 제공하며 그 비용을 지불한 만큼 더해진 재미를 느낄 수 있어요. 이 기사에서는 ‘Whiteout Survival’이 이 영역에서 뛰어난 네 가지 방법에 대해 살펴보겠어요. 이 전략들은 게임을 위해 돈을 벌이는 것뿐만 아니라 플레이어들의 즐거움을 크게 높여주고 있답니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 빌더를 강화하세요: 추가 빌더 제안\n\n많은 전략 게임과 마찬가지로 'Whiteout Survival'은 건물을 업그레이드할 수 있는 빌더 한 명으로 시작합니다. 즉, 다음 업그레이드를 시작하기 전에 하나의 업그레이드가 끝날 때까지 기다려야 합니다. 여기에 재미있는 점이 있습니다. 게임은 무료 15분 평가판으로 두 번째 빌더를 선물해줍니다. 바로 시작부터 추가적인 도움의 가치를 보여주는 것입니다. 평가판이 끝나면 두 가지 선택이 있습니다. 다이아몬드로 2일 동안 빌더를 고용하거나 현금으로 그들의 서비스를 영구적으로 확보할 수 있습니다. Century Games는 빠른 진행의 가치를 시연하기 위한 똑똑한 전략을 고안했습니다. 플레이어들에게 그 속도를 유지하기 위한 유연한 구매 옵션을 제공합니다.\n\n![이미지](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_1.png)\n\n# 다중 배틀 패스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n'화이트아웃 서바이벌'은 다양한 배틀 패스를 제공하여 승부의 건을 높이고 있습니다. 이러한 패스들은 영웅을 모으거나 얼음 요새를 강화하는 등 다양한 게임 측면에 맞춰 제작되었습니다. 플레이어들은 현재 상황에 가장 적합한 배틀 패스를 선택할 수 있습니다. 센추리 게임즈는 다양한 배틀 패스를 제공함으로써 플레이어의 다양한 관심사를 고려하여 참여를 촉진하고 선호 콘텐츠를 통해 구매 가능성을 높이고 있습니다. 이 방법은 게임플레이에 층을 더하며 플레이어가 게임 내 진행상황과 보상을 맞춤 설정할 수 있는 자유를 부여합니다.\n\n![이미지](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_2.png)\n\n## 맞춤형 상자 제공\n\n'화이트아웃 서바이벌'은 \"맞춤형 상자 제공\"이라는 독특한 기능을 통해 게임 내 상점에 새로운 변화를 더했습니다. 이 기능을 통해 상자를 채우는 보상을 직접 선택할 수 있습니다. 각각의 다양한 가격대의 상자에서는 미리 정해진 항목들과 해당 세트를 완성하기 위해 추가 보상을 선택할 수 있는 옵션이 포함되어 있습니다. 이 맞춤형 기능을 통해 바로 필요한 속도 향상 또는 경험치 상승과 같은 게임 요구에 맞게 구매를 맞춤 설정할 수 있습니다. 이러한 맞춤형을 가능케 함으로써 게임은 플레이어들이 제어를 선호하는 경향을 파악하여 직접 구성한 번들에 투자할 가능성을 높이고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_3.png)\n\n# VIP 진행: 구매로 쉬운 레벨 업\n\n'Whiteout Survival'에서 VIP 랭크를 올라가면 새로운 기능과 보너스가 해제됩니다. 레벨 1부터 시작하여 다음 레벨로 진행하기 위해 포인트를 모으면 더 좋은 보상을 받을 수 있습니다. 게임은 VIP 사다리를 빠르게 오르는 경로를 제공합니다: 다이아몬드를 사용하거나 VIP 포인트가 포함된 팩을 구입하세요. 랭크를 빨리 오르고 싶은 사람들에게는 이러한 옵션이 더 많은 게임 내 혜택으로 가는 지름길을 제공합니다.\n\n![이미지](/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n'Whiteout Survival'은 얼어붙은 아포칼립스에서 생존 기술뿐만 아니라 모험에 매끄럽게 통합되는 다양한 전략적 화폐화 옵션을 제공하여 여러분의 능력을 시험합니다. 새로운 VIP 레벨 도달, 맞춤형 상자 생성 및 배틀 패스 잠금 해제는 만족스러운 경험을 안겨줍니다. 이러한 통찰을 감상하고 게임 화폐화 전술의 보다 심층적인 탐구를 기대한다면 뉴스레터 구독을 잊지 말아주세요. 정보를 입수하고 앞서가는 자세를 유지하며 함께 가상 세계의 가치를 발견해 나가요.\n","ogImage":{"url":"/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_0.png"},"coverImage":"/assets/img/2024-05-23-LearnHowWhiteoutSurvivalEarned260Millionin2023withInnovativeMonetizationTactics_0.png","tag":["Tech"],"readingTime":4},{"title":"제이미니 API 사용 전에 읽어보세요","description":"","date":"2024-05-23 13:15","slug":"2024-05-23-ReadthisBeforeUsingGeminiAPI","content":"\n## Gemini API를 최대한 활용할 수 있도록 도와주는 개발자 안내서\n\n안녕하세요 👋🏻\n\n앱에 Gemini API를 사용하고 싶으신가요? Gemini AI 매개변수를 효과적으로 활용하는 방법은 무엇인가요? Gemini AI를 사용할 때 주의해야 할 점은 무엇일까요?\n\n![이미지](/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGemini AI를 처음 사용하시는 분이라면, 이는 텍스트, 이미지 및 오디오 등 다양한 유형의 데이터 입력에서 콘텐츠를 생성할 수 있는 모델로 정의되는 생성적 AI입니다.\n\n## Gemini API를 사용해야 하는 이유\n\n아마도 몇몇 분들은 \"Gemini 앱이 있는데, 왜 Gemini API를 사용해야 하죠?\" 라고 물을지도 모릅니다.\n\nGemini API는 AI 기반 응용 프로그램을 만들고 싶은 분들을 대상으로 하고 있습니다. 게다가 유료 버전에서는 귀하의 프롬프트 및 응답을 제품 개선에 사용하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 토큰\n\n생성적 AI 모델은 텍스트 데이터를 처리하기 위해 토큰이라는 단위로 분해합니다. 토큰은 문자, 단어 또는 구(phrase)가 될 수 있습니다. 이는 Gemini가 어떻게 단어를 분해하는지에 따라 다릅니다.\n\n# Top-K, Top-P 및 Temperature\n\n## topK\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ntopK 매개변수는 모델이 출력 토큰을 선택하는 방식을 변경합니다. 간단히 말해, 가능한 출력 토큰을 K개로 제한합니다.\n\n예시:\n다음 단어를 완성해야 합니다:\nThe quick brown fox jumps over the …\n\n다음 단어의 확률:\n\n1. squirrel: 0.08\n2. sleeping rabbit: 0.3\n3. lazy dog: 0.9\n4. dog: 0.7\n\n예시에서...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 topK를 1로 설정하면 (탐욕 디코딩), 출력 결과는 가장 높은 확률을 가진 단어만 표시됩니다. 즉, \"게으른 개\"가 됩니다.\n\n만약 topK를 N(N ≥ 1)으로 설정하면, 출력 결과는 가장 높은 확률을 가진 N개의 단어 중 하나가 나오게 됩니다. 예를 들어, \"게으른 개\", \"개\", \"자는 토끼\"가 있을 때, 이 중에서도 topP에 따라 단어가 더 필터링되고, 최종 출력은 온도를 이용하여 선택됩니다.\n\n## topP\n\ntopP 매개변수, 또한 넉클리어 샘플링이라고 불리는 것은 모델이 출력 토큰을 선택하는 방식을 변경합니다. 간단히 말해, 출력 토큰의 확률 합이 topP 값과 동일하거나 그 이상인 경우까지만 토큰을 생성하는 방식입니다. topP 값은 0.0에서 1.0 사이의 범위로 설정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시:\n다음 단어를 완성해야 합니다:\n수영은 매우…\n\n다음 단어의 확률:\n\n1. 인기 있는: 0.3\n2. 치유적인: 0.1\n3. 건강한: 0.4\n4. 어려운: 0.2\n\n이때 topP는 0.5로 설정합니다.\n\n가장 높은 확률을 가진 단어는 \"건강한\" (0.4)이지만, 임계 값을 충족하지 못하므로 두 번째로 높은 \"인기 있는\" (0.3)으로 이동합니다. 따라서 출력은 \"건강한\" (0.4)과 \"인기 있는\" (0.3)입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 온도\n\n온도는 topP 및 topK가 적용된 이후의 토큰 선택의 무작위성을 제어합니다. 또한 0.0에서 1.0 범위 내에서 온도 값을 설정할 수 있습니다. 우리는 여기서 식을 포함하지 않을 것입니다.\n\n알아두어야 할 것은 높은 온도와 낮은 온도를 언제 사용해야 하는지입니다.\n\n- 낮은 온도 (≤ 0.5)는 더 구체적이거나 덜 창의적인 출력이 필요할 때 적합합니다. 사용 사례 예시로는 요약, 질문 응답, 팩트-체킹, 번역 등이 있습니다.\n- 높은 온도 (≥ 0.5)는 더 창의적인 출력이 필요할 때 적합합니다. 사용 사례 예시로는 이야기 작성, 퀴즈 생성 등이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 가격 책정\n\n가격은 입력 및 출력 토큰에 따라 다르므로 비용을 최적화하기 위해 콘텐츠 생성 전에 입력 및 출력 토큰을 제한할 수 있습니다.\n\n다트(Dart)에서의 예시는 다음과 같습니다:\n\n```js\nFuture<void> main() async {\n  final GenerativeModel model = GenerativeModel(\n    model: 'gemini-1.5-pro-latest',\n    apiKey: 'YOUR_API_KEY',\n    generationConfig: GenerationConfig(\n      responseMimeType: 'application/json',\n      maxOutputTokens: 150,\n    ),\n  );\n\n  final token = await model.countTokens(\n    [Content.text('Hello World')],\n  );\n  print(token.totalTokens);\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# JSON 생성하기\n\n가끔 앱에서 JSON을 생성해야 할 때가 있습니다. 최신 Gemini 1.5 Pro에서는 이미 JSON 출력을 지원합니다.\n\nDart에서 GenerationConfig 내부에 responseMimeType: 'application/json' 속성을 추가할 수 있습니다.\n\nGemini 1.0 Pro를 사용하지 않는 경우에는 프롬프트할 때 출력을 지정할 수 있습니다. ' '예제': '문자열' ' 이런 JSON 구조로 ...를 생성해줘 라고 간단히 요청하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 다트(Dart)에서의 예시가 있어요:\n\n```js\nvoid main() {\n  final jsonString = jsonEncode({'story': 'string'});\n  final content = await model.generateContent([\n    Content.text(\n      'Generate me a story with this JSON structure: $jsonString',\n    ),\n  ]);\n  print(content.text);\n}\n```\n\n# 시스템 지침\n\n시스템 지침은 사용자가 특정 요구 사항과 사용 사례에 따라 모델의 동작을 조정할 수 있도록 합니다. AI 역할, 언어 스타일 또는 출력을 지정할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다트 코드 예시를 보여드립니다:\n\n```js\nvoid main() {\n  final GenerativeModel model = GenerativeModel(\n    model: 'gemini-1.5-pro-latest',\n    apiKey: 'YOUR_API_KEY',\n    systemInstruction: Content.system(\n      '''You are a horror story teller.\n      You will receive a title, then turn it into a short horror story\n      and respond it to the JSON object contains title and story''',\n    ),\n  );\n}\n```\n\n# 보안\n\n클라이언트 측에서 직접 Gemini API를 호출하는 것은 API 키 유출, 서비스 거부(DoS) 공격 등과 같은 위협에 노출될 수 있습니다. 클라이언트 측은 프로토타입에만 사용해야 합니다. 가장 안전한 방법은 서버 측에서 구현하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모두 끝났어요!\n\n아래에 댓글을 남기시고 망고가 Linkedin에서 우릴 이어도록 합시다!\n\n독해주셔서 감사합니다! 🐈\n","ogImage":{"url":"/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png"},"coverImage":"/assets/img/2024-05-23-ReadthisBeforeUsingGeminiAPI_0.png","tag":["Tech"],"readingTime":7},{"title":"Swift에서의 고급 오류 처리 Try-Catch를 넘어서","description":"","date":"2024-05-23 13:13","slug":"2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch","content":"\n<img src=\"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png\" />\n\n소개\n\n오류 처리는 견고한 응용 프로그램 구축의 중요한 측면입니다. Swift의 try, catch, throw 및 do로 소개된 오류 처리 모델은 오류를 우아하게 처리하는 강력하고 유연한 메커니즘을 제공합니다. 그러나 응용 프로그램이 복잡해지면 오류를 효과적으로 관리하기 위해 더 고급 기술이 필요할 수 있습니다. 이 글에서는 Swift에서 고급 오류 처리 전략인 Result 타입, async/await 오류 전파, 사용자 정의 오류 타입, 견고한 오류 처리 시스템을 만드는 데 가장 좋은 방법 등을 탐색해 보겠습니다.\n\n왜 고급 오류 처리가 중요한가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 try-catch를 사용한 기본적인 오류 처리는 많은 시나리오에 효과적이지만, 고급 기술은 다음과 같은 여러 가지 이점을 제공합니다:\n\n- 가독성 향상: 더 명확한 오류 처리 경로는 코드의 가독성과 유지보수성을 향상시킵니다.\n- 더 좋은 제어: 오류 전파 및 복구에 대한 더 많은 제어.\n- 디버깅 향상: 더 구체적인 오류 유형으로 문제를 진단하고 수정하기가 더 쉬워집니다.\n- 비동기 컨텍스트: 비동기 코드에서의 오류를 효과적으로 관리합니다.\n\n결과 유형 사용하기\n\n결과 유형은 성공 또는 실패를 나타내며, 값이나 오류를 캡슐화합니다. 오류 처리에 대해 더 함수형 접근 방식을 제공하며 비동기 작업에서 특히 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 예제 및 결과\n\n```swift\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed\n}\n\nfunc fetchData(from urlString: String) -> Result<Data, NetworkError> {\n    guard let url = URL(string: urlString) else {\n        return .failure(.invalidURL)\n    }\n\n    do {\n        let data = try Data(contentsOf: url)\n        return .success(data)\n    } catch {\n        return .failure(.requestFailed)\n    }\n}\n\nlet result = fetchData(from: \"https://example.com/data\")\n\nswitch result {\ncase .success(let data):\n    print(\"데이터 수신 성공: \\(data)\")\ncase .failure(let error):\n    print(\"데이터 가져오기 실패: \\(error)\")\n}\n```\n\n이 예제에서 fetchData 함수는 가져온 데이터 또는 오류를 캡슐화하는 Result 타입을 반환합니다.\n\nAsync/Await으로 에러 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwift의 새로운 동시성 모델은 async/await를 도입하여 비동기 코드를 처리하기 쉬워졌어요. 이 문맥에서 오류를 처리하는 방법을 살펴봅시다.\n\nAsync/Await 예제\n\n```js\nenum NetworkError: Error {\n    case invalidURL\n    case requestFailed\n}\n\nfunc fetchData(from urlString: String) async throws -> Data {\n    guard let url = URL(string: urlString) else {\n        throw NetworkError.invalidURL\n    }\n\n    let (data, _) = try await URLSession.shared.data(from: url)\n    return data\n}\n\nfunc processData() async {\n    do {\n        let data = try await fetchData(from: \"https://example.com/data\")\n        print(\"Data fetched: \\(data)\")\n    } catch {\n        print(\"Failed to fetch data: \\(error)\")\n    }\n}\n\nTask {\n    await processData()\n}\n```\n\n이 예제에서 fetchData 함수는 비동기이며 오류를 던질 수 있습니다. 이 오류는 processData 함수 내에서 try-catch를 사용하여 처리됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 정의 오류 유형 만들기\n\n사용자 정의 오류 유형은 오류 처리를 더 정확하고 의미 있게 만들어줍니다.\n\n사용자 정의 오류 유형을 이용한 예제\n\n```js\nenum FileError: Error {\n    case fileNotFound\n    case unreadable\n    case encodingFailed\n}\n\nfunc readFile(named fileName: String) throws -> String {\n    guard let filePath = Bundle.main.path(forResource: fileName, ofType: nil) else {\n        throw FileError.fileNotFound\n    }\n\n    guard let data = FileManager.default.contents(atPath: filePath) else {\n        throw FileError.unreadable\n    }\n\n    guard let content = String(data: data, encoding: .utf8) else {\n        throw FileError.encodingFailed\n    }\n\n    return content\n}\n\ndo {\n    let content = try readFile(named: \"example.txt\")\n    print(\"파일 내용: \\(content)\")\n} catch {\n    print(\"파일 읽기 실패: \\(error)\")\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에서 FileError는 파일 작업과 관련된 특정 오류를 정의합니다. readFile 함수는 이러한 오류 유형을 사용하여 상세한 오류 정보를 제공합니다.\n\n에러 처리를 위한 최상의 모법\n\n- 기술적인 오류 유형 사용: 오류에 대한 의미 있는 컨텍스트를 제공하는 사용자 정의 오류 유형을 정의하세요.\n\n```swift\nenum ValidationError: Error {\n    case invalidEmail\n    case passwordTooShort\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 적절한 수준으로 오류 전파하기: 오류를 효과적으로 처리할 수 있는 적절한 수준으로 전파하십시오.\n\n```js\nfunc performOperation() throws {\n    try validateInput()\n    try processData()\n}\n```\n\n3. 우아한 복구: 가능한 경우에는 오류로부터 복구할 수 있는 전략을 구현하여 실패하는 것이 아닌 대처하십시오.\n\n```js\nfunc fetchData() async {\n    do {\n        let data = try await fetchData(from: \"https://example.com\")\n        process(data)\n    } catch {\n        recoverFromError(error)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 중앙 집중식 오류 로깅: 디버깅을 간소화하기 위해 오류를 기록하는 데 중앙 집중식 방법을 사용하세요.\n\n```js\nfunc logError(_ error: Error) {\n    // 모니터링 서비스나 콘솔에 오류 기록\n    print(\"오류: \\(error)\")\n}\n```\n\n5. 사용자 친화적인 오류 메시지: 사용자에게 명확하고 실행 가능한 오류 메시지를 제공하세요.\n\n```js\nfunc displayError(_ error: Error) {\n    let message: String\n    switch error {\n    case is NetworkError:\n        message = \"네트워크 오류가 발생했습니다. 나중에 다시 시도해 주세요.\"\n    default:\n        message = \"예기치 못한 오류가 발생했습니다.\"\n    }\n    showAlert(with: message)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결론\n\nSwift에서의 고급 오류 처리는 기본적인 try-catch 블록을 넘어서 Result 타입, async/await, 그리고 사용자 정의 오류 타입과 같은 강력한 기능을 활용합니다. 이러한 고급 기술을 채택함으로써 더 견고하고 가독성이 높고 유지보수가 용이한 코드를 작성할 수 있습니다. 효과적인 오류 처리는 응용 프로그램이 오류를 우아하게 처리하여 개발자와 사용자 모두에게 더 나은 경험을 제공할 수 있도록 합니다. 이러한 전략을 받아들여 Swift 개발 기술을 향상시키고 더 견고한 응용 프로그램을 구축하세요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png"},"coverImage":"/assets/img/2024-05-23-AdvancedErrorHandlinginSwiftBeyondTry-Catch_0.png","tag":["Tech"],"readingTime":7},{"title":"Swift에서의 유니트 테스트 시작 가이드","description":"","date":"2024-05-23 13:12","slug":"2024-05-23-UnitTestinSwiftAStartingGuide","content":"\n# iOS 프로젝트에 단위 테스트 추가하는 방법과 테스트에 관한 주요 개념 배우기\n\n![image](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_0.png)\n\n버그를 고치는 걸 좋아하시나요?\n\n확실히 싫어하시죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 적절한 유닛 테스트 구조를 갖는 것은 미래에 머리 아픈 문제를 피하는 데 도움이 됩니다.\n\n단위 테스트는 당신이 만든 모든 변경 사항 후에 코드가 여전히 예상대로 작동하는지 확인하고, 새 코드를 프로덕션 환경에 배포할 때 더 확신을 갖게 해주며, 전체 코드 품질을 향상시키고, 코드베이스 복잡성을 줄이는 등의 암묵적인 이점이 있습니다.\n\n이제 테스트의 주요 개념과 iOS 프로젝트에 어떻게 추가하는지 알아봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단위 테스트란 무엇인가요?\n\n우리가 함께 이야기할 때, 단위 테스트는 우리 애플리케이션 코드의 작은, 독립적이며 명확한 블록(유닛이라고도 함)이 예상대로 작동하는 지를 확인하는 코드 조각들이라고 말할 수 있어요.\n\n### 테스트 구조\n\n코딩 부분으로 바로 들어가기 전에 이해해야 할 여러 구성 요소가 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![UnitTestinSwiftAStartingGuide_1.png](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_1.png)\n\n- 테스트 메소드는 코드 일부를 유효성 검사하는 메소드입니다. 여기서 우리는 테스트를 생성하고 개발합니다. 이러한 메소드는 테스트 결과를 생성하며, 통과하거나 실패할 수 있습니다.\n- 테스트 클래스는 테스트 메소드의 집합입니다. 일반적으로 특정 로직을 테스트하는 데 사용되며, 예를 들어 인증(Authentication)을 그룹화합니다.\n- 테스트 번들에는 테스트 클래스의 집합이 포함되며, 두 가지 테스트 유형 중 하나인 Unit 또는 UI를 나타냅니다.\n- 테스트 계획은 테스트 번들의 집합이며, 여기에는 Unit 및 UI 테스트를 모두 포함할 수 있습니다. 테스트 계획에서는 테스트 실행 시 고려해야 할 구성 목록을 설정합니다.\n\n# 테스트 번들 생성으로 시작\n\n`파일` -> `새로 만들기` -> `타겟`으로 이동하여 Unit Testing Bundle을 검색합니다. 대상에 적절한 이름을 지정하고 일반적으로 앱 이름 뒤에 Tests로 끝납니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트 번들을 만들면 기본 구성으로 테스트 계획이 자동으로 생성됩니다.\n\n![Unit Testing in Swift: A Starting Guide](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_2.png)\n\n# 단위 테스트 설정하기\n\n모든 프로그래밍 언어에는 단위 테스트를 실행하기 위한 프레임워크나 라이브러리가 있습니다. iOS 개발 환경에서는 XCTest 프레임워크를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 테스트 번들이 준비되었으니 새로운 테스트 클래스를 추가할 수 있습니다. 네비게이션 패널이나 메뉴(File -> File -> Unit Test Case Class)를 통해 새로 만들어주세요.\n\nOrderManager 클래스 뒤에 있는 로직을 테스트하기를 원하므로, 테스트 클래스의 좋은 이름은 OrderTests가 될 것 같아요.\n\n```js\n// 새 주문 추가\nfunc add(_ order: Order) throws { ... }\n// 마지막 주문을 반복하며 주문 목록에 추가\nfunc repeatLastOrder() { ... }\n```\n\n테스트 클래스 안에 각 함수마다 테스트 메소드를 만들어봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱의 코드에 접근하지 않고 파일 단위로 공유하지 않고 테스트 대상에서 앱의 코드에 액세스하려면 @testable 지시문을 추가하고 앱을 가져와야 합니다.\n\n```swift\nimport XCTest\n@testable import Coffee_Shop_App\n\nfinal class OrderTests: XCTestCase {\n\n    override func setUpWithError() throws {}\n    override func tearDownWithError() throws {}\n\n    func testAddNewOrder() {}\n    func testRepeatLastOrder() {}\n}\n```\n\n<img src=\"/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_3.png\" />\n\n각 테스트가 시작하기 전에 XCTest는 setUpWithError() 함수를 실행합니다. 따라서 여기서 테스트의 초기 상태를 설정해야 합니다. 특정 클래스의 인스턴스 생성, 의존성 주입, 변수 값 구성 등이 될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트가 끝난 후에는 tearDownWithError()가 호출됩니다. 여기서 우리가 고려하는 모든 것을 정리하기에 좋은 장소입니다.\n\n## 이제 Unit Tests를 작성하기 시작할 준비가 모두 완료되었습니다\n\n먼저, OrdersManager에 액세스해야 합니다.\n\n- 클래스에 속성을 추가합니다.\n- setUpWithError() 메서드에서 인스턴스를 만듭니다.\n- tearDownWithError() 메서드에서 상태를 정리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@testable import Coffee_Shop_App\n\nfinal class OrderTests: XCTestCase {\n  private var ordersManager: OrdersManager!\n\n  override func setUpWithError() throws {\n    ordersManager = OrdersManager.shared\n  }\n\n  override func tearDownWithError() throws {\n    ordersManager.removeAllOrders()\n    ordersManager = nil\n  }\n\n  func testAddNewOrder() {}\n  func testRepeatLastOrder() {}\n}\n```\n\n만약 단위 테스트를 시작한다면, 'Arrange / Act / Assert' 패턴을 사용하는 것이 좋은 초보자를 위한 초기 단계입니다. 이 패턴을 사용하여 테스트를 다음과 같이 분해하시면 됩니다:\n\n- Arrange → 테스트가 사용할 모든 필요한 객체나 데이터를 생성합니다.\n- Act → 테스트하려는 메서드나 함수를 실행합니다.\n- Assert → 얻은 결과를 기대한 결과와 비교합니다.\n\n```kotlin\nfinal class OrderTests: XCTestCase {\n  private var ordersManager: OrdersManager!\n\n  override func setUpWithError() throws {\n    ordersManager = OrdersManager.shared\n  }\n\n  override func tearDownWithError() throws {\n    ordersManager.removeAllOrders()\n    ordersManager = nil\n  }\n\n  func testAddNewOrder() {\n    // 1 - Arrange\n    let orderItems: [OrderItem] = [\n      .init(item: AnyMenuItem(Coffee.flatwhite), size: .regular, quantity: 1),\n      .init(item: AnyMenuItem(Food.chickenSandwich), size: .regular, quantity: 1),\n    ]\n    let order = Order(items: orderItems)\n\n    // 2 - Act\n    try? ordersManager.add(order)\n\n    // 3 - Assert\n    XCTAssertEqual(ordersManager.orders.count, 1)\n  }\n\n  func testRepeatLastOrder() {\n    // 1 - Arrange\n    let orderItems: [OrderItem] = [\n      .init(item: AnyMenuItem(Coffee.flatwhite), size: .regular, quantity: 1),\n      .init(item: AnyMenuItem(Food.chickenSandwich), size: .regular, quantity: 1),\n    ]\n\n    // 2 - Act\n    let order = Order(items: orderItems)\n    try? ordersManager.add(order))\n    ordersManager.repeatLastOrder()\n\n    // 3 - Assert\n    XCTAssertEqual(ordersManager.orders.count, 2)\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Xcode에서 단위 테스트 직접 실행하기\n\n구성 세트에 포함된 모든 테스트, 테스트 번들에 포함된 모든 테스트, 테스트 클래스에 포함된 모든 테스트, 일부 특정 테스트 메서드의 그룹 또는 한 번에 하나의 테스트 메서드를 실행할 수 있습니다.\n\n테스트를 실행한 후에는 결과가 포함된 테스트 보고서를 받을 수 있습니다. 또한 Test 네비게이터 및 테스트 클래스 내에서 테스트 결과를 직접 확인할 수 있습니다.\n\n![image](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 테스트 커버리지\n\n테스트를 실행한 후에 테스트 커버리지 정보를 활성화할 수 있습니다. 시험한 코드 안에서 테스트 된 코드 부분을 볼 수 있습니다.\n\n![unit test](/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_5.png)\n\n녹색으로 표시된 부분은 최근 테스트 실행에서 도달한 코드 부분이고, 빨간색으로 표시된 부분은 도달하지 못한 코드 부분입니다. 데모에서 주문 최소 금액을 확인하는 부분이 누락되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 이 시나리오를 발견하면, 새로운 유닛 테스트를 추가해서 이를 확인하고 테스트를 다시 실행할 수 있어요.\n\n# 다른 XCTAssert 사용\n\n테스트 결과를 확인할 때 사용할 수 있는 다양한 함수들이 있어요. 몇 가지 예시를 보여드릴게요.\n\n```js\n// 1 - throw 함수가 예외를 발생시키지 않는지 확인\nXCTAssertNoThrow(try ordersManager.add(order))\n\n// 2 - throw 함수가 에러를 발생시키는지 확인\nXCTAssertThrowsError(try ordersManager.add(order)) { error in\n  if let appError = error as? AppError, let errorType = appError.type as? OrderError {\n    XCTAssertEqual(errorType.code, 2)\n  } else {\n    XCTFail(\"잘못된 에러 유형이 트리거됐어요\")\n  }\n}\n\n// 3 - 옵셔널 값이 nil이 아닌지 확인\nlet lastCoffeeDescription = ordersManager.getLastCoffee()\nXCTAssertNotNil(lastCoffeeDescription)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nXCTAssertEqual(\n  ordersManager.orders.count,\n  1,\n  \"주문이 올바르게 추가되지 않았습니다\"\n);\n```\n\n# 명심해야 할 점\n\n- 버그를 수정하는 것보다 테스트를 작성하는 데 시간을 소비하는 것이 항상 좋습니다.\n- 단위 테스트를 추가하는 것을 추가 작업으로 보지 마세요. 개발 과정의 일부로 테스트를 추가하려고 노력하세요.\n- FIRST 원칙을 기억하세요. 모든 단위 테스트는 빠르고 독립적이며 반복 가능하며 자가 검증 가능하며 적시성을 가져야 합니다.\n- 테스트가 실패하면 조심해야 합니다. 테스트를 적응시키려고 할 수 있습니다. 그러나 이는 일부 경우에는 올바를 수 있지만 (테스트가 잘못 작성된 경우) 대게 테스트하려는 논리가 잘못된 것입니다.\n- 100%의 테스트 커버리지를 추구하지 마세요. 100%의 커버리지가 있더라도 10가지 가능한 시나리오 중 1개에 대한 테스트만 있는 경우가 있습니다. 대신 품질 높은 테스트를 작성하는 데 중점을 두세요.\n- 테스트를 사용하여 전체적인 코드 품질을 높일 수 있는 작은 코드 리팩터링을 찾을 수 있는 기회로 활용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n질문이 있으시면 언제든지 메시지 보내주세요! 🙂\n\n- 🤓 iOS 개발 팁 및 통찰력이 담긴 규칙적인 콘텐츠를 보려면 X에 들러주세요.\n- 🚀 제 GitHub에서 제 예제 프로젝트를 모두 공유하고 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_0.png"},"coverImage":"/assets/img/2024-05-23-UnitTestinSwiftAStartingGuide_0.png","tag":["Tech"],"readingTime":10},{"title":"SwiftUI 네비게이션 - 코디네이터 패턴 - 파트 3 시트, FullscreenCover","description":"","date":"2024-05-23 13:10","slug":"2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover","content":"\n![이미지](/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png)\n\n이 글은 이전 글들을 이어서 작성되었으며, 그 위에 쌓아 올릴 것입니다.\nSwiftUI 네비게이션 파트 1 — 푸시 네비게이션\nSwiftUI 네비게이션 파트 2 — 알림\n\n이 글에서는 Sheets 및 FullscreenCovers을 동시에 다룰 것이며, 이들은 동일한 방식으로 구현됩니다.\n\n시작해 봅시다! 이전 글들에서는 결정적 목적지로 조정하기 위해 Routes를 사용했습니다. 그러나 SwiftUI는 어떻게 이루어지는 걸까요?\n뷰 계층 구조의 루트에 있는 NavigationStack에 대한 네비게이션 경로에 대한 바인딩이 있습니다. Apple의 문서 예제를 살펴보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nNavigationStack(path: $presentedParks) {\n    List(parks) { park in\n        NavigationLink(park.name, value: park)\n    }\n    .navigationDestination(for: Park.self) { park in\n        ParkDetails(park: park)\n    }\n}\n```\n\n우리는 NavigationStack 라는 뷰가 있습니다. 이 뷰를 통해 일부 데이터 유형의 바인딩을 통해 .navigationDestination이라는 뷰 수정자에서 제공된 뷰로 이동할 수 있습니다 🤔 어떻게 보면 흥미로운 것 같네요.\n\n그럼 이 뷰 수정자가 무엇인지 궁금하죠? 프레임워크 문서에서 더 자세히 살펴봐 봅시다.\n\n```js\n/// 스택에 한 개 이상의 네비게이션 대상 수정자를 추가할 수 있습니다.\n/// 여러 데이터 유형을 표시해야 하는 경우 스택에 네비게이션 대상 수정자를 여러 개 추가할 수 있습니다.\n///\n/// \"List\" 또는 \"LazyVStack\"과 같은 \"lazy\" 컨테이너 내부에 네비게이션 대상 수정자를 넣지 마세요.\n/// 이러한 컨테이너는 화면에 렌더링할 때 필요한 경우에만 자식 뷰를 생성합니다.\n/// 항상 네비게이션 대상 수정자를 이러한 컨테이너 외부에 추가하여 네비게이션 스택이 대상을 항상 볼 수 있도록 하세요.\n///\n/// - Parameters:\n///   - data: 이 대상이 일치하는 데이터의 유형입니다.\n///   - destination: 스택의 네비게이션 상태에 유형 'data'의 값을 포함하고 있을 때 표시할 뷰를 정의하는 뷰 빌더입니다.\n///     클로저는 데이터 값을 나타내는 하나의 인수를 사용합니다.\npublic func navigationDestination<D, C>(for data: D.Type, @ViewBuilder destination: @escaping (D) -> C) -> some View where D : Hashable, C : View\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뭐 이건 Data.Type을 받아들이는 ViewModifier인데, 그런 다음에 destination이라고 불리는 클로저가 주입되는데, 이 클로저는 hashable해야 할 that Data.Type의 인스턴스를 주입하고 구체적인 View를 반환해야 해요...... 그렇죠. 😵\n\n또 다른 것은 .navigationDestination(\\_:)이 NavigationStack 내부의 View에 적용되어야 하며, NavigationStack의 범위 외부에 적용할 수 없다는 것을 주의해야 해요. 🤔\n\n뷰 계층 구조를 통해 데이터를 상위 뷰로 전파하는 유사한 시그니처를 가진 다른 것이 있어요. 이것이 바로 데이터를 뷰의 부모에게 전달하는 데 사용되는 PreferenceKeys입니다!\n\nPreferenceKeys를 사용하여 .navigationDestination(\\_:)이 NavigationStack에 하는 것처럼 내비게이션 목적지를 전달할 수 있을까요?\n우리는 곧 알게 될 거예요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시트 및 풀스크린 커버의 ViewModifier를 검사해 봅시다.\n\n```js\n    public func sheet<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View\n\n    public func fullScreenCover<Item, Content>(item: Binding<Item?>, onDismiss: (() -> Void)? = nil, @ViewBuilder content: @escaping (Item) -> Content) -> some View where Item : Identifiable, Content : View\n```\n\n이들은 서로 거의 동일하며 navigationDestination(\\_:)과도 매우 유사합니다. 주요 차이점은 나타낼 아이템에 대한 바인딩이 Hashable 대신 Identifiable을 준수해야 하며 전달할 수 있는 선택적인 onDismiss 클로저가 있는 것입니다.\n\nRoutes도 Identifiable을 준수하도록 만들어 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable { // <-- Identifiable\n    var id: String { String(describing: self) }\n\n    case detailView\n    case secondDetailView(String)\n}\n```\n\n이제 루트를 처리하는 ViewModifier를 만들어야 합니다. navigationDestination(_:)가 어떻게 작동하는지 더 잘 이해하려고 했고, navigationDestination(_:)와 동일하게 목적지를 뷰 계층 구조로 전달할 수 있는 방법을 재현해 볼 수 있을지 생각했습니다.\n\n내가 알기로는 뷰 계층 구조로 데이터를 전송하는 유일한 방법은 PreferenceKeys이니까 그것부터 시작하겠습니다.\n그러나 몇 가지 기준이 있습니다. 어떤 경로에 대해서도 작동하고 다른 경로에 대한 모든 목적지를 해결할 수 있어야합니다. 이 기준으로 인해 타입 지워를 사용해야 합니다. 다음과 같이 PreferenceKeys를 생성해 봅시다.\n\n```js\nstruct SheetFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -> [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } } // reduce all into one value (dictionary)\n}\n\nstruct CoverFactoryKey: PreferenceKey {\n    static var defaultValue: [String: NavigationViewFactory] = [:]\n    static func reduce(value: inout [String: NavigationViewFactory], nextValue: () -> [String: NavigationViewFactory]) { value.merge(nextValue()) { $1 } }\n}\n\nextension View {\n    public func sheetDestination<D,C>(for data: D.Type, @ViewBuilder sheet: @escaping (D) -> C) -> some View where D: Identifiable & Hashable, C : View  {\n        preference(key: SheetFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, sheet)]) // <- Here we set the key to the data type's description! and pass our view factory\n    }\n\n    public func coverDestination<D,C>(for data: D.Type, @ViewBuilder cover: @escaping (D) -> C) -> some View where D: Identifiable & Hashable, C : View  {\n        preference(key: CoverFactoryKey.self, value: [String(describing: data): NavigationViewFactory(data, cover)])\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네비게이션 목적지()가 sheetDestination()와 coverDestination() 선호 키 모두 호출자의 모든 값을 하나의 [String: NavigationViewFactory] 사전으로 줄입니다.\n\n기본적으로 여러 Coordinator가 있는 경우 각각이 자체 경로 유형을 위해 sheetDestination() 선호 키를 사용합니다. 이것은 PreferenceKeys에서 보내진 모든 값들을 하나의 사전으로 병합/줄이고, 문자열 키를 사용하여 작업하는 데이터 유형에 대한 식별자로 사용할 수 있습니다. 따라서 뷰 계층 구조를 통해 전달된 대응하는 예상 값에 접근할 수 있습니다. 이 값은 해당 목적지를 반환하는 데 도움이 됩니다.\n\n여기에는 데이터 유형을 설명하는 ID와 AnyView를 반환하는 타입 지워진 NavigationViewFactory가 있습니다.\nAnyView는 SwiftUI에서 제공되는 타입 지워진 뷰 래퍼로 성능에 부담이 있으므로 절약해서 사용해야 합니다. 그러나 한 번에 하나의 시트나 커버만 표시할 수 있기 때문에 수용할만한 것으로 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNavigationController로 다시 가서 코드를 추가해 봅시다.\n\n```js\n@Observable final class NavigationController {\n    var navigationPath = NavigationPath()\n    var alertPath = AlertPath()\n    var sheetPath: SheetPath = .init() // <- SheetPath를 생성해 봅시다\n    var coverPath: CoverPath = .init() // <- CoverPath를 생성해 봅시다\n\n    func presentSheet<T>(_ route: T, onDismiss: (() -> Void)? = nil)  where T: Codable & Identifiable & Hashable  {\n        sheetPath.setSheet(route, onDismiss: onDismiss)\n    }\n\n    func presentCover<T>(_ route: T, onDismiss: (() -> Void)? = nil)  where T: Codable & Identifiable & Hashable  {\n        coverPath.setCover(route, onDismiss: onDismiss)\n    }\n}\n\n// Sheet\nstruct SheetPath: Identifiable {\n    var id: String { sheet?.id ?? UUID().uuidString } // <- 현재 sheet의 id를 사용합니다.\n    var sheet: SheetContainer?\n\n    mutating func setSheet<T>(_ sheet: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.sheet = SheetContainer(sheet, onDismiss: onDismiss)\n    }\n}\n\nstruct SheetContainer: Identifiable {\n    let id: String\n    let sheet: Any\n    let onDismiss: (() -> Void)?\n\n    init<T>(_ sheet: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.id = String(describing: T.self)\n        self.sheet = sheet\n        self.onDismiss = onDismiss\n    }\n}\n\n// Fullscreen Cover\nstruct CoverPath: Identifiable {\n    var id: String { cover?.id ?? UUID().uuidString }\n    var cover: CoverContainer?\n\n    mutating func setCover<T>(_ cover: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.cover = CoverContainer(cover, onDismiss: onDismiss)\n    }\n}\n\nstruct CoverContainer: Identifiable {\n    let id: String\n    let cover: Any\n    let onDismiss: (() -> Void)?\n\n    init<T>(_ cover: T, onDismiss: (() -> Void)? = nil) where T: Codable & Identifiable & Hashable  {\n        self.id = String(describing: T.self)\n        self.cover = cover\n        self.onDismiss = onDismiss\n    }\n}\n```\n\n이 두 가지 구현 사항은 기본적으로 동일하며 같은 컨테이너, 경로, 함수 뷰 수정자 등을 사용하고 열거형 PresentationMode를 추가하여 sheet와 cover를 구분할 수 있는 case를 추가할 수 있습니다. 그러나 일관성을 유지하기 위해 이 예제에서는 이들을 분리해 두었습니다. 또한 SwiftUI가 이후에 여러 개의 sheet/cover를 지원한다면 별도로 처리하고자 할 수도 있습니다. 선택은 당신에게 맡깁니다. 지금까지 어떤 것들을 얻었나요?\n\n- NavigationController에는 이제 sheet 및 fullScreenCover에 대한 경로가 있습니다.\n- 우리는 데이터 작업의 구체적인 유형을 지우기 위해 타입 이레이저를 사용하지만, 우리가 수용할 수 있는 유형으로만 컨테이너를 초기화할 수 있도록 하여, 지워진 타입 값은 일종의 Identifiable, Hashable 및 Codable 유형이 되도록 보장합니다.\n- 또한, 해당 데이터 유형의 설명을 Identifiable 준수를위한 식별자로 저장하여 우리의 뷰 팩토리 콜백 딕셔너리에서 구분할 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여전히 함께 계신다니 너무 기쁘네요! 이제 모든 것을 함께 연결해보려 합니다.\n\n이제 시트를 표시하는 ViewModifier를 만들어야 합니다.\n\n```js\nextension View {\n    func sheet(for sheetPath: Binding<SheetPath>) -> some View {\n        modifier(SheetModifier(sheetPath: sheetPath))\n    }\n\n    func cover(for data: Binding<CoverPath>, onDismiss: (() -> Void)? = nil) -> some View {\n        modifier(CoverModifier(data: data))\n    }\n}\n\nstruct SheetModifier: ViewModifier {\n    @Binding var sheetPath: SheetPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -> Void)?\n\n    init(sheetPath: Binding<SheetPath>) {\n        self._sheetPath = sheetPath\n        self.onDismiss = sheetPath.wrappedValue.sheet?.onDismiss\n    }\n\n    func body(content: Content) -> some View {\n        content\n            .onPreferenceChange(SheetFactoryKey.self) { factories = $0 }\n            .sheet(item: _sheetPath.sheet, onDismiss: sheetPath.sheet?.onDismiss, content: { factories[sheetPath.id]?.factory($0.sheet) })\n    }\n}\n\nstruct CoverModifier: ViewModifier {\n    @Binding var data: CoverPath\n    @State private var factories: [String: NavigationViewFactory] = [:]\n    private let onDismiss: (() -> Void)?\n\n    init(data: Binding<CoverPath>) {\n        self._data = data\n        self.onDismiss = data.wrappedValue.cover?.onDismiss\n    }\n\n    func body(content: Content) -> some View {\n        content\n            .onPreferenceChange(CoverFactoryKey.self) { factories = $0 }\n            .fullScreenCover(item: _data.cover, onDismiss: data.cover?.onDismiss, content: { factories[data.id]?.factory($0.cover) })\n    }\n}\n```\n\n이게 뭐하는 거야? 모든 .sheetDestination()를 사용하는 코디네이터는 경로에 해당하는 코디네이션 함수를 뷰 계층 구조에 전달합니다. 그리고 sheetPath에 값을 설정하면 동일한 데이터 유형에 대한 viewFactory를 추출하고 데이터 인스턴스를 주입하여 메서드를 호출하여 대상을 반환할 것입니다. 모두 어떻게 함께 작동하는지 예제를 살펴봅시다.\n\n```js\nenum FirstTabCoordinatorRoute: Codable, Hashable, Identifiable {\n    var id: String { String(describing: self) }\n    ... 이전 경로들\n\n    case sheet // 선택 사항으로 연결된 값 전달 가능\n    case cover\n}\n\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor var rootView: some View {\n        let viewModel = FirstViewModel(self)\n        FirstView(viewModel)\n            .navigationDestination(for: Route.self, destination: coordinate(_:))\n            .sheetDestination(for: Route.self, sheet: coordinate(_:))\n            .coverDestination(for: Route.self, cover: coordinate(_:))\n    }\n\n    func presentSheet(onDismiss: (() -> Void)? = nil) {\n        navigationController.presentSheet(Route.sheet, onDismiss: onDismiss)\n    }\n\n    func presentCover(onDismiss: (() -> Void)? = nil) {\n        navigationController.presentCover(Route.cover, onDismiss: onDismiss)\n    }\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -> some View {\n        switch route {\n            ... 이전 경로들\n\n            case .sheet: SomeBranchedView()\n            case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n와, 정말 깔끔하네요!\nrootView 계산 속성 내에서 PreferenceKeys를 설정하여 모든 정보가 코디네이터의 Route.Types를 해결하는 데 필요한 정보를 코디네이트(coordinates) 함수로 보냅니다. 이 함수는 특정 코디네이터가 좌표를 맡은 모든 뷰를 생성합니다. 🤔 꽤 괜찮죠.\n\n```js\nstruct CoordinatedView<C: Coordinator>: View {\n    private let coordinator: C\n\n    init(_ coordinator: C) {\n        self.coordinator = coordinator\n    }\n\n    var body: some View {\n        @Bindable var navigationController = coordinator.navigationController\n        NavigationStack(path: $navigationController.navigationPath) {\n            coordinator.rootView\n        }\n        .sheet(for: $navigationController.sheetPath)\n        .cover(for: $navigationController.coverPath)\n        .alert(for: $navigationController.alertPath)\n    }\n}\n```\n\n마지막으로 루트 CoordinatedView에 sheet 또는 cover를 적용하는 방법에 대해 다음과 같이 살펴보겠습니다. 이것도 꽤 깔끔하네요 😉\n\n그러니까 이 경우를 위해 우리의 view와 viewModel을 검사해봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct FirstView: View {\n    let viewModel: FirstViewModel\n\n    var body: some View {\n        VStack {\n            Text(\"First View\")\n            Button(\"상세 화면으로 이동\") {\n                viewModel.didTapButton()\n            }\n        }\n    }\n}\n\n@Observable class FirstViewModel {\n\n    private let coordinator: FirstTabCoordinator\n\n    init(coordinator: FirstTabCoordinator) {\n        self.coordinator = coordinator\n    }\n\n    func didTapButton() {\n        coordinator.presentSheet {\n          // closure called onDismiss\n        }\n    }\n}\n```\n\n우리의 뷰는 didTapButton 이외에 무슨 일이 벌어지고 있는지 알 수 없습니다.\n\nℹ️ 또한 다른 필요한 수식어(modifier)들이 coordinate() 함수에서 반환되기 전에 뷰에 적용될 수 있습니다.\n\n예를 들어, 시트에 presentationDetents를 적용하려면. 그리고 뷰 내부에서 심지어 그것에 대해 알 필요조차 없을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n@Observable final class FirstTabCoordinator: Coordinator {\n    ... 이전 코드\n\n    @ViewBuilder @MainActor func coordinate(_ route: Route) -> some View {\n        switch route {\n         ... 이전 루트\n\n        case .sheet: SomeBranchedView().presentationDetents([.medium, .large]) // 시트를 반으로 크기 조정하고 드래그 액션 등을 허용합니다.\n        case .cover: SomeCoverView()\n        }\n    }\n}\n```\n\n지금은 여기까지입니다.\n\n이 글에서 어떤 통찰을 얻으셨다면 좋겠네요. 피드백이나 개선 제안이 있다면 알려주세요. 이 글이 가치 있다고 느끼신다면 공유해주세요!\n\n즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png"},"coverImage":"/assets/img/2024-05-23-SwiftUINavigationThecoordinatorpatternpart3SheetFullscreenCover_0.png","tag":["Tech"],"readingTime":16}],"page":"74","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}