{"pageProps":{"posts":[{"title":"Read the Docs 트래픽 분석을 위해 Vizro-AI를 활용한 재사용 가능한 대시보드를 구축했어요","description":"","date":"2024-05-17 19:00","slug":"2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI","content":"\n## (50 줄 미만의 코드로)\n\n<img src=\"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_0.png\" />\n\n이 글에서는 기술 작성자로서 유지 관리하는 문서의 트래픽 데이터를 시각화하기 위해 대시보드를 구축하는 방법을 설명하겠습니다. 디자인 스킬이 부족하고 파이썬 경험이 제한적이어서 유지하는 문서의 영향과 사용량을 보여주기 위한 간단하고 로우코드 접근 방식이 필요했습니다. 이것은 오픈 소스 솔루션인 비즈로(Vizro)를 로우코드 대시보드의 템플릿으로 사용하고, 비즈로-AI(Vizro-AI)를 통해 생성적 AI로 개별 차트를 구축하는 것으로 나타났습니다.\n\n## 요약?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 당신이 바로 시작하고 싶다면, 내 GitHub 레포지토리에서 대시보드에 대한 Jupyter Notebook 코드를 찾을 수 있어.\n\n## Read the Docs 대시보드 프로젝트\n\n만약 나와 같이 Read the Docs (RTD)를 사용하여 오픈 소스 문서 프로젝트를 관리한다면, 아마도 프로젝트 대시보드에서 지난 90일치의 트래픽 데이터를 CSV 형식으로 다운로드할 수 있는 것을 발견했을 것입니다. 대시보드에는 페이지 뷰 합계 차트도 표시되어 있습니다, 아래와 같은 차트가 있죠.\n\n![RTD Traffic Chart](/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n추가적인 시각적 출력을 위해 Google Analytics (GA)를 활용할 수 있습니다. 그러나 일부 프로젝트에서는 유럽 연합(EU)에서 특히 논란이 되는 일반 데이터 보호 규정(GDPR)과의 준수 때문에 GA를 사용하지 않기를 선호하기도 합니다.\n\n## 코드 및 데이터 가져오기\n\n아래 예시에서 사용된 가짜 CSV 트래픽 데이터는 저희 프로젝트의 트래픽을 비공개로 유지하기 위해 OpenAI의 도움을 받아 생성한 것입니다. 이 가짜 데이터는 진짜 RTD 데이터와 동일한 필드를 가지고 있어서 RTD 대시보드에서 다운로드한 데이터로 대시보드를 다운로드하고 사용할 수 있습니다.\n\n예시를 직접 실행하려면 가짜 데이터(또는 직접 다운로드한 데이터)와 Jupyter Notebook 코드가 필요합니다. 이는 기본 수준에서 쉽게 진행할 수 있지만 보다 고급 사용자는 확장할 수 있습니다. 개선된 버전을 만드신 경우 알려주시면 감사하겠습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Vizro와 Vizro-AI란 무엇인가요?\n\nVizro는 Plotly와 Dash를 기반으로 한 프레임워크로, 사용자 정의 대시보드 레이아웃을 지정하기 위해 구성 접근법을 사용합니다. Vizro 대시보드는 Vizro와 별도로 구성된 Vizro-AI가 생성한 차트로 채울 수 있습니다. Vizro-AI는 시각화 프로세스를 단순화하기 위해 생성적 AI를 활용하는 독립적인 패키지입니다.\n\n이 예에서, 저는 데이터와 자연어 지시사항을 제공했고, Vizro-AI가 Python 코드를 생성하고 요청한 차트를 생성했습니다. 이것은 저에게 쓰기 작업을 하는 측면에서 잘 작동했습니다. 왜냐하면 저는 프론트엔드 디자인 기술이 없고 Plotly를 잘 모르기 때문입니다. 하지만 OpenAI로부터 적절한 생성적 AI 프롬프트를 작성하고 차트를 얻는 것도 즐거운 일이라고 생각합니다.\n\n## Vizro-AI 설정하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트북 코드를 실행하기 전에 Vizro-AI를 Python 3.9 이상의 가상 환경 안에 설정해야 합니다. pip install vizro_ai 명령을 사용하여 패키지를 설치해주세요.\n\n다음으로 OpenAI에 접속하기 위해 API 키가 필요합니다. 계정이 없다면 먼저 생성하고, 무료 버전을 사용할 수 없기 때문에 모델을 이용하기 위해 일부 크레딧을 구매해야 합니다. API 키를 생성하고 환경에 추가하여 코드를 통해 OpenAI에 성공적으로 호출할 수 있게 해주세요. OpenAI 문서에 간단한 지침이 있고, Vizro-AI LLM 설정 가이드에도 이 과정이 포함되어 있습니다.\n\n## 차트 생성\n\n이 시점에서 주피터 노트북을 열어 첫 차트를 만들거나, 제 저장소에서 노트북을 열어 내가 작성한 코드를 차례로 살펴보고, RTD 데이터(또는 제공한 가짜 데이터)를 pandas DataFrame에 불러와주세요. 아래 코드에서는 df로 이름을 지었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 코드는 Vizro-AI에 요청을 제출하여 Read the Docs 프로젝트 대시보드의 차트와 유사한 차트를 생성하는 방법을 보여줍니다. 이 차트는 날짜별 조회수를 보여주며 문서의 안정 버전과 최신 버전으로 데이터를 분할하여 두 개의 추적 값으로 나뉩니다:\n\nVizro-AI는 \"가장 최신 및 안정 버전의 각 날짜별 조회 수 행을 결합한 후 가장 최신 및 안정 버전의 조회수를 비교하는 선 그래프를 그리세요\"라는 자연어 쿼리와 데이터프레임을 모델에 전달합니다. 위 예제에서는 gpt-4 모델을 지정했습니다. Vizro-AI는 가격이 낮고 더 빠른 답변을 제공하기 위해 기본적으로 gpt-3.5-turbo를 사용하지만, 가장 정교한 차트 제공이 불가능합니다. 그래서 명시적으로 gpt-4 모델을 사용할 것을 요청했습니다.\n\n차트 출력은 데이터 및 쿼리 제출 시점에서 OpenAI로부터 받은 출력에 따라 달라집니다. explain=True 매개변수는 Vizro-AI에게 결과 차트 생성 방식을 설명하도록 요청하며, 해당 설명은 쥬피터 노트북에서 출력되며 show() 명령어에 의해 표시되는 차트와 함께 표시됩니다.\n\nVizro-AI가 제공하는 인사이트 텍스트는 트래픽 데이터 조작 방법을 설명합니다. 코드 섹션은 코드 스니펫이 요청된 선 그래프를 생성하는 방법에 따라 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_2.png\" />\n\n아래에 표시된 차트는 다음과 같습니다:\n\n<img src=\"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_3.png\" />\n\n## 더 많은 차트 만들기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVizro-AI가 제공하는 코드를 활용하여 추가 차트를 작성했습니다. 다음과 같이 교통량을 자세히 설명하는 몇 가지 차트를 작성했습니다.\n\nVizro-AI가 데이터를 조작하고 차트를 생성하는 코드를 생성해 주어서 작업을 간편하게 해 주었습니다. 차트 자체만으로 유용하며, 더욱 유용한 것은 이를 조합하여 한 화면에 통합된 대시보드를 만드는 것입니다.\n\n## Vizro 대시보드 만들기\n\nVizro-AI 코드와 동일한 Jupyter Notebook에서 Vizro를 사용할 수 있습니다. Vizro 설명서에 설명된대로 pip install vizro를 수행해 주세요. 여기에는 차트 생성이 없는 간단한 대시보드의 구조를 위한 코드가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 시점에서 두 가지 옵션이 있습니다:\n\n- 대시보드를 생성할 때마다 Vizro-AI를 사용하여 차트를 생성합니다.\n- Vizro-AI가 반환한 Python 코드를 직접 Plotly로 호출합니다.\n\n첫 번째 옵션은 더 적은 코드를 필요로 하지만 반환 속도가 느리고 더 비싸며, Vizro-AI를 사용하여 OpenAI를 호출하기 때문에 더 많은 비용이 소요됩니다. 두 번째 옵션은 더 빠르지만 코드 조작이 더 많이 필요합니다.\n\n다음은 대시보드 코드를 포함하는 셀입니다. 이 코드는 Vizro-AI를 통해 호출하는 함수를 사용하여 첫 번째 옵션을 보여줍니다. (자신의 실행을 계획하고 있다면, 이 코드를 실행하려면 내 레포지토리의 노트북을 사용하고 데이터를 로드하고 Vizro-AI에 대한 호출 설정을 설정하는 셀을 실행해야 합니다):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n약간 다른 버전을 제공해본다. 여기서 두 번째 옵션을 사용하여 차트 중 하나를 생성했다. Plotly 조작은 제한되어 있어서 Python 코드를 약간 수정하여 라인의 색을 변경했다. (여러분이 직접 실행하려는 경우, 내 저장소의 노트북을 사용하고 데이터를 로드하고 차트 생성 함수를 설정하는 셀을 실행했는지 확인하세요).\n\n자신만의 Read the Docs 데이터로 대시보드를 시도해보기 위해 주피터 노트북을 다운로드할 수 있어요. 제가 제공한 가짜 데이터로 만든 대시보드는 다음과 같이 보입니다.\n\n제 동료 중 한 명(Nadija 감사합니다!)가 제게 팁을 줬어요. 대시보드를 노트북에서 실행한 다음 다음과 같이 선택한 포트를 보고 별도의 브라우저 창에서 볼 수 있다고 해요:\n\n```js\nVizro().build(dashboard).run(port=8006) # 브라우저에서 localhost8006\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또 다른 방법(Anthony 님 감사합니다!)으로, 위의 두 번째 대시보드 예제에서 보여 드린 대로, 대시보드를 보기 위한 클릭 가능한 링크를 생성할 수 있습니다:\n\n```js\nVizro()\n  .build(dashboard)\n  .run((jupyter_mode = \"external\"));\n```\n\n# 마무리\n\n이 예에서는 Vizro-AI를 사용하여 문서 트래픽을 시각화하기 위한 Plotly 차트를 생성하고, 그 차트를 Vizro 대시보드에 구축하는 방법을 보여드렸습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 데이터 과학과 파이썬 기술이 있고 디자인에 재능이 있다면, Plotly와 Dash로 대시보드를 구축하는 도전에 도전해 보고 싶을 것입니다. 하지만 이런 기술이 없는 사람들에게는 OpenAI를 활용하여 위와 같은 결과물을 얻을 수 있다는 것이 정말 큰 변화입니다. 이제 50줄 정도의 코드로 Read the Docs 트래픽 데이터에 대한 유용한 시각화를 얻었습니다. 전문적으로 보이며 확장 가능하고 상대적으로 쉽게 공유할 수 있습니다. 추가적인 노력으로 필터, 매개변수 또는 별도의 탐색 가능한 페이지와 같은 사용자 정의 기능을 추가하여 더 개선할 수 있습니다.\n\n더 나아가, 동료들과 협업하여 대시보드 코드를 다른 Read the Docs 프로젝트에 맞게 수정할 수 있습니다. 프로젝트를 쉽게 설명하기 위해 주피터 노트북을 사용했지만, 이 방식은 파이썬 스크립트에서도 잘 작동하여 쉽게 공유하고 버전 관리를 할 수 있습니다. 또한 대시보드를 배포하여 동료들이 코드를 실행하지 않고 직접 액세스할 수도 있습니다.\n\n저희 팀은 이제 하루만에 기술 작가에 의해 구축된 문서 영향을 추적하는 데 유용하고 사용할 수 있는 대시보드를 소유하고 있습니다. 더 바랄 것이 무엇이 있을까요?\n\n이 글을 작성하는 동안 여러 차례 리뷰 피드백을 주신 동료들, 특히 Nadija와 Anna 그리고 Joe에게 감사드립니다.\n","ogImage":{"url":"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_0.png"},"coverImage":"/assets/img/2024-05-17-IBuiltaReusableDashboardforReadtheDocsTrafficAnalyticsUsingVizro-AI_0.png","tag":["Tech"],"readingTime":9},{"title":"마이크로소프트의 응용 프로그램 업데이트 접근 방식의 문제가 윈도우 PC에 혼란을 야기합니다","description":"","date":"2024-05-17 18:58","slug":"2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs","content":"\n![image](/assets/img/2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs_0.png)\n\n안녕하세요! WinRAR을 설치해 두셨나요? PC가 취약할 수 있습니다. 이 문제의 근본은 Windows 8로 돌아갑니다.\n\nChris Hoffman 작성\n\n여전히 적극적으로 악용되고 있는 방대한 보안 결함을 가진 WinRAR은 자동 업데이트를 지원하지 않는 많은 Windows 애플리케이션 중 하나입니다. 개발자는 전 세계적으로 5억 개 이상의 WinRAR 설치를 자랑하며, 따라서 수억 대의 PC가 오늘날 악성 ZIP 파일로부터 취약할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2023년에 세계에서 가장 인기 있는 데스크톱 운영 체제가 설치된 응용 프로그램을 쉽게 업데이트할 수 있는 방법을 제공하지 않는다니, 어떻게 된 일인가요?\n\nWindows 업데이트는 보안 패치를 설치하지만 여기서 그치고 있어요. 다운로드한 많은 응용 프로그램은 스스로 업데이트를 수행하지만 일부는 업데이트를 확인할 생각조차 못 합니다. Microsoft가 Windows 8을 만드느라 많은 시간을 낭비하고 나서 그 이후 Windows 10으로 넘어가며 거의 모든 Windows 사용자가 원하지 않았던 유형의 애플리케이션을 위한 스토어를 구축하려고 했으면, PC 사용자는 현명한 결정을 할 수 있었을 것입니다. Windows 스토어에 대해 잃어버린 십 년이었죠.\n\n# WinRAR이 공격 받고 스스로 업데이트하지 않아요\n\n파일 아카이빙 프로그램 WinRAR의 결함은 특수하게 디자인된 ZIP 아카이브를 다운로드하고 열면 공격자가 PC에서 원하는 코드를 실행할 수 있다는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공격자들이 2023년 초부터 이 버그를 악용해왔습니다. WinRAR 개발사 RARLAB은 8월에 이 취약점을 수정한 업데이트를 출시했지만, 수개월 후에도 여전히 이 버그에 대해 언급 중입니다. 왜냐하면 정부 지원 사이버 범죄 조직을 포함한 기관들이 여전히 이를 악용하고 있기 때문입니다. 이는 구글의 위협 분석 그룹에 따르면 \"여러 국가의 그룹들\"이라고 합니다.\n\n문제는요: WinRAR은 자동으로 업데이트되지 않습니다. 심지어 업데이트를 확인하고 사용자에게 중요한 보안 업데이트가 가능하다고 알리지도 않습니다. 많은 사람들이 오래된 업데이트되지 않은 버전의 WinRAR을 사용하고 있으며 이 패치를 설치하지 않을 것입니다. 새로운 PC를 구입하고 다시 설치할 때에만 안전한 버전의 WinRAR을 얻을 것입니다. 소망하기를 그들이 악의적인 ZIP 파일을 열지 않았으면 좋겠네요.\n\n# WinRAR이 자동 업데이트되지 않는 이유는?\n\n그렇다면 왜 자동 업데이트 기능이 없는 걸까요? 저는 RARLAB에 연락을 취해보았고 WinRAR 개발자인 Eugene Roshall은 Windows가 웹사이트에서 다운로드한 데스크톱 앱을 자동으로 업데이트할 수 있는 방법을 제공하지 않는다고 말했습니다. \"모든 개발자는 모든 보안 및 기술적 문제를 고려하여 바퀴를 다시 발명해야 합니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로샬은 RARLAB이 업데이트 알림을 구현하는 것을 고려해 왔지만 기업 시스템 관리자들이 이 아이디어를 좋아하지 않고 사용자 컴퓨터에 팝업 알림이 나타나는 대신 소프트웨어 업데이트에 대해 중앙 집중식 접근을 선호한다고 말했습니다.\n\n하지만 RARLAB은 어쨌든 이 기능을 추가할 수도 있으며 해당 회사는 \"Avast, Kaspersky 및 기타 업데이트 프로그램과 긴밀히 협력하고 있다\"고 말했습니다.\n\n평균적인 Windows PC의 업데이트 상황은 정말 난잡합니다. 어도비, 구글, PC 제조업체 및 다른 개발자들로부터 별도의 업데이트 서비스를 가질 가능성이 매우 높습니다. 그것이 작동하더라도 각 개발자에게는 고통이 될 뿐만 아니라 CPU 및 메모리 자원을 소모하는 많은 불필요한 백그라운드 프로세스가 있습니다.\n\n저는 개인적으로 항상 7-Zip을 선호해 왔지만, 그것도 내장된 업데이트 확인기가 없습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 윈도우 8 문제의 시작\n\n윈도우 8에 '앱 스토어'가 포함될 예정이라고 처음 들었을 때, 저는 흥분했습니다.\n\n데스크톱 리눅스에 대한 경험이 있는 사람으로서, 제가 가장 좋아하는 것 중 하나는 패키지 관리자입니다. 리눅스에서는 개발자 웹사이트에서 각 애플리케이션을 다운로드하는 대신 패키지 관리자를 통해 애플리케이션을 얻습니다. 업데이트가 나오면 패키지 관리자가 업데이트를 찾아 설치해줍니다. 중앙에서 관리되며 한 애플리케이션이 모든 애플리케이션 업데이트를 확인하고 설치합니다.\n\n2011년 마이크로소프트 빌드에서 최초로 발표된 Windows Store는 윈도우 8에서 그런 종류의 경험을 제공할 수 있었을 것입니다. 그러나 마이크로소프트는 새로운 '메트로 앱'을 위한 새로운 스토어만을 제공하기로 결정했습니다. (그러나 개발자들은 전통적인 데스크톱 앱에 대한 목록을 게시하고 직접 PC 사용자를 웹사이트로 이동할 수 있었습니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그보다 나쁜 것은, Windows 8 스토어가 한 때 사기 가득했다는 것이었습니다. \"VLC\" 같은 것을 검색하면 VLC를 다운로드할 위치를 보여주는 애플리케이션을 지불하라는 저금급한 결과물들로 가득찼습니다. 이 문제를 강조한 첫 번째 사람은 아니었지만, 2014년에 이 사기에 대해 강조한 것은 어디서나 Windows 사용자들의 불만을 대변했습니다. 결국, Microsoft는 2015년에 스토어를 개선하기로 약속하며 일반인들의 압력에 반응했습니다.\n\n# Microsoft은 Windows 10에서 시간을 낭비했습니다\n\nWindows 10은 Windows 8의 많은 문제를 해결했지만, 여전히 Microsoft의 불명확한 앱 전략의 피해자였습니다.\n\nWindows 10이 출시된 시점에도 스토어는 \"Universal Windows Platform\" 애플리케이션만 허용했습니다. 이것은 합리적이지 않았습니다. 그때쯤에는 Windows Phone이 사라졌으므로, 유니버설 플랫폼은 데스크톱 PC, Xbox 및 HoloLens가 되는 것인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nWindows 8과 Windows 10에서 PC 사용자들은 상점을 무시하도록 훈련을 받았습니다.\n\n# Windows 11은 너무 늦게 나왔습니다\n\n좋은 소식은 Windows 11이 이를 뒤집었다는 것입니다. 네, Windows 8 출시 9년 후에 마이크로소프트가 마침내 전통적인 Windows 데스크톱 애플리케이션을 데스크톱 PC 운영 체제의 앱 스토어에서 허용해야 한다고 결정했습니다.\n\n이제 개발자들은 전통적인 Windows 데스크톱 앱을 Windows 스토어에 넣을 수 있으며, PC 사용자들은 전통적인 Windows 데스크톱 앱을 설치할 수 있습니다. 스토어를 통해 응용프로그램을 중앙 집중식으로 업데이트할 수 있습니다. 하지만 우리는 다 무시하도록 훈련되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 나쁜 것은 최신 Windows 11 PC에서 앱 스토어를 둘러보다가 스토어에 있는 VLC 같은 앱들이 \"제공 및 업데이트한 사람\"이라고 되어 있는 걸 발견했어요. 그래서 스토어에서 앱을 설치해도, 해당 앱이 여전히 자체 업데이트를 설치할 확률이 높아요.\n\n진짜 안타까운 일이에요. 새 PC를 설정하고 모든 앱을 자동으로 설치할 수 있으면 좋겠고요. 몇십 년 전 데스크톱 리눅스에서 할 수 있었던 것처럼 앱을 업데이트할 수 있는 단일 장소가 있으면 더 좋겠죠.\n\n# 전문가들은 다른 옵션을 가지고 있어요\n\n전문가들은 소프트웨어 업데이터 유틸리티나 winget, Chocolatey 같은 패키지 매니저를 활용할 수 있어요. 그러나 일반 Windows PC 사용자들은 여전히 웹사이트에서 프로그램을 다운로드하고 설치하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n차트 태그를 마크다운 형식으로 변경해 주세요.\n\n벌써 윈도우 데스크톱에서 이 문제들을 해결하는 최선의 방법이 스토어인지는 아마도 아닐 거예요. 하지만 만약 마이크로소프트가 지난 10년 동안 스토어를 진지하게 대하고 일반 PC 사용자와 그들이 실제로 사용하는 애플리케이션을 위해 사용할 만한 수준으로 만들려고 노력했다면, 우리는 해결책에 훨씬 가까웠을 거에요.\n\n적어도 윈도우 11은 RAR, 7Z 및 다른 아카이브 형식에 대한 내장 지원을 얻었기 때문에 WinRAR 및 7-Zip과 같은 애플리케이션을 업데이트하는 걱정 없이 제거할 수 있게 됐어요. 제 생각에는 그것이 발전이에요.\n\n원문 게시 위치: https://www.pcmag.com.\n","ogImage":{"url":"/assets/img/2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs_0.png"},"coverImage":"/assets/img/2024-05-17-MicrosoftsFlawedApproachtoAppUpdatesWreaksHavoconWindowsPCs_0.png","tag":["Tech"],"readingTime":7},{"title":"윈도우 컨셉트 저니 - wow64windll Wow64 콘솔 및 Win32 API 기록","description":"","date":"2024-05-17 18:57","slug":"2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging","content":"\n일반적으로 \"wow64.dll\"(Win32 콘솔 및 Win32 API 로깅)은 WOW64에서 사용되는 동적 링크 라이브러리입니다. \"%windir%\\system32\\wow64win.dll\"에 위치한 64비트 이진 파일입니다. 이 DLL 파일은 Microsoft에 의해 디지털로 서명되었습니다.\n\n요약하면, \"wow64win.dll\"은 \"win32k.sys\" 진입점 함수들을 제공합니다(https://learn.microsoft.com/en-us/windows/win32/winprog64/wow64-implementation-details). 따라서 이는 \"win32k.sys\"에서 노출된 관련 시스콜을 호출하기 위해 사용됩니다(\"NtGdi*\" 또는 \"NtUser*\"로 시작되는 것과 같은 것들) — 아래 스크린샷에서 보여지는 대로(무료 버전의 IDA를 사용하여 캡처했습니다).\n\n마지막으로, DLL의 특성을 고려하면 원래 파일 이름은 \"wow64lg2.dll\"임을 알 수 있습니다 — 아래 스크린샷에서도 확인할 수 있습니다. 또한, \"wow64.dll\" (https://medium.com/@boutnaru/the-windows-concept-journey-wow64-dll-win32-emulation-on-nt64-8ff99ec32c43)은 \"wow64win.dll\"에 종속되어 있습니다. 따라서 일반적으로 user32.dll을 로드하지 않는 \"비 Windows 서브시스템\" 프로세스에서도로드될 수 있습니다(https://wbenny.github.io/2018/11/04/wow64-internals.html).\n\n다음 글에서 뵙겠습니다;-) 트위터에서 팔로우할 수 있으세요 — @boutnaru (https://twitter.com/boutnaru). 또한 다른 글을 읽고 싶으시면 미디엄에서 확인 가능합니다 — https://medium.com/@boutnaru. 무료 eBook은 https://TheLearningJourneyEbooks.com에서 찾을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png](/assets/img/2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png)\n","ogImage":{"url":"/assets/img/2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png"},"coverImage":"/assets/img/2024-05-17-TheWindowsConceptJourneywow64windllWow64ConsoleandWin32APILogging_0.png","tag":["Tech"],"readingTime":2},{"title":"여러분은 핫 코너를 제대로 활용하지 않고 있어요 이전에 아무도 말해주지 않은 꿀팁","description":"","date":"2024-05-17 18:54","slug":"2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore","content":"\n맥 macOS의 핫 코너 기능이 정말 소홀히 다루어지고 있는 기능이에요. 왜냐하면 이렇게 말할 수 있어요:\n\n- 몇몇 사람들은 이 기능이 존재한다는 것을 알지만, 거의 사용하지 않아요.\n- 몇몇 사람들은 이 기능이 존재조차 모르고 있어요. (기본적으로 아래 오른쪽 모서리로 스와이프하면 퀵 노트를 열 수 있다는 건 알지만요)\n\n핫 코너를 통해 맥 화면의 네 구석 중 아무 쪽 모서리로도 포인터를 스와이프하여 10가지 사전 정의된 작업 중 하나를 실행할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것들은 10가지 사전 정의된 작업입니다:\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_1.png)\n\n(‘—’는 아무 행동도 없음을 나타냄.)\n\n시스템 설정 ⚙️ `데스크톱 및 독 🖥️` 핫 코너에서 핫 코너를 원하시는대로 구성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(설정에 깊이 들어갈 필요가 있나요? 네, 따라서 직접 해당 페이지로 이동하는 이 바로 가기를 사용해보세요. 이 URL을 사용합니다: x-apple.systempreferences:com.apple.Desktop-Settings.extension?HotCorners)\n\n자, 여기 제임스라는 사용자의 핫코너 구성입니다:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_2.png)\n\n그러므로 그에게는(swiping towards)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 왼쪽 상단 모서리는 아무 기능도 하지 않습니다.\n- 왼쪽 하단 모서리에서는 현재 애플리케이션 창들이 표시됩니다.\n- 오른쪽 상단 모서리를 클릭하면 알림 센터가 열립니다.\n- 오른쪽 하단 모서리를 클릭하면 바탕 화면이 표시됩니다.\n\n잘 했어요, 제임스는 생산성을 위해 이러한 핫 코너 구성을 설정했어요. 그것을 즐기고 있어요.\n\n그러나 불행하게도 일할 때 활성 모서리 중 하나에 포인터가 닿으면 의도치 않게 이를 자주 작동시키고 있어요.\n\n생산성을 위해 만든 구성이 실제로 그것을 방해하고 있다는 것이 그에게 거슬리는 문제입니다. 그는 심지어 핫 코너를 공백으로 되돌리고 싶다고 생각한 적도 있었어요 — 그런데 이 꿀팁을 몰라서 그랬던 게죠:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# \"수정자 키\"를 설정하여 의도하지 않은 핫 코너 트리거 방지하기\n\n이것은 위장된 기능입니다 — 하지만 더 많은 사람들이 실제로 핫 코너를 사용할 것이라고 생각합니다.\n\n핫 코너를 구성할 때... 예를 들어 데스크톱으로 설정한다고 가정해 보세요. '데스크톱'을 클릭할 때 ⌘를 누르고 있는지 확인해 보세요. 그러면 이렇게 보이게 됩니다:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 의미는 데스크톱을 활성화시키기 위해서는 ⌘을 누른 채로 포인터를 그 모서리쪽으로 스와이프해야 합니다 (보통의 스와이프는 작동하지 않습니다).\n\n이것은 대부분의 의도하지 않은 트리거를 방지할 수 있습니다. ⌘을 누르고 포인터를 모서리쪽으로 스와이프는 매우 낮은 확률이기 때문입니다.\n\n사용할 수 있는 모든 수정자 키는 무엇인가요?\n\n- Shift ⇧\n- Control ⌃\n- Option ⌥\n- Command ⌘\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알지만?\n무심코 트리거가 작동할 확률을 거의 0으로 줄이기 위해 두 개 이상의 수정자 키를 함께 사용하는 것도 좋을지 몰라요:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_4.png)\n\n멋지죠?\n\n# 이제, 프로 사용자를 위한 꿀팁 (그리고 그 중요성)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. 터미널을 통한 핫 코너 구성\n2. 쉬운 핫 코너 구성을 위해 이 오토메이터 앱을 가져다 쓰세요\n3. 핫 코너 프로필 작성, 내보내기, 적용하기\n4. 프로필 작성을 쉽게 하는 오토메이터 앱\n\n# 1. 터미널을 통한 핫 코너 구성\n\n나는 개발자이며 CLI(명령줄) 도구를 UI를 가진 도구보다 항상 선호합니다. 왜냐하면 CLI를 사용하면 내가 하는 일에 대해 더 많은 제어를 할 수 있고 더 CPU 효율적입니다.\n\n그래서 여기에 제가 터미널 명령어를 사용하여 핫 코너를 구성하는 방법이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예를 들어,\n\n아래 명령어는 bottom-left 핫 코너를 수정 없이 Mission Control로 설정합니다.\n\n```js\ndefaults write com.apple.dock wvous-bl-corner -int 2;\ndefaults write com.apple.dock wvous-bl-modifier -int 0;\nkillall Dock\n```\n\n하지만 어떻게 해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 명령어의 각 부분을 설명합니다...\n\n`defaults write com.apple.dock`는 지정된 구성을 도크 설정에 쓰는 것입니다 (핫코너는 내부적으로 도크에 연결되어 있습니다).\n\n`wvous`는 macOS에서 핫코너를 설정하고 구성하는 데 사용되는 키입니다. 이 두 가지는 모든 핫코너 명령에 공통적입니다.\n\n- `bl`은 왼쪽 아래를 나타내며, 마찬가지로,\n- `br`은 오른쪽 아래를 나타내며,\n- `tr`은 오른쪽 위를 나타내며,\n- `tl`은 왼쪽 위를 나타냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코너는 작업을 실행하도록 코너를 구성하고 있어요.\n\n모디파이어는 코너에 모디파이어를 설정하도록 합니다 (말했듯이, ⇧, ⌃, ⌥, ⌘를 모디파이어로 사용할 수 있어요). 당연히 작업이 없는 코너에 모디파이어를 설정하는 것은 쓸모가 없죠.\n\n코너 뒤에 -int 2를 넣으면 미션 컨트롤을 실행하도록 코너를 설정하는 거에요.\n\n여기 각 작업에 연관된 정수들이 있어요:\n• 0, 1: 아무 작업 안 함\n• 2: 미션 컨트롤 (이거 사용해봤죠?)\n• 3: 애플리케이션 창\n• 4: 데스크탑\n• 5: 화면 보호기 시작\n• 6: 화면 보호기 비활성화\n• 7: 대시보드 (macOS 카탈리나부터 중단)\n• 10: 디스플레이를 절전 모드로 전환\n• 11: 런치패드\n• 12: 알림 센터\n• 13: 화면 잠금\n• 14: 빠른 노트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n-int `integer` 명령어를 사용하면 Hot Corner 작업에 수정자를 설정할 수 있어요. 이 경우 0은 수정자가 없음을 의미해요.\n\n```js\n각 수정자와 조합에 대응되는 정수는 다음과 같아요:\n•  131072: Shift (⇧)\n•  262144: Control (⌃)\n•  524288: Option (⌥)\n• 1048576: Command (⌘)\n조합을 사용하려면 각 키에 해당하는 정수를 더해주면 돼요.\n•  393216: Shift+Control (⇧+⌃)\n•  655360: Shift+Option (⇧+⌥)\n• 1179648: Shift+Command (⇧+⌘)\n•  786432: Control+Option (⌃+⌥)\n• 1310720: Control+Command (⌃+⌘)\n• 1572864: Option+Command (⌥+⌘)\n•  917504: Shift+Control+Option (⇧+⌃+⌥)\n• 1441792: Shift+Control+Command (⇧+⌃+⌘)\n• 1703936: Shift+Option+Command (⇧+⌥+⌘)\n• 1835008: Control+Option+Command (⌃+⌥+⌘)\n• 1966080: Shift+Control+Option+Command (⇧+⌃+⌥+⌘)\n```\n\nkillall Dock 명령은 Dock(및 Hot Corner)을 가장 최신 변경 사항을 적용하여 새로고침해요.\n\n## 더 나은 이해를 위한 예제 명령어 (‘killall Dock’를 제외한)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 왼쪽 위 모서리를 미션 컨트롤로 설정하려면:\n\n```js\ndefaults write com.apple.dock wvous-tl-corner -int 2;\ndefaults write com.apple.dock wvous-tl-modifier -int 0\n```\n\n- 오른쪽 위 모서리를 Command(⌘) 키와 함께 데스크톱으로 설정하려면:\n\n```js\ndefaults write com.apple.dock wvous-tr-corner -int 4;\ndefaults write com.apple.dock wvous-tr-modifier -int 1048576\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Shift+Command (⇧+⌘)를 사용하여 왼쪽 하단 모서리를 시작 화면 보호기로 설정하십시오:\n\n```js\ndefaults write com.apple.dock wvous-bl-corner -int 5;\ndefaults write com.apple.dock wvous-bl-modifier -int 1179648\n```\n\n### #2. Hot Corners 설정을 쉽게 할 수 있는 Automator 앱 훔쳐보기\n\n당신의 고통을 이해합니다 —\n터미널을 통해 Hot Corners를 구성하는 것은 시스템 설정에서 직접 수행하는 것보다 훨씬 어렵고 복잡합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 이 Automator 앱(Hot Corners Configurator)을 만들었습니다. 이 앱을 사용하면 작업이 10배 쉬워집니다. (앱이 작동하지 않는 경우에는 다시 시도하기 전에 Hot Corners에 무작위 조치를 할당하세요.)\n\n한 번 더 James의 Hot Corners 구성을 살펴보겠습니다. (이제는 수식어를 사용합니다):\n\n![James' Hot Corners Configuration](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_5.png)\n\n그리고 이것이 Automator 앱을 실행했을 때 나타나는 화면입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_6.png)\n\nIt displays the names of all the four corners along with their Action and Modifier info.\n\nIt also contains an additional option — ‘CLEAR ALL HOT CORNERS’ — that can clear all corners of their actions and (obviously) modifiers.\n\nJames wants to configure his empty top-left corner to open Launchpad with the modifier as Control (⌃). So he selects TOP-LEFT ↖, and sees this:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_7.png\" />\n\n이제 '런치패드'를 선택하면 다음과 같은 화면이 표시됩니다:\n\n<img src=\"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_8.png\" />\n\n여기서 'Control, ⌃'를 선택하고 OK를 클릭합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 새로운 액션 및 수정자는 macOS 시스템 설정에서 구성됩니다. 확인하려면 핫 코너를 시도해보거나 앱을 다시 시작하여 변경 사항이 반영되는지 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_9.png)\n\n이게 다에요. 이제 터미널이나 시스템 설정을 통해 핫 코너를 구성하는 게 더 편한 것 같지 않나요?\n\n## 앱의 AppleScript 코드를 보고 싶으세요? 여기를 클릭하시면 별지에서 내려갈 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# #3. 핫 코너 프로필 만들기, 내보내기 및 적용\n\n만약 생산성에 집착하고 있다면, 이미 다양한 핫 코너 프로필을 만들고 사용하고 있는 꿈을 꾸고 있을지도 모릅니다. 예를 들어\n\n- 프로필 1 (작업용): 화면 왼쪽 하단을 누르면 데스크톱으로 이동,\n- 프로필 2 (가정용): 화면 왼쪽 하단을 누르면 스크린 보호기가 실행됩니다.\n\n일반적으로 말해 - 하루 종일 사용할 핫 코너 구성의 다양한 프로필을 만들 수 있어야 합니다. 한 번 프로필을 적용하면, 기존의 모든 구성이 새로운 구성으로 대체되어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 여러분이 이를 달성하는 데 도움을 드릴게요.\n\n디스크탑을 프로필을 저장할 기본 폴더로 사용해 보세요 (cd desktop을 사용해주세요). 이미 만들고 있는 프로필을 위해 핫 코너를 설정했다고 가정하고...\n\n아래 명령어를 사용해서 myProfile이란 이름의 프로필로 설정을 저장해보세요:\n\n```js\ndefaults read com.apple.dock | grep wvous > myProfile.txt\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내Profile.txt 파일이 데스크톱에 생성될 것입니다. 제 프로필을 위해 그 안에 있는 내용은 다음과 같습니다(참고용):\n\n```js\n    \"wvous-bl-corner\" = 3;\n    \"wvous-bl-modifier\" = 1048576;\n    \"wvous-br-corner\" = 4;\n    \"wvous-br-modifier\" = 1179648;\n    \"wvous-tl-corner\" = 0;\n    \"wvous-tl-modifier\" = 0;\n    \"wvous-tr-corner\" = 12;\n    \"wvous-tr-modifier\" = 262144;\n```\n\n이 파일에는 네 개의 Hot Corners에 대한 작업 및 수정자가 포함되어 있습니다.\n\n이제 새 프로필(이름을 myNewProfile로 지정합시다)을 위해 이전에 제공한 Automator 앱을 사용하여 서로 다른 Hot Corner 구성을 설정할 수 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 모든 프로필을 안전한 장소에 저장하고 원할 때 적용하세요. 그런데 어떻게 적용하죠?\n\n다음 명령어를 사용하세요:\n\n```js\ndefaults write com.apple.dock wvous-<corner_name>-corner -int <integer>;\ndefaults write com.apple.dock wvous-<corner_name>-modifier -int <integer>;\nkillall Dock\n```\n\n그냥 `corner_name`과 `integer`를 해당 값으로 대체하세요. 각 모서리마다 한 번씩 해야 합니다 (총 네 번). 그러면 전체 프로필이 적용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이해합니다 — 다시 어려워졌네요. 그래서 여기 Automator 앱이 있어요. 프로필 관련 작업이 쉽게 이루어집니다.\n\n이 앱 이름은 Profiles Configurator입니다. 어때요!\n\n토글되면, 새 프로필을 만들 건지 기존 프로필을 적용할 건지 선택하라는 창이 표시됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_10.png)\n\n## '새 프로필 생성'을 선택하면:\n\n새 프로필의 이름을 지정하라는 메시지가 나타납니다.\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클릭 OK할 때 프로필이 \"Hot Corner Profiles\"라는 데스크톱 폴더에 저장되고 현재 핫 코너 구성이 포함됩니다.\n\n프로필 이름을 비워 놓으면 다시 시도하라는 메시지가 표시됩니다.\n\n❗️안타깝게도 해결하려고 많은 노력을 기울였지만 해내지 못한 버그가 있습니다:\n프로필 이름을 숫자로 끝내면 저장은 성공하지만 적용하는 동안 오류가 발생할 수 있습니다(Profile2, Profile15). 그러나 이름 \"사이\"에 숫자를 넣는 것(Ex: Profile2A)은 가능합니다.\n\n## '기존 프로필 적용'을 선택하는 경우:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 기존 프로필이 표시됩니다\n\n![프로필 이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_12.png)\n\n선호하는 프로필을 선택하고 확인을 클릭하세요. 이제 확인할 수 있습니다:\n\n![프로필 이미지](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_13.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 번 Apply Profile을 클릭하면 선택한 프로필에 따라 Hot Corners가 구성됩니다.\n\n## 주의할 점\n\n- 아직 아이디어를 이해하지 못했다면, 프로필을 친구들에게 내보내거나 가져올 수 있습니다.\n- 기존 프로필이 없는 상황에서 '기존 프로필 적용'을 선택하면 프로필을 만들도록 요구받게 됩니다:\n\n![image](/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 어플리케이션의 AppleScript 코드를 보고 싶으세요? 별지의 해당 부분으로 스크롤 다운하는 건 어때요?\n\n자, 그러면 이 Automator 앱을 어떻게 찾아내시나요? 만족스러우세요? 하루에 얼마나 자주 사용하고 싶으신가요?\n\n답변 주시면 알려주세요!\n\n## 터미널 명령어에 열광하시나요? 그렇다면 이 이야기들을 읽는 걸 즐기실 거에요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 마지막으로,\n\n새로운 iOS 및 Mac 앱을 탐험하는 것을 좋아한다면(저와 같이요), Setapp에 가입해 보세요. 월 $9.99에 240개가 넘는 놀라운 앱들을 선별하여 이용할 수 있습니다. 개별 구매 시 수백 달러가 필요한 앱들을 저렴하게 이용할 수 있어요.\n\n- Setapp 여행을 시작하려면 제 제휴 링크를 사용하세요! (30일간 무료로 이용 가능)\n- Setapp에서 제가 선정한 100개가 넘는 Ultimate macOS Apps 목록을 무료로 받아보세요.\n\n새로운 스토리를 게시할 때마다 알림을 받기 위해 460명이 넘는 다른 구독자들과 함께 참여하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 부록\n\n## Hot Corners Configurator를 위한 AppleScript 코드\n\n```js\non extractNumber(inputString)\n    set AppleScript's text item delimiters to \"=\"\n    set stringItems to text items of inputString\n    set numberString to item 2 of stringItems\n    set AppleScript's text item delimiters to \"\"\n    set trimmedNumberString to trimSpaces(numberString)\n    return trimmedNumberString as integer\nend extractNumber\n\non trimSpaces(inputString)\n    return text 2 thru -2 of (inputString as text)\nend trimSpaces\n\non getCorner(cornerString)\n    set text item delimiters to \" [\"\n    set resultString to item 1 of text items of cornerString\n    set text item delimiters to AppleScript's text item delimiters\n    return resultString\nend getCorner\n\non getModifier(modifierString, whichPart)\n    set text item delimiters to \",\"\n    set resultString to modifierString\n    if resultString contains \",\" then\n        set resultString to item whichPart of text items of resultString\n    end if\n    set text item delimiters to AppleScript's text item delimiters\n    return resultString\nend getModifier\n\nset actionMappings to {¬\n    \"No Action\", 1, ¬\n    \"Mission Control\", 2, ¬\n    \"Application Windows\", 3, ¬\n    \"Desktop\", 4, ¬\n    \"Start Screen Saver\", 5, ¬\n    \"Disable Screen Saver\", 6, ¬\n    \"Put Display to Sleep\", 10, ¬\n    \"Launchpad\", 11, ¬\n    \"Notification Centre\", 12, ¬\n    \"Lock Screen\", 13, ¬\n    \"Quick Note\", 14 ¬\n}\n\nset modifierMappings to {¬\n    \"No Modifier\", 0, ¬\n    \"Shift,⇧\", 131072, ¬\n    \"Control,⌃\", 262144, ¬\n    \"Option,⌥\", 524288, ¬\n    \"Command,⌘\", 1048576, ¬\n    \"Shift+Control,⇧+⌃\", 393216, ¬\n    \"Shift+Option,⇧+⌥\", 655360, ¬\n    \"Shift+Command,⇧+⌘\", 1179648, ¬\n    \"Control+Option,⌃+⌥\", 786432, ¬\n    \"Control+Command,⌃+⌘\", 1310720, ¬\n    \"Option+Command,⌥+⌘\", 1572864, ¬\n    \"Shift+Control+Option,⇧+⌃+⌥\", 917504, ¬\n    \"Shift+Control+Command,⇧+⌃+⌘\", 1441792, ¬\n    \"Shift+Option+Command,⇧+⌥+⌘\", 1703936, ¬\n    \"Control+Option+Command,⌃+⌥+⌘\", 1835008, ¬\n    \"Shift+Control+Option+Command,⇧+⌃+⌥+⌘\", 1966080 ¬\n}\n\nset shellCommand to \"defaults read com.apple.dock | grep wvous\"\nset hotCornersInfo to do shell script shellCommand\nset linesList to paragraphs of hotCornersInfo\n\non getActionString(actionValue, actionMappings)\n    repeat with i from 1 to length of actionMappings by 2\n        if item (i + 1) of actionMappings is actionValue then\n            return item i of actionMappings\n        end if\n    end repeat\n    if actionValue is 0 then\n        return \"No Action\"\n    end if\nend getActionString\n\non getModifierString(modifierValue, modifierMappings)\n    repeat with i from 1 to length of modifierMappings by 2\n        if item (i + 1) of modifierMappings is modifierValue then\n            return item i of modifierMappings\n        end if\n    end repeat\n    return \"No Modifier\"\nend getModifierString\n\nrepeat with lineNext in linesList\n    if lineNext contains \"bl-corner\" then\n        set blCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"bl-modifier\" then\n        set blModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    else if lineNext contains \"br-corner\" then\n        set brCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"br-modifier\" then\n        set brModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    else if lineNext contains \"tl-corner\" then\n        set tlCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"tl-modifier\" then\n        set tlModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    else if lineNext contains \"tr-corner\" then\n        set trCorner to getActionString(extractNumber(lineNext), actionMappings)\n    else if lineNext contains \"tr-modifier\" then\n        set trModifier to getModifierString(extractNumber(lineNext), modifierMappings)\n    end if\nend repeat\n\nset cornerOptions to {\"TOP-LEFT ↖            [ACTION: \" & tlCorner & \", MODIFIER: \" & getModifier(tlModifier, 2) & \"]\", ¬\n    \"TOP-RIGHT ↗          [ACTION: \" & trCorner & \", MODIFIER: \" & getModifier(trModifier, 2) & \"]\", ¬\n    \"BOTTOM-LEFT ↙    [ACTION: \" & blCorner & \", MODIFIER: \" & getModifier(blModifier, 2) & \"]\", ¬\n    \"BOTTOM-RIGHT ↘ [ACTION: \" & brCorner & \", MODIFIER: \" & getModifier(brModifier, 2) & \"]\", ¬\n    \"CLEAR ALL HOT CORNERS\"}\n\nset selectedCorner to choose from list cornerOptions with prompt \"코너를 선택하세요:\" without multiple selections allowed and empty selection allowed\n\nif selectedCorner is not false then\n    set selectedCorner to item 1 of selectedCorner as text\n    if selectedCorner is \"CLEAR ALL HOT CORNERS\" then\n        set corners to {\"tl\", \"tr\", \"bl\", \"br\"}\n        repeat with currentCorner in corners\n            do shell script \"defaults write com.apple.dock wvous-\" & currentCorner & \"-corner -int 0\"\n            do shell script \"defaults write com.apple.dock wvous-\" & currentCorner & \"-modifier -int 0\"\n        end repeat\n\n        do shell script \"killall Dock\"\n\n    else\n        set selectedCornerAbbreviation to \"\"\n        if selectedCorner contains \"TOP-LEFT ↖\" then\n            set selectedCornerAbbreviation to \"tl\"\n        else if selectedCorner contains \"TOP-RIGHT ↗\" then\n            set selectedCornerAbbreviation to \"tr\"\n        else if selectedCorner contains \"BOTTOM-LEFT ↙\" then\n            set selectedCornerAbbreviation to \"bl\"\n        else if selectedCorner contains \"BOTTOM-RIGHT ↘\" then\n            set selectedCornerAbbreviation to \"br\"\n        end if\n\n        set cornerActions to {\"No Action\", ¬\n            \"Mission Control\", ¬\n            \"Application Windows\", ¬\n            \"Desktop\", ¬\n            \"Start Screen Saver\", ¬\n            \"Disable Screen Saver\", ¬\n            \"Put Display to Sleep\", ¬\n            \"Launchpad\", ¬\n            \"Notification Centre\", ¬\n            \"Lock Screen\", ¬\n            \"Quick Note\"}\n\n        set chosenAction to choose from list cornerActions with prompt \"선택한 코너의 액션을 선택하세요: \" & getCorner(selectedCorner) default items {\"No Action\"} without multiple selections allowed and empty selection allowed\n\n        if chosenAction is not false then\n            if (count of chosenAction) > 0 then\n                set selectedActionText to item 1 of chosenAction\n                if selectedActionText is not \"No Action\" then\n                    set selectedActionValue to 0\n                    repeat with i from 1 to length of actionMappings by 2\n                        if item i of actionMappings is selectedActionText then\n                            set selectedActionValue to item (i + 1) of actionMappings\n                            exit repeat\n                        end if\n                    end repeat\n\n                    if selectedActionValue is not 0 then\n                        set modifierOptions to {}\n                        repeat with i from 1 to length of modifierMappings by 2\n                            set end of modifierOptions to item i of modifierMappings\n                        end repeat\n\n                        set chosenModifier to choose from list modifierOptions with prompt \"선택한 코너의 모디파이어를 선택하세요: \" & getCorner(selectedCorner) default items {\"No Modifier\"} without multiple selections allowed and empty selection allowed\n\n                        if chosenModifier is not false then\n                            if (count of chosenModifier) > 0 then\n                                set selectedModifierText to item 1 of chosenModifier\n                                set selectedModifierValue to 0\n\n                                repeat with i from 1 to length of modifierMappings by 2\n                                    if item i of modifierMappings is selectedModifierText then\n                                        set selectedModifierValue to item (i + 1) of modifierMappings\n                                        exit repeat\n                                    end if\n                                end repeat\n\n                                set actionCommand to \"defaults write com.apple.dock wvous-\"\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```\n\nJavaScript 코드입니다. 함수와 변수를 정의하고 사용자 선택에 따라 프로필을 생성하거나 적용합니다. 조건문과 반복문을 사용하여 프로필 파일을 읽고 해당하는 설정을 적용합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_0.png"},"coverImage":"/assets/img/2024-05-17-YoureUnderutilizingHotCornersHacksNobodyToldYouBefore_0.png","tag":["Tech"],"readingTime":26},{"title":"제목 v058 몬아크의 심볼 검색 기능으로 글쓰기 역량 향상하기","description":"","date":"2024-05-17 18:53","slug":"2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch","content":"\n<img src=\"/assets/img/2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch_0.png\" />\n\n손으로 쓰는 것과 타자 입력의 주요 차이점 중 하나는 기호를 손으로 훨씬 쉽게 쓸 수 있다는 것입니다. 왜냐하면 키보드에는 이미 훨씬 더 자주 필요한 키들이 가득하기 때문이죠.\n\n실제로 맥에서 특정 키보드 조합을 눌러 기호를 입력할 수 있습니다. 이음대는 ⌥+마이너스이고, 점 목록은 ⌥+8입니다. 문제는 뭐지요? 그게 제가 기억하는 모든 것입니다. 수천 개의 기호가 있고, 그 모든 것이나 아주 몇 가지를 기억하려고 노력하려는 것은 현실적이지 않습니다.\n\n이제 Monarch로 그럴 필요가 없습니다! 앱을 열고 이모지를 찾을 때와 같이 탐색을 시작할 수 있습니다. 가장 좋은 점은 특정 기호를 찾기 어렵거나 그들을 위한 시스템 이름을 기억하는 데 어려움을 겪는다면... 더는 그럴 필요가 없다는 것입니다! 이모지처럼 Monarch는 ⌘+E를 사용하여 기호의 이름을 원하는 대로 바꿀 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 메시지에서는 심볼을 사용하지는 않지만, 종종 심볼이 메시지를 더 잘 전달하거나 간결하게 표현할 때, 또는 설명서를 작성할 때 전문적으로 제시해주기도 합니다.\n\nMonarch은 곧 v1.0을 출시할 예정이므로, 평생 라이선스를 획득하려면 빨리 움직여야 합니다! 무료로 30일간 사용해보세요 (신용카드 필요 없음).\n\n# 학생 할인\n\n학생 할인(25% 할인)을 받으려면 학생 이메일(rmdashrfv@hey.com)로 직접 연락해주세요. 뉴욕시 소재 학교에 재학 중인 학생들은 버전 0.x에 40% 할인 혜택을 받을 수 있습니다. 버전 1.0은 우리가 예상하기 전에 여기 있을 것입니다!\n","ogImage":{"url":"/assets/img/2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch_0.png"},"coverImage":"/assets/img/2024-05-17-v058EnhanceyourwritingwithSymbolSearchinMonarch_0.png","tag":["Tech"],"readingTime":2},{"title":"쉘 스크립트를 여전히 작성해야 하는 이유","description":"","date":"2024-05-17 18:51","slug":"2024-05-17-WhyYouShouldStillWriteShellScripts","content":"\n고전적 접근 방식에 대한 현대적인 사례.\n\n![이미지](/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png)\n\n솔직히 말해서, grep -o `Response Code:.*` | cut -f 3 -d ` ` | sort | uniq -c | sort -h 3을 지켜보는 것은 고오급한 Kubernetes Operator를 사용하여 일어나는 것만큼 흥미롭지 않습니다. 많은 소프트웨어 전문가들, 시스템 관리자의 건강한 비율을 포함하여 긴 셸 스크립트를 보는 것은 공포와 혼란의 조합으로 인식합니다. 그러나 나는 현대 엔지니어가 갖춰야 할 유용한 기술 중 하나로 셸 스크립트를 편안하게 작성하고 한 줄 기반으로 만드는 능력을 주장합니다.\n\n대학 시절에 스크립팅 수업을 들었습니다. 수업의 처음 몇 주는 Perl로 넘어가기 전에 셸의 기본 사항을 배우는 데 집중했습니다. 우스꽝스럽게도, 지금은 이 매우 같은 강의를 가르치지만 내용은 Perl에서 Python으로 변화했습니다. 불가피하게, 나의 학생들은 저와 같은 어려움을 겪습니다: 셸 구문은 난해하고 혼란스럽고 기억하기 어려운 것들입니다. 그것은 단순히 \"오래된\" 느낌이 들어서, 첫 번째 셸 스크립트를 작성하는 것은 어둠 속에서 헤매고 있는 것과 같은 느낌입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시간이 흐르면서 저는 쉘을 매우 강력한 기능과 풍부한 역사를 가진 도구로 칭찬하게 되었습니다. 쉘 스크립트를 작성하는 방법을 배우는 것은 아마도 여러분이 익숙한 것과는 다르게 사용자 친화적이지 않을 수도 있습니다. 특히 Python이나 Go와 같은 언어에서 오신 경우에는 더 그렇습니다. 그러나 나는 모두가 쉘 스크립팅 능력을 키우는 데 시간을 쏟는 것이 매우 값진 일이라고 생각합니다.\n\n아래에는 파일을 열 때 #!/bin/bash라는 구문을 보고 신경 쓰이는 경우 고려해 볼 다섯 가지 이유가 있습니다:\n\n## Reason 1: Containers Demand It\n\n컨테이너는 현재 워크로드를 배포하는 표준 방식입니다. 동의하든 그렇지 않든, 쿠버네티스 열풍에 흔들리지 않았더라도 환경에서 컨테이너화된 워크로드를 배포 중인 가능성은 높습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n바이너리 엔트리포인트에 의존하는 컨테이너를 빌드할 수 있지만, 보통 컨테이너는 시작 스크립트를 실행합니다. 이는 실행 시간 구성을 제한하는 기회를 제공합니다. 고품질 쉘 스크립트를 작성하면 컨테이너 엔트리포인트의 품질을 향상시켜 컨테이너 이미지 사용자에게 강력한 실행 시간 구성을 제공할 수 있습니다. 이는 오류 확인부터 자격 증명 또는 구성 매개변수를 자동으로 생성하는 것과 같은 더 복잡한 구성까지 모두 포함됩니다.\n\n게다가: 엔트리포인트 스크립트를 POSIX 쉘(#!/bin/sh)로만 제한하는 방법을 배우면 컨테이너 이미지에서 Bash를 제거하고 그 크기와 공격 표면을 줄일 수 있습니다.\n\n# 공식 MariaDB 컨테이너는 623줄의 도커 엔트리포인트 쉘 스크립트를 사용합니다.\n\n$ podman exec -it mariadb wc -l /usr/local/bin/docker-entrypoint.sh\n623 /usr/local/bin/docker-entrypoint.sh\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로그 및 추적 프로젝트는 대략 백만 개 정도가 있어요. 왜 그럴까요? 로깅은 도전적입니다, 특히 분산 마이크로서비스 세계에서요. 멋진 추적 도구와 로그 집계 서비스는 훌륭하지만 종종 명령줄에서 찾을 수 있는 그 유연성을 제공하지 못할 때가 많아요. 저는 파이프된 명령어 한 줄을 작성하는 것이 대부분의 로깅 시스템 UI를 헤매는 것보다 빠르다고 생각해요.\n\nGUI를 버리지 않는 것을 추천하지 않아요. 오히려 그게 유용해요. 텍스트 데이터를 그래픽 인터페이스와 명령줄 모두에서 탐색하는 것이 유용하기 때문이죠. 내 전형적인 워크플로우는 로깅 UI(예: 키바나)를 사용하여 관심 있는 로그로 대략적으로 필터링한 다음 로그 메시지를 다운로드하여 쉽게 구문 분석하기 위해 셸 유틸리티를 사용하는 것입니다. 원하는 것을 더 잘 알게 되면 실제 쿼리가 있는 대시보드를 작성하게 될 거예요.\n\n생산 문제를 디버깅할 때도 아마 당신은 당신의 서버나 쿠버네티스 클러스터에 앉아 있을 거예요. 장애 발생 시 분 단위가 중요할 때 몇 번의 키 입력으로 바로 이론을 테스트하는 것이 절대적으로 중요합니다. 문제가 심각해서 로그 수집 자체가 고장났을 수도 있고, 아니면 터미널과 로깅 도구 간의 컨텍스트 전환을 계속할 여유가 없을 수도 있어요. 그 어떤 경우에도, 단순한 한 줄짜리 명령어를 만들어 내는 데 익숙해서 다행할 것입니다.\n\n배우는 곡선은 있지만, 쉘에서 사용 가능한 많은 유틸리티로 편안해지면 쉘 명령어를 사용하여 데이터를 \"탐색\"하는 것이 훨씬 쉽다는 것을 알게 되실 거예요. 필요한 데이터를 빠르게 반환하는 작은 스크립트 라이브러리를 점차적으로 구축할 수 있을 거예요. 제가 가장 좋아하는 것 중 하나는 제 Nginx 로그를 구문 분석하고 서버를 공격하는 상위 10개 IP 주소를 알려주는 간단한 Bash 한 줄짜리입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n$ cut -f 1 -d ' ' /var/log/nginx/access.log | sort | uniq -c | sort -hr | head -n 10\n     38 65.108.66.11\n     20 91.240.118.252\n     18 194.110.115.68\n     17 3.234.236.64\n     11 190.117.58.32\n     11 172.56.209.241\n     11 165.225.233.21\n     10 95.161.221.0\n     10 85.173.195.175\n     10 37.79.10.45\n```\n\n# Reason 3: 어떤 (텍스트) 데이터 형식이든\n\n우리가 일상적으로 다루는 대부분의 데이터는 텍스트 형식입니다: 애플리케이션 데이터, 설정 파일, 로그 메시지 등등. 이러한 데이터나 로그 집계 플랫폼에서 이 데이터를 다루는 것은 데이터의 형식(또는 스키마)에 대해 신중한 고려를 요구합니다. 이는 장기적인 저장 및 검색을 위해 이상적인 선택입니다: 데이터 형식을 이해하는 것은 복잡한 데이터를 효율적으로 저장하고 쿼리하는 데 중요합니다.\n\n하지만 당신은 아마도 데이터를 탐색하는 데 편의를 제공하는 방식으로 빠르고 쉽게 데이터를 다루고 싶어하는 상황에 직면해 본 적이 있을 것입니다. 아직 다루고 있는 데이터의 구조나 형식에 대해 이해하고 있지 않을 수도 있습니다. 이를 이해하려는 과정에 있을 수도 있고, 특정 데이터의 일부를 빠르게 쿼리하거나 변환하고 싶을 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n쉘(shell)이 빛을 발하는 작업들이에요! 대부분의 쉘 도구들은 텍스트의 구조에 대해 크게 신경 쓰지 않고 원시 텍스트와 직접 작동합니다. 임의로 형식이 지정되지 않은 텍스트 파일에서 모두 dev를 prod로 변경하고 싶다면, 쉘이 도움이 될 거예요. JSON이나 YAML과 같은 구조화된 데이터 형식을 이미 사용하고 있다면, jq나 yq와 같은 도구를 사용해서 이러한 형식과 함께 작업할 수 있어요.\n\n```js\n# 개발용 구성 파일\n$ cat /tmp/sample.json\n{\n    \"Environment\": \"dev\",\n    \"Database\": {\n        \"Host\": \"dev.example.com\"\n    },\n    \"AppName\": \"iot-dev\",\n    \"CacheShards\": [\n        \"east1-cache-dev-1\",\n        \"east1-cache-dev-2\",\n        \"east1-cache-dev-3\"\n    ]\n}\n\n# Sed는 JSON, YAML, XML 또는 다른 형식이든 상관하지 않아요.\n# 텍스트이면 됩니다!\n$ sed -s 's/dev/prod/g' /tmp/sample.json\n{\n    \"Environment\": \"prod\",\n    \"Database\": {\n        \"Host\": \"prod.example.com\"\n    },\n    \"AppName\": \"iot-prod\",\n    \"CacheShards\": [\n        \"east1-cache-prod-1\",\n        \"east1-cache-prod-2\",\n        \"east1-cache-prod-3\"\n    ]\n}\n```\n\n# 이유 4: 자동화를 지지합니다\n\n자동화는 소프트웨어 엔지니어부터 운영 전문가에 이르기까지 모두의 책임이에요. 소프트웨어 분야에서 일하고 있다면 이미 자동화의 이점을 잘 알고 있고, 아마도 자동화된 몇 가지 프로세스를 진정으로 자랑스럽게 자동화했을 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n셸 스크립트는 존재하는 자동화 방식 중 가장 일반적이고 간단하며 기본적인 유형 중 하나입니다. Ansible, Puppet, Chef, Kubernetes 및 기타 도구들이 나오기 전에는 셸만 있었습니다. 옛날의 시스템 관리자들은 사용자 관리부터 보안 감사까지 모든 것을 다루기 위해 스크립트를 작성했습니다. 이러한 프로세스를 자동화하기 위해 다른 도구를 배울 필요가 없었기 때문에 셸은 시스템과 상호 작용하는 유일한 방법이었죠.\n\n이러한 형태의 자동화를 이해하는 것은 그저 향수에 젖은 연습을 하는 것 이상입니다. 종종 복잡한 프로세스를 자동화하기 위해서는 간단한 셸 스크립트만으로 충분할 수 있습니다. 게다가 많은 자동화 플랫폼들은 이미 강력한 셸 스크립트의 래퍼일 뿐입니다. 셸 스크립트를 작성하고 읽는 방법을 이해하는 것은 자동화 기초에 대한 더 나은 이해를 제공받게 되며, 복잡한 문제를 간단한 방식으로 해결하는 데 도움이 될 것입니다.\n\n# 이유 5: 모든 곳에서 존재하는 기술\n\n현대 컴퓨팅 세계의 현실은 대부분의 기업이 이종 컴퓨팅 워크로드를 실행한다는 것입니다: 가상 머신, 컨테이너, 물리적 호스트 등이 있습니다. 워크로드는 클라우드, 온프레미스 및 엣지에서 실행됩니다. 우수한 엔지니어들은 이러한 환경을 횡단하여 편안하게 작업할 수 있어서 자신을 다른 사람들과 구분지을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 최신 데이터 처리 또는 로그 분석 도구가 없어서 간소화된 컨테이너 애플리케이션 문제 해결에 어려움이 있을 때는 어떻게 해야 할까요? 새로운 팀(또는 직장)으로 옮겨갔을 때 새 역할에서 사용하는 도구체인이 완전히 다를 경우에는 어떻게 해야 할까요?\n\n기본적인 셸 스크립트 작성에 능숙하다면 걱정할 필요가 없습니다. 완전히 다른 환경의 원격 시스템에 로그인하여 로그 데이터를 캡처하거나 자동화된 결함 해결 기능을 동일하게 수행할 수 있습니다. 이런 셸 스크립트를 작성하여 산업 분야에서 계속 발전시키는 경력을 쌓을 수 있습니다. 셸은 시간에 걸쳐 검증되어왔으며, 업계에서의 시간 동안 그것이 성과를 거두는 것을 발견하게 될 것입니다.\n\n# 결론\n\n작은 셸 스크립트도구 상자를 구축하세요. 퇴사할 때 멋진 Kubernetes 오퍼레이터, 놀라운 Kibana 대시보드 또는 멋진 커맨드 라인 도구를 가져갈 수 없을 수도 있습니다. 또한 그것은 간단히 기억에서 재구성하기에 너무 복잡할 수도 있습니다. 그러나 다음 회사에서는 셸이 포함된 시스템이 있을 것이며, 그럼에도 불구하고 당신이 익숙하고 쉽게 어떤 작업이든 수행할 수 있다는 것을 확신할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n확실하게 말씀드리자면: 쉘 스크립트 작성에는 제약과 도전이 있습니다. 하지만 그에 대한 논의는 다음에 하도록 하죠. 그래도 컨테이너 엔트리포인트를 파헤치는 과정에서 #!/bin/sh를 보게 된다고 두려워하지 마세요. 구문과 스타일에 익숙해지면, 강력한 쉘 스크립트가 소프트웨어 전문가로써 우리의 삶을 더 쉽게 만든다는 점을 감사히 여기게 될 거에요.\n","ogImage":{"url":"/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png"},"coverImage":"/assets/img/2024-05-17-WhyYouShouldStillWriteShellScripts_0.png","tag":["Tech"],"readingTime":8},{"title":"리눅스 68에서 사용자 정의 시스템 호출 만들기","description":"","date":"2024-05-17 18:49","slug":"2024-05-17-CreateCustomSystemCallonLinux68","content":"\n여태껏 사용자 정의 시스템 호출을 만들어보고 싶으셨나요? 과제를 위해서든, 즐거움을 위해서든, 또는 커널에 대해 더 많이 배우기 위해서든, 시스템 호출은 우리 시스템에 대해 더 많이 알아갈 수 있는 멋진 방법입니다.\n\n# 이 안내에 따를 이유는?\n\n이 주제에 대한 다양한 안내서가 있지만, 커널 개발 속도의 문제 때문에 문제가 발생합니다. 대부분의 안내서들은 오래되었고 다양한 오류를 발생시키기 때문에, 저는 이 포스트를 오류를 경험하고 그것들을 해결한 후에 작성하게 되었습니다 :)\n\n## 커널 컴파일을 위한 시스템 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRed Hat / Fedora / Open Suse 기반 시스템에서는 아래와 같이 간편하게 실행할 수 있어요.\n\n```bash\nsudo dnf builddep kernel\nsudo dnf install kernel-devel\n```\n\nDebian / Ubuntu 기반 시스템에서는\n\n```bash\nsudo apt-get install build-essential vim git cscope libncurses-dev libssl-dev bison flex\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 커널 가져오기\n\n커널 소스 트리를 복제하세요. 특히 6.8 브랜치를 복제할 것이지만, 지침은 커널 개발자가 프로세스를 변경할 때까지 최신 브랜치에서도 작동해야 합니다.\n\n```js\ngit clone --depth=1 --branch v6.8 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\n```\n\n이상적으로, 복제된 버전은 현재 사용 중인 커널 버전과 같거나 더 높아야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 커널 버전은 다음 명령어를 통해 확인할 수 있어요\n\n```bash\nuname -r\n```\n\n## 새로운 시스템 호출 생성\n\n다음을 수행해주세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncd linux\nmake mrproper\nmkdir hello\ncd hello\ntouch hello.c\ntouch Makefile\n```\n\n이 명령은 다운로드한 커널 소스 코드 내에 \"hello\"라는 폴더를 만들고, 그 안에 hello.c(시스템 호출 코드)와 Makefile(컴파일 규칙) 두 개의 파일을 생성합니다.\n\n좋아하는 텍스트 편집기에서 hello.c를 열고 다음 코드를 넣어주세요.\n\n```js\n#include <linux/kernel.h>\n#include <linux/syscalls.h>\n\nSYSCALL_DEFINE0(hello) {\n    pr_info(\"Hello World\\n\");\n    return 0;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커널 로그에 \"Hello World\"가 출력됩니다.\n\n우리는 단순히 프린트만 할 것이기 때문에 n=0을 사용합니다.\n\n이제 다음을 Makefile에 추가해주세요\n\nobj-y := hello.o\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제\n\n```js\ncd ..\ncd include/linux/\n```\n\n이 디렉토리 안에서 \"syscalls.h\" 파일을 열고 다음을 추가하세요.\n\n```js\nasmlinkage long sys_hello(void)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png\" />\n\n이것은 이전에 만든 syscall 함수에 대한 프로토타입입니다.\n\n커널 루트 내의 \"Kbuild\" 파일을 열고 (cd ../..) 맨 아래에 다음을 추가하십시오.\n\n```js\nobj-y += hello/\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 우리가 포함한 새 폴더도 컴파일하도록 커널 빌드 시스템에 지시합니다.\n\n이 작업이 완료되면, 아키텍처별 테이블에 시스콜 항목도 추가해 주어야 합니다.\n\n각 CPU 아키텍처는 특정 시스콜을 가질 수 있으며, 우리의 시스콜이 어떤 아키텍처를 위해 만들어졌는지 알려주어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nx86_64 아키텍처에서 파일은\n\n```js\narch / x86 / entry / syscalls / syscall_64.tbl;\n```\n\n빈번호를 사용하고 테이블 주석에서 금지된 번호를 사용하지 않도록 유의하여 시스콜 항목을 추가하세요.\n\n제가 사용 가능한 번호 중 462번이 비어 있어서 새 항목을 다음과 같이 추가했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n462 공통 안녕 sys_hello\n```\n\n<img src=\"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_2.png\" />\n\n여기서 462은 우리의 시스템 호출에 매핑되며 두 아키텍처에 대해 공통인 sys_hello로 명명된 hello 시스템 호출의 진입 함수(entry function)입니다.\n\n## 새 커널을 컴파일하고 설치하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령을 실행하십시오.\n\n주의: 이 안내를 따르더라도 시스템의 안전, 보안, 무결성과 안정성을 보장하지 않습니다. 여기 나열된 모든 지침은 제 경험이며 귀하의 시스템에서의 결과를 대표하지 않습니다. 조심히 주의하여 진행하십시오.\n\n이제 법적인 부분은 끝냈으니, 계속해봅시다 ;)\n\n```js\ncp /boot/config-$(uname -r) .config\nmake olddefconfig\nmake -j $(nproc)\nsudo make -j $(nproc) modules_install\nsudo make install\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 부팅된 커널의 구성 파일을 복사하고, 빌드 시스템에 동일한 값을 사용하도록 요청하여 기본값을 설정합니다. 그런 다음 nproc에 의해 주어진 코어 수에 따라 병렬 처리를 사용하여 커널을 빌드합니다. 이후 사용자 정의 커널을 설치합니다 (자체 책임으로).\n\n커널 컴파일에는 많은 시간이 소요되므로 커피 한 잔 또는 10잔을 마시며 터미널에서 스크롤되는 텍스트 줄을 즐기세요.\n\n시스템 속도에 따라 몇 시간이 걸릴 수 있으므로 실제 소요 시간이 다를 수 있습니다. 이 단계에서 열이 치기도 할 수 있으니 온도를 확인하려면 팬이 소리를 지를 수도 있습니다 (내 경우에도 그렇었어요).\n\n## 재미있는 부분, 새로운 시스템 호출 사용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 시스템 호출이 우리의 커널에 통합되었으니 시스템을 재부팅하고 부팅 중에 grub에서 새로운 커스텀 커널을 선택해주세요\n\n![image](/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_3.png)\n\n부팅 후 시스템 호출을 사용하는 C 프로그램을 작성해봅시다.\n\n다음 내용을 가진 파일 \"test.c\"를 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n#include <stdio.h>\n#include <sys/syscall.h>\n#include <unistd.h>\nint main(void) {\n  printf(\"%ld\\n\", syscall(462));\n  return 0;\n}\n```\n\n당신이 테이블에서 시스템 콜에 대해 선택한 번호로 462을 대체하세요.\n\n프로그램을 컴파일하고 실행하세요.\n\n```js\nmake test\nchmod +x test\n./test\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모두 정상적으로 진행되면, 터미널에서 \"0\"을 출력하고 시스콜 출력이 커널 로그에 표시됩니다.\n\n다음 명령어를 사용하여 로그에 액세스하세요.\n\n```bash\nsudo dmesg | tail\n```\n\n그러면 원하는 시스템 콜 메시지가 출력된 것을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 성공적으로 수행했다면 축하드려요 🎉 좋아요와 댓글이 있다면 감사하겠습니다 :) 꼭 여러분의 이야기를 공유해 주세요 :D\n\n다시 한 번 아래 사항을 기억해 주세요:\n\n- 커널을 컴파일하는 데 많은 시간이 걸립니다.\n- 새로 컴파일한 커널은 상당한 용량을 차지하므로 저장 공간 확인이 필요합니다.\n- 리눅스 커널은 코드 변경이 빠르게 이뤄집니다.\n","ogImage":{"url":"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png"},"coverImage":"/assets/img/2024-05-17-CreateCustomSystemCallonLinux68_0.png","tag":["Tech"],"readingTime":9},{"title":"악용하지 말아야 할 멋진 Swift 기능들","description":"","date":"2024-05-17 18:48","slug":"2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse","content":"\n![ThecoolSwiftfeaturesthatyoushouldnotabuse](/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png)\n\niOS 개발자로서, 나는 많은 기존 코드에서 작업하거나 몇 가지 Swift 기능을 시도해 본 적이 있습니다. 그들을 사용하거나 악용 당하는 것을 보면서, 적어도 조심스럽게 사용해야 할 상위 6개의 Swift 언어 기능을 공유하고, 왜 그것들을 팀에서 금지해야 할지 생각했습니다. 간단히 살펴보겠습니다. 동의하지 않거나 다른 예제가 있는 경우 댓글에서 공유해주세요 💬.\n\n# .init() 인스턴스화\n\n.init()을 사용하는 것은 처음 봤을 때 몇 가지 경우에 편리할 수 있지만 (클래스/구조체 이름 바꿀 때 노이즈가 적음), 코드 검토 및 유지보수 시 가독성이 저하됩니다. 코드 검토에서는 호출자로 이동하여 객체의 유형을 확인해야 하며, 유지보수 중에는 객체를 확인하려면 이동해야 합니다. 팀의 생산성을 높이기 위해 사용하지 않아야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n//To avoid ❌\nlet example = .init(title: \"title\")\n//To prefer ✅\nlet example = Example(title: \"title\")\n```\n\nSwiftlint을 사용하면 이 좋은 규칙을 강제로 적용할 수 있어요.\nSwiftlint를 사용하신다면, 프로젝트에서 사용해야 하는 최상의 Swiftlint 설정에 관한 기술적인 문서를 작성했어요 ⬇️\n\n# $0, $1, 등...\n\n$0는 매우 편리하지만 코드 리뷰에서는 코드를 덜 가독성 있게 만들 수 있어요(이 게시물이 말합니다).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// ❌를 피하기 위해\nnumbers.sort { $0 > $1 }\n// ✅를 선호하기 위해\nnumbers.sort { leftNumber, rightNumber in leftNumber > rightNumber }\n\n# 서브스크립트\n\n서브스크립트 기능은 처음 봤을 때 매우 매력적으로 보입니다:\n\n```js\nstruct TimesTable {\n    let multiplier: Int\n\n    subscript(index: Int) -> Int {\n        return multiplier * index\n    }\n}\n\nlet table = TimesTable(multiplier: 3)\nlet result = table[5]  // 결과 = 15\nprint(result)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n서브스크립트가 그렇게 나쁘지는 않지만 테이블[5]을 읽는 일반적인 개발자들은 테이블이 배열이라고 생각하고 다섯 번째 항목에 접근하려는 것으로 생각할 것입니다. 이는 바로 그게 아니기 때문에 코드 리뷰나 파일 간, 모듈 간 사용 시 가독성이 떨어집니다. 논리적인 코드 난독화는 피해야 합니다. 이겪하고자 하는 점이 명확하지 않아서 널리 사용되지 않는 것 때문에 이것을 추천하지는 않습니다.\n\n# 확장(Extensions) 남용\n\n확장은 가독성과 모듈화를 높입니다. 디자인 상, 보호기능이 없는 특성이며 난잡한 코드나 불필요한 사용 또는 안티패턴으로 이어질 수 있습니다.\n\n먼저, 이 규칙을 활성화하지 않았다면, 활성화해야 합니다. 이 규칙은 확장의 일부 불필요한 사용을 감지합니다. 예를 들어, ViewController의 델리게이트를 같은 파일에서 확장을 사용해 구현하지만 어떤 프로토콜 준수 제한도 없거나 그러한 것을 분할하는 경우 등을 감지합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass MyViewController: UIViewController{\n  private var IBOutlet textfield: UITextField\n\n  textfield.delegate = self\n...\n}\n\n// To Avoid❌\nextension UIViewController: UITextViewDelegate {\n\n}\n```\n\n올바르지 않은 SOLID 확장 사용 예시:\n\n```js\ncontainer.register(Buyable.self, NetworkManager())\n\nclass NetworkManager {\n  var user: User\n}\n\nprotocol Buyable {\n  func canBuy() -> Bool\n}\n\nIn Buy.swift\nextension NetworkManager: Buyable {\n  @Inject var cart: CartStore\n\n  func canBuy() -> Bool {\n    if cart.hasEnough { return true} else { return false }\n    //we can still access to user here...\n  }\n\n}\n\nclass CartViewModel {\n  @Inject var buy: Buyable // Illusion to have a Buyable\n\n  func addItem() {\n    if buy.canBuy() { /* */ }\n\n  }\n\n}\n```\n\n우리는 Buyable이 Buy 객체의 프로토콜일 수 있다는 환상을 갖고 있지만, 전혀 그렇지 않습니다. 이를 서로 다른 파일에 걸쳐 사용하면서 매우 지저분한데다가 혼란스럽습니다. 하지만... 작동합니다. (코틀린에서는 이렇게 하는 것이 불가능합니다).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Property wrappers\n\n테이블 태그를 Markdown 형식으로 변경하면 다음과 같습니다.\n\nI love them, for writing cross native code, property wrappers is an awesome feature. First usecase from the swift community was to use them for improving the usage of Injection (like Swinject), can lead to read source code like a dagger-hilt style and it’s the equivalent of the delegated properties in Kotlin. But like Kotlin, it has the same drawbacks: readability / logic obfuscation / spagetthi architecture.\n\n```js\n@propertyWrapper\nstruct Sanitized {\n    private(set) var value: String = \"\"\n\n    var wrappedValue: String {\n        get { value }\n        set { value = newValue.trimmingCharacters(in: .whitespacesAndNewlines) }\n    }\n\n    init(wrappedValue initialValue: String) {\n        self.wrappedValue = initialValue\n    }\n}\n\nstruct User {\n    @Sanitized var username: String\n}\n\n// Exemple d'utilisation\nvar user = User(username: \"   Chris   \")\nuser.\nprint(user.username) // Output: \"Chris\"\n```\n\nHow can we really use this as a business rule implementation? If we want to add additional features to our string, we will have to add them inside our Sanitized property wrapper or write them outside to maintain a single responsibility principle. Why isn`t Sanitized a function of your User? It may create inconsistency. Property wrappers should be used wisely and could be replaced by small extensions 💡.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 게터/세터 재정의\n\n이것은 정사각형/속성 감싸기와 거의 비슷합니다. didSet의 사용은 로직을 혼란스럽게 만들 수 있으며 이해하기 어렵게 만들 수 있습니다:\n\n```js\nstruct Temperature {\n    var celsiusValue: Double {\n        didSet {\n            print(\"무슨 일이 일어났어요\")\n        }\n    }\n\n    init(celsiusValue: Double) {\n        self.celsiusValue = celsiusValue\n    }\n}\n\nvar temp = Temperature(celsiusValue: 20)\ntemp.celsiusValue = 25\n//무슨 일이 일어났어요\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이건 명백해 보일지 모르지만 때로는 강제 언래핑 할 때 어떻게 해야할지 모르겠어요 (그리고 이것이 꼭 멋진 기능은 아닐 수 있어요) - 함수 호출이 확실히 동작할 것이라고 가정하는 것이 유혹스러울 수 있습니다 (하지만 옵셔널 값을 반환할 수도 있어요). 그렇다면, 만약 여러분의 코드가 아니라면 결국 실패할 수 있는 가능성을 가정해야 해요. 예를 들면:\n\n```js\n// SPM에서 UIFont를 로드하려고 하는 경우\nregisterFont(\"font.ttf\") // font가 로드된 것으로 가정합니다\n\n// ❌ 하지마세요\nlet font = UIFont(name: \"font.ttf\")!\n\n// 하세요\nguard let font = UIFont(name: \"font.ttf\") else {\n    Crashlytics.record(\"font.ttf failed to be registered\") // 충돌을 모니터링합니다\n    return // 또는 fatalError() 또는 기본 폰트를 인스턴스화하세요\n}\n```\n\n# 결론\n\n고급 언어 기능 사용은 라이브러리나 구조적인 프레임워크/사용자 정의 아키텍처를 사용하는 것과 유사합니다: 현명하게 사용되어야 하며, 팀으로 수용되어야 합니다. 새로운 프로젝트에 참여하는 새로운 사람이 이 코드 라인을 읽었을 때, 쉽게 이해할 수 있는지 아닌지 고려해야 합니다. 학습은 함의하거나 빛나는 새로운 기능을 남용하지 않는 시점을 인식하거나 더 전통적인 방식으로 돌아가야 하는 시점을 받아들이는 것 또한 포함됩니다 😀.\n","ogImage":{"url":"/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png"},"coverImage":"/assets/img/2024-05-17-ThecoolSwiftfeaturesthatyoushouldnotabuse_0.png","tag":["Tech"],"readingTime":8},{"title":"어이쿠, 내 앱이 성공했는데 접근성에 대해 생각하지 않았어요","description":"","date":"2024-05-17 18:44","slug":"2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility","content":"\n본인이 천재적인 앱 아이디어, 새로운 일자리, 또는 벤처 자본을 받았을 때, 새로운 기능을 배포하는 데만 시선을 집중하는 유혹이 감도는 건 이해합니다.\n\n올바른 방식으로 집중한다면, 이러한 집중은 앱을 다운로드 차트의 정상으로 랭킹시키며 성과를 거둘 수 있습니다. 그렇지만 그것으로 충분하지 않습니다. 모두가 본인의 앱을 사용하기 전까지 멈출 수 없을 겁니다.\n\n이런 믿을 수 없는 목표를 달성한 후, 현실적인 진실을 알아차립니다: 6명 중 1명이 본인의 앱이 고장나있다고 생각합니다.\n\n그런 다음, 깨닫게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n16%의 사람들이 어떤 형태의 접근성(a11y - 멋진 친구 중 하나라면) 요구사항을 가지고 있습니다. 그러나 자유롭게 움직이면서 일할 때, 쉽게 a11y를 뒷전에 두는 경우가 많습니다. 특히 기한에 쫓기고 리더십으로부터 제한된 참여를 받을 때 말이죠.\n\n더 성공하게 되면, 사용자들의 접근성 요구를 인정하지 못한 것으로 비판받을 확률이 커집니다. 불행히도 이를 우선적으로 다루기가 어렵습니다. 영향력 있는 누군가가 접근성을 옹호하지 않는 한 말이죠.\n\n오늘은 도와드리겠습니다. 앱을 접근성에 맞춰 빠르게 개선하는 방법을 보여드릴게요:\n\n- SwiftUI 앱에서 a11y를 점검합니다.\n- 모든 텍스트 크기에서 앱을 잘 보이도록 만듭니다.\n- 화면 낭독기를 사용할 수 있게 만듭니다.\n- 이해관계자들을 설득하여 a11y를 우선시하도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사를 위해 특별히 만든 캣 테마 동반 앱을 살펴볼 것입니다. 표면 상으로는 괜찮아 보이지만, a11y(웹 접근성) 관점에서 평가를 시작하자마자 완전히 망가진 상태입니다.\n\n기술을 완전히 이해하고 싶다면, 코드를 함께 작성해보세요! 우리는 이 기사에서 자세히 다룬 모든 기술을 구현하기 위해 Before/ 폴더에서 시작합니다 (최종 및 개선된 앱은 After/ 폴더를 참조하세요).\n\n# 앱의 접근성(A11y) 감사\n\na11y(웹 접근성)를 제대로 이해하려면 실제 장치에서 접근성을 테스트해야 합니다. 이것이 모든 사용자가 앱과 상호 작용하는 방식입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n접근성(a11y) 작업을 진행할 때는, 먼저 컨트롤 센터를 최적화해야 합니다. 정말 대단한 시간을 절약할 수 있어요.\n\n아이폰 설정으로 이동하여, 컨트롤 센터에 \"텍스트 크기\" 컨트롤과 \"접근성 바로 가기\"를 추가해보세요. \"텍스트 크기\"를 추가하면, 어떤 어플에서든 어디서든 밑으로 스와이프하여 텍스트 크기를 즉시 선택할 수 있어요. 심지어 어플당 크기 조절도 가능해요.\n\n\"접근성 바로 가기\"를 추가하면, 어시스티브터치(AssistiveTouch), 보이스오버(VoiceOver), 색상 필터, 모션 감소 등 다양한 접근성 기능을 쉽게 적용할 수 있어요. 하지만 잠금 버튼을 세 번 누르면 동일한 메뉴가 나오기 때문에 더 쉽게 접근할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 텍스트 크기 감사\n\niOS에서는 extraSmall부터 accessibilityExtraExtraExtraLarge(즉, AX5)까지 12가지의 텍스트 크기 옵션이 있습니다. 최대 크기인 accessibilityExtraExtraExtraLarge는 기본(큰) 크기보다 약 310%\\* 더 큽니다.\n\n텍스트 크기가 정상적으로 작동하는지 확인하기 위해 두 가지 감사를 선호합니다:\n\n- 앱을 가장 큰 일반 폰트인 extraExtraExtraLarge(즉, xxxl)로 테스트하고, 가급적 볼드 텍스트 접근성 설정도 활성화하세요. 이는 상대적으로 일반적인 가장 큰 폰트로, 제 어머니도 이 폰트를 사용합니다. 앱은 이 크기에서 잘 보여야 합니다.\n- 앱을 가장 큰 접근성 폰트인 AX5로 테스트하세요. 이 크기는 익숙하지 않다면 우스꽝스러울 수 있지만, 이 크기밖에는 앱과 상호작용할 수 있는 방법이 없는 사람들이 있습니다. UI를 이 크기로 완벽하게 만드는 것은 어려울지라도, 접근성 텍스트 크기 설정에서 앱이 작동하는지조차 확인하지 않은 회사는 명백히 부족합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희 앱을 한 번 살펴보겠습니다.\n\n![앱 스크린샷](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_1.png)\n\n바로 앱을 실행해보면, 정성껏 디자인한 로그인 UI가 텍스트 크기 조절 시 문제가 발생합니다. 저희는 대용량의 텍스트 크기를 예상하지 못했기 때문에 내용을 스크롤할 필요가 있다는 생각조차 하지 못했습니다.\n\n더 나아가서, 색맹일 경우 로그인 버튼의 대비가 미미하여 버튼을 읽을 수 없을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 앱의 메인 목록 화면도 확인해 봅시다.\n\n![Main List Screen](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_2.png)\n\n이 화면은 덜 '부서지는' 느낌이 나요. 모든 것이 보이지만 액세스 가능한 크기의 폰트를 사용하는 사람에게는 이 크기에서 앱을 테스트하지 않았다는 것이 분명합니다. 공간을 다투는 텍스트 레이블이나 순창방에서 아이콘만큼 큰 캡션을 보세요.\n\n## 스크린 리더 오디트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 사용자는 텍스트 크기 조정에 영향을 받지 않습니다 — 그들은 앱과 상호 작용하기 위해 스크린 리더기가 필요할 수 있기 때문입니다.\n\niOS VoiceOver는 여기서의 중요한 작업을 훌륭하게 처리하므로 여러분 팀의 약간의 배려가 큰 차이를 만들어냅니다.\n\n텍스트 크기 감사와 마찬가지로 스크린 리더기 감사도 실제 기기에서 하는 것이 가장 좋습니다 (잠금 버튼을 3번 눌러보세요, 기억하세요!). 또한 Xcode에 내장된 개발자 도구인 접근성 검사 도구가 VoiceOver 작업에 도움이 됩니다.\n\n![2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱을 통해 걸어가면, 텍스트 크기 조정과 비교하면 적어도 깨진 부분이 적은 편이에요. 하지만 이미지와 같은 많은 UI 영역이 전혀 보이지 않아 사용자에게 직접적인 지원이 되지 않아요. 그 이유는 접근성 레이블을 추가하는 데 신경을 쓰지 않았기 때문이죠.\n\n![이미지1](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_4.png)\n\n특히 VoiceOver를 사용하지 않은 경우, 화면 리더기가 모든 UI 요소를 반복하며 읽어주지만 아이콘에는 라벨이 붙어있지 않아 명확합니다.\n\n![이미지2](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n큰 목록이 있으면 상황이 더 악화됩니다.\n\nSwiftUI에 내용에 대한 정보를 제공하지 않으면, 스크롤 가능한 내용의 아래쪽 로그아웃 버튼으로 이동하려면 100번 이상 스와이프해야 할 수도 있는 상황에 처하게 될 수 있습니다. 페이징에 대해서 시작도 하지 마세요.\n\n![앱 접근성을 고려하지 않고 앱이 성공적이라고 생각하지 않은 경우 스크린샷](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_6.png)\n\n우리 앱을 접근성이 좋은 앱이라고 부를 수 있기 전에 해결해야 할 문제가 많습니다. 다행히 SwiftUI에는 a11y에 대해 신속하게 파악할 수 있는 도구가 가득합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스피드런 액세시빌리티\n\n이제 문제가 어디에 있는지 알았으니, 하나씩 빠르게 해결해 나갈 수 있어요.\n\n## 스크롤 가능한 콘텐츠\n\n이것은 가장 불편한 문제입니다. 큰 텍스트 크기에 대한 스크롤 뷰로 확장되지 않아 앱 온보딩이 완전히 망가졌어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 감사에서는 로그인 화면 버튼이 폰트 크기가 커짐에 따라 화면 밖으로 밀렸습니다. 나머지 텍스트 내용은 서로 밀어붙여져 레이블이 겹치고 확장할 공간이 없어 잘린 것처럼 보였어요.\n\n자연스러운 해결책은 콘텐츠를 스크롤 가능하도록 만드는 것입니다. 그러나 모든 화면이 컨텐츠가 잘 맞는 경우에도 스크롤이 자유롭게 되어서는 안 됩니다. 우리는 Ionic 앱을 만드는 일이 아니에요. _억압된 기억으로 전율을 느끼며_\n\n이 문제는 사용자 지정 뷰 수정자로 해결할 수 있습니다. 제가 a11yScrollView()라고 부르는 이 뷰 수정자의 목표는 화면 내용을 스크롤 뷰로 감싸지만 필요한 경우에만 발생하도록 하는 것입니다. 이것을 작은 라이브러리 A11yUtils에 추가하여 여러분의 코드에서 사용할 수 있도록 했어요.\n\n현재 이것은 iOS 16.4 이상에서만 우리의 꿈이 되는 동작을 실현합니다 — 이미 콘텐츠가 맞는 경우 스크롤을 방지하기 위해 스크롤 뷰에 scrollBounceBehavior를 적용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n미래에는 iOS 16에서 ViewThatFits\\* 및 iOS 15에서 GeometryReader와 함께 작동하도록하고 싶습니다.\n\nOS 버전을 지정하는 사람이 주위에 없기 때문에 저희 온보딩 뷰의 VStack에 이 수정자를 적용할 수 있습니다.\n\n```swift\n// OnboardingView.swift\n\nimport A11yUtils\nimport SwiftUI\n\nstruct OnboardingView: View {\n\n    @Binding var isLoggedIn: Bool\n\n    var body: some View {\n        NavigationStack {\n            VStack(spacing: 20) { /* ... */ }\n              .padding(.horizontal)\n              .a11yScrollView()\n              .navigationTitle(\"Create account\")\n        }\n    }\n}\n```\n\n이제 콘텐츠가 멋지게 스크롤되어 xxxl, AX3 및 AX5에서 잘 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_7.png\" />\n\n## 스페이서는 코드 냄새입니다\n\n온보딩 화면을 작업하는 동안, 우리가 할 수 있는 또 다른 간단한 개선 사항이 있습니다:\n\n```js\nVStack(spacing: 20) {\n    // ...\n    OnboardingReasonsText()\n    Spacer()\n    LoginButtonView()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n텍스트 크기가 크면 화면 공간이 제한되어 Spacer()를 사용하면 문제가 발생할 수 있습니다. SwiftUI 레이아웃 엔진은 공간을 만들기 위해 열심히 노력합니다. 심지어 그 공간이 더 이상 없어도 텍스트가 절단되는 문제가 발생할 수 있습니다.\n\n이러한 시나리오에서 스페이서를 매우 좁은 높이로 압축해도 VStack에 정의된대로 위아래로 각각 20포인트의 공간이 생길 것입니다.\n\n우리는 Spacer()를 frame() 수정자로 바꿀 수 있습니다:\n\n```js\nVStack(spacing: 20) {\n    OnboardingReasonsText()\n    LoginButtonView()\n        .frame(maxHeight: .infinity, alignment: .bottom)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프레임은 더 신뢰할 수 있는 방식으로 작동합니다: SwiftUI는 이 버튼 위에 가능한 한 많은 공간을 제공해야 함을 알지만, 여백 자체가 UI의 중요한 부분이 아니기 때문에 공간이 부족하면 불필요한 여백이 적용되지 않습니다.\n\n이 프레임 수정자는 의미가 더 명확합니다. 즉, SwiftUI에게 우리의 의도를 명확하게 전달합니다. 이것은 a11y와 관련된 중요한 개념이므로 나중에 더 자세히 다룰 것입니다.\n\n## 이미지와 아이콘의 확대\n\n다이나믹 타입 덕분에 iOS는 사용자가 선택한 글꼴 크기에 따라 앱 내 글꼴을 자동으로 확대합니다. 이것은 사용자 정의 글꼴과도 쉽게 구현할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 SwiftUI에서 의미있는 글꼴 크기를 사용할 때 텍스트가 자동으로 조절된다는 것을 의미합니다.\n\n```js\nText(cat.quote)\n    .font(.body) // 이것도 잘 작동합니다\n```\n\n더 좋은 것은 SFSymbols를 사용할 때 아이콘에도 동적 글꼴 크기를 적용할 수 있다는 것입니다!\n\n```js\nImage(systemName: \"heart.circle.fill\")\n    .font(.body) // 이것도 SFSymbols와 잘 작동합니다\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안타깝게도 대부분의 iOS 앱에는 Android 버전이 있으므로, 디자이너가 SFSymbols을 사용하는 대신 맞춤 아이콘을 만든다는 점에 유의하셔야 합니다. 대부분의 앱은 사용자 정의 이미지와 미디어를 포함합니다.\n\n따라서 우리의 예시인 Before/에서는 아이콘을 SwiftUI에 추가하는 일반 이미지처럼 처리하여, 하드코딩된 크기를 사용했습니다.\n\n```js\nImage(cat.image)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .frame(width: 72, height: 72) // 하드코딩된 크기 - 확장되지 않을 것입니다!\n    .clipShape(Circle())\n\nImage(systemName: cat.icon)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .foregroundStyle(.secondary)\n    .frame(width: 24, height: 24) // 하드코딩된 크기 - 확장되지 않을 것입니다!\n```\n\n결과는 어떻게 될까요? 가장 큰 글꼴 크기로 조정했을 때, 콘텐츠가 매우 어울리지 않게 보일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_8.png)\n\nSwiftUI에는 사용자 정의 이미지 및 뷰에서 동적 타입의 파워를 제공하는 멋진 도구인 @ScaledMetric 프로퍼티 래퍼가 있습니다.\n\n```swift\n@ScaledMetric(relativeTo: .largeTitle) private var imageSize: CGFloat = 72\n@ScaledMetric(relativeTo: .body) private var iconSize: CGFloat = 24\n```\n\n우리는 @ScaledMetric을 자체로 사용할 수 있으며, 이는 기본 body 글꼴 크기 조정을 사용합니다. relativeTo를 사용하면 SwiftUI가 어떻게 조정할 지 알 수 있으므로 더 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nlargeTitle은 이미 상당히 크기 때문에 조금 더 확장됩니다. 캡션 스타일의 글꼴은 더 많이 확장됩니다. 이 경우 아이콘은 본문 크기 조정이 되어 동반하는 인용문 텍스트와 일치합니다.\n\n```js\nImage(cat.image)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .frame(width: imageSize, height: imageSize) // 동적 크기 조정\n    .clipShape(Circle())\n\nImage(systemName: cat.icon)\n    .resizable()\n    .aspectRatio(contentMode: .fit)\n    .foregroundStyle(.secondary)\n    .frame(width: iconSize, height: iconSize) // 동적 크기 조정\n```\n\n이제 이미지가 텍스트와 함께 더 합리적으로 보입니다.\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_9.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 콘텐츠 정렬하기\n\n이미지는 더 잘 확장되지만, 여전히 텍스트 라벨이 공간을 지배하며 UI가 깨져 보입니다. 레이아웃 엔진과의 협상을 끝내고 나니, 줄바꿈으로 가득 차 있습니다.\n\n만약 사용자의 텍스트 확장에 기반한 컨텐츠의 정렬이 가능하다면 어떨까요?\n\n다행히도, 라이브러리 A11yUtils 덕분에 A11yHStack을 활용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 SwiftUI 도구 릴리스 속도가 빨라서 (그리고 Apple의 뒷전포기가 혹독해서), 이것은 최소 지원 OS에 기반을 둔 두 가지 다른 구현을 가지고 있어요:\n\n- iOS 16에서는 ViewThatFits를 사용하여 HStack이 모든 내용을 포함할 수 있는지 확인하고, 그렇지 않으면 내용을 정렬하기 위해 VStack을 사용합니다.\n- iOS 15에서는 더 단호한 방식을 적용하여, @Environment(\\.sizeCategory)를 확인하고, 접근성 텍스트 크기 범주 (예: AX1, AX2 또는 AX5) 가 사용된 경우에는 VStack으로 전환합니다.\n\n다음은 간단한 접근 방식입니다:\n\n```js\n@Environment(\\.sizeCategory) private var sizeCategory\n\nvar body: some View {\n    if sizeCategory.isAccessibilityCategory {\n        VStack(alignment: .leading, spacing: spacing) {\n            content()\n        }\n        .frame(maxWidth: .infinity, alignment: .leading)\n    } else {\n        HStack(alignment: alignment, spacing: spacing) {\n            content()\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n@Environment(\\.sizeCategory)은 중요한 경우에 사용할 수 있는 유용한 도구입니다. 사용자가 접근성 텍스트 크기 범주를 사용하는지 여부를 알아야 하는 경우 (isAccessibilityCategory와 함께). 때로는 이 속성을 사용하여 대량 콘텐츠 크기에 맞지 않는 이미지와 같은 불필요한 UI 요소를 제거하는 데 활용합니다.\n\n더 현대적인 구현은 비슷하게 동작하지만 ViewThatFits를 활용하여 콘텐츠가 맞지 않는 경우에만 재분배됩니다:\n\n```js\nvar body: some View {\n    ViewThatFits {\n        HStack(alignment: alignment, spacing: spacing) {\n            content()\n        }\n        VStack(alignment: .leading, spacing: spacing) {\n            content()\n        }.frame(maxWidth: .infinity, alignment: .leading)\n    }\n}\n```\n\n생각을 많이 해면 A11yHStack을 몇 군데에 적용할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport A11yUtils\n\nA11yHStack {\n    Image(cat.image)\n    VStack {\n        A11yHStack {\n            Text(cat.name)\n            Text(\"\\(cat.age) years old\")\n        }\n        HStack {\n            Image(systemName: cat.icon)\n            Text(cat.quote)\n        }\n    }\n}\n```\n\n이제 컨텐츠가 매우 큰 텍스트 크기에서 더 적절해 보입니다.\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_10.png\" />\n\n## 스크린 리더 개선사항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보이스오버는 퍼즐 조각 중 비교적 간단한 부분입니다.\n\n앱이 스크린 리더와 잘 작동하도록 만드는 것은:\n\n- 시각적 콘텐츠가 충분히 설명되었는지 확인하기.\n- 탐색이 직관적으로 작동되도록 만들기.\n- 뷰가 의미론적으로 올바른지 확인하기.\n\n먼저 시각적 설명부터 시작해보죠. 이것은 우리 레퍼토리에서 가장 간단한 수정 사항입니다: 그래픽 콘텐츠가 VoiceOver에 의해 설명될 수 있도록 보장하는 것입니다. accessibilityLabel 수정자가 우리의 책과 버터라고 할 수 있죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nImage(\"catKingdom\").accessibilityLabel(\n  Text(\"나의 세 마리 고양이: 코디, 로지, 루나\")\n);\n```\n\n스크린리더가 현재 초점을 맞춘 대상을 설명하는 방법을 알려줍니다.\n\n![Cat Kingdom](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_11.png)\n\n이제 주 뷰의 셀에 동일한 방식을 적용할 수 있습니다. Cat 데이터 모델을 약간 수정하여 각 고양이 사진과 함께 이미지 설명을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nstruct Cat {\n    // ...\n    let imageDescription: String\n}\n\nImage(cat.image)\n    .accessibilityLabel(Text(cat.imageDescription))\n```\n\n이건 들릴만큼 쉽고, Apple 플랫폼에서만 작동하는 경향이 있어요.\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_12.png)\n\n우리 앱을 통해 탐색할 때, 좀 더 신중하게 할 수 있는 기회가 있어요. 기본 설정으로 VoiceOver는 SwiftUI 뷰 트리의 모든 잎 노드를 반복하며 모든 이미지, 버튼 및 텍스트를 읽어줄 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔 사용자에게 불필요한 탐색을 초래합니다. 저희 앱에서는 각 고양이의 아이콘과 인용구를 건너뛰려면 여러 번 탭해야 합니다. 아이콘의 이름(예: cat.fill)을 읽는 것은 경험에 별다른 도움이 되지 않습니다.\n\n이들을 단일 a11y 요소로 결합하여 screenreader가 탐색 중에 하나의 항목으로 처리할 수 있도록 할 수 있습니다.\n\n```swift\nHStack {\n    Image(systemName: cat.icon)\n    Text(cat.quote)\n}\n.accessibilityElement(children: .combine)\n```\n\n이제 screenreader가 요소를 하나로 이동하는 것을 들을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_13.png)\n\n어떤 상황에서는 그래픽적으로 시간이 표시되는 셀렉트한 타이머 요소와 같이 복잡한 UI가 있을 수 있습니다. VoiceOver는 똑똑하지만, 설명되지 않은 뷰들의 번잡한 모음에서 유용한 정보를 유추하지는 못합니다.\n\n여기서 accessibilityRepresentation 수정자가 정말 유용하게 사용됩니다. 이를 통해 뷰의 VoiceOver UI를 완전히 사용자 정의된 접근성 표현으로 대체할 수 있습니다.\n\n최근에 개발한 개인 프로젝트 'Check 'em'에서는 사용자의 2단계 인증 코드가 카운트다운과 함께 표시되어 해당 기능이 특히 유용했습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// AccountView.swift\n\nstruct AccountView: View {\n\n    var body: some View {\n        Section(account.name) {\n            // Image, 2FA Code Text, and Countdown UI ...\n        }\n        .accessibilityRepresentation {\n            VStack {\n                Text(account.name)\n                if let code = account.code {\n                    ForEach(Array(code.enumerated()), id: \\.0) {\n                        Text(String($0.1))\n                    }\n                }\n                if let countdown = account.countdown {\n                    Text(\"Expires in \\(countdown)\")\n                }\n            }.accessibilityElement(children: .combine)\n        }\n    }\n```\n\n이 modifier를 사용하여 각 셀 요소를 순서대로 반복하는 것보다 훨씬 유용한 완전히 사용자 정의 된 VoiceOver 인터페이스를 소개할 수 있었습니다. 또한 화면 낭독기가 \"676,252\"를 \"육십 칠만 육천 이백 오십 이\"로 읽는 것을 방지했습니다.\n\n![Screenshot](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_14.png)\n\n## Native components\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 어플리케이션의 주요 뷰는 저희 콘텐츠를 배치하는 일반적이지만 조잡한 방법을 사용합니다: ForEach 내에 있는 셀을 래핑하는 방식으로 LazyVStack을 래핑하고 ScrollView로 래핑합니다.\n\n```js\nScrollView {\n    LazyVStack(spacing: 24) {\n        ForEach(cats, id: \\.name) {\n            CatView(cat: $0)\n        }\n    }\n}\n```\n\n최적의 방법은 가능한 한 SwiftUI의 기본 구성 요소를 활용하는 것입니다. 이 경우에는 List가 가장 적합합니다.\n\nApple은 사용자 정의 UI 대신 iOS-Settings 스타일의 List를 사용하려면 모디파이어를 3개 추가해야 한다는 점을 설명할 때, 이 작업을 좀 더 어렵게 만들어 놓았습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n목록(고양이) {\n    고양이뷰(고양이: $0)\n        .목록행배경(Color.clear)\n        .목록행구분선(.숨김)\n}\n.목록스타일(일반목록스타일())\n```\n\n이제 보일러플레이트를 작성했으니 수정자들을 자유롭게 사용하여 SwiftUI 목록에서 자체 UI를 사용할 수 있습니다.\n\n<img src=\"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_15.png\" />\n\n한 가지 질문이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왜 네이티브 컴포넌트를 사용하는 것에 이렇게 많은 노력을 기울일까요?\n\n먼저, 비 접근성(a11y) 관련 이유: SwiftUI List는 UICollectionView를 사용하여 구현됩니다. 이는 고성능 스크롤링을 위해 셀 재사용을 활용하며 항목이 많아도 성능을 유지합니다. 그에 반해 LazyVStack은 이전에 렌더링된 모든 셀을 메모리에 유지하므로 많은 항목을 스크롤하는 경우 성능이 뚝뚝 떨어집니다.\n\n네이티브 컴포넌트를 사용하는 a11y 관련 이유는 간단하지만 다양합니다:\n\nList는 의미론적 의미가 있습니다: 화면 판독기에게 비슷한 콘텐츠 컬렉션을 포함하는 컨테이너임을 알려줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것이 많은 목록 항목이 있는 경우, 순진한 구현이 망가진 이유입니다: VoiceOver로 목록 컨테이너를 건너뛸 수 있게 해주지 않고 모든 항목을 스와이프해야만 로그아웃 버튼에 도달할 수 있었습니다.\n\nList를 사용하면 SwiftUI가 화면 판독기에게 그 내용이 단일 컨테이너임을 알려줄 수 있어, 화면 판독기가 쉽게 이동할 수 있습니다.\n\n아래는 Markdown 형식으로 변경된 이미지 링크입니다:\n\n![이미지](/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_16.png)\n\n또한 List에는 스와이프 삭제, 드래그 앤 드롭, 키보드 기반 탐색 등 많은 내장 상호작용 모드가 있습니다. 네이티브 컴포넌트를 사용할 때 이들은 자동으로 작동합니다. 사용자 지정 구현과 함께 하는 화면 판독기 작업을 어떻게 할 것인지 아시겠습니까?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리스트는 심지어 가장 복잡한 컴포넌트도 아닙니다. 사용자 정의 그리드나 레이아웃 프로토콜을 사용하지 않는 뷰의 사용자 정의 분배에 a11y를 어떻게 구현할 것인가요?\n\n# 이해관계자 설득\n\n이제 SwiftUI 앱에서 a11y를 빠르게 실행하는 방법을 이해했으니, 작업에 착수하기 전에 남은 퍼즐 조각은 비즈니스의 나머지 구성원으로부터 승인을 얻는 것입니다. 여기서 당신이 조직적 영향력을 행사하는 소프트 스킬을 펼칠 수 있습니다.\n\n당신이 휘둘 수 있는 큰, 둔한 도구 중 하나는 입법의 망치입니다. 영국, 미국, 그리고 EU와 같은 세계 각국은 디지털 서비스가 접근성의 최소 기준을 충족해야 한다는 법률을 시행했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 웹 접근성(웹 콘텐츠 접근성)은 실제로 비즈니스에서 큰 이점을 제공합니다. 현재 세계 인구의 16%가 중요한 장애를 겪고 있습니다. 즉, 다양한 요구에 맞게 서비스를 제공함으로써 사용자, 긍정적인 리뷰 및 수익을 놓칠 수 있습니다. 대상 시장에 따라 이는 더 또는 덜 중요할 수 있습니다.\n\n작은 규모에서는, 접근성을 제품 부채로 다루는 것보다 앱이 어떻게 오작동하는지 간단히 보여주는 것이 훨씬 효과적이라는 것을 발견했습니다. 접근성 요구사항을 추상적인 개념에서 벗어나서 버그 있는 가입 플로우를 보여주는 것이 어떤 엔지니어링 조직에게도 더 설득력있을 것입니다.\n\n제품에 쉽게 접근할 수 있도록 옹호하는 영향력 있는 리더십 속에 있는 옹호자를 가지는 것이 가장 도움이 됩니다. 물론, 모든 조직이 다르기 때문에 이 조언을 적용할 때 결과가 다를 수 있습니다.\n\n가장 중요한 것은, 이제 웹 접근성을 빠르게 적용하고 제품이 완전히 접근 가능한 상태라면?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공을 놓치지 마세요!\n\n기술 부채와 마찬가지로, 이제 좋은 위치에 있으니 a11y를 표준 개발 워크플로에 통합할 수 있습니다. 이미 알고 계시니 빠르고 쉽게 할 수 있어요!\n\n# 결론\n\n오늘 많은 내용을 다뤘습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 앱을 감사하여 대화형 텍스트 스케일링 또는 VoiceOver를 사용할 때 발생하는 일반적인 접근성 오류를 확인하는 프로세스를 거쳤습니다.\n\n텍스트 스케일링을 사용할 때 발생하는 문제를 수정하고, a11yScrollView로 스크롤링을 적용하고, @ScaledMetric으로 콘텐츠 스케일링하고, A11yHStack으로 정렬하는 방법을 살펴보았습니다.\n\n화면 판독기에서 앱이 잘 작동하도록 만들기 위해 accessibilityLabels를 구현했고, accessibilityElements를 결합하고, 심지어 완전히 사용자 정의된 accessibilityRepresentations도 구현했습니다.\n\n네이티브 SwiftUI 구성 요소 대신 사용자 지정보기를 사용하는 이유에 대해 논의했습니다. 이유로는 의미론, 상호 작용 모드 및 성능이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, 당신이 조직 내에서 접근성에 진지하게 대응하기 위해 소프트 스킬을 적용하는 방법을 살펴보았습니다.\n\n당신이 SwiftUI 앱에서 접근성에 진지하다면, 동반 앱을 통해 이러한 기술들을 직접 구현해보는 것을 적극 권장합니다. 도구를 체득하는 가장 좋은 방법이죠. 지금까지 작업해온 사이드 프로젝트가 있다면, 그것 역시 좋은 시작점일 것입니다.\n\n내 A11yUtils 라이브러리에 기여 (문제 포함)를 기쁘게 받아들이겠습니다. 지금도 SwiftUI에 이미 있는 API를 보완하기 위한 포괄적인 접근성 도구 모음으로 이것을 발전시키기 위해 커뮤니티와 협력하고 싶어합니다.\n","ogImage":{"url":"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png"},"coverImage":"/assets/img/2024-05-17-OhShtMyAppisSuccessfulandIDidntThinkAboutAccessibility_0.png","tag":["Tech"],"readingTime":27},{"title":"Jetpack Compose에서 안정성을 마스터하여 앱 성능 최적화하기","description":"","date":"2024-05-17 18:39","slug":"2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose","content":"\n![Jetpack Compose](/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png)\n\n젯팩 컴포즈는 구글의 첨단 UI 툴킷으로서, 안정적인 1.0 버전 이후 뛰어난 가능성을 보여주었습니다. Google의 보고에 따르면, 제트팩 컴포즈를 사용하여 개발된 앱이 이미 12만 5천 개 이상이 Google Play Store에서 성공적으로 출시되면서 프로덕션 목적으로의 채택이 급증했습니다.\n\n제트팩 컴포즈는 내장된 최적화 기능을 갖추고 있지만, 개발자들은 컴포즈가 UI 요소를 어떻게 렌더링하는지 이해하고, 다양한 시나리오에서 제트팩 컴포즈의 성능을 최적화하기 위한 전략을 파악해야 합니다. 이러한 지식은 애플리케이션의 성능에 잠재적인 영향을 최소화하고 더 나은 사용자 경험을 제공하기 위한 중요한 역할을 합니다.\n\n이 기사에서는 제트팩 컴포즈의 내부 작업을 이해하고, 안정성을 관리하여 애플리케이션의 성능을 향상시키는 방법을 안내하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Jetpack Compose 단계\n\n안정성에 대해 자세히 살펴보기 전에 Jetpack Compose의 단계를 이해하는 것이 중요합니다. 이 단계에서는 화면에 Compose UI 노드를 렌더링하는 과정이 여러 연속적인 단계를 통해 진행됩니다.\n\n![Jetpack Compose Phases](/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_1.png)\n\nJetpack Compose는 한 프레임의 렌더링을 세 가지 구분된 단계를 통해 실행합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 구성: 이 단계에서는 Composable 함수에 대한 설명을 생성하고 여러 메모리 슬롯을 할당함으로써 프로세스가 시작됩니다. 이러한 슬롯은 각 Composable 함수를 메모이즈하여 런타임 중에 효율적인 호출 및 실행을 가능하게 합니다.\n- 레이아웃: 이 단계에서는 Composable 트리 내 각 노드의 위치를 설정합니다. 레이아웃 단계는 주로 각 Composable 노드를 측정하고 적절히 배치하여 UI의 전체 구조 내에서 모든 요소가 정확히 배열되도록 보장합니다.\n- 그리기: 이 마지막 단계에서는 Composable 노드가 일반적으로 장치의 화면인 캔버스에 렌더링됩니다. 이 중요한 단계는 UI를 시각적으로 구축하여 설계된 Composables을 사용자 상호 작용을 위해 사용할 수 있게 합니다.\n\n내부 메커니즘은 훨씬 더 복잡하지만, 기본적으로 Composable 함수를 작성할 때 화면에 표시되기 위해 이러한 단계를 거칩니다.\n\n이제 레이아웃의 크기 및 색상과 같은 UI 요소를 수정하려고 한다고 가정해 봅시다. 그림 그리기 단계가 완료된 경우, Compose는 이러한 새 값들을 적용하기 위해 처음부터 다시 이러한 단계를 다시 방문해야 합니다. 이러한 업데이트 사이클을 재구성이라고 합니다:\n\n![이미지](/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n재구성은 입력 변경에 대한 응담으로 조합 가능한 함수가 새롭게 실행되어 Composition 단계에서 시작됩니다. 이 프로세스는 State에서 관찰하거나 내재적으로 Compose 런타임과 컴파일러 메커니즘들이 연관된 다양한 요소에 의해 트리거될 수 있습니다.\n\n전체 UI 트리와 요소를 재구성하는 것은 상당한 계산 리소스를 필요로 하며 앱의 성능에 직접적인 영향을 미칠 수 있습니다. 필요한 경우에만 재구성을 트리거함으로써(불필요할 때 재구성을 건너뛸 경우) 계산 리소스를 최소화하여 UI 성능을 향상시킬 수 있습니다.\n\n따라서, Compose 런타임의 작동 방식을 포함한 재구성 프로세스에 대한 심층적인 이해, 재구성을 건너뛸 기회를 식별하고 재구성을 트리거하는 요소를 인식하는 것이 중요합니다.\n\n이제 안정성 개념을 탐구하고 재구성 비용을 최적화하여 응용 프로그램 성능을 향상시킬 방법을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안정성 이해\n\n이전 섹션에서 언급된 바와 같이, 이미 렌더링된 UI를 업데이트하기 위해 다양한 방법이 존재합니다. Composable 함수의 매개변수의 안정성은 Compose 런타임과 컴파일러의 작동과 깊이 얽혀 있어, 재구성을 시작하는 결정적인 요소로 부각됩니다.\n\nCompose 컴파일러는 Composable 함수의 매개변수를 안정적인 것과 불안정한 것 두 가지로 분류합니다. 이러한 매개변수 안정성의 분류는 Compose 런타임에 의해 Composable 함수가 재구성되어야 하는지 여부를 결정하는 데 사용됩니다.\n\n# 안정함 vs. 불안정함\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제, 어떻게 매개변수가 안정적인지 불안정한지로 분류되는지 궁금할 수 있습니다. 이 결정은 Compose 컴파일러에 의해 이루어집니다. 컴파일러는 Composable 함수에서 사용된 매개변수의 유형을 검토하고 다음 기준에 따라 안정적인지를 분류합니다:\n\n- String을 포함한 기본 유형은 본질적으로 안정적입니다.\n- (Int) -` String과 같은 람다 표현식으로 나타낸 함수 유형은 안정적으로 간주됩니다.\n- 불변하고 안정적인 공개 속성으로 특징지어진 데이터 클래스 또는 안정성 주석인 @Stable이나 @Immutable과 같이 명시적으로 표시된 클래스는 안정적으로 간주됩니다. 이러한 주석의 구체적인 내용에 대해 다음 섹션에서 자세히 살펴볼 것입니다.\n\n예를 들어, 아래와 같이 데이터 클래스를 상상해 볼 수 있습니다:\n\nComposable 컴파일러에 의해 안정적으로 간주되는 불변 기본 속성으로 구성된 User 데이터 클래스입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나, Composable 함수 내에서 매개변수 유형을 평가하는 컴파일러는 아래 기준에 따라 해당 유형을 불안정하다고 식별합니다:\n\n- List, Map 등의 인터페이스와 Any와 같은 추상 클래스와 같이 컴파일 시간에 구현이 예측할 수 없는 유형은 불안정하다고 간주됩니다. 이 분류의 근거는 다음 섹션에서 더 자세히 논의될 예정입니다.\n- 특히 적어도 하나의 가변 또는 본질적으로 불안정한 공용 속성을 포함하는 데이터 클래스와 같은 클래스는 불안정하다고 분류됩니다.\n\n예를 들어, 다음과 같은 데이터 클래스를 상상해볼 수 있습니다:\n\nUser 데이터 클래스는 기본 속성으로 구성되어 있지만, 가변 이름 속성의 존재로 인해 Compose 컴파일러가 이를 불안정하다고 분류합니다. 이 분류는 안정성이 모든 속성의 종합적인 안정성을 평가하여 단일 가변 속성이 전체 클래스를 불안정하게 만들 수 있기 때문에 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스마트 재구성\n\n안정성의 원칙을 탐색하고 Compose 컴파일러가 안정적인지 불안정한지를 구별하는 방법을 살펴봤다면, 이러한 차이점을 활용하여 재구성을 트리거하는 실용적인 사용법에 관심이 생길 수 있습니다. Compose 컴파일러는 변경 가능 함수의 각 매개변수의 안정성을 평가하여 Compose 런타임이 이 정보를 효율적으로 활용할 수 있도록 기초를 마련합니다.\n\n클래스의 안정성이 결정되면, Compose 런타임은 이 통찰력을 활용하여 내부 메커니즘인 스마트 재구성을 통해 재구성을 시작합니다. 스마트 재구성은 제공된 안정성 정보를 활용하여 불필요한 재구성을 선택적으로 건너뛰어 Compose의 전체 성능을 향상시킵니다.\n\n스마트 재구성이 작동하는 원칙 중 일부는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 등가성 확인: Composable 함수에 새 입력이 전달될 때마다 해당 입력은 반드시 클래스의 equals() 메서드를 사용하여 이전 입력과 비교됩니다.\n- 안정성에 따른 결정:\n\n- 매개변수가 안정적이고 값이 변경되지 않은 경우 (equals()가 true를 반환), Compose는 관련 UI 구성 요소를 다시 구성하지 않습니다.\n- 매개변수가 불안정하거나 안정적이지만 값이 변경된 경우 (equals()가 false를 반환), 런타임은 다시 구성을 시작하여 UI 레이아웃을 무효화하고 다시 그립니다.\n\n위 시나리오에서 불필요한 다시 구성을 피함으로써 UI 성능을 향상시킬 수 있습니다. 전체 UI 트리를 다시 구성하는 것은 상당한 계산 리소스를 필요로하며, 적절하게 처리되지 않으면 성능에 부정적인 영향을 줄 수 있습니다.\n\nJetpack Compose는 스마트한 다시 구성을 기본적으로 제공하지만, Composable 함수에서 사용되는 클래스를 안정화하고 최대한 다시 구성을 줄이는 방법을 숙지하는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 합성 가능한 함수 추론하기\n\n이제 컴포즈 컴파일러가 클래스 안정성을 결정하고 컴포즈 런타임이 이 정보를 내부 메커니즘인 스마트 재구성으로 활용하는 방법을 이해했습니다. 그렇지만 이해해야 할 또 다른 중요한 개념은 합성 가능한 함수의 유형 추론입니다.\n\n컴포즈 컴파일러는 코틀린 컴파일러 플러그인을 사용하여 개발자가 작성한 소스 코드를 컴파일 시 분석할 수 있게 만들어졌습니다. 더불어, 컴포즈 함수의 고유한 특성과 더 잘 일치하도록 원본 소스 코드를 조정할 수 있습니다.\n\n컴파일러는 합성 가능한 함수를 시작 가능함, 이동 가능함, 대체 가능함 등으로 분류하여 실행을 최적화합니다. 이 게시물에서는 특히 재구성에 중요한 역할을 하는 시작 가능한 유형에 대해 자세히 살펴볼 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다시 시작 가능한\n\n다시 시작 가능한은 Composable 함수의 일종으로, Compose 컴파일러에 의해 결정되며 recomposition 프로세스의 중추 역할을 합니다. 이전에 탐구한 대로, Compose 런타임은 입력 값의 변화를 감지하면 이러한 새 입력 값으로 함수를 다시 시작(또는 다시 호출)하여 데이터 변경을 정확하게 반영합니다.\n\nCompose 런타임에서 제공하는 특정 주석으로 Composable 함수를 명시적으로 주석 처리하지 않으면 대부분의 함수는 기본적으로 다시 시작 가능하다고 간주됩니다. 이는 Compose 런타임이 언제든지 입력 또는 상태 변경이 발생할 때 해당 Composable 함수에 대해 recomposition을 트리거할 수 있다는 것을 의미합니다.\n\n# 건너뛰기 가능한\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSkipable은 또 다른 Composable 함수의 특성을 나타내며, 이는 이전 섹션에서 논의된 스마트 recomposition에 의해 설정된 적절한 조건 하에서 전체 recomposition 프로세스를 완전히 우회할 수 있음을 의미합니다. 따라서, skipable 함수가 바로 recomposition을 건너뛰고 UI 성능을 향상시킬 수 있는 잠재력과 직접적으로 연결된다고 단언할 수 있습니다. 이는 특정 상황에 따라서 달려있는데요.\n\n이 능력은 특히 규모가 큰 함수 호출 계층 구조의 정상 Composable 함수의 성능을 향상시키는 데 중요합니다. 이러한 루트 Composable의 recomposition을 건너뛰면, Compose는 이러한 루트 Composable의 recomposition을 건너뛰면, 해당 계층의 하위 함수들 중 어떤 것도 호출할 필요가 없어지며, 전체 recomposition 프로세스가 간소화됩니다.\n\nComposable 함수가 재시작 가능(restartable)이면서 동시에 skippable로 분류되는 경우도 있음을 기억하는 것이 중요합니다. skippable로 분류되면 재시작 가능한 recomposition을 거칠 수 있다는 것을 함축하므로요. 이제 작성한 Composable 함수가 재시작 가능 또는 skippable로 분류되는지 알아보는 방법을 살펴보겠습니다.\n\n# Compose Compiler Metrics\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCompose 컴파일러 플러그인을 사용하면 Compose에 고유한 특정 개념에 중점을 둔 자세한 보고서와 메트릭을 생성할 수 있습니다. 이러한 통찰력은 Compose 코드의 복잡성을 파헤치는 데 유용하며, 마이크로 레벨에서 작동 방식을 정확하게 이해할 수 있도록 도와줍니다.\n\nCompose 컴파일러 메트릭을 생성하려면, 아래 예제에 설명된 대로 루트 모듈의 build.gradle 파일에 컴파일러 옵션을 추가하면 됩니다:\n\n프로젝트를 동기화하고 빌드한 후, /build/compose_metrics 디렉토리에 생성된 세 가지 다른 파일인 module.json, composablex.txt 및 classes.txt에 액세스할 수 있습니다. 이 파일들을 각각 자세히 살펴보겠습니다.\n\n## 최상위 메트릭 (modules.json)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 보고서는 Compose에 특화된 고수준 메트릭을 제공하며, 주로 추적할 수 있는 숫자 데이터 지점을 생성하는 데 목적이 있습니다. 이러한 메트릭 간의 관계는 통찰력 있는 관찰을 제공할 수 있습니다. 예를 들어, \"skippableComposables\"의 수를 \"restartableComposables\"의 수와 비교하면, Composable 함수의 재구성이 건너뛰어질 비율을 나타내는 백분율이 도출됩니다.\n\n아래는 foundation 모듈을 위한 샘플 보고서입니다:\n\n```js\n{\n \"skippableComposables\": 36,\n \"restartableComposables\": 41,\n \"readonlyComposables\": 6,\n \"totalComposables\": 60,\n \"restartGroups\": 41,\n \"totalGroups\": 82,\n \"staticArguments\": 25,\n  \"certainArguments\": 138,\n  \"knownStableArguments\": 377,\n  \"knownUnstableArguments\": 25,\n  \"unknownStableArguments\": 24,\n  ..\n```\n\n## Composable Signatures (composables.txt)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 보고서는 사람이 이해하기 쉽도록 작성된 의사 Kotlin 스타일 함수 서명을 사용합니다. 이 모듈 내의 각 구성 가능한 함수를 자세히 살펴보며 각 매개변수를 분석하고 특정 통찰을 제공합니다.\n\n이 보고서는 전체 구성 가능한 함수가 다시 시작 가능한지, 건너뛸 수 있는지 또는 읽기 전용인지를 식별합니다. 또한 각 매개변수를 안정적인지 불안정한지로 레이블링하고 각 기본 매개변수 표현을 정적인지 동적인지로 표시하여 구성 가능한 특성에 대한 포괄적인 개요를 제공합니다.\n\n기본적으로 이러한 서명들은 Composable 함수가 건너뛰기 가능한지 여부를 분석하거나 함수가 건너뛰기가 불가능하도록 제약하는 불안정한 매개변수를 식별하는 데 사용할 수 있습니다.\n\n다음은 Composable 함수에 대한 샘플 보고서입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nrestartable skippable scheme(\"[androidx.compose.ui.UiComposable]\") fun Avatar(\n  stable modifier: Modifier? = @static Companion\n  stable imageUrl: String? = @static null\n  stable initials: String? = @static null\n  stable shape: Shape? = @dynamic VideoTheme.<get-shapes>($composer, 0b0110).circle\n  stable textSize: StyleSize? = @static StyleSize.XL\n  stable textStyle: TextStyle? = @dynamic VideoTheme.<get-typography>($composer, 0b0110).titleM\n  stable contentScale: ContentScale? = @static Companion.Crop\n  stable contentDescription: String? = @static null\n)\n\n## Classes (classes.txt)\n\nThis report also utilizes pseudo-Kotlin style function signatures crafted for human readability. This file is designed to help you grasp how the stability inferencing algorithm has interpreted a specific class. At the top level, each class is categorized as stable, unstable, or runtime. “Runtime” indicates that the stability is contingent on other dependencies, which will be determined at runtime (such as a type parameter or a type in an external module).\n\nThe stability assessment is based on the class’s fields, with each field listed under the class and labeled as stable, unstable, or runtime stable. The bottom line reveals the “expression” employed to determine this stability at runtime, providing a comprehensive overview of how each class`s stability is evaluated.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nstable class StreamShapes {\n  stable val circle: Shape\n  stable val square: Shape\n  stable val button: Shape\n  stable val input: Shape\n  stable val dialog: Shape\n  stable val sheet: Shape\n  stable val indicator: Shape\n  stable val container: Shape\n}\n```\n\n일련의 Compose 컴파일러 메트릭을 생성하는 프로세스를 탐험하고, 각 파일의 중요성을 이해하며, 이 정보를 사용하여 더 많이 건너뛸 수 있는 Composable 함수를 작성하려고 노력하는 방법을 배웠어요. 이 주제를 깊이 있게 탐구하고 싶다면 상세한 통찰을 얻기 위해 Interpreting Compose Compiler Metrics를 확인해보세요.\n\n# 안정성 주석\n\n이제 Compose 컴파일러가 안정성을 처리하는 방식과 이러한 안정성 결정이 다시 구성에 어떻게 영향을 미치는지, 그리고 당신의 애플리케이션 성능에 어떻게 영향을 미칠 수 있는지 통찰력을 얻었어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nComposed of immutability and stability annotations, let's take a journey into transforming changeable classes into reliable ones using annotations from the compose-runtime library. The main actors in this process are @Immutable and @Stable.\n\n# Immutability\n\nWhen you decorate your class with the @Immutable annotation, you reassure the Compose compiler that all public properties and fields within the class will remain unchanged (immutable) once they are created. This provides a more solid guarantee compared to the val keyword at the language level. While val prevents properties from being modified via a setter, it still allows creation through mutable data structures like Lists initialized with MutableList.\n\nTo make sure your classes are distinctly marked as stable with the @Immutable annotation, adhere to the guidelines below:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모든 공용 속성에 val 키워드를 사용하여 불변성을 보장하세요.\n- 사용자 지정 setter를 피하고 공용 속성이 변경 가능성을 지원하지 않도록 합니다.\n- 모든 공용 속성의 유형이 본질적으로 불변 또는 안정적이거나 안정성 주석으로 명시적으로 표시되었는지 확인하세요. 예를 들어 인터페이스는 불안정하다고 간주되므로 속성으로 사용되는 모든 인터페이스 유형도 안정성을 위해 주석을 달아야 합니다.\n- 컬렉션인 속성들의 경우, 안정성을 유지하기 위해 kotlinx.collections.immutable에서 제공하는 불변 컬렉션을 선택하세요.\n\n@Immutable 주석은 위의 불변성 규칙을 준수하는 클래스에 효과적이며, 불필요한 recomposition을 건너뛰어 응용프로그램 성능을 향상시킬 때 중요한 역할을 합니다.\n\n그러나 @Immutable 주석을 분별하게 사용하는 것이 중요합니다. 적절하게 사용하지 않으면 의도하지 않은 recomposition 건너뛰기로 인해 Compose 레이아웃이 예상대로 업데이트되지 않을 수 있습니다.\n\n# 안정함\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`@Stable` 어노테이션은 `@Immutable` 어노테이션보다 Compose 컴파일러에 더 강력하지만 약간 덜 엄격한 커밋먼트를 나타냅니다. 함수나 프로퍼티에 적용되면, `@Stable` 어노테이션은 해당 유형이 가변할 수 있다는 것을 나타냅니다. 처음에는 약간 모순적으로 보일 수도 있습니다. 이 문맥에서 \"Stable\"이라는 용어는 함수가 동일한 입력에 대해 항상 동일한 결과를 반환할 것이라는 의미로, 잠재적인 가변성에도 불구하고 예측 가능한 동작을 보장합니다.\n\n따라서 `@Stable` 어노테이션은 주로 public 프로퍼티가 불변인 클래스에 적합하지만 클래스 자체가 안정적이지 않을 수 있는 경우에 사용됩니다. 예를 들어, Jetpack Compose의 State 인터페이스는 value라는 불변 프로퍼티만 노출합니다. 그러나 이 불변 프로퍼티의 내부 값은 여전히 setValue 함수를 통해 수정될 수 있으며, 일반적으로 MutableState를 생성하여 이를 수행합니다.\n\nState와 MutableState를 통한 데모로 보여 준 것처럼, MutableState에 의해 생성된 State 인스턴스는 getValue 함수(값 프로퍼티의 게터)로부터 일관되게 동일한 값을 얻을 것이며, setValue 함수에 대한 동일한 입력에 대해 동일한 결과를 반환합니다. 제공된 코드 스니펫에서는 `@Stable` 어노테이션이 지정된 State와 MutableState 인터페이스를 모두 보여줍니다.\n\n# Immutable vs Stable\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**@Immutable**과 **@Stable** 주석 사이의 구별과 어떤 것을 사용해야 하는지 결정하는 것은 처음에는 혼란스러울 수 있습니다. 하지만 실제로는 꽤 간단합니다. 이전에 언급했듯이, **@Immutable** 주석은 클래스의 모든 공용 속성이 불변이라는 의미로, 생성된 후에 상태가 변경될 수 없음을 나타냅니다. 반면에 **@Stable** 주석은 가변 객체에 적용될 수 있으며, 동일한 입력에 대해 일관된 결과를 생성해야 하는 것을 요구합니다.\n\n**@Immutable** 주석은 대부분 도메인 모델에 적용되는데, 특히 Kotlin 데이터 클래스를 사용할 때 다음 예시에서와 같이 나타납니다:\n\n반면에 **@Stable** 주석은 여러 구현 가능성을 제공하는 인터페이스에 대해 일반적으로 사용되며, 내부 가변 상태를 가질 수 있습니다. 아래 의미 있는 예시는 이 주석을 이해하는 데 도움이 됩니다:\n\n**@Stable** 주석을 적용하면 **UiState** 클래스를 안정적으로 지정할 수 있습니다. 이는 최적화된 건너뛰기와 지능적인 재구성을 가능하게 하여 업데이트의 효율성을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# NonRestartableComposable\n\nJetpack Compose의 @NonRestartableComposable 주석은 특정 구성 가능한 함수의 recomposition 동작을 최적화하기 위해 고안된 비교적 고급 기능입니다. 이 주석은 구성 가능한 함수가 호출 매개변수의 변경으로 인해 recomposition 중 자동으로 다시 시작되지 않아야 함을 Compose 컴파일러에 알리는 역할을 합니다. 일반적으로 구성 가능한 함수의 입력 값이 변경되면 Compose 런타임은 함수를 다시 시작하여 새로운 입력 값을 소비하게 할 수 있습니다.\n\n그러나 이러한 다시 시작이 항상 필요하거나 원하는 것은 아닐 수 있습니다, 특히 함수의 내부 상태나 부작용을 다시 시작해야 할 때가 아닌 경우에 해당합니다. @NonRestartableComposable을 적용하면 런타임이 함수를 다시 시작하지 않고 매개변수를 업데이트하도록 지시하여 내부 상태와 진행 중인 부작용을 유지할 수 있습니다.\n\n@NonRestartableComposable의 일부로 동작하는 대표적인 예는 Compose 런타임 라이브러리의 Side-effect API 내에서 발견됩니다. 예를 들어 LaunchedEffect의 구현은 이 주석을 사용하여 효과가 불필요하게 다시 시작되지 않도록 보장합니다. 아래 코드에서 보여진 것처럼요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 @NonRestartableComposable 주석을 사용할 때 주의해야 하며 앱 성능을 향상시키기 위한 수단으로만 사용해서는 안 됩니다. 선별적으로 사용하지 않으면 원하지 않는 결과로 이어질 수 있습니다.\n\n# Composable 함수 안정화\n\n앱 성능을 최적화하는 목적으로 안정한 클래스를 작성하는 방법에 대해 알아보았습니다. 그러나 Composable 함수의 완전한 안정성 달성은 여기서 멈추지 않습니다. 왜냐하면 일부 클래스(예: Kotlin의 컬렉션 또는 제3자 라이브러리에서 제공하는 클래스)는 직접 제어할 수 없을 수 있기 때문입니다.\n\n이전에 언급했던 바와 같이 스마트 recomposition 중 Composable 함수를 건너뛸 수 있는 능력은 해당 함수의 각 매개변수의 안정성에 의해 결정됩니다. 스마트 recomposition을 위해 Composable 함수 내에서 사용되는 모든 매개변수가 안정적임을 보장하는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션에서는 Composable 함수를 스킵할 수 있는 네 가지 다른 전략을 탐구하여 효율적인 recomposition으로 성능을 향상시킬 수 있습니다.\n\n# Immutable Collections\n\n처음에는 List가 요소를 수정하는 것을 허용하지 않더라도, 인터페이스인 특히 kotlin.collections이 Jetpack Compose에서 불안정하게 여겨지는 이유를 의심할 수 있습니다.\n\n아래의 좋은 예제를 살펴보면 그 이유를 이해할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nuserList 필드는 List로 선언되어 있습니다. List는 기본적으로 요소의 수정을 허용하지 않습니다. 그러나 첫 번째 줄에서 나와 있듯이, 이 List는 MutableList로부터 생성될 수 있습니다. 이는 List 인터페이스 자체가 수정을 제한하지만 해당 내부 구현이 변경 가능할 수 있다는 것을 의미합니다. Compose 컴파일러는 구현 유형을 추론할 수 없어, 이러한 인스턴스들을 안정적이지 않은 것으로 간주하여 정확한 동작을 보장합니다.\n\n그러므로 공식 Android 문서에서는 Composable 함수의 컬렉션 매개변수의 안정성을 보장하기 위해 kotlinx.collections.immutable 라이브러리나 Guava의 Immutable Collections를 활용할 것을 권장합니다.\n\nkotlinx.collections.immutable 라이브러리는 ImmutableList 및 ImmutableSet과 같은 여러 컬렉션을 제공하며, 이는 표준 kotlin.collections의 동작을 모방하지만 변경 불가능합니다. 이러한 컬렉션은 읽기 전용이며, 생성 후에는 수정이 불가능합니다.\n\n이제 Compose 컴파일러가 kotlinx.collections 대비 kotlinx.collections.immutable의 안정성을 결정할 때 고려하는 주요 요소에 대해 궁금해 할 수 있습니다. 구분은 Compose 컴파일러가 변경 불가능 컬렉션을 이해하는 데 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 자세한 통찰을 얻으려면 Compose 컴파일러 라이브러리의 일부인 KnownStableConstructs.kt 파일을 참고하십시오. 아래 코드를 보면, Compose 컴파일러가 안정적으로 간주해야 하는 클래스의 패키지 이름 목록을 수동으로 유지한다는 것을 확인할 수 있습니다:\n\n아래 코드 조각을 살펴보면, Composable 함수의 매개변수 안정성을 분석하는 Compose 컴파일러의 일부입니다. 알려진 안정 구조체 클래스에 나열된 매개변수 유형에 대한 안정성을 컴파일러가 유추하지 않는 것이 분명합니다:\n\n## Lambda\n\nCompose 컴파일러에서는 Kotlin 람다 표현식의 처리가 독특한 접근 방식을 취합니다. 이전에 설명한 바와 같이, Compose 컴파일러는 IR(Intermediate Representation) 변환을 통해 개발자가 작성한 소스 코드를 수정합니다. 따라서 컴파일러는 Composable 함수에 전달된 람다의 실행을 최적화하기 위해 Compose 런타임에 일부 규칙을 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCompose 컴파일러는 람다 표현식을 처리할 때 람다가 값을 캡처하는지 여부에 따라 다른 방식으로 다룹니다. 클로저의 맥락에서 값들을 캡처하는 것은 람다 표현식이 직접적인 범위 외부에 있는 변수에 의존한다는 의미입니다. 외부 변수에 독립적인 람다라면 아래 예시처럼 값들을 캡처하지 않는다고 말할 수 있습니다:\n\n람다 매개변수가 어떤 값도 캡처하지 않는 경우, Kotlin은 이러한 람다를 싱글톤으로 처리하여 불필요한 할당을 최소화합니다. 반면, 람다가 클로저 밖의 변수에 의존하는 경우, 아래 예시에서 볼 수 있듯이 값들을 캡처한다고 간주됩니다:\n\n람다 매개변수가 외부 값들을 캡처하는 경우, 그 실행 결과는 캡처된 값들에 따라 달라질 수 있습니다. 이를 해결하기 위해, Compose 컴파일러는 메모리제이션 전략을 사용하여 람다를 remember 함수 호출 내에 캡슐화합니다. 캡처된 값은 remember에 대한 키 매개변수로 작용하여, 캡처된 값들의 변화에 적절히 반응하여 람다가 적절하게 재호출되도록 합니다.\n\n결과적으로, 람다가 값들을 캡처하는지 여부에 관계없이, 해당 람다는 Composable 함수 내에서 안정적으로 간주됩니다. Composable 함수가 Any 유형의 매개변수를 수용하는 시나리오를 고려해보면, Any가 변경 불가능한 값을 포함하는 등 다양한 값 범위를 포함할 수 있기 때문에, Compose 컴파일러에서는 불안정하게 취급됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 아래 예시와 같이 람다 표현식을 사용하여 값을 제공하는 경우, Compose 컴파일러는 람다 매개변수를 안정적으로 처리합니다:\n\n# Wrapper Class\n\nComposable 함수를 안정화하는 또 다른 효과적인 전략은 제어 범위를 벗어난 불안정한 클래스에 대한 래퍼 클래스를 만드는 것입니다. 이러한 경우에는 예시와 같이 안정성 주석을 직접 적용할 수 없는 클래스에 적용할 수 있습니다.\n\n그런 다음 Composable 함수의 매개변수 유형으로 이 래퍼 클래스를 활용할 수 있습니다. 아래 코드에서 보여지는 것처럼요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파일 구성\n\nCompose 컴파일러 버전 1.5.5부터 구성 파일에서 클래스를 나열할 수 있는 옵션이 추가되었습니다. 이러한 지정된 클래스는 Compose 컴파일러에 의해 안정적으로 인식됩니다. 이 기능은 서드파티 라이브러리에서 가져온 클래스와 같이 제어할 수 없는 클래스들을 사용할 때 매우 유용합니다.\n\n이 기능을 활성화하려면 아래와 같이 앱 모듈의 build.gradle.kts 파일에 Compose 컴파일러 구성을 추가하십시오:\n\n다음으로, 앱 모듈의 루트 디렉토리에 compose_compiler_config.conf 파일을 아래와 같이 생성하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// LocalDateTime을 안정적으로 간주합니다.\njava.time.LocalDateTime\n// Kotlin 컬렉션을 안정적으로 간주합니다.\nkotlin.collections.*\n// 내 데이터 계층과 모든 하위 모듈을 안정적으로 간주합니다.\ncom.datalayer.**\n// 제네릭 타입을 첫 번째 타입 매개변수를 기반으로 안정적으로 간주합니다.\ncom.example.GenericClass<*,_>\n```\n\n프로젝트를 빌드하고 Compose 컴파일러 메트릭을 생성하면, 구성 파일에서 지정한 클래스들이 안정적으로 인식되어 스마트 재구성을 건너뛸 수 있습니다.\n\n공식 안드로이드 가이드에 따르면, Compose 컴파일러는 각 프로젝트 모듈 별로 독립적으로 작동하므로 필요에 따라 다른 모듈에 대해 각기 다른 구성을 제공할 수 있습니다. 또는 프로젝트 루트 수준에서 단일 구성을 선택하고 각 모듈에 대해 해당 경로를 지정할 수도 있습니다.\n\n기억해야 할 중요한 점은 구성 파일이 정의된 클래스들을 기본적으로 안정적으로 만들지 않습니다. 대신, 구성 파일을 활용하여 Compose 컴파일러와 계약을 맺는 것입니다. 따라서이 기능을 분별있게 사용하여 특정 시나리오에서 스마트 재구성 프로세스를 우연히 건너뛰는 일을 피해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 멀티 모듈 아키텍처의 안정성\n\n당신의 Gradle 모듈을 모듈화하는 것은 훌륭한 전략으로, 향상된 재사용성, 병렬 빌드, 탈중앙화된 팀 집중력 등의 혜택을 제공합니다. 안드로이드 공식 가이드도 모듈화를 권장하며, 프로젝트 규모에 맞게 코드의 확장성을 향상시키고 가독성을 개선하며 전반적인 코드 품질을 높이는 수단으로 모듈화를 소개합니다.\n\n모듈화는 Jetpack Compose에서 고유한 도전 과제를 소개합니다: 독립된 모듈로부터의 클래스는 그들의 퍼블릭 프로퍼티의 불변성 여부와 상관없이 불안정하다고 간주됩니다. 이를 극복하기 위해, 데이터 모듈에 compose-runtime 라이브러리를 가져오고 데이터 클래스에 안정성 주석을 달 것을 권장합니다.\n\n그러나, Jetpack Compose 런타임 라이브러리에 직접 의존하지 않고 순수한 Kotlin/JVM 라이브러리에 초점을 맞춘 경우에는 compose 런타임 라이브러리에 의존하는 것이 이상적이지 않은 경우가 있을 수 있습니다. 이러한 시나리오에서 두 가지 주요 솔루션이 제시됩니다: compose-stable 마커 라이브러리를 채택하거나 안정성을 보장하기 위해 파일 구성을 활용하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안정적인 마커 작성기\n\n\"안정적인 마커\" 라이브러리는 @Immutable 및 @Stable과 같은 안정성 주석을 제공하며, 이는 compose-runtime 라이브러리 내의 유사한 주석 기능을 반영합니다. compose-runtime 라이브러리를 직접 사용하는 것 대신 compose-stable 마커 라이브러리를 선택하면 아래에 설명된 두 가지 주요 이점이 제공됩니다:\n\n- 가벼움: 클래스, 함수 및 확장 기능이 풍부한 compose-runtime 라이브러리는 응용 프로그램의 크기를 늘릴 수 있는 가능성이 있습니다. 반면에 compose-stable 마커 라이브러리는 안정성 주석에만 초점을 맞춘 가벼운 대안을 제공합니다. 이를 통해 응용 프로그램의 크기를 줄이고 전체 compose-runtime 라이브러리를 사용하는 것보다 빌드 시간을 단축할 수 있습니다.\n- 의존성 없음: compose-runtime 라이브러리에는 SideEffect, LaunchedEffect, snapshotFlow 및 Compose 컴파일러와 관련된 기타 주석들과 같은 Compose 런타임 기능을 실행하는 데 필수적인 기능이 포함되어 있습니다. 이러한 설정은 데이터 모듈에 필요하지 않은 경우에도 모듈이 이러한 API에 액세스 할 수 있는 가능성을 발생시킬 수 있습니다. compose-stable 마커 라이브러리를 선택하면 이러한 특수화된 API에 실수로 액세스하는 위험을 제거하여 모듈이 집중되고 효율적으로 유지되도록 보장합니다.\n\n해당 라이브러리의 좋은 사용 사례는 Compose용 Stream의 적응 가능한 채팅 및 비디오 SDK의 코어 모듈에서 발견할 수 있습니다. 이러한 SDK의 코어 모듈은 compose-stable 마커를 활용하여 도메인 클래스를 안정적으로 지정합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncompose-stable-marker 라이브러리에 대해 더 알아보려면 GitHub 저장소를 방문해 주세요.\n\n# 파일 구성\n\n이전 섹션에서 논의한 것처럼 파일 구성은 Compose 컴파일러와의 계약을 달성하여 원본이나 가변성과 무관하게 특정 클래스를 안정적으로 다루도록 합니다. 이는 다른 모듈에서 클래스를 나열하여 파일 구성에 포함시키면 컴파일러가 자동으로 이를 안정적인 것으로 인식한다는 것을 의미합니다.\n\n한 가지 강조해야 할 점은 이 기능을 분별하여 사용해야 합니다. Compose 컴파일러는 이러한 클래스들을 안정적으로 지속적으로 다룰 것이므로 스마트한 재구성 행동을 조정하여 의도하지 않은 동작을 유발할 수 있습니다. 또한, 이러한 강제적인 안정성으로 인한 디버깅 문제는 애플리케이션 내에서 해결하기 어려울 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 강한 스킵 모드\n\n컴포저블 함수를 제작할 때 건너뛸 수 있는 또 다른 전략은 강한 스킵 모드를 활성화하는 것입니다. Compose Compiler 버전 1.5.4에서 소개된 이 기능은 불안정한 매개변수를 포함한 경우에도 컴포저블 함수를 건너뛸 수 있게 해주며, 불안정한 캡처를 포함하는 람다를 최적화된 성능을 위해 메모이즈합니다.\n\n현재 실험 단계에 있으며 아직 제품용으로 준비되지 않았지만, 강한 스킵 모드는 Compose 1.7 알파에서 기본으로 활성화될 예정입니다. 효과와 안정성은 베타 단계로 진행되기 전에 철저히 평가될 것입니다. 일시적으로 이 실험적 기능을 활성화하려면 다음 Compose 컴파일러 옵션을 포함시키면 됩니다:\n\n강한 스킵 모드는 재구성 중에 컴포저블 함수를 건너뛸 때 Compose 컴파일러가 사용하는 전통적인 안정성 기준을 수정합니다. 일반적인 상황에서 컴포저블 함수는 오직 안정적인 매개변수만 포함하고 있는 경우에만 건너뛸 수 있는 것으로 간주됩니다. 그러나 강한 스킵 모드는 이 전통을 변경합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기능이 활성화되면 모든 다시 시작 가능한 Composable 함수가 건카볼입니다. 이전 값을 무시하고 불안정한 매개변수가 포함되었는지 여부에 관계없이. 그러나, 다시 시작할 수 없는 Composable 함수는 영향을 받지 않으며 건너뛸 수 없습니다.\n\n재조합 중 Composable 함수를 건너뛸지 여부를 평가할 때 이 모드는 불안정한 매개변수와 해당 이전 값과의 인스턴스 동등성을 비교하기 위해 사용됩니다. 반면에, 안정적 매개변수는 Object.equals()에 의해 정의된 객체 동등성을 사용하여 비교됩니다.\n\n재조합 중 이러한 기준에 모든 매개변수가 일치하는 경우 Composable 함수가 우회됩니다. 불필요한 업데이트를 줄여 성능을 최적화합니다.\n\nComposable 함수를 강력한 건카볼 모드에서 제외하고 다시 시작할 수 있지만 건너뛸 수 없도록 만들려면 @NonSkippableComposable 주석을 적용할 수 있습니다. 이는 매개변수 안정성과 관계없이 항상 재조합을 위해 해당 함수가 고려됨을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한편, 객체 동등성(object equality)을 사용하여 객체를 비교하려면 여전히 도메인 모델 클래스에 @Stable 주석을 추가해야 합니다.\n이 기능과 람다 메모이제이션(Lambda Memoization)의 향상된 개념에 대한 더 깊은 이해를 위해 '강력한 스킵 모드(Strong Skipping Mode)'에 대한 상세 가이드를 참조해보세요.\n\n# 결론\n\n탐험이 마무리되었습니다! 안정성의 개념, 안정성 추론과 스마트 recomposition 뒤에 숨은 메커니즘, 클래스 및 Composable 함수를 안정화하는 효과적인 전략, 그리고 응용 프로그램 성능을 향상시키는 방법에 대해 다루었습니다.\n\n안정성의 중요성을 깨달으면 화면에 UI 노드를 렌더링하는 메커니즘에 영향을 줌으로써 최종적으로 응용 프로그램의 성능에 영향을 미치게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원래 getstream.io에 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-17-OptimizeAppPerformanceByMasteringStabilityinJetpackCompose_0.png","tag":["Tech"],"readingTime":30}],"page":"116","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":19,"currentPageGroup":5},"__N_SSG":true}