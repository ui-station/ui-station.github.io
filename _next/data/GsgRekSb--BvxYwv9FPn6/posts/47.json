{"pageProps":{"posts":[{"title":"UI 개발을 위해 서버가 필요하지 않아요 - 네, 정말 그렇게요","description":"","date":"2024-06-19 11:13","slug":"2024-06-19-IDontNeedaServerforUIDevelopmentYesYouHeardItRight","content":"\n<!--\n/assets/img/2024-06-19-IDontNeedaServerforUIDevelopmentYesYouHeardItRight_0.png\n\nUI 개발 세계에서 많은 사람들이 지속적인 서버 개발, 배포 문제, 서버 이용 불가 등과 같은 다양한 서버 관련 장애물을 직면합니다. 이러한 도전에 부딪치면 개발 프로세스가 느려질 수 있습니다. 이러한 장애물을 극복하기 위해 나는 개발자들이 HTTP 서버를 모의하여 예측 가능하고 테스트 가능하며 독립적인 UI 환경을 만들 수 있도록 해주는 강력한 툴인 WireMock을 사용하기로 결정했습니다.\n\n이 글에서는 WireMock를 설정하고 다양한 시나리오를 구성하며 엔드포인트를 유효성 검사하는 과정을 안내해드리겠습니다. 초기 WireMock 템플릿은 이 \n\n참조 동영상은 여기에서 확인할 수 있습니다.\n-->\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# WireMock을 사용하는 이유\n\nWireMock은 개발 중에 서버 의존성을 제거하는 데 도움이 됩니다. 서버 응답을 시뮬레이션함으로써 실제 서버가 준비되거나 이용 가능할 때까지 기다리지 않고 UI를 개발하고 테스트할 수 있습니다. 이 접근 방식은 통합하기 전에 모든 가능한 엣지 케이스를 다룰 수 있도록 보장하여 응용 프로그램의 신뢰성과 견고성을 향상시킵니다.\n\n# WireMock 설정하기\n\n로컬 머신에서 WireMock을 설정하려면 다음 단계를 따르세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리포지토리를 복제하세요:\n\ngit clone https://github.com/piappstudio/WireMock.git\n\nWireMock 실행: 터미널을 열고 로컬 서버를 설정하기 위해 다음 명령을 실행하세요:\n\n```js\njava -jar wiremock-standalone-3.6.0.jar --port 9191 --verbose --global-response-templating --jetty-header-buffer-size 16384\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 명령은 WireMock 서버를 9191 포트에서 시작하며 자세한 로깅과 전역 응답 템플릿 사용이 활성화됩니다.\n\n## 폴더 구조\n\n- \\_\\_file\n  - \\_\\_files 폴더는 응답 일부로 제공될 수 있는 정적 파일을 저장하는 데 사용됩니다. 이러한 파일에는 JSON, XML 또는 기타 반환하려는 콘텐츠가 포함될 수 있습니다.\n- mappings\n  - \\_\\_files 폴더는 모의 요청에 대한 응답의 일부로 제공될 수 있는 정적 파일을 저장하는 데 사용됩니다. 이 파일에는 JSON, XML, HTML 또는 기타 반환하려는 콘텐츠가 포함될 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-IDontNeedaServerforUIDevelopmentYesYouHeardItRight_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 JSON 응답을 반환하는 스텁을 만들고 싶다면 다음과 같이 작성할 수 있습니다. GET 요청이 /v1/biggoss/shows로 들어오는 경우를 가정하겠습니다.\n\n```js\n{\n  \"request\": {\n    \"method\": \"GET\",\n    \"url\" : \"/v1/biggboss/shows\"\n  },\n  \"response\": {\n    \"status\": 200,\n    \"headers\": {\n      \"Content-Type\": \"application/json\"\n    },\n    \"bodyFileName\": \"biggboss-shows-api/default.json\"\n  }\n}\n```\n\n- Request: 수신된 요청의 구조를 정의합니다.\n- Response: 위 요청에 대한 응답의 구조를 정의합니다.\n\n# API 유효성 검사\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n/v1/biggboss/shows 엔드포인트를 유효성 검사하려면 다음 단계를 따라 주세요:\n\n- Postman 열기: Postman에 WireMock-BiggBoss.postman_collection.json 파일을 가져오세요.\n- 요청 호출: “Bigg Boss Shows” 엔드포인트로 요청을 보내 응답을 받으세요.\n\n```js\n{\n  \"shows\": [\n    {\n      \"title\": \"BiggBoss Tamil Season 7\",\n      \"id\": \"bbtamil7\",\n      \"host\": \"Kamalahaasan\",\n      \"start_date\": \"2023-10-01\",\n      \"end_date\": \"2024-01-14\",\n      \"winner\": \"Archana\",\n      \"runner\": \"Manichandra\",\n      \"cash\": \"Poornima (16L)\",\n      \"logo\": \"https://raw.githubusercontent.com/piappstudio/resources/main/biggboss/images/shows/tamil/session7/logo.png\",\n      \"more_info\": \"https://raw.githubusercontent.com/piappstudio/resources/main/biggboss/json/shows/tamil_session_7.json\",\n      \"trends\": \"https://raw.githubusercontent.com/piappstudio/resources/main/biggboss/json/shows/tamil_session_7_trends.json\",\n      \"votes\": \"https://raw.githubusercontent.com/piappstudio/resources/main/biggboss/json/shows/tamil/season7/votes.json\"\n    }\n  ],\n  \"reviewers\": [\n    {\n      \"channel_name\": \"SBI Electroal Bond - 1 (Google Drive)\",\n      \"description\": \"Google Drive에서 더 나은 분석을 위해 엑셀 형식의 선거채권 파트-1 다운로드\",\n      \"url\": \"https://docs.google.com/spreadsheets/d/17DJrN1orB93OTIYF6QMiFj1aZ9F2WZrA_D8zfjH56FE\",\n      \"image\": \"https://i.ytimg.com/vi/z_OY38rDj9k/hq720.jpg\"\n    },\n    {\n      \"channel_name\": \"SBI Electroal Bond - 2 (Google Drive)\",\n      \"description\": \"Google Drive에서 더 나은 분석을 위해 엑셀 형식의 선거채권 파트-2 다운로드\",\n      \"url\": \"https://docs.google.com/spreadsheets/d/1GQBoGkyqNd3HOWDaJc2ueOmDQpmYob74\",\n      \"image\": \"https://i.ytimg.com/vi/z_OY38rDj9k/hq720.jpg\"\n    },\n    {\n      \"channel_name\": \"Bigg Boss Tamizh Review\",\n      \"description\": \"BiggBoss 리뷰, 비평가, 트롤 및 심층 분석\",\n      \"url\": \"https://www.youtube.com/@tamizhreview/videos\",\n      \"image\": \"https://raw.githubusercontent.com/piappstudio/resources/main/biggboss/images/shows/tamil/session7/channels/tamizhreview.png\"\n    },\n    {\n      \"channel_name\": \"Pi App Studio\",\n      \"description\": \"타밀어로 무료 iOS 및 안드로이드 개발 강좌\",\n      \"url\": \"https://www.youtube.com/@piappstudio/videos\",\n      \"image\": \"https://raw.githubusercontent.com/piappstudio/resources/main/biggboss/images/shows/tamil/session7/channels/piappstudio.png\"\n    }\n  ]\n}\n```\n\n이제 시나리오 기반 구성으로 넘어가 봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# WireMock의 기본 키워드 이해하기\n\n## Url/UrlPathPattern\n\nWireMock에서 처리할 URL을 정의합니다.\n\n## Priority\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환경 설정의 우선순위를 설정합니다. 여러 개의 설정이 존재하는 경우, 우선 순위가 가장 높은 것(숫자가 가장 작은 것)이 선택됩니다. 기본값은 5이며, 여기서 1이 가장 높은 우선 순위이고 Integer.MAX_VALUE(Java)가 가장 낮은 우선 순위입니다.\n\n## 시나리오명\n\n- 정의: 동일 시나리오에 속하는 관련된 스텁 그룹을 나타내는 고유 식별자입니다.\n- 목적: 여러 요청과 응답을 연결하여 상태를 유지하는 동작을 가능케 합니다.\n- 예시: \"scenarioName\": \"biggboss-show\"\n\n## newScenarioState\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- **정의:** 요청이 일치되고 응담이 제공된 후 시나리오가 전환하는 상태입니다.\n- **목적:** 시나리오가 다른 상태로 이동하여 순차적인 상태 기반 상호작용이 가능하도록 합니다.\n- **예시:** \"newScenarioState\": \"shows-only\"\n\n## 요구 시나리오 상태\n\n- **정의:** 특정 스텁이 요청과 일치하려면 시나리오가 있어야 하는 상태를 지정합니다.\n- **목적:** 시나리오가 특정 상태에 있을 때만 스텁이 일치하도록 보장합니다.\n- **예시:** \"requiredScenarioState\": \"shows-only\"\n\n# 빈 시나리오 구성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n새로운 엔드포인트/시나리오/shows/empty를 만들어서 \"shows-empty\" 상태를 트리거하는게 좋을 거예요.\n\n```js\n{\n  \"scenarioName\": \"biggboss-show\",\n  \"newScenarioState\": \"shows-empty\",\n  \"request\": {\n    \"method\": \"POST\",\n    \"urlPathPattern\" : \"/scenario/shows/empty\"\n  },\n  \"response\": {\n    \"status\": 200,\n    \"body\": \"Empty show scenario stated\"\n  }\n}\n```\n\n이 구성은 \"Bigg Boss\" 쇼를 관리하는 애플리케이션의 동작을 시뮬레이션하고 싶은 경우 유용합니다. /scenario/shows/empty 엔드포인트로 포스트를 보내면 시나리오의 상태가 \"shows-empty\"로 전환되어 후속 요청 처리에 영향을 줄 수 있습니다.\n\n이제 이 상태를 감지하고 /v1/biggboss/shows에 대한 응답을 구성해볼까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n{\n  \"scenarioName\": \"biggboss-show\",\n  \"requiredScenarioState\": \"shows-empty\",\n  \"request\": {\n    \"method\": \"GET\",\n    \"url\" : \"/v1/biggboss/shows\"\n  },\n  \"response\": {\n    \"status\": 200,\n    \"headers\": {\n      \"Content-Type\": \"application/json\"\n    },\n    \"bodyFileName\": \"biggboss-shows-api/empty_shows.json\"\n  }\n}\n```\n\nempty_shows.json\n\n```js\n{\n}\n```\n\n여기서 /v1/biggboss/shows API에 대해 shows-empty가 요구되는 경우 empty_shows.json 파일을 설정하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 실행 단계\n\n- Mock 서버 시작\n- “shows-empty” 시나리오를 트리거하기 위해 /scenario/shows/empty를 호출\n- 빈 JSON을 받기 위해 클라이언트 API /v1/biggboss/shows 호출\n\n# 리뷰어 전용 시나리오 구성\n\nshows-reviewers-only 시나리오를 트리거하기 위한 새로운 엔드포인트/scenario/shows/reviewers 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n{\n  \"scenarioName\": \"biggboss-show\",\n  \"newScenarioState\": \"shows-reviewers-only\",\n  \"request\": {\n    \"method\": \"POST\",\n    \"urlPathPattern\": \"/scenario/shows/reviewers\"\n  },\n  \"response\": {\n    \"status\": 200,\n    \"body\": \"Only reviewers scenario stated\"\n  }\n}\n```\n\nshows-reviewers-only시나리오와 일치하도록 스텁 구성\n\n```json\n{\n  \"scenarioName\": \"biggboss-show\",\n  \"requiredScenarioState\": \"shows-reviewers-only\",\n  \"request\": {\n    \"method\": \"GET\",\n    \"url\": \"/v1/biggboss/shows\"\n  },\n  \"response\": {\n    \"status\": 200,\n    \"headers\": {\n      \"Content-Type\": \"application/json\"\n    },\n    \"bodyFileName\": \"biggboss-shows-api/only_reviewers.json\"\n  }\n}\n```\n\nonly_reviewers.json\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```json\n{\n  \"reviewers\": [\n    {\n      \"channel_name\": \"SBI Electroal Bond - 1 (Google Drive)\",\n      \"description\": \"Google 드라이브에서 더 나은 분석을 위해 엑셀 형식의 선거 채권 파트 1 다운로드\",\n      \"url\": \"https://docs.google.com/spreadsheets/d/17DJrN1orB93OTIYF6QMiFj1aZ9F2WZrA_D8zfjH56FE\",\n      \"image\": \"https://i.ytimg.com/vi/z_OY38rDj9k/hq720.jpg\"\n    },\n    {\n      \"channel_name\": \"SBI Electroal Bond - 2 (Google Drive)\",\n      \"description\": \"Google 드라이브에서 더 나은 분석을 위해 엑셀 형식의 선거 채권 파트 2 다운로드\",\n      \"url\": \"https://docs.google.com/spreadsheets/d/1GQBoGkyqNd3HOWDaJc2ueOmDQpmYob74\",\n      \"image\": \"https://i.ytimg.com/vi/z_OY38rDj9k/hq720.jpg\"\n    },\n    {\n      \"channel_name\": \"Bigg Boss Tamizh Review\",\n      \"description\": \"BiggBoss 리뷰, 비평가, 트롤 및 심층 분석\",\n      \"url\": \"https://www.youtube.com/@tamizhreview/videos\",\n      \"image\": \"https://raw.githubusercontent.com/piappstudio/resources/main/biggboss/images/shows/tamil/session7/channels/tamizhreview.png\"\n    },\n    {\n      \"channel_name\": \"Pi App Studio\",\n      \"description\": \"타밀어로 무료 iOS 및 안드로이드 개발 코스\",\n      \"url\": \"https://www.youtube.com/@piappstudio/videos\",\n      \"image\": \"https://raw.githubusercontent.com/piappstudio/resources/main/biggboss/images/shows/tamil/session7/channels/piappstudio.png\"\n    }\n  ]\n}\n```\n\n## 실행 단계\n\n- 목 서버 시작\n- /scenario/shows/reviewers를 호출하여 “shows-reviewers-only” 시나리오를 트리거\n- 리뷰어만 내보내는 JSON 응답을 받기 위해 클라이언트 API /v1/biggboss/shows 호출\n\n동일한 방식으로 “N”개의 시나리오와 해당 클라이언트 스텁을 구성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 모든 API에 대한 전역 오류 처리\n\n500, 503 및 404와 같은 전역 오류는 다른 endpoint에 대한 시나리오와 유사한 방식으로 WireMock 시나리오를 사용하여 처리할 수 있습니다. 이러한 오류를 구성하는 방법은 다음과 같습니다:\n\n- 오류 시나리오 생성:\n\n- 500 내부 서버 오류: server-down-error-started\n- 503 서비스를 사용할 수 없음: server-maintenance-error-started\n- 404 찾을 수 없음: server-api-not-found-error-started\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 전역 오류에 대한 클라이언트 스텁을 구성하는 데 몇 가지 특별한 고려 사항이 있습니다:\n\n- 우선 순위: \"priority\"를 1로 설정하세요. 기본적으로 스텁 우선 순위는 5이지만, 1로 설정하면 요청이 발생할 때 이 스텁이 가장 높은 우선 순위를 갖게 됩니다. WireMock는 모든 요청을 가로채고 requiredScenarioState를 확인한 후 시스템 상태가 일치하는 경우 적절한 오류 응답을 반환합니다.\n- urlPathPattern: \"/(.\\*)\"을 사용하세요. 이 와일드카드 정규식은 모든 엔드포인트와 일치하여 오류 응답이 전역적으로 적용되도록 합니다.\n\n```js\n{\n  \"priority\": 1,\n  \"scenarioName\": \"general-server-error\",\n  \"requiredScenarioState\": \"server-down-error-started\",\n  \"request\": {\n    \"urlPathPattern\" : \"/(.*)\"\n  },\n  \"response\": {\n    \"status\": 500,\n    \"body\": \"Server is Down\"\n  }\n}\n```\n\n## 실행 단계\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 목 서버를 시작하세요.\n- /scenario/trigger-server-down-error를 호출하여 \"500 에러\" 시나리오를 시작하세요.\n- /v1/biggboss/shows 클라이언트 API를 호출하여 500 에러 응답을 받으세요. 실제로 시스템은 모든 API 호출에 대해 이 500 에러를 반환합니다.\n- 모든 시나리오를 재설정하려면 \\_\\_admin/scenarios/reset을 호출하세요.\n\n# 결론\n\nWireMock를 사용하여 UI 개발을 하는 것은 게임 체인저입니다. 서버 가용성과 독립적으로 작업할 수 있어 개발 프로세스가 효율적이고 중단되지 않음을 보장합니다. 다양한 시나리오를 설정하고 엔드포인트를 확인함으로써 더 신뢰할 수 있고 견고한 응용프로그램을 구축할 수 있습니다.\n\nGitHub 저장소에서 자세한 내용과 템플릿을 확인하고 시작하는 데 도움이 되는 구독 부탁드립니다. 즐거운 코딩하세요!\n","ogImage":{"url":"/assets/img/2024-06-19-IDontNeedaServerforUIDevelopmentYesYouHeardItRight_0.png"},"coverImage":"/assets/img/2024-06-19-IDontNeedaServerforUIDevelopmentYesYouHeardItRight_0.png","tag":["Tech"],"readingTime":14},{"title":"안드로이드에서 WebP 이미지 형식","description":"","date":"2024-06-19 11:11","slug":"2024-06-19-WebPImageFormatonAndroid","content":"\n드로어블은 앱 크기를 늘리는 주요 요인 중 하나입니다. 이제 웹피 이미지 형식으로 이동하여 이미지를 최적화하는 방법에 대해 알아볼 거에요.\n\n이 게시물에서는 웹피 형식이 무엇인지, 안드로이드에서 사용해야 하는 이유, 이미지를 변환하는 방법, 유의해야 할 점, 잘 알려진 기업들이 앱 크기를 줄이기 위해 어떻게 활용하는지, 그리고 성능에 미치는 영향을 다룰 것입니다.\n\n## 안드로이드의 이미지 형식 개요\n\n과거에 안드로이드 앱은 아이콘, 이미지 자산 및 기타 드로어블에 JPEG 및 PNG 형식을 사용했습니다. 같은 자산에 대해 서로 다른 해상도의 파일을 생성하여 drawable-xxxhdpi, drawable-xxhdpi 등과 같은 적절한 밀도 폴더에 배치하는 것이 표준적인 방법이었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나중에 Android 5.0(API 수준 21)은 VectorDrawable을 지원하게 되었어요. VectorDrawable은 XML 파일에 정의된 벡터 그래픽이에요. 품질 손실 없이 확대/축소할 수 있어서 같은 파일이 다른 화면 밀도에 대해 손실 없이 크기가 조정돼요. 이는 다른 해상도의 파일을 제공할 필요가 없어서 더 작은 앱 크기를 만들어냅니다.\n\nCompose를 통해 Android는 ImageVector를 사용하여 아이콘을 정의하는 또 다른 방법을 가져왔어요. Compose는 개발자가 활용할 수 있는 미리 정의된 Material 아이콘 세트를 제공하며 프로젝트에 추가 자산을 추가로 제공할 필요가 없습니다.\n\n그러나 VectorDrawable과 ImageVector은 일반적으로 점, 선 및 곡선만 사용하여 달성할 수 있는 한계가 있기 때문에 주로 아이콘이나 간단한 삽화에 사용됩니다.\n\n더 복잡한 그림을 위해 주로 PNG 또는 JPG 형식을 계속 사용하며, 사진이나 배경 이미지와 같이 잘 작동하지만 더 큰 앱 크기를 가져올 수 있어요. 이때 WebP가 등장하는 거죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![WebP](/assets/img/2024-06-19-WebPImageFormatonAndroid_0.png)\n\n## 웹피(WebP)란?\n\n웹피(WebP)는 Google에서 개발한 이미지 형식으로, JPEG와 PNG보다 더 나은 압축을 제공합니다. 이 형식은 유실 압축과 비유실 압축을 모두 지원하며 투명도도 지원합니다.\n\nGoogle에 따르면, WebP의 사용은 비손실 압축의 경우 PNG보다 평균 26% 더 작은 파일 크기를 가지게 되고, 유실 압축의 경우 25-34% 정도 더 작아진다고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n공식 페이지나 위키피디아에서 WebP의 작동 방식에 대해 더 많이 읽을 수 있어요.\n\n## 안드로이드에서의 WebP\n\n손실 압축 WebP 이미지는 Android 4.0(API 레벨 14) 이상에서, 그리고 무손실 및 투명한 WebP 이미지는 Android 4.3 (API 레벨 18) 이상에서 지원됩니다.\n\n기존의 BMP, JPG, PNG 또는 정적 GIF 이미지를 Android Studio를 사용하여 WebP 형식으로 변환할 수 있어요. Android Studio를 사용하여 무손실이나 투명한 WebP 이미지를 작성하려면 프로젝트가 minSdkVersion을 18 이상으로 선언해야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 왜 사용해야 하나요?\n\n앱의 다운로드 크기는 특히 개발도상국에서 성공을 거두는 데 중요한 지표입니다. 사용자가 다운로드해야 하는 메가바이트 수가 적은 앱을 소유하고 있는 것은 동료들과 비교했을 때 이점이 될 수 있습니다.\n\n드로어블은 대기업들이 앱 크기 최적화를 수행함에 따라 크기가 늘어나는 주요 원인 중 하나로 확인되었습니다 (Square, Grab). 그들이 .png 및 .jpg 형식에서 변경함으로써 앱 크기를 상당한 비율로 줄일 수 있었다는 교훈을 얻었습니다.\n\n이로써 WebP는 Android에서 사용하기 좋은 이미지 형식입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이미지를 WebP로 변환하는 방법\n\nAndroid Studio에는 JPG, PNG, BMP 또는 정적 GIF 이미지를 WebP 이미지로 변환하는 내장 변환 도구가 있습니다.\n\n- 기존 이미지를 변환하려면 파일을 마우스 오른쪽 버튼으로 클릭하고 \"Convert to WebP\" 옵션을 선택하십시오. 여러 파일을 변환하려면 모두 선택한 다음 그 중 하나에 마우스 오른쪽 버튼을 클릭하십시오.\n\n![이미지](/assets/img/2024-06-19-WebPImageFormatonAndroid_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 새 대화 상자가 열립니다. 여기에서 인코딩 유형과 품질을 설정할 수 있습니다. 손실 압축을 선택하면 인코딩 품질을 설정할 수 있습니다. 품질이 자동으로 100%로 설정되는 손실 없는 인코딩에는 이 설정이 사용할 수 없습니다. \"미리보기/검토\" 확인란이 선택되어 있는지 확인하여 원본 이미지와 변환된 이미지를 비교할 수 있습니다. 미리보기로 진행하려면 확인 버튼을 누르세요.\n\n![WebPImageFormatonAndroid_2.png](/assets/img/2024-06-19-WebPImageFormatonAndroid_2.png)\n\n3. 다음 단계에서는 변환을 확인하기 전에 이미지 품질의 차이를 확인할 수 있습니다. 왼쪽에는 원본 이미지 (PNG, JPG, ...)가 표시되고, 오른쪽에는 변환된 WebP 이미지가 있으며, 중앙에는 품질 손실이나 차이가 표시됩니다. 아래에서 품질 설정을 변경하여 수용할 수 있는 값으로 변경할 수 있습니다. 또한 원본 대 변환된 파일 크기도 표시되므로 얼마나 많은 공간을 절약할 수 있는지 알 수 있습니다.\n\n여러 파일을 변환할 때 각 이미지에 대해 이 비교 대화 상자가 제공됩니다. 각 이미지에 대한 설정을 조정하거나 모든 이미지에 대해 일괄 적용 및 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지를 변환하려면 Finish를 눌러주세요.\n\n4. 이미지를 변환한 후 공간을 얼마나 절약했는지에 대한 정보 메시지가 표시됩니다.\n\n![WebPImageFormatonAndroid_3.png](/assets/img/2024-06-19-WebPImageFormatonAndroid_3.png)\n\n5. 이제 끝났어요! 코드를 수정할 필요가 없습니다. 표준 방식 (R.drawable.image_name)으로 드로어블을 참조하고 있다면요. 파일 이름으로 직접 참조하고 있다면 .png 또는 .jpg 확장자를 .webp로 변경해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 주의 사항\n\n1. PNG: PNG 이미지/아이콘을 변환할 때 대부분의 경우 손실 없는 (100% 품질) 설정을 사용할 수 있습니다. 품질에 손상이 없으며 변환된 파일이 상당히 작아집니다.\n\n   이 샘플 PNG 이미지의 경우, 변환된 파일 크기는 품질 손실 없이 65% 작아집니다 (22.0 KB 대 63.0 KB).\n\n![PNG 이미지](/assets/img/2024-06-19-WebPImageFormatonAndroid_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 사용 사례: 선택하는 품질은 사용 사례에 따라 다릅니다. 화면 배경으로 이미지를 사용하는 경우에는 알아챌 수 없기 때문에 낮은 품질 설정이 허용됩니다. 화면에 두드러지게 표시되는 이미지에는 높은 품질 설정을 사용하세요.\n\n3. JPG: JPG 이미지를 변환할 때 이미지 품질과 변환된 파일 크기 사이의 균형을 찾아야 합니다. 더 높은 이미지 품질(80% 이상)을 사용하면 때로는 원본보다 더 큰 파일이 생성될 수 있습니다.\n\n예시: 아래 변환된 샘플 이미지의 크기는 736.5 KB이며 원본은 922.5 KB인데 품질을 75%로 설정했을 때입니다. 이는 21%의 절감을 의미합니다. 60% 품질로 사용하면 파일 크기는 627.5 KB(32% 절감)가 됩니다. 그러나 85% 설정을 사용하면 1.0MB의 파일 크기를 가지게 되며 원본보다 14% 증가합니다. 품질이 중요하다면 이 특정 이미지를 변환하는 데는 가치가 없습니다.\n\n![2024-06-19-WebPImageFormatonAndroid_5](/assets/img/2024-06-19-WebPImageFormatonAndroid_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nInitial dialog(2단계)에서 \"변환 결과가 원본보다 큰 파일을 건너뛰기\" 설정을 확인하여 변환된 파일이 큰 이미지를 걸러낼 수 있어요. 이 설정은 기본적으로 활성화되어 있어요.\n\n![Image](/assets/img/2024-06-19-WebPImageFormatonAndroid_6.png)\n\nJPG와 WebP 간 이미지 품질 및 파일 크기 차이를 볼 수 있는 샘플 앱이 궁금하시다면, 이 샘플 앱을 확인해보세요.\n\n![Image](/assets/img/2024-06-19-WebPImageFormatonAndroid_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 방향: Whatnot Engineering은 최근 ExifInterface의 버그로 WebP 이미지를 올바른 방향으로 표시하는 문제를 해결하는 데 어려움을 겪었던 내용을 하이퍼디프로 발표했습니다. 그들은 Google에 수정 사항을 제출했고, 최신 AndroidX 릴리스에서 이 문제가 해결되었을 것으로 예상됩니다.\n\n5. 취약점: 2023년 9월에 libwebp 라이브러리에서 두 가지 취약점이 발견되었습니다. 공격자는 특정 .webp 무손실 파일을 작성하여 응용 프로그램에서 경계를 벗어나거나 오버플로 조건을 발생시킬 수 있습니다. 대부분의 모바일 앱에서는 정적 WebP 이미지를 사용하고 있기 때문에 이는 큰 문제가 되지 않을 것입니다. 그러나 서버에서 WebP 이미지를 제공하고 기기에서 WebP 이미지를 업로드하는 경우, 서버에서 추가적인 유효성 검사와 보안 검사를 고려해야 합니다.\n\n## WebP 형식을 사용하여 앱 크기를 최적화하는 회사들\n\n여러 기업이 앱 크기를 줄이기 위해 노력한 경험을 공유했습니다. 대부분의 경우에서 주요 요소는 적절한 형식을 사용하여 이미지를 압축하는 것입니다. 여기에는 이미지 자산을 WebP로 변환하여 앱 크기를 최적화한 회사들의 몇 가지 예시가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Square: [https://developer.squareup.com/blog/keeping-up-with-android-app-size-growth/](https://developer.squareup.com/blog/keeping-up-with-android-app-size-growth/)\n- Grab: [https://engineering.grab.com/project-bonsai](https://engineering.grab.com/project-bonsai)\n- Yelp: [https://engineeringblog.yelp.com/2016/05/yelp-android-app-went-on-a-diet.html](https://engineeringblog.yelp.com/2016/05/yelp-android-app-went-on-a-diet.html)\n\n## 원격 WebP 이미지는 어떻게 되나요?\n\nAndroid는 WebP 형식의 인코딩 및 디코딩을 공식적으로 지원하므로 모든 이미지 라이브러리가 URL에서 WebP 이미지를 표시할 수 있어야 합니다. 이는 Coil, Glide 등을 포함합니다.\n\nCoil 및 Glide를 사용하여 Compose에서 WebP 이미지를로드하는 방법을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 성능은 어떠한가요?\n\n이미지를 100번 불러오고 불러오는 시간을 추적하는 간단한 벤치마크를 작성했습니다. Coil을 사용하여 drawable 폴더에서 이미지를 완전한 해상도로 불러옵니다. 결과는 샘플 앱의 릴리스 빌드에서 순차적으로 세 번 실행한 결과입니다.\n\n벤치마크에 사용된 JPG 이미지는 원본 100% 품질 이미지이고, WebP 이미지는 80% 품질로 변환된 이미지입니다.\n\n```js\nSamsung S10 (Android 12):\n| 로드 시간 (ms)   | JPG | WebP | 차이 (%)         |\n|------------------|-----|------|------------------|\n| 평균             | 143 | 161  | +12%             |\n| 최소 (Android 14) | 100 | 126  | +26%             |\n| 최대             | 164 | 180  | +10%             |\n\n\nSamsung S21 Ultra (Android 14):\n| 로드 시간 (ms)   | JPG | WebP | 차이 (%)         |\n|------------------|-----|------|------------------|\n| 평균             | 75  | 91   | +21%             |\n| 최소 (Android 14) | 67  | 82   | +22%             |\n| 최대             | 96  | 113  | +18%             |\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹페이지 이미지를 불러오는 데 웹피 파일이 JPG 파일보다 12–21% 더 오래 걸린다는 것을 확인할 수 있었습니다. 차이는 밀리초 단위로 측정되며 사용자들이 눈으로 구별하기에는 미미합니다. 물론 변환 이미지에 선택한 이미지 품질에 따라 차이가 발생합니다. 저품질을 사용하면 더 빨리 불러와지고 파일 크기도 작아집니다.\n\n메모리 소비는 두 경우 모두 비슷합니다.\n\n결과를 토대로 성능 차이가 매우 작아서 대부분의 앱에서 웹피 형식으로 마이그레이션하는 데 영향을 미치지 않을 것으로 판단됩니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nWebP은 JPEG와 JPG보다 압축률이 더 높은 현대 이미지 파일 형식입니다. 따라서 다운로드 크기가 성공에 중요한 지표인 안드로이드 앱에 사용하기에 이상적인 후보입니다, 특히 개발도상국에서는 더욱 그렇습니다.\n\nAndroid 시스템에서 API 레벨 18부터 완전히 지원되며, Android Studio에는 내장된 쉬운 변환 툴이 제공됩니다.\n\n이 형식은 파일 크기를 줄이는 좋은 방법을 제공하지만, 변환된 이미지는 압축 설정에 따라 품질이 약간 낮아질 수 있고 로드 시간이 조금 더 오래 걸릴 수 있다는 단점이 있습니다. 따라서 사용 사례에 맞게 다양한 품질 설정을 테스트하는 것이 중요합니다.\n\n이 내용이 유용하게 느껴졌으면 좋겠고, 이미지 자산을 WebP로 변환하여 앱 크기를 최적화하시기를 고려해 주셨으면 합니다. 이미 앱에서 WebP를 사용 중이라면 의견을 자유롭게 공유해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고 자료:\n\n- [이미지를 WebP로 변환하는 방법](https://developer.android.com/studio/write/convert-webp)\n- [APK 크기를 줄이는 공식 권장사항: WebP 형식 사용하기](https://developer.android.com/topic/performance/reduce-apk-size#use-webp)\n- [이미지 다운로드 크기를 줄이는 방법에 대한 공식 제안](https://developer.android.com/develop/ui/views/graphics/reduce-image-sizes)\n","ogImage":{"url":"/assets/img/2024-06-19-WebPImageFormatonAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-WebPImageFormatonAndroid_0.png","tag":["Tech"],"readingTime":12},{"title":"Nodejs를 활용하기 현대 비즈니스 성장의 핵심","description":"","date":"2024-06-19 11:09","slug":"2024-06-19-HarnessingNodejsKeytoModernBusinessGrowth","content":"\n# 소개: Node.js 이해하기\n\n- Node.js와 비즈니스 혁신: Node.js는 논블로킹, 이벤트 주도 아키텍처로 유명하며 분산된 장치 간 실시간 데이터 집약적 애플리케이션에 이상적입니다. 백엔드 개발에서의 사용은 고객 경험과 운영 효율을 향상시킵니다.\n- 왜 중요한가: 기술적 발전에 발맞추려는 비즈니스에게는 Node.js 개발 서비스를 통합하는 것이 중요합니다. 빠른 시장 진입을 가능하게 하고 애플리케이션 성능을 향상시키며 확장 가능한 솔루션을 지원합니다.\n\n# 섹션 1: Node.js의 확장성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 성장을 위해 설계된: Node.js는 수평 및 수직 확장을 손쉽게 지원하여 성장을 예상하는 비즈니스에게 강력한 도구가 됩니다. 이 유연성은 성능을 희생하지 않고 증가된 부하를 처리할 수 있도록 회사에게 가능하게 합니다.\n- 현실 세계 응용: PayPal과 LinkedIn 같은 기업들은 Node.js를 활용하여 서버 응답 시간을 개선하고 수백만 개의 동시 연결을 처리하는 능력을 증명했습니다. 이는 효과적으로 확장할 수 있는 능력을 보여줍니다.\n\n# Section 2: Node.js로 비용 효율성 달성\n\n- 개발 비용 절감: Node.js는 개발자가 클라이언트 및 서버 측 코드를 모두 작성할 수 있는 JavaScript를 사용합니다. 이 일관성은 다중 언어 및 팀을 관리하는 복잡성과 비용을 줄입니다.\n- 효율적인 운영: Node.js의 가벼운 프레임워크와 단일 스레드에서 여러 요청을 처리할 수 있는 능력은 많은 하드웨어 리소스를 필요로 하지 않아 운영 비용을 낮출 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HarnessingNodejsKeytoModernBusinessGrowth_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 섹션 3: 웹 개발을 위한 Node.js 프레임워크\n\n- 견고한 생태계: Node.js는 Express.js, Koa.js, Sails.js와 같은 다양한 프레임워크를 제공하여 웹 개발 작업을 빠르고 간단하게 처리할 수 있습니다.\n\n- 적절한 프레임워크 선택: 각 프레임워크는 서로 다른 개발 요구에 맞게 설계된 고유한 기능을 갖고 있습니다. 예를 들어, Express.js는 간결한 구조와 높은 성능으로 알려져 있어 웹 및 모바일 애플리케이션을 구축하는 데 적합합니다.\n\n# 섹션 4: Node.js로 가속화된 개발\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 실행 속도: Node.js는 JavaScript 코드를 네이티브 기계 코드로 직접 컴파일하여 실행을 가속화하고 응용 프로그램을 더 빠르고 효율적으로 만듭니다.\n- 빠른 개발 주기: Node.js의 논블로킹 특성을 통해 지연 없이 요청을 처리하여 더 빠른 개발 주기와 빠른 업데이트를 이끌어냅니다.\n\n# 섹션 5: 비교: Node.js vs. Golang\n\n- 성능 측면: Node.js는 동시 요청 처리에 뛰어나지만, Golang은 대량 데이터 처리에 있어 속도와 효율성으로 인해 자주 칭찬을 받습니다.\n- 적절한 사용 사례: 프로젝트 요구 사항에 따라, 실시간 웹 애플리케이션에는 Node.js가 선호되고, 그에 반해 Golang은 시스템 수준 프로그래밍에 더 적합할 수 있습니다.\n\n더 많은 정보 — Node.js vs. Golang, 어느 쪽이 더 좋을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 섹션 6: Node.js와 React.js의 시너지\n\n- 풀 스택 개발: Node.js를 React.js와 결합하면 서버 측과 클라이언트 측을 효율적으로 처리해 개발 프로세스를 간소화할 수 있습니다.\n\n- 매끄러운 통합: 백엔드에는 Node.js를, 프론트엔드에는 React.js를 사용하여 대화형 사용자 인터페이스를 개발하는 강력한 조합을 만들어낼 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HarnessingNodejsKeytoModernBusinessGrowth_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 섹션 7: 전문 인력 채용: Node.js 개발자\n\n- 인재 발굴: Node.js의 전체 잠재력을 발휘하기 위해서는 숙련된 Node.js 개발자를 고용하는 것이 중요합니다. 전문 개발자는 비즈니스 목표와 일치하는 맞춤 솔루션을 만들어낼 수 있습니다.\n- 찾아야 할 주요 특성: Node.js 프레임워크 경험, 비동기 프로그래밍 이해, 그리고 프론트엔드 기술에 대한 친숙함은 Node.js 개발자에게 필수적인 기술입니다.\n\n# 섹션 8: 왜 JavaScript 개발 회사를 선택해야 할까요?\n\n- 포괄적인 솔루션: 전문 JavaScript 개발 회사는 Node.js 및 다른 JavaScript 프레임워크에 대한 전문 지식을 갖추어 웹 및 애플리케이션 개발에 전체적인 접근을 보장합니다.\n- 지속적인 지원: 개발 이상으로 이러한 회사들은 애플리케이션이 장기적으로 효율적이고 안전하게 유지되도록 지속적인 유지보수, 업데이트 및 지원을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론: 최고의 Node.js 개발 회사와 파트너십을 맺어보세요\n\n- 전략적 이점: 이미 입증된 Node.js 개발 회사와 협업하면 최신 기술과 업계 모범 사례에 접근할 수 있습니다.\n- 장기적 이점: 신뢰할 수 있는 회사와의 파트너십은 즉각적인 기술적 솔루션뿐만 아니라 비즈니스 전략적 이점을 제공하여 성장과 혁신을 유지하는 데 도움이 됩니다.\n\n![Node.js 이미지](/assets/img/2024-06-19-HarnessingNodejsKeytoModernBusinessGrowth_3.png)\n\n현대 비즈니스 환경에서 Node.js를 이해하고 활용하는 구조화되고 자세한 방법은 비즈니스 효율성, 확장성 및 성장을 촉진하는 핵심 역할을 강조합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-HarnessingNodejsKeytoModernBusinessGrowth_0.png"},"coverImage":"/assets/img/2024-06-19-HarnessingNodejsKeytoModernBusinessGrowth_0.png","tag":["Tech"],"readingTime":5},{"title":"Swift에서의 오류 처리","description":"","date":"2024-06-19 11:08","slug":"2024-06-19-ErrorhandlinginSwift","content":"\n## 사용자에게 경고하기 위해 do-catch 문과 사용자 정의 오류를 던지는 방법 (코드 예제와 함께)\n\n에러 처리는 모든 앱의 기본적인 부분입니다.\n\n사용자가 수행하는 모든 조치가 성공하는 것은 아닙니다. 일부는 실패할 것이며, 우리의 앱은 사용자에게 일어난 일을 쉽게 알려주고 문제를 피하기 위해 무엇을 시도할 수 있는지 알려줘야 합니다.\n\n간단한 throw 및 do-catch 문을 사용하여 간단한 에러 처리를 어떻게 달성할 수 있는지 보여드릴게요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-에러핸들링인Swif_0.png\" />\n\n## 에러 정의 및 던지기\n\n에러를 표현하려면 Error 프로토콜을 준수하는 타입을 사용해야 합니다. 이는 아무런 제약이 없는 빈 프로토콜이며, 우리가 가장 잘 적합한 타입으로 에러를 정의할 수 있다는 것을 의미합니다.\n\n일반적으로 enum이 시작하기에 가장 좋은 방법입니다. 네트워크 에러를 처리하고 싶다고 가정해보면, 아래 enum을 정의할 수 있습니다👇\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n열거형 NetworkError: 오류 {\n    case unexpected\n    case invalidURL(_ url: URL)\n    case apiError(statusCode: Int)\n}\n```\n\n백엔드 API로 요청을 수행할 때 오류가 발생하면 NetworkError를 던질 수 있습니다.\n\n```js\n열거형 ApiMethod {...}\n구조체 ApiRequest {...}\n\nfunc createRequest(from url: String, method: ApiMethod) throws -> ApiRequest {\n  guard let URL = URL(string: url) else {\n    throw NetworkError.invalidURL(url)\n  }\n  ...\n}\n```\n\n## 오류 처리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 사용자 정의 오류를 갖고 있고, 이를 throw하고 있습니다. 하지만, 이를 어떻게 잡을 수 있을까요?\n\n다른 많은 언어와 마찬가지로, Swift에는 do-catch 문이 있습니다. 만약 do 절 내에서 오류가 throw되면, 실행은 catch 절로 전달되고 오류는 로컬 상수 error에 저장됩니다.\n\n```js\ndo {\n  let result = try createRequest(from: \"//myapi.com/\", method: .GET)\n} catch {\n  print(error)\n  // 적절한 처리를 수행\n}\n```\n\n가끔씩 우리는 잡은 오류 형식(또는 오류 값)에 따라 특정 작업을 트리거하길 원합니다. 이를 패턴을 사용하여 수행할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndo {\n  let result = try makeRequest(to: \"//myapi.com/\", method: .GET)\n} catch NetworkError.invalidUrl(let url) {\n  // ...\n} catch {\n  print(error)\n  //\n}\n```\n\n## 에러 전파하기\n\n던져진 함수는 함수 내에서 발생한 에러를 호출자의 범위로 전파할 수 있습니다.\n\n```js\nstruct User: Decodable {\n    let name: String\n    let age: Int\n}\n\nfunc decodeJSON<T: Decodable>(_ jsonString: String) throws -> T {\n    let jsonData = Data(jsonString.utf8)\n    let decodedObject = try JSONDecoder().decode(T.self, from: jsonData)\n    return decodedObject\n}\n\nfunc getUserFromJSON(_ jsonString: String) -> User? {\n    do {\n        let user: User = try decodeJSON(jsonString)\n        return user\n    } catch {\n        print(error)\n        return nil\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## try? & try!\n\n가끔은 던지는 함수로 발생한 오류에 대해 신경 쓰지 않을 수 있습니다. 이런 상황에서는 do-catch 문을 사용하지 않고 try? 지시어를 사용할 수 있습니다.\n\ntry?를 사용하면 호출하는 함수가 옵셔널이 됩니다. 즉, 반환 값을 가진 함수를 호출하는 경우 값은 nil이 됩니다.\n\n```js\nlet request = try? createRequest(from: \"malformedurl\", method: .GET)\n// request = nil\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한편, 때때로 특정한 던지기 함수가 런타임에서 실패하지 않을 것을 확신할 수 있습니다. 이런 경우에는 try!를 사용할 수 있습니다. 그리고 try?와 마찬가지로 do-catch 클로저를 사용할 필요가 없습니다.\n\n```js\nlet request = try! createRequest(from: \"https://myapi.com/\", method: .GET)\n```\n\n## 비동기 코드\n\n에러를 던지는 것은 비동기 코드와 잘 작동합니다. 함수 선언에서 throws 키워드 앞에 async 키워드를 넣어주어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비동기 함수를 호출할 때는 try await (키워드 순서 스와이프)를 사용합니다.\n\n```js\nfunc performRequest(with request: ApiRequest) async throws -> ApiResult {...}\n\n// ----------------\n\ndo {\n  let request = try makeRequest(to: \"https://myapi.com/users\", method: .GET)\n  let apiRestul = try await performRequest(with: request)\n} catch NetworkError.invalidUrl(let url) {\n  // ...\n} catch {\n  print(error)\n  //\n}\n```\n\n# 사용자에게 알림\n\n에러 구조를 구축했으니, 이제 사용자들에게 무엇이 잘못되었는지 알려줄 필요가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:592/1*cfrDQghry5EPpPhMSFFDaA.gif\" />\n\n각각의 오류에 대한 설명 은 오류가 처음에 발생한 이유입니다.\n사용자가 사용자를 피할 수 있는 가능한 조치입니다.\n\n우리는 Error enum에 해당 정보를 변수로 추가할 수 있습니다. 그러나 이미 모든 이 정보를 그룹화하기 위한 프로토콜이 있습니다: LocalizedError. 우리의 사용 사례에서 우리는 failureReason 및 recoverySuggestion 변수 만 구현하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nenum OrderError: LocalizedError {\n  case unexpected\n  case outOfCoffee(coffee: Coffee)\n  case minimumNotMet(currentPrice: Float)\n\n  var failureReason: String? {\n    switch self {\n    case .unexpected:\n      return \"주문 처리 중 문제가 발생했습니다.\"\n    case .outOfCoffee(let coffee):\n      return \"\\(coffee.name)가 다 떨어졌어요.\"\n    case .minimumNotMet:\n      return \"앱에서 주문하려면 최소 $10 이상 사용해야 합니다.\"\n    }\n  }\n\n  var recoverySuggestion: String? {\n    switch self {\n    case .unexpected:\n      return \"몇 분 후에 다시 시도해주세요.\"\n    case .outOfCoffee:\n      return \"다른 종류의 커피로 변경해보세요.\"\n    case .minimumNotMet(let currentPrice):\n      return \"주문에 $\\(10-currentPrice) 더 추가해주세요.\"\n    }\n  }\n}\n```\n\n여기에서 작업이 완료됩니다. 그러나 앱에 통합된 로깅 솔루션이 있다면, 오류 구조를 확장하여 추가 정보를 추가할 수 있습니다.\n\n```swift\nimport Foundation\nimport HKLogger\n\nstruct AppError: Error {\n  let type: LocalizedError\n  var userMessage: String {\n    return \"\\(type.failureReason ?? ErrorConstants.defaultError) \\n\\n \\(type.recoverySuggestion ?? ErrorConstants.defaultAction)\"\n  }\n  // 필요한 만큼 많은 속성을 추가\n\n  init(type: LocalizedError, debugInfo: String? = nil) {\n      self.type = type\n      guard let debugInfo else { return }\n      HKLogger.shared.error(message: debugInfo)\n  }\n}\n```\n\n이렇게 함으로써 로깅 오류 로직을 한 곳에 중앙 집중화할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내 사용자 정의 AppError를 사용하여 경고를 표시하는 간단한 View 확장을 만들 수 있습니다.\n\n```js\nextension View {\n    func alert(isPresented: Binding<Bool>, withError error: AppError?) -> some View {\n        return alert(\n            \"Ups! :(\",\n            isPresented: isPresented,\n            actions: {\n                Button(\"Ok\") {}\n            }, message: {\n                Text(error?.userMessage ?? \"\")\n            }\n        )\n    }\n}\n\n// ---------------------------------------------------\n\nstruct OrderConfirmationView: View {\n  @StateObject private var viewModel = ConfirmationViewModel()\n\n  var body: some View {\n    VStack(alignment: .leading) {\n      // ...\n      Button(\"주문하기\") {\n        viewModel.tryToPlaceOrder(order)\n      }\n    }\n    .alert(isPresented: $viewModel.showError, withError: viewModel.appError)\n  }\n}\n\n// ---------------------------------------------------\n\n@Observable\nfinal class ConfirmationViewModel: ObservableObject {\n    var appError: AppError?\n    var showError = false\n\n    func tryToPlaceOrder(_ order: Order) {\n        do {\n            try OrdersManager.shared.add(order)\n        } catch let error as AppError {\n            showError = true\n            appError = error\n        } catch {\n            appError = AppError(type: OrderError.unexpected)\n        }\n    }\n}\n\n// ---------------------------------------------------\n\nfinal class OrdersManager {\n  // ...\n  func add(_ order: Order) throws {\n    if order.price >= 10 {\n      orders.append(order)\n    } else {\n      throw AppError(type: OrderError.minimumNotMet(currentPrice: order.price))\n    }\n  }\n}\n```\n\n질문이 있으신가요? 언제든지 메시지를 남겨주세요! 🙂\n\n- 🤓 iOS 개발 팁과 통찰력에 관한 콘텐츠를 X에서 함께 확인해보세요.\n- 🚀 모든 예제 프로젝트를 공유하는 내 GitHub를 확인해보세요 (이것도 포함됩니다 😉)\n","ogImage":{"url":"/assets/img/2024-06-19-ErrorhandlinginSwift_0.png"},"coverImage":"/assets/img/2024-06-19-ErrorhandlinginSwift_0.png","tag":["Tech"],"readingTime":10},{"title":"iOS에서 Chain of Responsibility 디자인 패턴","description":"","date":"2024-06-19 11:07","slug":"2024-06-19-ChainofResponsibilityDesignPatterniniOS","content":"\n![Chain of Responsibility](/assets/img/2024-06-19-ChainofResponsibilityDesignPatterniniOS_0.png)\n\nChain of Responsibility(줄여서 CoR)는 행위 디자인 패턴으로, 클래스의 책임을 다른 시스템 부분에 위임하여 주어진 입력에 대해 더 나은 대응이 될 수 있는 곳으로 작업을 위임하는 디자인 패턴입니다.\n\n예를 들어, 고객 서비스에 전화를 걸 때, 그들은 결국 고객이 제시한 상황을 더 잘 도와줄 수 있는 구체적인 영역으로 통화를 이동할 것입니다.\n\n# 구현\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 패턴을 구현하려면 체인 링크 사이에서 공유될 인터페이스를 만들어야 합니다.\n\n```js\nprotocol RequestHandler {\n    var nextHandler: RequestHandler? { get set }\n    func handleRequest(request: HTTPRequest)\n}\n```\n\n이 프로토콜은 모든 가능한 핸들러에서 구현될 것이며, 필요한 경우 미래에 추가할 수 있도록 열려 있습니다. 이를 준수하는 객체는 체인 내의 다음 핸들러를 노출하고 요청을 관리하는 데 호출될 함수를 노출할 것입니다.\n\n```js\nclass Authenticator: RequestHandler {\n    var nextHandler: RequestHandler?\n\n    func handleRequest(request: HTTPRequest) {\n        print(\"요청 인증 중...\")\n        // 인증 로직 ...\n        nextHandler?.handleRequest(request: request)\n    }\n}\n\nclass Logger: RequestHandler {\n    var nextHandler: RequestHandler?\n\n    func handleRequest(request: HTTPRequest) {\n        print(\"요청 로깅 중...\")\n        // 로깅 로직 ...\n        nextHandler?.handleRequest(request: request)\n    }\n}\n\nlet authenticator = Authenticator()\nlet logger = Logger()\n\nauthenticator.nextHandler = logger\nlet request = HTTPRequest(path: \"/api/resource\", method: .get)\nauthenticator.handleRequest(request: request)\n\n// \"요청 인증 중...\"과 \"요청 로깅 중...\"을 출력합니다.\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 예시에서, 요청이 실패하면 해당 문제를 처리하여 처리할 수 있다면 다음 대리자에게 처리를 맡깁니다. 반대로, 요청이 완료되면 실행은 성공적으로 종료되고 반환됩니다.\n\n다른 예시는 로컬로 캐시된 데이터를 관리하거나 원격으로 가져오는 경우입니다.\n\n```js\nprotocol DataRequest { ... }\n\nprotocol DataProvider {\n  var nextProvider: DataProvider? { get set }\n  func fetch(request: DataRequest) async\n}\n\nclass LocalProvider: DataProvider {\n  var nextProvider: DataProvider? = nil\n\n  init(nextProvider: DataProvider? = nil) {\n    nextProvider = nextProvider\n  }\n\n  func fetch(request: DataRequest) async {\n    print(\"로컬에서 가져오는 중\")\n    // 로컬로 가져오면 반환, 아니면...\n    await nextProvider?.fetch(request: request)\n  }\n}\n\nclass RemoteProvider: DataProvider {\n  var nextProvider: DataProvider? = nil\n\n  init(nextProvider: DataProvider? = nil) {\n    nextProvider = nextProvider\n  }\n\n  func fetch(request: DataRequest) async {\n    print(\"원격에서 가져오는 중\")\n    // 원격에서 가져오면 반환, 아니면...\n    await nextProvider?.fetch(request: request)\n  }\n}\n\nlet remoteProvider = RemoteProvider()\nlet databaseProvider = LocalProvider(nextProvider: remoteProvider)\n\nTask {\n  await databaseProvider.fetch(request: ...)\n}\n```\n\n만약 로컬 저장소에서 데이터를 찾을 수 없는 경우, 클라우드에서 가져와야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 장점과 고려사항\n\n이 패턴은 여러 가지 장점을 가지고 있습니다:\n\n- 입력 및 수행할 고유한 작업에만 관심이 있기 때문에 단일 책임 원칙을 따릅니다. 다른 하위 시스템의 책임을 순서대로 위임합니다.\n- 시스템의 일부를 쉽게 추가하거나 제거할 수 있으므로 개방/폐쇄 원칙을 준수합니다. 시스템의 다른 부분과 강하게 결합되지 않으며 동일한 순서에 새로운 가지를 쉽게 만들고 연결하여 무결성을 손상시키지 않고 클라이언트와의 상호 작용에 영향을 주지 않습니다.\n\n고려해야 할 사항이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- \"최적맞춤\" 시스템이 입력을 사용하지 않는다면 일부 요청이 처리되지 않을 수 있습니다.\n\n# 결론\n\n위에서 언급한대로, 이 디자인 패턴을 사용하면 유연성과 확장성을 추가하기 위해 분리될 수 있는 고응집 모듈을 쉽게 분리할 수 있습니다. 이는 사용자 상호작용 이벤트 처리를 위한 GUI 프레임워크나 원격 또는 로컬 데이터 접근을 위한 리포지터리 레이어에서 볼 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-ChainofResponsibilityDesignPatterniniOS_0.png"},"coverImage":"/assets/img/2024-06-19-ChainofResponsibilityDesignPatterniniOS_0.png","tag":["Tech"],"readingTime":5},{"title":"구성 가능한 아키텍처TCA 확장 가능한 iOS 애플리케이션 개발을 위한 견고한 프레임워크","description":"","date":"2024-06-19 11:06","slug":"2024-06-19-TheComposableArchitectureTCAARobustFrameworkforScalableiOSApplicationDevelopment","content":"\n![이미지](/assets/img/2024-06-19-TheComposableArchitectureTCAARobustFrameworkforScalableiOSApplicationDevelopment_0.png)\n\n컴포저블 아키텍처(TCA)는 Point-Free 팀이 디자인한 첨단 소프트웨어 아키텍처 패턴으로, 확장 가능하고 유지보수가 용이하며 테스트 가능한 iOS 애플리케이션을 구축하기 위해 고안되었습니다. Swift 프로그래밍 언어를 활용하는 TCA는 iOS 애플리케이션을 설계하고 구현하는 구조화된 조합 방법론을 제공하여 간결함, 모듈성 및 관심사의 분리에 중점을 둡니다.\n\n# TCA의 주요 개념과 원칙\n\n## 1. 상태(State):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTCA에서 애플리케이션 상태는 애플리케이션의 현재 데이터 및 UI 상태를 나타내며, 변경할 수 없는 구조체로 정의됩니다. 각 상태 요소를 명시적으로 정의하면 이해하고 관리하기 쉽고 더 명확하고 유지보수가 쉬운 코드를 작성할 수 있습니다.\n\n```js\nstruct AppState {\n var count: Int\n var isLoggedIn: Bool\n}\n```\n\n## 2. 액션:\n\nTCA에서 액션은 애플리케이션 상태에 변경을 일으킬 수 있는 이벤트 또는 사용자 의도입니다. 각 액션은 애플리케이션 내에서 특정 이벤트에 해당하는 열거형으로 표시됩니다. 이 구조화된 접근 방식은 상태 업데이트가 예측 가능하고 제어 가능하다는 것을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nenum AppAction {\n case increment\n case decrement\n case login\n case logout\n}\n```\n\n## 3. 리듀서:\n\n리듀서는 TCA에서 현재 상태와 액션을 입력으로 받아 새로운 상태를 반환하는 순수 함수입니다. 비즈니스 로직을 캡슐화하여 주어진 액션에 기반한 일관된 상태 변경을 보장합니다. 이를 통해 응용 프로그램의 동작이 더 예측 가능해집니다.\n\n```js\nvar body: some Reducer {\n  Reducer { state, action, environment in\n    switch action {\n      case .increment:\n        state.count += 1\n        return .none\n      case .decrement:\n        state.count -= 1\n        return .none\n      case .login:\n        state.isLoggedIn = true\n        return .none\n      case .logout:\n        state.isLoggedIn = false\n        return .none\n    }\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. 환경:\n\nTCA의 환경은 서비스, API 또는 데이터 소스와 같은 외부 종속성에 대한 참조를 보유하는 종속성 컨테이너 역할을 합니다. 이를 통해 리듀서와 이펙트가 이러한 종속성과 제어 가능하고 테스트 가능하게 상호 작용할 수 있으며, 코드의 모듈성과 유지 보수성을 향상시킵니다.\n\n```js\n@Dependency(\\.apiClient) var apiClient\n```\n\n## 5. 이펙트:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTCA에서의 Effects는 네트워크 요청이나 데이터베이스 작업과 같은 부작용을 나타냅니다. Reducer에서 반환할 수 있는 값으로 모델링되며, Effects는 비동기적으로 실행되어 상태를 업데이트하는 새로운 액션을 생성할 수 있어 반응적이고 동적인 애플리케이션 흐름을 용이하게 합니다.\n\n```js\ncase .login:\n state.isLoggedIn = true\n return .run { send in\n      await send(.userDataResponse(Result {\n       try await apiClient.fetchUserData()\n       }))\n }\n```\n\n## 6. Stores:\n\nStores는 TCA의 중심 구성 요소로, 애플리케이션 상태를 관리하고 액션을 처리합니다. Store는 현재 상태, 리듀서 및 환경을 포함하며, 액션을 디스패치하고 상태 변경을 관찰할 수 있는 메서드를 제공하여 애플리케이션의 상태 관리를 중앙 집중화합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 7. 조회:\n\nTCA에서 뷰는 상태를 갖지 않고 선언적인 UI 구성 요소로, 애플리케이션의 현재 상태를 렌더링하고 사용자 상호작용에 따라 액션을 디스패치합니다. 이 설계는 UI와 비즈니스 로직 사이의 명확한 분리를 장려하여 코드 가독성과 유지보수성을 향상시킵니다.\n\n```js\nstruct ContentView: View {\n    @Bindable var store: StoreOf<LoginCore>\n\n    init(store: StoreOf<LoginCore>) {\n        self.store = store\n    }\n\n    var body: some View {\n         VStack {\n             Text(\"\\(store.count)\")\n             Button(\"증가\") {\n                store.send(.increment)\n                 }\n             Button(\"감소\") {\n                store.send(.decrement)\n                 }\n             if store.isLoggedIn {\n                 Text(\"환영합니다!\")\n                 }\n            else {\n                 Button(\"로그인\") {\n                    store.send(.login)\n                     }\n            }\n        }\n    }\n}\n```\n\n# 다른 아키텍처 패턴 대비 TCA의 장점\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1. 모듈화와 구성:\n\nTCA는 상태, 액션, 리듀서 및 이펙트와 같은 구성 요소가 자기 포함적이고 재사용 가능한 모듈화 접근 방식을 촉진합니다. 이 모듈화는 복잡한 애플리케이션을 처리 가능한 조각으로 분해하여 코드 구성과 재사용을 개선합니다.\n\n## 2. 예측 가능한 상태 관리:\n\nTCA는 상태 변경을 액션과 리듀서를 통해 처리하여 상태 전이를 결정론적이고 추론하기 쉽도록 합니다. 이 예측 가능성은 디버깅을 간단하게 하고 예상치 못한 동작이 발생할 가능성을 줄입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. 단방향 데이터 흐름:\n\n단방향 데이터 흐름을 준수함으로써 TCA는 관심사의 명확한 분리를 강제하고 제어되지 않은 데이터 변이를 방지합니다. 이 패턴은 데이터 흐름을 추적하고 상태 변경이 애플리케이션을 통해 어떻게 전파되는지 이해하는 데 도움이 됩니다.\n\n## 4. 테스트 용이성:\n\nTCA는 비즈니스 로직을 UI 구성 요소와 외부 종속성으로부터 분리함으로써 테스트 가능성을 향상시킵니다. 리듀서와 효과는 격리된 상태에서 단위 테스트할 수 있어 다양한 시나리오에서 애플리케이션 동작을 확인하는 포괄적인 테스트 스위트를 가능하게 합니다. 의존성 주입과 순수 함수는 쉬운 모킹과 테스트를 지원합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nlet store = TestStore(\n initialState: AppState(count: 0, isLoggedIn: false),\n reducer: appReducer,\n environment: AppEnvironment(apiClient: MockAPIClient(), mainQueue: .main)\n)\nlet store = TestStore(\n              initialState: AppState(count: 0, isLoggedIn: false)\n            ) {\n              LoginCore()\n            } withDependencies: {\n              $0.apiClient = .mock\n            }\nstore.send(.increment) {\n $0.count = 1\n}\n```\n\n## 5. Scalability and Maintainability:\n\nTCA의 구조화된 접근 방식은 확장성과 유지 관리성을 향상시킵니다. 모듈화된 디자인과 관심사 분리로 인해 기능 추가, 코드 리팩터링 및 다른 개발자들과 협업하는 것이 더 쉬워집니다. TCA의 선언적인 특성 또한 코드 가독성을 향상시키며, 개발자들에게 인지 부하를 줄여줍니다.\n\n## 6. Error Handling and Resilience:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTCA는 효율적인 오류 처리 및 부작용 관리 메커니즘을 제공합니다. 이는 효과 취소 및 재시도 전략과 같은 부작용을 다루는 데 도움이 됩니다. 리듀서와 이펙트 내에 오류 처리 로직을 캡슐화함으로써 TCA는 응용 프로그램 전반에서 일관된 오류 관리를 보장하여 복원력과 사용자 경험을 향상시킵니다.\n\n# 다른 아키텍처와 비교\n\nMVC(Model-View-Controller) 또는 MVVM(Model-View-ViewModel)과 같은 전통적인 패턴과 비교하여 TCA는 보다 구조화되고 예측 가능한 접근 방식을 제공합니다.\n\n응용 프로그램이 커짐에 따라 MVC 및 MVVM은 코드가 얽히고 복잡해질 수 있지만, TCA는 모듈화와 단방향 데이터 흐름을 강조하여 관심사의 깔끔한 분리를 유지하는 데 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTCA(TemporaryChange-of-Address)는 VIPER(View-Interactor-Presenter-Entity-Router)에 비해 테스트 가능성과 간단함에서 뛰어납니다. VIPER와 자주 관련된 복잡성과 보일러플레이트를 피할 수 있습니다.\n\n# 잠재적인 단점 대응\n\nTCA는 많은 혜택을 제공하지만 잠재적인 도전이 있음을 인지하는 것이 중요합니다:\n\n- 학습 곡선: TCA는 새로운 개념을 소개하며 함수형 프로그래밍 패러다임을 이해해야 하기 때문에, 보다 전통적인 패턴에 익숙한 개발자에게는 도전이 될 수 있습니다.\n- 초기 설정: 새 프로젝트에 TCA를 설정하는 것은 처음에는 보일러플레이트 코드가 더 많이 필요하지만, 장기적인 유지 관리성과 확장성 측면에서 보상을 받을 수 있습니다.\n- 성능 부담: TCA의 추가 추상화 레이어는 약간의 성능 부담을 줄 수 있지만, 대부분의 애플리케이션에는 무시해도 괜찮을 정도로 미세합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nComposable Architecture는 iOS 애플리케이션을 구축하기 위한 실용적이고 효과적인 프레임워크를 제공하며, 간결함, 확장성 및 유지보수성을 강조합니다. 이 모듈식, 예측 가능하고 테스트 가능한 디자인은 변화하는 요구사항과 함께 발전할 수 있는 견고하고 고품질의 소프트웨어를 개발하는 데 이상적인 선택지입니다.\n\nTCA를 활용함으로써, 개발자들은 잘 구조화되고 견고한 iOS 애플리케이션을 만들어 스위프트 생태계에서 애플리케이션 아키텍처의 새로운 표준을 설정할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-TheComposableArchitectureTCAARobustFrameworkforScalableiOSApplicationDevelopment_0.png"},"coverImage":"/assets/img/2024-06-19-TheComposableArchitectureTCAARobustFrameworkforScalableiOSApplicationDevelopment_0.png","tag":["Tech"],"readingTime":9},{"title":"iOS 앱을 위한 현대적 아키텍처","description":"","date":"2024-06-19 11:02","slug":"2024-06-19-ModernArchitectureforiOSapps","content":"\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_0.png)\n\n많은 iOS 개발 측면 중 앱의 아키텍처는 가장 중요하고 흥미로운 주제 중 하나입니다. 아키텍처는 규칙 세트가 아닌 시스템의 속성으로, 앱이 작동하는 방식 뿐만 아니라 성장과 평가 방식을 정의합니다. 이는 앱의 모든 부분에 영향을 미치며 개발 프로세스와 최종 제품의 품질에도 직접적인 영향을 미칩니다.\n\n거대한 코드베이스와 강하게 결합된 구성 요소가 보편적이던 시절은 지나갔습니다. 이제 모바일 우선 접근 방식이 이긴 상황이고, 오늘날 모바일 응용 프로그램은 진지하고 매우 경쟁력있는 비즈니스입니다. 결과적으로 고객의 높은 요구 사항을 충족하기 위해 더 모듈화되고 테스트 가능하며 견고한 코드베이스를 만들기 위해 정교한 아키텍처 패턴을 활용합니다.\n\n본문에서는 좋은 아키텍처가 어떻게 보여야 하는지와 그 이유, 도래하는 혜택 및 최대한 활용하기 위해 현대 기술 스택을 활용하여 어떻게 구축해야 하는지에 대한 경험을 공유하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 고지사항\n\n- 제가 언급한 방법이 유일한 올바른 방법이라고 주장하지는 않습니다. 소프트웨어 개발에서는 문제를 해결할 수 있는 다양한 방법이 일반적으로 있으므로, 다른 해결책이 잘 작동하고 만족스러운 경우에는 괜찮습니다.\n- 이 방법은 팀 또는 여러 팀의 개발자들이 개발한 상대적으로 큰 앱에 가장 적합합니다.\n- 이 글은 iOS 개발을 중점적으로 다루지만, 처음 봤을 때 안드로이드 개발에도 큰 노력 없이 도입될 수 있을 것으로 보입니다.\n\n# 좋은 아키텍처란 무엇인가요?\n\n실제 앱에 적합한 좋은 아키텍처를 정의해 봅시다. 이에 대해 약간 다른 의견이 많이 있지만, 일반적으로 다음 요구 사항에 초점을 맞춥니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 쉽게 읽고 이해하기 쉽습니다.\n- 재사용, 확장 및 확장하기 쉽습니다.\n- 테스트하고 테스트가 저렴합니다.\n- 쉽게 디버그하고 수정하며 유지 관리하기 쉽습니다.\n- 새로운 개발자를 온보딩하기 쉽습니다.\n\n많이들 '쉽다'라고 하는데, 해결책은 최소한의 부가 코드를 가지고 끝내야 하며, 엔지니어링은 너무 많이 하지 않아야 쉽다고 할 수 있습니다. 동시에 개발 프로세스에서 매우 효율적이어야 합니다. 또 한 가지 중요한 특징을 더할 거면, 그것은 놈, 구조는 부적절하게 사용되는 것에 저항할 정도로 충분히 강력해야 합니다. 예를 들어, MVC는 잘못 사용하기 매우 쉬우며, 그것이 바로 우리가 \"Massive ViewController\"라고 하는 반패턴을 갖게 된 이유입니다 (대신에 \"Model-View-Controller\"). 좋은 아키텍처는 스스로를 보호하고 기반이 되는 원칙을 지켜야 합니다.\n\n반면에, 아키텍처는 다소 융통성 있으면서 지나치게 과도하지 않아야 합니다. 소프트웨어 개발은 순수한 수학 추상화가 아니며, 앱은 실제 사람들이 개발합니다 (실수를 할 수 있음), 그리고 실제 사람들이 (아키텍처에 대해 전혀 신경쓰지 않을 수도 있는) 실제 하드웨어에서 앱을 사용합니다 (이에는 제한이 있을 수 있음), 종종 3rd party 프레임워크를 사용하며 (이것들은 때로는 우리의 제어 하에 있지 않을 수도 있음). 앱을 외부 환경과 조건에 쉽게 적응시키는 것이 상대적으로 쉬워야 합니다. 다시 말해, 좋은 아키텍처는 가능한 한 간단해야 하고, 필요한 만큼 복잡해야 합니다.\n\n# 아키텍처에 대해 더 자세히 알아보기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아키텍처는 일종의 타협안이며, 결과가 따라온다는 것을 명심해야 해요. MVC, MVP, MVVM과 같은 이러한 아키텍처 패턴들은 매우 간단하고 짧은 학습 후에 쉽게 사용을 시작할 수 있어요. 하지만 이러한 간단함의 반대편은 이러한 패턴들이 보통 코드베이스의 분리 방법을 설명하기 때문에 실제로 해석과 구현이 상당히 다르다는 사실이에요. 결과적으로 각 팀은 레이어 사이의 분리를 유지하기 위해 자체 규칙을 가지고 있으며, 이러한 규칙은 일반적으로 쉽게(실제로는 아마도) 어기기 쉽다는 것이죠. 이러한 패턴의 전형적인 문제는 거대한 비즈니스 로직 레이어인데, 이는 레이어 간의 명확한 경계가 없으면 의존성 주입 없이도 서비스 레이어 및 다른 엔티티를 직접 사용하는 경향이 있어서 제대로 테스트하기 어렵다는 점이에요.\n\nRIBs와 VIPER와 같은 고급 아키텍처 패턴도 있지만, 둘 다 기술적으로 낡았으며 UIKit과 함께 작동하도록 개발되었으므로 SwiftUI와는 잘 작동하지 않아요. 게다가 VIPER는 혜택이 그리 크지 않으면서도 많은 보일러플레이트 코드를 가지고 있어요. RIBs는 여전히 UIKit만을 사용하고 SwiftUI를 사용할 계획이 없다면 좋은 아키텍처일 수 있지만, 실제로는 어렵다고 보여요 — SwiftUI로만 구현할 수 있는 일부 새로운 iOS 기능들이 있을 수 있다는 점이죠.\n\n구성 가능 아키텍처(TCA)는 아마 SwiftUI와 함께 작동할 수 있도록 구상된 유일한 아키텍처일 거예요. 주요 단점은 애플리케이션 전체에 하나의 Scope를 사용하는 것이 권장된다는 것이어서, 앱의 한 부분을 다른 부분과 분리하기 어려운 점이 있어요. 이는 앱이 MVP 이상이거나 여러 개발자 팀에 의해 개발되는 경우에 중요하답니다. 또한, 몇몇 곳에서 TCA의 구현은 상당히 범위가 크게 보일 수 있고(많은 사용자 정의 내장 도구)과 오버 엔지니어링(보일러플레이트 코드)에 대한 우려도 있어요. 또한, 많은 사람들이 가파른 학습 곡선과 성능 문제에 대해 언급하고 있어요. 그렇지만 SwiftUI를 사용해야 하고 어떤 종류의 아키텍처가 필요한지 감이 오지 않는다면, TCA가 좋은 시작점이 될 수 있어요.\n\n## 현대 소프트웨어는 팀워크입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현대의 대부분의 경쟁력 있는 모바일 앱은 단독으로 개발되는 것이 아니라, 경우에 따라 수십 개의 팀에 의해 개발됩니다. 물론 시장에는 많은 독립 개발자들이 있지만, 대부분의 경우 비즈니스 앱과는 조금 다릅니다.\n\n팀워크는 앱이 병렬 개발을 허용하고 쉽게 수행해야 한다는 것을 뜻합니다. 또한, 각 앱의 부분은 많은 개발자에 의해 개발되어야 합니다. 이는 아키텍처가 코드의 각 특정 부분이 어디에 위치해야 하며 어떻게 구현되어야 하는지에 대한 엄격한 규칙이 있어야 한다는 것을 의미합니다. 또한, 아키텍처는 일관성 있는 높은 수준을 가져야 합니다. 그렇지 않으면 한 개발자가 다른 개발자의 작업을 이어 나가지 못할 것입니다. 이 모든 것을 고려하면 아키텍처는 탁월한 수준의 테스트 가능성을 제공해야 합니다. 집중적인 개발의 경우, 아키텍처는 인식 및 이해 부담을 증가시키지 않으면서 수평적 확장성의 좋은 수준을 제공해야 합니다.\n\n## 두 수준의 아키텍처\n\n보통 사람들은 이에 대해 많이 이야기하지 않지만, 잘 구조화된 모듈화 수준이 높은 앱은 두 수준의 아키텍처를 갖고 있습니다. 첫 번째 수준은 건물 블록과 같은 것으로, MVC, MVP, MVVM 등과 같은 하나의 특정 화면 또는 해당 일부 (복잡한 화면의 경우)를 구축하는 책임이 있는 아키텍처입니다. 두 번째 수준은 모든 건물 블록을 조합하고 이를 위해 모든 필요한 종속성을 제공하며 앱의 다양한 부분 간의 라우팅을 포함하는 아키텍처를 담당합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n중간 규모 이상의 모바일 앱을 위해서는 좋은 앱 아키텍처에 대한 위에서 언급한 모든 요구 사항을 충족시키기 위해 두 가지 아키텍처가 필요합니다. 예를 들어, 이 두 번째 아키텍처 없이는 앱의 각 부분에 대해 명확하고 강력한 경계를 설정하는 것이 불가능하며, 가로 확장성, 테스트 가능성, 디버깅 및 유지 관리와 같은 것들을 달성하는 것이 극도로 어려울 것입니다. 이 역할을 수행하기에 가장 적합한 후보 중 하나는 \"Composition Root\" 패턴입니다. 이에 대해 이 글에서 나중에 자세히 설명하겠습니다.\n\n# Elm 아키텍처\n\nElm 아키텍처는 웹 개발에서 잘 알려져 있지만, 모바일 개발을 포함한 다른 영역에 대해 거의 고려되지 않습니다. 명백히 웹을 위해 개발된 아키텍처를 모바일 개발에 그대로 사용하는 것은 불가능합니다. 그러나 최고의 아이디어를 가져와서 이를 모바일 특이사항에 맞게 확장하고 동작하는 프로토타입을 구현하는 것은 가능합니다.\n\n## Elm 아키텍처란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 Elm 프로그램도 항상 다음과 같은 요소로 구분됩니다:\n\n- 앱의 현재 상태를 유지하는 Model\n- Model을 사용자 인터페이스(UI)로 변환하는 View\n- UI에서 발생하는 이벤트인 Message\n- Message를 기반으로 새로운 Model을 생성하는 Update\n\n![Elm Program Structure](/assets/img/2024-06-19-ModernArchitectureforiOSapps_1.png)\n\n이를 기반으로, 몇 가지 매우 중요한 결과가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모델은 주로 모바일 개발에서 State로 명명되며, 앱의 현재 상태나 현재 화면 등을 나타내는 데 필요한 모든 것을 유지하는 단일한 진실의 원천입니다.\n- 뷰는 모바일 개발에서는 뷰 빌더라고하는 순수한 함수인 뷰로, 상태를 입력으로 받고 사용자 인터페이스를 출력으로 하는 기능입니다.\n- 메시지 또는 이벤트는 사용자(또는 앱의 다른 부분)이 보낼 수 있는 한정된 집합이며, 여기서 키워드는 한정된 것이므로 예측할 수 없는 것이 오는 것은 불가능합니다.\n- 업데이트 함수 또는 리듀서는 현재 상태와 새 이벤트를 입력으로 받고 새 상태를 출력으로 하는 순수한 함수입니다. 이는 상태가 변경될 수 있는 유일한 장소입니다.\n\n실제로 앱의 모든 부분은 고립되어 있지 않고 다른 부분들과 협력하여 작동하며 몇 가지 종속성이 있습니다. 이 모든 것은 일종의 환경입니다. 또한 각 이벤트는 상태를 변경할 수 있는 몇 가지 부작용을 일으킬 수 있습니다. 사실, 새로운 상태는 현재 상태에 이벤트의 부작용을 적용한 결과물입니다. 그리고 사용자 인터페이스로부터 이벤트를 받아오기 위한 일종의 추상화, 즉 사용자 이벤트를 생성할 환경인 \"UI 피드백\"이 필요합니다.\n\n![image](/assets/img/2024-06-19-ModernArchitectureforiOSapps_2.png)\n\n예를 들어 사용자가 Pull-to-Refresh 제스처를 수행하면 \"사용자가 업데이트 요청함\" 이벤트가 리듀서 함수로 전달됩니다. 리듀서는 첫 번째 부작용 \"로딩이 시작됨\"을 생성하고 새 데이터를 가져 오기 위해 네트워크 API 호출을 수행합니다. 그런 다음 API 호출이 완료되면 리듀서는 두 번째 부작용 \"로딩이 중지됨\"을 생성합니다. 세 번째 부작용은 API 호출의 결과에 따라 다르며, 성공하는 경우 리듀서는 \"새로운 데이터가 도착함\" 효과를 생성하고, 그렇지 않으면 \"오류가 발생함\" 효과가 됩니다. 각 효과는 현재 상태에 적용되며 각 상태의 변경 후, 뷰 빌더가 사용자를 위해 업데이트된 실제 UI를 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_3.png)\n\n지금까지 우리가 가지고 있는 내용을 정리해 봅시다:\n\n- State — 진실의 단일 출처\n- Event — Reducer에 대한 외부(일반적으로 사용자 입력 또는 “앱이 비활성 상태가 되었음”과 같은 시스템 이벤트) 액션\n- Effect — 내부 액션, State를 변경하는 이유\n- Environment — 이벤트를 이펙트로 변환하는 데 도움이 되는 모든 필수 의존성\n- UI-피드백 — 이벤트를 생성하는 함수\n- Reducer — Event를 Environment와 현재 State에 의해 Effect로 변환하는 \"이벤트 핸들러\"와 현재 State에 사이드 이펙트를 적용하여 새로운 State를 생성하는 \"이펙트 핸들러\" 두 가지 순수 함수를 포함하는 유한 상태 머신\n\n처음에는 조금 복잡해 보일 수 있지만, 실제로 사용하는 데 매우 쉽습니다. 특정 엔티티의 한정된 세트가 있고 각각이 특정 작업에만 책임 있기 때문입니다. 일방향 흐름이기 때문에 이를 따르고 무슨 일이 일어나고 있는지 이해하는 것이 쉽습니다. 대부분의 로직은 순수 함수이며, 진실의 단일 출처이며, 비즈니스 및 프리젠테이션 로직이 확실히 분리되어 있습니다. 이 모든 것을 고려할 때, 이 접근 방식은 정말 높은 수준의 테스트 가능성을 가지고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구현\n\niOS를 위한 Elm 아키텍처의 공식적인 구현은 없지만 적어도 두 가지 매우 좋은 시도가 있습니다:\n\n- RxFeedback: 기술적으로 오래되었으며 이벤트/이펙트를 분리하지 않고 SwiftUI 지원이 없습니다.\n- The Composable Architecture (TCA): 하나의 scope를 사용하며 앱의 다른 부분 간에 명확한 경계가 없으며 이벤트/이펙트를 분리하지 않습니다.\n\n왜 이벤트/이펙트를 분리해야 하는 이유일까요? — 비즈니스 로직의 보호를 위해서입니다. 시스템에 이 분리가 없다면 시스템은 외부에서 내부 이펙트로 확장될 수 있는 공개 이벤트를 가로채고 로직을 망가뜨릴 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n왜 명확한 경계가 중요한가요? — 앱을 작은 독립적인 조각으로 분할하는 가능성은 중요합니다. 전체 코드베이스를 개별 패키지와 타겟으로 분리하면 적은 결합도와 각 부분의 제한된 범위가 유지되어 테스트 가능성, 디버깅 용이성 및 유지 관리에 필수적인 좋은 수준을 유지할 수 있습니다.\n\n## 기술 스택\n\n기술적 측면에서 iOS 개발은 멈춰있지 않고 지속적으로 발전하고 있으며, 최근 몇 년 동안을 돌아보면 다음 몇 단계를 구분할 수 있습니다:\n\n- UIKit + GCD (iOS 9–12): iOS 개발의 기술 스택은 주로 Grand Central Dispatch (GCD) 및 Operation Queue와 함께 작동하는 UIKit으로 구성되어 있었으며 (일부는 스토리보드를 사용했지만, 보다 고급화된 개발자들은 UI를 프로그래밍적으로 구현했습니다).\n- UIKit + RxSwift (iOS 10–13): 반응형 프로그래밍의 등장: MVVM과 UI 바인딩은 제게는 새로운 것이 아니었습니다. 이전에 Microsoft Windows Phone에서 사용해본 적이 있었는데, 대부분의 모바일 개발자들에게는 마음을 바꾸는 혁명같은 것이었습니다.\n- UIKit + Combine (iOS 13–16): Apple이 마침내 원시적인 반응형 프레임워크인 Combine을 제시했는데, RxSwift와 같은 일부 영역에서는 그만큼 강력하지 않지만, 일상적인 루틴에 충분히 좋으며 여전히 대부분의 앱에서 활발히 사용되고 있습니다.\n- SwiftUI + Async/Await (iOS 15+): 네이티브 SwiftUI를 사용한 선언적 UI의 새 시대의 시작으로 처음에는 충분히 안정적이지 않았지만, 매 iOS 릴리스마다 점점 더 안정되고 매력적으로 변화했습니다. Async/Await는 여러 해 동안 많이 원하던 언어 기능이 드디어 출시되었으며 구현이 훌륭하고 강력합니다. 여전히 개선 중이지만, 확실히 제작용으로 완성되었으며 적어도 다음 몇 년 동안 기술 표준이 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플리케이션이 잘 관리되고 리팩터링이 필요한 부분을 계속 수행하는 경우, 이러한 단계들은 서로 점진적으로 전환됩니다. 만약 앱이 iOS 16의 최소 배포 버전을 갖고 있지만 여전히 RxSwift를 적극적으로 사용 중이라면, 무언가 잘못되었을 가능성이 높으며 앱의 기술적 측면에 충분한 주의를 기울이지 않고 있는 것일 수도 있습니다.\n\n오늘날, 인기 있는 많은 앱이 iOS 13 이하 버전을 지원하지 않기 때문에, 우리는 GCD를 사용한 쓰레드 수동 관리에 대해 이미 잊어도 좋을 것입니다(일부 필요한 드문한 경우를 제외하고) RxSwift 및 ReactiveX와 같은 경쟁자들에 대해서도 마찬가지입니다. 현재의 주류는 UIKit + Combine이지만, 내일의 주류는 SwiftUI + Async/Await입니다.\n\n## 소스 코드\n\n우리는 다 알다싶이 - \"말은 싸다. 코드를 보여줘.\"라는 말처럼; Elm 아이디어를 기반으로 하고 SOLID와 Clean Architecture 원칙을 염두에 두어 오늘날 가장 인기있는 기술 스택인 Combine + UIKit으로 Elm 아키텍처를 내 비전대로 구현했습니다. 이 구현은 여기에서 찾아볼 수 있습니다: https://github.com/angryscorp/TEA-Combine.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 구현을 쉽게 평가할 수 있지만 몇 가지 순간을 강조하고 싶습니다.\n\n모든 개체는 구조체 및 열거형이며, 비즈니스 로직 레이어에 클래스가 없습니다. 이는 잠재적인 상속 문제 없이 더 나은 성능을 의미합니다.\n\n```js\npublic struct SceneEnvironment {\n    let getRandomNumber: () -> AnyPublisher<Int, Never>\n    let selectSomething: () -> AnyPublisher<Int?, Never>\n}\n\npublic struct SceneState: Equatable {\n    var something: Int? = nil\n    var currentValue = 0\n    var counter = 0\n}\n\npublic enum SceneEvent {\n    case userDidRequestIncrease\n    case userDidRequestDecrease\n    case userDidRequestSomething\n}\n\npublic enum SceneEffect {\n    case resultDidReceive(Int)\n    case somethingDidReceive(Int?)\n}\n```\n\n어셈블리 함수는 부작용이 없는 순수 함수로, 현재 장면이 의존하는 모든 것을 쉽게 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\npublic struct MainScene {\n\n    public static func create(\n        setRootVC: (UIViewController) -> Void,\n        selectSomething: @escaping (UIViewController) -> AnyPublisher<Int?, Never>\n    ) {\n        let vc = ViewController()\n\n        let env = SceneEnvironment(\n            getRandomNumber: { Just(Int.random(in: 1...9)).eraseToAnyPublisher() },\n            selectSomething: { selectSomething(vc) }\n        )\n\n        TEA.start(\n            initialState: SceneState(),\n            environment: env,\n            feedback: vc.bind,\n            transform: SceneReducer.transform,\n            apply: SceneReducer.apply\n        ).store(in: &vc.subscriptions)\n\n        setRootVC(vc)\n    }\n}\n```\n\nReducer의 함수들도 순수하며, Event와 Effect가 단순히 열거형이기 때문에 이곳에서 switch 연산자를 효과적으로 사용할 수 있고, Event나 Effect에 대한 변경사항이 눈에 띄게 놓치지 않도록 합니다 (소스 코드가 컴파일 중지됩니다).\n\n```js\npublic enum SceneReducer {\n\n    public static func transform(\n        state: SceneState,\n        event: SceneEvent,\n        env: SceneEnvironment\n    ) -> AnyPublisher<SceneEffect, Never> {\n        switch event {\n        case .userDidRequestDecrease:\n            return env.getRandomNumber()\n                .map { SceneEffect.resultDidReceive(-$0) }\n                .eraseToAnyPublisher()\n\n        case .userDidRequestIncrease:\n            return env.getRandomNumber()\n                .map { SceneEffect.resultDidReceive($0) }\n                .eraseToAnyPublisher()\n\n        case .userDidRequestSomething:\n            return env.selectSomething()\n                .map(SceneEffect.somethingDidReceive)\n                .eraseToAnyPublisher()\n        }\n    }\n\n    public static func apply(\n        state: SceneState,\n        effect: SceneEffect\n    ) -> SceneState {\n        switch effect {\n        case let .resultDidReceive(value):\n            return .init(\n                something: state.something,\n                currentValue: state.currentValue + value,\n                counter: state.counter + 1\n            )\n\n        case let .somethingDidReceive(value):\n            return .init(\n                something: value,\n                currentValue: state.currentValue,\n                counter: state.counter\n            )\n        }\n    }\n}\n```\n\n사용자 인터페이스와 비즈니스 로직을 연결하는 모든 것은 딱 한 가지 함수 뿐이며, 따라서 UI 부분을 다른 것으로 쉽게 대체할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nfunc bind(state: AnyPublisher<SceneState, Never>) -> AnyPublisher<SceneEvent, Never> {\nstate\n.receive(on: DispatchQueue.main)\n.sink(receiveValue: { [unowned self] state in\nself.somethingLabel.text = \"Something: \" + (state.something.map {\"\\($0)\"} ?? \"nil\")\nself.counterLabel.text = \"Counter: \\(state.counter)\"\nself.currentValueLabel.text = \"Current value: \\(state.currentValue)\"\n\n            })\n            .store(in: &subscriptions)\n\n        return eventSubject.eraseToAnyPublisher()\n    }\n\n환경은 모든 종속성 및 라우팅을 포함하며, 장면 관점에서 봤을 때, 서비스 종속성과 다른 화면에서 값을 가져오는 것 사이에 기본적인 차이가 없습니다. 두 종속성 모두 순수 함수로 표현할 수 있습니다.\n\npublic struct SceneEnvironment {\nlet getRandomNumber: () -> AnyPublisher<Int, Never>\nlet selectSomething: () -> AnyPublisher<Int?, Never>\n}\n\n## 추가 개발\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 시간은 멈추지 않고 Combine에서 Async/Await와 SwiftUI로 이동할 시간입니다. 여기 Elm 아이디어가 여기서도 잘 작동하는 증거입니다: https://github.com/angryscorp/TEA-AsyncAwait.\n\n모든 것이 비슷하게 보이고 이미 익숙한데, 반응형 접근 방식이 새로운 Swift Modern Concurrency로 대체되어 더 간결하고 명확해졌습니다.\n\n```swift\npublic enum ExampleReducer {\n\n    public static func transform(\n        state: ExampleState,\n        event: ExampleEvent,\n        env: ExampleEnvironment\n    ) async -> ExampleEffect {\n        switch event {\n        case .increase:\n            let newValue = await env.increment(state.currentValue)\n            return .newValue(newValue)\n        case .decrease:\n            let newValue = await env.decrement(state.currentValue)\n            return .newValue(newValue)\n        }\n    }\n\n    public static func apply(\n        state: inout ExampleState,\n        effect: ExampleEffect\n    ) async -> ExampleState {\n        switch effect {\n        case .newValue(let newValue):\n            state.currentValue = newValue\n            return state\n        }\n    }\n}\n```\n\n모든 이점이 동일합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 리듀서를 위한 순수 함수\n- 비즈니스 로직이 없는 뷰\n- 상태는 단일 진실의 원천\n- 이벤트와 효과는 그냥 열거형\n- 적절한 종속성 주입\n- 비즈니스 로직과 UI가 확연히 분리됨\n- 응용 프로그램의 각 부분에 대한 명확한 경계\n- 모든 것이 쉽게 테스트, 디버깅 및 유지 관리될 수 있음\n- 강력하고 따르기 쉬운 구조\n\n이러한 구현 방식들은 iOS 개발에도 뛰어난 성과를 보여주는 Elm 아키텍처가 잘 작동함을 예시로 제시한 것입니다. 물론 그대로 사용할 수 있지만, 이것을 초안으로 삼아 개선하거나 이 원칙을 기반으로 자체 솔루션을 구현하는 등 다양하게 활용할 수 있습니다.\n\n# 테스트\n\n이미 테스트 가능성에 대한 언급을 조금 했었지만, 이번에 한 번 더 테스트의 중요성을 강조하고 싶습니다. 모바일 개발에서 일반적인 문제 중 하나는 테스트 작성이 인기 없다는 것입니다. 실제로 그 이유는 대부분 응용 프로그램 아키텍처가 안 좋기 때문입니다. 안 좋은 아키텍처는 기능을 테스트하기 어렵게 만듭니다. 테스트하기 어렵다는 것은 제대로 테스트하기 위해 많은 시간이 소요된다는 것을 의미합니다. 많은 시간이 든다는 것은 매우 비용이 소요된다는 것입니다. 매우 비용이 소요된다는 것은 비즈니스적인 측면에서 볼 때 이미 모든 게 올바르게 작동하고 있다고 보기 때문에 구현되지 않을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_4.png)\n\n그래서 이것의 주요 결과는 테스트 작성이 저렴해야 합니다. 이상적으로는 테스트를 몇 줄의 코드로 구현할 수 있어야 합니다. Elm 아키텍처를 사용하면 가능합니다. 예를 들어 비즈니스 로직을 테스트하는 방법을 보여드릴게요.\n\n일반적인 Elm 아키텍처 단위 테스트는 다음과 같습니다 - 말 그대로 세 줄의 코드입니다:\n\n- 어떤 이벤트가 발생했는가\n- 초기 상태\n- 기대되는 상태\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n    func test_userDidRequestIncrease() {\n        test(\n            event: .userDidRequestIncrease,\n            initialState: .init(currentValue: 2, counter: 2),\n            expectedState: .init(currentValue: 7, counter: 3)\n        )\n    }\n```\n\n그게 다에요. 다양한 Event와 State 조합을 테스트함으로써 모든 비즈니스 로직을 테스트하고 모든 것이 올바르게 작동하는지 확인할 수 있어요. 또한 한 가지 모범 사례를 포함하여 더 포괄적인 테스트를 위해 Effect 체인을 테스트할 수 있어요.\n\n```js\n    func test_userDidRequestDoubleIncreaseAndDecrease() {\n        test(\n            events: [.userDidRequestIncrease, .userDidRequestIncrease, .userDidRequestDecrease],\n            initialState: .init(currentValue: 23, counter: 2),\n            expectedState: .init(currentValue: 28, counter: 5)\n        )\n    }\n```\n\nThe full implementation of XCTestCase for the Elm architecture can be found here.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단위 테스트 외에도 스냅샷 테스트가 존재합니다. 많은 이점이 있음에도 불구하고, 스냅샷 테스트는 모바일 개발에서 매우 인기가 없으며, 그 이유는 보통 비슷합니다. 스냅샷 테스트를 구현하려면 뷰를 초기화해야 하는데, 이는 품질이 낮거나 적절한 의존성 주입 메커니즘이 없는 경우 쉽지 않을 수 있습니다.\n\n그러나 Elm을 사용하면 매우 쉽습니다. 강력한 레이어 분할 덕분에 뷰는 매우 간단하며 기본적으로 상태에만 의존합니다 (상태는 종종 초기값 또는 기본값을 갖습니다). 따라서 스냅샷 테스트를 만들려면 몇 줄의 코드를 작성해야 하며, 단위 테스트와 마찬가지로 간단합니다.\n\n스냅샷 테스트는 두 가지 이유로 매우 유용하고 중요합니다:\n\n- UI 레이어를 재발을 보호하므로 어떠한 변경과 리팩터링도 두렵지 않고 수행할 수 있습니다.\n- 테스트의 필요성을 염두에 두고 뷰를 올바른 방식으로 구현하도록 개발자들에게 유도하므로 유지보수와 시스템 디버깅 수준을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구성 루트\n\n엘름 아키텍처는 장면 수준에서(장면이 보통 하나의 화면을 의미함) 발생하는 문제를 완벽하게 해결하지만, 이 외에도 앱에 다른 문제가 있을 수 있으며, 그 중 두 가지가 가장 중요합니다:\n\n- 적절한 종속성 주입이 없음\n- 모듈화가 되어 있지 않음\n\n적절한 종속성 주입의 부재는 다음과 같은 결과로 이어집니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 장면 내에서 종속성 해결(Service-Locator 반패턴)\n- 주입 없이 종속성을 직접 사용하여 장면 테스트가 불가능해지는 문제\n\n모듈화 부족(앱이 모놀리스이며 모듈로 분리되지 않은 것을 의미)은 다음과 같은 문제로 이어집니다:\n\n- 유지보수 및 디버깅이 어려워지는 단일 전역 범위\n- 작은 변경이 앱의 매우 다른 부분에 영향을 미칠 수 있으며, 강력한 회귀 테스트 없이는 눈에 띄지 않을 수 있음\n\n모든 이러한 문제는 \"구성 루트\" 패턴을 통해 성공적으로 해결하고 전체 코드 베이스를 독립적인 모듈(스위프트 패키지 매니저(SPM) 용어에서 패키지 및 타겟)로 분할함으로써 해결할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nComposition Root은 모듈이 결합되는 애플리케이션의 고유 위치입니다.\n\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_5.png)\n\n실제 응용 프로그램에서 \"Composition Root\" 패턴이 어떻게 보이는지 더 잘 이해하기 위해 이를 보여드릴게요.\n\n![이미지](/assets/img/2024-06-19-ModernArchitectureforiOSapps_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 구성 요소는 별도의 타겟으로 Swift Package에 있으며, 이상적으로 관련된 몇 가지 구성 요소/타겟(예: \"온보딩\" 플로우와 같이 함께하는 사용자 흐름)은 별도의 Swift 패키지에 위치해 있습니다.\n\n여기에 \"구성 루트(Composition Root)\" 구현의 간단한 예제를 찾을 수 있습니다.\n\n구성 루트와 모듈화는 다음과 같은 탁월한 장점을 가지고 있습니다:\n\n- 앱의 독립적인 부분이 서로 다른 모듈에 위치\n- 모듈간 명확하고 강력한 경계\n- 한 모듈의 변경이 다른 모듈에 영향을 미칠 수 없음\n- 가볍고 최적화하기 쉬운 실행 레이어\n- 전체 앱 및 그 어떤 부분에 대한 안정성, 유지보수 및 디버깅이 크게 향상됨\n- 모든 종속성이 안전하게 해결되었음을 정적 컴파일 시 보장\n- 의도하지 않은 모듈 간 사용 또는 간섭 제외\n- 앱의 모든 레이어 및 부분 간의 낮은 결합도\n- 변경되지 않은 모듈을 캐싱하여 컴파일 프로세스가 빨라짐\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 걱정하는 것을 그치고, 삶을 시작하는 방법\n\n혹시 이 모든 것이 흥미롭긴 하지만, 여러분의 앱의 현재 상태에서 실제로 시도해보기에는 너무 멀게 느껴진다면, 그것은 오산이다. 앱의 상태에 따라 Elm 아이디어와 Clear Architecture 원칙으로의 여정이 더 오래 또는 더 짧을 수 있지만, 확실히 가능하며 가능한 한 빨리 해야 할 것입니다.\n\n이를 위해 특별한 리팩터링 작업이 필요하지는 않습니다. 단지 Core 패키지를 만들고 Domain 타겟(비어있어도 괜찮습니다)을 생성한 뒤, 일상적인 기능 작업의 일부로 점진적으로 채워 넣기 시작하면 됩니다. 새로운 멋진 기능을 구현하려면 새로운 Swift 패키지를 만들어 이 패키지에 모든 코드를 작성하면 됩니다(한 화면씩 한 타겟). 이 기능을 위해 새로운 Domain 엔티티가 필요하다면 FeatureDomain 타겟을 만들고 해당 엔티티를 넣으면 됩니다. 몇 개의 화면에서 로직을 재사용해야 한다면 새로운 UseCase 타겟을 만들고 해당 로직을 옮기면 됩니다. Composition Root을 시도할 준비가 되면 한 번에 앱 전체를 다시 쓸 필요는 없습니다. 적절한 진입점을 찾아서 진입점 이후의 모든 것이 자동으로 모듈성과 Composition Root의 장점을 얻을 수 있습니다.\n\n다시 강조하고 싶은 것은, 앱을 개선하기 위해 특별한 작업이 필요하지 않으며, 일상적인 루틴의 일부로 이를 수행하면 된다는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 모든 것은 이론적인 접근이나 환상에 그치는 것이 아닙니다. 몇 차례 시도해 본 경험을 통해 알려주겠습니다. 많은 문제와 안티패턴이 존재하는 레거시 앱을 성공적으로 최고 수준의 견고하고 효율적인 솔루션으로 변환했습니다.\n\n# 결론\n\nElm 아키텍처와 Composition Root 패턴 뒤에 있는 아이디어는 새로운 것이 아니지만, 모바일 개발에서 지나치게 소홀히 다루는 것을 알 수 있습니다. 이 기사는 이러한 원칙이 어떻게 실무에 적용될 수 있는지에 대한 이해의 공백을 채우기 위한 지식과 경험을 공유하기 위한 것입니다. 저는 이러한 접근 방식을 일상적인 업무에 사용하며, 제 팀뿐만 아니라 저 자신도 매우 만족하고 있습니다.\n\n실제 제작 개발에서 검증된 작동하는 구현을 제공했지만, 항상 솔루션과 아이디어를 특정 상황과 기술 스택에 맞게 맞추는 것이 더 좋습니다. 이를 강화시키기 위해 발전시킬 수 있는 초안으로도 고려할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 권장하고 장려하는 바에 따라 아키텍처 주제에 조금 더 깊이 파고들어보시고 이 글에서 제안하는 아이디어를 귀하의 프로젝트에서 시도해보세요. 그것이 잘 작동하고 귀하의 앱을 다음 수준으로 끌어 올릴 수 있다는 것을 직접 확인하면서, 없을 때 어떻게 살아온 지 의심스러울 정도일 겁니다.\n","ogImage":{"url":"/assets/img/2024-06-19-ModernArchitectureforiOSapps_0.png"},"coverImage":"/assets/img/2024-06-19-ModernArchitectureforiOSapps_0.png","tag":["Tech"],"readingTime":25},{"title":"맥OS Sequoia의 새로운 기능들","description":"","date":"2024-06-19 11:00","slug":"2024-06-19-WhatsNewinmacOSSequoia","content":"\n맥OS 15 세쿼이아의 흥미진진한 혁신에 빠져 보세요! WWDC 2024에서 공개됐어요!\n\n![맥OS 세쿼이아](https://miro.medium.com/v2/resize:fit:1400/1*WWqe1h7PVj4W71TS8J2IzA.gif)\n\nWWDC 2024에서 뽐낸 주목할만한 발표 중 하나는 macOS 세쿼이아였는데요, 맥 사용자들에게 원활하고 강력한 경험을 제공할 것을 약속하고 있어요. 생산성, 창의성, 연결성에 초점을 맞춘 macOS 세쿼이아는 Apple 생태계를 향상시키는 새로운 기능을 소개했어요.\n\n정교한 사용자 인터페이스부터 혁신적인 성능 향상까지, 함께 WWDC 2024에서 발표된 흥미로운 내용을 살펴보아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# macOS 15을 지원하는 기기들:\n\n- MacBook Pro (2018년 이후 모델)\n- MacBook Air (2018년 이후 모델)\n- Mac Pro (2019년 이후 모델)\n- Mac Studio (2022년 이후 모델)\n- Mac Mini (2018년 이후 모델)\n- iMac Pro (2017년 이후 모델)\n- iMac (2019년 이후 모델)\n\n# 내부에서 찾을 수 있는 것들:\n\n- iPhone 미러링\n- 창 배치\n- 비디오 콜\n- Safari\n- 비밀번호 앱\n- Mac 게임\n- macOS Sequoia에서의 추가 기능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 아이폰 미러링\n\nmacOS Sequoia에서는 아이폰 미러링을 통한 연속성의 중요한 기능이 소개되었습니다. 이로써 맥이 잠겨 있을 때에도 아이폰에 완전히 액세스할 수 있습니다.\n\n미러링을 통해 사용자는 아이폰의 모든 앱을 실행하고 사용할 수 있습니다. 맥의 키보드, 마우스 및 트랙패드를 사용하여 아이폰과 상호 작용할 수도 있습니다. 아이폰의 오디오는 맥을 통해 재생됩니다.\n\n미러링을 하면 아이폰과 맥 간에 파일을 드래그하여 이동할 수 있습니다. 아이폰의 알림은 맥의 알림과 함께 표시되므로 사용자는 아이폰이 없을 때에도 확인하고 상호 작용할 수 있습니다. 알림을 탭하면 해당 앱이 미러링 모드에서 열립니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_0.png)\n\n# 창 타일링\n\n사용자는 창을 화면 가장자리로 끌어다 놓아 데스크탑에 배치하는 창 타일링 제안을 받을 수 있습니다. 키보드 및 메뉴 단축키를 사용하여 창을 정리하여 사용자가 조직적으로 유지할 수 있습니다.\n\n![image](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 비디오 콘퍼런싱\n\n프레젠터 미리보기를 통해 사용자들은 공유하기 전에 공유할 내용을 볼 수 있으며, FaceTime 및 Zoom 앱과 함께 작동합니다. 사용자는 비디오 콘퍼런싱 중에 최상의 모습을 유지하기 위해 배경 사진을 설정할 수도 있습니다.\n\n![image](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_2.png)\n\n# Safari\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Safari는 이제 페이지 강조 기능을 제공하여 방향, 요약 또는 사람, 음악, 영화 및 TV 프로그램에 대해 자세히 알아보기 위한 빠른 링크와 같은 유용한 정보를 제공합니다.\n- 웹 페이지에서 비디오를 발견하면 사용자가 Picture in Picture를 포함한 완전한 재생 제어 기능을 제공하는 동시에 중심에 배치됩니다.\n- 재설계된 리더(Reader)는 혼잡하지 않고 독서 경험을 제공합니다. Safari는 개인 브라우징을 특징으로하며, 히스토리 보호와 웹 사이트가 브라우징하는 동안 사용자를 추적하는 것을 방지합니다.\n\n기타 Safari 기능으로는\n\n- 프로필\n- 번역\n- 확장 기능\n- 탭 그룹\n- 패스키\n- 개인 릴레이\n\n# 비밀번호 앱\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nmacOS Sequoia의 Passwords 앱을 사용하면 모든 암호에 쉽게 액세스할 수 있어요. iCloud 동기화를 통해 암호를 모든 Apple 기기 간에 동기화할 수 있어요.\n\n![2024-06-19-WhatsNewinmacOSSequoia_3.png](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_3.png)\n\n# 맥에서 게임하기\n\n## 1. 새로운 게임 타이틀\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n맥에서 기다리고 있던 Ubisoft의 Assassin's Creed Shadows가 11월 15일에 출시될 예정입니다.\n\n다른 맥용 게임 소개\n\n- Prince of Persia: The Lost Crown\n- RESIDENT EVIL 7 biohazard\n- RESIDENT EVIL 2\n- World of Warcraft: The War Within\n- Frostpunk 2\n- Palworld\n- Sniper Elite 4\n- RoboCop: Rogue City\n\n![이미지](/assets/img/2024-06-19-WhatsNewinmacOSSequoia_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. 몰입형 게임 경험\n\n에어팟 프로(2세대)에서 개인화된 공간 오디오로 인해 레이턴시가 줄어들어 더 반응이 좋아졌습니다. 게임 모드 개선으로 더 부드러운 프레임률을 제공합니다.\n\n## 3. 게임 포팅 툴킷 2\n\n개발자들은 게임 포팅 툴킷 2의 개선 사항을 활용하여 이제 Apple 기기로 쉽게 게임을 가져올 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Mac용 Apple Intelligence\n\n강력한 생성 모델을 활용한 개인용 지능 시스템으로, 개인 맥락을 이해하고 사용자에게 미치는 유용하고 관련성 높은 기능과 콘텐츠를 제공하며 개인정보 보호를 핵심가치로 삼습니다.\n\nApple 실리콘의 힘을 빌려, Apple Intelligence는 언어와 이미지를 생성하고 개인 맥락을 활용하여 모든 앱에서 작업을 가속화하여 사용자의 일상 업무를 더욱 효율적으로 처리할 수 있습니다.\n\n## 1. 언어 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기능 재작성은 친근하거나 전문적이거나 간결하다는 다른 톤으로 텍스트를 조정할 수 있습니다.\n- 교정은 문법, 어휘 선택, 문장 구조를 확인하며, 사용자가 검토하거나 수락할 편집 제안을 할 수 있습니다.\n- 사용자는 독자의 시간을 절약하기 위해 텍스트를 글머리 기호, 목록 또는 간결한 단락으로 요약할 수 있습니다.\n- Mail 앱의 중요 메시지는 가장 긴급한 이메일(이벤트나 탑승권과 같은)을 보여주는 인박스 상단에 새 섹션을 추가합니다. Mail 앱은 또한 사용자가 전체 이메일을 열어 읽을 필요 없이 이메일 요약을 표시합니다.\n- 스마트 답장은 이메일의 질문을 분석하고 식별하여 빠른 응답을 위한 제안을 제공하며, 모든 것이 답변되도록 보장합니다.\n\n<img src=\"/assets/img/2024-06-19-WhatsNewinmacOSSequoia_5.png\" />\n\n### 2. 이미지 만들기\n\n<img src=\"/assets/img/2024-06-19-WhatsNewinmacOSSequoia_6.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3. 시리\n\n# macOS Sequoia의 추가 기능\n\n- 메시지에는 새로운 텍스트 효과, 이모티콘, 스티커 Tapbacks가 포함되어 있습니다. 사용자는 메시지를 나중에 보낼 수도 있습니다.\n- Apple Maps는 이제 모든 63개 국립 공원의 하이킹 코스를 보여줍니다. 사용자는 길이, 고도 및 루트 유형으로 필터링하여 오프라인 액세스를 위해 저장할 수 있습니다.\n- 캘린더에는 레마인더에서 이벤트와 작업을 표시하여 사용자가 하루 내내 레마인더에 대해 조치를 취할 수 있습니다.\n- 메모는 이제 등식의 자동 해결을 지원하여 사용자가 등식을 입력하기만 하면 숫자를 빠르게 계산할 수 있습니다. 메모의 새로운 오디오 전사 기능은 사용자가 Apple Intelligence를 활용하여 대본을 만들고 요약하는 데 도움을 줍니다.\n\n# 마무리 생각\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n맥OS Sequoia는 혁신적인 기능과 원활한 Apple 생태계 전체에서의 통합을 통해 맥 경험을 새로운 차원으로 끌어올립니다. 이 업데이트는 모든 사용자를 위한 생산성, 창의성 및 연결성을 재정의합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-WhatsNewinmacOSSequoia_0.png"},"coverImage":"/assets/img/2024-06-19-WhatsNewinmacOSSequoia_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI에서 FocusState를 마스터하기 고급 기능을 활용한 동적 폼 관리","description":"","date":"2024-06-19 10:59","slug":"2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures","content":"\n<img src=\"/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png\" />\n\n사용자의 포커스를 효과적으로 관리하는 것은 모든 애플리케이션에서 매끈하고 직관적인 사용자 경험을 만들기 위해 중요합니다. SwiftUI는 FocusState라는 강력한 기능을 제공하는데, 이를 사용하면 개발자가 폼 입력 및 기타 대화형 요소의 포커스 상태를 동적으로 관리할 수 있습니다. 이 블로그 포스트에서는 FocusState를 사용하여 사용자 상호작용에 따라 포커스를 조정하는 사용자 지정 입력 폼을 만드는 방법을 살펴보겠습니다. 또한 조건부 포커스, 키보드 관리 및 사용자 정의 포커스 처리와 같은 고급 기능을 포함하고 있습니다.\n\n## FocusState 이해하기\n\nFocusState는 SwiftUI에서 도입된 프로퍼티 래퍼로, 텍스트 필드와 같은 뷰의 포커스 상태를 관리하는 데 도움을 주는 역할을 합니다. FocusState를 사용하면 어떤 입력 필드에 포커스를 맞출지를 프로그래밍적으로 제어할 수 있어 사용자 경험을 더 부드럽게 만들 수 있습니다, 특히 폼에서의 경우에 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 커스텀 입력 폼 만들기\n\n사용자 입력에 따라 동적으로 포커스가 변경되는 여러 텍스트 필드가 있는 포괄적인 양식을 만들어 봅시다. 조건부 포커스, 키보드 해제 및 사용자 정의 포커스 로직과 같은 고급 기능을 통합할 것입니다.\n\n## 구현 단계별\n\n1. 양식 필드와 포커스 상태 정의하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 다양한 폼 필드를 나타내는 열거형을 정의합니다. 그런 다음, 폼 상태와 포커스 상태를 나타내는 구조체를 생성합니다.\n\n```js\nimport SwiftUI\n\nenum FormField: Hashable {\n    case firstName\n    case lastName\n    case email\n    case password\n    case confirmPassword\n}\n\nstruct FormState {\n    var firstName: String = \"\"\n    var lastName: String = \"\"\n    var email: String = \"\"\n    var password: String = \"\"\n    var confirmPassword: String = \"\"\n}\n```\n\n2. 폼 뷰 생성하기:\n\n이제, 폼 필드를 포함하는 뷰를 생성해보겠습니다. @FocusState 프로퍼티 래퍼를 사용하여 포커스 상태를 관리하고 더 많은 고급 기능을 추가할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nstruct CustomFormView: View {\n    @State private var formState = FormState()\n    @FocusState private var focusedField: FormField?\n\n    var body: some View {\n        VStack {\n            Form {\n                TextField(\"이름\", text: $formState.firstName)\n                    .focused($focusedField, equals: .firstName)\n                    .onSubmit {\n                        focusedField = .lastName\n                    }\n                    .submitLabel(.next)\n\n                TextField(\"성\", text: $formState.lastName)\n                    .focused($focusedField, equals: .lastName)\n                    .onSubmit {\n                        focusedField = .email\n                    }\n                    .submitLabel(.next)\n\n                TextField(\"이메일\", text: $formState.email)\n                    .focused($focusedField, equals: .email)\n                    .keyboardType(.emailAddress)\n                    .onSubmit {\n                        focusedField = .password\n                    }\n                    .submitLabel(.next)\n\n                SecureField(\"비밀번호\", text: $formState.password)\n                    .focused($focusedField, equals: .password)\n                    .onSubmit {\n                        focusedField = .confirmPassword\n                    }\n                    .submitLabel(.next)\n\n                SecureField(\"비밀번호 확인\", text: $formState.confirmPassword)\n                    .focused($focusedField, equals: .confirmPassword)\n                    .onSubmit {\n                        validateForm()\n                    }\n                    .submitLabel(.done)\n            }\n            .padding()\n\n            Button(\"제출\") {\n                validateForm()\n            }\n            .padding()\n            .buttonStyle(.borderedProminent)\n        }\n        .onTapGesture {\n            // 필드 외부를 탭하면 키보드 닫기\n            focusedField = nil\n        }\n        .toolbar {\n            ToolbarItemGroup(placement: .keyboard) {\n                Spacer()\n                Button(\"완료\") {\n                    focusedField = nil\n                }\n            }\n        }\n    }\n\n    private func validateForm() {\n        // 여기서 폼 유효성 검사 및 제출 로직 수행\n        guard !formState.firstName.isEmpty,\n              !formState.lastName.isEmpty,\n              isValidEmail(formState.email),\n              formState.password == formState.confirmPassword else {\n            // 오류 메시지 표시 또는 유효성 검사 실패 처리\n            return\n        }\n\n        // 폼 제출 처리\n        print(\"폼이 제출되었습니다: \\(formState)\")\n        focusedField = nil\n    }\n\n    private func isValidEmail(_ email: String) -> Bool {\n        // 기본적인 이메일 유효성 검사 로직\n        let emailRegEx = \"[A-Z0-9a-z._%+-]+@[A-Z0-9a-z.-]+\\\\.[A-Za-z]{2,64}\"\n        let emailPred = NSPredicate(format: \"SELF MATCHES %@\", emailRegEx)\n        return emailPred.evaluate(with: email)\n    }\n}\n```\n\n3. Form View 미리보기:\n\n마지막으로 SwiftUI 미리보기에서 Form View를 미리볼 수 있습니다.\n\n```swift\n#Preview {\n  CustomFormView()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Explanation\n\n- **포커스 관리:** 각 TextField 및 SecureField는 `.focused($focusedField, equals: .formField)` 수정자를 사용하여 특정 포커스 상태와 연결됩니다. 이를 통해 사용자가 하나의 필드를 제출할 때 다음 필드로 포커스가 전환됩니다.\n\n- **동적 포커스 조정:** `onSubmit` 수정자는 반환 키 작업을 처리하는 데 사용됩니다. 사용자가 현재 필드를 제출하면 포커스가 다음 필드로 변경됩니다.\n\n- **사용자 지정 키보드 툴바:** 키보드에 사용자 정의 툴바가 추가되어 \"완료\" 버튼을 탭함으로써 키보드를 해제할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n• 양식 제출 및 유효성 검사: validateForm 함수는 양식 제출과 유효성 검사를 처리합니다. 비어있는 필드, 유효한 이메일 형식 및 일치하는 비밀번호를 확인한 후에야 양식 제출이 진행됩니다.\n\n• 키보드 해제: onTapGesture 수정자는 사용자가 입력 필드 외부를 탭할 때 키보드를 해제하는 데 사용됩니다.\n\n## 결론\n\nSwiftUI에서 FocusState를 사용하면 입력 필드의 포커스 상태를 관리하여 동적이고 사용자 친화적인 양식을 만들 수 있습니다. 조건부 포커스, 키보드 관리 및 사용자 정의 유효성 검사와 같은 고급 기능을 통합함으로써 SwiftUI 애플리케이션에서 사용자 경험을 향상시키고 더 견고한 양식을 생성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원하는 경우 원시 모바일 개발에 대해 더 알아보려면 여기에서 다른 기사들을 확인해보세요: [https://medium.com/@wesleymatlock](https://medium.com/@wesleymatlock)\n\n코딩을 즐기세요! 🚀\n","ogImage":{"url":"/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringFocusStateinSwiftUIDynamicFormManagementwithAdvancedFeatures_0.png","tag":["Tech"],"readingTime":7},{"title":"MVVM 아키텍처로 SwiftUI 앱 구축하기 실전 안내","description":"","date":"2024-06-19 10:58","slug":"2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide","content":"\n이 튜토리얼에서는 MVVM(Model-View-ViewModel) 아키텍처를 사용하여 간단한 SwiftUI 애플리케이션을 만드는 방법을 안내합니다. 데이터 처리 및 네트워킹을 위해 Combine 프레임워크를 활용할 것입니다. 이 예제에서는 REST API에서 데이터를 가져오고 게시하는 방법을 보여줍니다.\n\n# 개요\n\n다음과 같은 간단한 앱을 만들 것입니다:\n\n- 서버에서 게시물 목록을 가져오기.\n- SwiftUI 뷰에서 게시물을 표시하기.\n- 새 게시물을 생성하기.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로젝트 설정\n\n먼저 Xcode에서 새로운 SwiftUI 프로젝트를 생성하세요. 그런 다음, 더 나은 구성을 위해 다음과 같은 폴더를 설정합니다:\n\n- Models\n- ViewModels\n- Views\n- Services\n\n# Models\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"Post\" 모델을 시작해봅시다. 이 모델은 Identifiable과 Codable을 준수합니다.\n\n```swift\n// Models/Post.swift\n\nimport Foundation\n\nstruct Post: Identifiable, Codable {\n    let id: Int\n    let title: String\n    let body: String\n}\n```\n\n# 서비스\n\n네트워크 요청을 처리하기 위한 서비스 레이어가 필요합니다. ApiService와 ApiEndpoints를 만들 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n// Services/ApiEndpoints.swift\n\nimport Foundation\n\nclass ApiEndpoints {\nstatic let baseURL = \"https://jsonplaceholder.typicode.com\"\n\n    static var posts: String { return \"\\(baseURL)/posts\" }\n    static func post(id: Int) -> String { return \"\\(baseURL)/posts/\\(id)\" }\n\n}\n\n// Services/ApiService.swift\n\nimport Foundation\nimport Combine\n\nclass ApiService {\nstatic let shared = ApiService()\nprivate init() {}\n\n    private func makeRequest<T: Decodable>(url: String, method: String, body: Data? = nil) -> AnyPublisher<T, Error> {\n        guard let url = URL(string: url) else {\n            fatalError(\"Invalid URL\")\n        }\n\n        var request = URLRequest(url: url)\n        request.httpMethod = method\n        if let body = body {\n            request.httpBody = body\n            request.setValue(\"application/json\", forHTTPHeaderField: \"Content-Type\")\n        }\n\n        return URLSession.shared.dataTaskPublisher(for: request)\n            .tryMap { output in\n                guard let response = output.response as? HTTPURLResponse,\n                      response.statusCode >= 200 && response.statusCode < 300 else {\n                    throw URLError(.badServerResponse)\n                }\n                return output.data\n            }\n            .decode(type: T.self, decoder: JSONDecoder())\n            .eraseToAnyPublisher()\n    }\n\n    func get<T: Decodable>(url: String) -> AnyPublisher<T, Error> {\n        return makeRequest(url: url, method: \"GET\")\n    }\n\n    func post<T: Decodable, U: Encodable>(url: String, body: U) -> AnyPublisher<T, Error> {\n        guard let bodyData = try? JSONEncoder().encode(body) else {\n            fatalError(\"Invalid body data\")\n        }\n        return makeRequest(url: url, method: \"POST\", body: bodyData)\n    }\n\n    func delete<T: Decodable>(url: String) -> AnyPublisher<T, Error> {\n        return makeRequest(url: url, method: \"DELETE\")\n    }\n\n}\n\n# ViewModels\n\n이제, PostViewModel을 만들어서 게시물을 가져오고 만들어봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n// ViewModels/PostViewModel.swift\n\nimport Foundation\nimport Combine\n\nclass PostViewModel: ObservableObject {\n    @Published var posts: [Post] = []\n    @Published var isLoading = false\n    @Published var errorMessage: String? = nil\n\n    private var cancellables = Set<AnyCancellable>()\n    private let apiService = ApiService.shared\n\n    func fetchPosts() {\n        self.isLoading = true\n        self.errorMessage = nil\n\n        apiService.get(url: ApiEndpoints.posts)\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { [weak self] completion in\n                self?.isLoading = false\n                switch completion {\n                case .failure(let error):\n                    self?.errorMessage = error.localizedDescription\n                case .finished:\n                    break\n                }\n            }, receiveValue: { [weak self] posts in\n                self?.posts = posts\n            })\n            .store(in: &cancellables)\n    }\n\n    func createPost() {\n        let newPost = Post(id: 101, title: \"New Post\", body: \"This is a new post.\")\n\n        apiService.post(url: ApiEndpoints.posts, body: newPost)\n            .receive(on: DispatchQueue.main)\n            .sink(receiveCompletion: { completion in\n                switch completion {\n                case .failure(let error):\n                    print(\"Error: \\(error.localizedDescription)\")\n                case .finished:\n                    print(\"Post created successfully\")\n                }\n            }, receiveValue: { (post: Post) in\n                print(\"Created post: \\(post)\")\n            })\n            .store(in: &cancellables)\n    }\n}\n```\n\n# Views\n\n마지막으로, SwiftUI 뷰를 생성하여 게시물을 표시하고 사용자 상호작용을 처리합니다.\n\n```swift\n// Views/PostListView.swift\n\nimport SwiftUI\n\nstruct PostListView: View {\n    @StateObject private var viewModel = PostViewModel()\n\n    var body: some View {\n        NavigationView {\n            VStack {\n                if viewModel.isLoading {\n                    ProgressView(\"로딩 중...\")\n                } else if let errorMessage = viewModel.errorMessage {\n                    Text(\"오류: \\(errorMessage)\")\n                } else {\n                    List(viewModel.posts) { post in\n                        VStack(alignment: .leading) {\n                            Text(post.title)\n                                .font(.headline)\n                            Text(post.body)\n                                .font(.subheadline)\n                        }\n                    }\n                }\n            }\n            .navigationTitle(\"게시물\")\n            .onAppear {\n                viewModel.fetchPosts()\n            }\n            .toolbar {\n                Button(action: {\n                    viewModel.createPost()\n                }) {\n                    Image(systemName: \"plus\")\n                }\n            }\n        }\n    }\n}\n\nstruct PostListView_Previews: PreviewProvider {\n    static var previews: some View {\n        PostListView()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 모두 함께 적용하기\n\n모두가 동작하는 것을 보려면 PostListView를 App 구조체의 진입점으로 설정하세요.\n\n```js\n// demoApp.swift\n\nimport SwiftUI\n\n@main\nstruct demoApp: App {\n    var body: some Scene {\n        WindowGroup {\n            PostListView()\n        }\n    }\n}\n```\n\n이 튜토리얼에서는 SwiftUI 애플리케이션에서 간단한 MVVM 아키텍처를 구현했습니다. 이 구조는 관심사를 분리하여 코드를 보다 깨끗하고 유지보수하기 쉽게 만들어주며, Combine과 같은 Swift의 강력한 기능을 활용하여 비동기 데이터 스트림 처리에도 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 안내를 따르면 SwiftUI 프로젝트에서 MVVM을 설정하고 사용하는 방법에 대해 잘 이해할 수 있을 것입니다. 코딩을 즐기세요!\n","ogImage":{"url":"/assets/img/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaSwiftUIAppwithMVVMArchitectureAPracticalGuide_0.png","tag":["Tech"],"readingTime":8}],"page":"47","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}