{"pageProps":{"posts":[{"title":"컴포즈 멀티플랫폼Android iOS으로 UI 중심 안드로이드 라이브러리 이주하기","description":"","date":"2024-05-23 12:52","slug":"2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS","content":"\n연혁을 거듭하면서, Kotlin Multiplatform이 드디어 여기 머물 것 같습니다. 그러나 비즈니스 로직만 공유하는 것이 특히 React Native, Flutter 및 기타 기술이 더 많은 일을 할 수 있는 만큼 편리하고 경쟁력이 있다고 느끼는 어색한 느낌이 아직 남아 있었습니다. 그래서 매우 기대되었던 Compose Multiplatform for iOS의 첫 번째 알파 버전을 작년에 보게 되어 정말 기뻤습니다.\n\n퍼즐이 마침내 맞추어졌습니다. 이제 안드로이드 개발자들은 최소한의 추가 노력으로 iOS 앱을 코틀린으로 만들 수 있습니다. 그러나 이게 정말 그럴까요? 알아봅시다. 여기서는 라이브러리 이전에 대해 설명하겠습니다. 전체 애플리케이션을 이전할 때 몇 가지 점이 다를 수 있습니다.\n\n<img src=\"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png\" />\n\n## 내 경우에 관하여\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드/Kotlin과 iOS/Swift 클라이언트가 있습니다. 두 클라이언트 모두 다음 UI 기능을 갖춘 자체 제작 라이브러리를 사용합니다:\n\n- 정적으로 로드할 수 있는 이미지\n- 로드 가능한 GIF\n- 비디오 (CDN으로부터 스트리밍 로딩)\n- 모든 항목은 수직 목록에 수평 목록이 내장됩니다\n\n추가로:\n\n- 네트워크 통신\n- 디스크 캐싱\n\n언제든지 물어보세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](https://miro.medium.com/v2/resize:fit:472/1*4Eb5MmEXdZwZC8WkYBB6yA.gif)\n\n우리에게는 Compose Multiplatform 기능과 성능을 테스트하는 좋은 시작점이었습니다. 무엇이 문제가 될 수 있는지 알고 싶다면, 여기에서 확인해보세요.\n\n## 왜 Compose Multiplatform 인가요?\n\n일부 소스에서 Jetpack Compose를 선언적 API로 설명합니다. 저에게 있어 Jetpack Compose의 주요 장점은 전통적인 XML 레이아웃과 비교했을 때의 유연성입니다. 그리고 Jetpack Compose에서 레이아웃을 작성한 후에는 Compose Multiplatform로 이전하는 것이 정말 어렵지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비즈니스적인 관점에서 주요 방해 요인이 없이 코드베이스를 점진적으로 통합하는 것이 더 쉽습니다. 추가 개발자가 필요하지 않습니다. 그것이 Compose Multiplatform이 허용하는 것입니다.\n\nJetbrains에 따르면, 이것이 어떻게 작동하는지 간단히 상기시켜 드리겠습니다:\n\n![Jetbrains Image](/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_1.png)\n\n## 코드베이스에서의 장애물\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔 우리는 모두 KMP 코드가 아닌 코드를 작성하거나 사용합니다. 때로는 많을 때도 있죠.\n\n전형적인 예시는 다음과 같습니다:\n\n- Java 코드\n- Dagger 2, RxJava, Retrofit 등과 같은 호환되지 않는 라이브러리 종속성\n- XML 레이아웃, 뷰, 프래그먼트\n- 안드로이드 서비스, 푸시 알림, 인앱 구매\n- 그 밖에도...\n\n여기에는 주로 2가지 해결책이 있습니다:\n\n- 코드를 다시 작성하거나 KMP 호환 라이브러리로 이전하여 commonMain 폴더에 넣습니다.\n- 호환되지 않는 코드를 플랫폼별 서브모듈인 androidMain 및 iosMain에 넣습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사실 platform-specific 하위 모듈에 항상 코드를 넣을 수 있습니다. 그러나 이 경우에는 iOS용으로 코드를 작성하거나 iOS에서도 구현해야 합니다.\n\n## iOS에 특정한 코드를 작성하는 방법은?\n\niOS 플랫폼별 코드를 정의하거나 사용하는 데는 2가지 주요 옵션이 있습니다:\n\n옵션 1.\niosMain 폴더에 구현된 Expect/actual 함수.\n다음은 구조가 어떻게 보이는지 예시입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_2.png\" />\n\n옵션 2.\niOS 측에서 호출할 수 있는 몇 가지 커넥터를 제공합니다.\n다음은 commonMain에서 빈 로거를 정의하는 예입니다:\n\n```kotlin\nobject Bridge {\n    var logger: (String) -> Unit = {}\n    ...\n}\n```\n\niOS/Swift 앱에서 로거에 대한 구현을 할당합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport ...\n\nBridge.shared.logger = {\n    print(\"ios log: \" + $0)\n}\n```\n\n그냥 간단한 경우일 뿐입니다. 사실 거의 모든 것을 이 방법으로 연결할 수 있습니다. commonMain에서 인터페이스를 정의하고 전체 구현을 별도로 Swift로 작성하는 것도 가능합니다.\n\n물론 작성해야 하는 플랫폼별 코드가 많아질수록 더 나쁠 수 있습니다. 제 상황에서는 iosMain에 전체 라이브러리 코드의 약 9%가 있고, androidMain에는 약 13%가 있습니다. 이 비율은 여러분의 상황에서는 낮을 수도 있습니다.\n\n## 어떻게 마이그레이션을 시작할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 Android/Kotlin 및 iOS/Swift 클라이언트를 보유하고 있습니다. 통합을 시작하는 방법은 무엇일까요?\n\nAndroid의 경우, 기존 앱 또는 라이브러리에 KMP(코틀린 멀티플랫폼)과 호환되는 코드를 단계별로 다시 작성하여 통합할 수 있습니다. 언어는 그대로 유지되지만 의존하는 접근 방식과 라이브러리는 변경될 수 있습니다.\n\n간단한 경우에는 다음과 같습니다:\n\n- 코드베이스에 KMP 모듈을 만듭니다.\n- 코드를 공통 모듈(commonMain)로 순차적으로 이동시킵니다.\n- 플랫폼에서 이동할 수 없는 부분에 대한 커넥터를 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 우리의 경우에 iOS와 안드로이드 클라이언트가 의존하는 UI 중심 라이브러리를 마이그레이션하기로 결정했습니다. 그 라이브러리를 완전히 다시 작성해야 했던 이유는 RxJava와 XML 레이아웃을 기반으로 했기 때문이었습니다.\n\n## 우리의 주요 기술 변화\n\nRxJava → Coroutines / Flow\n만약 Rx를 사용 중이라면 Flow로 마이그레이션하거나 Reaktive와 같은 KMP 대안을 사용해야 합니다.\n\nRetrofit → Ktor\nKtor는 매우 편리한 네트워크 라이브러리입니다. 큰 문제는 없었습니다. 여러 번 검색해서 익숙했던 것을 어떻게 쓰는지 찾아보면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRoom → Room?\n제 경우에는 일반 디스크 캐싱을 Okio로 대체하는 것이 허용되었습니다. 하지만 사실 Room은 KMP도 지원합니다.\n\nGlide → Coil 3 + iOS용 자체 GIF 구현.\nCoil 3는 아직 알파 버전이지만 동작합니다. 제 경우 문제는 iOS에서 GIF를 재생할 수 없었던 것이었습니다. 안타깝게도 몇 일 동안 문제를 해결하고 디스크 캐싱을 통해 해결책을 구현하는 데 시간이 걸렸습니다.\n\n제 경우 이미지에 대한 기본 계약:\n\n```js\n@Composable\nexpect fun LoadableImage(\n    modifier: Modifier,\n    url: String,\n    imageColorFilter: ColorFilter? = null,\n    size: Size? = null,\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJetpack ExoPlayer → ExoPlayer + AVPlayer\n우리는 각 플랫폼마다 플레이어를 대체하기 위해 expect/actual을 사용합니다.\nExoPlayer는 디스크 캐싱 및 스트리밍 재생 기능을 갖춘 안드로이드용 강력한 솔루션입니다.\nAvPlayer는 iOS의 기본 솔루션입니다.\n\n플레이어의 기본 계약:\n\n```js\n@Composable\nexpect fun VideoPlayer(\n    modifier: Modifier,\n    url: String,\n    volumeEnabled: State<Boolean>,\n)\n```\n\n## 안드로이드용 빌드 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안드로이드의 경우 일반적인 안드로이드 라이브러리와 유사합니다. 이 라이브러리는 애플리케이션의 모듈로 사용할 수 있습니다. 현재는 이것이 우리의 선택입니다.\n\n다른 옵션으로 그레이들 복합 빌드를 사용할 수도 있습니다. 자세한 내용은 다음 기사를 참조하세요:\n\n마지막으로, 그레이들 작업 bundleReleaseAar을 사용하여 라이브러리를 .aar 파일로 조립할 수 있습니다.\n\n## iOS용 빌드 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로컬 개발 중에는 XCFramework을 빌드하고 iOS 프로젝트에 넣습니다. 프로세스는 여기에 설명되어 있습니다:\n\n간단히 말하면 다음과 같습니다:\n\n- Gradle 작업을 호출합니다.\n  로컬 빌드(빠름)의 경우 iosX64Binaries 또는 iosArm64Binaries를 사용하거나 최종 이진 파일의 경우 assembleReleaseXCFramework를 사용합니다(느림).\n- build/bin/iosArm64/releaseFramework (또는 유사한 경로)에서 결과물을 iOS 프로젝트로 복사합니다.\n- Xcode에 의해 동기화될 때까지 잠시 기다립니다.\n- 완료. iOS 프로젝트에서 Kotlin 코드를 사용하세요.\n\n자동화된 CI/CD 파이프라인에서는 프로세스가 약간 다르지만 이는 다른 이야기입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 나의 경우의 결과\n\n현재 저희 이주 작업은 사전 제작 단계에 있지만, 이미 몇 가지 결론을 도출할 수 있습니다.\n\n🟢 기능성.\n저희 라이브러리의 모든 주요 기능이 이주되었습니다.\n일부 비중요한 예외를 제외하고 기능 요구 사항이 충족되었습니다.\n\n🟢 코드베이스.\n이와 같이 재작성하는 것은 많은 레거시 코드를 제거할 수 있는 기회입니다.\n숫자:\n이주 이전: 10,000 줄 코드, 1,200 줄 XML\n이후: 4,000 줄 코드\n결과: 기존 버전과 비교했을 때 코드 양이 약 2.5배 감소했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🟢 성능.\niOS에서는 iPhone SE에서도 부드럽게 스크롤됩니다.\n저사양 안드로이드 기기에서는 XML 버전과 비교했을 때 그렇게 부드럽지 않지만, 심각한 문제는 아닙니다.\n\n🟡 개발 생산성.\n일반적으로, 현대적인 안드로이드 개발과 Jetpack Compose에 익숙하다면 주요 문제가 없을 것입니다. 다만 제 경험상 한 가지 예외가 있습니다: Android Studio 및 IDEA에는 미리보기가 없습니다. Fleet에서는 작동하지만 AS/IDEA에서는 Composable 함수를 블라인드로 작성해야 합니다.\n\n🟡 이진 크기.\nAndroid APK: + 0.5 MB\niOS IPA: + 18 MB\n\n🟡 라이브러리 크기.\n거대한 XCFrameworks 크기. 300MB 이상입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n🔴 빌드 시간.\niOS의 빌드 시간이 길어요. 기계에 따라 다르지만 라이브러리 4k 줄의 코드를 가지고 17분 같은 숫자를 볼 수 있어요.\n\n## 결론\n\n2024년에는 Kotlin으로 크로스 플랫폼 UI를 작성하는 것이 전혀 가능합니다.\n\nKMP와 Compose Multiplatform의 멋진 점은 Kotlin으로 코드를 작성해야 한다면, 왜 KMP 호환 방식으로 작성하지 않을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 경우에는 결과가 수용 가능하며, 스트레스 테스트로 간주할 수 있습니다. 또한 iOS용 Compose Multiplatform이 알파 단계에 있고, Kotlin 2가 미래에 있음을 염두에 두어야 합니다.\n\n읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png"},"coverImage":"/assets/img/2024-05-23-MigratingUI-orientedAndroidlibrarytoComposeMultiplatformAndroidiOS_0.png","tag":["Tech"],"readingTime":11},{"title":"유용한 정보 공유 - 소셜 미디어에서 Composables 사용하는 방법","description":"","date":"2024-05-23 12:51","slug":"2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia","content":"\n![Screenshot](/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png)\n\n# 사진이 없으면 일어나지 않았어요\n\n인스타그램 게시물은 황홀한 모험의 마무리 또는 무기화된 FOMO의 조각일 수 있어요. 어쨌든 사람들은 자신의 하이라이트와 취미를 소셜 미디어에 기억하기를 좋아해요.\n\n최근에 Viz 앱에 공유 기능을 추가했어요. 이제 다이버와 스노클러도 이 의식에 참여할 수 있어요. 당시에는 Compose에서 생성된 아름다운 뷰를 Instagram, TikTok, Twitter 등에서 공유 가능한 이미지로 어떻게 변환하는지에 대해 온라인에 많이 쓰여 있지 않았어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 다른 쪽으로 나와서 스스로 구현하는 방법을 안내해 드릴게요! 순서는 대략 다음과 같아요:\n\n- 공유하고 싶은 모든 콘텐츠를 포함하는 컴포저블 만들기\n- 컴포저블을 이미지로 변환하기\n- 안드로이드의 Sharesheet를 사용하여 이미지를 공유하기\n\n제가 공유된 백 엔드 코드를 작성할 때 KMP를 사용하고 있지만, UI는 Android 및 iOS에 대해 별도로 네이티브로 작성했어요. Android 버전은 아래에 작성되어 있고 SwiftUI 버전은 다음 주 별도의 기사에서 공유될 예정이에요!\n\n# 공유 가능한 형식 디자인하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n삼격하고 상대적으로 높은 이동성을 가지고 있는 정사각형은 모든 소셜 미디어 플랫폼에서 최적의 화면 비율이에요. 인스타그램을 예로 들어보면—이 모양은 스크롤 피드에서 \"게시물\"로 공유되거나 전체 화면 \"스토리\"에 쉽게 가운데 정렬될 수 있어요.\n\n이 이상적인 크기는 두 가지 요소에 따라 다릅니다:\n\n- 이미지로 공유될 때 선명하고 뚜렷하게 보이기 위한 충분한 세부 정보가 있는 크기\n- 디자인 시스템에서 폰트 스타일 토큰을 수용할 수 있는 크기 (원시 작성, Material3 또는 다른 것)\n\n저는 안드로이드에서 400.dp부터 500.dp 크기가 이 두 목표를 모두 잘 이루어낼 수 있다고 생각해요. 대부분의 휴대폰에서 전체 화면 크기로 변환될 거예요. 그리고 이 크기에서 '제목', '헤드라인', '본문'과 같은 폰트 스타일을 사용하면 본인만의 원시 폰트 크기를 계산할 필요 없이 손쉽게 사용할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun MyShareContent() {\n    val headline = MaterialTheme.typography.headlineLarge\n    val title = MaterialTheme.typography.titleLarge\n\n    Box(\n        modifier = Modifier\n            .size(400.dp)\n            .background(color = MaterialTheme.colorScheme.surface)\n    ) {\n        Column(\n            verticalArrangement = Arrangement.SpaceBetween,\n            horizontalAlignment = Alignment.CenterHorizontally,\n            modifier = Modifier\n                .padding(12.dp)\n                .fillMaxSize(),\n        ) {\n            Icon(\n                painter = painterResource(id = R.drawable.v3_logo_with_text),\n                tint = Color.Unspecified, // 원본 SVG 색상 유지\n                contentDescription = null,\n                modifier = Modifier.height(200.dp)\n            )\n            Text(text = \"Moon Bay Marine Reserve\", style = headline)\n\n            Row(\n                horizontalArrangement = Arrangement.SpaceBetween,\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(text = \"Date\", style = title)\n                Text(text = \"Thursday 10 April 2024\", style = title)\n            }\n\n            Row(\n                horizontalArrangement = Arrangement.SpaceBetween,\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(text = \"Time\", style = title)\n                Text(text = \"10:20 - 11:45\", style = title)\n            }\n        }\n    }\n}\n```\n\n![Image](/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_1.png)\n\n# 그래픽 레이어에 Composable 기록하기\n\nCompose의 최신 버전(1.7)에서는 훌륭한 GraphicsLayer API가 소개되었습니다. 이는 Composable의 그리기를 캡처하고 다른 위치에서 재생하는 방법을 제공합니다. 결국 이를 사용하여 Composable을 이미지 파일로 기록할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nvar graphicsLayer = rememberGraphicsLayer()\n\nBox(modifier = Modifier\n    .size(400.dp)\n    .drawWithCache {\n        // draw to graphics layer\n        graphicsLayer = obtainGraphicsLayer().apply {\n            record { drawContent() }\n        }\n        // draw to actual UI\n        onDrawWithContent { drawContent() }\n    }) {\n    // The content being recorded\n    Surface(modifier = Modifier.fillMaxSize()) {\n        MyShareContent()\n    }\n}\n```\n\n이 코드 스니펫의 주요 기능:\n\n- Box를 부모 컨테이너로 사용\n- 공유하려는 컴포저블을 Box의 콘텐츠 매개변수에 배치\n- drawWithCache 수정자를 사용하여 콘텐츠의 그리기를 캡처\n- record 메서드를 사용하여 그림을 저장된 graphicsLayer 변수로 리디렉션\n\n# 컴포저블 그리기를 완전히 건너뛰기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컴포저블을 화면에서 숨기고 전혀 표시하지 않을 수도 있습니다.\n\nViz 앱에서 사용자가 게시물을 저장한 후에는 전체 상세 버전을 보여줍니다. 그러나 소셜 미디어에 공유하기 위한 간단한 요약 버전을 제공합니다. 이 경우 화면에 전체 버전을 표시하고 공유 가능한 버전은 오프스크린에서 생성합니다.\n\n이를 달성하려면 코드에 몇 가지 변경 사항이 필요합니다 —\n\n```js\nvar graphicsLayer = rememberGraphicsLayer()\n\nBox(modifier = Modifier\n    .size(0.dp) // UI에 공간을 사용하지 않도록 크기를 0으로\n    .drawWithCache {\n        // 그래픽 레이어에 그리기\n        graphicsLayer = obtainGraphicsLayer().apply {\n            record(\n                size = IntSize(\n                    width = 400.dp.toPx().toInt(),\n                    height = 400.dp.toPx().toInt()\n                )\n            ) {\n                drawContent()\n            }\n        }\n\n        // 화면에 그리기를 건너뛰기 위해 비워 두기\n        onDrawWithContent { }\n    }) {\n    Box(\n        // 녹화의 원하는 크기로 부모 크기를 재정의\n        modifier = Modifier\n            .wrapContentHeight(unbounded = true, align = Alignment.Top)\n            .wrapContentWidth(unbounded = true, align = Alignment.Start)\n            .requiredSize(400.dp)\n    ) {\n        // 녹화되는 내용\n        Surface(modifier = Modifier.fillMaxSize()) {\n            MyShareContent()\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드 스니펫의 주요 기능은 다음과 같습니다:\n\n- 부모 Box 콤포저블은 크기를 0.dp로 설정합니다.\n- onDrawWithContent ' '은 비워두었는데요 — 이것은 화면에 그리는 것을 건너뛸 때 사용됩니다.\n- 자식 콤포저블에는 wrapContentHeight 및 wrapContentWidth 수정자를 사용하여 unbound = true로 설정합니다.\n- 자식 콤포저블에는 desired size를 지정하기 위해 requiredSize 수정자를 사용하여 크기를 설정합니다(400.dp).\n\n# 그래픽 레이어를 이미지 파일에 작성하세요\n\nAndroid 플랫폼에 파일을 작성할 때, 성능, 권한, API의 가용성 등 여러 가지 고려할 사항이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간결함과 집중을 위해 여기에 기본적인 해결책을 제시할게요. 안드로이드 14에서 잘 작동하는데요, 미디어 저장소 API로의 이동이라는 소문에도 불구하고요. 파일을 공유 Pictures 디렉토리에 쓰고, 미디어 스캐너를 사용하여 공유 가능한 URI를 생성함으로써 대부분의 권한 고려 사항을 회피할 수 있어요.\n\n파일 작성에 대해 미묘하게 다루고 싶다면, Wan Xiao의 다음 글을 추천드려요 -\n\n지금은 다음과 같은 과정을 따를 거에요:\n\n- 그래픽 레이어를 비트맵으로 변환\n- 비트맵을 PNG로 압축\n- PNG를 Pictures 디렉토리에 파일로 쓰기\n- 새 이미지 파일의 URI 가져오기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nprivate suspend fun GraphicsLayer.saveAsShareableFile(context: Context): Uri? {\n\n    // 비트맵으로 변환\n    val bitmap = this.toImageBitmap().asAndroidBitmap()\n\n    // 파일 생성\n    val file = File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES),\n        \"my-app-post-${System.currentTimeMillis()}.png\")\n\n    // PNG로 비트맵을 파일에 쓰기\n    file.outputStream().use { out ->\n        bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)\n        out.flush()\n    }\n\n    // 공유를 위한 파일 URI 가져오기\n    return file.scanPath(context)\n}\n\nsuspend fun File.scanPath(context: Context): Uri? {\n    // 코루틴으로 자바 콜백 래핑\n    return withTimeoutOrNull(timeMillis = 5000) {\n        suspendCancellableCoroutine { continuation ->\n            MediaScannerConnection.scanFile(\n                context,\n                arrayOf(path),\n                arrayOf(\"image/png\")\n            ) { scannedPath, scannedUri ->\n                continuation.resume(scannedUri)\n            }\n        }\n    }\n}\n```\n\n사회적 공유 이미지를 위해 PNG를 사용하는 것을 추천합니다. 텍스트가 포함된 이미지일 경우 선명도를 보존하는 것이 중요합니다. 각 소셜 미디어 플랫폼은 이미지를 원하는 크기와 형식으로 압축하기 때문에 이미지의 품질을 최대로 유지해야 합니다.\n\n# 버튼으로 프로세스 시작\n\n이미지 URI를 얻은 후에는 공유 인텐트를 생성하여 어디든 전송할 수 있습니다. 이렇게 하면 Android 공유 시트가 열리고 나머지 프로세스를 자동으로 처리합니다 — 추가적인 코드는 필요하지 않습니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval context = LocalContext.current\nval coroutineScope = rememberCoroutineScope()\nvar graphicsLayer = rememberGraphicsLayer()\n\nButton(onClick = {\n    coroutineScope.launch {\n        if (graphicsLayer.size.width > 0 && graphicsLayer.size.height > 0) {\n            val uri = graphicsLayer.saveAsShareableFile(context)\n            val shareIntent: Intent = Intent().apply {\n                action = Intent.ACTION_SEND\n                putExtra(Intent.EXTRA_STREAM, uri)\n                type = \"image/png\"\n            }\n            startActivity(\n                context, Intent.createChooser(shareIntent, \"share\"), null\n            )\n        }\n    }\n\n}) {\n    // imo - nicer than IconButton with text\n    Row(horizontalArrangement = Arrangement.spacedBy(ButtonDefaults.IconSpacing)) {\n        Icon(\n            Icons.Default.Share,\n            contentDescription = null,\n            modifier = Modifier.size(18.dp)\n        )\n        Text(\n            text = \"Share\", style = MaterialTheme.typography.labelLarge\n        )\n    }\n}\n\n// Shareable 컴포저블을 여기에 포함하세요...\n```\n\n이 코드 스니펫에서 중요한 기능:\n\n- 부모 컴포저블에 범위 지정된 코루틴 시작\n- 그래픽 레이어가 0보다 큰지 확인하여 실행 보호\n- 이전에 생성한 헬퍼 확장 기능을 사용하여 그래픽 레이어 저장\n- 공유 Intent 생성 및 시작\n\n이러한 기능은 ViewModel에서 구현하는 것이 좋을까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전체 과정은 다른 상태와 상호 작용할 필요 없이 구성 가능한 내부에 포함될 수 있습니다.\n\n또한 컴포저블 내에 Context를 유지하고 관리하는 것이 더 쉽습니다. 이러한 이유로, 버튼의 onClick 매개변수에서 코루틴을 직접 시작하는 것을 권장합니다.\n\n# 전체 코드 — 모든 것을 함께 넣기\n\n그래 — 이제 복사/붙여넣기 시간입니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kt\n// 모든 명확하지 않은 임포트\n// 더 짧게 하기 위해 구성 임포트는 제외\nimport android.content.Context\nimport android.content.Intent\nimport android.graphics.Bitmap\nimport android.media.MediaScannerConnection\nimport android.net.Uri\nimport android.os.Environment\nimport androidx.core.content.ContextCompat.startActivity\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport kotlinx.coroutines.withTimeoutOrNull\nimport java.io.File\nimport kotlin.coroutines.resume\n\n@Composable\nfun MyShareScreen() {\n    val context = LocalContext.current\n    val coroutineScope = rememberCoroutineScope()\n    var graphicsLayer = rememberGraphicsLayer()\n\n    Column {\n        Button(onClick = {\n            coroutineScope.launch {\n                if (graphicsLayer.size.width > 0 && graphicsLayer.size.height > 0) {\n                    val uri = graphicsLayer.saveAsShareableFile(context)\n                    val shareIntent: Intent = Intent().apply {\n                        action = Intent.ACTION_SEND\n                        putExtra(Intent.EXTRA_STREAM, uri)\n                        type = \"image/png\"\n                    }\n                    startActivity(\n                        context, Intent.createChooser(shareIntent, \"share\"), null\n                    )\n                }\n            }\n\n        }) {\n            // IMO - nicer than IconButton with text\n            Row(horizontalArrangement = Arrangement.spacedBy(ButtonDefaults.IconSpacing)) {\n                Icon(\n                    Icons.Default.Share,\n                    contentDescription = null,\n                    modifier = Modifier.size(18.dp)\n                )\n                Text(\n                    text = \"Share\", style = MaterialTheme.typography.labelLarge\n                )\n            }\n        }\n\n        Box(modifier = Modifier\n            .size(0.dp) // size 0 so that no space is used in the UI\n            .drawWithCache {\n                // draw to graphics layer\n                graphicsLayer = obtainGraphicsLayer().apply {\n                    record(\n                        size = IntSize(\n                            width = 400.dp.toPx().toInt(),\n                            height = 400.dp.toPx().toInt()\n                        )\n                    ) {\n                        drawContent()\n                    }\n                }\n\n                // leave blank to skip drawing on the screen\n                onDrawWithContent { }\n            }) {\n            Box(\n                // override the parent size with desired size of the recording\n                modifier = Modifier\n                    .wrapContentHeight(unbounded = true, align = Alignment.Top)\n                    .wrapContentWidth(unbounded = true, align = Alignment.Start)\n                    .requiredSize(400.dp)\n            ) {\n                // The content being recorded\n                Surface(modifier = Modifier.fillMaxSize()) {\n                    Text(\"My Share Content Here\")\n                }\n            }\n        }\n    }\n}\n\nsuspend fun GraphicsLayer.saveAsShareableFile(context: Context): Uri? {\n\n    // convert to bitmap\n    val bitmap = this.toImageBitmap().asAndroidBitmap()\n\n    // create file\n    val file = File(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES),\n        \"my-app-post-${System.currentTimeMillis()}.png\")\n\n    // write bitmap to file as PNG\n    file.outputStream().use { out ->\n        bitmap.compress(Bitmap.CompressFormat.PNG, 100, out)\n        out.flush()\n    }\n\n    // get file URI for sharing\n    return file.scanPath(context)\n}\n\nsuspend fun File.scanPath(context: Context): Uri? {\n    // wrap java callback in coroutine\n    return withTimeoutOrNull(timeMillis = 5000) {\n        suspendCancellableCoroutine { continuation ->\n            MediaScannerConnection.scanFile(\n                context,\n                arrayOf(path),\n                arrayOf(\"image/png\")\n            ) { scannedPath, scannedUri ->\n                continuation.resume(scannedUri)\n            }\n        }\n    }\n}\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*wX0_iwYqjzYVOm9Qu4pv1A.gif)\n\n# 정리합니다\n\n저는 Viz 앱을 개발하고 운영하는 독립 개발자입니다. 이 앱은 Kotlin Multiplatform을 활용한 네이티브 iOS 및 Android 앱입니다. 호주에서 다이빙, 스노클링 또는 프리다이빙을 즐기는 분들에게 꼭 한번 확인해보세요! 이 앱은 사람들이 서로 물 조건을 공유하고 해저 사진을 업로드하며 다이빙 로그를 유지할 수 있는 공간입니다. 항상 무료이며 가입이 필요하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n잘못된 부분이나 버그를 발견하셨나요? 제안이나 대안이 있으시다면 언제든지 편하게 피드백해주세요! 이 기사에 몇 가지 수정사항을 추가하는 것에 항상 열려있습니다!\n\n그렇지 않다면, 여러분들이 이 내용을 유용하게 사용하고 있는지 알기 위해 언제나 의견/좋아요 등을 감사히 받겠습니다 :)\n","ogImage":{"url":"/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png"},"coverImage":"/assets/img/2024-05-23-SomethingWorthSharingHowtouseComposablesonSocialMedia_0.png","tag":["Tech"],"readingTime":16},{"title":"루비 필터를 Logstash에서 테스트하는 방법","description":"","date":"2024-05-23 12:49","slug":"2024-05-23-HowtotestaRubyfilterinLogstash","content":"\n이전 기사에서는 Logstash에서 코드를 공유하고 루비 필터에서 모듈을 만드는 방법을 보았습니다. 이 기사에서는 결과 이벤트가 예상대로인지 확인하기 위해 필터를 테스트하는 방법을 보여드릴 것입니다.\n\n# 이전 코드에 대해\n\n기억을 새기기 위해, 코드는 다음과 같았습니다:\n\n```js\nrequire './script/denormalized_by_prizes_utils.rb'\n\n# `params`의 값은 로그스태시 구성에서 `script_params`에 전달된 해시의 값입니다.\ndef register(params)\n    @keep_original_event = params[\"keep_original_event\"]\nend\n\n# 필터 메소드는 이벤트를 수신하고 이벤트 목록을 반환해야 합니다.\n# 이벤트를 삭제하면 반환 배열에 포함되지 않음을 의미합니다.\n# 새 이벤트를 만드는 것은 반환된 배열에 LogStash::Event의 새 인스턴스만 추가하면 됩니다.\ndef filter(event)\n\n    items = Array.new\n\n    # 원래 이벤트를 유지하려면\n    originalEvent = LogStash::Util::DenormalizationByPrizesHelper::getOriginalEvent(event, @keep_original_event);\n    if not originalEvent.nil?\n        items.push originalEvent\n    end\n\n    # 상품 항목을 가져옵니다 (정규화)\n    prizes = LogStash::Util::DenormalizationByPrizesHelper::getPrizes(event);\n    if prizes.nil?\n        return items\n    end\n\n    # 복제 기본 이벤트 생성\n    eventBase = LogStash::Util::DenormalizationByPrizesHelper::getEventBase(event);\n\n    # 필요한 수정으로 상품 항목별 이벤트 생성\n    prizes.each { |prize|\n        items.push LogStash::Util::DenormalizationByPrizesHelper::createEventForPrize(eventBase, prize);\n    }\n\n    return items;\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 코드는 denormalized_by_prizes_utils.rb 파일 전체 내용입니다.\n\n```rb\nmodule LogStash::Util::DenormalizationByPrizesHelper\n    include LogStash::Util::Loggable\n\n    # 원본 이벤트 유지 여부 확인\n    def self.getOriginalEvent(event, keepOriginalEvent)\n        logger.debug('keepOriginalEvent is :' + keepOriginalEvent.to_s)\n        if keepOriginalEvent.to_s == 'true'\n            event.set('[@metadata][_index]', 'prizes-original');\n            return event;\n        end\n        return nil;\n    end\n\n    # 상금 아이템 얻기 (정규화)\n    def self.getPrizes(event)\n        prizes = event.get(\"prize\");\n        if prizes.nil?\n            logger.warn(\"이벤트에 상금이 없습니다: \" + event.to_s)\n        end\n        return prizes;\n    end\n\n    # 클론 기본 이벤트 생성\n    def self.getEventBase(event)\n        eventBase = event.clone();\n        eventBase.set('[@metadata][_index]', 'prizes-denormalized');\n        eventBase.remove(\"prize\");\n        return eventBase;\n    end\n\n    # 필요한 수정과 함께 현재 상금 아이템을 위한 이벤트 클론 생성\n    def self.createEventForPrize(eventBase, prize)\n        eventPrize = eventBase.clone();\n        # 각 상금 아이템 값을 상금 객체로 복사\n        prize.each { |key,value|\n            eventPrize.set(\"[prize][\" + key + \"]\", value)\n        }\n        return eventPrize;\n    end\nend\n```\n\n## 일반 구문\n\n이 섹션에서는 예상된 이벤트가 실제로 예상한 대로 생성되는지 확인하는 기능 테스트를 작성하는 방법을 보여줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하나 이상의 테스트 케이스를 작성할 수 있으며 각 테스트 케이스마다 필요한 만큼의 테스트를 수행할 수 있습니다. 이러한 테스트는 루비 필터 파일 끝에 작성되어야 합니다. 즉, register/filter 함수를 포함하는 주 파일에 작성되어야 합니다.\n\n필터 테스트는 다음과 같은 구문을 따라야 합니다:\n\n```js\ntest \"테스트 케이스 이름\" do\n\n    parameters do\n    {\n        # 필터에 전달할 매개변수\n    }\n    end\n\n    in_event {\n        # 필터 프로세스에 도착하는 이벤트\n    }\n\n    # expect 메서드를 사용한 테스트\n\nend\n```\n\n# 저희 루비 필터에 테스트를 구현합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예제에서는 역정규화를 구현했기 때문에 테스트에서 원본 이벤트를 잘 역정규화했는지 여러 경우(원본 이벤트 유지 여부, 상금 목록에 상금 하나 또는 둘의 예)를 확인할 것입니다.\n\n## 테스트 케이스\n\n따라서, 아래에 제시된 네 가지 테스트 케이스가 필요합니다:\n\n```js\ntest \"Case 1: 이벤트에 상금 하나 / 원본 이벤트 유지하지 않음\" do\n\n    parameters do\n    {\n        \"keep_original_event\" => false\n    }\n    end\n\n    in_event {\n        {\n            \"id\"        => 1,\n            \"firstname\" => \"Pierre\",\n            \"surname\"   => \"Curie\",\n            \"gender\"    => \"male\",\n            \"prize\"     => [\n                {\n                    \"year\" => 1903,\n                    \"category\" => \"physics\"\n                }\n            ]\n        }\n    }\n\n    # expect 메소드를 사용한 테스트\n\nend\n\ntest \"Case 2: 이벤트에 상금 하나 / 원본 이벤트 유지\" do\n\n    parameters do\n    {\n        \"keep_original_event\" => true\n    }\n    end\n\n    in_event {\n        {\n            \"id\"        => 1,\n            \"firstname\" => \"Pierre\",\n            \"surname\"   => \"Curie\",\n            \"gender\"    => \"male\",\n            \"prize\"     => [\n                {\n                    \"year\" => 1903,\n                    \"category\" => \"physics\"\n                }\n            ]\n        }\n    }\n\n    # expect 메소드를 사용한 테스트\n\nend\n\ntest \"Case 3: 이벤트에 상금 둘 / 원본 이벤트 유지하지 않음\" do\n\n    parameters do\n    {\n        \"keep_original_event\" => false\n    }\n    end\n\n    in_event {\n        {\n            \"id\"        => 2,\n            \"firstname\" => \"Marie\",\n            \"surname\"   => \"Curie\",\n            \"gender\"    => \"female\",\n            \"prize\"     => [\n                {\n                    \"year\" => 1903,\n                    \"category\" => \"physics\"\n                },\n                {\n                    \"year\" => 1911,\n                    \"category\" => \"chemistry\"\n                }\n            ]\n        }\n    }\n\n    # expect 메소드를 사용한 테스트\n\nend\n\ntest \"Case 4: 이벤트에 상금 둘 / 원본 이벤트 유지\" do\n\n    parameters do\n    {\n        \"keep_original_event\" => true\n    }\n    end\n\n    in_event {\n        {\n            \"id\"        => 2,\n            \"firstname\" => \"Marie\",\n            \"surname\"   => \"Curie\",\n            \"gender\"    => \"female\",\n            \"prize\"     => [\n                {\n                    \"year\" => 1903,\n                    \"category\" => \"physics\"\n                },\n                {\n                    \"year\" => 1911,\n                    \"category\" => \"chemistry\"\n                }\n            ]\n        }\n    }\n\n    # expect 메소드를 사용한 테스트\n\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 기능 테스트 구현\n\n이 글에서는 더 복잡한 테스트 케이스(마지막)만 구현할 것입니다. 다른 것들에 대해서도 원리는 동일하지만 서로 다른 테스트 케이스를 테스트하므로 예상 결과는 같지 않을 것입니다.\n\n그래서 마지막 테스트 케이스에서 다음을 확인할 것입니다:\n\n- 원본이 변경 없이 출력에 포함되어 있는지 확인하기\n- \"prize\" 배열의 각 항목마다 문서를 생성하므로 두 항목은 두 개의 문서를 생성해야 합니다\n- 생성된 각 항목이 올바른 공통 필드와 올바른 상금 필드를 포함하고 있는지 확인하기\n- 결과적으로 출력에는 3개의 이벤트가 있어야 하며, 각 이벤트는 별도의 인덱스에 있어야 합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희의 테스트는 다음과 같이 작성될 수 있어요:\n\n```js\ntest \"Case 4: two prizes in event / keep original event\" do\n\n    parameters do\n    {\n        \"keep_original_event\" => true\n    }\n    end\n\n    in_event {\n        {\n            \"id\"        => 2,\n            \"firstname\" => \"Marie\",\n            \"surname\"   => \"Curie\",\n            \"gender\"    => \"female\",\n            \"prize\"     => [\n                {\n                    \"year\" => 1903,\n                    \"category\" => \"physics\"\n                },\n                {\n                    \"year\" => 1911,\n                    \"category\" => \"chemistry\"\n                }\n            ]\n        }\n    }\n\n    expect(\"Count of events\") do |events|\n        events.length == 3\n    end\n\n    expect(\"Each event has same shared fields\") do |events|\n        result = true\n        events.each { |event|\n            result &= event.get(\"[id]\") == 2\n            result &= event.get(\"[firstname]\") == \"Marie\"\n            result &= event.get(\"[surname]\") == \"Curie\"\n            result &= event.get(\"[gender]\") == \"female\"\n        }\n        result\n    end\n\n    expect(\"Each event has good _index\") do |events|\n        result = true\n        result &= events[0].get(\"[@metadata][_index]\") == \"prizes-original\"\n        result &= events[1].get(\"[@metadata][_index]\") == \"prizes-denormalized\"\n        result &= events[2].get(\"[@metadata][_index]\") == \"prizes-denormalized\"\n        result\n    end\n\n    expect(\"Each event has good prize fields\") do |events|\n        result = true\n        result &= events[0].get(\"[prize][0][year]\") == 1903\n        result &= events[0].get(\"[prize][0][category]\") == \"physics\"\n        result &= events[0].get(\"[prize][1][year]\") == 1911\n        result &= events[0].get(\"[prize][1][category]\") == \"chemistry\"\n        result &= events[1].get(\"[prize][year]\") == 1903\n        result &= events[1].get(\"[prize][category]\") == \"physics\"\n        result &= events[2].get(\"[prize][year]\") == 1911\n        result &= events[2].get(\"[prize][category]\") == \"chemistry\"\n        result\n    end\n\nend\n```\n\n여러 개의 어설션을 갖는 `expect` 메서드를 사용할 때는, `&&` 또는 `&=` 연산자를 사용하여 어설션 결과를 결합하는데 문법에 주의하세요.\n\n우리의 테스트 케이스 구현이 준비되었어요. 모든 테스트 케이스는 Logstash 시작 시 실행되며 해당 파이프라인이 생성될 때 실행돼요. 실제로, Logstash는 Ruby 필터에 작성된 모든 테스트를 찾을 수 있어요. 그리고 Logstash 로그에서 모든 테스트 결과를 볼 수 있을 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n![이미지1](/assets/img/2024-05-23-HowtotestaRubyfilterinLogstash_0.png)\n\n![이미지2](/assets/img/2024-05-23-HowtotestaRubyfilterinLogstash_1.png)\n\n테스트가 실패한 경우, 테스트 케이스 이름 및 필요한 모든 정보(매개변수, 입력 이벤트, 결과)를 명확히 확인할 수 있습니다. 최소한 하나의 테스트가 실패하면 연결된 파이프라인은 시작되지 않습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-HowtotestaRubyfilterinLogstash_0.png"},"coverImage":"/assets/img/2024-05-23-HowtotestaRubyfilterinLogstash_0.png","tag":["Tech"],"readingTime":10},{"title":"성능 평가와 프로파일링","description":"","date":"2024-05-23 12:46","slug":"2024-05-23-BenchmarkingandProfiling","content":"\n이 안내서는 모든 언어와 프레임워크에 적용됩니다. 일부 제안 사항은 루비에 맞게 조정되어 있습니다.\n\n# 벤치마크\n\n벤치마크는 정의된 프로시저에 의해 사용되는 자원 또는 시간의 합성 측정입니다.\n\n합성 측정 - 프로덕션에서 발생하는 조건을 완벽하게 재현하지는 않습니다. 대략적인 추정 값을 제공하는 것이 목적입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자원 또는 시간, 절차 - 우리는 메서드가 실행되는 데 얼마나 오랜 시간이 걸렸는지, 초당 몇 번의 반복이 실행되었는지 또는 얼마나 많은 객체가 생성되었는지와 같은 정보를 얻을 수 있습니다 - 이 모든 것은 메서드나 컨트롤러 액션과 같은 정의된 절차에 의해 가능합니다.\n\n다른 범위 수준을 가진 3 가지 종류의 벤치마킹 -\n\n- Micro - 이러한 벤치마크는 작은 기능을 테스트합니다. 많은 반복이 실행됩니다. 예: 코드 한 줄이 100만 번 실행됩니다. 이 코드 라인은 자체적으로 더 많은 메서드를 호출할 수 있습니다. 이 개별 LOC에 대한 최적화는 LOC가 많은 곳에서 호출되지 않는 경우에는 유용하지 않을 수 있습니다.\n- Macro - 이러한 벤치마크는 비교적 큰 기능을 테스트합니다. 상대적으로 적은 반복이 실행됩니다. 예: 컨트롤러 액션 또는 서비스 객체가 수천 번 실행됩니다. 이곳에서의 최적화는 유용할 수 있습니다. 결과는 벤치마킹 결과에서 확인할 수 있습니다.\n- App - 이러한 벤치마크는 훨씬 큰 기능을 테스트합니다. 매우 적은 반복이 실행됩니다. 예: 전체 기능이 수백 번 실행됩니다. 이곳에서의 최적화는 유용할 수 있습니다. 그러나 최적화의 효과는 많은 코드를 실행하므로 벤치마킹 결과에서는 보이지 않을 수 있습니다.\n\n루비 세계의 몇 가지 벤치마킹 젬은 - benchmark-ips와 benchmark-ipsa가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 벤치마킹 매개변수 —\n\n- 워밍업 시간 — 벤치마킹 이전에 데이터를로드하고 캐시를 채우면서 코드가 안정 상태에 도달하는 데 필요합니다. 안정적인 결과를 얻기 위해 코드를 충분히 워밍업하십시오. 예를 들어, CRuby는 JRuby나 TruffleRuby보다 훨씬 빠르게 안정 상태에 도달합니다. 따라서 후자의 경우 더 긴 워밍업 시간이 필요할 수 있습니다.\n- 벤치마킹 시간 — 실제 벤치마킹이 실행될 시간을 결정합니다. 분산을 낮추기 위해 충분히 길어야 합니다. 분산이 높은 경우 벤치마킹 시간을 늘리면 도움이 될 수 있습니다.\n\n팁: 실제로 중요한 것만 측정하도록 합니다. 벤치마킹 중인 코드를 정확히 알고 있는지 확인하십시오. 벤치마킹 블록 외에 필요하지 않은 코드는 모두 제외하도록 합니다.\n\n팁: 쓴 모든 벤치마크를 /benchmarks 폴더와 같은 위치에 저장하여 손쉽게 접근할 수 있도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 프로파일링\n\n프로파일은 프로시저의 여러 서브루틴에 의해 사용된 자원의 상대적 소비를 **단계별로** 기록한 것입니다.\n\n단계별 계산 - 초당 몇 번의 반복이 실행되었는지와 같이 누적 또는 단일 값 대신 우리는 많은 정보를 얻습니다. 예를 들어, 우리는 1번째 줄에서 10%의 시간을 보내고 2번째 줄에서 5%를 사용했으며, 이와 같은 방식으로 매우 세부적인 수준에서 정보를 얻을 수 있습니다.\n\n상대적 소비 - 100밀리초의 시간을 소비했다는 벤치마크가 하는 것처럼 절대 숫자를 제공하지 않습니다. 대신 백분율과 같은 상대적 측정치를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리소스 — 우리는 메모리나 시간과 같은 다양한 리소스를 프로파일링할 수 있어요.\n\n서브루틴 — 프로시저의 서브루틴을 프로파일링할 거에요. 이는 Ruby와 같은 프로그래밍 언어의 메서드를 가리킬 수 있어요. 예를 들어 프로시저 내 각 메서드에 얼마나 많은 시간이 소요되었는지를 확인할 수 있어요.\n\n프로파일링 결과 — \"무엇이 느린가요?\". 이 결과는 상세하게 제공하려고 애쓰지만, 어플리케이션의 성능을 저하시키기 때문에 상용 프로파일러인 New relic, Scout, Skylight과 같은 제품은 앱에 큰 영향을 주지 않으면서도 충분한 데이터를 제공하기 위해 절충할 거에요.\n\n깊은 결과를 얻으려면, 프로파일링 환경이 거의 제품과 동일하게 작동해야 해요. 특히 데이터 양을 고려할 때 말이죠. 여기서 깊은 프로파일링을 활성화할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발 환경에서 프로덕션과 유사한 동작을 얻기 위해 몇 가지 설정이 있습니다. Ruby on Rails에서 다음과 같은 조건문 뒤에 이 설정들을 넣는 것이 좋습니다. 예를 들어, RAILS_ENV가 \"PROFILE\"인 경우에만 이 변경 사항을 적용하십시오.\n\n![이미지](/assets/img/2024-05-23-BenchmarkingandProfiling_0.png)\n\n거의 모든 프로파일러에서 시간을 측정하는 두 가지 모드가 있습니다 —\n\n- CPU 시간: 이 모드는 CPU 사이클을 기준으로 시간을 측정합니다. 이는 IO 대기 및 슬립과 같은 작업이 해당 프로세스의 CPU 사이클 동안 발생했기 때문에 이러한 프로필에 나타나지 않습니다.\n- WALL 시간: 이는 시계를 기준으로 합니다. 따라서 IO 대기 및 슬립과 같은 모든 것이 나타납니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용 사례에 따라 때로는 CPU 시간을 사용하는 것이 좋을 수도 있고 때로는 WALL 시간을 사용하는 것이 좋을 수도 있습니다.\n\n프로파일러에는 두 가지 종류가 있습니다 —\n\n- 통계적 — 사용 가능한 스택 프레임의 일부를 샘플링합니다. 따라서 프로세스 실행을 X 밀리초마다 중단하여 스택 프레임의 스냅샷을 찍은 다음 프로세스를 계속 실행합니다. 그런 다음 그러한 스택 프레임이 프로파일로 집계됩니다.\n- 추적 — 언어에 훅을 걸어두는 방식입니다. 메소드를 호출할 때마다 관련 카운터를 증가시키고 해당 메소드가 실행되었다는 사실을 기록합니다.\n\n그래서 추적 프로파일러는 발생하는 모든 일을 기록할 수 있습니다. 반면에 통계적 프로파일러는 전체 데이터 중 1% 정도만 처리할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비 세계에서 주로 사용하는 주요 프로파일러는 2가지가 있어요 —\n\n- Stackprof — 이것은 통계적입니다.\n- Ruby-prof — 이것은 추적적입니다.\n\nmemory_profiler를 사용하여 루비 세계에서 메모리 프로파일을 작성하세요.\n\n루비 세계에서 memory_profiler와 stackprof와 상호 작용하는 가장 좋은 방법은 rack-mini-profiler를 사용하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n얼마나 좋게 측정하더라도 결국 하루 끝에는 모든 프로덕션 시나리오를 비프로덕션에서 완벽히 재현할 수는 없습니다.\n\n프로덕션 환경에서 성능을 측정하는 방법을 따라보세요 —\n\n1. 프로덕션 지표 읽기 — 예를 들어, 조사를 통해 검색이 너무 느린 것을 발견했다고 가정해봅시다.\n2. 핫스팟 찾기 위한 프로파일링 — 어디에서 문제가 발생하는지 정확하게 찾기 위해 프로파일링을 수행하세요. 어떤 작업이 가장 느린지 찾아보세요. 예를 들어, 검색 메서드가 가장 느리다고 가정해봅시다.\n3. 벤치마크 생성 — 느린 부분을 찾아 해당 부분에 대한 벤치마크를 만들어보세요. 예를 들어, 어떤 것을 검색할 때 각 결과 라인을 렌더링하는 데 얼마나 걸리는지 파악해보세요.\n4. 반복 — 벤치마크를 수행하고 문제를 찾았다면, 해결책을 구현하는 것은 꽤 간단합니다. 가장 느린 부분을 개선하기 위해 반복 작업하고 향상을 확인하세요. 예를 들어, 이전에 초당 1000개의 결과를 렌더링했다면, 이제 솔루션을 구현한 후 10000개의 결과를 벤치마크할 수 있습니다.\n5. 배포 — 솔루션을 배포하세요.\n\n이 노트는 Nate Berkopec의 강연을 바탕으로 준비되었습니다. 이 강연을 시청하려면 여기를 클릭하세요 —\n","ogImage":{"url":"/assets/img/2024-05-23-BenchmarkingandProfiling_0.png"},"coverImage":"/assets/img/2024-05-23-BenchmarkingandProfiling_0.png","tag":["Tech"],"readingTime":6},{"title":"루비 온 레일즈에서 GRASP 원칙 이해하기","description":"","date":"2024-05-23 12:45","slug":"2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails","content":"\n![Understanding GRASP Principles in Ruby on Rails](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_0.png)\n\n소프트웨어 엔지니어링에서, GRASP (General Responsibility Assignment Software Patterns) 원칙은 시스템 내의 여러 구성 요소에 책임을 할당하는 데 도움이 되는 지침 세트입니다. 이러한 원칙은 유지 관리 가능하고 확장 가능하며 견고한 애플리케이션을 만드는 데 중요합니다. 인기 있는 웹 애플리케이션 프레임워크인 Ruby on Rails의 맥락에서 GRASP 원칙을 적용하면 코드의 품질과 구조를 크게 향상시킬 수 있습니다. 본문에서는 GRASP 원칙과 Ruby on Rails 개발에서의 적용에 대해 탐구합니다.\n\n## Information Expert\n\n원칙: 책임을 완수하기 위해 필요한 정보를 갖고있는 클래스에 책임을 할당합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레일즈에서: 레일즈 애플리케이션에서 모델은 일반적으로 정보 전문가입니다. 애플리케이션의 엔티티와 관련된 비즈니스 로직 및 데이터를 포함합니다. 예를 들어, 주문의 총 가격을 계산해야 한다면, 이 로직은 주문 모델에 있어야 합니다. 왜냐하면 주문 모델은 라인 아이템과 가격에 액세스할 수 있기 때문입니다.\n\n![이미지](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_1.png)\n\n## 생성자\n\n원칙: 클래스 인스턴스를 만드는 책임을 집계, 포함 또는 밀접하게 사용하는 클래스에 할당합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레일즈에서: 이 원칙은 종종 레일즈 컨트롤러와 모델이 상호 작용하는 방식에 반영됩니다. 예를 들어, 새로운 사용자를 만들 때 UsersController는 User 모델을 인스턴스화하는 역할을 담당할 것입니다.\n\n![이미지](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_2.png)\n\n## Controller\n\n원칙: 시스템 이벤트 처리 책임을 전반적인 시스템 또는 특정 시나리오를 반영하는 컨트롤러 클래스에 할당합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비온 레일스: 레일스의 MVC(Model-View-Controller) 아키텍처는 이 원칙을 내재적으로 지원합니다. 컨트롤러는 들어오는 HTTP 요청을 처리하고 모델과 상호 작용하여 뷰를 렌더링합니다. UsersController는 사용자 계정과 관련된 모든 작업을 처리할 것입니다.\n\n![이미지](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_3.png)\n\n## 낮은 결합도\n\n원칙: 클래스 간의 종속성을 줄여 시스템을 모듈식으로 만들고 유지보수하기 쉽게 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레일즈에서: 이 원칙은 서비스 객체, 관심사 또는 데코레이터를 사용하여 비즈니스 로직을 모델과 컨트롤러 외부에 캡슐화하여 복잡성을 줄일 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_4.png)\n\n## 높은 응집력\n\n원칙: 클래스가 하나의 명확히 정의된 목적을 가지고 있으며 그 책임이 밀접하게 관련되어 있음을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레일즈에서는 관례를 통해 높은 응집력을 장려합니다. 모델은 데이터 관련 로직에 집중해야 하고, 컨트롤러는 요청 처리 로직에 집중하며, 뷰는 표현 로직에 집중해야 합니다. 이 분리를 명확히 유지하면 유지보수성이 향상됩니다.\n\n![UnderstandingGRASPPrinciplesinRubyonRails_5](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_5.png)\n\n## 간접성\n\n원칙: 중간 객체에 책임을 할당하여 다른 구성 요소 또는 서비스 간의 중개를 수행합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레일즈에서 미들웨어, 옵저버 또는 서비스 객체를 사용하면 간접적인 레이어를 도입할 수 있습니다. 예를 들어 레일즈의 Active Job은 백그라운드 작업 처리를 위한 추상화를 제공합니다.\n\n![이미지](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_6.png)\n\n## 다형성\n\n원칙: 동작의 변화를 처리하기 위해 다형적 동작을 사용하여 시스템을 더 유연하고 확장 가능하게 만드세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레일즈에서: 다형성은 인터페이스나 추상 클래스를 사용하여 구현할 수 있습니다. 또한 레일즈는 다형성 연관을 지원하여 모델이 단일 연관을 사용하여 다른 모델 중 하나 이상에 속할 수 있게 합니다.\n\n![이미지](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_7.png)\n\n## 순수 패브릭\n\n원칙: 문제 도메인의 개념을 나타내지 않고 단지 높은 응집도와 낮은 결합도를 달성하기 위해 설계된 클래스를 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비온 레일즈에서는 서비스 객체가 순수한 패브릭 예제입니다. 이들은 모델이나 컨트롤러 내에 자연스럽게 들어 맞지 않는 복잡한 로직을 캡슐화합니다.\n\n![이미지](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_8.png)\n\n## 보호된 변형\n\n원칙: 원하는 요소를 캡슐화하여 변동 요소에 의한 다른 요소의 변화로부터 보호하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비온 레일즈에서는 스트래티지 패턴과 SOLID 원칙을 준수하여 GRASP 원칙과 중첩되는 디자인 패턴으로 이를 달성할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_9.png)\n\n# 결론\n\nGRASP 원칙은 소프트웨어 개발에 잘 근거한 디자인 결정을 내리기 위한 견고한 기반을 제공합니다. 루비온 레일즈 애플리케이션에 적용되면 이러한 원칙은 깔끔하고 조직적이며 유지보수 가능한 코드 기반을 유지하는 데 도움이 됩니다. GRASP 원칙을 준수함으로써, 레일즈 개발자는 기능적이고 확장 가능하며 이해하기 쉬운 애플리케이션을 구축할 수 있으며, 이는 궁극적으로 더 나은 소프트웨어 품질과 개발자 생산성으로 이어집니다.\n","ogImage":{"url":"/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_0.png"},"coverImage":"/assets/img/2024-05-23-UnderstandingGRASPPrinciplesinRubyonRails_0.png","tag":["Tech"],"readingTime":6},{"title":"Logstash에서 Ruby 코드를 공유하는 방법","description":"","date":"2024-05-23 12:44","slug":"2024-05-23-HowtoshareRubycodeinLogstash","content":"\n이전 기사에서는 루비 필터를 사용하여 문서를 비정규화하는 방법을 살펴보았습니다. 이 기사에서는 코드를 개선하고 필터간에 코드를 공유하는 방법을 보여드리겠습니다.\n\n## 이전 코드에 대해\n\n기억하시나요? 이전 코드는 다음과 같았습니다:\n\n```js\n# 'params'의 값은 로그스태시 구성에서 'script_params'로 전달된 해시의 값입니다.\ndef register(params)\n    @keep_original_event = params[\"keep_original_event\"]\nend\n\n# 필터 메서드는 이벤트를 받아들이고 이벤트 목록을 반환하여야 합니다.\n# 이벤트를 삭제하면 반환 배열에 포함되지 않습니다.\n# 새로운 이벤트를 만들려면 반환된 배열에 LogStash::Event의 새 인스턴스를 추가하기만 하면 됩니다.\ndef filter(event)\n\n    items = Array.new\n\n    # 원본 이벤트를 유지하도록 요청되었는지 확인\n    logger.debug('keep_original_event is :' + @keep_original_event.to_s)\n\n    if @keep_original_event.to_s == 'true'\n        event.set('[@metadata][_index]', 'prizes-original');\n        items.push event\n    end\n\n    # 상금 아이템 가져오기 (비정규화)\n    prizes = event.get(\"prize\");\n    if prizes.nil?\n        logger.warn(\"No prizes for event \" + event.to_s)\n        return items\n    end\n\n    # 복제된 기본 이벤트 생성\n    eventBase = event.clone();\n    eventBase.set('[@metadata][_index]', 'prizes-denormalized');\n    eventBase.remove(\"prize\");\n\n    # 각 상금 아이템별로 필요한 수정과 함께 이벤트 생성\n    prizes.each { |prize|\n        eventPrize = eventBase.clone();\n\n        # 각 상금 아이템 값을 상금 객체로 복사\n        prize.each { |key,value|\n            eventPrize.set(\"[prize][\" + key + \"]\", value)\n        }\n\n        items.push eventPrize\n    }\n\n    return items\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보시다시피, 우리에게는 매개변수를 설명하는 register 함수와 필터 기능을 구현하는 다른 함수가 2개뿐입니다. 그러나 기능 전체를 한 방법에 구현하는 것은 가독성, 유지 관리 가능성, 테스트 가능성 등 여러 가지 이유로 최선의 선택이 아닙니다.\n\n# 루비 코드 공유\n\n코드를 공유하는 첫 번째 방법은 다른 루비 파일에 일부 함수를 외부화하고 이러한 함수를 우리의 루비 필터에서 호출하는 것입니다.\n\n예를 들어, 우리는 일부 코드 조각을 간단한 함수로 외부화할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 원본 이벤트를 얻기 위한 함수(원하면 현재 이벤트를 유지하려면)\n- 이벤트로부터 상품 배열을 얻기 위한 함수\n- 각 상품을 위해 복제되는 이벤트 베이스를 구성하는 함수\n- 각 상품마다 이벤트를 생성하는 함수\n\n```js\n# 필요 시 원본 이벤트 유지\ndef getOriginalEvent(event)\n    logger.debug('keep_original_event is :' + @keep_original_event.to_s)\n    if @keep_original_event.to_s == 'true'\n        event.set('[@metadata][_index]', 'prizes-original');\n        return event;\n    end\n    return nil;\nend\n\n# 상품 항목 가져오기 (정규화)\ndef getPrizes(event)\n    prizes = event.get(\"prize\");\n    if prizes.nil?\n        logger.warn(\"No prizes for event \" + event.to_s)\n    end\n    return prizes;\nend\n\n# 복제된 베이스 이벤트 생성\ndef getEventBase(event)\n    eventBase = event.clone();\n    eventBase.set('[@metadata][_index]', 'prizes-denormalized');\n    eventBase.remove(\"prize\");\n    return eventBase;\nend\n\n# 필요한 수정을 수행한 현재 상품 항목 복제 이벤트 생성\ndef createEventForPrize(eventBase, prize)\n    eventPrize = eventBase.clone();\n    # 각 상품 항목 값을 상품 객체로 복사\n    prize.each { |key,value|\n        eventPrize.set(\"[prize][\" + key + \"]\", value)\n    }\n    return eventPrize;\nend\n```\n\n위 코드는 denormalized_by_prizes_utils.rb라는 이름의 파일에 작성되어 있습니다.\n\n그 이후에 필터의 주요 코드는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\nrequire './script/denormalized_by_prizes_utils.rb'\n\n// `params`의 값은 로그스태시 구성에서 `script_params`로 전달된 해시 값입니다.\nfunction register(params) {\n    @keep_original_event = params[\"keep_original_event\"];\n}\n\n// 필터 메서드는 이벤트를 수신하고 이벤트 목록을 반환해야 합니다.\n// 이벤트를 삭제하면 반환 배열에 포함되지 않습니다.\n// 새 이벤트를 생성하려면 반환된 배열에 LogStash::Event 인스턴스를 추가하면 됩니다.\nfunction filter(event) {\n\n    var items = [];\n\n    // 필요하다면 원본 이벤트를 유지합니다.\n    var originalEvent = getOriginalEvent(event);\n    if (!originalEvent) {\n        items.push(originalEvent);\n    }\n\n    // 상금 아이템(정규화) 가져오기\n    var prizes = getPrizes(event);\n    if (!prizes) {\n        return items;\n    }\n\n    // 클론 기본 이벤트 생성\n    var eventBase = getEventBase(event);\n\n    // 필요한 수정을 가진 상금 항목별 하나의 이벤트 생성\n    prizes.forEach(function(prize) {\n        items.push(createEventForPrize(eventBase, prize));\n    });\n\n    return items;\n}\n```\n\n기존 코드보다 훨씬 읽기 쉽고 필터 기능의 다른 단계를 직접 확인할 수 있습니다. 작은 함수로 잘 세분화되고 이해하기 쉽게 작성하여 유지보수성이 향상될 것입니다.\n\n하지만 경우에 따라 코드를 공유하는 여러 파일과 여러 파일이 필요한 필터를 갖고 있는 경우, 충돌이 발생하거나 유지보수성이 일부 저하될 수 있습니다.\n\n# 모듈 생성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 방법으로 코드를 공유하는 방법은 모듈을 만드는 것입니다. 이 모듈은 같은 기능적 범위의 코드 조각을 그룹화할 것입니다. 우리는 공유 함수를 사용하기 전에 모듈 이름을 지정해야 하기 때문에 충돌이 발생하지 않을 것입니다.\n\n이전에 공유된 함수는 다음과 같이 될 것입니다:\n\n```js\nmodule LogStash::Util::DenormalizationByPrizesHelper\n    include LogStash::Util::Loggable\n\n    # 원래 이벤트 유지\n    def self.getOriginalEvent(event, keepOriginalEvent)\n        logger.debug('keepOriginalEvent is :' + keepOriginalEvent.to_s)\n        if keepOriginalEvent.to_s == 'true'\n            event.set('[@metadata][_index]', 'prizes-original');\n            return event;\n        end\n        return nil;\n    end\n\n    # 상품 항목 가져오기 (정규화 해제)\n    def self.getPrizes(event)\n        prizes = event.get(\"prize\");\n        if prizes.nil?\n            logger.warn(\"No prizes for event \" + event.to_s)\n        end\n        return prizes;\n    end\n\n    # 복제 기본 이벤트 생성\n    def self.getEventBase(event)\n        eventBase = event.clone();\n        eventBase.set('[@metadata][_index]', 'prizes-denormalized');\n        eventBase.remove(\"prize\");\n        return eventBase;\n    end\n\n    # 필요한 수정으로 현재 상품 항목을 위한 복제 이벤트 생성\n    def self.createEventForPrize(eventBase, prize)\n        eventPrize = eventBase.clone();\n        # 각 상품 항목 값을 상품 객체로 복사\n        prize.each { |key,value|\n            eventPrize.set(\"[prize][\" + key + \"]\", value)\n        }\n        return eventPrize;\n    end\n\nend\n```\n\nlogger 인스턴스를 사용할 수 있도록 Loggable Util 모듈을 포함해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주요 코드는 다음과 같습니다:\n\n```js\nrequire './script/denormalized_by_prizes_utils.rb'\n\n# `params`의 값은 Logstash 구성에서 `script_params`에 전달된 해시의 값입니다.\ndef register(params)\n    @keep_original_event = params[\"keep_original_event\"]\nend\n\n# 필터 메서드는 이벤트를 받아서 이벤트 목록을 반환해야 합니다.\n# 이벤트를 삭제하는 것은 반환 배열에 포함시키지 않는 것을 의미합니다.\n# 새 이벤트를 생성하는 것은 반환 배열에 LogStash::Event의 인스턴스를 추가하는 것만 필요합니다.\ndef filter(event)\n\n    items = Array.new\n\n    # 요청이 있을 경우 원본 이벤트 보존\n    originalEvent = LogStash::Util::DenormalizationByPrizesHelper::getOriginalEvent(event, @keep_original_event);\n    if not originalEvent.nil?\n        items.push originalEvent\n    end\n\n    # 상품 항목 가져오기 (정규화)\n    prizes = LogStash::Util::DenormalizationByPrizesHelper::getPrizes(event);\n    if prizes.nil?\n        return items\n    end\n\n    # 복제된 기본 이벤트 생성\n    eventBase = LogStash::Util::DenormalizationByPrizesHelper::getEventBase(event);\n\n    # 필요한 수정을 가한 상품 항목별로 이벤트 생성\n    prizes.each { |prize|\n        items.push LogStash::Util::DenormalizationByPrizesHelper::createEventForPrize(eventBase, prize);\n    }\n\n    return items;\nend\n```\n\n주요 코드를 수정할 필요가 많지 않습니다. 함수 호출을 모듈 이름과 함께 접두사로 붙이면 됩니다. 따라서 필터 기능에 통합된 다른 모듈에 있는 여러 `getEventBase` 함수와 같은 함수들이 있을 경우 충돌 없이 사용할 수 있습니다. 명시적으로 각 경우에 사용할 모듈을 설정하고 가독성을 향상시키기 때문에 좋습니다.\n\n다음 글에서는 필터 코드를 테스트하는 방법에 대해 이야기할 것입니다...\n","ogImage":{"url":"/assets/img/2024-05-23-HowtoshareRubycodeinLogstash_0.png"},"coverImage":"/assets/img/2024-05-23-HowtoshareRubycodeinLogstash_0.png","tag":["Tech"],"readingTime":8},{"title":"자바 함수형 인터페이스를 사용하여 의존성을 역전하는 방법","description":"","date":"2024-05-23 12:43","slug":"2024-05-23-How-toUseJavaFunctionalInterfacestoInvertDependencies","content":"\n자바 프로젝트 내에서 의존성을 역전시키기 위해 자바 함수형 인터페이스를 사용해 본 적이 있나요? 이 기사에서는 Supplier, Consumer 및 Function 세 가지 주요 인터페이스를 활용하여 이를 수행하는 방법을 살펴볼 것입니다.\n\n![이미지](/assets/img/2024-05-23-How-toUseJavaFunctionalInterfacestoInvertDependencies_0.png)\n\n## Supplier\n\nSupplier 인터페이스는 입력 매개변수가 필요하지 않은 객체를 제공해야 할 때 사용됩니다. 다음은 Supplier 인터페이스입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\npublic interface Supplier<T> {\n   T get();\n}\n```\n\n이 인터페이스를 활용하는 필요성을 더 잘 이해하기 위해 코드 몇 줄을 확인해 봅시다.\n\n```java\npublic class Logger {\n   public void log(String message) {\n      if (isLogEnabled()) {\n         write(message);\n      }\n   }\n}\n\n// Logger 클래스 사용 예시\npublic class Controller {\n   @Inject Logger logger;\n\n   public void execute() {\n      logger.log(generateLogMessage());\n   }\n}\n```\n\n위 코드에서는 로깅이 활성화되어 있을 때 로그 메시지를 작성하는 Logger 클래스가 있습니다. Controller 클래스는 generateLogMessage 메서드의 결과를 전달하여 로거를 호출합니다. 지금까지는 모든 것이 잘 보입니다. 그러나 만약 generateLogMessage 메서드가 많은 처리를 필요로 하거나 상당한 리소스를 소비하며 로깅이 비활성화된 경우를 상상해보세요. 이러한 경우 유용한 리소스가 낭비되며 생성된 로그 메시지가 활용되지 않을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 문제의 해결책은 Logger 클래스에 Supplier를 전달하여 요청 시 메시지를 반환하고, 로거가 로그가 활성화된 경우에만 메서드를 호출하도록 하는 것입니다. 아래와 같이 구현할 수 있습니다:\n\n```js\npublic class Logger{\n   public void log(Supplier<String> messageSupplier){\n      if(isLogEnabled()){\n        write(messageSupplier.get());\n      }\n   }\n}\n\n// Logger 클래스 사용 예제\npublic class Controller{\n   @Inject Logger logger;\n\n   public void execute(){\n      logger.log(() -> generateLogMessage());\n   }\n}\n```\n\n이제 generateLogMessage 메서드는 Supplier의 get 메서드가 호출될 때에만 실행되며, 로그가 비활성화된 경우 자원을 절약할 수 있습니다. 또한 Supplier를 사용한 이러한 솔루션은 로깅을 위한 매우 복잡한 로직을 구현할 유연성을 제공하며 필요할 때에만 호출됨을 보장합니다.\n\n# 기능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFunction 인터페이스를 사용하면 매개변수를 받아 결과를 생성하는 함수를 정의할 수 있습니다. 아래는 Function 인터페이스입니다 (일부 기본 메서드는 생략됨):\n\n```js\npublic interface Function<T, R>{\n   R apply(T t);\n}\n```\n\nFunction 인터페이스를 탐색하기 시작하려면, 판매 주문에서 품목의 가격을 계산하는 책임을 지는 클래스를 살펴보겠습니다. 이 클래스는 제품, 수량 및 할인 (0에서 100까지 범위)과 같은 입력을 가져옵니다:\n\n```js\npublic class PriceCalculator{\n   public BigDecimal calculatePrice(Product product,\n                                    Integer quantity,\n                                    BigDecimal discount){\n     var grossPrice = product.getUnitPrice()\n                             .multiply(BigDecimal.valueOf(quantity));\n     var discountAmount = grossPrice.multiply(discount)\n                                    .divide(BigDecimal.valueOf(100));\n     return grossPrice.minus(discountAmount);\n   }\n}\n\n// 사용 예시\nvar result = priceCalculator(product, 10, BigDecimal.value(10));\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 클래스는 초기에 총 가격을 계산하고 할인을 적용한 후 총 가격에서 빼는 작업을 합니다. 이제 새로운 요구 사항을 고려해봅시다: 가격에 통화 변환을 수행해야 합니다.\n\n하나의 접근 방식은 이 클래스에 직접 통화 변환 로직을 추가하는 것일 수 있지만, 이는 버그를 도입할 수 있습니다. 더 견고한 해결책은 통화 변환을 처리하는 함수 매개변수를 추가하는 것입니다.\n\n```js\npublic class PriceCalculator{\n   public BigDecimal calculatePrice(\n                        Product product,\n                        Integer quantity,\n                        BigDecimal discount,\n                        Function<BigDecimal,BigDecimal> converterFunction){\n     var grossPrice = product.getUnitPrice()\n                             .multiply(BigDecimal.valueOf(quantity));\n     var discountAmount = grossPrice.multiply(discount)\n                                    .divide(BigDecimal.valueOf(100));\n     var netPrice = grossPrice.minus(discountAmount);\n     return converterFunction.apply(netPrice);\n   }\n}\n\n// Usage example\nvar result = priceCalculator(product,\n                             10,\n                             BigDecimal.value(10),\n                             netPrice -> netPrice.multiply(CURRENCY_RATE));\n```\n\n새로운 요구 사항의 추가로 인해 최소한의 영향을 받았고, 의존성을 성공적으로 역전시켰습니다. PriceCalculator 클래스는 더 이상 통화 변환을 처리할 필요가 없으며, 대신 제공된 함수를 호출하고 최종 결과를 반환합니다. 이 설계를 통해 PriceCalculator 클래스를 수정하지 않고도 어떤 통화로든 변환할 수 있게 되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가격 계산기 클래스를 변경하지 않고 이 요구 사항을 해결하는 다양한 방법이 있습니다. PriceCalculator를 호출하는 퍼사드로 작동하는 또 다른 클래스를 만들어 화폐 변환을 수행할 수 있습니다. 일반적으로 어떤 솔루션을 따를지는 프로젝트 결정입니다.\n\n# 소비자\n\nConsumer 인터페이스를 통해 매개변수를 받아 특정 작업을 수행하고 값을 반환하지 않는 함수를 정의할 수 있습니다. 다음은 Consumer 인터페이스입니다 (일부 기본 메서드는 생략됨):\n\n```js\npublic interface Consumer<T> {\n    void accept(T t);\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n소비자 인터페이스의 예제를 살펴보기 위해 이 클래스를 살펴봅시다. 여기에는 엔티티에 일부 정보를 설정한 후 데이터베이스에 저장하는 작업이 포함되어 있습니다:\n\n```java\npublic class EntitySaver{\n   public void create(Entity entity){\n      entity.setCreationDate(new Date());\n      database.insert(entity);\n   }\n}\n\n// 사용 예시\nentitySaver.create(entity);\n```\n\n이제 엔티티가 생성될 때 다른 클래스에 알림을 보내어야 하는 경우를 가정해 봅시다. 그러나 create 메서드 인터페이스를 수정할 수 없는 경우, 소비자 인터페이스를 사용하여 발행-구독 패턴을 구현할 수 있습니다. 다음은 이를 어떻게 달성할 수 있는지에 대한 예시입니다:\n\n```java\npublic class EntitySaver{\n   private List<Consumer<Entity>> consumerList = new ArrayList<>();\n\n   public void register(Consumer<Entity> consumer){\n      consumerList.add(consumer);\n   }\n\n   public void create(Entity entity){\n      entity.setCreationDate(new Date());\n      database.insert(entity);\n      consumerList.forEach(consumer -> consumer.accept(entity));\n   }\n}\n\n// 사용 예시\nentitySaver.register(entity -> log.info(entity));\nentitySaver.register(entity -> mailerService.notifyUser(entity));\nentitySaver.create(entity);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 발행-구독 패턴의 구현에서는 Consumer 인터페이스를 활용합니다. EntitySaver 클래스는 이제 Consumer 리스트를 유지하고 등록 메서드를 포함하여 소비자를이 목록에 추가합니다. create 메서드의 인터페이스는 변경되지 않았지만, 만들어진 엔티티를 '소비'하기위한 한 줄의 코드를 도입했습니다.\n\n# 결론\n\nJava 기능 인터페이스는 많은 년 전에 소개되었으며, Java에서 개발을하던 방식에 큰 영향을 미쳤습니다. 우리는 이를 람다 함수로 사용할 수 있지만 의존성을 뒤집고 코드를 더 깔끔하게 만드는 데 사용할 수도 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-How-toUseJavaFunctionalInterfacestoInvertDependencies_0.png"},"coverImage":"/assets/img/2024-05-23-How-toUseJavaFunctionalInterfacestoInvertDependencies_0.png","tag":["Tech"],"readingTime":8},{"title":"제 1장 반응형 프로그래밍 소개","description":"","date":"2024-05-23 12:42","slug":"2024-05-23-Chapter1IntroductiontoReactiveProgramming","content":"\n![Chapter 1 Introduction to Reactive Programming](/assets/img/2024-05-23-Chapter1IntroductiontoReactiveProgramming_0.png)\n\nIn the fast-paced world of software development, building applications that are not only responsive but also scalable is crucial. Traditional programming paradigms often struggle to keep up with the demands of modern applications, where users expect real-time responsiveness and seamless user experiences. Introducing reactive programming, a paradigm shift that promises to revolutionize the way we build software.\n\n## Understanding Reactive Programming\n\nReactive programming is not just a buzzword; it’s a fundamental shift in how we approach software development. At its core, reactive programming is about building asynchronous, event-driven, and non-blocking applications. But what exactly does that mean?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에서 설명을 해보겠습니다:\n\n## 비동기적이고 논블로킹\n\n전통적인 프로그래밍에서 작업은 순차적으로 실행되어 이전 작업이 완료될 때까지 기다립니다. 이러한 방식은 병목 현상과 성능 저하를 야기할 수 있으며, 특히 높은 동시성을 필요로 하는 애플리케이션에서 문제가 될 수 있습니다.\n\n한편, 반응형 프로그래밍은 작업을 비동기적으로 실행할 수 있도록 해주어 이전 작업이 완료될 때까지 기다릴 필요가 없다는 의미입니다. 이러한 비동기적인 특성은 쓰레드를 차단하지 않고 대량의 동시 요청을 처리할 수 있게 해주어 자원 활용 및 성능을 향상시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이벤트 주도 아키텍처\n\n반응형 시스템에서 구성 요소는 이벤트를 발생시키고 반응함으로써 통신합니다. 이벤트는 사용자 입력부터 데이터 변경 또는 시스템 알림까지 무엇이든 될 수 있습니다. 이 이벤트 주도 아키텍처를 통해 느슨하게 결합되고 매우 확장 가능한 시스템이 가능하며, 구성 요소는 실시간으로 변경에 반응할 수 있습니다.\n\n## 반응형 애플리케이션\n\n반응형 프로그래밍의 주요 목표 중 하나는 사용자 상호작용 및 외부 이벤트에 반응하는 애플리케이션을 구축하는 것입니다. 비동기적으로 작업을 처리하고 신속하게 이벤트에 반응함으로써, 반응형 애플리케이션은 심한 부하 하에서도 원활하고 상호작용적인 사용자 경험을 제공할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 반응형 스트림\n\n반응형 프로그래밍은 종종 비동기적으로 처리되며 반응적으로 처리되는 데이터 항목의 시퀀스인 반응형 스트림 개념에 의존합니다. 반응형 스트림은 백프레셔(backpressure)를 처리하기 위한 메커니즘을 제공하며, 소비자가 생산자로부터 데이터를 소비하는 속도를 제어하여 과부하와 리소스 고갈을 방지합니다.\n\n# 반응형 프로그래밍의 장점\n\n이제 반응형 프로그래밍의 기본 개념을 이해했으므로, 이에 대한 주요 이점을 몇 가지 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 확장성: 반응형 프로그래밍은 비동기적이고 이벤트 주도적인 특성 덕분에 응용 프로그램이 손쉽게 확장될 수 있습니다.\n- 반응성: 반응형 응용 프로그램은 실시간 피드백과 원할한 경험을 제공하여 사용자에게 높은 반응성을 제공합니다.\n- 탄력성: 비동기적이며 논블로킹 I/O를 채택함으로써, 반응형 응용 프로그램은 장애에 대해 견고하고 에러를 우아하게 처리할 수 있습니다.\n\n# 반응형 프로그래밍의 단점\n\n모든 해결책에는 고유의 도전 과제가 있고, 반응형 프로그래밍 또한 예외는 아닙니다. 이와 함께 따르는 주요한 단점들을 살펴보겠습니다:\n\n- 학습 곡선: 비동기적 프로그래밍 개념을 배우는 것은 강압적 프로그래밍에 익숙한 개발자에게 놀라울 수 있습니다. 비동기적 및 논블로킹 성질을 반응형 시스템에서 파악하는 데 시간과 노력이 필요합니다.\n- 복잡성: 반응형 프로그래밍을 구현하면 코드베이스에 복잡성을 도입할 수 있습니다. 개발자는 비동기식 연산을 이해하고 반응형 스트림을 효과적으로 관리해야 합니다.\n- 디버깅 과제: 비동기적이고 이벤트 주도적인 코드를 디버깅하는 것은 동기화된 코드와 비교해 고유의 도전 과제를 제기합니다. 데이터 흐름을 추적하고 동시성 문제를 진단하기 위해 전문 기술이 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nReactive 프로그래밍은 단순히 흘러가는 유행이 아니라 소프트웨어를 구축하는 방식에서 패러다임 변화이며, 오랫동안 유지될 것으로 예상됩니다. 이것이 가지고 있는 도전에도 불구하고, reactive 프로그래밍의 장점은 특히 오늘날 매우 동시성이 높은 응용프로그램 환경에서 그 단점을 능가하는 경우가 많습니다. 비동기적이고 이벤트 주도적인 아키텍처를 채택함으로써, 개발자들은 그 어느 때보다도 더 민첩하고 확장 가능하며 견고한 응용프로그램을 만들 수 있습니다.\n\n이 블로그 포스트에서는 reactive 프로그래밍의 한 부분에 불과합니다. Reactive 스트림부터 고급 오류 처리 전략까지 더 탐구해야 할 부분이 많이 남아 있습니다. 하지만 이 소개가 reactive 프로그래밍에 대해 더 탐구하고 싶게 만들었으면 좋겠습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-Chapter1IntroductiontoReactiveProgramming_0.png"},"coverImage":"/assets/img/2024-05-23-Chapter1IntroductiontoReactiveProgramming_0.png","tag":["Tech"],"readingTime":5},{"title":"자바에서 엔티티를 DTO로 매핑하고 그 반대로하기","description":"","date":"2024-05-23 12:41","slug":"2024-05-23-MappingEntitiestoDTOsandviceversainJava","content":"\n![Mapping entities to DTOs in Java](/assets/img/2024-05-23-MappingEntitiestoDTOsandviceversainJava_0.png)\n\nIn Java, entities and DTOs are two different types of classes often used together. Entities are used to represent data in the database, while DTOs are used to represent data that is sent to or received from a client.\n\nTo map data from an entity to a DTO, you need to define a mapping between the attributes of the two classes. This can be done manually or automatically.\n\n## Manual mapping\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수동 매핑은 엔티티를 DTO로 매핑하는 가장 간단한 방법입니다. 이 접근 방식에서는 엔티티의 속성에서 DTO의 속성으로 값을 복사하는 코드를 작성합니다.\n\n예를 들어, 다음 코드는 Customer 엔티티의 속성을 CustomerDTO의 속성에 매핑합니다:\n\n```js\npublic CustomerDto toDto(Customer customer) {\n  CustomerDto dto = new CustomerDto();\n  dto.setName(customer.getName());\n  dto.setCpf(customer.getCpf());\n  dto.setDateOfBirth(customer.getDateOfBirth());\n  return dto;\n}\n```\n\n이 방법은 간단하고 유연하지만, 특히 복잡한 엔티티나 많은 매핑이 있는 경우에는 반복적이고 오류가 발생할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자동 매핑\n\n자동 매핑은 엔티티를 DTO로 매핑하는 더 효율적이고 신뢰할 수 있는 방법입니다. 이 방법을 사용하면 프레임워크나 라이브러리를 사용하여 매핑 코드를 자동으로 생성합니다.\n\n자동 매핑을 위한 인기 있는 라이브러리 중 하나는 MapStruct입니다. MapStruct(https://mapstruct.org/)는 도메인별 언어(Domain-Specific Language, DSL)를 사용하여 매핑 규칙을 정의합니다.\n\n예를 들어, 다음 코드는 Customer 엔티티의 속성을 CustomerDTO의 속성에 매핑하는 매핑 규칙을 정의합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n@Mapper\npublic interface CustomerMapper {\n\n  CustomerDto toDto(Customer customer);\n\n}\n```\n\n위 코드는 Customer 엔티티를 입력으로 받아 CustomerDTO를 출력으로 반환하는 toDto() 메서드를 정의합니다. MapStruct는 이 두 클래스의 속성 간 매핑을 결정하기 위해 메서드의 이름을 사용합니다.\n\nMapStruct는 DTO에서 엔티티로 값들을 매핑하는 데에도 사용할 수 있습니다. 예를 들어, 다음 코드는 CustomerDTO의 속성들을 Customer의 속성들과 매핑하기 위한 매핑 규칙을 정의합니다:\n\n```js\n@Mapper\npublic interface CustomerMapper {\n\n  Customer fromDto(CustomerDto dto);\n\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nModelMapper라고 하는 강력한 라이브러리도 있어요. 이 라이브러리는 객체 매핑 프로세스를 간단하게 해주며 매핑 동작을 사용자 정의하는 데 많은 유연성을 제공해요.\n\nJava 프로젝트에서 ModelMapper를 사용하려면 프로젝트에 ModelMapper 라이브러리를 추가해야 해요. 만약 Maven을 사용 중이라면 다음 종속성을 프로젝트의 pom.xml 파일에 추가하세요:\n\n```js\n<dependency>\n  <groupId>org.modelmapper</groupId>\n  <artifactId>modelmapper</artifactId>\n  <version>2.4.2</version>\n</dependency>\n```\n\n만약 Gradle을 사용 중이라면 build.gradle 파일에 다음을 추가하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nimplementation 'org.modelmapper:modelmapper:2.4.2'\n\n프로젝트에 ModelMapper 라이브러리를 추가한 후, 서로 다른 구조를 갖는 두 개의 객체 간에 매핑을 시작할 수 있습니다.\n\n예를 들어, 서로 다른 구조를 갖는 두 개의 객체가 있고, 이들 사이의 데이터를 매핑하려고 한다고 가정해봅시다. 아래는 예시입니다:\n\n```java\npublic class User {\n    private String name;\n    private int age;\n\n    // 생성자, 게터, 세터 메서드\n}\n\npublic class UserDTO {\n    private String fullName;\n    private int userAge;\n\n    // 생성자, 게터, 세터 메서드\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        User user = new User(\"John\", 30);\n        ModelMapper modelMapper = new ModelMapper();\n        UserDTO userDTO = modelMapper.map(user, UserDTO.class);\n        System.out.println(userDTO.getFullName()); // 출력: John\n        System.out.println(userDTO.getUserAge()); // 출력: 30\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 예에서는 User 및 UserDTO라는 두 개의 다른 구조를 갖는 두 개의 객체가 있습니다. User 객체에는 이름(name)과 나이(age) 필드가 있고, UserDTO 객체에는 풀 네임(fullName)과 사용자 나이(userAge) 필드가 있습니다. User 객체를 UserDTO로 매핑하기 위해 ModelMapper 인스턴스를 사용합니다. map() 메서드는 소스 객체와 대상 객체 클래스 두 가지 인수를 사용합니다.\n\nmain 메서드를 실행하면 출력으로 John과 30이 나오는데, 이는 매핑이 성공적으로 수행되었음을 나타냅니다.\n\nModelMapper를 사용하고 사용자화하는 방법에 대한 자세한 안내를 원하시면 다음 기사를 참고하십시오: [링크](http://bit.ly/4b4b5sz)\n\n# 따라서, 어떤 접근 방식을 선택해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n엔티티를 DTO로 매핑하는 가장 좋은 방법은 여러 요소에 따라 다릅니다. 일반적으로, 간단한 클래스나 매핑이 적은 경우 수동 매핑이 좋은 선택이 됩니다. 복잡한 클래스나 많은 매핑이 필요한 경우 자동 매핑이 좋은 선택입니다.\n\n다음은 접근 방식을 선택할 때 고려해야 할 사항입니다:\n\n- 관련된 클래스의 복잡성: 많은 속성을 가진 복잡한 클래스는 수동 매핑이 반복적이고 오류를 발생하기 쉽게 만들 수 있습니다. 이러한 클래스에 대해 자동 매핑이 좋은 선택일 수 있습니다.\n- 필요한 매핑의 양: 많은 매핑이 필요한 클래스는 수동 매핑을 유지하기 어렵게 만들 수 있습니다. 이러한 클래스에 대해 자동 매핑이 좋은 선택일 수 있습니다.\n- 사용자 정의 필요성: 수동 매핑을 통해 필요에 맞게 매핑을 사용자 정의할 수 있습니다. 자동 매핑은 더 제한적일 수 있습니다.\n\n최종적으로, 엔티티를 DTO로 매핑하는 가장 좋은 방법은 애플리케이션의 특정 요구사항을 충족시키는 방법입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 추가 고려 사항\n\n위에서 언급된 요소들 외에도, 엔티티들을 DTO에 매핑할 때 고려해야 할 몇 가지 사항이 있습니다:\n\n- 데이터 유형: 두 클래스의 속성들의 데이터 유형이 호환되는지 확인하세요.\n- Null 값: Null 값을 어떻게 처리할지 고려해보세요.\n- 컬렉션: 두 클래스 중 하나가 속성의 컬렉션을 포함하고 있다면, 컬렉션 내 각 요소에 대한 매핑을 정의해야 합니다.\n\n이러한 사항들을 따르면, 매핑 코드가 정확하고 효율적임을 보장할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\nMapStruct와 ModelMapper는 Java 프로젝트에서 엔티티를 DTO로 매핑하거나 그 반대로 하는 데 편리하고 효율적인 솔루션을 제공합니다. 이러한 라이브러리를 도입함으로써 개발자는 보일러플레이트 코드를 크게 줄이고 코드 유지 보수성을 향상시키며 타입 안정성을 보장할 수 있습니다. MapStruct 또는 ModelMapper를 프로젝트에 통합하면 매핑 프로세스를 간소화하여 견고하고 확장 가능한 애플리케이션을 구축하는 데 집중할 수 있습니다.\n\n즐거운 코딩 ;)\n\n아래 기사들도 참고해보세요\n","ogImage":{"url":"/assets/img/2024-05-23-MappingEntitiestoDTOsandviceversainJava_0.png"},"coverImage":"/assets/img/2024-05-23-MappingEntitiestoDTOsandviceversainJava_0.png","tag":["Tech"],"readingTime":7},{"title":"자바 스레드 로컬Thread Locals은 어떻게 동작하나요","description":"","date":"2024-05-23 12:39","slug":"2024-05-23-HowdoJavaThreadLocalswork","content":"\n<img src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png\" />\n\n자바에서 쓰레드 로컬(Thread Locals)은 전체 쓰레드 범위를 가지는 변수입니다. 이 말은 쓰레드 어디서든지 이러한 변수를 설정하고, 동일한 쓰레드에서는 어디서든지 액세스할 수 있다는 것을 의미합니다. 한 쓰레드에서 설정된 값은 다른 쓰레드에서 접근할 수 없습니다.\n\n자바 ThreadLocal 클래스에는 두 가지 유형이 있음을 알아야 합니다 — ThreadLocal 및 InheritableThreadLocal. 두 클래스 간의 차이를 살펴봅시다.\n\n# ThreadLocal 클래스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 쓰레드 로컬 변수가 선언된 예시입니다. user 변수는 User 타입(Class 또는 Interface)의 변수를 보유하는 ThreadLocal 변수입니다. 여기서 user 변수가 public 및 static으로 선언되어 어디서든 코드 내에서 접근할 수 있도록 설정되었습니다.\n\n```js\n// Declare a Thread Local Variable user\npublic static final ThreadLocal<User> user\n                     = new ThreadLocal<>();\n```\n\n아래는 쓰레드를 위해 user를 설정하고 가져오는 방법입니다. 예시에서는 'bob'으로 설정된 User 객체에 user 변수를 설정하고, 동일한 쓰레드 내에서 get() 메소드를 호출하면 User 'bob'이 검색됩니다.\n\n```js\n// Sets the calling thread’s value for user\nuser.set(new User(\"bob\"));\n\n// Gets the calling thread’s value for user\nUser requestUser = user.get();\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용자 변수가 코드베이스 전체에서 접근 가능하더라도 set(..) 메서드는 전달된 User 객체가 \"호출\" 스레드와 연관되도록 합니다. get() 메서드는 또한 \"호출\" 스레드와 연관된 User 객체를 검색하며, 다른 스레드에서 get() 메서드를 호출하더라도 bob이 아니라 다른 사용자(또는 null)를 검색하지 않습니다. 각 Java 스레드는 해당 스레드에 설정된 모든 스레드 로컬을 포함하는 ThreadLocal Map과 연결됩니다.\n\n만약 아무것도 설정되지 않은 경우 get() 메서드를 호출하면 어떻게 될까요? 이 메서드는 단순히 null을 반환합니다.\n\n그러나 람다 공급자로 초기 User 객체를 반환하는 Thread Local 객체를 생성할 수 있습니다. 아래 예제는 'anonymous'라는 User를 반환하는 공급자를 보여줍니다. 따라서 값이 설정되지 않은 ThreadLocal에 get() 메서드를 호출하면 이전에 값을 설정하지 않았을 때 공급자의 get() 메서드가 호출되며 사용자의 초기 값으로 설정됩니다.\n\n```js\n// 공급자와 함께 Thread Local 변수 user를 선언\npublic static ThreadLocal<User> user\n          = ThreadLocal.withInitial(\n                () -> new User(\"anonymous\"))\n\n// 'Anonymous'를 반환\nUser requestUser = user.get();\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음과 같이 remove() 메서드를 호출하여 이전에 설정된 값을 제거할 수도 있습니다.\n\n```js\n// 호출 스레드의 사용자 값 제거\nuser.remove();\n```\n\n이 방법은 기본적으로 스레드와 관련된 User 객체를 제거합니다. 더 중요한 것은 이 작업으로 다른 스레드에는 영향을 미치지 않는다는 점입니다.\n\n스레드 로컬을 다이어그램 형식으로 시각화한다면(저는 이것을 좋아합니다), 다음과 같이 보일 것입니다. 두 스레드의 사용자 변수가 서로 다른 User 객체를 가리키는 것을 알 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_1.png\" />\n\n# ThreadLocal 및 자식 스레드\n\n이전 섹션까지의 논의는 주로 한 개의 Java 스레드와 관련되어 있었습니다. 만약 Java 스레드가 새로운 자식 스레드를 시작한다면 어떻게 될까요? 자식 스레드가 부모에서 정의된 Thread Local 변수에 자동으로 액세스할 수 있을까요?\n\n답은 \"아니요\"입니다! 자식 스레드는 부모의 Thread Local에 액세스할 수 없으며 이에 대한 매우 좋은 이유가 있습니다. 만약 액세스 가능하다면, Thread Local 변수에 저장된 객체는 스레드 안전하게 작성되어야 할 것이며 이렇게 되면 여러 스레드가 동일한 사용자 객체에 액세스할 수 있을 것입니다. 이는 Java 엔지니어들에 의한 좋은 기본 디자인 결정입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 때로는 그런 액세스가 유용할 때가 있습니다. 많은 사용자가 애플리케이션에 액세스하는 웹 애플리케이션과 같은 시나리오를 상상해보십시오. 요청 처리 중 사용자와 연결된 단일 Java 스레드가 있으며, 이 스레드의 Thread Local 객체에 사용자 객체가 저장되어 있다고 상상할 수 있습니다(이는 많은 응용 프로그램 서버 및 Spring Boot와 같은 프레임워크에서 수행됩니다). 그러나 생성된 자식 스레드도이 사용자 정보에 액세스하길 원할 수 있습니다.\n\n이 시나리오에 대해 Java는 InheritableThreadLocal이라는 다른 클래스를 제공합니다.\n\n# InheritableThreadLocal 클래스\n\n이 클래스를 사용하는 구문은 사실상 ThreadLocal 클래스와 거의 동일합니다. 아래 예제에서는 InheritableThreadLocal 클래스에 대한 해당 메서드를 보여줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n// 상속 가능한 쓰레드 로컬 변수 user를 선언합니다\npublic static final InheritableThreadLocal<User> user = new InheritableThreadLocal<>();\n\n// 호출 중인 쓰레드의 user 값을 설정합니다\nuser.set(new User(\"bob\"));\n\n// 호출 중인 쓰레드의 user 값을 가져옵니다\nUser requestUser = user.get();\n\n// 호출 중인 쓰레드의 user 값을 제거합니다\nuser.remove();\n```\n\n쓰레드 로컬 맵과 마찬가지로, 모든 쓰레드에는 상속 가능한 쓰레드 로컬 변수를 위한 맵이 있습니다. 여기서 큰 차이점은 자식 쓰레드가 생성될 때, 자식의 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된다는 것입니다. 따라서, 상속 가능한 쓰레드 로컬 변수는 자식 쓰레드에서도 접근할 수 있습니다.\n\n만약 상속 가능한 쓰레드 로컬 변수를 다이어그램 형태로 시각화한다면, 다음과 같이 보일 것입니다. 상속 가능한 쓰레드 로컬 맵이 부모로부터 복제된 것을 볼 수 있습니다.\n\n<img src=\"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 함정에 유의하세요!\n\n위 다이어그램에서 명확히 볼 수 있듯이, 상속 가능한 쓰레드 로컬 변수의 장점은 단점이 될 수도 있습니다. 기본적으로, 자식 쓰레드가 생성될 때 상속 가능한 쓰레드 로컬 맵도 복제됩니다. 그러나 부모와 자식 쓰레드에서 동일한 \"User\" 객체를 가리킨다는 것을 알 수 있습니다.\n\n이것은 User 객체가 여러 쓰레드에서 접근될 수 있고 스레드 안전하게 작성되어야 한다는 것을 의미합니다. 다시 말하면 - 단순한 ThreadLocal 클래스와 관련된 스레드 안전성이 InheritableThreadLocal 클래스를 사용할 때는 손실됩니다. 이것은 여러분의 디자인에 완벽히 적합할 수 있습니다 - 이에 문제는 없습니다.\n\n그러나 더 안전한 접근 방식이 있을 수 있습니다. InheritableThreadLocal을 생성할 때 다음과 같이 childValue(..) 메서드를 지정할 수 있습니다. 사실, 아래 예시에서는 초기값과 child 값도 지정합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\npublic static final InheritableThreadLocal<User> user\n                   = new InheritableThreadLocal<>() {\n\n   @Override\n   protected User initialValue() {\n      return new User(\"anonymous\");\n   }\n\n   @Override\n   protected User childValue(User parentValue) {\n      return new User(parentValue.getId());\n   }\n};\n```\n\n위 변경 사항을 통해 상속 가능한 스레드 로컬 맵이 복제될 때 자식에 연관된 값은 childValue(..) 메소드를 사용하여 부모 값이 전달되어 설정됩니다. 상속 가능한 스레드 로컬마다 새로운 객체가 생성되므로, User 객체가 부모 및 자식 스레드 간에 공유되지 않습니다. 이 변경으로 스레드 안전성으로 돌아가지만 User 객체에는 읽기 전용으로 액세스할 수 있게됩니다(사실상 복사본을 생성함).\n\n다시 말하지만, 다이어그램 형식으로 상속 가능한 스레드 로컬을 시각화하면, 이와 같이 보일 것입니다. 이제 부모와 자식 스레드의 사용자가 서로 다른 User 객체를 가리키는 것을 명확히 알 수 있습니다.\n\n![Java Thread Locals 동작 방식](/assets/img/2024-05-23-HowdoJavaThreadLocalswork_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자바 스레드 지역 변수에 대한 좋은 이해를 얻을 수 있기를 바랍니다.\n\n이 게시물이 도움이 되었다면 지원을 표시하기 위해 클로버 아이콘 👏을 몇 번 클릭해 주세요. 읽어 주셔서 감사합니다!\n","ogImage":{"url":"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png"},"coverImage":"/assets/img/2024-05-23-HowdoJavaThreadLocalswork_0.png","tag":["Tech"],"readingTime":8}],"page":"76","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}