{"pageProps":{"posts":[{"title":"안드로이드 주니어 개발자가 되는 법 초보자를 위한 가이드","description":"","date":"2024-06-22 22:38","slug":"2024-06-22-BecomingAndroidJuniorDeveloper","content":"\n안드로이드 앱 개발의 세계는 지속적으로 진화하고 있으며, 모바일 앱에 대한 수요가 계속 증가함에 따라 이 흥미로운 분야로 진입하기에 더 좋은 때는 없습니다. 안드로이드 주니어 개발자가 되기를 희망하는 경우, 여기에 여러분이 여정을 탐험하고 성공을 위해 스스로를 설정하는 데 도움이 되는 포괄적인 안내서가 있습니다.\n\n![BecomingAndroidJuniorDeveloper_0.png](/assets/img/2024-06-22-BecomingAndroidJuniorDeveloper_0.png)\n\n## 안드로이드 주니어 개발자로서 기대할 수 있는 것은?✍🏻\n\n안드로이드 주니어 개발자로서, 당신은 경험 많은 개발자들과 협력하여 아이디어를 현실로 만드는 데 중요한 역할을 맡을 것입니다. 여러분의 책임은 다음과 같을 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 깨끗하고 유지보수 가능한 코드를 작성하며 최상의 실천 방법과 코딩 규칙을 준수합니다.\n- XML 및 Android UI 프레임워크를 사용하여 UI 구성 요소를 구현합니다.\n- API를 소비하여 데이터를 가져와 애플리케이션에 통합합니다.\n- 응용 프로그램을 테스트하고 디버깅하여 올바로 작동하고 원활하게 작동하는지 확인합니다.\n- 팀원과 협력하여 전체 개발 프로세스에 기여합니다.\n\n## 안드로이드 주니어 개발자를 위한 필수 기술과 지식 📝\n\n안드로이드 주니어 개발자로서 뛰어나기 위해 다음 분야의 견고한 기초를 갖추어야 합니다:\n\n- 프로그래밍 기초: 변수, 데이터 유형, 연산자, 제어 흐름문 및 함수 등 프로그래밍의 핵심 개념 이해\n- Kotlin: 안드로이드 개발을 위한 주요 프로그래밍 언어인 Kotlin에 숙련되어야 함\n- Android SDK: 활동, 뷰, 레이아웃 및 인텐트와 같은 Android 소프트웨어 개발 키트(SDK) 및 구성 요소 이해\n- XML: 안드로이드 앱에서 레이아웃 및 리소스를 정의하기 위한 XML에 대한 친숙함\n- UI 디자인 원칙: 직관적이고 사용자 친화적 인터페이스를 만들기 위한 UI 디자인 원칙 이해\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 안드로이드 주니어 개발자로서 기술을 향상하는 방법은? 🤔\n\n지속적인 연습: 안드로이드 개발을 숙달하기 위해서는 꾸준한 실습이 필수적입니다. 개인 프로젝트에 참여하거나 오픈소스 프로젝트에 기여하거나 코딩 챌린지에 참여하세요.\n\n최신 정보 습득: 안드로이드 환경은 끊임없이 진화하고 있습니다. 최신 SDK 릴리스, 라이브러리 및 모범 사례에 대해 항상 최신 정보를 유지하세요.\n\n고급 주제 탐구: 자신감을 얻으면 멀티스레딩, 네트워킹, 성능 최적화와 같은 고급 안드로이드 개념에 집중해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n멘토 찾기: 경험이 풍부한 안드로이드 개발자를 찾아 안내를 받고 피드백을 받으며 도전을 극복하는 데 도움을 받으세요.\n\n커뮤니티에 기여하기: 온라인 포럼에 참여하고 밋업에 참석하여 안드로이드 개발자 커뮤니티와 연결되는 지식을 공유하세요.\n\n포트폴리오 만들기: 안드로이드 앱의 포트폴리오를 만들어 실력과 문제 해결 능력을 증명하세요.\n\n성공적인 안드로이드 주니어 개발자가 되기 위해서는 헌신, 지속적인 학습, 혁신적인 모바일 애플리케이션을 만드는 열정이 필요합니다. 인내심과 올바른 방법으로, 이 동적이고 계속 성장하는 분야에서 보람찬 경력을 쌓을 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-BecomingAndroidJuniorDeveloper_0.png"},"coverImage":"/assets/img/2024-06-22-BecomingAndroidJuniorDeveloper_0.png","tag":["Tech"],"readingTime":3},{"title":"MVVM, MVI 및 Kotlin Flows를 활용한 최신 안드로이드 개발  Part 1","description":"","date":"2024-06-22 22:37","slug":"2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1","content":"\n## 안드로이드 MVI 아키텍처의 심층 탐구\n\n<img src=\"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png\" />\n\n앱 개발 프로세스를 개선하고 스트림라인하는 방법을 찾느라 고심 중인 안드로이드 개발자이신가요? Kotlin flows를 사용하여 MVVM 및 MVI 아키텍처 패턴을 결합하는 것을 들어보았지만 그것이 어떻게 도움이 될 수 있는지 또는 어디서 시작해야 하는지 확실하지 않으신가요? 이 기사는 여러분을 위해 특별히 작성되었습니다.\n\n안드로이드 개발에 있어서 올바른 아키텍처 패턴을 선택하는 것이 얼마나 중요한지 우리 모두 알고 있습니다. 이는 관리 가능한 프로젝트와 완전한 엉망인 프로젝트 사이의 차이를 의미할 수 있습니다. 이미 MVVM (Model-View-ViewModel) 및 MVI (Model-View-Intent) 패턴에 대해 알고 계실 것으로 생각됩니다. 각각에는 강점과 약점이 있습니다. MVVM은 데이터 바인딩과 표시 상태 관리에서 빛을 발하며, MVI는 단방향 데이터 흐름과 강력한 상태 관리로 빛을 발합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 이 두 강력한 패턴을 결합하여 안드로이드 개발에 더 강력한 접근 방식을 만들 수 있다고 말했다면 어떨까요? 바로 Kotlin flows를 사용하여 MVVM과 MVI 간의 원활한 통합을 제공하는 방법을 이 글에서 살펴보겠습니다.\n\n# MVC 대 MVI\n\n결합된 방식에 대해 자세히 살펴보기 전에 먼저 MVC (Model-View-Controller)와 MVI의 핵심 원칙을 이해해 보겠습니다.\n\n## MVC란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVC 패턴에서 Model은 데이터와 비즈니스 로직을 나타내고, View는 UI를 렌더링하는 역할을 하며, Controller는 Model과 View 사이에서 중개자 역할을 하며, 사용자 입력을 처리하고 Model과 View를 업데이트합니다.\n\n![Image](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_1.png)\n\n다음은 안드로이드에서 Model-View-Controller (MVC) 아키텍처를 구현하는 예시입니다:\n\nModel 파일 이름은 UserModel.kt:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\ndata class User(val id: String, val name: String, val email: String)\n\nclass UserModel {\n    private val users: MutableList<User> = mutableListOf()\n\n    fun addUser(user: User) {\n        users.add(user)\n    }\n\n    fun getUsers(): List<User> {\n        return users.toList()\n    }\n}\n```\n\nUserModel 클래스는 Model을 나타내며 사용자 목록을 관리합니다.\n\n컨트롤러는 UserController.kt 입니다:\n\n```kotlin\nclass UserController(private val userView: UserView) {\n\n    private val userModel = UserModel()\n\n    // 모델 조작\n    fun addUser(name: String, email: String) {\n        val user = User(UUID.randomUUID().toString(), name, email)\n        userModel.addUser(user)\n\n        val users = userModel.getUsers()\n        updateView(users)\n    }\n\n    private fun updateView(users: List<User>) {\n        // 뷰에서 UI를 업데이트하는 적절한 메서드 호출\n        userView.displayUsers(users)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nThe UserController 클래스는 Controller 역할을 하며 사용자 상호작용을 처리하고 Model을 업데이트합니다. 또한 Model의 변경 사항에 따라 UI를 업데이트하기 위해 View와 통신합니다.\n\n뷰는 MvcActivity.kt에서 제공됩니다:\n\n```js\ninterface UserView {\n    fun displayUsers(users: List<User>)\n}\n\nclass MvcActivity : AppCompatActivity(), UserView {\n    private lateinit var userAdapter: UserAdapter\n    private lateinit var binding: ActivityMvcBinding\n    private lateinit var controller: UserController\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMvcBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        setupRecyclerView()\n\n        // 컨트롤러 생성\n        controller = UserController(this)\n\n        binding.addUserButton.setOnClickListener {\n            val name = binding.nameEditText.text.toString()\n            val email = binding.emailEditText.text.toString()\n            // 사용자 입력 전송\n            controller.addUser(name, email)\n        }\n    }\n\n    override fun displayUsers(users: List<User>) {\n        // 사용자 목록을 표시하기 위해 UI 업데이트\n        userAdapter.setUsers(users)\n    }\n\n    private fun setupRecyclerView() {\n        // 코드가 간결하게 유지될 수 있도록 주석 처리됨\n    }\n}\n```\n\nMvcActivity 클래스는 View를 나타내며 UI를 표시하는 역할을 담당합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## MVI란 무엇인가요?\n\n![image](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_2.png)\n\nMVI 패턴은 Model-View-Controller (MVC) 패턴의 변형으로 생각될 수 있습니다. Model-View-Intent (MVI)의 주요 아이디어는 사용자 인터페이스를 구축하기 위한 반응적이고 기능적 접근 방식을 제공하는 것입니다. 이는 Model-View-Controller (MVC) 아키텍처와 유사합니다.\n\n## MVI는 어떻게 작동하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVI에서 기본 개념은 동일하지만 보다 반응적이고 기능적인 프로그래밍 스타일을 강조합니다. Model을 직접 변경하거나 View를 업데이트하는 대신, MVI는 사용자 의도를 불변의 데이터 구조 (Intents)로 캡처하고 단방향 데이터 흐름을 통해 이를 처리하는 데 초점을 맞춥니다. 이러한 흐름은 일반적으로 세 가지 주요 구성 요소로 구성됩니다:\n\n- Model: 응용 프로그램의 현재 상태를 나타냅니다. Model은 변경할 수 없습니다. Model은 의도를 처리하고 Model의 새 버전을 생성함으로써 업데이트됩니다.\n- View: 현재 Model 상태를 기반으로 UI를 렌더링하는 역할을 합니다. View는 수동적이며 Model이 변경될 때마다 업데이트를 수신합니다.\n- Intent: 사용자 작업 또는 의도를 나타내며, View에서 Model을 업데이트하기 위해 전송됩니다. Intents는 사용자가 수행하려는 작업을 설명하는 일반적으로 간단한 데이터 구조입니다.\n\n![이미지](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_3.png)\n\nMVI 패턴은 엄격한 단방향 데이터 흐름을 강제합니다. 데이터는 의도에서 모델로, 그리고 모델에서 뷰로 흐릅니다. 이렇게 하면 앱의 동작 및 상태에 대한 추론이 더 쉬워지며 구성 요소 간 부작용이나 종속성이 없기 때문에 유지보수가 쉽습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## MVC에서 MVI로 변환하기:\n\n위의 코드를 MVI 아키텍처로 어떻게 변경할 수 있는지 알아봅시다. 먼저 두 가지 추가 클래스를 추가해야 합니다. 뷰 내에서 사용자 관련 데이터의 현재 상태를 나타내는 UserViewState 클래스를 소개했습니다. UserIntent sealed 클래스는 사용자 의도를 나타내는 다양한 의도를 정의합니다. 예를 들어 사용자를 추가하는 것입니다.\n\n```js\ndata class UserViewState(val users: List<User>)\n\nsealed class UserIntent {\n    data class AddUser(val name: String, val email: String) : UserIntent()\n    // GetUsers와 같은 다른 사용자 의도도 추가할 수 있습니다.\n}\n```\n\nUserController와 UserView 인터페이스를 제거할 수 있습니다. 또한 UserModel 클래스를 변경하여 현재 뷰 상태를 유지하고 사용자 의도를 처리하며 사용자 상태를 업데이트할 수 있습니다. UserModel은 Kotlin Coroutines Flow를 사용하여 반응적일 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass UserModel {\n    // 애플리케이션의 현재 뷰 상태를 유지합니다\n    private val _userViewState: MutableStateFlow<UserViewState> = MutableStateFlow(UserViewState(emptyList()))\n    // 다른 뷰들과 뷰 상태를 공유하여 핫 플로우로 제공합니다\n    val userViewState = _userViewState.asStateFlow()\n\n    // processUserIntents에서 사용할 현재 뷰 상태를 얻습니다\n    private fun currentViewState(): UserViewState {\n        return _userViewState.value\n    }\n\n    // 뷰로부터 사용자 의도를 처리합니다\n    fun processUserIntents(userIntent: UserIntent) {\n        when (userIntent) {\n            is UserIntent.AddUser -> {\n                val user = User(UUID.randomUUID().toString(), userIntent.name, userIntent.email)\n                val newViewState = currentViewState().copy(users = currentViewState().users + user)\n                _userViewState.value = newViewState\n            }\n            /*\n            * 다른 사용자 의도(예: 사용자 목록 가져오기)도 여기서 처리할 수 있습니다\n            * */\n        }\n    }\n}\n```\n\nuserViewState는 사용자 뷰 상태를 핫 플로우로 공유합니다. 핫 플로우는 활성 구독자 여부와 관계없이 값을 방출합니다. 핫 플로우는 구독자 여부와 상관없이 계속 업데이트를 방출하는 공유 상태를 유지합니다. 새로운 구독자가 참여하면 최신 값 및 이후의 업데이트를 수신합니다. asStateFlow() 함수는 MutableSharedFlow를 StateFlow로 변환하며, 얻어진 StateFlow는 최신 값 유지 및 구독자 활동 여부에 관계없이 업데이트를 방출하는 핫 플로우로 간주될 수 있습니다.\n\n그리고 View 부분에 대한 변경사항은 다음과 같습니다:\n\n```js\nclass MviActivity : AppCompatActivity() {\n    private lateinit var userAdapter: UserAdapter\n    private lateinit var binding: ActivityMviBinding\n    private val model = UserModel()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        binding = ActivityMviBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        setupRecyclerView()\n\n        binding.addUserButton.setOnClickListener {\n            val name = binding.nameEditText.text.toString()\n            val email = binding.emailEditText.text.toString()\n\n            // 사용자 의도를 생성하고 모델에 전달합니다\n            val userIntent = UserIntent.AddUser(name, email)\n            model.processUserIntents(userIntent)\n        }\n\n        // UI가 뷰 상태 변경을 관찰합니다\n        model.userViewState\n            .onEach { userViewState ->\n                renderUserViewState(userViewState)\n            }\n            .launchIn(lifecycleScope)\n    }\n\n    private fun renderUserViewState(userViewState: UserViewState) {\n        // 사용자 목록을 표시하기 위해 UI를 업데이트합니다\n        userAdapter.setUsers(userViewState.users)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMviActivity에서는 onEach를 사용하여 상태 플로우를 관찰하고 renderUserViewState()를 호출하여 UI를 업데이트합니다.\n\n수정된 코드로 다시 다이어그램을 살펴봅시다. 코드를 다이어그램의 각 부분에 매핑하는 방법을 살펴봅시다:\n\n![Diagram](/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_4.png)\n\n위 다이어그램에서 사용자는 OnClick 등의 액션을 트리거할 수 있습니다. 이러한 액션들은 인텐트로 파싱되어 모델에 전달될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델에서 processUserIntentsexecutes는 전달된 Intent에 기반한 로직을 실행하며, 이 경우 UserIntent.AddUser를 받아 새로운 상태를 생성합니다:\n\n```js\nval newViewState = currentViewState().copy(users = currentViewState().users + user)\n_userViewState.value = newViewState\n```\n\ncopy()는 기존 객체와 동일한 속성을 가진 새 객체를 생성하는 Kotlin 함수입니다. 이 경우 currentViewState().copy()는 현재 뷰 상태와 동일한 속성을 가진 새 UserViewState 객체를 생성합니다.\n\nusers = currentViewState().users + user 부분은 새로운 뷰 상태의 users 속성을 업데이트해야 함을 명시합니다. 요약하자면, 이 두 줄의 코드는 현재 뷰 상태의 복사본을 만들어 사용자 목록에 새로운 사용자가 추가된 새로운 뷰 상태 객체를 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n뷰 부분에서 새 상태가 생성될 때마다 MviActivity가 변경 사항을 observe합니다.\n\n```js\nmodel.userViewState\n  .onEach { userViewState ->\n      renderUserViewState(userViewState)\n  }\n  .launchIn(lifecycleScope)\n```\n\n그리고 renderUserViewState(userViewState)를 사용하여 사용자에게 상태를 표시합니다. 반응형 프로그래밍과 Kotlin Coroutine 플로우 덕분에 가능해졌습니다.\n\n# 다음은 무엇인가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 시리즈에서는 MVVM 아키텍처를 MVI와 비교하고 이러한 아키텍처를 더 깊이 파헤쳐 양쪽에서 최상의 결과를 얻을 수 있는 방법에 대해 살펴볼 것입니다. 기대해주세요!\n","ogImage":{"url":"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png"},"coverImage":"/assets/img/2024-06-22-ModernAndroidDevelopmentwithMVVMMVIandKotlinFlowsPart1_0.png","tag":["Tech"],"readingTime":12},{"title":"안드로이드 브로드캐스트 리시버 완벽 마스터하기","description":"","date":"2024-06-22 22:36","slug":"2024-06-22-MasteringBroadcastReceiversinAndroid","content":"\n<img src=\"/assets/img/2024-06-22-MasteringBroadcastReceiversinAndroid_0.png\" />\n\n안드로이드 앱 개발에서 브로드캐스트 수신기는 시스템 전반에 걸친 브로드캐스트 공지를 수신하기 위한 앱의 기능을 활성화하는 데 중요한 역할을 합니다. 장치의 배터리가 낮아지거나 인터넷 연결이 변경되었을 때, 또는 새로운 SMS가 도착했을 때를 감지하는 것처럼, 브로드캐스트 수신기는 이러한 이벤트에 대응하기 위한 주요 구성 요소입니다. 이 기사에서는 브로드캐스트 수신기가 무엇인지, 어떻게 작동하는지, 그리고 안드로이드 앱에서 효과적으로 활용하는 방법에 대해 살펴보겠습니다.\n\n# 브로드캐스트 수신기란?\n\n브로드캐스트 수신기는 활동(Activities), 서비스(Services), 콘텐트 제공자(Content Providers)와 함께 안드로이드 앱의 네 가지 주요 구성 요소 중 하나입니다. 브로드캐스트 수신기를 통해 앱은 다른 애플리케이션이나 시스템으로부터의 브로드캐스트 메시지를 수신하고 응답할 수 있습니다. 이러한 브로드캐스트는 시스템이나 다른 앱이 서로 통신할 수 있는 방법을 제공하는 것으로 생각할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 본문을 한국어로 번역해보겠습니다.\n\n이제 본문을 한국어로 번역해보겠습니다.\n\n두 가지 주요 방송 유형이 있습니다:\n\n- 시스템 방송: Android 시스템이 특정 시스템 이벤트(예: 기기를 충전할 때 또는 화면이 켜질 때) 발생 시 보내는 방송입니다.\n- 사용자 정의 방송: 앱이나 기타 제3자 앱이 특정 이벤트를 전달하기 위해 보내는 방송입니다.\n\n# 방송 수신기 동작 방식\n\n방송 수신기는 관심 있는 방송을 지정하는 IntentFilter를 정의함으로써 동작합니다. 이 필터와 일치하는 방송이 전송되면 수신기의 onReceive 메서드가 호출되어 앱이 해당 이벤트에 대응할 수 있게 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 브로드캐스트 수신기 정의하기\n\n브로드캐스트 수신기는 AndroidManifest.xml 파일에 정적으로 또는 코드에서 동적으로 정의할 수 있습니다.\n\n## 정적 등록\n\n정적 등록은 앱의 AndroidManifest.xml 파일에 수신기를 선언하는 것을 의미합니다. 이 방법은 앱이 실행 중이 아닌 경우에도 브로드캐스트를 수신하는 데 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<receiver android:name=\".MyBroadcastReceiver\">\n  <intent-filter>\n    <action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n    <action android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" />\n  </intent-filter>\n</receiver>\n```\n\n## 동적 등록\n\n동적 등록은 런타임에서 수행되며 일반적으로 Activity 또는 Service 내에서 수행됩니다. 이 접근 방식을 통해 앱의 라이프사이클에 따라 수신기의 등록 및 해제를 더 유연하게 처리할 수 있습니다.\n\n```js\nval receiver = MyBroadcastReceiver()\nval filter = IntentFilter().apply {\n    addAction(\"android.intent.action.BOOT_COMPLETED\")\n    addAction(\"android.net.conn.CONNECTIVITY_CHANGE\")\n}\nregisterReceiver(receiver, filter)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 브로드캐스트 수신기 구현\n\n다음은 브로드캐스트 수신기 구현의 간단한 예제입니다:\n\n```js\nclass MyBroadcastReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        when (intent.action) {\n            Intent.ACTION_BOOT_COMPLETED -> {\n                // 부팅 완료 처리\n                Log.d(\"MyBroadcastReceiver\", \"기기 부팅됨\")\n            }\n            ConnectivityManager.CONNECTIVITY_ACTION -> {\n                // 연결 상태 변경 처리\n                Log.d(\"MyBroadcastReceiver\", \"연결 상태 변경됨\")\n            }\n        }\n    }\n}\n```\n\n# 실용적인 사용 사례\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n방송 수신기는 다양하고 다양한 시나리오에서 사용할 수 있습니다. 이제 몇 가지 실용적인 사용 사례를 살펴보겠습니다:\n\n# 연결 변경 처리\n\n네트워크 연결이 변경될 때 필요한 작업을 수행하려고 할 수 있습니다. 예를 들어, 기기가 인터넷에 연결될 때 데이터를 동기화하는 등의 작업을 수행할 수 있습니다.\n\n```js\nclass ConnectivityReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager\n        val networkInfo = connectivityManager.activeNetworkInfo\n        if (networkInfo != null && networkInfo.isConnected) {\n            // 기기가 인터넷에 연결됨\n            Log.d(\"ConnectivityReceiver\", \"인터넷에 연결됨\")\n        } else {\n            // 기기가 인터넷에 연결되지 않음\n            Log.d(\"ConnectivityReceiver\", \"인터넷에 연결되지 않음\")\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 시스템 이벤트에 대응하기\n\n특정 시점에 작업을 수행하려면 방송 수신기(Broadcast Receivers)를 사용할 수 있습니다. 예를 들어 장치 부팅 시 서비스를 시작하는 등의 작업을 수행할 수 있습니다.\n\n```js\nclass BootCompletedReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {\n            val serviceIntent = Intent(context, MyService::class.java)\n            context.startService(serviceIntent)\n        }\n    }\n}\n```\n\n# 사용자 정의 방송 수신하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신의 앱은 자체 사용자 정의 브로드캐스트를 정의하고 수신할 수도 있습니다. 이를 통해 다른 구성 요소 또는 앱 간에 통신할 수 있습니다.\n\n```js\n// 사용자 정의 브로드캐스트 보내기\nval intent = Intent(\"com.example.MY_CUSTOM_ACTION\")\nsendBroadcast(intent)\n\n// 사용자 정의 브로드캐스트 수신하기\nclass CustomBroadcastReceiver : BroadcastReceiver() {\n    override fun onReceive(context: Context, intent: Intent) {\n        if (intent.action == \"com.example.MY_CUSTOM_ACTION\") {\n            // 커스텀 동작 처리\n            Log.d(\"CustomBroadcastReceiver\", \"커스텀 동작 수신됨\")\n        }\n    }\n}\n```\n\n# 모범 사례\n\n브로드캐스트 수신기는 강력하지만 흔한 실수를 피하기 위해 신중하게 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 전력 소비 관리\n\n방송 수신기 중에는 명시적으로 등록된 수신기가 배터리 수명에 상당한 영향을 미칠 수 있습니다. 더 이상 필요하지 않은동적으로 등록된 수신기는 항상 등록 해제해야 합니다.\n\n# 보안 고려 사항\n\n민감한 방송을 위한 수신기를 정의할 때 주의해야 합니다. 특정 방송을 보낼 수 있거나 수신할 수 있는 애플리케이션은 신뢰할 수 있는 앱들만 보낼 수 있도록 권한 검사를 사용해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<receiver android:name=\".SecureBroadcastReceiver\">\n  <intent-filter>\n    <action android:name=\"com.example.SECURE_ACTION\" />\n  </intent-filter>\n  <permission android:name=\"com.example.permission.SECURE_BROADCAST\" />\n</receiver>\n```\n\n# 메모리 누수 방지하기\n\n적절한 라이프사이클 메소드에서 동적으로 등록된 리시버를 해제하여 메모리 누수를 방지하세요.\n\n```js\noverride fun onPause() {\n    super.onPause()\n    unregisterReceiver(myReceiver)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n브로드캐스트 수신기는 안드로이드 개발에서 기본 구성 요소로, 앱이 다양한 시스템 및 사용자 이벤트를 듣고 대응할 수 있게 합니다. 방송을 효과적으로 등록하고 처리하는 방법을 이해하면, 더 반응적이고 동적인 애플리케이션을 만들 수 있습니다. 전력 소비와 보안을 관리하기 위한 최상의 방법을 준수하여 앱을 효율적이고 안전하게 유지하세요. 이 도구와 기술을 활용하면 안드로이드 프로젝트에서 브로드캐스트 수신기의 모든 잠재력을 활용할 준비가 되어 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-MasteringBroadcastReceiversinAndroid_0.png"},"coverImage":"/assets/img/2024-06-22-MasteringBroadcastReceiversinAndroid_0.png","tag":["Tech"],"readingTime":8},{"title":"루비 온 레일즈Ruby on Rails에서 Active Record Associations를 위한 최고 모범 사례 10가지","description":"","date":"2024-06-22 22:35","slug":"2024-06-22-10BestPracticesActiveRecordAssociationsinRubyonRails","content":"\n![Active Record associations](/assets/img/2024-06-22-10BestPracticesActiveRecordAssociationsinRubyonRails_0.png)\n\n루비 온 레일즈( Ruby on Rails)의 Active Record associations은 응용 프로그램의 다른 모델 간 관계를 표현하는 강력한 방법입니다. 직관적인 API를 통해 관련 데이터를 처리하기 쉽게 만들어줍니다. Active Record associations을 효과적으로 활용하는 몇 가지 모베스트 프랙티스는 다음과 같습니다:\n\n## 적절한 Association 유형 선택\n\nRails는 여러 가지 Association 유형을 지원합니다: belongs_to, has_many, has_one, has_many :through, has_one :through, 그리고 has_and_belongs_to_many. 모델 간 관계를 정확하게 반영하는 것을 선택하십시오. 예를 들어, 일대다 관계의 경우 has_many를 사용하고 해당 관계의 반대쪽에는 belongs_to를 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-22-10BestPracticesActiveRecordAssociationsinRubyonRails_1.png\" />\n\n##dependent: 올바르게 사용하기\n\n소유자가 삭제될 때 관련된 객체에 대해 어떻게 처리해야 하는지 지정하세요. :destroy, :delete_all, :nullify 또는 :restrict_with_error와 같은 옵션을 사용하여 고아 레코드를 관리하고 데이터베이스 무결성을 유지할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-22-10BestPracticesActiveRecordAssociationsinRubyonRails_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 연관성을 활용하여 스코프 활용하기\n\n공통 질의 패턴을 재사용하기 위해 연관성에 대한 스코프를 정의할 수 있습니다.\n\n아래와 같이 작성할 수 있습니다:\n\n![img](/assets/img/2024-06-22-10BestPracticesActiveRecordAssociationsinRubyonRails_3.png)\n\n이렇게 하면 사용자의 게시물 중 게시된 것만 반환하는 것으로 자동으로 필터링됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## has_many :through를 has_and_belongs_to_many보다 선호하세요\n\nhas_many :through는 조인 모델을 일반적인 ActiveRecord 모델로 사용할 수 있어 has_and_belongs_to_many보다 유연성이 높습니다. 조인 테이블에 추가 속성을 필요로 할 때 유용합니다.\n\n## 다형 관계는 되도록 삼가세요\n\n다형 관계는 강력하지만 스키마를 더 복잡하고 이해하기 어렵게 만들 수 있습니다. 실제로 필요할 때에만 사용하세요. 예를 들어, 모델이 단일 관계에서 두 개 이상의 다른 모델에 속할 수 있는 경우에 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 데이터베이스에서 외래 키 인덱싱\n\n데이터베이스에 외래 키 열을 생성하는 관계(예: belongs_to)에 대해 해당 열이 인덱싱되어 있는지 확인하세요. 이렇게 하면 해당 관계를 활용하는 쿼리의 성능을 크게 향상시킬 수 있습니다.\n\n## N+1 쿼리 피하기\n\nN+1 쿼리 문제를 주의하세요. 이 문제는 하나의 쿼리로 기본 객체를 검색한 다음 각 객체의 관계를 가져오기 위해 추가 쿼리가 실행되는 상황을 의미합니다. 관련 관계를 미리로드하고 데이터베이스 쿼리 수를 줄이기 위해 .includes 메서드를 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 콜백에 주의하세요\n\n모델에서 콜백 (before_save, after_create 등)을 사용할 때 특히 관련성을 주의해야 합니다. 적절하게 관리되지 않으면 예상치 못한 동작이나 성능 문제를 일으킬 수 있습니다.\n\n## inverse_of 옵션 사용 고려\n\n:inverse_of 옵션을 사용하여 역 관련성을 수동으로 지정할 수 있습니다. 이를 통해 객체 로딩을 최적화하고 단일 요청 범위 내에서 관련성 일관성을 보장할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 적절하게 연관된 객체 유효성 검사\n\n저장하기 전에 연관된 객체가 특정 기준을 충족하는지 확인하기 위해 유효성을 사용하세요. Rails는 이를 위해 validates_associated를 제공하지만, 연관된 객체의 유효성만을 확인하며 연관 자체의 존재 여부는 확인하지 않음을 기억해주세요.\n\n이러한 모범 사례를 따르면 Active Record 관계를 최대한 활용하여 유지보수성, 효율성 및 견고성이 높은 애플리케이션을 구축할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-10BestPracticesActiveRecordAssociationsinRubyonRails_0.png"},"coverImage":"/assets/img/2024-06-22-10BestPracticesActiveRecordAssociationsinRubyonRails_0.png","tag":["Tech"],"readingTime":4},{"title":"Ruby로 챗봇 개발하는 방법","description":"","date":"2024-06-22 22:34","slug":"2024-06-22-DevelopingChatbotsUsingRuby","content":"\n루비를 사용하면 챗봇을 빠르고 쉽게 개발할 수 있어요. 이 글에서는 루비를 사용하여 챗봇을 개발하는 장점을 코드 예제와 함께 살펴볼 거에요.\n\n![Ruby Chatbot Development](/assets/img/2024-06-22-DevelopingChatbotsUsingRuby_0.png)\n\n현대 기술 세계에서 챗봇은 이미 매우 인기 있는 기술이에요. 사용자와의 커뮤니케이션을 자동화하는 편리하고 효율적인 방법을 제공해 줘요.\n\n챗봇을 만드는 데 사용되는 프로그래밍 언어 중 하나가 루비예요. 루비는 챗봇 개발을 빠르고 쉽게 만들어주는 많은 도구와 라이브러리를 제공하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사에서는 코드 예제와 함께 챗봇 개발에 루비를 사용하는 장점을 살펴볼 것입니다.\n\n## 챗봇 개발을 위한 루비의 장점:\n\n- 코드의 간결성과 명확성: 루비는 사용하기 쉽고 이해하기 쉬운 구문을 가지고 있어 코드를 읽고 이해하기 쉽게 만듭니다. 특히 챗봇 개발에서는 코드를 쉽게 유지보수하고 확장할 수 있어야 하는데 이는 매우 중요합니다.\n- 큰 커뮤니티와 라이브러리: 루비는 활발한 개발자 커뮤니티를 갖고 있으며 챗봇 개발을 위한 많은 유용한 라이브러리와 프레임워크를 만들어냈습니다. 예를 들어 “Telegram Bot API”와 “Slack Ruby Bot” 같은 라이브러리는 인기있는 메시징 플랫폼과 간편하게 상호작용할 수 있는 방법을 제공합니다.\n- API 및 웹 서비스 지원: 루비는 API 및 웹 서비스 작업을 강력하게 지원합니다. 이를 통해 챗봇이 다양한 웹 응용프로그램 및 서비스와 상호 작용할 수 있도록 하여 자동화와 통합의 넓은 가능성을 엽니다.\n\n## “Telegram Bot API” 라이브러리를 사용하여 루비로 간단한 챗봇 개발 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nrequire 'telegram_bot'\n\nbot = TelegramBot.new(token: 'YOUR_TELEGRAM_BOT_TOKEN')\n\nbot.get_updates(fail_silently: true) do |message|\n  puts \"@#{message.from.username}: #{message.text}\"\n\n  case message.text\n  when '/start'\n    response = 'Hello! I am a Ruby chatbot.'\n  when '/help'\n    response = 'I can help you automate communication.'\n  else\n    response = 'Sorry, I don’t understand your request.'\n  end\n\n  bot.send_message(chat_id: message.chat.id, text: response) if response\nend\n\nbot.run\n```\n\n이 예시에서는 간단한 챗봇을 만들기 위해 \"Telegram Bot API\" 라이브러리를 사용합니다. 이 봇은 사용자로부터 메시지를 받아들이고, \"/start\"와 \"/help\" 명령을 처리하며, 적절한 메시지로 응답합니다. 받은 메시지가 명령이 아닐 경우, 봇은 \"죄송합니다, 요청을 이해하지 못했습니다.\" 라는 응답을 보냅니다.\n\n## \"Slack Ruby Bot\" 라이브러리를 사용하여 루비로 챗봇을 개발하는 예시:\n\n```js\nrequire 'slack-ruby-bot'\n\nclass MyBot < SlackRubyBot::Bot\n  command 'hello' do |client, data, _match|\n    client.say(channel: data.channel, text: 'Hello, I am a Ruby chatbot!')\n  end\n\n  command 'weather' do |client, data, _match|\n    # 날씨를 외부 API에서 가져오는 코드를 추가할 수 있습니다\n    weather = get_weather()\n    client.say(channel: data.channel, text: \"Current weather: #{weather}\")\n  end\nend\n\nMyBot.run\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서는 \"Slack Ruby Bot\" 라이브러리를 사용하여 Slack에서 작동하는 챗봇을 개발합니다. 이 챗봇은 \"/hello\" 및 \"/weather\" 두 가지 명령에 응답합니다. \"/hello\" 명령을 받으면 인사 메시지를 보내고, \"/weather\" 명령을 받으면 날씨 정보를 검색해 외부 API에서 결과를 채팅으로 전송합니다.\n\n루비는 챗봇 개발을 위한 다양한 라이브러리를 제공하며, 프로젝트에 가장 적합한 것을 선택할 수 있습니다. \"Telegram Bot API\"나 \"Slack Ruby Bot\" 외에도 \"Discordrb\"와 같은 다른 라이브러리들이 해당 메시징 플랫폼과 상호작용할 수 있는 기능을 제공합니다.\n\n결론적으로, 다양한 라이브러리를 사용하여 루비로 챗봇을 개발하는 것은 커뮤니케이션 자동화 및 다양한 메시징 플랫폼과 통합하는 넓은 기회를 제공합니다. 루비는 코드 간결성, 활발한 개발자 커뮤니티 및 API 지원을 보장하여 챗봇 생성에 이상적인 선택지입니다.\n","ogImage":{"url":"/assets/img/2024-06-22-DevelopingChatbotsUsingRuby_0.png"},"coverImage":"/assets/img/2024-06-22-DevelopingChatbotsUsingRuby_0.png","tag":["Tech"],"readingTime":4},{"title":"루비 온 레일스  2024년 6월 최신 버전 완벽 가이드","description":"","date":"2024-06-22 22:32","slug":"2024-06-22-FULLRubyonRailsJune2024","content":"\n루비 온 레일즈 뉴스레터를 필요로 할 때!\n\n![루비 온 레일즈](/assets/img/2024-06-22-FULLRubyonRailsJune2024_0.png)\n\n루비 온 레일즈 월간 뉴스레터의 최신 판을 환영합니다! 저는 여러분의 Desi 개발자인 사즈자드 우마르입니다. 루비 온 레일즈 세계에서의 통찰과 업데이트, 커뮤니티 하이라이트를 새롭게 제공해 드리는 것에 흥분합니다. 루비 온 레일즈에서의 여정을 시작한 개발자이든 경험이 풍부한 개발자이든, 최신 트렌드와 전 세계 이야기로 여러분을 감동시키고 정보를 제공하는 것이 제 목표입니다. 루비 온 레일즈 생태계의 새로운 소식들을 알아보고, 레일즈가 계속 발전하며 개발자들이 멋진 애플리케이션을 개발할 수 있도록 하는 방법을 확인해 보세요. 바로 시작해 봅시다!\n\n# 루비 컨퍼런스 2024의 CFP가 오픈되었습니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n올해 찾고 있는 몇 가지 테마가 있지만, 루비와 관련된 모든 것을 제출해주세요. 기술적이지 않은 이야기일지라도 괜찮아요. 아래는 주제들입니다:\n\n- 성능과 규모\n- 웹에서의 루비\n- 인공지능, 데이터 과학 및 머신 러닝에서의 루비\n- 이상한 루비\n- 당신의 위대한 아이디어!\n\nCFP는 2024년 7월 8일에 마감됩니다. RubyConf 2024에 대한 모든 정보를 여기에서 확인해주세요.\n\n# Rails 8.0 개발이 지금 시작됩니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRails 8 개발이 공식적으로 시작되었습니다.\n\n다음은 관련 커밋입니다.\n\n# Rails 8은 새 앱을 위해 Ruby 3.3+만을 대상으로 할 것입니다\n\n다음은 관련 커밋입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 레일스 8에는 기본적으로 Kamal이 추가되었습니다\n\n레일스는 클라우드나 베어 메탈로 애플리케이션을 배포하는 기본 답안을 갖춰야 합니다. 그 답안이 바로 Kamal입니다. 레일스 8은 최대한 자동으로 구성하지만, --skip-kamal 옵션으로 옵트아웃할 수도 있습니다.\n\n모든 자세한 내용은 여기에서 확인해주세요.\n\n# 7.0.8.2 및 7.1.3.3 버전이 출시되었습니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nTrix Editor에 몇 가지 취약점이 있었습니다. 이 업데이트는 Trix를 수정된 버전으로 업그레이드합니다.\n\n여기서 모든 세부 정보를 읽어보세요.\n\n# Rails 보안 릴리스\n\nRails 버전 6.1.7.8, 7.0.8.4, 7.1.3.4 및 7.2.0.beta2가 출시되었습니다! 이들은 보안 릴리스이니 최대한 빨리 업그레이드해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 모든 세부 정보를 확인해주세요.\n\n# QR Maker로 빠르고 쉽게 맞춤형 QR 코드 생성하기 (금방할 수 있어요 :D)\n\n스포일러 경고 - 저의 앱인 QRmaker로 무료로 맞춤형 QR 코드를 만들 수 있어요 https://www.qrmaker.top.\n\n기능:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- URL, WIFI 또는 텍스트용 QR 코드를 쉽게 생성하세요.\n- 브랜드 로고 추가하기\n- 브랜드 색상 추가하기\n\n![QR 코드 이미지](/assets/img/2024-06-22-FULLRubyonRailsJune2024_1.png)\n\n[QR 코드 메이커 웹사이트](https://www.qrmaker.top)\n\nDesi Developer 유튜브 채널에 새 비디오를 업로드했어요. QRmaker 앱의 공개 URL 보안에 대해 설명하고 있어요. 관심 있으시면 비디오 링크에서 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# create_schema에 :if_not_exists 및 :force 옵션을 추가했어요\n\nPostgreSQL의 create_schema는 편리한 :force 및 :if_not_exists 옵션을 지원하지 않았죠. drop_schema는 :if_exists를 지원하는데요. 이 PR은 create_schema에 지원을 추가했어요.\n\n자세한 내용은 여기에서 확인해주세요.\n\n# ActiveRecord::Relation#touch_all이 update에 사용된 사용자 정의 속성을 속성으로 별칭지어 수정된 문제를 해결했어요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 우리가 다음과 같은 것을 가지고 있다면:\n\n```js\ncreate_table :users do |t|\n  t.timestamp :legacy_updated_at\nend\n\nclass User < ActiveRecord::Base\n  alias_attribute :updated_at, :legacy_updated_at\nend\n\nUser.touch_all(:updated_at)\n```\n\n그렇다면 ActiveRecord는 updated_at을 올바르게 별칭으로 해석하지 못하고 동일한 열을 두 번 업데이트하는 쿼리로 결과가 나올 것입니다. 이 PR은 이 문제를 해결합니다.\n\n자세한 내용은 여기에서 확인해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# ActiveSupport::XmlMini가 이제 기간을 지원합니다\n\n이 Pull Request는 ActiveSupport::XmlMini에 ActiveSupport::Duration을 사용하여 기간 파서 및 포매터를 추가했습니다.\n\n자세한 내용은 여기를 확인해주세요.\n\n# 배치에서 touch_all 지원\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이전에 ActiveRecord는 batches를 통해 touch_all을 실행하는 기능이 부족했습니다 (update_all/delete_all 등과 비교하여).\n\n```js\nPost.in_batches.touch_all;\n```\n\n이 PR은 batches에서 touch_all을 지원하게 됩니다.\n\n자세한 내용은 여기에서 확인하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Rails에서는 Store 열이 구성되지 않았을 때 자세한 오류를 발생시킵니다\n\n개발자가 구조화된 열 유형 (hstore 또는 json)을 사용하지 않았거나 ActiveRecord.store와 함께 직렬화기를 선언하지 않은 경우:\n\n```js\nclass User < ActiveRecord::Base\n  store_accessor :settings, :notifications\nend\n```\n\n그럼 ConfigurationError가 발생하여 접근자를 읽거나 쓸 때 자세한 오류 메시지가 출력됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nputs user.notifications\n  # ActiveRecord::ConfigurationError: 설정 열 'settings'이 저장소로 구성되지 않았습니다. 'ActiveRecord.store'를 통해 열이 직렬화되었는지 또는 데이터베이스가 지원하는 경우 hstore 또는 json과 같은 구조화된 열 유형을 사용했는지 확인하십시오.\n```\n\n이전에 이 상황에서는 엑세서가 읽거나 쓰여질 때 NoMethodError가 발생했습니다:\n\n```js\nputs user.notifications\n# NoMethodError: ActiveRecord::Type::Text의 인스턴스에 대해 'accessor' 메서드가 정의되지 않았습니다.\n```\n\n설명적인 예외를 발생시킴으로써 개발자가 빠르게 무엇이 잘못되었고 어떻게 수정해야 하는지 이해하는 데 도움이 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 모든 세부 사항을 확인해주세요.\n\n# 플러그인 생성기에 루비캅 및 GitHub Actions 추가\n\n이 풀 리퀘스트는 플러그인 생성기를 업데이트하여 GitHub Actions 및 루비캅을 위한 템플릿을 포함하도록 했습니다. 또한 루비캅 린팅을 통과하도록 몇 가지 파일을 업데이트했습니다.\n\n자세한 내용은 여기를 읽어주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# automatically_invert_plural_associations은 이제 기본적으로 활성화되지 않습니다\n\n많은 감지하기 어려운 문제를 발생시킬 수 있는 가능성 때문에 automatically_invert_plural_associations는 기본적으로 비활성화되어 있습니다. 그러나 시도해 보고 싶다면 선택하여 활성화할 수 있습니다.\n\n자세한 내용은 여기에서 확인하세요.\n\n# 개발자 컨테이너는 선택 사항으로 만들고 devcontainer 명령어를 생성했습니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 Pull Request는 Rails 7.2 개발 컨테이너가 선택 기능으로 제공될 예정이기 때문에 작성되었습니다. 따라서 새로운 앱은 --devcontainer 플래그를 rails new에 전달해야만 개발 컨테이너를 받을 수 있습니다. 또한, 기존 앱에 대한 devcontainer를 생성할 수 있게 bin/rails devcontainer를 사용할 수 있습니다.\n\n모든 세부 내용은 여기에서 확인해주세요.\n\n# schema_cache_ignored_tables에 대한 새로운 public method가 추가되었습니까?\n\n이전에는 무시된 스키마 캐시 테이블을 설정하는 메서드만 있었지만, 스키마 캐시에 의해 테이블이 무시되었는지 확인할 수 있는 방법이 없었습니다. 애플리케이션은 자체 스키마 캐시를 구현하거나 적어도이 확인을 실행할 수 있기를 원할 수 있습니다. 내부 메서드를 구현하도록 강제하는 대신, 이것은 테이블이 스키마 캐시 코드에서 무시되는지 묻는 방법을 추가합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n사용법:\n\n```js\nActiveRecord.schema_cache_ignored_tables = [\"developers\"]\nActiveRecord.schema_cache_ignored_tables?(\"developers\")\n```\n\n여기에서 모든 세부 정보를 확인하세요.\n\n# 필요하지 않은 경우 Kamal 저장소 볼륨을 구성하지 마세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 Pull Request는 Kamal에서 Docker 영구 저장소 볼륨을 구성해야 하는 것이 sqlite 또는 ActiveStorage에만 필요한 것으로 보입니다. 다른 데이터베이스를 사용하고 --skip-active-storage 옵션을 사용하는 경우에는 구성을 건너뛸 수 있습니다.\n\n여기에서 자세한 내용을 읽어보세요.\n\n# 복합 기본 키에 대한 사전로드된 연관의 ID 리더 문제 해결\n\n모델에서 복합 기본 키를 사용할 때 primary_key는 배열이 됩니다. 이는 사전로드된 연관에 대해 `association`\\_ids 메서드를 호출할 때 문제가됩니다. 내부적으로 Rails는 Enumerable에서 pluck 메서드를 사용하여 사전로드된 결과를 검색합니다. 그러나 pluck 메서드는 인수로 배열을 허용하지 않습니다. 이를 수용하기 위해 splat 연산자를 사용하여 배열을 동적으로 여러 인수로 분할해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금 예제 조합 기본 키로 관계를 호출하면 user.posts.ids가 예상대로 작동합니다.\n\n자세한 내용은 여기를 읽어보세요.\n\n# 전역으로 strict_loading_mode 설정할 수 있습니다\n\n이 Pull Request는 새로운 class_attribute :strict_loading_mode을 추가했는데, 기본값은 :all입니다. :n_plus_one_only로 설정하면 strict loading 검사를 수행할 때 기본적으로 이 모드가 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 모든 세부 정보를 확인하세요.\n\n# 첫 요청 시나 url_helpers 호출 시 경로 그리기 지연\n\n많은 경로를 가진 앱은 부팅하는 데 오랜 시간이 걸립니다. 경로와 관련이 없는 이유로 개발자가 앱을 부트할 수 있습니다(단위 테스트 실행, 마이그레이션, rake 작업 등), 따라서 이 작업은 개발 및 테스트에서 지연되어야 한다고 생각합니다.\n\n이 Pull Request는 엔진 및 앱 라우트 세트를 현재 Rails 애플리케이션을 알고 있는 Rails::Engine::RouteSet으로 변경합니다. 기본 미들웨어 스택도 변경되어 필요시 경로를 로드하는 Rails::Rack::LoadRoutes 미들웨어를 포함합니다. 이 PR은 다음 상황에서 경로를 로드합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발/테스트 중:\n\n- 미들웨어를 통해 처음 요청했을 때\n- 어플리케이션 또는 엔진 url_helpers.some_path를 method_missing을 통해 호출했을 때\n- 어플리케이션 또는 엔진 url_helpers.respond_to?(:some_path)을 respond_to_missing을 통해 호출했을 때\n\n운영 중:\n\n- 기존 동작인 finisher로 미리 실행했을 때\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 이유로든 개발자가 이전 동작으로 되돌아가길 원한다면, Rails.application.reload_routes!를 추가하는 이니셜라이저를 사용할 수 있습니다.\n\n자세한 내용은 여기에서 확인할 수 있습니다.\n\n# sql.active_record 이벤트 페이로드에 현재 트랜잭션 포함\n\n새로 추가된 ActiveRecord::Transaction#uuid 덕분에 트랜잭션으로 쿼리를 그룹화하거나 데이터베이스 활동을 추적하는 것이 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 모든 세부 정보를 확인하세요.\n\n# to_time_preserves_timezone의 재발의 폐지\n\n이전 감시가 모든 사용자에게 경고되지 않았기 때문에 제거를 계속 진행하면 경고되지 않은 행동 변경이 발생할 수 있습니다.\n\n이 풀 리퀘스트는 이전 경고를 복원한 후, 이미 설정된 구성 설정이 아닌 경우 to_time이 처음 호출될 때 추가로 경고를 추가합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에 모든 세부 정보를 읽어보세요.\n\n# 로거 젬에 명시적 의존성 추가\n\n로거는 Ruby 3.5를 위한 번들된 젬 후보이므로 이 젬 없이는 경고 메시지가 표시될 것입니다.\n\n여기에 모든 세부 정보를 읽어보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 첨부 파일에 콘텐츠 속성이 있을 때만 살균 작업 수행\n\n최근 보안 업데이트에서 ActionText::Attachable::ContentAttachment의 콘텐츠 속성을 살균하는 작업이 이루어졌습니다. 이 업데이트의 부작용으로 콘텐츠가 없는 경우에도 항상 속성을 설정하게 되어 Trix가 이미지 미리보기를 표시하지 못하는 문제가 발생했습니다. 본 풀 리퀘스트는 이 문제를 해결하고 수정하였습니다.\n\n자세한 내용은 여기를 클릭해주세요.\n\n# bin/rails notes를 위한 내부 경로 추가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nrails/info/routes 루트에서 영감을 받아 rails/info/notes 내부 루트가 추가되었습니다.\n\n이제 다음을 수행하는 것과 같을 것입니다:\n\n```js\n$ bin/rails notes\n\napp/controllers/posts_controller.rb:\n  * [ 9] [TODO] Move this logic to a concern\n  * [18] [FIXME] Refactor this method\napp/models/post.rb:\n  * [ 2] [TODO] Refactor this validation\n```\n\nUI에서 노트를 확인할 수 있도록 bin/rails notes를 위한 내부 루트가 추가되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 모든 내용을 읽어보세요.\n\n# puma.rb를 app:update의 대상으로 돌려놓았습니다\n\nRails는 지난 몇 차례에 걸쳐 puma.rb를 개선했으며, 미래 릴리스에서 rails app:update를 통해 파일을 업데이트할 것입니다.\n\n여기서 모든 내용을 읽어보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 새로운 start_transaction.active_record 이벤트를 정의했습니다\n\n이 변경으로 인해 트랜잭션이 시작될 때마다 새로운 start_transaction.active_record 이벤트가 발생합니다. 이 이벤트는 트랜잭션이 완료될 때 트리거되는 기존 transaction.active_record 이벤트와 보완 관계에 있습니다.\n\n자세한 내용은 여기를 확인해주세요.\n\n# ActiveRecord: in_order_of에 대한 옵션 필터 추가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 Pull Request는 현재 in_order_of 메소드가 항상 where 절을 사용하여 결과를 값으로만 필터링하도록 구현된 것에 대한 문제점을 해결하기 위해 작성되었습니다. 때로는 정렬에서 일부 값을 우선순위로 지정하고 나머지 정렬에 신경 쓰지 않고 전체 검색 범위를 원할 때가 있습니다. 여기서 제안하는 것은 값에 의해 검색 범위를 필터링할지 여부를 지정할 수 있는 옵션을 추가하는 것입니다.\n\n이 Pull Request가 변경하는 내용은 다음과 같습니다:\n\n```js\norder = [3, 4, 1]\n\n# 옵션을 지정하지 않은 경우\nPost.in_order_of(:id, order).to_sql\n# SELECT\n  # \"posts\".* FROM \"posts\"\n# WHERE\n  # \"posts\".\"id\" IN (3, 4, 1)\n# ORDER BY\n  # CASE WHEN \"posts\".\"id\" = 3 THEN 1 WHEN \"posts\".\"id\" = 4 THEN 2 WHEN \"posts\".\"id\" = 1 THEN 3 END ASC\n# 옵션을 false로 설정한 경우\nPost.in_order_of(:id, order, filter: false).to_sql\n# SELECT\n  # \"posts\".* FROM \"posts\"\n# ORDER BY\n  # CASE WHEN \"posts\".\"id\" = 3 THEN 1 WHEN \"posts\".\"id\" = 4 THEN 2 WHEN \"posts\".\"id\" = 1 THEN 3 ELSE 4 END ASC\n```\n\n자세한 내용은 여기를 참조하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비 온 레일 월간 뉴스레터에 함께해줘서 감사해요! 새로운 정보와 업데이트가 유용했길 바라요. 계속해서 구독하여 레일 생태계의 최신 소식과 영감을 얻도록 하세요. 다음 달에 또 만나요. 즐거운 코딩 되세요!\n","ogImage":{"url":"/assets/img/2024-06-22-FULLRubyonRailsJune2024_0.png"},"coverImage":"/assets/img/2024-06-22-FULLRubyonRailsJune2024_0.png","tag":["Tech"],"readingTime":17},{"title":"루비로 API를 구축하는 강력한 프레임워크, Grape","description":"","date":"2024-06-22 22:31","slug":"2024-06-22-GrapeAPowerfulFrameworkforBuildingAPIsinRuby","content":"\n웹 애플리케이션 또는 API를 개발하는 경우, 아마도 루비 프로그래밍 언어의 강력한 프레임워크인 Grape에 대해 들어보셨을 것입니다. Grape는 개발자에게 API를 빠르고 편리하게 생성하는 도구를 제공하며, 개발자 커뮤니티에서 인기를 얻고 있습니다.\n\n![Grape](/assets/img/2024-06-22-GrapeAPowerfulFrameworkforBuildingAPIsinRuby_0.png)\n\n```ruby\nmodule V1\n  # 기본 API 클래스\n  class Api < Grape::API\n    version 'v1', using: :path\n\n    mount Budget\n    mount Backend\n  end\nend\n```\n\nGrape는 간결하고 가벼운 프레임워크로, 간단한 것부터 복잡한 API를 생성하기에 적합합니다. 루비 프레임워크 Sinatra 위에 구축되어 있어, 이미 Sinatra에 익숙한 개발자들에게 매력적입니다. Grape의 주요 특징은 간단하고 직관적인 구조에 있습니다. 라우트, 리소스 및 API 매개변수를 정의하기 위한 선언적 DSL(Domain-Specific Languages) 세트를 개발자에게 제공하여 효율적이고 유연한 API를 빠르고 쉽게 생성할 수 있도록 도와줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGrape의 주요 장점 중 하나는 그 명확성입니다. 그것은 경로를 정의하는 간단하고 이해하기 쉬운 방법을 제공하며 GET, POST, PUT 및 DELETE와 같은 모든 종류의 HTTP 요청을 처리합니다. 또한, Grape는 JSON 및 XML과 같은 다양한 데이터 형식에 대한 내장 지원을 갖추고 있어 RESTful API를 만드는 데 이상적인 선택지입니다.\n\n```javascript\nrequire 'grape-swagger'\n\n# Root API class\nclass RootApi < Grape::API\n  format :json\n  prefix :api\n\n  helpers do\n    def permitted_params\n      @permitted_params ||= declared(params, include: false)\n    end\n  end\n\n  mount ::V1::Api\n\n  add_swagger_documentation \\\n    host: ENV.fetch('SWAGGER_HOST'),\n    doc_version: '0.0.1',\n    base_path: '',\n    mount_path: '/v1/docs',\n    add_base_path: true,\n    add_version: true,\n    info: {\n      title: 'Grape API',\n      contact_url: 'https://localhost:3000'\n    },\n    array_use_braces: true\nend\n```\n\n더불어, Grape는 강력한 데이터 유효성 검사 기능을 갖고 있습니다. Grape를 사용하면 쉽게 요청 매개변수를 선언하고 유효성을 검사할 수 있어 데이터 무결성을 보장하고 API의 보안성을 높일 수 있습니다. 또한 데이터 직렬화 및 표현을 단순화하는 Grape::Entity와 같은 확장을 사용할 수도 있습니다.\n\n하지만 그것만이 아닙니다! Grape는 API의 기능을 설정하고 확장하는 다양한 옵션을 제공합니다. 인증 및 권한 부여 메커니즘, 확장 가능한 플러그인, 요청 필터 등을 지원하며 훨씬 더 많은 기능까지 제공합니다. 또한 ActiveRecord 및 Grape-Swagger와 같은 유용한 gem들과 통합하여 더 많은 유연성과 편의성을 얻을 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요약하자면, Grape은 루비로 API를 구축하기 위한 강력하고 유연한 프레임워크입니다. 간단한 구문, 사용 편의성 및 다양한 기능적 기능을 갖추고 있습니다. 웹 애플리케이션을 위한 API를 만들어야 한다면, Grape은 개발에서 효율성과 유연성을 달성하기 위한 훌륭한 선택입니다.\n","ogImage":{"url":"/assets/img/2024-06-22-GrapeAPowerfulFrameworkforBuildingAPIsinRuby_0.png"},"coverImage":"/assets/img/2024-06-22-GrapeAPowerfulFrameworkforBuildingAPIsinRuby_0.png","tag":["Tech"],"readingTime":3},{"title":"Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법","description":"","date":"2024-06-22 22:29","slug":"2024-06-22-HowITuningPumaforRubyonRailsatKubernetes","content":"\n## 쿠버네티스에 맞게 Puma 튜닝하기\n\nPuma는 Ruby on Rails용 인기 있는 웹 서버 패키지이며, Puma 구성을 잘 튜닝하면 서비스 효율성이 더욱 향상됩니다.\n\nPuma 젬: [https://rubygems.org/gems/puma](https://rubygems.org/gems/puma)\n\n![이미지](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 왜 리팩토링 해야 하나요?\n\n가장 중요한 이유는 도커에서 쿠버네티스 아키텍처로 마이그레이션할 때, Puma 구성을 새 아키텍처에 맞게 업데이트해야 할 수도 있다는 것입니다. 따라서, 저는 많은 기사와 소스 저장소를 재조사하여 이를 다시 작성하는 데 도움을 받았어요.\n\n# Puma 구성 튜닝을 하기 전, 확인해야 할 사항\n\n- 처음에는 가장 중요한 서비스를 사용하지 마세요. 그 대신 부수적인 서비스를 사용하세요.\n  예를 들어, 먼저 테스트할 때 회원 OAuth 서비스를 사용하지 마세요. 이 예에서, 저는 테스트용으로 메일 센터를 사용했어요. (대부분의 요청이 내부 호출이며, 요청이 실패하면 다시 시도합니다.)\n- 서비스의 온라인 상태를 확인하기 위해 모니터링 서비스 중 하나가 반드시 필요해요. 저는 서비스와 쿠버네티스 상태를 확인하기 위해 Datadog를 사용하고 있어요.\n- 각 구성 설정과 단계별 튜닝을 위해 왜 그리고 어떻게 하는지 알아야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Puma 구성 리팩터링\n\n## 우리의 초기 Puma 구성\n\n첫 번째 구성은 다음과 같습니다.\n\n```js\n#!/usr/bin/env puma\n\nenvironment ENV.fetch(\"RAILS_ENV\") { \"development\" }\n\nif ENV['RAILS_ENV'].nil? || ENV['RAILS_ENV'] == 'development'\n  threads_count = ENV.fetch(\"RAILS_MAX_THREADS\") { 5 }\n  threads threads_count, threads_count\n\n  port ENV.fetch(\"PORT\") { 3000 }\n\n  plugin :tmp_restart\nelse\n  directory './'\n  rackup \"./config.ru\"\n\n  pidfile \"./tmp/pids/puma.pid\"\n  state_path \"./tmp/pids/puma.state\"\n\n  threads 0,16\n\n  port ENV.fetch(\"PORT\") { 3000 }\n\n  workers 2\n\n  prune_bundler\n\n  on_restart do\n    puts 'Refreshing Gemfile'\n    ENV[\"BUNDLE_GEMFILE\"] = \"./Gemfile\"\n  end\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 리팩터링 키포인트 1: 스레드 용량 감소\n\n일부 참조 링크를 조사했는데, 먼저 그것들을 확인해보세요.\n\n- [문서] 쿠버네티스에 적합한 Puma 튜닝 방법\n- 최대 효율을 위한 Puma, Unicorn 및 Passenger 구성\n- Pod 당 워커 및 기타 구성 문제\n\n마지막 문제 토론에 따르면, 너무 많은 스레드를 사용하는 것은 더 많은 요청을 수용하기에 적합하지 않으며, 리소스가 Global VM 락에 직면할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 설정에서는 각 워커에 너무 많은 스레드를 설정했어요. 그래서 이것이 제 첫 번째 반응 대상이 됐어요.\n\nPuma 문서의 기사에 따르면, 쿠버네티스 팟 _ Puma 워커 _ 스레드가 최종 총 용량이라는 걸 알 수 있어요.\n\n이전에 우리의 용량은 64였어요. 2 (팟) _ 2 (워커) _ 16 (최대 스레드)인거죠. 큰 감소가 심각한 문제를 일으킬 것을 두려워해서, 처음에는 스레드를 8로 순차적으로 감소시켰고, 마지막에 5로 줄였어요 (총 용량은 20이 될 거예요).\n\n```js\n# puma.rb\n# Puma에게 1에서 5 범위 내에서 스레드를 자동 조정하도록 설정합니다.\n# 각 스레드가 더 많은 CPU / 메모리 리소스를 갖으므로 16에서 5로 줄였어요.\nthreads 0, 5\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Refactor Key 2: CPU 코어의 수를 신뢰성 있게 감지할 수 있어야 합니다.\n\n초기 설정에서는 이전 도커 인프라에서 각 서비스가 사용할 수 있는 2개의 vCPU를 가지고 있기 때문에, 종업원을 두 명으로 설정했습니다.\n\n첫 번째 시도에서, 새로운 Rails 버전의 Puma 구성 설정을 참조하여 CPU를 감지하였습니다.\n\n```js\n# Specifies that the worker count should equal the number of processors in production.\nif ENV[\"RAILS_ENV\"] == \"production\"\n  worker_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\n  workers worker_count if worker_count > 1\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비 메소드를 사용하여 CPU 프로세서 카운트를 감지하는 것은 좋은 아이디어에요. \"물리 프로세서 수\" 또는 \"OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서\"를 기준으로 결정할 수 있어요.\n\n```js\n# Module: Concurrent\n\nrequire \"concurrent-ruby\"\n\n# 현재 시스템의 물리 프로세서 코어 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\nConcurrent.physical_processor_count\n\n# OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\nConcurrent.processor_count\n```\n\n만약 Kubernetes 베이스 클러스터 노드에 CPU가 4개 있고, 서비스를 1000(µs) CPU 리소스로 제한한다면, Coucurrnet 메소드를 사용하면 항상 4를 반환할 거에요 (호스트 수준 리소스가 보이기 때문에 팟 수준 리소스가 아니에요).\n\n그래서 Puma가 Kubernetes 설정을 직접 읽을 수 있도록 해야 해요. 다음과 같이 시도해 봤어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# K8S CPU 제한을 설정하는 방법을 확인하세요.\n\n## cpu.cfs_quota_us는 그룹이 해당 창기간 동안 사용할 수 있는 최대 CPU 시간(마이크로초 단위)을 지정합니다.\n\n## cpu.cfs_period_us는 CPU 액세스를 위한 시간 창문의 길이(마이크로초 단위)를 나타냅니다.\n\n## quota가 -1이면 CPU 자원 사용에 대한 제한이 없는 것을 의미합니다.\n\n\"concurrent-ruby\"을 요구합니다.\nquota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\nperiod_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\nquota = File.read(quota_file).strip.to_i\nperiod = File.read(period_file).strip.to_i\n\nif quota != -1\nprocessors_count = (quota.to_f / period.to_f).ceil\nelse\nprocessors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\nend\n\nCPU 자원이 제한되지 않는 경우에는 서비스가 노드의 CPU 최대 범위를 사용할 수 있으므로 물리적 프로세서 개수를 기반으로 설계되었습니다. 제한이 있는 경우 계산하세요!\n\n## 리팩터링 핵심 3: 항상 서비스에 시간 제한을 설정하세요.\n\nSidekiq 작성자인 마이크의 글을 예전에 읽었는데도 기억이 싱싱합니다. 모든 네트워크 요청에는 타임아웃을 설정해야 한다는 교훈을 주었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 참고한 GitHub은 puma 타임아웃 설정을 위해 the-ultimate-guide-to-ruby-timeouts입니다. 매우 유용합니다.\n\n![이미지](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_1.png)\n\n## 리팩터링 핵심 4: 에러 처리 설정하기.\n\nPuma에는 기본 에러 처리 구성이 내장되어 있습니다. 또한 오류를 캡처하는 Sentry 시스템도 있으므로 에러가 발생할 때 Sentry 캡처를 추가하는 것이 좋아 보입니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 참조: https://github.com/puma/puma?tab=readme-ov-file#error-handling\n\nlowlevel_error_handler do |e|\n  Sentry.capture_exception(e)\n  [500, {}, [\"오류가 발생했습니다\"]]\nend\n```\n\n## 최종 Puma 설정\n\n```js\n# 이 구성 파일은 Puma에 의해 평가될 것입니다. 여기에서 호출되는 최상위 메서드들은\n# Puma의 구성 DSL의 일부입니다. DSL에서 제공하는 메서드에 대한 자세한 정보는 https://puma.io/puma/Puma/DSL.html에서 확인하세요.\n\n# Puma는 설정 가능한 일정 수의 프로세스(작업자)를 시작하고 각 프로세스는 내부 스레드 풀에서 스레드로 각 요청을 처리합니다.\n#\n# 각 작업자당 이상적인 스레드 수는 응용 프로그램이 IO 작업을 기다리는 시간과\n# 처리량을 지연 시간보다 우선시할지에 따라 다릅니다.\n#\n# 일반적으로 스레드 수를 늘리면 특정 프로세스가 처리할 수 있는 트래픽 양(처리량)이 늘어납니다.\n# 그러나 CRuby의 Global VM Lock (GVL)로 인해 반응 시간(지연 시간)이 악화될 수 있고\n# 수응용 프로그램의 경우 감소하기 때문에 이 형벌이 선뜻 좋은 결정이라고 할 수 없습니다.\n#\n# 평균적인 Rails 응용 프로그램에 대한 처리량과 지연 시간 사이의 괜찮은 절충으로 간주되는 3개의 스레드로 설정됩니다.\n#\n# 연결 풀이나 다른 리소스 풀을 사용하는 모든 라이브러리는\n# 스레드 수와 동일하거나 그 이상의 연결을 제공하도록 구성되어야 합니다.\n# 이에는 `database.yml`의 Active Record의 `pool` 매개변수가 포함됩니다.\ndefault_threads_count = ENV.fetch(\"RAILS_MAX_THREADS\") { 3 }\nthreads default_threads_count, default_threads_count\n\n# 프로덕션 및 준비 단계에서 작업자 수를 프로세서 수와 동일하게 설정\nif rails_env == \"production\" || rails_env == \"preparing\"\n  # 프로세스 당 1개 이상의 스레드를 실행중인 경우 작업자 수\n  # 기본적으로 프로세서(컴퓨터 코어)의 수와 동일하게 설정해야합니다.\n  #\n  # 이것은 신뢰할 수 없te, CPU 코어의 수를 신뢰할 수없습니다.\n  # `WEB_CONCURRENCY` 환경 변수를 프로세서 수와 일치하도록 설정하는지 확인하세요.\n  require \"concurrent-ruby\"\n\n  # config 파일로부터 K8S CPU 한정 메모리 확인\n  ## cpu.cfs_quota_us는 그 그룹이 그 창에서 사용할 수 있는 최대 CPU 시간(밀리 초 단위)을 지정합니다.\n  ## cpu.cfs_period_us는 CPU 액세스 시간 창의 길이를 지정합니다.\n  quota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\n  period_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\n  quota = File.read(quota_file).strip.to_i\n  period = File.read(period_file).strip.to_i\n\n  if quota != -1\n    processors_count = (quota.to_f / period.to_f).ceil\n  else\n    processors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\n  end\n\n  # 작업자 및 스레드 설정\n  if processors_count > 1\n    workers processors_count\n    threads 0, 5\n\n    on_worker_boot do\n      ActiveRecord::Base.establish_connection if defined?(ActiveRecord)\n    end\n  else\n    preload_app!\n  end\n\n  worker_timeout 15\n  worker_shutdown_timeout 8\nend\n\n# Puma가 요청을 수신하기 위해 청취하는 `포트`를 지정; 기본값은 3000입니다.\nport ENV.fetch(\"PORT\") { 3000 }\n\n# Puma가 실행할 `환경`을 지정합니다.\nenvironment rails_env\n\n# `bin/rails restart` 명령으로 Puma를 다시 시작할 수 있도록 허용\nplugin :tmp_restart\npidfile ENV[\"PIDFILE\"] if ENV[\"PIDFILE\"]\n\nif rails_env == \"development\"\n  # 디버거에 의해 일시 중단되었을 때 Puma에 의해 작업자가 종료되지 않도록 매우 넉넉한 `worker_timeout`를 지정합니다.\n  worker_timeout 3600\nend\n\n# 응용 프로그램의 범위를 벗어난 오류가 발생하면 Puma가 500 및 간단한 텍스트 오류 메시지와 함께 응답\nlowlevel_error_handler do |e|\n  Sentry.capture_exception(e)\n  [500, {}, [\"오류가 발생했습니다\"]]\nend\n```\n\n이전에 언급하지 않았던 몇 가지 작은 변경 사항이 있지만 참고하실 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- **on_worker_boot** 메소드를 사용해보세요.\n  작업자가 부팅될 때 항상 ActiveRecord가 데이터베이스에 연결되어 있는지 확인하세요 (필요하다면 Redis를 추가할 수도 있습니다).\n\n- 여러 작업자를 사용하는 경우 **preload_app!**는 기본적으로 켜져 있습니다.\n  Rails에서는 새로운 Puma 템플릿이 작업자 수가 1인 경우에도 preload_app를 사용합니다.\n  https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\n\n# 모든 것을 모니터링하세요\n\n만든 변경사항은 항상 모니터링되어야 함을 기억하세요.\n\n새로운 환경 설정을 프로덕션에 배포할 때 문제가 없어야 합니다. (물론, 우리는 준비된 환경이 있고 서비스가 작동하는지 확인하기 위해 몇 가지 스트레스 테스트를 수행하였지만, 요청량은 프로덕션 환경과 비교할 수 없을 정도로 상이합니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요청 용량을 64에서 20으로 줄인 후에도 서비스는 잘 작동했어요. CPU 및 메모리 사용량이 크게 개선되지는 않았지만, 스레드 용량을 더 적합한 상황으로 줄여 GVL을 피하려고 성공적으로 조정했습니다.\n\n![그림 1](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_2.png)\n\n![그림 2](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_3.png)\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 멀티스레드인 경우, Puma 워커 당 1개의 CPU를 할당하세요.\n  참고: https://github.com/puma/puma/issues/2645#issuecomment-867629826\n- 대부분의 Puma는 워커 당 약 512MB ~ 1GB의 메모리를 사용하며, 마스터 프로세스에 대략 1GB를 사용합니다.\n  참고: https://github.com/puma/puma/issues/2645#issuecomment-867629826\n- 대부분의 Puma는 각 쓰레드 당 약 300MB ~ 500MB의 메모리를 사용합니다.\n  이는 웹 서비스의 유형과 기능에 따라 다를 수 있으며, Ruby 3 및 Rails 6 응용 프로그램을 실험하면서 각 프로세스가 약 200MB ~ 400MB 정도 사용한다는 기사를 참조했습니다.\n  참고: https://www.speedshop.co/2017/10/12/appserver.html\n- 각 Puma 워커를 3 ~ 5개의 쓰레드로 설정하는 것이 일반 목적에 가장 적합합니다.\n  참고 1: https://github.com/rails/rails/issues/50450\n  참고 2: https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration\n- 자원에 따라 구성이 동적으로 조정되도록 하세요.\n- 웹 서비스에 대한 시간 초과 및 오류 처리 메커니즘을 항상 설정하세요.\n  참고 1: https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\n  참고 2: https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts\n- 생산 환경에 배포하기 전에 중요하지 않은 서비스부터 사용하고, 배포 전에 더 많은 테스트를 수행하세요.\n- 생산 환경에 배포할 때 모니터링 서비스를 사용하여 모든 변경 사항을 처리하고 기록하는 데 도움을 받으세요.\n\n# 참고 자료\n\n- https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server\n- https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma\n- https://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues\n- https://github.com/puma/puma?tab=readme-ov-file#clustered-mode\n- https://github.com/puma/puma?tab=readme-ov-file#error-handling\n- https://github.com/puma/puma/issues/2645\n- https://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb\n- https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\n- https://github.com/rails/rails/issues/50450\n- https://puma.io/puma/Puma/DSL.html\n- https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method\n- https://www.speedshop.co/2017/10/12/appserver.html\n- https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\n","ogImage":{"url":"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png"},"coverImage":"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png","tag":["Tech"],"readingTime":14},{"title":"Ruby on Rails로 OCR 시스템 구축하는 방법","description":"","date":"2024-06-22 22:27","slug":"2024-06-22-HowIbuiltanOCRSystemwithRails","content":"\n친구와의 대화 중에 이 아이디어가 떠올랐어요. 친구가 문서를 스캔하고 분석해야 할 일이 많다는데, 시간을 내기가 어려워한다는 걸 언급했더라구요. 그 일이 어려운 작업으로 들리고, 스트레스를 받고 있다는 걸 알 수 있었어요. 그래서 \"어쩌면 해결책을 찾을 수도 있겠네요\" 라고 말했죠. 그 순간, Ruby와 RTesseract를 사용하여 작은 스크립트를 만들기로 결심했어요. 이 스크립트는 그의 문서 스캔을 도와주는 것뿐만 아니라 이미지에서 텍스트를 추출하기 위한 OCR 작업도 수행했답니다. 이 작업은 상당히 유용했고, 다른 사람들도 이 아이디어의 더 강력한 버전에서 혜택을 받을 수 있을 거라 생각했어요. 그래서 이렇게 Rails 어플리케이션이 탄생했죠.\n\n![OCR 시스템을 Rails로 어떻게 만들었는지](/assets/img/2024-06-22-HowIbuiltanOCRSystemwithRails_0.png)\n\n# 사용할 도구\n\n## 이 프로젝트에서 사용할 도구는 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 루비 온 레일즈: 난 올드 스쿨이라서.\n- Active Storage: 빠르니까.\n- Tailwind CSS: 요즘 누가 안 하는가?\n- Tesseract OCR: 마술사처럼 사진을 단어로 바꿔주지.\n- RTesseract: 우리 앱과 친구되게 만들어 주는 루비 젬이야.\n\n# 단계 1: 재료 준비하기\n\n먼저 레일즈 앱이 필요해. 하나 만들기 위해 다음 명령어를 실행해봐\n\n```js\nrails new ocr\ncd ocr\nrails active_storage:install\nrails db:migrate\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, Tailwind가 필요합니다.\n\n```js\nbundle add tailwindcss-rails\nrails tailwindcss:install\n```\n\n이걸로 대부분의 작업이 끝날 거예요. 더 자세히 알고 싶다면, Tailwind의 문서를 살펴보세요.\n\n# 단계 2: 모델 생성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모델을 생성하여 파일 첨부 기능이 포함된 모델을 만들어봅시다. 예시를 위해 Document 모델을 생성해보겠습니다:\n원하시는 다른 열을 포함시킬 수 있습니다. 저는 제목 열만을 포함하겠습니다.\n\n```js\nrails generate model Document title:string\nrails db:migrate\n```\n\n# 단계 3: 모델 업데이트\n\n파일 첨부를 다루기 위해 Active Storage를 사용할 것입니다. 이를 통해 모델에 파일을 쉽게 첨부할 수 있습니다. Document 모델을 수정하여 파일 첨부를 포함하도록 해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 단계별로 설명해 드리겠습니다:\n\n- 모델 생성: 이미 제목 속성이 있는 문서 모델을 생성했습니다.\n- Active Storage 관계 추가: 문서 모델을 업데이트하여 하나의 첨부 파일이 있다는 것을 나타냅니다. 이는 Active Storage가 제공하는 has_one_attached 메서드를 사용하여 수행됩니다.\n- 모델 정의: app/models/document.rb에 있는 문서 모델 파일을 열고 다음 코드를 추가하세요:\n\n```ruby\nclass Document < ApplicationRecord\n  has_one_attached :file\nend\n```\n\n- has_one_attached :file: 이 코드는 Rails에게 각 문서 인스턴스가 첨부 파일을 하나 가질 수 있다고 알려줍니다. Active Storage가 첨부를 우리 대신 관리하며, 메타데이터는 데이터베이스에, 실제 파일은 구성된 저장 서비스(로컬 디스크, Amazon S3 등)에 저장됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 모델에 has_one_attached :file를 추가함으로써, 이제 생성할 컴포넌트가 또 하나 생겼습니다: 컨트롤러.\n\n# 단계 4: 컨트롤러 생성\n\n이제 모델을 설정했으니, 문서를 관리하고 파일 업로드를 처리하는 컨트롤러를 생성할 때입니다.\n\n```js\nrails generate controller Documents\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 문서를 업로드하고 표시하는 데 필요한 작업을 정의하겠습니다. app/controllers/documents_controller.rb에 위치한 DocumentsController 파일을 열어 다음 코드로 업데이트하세요:\n\n```js\nclass DocumentsController < ApplicationController\n  def new\n    @document = Document.new\n  end\n\n  def create\n    @document = Document.new(document_params)\n    if @document.save\n      redirect_to @document, notice: '문서가 성공적으로 업로드되었습니다.'\n    else\n      render :new\n    end\n  end\n\n  def show\n    @document = Document.find(params[:id])\n  end\n\n  private\n\n  def document_params\n    params.require(:document).permit(:title, :file)\n  end\nend\n```\n\n- new 액션: 이 액션은 새 Document 객체를 초기화합니다. 이것은 당신의 걸작을 위한 빈 캔버스를 설정하는 것과 같습니다. 여기서 미래의 OCR을 위해 파일을 업로드할 것입니다.\n- create 액션: 이 액션은 새 문서를 생성하는 작업을 처리합니다. 폼 (제목 및 파일)에서 매개변수를 가져와 새 Document 객체를 만들고 저장을 시도합니다. 저장에 성공하면 문서의 표시 페이지로 이동하여 성공 메시지가 표시됩니다. 실패한 경우 새 문서 양식을 다시 렌더링하여 실수를 수정할 수 있습니다. 이 액션에서 또한 파일 업로드를 처리합니다.\n- show 액션: 이 액션은 ID로 문서를 찾아서 표시합니다. 여기에서 마법이 일어날 것이지만, 현재는 파일을 표시만 합니다.\n\n# 단계 5: 뷰 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 뷰를 생성할 차례에요.\n\n아래 내용을 app/views/documents/new.html.erb에 추가해주세요:\n\n```js\n<!-- app/views/documents/new.html.erb -->\n<div class=\"min-h-screen bg-gray-100 flex items-center justify-center\">\n  <div class=\"bg-white p-8 rounded-lg shadow-md w-full max-w-md\">\n    <h2 class=\"text-2xl font-bold mb-6 text-center\">새 문서 업로드</h2>\n\n    <%= form_with model: @document, local: true, class: \"space-y-6\" do |form| %>\n      <% if @document.errors.any? %>\n        <div class=\"bg-red-100 text-red-700 p-4 rounded-lg\">\n          <h3 class=\"font-bold\">제출 과정에 오류가 있습니다:</h3>\n          <ul class=\"list-disc list-inside\">\n            <% @document.errors.full_messages.each do |message| %>\n              <li><%= message %></li>\n            <% end %>\n          </ul>\n        </div>\n      <% end %>\n\n      <div class=\"space-y-2\">\n        <%= form.label :title, class: \"block font-medium text-gray-700\" %>\n        <%= form.text_field :title, class: \"block w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500\" %>\n      </div>\n\n      <div class=\"space-y-2\">\n        <%= form.label :file, class: \"block font-medium text-gray-700\" %>\n        <%= form.file_field :file, class: \"block w-full px-4 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500\" %>\n      </div>\n\n      <div>\n        <%= form.submit \"문서 업로드\", class: \"w-full bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500\" %>\n      </div>\n    <% end %>\n  </div>\n</div>\n```\n\n그리고 app/views/documents/show.html.erb에 다음 내용을 추가해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<p>\n  <strong>Title:</strong>\n  <%= @document.title %>\n</p>\n\n<p>\n  <strong>File:</strong>\n  <%= link_to @document.file.filename.to_s, rails_blob_path(@document.file, disposition: \"attachment\") %>\n</p>\n\n# Step 6: 라우트 추가\n\n이 부분은 Rails가 대부분 처리하기 때문에 작은 단계입니다. config/routes.rb에 다음을 추가해보세요:\n\n```ruby\nRails.application.routes.draw do\n  resources :documents, only: [:new, :create, :show]\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 7: 스토리지 서비스 구성하기\n\n기본적으로 Active Storage는 파일을 저장하기위해 로컬 디스크를 사용합니다. config/storage.yml에서 Amazon S3, Google Cloud Storage 및 Microsoft Azure Blob Storage와 같은 다른 스토리지 서비스를 구성할 수 있습니다.\n\nActive Storage를 사용하면 구성 파일을 업데이트하여 이러한 스토리지 서비스 간에 쉽게 전환할 수 있습니다. 이 유연성을 통해 필요에 가장 적합한 스토리지 솔루션을 선택하고 애플리케이션이 성장함에 따라 확장할 수 있습니다.\n\n여기 우리 앱에서 사용할 구성입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n지금 이 작업을 해보세요. 터미널에 가서 앱을 시작해보세요.\n\n./bin/dev\n\n다음과 같은 내용이 나와야 합니다:\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<table> 태그를 Markdown 형식으로 변경하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신의 Gemfile에 Gem을 추가해보세요.\n\n```js\ngem 'rtesseract'\n```\n\n# 단계 9: OCR 메소드 구현하기\n\n문서 모델에 OCR을 수행하는 메소드를 만들어보세요. 아래와 같이 할 수 있어요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```rb\nclass Document < ApplicationRecord\n  has_one_attached :file\n\n  def perform_ocr\n    return unless file.attached?\n\n    file_path = ActiveStorage::Blob.service.send(:path_for, file.key)\n    image = RTesseract.new(file_path)\n    image.to_s\n  end\nend\n```\n\n# 단계 10: 컨트롤러 업데이트하여 OCR 사용\n\nOCR 수행을 위한 액션을 포함하도록 DocumentsController를 수정합니다:\n\n```rb\nclass DocumentsController < ApplicationController\n  def new\n    @document = Document.new\n  end\n\n  def create\n    @document = Document.new(document_params)\n    if @document.save\n      redirect_to @document, notice: '문서가 성공적으로 업로드되었습니다.'\n    else\n      render :new\n    end\n  end\n\n  def show\n    @document = Document.find(params[:id])\n    @ocr_text = @document.perform_ocr\n  end\n\n  private\n\n  def document_params\n    params.require(:document).permit(:title, :file)\n  end\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 11: OCR 텍스트 표시를 위한 뷰 업데이트\n\nshow.html.erb 뷰를 수정하여 OCR 텍스트를 표시합니다:\n\n```js\n<p>\n  <strong>제목:</strong>\n  <%= @document.title %>\n</p>\n\n<p>\n  <strong>파일:</strong>\n  <%= link_to @document.file.filename.to_s, rails_blob_path(@document.file, disposition: \"attachment\") %>\n</p>\n\n<% if @ocr_text.present? %>\n  <p>\n    <strong>OCR 텍스트:</strong>\n    <pre><%= @ocr_text %></pre>\n  </p>\n<% end %>\n```\n\n# 단계 12: Tesseract가 설치되었는지 확인하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시스템에 Tesseract OCR이 설치되어 있는지 확인해주세요. 다음 명령어를 사용하여 운영 체제에 맞게 설치할 수 있습니다:\n\n```js\nmacOS:\nbrew install tesseract\n\nUbuntu:\nsudo apt-get install tesseract-ocr\n```\n\n앱을 실행한 후에는 다음과 같은 결과가 나타납니다:\n\n![OCR 결과](/assets/img/2024-06-22-HowIbuiltanOCRSystemwithRails_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n텍스트에는 개선할 여지가 많이 있어요. 댓글로 의겢나 생각을 알려주세요.\n\n또한, 제 Github에서 전체 소스 코드를 확인하세요: https://github.com/luizcg/ocr\n","ogImage":{"url":"/assets/img/2024-06-22-HowIbuiltanOCRSystemwithRails_0.png"},"coverImage":"/assets/img/2024-06-22-HowIbuiltanOCRSystemwithRails_0.png","tag":["Tech"],"readingTime":12},{"title":"Rails 크론 잡 - Rails에서 작업 스케줄링 하는 방법","description":"","date":"2024-06-22 22:26","slug":"2024-06-22-RailsCronJobsTaskSchedulingInRails","content":"\n![image](/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png)\n\n언젠가 자동으로 작업을 예약해야 하는 상황에 처했던 적이 있나요? 매일 이메일을 보내거나 외부 API와 정기적으로 데이터를 동기화하는 것과 같은 작업들이 될 수 있습니다. 여기서 Cron 작업이 유용하게 사용됩니다. 이를 통해 이러한 작업들을 쉽게 자동화할 수 있습니다. 이 블로그에서는 예약된 작업을 실행하는 데 사용되는 Unix/Linux 시스템에 통합된 기본 소프트웨어인 Cron을 소개할 것입니다. 또한 Ruby Whenever Gem을 사용하여 특히 Rails 애플리케이션에서 Cron 작업을 쉽게 배포하는 빠른 가이드도 제공할 예정입니다.\n\n# Cron 작업이란?\n\nWhenever Gem을 사용한 Rails에서 Cron 작업을 사용하는 방법에 대해 설명하기 전에, cron 작업이 무엇인지 간단히 설명해 드리겠습니다. (이 주제에 대해 자세한 기사를 곧 쓸 것입니다)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단히 말해서, Cron은 특정 시간에 반복적으로 작업을 예약하고 실행할 수 있게 해주는 명령줄 도구입니다. 이러한 작업들을 'cron jobs'라고 합니다. Cron은 Linux/Unix 시스템에 내장되어 있기 때문에 추가적인 종속성을 설치할 필요가 없습니다. 일반적으로 cron jobs는 'crontab'이라는 파일에 작성됩니다. 'crontab'은 Cron Table의 약자입니다. crontab 작업/cron job의 구문은 다섯 개의 숫자로 구성되어 있으며 각각은 작업을 실행해야 하는 시간을 나타내며 그 뒤에 실행할 스크립트가 따릅니다. 구문은 다음과 같아야 합니다:\n\n```js\n# ┌───────────── 분 (0 - 59)\n# │ ┌───────────── 시간 (0 - 23)\n# │ │ ┌───────────── 일 (1 - 31)\n# │ │ │ ┌───────────── 월 (1 - 12)\n# │ │ │ │ ┌───────────── 요일 (0 - 6) (일요일부터 토요일까지;\n# │ │ │ │ │ 7는 일요일일 수도 있음)\n# │ │ │ │ │\n# │ │ │ │ │\n# * * * * * 실행할 명령어\n```\n\n아래 다이어그램은 구문을 잘 설명하고 있습니다:\n\n<img src=\"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_1.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레일즈 작업을 예약하는 데는 crontab을 사용할 수 있지만, 낡고 복잡하게 느껴질 수 있습니다. 이 프로세스는 다음 명령어를 사용하는 것을 포함합니다:\n\n```js\n0 * * * * 'cd path/to/project && bundle exec some_task'\n```\n\n# Whenever 젬\n\n이제 레일즈에서 cron 작업을 다루는 더 나은 방법에 대해 설명해 드리겠습니다. 전통적이고 다소 난잡한 crontab을 다루는 대신, 일정을 잡는 것이 훨씬 간편하고 우아한 루비 젬이 있습니다. 이 용도로 가장 많이 사용되는 젬은 Whenever입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n'Whenever'은 크론 작업을 설정하는 과정을 간소화하는 젬입니다. 크론탭을 수동으로 편집하는 대신 Whenever을 사용하여 루비 코드로 크론 작업을 작성할 수 있습니다. 이 젬은 크론탭을 자동으로 업데이트해줍니다.\n\n# Whenever 젬 설정하기\n\n이제 어플리케이션에 해당 젬을 설정하고 사용해봅시다. 먼저 젬을 설치해야 합니다. 아래와 같이 Gemfile에 젬을 포함시키고 bundle install을 실행하세요.\n\n```js\ngem 'whenever', require: false\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 젬을 초기화하기 위해 아래 명령을 실행해보세요.\n\n```js\nbundle exec .wheneverize\n```\n\n`.wheneverize` 명령을 실행하면 config 디렉토리, 구체적으로는 config/schedule.rb에 schedule.rb라는 이름의 파일이 생성됩니다. 이 파일은 작업 실행 시간을 정의하고 실행할 Rake 작업을 지정하는 역할을 합니다.\n\n이제 젬을 설정한 후 작업을 실제로 예약해 보겠습니다. 이를 위해서 Rake 작업을 만들어 시작하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n레일즈 g task batch send_messages\n```\n\n레일즈의 rake 태스크를 생성했다면, 해당 태스크 파일은 lib/tasks/sample.rb에 있을 거에요. 이제 이곳에 이메일을 보내는 기능을 추가해 보겠습니다.\n\n```js\n# lib/tasks/send_messages.rake\n\nnamespace :messages do\n  desc \"사용자에게 메시지 보내기\"\n  task send: :environment do\n    User.all.each do |user|\n      MessageMailer.send_message(user.email).deliver_now\n      puts \"#{user.email}님에게 메시지를 보냈습니다.\"\n    end\n  end\nend\n```\n\nRake 태스크에 로직을 추가했다면, schedular.rb 파일에 등록해 보세요. 여기서는 예시로 1분 간격으로 설정하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n매 분마다\n    rake 'messages:send'\nend\n```\n\n그런 다음 crontab을 업데이트하고 해당 작업을 추가할 것입니다. 아래 명령을 실행하여 작업을 추가하실 수 있습니다.\n\n```js\nwhenever --update-crontab\n```\n\nCron Job을 성공적으로 설정했습니다. 특정 시간에 실행되도록 예약되었습니다. 또한 whenever --clear-crontab 명령을 사용하여 crontab을 지울 수 있고, crontab을 보려면 crontab -l을 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Sidekiq-Cron Gem\n\nSidekiq-cron은 작업 처리 라이브러리인 Sidekiq의 애드온입니다. Sidekiq-cron을 사용하면 특정 시간이나 간격에 작업을 예약할 수 있습니다. Sidekiq-cron은 Sidekiq에서 제공하는 공식 젬이 아님을 유의해야 합니다.\n\nSidekiq에서 작업을 예약하는 것은 일반적으로 엔터프라이즈 수준의 기능으로 간주되어 유료 라이선스가 필요할 수 있습니다. 그러나 엔터프라이즈 버전에 돈을 쓰고 싶지 않다면 Sidekiq-cron은 여러분에게 적합한 대안입니다.\n\n간단히 말하면, Sidekiq-cron은 공식 엔터프라이즈 버전을 지불하지 않고도 Sidekiq 내에서 작업을 예약할 수 있게 해주는 도구입니다. 비슷한 예약 기능을 제공하여 작업이 언제와 얼마나 자주 실행되어야 하는지 지정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Sidekiq-Cron Gem 설정하기\n\n이제 우리의 애플리케이션에 Sidekiq-Cron 젬을 설정해 봅시다. 먼저 젬을 설치해야 합니다. Gemfile에 아래와 같이 젬을 추가하고 bundle install을 실행해주세요.\n\n```js\ngem 'sidekiq-cron'\n```\n\n그런 다음 config/ 디렉토리에 schedule.yml 파일을 생성하세요. Whenever 젬의 경우처럼 파일을 초기화하는 기능은 제공되지 않지만, 다행히 Sidekiq-Cron은 파일을 초기화하는 기능을 제공하지 않습니다. 또한 config/initializers 디렉토리에 sidekiq.rb라는 이름의 파일을 생성하여 아래 내용을 추가해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nschedule_file = \"config/schedule.yml\"\nif File.exist?(schedule_file) && Sidekiq.server?\n   Sidekiq::Cron::Job.load_from_hash YAML.load_file(schedule_file)\nend\n```\n\n우리의 초기 설정이 완료되었습니다. 이제 실제 작업을 생성할 차례입니다. 터미널로 이동하여 다음 명령을 입력하세요.\n\n```js\nrails generate job send_bulk_emails\n```\n\n그리고 이 코드에 일부 기능을 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고: 레일즈 백그라운드 작업/워커를 설정, 생성 및 사용하는 방법에 대한 자세한 튜토리얼이 필요하시다면 이 기사를 참조해주세요.\n\n```js\nclass SendBulkEmailJob < ApplicationJob\n  queue_as :default\n\ndef perform(emails)\n    begin\n      BulkEmailService.send_emails(emails)\n    rescue StandardError => e\n      Rails.logger.error \"Error sending bulk emails: #{e.message}\"\n      raise e\n    end\n  end\nend\n```\n\n작업을 만든 후, 터미널에 sidekiq을 입력하여 실행하고 다음과 같이 스케줄러 파일에 작업을 추가하세요:\n\n```js\nemail_job:\n   cron: \"*/5 * * * *\"\n   class: \"SendBulkEmailJob\"\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n워커를 실행하려면 터미널에서 새 탭을 열어주세요. 앱이 활성화된 상태에서도 워커가 계속 실행되어야 하는 점을 주의해 주세요. 레일즈 서버를 시작하거나 기타 작업을 실행해야 하는 경우 다른 탭으로 전환해야 합니다.\n\n모두입니다! 첫 번째 Sidekiq-cron 작업을 생성한 것을 축하드립니다!\n\n# 결론\n\n요약하면, 크론 작업은 Unix/Linux 시스템에서 반복적인 작업을 자동화하는 데 필수적입니다. Whenever 젬은 루비 코드로 작성하고 크론 작업을 예약하는 레일즈 애플리케이션에서 간단하게 사용할 수 있도록 하며 crontab을 자동으로 업데이트합니다. Sidekiq-Cron은 Sidekiq에서 작업을 예약하는 데 유용한 젬입니다. 두 젬은 크론 작업을 관리하고 실행하는 과정을 간소화하여 애플리케이션의 자동화와 효율성을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앞으로의 기사에서는 Rails가 어떻게 작동하는지에 대해 더 알아볼 것입니다. 그러니 계속해서 주의 깊게 지켜보고 배우세요!\n","ogImage":{"url":"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png"},"coverImage":"/assets/img/2024-06-22-RailsCronJobsTaskSchedulingInRails_0.png","tag":["Tech"],"readingTime":9}],"page":"33","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}