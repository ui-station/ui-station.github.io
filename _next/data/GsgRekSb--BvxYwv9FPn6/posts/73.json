{"pageProps":{"posts":[{"title":"Amazon Redshift의 디자인을 이해하는 데 다시 8시간을 보냈어요 내가 발견한 것은 여기 있어요","description":"","date":"2024-05-23 13:50","slug":"2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound","content":"\n## 레드시프트 학술 논문으로부터의 모든 통찰: 2022년에 새롭게 태어난 아마존 레드시프트\n\n- 역사와 배경\n- 고수준 아키텍처\n- 쿼리의 생애\n- 코드 생성\n- 컴파일 서비스\n- 저장\n- 컴퓨팅\n- 통합\n\n# 소개\n\n나이가 들수록 많은 것들을 잘못 알고 있었다는 것을 깨달았습니다. 아마존 레드시프트에 대해 잘못 생각한 것이 하나입니다. 레드시프트에 갇혀 거의 일 년을 보낸 후 구글 빅쿼리를 처음 사용했을 때, 빅쿼리가 5배 이상 더 발전된 기술이고(특히 빅쿼리의 서버리스 경험 때문에), 레드시프트보다 더 진보했다고 스스로에게 이야기했습니다. 그 인상은 세 년간 지속되었습니다. 돌이켜보면, 나 자신을 비웃으며 왜 그렇게 순진했는지 의문을 제기합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우수한 제품인 BigQuery, Redshift 또는 Snowflake와 같은 데이터베이스는 각각 하드웨어 제약 조건을 다루고 시스템 디자인 문제를 해결하는 고유한 방식이 있습니다. 어떤 데이터베이스가 더 빠른지 비교하는 대신에, 나는 그들의 내부 구현을 살펴가면서 가치 있는 것들을 배우는 것을 좋아해요. 이 기사는 Amazon Redshift에 대해 심층적으로 탐구한 결과물입니다 — 이전에 내가 무시했던 OLAP 시스템입니다.\n\n이 기사에서는 학술 논문 \"Amazon Redshift Re-invented (2022)\"에서 대부분의 자료를 사용할 것이며, 추가 참고 문서는 기사 끝에 포함될 것입니다.\n\n# 역사\n\nAmazon Redshift는 클라우드를 위해 설계된 열 지향적 대규모 병렬 처리 데이터 웨어하우스입니다. 이 시스템은 대규모 병렬 처리 (MPP) 데이터 웨어하우스 회사 ParAccel에서 기술을 기반으로 구축되었으며, 이후 Actian에 인수되었습니다. 이 시스템은 이전 버전인 PostgreSQL 8.0.2를 기반으로 구축되었으며, Redshift는 그 버전에 변경을 가했습니다. 초기 프리뷰 베타판은 2012년 11월에 출시되었고, 전체 버전은 2013년 2월 15일에 제공되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# High-level architecture\n\n![img](/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_0.png)\n\nRedshift 클러스터는 쿼리 실행을 처리하기 위해 여러 컴퓨팅 인스턴스로 구성됩니다. 각 클러스터는 단일 코디네이터 노드(=리더)와 여러 워커 노드를 가지고 있습니다.\n\n데이터는 Amazon S3를 기반으로 하는 Redshift 관리 스토리지(RMS)에 저장됩니다. Redshift가 쿼리를 처리할 때, 데이터는 압축된 컬럼 지향 형식으로 로컬 SSD에 있는 컴퓨팅 노드에 캐싱됩니다. (저의 제한된 지식으로는 이것이 Snowflake 저장 계층과 유사하다고 생각됩니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 데이터는 여러 버킷으로 분할되어 모든 워커 노드에 분산됩니다. Redshift는 데이터의 특성에 기반하여 파티션 스키마를 적용할 수도 있고, 사용자가 명시적으로 라운드로빈 또는 해시와 같은 원하는 파티션 스키마를 선언할 수도 있습니다.\n\n컴퓨팅과 스토리지 외에도 Redshift에는 다음과 같은 구성 요소가 있습니다 :\n\n- AQUA는 FPGA를 활용하여 쿼리 성능을 가속화하는 레이어입니다.\n- Compilation-As-A-Service는 생성된 코드(쿼리에서)를 위한 캐싱 서비스입니다.\n- Amazon Redshift Spectrum을 사용하면 Redshift에서 S3의 데이터를 직접 쿼리할 수 있습니다.\n\n# 쿼리의 생명주기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_1.png\" />\n\n아키텍처 구성 요소를 자세히 살펴보기 전에, Redshift 쿼리의 여정을 간단히 살펴보겠습니다:\n\n- 쿼리는 먼저 리더 노드에 \"안녕\"이라고 말합니다. 여기서 구문 분석, 재작성 및 최적화됩니다.\n- Redshift는 클러스터의 토폴로지를 사용하여 최적의 계획을 선택합니다. 계획 프로세스는 데이터 분포 정보도 활용하여 데이터 이동을 줄입니다.\n- 계획 단계 후 Redshift는 실행 단계로 이동합니다. 계획은 개별 실행 단위로 분할됩니다. 각 단위는 이전 단위의 중간 출력을 사용합니다. Redshift는 각 단위에 대해 최적화된 C++ 코드를 생성 및 컴파일하고 이 코드를 네트워크를 통해 컴퓨트 노드로 전송합니다.\n- 열 지향 데이터는 로컬 SSD에서 스캔되거나 Redshift 관리 스토리지에서 공급됩니다.\n\nRedshift 실행 엔진은 성능을 향상시키기 위해 여러 최적화 기술을 적용합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- zone-maps를 사용하는 것은 작은 해시 테이블이며 각 데이터 블록의 최소-최대 값을 저장합니다. (Snowflake와 BigQuery도 이렇게 합니다.)\n- 스캔 연산은 Vectorization 및 SIMD(단일 명령, 다중 데이터) 처리를 사용합니다.\n- 가벼운 압축 형식입니다.\n- 블룸 필터\n- 프리패칭\n- Redshift의 AZ64 압축.\n\n제가 Redshift 구성 요소에 대해 자세히 설명할 때 이러한 기술들을 다시 볼 수도 있습니다.\n\n# 코드 생성\n\nOLAP(On-Line Analytical Processing) 세계에서 쿼리 성능을 향상시키는 두 가지 주요 방법은 벡터화(Vectorization)와 코드 특수화(Code Specialization)입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nVectorization의 주요 아이디어는 하나의 레코드를 처리하는 대신, 엔진이 일괄(벡터) 값으로 처리한다는 것입니다.\n\n후자의 방식에서 엔진은 각 쿼리에 대해 코드를 생성하여 CPU 명령을 줄입니다. 코드 특수화를 적용하지 않는 시스템에서 각 연산자는 데이터 유형을 확인하고 입력 데이터 유형에 적합한 함수를 선택하기 위해 조건 블록(switch)을 통과해야 합니다. 코드 생성 방식은 실행 중에 해당 쿼리의 모든 연산자를 생성하기 때문에 이러한 과정을 피합니다.\n\nRedshift는 코드 생성 방식을 적용했습니다. 시스템은 쿼리 계획과 실행 스키마에 특정한 C++ 코드를 생성합니다. 생성된 코드는 컴파일되고, 바이너리가 실행을 위해 컴퓨팅 노드로 전달됩니다. 각 컴파일된 파일은 물리적 쿼리 계획의 일부인 세그먼트라고 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코드 생성을 적용했음에도 불구하고 Redshift는 생성된 코드에 SIMD-벡터화된 데이터 스캔 레이어를 추가합니다. 벡터화된 스캔 함수는 미리 컴파일되며 (실시간으로 생성되는 것이 아닌) Switch 문으로 모든 데이터 유형을 처리합니다. 이는 Redshift가 더 나은 데이터 스캔 성능을 달성하고 각 쿼리에 대해 컴파일해야 하는 내장 코드 양을 줄이는 데 도움이 됩니다.\n\n# 컴파일 서비스\n\n위 섹션에서 알 수 있듯이 Redshift는 쿼리 실행을 위해 컴파일된 최적화된 객체를 사용할 것입니다. 이러한 객체는 로컬 클러스터 캐시에 캐싱되므로 동일하거나 유사한 쿼리가 실행될 때 마다 컴파일된 객체가 재사용되어 실행 시간이 더 빨라집니다. Redshift가 쿼리를 컴파일할 필요가 없어지기 때문입니다. 이 전략은 필요한 컴파일된 객체가 로컬 캐시에 있는 경우에만 성능을 향상시킵니다. 그렇지 않은 경우 Redshift는 코드를 생성해야 하므로 지연이 발생합니다.\n\n<img src=\"/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2020년에 Redshift는 컴파일 서비스를 소개했어요 (만약 마일스톤에 관해 틀린 정보를 전달했다면 이를 수정해 주세요). 이 서비스는 클러스터 리소스 대신 별도의 리소스를 사용해요. 컴파일 서비스는 컴파일된 객체를 외부 캐시에 캐싱하여 Redshift가 여러 클러스터에 대해 캐시된 객체를 제공할 수 있게 해줘요.\n\n또한, 컴파일 서비스는 외부 컴파일 서비스의 병렬성을 활용하여 원하는 객체가 로컬 캐시나 외부 캐시에 없을 경우 코드를 더 빨리 컴파일할 수 있어요.\n\nRedshift 뒤에 있는 사람들은 다음을 관찰했어요:\n\n# CPU 친화적인 인코딩\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRedshift은 디스크에 압축된 데이터를 저장합니다. LZO 및 ZSTD와 같은 일반적인 압축 알고리즘 외에도 Redshift는 AZ64 알고리즘과 같은 최적화된 유형별 알고리즘을 지원합니다. 이 알고리즘은 숫자 및 날짜/시간 데이터 유형을 다루는 것으로, 2019년에 Amazon에서 소개되었습니다. AZ64은 높은 압축 비율을 달성하고 성능을 향상시키도록 설계되었습니다. AZ64는 ZSTD와 비슷한 압축률을 달성하지만 빠른 압축 해제 속도를 갖추고 있습니다.\n\n여기서 언급해야 할 멋진 점은 사용자가 AUTO 옵션(레드시프트가 데이터에 대한 압축을 자동으로 정의하도록 하는 옵션) 외에도 열 단위로 명시적으로 압축 체계를 정의할 수 있다는 것입니다. 게다가 한번 정의한 후에는 ALTER TABLE 절을 사용하여 압축 체계를 변경할 수 있습니다. 이것은 흥미로운 기능이라고 생각합니다. 사용자가 데이터에 대해 가장 이해하고 있으므로 유연한 압축 옵션을 허용하는 것이 데이터가 어떻게 저장되는지에 대한 더 나은 통제를 제공할 수 있을 것입니다. 그에 상응하여 더 많은 권한은 더 큰 책임을 의미합니다. 조심하지 않으면 나쁜 (압축) 선택이 성능과 비용에 악영향을 줄 수 있습니다. 내가 아는 한, Google은 BigQuery에서 이 기능을 허용하지 않습니다. Snowflake가 이를 지원하는지 알지 못하니 알고 계시면 의견을 남겨주세요.\n\n# 적응형 실행\n\nRedshift의 쿼리 엔진은 실행 통계에 따라 생성된 코드나 실행 속성을 조정하여 성능을 향상시키는 런타임 결정을 내립니다. 실행 중에 Bloom 필터를 사용하는 것은 Redshift의 동적 최적화의 대담한 예입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Amazon Redshift을 위한 AQUA\n\n<img src=\"/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_4.png\" />\n\nAdvanced Query Accelerator (AQUA)는 2021년에 Redshift에 의해 소개된 멀티 테넌시 서비스입니다. 이는 Redshift Managed Storage를 위한 캐싱 레이어 역할을 하며 복잡한 스캔 및 집계를 가속화합니다.\n\nAQUA는 지역 서비스인 Amazon S3에서 데이터를 가져오는 레이턴시를 피하고 Redshift의 캐시 스토리지에 데이터를 채우는 필요성을 줄이기 위해, 클러스터의 핫 데이터(여러 번 액세스되는 데이터)를 로컬 SSD에 캐싱합니다. Redshift는 입력 쿼리로부터 해당 스캔 및 집계 작업을 감지하고 이를 AQUA로 푸시하여 캐시된 데이터로 처리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아마존의 사람들은 AWS의 Nitro ASIC를 활용한 커스텀 서버를 설계하여 압축 및 암호화를 가속화하고, FPGAs를 사용하여 필터링 및 집합 연산의 실행 속도를 향상시키도록 했습니다.\n\n# 쿼리 재작성 프레임워크\n\nRedshift는 또한 두 가지 목표를 가진 새로운 쿼리 재작성 프레임워크(QRF)를 소개했습니다:\n\n- 연합, 조인 및 집계와 같은 연산의 실행 순서를 최적화하기 위한 재작성 규칙.\n- 점진적 재료화 뷰 쿼리 및 유지 관리를 위한 스크립트 작성. (곧 다룰 예정입니다)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 스토리지\n\n이 섹션에서는 Redshift의 스토리지 레이어인 Redshift Managed Storage부터 동시성 제어까지 살펴볼 것입니다.\n\n# Redshift Managed Storage (RMS)\n\nRA3 클러스터 유형이나 Redshift 서버리스를 선택할 때, 데이터는 RMS에 저장됩니다. 이 저장 레이어는 Amazon S3를 기반으로 하며, 특정 년도 동안 다중 존에서 99.999999999%의 내구성과 99.99%의 가용성을 달성합니다. RMS를 사용하면 데이터가 컴퓨팅 노드에서 분리되어 저장되므로 고객은 컴퓨팅과 스토리지를 독립적으로 확장하고 비용을 지불할 수 있습니다. RMS는 S3를 기반으로 하기 때문에 데이터 블록 온도 및 블록화와 같은 최적화를 사용하여 높은 성능을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRMS는 고대역 네트워킹을 제공하는 AWS Nitro 시스템 위에서 구축되었어요. RMS는 티어-1 캐시로 높은 성능의 SSD 기반 로컬 스토리지를 사용하고 있어요. Redshift는 자동으로 미세하게 데이터를 제거하고 지능적으로 데이터를 미리 가져오는 기술을 활용하여 로컬 SSD에서 최고의 성능을 얻으면서 S3의 무제한 확장성을 달성하고 있어요.\n\n![이미지](/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_5.png)\n\nRMS는 S3로부터 데이터 접근을 향상시키기 위해 데이터 블록을 메모리에 넣고 로컬 SSD에 캐시하는 미리가져오기 메커니즘을 사용하고 있어요. RMS는 관련 블록이 로컬에서 사용 가능하도록 유지하기 위해 캐시 대체를 조정하면서 모든 블록에 대한 액세스를 추적해요. 로컬 SSD 위의 캐시 레이어인 메모리 디스크 캐시 크기는 쿼리의 성능과 메모리 요구 사항을 균형있게 조정할 수 있도록 동적으로 변경될 수 있어요.\n\n테이블의 데이터는 데이터 슬라이스로 분할되어 논리적인 데이터 블록 체인으로 저장됩니다. 각 블록(크기 1MB)에는 식별, 테이블 소유권 또는 슬라이스 정보와 같은 정보가 포함된 헤더가 있어요. 블록은 메모리 내 구조인 슈퍼 블록을 사용하여 색인화돼요. 논문에 따르면 슈퍼 블록은 많은 파일 시스템과 유사한 특성을 가진 색인 구조입니다. 쿼리는 슈퍼 블록을 스캔하기 위해 존 맵을 사용하여 필요한 데이터 블록을 가져와요. 게다가 슈퍼 블록은 실행 중인 쿼리에 의해 처리된 데이터 블록을 위한 쿼리 추적 정보도 포함하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRMS는 Amazon S3로 트랜잭션을 동기화하여 여러 클러스터가 일관된 데이터에 액세스할 수 있게 해줍니다. 데이터는 쓰기 요청을 일괄 처리함으로써 다른 가용 영역에 걸쳐 S3에 쓰여집니다. 동시 클러스터는 동시 쓰기를 위해 필요할 때 요청되며 읽기는 스냅샷 분리에 의존합니다.\n\n메인 클러스터에서 데이터가 삭제되면 Redshift는 해당 데이터가 더 이상 쿼리에 필요하지 않음을 보장하고, 이 데이터를 개체 저장소의 가비지 컬렉터용으로 표시합니다. 데이터가 Amazon S3에 백업되어 있기 때문에 SSD가 고장나도 데이터는 손실되지 않습니다.\n\nAmazon S3는 또한 데이터 스냅샷을 저장합니다. 이러한 스냅샷은 복원 지점으로 작용합니다. Redshift는 전체 클러스터 데이터뿐만 아니라 개별 테이블의 데이터를 복원하는 것도 지원합니다. Amazon S3는 데이터 공유와 머신 러닝의 진실의 원천으로도 기능합니다.\n\n# 데이터 메타데이터 분리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n메타데이터와 데이터를 분리하면 Elastic Resize 및 Cross Instance Restore와 같은 프로세스를 구현하기가 더 쉬워집니다. 이 둘 다 메타데이터를 한 클러스터 구성에서 다른 클러스터 구성으로 이동해야 합니다.\n\nElastic Resize는 고객이 클러스터의 노드를 추가하여 성능을 향상시키거나 노드를 제거하여 비용을 절약할 수 있는 기능입니다. Cross-Instance Restore를 통해 사용자는 하나의 인스턴스 유형 클러스터에서 가져온 스냅샷을 다른 인스턴스 유형이나 다른 노드 수의 클러스터로 복원할 수 있습니다.\n\n이 프로세스의 구현 세부 정보는 다음과 같습니다:\n\n- 데이터의 사본이 Amazon S3에 저장되도록 보장합니다.\n- 재구성하기 전 Redshift는 클러스터의 데이터를 고려합니다. 데이터 이동을 최소화하는 재구성 계획을 수립하여 균형 잡힌 클러스터를 생성합니다.\n- 재구성하기 전에 Redshift는 데이터에 대한 카운트와 체크섬을 기록하고 완료 후 정확성을 검증합니다.\n- 복원의 경우 Redshift는 테이블 수, 블록 수, 행 수, 사용된 바이트 및 데이터 분포의 카운트를 기록하고 스냅샷과 함께 저장합니다. 복원 후에 카운트와 체크섬을 검증하고 새 쿼리를 수락하기 전에 확인합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 논문을 따르면:\n\n## 로컬 저장소의 한계를 넘어서\n\nRedshift는 무한한 확장성을 제공하기 위해 Amazon S3를 활용하며, 로컬 메모리와 SSD를 캐시로 사용합니다. (Snowflake와 같이).\n\n클러스터는 각 데이터 블록의 액세스 횟수에 따라 작업 데이터 세트를 로컬로 유지합니다. Tiered 캐시는 이 정보를 추적하는 역할을 합니다. 캐시는 두 단계로 구성됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_6.png)\n\n- Low level: This level stores cold data blocks. Every time the query accesses a data block, the system increases the block’s reference count.\n- High level: the cold blocks become hot (after being accessed multiple times), and the policy promotes data blocks to a high level.\n\nDuring eviction, the reference count of each block is decremented. When the reference count reaches zero, the block will be moved down to the low level or entirely evicted from the cache.\n\n(Sounds like Python object’s reference count, huh?)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRMS는 클러스터 재구성 후 로컬 SSD에 데이터를 다시 채우는 데 티어별 저장소 캐시를 사용합니다 (예 : Elastic Resize). 이와 같은 시나리오에서 컴퓨팅 노드는 고객 쿼리에서 가장 자주 액세스될 것으로 예상되는 데이터 블록을 로컬 디스크에 채웁니다.\n\n마지막으로, Redshift에는 메모리 내에서 가장 빈번하게 액세스되는 가장 뜨거운 블록을 유지하는 동적 디스크 캐시라는 또 다른 캐시 레이어가 있습니다. 또한 특정 쿼리에서 임시 블록을 저장합니다. 이 캐시는 메모리가 사용 가능할 때 자동으로 확장되고 시스템이 메모리 부족 상태가 되면 자동으로 축소됩니다.\n\n# 점진적 커밋\n\n비용을 절감하기 위해 RMS는 마지막 커밋과 비교하여 데이터 변경 사항만 캡처합니다. 이러한 변경 사항은 나중에 커밋 로그에 업데이트됩니다. Redshift의 로그 기반 커밋 프로토콜은 인메모리 구조를 영구 구조(디스크)로부터 분리하며, 각 슈퍼블록은 변경 사항의 로그입니다. 논문에서 가져온 내용:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 로그 구조화된 메타데이터는 일관된 데이터에 접근하여 로그를 적용함으로써 동시성 확장 및 데이터 공유와 같은 기능의 비용을 줄입니다.\n\n# 동시성 제어\n\nRedshift는 다중 버전 동시성 제어를 구현하여 읽기 프로세스가 다른 읽기 요청으로 블록되는 것을 방지합니다. 쓰기 요청은 다른 동시 쓰기 요청에 의해만 차단될 수 있습니다.\n\n각 트랜잭션은 트랜잭션이 시작되기 전에 모든 커밋된 트랜잭션에 의해 설정된 데이터베이스의 일관된 스냅샷을 볼 수 있습니다. 논문에서 Amazon은 스냅샷 격리 위에 Serial Safety Net (SSN)을 기반으로 한 새로운 디자인을 사용하여 엄격한 직렬화를 메모리 효율적인 방식으로 보장하는데 사용했습니다. 이 디자인은 이전에 커밋된 트랜잭션의 요약 정보만 사용하므로 엄격한 직렬화를 보장할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 계산\n\n아마존을 따라가는 레드시프트는 매주 수십억 개의 쿼리를 처리합니다. 사용자는 필요에 따라 계산 성능을 조절할 수 있는 다음 옵션 중 하나를 선택할 수 있습니다:\n\n# 클러스터 크기 확장\n\n![image](/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 설정을 통해 고객은 필요에 따라 클러스터에서 컴퓨팅 노드를 추가하거나 제거할 수 있습니다. 데이터를 섞는 대신, Elastic Resize는 데이터 파티션 할당(메타데이터만)을 분배하여 데이터 파티션을 노드 간에 조직화되고 균형 있게 유지합니다. 크기를 조정한 후, 컴퓨팅 노드의 로컬 캐시(SSD)는 할당 정보에 따라 S3에서 데이터를 받아 채웁니다. (Redshift는 핫 데이터에 우선순위를 둠)\n\n그러나 이로 인해 잠재적인 문제가 발생할 수 있습니다. 크기를 조정한 후, 각 노드가 담당하는 데이터의 수가 크기를 조정하기 이전과 다를 수 있으며, 이는 일관되지 않은 쿼리 성능을 초래할 수 있습니다. Redshift는 이를 다루기 위해 컴퓨팅 병렬성(작업자, 프로세스, 스레드 수)을 데이터 파티션과 분리합니다:\n\n![이미지](/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_8.png)\n\n- 컴퓨팅 병렬성이 `데이터 파티션의 수와 같은 경우, 개별 컴퓨팅 프로세스는 여러 데이터 파티션에서 작업합니다.\n- 컴퓨팅 병렬성이 `데이터 파티션의 수와 다른 경우, 여러 컴퓨팅 프로세스가 개별 데이터 파티션에서 작업을 공유합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRedshift은 공유 가능한 작업 단위 덕분에 이것을 달성합니다.\n\n## 동시성 스케일링\n\n이 구성은 OLAP 시스템의 전형적인 도전 과제 중 하나인 동시성을 다루는 데 도움을 줍니다. 사용자가 Redshift에서 더 많은 동시성 기능을 필요로 할 때 동적으로 확장됩니다.\n\n![이미지](/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_9.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nConcurrency Scaling을 사용하면 사용자는 쿼리를 제출하기 위한 단일 클러스터 활성 엔드포인트를 유지합니다. Redshift는 리소스가 완전히 활용되고 새로운 쿼리가 지속적으로 발생하는 것을 감지하면 자동으로 추가적인 Concurrency Scaling 컴퓨팅 클러스터를 추가합니다. 대기 중인 쿼리는 이러한 클러스터로 라우팅되어 처리됩니다. 또한 추가된 클러스터는 S3로부터 데이터를 로컬 디스크에 채웁니다.\n\n# 컴퓨팅 분리\n\nRedshift는 고객이 다른 Redshift 컴퓨팅 클러스터 및 AWS 계정 간에 데이터를 공유할 수 있도록 합니다. 컴퓨팅 클러스터는 단일 데이터 원본에 액세스할 수 있으며 ETL 파이프라인을 개발하거나 데이터 복사 비용을 부담할 필요가 없습니다.\n\n사용자는 스키마와 테이블부터 사용자 정의 함수(UDF)까지 다양한 수준에서 데이터를 공유할 수 있습니다. 다른 사람과 데이터를 공유하려면 데이터의 소유자(생산자)가 먼저 데이터 공유를 생성하고 사용자에게 액세스를 부여합니다. Redshift는 IAM 정책과 메타데이터를 사용하여 인증 및 권한 부여를 구현합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n고객은 메타데이터 요청을 사용하여 공유된 객체에 대한 쿼리를 공유합니다. 공유 데이터에 액세스하는 것이 인가된 고객만 서비스를 제공받을 수 있습니다. 각 요청은 디렉토리 서비스 및 프록시 레이어를 통해 전달됩니다. 프록시는 요청을 인증하고 승인하며 메타데이터 요청을 적절한 프로듀서로 라우팅합니다. 고객 측에서 메타데이터를 수신한 후에는 RMS에서 원하는 데이터를 읽고 쿼리를 처리합니다. 공유 데이터를 쿼리할 때의 캐시 프로세스는 변경되지 않습니다: 공유 데이터는 클러스터에 캐시되며 이후의 쿼리에서는 로컬로 데이터를 읽어옵니다.\n\n## 자동 튜닝 및 운영\n\n첫날부터 Redshift는 전통적인 데이터 웨어하우징 시스템(로컬 서버 및 데이터 센터 구축)과 비교하여 많은 측면을 간소화했습니다. 그럼에도, 일부 유지 관리 및 튜닝 작업은 경험 많은 데이터베이스 관리자가 필요합니다: 사용자는 성능 향상을 위해 명시적으로 vacuum 프로세스를 예약하거나 분산 또는 정렬 키를 결정해야 합니다.\n\n현재 Redshift는 고객 워크로드에 성능 영향을 미치지 않고 비주요 프로세스인 vacuuming, analyzing 또는 materialized views 새로고침을 자동으로 실행합니다. Redshift는 사용자 워크로드를 관찰하고 분석하여 성능 향상 기회를 식별하며, 예를 들어 워크로드에 대한 최적의 분산 및 정렬 키를 자동으로 지정하여 적용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, Redshift는 고급 예측 메커니즘을 활용하여 웜 풀을 통해 필요할 때 추가 노드를 가능한 빨리 사용할 수 있습니다. 이는 Snowflake의 사전 웜 워커 풀과 매우 유사하며, 노드 장애 또는 동시성 스케일링으로 인한 쿼리 대기 시간 및 다운타임을 줄입니다. 마지막으로, Amazon Redshift는 사용자 개입 없이 실행 및 스케일링이 쉬운 서버리스 옵션(예: Google BigQuery)을 제공합니다.\n\n# 자동 테이블 최적화\n\n분배 및 정렬 키와 같은 속성을 최적화하여 작업 부하의 성능을 최적화할 수 있습니다. 분배 키는 테이블 데이터가 클러스터 전체에 분배되는 방식을 나타내는 속성으로, 시스템이 병렬 리소스를 효율적으로 할당할 수 있도록 도와줍니다. 정렬 키는 하나 이상의 열을 기반으로 데이터를 정리하여 존 맵 인덱싱을 활용합니다. 존 맵은 데이터 단위의 최소값 및 최대값을 저장하는 인덱싱 구조로, 불필요한 데이터를 건너뛰는 데 매우 유용하며 데이터 정렬은 존 맵을 효율적으로 활용할 수 있습니다. (이건 BigQuery 클러스터링과 비슷하게 들리나요?)\n\n![Amazon Redshift 디자인을 이해하는 데 또 8시간을 보냈어요. 여기서 발견한 것들](/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_10.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n과거에는 이러한 키들이 사용자에 의해 명시적으로 정의되었습니다. 지금은 Redshift가 자동으로 Automatic Table Optimization (ATO)을 통해 이 프로세스를 처리합니다. ATO는 워크로드를 분석하여 최적의 분배 및 정렬 키를 추천합니다. 추천을 생성하기 위해 최적화된 쿼리 계획, 기본치, 및 예측 선택도와 같은 쿼리 실행 메타데이터를 주기적으로 수집합니다.\n\n목표와 함께 추천된 키들:\n\n- 분배 키: 데이터 이동 비용을 최소화하기 위해 시스템은 특정 워크로드의 모든 테이블을 조사하여 추천해야 합니다.\n- 정렬 키: 디스크에서 읽어야 하는 데이터 양을 줄이기 위해.\n\n추천을 받은 후, Redshift는 고객들에게 두 가지 옵션을 제공합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 콘솔을 통한 수동 적용.\n- 자동 백그라운드 워커가 권장 사항을 적용합니다. 이 워커는 설정을 점진적으로 적용하고 클러스터가 너무 바쁘지 않을 때에만 작업을 실행합니다.\n\n# 자동 워크로드 관리\n\nRedshift의 자동 워크로드 관리자(AutoWLM)는 입장 제어, 스케줄링 및 자원 할당을 담당합니다. 쿼리를 수신한 후 AutoWLM은 실행 계획과 최적화된 통계를 벡터 형식으로 변환합니다. 그런 다음 Redshift는 해당 벡터를 ML 모델로 넣어 컴파일 및 실행 시간을 예측합니다. Redshift는 모델의 결과를 사용하여 예측된 실행 시간을 기반으로 쿼리를 대기열에 넣습니다. 추정된 메모리 요구량(모델에 의해 예측됨)이 사용 가능한 메모리 풀에서 충족될 때만 쿼리가 실행 단계로 진행됩니다. 또한 자원 이용률이 너무 높다고 감지될 때 AutoWLM은 병행성 비율을 제한하여 쿼리 대기 시간을 피합니다.\n\nAutoWLM은 스케줄링에 가중 라운드로빈 메커니즘을 활용하여 우선순위가 더 높은 쿼리를 우선적으로 더 자주 스케줄링합니다. 또한 SLA를 준수해야 하는 높은 우선순위 쿼리는 하드웨어 자원의 더 큰 할당을 받습니다. Redshift는 서로 다른 우선순위를 갖는 쿼리가 동시에 실행될 때 CPU 및 I/O를 지수함수적으로 감소하는 부분으로 분할합니다. 이는 높은 우선순위 쿼리를 낮은 우선순위 쿼리보다 지수함수적으로 빠르게 부스트합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하위 우선순위 쿼리 뒤에 높은 우선순위 쿼리가 오면 AutoWLM은 상위 우선순위 쿼리에 공간을 확보하기 위해 하위 우선순위 쿼리에서 리소스를 회수합니다. 낮은 우선순위 쿼리에서 리소스 고갈을 방지하기 위해 시스템에 의해 리소스가 회수되는 확률이 각 빼앗애질 때마다 줄어듭니다. 결과적으로 리소스가 고갈되면 Redshift는 상위 우선순위 리소스를 제공하기 위해 하위 우선순위 쿼리를 대기열에 넣습니다.\n\n# 쿼리 예측 프레임워크\n\n위 섹션에서 언급했듯이 AutoWLM은 메모리 소비량이나 실행 시간과 같은 메트릭을 예측하기 위해 머신 러닝 모델을 사용합니다. Redshift의 쿼리 예측 프레임워크는 이러한 모델을 유지하는 역할을 합니다. 이 프레임워크는 Redshift 클러스터에서 실행되며 데이터를 수집하고 XGBoost 모델로 훈련을 하며 필요할 때 결과를 출력합니다. 클러스터에서 프레임워크를 실행함으로써 변화하는 워크로드에 빠르게 적응할 수 있습니다. 위에서 언급한 코드 컴파일 서비스도 최적화를 위해 쿼리 예측 프레임워크를 사용합니다.\n\n# 자료화된 뷰\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image description](/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_11.png)\n\nSQL 뷰와 Materialize View (MV)은 쿼리 결과를 테이블처럼 나타내는 방법을 제공합니다. View와는 달리, MV는 데이터를 디스크에 물리적으로 유지하므로 MV에서 데이터를 쿼리할 때 실행 시간이 빨라집니다. Redshift는 MV 관리를 다음과 같이 자동화합니다:\n\n- 기본 테이블의 변경 사항을 반영하여 필터, 선택, 그룹화 및 조인을 점진적으로 유지합니다.\n- 유지 관리 시간을 자동화합니다: Redshift는 어떤 MV를 새로 고쳐야 하는지 감지합니다. 이는 쿼리 워크로드에서 MV의 유틸리티 및 MV 새로 고침 비용 두 가지 요소를 사용하여 수행됩니다.\n- MV를 통해 쿼리를 자동으로 다시 작성하여 최적의 성능을 달성합니다. 점진적 유지 관리 및 쿼리 다시 작성은 \"쿼리 다시 작성 프레임워크\" 섹션에서 언급된 프레임워크를 사용합니다.\n\n# 스마트 웜 풀\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라우드 시대에는 하드웨어 고장이 더 이상 예외가 아닙니다. 머신 고장으로 인한 성능 저하를 방지하기 위해 Redshift는 스마트 웜 풀 아키텍처(컴퓨팅 머신이 서비스되기 전에 미리 웜업됨)를 사용합니다. 이 아키텍처는 많은 프로세스에서 효율성을 제공합니다: 실패한 노드 교체, 클러스터 재개, 자동 동시성 스케일링...\n\n![image](/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_12.png)\n\n웜 풀은 사전 설치된 소프트웨어와 네트워킹 구성을 갖춘 EC2 컴퓨트 인스턴스 그룹입니다. 각 지역마다 AWS 가용 영역마다 별도의 웜 풀이 위치해 있습니다. 작업을 낮은 지연 시간으로 유지하기 위해서는 웜 풀에서 노드를 획득할 때 높은 히트율이 필요합니다. Redshift는 머신러닝 모델을 사용하여 특정 시점에서 필요한 EC2 인스턴스 수를 예측합니다. 시스템은 각 지역과 가용 영역에서 웜 풀을 동적으로 조정하여 인프라 비용을 절약합니다.\n\n# 통합\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내장형인 AWS Redshift는 Amazon 클라우드 서비스 생태계의 혜택을 크게 누립니다. 여기에는 Redshift의 통합 옵션 몇 가지가 있습니다.\n\n- Amazon Redshift Spectrum을 사용하면 S3에서 데이터를 직접 쿼리할 수 있습니다. 이 기능은 대규모 Scale-Out 처리를 제공하여 Parquet, Text, ORC 및 AVRO 형식의 데이터를 스캔하고 집계합니다.\n- Amazon Sagemaker와 함께하는 Redshift ML을 사용하면 SQL을 사용하여 기계 학습 모델을 학습하고 예측하는 것이 쉬워집니다. Redshift ML은 Amazon SageMaker를 활용하여 모델을 학습한 뒤 SQL 함수로 노출하고 사용자는 SQL을 사용하여 직접 사용할 수 있습니다\n- Redshift Federated Query를 사용하면 Redshift가 고객의 OLTP 데이터베이스 (Postgres, MySQL 등)에 직접 연결하여 데이터를 가져올 수 있습니다. 이 편리한 기능으로 ETL 파이프라인을 통해 OLTP 출처에서 데이터를 추출할 필요가 없어집니다.\n- 슈퍼 스키마리스 처리: SUPER 반구조화 형식은 스키마가 없는 중첩 데이터를 포함할 수 있습니다. SUPER 형식의 값은 Redshift 문자열 및 숫자 스칼라, 배열 및 구조체로 구성될 수 있습니다. 사용자는 SUPER 유형을 사용할 때 미리 스키마를 정의할 필요가 없습니다. Redshift의 동적 형식 지정은 중첩 데이터를 감지할 수 있습니다.\n- Lambda와 함께하는 Redshift: Redshift는 AWS Lambda 코드를 지원하는 사용자 정의 함수(UDF)를 지원합니다. Lambda UDF는 Java, Go, PowerShell, Node.js, C#, Python 및 Ruby로 작성할 수 있습니다.\n\n# 마무리\n\n조금 긴 글이었죠? 이 글이 제 가장 긴 글입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제목에 언급된 \"8시간\"에도 불구하고, 이 블로그를 마무리하는 데 거의 일주일이 걸렸어요. Redshift 논문은 많은 새로운 내용을 제공해서 조금 힘들었죠. 게다가, 이번에는 코드 특화 접근 방식을 선택한 OLAP 시스템을 연구한 것이 처음이라서 (이전에 공부한 시스템들은 모두 벡터화를 사용했어요: BigQuery, Snowflake, DuckDB).\n\n코드 특화 외에도, Redshift의 주요 기능으로는 컴파일 서비스, Redshift 관리 스토리지, 그리고 데이터베이스 운영을 위해 머신 러닝을 적용한 것이 언급할만해요. 게다가, Redshift의 웜 풀 아키텍처는 Snowflake의 사전 웜 풀과 유사한데, 두 솔루션이 모두 컴퓨팅 스케일링의 지연 시간을 최소화하려고 노력하지만, Redshift의 경우는 머신 러닝 모델을 활용해서 작동한다는 점이 다르죠.\n\n지금은 Redshift가 백그라운드 작업에 머신 러닝을 명시적으로 사용한다는 유일한 시스템인 것으로 보여요. Snowflake나 BigQuery는 이를 언급하지 않았죠. (제가 놓친 부분이 있다면 알려주세요)\n\n이제 이만 헤어집니다. 다음 주에 또 만나요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 자료\n\n논문: Amazon Redshift Re-invented — 2022\n\n문서: Amazon Redshift 공식 문서\n\nPowerPoint 프레젠테이션: Amazon Redshift에 대한 심층 학습 및 모범 사례\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 뉴스레터는 매주 블로그 형식의 이메일로, 내가 더 똑똑한 사람들로부터 배운 것들을 정리해 두는 공간입니다.\n\n그러니 나와 함께 배우고 성장하고 싶다면 여기에서 구독해 주세요: https://vutr.substack.com.\n","ogImage":{"url":"/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_0.png"},"coverImage":"/assets/img/2024-05-23-Ispentanother8hoursunderstandingthedesignofAmazonRedshiftHereswhatIfound_0.png","tag":["Tech"],"readingTime":27},{"title":"유튜브에서 배우는 LLMs 사용하기","description":"","date":"2024-05-23 13:47","slug":"2024-05-23-UsingLLMstoLearnFromYouTube","content":"\n![Using LLMs to Learn From YouTube](/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_0.png)\n\n# 소개\n\n팟캐스트나 시청하고 싶은 비디오를 만나본 적이 있나요? 하지만 길이 때문에 시간을 내기 어려워한 적이 있나요? 이러한 형태의 내용의 특정 부분을 다시 참조할 수 있는 쉬운 방법을 바란 적이 있나요?\n\n저는 The Diary of a CEO와 같은 인기 팟캐스트의 YouTube 비디오들에 관해 많은 시간을 할애하기 어려운 문제에 직면해왔습니다. 사실 이러한 팟캐스트에서 다루는 많은 정보들은 빠른 구글 검색을 통해 손쉽게 찾을 수 있습니다. 그러나 저자가 열정적으로 어떤 것에 대한 견해를 표현하거나 성공한 기업가의 경험을 그들의 관점에서 듣는 것은 훨씬 더 통찰력과 명확함을 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 문제로 동기부여 받으면서 LLM(언어 모델)을 기반으로 한 애플리케이션 및 개발에 대해 배우고 싶어졌습니다. 그래서 YouTube 동영상의 내용에 관한 질문을 할 수 있는 챗봇을 구축하기로 결정했습니다. 이 프레임워크인 RAG(Retrieval Augmented Generation)를 사용했습니다. 이후에, 이 어플리케이션을 LangChain, Pinecone, Flask, React를 사용하여 개발하고 AWS에 배포하는 경험에 대해 이야기하겠습니다:\n\n# 백엔드\n\nLLM이 사용자 정의 질문에 답변을 생성하는 소스로 YouTube 동영상의 대본을 사용할 것입니다. 이를 용이하게 하기 위해, 백엔드는 이를 실시간으로 검색하고 적절히 저장하여 사용할 수 있는 방법과 답변 생성에 사용할 수 있게 하는 방법이 필요합니다. 또한 사용자가 나중에 참조할 수 있도록 채팅 기록을 저장하는 방법도 있으면 좋겠습니다. 이제 이러한 요구 사항을 모두 충족시키기 위해 백엔드를 개발하는 방법에 대해 살펴보겠습니다.\n\n## 응답 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 대화형 질문 응답 도구는 관련 컨텍스트와 채팅 기록을 모두 고려하여 질문에 대한 응답을 생성할 수 있어야 합니다. 이는 아래에 설명된대로 대화 기억을 갖춘 데이터 검색 확장 생성을 사용하여 달성할 수 있습니다:\n\n![image](/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_1.png)\n\n불분명한 부분을 명확히 하기 위해 다음과 같은 단계가 포함됩니다:\n\n- 질문 요약: 현재 질문과 채팅 기록을 적절한 프롬프트를 사용하여 단독 질문으로 요약합니다. 이를 위해 LLM에게 요청합니다.\n- 의미 검색: 다음으로, 이러한 축약된 질문과 가장 관련성 있는 YouTube 대본 청크를 검색해야 합니다. 대본 자체는 단어 및 구의 수치적 표현인 임베딩으로 저장되어 있습니다. 이 임베딩은 내용과 의미를 포착하는 임베딩 모델에 의해 학습되었습니다. 의미 검색 중에는 임베딩이 축약된 질문의 임베딩과 가장 유사한 각 대본 구성 요소를 검색합니다.\n- 컨텍스트 인식 생성: 이러한 검색된 대본 청크는 다시 LLM에게 다른 프롬프트로 사용되어 축약된 질문에 대답하도록 요청됩니다. 축약된 질문을 사용하면 생성된 답변이 현재 질문 및 채팅 중 사용자가 이전에 물었던 질문과 관련이 있는지 보장됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 데이터 파이프라인\n\n이미 설명된 프로세스의 구현 단계에 들어가기 전에, YouTube 비디오 트랜스크립트 자체에 집중해 보겠습니다. 언급했듯이, RAG 프로세스의 시맨틱 검색 단계에서 효율적으로 검색하고 검색될 수 있도록 이들을 임베딩으로 저장해야 합니다. 이제 이를 위한 소스, 검색 방법 및 저장 방법을 살펴보겠습니다.\n\n- 소스: YouTube는 비디오 ID 및 자동 생성된 트랜스크립트와 같은 메타데이터에 액세스할 수 있도록 Data API를 제공합니다. 첫 번째로, 다양한 돈 전문가와 기업가가 개인 재무, 투자, 성공적인 비즈니스 구축에 대해 논의하는 The Diary of a CEO 팟캐스트 플레이리스트를 선택했습니다.\n- 검색: YouTube 비디오의 비디오 ID와 같은 메타데이터를 검색하는 데 책임 있는 한 클래스와, youtube-transcript-API Python 패키지를 사용하여 비디오 트랜스크립트를 검색하는 데 책임 있는 다른 클래스를 활용합니다. 이 트랜스크립트는 그들의 원시 형태로 JSON 파일로 저장됩니다.\n- 저장: 그런 다음, 트랜스크립트를 임베딩으로 변환하고 벡터 데이터베이스에 저장해야 합니다. 그러나 이 단계의 사전 조건은 각 질문에 가장 관련성 높은 텍스트 세그먼트를 얻는 동시에 LLM 프롬프트의 길이를 최소화하기 위해 이를 청크로 분할해야 한다는 것입니다. 이 요구 사항을 충족시키기 위해 본 요구 사항을 만족시키기 위해 본 사용자 정의 S3JsonFileLoader 클래스를 정의하고(상자 밖의 문제로 인해 일부 문제가 발생함), 텍스트 분할 객체를 사용하여 트랜스크립트를 로드할 때 분할합니다. 그런 다음, 오픈AI의 gpt-3.5-turbo 모델이 예상하는 임베딩으로 트랜스크립트 청크를 저장하기 위해 LangChain의 인터페이스를 이용하여 선택한 Vectorstore인 Pinecone Vectorstore에 연결합니다:\n\n```js\nimport os\n\nimport pinecone\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\nfrom langchain.vectorstores import Pinecone\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.embeddings.openai import OpenAIEmbeddings\n\nfrom chatytt.embeddings.s3_json_document_loader import S3JsonFileLoader\n\n# 트랜스크립트를 청크로 나누기 위한 스플리터 정의\ntext_splitter = RecursiveCharacterTextSplitter(\n    chunk_size=pre_processing_conf[\"recursive_character_splitting\"][\"chunk_size\"],\n    chunk_overlap=pre_processing_conf[\"recursive_character_splitting\"][\n        \"chunk_overlap\"\n    ],\n)\n\n# 트랜스크립트 로드 및 분할\nloader = S3JsonFileLoader(\n    bucket=\"s3_bucket_name\",\n    key=\"transcript_file_name\",\n    text_splitter=text_splitter,\n)\ntranscript_chunks = loader.load(split_doc=True)\n\n# 관련 Pinecone 벡터스토어에 연결\npinecone.init(\n    api_key=os.environ.get(\"PINECONE_API_KEY\"),\n    environment=\"gcp-starter\"\n)\npinecone_index = pinecone.Index(os.environ.get(\"INDEX_NAME\"), pool_threads=4)\n\n# Pinecone에 트랜스크립트 청크를 임베딩으로 저장\nvector_store = Pinecone(\n    index=pinecone_index,\n    embedding=OpenAIEmbeddings(),\n    text_key=\"text\",\n)\nvector_store.add_documents(documents=transcript_chunks)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 주기적으로 실행되도록 구성된 워크플로를 이용하여 이러한 단계를 자동화하기 위해 몇 가지 AWS 서비스를 활용할 수도 있습니다. 저는 위에서 언급한 세 가지 단계마다 별도의 AWS Lamba 함수(필요한 리소스를 런타임에 필요에 따라 프로비저닝 및 활용하는 서버리스 컴퓨팅 형태)를 구현하고, 이러한 함수의 실행 순서를 AWS Step Functions(서버리스 오케스트레이션 도구)를 사용하여 정의합니다. 그런 다음, 이 워크플로는 매주 한 번 실행되도록 설정한 Amazon EventBridge 일정에 의해 실행됩니다:\n\n![이미지](/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_2.png)\n\n## RAG 구현\n\n이제 우리가 선택한 재생 목록의 대본이 주기적으로 검색되고 임베딩으로 변환되어 저장되고 있는데, 이제 응용 프로그램의 핵심 백엔드 기능 구현으로 이동할 수 있습니다. 즉, 사용자 정의 질문에 대한 답변을 생성하는 프로세스를 구현해야 합니다. 다행히 LangChain은 이 작업을 완벽하게 수행하는 ConversationalRetrievalChain을 기본 제공합니다! 필요한 것은 쿼리, 채팅 기록, 대본 청크를 검색하는 데 사용할 수 있는 벡터 저장소 개체 및 선택한 LLM을 이 체인에 전달하는 것뿐입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport pinecone\nfrom langchain.vectorstores import Pinecone\nfrom langchain.chat_models import ChatOpenAI\nfrom langchain.embeddings.openai import OpenAIEmbeddings\n\n# 세맨틱 검색을 수행할 벡터 저장소를 정의합니다. 이를 위해 Pinecone 벡터 데이터베이스에 대해 세맨틱 검색을 수행합니다.\npinecone.init(\n    api_key=os.environ.get(\"PINECONE_API_KEY\"), environment=\"gcp-starter\"\n)\npinecone_index = pinecone.Index(os.environ.get(\"INDEX_NAME\"), pool_threads=4)\nvector_store = Pinecone(\n    index=pinecone_index,\n    embedding=OpenAIEmbeddings(),\n    text_key=\"text\",\n)\n\n# RAG에서 대화 기억을 갖고 있는 단계를 수행할 검색 연쇄를 정의합니다.\nchain = ConversationalRetrievalChain.from_llm(\n    llm=ChatOpenAI(), retriever=vector_store.as_retriever()\n)\n\n# 현재 질문과 채팅 이력을 전달하여 체인을 호출합니다.\nresponse = chain({\"question\": query, \"chat_history\": chat_history})[\"answer\"]\n```\n\n## 채팅 이력 저장\n\n백엔드는 이제 질문에 대한 답변을 생성할 수 있지만 사용자가 이전 채팅 내용을 참조할 수 있도록 채팅 이력을 저장하고 검색할 수도 있으면 좋을 것입니다. 이는 동일한 항목에 대한 다른 사용자의 액세스 패턴을 알려진 대로 처리하는 NoSQL 데이터베이스인 DynamoDB를 사용하기로 결정했습니다. 이 데이터베이스는 이러한 형식의 비구조적 데이터를 처리하는 빠른 속도와 비용 효율성으로 알려져 있습니다. 추가로 boto3 SDK는 데이터베이스와 상호 작용을 단순화하여 저장 및 검색에 몇 가지 함수만 필요합니다:\n\n```js\nimport os\nimport time\nfrom typing import List, Any\n\nimport boto3\n\ntable = boto3.resource(\"dynamodb\").Table(os.environ.get(\"CHAT_HISTORY_TABLE_NAME\"))\n\ndef fetch_chat_history(user_id: str) -> str:\n    response = table.get_item(Key={\"UserId\": user_id})\n    return response[\"Item\"]\n\n\ndef update_chat_history(user_id: str, chat_history: List[dict[str, Any]]):\n    chat_history_update_data = {\n        \"UpdatedTimestamp\": {\"Value\": int(time.time()), \"Action\": \"PUT\"},\n        \"ChatHistory\": {\"Value\": chat_history, \"Action\": \"PUT\"},\n    }\n    table.update_item(\n        Key={\"UserId\": user_id}, AttributeUpdates=chat_history_update_data\n    )\n\n\ndef is_new_user(user_id: str) -> bool:\n    response = table.get_item(Key={\"UserId\": user_id})\n    return response.get(\"Item\") is None\n\n\ndef create_chat_history(user_id: str, chat_history: List[dict[str, Any]]):\n    item = {\n        \"UserId\": user_id,\n        \"CreatedTimestamp\": int(time.time()),\n        \"UpdatedTimestamp\": None,\n        \"ChatHistory\": chat_history,\n    }\n    table.put_item(Item=item)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## API를 통해 로직 노출하기\n\n이제 모든 핵심 기능을 다루었지만 사용자가 상호작용하는 앱의 클라이언트 측은 이러한 프로세스를 트리거하고 활용하는 방법이 필요합니다. 이를 용이하게하기 위해 Flask API 내의 각 로직 조각(응답 생성, 채팅 기록 저장, 채팅 기록 검색)은 개별 엔드포인트를 통해 노출되며, 프론트 엔드에서 호출될 것입니다:\n\n```js\nfrom dotenv import load_dotenv\nfrom flask import Flask, request, jsonify\nfrom flask_cors import CORS\n\nfrom chatytt.chains.standard import ConversationalQAChain\nfrom chatytt.vector_store.pinecone_db import PineconeDB\nfrom server.utils.chat import parse_chat_history\nfrom server.utils.dynamodb import (\n    is_new_user,\n    fetch_chat_history,\n    create_chat_history,\n    update_chat_history,\n)\n\nload_dotenv()\napp = Flask(__name__)\n\n# 서버와 클라이언트가 각각 호스팅되므로 Cross Origin Resource Sharing을 활성화\nCORS(app)\n\npinecone_db = PineconeDB(index_name=\"youtube-transcripts\", embedding_source=\"open-ai\")\nchain = ConversationalQAChain(vector_store=pinecone_db.vector_store)\n\n@app.route(\"/get-query-response/\", methods=[\"POST\"])\ndef get_query_response():\n    data = request.get_json()\n    query = data[\"query\"]\n\n    raw_chat_history = data[\"chatHistory\"]\n    chat_history = parse_chat_history(raw_chat_history)\n    response = chain.get_response(query=query, chat_history=chat_history)\n\n    return jsonify({\"response\": response})\n\n\n@app.route(\"/get-chat-history/\", methods=[\"GET\"])\ndef get_chat_history():\n    user_id = request.args.get(\"userId\")\n\n    if is_new_user(user_id):\n        response = {\"chatHistory\": []}\n        return jsonify({\"response\": response})\n\n    response = {\"chatHistory\": fetch_chat_history(user_id=user_id)[\"ChatHistory\"]}\n\n    return jsonify({\"response\": response})\n\n\n@app.route(\"/save-chat-history/\", methods=[\"PUT\"])\ndef save_chat_history():\n    data = request.get_json()\n    user_id = data[\"userId\"]\n\n    if is_new_user(user_id):\n        create_chat_history(user_id=user_id, chat_history=data[\"chatHistory\"])\n    else:\n        update_chat_history(user_id=user_id, chat_history=data[\"chatHistory\"])\n\n    return jsonify({\"response\": \"chat saved\"})\n\n\nif __name__ == \"__main__\":\n    app.run(debug=True, port=8080)\n```\n\n마지막으로, 세 개의 엔드포인트를 하나의 함수로 래핑하여 AWS Lambda를 사용하고, API Gateway 리소스에 의해 트리거되는 방식으로 요청을 올바른 엔드포인트로 보내도록 하는 방법을 설명합니다. 이제 이 설정의 흐름은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 이 전체에 사용되는 각 섹션에 대한 전용 기능 컴포넌트를 활용하여 채팅 봇 애플리케이션에서 기대할 수 있는 모든 일반 요구 사항을 다룹니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 사용자 입력을 보내는 채팅 버튼이 있는 컨테이너입니다.\n- 사용자 입력 및 답변이 표시되는 채팅 피드가 있습니다.\n- 채팅 기록, 새로운 채팅 버튼 및 채팅 저장 버튼이 있는 사이드바가 있습니다.\n\n이 컴포넌트들 간의 상호작용과 데이터 흐름은 아래와 같이 설명됩니다:\n\n![Components Interaction](/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_4.png)\n\n세 가지 엔드포인트로의 API 호출 및 클라이언트 측에서 관련 변수의 상태 변경은 각각의 기능 컴포넌트에서 정의됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 질문마다 생성된 답변을 가져오는 논리:\n\n```js\nimport React from \"react\";\nimport {chatItem} from \"./LiveChatFeed\";\n\ninterface Props {\n    setCurrentChat: React.SetStateAction<any>\n    userInput: string\n    currentChat: Array<chatItem>\n    setUserInput: React.SetStateAction<any>\n}\n\nfunction getCurrentChat({setCurrentChat, userInput, currentChat, setUserInput}: Props){\n    // 현재 채팅은 라이브 채팅 피드에 표시됩니다. LLM 응답을 기다리기 전에\n    // 사용자 질문을 제공하기 위해 API에 대답을 요청하기 전에 복사하여\n    // 별도 변수에 전달하고 현재 채팅에 추가합니다.\n    const userInputText = userInput\n    setUserInput(\"\")\n    setCurrentChat([\n        ...currentChat,\n        {\n            \"text\": userInputText,\n            isBot: false\n        }\n    ])\n\n    // 포스트 요청을 위한 API 페이로드 생성\n    const options = {\n        method: 'POST',\n        headers: {\n            \"Content-Type\": 'application/json',\n            'Accept': 'application/json'\n        },\n        body: JSON.stringify({\n            query: userInputText,\n            chatHistory: currentChat\n        })\n    }\n\n    // 엔드포인트에 핑을 보내 응답을 기다린 후 현재 채팅에 추가하여\n    // 라이브 채팅 피드에 표시\n    fetch(`${import.meta.env.VITE_ENDPOINT}get-query-response/`, options).then(\n        (response) => response.json()\n    ).then(\n        (data) => {\n            setCurrentChat([\n                ...currentChat,\n                {\n                    \"text\": userInputText,\n                    \"isBot\": false\n                },\n                {\n                    \"text\": data.response,\n                    \"isBot\": true\n                }\n            ])\n        }\n    )\n}\n\nexport default getCurrentChat\n```\n\n2. 사용자가 채팅 저장 버튼을 클릭할 때 채팅 기록을 저장하는 방법:\n\n```js\nimport React, {useState} from \"react\";\nimport {chatItem} from \"./LiveChatFeed\";\nimport saveIcon from \"../assets/saveicon.png\"\nimport tickIcon from \"../assets/tickicon.png\"\n\ninterface Props {\n    userId: String\n    previousChats: Array<Array<chatItem>>\n}\n\nfunction SaveChatHistoryButton({userId, previousChats}: Props){\n    // 현재 채팅이 저장되었는지 여부를 결정하는 상태 정의합니다.\n    const [isChatSaved, setIsChatSaved] = useState(false)\n\n    // 채팅 기록을 저장하는 PUT 요청 페이로드 생성\n    const saveChatHistory = () => {\n        const options = {\n            method: 'PUT',\n            headers: {\n                \"Content-Type\": 'application/json',\n                'Accept': 'application/json'\n            },\n            body: JSON.stringify({\n                \"userId\": userId,\n                \"chatHistory\": previousChats\n            })\n        }\n\n        // 채팅 기록이 성공적으로 저장되면 API에 핑 보내고\n        // isChatSaved 상태를 true로 설정합니다\n        fetch(`${import.meta.env.VITE_ENDPOINT}save-chat-history/`, options).then(\n            (response) => response.json()\n        ).then(\n            (data) => {\n                setIsChatSaved(true)\n            }\n        )\n    }\n\n    // isChatSaved 상태 값에 따라 저장된 채팅 버튼에 동적으로 텍스트 표시\n    return (\n        <button\n            className=\"save-chat-history-button\"\n            onClick={() => {saveChatHistory()}\n        > <img className={isChatSaved?\"tick-icon-img\":\"save-icon-img\"} src={isChatSaved?tickIcon:saveIcon}/>\n        {isChatSaved?\"Chats Saved\":\"Save Chat History\"}\n        </button>\n    )\n}\n\nexport default SaveChatHistoryButton\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. 앱이 처음으로 로드될 때 채팅 기록을 검색합니다:\n\n```js\nimport React from \"react\";\nimport {chatItem} from \"./LiveChatFeed\";\n\ninterface Props {\n    userId: String\n    previousChats: Array<Array<chatItem>>\n    setPreviousChats: React.SetStateAction<any>\n}\n\nfunction getUserChatHistory({userId, previousChats, setPreviousChats}: Props){\n    // GET 요청을 위한 페이로드 생성\n    const options = {\n            method: 'GET',\n            headers: {\n                \"Content-Type\": 'application/json',\n                'Accept': 'application/json'\n            }\n        }\n\n        // GET 요청이므로 사용자 ID를 쿼리 매개변수로 전달합니다.\n        // API에서 반환된 채팅 기록으로 이전 채팅 상태를 설정합니다.\n        fetch(`${import.meta.env.VITE_ENDPOINT}get-chat-history/?userId=${userId}`, options).then(\n            (response) => response.json()\n        ).then(\n            (data) => {\n            if (data.response.chatHistory.length > 0) {\n                setPreviousChats(\n                        [\n                            ...previousChats,\n                            ...data.response.chatHistory\n                        ]\n                    )\n                }\n            }\n        )\n}\n\nexport default getUserChatHistory\n```\n\nUI 자체에 대해, ChatGPT의 인터페이스와 매우 유사한 것을 선택했습니다. 중앙의 채팅 피드 구성 요소와 채팅 기록과 같은 지원 콘텐츠를 담은 사이드바가 있습니다. 사용자를 위한 편안함 기능으로는 가장 최근에 생성된 채팅 항목으로 자동 스크롤링 및 로그인시 이전 채팅이 로드되는 등이 있습니다. 최종 UI 모습은 아래와 같습니다:\n\n이제 완전히 기능하는 UI가 준비되었으니 온라인 사용을 위해 호스팅해야 합니다. 저는 AWS Amplify를 사용하여 이를 수행하기로 선택했습니다. Amplify는 리소스 프로비저닝 및 웹 애플리케이션 호스팅을 처리하는 완전 관리형 웹 호스팅 서비스 중 하나입니다. 앱의 사용자 인증은 Amazon Cognito에 의해 관리되며 사용자 회원가입, 로그인, 자격 증명 저장 및 관리를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_5.png\" />\n\n# ChatGPT 응답과 비교\n\n앱을 구축하는 과정을 논의했으니, 몇 가지 질문에 대한 생성된 응답을 심도 있게 살펴보고, 이를 ChatGPT\\*에 제시된 동일한 질문과 비교해 보겠습니다.\n\n저희 애플리케이션에서 사용되는 LLM에 제시된 기본 프롬프트에는 시맨틱 검색 단계에서 검색된 추가 컨텍스트(관련 트랜스크립트 청킹 형태)가 포함될 것이기 때문에 이러한 비교는 본질적으로 \"부당\"한 것이라는 점에 유의하십시오. 그러나, RAG를 사용하여 생성된 프롬프트와 같은 기본 LLM에 의해 생성된 응답과 어떤 차이가 있는지 정성적으로 평가할 수 있게 해줄 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\\*All ChatGPT responses are from gpt-3.5, since this was the model used in the application.\n\n## 예시 1:\n\nSteven Bartlett가 금융 작가이자 투자자인 Morgan Housel과의 대화를 나누는 이 비디오의 내용에 대해 알고 싶습니다. 비디오 제목을 보면 집 구입에 반대하는 것으로 보이지만, 시간이 없어서 전체 내용을 확인할 수 없다고 가정해 봅시다. 여기 저는 이에 대해 애플리케이션과의 대화 스니펫을 보여드립니다:\n\n<img src=\"/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_6.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그를 Markdown 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 예시 2\n\n아래는 수익화 및 인수 전문가인 Alex Hormozi와의 이 토론에 대한 채팅에서 일부 스니펫이 있습니다. 비디오 제목으로부터, 그는 비즈니스를 성공적으로 확장하는 데에 대해 잘 알고 있다는 것 같아, 그에 대해 더 많은 세부 정보를 요청했습니다:\n\n![이미지](/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_8.png)\n\n이것은 합리적인 대답으로 보이지만, 동일한 질문 라인에서 더 많은 정보를 추출할 수 있는지 확인해 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![LLM 이미지1](/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_9.png)\n\n![LLM 이미지2](/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_10.png)\n\nYouTube 트랜스크립트에서 LLM이 추출할 수 있는 세부 수준에 주목해보세요. 위의 내용은 비디오의 17:00-35:00 타임스탬프 주변 15~20분 부분에서 찾을 수 있습니다.\n\nChatGPT에 같은 질문을 한 결과, 기업가에 관한 일반적인 답변만 제공되었지만 비디오 트랜스크립트 내용을 통해 사용할 수 있는 세부 정보가 부족합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![사용 예시 이미지](/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_11.png)\n\n# 배포\n\n마지막으로 논의할 주제는 AWS에서 각 구성 요소를 배포하는 과정입니다. 데이터 파이프라인, 백엔드 및 프론트엔드는 각각 자체 CloudFormation 스택(여러 AWS 리소스의 모음) 내에 포함되어 있습니다. 이렇게 각각을 격리된 상태에서 배포할 수 있도록 해줌으로써, 개발 중에 전체 앱이 불필요하게 다시 배포되지 않도록 합니다. 저는 AWS SAM (서버리스 애플리케이션 모델)을 사용하여 각 구성 요소에 대한 인프라를 코드로 배포하는데 활용하고 있습니다. SAM 템플릿 사양 및 CLI를 활용합니다:\n\n- SAM 템플릿 사양 - AWS CloudFormation을 확장하는 용도로 사용되는 간결한 구문으로, AWS 리소스의 모음을 정의하고 구성하는 데 사용됩니다. 리소스 간 상호 작용 방식 및 필요한 권한을 지정합니다.\n- SAM CLI - SAM 템플릿에 정의된 리소스를 빌드하고 배포하는 데 사용되는 명령줄 도구입니다. 애플리케이션 코드 및 종속성의 패키징, SAM 템플릿을 CloudFormation 구문으로 변환하고 CloudFormation에서 개별 스택으로 템플릿을 배포하는 작업을 처리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 글 전체 템플릿(자원 정의)을 모두 포함하는 대신, 우리가 이야기한 각 서비스에 대해 특정 관심 영역을 강조하겠습니다.\n\nAWS 리소스에 민감한 환경 변수 전달하기:\n\n유튜브 데이터 API, OpenAI API, Pinecone API와 같은 외부 구성 요소는 애플리케이션 전체에서 많이 의존합니다. 이러한 값을 CloudFormation 템플릿에 하드코딩하고 '매개변수'로 전달하는 것이 가능하지만, 더 안전한 방법은 AWS SecretsManager에서 각각의 비밀을 만들고 다음과 같이 해당 템플릿에서 이 비밀을 참조하는 것입니다:\n\n```js\nParameters: YoutubeDataAPIKey: Type: String;\nDefault: \"{resolve:secretsmanager:youtube-data-api-key:SecretString:youtube-data-api-key}\";\nPineconeAPIKey: Type: String;\nDefault: \"{resolve:secretsmanager:pinecone-api-key:SecretString:pinecone-api-key}\";\nOpenaiAPIKey: Type: String;\nDefault: \"{resolve:secretsmanager:openai-api-key:SecretString:openai-api-key}\";\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n람다 함수 정의:\n\n이 서버리스 코드 단위들은 데이터 파이프라인의 중심을 형성하며 웹 애플리케이션의 백엔드로의 진입점 역할을 합니다. SAM을 사용하여 이들을 배포하는 것은 호출될 때 함수가 실행해야 할 코드의 경로를 정의하는 것과 필요한 권한 및 환경 변수를 함께 지정하는 것만으로 간단합니다. 다음은 데이터 파이프라인에서 사용되는 함수 중 하나의 예시입니다:\n\n```js\nFetchLatestVideoIDsFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      CodeUri: ../code_uri/.\n      Handler: chatytt.youtube_data.lambda_handlers.fetch_latest_video_ids.lambda_handler\n      Policies:\n        - AmazonS3FullAccess\n      Environment:\n        Variables:\n          PLAYLIST_NAME:\n            Ref: PlaylistName\n          YOUTUBE_DATA_API_KEY:\n            Ref: YoutubeDataAPIKey\n```\n\nAmazon States 언어로 데이터 파이프라인의 정의를 검색하는 것:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개별 람다 함수에 Step Functions을 오케스트레이터로 사용하려면, Amazon States Language에서 각 함수가 실행되어야 하는 순서 및 최대 재시도 횟수와 같은 구성을 정의해야 합니다. 이 작업을 간단하게 수행하는 방법은 Step Functions 콘솔의 Workflow Studio를 사용하여 워크플로우를 다이어그램으로 만든 다음, 해당 워크플로우의 자동 생성된 ASL 정의를 적절히 수정할 수 있는 시작점으로 활용하는 것입니다. 그러면 이를 CloudFormation 템플릿에 링크하여 해당 위치에 정의하는 대신에 사용할 수 있습니다:\n\n```js\nEmbeddingRetrieverStateMachine:\n  Type: AWS::Serverless::StateMachine\n  Properties:\n    DefinitionUri: statemachine/embedding_retriever.asl.json\n    DefinitionSubstitutions:\n      FetchLatestVideoIDsFunctionArn: !GetAtt FetchLatestVideoIDsFunction.Arn\n      FetchLatestVideoTranscriptsArn: !GetAtt FetchLatestVideoTranscripts.Arn\n      FetchLatestTranscriptEmbeddingsArn: !GetAtt FetchLatestTranscriptEmbeddings.Arn\n    Events:\n      WeeklySchedule:\n        Type: Schedule\n        Properties:\n          Description: Schedule to run the workflow once per week on a Monday.\n          Enabled: true\n          Schedule: cron(0 3 ? * 1 *)\n    Policies:\n    - LambdaInvokePolicy:\n        FunctionName: !Ref FetchLatestVideoIDsFunction\n    - LambdaInvokePolicy:\n        FunctionName: !Ref FetchLatestVideoTranscripts\n    - LambdaInvokePolicy:\n        FunctionName: !Ref FetchLatestTranscriptEmbeddings\n```\n\n이 포스트에서 논의한 데이터 파이프라인을 위해 사용된 ASL 정의는 여기에서 확인할 수 있습니다.\n\nAPI 리소스 정의:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹 애플리케이션용 API가 프론트엔드와 별도로 호스팅될 예정이므로 API 리소스를 정의할 때 CORS (Cross-Origin Resource Sharing) 지원을 활성화해야 합니다:\n\n```js\nChatYTTApi: Type: AWS::Serverless::Api;\nProperties: StageName: Prod;\nCors: AllowMethods: \"'*'\";\nAllowHeaders: \"'*'\";\nAllowOrigin: \"'*'\";\n```\n\n위 설정을 통해 두 리소스가 서로 자유롭게 통신할 수 있게 됩니다. 람다 함수를 통해 액세스할 수 있는 여러 엔드포인트는 다음과 같이 정의할 수 있습니다:\n\n```js\nChatResponseFunction:\n    Type: AWS::Serverless::Function\n    Properties:\n      Runtime: python3.9\n      Timeout: 120\n      CodeUri: ../code_uri/.\n      Handler: server.lambda_handler.lambda_handler\n      Policies:\n        - AmazonDynamoDBFullAccess\n      MemorySize: 512\n      Architectures:\n        - x86_64\n      Environment:\n        Variables:\n          PINECONE_API_KEY:\n            Ref: PineconeAPIKey\n          OPENAI_API_KEY:\n            Ref: OpenaiAPIKey\n      Events:\n        GetQueryResponse:\n          Type: Api\n          Properties:\n            RestApiId: !Ref ChatYTTApi\n            Path: /get-query-response/\n            Method: post\n        GetChatHistory:\n          Type: Api\n          Properties:\n            RestApiId: !Ref ChatYTTApi\n            Path: /get-chat-history/\n            Method: get\n        UpdateChatHistory:\n          Type: Api\n          Properties:\n            RestApiId: !Ref ChatYTTApi\n            Path: /save-chat-history/\n            Method: put\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n리액트 앱 리소스를 정의하는 방법:\n\nAWS Amplify를 사용하면 관련 Github 저장소에 대한 참조와 적절한 액세스 토큰을 사용하여 애플리케이션을 빌드하고 배포할 수 있습니다:\n\n```js\nAmplifyApp:\n    Type: AWS::Amplify::App\n    Properties:\n      Name: amplify-chatytt-client\n      Repository: <https://github.com/suresha97/ChatYTT>\n      AccessToken: '{resolve:secretsmanager:github-token:SecretString:github-token}'\n      IAMServiceRole: !GetAtt AmplifyRole.Arn\n      EnvironmentVariables:\n        - Name: ENDPOINT\n          Value: !ImportValue 'chatytt-api-ChatYTTAPIURL'\n```\n\n한 번 저장소 자체에 액세스할 수 있으면, Amplify는 앱을 구축하고 배포하는 방법에 대한 지침이 포함된 구성 파일을 찾습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\nversion: 1\nfrontend:\n  phases:\n    preBuild:\n      commands:\n        - cd client\n        - npm ci\n    build:\n      commands:\n        - echo \"VITE_ENDPOINT=$ENDPOINT\" >> .env\n        - npm run build\n  artifacts:\n    baseDirectory: ./client/dist\n    files:\n      - \"**/*\"\n  cache:\n    paths:\n      - node_modules/**/*\n```\n\n덤으로, 계속적인 배포 프로세스를 자동화하기 위해 모니터링할 브랜치 리소스를 정의하여 추가 커밋이 발생할 때 앱을 자동으로 재배포할 수도 있습니다:\n\n```yaml\nAmplifyBranch:\n  Type: AWS::Amplify::Branch\n  Properties:\n    BranchName: main\n    AppId: !GetAtt AmplifyApp.AppId\n    EnableAutoBuild: true\n```\n\n이렇게 최종 배포가 완료되면, AWS Amplify 콘솔에서 제공된 링크를 통해 누구에게나 접근 가능합니다. 이렇게 접근한 앱의 데모 기록은 다음에서 확인할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n높은 수준에서 다음 단계를 다뤘습니다:\n\n- 콘텐츠 수집 및 저장을 위한 데이터 파이프라인 구축.\n- 대화 기억을 활용한 검색 증강 생성을 수행하는 백엔드 서버 구성.\n- 생성된 답변 및 채팅 기록을 제공하는 사용자 인터페이스 설계.\n- 이러한 구성 요소를 연결하고 배포하여 가치를 제공하고 시간을 절약하는 솔루션을 생성하는 방법.\n\n이러한 응용프로그램이 학습 및 개발 목적의 YouTube 비디오 소비를 최적화하고 어떤 방식으로든 간소화할 수 있는 방법을 알아보았습니다. 그러나 이러한 방법은 동일하게 직장에서 내부 사용이나 고객을 위한 솔루션을 확장하는 데 쉽게 적용할 수 있습니다. 이것이 LLMs의 인기와 특히 RAG 기술이 많은 조직에서 큰 주목을 받는 이유입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마크다운 형식으로 표 태그를 변경해보세요.\n\n# 감사의 글\n\nDiary of a CEO 팀에게 이 프로젝트와 이 글 작성 중에 이 플레이리스트의 비디오 대본을 사용할 수 있는 허락을 받아 감사의 말씀을 전합니다.\n\n모든 이미지는 별도 명시가 없는 한 저자가 찍은 것입니다.\n","ogImage":{"url":"/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_0.png"},"coverImage":"/assets/img/2024-05-23-UsingLLMstoLearnFromYouTube_0.png","tag":["Tech"],"readingTime":29},{"title":"접근성 있는 비디오 게임 디자인하기","description":"","date":"2024-05-23 13:43","slug":"2024-05-23-Designingaccessiblevideogames","content":"\n비디오 게임은 오직 즐거움의 형태에 머무르는 것이 아닙니다; 그것들은 이야기 전달, 소셜 상호 작용, 그리고 몰입형 경험을 위한 강력한 매체입니다.\n\n사람들이 여가 시간을 게이밍에 할애하는 이유는 많습니다. 시작하기에, 그들은 현실에서 벗어나 다른 사람들과 연결되는 방법입니다. 누군가가 왜 게임을 원할 수 있는 가능한 이유들을 모두 나열할 수 있지만, 그것은 그 자체로 한 섹션이 될 것입니다.\n\n모든 사람은 게임의 독특하고 몰입적인 세계를 즐길 자격이 있지만, 불행하게도 그것이 많은 게임에는 해당되지 않습니다. 지난 몇 년 동안 접근성 있는 게임 디자인으로의 움직임이 있었지만, 아직 가야 할 길은 멀습니다.\n\n많은 게임이 일부 접근성 설정과 기능을 구현하고 있지만, 몇몇 회사만이 시간, 예산, 그리고 능력이 The Last of Us Part II만큼 멋지게 접근 가능하도록하는 게임을 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위와 같이, 접근성에 대한 대화를 중요시하고 시작부터 구현하는 것이 중요합니다. 복잡한 설정 메뉴가 모든 게임에 가능하지는 않을 수 있음을 이해합니다, 특히 소규모 스튜디오의 경우에는 더 그렇습니다.\n\n예산이 전무한 소규모 인디 스튜디오에서 근무하고 있는 사람으로서, 제가 이해한다는 것에 신뢰해 주세요.\n\n게임을 접근성 있게 디자인하는 것은 모든 플레이어에 도움이 되며, 접근성을 고려한 기능은 모든 능력을 가진 플레이어들에게 널리 사용됩니다.\n\n자막을 예로 들어 보겠습니다. 명백히 자막은 청각 장애가 있는 플레이어들에게 매우 유용한 도구이지만, 청각 장애가 없는 플레이어들도 자주 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트: 이 기사는 접근성 있는 게임을 디자인하는 방법 중 일부만 다룹니다.\n\n더 포괄적인 목록이 궁금하시다면 '게임 접근성 지침'을 확인해보세요.\n\n여러분께서는 직접 조사를 하시고, 무엇보다도 다양한 능력을 가진 실제 사용자들로 게임을 테스트하는 것을 권장합니다.\n\n# 어시스트 모드 vs 의도한 경험\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 플레이어는 게임 자체의 도움을 필요로하여 제시된 도전들을 극복할 수 있습니다. 특정 게임들은 조준장치를 추가하여 플레이어가 조준, 조향, 내비게이션, 퍼즐 해결 또는 장애물 극복 등 다양한 방식으로 도움을 받을 수 있도록 합니다. 이렇게 함으로써, 플레이어는 게임의 난이도를 맞춤 설정하고 자신의 속도에 맞춰 게임 콘텐츠를 즐길 수 있습니다.\n\n일부 게임 회사들 사이에서 이러한 보조가 어떻게 게임의 정신이나 목적을 망치는지에 대한 논쟁이 있습니다.\n\n특정 프랜차이즈의 개발자들과 팬들은 종종 \"프롬 소프트웨어의 '세키로: 섀도우 다이 트와이스(Sekiro: Shadows Die Twice)'나 Sloclap의 '시퍼(Sifu)'와 같은 게임에 쉬운 난이도나 보조 게임 설정을 추가하는 것을 반대하며, 예술적 방향성과 개발자의 목표인 형벌적인 경험을 만들려는 것을 인용하며 다른 난이도 모드 추가는 '망치게 될 것'이라고 주장합니다.\"\n\n만약 다크 소울즈(Dark Souls)이 쉬웠다면, 다크 솔울즈가 아니었을 것입니다. 이는 사실일 수 있지만, 접근성 옵션은 게임을 쉽게 만드는 것이 아니라 광범위한 대중에 渙근하게 하는 것을 목적으로 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게임이 제공하는 체험을 제한하거나 묽게 만드는 것이 아닙니다. 만약 당신의 게임이 숲을 통해 야생 동물을 쫓는 긴장감을 제공하길 원한다면, 그것이 플레이어 경험으로 추구해야 할 것입니다.\n\n모든 실력 수준의 플레이어는 게임을 플레이하는 동안 도전과 재미를 동시에 찾고 있습니다. 에임 어시스트와 같은 기능을 도입하면 처음에는 플레이어가 속임수를 쓰는 것을 느낄 수도 있지만, 현실은 그렇지 않습니다. 에임 어시스트를 추가하는 예시에서는, 에임에 대한 신체적 제약을 겪는 개인들에게 기회를 제공하여 게임을 원활히 탐험하고, 멋진 느낌을 느낄 수 있게 합니다.\n\n플레이어가 게임을 진행하는 데 도움이 필요하지 않은데도 어시스트 모드를 사용할까봐 걱정된다면, 경고 문구를 추가하는 것을 고려해보세요.\n\n인기 있는 인디 플랫포머인 'Celeste'는 플레이어가 게임을 자신의 요구에 맞게 조정할 수 있도록 허용하면서도, 이것이 게임을 플레이하는 방식이 아니라는 경고를 제공하는 뛰어난 작업을 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게임 제작자 도구킷이 말하듯이, 접근성과 게임이 의도대로 플레이되는 것 사이의 균형을 맞추는 것은 하나의 중요한 요소, 소통에 달려 있어요.\n\n우리가 제대로 소통한다면, 사용자들은 게임이 어떻게 플레이되어야 하는지 알게 될 거예요. 특정 보조 모드나 설정을 켜야 하는지 결정하는 것은 플레이어의 몫이에요. 이는 그들을 위해 디자인된 의도된 경험을 변경할 수 있어요.\n\n난이도는 게임의 일부입니다. 그러나 플레이어가 물리적 또는 정신적으로 그것을 완료할 수 없는 정도로 게임을 너무 어렵게 만들면, 그들은 그것을 전혀 플레이할 수 없게 될 거에요.\n\n# 멀티플레이어 게임에서의 접근성 균형 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금, 지금. 방 안의 코끼리에 대해 얘기해 보죠: 멀티플레이어 게임. 멀티플레이 경험을 공정하게 유지하면서 접근성 높은 것으로 만드는 방법은 뭘까요?\n\nAPX 프레임워크는 이를 \"하우스 룰\"이라고 부릅니다.\n\n플레이어들은 온라인에서 다른 사람들과 맞붙을 때 선택지를 받을 수 있습니다. 플레이어들은 특정 설정(에임 어시스트, 매크로 등), 게임 옵션(매치 길이, 게임 모드 등), 그리고/또는 특정 실력 수준의 플레이어들과만 플레이할지 선택할 수 있습니다.\n\n![Designingaccessiblevideogames_0](/assets/img/2024-05-23-Designingaccessiblevideogames_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 플레이어들이 특정 설정으로 다른 사람들에게 이점을 준다고 느낀다면, 그들은 해당 설정을 사용하지 않는 플레이어들과 함께 대기열에 들 수 있습니다.\n\n이렇게 함으로써 플레이어 간 의사 소통에 관한 문제도 해결할 수 있습니다. 예를 들어, 음성 채팅 없이 게임을 선호하는 플레이어들 또는 그러한 방식을 수용할 수 있는 플레이어들과 온라인 멀티플레이 매치를 우선적으로 매칭하는 옵션을 제공하세요. 의사소통에 크게 의존하는 협력 게임에서는 음성 대화를 할 수 없는 플레이어들로 인해 팀원들이 좌절할 수도 있습니다. 이러한 좌절은 게임에서 해당 플레이어를 제거하거나 미래 매치에서 제외시킬 수도 있습니다.\n\n# 저장 — 자동 및 수동\n\n몇몇 사람들은 어려운 도전에 맞서고 같은 레벨을 통과하기 위해 끊임없이 시간을 보내는 것을 좋아합니다 (FromSoftware 팬들에게 주목!).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다른 사람들은 그렇지 않을 수도 있습니다. 원하는 때에 게임을 저장하고 싶다는 것은 단순히 개인적인 취향일 수도 있고, 신체적, 정신적 스트레스를 덜기 위한 문제일 수도 있습니다.\n\n신체적 장애를 가진 플레이어들은 힘든 동작이나 도전적인 상황을 반복하기 위해 게임을 저장해야 할 수도 있습니다. 가장 유명한 게임 메커니즘 중 하나를 예를 들어보겠습니다: 퀵타임 이벤트. 특히 버튼 누르기입니다.\n\n(이상적으로는 버튼을 연타하는 부분을 우회하거나 그 부분을 완전히 제거할 방법을 추가하고 싶지만, 이 예시를 계속 진행해 봅시다.)\n\n사용자가 방금 큰 무서운 괴물을 피하기 위해 \"X\"를 연타해야 했던 작업을 끝냈다고 상상해봅시다. 안도의 한숨을 내쉬며 그 다음 장면으로 나아갑니다. 은어, 저거는 못 봤네요; 건너 돌다가 절벽으로 떨어지고 큰 “게임 오버”가 화면에 나타납니다. 다시 시도하고, 이미 따가운 버튼 누르기 손이 아팠던 사용자는 그 섹션을 다시 해야 한다는 걸 깨달을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 플레이어들은 그 섹션을 다시 시작하면서 한숨을 쉴 수도 있지만, 다른 사람들은 그 섹션을 다시 완료할 물리적 또는 정신적 능력이 되지 않을 수도 있어요.\n\n버튼을 연담하다 보니 플레이어에게 신체적으로 지친 상태가 되어 하루 쉬고 다음 날 다시 시도해야 할 수도 있어요. 다음 날이 왔지만, 다시 시도하여 실패하고 다시 쉬고 다음 날 다시 시도해야 할 수도 있어요. 즐겁지 않죠.\n\n이 도전은 반드시 신체적인 것만은 아닐 수도 있어요.\n\n게임의 특정 섹션에서 플레이어가 계속해서 듣거나 보고 싶어하지 않는 매우 감정적으로 자극하는 대화나 이미지가 있는 가능성도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 섹션이 너무 자극적이어서 진행이 어려울 수 있습니다.\n\n무엇이든 그 이유가 되더라도, 사용자들에게 저장할 수 있게 해주세요.\n\n저는 개인적으로 자동 저장과 수동 저장 둘 다 구현하는 것을 추천드립니다.\n\n왜냐하면 몇 가지 이유가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자동 저장은, 그냥 자동으로 됩니다. 사용자들은 자신이 죽거나 집의 전원이 어떤 이유로든 꺼진다고 해도 많은 진행 상황을 잃을 걱정을 할 필요가 없습니다.\n\n하지만, 자동 저장에는 몇 가지 문제가 있습니다.\n\n우리 아버지는 게임 The Callisto Protocol의 출시일에 대해 매우 흥분했습니다. 그는 잠깐 게임을 플레이하고 멋지다고 생각했지만, 가장 어려운 난이도로 플레이하더라도 실제 도전감이 전혀 느껴지지 않았다고 느꼈습니다.\n\n그는 나를 불러 자신이 특정 부분을 진행하면서 적에게 죽고, 다시 부활해서 방금 전에 있었던 곳에서 10 피트 떨어진 곳에서 되살아났다는 것을 보라고 말했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"그는 말했다, '게임 전체가 이런 식이야. 내가 죽어도 걱정 안 해. 원래 있던 곳으로 돌아가는 데 10초가 걸리니까. 긴장감이 없어.'\n\n게임을 자주 저장하는 것은 일부 플레이어에게 좋을 수 있지만, 다른 사람들의 경험을 방해할 수도 있어. 나는 일정 구간을 거치고 자동 저장하는 것을 선호하지만, 사용자가 수동으로 저장할 수 있는 옵션을 제공하는 게 좋다.\n\n수동 저장 옵션이 없으면 짧은 간격으로만 게임을 플레이하거나 사전 예고 없이 갑자기 게임을 중단해야 하는 게이머에게 불리할 수 있다.\n\n더 큰 장애물을 가진 플레이어들에게는 이 제한이 게임을 할 수 있게 여부를 결정할 수도 있다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 누군가가 다시 하기 싫은 섹션을 완료한다면, 저장할 수 있어요. 도전을 좋아하는 플레이어들은 계속해서 진행할 수 있어요.\n\n# 난이도 모드는 싫어\n\n비디오 게임에서 난이도를 조절하는 것에 대해 이야기해봐요.\n\n엄청나게 많은 게임들이 플레이어들이 난이도를 선택할 수 있는 옵션을 제공하지만, 그중에서 제대로 하는 게임은 매우 드데요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어려움은 적의 체력, 플레이어 체력, 적의 수, 전리품 드랍 빈도, 플레이어 및 적의 공격력 등을 조절합니다.\n\n이 모든 것은 괜찮은데, 더 자세히 살펴보기 시작하면 문제가 될 수 있어요.\n\n예를 들어, 어떤 이용자는 게임의 전투 요소를 정말 좋아하지만 무슨 이유에서인지 게임의 파쿠르 부분을 완료하지 못할 수 있어요. 그들은 전투 부분에 높은 난이도를 원할지 몰라도 파쿠르 부분에는 쉬운 난이도를 원할 수 있어요. 또한 누군가는 액션을 좋아하지만 한 플랫폼을 건너는 데 2시간을 헤매다가, 이 경험이 그만한 가치가 없어지는 경우도 있을 거예요.\n\n난이도 설정을 조절할 수 없다면, 상황은 어려움의 암흑일 수 있어요. 예를 들어, 쉬운 난이도에서 게임을 플레이하면 전투가 재미없어 보일 수 있지만, 어려운 난이도에서 플레이하면 플랫폼이 불편할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n장애를 가진 플레이어를 고려할 때 이 문제는 더욱 복잡해질 수 있습니다.\n\n보편적인 컨트롤의 접근성이 부족하여 어려움을 겪을 수 있는 사람을 고려해 봅시다. 그들은 주로 쉬운 난이도 설정을 선택하여 명령을 단순화하고 게임 플레이 속도를 늦추게 됩니다. 이러한 선택은 어떤 접근성을 제공하기는 하지만 게임에서 찾는 전반적인 도전과 흥미를 떨어뜨릴 수도 있습니다.\n\n많은 게이머들이 쉬운 난이도를 선택하는 것은 도전을 원치 않기 때문이 아니라, 그것이 접근 가능한 유일한 모드이기 때문일 수도 있습니다.\n\n일반적으로 어려움 설정을 선택하는 것은 혼란과 스트레스를 초래할 수도 있습니다. 게임의 여러 요소를 몇 가지 옵션으로 일반화하여 선택할 수 있도록 하는 어려움 모드는 게임에서 각 난이도가 실제 게임 플레이에 어떤 의미를 갖는지 명확히 설명해 주지 않는 경향이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n균형 잡힌 경험. 멋지네요… 하지만… 균형이 정확히 무슨 뜻이죠?\n\n몬스터보다 내가 가진 체력이 동일한 수준이라는 걸 의미하는 건가요? 더 많은가요? 어떤 스탯이 영향을 받나요? 이 중 어떤 설정이 게임을 접근하기 쉽게 만들어줄까요?\n\n전혀 모르겠네요.\n\n그럼, 해결책은 무엇일까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래요, 각 플레이어마다 독특하고 능력 수준 및 개인 성향에 맞는 맞춤형 경험을 얻을 수 있다는 것 같아요. 그렇다면… 그걸 한정된 난이도 옵션에 어떻게 넣을까요?\n\n음, 번들 하나 말이죠.\n\n구체적으로 말하면, 플레이어가 조절할 수 있는 설정들의 번들이죠.\n\n어찌되었든, 난이도 모드는 그냥 서로 다른 설정들의 번들일 뿐이에요; 우리는 그것을 바꿀 수 있는 옵션을 플레이어에게 일반적으로 제공하지 않을 뿐이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플레이어들이 적의 수, 시간 제한, 보상 획득량 등을 조절할 수 있는 기능을 제공한다면, 그들이 직접 원하는 난이도 모드를 만들 수 있어요.\n\n난이도 모드에 몇 가지 사전 설정값을 사용자에게 제공하되, 이후 사용자가 직접 선호에 맞게 수정할 수 있도록 해보세요.\n\n여러 난이도 모드를 제공하는 것 외에도, 사용자가 맞춤형 난이도를 선택할 수 있도록 하는 것도 좋아요.\n\n난이도 설정이 정말 잘 된 게임 중 하나인 Pathologic 2 생존 게임이 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n누군가는 가장 강렬하고 복잡한 퍼즐을 원할 수 있고, 또한 가장 쉬운 전투를 선호할 수도 있습니다. 또 다른 누군가는 퍼즐을 완전히 건너뛰고 가장 도전적인 전투 경험을 원할 수도 있죠.\n\n플레이어가 자신만의 플레이 스타일에 가장 적합한 경험을 만들 수 있도록 옵션을 제공해주세요.\n\n# 감각을 활용해보세요\n\n중요한 정보를 플레이어에게 전달할 때 적어도 두 가지 다른 감각을 사용하는 것이 좋은 지침입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 전리품이 나온 경우 시각적인 표시뿐만 아니라 청각적인 표시도 하세요. 플레이어가 피해를 입은 경우 시각적 피드백과 함께 햅틱 피드백을 제공하세요.\n\n여러 감각을 통해 정보를 전달하는 좋은 예시는 게임 모탈 컴뱃(Mortal Kombat)에서 찾을 수 있습니다.\n\n카를로스 바스케즈, 또는 스트리머 래틀헤드로 알려진 사람은 시각 장애인 프로 모탈 컴뱃 플레이어입니다. 그는 소리에 완전히 의존하면서 최고 수준의 경기에 참가할 수 있습니다.\n\nTheGamer와의 인터뷰 중에 Rattlehead는 게임이 설계되는 동안 때로는 \"우연한 접근 가능성\"을 만들어낼 수 있다고 언급합니다. 이 우연한 접근 가능성은 게임을 플레이할 수 있게 만들어 줄 수도 있지만, 개발자들이 실제로 시각 장애인 게이머를 듣게 되면 게임이 완전히 새로운 수준으로 진화될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 사람들은 2D 대전 게임과 같은 일부 종류의 게임만 시각 장애인 커뮤니티에 접근 가능하다고 주장합니다. 이는 사실이 될 수 있지만, 접근성을 처음부터 고려하지 않는다면 해당할 수 있습니다.\n\n접근성을 고려하여 게임을 만든다면 복잡한 3D 게임도 누구에게나 플레이할 수 있게 할 수 있습니다. 이러한 사례 중 하나가 God of War: 라그나로크에 있습니다. 시갚을 사용하지 않고도 게임을 완주할 수 있습니다.\n\n게임에서는 플레이어가 어디로 가야하는지 듣을 수 있는 핑 시스템과 적과 싸울 때 락온 시스템을 사용합니다.\n\nRoss Minor의 게임 플레이를 시청해보면, 2022 게임 어워즈에서 접근성 혁신상을 수상하더라도 해당 게임이 완벽에 가깝지 않음을 알게 될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비디오 게임은 접근성 측면에서 많은 발전을 이뤄왔지만, 아직 가야 할 길이 많습니다.\n\nGod of War: Ragnarök과 같이 철저한 접근성 시스템을 갖춘 게임들을 공부하고, 그들이 제대로 한 부분과 개선할 수 있는 부분을 주목해 보는 걸 권장합니다.\n\n이어서 청각 정보를 시각적으로 전달하는 것에 대해 이야기해 보겠습니다. 청각 장애가 있는 플레이어들은 햅틱스나 부가적인 시각적 표시를 통해 정보를 전달받아야 할 수도 있습니다.\n\n시작하려면, 생존 게임인 Raft에서 나쁜 예시를 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n(참고: 저는 Raft를 사랑하는 팬으로, 그것과 함께 많은 즐거움을 느꼈지만, 접근성 부분에는 많은 부족함이 있습니다.)\n\nRaft의 주요 기능 중 하나는 상황에 따라 플레이어에게 다가와 그들의 뗏목/기지를 먹으려는 상어를 중심으로 돌아갑니다. 플레이어는 상어를 막기 위해 어떤 종류의 막대나 무기로 상어를 때려야 합니다.\n\n플레이어는 상어가 나타날 때 상어가 나뭇결을 물거나 철퍼지는 소리를 듣고 알 수 있습니다.\n\n플레이어가 청각 장애가 있거나 청력이 떨어지거나 시끄러운 환경에서 플레이하거나 소리 없이 게임을 플레이할 때는 직접 상어를 바라봐야만 상어가 있는지 알 수 있는 방법이 없습니다. 이 문제는 플레이어가 특히 큰 기지를 건설하고 뗏목의 모든 구석을 보는 방법이 없을 때 더 큰 문제가 됩니다. 이 문제는 소리가 어디에서 시계가 오는지 표시하는 시각적 지시기를 사용하여 해결할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포트나이트는 시각적 오디오를 활용한 게임의 좋은 예시입니다. 플레이어 주위에 나타나는 링은 다양한 소리가 어디에서 나오는지를 표시합니다. 발소리, 총 소리, 전리품 등이 링에 표시되어 플레이어가 특정 방향에서 무슨 일이 일어나고 있는지 알 수 있습니다.\n\n이 설정은 청각 장애가 있는 사용자, 소리 없이 플레이하는 사용자 또는 소음이 있는 환경에서도 사용자들이 공평하게 게임을 즐길 수 있도록 도와줍니다.\n\n각각의 감각을 통해 정보를 전달하는 것 뿐만 아니라 정보가 명확히 표시되도록 하는 것도 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n시각 장애를 가진 게이머들을 위해 경험을 맞춤 설정하는 것은 배경 세부사항을 없애는 것을 포함할 수도 있습니다. 이 조정은 그들이 전경의 중요한 물체들을 쉽게 구별하고 집중할 수 있도록 돕습니다. 이에 대한 훌륭한 예시는 The Last of Us: Part II에서 볼 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-Designingaccessiblevideogames_2.png)\n\n상호작용 가능한 항목들과 적들과 같은 중요한 요소들이 강조되고 배경은 회색조로 처리됩니다. 플레이어들은 화면에서 중요한 정보를 더 쉽게 파악할 수 있습니다.\n\n신경 다양성을 가진 일부 플레이어들에게는 특정 요소를 제거하여 시각적 장면을 조정하는 것이 필수적일 수 있습니다. 이 수정은 그들이 받는 시각적 자극을 줄이고, 그들의 독특한 요구에 맞는 편안한 환경을 만들어냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게이머들은 오디오 설정을 조절하여 볼륨 레벨을 조절하거나 다른 오디오 채널을 관리하기를 원할 수 있습니다. 예를 들어, 플레이어는 음악을 줄이고 특정 효과음을 올려서 게임 진행을 완전히 이해할 수 있을 수도 있습니다. 이 유연성은 게임의 소리 신호를 통해 중요한 정보를 신뢰할 수 있게 흡수할 수 있도록 보장합니다.\n\n# 함께 하면 더 즐겁습니다\n\n친구나 가족과 함께 플레이할 수 있는 기능을 고려해보세요.\n\n어떤 플레이어들은 게임의 일부를 다른 사람에게 맡길 필요가 있을 수도 있습니다. 예를 들어, 플레이어는 버튼을 누를 수 있지만 조이스틱을 사용할 수 없을 수도 있습니다. 다른 사람이 다른 컨트롤러를 이용하여 함께 들어와 조이스틱을 통해 모든 움직임을 제어할 수 있다면, 다른 플레이어는 버튼을 전부 누를 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어 Xbox는 Xbox Copilot을 통해 이 문제를 깔끔하게 해결했습니다. Copilot을 켜면 두 명의 플레이어가 각각 다른 컨트롤러를 사용하여 게임을 조종할 수 있습니다. 이는 \"플레이어들이 게임을 플레이하는 데 필요한 조작을 서로 나눠서 맡도록 할 수 있게 해주는데, 이는 한 명의 플레이어가 게임을 플레이하는 데 필요한 모든 행동을 처리할 수 없는 상황이거나 플레이어들이 공동 경험을 원할 때 유용합니다.\"\n\n난이도가 있는 섹션을 완수하거나 도전적인 퍼즐을 해결하거나 감정적인 콘텐츠를 다룰 때 다른 사람이 도와주는 것은 플레이어가 진전하는 데 큰 도움이 됩니다.\n\n이것은 장애를 가진 사용자들뿐만 아니라, 능숙하지 못한 어린 가족 구성원과 함께 게임을 완주할 수 있는 상황도 고려해보세요.\n\n이것은 플레이어 사이에 공동 경험을 만들어내는 협동 요소를 추가하는 재미있는 방법입니다. 게임이 협동 모드가 아니라면, 일반적으로 한 명이 플레이하는 경험이었던 것을 커플, 친구, 가족끼리 협력하여 공유할 수 있는 방법이 될 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 매크로\n\n마이크로소프트에 따르면, 매크로는 \"작업을 자동으로 수행하기 위해 하나의 명령으로 그룹화된 일련의 명령과 지시\"입니다.\n\n비디오 게임의 맥락에서, 이는 하나의 버튼을 동시에 또는 순서대로 여러 작업을 수행하도록 매핑하는 것이 될 수 있습니다.\n\n매크로가 흔한 게임인 월드 오브 워크래프트(WoW)를 살펴봅시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nWoW은 전투 중 사용할 능력과 액션을 다량 제공하는 것으로 유명합니다. 게임 속에서 여러 막대에 시전할 주문들이 넘치게 되면서 플레이어들 중 일부는 여러 가지 주문들로 가득 찬 액션 바를 가지게 되었습니다.\n\n아래는 너무 많은 것들이 액션 바에 할당된 극단적인 예시의 스크린샷이지만, 요점은 전달됩니다.\n\n![WoW screenshot](/assets/img/2024-05-23-Designingaccessiblevideogames_3.png)\n\n매크로를 사용하면 단일 키가 한 번의 버튼 누름으로 여러 주문을 실행할 수 있도록 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n버튼을 10번 누르는 작업이 1번으로 줄어들 수 있어요.\n\n게이밍에서 매크로의 주요 장점 중 하나는 개별 플레이어에게 맞춤형 솔루션을 제공할 수 있다는 점입니다.\n\n예를 들어, 신체적 장애가 있는 게이머들은 복잡한 키 조합이나 마우스 이동을 실행하는 데 어려움을 겪을 수 있습니다. 매크로를 사용하면 신체적 스트레인을 줄일 수 있어 게이머가 더 오래 플레이하고 더 즐거운 경험을 할 수 있도록 도와줍니다.\n\n게다가, 매크로 기능은 kognitive 어려움이나 처리 속도에 영향을 주는 상황에 있는 플레이어들의 반응 시간을 크게 향상시킬 수 있어요. 특정 작업들을 자동화함으로써 플레이어는 더 효율적으로 명령을 실행할 수 있어 게임의 속도에 맞춰 가는 데 도움을 줄 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 향상된 반응 시간은 접근성을 높이는 데 훌륭하지만, 멀티플레이 경험에서 부당한 이점에 대한 명백한 우려를 제기합니다. 모든 게임에서 플레이어가 매크로를 사용하는 것이 현실적으로 가능하지는 않을 수 있지만, 고려해 볼 것을 권장합니다.\n\n접근성에서 매크로의 역할에 관심이 있다면 Laura K Buzz의 이 비디오를 확인해보세요.\n\n# 대체 입력 장치 및 키 할당 재설정\n\n일반적인 컨트롤러를 대체 입력 장치로 교체하거나 키 할당을 재설정하는 것이 게임을 접근성 있게 만드는 중요한 부분입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n활동 제약이 있는 플레이어들에게는 적응형 컨트롤러, 스위치, 또는 동작 센서와 같은 대체 입력 장치를 연결할 수 있는 능력이 플레이 여부를 결정할 수도 있어요.\n\n발판부터 QuadStick와 같은 멋진 기술들이 많이 있어요. QuadStick은 입으로 작동하는 비디오 게임 컨트롤러입니다.\n\n게다가 여러 입력 장치를 사용할 수 있는 옵션은 맞춤형이고 유동적인 게이밍 경험을 촉진해요. 플레이어들은 자신의 편안함과 능력에 가장 잘 맞는 장치 조합을 선택할 수 있어서 자기 주도성과 포용성을 유발해요. 이는 장애가 있는 개인들의 접근성을 향상시키는 뿐만 아니라 다양한 게임 취향을 가진 광범위한 관객들에게도 맞춤화됩니다.\n\n모든 종류의 대체 컨트롤러와 설정을 사용하는 플레이어들로 테스트하는 것이 중요해요. 모든 것이 올바르게 작동하는지 확인하기 위해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플레이어들이 자신의 기기를 사용할 수 있는 것 외에도, 제어를 적절하게 다시 매핑할 수 있어야 합니다.\n\n키 바인딩 다시 매핑을 통해 개인들은 편리하고 관리하기 쉬운 키나 버튼에 명령을 할당할 수 있습니다. 예를 들어, 플레이어는 \"점프\"를 발판으로 또는 움직임 제어를 별도의 조이스틱으로 다시 매핑해야 할 수도 있습니다.\n\n다시 매핑은 모든 플레이어에게 혜택을 주는데, 왜냐하면 각자가 선호하고 익숙한 제어 방식이 있기 때문입니다. 특히 PC에서 게임을 열 때마다, 처음으로 하는 일 중 하나는 설정에 들어가서 쉽게 접근할 수 없는 키 바인딩을 다시 매핑하는 것입니다.\n\n이제 모든 이 키 다시 매핑과 사용자 정의 설정을 고려해주시고, 플레이어의 설정이 세션 간에 유지되도록 해주세요. 누군가가 게임에 들어가서 자신의 플레이 스타일과 고유한 요구를 맞추기 위해 설정을 완벽하게 조정하는 데 한 두 시간을 소비한다면, 돌아왔을 때 모든 게 완벽하게 유지되어야 합니다. 아무도 그 모든 작업을 다시 해야할 필요가 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 아직 나가지 마세요\n\n제가 다룬 내용은 게임 접근성을 위한 초반 작업에 불과해요.\n\n이 글에서는 적절한 자막 및 캡션 추가, 색맹을 위한 디자인, 컨트롤 감도 조절 등을 다루지 않았습니다.\n\n아래 링크된 멋진 자료들을 확인해보는 것을 강력히 권유합니다. 게다가 AbleGamer의 APX (Accessible Player Experiences) 인증 실무자가 되기 위한 2일 과정도 적극 추천해요. (저는 어떠한 방식으로도 후원받고 있지 않아요. 진심으로 이 과정을 좋아했습니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 더 읽을거리\n\n- 접근성은 쉽지 않아요: 게임을 모두에게 알맞게 만드는 것에 대해 '쉬운 모드' 논의에서 빠뜨리는 것 →\n  \"난이도가 높은 게임을 더 접근성 있게 만드는 것은 난이도 수준을 넘어서 하는 일입니다.\"\n- 접근 가능한 플레이어 경험 (APX) 패턴 →\n  독특하고 플레이어가 자신의 Bedz어에 맞게 조절할 수 있는 플레이 경험이 확보되도록 하는 도전과 접근 패턴 목록. 정말 확인해보세요.\n- 접근 가능한 비디오 게임 디자인 →\n  이 기사를 좋아하신다면, 다른 기사도 마음에 드실 거에요.\n- BBC 자막 가이드 라인 →\n  여러분 모두에게 자막을 읽을 수 있고 접근할 수 있게 만드는 방법을 배워보세요.\n- 게임 접근성 지침 →\n  게임을 접근성 있게 디자인하는 데 가장 필요한 도구/자료 중 하나에요.\n- 게임 제작자의 도구킷(TK) - 비디오 게임 접근성 재생 목록 →\n  게임 개발자라면 꼭 봐야 할 GA 재생 목록으로, 접근성이 있는 비디오 게임을 디자인하는 방법이 가득 담겨 있어요. 이 동영상은 꼭 시청해야 할 필수영상입니다.\n\n여러분들의 생각이나 경험이 있으면, 알려주세요! 이 게시물에 응답하거나 LinkedIn에서 알려주세요. UX나 비디오 게임 관련해서 어떤 주제라도 얘기 나누는 것을 즐깁니다.\n\n✨ 누군가에게 UX 디자이너가 필요하다면, 저에게 연락해주세요!\n","ogImage":{"url":"/assets/img/2024-05-23-Designingaccessiblevideogames_0.png"},"coverImage":"/assets/img/2024-05-23-Designingaccessiblevideogames_0.png","tag":["Tech"],"readingTime":23},{"title":"내가 마케터가 되고 싶지 않았어요 게임","description":"","date":"2024-05-23 13:41","slug":"2024-05-23-IDidntWanttoBeaGameMarketer","content":"\n![image](/assets/img/2024-05-23-IDidntWanttoBeaGameMarketer_0.png)\n\n아마도 제가 거절한 사람은 오늘 인도네시아의 가장 큰 인디 게임 회사 중 하나의 마케팅 책임자로 일하고 있는 저를 보고 궁금해 할 것입니다. 저 자신도 제 결정에 대해 여전히 의문을 품고 있습니다.\n\n예전엔 마케팅이 거짓말을 하는 것이라고 생각했어요. 나라에서 가장 인기 있는 제품이 되거나, 그 지역에서 가장 인기 있는 음식점이 된다는 것... \"마케팅\"이라는 말이 별로 듣기 싫었죠. 사람들에게 실망시키는 결과를 원하지 않았어요. 아마 사람을 기쁘게 해주는 것은 고집스러운 사람의 기본적인 성격인 것 같아요. 그리고 저는 그런 사람이에요.\n\n2014년 초, 대학을 졸업한 뒤 첫 직장을 얻었습니다. 저는 그래픽 디자인을 공부했기 때문에, 한 모바일 게임 회사에 2D 아티스트로 지원했고 합격했어요! 하지만, 속은 느낌이 들었어요. 그들은 당시 회사를 떠나는 커뮤니티 매니저를 대신할 수 있느냐고 물었어요. 그냥 잠깐이라고 했어요. 그런데, 2.5년이 지나가고 나는 커뮤니티 관리 이상을 했습니다. 유저 유치, 비즈니스 개발, 약간의 모바일 게임 마케팅, 투자자들에게 프레젠테이션을 하는 법 등 Adobe Photoshop이나 Illustrator를 사용하는 일과는 관련이 없는 일들을 배웠어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그때, 내가 모바일 게임 마케터로 근무한 직업을 좋아했었나요? 음.\n\n2017년, 1년 동안 미술 교사로 일한 후 게임 산업으로 돌아와 다시 커뮤니티 매니저가 되었습니다. 이번에는 프리미엄 PC(및 콘솔) 인디 게임 회사에서 일하는 기회를 얻었는데, 모바일 게임과는 전혀 다른 비즈니스 모델을 가지고 있습니다. 쉽다고 생각했지만, 아니었습니다. 커뮤니티, 시장 행동, 사용해야 했던 방법 등 모든 것이 달랐습니다.\n\n하지만 그럼에도 게임 마케팅을 하는 것에서 좋아하는 점을 발견했습니다. 특히 프리미엄 게임에 대한 마케팅을 좋아하는 것이었죠.\n\nSeth Godin의 All Marketers Are Liars (Tell Stories)를 읽은 후에 다시 깨닫게 되었습니다. 책을 아직 다 읽지 못했는데, 지금은 친구가 책을 빌려가고 있어요. 그러나 지금까지는 좋은 읽을거리입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-IDidntWanttoBeaGameMarketer_1.png)\n\n책에 대해 얘기하지 않을 거예요. 대신 (프리미엄) 게임 마케터로서 이야기를 전하는 방법에 대해 조금 이야기해 볼게요.\n\n솔직하지 않을 수 없어요.\n\n모바일 및 프리미엄 게임의 마케팅을 해본 경험을 통해, 프리미엄 게임 플레이어에게는 솔직하지 않을 수 없다는 것을 배웠어요. 모바일에서는 가짜 광고를 사용하여 다운로드를 받고 설치 횟수가 중요한 반면, 프리미엄 게임 플레이어들은 언제든지 환불을 요청하거나 안 좋은 리뷰를 남겨서 당신의 게임이 사람들에게 구매되지 않도록 할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게이머들은 똑똑해요. Steam에서 보던 리뷰들을 구글 플레이나 앱 스토어에서 본 것과 비교했을 때 정말 놀랐어요. 거기서 1점을 주고 \"좋은 게임\"이라고 리뷰하는 것들과는 달리 PC와 콘솔 게이머들은 건설적인 피드백을 주고 게임에서 좋은 점이 무엇인지, 어떤 것이 좋았는지 등을 지적해 줘요.\n\n그저 게임의 좋은 점을 보여주세요.\n\n게임의 픽셀 아트가 잘 만들어졌다고 생각하시나요? 그것이 어떻게 만들어졌는지 보여주고, 게임 안에서 픽셀 아트가 얼마나 멋있게 보이는지 보여주세요. 게임이 가장 맛있는 전투 메카닉을 가지고 있다고 생각하시나요? 동영상을 찍어서 보여주세요. 게임의 음악이 좋으시다고 생각하시나요? 그 음악을 들려주세요.\n\n하지만 기억하세요, 마지막으로 게임을 좋아하는지 결정할 사람들은 잠재적 플레이어들이겠죠... 이것은 시장 유효성을 확인할 때 사용할 수 있어요. (이 말을 설명할 필요가 없는데요, 이것은 별도의 글이 될 수 있기 때문에)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n진정성에 관한 이야기예요.\n\n진정성은 매우 중요해요, 특히 당신의 게임이나 회사가 오랫동안 지속되길 원하고 강력한 커뮤니티나 팬 베이스를 갖고, 당신이 즐겁게 제작하는 게임을 계속 제공하고 싶을 때입니다.\n\n저는 현재 회사에서 거의 7년째 근무하고 있어요. 만약 저가 내가 아닌 다른 사람으로 가장해야 하거나 좋아하지 않거나 즐기지 않는 것을 홍보해야 한다면, 이렇게 오래 지속되지 못할 것 같아요. 제가 알고 있는 게임의 좋은 점을 공유하고, 개발자가 이 게임을 만드는 이유를 말해요... 그리고 나는 운이 좋아 내가 게임을 홍보하고 일하는 것을 즐길 수 있는 회사에서 일하고 있다고 생각해요.\n\n이게 회사가 개발하는 모든 게임을 즐기는 것을 의미할까요? 저는 캐주얼 게이머예요. 전략이나 턴 기반 전술 게임을 할 수 없어 해전 게임, 혹은 전략을 구상해야 하는 게임을 할 수 없어요. 하지만, 우리 회사의 주력 타이틀 중 하나는 턴 기반 메카 전략 게임이에요. 그럼에도 불구하고, 팀이 이 게임을 얼마나 사랑하는지 알기 때문에, 제가 할 일은 그들이 왜 그것을 좋아하는지 물어보고, 어떤 것을 사람들에게 보여주길 원하는지 알아내는 것 뿐이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 게임 마케터로 일하는 것을 좋아하나요?\n\n음, 솔직히 말하자면... 제 꿈은 고양이들과 함께 집에서 종일 게임을 하며 간식을 먹고 일하지 않아도 되는 거예요. 그렇지만 그런 꿈이지만 현재로서는 일하는 것을 즐기는 직업이에요.\n\n그런데 여러분은요? 여러분의 이야기는 무엇인가요?\n","ogImage":{"url":"/assets/img/2024-05-23-IDidntWanttoBeaGameMarketer_0.png"},"coverImage":"/assets/img/2024-05-23-IDidntWanttoBeaGameMarketer_0.png","tag":["Tech"],"readingTime":5},{"title":"Roomsxyz에서의 프로그래밍 파트 1","description":"","date":"2024-05-23 13:39","slug":"2024-05-23-ProgramminginRoomsxyzPart1","content":"\nPart 1 | Part 2 | Part 3\n\nRooms.xyz은 정확히 판타지 콘솔은 아니지만 (과거 몇 가지 기사를 써온 주제) 많은 동일한 원칙을 공유합니다. 그것은 당신이 보설 기반 미니 게임과 상호 작용 경험을 매우 쉽게 만들 수 있는 도구이며, 보설 객체와 Lua 스크립팅을 사용합니다.\n\n공개: 나는 Rooms.xyz 뒤의 3인 스타트업 \"Things, Inc.\"의 직원입니다. \"Inc\" 부분이 다소 기업적으로 보일 수 있지만, 사실은 우리는 무엇을 하는지 모르지만 멋진 것을 만들고 싶어 하는 3인 조직입니다.\n\n이 기사는 객체의 동작을 사용자 정의하기 위해 Rooms에서 Lua 코드를 작성하는 방법의 프로그래밍 모델과 기본 사항 (매우 표면적으로)을 면밀히 살펴봅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nPart 1에서는 기초 사항을 다룰 것입니다:\n\n- 방과 물건\n- 기본 프로그래밍\n- 물건 이동\n- 순서\n\n![이미지](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_0.png)\n\n# 프로그래밍을 해야 할까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n음, 디저트를 먹어야 하나요? 이 기사의 전제는 당신이 프로그래밍에 흥미를 느끼며 프로그래밍이 재미있다는 것입니다. 사실 당신과 나는 당신을 프로그래밍을 하지 못하게 하는 데는 약간의 노력이 필요할 것을 알고 있어요. 만약 토스트기에 API가 있다면 당신은 그것을 프로그래밍할 것입니다. 아마 그것에 API가 있는지도 모르겠네요. 토스트기 프로그래밍을 멈추고 돌아오세요.\n\n이 모든 말의 요점은: 아니, Rooms에서 프로그래밍을 할 필요는 없어요. 단순히 기존 객체를 기반으로 아름다운 방을 만들 수 있어요(라이브러리에는 많은 객체가 있어요!), 많은 객체는 이미 기존 동작을 갖고 있어요. 그러나 높은 천장에 다다르고 동작이 재미있고 독특한 방을 만들고 싶다면, 프로그래밍이 그 방법이에요!\n\n# 방이란 무엇인가요?\n\n방은 작은 상호작용 3D 환경입니다. 그게 바로 당신이 만들고 있는 것. 방이나 상호작용 3D 환경에 흥미가 없다면, 저런, Rooms.xyz를 즐기진 못할 거예요. 방은 미니 게임이 될 수도 있고 사용자가 접근할 수 있는 즐거운(아닐 수도 있지만, 우리는 그렇길 바래요) 경험이 될 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_1.png)\n\n이것은 미니 게임의 예시입니다. 볼링공을 클릭하여 볼링을 할 수 있는 미니 볼링 게임입니다. 아마 볼링은 이렇게 하는 거겠지요.\n\n# 물건이란?\n\n물건이란 객체입니다. 정말, 물건? 더 일반적인 이름을 선택할 수 없었을까요? 음, 네, 객체는 더 일반적이었겠죠. 가끔 커피를 충분히 마시지 않은 경우에는 그것들을 객체라고도 부르기도 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 방 안에 있는 각 물체는 물체(Thing)입니다. 위쪽 방에서 볼링공은 물체입니다. 각 핀도 물체이고, 테이블도 물체이며, 쥬크박스도 물체입니다. 이해하시죠. 모든 것이 물체입니다.\n\n(\\*) 벽과 바닥도 물체입니다만, 누구에게도 말하지 마세요. 왜냐하면 이건 우리 디자인의 이상한 부분이라서 아직 그것이 맞는지 확신하지 못하기 때문이에요.\n\n# 물체를 그렇게 행동하게 만드는 것은 무엇인가요?\n\n스포일러 경고: 코드입니다. 다른 것으로 생각했나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n수정 모드에서 물건을 클릭하고 \"Code\" 버튼을 클릭하면 코드 편집기가 표시됩니다.\n\n<img src=\"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_2.png\" />\n\n코드 편집기에 Lua 코드를 입력할 수 있습니다. Lua는 브라질인이 만든 사랑스러운 스크립트 언어입니다. 나도 브라질인은 아니에요. 다른 브라질인이 만든 거에요. 우리가 참 많죠.\n\n어쨌든, Lua를 자바스크립트의 불편한 부분 없는 버전으로 생각해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ProgramminginRoomsxyzPart1_3](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_3.png)\n\n우리가 코드가 없기 때문에 처음부터 시작할 필요가 없다는 메시지가 나옵니다. 간단한 템플릿을 선택하여 시작하는 것이 좋습니다. Hello 템플릿을 선택해주세요. 이 템플릿을 사용하면 좋습니다. 왜냐하면 더 복잡한 것들을 탐험할 때 직접 모든 것을 배울 수 있다는 것을 깨닫고 이 기사를 읽는 것을 중단할 수도 있기 때문입니다.\n\n또한 모든 API 함수에 대한 완전한 문서가 있으므로 이 자습서를 읽은 후 (또는 중간 중간에) API가 수행할 수 있는 모든 것을 알아볼 수 있습니다.\n\n# 코딩에 들어가기 전에...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRooms.xyz에서 작업을 저장하려면 회원 계정을 만들어야 합니다. 현재 Rooms.xyz가 알파 상태이기 때문에 공식 홈페이지를 통해 초기 액세스를 요청해야 합니다. 홈페이지에서 \"초기 액세스 요청\" 버튼을 클릭하면 됩니다.\n\n그러나 계정을 만들지 않고도 이 튜토리얼을 따라할 수 있습니다. 유일한 주의점은 만든 방을 저장하고 공유할 수 없다는 것입니다.\n\n# 안녕하세요라고 말하기\n\n안녕하세요 템플릿을 클릭하면 미리 작성된 코드가 표시됩니다. 클릭하면 객체가 \"안녕하세요\"라고 말하는 매우 흥미진진한 스크립트입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Programming in Roomsxyz Part1_4](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_4.png)\n\nNow run it, either in the preview window (click Update Preview), or get out of the code editor and enter Preview mode.\n\nThis thing at the top is how you switch from Edit to Preview (that is, Play) mode. You probably already figured this out, but just in case, it's here:\n\n![Programming in Roomsxyz Part1_5](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_5.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해 보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앞으로는 코드 스크린샷을 찍지 않을 거에요 (코드를 보여주는 바보 같은 방식이라서, 커피숍에서 다른 개발자들이 내 모습을 이상하게 쳐다보고 있거든). 대신에 이렇게 작은 블록 안에 코드를 직접 쓸 거에요:\n\n```js\n-- 사용자가 클릭했을 때 실행되는 함수입니다.\nfunction onClick()\n  say(\"Hello\")\nend\n```\n\n물론 그 테이블이 모든 걸 상상할 수 있는 어떤 말이라도 할 수 있도록 string을 수정할 수 있어요. 완전히 다른 문구인 아래와 같이요:\n\n<img src=\"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_7.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신이 더 나은 내용을 찾을 수 있다고 확신해요.\n\n# 핸들러 (미리 정의된 함수)\n\n이전 예제에서 우리의 함수는 onClick으로 불렸어요. 이것은 우연이 아니에요: 사용자가 무언가를 클릭할 때 실행되는 함수에요. 모든 Thing은 고유의 onClick 함수를 가질 수 있어요.\n\n이것은 중복되어 보일 수 있지만, onClick 함수는 반드시 onClick으로 불러져야 해요. \"onclick\"이나 \"ONCLICK\"이나 \"clementine\"으로 불러도 작동하지 않아요. 엔진은 정확히 onClick이라는 이름을 대소문자 구분하여 찾기 때문이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일부 다른 핸들러 함수의 예시는 다음과 같습니다:\n\n- onStart(): 방이 시작될 때 호출됩니다.\n- onCollision(): 물체가 다른 물체와 충돌할 때 호출됩니다.\n- onButtonDown(): 가상 조이스틱 버튼이 눌렸을 때 호출됩니다.\n- onButtonUp(): 가상 조이스틱 버튼이 놓였을 때 호출됩니다.\n- onUpdate(): 한 프레임당 한 번 호출됩니다 (초당 60번).\n\n지금은 이에 대해 걱정할 필요가 없어요. 다음에 일부를 살펴볼 텐데, 그 중 일부는 무시할 거에요. 하지만 그 당시에는 멀리 나아가서 당신이 이 목록을 기억할 정도가 되지 않을 거예요. 그리고 제가 이를 건너뛰었다는 걸 알아차리지 못할 거에요.\n\n# onStart() 함수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n방이 시작할 때 사용자의 작업과 상관없이 무언가를 하고 싶을 때 유용한 기능이에요.\n\n```js\n-- 방이 시작할 때 이 함수가 실행됩니다.\nfunction onStart()\n  say(\"나를 클릭해주세요!\")\nend\n\n-- 사용자가 클릭할 때 이 함수가 실행됩니다.\nfunction onClick()\n  say(\"클릭해주셔서 감사합니다\")\nend\n```\n\n원하는 경우에는 onStart() 안에 초기화 코드를 넣는 대신 함수 밖에 초기화 코드를 놓을 수도 있어요. 이건 스타일의 문제에요:\n\n```js\n-- 방이 시작할 때 이 코드가 실행됩니다.\nsay(\"나를 클릭해주세요!\")\n\n-- 사용자가 클릭할 때 이 함수가 실행됩니다.\nfunction onClick()\n  say(\"클릭해주셔서 감사합니다\")\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n나는 onStart() 안에 있다면 더 깔끔하다고 생각해요. 개인 취향입니다.\n\n# 물리학에 대한 이야기\n\n코드를 따라하며 작업하는 경우, 작업 중인 객체가 물리 유형으로 Kinematic으로 설정되어 있는지 확인하세요. 나중에 더 설명하겠지만, Kinematic 객체는 원하는대로 동작합니다. 동적(비 키네마틱) 객체는 자기 맘대로 동작합니다. 우리는 현재 주인공이니까 그것을 키네마틱으로 설정해서 우리가 움직일 수 있게 해야 해요.\n\n# 물리학에 대한 이야기\n\n코드를 따라하며 작업하는 경우, 작업 중인 객체가 물리 유형으로 Kinematic으로 설정되어 있는지 확인하세요. 나중에 더 설명하겠지만, Kinematic 객체는 원하는대로 동작합니다. 동적(비 키네마틱) 객체는 자기 맘대로 동작합니다. 우리는 현재 주인공이니까 그것을 키네마틱으로 설정해서 우리가 움직일 수 있게 해야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 한 번 시도해보세요!\n\n이 코드를 객체에 적용해보세요. 시작점이 필요하다면 https://rooms.xyz/btco/tutostart에서 시작해보세요. 택시를 클릭하고 코드를 다음과 같이 설정하세요:\n\n```js\n-- 사용자가 클릭했을 때 실행되는 함수입니다.\nfunction onClick()\n  startSpin()\nend\n```\n\n이제 미리보기 모드로 이동하여 클릭해보세요. 회전하기 시작해야 합니다! 실제 자동차에서는 시도하지 마세요. 일반적으로 이 튜토리얼로부터 운전 조언을 받지 마세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*z8Qu3AWjVrfDKmP1mCaRfw.gif)\n\n[여기](https://rooms.xyz/btco/tutospin)에서 결과물을 확인해보세요.\n\n# 즉시 이동하기 (애니메이션 없이)\n\n만약 물체를 새로운 위치로 이동하고 싶다면, setPosition() 함수를 사용하고 새로운 좌표를 알려주면 됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nfunction onClick()\n  -- 방의 중앙으로 이동합니다.\n  setPosition(0, 0, 0)\nend\n```\n\n클릭하면 빠앗, 갑자기 방의 중앙으로 이동합니다 (아마도 차의 탑승자들에게는 매우 거친 경험이 될 것입니다).\n\n결과를 확인하려면 다음 링크를 방문해 보세요: https://rooms.xyz/btco/tutosetpos.\n\n# 부드럽게 이동하기 (애니메이션 포함)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n멋져요! 이제 객체를 순조롭게 이동시키는 방법을 알아보겠습니다. 객체를 순간이동시키는 것이 아닌 특정 양만큼 부드럽게 이동시키려면 startMoveBy() 함수를 사용하면 됩니다. 이 함수는 delta(x, y, z)와 총 시간을 인수로 받아 요청한 위치로 객체를 이동시킵니다.\n\n```js\n-- 사용자가 클릭했을 때 실행되는 함수.\nfunction onClick()\n  say(\"출발합니다!\")\n  -- 1초 동안 남쪽으로 30단위 이동합니다.\n  startMoveBy(0, 0, -30, 1)\nend\n```\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*VXfa4E4HAm71LVNfawS4vA.gif\" />\n\n왜 0, 0, -30일까요? 우리의 좌표 시스템이 그런식으로 작동하기 때문이죠:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_9.png\" />\n\n그래서 +Z는 왼쪽 벽 쪽이고, +X는 오른쪽 벽 쪽입니다. Cardinal 방향은 다음과 같이 정의합시다:\n\n- \"북쪽\"이라고 할 때, +Z 쪽을 의미합니다.\n- \"동쪽\"이라고 할 때, +X 쪽을 의미합니다.\n- \"남쪽\"이라고 할 때, -Z 쪽을 의미합니다.\n- \"서쪽\"이라고 할 때, -X 쪽을 의미합니다.\n- \"위쪽\"이라고 할 때, +Y 쪽을 의미합니다.\n- \"아래쪽\"이라고 할 때, -Y 쪽을 의미합니다.\n\n그리고 방의 중심은 (0, 0, 0) 입니다. 이는 방 중앙에 있는 바닥의 지점을 의미합니다. 방의 표면은 약 95x95의 크기이며, 높이는 75 단위입니다. 따라서 X와 Z 좌표는 약 -47.5에서 +47.5까지이며, Y 좌표는 0에서 75까지입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n결과를 확인하려면 다음 주소를 확인해보세요: [https://rooms.xyz/btco/tutomove](https://rooms.xyz/btco/tutomove)\n\n# 움직이고 멈추는 차\n\n오늘 시장에서 가장 좋은 차들은 움직이고 멈추는 기능을 갖추고 있어요. 함께 만들어 보도록 하죠. 클릭하면 차가 움직이고, 다시 클릭하면 멈추는 기능을 만들어 보겠습니다. 이제 코드를 확인해봅시다:\n\n```js\nmoving = false\n\n-- 사용자가 클릭했을 때 실행되는 함수입니다.\nfunction onClick()\n  if moving then\n    stopMove()\n    moving = false\n  else\n    startMoveBy(0, 0, -48, 10)\n    moving = true\n  end\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시는 startMoveBy()로 시작된 모션을 중지하기 위해 stopMove()를 호출하는 방법을 보여주며, 차량의 상태(이동 중 또는 이동 중이 아님)를 추적할 수 있는 불리언 변수를 가지는 방법을 보여줍니다. 또한 함수 외부에 변수가 존재할 수 있음을 보여주며, 이는 함수 내에서 선언된 경우 함수 호출 간에 값을 유지할 수 있음을 보여줍니다.\n\n결과를 확인하세요: https://rooms.xyz/btco/tutostartstop\n\n# 순차적 실행\n\n의도하지 않은 점 중 하나는 say(), startMoveBy() 등과 같은 함수가 비동기적이라는 것입니다. 즉, 이 함수들은 코드의 실행이 계속될 동안 백그라운드에서 실행됩니다. 따라서 이러한 함수를 여러 번 호출하는 경우 이 함수들은 함께 실행되며 순차적으로 실행되지 않습니다. 예를 들어:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n-- 경고: 이것이 하는 것 같은 일은 하지 않습니다.\nfunction onClick()\n  -- 남쪽으로 20 단위 이동, 1초 동안에.\n  startMoveBy(0, 0, -20, 2)\n  -- 서쪽으로 20 단위 이동, 1초 동안에.\n  startMoveBy(-20, 0, 0, 2)\n  -- 작업이 완료되었다고 말합니다.\n  say(\"작업 완료\")\n  -- 회전을 시작합니다.\n  startSpin()\nend\n```\n\n자동차가 먼저 남쪽으로 20 단위 이동하고, 그런 다음 서쪽으로 20 단위 이동하고, \"작업 완료\"를 말하고 회전을 시작할 것이라고 생각할 수 있습니다. 하지만 실제로 모든 것을 동시에 시도하려고 하고 정말 엉망입니다.\n\n그래서 어떻게 해야 하나요? 다른 함수를 우리 레퍼토리에 추가해야 합니다. 그리고 레퍼토리는 멋진 프랑스어 단어이기도 하니까! 그 함수는 wait()입니다. 특정 시간을 기다렸다가 다른 함수를 호출합니다. 우리는 순서대로 수행하기 위해 이를 사용할 수 있습니다.\n\n```js\nfunction onClick()\n  -- 남쪽으로 20 단위 이동, 1초 동안에.\n  startMoveBy(0, 0, -20, 1)\n  -- 1초 기다립니다 (이동하는 데 걸리는 시간)\n  -- 그리고 moveWest를 호출합니다.\n  wait(1, moveWest)\nend\n\nfunction moveWest()\n  -- 서쪽으로 20 단위 이동, 1초 동안에.\n  startMoveBy(-20, 0, 0, 1)\n  -- 1초 기다립니다 (이동하는 데 걸리는 시간)\n  -- 그리고 sayDone을 호출합니다.\n  wait(1, sayDone)\nend\n\nfunction sayDone()\n  say(\"작업 완료\")\n  -- 회전을 시작합니다.\n  startSpin()\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*CL1gPOlI-i0jEA8VNiiH1w.gif)\n\n이건 동작합니다. 차가 옆으로 드리프트하고 회전하지 않는다는 사실을 제외하고 잘 작동합니다. 하지만 운전 팁은 제게 말하지 않았나요?\n\n결과를 확인하세요: [여기](https://rooms.xyz/btco/tutoseq)\n\n# 주기적으로 무언가를 수행하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 간격마다 주기적으로 함수를 호출하려면 every()를 사용할 수 있습니다.\n\n여기 한 예제가 있어요. 이러한 예제의 효과를 해소하기 위해 커피를 마셔야 합니다.\n\n이 예에서 양은 다음과 같은 코드를 가지고 있습니다:\n\n```js\nc = 0\n\nfunction onStart()\n  -- count() 함수를 1초마다 호출합니다.\n  every(1, count)\nend\n\nfunction count()\n  c = c + 1\n  say(c .. \" sheep\")\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서 onStart()에서 우리는 count() 함수가 매 초 호출되기를 원한다고 말합니다. 엔진은 매 초 count() 함수를 호출하여 우리는 카운터를 증가시키고 양이 현재 카운트를 말하도록합니다.\n\n![이미지](/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_10.png)\n\n결과 확인: https://rooms.xyz/btco/tutocount\n\n참고: 성능상의 이유로 간격을 0.25초보다 작게 설정할 수 없습니다. 그러나 다른 방법으로 여전히 성능을 저하시킬 수 있으니 포기하지 마세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Part 1 마침\n\n와우! 이렇게 멀리 진전했고 내 유머 감각과 글쓰기 스타일을 참으셨군요. Part 2에서 더 나아갈 수는 없지만, 아래 링크를 클릭해서 계속 진행해보세요.\n\nPart 2로 이동하기 →\n","ogImage":{"url":"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_0.png"},"coverImage":"/assets/img/2024-05-23-ProgramminginRoomsxyzPart1_0.png","tag":["Tech"],"readingTime":17},{"title":"100일간의 스팀 세일 분석","description":"","date":"2024-05-23 13:36","slug":"2024-05-23-100DaysofSteamSalesAnalysis","content":"\n게임 개발 산업에 종사한 사람이라면, 성공적인 게임을 만드는 것이 얼마나 어려운지 알 것입니다. 누구도 그 공식을 알아내지 못했습니다. 모든 것을 올바르게 해도 실패할 수 있죠.\n\n우리는 소중한 성공 사례에 감격합니다. Stardew Valley, Lethal Company, Undertale. 가능합니다. 그러나 성공 사례마다 수천 개의 잊혀진 실패 사례가 있습니다.\n\n우리는 우리의 열정적인 프로젝트에 수백 시간을 투자합니다. 고용주들이 수십만 달러를 쓸 것이라고 확신할 수도 있는 노동이죠. 대신 우리는 모든 걸 스스로에게 걸어, 대부분 몇 달러만 돌려받게 됩니다.\n\n우리는 용감한 건지, 그냥 바보인 건지요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 질문을 해결하고 동료 개발자들에게 희망을 줄 수 있기를 바라며, 2023년 1월 1일부터 스팀에서 출시된 게임 100일을 살펴보고 판매 성적을 분석하여 모두가 꿈을 이루는 확률을 알아보았습니다.\n\n# 개요\n\n100일 동안 총 2823개의 유료 게임이 출시되었으며, 하루 평균 새로운 게임은 28개입니다.\n\n스팀 수수료를 고려한 평균 매출은 228,723달러(미국 달러)였습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n처음에는 좋아 보일 수 있지만, 스팀 세일은 공격적인 파레토 분포를 따릅니다. 이는 일반적으로 '80:20' 규칙으로 알려진데, 입력의 20%가 결과의 80%를 만든다는 의미입니다.\n\n스팀 세일은 조금 더 극단적입니다:\n\n![Steam Sales Analysis](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png)\n\n중앙값 수익, 즉 평균 게임이 벌어들인 금액에 더 관심이 있습니다. 이를 시각화하기 쉽게 만들기 위해 10만 달러 이상 벌어든 모든 게임을 제거해 보겣습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_1.png)\n\n`스팀`의 수익 중앙값은 `대단한` $799 미국 달러였습니다. 처참해 보일 수 있지만, 이 데이터를 다른 말로 바꾸면 더 희망적으로 보일 수 있습니다.\n\n출시된 게임 중 1개당 $1,000,000 이상을 벌어들인 게임은 42개 중 1개이며, 매주 4개의 초대 성공적인 게임을 나타냅니다.\n\n게임 중 1개당 $100,000 이상을 벌어들인 게임은 12개 중 1개이며, 주당 17개의 성공적인 게임을 나타냅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 당신의 게임이 상위 8%에 들면 생계를 유지할 수 있어요. 상위 2%에 들면 거액의 수익을 올릴 수 있어요.\n\n어렵긴 하지만 불가능하진 않아요.\n\n안타깝게도, 5개 중 1개 게임은 $100 미만 수익을 올렸어요. 매주 40개의 실패한 게임이 있어요.\n\n**방법**\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSteams API를 사용하여 100일 간의 게임 출시를 가져 와 파싱하기 위해 파이썬을 사용했습니다. 나쁜 항목을 제거하고 JSON 구조를 단순화 한 후 CSV로 변환하여 다음과 같이 구글 스프레드 시트로 가져왔습니다:\n\n[구글 스프레드 시트 링크](https://docs.google.com/spreadsheets/d/1T-Tw6PwxEAqYMnos5pYwRbwcNVacYn9zCt6HpL9jLfQ/edit?usp=sharing)\n\n<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_2.png\" />\n\n스팀 API에서 얻을 수 없는 유일한 측정 항목은 수익이었습니다. 그러나 스팀 게임이 소유자 대 리뷰 비율이 30 대 1로 매우 잘 알려져 있으며 이는 모든 게임에 90%의 상관 관계를 가지고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n소스: https://vginsights.com/insights/article/further-analysis-into-steam-reviews-to-sales-ratio-how-to-estimate-video-game-sales\n\n스팀은 플랫폼의 매출에서 30%의 수수료를 가져갑니다. 이는 순수 매출로 이어집니다.\n\n# 양적 데이터\n\n장르, 콘텐츠 등급 및 VR 지원과 같은 기능과 같은 요인별 중앙값 매출을 분석해 봅시다. 먼저 장르부터 시작합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_3.png\" />\n\n친구들 게임이 MMO RPG보다 현저히 성적이 안 좋다는 것을 알 수 있어요. 하지만 이러한 모바일 게임들이 몇 일 만에 만들어질 수 있다는 사실을 고려해야 해요. 한편 MMO는 큰 예산과 수 년의 생산 시간을 요구해요.\n\n다음은 플랫폼 분포를 살펴봅시다.\n\n<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_4.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파레토 분포에 관한 보편적인 사실 중 하나는 그의 공격적인 정도가 데이터 세트의 크기와 비례한다는 것입니다. 다시 말해, 경쟁이 더 많은 시장에서는 불평등이 더 많이 나타납니다.\n\n간단히 맥(mac)의 게임이 더 적기 때문에 경쟁이 적고, 구매자가 게임을 선택할 기회가 더 많습니다.\n\n재미있게도, VR의 수익성은 크게 감소했습니다. 일정 시점에는 게임 수가 적어서 매출 중앙값이 $150,000에 이르렀습니다.\n\n마지막으로 콘텐츠 등급을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_5.png)\n\n데이터 세트에서 대략 10%의 게임이 '성인 전용'으로 표시되어 있습니다. 이들은 평균적인 게임만큼 잘 할 수 있었습니다. 다른 한편으로, 폭력은 명백히 경쟁에서 우위를 차지했습니다.\n\n이 데이터의 타당성도 살펴보겠습니다. 각 게임이 출시 월에 따라 얼마나 많은 수익을 올렸는지부터 시작해 보죠.\n\n![image](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2023년 1월 1일을 선택한 이유는 데이터를 최근 것으로 유지하면서도 게임이 수익을 얻을 수 있는 충분한 시간을 주기 위해서예요.\n\n여기서 볼 수 있듯이 중간 수준의 게임은 한 해 후에도 월 평균 90달러 정도의 수익을 올리고 있어요.\n\n마지막으로, 상관관계와 인과관계를 다루고 있음을 강조하기 위해, 게임 이름의 첫 글자로 매출을 시각화한 것이 재미있을 것 같아서요.\n\n![그림](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신이 게임 제목을 'y'로 시작하게 하면 'v'로 시작하는 것보다 수익이 15배 많아진다는 정말인가요?\n\n아마 그렇지 않을 거에요.\n\n데이터를 살펴보는 것이 중요하지만, 이렇게 많은 불확실성 속에서 세세한 부분에 대해 파고들어가는 것은 그다지 유용하지 않을 수 있어요.\n\n# 질적 데이터\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저는 확실히 첫 번째로 스팀 세일을 분석하려는 사람은 아니에요. 이미 그에 관한 전체 웹사이트들이 있어요. 이 연구를 시작한 후에야 알게 된 사실이에요:\n\n하지만, 질적 연구에 참여하는 사람을 별로 보지 못해요. 즉, 개별 항목을 보다 자세히 살피는 것이죠. 제 데이터 세트에 게임 스크린샷을 추가한 이유 중 하나는 어떤 게임이 잘 되고 있는지 감을 잡을 수 있도록 도와주고자 했기 때문이에요.\n\n그래서 이제 3가지 예시를 질적으로 분석해보려고 해요:\n\n- 데이터를 기반으로 매우 성공적인 게임이지만, 사실 그렇지 않아야 했던 게임.\n- 대부분의 개발자에게 이룰 수 있는 것처럼 보이는 성공한 게임들.\n- 실패한 게임(또는 숨겨진 보석). 실패했지만, 더 나은 성과를 이루었을지도 모르는 게임들.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 놀랍게 성공한\n\nPizza Tower ($20,033,360):\n\n![Pizza Tower](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_8.png)\n\nPizzas Tower는 GameMaker로 만든 '잘 못 그린' 예술이 특징인 2D 플랫포머 게임입니다. 이런 상황에도 불구하고 Pizza Tower는 풍자, 주제, 혁신을 적절히 조합하여 성공을 거두었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2D 플랫포머는 가장 경쟁력이 있고 매출 성적이 가장 낮은 장르 중 하나입니다. Pizza Tower는 모든 규칙을 깨고 어떤 꿈의 게임이든 가능함을 보여줍니다.\n\n4년 개발 주기로 2,000만 달러의 매출을 달성했어요.\n\n## 중간 성공적이고 가능성 있는 게임\n\nInto the Flames ($406,627)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_9.png\" />\n\nhttps://store.steampowered.com/app/1222300/Into_The_Flames/\n\nInto the Flames는 활발히 개발 중인 소방 시뮬레이션 게임으로, 한 명의 개발자가 개발하고 있을 수 있습니다. 그래픽은 최고는 아니지만, 어떤 흥미를 끌고 있는 특정 주제를 다루고 있습니다.\n\n제 꿈의 세팅($255,085)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n~~<img src=\"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_10.png\" />~~\n\n[링크](https://store.steampowered.com/app/2200780/My_Dream_Setup/)\n\n내 꿈의 세팅은 간단하지만 매우 정교한 시뮬레이션 게임으로, 최고의 게이밍 룸을 만드는 데 초점을 맞추고 있습니다.\n\n이는 모든 게이머가 익숙한 주제를 다루고 있으며, $5의 가격표로 쉽게 구매할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nBeton Brutal ($117,945)\n\n![Screenshot](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_11.png)\n\nAnother game from a solo developer. A single player parkour game with some beautiful, brutalist inspired architecture.\n\nFinding success with any of the above games would, at the very least, fund your solo development endeavors for years to come.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 실패한 게임 (숨은 보물들)\n\n지금까지 카테고리 예시를 찾는 것은 쉬웠습니다. 왜냐하면 우리는 게임 중 상위 8%만 살펴보면 되기 때문이죠. 이제 우리는 그 꿈을 이루지 못한 2600개의 다른 타이틀로 깊게 파고들어봅니다.\n\n좋은 소식은 무언가 돋보이는 게임을 발견하려고 수천 개의 게임을 스크롤해야 했다는 것입니다. 즉, 대부분의 게임들이 열등한 위치에 있는게 타당하다는 것을 뜻하는 더 좋은 방법입니다.\n\nA Rum Tale ($63)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_12.png)\n\n[A Rum Tale](https://store.steampowered.com/app/2246310/A_Rum_Tale/)\n\n이 게임은 정말 잘 만들어진 플랫포머 게임입니다. 하지만 리뷰가 단 3개밖에 없네요.\n\n그래픽이 탁 트이고 체적 안개 기능까지 갖추고 있는데, 이 정도면 좀 더 많은 관심을 받았으면 하는데요. 소규모 팬덤도 없는 것이 놀랍네요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그 정보를 찾기 어려울 수 있습니다. 이는 마케팅 실패를 보여줄 수 있습니다.\n\n플레임 키퍼 ($9,933)\n\n![이미지](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_13.png)\n\n[링크](https://store.steampowered.com/app/1374230/Flame_Keeper/)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n귀엽고 테마가 매력적인 액션 로그 라이트 게임입니다. $9,000에 매력적인 요소를 보였지만, 개발자가 투자금을 회수했는지 의문스럽습니다.\n\n아마도 75%의 리뷰 평점 때문에 인기를 얻지 못한 것 같아요.\n\n킹에게 공격 ($198)\n\n![이미지](/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://store.steampowered.com/app/2108410/Attack_on_King_Reloaded/\n\n이 VR 게임은 RPG 전략 장르를 완전히 몰입형으로 조합한 흥미로운 작품입니다. 정교한 그래픽을 갖추고 있는 것으로 보입니다.\n\n그러나 독특한 스타일에도 불구하고 주목을 받지 못하고 있다고 하네요.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 연구 결과를 기반으로, 이것은 나에게 그리고 다른 인디 개발자들에게 제안할 팁입니다.\n\n## 큰 그림을 그리라아니면 집에 귀환하라.\n\n게임을 작게 유지하는 것에 대한 모든 관습적인 조언에도 불구하고, 자신이 감당할 수 있는 것 이상의 일을 성공적으로 해낸 개발자들이 가장 높은 곳에 도달하는 것처럼 보입니다.\n\n왜냐하면 이 세계는 승자가 모두를 가져가는 것이기 때문입니다. '괜찮은' 게임을 만들었다고해서 어떤 칭찬도 받을 수 없는 것이죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n게임이 복잡해야 한다는 뜻은 아니에요. 간단한 게임도 충분하죠. 그저 꼭 필요한 것만 잘 갖추어 주면 돼요. 예를 들어, 예술, 상점 페이지, 음악, 시각 효과, 게임 플레이, 플레이어 경험 등이 선택한 장르에 맞게 최고 수준이어야 해요.\n\n## 향수를 활용하세요\n\n개발자로서 우리는 창의성과 독창성을 자랑스러워해요. 여러분이 좋아하는 게임을 그대로 복사해서 만들라는 건 아니에요. 그런 게임들은 대체로 성공하지 않거든요. 하지만 사랑받는 시리즈에서 영감을 받으면 플레이어들과 감성적으로 연결될 수 있어요.\n\n만일 여러분의 게임 이미지가 플레이어들에게 좋은 추억을 떠올리게 하면서 동시에 새롭고 흥미로운 것을 제공한다면, 누르는 클릭을 유도하는 데 성공할 가능성이 높아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오늘날에도 '뱀파이어 생존자' 장르 중에서 새로운 게임들이 약간 다르고 조금 더 나은 점으로 성공을 거두고 있어요.\n\n새로운 장르를 창조하는 것은 판매를 한다고 느껴질 수도 있지만, 플레이어들에게 자신의 게임을 이해하고 그 시간과 돈을 투자하는 가치가 있다고 설득하는 것은 어렵다는 문제가 있어요.\n\n## 위대함은 부정할 수 없어요.\n\n매주 스팀에서는 매출이 100만 달러 이상이 될 4개의 게임이 출시되어요. 그것은 연간 200개 이상이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n200 명 중 한 명이 될 수 있다고 믿나요? 제가 그렇게 생각해요. 그게 아니었다면 이 글을 읽고 있지 않으셨을 거예요.\n\n위대한 게임은 부정할 수 없어요. 그것들은 피할 수 없어요. 그만큼 열려 있는 가능성이 크거든요.\n\n당신의 게임에서 '출시' 버튼을 누르면, 만약 그 날 다른 27명이 출시한 게임보다 나은 퀄리티라면, 당신은 성공했다고 볼 수 있어요.\n\n그렇지 않다면, 내일이 또 있을 거예요. 함께 힘내봐요!\n","ogImage":{"url":"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png"},"coverImage":"/assets/img/2024-05-23-100DaysofSteamSalesAnalysis_0.png","tag":["Tech"],"readingTime":15},{"title":"프로듀서로부터 온 편지","description":"","date":"2024-05-23 13:35","slug":"2024-05-23-LetterfromtheProducer","content":"\n# 2024년 5월\n\n![이미지](/assets/img/2024-05-23-LetterfromtheProducer_0.png)\n\n안녕하세요,\n\nBitcraft Closed Alpha(1)가 4월 30일에 종료되었고, 참으로 멋진 여정이었습니다! 먼저, 참가해 주신 모든 테스터 여러분께 감사드립니다. 피드백을 공유해 주시고 버그를 신고해 주신 노력에 진심으로 감사드리며, 가장 중요한 것은 언제나 함께하는 커뮤니티 여러분이 조금 험난한 여정 속에서도 인내심과 이해를 보여 주신 점에 감사드립니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 것이 처음에는 잘 진행되었지만 며칠 지나고 나면 몇 가지 문제가 발생하기 시작했고, 특히 여러 플레이어들이 긴 시간 동안 동일한 세계를 공유할 때 그 문제들이 더욱 두드러지게 나타났습니다. 바로 이것이 테스트의 요점입니다 — 하지만 어쨌든, 서버를 두 달 이상 닫아놓은 것은 우리가 희망하지 않았던 일이었습니다. BitCraft를 다시 작동시키기 위해 힘들게 노력하는 동안 커뮤니티로부터 받은 지원에 다시 한 번 감사드립니다.\n\n![LetterfromtheProducer_1](/assets/img/2024-05-23-LetterfromtheProducer_1.png)\n\n아울러, 알파 테스트 중 BitCraft의 비디오를 제작하고 스트리밍한 모든 콘텐츠 크리에이터들에게도 인사를 전합니다. 우리는 프리-알파에서 클로즈드 알파로 전환된 게임의 NDA가 없을 위험이 있었고, 그것이 완성도 있는 게임 경험을 제공하지 않을 것이라는 것을 알고 있었습니다. 여러분 모두가 스트리밍하면서 실시간으로 기술적 문제를 다루는 동안 훌륭한 대우를 해 주고 이해해 주셨습니다.\n\n다행히도 몇 번의 야행 끝에 BitCraft를 다시 발표할 수 있는 상태로 만들었으며, 두 번째 테스트의 후반부는 비교적 원활하게 진행되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![LetterfromtheProducer_2](/assets/img/2024-05-23-LetterfromtheProducer_2.png)\n\n테스트 서버를 종료한 다음 주, Clockwork Labs 팀은 회사 워크샵에 참석했어요! 이번이 많은 분들이 오랜 시간 동료들을 첫 만남했던 시간이었어요! 저희는 등산, 보트 여행, 탈출 게임, 캠프파이어 모임을 통해 에너지를 모았고 BitCraft, SpacetimeDB 및 Clockwork Labs 전체의 다음 단계를 논의하고 계획했어요.\n\n![LetterfromtheProducer_3](/assets/img/2024-05-23-LetterfromtheProducer_3.png)\n\n이제 저희는 돌아와서 다가올 도전에 대처할 준비가 되었어요. 하지만 먼저, BitCraft Closed Alpha one에서 배운 내용을 간단히 살펴볼게요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![LetterfromtheProducer_4](/assets/img/2024-05-23-LetterfromtheProducer_4.png)\n\nRound-up — Closed Alpha 1\n\nLet’s start with a few numbers. 6452 players tested BitCraft for more than one hour. A total of 2211 claim totems have been built. We will make adjustments to the onboarding experience here, to make players feel less pressured to immediately settle down but maybe join a claim during their first steps in BitCraft. 128 claims had 5 or more members and 83 players had joined the largest settlement.\n\n![LetterfromtheProducer_5](/assets/img/2024-05-23-LetterfromtheProducer_5.png)\n\nWe were excited to see testers building larger villages and cooperating to quickly leave the Stone Age and reach higher-tier technology. Many players started specializing, and we are happy with the direction the cooperative gameplay went with coordination. The tester feedback will help us further improve, polish, and continuously develop the basic systems already in place like chat and claim management. Specifically, we will also address the hurdles some solo testers faced with their claim — nobody should have to worry about losing their progress during the first hours of playing BitCraft. But everything considered, we are happy with the results and believe that the town-scale gameplay is heading in the right direction.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본 기계 및 구현을 더 자세히 살펴봐야 하는 요소는 플레이어 간 상품 거래입니다. 시험 결과, 정착지 간 번창하는 거래에 필요한 적절한 도구와 인센티브가 아직 부족하다는 것이 확인되었습니다. 게임 디자이너들은 많은 플레이어와 이야기를 나누어 상황을 완전히 이해하고 식별된 문제를 해결할 계획을 이미 가지고 있으며, 이는 비트크래프트의 상인 생활을 재미있고 보람찬 경험으로 만들어 낼 것입니다.\n\n또한 이동 시스템이 있습니다. 우리는 클릭해서 이동하는 시스템을 구현함으로써 최상의 장기적 게임 경험을 제공할 것으로 믿지만, 사실은 거의 모든 새로운 테스터가 적응하는 데 시간이 필요하다는 것이 분명해졌습니다. 우리는 WASD 이동을 요청하는 열정적인 초기 피드백을 받았지만, 익숙해지면 포인트투클릭이 더 나은 편리한 게임 경험을 제공한다는 것에 대해 숙련된 테스터들 간에 토론이 이루어졌습니다.\n더 나은 경험을 위해 나아가면서 첫날 잠재적 플레이어를 잃는 것은 분명히 우리의 의도가 아닙니다. WASD 이동이 구현된 이후 나중에 Alpha Test(닫힌 알파 2가 아님)를 실행할 계획입니다. 이 테스트에서의 데이터와 피드백은 우리가 올바른 방향으로 나아갈 수 있도록 도와줄 것입니다.\n\n이제 다음 단계 — 닫힌 알파 2\n우리의 현재 계획은 2024년 6월 16일에 다음 테스트를 시작하는 것입니다. 알파 2는 제국 시스템의 첫 번째 반복 테스트에 초점을 맞출 것입니다. 이는 데이터 및 피드백을 수집하기 위해 진행되는 짧은 시범 테스트로 예상됩니다.\n기간, 테스터 수 및 초대 절차 등 세부 정보는 아직 논의 중에 있습니다. 추후 공지를 통해 안내해드릴 예정입니다.\n다음 테스트에서 제국 시스템이 중점이 될 것이지만, 기존 콘텐츠를 계속해서 보강할 것입니다. 게임 밸런스 개선, 새로운 아트 자산 및 다양한 세부사항이 시간이 지남에 따라 추가될 것으로 기대할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다! 더 많은 소식을 기대해주세요!\n\n감사합니다,\nAlessandro\n","ogImage":{"url":"/assets/img/2024-05-23-LetterfromtheProducer_0.png"},"coverImage":"/assets/img/2024-05-23-LetterfromtheProducer_0.png","tag":["Tech"],"readingTime":6},{"title":"프로모션에 대한 공학 매니저의 고백","description":"","date":"2024-05-23 13:33","slug":"2024-05-23-ConfessionofanEngineeringManageronPromotions","content":"\n![이미지](/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png)\n\n많이 들어온 것 중에 한 가지 예제로 좋은 매니저의 핵심 지표는 누군가를 승진시키는 능력이라고 들거나 들어 봤습니다. 표면적으로는 충분히 합리적으로 들립니다. 결국, 매니저는 자신의 사람들을 승진시킬 수 없다면 무엇을 하는 걸까요?\n\n더 깊이 들어가보면, 이 명제는 오해를 불러일으킵니다.\n\n저는 듣긴 했고, 유감스럽게도 스스로도 이를 말해본 적이 있습니다. 엔지니어링 매니저로서 승진 판정 회의에 참여하면 마치 후보를 대신해서 타석에 들어가는 것이 야구에서 대타수 비슷하다는 말씀을 들어왔습니다. 후보는 스트라이크 피치이고, 매니저의 일은 대타로서 4구짜리 패스트볼을 홈런으로 쳐야 하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특이사항이 잘못되었습니다.\n\n다른 변수 중 두 가지만 고려하세요: 상승 시장 대 하락 시장, 대기업 대 중소기업.\n\n## 시장 상황\n\n첫째, 좋은 시기에는 기업들이 유동성과 낮은 이자율로 자극을 받고, 경영진의 목표는 성장을 위해 모두 사용하게 됩니다. 이러한 환경에서 조직은 가로 및 세로로 확장해야 하므로, 빠르게 사람을 승진시키는 것은 필수적인 일과 신입사원을 유치하는 방법입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어려운 시기에는 프로모션이 종종 지연되거나 훨씬 더 엄격한 검토를 받을 수 있습니다. 대형 테크 기업은 일반적으로 해고(유감없는)와 이직(유감 있는)으로 구성된 최소 15%의 교체 대상을 갖고 있습니다. 시장이 활발할 때, 자발적인 이직은 일반적으로 적어도 10%는 발생하기 때문에 해고를 최소화하려고 합니다. 그러나 시장이 침체할 때, 이직은 감소하고 기업은 해고를 증가시키고 인력을 오래 유지하려고 합니다.\n\n## 자본 지출\n\n둘째로, 인재에 지출할 자본이 적은 중소기업이나 기업은 종종 직함 팽창이나 빠른 승진 경로에 의존하곤 합니다. 제 경험상으로, 기업들이 비문으로 제정하지 않은 인상과 가장 많은 이직을 두려워하는 사람에 대한 역순 스택 랭킹만을 기반으로 승진시키는 경우를 보았습니다. 그들은 성과를 보상으로 승진시킨다고 말할 수 있습니다.\n\n그에 비해 대기업들 및 특히 대규모 기술 기업들은 종종 그 반대로 행동합니다. 그들은 모든 분야에서 다음 단계에 존재함이 입증될 때까지 직원들을 현재 수준에 유지시키곤 합니다. 냉소적으로 바라보면, 누군가가 확실하게 다음 수준에 준비되어 있지 않으면 승진이 불가능하다는 뜻입니다. 또한, 그러한 기업에서는 고문련 엔지니어 포지션이 일반적으로 경력의 맥이며, 그 이후의 다음 수준으로 진출하는 탈출 속도가 다른 곳보다 훨씬 높습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가장 나쁜 경우 — 뜨거운 시장에서 소규모 회사, 승진은 대부분 담당자가 자신의 직원을 구두로 잘 홍보하는 능력에 달려 있습니다. 지정타자의 비유가 꼭 어울립니다. 결과는 종종 잘못 계산되고 불공평할 수 있습니다. 자신의 매니저가 황금처럼 말 잘하는 사람은 다른 사람의 비용으로 승진할 수 있습니다.\n\n승진은 데이터 비교의 표준화되고 투명한 프로세스여야 하며 충분한 명확성이 있어야 합니다. 매니저의 역할은 데이터를 신중하게 기록하고 쇼케이스하며, 직원의 공헌과 영향을 양적 및 질적으로 깊게 이해해야 합니다. 아래는 예시 목록입니다:\n\n양적 데이터 샘플\n\n- 코딩: diff\\* 개수, diff 당 평균 수정 횟수, 코드 리뷰 횟수\n- 문서화: 설계 문서 (RFC\\*\\*) 개수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- diff는 주 코드베이스에 병합된 코드 변경의 단위이며, 병합 요청 등으로도 알려져 있어요.\n\n\\*\\* RFC(의견 요청); 디자인 및 리뷰를 위한 표준화된 문서\n\n질적 데이터 샘플\n\n- 코딩: 디자인 패턴, 코드 커버리지\n- 디자인: 디자인의 견고성, 코멘트 대응\n- 운영: 인시던트 관리, 당직 교대체제\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 제기된 비정상적인 상황을 제외하고 승진을 안정적으로 이룰 수 있는 세 가지 중요 권고 사항입니다:\n\n```js\n1. 현재 수준에서 뛰어나게 성과를 올린 후, \"위로 치“\n2. 미래 승진 추천자들과 협력\n3. 경쟁 상황 파악하기\n```\n\n## 현재 수준에서 뛰어나게 성과를 올린 후, “위로 치“\n\n어떤 사람들은 현재 수준에서 뛰어난 성과를 낸 후에야 그보다 한 단계 높은 수준의 성과를 얻으려는 실수를 범할 때가 있습니다. 예를 들어, 중급 직원에게 요구되는 평가 지표는 일반적으로 우수한 코딩 생산성입니다(시니어 직원보다 더 높은 수준). 코드 작성 능력이 탁월하고 빠른 속도로 작업을 완료하는 능력을 보여주지 않은 채 프로젝트를 주도하려는 것은 실수일 수 있습니다. 결국, 제한된 시간 내에 두 가지 모두 최적화하는 것은 매우 어려울 수 있습니다. 여기에서 매니저의 역할은 직원들의 승진 경로를 저해하지 않도록 올바르게 배치하는 일입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 미래 프로모션 엔도서와 협업하기\n\n프로모션을 위해 팀 외부 엔도서가 필요하기 때문에 안정적으로 지지를 받으려면 상호 기능적 프로젝트에서 기회를 찾아 수준 +2/3/4 직원과 협업해야 합니다. 인정받을만한 일을 해내고 그에 대해 인정받는 것이 유일한 방법입니다. 간단히 말해서, 외부 시니어 직원들과의 상호 기능적 프로젝트에서 협업하지 않으면 승진하기가 거의 불가능합니다.\n\n이 과정은 밀어서와 끌어서 둘 다 필요합니다: 매니저는 \"승진 가능한\" 직원을 눈에 띄는 프로젝트에 배치해야 하며 직원들도 이와 같은 프로젝트를 적극적으로 요청해야 합니다.\n\n\\*현재 수준이 중급이라면 L+2는 스태프 엔지니어, L+3은 시니어 스태프 엔지니어가 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 경쟁사 파악하기\n\n누구의 말도 믿지 마세요. 매 프로모션 주기마다, 홍보를 위한 예산과 업무 성과 향상 계획(PIP)이 할당됩니다. 즉, 경영진은 직원들을 순위에 따라 정렬하고 최상위 및 최하위 업무 성과자를 식별합니다. 일반적으로 상위 15%와 하위 15%로 나누어집니다.\n\n매니저와 성장 가능성이 있는 직원은 경영진의 최고 성과자가 누구인지 충분히 조사하고 주기적으로 그들의 양적 및 질적 지표를 모니터링해야 합니다. 기준이 어디에 있는지 주의 깊게 살펴보고 동일한 리그에 속하기 위해 노력해야 합니다. 매니저가 이를 미리 발견했고 직원이 차이를 알고 있다면, 프로모션 케이스가 이루어지지 않는다면 놀라울 일이 없을 것입니다.\n\n지표는 업무 성과의 대리품이지만 그 자체로는 아니기 때문에 조작될 수 있습니다. 매니저로서, 자신의 직원을 홍보하고 다른 직원을 방해하는 것이 아닌, 종종 칭찬받는 좋은 매니저의 질로 자신의 직원에 대해 종합적이고 진실한 데이터를 제시하는 것이 더 유익합니다. 또한 다른 매니저들이 정직하게 유지할 수 있도록 하는 것이 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n후보의 코딩 생산성이 비정상적으로 높은가요? 구성 변경이 이에 포함되나요? 설계 문서의 저자로 명시된 후보가 실제 참여한 내용이 다른 공동 저자보다 적은가요? 관리자는 플랫폼 팀 대비 제품 팀의 코딩 생산성을 구분하나요? 현재 수준에서 뛰어나지 않은 상태에서 \"짧은 장면\"을 보이나요?\n\n마지막 고백: 대부분의 경우 지금 시대의 대형 기술 기업에서 수석급으로 승진하려면 어려운 과제이며, 대개 대형 기술 기업 외부의 레벨 +1에서 새로운 직장을 구하는 것보다 더 어려울 수 있다고 말하자면, 참여가 쉽지 않습니다. 내 관찰에 따르면, 가장 견고한 5시간 인터뷰 루프 조차도 흔히 판정위원회보다 더 부담을 받으며 여러 가지 눈가림이 존재합니다. 희망하는 후보에게는 단순히 새로운 직장을 찾는 것이 유리할 수 있습니다(충분한 시도만 하면).\n","ogImage":{"url":"/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png"},"coverImage":"/assets/img/2024-05-23-ConfessionofanEngineeringManageronPromotions_0.png","tag":["Tech"],"readingTime":6},{"title":"꿈같은 원격 인턴십을 얻은 방법","description":"","date":"2024-05-23 13:32","slug":"2024-05-23-HowILandedaDreamRemoteInternship","content":"\n여러 인턴십과 소프트웨어 개발 분야의 다양한 경험을 쌓은 뒤, 원격 인턴십을 위한 엄격한 채용 프로세스를 거친 내 최근 여정을 기쁘게 공유하려고 합니다. 이 모든 과정이 어떻게 진행되었는지 살펴보겠습니다.\n\n# 제 소개\n\n# 경험\n\n- SDE 인턴, NewGen Software\n- 풀스택 개발자 @Infiniti Solutions\n- 프론트엔드 엔지니어 @Spotline, USA (원격 근무)\n- UI/UX 디자이너, Fiverr\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기술 스택\n\n- 언어: C++, JavaScript, Java\n- 백엔드 개발: Express.js, Node.js, Backend TypeScript\n- 프론트엔드 개발: HTML, CSS, React.js, TypeScript, Next.js, Tailwind\n- 데이터베이스: Firebase, MySQL, MongoDB, Prisma, Postgres\n- 버전 관리: Git, GitHub, Docker\n\n# 기회의 출처\n\n나는 직접 연락을 받아온 맴버로부터 Twitter DM을 통해 이 기회를 발견했어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 면접 프로세스\n\n## 1차 심층 면접\n\n첫 번째 라운드는 역할과 관련 기술 스택에 대해 논의하는 간단한 30 ~ 40분간의 심층 면접이었습니다. 이 역할은 Next.js, TypeScript 및 Postgres와 AWS에 중점을 둔 풀-스택 SWE 인턴십을 위한 것이었습니다. 저는 이전 경험 및 인턴십을 자세히 설명하며 특히 Next.js 프로젝트에서의 업무를 강조했습니다.\n\n## 코딩 라운드 1\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계는 빠른 속도의 라이브 코딩 라운드였어요. 프론트엔드에 전자 메일 콘텐츠와 여러 이메일 주소를 입력할 수 있는 두 개의 입력 상자를 만드는 것이 제 몫이었어요. 시스템은 이메일 목록을 표시하고 이메일을 삭제하고 메일링 익스텐션을 통합해야 했어요. 저는 더미 이메일을 보내기 위해 Node-mailer와 Mailtrap을 선택했어요. 압박 속에서도 이러한 기능들을 성공적으로 구현했어요.\n\n![이미지](/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png)\n\n# 코딩 라운드 2/시스템 디자인\n\n이 라운드는 시스템 디자인과 코딩을 결합하여 거의 2시간 동안 진행되었어요. 저에게는 Excalidraw를 사용하여 레스토랑을 위한 팁 시스템을 디자인하라는 임무가 주어졌어요. 이 작업에는 화면 계획, 업로드 서비스 또는 AWS를 사용한 이미지 저장, 그리고 빠른 로딩 시간을 보장하는 것이 포함되었어요. 시스템 디자인을 완료한 후에는 빠르게 이 시스템의 초기 프론트엔드 화면을 코딩했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 이전 라운드에서 소개했던 메일링 시스템을 새롭게 업데이트하여 Prisma DB 통합을 추가하여 사용자를 추가하고 삭제하는 기능과 이메일에 구독 해지 버튼이 추가되었습니다. 이 시연은 내 작업 능력을 강력하게 증명하는 계기가 되었습니다.\n\n# 문화적 적합성\n\n최종 라운드는 인사팀 및 팀 문화 적합성 인터뷰로, 내 사고 방식과 팀에 얼마나 잘 적응할 수 있는지에 중점을 두었습니다.\n\n# 결과\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일주일 후에, 인턴십에 선발되었다는 이메일을 받게 되었어요! 이 경험 전체가 믿을 수 없을 정도로 보람찼고, 이 새로운 여정을 시작할 수 있어 너무 흥분되고 있어요.\n\n![이미지](/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_1.png)\n\n# 회고와 조언\n\n과거의 기술 능력, 준비, 그리고 강력한 이전 작업의 시연이 성공에 중요한 역할을 했던 것으로 돌아봤을 때, 비슷한 기회에 대비하는 분들에게 다음을 추천해요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기술 스킬: 자신의 기술 스킬을 끊임없이 향상시키세요. 특히 해당 역할과 관련된 기술에 집중해보세요.\n- 준비: 정기적으로 코딩 및 시스템 설계 문제를 연습해보세요.\n- 프레젠테이션: 이전 작업물을 선보일 준비를 하고, 여러분의 사고 과정을 명확하게 설명할 수 있도록 준비하세요.\n- 문화적합성: 회사의 문화를 이해하고, 면접 중에 어떻게 그것과 일치하는지를 보여주세요.\n\n입사 시즌은 스트레스를 유발할 수 있지만, 끈기와 지속적인 개선이 중요합니다. 때로는 기회가 예상치 못한 때에 찾아올 수 있고, 모든 경험은 여러분의 여정에 가치를 더할 것입니다. 앞으로 나아가며, 성공은 따를 것입니다.\n\n이 상세한 설명이 비슷한 채용 과정을 거치는 분들에게 유용한 통찰을 제공했으면 좋겠습니다. 궁금한 점이 있거나 추가적인 조언이 필요하시면 얼마든지 연락해주세요. 여러분의 여정에 행운을 빕니다!\n","ogImage":{"url":"/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png"},"coverImage":"/assets/img/2024-05-23-HowILandedaDreamRemoteInternship_0.png","tag":["Tech"],"readingTime":4},{"title":"50가지 코딩 법칙이 적절한 프로그래머가 되도록 만들어줄 거예요","description":"","date":"2024-05-23 13:27","slug":"2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer","content":"\n## 이 법칙을 따르지 않으면 해고당할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png)\n\n수백 또는 아마 수천 가지의 파이썬 최고의 관행들이 있습니다. 누구에게 물어도 다소 다른 실천 방법을 얻을 수 있습니다.\n\n인터넷은 모든 사람에게 의견 표명의 권리를 부여했습니다. 심지어 저도 말이죠. 하지만 이 기사에서는 암호화된 50가지 파이썬 최고의 관행을 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n신이라도 조작할 수 없는 기술들이 있어요. 이러한 기술들은 전문가와 아마추어를 구분하며 다양한 프로그래밍 언어에도 적용할 수 있어요.\n\n대부분의 파이썬 개발자들은 코드를 빠르게 테스트하거나 오류를 디버그할 곳이 필요해요. 제가 만든 python-fiddle.com 이라는 웹사이트를 이용하면 코드를 빠르게 테스트하고 AI/LLMs를 사용하여 가능한 오류의 해결책을 찾아줄 수 있어요.\n\n만약 웹 스크래퍼를 만들거나 데이터를 분석하거나 암호화폐 관련 프로젝트를 개발하거나 기계 학습 모델을 만들거나 Django 또는 Flask 웹사이트를 만들거나 작업을 자동화하거나 SQL 관련 프로젝트 등이 필요하다면, 이 사람에게 메시지를 보내보세요.\n\n## 법칙 1: 가능한 한 주석을 피하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코멘트는 종종 사실과는 다른 내용을 전달할 수 있는 방식을 갖고 있어요. 코드가 실제로 무엇을 하는지가 아닌 다른 사람이 말하는대로 어떤 일을 하고 있는지를 읽는 사람의 마음을 벗어낼 수 있어요.\n\n시간이 흐르고 코드가 업데이트되거나 변경될 때 이 문제가 매우 심각해질 수 있어요. 어느 순간, 코멘트가 거짓이 되고 이제 모든 사람들은 거짓을 통해 진실을 관찰해야 할 수도 있어요.\n\n모든 비용을 피해야 하는 것이 코멘트에 대한 태도예요. 코멘트는 독자가 당신의 과거적인 생각을 상속받도록 강요해요. 함수나 클래스가 변경되면 대부분 코멘트는 함께 변경되지 않을 가능성이 높아요. 대부분, 코멘트는 독자가 앞으로 생각하도록 막을 수 있어요.\n\n코멘트는 작성자가 명확한 클래스, 함수 또는 변수 이름을 제시하지 못했다는 것을 나타냅니다. 이는 프로그래머의 태도의 부족을 드러내고 팀에 그러한 태도를 상속받도록 강요해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주석을 가능한 한 피해야 합니다.\n\n로우 14와 15에서는 언제 주석을 사용해야 하고 언제 사용하면 안 되는지 알 수 있습니다.\n\n## 로우 2: 변수에 타입 속성을 이름으로 사용하지 마세요\n\n가끔 특정 변수가 문자열인지 정수형인지를 명시하고 싶을 때가 있습니다. 따라서 일부 개발자는 변수를 다음과 같이 지정할 수 있습니다: name_of_variable_str 또는 name_of_variable_int.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n변수가 문자열인 것이 직관적으로 이해되는 경우와 같이, 변수가 결코 int(정수) 타입이 될 수 없는 경우에는 이것이 상당히 중복될 수 있습니다.\n\n그러나 변수 타입이 직관적이지 않은 경우에는 변수명을 지정할 때 타입을 명시하는 대신 타입 어노테이션을 사용하는 것이 가장 좋은 방법입니다.\n\nname_of_variable:str = value 대신 name_of_variable_str = value를 사용하는 대신 이 방법을 사용하면 모두가 변수가 문자열인 것을 알 수 있으며 코드를 깔끔하고 간결하게 유지할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법률 3: 클래스 이름은 명사여야 합니다.\n\n클래스 이름을 명사로 유지하는 것이 항상 최선의 실천 방법입니다.\n\n이는 대부분 클래스 객체가 특징과 동작을 식별하거나 표현하는 데 사용되기 때문입니다. 어떻게 양이 어떤 특징(뿔)과 행동(주변 사람에게 고개를 끄덕이다)을 나타내듯이요.\n\n이는 코드를 매우 가독성 있고 중복되지 않게 만듭니다. 예를 들어, Goat.get_horn_length() 대신 GetGoat.get_horn_length()을 사용하는 대신 Goat.get_horn_length()을 사용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법칙 4: 함수 이름은 동사여야 합니다\n\n함수는 인접한 개발자가 수행하는 작업을 명확하게 이해할 수 있도록 동사로 가장 잘 명명되어야 합니다.\n\n이는 주석이 필요 없어지게 하고 어떤 개발자든 원시 코드를 확인하지 않고도 정신적으로 개념화할 수 있도록 해줍니다.\n\n## 법칙 5: 함수는 매개변수와 반환 형식을 명시해야 합니다\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수를 정의할 때는 항상 인수의 유형 및 함수의 결과가 반환하는 데이터 유형을 명시해야 합니다.\n\n이렇게 하면 당신과 팀의 개발자들 모두 print 문을 계속 사용하지 않고도 예상되는 결과를 알 수 있게 됩니다.\n\n![이미지1](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_1.png)\n\n![이미지2](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법칙 6: 함수는 한 가지 기능만 수행해야 합니다\n\n주니어 개발자들은 종종 이 규칙을 어기기 좋아합니다. 함수가 한 가지 기능만을 수행하는 것은 버그가 어디에 있는지 노출시키고 재사용성을 높이며, 함수 이름이 하는 일을 정확히 수행하도록 해줍니다.\n\n다음과 같은 일을 하고 싶지 않을 것입니다...\n\n![Img](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주소가 유효한지 확인하고 확인 후 위도와 경도를 반환합니다. 이 함수는 두 가지 작업을 수행합니다. 주소가 유효한지 확인하고 해당 주소의 지리적 위치를 반환합니다.\n\n다음은 더 나은 방법입니다.\n\n![Better Way](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_4.png)\n\n위의 함수들은 하나의 일만을 하고 그 이상의 일을 하지 않습니다. 덜 간결해 보일 수 있지만 훨씬 간결하고 가독성이 높습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수의 \"하나\" 기능을 정확히 알아내는 것은 새로운 개발자들에게는 약간 어려울 수 있어요. 함수가 무엇을 수행해야 하는지를 매우 구체적으로 명시해야 해요.\n\n보통은 함수 내에서 일부 작업을 추출하거나 그룹화하여 다른 하나의 함수로 만들 수 있다면, 아마도 함수가 한 가지 이상의 일을 수행하고 있는 것일지도 모르겠어요.\n\n또 다른 방법은 함수가 여러 수준의 추상화를 갖는지 여부를 확인하는 것이에요...\n\n## LAW 7: 함수는 동일한 추상화 수준에 있어야 해요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수가 동일한 추상화 수준에 있을 때 언급하는 것은 함수가 단일하고 명확한 작업을 수행해야 한다는 아이디어를 가리킵니다. 해당 작업은 함수 전체에서 일관된 추상화 수준에 있어야 합니다.\n\n다시 말해, 함수는 특정한 세부 사항이나 복잡성에 집중해야 하며, 모든 함수의 작업은 동일한 수준에서 작동해야 합니다.\n\n![image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_5.png)\n\n이 함수는 낮은 추상화 수준의 명령문을 가지고 있습니다. sum, len 등과 같은 것들이 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_6.png\" />\n\n예를 들어, 이 함수에는 여러 수준의 추상화가 있습니다. get_numbers()는 높은 수준의 추상화, 리스트 내포(list comprehension)는 중간 수준의 추상화이며 sum은 낮은 수준의 추상화입니다.\n\n## 제8의 법칙: 함수와 인수는 형제 자매처럼\n\n함수 이름은 매우 밀접하게 그 인수와 관련되어야 합니다. 함수 이름과 관련성이 없는 인수를 전달하는 것은 좋은 방법이 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 코드를 Markdown 형식으로 변경해보세요.\n\nwrite(True)\n\nwrite(name)\n\n두 번째 예시가 함수가 정확히 무엇을 하는지 더 잘 설명하고 있어요. 이것을 읽는 사람에게 이름을 작성하고 있다는 사실이 명확해요.\n\n첫 번째 예시는 두 번째 예시만큼 명시적이지 않아요. 추측을 하거나 함수 전체를 살펴봐야 할 수도 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법칙 9: 함수는 작아야 합니다\n\n함수는 재사용 가능하도록 설계되었습니다. 그리고 함수가 커질수록 재사용 가능성이 낮아집니다. 이는 함수가 한 가지 일만 해야 하는 이유와 관련이 있습니다. 한 가지 일만 하면 함수가 작을 가능성이 높습니다.\n\n## 법칙 10: 불필요한 단어 및 중복 단어 피하기\n\n개발자가 변수나 함수의 의미를 더 명확하게 해주는 단어가 아닌 단어를 사용하는 시간도 있습니다. 이런 목록화:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_7.png)\n\n함수의 구현에 대한 사전 지식이 없으면 이를 본 개발자는 어떤 함수를 사용해야 하는지 알 수 없습니다.\n\n## LAW 11: 더러운 프로그래머가 되지 말라\n\n시니어 개발자라면 그가 코드가 깨끗할 때에만 정신적으로 맑다고 말할 것입니다. 이것은 더러운 코드를 작성하는 것이 더러운 프로그래머를 만들기 때문입니다. 깨끗한 코드는 팀의 모든 이들에게 깨끗한 코드를 계속 작성하도록 장려합니다. 항상 깨끗한 코드를 작성하도록 노력해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 깨끗한 코드란 무엇일까요? 깨끗한 코드는 잘 구조화되어 정리되어 있습니다.\n\n깨끗한 코드는 버그를 숨기지 않습니다. 프로그래머가 버그가 숨을 수 있는 어떤 곳이든 드러내며, 완전한 리팩토링 없이 쉽게 수정할 수 있는 공간을 마련해줍니다.\n\n## LAW 12: 개방폐쇄 원칙\n\n개방폐쇄 원칙(Open Closed Principles, OCP)은 클래스, 메서드 또는 함수가 확장을 위해 열려 있지만 수정에는 닫혀 있어야 한다고 말합니다. 이는 정의된 모든 클래스, 메서드 또는 함수가 코드를 변경하지 않고 여러 인스턴스에 재사용하거나 확장할 수 있도록 만든다는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 예제를 들어보겠습니다. address라는 클래스가 있다고 가정해 봅시다.\n\n![address class](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_8.png)\n\n이것은 OCP를 준수하지 못한 것입니다. 새로운 국가가 추가될 때마다, 해당 국가를 보충하기 위해 새로운 if 문을 작성해야 합니다. 지금은 간단해 보일 수 있지만, 상상해 보세요. 100개 이상의 국가를 고려해야 한다면 어떻게 될까요?\n\n여기서 OCP가 중요한 역할을 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_9.png)\n\n이제 클래스나 함수를 수정할 필요가 없어서 보다 견고한 해결책입니다. 어떤 나라와 그 나라의 수도를考え하고 싶을 때 capital 사전만 조정하면 됩니다.\n\n또 다른 흔한 예는 클래스 상속을 사용하는 것입니다.\n\n예를들어:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 다른 지불 방법을 추가할 때마다 항상 PaymentProcessor 클래스를 수정해야한다는 것이 잘못된 방법입니다.\n\n더 나은 방법은 다음과 같습니다:\n\n![이미지](/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이렇게 하면 새로운 결제 옵션을 추가해야 할 때마다, 예를 들어 암호화폐나 페이팔 같은 것, 이를 달성하기 위해 어떤 클래스도 수정할 필요가 없습니다. 단순히 다음과 같이 하면 됩니다:\n\n<img src=\"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_12.png\" />\n\n## 법칙 13: 리스코프 치환 원칙\n\n이 전 원칙을 살펴보면, 암호화폐를 사용하여 결제할 때 우리는 정확히 어떤 암호화폐를 보내는지 명시적으로 지정하지 않습니다. 금액만 명시합니다. 그래서 만약 우리가 암호화폐를 명시하고 싶어한다면, 일반적으로 다음과 같이 할 것입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\nfrom abc import abstractmethod\n\nclass PaymentProcessor:\n\n   @abstractmethod\n   def pay_tax(amount, crypto):\n      pass\n```\n\n그런 다음 각 결제 프로세서를 호출할 때 crypto 인수를 None 타입으로 선언하거나 필요하지 않은 경우 인수를 전달하지 않도록 기본값을 지정합니다. 이 두 경우 모두 Liskov Substitution Principle을 준수하지 못합니다.\n\n이는 부모 클래스 또는 추상 클래스가 대부분의 하위 클래스에게 관련이 없는 인수를 포함하고 있기 때문입니다.\n\n리스코프 치환 원칙(LSP)은 \"슈퍼클래스의 객체는 하위 클래스의 객체로 교체해도 프로그램의 정확성에 영향을 미치지 않아야 한다\"는 것을 명시합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nLSP를 준수하기 위해 CryptoPaymentProcessor 클래스 내에서 암호화폐를 정의해야합니다. 이렇게 하면 다른 하위 클래스와의 불필요한 충돌을 방지할 수 있습니다.\n\n```js\nclass CryptoPaymentProcessor(PaymentProcessor):\n   def __init__(self, crypto):\n      self.crypto = crypto\n\n   def pay_tax(amount):\n      print(f'당신의 {self.crypto} 지갑으로 세금 지불이 진행됩니다')\n      print(f'{amount}을(를) 청구할 예정입니다.')\n```\n\n## LAW 14: 언제 코멘트를 사용해야 할지 알기\n\n코멘트를 사용해야 할 때마다 코드로 표현하지 못한 것에 대해 부끄러워해야 합니다. 그러나 댓글을 사용하면 실제로 코드 자체보다 코드의 기본 작업을 잘 설명하는 데 도움이 되는 경우도 있습니다. 여기 \"좋음\" 코멘트의 5가지 좋은 예제가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친절한 메모\n코드를 읽는 사람에게 코드를 더 잘 전달하는 데 도움이 되는 정보가 있는 메모를 작성하는 것은 언제나 좋습니다. 예를 들어 함수의 반환 값을 강조하는 메모는 더 많은 명확성을 제공할 수 있습니다. 그러나 이러한 메모는 명확한 함수 또는 변수 이름을 사용하여 불필요하게 만들 수 있습니다.\n\n할 일 메모\n이러한 메모는 다른 프로그래머들이 이 함수/작업이 아직 미완성이거나 수정이 필요하다는 것을 알 수 있도록 도와줍니다. 특정 함수를 구현하는 더 나은 방법이 있을 수도 있습니다. 때로는 코드가 주기적으로 실패할 수 있습니다.\n\n당신의 이유에 상관없이, 이러한 메모는 가져가는 것보다 더 많은 가치를 제공합니다. 할 일 메모는 일반적으로 과업이 완료되었거나 제대로 수정된 후에 제거되어야 한다는 것을 기억하기 때문에 코드가 변경되거나 개선될 때 거의 손대지 않는 경향이 있습니다.\n\n후행 작용 경고\n가끔은 다른 개발자들에게 잠재적인 위험을 알리고 싶을 때가 있습니다. 이 위험에 발을 딛게 되면 예기치 못한 결과가 생길 수 있습니다. 우리는 모두 하루를 생존하고 싶어합니다. 이 상황에서 메모가 문제를 해결하는 데 도움이 될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n특정 코드가 시간이 걸리거나 특정 시스템을 과부하시킬 가능성이 있는 경우, 독자나 다른 프로그래머에게 \"#COMPUTING RESOURCES를 많이 소비함\"과 같은 경고가 도움이 될 수 있습니다.\n\n## 법칙 15: 언제 주석이 나쁜가요?\n\n소음 주석\n이러한 주석들은 당연한 것을 다시 강조하는 주석입니다. 추가 정보를 제공하지 않고 코드의 더 많은 길이만 늘립니다. 많은 시간, 우리는 이러한 주석을 건너뛰곤 합니다. 소음 주석의 예시는 다음과 같습니다:\n\n```js\n# 동물 리스트에 추가합니다\nanimal.append(dog)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n비 로컬 정보\n프로그래머들이 주석을 사용할 때 범하는 실수 중 하나는 전역 정보를 로컬에서 제공하는 것입니다. 주석을 작성할 때는 해당 함수나 문을 참조하는 것에만 관련되도록 유지하십시오. 그 외의 부분은 제거해야 합니다.\n\n명확하지 않은 주석\n우리가 알기에는 분명한 주석을 작성하기 쉽습니다만 다른 사람에게는 명확하지 않을 수 있습니다. 주석과 함수 간의 연결은 명확해야 합니다. 둘 다 동일한 단계나 절차를 따라야 합니다. 주석이 또 다른 주석을 필요로 하지 않도록 해야 합니다.\n\n짧은 함수\n짧은 함수에 대해 주석이 필요하지 않을 가능성이 높습니다. 함수가 짧을수록 좋은 이름으로 설명할 수 있는 가능성이 높습니다. 따라서 이러한 함수는 보통 자기 설명적입니다.\n\n## 법칙 16: 소스 파일을 짧게 유지하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n소스 파일은 최대 500줄이지만 100–200줄 사이로 유지하는 것이 좋습니다. 매우 좋은 이유가 없는 한 다른 방법을 선택하는 것을 권장하지 않습니다. 소스 파일을 짧게 유지하면 재사용성과 가독성과 같은 다양한 명백한 이점이 있습니다. 또한 연결할 내용을 찾느라 스크롤하고 시간을 낭비하는 일이 줄어들기 때문에 유지 및 업데이트하기가 더 쉽습니다.\n\n## 법칙 17: 빈 줄 사용 시점을 알아두세요\n\n빈 줄은 새로운 개념과 분리된 부분으로 진행하고 있다는 것을 독자에게 알려주는 방법입니다. 각 줄 그룹은 완전한 생각을 나타냅니다. 이는 독자가 생각이 끝났는지를 이해하는 데 도움이 됩니다.\n\n## 법칙 18: 관련된 코드/함수/클래스를 가까이 유지하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테이블 태그를 마크다운 형식으로 변경해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 가지가 강하게 관련이 없음을 나타내기 위해 공백을 사용하고, 강하게 연관된 것들은 공백을 사용하지 않습니다. 예를 들어 함수를 정의할 때...\n\n```js\ndef create(name):\n    print(name)\n```\n\n함수와 이름 변수 사이에 공백이 없습니다. 만약 공백이 있다면, 매우 조화롭지 않고 조직되지 않은 모습이 될 것입니다...\n\n```js\ndef create (name):\n    print (name)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수에 전달되는 인수는 구별되어야 합니다.\n\n## 법칙 20: 팀 규칙 준수\n\n거의 모든 개발자는 자신만의 스타일을 갖고 있습니다. 파일 이름 짓는 방식부터 print 문 작성 방식까지.\n\n하지만 다른 개발자들과 협업할 때는 개인적인 취향을 내려놓고 팀의 선호도를 받아들이는 것이 좋습니다. 다른 사람들이 당신의 코드에서 아름다움을 느끼지 못할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## LAW 21: 마법 숫자 피하기\n\n마법 숫자란 나중에 변경될 수 있는 하드 코딩된 값으로, 그래서 업데이트하기 어려울 수 있습니다.\n\n예를 들어, \"나의 주문\" 개요 페이지에서 마지막 50개 주문을 보여주는 페이지가 있다고 가정해봅시다. 여기서 50은 마법 숫자입니다. 왜냐하면 표준이나 규약으로 설정되지 않았으며, 명세서에 기술된 이유로 임의로 정한 숫자입니다.\n\n이제 50을 서로 다른 곳에 넣으시는 것입니다 — SQL 스크립트 (SELECT TOP 50 \\* FROM orders), 웹사이트 (마지막 50개 주문), 주문 로그인 (for (i = 0; i ` 50; i++)) 그리고 가능한 다른 많은 장소에.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 나쁨\n\nSELECT TOP 50 \\* FROM orders\n\n# 좋음\n\nNUM_OF_ORDERS = 50\nSELECT TOP NUM_OF_ORDERS \\* FROM orders\n\n## LAW 22: 깊은 중첩 피하기\n\n루프, 조건문 또는 함수 내의 중첩 수준을 제한하여 가독성을 향상시킵니다.\n\n# 나쁨\n\nif x:\nif y:\ndo_something()\n\n# 좋음\n\nif x and y:\ndo_something()\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## LAW 23: 임시 변수 피하기\n\n```js\n# 나쁜 예\ntemp_result = calculate(x, y)\nfinal_result = temp_result * 2\n\n# 좋은 예\nfinal_result = calculate(x, y) * 2\n```\n\n## LAW 24: 암호적 줄임말 피하기\n\n가독성을 높이기 위해 암호적 줄임말 대신 설명적인 이름을 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 나쁜 예시\n\ndef calc(x, y):\npass\n\n# 좋은 예시\n\ndef calculate_total_price(quantity, unit_price):\npass\n\n## 법칙 25: 경로 하드코딩 피하기\n\n파일 경로나 URL을 하드코딩하지 말고, 대신 구성 파일 또는 환경 변수를 사용해주세요.\n\n# 나쁜 예시\n\nfile_path = \"/path/to/file.txt\"\n\n# 좋은 예시\n\nimport os\nfile_path = os.getenv(\"FILE_PATH\")\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## LAW 26: 항상 Try-Catch-Finally 문 사용하기\n\n코드를 작성할 때, 오류 처리를 반드시 포함하는 것이 가장 좋습니다. 이렇게 하면 디버깅 프로세스를 가속화하고 코드의 정교성을 높일 수 있을 뿐만 아니라 코드를 깔끔하고 관리하기 쉽게 유지할 수도 있습니다.\n\n특정 코드에서 오류가 발생할 가능성이 높은 경우 try-catch 문을 사용하고 싶어할 것입니다.\n\nAPI 요청, 파일 처리 등의 작업은 어떤 이유로든 실패하거나 오류를 일으킬 가능성이 높습니다. 반면에 곱셈이나 나눗셈과 같은 작업에 대해 try-catch 문을 사용하는 것은 오히려 문제를 더 만들어내기 때문에 지양해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법칙 27: 예외와 함께 컨텍스트 제공하기\n\n예외가 발생했을 때는 해당 예외가 발생한 위치와 디버깅할 수 있도록 충분한 컨텍스트를 제공해야 합니다.\n\n예외와 함께 유용한 오류 메시지를 생성해야 합니다. 오류를 출력할 때 해당 작업이 실패한 컨텍스트와 실패 유형을 명시해야 합니다.\n\n## 법칙 28: 여러 예외 클래스 사용 피하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같은 코드를 본 적이 있나요?\n\n```js\ntry:\n    pass\nexcept ValueError:\n    pass\nexcept TypeError:\n    pass\nexcept IndexError:\n    pass\nexcept KeyError:\n    pass\nexcept FileNotFoundError:\n    pass\n```\n\n이 코드는 매우 부적절하며, 오류 처리에 추가 도움을 제공하는 대신 가독성, 복잡성 및 유지보수 측면에서 문제를 일으킵니다.\n\n우리가 마주칠 수 있는 모든 종류의 오류를 처리하기 위해 보다 일반적인 예외를 사용하는 것이 종종 더 나은 방법입니다. 기본적으로 이 유형의 예외는 우리가 받은 오류의 유형을 포함합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ntry:\n pass\nexcept Exception:\n pass\n```\n\n특정 유형의 오류를 잡고 싶을 때 다른 모든 오류가 통과될 수 있도록 해주세요.\n\n## 법칙 29: 함수는 변이하거나 값을 반환해야 하나 둘 다 하면 안 된다.\n\n함수를 작성할 때 해당 함수가 정확히 무엇을 해야 하는지 유의해야 합니다. 인수를 변이시킬까요? 아니면 반환해야 하나요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 함수가 전달된 인수를 변형시키면, 그 함수 안에서만 그 작업을 하면 됩니다. 그 이외의 곳에서는 건드릴 필요가 없어요.\n\n하지만 여기서 변형이 무엇을 의미하는 걸까요? 함수가 인수의 내용을 변경하거나 인수의 데이터 유형을 변경하는 경우 변형됩니다.\n\n```js\ndef changed(array):\n    array.append('hello')\n```\n\n만약 인수가 다른 변수를 만들기 위해 사용된다면 그것은 변형이 아닙니다. 예를 들어, 시간이라는 인수가 거리를 계산하는 데 사용된다면, 그것은 변형이 아니기 때문에 거리는 그 함수에서 반환될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ndef calculate_distance(time, speed):\n    distance = speed * time\n    return distance\n```\n\n하지만 두 마리 토끼를 모두 잡는 방법이 있어요. 함수의 인수를 복사하고 그에 대한 변이(mutation)를 수행할 수 있어요. 이렇게 하면 부작용을 피할 수 있어요.\n\n```js\ndef changed(array):\n    array_copy = array[:]\n    array_copy.append(4)\n    return array_copy\n```\n\n## 법칙 30: 모든 함수 이름이 동사일 필요는 없어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네, 알겠어요. 이전에 제가 언급했던 것처럼 모든 함수명은 일반적으로 동사여야 한다고 했었는데, 때로는 함수명이 명사 형태여야 하는 경우가 있습니다. 이것이 언제 그런지 아는 것은 이전 법칙/법칙 29에 근거합니다.\n\n인수를 변형하지 않고 무언가를 반환하는 함수라면, 함수명은 명사여야 합니다. 반면에 인수를 변형하고 반환하지 않는 함수는 동사여야 합니다.\n\n이것은 파이썬 자체에 내장된 일반적인 관례입니다. sort나 append와 같은 메서드는 데이터 유형을 변형하고 None을 반환하기 때문에 동사입니다. 반면에 sorted, sum, product와 같은 메서드들은 전달된 인수를 변형하지 않고 데이터의 새 복사본을 반환하기 때문에 모두 명사입니다.\n\n물론 이에는 예외가 있고, 한 번 예외 상황을 마주했을 때는 언제든지 동사를 사용하도록 되돌아가도 괜찮습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법칙 31: 클래스는 작아야 합니다\n\n그렇습니다! 클래스는 가능한 작아야 합니다. 함수와 마찬가지로요.\n\n함수에서는 크기가 함수 내의 줄 수에 의해 결정되지만 클래스에서는 책임의 수에 따라 결정됩니다.\n\n일반적으로 클래스 이름은 해당 클래스가 가질 수 있는 책임의 종류를 나타냅니다. 그러나 이름이 모호하거나 너무 일반적인 경우, 대부분 너무 많은 책임을 부여하고 있는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 클래스가 하나의 이유, 즉 변경할 책임이 하나만 있어야 한다는 SRP(단일 책임 원칙)로 되돌아가게 됩니다.\n\n## LAW 32: 클래스는 인스턴스 변수의 개수를 적게 가져야 합니다.\n\n인스턴스 변수는 클래스가 정의되거나 인스턴스화될 때 정의된 변수입니다.\n\n```js\nclass Animal:\n    def __init__(self, name):\n        self.name = name #인스턴스 변수\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 모든 우리의 함수가 클래스 책임과 관련이 있다면, 많은 인스턴스 변수를 가질 이유가 없어요.\n\n수많은 인스턴스 변수가 생기기 시작하는 건, 클래스의 핵심 역할에서 벗어난 함수 때문입니다.\n\n이러한 함수들은 다른 함수가 필요하지 않은 자체 변수를 가지게 됩니다.\n\n## 법칙 33: 당신의 클래스는 응집력이 있어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클래스 내의 모든 함수는 하나 이상의 인스턴스 변수를 포함해야 합니다. 함수가 클래스 내의 인스턴스 변수와 관련이 많거나 해당 변수를 포함하면 클래스의 응집력이 더 높아집니다.\n\n## 법칙 34: 자원 관리를 위해 with 문 사용하기\n\n파일이나 데이터베이스 연결과 같은 자원을 자동으로 관리하려면 with 문을 사용하여 해당 자원이 제대로 닫히거나 해제되도록 합니다.\n\n```js\n# 나쁜 예\nfile = open(\"example.txt\", \"r\")\ndata = file.read()\nfile.close()\n\n# 좋은 예\nwith open(\"example.txt\", \"r\") as file:\n    data = file.read()\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법칙 35: 복잡한 삼항 표현식 피하기\n\n과도하게 복잡한 삼항 표현식 사용을 삼가하고, 코드를 더 잘 이해할 수 있도록 간결함보다 가독성을 선호하세요.\n\n```js\n# 나쁨\nresult = \"even\" if number % 2 == 0 else \"odd\" if number % 3 == 0 else \"neither\"\n\n# 좋음\nif number % 2 == 0:\n    result = \"even\"\nelif number % 3 == 0:\n    result = \"odd\"\nelse:\n    result = \"neither\"\n```\n\n## 법칙 36: 정체성 비교에 ‘is’와 ‘is not’ 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대부분의 경우, 우리는 두 변수 사이의 비교를 확인하기 위해 ==를 사용합니다. 불변 데이터 유형인 문자열이나 정수와 같은 경우에는 보통 두 변수가 동일한 메모리 위치에 저장되기 때문에 메모리 위치 확인은 필요하지 않습니다.\n\n그러나 list, dict 및 사용자 정의 객체와 같은 가변 데이터 유형과 작업할 때는 종종 변수의 서브 유형과 메모리 위치를 확인하는 is 비교 연산자를 사용하는 것이 더 좋습니다.\n\n가변 객체의 메모리 위치는 Python의 작동 방식 때문에 보통 같지 않습니다. Python은 가변 객체를 서로 다른 메모리 위치에 저장합니다. 이것은 언제든지 변경될 수 있으며 각 객체가 다른 객체와 독립적이어야 하기 때문입니다.\n\n문자열, 튜플 및 정수는 생성된 후에 변경할 수 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n아래 링크를 사용하여 이 코드를 실행해보세요:\nhttps://python-fiddle.com/saved/nV6iEIyBuHm2mevD9Bhg\n\n# 예시 2: 두 리스트가 동일한 객체를 참조하는지 확인\nlist1 = [1, 2, 3]\nlist2 = [1, 2, 3]\n\n# 선호되지 않는 방법: == 사용\nif list1 == list2:\n    print(\"리스트는 동일한 값을 가집니다\")\n\n# 선호되는 방법: is 사용\nif list1 is list2:\n    print(\"리스트는 동일한 객체를 참조합니다\")\n\n# 참고: 이 경우에, list1과 list2는 동일한 값을 가진 다른 객체이므로,\n# `is`를 사용하면 `==`와 다른 결과가 나옵니다.\n```\n\n## LAW 37: 의존 역전 원칙\n\n의존 역전 원칙(Dependency Inversion Principle, DIP)은 객체 지향 설계의 중요한 원칙으로, 컴포넌트 간의 느슨한 결합을 촉진하고 소프트웨어 시스템의 보다 쉬운 유지보수와 확장을 돕습니다.\n\n고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시 말해서, 클래스는 구체적인 구현이 아닌 인터페이스 또는 추상 클래스에 의존해야 합니다.\n\n```js\n# 나쁜 예\nclass Logger:\n    def log(self, message):\n        with open('log.txt', 'a') as f:\n            f.write(message + '\\n')\n\nclass Calculator:\n    def __init__(self):\n        self.logger = Logger()\n\n    def add(self, x, y):\n        result = x + y\n        self.logger.log(f\"{x}와 {y}를 더했습니다. 결과 = {result}\")\n        return result\n```\n\n위 예시에서 Logger 클래스를 정의하고 Calculator 클래스에서 직접 인스턴스를 생성합니다. 이로 인해 Calculator는 이제 Logger 클래스에 의존하며, Logger 클래스를 변경하면 Calculator 클래스도 수정해야 합니다.\n\n또한 이는 개방-폐쇄 원칙(확장에는 열려 있고 수정에는 닫혀 있음)을 지키지 못하는 것을 보여줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 좋은 코드\nfrom abc import ABC, abstractmethod\n\nclass LoggerInterface(ABC):\n    @abstractmethod\n    def log(self, message):\n        pass\n\nclass Logger(LoggerInterface):\n    def log(self, message):\n      with open('log.txt', 'a') as f:\n          f.write(message + '\\n')\n\nclass Calculator:\n    def __init__(self, logger: LoggerInterface):\n        self.logger = logger\n\n    def add(self, x, y):\n        result = x + y\n        self.logger.log(f\"Added {x} and {y}, result = {result}\")\n        return result\n```\n\n이 기능은 테스트하기가 더 어려울 수 있지만, 가짜 로거 클래스를 사용하여 테스트할 수 없게 만든다는 문제가 있습니다.\n\n이렇게 하면 인터페이스가 일관성을 유지하는 한 한 요소의 변경이 다른 요소에 변경을 요구하지 않기 때문에 모듈화를 촉진합니다.\n\n이 모듈성은 코드베이스를 더 쉽게 이해, 수정 및 확장할 수 있도록 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법칙 38: 데이터 유효성 검사에 'assert' 사용을 피하십시오\n\n'assert' 문은 디버깅 및 개발 목적으로만 사용하고, 제품 코드에서 데이터 유효성 검사에는 사용을 피하십시오.\n\n```js\n# 안 좋은 예\nassert x > 0, \"x는 양수여야 합니다.\"\n\n# 좋은 예\nif x <= 0:\n    raise ValueError(\"x는 양수여야 합니다.\")\n```\n\n## 법칙 39: 하드 코딩된 숫자를 피하십시오\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n명확성을 높이고 코드 수정을 쉽게 만들기 위해 의미 있는 이름으로 상수를 작성하십시오.\n\n```js\nDISCOUNT_RATE = 0.1\n\ndef calculate_discount(price):\n    discount = price * DISCOUNT_RATE\n    return price - discount\n```\n\n위 예제는 10% 할인을 나타내는 하드 코딩된 숫자 0.1을 사용합니다.\n\n이로 인해 숫자의 의미를 이해하기 어렵고 다른 부분에서 필요시 할인율을 조정하는 것이 어려워집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```python\ndef calculate_discount(price):\n    TEN_PERCENT_DISCOUNT = 0.1\n    discount = price * TEN_PERCENT_DISCOUNT\n    return price - discount\n```\n\n개선된 코드는 숫자를 하드코딩하는 대신 TEN_PERCENT_DISCOUNT라는 이름이 지정된 상수로 대체합니다. 이 이름은 값의 의미를 즉시 전달하여 코드를 자체 문서화하는 데 도움이 됩니다.\n\n## LAW 40: DRY (Don’t Repeat Yourself) 원칙을 따르세요\n\n같은 코드를 한 번 이상 작성하지 않도록 합니다. 대신 함수, 클래스, 모듈, 라이브러리 또는 기타 추상화를 사용하여 코드를 재사용하세요. 이렇게 하면 코드가 더 효율적이고 일관되며 유지 보수가 용이해집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 표를 변경하여 마크다운 형식으로 변환해보세요.\n\n```js\n# 나쁜 예\n\ndef calculate_book_price(quantity, price):\n    return quantity * price\ndef calculate_laptop_price(quantity, price):\n    return quantity * price\n\n# 좋은 예\n\ndef calculate_product_price(product_quantity, product_price):\n    return product_quantity * product_price\n```\n\n## LAW 41: 존중할 만한 코딩 기준을 따르세요.\n\n공백, 주석, 그리고 명명에 대한 일반적으로 인정받은 컨벤션을 따르는 것이 중요합니다. 대부분의 프로그래밍 언어에는 커뮤니티에서 인정하는 코딩 표준과 스타일 가이드가 있습니다. 예를 들어, Python의 경우 PEP 8가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일반적으로 사용되는 관례들은 다음과 같습니다:\n\n- 변수, 함수 및 클래스 이름에는 snake_case를 사용합니다.\n- 들여쓰기에는 탭 대신 공백을 사용합니다.\n- 들여쓰기 단계마다 4개의 공백을 사용합니다.\n- 모든 줄을 최대 79자로 제한합니다.\n- 2진 연산자 앞에 줄바꿈을 넣습니다.\n\n## 법칙 42: 데메테르의 법칙\n\n데메테르의 법칙은 간단히 말하면 모듈/함수/클래스는 주변 모듈/함수/클래스에 대한 지식이나 참조를 가질 수 있지만 그 이상의 지식은 가져서는 안 된다는 것을 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인접한 이웃이라 함은 직접 액세스할 수 있는 메소드, 함수 또는 변수를 의미합니다.\n\n예제를 통해 설명해드리겠습니다...\n\n```js\nclass Order:\n    def __init__(self, customer):\n        self.customer = customer\n\n    def get_customer_name(self):\n        # 위반 사항: 주문이 고객의 구조에 대해 너무 많이 알고 있습니다\n        return self.customer.get_profile().get_name()\n```\n\n이 예제에서 Order 클래스는 고객의 프로필에 직접 접근하여 고객의 이름을 검색합니다. Order는 고객 객체의 내부 구조에 액세스하여 프로필 및 이름에 접근하고 있으므로 이는 데메테르 법칙을 위반합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주변 이웃을 넘어서고 이제 고객 개체에 대해 너무 많이 알게 되었습니다.\n\n```js\nclass Order:\n    def __init__(self, customer):\n        self.customer = customer\n\n    def get_customer_name(self):\n        # 준수 사항: 주문은 직접적인 협력자와만 상호 작용합니다\n        return self.customer.get_name()\n```\n\n이 준수 사례에서 Order 클래스는 해당 고객 개체와만 상호 작용하고 고객의 이름을 검색하기 위해 직접적으로 메서드를 호출합니다.\n\n고객 개체의 내부 구조에 접근하지 않으므로 Demeter의 법칙을 따릅니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법칙 43: 간결함보다 가독성이 중요합니다\n\n코드는 기계가 해석할 수 있어야 합니다. 그러나 다른 개발자들도 코드를 이해할 수 있어야 합니다. 특히 여러 명이 참여하는 프로젝트에서 작업할 때는 더욱 중요합니다.\n\n소프트웨어 개발에서 가독성은 항상 코드의 간결성보다 중요합니다.\n\n만약 다른 개발자들이 이해할 수 없는 간결한 코드를 작성한다면, 그것은 별 의미가 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법칙 44: Import를 깨끗하게 유지하세요\n\n필요한 모듈과 심볼만을 가져와서 import 섹션을 깔끔하게 유지하고 가독성을 향상시키세요. 모듈에서 모든 (\\*) 것을 가져올 때, 모든 변수, 함수 및 클래스도 가져오게 되어 특정 함수/클래스가 어디서 온 것인지 알기 어려워지며, 최신 IDE를 사용할 때 번거로울 수 있습니다.\n\n예를 들어, get_file이라는 함수를 작성하고 싶다고 상상해보세요. g를 클릭하면 IDE가 g로 시작하는 함수/클래스/변수 목록을 추천해줍니다. 이렇게 되면 꽤 혼란스러워질 수 있습니다.\n\n이것이 더 큰 문제로 변하는 경우가 있습니다. 함수를 호출하려고 할 때 더욱 문제가 될 수 있습니다. 함수 이름이 추천 목록 사이에 잃어버릴 수 있고, 이제 IDE가 효율적인 해결책보다는 문제로 변할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 나쁜 예\n\nfrom module import \\*\n\n# 좋은 예\n\nfrom module import symbol1, symbol2\n\n## LAW 45: Null/None을 반환하지 마세요\n\n보통 함수를 정의할 때, 기본적으로 반환 값이 지정되지 않은 경우 None이 반환됩니다. 그렇지만 우리가 명시적으로 None을 반환할 때는, 해당 함수가 None 이외의 다른 값을 반환할 수 있다는 것을 간접적으로 읽는 사람에게 알리는 것입니다.\n\n만약 이게 사실이 아니라면, 많은 오해를 불러올 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 법률 46: 건설과 사용 분리하기\n\n관심사의 분리는 소프트웨어 공학에서 매우 기본적인 원칙이 되어왔습니다. 우리는 소프트웨어의 건설 방식을 사용 방식으로부터 분리하는 방법을 알아야 합니다.\n\n이는 종종 시작 과정, 즉 의존성 및 객체들이 결합되는 때와 실행 시간 로직, 즉 응용 프로그램 로직이 사용자 입력이나 다른 트리거로부터 실행되는 경우와 같은 것들을 분리하는 것을 의미합니다.\n\n건설과 사용을 분리하는 일반적인 방법은 main이라는 파일/함수/모듈에서 응용 프로그램 로직을 구성하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주요 기능은 응용 프로그램이 원활하게 실행되도록 필요한 객체를 구축합니다. 이렇게 함으로써 다른 모듈이 응용 프로그램에 강하게 결합되지 않도록하고 재사용성과 모듈성을 증진시킵니다.\n\n## LAW 47: 간단한 디자인에는 모든 이러한 규칙이 포함됩니다\n\n모든 테스트 실행: 시스템은 문서상으로 완벽한 디자인을 가질 수 있지만, 시스템이 의도한 대로 작동하는지 확인할 수 있는 방법이 없다면, 문서상의 디자인은 의문스러워집니다.\n\n중복이 포함되지 않음: 중복은 잘 설계된 시스템의 주요 적인 적수입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로그래머의 의도를 표현합니다\n\n클래스와 메소드의 수를 최소화합니다\n\n## LAW 48: 중첩된 Try-Except 블록 피하기\n\n너무 복잡한 오류 처리 논리를 방지하기 위해 try-except 블록을 과도하게 중첩하는 것을 삼가세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 나쁜 예시\ntry:\n    try:\n        # 오류가 발생할 수 있는 코드\n        pass\n    except ValueError:\n        # ValueError 처리\n        pass\nexcept Exception as e:\n    # 다른 예기치 않은 오류 처리\n    pass\n\n# 좋은 예시\ntry:\n    # 오류가 발생할 수 있는 코드\n    pass\nexcept ValueError:\n    # ValueError 처리\n    pass\nexcept Exception as e:\n    # 다른 예기치 않은 오류 처리\n    pass\n```\n\n## 법칙 49: 필요할 때만 동시성 사용하기\n\n동시성 기능을 구현할 때 나쁜 코드를 작성하기가 매우 쉽습니다.\n\n또한, 매우 결함이 많은 동시성 기능을 구현할 때 깔끔한 코드를 작성하는 것도 매우 쉽습니다. 보통 시스템에 많은 스트레스가 가해질 때까지 잘못되었다는 것을 인식하지 못할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n너는 매우 현명하게 전투를 선택하길 원해.\n\n너의 동시성 코드가 실패할 수 있는 여러 이유들이 있다. 여기 몇 가지 예시가 있다:\n\n굶주림(Starvation): 굶주림은 스레드나 프로세스가 공유 자원에 접근할 수 없어 계속해서 시도해도 영원히 실패하는 경우 발생한다. 이는 다른 스레드나 프로세스가 계속해서 자원을 확보하고 보유하여 굶주는 스레드가 진행하지 못하게 하는 경우에 발생할 수 있다.\n\n교착상태(Deadlocks): 교착상태는 두 개 이상의 스레드나 프로세스가 상호적으로 서로 자원을 해제하기를 무한정 대기하고 있는 경우 발생한다. 이는 각 프로세스가 한 자원을 보유하고 다른 프로세스가 보유한 다른 자원을 기다리며 순환 의존성을 만들어 서로 대기하는 경우에 발생할 수 있다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## LAW 50: 49가지 법칙을 따르세요\n\n이 법칙들은 당신을 소프트웨어 엔지니어로서의 여정에서 안내하기 위해 존재합니다. 필요할 때마다 이를 준수해야 합니다.\n\n그러나 경험과 기술이 쌓일수록, 특정 규칙을 따를 때와 그렇지 않을 때를 판단할 수 있는 능력을 가지고 싶을 것입니다.\n\n이 직관은 자신의 기술을 숙달한 사람들에게만 주어지며, 만약 초보자이거나 2년 전에 경력을 시작한 경우라면, 이 법칙을 하늘로 가는 유일한 티켓으로 여기는 것이 가장 좋습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n대부분의 파이썬 개발자들은 코드를 빠르게 테스트하거나 오류를 디버깅하는 곳이 필요합니다. 저는 python-fiddle.com이라는 웹사이트를 개발했습니다. 여기에서 빠르게 코드를 테스트하고 AI/LLMs를 활용하여 가능한 오류의 해결책을 찾을 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png"},"coverImage":"/assets/img/2024-05-23-50CodingLawsThatWouldMakeYouADecentProgrammer_0.png","tag":["Tech"],"readingTime":40}],"page":"73","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}