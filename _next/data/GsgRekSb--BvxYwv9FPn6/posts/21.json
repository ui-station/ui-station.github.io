{"pageProps":{"posts":[{"title":"Ruby on Rails 7에서 Javascript 및 Bootstrap 에셋 번들링 하는 방법","description":"","date":"2024-06-23 20:50","slug":"2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7","content":"\n최근 몇 달 동안 (2023년 초반) 저는 Ruby on Rails를 통해 프론트엔드 웹 개발을 배우고 있는 중이에요. 그리고 지금까지 정말 멋진 여정이었어요. 그런데 프로젝트에 자산 (자바스크립트 및 CSS 라이브러리)을 넣는 방법에 몇 가지 변화가 있었던데, 이는 초보자에게는 조금 어려울 수 있어요.\n\n이번 시간 동안 많은 검색을 해본 결과, Ruby on Rails 포럼에서 해당 질문에 대한 포스트를 찾았어요. 그리고 여기서 4가지 방법으로 프로젝트에 자산을 로드하는 방법을 설명하겠어요. 또한 내가 발견한 몇 가지 결과물도 이 가이드에서 설명하려고 해요. 이 결과물은 대부분 David Heinemeier Hansson (또는 커뮤니티에서는 DHH로 알려진)의 유튜브 튜토리얼에서 나온 것들이에요. 그는 Ruby on Rails 창시자이기도 하죠.\n\n# 무슨 일이 일어나고 있지?\n\nRuby on Rails는 Ruby로 작성된 프레임워크로, 웹 애플리케이션 개발을 많이 도와줘요 (프론트엔드 및 백엔드 모두, 즉: HTML, Javascript, CSS, 그리고 데이터베이스 및 URI 경로 통합이요). Ruby로 HTML과 Javascript를 작성할 수도 있지만, 서버를 시작하고 브라우저에서 사이트를 볼 때는 HTML만이 기본적으로 렌더링될 뿐이에요. 따라서, 우리는 사용하고 싶은 자바스크립트 및 라이브러리, 그리고 사용자 정의 CSS와 CSS 라이브러리를 프로젝트에 컴파일할 방법이 필요해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부트스트랩(버튼이나 네비게이션 바와 같은 스타일이 적용된 컴포넌트를 제공하는 CSS 라이브러리)을 제 프로젝트에 번들링하려고 노력했는데, 때로는 CSS 라이브러리가 제대로 로드되지 않아 사이트가 90년대 페이지처럼 순수 HTML로 렌더링되고, 대부분의 경우 CSS 라이브러리가 로드되더라도 상호작용(예: 네비게이션 바 축소 메뉴 확장)에 반응하지 않았습니다. 이는 Bootstrap이 작동하기 위해 필요한 JavaScript가 제대로 로드되지 않음을 의미합니다.\n\n또한 대부분의 자습서들이 작동하지 않아서 무엇이 문제인지 정말로 이해하기로 결심했습니다.\n\n마지막으로 이 게시물에서 설명한대로, 이 목표를 달성하는 네 가지 방법을 발견했습니다(2023년 3월 현재, Ruby On Rails 7 기준):\n\n- 이전 방식(7버전 이전) : 스프로켓 및 젬을 통해 부트스트랩을 수동으로 번들링하는 방식;\n- Webpacker 젬 사용: 이 젬은 자바스크립트 Webpack, Node 및 yarn을 랩핑합니다. JavaScript ES6부터는 번역이 더 이상 필요하지 않으며 이 젬은 폐지되었고 shakapacker 젬으로 대체되었습니다. 해당 젬의 GitHub에 따르면 :\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고: HMR은 Hot Module Reloading의 약자로, 코드를 편집할 때 사이트가 자동으로 다시로드됩니다.\n\n- 새로운 방법 #1: Rails 7 Importmaps를 사용하는 방법: 단일 파일 importmap.rb에 가져오기를 정의합니다. 이 파일은 코드를 JS 및 CSS로 변환하고 이 파일들을 번들링합니다.\n- 새로운 방법 #2: Rails 7 JS 번들링 및 CSS 번들링 gems를 사용하는 방법: 이를 새 프로젝트에 선언하거나 기존 프로젝트에 추가하고, esbuild 및 yarn (또는 다른 도구를 선택할 수도 있음)를 사용하여 CSS 파일을 변환하고 번들링합니다.\n\n포럼에서 설명한대로, rails pipeline은 세 가지 작업을 수행합니다: 변환(다른 확장자를 .js 및 .css로 변환), 번들링(모든 파일을 하나의 .js 및 .css 파일로 결합하여 브라우저에서 작동하도록 함), 그리고 파일 다이제스팅(파일을 해싱하고 브라우저 캐시를 가능하게하며 개발중 캐시를 무효화해 코드 변경이 브라우저 캐시에 덮어씌워지지 않도록 합니다). Sprockets는 모든 세 가지를 실행했었기 때문에 옵션 #1이 작동하지만, importmaps 또는 js/css 번들링 gems를 사용하는 경우 첫 2단계만 수행하고 다이제스팅은 sprockets에 남깁니다.\n\n# 튜토리얼\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레일즈 7은 이미 importmaps를 사용할 수 있도록 사전 구성되어 있습니다. 따라서 importmap 및 번들링 젬 방식을 설명하고 있어요. 번들링 젬 방식은 다음 튜토리얼에서 소개될 예정입니다.\n\n# Importmaps 튜토리얼\n\n- 레일즈를 사용하여 새 앱을 시작하세요. [앱이름]으로 rails new [appname];\n\n![이미지](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_1.png\" />\n\n우리가 볼 수 있듯이, Rails 7은 이미 우리를 위해 스프라켓(4)을 설정하고 importmaps(1)를 설치하며, 메인 HTML 파일(2)에서 사용하고, 우리의 import JS 파일을 스프라켓 매니페스트.js에 연결하고(3 및 4), 필요하다면 CDN을 통해 CSS 및 JS 파일을 핀(import)할(importmap) 수 있도록 명령 줄에서 importmap 명령을 활성화합니다.\n\n- 부트스트랩의 경우, 우리는 젬 튜토리얼을 따릅니다: Gemfile에서 부트스트랩 젬을 가져와 sprockets-rails이 사용되는지 확인합니다. 젬은 루비 라이브러리이며, Rails는 rubygems.org에서 이를 로드합니다. 우리의 모든 젬은 Gemfile에 선언됩니다.\n\n<img src=\"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![screenshot1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_3.png)\n\n- Change the application.css extension to .scss and replace the file contents by @import \"bootstrap\"\n\n![screenshot2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_4.png)\n\n- Add bootstrap and popper to importmap (popper is required by bootstrap to show popovers, like the dropdown on our navbar)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image 1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_5.png)\n\n![Image 2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_6.png)\n\n- Add Bootstrap (and popper) to be precompiled in our assets.rb\n\n![Image 3](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 번들 설치를 통해 gems를 설치하세요 (또는 단축키 번들)\n\n![이미지1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_8.png)\n\n만약 rails 서버를 통해 앱을 시작하면 (또는 단축키 rails s를 사용하면), 레일즈 페이지가 표시됩니다:\n\n![이미지2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_9.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 앱에 페이지를 추가하려면 controllers(home/index)을 생성합니다. 레일즈 generate controllers home index(단축어로는 rails g)를 사용하세요. 이 명령어는 home_controller(관례에 따라 지어지는 새로운 컨트롤러)와 index 액션을 생성합니다.\n\n![이미지1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_10.png)\n\n![이미지2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_11.png)\n\n정말 멋지죠! 하지만 이 페이지를 루트(localhost:3000/)로 설정하려면 routes.rb에서 변경하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 Markdown 형식으로 변환되었습니다.\n\n![이미지](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_12.png)\n\n원래 우리는 Rails에게 앱의 루트가 home 컨트롤러이고 인덱스라는 액션에 있다고 말합니다. 이제 rails s로 서버를 재시작하고 브라우저를 엽니다:\n\n![이미지](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_13.png)\n\nBootstrap이 작동하는지 확인하기 위해 우리는 부트스트랩 사이트에서 데모 네비게이션 바를 새로운 *navbar.html.erb 파일에 복사합니다 (이름 앞의 *는 중요합니다!)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_14.png)\n\n그리고 이를 app/views/shared 폴더에 넣어주세요 (views 폴더 안에 shared 폴더를 만드세요).\n\n우리의 \\_navbar.html.erb는 부분(partial)이라고 불립니다: 이것은 우리의 html의 일부, 컴포넌트로 렌더링됩니다. 또한, 우리 Rails 프로젝트의 \"html\" 파일들은 실제로 순수한 html이 아니라 특별한 .html.erb (Embedded Ruby) 확장자를 사용합니다. 이렇게 하면 우리는 HTML 코드 안에 Ruby 코드를 삽입할 수 있습니다.\n\nApplication.html.erb로 이동하여 render_partial에 우리의 부분을 추가해보세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot 1](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_15.png)\n\nyield는 컨트롤러에서 요청한 페이지를 렌더링하는 특별한 단어입니다. 이 방법을 사용하면 전체 HTML에 application.html.erb 헤더와 네비게이션 바가 모든 페이지에 포함되며, yield는 요청한 페이지(이 경우 루트)를 렌더링합니다:\n\n![Screenshot 2](/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_16.png)\n\n부트스트랩 네비게이션 바가 성공적으로 로드되었지만 드롭다운 메뉴 클릭이 작동하지 않습니다. sprockets에게 부트스트랩에 필요한 Javascript를 번들하도록 알려야 합니다. javascript/application.js 파일에 누락된 require를 추가해줍니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_17.png\" />\n\n<img src=\"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_18.png\" />\n\n이제 모든 것이 잘 작동합니다!\n\n이 간단한 튜토리얼로 도움이 되었기를 바랍니다. Rails는 웹 애플리케이션을 개발하는 데 많은 도움이 되며, 여러분도 사용하면 좋겠네요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래에서 뵙겠습니다!\n\n## 유용한 링크:\n\n- Rails 포럼, 포스트 및 제 답변;\n- Bootstrap Rubygems 설치 및 Bootstrap gem의 깃허브;\n","ogImage":{"url":"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_0.png"},"coverImage":"/assets/img/2024-06-23-JavascriptBootstrapAssetBundlinginRubyonRails7_0.png","tag":["Tech"],"readingTime":10},{"title":"RSpec 매처와 기대 설정 방법","description":"","date":"2024-06-23 20:48","slug":"2024-06-23-RSpecMatchersandExpectations","content":"\n![이미지](/assets/img/2024-06-23-RSpecMatchersandExpectations_0.png)\n\n버그가 없는 코드를 작성하는 것은 끝이 없는 전투입니다. 가장 경험 많은 개발자라도 모든 예외 상황과 잠재적인 문제를 잡는 데 어려움을 겪습니다. 그러나 올바른 도구와 기술을 활용하면 소프트웨어의 신뢰성을 크게 향상시킬 수 있습니다.\n\n# RSpec Expectations 탐색\n\nRSpec의 expectations는 Ruby 웹 어플리케이션을 테스트하는 강력한 도구입니다. 전통적인 어설션과 달리 expectations는 조합성, 자동 부정, 가독성 향상 및 더 유용한 에러 메시지를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기대하는 요소\n\n기대는 세 가지 주요 부분으로 구성됩니다:\n\n- Subject: 일반적으로 루비 클래스의 인스턴스인 테스트 대상 객체입니다.\n- Matcher: 예상되는 동작을 지정하고 통과/실패 논리를 제공하는 객체입니다.\n- 사용자 정의 실패 메시지(선택 사항): 기대가 실패할 때 추가적인 문맥을 제공하기 위한 사용자 정의 메시지입니다.\n\n여기 예시가 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 주제\n\nsubject = Course.new(name: \"루비 입문\")\n\n# 매처 및 사용자 정의 실패 메시지를 사용한 예상\n\nexpect(subject.name).to eq(\"루비 입문\"), \"과정 이름이 일치해야 함\"\n\n# 매처 구성\n\n다양한 방법으로 매처를 조합하여 복잡한 동작을 정밀하게 지정할 수 있습니다:\n\n- 다른 매처에 매처 전달하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexpect(subject.lessons).to start_with(an_object_having_attributes(title: \"Ruby Basics\"))\n```\n\n2. Embedding matchers in Arrays and Hashes:\n\n```js\nexpected_student = {\n  name: \"John Doe\",\n  enrolled_courses: an_object_having_attributes(name: a_string_starting_with(\"Introduction\"))\n}\nexpect(subject.students).to include(expected_student)\n```\n\n3. Combining matchers with logical operators:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexpect(subject.grading_system).to be_present & match(/letter|numeric/)\n```\n\n## 전통적인 단언문보다 RSpec의 장점\n\n전통적인 단언문과는 달리, RSpec의 기대치는 다음과 같은 장점을 제공합니다:\n\n- 개선된 가독성: 구문은 자연어에 더 가깝기 때문에 테스트를 읽고 이해하기 쉽습니다.\n- 결합성: 매처를 결합하여 더 복잡한 단언문을 만들 수 있으며 명확성을 잃지 않습니다.\n- 더 나은 오류 메시지: 테스트가 실패할 때 RSpec은 디버깅을 더 쉽게 만드는 자세한 메시지를 제공합니다.\n- 자동 부정: .not_to 또는 .to_not를 사용하면 부정이 더 직관적이며 테스트의 표현력을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 생성된 예제 설명\n\nMatchers는 자체적으로 설명을 제공하여 RSpec이 예제에 대한 가독성있는 설명을 생성할 수 있게 합니다. 이는 중복을 줄이고 테스트를 미래를 대비하여 더 견고하게 만드는 데 도움이 될 수 있습니다.\n\n```js\nRSpec.describe Course, \"#enrolled_students\" do\n  subject { Course.new(name: \"Introduction to Ruby\") }\n\n  it { is_expected.to have_attributes(enrolled_students: be_empty) }\n  it { should_not have_attributes(enrolled_students: include(an_object_having_attributes(name: \"John Doe\"))) }\nend\n```\n\n출력은 다음과 같이 표시됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCourse#enrolled_students\nshould have attributes enrolled_students: []\nshould not have attributes enrolled_students: [#<name: \"John Doe\">]\n\nWhile generated descriptions are convenient, use them judiciously. They can be misleading if your setup code changes, and one-liner specs can sometimes\nbe harder to read and maintain.\n\n# Exploring RSpec’s Matchers for Your App\n\nRSpec offers a wide range of built-in matchers to help you write expressive and robust tests.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 기본 일치자\n\n이러한 일치자는 문자열, 숫자 및 부울과 같은 기본 데이터 유형을 처리합니다. 예를 들어, 학생의 이름이 특정 값과 일치하는지 테스트하려면:\n\n```js\nstudent = Student.new(name: \"John Doe\")\nexpect(student.name).to eq(\"John Doe\")\n```\n\n# 컬렉션 일치자\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRSpec은 배열이나 해시와 같은 컬렉션과 함께 작업하는 여러 매처를 제공합니다. 특정 요소가 컬렉션에 포함되어 있는지 확인하려면 include를 사용할 수 있습니다:\n\n```js\nenrolled_courses = [\n  { name: \"Ruby Basics\", credits: 3 },\n  { name: \"Web Development\", credits: 5 }\n]\n\nexpect(enrolled_courses).to include(\n  an_object_having_attributes(name: \"Ruby Basics\")\n)\n```\n\nmatch 매처는 깊게 중첩된 데이터 구조에 유용하며, 배열 요소나 해시 값에 대해 어떤 수준에서든 매처를 대체할 수 있습니다.\n\n# 블록 매처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔은 코드 블록의 동작을 테스트해야 할 때가 있습니다. 예를 들어, 예외가 발생하는지 확인하거나 메소드가 블록에 제어를 양보하는지 확인하는 것입니다. 이런 시나리오에는 RSpec의 블록 매처들이 유용합니다.\n\n```js\nexpect { course.enroll(nil) }.to raise_error(ArgumentError)\n\nexpect { |block| course.lessons.each(&block) }.to yield_successive_args(\n  [\"Lesson 1\", 1],\n  [\"Lesson 2\", 2]\n)\n```\n\n# 조합된 매처들\n\nRSpec의 장점 중 하나는 매처들을 조합할 수 있다는 것입니다. 이를 통해 복잡한 동작을 정확하게 지정할 수 있습니다. 논리 연산자를 사용하여 매처를 결합하거나, 하나의 매처를 다른 매처로 전달하거나, 매처를 데이터 구조 안에 포함시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexpect(course.lessons).to all(\n  have_attributes(duration: a_value_between(30, 90))\n    .and(start_with(\"Lesson\"))\n)\n```\n\n# 간단한 설명\n\nRSpec expectations은 조합성, 가독성 및 자세한 오류 메시지를 제공합니다. 복잡한 조건을 정확하게 지정하기 위해 matcher composition을 사용하세요.\n\n기본 데이터 유형의 경우 등가성 및 진실성 matcher를 사용하세요. include, match 및 contain_exactly로 컬렉션을 확인하세요. 예외와 블록 matcher를 사용하여 코드 동작을 테스트하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n일치자를 중첩하여 배치하거나 데이터 구조에 삽입하여 논리 연산자를 사용하여 작성하세요. 엄격한 동등성보다는 유연한 일치자를 선택하세요. 가독성을 높이기 위해 별칭 및 사용자 정의 메시지를 사용하세요.\n","ogImage":{"url":"/assets/img/2024-06-23-RSpecMatchersandExpectations_0.png"},"coverImage":"/assets/img/2024-06-23-RSpecMatchersandExpectations_0.png","tag":["Tech"],"readingTime":7},{"title":"2024년 최신 가이드 Rails 프로젝트에 Swagger UI 설정하는 방법","description":"","date":"2024-06-23 20:47","slug":"2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition","content":"\n![이미지](/assets/img/2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition_0.png)\n\n명확하고 상호작용이 가능한 API 문서 작성은 유지보수 가능하고 접근성 있는 웹 서비스를 개발하는 중요한 부분입니다. Swagger UI는 개발자를 위한 동적 문서 인터페이스로서, Ruby on Rails 프로젝트에 통합하면 개발자 경험을 크게 향상시킬 수 있습니다. 이 글에서는 Grape API를 위한 인기 있는 gem인 grape-swagger와 RSpec API 문서 작성을 위한 gem인 rswag를 사용하여 Swagger UI를 설정하는 과정을 자세히 설명합니다.\n\n---\n\n# 해결책 1: 일반적인 Rails 프로젝트용\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCordyline은 Progressive Documentation 아이디어를 가진 새로운 프로젝트에요.\n\n## 단계 1: Cordyline 설치\n\nCordyline 공식 웹사이트를 방문해서 미리 만들어진 gem 앱을 다운로드하세요.\n\n## 단계 2: 통합\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비 온 레일즈 프로젝트를 선택하고 번들 설치를 실행해주세요.\n\n(base) 컨트롤러에 도우미 모듈을 추가해주세요.\n\n```js\nclass ApplicationController < ActionController::API\n include Cordyline::DocGen\nend\n```\n\n## 단계 3: 첫 번째 문서 작성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n컨트롤러의 모든 동작에서는 docto 메서드를 사용하여 문서 주석을 작성하세요.\n\n```js\nclass WelcomeController\n  doc \"인사 엔드포인트, 아무 동작 없음\" do\n    detail \"일부 세부 정보\"\n  end\n\n  def index\n  end\nend\n```\n\n## 단계 4: Swagger 문서 호스팅\n\n아래 라인을 routes.rb 파일에 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nrequire 'cordyline/web'\n\nTestApp::Application.routes.draw do\n  mount Cordyline::Web => '/team_doc' # 또는 다른 경로\nend\n```\n\n이제 팀은 배포된 웹사이트에서 /team_doc/index.html 경로로 Swagger 문서에 액세스할 수 있습니다.\n\n# 해결책 2: Grape API에 대한 설명\n\nGrape는 루비용 REST와 유사한 API 마이크로 프레임워크로, Rack에서 실행하거나 Rails와 같은 기존 웹 애플리케이션 프레임워크와 함께 사용할 수 있도록 설계되었습니다. Grape-swagger는 Grape API에 대한 자동 생성된 문서를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 1: grape-swagger 설치하기\n\nGemfile에 grape-swagger를 추가하고 프로젝트에 추가하려면 번들 설치를 실행하세요:\n\n```js\ngem 'grape-swagger'\n```\n\n그리고 실행하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n번들 설치\n```\n\n## 단계 2: grape-swagger 구성\n\ngrape-swagger를 위한 초기 설정을 해보세요:\n\n```js\n# config/initializers/swagger.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nif defined?(Grape)\n  GrapeSwaggerRails.options.url      = \"/api/swagger_doc\"\n  GrapeSwaggerRails.options.app_name = \"MyApp\"\n  GrapeSwaggerRails.options.app_url  = \"/\"\nend\n```\n\n## 단계 3: API 엔티티 및 문서 정의\n\ngrape-swagger가 문서화할 수 있도록 API 엔티티를 정의해야 합니다:\n\n```js\n# app/api/entities/my_entity.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n모듈 API\n  모듈 엔티티\n    클래스 MyEntity < Grape::Entity\n      expose :id, documentation: { type: 'Integer', desc: '엔티티의 ID' }\n      # ... 추가 코드 ...\n    end\n  end\nend\n```\n\n## 단계 4: 스웨거 엔드포인트 추가\n\nAPI 베이스 클래스에서 스웨거 설명 라우트를 추가하여 스웨거 JSON을 제공할 수 있도록 합니다:\n\n```js\n# app/api/base.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nclass API::Base < Grape::API\n  add_swagger_documentation\nend\n```\n\n## 단계 5: Swagger 문서 보기\n\n이제 http://localhost:3000/swagger로 이동하여 Swagger UI에 액세스할 수 있습니다.\n\n# 해결 방법 3: RSpec 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nrswag은 API 테스트에 기반하여 자동으로 Swagger 호환 API 문서를 생성하는 데 RSpec과 통합됩니다.\n\n## 단계 1: rswag-specs 설치\n\nGemfile에 rswag-specs를 추가하고 설치하세요:\n\n```js\ngem 'rswag-specs'\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 다음을 실행해 주세요:\n\n```js\nbundle install\n```\n\n## 단계 2: 구성 및 파일 생성\n\nRSwag 생성기를 실행하여 API 사양을 위한 초기 구성 및 디렉터리를 생성하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nrails g rswag:install\n```\n\n## 단계 3: Swagger DSL을 사용하여 요청 스펙 작성하기\n\n스펙 파일을 생성하고 RSwag의 DSL을 사용하여 엔드포인트를 테스트하고 문서화하세요:\n\n```js\n# spec/integration/my_api_spec.rb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```ruby\nrequire 'swagger_helper'\ndescribe 'My API' do\n  path '/my_api/endpoint' do\n    ...\n    get 'Retrieves something' do\n      produces 'application/json'\n      response '200', 'successful' do\n        schema type: :object,\n               properties: {\n                 id: { type: :integer }\n               },\n               required: ['id']\n        # Your test code goes here\n      end\n    end\n  end\nend\n```\n\n## 단계 4: RSwag UI로 API 문서에 액세스하기\n\nRSwag는 http://localhost:3000/api-docs에서 액세스할 수 있는 Swagger UI를 제공합니다. 이 UI는 직접 작성한 사양을 반영합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoSetUpSwaggerUIforRailsProject2024Edition_0.png","tag":["Tech"],"readingTime":7},{"title":"루비에서 SELF 키워드 사용하는 방법","description":"","date":"2024-06-23 20:46","slug":"2024-06-23-SELFkeywordinruby","content":"\nRuby에서 self의 목적은 무엇인가요?\n\n<img src=\"/assets/img/2024-06-23-SELFkeywordinruby_0.png\" />\n\nRuby에서 self는 현재 객체를 나타내는 특별한 변수입니다. self의 의미는 사용되는 문맥에 따라 달라집니다. self를 이해하는 것은 다른 범위 내에서 어떻게 메서드와 변수에 접근하고 조작하는지에 영향을 미치므로 중요합니다. 이 글에서는 Ruby에서 self의 목적에 대해 자세히 살펴보고 상세한 예시를 제시하겠습니다.\n\n# Ruby에서 self의 목적\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 인스턴스 변수 및 메소드에 접근하기: 인스턴스 메소드 내부에서 self는 클래스의 인스턴스를 가리키며, 인스턴스 변수와 메소드에 접근할 수 있게 합니다.\n- 클래스 메소드 정의하기: 클래스 정의 내부에서 self는 클래스 자체를 가리킵니다. 이는 클래스 메소드를 정의하는 데 유용합니다.\n- 싱글톤 메소드: self를 사용하여 클래스의 모든 인스턴스가 아닌 단일 객체에 속하는 메소드를 정의할 수 있습니다.\n- 메타프로그래밍: self는 메타프로그래밍에서 자주 사용되어 동적으로 메소드를 정의하고 객체를 조작하는 데 활용됩니다.\n- 문맥 인식: self는 코드 실행 문맥을 이해하는 데 도움이 되어 메소드 해결과 범위 관리에 중요합니다.\n\n# self 사용 예시\n\n## 1. 인스턴스 변수와 메소드에 접근하기\n\n이 문맥에서 self는 인스턴스 메소드 내부에서 인스턴스 변수와 메소드에 접근 가능하도록 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\nclass Person\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\n\n  def birthday\n    self.age += 1\n  end\n\n  def introduce\n    \"Hello, I'm #{self.name} and I'm #{self.age} years old.\"\n  end\n\n  # Getter and setter methods\n  def name\n    @name\n  end\n\n  def age\n    @age\n  end\n\n  def age=(new_age)\n    @age = new_age\n  end\nend\n\nperson = Person.new(\"Alice\", 30)\nputs person.introduce # 출력: \"안녕, 나는 Alice이고 30살이야.\"\nperson.birthday\nputs person.introduce # 출력: \"안녕, 나는 Alice이고 31살이야.\"\n```\n\n## 2. 클래스 메소드 정의하기\n\n클래스 내부에서 사용될 때 self는 클래스 자체를 가리키며, 클래스 메소드를 정의하는 데 유용합니다.\n\n```javascript\nclass MathUtils\n  def self.square(num)\n    num * num\n  end\n\n  def self.cube(num)\n    num * num * num\n  end\nend\n\nputs MathUtils.square(3) # 출력: 9\nputs MathUtils.cube(3)   # 출력: 27\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass MathUtils\n  class << self\n    def square(num)\n      num * num\n    end\n\n    def cube(num)\n      num * num * num\n    end\n  end\nend\n\nputs MathUtils.square(3) # Output: 9\nputs MathUtils.cube(3)   # Output: 27\n```\n\n## 3. Singleton Methods\n\nself can be used to define methods on a single object (singleton methods).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nstr = \"Hello\"\n\ndef str.shout\nself.upcase + \"!!!\"\nend\n\nputs str.shout # Output: \"HELLO!!!\"\n\n## 4. 메타프로그래밍\n\n메타프로그래밍에서 자주 self는 메소드를 동적으로 정의하고 객체를 조작하는 데 사용됩니다.\n\n```ruby\nclass MyClass\n  def self.create_method(name)\n    define_method(name) do\n      \"Method #{name} called\"\n    end\n  end\nend\n\nMyClass.create_method(:greet)\nobj = MyClass.new\nputs obj.greet # Output: \"Method greet called\"\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nself는 메소드 해결 및 범위 관리에 중요한 실행 컨텍스트를 이해하는 데 도움이 됩니다.\n\n```js\nclass Animal\n  def speak\n    \"동물이 말합니다\"\n  end\n\n  def call_speak\n    self.speak\n  end\nend\n\nclass Dog < Animal\n  def speak\n    \"멍멍!\"\n  end\nend\n\ndog = Dog.new\nputs dog.call_speak # 출력: \"멍멍!\"\n```\n\n## 6. 속성 작성기와 self 사용\n\nself를 사용하는 것은 속성 작성기(setters)를 호출할 때 중요합니다. 이는 로컬 변수 할당과 모호함을 피하기 위해 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass User\n  attr_accessor :name\n\n  def initialize(name)\n    @name = name\n  end\n\n  def rename(new_name)\n    self.name = new_name # setter method `name=`이(가) 사용됨\n  end\nend\n\nuser = User.new(\"John\")\nuser.rename(\"Doe\")\nputs user.name # 출력: \"Doe\"\n```\n\n# 요약\n\n- 인스턴스 컨텍스트: 인스턴스 메서드 내에서 self는 클래스의 현재 인스턴스를 가리킵니다.\n- 클래스 컨텍스트: 클래스 메서드 및 클래스 정의 내에서 self는 클래스 자체를 가리킵니다.\n- 싱글톤 메서드: self는 개별 객체에 대해 메서드를 정의하는 데 사용될 수 있습니다.\n- 메타프로그래밍: self는 동적으로 메서드를 정의하고 객체를 조작하는 데 사용됩니다.\n- 컨텍스트 인식: self는 현재 실행 컨텍스트를 이해하는 데 도움을 주며, 메서드 해결과 범위에 영향을 줍니다.\n- 속성 쓰기: self는 로컬 변수 할당과 구별하기 위해 세터 메서드를 호출하는 데 필요합니다.\n\nRubyself의 사용을 숙달하면 더 유연하고 재사용 가능하며 유지 관리가 쉬운 코드를 작성할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-SELFkeywordinruby_0.png"},"coverImage":"/assets/img/2024-06-23-SELFkeywordinruby_0.png","tag":["Tech"],"readingTime":5},{"title":"업데이트 실행 가능한 pod로 gem cocoapods  0a를 찾을 수 없는 경우 해결 방법 GemGemNotFoundException","description":"","date":"2024-06-23 20:45","slug":"2024-06-23-Updatedcantfindgemcocoapods0awithexecutablepodGemGemNotFoundException","content":"\n이는 CocoaPods가 시스템에 설치되어 있지 않거나 PATH 변수에 설치되어 있지만 실행 파일인 'pod'를 찾을 수 없음을 의미합니다.\n\n![이미지](/assets/img/2024-06-23-Updatedcantfindgemcocoapods0awithexecutablepodGemGemNotFoundException_0.png)\n\n문제:\n\n```js\n.rvm/rubies/ruby-2.7.6/lib/ruby/site_ruby/2.7.0/rubygems.rb:264:in `find_spec_for_exe': can't find gem cocoapods (>= 0.a) with executable pod (Gem::GemNotFoundException)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해결책:\n\n```javascript\n// cocoapod이 설치되어 있는지 확인하세요. 아니라면\nsudo gem install cocoapods\n\ngem pristine --all\n\n// gem 실행 시 권한 오류가 발생한다면 (Errno::EACCES), 슈퍼 사용자를 사용하세요\n```\n\n```javascript\nbundle i 또는 bundle install\n```\n\n2024년 2월 업데이트:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems.rb:283:in `find_spec_for_exe': 실행 가능한 'pod'로 cocoapods (>= 0.a) 젬을 찾을 수 없습니다 (Gem::GemNotFoundException)\n from /System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/lib/ruby/2.6.0/rubygems.rb:302:in `activate_bin_path'\n from /usr/local/bin/pod:23:in `<main>'\n```\n\n# 알 수 없는 루비 인터프리터 버전 (어떻게 처리할지 모름): `=2.6.10.\n\n```js\nnano ~/.bash_profile\nsource ~/.bash_profile\n# bash_profile에 아래 경로 추가\n```\n\n```js\n# .bash_profile에 RVM이 가장 마지막에 있지 않으면 오류가 발생할 수 있음\nexport PATH=\"$PATH:$HOME/.rvm/bin\" # Ruby 버전을 관리하기 위해 RVM을 스크립트에 추가\nexport PATH=\"$GEM_HOME/bin:$PATH\"\n[[ -s \"$HOME/.rvm/scripts/rvm\" ]] && source \"$HOME/.rvm/scripts/rvm\"  # RVM을 셸 세션에 함수로 로드\n```\n","ogImage":{"url":"/assets/img/2024-06-23-Updatedcantfindgemcocoapods0awithexecutablepodGemGemNotFoundException_0.png"},"coverImage":"/assets/img/2024-06-23-Updatedcantfindgemcocoapods0awithexecutablepodGemGemNotFoundException_0.png","tag":["Tech"],"readingTime":2},{"title":"Ruby on Rails에서 스파게티 코드 피하는 방법","description":"","date":"2024-06-23 20:44","slug":"2024-06-23-AvoidingSpaghettiCodeinRubyonRails","content":"\n![이미지](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_0.png)\n\n깨끗하고 유지보수 가능한 코드를 작성하는 것은 개발자에게 중요한 기술입니다. 특히 Ruby on Rails와 같은 견고한 프레임워크를 사용할 때는 더욱 중요합니다. 스파게티 코드란 복잡하고 읽기 어렵고 모듈화되지 않은 코드를 가리키며, 이는 애플리케이션을 확장하거나 디버그하고 유지하기 어렵게 만들 수 있습니다. 이 기사는 Ruby on Rails 개발자들이 스파게티 코드 함정에 빠지지 않도록 도와주기 위한 실용적인 팁과 예제를 제공합니다.\n\n## 레일스의 방식을 따르기\n\n원칙: 더 깨끗하고 예측 가능한 코드베이스를 위해 레일스의 관례를 활용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예제: Rails는 모델, 뷰, 컨트롤러, 도우미 등과 관련된 코드를 위한 특정 장소를 제공합니다. 예를 들어, 새로운 리소스를 생성할 때:\n\n![](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_1.png)\n\n이 명령은 Rails의 관례를 준수하여 모델, 컨트롤러 및 뷰를 관행적인 위치에 생성하여 깨끗하고 조직화된 코드베이스를 유도합니다.\n\n## RESTful 리소스 사용하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원칙: 응용 프로그램을 리소스를 중심으로 구성하고 RESTful 경로를 준수하세요.\n\n예: 가능한 경우에는 사용자 정의 경로가 아닌 RESTful 경로를 사용하여 config/routes.rb에서 다음을 수행하십시오:\n\n![RESTful routes](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_2.png)\n\n이 간단한 한 줄은 RESTful 원칙을 준수하는 일곱 가지 다른 경로를 생성하여 응용 프로그램 구조에서 일관성과 예측 가능성을 촉진합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## DRY (Don’t Repeat Yourself)\n\n원칙: 코드 중복을 피해서 응용 프로그램을 유지 관리하기 쉽게 만듭니다.\n\n예: 공유 뷰 코드에 대해 부분 적용파일을 사용하십시오. 여러 뷰가 동일한 포스트 양식을 사용하는 경우 \\_form.html.erb와 같은 부분 적용 파일을 만드세요:\n\n<img src=\"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 다음과 같이 Markdown 형식으로 해당 테이블을 추가하세요:\n\n![Avoiding Spaghetti Code](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_4.png)\n\n## 가벼운 컨트롤러, 뚱뚱한 모델\n\n원칙: 컨트롤러는 경량이어야 하며, HTTP와 관련된 로직만 처리하고, 모델은 비즈니스 로직을 처리해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: 비즈니스 로직을 컨트롤러에 넣는 대신:\n\n![AvoidingSpaghettiCodeinRubyonRails_5](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_5.png)\n\n로직을 모델로 옮기세요:\n\n![AvoidingSpaghettiCodeinRubyonRails_6](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 서비스 객체 사용하기\n\n주의 사항: 복잡한 비즈니스 로직을 다룰 때는 모델을 간단하고 유지보수하기 쉽도록 서비스 객체를 사용하세요.\n\n예시: 게시물 생성이 여러 단계를 거치는 경우 서비스 객체를 만드세요:\n\n![예시 이미지](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_7.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼, 귀하의 컨트롤러에서:\n\n![AvoidingSpaghettiCodeinRubyonRails_8](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_8.png)\n\n## ActiveRecord 관계 및 스코프\n\n주요 원칙: 모델 관계에는 연관성을 사용하고 자주 사용하는 쿼리에는 스코프를 사용하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: 모델에서 연관 관계 정의하기:\n\n![이미지](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_9.png)\n\n그리고 일반적인 쿼리에 대해 스코프 사용하기:\n\n![이미지](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_10.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 테스트\n\n원칙: 코드에 대한 테스트를 작성하여 예상대로 작동하는지 확인하세요.\n\n예시: 모델 테스트를 작성하기 위해 RSpec을 사용하세요:\n\n![image](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 리팩터링\n\n원칙: 코드의 구조와 가독성을 꾸준히 개선하세요.\n\n예시: 복잡한 메서드를 작은 조각으로 나눠서 관리하기 쉬운 코드로 리팩터링하세요.\n\n이전:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_12.png\" />\n\nAfter:\n\n<img src=\"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_13.png\" />\n\n## Follow Ruby and Rails Style Guides\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n원칙: 스타일 가이드를 준수하여 코드 일관성 유지하기\n\n예시: RuboCop을 사용하여 스타일 지침을 자동으로 강제합니다. 간단한 .rubocop.yml 파일을 사용하여 커뮤니티 표준을 강요할 수 있습니다:\n\n![image](/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_14.png)\n\n## 코드 리뷰\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**원칙:** 고품질을 유지하고 지식을 공유하기 위해 코드 리뷰에 참여하십시오.\n\n**예시:** 코드 리뷰를 위해 GitHub 풀 리퀘스트를 사용하십시오. 팀원들로부터 리뷰를 요청하여 문제를 일찍 발견하고 일관된 코딩 관행을 유지할 수 있습니다.\n\n이러한 원칙과 예시를 적용함으로써 Ruby on Rails 개발자들은 더 깨끗하고 유지보수하기 좋은 코드를 작성할 수 있으며, 꼬여버린 스파게티 코드를 피하고 응용 프로그램을 보다 즐겁고 확장하기 쉽게 만들 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_0.png"},"coverImage":"/assets/img/2024-06-23-AvoidingSpaghettiCodeinRubyonRails_0.png","tag":["Tech"],"readingTime":7},{"title":"AOP를 활용한 공통 관심사 처리 방법","description":"","date":"2024-06-23 20:42","slug":"2024-06-23-HandlingcrosscuttingconcernswithAOP","content":"\n# 목차\n\n- 소개\n- AOP의 다양한 구성 요소\n  - ` Aspect\n  - ` Join Point\n  - ` Pointcut\n  - ` Advice\n- 로깅 프레임워크를 사용하여 AOP 이해하기\n- AOP와 필터의 차이점은 무엇인가요?\n- 결론\n\n# 소개\n\n관점 지향 프로그래밍(Aspect-Oriented Programming, AOP)은 모듈성을 높이기 위해 교차하는 관심사를 측면(Aspect)으로 분리할 수 있도록 하는 프로그래밍 표준입니다. 전통적인 프로그래밍 패러다임에서는 로깅, 보안 및 트랜잭션 관리와 같은 공통 관심사가 다양한 모듈에 걸쳐 분산되어 코드베이스를 유지 및 이해하기 어렵게 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전통적인 로깅 방식:\n\n```js\nprivate User getUserById(Integer userId){\n    Long startTime = System.currentTimeMillis();\n    logger.info(\"Starting method getUserById at {}\", startTime);\n    User user = myDao.getUserById(userId);\n    Long endTime = System.currentTimeMillis();\n    logger.info(\"Ending method getUserById with response {} at time {}\", user, endTime);\n    return user;\n}\n```\n\n그러나 관점 지향 프로그래밍(Aspect-Oriented Programming, AOP)을 활용하면 교차 우선 관심사항(Cross-cutting concerns)을 분리된 단위인 어스펙트(Aspects)로 캡슐화할 수 있습니다. 이를 통해 코드를 더욱 깔끔하고 모듈화할 수 있으며, 각 어스펙트가 특정한 교차 우선 관심사항을 다룹니다.\n\nAOP를 사용한 로깅:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Logging(printResponse = true, logLevel = LOG.INFO)\nprivate User getUserById(Integer userId){\n  User user = myDao.getUserById(userId);\n  return user;\n}\n```\n\n# AOP의 다양한 구성 요소\n\nAOP의 다양한 구성 요소를 연극 공연의 예를 들어 설명해 보겠습니다.\n\nJoin Point: 연극 무대에 있는 자신을 상상해보세요. 배우들이 하는 장면 변화나 특정 동작은 모두 join point로 작용합니다. 예를 들어, 캐릭터가 무대에 나오거나 내려갈 때, 특정 대사를 말할 때가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포인트컷: 지금 이 시점에서 연극 대본이 포인트컷 역할을 합니다. 이는 특정 대사나 활동의 타이밍을 설정합니다. 예를 들어, 특정 캐릭터가 자정에 무대에 나와야 한다는 것을 시사할 수 있습니다.\n\n조언: 배우들의 연기가 조언을 대변합니다. 그들은 지정된 대본 위치(포인트컷)에서 지시된 대사를 전달하거나 행동을 수행합니다. 따라서 특정 캐릭터가 자정에 무대에 나와야 한다면, 해당 캐릭터를 연기하는 배우는 대본의 지시(포인트컷)에 따라 정해진 대로 행동하게 됩니다.\n\n프로그램은 예시로 든 이 극장 공연을 나타냅니다. 각 장면이나 행동은 조인 포인트가 되며, 대본은 언제 행동이 일어나야 하는지를 나타내는 포인트컷이며, 배우의 연기는 그 시간에 수행되는 조언입니다.\n\n이제 각 구성 요소에 대해 자세히 알아보겠습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 1.) Aspect\n\nAspect(관점)은 횡단 관심사(cross-cutting concerns)를 캡슐화합니다. 지정된 결합 지점(join points)에서 기본 코드에 적용해야 하는 동작을 정의하는 코드를 포함합니다. Aspect에는 조언(advice)과 포인트컷(pointcuts)이 포함됩니다.\n\n## 2.) Join Point\n\nJoin Point(결합 지점)는 프로그램 실행 중 특정 지점인데, 메서드 실행, 메서드 호출, 객체 인스턴스화 및 필드 접근 같은 지점에서 Aspect를 적용할 수 있습니다. Aspect는 결합 지점을 정의하여 영향을 미치는 결합 지점을 명시합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3.) 포인트컷\n\n포인트컷은 측면이 적용되어야 하는 코드의 기준을 지정합니다. 메서드 시그니처, 클래스 이름, 주석 또는 기타 기준을 기반으로 할 수 있습니다.\n\n아래는 응용 프로그램에서 조인 포인트를 선택하는 데 사용할 수 있는 다양한 유형의 포인트컷입니다.\n\ni) 실행 포인트컷: 이는 응용 프로그램에서 메서드를 실행하는 기준에 따라 조인 포인트를 선택합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n@Before(\"execution(* com.user.service.*.*(..))\")\npublic Object performAuth(JoinPoint joinPoint) throws Throwable {\n    // Advice implementation\n}\n```\n\n“execution(_ com.user.service._.\\*(..))”: 이 부분은 포인트컷 표현식입니다. 왼쪽부터 오른쪽으로 살펴보겠습니다.\n\nexecution - 이 부분은 메서드 실행을 기반으로 포인트컷을 정의하고 있다는 키워드입니다.\n\n- - 이 와일드카드는 메서드의 반환 타입을 나타냅니다. 여기서 \\*는 어떤 반환 타입이던지를 의미합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncom.user.service.* - 이 부분은 대상 클래스가 위치한 패키지를 지정합니다 (com.user.service). 마지막 점 뒤의 *는 이 패키지 내의 모든 클래스 이름을 의미합니다.\n\n.* - 이 부분은 메서드 이름을 지정합니다. 여기서 .*는 모든 메서드 이름을 의미합니다.\n\n(..) - 이 부분은 메서드 매개변수를 지정합니다. (..)은 모든 타입의 매개변수를 가진 임의의 개수의 매개변수를 의미합니다.\n\nii) 포인트컷 내에서: 이 포인트컷 표현식은 표현식에 정의된 패키지 이름이나 클래스를 기반으로 조인 포인트를 선택합니다. 해당 패키지/클래스 내의 모든 메서드 실행을 선택합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Around(\"within(com.cache.service.*)\")\npublic Object warmupAndDestroyCache(ProceedingJoinPoint joinPoint) throws Throwable {\n    // Advice implementation\n}\n```\n\n\"within(com.cache.service.\\*)\" : 이 표현은 com.cache.service 패키지 내에서 모든 메서드를 선택합니다.\n\niii) 어노테이션 포인트컷: 이 포인트컷은 지정된 어노테이션으로 주석이 달린 모든 메서드와 일치하는 조인 포인트를 선택합니다.\n\n```java\n@After(\"@annotation(com.user.annotations.AuditPurchase)\")\npublic Object logPurchaseHistory(JoinPoint joinPoint) throws Throwable {\n    // Advice implementation\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n“@annotation(com.user.annotations.AuditPurchase)” : 이 표현은 AuditPurchase 어노테이션이 지정된 모든 메서드를 선택합니다.\n\niv) @within Pointcut : 이 포인트컷은 대상 클래스에 특정 어노테이션이 있는 조인 포인트를 선택합니다. 지정된 어노테이션이 지정된 클래스 내에서 메서드 실행될 때 이 포인트컷에 의해 일치됩니다.\n\n```js\n@AfterThrowing(pointcut = \"@within(com.user.annotations.LogError)\", throwing = \"ex\")\npublic void logError(JoinPoint joinPoint, Throwable ex) {\n   // Advice implementation\n}\n```\n\n위에서 정의된 것 외에도 사용 사례에 따라 적용할 수 있는 여러 종류의 포인트컷 표현식이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4.) 조언\n\n조언은 특정 조인 포인트에서 취해지는 작업입니다. 일부 조건이 충족될 때 응용 프로그램에 추가하고 싶은 동작입니다. 조언은 일반적으로 포인트컷 표현과 관련이 있으며, 이 표현은 코드베이스 내에서 조언이 적용되어야 하는 위치를 정의합니다. 조언은 해당 포인트컷 표현과 일치하는 조인 포인트에서 실행될 수 있습니다.\n\n다양한 유형의 조언:\n\n- Before advice: 이 유형의 조언은 조언된 메서드가 호출되기 전에 실행됩니다. 입력 유효성 검사, 메서드 실행 시작 로깅 등과 같은 작업을 실행하는 데 일반적으로 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Before(\"@within(com.user.annotations.ValidateUserId)\")\npublic void validateUserId(JoinPoint joinPoint) {\n    Integer userId = ((MethodSignature) joinPoint.getSignature()).getMethod().getAnnotation(ValidateUserId.class).userId();\n    // validation 작업에 대한 나머지 로직\n}\n```\n\n- After advice: 이 유형의 어드바이스는 조언된 메서드가 성공 또는 실패에 관계없이 완료된 후에 실행됩니다. 주로 리소스 정리 작업에 사용됩니다.\n\n```java\n@After(\"execution(* com.user.service.*.*(..))\")\npublic void clearCache(JoinPoint joinPoint) {\n    // Advice 구현\n}\n```\n\n- After returning advice: 이 유형의 어드바이스는 어드바이스된 메서드가 예외를 던지지 않고 성공적으로 완료된 후에 실행됩니다. 메서드 실행 결과를 기록하거나 반환된 값에 기반한 후속 처리 작업을 수행하는 데 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@AfterReturning(pointcut = \"execution(* com.user.service.utils.regex.*.*(..))\", returning = \"result\")\npublic void removeHtmlTagsFromResult(JoinPoint joinPoint, Object result) {\n    // Advice implementation\n}\n```\n\n- After throwing advice: 이 유형의 어드바이스는 조언된 메서드가 예외를 던질 때 실행됩니다. 에러 로깅, 예외 처리 등에 유용합니다.\n\n```java\n@AfterThrowing(pointcut = \"execution(* com.user.service.*.*(..))\", throwing = \"exception\")\npublic void logError(JoinPoint joinPoint, Exception exception) {\n    // Advice implementation\n}\n```\n\n- Around advice: 이 유형의 어드바이스는 조언된 메소드의 호출을 완전히 제어합니다. 입력 및 출력을 포함하여 특정한 로직을 수행하기 위해 메소드 호출을 가로챕니다. 원래 메소드 호출 전후에 사용자 정의 로직을 수행하고, 원래 메소드 호출을 계속할지 여부를 제어할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 로깅 프레임워크를 활용한 AOP 이해\n\n여기서는 메서드에서 소요된 시간을 기록하는 어노테이션 기반 로깅 프레임워크를 생성할 것입니다. 해당 메서드의 입력 및 출력 매개변수를 출력하면서 소요된 시간을 기록합니다.\n\n단계 1: 어스펙트 생성\n\n먼저 로깅 어스펙트 클래스를 생성하여 로깅을 수행하는 어드바이스를 포함시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Aspect\n@Component\npublic class LoggingAspect {\n  // 어드바이스와 포인트컷 표현을 포함한 메소드\n}\n```\n\n단계 2: 어드바이스와 포인트컷 정의\n\n이 단계에서는 \"@annotation(com.user.service.annotations.LogTime)\" 포인트컷 표현을 가진 @Around 어드바이스를 가지는 doLogging 메소드를 생성할 것입니다.\n\n```java\n@Aspect\n@Component\npublic class LoggingAspect {\n\n  @Around(value = \"@annotation(com.user.service.annotations.LogTime)\")\n  public Object doLogging(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n\n    MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();\n    Method method = signature.getMethod();\n    LogTime loggableMethod = method.getAnnotation(LogTime.class);\n\n    // 이전 처리\n    LogWriter.write(proceedingJoinPoint.getTarget().getClass(), method.getName() + \"() 실행 시작 \");\n\n    if (proceedingJoinPoint.getArgs() != null && proceedingJoinPoint.getArgs().length > 0) {\n      StringBuilder sb = new StringBuilder();\n      for (int i = 0; i < proceedingJoinPoint.getArgs().length; i++) {\n        sb.append(method.getParameterTypes()[i].getName()).append(\":\").append(proceedingJoinPoint.getArgs()[i]);\n        if (i < proceedingJoinPoint.getArgs().length - 1)\n          sb.append(\", \");\n      }\n\n      LogWriter.write(proceedingJoinPoint.getTarget().getClass(), method.getName() + \"() args \" + sb);\n    }\n\n    long startTime = System.currentTimeMillis();\n\n    // 주요 메소드 실행\n    Object result = proceedingJoinPoint.proceed();\n\n    long endTime = System.currentTimeMillis();\n\n    // 결과 표시\n    if (result != null) {\n      LogWriter.write(proceedingJoinPoint.getTarget().getClass(), method.getName() + \"() 결과 : \" + result);\n    }\n\n    // 이후 표시\n    LogWriter.write(proceedingJoinPoint.getTarget().getClass(), method.getName() + \"() 실행 완료 및 실행 시간 \" + (endTime - startTime) + \" 밀리초 소요\");\n\n    return result;\n  }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n단계 3: 어노테이션 생성\n\n이번 단계에서는 우리가 어느 메서드에든 로깅 어드바이스를 적용할 수 있는 사용자 지정 LogTime 어노테이션을 만들고 있습니다.\n\n```java\n@Component\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface LogTime {\n\n}\n```\n\n단계 4: 어드바이스 대상 메서드 어노테이션하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로, 실행 시간을 추적할 메서드에 사용자 정의 LogTime 주석을 적용해야 합니다.\n\n```js\n@LogTime\npublic User getUserById(Long userId) {\n  Query query = Query.query(Criteria.where(\"userId\").is(userId)\n  return mongoTemplate.findOne(query, User.class);\n}\n```\n\n결과 예시 로그:\n\n<img src=\"/assets/img/2024-06-23-HandlingcrosscuttingconcernswithAOP_0.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# AOP은 필터와 어떻게 다른가요?\n\n![이미지](/assets/img/2024-06-23-HandlingcrosscuttingconcernswithAOP_1.png)\n\n# 결론\n\n마지막으로, 관점지향 프로그래밍(AOP)은 소프트웨어 개발에서 교차 관심사를 모듈화하는 강력한 패러다임을 제공합니다. AOP는 로깅, 보안, 트랜잭션 관리와 같은 관심사를 핵심 비즈니스 로직과 분리함으로써 코드의 모듈성, 재사용성, 유지보수성을 향상시킵니다. 관점, 포인트컷, 어드바이스를 사용함으로써 AOP는 개발자들이 이러한 교차 관심사를 주 응용 로직과 별도로 캡슐화할 수 있게 하며, 보다 깨끗하고 유지보수가 쉬운 코드베이스를 유도합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-HandlingcrosscuttingconcernswithAOP_0.png"},"coverImage":"/assets/img/2024-06-23-HandlingcrosscuttingconcernswithAOP_0.png","tag":["Tech"],"readingTime":14},{"title":"자바 스프링 부트에서 꼭 알아야 할 5가지 디자인 패턴 베스트 프랙티스와 예제","description":"","date":"2024-06-23 20:41","slug":"2024-06-23-Top5DesignPatternsinJavaSpringBootBestPracticesandExamples","content":"\n## 이것들은 저가 자주 사용하고 완전 사랑하는 디자인 패턴들이에요...\n\n![Top 5 Design Patterns in Java Spring Boot Best Practices and Examples](/assets/img/2024-06-23-Top5DesignPatternsinJavaSpringBootBestPracticesandExamples_0.png)\n\n10년 동안 Spring Boot와 Spring Framework 세계에 몰두한 경험이 있는 숙련된 Java 백엔드 개발자로서, 저는 견고하고 확장 가능한 응용 프로그램을 구축하는 데 디자인 패턴들이 하는 중요한 역할을 깨달았어요. 이 문서에서는 다섯 가지 핵심 디자인 패턴을 살펴보고, Spring Boot 프로젝트에서 효과적으로 적용하는 최상의 방법을 탐구할 거에요. 각 패턴은 구현을 설명하기 위해 실용적인 예제와 함께 제시될 거에요.\n\n# 싱글톤 패턴\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n싱글톤 패턴은 클래스가 하나의 인스턴스만 가지고 있도록 보장하고 전역적인 접근 점을 제공합니다. 이는 데이터베이스 연결이나 캐싱 객체와 같은 리소스를 관리하는 데 유용합니다. 스프링 부트에서 이를 구현하는 방법은 다음과 같습니다:\n\n```js\npublic class DatabaseConnection {\n    private static DatabaseConnection instance;\n\n    private DatabaseConnection() {\n        // 인스턴스화를 방지하기 위한 개인 생성자\n    }\n\n    public static synchronized DatabaseConnection getInstance() {\n        if (instance == null) {\n            instance = new DatabaseConnection();\n        }\n        return instance;\n    }\n}\n```\n\n# 팩토리 메소드 패턴\n\n팩토리 메소드 패턴은 슈퍼클래스에서 객체를 생성하는 인터페이스를 제공하여 하위 클래스가 생성될 객체의 유형을 변경할 수 있도록 합니다. 이는 객체 생성 논리를 클라이언트 코드에서 분리하는 데 유용합니다. 스프링 부트에서 예시를 살펴봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\npublic interface PaymentProcessor {\n    void processPayment();\n}\n\npublic class CreditCardProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment() {\n        // 신용카드 결제 로직 처리\n    }\n}\n\npublic class PayPalProcessor implements PaymentProcessor {\n    @Override\n    public void processPayment() {\n        // 페이팔 결제 로직 처리\n    }\n}\n\npublic interface PaymentProcessorFactory {\n    PaymentProcessor createPaymentProcessor();\n}\n\n@Component\npublic class PaymentProcessorFactoryImpl implements PaymentProcessorFactory {\n    @Override\n    public PaymentProcessor createPaymentProcessor() {\n        // 어떤 프로세서를 생성할지 결정하는 로직 (설정 등을 기반으로)\n        return new CreditCardProcessor();\n    }\n}\n```\n\n# 옵저버 패턴\n\n옵저버 패턴은 객체 간의 일대다 종속성을 정의하여 한 객체의 상태가 변경될 때 종속 객체가 자동으로 통지 및 업데이트되도록 하는 패턴입니다. 이는 주로 이벤트 기반 시스템에서 사용됩니다. Spring Boot에서 이를 구현해 봅시다:\n\n```java\nimport org.springframework.context.ApplicationEvent;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class OrderListener implements ApplicationListener<OrderEvent> {\n    @Override\n    public void onApplicationEvent(OrderEvent event) {\n        // 주문 이벤트 처리\n    }\n}\n\npublic class OrderEvent extends ApplicationEvent {\n    public OrderEvent(Object source) {\n        super(source);\n    }\n}\n\n@Component\npublic class OrderService {\n    private ApplicationEventPublisher eventPublisher;\n\n    public OrderService(ApplicationEventPublisher eventPublisher) {\n        this.eventPublisher = eventPublisher;\n    }\n\n    public void placeOrder() {\n        // 주문을 처리하는 로직\n        // 주문 이벤트 발행\n        eventPublisher.publishEvent(new OrderEvent(this));\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 데코레이터 패턴\n\n데코레이터 패턴을 사용하면 동적으로 객체에 동작을 추가할 수 있습니다. 이는 동일한 클래스의 다른 객체들의 동작에 영향을 주지 않고 기능을 추가하는 데 유용합니다. 로깅, 캐싱 또는 암호화와 같은 기능을 기존 클래스에 추가하는 데 유용합니다. Spring Boot에서 이를 구현해 봅시다:\n\n```js\npublic interface DataService {\n    void fetchData();\n}\n\n@Component\npublic class DataServiceImplementation implements DataService {\n    @Override\n    public void fetchData() {\n        // 데이터 가져오기 구현\n    }\n}\n@Component\npublic class LoggingDecorator implements DataService {\n    private DataService delegate;\n    public LoggingDecorator(DataService delegate) {\n        this.delegate = delegate;\n    }\n    @Override\n    public void fetchData() {\n        // 데이터를 가져오기 전의 로깅 로직\n        delegate.fetchData();\n        // 데이터를 가져온 후의 로깅 로직\n    }\n}\n```\n\n# 전략 패턴:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n전략 패턴은 알고리즘 패밀리를 정의하고 각각을 캡슐화하여 상호 교환할 수 있도록 만드는 것을 말합니다. 여러 알고리즘을 상호 교환할 수 있는 경우에 유용합니다. 이를 Spring Boot에 구현해 보겠습니다:\n\n```java\npublic interface CompressionStrategy {\n    void compress(String file);\n}\n\n@Component\npublic class ZipCompressionStrategy implements CompressionStrategy {\n    @Override\n    public void compress(String file) {\n        // Zip 압축 로직\n    }\n}\n\n@Component\npublic class RarCompressionStrategy implements CompressionStrategy {\n    @Override\n    public void compress(String file) {\n        // RAR 압축 로직\n    }\n}\n\n@Component\npublic class CompressionContext {\n    private CompressionStrategy strategy;\n\n    public CompressionContext(CompressionStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void setStrategy(CompressionStrategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void compressFile(String file) {\n        strategy.compress(file);\n    }\n}\n```\n\n# 결론\n\n디자인 패턴은 Java 백엔드 개발자의 장비함에 있어 필수적인 도구입니다, 특히 Spring Boot와 같은 프레임워크와 함께 작업할 때 더욱 중요합니다. 이러한 패턴을 숙달하고 프로젝트에 적절히 적용함으로써 유지보수 및 확장 가능한 코드를 이해하고 구현하는 데 도움을 받을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n커피 한 모금 마셔보세요... ☕︎☕︎☕︎\n","ogImage":{"url":"/assets/img/2024-06-23-Top5DesignPatternsinJavaSpringBootBestPracticesandExamples_0.png"},"coverImage":"/assets/img/2024-06-23-Top5DesignPatternsinJavaSpringBootBestPracticesandExamples_0.png","tag":["Tech"],"readingTime":6},{"title":"Amazon Athena와 함께하는 Spring Boot 사용법","description":"","date":"2024-06-23 20:39","slug":"2024-06-23-SpringBootwithAmazonAthena","content":"\nSpring Boot과 데이터 레이크를 통합하는 방법을 알려드릴게요. 아마존 S3 데이터에 SQL 인터페이스를 제공합니다.\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_0.png)\n\n# 소개\n\n우리는 SpringBoot 애플리케이션을 Amazon Athena와 연결하는 방법을 살펴볼 거에요. Athena가 무엇이며 어떻게 작동하는지 먼저 배운 후, Athena를 쿼리하는 SpringBoot 3 애플리케이션을 생성할 거에요. 해당 애플리케이션은 노출된 Rest API를 통해 Athena에 쿼리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 아테나 소개\n\n아마존 아테나는 다양한 소스와 형식에 저장된 데이터에 표준 SQL을 실행할 수 있는 쿼리 서비스입니다. 주로 S3와 함께 사용됩니다. 아테나는 Facebook에서 오픈 소스로 공개된 분산 SQL 엔진 Presto를 기반으로 합니다. 아테나는 서버리스이므로 설정하거나 관리할 인프라가 필요하지 않습니다.\n\n아테나는 아마존 S3에 있는 데이터를 분석하는 데 사용됩니다. 아테나는 CSV, ORC, Apache Parquet, Apache Avro, JSON과 같은 데이터 형식을 포함한 다양한 유형의 구조화 및 비구조화 데이터 유형과 작동할 수 있습니다.\n\n아마존의 Simple Storage Service인 S3는 아테나와 함께 사용하기 가장 권장되는 데이터 저장소입니다. S3는 AWS의 객체 저장 서비스로 어떤 파일 형식의 저렴한 저장을 제공합니다. S3는 버킷 내의 객체로 데이터를 저장합니다. 객체는 파일과 파일을 설명하는 메타데이터를 포함합니다. 버킷은 객체를 위한 컨테이너입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAmazon S3에 데이터를 저장하려면 먼저 버킷을 생성하고 버킷 이름과 AWS 지역을 지정해야 합니다. 그런 다음 해당 버킷에 데이터를 Amazon S3의 객체로 업로드합니다. 각 객체는 버킷 내에서의 객체를 식별하는 고유 키(또는 키 이름)를 가지고 있습니다.\n\n# 데이터 다운로드\n\n저희 데이터는 전 세계 도시 인구에 대한 무료 버전 데이터 입니다. 다음 링크에서 액세스할 수 있습니다: [https://simplemaps.com/data/world-cities](https://simplemaps.com/data/world-cities). 원본 데이터 세트에는 몇 가지 조작이 필요했는데, 예를 들어 따옴표 제거와 같은 조작이 있었으며, 따라서 소스 코드에 포함된 클린한 버전이 제공되며 다음 링크를 통해 다운로드 받을 수 있습니다. 이 데이터에는 다음 스키마가 있습니다.\n\n```js\n도시, 도시_ascii, 위도, 경도, 국가, iso2, iso3, 관리 이름, 수도, 인구, id\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그리고 몇 줄의 샘플이 이렇게 보입니다.\n\n```js\nTokyo,Tokyo,35.6839,139.7744,Japan,JP,JPN,Tōkyō,primary,39105000,1392685764\nJakarta,Jakarta,-6.2146,106.8451,Indonesia,ID,IDN,Jakarta,primary,35362000,1360771077\nDelhi,Delhi,28.6667,77.2167,India,IN,IND,Delhi,admin,31870000,1356872604\nManila,Manila,14.6,120.9833,Philippines,PH,PHL,Manila,primary,23971000,1608618140\nSão Paulo,Sao Paulo,-23.5504,-46.6339,Brazil,BR,BRA,São Paulo,admin,22495000,1076532519\n```\n\n다운로드한 파일의 위치를 주의해주세요. 곧 접근할 것입니다.\n\n# S3 준비\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로는 데이터를 저장하는 데 사용할 S3 버킷을 생성해야 합니다. 이는 고유한 이름이어야 합니다. 제가 사용한 이름은 world-cities-athena 입니다. 상호적으로 따라오는 경우 다른 고유한 이름을 사용해야 합니다.\n\nAmazon S3 - Buckets - Create bucket 페이지로 이동하여 다음을 입력하고, 버킷 이름으로 교체하세요.\n\n이미지 src=\"/assets/img/2024-06-23-SpringBootwithAmazonAthena_1.png\" />\n\n나머지 설정은 기본값으로 선택하고, 하단의 \"버킷 생성\" 버튼을 눌러주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 새 버킷을 선택하고 \"폴더 생성\" 버튼을 사용하여 input 및 queries라는 두 개의 폴더를 만들어주세요.\n\n<img src=\"/assets/img/2024-06-23-SpringBootwithAmazonAthena_2.png\" />\n\n폴더를 만들면 위의 이미지와 같이 구성이 되어야 해요.\n\n마지막으로, input 폴더를 클릭하고 \"업로드\"를 선택하여 이전 섹션에서 다운로드한 데이터 세트를 업로드해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_3.png)\n\n이렇게 완료되면 위와 같이 나타날 것입니다.\n\n마지막 단계는 쿼리 결과를 저장할 버킷을 생성하는 것입니다. 이 버킷은 우리가 Athena를 쿼리할 때 포함되며 각 쿼리의 결과가 해당 버킷에 저장됩니다. 그러면 쿼리를 다시 실행하지 않고 결과에 액세스할 수 있으며 비용이 발생하지 않습니다. 그러나 S3에 결과 파일의 저장 비용은 사용자가 책임져야 합니다. 버킷을 생성하려면 다시 Amazon S3 - `Buckets -` Create bucket 페이지로 이동하고 버킷 이름을 world-cities-results로 입력하십시오.\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다시 모든 기본 값으로 유지하고 아래에 있는 버킷 생성 버튼을 선택하세요.\n\n이제 S3를 구성하고, 다음 단계로 넘어가서 Athena 데이터베이스와 테이블을 설정할 준비가 되었습니다.\n\n# Athena 구성\n\nAthena 데이터베이스를 구성하기 위한 몇 가지 단계가 있습니다. 이 모든 작업은 Athena AWS 콘솔 내에서 수행됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![SpringBootwithAmazonAthena_5](/assets/img/2024-06-23-SpringBootwithAmazonAthena_5.png)\n\nNote that the interface changed somewhat recently and what you select is the line stating “Query your data with Trino SQL”, Trino being a fork of the SQL Query Engine.\n\nOnce you select Launch query editor then you will see this screen.\n\n![SpringBootwithAmazonAthena_6](/assets/img/2024-06-23-SpringBootwithAmazonAthena_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n오른쪽에 있는 쿼리 창을 사용하여 Athena와 상호 작용할 수 있습니다. 이 방법을 사용하겠습니다. 객체를 수동으로 정의하는 마법사 형식의 테이블 생성 방법도 있습니다.\n\n먼저 데이터베이스를 생성하겠습니다. 데이터베이스는 처음에 기본값으로 설정되어 있고 우리만의 특정 데이터베이스를 생성하려고 합니다.\n\n쿼리 창에 다음을 입력하세요.\n\n```js\ncreate database worldcitiesdb\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음과 같이 됩니다.\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_7.png)\n\n그런 다음 **실행**을 누르세요.\n\n그럼 왼쪽 데이터 창의 Database 드롭다운에서 새 데이터베이스를 선택할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n현재 시점에서는 새로운 데이터베이스에 테이블이 없는 상태일 것입니다.\n\n테이블을 생성하려면 쿼리를 사용하여 데이터 파일을 가리키고 동시에 데이터로 테이블을 생성하고 채울 것입니다.\n\n오른쪽 쿼리 창에 다음 SQL을 입력하세요.\n\n```js\nCREATE EXTERNAL TABLE IF NOT EXISTS `worldcitiesdb`.`worldcities` (\n `city` string,\n `city_ascii` string,\n `lat` double,\n `lng` double,\n `country` string,\n `iso2` string,\n `iso3` string,\n `admin_name` string,\n `capital` string,\n `population` int,\n `id` int\n)\nROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe'\nWITH SERDEPROPERTIES (\n 'serialization.format' = ',',\n 'field.delim' = ','\n)\nLOCATION 's3://world-cities-athena/input/'\nTBLPROPERTIES ('skip.header.line.count' = '1')\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 create 문에서 특히 이 줄에 주목해주세요.\n\n```js\nLOCATION 's3://world-cities-athena/input/'\n```\n\n이 줄을 여러분의 버킷 이름으로 교체해야 하지만, 그 외에는 수정하지 말아야 합니다.\n\n쿼리에서 world-cities-athena를 여러분의 버킷으로 교체하신 후 Run을 눌러주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n한 두 번 실행한 후 녹색 성공 메시지가 표시됩니다. 그러면 새 테이블이 Athena에서 왼쪽 데이터 창에 표시됩니다.\n\n![Spring Boot with Amazon Athena](/assets/img/2024-06-23-SpringBootwithAmazonAthena_8.png)\n\n쿼리 창에 테스트 쿼리를 입력하고 실행하여 테스트할 수 있습니다.\n\n```js\nselect * from worldcities limit 50\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 데이터베이스 및 테이블이 있는지 확인하고 쿼리할 수 있다는 것을 확인합니다.\n\n![image](/assets/img/2024-06-23-SpringBootwithAmazonAthena_9.png)\n\nAthena 데이터베이스가 올바르게 설정되었습니다.\n\n# 코드 워크스루\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사의 코드는 제 Github에서 찾을 수 있습니다. 코드와 함께 다양한 SQL 문도 포함되어 있어요.\n\nAthena가 설정되었다면, 다음 단계는 REST API를 통해 노출할 SpringBoot 애플리케이션을 구현하는 것입니다. S3 기반 Athena 데이터베이스를 삭제하거나 업데이트할 수 없지만, 쿼리를 사용하여 테이블에 추가하거나 쿼리를 실행할 수 있어요.\n\n우리 경우 이전 섹션에서 만든 테이블을 쿼리할 수 있는 두 개의 REST 엔드포인트를 생성할 거에요. 첫 번째 엔드포인트는 국가별로 가져오고, 두 번째 엔드포인트는 국가 코드가 필요합니다. 둘 다 인구순으로 레코드를 표시하며, 가장 큰 값부터 (내림차순) 나타날 거에요.\n\n시작하기 전에 아래에 표시된 Spring Initializr에서 기본 종속성 집합을 가진 SpringBoot 애플리케이션을 생성할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-23-SpringBootwithAmazonAthena_10.png\" />\n\n여기서는 아테나와 작업하기 위해 필요한 라이브러리를 추가해야 합니다. 이를 위해 Java AWS SDK를 사용할 것입니다. 아래 종속성을 추가하여 이를 활성화하세요.\n\n```js\n<dependency>\n   <groupId>software.amazon.awssdk</groupId>\n   <artifactId>auth</artifactId>\n   <version>2.22.9</version>\n</dependency>\n<dependency>\n   <groupId>software.amazon.awssdk</groupId>\n   <artifactId>athena</artifactId>\n   <version>2.22.9</version>\n</dependency>\n<dependency>\n   <groupId>com.amazonaws</groupId>\n   <artifactId>aws-java-sdk</artifactId>\n   <version>1.12.636</version>\n</dependency>\n```\n\n위의 종속성들은 구현에 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 전체 pom.xml을 확인할 수 있습니다.\n\n## 응용 프로그램 구성\n\n응용 프로그램 구성에는 athena에 액세스하기 위해 필요한 모든 정보가 포함됩니다.\n\n```java\n@Data\n@Component\n@ConfigurationProperties(prefix = \"athena\")\npublic class AppConfiguration {\n    private String region;\n    private String workGroup;\n    private String catalog;\n    private String database;\n    private String resultsBucket;\n    private int clientExecutionTimeout;\n    private int limit;\n    private int retrySleep;\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱리케이션.yml의 해당 섹션은 아래와 같이 표시됩니다.\n\nathena:\nregion: us-east-1\nworkgroup: primary\ncatalog: AwsDataCatalog\ndatabase: worldcitiesdb\nlimit: 25\nclient-execution-timeout: 100000\nretry-sleep: 1000 # 1초\nresults-bucket: s3://world-cities-results\n\n## Athena 레이어\n\n다음으로 Athena 클라이언트를 생성하고 쿼리를 실행하는 접근 논리를 구현해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 Athena 클라이언트를 생성하는 것이 중요합니다. 아래 제공된 코드대로 작업이 진행됩니다.\n\n```js\n@Component\npublic class AthenaClientFactory {\n\n    public AthenaClient createAthenaClient() {\n        return AthenaClient.builder()\n            .credentialsProvider(DefaultCredentialsProvider.create())\n            //.credentialsProvider(EnvironmentVariableCredentialsProvider.create()) // use if creds are\n                                                                                    // env vars\n            .build();\n    }\n}\n```\n\n이 코드는 ~/.aws/credentials 파일에서 액세스 및 시크릿을 로딩하는 과정입니다. 하지만 환경 변수를 사용하고 싶다면 EnvironmentVariableCredentialsProvider를 사용할 수도 있습니다.\n\n이 작업은 software.amazon.awssdk.services.athena.AthenaClient 클래스의 인스턴스를 생성합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 필요한 구성 요소는 쿼리 시작 및 완료입니다. 이것은 두 단계 프로세스입니다.\n\n- 쿼리를 실행하면 시스템에 의해 쿼리 ID가 생성됩니다.\n- 위의 쿼리 ID는 쿼리 완료 상태를 확인하기 위해 성공 또는 실패 여부를 묻는 루프에서 사용됩니다.\n\n아래에 코드가 표시되어 있습니다. 코드에 대한 설명은 코드 뒷부분에 이어집니다.\n\n```js\n@Slf4j\n@Component\npublic class AthenaQuery {\n\n    private final AppConfiguration appConfiguration;\n\n    @Autowired\n    public AthenaQuery(AppConfiguration appConfiguration) {\n        this.appConfiguration = appConfiguration;\n    }\n\n    public String createAthenaQuery(AthenaClient athenaClient, String query) {\n\n        try {\n            QueryExecutionContext queryExecutionContext = QueryExecutionContext.builder()\n                .database(appConfiguration.getDatabase())\n                .build();\n\n            ResultConfiguration resultConfiguration = ResultConfiguration.builder()\n                .outputLocation(appConfiguration.getResultsBucket())\n                .build();\n\n            StartQueryExecutionRequest startQueryExecutionRequest = StartQueryExecutionRequest.builder()\n                .queryString(query)\n                .queryExecutionContext(queryExecutionContext)\n                .resultConfiguration(resultConfiguration)\n                .build();\n\n            StartQueryExecutionResponse startQueryExecutionResponse = athenaClient.startQueryExecution(startQueryExecutionRequest);\n            return startQueryExecutionResponse.queryExecutionId();\n        } catch (AthenaException e) {\n            log.error(\"Error during query execution\", e);\n        }\n        return \"\";\n    }\n\n    public void completeAthenaQuery(AthenaClient athenaClient, String queryExecutionId) {\n\n        GetQueryExecutionRequest getQueryExecutionRequest = GetQueryExecutionRequest.builder()\n            .queryExecutionId(queryExecutionId).build();\n\n        GetQueryExecutionResponse getQueryExecutionResponse;\n        boolean isStillRunning = true;\n        while (isStillRunning) {\n            getQueryExecutionResponse = athenaClient.getQueryExecution(getQueryExecutionRequest);\n            String queryState = getQueryExecutionResponse.queryExecution().status().state().toString();\n            if (queryState.equals(QueryExecutionState.FAILED.toString())) {\n                throw new RuntimeException(\"The Amazon Athena query failed to run with error message: \" + getQueryExecutionResponse\n                    .queryExecution().status().stateChangeReason());\n            } else if (queryState.equals(QueryExecutionState.CANCELLED.toString())) {\n                throw new RuntimeException(\"The Amazon Athena query was cancelled.\");\n            } else if (queryState.equals(QueryExecutionState.SUCCEEDED.toString())) {\n                isStillRunning = false;\n            } else {\n                try {\n                    Thread.sleep(appConfiguration.getRetrySleep());\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            log.debug(\"The current status is: \" + queryState);\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n쿼리는 createAthenaQuery 메서드로 시작됩니다. 이는 데이터베이스와 결과 버킷을 가진 쿼리 컨텍스트를 생성한 다음 쿼리를 Athena에 제출하여 수행됩니다. 성공적으로 실행된 경우 UUID 형식의 쿼리 실행 ID가 반환되며, 그렇지 않으면 빈 문자열이 반환됩니다.\n\ncompleteAthenaQuery 메서드에서는 쿼리가 성공적으로 완료되거나 쿼리가 실패하거나 취소(시간 초과) 될 때까지 루프를 사용합니다. 이는 결과가 준비될 때까지 실행 경로를 차단하기 위한 것입니다.\n\n## DTO 레이어\n\n이는 쿼리에서 가져온 필드와 일치하는 간단한 레코드입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\ndata class TopTenCities(val name: String, val population: Int)\n```\n\n자바 레코드의 사용으로 이것은 간단한 한 줄짜리 문장이 됩니다. 레코드 클래스를 사용하면 getter 및 동등성 비교 기능이 있는 변경 불가능한 POJO를 얻을 수 있습니다.\n\n## 서비스\n\n구현 내에서 서비스는 모든 것을 연결합니다. 이는 이전에 살펴본 Athena 클래스를 사용하여 Athena에서 데이터를 검색하고, 그런 다음 위의 POJO TopTenCities로 매핑합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n@Service\n@AllArgsConstructor\n@Slf4j\npublic class AthenaService {\n\n    private static final String QUERY_ALL = \"SELECT city, population FROM worldcities \" +\n        \"ORDER BY population DESC LIMIT {limit}\";\n\n    private static final String QUERY = \"SELECT city, population FROM worldcities where iso2 = '{country}' \" +\n        \"ORDER BY population DESC LIMIT {limit}\";\n\n    private final AthenaClientFactory athenaClientFactory;\n\n    private final AthenaQuery athenaQuery;\n\n    public List<TopTenCities> getTop10All(Integer limit) {\n        return run(\"\", limit, QUERY_ALL);\n    }\n\n    public List<TopTenCities> getTop10(String country, Integer limit) {\n        return run(country, limit, QUERY);\n    }\n\n    public List<TopTenCities> run(String country, Integer limit, String query) {\n\n        AthenaClient athenaClient = athenaClientFactory.createAthenaClient();\n\n        String finalQuery = query.replace(\"{country}\", country)\n            .replace(\"{limit}\", String.valueOf(limit));\n        String queryExecutionId = athenaQuery.createAthenaQuery(athenaClient,\n            finalQuery);\n\n        if (!queryExecutionId.isEmpty()) {\n            log.info(\"Query submitted with query id {} and current mills {}\", queryExecutionId, System.currentTimeMillis());\n\n            athenaQuery.completeAthenaQuery(athenaClient, queryExecutionId);\n\n            log.info(\"Query finished at {}\", System.currentTimeMillis());\n\n            return processResultRows(athenaClient, queryExecutionId);\n        } else {\n            log.error(\"Issue while running the query \" + finalQuery);\n            return new ArrayList<>(); // return empty array\n        }\n    }\n\n    private List<TopTenCities> processResultRows(AthenaClient athenaClient, String queryExecutionId) {\n\n        List<TopTenCities> result = new ArrayList<>();\n        GetQueryResultsRequest getQueryResultsRequest = GetQueryResultsRequest.builder()\n            .queryExecutionId(queryExecutionId).build();\n\n        GetQueryResultsIterable getQueryResultsResults = athenaClient.getQueryResultsPaginator(getQueryResultsRequest);\n\n        for (GetQueryResultsResponse Resultresponse : getQueryResultsResults) {\n            List<ColumnInfo> columnInfoList = Resultresponse.resultSet().resultSetMetadata().columnInfo();\n\n            int resultSize = Resultresponse.resultSet().rows().size();\n            log.info(\"Result size: \" + resultSize);\n\n            List<Row> results = Resultresponse.resultSet().rows();\n            result = processRow(results, columnInfoList);\n        }\n        return result;\n    }\n\n    private List<TopTenCities> processRow(List<Row> rowList, List<ColumnInfo> columnInfoList) {\n\n        List<String> columns = new ArrayList<>();\n        List<TopTenCities> result = new ArrayList<>();\n\n        for (ColumnInfo columnInfo : columnInfoList) {\n            columns.add(columnInfo.name());\n        }\n\n        int rowCtr = 0;\n        for (Row row : rowList) {\n            int index = 0;\n\n            // simple mapping logic for the POJO\n            String name = \"\";\n            String population = \"\";\n\n            for (Datum datum : row.data()) {\n                log.debug(columns.get(index) + \": \" + datum.varCharValue());\n                // skip row header row\n                if (rowCtr > 0) {\n                    if (index == 0) {\n                        name = datum.varCharValue();\n                    } else {\n                        population = datum.varCharValue();\n                    }\n                }\n                index++;\n            }\n            rowCtr++;\n            if (!name.isEmpty()) {\n                var topTenCities = new TopTenCities(name, Integer.valueOf(population));\n                result.add(topTenCities);\n            }\n            log.debug(\"===================================\");\n        }\n        return result;\n    }\n}\n```\n\n이제 각 부분을 확인하면서 구현 내용을 이해하겠습니다. run 메서드는 주요 기능을 담당합니다. 여기서 SQL 쿼리 생성이 이루어지고, Athena 처리 레이어에서 이전에 살펴본 createAthenaQuery 및 completeAthenaQuery 메서드가 호출됩니다. 전자는 쿼리를 초기화하고 제출하며, 후자는 처리를 계속하기 전에 완료될 때까지 대기합니다.\n\nAthenaService의 processResultRows 메서드에서 GetQueryResultsRequest 클래스를 사용하여 쿼리 결과를 검색합니다. 이는 전체 결과를 반환하고, processRows가 각 행을 하나씩 처리하고 Java 개체로 매핑하는 데 사용됩니다.\n\n## Rest API\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로 살펴볼 부분은 API 레벨입니다. 여기에서 컨트롤러를 구현합니다.\n\n```js\n@RestController\n@RequestMapping(value = \"/cities\", produces = APPLICATION_JSON_VALUE)\n@AllArgsConstructor\npublic class ApiController {\n\n    private final AthenaService athenaService;\n\n    @GetMapping(value = {\"\", \"/\"})\n    public ResponseEntity<List<TopTenCities>> getTop10All(@RequestParam(defaultValue = \"10\") Integer limit) {\n\n        List<TopTenCities> result = athenaService.getTop10All(limit);\n        return ResponseEntity.accepted().body(result);\n    }\n\n    @GetMapping(value = {\"/{country}\"})\n    public ResponseEntity<List<TopTenCities>> getTop10(@PathVariable(\"country\") String country,\n                                                       @RequestParam(defaultValue = \"10\") Integer limit) {\n\n        List<TopTenCities> result = athenaService.getTop10(country, limit);\n        return ResponseEntity.accepted().body(result);\n    }\n}\n```\n\n여기에 두 개의 엔드포인트가 선언되어 있습니다. 하나는 (GET) /cities 이고 다른 하나는 (GET) /cities/'country' 입니다. 두 엔드포인트 모두 선택적으로 쿼리 파라미터를 받아들이며, 반환할 값의 수를 설정할 수 있습니다. 기본값은 10입니다.\n\n# 테스팅\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 명령어로 애플리케이션을 시작하여 테스트해보세요.\n\n```js\njava -jar target/athena-sample-0.0.1-SNAPSHOT.jar\n```\n\n이렇게 하면 애플리케이션이 실행됩니다. 브라우저 URL에 다음을 입력하여 실행 여부를 확인할 수 있습니다.\n\n```js\nhttp://localhost:8080/api/actuator\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 URL을 브라우저에 입력하면 모든 국가의 인구 순으로 상위 열 개의 도시가 반환됩니다.\n\nhttp://localhost:8080/api/cities\n\n다음과 같이 표시됩니다.\n\n![이미지](/assets/img/2024-06-23-SpringBootwithAmazonAthena_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 코드도 시도해 볼 수 있어요.\n\n```js\nhttp://localhost:8080/api/cities/US?limit=15\n```\n\n이렇게 하면 미국 내 인구 순으로 상위 15개의 도시 정보를 받아볼 수 있어요. DE, BR, CA와 같은 다른 국가 코드로도 시도해 보세요.\n\n우리는 SpringBoot 애플리케이션을 통해 Athena를 쿼리할 수 있음을 보여줬고, 이를 REST API를 통해 모두 연결했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 자료\n\n- Amazon Athena를 활용한 서버리스 분석 — Packt Publishing — Anthony Virtuoso, Mert Turkay Hocanin, Aaron Wishnick\n\n# 요약\n\n오늘은 SpringBoot 애플리케이션에서 Athena로 인터페이스를 만드는 방법을 살펴보았습니다. 우리는 Athena에 대한 배경 정보부터 시작했습니다. 그 후에 CSV 파일을 Athena로 로드하고 사용 가능하게 만드는 방법을 살펴보았습니다. 다음으로 SpringBoot 애플리케이션과 Athena를 연결하고 쿼리하는 방법을 살펴보았습니다. 이러한 클래스들은 여러분의 애플리케이션에 기초를 제공할 수 있습니다. 마지막으로 우리는 테스트를 해보았습니다. 함께 이 여정을 함께해줘서 감사합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글의 코드는 제 Github에서 찾아볼 수 있어요.\n\n즐거운 여정되세요!\n","ogImage":{"url":"/assets/img/2024-06-23-SpringBootwithAmazonAthena_0.png"},"coverImage":"/assets/img/2024-06-23-SpringBootwithAmazonAthena_0.png","tag":["Tech"],"readingTime":26},{"title":"엔지니어를 위한 Redis 클러스터 업그레이드 마스터하기 무중단 전환 가이드","description":"","date":"2024-06-23 20:36","slug":"2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition","content":"\n# 소개\n\nAWS ElastiCache에서 Redis 클러스터를 업그레이드하는 것은 지속적인 성능과 보안을 보장하기 위해 꼼꼼한 계획과 실행이 필요한 중요한 작업입니다. 여러 번의 Redis 업그레이드를 직접 이끈 경험을 통해 해당 블로그 게시물에서 과정을 반복 가능한 일련의 단계로 정리했습니다. Redis 클러스터 업그레이드의 복잡성에 대해 자세히 살펴보며, 최선의 사례, 세부적인 전개 전략, 그리고 필수적인 롤백 계획에 대해 다룰 것입니다.\n\n이 과정은 준비 단계, 전개 단계 및 전개 후 단계로 자연스럽게 나눌 수 있습니다.\n\n# 준비 단계\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 부분은 아마도 가장 많은 시간을 소비하지만 매우 중요한 단계로 볼 수 있습니다. 주요 고려 사항은 다음과 같습니다:\n\n# 1. 호환성 매트릭스\n\nRedis 및 선택한 클라이언트 라이브러리(예: Java용 Jedis)에서 제공한 호환성 매트릭스를 철저히 검토해보세요. 이 매트릭스는 버전 간의 잠재적인 호환성 문제를 강조해줍니다.\n\n![MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0](/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRedis 자체의 릴리스 노트 및 클라우드 제공 업체 문서(예: AWS 문서)를 면밀히 살펴보세요. 이를 통해 새로운 기능, 버그 수정, 사용 중단 예정 기능 및 패치 베이스가 있는 변경 사항을 알 수 있습니다.\n\n## 2. 릴리스 노트\n\nRedis 및 클라이언트 라이브러리의 릴리스 노트를 주의 깊게 읽는 것이 매우 중요합니다. 이는 새로운 기능, 버그 수정, 사용 중단 예정 기능 및 변경 사항에 대한 중요한 정보를 제공합니다. 이러한 릴리스 노트는 Redis 문서에서 찾을 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n모든 Redis 호환 서비스를 제공하는 클라우드 제공업체는 변경 사항을 요약하여 제공합니다. 예를 들어 AWS 문서는 데이터베이스 엔진에 대한 중요한 변경 사항을 잘 요약합니다.\n\n# 3. 스테이징 환경에서 테스트\n\n프로덕션 설정과 유사한 스테이징 환경을 만듭니다. 다음을 포함합니다:\n\n- 인스턴스 유형 및 크기: 프로덕션과 동일한 AWS 인스턴스 유형 및 크기 사용.\n- 네트워크 구성: VPC, 서브넷 및 보안 그룹 설정을 미러링.\n- 데이터 양: 동일한 양의 데이터로 스테이징 환경을 채웁니다. 이것은 실제 업그레이드를 시작하기 전에 데이터 백업을 수행하는 데 걸리는 시간을 이해하는 데 매우 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n스테이징 환경이 생성되면 새로운 Redis 버전과 함께 애플리케이션을 테스트하기 시작하는 시간입니다. 테스트는 다음 세 가지 하위 섹션으로 나눌 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_2.png)\n\n- 기능 테스트\n  새 버전과 완벽하게 작동하는지 확인합니다. 애플리케이션 코드베이스에 있는 모든 Redis 명령이 호환되는지 확인해야 합니다.\n  Lua 스크립트가 있는 경우 모든 사용자 정의 스크립트가 올바르게 실행되는지 확인하는 것이 중요합니다.\n- 성능 테스트\n  Redis는 일반적으로 지연 시간이 민감한 중요한 응용 프로그램에서 사용됩니다. 따라서 Gatling이나 Apache JMeter와 같은 부하 테스트 도구를 사용하여 업그레이드된 Redis 클러스터의 성능을 측정하는 것이 중요합니다.\n  Redis 엔진 업그레이드 중에는 더 높은 성능을 제공하는 경우가 있습니다. 이를 확인하기 위해 철저한 부하 테스트를 수행할 수 있습니다. 또한 클라이언트 라이브러리 설정을 조정하여 더 나은 성능을 얻을 수 있습니다.\n- 신뢰성 테스트\n  신뢰성 테스트는 제품 환경에 영향을 미치기 전에 잠재적인 문제를 발견하기 위한 것입니다. 장애 및 스트레스 시나리오를 시뮬레이션하여 업그레이드된 Redis 클러스터가 실제 환경에서 직면할 도전에 견딜 수 있는지 확인할 수 있습니다.\n  애플리케이션의 Redis 클라이언트가 노드 장애, 네트워크 중단 및 클러스터 재구성을 처리하는 방식을 테스트합니다. 이러한 클라이언트가 신속하게 새로운 노드에 연결하고 데이터 불일치를 우아하게 처리하는지 확인합니다.\n\nRedis 클라이언트 라이브러리는 노드 IP를 캐시합니다. 다중 샤딩 및 다중 노드 Redis 클러스터에서는 클라이언트 라이브러리에서 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 클라이언트 라이브러리에서 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운 노드에 빨리 연결할 수 있도록 새로 고치고 새로운\\_IWPAৰ새로 운용할 수 있도록 해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 4. 위험한 명령어 비활성화\n\n대부분의 경우, CPU가 Redis에서 병목 현상을 일으킵니다. 따라서 이러한 블로킹 명령어의 사용을 비활성화하거나 제한하는 것이 중요합니다. 여기에는 두 가지 범주가 있습니다.\n\n- 블로킹 명령어 — KEYS\\* , 대량 데이터 세트에서의 SORT 등\n- 비용이 많이 드는 명령어 — HGETALL , 범위가 큰 ZRANGE\n\nRedis는 명령어 이름을 변경하는 기능을 제공하며, FLUSHALL과 같은 명령어를 \\_DO_NOT_USE_FLUSHALL과 같이 애매한 이름으로 변경할 수 있습니다. ElastiCache를 사용하면 명령어 동작에 영향을 미치는 매개변수를 수정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, 고가의 명령을 실행할 수 있는 느린 클라이언트를 자동으로 연결 해제하는 타임아웃 설정을 조정할 수 있습니다.\n\n## 5. 모니터링 및 로깅\n\n### 가. 향상된 모니터링\n\n중요한 메트릭인 CPU 사용량, 메모리 사용량 및 네트워크 처리량과 같은 주요 메트릭을 추적하기 위해 향상된 모니터링을 활성화하세요. AWS Elasticache는 Redis 클러스터에 대해 약 40여 가지 메트릭을 제공하며, 이러한 메트릭은 클러스터의 전반적인 상태를 파악하는 데 도움을 줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## b. 로깅 및 알림\n\nRedis 명령에 대한 로깅을 설정하고 중요 지표에 대한 알림을 구성하십시오. 이는 문제를 신속히 식별하고 진단하는 데 도움이 됩니다.\n\n업그레이드 단계에서는 Engine Logs와 Slow Logs를 활성화하고 이러한 로그 위에 경고를 설정하는 것이 중요합니다.\n\n# 롤아웃 단계\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n항목을 준비해 둔 후, 상세한 전개 계획을 작성하는 시간이에요. 서비스가 적거나 없는 시간대에 일정을 잡아 방해를 최소화 해보세요. 중요한 애플리케이션의 경우, 업그레이드 창을 신중하게 선택해야 해요. 왜냐하면 업그레이드를 위한 데이터 백업 과정은 상당한 Redis CPU 자원을 소비할 수 있기 때문이죠.\n\n꼭 기억해야 할 몇 가지 포인트가 있어요 —\n\n- 전체 백업: 시작하기 전에 Redis 클러스터 데이터의 전체 백업을 만들어 보세요. 스냅샷이나 선택한 지속성 메커니즘을 사용해보세요. 백업 및 복원 시간을 제품 환경에서 측정하여 업그레이드 창에 미치는 전반적인 영향을 이해하세요.\n- 데이터 일관성 확인: 백업 이후, 기본 및 레플리카 노드 간에 데이터 크기 및 키/값 쌍이 일치하는지 확인해보세요. 이 단계는 진행하기 전에 데이터 무결성을 보장하기 위해 중요해요.\n- 문서 버전: 철저한 롤백 절차를 문서화해보세요. 이에는 백업에서 복원 및 이전 버전에서 클러스터 다시 시작에 대한 상세 단계가 포함돼야 해요. 롤백을 예상대로 작동하는지 확인하기 위해 롤백의 시뮬레이션을 진행하세요.\n- 클라이언트 연결: 애플리케이션 팟이 새 Redis 클러스터에 연결할 수 있는지 확인해보세요. 클라이언트 라이브러리가 DNS 항목을 캐시하는 경우, 최신 연결 정보를 얻기 위해 Refresh Rate를 줄이거나 팟의 Rolling Restart를 실행해야 할 수도 있어요.\n- Thundering Herd 완화: Redis가 데이터베이스의 캐시 역할을 한다면, 캐시가 무효화되거나 실패할 경우 \"Thundering Herd\" 효과에 대비해야 해요. 이는 데이터베이스를 압도할 수 있어요. 데이터베이스 용량을 평가하고, 부담이 더 큰 작업을 처리할 수 있도록 필요에 따라 확장을 고려하세요.\n- 단계별 업그레이드: 새 버전의 안정성을 테스트하기 위해 중요하지 않은 노드(예: 읽기 레플리카)부터 업그레이드를 시작해보세요. 모든 것이 순조롭게 진행되면, 점진적으로 나머지 노드를 업그레이드하면서 프로세스 전반에 걸쳐 애플리케이션이 계속 작동하는지 확인하세요.\n- 커뮤니케이션: 유지보수 창에 대해 모든 이해당사자 및 애플리케이션/서비스 이용자에게 알리세요. 이를 통해 다른 팀이 즉각적으로 발생한 문제나 비정상적인 현상을 보고할 수 있게 돕습니다.\n\n전개 자체에는 여러 가지 방식이 있을 수 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 노드별 업그레이드: 중요한 애플리케이션의 경우, 시간이 오래 걸리지만 빠른 문제 감지가 가능한 한 번에 한 노드씩 업그레이드하는 방법이 있습니다.\n- 클러스터 재생성 (AWS ElastiCache): AWS 및 다른 클라우드 공급업체는 종종 클러스터 재생성 전략을 사용합니다. 이는 이전 클러스터의 스냅샷을 새 버전이 적용된 새 클러스터에 적용하고 데이터 동기화를 보장한 다음 DNS를 새 클러스터로 전환하는 과정을 포함합니다.\n\n## 중요 사항:\n\n전략의 선택은 특정 요구 사항, 리스크 허용 수준 및 애플리케이션의 성격에 따라 다릅니다.\n\n# 롤아웃 후 단계\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n롤아웃 후기 단계는 주로 모니터링과 문서화에 초점을 맞추며, 업그레이드된 Redis 클러스터의 안정성과 성능을 보장합니다. 클러스터를 단계별로 업그레이드한 후(먼저 읽기 레플리카, 그 다음 비중요 샤드, 마지막으로 주 노드) 다음 단계가 중요합니다:\n\n- 지속적인 모니터링\n  업그레이드된 클러스터를 긴 기간 동안 높은 수준으로 모니터링하여 예기치 못한 문제를 신속하게 감지하고 해결하세요. 이전 Redis 클러스터에서 역사적인 메트릭을 내보내고 저장하는 것을 강력히 권장합니다. 이를 통해 현재 성능을 이전 기준선(예: 1개월, 3개월 전)과 비교함으로써 이상 징후를 탐지할 수 있습니다.\n- 문서화\n  철저한 문서화가 중요합니다. 업그레이드 과정 전체를 기록하고 타임라인, 수행된 구체적인 단계, 그리고 마주친 어려움을 기록하세요. 이 문서화는 미래 업그레이드에 대한 소중한 참고 자료가 되며, 데이터 백업 기간, 동기화 프로세스, 그리고 현재 데이터 양과 관련된 기타 주요 메트릭에 대한 통찰을 제공합니다.\n\n# 결론\n\nRedis 클러스터를 업그레이드하는 것은 원활한 전환과 응용 프로그램의 안정성과 성능을 유지하기 위해 구조화된 방식이 요구됩니다. 이 글에서 제안된 전략과 모범 사례를 따르면, 위험을 크게 줄이고 새로운 Redis 기능 및 향상 사항을 성공적으로 통합할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여러 번의 Redis 업그레이드 경험과 통찰을 공유했지만, 언제나 더 배우고 싶습니다. 추가 팁, 제안 또는 실제 예시가 있으시면 아래 댓글을 남겨주세요. 여러분의 피드백은 우리 모두가 Redis 업그레이드 프로세스를 더 견고하게 만들고 발전시키는 데 도움이 될 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png"},"coverImage":"/assets/img/2024-06-23-MasteringRedisClusterUpgradesAnEngineersGuidetoaSeamlessTransition_0.png","tag":["Tech"],"readingTime":9}],"page":"21","totalPageCount":119,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}