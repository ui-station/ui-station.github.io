{"pageProps":{"post":{"title":"iOS 앱에서 코디네이터 패턴 사용하는 방법","description":"","date":"2024-06-22 23:06","slug":"2024-06-22-CoordinatorPatterniniOSApp","content":"\n# 코디네이터란 무엇인가요?\n\niOS 개발에서 코디네이터는 앱의 탐색 흐름을 처리하는 객체입니다. 때로는 \"플로우 컨트롤러\" 또는 \"라우터\"라고도 합니다.\n\n코디네이터는 뷰 컨트롤러가 어떻게 표시되고, 푸시되며 해제되는지, 앱의 다른 섹션 및 뷰가 어떻게 연결되는지에 대한 로직을 처리합니다.\n\n코디네이터는 보통 정의하는 클래스이며, 뷰 컨트롤러를 생성, 표시, 해제할 수 있는 메서드와 함께 정의됩니다. 앱의 흐름이 복잡한 경우에는 다른 코디네이터와 필요한 경우 통신할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# MVVM+C 패턴이란 무엇인가요?\n\n일반적인 iOS 개발(예: MVC 패턴)에서는 일반적으로 네비게이션의 책임이 뷰 컨트롤러에게 주어집니다. 그러나 더 복잡한 플로우(예: 뷰 컨트롤러 간의 강한 결합, 코드 재사용성의 부족 및 테스트 문제 등)에서 많은 문제가 발생할 수 있습니다.\n\nMVVM+C(가끔 \"Coordinator 패턴\"이라고도 부릅니다)은 앱 내에서 책임을 분리하는 것을 촉진하는 디자인 패턴입니다. 특히 네비게이션 및 플로우 제어에 있어서 책임을 분리하도록 권장합니다.\n\n간단히 설명하면, 이 패턴에서 ViewModel은 데이터를 UI 요소에 바인딩하고 데이터가 변경되는 즉시 UI를 변경합니다. ViewController의 책임은 UI에서 발생하는 이벤트를 ViewModel에 알리는 것이므로 ViewModel이 해당 이벤트에 적절히 반응할 수 있습니다. 그리고 Coordinator가 네비게이션 로직을 처리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 패턴에 대한 훌륭한 기사가 있어요. 꼭 읽어보시길 추천합니다!\n\n## 코디네이터를 사용하는 장점은 무엇인가요?\n\n- 관심사 분리 (각 모듈이 단일 책임을 갖습니다)\n- 거대한 ViewControllers와 ViewModels 피하기\n- UI를 가능한 가장 덤하고 재사용 가능하게 유지\n- RX-Swift, Combine과 같은 반응적인 프레임워크와 뛰어난 호환성을 보여줍니다!\n\n## 코드 예시\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에는 “MainCoordinator”가 네비게이션 스택에 “ViewController”를 푸시하는 간단한 예제가 있습니다.\n\n“SecondViewController”로 이동하려면 해당하는 코디네이터에서 네비게이션을 처리하는 “goToSecondVC” 메서드를 호출하면 됩니다. 이렇게 하면 뷰 컨트롤러가 자체적으로 네비게이션을 처리할 필요가 없어집니다.\n\n```js\n// 먼저, 코디네이터를 위한 프로토콜을 정의해봅시다\n\nprotocol Coordinator {\n    var childCoordinators: [Coordinator] { get set }\n    var navigationController: UINavigationController { get set }\n\n    func start()\n}\n\n\n// 그 다음, 코디네이터(MainCoordinator)를 생성해봅시다\n\nclass MainCoordinator: Coordinator {\n    var childCoordinators = [Coordinator]()\n    var navigationController: UINavigationController\n\n    init(navigationController: UINavigationController) {\n        self.navigationController = navigationController\n    }\n\n    func start() {\n        let vc = ViewController.instantiate()\n        vc.coordinator = self\n        navigationController.pushViewController(vc, animated: false)\n    }\n\n    func goToSecondVC() {\n        let secondVC = SecondViewController.instantiate()\n        secondVC.coordinator = self\n        navigationController.pushViewController(secondVC, animated: true)\n    }\n}\n\n// 마지막으로, \"AppDelegate\"나 \"SceneDelegate\"에서\n// 메인 코디네이터를 인스턴스화하고 시작하는 방법입니다\n\nvar mainCoordinator: MainCoordinator?\n\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {\n    let navController = UINavigationController()\n    mainCoordinator = MainCoordinator(navigationController: navController)\n    mainCoordinator?.start()\n\n    window = UIWindow(frame: UIScreen.main.bounds)\n    window?.rootViewController = navController\n    window?.makeKeyAndVisible()\n    return true\n}\n```\n\n읽어 주셔서 감사합니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Coordinator Pattern in iOS App](/assets/img/2024-06-22-CoordinatorPatterniniOSApp_0.png)\n","ogImage":{"url":"/assets/img/2024-06-22-CoordinatorPatterniniOSApp_0.png"},"coverImage":"/assets/img/2024-06-22-CoordinatorPatterniniOSApp_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h1>코디네이터란 무엇인가요?</h1>\n<p>iOS 개발에서 코디네이터는 앱의 탐색 흐름을 처리하는 객체입니다. 때로는 \"플로우 컨트롤러\" 또는 \"라우터\"라고도 합니다.</p>\n<p>코디네이터는 뷰 컨트롤러가 어떻게 표시되고, 푸시되며 해제되는지, 앱의 다른 섹션 및 뷰가 어떻게 연결되는지에 대한 로직을 처리합니다.</p>\n<p>코디네이터는 보통 정의하는 클래스이며, 뷰 컨트롤러를 생성, 표시, 해제할 수 있는 메서드와 함께 정의됩니다. 앱의 흐름이 복잡한 경우에는 다른 코디네이터와 필요한 경우 통신할 수도 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>MVVM+C 패턴이란 무엇인가요?</h1>\n<p>일반적인 iOS 개발(예: MVC 패턴)에서는 일반적으로 네비게이션의 책임이 뷰 컨트롤러에게 주어집니다. 그러나 더 복잡한 플로우(예: 뷰 컨트롤러 간의 강한 결합, 코드 재사용성의 부족 및 테스트 문제 등)에서 많은 문제가 발생할 수 있습니다.</p>\n<p>MVVM+C(가끔 \"Coordinator 패턴\"이라고도 부릅니다)은 앱 내에서 책임을 분리하는 것을 촉진하는 디자인 패턴입니다. 특히 네비게이션 및 플로우 제어에 있어서 책임을 분리하도록 권장합니다.</p>\n<p>간단히 설명하면, 이 패턴에서 ViewModel은 데이터를 UI 요소에 바인딩하고 데이터가 변경되는 즉시 UI를 변경합니다. ViewController의 책임은 UI에서 발생하는 이벤트를 ViewModel에 알리는 것이므로 ViewModel이 해당 이벤트에 적절히 반응할 수 있습니다. 그리고 Coordinator가 네비게이션 로직을 처리합니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>이 패턴에 대한 훌륭한 기사가 있어요. 꼭 읽어보시길 추천합니다!</p>\n<h2>코디네이터를 사용하는 장점은 무엇인가요?</h2>\n<ul>\n<li>관심사 분리 (각 모듈이 단일 책임을 갖습니다)</li>\n<li>거대한 ViewControllers와 ViewModels 피하기</li>\n<li>UI를 가능한 가장 덤하고 재사용 가능하게 유지</li>\n<li>RX-Swift, Combine과 같은 반응적인 프레임워크와 뛰어난 호환성을 보여줍니다!</li>\n</ul>\n<h2>코드 예시</h2>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>여기에는 “MainCoordinator”가 네비게이션 스택에 “ViewController”를 푸시하는 간단한 예제가 있습니다.</p>\n<p>“SecondViewController”로 이동하려면 해당하는 코디네이터에서 네비게이션을 처리하는 “goToSecondVC” 메서드를 호출하면 됩니다. 이렇게 하면 뷰 컨트롤러가 자체적으로 네비게이션을 처리할 필요가 없어집니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 먼저, 코디네이터를 위한 프로토콜을 정의해봅시다</span>\n\nprotocol <span class=\"hljs-title class_\">Coordinator</span> {\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">childCoordinators</span>: [<span class=\"hljs-title class_\">Coordinator</span>] { get set }\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">navigationController</span>: <span class=\"hljs-title class_\">UINavigationController</span> { get set }\n\n    func <span class=\"hljs-title function_\">start</span>()\n}\n\n\n<span class=\"hljs-comment\">// 그 다음, 코디네이터(MainCoordinator)를 생성해봅시다</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MainCoordinator</span>: <span class=\"hljs-title class_\">Coordinator</span> {\n    <span class=\"hljs-keyword\">var</span> childCoordinators = [<span class=\"hljs-title class_\">Coordinator</span>]()\n    <span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">navigationController</span>: <span class=\"hljs-title class_\">UINavigationController</span>\n\n    <span class=\"hljs-title function_\">init</span>(<span class=\"hljs-params\">navigationController: UINavigationController</span>) {\n        self.<span class=\"hljs-property\">navigationController</span> = navigationController\n    }\n\n    func <span class=\"hljs-title function_\">start</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">let</span> vc = <span class=\"hljs-title class_\">ViewController</span>.<span class=\"hljs-title function_\">instantiate</span>()\n        vc.<span class=\"hljs-property\">coordinator</span> = self\n        navigationController.<span class=\"hljs-title function_\">pushViewController</span>(vc, <span class=\"hljs-attr\">animated</span>: <span class=\"hljs-literal\">false</span>)\n    }\n\n    func <span class=\"hljs-title function_\">goToSecondVC</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">let</span> secondVC = <span class=\"hljs-title class_\">SecondViewController</span>.<span class=\"hljs-title function_\">instantiate</span>()\n        secondVC.<span class=\"hljs-property\">coordinator</span> = self\n        navigationController.<span class=\"hljs-title function_\">pushViewController</span>(secondVC, <span class=\"hljs-attr\">animated</span>: <span class=\"hljs-literal\">true</span>)\n    }\n}\n\n<span class=\"hljs-comment\">// 마지막으로, \"AppDelegate\"나 \"SceneDelegate\"에서</span>\n<span class=\"hljs-comment\">// 메인 코디네이터를 인스턴스화하고 시작하는 방법입니다</span>\n\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-attr\">mainCoordinator</span>: <span class=\"hljs-title class_\">MainCoordinator</span>?\n\nfunc <span class=\"hljs-title function_\">application</span>(_ <span class=\"hljs-attr\">application</span>: <span class=\"hljs-title class_\">UIApplication</span>, didFinishLaunchingWithOptions <span class=\"hljs-attr\">launchOptions</span>: [<span class=\"hljs-title class_\">UIApplication</span>.<span class=\"hljs-property\">LaunchOptionsKey</span>: <span class=\"hljs-title class_\">Any</span>]?) -> <span class=\"hljs-title class_\">Bool</span> {\n    <span class=\"hljs-keyword\">let</span> navController = <span class=\"hljs-title class_\">UINavigationController</span>()\n    mainCoordinator = <span class=\"hljs-title class_\">MainCoordinator</span>(<span class=\"hljs-attr\">navigationController</span>: navController)\n    mainCoordinator?.<span class=\"hljs-title function_\">start</span>()\n\n    <span class=\"hljs-variable language_\">window</span> = <span class=\"hljs-title class_\">UIWindow</span>(<span class=\"hljs-attr\">frame</span>: <span class=\"hljs-title class_\">UIScreen</span>.<span class=\"hljs-property\">main</span>.<span class=\"hljs-property\">bounds</span>)\n    <span class=\"hljs-variable language_\">window</span>?.<span class=\"hljs-property\">rootViewController</span> = navController\n    <span class=\"hljs-variable language_\">window</span>?.<span class=\"hljs-title function_\">makeKeyAndVisible</span>()\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\n</code></pre>\n<p>읽어 주셔서 감사합니다!</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p><img src=\"/assets/img/2024-06-22-CoordinatorPatterniniOSApp_0.png\" alt=\"Coordinator Pattern in iOS App\"></p>\n</body>\n</html>\n"},"__N_SSG":true}