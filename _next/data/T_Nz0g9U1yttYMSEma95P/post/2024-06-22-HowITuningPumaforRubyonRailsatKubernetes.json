{"pageProps":{"post":{"title":"Kubernetes 환경에서 Ruby on Rails의 Puma 튜닝 방법","description":"","date":"2024-06-22 22:29","slug":"2024-06-22-HowITuningPumaforRubyonRailsatKubernetes","content":"\n## 쿠버네티스에 맞게 Puma 튜닝하기\n\nPuma는 Ruby on Rails용 인기 있는 웹 서버 패키지이며, Puma 구성을 잘 튜닝하면 서비스 효율성이 더욱 향상됩니다.\n\nPuma 젬: [https://rubygems.org/gems/puma](https://rubygems.org/gems/puma)\n\n![이미지](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 왜 리팩토링 해야 하나요?\n\n가장 중요한 이유는 도커에서 쿠버네티스 아키텍처로 마이그레이션할 때, Puma 구성을 새 아키텍처에 맞게 업데이트해야 할 수도 있다는 것입니다. 따라서, 저는 많은 기사와 소스 저장소를 재조사하여 이를 다시 작성하는 데 도움을 받았어요.\n\n# Puma 구성 튜닝을 하기 전, 확인해야 할 사항\n\n- 처음에는 가장 중요한 서비스를 사용하지 마세요. 그 대신 부수적인 서비스를 사용하세요.\n  예를 들어, 먼저 테스트할 때 회원 OAuth 서비스를 사용하지 마세요. 이 예에서, 저는 테스트용으로 메일 센터를 사용했어요. (대부분의 요청이 내부 호출이며, 요청이 실패하면 다시 시도합니다.)\n- 서비스의 온라인 상태를 확인하기 위해 모니터링 서비스 중 하나가 반드시 필요해요. 저는 서비스와 쿠버네티스 상태를 확인하기 위해 Datadog를 사용하고 있어요.\n- 각 구성 설정과 단계별 튜닝을 위해 왜 그리고 어떻게 하는지 알아야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Puma 구성 리팩터링\n\n## 우리의 초기 Puma 구성\n\n첫 번째 구성은 다음과 같습니다.\n\n```js\n#!/usr/bin/env puma\n\nenvironment ENV.fetch(\"RAILS_ENV\") { \"development\" }\n\nif ENV['RAILS_ENV'].nil? || ENV['RAILS_ENV'] == 'development'\n  threads_count = ENV.fetch(\"RAILS_MAX_THREADS\") { 5 }\n  threads threads_count, threads_count\n\n  port ENV.fetch(\"PORT\") { 3000 }\n\n  plugin :tmp_restart\nelse\n  directory './'\n  rackup \"./config.ru\"\n\n  pidfile \"./tmp/pids/puma.pid\"\n  state_path \"./tmp/pids/puma.state\"\n\n  threads 0,16\n\n  port ENV.fetch(\"PORT\") { 3000 }\n\n  workers 2\n\n  prune_bundler\n\n  on_restart do\n    puts 'Refreshing Gemfile'\n    ENV[\"BUNDLE_GEMFILE\"] = \"./Gemfile\"\n  end\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 리팩터링 키포인트 1: 스레드 용량 감소\n\n일부 참조 링크를 조사했는데, 먼저 그것들을 확인해보세요.\n\n- [문서] 쿠버네티스에 적합한 Puma 튜닝 방법\n- 최대 효율을 위한 Puma, Unicorn 및 Passenger 구성\n- Pod 당 워커 및 기타 구성 문제\n\n마지막 문제 토론에 따르면, 너무 많은 스레드를 사용하는 것은 더 많은 요청을 수용하기에 적합하지 않으며, 리소스가 Global VM 락에 직면할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 설정에서는 각 워커에 너무 많은 스레드를 설정했어요. 그래서 이것이 제 첫 번째 반응 대상이 됐어요.\n\nPuma 문서의 기사에 따르면, 쿠버네티스 팟 _ Puma 워커 _ 스레드가 최종 총 용량이라는 걸 알 수 있어요.\n\n이전에 우리의 용량은 64였어요. 2 (팟) _ 2 (워커) _ 16 (최대 스레드)인거죠. 큰 감소가 심각한 문제를 일으킬 것을 두려워해서, 처음에는 스레드를 8로 순차적으로 감소시켰고, 마지막에 5로 줄였어요 (총 용량은 20이 될 거예요).\n\n```js\n# puma.rb\n# Puma에게 1에서 5 범위 내에서 스레드를 자동 조정하도록 설정합니다.\n# 각 스레드가 더 많은 CPU / 메모리 리소스를 갖으므로 16에서 5로 줄였어요.\nthreads 0, 5\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Refactor Key 2: CPU 코어의 수를 신뢰성 있게 감지할 수 있어야 합니다.\n\n초기 설정에서는 이전 도커 인프라에서 각 서비스가 사용할 수 있는 2개의 vCPU를 가지고 있기 때문에, 종업원을 두 명으로 설정했습니다.\n\n첫 번째 시도에서, 새로운 Rails 버전의 Puma 구성 설정을 참조하여 CPU를 감지하였습니다.\n\n```js\n# Specifies that the worker count should equal the number of processors in production.\nif ENV[\"RAILS_ENV\"] == \"production\"\n  worker_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\n  workers worker_count if worker_count > 1\nend\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n루비 메소드를 사용하여 CPU 프로세서 카운트를 감지하는 것은 좋은 아이디어에요. \"물리 프로세서 수\" 또는 \"OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서\"를 기준으로 결정할 수 있어요.\n\n```js\n# Module: Concurrent\n\nrequire \"concurrent-ruby\"\n\n# 현재 시스템의 물리 프로세서 코어 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\nConcurrent.physical_processor_count\n\n# OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\nConcurrent.processor_count\n```\n\n만약 Kubernetes 베이스 클러스터 노드에 CPU가 4개 있고, 서비스를 1000(µs) CPU 리소스로 제한한다면, Coucurrnet 메소드를 사용하면 항상 4를 반환할 거에요 (호스트 수준 리소스가 보이기 때문에 팟 수준 리소스가 아니에요).\n\n그래서 Puma가 Kubernetes 설정을 직접 읽을 수 있도록 해야 해요. 다음과 같이 시도해 봤어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# K8S CPU 제한을 설정하는 방법을 확인하세요.\n\n## cpu.cfs_quota_us는 그룹이 해당 창기간 동안 사용할 수 있는 최대 CPU 시간(마이크로초 단위)을 지정합니다.\n\n## cpu.cfs_period_us는 CPU 액세스를 위한 시간 창문의 길이(마이크로초 단위)를 나타냅니다.\n\n## quota가 -1이면 CPU 자원 사용에 대한 제한이 없는 것을 의미합니다.\n\n\"concurrent-ruby\"을 요구합니다.\nquota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\nperiod_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\nquota = File.read(quota_file).strip.to_i\nperiod = File.read(period_file).strip.to_i\n\nif quota != -1\nprocessors_count = (quota.to_f / period.to_f).ceil\nelse\nprocessors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\nend\n\nCPU 자원이 제한되지 않는 경우에는 서비스가 노드의 CPU 최대 범위를 사용할 수 있으므로 물리적 프로세서 개수를 기반으로 설계되었습니다. 제한이 있는 경우 계산하세요!\n\n## 리팩터링 핵심 3: 항상 서비스에 시간 제한을 설정하세요.\n\nSidekiq 작성자인 마이크의 글을 예전에 읽었는데도 기억이 싱싱합니다. 모든 네트워크 요청에는 타임아웃을 설정해야 한다는 교훈을 주었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n제가 참고한 GitHub은 puma 타임아웃 설정을 위해 the-ultimate-guide-to-ruby-timeouts입니다. 매우 유용합니다.\n\n![이미지](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_1.png)\n\n## 리팩터링 핵심 4: 에러 처리 설정하기.\n\nPuma에는 기본 에러 처리 구성이 내장되어 있습니다. 또한 오류를 캡처하는 Sentry 시스템도 있으므로 에러가 발생할 때 Sentry 캡처를 추가하는 것이 좋아 보입니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 참조: https://github.com/puma/puma?tab=readme-ov-file#error-handling\n\nlowlevel_error_handler do |e|\n  Sentry.capture_exception(e)\n  [500, {}, [\"오류가 발생했습니다\"]]\nend\n```\n\n## 최종 Puma 설정\n\n```js\n# 이 구성 파일은 Puma에 의해 평가될 것입니다. 여기에서 호출되는 최상위 메서드들은\n# Puma의 구성 DSL의 일부입니다. DSL에서 제공하는 메서드에 대한 자세한 정보는 https://puma.io/puma/Puma/DSL.html에서 확인하세요.\n\n# Puma는 설정 가능한 일정 수의 프로세스(작업자)를 시작하고 각 프로세스는 내부 스레드 풀에서 스레드로 각 요청을 처리합니다.\n#\n# 각 작업자당 이상적인 스레드 수는 응용 프로그램이 IO 작업을 기다리는 시간과\n# 처리량을 지연 시간보다 우선시할지에 따라 다릅니다.\n#\n# 일반적으로 스레드 수를 늘리면 특정 프로세스가 처리할 수 있는 트래픽 양(처리량)이 늘어납니다.\n# 그러나 CRuby의 Global VM Lock (GVL)로 인해 반응 시간(지연 시간)이 악화될 수 있고\n# 수응용 프로그램의 경우 감소하기 때문에 이 형벌이 선뜻 좋은 결정이라고 할 수 없습니다.\n#\n# 평균적인 Rails 응용 프로그램에 대한 처리량과 지연 시간 사이의 괜찮은 절충으로 간주되는 3개의 스레드로 설정됩니다.\n#\n# 연결 풀이나 다른 리소스 풀을 사용하는 모든 라이브러리는\n# 스레드 수와 동일하거나 그 이상의 연결을 제공하도록 구성되어야 합니다.\n# 이에는 `database.yml`의 Active Record의 `pool` 매개변수가 포함됩니다.\ndefault_threads_count = ENV.fetch(\"RAILS_MAX_THREADS\") { 3 }\nthreads default_threads_count, default_threads_count\n\n# 프로덕션 및 준비 단계에서 작업자 수를 프로세서 수와 동일하게 설정\nif rails_env == \"production\" || rails_env == \"preparing\"\n  # 프로세스 당 1개 이상의 스레드를 실행중인 경우 작업자 수\n  # 기본적으로 프로세서(컴퓨터 코어)의 수와 동일하게 설정해야합니다.\n  #\n  # 이것은 신뢰할 수 없te, CPU 코어의 수를 신뢰할 수없습니다.\n  # `WEB_CONCURRENCY` 환경 변수를 프로세서 수와 일치하도록 설정하는지 확인하세요.\n  require \"concurrent-ruby\"\n\n  # config 파일로부터 K8S CPU 한정 메모리 확인\n  ## cpu.cfs_quota_us는 그 그룹이 그 창에서 사용할 수 있는 최대 CPU 시간(밀리 초 단위)을 지정합니다.\n  ## cpu.cfs_period_us는 CPU 액세스 시간 창의 길이를 지정합니다.\n  quota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\n  period_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\n  quota = File.read(quota_file).strip.to_i\n  period = File.read(period_file).strip.to_i\n\n  if quota != -1\n    processors_count = (quota.to_f / period.to_f).ceil\n  else\n    processors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\n  end\n\n  # 작업자 및 스레드 설정\n  if processors_count > 1\n    workers processors_count\n    threads 0, 5\n\n    on_worker_boot do\n      ActiveRecord::Base.establish_connection if defined?(ActiveRecord)\n    end\n  else\n    preload_app!\n  end\n\n  worker_timeout 15\n  worker_shutdown_timeout 8\nend\n\n# Puma가 요청을 수신하기 위해 청취하는 `포트`를 지정; 기본값은 3000입니다.\nport ENV.fetch(\"PORT\") { 3000 }\n\n# Puma가 실행할 `환경`을 지정합니다.\nenvironment rails_env\n\n# `bin/rails restart` 명령으로 Puma를 다시 시작할 수 있도록 허용\nplugin :tmp_restart\npidfile ENV[\"PIDFILE\"] if ENV[\"PIDFILE\"]\n\nif rails_env == \"development\"\n  # 디버거에 의해 일시 중단되었을 때 Puma에 의해 작업자가 종료되지 않도록 매우 넉넉한 `worker_timeout`를 지정합니다.\n  worker_timeout 3600\nend\n\n# 응용 프로그램의 범위를 벗어난 오류가 발생하면 Puma가 500 및 간단한 텍스트 오류 메시지와 함께 응답\nlowlevel_error_handler do |e|\n  Sentry.capture_exception(e)\n  [500, {}, [\"오류가 발생했습니다\"]]\nend\n```\n\n이전에 언급하지 않았던 몇 가지 작은 변경 사항이 있지만 참고하실 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- **on_worker_boot** 메소드를 사용해보세요.\n  작업자가 부팅될 때 항상 ActiveRecord가 데이터베이스에 연결되어 있는지 확인하세요 (필요하다면 Redis를 추가할 수도 있습니다).\n\n- 여러 작업자를 사용하는 경우 **preload_app!**는 기본적으로 켜져 있습니다.\n  Rails에서는 새로운 Puma 템플릿이 작업자 수가 1인 경우에도 preload_app를 사용합니다.\n  https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\n\n# 모든 것을 모니터링하세요\n\n만든 변경사항은 항상 모니터링되어야 함을 기억하세요.\n\n새로운 환경 설정을 프로덕션에 배포할 때 문제가 없어야 합니다. (물론, 우리는 준비된 환경이 있고 서비스가 작동하는지 확인하기 위해 몇 가지 스트레스 테스트를 수행하였지만, 요청량은 프로덕션 환경과 비교할 수 없을 정도로 상이합니다.)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요청 용량을 64에서 20으로 줄인 후에도 서비스는 잘 작동했어요. CPU 및 메모리 사용량이 크게 개선되지는 않았지만, 스레드 용량을 더 적합한 상황으로 줄여 GVL을 피하려고 성공적으로 조정했습니다.\n\n![그림 1](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_2.png)\n\n![그림 2](/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_3.png)\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 멀티스레드인 경우, Puma 워커 당 1개의 CPU를 할당하세요.\n  참고: https://github.com/puma/puma/issues/2645#issuecomment-867629826\n- 대부분의 Puma는 워커 당 약 512MB ~ 1GB의 메모리를 사용하며, 마스터 프로세스에 대략 1GB를 사용합니다.\n  참고: https://github.com/puma/puma/issues/2645#issuecomment-867629826\n- 대부분의 Puma는 각 쓰레드 당 약 300MB ~ 500MB의 메모리를 사용합니다.\n  이는 웹 서비스의 유형과 기능에 따라 다를 수 있으며, Ruby 3 및 Rails 6 응용 프로그램을 실험하면서 각 프로세스가 약 200MB ~ 400MB 정도 사용한다는 기사를 참조했습니다.\n  참고: https://www.speedshop.co/2017/10/12/appserver.html\n- 각 Puma 워커를 3 ~ 5개의 쓰레드로 설정하는 것이 일반 목적에 가장 적합합니다.\n  참고 1: https://github.com/rails/rails/issues/50450\n  참고 2: https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration\n- 자원에 따라 구성이 동적으로 조정되도록 하세요.\n- 웹 서비스에 대한 시간 초과 및 오류 처리 메커니즘을 항상 설정하세요.\n  참고 1: https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\n  참고 2: https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts\n- 생산 환경에 배포하기 전에 중요하지 않은 서비스부터 사용하고, 배포 전에 더 많은 테스트를 수행하세요.\n- 생산 환경에 배포할 때 모니터링 서비스를 사용하여 모든 변경 사항을 처리하고 기록하는 데 도움을 받으세요.\n\n# 참고 자료\n\n- https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server\n- https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma\n- https://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues\n- https://github.com/puma/puma?tab=readme-ov-file#clustered-mode\n- https://github.com/puma/puma?tab=readme-ov-file#error-handling\n- https://github.com/puma/puma/issues/2645\n- https://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb\n- https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\n- https://github.com/rails/rails/issues/50450\n- https://puma.io/puma/Puma/DSL.html\n- https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method\n- https://www.speedshop.co/2017/10/12/appserver.html\n- https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\n","ogImage":{"url":"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png"},"coverImage":"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png","tag":["Tech"],"readingTime":14},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<h2>쿠버네티스에 맞게 Puma 튜닝하기</h2>\n<p>Puma는 Ruby on Rails용 인기 있는 웹 서버 패키지이며, Puma 구성을 잘 튜닝하면 서비스 효율성이 더욱 향상됩니다.</p>\n<p>Puma 젬: <a href=\"https://rubygems.org/gems/puma\" rel=\"nofollow\" target=\"_blank\">https://rubygems.org/gems/puma</a></p>\n<p><img src=\"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_0.png\" alt=\"이미지\"></p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>왜 리팩토링 해야 하나요?</h1>\n<p>가장 중요한 이유는 도커에서 쿠버네티스 아키텍처로 마이그레이션할 때, Puma 구성을 새 아키텍처에 맞게 업데이트해야 할 수도 있다는 것입니다. 따라서, 저는 많은 기사와 소스 저장소를 재조사하여 이를 다시 작성하는 데 도움을 받았어요.</p>\n<h1>Puma 구성 튜닝을 하기 전, 확인해야 할 사항</h1>\n<ul>\n<li>처음에는 가장 중요한 서비스를 사용하지 마세요. 그 대신 부수적인 서비스를 사용하세요.\n예를 들어, 먼저 테스트할 때 회원 OAuth 서비스를 사용하지 마세요. 이 예에서, 저는 테스트용으로 메일 센터를 사용했어요. (대부분의 요청이 내부 호출이며, 요청이 실패하면 다시 시도합니다.)</li>\n<li>서비스의 온라인 상태를 확인하기 위해 모니터링 서비스 중 하나가 반드시 필요해요. 저는 서비스와 쿠버네티스 상태를 확인하기 위해 Datadog를 사용하고 있어요.</li>\n<li>각 구성 설정과 단계별 튜닝을 위해 왜 그리고 어떻게 하는지 알아야 해요.</li>\n</ul>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>Puma 구성 리팩터링</h1>\n<h2>우리의 초기 Puma 구성</h2>\n<p>첫 번째 구성은 다음과 같습니다.</p>\n<pre><code class=\"hljs language-js\">#!<span class=\"hljs-regexp\">/usr/</span>bin/env puma\n\nenvironment <span class=\"hljs-variable constant_\">ENV</span>.<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"RAILS_ENV\"</span></span>) { <span class=\"hljs-string\">\"development\"</span> }\n\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable constant_\">ENV</span>[<span class=\"hljs-string\">'RAILS_ENV'</span>].<span class=\"hljs-property\">nil</span>? || <span class=\"hljs-variable constant_\">ENV</span>[<span class=\"hljs-string\">'RAILS_ENV'</span>] == <span class=\"hljs-string\">'development'</span>\n  threads_count = <span class=\"hljs-variable constant_\">ENV</span>.<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"RAILS_MAX_THREADS\"</span></span>) { <span class=\"hljs-number\">5</span> }\n  threads threads_count, threads_count\n\n  port <span class=\"hljs-variable constant_\">ENV</span>.<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"PORT\"</span></span>) { <span class=\"hljs-number\">3000</span> }\n\n  plugin :tmp_restart\n<span class=\"hljs-keyword\">else</span>\n  directory <span class=\"hljs-string\">'./'</span>\n  rackup <span class=\"hljs-string\">\"./config.ru\"</span>\n\n  pidfile <span class=\"hljs-string\">\"./tmp/pids/puma.pid\"</span>\n  state_path <span class=\"hljs-string\">\"./tmp/pids/puma.state\"</span>\n\n  threads <span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">16</span>\n\n  port <span class=\"hljs-variable constant_\">ENV</span>.<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"PORT\"</span></span>) { <span class=\"hljs-number\">3000</span> }\n\n  workers <span class=\"hljs-number\">2</span>\n\n  prune_bundler\n\n  on_restart <span class=\"hljs-keyword\">do</span>\n    puts <span class=\"hljs-string\">'Refreshing Gemfile'</span>\n    <span class=\"hljs-variable constant_\">ENV</span>[<span class=\"hljs-string\">\"BUNDLE_GEMFILE\"</span>] = <span class=\"hljs-string\">\"./Gemfile\"</span>\n  end\nend\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>리팩터링 키포인트 1: 스레드 용량 감소</h2>\n<p>일부 참조 링크를 조사했는데, 먼저 그것들을 확인해보세요.</p>\n<ul>\n<li>[문서] 쿠버네티스에 적합한 Puma 튜닝 방법</li>\n<li>최대 효율을 위한 Puma, Unicorn 및 Passenger 구성</li>\n<li>Pod 당 워커 및 기타 구성 문제</li>\n</ul>\n<p>마지막 문제 토론에 따르면, 너무 많은 스레드를 사용하는 것은 더 많은 요청을 수용하기에 적합하지 않으며, 리소스가 Global VM 락에 직면할 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>우리 설정에서는 각 워커에 너무 많은 스레드를 설정했어요. 그래서 이것이 제 첫 번째 반응 대상이 됐어요.</p>\n<p>Puma 문서의 기사에 따르면, 쿠버네티스 팟 _ Puma 워커 _ 스레드가 최종 총 용량이라는 걸 알 수 있어요.</p>\n<p>이전에 우리의 용량은 64였어요. 2 (팟) _ 2 (워커) _ 16 (최대 스레드)인거죠. 큰 감소가 심각한 문제를 일으킬 것을 두려워해서, 처음에는 스레드를 8로 순차적으로 감소시켰고, 마지막에 5로 줄였어요 (총 용량은 20이 될 거예요).</p>\n<pre><code class=\"hljs language-js\"># puma.<span class=\"hljs-property\">rb</span>\n# <span class=\"hljs-title class_\">Puma</span>에게 <span class=\"hljs-number\">1</span>에서 <span class=\"hljs-number\">5</span> 범위 내에서 스레드를 자동 조정하도록 설정합니다.\n# 각 스레드가 더 많은 <span class=\"hljs-variable constant_\">CPU</span> / 메모리 리소스를 갖으므로 <span class=\"hljs-number\">16</span>에서 <span class=\"hljs-number\">5</span>로 줄였어요.\nthreads <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h2>Refactor Key 2: CPU 코어의 수를 신뢰성 있게 감지할 수 있어야 합니다.</h2>\n<p>초기 설정에서는 이전 도커 인프라에서 각 서비스가 사용할 수 있는 2개의 vCPU를 가지고 있기 때문에, 종업원을 두 명으로 설정했습니다.</p>\n<p>첫 번째 시도에서, 새로운 Rails 버전의 Puma 구성 설정을 참조하여 CPU를 감지하였습니다.</p>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">Specifies</span> that the worker count should equal the number <span class=\"hljs-keyword\">of</span> processors <span class=\"hljs-keyword\">in</span> production.\n<span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable constant_\">ENV</span>[<span class=\"hljs-string\">\"RAILS_ENV\"</span>] == <span class=\"hljs-string\">\"production\"</span>\n  worker_count = <span class=\"hljs-title class_\">Integer</span>(<span class=\"hljs-variable constant_\">ENV</span>.<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"WEB_CONCURRENCY\"</span></span>) { <span class=\"hljs-title class_\">Concurrent</span>.<span class=\"hljs-property\">physical_processor_count</span> })\n  workers worker_count <span class=\"hljs-keyword\">if</span> worker_count > <span class=\"hljs-number\">1</span>\nend\n</code></pre>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>루비 메소드를 사용하여 CPU 프로세서 카운트를 감지하는 것은 좋은 아이디어에요. \"물리 프로세서 수\" 또는 \"OS에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서\"를 기준으로 결정할 수 있어요.</p>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">Module</span>: <span class=\"hljs-title class_\">Concurrent</span>\n\n<span class=\"hljs-built_in\">require</span> <span class=\"hljs-string\">\"concurrent-ruby\"</span>\n\n# 현재 시스템의 물리 프로세서 코어 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\n<span class=\"hljs-title class_\">Concurrent</span>.<span class=\"hljs-property\">physical_processor_count</span>\n\n# <span class=\"hljs-variable constant_\">OS</span>에서 보이는 프로세서 및 프로세스 스케줄링에 사용되는 프로세서 수.\n# 성능상의 이유로 처음 호출될 때 계산된 값은 메모이즈될 거에요.\n<span class=\"hljs-title class_\">Concurrent</span>.<span class=\"hljs-property\">processor_count</span>\n</code></pre>\n<p>만약 Kubernetes 베이스 클러스터 노드에 CPU가 4개 있고, 서비스를 1000(µs) CPU 리소스로 제한한다면, Coucurrnet 메소드를 사용하면 항상 4를 반환할 거에요 (호스트 수준 리소스가 보이기 때문에 팟 수준 리소스가 아니에요).</p>\n<p>그래서 Puma가 Kubernetes 설정을 직접 읽을 수 있도록 해야 해요. 다음과 같이 시도해 봤어요:</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<h1>K8S CPU 제한을 설정하는 방법을 확인하세요.</h1>\n<h2>cpu.cfs_quota_us는 그룹이 해당 창기간 동안 사용할 수 있는 최대 CPU 시간(마이크로초 단위)을 지정합니다.</h2>\n<h2>cpu.cfs_period_us는 CPU 액세스를 위한 시간 창문의 길이(마이크로초 단위)를 나타냅니다.</h2>\n<h2>quota가 -1이면 CPU 자원 사용에 대한 제한이 없는 것을 의미합니다.</h2>\n<p>\"concurrent-ruby\"을 요구합니다.\nquota_file = '/sys/fs/cgroup/cpu/cpu.cfs_quota_us'\nperiod_file = '/sys/fs/cgroup/cpu/cpu.cfs_period_us'\nquota = File.read(quota_file).strip.to_i\nperiod = File.read(period_file).strip.to_i</p>\n<p>if quota != -1\nprocessors_count = (quota.to_f / period.to_f).ceil\nelse\nprocessors_count = Integer(ENV.fetch(\"WEB_CONCURRENCY\") { Concurrent.physical_processor_count })\nend</p>\n<p>CPU 자원이 제한되지 않는 경우에는 서비스가 노드의 CPU 최대 범위를 사용할 수 있으므로 물리적 프로세서 개수를 기반으로 설계되었습니다. 제한이 있는 경우 계산하세요!</p>\n<h2>리팩터링 핵심 3: 항상 서비스에 시간 제한을 설정하세요.</h2>\n<p>Sidekiq 작성자인 마이크의 글을 예전에 읽었는데도 기억이 싱싱합니다. 모든 네트워크 요청에는 타임아웃을 설정해야 한다는 교훈을 주었습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>제가 참고한 GitHub은 puma 타임아웃 설정을 위해 the-ultimate-guide-to-ruby-timeouts입니다. 매우 유용합니다.</p>\n<p><img src=\"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_1.png\" alt=\"이미지\"></p>\n<h2>리팩터링 핵심 4: 에러 처리 설정하기.</h2>\n<p>Puma에는 기본 에러 처리 구성이 내장되어 있습니다. 또한 오류를 캡처하는 Sentry 시스템도 있으므로 에러가 발생할 때 Sentry 캡처를 추가하는 것이 좋아 보입니다!</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<pre><code class=\"hljs language-js\"># 참조: <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//github.com/puma/puma?tab=readme-ov-file#error-handling</span>\n\nlowlevel_error_handler <span class=\"hljs-keyword\">do</span> |e|\n  <span class=\"hljs-title class_\">Sentry</span>.<span class=\"hljs-title function_\">capture_exception</span>(e)\n  [<span class=\"hljs-number\">500</span>, {}, [<span class=\"hljs-string\">\"오류가 발생했습니다\"</span>]]\nend\n</code></pre>\n<h2>최종 Puma 설정</h2>\n<pre><code class=\"hljs language-js\"># 이 구성 파일은 <span class=\"hljs-title class_\">Puma</span>에 의해 평가될 것입니다. 여기에서 호출되는 최상위 메서드들은\n# <span class=\"hljs-title class_\">Puma</span>의 구성 <span class=\"hljs-variable constant_\">DSL</span>의 일부입니다. <span class=\"hljs-variable constant_\">DSL</span>에서 제공하는 메서드에 대한 자세한 정보는 <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//puma.io/puma/Puma/DSL.html에서 확인하세요.</span>\n\n# <span class=\"hljs-title class_\">Puma</span>는 설정 가능한 일정 수의 프로세스(작업자)를 시작하고 각 프로세스는 내부 스레드 풀에서 스레드로 각 요청을 처리합니다.\n#\n# 각 작업자당 이상적인 스레드 수는 응용 프로그램이 <span class=\"hljs-variable constant_\">IO</span> 작업을 기다리는 시간과\n# 처리량을 지연 시간보다 우선시할지에 따라 다릅니다.\n#\n# 일반적으로 스레드 수를 늘리면 특정 프로세스가 처리할 수 있는 트래픽 양(처리량)이 늘어납니다.\n# 그러나 <span class=\"hljs-title class_\">CRuby</span>의 <span class=\"hljs-title class_\">Global</span> <span class=\"hljs-variable constant_\">VM</span> <span class=\"hljs-title class_\">Lock</span> (<span class=\"hljs-variable constant_\">GVL</span>)로 인해 반응 시간(지연 시간)이 악화될 수 있고\n# 수응용 프로그램의 경우 감소하기 때문에 이 형벌이 선뜻 좋은 결정이라고 할 수 없습니다.\n#\n# 평균적인 <span class=\"hljs-title class_\">Rails</span> 응용 프로그램에 대한 처리량과 지연 시간 사이의 괜찮은 절충으로 간주되는 <span class=\"hljs-number\">3</span>개의 스레드로 설정됩니다.\n#\n# 연결 풀이나 다른 리소스 풀을 사용하는 모든 라이브러리는\n# 스레드 수와 동일하거나 그 이상의 연결을 제공하도록 구성되어야 합니다.\n# 이에는 <span class=\"hljs-string\">`database.yml`</span>의 <span class=\"hljs-title class_\">Active</span> <span class=\"hljs-title class_\">Record</span>의 <span class=\"hljs-string\">`pool`</span> 매개변수가 포함됩니다.\ndefault_threads_count = <span class=\"hljs-variable constant_\">ENV</span>.<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"RAILS_MAX_THREADS\"</span></span>) { <span class=\"hljs-number\">3</span> }\nthreads default_threads_count, default_threads_count\n\n# 프로덕션 및 준비 단계에서 작업자 수를 프로세서 수와 동일하게 설정\n<span class=\"hljs-keyword\">if</span> rails_env == <span class=\"hljs-string\">\"production\"</span> || rails_env == <span class=\"hljs-string\">\"preparing\"</span>\n  # 프로세스 당 <span class=\"hljs-number\">1</span>개 이상의 스레드를 실행중인 경우 작업자 수\n  # 기본적으로 프로세서(컴퓨터 코어)의 수와 동일하게 설정해야합니다.\n  #\n  # 이것은 신뢰할 수 없te, <span class=\"hljs-variable constant_\">CPU</span> 코어의 수를 신뢰할 수없습니다.\n  # <span class=\"hljs-string\">`WEB_CONCURRENCY`</span> 환경 변수를 프로세서 수와 일치하도록 설정하는지 확인하세요.\n  <span class=\"hljs-built_in\">require</span> <span class=\"hljs-string\">\"concurrent-ruby\"</span>\n\n  # config 파일로부터 <span class=\"hljs-variable constant_\">K8S</span> <span class=\"hljs-variable constant_\">CPU</span> 한정 메모리 확인\n  ## cpu.<span class=\"hljs-property\">cfs_quota_us</span>는 그 그룹이 그 창에서 사용할 수 있는 최대 <span class=\"hljs-variable constant_\">CPU</span> 시간(밀리 초 단위)을 지정합니다.\n  ## cpu.<span class=\"hljs-property\">cfs_period_us</span>는 <span class=\"hljs-variable constant_\">CPU</span> 액세스 시간 창의 길이를 지정합니다.\n  quota_file = <span class=\"hljs-string\">'/sys/fs/cgroup/cpu/cpu.cfs_quota_us'</span>\n  period_file = <span class=\"hljs-string\">'/sys/fs/cgroup/cpu/cpu.cfs_period_us'</span>\n  quota = <span class=\"hljs-title class_\">File</span>.<span class=\"hljs-title function_\">read</span>(quota_file).<span class=\"hljs-property\">strip</span>.<span class=\"hljs-property\">to_i</span>\n  period = <span class=\"hljs-title class_\">File</span>.<span class=\"hljs-title function_\">read</span>(period_file).<span class=\"hljs-property\">strip</span>.<span class=\"hljs-property\">to_i</span>\n\n  <span class=\"hljs-keyword\">if</span> quota != -<span class=\"hljs-number\">1</span>\n    processors_count = (quota.<span class=\"hljs-property\">to_f</span> / period.<span class=\"hljs-property\">to_f</span>).<span class=\"hljs-property\">ceil</span>\n  <span class=\"hljs-keyword\">else</span>\n    processors_count = <span class=\"hljs-title class_\">Integer</span>(<span class=\"hljs-variable constant_\">ENV</span>.<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"WEB_CONCURRENCY\"</span></span>) { <span class=\"hljs-title class_\">Concurrent</span>.<span class=\"hljs-property\">physical_processor_count</span> })\n  end\n\n  # 작업자 및 스레드 설정\n  <span class=\"hljs-keyword\">if</span> processors_count > <span class=\"hljs-number\">1</span>\n    workers processors_count\n    threads <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>\n\n    on_worker_boot <span class=\"hljs-keyword\">do</span>\n      <span class=\"hljs-title class_\">ActiveRecord</span>::<span class=\"hljs-title class_\">Base</span>.<span class=\"hljs-property\">establish_connection</span> <span class=\"hljs-keyword\">if</span> defined?(<span class=\"hljs-title class_\">ActiveRecord</span>)\n    end\n  <span class=\"hljs-keyword\">else</span>\n    preload_app!\n  end\n\n  worker_timeout <span class=\"hljs-number\">15</span>\n  worker_shutdown_timeout <span class=\"hljs-number\">8</span>\nend\n\n# <span class=\"hljs-title class_\">Puma</span>가 요청을 수신하기 위해 청취하는 <span class=\"hljs-string\">`포트`</span>를 지정; 기본값은 <span class=\"hljs-number\">3000</span>입니다.\nport <span class=\"hljs-variable constant_\">ENV</span>.<span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-params\"><span class=\"hljs-string\">\"PORT\"</span></span>) { <span class=\"hljs-number\">3000</span> }\n\n# <span class=\"hljs-title class_\">Puma</span>가 실행할 <span class=\"hljs-string\">`환경`</span>을 지정합니다.\nenvironment rails_env\n\n# <span class=\"hljs-string\">`bin/rails restart`</span> 명령으로 <span class=\"hljs-title class_\">Puma</span>를 다시 시작할 수 있도록 허용\nplugin :tmp_restart\npidfile <span class=\"hljs-variable constant_\">ENV</span>[<span class=\"hljs-string\">\"PIDFILE\"</span>] <span class=\"hljs-keyword\">if</span> <span class=\"hljs-variable constant_\">ENV</span>[<span class=\"hljs-string\">\"PIDFILE\"</span>]\n\n<span class=\"hljs-keyword\">if</span> rails_env == <span class=\"hljs-string\">\"development\"</span>\n  # 디버거에 의해 일시 중단되었을 때 <span class=\"hljs-title class_\">Puma</span>에 의해 작업자가 종료되지 않도록 매우 넉넉한 <span class=\"hljs-string\">`worker_timeout`</span>를 지정합니다.\n  worker_timeout <span class=\"hljs-number\">3600</span>\nend\n\n# 응용 프로그램의 범위를 벗어난 오류가 발생하면 <span class=\"hljs-title class_\">Puma</span>가 <span class=\"hljs-number\">500</span> 및 간단한 텍스트 오류 메시지와 함께 응답\nlowlevel_error_handler <span class=\"hljs-keyword\">do</span> |e|\n  <span class=\"hljs-title class_\">Sentry</span>.<span class=\"hljs-title function_\">capture_exception</span>(e)\n  [<span class=\"hljs-number\">500</span>, {}, [<span class=\"hljs-string\">\"오류가 발생했습니다\"</span>]]\nend\n</code></pre>\n<p>이전에 언급하지 않았던 몇 가지 작은 변경 사항이 있지만 참고하실 수 있습니다.</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>\n<p><strong>on_worker_boot</strong> 메소드를 사용해보세요.\n작업자가 부팅될 때 항상 ActiveRecord가 데이터베이스에 연결되어 있는지 확인하세요 (필요하다면 Redis를 추가할 수도 있습니다).</p>\n</li>\n<li>\n<p>여러 작업자를 사용하는 경우 **preload_app!**는 기본적으로 켜져 있습니다.\nRails에서는 새로운 Puma 템플릿이 작업자 수가 1인 경우에도 preload_app를 사용합니다.\n<a href=\"https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\" rel=\"nofollow\" target=\"_blank\">https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt</a></p>\n</li>\n</ul>\n<h1>모든 것을 모니터링하세요</h1>\n<p>만든 변경사항은 항상 모니터링되어야 함을 기억하세요.</p>\n<p>새로운 환경 설정을 프로덕션에 배포할 때 문제가 없어야 합니다. (물론, 우리는 준비된 환경이 있고 서비스가 작동하는지 확인하기 위해 몇 가지 스트레스 테스트를 수행하였지만, 요청량은 프로덕션 환경과 비교할 수 없을 정도로 상이합니다.)</p>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<p>요청 용량을 64에서 20으로 줄인 후에도 서비스는 잘 작동했어요. CPU 및 메모리 사용량이 크게 개선되지는 않았지만, 스레드 용량을 더 적합한 상황으로 줄여 GVL을 피하려고 성공적으로 조정했습니다.</p>\n<p><img src=\"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_2.png\" alt=\"그림 1\"></p>\n<p><img src=\"/assets/img/2024-06-22-HowITuningPumaforRubyonRailsatKubernetes_3.png\" alt=\"그림 2\"></p>\n<h1>결론</h1>\n<!-- ui-station 사각형 -->\n<p><ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-4877378276818686\" data-ad-slot=\"7249294152\" data-ad-format=\"auto\" data-full-width-responsive=\"true\"></ins></p>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n<ul>\n<li>멀티스레드인 경우, Puma 워커 당 1개의 CPU를 할당하세요.\n참고: <a href=\"https://github.com/puma/puma/issues/2645#issuecomment-867629826\" rel=\"nofollow\" target=\"_blank\">https://github.com/puma/puma/issues/2645#issuecomment-867629826</a></li>\n<li>대부분의 Puma는 워커 당 약 512MB ~ 1GB의 메모리를 사용하며, 마스터 프로세스에 대략 1GB를 사용합니다.\n참고: <a href=\"https://github.com/puma/puma/issues/2645#issuecomment-867629826\" rel=\"nofollow\" target=\"_blank\">https://github.com/puma/puma/issues/2645#issuecomment-867629826</a></li>\n<li>대부분의 Puma는 각 쓰레드 당 약 300MB ~ 500MB의 메모리를 사용합니다.\n이는 웹 서비스의 유형과 기능에 따라 다를 수 있으며, Ruby 3 및 Rails 6 응용 프로그램을 실험하면서 각 프로세스가 약 200MB ~ 400MB 정도 사용한다는 기사를 참조했습니다.\n참고: <a href=\"https://www.speedshop.co/2017/10/12/appserver.html\" rel=\"nofollow\" target=\"_blank\">https://www.speedshop.co/2017/10/12/appserver.html</a></li>\n<li>각 Puma 워커를 3 ~ 5개의 쓰레드로 설정하는 것이 일반 목적에 가장 적합합니다.\n참고 1: <a href=\"https://github.com/rails/rails/issues/50450\" rel=\"nofollow\" target=\"_blank\">https://github.com/rails/rails/issues/50450</a>\n참고 2: <a href=\"https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration\" rel=\"nofollow\" target=\"_blank\">https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server#recommended-default-puma-process-and-thread-configuration</a></li>\n<li>자원에 따라 구성이 동적으로 조정되도록 하세요.</li>\n<li>웹 서비스에 대한 시간 초과 및 오류 처리 메커니즘을 항상 설정하세요.\n참고 1: <a href=\"https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\" rel=\"nofollow\" target=\"_blank\">https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/</a>\n참고 2: <a href=\"https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts\" rel=\"nofollow\" target=\"_blank\">https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts</a></li>\n<li>생산 환경에 배포하기 전에 중요하지 않은 서비스부터 사용하고, 배포 전에 더 많은 테스트를 수행하세요.</li>\n<li>생산 환경에 배포할 때 모니터링 서비스를 사용하여 모든 변경 사항을 처리하고 기록하는 데 도움을 받으세요.</li>\n</ul>\n<h1>참고 자료</h1>\n<ul>\n<li><a href=\"https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server\" rel=\"nofollow\" target=\"_blank\">https://devcenter.heroku.com/articles/deploying-rails-applications-with-the-puma-web-server</a></li>\n<li><a href=\"https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma\" rel=\"nofollow\" target=\"_blank\">https://github.com/ankane/the-ultimate-guide-to-ruby-timeouts?tab=readme-ov-file#puma</a></li>\n<li><a href=\"https://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues\" rel=\"nofollow\" target=\"_blank\">https://github.com/puma/puma/blob/master/docs/kubernetes.md#workers-per-pod-and-other-config-issues</a></li>\n<li><a href=\"https://github.com/puma/puma?tab=readme-ov-file#clustered-mode\" rel=\"nofollow\" target=\"_blank\">https://github.com/puma/puma?tab=readme-ov-file#clustered-mode</a></li>\n<li><a href=\"https://github.com/puma/puma?tab=readme-ov-file#error-handling\" rel=\"nofollow\" target=\"_blank\">https://github.com/puma/puma?tab=readme-ov-file#error-handling</a></li>\n<li><a href=\"https://github.com/puma/puma/issues/2645\" rel=\"nofollow\" target=\"_blank\">https://github.com/puma/puma/issues/2645</a></li>\n<li><a href=\"https://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb\" rel=\"nofollow\" target=\"_blank\">https://github.com/rails/rails/blob/main/activestorage/test/dummy/config/puma.rb</a></li>\n<li><a href=\"https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt\" rel=\"nofollow\" target=\"_blank\">https://github.com/rails/rails/blob/main/railties/lib/rails/generators/rails/app/templates/config/puma.rb.tt</a></li>\n<li><a href=\"https://github.com/rails/rails/issues/50450\" rel=\"nofollow\" target=\"_blank\">https://github.com/rails/rails/issues/50450</a></li>\n<li><a href=\"https://puma.io/puma/Puma/DSL.html\" rel=\"nofollow\" target=\"_blank\">https://puma.io/puma/Puma/DSL.html</a></li>\n<li><a href=\"https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method\" rel=\"nofollow\" target=\"_blank\">https://ruby-concurrency.github.io/concurrent-ruby/master/Concurrent.html#physical_processor_count-class_method</a></li>\n<li><a href=\"https://www.speedshop.co/2017/10/12/appserver.html\" rel=\"nofollow\" target=\"_blank\">https://www.speedshop.co/2017/10/12/appserver.html</a></li>\n<li><a href=\"https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/\" rel=\"nofollow\" target=\"_blank\">https://www.mikeperham.com/2015/05/08/timeout-rubys-most-dangerous-api/</a></li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}