{"pageProps":{"posts":[{"title":"SwiftUI 아키텍처 완벽 해부 1부","description":"","date":"2024-06-30 19:31","slug":"2024-06-30-DemystifyingSwiftUIArchitecturePartI","content":"\n\nSwiftUI를 처음 공부하기 시작했을 때, 처음 모바일 앱을 구조화하는 데 많은 시간을 소비했어요. 이 질문의 핵심은 관심사 분리와 모듈화에 있어요. 여기서, 나는 여러분이 시간, 에너지, 그리고 뇌 자원을 절약하는 데 도움이 될 것을 바라면서 제 발견을 소개할 거예요. 바로 시작해 볼까요?\n\n참고: 초보자부터 중급자용 복잡도 애플리케이션을 고려했어요. 내가 제공하는 포괄적인 개요와 강조된 미묘한 점들을 통해, 여러분은 더 관심 있는 구성 요소를 자세히 연구할 수 있겠죠.\n\n첫 번째 단계는 아키텍처 패턴을 결정하는 것이에요. MVVM (Model-View-View Model)은 제 추천이지만, 여러분의 프로젝트에 맞지 않는다면 다른 패턴을 선택하시길 권장해요. MVVM 아키텍처 패턴이 수업 및 실제 앱에서 널리 사용되기 때문에, MVVM 아키텍처를 구현하는 방법에 대해 다룬 자료가 풍부하게 있어요. 다른 가능한 아키텍처 패턴으로는 MVC, VIPER, RIBs가 있어요.\n\n오늘은 서비스 레이어를 갖춘 MVVM 아키텍처 패턴에 대해 이야기할 거예요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모델: 애플리케이션 뒤의 데이터 및 비즈니스 로직 기능을 나타냅니다. 모델은 일반적으로 클래스와/또는 구조체로 구성됩니다. 클래스 대신 구조체를 사용해야 하는지의 주된 차이점은 앱이 같은 객체를 전달하는지 (클래스) 또는 속성의 복사본을 사용하는지 (구조체)에 달려 있습니다. 클래스의 속성이 필요하지 않다면 구조체가 선호되는 데이터 구조입니다.\n\n- 뷰: 사용자에게 정보/그래픽을 표시하고 사용자로부터 입력을 받는 사용자 인터페이스입니다. 뷰는 애플리케이션의 데이터와 사용자 간의 양방향 통신 채널로 작동합니다.\n\n주요 뷰 구성 요소는 다음과 같습니다:\n- 컨테이너 (예: NavigationStack, List, Form, ScrollView, Group, Grid, TabView): 뷰 구성 요소를 함께 조합합니다\n- 스택 (예: HStack, VStack, ZStack): 구조화된 스택 뷰 내에서 컨트롤 및 디스플레이를 배치합니다\n- 컨트롤 (예: Button, Picker, TextField, Toggle, Slider): 사용자 입력을 수락합니다\n- 디스플레이 (예: Text, Image, Label): 사용자에게 정보를 표시합니다\n- 레이아웃 도구 (예: Spacer, Divider, GeometryReader): 더 정확하게 뷰 구성 요소를 배치하여 원하는 뷰를 달성합니다\n- 팝업 (예: Alert, Sheet): 현재 네비게이션 흐름에서 벗어나고 사용자에게 추가 뷰/정보를 표시합니다\n\n- 뷰 모델: 모델의 데이터와 뷰의 사용자 인터페이스 사이의 중개자 역할을 합니다. 뷰 모델은 Observable Object 프로토콜 (@ObservedObject / @StateObject)을 통해 애플리케이션의 상태를 관리하며, iOS 17부터 Observable Macro도 시작했습니다. Observable Object 프로토콜은 뷰 모델의 @Published 속성이 변경 사항을 뷰로 게시할 수 있게 합니다. 결과적으로 뷰는 관찰된 변경 사항에 기반하여 다시 그려집니다. 뷰 모델에는 또한 모델 데이터를 원하는 뷰 형식으로 변환하는 데이터 변환 함수와 서비스 계층과의 상호 작용을 관리하는 기능이 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— 서비스 레이어: MVVM 아키텍처 패턴 외부의 데이터 작업을 처리합니다. 데이터를 검색하거나 저장하고 응용 프로그램에 제3자 서비스/소프트웨어 패키지를 통합하는 등의 작업을 다루며, 이 내용은 이 게시물에서 다루지 않습니다.\n\n- API / URL을 통한 데이터 검색: 모바일 장치는 주로 저장 공간 한정과 보안 기능 때문에 외부 서버에 데이터를 저장합니다. 앱은 API / URL 호출을 통해 외부 데이터를 검색하며, 높은 오류 처리 능력을 갖추고 있습니다 (앱이 치명적 오류로 인해 충돌하는 것은 피해야 합니다). 데이터를 검색한 후, 이를 인코딩/디코딩하여 네트워크와 네이티브 뷰 모델 친화적인 데이터 형식으로 변환합니다.\n\n- 로컬 (UserDefaults) 및 외부 (Apple의 CoreData, Apple의 CloudKit, 제3자) 솔루션을 통한 데이터 유지: 사용자가 앱을 사용할 때, 앱 데이터가 세션 간에 유지되기를 기대합니다. UserDefaults는 사용자 환경설정 및 앱 설정을 저장하는 간단한 솔루션입니다. 데이터 유지 프레임워크/솔루션은 큰 데이터 세트를 저장하기 위해 필요합니다. CoreData는 Apple의 기본 데이터 유지 프레임워크로, 기본적으로 SQLite를 사용합니다. CoreData는 학습 곡선이 있지만 오프라인 기능, 캐싱, 고급 정렬/쿼리와 같은 내장 기능을 제공합니다. 다른 주목할 만한 솔루션으로는 Apple의 CloudKit이 있으며, Firebase와 Realm과 같은 제3자 솔루션이 있습니다.\n\n요약하자면, 모바일 앱 아키텍처는 실제로 관심사 분리 (MVVM + 서비스)와 각 레이어 내에서의 모듈화로 구축됩니다. 이 글이 유익했기를 바라며, 다음 시리즈도 기대해주시기 바랍니다!","ogImage":{"url":"/assets/img/2024-06-30-DemystifyingSwiftUIArchitecturePartI_0.png"},"coverImage":"/assets/img/2024-06-30-DemystifyingSwiftUIArchitecturePartI_0.png","tag":["Tech"],"readingTime":4},{"title":"GSoC 2024  OpenMRS 5주차  환자 생성 및 리소스 동기화","description":"","date":"2024-06-30 19:30","slug":"2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources","content":"\n\n안녕하세요 여러분! 🌟\n\n모두가 멋진 하루를 보내고 계시길 바랍니다! 이번 주는 몇 가지 중요한 발전이 있는 흥미로운 여정이었습니다. 강조할만한 부분을 알아보도록 하죠!\n\n![이미지](/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_0.png)\n\n# OpenMRS에서 FHIR 엔드포인트를 활용한 환자 생성 🏥\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환자를 만드는 도전에 도전 중이었어요. 특히 FHIR 엔드포인트를 사용하는 것이 너무 어려웠어요. 이유는 Patient 리소스에 고유한 환자 식별자를 제공해야 했기 때문이에요. 저희의 여정을 간략히 소개할게요:\n\n# 시도한 방법:\n\n- Idgen 엔드포인트 방법: 이 방법은 idgen 엔드포인트를 호출하여 고유한 ID를 생성하고 이를 환자 리소스 페이로드와 함께 포함하는 방법이었어요. 웹 앱에선 간단하지만 오프라인 우선 애플리케이션에는 최적이 아니었어요.\n- HSU ID 방법: 이 방법은 요청 페이로드에 위치 ID를 사용하여 엔드포인트를 호출하여 세션 ID를 가져오는 것을 요구했어요. 이 세션 ID에는 사용자의 위치 정보가 포함되어 있어 쿠키로 전달되어야 했어요. 그러나 RESTful API에 대한 세션 유지는 이상적이지 않았어요.\n- Legacy-ID 식별자 솔루션: 마침내 legacy-id 식별자를 사용하기로 결정했어요. 이 방법은 값만 필요로 하기 때문에 UUID를 제공하여 고유성을 보장할 수 있어요. 연간 약 10만 명의 사용자에게 안전한 방법이에요.\n\n# 예시 FHIR 환자 리소스:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n엔드포인트:\n\n![img](/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_1.png)\n\n리소스:\n\n```js\n{\n  \"resourceType\": \"Patient\",\n  \"meta\": {\n    \"versionId\": \"1\"\n  },\n  \"name\": [\n    {\n      \"use\": \"official\",\n      \"family\": \"Jane Doe\",\n      \"given\": [\n        \"10000032\"\n      ]\n    }\n  ],\n  \"gender\": \"female\",\n  \"birthDate\": \"1928-05-06\",\n  \"identifier\": [\n    {\n      \"use\": \"official\",\n      \"type\": {\n        \"text\": \"Legacy ID\"\n      },\n      \"value\": \"dd1819e6-b0b7-4286-8941-a82a0a0fceb0\"\n    }\n  ],\n  \"address\": [\n    {\n      \"use\": \"home\",\n      \"city\": \"Unknown City\",\n      \"state\": \"Unknown State\",\n      \"postalCode\": \"Unknown PostalCode\",\n      \"country\": \"Unknown Country\"\n    }\n  ],\n  \"active\": true,\n  \"deceasedBoolean\": false\n}\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 동기화된 자원 기능 🔄\n\n저희 애플리케이션에서 환자가 등록되면 로컬에 저장됩니다. 사용자가 서버와 동기화할 때만 환자가 업로드됩니다. 데이터 손실을 피하기 위해 사용자가 환자 데이터가 동기화되었는지 알 수 있어야 합니다.\n\n![이미지](/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_2.png)\n\n# 구현 단계:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Unsynced 환자 식별: 저는 FhirEngine의 localChanges API를 사용하여 동기화되지 않은 환자를 식별하기 위한 로직을 개발했습니다. 이 API는 FHIR 자원에 적용된 로컬 변경 목록을 반환합니다. 환자 목록을 가져온 후에는 각 환자에 대한 로컬 변경 목록이 비어 있는지 확인하여(동기화된 자원을 나타냄) 이 정보를 PatientItem의 isSynced 플래그로 저장합니다.\n- UI 업데이트: 이 데이터를 사용하여 UI가 동기화 상태를 적절하게 반영합니다.\n\n# PR 링크:\n\n여기서 구현 상세 내용을 확인하세요.\n\n# 다음 주 계획 🔧\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 환자 생성 테스트 및 통합: 환자 생성 프로세스가 매끄럽게 작동하는지 확인합니다.\n- 환자 편집 기능: 환자 편집 기능을 추가 및 개선합니다.\n- UI 업데이트: 더 많은 화면에서 사용자 인터페이스를 개선하여 더 나은 사용자 경험을 제공합니다.\n\n더 많은 업데이트를 기대해주시고, 이 흥미진진한 여정을 따라와 주셔서 감사합니다! 🎉\n\n독자 여러분, 읽어 주셔서 감사합니다! 저에게 문의할 사항이 있으시면 언제든지 연락해주세요! 특히 헬스케어, 풀스택 개발, FHIR, OpenMRS Android, Open Health Stack, 노래 추천 등이라면 더욱 환영합니다. 🎵\n\nLinkedIn이나 OpenMRS Talk에서 저를 찾아보시고 GitHub에서 제 프로젝트를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_0.png"},"coverImage":"/assets/img/2024-06-30-GSoC2024OpenMRSWeek5PatientCreationSyncedResources_0.png","tag":["Tech"],"readingTime":4},{"title":"실시간 데이터 파이프라인 마스터하기 PostgreSQL에서 MinIO로 Strimzi Kafka Connect를 사용한 CDC 구현 방법  Part-1","description":"","date":"2024-06-30 19:28","slug":"2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1","content":"\n\n<img src=\"/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_0.png\" />\n\n안녕하세요! 이번 기사 시리즈에서는 쿠버네티스 환경 내에서 Kafka를 활용한 Change Data Capture (CDC)의 세계로 여러분을 안내할 예정이에요. CDC의 기본 개념을 탐구하고 매력적인 장점을 발견하며 실용적인 구현 가이드를 안내할 거예요. 이 과정에서 Kafka 기반 CDC가 데이터 아키텍처를 혁신시킬 수 있는 실제 시나리오를 탐구해볼 거에요. 실시간 데이터 스트리밍 및 통합 방법을 변화시키기 위해 준비하세요!\n\n본 기사 시리즈는 이론적 통찰과 실용적인 구현 세부 사항을 제공하기 위해 세 가지 부분으로 구성되어 있어요.\n\n부분 1: 이론적 기초 및 일반 아키텍처 : 이 섹션에서는 Change Data Capture (CDC)의 기초 개념과 현대 데이터 아키텍처에서의 중요한 역할을 탐구할 거에요. Kafka를 사용하는 이점을 특히 Strimzi와 함께 사용하여 관계형 및 NoSQL 데이터베이스, 객체 스토리지 및 기타 데이터 저장소에서 실시간 데이터 변경을 캡처하는 중앙 스트리밍 플랫폼으로 사용하는 것의 이점에 대해 논의할 거에요. 이 부분은 CDC 개념을 설명하고 Kafka Connect 클러스터 아키텍처를 심층적으로 살펴보며 CDC의 사용 사례 시나리오를 강조할 거에요. 이론적 기초를 이해함으로써 효율적이고 확장 가능한 데이터 파이프라인을 가능하게 하는 CDC의 중요성을 이해할 수 있으며, 이후 섹션에서의 실제 구현을 위한 준비를 할 수 있어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부분 2: 실제 구현 — PostgreSQL에서 Kafka로 데이터 수집\n다음으로, 실제 구현 세부 사항을 살펴보겠습니다. PostgreSQL로부터 데이터 변경을 Kafka로 수집하도록 구성된 Kafka Connect 클러스터와 같은 Strimzi 리소스를 설정하는 방법을 배우게 됩니다. 저는 커넥터 설정 및 전체 설정을 Kubernetes에 배포하는 방법을 강조하면서 구성 단계를 안내해 드리겠습니다.\n\n부분 3: 실제 구현 — Kafka에서 MinIO로 Apache Parquet 형식으로 데이터 싱크\n최종 부분은 데이터를 MinIO로 Apache Parquet 파일로 싱크하는 데 중점을 둡니다. 실시간 처리와 분석에 대비하여 준비된 데이터임을 보장합니다. 데이터 스키마 호환성과 무결성을 유지하기 위해 스키마 레지스트리를 활용하겠습니다. 이 부분에서는 데이터 싱크를 위한 Kafka 커넥터 구성, 데이터 형식 처리, 전체 솔루션을 Kubernetes에 배포하는 방법에 대한 세부 단계가 포함될 것입니다.\n\n이 글을 마치면, 카프카를 활용한 강력한 CDC 파이프라인을 Kubernetes 환경에서 효율적이고 확장 가능하게 구현하는 괜찮은 경험과 포괄적인 이해력을 얻게 될 것입니다. Part-1 주제를 계속해 보겠습니다.\n\n- Change Data Capture (CDC) 및 Kafka와의 중요성 소개\n- 사용 사례 시나리오\n- Strimzi Kafka란 무엇인가요?\n- Kafka Connect는 무엇인가요?\n- Kafka Connect 아키텍처\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Kafka를 이용한 Change Data Capture(CDC)의 소개 및 중요성\n\n— Change Data Capture(CDC)란 무엇인가요?\n\nChange Data Capture(CDC)는 데이터베이스에서 데이터가 변경되는 것을 식별하고 캡처하는 프로세스로, 이러한 변경 사항이 실시간으로 다른 시스템으로 전파될 수 있도록 보장합니다.\n\n— 왜 Kafka와 CDC가 게임 체인저인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 실시간 데이터 처리: CDC with Kafka를 사용하면 데이터 변경을 계속 캡처하고 스트리밍하여 실시간으로 데이터를 사용 가능하게 하여 분석 및 의사 결정을 위한 즉각적인 데이터 이용이 가능합니다.\n- 확장성: Kafka의 분산 아키텍처는 고 처리량과 장애 허용성을 보장하여 여러 소스를 통해 대량의 데이터 변경을 처리하는 확장성을 가집니다.\n- 데이터 생성자와 소비자의 분리: Kafka는 중개자 역할을 수행하여 데이터 생성자(데이터베이스)와 데이터 소비자(어플리케이션 및 분석 플랫폼)를 분리하여 독립적인 확장과 개발을 용이하게 합니다.\n- 원활한 통합: Kafka Connect는 다양한 데이터 소스 및 싱크와 통합하기 위한 견고한 프레임워크를 제공하여 이질적인 시스템 간에 원활한 데이터 흐름을 보장합니다.\n- 데이터 일관성과 신뢰성: CDC에서 데이터 소스 수준에서 변경을 캡처함으로써 데이터 일관성과 신뢰성을 유지하여 분산 시스템 전반에 정확하고 최신의 데이터를 유지합니다.\n- 이벤트 주도 아키텍처: CDC with Kafka는 데이터 변경이 실시간 작업과 워크플로를 트리거하는 이벤트 주도 아키텍처를 지원하여 반응성과 자동화를 향상시킵니다.\n- 지연 시간 감소: CDC와 Kafka를 사용하면 데이터 생성과 사용 가능성 사이의 지연 시간이 최소화되어 근사 실시간 분석과 운영 지능을 지원합니다.\n- 과거 데이터 재생: Kafka의 데이터 변경 저장 및 재생 기능을 통해 과거 데이터 분석 및 복구가 가능하여 유용한 통찰력을 제공하고 시나리오의 백테스팅이 가능합니다.\n- 비용 효율성: Kafka의 효율적인 데이터 스트리밍 기능을 활용함으로써 조직은 전통적인 배치 처리와 ETL 작업에 관련된 오버헤드와 복잡성을 줄일 수 있습니다.\n\n## 사용 사례 시나리오\n\n아래 시나리오에서 CDC와 Kafka를 사용하면 실시간 데이터 통합, 향상된 효율성 및 확장성을 제공하여 중요한 데이터가 항상 최신 상태로 여러 시스템 및 어플리케이션에서 접근 가능하도록 보장할 수 있습니다.\n\n1-) 실시간 재고 관리 시스템: 소매 회사가 여러 창고와 상점 전반에 걸쳐 실시간으로 재고를 최신 상태로 유지해야 하는 경우.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— Kafka를 이용한 CDC의 장점:\n\n- 실시간 업데이트: 재고 데이터가 지속적으로 업데이트되어 모든 위치에서 재고 부족 또는 과잉 상황을 방지합니다.\n- 확장성: 대량의 데이터를 효율적으로 처리하는 Kafka의 능력은 소매 환경에서 일반적인 높은 거래율을 지원합니다.\n- 통합성: 관계형 및 NoSQL 데이터베이스 및 어플리케이션과 원활하게 통합되어 전체 시스템 내에서 데이터 일관성과 정확도를 보장합니다.\n\n2-) 고객 활동 추적 시스템: 전자상거래 플랫폼은 고객 활동(페이지 조회, 제품 클릭, 구매 등)을 실시간으로 추적하여 맞춤형 추천을 제공하고자 합니다.\n\n— Kafka를 이용한 CDC의 장점:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 즉각적인 통찰력: 실시간으로 고객 활동을 캡처하고 처리하여 적시적이고 관련성 있는 추천을 제공합니다.\n- 향상된 사용자 경험: 실시간 데이터를 활용하여 플랫폼이 맞춤형 쇼핑 경험을 제공하여 고객 만족도와 참여도를 높일 수 있습니다.\n- 유연성: Kafka의 Apache Flink와 같은 처리 프레임워크와의 통합을 통해 복합 이벤트 처리와 분석이 가능합니다.\n\n3-) 재무 거래 모니터링: 은행은 사기를 탐지하고 통찰력을 제공하기 위해 실시간으로 재무 거래를 모니터링하고 분석하려고 합니다.\n\n— Kafka와 CDC의 혜택:\n\n- 사기 탐지: 실시간 모니터링을 통해 의심스러운 활동을 즉각적으로 감지하여 사기 거래의 위험을 줄입니다.\n- 규정 준수: 모든 거래 데이터가 정확하고 즉각적으로 기록되도록 보장하여 은행이 규제 요건을 충족할 수 있습니다.\n- 확장성과 신뢰성: Kafka의 고장 내성 아키텍처를 통해 고부하 조건에서도 지속적인 데이터 흐름과 처리가 가능합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4-) 주문 처리 시스템: 온라인 상점이 주문 변경에 실시간으로 반응해야 하는 여러 서비스를 통합하여 주문 처리를 최적화하고자 합니다.\n\n— 카프카를 활용한 변경 데이터 캡처(CDC)의 장점:\n\n- 효율성: 실시간 데이터 흐름을 통해 주문 관련 서비스(재고 업데이트, 알림, 배송)가 신속하게 실행되어 처리 시간을 단축시킵니다.\n- 조정: 카프카를 통해 서로 다른 마이크로서비스가 주문 변경을 소비하고 독립적으로 움직이면서도 일관되게 작동하여 전체 시스템의 효율성을 향상시킵니다.\n- 일관성: 모든 서비스 간의 데이터 일관성을 유지하여 정확한 주문 추적과 충족을 보장합니다.\n\n5-) 사용자 프로필 동기화: 소셜 미디어 플랫폼이 실시간으로 여러 시스템 간에 사용자 프로필을 동기화해야 합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n— Kafka와 함께 CDC의 이점:\n\n- 일관성: 사용자 프로필 변경 사항이 모든 시스템에 즉시 전파되어 일관된 사용자 경험을 유지합니다.\n- 통합: Kafka의 다양성은 검색 인덱스, 추천 엔진 및 캐싱 레이어와 같은 다양한 하향 시스템과의 데이터 동기화를 원활하게 수행할 수 있습니다.\n- 확장성: 소셜 미디어 플랫폼에서 일반적인 프로필 변경의 대량 처리를 다룰 수 있어 신뢰할 수 있고 효율적인 데이터 동기화를 보장합니다.\n\n## Strimzi Kafka란\n\nStrimzi Kafka는 Kubernetes에서 Apache Kafka의 배포, 관리 및 운영을 간소화하는 오픈소스 프로젝트입니다. Strimzi는 Kafka 클러스터를 생성하고 관리하기 위한 Kubernetes 네이티브 자원과 도구를 제공하여 Kafka를 클라우드 네이티브 환경에서 실행하기 쉽도록 합니다. 자동화된 배포, 스케일링, 롤링 업데이트 및 모니터링과 같은 주요 기능을 포함하여 사용자는 Kubernetes의 확장 가능성과 탄력성을 활용하여 Kafka의 강력한 메시징 및 스트리밍 기능을 사용할 수 있습니다. Strimzi를 사용함으로써 기관은 기존 Kubernetes 인프라에 Kafka를 효율적으로 통합하여 데이터 스트리밍 및 처리 기능을 향상시킬 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 카프카 커넥트 및 커넥트 클러스터 아키텍처란\n\n카프카 커넥트는 카프카 브로커와 외부 시스템(예: 데이터베이스) 간의 데이터를 스트리밍하는 통합 툴킷입니다. 플러그인 아키텍처를 사용하여 커넥터를 구현하며, 이를 통해 다른 시스템에 연결하고 데이터를 조작하기 위한 구성 옵션을 제공합니다. 플러그인에는 커넥터, 데이터 컨버터 및 변환기가 포함됩니다. 커넥터는 특정 유형의 외부 시스템과 작동하며 해당 구성에 대한 스키마를 정의합니다. 카프카 커넥트에 구성을 제공하여 커넥터 인스턴스를 생성하고, 이를 통해 시스템 간 데이터 이동 작업을 정의합니다.\n\nStrimzi는 분산 모드에서 카프카 커넥트를 운영하며, 여러 워커 팟 간에 데이터 스트리밍 작업을 관리합니다. 각 커넥터는 개별 워커에서 실행되며 해당 작업은 워커 그룹에 분산되어 확장 가능한 파이프라인을 제공합니다. 각 워커는 별도의 팟으로 실행되어 오류 허용성이 향상됩니다. 작업의 수가 워커 수를 초과하는 경우, 각 워커에 여러 작업이 할당됩니다. 워커가 실패하면 해당 작업은 자동으로 활성 워커에 재할당되어 지속적인 작동이 보장됩니다.\n\n워커는 데이터를 소스 또는 대상 시스템에 적합한 다른 형식으로 변환합니다. 커넥터 구성에 따라, 워커는 변환기를 적용하여 변환 전에 메시지를 조정하는 경우도 있습니다(예: 데이터 필터링). 카프카 커넥트에는 내장 변환기가 있지만 필요한 경우 플러그인을 통해 추가 변환을 제공할 수도 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 Kafka Connect 클러스터 아키텍처의 소스를 살펴봅시다.\n\n![image](/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_1.png)\n\n1-) 플러그인 구현:\n\n- 역할: 플러그인은 소스 커넥터를 위한 필요한 구현 자산을 제공합니다.\n- 세부 정보: Kafka Connect의 플러그인 아키텍처는 유연성과 확장성을 제공합니다. 플러그인은 커넥터 뿐만 아니라 변환기와 변환도 포함하며, 이러한 구성 요소를 통해 Kafka Connect가 다양한 외부 시스템과 상호 작용하고 필요한 대로 데이터를 조작할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n2-) Worker 및 Connector 초기화:\n\n- 역할: 단일 Worker가 소스 Connector 인스턴스를 초기화합니다.\n- 상세 내용: Worker는 Kafka Connect 클러스터의 기본 구성 요소입니다. 각 Worker 파드는 독립적으로 실행되어 설정의 분산 구조를 보장합니다. Connector가 인스턴스화되면 하나의 Worker가 이를 초기화하는 책임을 지며, 이로써 Connector가 올바르게 시작되고 수명 주기 동안 모니터링됩니다.\n\n3-) 작업 생성 및 분배:\n\n- 역할: 소스 Connector는 데이터를 스트리밍하기 위한 작업을 생성합니다.\n- 상세 내용: 초기화 후 Connector는 일련의 작업을 정의합니다. 이러한 작업은 실제 데이터 스트리밍을 처리하는 작업 단위입니다. 작업은 사용 가능한 Worker 간에 분산되어 부하를 균형 있게 분배하고 처리량을 극대화합니다. 작업의 개수는 일반적으로 워크로드 및 클러스터의 용량에 따라 정의됩니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4-) 병렬 작업 실행:\n\n- 역할: 작업은 외부 데이터 시스템을 병렬로 폴링하여 레코드를 반환합니다.\n- 세부 내용: 각 작업은 독립적으로 작동하여 외부 소스 시스템에서 데이터를 폴링합니다. 이 병렬 실행은 데이터가 효율적으로 및 실시간으로 흡수되도록 보장합니다. 작업은 계속해서 외부 시스템을 폴링하여 새로운 데이터 변화가 신속히 포착되고 처리되도록 합니다.\n\n5-) 데이터 변환:\n\n- 역할: 변환은 레코드를 조정하여 필터링하거나 다시 레이블링합니다.\n- 세부 내용: 데이터가 Kafka로 변환되어 전송되기 전에 변환되어야 할 수 있습니다. 변환은 원치 않는 데이터를 필터링하거나 필드를 다시 레이블링하거나 다른 수정을 적용하는 데 사용될 수 있습니다. Kafka Connect는 내장된 변환을 지원하지만 사용자 정의 변환은 플러그인을 통해 추가할 수 있으며, 데이터가 처리되는 방식에 유연성을 제공합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n6-) 데이터 변환:\n\n- 역할: 변환기는 레코드를 Kafka에서 사용할 수 있는 형식으로 변환합니다.\n- 상세: 변환기는 Kafka와 외부 시스템 간의 데이터를 직렬화하고 역직렬화하는 역할을 맡습니다. 이들은 데이터가 Kafka 토픽에 호환되는 형식으로 처리되도록 보장합니다. 일반적인 변환기에는 JSONConverter, AvroConverter 및 StringConverter가 포함됩니다. 이러한 변환기들은 데이터 형식의 번역을 처리하여 Kafka가 레코드를 저장하고 관리하는 것을 원활하게 만듭니다.\n\n7-) 커넥터 관리:\n\n- 역할: 소스 커넥터는 KafkaConnectors 또는 Kafka Connect API를 사용하여 관리됩니다.\n- 상세: Kafka Connectors의 관리는 Strimzi에서 제공하는 Kubernetes 사용자 정의 리소스인 KafkaConnectors 또는 Kafka Connect REST API를 통해 수행될 수 있습니다. 이러한 관리 인터페이스는 관리자가 커넥터와 작업을 생성, 구성 및 모니터링하여 데이터 통합 프로세스에 대한 전체 제어를 제공합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 구성 요소와 프로세스를 활용하면 Strimzi Kafka Connect는 견고하고 확장 가능한 데이터 스트리밍 파이프라인을 구축하여 다양한 시스템 간 실시간 데이터 통합 및 처리를 보장합니다.\n\n지금까지 모든 것이 잘 진행되었다면, Sink Kafka Connect 클러스터 아키텍처로 계속 진행합시다 :)\n\n![이미지](/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_2.png)\n\n사실 대부분의 구성 요소가 소스 커넥트 클러스터와 유사한 기능을 수행합니다. 여기서의 차이점은 작업이 관련 Kafka 토픽에서 데이터를 폴링하고 변환 및 처리 프로세스를 거친 후 외부 데이터 시스템으로 데이터를 전송한다는 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이론적 기초를 다지면서, 이제 실용적인 부분으로 진입할 준비가 되었습니다. 다가오는 섹션에서는 소망을 걸고 Kafka Connect 클러스터 설정에 실질적으로 착수할 것입니다. 먼저, PostgreSQL에서 데이터를 매끄럽게 수집하는 소스 Kafka Connect 클러스터를 생성할 것이며, 그 다음으로는 Kafka 토픽에서 데이터를 읽어 Apache Parquet 형식으로 MinIO에 저장하는 싱크 Kafka Connect 클러스터를 설정할 것입니다. 이것이 실제로 어떻게 이루어지는지 궁금하신가요? 이 구현 여정에 참여하려면 계속 읽어보세요 :)\n\nGithub : https://github.com/menendes\n\nLinkedin : https://www.linkedin.com/in/ibrahim-halil-koyuncu-b1030516a/","ogImage":{"url":"/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_0.png"},"coverImage":"/assets/img/2024-06-30-MasteringReal-TimeDataPipelinesImplementingCDCwithStrimziKafkaConnectfromPostgreSQLtoMinIOPart-1_0.png","tag":["Tech"],"readingTime":13},{"title":"Docker 단계별 가이드 Reactjs 프로젝트를 Docker로 윈도우 환경에서 로컬 설정하는 방법","description":"","date":"2024-06-30 19:27","slug":"2024-06-30-Step-by-StepGuidetoDockerLocalSetuponWindowswithaDockerizedReactjsProject","content":"\n\n<img src=\"/assets/img/2024-06-30-Step-by-StepGuidetoDockerLocalSetuponWindowswithaDockerizedReactjsProject_0.png\" />\n\n소개:\n\n도커는 응용 프로그램을 격리된 컨테이너에 배포하고 관리하는 데 도움이 되는 강력한 도구입니다. 이 안내서는 Windows에서 도커를 설정하고 React.js 프로젝트를 도커화하는 방법을 안내하여 원할하고 효율적인 개발 워크플로우를 보장합니다.\n\n도커란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커는 가벼운 격리 소프트웨어 컨테이너 내에서 애플리케이션을 배포하고 관리하는 자동화를 가능케하는 오픈 소스 플랫폼이에요. 이를 통해 응용 프로그램이 모든 환경에서 일관되게 실행되도록 보증하며, 모든 종속성을 캡슐화해요.\n\n도커 파일을 이해하고 계신가요?\n\n도커 파일(Dockerfile)은 도커 이미지를 빌드하는 방법에 대한 지시사항이 담긴 텍스트 파일이에요. 도커 이미지를 실행 가능한 이미지로 만들기 위해 기본 이미지, 애플리케이션 코드, 종속성 및 기타 설정을 지정해요.\n\n도커 이미지란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이미지는 응용 프로그램을 실행하는 데 필요한 모든 것을 포함하는 가벼운, 독립적이고 실행 가능한 소프트웨어 패키지입니다. 코드, 런타임, 시스템 도구, 라이브러리 및 설정을 포함하여 응용 프로그램을 실행하는 데 필요한 모든 것이 포함되어 있습니다. Docker 이미지는 기본 이미지에서 생성되며 추가 구성 요소로 사용자 정의할 수 있습니다.\n\n도커 컨테이너란 무엇인가요?\n\n컨테이너는 응용 프로그램과 해당 종속성을 캡슐화하는 격리된 환경입니다. 각 컨테이너는 호스트 머신에서 격리된 프로세스로 실행되며 자체 파일 시스템, 네트워킹 및 리소스를 가지고 있습니다. 하나의 도커 이미지에서 여러 컨테이너를 생성할 수 있습니다.\n\n도커 컴포즈란 무엇인가요?\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도커 Compose는 여러 개의 컨테이너로 구성된 애플리케이션을 정의하고 관리하는 도구입니다. 이를 사용하면 YAML 파일에서 여러 개의 컨테이너 설정 및 서로 통신하는 방식을 정의할 수 있습니다. 도커 Compose를 사용하면 복잡한 애플리케이션을 여러 개의 상호 연결된 컨테이너로 쉽게 실행할 수 있습니다.\n\n컨테이너 레지스트리란 무엇인가요?\n\n컨테이너 레지스트리는 컨테이너 이미지를 저장하고 공유하는 중앙 저장소입니다. 버전 관리 및 이미지 무결성을 보장하면서 컨테이너화된 애플리케이션을 안전하게 관리하고 배포할 수 있습니다. 예시로는 Docker Hub, Amazon ECR, Google Container Registry, Azure Container Registry 및 GitHub Container Registry 등이 있습니다.\n\nWindows에 Docker 설치 방법:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 도커 공식 문서인 Docker Docs를 방문해주세요.\n- 윈도우용 도커인 Docker Desktop을 다운로드하세요.\n- 윈도우에서 WSL을 구성하세요:\n\n  - \"Windows 기능 켜기 끄기\"를 검색하고 선택하세요.\n  - \"Windows 하이퍼바이저 플랫폼\"과 \"Windows용 하위 시스템 for Linux\"을 활성화하세요.\n  - 확인을 클릭하고 시스템을 다시 시작하세요.\n  - 문제가 발생하면 이 안내에 따라 WSL을 수동으로 구성하세요.\n\n4. 도커 데스크탑 설치하기:\n\n  - 다운로드한 Docker Desktop Installer.exe를 실행하세요.\n  - 설치 단계를 따라 진행하고 시스템을 재시작하세요.\n  - 자동으로 재시작하면 화면에 \"도커 구독 서비스 약정\" 대화상자가 나타납니다.\n  - 동의 버튼을 클릭하세요.\n  - 로그인하거나 로그인 없이 계속하세요.\n  - 도커 홈페이지에 오신 것을 환영합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n5. 설치 검증하기:\n\n- 명령 프롬프트를 열고 도커가 올바르게 설치되었는지 확인하기 위해 docker version 및 images를 실행합니다.\n\n```js\ndocker version\n\ndocker images\n```\n\nReact.js 프로젝트 도커화하기:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- React.js 프로젝트를 생성하세요.\n- 개발용 도커 파일을 생성하세요:\n\n- React.js 프로젝트의 루트 디렉토리에 다음 내용을 가진 Dockerfile.dev을 생성하세요\n\n```js\nFROM node:alpine\nWORKDIR /app\nCOPY package.json /app\nRUN npm install\nCOPY . /app\nCMD [\"npm\", \"start\"]\n```\n\n3. .dockerignore 파일을 생성하세요:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- React.js 프로젝트의 루트 디렉토리에 다음 내용으로 .dockerignore 파일을 만들어주세요:\n\n```js\nnode_modules\nREADME.md\n.gitignore\n```\n\n4. Docker 이미지 빌드하기:\n\n```js\ndocker build -f Dockerfile.dev -t myapp .\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- docker build: 이 명령은 Docker에게 Dockerfile에 있는 지시사항을 기반으로 새 이미지를 생성하도록 지시합니다.\n- -f Dockerfile.dev: -f 플래그는 사용할 Dockerfile의 이름을 지정합니다. 이 경우에는 Dockerfile.dev입니다.\n- -t myapp: -t 플래그는 이미지에 이름을 태그합니다. 여기서 이미지는 myapp으로 태그됩니다.\n- .: 명령어 끝에 있는 점은 현재 디렉토리인 빌드 컨텍스트를 나타냅니다.\n\n5. Docker 이미지 실행:\n\n```js\ndocker ps\n```\n\n```js\ndocker run -it --name myProject -p 3000:3000 myapp\ndocker run -it -d --name myProject -p 3000:3000 myapp\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- -i (interactive): 상호작용 모드를 유지하여 STDIN을 닫지 않습니다. 이는 대화형 프로세스에 유용합니다.\n- -t (tty): 의사-TTY를 할당합니다. 이는 터미널 상호작용에 유용합니다.\n- -d: 이 플래그는 컨테이너를 백그라운드에서 실행하고 터미널을 차단하지 않는 분리된 모드로 실행합니다.\n- --name myProject: 이 플래그는 컨테이너에 이름을 지정하여 관리를 더 쉽게 합니다. 이 경우 컨테이너의 이름은 myProject입니다.\n- -p 3000:3000: 이 플래그는 호스트의 포트 3000을 컨테이너의 포트 3000에 매핑합니다. 형식은 호스트포트:컨테이너포트입니다. 이를 통해 컨테이너 내에서 실행 중인 애플리케이션에 호스트 머신의 포트 3000을 통해 액세스할 수 있습니다.\n\nYouTube 비디오:\n도커 + React js 설정 및 구성에 대한 상세한 단계는 아래 비디오 튜토리얼을 시청하세요:\n\n결론:\nDocker는 현대 개발자들에게 귀중한 도구로, 격리된 환경에서 애플리케이션을 관리하고 배포하는 효율적인 방법을 제공합니다. 이 안내를 따라오면 다음을 배울 수 있습니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Dockerfiles, 이미지, 컨테이너, Docker Compose 및 컨테이너 레지스트리를 포함한 Docker의 기본 개념을 이해합니다.\n- WSL과 같은 필수 구성 요소를 올바르게 구성하여 Windows 기기에 Docker를 설치합니다.\n- React.js 프로젝트를 Docker화하여 일관된 이식 가능한 개발 환경을 활성화합니다.\n\n더 많은 DevOps 및 기술 관련 자습서와 통찰력을 기대해주세요!\n\n저작권 © 2024 MAC Tech Family, 판권 소유.","ogImage":{"url":"/assets/img/2024-06-30-Step-by-StepGuidetoDockerLocalSetuponWindowswithaDockerizedReactjsProject_0.png"},"coverImage":"/assets/img/2024-06-30-Step-by-StepGuidetoDockerLocalSetuponWindowswithaDockerizedReactjsProject_0.png","tag":["Tech"],"readingTime":7},{"title":"AWS Step Function을 사용한 직원 온보딩 프로세스 구축 방법","description":"","date":"2024-06-30 19:26","slug":"2024-06-30-BuildinganAWSStepFunctionforEmployeeOnboardingProcess","content":"\n\n이번 튜토리얼에서는 직원 입사 절차를 자동화하기 위해 AWS Step Function을 만들어보겠습니다. 이 과정에는 직원 레코드 작성, 문서 확인, 환영 이메일 발송, 필요 장비 할당 등이 포함됩니다.\n\n# 단계 1: 서버리스 프로젝트 설정하기\n\n먼저, Serverless Framework가 설치되어 있는지 확인하세요. 만약 없다면 npm을 사용하여 설치할 수 있습니다:\n\n```js\nnpm install -g serverless\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로 새로운 Serverless 프로젝트를 만들어보세요:\n\n```js\nserverless create --template aws-nodejs --path employee-onboarding\ncd employee-onboarding\n```\n\n# 단계 2: Serverless Step Functions 플러그인 설치하기\n\n프로젝트에 Serverless Step Functions 플러그인을 추가해보세요. 이 플러그인은 Serverless Framework를 사용하여 Step Functions을 정의하고 배포하는 데 필요합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nnpm install --save serverless-step-functions\n```\n\n# 단계 3: Serverless Framework 구성\n\nserverless.yml 파일에서 서비스를 Step Functions 플러그인을 사용하도록 구성하고 AWS 리소스와 함수를 정의합니다.\n```js\nservice: employee-onboarding\nframeworkVersion: '3'\nprovider:\n  name: aws\n  runtime: nodejs18.x\n  stage: ${opt:stage, 'dev'}\n  region: us-east-1\n  iamRoleStatements:\n    - Effect: \"Allow\"\n      Action:\n        - \"dynamodb:*\"\n      Resource: !GetAtt EmployeeTable.Arn\n    - Effect: \"Allow\"\n      Action:\n        - \"sns:*\"\n      Resource: \"arn:aws:sns:us-east-1:*:NotifyEmployee\"\nfunctions:\n  createEmployeeRecord:\n    handler: handler.createEmployeeRecord\n    environment:\n      EMPLOYEE_TABLE: !Ref EmployeeTable\n  verifyDocuments:\n    handler: handler.verifyDocuments\n  sendWelcomeEmail:\n    handler: handler.sendWelcomeEmail\n  assignEquipment:\n    handler: handler.assignEquipment\nplugins:\n  - serverless-step-functions\nstepFunctions:\n  stateMachines:\n    EmployeeOnboardingStateMachine:\n      name: EmployeeOnboardingStateMachine\n      definition:\n        Comment: \"A state machine for onboarding new employees.\"\n        StartAt: CreateEmployeeRecord\n        States:\n          CreateEmployeeRecord:\n            Type: Task\n            Resource: !GetAtt createEmployeeRecord.Arn\n            ResultPath: \"$.employee\"\n            Next: VerifyDocuments\n          VerifyDocuments:\n            Type: Task\n            Resource: !GetAtt verifyDocuments.Arn\n            ResultPath: \"$.documentVerification\"\n            Next: DocumentCheck\n          DocumentCheck:\n            Type: Choice\n            Choices:\n              - Variable: \"$.documentVerification.status\"\n                StringEquals: \"verified\"\n                Next: SendWelcomeEmail\n            Default: DocumentError\n          DocumentError:\n            Type: Pass\n            Result: \"Document verification failed\"\n            End: true\n          SendWelcomeEmail:\n            Type: Task\n            Resource: !GetAtt sendWelcomeEmail.Arn\n            ResultPath: \"$.emailStatus\"\n            Next: AssignEquipment\n          AssignEquipment:\n            Type: Task\n            Resource: !GetAtt assignEquipment.Arn\n            ResultPath: \"$.equipmentStatus\"\n            End: true\nresources:\n  Resources:\n    EmployeeTable:\n      Type: AWS::DynamoDB::Table\n      Properties:\n        TableName: EmployeeTable-${self:provider.stage}\n        AttributeDefinitions:\n          - AttributeName: employeeId\n            AttributeType: S\n        KeySchema:\n          - AttributeName: employeeId\n            KeyType: HASH\n        BillingMode: PAY_PER_REQUEST\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 상태 머신의 자세한 설명\n\n## 1. CreateEmployeeRecord\n\n- 유형: 작업\n- createEmployeeRecord 람다 함수를 호출하여 작업 수행\n- 리소스: !GetAtt createEmployeeRecord.Arn\n- createEmployeeRecord 람다 함수의 ARN\n- ResultPath: $.employee\n- 이 작업의 출력을 상태 입력의 employee 필드에 저장\n\n- 다음: VerifyDocuments\n- 이 작업이 완료된 후 VerifyDocuments 상태로 전환\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 2. VerifyDocuments\n\n- verifyDocuments Lambda 기능을 호출하여 작업을 수행합니다.\n\n## 3. DocumentCheck\n\n- 유형: Choice\n- 변수 값에 따라 분기 로직을 추가합니다.\n- 선택지:\n  - documentVerification.status 필드를 평가합니다.\n  - 값이 확인된 경우 SendWelcomeEmail 상태로 전환합니다.\n  - 기본값: DocumentError\n  - 선택지와 일치하는 것이 없는 경우 DocumentError 상태로 전환합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 4. DocumentError\n\n- 유형: Pass\n- 입력을 수정하지 않고 출력으로 전달합니다.\n- 결과: \"문서 검증 실패\"\n- 이 상태의 출력 값입니다.\n- 종료: true\n- 이 상태를 최종 상태로 표시합니다.\n\n## 5. SendWelcomeEmail\n\n- sendWelcomeEmail Lambda 함수를 호출하여 작업을 수행합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 6. 장비할당\n\n- assignEquipment 람다 함수를 호출하여 작업을 수행합니다.\n\n# 단계 4: 람다 함수 구현\n\nhandler.js 파일을 만들어 람다 함수를 정의하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n직원 레코드 생성\n\n```js\n'use strict';\nconst AWS = require('aws-sdk');\nconst docClient = new AWS.DynamoDB.DocumentClient();\nmodule.exports.createEmployeeRecord = async (event) => {\n  const EMPLOYEE_TABLE = process.env.EMPLOYEE_TABLE;\n  const employee = JSON.parse(event.body);\n  const params = {\n    TableName: EMPLOYEE_TABLE,\n    Item: {\n      employeeId: employee.employeeId,\n      name: employee.name,\n      role: employee.role,\n      email: employee.email,\n    },\n  };\n  await docClient.put(params).promise();\n  return {\n    statusCode: 200,\n    body: JSON.stringify(employee),\n  };\n};\n```\n\n문서 확인\n\n```js\nmodule.exports.verifyDocuments = async (event) => {\n  const { employeeId, documents } = JSON.parse(event.body);\n  const status = documents && documents.length > 0 ? 'verified' : 'unverified';\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ employeeId, status }),\n  };\n};\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n↓\n\n웰컴 이메일 전송\n\n```js\nconst sns = new AWS.SNS();\nmodule.exports.sendWelcomeEmail = async (event) => {\n  const { email } = JSON.parse(event.body).employee;\n  const params = {\n    Message: '회사에 오신 것을 환영합니다!',\n    Subject: '환영합니다',\n    TopicArn: process.env.SNS_TOPIC_ARN,\n  };\n  await sns.publish(params).promise();\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ status: '이메일 전송됨' }),\n  };\n};\n```\n\n장비 할당\n\n```js\nmodule.exports.assignEquipment = async (event) => {\n  const { employeeId } = JSON.parse(event.body);\n  // 장비 로직 여기에 작성\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ status: '장비 할당됨', employeeId }),\n  };\n};\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 4: 서버리스 서비스 배포하기\n\n서버리스.yml 파일 구성을 완료한 후 서버리스 서비스를 배포하세요. 이 단계에서는 람다 함수를 배포하고, DynamoDB 테이블과 같은 필요한 AWS 리소스를 생성하며, Step Functions 스테이트 머신을 배포합니다.\n\n```js\nserverless deploy\n```\n\n배포 중에는 서버리스 프레임워크가 제공된 설정에 따라 Step Functions 스테이트 머신을 만듭니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 단계 5: 상태 머신의 ARN 가져오기\n\n배포된 후에는 AWS 관리 콘솔 또는 CLI에서 Step Functions 상태 머신의 ARN (Amazon 리소스 이름)을 얻을 수 있습니다.\n\n# 단계 6: IAM 역할 문장 업데이트\n\nserverless.yml 파일의 IAM 역할 문장을 Step Functions 상태 머신의 ARN으로 업데이트하세요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```yaml\niamRoleStatements:\n  - Effect: \"Allow\"\n    Action:\n      - \"states:*\"\n    Resource: \"arn:aws:states:us-east-1:123456789012:stateMachine:EmployeeOnboardingStateMachine\"\n```\n\n# 단계 7: 서버리스 서비스 다시 배포하기\n\nIAM 역할 문장을 업데이트한 후에 변경 사항을 적용하기 위해 서버리스 서비스를 다시 배포하세요.\n\n```sh\nserverless deploy\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 요약\n\n이 튜토리얼은 직원 온보딩 프로세스를 자동화하기 위한 AWS Step Function을 생성하는 방법을 보여줍니다. Serverless Framework와 Serverless Step Functions 플러그인을 활용하여 작업, 분기 논리, 오류 처리를 포함한 복잡한 워크플로우를 정의하고 배포하여 온보딩 프로세스를 효율적이고 확장 가능하게 만들 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-30-BuildinganAWSStepFunctionforEmployeeOnboardingProcess_0.png"},"coverImage":"/assets/img/2024-06-30-BuildinganAWSStepFunctionforEmployeeOnboardingProcess_0.png","tag":["Tech"],"readingTime":10},{"title":"TGE 및 Alpha Realm으로 가는 길 개척하는 방법","description":"","date":"2024-06-30 19:25","slug":"2024-06-30-ForgingthePathtoTGEandAlphaRealm","content":"\n\n![2024-06-30-ForgingthePathtoTGEandAlphaRealm_0](/assets/img/2024-06-30-ForgingthePathtoTGEandAlphaRealm_0.png)\n\n안녕하세요, KOKODI 워리어 여러분! 토큰 생성 이벤트(TGE)와 알파 릴리스를 향한 여정이 전속력으로 진행 중입니다. KOKODI 우주에서 무슨 일이 일어나고 있는지 함께 알아봐요!\n\n# 최신 업데이트 및 TGE\n\nBeam과의 파트너십을 발표해 기쁘게 생각합니다. 이를 통해 빠른 트랜잭션, 강화된 보안, 그리고 견고한 전리품 경제를 제공하게 되었습니다. 게다가 Merit Circle이 직접 투자자로 합류했습니다. Beam의 기술적 지원과 함께, KOKODI는 Merit Circle의 web3 게임에 대한 전문 지식, 혁신적인 프로젝트 지원에 대한 약속, 그리고 개발 자금을 확보하기 위한 1~2차 VCs의 접근을 통해 혜택을 받을 것입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 가치 있는 연결과 명망 있는 파트너십을 구축하기 위해, 펌프 앤 덤프 스키마를 피하면서 투자자를 신중하게 선정합니다. 이 방식은 자금 조달 과정을 늦추기는 하지만 장기적인 성장과 성공에 중요한 역할을 합니다.\n\n장기적인 지속가능성에 대한 약속은 우리가 거래소 상장 전략을 재평가하게 되어, 단기간의 흥분보다는 지속 가능한 성장에 집중하고 있음을 의미합니다. 튼튼한 출시를 위해 TGE 창구를 올해 가을로 이동시켰습니다. 더 많은 세부사항을 기대해 주세요!\n\n# KOKODI 알파: 전투의 맛을 먼저 맛보세요\n\n2024년 11월에 KOKODI 알파가 출시됩니다! 여기에서 기대할 수 있는 것들입니다:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 4개의 종족 중 하나를 선택하여 독특한 캐릭터를 만들어보세요\n- 2가지 스릴 넘치는 게임 모드: 4대4 아레나 및 탈출 배틀 로얄\n- 경험치, 전리품 및 $KOKO 토큰을 획득하세요\n- 웹 상점에서 자산을 거래하세요\n- 친구를 초대하면 보상을 받을 수 있습니다\n- NFT 소유자를 위한 독점적인 코스메틱 보너스\n\n# KOKODI의 미래를 함께 만들어보세요\n\n알파 버전을 준비하기 위해 24/7 이용 가능한 4대4 아레나 모드가 포함된 테스트 빌드에 액세스 권한을 부여합니다. 이 테스트 단계는 게임 플레이, 게임 경제 기능을 개선하고 소중한 피드백을 수집하는 데 도움이 될 것입니다.\n\n## 주요 포인트:\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 7월부터 11월 알파 릴리스까지 새로운 기능이 소개될 예정입니다.\n- 테스트 기능에는 XP 포인트, 웹 상점, 추천 시스템, 밸런스 조정, 그리고 개선된 그래픽이 포함되어 있습니다.\n- 추가 기능은 가능해질 때마다 공지될 예정입니다.\n\n## NFT 소유자를 위한 정보:\n\n- 모든 KOKODI NFT 소유자들은 테스트 빌드에 접속할 수 있습니다.\n- 적어도 하나의 KOKODI NFT를 소유하고 있다면, 디스코드에서 티켓을 제출하여 접속하세요.\n- 게임 밤과 개발자 스트림 중에도 테스트 버전을 플레이할 수 있습니다.\n\n지금 바로 접근 권한을 확보하세요! 데브, 커뮤니티 멤버, 특별 게스트와 함께 플레이할 수 있는 다가오는 이벤트에 참여해보세요. 다음 주에 다양한 기회가 기다리고 있어요!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 다가오는 이벤트:\n\n- 게임 나이트: 7월 3일 수요일, 오후 6:00–8:00 CET\n- DevStream + 질의응답: 7월 5일 금요일, 오후 6:00–8:00 CET\n\n당신의 궁금증을 해결하고 싶다면 DevStream에 참여해주세요! 여기에서 질문을 제출하고 디스코드에서 시청하세요. 최고의 질문은 소셜 포인트를 획득하게 됩니다!\n\nKOKODI의 미래를 함께 만들 준비가 되었습니다. 여러분의 여정이 지금 시작됩니다!\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 코코디 소개\n\n코코디는 성인들이 버린 애니메이션 판타지 세계에 세팅된 서드 파티 액션 PvP 게임입니다. 이 게임에서 8세의 아이들이 서로와 몬스터들과 교전하여 근접 및 원거리 무기와 마법을 사용하여 사탕, 명성, 그리고 그들의 클랜을 위한 평판을 얻습니다.\n\n공식 코코디 x 빔 파트너십 발표 확인하기\n\n# 빔 소개\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n머릿말이 게이밍에 초점을 맞춘 블록체인인 Beam은 Merit Circle에서 최근 출시되었습니다. Beam은 게이머와 개발자가 모여 게이밍 산업의 미래를 함께 만들어가는 활기찬 커뮤니티 중심 생태계를 구현합니다.\n\nBeam에 대해 더 자세히 알아보세요.\n\n## Merit Circle 소개\n\nMerit Circle은 분산형 자율 조직(DAO)으로, 게이밍 산업의 미래를 형성하고 장려하는 조직입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n웹3 게임 플랫폼 및 이니셔티브에 대해 알아보세요.\n\n메리트 서클에 대해 더 알아보기","ogImage":{"url":"/assets/img/2024-06-30-ForgingthePathtoTGEandAlphaRealm_0.png"},"coverImage":"/assets/img/2024-06-30-ForgingthePathtoTGEandAlphaRealm_0.png","tag":["Tech"],"readingTime":5},{"title":"단돈 7만 원으로 집중력 향상하는 방법 FocusSupreme","description":"","date":"2024-06-30 19:24","slug":"2024-06-30-AchieveFocusforOnly70FocusSupreme","content":"\n\n\n![이미지](/assets/img/2024-06-30-AchieveFocusforOnly70FocusSupreme_0.png)\n\nFacebook 포스트에 새로운 댓글이 달렸어요. 어떤 \"Bitcoin 투자자\"가 당신을 유인하려고 하고, 새로운 Gmail 알림이 있습니다. 차량이 밖에서 우는 소리, 창문 아래에서 아이들이 소리를 지르고, 서버는 배경에서 울리고 있습니다. 월요일 10시입니다. 당신은 한 줄의 코드도 쓰지 않았습니다. 모니터를 응시합니다... 어쩌면 다른 YouTube 동영상이 도움이 될지도 모릅니다. 스물 분 후... 아마 오늘도 안 되겠네요, 친구. 이제 이메일함에 또 다른 10통의 이메일이 들어왔네요. 그 사기꾼이 힌트를 잡지 못하고, 여전히 — 아직 코드는 없네요.\n\n우리 모두 다 거기에 다녔지만, 여기 제 해결책이 있어요.\n\n# Apple iPod\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n![이미지](/assets/img/2024-06-30-AchieveFocusforOnly70FocusSupreme_1.png)\n\n우리는 모두 학교에서 멋진 아이팟을 가진 모든 멋진 친구들을 기억합니다 (나도 포함 - 그걸 위해 열심히 일했어요!) 그리고 그 싼 USB 플래시 MP3 드라이브들이 얼마나 멋지지 않았는지, 맞죠? 맞죠? 나 나이 드가 아니에요, 알았죠!\n\n어쨌든, 어릴 때 우리는 이 iPod라는 것을 가졌다구요. 그것들은 음악, 팟캐스트, 오디오북을 듣는 것만 허용하며 몇몇은 게임이나 비디오를 지원하기도 했어요.\n\n하지만 물론, Spotify 소유주 다니엘 에크는 수기방을 통해 그 기가바이트 단위로 음악을 불법으로 다운로드하는 것에 막을 두었습니다. 아마도 uTorrent에 관여해왔기 때문일 거에요, 정말 그의 일을 알 것 같아요.\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\n<img src=\"/assets/img/2024-06-30-AchieveFocusforOnly70FocusSupreme_2.png\" />\n\n현재 주로 찾는 아이팟은 아이팟 비디오(5.5세대) 또는 7세대입니다. 사용하는 OS에 따라 라이브러리에서 다루는 노래 수나 5.5세대의 부드러운 소리를 원할 수 있습니다. 저는 7세대의 강한 소리를 선호하며 구입했습니다. 또한 크기 차이도 있지만, 이에 대해서는 다른 글에 쓸 예정이니 그렇게 큰 문제는 아닙니다.\n\n# 왜\n\n<img src=\"/assets/img/2024-06-30-AchieveFocusforOnly70FocusSupreme_3.png\" />\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아직도 iPod을 사고 싶지 않으시군요? 20년 된 종이같은 무게를 들고 $70을 쓰기는 꺼려지는군요, 맞죠?\n\n하지만, 이 장치가 당신에게 무엇을 제공할 수 있는지 말해드릴게요.\n\n모든 그 알림 소음에 대해 이야기했던 것들을 기억하시나요? 그냥 헤드폰을 착용하고, 새 iPod에는 연결 기능이 없기 때문에 원자폭탄 말고는 당신의 집중력을 떨치지 않을 거예요.\n\n기술의 진화 과정에서 우리는 무언가를 잃어버렸습니다. UX 향상 요소들이 당신의 시선을 빼앗기고, 알림들이 당신을 앱으로 다시 끌어들이며, 인터넷은 일상을 이전보다 더 연결되게 만들었습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 기억하세요 — 일을 해야하고, 그 코드를 작성하고, 돈을 벌어야 합니다. 그리고 일론과 로건이 고통을 겪으면서 상상한 새로운 광대 자동차를 사는 꿈을 이루어야 합니다 (또는, 음식을 먹을 수도 있지만요... 그런 것도 괜찮아요)!\n\n그렇게 되어 가면서, 마침내 집중할 수 있게 되어서 얼마만큼 오랫동안 집중했는지 놀라게 될 것입니다. 1시간을 달성하고 흐름에 몰두하게 될 것입니다.\n\n# 결론\n\n![이미지](/assets/img/2024-06-30-AchieveFocusforOnly70FocusSupreme_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 내 이야기야. 아무것도 도움이 되지 않았어. DND 모드, 집중 앱, 그 특별한 런처들... 모두 1-2천 달러짜리 장비를 죽은 할머니 엉덩이처럼 쓸모없게 만들었지.\n\n이 중 어느 것이라도 익숙하다면, #FocusSupreme 여정에 참여하는 것을 강력히 추천해. 내가 어떻게 도움을 받았는지, 그리고 어떻게 하지 않았는지를 쓸 거야. 어떻게 삶을 최적화하여 더 많은 글을 쓰고 BS에 덜 시간을 들였는지에 대해.\n\n우선 DND 모드부터 시도해 볼 수 있어. 동일한 일을 할 수 있는 싼 MP3 플레이어를 사거나, 다른 이어플러그를 시도할 수도 있겠지. 그러나 결국 더 필요한 것이 생길 거야, 아니면 심지어 EDC에 역사의 한 부분을 갖게 될 수도 있어.\n\n이어플러그 - $1 Aliexpress\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n환영합니다. 이 글을 좋아하셨다면 박수를 치지 말고 다른 글도 확인해보세요.\n\n그런데 우리 Redbubble 샵에서 (노트북) 스티커 중 하나를 구할 수도 있어요.","ogImage":{"url":"/assets/img/2024-06-30-AchieveFocusforOnly70FocusSupreme_0.png"},"coverImage":"/assets/img/2024-06-30-AchieveFocusforOnly70FocusSupreme_0.png","tag":["Tech"],"readingTime":4},{"title":"모바일 개발 플랫폼과 그들의 소프트웨어 아키텍처 패턴들 비교","description":"","date":"2024-06-30 19:22","slug":"2024-06-30-CommonMobileDevelopmentPlatformsandtheirSoftwareArchitecturePatterns","content":"\n\n# 소개\n\n모바일 개발은 올바른 방법으로, 적절한 도구와 필요한 소프트웨어 아키텍처로 각 과정을 구현할 때 더 쉬워집니다. 애플리케이션 개발에 사용되는 많은 모바일 개발 플랫폼이 있습니다. 일부는 네이티브 애플리케이션 개발용이고, 다른 일부는 크로스 플랫폼 애플리케이션 개발용입니다. 두 가지 주요 네이티브 개발 플랫폼은 Kotlin, Java, C++을 지원하는 Android Studio(안드로이드 개발을 위한 공식 통합 개발 환경)와 Objective-C 및 Swift를 지원하는 iOS 개발을 위한 공식 통합 개발 환경 인 Xcode입니다. 일부 주요 크로스 플랫폼 플랫폼으로는 Flutter, React Native, Xamarin, Ionic 등이 있습니다. Unity, Unreal Engine, Flutterflow 및 Appgyver 같은 게임 개발 플랫폼 및 노코드 개발 플랫폼도 있습니다.\n\n![Common Mobile Development Platforms and their Software Architecture Patterns](/assets/img/2024-06-30-CommonMobileDevelopmentPlatformsandtheirSoftwareArchitecturePatterns_0.png)\n\n## 목차\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 소개\n- 네이티브 개발 플랫폼\n- 안드로이드 스튜디오\n- 소프트웨어 아키텍처 패턴\n- 엑스코드\n- 소프트웨어 아키텍처 패턴\n- 크로스 플랫폼 개발 플랫폼\n- 플러터\n- 소프트웨어 아키텍처 패턴\n- 일부 아키텍처의 장단점\n- 개인 경험 및 HNG 인턴십 여정\n- 결론\n\n# 네이티브 개발 플랫폼\n\n주요 모바일 애플리케이션 운영 체제 중 두 가지는 안드로이드 OS와 애플 iOS이며, 이 두 운영 체제를 위한 네이티브 개발 플랫폼은 안드로이드 스튜디오와 Xcode입니다.\n\n# 안드로이드 스튜디오\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안드로이드 스튜디오는 안드로이드 애플리케이션 개발을 위한 공식 IDE로, Kotlin, Java, C++를 지원합니다. (또한 dart, Kotlin Multiplatform Mobile KMM 및 Jetpack Compose의 사용을 허용합니다) 모바일 애플리케이션을 개발할 수 있습니다.\n\n# 소프트웨어 아키텍처 패턴\n\n안드로이드 개발에서 사용되는 몇 가지 소프트웨어 아키텍처 패턴은 MVC(Model-View-Controller), MVP(Model-View-Presenter)입니다.\n\nMVC(Model-View-Controller):\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 모델: 데이터를 관리하고 애플리케이션의 로직을 관리합니다.\n- 뷰: 사용자 인터페이스 구성 요소를 나타내며 사용자에게 표시되는 데이터를 표시합니다.\n- 컨트롤러: 모델과 뷰 사이의 연결 역할을 합니다.\n\nMVP (Model-View-Presenter):\n\n- 모델: 이 경우 모델은 데이터를 관리합니다.\n- 뷰: 뷰는 데이터를 표시하고 사용자 입력을 처리하는 역할을 담당합니다.\n- 프레젠터: 모델로부터 데이터를 검색하고 뷰를 업데이트합니다.\n\n단방향 데이터 흐름 (UDF):\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 이건 주로 데이터가 상태에서 유저 인터페이스로의 단일 방향으로 흐르는 Jetpack Compose에서 주로 사용됩니다.\n\n## Xcode\n\nXcode은 iOS 앱 개발을 위한 공식 통합 개발 환경으로, Objective-C와 Swift를 지원합니다. 코드 편집기, 그래픽 인터페이스 디자이너, 디버거 및 iOS 시뮬레이터가 포함되어 있습니다.\n\n## 소프트웨어 아키텍처 패턴\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안드로이드와 마찬가지로 iOS에도 애플리케이션 개발에 구현된 동일한 소프트웨어 아키텍처 패턴이 있습니다. 이러한 아키텍처 중 일부는 MVC (Model View Controller), MVP (Model View Presenter) 및 MVVM (Model View ViewModel)입니다.\n\nMVVM (Model View ViewModel):\n\n이 패턴은 안드로이드 개발 플랫폼에서 다루지 않은 것처럼 Model, View 및 ViewModel이 있으며, 각 역할은 아래와 같습니다.\n\n- Model: 데이터 표현 및 비즈니스 로직을 제공합니다.\n- View: 데이터를 보이게 하고 최종 사용자와 상호 작용합니다.\n- ViewModel: 뷰에 제시될 데이터를 관리하고 UI 관련 데이터를 처리합니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 크로스 플랫폼 개발 플랫폼\n\n일부 주요 크로스 플랫폼 플랫폼은 Flutter, React Native, Xamarin 및 Ionic입니다. 이러한 플랫폼은 코드를 한 번 작성하고 다른 플랫폼에서 실행하는 개념을 허용합니다.\n\n# Flutter\n\nFlutter는 Google에서 만든 크로스 플랫폼 애플리케이션 개발 플랫폼으로, Dart 언어를 사용하는 단일 코드 베이스로 작성하여 Android, iOS, Web 및 데스크톱과 같은 플랫폼으로 컴파일할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 소프트웨어 아키텍처 패턴\n\n## BLoC (Business Logic Component) Pattern\n\nBLoC(비즈니스 로직 컴포넌트)는 플러터에서 널리 사용되는 아키텍처 패턴으로, 사용자 인터페이스와 비즈니스 로직을 분리하는 데 중점을 둡니다. 데이터 흐름을 처리하기 위해 스트림과 시크를 사용합니다. 플러터에서 '위젯'으로 알려진 사용자 인터페이스 구성 요소는 BLoC 레이어와 상호 작용하여 데이터를 받아오고 이벤트를 보냅니다. BLoC 레이어는 로직을 보유하고 이벤트를 처리하며 앱 상태를 업데이트합니다. 이 패턴은 재사용성과 테스트 가능성을 향상시키며 응용 프로그램을 보다 반응적으로 만듭니다.\n\n## Provider Pattern\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n플러터에서 널리 사용되는 또 하나의 패턴은 Provider 패턴입니다. 이 패턴은 의존성 주입 개념을 기반으로 하며 상태를 쉽게 관리할 수 있는 방법을 제공합니다. Provider 클래스는 데이터 원본 역할을 하며 다른 위젯들은 이 데이터에 대한 액세스 및 업데이트를 할 수 있습니다. Provider 패턴을 사용하면 개발자들은 여러 화면 간에 상태를 쉽게 공유하고 관리할 수 있어서 코드의 모듈성을 향상시키고 번거로운 코드를 줄일 수 있습니다.\n\n# 일부 아키텍처의 장단점\n\n# MVC 아키텍처의 장점\n\n- 애플리케이션 개발이 빨라집니다.\n- 여러 개발자가 협업하고 함께 작업하기 쉽습니다.\n- 애플리케이션 업데이트가 쉽습니다.\n- 애플리케이션에 올바르게 작성된 다수의 수준이 있기 때문에 디버깅이 쉽습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# MVC 아키텍처의 단점\n\n- 어느 순간 확장하기 어려워질 수 있습니다.\n- MVC 아키텍처를 이해하기 어려울 수 있습니다.\n- 메소드에 엄격한 규칙을 따라야 합니다.\n\n# MVVM 아키텍처의 장점\n\n- 개발하기 쉽습니다.\n- 테스트가 쉽습니다.\n- 유지보수가 쉽습니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# MVVM 아키텍처의 단점\n\n- 디버그하기 어려움\n- 복잡함\n\n# Business Logic Component (BLoC)의 장점\n\n- UI와 로직을 분리하기 쉬움\n- 코드를 테스트하기 쉬움\n- 코드를 재사용하기 쉬움\n- 성능이 좋음\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 비즈니스 로직 컴포넌트 (BLoC)의 단점\n\n- 더 많은 보일러플레이트\n\n# 개인 경험 및 HNG 인턴십 여정\n\n기술을 사랑하고 창작하는 것을 좋아하는 사람으로서, Android 네이티브 개발부터 시작해 Kotlin과 XML을 사용하여 플러터를 사용한 이동 앱 개발을 배우는 도전에 나섰습니다. 그러나 자학한 사람이기 때문에 이동 개발에 대한 이해를 더 많이 필요로 했던 중요한 영역 중 몇 가지를 놓칠 수도 있다고 생각했습니다. 그래서 글로벌 시장에 준비되었는지 알고 싶어졌고, 그 이유로 HNG11 인턴십에 합류하기로 결정했습니다. HNG11 인턴십은 이동 개발 능력을 확인하고 글로벌 시장에 준비되었는지 판단할 수 있도록 도와주는 급속한 성장 인턴십입니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인턴십은 시기 적절한 것입니다. 멘토의 안내나 이겨야 할 마감 기한이 없을 때 관심이 흩어질 수 있습니다.\n\n## 결론\n\n모바일 개발은 올바른 도구와 지식, 각 모바일 개발 플랫폼의 올바른 아키텍처에 대한 이해와 함께 진행되면 간단하고 쉬워집니다. HNG 인턴십을 통해 모바일 개발 여정에서 선두에 서 있기 위한 이러한 요구 사항을 충족시키고 전략에 앞서 나아갈 수 있도록 준비할 것입니다.","ogImage":{"url":"/assets/img/2024-06-30-CommonMobileDevelopmentPlatformsandtheirSoftwareArchitecturePatterns_0.png"},"coverImage":"/assets/img/2024-06-30-CommonMobileDevelopmentPlatformsandtheirSoftwareArchitecturePatterns_0.png","tag":["Tech"],"readingTime":8},{"title":"SwiftUI에서 접을 수 있는 섹션을 사용한 리스트 만드는 방법","description":"","date":"2024-06-30 19:21","slug":"2024-06-30-SwiftUIlistwithcollapsiblesections","content":"\n\n리스트는 많은 데이터를 보여주는 좋은 방법입니다. 섹션은 이를 그룹화하는 데 유용합니다. 변수, 프로그래밍, 그리고 접을 수 있는 섹션을 어떻게 만들 수 있을까요?\n\n리스트를 그룹화하는 한 가지 방법은 사이드바를 가지고 다양한 섹션을 숨기고 보여주는 것입니다. 이는 앱에서 유용한 리스트만 보여주기 위해 당신과 사용자가 도움이 됩니다.\n\n# 간단한 방법\n\niOS14에서는 섹션 상태 변수를 위한 optional binding parameter를 도입했습니다. 이것은 .liststyle sidebar와 함께 사용되어 자동으로 섹션을 숨기고 보여줍니다.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\n@State private var isExpandedAllSeas: Bool = true\n....\n\nVStack {\n    List {\n       Section(\n           isExpanded: $isExpandedAllSeas,\n           content: {\n              ForEach(allSea) { sea in\n                  HStack {\n                     Image(systemName: \"water.waves\")\n                     Text(sea.name)\n               }\n       }\n       .onDelete(perform: allSeaDelete)\n       .onMove(perform: allSeaMove)\n       },\n       header: {\n           Text(\"All seas\")\n       })\n                 \n    }\n    .listStyle(.sidebar)\r\n```\n\n상태 변수의 초기 설정을 통해 접히거나 펼쳐진 섹션으로 시작할 수 있습니다.\n\n# 더 어려운 방법\n\n만약 이차원 데이터 배열을 가지고 있고 섹션의 수가 다른 경우에는 어떻게 하면 될까요?\n\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n부울(bool) 타입의 상태 변수를 사용하는 것으로는 문제를 해결할 수 없어요. 이렇게 하면 모든 섹션이 닫혀 있거나 열려 있게 됩니다.\n\n`isExpanded`가 예상하는 타입인 `Binding<Bool>`이 필요합니다. 따라서 값에 대한 getter 및 setter 속성을 주의 깊게 처리해야 합니다.\n\n예를 들어 몇 개의 해양을 나타내는 이차원 데이터로 시작해볼까요? 대양 지역(OceanRegion) 예시입니다.\n\n```js\n@State private var oceanRegions: [OceanRegion] = [\n        OceanRegion(name: \"태평양\",\n                    seas: [Sea(name: \"오스트랄라시안 지중해\"),\n                           Sea(name: \"필리핀 해\"),\n                           Sea(name: \"코랄 해\"),\n                           Sea(name: \"남중국해\")]),\n        OceanRegion(name: \"대서양\",\n                    seas: [Sea(name: \"미국 지중해\"),\n                           Sea(name: \"사르가소 해\"),\n                           Sea(name: \"카리브 해\")]),\n        OceanRegion(name: \"인도양\",\n                    seas: [Sea(name: \"벵갈만\")])\n ]\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그러면 약간 다른 상태 변수가 필요합니다.\n\n```js\n@State private var isExpanded: Set<String> = []\n```\n\n확장된 섹션의 모든 해양 지역 이름이 포함된 문자열 집합을 사용하고 있습니다. 이제 OceanRegions에서 섹션과 각 섹션마다 일부 Seas가 있는 List를 구성할 수 있습니다.\n\n```js\nVStack {\n    List {\n        ForEach(oceanRegions) { region in\n            Section(\n                isExpanded: Binding<Bool> (\n                    get: {\n                        return isExpanded.contains(region.name)\n                    },\n                    set: { isExpanding in\n                        if isExpanding {\n                            isExpanded.insert(region.name)\n                        } else {\n                            isExpanded.remove(region.name)\n                        }\n                    }\n                ),\n                content: {\n                    ForEach(region.seas) { sea in\n                        Text(sea.name)\n                    }.onDelete(perform: { indexSet in\n                        delete(indexSet: indexSet, region: region.id)\n                    })\n                },\n                header: {\n                    Text(region.name)\n                }\n            )\n        }\n    }\n    .listStyle(.sidebar)\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 섹션의 축소 상태가 변경될 때 지역 이름을 삽입하고 제거해야 하기 때문에 State 변수인 isExpanded를 직접 사용할 수 없습니다.\n그래서 이를 위해 isExpanded가 기대하는 Bool 유형의 제네릭 Binding을 사용하고 있습니다.\n\n```js\nisExpanded: Binding<Bool> (...)\n```\n\n이제 getter와 setter 로직이 필요합니다. 이겁니다. 섹션의 region.name을 사용합니다. 이유는 그겁니다. region.name이 고유하기 때문입니다. 물론 더 복잡한 시나리오에서는 uuid를 사용할 수도 있습니다.\ngetter는 boolean을 반환하며, 이 boolean은 State 변수에서 나왔기 때문에 Binding`Bool`입니다.\n반면에 setter는 섹션이 확장되면 region.name을 String으로 Set에 추가하고, 섹션이 축소되면 region.name을 제거합니다.\n\n```js\nisExpanded: Binding<Bool> (\n               get: {\n                   return isExpanded.contains(region.name)\n               },\n               set: { isExpanding in\n                   if isExpanding {\n                       isExpanded.insert(region.name)\n                   } else {\n                       isExpanded.remove(region.name)\n                   }\n               }\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 설정으로 모든 섹션이 처음에 접혀 있는 상태인 하나의 공개된 포인트가 있습니다. 초기 상태 isExpanded가 빈 Set이기 때문입니다.\n\n```js\n@State private var isExpanded: Set<String> = []\n```\n\n필요한 모든 데이터가 준비되어 있고, 우리는 이것을 고유한 init 함수와 연결하기만 하면 됩니다.\n\n```js\n// @State private var isExpanded: Set<String> = []\n@State private var isExpanded: Set<String>\ninit() {\n        _isExpanded = State(initialValue: Set(oceanRegions.map { $0.name }))\n    }\n```\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n초기 isExpanded 상태를 채우려면 oceanRegions 배열에서 데이터를 매핑해야 합니다.\n\n그리고 이렇게 하면 oceanRegions 배열의 모든 섹션이 확장된 상태로 표시됩니다.\n\n<img src=\"/assets/img/2024-06-30-SwiftUIlistwithcollapsiblesections_0.png\" />","ogImage":{"url":"/assets/img/2024-06-30-SwiftUIlistwithcollapsiblesections_0.png"},"coverImage":"/assets/img/2024-06-30-SwiftUIlistwithcollapsiblesections_0.png","tag":["Tech"],"readingTime":6},{"title":"알고리즘 트레이딩 플랫폼을 Rust로 18개월 재구축 후 후회한 이유","description":"","date":"2024-06-30 19:20","slug":"2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret","content":"\n\n## NexusTrade - AI-Powered Algorithmic Trading Platform\n\n저는 어린이자 희망 넘치는 러스트 팬이었습니다. 서류상으로 러스트는 신이 디자인한 프로그래밍 언어와 같았습니다. 러스트는 가장 빠르고 안전한 프로그래밍 언어 중 하나입니다.\n\n러스트가 완벽한 언어라고 생각하는 사람이 많았습니다. 온라인에서 러스트 프로그래밍 언어에 대해 검색하면 압도적으로 긍정적인 의견을 만나게 될 것입니다. 매체의 모든 안내서, 레딧의 모든 게시물, 스택 오버플로우의 모든 답변이 빛나고 있습니다.\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_0.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n주어진 이유로 TypeScript에서 떨어지기로 결정했고, 오픈소스 알고리즘 트레이딩 시스템 전체를 Rust로 다시 작성하기로 했습니다.\n\n# Rust에 중립적인 평가를 내린 적이 있어요. 그걸 철회합니다.\n\n저는 4개월 전 Rust에 대한 제 경험에 대해 썼습니다. 제 마지막 글에서 저는 속도와 열거형 및 강력한 유형화와 같은 언어 설계의 일부 측면을 정말 좋아하는 반면, 그 언어를 정말 좋아하지는 않았다고 결론 내렸습니다. 제 글은 Reddit에서 가혹한 비평을 받았는데, 그 중 하나는 제 글을 작성할 때 ChatGPT를 사용했다고 비난하는 높은 투표를 받은 댓글이 포함되어 있었어요.\n\n![2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_1.png](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_1.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n포스팅 후에 Rust에 공정한 기회를 주지 않았다고 생각했어요. 아마도 그냥 순진했거나 잘못된 기대로 들어왔던 걸지도 몰라요.\n\n이제 언어를 좀 더 오래 사용해본 뒤, 자신있게 한 가지 결론을 낼 수 있어요…\n\n이 언어는 정말 쓰레기야.\n\n# Rust에서 정말 싫어하는 점\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 Rust가 무슨 열망인지에 대한 기사를 찾고 있다면 인터넷 어디든 찾아보세요. 이 언어에 대해 중립적인 정보를 찾기 어려울 겁니다. 이 기사는 이 게으른 언어에 대한 제 혐오에 집중한 랜트일 겁니다.\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_2.png)\n\n## 끔찍하고 장황하며 직관적이지 않은 구문 및 의미론\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_3.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아무도 Rust가 극악한 의미론을 가지고 있다고 말한 적이 있다면 당신 얼굴을 향해 거짓말을 하고 있어요. 어떤 부분들은, 만일 극도로 강력한 큰 언어 모델에 접근할 수 없다면, 함수를 작성하는 것이 문자 그대로 불가능해질 수 있어요. 저는 run_transaction 함수에서 where 절을 찾는 데 90분을 쓰고 싶지 않아요. 단지 제 미친 함수를 작성하고 싶을 뿐이에요.\n\n결국, 제가 도우미 함수 아이디어를 완전히 포기해야 했어요, 왜냐하면 코드를 컴파일할 수 없었거든요. 사람들이 Rust의 가장 큰 강점으로 주장하는 것(오류를 제거하기 위한 엄격한 컴파일러)은 Rust의 가장 큰 결함 중 하나예요. 그냥 가비지 컬렉터를 주시고, 제가 하고 싶은 대로 하게 해주세요!\n\n반면에, 만약 Go로 이 같은 함수를 작성한다면, 다음과 같이 보일 거예요:\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_4.png)\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함수의 핵심은 상대적으로 동일하지만, 코드가 정상적으로 작동하는 방법을 알아내기 위해 역처 엄청 하실 필요가 없어요. 그냥 작동해요! \n\n## 엄청난 오류 처리\n\nRust는 오류 처리에 대해 정말 멋진 일을 합니다. unsafe 언랩을 피한다면, 코드가 실행되고 계속 실행될 것이라고 확신할 수 있어요. NilPointerExceptions나 처리되지 않은 오류는 더 이상 발생하지 않죠. 좋지 않나요! (그렇죠?)\n\n잘못되었어요. 왜냐하면 데이터가 잘못되거나 예기치 못한 일이 발생할 때, 일이 어째서 그렇게 된 건지 알아내기 위해 고군분투해야 해요. 아마 제가 바보인 건지, 스택 트레이스를 활성화하는 방법을 모르는 건지 모르겠어요. 하지만 어플리케이션에서 오류가 발생하면, 왜 그런 일이 일어났는지 전혀 모르겠어요.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_5.png\" />\n\n그와 대조적으로 Python과 같은 언어는 정확히 무엇이 발생했는지를 당신에게 알려주는 아름다운 예술같은 스택 추적을 제공합니다. Go에서도 errors.Wrap(...)를 사용하여 응용 프로그램 전체의 오류 스택을 볼 수 있습니다. 아마도 나는 제 바보일지도 모릅니다, 왜냐하면 Rust에서 오류를 만나면 어떤 일이 발생했는지 이해하려고 하느라 혼란스러워합니다. 제 응용 프로그램 전체에 eprintln!(...)이 흩어져 있어야 합니다.\n\n사실, 아니죠. 저는 바보가 아닙니다. 이것은 결함이 있는 언어 디자인입니다.\n\n## 화가 나는 커뮤니티\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n핫한 주장: 러스트 커뮤니티는 가식적으로 친절하고 멋진 모습을 내세운 것만큼 실제로 그렇지 않을 수도 있어요. 그들은 자기들이 좋아하는 언어에 결함이 있다고 말해주는 걸 싫어하는 허세 부리는 사람들이라고 할 수 있어요.\n\n![이미지](/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_6.png)\n\n예를 들어, 저는 Rust 서브레딧에서 MongoDB Rust 크레이트로 에러 핸들링을 개선하는 방법에 대해 질문했더니 다음과 같은 답변을 받았어요:\n\n- 포스트그레스로 바꾸세요 (그래, 몇 개의 구리 에러 메시지 땜에 전체 데이터베이스 설계를 다시 하겠지)\n- 왜 MongoDB를 쓰는 거야? (나는 그것이 좋아. 다음 질문은?)\n- MongoDB는 고(Go)와 파이썬(Python)에서도 나쁘죠 (어쩌면 그렇겠지만, TypeScript에서는 괜찮아요. 그리고 네 뭐라고 하는 건 내 질문에 대한 대답이 되지 않아요)\n- (거의 없는) 실제로 도움이 되는 에러 메시지 개선 제안\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nRust와 같이 사이코패스 같은 프로그래밍 커뮤니티는 없다고 생각해. 이 언어의 엄청난 학습 곡선, 장황함, 형편없는 오류 메시지, 엉뚱한 구문, 의심스러운 언어 디자인 선택과 같은 큰 결함들을 모두 무시하고 있어. 그들은 개발자의 능력 문제일거라고 주장하는데, 나는 그것이 미친 짓이라고 생각해!\n\n# 마지막으로\n\n모든 이야기를 한 마디로 정리하면, Rust에는 몇 가지 장점이 있다. 빠르다는 점... 음, 그게 대부분이야.\n\n아마 안전한 측면이 있다고 해야겠군. C++과 비교해 보면 명백히 더 나은 언어지만, 다른 언어(예: Go)와 비교할 때는 \"안전성\"이 오히려 단점이라고 생각해. 내 어플리케이션이 실행하는데 몇십 밀리초 더 걸리더라도, 개발 시간이 절반으로 줄어든다면 더 나은 것 같아.\n\n<!-- ui-station 사각형 -->\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n밝은 면에서 말하자면, Go로 앱을 개발한다고 선택한 나는 아마 후회를 할 것이다. \"만약 더 빠를 수 있다면?\" 라고 생각할 것이고, \"Rust가 빵을 썰어 먹기 좋은 제품이라는 또 다른 기사가 있네. 어떻게 이런 실수를 했지!\" 라고 스스로 생각할 것이다.\n\n적어도 이제 Rust를 알게 되어 어떤 것이든 배울 수 있다고 느낀다. 혹은 그냥 재미로 OCaml을 배울 수도 있지 않을까? Rust보다 그렇게 나쁠리가 없을 텐데?\n\n읽어 주셔서 감사합니다! 알고리즘을 트레이딩하고 인공지능에 관심이 있다면 오로라의 인사이트로 구독하세요! Rust가 얼마나 빠른지 확인하려면 오늘 NexusTrade에 계정을 만들어보세요!","ogImage":{"url":"/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_0.png"},"coverImage":"/assets/img/2024-06-30-Ispent18monthsrebuildingmyalgorithmictradingplatforminRustImfilledwithregret_0.png","tag":["Tech"],"readingTime":7}],"page":"1","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}