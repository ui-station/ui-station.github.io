{"pageProps":{"posts":[{"title":"인터뷰 경험 Zomato  SDE 1  Android","description":"","date":"2024-06-19 10:40","slug":"2024-06-19-InterviewExperienceZomatoSDE1Android","content":"\n<img src=\"/assets/img/2024-06-19-InterviewExperienceZomatoSDE1Android_0.png\" />\n\n- **지원 과정**: Zomato는 추천을 통해서만 채용합니다. LinkedIn으로 채용 소식을 받아 해당 기회에 지원한 뒤, 이전의 경험을 토대로 가장 혁신적인 기술 기업 중 하나인 Zomato로 진입하게 되었습니다. 간단한 이력서 교환을 통해 잊을 수 없는 모험이 시작되었습니다.\n- **전화 인터뷰**: 연락을 시작한 후 1주일 뒤에 EM님과 전화로 대화를 나누었습니다. 인터뷰 과정에 대해 상세히 이야기해 주셨습니다. 저의 현재 역할부터 제 경험까지 세밀하게 살펴보는 질문을 통해 이 과정은 첫 번째 인터뷰로 이어졌습니다.\n- **첫 번째 라운드**: 이 라운드는 주로 Android 분야에서의 기본 내용에 초점을 맞추었습니다. Coroutines Internals부터 Performance Optimisation에 이르기까지 다양한 주제를 탐구했습니다. Activity Lifecycle, RecyclerView, Views, View Model Internal 및 작동 방식 등 Android와 관련된 중요한 주제를 논의한 후 App 성능 최적화 및 Android 주변의 다른 최적화 내용으로 이어졌습니다. Android에 대한 토론 이후, 인터뷰어는 문제 해결 능력을 테스트하기 위해 DSA 질문을 하였습니다. 해결 방법에 대해 설명해 달라는 요청을 받았고, 또 다른 해결책에 대해 물었습니다.\n- **두 번째 라운드**: 이 라운드에서 인터뷰어는 모바일 시스템 디자인부터 시작하여 작은 Zomato 애플리케이션 기능을 설계하도록 요청했습니다. 그 후 Coroutines 및 Threads에 관한 몇 가지 질문을 하였으며, 몇 가지 디자인 패턴을 구현해 보라는 요청도 있었습니다. 시스템 디자인 후에는 Leetcode 중급 문제를 제시하고 Google 문서에 솔루션을 작성하도록 요청했습니다.\n- **세 번째 라운드**: 두 번째 라운드 후 몇 주 뒤에 고용 관리자 라운드가 예정되었습니다. 이 라운드에서는 기대치 설정 및 보수 및 근무지에 대해 논의합니다.\n\n2일 후에 제가 입사 제안서를 받았습니다. 이 글이 도움이 되었다면 아래의 박수 버튼을 눌러 알려주세요. LinkedIn에서도 팔로우해 주시면 감사하겠습니다.\n\n추신: Medium에서는 50번 박수를 두드릴 수 있습니다! 아이콘을 길게 눌러보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음은 어떤 것을 더 작성해주세요? ✍️\n","ogImage":{"url":"/assets/img/2024-06-19-InterviewExperienceZomatoSDE1Android_0.png"},"coverImage":"/assets/img/2024-06-19-InterviewExperienceZomatoSDE1Android_0.png","tag":["Tech"],"readingTime":2},{"title":"앱에 대한 자부심  안드로이드에서 GraphQL 사용해보기","description":"","date":"2024-06-19 10:39","slug":"2024-06-19-PrideinYourAppTryingOutGraphQLonAndroid","content":"\n![이미지](/assets/img/2024-06-19-PrideinYourAppTryingOutGraphQLonAndroid_0.png)\n\n모두들, 요즘은 프라이드 달이에요! LGBTIQA+ 커뮤니티 구성원으로서, 이번 달은 좋으면서도 스트레스를 받는 시기예요. 누군가 무슨 일을 일으키려 할지 예측할 수 없어요. 이번 달은 정말 몇몇 나쁜 사람들을 끌어모을 것 같아요. 그리고 유럽에서 논할 우파의 급부상까지... 시작도 못하겠네요.\n\n오래전부터 안드로이드에서 GraphQL을 시도해보고 싶어했는데, 이 Pride Flag API를 발견하면서 이제 내가 그때가 된 것 같았어요. API(그리고 GraphQL)를 시도하고 블로그 글을 써서 프라이드를 기념하는 좋은 방법이죠!\n\nGraphQL에 대해 조금 소개하자면: 저는 과거에서 GraphQL에 대해 이야기하며 공개 연설 경력을 시작했어요 (JavaScript도요. 제 밝혀지지 않은 비밀이죠.) 재미있었고 정말 좋았어요. 물론, 어떠한 기술을 사용할지 고려할 때 항상 장단점이 있지만, 그래도 정말 좋아했어요. 어느 밋업에서 \"GraphQL에 대해 물어봐주세요\"라는 문구가 적힌 티셔츠를 받았는데, 아마 그 저의 가장 멋진 티셔츠였을 거예요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안녕하세요!\n\n안드로이드로 전환했을 때는 GraphQL을 안드로이드와 통합하는 방법을 배울 필요성을 느끼지 못했어요. 그래서 그동안 시도해보고 싶었는데, 이제야 좋은 방법을 찾아 해볼 기회를 찾았어요. 함께 시작해봐요!\n\n# GraphQL\n\nGraphQL이라는 단어를 처음 들어보셨다면, 이것은 그래프 형태로 API를 구축하는 쿼리 언어로 대안적인 방법입니다.\n\nGraphQL API를 통해 필요한 것만 요청할 수 있습니다. 그래서 항상 모든 것을 반환하는 REST API와 달리 GraphQL API는 요청한 값만 반환합니다. 그리고 그래프 기반으로 데이터를 중첩하여 하나의 쿼리로 가져올 수 있어요. 예를 들어 작가, 그의 책, 그리고 책 속 캐릭터를 예로 들 수 있는데, REST API에서는 세 번의 요청이 필요하죠 (물론 API에 따라 달라질 수 있어요).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGraphQL은 데이터를 쿼리, 변경 또는 구독하는 세 가지 작업을 제공합니다. REST와 비교하면, 쿼리는 GET 요청과 일치하고, 변경은 데이터를 변경하는 다른 모든 요처과 일치하며, 구독은 양방향으로 작동합니다 - 예를 들어, 웹소켓과 같이요.\n\n이 블로그 포스트의 맥락에서는 데이터를 쿼리할 것입니다. 사용 가능한 작업 및 일반적인 GraphQL에 대해 더 알고 싶다면, GraphQL 문서로 이동하세요.\n\nGraphQL을 사용하기 위해 우리는 Apollo Kotlin(이전 Apollo Android)을 사용할 것입니다. 이 라이브러리는 타입 안전하며 Kotlin 멀티플랫폼과 호환됩니다.\n\n# 의존성 및 스키마 가져오기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nApollo Kotlin을 시작하려면 프로젝트에 몇 가지 종속성을 추가해야 합니다:\n\n```js\n// 프로젝트 수준의 build.gradle.kts\n\nplugins {\n  id(\"com.apollographql.apollo3\").version(\"3.8.4\")\n}\n```\n\n그리고\n\n```js\n// 모듈 수준의 build.gradle.kts\n\ndependencies {\n  implementation(\"com.apollographql.apollo3:apollo-runtime:3.8.4\")\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 패키지들의 버전 번호는 반드시 동일해야 합니다.\n\n의존성에 추가하여 생성된 모델을 위한 패키지 이름을 추가해야 합니다:\n\n```js\n// module-level build.gradle.kts\n\napollo {\n    service(\"service\") {\n        packageName.set(\"com.example\")\n    }\n}\n```\n\n많은 프로젝트에서는 그레이들 파일을 동기화하게 됩니다. 그러나 이 프로젝트는 다릅니다; 여전히 GraphQL 쿼리의 스키마가 필요합니다. 여러 옵션이 있지만 외부 API를 통해 스키마를 내려받는 것이 가장 쉽습니다. 스키마를 src/main/graphql에 저장해야 하며, 이 작은 프로젝트의 경우에는 다음 명령어를 사용하여 이 작업을 수행합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n./gradlew :app:downloadApolloSchema --endpoint= 'https://pride.dev/api/graphql' --schema=app/src/main/graphql/schema.graphqls\n```\n\n스키마를 얻었다면 Gradle 파일을 동기화하고 데이터 쿼리를 계속합니다.\n\n# 데이터 쿼리\n\n이 작은 앱에서는 데이터를 읽고 싶습니다 — 따라서 GraphQL 용어로는 쿼리하려고 합니다. 모든 속성이 필요하지 않으므로 필요한 것만 포함한 쿼리를 정의합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nquery FlagQuery {\n  allFlags {\n    name\n    year\n    svgUrl\n  }\n}\n```\n\nApollo Kotlin을 사용하면 모든 쿼리에 이름이 지정되어 있어야 합니다. 이름이 없는 쿼리가 있으면 오류가 발생할 수 있어요. 믿어요, 제 경험이죠.\n\n이 쿼리는 API에서 사용 가능한 모든 플래그를 가져옵니다. 플래그의 이름, 연도 및 SVG URL이 필요하기 때문에 쿼리에 이러한 속성을 작성합니다.\n\nAndroid 프로젝트에 쿼리를 추가하려면 먼저 src/main/ 폴더에 파일을 만들어야 합니다. 이 폴더는 스키마가 있는 폴더와 동일합니다. 파일 이름을 FlagQuery.graphql로 지정하고 쿼리를 추가합니다. 앱이 빌드 될 때 자동으로 실행되는 작업을 통해 Apollo는 쿼리에 대한 모델을 생성합니다. 그러니 앱을 빌드하고 나면 쿼리 모델을 사용할 수 있을 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 시점에서 AndroidManifest에 인터넷 권한을 추가해야 한다는 것을 상기시키고 싶어요. 그렇게 하지 않으면, 다음 단계가 더 복잡해질 거에요. 믿어줘요, 알아요.\n\n추가해야 하는 내용을 상기시키기 위해 여기에 있어요. 나처럼 검색 엔진을 사용하지 않아도 괜찮아요:\n\n```js\n// AndroidManifest.xml\n\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```\n\n자, 이제 쿼리가 준비되었는데, 이것을 UI에 어떻게 연결할까요? 답은 GraphQL 클라이언트입니다. 데이터를 쿼리하는 데 사용할 수 있어요. 이 데모를 위해 간단하게 만들고 있으니, GraphQL 클라이언트를 정의하고 데이터를 뷰 모델에서 쿼리할 것이에요. 제작용 앱에서는 아마 레이어 구조가 더 복잡할 거에요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 클라이언트를 정의합니다:\n\n```js\n// GraphQLClient.kt\n\nconst val API_ENDPOINT = \"https://pride.dev/api/graphql\"\n\nval apolloClient = ApolloClient.Builder()\n    .serverUrl(API_ENDPOINT)\n    .build()\n```\n\n뷰 모델에서는 먼저 UI에서 사용할 상태를 정의합니다:\n\n```js\n// FlagsViewModel.kt\n\ndata class FlagsUiState(\n    val loading: Boolean = true,\n    val flags: List<FlagQuery.AllFlag> = emptyList(),\n    val currentFlag: FlagQuery.AllFlag? = null,\n)\n\nclass FlagsViewModel : ViewModel() {\n    private var _state = MutableStateFlow(FlagsUiState())\n    val state = _state.asStateFlow()\n    ...\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAPI에서 받은 모든 플래그를 저장하고 상세 페이지에서 현재 플래그를 표시하려고 합니다. 이를 위해 상태에 플래그 및 현재 플래그 속성이 있습니다. 두 속성 모두 (FlagQuery.AllFlag)은 Apollo Kotlin에 의해 생성된 형식입니다.\n\n모든 플래그를 쿼리하려면 ViewModel 내부에 다음과 같은 함수를 정의하세요:\n\n```js\n// FlagsViewModel.kt\n\nsuspend fun getFlags() {\n    val flagsQuery = apolloClient\n        .query(FlagQuery())\n        .execute()\n\n    _state.update { currentState ->\n        currentState.copy(\n            loading = false,\n            flags = flagsQuery.data?.allFlags ?: emptyList(),\n        )\n    }\n}\n```\n\n따라서 플래그를 가져오려면 apolloClient.query(...)를 호출하는 중단 함수가 필요하며, 이 함수 내에서 이전에 정의한 FlagQuery와 함께 실행해야합니다. 성공하면 데이터 속성에서 데이터를 반환하고 해당 데이터를 사용하여 상태를 업데이트할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 현재 상태에 플래그를 저장하고 싶다고 언급했었습니다. 이를 설정하는 것은 GraphQL 매직 없이 간단한 함수입니다:\n\n```js\n// FlagsViewModel.kt\n\nfun setFlag(flag: FlagQuery.AllFlag) {\n    _state.update {\n        it.copy(\n            currentFlag = flag,\n        )\n    }\n}\n```\n\n# UI에 대해 간략히\n\nUI 측면에서는 매우 간단한 작업을 수행하고 있습니다: 플래그 목록을 표시한 다음 상세 뷰로 이동합니다. GraphQL과 관련이 없으므로 데이터를 상태로 전달하는 것은 이 블로그 포스트의 범위를 벗어납니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기에 경험이 어떻게 보이는지 보여주는 비디오가 있어요:\n\nUI 코드를 확인하고 싶다면, Flag Explorer 리포지토리로 이동해보세요.\n\n# 마무리\n\n이 블로그 포스트에서는 GraphQL과 안드로이드 프로젝트에서의 활용 방법에 대해 논의했습니다. 예를 들어, Pride Flag API에서 프라이드 플래그를 가져오는 작은 앱을 만들었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트에 GraphQL을 추가하는 것은 생각보다 꽤 간단했습니다. 어떤 이유에서인지 더 복잡할 거라고 생각했는데요. 글 처음에 언급한 대로 저는 GraphQL에 대해 호감을 가지고 있어요, 그래서 실제 프로젝트에서 사용해보면 멋질 것 같아요. 앞으로 어떤 일이 일어날지 기대되네요!\n\nGraphQL에 대해서 어떻게 생각하세요? 사용해보신 적이 있나요?\n\n# 블로그 포스트에서의 링크\n\n- 프라이드 플래그 API\n- GraphQL 문서\n- 아폴로 코틀린\n- 플래그 익스플로러\n","ogImage":{"url":"/assets/img/2024-06-19-PrideinYourAppTryingOutGraphQLonAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-PrideinYourAppTryingOutGraphQLonAndroid_0.png","tag":["Tech"],"readingTime":9},{"title":"2024년을 위한 Kotlin Mobile의 최고의 10가지 클린 코드 팁","description":"","date":"2024-06-19 10:36","slug":"2024-06-19-MyTop10CleanCodeTipsforKotlinMobilein2024","content":"\n<img src=\"/assets/img/2024-06-19-MyTop10CleanCodeTipsforKotlinMobilein2024_0.png\" />\n\n당신의 코드에 즉시 적용할 수 있는 팁입니다.\n\n요즘에는 '클린 코드'가 좋은 프로그래밍 관행의 표식이자 동시에 인기 있는 유행어가 되었습니다. 수많은 지침과 잘 지어진 원칙들이 존재하는데, 때로는 서로 모순될 수도 있습니다. 예를 들어 SOLID 원칙을 따르면 테스트하기 쉬운 코드를 만들 수 있지만, 그것들을 지나치게 엄격하게 사용하면 코드가 너무 많은 작은 클래스로 나뉘어져 가독성이 떨어지고 확장 및 유지 보수가 어려워질 수 있습니다.\n\n싱클레어 베이직부터 파스칼, 델파이, 얼랭을 거쳐 모바일 애플리케이션을 위해 Objective-C와 Java, 그리고 이제 Kotlin과 Swift로 이어지는 애플리케이션 개발의 오랜 이야기를 가지고 있습니다. 제가 진로 중 최근에 일한 여러 기술들을 살펴보면, 오늘부터 당신이 코드의 품질을 향상시키기 위해 사용할 수 있는 여러 기술을 채택했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 모든 원칙과 팁 중에서 꼭 기억해야 할 중요한 한 가지가 있습니다:\n\n이것은 코드를 완벽하게 정리했지만 이를 출시하지 않았다면 모든 노력이 물거품이 될 수 있다는 것을 의미합니다.\n\n이를 명심하고 앱을 개발하고 출시해 주세요. 계속해서 코드를 검토하고 재구성하며 개선해 나가세요. 다음 10가지 팁은 앱을 출시하는 데만 도움을 주는 것이 아니라 끊임없는 다듬기에 갇히지 않도록 도와줍니다.\n\n# 1. 프로젝트 파일 구성하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n프로젝트의 파일 구조에 영향을 미치는 여러 가지 널리 논의된 코드 아키텍처가 있습니다. 가장 널리 인식되는 것 중 하나는 Clean Architecture입니다. 그러나 이는 Hexagonal이나 Onion과 같은 다른 아키텍처가 나쁘다는 것을 의미하는 것은 아닙니다. 기존의 아키텍처는 대부분의 개발자가 직면하는 일반적인 문제를 해결하지만, 아키텍처의 선택은 개발 요구 사항에 적합한 것과 팀이 효과적으로 지원할 수 있는 것에 따라 다릅니다.\n\n주의해야 할 점은 일관성 있는 명명 규칙을 준수하고 파일 이름의 길이에 대해 두려워하지 말아야 합니다.\n\n일관된 명명 패턴 채택이 중요합니다. 이름은 파일의 내용과 목적을 즉각적으로 파악할 수 있어야 합니다. 예를 들어:\n\n- NetworkManager, NetworkHelper: 네트워크 관련 작업을 위한 이름입니다.\n- MainScreen, OtherScreen: 구성 가능한 화면에 대한 이름입니다(또는 old-style의 MainActivity, MainFragment).\n- MainViewModel, MenuViewModel: ViewModel 클래스에 대한 이름입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 명명 규칙은 MainActivity, MainScreen 및 MainViewModel과 같은 다른 구성 요소 간의 관계를 손쉽게 추적할 수 있도록 합니다. 서로 다른 패키지에 위치해 있더라도요.\n\n## 효과적인 패키지 구조\n\n한 번 더 강조하지만, 기존 아키텍처에서 선택할 수 있지만, 절대적으로 그 중 어느 것도 법이라는 것을 기억하세요.\n\n제 프로젝트에서는 내게 쉽게 탐색할 수 있는 방식으로 구조를 사용했습니다. UI 패키지는 계층적으로 구성되어 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-MyTop10CleanCodeTipsforKotlinMobilein2024_1.png)\n\n이렇게 관련된 구성 요소가 함께 그룹화되어 있으면 코드베이스를 빠르게 탐색하고 이해하기 쉬워집니다.\n\n# 2. 하나, 둘… 리팩토링!\n\n즉, 세 번 까지의 규칙입니다. 이 규칙은 코드를 리팩토링할 시간을 이해하는 데 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 무언가를 처음으로 코딩할 때는 그냥 시작하세요.\n- 두 번째로 반복할 때는 주의 깊게 유지하세요.\n- 세 번째는? 멈추고 리팩터링하세요.\n\n이 규칙은 조기 추상화와 코드 중복의 함정을 피하면서 유연한 아키텍처를 구축하는 데 도움이 됩니다. 이 접근 방식은 지나치게 복잡한 아키텍처로 이어질 수 있는 과도한 엔지니어링이나 부족한 엔지니어링으로 해결책을 개발하는 과정에서 발생할 수 있는 문제점을 피하면서 유지보수 가능한 코드를 개발하는 데 도움이 됩니다.\n\n## 3. 깊은 중첩 피하기: 화살표 머리모양 안티-패턴 대응\n\n깊은 중첩은 여러 개의 반복문 및 조건문과 같은 제어 구조의 계층이 서로 중첩되어 있을 때 코드의 가독성과 명확성을 상당히 떨어뜨릴 수 있습니다. 코드를 이해하고 유지하는 것을 더 어렵게 만들 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n깊게 중첩된 예제는 복잡성을 보여줍니다:\n\n```js\nfun getUserRole(userInput: UserInput): String? {\n    if (userInput.login.isNotEmpty()) {\n        if (userInput.password.isNotEmpty()) {\n            if (isUserExist(userInput.login)) {\n                if (isPasswordValid(userInput.password)) {\n                    return userRole(userInput.login)\n                } else {\n                    return UserRole.Unknown\n                }\n            }\n            return UserRole.Unknown\n        }\n        return UserRole.Unknown\n    }\n    return UserRole.Unknown\n}\n```\n\n이 코드 구조는 각 중첩된 레이어를 주의 깊게 탐색해야 하기 때문에 이해하고 수정하기 어렵습니다. 또한 종료 로직 및 반환 값과 관련된 버그 발생 가능성이 증가합니다.\n\n조기 종료를 사용하여 코드를 리팩토링하면 구조를 단순화하고 가독성을 높일 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ngetUserRole 함수는 사용자 입력을 받아와서 해당 사용자의 역할을 반환하는 함수입니다. 입력된 사용자 정보가 비어있는 경우 Unknown 역할을 반환하고, 사용자가 존재하지 않는 경우 NotExists 역할을 반환합니다. 입력된 비밀번호가 유효하지 않은 경우 Unauthorized 역할을 반환합니다. 그 외의 경우에는 해당 사용자의 역할을 반환합니다.\n\n코드를 리팩토링하여 불필요한 복잡성을 제거하고 코드를 더 직관적이고 이해하기 쉽게 만들었습니다. (최적화가 필요한 미려한 코드는 아니지만, 이제 명확하게 보입니다).\n\n대안으로 Kotlin의 when 구문을 사용할 수도 있습니다:\n\nfun getUserRole(userInput: UserInput): String? {\n    return when {\n        userInput.login.isEmpty() -> UserRole.Unknown\n        userInput.password.isEmpty() -> UserRole.Unknown\n        !isUserExist(userInput.login) -> UserRole.NotExists\n        !isPasswordValid(userInput.password) -> UserRole.Unauthorized\n        else -> userRole(userInput.login)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n깊은 중첩을 피하고 초기 종료 및 when 문과 같은 전략을 활용함으로써 코드를 더 접근 가능하고 유지 보수성이 높아지며 작업하기 쉬워집니다. 이 방식은 코드의 전반적인 가독성을 향상시키는 구조를 제공합니다. 또한 어떤 코드가 리팩토링이 필요한지 감지하는 데 도움이 될 수 있습니다.\n\n# 4. 코드 설명서 작성\n\n이것은 논란이 많은 주제입니다. 많은 사람들이 \"코드는 유머와 같다. 설명이 필요하면 나쁜 것\"이라고 말하며 일반적으로 주석이 바람직하지 않다고 생각하기 시작합니다.\n\n그러나 몇 년 동안 유지 보수 가능한 코드를 제공하려면 문서화해야 합니다. 그러나 각 줄마다 주석을 다는 것은 좋은 방법이 아닙니다 :)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 주의해야 할 때 코멘트를 작성해야 하는 경우\n\n- 메소드나 프로퍼티의 이름이 명확하지 않은 경우에 문서화합니다. 복잡한 알고리즘이나 복잡한 로직을 설명합니다.\n- 타사 라이브러리와의 통합 지점에 대해 문서화합니다. Retrofit을 문서화할 필요는 없지만, 인터셉터를 작성한다면 설명적인 이름을 지어 간단히 무엇을 하는지와 언제 추가해야 하는지에 대한 간단한 설명을 추가하는 것이 좋습니다.\n- 때로는 코드에 특정 문제에 대한 비표준적인 해결책이나 회피책이 포함될 수 있습니다. 이슈 트래커나 버그 보고서에서 작업에 대한 링크를 추가하는 것이 좋을 수 있습니다.\n- 코드 블록의 목적이나 의도를 설명하는 간략한 코멘트가 특히 크거나 복잡한 함수에서 좋을 수 있습니다.\n\n가끔은 \"기다려! 우리는 깔끔한 코드에 대해 이야기하고 있어. 함수가 복잡하거나 이해하기 어렵다는 것은 의도한 것이 아니잖아\"라고 말할 수 있습니다.\n\n깔끔한 코드가 중요하지만, 코드 명확성에 대한 절대적인 해결책은 아니며, 특히 데이터 암호화나 사용자 지정 하드웨어 통합과 같이 복잡한 시스템에서는 더욱 그렇습니다. 이러한 경우에 잘 쓰여진 코드조차 밀집하고 완전히 자명하지 않을 수 있습니다. 균형을 잡는 것이 중요합니다 - 코드를 보완하기 위해 코멘트를 사용하여 코드만으로는 충분하지 않은 부분에 통찰력을 제공합니다. 코드를 가능한 한 읽기 쉽게 만드는 데 중점을 둘 뿐만 아니라 복잡한 섹션을 명확하게 해주기 위해 코멘트가 필요한 경우를 인정하는 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어:\n\n```kotlin\ndata class HardwareConnection(\n    val ip: String,\n    val port: Int\n) {\n    /**\n     * 명령을 보낸 후 연결을 닫습니다. 연결이 닫히지 않은 경우,\n     * 디바이스는 마지막 명령을 보낸 후 60초 동안 차단됩니다.\n     * 이 차단은 디바이스 측에서 발생합니다.\n     */\n    fun sendCommand(command: String) {\n        val connection = HardwareSDK.connect(ip, port)\n        connection.sendCommand(command)\n        connection.close()\n    }\n}\n```\n\n그러나 너무 많이 설명하는 것은 코드를 혼란스럽게 만들고 가독성을 떨어뜨릴 수 있습니다. 명백한 문장에 주석을 추가하거나 기본적인 작업을 설명할 필요는 없습니다. 주석은 가치를 더해야 하며 이미 명확한 함수와 변수명에서 알 수 있는 내용을 반복해서 설명하는 것은 피해야 합니다. 각 주석이 코드를 압도하지 않으면서 명확한 목적을 제공하는 적절한 지점을 찾는 것이 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n// 사용자의 나이를 저장하는 변수를 정의합니다\nvar userAge: Int = 25\n```\n\n또는\n\n```kotlin\nclass UserManager(private val database: Database) {\n    fun createUser(user: User) {\n        // 사용자를 데이터베이스에 저장합니다\n        database.save(user)\n    }\n\n    fun deleteUser(userId: String) {\n        // 사용자를 데이터베이스에서 삭제합니다\n        database.delete(userId)\n    }\n}\n```\n\n## 5. 전역 상태와 싱글톤의 한계를 설정하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱을 개발할 때는 종단 없이 존재하는 값을 또는 인스턴스를 관리해야 하는 경우가 많습니다.\n\n이 데이터를 관리하기 위해 싱글톤을 사용하는 것은 간단해 보일 수 있습니다. 그러나 명확한 코드는 사람이 이해하기 쉽다는 것뿐만이 아니라 빌드 시스템과 테스트에도 직관적이어야 합니다.\n\n전역 상태는 여러 문제를 발생시킬 수 있습니다:\n\n예측 불가능한 동작: 예를 들어, 컨텍스트 객체나 런타임 권한을 저장하는 경우, 이 값들은 시간이 지남에 따라 변경될 수 있습니다. 전역 상태는 이러한 상태를 항상 최신 상태로 유지할 것을 보장하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n복잡한 테스트: 전역 변수의 복잡한 상태를 모방하는 것은 어려울 수 있고, 테스트들이 서로 간섭할 수 있습니다. 이는 신뢰할 수 없거나 잘못된 테스트 결과로 이어질 수 있습니다.\n\n추적이 어려움: 전역 상태가 언제 어떻게 변경되었는지 추적하기 어려울 수 있으며, 이는 디버깅을 복잡하게 만들 수 있습니다.\n\n동시 액세스 문제: 이는 디버깅과 수정이 어려운 충돌을 일으킬 수 있습니다.\n\n재생성/재초기화 문제: 안드로이드가 앱을 중지하고 다시 시작하기로 결정하는 경우, 전역 상태의 모든 변수가 제대로 초기화될 것을 보장할 수 없습니다. 이는 Kotlin의 비-널러블 필드에서 심지어 Null Pointer Exception이 발생할 수 있어 디버깅이 매우 어려워질 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n싱글톤 또는 글로벌 객체를 사용하는 대신, 앱의 구성 요소 사이에 클래스 인스턴스를 전달하거나 데이터를 직접 저장하지 않고 특정 소스에서 데이터를 검색하는 도우미/서비스 클래스를 사용하는 것을 고려해보세요. Koin 또는 Hilt와 같은 의존성 주입 프레임워크를 사용하면 객체 관리와 생성을 간편화할 수 있습니다.\n\n가끔은 싱글톤을 완전히 피하는 것이 불가능할 수 있습니다. 이런 경우가 있을 때마다 데이터를 분석하여 실제로 전역 상태나 싱글톤이 필요한지 확인하세요. 예를 들어:\n\n- 데이터가 특정 액티비티, 프래그먼트, 화면 또는 뷰 모델 라이프사이클 내에서만 필요한 경우 해당 라이프사이클에 연결해야 합니다.\n- 앱 상태를 재시작 중에 유지해야 하는 경우, Helper/Service 및 공유 프레퍼런스 또는 데이터베이스의 조합을 고려해보세요.\n- 백그라운드 프로세스로 주기적으로 새 데이터를 백엔드에서 가져와 UI로 전달해야 하는 경우, 이 데이터를 데이터베이스에 저장하고 콜드 플로 또는 핫 플로에 연결하여 업데이트가 도착할 때마다 업데이트를 전달할 수 있습니다. 이와 유사한 기법은 애플리케이션 전반의 이벤트에도 적용할 수 있습니다.\n\n# 6. 복잡한 한 줄 코드 피하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n표 태그는 공간을 절약하거나 코드를 이해하기 어렵게 만드는 것만이 아니라요. 예를 들어 아래와 같이요.\n\n```js\nval result = someList.filter { it.hasChildren }.map { it.children }.takeIf { it.size() > 2 } ?: listOf(0)\n```\n\n각 작업을 개별적인 단계로 분리하면 코드를 더 읽기 쉽게 만들 수 있어요.\n\n```js\nval result = someColdFlowOrList\n    .filter { it.hasChildren }\n    .map { it.children }\n    .takeIf { it.size() > 2 }\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 7. `it` 대신 값에 이름 사용하기\n\n많은 경우 이름을 생략할 수 있지만, 여러 겹의 레이어가 있는 경우 클로저 매개변수에 이름을 지정하는 것이 좋습니다.\n\n```kotlin\ndata class User(\n    val name: String,\n    val address: Address? = null,\n    val age: Int? = null\n)\n\ndata class Address(val city: String)\n\nval user = User(\"Alex\", Address(\"Stockholm\"))\n\nuser.let { user ->\n    user.address?.let { address ->\n        println(\"City: ${address.city}\")\n    }\n}\n```\n\n이렇게 하면 더 읽기 쉬워집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nuser.let { user ->\n    user.address?.let { address ->\n        println(\"도시: ${address.city}\")\n    }\n}\n```\n\n네, 안드로이드 스튜디오는 이러한 간단한 경우를 식별하는 데 도움을 줍니다. 그러나 이 경우에는 아무 말도 하지 않습니다.\n\n```kotlin\nuser.let {\n    println(\"이름: ${it.name}\")\n    it.address?.let {\n        println(\"도시: ${it.city}\")\n    }\n    it.age?.let {\n        println(\"나이: ${it}\")\n    }\n}\n```\n\n비교해보세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nuser?.let { user ->\n    println(\"이름: ${user.name}\")\n    user.address?.let { userAddress ->\n        println(\"도시: ${userAddress.city}\")\n    }\n    user.age?.let { userAge ->\n        println(\"나이: $userAge\")\n    }\n}\n```\n\n# 8. 해킹 스타일 또는 젠 코드를 피하세요\n\n예를 들어, 내 프로젝트 중 하나에 이렇게 썼습니다. 저에게는 꽤 직관적이지만, 동료들이 이해하는 데 어려움을 겪습니다. 여기서 필터는 무엇을 하는 건가요? 동시에 수정될 가능성이 있나요?\n\n```kotlin\nfilters\n    .indexOfFirst { it.id == id }\n    .takeIf { it != -1 }\n    ?.let { index ->\n        filters[index] = filters[index].copy(\n            isActive = !filters[index].isActive\n        )\n    }\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n덜 중첩되어 있어서 읽기가 더 쉬워질 거예요.\n\n```js\nval index = filters.indexOfFirst { it.id == id }\nif (index != -1) {\n    filters[index] = filters[index].copy(isActive = !filters[index].isActive)\n}\n```\n\n병렬로 수정할 수 있는지 여부에 대해 의문이 없다는 걸 보여줘요.\n\n# 9. IfNeeded 및 Maybe 함수 피하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 유형의 함수는 조건부 논리를 내부에 캡슐화하여 일부 부작용을 초래합니다.\n\n보통 이러한 함수들은 데이터 일관성이 여러 비동기 데이터 스트림에 의존하는 복잡한 시나리오에서 나타나며, 코드 중복을 피하거나 논리 분기를 단순화하기 위해 일부 논리를 캡슐화해야 할 때 사용됩니다. 반면에 이러한 함수들은 코드를 예측하기 어렵게 만들 수 있으며 불필요한 종속성을 도입할 수도 있습니다.\n\n예를 들어:\n\n```js\nclass User(\n    val name: String,\n    val email: String,\n    val age: Int,\n    val emailMarketingEnabled: Boolean\n)\n\nclass UserManager {\n    private var user: User = User.empty()\n    private val parentalControlManager = ParentalControlManager()\n    private val marketingManager = MarketingManager()\n    private val database = Database()\n\n    fun updateUserProfileIfNeeded() {\n        if (user.age < 18) {\n            parentalControlManager.checkPermissions(user) {\n                updateUser(user.copy(emailMarketingEnabled = true))\n            }\n        } else {\n            marketingManager.sendPromotionalEmail(user)\n            updateUser(user.copy(emailMarketingEnabled = true))\n        }\n    }\n\n    fun updateUser(user: User) {\n        database.update(user)\n    }\n}\n\nclass MainViewModel(private val userManager: UserManager) : ViewModel() {\n// ...\n   fun onActivatePromotionEmails() {\n        userManager.updateUserProfileIfNeeded()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 예시에서는 고전적인 논리 함정이 발생했습니다. 앱은 사용자를 업데이트해야 하지만 특정 경우에만 그렇게 해야 합니다. 여기서는 미성년자에 대한 경우입니다. 사용자가 만 18세 미만이라면 앱은 그들의 권한을 확인해야 합니다. 또한 사용자를 업데이트할 수 있는 성공적인 콜백이 있는 것으로 가정할 수 있습니다.\n\n저는 이를 많이 보았습니다. 구성과 중재자 패턴 사이의 무언가가 있습니다. 모든 것이 한 곳에 모여 편리해 보입니다. 그러나 이러한 코드는 많은 문제를 발생시킵니다:\n\n- updateUserProfileIfNeeded 메서드는 너무 많은 것을 담당합니다: 사용자의 연령 확인, 부모 관리 체크 처리, 사용자 프로필 업데이트, 마케팅 매니저와 상호 작용합니다.\n- 사용자의 연령에 따라 다른 작업을 수행하는데, 이는 메서드의 이름이나 서명에서 즉시 파악되지 않습니다. 이 숨겨진 논리로 인해 메서드가 예측하기 어렵고 이해하기 어려워집니다.\n- 사용자 객체가 연령 확인의 부작용으로 수정됩니다. 이와 같은 부작용은 버그를 발생시키고 코드를 유지보수하기 어렵게 만들 수 있습니다.\n- updateUserProfileIfNeeded 메서드는 사용자 객체의 현재 상태에 의존합니다. 이는 전역 상태 또는 공유 상태의 예시로, 특히 다중 스레드 환경에서 예측할 수 없는 동작을 초래할 수 있어 시스템이 더 오류가 발생하기 쉬워집니다.\n- 해당 메서드는 ParentalControlManager 및 MarketingManager와 강하게 결합되어 있습니다. 이 강한 결합은 UserManager 클래스를 테스트하고 유지보수하기 어렵게 만듭니다.\n- updateUserProfileIfNeeded 메서드의 이름은 실제 기능을 명확히 전달하지 않습니다.\n\n작은 조치로는 함수를 작은 함수로 분리하거나 관리자를 매개변수로 전달하는 것과 같은 것으로 문제를 해결할 수 없습니다. 이 클래스는 완전히 리팩토링되어 업데이트 기능만 포함하도록 해야 합니다. 권한 확인 및 마케팅 작업은 UserManager 바깥으로 이동되어야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nclass ParentalControlManager {\n    fun canUpdateProfile(user: User): Boolean {\n        return user.age < 18 && hasPermissions(user)\n    }\n}\n\nclass UserManager {\n    private var user: User = User.empty()\n    private val database = Database()\n\n    fun updateUser(user: User) {\n        database.update(user)\n    }\n\n    fun activatePromotionEmails(user: User) {\n        updateUser(\n            user.copy(emailMarketingEnabled = true)\n        )\n    }\n}\n\nclass MainViewModel(\n    private val parentalControlManager : ParentalControlManager,\n    private val marketingManager : MarketingManager,\n    private val userManager : UserManager\n    ) : ViewModel() {\n\n// ...\n   fun onActivatePromotionEmails() {\n        if (parentalControlManager.canUpdateProfile(user)) {\n              userManager.activePromotionEmails(user)\n              marketingManager.sendPromotionalEmail(user)\n        }\n    }\n}\n```\n\n그래서 여기에서 발생한 일들입니다:\n\n- 부모 관리 관련 로직은 이제 ParentalControlManager 내로 캡슐화되었습니다.\n- UserManager는 이제 사용자 업데이트 및 프로모션 이메일 활성화와 같은 사용자 관련 작업에만 초점을 맞추어 일관성이 높아졌습니다.\n- ParentalControlManager와 MarketingManager의 로직을 UserManager에서 분리함으로써 결합도가 줄었습니다. UserManager는 더 이상 ParentalControlManager와 MarketingManager의 동작에 직접 의존하지 않습니다.\n- canUpdateProfile 및 activatePromotionEmails와 같은 메서드 이름은 더 서술적이며 기능을 정확하게 반영합니다. 이는 가독성과 유지 보수성을 향상시킵니다.\n- MainViewModel은 이제 parentalControlManager.canUpdateProfile(user)의 결과에 따라 프로필 업데이트가 가능한지 명확하게 확인합니다. 이로써 로직 흐름이 더 명확하고 예측 가능해집니다.\n- 새로운 구조는 UserManager 내에서 부수 효과로 사용자 상태를 수정하는 일을 피합니다. 대신 사용자에 대한 변경사항이 명시적이고 투명하게 이루어집니다.\n- ParentalControlManager, MarketingManager 및 UserManager는 더 이상 서로 의존하지 않으며 이러한 모든 객체가 MainViewModel에 전달됩니다. 이는 테스트를 개선하고 의존성 주입을 사용할 수 있도록 분명한 방식으로 객체 초기화를 허용하는 좋은 사례입니다.\n\n# 10. 잘 자세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n더 나은 코드를 작성하기 위한 주요 팁은 휴식을 취하고 자신을 이해하는 것입니다. 충분한 휴식을 취하지 않으면 복잡한 코드 솔루션을 추적하기 어렵거나 작업을 향상시키기 위한 열망이 떨어질 수 있습니다. 업무-생활 균형을 유지하고 매일 7~8시간의 수면을 목표로 삼으며, 마음을 쉬게 해주는 활동을 할 것을 권장합니다. 화면이 아닌 좋은 책을 읽는 것도 좋은 방법입니다. 기억하세요, 당신의 정신적 건강은 기술적 기량만큼 중요합니다. 충분한 휴식과 건강한 상태의 개발자일수록 효율적이고 오류가 적으며 유지보수가 쉬운 코드를 작성할 가능성이 높습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-MyTop10CleanCodeTipsforKotlinMobilein2024_0.png"},"coverImage":"/assets/img/2024-06-19-MyTop10CleanCodeTipsforKotlinMobilein2024_0.png","tag":["Tech"],"readingTime":20},{"title":"젯팩 콤포즈로 귀여운 3D 라디오 버튼을 만드는 방법","description":"","date":"2024-06-19 10:35","slug":"2024-06-19-HowtoCreateaCute3DRadioButtoninJetpackCompose","content":"\n환영합니다 👋\n\n이 글에서는 젯팩 컴포즈로 귀여운 3D 라디오 버튼을 만들어, 5분만에 앱의 외관을 개선해볼 거에요.\n\n코드를 살펴봐요! 🔎\n\n![이미지](/assets/img/2024-06-19-HowtoCreateaCute3DRadioButtoninJetpackCompose_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 상수 정의\n\n나중에 사용할 상수를 정의하여 여정을 시작해보겠습니다.\n\n```js\n// 라디오 버튼 애니메이션 지속 시간\nprivate const val RadioAnimationDuration = 100\n\n// 그림자 효과에 대한 오프셋 및 흐림 반경\nprivate val RadioShadowOffset = 1.dp\nprivate val RadioShadowBlur = 2.dp\n\n// 그림자 및 빛효과에 대한 색상\nprivate val RadioShadowColor = Color.Black.copy(0.54f)\nprivate val RadioGlareColor = Color.White.copy(0.64f)\n\n// 라디오 버튼 및 그의 점에 대한 크기 상수\nprivate val RadioButtonDotSize = 12.dp\nprivate val RadioStrokeWidth = 3.dp\nprivate val RadioButtonSize = 22.dp\n```\n\n# 다양한 상태를 위한 색상 정의\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음 단계는 라디오 버튼이 다양한 상태(선택됨, 선택되지 않음, 활성화됨, 비활성화됨)에서 사용하는 색상을 정의하는 것입니다. 이러한 색상을 관리하는 ConvexRadioButtonColors 클래스를 만들 것입니다.\n\n```kotlin\nclass ConvexRadioButtonColors(\n    private val selectedColor: Color,\n    private val unselectedColor: Color,\n    private val disabledSelectedColor: Color,\n    private val disabledUnselectedColor: Color\n) {\n    @Composable\n    fun radioColorAsState(enabled: Boolean, selected: Boolean): State<Color> {\n        // 현재 상태를 기반으로 대상 색상을 결정합니다\n        val target = when {\n            enabled && selected -> selectedColor\n            enabled && !selected -> unselectedColor\n            !enabled && selected -> disabledSelectedColor\n            else -> disabledUnselectedColor\n        }\n        // 활성화됐을 때 색상을 애니메이션화하고, 그렇지 않으면 업데이트된 상태를 직접 반환합니다\n        return if (enabled) {\n            animateColorAsState(target, tween(durationMillis = RadioAnimationDuration))\n        } else {\n            rememberUpdatedState(target)\n        }\n    }\n}\n```\n\n이 클래스는 라디오 버튼의 다양한 상태를 나타내는 네 가지 색상을 매개변수로 사용하며, 현재 라디오 버튼 상태에 기반하여 적절한 색상을 반환하는 radioColorAsState 컴포저블 함수를 제공합니다.\n\n# 기본 색상 제공하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다음으로, 라디오 버튼의 기본 색상 값을 제공하는 ConvexRadioButtonDefaults 객체를 생성할 것입니다.\n\n```js\nobject ConvexRadioButtonDefaults {\n    @Composable\n    fun colors(\n        selectedColor: Color = MaterialTheme.colorScheme.primary,\n        unselectedColor: Color = MaterialTheme.colorScheme.onSurfaceVariant,\n        disabledSelectedColor: Color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = DisabledAlpha),\n        disabledUnselectedColor: Color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = DisabledAlpha)\n    ): ConvexRadioButtonColors = ConvexRadioButtonColors(selectedColor, unselectedColor, disabledSelectedColor, disabledUnselectedColor)\n}\n```\n\n이 객체는 기본 또는 지정된 색상으로 ConvexRadioButtonColors 인스턴스를 반환하는 Composable 함수 colors를 제공합니다. 이러한 기본값은 현재 material theme의 색상 체계를 기반으로 합니다.\n\n# Convex Radio Button 정의하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 주요 ConvexRadioButton composable 함수를 선언하고 그 매개변수들을 살펴볼 수 있습니다.\n\n```js\n@Composable\nfun ConvexRadioButton(\n    selected: Boolean,\n    modifier: Modifier = Modifier,\n    enabled: Boolean = true,\n    colors: ConvexRadioButtonColors = ConvexRadioButtonDefaults.colors(),\n    interactionSource: MutableInteractionSource = remember { MutableInteractionSource() },\n    onClick: () -> Unit\n)\n```\n\n💎 selected ➜ 라디오 버튼이 선택되었는지 여부를 나타냅니다.\n\n💎 modifier ➜ 이 라디오 버튼에 적용할 Modifier입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n💎 enabled ➜ 라디오 버튼이 사용자 상호 작용을 위해 활성화되는지 여부를 나타냅니다.\n\n💎 colors ➜ 라디오 버튼의 다른 상태에 대한 색상을 정의하는 ConvexRadioButtonColors의 인스턴스입니다.\n\n💎 interactionSource ➜ 사용자 상호 작용 이벤트를 처리하는 상호 작용 소스입니다.\n\n💎 onClick ➜ 라디오 버튼이 클릭될 때 호출되는 람다 함수입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Convex Radio Button 구현\n\n우리는 가장 흥미로운 부분, Convex 라디오 버튼을 만드는 과정에 진입하고 있어요.\n\n## 준비\n\n이 기능을 구현하기 위해 innerShadow 및 convexBorder 수정자를 활용해야 합니다. 자세한 설명은 아래 제공된 관련 기사를 참조하거나👇 또는 InnerShadow Gist, ConvexBorder Gist에서 코드를 가져오세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 구현\n\n자, 코드로 들어가 봅시다 👀\n\n```js\n@Composable\nfun ConvexRadioButton(\n    /* 매개변수... */\n) {\n    // 선택된 상태에 따라 도트의 크기를 애니메이션화합니다\n    val dotSize = animateDpAsState(\n        targetValue = if (selected) RadioButtonDotSize else 0.dp,\n        animationSpec = tween(durationMillis = RadioAnimationDuration)\n    )\n    // 현재 상태에 맞는 색상을 가져옵니다\n    val radioColor = colors.radioColorAsState(enabled, selected)\n\n    // 선택 및 클릭 상호작용을 처리하는 Modifier\n    val selectableModifier = Modifier.selectable(\n        selected = selected,\n        onClick = onClick,\n        enabled = enabled,\n        role = Role.RadioButton,\n        interactionSource = interactionSource,\n        indication = rememberRipple(bounded = false, radius = RadioButtonSize)\n    )\n\n    // 오목한 테두리를 적용하는 Modifier\n    // 이것은 외부 원 또는 선택되지 않은 상태를 나타냅니다\n    val convexBorderModifier = Modifier.convexBorder(\n        color = radioColor.value,\n        shape = CircleShape,\n        strokeWidth = RadioStrokeWidth,\n        convexStyle = ConvexStyle(RadioShadowBlur, RadioShadowOffset, RadioGlareColor, RadioShadowColor)\n    )\n\n    // 라디오 버튼의 주요 컨테이너\n    Box(\n        modifier\n            .minimumInteractiveComponentSize() // 최소 터치 대상 크기를 보장합니다\n            .then(selectableModifier) // 선택 가능한 동작 추가\n            .size(RadioButtonSize) // 라디오 버튼의 크기를 설정합니다\n            .then(convexBorderModifier), // 오목한 테두리 적용\n        contentAlignment = Alignment.Center\n    ) {\n        // 크기가 0 이상인 경우 내부 점을 조건부로 표시합니다\n        if (dotSize.value > 0.dp) {\n            Box(\n                modifier = Modifier\n                    .size(dotSize.value)\n                    .background(radioColor.value, CircleShape)\n                    // 두 개의 내부 그림자를 활용해 오목한 효과를 생성합니다\n                    .innerShadow(CircleShape, RadioShadowColor, RadioShadowBlur, -RadioShadowOffset, -RadioShadowOffset)\n                    .innerShadow(CircleShape, RadioGlareColor, RadioShadowBlur, RadioShadowOffset, RadioShadowOffset)\n            )\n        }\n    }\n}\n```\n\n축하해요🥳! 성공적으로 만들어냈어요👏. 전체 코드 구현은 GitHub Gist에서 확인할 수 있습니다🧑‍💻. 이제 어떻게 활용할 수 있는지 살펴보도록 하죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 광고\n\n외국어를 배우고 있고 새로운 어휘에 어려움을 겪고 계신가요? 그렇다면, 여러분의 학습을 쉽고 편리하게 만들어 줄 이 어플을 꼭 확인해 보시기를 강력히 추천합니다!\n\n<img src=\"/assets/img/2024-06-19-HowtoCreateaCute3DRadioButtoninJetpackCompose_1.png\" />\n\n# 실용적인 예시 💁\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n알겠어요, 결제 옵션을 선택하기 위한 간단한 예제를 만들어 봅시다.\n\n먼저, 필요한 옵션들을 나타내기 위해 enum 클래스 PaymentOption을 만들어주세요:\n\n```js\nenum class PaymentOption(val displayName: String) {\n    CreditCard(\"신용 카드\"),\n    PayPal(\"PayPal\"),\n    BankTransfer(\"은행 송금\"),\n}\n```\n\n다음으로, 현재 선택된 옵션을 저장하기 위한 상태 변수가 필요합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nvar selectedOption by remember { mutableStateOf(PaymentOption.CreditCard) }\n```\n\n마지막으로, 모든 가능한 옵션을 열에 넣어주세요:\n\n```js\nColumn {\n    PaymentOption.entries.forEach { option ->\n        Row(verticalAlignment = Alignment.CenterVertically) {\n            ConvexRadioButton(\n                selected = (option == selectedOption),\n                onClick = { selectedOption = option }\n            )\n            Text(option.displayName)\n        }\n    }\n}\n```\n\n## 결과:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](https://miro.medium.com/v2/resize:fit:826/1*5IdpszpbEX4LHPABjORO-g.gif)\n\nYou might also like 👇\n\nThank you for reading this article! ❤️ I hope you’ve found it enjoyable and valuable. Feel free to show your appreciation by hitting the clap 👏 if you liked it and follow Kappdev for more exciting articles 😊\n\nHappy coding!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-19-HowtoCreateaCute3DRadioButtoninJetpackCompose_2.png)\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoCreateaCute3DRadioButtoninJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoCreateaCute3DRadioButtoninJetpackCompose_0.png","tag":["Tech"],"readingTime":11},{"title":"이벤트브라이트의 MVI","description":"","date":"2024-06-19 10:33","slug":"2024-06-19-MVIatEventbrite","content":"\n![이미지](/assets/img/2024-06-19-MVIatEventbrite_0.png)\n\n저는 6개월 전에 Senior Android Engineer로 Eventbrite에 합류했습니다. 여기서 6개월을 일한 후, 발견한 한 가지는 이곳이 단순히 제품 중심의 회사가 아니라 기술 중심의 회사라는 것입니다. 저희가 가지고 있는 아키텍처와 함께 일할 수 있는 뛰어난 두뇌들이 매일 저를 흥분하게 만듭니다.\n\nEventbrite는 누구에게나 자신의 열정을 충전하고 삶을 더 풍부하게 만드는 이벤트를 만들고 공유하고 찾고 참석할 수 있는 글로벌 셀프 서비스 티케팅 플랫폼입니다. 음악 축제부터 마라톤, 회의, 지역 집회 및 기금 모금 행사, 게임 대회, 공연 대회 등까지 다양한 이벤트를 지원합니다. 우리의 미션은 실시간 체험을 통해 세계를 하나로 이어주는 것입니다.\n\n저희 Eventbrite에는 두 가지 제품이 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 주최자 앱: 이 앱은 이벤트브라이트에서 이벤트를 개최하려는 창작자들을 위한 것입니다. 이 앱은 창작자들이 이벤트를 모바일에서 관리할 수 있도록 도와줍니다 — 이벤트 만들기 & 편집하기, 티켓 추적 & 판매하기, 그리고 게스트 체크인하기.\n- 참가자 앱: 이 앱은 근처 이벤트에 참가하고 싶어하는 참가자들을 위한 것입니다. 이 플랫폼을 통해 티켓을 예약할 수 있습니다.\n\n이벤트브라이트에서 운영 중인 안드로이드 앱은 MVI 아키텍처를 기반으로 합니다. 이 기사에서는 MVI 아키텍처가 무엇인지, MVVM과 어떻게 다른지, 그리고 그 장점에 대해 설명하겠습니다. 그리고 참가자 앱에서 이벤트를 확인하는 예시로 어떻게 구현할 수 있는지도 알려드리겠습니다.\n\n# MVI[Model View Intent]\n\nModel-View-Intent(MVI) 아키텍처 패턴은 주로 André Staltz가 개발한 자바스크립트 프레임워크인 Cycle.js에 속한다고 알려져 있습니다. 그러나 MVI는 다양한 개발자와 커뮤니티에 의해 채택되고 다양한 프로그래밍 언어 및 플랫폼에서 적용 및 조정되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위 내용을 이해하기 위해 이 비디오도 확인해 볼 수 있어요.\n\n안드로이드에서는 Hannes Dorfmann의 글 이후로 인정받게 되었습니다. 그들은 블로그에서 MVI 아키텍처에 대해 상세히 설명했습니다. 여기서 확인할 수 있어요.\n\n- Model: 모델은 애플리케이션의 데이터와 비즈니스 로직을 나타냅니다. MVI에서는 모델이 변경 불가능하며 애플리케이션의 현재 상태를 나타냅니다.\n- View: 뷰는 UI를 렌더링하고 사용자 입력에 반응하는 역할을 합니다. 그러나 MVVM 및 MVC와는 달리, MVI에서의 뷰는 수동 구성요소입니다. 뷰는 모델과 직접 상호작용하거나 데이터를 기반으로 결정하지 않습니다. 대신, 뷰모델로부터 상태 업데이트와 사용자 의도를 받습니다.\n- Intent: 의도는 UI에서 발생하는 사용자 작업 또는 이벤트를 나타냅니다. MVI에서는 이러한 의도가 뷰에 의해 캡처되어 뷰모델에게 전송되어 처리됩니다.\n- ViewModel: MVI에서의 뷰모델은 애플리케이션 상태와 비즈니스 로직을 관리합니다. 뷰로부터 사용자 의도를받아 처리하고 모델을 업데이트합니다. 그런 다음 뷰모델은 새로운 상태를 발행하고, 이를 뷰가 관찰하고 렌더링 합니다.\n\n이번에는 Eventbrite 앱을 통해 MVI를 이해해 봅시다. Model — View — Intent 개념을 적용해 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-MVIatEventbrite_1.png)\n\n이것은 Attendee 앱의 이벤트 세부 페이지입니다. 사용자는 보통 두 곳에서 이 페이지에 액세스할 수 있습니다. 이벤트 목록에서 그리고 검색에서.\n\n이 페이지에는 이벤트의 이름, 날짜, 시간, 장소, 주최자, 이벤트에 대한 요약 등에 대한 세부 정보가 표시됩니다. 그리고 몇 가지 클릭이 있습니다: 좋아요, 좋아하지 않음, 공유, 창작자 팔로우, 티켓 구매 등이 있습니다.\n\nMVI를 사용하여 단계별로 구현 방법을 이해해 보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# # 모델\n\n## 뷰 상태\n\n이벤트 세부 페이지에서 다음 상태를 가질 수 있습니다:\n\n- 로딩\n- 콘텐츠\n- 오류\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n각 화면에 대한 3가지 기본 상태입니다.\n\n```js\n내부 봉인된 클래스 ViewState {\n\n    @Immutable\n    class Loading(val onBackPressed: () -> Unit = {}) : ViewState()\n\n    @Immutable\n    class Content(val event: UiModel) : ViewState()\n\n    @Immutable\n    class Error(val error: ErrorUiModel): ViewState()\n\n}\n```\n\n화면의 초기 상태는 Loading입니다. 서버에서 이벤트 세부 정보를 가져 오는 동안 진행률 표시줄을 표시할 것입니다.\n\n<img src=\"/assets/img/2024-06-19-MVIatEventbrite_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nCompose에서는 상태를 확인하고보기를로드합니다.\n\n```kotlin\n@Composable\ninternal fun Screen(\n    state: State,\n) {\n    when (state) {\n        is State.Loading -> Loading()\n        is State.Error -> Error(state.error)\n        is State.Content -> Content(state.event)\n    }\n}\n```\n\n따라서 이제 UI를 변경하려면 직접 변경하는 대신 상태와 통신하여 UI가 상태를 관찰하고 변경 사항을 반영하게합니다.\n\n# # 의도\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이벤트\n\n![이미지](/assets/img/2024-06-19-MVIatEventbrite_3.png)\n\n이벤트는 작업을 정의하는 sealed 클래스입니다.\n\n```js\nsealed class Event {\n    data object Load : Event()\n    class FetchEventError(val error: NetworkFailure) : Event()\n    class FetchEventSuccess(val event: ListingEvent) : Event()\n    class Liked(val event: LikeableEvent) : Event()\n    class Disliked(val event: LikeableEvent) : Event()\n    class FollowPressed(val user: FollowableOrganizer) : Event()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-MVIatEventbrite_4.png\" />\n\n하나씩 각 이벤트를 이해해봐요.\n\n로드 이벤트:\n\n로드는 초기 이벤트로, 프래그먼트에서 트리거됩니다. OnCreate에서 이벤트를 설정하고, 초기 이벤트인 로드를 가져와 ViewModel에서 처리하죠.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n 재정의 하여 이벤트를 처리하는 suspend fun 핸들이벤트(event: Event) {\n        when (event) {\n            is Event.Load -> load()\n        }\n}\n```\n\n로드 기능에서는 서버에서 이벤트 세부정보를 가져옵니다. 이 API의 성공 또는 오류에 따라 UI 상태를 변경하고, UI가 이에 맞게 업데이트됩니다.\n\n```kotlin\n getEventDetail.fetch(eventId)\n                .fold({ error ->\n                    state {\n                       ViewState.Error(\n                            error = error.toUiModel(events)\n                    }\n                }) { response ->\n                    state { ViewState.Content(event.toUiModel(events, effect)) }\n                }\n```\n\nView에서 변경사항을 받음\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n내부 fun EventDetailScreen(\n    상태: ViewState\n) {\n    when (상태) {\n        is ViewState.Loading -> Loading()\n        is ViewState.Error -> Error(상태.error)\n        is ViewState.Content -> Content(상태.event)\n    }\n}\n```\n\n## Reducer\n\nState Reducer은 함수형 프로그래밍에서 나온 개념으로 이전 상태를 입력으로 받아 이전 상태에서 새로운 상태를 계산합니다.\n\n참석자가 크리에이터를 팔로우하는 기능을 예로 들어서 이해해봅시다. 사용자가 팔로우 버튼을 클릭했을 때 어떤 일이 일어날까요?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-MVIatEventbrite_5.png\" />\n\n먼저, **UiModel**이라는 객체가 있습니다. 이 객체에는 콘텐츠 상태가 포함되어 있으며, 이를 사용하여 UI에 데이터를 표시합니다.\n\n```js\ninternal data class UiModel(\n    val eventTitle: String,\n    val date: String,\n    val location: String,\n    val summary: String,\n    val organizerInfo: OrganizerState,\n    val onShareClick: () -> Unit,\n    val onFollowClick: () -> Unit\n)\n```\n\n이제 한 단계씩 이해해 봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**작업 1: 사용자 클릭 리스너 구현 및 이벤트 트리거**\n\n```js\nonClick {\n  events(EventDetailEvents.FollowPressed(followableOrganizer))\n}\n```\n\n**작업 2: ViewModel에서 이벤트 처리**\n\n이미 팔로우된 주최자인 경우 언팔로우하고, 그렇지 않은 경우 팔로우하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 followableOrganizer가 팔로우되어 있다면 {\n상태 { onUnfollow(::event, ::effect) }\n} 그렇지 않으면 {\n상태 { onFollow(::event, ::effect) }\n}\n\n액션 3: 리듀서\n\nonUnfollow 및 onFollow는 리듀서에 의해 처리되며, 이 곳에서 이전 상태를 가져와 수정한 후 다시 뷰로 보내줍니다.\n\n```kotlin\nprivate fun getFollowContent(\n        event: UiModel,\n        newState: Boolean, // 팔로우 중 또는 언팔로우 중 표시\n        events: (Event) -> Unit\n) = ViewState.Content(\n        event.copy(\n                organizerState = with((event.organizerState as OrganizerState)) {\n                    val hasChanged = newState != isFollowing\n                    OrganizerState.Content(copy(\n\n                            isFollowing = newState,\n                            listeners = OrganizerListeners(\n                                    onFollowUnfollow = {\n                                        val followableUser = event.toFollowableModel(newState, it.toBookmarkCategory())\n                                        events(Event.FollowPressed(followableUser))\n                                    }\n                            )\n                    )\n                    )\n                }\n        )\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n`getFollowContent` 함수는 View 상태를 반환합니다.\n\n**액션 4:** 뷰 모델에서 View 상태를 반환합니다\n\n```js\nstate { onUnfollow(::event, ::effect) }\n```\n\n**액션 5:** 이 변경사항을 관찰하여 View를 수정하세요\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 결론\n\n마지막으로, Eventbrite에서 Model-View-Intent (MVI) 아키텍처를 채택한 결과, 안드로이드 앱이 향상되었을 뿐만 아니라 개발 프로세스가 간단해졌습니다. MVI를 받아들이면 상태 관리가 간소화되고 데이터 흐름이 개선되며 응용 프로그램 내에서 더 예측 가능하고 일관된 동작이 보장됩니다.\n\nMVI의 주요 장점은 MVVM과 같은 전통적인 아키텍처에 비해 명확하게 드러납니다. MVI로 전환하면 상태 관리에 대한 명확하고 중앙 집중식 접근 방식을 누릴 수 있습니다. Model은 응용 프로그램의 불변 상태를 표현하고, View는 상태 업데이트에 따라 수동적으로 UI를 렌더링하며, Intent는 사용자 조작을 효율적으로 캡처합니다. 이 단방향 데이터 흐름은 데이터 및 이벤트의 흐름을 간소화하므로 앱의 동작을 이해하기 쉬워지며 MVVM에서 상태 변경을 관리하는 데 일반적으로 동반되는 복잡성이 줄어듭니다.\n\n게다가, Eventbrite 앱에서 MVI를 구현한 결과, Event 상세 페이지 예제를 통해 그 실용성과 효과를 보여주었습니다. 명확한 상태를 정의하고 이벤트를 처리하며 새로운 상태를 계산하기 위해 reducer를 사용함으로써 더 효율적이고 유지보수가 용이한 코드 기반을 구축했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMVI 아키텍처 도입은 Eventbrite에서 강력하고 확장 가능한 안드로이드 앱을 구축할 뿐만 아니라 개발 프로세스를 간소화하는 선례를 제시했습니다. 관심사의 명확한 분리, 예측 가능한 데이터 흐름, 그리고 중앙 집중식 상태 관리는 모든 개발자가 프로젝트에 통합을 고려해야 할 가치 있는 패러다임으로 만들어 냈습니다. MVI를 사용하면 직관적이고 잘 구조화된 애플리케이션을 통해 우수한 사용자 경험을 창출하는 길이 더욱 분명해지고 달성 가능해집니다.\n\n귀하의 피드백은 계속해서 개선해 나가기 위해 중요합니다. 계속해서 보내주세요.\n\n이 글이 도움이 되었기를 바랍니다. 제안이나 코멘트가 있으면 댓글 섹션에서 알려주세요. 또는 karishma.agr1996@gmail.com 으로 연락 주셔도 됩니다.\n\n당신의 좋아요는 다른 사람들이 이 글을 발견하는 데 도움이 됩니다 😃 .\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](https://miro.medium.com/v2/resize:fit:1200/1*ogke9Q7S3f_WKKfqc1y6_w.gif)\n","ogImage":{"url":"/assets/img/2024-06-19-MVIatEventbrite_0.png"},"coverImage":"/assets/img/2024-06-19-MVIatEventbrite_0.png","tag":["Tech"],"readingTime":13},{"title":"시니어 엔지니어로부터 온 편지 앱 개발자를 위해","description":"","date":"2024-06-19 10:32","slug":"2024-06-19-ALetterfromaSeniorEngineerForAppDevelopers","content":"\n\"오늘의 시장 동향과 미래 기술 살펴보기\n\n![Senior Engineer's Letter for App Developers](/assets/img/2024-06-19-ALetterfromaSeniorEngineerForAppDevelopers_0.png)\n\n이전에 안드로이드 개발자로서 좋지 않은 것 같았어요. 그것을 바꾸기로 결심하고 안드로이드의 기본을 숙달하기로 했어요. 한 선임 안드로이드 개발자로부터 지도를 받아 매우 값진 교훈을 얻었는데, 함께 나누고 싶어요.\n\n# 리포트: 감원과 IT 산업\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레이오프와 IT 산업은 마치 음양처럼 얽혀 있는 관계입니다. 회사가 자금 부족으로 어려움을 겪을 때, 레이오프가 종종 따라오곤 합니다. 이는 과거에도 통용된 것으로, 오늘날에도 계속되고 있습니다.\n\n요점: 언제나 사이드 일을 가지고 계세요. 당신만의 제품을 개발하거나 프리랜서 일을 받기 위해 노력한다면, 현재 보유한 기술과 영업 기술을 결합하여 신뢰할만한 사이드 일을 얻을 수 있을 겁니다. 프로젝트를 진행하고 소셜 미디어에 공유하며 실생활 문제를 해결하는 것부터 시작해보세요.\n\n# Flutter, React Native, 그리고 안드로이드 직군\n\n고객들이 앱 뒤에 사용된 언어를 신경 쓰지는 않습니다. 그들이 중요하게 생각하는 것은 보안과 개인 정보입니다. Flutter와 React Native은 앱을 만들기 위한 좋은 옵션들이지만, 네이티브 앱은 더 많은 사용자 정의를 허용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n많은 엔지니어들이 저조한 급여로 시작합니다(20,000달러에서 30,000달러 정도). 만약 여러분이 이러한 위치에 있다면, 시간이 흐름에 따라 여러분의 기술을 향상시키는 데 집중하세요. 하루가 끝날 때, 앱 개발자로서의 경험과 끈기 있는 노력은 운에 뒤지지 않을 것입니다.\n\n# IT 산업의 트렌드\n\nIT 산업은 항상 발전하고 있습니다. VR, AR 또는 새로운 것이 떠오를 때도, 기초는 변함없이 남아 있습니다. 우리는 미래를 과거의 추상화로 구축합니다. 트렌드를 파악하는 것이 중요하지만, 핵심 원칙을 이해하는 것이 더 중요합니다.\n\n# 완벽한 이력서 작성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이력서 작성 시 우선순위는 다음과 같습니다: 경험 `프로젝트` 학위. 이력서의 대부분 내용은 인사 담당자가 시간 부족으로 충분히 읽지 않습니다. 인상을 주기 위해 몇 초밖에 주어지지 않으니, 이 우선순위를 명심해주세요.\n\n신입 사원의 경우, 학위와 성적은 중요하지만, 첫 직장 이후로는 그다지 중요하지 않아요.\n\n더 자세한 내용을 원하신다면:\n\n결론: 안드로이드 개발은 쉽지 않지만 보람 있습니다. 기술을 향상시키고 산업 트렌드에 맞춰 가며, 일자리 시장 변화에 대비할 준비를 항상 갖춰야 합니다. 그리고 기억하세요, 경험과 프로젝트가 학위보다 더 큰 의미가 될 거에요.\n","ogImage":{"url":"/assets/img/2024-06-19-ALetterfromaSeniorEngineerForAppDevelopers_0.png"},"coverImage":"/assets/img/2024-06-19-ALetterfromaSeniorEngineerForAppDevelopers_0.png","tag":["Tech"],"readingTime":3},{"title":"제트팩 콤포즈에서 멋진 3D 테두리를 만드는 방법","description":"","date":"2024-06-19 10:31","slug":"2024-06-19-HowtoCreateaStunning3DBorderinJetpackCompose","content":"\n환영합니다! 👋\n\n이 기사에서는 Jetpack Compose용 놀라운 3D 테두리 수정자를 만들어보겠습니다. 이 수정자는 어떤 모양의 뷰에도 적용할 수 있습니다. 게다가, 이 수정자를 사용하여 아름다운 검색 바를 만들어볼 것입니다.\n\n자세히 알아보시죠! 🚀\n\n![image](/assets/img/2024-06-19-HowtoCreateaStunning3DBorderinJetpackCompose_0.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Convex Border\n\nModifier를 위한 주요 convexBorder 확장 기능을 정의하는 것부터 시작해봅시다. 이 기능은 최종적으로 윤곽선을 그립니다.\n\n## ConvexStyle\n\n이전에 윤곽 효과의 스타일을 나타내는 ConvexStyle 데이터 클래스를 만들어서 명확성을 높입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\ndata class ConvexStyle(\n    val blur: Dp = 3.dp,\n    val offset: Dp = 2.dp,\n    val glareColor: Color = Color.White.copy(0.64f),\n    val shadowColor: Color = Color.Black.copy(0.64f)\n)\n```\n\n## 함수\n\n이제 함수를 정의하기 위해 모든 준비가 되었습니다:\n\n```kotlin\nfun Modifier.convexBorder(\n    color: Color,\n    shape: Shape,\n    strokeWidth: Dp = 8.dp,\n    convexStyle: ConvexStyle = ConvexStyle()\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n⭐ color ➜ 테두리의 색상입니다.\n\n⭐ shape ➜ 테두리의 모양입니다.\n\n⭐ strokeWidth ➜ 테두리 선의 너비입니다.\n\n⭐ convexStyle ➜ 테두리에 적용된 볼록 효과의 스타일입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 구현\n\n자, 이제 우리는 구현을 진행할 수 있어요.\n\n## 그림자와 반짝임 그리기\n\nconvexBorder 함수를 구현하기 전에, 볼록한 효과를 만들기 위해 그림자를 그리는 지원 함수 drawConvexBorderShadow를 정의해야 해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfun DrawScope.drawConvexBorderShadow(\n    outline: Outline,\n    strokeWidth: Dp,\n    blur: Dp,\n    offsetX: Dp,\n    offsetY: Dp,\n    shadowColor: Color\n) = drawIntoCanvas { canvas ->\n    // Paint 객체를 생성하고 설정합니다\n    val shadowPaint = Paint().apply {\n        this.style = PaintingStyle.Stroke\n        this.color = shadowColor\n        this.strokeWidth = strokeWidth.toPx()\n    }\n\n    // 변환 전 현재 레이어 저장\n    canvas.saveLayer(size.toRect(), shadowPaint)\n\n    val halfStrokeWidth = strokeWidth.toPx() / 2\n    // 테두리가 경계 내에 맞도록 캔버스 이동\n    canvas.translate(halfStrokeWidth, halfStrokeWidth)\n    // 그림자 외곽선 그리기\n    canvas.drawOutline(outline, shadowPaint)\n\n    // 그림자에 대한 혼합 모드 및 흐림 효과 적용\n    shadowPaint.asFrameworkPaint().apply {\n        xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_OUT)\n        maskFilter = BlurMaskFilter(blur.toPx(), BlurMaskFilter.Blur.NORMAL)\n    }\n    // 클리핑용 색상 설정\n    shadowPaint.color = Color.Black\n\n    // 캔버스 이동 및 그림자 클리핑 외곽선 그리기\n    canvas.translate(offsetX.toPx(), offsetY.toPx())\n    canvas.drawOutline(outline, shadowPaint)\n    // 캔버스를 원래 상태로 복원\n    canvas.restore()\n}\n```\n\n이 함수가 어떻게 작동하는지 더 잘 이해하려면 아래 이미지를 확인해보세요 👇\n\n<img src=\"/assets/img/2024-06-19-HowtoCreateaStunning3DBorderinJetpackCompose_1.png\" />\n\n## convexBorder 구현\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 drawConvexBorderShadow 함수를 사용하여 볼록한 테두리를 그리는 주요 함수를 정의할 수 있습니다.\n\n여기에 코드 예시가 있습니다 👇\n\n```kotlin\nfun Modifier.convexBorder(\n    /* 매개변수... */\n) = this.drawWithContent {\n    // 캔버스 경계 내에 맞도록 크기 조정\n    val adjustedSize = Size(size.width - strokeWidth.toPx(), size.height - strokeWidth.toPx())\n    // 모양과 조정된 크기에 기반한 윤곽 생성\n    val outline = shape.createOutline(adjustedSize, layoutDirection, this)\n\n    // 컴포저 내의 원본 콘텐츠 그리기\n    drawContent()\n\n    // 테두리를 캔버스에 맞게 이동\n    translate(halfStrokeWidth, halfStrokeWidth) {\n        // 주요 테두리 윤곽 그리기\n        drawOutline(\n            outline = outline,\n            color = color,\n            style = Stroke(width = strokeWidth.toPx())\n        )\n    }\n\n    with(convexStyle) {\n        // 그림자 윤곽 그리기\n        drawConvexBorderShadow(outline, strokeWidth, blur, -offset, -offset, shadowColor)\n        // 눈부심 윤곽 그리기\n        drawConvexBorderShadow(outline, strokeWidth, blur, offset, offset, glareColor)\n    }\n}\n```\n\n이 코드가 어떻게 작동하는지 확인해보세요👇\n\n<img src=\"/assets/img/2024-06-19-HowtoCreateaStunning3DBorderinJetpackCompose_2.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n축하드려요🥳! 성공적으로 만들었네요👏. 전체 코드 구현은 GitHub Gist에서 확인하실 수 있어요🧑‍💻. 이제 이 기능을 활용해 아름다운 사용자 정의 검색 바를 만드는 방법을 알아보겠어요.\n\n## 광고\n\n외국어를 배우고 새로운 어휘에 어려움을 겪고 계신가요? 그렇다면, 여정을 쉽고 편리하게 만들어줄 이 어플을 확인해보시기를 강력히 추천해요!\n\n<img src=\"/assets/img/2024-06-19-HowtoCreateaStunning3DBorderinJetpackCompose_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 실용적인 예제 💁\n\n자, 오늘의 기사에서 실용적인 부분으로 들어가 봅시다.\n\n커스텀 스타일이 적용된 TextField를 작성하기 위해 BasicTextField의 decorationBox 매개변수를 활용할 수 있습니다.\n\n```js\n// 텍스트 입력을 보관할 가변 상태\nvar text by remember { mutableStateOf(\"\") }\n\nBasicTextField(\n    value = text,\n    onValueChange = { text = it },\n    singleLine = true,\n    keyboardOptions = KeyboardOptions(\n        capitalization = KeyboardCapitalization.Sentences,\n        imeAction = ImeAction.Search\n    ),\n    textStyle = LocalTextStyle.current.copy(\n        fontSize = 16.sp,\n        fontWeight = FontWeight.Medium\n    ),\n    decorationBox = { innerTextField ->\n        Row(\n            modifier = Modifier\n                .size(350.dp, 60.dp)\n                // 배경 색상과 모양 설정\n                .background(Color(0xFF7F2DBF), CircleShape)\n                // 동일한 색상과 모양으로 볼록한 테두리 적용\n                .convexBorder(Color(0xFF7F2DBF), CircleShape)\n                .padding(horizontal = 20.dp),\n            verticalAlignment = Alignment.CenterVertically,\n            horizontalArrangement = Arrangement.spacedBy(8.dp)\n        ) {\n            // 검색 아이콘 추가\n            Icon(\n                imageVector = Icons.Rounded.Search,\n                contentDescription = null\n            )\n            Box {\n                // 입력 텍스트가 비어 있을 때 플레이스홀더 텍스트 표시\n                if (text.isEmpty()) {\n                    Text(\n                        text = \"검색...\",\n                        style = LocalTextStyle.current.copy(color = Color(0xFF242424))\n                    )\n                }\n                // 실제 텍스트 필드 표시\n                innerTextField()\n            }\n        }\n    }\n)\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 결과 😍\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*d8g4XiPZ6-d3y-3aTig-9Q.gif)\n\n아래 내용도 맘에 드실지도요 👇\n\n이 글을 읽어 주셔서 감사합니다! ❤️ 즐겁고 유익한 시간이 되셨기를 바랍니다. 좋아하신다면 박수 👏를 눌러주세요. Kappdev를 팔로우하시면 더 많은 흥미로운 글을 만나보실 수 있습니다 😊\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n행복한 코딩하세요!\n\n![이미지](/assets/img/2024-06-19-HowtoCreateaStunning3DBorderinJetpackCompose_4.png)\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoCreateaStunning3DBorderinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoCreateaStunning3DBorderinJetpackCompose_0.png","tag":["Tech"],"readingTime":9},{"title":"안드로이드  안드로이드 앱 링크 처리하기","description":"","date":"2024-06-19 10:30","slug":"2024-06-19-AndroidHandlingAndroidAppLinks","content":"\n# 안드로이드 앱 링크는 사용자를 앱 내의 링크 특정 콘텐츠로 직접 이동시킵니다\n\n![AndroidHandlingAndroidAppLinks_0.png](/assets/img/2024-06-19-AndroidHandlingAndroidAppLinks_0.png)\n\n# 다양한 종류의 링크 이해하기\n\n- 딥 링크\n- 웹 링크\n- 안드로이드 앱 링크\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 1. 딥 링크\n\n# 딥 링크는 사용자를 앱의 특정 부분으로 직접 이동하는 모든 스키마의 URI입니다\n\n```js\n<activity\n android:name=\".MyMapActivity\"\n android:exported=\"true\"\n …>\n <intent-filter>\n <action android:name=\"android.intent.action.VIEW\" />\n <category android:name=\"android.intent.category.DEFAULT\" />\n <category android:name=\"android.intent.category.BROWSABLE\" />\n <data android:scheme=\"geo\" />\n </intent-filter>\n</activity>\n```\n\n# 2. 웹 링크\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 웹 링크는 HTTP 및 HTTPS 스키마를 사용하는 딥 링크입니다. 안드로이드 12 이상에서 웹 링크(안드로이드 앱 링크가 아닌)를 클릭하면 항상 웹 브라우저에서 콘텐츠가 표시됩니다.\n\n# 🧑‍💻\n\n```js\n<intent-filter>\n  <action android:name=\"android.intent.action.VIEW\" />\n  <category android:name=\"android.intent.category.DEFAULT\" />\n  <category android:name=\"android.intent.category.BROWSABLE\" />\n  <data android:scheme=\"http\" />\n  <data android:host=\"myownpersonaldomain.com\" />\n</intent-filter>\n```\n\n# 3. 안드로이드 앱 링크\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Android App Links, Android 6.0(API 레벨 23) 이상에서 사용할 수 있으며, HTTP 및 HTTPS 스키마를 사용하는 웹 링크이며 autoVerify 속성을 포함합니다.\n\n## ⚡ 사용자가 Android 앱 링크를 클릭하면 설치되어 있으면 즉시 앱이 열리며 명확성 제거 대화 상자가 나타나지 않습니다.\n\n## ⚡ 사용자가 앱을 기본 핸들러로 설정하고 싶지 않다면, 앱 설정에서 이 동작을 재정의할 수 있습니다.\n\n## 🧑‍💻\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<intent-filter android:autoVerify=\"true\">\n  <action android:name=\"android.intent.action.VIEW\" />\n  <category android:name=\"android.intent.category.DEFAULT\" />\n  <category android:name=\"android.intent.category.BROWSABLE\" />\n  <data android:scheme=\"http\" />\n  <data android:scheme=\"https\" />\n  <data android:host=\"myownpersonaldomain.com\" />\n</intent-filter>\n```\n\n# 👍 Android 앱 링크는 다음과 같은 이점을 제공합니다:\n\n# 🤔 안전하고 특정: Android 앱 링크는 소유한 웹 사이트 도메인으로 링크된 HTTP URL을 사용하기 때문에 다른 앱이 여러분의 링크를 사용할 수 없습니다.\n\n# 🤔 신뢰할 수 있는 사용자 경험: Android 앱 링크는 웹 사이트와 앱에서 동일한 콘텐츠에 대해 단일 HTTP URL을 사용하므로 앱이 설치되지 않은 사용자는 앱이 아닌 웹 사이트로 이동하게 됩니다. 404 오류나 오류가 발생하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 참고 링크:\n\n- [앱 링크 소개](About App Links)\n- [딥 링크 생성](Create Deep Links)\n\n# [www.moboinfo.com](www.moboinfo.com)\n\nLinkedin: [https://www.linkedin.com/in/devprithvi/](https://www.linkedin.com/in/devprithvi/)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n깃허브: https://github.com/devprithvi\n\n유튜브: https://www.youtube.com/@moboinfo\n\n#딥링크 #안드로이드 #안드로이드딥링크\n","ogImage":{"url":"/assets/img/2024-06-19-AndroidHandlingAndroidAppLinks_0.png"},"coverImage":"/assets/img/2024-06-19-AndroidHandlingAndroidAppLinks_0.png","tag":["Tech"],"readingTime":4},{"title":"Gradle에서 종속성을 디버깅하기","description":"","date":"2024-06-19 10:29","slug":"2024-06-19-DebuggingdependenciesinGradle","content":"\n## Android 앱에서 dependencyInsight 사용 방법 및 transient dependencies를 특정 버전으로 고치는 방법\n\n![이미지](/assets/img/2024-06-19-DebuggingdependenciesinGradle_0.png)\n\n간략히 말하자면; 빠르게 알고 싶다면 아래의 제목 섹션으로 이동하여 dependencyInsight를 사용하는 방법에 대한 지침을 따르세요.\n\n최근에 안드로이드 앱에서 종속성을 베타 버전(androidx.navigation:navigation-compose, 버전 2.8.0-beta02 정확히)으로 업그레이드해야 했습니다. 일반적으로 베타 버전의 종속성은 다른 Jetpack Compose 종속성(일시적 종속성)을 필요로 합니다. 그 중에는 알파 또는 베타 버전으로 지정된 것들도 있습니다. 일반적으로 이는 괜찮습니다. 알파 또는 베타 버전의 종속성에 문제가 있을 수 있고, 안정된 버전을 기다릴 수 있고 필요하다면 버그를 제기할 수 있다는 것을 받아들입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 내 경우에는 기다릴 수 없었습니다. 내 앱에 빨리 배포해야 하는 쿨한 새로운 기능을 새로운 네비게이션 라이브러리(Type-Safe Navigation yay!)에서 원했어요. 문제는, 일시적 종속성의 새로운 알파 버전이 앱에서 발생시키지 않으려고 했던 크래시를 일으켰다는 것이었어요(내 경우 HorizontalPager에서 NoSuchMethodError가 발생했어요)!\n\n조사를 해보니, HorizontalPager 생성자가 androidx.compose.foundation 종속성의 1.7.0-beta02 버전에서 시그니처가 변경되었다는 것을 발견했어요(HorizontalPager는 실험적 API로 표시되어 있어 이것이 전혀 놀라운 일이 아니었어요). 이것은 androidx.navigation:navigation의 일시적 종속성으로 포함되었던 것이었어요. 네비게이션 라이브러리는 1.7.0-beta02 버전을 명시했지만, 이전 안정 버전인 1.6.7에서 내 HorizontalPager 구현이 작동하는 것을 알고 있었어요.\n\n그럼 어떡해야 할까요? androidx.navigation:navigation 또는 androidx.compose.foundation:foundation이 안정화되어 내 앱에 통합되기를 기다릴까요(필요한 새로운 기능을 배포해야 하지만)? 새로운 종속성을 가지고 무언가를 갖다 붙이려고 노력할까요, 아니면 안정화된 종속성 버전이 사용되도록 확인할 수 있을까요?\n\n이 시점에서 난 심지어 어떤 종속성이 일시적 종속성 버전 업그레이드를 유발하고 있는지도 몰랐어요 — 똑같은 작업에서 다른 종속성을 여러 개 업데이트했기 때문에 무엇이든지 가능합니다...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Gradle 의존성 트리 보기\n\n가장 먼저 확인해야 할 것은 전체 의존성 트리입니다.\n\n가장 간단한 방법은 gradle wrapper를 사용하여 의존성 명령을 실행하는 것입니다:\n\n```js\n./gradlew :app:dependencies\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위에서도 언급했듯이 모듈을 지정하면 흥미로운 모듈 전체의 출력을 얻을 수 있습니다. 모듈을 제외하면 보통 원하는 결과가 아닌 상위 수준의 세부 정보만을 얻게 됩니다.\n\n대신 모듈을 지정하면 해당 모듈이 필요로 하는 종속성 목록 및 이를 통해 암시적으로 필요한 종속성들을 얻을 수 있습니다.\n\n더 신기하게 하고 싶다면 종속성 명령에 --scan을 추가하여 검색 가능한 웹 기반 보고서를 생성할 수도 있습니다. 이를 위해서는 gradle으로 이메일을 확인해야 하며, 종종 텍스트 버전을 볼 때 더 빠르다고 생각합니다. 일반적으로 명령 결과를 파일로 출력하여 큰 프로젝트에서도 변경 전과 변경 후 결과를 비교할 수 있습니다 (결과가 너무 길어질 수 있습니다!).\n\n./gradlew :app:dependencies `dependencyTree.txt\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 의존성 트리 출력 이해하기\n\n만약 결과 파일을 살펴보면 엄청나게 크다는 것을 알 수 있습니다 (간단한 테스트 Hello World 앱으로는 7435줄이었어요). 원하는 설정을 지정하여 이를 줄일 수 있습니다. 대부분의 경우에는 compileClasspath, runtimeClasspath, testCompileClasspath, 그리고 testRuntimeClasspath를 확인할 수 있습니다. 저는 runtimeClasspath를 필요로 했고, 빌드 유형을 debug로 추가했어요:\n\n```js\n./gradlew :app:dependencies --configuration debugRuntimeClasspath\n> dependencyTree.txt\n```\n\n이제 제 파일은 단지 692줄이에요. 훨씬 사용하기 편리하죠!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 우리는 모든 종속성과 포함된 순환 종속성을 확인할 수 있어요. 예를 들어:\n\n```js\n+--- androidx.navigation:navigation-compose:2.8.0-beta02\n|    +--- androidx.activity:activity-compose:1.8.0 -> 1.9.0 (*)\n|    +--- androidx.compose.animation:animation:1.7.0-beta02 (*)\n|    +--- androidx.compose.foundation:foundation-layout:1.7.0-beta02 (*)\n|    +--- androidx.compose.runtime:runtime:1.7.0-beta02 (*)\n|    +--- androidx.compose.runtime:runtime-saveable:1.7.0-beta02 (*)\n|    +--- androidx.compose.ui:ui:1.7.0-beta02 (*)\n|    +--- androidx.lifecycle:lifecycle-viewmodel-compose:2.6.2 -> 2.8.1\n|    |    \\--- androidx.lifecycle:lifecycle-viewmodel-compose-android:2.8.1\n|    |         +--- androidx.annotation:annotation:1.8.0 (*)\n|    |         +--- androidx.compose.runtime:runtime:1.6.0 -> 1.7.0-beta02 (*)\n|    |         +--- androidx.compose.ui:ui:1.6.0 -> 1.7.0-beta02 (*)\n|    |         +--- androidx.lifecycle:lifecycle-common:2.8.1 (*)\n|    |         +--- androidx.lifecycle:lifecycle-viewmodel:2.8.1 (*)\n...\n```\n\n여기서 우리는 androidx.navigation:navigation-compose가 androidx.compose.foundation:foundation-layout:1.7.0-beta02를 포함한다는 것을 볼 수 있어요.\n\nGradle 문서에서는 각 종속성마다 나열된 주석 기호의 의미를 이해하는 데 도움이 되는 설명이 명확하게 제공되어 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 여기서 androidx.navigation:navigation-compose:2.8.0-beta02가 androidx.compose.foundation:foundation-layout을 버전 1.7.0-beta02를 사용하도록 강제하는지 알 수 없어요. 큰 프로젝트에서는 문제가 되는 라이브러리의 각 언급을 모두 확인하고 비교하는 것도 매우 수고스러울 수 있어요.\n\n# dependencyInsight로 의존성 대상 지정하기\n\n대신, dependencyInsight를 사용하여 의존성에 대한 특정 해결 방법 정보를 얻을 수 있어요.\n\n./gradlew :app:dependencyInsight — configuration debugRuntimeClasspath — dependency androidx.compose.foundation ` dependencyInsight.txt`\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n./gradlew :app:dependencyInsight --configuration debugRuntimeClasspath\n--dependency androidx.compose.foundation > dependencyInsight.txt\n\n여기서도 구성을 전달하고 관심 있는 종속성을 인수로 추가합니다. 또한 결과를 파일에 보내어 변경 전과 변경 후의 결과를 diff 할 수 있습니다. --scan 플래그를 사용하여 웹 버전도 있습니다.\n\n파일 상단에는 종속성에 대한 메타데이터와 요청된 버전 및 해결된 버전에 대한 정보가 표시됩니다:\n\n> 작업 :app:dependencyInsight\n> androidx.compose.foundation:foundation:1.7.0-beta02\n> Variant releaseRuntimeElements-published:\n\n    | 속성 이름                                      | 제공     | 요청    |\n    |----------------------------------------------|---------|---------|\n    | org.gradle.status                             | release |         |\n    | org.gradle.category                           | library | library |\n    | org.gradle.usage                              | java-runtime | java-runtime |\n    | org.jetbrains.kotlin.platform.type            | androidJvm | androidJvm |\n    | com.android.build.api.attributes.AgpVersionAttr | | 8.6.0-alpha03 |\n    | com.android.build.api.attributes.BuildTypeAttr  | | debug |\n    | org.gradle.jvm.environment                     | | android |\n    선택 이유:\n       - 제약 조건으로 인해 foundation-layout이 atomic 그룹인 androidx.compose.foundation에 있음\n       - 제약 조건으로 인해\n       - 제약 조건으로 인해 Text의 심각한 버그 방지\n       - 버전 1.7.0-beta02, 1.6.7, 1.4.0 및 1.6.0 사이의 충돌 해결로 인해\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 해결된 버전과 그것을 요청한 종속성 목록을 볼 수 있습니다:\n\n```js\nandroidx.compose.foundation:foundation:1.7.0-beta02\n+--- debugRuntimeClasspath\n\\--- androidx.compose.foundation:foundation-layout-android:1.7.0-beta02\n     +--- androidx.compose:compose-bom:2024.05.00 (androidx.compose.foundation:foundation-layout-android:1.6.7를 요청함)\n     |    \\--- debugRuntimeClasspath\n     \\--- androidx.compose.foundation:foundation-layout:1.7.0-beta02\n          +--- androidx.compose:compose-bom:2024.05.00 (androidx.compose.foundation:foundation-layout:1.6.7를 요청함) (*)\n          +--- androidx.navigation:navigation-compose:2.8.0-beta02\n...\n```\n\n각 요청에 대한 선택 이유도 제공됩니다. 따라서 여기에서 문제 버전이 선택된 이유를 찾을 수 있습니다.\n\n나무가 크고 어떤 라이브러리가 원인일 수 있다는 감이 있다면, 아래 설명된대로 제외를 수행한 후 명령어를 다시 실행하고 출력을 비교하여 변경된 내용을 확인할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 특정 종속성 버전 강제 지정\n\n이제 원하지 않는 추이 버전을 포함시키는 종속성 또는 종속성을 알게 되었으므로, **exclude**를 사용하여 제외할 수 있습니다. 다음은 내 예시입니다:\n\n```js\nimplementation(libs.compose.navigation) {\n    exclude(group = \"androidx.compose.foundation\", module = \"foundation\")\n    exclude(group = \"androidx.compose.foundation\", module = \"foundation-android\")\n    exclude(group = \"androidx.compose.foundation\", module = \"foundation-layout-android\")\n}\n```\n\n위와 같이 사용하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ncompose-navigation = { group = \"androidx.navigation\", name = \"navigation-compose\", version.ref = \"2.8.0-beta02\"\n\n그리고 원하는 버전을 포함시키는 것을 잊지 마세요:\n\nimplementation(libs.compose.foundation)\nimplementation(libs.compose.foundation.layout)\n\nwhere:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\ncompose-foundation = { group = \"androidx.compose.foundation\", name = \"foundation\", version.ref = \"1.6.7\"}\ncompose-foundation-layout = { group = \"androidx.compose.foundation\", name = \"foundation-layout-android\", version.ref = \"1.6.7\"}\n```\n\n위와 같이 제 종속성 문제를 해결했어요. 당연히 전이 종속성 버전을 재정의하는 것은 자주 하고 싶지 않은 일이에요 (의외로 빌드 또는 런타임 오류를 발생시키기도 해요) 하지만 필요할 때는 시도해볼 가치가 있는 것이에요.\n","ogImage":{"url":"/assets/img/2024-06-19-DebuggingdependenciesinGradle_0.png"},"coverImage":"/assets/img/2024-06-19-DebuggingdependenciesinGradle_0.png","tag":["Tech"],"readingTime":11},{"title":"안드로이드 앱 개발 플랫폼의 미래 트렌드","description":"","date":"2024-06-19 10:28","slug":"2024-06-19-FutureTrendsinAndroidAppDevelopmentPlatforms","content":"\n안녕하세요! 안드로이드 앱 개발의 세계는 끊임없이 진화하고 있습니다. 전 세계에서 활성화된 안드로이드 장치가 25억 대 이상이 되면서, 이 플랫폼은 모바일 시장을 지배하고 있습니다. 기술이 발전함에 따라 새로운 트렌드가 등장하여 개발자들이 앱을 만드는 방식을 형성하고 있습니다. AppsRhino에서는 이러한 트렌드를 면밀히 살피어 고객들이 선발에 성공할 수 있도록 돕고 있습니다. 안드로이드 앱 개발 플랫폼의 미래 트렌드 중 일부를 살펴보겠습니다.\n\n# 1. 인공지능 및 머신 러닝 통합\n\n인공지능 (AI)과 머신 러닝 (ML)은 기술 산업을 변화시키고 있으며, 안드로이드 앱 개발도 예외는 아닙니다. AI 및 ML은 개인화, 예측 분석 및 스마트 자동화를 통해 사용자 경험을 향상시킬 수 있습니다.\n\n# 작동 방식:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 개인 맞춤 콘텐츠: 앱은 사용자의 행동과 선호도를 분석하여 맞춤형 콘텐츠를 제공할 수 있습니다.\n- 예측 분석: 인공지능은 사용자의 필요를 예측하고 그에 맞는 조치나 제품을 제안할 수 있습니다.\n- 스마트 자동화: 음성 비서와 챗봇과 같은 기능들이 사용자 상호작용을 개선합니다.\n\n**실제 예시:**\n\n구글 어시스턴트는 많은 안드로이드 앱에 통합되어 사용자 명령을 이해하고 효율적으로 작업을 수행하는 데 인공지능을 활용합니다.\n\n# 2. 사물인터넷(IoT) 연결성\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인터넷 의사소통(IoT)은 일상적인 장치들을 인터넷에 연결하여 데이터를 주고받을 수 있도록 합니다. 안드로이드 앱에서의 IoT 통합을 통해 사용자들은 스마트폰에서 직접 스마트 장치들을 제어하고 모니터링할 수 있습니다.\n\n## 작동 방식:\n\n- 스마트 홈 장치: 모바일 앱을 통해 조명, 난방 및 보안 시스템을 제어할 수 있습니다.\n- 웨어러블 기기: 건강 지표를 모니터링하기 위해 피트니스 추적기 및 스마트워치를 동기화합니다.\n\n## 실제 사례:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nGoogle Home과 같은 앱을 사용하면 사용자들은 쉽게 스마트 홈 기기를 관리할 수 있어요.\n\n## 3. 증강 현실 (AR) 및 가상 현실 (VR)\n\n증강 현실 (AR) 및 가상 현실 (VR)은 게임, 교육 및 소매 분야에서 점점 인기 있는 몰입형 경험을 제공해요. 이러한 기술들은 사용자들이 앱과 상호 작용하는 방식을 혁신할 것으로 예상돼요.\n\n## 작동 방법:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AR: 카메라 화면을 통해 디지털 콘텐츠를 실제 세계에 덧붙입니다.\n- VR: VR 헤드셋을 사용하여 완전히 몰입형 디지털 환경을 만듭니다.\n\n## 실제 예시:\n\nIKEA Place와 같은 앱들은 AR을 사용하여 사용자가 가구를 구매하기 전에 집 안에서 가구가 어떻게 보일지 시각화할 수 있게 돕습니다.\n\n## 4. 블록체인 기술\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n블록체인 기술은 암호화폐에만 해당되는 것이 아닙니다. 금융, 의료, 공급망 관리를 포함한 다양한 산업에 혜택을 주는 안전하고 투명하며 탈중앙화된 솔루션을 제공합니다.\n\n## 작동 방식:\n\n- 보안: 거래를 안전하게 처리하고 데이터를 저장하는 안전한 방법을 제공합니다.\n- 투명성: 탈중앙화된 장부를 통해 데이터 무결성과 투명성을 확보합니다.\n\n## 실제 사례:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱들은 블록체인을 이용하여 다이아몬드나 고급 와인과 같은 가치 있는 물품의 진위와 유래를 확인하는 데 사용됩니다.\n\n## 5. 5G 기술\n\n5G 기술의 도입으로 더 빠른 인터넷 속도와 더 안정적인 연결이 약속되고 있습니다. 안드로이드 앱 개발에 상당한 영향을 미칠 것으로 예상되며, 더 복잡하고 데이터 중심적인 애플리케이션을 제공할 수 있습니다.\n\n## 작동 방식:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 속도: 상당히 빠른 다운로드 및 업로드 속도를 제공합니다.\n- 지연 시간: 실시간 통신 및 스트리밍을 효율적으로 만들어 지연 시간을 줄입니다.\n\n## 현실 세계 예시:\n\n5G는 모바일 게임 및 비디오 회의와 같은 앱에서 경험을 향상시켜 더 부드럽고 반응성이 뛰어난 상호작용을 제공합니다.\n\n## 6. 클라우드 기반 개발\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클라우드 기반 개발 플랫폼은 확장성, 유연성 및 비용 효율성으로 인해 인기를 얻고 있어요. 이러한 플랫폼을 사용하면 개발자들은 별도의 하드웨어가 필요하지 않고 애플리케이션을 개발, 테스트 및 배포할 수 있어요.\n\n## 작동 방식:\n\n- 확장성: 수요에 따라 쉽게 자원을 확장하거나 축소할 수 있어요.\n- 협업: 분산된 개발 팀 간의 협업을 용이하게 해줘요.\n\n## 실제 사례:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파이어베이스와 같은 플랫폼은 클라우드 기반 백엔드 서비스를 제공하여 앱 개발을 간편하게 하고 성능을 향상시킵니다.\n\n## 7. 즉시 앱\n\n즉시 앱은 사용자가 설치하지 않고도 앱을 시도할 수 있게 해줍니다. 이 기능은 원활한 경험을 제공하여 사용자 참여 및 전환율을 높일 수 있습니다.\n\n## 작동 방식:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 접근성: 사용자들은 링크를 통해 앱의 일부에 즉시 접근할 수 있습니다.\n- 사용자 경험: 앱의 발견 및 사용 과정에서 마찰을 줄입니다.\n\n**실제 예시:**\n\nGoogle Play Instant를 통해 사용자들은 전체 다운로드를 약속하기 전에 게임과 앱을 테스트할 수 있습니다.\n\n## 8. 앱 보안 강화\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 개인 정보 보호 및 보안에 대한 우려가 커지면서, 강화된 앱 보안 조치가 개발자들에게 중요한 과제가 되고 있습니다. 견고한 보안 프로토콜을 구현함으로써 사용자 데이터를 안전하게 보호하고 신뢰를 구축할 수 있습니다.\n\n# 작동 방식:\n\n- 암호화: 데이터가 안전하게 전송되고 저장되도록 합니다.\n- 인증: 사용자 신원을 확인하기 위해 다중 인증을 사용합니다.\n\n# 실제 사례:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSignal과 같은 앱은 안전한 메시징을 보장하기 위해 종단간 암호화를 제공합니다.\n\n## 9. 다중 플랫폼 개발 도구\n\nFlutter와 React Native과 같은 다중 플랫폼 개발을 지원하는 도구를 사용하면, 개발자는 코드를 한 번 작성하고 안드로이드 및 iOS를 포함한 여러 플랫폼에 배포할 수 있습니다.\n\n## 작동 방식:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 코드 재사용성: 코드를 한 번 작성하고 여러 플랫폼에서 사용합니다.\n- 일관성: 다른 기기에서도 일관된 사용자 경험을 보장합니다.\n\n## 실제 예시:\n\nReflectly와 같은 앱은 Flutter를 사용하여 Android 및 iOS에서 일관된 사용자 경험을 제공합니다.\n\n## 10. 음성 기술\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n음성 기술은 모바일 앱에 점점 더 통합되어 사용자가 기기와 상호 작용하는 무료 손 쉬운 방법을 제공합니다. Google 어시스턴트와 같은 음성 비서들이 이 트렌드를 이끌고 있습니다.\n\n## 작동 방식:\n\n- 음성 명령: 사용자는 음성 명령을 사용하여 작업을 수행할 수 있습니다.\n- 음성 검색: 음성 검색 기능으로 앱 기능을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n보이스 기능이 탑재된 Google Maps와 같은 앱을 사용하면 사용자는 목소리로 길 안내 및 위치 검색을 할 수 있어요.\n\n# 결론\n\n안드로이드 앱 개발의 미래는 밝은데요, AI 및 IoT부터 5G 및 블록체인까지 많은 흥미로운 트렌드가 다가오고 있어요. 이러한 발전은 사용자 경험을 향상시키고 개발자들에게 새로운 가능성을 열어줄 것으로 기대되어요. AppsRhino에서는 이러한 트렌드를 선도하며 클라이언트를 위한 최첨단 솔루션을 제공하고 있어요. 기존 앱에 최신 기술을 통합하거나 새로운 앱을 처음부터 구축하려는 경우, 당사의 전문가 팀이 도와드리겠어요. 안드로이드 앱 개발의 미래를 탐험하는 데 어떻게 도울 수 있는지 자세히 알아보려면 오늘 당사에 문의해주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-FutureTrendsinAndroidAppDevelopmentPlatforms_0.png"},"coverImage":"/assets/img/2024-06-19-FutureTrendsinAndroidAppDevelopmentPlatforms_0.png","tag":["Tech"],"readingTime":8}],"page":"43","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}