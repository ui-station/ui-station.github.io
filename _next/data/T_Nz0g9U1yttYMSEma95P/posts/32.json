{"pageProps":{"posts":[{"title":"iOS SwiftUI 프로젝트에서 MVVM으로 적용하는 Clean Architecture","description":"","date":"2024-06-19 14:01","slug":"2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject","content":"\n![Clean Architecture](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png)\n\nClean architecture는 Robert C. Martin(명칭: Uncle Bob)이 소개한 소프트웨어 디자인 원칙입니다. Hexagonal Architecture, Onion Architecture, Screaming Architecture 등 소프트웨어 아키텍처에 대한 몇 가지 아이디어가 있었습니다. 이러한 아키텍처들의 주요 개념은 관심사의 분리입니다.\n\n이 기사에서는 클린 아키텍처를 논의하고, 데모 프로젝트를 통해 iOS SwiftUI 앱에 Clean Architecture와 MVVM을 적용하는 방법을 살펴볼 것입니다.\n\n# 클린 아키텍처\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_1.png)\n\n위 그래프에서 확인할 수 있듯이, 원들은 소프트웨어의 서로 다른 영역을 나타냅니다. 가장 바깥쪽 층은 소프트웨어의 가장 낮은 수준이며, 깊이 들어갈수록 소프트웨어의 수준이 높아집니다. 내부 층은 외부 층에 대해 아무것도 알지 못합니다. 보통, 층이 깊어질수록 해당 층은 변하기 적은 경향이 있습니다.\n\n클린 아키텍처의 주요 규칙은 내부 층에서 외부 층으로의 의존성을 갖지 않는 것입니다. 의존성은 외부 층에서 내부 층으로 연결되어야 합니다. 바깥쪽에서 안쪽으로 향하는 화살표가 의존성 규칙입니다.\n\n클린 아키텍처에는 다양한 층이 있으며, 그룹화한 후에 프레젠테이션, 도메인 및 데이터 층 세 개로 구분할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_2.png\" />\n\n## 표현 계층\n\n이 계층은 View와 ViewModel로 구성되어 있습니다. View는 하나 이상의 사용 사례를 실행하는 ViewModel에 의해 조정됩니다. 표현 계층은 도메인 계층에만 의존합니다.\n\n## 도메인 계층\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 가장 안쪽 레이어입니다. 이 레이어에는 Entities, Use cases 및 Repository interfaces가 포함되어 있습니다. 이 레이어는 다른 레이어에 종속적이지 않습니다. 따라서 이 레이어는 재사용이 가능하고 테스트하기 쉽습니다. 또한 비즈니스 로직이 여기에 작성됩니다.\n\n## 데이터 레이어\n\n이 레이어에는 리포지토리 구현 및 데이터 소스가 포함되어 있습니다. 리포지토리는 데이터 소스로부터 데이터를 조정하는 역할을 합니다. 데이터 소스는 원격 또는 로컬(예: 코어 데이터)일 수 있습니다. 데이터 레이어는 도메인 레이어에 종속됩니다. 이 레이어에서는 네트워크 JSON 데이터를 도메인 모델로 매핑할 수 있습니다.\n\n## 의존성 방향과 데이터 흐름\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n인터페이스(UI)는 ViewModel(프리젠터)에서 메서드를 호출합니다. ViewModel은 Use Case를 실행하고, Use Case는 데이터를 가져오기 위해 Repository를 호출합니다. Repository는 네트워크나 영구 저장 DB에서 데이터를 가져옵니다. 데이터는 다시 UI로 흐르고, 여기서 데이터를 보여줍니다.\n\n이 흐름은 다음과 같습니다:\n\n인터페이스(UI) - ViewModel(프리젠터) - Use Case(도메인) - Repository(데이터)\n\n이 흐름은 Clean Architecture의 종속성 규칙을 위배합니다. 종속성 규칙에 따르면, 가장 내부에 있는 도메인 레이어는 가장 바깥에 있는 데이터 레이어에 종속되어서는 안 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n도메인 계층(Use Case)이 사용 사례(도메인 계층)부터 직접적으로 의존하는 대신, 사용 사례는 저장소 인터페이스/프로토콜에 의존하게 됩니다. 이 저장소 프로토콜은 도메인 계층 안에 존재할 것입니다. 이렇게 함으로써 우리는 흐름의 방향을 뒤집을 수 있습니다. 이 뒤집힌 방향이 어떻게 이뤄지는지 자세히 이해해 봅시다:\n\n![이미지](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_3.png)\n\n의존성 역전은 데이터 계층과 도메인 계층 간에 발생합니다. 도메인 계층 내부에 저장소 인터페이스가 있기 때문에 데이터 계층은 저장소 인터페이스를 위해 도메인 계층에 의존하게 됩니다. 도메인 계층에서 인터페이스가 변경된다면 데이터 계층도 그에 따라 변경될 것입니다. 여기서는 의존성 방향이 역전되어 있습니다.\n\n인터페이스는 더 높은 수준(도메인에서)에서 결정되고 해당 수준의 클래스(사용 사례)가 이에 의존하므로 추상화에 의존하게 됩니다. 게다가 하위 수준 클래스(저장소) 구현은 더 높은 수준에서 정의된 인터페이스에 의존하므로 세부 사항은 이제 추상화에 의존하게 됩니다. 이것이 바로 의존성 역전의 원칙입니다. 기억하세요, 소프트웨어의 내부 원이 더 높은 수준의 소프트웨어 수준이므로 도메인 계층은 데이터 계층보다 높은 수준에 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그래서, 흐름이 다음과 같이 됩니다:\n\n프레젠테이션 레이어 — `도메인 레이어` — 데이터 레이어\n\n이론은 여기까지! 이제 각 레이어와 MVVM을 예제 프로젝트 및 샘플 코드를 통해 이해하는 시간입니다.\n\n# 예제 프로젝트 — ProductClean\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 공개 API에서 제품 목록을 가져와 목록으로 표시하는 간단한 iOS 애플리케이션입니다. 목록에서 각 항목을 클릭하면 제품 세부 정보 페이지로 이동합니다. 이 프로젝트는 MVVM과 Clean 아키텍처를 사용하여 구축되었습니다. SwiftUI를 사용하여 UI를 구현했습니다.\n\nClean 아키텍처는 구성 요소 간의 역할 분리를 위해 사용되었고 MVVM과 Clean 아키텍처를 함께 사용하여 UI와 프리젠터 사이의 역할을 분리했습니다.\n\n앱의 HLD (고수준 설계) 및 폴더 구조를 살펴보겠습니다:\n\nHLD를 통해 이 앱에는 제품이라는 단일 모듈이 있음을 알 수 있습니다. 필요한 경우 여러 모듈을 가질 수 있습니다. 예를 들어, 이 앱에 로그인 및 결제 기능을 추가하려면 로그인 및 결제 모듈을 추가할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저희는 세 개의 레이어를 가지고 있다는 것을 알고 있어요. 각 레이어를 자세히 살펴볼게요:\n\n## 프레젠테이션 레이어\n\n프레젠테이션 레이어 = ViewModel(프레젠터) + View(UI)\n\n프레젠테이션 레이어에는 ProductListView와 ProductListViewModel이 포함되어 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductListView\n\nProductListView는 비즈니스 로직(Use cases)에 대한 접근이 없고 데이터 조작과 관련된 코드도 포함하고 있지 않아요. 오직 ViewModel에만 접근할 수 있어요. 따라서 뷰는 재사용성이 높아지고 교체가 가능해져요.\n\n뷰는 ViewModel에 제품 데이터를 가져오도록 요청하고 ViewModel에서 제품 배열을 관찰해요. 제품 배열을 받으면 해당 데이터를 목록에서 표시해요.\n\n```js\nimport SwiftUI\n\nstruct ProductListView<ViewModel>: View where ViewModel: ProductListViewModelProtocol {\n\n    @ObservedObject private var viewModel: ViewModel\n    init(viewModel: ViewModel) {\n        self.viewModel = viewModel\n    }\n\n    var body: some View {\n        NavigationStack {\n            if viewModel.shouldShowLoader() {\n                ProgressView()\n                    .progressViewStyle(.circular)\n            } else {\n                ProductListLayout(items: viewModel.products)\n                    .overlay {\n                        if viewModel.isError {\n                            ErrorView(errorTitle: AppConstant.errorTitle, errorDescription: viewModel.error) {\n                                Task {\n                                    await fetchProducts()\n                                }\n                            }\n                        }\n                    }\n                    .navigationTitle(viewModel.title)\n            }\n        }\n        .task {\n            await fetchProducts()\n        }\n    }\n\n    private func fetchProducts() async {\n        await viewModel.fetchProducts()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n참고: @ObservedObject 프로퍼티 래퍼는 뷰 내에 observable 유형인 ViewModel을 저장하는 데 사용됩니다.\n\nProductListViewModel\n\nProductListViewModel은 어떤 UI 프레임워크도 import하지 않습니다. 따라서 재사용 가능해집니다. 이는 ProductListViewModelProtocol을 준수하며 ViewModel을 모의(mock)할 수 있고 테스트할 수 있도록 합니다.\n\n```js\nimport Foundation\n\nprotocol ProductListViewModelProtocol: ObservableObject {\n    var products: [ProductListItemViewModel] { get set }\n    var isError: Bool { get }\n    var error: String { get }\n    var isEmpty: Bool { get }\n    var title: String { get }\n    func shouldShowLoader() -> Bool\n    func fetchProducts() async\n}\n\nfinal class ProductListViewModel: ProductListViewModelProtocol {\n\n    @Published var products: [ProductListItemViewModel] = []\n    @Published var isError: Bool = false\n    @Published var error: String = \"\"\n    var isEmpty: Bool { return products.isEmpty }\n    var title: String = AppConstant.productListTitle\n    private let productListUseCase: ProductListUseCase!\n\n    init(useCase: ProductListUseCase) {\n        self.productListUseCase = useCase\n    }\n\n    /// This method fetches products and catches error if any\n    @MainActor func fetchProducts() async {\n        do {\n            let productList = try await productListUseCase.fetchProductList()\n            self.products = self.transformFetchedProducts(products: productList)\n            self.isError = false\n        } catch {\n            self.isError = true\n            if let networkError = error as? NetworkError {\n                self.error = networkError.description\n            } else {\n                self.error = error.localizedDescription\n            }\n        }\n    }\n\n    /// This method maps Product to ProductListItemViewModel\n    /// - Parameter products: array of Product\n    /// - Returns: array of ProductListItemViewModel\n    private func transformFetchedProducts(products: [ProductDomainListDTO]) -> [ProductListItemViewModel] {\n        products.map { ProductListItemViewModel(id: $0.productId,\n                                           title: $0.title,\n                                           description: $0.description,\n                                                price: $0.price.getAmountWithCurrency(),\n                                                category: $0.category.capitalized,\n                                           image: $0.thumbnail) }\n    }\n\n    /// This method checks if the loader should be shown or not\n    /// - Returns: True if there the product array is empty and error is not there\n    func shouldShowLoader() -> Bool {\n        return (isEmpty && !isError)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductListViewModel은 제품 배열, 오류 및 기타 정보를 저장하기 위해 ObservableObject 프로토콜을 준수합니다. ProductListViewModel 내부의 속성에는 뷰에서 액세스되기 때문에 뷰가 업데이트되는 @Published 속성 래퍼가 추가되었습니다. 따라서 @Published 속성 (제품, isError 등) 중 하나가 변경되면 뷰가 업데이트됩니다.\n\nfetchProducts 함수에 @MainActor 속성이 사용되면 해당 작업이 주 스레드에서 실행됨을 보장합니다. fetchProducts 함수 내부에서 @Published 속성이 업데이트되는 것을 볼 수 있습니다. 이러한 속성이 뷰에서 사용되고 이러한 속성이 변경될 때 뷰가 업데이트된다는 것을 알고 있습니다. 뷰(UI)가 주 스레드에서 업데이트되기를 원합니다.\n\n## MVVM\n\nMVVM(Mode-View-ViewModel)은 ViewModel이 뷰와 모델 사이에서 중재자 역할을 하는 디자인 패턴입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![image](/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_4.png)\n\n뷰모델은 UI 프레임워크를 가져오지 않기 때문에 재사용 가능하고 테스트할 수 있습니다. 하나의 뷰모델에 대해 서로 다른 뷰 구현을 사용할 수 있습니다. 예를 들어, 같은 뷰모델에 대해 UIKit 또는 SwiftUI 뷰를 사용할 수 있습니다.\n\n위에서 논의한 대로 데이터 바인딩에는 ObservableObject 프로토콜을 사용했지만 다른 데이터 바인딩 방법도 사용할 수 있습니다. 예를 들어 델리게이트, 클로저, 알림, 구독자/발행자 등이 있습니다.\n\n저희 프로젝트에서 MVVM은 UI와 프리젠터 간의 관심을 분리하는 데 사용되었습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 도메인 레이어\n\n도메인 레이어 = 유스 케이스 + 엔티티 + 리포지토리 인터페이스\n\n도메인 레이어는 ProductListUseCase, ProductDomainListDTO(엔티티) + ProductListRepository 프로토콜로 이루어져 있어요.\n\n특정 모듈의 요구 사항에 따라 여러 개의 유스 케이스가 있을 수 있고, 하나의 유스 케이스가 다른 유스 케이스에 의존할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 계층은 Use Case에 쓰인 응용 프로그램 비즈니스 규칙 때문에 가장 중요한 계층입니다. 우리는 Use Case를 보기만 해도 응용 프로그램이 무엇을 하는지 이해할 수 있습니다. 이것을 Screaming Architecture라고 합니다.\n\nProductListUseCase\n\nProductListUseCase는 fetchProductList 함수를 포함하는 ProductListUseCase 프로토콜을 준수합니다. 이는 저장소에 접근하고 저장소로부터 제품 목록 데이터를 불러옵니다.\n\n```js\nimport Foundation\n\nprotocol ProductListUseCase {\n    func fetchProductList() async throws -> [ProductDomainListDTO]\n}\n\nfinal class DefaultProductListUseCase: ProductListUseCase {\n\n    private let repository: ProductListRepository\n\n    init(repository: ProductListRepository) {\n        self.repository = repository\n    }\n\n    func fetchProductList() async throws -> [ProductDomainListDTO] {\n        try await repository.fetchProductList()\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductListRepositoryProtocol\n\n도메인 레이어에는 ProductListRepositoryProtocol이 포함되어 있고 ProductListUseCase는 직접 repository 대신 ProductListRepositoryProtocol에 종속되어 있습니다. 따라서 의존성 방향이 역전되었습니다. 위의 의존성 방향 및 데이터 흐름 섹션에서 이미 자세히 논의한 바 있습니다.\n\n```js\nprotocol ProductListRepository {\n    func fetchProductList() async throws -> [ProductDomainListDTO]\n}\n```\n\n참고: ProductListRepositoryProtocol은 의존성 역전에 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nProductDomainListDTO\n\nProductDomainListDTO는 도메인 데이터 전송 객체(DTO)로, 중간 객체로 작동하고 개체를 프레젠테이션 레이어에서 사용할 모델로 변환하는 역할을 담당합니다.\n\n```js\nimport Foundation\n\nstruct ProductDomainListDTO {\n    let productId: Int\n    let title: String\n    let description: String\n    let price: Double\n    var category: String\n    let thumbnail: String\n}\n```\n\n## 데이터 레이어\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 레이어 = 리포지토리 구현 + 서비스 / 데이터 저장소\n\n데이터 레이어는 DefaultProductListRepository(리포지토리 구현)와 ProductListService로 구성되어 있습니다.\n\nDefaultProductListRepository\n\nDefaultProductListRepository는 ProductListService에 액세스하고 서비스로부터 제품 데이터를 가져와 도메인으로 데이터를 반환하는 fetchProductList 함수를 갖고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport Foundation\n\nfinal class DefaultProductListRepository: ProductListRepository {\n\n    private let service: ProductListService\n\n    init(service: ProductListService) {\n        self.service = service\n    }\n\n    func fetchProductList() async throws -> [ProductDomainListDTO] {\n        try await service.fetchProductListFromNetwork().products.map { $0.toDomain() }\n    }\n}\n```\n\n참고: 앱이 오프라인 지원을 하는 경우 ProductListRepository에 영속 데이터 저장소 (예: CoreData)가 주입됩니다. 먼저 리포지토리는 캐시된 데이터가 있는지 영구 저장소에서 확인하고, 캐시된 데이터를 도메인 모델로 매핑하여 데이터가 있으면 도메인에 반환합니다. 그런 다음 서비스에게 네트워크에서 데이터를 가져 오도록 요청합니다. 데이터를 가져온 후 리포지토리는 새 데이터로 영구 저장소를 업데이트하고, 도메인 모델로 매핑하여 도메인 계층에 데이터를 반환합니다.\n\nProductListService\n\nProductListService는 네트워크에서 제품 데이터를 가져 오는 fetchProductListFromNetwork 함수 내에서 사용되는 apiDataService에 액세스 권한이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nimport Foundation\n\nprotocol ProductListService {\n    func fetchProductListFromNetwork() async throws -> ProductPageDataListDTO\n}\n\nfinal class DefaultProductListService: ProductListService {\n\n    private let apiDataService: DataTransferService\n\n    init(apiDataService: DataTransferService) {\n        self.apiDataService = apiDataService\n    }\n\n    func fetchProductListFromNetwork() async throws -> ProductPageDataListDTO {\n        let productListNetworkRequest = DefaultNetworkRequest(path: APIEndpoint.products,method: .get)\n        return try await apiDataService.request(request: productListNetworkRequest)\n    }\n}\n```\n\n## 네트워크\n\n여기서 URLSession을 사용하여 실제 API 호출이 발생합니다. 먼저 EndPoint와 HTTPMethod를 제공하여 첫 번째 네트워크 요청을 생성합니다. 그런 다음 URL 요청이 생성됩니다. URL 요청을 사용하여 데이터를 가져옵니다. 에러가 발생하면 에러를 처리합니다. 또한 Decodable을 사용하여 데이터를 매핑합니다.\n\n```js\nimport Foundation\n\nprotocol DataTransferService {\n    func request<T: Decodable>(request: NetworkRequest) async throws -> T\n}\n\nfinal class DefaultDataTransferService: DataTransferService {\n\n    private let networkManager: NetworkManager\n    init(networkManager: NetworkManager) {\n        self.networkManager = networkManager\n    }\n\n    /// 네트워크 매니저에서 데이터를 가져와 decode 메서드를 사용하여 데이터를 디코딩하는 메서드입니다.\n    /// - Parameter request: 네트워크 요청\n    /// - Returns: Decodable 유형의 객체\n    func request<T>(request: NetworkRequest) async throws -> T where T : Decodable {\n        let data = try await networkManager.fetch(request: request)\n        return try decode(data: data)\n    }\n\n    /// JSONDecoder를 사용하여 데이터를 디코딩하는 메서드입니다.\n    /// - Parameter data: 데이터\n    /// - Returns: Decodable 유형의 객체\n    func decode<T>(data: Data) throws -> T where T : Decodable {\n        do {\n            let decodedData = try JSONDecoder().decode(T.self, from: data)\n            return decodedData\n        } catch {\n            throw NetworkError.unableToDecode\n        }\n    }\n}\n\nimport Foundation\n\nprotocol NetworkSessionManager {\n    func request(with config: NetworkConfigurable, request: NetworkRequest) async throws -> (Data?, URLResponse?)\n}\nprotocol NetworkManager {\n    func fetch(request: NetworkRequest) async throws -> Data\n}\n\nfinal class DefaultNetworkManager: NetworkManager {\n\n    private let config: NetworkConfigurable\n    private let sessionManager: NetworkSessionManager\n\n    init(config: NetworkConfigurable,\n        sessionManager: NetworkSessionManager = DefaultNetworkSessionManager()) {\n        self.config = config\n        self.sessionManager = sessionManager\n    }\n\n    /// 세션 매니저에서 데이터를 가져오고 데이터 및 응답을 유효성 검사하는 메서드입니다.\n    /// - Parameter request: 네트워크 요청\n    /// - Returns: 데이터\n    func fetch(request: NetworkRequest) async throws -> Data {\n        let (data, response) = try await sessionManager.request(with: config, request: request)\n        guard let response = response as? HTTPURLResponse else { throw NetworkError.noResponse }\n        if response.statusCode != 200 { throw NetworkError.failed }\n        guard let data = data else { throw NetworkError.noData }\n        return data\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n노트: 네트워크 관련된 더 많은 코드는 예시 프로젝트의 네트워킹 폴더에 있습니다.\n\n# 의존성 주입 (DI)\n\n의존성 주입은 객체가 자체적으로 만들지 않고 필요로 하는 다른 객체들을 받는 프로그래밍 기법입니다.\n\n우리의 예시 프로젝트에서는 AppDIContainer라는 클래스를 만들었는데, 이 클래스에는 apiDataTransferService가 포함되어 있습니다. 이 apiDataTransferService 객체는 Product 모듈을 생성하는 데 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```swift\nimport Foundation\n\nfinal class AppDIContainer {\n\n    lazy private var apiDataTransferService: DataTransferService = {\n        let config = ApiDataNetworkConfig(baseURL: AppConfiguration.baseURL)\n        let sessionManager = DefaultNetworkSessionManager(session: SharedURLSession.shared)\n        let networkManager = DefaultNetworkManager(config: config, sessionManager: sessionManager)\n        return DefaultDataTransferService(networkManager: networkManager)\n    }()\n\n    lazy var productListView: ProductListView = {\n        let productsModule = ProductsModule(apiDataTransferService: apiDataTransferService)\n        return productsModule.generateProductListView()\n    }()\n}\n```\n\n참고: 우리는 의존성 주입으로 apiDataTransferService를 Product Module에 전달하고 있습니다.\n\n# 결론\n\n클린 아키텍처는 매우 확장 가능하고 테스트 가능하며 유지보수 가능한 소프트웨어를 구축하는 데 도움을 줍니다. 각 계층이 특정 역할을 가지고 다른 부분과 격리되도록 응용 프로그램을 여러 계층으로 분리하여 관련성을 제공합니다. 이는 재사용성의 가능성을 높이고 비즈니스 요구 사항 및 경쟁 시장의 변화에 대응할 수 있도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n읽어 주셔서 감사합니다. 연락 기다리겠습니다!\n\n좋은 코딩하세요 :)\n\n![image](https://miro.medium.com/v2/resize:fit:200/1*bdto5WbUfHzG7AuZXY3aGA.gif)\n\n링크드인에서 연결해요.\n","ogImage":{"url":"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png"},"coverImage":"/assets/img/2024-06-19-TheCleanArchitecturewithMVVMintheiOSSwiftUIProject_0.png","tag":["Tech"],"readingTime":22},{"title":"Swift 테스팅 프레임워크 소개","description":"","date":"2024-06-19 13:59","slug":"2024-06-19-IntroductiontoSwiftTestingFramework","content":"\n## Swift 개발 혁신: WWDC 2024에서 공개된 테스팅 도구\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_0.png)\n\n2024년 WWDC에서 가장 흥미로운 도구 중 하나는 Swift Testing으로, Swift 코드의 테스트를 이전보다 강력하게 만듭니다. 이를 통해 개발자들은 최소한의 코드로 높은 품질의 제품을 자신 있게 제공할 수 있습니다.\n\nSwift Testing에는 동시성을 지원하는 기능, 병렬 테스트 실행, 그리고 테스트 매크로 도입과 같은 혁신적인 기능이 포함되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 목차\n\n- 전제 조건\n- Swift 테스트 대상 추가 방법\n- 구성 요소\n- 매개변수화된 테스트\n- XCTest와 Swift Test 비교\n- XCTest에서의 이주 팁\n- 결론\n\n# 전제 조건\n\n# Swift 테스트 대상 추가 방법?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nSwift 테스팅을 시작하려면 새 프로젝트를 생성할 때 XCTest UI 테스트와 함께 Swift Testing을 선택해야 합니다.\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_1.png)\n\n이제 해당 테스트 대상에 테스트 케이스를 작성할 수 있습니다.\n\n# 구성 요소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트가 가독성 있게 작성되어 있는지 확인하는 것이 중요합니다, 특히 코드베이스가 복잡해지는 경우 더욱 그렇습니다. Swift Testing은 이를 돕기 위해 몇 가지 기능을 추가했으므로 표현력 있는 테스트를 작성하는 것이 더 쉬울 것입니다.\n\n총 4개의 구성 요소가 있습니다. 각각에 대한 자세한 정보를 아래에서 찾을 수 있습니다.\n\n1. 테스트 함수\n\n- 전역 함수 또는 클래스 메소드일 수 있습니다.\n- async 또는 throws로 표시할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_2.png)\n\n2. 기대값\n\n- #expect 매크로:\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n만약 실패가 발생하면, 실패에 대한 자세한 정보가 표시되어 어디서 잘못된 것인지 이해할 수 있습니다.\n\n![image](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_4.png)\n\n- `#expect(.throws: (any Error).self)` 매크로:\n\n만약 이 블록에서 어떤 오류도 throw하지 않는다면 실패합니다. 그렇지 않으면 성공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래의 테스트 케이스를 확인해보세요:\n\n![test image](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_5.png)\n\n위의 예에서, 오류를 던지는 함수는 테스트를 성공적으로 통과했지만, 오류를 던지지 않는 함수는 테스트에 통과하지 못했습니다.\n\n- #require 매크로:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n해당 테이블 태그를 마크다운 형식으로 변경해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_7.png\" />\n\n4. 테스트 스위트\n\n설정 및 정리 로직은 각각 init()와 deinit()을 사용하여 구현됩니다. init()은 테스트 실행 전에 호출되고, deinit()은 테스트 실행 후에 호출됩니다.\n\n각 테스트 함수는 독립적으로 자체 인스턴스에서 실행되므로 실수로 데이터를 공유하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 특정 테스트 이름을 가진 테스트 네비게이터에 두 개의 스위트를 볼 수 있습니다. 부 스위트는 부모 스위트 아래에 계층적으로 표시됩니다.\n\n![Test Navigator](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_8.png)\n\n# 매개변수화 테스트\n\n매개변수화 테스트는 중복 코드나 과도한 개별 테스트 케이스 생성 없이 철저한 테스트 커버리지를 보장하는 데 도움이 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n매개변수화된 테스트를 실습해 봅시다.\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_9.png)\n\n위는 Swift 테스트에서 매개변수화된 테스트의 잘못된 구문을 나타냅니다. @Test 어노테이션에서 인수를 사용해야 합니다.\n\n위 예시에서 세 가지 인수가 제공되었습니다. 두 가지는 올바르고 하나는 잘못되었지만, 전체 테스트 케이스는 실패로 표시될 것입니다. 그러나 테스트 탐색기에서 실패의 원인이 된 인수를 볼 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_10.png\" />\n\n# XCTest와 Swift Test 비교\n\nSwift Tests와 XCTest의 구성 요소 비교:\n\n1. 테스트 함수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_11.png)\n\n2. 기대\n\n두 프레임워크의 기대는 매우 다릅니다.\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_12.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트가 실패하면 테스트가 중지되는 방식도 두 프레임워크에서 차이가 있습니다.\n\n3. 테스트 스위트\n\n![이미지](/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_13.png)\n\n## XCTest에서의 이주를 위한 팁\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- XCTest와 Swift Test는 단일 타겟으로 작성할 수 있습니다. 새로운 타겟을 만드는 것은 필수적이지 않습니다.\n- 여러 메소드가 유사한 구조를 가질 때는 하나의 테스트로 결합하고 해당 함수를 매개변수화할 수 있습니다.\n- 개별 XCTest 클래스를 하나의 전역 @Test 함수로 결합합니다.\n- Swift 테스트에서는 함수 이름에 테스트 접두사를 더 이상 사용할 필요가 없습니다. 함수에서 제거할 수 있습니다.\n- Swift 테스팅에서는 XCTAssertion을 사용하지 않고, XCTest에 있는 #expect나 #require와 같은 테스팅 매크로를 피해야 합니다.\n\n# 결론\n\nSwift Testing은 매크로와 함께 표현력 높은 API를 제공하여 코드를 최소로 사용하여 테스트 동작을 선언할 수 있습니다. #expect API는 제공된 표현식을 유효성 검사하는 데 Swift 표현식과 연산자를 사용합니다. 매개변수화된 테스트는 유사한 구조의 코드를 수용하여 중복 코드를 줄이는 데 도움이 됩니다. 또한 Swift Testing은 병렬 테스트를 지원하여 전체 테스트 효율성과 생산성을 향상시킵니다. 그러나 직렬화된 테스트를 활성화하려면 직렬화된 특성을 사용해야 합니다.\n","ogImage":{"url":"/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_0.png"},"coverImage":"/assets/img/2024-06-19-IntroductiontoSwiftTestingFramework_0.png","tag":["Tech"],"readingTime":8},{"title":"Android 개발에서 향상된 디버깅 품질","description":"","date":"2024-06-19 13:56","slug":"2024-06-19-BetterDebuggingQualityinAndroidDevelopment","content":"\n![Better Debugging Quality in Android Development](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_0.png)\n\n개발 중에는 때때로, 이 검사 또는 등록 양식을 한 번 더 다시 쓰지 않으면 안 되는 상황이 발생합니다. 와락그러면서도 작은 버그를 찾기 위해 그 순응하지 않는 작은 고집스러운 버그를 발견하게 됩니다. 바로 이 점 때문에 우리에게 현저한 피해를 줄 수 있다는 것을 잊지 마세요. 그러므로 더 이상 그만 하기로 해야 합니다.\n\n이 기사에서는 개발자로서 우리에게 매우 보편적인 보스 같은 여정을 겪어볼 것입니다. 지금 우리는 왼쪽, 오른쪽, 여기저기에 명령을 내리는 것을 좋아하는 우리 개발자들에게 익숙한 이야기죠 😀.\n\n오늘 하루, 우리는 테스트 디바이스나 에뮬레이터를 제어하는 것뿐만 아니라 그 양식을 여러 번 작성하는 본능적 욕구도 제어할 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신은 개발자로서. 위의 텍스트를 친근한 어조로 한국어로 번역해주세요.\n\n\"어떤가요??\"라고 물을 수 있어요. 우리는 adbcommands를 사용할 거에요. ADB(Android Debug Bridge)라는 것은 안드로이드 장치나 에뮬레이터를 제어하기 위한 명령줄 도구에요. \"안드로이드 디버그...\" \"커마...\"만 듣고 어딘가로 가지 마세요. 약간 지루해 보일 수도 있지만, 제가 가능한 한 재미있게 만들어 드릴게요.\n\n사실 마지막에는 이 명령을 한 번, 두 번, 세 번 정도만 사용할 거에요... 우리가 선택한 바로 가기로 이 명령들을 사용할 필요가 없게 할 거에요. (또는 경우에 따라 윈도우를 사용한다면 일명 하나의 명령만 남겨두게 할 거에요. 🙂).\n\n# 사용자 정의 가능한 입력 플로우 스크립트 생성\n\n우선, 장치/에뮬레이터와 상호작용할 명령어들이 여기 있어요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# 호스트 안드로이드 장치의 터미널에서 명령을 열거나 실행합니다.\nadb shell\n\n# 현재 활성화된 TextField에 지정된 문자열을 입력합니다.\nadb shell input text \"Hello World!\"\n\n# 장치 화면의 지정된 좌표를 탭합니다.\nadb shell input tap 700 1500\n```\n\n지금 당신은 아마 \"정적 좌표를 사용하여 텍스트 필드를 찾을까?\"라고 생각할 수 있습니다. 전혀, 그렇지 않습니다. 하지만 당신이 자신을 어렵게 만들고 싶다면 사용할 수 있습니다 :D. 화면에 기대되는 UI 요소의 좌표를 찾을 때, 우리는 uiautomator의 덤프를 사용할 것입니다. 이를 다운로드하려면 Python3가 필요합니다.\n\n```js\nadb exec-out uiautomator dump /dev/tty\n```\n\n이 명령어가 마법이 시작되는 곳입니다. UI Automator는 XML 형식의 현재 화면 보기 계층에 대한 덤프를 생성합니다. 이 명령을 입력하면 이 파일이 터미널에 표시될 것입니다. 그리고 우리가 관심 있는 부분은 실제로 이 파일의 각 요소의 [bounds] 태그이며, 다음은 그 노드 중 하나의 서식이 적용된 버전입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_1.png\" />\n\n그렇게 말하니까 아마 이해가 가실 거에요. 우리는 각 요소의 경계를 가져오기 위한 파서를 만들어야 합니다. 물론 원하는 때마다 관련 요소에 접근 하는 방법은 그들의 이름을 호출하는 것입니다 :). 아래 스크립트에서 우리는 효과적으로 해당 목표를 달성하기 위해 터미널 명령을 사용합니다.\n\n```js\n# UI 요소를 탭하는 함수 (요소가 존재하는 경우)\nfunction tapIfExists() {\n    # UI 요소의 좌표 가져오기\n    coords=$(getCoords \"${1}\")\n\n    # 좌표가 찾아졌는지 확인\n    if [[ \"$coords\" != \"-\" ]]; then\n        # adb를 사용하여 좌표 탭하기\n        adb shell input tap \"$coords\"\n    fi\n}\n\n# 텍스트를 기반으로 UI 요소의 좌표를 가져오는 함수\nfunction getCoords() {\n    # UI 계층 구조를 덤프하고 변수에 저장\n    fastdump=$(/usr/bin/python3 -c \"import uiautomator2 as u2;d=u2.connect(); out=d.dump_hierarchy(); print(out)\")\n\n    # 지정된 텍스트가 있는 요소가 있는지 확인\n    present=$(echo \"$fastdump\" | grep \"text=\\\"${1}\\\"\")\n\n    # 요소를 찾은 경우\n    if [[ $? -eq 0 ]]; then\n        # 덤프에서 좌표 추출\n        arr=($(echo \"$fastdump\" | sed 's/></>\\n</g' | grep \"text=\\\"${1}\\\"\" | grep -o \"\\[.*\\]\" | sed 's/\\]\\[/,/g' | sed 's/\\]//g;s/\\[//g;s/,/\\n/g'))\n\n        # 중앙 x좌표 계산\n        x=$(echo \"(${arr[0]}+${arr[2]})/2\" | bc)\n\n        # 중앙 y좌표 계산\n        y=$(echo \"(${arr[1]}+${arr[3]})/2\" | bc)\n\n        # 좌표 출력\n        echo \"$x $y\"\n    else\n        # 요소를 찾지 못한 경우 \"-\" 출력\n        echo \"-\"\n    fi\n}\n```\n\n이렇게 하면 모든 것이 훨씬 더 쉬워집니다. 예를 들어 로그인 플로우를 만들었습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```javascript\n# ...\n# 파일 끝에 사용자 정의 로직을 추가하는 중...\n\ntapIfExists \"E-mail\"\nadb shell input text \"sevbanbuyer@gmail.com\"\ntapIfExists \"Password\"\nadb shell input text \"asdasdfasd\"\ntapIfExists \"SIGN IN\"\n```\n\n이 스크립트로 우리는 등록 과정을 단 한 개의 명령으로 줄였어요: ./`your-script-file-name` 하지만 아직 끝나지 않았습니다. 만약 Mac을 사용하고 계시다면 입력 과정에 대한 단축키를 만들 수 있어요. 이를 위해 먼저 Mac의 Automator 앱으로 Applescript 워크플로우를 만들어야 해요.\n\n<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_2.png\" />\n\n<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_3.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n# Automator의 applescript에 다음을 넣으세요\non run {input, parameters}\n do shell script \"<path-to-your-script>\"\nend run\n```\n\n```js\n#!/bin/bash\n\nADB_PATH=\"<adb의 전체 경로>\" # 주의 !\n\nfunction tapIfExists(){\n    coords=$(getCoords \"${1}\")\n    if [[ \"$coords\" != \"-\" ]]; then\n        $ADB_PATH shell input tap \"$coords\" # 주의 !\n    fi\n}\n\nfunction getCoords(){\n    fastdump=$(/usr/bin/python3 -c \"import uiautomator2 as u2;d=u2.connect(); out=d.dump_hierarchy(); print(out)\")\n    present=$(echo \"$fastdump\" | grep \"text\\=\\\"${1}\\\"\")\n    if [[ $? -eq 0 ]]; then\n        arr=($(echo \"$fastdump\" | sed 's/></>\\n</g' | grep \"text\\=\\\"${1}\\\"\" | grep -o \"\\[.*\\]\" | sed 's/\\]\\[/,/g' | sed 's/\\]//g;s/\\[//g;s/,/\\n/g'))\n        x=$(echo \"(${arr[0]}+${arr[2]})/2\" | bc)\n        y=$(echo \"(${arr[1]}+${arr[3]})/2\" | bc)\n        echo \"$x $y\"\n    else\n        echo \"-\"\n    fi\n}\n\ntapIfExists \"이메일\"\n$ADB_PATH shell input text \"sevbanbuyer@gmail.com\" # 주의 !\ntapIfExists \"암호\"\n$ADB_PATH input text \"asdasdfasd\"  # 주의 !\ntapIfExists \"로그인\"\n```\n\nApplescript에 완전한 경로가 포함된 스크립트를 제공하면, Settings에서 `Keyboard` Keyboard Shortcuts `Services` General로 이동하고 그 섹션에 스크립트가 표시됩니다. 이제 원하는 단축키를 할당할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_4.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 출력물이 있어요:\n\n![Dumpsys](https://miro.medium.com/v2/resize:fit:784/1*OA1yF70mPJNjQ78lzlFoDg.gif)\n\n# Dumpsys\n\ndumpsys 명령어는 장치에서 실행 중인 모든 시스템 서비스에 대한 진단 정보를 제공합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 표를 다음과 같이 변경해 주세요:\n\n| 주제               | 설명                                      |\n| ------------------ | ----------------------------------------- |\n| 활동 및 프래그먼트 | - 활동 및 프래그먼트에 대한 정보          |\n| 배터리             | - 배터리 상태 및 관리에 관한 정보         |\n| 알람               | - 알람 설정 및 관리에 관한 정보           |\n| 패키지 정보        | - 앱 패키지 정보에 대한 정보              |\n| 작업 스케줄러      | - 작업 스케줄러 사용법과 정보에 대한 정보 |\n\n이 서비스들과 상호작용하면서 코드를 통해 어떤 일이 벌어지는지를 알아내므로 버그에 대한 효율적인 추측이 가능합니다.\n\n\"AlarmManager를 사용하여 알람을 설정했는데, 정말 설정되었을까요?\"\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\"조각을 확장했지만 아무것도 보이지 않아요. 제가 제대로 한 걸까요?\"\n\n- 리뷰 중인 앱을 분석하고 실제로 무엇을 보고 있는지 확인하기 위해 dumpsysis를 사용하는 것이 좋습니다.\n\n다음은 명령어입니다:\n\n```js\nadb shell dumpsys <service>\n\nadb shell dumpsys battery\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_5.png)\n\n덤프시스에서 grep을 사용하여 검색할 수 있습니다. 예를 들어:\n\n```js\nadb shell dumpsys | grep \"ACTIVITY\"\n\nadb shell dumpsys | grep \"BottomNavigationItemView\"\n```\n\n# 로컬 파일의 내용 보기/변경\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n로컬 스토리지를 다룰 때 종종 어려움을 겪곤 합니다.\n\n- 스토리지 데이터를 쿼리하기 위해 중단점을 설정하거나\n- printlines 또는 로그를 추가하는 것은 수정 및 빌드가 필요하여 시간이 많이 소요됩니다.\n\n우리는 이 디버깅 프로세스를 최적화할 수 있는 기회가 있습니다.\n\n- 앱의 내부 데이터는 data/path에 저장됩니다.\n- 이론적으로 우리는 cd, ls, echo, nano 등의 일반 터미널 명령어를 사용하여 기기에서 이 데이터를 볼 수 있지만 실제로는 이와 같은 문제가 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_6.png)\n\n안드로이드는 앱의 리소스에 쉽게 액세스할 수 없도록 허용하지 않는다는 점이 좋은 것 같아요.\n\n그런데 앱의 내부 데이터의 정확한 경로는 다음과 같아요: /data/user/0/`your.package.name` 그래도 저 정확한 경로를 알아도 들어가지 못하는 걸 보면 다른 방법이 필요할 걸요.\n\n이를 위해 안드로이드의 각 앱이 사실 별칭으로 패키지 이름을 가진 사용자라는 사실을 활용할 거에요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Screenshot 1](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_7.png)\n\n우리는 run-as 명령어를 사용하여 앱이 셀프인 것처럼 속이는 데 사용했습니다. 이제 우리는 앱의 내부 저장소를 lsin 할 수 있고, sharedPref, 데이터베이스 또는 파일과 같은 데이터를 볼 수 있습니다. 이 데이터들은 코드베이스 내에서 파일 API를 사용하여 생성된 것입니다.\n\n![Screenshot 2](/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_8.png)\n\n그리고 BUM! 여기가 제 앱의 공유 프리퍼런스 파일이고, onboarding_key와 해당 값을 볼 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n\\<img src=\"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_9.png\" />\n\n이제 이 선호 값을 어떻게 편집할 수 있어서 앱을 다시 빌드하지 않고 변경 사항을 확실히 적용하는 데 시간을 낭비하지 않을 수 있는지 묻게 될 것입니다. 일반적으로 터미널에서 사용하는 텍스트 편집기를 adb 쉘에서 사용할 수는 없지만 여기에 대한 해결책이 있습니다: sedcommand. -iflag로 파일을 직접 덮어쓸 수 있으므로 여기 제 앱의 온보딩 키에 대한 적용입니다:\n\n```js\nemu64a:/data/user/0/com.sevban.tradejournal/shared_prefs $ grep \"onboarding_key\" presentation.MainActivity.xml\n    <boolean name=\"onboarding_key\" value=\"true\" />\nemu64a:/data/user/0/com.sevban.tradejournal/shared_prefs $\n\ncat presentation.MainActivity.xml |\ngrep \"onboarding_key\" |\nsed -i \"s/true/false/g\" presentation.MainActivity.xml\n\nemu64a:/data/user/0/com.sevban.tradejournal/shared_prefs $ grep \"onboarding_key\" presentation.MainActivity.xml\n    <boolean name=\"onboarding_key\" value=\"false\" />\n```\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n안드로이드 개발에서 디버깅 프로세스를 개선하는 과정은 어렵지 않을 수 있어요. ADB 및 uiautomator와 같은 도구를 활용하여 양식 작성과 같은 반복적인 작업을 자동화하고 앱의 동작에 대한 깊은 통찰력을 얻을 수 있어요.\n\n사용자 정의 입력 흐름 스크립트를 생성하면 UI 상호작용을 자동화하여 디버깅을 더 효율적이고 단조로운 일이 줄어들어요. dumpsys를 사용하고 run-as 및 sed 명령어를 사용하여 로컬 파일에 액세스하면 문제를 진단하고 효과적으로 해결할 수 있어요.\n\n이러한 기술을 활용하면 디버깅 프로세스를 변화시킬 수 있어요. 가능한 경우 자동화 도구를 적극적으로 활용하고 더욱 원활하고 생산적인 개발 경험을 누려보세요.\n\n참고 문헌:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://www.youtube.com/watch?v=DcU1czPxQ10&t=1326s\n","ogImage":{"url":"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_0.png"},"coverImage":"/assets/img/2024-06-19-BetterDebuggingQualityinAndroidDevelopment_0.png","tag":["Tech"],"readingTime":13},{"title":"안녕하세요 오늘은 안드로이드용 5가지 최고의 무료 음악 플레이어 앱에 대해 이야기해 보려고 해요 함께 즐겁게 앱을 살펴보시죠","description":"","date":"2024-06-19 13:54","slug":"2024-06-19-5BestFreeMusicPlayerAppsforAndroid","content":"\n이 기사는 완전히 무료로 사용할 수 있고 광고가 없으며 유용한 기능이 제공되는 최고의 5가지 오프라인 음악 플레이어 앱을 소개합니다.\n\n![이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png)\n\n본 기사에서는 Google Play Store에서 사용할 수 있는 안드로이드 기기용 최고의 5가지 무료 오프라인 음악 플레이어 앱을 살펴볼 예정입니다. 각 음악 플레이어를 비교하려면 우리는 최고의 음악 플레이어를 찾는 데 도움이 되는 몇 가지 주요 요소를 고려해야 합니다. 이러한 요소는 다음과 같습니다:\n\n- 좋은 디자인\n- 유용한 기능\n- 기기 호환성\n- 보안\n- 추가 기능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다가오는 섹션에서는 각 음악 플레이어를 이 주요 요소로 평가할 것입니다.\n\n## #1: Groovy — 음악 플레이어\n\nPlay Store 링크: [여기를 클릭하세요](https://play.google.com/store/apps/details?id=com.bitmavrick.groovy)\n\nGroovy는 현재 최고의 음악 플레이어 앱 중 하나입니다. 단순하고 독특한 UI 디자인 시스템을 갖추고 있어 누구나 쉽게 이해하고 작동할 수 있으며 프로 사용자를 위한 많은 사용자 정의 옵션을 제공합니다. 이 앱은 Material-You를 따르는 디자인으로 동적 테마를 지원하고 아이콘 테마를 지원합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_1.png\" />\n\n유용한 기능들을 요청하면, 이 앱은 음악, 앨범, 아티스트 등을 쉽게 찾을 수 있는 트랙 조직 시스템으로 제공됩니다. 강력한 음악 검색 시스템뿐만 아니라 셔플 모드, 음악 재생 리스트 조직 시스템, 음악 정렬, 기기에서 포함하고 싶지 않은 폴더 차단 등 다양한 유용한 기능들도 제공하고 있습니다.\n\n이 앱은 거의 모든 종류의 안드로이드 기기와 호환됩니다. 예를 들어, 스마트폰, 태블릿, 폴더블 기기, 크롬북, 안드로이드 TV 등을 지원합니다. 플레이어는 세로 및 가로 디스플레이 모드를 모두 지원합니다.\n\n보안에 대해 생각해보신다면, 이 앱은 완전히 오픈 소스이며 보안에 대해 매우 투명하게 공개되어 있습니다. 사용자로부터 개인 정보를 수집하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마지막으로 추가 기능을 이야기하자면 슬립 타이머, 이퀄라이저, 'Amoled 테마'라고 불리는 한 가지 추가 어두운 테마, 음악 슬라이더 사용자 정의 등 많은 기능이 있습니다.\n\n## #2: 바닐라 음악 플레이어\n\nPlay 스토어 링크: [https://play.google.com/store/search?q=vanilla%20music%20player&c=apps&hl=en&gl=US](https://play.google.com/store/search?q=vanilla%20music%20player&c=apps&hl=en&gl=US)\n\n바닐라 음악 플레이어는 인상적인 아름다운 디자인 미학을 가지고 있습니다. 그러나 지금은 초기 릴리스 상태입니다. 그래서 스크롤할 때 UI가 조금 느려 보일 수 있습니다. 그 외에는 매우 멋진 음악 플레이어 앱입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_2.png)\n\n이 플레이어의 주요 기능은 매우 멋진 UI 애니메이션이 있고 사용자 지정 재생 목록을 만들거나 음악 파일을 삭제하거나 숨길 수 있으며 음악 파일을 다양한 방식으로 정렬할 수 있다는 것입니다. 이 플레이어는 가사 지원도 하고 있습니다. 음악 파일과 함께 가사가 있는 경우 플레이어 내에서 가사를 볼 수 있습니다.\n\n호환성 부서에서는 아직 알 수 없습니다. 초기 릴리스로 인해 모든 종류의 기기를 지원해야 합니다.\n\nGroovy와는 달리이 앱은 오픈 소스가 아닙니다. 그러나 앱은 사용자의 개인 정보를 수집하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n추가 기능에 관해 이 응용 프로그램은 사용자가 원하는 UI 색상을 사용자 정의할 수 있는 색상 팔레트를 지원합니다. 정말 멋지죠!\n\n# #3: Poweramp Music Player (체험판)\n\nPlay Store 링크: https://play.google.com/store/apps/details?id=com.maxmpz.audioplayer\n\n절대적인 제어와 사용자 정의를 원한다면, 이 음악 플레이어가 바로 당신을 위한 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_3.png)\n\nPoweramp Music Player은 음악 플레이어에 모든 것이 필요한 사람들을 위한 최고의 선택입니다. 이 앱의 주요 포커스 포인트는 견고한 이퀄라이저입니다. 10 밴드 음악 이퀄라이저 지원과 수동 베이스, 트레블 컨트롤러도 제공합니다.\n\n이 앱의 위치에 대한 주요 이유는 UI/UX입니다. 앱의 디자인은 다소 구식이며 사용하기 복잡합니다. 주요 제공 요소는 음악 사용자 정의입니다.\n\n보안 면에서는 오픈 소스 애플리케이션이 아닙니다. 그러나 사용자의 개인 정보를 수집하지는 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# #4: 간단한 음악 플레이어\n\nPlay Store 링크: [여기를 클릭하여 Play Store에서 확인해보세요](https://play.google.com/store/apps/details?id=com.github.anrimian.musicplayer)\n\n이름에서 알 수 있듯이, 이 음악 플레이어는 정말로 간단합니다. 설치하기만 하고 사용하면 됩니다.\n\n![이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_4.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 음악 플레이어는 추가 기능이 없지만, 단순함을 원하는 사용자에게는 정말 좋습니다. 전문가로서 이 플레이어에 누락된 몇 가지 중요한 기능을 느껴요. 예를 들어, 오디오 파일을 필터링할 수 있는 시스템이 없고, My Call 및 음성 녹음 파일이 음악 파일과 혼합되어 나타나서 저에게는 큰 문제입니다. 전체적인 디자인은 꽤 간단하며 특별한 점도 없지만 불평할 만한 점도 없어요. 일이 잘 되어요.\n\n보안 관련 부분에서 이 앱은 오픈 소스이며 보안에 대해 투명해요. 또한이 앱은 사용자의 개인 정보를 수집하지 않아요.\n\n# #5: Musicmax — 음악 플레이어\n\nPlay Store 링크: https://play.google.com/store/apps/details?id=com.maximillianleonov.musicmax&pcampaignid=web_share\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMusicmax은 저희가 가장 추천하지 않는 음악 플레이어 앱입니다. 이 플레이어는 전반적으로 꽤 좋은 음악 재생 경험을 제공합니다.\n\n![음악 플레이어 이미지](/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_5.png)\n\n이 음악 플레이어는 꽤 양호한 UI 경험을 제공하지만, 가로 모드로 변경할 때 상황이 그리 좋지 않습니다. UI 부서에서 더 많은 작업이 필요합니다. 이 플레이어는 무료 앱으로 가지고 있기 좋은 즐겨찾기 섹션이 있습니다. 또한 다크 모드와 기본적인 기능을 지원합니다.\n\n이 앱은 스마트폰만을 지원합니다. 보안을 위해 오픈 소스로 투명하게 제공됩니다. 이 앱은 사용자의 개인 정보를 수집하지 않습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기 있습니다. 이것이 제 의견으로는 최고의 5가지 음악 플레이어 앱입니다. 남은 하루도 좋은 하루 되세요!\n","ogImage":{"url":"/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-5BestFreeMusicPlayerAppsforAndroid_0.png","tag":["Tech"],"readingTime":7},{"title":"접근성 강화 포용적 안드로이드 앱으로의 여정","description":"","date":"2024-06-19 13:51","slug":"2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps","content":"\n![이미지](/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png)\n\n혁신을 추구하는 것은 종종 포용성 요구를 무시하는 경향이 있습니다. 우리의 삶이 디지털 인터페이스와 더불어 점점 더 얽히게 되면, 능력에 관계없이 모든 사람이 디지털 세계에 완전히 접근할 수 있도록 하는 것이 더 중요해지고 있습니다. 특히, 수십억 명의 소비자를 연결하는 전 세계 플랫폼인 안드로이드 생태계에 대해서는 특히 그렇습니다. 이 글에서는 안드로이드의 접근성에 대해 살펴보고, 보다 포용적이고 공정한 기술 환경을 구축하는 데 어떻게 도움이 될 수 있는지 알아보겠습니다.\n\n유럽 접근성법(EAA)은 디지털 접근성의 긴급성을 증대시키는 중요한 요소입니다. 장애를 가진 사람들에게 장애를 제거하도록 제정된 EAA는 유럽 연합 내에서 운영되는 많은 기업들이 2025년까지 자사의 디지털 서비스와 제품을 접근 가능하게 만들도록 요구합니다. 이 규정은 접근성이 단순한 도덕적 필요성뿐만 아니라 법적 요구사항이라는 것을 강조하는 패러다임 변화를 대표합니다. 마감일이 다가오면 기업들은 다양한 고객 요구를 충족시키는 중요성을 인식하면서 자사의 디지털 서비스를 재평가해야 합니다.\n\n이 글은 개발자들이 자신들의 안드로이드 애플리케이션의 접근성을 향상시킬 수 있는 다양한 방법에 대해 자세히 안내합니다. 사용자 친화적인 기능을 포함하고 포용적 설계 원칙을 준수하는 등 어플리케이션을 더 접근 가능하게 만드는 실용적 기술들을 살펴봅니다. 또한, 우리는 테스트의 중요한 요소를 살펴보며 제공된 솔루션이 참으로 포괄적인지 보장하는 방법과 도구에 대해 알아봅니다. 안드로이드 접근성의 복잡한 세계를 탐험하는 과정에서, 개발자들에게 국경을 초월하고 보편적 설계의 정신을 수용하는 디지털 경험을 구축하도록 영감을 줄 수 있기를 희망합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 포용\n\n디지털 접근성 분야에서의 포용은 기술적 요구사항 이상의 의미를 갖습니다. 이는 기술이 배제의 이유가 아닌 평등을 위한 수단으로 작용하기 위한 심도 있는 약속입니다. 접근성 있는 디자인은 사람들의 삶에 광범위한 영향을 미치며, 긍정적이든 부정적이든 모든 능력을 갖춘 사람들에게 영향을 줍니다.\n\n긍정적인 면에서 접근성 있는 기술은 장애로 인해 제약을 받는 사람들을 자유롭게 해 줄 수 있는 변형력을 갖습니다. 시각 장애인이 액세스 가능한 안드로이드 앱을 사용할 때 화면 판독기를 사용한다면 어떨까요. 올바른 접근성 기능이 제대로 설계되어 있다면, 이 사용자는 프로그램을 독립적으로 탐색하고 정보에 접근하며 이전에는 이용할 수 없었던 활동에 참여할 수 있습니다. 이러한 증가된 자유는 그들의 일상을 개선하는 것뿐만 아니라 자아감과 포용감을 육성하는 데에도 도움이 됩니다.\n\n반면에 디지털 접근성 부족은 편견과 문화적 장애를 악화시킬 수 있습니다. 화면 판독기와 호환되지 않거나 그림에 대한 대체 텍스트를 제공하지 않는 웹사이트나 앱은 시각 장애를 가진 사람들을 효과적으로 배제시킬 수 있습니다. 이러한 배제는 단순히 불편을 초래하는 것 이상으로 교육, 취업 및 사회 참여에 대한 장애물을 만들어냅니다. 예를 들어 접근성 기능이 충분하지 않은 취업 지원 포털은 장애를 가진 유능한 개인이 채용 공고에 지원하는 것을 방해할 수 있어 전문적 발전 가능성을 제한할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 액세스할 수없는 기술은 디지털 격차를 악화시킬 수 있습니다. 디지털 풍경을 쉽게 탐색할 수 있는 사람과 앞을 굳이 막는 장애물을 마주치는 사람 간의 격차를 만들어 낼 수 있습니다. 학습 장애를 가진 학생이 교육 자료에 엑세스하기 어렵다면 애플리케이션이 접근성 기능을 제공하지 않는 경우 어떻게 될까요? 이는 그들의 학업 진행을 방해할 뿐만 아니라 향후 취업 및 사회적 상호작용으로 이어지는 배제의 피라미드를 유발할 수 있습니다.\n\n간략히 말하자면, 디지털 접근성의 포용의 중요성은 모든 능력을 가진 개인들의 삶의 질을 형성하는 능력에 있습니다. 규제 요건을 충족시키는 것뿐만 아니라 기술이 장벽을 만들지 않고 사람들을 연결하는 다리 역할을 하는 세상을 육성하는 데 의미가 있습니다. 안드로이드 개발에서 포용적 디자인 원칙을 수용함으로써 사용자 경험을 향상시킬 뿐 아니라 보다 공정하고 조화로운 디지털 사회에 기여할 수 있습니다.\n\n# 유럽 접근성 법안 (EAA)\n\n유럽 접근성 법안(EAA)은 유럽 연합 내에서 보다 포용적이고 접근성 있는 디지털 풍경을 창출하기 위한 전환이라고 말할 수 있습니다. 장애를 가진 사람들이 직면한 장애물을 철폐하기 위해 제정된 EAA는 디지털 서비스 및 제품 스펙트럼에 걸쳐 접근성 표준을 강제하는 포괄적인 프레임워크를 제시합니다. 그 중요성은 법률적 틀 내뿐만 아니라 수십만 명의 디지털 배제를 오래 겪어온 개인들의 삶에 미치는 영향에서도 드러납니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n핵심적으로 EAA는 기술이 방해요소가 아닌 오히려 촉진요소로 작용하는 사회 조성을 위한 의지를 반영합니다. 그 중요 조항 중 하나는 유럽 연합 내에서 운영되는 많은 기업들이 2025년까지 자사의 디지털 서비스와 제품들이 접근성을 보장해야 한다는 것을 명시하고 있습니다. 이는 웹사이트부터 모바일 애플리케이션, ATM, 그리고 e북까지 다양한 디지털 인터페이스를 포함하고 있습니다. 이 기한을 부과함으로써, EAA는 기업들이 디지털 제품을 제공하는 데 있어 접근성을 우선시하는 것을 강요하여 기술 산업에서 패러다임 변화를 촉발시킵니다.\n\nEAA의 중요성은 장애를 가진 개인들의 삶에 미칠 전환적인 영향을 고려할 때 특히 명확해집니다. 기술이 일상적인 활동에서 점점 더 중요한 역할을 하게 되는 가운데, 디지털 콘텐츠와 서비스에 접근할 수 있는 능력은 사회 전체적인 참여와 동일시되어집니다. EAA는 접근성을 강제함으로써, 장애를 가진 사람들을 위한 교육, 일자리, 그리고 사회 참여의 문을 열어주어 모두가 기여하고 번영할 수 있는 포용적 환경을 조성합니다.\n\n더불어, EAA는 유럽 연합을 넘어 국제적으로 디지털 접근성에 대한 시각을 영향을 미치는 선례를 제공합니다. 기업들이 EAA의 요구 사항에 대응하며 직면하는 도전에 대처할 때, 그들은 법적 의무뿐만 아니라 모든 사용자의 요구를 충족시키기 위한 기술을 만들어내는 도덕적 필요성을 받아들이고 있습니다. 이러한 노력을 통해 EAA는 모든 사람이 접근 가능한 디지털 시대의 혜택을 얻을 수 있도록 하는 데 있어 길잡이 역할을 하며, 디지털 포용이 규정적인 체크박스뿐만 아니라 기술 혁신의 필수 요소로 자리 잡는 미래의 길을 밝혀주고 있습니다.\n\n요약하자면, 유럽 접근성법은 디지털 접근성이 법으로 강제되는 것뿐만 아니라 사회적 필요성으로 받아들여지는 새로운 시대를 예고합니다. 비즈니스들이 포용성을 우선시하도록 강요함으로써, EAA는 장벽을 허물고 디지털 시대의 혜택이 모든 이에게 접근 가능하도록 보장하고, 보다 공정하고 조화로운 디지털 미래를 위한 기초를 마련하고 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 접근성 높은 안드로이드 앱 만들기\n\n접근성 높은 안드로이드 앱을 만드는 것은 다양한 디자인 고려 사항과 기능을 아우르는 복합적인 접근 방식이 필요합니다. 이러한 조치들은 다양한 능력을 가진 사용자들이 응용 프로그램을 원활하게 탐색하고 상호 작용할 수 있도록 보장하는 데 중요합니다. 안드로이드 앱 개발에서 접근성을 향상시키는 여러 가지 핵심 전략을 소개합니다:\n\n## 텍스트 가시성과 대비\n\n명확하고 가독성 있는 글꼴을 사용하여 가독성을 보장하세요. 글꼴 크기와 대비 비율을 조정하여 시각 장애가 있는 사용자나 작은 텍스트를 읽는 데 어려움이 있는 사용자들의 가시성을 향상시킵니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린:\n\n```kotlin\n// 가독성을 높이기 위해 텍스트 크기와 색상 설정\ntextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 18f)\ntextView.setTextColor(ContextCompat.getColor(context, R.color.textColor))\n```\n\nXML:\n\n```xml\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"18sp\"\n    android:textColor=\"@color/textColor\"/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 컴포즈:\n\n```kotlin\nText(\n    text = \"Hello, World!\",\n    fontSize = 18.sp,\n    color = Color.Black // 적절한 색상 사용\n)\n```\n\n# 크고 간단한 컨트롤\n\n모터 장애가 있는 사용자나 터치 인터페이스를 사용하는 사용자들을 위해 클릭 실수의 위험을 줄이기 위해 더 큰 터치 대상과 버튼을 구현하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin:\n\n```kotlin\n// 버튼 크기 키우기\nbutton.layoutParams.width = 150\nbutton.layoutParams.height = 150\n```\n\nXML:\n\n```xml\n<Button\n    android:id=\"@+id/button\"\n    android:layout_width=\"150dp\"\n    android:layout_height=\"150dp\"/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 컴포즈:\n\n```js\nButton(\n    onClick = { /* 버튼 클릭 로직 */ },\n    modifier = Modifier.size(150.dp)\n) {\n    Text(\"눌러주세요!\")\n}\n```\n\n# 콘텐츠 설명 및 대체 텍스트\n\n컨텐츠 설명 또는 대체 텍스트를 사용하여 이미지와 기타 텍스트가 아닌 요소에 대한 설명을 제공하세요. 이렇게 하면 스크린 리더를 사용하는 사용자들이 콘텐츠와 문맥을 이해할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin (이미지용):\n\n```js\nimageView.contentDescription = \"이미지에 대한 설명 텍스트\";\n```\n\nXML (ImageView용):\n\n```js\n<ImageView\n  android:layout_width=\"wrap_content\"\n  android:layout_height=\"wrap_content\"\n  android:contentDescription=\"이미지에 대한 설명 텍스트\"\n  app:srcCompat=\"@drawable/your_image\"\n/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 컴포즈 (이미지용):\n\n```kotlin\nImage(\n    painter = painterResource(id = R.drawable.your_image),\n    contentDescription = \"이미지에 대한 설명적 텍스트\",\n    modifier = Modifier.size(100.dp)\n)\n```\n\n# 색상 및 테마\n\n정보를 전달하기 위해 오로지 색상에 의존하지 말고, 색맹이나 시각 장애가 있는 사용자도 고려하여 중요 정보가 다른 시각적 신호를 통해서도 확인할 수 있도록 해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nKotlin:\n\n```js\n// 색상만으로 정보 전달에 의존하지 말고,\n// 아이콘이나 레이블과 같은 다른 시각적 단서를 사용하세요\ntextView.setBackgroundResource(R.drawable.rounded_corner_background);\n```\n\nXML:\n\n```js\n<TextView\n  android:layout_width=\"wrap_content\"\n  android:layout_height=\"wrap_content\"\n  android:background=\"@drawable/rounded_corner_background\"\n  android:text=\"중요 정보\"\n/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 콤포즈:\n\n## 적응형 레이아웃과 반응형 디자인\n\n다양한 화면 크기와 방향에 적응하는 레이아웃을 디자인하세요. 반응형 디자인은 앱이 다양한 기기에서 사용자 친화적으로 유지되도록 하여 다양한 접근성 요구를 가진 사용자들에게 혜택을 줍니다.\n\n코틀린:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n//적응형 레이아웃을 위해 ConstraintLayout을 사용하세요\nval constraintLayout = findViewById<ConstraintLayout>(R.id.constraintLayout)\nval layoutParams = ConstraintLayout.LayoutParams(\n    ConstraintLayout.LayoutParams.MATCH_PARENT,\n    ConstraintLayout.LayoutParams.MATCH_PARENT\n)\nconstraintLayout.layoutParams = layoutParams\n```\n\nXML:\n\n```js\n<androidx.constraintlayout.widget.ConstraintLayout\n    android:id=\"@+id/constraintLayout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- 여기에 UI 구성 요소를 추가하세요 -->\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\nJetpack Compose:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# TalkBack 및 화면 판독기\n\n시각 장애를 가진 사용자들을 위해 음성 피드백을 제공하는 TalkBack과 같은 화면 판독기를 통합하세요. 화면 판독기 사용자가 사용하는 제스처에 대한 앱의 호환성과 응답성을 테스트하세요.\n\n```js\n// 특정 뷰에 TalkBack 활성화\nViewCompat.setAccessibilityDelegate(view, object : AccessibilityDelegateCompat() {\n    override fun onInitializeAccessibilityNodeInfo(host: View?, info: AccessibilityNodeInfoCompat?) {\n        super.onInitializeAccessibilityNodeInfo(host, info)\n        info?.roleDescription = \"TalkBack용 사용자 정의 설명\"\n    }\n})\n```\n\nXML:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n<View\n    android:id=\"@+id/view\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:contentDescription=\"TalkBack를 위한 사용자 정의 설명\"/>\n```\n\n젯팩 Compose:\n\n# 키보드 탐색\n\n터치 인터페이스 사용에 어려움을 겪을 수 있는 사용자들을 위해 키보드를 사용한 부드러운 탐색을 활성화하세요. 앱 내에서 논리적이고 직관적인 키보드 탐색 경로를 구현해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린:\n\n```kotlin\n// 뷰에 키보드 탐색 기능 활성화\nview.isFocusable = true\nview.isFocusableInTouchMode = true\nview.requestFocus()\n```\n\nXML:\n\n```xml\n<View\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:focusable=\"true\"\n    android:focusableInTouchMode=\"true\"/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n젯팩 콤포즈:\n\n```js\n// 콤포즈에서는 포커스가 일반적으로 자동으로 관리되지만 영향을 줄 수 있습니다\nTextField(\n    value = text,\n    onValueChange = { newText -> text = newText },\n    label = { Text(\"라벨\") },\n    modifier = Modifier.focusRequester(focusRequester)\n)\n```\n\n# 음성 명령 및 음성 입력\n\n음성 명령 기능을 통합하여 사용자가 음성을 사용하여 앱과 상호 작용할 수 있도록합니다. 이는 접근성이 떨어지는 개인이나 무료 경험을 선호하는 사람들에게 큰 혜택이 될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMarkdown:\n\n```xml\n<EditText\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"wrap_content\"\n    android:inputType=\"textMultiLine\"\n    android:imeOptions=\"actionDone\"/>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자막 및 대본\n\n오디오 및 비디오 콘텐츠에 자막을 포함시켜 보조기기를 사용하는 사용자들이 이용하기 쉽도록 하고, 대본을 제공하여 멀티미디어 콘텐츠를 보다 넓은 대중이 이용할 수 있도록 합니다.\n\nKotlin:\n\n```js\n// 비디오에 대한 자막 설정\nvideoView.contentDescription = \"비디오에 대한 자막\";\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nXML:\n\n```js\n<VideoView\n  android:id=\"@+id/videoView\"\n  android:layout_width=\"match_parent\"\n  android:layout_height=\"wrap_content\"\n  android:contentDescription=\"동영상을 위한 캡션\"\n/>\n```\n\nJetpack Compose:\n\n# 고대비 테마\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n저시안을 가진 사용자 또는 특정 시각적 선호도를 갖는 사용자를 위해 시각성을 향상시키는 고대비 테마나 모드를 제공해보세요.\n\nKotlin:\n\n```js\n// 고대비 테마로 동적으로 전환하기\nAppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES);\n```\n\nMarkdown:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<!-- styles.xml에 고대비 테마를 정의하세요 -->\n<style name=\"HighContrastTheme\" parent=\"Theme.AppCompat.DayNight\">\n    <item name=\"android:windowBackground\">@color/highContrastBackground</item>\n    <!-- 필요한 다른 속성을 추가하세요 -->\n</style>\n```\n\nJetpack Compose:\n\n```js\n// Compose 테마는 코드로 정의되며 프로그래밍 방식으로 전환할 수 있습니다\nval highContrastTheme = myTheme.copy(\n    colors = highContrastColors\n)\n```\n\n# 접근성이 좋은 폼\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n친절한 톤으로 번역해보겠습니다:\n\n친밀한 레이블, 명확한 지시사항 및 적절한 입력 유효성 검사를 갖춘 양식을 디자인하세요. 이를 통해 인지 장애가 있는 사용자나 복잡한 양식 구조에 어려움을 겪는 사용자들에게 도움이 됩니다.\n\nKotlin:\n\n```kotlin\n// 양식 필드에 적절한 레이블링과 입력 유효성 검사를 보장\neditText.hint = \"당신의 이름\"\neditText.inputType = InputType.TYPE_CLASS_TEXT\n```\n\nXML:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n// Compose에서는 TextField 또는 기타 관련 컴포넌트를 사용하여 Form을 구축할 수 있습니다\nTextField(\n    value = text,\n    onValueChange = { newText -> text = newText },\n    label = { Text(\"Your Name\") },\n    singleLine = true\n)\n```\n\n# 동적 텍스트 및 폰트 크기 조정하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱 설정에서 텍스트 크기를 사용자 정의할 수 있도록 허용하여 사용자가 인터페이스를 개인적인 필요에 맞게 조정할 수 있게 합니다.\n\n이러한 접근성 기능과 디자인 원칙을 통합함으로써 안드로이드 앱 개발자는 모든 사용자에게 접근 가능한 더 포괄적인 디지털 환경에 기여할 수 있습니다. 실제 사용자와 피드백을 수렴하여 정기적인 테스트를 통해 앱의 접근성과 사용자 경험을 더욱 세련되게 할 수 있습니다.\n\n코틀린:\n\n```kotlin\n// Allow users to customize text size in the app settings\nval sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context)\nval textSize = sharedPreferences.getFloat(\"text_size\", 16f)\ntextView.textSize = textSize\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nXML:\n\n```xml\n<TextView\n    android:id=\"@+id/textView\"\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"?attr/textSizePreference\"/>\n```\n\nJetpack Compose:\n\n이 예시들은 각 접근성 요소가 Kotlin, XML 및 Jetpack Compose에서 어떻게 처리될 수 있는지에 대한 간략한 통찰력을 제공합니다. 앱의 아키텍처 및 디자인에 따라 이러한 개념을 적절하게 조정 및 통합해야 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 안드로이드 앱의 접근성 테스트\n\n모든 능력을 가진 사용자에게 안드로이드 앱이 접근 가능하도록 보장하려면 수동 및 자동화된 접근성 테스트 방법을 종합적으로 활용해야 합니다. 아래에서는 TalkBack 및 Switch Access를 활용한 수동 테스트부터 접근성 스캐너, APK 사전 시작 보고서, UIAutomatorViewer, Lint, Espresso, 사용자 테스트와 같은 분석 도구 및 프레임워크를 활용하는 다양한 테스트 방법을 개요로 설명합니다.\n\n# TalkBack\n\nTalkBack은 안드로이드 기기용 화면 리더기로, 시각 장애를 가진 사용자들을 위해 음성으로 피드백을 제공합니다. TalkBack로 수동 테스트하는 방법은 다음과 같습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기기 설정에서 TalkBack을 활성화하세요.\n- 터치 제스처를 사용하여 앱을 탐색하고 TalkBack이 UI 요소를 읽는 방법을 확인해보세요.\n\n# 스위치 액세스\n\n스위치 액세스를 사용하면 기동 장애가 있는 사용자가 스위치를 사용하여 Android 기기와 상호 작용할 수 있습니다. 스위치 액세스를 수동으로 테스트하려면:\n\n- 기기 설정에서 스위치 액세스를 활성화하세요.\n- 스위치 장치를 연결하고 앱을 탐색하면서 모든 상호 작용 요소에 접근하고 사용할 수 있는지 확인하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 음성 액세스\n\n음성 액세스를 통해 사용자는 음성 명령을 사용하여 기기를 제어할 수 있습니다. 음성 액세스를 수동으로 테스트하려면:\n\n- 기기 설정에서 음성 액세스를 활성화합니다.\n- 음성 명령을 사용하여 앱을 탐색하고 모든 기능이 접근 가능한지 확인합니다.\n\n# 접근성 스캐너\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n접근성 스캐너는 잠재적인 접근성 문제를 검사하는 자동화 도구입니다. Accessibility Scanner를 사용하려면:\n\n- 테스트 기기에 Accessibility Scanner 앱을 설치하세요.\n- 앱을 열고 스캐너를 실행하여 접근성을 향상시키는 권고 사항을 받아보세요.\n\n# APK 사전 발매 보고서\n\nGoogle Play 콘솔의 APK 사전 발매 보고서는 앱의 접근성 성능에 대한 통찰을 제공합니다. 보고서를 생성하려면:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Play Console에 앱을 업로드하세요.\n- \"릴리스 관리\"로 이동하여 \"사전 론칭 보고서\"를 확인하고 접근성 섹션을 검토하세요.\n\n## UIAutomatorViewer\n\nUIAutomatorViewer는 앱의 UI 구성 요소를 검사하는 도구입니다. UIAutomatorViewer를 사용하려면:\n\n- Android SDK 도구에서 뷰어를 실행하세요.\n- 기기를 연결하고 앱을 열어 UI 요소를 적절한 레이블과 계층 구조로 검사하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 린트\n\n안드로이드 린트에는 코드에서 잠재적인 문제를 식별하는 접근성 체크가 포함되어 있습니다. 린트를 실행하려면:\n\n- 터미널에서 다음 명령을 사용하십시오: `./gradlew lint`\n- 생성된 보고서에서 접근성 경고를 검토하십시오.\n\n# 에스프레소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에스프레소는 안드로이드용 강력한 테스팅 프레임워크로, UI 테스팅 및 접근성 측면에서 사용할 수 있습니다. 에스프레소를 사용하여 가시성을 테스트하는 간단한 예제를 확인해보세요:\n\n```js\nAccessibilityChecks.enable().setRunChecksFromRootView(true);\n```\n\n```js\nAccessibilityChecks.enable().apply {\n    setSuppressingResultMatcher(allOf(\n        matchesCheckNames(`is`(\"TextContrastViewCheck\")),\n        matchesViews(withId(R.id.countTV))\n    ))\n}\n```\n\n# 사용자 테스팅\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n**마지막으로, 다양한 능력을 가진 사람들을 대상으로 한 사용자 테스트는 앱의 접근성에 대한 귀중한 통찰을 제공합니다. 다음을 고려해 보세요:**\n\n- **장애를 가진 사용자를 모집하여 앱을 테스트합니다.**\n- **그들의 경험에 대한 피드백을 수집하고 반복적으로 개선합니다.**\n\n**이러한 테스트 방법을 결합하여 안드로이드 앱이 접근 가능하다는 것을 체계적으로 보장할 수 있습니다. 모든 사용자에게 긍정적이고 포괄적인 경험을 제공해 보세요.**\n\n# **결론**\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n드디어 안드로이드 앱 개발에서 접근성을 채택하는 것은 준수를 넘어서 모든 능력을 가진 사용자를 환영하는 포용적인 디지털 세계를 만들기 위한 약속입니다. 접근성 있는 앱을 개발하는 길은 다양한데, 가시성과 간결함을 우선시하는 디자인 원칙을 구현하는 것부터 첨단 테스트 방법을 활용하는 등 모든 것을 포함합니다.\n\n유럽 접근성법(EAA)은 2025년까지 회사들이 디지털 제품을 접근성 있게 하는 것을 보장하는 법적, 윤리적 필수성을 강조하는 선례를 제공했습니다. 이 지침은 디지털 포용성의 중요성을 인식하는 글로벌 이동을 강조합니다. 개발자로서, 우리는 이 변화에서 중추적인 역할을 하며, 장애요소를 제거하고 사용자가 디지털 세계를 원활하게 탐색할 수 있는 솔루션을 개발하는 역할을 맡았습니다.\n\nTalkBack, Switch Access, Voice Access와 같은 수동 테스트부터 Accessibility Scanner, APK Pre-Launch Report, UIAutomatorViewer, Lint와 같은 첨단 분석 도구를 활용하는 것까지, 개발 과정의 모든 단계가 접근성의 최종 목표에 기여합니다. Espresso와 같은 강력한 테스트 프레임워크를 통해 개발자들은 접근성 구현의 효과를 프로그래밍적으로 확인할 수 있습니다.\n\n하지만 가장 통찰력 있는 피드백은 종종 실제 사용자로부터 옵니다. 특히 다양한 능력을 가진 사용자들을 참여시키는 사용자 테스트는 접근성 평가에 질적인 차원을 제공합니다. 그들의 경험과 시각은 개발자들을 자신들의 앱을 개선하도록 이끄는 데 도움이 되며, 앱을 보다 직관적이고 탐색 가능하며 보편적으로 환영받는 것으로 만듭니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n접근성에 대한 약속은 고정적인 것이 아닙니다. 계속된 학습과 적응이 필요하며, 만능 디자인 원칙을 준수하는 디지턈 환경을 만들기 위한 변함없는 헌신이 필요합니다. 앞으로 나아가면서, 우리는 규제적인 기준을 준수하는 것뿐만 아니라, 제약을 넘어진 디지턈 경험을 개발하고 진정한 포용의 정신을 대변하는 것을 목표로 할 것입니다. 이렇게 함으로써, 법적 요구사항을 충족할 뿐만 아니라, 기술이 다양한 삶의 방식을 가진 사람들을 통합하는 다리 역할을 하며 미래에 기여할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png"},"coverImage":"/assets/img/2024-06-19-AccessibilityAmplifiedAJourneytoInclusiveAndroidApps_0.png","tag":["Tech"],"readingTime":24},{"title":"Jetpack Compose와 함께 ViewModel 사용하기","description":"","date":"2024-06-19 13:50","slug":"2024-06-19-HowtoUseViewModelwithJetpackCompose","content":"\n이 기사는 ViewModel을 Jetpack Compose와 통합하여 데이터를 효율적으로 관리하고 표시하는 방법을 안내합니다.\n\n## ViewModel 이해하기\n\nViewModel은 Android 아키텍처 컴포넌트의 일부로서 UI 관련 데이터를 라이프사이클에 맞게 관리하는 데 도움이 됩니다. 환경 변경을 살아남고 활동 또는 프래그먼트와 같은 전통적인 Android 컴포넌트보다 긴 수명 주기 동안 UI 관련 데이터를 보관하고 관리하는 데 이상적입니다.\n\n## ViewModel 설정하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n먼저 프로젝트에 Jetpack Compose가 설정되어 있는지 확인하세요. 이곳에는 Kotlin을 사용하여 Jetpack Compose를 이용한 ViewModel의 기본 설정이 있습니다:\n\nFoodCategoriesUiState: 이 sealed 인터페이스는 UI가 취할 수 있는 다양한 상태를 정의합니다: 로딩, 성공 (사진 목록 포함), 오류. 이를 통해 UI 상태를 구조적으로 관리하고 표현할 수 있습니다.\n\nFoodCategoriesViewModel: 이 클래스는 ViewModel을 확장하며 Food Categories 사진을 표시하기 위한 UI 관련 데이터를 관리합니다.\n\nfoodCategoriesUiState: 이 속성은 mutableStateOf를 사용하여 초기화된 로딩 상태인 UI의 현재 상태를 나타냅니다. Jetpack Compose가 이를 관찰하고 UI를 업데이트할 수 있는 반응적 상태입니다. 외부 클래스가 직접 수정할 수 없도록 private로 설정되어 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n초기화 블록: FoodCategoriesViewModel을 초기화하면 getFoodCategories()가 호출되어 즉시 Food Categories 사진을 가져오는 프로세스가 시작됩니다.\n\ngetFoodCategories(): 이 함수는 viewModelScope에서 코루틴을 시작합니다. Food Categories 사진을 비동기적으로 가져오기 전에 foodCategoriesUiState를 로딩으로 업데이트합니다.\n코루틴 내부:\n\n- getFoodCategories() 메서드를 사용하여 foodCategoriesRepository에서 사진을 가져오려고 시도합니다.\n- 성공하면(try 블록), 가져온 사진과 함께 foodCategoriesUiState를 성공으로 업데이트합니다.\n- IOException 또는 HttpException이 발생하면(catch 블록), foodCategoriesUiState를 에러로 업데이트합니다.\n\n팩토리 동반 객체: 이 객체는 FoodCategoriesViewModel 인스턴스를 인스턴스화하는 데 사용할 수 있는 ViewModelProvider.Factory를 제공합니다. ViewModel 인스턴스에 리포지토리와 같은 의존성이 필요한 경우에는 팩토리 패턴을 사용하는 것이 일반적입니다.\n\nviewModelFactory: 이는 androidx.lifecycle.viewmodel 라이브러리에서 제공되는 함수입니다. ViewModelProvider.Factory를 만들어 ViewModel 인스턴스를 람다(초기화자)를 사용하여 초기화할 수 있게 해줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n초기화 Lambda: 람다 내부에서는 FoodCategoriesApplication에서 FoodCategoriesRepository 종속성을 검색합니다. 이는 APPLICATION_KEY를 사용하여 수행되는데, 이는 맵 형태 구조(바로 이 구조)에서 애플리케이션 인스턴스를 검색하는 데 사용되는 키입니다.\n\n의존성 주입: 이 팩토리 패턴을 사용함으로써 FoodCategoriesViewModel은 종속성(foofCategoriesRepository)이 주입된 상태로 인스턴스화될 수 있습니다. 이는 관심사의 분리를 촉진하고 종속성의 목 표현을 주입함으로써 단위 테스트를 용이하게 합니다.\n\n📖 FoodCategoriesViewModel 클래스는 Jetpack Compose와 통합하여 Food Categories 사진 검색이 repository(foofCategoriesRepository)로부터 어떻게 상태를 관리하는지에 관여합니다. 이는 UI (foofCategoriesUiState)가 데이터를로드하는 중인지, 성공적으로 가져 왔는지 또는 가져오는 동안 오류가 발생했는지를 반영하도록 보장합니다. 이 설정은 Kotlin 코루틴(viewModelScope.launch)을 사용하여 비동기 작업과 Jetpack Compose의 반응형 상태 관리(mutableStateOf)를 통해 상태 변경에 따라 UI 업데이트를 제공합니다.\n\n## HomeScreen\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n👉 홈 화면 Composable 기능:\n\n- foodCategoriesUiState: FoodCategoriesViewModel에서 관리되는 UI의 현재 상태를 나타냅니다.\n- retryAction: FoodCategoriesViewModel에서 전달되는 람다 함수로, 오류가 발생한 경우 사진을 다시 가져오는 처리를 담당합니다.\n- modifier: 레이아웃과 모양 속성을 지정할 수 있게 해주는 Compose Modifier입니다.\n\n👉 When 표현식:\n\nfoodCategoriesUiState에 따라 다음이 실행됩니다:\n\n- Loading: 로딩 인디케이터를 표시하는 LoadingScreen을 호출합니다.\n- Success: 사진 목록(foodCategoriesUiState.photos)을 전달하여 그리드 형태의 사진을 보여주는 PhotosGridScreen을 호출합니다.\n- Error: 에러 메시지와 다시 시도하는 버튼이 함께 표시되는 ErrorScreen을 호출합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## ViewModel을 Jetpack Compose와 통합하기\n\n👉 FoodCategoriesApp 콤포저블 함수:\n@Composable: 이 함수가 Jetpack Compose를 사용하여 콤포저블 UI 요소를 정의한다는 것을 나타냄.\nScaffold: 상단 바, 컨텐츠 영역 및 선택적인 플로팅 액션 버튼을 포함하는 앱을 위한 기본 레이아웃 구조를 제공.\nSurface: 내용을 그리기 위한 컨테이너로, 지금의 경우 사용 가능한 공간 전체를 차지함(fillMaxSize() 수정자).\nviewModel: androidx.lifecycle.viewmodel.compose에서 ViewModel 인스턴스(FoodCategoriesViewModel)를 제공하는 공장(FoodCategoriesViewModel.Factory)을 사용하여 가져오는 콤포저블 함수.\nHomeScreen: FoodCategoriesViewModel에서 foodCategoriesUiState 및 retryAction을 전달 받는 HomeScreen.kt에 정의된 다른 콤포저블 함수.\n\n👉 ViewModel 통합:\nviewModel(factory = FoodCategoriesViewModel.Factory): 이 줄은 앞에서 정의된 Factory를 사용하여 FoodCategoriesViewModel의 인스턴스를 가져옴. 이는 음식 카테고리 사진을 가져와 표시하는 관련 상태를 관리함.\nFoodCategoriesViewModel 인스턴스(foodCategoriesViewModel)는 UI 상태(foodCategoriesUiState)를 관리하며 리포지토리에서 음식 카테고리 사진을 가져오는 메서드(getFoodCategories)를 제공함.\n\n요약하면, FoodCategoriesApp은 Jetpack Compose의 Scaffold와 Surface를 사용하여 앱의 기본 구조를 설정하고, UI 상태 및 데이터 가져오기를 관리하기 위해 FoodCategoriesViewModel을 통합함. 반면에 HomeScreen은 FoodCategoriesViewModel에서 관리되는 다양한 상태(로딩, 성공, 오류)에 기반한 UI 구성 요소를 정의함. 함께 사용하여 Jetpack Compose와 ViewModel 아키텍처를 사용하여 안드로이드 앱에서 동적이고 반응적인 UI를 구축하는 방법을 보여줌.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![How to Use ViewModel with Jetpack Compose](/assets/img/2024-06-19-HowtoUseViewModelwithJetpackCompose_0.png)\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoUseViewModelwithJetpackCompose_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoUseViewModelwithJetpackCompose_0.png","tag":["Tech"],"readingTime":6},{"title":"코틀린 고급 주제 필수","description":"","date":"2024-06-19 13:48","slug":"2024-06-19-KotlinAdvancedTopicsEssential","content":"\nKotlin Multiplatform (KMP)의 공식 릴리스와 안드로이드와의 통합으로 Kotlin은 엄청난 인기를 얻고 있습니다. Kotlin의 매력은 다양성에 있습니다. 개발자들이 단일 언어를 습득하고 백엔드, 프론트엔드(Android, iOS 및 웹)를 포함한 여러 플랫폼에서 활용할 수 있습니다. Kotlin이 계속 성장함에 따라 개발자들은 필수적이고 고급 주제를 탐색하여 기술을 향상시킬 수 있어야 합니다. 이를 통해 예외적인 코딩 표준을 유지하고 산업에서 앞서 나갈 수 있습니다.\n\n![img](/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png)\n\n### 위임\n\nKotlin에서의 위임은 객체가 일부 책임을 다른 객체에 위임할 수 있도록 하는 디자인 패턴입니다. Kotlin은 by 키워드를 사용하여 위임에 대한 내장 지원을 제공합니다. Kotlin에서는 클래스 위임과 속성 위임 두 가지 주요 위임 유형이 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 속성 위임\n\nlazy 위임은 속성이 처음 액세스 될 때만 초기화됩니다. 이는 비용이 많이 드는 객체 초기화나 프로그램 실행 중에만 필요한 속성에 유용합니다. 이를 통해 리소스 사용을 최적화하고 응용 프로그램 성능을 향상시킬 수 있습니다. 기본적으로 lazy 초기화는 스레드 안전합니다.\n\n```js\nval myName: String by lazy {\n    println(\"계산됨\")\n    \"내 이름\"\n}\n```\n\n## 클래스 위임\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n클래스 위임은 한 클래스가 다른 클래스로 메서드 구현을 위임할 수 있게 합니다. 이는 합성을 위해 유용하며 상속 없이 다른 클래스의 동작을 통합할 수 있도록 합니다. 인터페이스 구현 또는 기능을 다른 클래스로 위임함으로써 코드 중복을 피할 수 있습니다.\n\n```kotlin\n    interface Weather {\n        fun currentWeather()\n    }\n\n    class Summer : Weather {\n        override fun currentWeather() {\n            println(\"Current weather is ${javaClass.simpleName}\")\n        }\n    }\n\n    class HolidayPlans(weather: Weather) : Weather by weather {\n    }\n```\n\n# 확장 함수\n\nKotlin의 확장 함수를 사용하면 코드의 재사용성을 높이기 위해 우리만의 유틸리티 함수를 작성할 수 있습니다. 내부적으로 확장 함수는 컴파일 시점에 클래스에 대해 정적으로 해결되며 해당 클래스의 공개 멤버에 액세스할 수 있도록 합니다(소스 코드를 수정하지 않고).\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval EMAIL_ADDRESS_PATTERN = Pattern.compile(\n        \"[a-zA-Z0-9\\\\+\\\\.\\\\_\\\\%\\\\-\\\\+]{1,256}\\\\@[a-zA-Z0-9][a-zA-Z0-9\\\\-]{0,64}(\\\\.[a-zA-Z0-9][a-zA-Z0-9\\\\-]{0,25})+\"\n    )\n\n    private fun String.isEmail() =\n        EMAIL_ADDRESS_PATTERN.matcher(this).matches()\n\n    fun verifyCredential(emailId: String) {\n        println(emailId.isEmail())\n    }\n```\n\n# 고차 함수\n\n고차 함수를 사용하면 함수를 인수로 사용하거나 함수를 반환하거나 둘 다를 할 수 있습니다. 이를 통해 추상 코드를 생성하고 특정 상황에서 함수 구현을 선언하고 다른 상황에서 실행할 수 있습니다. 이를 통해 강력한 추상화와 더 깨끗하고 모듈화된 코드를 작성할 수 있습니다.\n\n## 기본 고차 함수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfun calculate(a: Int, b: Int, operator: (Int, Int) -> Int) {\n  operator(a, b)\n}\n\nfun main() {\n    val sum = calculate(5, 3) { a, b -> a + b }\n    println(\"합계: $sum\") // 합계: 8\n    val product = calculate(5, 3) { a, b -> a * b }\n    println(\"곱셈: $product\") // 곱셈: 15\n}\n```\n\n## 함수 반환\n\n```kotlin\nfun operation(op: String): (Int, Int) -> Int {\n    return when (op) {\n        \"add\" -> { a, b -> a + b }\n        \"multiply\" -> { a, b -> a * b }\n        else -> { _, _ -> 0 }\n    }\n}\n\nfun main() {\n    val addOperation = operation(\"add\")\n    println(\"덧셈: ${addOperation(2, 3)}\") // 덧셈: 5\n    val multiplyOperation = operation(\"multiply\")\n    println(\"곱셈: ${multiplyOperation(2, 3)}\") // 곱셈: 6\n}\n```\n\n- inline: 컴파일러에게 함수의 바이트코드를 호출 지점에 직접 넣도록 요청합니다. 함수 호출 및 람다 생성의 오버헤드를 줄여 성능을 향상시킬 수 있습니다.\n- noinline: 인라인 함수 내 람다 매개변수를 인라인화하지 못하게 합니다. 람다를 저장하거나 전달해야 할 때 유용합니다.\n- crossinline: 인라인 함수 내 람다의 비지역 반환을 방지합니다. 람다가 둘러싸는 함수로부터 반환하지 못하도록하여 람다의 예측 가능한 동작을 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Sealed Class / Interface\n\nSealed 클래스는 자바 세계의 enum의 고급 버전으로 볼 수 있습니다. 코틀린에서 sealed class와 sealed interface를 모두 선언할 수 있습니다. Sealed 클래스와 sealed interface는 Kotlin에서 제한된 계층 구조를 모델링하는 유용한 도구입니다. 두 가지 중에서 선택하는 것은 상태와 동작을 공유해야 하는지(Sealed class 사용) 또는 동작에 대한 계약을 정의해야 하는지에 따라 다릅니다(Sealed interface 사용).\n\n```js\nsealed interface Polygon {\n    data class Circle(val radius: Double) : Polygon\n    data class Square(val side: Double) : Polygon\n    data object NotAShape : Polygon\n}\n```\n\n```js\nsealed class Shape(area: Double) {\n    data class Circle(val radius: Double) : Shape(3.14* radius* radius)\n    data class Square(val side: Double) : Shape(side * side)\n    data object NotAShape : Shape(0.0)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 제네릭\n\n제네릭은 Kotlin에서 선언된 클래스, 인터페이스 및 함수에 타입 매개변수를 사용할 수 있는 강력한 도구입니다. 이를 통해 다양한 데이터 유형을 허용하고 타입 안전성을 유지하면서 유연하고 재사용 가능한 코드를 작성할 수 있습니다.\n\n## 제네릭 클래스\n\n```js\nclass Machine<T>(val type: T)\n\nfun main() {\n    val machine1 = Machine(12)\n    val machine2 = Machine(\"optimus\")\n    println(machine1.type) // 12\n    println(machine2.type) // optimus\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 일반 함수들\n\n일반 함수들은 타입 매개변수를 가진 함수들입니다. 이를 통해 우리는 타입 안전성을 희생하지 않고 다른 타입들에 대해 동작하는 함수를 작성할 수 있습니다.\n\n```kotlin\nfun <T> singletonList(item: T): List<T> {\n    return listOf(item)\n}\n\nfun main() {\n    val intList = singletonList(5)\n    println(intList) // [5]\n}\n```\n\n## Variance\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n분산이란 일반적인 유형 간의 서브타이핑 관계를 정의합니다.\n\n- 불변성은 요소를 소비하고 생성할 수 있습니다. `T` 타입의 `Invariant` 클래스입니다.\n\n```kotlin\nclass Invariant<T>(var value: T)\nval intInvariant = Invariant<Int>(12)\n// var anyInvariant : Invariant<Any> = intInvariant // 컴파일 오류\n```\n\n- 공산성은 요소를 생성만 할 수 있습니다. `T`의 슈퍼 클래스는 `T`를 대체할 수 있지만 서브타입은 아닙니다. `out T`입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nclass Contravariant<out T>(private val value: T) {\n    fun get(): T {\n        return value\n    }\n}\n\nfun main() {\n    val intContravariant = Contravariant<Int>(12)\n    val anyContravariant: Contravariant<Any> = intContravariant\n    // val doubleContravariant : Contravariant<Double> = intContravariant // Compilation error\n}\n```\n\n- Contravariance can only consume elements. The subclasses of T can replace it but not the superclass. `in T`\n\n```kotlin\nclass Contravariant<in T> {\n    fun put(item: T) { println(item) }\n}\n\nfun main() {\n    val numberContravariant = Contravariant<Number>()\n    val doubleContravariant: Contravariant<Double> = numberContravariant\n    // val anyContravariant: Contravariant<Any> = numberContravariant  // Compilation error\n}\n```\n\n# 코루틴\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코루틴은 가볍고(쓰레드보다 훨씬 가볍습니다). 블로킹하지 않고, 어느 스레드도 차단하지 않지만 코드 실행을 일시 중단하고 다시 시작합니다. 디스패처(dispatchers)와 스코프(scopes)에 따라 코루틴이 널리 분류됩니다.\n\n## 코루틴 스코프\n\n- GlobalScope 어떤 특정 라이프사이클에 바인딩되지 않은 최상위 코루틴을 시작하는 글로벌 스코프\n- lifecycleScope 액티비티나 프래그먼트의 수명주기에 바인딩된 스코프\n- viewModelScope ViewModel 수명주기에 바인딩된 스코프\n\n```js\nGlobalScope.launch {\n    // 오래 실행되는 작업\n}\nlifecycleScope.launch {\n    // 코루틴 코드\n}\nviewModelScope.launch {\n    // 코루틴 코드\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Coroutine Dispatchers\n\n- `dispatchers.Main`은 주 (UI) 스레드에서 실행됩니다.\n- `dispatchers.IO`는 네트워크 또는 데이터베이스 작업에 사용됩니다.\n- `dispatchers.Default`는 CPU 집약적인 작업에 사용됩니다 (비트맵 작업).\n- `dispatchers.Unconfined`는 호출자 스레드에서 실행되지만 처음 일시 중지 지점까지만 실행됩니다.\n\n## Builders\n\n- `launch`는 새로운 코루틴을 시작하고 결과를 반환하지 않습니다. Fire-and-forget 방식입니다.\n- `async`는 새로운 코루틴을 시작하고 향후 결과를 나타내는 Deferred를 반환합니다. 결과를 얻으려면 `await`를 사용하세요.\n- `runBlocking`은 해당 블록이 완료될 때까지 현재 스레드를 차단합니다. 주로 메인 함수 및 테스트에서 사용됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nCoroutineScope(Dispatchers.Main).launch {\n    // 코루틴 코드\n}\n\nval deferred = CoroutineScope(Dispatchers.Default).async {\n    // 비동기 작업\n    \"결과\"\n}\nrunBlocking {\n    val result = deferred.await()\n    println(result)\n}\n\nrunBlocking {\n    // 코루틴이 완료될 때까지 블록됨\n}\n```\n","ogImage":{"url":"/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png"},"coverImage":"/assets/img/2024-06-19-KotlinAdvancedTopicsEssential_0.png","tag":["Tech"],"readingTime":10},{"title":"픽셀 완벽 모든 화면, 모든 폴드를 위한 디자인","description":"","date":"2024-06-19 13:46","slug":"2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold","content":"\n모바일 기기 다양성이 이전에 없던 수준으로 증가했습니다. 앱 개발자들은 스마트폰, 태블릿, 접이식 기기와 같은 다양한 기기들이 각각 다른 화면 크기, 해상도 및 방향을 가지고 있기 때문에 많은 도전을 겪습니다. 이 넓은 범위에서 부드러운 사용자 경험을 만들기 위해서는 창의력 뿐만 아니라 다양한 화면 크기에 관련된 미묘한 부분을 깊이 이해해야 합니다.\n\n본 문서는 다양한 화면을 위해 응용프로그램을 생성하고 테스트하는 과학과 예술을 탐구하며, 다양한 형태 요소를 가진 기기에 대한 디자인 세부 사항에 대한 통찰력 있는 정보를 제공합니다. 태블릿에서 접이식 폰으로의 환경은 항상 변화하기 때문에, 개발자들은 모든 기기에서 앱이 멋지게 보이고 완벽하게 작동하도록 보장하기 위해 항상 최신 정보를 유지해야 합니다.\n\n다양한 화면 크기에 대한 디자인 시 고려해야 할 중요한 요소와 Jetpack Compose 및 XML 레이아웃을 사용하여 레이아웃을 관리하는 실용적인 조언에 대해 논의할 것입니다. 또한 사용자가 기능성 또는 스타일에 어긋나지 않고 세로 및 가로 모드 사이를 쉽게 전환할 수 있도록 하는 다양한 화면 방향을 지원하는 것이 얼마나 중요한지에 대해 이야기하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테스트는 개발 과정 중요한 부분이에요. 다양한 기기에서 앱의 기능을 확인하는 실용적인 방법을 안내해 드릴게요. 에뮬레이터를 사용하여 빠른 반복부터 디바이스 팜을 활용해 철저한 테스트까지, 테스트 환경에서의 복잡성을 성공적으로 해결하기 위해 필요한 기술과 정보를 제공할 거예요.\n\n함께 다중 화면 개발과 테스트의 복잡성을 탐험해 볼까요? 오늘날 접근 가능한 다양한 화면에 적응할 수 있는 애플리케이션을 디자인하는 수수께끼를 풀며, 미래 기술 발전에 부응할 수 있도록 하겠어요.\n\n# 폼 팩터 스펙트럼\n\n폼 팩터는 이제 전통적인 것 이상을 포함하고 있어요. 접이식 기기의 등장과 스마트폰, 태블릿의 전통적인 제약으로 개발자들은 이제 다양한 화면 크기와 모양을 대상으로 하고 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 형태 요소의 진화\n\n스마트폰 및 태블릿: 전통적인 스마트폰 및 태블릿은 오랫동안 모바일 애플리케이션의 표준 형태 요소였습니다. 컴팩트한 화면부터 확장된 태블릿까지 다양한 디바이스가 있었기 때문에, 개발자들은 다양한 화면 크기와 해상도를 수용할 수 있도록 레이아웃을 조정하는 데 익숙해져 왔습니다.\n\n접이식 디바이스: 접이식 디바이스의 등장으로 새로운 시대가 열렸습니다. 이로 인해 개발자들은 정적 화면의 제약을 벗어나 생각하도록 도전받게 되었습니다. 접이식 디바이스는 유연성과 혁신을 동시에 제공하여 사용자가 컴팩트한 형태와 확장된 디스플레이 사이를 매끄럽게 전환할 수 있게 합니다. 접이식 디바이스 시장이 계속 성장함에 따라 적응형 앱 디자인의 필요성이 더욱 뚜렷해지고 있습니다.\n\n## 서로 다른 형태 요소에 맞추는 이유?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n향상된 사용자 경험: 다양한 형태 요소에 맞게 애플리케이션을 디자인하면 사용자가 선택한 기기에 관계없이 최적의 경험을 제공할 수 있습니다. 특정 화면에 맞게 레이아웃을 맞추면 더 몰입감 있고 사용자 친화적인 상호작용이 가능해져 사용자 만족도가 높아집니다.\n\n시장 접근성: 다양한 형태 요소 수용을 통해 앱의 잠재적 사용자 기반을 확대할 수 있습니다. 시장에 있는 다양한 기기들을 수용함으로써 애플리케이션의 접근성을 더 넓은 관객에게 제공하여 새로운 시장과 인구통계를 개방할 수 있습니다.\n\n미래 준비: 기술이 발전함에 따라 형태 요소도 변합니다. 유연성을 고려하여 디자인하면 새로운 모양과 크기의 기기가 등장해도 앱이 여전히 관련성 있고 기능적이게 유지될 수 있습니다.\n\n## 레이아웃 조정 대 기존 지원 중단\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n다양한 형태 요인을 수용해야 할 때, 개발자는 적응성과 실용성 사이의 균형을 유지해야 합니다. 다음은 고려해야 할 주요 사항입니다:\n\n레이아웃 조정:\n\n- 반응형 디자인 원칙을 활용하여 다양한 화면 크기에 동적으로 적응하는 레이아웃을 만듭니다.\n- XML 레이아웃에서 ConstraintLayout 또는 Jetpack Compose에있는 반응형 수정자와 같은 기술을 활용하여 다양한 기기에서 일관된 사용자 경험을 보장합니다.\n\n지원 중단:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 귀하의 앱 대상 사용자를 기준으로 특정 형태 요소를 지원하는 실용성을 평가합니다.\n- 특정 기기를 지원하지 않을지 결정할 때 필요한 개발 노력과 잠재적 사용자 영향을 고려합니다.\n\n형태 요소의 다양성을 수용하는 것은 단순히 디자인 고려사항이 아니라 전략적 필수불가결입니다. 다양한 형태 요소 개발의 복잡성을 탐구하는 동안 목표는 명확합니다: 정적 화면의 제약을 초월하며 다양한 장치 스펙트럼의 사용자에게 원활하고 즐거운 경험을 제공하는 애플리케이션을 만드는 것입니다.\n\n# 적응형 레이아웃 만들기\n\n## 다중 레이아웃 지원을 위한 XML 데이터 바인딩\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n반응형 XML 레이아웃:\n\n- XML에서 `layout` 및 `data` 요소를 사용하여 레이아웃 구성 요소에 데이터를 바인딩하세요.\n- 리소스 지정자(예: 태블릿용 res/layout-large)를 활용하여 서로 다른 화면 크기에 대한 특정 레이아웃을 생성하세요.\n\n```js\nres / layout / activity_main.xml; // 기본 레이아웃\nres / layout - sw600dp / activity_main.xml; // 7인치 태블릿용 레이아웃\nres / layout - land / activity_main.xml; // 가로 방향용 레이아웃\n```\n\n가로 방향에 최적화된 레이아웃:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 기기가 회전될 때 사용성이 향상되는 랜드스케이프 전용 레이아웃을 만들어보세요.\n\n```xml\n<!-- res/layout-land/activity_main.xml -->\n<LinearLayout\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- 랜드스케이프 전용 UI 구성 요소 -->\n</LinearLayout>\n```\n\n접이식 기기:\n\n- 맞춤형 레이아웃을 제공하기 위해 접이식 기기용 리소스 한정자를 활용하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n<!-- res/layout-large/activity_main.xml -->\n<LinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- Foldable device UI components -->\n</LinearLayout>\n```\n\n반응형 ConstraintLayout:\n\n- ConstraintLayout을 활용하여 다양한 화면 크기와 방향에 자동으로 조절되는 반응형 디자인을 만듭니다.\n\n## 동적 UI를 위한 Jetpack Compose\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n화면 크기 처리:\n\n젯팩 컴포즈에서 Modifier.fillMaxSize()는 레이아웃이 사용 가능한 공간을 차지하도록 보장하며, 다양한 화면 크기에 적응합니다. 또한 padding 수정자를 사용하여 일관된 여백을 제공하면 다양한 크기에 걸쳐 깔끔하고 조직적인 모양을 유지할 수 있습니다.\n\n방향 관리:\n\nLocalConfiguration.current.orientation을 사용하여 현재 방향을 확인하면 Composable 함수 내에서 조건부로 다른 레이아웃을 정의할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Foldable 기기용 SlidingPaneLayout\n\n- SlidingPaneLayout을 활용하여 Foldable 기기를 위한 슬라이딩 패널 UI를 만들어보세요.\n\nDataBinding과 Jetpack Compose에서 이러한 기술들을 활용함으로써, 다양한 화면 크기, 방향 및 심지어 Foldable 기기의 독특한 형태 요소까지 우아하게 수용하는 적응형 레이아웃을 만들 수 있습니다. 크기를 조정하거나 동적 레이아웃을 사용하더라도, 사용자들에게 다양한 기기 스펙트럼에서 일관되고 즐거운 경험을 제공하는 것이 목표입니다.\n\n# 함정 피하기 & 최선의 실행 방법\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 흔한 함정 및 그것을 피하는 방법\n\n고정된 크기:\n\n- 함정: 크기를 하드코딩하는 것은 다른 화면 크기에서 레이아웃이 왜곡될 수 있습니다.\n- 해결책: 상대적인 크기인 wrap_content 및 match_parent를 사용하거나 일관된 크기를 위해 밀도 독립적인 픽셀(dp)을 활용하십시오.\n- XML 데이터 바인딩 예시:\n\n- Jetpack Compose 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n밀도 독립성을 무시하고:\n\n- 함정: 고정된 픽셀 값에만 의존하는 것은 다른 픽셀 밀도를 가진 장치에서 일관성 없는 UI를 초래할 수 있습니다.\n- 해결책: 밀도 독립 단위(dp XML에서, Compose에서는 dp 또는 sp)를 사용하여 UI 요소가 다른 화면에서 적절하게 확장되도록 보장합니다.\n- XML 데이터 바인딩:\n\n```js\n<!-- res/layout/activity_main.xml -->\n<TextView\n    android:layout_width=\"wrap_content\"\n    android:layout_height=\"wrap_content\"\n    android:textSize=\"16sp\"\n    android:padding=\"8dp\"\n    android:text=\"밀도 독립적 텍스트\" />\n```\n\n- Jetpack Compose:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// src/main/kotlin/com/example/myapp/ui/MainScreen.kt\nText(\n    text = \"밀도 독립적 텍스트\",\n    fontSize = 16.sp,\n    modifier = Modifier.padding(8.dp)\n)\n```\n\n방향 변경 무시:\n\n- 함정: 가로 또는 세로 방향을 무시하면 사용자 경험이 최적화되지 않을 수 있습니다.\n- 해결책: 장치가 회전될 때 개선된 사용성을 위해 랜드스케이프 전용 레이아웃을 설계합니다.\n- XML 데이터 바인딩 예시:\n\n```js\n<!-- res/layout-land/activity_main.xml -->\n<LinearLayout\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- 랜드스케이프 전용 UI 구성 요소 -->\n</LinearLayout>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Jetpack Compose 예시:\n\n접힐 수 있는 장치 고려를 무시할 때:\n\n- 함정: 접힐 수 있는 장치의 독특한 형태 요소를 간과하면 최적의 사용자 경험을 보장받기 어려울 수 있습니다.\n- 해결책: 접힐 수 있는 장치에 대한 리소스 크기 조정자를 통합하고 레이아웃을 맞춤화하여 그들의 기능을 최대한 활용하십시오.\n- XML 데이터 바인딩 예시:\n\n```js\n<!-- res/layout-large/activity_main.xml -->\n<LinearLayout\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n    <!-- 접힐 수 있는 장치 UI 구성 요소 -->\n</LinearLayout>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- **Jetpack Compose 예시:**\n\n## 원활한 경험을 위한 추가 팁\n\n동적 간격:\n\n- 화면 크기에 따라 차원 리소스를 사용하여 간격을 동적으로 조절합니다.\n- XML 데이터 바인딩 예시:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nText(\n    text = \"동적 간격\",\n    modifier = Modifier\n        .padding(dimensionResource(id = R.dimen.margin_standard))\n)\n```\n\n반응형 글꼴 크기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- Responsive 폰트 크기를 조절하는 데 디멘션 리소스를 사용하세요.\n- XML 데이터바인딩 예시:\n\n```js\n<TextView\n  android:layout_width=\"wrap_content\"\n  android:layout_height=\"wrap_content\"\n  android:text=\"Responsive Font\"\n  android:textSize=\"@dimen/text_size_medium\"\n/>\n```\n\n- Jetpack Compose 예시:\n\n```js\nText(\n  (text = \"Responsive Font\"),\n  (fontSize = dimensionResource((id = R.dimen.text_size_medium)).value)\n);\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n화면 크기, 방향 및 접이식 장치의 다양한 환경을 다루기 위해서는 세부 사항에 주의해야 합니다. 흔한 실수를 피하고 이러한 추가적인 기교를 구현하여 다양한 장치에서 원활하고 즐거운 사용자 경험을 제공하는 적응형 레이아웃을 만들 수 있습니다.\n\n# 스펙트럼 테스팅: 에스프레소, 파이어베이스 디바이스 팜, 그리고 에뮬레이터\n\n다양한 화면 크기와 방향에서 앱이 원활하게 작동하도록 보장하기 위해서는 견고한 테스트 전략이 필요합니다. 이 섹션에서는 에스프레소를 사용하여 애플리케이션을 효율적으로 테스트하는 방법, 포괄적인 디바이스 커버리지를 위해 파이어베이스 디바이스 팜을 활용하는 방법, 그리고 테스트 필요에 맞게 맞춤형 에뮬레이터를 설정하는 방법을 살펴보겠습니다. 게다가 이러한 테스트를 로컬 및 지속적 통합(Continuous Integration, CI) 파이프라인 내에서 실행하는 스크립트도 제공할 것입니다.\n\n## 로컬 테스트를 위한 에스프레소\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n에스프레소는 안드로이드용 강력한 테스팅 프레임워크로서 간결하고 신뢰할 수 있는 UI 테스트를 작성할 수 있습니다. 로컬에서 다양한 화면 크기와 방향을 테스트하려면 에스프레소의 ViewMatchers 및 ViewActions를 사용하여 UI 요소를 확인하는 ViewAssertions와 결합할 수 있습니다.\n\n에스프레소 코드 예시:\n\n## Firebase Device Farm를 활용한 철저한 테스트\n\nFirebase Device Farm는 다양한 실제 기기에서 앱을 테스트할 수 있는 클라우드 기반 솔루션을 제공합니다. 다양한 화면 크기, 방향 및 기기를 커버하는 테스트 매트릭스를 생성하여 다양한 구성에 대해 철저한 테스트를 보장할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFirebase Test Lab 예제 코드:\n\n## 사용자 정의 테스트 환경을 위한 에뮬레이터 설정\n\nAndroid 에뮬레이터는 테스트를 위한 사용자 정의 가상 장치를 생성하는 유연한 방법을 제공합니다. 에뮬레이터를 구성하여 실제 시나리오를 모방하기 위해 특정 화면 크기, 해상도 및 방향을 일치시킬 수 있습니다.\n\n## 사용자 정의 에뮬레이터 설정:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAVD Manager를 사용하여 새로운 에뮬레이터를 생성하세요. 화면 크기, 해상도 및 방향과 같은 장치 세부 정보를 지정해주세요.\n\n```js\nemulator -avd Pixel_6_API_32 -orientation portrait\n```\n\n에뮬레이터 시작: 원하는 구성으로 에뮬레이터를 시작하세요.\n\n## 로컬에서 테스트를 실행하는 스크립트:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n#!/bin/bash\n# Espresso 테스트가 'androidTest' 디렉토리에 있다고 가정합니다\n./gradlew connectedAndroidTest\n```\n\n## CI 파이프라인용 스크립트 (Firebase Device Farm 통합):\n\n이러한 테스트 전략을 개발 워크플로에 통합함으로써, 앱이 다양한 화면 크기, 해상도, 방향에서 매끄럽게 작동함을 보장할 수 있습니다. Espresso로 로컬에서 테스트하거나 Firebase Device Farm에서 다양한 설정을 탐색하거나 사용자 정의 에뮬레이터를 만들 때, 포괄적인 테스트 접근 방식은 높은 품질의 사용자 경험을 제공하는 데 중요합니다.\n\n# 결론\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금보다 더 중요한 것은 다양한 화면 크기, 방향 및 접힐 수 있는 장치에서 매끄럽게 작동하는 경험을 디자인하는 것입니다. 다양한 형태 요소 테스트와 개발을 통한 탐구는 디지털 세계의 도전에 대처하려는 개발자들에게 더 나은 방법을 제시하고 있습니다.\n\nJetpack Compose와 XML 데이터 바인딩의 적응형 디자인 개념을 활용하면, 개발자들은 점점 다양해지는 기기 범위에 맞춰 레이아웃을 유동적으로 조정할 수 있습니다. 이러한 방법으로 제공되는 적응성은 스마트폰, 태블릿 및 접힐 수 있는 장치에서 동일하고 즐거운 경험을 제공하여 모든 고객이 일관된 사용자 경험을 누릴 수 있도록 보장합니다.\n\n앱 개발의 중요한 요소인 테스팅은 Espresso, Firebase Device Farm 및 에뮬레이터 설정을 통해 다양한 시각에서 다뤄졌습니다. 로컬 테스트부터 클라우드 기반 솔루션까지, 개발자들은 다양한 도구를 활용하여 앱이 다양한 환경에서 완벽하게 작동하도록 보장할 수 있습니다. 특정 구성을 위해 Espresso 테스트를 실행하거나 Firebase를 활용하여 포괄적인 장치 커버리지를 제공하거나 로컬 및 CI/CD 파이프라인 테스트를 위해 에뮬레이터 설정을 스크립팅하는 것과 같이, 선택 가능한 옵션이 풍부합니다.\n\n이 조사를 마치면 다양성 수용이 성공에 중요하다는 것이 명확해집니다. 다양한 형태 요소의 미묘한 점을 이해하고 전형적인 실수를 피하며 여분의 전술을 추가함으로써, 개발자들은 제약을 뛰어넘는 응용프로그램을 만들 수 있습니다. 창의성에 경계가 없는 세계에서, 점진적인 개발자들은 포괄적이고 유연한 디지털 경험을 만들기 위한 헌신으로 구별됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 기사가 개발자들에게 나침반 역할을 하여 다중 화면 애플리케이션의 개발과 테스트의 복잡성을 탐험하고, 현재의 요구 사항을 충족시키는 데만 그치지 않고 미래 기술의 돌파구에도 견고한 프로그램을 만드는 데 영감을 주길 바랍니다. 우리는 어느 날 고객들이 어디서나 그들만의 세계를 탭하고 스와이프하며 펼쳐질 수 있는 시대를 기대하고 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold_0.png"},"coverImage":"/assets/img/2024-06-19-PixelPerfectDesigningforEveryScreenEveryFold_0.png","tag":["Tech"],"readingTime":16},{"title":"피그마로부터 코틀린 Compose를 위한 자동 거의 자원 생성","description":"","date":"2024-06-19 13:44","slug":"2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose","content":"\n![image](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png)\n\n자동화에 대해 이야기해보겠습니다. 루틴적이고 시간이 많이 소요되는 프로세스를 자동화해야 할 때가 많습니다. 이전 프로젝트에서는 클라이언트를 위한 다양한 UI 사용자 정의가 포함된 단일 코드베이스 기반의 화이트 레이블 솔루션을 갖고 있었습니다. 이 게시물에서는 디자이너의 변경 사항을 찾는 데 추가 시간을 낭비하지 않고 즉시 코드 작성을 시작하는 데 도움이 된 다양한 접근 방식과 도구에 대해 이야기하겠습니다.\n\n# FIGMA/WHATEVER DSM\n\n기초부터 시작해보겠습니다. 디자이너들도 DRY 원칙을 따르기 위해 노력하며 Design System Manager와 같은 훌륭한 도구를 개발합니다. 먼저, 프로젝트에서 반복될 수 있는 구성요소를 식별하고 색상 및 스타일의 구조화된 세트를 개발합니다. 따라서 한 곳에서 색상이나 스타일이 변경되면 전체 프로젝트에서 자동으로 변경됩니다. 편리하죠? Figma나 다른 도구를 사용하여 이러한 구성을 특별한 파일로 내보낼 수 있으며, 그 파일을 분석하여 이를 기반으로 코드를 생성할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJetpack Compose을 사용하면 ColorScheme과 TextStyle과 같은 클래스를 알 수 있을 것입니다. Material 철학에 따라, 우리는 ColorScheme을 사용하여 색상을 설명하고 TextStyle을 사용하여 텍스트의 모양을 설명합니다. 이는 컴포넌트가 렌더링하는 데 사용되는 것입니다.\n\n# 코드 생성\n\nRoom, Dagger2와 같은 라이브러리를 사용해 본 적이 있다면, 이미 익숙한 개념일 수 있습니다.\n\nJava에서는 이 개념을 주석 처리(annotation processing)이라고 하며, Kotlin에서는 kapt 또는 ksp로 참조됩니다. 본질적으로 코드를 분석하고 추가 파일을 생성하는 컴파일러 기능입니다. 그러나 JSON 파일에 주석을 첨부할 수 없고 Kotlin 파일이 아니기 때문에, 여기에는 다른 해결책이 필요합니다. 따라서, 입력 데이터를 가져와 필요한 파일을 찾아 필요한 클래스를 생성하는 플러그인을 개발하는 방법을 배울 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# Gradle 플러그인\n\nGradle 플러그인을 만드는 방법은 main 그레이들 파일에 작업을 작성하는 것에서 buildSrc에 코드를 배치하는 것까지 다양합니다. 그러나 저희는 권장 사항을 따라 composite 빌드를 사용할 것입니다. 이 아이디어는 간단합니다: 플러그인은 애플리케이션 코드와 분리되어 유지되고, 그런 다음 모든 것이 결합됩니다. 여기에서 AGP와 함께 이 메커니즘을 사용하는 방법에 대한 많은 예를 찾을 수 있으며, 오랫동안 가지고 있던 질문에 대한 답변을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_1.png)\n\n여기에 특별한 것은 없습니다. 차이는 플러그인이 가장 높은 수준에서 어떻게 연결되는지에 있습니다. includeBuild()를 사용하여 연결합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n당신의 플러그인 프로젝트의 build.gradle.kts 파일에서, 플러그인이 제대로 작동하기 위해 필요한 종속성 및 기본 구성을 명시해야 합니다. 다음은 플러그인을 위한 예시 설정입니다:\n\n# Gradle 플러그인 구현\n\n젯팩 콤포즈에 대한 Figma 파일 생성을 자동화하기 위한 목표를 달성하기 위해, Gradle 플러그인을 사용하여 다음 단계를 따라야 합니다:\n\n- DSM 토큰의 구조를 분석하고 해당 모델을 준비합니다.\n- 프로젝트에 각 클라이언트 디자인을 설명하는 토큰을 포함하는 모든 가능한 플레이버를 찾습니다.\n- 이 데이터를 분석하여 필요한 파일을 생성하는 방법을 학습합니다.\n- 이를 편리하게 만들고 Gradle 작업에 포장합니다.\n- ...\n- 코드를 작성하세요!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n파일에는 색상 설명이 포함되어 있습니다. 이 설명은 여러 논리적 수준으로 구성될 수 있으며, 마지막 수준에는 우리가 관심을 가지는 정보가 포함되어 있습니다. 일반적으로 리소스는 유사한 구조를 가지며, 타입과 값이 명시됩니다.\n\n```js\n{\n  \"color\": {\n    \"m3\": {\n      \"white\": {\n        \"description\": \"\",\n        \"type\": \"color\",\n        \"value\": \"#ffffffff\",\n        \"blendMode\": \"normal\"\n      },\n      \"black\": {...},\n      \"sys\": {\n        \"light\": {...},\n        \"dark\": {...}\n      },\n      \"ref\": {...},\n      \"key-colors\": {...},\n      \"source\": {...},\n      \"surfaces\": {...},\n      \"state-layers\": {...}\n    }\n  },\n  \"font\": {...},\n  \"typography\": {...}\n}\n```\n\n색상에 대해서는 해당 값을 관심 있게 살펴보고 있으며, 해당 클래스에는 해당 색상의 16진수 표현이 포함됩니다.\n\n# Gradle 작업\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n작업 등록 중에는 주석으로 표시된 모든 필드를 설정해야 합니다. 즉, JSON 파일의 경로, 플레이버 폴더의 경로 및 생성된 파일의 최종 패키지입니다.\n\n우리의 삶을 편하게 하기 위해 몇 가지를 하드코딩할 것이지만, 더 많은 유연성이 필요한 경우 gradle 확장 기능을 살펴볼 가치가 있습니다.\n\n이 작업은 추상적이므로 일부 구성은 구현에 맡겨둡니다. 따라서 색상 파일을 생성할 작업의 구조는 다음과 같이 보일 것입니다.\n우리의 작업을 실행할 수 있게 하려면 프로젝트에 등록해야 합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우선 플러그인을 사용하여 프로젝트에 존재하는 빌드 변형을 결정하고 각 유형에 대한 작업을 등록해야 합니다.\n\n이제 가장 흥미로운 부분으로 넘어가 봅시다. 파일 생성이 실제로 어떻게 일어나는지요.\n\n이를 위해 KotlinPoet라는 도구를 사용해야 합니다. 이 도구를 사용하면 필요한 파일을 쉽게 생성할 수 있습니다. 이 전체 매커니즘은 다양한 빌더로 구성되어 있으며, 여기에 파일 유형, 속성, 값 등을 추가합니다.\n\n우리의 작업 핵심은 JSON 구문 분석, 필요한 데이터 획득 및 해당 파일에 쓰는 데 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJSON 파일의 구조를 알고 있기 때문에 데이터를 수집하는 함수를 작성할 수 있어요. 결과적으로 필드 이름을 키로, 모델을 값으로 하는 맵이 만들어질 거예요.\n\n모든 필드의 목록을 갖게 되면, KotlinPoet을 사용하여 파일에 생성하고 싶은 내용을 설명할 수 있어요. 그 결과, 다음과 같은 모습의 파일을 얻게 될 거예요:\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_2.png)\n\n![이미지](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n생성된 파일을 사용하여 테마를 설명할 수 있습니다.\n\n![Image 4](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_4.png)\n\n![Image 5](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_5.png)\n\n![Image 6](/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그게 다야! 우리의 초기 작업은 완료되었습니다. 이제 파일을 프로젝트에 업로드하고 작업을 실행하여 개발에 사용할 수 있는 파일을 얻을 수 있습니다. 이전에는 수동으로 수행되어 인간 요인으로 인한 오류가 포함될 수 있었지만, 이제는 원활하게 작동하며 추가 종속성이 필요하지 않습니다(Android와 iOS 솔루션은 기존의 Node.js 모듈을 설치하여 작업을 수행하지 못했으며 여전히 개발자 개입이 필요했습니다).\n\n# 명백하지 않은 도전 과제\n\n플러그인 개발은 문제 해결의 절반입니다. 언제나 문제가 발생할 수 있습니다:\n\n- 프로젝트 복잡성으로 인해 디자이너들은 Material Design을 제대로 사용하지 않고 수십, 아니 수백 개의 사용자 정의된 이름을 가진 색상과 스타일을 만들었습니다. 이로 인해 표준 MaterialTheme을 사용할 수 없었고, 결과적으로 우리 플러그인은 사용자 정의 ColorScheme과 Typography 클래스를 생성했습니다.\n- 초기 개발 및 이전 이관에 상당한 시간이 소요되었지만, Material 설정이 깨끗하고 디자이너와의 토큰 이름 문제를 해결하는 데 몇 시간을 보낼 필요가 없다면 이것은 문제가 되지 않습니다.\n- @Preview 주석은 모두 우리 사용자 정의 테마로 래핑되어야 합니다.\n- 디자인 자체가 문제일 수 있습니다. 고객 중 한 명은 그라데이션을 가진 버튼을 가졌는데, 이 토큰에는 색상을 사용해야 했습니다. 이 문제는 임시 해결 방법으로 우아하게 해결되었지만, 미래에 이러한 충돌이 발생하지 않도록 디자이너에게 강력히 당부했습니다.\n- 구성 복잡성 - 과정 자체는 간단하지만, 이전 문제와 같은 문제는 플러그인의 논리나 모델 구조를 크게 변경해야 할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그거면 끝이에요. 비슷한 솔루션을 만들어 본 경험이 있거나 미리보기를 위해 매번 사용자 정의 테마를 작성하는 것을 피하는 방법을 아시는 분들은 댓글에서 공유해 주세요. 코드가 필요한 경우 전체 프로젝트는 여기에서 확인할 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png"},"coverImage":"/assets/img/2024-06-19-AutomaticalmostresourcegenerationfromFigmaforCompose_0.png","tag":["Tech"],"readingTime":8},{"title":"Jetpack Compose 안드로이드에서 사용자 지정 PDF 뷰어 만들기","description":"","date":"2024-06-19 13:43","slug":"2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid","content":"\n![PDFViewer](/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png)\n\nPDF는 우리가 매일 사용하는 가장 일반적인 파일 형식 중 하나입니다. 그러나 Jetpack Compose에서 공식 PDF 뷰어가 아직 없습니다. 그렇다면 왜 만들지 않을까요?\n\n## 어떻게 가능한가요?\n\n우리의 계획 개요를 살펴봅시다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- PDF 파일이 있는 원격 URL 또는 전화 저장소가 있습니다.\n- 하나씩 페이지를 보여줄 수 있습니다.\n- 페이지는 확대 및 이동할 수 있어야 합니다.\n- 서버 PDF를 로컬 캐시/저장소에 다운로드하고 저장해야 합니다.\n- PDF를 '페이지'를 나타내는 '비트맵' 목록으로 변환할 수 있습니다.\n- 그런 다음 간단히, 비트맵을 지원하는 이미지 컴포저블을 사용하여 세로로 페이지를 하나씩 모두 표시할 것입니다.\n\n## 단계 1: PDF 다운로드 및 저장\n\n이 시점에서 PDF의 URL만 있습니다. 이를 다운로드하는 기능을 만들어 보겠습니다.\n\n먼저 AndroidManifest.xml에 다음 권한을 추가하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```java\n<uses-permission android:name=\"android.permission.INTERNET\" />\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n```\n\n우리는 HttpURLConnection 객체를 사용하여 연결을 설정하고 InputStream을 가져올 것입니다.\n\n```java\nval connection = URL(url).openConnection() as HttpURLConnection\nconnection.connect()\n```\n\n위의 코드들이 작동하여 PDF 파일을 가져올 것입니다. 작업이 완료되었고 필요한 Input stream을 얻었는지 확인해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nif (connection.responseCode != HttpURLConnection.HTTP_OK) {\n    connection.disconnect()\n    return@withContext null\n}\n\nval inputStream = connection.inputStream\n```\n\n작업이 끝나면 꼭 연결을 끊어 주세요.\n\n```kotlin\nconnection.disconnect()\n```\n\n이제 다운로드 부분이 완료되었으니 사용자의 로컬 스토리지에 저장해주세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nfile = File.createTempFile(fileName, \".pdf\")\nval outputStream = FileOutputStream(file)\ninputStream.copyTo(outputStream)\noutputStream.close()\n```\n\n변경 후 전체 함수는 다음과 같습니다:\n\n```kotlin\nsuspend fun downloadAndGetFile(url: String, fileName: String): File? {\n    if (isFileExist(fileName)) return File(fileName) // 이 줄은 중복 파일 생성을 피하기 위해 중요합니다.\n    var connection: HttpURLConnection? = null\n    var file: File? = null\n    try {\n        withContext(Dispatchers.IO) {\n            connection = URL(url).openConnection() as HttpURLConnection\n            connection!!.connect()\n\n            if (connection!!.responseCode != HttpURLConnection.HTTP_OK) {\n                return@withContext null\n            }\n\n            val inputStream = connection!!.inputStream\n            file = File.createTempFile(fileName, \".pdf\")\n            val outputStream = FileOutputStream(file)\n            inputStream.copyTo(outputStream)\n            outputStream.close()\n        }\n    } catch (e: IOException) {\n        // UI에 응답을 전송합니다.\n    } finally {\n        connection?.disconnect()\n    }\n    return file\n}\n```\n\n```kotlin\nfun isFileExist(path: String): Boolean {\n    val file = File(path)\n    return file.exists()\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 2: 파일 객체를 List`Bitmap`으로 변환합니다.\n\n이 변환에는 PdfRenderer 클래스를 사용할 것입니다:\n\n```js\nPdfRenderer renderer = new PdfRenderer(ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY));\n```\n\n하지만 이것을 직접 사용하는 것은 Jetpack Compose에서 좋지 않고 많은 RAM을 소비할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그럼 다음과 같이 사용할 것입니다:\n\n```js\nval rendererScope = rememberCoroutineScope()\nval mutex = remember { Mutex() }\nval renderer by produceState<PdfRenderer?>(null, file) {\n    rendererScope.launch(Dispatchers.IO) {\n        val input = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY)\n        value = PdfRenderer(input)\n    }\n    awaitDispose {\n        val currentRenderer = value\n        rendererScope.launch(Dispatchers.IO) {\n            mutex.withLock {\n                currentRenderer?.close()\n            }\n        }\n    }\n}\n```\n\n이제 우리가 만든 \"PDFRenderer\" 객체인 \"renderer\"를 사용하여 모든 페이지를 가져와 비트맵 객체에 렌더링할 것입니다.\n\n```js\nrenderer?.let {\n    it.openPage(index).use { page ->\n        page.render(destinationBitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 모든 페이지에 대한 비트맵을 가져올 수 있습니다. UI에서 모든 페이지에 표시할 시간입니다.\n\n## 단계 3: UI에 목록`비트맵` 표시 + 줌 및 이동 기능 추가:\n\nPDFViewer Composable의 전체 코드가 필요하면 이를 참조하십시오:\n\n여기서 설명이 시작됩니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- BoxWithConstraints를 사용하는 이유는 페이지의 높이와 너비를 정의하고 줌 및 이동을 위해 화면의 높이와 너비가 필요하기 때문입니다.\n\n```js\n            val width = with(LocalDensity.current) { maxWidth.toPx() }.toInt()\n            val height = (width * sqrt(2f)).toInt()\n            val pageCount by remember(renderer) { derivedStateOf { renderer?.pageCount ?: 0 } }//Used ahead\n\n            var scale by rememberSaveable {\n                mutableFloatStateOf(1f)\n            }\n            var offset by remember {\n                mutableStateOf(Offset.Zero)\n            }\n            val state = //Used for Zoom and Move\n                rememberTransformableState { zoomChange, panChange, rotationChange ->\n                    scale = (scale * zoomChange).coerceIn(1f, 5f)\n\n                    val extraWidth = (scale - 1) * constraints.maxWidth\n                    val extraHeight = (scale - 1) * constraints.maxHeight\n\n                    val maxX = extraWidth / 2\n                    val maxY = extraHeight / 2\n\n                    offset = Offset(\n                        x = (offset.x + scale * panChange.x).coerceIn(-maxX, maxX),\n                        y = (offset.y + scale * panChange.y).coerceIn(-maxY, maxY),\n                    )\n                }\n```\n\nZoom 구현을 자세히 이해하려면 이 비디오를 시청하세요.\n\n2. 이 상태를 LazyColumn과 함께 간단히 사용하고 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n            LazyColumn(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .graphicsLayer {\n                        scaleX = scale\n                        scaleY = scale\n                        translationX = offset.x\n                        translationX = offset.y\n                    }\n                    .transformable(state)\n```\n\n3. 호출할 때 이미 PDF 파일을 다운로드하고 저장했습니다.\n\n```kotlin\nLaunchedEffect(key1 = Unit) {\n        file = async { downloadAndGetFile(url, fileName) }.await()\n    }\n```\n\n4. \"cacheKey\"로부터 Bitmap 객체를 만들어야 합니다. 이미지도 캐시에 저장될 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval cacheKey = MemoryCache.Key(\"${file!!.name}-$index\")\nval cacheValue: Bitmap? = imageLoader.memoryCache?.get(cacheKey)?.bitmap\nvar bitmap: Bitmap? by remember { mutableStateOf(cacheValue) }\n```\n\n5. 이후에는 각 페이지의 비트맵을 가져와 Coil ImageRequest 객체로 표시합니다.\n\n```kotlin\nval request = ImageRequest.Builder(context)\n    .size(width, height)\n    .memoryCacheKey(cacheKey)\n    .data(bitmap)\n    .build()\n\nImage(\n    modifier = Modifier\n        .background(Color.Transparent)\n        .border(1.dp, MaterialTheme.colors.background)\n//        .aspectRatio(1f / sqrt(2f))\n        .fillMaxSize(),\n    contentScale = ContentScale.Fit,\n    painter = rememberAsyncImagePainter(request),\n    contentDescription = \"Page ${index + 1} of $pageCount\"\n)\n```\n\n나머지 부분은 상당히 직관적이고 이해하기 쉽습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 새로운 것을 배웠다면, 좋다면 팔로우 버튼을 눌러 주세요.\n","ogImage":{"url":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png"},"coverImage":"/assets/img/2024-06-19-CreatingCustomPDFViewerinJetpackComposeAndroid_0.png","tag":["Tech"],"readingTime":10}],"page":"32","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}