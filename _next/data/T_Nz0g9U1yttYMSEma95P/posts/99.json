{"pageProps":{"posts":[{"title":"스위프트 플레이그라운드에서 머신 러닝 모델을 사용하는 방법","description":"","date":"2024-05-18 17:20","slug":"2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds","content":"\n<img src=\"/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png\" />\n\n많은 사람들처럼, 올해의 Swift Student Challenge 아이디어를 개발하면서 내가 많은 시간을 쏟으면서 내 인내심을 시험받는 여러 가지 장애물을 만났어. 그래서, 몇 밤을 잠 못 이루게 한 문제에 대한 해결책을 공유하고 싶어: Swift Playgrounds에서 CoreML을 구현하는 방법.\n\n앱이 SSC에 참가하기 위한 요구 사항 중 하나는 Swift Playground여야 한다는 것을 아실 것입니다. 그러나 이러한 종류의 프로젝트는 장단점을 갖고 있어. Swift Playground는 Apple이 만든 대화형 개발 환경으로, 개발자와 프로그래밍 학습자들이 빠르고 쉽게 Swift 코드를 작성, 테스트, 시각화할 수 있게 해줘. Swift Playgrounds는 macOS용 Apple의 종합 개발 스위트인 Xcode와 iPad용 독립형 앱으로 모두 사용할 수 있어. 이 환경은 프로그래밍을 배우거나 Swift로 새로운 아이디어나 알고리즘을 실험하는 데 특히 유용해.\n\n반면에 Core ML (Core Machine Learning)은 Apple이 개발한 프레임워크로, iOS, macOS, watchOS 및 tvOS 앱에 머신 러닝 모델을 통합할 수 있게 해줘. Core ML을 사용하면 개발자들은 사전 훈련된 머신 러닝 모델을 활용하여 이미지 인식, 자연어 처리, 데이터 분석 등의 작업을 인터넷 연결 없이 효율적이고 실시간으로 수행할 수 있어.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 표준 Swift 프로젝트에서 Core ML을 사용하는 것은 매우 간단합니다. 우리 모델을 프로젝트에 추가하기만 하면 앱에서 사용할 수 있습니다. 그러나 이 글을 작성하는 시점에서 Swift Playground에서의 사용은 조금 복잡합니다. 후자의 형식에서는 앱에서 모델을 사용하려면 해당 모델이 앱에 의해 사용되도록 설정해야 하는 일련의 단계를 따라야 합니다. 이는 잘 문서화되어 있고 웹의 다양한 위치에서 찾을 수 있습니다. 그럼에도 불구하고, Xcode 15가 출시되면서 사용자들 사이에 널리 알려지지 않은 마지막 단계가 있습니다.\n\n## 첫 번째 단계: 파일 가져오기\n\nSwift Playgrounds 프로젝트에서 ML 모델을 사용하려면, 모델의 .mlmodel 파일을 추가할 임시 Swift 프로젝트를 먼저 준비해야 합니다. 이 프로젝트를 컴파일함으로써 두 가지를 달성할 수 있습니다: 해당 프로젝트의 클래스 파일과 컴파일된 모델 얻기. 이 두 가지는 Playground를 통해서는 불가능하기 때문에, 많은 사람들이 첫 시도에서 CoreML 모델을 성공적으로 구현하지 못한 것일 수 있습니다.\n\n첫 번째 단계에서는, 단순히 임시 앱을 빌드하고, Xcode 파일 탐색기에서 .mlmodel 파일을 클릭한 다음 Model Class 옆에 우리 CoreML 모델의 이름을 클릭하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ML model class file](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_1.png)\n\nThis will take you to the class file of our CoreML model, which acts as the interface between the model and our app. It allows us to provide information and receive a processed response from it.\n\n![Show in Finder](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_2.png)\n\nWhile completing the remaining steps, we need to create a copy of this file and save it in another folder. Right-click on the file, choose \"Show in Finder,\" and create a duplicate.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![ML model in Swift Playgrounds](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_3.png)\n\n![ML model in Swift Playgrounds](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_4.png)\n\n다음 단계는 CoreML 모델의 컴파일된 버전을 획득하는 것입니다. 이를 위해 먼저 응용 프로그램의 컴파일된 파일, 빌드에 액세스해야 합니다. 이를 찾으려면 Finder를 열고 명령 ⌘ + Shift + G를 사용하세요. 그런 다음 다음 경로로 이동하세요:\n\n~/Library/Developer/Xcode/DerivedData\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 디렉터리 내에서 임시 앱 이름으로된 폴더를 찾아 들어가야 해요.\n\n![Folder 5](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_5.png)\n\n폴더 안으로 들어가서 Build/Products/Debug-iphonesimulator로 이동해주세요.\n\n![Folder 6](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_6.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![그림1](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_7.png)\n\n![그림2](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_8.png)\n\n여기서 우리는 임시 앱 이름으로 된 파일을 찾을 수 있습니다. 이 파일에 마우스 오른쪽 버튼을 클릭하고 \"Package Contents 표시\"를 선택합니다.\n\n![그림3](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_9.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 우리가 원하던 것을 찾을 수 있습니다: 컴파일된 ML 모델, .mlmodelc 파일(c는 컴파일된 형태를 의미합니다). 클래스 파일과 마찬가지로 이 파일의 사본을 만들어 쉽게 접근할 수 있는 위치에 저장하세요.\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_10.png)\n\n이 두 파일을 가지고 있다면, 모델을 변경하거나 업데이트할 일이 없는 한 임시 앱에 대해서 잊을 수 있습니다. 모델을 변경하려면 이전 단계를 반복해야 합니다. 이제 우리는 플레이그라운드 프로젝트로 넘어가 마지막 단계를 수행하겠습니다.\n\n## 두 번째 단계: 플레이그라운드 설정하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 프로젝트를 구하는 데 도움이 된 단계로 넘어갑시다. 모델을 사용하려면 플레이그라운드를 마무리하려면 몇 가지 최종 조정이 필요합니다. 먼저, 클래스 파일을 프로젝트 내에 배치하십시오. 추가로, ML 모델을 넣을 폴더를 만들고 다른 것은 아무것도 넣지 마십시오. 저는 편의상 MLFile이라는 이름을 붙였습니다.\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_11.png)\n\n이제 Xcode를 닫고 Finder에서 프로젝트 위치로 이동해야 합니다. 파일에서 마우스 오른쪽 버튼을 클릭하고 \"패키지 내용 보기\"를 선택하십시오.\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_12.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이것은 Playgrounds 프로젝트의 내용을 보여줄 것입니다. 그 안에서 Package.swift 파일을 찾아 열어봅니다.\n\n![Package.swift 파일](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_13.png)\n\n이 파일 안에는 프로젝트 구성 정보가 있습니다.\n\n![프로젝트 구성](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\ntargets 섹션 내에서 .executableTarget() 메서드로 이동하여 아래 내용을 매개변수로 추가해주세요:\n\n```js\nresources: [\n                .process(\"Resources\"),\n                .copy(\"<ModelFolderName>/<YourModelName>.mlmodelc\")\n            ]\n```\n\n저의 프로젝트에서는 다음과 같이 나타날 겁니다:\n\n![이미지](/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_15.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 이제 모두 준비되었습니다!\n\n좋아요! 이제 Swift Playground App 프로젝트 내에서 우리의 ML 모델을 사용할 수 있게 되었습니다. 이 변경이 필요한 이유는 Playground가 일반 프로젝트와 다르게 작동하기 때문입니다. 우리가 리소스를 사용할 때 Playground는 프로젝트의 구조를 무시하고, 만들어 둔 폴더 구조를 존중하는 대신에 포함된 파일을 추출하여 모두 한데 모읍니다. 이는 동일한 이름의 파일이 다른 폴더에 있더라도 컴파일 중 충돌을 일으킬 수 있다는 것을 의미합니다. 이는 우리의 Swift Package 내 .process() 메서드의 덕분입니다. .copy()를 구현함으로써, 우리가 지정한 폴더나 파일에 대해 폴더 구조가 존중되도록 보장합니다.\n\n이제 우리 프로젝트가 요구하는 CoreML 구현을 계속하면 됩니다. 이 해결책이 여러분께 몇 시간의 불면의 밤을 덜어주고 프로젝트를 더 나은 수준으로 이끌 수 있기를 바랍니다. 행운을 빕니다!\n\n도움이 필요하거나 중간에 질문이 생기면 언제든지 연락해 주세요!\n","ogImage":{"url":"/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png"},"coverImage":"/assets/img/2024-05-18-HowtouseaMLmodelinSwiftPlaygrounds_0.png","tag":["Tech"],"readingTime":8},{"title":"네이티브 iOS 느낌을 Compose Multiplatform 앱에서 가져오기","description":"","date":"2024-05-18 17:18","slug":"2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp","content":"\nCompose의 기본 모양과 느낌은 Material Design입니다. Compose Multiplatform에서는 일부 요소를 iOS에서 더 네이티브하게 느끼도록 조정했습니다. 예를 들어, 버전 1.5부터 iOS의 스크롤 효과를 해당 플랫폼의 것과 유사하도록 만들었습니다. 그러나 대부분의 UI 요소는 여전히 Material처럼 보입니다. 앱에서 iOS 네이티브 룩 앤 필을 더 얻는 쉬운 방법을 살펴보겠습니다.\n\n![image](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png)\n\n우리는 Compose Cupertino라는 라이브러리를 사용할 것입니다. 이 라이브러리는 여러 가지 버전으로 제공됩니다:\n\n- cupertino: Compose를 사용하여 iOS와 유사한 위젯을 구축했습니다;\n- cupertino-native: 네이티브 UIKit 구성 요소 주변의 래퍼;\n- cupertino-adaptive: 안드로이드에서 Material Design을 사용하는 적응형 테마/래퍼 및 iOS의 cupertino와 cupertino-native의 일부 위젯을 사용합니다 (이 글의 주된 내용);\n- cupertino-icons-extended: 가장 많이 사용되는 Apple SF Symbols 800개 이상(참고: 이들은 저작권이 있으며 라이센스 계약을 준수해야 합니다);\n- cupertino-decompose: 화면 전환 및 스와이프 동작의 네이티브 느낌.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글에서는 얼마나 쉽게 Adaptive 플레이버를 사용하여 앱의 시스템 바(상단바 + 내비게이션/탭바) 및 주요 구성 요소(버튼 + 로딩 인디케이터 + 대화상자)를 개선할 수 있는지 살펴볼 것입니다. 라이브러리에는 더 많은 기능이 있으므로 이 글은 그에 대한 소개이고 완벽한 안내서는 아닙니다. 또한 Android에서 iOS 모습을 테스트하는 방법도 알아볼 것입니다!\n\n# 작동 원리는 무엇인가요?\n\nCupertino의 네이티브 룩을 가진 위젯은 Compose를 사용하여 완전히 재구성된 iOS 구성 요소입니다. 이것은 실제 네이티브 컴포넌트가 아니라 그 모습을 그대로 보이도록 그려진 것이라는 것을 의미합니다. 그 점에 대해 우리는 걱정할 필요가 있을까요? 나는 그렇지 않다고 생각합니다. 왜냐하면 이것은 Compose 자체가 안드로이드 컴포넌트를 재구성하는 방식과 비슷하기 때문입니다. 이들은 레거시 android.view 컴포넌트에 의존하는 대신 캔버스에 그려집니다.\n\nCupertino Adaptive는 Material 컴포넌트뿐만 아니라 그들의 API를 염두에 두고 만들어졌습니다. 즉, 현재 사용 중인 많은 Material 컴포넌트를 Adaptive 대체품으로 사용 가능합니다. 단 몇 초 내에 교체할 수 있습니다. Android에서는 여전히 동일한 기본 코드를 호출하지만, iOS에서는 네이티브 컴포넌트처럼 보이게 그려집니다. 예외는 AdaptiveAlertDialogNative와 같이 \\*Native로 끝나는 적응형 위젯입니다. 그것은 대화 상자를 위한 실제 UIKit 컴포넌트를 호출하는 Cupertino Native 래퍼를 호출합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n함께 해보겠습니다! 모든 코드는 https://github.com/jacobras/ComposeCupertinoSample 에서 확인할 수 있습니다.\n\n# 튜토리얼: Material을 Cupertino으로 적응하게 만들기\n\n이번에 사용할 샘플 프로젝트는 Kotlin Multiplatform Wizard로 생성되었습니다. 툴바, 두 개의 탭, 로딩 표시기, 그리고 대화상자를 포함한 Material3 구성 요소가 구현되어 있습니다. 시작 지점 코드베이스는 여기에서 확인할 수 있습니다: ComposeCupertinoSample/tree/starting-point.\n\n## 1: 의존성 추가하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리는 버전 카탈로그에 의존성을 추가하고 앱에서 구현했어요:\n\n```js\n// gradle/libs.versions.toml 파일:\ncupertino = { module = \"io.github.alexzhirkevich:cupertino-adaptive\", version = \"0.1.0-alpha03\" }\n\n// composeApp/build.gradle.kts 파일의 common.dependencies 안에:\nimplementation(libs.cupertino)\n```\n\n전체 커밋 내역: ComposeCupertinoSample/pull/2/commits/d7b05ad809bc03cf87c3c58a6f7765f5c6442b92\n\n## 2: 테마 업데이트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAppTheme은 현재 MaterialTheme을 사용합니다. 이것을 adaptive theme을 사용하도록 변경해야 합니다. material과 cupertino라는 두 가지 중요한 매개변수가 있습니다. material은 현재 MaterialTheme을 취하고, cupertino은 CupertinoTheme을 취합니다. 후자는 darkColorScheme() 또는 lightColorScheme()에 사용자 정의 색상을 전달하여 iOS 외관을 사용자 정의할 수 있습니다.\n\n```js\n// 변경 전\n@Composable\nfun AppTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    MaterialTheme(\n        colorScheme = if (useDarkTheme) {\n            darkColorScheme()\n        } else {\n          lightColorScheme()\n        },\n        content = content\n    )\n}\n\n// 변경 후\n@OptIn(ExperimentalAdaptiveApi::class)\n@Composable\nfun AppTheme(\n    useDarkTheme: Boolean = isSystemInDarkTheme(),\n    theme: Theme = determineTheme(),\n    content: @Composable () -> Unit\n) {\n    AdaptiveTheme(\n        material = {\n            MaterialTheme(\n                colorScheme = if (useDarkTheme) {\n                    androidx.compose.material3.darkColorScheme()\n                } else {\n                    androidx.compose.material3.lightColorScheme()\n                },\n                content = it\n            )\n        },\n        cupertino = {\n            CupertinoTheme(\n                colorScheme = if (useDarkTheme) {\n                    darkColorScheme()\n                } else {\n                    lightColorScheme()\n                },\n                content = it\n            )\n\n        },\n        target = theme,\n        content = content\n    )\n}\n```\n\ndetermineTheme() 메서드는 [androidMain]에서 Theme.Material을 반환하고 [iosMain]에서 Theme.Cupertino를 반환하는 expect/actual 함수입니다. 자세한 내용은 전체 커밋을 참조하세요: ComposeCupertinoSample/pull/2/commits/592b3e2a1d35ff8a9961dbc6739e0e25bf581b95\n\n지금 앱을 실행하면 아직 아무것도 변경되지 않습니다. 모든 것이 이전과 똑같이 보입니다. 왜냐하면 아직 적응형 컴포넌트를 사용하지 않았기 때문입니다. 이는 안드로이드에서는 모든 것이 변하지 않음을 보여줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 3: 적응형 구성요소 사용하기\n\n이제 재미있는 부분이 시작됩니다! 이것은 또한 가장 쉬운 변경입니다. 모든 자료 구성요소를 찾아서 적응형 래퍼로 대체합니다. 예를 들어요:\n\n```js\n// Before\nButton(onClick = { showContent = !showContent }) {\n    Text(\"Click me!\")\n}\n\n// After\nAdaptiveButton(onClick = { showContent = !showContent }) {\n    Text(\"Click me!\")\n}\n```\n\n다른 구성요소들도 이와 같이 변경할 예정입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_1.png)\n\n패턴은 명확해야 합니다: iOS 스타일 컴포넌트에는 Cupertino[ComponentName]을 사용하고, 플랫폼에 따라 변경되는 컴포넌트에는 Adaptive[ComponentName]을 사용해야 합니다. 이 튜토리얼에서는 모두 Adaptive 컴포넌트만 사용할 것입니다.\n\n대부분은 매개변수를 변경하지 않고 이름만 변경하면 됩니다. AlertDialog은 text를 title로, confirmButton을 buttons로 변경해야 하는 예외입니다.\n\n전체 커밋: ComposeCupertinoSample/pull/2/commits/a8da43dd7db1187df15c0fbbca9af3ef705c64bd\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n앱을 iOS에서 다시 실행하면 변경 사항 이전을 보여주는 좌측 시뮬레이터와 변경 후를 보여주는 우측 시뮬레이터가 표시됩니다:\n\n![이미지1](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_2.png)\n\n정말 멋지게 보이네요! 다크 테마도 두 플랫폼에서 작동합니다:\n\n![이미지2](/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 안드로이드에서의 테스트\n\n안드로이드에서 쿠퍼티노 스타일을 테스트하려면 Android 소스 세트의 determineTheme() 메서드만 변경하면 됩니다:\n\n```js\nactual fun determineTheme(): Theme = Theme.Material3\n```\n\n# 추가 단계 및 독서\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요즘 이렇게 쉽고 영향력이 큰 작업이었는지 알겠죠. 더 할 수 있는 일이 있습니다. 아이폰/아이패드에서 iOS 아이콘을 사용하거나 더 많은 네이티브 모양의 구성 요소를 사용하는 것 등이 가능하지만, 결정은 여러분에게 달려 있습니다. 제가 제공한 것은 라이브러리를 시작하는 짧은 소개였죠.\n\n- GitHub: Compose Cupertino\n- GitHub: Compose Cupertino 샘플 앱\n","ogImage":{"url":"/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png"},"coverImage":"/assets/img/2024-05-18-GettingthenativeiOSlookfeelinyourComposeMultiplatformapp_0.png","tag":["Tech"],"readingTime":9},{"title":"Apple의 생태계  사랑하지만이 5가지 이유 때문에 화가 나요","description":"","date":"2024-05-18 17:16","slug":"2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD","content":"\n![이미지](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png)\n\n내가 글을 쓸 때마다, 어떤 순간에라도, Apple의 생태계란 구문이 끼어들게 돼요.\n\n진짜 그 유혹에 맞섰다가도 다른 표현 방법이 떠오르지 않아요.\n\nApple은 우리 주변에 조용하게 그리고 매끄럽게 이 벽이 있는 정원을 쌓아 올렸어요. 우리가 알아채지 못하게. 틀림없이, 이것은 우리가 계속해서 Apple의 최신 제품을 사도록 매료하게 만드는 일부분이에요. 전반적으로, 이는 아주 효과적으로 작동해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단한 것조차 iPhone에서 iPhone으로 전환하는 것은 훨씬 쉬워요. 하나를 다른 쪽에 가져가면 거의 끝나요. iCloud는 마치 대가감 있게 모든 것을 감독하고 우리의 Apple 생활을 유지하는 데 필요합니다.\n\nApple 생활에 대해 칭찬하고 사랑할 만한 것이 많이 있어요. 예를 들어, 최근에 시작한 Photos 앱은 얼마나 강력한지 깨닫고 있는 앱이에요. 그것은 보석 같아요.\n\n그래, 우리 사진과 문서가 동기화되고 어디에서나 사용 가능하다는 것에 새로운 점은 없어요. 우리는 그것을 기대하죠. 그러나 Apple 생태계의 미세한 뉘앙스가 더 흥미로운 거예요. 여러 Apple 기기를 소유하는 것이 얼마나 매끄럽게 통합될 수 있는지를 만드는 요소들이에요.\n\n# Apple 생활\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n핸드오프는 가끔 언급하는 주제야 — 진짜 좋아해.\n\n아침 러닝 후에 집에 들어오면 핸드폰을 홈팟 중 하나에 건네면 방금 듣고 있던 앨범이나 팟캐스트가 계속 재생돼! 천재적이지!\n\n![이미지](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_1.png)\n\n유니버설 컨트롤은 여러 대의 맥에서 마우스를 공유하는 것이 정말 편리해. 지금 이 글을 쓰고 있는데 Studio Display 앞에는 16인치 맥북 프로 한 대와 한쪽에는 M2 맥북 에어가 있어 — 하지만 하나의 키보드, 하나의 마우스, 하나의 트랙패드로 모든 것을 제어할 수 있어. 진짜 멋져.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n요즘 나의 블루투스가 하루에 여러 번 무작위로 끊기고 있어서 M1 MacBook Pro에서 유니버설 컨트롤도 끊기는 현상이 발생하고 있어. 스튜디오 환경은 그대로인데 뭔가 이상한 점을 눈치 채신 분들 있을까 궁금해. 나는 Sonoma 14.3.1을 사용 중이야.\n\n하지만 그런 이상한 문제들은 제치고, 애플 제품을 사용하면 정말 대단한 기능을 체험할 수 있어. 매일 모든 것이 완벽하게 작동하는 게 정말 대단한 거지만, 예외가 발생하면 그때는...!\n\n애플 제품들과 함께하는 게 멋지긴 한데 가끔은 골치 아픈 순간들이 있어. 그럴 때는 짜증 나는 건 말할 것도 없고, 오늘은 나만의 일상적인 짜증거리들을 소개하고 싶어. 이 중에서 가장 먼저 소개할 건...\n\n# 시리\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n음 - 아마 거기까지 둘 수도 있겠어요. 우리 모두가 Siri를 사용하는 데 어려움을 겪는 것을 알고 있지만, 적어도 언급하지 않고는 명백한 양심으로 이 이야기를 쓸 수 없을 것 같아요!\n\n저는 오직 Siri만 사용해왔고, 작년에 Pixel 8 Pro를 사용하면서 구글의 음성 어시스턴트 대안을 잠시 체험해 봤었는데, 그 차이에 놀랐습니다.\n\n이론적으로, 깨어나는 명령어가 단순한 Siri로 줄어들었지만, 저에게는 때로는 그렇게 작동하지 않아요. 가장 불안정한 반응은 차 안에서 Apple CarPlay을 사용할 때입니다.\n\n![이미지](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n차 안은 음성 어시스턴트가 아주 유용한 곳이지만 내 경험상 Siri는 차 안에서 최악입니다. 많은 경우에 응답을 받지 못하고 거의 어느 때나 일어나는 명령어를 인식하지 못합니다. 대신 예전의 \"Hey Siri\" 명령어를 사용해야 하고 심지어 CarPlay도 그 명령어를 잡지 못할 때가 있습니다. 대신 전화가 깨어나버립니다!\n\nSiri가 작동할 때 대답이나 응답이 대부분 이상하거나 이상합니다. 그 \"세부 정보를 전화로 보낼 수 있어요\" 멘트를 한 번 더 들으면 진짜 화가 나서 홈팟을 거실 창문으로 던질지도 모릅니다!\n\n솔직히 Siri는 엉망입니다! 우리는 올해 WWDC에서 Apple이 AI에 대한 견해를 공개하면서 Siri를 크게 개선할 것이라는 강력한 소문을 듣고 있습니다. 이번에는 제대로 처리하길 바랍니다.\n\n현재의 Siri는 다소 농담처럼 보입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 지속성 카메라\n\n일단 이것에 대해 명확히 하고 싶은 것이 있어요 — 지속성 카메라 자체로는 정말 멋져요.\n\n아직 사용해보지 않았다면 꼭 사용해보세요! 당신이 가지고 있는 최고의 웹캠은 아마도 당신의 주머니 속에 있는 아이폰 카메라일 거에요 — 그리고 지속성 카메라를 사용하면 이를 맥북이나 아이맥에 연결해서 영상 통화에 아이폰 카메라를 사용할 수 있답니다.\n\n최신 tvOS로 업데이트했다면, 심지어 TV에서 FaceTime 통화에도 사용할 수 있어요 — HD로 자신을 55인치 패널에서 볼 수 있는 용기가 충분하다면 말이에요! 하지만 완벽하게 무선으로 작동하기 때문에 이용이 편리해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_3.png)\n\n그 모든 칭찬을 해도 오늘의 나쁜 목록에 올라간 이유가 무엇인가요?\n\n이것은 좀 사용자별이라고 인정하고 시작하겠습니다. 그러나 매번 Premiere Pro를 열 때마다 iPhone이 사진 입력으로 연결하려고 해서 짜즯네요! 너무 작은 일이라는 걸 알지만, 그저 Premiere를 영원히 잊으라고 말할 방법이 있었으면 좋겠어요. 그냥 프로젝트를 계속하고 싶은데 전화기를 계속 연결을 끊을 필요가 없어야 하는데요 — 어이쿠!\n\n그리고 유사한 일로...\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 자동 전환\n\n다시 말해요 - 멋진 개념이지만 이것과 함께 살아가는 것은 꽤 골치 아파요.\n\n아마 여러 대의 맥을 가지고 계시다면 망상할 것 같아요. 만약 여러 대의 맥을 사용하는 AirPods 사용자라면, 한 대의 맥에서 작업을 하면서 무언가를 듣다가 다른 맥으로 전환하면, AirPods가 엄청 괴로워져요. 갑자기 다른 맥으로 따라오려고 하는 것 같아요 - 이상한 일은, 다른 맥에서 아무것도 재생되고 있지 않은 상태에서도 발생해요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자동 전환은 이론적으로 유용한 기능 중 하나입니다... 어딘가 연구실에서는 그게 세상에서 가장 이치에 맞는 것처럼 보일지도 몰라요. 하지만 현실에서는 조금 다른 일이 일어날 수 있죠.\n\n# 무엇을 두고 왔나요?\n\n다시 한 번, 이런 일은 여러분에게도 일어날 것입니다.\n\n집에 돌아오는 길에 가게에 잠깐 들러 저녁을 사러 가면서 맥북이나 에어팟 맥스를 차 안에 두고 나온 적이 있을 거예요. 그럴 때마다 Apple Watch로 '무언가를 두고 나왔다'는 알림이 오면 마치 무언가를 훔쳐갔다고 생각되어 놀랍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네, Find My 앱에서 알림을 끌 수 있는 건 알고 있어요—하지만 항상 할 생각은 하지만 항상 잊게 돼요.\n\n알림이 너무 많다면—어떻게 생각하세요?\n\n# 침묵의 암살자\n\n그래서—요즘 대부분의 사람들처럼 전화 소리를 끈 상태로 핸드폰을 사용해요. 전화를 많이 받지 않고, 묵상적으로 소리가 없는 상태가 더 평온하다고 느껴지거든요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n내가 전화를 받는 방법은 일반적으로 책상 앞에 놓인 전화로 전화를 보거나 Apple Watch의 진동 팔찌로 전화를 받는 것을 의지합니다.\n\n![Image](/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_5.png)\n\n하지만 여기가 문제예요. 오늘 언급한 이 분규 중 많은 것들과 마찬가지로 이 기능은 때때로만 작동합니다. 그 이유나 근거가 없어 보이죠. 작동할 때는 최고의 방법 중 하나로 호출 알림을 받지만, 내가 이것에 의존할 수 없어요.\n\n또한 시계로 Mac 잠금 해제도 좀 이상해요. 웃기는 건 Mac이 가장 잘 작동하는 것은 제 오래된 2015년형 27인치 iMac이에요. Apple Watch가 작동해야 하는데 새로운 지문 인식 Magic Keyboard를 사는 걸 피하려고 했어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n간단한 문제 해결 방법\n(paren은 괄호)\n\n1. 처음에 내가 지정한 form_tools라는 class를 넣었는데, HTML 태그와 같이 들어가서 CSS가 적용되지 않아서 문의했습니다. 아마도 TagUISetting쪽에도 포함시켜서 설정을 보완하는 것이 최선인 것 같습니다.\n2. 두 번째 문제는 TagAcceptCallback 함수를 정의하지 않았다는 것입니다. 그래서 문제 해결을 위해 함수를 추가했습니다. 이제 기능이 잘 작동합니다.\n3. 세 번째 문제는 항상 합의 가을로 떨어진다는 것입니다. 그래서 로직을 수정하여 기온이 5도 이상인지 아닌지에 따라 계절을 변화시키도록 했습니다. 그렇게 하니까 잘 작동했습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n200개 이상의 생산성 앱을 한 곳에서 쉽게 확인하고 싶나요? 그렇다면 SetApp을 확인해보세요. 정말 멋진데요 — 매월 한 번의 요금으로 Bartender, CleanShot X, Paste, iStat Menus, 그리고 BetterTouchTool과 같은 훌륭한 앱 중에서 선택할 수 있습니다. 한 번 시도해보고 30일 무료 이용해 보고 싶다면 제 제휴 링크를 클릭하고 확인해보세요. 어떤 앱이 가장 마음에 들었는지 저에게 알려주세요.\n\n원문은 2024년 3월 8일에 https://talkingtechandaudio.com에서 게시되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png"},"coverImage":"/assets/img/2024-05-18-ApplesecosystemIloveitbutthese5thingsmakemeMAD_0.png","tag":["Tech"],"readingTime":9},{"title":"Jetpack Compose 내비게이션 초보부터 고급까지 전체 가이드","description":"","date":"2024-05-18 17:13","slug":"2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced","content":"\n아래는 Markdown 형식으로 변환되었습니다.\n\n![이미지](/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png)\n\n# 안드로이드에서의 네비게이션은 무엇인가요?\n\n네비게이션은 애플리케이션의 다른 구성 요소 간에 이동하는 방법을 이해하는 데 도움이 됩니다.\n\nAndroid JetPack 네비게이션은 고수준의 네비게이션을 간편하게 구현하는 데 도움을 줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네비게이션 컴포넌트는 세 가지 주요 부분으로 구성되어 있어요:\n\n- 네비게이션 그래프: 이는 모든 네비게이션 관련 데이터를 한 곳에 모아 둔 리소스입니다. 이에는 앱 내의 모든 위치인 목적지들과 사용자가 앱을 통해 이동할 수 있는 가능한 경로들이 포함됩니다. 앱에서 갈 수 있는 모든 장소와 그 있는 방법을 담은 큰 책처럼 생각하시면 좋아요. 이것은 지도와 안내서가 결합된 것으로 이해할 수 있어요.\n- NavHost: 이는 레이아웃에 포함할 수 있는 독특한 컴포저블(composable)입니다. 네비게이션 그래프에서 다양한 목적지를 표시해줘요. NavHost는 NavController를 네비게이션 그래프에 연결하여 네비게이션 사이를 이동할 수 있는 컴포저블 목적지를 지정하는 링크 역할을 합니다. 컴포저블 간을 이동하는 동안 NavHost의 내용은 자동으로 recompose됩니다. 네비게이션 그래프의 각 컴포저블 목적지는 경로에 연결돼 있어요.\n- NavController: NavController는 네비게이션 컴포넌트의 중심 API입니다. 이는 상태를 가지고 있으며, 앱의 화면을 구성하는 컴포저블들의 백 스택과 각 화면의 상태를 추적합니다.\n\n# Jetpack Compose에서의 네비게이션\n\n네비게이션 컴포넌트는 Jetpack Compose 애플리케이션을 지원해줍니다. 네비게이션 컴포넌트의 인프라와 기능을 활용하면서 컴포저블들 간을 이동할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nJetpack Compose에서 탐색을 시작하려면 프로젝트의 build.gradle 파일에 필수 종속성을 포함해야 합니다:\n\n```js\nimplementation \"androidx.navigation:navigation-compose:2.7.1\"\n```\n\nJetpack Compose에서 탐색에 대한 기본 개념.\n\n## NavController:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNavController은 네비게이션 컴포넌트의 중심 API입니다. 상태를 유지하며, 앱의 화면을 구성하는 컴포저블의 백 스택 및 각 화면의 상태를 추적합니다.\n\n이러한 NavController는 다음과 같이 rememberNavController() 메서드를 사용하여 만들 수 있습니다:\n\n```js\nval navController = rememberNavController()\n```\n\nNavController를 만들 때는 모든 컴포저블이 해당 NavController에 액세스할 수 있는 컴포저블 계층구조의 적절한 위치에서 만들어야 합니다. 이는 상태 끌어올리기(state hoisting)의 원리를 따르며, 현재 currentBackStackEntryAsState()를 통해 제공되는 NavController 및 상태를 통해 화면 외부의 컴포저블을 업데이트하는 데 참고할 수 있도록 합니다. 이러한 기능의 예시는 바텀 네비게이션바와의 통합을 참고하세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## NavHost:\n\n각 NavController는 단일 NavHost composable과 연결되어야 합니다. NavHost는 NavController를 네비게이션 그래프와 연결하여 이동할 수 있는 composable 목적지를 지정합니다. composable 사이를 이동하면 NavHost의 내용이 자동으로 recomposed됩니다. 네비게이션 그래프의 각 composable 목적지는 route와 연결됩니다.\n\nNavHost를 생성하려면 이전에 rememberNavController()를 통해 생성한 NavController와 그래프의 시작 목적지인 route가 필요합니다. NavHost 생성은 네비게이션 Kotlin DSL에서 lambda 구문을 사용하여 네비게이션 그래프를 구성합니다. composable() 메서드를 사용하여 네비게이션 구조를 추가할 수 있습니다. 이 메서드는 route 및 목적지에 연결할 composable를 제공해야 합니다:\n\n```js\nNavHost(navController = navController, startDestination = \"profile\") {\n    composable(\"profile\") { Profile(/*...*/) }\n    composable(\"friendslist\") { FriendsList(/*...*/) }\n    /*...*/\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예시: 네비게이션 그래프, 네브호스트 및 네비게이션 아이템 설정하는 방법\n\n단계 1: 네비게이션을 위한 화면 이름 및 라우트를 하나의 파일에 정의합니다. 예시. AppNavigation.kt\n\n```kotlin\nenum class Screen {\n    HOME,\n    LOGIN,\n}\nsealed class NavigationItem(val route: String) {\n    object Home : NavigationItem(Screen.HOME.name)\n    object Login : NavigationItem(Screen.LOGIN.name)\n}\n```\n\n단계 2: NavHost 및 화면을 정의합니다. 예시. AppNavHost.kt\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun AppNavHost(\n    modifier: Modifier = Modifier,\n    navController: NavHostController,\n    startDestination: String = NavigationItem.Splash.route,\n    ... // 다른 매개변수\n) {\n    NavHost(\n        modifier = modifier,\n        navController = navController,\n        startDestination = startDestination\n    ) {\n        composable(NavigationItem.Splash.route) {\n            SplashScreen(navController)\n        }\n        composable(NavigationItem.Login.route) {\n            LoginScreen(navController)\n        }\n    }\n}\n```\n\n단계 3: MainActivity.kt 파일에서 AppNavHost를 호출합니다.\n\n```kotlin\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            AutoPartsAppTheme {\n               Surface(\n                    modifier = Modifier.fillMaxSize(),\n                    color = MaterialTheme.colorScheme.background\n                ) {\n                    AppNavHost(navController = rememberNavController())\n                }\n            }\n        }\n    }\n}\n```\n\n## 네비게이션 인자:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n네비게이션 Compose는 코틀린을 사용하여 콤포저블 목적지 간에 인수를 전달하는 것을 지원합니다. 이를 위해 기본 네비게이션 라이브러리를 사용할 때 딥 링크에 인수를 추가하는 방식과 유사한 방식으로 라우트에 인수 자리 표시자를 추가해야 합니다.\n\n## 사용 사례:\n\n- 인수가 없을 때\n- Int, String 등 미리 정의된 데이터 유형과 같은 간단한 인수를 사용할 때\n\n3. 사용자가 정의한 데이터 유형 같은 복잡한 인수를 사용할 때\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n4. 선택적 매개변수\n\n5. 결과값으로 되돌아가기\n\n## 매개변수 없이:\n\n```js\nNavHost(navController = navController, startDestination = \"profile\") {\n    composable(\"profile\") { Profile(/*...*/) }\n    composable(\"friendslist\") { FriendsList(/*...*/) }\n    /*...*/\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 간단한 인수로:\n\n기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다:\n\n```js\nNavHost(startDestination = \"profile/{userId}\") {\n    ...\n    composable(\"profile/{userId}\") {...}\n}\n```\n\n기본적으로 모든 인수는 문자열로 구문 분석됩니다. composable()의 인수 매개변수는 NamedNavArguments의 목록을 허용합니다. navArgument 메서드를 사용하여 NamedNavArgument를 빠르게 만들고 그 정확한 유형을 지정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nNavHost(startDestination = \"profile/{userId}\") {\n    ...\n    composable(\n        \"profile/{userId}\",\n        arguments = listOf(navArgument(\"userId\"){\n           type = NavType.StringType\n        })\n    ) {...}\n}\n```\n\n`composable(\"profile/{userId}\") { backStackEntry ->\n   val userId = backStackEntry.arguments?.getString(\"userId\")\n   // 여기서 사용자 데이터를 가져와야 합니다\n   Profile(\n      navController, \n      // 사용자 데이터를 가져와서 전달하세요. 예: UserInfo\n   )\n}\n`\n\n대상으로 전달하려면 navigate 호출 시 경로에 추가해야 합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nnavController.navigate(\"profile/user1234\");\n```\n\n지원되는 유형 목록을 보려면 전달 방법을 참조하세요.\n\n## 복잡하거나 사용자 정의 인수로:\n\n이동할 때 복잡한 데이터 객체를 전달하는 것은 권장되지 않지만 대신 고유 식별자 또는 기타 형식의 ID와 같이 최소한의 정보를 인수로 전달해야합니다. 이를 통해 이동 작업 수행 가능합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n// 새로운 대상으로 이동할 때 사용자 ID만 전달하실 때\nnavController.navigate(\"profile/user1234\");\n```\n\n복잡한 객체는 데이터 레이어와 같은 단일 진실의 원천으로 저장해야 합니다. 이동 후 목적지에 도착하면 전달된 ID를 사용하여 단일 진실의 원천에서 필요한 정보를로드할 수 있습니다. 데이터 레이어에 액세스하는 ViewModel에서 인수를 검색하려면 SavedStateHandle를 사용할 수 있습니다.\n\n```js\nclass UserViewModel(\n    savedStateHandle: SavedStateHandle,\n    private val userInfoRepository: UserInfoRepository\n) : ViewModel() {\n\n    private val userId: String = checkNotNull(savedStateHandle[\"userId\"])\n\n    // 전달된 userId 인수를 기반으로 데이터 레이어(예: userInfoRepository)에서 관련 사용자 정보 검색\n    private val userInfo: Flow<UserInfo> = userInfoRepository.getUserInfo(userId)\n\n   --------------- OR -----------------\n\n    // 네트워크 또는 데이터베이스에서 데이터 가져오기\n    private val _dataFlow =\n            MutableStateFlow<UserInfo>(userInfoRepository.getUserInfo(userId))\n    val dataFlow get() = _dataFlow.asStateFlow()\n}\n```\n\n적합한 기능\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n//Navhost\ncomposable(\"profile/{userId}\") { backStackEntry ->\n   val userId = backStackEntry.arguments?.getString(\"userId\")\n   // 여기서 사용자 데이터를 가져와야 합니다\n   val userInfo by taskViewModel.dataFlow.collectAsState()\n   Profile(\n      navController,\n      userInfo\n   )\n}\n\n// 프로필 화면\n@Composable\nfun Profile(navController: NavController, userInfo: UserInfo){\n    // 여기서 작업을 수행합니다\n}\n```\n\n이 접근 방식은 구성 변경 중에 데이터 유실을 방지하고 해당 객체가 업데이트되거나 변경될 때 불일치를 방지합니다.\n\n복잡한 데이터를 인수로 전달하는 것을 피해야 하는 이유 및 지원되는 인수 유형 목록에 대한 보다 자세한 설명은 Best practice를 참조하세요.\n\n## 선택적 인수 추가하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNavigation Compose는 선택적 네비게이션 인수도 지원합니다. 선택적 인수는 필수 인수와 두 가지 방법으로 다릅니다:\n\n- 쿼리 매개변수 구문(\"?argName='argName'\")을 사용하여 포함되어야 합니다.\n- defaultValue가 설정되어 있어야 하거나 nullable = true이어야 합니다(이는 기본 값을 자동으로 null로 설정합니다).\n\n이는 모든 선택적 인수가 콤포저블() 함수에 명시적으로 추가되어야 한다는 것을 의미합니다:\n\n```js\ncomposable(\n    \"profile?userId={userId}/{isMember}\",\n    arguments = listOf(\n         navArgument(\"userId\") {\n            type = NavType.StringType\n            defaultValue = \"user1234\"\n           // 또는\n            type = NavType.StringType\n            nullable = true\n         },\n         navArgument(\"isNewTask\") {\n            type = NavType.BoolType\n         }\n     )\n) { backStackEntry ->\n    val userId = backStackEntry.arguments?.getString(\"userId\")\n    val isMember = backStackEntry.arguments?.getBoolean(\"isMember\")?:false\n    Profile(navController, userId, isMember)\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 대상에 인수가 전달되지 않더라도 defaultValue = \"user1234\"가 대신 사용됩니다.\n\n경로를 통해 인수를 처리하는 구조는 Composable이 Navigation과 완전히 독립되도록 하며 이로 인해 테스트하기 훨씬 더 용이해집니다.\n\n## 결과 값으로 되돌아가기\n\n결과 값을 사용하여 되돌아가는 것이 가장 일반적인 작업입니다. 즉, 필터 대화상자를 열고 필터를 선택한 다음 해당 필터를 적용하기 위해 선택된 필터와 함께 되돌아가는 경우입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n두 개의 화면이 있습니다. 1. 첫 번째 화면과 2. 두 번째 화면입니다. 우리는 두 번째 화면에서 첫 번째 화면으로 데이터를 필요로 합니다.\n\nNavHost.kt : 내비게이션 그래프 설정.\n\n```js\n val navController = rememberNavController()\n NavHost(\n     navController = navController,\n     startDestination = \"firstscreen\"\n ) {\n    composable(\"firstscreen\") {\n        FirstScreen(navController)\n    }\n    composable(\"secondscreen\") {\n        SecondScreen(navController)\n    }\n}\n```\n\nFirstScreen.kt: NavController의 현재 백 스택 항목의 savedStateHandle를 사용하여 두 번째 화면에서 다시 이동한 후 데이터를 검색합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\nfun FirstScreen(navController: NavController) {\n    // 다음 화면에서 데이터를 가져옵니다\n    val msg =\n        navController.currentBackStackEntry?.savedStateHandle?.get<String>(\"msg\")\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Button(onClick = { navController.navigate(\"secondscreen\") }) {\n            Text(\"다음 화면으로 이동\")\n        }\n        Spacer(modifier = Modifier.height(8.dp))\n        msg?.let {\n            Text(it)\n        }\n    }\n}\n```\n\nSecondScreen.kt: 이전 백 스택 항목의 savedStateHandle 내에 데이터를 넣습니다.\n\n```kotlin\n@Composable\nfun SecondScreen(navController: NavController) {\n    var text by remember {\n        mutableStateOf(\"\")\n    }\n    Column(\n        Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        TextField(\n            value = text, onValueChange = { text = it },\n            placeholder = {\n                Text(\"텍스트를 입력하세요\", color = Color.Gray)\n            }\n        )\n        Spacer(Modifier.height(8.dp))\n        Button(onClick = {\n\n           // 데이터를 savedStateHandle에 넣어 이전 화면에서 데이터를 가져옵니다\n\n            navController.previousBackStackEntry?.savedStateHandle?.set(\"msg\", text)\n            navController.popBackStack()\n        }) {\n            Text(text = \"제출\")\n        }\n    }\n}\n```\n\n비디오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nhttps://github.com/KaushalVasava/JetPackCompose_Basic/assets/49050597/1d96d44f-66e1-4f3b-bba1-2844ab6553cc\n\nGitHub 저장소: https://github.com/KaushalVasava/JetPackCompose_Basic/tree/navigate-back-with-result\n\n# 딥 링크\n\nNavigation Compose은 암시적 딥 링크를 지원하며 composable() 함수의 일부로 정의할 수 있습니다. 딥 링크 매개변수 deepLinks는 navDeepLink 메소드를 사용하여 빠르게 생성할 수 있는 NavDeepLinks 목록을 수용합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nval uri = \"https://www.example.com\"\ncomposable(\n    \"profile?id={id}\",\n    deepLinks = listOf(navDeepLink { uriPattern = \"$uri/{id}\" })\n) { backStackEntry ->\n    Profile(navController, backStackEntry.arguments?.getString(\"id\"))\n}\n```\n\n이러한 딥 링크를 사용하면 특정 URL, 액션 또는 MIME 유형을 composable과 연결할 수 있습니다. 기본적으로 이러한 딥 링크는 외부 앱에 노출되지 않습니다. 이러한 딥 링크를 외부에서 사용 가능하게 하려면 앱의 manifest.xml 파일에 적절한 `intent-filter` 요소를 추가해야 합니다. 위의 딥 링크를 활성화하려면 manifest의 `activity` 요소 내에 다음을 추가해야 합니다:\n\n```js\n<activity …>\n  <intent-filter>\n    ...\n    <data android:scheme=\"https\" android:host=\"www.example.com\" />\n  </intent-filter>\n</activity>\n```\n\n다른 앱에 의해 트리거된 경우 딥 링크가 활성화될 때 해당 composable로 자동으로 이동합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이러한 동일한 딥 링크는 콤포저블에서 적절한 딥 링크와 함께 PendingIntent를 작성하는 데 사용할 수도 있습니다:\n\n```kotlin\nval id = \"exampleId\"\nval context = LocalContext.current\nval deepLinkIntent = Intent(\n    Intent.ACTION_VIEW,\n    \"https://www.example.com/$id\".toUri(),\n    context,\n    MyActivity::class.java\n)\nval deepLinkPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {\n    addNextIntentWithParentStack(deepLinkIntent)\n\n    val flag = if(Build.VERSION.SDK_INT > Build.VERSION_CODES.S){\n                    PendingIntent.FLAG_IMMUTABLE\n                }\n                else\n                    PendingIntent.FLAG_UPDATE_CURRENT\n    getPendingIntent(0, flag)\n}\n```\n\n그런 다음 이 deepLinkPendingIntent를 다른 PendingIntent와 마찬가지로 사용하여 앱을 딥 링크 대상지에서 열 수 있습니다.\n\n# 중첩된 내비게이션\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Image](/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_1.png)\n\n앱의 UI에서 특정 플로우를 모듈화하기 위해 대상을 중첩 그래프로 그룹화할 수 있습니다. 이러한 예로는 독립적인 로그인 플로우가 있을 수 있습니다.\n\n중첩 그래프는 메인 그래프처럼 대상을 그룹화하며 해당 경로에 대한 지정된 시작 대상이 필요합니다. 이것은 중첩된 그래프의 경로에 액세스할 때 이동할 위치입니다.\n\nNavHost에 중첩된 그래프를 추가하려면 네비게이션 익스텐션 함수를 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nNavHost(navController, startDestination = \"home\") {\n    ...\n    // 그래프를 통해 경로('login')로 이동하면 자동으로\n    // 그래프의 시작 대상인 'username'으로 이동합니다.\n    // 이로써 그래프의 내부 라우팅 로직을 캡슐화합니다.\n    navigation(startDestination = \"username\", route = \"login\") {\n        composable(\"username\") { ... }\n        composable(\"password\") { ... }\n        composable(\"registration\") { ... }\n    }\n    ...\n}\n```\n\n그래프가 커질수록 여러 메소드로 나누는 것이 좋습니다. 이렇게 하면 여러 모듈이 각자의 네비게이션 그래프를 기여할 수 있습니다.\n\n```js\nfun NavGraphBuilder.loginGraph(navController: NavController) {\n    navigation(startDestination = \"username\", route = \"login\") {\n        composable(\"username\") { ... }\n        composable(\"password\") { ... }\n        composable(\"registration\") { ... }\n    }\n}\n```\n\nNavGraphBuilder를 확장 메소드로 만들면 미리 작성된 navigation, composable, dialog 익스텐션 메소드와 함께 사용할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nNavHost(navController, startDestination = \"home\") {\n    ...\n    loginGraph(navController)\n    ...\n}\n```\n\n예시:\n\n```kotlin\nval navController = rememberNavController()\nNavHost(navController = navController, startDestination = \"home\") {\n    composable(\"about\") {}\n    navigation(\n        startDestination = \"login\",\n        route = \"auth\"\n    ) {\n        composable(\"login\") {\n            val viewModel = it.sharedViewModel<SampleViewModel>(navController)\n\n            Button(onClick = {\n                navController.navigate(\"calendar\") {\n                    popUpTo(\"auth\") {\n                        inclusive = true\n                    }\n                }\n            }) {\n            }\n        }\n        composable(\"register\") {\n            val viewModel = it.sharedViewModel<SampleViewModel>(navController)\n        }\n        composable(\"forgot_password\") {\n            val viewModel = it.sharedViewModel<SampleViewModel>(navController)\n        }\n    }\n    navigation(\n        startDestination = \"calendar_overview\",\n        route = \"calendar\"\n    ) {\n        composable(\"calendar_overview\") { }\n        composable(\"calendar_entry\") { }\n    }\n}\n```\n\nNavBackStack entry를 위한 확장 함수\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\n@Composable\ninline fun <reified T : ViewModel> NavBackStackEntry.sharedViewModel(navController: NavController): T {\n    val navGraphRoute = destination.parent?.route ?: return viewModel()\n    val parentEntry = remember(this) {\n        navController.getBackStackEntry(navGraphRoute)\n    }\n    return viewModel(parentEntry)\n}\n```\n\n# 하단 탐색 막대와 통합\n\n조합 가능한 구조의 위쪽 수준에서 NavController를 정의함으로써, 네비게이션을 하단 탐색 막대와 같은 다른 구성 요소와 연결할 수 있습니다. 이를 통해 하단 막대에서 아이콘을 선택하여 탐색할 수 있습니다.\n\nBottomNavigation 및 BottomNavigationItem 구성 요소를 사용하려면 Android 애플리케이션에 androidx.compose.material 종속성을 추가하십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\n좌측 테이블을 Markdown 형식으로 변환했습니다.\n```\n\n하단 네비게이션바의 항목을 네비게이션 그래프의 루트에 링크하려면 Screen과 같은 sealed class를 정의하는 것이 좋습니다. 이 클래스는 목적지의 루트와 문자열 리소스 ID를 포함합니다.\n\n```js\nsealed class Screen(val route: String, @StringRes val resourceId: Int) {\n    object Profile : Screen(\"profile\", R.string.profile)\n    object FriendsList : Screen(\"friendslist\", R.string.friends_list)\n}\n```\n\n이후 BottomNavigationItem에서 사용할 수 있는 리스트에 해당 항목을 넣으십시오.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nval items = listOf(\n    Screen.Profile,\n    Screen.FriendsList\n)\n```\n\nBottomNavigation 컴포저에서 currentBackStackEntryAsState() 함수를 사용하여 현재 NavBackStackEntry를 가져옵니다. 이 엔트리를 통해 현재 NavDestination에 액세스할 수 있습니다. 각 BottomNavigationItem의 선택 상태는 아이템의 경로를 현재 목적지 및 부모 목적지의 경로와 비교하여 결정할 수 있습니다 (중첩된 내비게이션을 사용하는 경우 처리하기 위해 NavDestination 계층구조를 통해).\n\n아이템의 경로는 또한 onClick 람다를 navigate 호출과 연결하는 데 사용되어 해당 아이템을 탭하면 해당 아이템으로 이동합니다. saveState 및 restoreState 플래그를 사용하여 해당 아이템의 상태와 백 스택이 올바르게 저장되고 전환될 때 해당 아이템의 상태가 올바르게 복원됩니다.\n\n```kotlin\nval navController = rememberNavController()\nScaffold(\n    bottomBar = {\n        BottomNavigation {\n            val navBackStackEntry by navController.currentBackStackEntryAsState()\n            val currentDestination = navBackStackEntry?.destination\n            items.forEach { screen ->\n                BottomNavigationItem(\n                    icon = { Icon(Icons.Filled.Favorite, contentDescription = null) },\n                    label = { Text(stringResource(screen.resourceId)) },\n                    selected = currentDestination?.hierarchy?.any { it.route == screen.route } == true,\n                    onClick = {\n                        navController.navigate(screen.route) {\n                            popUpTo(navController.graph.findStartDestination().id) {\n                                saveState = true\n                            }\n                            launchSingleTop = true\n                            restoreState = true\n                        }\n                    }\n                )\n            }\n        }\n    }\n) { innerPadding ->\n    NavHost(navController, startDestination = Screen.Profile.route, Modifier.padding(innerPadding)) {\n        composable(Screen.Profile.route) { Profile(navController) }\n        composable(Screen.FriendsList.route) { FriendsList(navController) }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nNavController.currentBackStackEntryAsState() 메소드를 활용하여 네비게이션 컨트롤러 상태를 NavHost 함수 밖으로 빼내어 BottomNavigation 컴포넌트와 공유합니다. 이렇게 하면 BottomNavigation이 항상 최신 상태를 가지게 됩니다.\n\n읽어 주셔서 감사합니다. 🙌🙏✌\n\n더 많은 안드로이드 개발, 코틀린 및 KMP에 관한 유용한 기사를 보시려면 박수를 날려주세요 👏 그리고 팔로우해 주세요.\n\n안드로이드, 코틀린 및 KMP 관련 도움이 필요하시다면 언제든지 도와드리겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nMedium, LinkedIn, Twitter, GitHub, Instagram에서 나를 팔로우하고 DM으로 앱 개발 프리랜싱 업무를 문의해주세요.\n","ogImage":{"url":"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png"},"coverImage":"/assets/img/2024-05-18-NavigationinJetpackcomposeFullguideBeginnertoAdvanced_0.png","tag":["Tech"],"readingTime":25},{"title":"Kotlin에서 플로우와 비동기성 이해를 위한 7가지 레시피","description":"","date":"2024-05-18 17:11","slug":"2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin","content":"\n코틀린 코루틴의 깨끗한 세계에서는 다양한 시간에 실행되는 많은 작업들이 놀랍게도 적은 스레드로 쌓이게 됩니다. 이러한 코루틴들은 종종 서로 통신을 해야합니다. 예를 들어 비동기 작업이 완료되어 결과를 보고해야 하거나 진행 중인 작업이 결과를 전달해야 할 때입니다.\n\n코틀린에는 이러한 통신을 관리하는 데 도움이 되는 여러 구조가 있습니다. 서스펜드 함수는 비동기 작업을 기다리는 데 도움이 되며, 여러 결과를 기대하는 경우 플로우가 필요합니다.\n\n이 기사에서는 일반적으로 비동기 처리에 대해 예시를 들고, 플로우를 소개합니다. 플로우가 왜 필요한지, 핫 플로우와 콜드 플로우의 차이, 그리고 콜백을 서스펜드 함수와 플로우로 변환하는 방법에 대해 알아보겠습니다.\n\n# 레시피 1: 자바 콜백, 어린날로의 돌아가기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우선, 여기에는 일시 중단 함수나 플로우가 아닌 것이 있습니다. Firestore에서 문서를 가져오는 방법은 다음과 같습니다:\n\n```js\nFirebase.firestore.collection(\"users\").document(\"me\")\n  .get()   // \"me\" 문서의 비동기 다운로드 시작\n  .addOnSuccessListener { result ->\n    // 다운로드가 완료될 때이 함수가 호출됩니다\n  }\n```\n\n이는 비동기 콜백 패턴입니다. 요청을 하면 작업이 비동기적으로 수행되고 나중에 결과가 돌아옵니다.\n\nJava와 하위 호환성을 유지하며 작성된 API는 이와 같은 비동기 콜백을 가득 가지고 있습니다. 이 패턴은 오래된 것으로 간주되므로 Kotlin 스타일이 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 레시피 2: Kotlin을 사용하여 콜백 처리하기: suspendCoroutine\n\n요청한 내용을 받고 나줌에 결과를 받는 상황을 처리하는 더 나은 방법은 코틀린 코루틴의 강력한 기능을 활용하는 대기 함수를 사용하는 것입니다. 제 최근 블로그 포스트에서 대기 함수에 대해 자세히 설명했었는데, 요약하자면: 대기 함수는 현재 코루틴을 일시 중단하지만 실행 중인 스레드를 차단하지 않습니다.\n\n좋은 소식은 콜백을 대기 함수로 변환할 수 있다는 것입니다\\*. 필요한 함수는 suspendCoroutine입니다:\n\n```js\nsuspend fun getDocument() = suspendCoroutine { continuation ->\n  Firebase.firestore.collection(\"users\").document(\"me\")\n    .get()\n    .addOnSuccessListener { result ->\n      // 받은 문서를 사용하여 일시 중단된 코루틴을 다시 실행합니다.\n      continuation.resume(result)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n좋아요. 이제는 getDocument()를 호출하는 방법이 훨씬 간단해졌어요. 예를 들어 ViewModel에서:\n\n```js\nviewModelScope.launch(Dispatchers.IO) {\n    val location = getDocument()\n}\n```\n\nJava의 모든 부가 기능을 제거한 Kotlin이 얼마나 아름다운지 보세요. 함수를 한 줄로 호출할 수 있어요. 아름다워요.\n\n# 안티-레시피 1: 일회성 함수는 한 번만 반환할 수 있어요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n하지만 만일 우리가 하나 이상의 응답을 예상하고 있다면 어떻게 해야 할까요?\n\nFirestore에게 문서의 새 버전을 얻을 때마다 업데이트를 유지하도록 요청할 수 있습니다. 이를 위해 addOnSnapshotListener를 사용하고 Firestore는 업데이트가 있을 때마다 리스너를 호출합니다:\n\n```js\nFirebase.firestore.collection(\"users\").document(\"me\")\n  .addOnSnapshotListener { snapshot, error ->\n    // 이 함수는 \"me\" 문서가 업데이트될 때마다 호출됩니다.\n  }\n```\n\n이것을 대기 함수로 변경할 수 있을까요? 아뇨! 대기 함수는 한 번만 반환합니다. 여러 번 continuation.resume()을 호출하면 IllegalStateException(\"이미 재개되었습니다\")가 발생합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Recipe 3](/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png)\n\nSo we need something different. What we need is a flow.\n\n# Recipe 3: Using callbackFlow to return multiple things from an async callback\n\nWhen an object hits the flow’s conveyor belt, we say it’s been emitted by the flow. When it gets taken off the conveyor belt to be handled, we say it’s been collected by a collector.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 Firestore 예제에서는 문서 데이터가 로드되는 플로우를 생성해야 합니다. 나중에 그것을 수집하는 코드를 작성할 것입니다.\n\n## 멀티 샷 콜백을 플로우로 변환하기: callbackFlow\n\n여기서 우리는 흐름 \"컨베이어 벨트\"를 생성하고 업데이트된 문서를 올립니다. 업데이트된 문서는 콜백에서 얻은 스냅샷으로 나타납니다:\n\n```js\n// callbackFlow를 사용하여 플로우 \"컨베이어 벨트\"를 만듭니다.\nval documentFlow = callbackFlow {\n\n  // Firestore에게 \"me\" 문서의 변경 사항을 계속 업데이트하라고 요청합니다.\n  database.collection(\"users\").document(\"me\")\n    .addOnSnapshotListener { snapshot, error ->\n      // 업데이트된 문서를 이 플로우의 \"컨베이어 벨트\"에 올립니다.\n      trySend(snapshot)\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이는 Firestore에서 받은 각 스냅샷을 방출하는 flow 객체를 생성합니다.\n\n# 레시피 4: flow 수집하기\n\n이제 이 컨베이어 벨트를 설정했고, documentFlow라는 변수에 할당했습니다. 결과를 어떻게 얻을까요?\n\n답변: collect 함수를 사용하여 결과를 수집합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nviewModelScope.launch {\n  documentFlow.collect { snapshot ->\n    // This is the snapshot placed on the conveyor belt earlier\n  }\n}\n```\n\n이 함수는 일시 중단되므로 코루틴 내에서 실행해야 합니다. collect에 전달하는 람다는 새 항목이 컨베이어 벨트에 나타날 때마다 호출됩니다.\n\n이것의 라이프사이클을 좀 고려해보죠. collect 함수는 컨베이어 벨트가 작동을 멈출 때까지 일시 중단됩니다.\n\n플로우 컨베이어 벨트가 작동을 멈출 수 있는 방법은 두 가지뿐입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 종료로: 발신자가 더 이상 전달할 것이 없으면 close()를 호출하여 컨베이어 벨트가 멈추도록 요청합니다.\n- 오류로: 발신자가 예외를 throw합니다. 이로 인해 자동으로 흐름이 닫힙니다.\n\n물론 위의 조건 중 어느 것도 발생하지 않을 수 있어서 컨베이어가 멈출 수도 없습니다. 따라서 collect 호출은 무한 루프를 나타낼 수 있습니다. 그러나 코루틴의 진정한 매력은 collect 함수가 취소 가능하다는 것입니다. 따라서 위의 예제에서는 viewModelScope가 취소되는 즉시 수집이 중지됩니다. 그렇기 때문에 위의 코드는 사실 완전히 안전합니다. 코루틴 범위, 컨텍스트, 작업에 대한 더 많은 내용은 블로그 글에서 확인하실 수 있습니다.\n\n# 레시피 5: Cold flows와 awaitClose\n\ncallbackFlow 람다 내의 코드는 수집기가 수집을 시작할 때 즉시 실행됩니다. 각 새로운 수집기는 다른 수집기와 병렬로 실행 중이더라도 코드가 다시 실행되게 합니다. 이것이 콜드 플로우 동작이라고 알려져 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이에 따라, 수집기가 수집을 멈출 때 Firestore 연결을 종료해야 합니다. 'awaitClose'를 사용하여 이를 자동으로 처리할 수 있습니다:\n\n```js\nval documentFlow = callbackFlow {\n  val listener = database.collection(\"users\").document(\"me\")\n    .addOnSnapshotListener { snapshot, error ->\n      ...\n    }\n\n  // 이 코드 블록은 수집기가 수집을 멈출 때마다 실행됩니다\n  awaitClose {\n    // Firestore 연결 종료\n    listener.remove()\n  }\n}\n```\n\n'awaitClose' 블록은 수집기가 수집을 멈출 때마다 실행됩니다. 이를 사용하여 원격 데이터베이스의 리스너를 등록 해제합니다.\n\n우리의 더 높은 수준의 코드를 수정할 필요는 없습니다: 우리는 여전히 레시피 4의 문서 플로우 수집을 위해 documentFlow.collect를 호출합니다. 모든 것이 요구될 때 필요한대로 모두 종료되도록 보장하는 데 필요한 다른 작업은 없습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 레시피 6: SharedFlow 및 여러 수집기\n\n알고 계세요. callbackFlow 람다의 코드는 수집기가 수집을 시작하는 즉시 실행됩니다. 즉, 동시에 100개의 수집기가 작동하는 경우 Firestore로부터 100개의 연결이 열리게 됩니다. 한 개로도 충분히 해결할 수 있는 상황에서 매우 비효율적입니다.\n\n실제로 우리가 원하는 것은 여러 수집기를 사용할 수 있는 flow 입니다. 이 flow는 첫 번째 수집기가 데이터 수집을 시작할 때 Firestore 연결을 시작하고, 마지막 수집기가 멈출 때 해당 연결을 종료해야 합니다. 해당 시간 사이에 도착하는 다른 수집기는 새로운 Firestore 연결을 열지 않고 데이터의 사본을 받아야 합니다.\n\n다시 말해, flow의 지속적인 이벤트와 개별 수집기의 도착/사라짐 간의 연계를 어느 정도 분리하고자 합니다. 더 이상 냉각된 flow를 사용하고 싶지 않으며, hot flow를 원합니다. hot flow의 수집기를 구독자(subscriber)라고 합니다 — 이러한 언어의 약간의 변경은 flow가 수집자와 독립적으로 계속되는 사실을 강조하기 위한 것입니다. 구독자는 단지 \"확인\"하는 역할을 하며, flow를 운전하는 것이 아닙니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n여기서 필요한 특정 종류의 핫 플로우는 SharedFlow입니다. SharedFlow는 데이터를 여러 구독자에게 방송하는 데 사용됩니다. 예를 들어 데이터를 SharedFlow 컨베이어 벨트에로드하는 코루틴이 여기에 있습니다.\n\n해당 코루틴이 실행중인 한 데이터는 컨베이어 벨트를 따라 이동합니다. 누군가 데이터를 수집하고 있든 상관없습니다.\n\n플로우가 흐르기 시작한 정확한 시점에 구독하면 순차적으로 0, 1, 2, 3, 4...가 출력됩니다. 그러나 몇 초 후에 수집을 시작하면 처음 몇 번의 에미션이 놓치고 7, 8, 9, 10, 11...이 출력됩니다. 이것은 플로우가 수집을 시작하기 전에 이미 흐르기 시작했음을 보여줍니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 레시피 7: 차가운 플로우를 공유해서 뜨겁게 만들기\n\n`shareIn()` 함수는 차가운 플로우를 가져와서 뜨겁게 만드는 데 사용됩니다. 즉, 이 함수는 코루틴을 시작하여 차가운 플로우를 수집하고 받은 모든 것을 구독자에게 다시 방송합니다. 구독자의 수는 0을 포함하여 제한이 없을 수 있습니다.\n\n다음은 `shareIn()` 함수의 정의입니다:\n\n```js\nfun <T> Flow<T>.shareIn(\n    scope: CoroutineScope,\n    started: SharingStarted,\n    replay: Int = 0\n): SharedFlow<T>\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한 Android Activity는 SharingStarted.WhileSubscribed()와 stopTimeoutMillis를 사용하는 예시입니다. 액티비티는 장치가 회전될 때 종료되고 다시 시작되기 때문에 해당 프로세스 중 구독자는 몇 밀리초 동안 사라집니다. 이를 방지하기 위해 코드 플로우를 즉시 종료하고 다시 시작하지 않도록하기 위해 shareIn의 coroutine은 5000밀리초 동안 유지됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n마침내, replay 매개변수를 사용하여 구독자가 처음 구독할 때 현재 및 이전 값도 받을 수 있습니다.\n\n# 요약하면...\n\n- suspendCoroutine을 사용하여 비동기 단일 호출 콜백을 일시 중단 함수로 변환할 수 있습니다.\n- 다중 호출 콜백이 있는 경우 플로우가 필요합니다. callbackFlow를 사용하여 다중 호출 콜백을 플로우로 변환할 수 있습니다.\n- callbackFlow에서 생성된 것과 같은 Cold flows는 각 수집기에 대해 별도로 실행됩니다.\n- Hot flows는 수집기(구독자라고도 불림)와 독립적으로 실행됩니다.\n- SharedFlow와 같은 Hot flows 예는 여러 구독자에게 배출을 전파하는 SharedFlow입니다. cold flow를 sharedIn()를 사용하여 SharedFlow로 변환할 수 있습니다.\n\n도움이 되었기를 바랍니다. 모든 의견을 환영합니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n코틀린에서의 비동기 처리는 매우 넓은 주제입니다. 그 중에서도 특히 플로우(Flow)는 다양한 기능이 있습니다. 이에 대해 특정 소주제에 초점을 맞춘 더 많은 기사를 쓸 예정이니, 댓글이나 LinkedIn에서 어떤 내용이 도움이 될지 알려주세요.\n\n- Firestore 팬 여러분을 위해 말하자면, kotlinx-coroutines-play-services 라이브러리의 await()을 사용하여 이 특정 콜백을 중지할 수 있는 작업으로 바꿀 수 있다는 사실을 지적할 것입니다. 맞아요, 당연히 맞습니다. 하지만 이렇게 멋진 예제를 볼 수 없을 테지요? 🙃\n\n\\*\\* Firebase는 실제로 그것 이상으로 똑똑하며, 여러 연결을 열지 않도록 합니다. 위를 참조하세요.\n\n톰 콜빈(Tom Colvin)은 안드로이드의 Google 개발 전문가로, 20년간 소프트웨어 아키텍처를 설계해왔습니다. 그는 모바일 앱 전문가인 Apptaura의 공동 창업자이자 CTO이며, 컨설팅을 통해 사용 가능합니다.\n","ogImage":{"url":"/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png"},"coverImage":"/assets/img/2024-05-18-SevenrecipestounderstandflowsandasynchronyinKotlin_0.png","tag":["Tech"],"readingTime":12},{"title":"플러터 애플리케이션에서 보안 강화하기","description":"","date":"2024-05-18 17:10","slug":"2024-05-18-IncreasesecurityinyourFlutterapplications","content":"\n![보안 강화하기](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png)\n\n현재의 디지털 세계에서 애플리케이션 보안은 절대적인 우선 순위입니다. 견고하고 안전한 Flutter 앱을 개발하는 것은 사용자 데이터를 보호하고 제품에 대한 신뢰를 유지하는 데 중요합니다. Flutter 애플리케이션 보안 여정을 시작하는 경우, 제 이전 기사를 읽어 보시기를 권장합니다. 해당 기사에서는 Gray Box 모드에서 응용 프로그램의 보안을 보장하기 위한 필수적인 실천 방법을 탐구했습니다(기사 링크).\n\n# 보안 분석: 주요 결론\n\nFlutter 애플리케이션의 보안 평가 중에 시장 경험을 토대로 가능한 취약점을 찾을 수 있는 여러 단계를 식별했습니다. 아래에서 자세히 이야기하도록 하겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 인증 검토\n\n애플리케이션에서 사용되는 인증 메커니즘을 조사합니다. 인증 중 강력한 보안 메커니즘의 부재로 사용자 토큰에 민감한 데이터가 평문으로 포함되는 문제가 발생했다고 발견했습니다. 명확히 말하자면, JWT 토큰은 올바른 방식으로 발급되지 않으면 복호화될 수 있습니다. jwt.io 웹사이트에서는 토큰을 붙여넣으면 모든 내부 데이터를 제시해줍니다.\n\n![이미지1](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_1.png)\n\n![이미지2](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nFigure 1에서는 웹 사이트에 추가된 JWT 토큰을 볼 수 있고, Figure 2에서는 분해된 데이터가 나타납니다. 이 토큰을 해독하는 데 도움이 되는 보안 키의 사용 방식을 강조할 가치가 있습니다. 이 키는 서버만 사용하여 컴파일하고 앱-클라이언트가 분해하는 데 사용됩니다. Figure 3에 표시된 대로입니다.\n\n![Image](/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_3.png)\n\n## 액세스 제어의 평가와 문제 해결 방지\n\n또 다른 중요한 점은 프론트엔드의 액세스 제어이며, 여러 중요한 결함을 발견할 수 있는데, 애플리케이션이 안전하지 않은 기기에서 액세스되도록 허용합니다. 즉, 탈옥 또는 루팅된 것으로 간주되는 특정 기기에서 허용됩니다.\n이러한 기기는 너무 허용되어 있어 일반적인 운영 체제에서 적용된 보안 제약 사항 없이 작업을 수행하고 응용 프로그램을 설치할 수 있는 것을 의미합니다. 이러한 환경에서는 앱 보안 메커니즘이 쉽게 우회될 수 있어 민감한 데이터 및 중요한 기능이 잠재적인 공격자에게 노출될 수 있습니다. 이는 미약한 기기로부터의 액세스를 차단하고 탐지하기 위해 프론트엔드에 보다 엄격한 보안 제어를 구현해야 함을 강조합니다.\nFlutter에서 액세스 제어 결함을 극복하고 안전하지 않은 기기에서 애플리케이션을 보호하기 위해 여러 전략을 채택할 수 있습니다. 이 기기들을 감지하는 것이 중요합니다. Flutter에는 기기의 탈옥 또는 루팅 여부를 확인하는 데 도움이 되는 특정 라이브러리가 있습니다. 탈옥 또는 루팅된 기기를 감지하면 사용자에게 경고 메시지를 표시하고 액세스를 차단하여 앱이 작동하지 않도록 할 수 있습니다.\n또 다른 중요한 조치는 애플리케이션이 실행되는 환경의 무결성을 확인하는 것입니다. 이는 에뮬레이터를 감지하고 응용프로그램 바이너리가 변경되지 않았는지 확인하는 것을 포함할 수 있습니다. 이를 위해 디지털 서명 및 체크섬 확인 기술을 사용하여 애플리케이션 코드가 변경되지 않도록 보장할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n또한, 로컬에 저장된 모든 민감한 데이터를 암호화하는 것이 중요합니다. 안전한 암호화 라이브러리를 사용하면 데이터가 평문으로 저장되지 않아 기기가 침해당해도 민감한 정보를 보호할 수 있습니다. 예를 들어, flutter_secure_storage 패키지는 Flutter에서 데이터를 안전하게 암호화하여 저장하는 방법을 제공합니다.\n\n마지막으로, 엄격한 서버 측 보안 정책을 시행하는 것이 중요합니다. 서버가 클라이언트의 확인이나 조치와는 독립적으로 모든 요청을 유효성을 검사하도록 하는 것이 필수적입니다. 서버는 설정된 보안 기준을 충족하지 않는 요청을 거부해야 하며, 가능한 공격에 대비한 추가적인 보호층을 추가해야 합니다.\n\n## 방지 방탈림 메커니즘의 실패\n\n또 다른 중요한 점은 안드로이드 애플리케이션을 디컴파일할 때 소스 코드를 변경하고 애플리케이션을 다시 컴파일할 수 있는지 확인하는 것입니다. APKTOOL과 같은 도구를 사용하여 APK를 디컴파일하고 획득한 Java 코드를 수정할 수 있습니다. 이 과정 이후에 텍스트 편집기인 Sublime Text와 같은 도구를 사용하여 변수를 변경할 수 있었습니다. 코드를 변경한 후에는 같은 APKTOOL을 사용하여 애플리케이션을 다시 컴파일하고 서명할 수 있었습니다. 이러한 프로세스가 완료된 후 수정된 소스 코드가 재컴파일된 애플리케이션에 적용되었는지 확인할 수 있습니다.\n\n이 취약점은 공격자가 역공학을 통해 애플리케이션의 내부 작업을 이해할 수 있게 하여 보안 메커니즘에 대한 공격을 개발할 수 있는 것을 의미합니다. 공격자는 왓츠앱이나 유튜브와 같은 앱에서 현재 매우 일반적인 사용자가 보낸 메시지를 삭제하지 못하도록 막거나 광고를 표시하는 등의 미인증된 새로운 기능을 추가할 수 있으며, 데이터 유출, 회사의 평판 및 이미지 훼손, 사기까지 발생할 수 있습니다.\n\n이러한 위험을 완화하기 위해 응용 프로그램이 컴파일 중에 수행한 코드 변경을 런타임에서 감지할 수 있어야 합니다. 응용 프로그램은 침해된 환경을 식별하고 서버에 위반 사항을 보고하거나 응용 프로그램을 종료함으로써 적절히 대응해야 합니다. 이러한 조치를 구현하는 것은 방탈림 시도에 대한 응용 프로그램의 보호와 사용자 데이터의 무결성 및 보안을 보장하는 데 중요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제까지 찾아낸 몇 가지 포인트들이 있어요. Flutter 애플리케이션에서 보안에 대해 더 알아보기를 권유합니다. 제공되는 자원을 활용하고 사이버보안 워크샵, 강좌 및 포럼에 참여해보세요. 보안은 공동 책임이며, 디지털 세계의 계속 변화하는 도전에 대비하기 위해 우리 모두가 교육받고 준비되어야 합니다.\n기억하세요, 보안은 목적지가 아니라 계속되는 여정입니다. 함께 하면 Flutter 앱을 모든 사용자들을 위해 더 안전하고 안전하게 만들 수 있습니다.\n공부하고 배우고, 애플리케이션을 통해 더 안전한 디지털 미래를 만들어 봅시다.\n\n도움이 되었나요? 커피 사주시겠어요?\n\n저를 팔로우해주세요.\n\n- Linkedin: raphaelkennedy\n- Youtube: raphaelpontes\n","ogImage":{"url":"/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png"},"coverImage":"/assets/img/2024-05-18-IncreasesecurityinyourFlutterapplications_0.png","tag":["Tech"],"readingTime":5},{"title":"응용 프로그램 아키텍처 데이터 레이어","description":"","date":"2024-05-18 17:09","slug":"2024-05-18-AppArchitectureDatalayer","content":"\n![AppArchitectureDatalayer_0](/assets/img/2024-05-18-AppArchitectureDatalayer_0.png)\n\n이전 글에서는 도메인 레이어를 안정적이고 플랫폼 독립적인 레이어로 다루었습니다. 오늘은 데이터 레이어의 목적을 다루겠습니다. 함께 알아봅시다.\n\n![AppArchitectureDatalayer_1](/assets/img/2024-05-18-AppArchitectureDatalayer_1.png)\n\n데이터 레이어는 앱의 나머지 부분에 데이터를 노출하는 역할을 합니다. 다양한 데이터 소스를 관리하고 그들 사이의 충돌을 처리합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 저장소\n\n데이터 레이어는 Repository로 이루어져 있습니다. 이전 챕터에서 언급했듯이 도메인 레이어에 대해:\n\n데이터 레이어는 도메인 레이어의 저장소를 구현한 것입니다. Repository 클래스는 앱에서 처리하는 각기 다른 유형의 데이터를 나타내어야 합니다. 예를 들어:\n\n## 네이밍 규칙\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레포지토리 클래스는 담당하는 데이터를 따라 이름이 지어집니다.\n\n데이터 유형 + DataRepository와 같은 형식을 따릅니다.\n\n예를 들어 TicketRepository 인터페이스가 있으면 충돌을 피하기 위해 구현체는 TicketDataRepository로 지정됩니다.\n\n## 데이터 소스\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n레포지토리는 다양한 데이터 소스를 관리합니다 (예: 로컬, 메모리, 네트워크). 이 작업을 담당하는 구성 요소는 DataSource입니다. 이는 데이터베이스, 네트워크, ShearedPreference, WorkManager 및 파일과 같은 데이터 소스와 레포지토리 사이의 추상화입니다.\n\n- 데이터 소스는 한 번에 하나의 데이터 소스와만 작업해야 합니다.\n- 데이터 소스는 데이터 레이어를 위해 비공개이어야 하며 레포지토리를 통해서만 접근해야 합니다.\n\n## 네이밍 규칙\n\n데이터 소스 클래스는 그들이 책임지는 데이터와 사용하는 소스를 기반으로 명명됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 유형 + 소스 유형 + DataSource.\n\n데이터 유형으로는 Remote 또는 Local을 사용하여 구현이 변경될 수 있으므로 더 일반적으로 설정하세요 (예: FaresLocalDataSource 또는 FaresRemoteDataSource). 소스가 중요한 경우를 위해 소스 유형을 사용하여 더 구체적으로 설명하세요 (예: FaresNetworkDataSource 또는 FaresFileDataSource).\n\n구현 세부 정보를 기반으로한 이름을 피하세요. 예를 들어, UserSQLiteDataSource와 같이 구현 세부 정보에 기반한 이름을 사용하지 마세요. 해당 데이터 소스를 사용하는 리포지토리는 데이터가 어떻게 저장되는지 알 필요가 없습니다. 이 규칙을 따르면 데이터 소스의 구현을 변경(예: SQLite에서 DataStore로 마이그레이션)하더라도 해당 소스를 호출하는 계층에 영향을 주지 않습니다.\n\nUserApi 인터페이스는 네트워크 API 클라이언트의 구현을 숨깁니다. Retrofit 또는 GraphQL이 인터페이스를 지원하는데 차이가 없습니다. 인터페이스에 의존함으로써 앱에서 API 구현을 교체할 수 있습니다. 또한 이러한 방식은 유연성을 제공하며 의존성을 쉽게 교체할 수 있도록 합니다. 예를 들어, 테스트에서 가짜 데이터 소스 구현을 주입할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 원본은 오류 발생 시 예외 처리를 하는 좋은 위치입니다. 애플리케이션에 데이터 원본과 관련된 예외를 노출시키지 말고 대신 애플리케이션이 처리할 수 있는 예외로 매핑해야 합니다.\n\n이전에 언급했던 대로, 리포지토리는 데이터 소스와 동시성을 관리하는 데 더 중점을 둔 것입니다.\n\n위의 예시에서 보듯이, 우리는 로컬 캐시를 관리하고 로컬 및 원격 데이터 소스의 우선순위를 설정하는 전략을 구현했습니다. 리포지토리는 상태를 가질 수 있으며 예를 들어 Mutex를 사용하여 다른 스레드에서 변경 가능한 변수에 대한 읽기 및 쓰기 액세스를 관리할 수 있습니다. 따라서 리포지토리의 수명주기에 대해 고려해야 합니다.\n\n## 수명주기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가능하다면 리포지토리를 무상태로 만들 것을 권장합니다. 동시에 싱글톤으로 유지하여(instance-duplication of data sources와 같은 버그를 피하기 위해 DI를 통해 관리) 안정성을 높일 수 있습니다. DataSource도 마찬가지로 싱글톤으로 만들고 캐시는 리포지토리에서 관리하는 것을 권장합니다.\n\n## 동시성\n\n리포지토리는 어떤 CoroutineDispatcher에서 작업을 실행할지 결정해야 하는 곳입니다. 서로 다른 유형의 작업을 서로 다른 디스패처(또는 쓰레드 풀)에서 실행하는 것이 좋은 실천입니다. IO 작업을 수행하는 경우 Dispatcher.IO를 사용하는 것이 좋습니다. 테스트하기 쉽도록 클래스 생성자를 통해 디스패처를 전달해야 합니다.\n\n# 모델\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 레이어에는 도메인 레이어에서 모델을 반영하는 데이터 모델이 있지만 표현이 다를 수 있습니다. 별도의 데이터 모델을 사용하면 전송 프로토콜에 맞게 사용자 정의할 수 있는 유연성을 제공합니다. 예를 들어, 서버와 클라이언트 간의 통신에 JSON 형식을 사용하고 일부 필드는 JSON 프로토콜에 더 적합한 다른 유형을 가질 수 있습니다. 도메인 모델을 DTO로 매핑하는 로직 및 그 반대는 Repository 클래스에 배치되어야 합니다.\n\n- 데이터 레이어는 도메인 모델만 노출하고 입력으로 사용해야 합니다.\n- 데이터 모델은 Parcelable 및 Serializable와 같은 플랫폼별 직렬화 방식을 구현할 수 있습니다.\n- 사전에 모델 클래스가 정의된 경우, 한 팀의 구성원이 기능의 다른 레이어에 개별적으로 작업할 수 있습니다.\n- 이 레이어에서 노출된 데이터는 변경할 수 없어야 합니다.\n\n## 명명 규칙\n\n모델 클래스는 책임을 지는 데이터 유형의 이름으로 지어집니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n데이터 유형 + DTO.\n\n예를 들어: RyderDTO, FareDTO.\n\n# 패키지 규칙\n\n```js\ndata/\n├─ local/\n│ ├─ dto/\n│ │ ├─ FareDTO\n│ │ ├─ RyderDTO\n│ ├─ FaresLocalDataSource\n│ ├─ FaresRemoteDataSource\n├─ network/\n│ ├─ api/\n│ │ ├─ UserNetworkApi // UserApi 인터페이스의 Retrofit 구현\n│ ├─ dto/\n│ │ ├─ UserDTO\n│ ├─ UserRemoteDataSource // UserApi 인터페이스 포함\n├─ repository/\n│ ├─ FaresDataRepository\n│ ├─ RydersDataRepository\n│ ├─ TicketsDataRepository\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 마무리\n\n데이터 레이어는 도메인 레이어에 정의된 리포지토리 구현을 중심으로 구축되었습니다. 이는 데이터의 다양한 소스를 관리하고 사용하는 방법에 대한 전략을 관리하는 역할을 합니다.\n\n다음 앱 아키텍처 주제에 대해서는 계속해서 확인해보세요. 그동안 레이어 간 데이터 매핑 방법에 대해 읽어볼 수 있습니다.\n","ogImage":{"url":"/assets/img/2024-05-18-AppArchitectureDatalayer_0.png"},"coverImage":"/assets/img/2024-05-18-AppArchitectureDatalayer_0.png","tag":["Tech"],"readingTime":6},{"title":"제트팩 코파 서체에서 Window Insets 이해하기","description":"","date":"2024-05-18 17:07","slug":"2024-05-18-UnderstandingWindowInsetsinJetpackCompose","content":"\n![Image](/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png)\n\n# 인셋이란 무엇인가요?\n\n인셋은 상태 바, 네비게이션 바, 디스플레이 컷아웃(노치 또는 핀홀로 자주 불림), IME 키보드와 같은 시스템 UI 요소로 인해 화면에서 완전히 사용할 수 없는 영역을 가리킵니다.\n\n기본적으로, 우리 앱의 UI는 상태 바와 네비게이션 바와 같은 시스템 UI 내에 레이아웃되도록 제한됩니다. 이는 시스템 UI 요소가 앱의 콘텐츠를 가리지 않도록 보장합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n그렇다면 왜 우리가 모습들에 대해 걱정해야 할까요?\n\n현대 스마트폰이 엣지 투 엣지 화면과 다양한 화면 비율을 맞이하면서, 인셋(insets) 관리가 중요도를 더욱 높이고 있습니다.\n\n본질적으로, 우리는 시스템 제어를 받는 인셋 패러다임에서 개발자들이 엣지 투 엣지 디스플레이를 활성화하거나 시스템 UI 요소 뒤로 그림을 그리며 인셋 관리를 직접 제어하는 방식으로 전환 중입니다!\n\n# 시작하는 방법은?\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 초기 설정\n\n우리 앱이 콘텐츠를 그릴 영역을 완전히 제어하도록 설정해야 합니다. 이 설정을 하지 않으면 앱이 시스템 UI 뒤에 검정색이나 단색을 그리거나 소프트웨어 키보드와 동기화되지 않을 수 있습니다.\n\n- Activity onCreate에서 enableEdgeToEdge 함수를 호출합니다.\n\n이 호출은 우리 앱에 시스템 UI 뒤에 표시하도록 요청합니다. 그런 다음 앱은 해당 간격이 UI를 조정하는 데 어떻게 사용되는지를 제어합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n\n    enableEdgeToEdge()\n\n    setContent {\n        // 앱 내용을 여기에 추가합니다\n    }\n}\n```\n\n- Activity AndroidManifest.xml에서 android:windowSoftInputMode=\"adjustResize\"를 설정하세요.\n\n이 설정을 추가하면 앱이 소프트웨어 IME의 크기를 받아들일 수 있으며, 이를 사용하여 IME가 앱에서 나타나고 사라질 때 내용을 적절하게 패딩 및 정렬할 수 있습니다.\n\n```xml\n<activity\n  android:name=\".ui.MainActivity\"\n  android:label=\"@string/app_name\"\n  android:windowSoftInputMode=\"adjustResize\"\n  android:theme=\"@style/Theme.MyApplication\"\n  android:exported=\"true\">\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 앱이 현재 어떻게 보이는지 아래 코드를 통해 살펴봅시다:\n\n```js\nsetContent {\n    Box(\n        modifier = Modifier\n             .fillMaxSize()\n             .background(color = Color.DarkGray)\n       )\n}\n```\n\n![이미지](/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_1.png)\n\n컬러로 채워진 Box가 화면 전체를 채우고 시스템 바(상단 상태 바 및 하단 네비게이션 바) 뒤에 그려짐을 확인할 수 있습니다. 이것은 우리의 코드가 이제 시스템 UI 뒤에 그리는 능력을 갖추고 있고 이러한 영역을 스스로 제어할 수 있다는 것을 의미합니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 여백 제어하기\n\n시스템 UI 뒤에 표시되고 모든 여백을 수동으로 처리하는 상태인 경우, Compose API를 사용하여 앱의 상호 작용 가능한 콘텐츠가 시스템 UI와 겹치지 않도록 할 수 있습니다.\n\n이러한 API는 또한 앱의 레이아웃을 여백 변경과 동기화시킵니다.\n\n조정할 수 있는 Composable 레이아웃을 조정하기 위해 Inset 유형을 사용하는 주요 방법은 패딩 수정자와 여백 크기 수정자가 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n패딩 수정자\n\n창 인셋을 패딩으로 적용하는 방법은 Modifier.windowInsetsPadding(windowInsets: WindowInsets)를 사용할 수 있습니다. 이는 Modifier.padding와 매우 유사하게 작동합니다.\n\nWindowInsets.systemBars, WindowInsets.statusBars, WindowInsets.navigationBars 등과 같은 몇 가지 내장된 창 인셋이 있습니다. 이를 사용하여 원하는 패딩을 제공할 수 있습니다.\n\n예를 들어 이전 코드에서 상태 바와 네비게이션 바를 제외하고 회색 상자를 그리고 싶다면, 다음과 같이 할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nsetContent {\n    Box(\n        modifier = Modifier\n            .fillMaxSize()\n            .background(color = Color.LightGray)\n            .windowInsetsPadding(WindowInsets.systemBars)\n    ) {\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.DarkGray)\n        )\n    }\n}\n```\n\nModifier windowInsetsPadding(WindowInsets.systemBars)은 상단 상태 표시줄과 하단 네비게이션 바에 패딩을 추가하며, 이들은 이해를 돕기 위해 LightGray로 칠해졌습니다. 이로써 우리 앱은 다음과 같이 보일 것입니다:\n\n![이미지](/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_2.png)\n\n우리는 또한 windowInsetsPadding(WindowInsets.statusBars) 또는 windowInsetsPadding(WindowInsets.navigationBars)를 사용하여 이러한 Insets를 별도로 제어할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가장 일반적인 종류의 Insets에 대한 많은 내장 메소드도 있습니다. 예를 들어:\n\n- safeDrawingPadding(), windowInsetsPadding(WindowInsets.safeDrawing)에 해당하는 메소드\n- safeContentPadding(), windowInsetsPadding(WindowInsets.safeContent)에 해당하는 메소드\n- safeGesturesPadding(), windowInsetsPadding(WindowInsets.safeGestures)에 해당하는 메소드\n\nInset 크기 조정기\n\n이러한 조정기는 컴포넌트의 크기를 insets의 정확한 크기로 설정하는 데 도움을 줍니다. Spacer 크기를 설정하는 데 유용합니다.Inset 크기를 차지하면서 화면을 만들 때 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n예를 들어, Inset 크기 수정자를 사용하여 상태 표시줄과 내비게이션 바에 패딩을 제공하도록 마지막 코드를 다음과 같이 작성할 수 있습니다. 이렇게 하면 동일한 결과가 생성됩니다.\n\njs\nsetContent {\nColumn {\nSpacer(\nmodifier = Modifier\n.fillMaxWidth()\n.background(color = Color.LightGray)\n.windowInsetsTopHeight(WindowInsets.statusBars)\n)\nBox(\nmodifier = Modifier\n.fillMaxSize()\n.background(color = Color.DarkGray)\n.weight(1f)\n)\nSpacer(\nmodifier = Modifier\n.fillMaxWidth()\n.background(color = Color.LightGray)\n.windowInsetsBottomHeight(WindowInsets.navigationBars)\n)\n}\n}\n\n이전과 같이 DarkGrey Box에 Insets 패딩을 추가하는 대신, 상태 표시줄과 내비게이션 바의 정확한 크기를 차지하는 LightGray Spacer를 추가했습니다.\n\n## 키보드 IME와 함께 구성 요소 패딩 크기 조정\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n가끔 키보드 IME가 열려 있는지 닫혀 있는지에 따라 UI 컴포넌트에 동적 패딩을 적용하고 싶을 때가 있습니다. 좋은 사용 사례는 목록 맨 아래에 입력 필드를 추가하는 경우입니다.\n\n다음과 같은 코드를 고려해보세요:\n\n```js\nsetContent {\n    Column(\n        modifier = Modifier.fillMaxSize().systemBarsPadding()\n    ) {\n        LazyColumn(\n            modifier = Modifier.weight(1f),\n            reverseLayout = true\n        ) {\n            items(100) { index ->\n                Text(text = \"Item $index\", modifier = Modifier.padding(16.dp).fillMaxWidth())\n            }\n        }\n\n        var textFieldValue by remember { mutableStateOf(TextFieldValue()) }\n\n        TextField(\n            modifier = Modifier.fillMaxWidth(),\n            value = textFieldValue,\n            onValueChange = { textFieldValue = it },\n            placeholder = {\n                Text(text = \"Type something here\")\n            }\n        )\n    }\n}\n```\n\n만약 TextField의 패딩을 처리하지 않는다면:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![Keyboard Opening](https://miro.medium.com/v2/resize:fit:600/1*8HIx9O4S3Lk3mpUJRqI21g.gif)\n\n키보드가 열릴 때 텍스트 필드가 화면 하단에 고정되어 있어서 사용자 경험이 그리 좋지 않음을 볼 수 있습니다.\n\n텍스트 필드 패딩을 조정한 후:\n\n위의 텍스트 필드에는 단순히 `imePadding()` 수정자를 추가하면 됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이제 코드는 다음과 같이 보입니다:\n\n```js\n// 이전 코드와 동일\n\nTextField(\n    modifier = Modifier.fillMaxWidth().imePadding(), // IME 패딩 추가\n    value = textFieldValue,\n    onValueChange = { textFieldValue = it },\n    placeholder = {\n        Text(text = \"여기에 무언가를 입력하세요\")\n    }\n)\n```\n\n이제 TextField 패딩이 변경되며 또한 IME의 상태 변화와 함께 애니메이션되어 입력 필드가 키보드와 함께 이동하는 효과를 만듭니다:\n\n<img src=\"https://miro.medium.com/v2/resize:fit:600/1*IQIdBM5ovhwMcHmJ0qCOZQ.gif\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 스크롤할 때 키보드 IME를 애니메이션화하자:\n\n스크롤 컨테이너에 추가하는 실험적 API 수정자 imeNestedScroll()가 있습니다. 이 수정자를 스크롤 컨테이너에 추가하면 컨테이너의 맨 아랫부분으로 스크롤할 때 키보드가 애니메이션으로 열립니다.\n\n위 코드를 수정해서 LazyColumn에 이 수정자를 추가하면 다음과 같습니다:\n\n```js\n// 위 코드와 같음\n\nLazyColumn(\n    modifier = Modifier.weight(1f).imeNestedScroll(), // 수정자 추가\n    reverseLayout = true\n) {\n\n// 이전과 같은 코드\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래와 같이 경험을 제공할 예정입니다:\n\n![image](https://miro.medium.com/v2/resize:fit:600/1*dciSCS0k29yCh1Z4lAM85A.gif)\n\n# 패딩 소비\n\n이제 이 시점에서 우리 마음 속에 몇 가지 질문이 떠오를 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n어떤 내부 삽입 패딩 수정자(예: safeDrawingPadding())를 고려할 때, Composable 계층 구조에서 이를 한 번만 적용해야 할까요? 한 번 이상 적용하면 어떻게 되나요? 부모에 적용한 다음에 하위 자식에 다시 적용하면 패딩이 두 번 추가될까요?\n\n내장된 삽입 패딩 수정자는 자동으로 적용된 인셋의 일부를 패딩으로 사용합니다. 구성 트리를 깊게 들어가면, 중첩된 삽입 패딩 수정자와 자식 Composable에 적용된 인셋 크기 조절 수정자는 외부 수정자에 의해 이미 소비(또는 적용 또는 고려)된 인셋의 일부를 알고 있어 해당 인셋을 다시 적용하지 않고 건너뛰어 중복 공간을 피합니다.\n\n이를 이해하기 위해 예시를 살펴봅시다:\n\n```js\nsetContent {\n    var textFieldValue by remember { mutableStateOf(TextFieldValue()) }\n    LazyColumn(\n        Modifier.windowInsetsPadding(WindowInsets.statusBars).imePadding()\n    ) {\n        items(count = 30) {\n            Text(\n                modifier = Modifier.fillMaxWidth().padding(16.dp),\n                text = \"Item $it\"\n            )\n        }\n        item {\n            TextField(\n                modifier = Modifier.fillMaxWidth().height(56.dp),\n                value = textFieldValue,\n                onValueChange = { textFieldValue = it },\n                placeholder = { Text(text = \"Type something here\") }\n            )\n        }\n        item {\n            Spacer(\n                Modifier.windowInsetsBottomHeight(\n                    WindowInsets.systemBars\n                )\n            )\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 코드는 LazyColumn에 긴 항목 목록을 표시합니다. 목록의 맨 아래에는 사용자 입력을 위한 TextField가 있고, 끝에는 창 간격 크기 수정자를 사용하여 하단 시스템 내비게이션 바에 공간을 제공하는 Spacer가 있습니다. 또한 LazyColumn에 imePadding이 적용되어 있습니다.\n\n여기서 키보드가 닫힌 경우 IME의 높이가 없어 imePadding() 수정자가 패딩을 적용하지 않습니다. 따라서 인셋이 사용되지 않고, 이 때 Spacer의 높이는 하단 시스템 바의 크기가 됩니다. 키보드가 열리면 IME 인셋이 IME의 크기에 맞도록 애니메이션화되며 imePadding() 수정자가 LazyColumn에 하단 패딩을 적용하기 시작합니다. 결과적으로 해당 인셋량도 \"소비\"하기 시작합니다.\n\n이제 이 시점에서 imePadding() 수정자에 의해 하단 시스템 바의 일부 여백이 이미 적용되어 Spacer의 높이가 감소하기 시작합니다. 어느 시점에서는 IME 패딩 크기가 하단 시스템 바의 크기를 초과하여 Spacer의 높이가 제로가 됩니다. 키보드가 닫히면 동일한 메커니즘이 반대로 발생합니다.\n\n이 동작은 모든 windowInsetsPadding 수정자 간의 통신을 통해 달성됩니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 코드가 작동하는 방식을 확인해보세요:\n\n![Code](https://miro.medium.com/v2/resize:fit:600/1*8ZLXFWRuKcZXvPtRmjxPJQ.gif)\n\n또 다른 예시를 살펴보겠습니다:\n\n이 예시에서는 Modifier.consumedWindowInsets(insets: WindowInsets)를 살펴보겠습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 수정자는 Modifier.windowInsetsPadding과 같은 방식으로 패딩을 소비하기 위해 사용됩니다. 그러나 소비된 인셋을 패딩으로 적용하지 않습니다.\n\n다른 수정자인 Modifier.consumedWindowInsets(paddingValues: PaddingValues)은 임의의 PaddingValues를 소비합니다.\n\n인셋 패딩 수정자가 아닌 일반 Modifier.padding 또는 고정 높이 간격과 같은 다른 메커니즘으로 패딩 또는 간격을 제공할 때 자식에게 알리는 데 유용합니다.\n\n다음 코드를 참고하세요:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```kotlin\nsetContent {\n    Scaffold { innerPadding ->\n        // innerPadding에는 사용하고 적용할 인셋 정보가 포함되어 있습니다\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.LightGray)\n                .padding(innerPadding)\n        ) {\n            Box(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .background(color = Color.Red)\n                    .windowInsetsPadding(WindowInsets.safeDrawing)\n            ) {\n                Box(\n                    modifier = Modifier\n                        .fillMaxSize()\n                        .background(color = Color.DarkGray)\n                )\n            }\n        }\n    }\n}\n```\n\n이 코드의 결과는 다음과 같이 보일 것입니다:\n\n<img src=\"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_3.png\" />\n\n우리는 이 결과물에 문제가 있는 것을 볼 수 있습니다. Scaffold 람다에서 얻은 innerPadding을 바깥 Box에 패딩으로 적용했지만, 내부 Box의 windowInsetsPadding(WindowInsets.safeDrawing)은 중복 패딩(빨간색으로 나타남)을 생성합니다. 즉, 어떤 이유로 인해 여기에서 인셋 소비가 발생하지 않았다는 의미입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n기본적으로 Scaffold는 우리가 사용하고 활용할 수 있는 insets를 매개변수 paddingValues로 제공합니다. Scaffold는 콘텐츠에 insets를 적용하지 않으며, 이 책임은 우리에게 있습니다.\n\n따라서 우리가 이중 패딩을 피하고 싶다면, consumeWindowInsets(innerPadding) 수정자를 사용하여 패딩을 직접 소비해야 합니다.\n\n다음은 업데이트된 코드를 고려해보세요:\n\n```js\nsetContent {\n    Scaffold { innerPadding ->\n        // innerPadding은 사용하고 적용할 인셋 정보를 포함합니다\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .background(color = Color.LightGray)\n                .padding(innerPadding)\n                // 이 인셋을 소비하여, 아래 계층에서 safeDrawing을 사용할 때 다시 적용되지 않도록 합니다\n                .consumeWindowInsets(innerPadding)\n        ) {\n              // 나머지 코드\n          }\n        }\n    }\n}\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n위의 내용을 한국어로 다음과 같이 번역하면 됩니다:\n\n이렇게 작성하면 됩니다:\n\n<img src=\"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_4.png\" />\n\n그러므로 innerPadding이 outer Box에 의해 소비되면 inner Box의 windowInsetsPadding(WindowInsets.safeDrawing)에 중복 패딩이 적용되지 않습니다.\n\n이로써 이 기사는 마칩니다!\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n이 글을 통해 많은 개발자들이 Insets의 필요성에 대해 이해하고, 효과적으로 활용하는 방법을 배울 것이라 확신합니다.\n\n모든 예시는 다음 저장소에서 확인할 수 있습니다: [https://github.com/pushpalroy/ComposeInsetsPlayground](https://github.com/pushpalroy/ComposeInsetsPlayground)\n\n팔로우 하기: @pushpalroy\n","ogImage":{"url":"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png"},"coverImage":"/assets/img/2024-05-18-UnderstandingWindowInsetsinJetpackCompose_0.png","tag":["Tech"],"readingTime":17},{"title":"AWS에 LLM 앱을 배포하는 오픈소스 셀프 서비스 방법","description":"","date":"2024-05-18 17:04","slug":"2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay","content":"\n![LLM](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png)\n\nLLM 어플리케이션은 OpenAI와 같은 타사 호스팅 LLM을 사용하도록 개발되었을 때 MLOps 오버헤드가 필요하지 않습니다. 이러한 컨테이너화된 LLM 파워드 앱 또는 마이크로서비스는 DevOps 관행을 따르며 배포할 수 있습니다. 본 문서에서는 우리의 LLM 앱을 AWS와 같은 클라우드 제공업체에 자동으로 배포하는 방법을 탐색해보겠습니다. LlamaIndex는 커뮤니티를 위한 준비된 RAGs 챗봇을 보유하고 있습니다. 우리는 샘플 앱으로 RAGs를 사용하겠습니다.\n\n# IaC Self-Service\n\nIaC는 Infrastructure as Code의 줄임말로 인프라 프로비저닝을 자동화하여 구성이 일관성 있고 반복 가능하게 보장합니다. IaC를 실행할 수 있는 여러 도구들이 있습니다. 본 문서에서는 Terraform을 중점으로 다룰 것인데, Terraform은 클라우드에 중립적인 특성을 가지고 있기 때문입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nIaC self-service의 주요 목적은 개발자들이 더 많은 액세스, 제어 및 소유권을 통해 파이프라인에 대한 생산성을 향상시키는 데 도움을 주는 것입니다.\n\n관심 있으신 분들을 위해, 약 1년 전에 DevOps self-service 모델에 관한 5부작 시리즈를 작성했습니다. DevOps self-service 모델에 관련된 모든 측면에 대해 자세히 다루었습니다.\n\n# 고수준 배포 다이어그램\n\nAWS에 컨테이너화된 응용 프로그램을 배포하는 다양한 옵션이 있습니다. ECS Fargate는 몇 가지 좋은 이유로 눈에 띕니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 컨테이너용 서버리스 컴퓨팅, 서버 관리 없이 가능\n- 확장성과 확장성 증가\n- 배포 간소화\n\n먼저 RAGs 앱을 위한 고수준 배포 다이어그램을 작성합니다.\n\n![image](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_1.png)\n\nAWS에 RAGs를 배포하려면 파이프라인이 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 파이프라인 개요\n\n먼저, 내가 만든 3-2-1 규칙을 기반으로 한 자가 서비스 파이프라인 아키텍처를 탐색해보겠습니다:\n\n- 3가지 유형의 소스 코드: Terraform 코드, 앱 소스 코드 및 GitHub Actions 워크플로 코드.\n- 2가지 유형의 파이프라인: 인프라 파이프라인 및 애플리케이션 파이프라인.\n- 1개의 파이프라인 통합 글루: GitHub Secrets 생성 자동화.\n\n![image](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_2.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n자, 한번 자세히 살펴봅시다.\n\n# 인프라 파이프라인\n\n저희는 인프라 파이프라인에서 terraform init, terraform plan, terraform apply 등 테라폼의 핵심 기능을 사용합니다. 아래 다이어그램을 참조해주세요. 2023년 8월 테라폼의 라이센스 변경에도 불구하고, 테라폼의 핵심 기능은 여전히 오픈 소스로 유지됩니다.\n\nterraform init 이전에 몇 가지 단계를 추가합니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 워크플로우 보안을 위한 Harden Runner\n- 클라우드 비용 관리를 위한 Infracost\n- 린트를 위한 TFLint\n- 정적 IaC 코드 분석을 위한 Checkov\n\n이러한 도구에 대한 자세한 내용은 파이프라인 보안 및 가드레일에 관한 제 논문을 확인해주세요.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_3.png)\n\n우리는 Terraform에서 IaC 코드를 처음부터 작성해야 할까요? 아닙니다. 잘 알려진 오픈 소스 Terraform 재사용 가능한 모듈인 terraform-aws-modules를 활용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## Terraform AWS 모듈\n\nterraform-aws-modules은 AWS에서 리소스를 관리하기 위해 명시적으로 설계된 사전 제작, 재사용 가능한 오픈 소스 Terraform 모듈의 다양한 모음입니다. Anton Babenko가 이끄는 terraform-aws-modules는 지금까지 57개의 모듈을 보유하고 있습니다! 이러한 모듈은 AWS에서 인프라 프로비저닝을 간소화하고 자동화하며, 모범 사례를 표준화하고, 인프라 코드를 작성하는 데 덜 신경 쓰고 빠른 배포를 달성할 수 있도록 돕습니다.\n\nGCP의 경우 terraform-google-modules, Azure의 경우 Azure-Verified-Modules가 있습니다.\n\n자신만의 재사용 가능한 모듈을 작성할 수도 있지만, 이 오픈 소스 재사용 가능한 모듈은 커뮤니티에서 지원하고 테스트됩니다. 인프라 파이프라인 개발을 빠르게 시작하는 데 유용합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리 RAGs 앱을 위해, 새 AWS 계정에 배포할 예정이며, terraform-aws-modules에서 다음 모듈들을 최소한으로 선택할 것입니다. \"최소한\" 이라고 말한 이유는 프로젝트 요구에 따라 추가로 리소스를 이 스택에 추가할 수 있습니다. 예를 들어 인증/인가 등을 위한 리소스 등이 있습니다. 그러나 이 POC 데모 앱에서는 자가 서비스 모델을 보여주고 오픈소스 IaC 재사용 가능 모듈을 소개하기 위해 최소 요구 사항을 준수할 것입니다. 두 가지 재료를 숙지하면 프로젝트 요구에 따라 추가 리소스를 프로비저닝하기 위해 재사용 가능 모듈을 선택하실 수 있습니다.\n\n![링크](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_4.png)\n\n- terraform-aws-vpc: 새 VPC, 공용/개인 서브넷, 인터넷 게이트웨이, NAT 게이트웨이, 경로 테이블 등을 프로비저닝하는 네트워킹 모듈입니다.\n- terraform-aws-s3-bucket: ALB 로그용 S3 버킷.\n- terraform-aws-alb: ECS 클러스터용 응용 프로그램 로드 밸런서 (ALB).\n- terraform-aws-ecs: RAGs를 배포할 ECS 클러스터에 대한 Elastic Container Service (ECS) Fargate 인스턴스.\n- terraform-aws-ecr: 앱용 도커 이미지를 저장하는 Elastic Container Registry (ECR).\n\n## 구현 전 요구 사항\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- AWS에서 OpenID Connect (OIDC) 구성: 우리는 GitHub Actions 워크플로를 사용하여 인프라 프로비저닝을 위한 Terraform 모듈을 시작할 것입니다. OIDC는 AWS 자격 증명을 GitHub 측에 저장하지 않고 GitHub Actions 워크플로가 AWS에 액세스할 수 있도록 합니다. GitHub에는 AWS에서 OIDC를 구성하는 방법에 대한 자세한 지침이 있습니다. 이 단계는 한 번만 AWS 계정당 수행하면 됩니다.\n- Terraform 원격 상태 관리: 인프라 상태는 Terraform 작업의 중요한 부분이며, 실제 세계 리소스를 구성에 매핑하고 메타데이터를 추적하여 대규모 인프라에서 성능을 향상시킵니다. Terraform 원격 상태를 사용하면 사용자가 인프라 상태를 원격 데이터 저장소에 저장하여 중앙 집중화, 보안, 일관성 및 기타 이점을 얻을 수 있습니다. 이 단계도 한 번만 AWS 계정당 수행하면 됩니다. 나는 원격 상태 관리를 위해 S3 버킷과 상태 잠금을 위한 DynamoDB를 통해 처리하는 Terraform 재사용 가능한 모듈을 개발했습니다. 소스 코드는 내 GitHub 리포지토리에 있습니다. 시작하려면 내 샘플 워크플로와 유사한 GitHub Actions 워크플로를 사용할 수 있습니다. GitHub Actions를 익숙하지 않은 경우 \"Application Pipelines\" 섹션을 참조하세요.\n\n## 단계 1: GitHub 환경 생성\n\nGitHub 환경은 시크릿/변수를 세 가지 레벨에서 저장할 수 있어서 파이프라인에서 인프라 프로비저닝 또는 애플리케이션 CI/CD 중에 시크릿/변수를 전달하여 파이프라인 작업을 돕는 중요한 역할을 합니다.\n\n우리의 RAGs 앱을 위해 dev라는 GitHub 환경을 만들고 애플리케이션 파이프라인을 위한 ROLE_TO_ASSUME과 인프라 파이프라인을 위한 TERRAFORM_ROLE_TO_ASSUME 두 환경 변수를 생성해보겠습니다. 이 때 값은 이미 상위 섹션의 사전 준비 지침을 따라 IAM 역할을 만들었다고 가정하고 각각의 IAM 역할 ARN으로 지정해주세요. 여기서 두 가지 다른 역할을 사용하는 이유는 서로 다른 권한을 할당할 수 있기 때문입니다. 참고로, \"Settings\" 탭을 보려면 레포지토리에서 관리자 권한이 필요합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_5.png\" />\n\n동일한 \"설정\" 탭 아래에서 우리는 저장소 수준에서 몇 가지 비밀을 생성합니다. 이는 동일한 앱에 대해 다른 환경에 적용할 수 있음을 의미합니다.\n\n<img src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_6.png\" />\n\n- NPM_TOKEN: 이 토큰이 필요한 이유는 애플리케이션이 Terraform 재사용 모듈을 호출할 때 이러한 자격 증명을 전달하지 않기 때문입니다. Terraform 재사용 모듈을 호출하는 앱이 Terraform 재사용 모듈이 있는 저장소에 연결하려면 저장소 범위의 토큰이 필요합니다. 특히 저장소가 개인 저장소인 경우 이것은 매우 중요합니다.\n- PIPELINE_TOKEN: 이 토큰은 Terraform이 GitHub 제공자를 호출하여 ECS_CLUSTER, ECS_SERVICE 등과 같은 GitHub 시크릿/변수를 자동으로 생성하게 하는 데 필요합니다. Terraform이 프비저단할 리소스를 기반으GitHub 시크릿/변수 생성의 자동화는 인프라 파이프라인을 애플리케이션 파이프라인과 통합하여 인프라 제공과 애플리케이션의 CI/CD 사이를 완벽하게 이어줍니다. 이 토큰은 저장소 및 read:public_key 스코프를 가져야 합니다.\n- OPENAI_KEY: 여기에는 OpenAI API 키를 저장합니다. 여기에 비밀로 저장되면 소스 코드에 노출되지 않습니다. CI 파이프라인에 이 비밀을 검색하여 전달하는 방법은 \"애플리케이션 파이프라인\" 섹션에서 자세히 살펴볼 것입니다.\n- INFRACOST_API_KEY: Infracost의 API 키입니다. 이는 클라우드 비용 관리를 자동화하는 인프라 비용 관리 도구로 사용될 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 2: 인프라 파이프라인 코드 추가\n\n마지막으로, 우리의 인프라 파이프라인 코드를 리포지토리에 추가해 봅시다. 아래 파일/폴더와 관련된 인프라 파이프라인을 확인해보세요. 샘플 코드는 내 리포지토리에서 확인할 수 있습니다. 이렇게 구성된 우리의 Terraform 코드가 왜 이런 구조를 갖는지에 대해 자세히 알아보려면 Terraform 프로젝트 구조에 대한 내 기사를 참고하세요.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_7.png)\n\nmain.tf 파일은 Terraform 재사용 가능 모듈을 위한 주요 래퍼입니다. 귀하의 스택에 따라 이 파일에서 한 개 이상의 재사용 가능 모듈을 호출할 수 있습니다. 우리의 RAGs 앱의 경우, 우리는 인프라를 프로비저닝하기 위해 terraform-aws-modules 섹션에서 언급된 다섯 개의 재사용 가능 모듈을 호출합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nterraform-aws-modules의 각 재사용 가능한 모듈에 대해 해당 모듈의 사용 패턴에 대한 예제 코드를 참조하십시오. 사용 사례에 따라 단순 또는 완전한 예제 중 하나를 선택하여 해당 재사용 가능한 모듈을 main.tf의 기반이로 사용할 수 있습니다.\n\n그런 다음, 샘플 예제 코드를 매개변수화하여 특정 환경의 terraform.tfvars 파일 아래 .env 폴더로 변수를 외부화합니다. 예를 들어, 프로덕션 환경의 CPU/메모리 값은 개발 환경에서 사용되는 값과 다를 가능성이 높습니다. 따라서 CPU/메모리는 매개변수화하기에 좋은 후보입니다.\n\n아래와 같이 ECS 프로비저닝을 위한 샘플 Terraform 코드의 주요 요소 몇 가지를 살펴보겠습니다.\n\n- Line 174는 우리가 재사용 가능한 모듈 terraform-aws-ecs를 호출하는 곳입니다.\n- Line 177 이후는 클러스터 이름과 같은 변수를 재사용 가능한 모듈로 전달하는 곳입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_8.png\" />\n\n귀하의 사용 사례에 따라, 비슷한 AWS 스택을 공유하는 많은 애플리케이션이 있다면 main.tf의 대부분 로직을 중앙 집중형 재사용 가능한 모듈 리포지토리로 이동하여 원래 terraform-aws-modules 위에 또 다른 추상화 레이어를 구현할 수 있습니다. 이 접근 방식은 IaC 코드의 추가 재사용성을 허용하여 호출자 리포지토리가 매개변수화를 위한 최소한의 IaC 코드를 갖도록 합니다. 제가 작성한 Terraform 프로젝트 구조에 대한 기사에서는 이와 같은 중앙 리포지토리가 조직 내에서 재사용 가능한 모듈을 보유하는 구현 방법을 자세히 설명하고 있습니다. 확인해보세요.\n\n## 단계 3: 인프라 파이프라인을 위한 GitHub Actions 워크플로우 추가\n\n테라폼 프로비저닝을 위한 재사용 가능한 GitHub Actions 워크플로우를 만들었습니다. 워크플로우 보안, 클라우드 비용 관리, IaC 린팅, 스캔 및 마지막으로 terraform init, plan, apply와 같은 단계를 포함하고 있습니다. 이는 샘플 워크플로우로, 귀하의 요구에 맞게 수정할 수 있습니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 RAGs 리포지토리에서 .github/workflows 디렉토리 아래에 terraform-aws.yml을 추가했습니다. 이 워크플로우의 주요 로직은 아래 빨간색으로 강조된 부분입니다:\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_9.png)\n\n- permissions: GitHub Actions 워크플로우가 OIDC를 사용하여 AWS에 인증할 수 있도록 id-token: write를 명시하는 것이 중요합니다.\n- uses: 이 줄은 재사용 가능한 워크플로우를 호출하며, 동일한 로직을 다른 워크플로우 또는 다른 리포지토리로부터 중복으로 작성하는 것을 방지합니다.\n- secrets: inherit: 이 줄은 환경/리포지토리/조직 수준에서 구성된 secrets/변수를 다른 리포지토리의 재사용 가능한 워크플로우로 전달할 수 있게 합니다.\n\n## 단계 4: 인프라스트럭처 파이프라인 시작\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n지금, 모든 일이 순조롭게 진행 중이에요. RAGs 저장소에서 \"Terraform AWS 프로비저닝\" 워크플로를 트리거하여 인프라 파이프라인을 시작해 봅시다.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_10.png)\n\n이 워크플로는 저희 개발 환경에서 AWS 자원을 프로비저닝할 거에요. 완료되면 Terraform Apply 단계에서 나오는 결과를 주의 깊게 확인해 주세요. 아래 스크린샷을 참고해 주세요. 나중에 RAGs 앱을 실행할 때 alb_dns 값을 사용할 거에요. 이 값을 메모해 두세요.\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_11.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\nAWS에 로그인하여 VPC 리소스 맵을 확인해 보세요. 아래 스크린샷을 참조하세요. 네트워킹 (VPC, 서브넷, 라우팅 테이블 등)가 성공적으로 프로비저닝되었습니다. 또한 새로운 ECS 클러스터, ECR, ALB가 준비되었는지 확인하세요.\n\n![AWS 스크린샷](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_12.png)\n\n# 애플리케이션 파이프라인 (CI/CD)\n\n이제 AWS에서 앱을 배포할 수 있는 인프라가 준비되었습니다. 새로 구성된 ECS 클러스터로 앱을 빌드하고 배포하는 것으로 넘어갑시다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래 다이어그램은 CI (Continuous Integration) 파이프라인의 주요 단계를 나열한 것입니다.\n\n![CI Pipeline](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_13.png)\n\n그리고 우리의 샘플 CD (Continuous Deployment) 파이프라인은 다음과 같습니다:\n\n![CD Pipeline](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_14.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 단계 1: 앱을 컨테이너화하세요 (컨테이너화되어 있지 않은 경우)\n\n먼저 RAGs 리포지토리에 Dockerfile을 추가하여 코드를 Docker 이미지로 빌드하고 AWS의 새로 프로비저닝된 ECR에 푸시해야 합니다. 아래 예시 Dockerfile 스니펫을 참조해 주세요.\n\n```js\nFROM python:3.9-slim\n\nWORKDIR /app\nCOPY requirements.txt requirements.txt\nCOPY . .\n\nRUN pip install -r requirements.txt\n\nEXPOSE 8501\nCMD [\"streamlit\", \"run\", \"1_🏠_Home.py\"]\n```\n\n## 단계 2: CI/CD를 위한 GitHub Actions 워크플로우 추가\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n개발 목적으로 CI/CD를 하나의 단일 워크플로에 통합할 수 있습니다. 그러나 실제로는 특히 고급 환경에서는 이미지 불변성을 보장하기 위해 CI/CD를 두 개의 다른 워크플로로 분리하는 것이 좋습니다. GitHub Actions 워크플로 오케스트레이션에 대해 더 자세히 확인하려면 제 GitHub Actions 워크플로 조정에 대한 글을 참조하세요.\n\nCI 및 CD를 처리하는 두 가지 재사용 가능한 GitHub Actions 워크플로를 만들었습니다:\n\n- python-build-image.yml: Python 앱을 위한 도커 이미지를 빌드합니다.\n- deploy-to-ecs.yml: 도커 이미지를 AWS ECS Fargate에 배포합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n아래는 이미지 빌드 워크플로우에서의 단계로, 워크플로우는 인프라 파이프라인의 단계 1에서 정의된 GitHub 리포지토리 시크릿을 통해 OpenAI API 키를 검색한 후, 해당 키를 .streamlit 디렉토리 아래의 secrets.toml 파일에 작성합니다. 시크릿 처리를 CI 파이프라인에 위임함으로써 API 키와 같은 시크릿을 관리할 때 걱정 없이 사용할 수 있습니다. API 키와 같은 시크릿을 소스 코드에 절대로 푸쉬하면 안 됩니다.\n\n<img src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_15.png\" />\n\n## 단계 3: CI/CD 파이프라인 시작\n\n코드 푸시 또는 PR 생성/병합에 의해 CI/CD 파이프라인이 자동으로 트리거되는 것이 좋습니다. GitHub Actions의 주요 장점 중 하나는 GitHub 레포지토리와 원활하게 통합되어 있기 때문에 이와 같이 작동합니다. 워크플로우에서 샘플 트리거는 다음과 같이 정의할 수 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\non:\npush:\nbranches: - main\npull_request:\n\n이제 애플리케이션 파이프라인을 시작할 시간입니다. 도커 이미지를 빌드하고 ECS에 배포하기 위해 수동으로 실행하거나 코드를 푸시/PR합니다. 아래에 성공적인 CI/CD 워크플로우 실행을 확인하세요.\n\n![CI/CD Workflow](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_16.png)\n\n## 단계 4: RAGs 앱 시작하기\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n우리의 RAGs 앱을 시작할 시간이에요. 이제 AWS ECS Fargate에 성공적으로 배포되었어요. 이전에 Terraform Apply 단계에서 인프라 파이프라인의 출력을 기억하시나요? 그 URL을 입력하여 RAGs 앱을 시작해보세요. 잘 작동할 거예요!\n\n![이미지](/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_17.png)\n\n# 제거 및 정리\n\n마지막으로, AWS 리소스를 제거하고 정리해야 해요. 우리의 Terraform GitHub Actions 워크플로 파일에는 제거를 위한 대체 플로우가 구축되어 있어요. 제거 워크플로우는 앱의 제거 브랜치를 생성하고 해당 브랜치를 선택하여 Terraform 워크플로우를 트리거함으로써만 실행될 수 있어요. 이와 같은 활동을 위해 별도의 제거 브랜치를 만드는 이유는 사용자가 제거 작업을 실수로 트리거하지 않도록 보호하는 추가적인 안전 장치를 제공하기 위함이에요. 아래 스크린샷을 보고 Terraform AWS 프로비저닝 워크플로우를 트리거하여 AWS 리소스를 제거해보세요.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n<img src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_18.png\" />\n\n# 주요 end-to-end 구현 포인트\n\n저희의 파이프라인의 주요 end-to-end 구현 포인트를 GitHub 저장소, GitHub Actions 워크플로우 및 Terraform 코드에서 살펴봅시다. 다음 다이어그램은 코드부터 구성, 통합 지점까지의 end-to-end 흐름을 강조합니다.\n\n<img src=\"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_19.png\" />\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n# 요약\n\n본 기사에서는 DevOps 셀프 서비스 모델을 사용하여 LlamaIndex의 RAGs 챗봇을 AWS ECS fargate에 배포하는 방법을 탐색했습니다. MLOps를 필요로 하지 않는 LLM 기반 앱의 경우, DevOps 셀프 서비스 모델을 사용하여 AWS와 같은 클라우드 제공업체에 배포하는 데 탁월하게 작동합니다.\n\n이 셀프 서비스 모델이 제공하는 파이프라인 프레임워크와 terraform-aws-modules와 같은 다양한 오픈 소스 IaC 재사용 모듈을 결합하면 프로젝트 요구 사항에 따라 재사용 가능한 모듈을 혼합하여 파이프라인에 대한 더 많은 액세스, 제어 및 소유권을 확보하여 생산성을 높일 수 있습니다.\n\n본 기사가 도움이 되었기를 바랍니다. 이 프레임워크의 완전한 소스 코드는 제 GitHub 저장소에 있습니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- https://github.com/wenqiglantz/reusable-workflows-modules\n- https://github.com/wenqiglantz/rags\n\n코딩을 즐기세요!\n\n## 참고 자료:\n\n- terraform-aws-modules GitHub 저장소\n- 아마존 웹 서비스에서 OpenID Connect 구성\n- 개발 운영자동화(Self-Service)로 향하는 길: 5부작 시리즈\n- 개발 운영자동화(Self-Service) 중심의 파이프라인 통합\n- 개발 운영자동화(Self-Service) 중심의 파이프라인 보안 및 가드레일\n- 개발 운영자동화(Self-Service) 중심의 GitHub Actions 워크플로 오케스트레이션\n- 개발 운영자동화(Self-Service) 중심의 Terraform 프로젝트 구조\n- 개발 운영자동화(Self-Service) 파이프라인 아키텍처와 3-2-1 규칙\n- Infracost + Terraform + GitHub Actions = 클라우드 비용 관리 자동화\n","ogImage":{"url":"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png"},"coverImage":"/assets/img/2024-05-18-DeployingLLMAppstoAWStheOpen-SourceSelf-ServiceWay_0.png","tag":["Tech"],"readingTime":19},{"title":"테라폼 DevOps 안내서 테라폼 CLI 명령어 및 치트 시트","description":"","date":"2024-05-18 17:01","slug":"2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet","content":"\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png)\n\n# 목차\n\n- 목차\n- Terraform CLI 및 명령어 치트 시트\n  - 초기화:\n  - 구성 관리:\n  - 인프라 관리:\n  - 상태 관리:\n  - 워크스페이스:\n  - 로그:\n  - 로그 레벨 활성화 및 제어:\n  - 로그 파일 지정:\n  - 셸 명령으로 로그 캡처:\n  - 다른 유용한 명령어:\n  - 추가 팁:\n- 결론\n- 나에 대해\n- 참고 문헌\n\n# Terraform CLI 및 명령어 치트 시트\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n테라폼 명령어는 인프라를 자동으로 프로비저닝하고 관리합니다. 이를 통해 수동으로 구성 작업을 줄이고 시간을 절약하며 오류를 줄일 수 있습니다.\n\n테라폼은 인프라를 코드로 관리하기 위한 다양한 명령어를 제공합니다.\n\n아래는 자주 사용되는 명령어에 대한 빠른 참조 가이드입니다:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 초기화:\n\n- terraform init: 플러그인을 다운로드하고 백엔드 구성을 수행하여 작업 디렉토리를 초기화합니다.\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_2.png)\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_3.png)\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 구성 관리:\n\n- terraform fmt: Terraform 구성 파일을 가독성 있게 형식화합니다.\n- terraform validate: Terraform 구성 구문을 유효성 검사합니다.\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_4.png)\n\n## 인프라 관리:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- terraform plan: 인프라 변경에 대한 자세한 실행 계획을 생성합니다.\n- terraform apply: 계획된 인프라 변경을 계획에 따라 적용합니다.\n- terraform apply -auto-approve: 확인 프롬프트 없이 계획을 적용합니다 (주의하여 사용해주세요!).\n- terraform destroy: Terraform 구성에 따라 기존 인프라를 파괴합니다.\n- terraform destroy -auto-approve: 확인 없이 인프라를 파괴합니다 (주의하여 사용해주세요!).\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_5.png)\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_6.png)\n\n## 상태 관리:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- terraform state list: Terraform이 관리하는 모든 리소스를 상태 파일에서 나열합니다.\n- terraform state show: 상태 파일에서 특정 리소스의 세부 정보를 표시합니다.\n- terraform state rm: 리소스를 Terraform 상태에서 제거하지만 공급자에서 파괴하지는 않습니다.\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_7.png)\n\n더 많은 정보는 여기에서 확인할 수 있습니다:\n\n## Workspaces:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- terraform workspace new: 새 워크스페이스를 만듭니다.\n- terraform workspace select: 기존 워크스페이스를 선택합니다.\n- terraform workspace list: 사용 가능한 모든 워크스페이스를 나열합니다.\n\n## 로그:\n\n테라폼 자체에는 전통적인 방식으로 로그를 볼 수 있는 내장 명령어가 없습니다. 그러나 환경 변수를 사용하여 테라폼의 로깅 동작을 제어할 수 있습니다. 다음은 테라폼 로그를 관리하는 방법입니다:\n\n## 로그 레벨 활성화 및 제어하기:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n- 테라폼은 TF_LOG 환경 변수를 사용하여 로그의 상세 수준을 제어합니다. 이를 다음 수준 중 하나로 설정할 수 있습니다:\n- ERROR: 오직 오류만 기록합니다 (기본값)\n- WARN: 경고 및 오류를 기록합니다\n- INFO: 정보 메시지, 경고 및 오류를 기록합니다\n- DEBUG: 자세한 디버그 정보를 기록합니다\n- TRACE: 가장 상세한 추적 정보를 기록합니다 (불안정한 형식)\n- 예시 (디버그 로그를 활성화):\n\n```js\nexport TF_LOG=\"DEBUG\"\nterraform plan\n```\n\n## 로그 파일 지정하기:\n\n- TF_LOG_PATH 환경 변수를 사용하여 테라폼이 로그를 작성할 특정 파일을 정의합니다.\n- 예시 (로그를 “terraform.log”에 작성):\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n```js\nexport TF_LOG_PATH=\"terraform.log\"\nterraform apply\n```\n\n## 셸 명령어로 로그 캡처하기:\n\n- 테라폼 명령어를 셸 기능과 결합하여 로그를 캡처하고 형식화할 수 있습니다:\n- 예시 (디버그 로그와 함께 플랜 출력 캡처):\n\n```js\nterraform plan -no-color 2>&1 | tee plan.log\n```\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n![이미지](/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_8.png)\n\n- 설명:\n  - no-color: 색이 없는 출력을 사용하여 해석을 쉽게 할 수 있습니다.\n  - 2>&1: 표준 출력(stdout)과 표준 오류(stderr)를 다음 명령어로 리디렉션합니다.\n  - tee plan.log: \"plan.log\"이라는 파일을 생성하고 캡처한 출력을 해당 파일에 기록합니다.\n\n## 기타 유용한 명령어:\n\n- terraform get: Terraform 모듈을 다운로드하고 설치합니다. (프로젝트 내의 모듈에 대해서)\n- terraform providers: 구성된 제공자에 관한 정보를 표시합니다.\n- terraform output: Terraform 구성에서 출력 값들을 표시합니다.\n- terraform version: Terraform 버전 정보를 표시합니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n## 추가 팁:\n\n- 자세한 도움말을 얻으려면 모든 명령어에 -help 플래그를 사용하세요 (예: terraform init -help).\n- 모든 명령어와 옵션에 대한 포괄적인 정보를 위해 공식 Terraform 문서를 참조하세요 https://developer.hashicorp.com/terraform/cli/commands.\n\n# 결론\n\nTerraform CLI를 숙달하고 중요한 명령어와 구성을 이해하면 인프라를 코드로 효율적으로 관리하고, 배포를 간소화하며, 확장 가능하고 재현 가능한 환경을 유지할 수 있습니다. 이는 인프라의 신뢰성과 민첩성을 향상시킬 것입니다.\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n감사합니다! 🙌🏻 구독하지 않고 CLAP 👏을 누르지 말고 잊지 마세요! 다음 기사에서 만나요.🤘\n\n# 저에 대해\n\n“안녕하세요! Joel O’Wembo입니다. AWS 인증 클라우드 아키텍트이자 백엔드 개발자이자 AWS 커뮤니티 빌더입니다. 저는 필리핀에 거주하고 있습니다 🇵🇭 클라우드 아키텍처, 데브옵스, 그리고 고가용성(HA) 원칙에 대한 깊은 이해력을 바탕으로 강력한 전문성을 제공합니다. 제 지식을 활용하여 고가용성을 갖춘 견고하고 확장 가능한 클라우드 응용프로그램을 효율적인 기업 배포를 위해 오픈 소스 도구를 사용하여 만듭니다.”\n\n저자(Joel O. Wembo)에 대한 더 많은 정보는 방문하십시오:\n\n<!-- ui-station 사각형 -->\n\n<ins class=\"adsbygoogle\"\nstyle=\"display:block\"\ndata-ad-client=\"ca-pub-4877378276818686\"\ndata-ad-slot=\"7249294152\"\ndata-ad-format=\"auto\"\ndata-full-width-responsive=\"true\"></ins>\n\n<script>\n(adsbygoogle = window.adsbygoogle || []).push({});\n</script>\n\n링크:\n\n- Linkedin: [https://www.linkedin.com/in/joelotepawembo/](https://www.linkedin.com/in/joelotepawembo/)\n- 웹사이트: [https://joelwembo.com](https://joelwembo.com)\n- 트위터: [https://twitter.com/joelwembo1](https://twitter.com/joelwembo1)\n- GitHub: [https://github.com/joelwembo](https://github.com/joelwembo)\n- 포트폴리오: [joelwembo.github.io](joelwembo.github.io)\n- Patreon: [https://www.patreon.com/joelwembo](https://www.patreon.com/joelwembo)\n\n# 참고 문헌\n","ogImage":{"url":"/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png"},"coverImage":"/assets/img/2024-05-18-TheGuidetoTerraformDevOpsTerraformCLICommandsandCheatSheet_0.png","tag":["Tech"],"readingTime":8}],"page":"99","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}